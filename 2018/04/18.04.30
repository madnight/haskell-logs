00:02:21 <cocreature> -j1 disables parallelism but iirc that’s the default for nix
00:02:33 <reactormonk> Is it possible to have overlapping type families?
00:05:40 <dminuoso> nshepperd: It looks as if the only reason they used lazy bytestrings is because they used `binary` for de/serialization
00:05:40 <pavonia> With closed type famlies you can, I think
00:06:39 <[exa]> woodson: if you're getting oom kill it should be in syslog/dmesg
00:06:58 * hackage dependency 1.0.0.0 - Dependency resolution for package management  http://hackage.haskell.org/package/dependency-1.0.0.0 (vmchale)
00:09:05 <dminuoso> I guess I could patch that to use binary-strict instead..
00:14:53 <piark_> hello
00:15:09 <liste> hi piark_
01:00:58 <epta> does docker sound like a good solution for running haskell console application on windows?
01:08:32 <statusbot> Maintenance update: restarting hackage server now... -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5ae6cce527ed461da7c8acfe
01:16:58 <statusbot> Maintenance update: Hackage is up & operational again. Thank you for your patience! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5ae6cce527ed461da7c8acfe
01:17:35 <pavonia> epta: Why do you need an additional wrapper for running Haskell application on Windows?
01:17:57 <ventonegro> I'm guessing POSIX
01:19:11 <Eduard_Munteanu> Docker is nice to have even on Linux environments, to make deployment easier.
01:19:22 <epta> posix, right
01:19:38 * Eduard_Munteanu wasn't aware Docker is a thing on Windows natively, though
01:23:39 <ventonegro> It spins up a Linux VM
01:24:26 * Eduard_Munteanu wonders if UML could work on Windows
01:44:04 <dminuoso> Given some `encode/decode` is it better to add in explicit TypeApplications for clarification, even when it's not necessary? https://gist.github.com/dminuoso/ba922b3f5a3ff7a6f3b948187c32a77b
01:44:32 <utdemir> I got a simple lens question. How do I apply two getters simultaneously, eg: (1, 2, 3, 4) ^. (_1 ??? _3) == (1, 3) ?
01:44:53 <utdemir> dminuoso: I prefer that, I think it makes it much clearer.
01:45:00 <merijn> dminuoso: I dislike TypeApplications in general, so I'm gonna go with "no"
01:45:57 <dminuoso> merijn: Oh right, you prefer completely explicit type annotations. :)
01:47:56 <jle`> dminuoso: it helps me
01:48:05 <jle`> it's the same reason why i use 'map' instead of 'fmap' whenever possible
01:48:26 <jle`> optimize for the future reader
01:48:36 <merijn> dminuoso: In that example I wouldn't annotate types at all,t bh
01:59:49 <reactormonk> Is there a way to have an overlapping associated type, or do I have to make an overlapping type family (if such a thing is even possible)
02:00:59 <merijn> reactormonk: I'm not sure what you mean by that?
02:03:06 <fishythefish> reactormonk: a type family does not have to be injective, if that's what you mean
02:03:36 <reactormonk> merijn, I'm doing a traversal over an hlist, and depending on which overlapping instance is picked, the type of the result is different.
02:04:39 <[exa]> utdemir: what about running 'both' on (_1, _3) ?
02:09:51 <fishythefish> [exa]: I thought `both` was for when the container is Bitraversable, not for pairing up traversals
02:10:58 <[exa]> (it was a first thought)
02:11:00 <Taneb> utdemir: there's lensProduct in Control.Lens.Unsound but you have to be careful that the targets of the lenses don't overlap
02:11:12 <Taneb> With getting it should be fine
02:26:42 * hackage weigh 0.0.8 - Measure allocations of a Haskell functions/values  http://hackage.haskell.org/package/weigh-0.0.8 (ChrisDone)
02:30:56 <strlnk2> Hello, I have been trying to get into GUI programming with Haskell but I've had issues with every single library I've tried (not compiling, not being able to set it up) - I clearly do not have the expertise to deal with these matters and would need to learn and invest time in this. However I am time-constrained, if you wanted to setup a sort of very simple GUI for your program, what would be the simplest approach you would take?
02:32:36 <capisce> strlnk2: http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html
02:32:48 <capisce> strlnk2: or using Qt bindings
02:57:14 <maerwald> python
02:59:12 <chorhizo> Hey, in this compilers unit I'm going to take they said I can do it in Haskell, but they won't be able to help me (it's usually done in C). Apparently it's a pretty brutal course so I'm not sure if it's such a good idea to do it in Haskell anymore... it's a C-style syntax we're creating
02:59:57 <chorhizo> but I've heard Haskell to build compilers is really good so maybe it would be alright slogging it on my own hmm
03:01:44 <merijn> chorhizo: It depends on how comfortable you are with Haskell
03:03:22 <tdammers> agree; if you'e super comfortable with Haskell, by all means do it; but some of the approaches you will be using will require some hoop-jumping in Haskell, particularly those that rely on mutable state a lot
03:04:33 <capisce> chorhizo: any techniques used in C should be translatable to Haskell fairly easily
03:04:47 <capisce> you don't necessarily need to use super-idiomatic Haskell
03:05:06 <capisce> but you can still get a lot of benefit from Haskell's stronger type safety and higher level abstractions
03:05:10 <chorhizo> merijn: tdammers: I guess I'm not super comfortable, I think I have a reasonable understanding up to and including monads, although I still havent used monads/monadic stuff that much in practice
03:05:58 <tdammers> chorhizo: you may be in for a rough ride then
03:06:06 <maerwald> tdammers: we love ST though :)
03:06:11 <capisce> and parsing C-style syntax is probably still a lot easier in Haskell than in C :)
03:06:12 <dminuoso> Well writing a compiler in C is a rough ride too..
03:06:26 <chorhizo> dminuoso: or so I've heard lol
03:06:34 <tdammers> maerwald: we do, but if you've never written any monadic code, then you probably aren't ready to translate idiomatic C into Haskell using ST
03:06:35 <dminuoso> Tokenizing/parsing is easy with flex/bison, but then the fun quickly stops.
03:06:36 <capisce> I'd definitely be more productive in Haskell
03:06:56 <dminuoso> Especially C is super frustrating because you have absolutely no abstractions.
03:06:59 <capisce> chorhizo: how familiar are you with C?
03:07:08 <chorhizo> very beginner knowledge of C
03:07:09 <chorhizo> lol
03:07:10 <maerwald> dminuoso: how is that frustrating? It's just a lot of work
03:07:16 <tdammers> sure, it's still a rough ride, but you'll get support from teacher / prof
03:07:22 <maerwald> and macros allow abstraction :P
03:07:22 <chorhizo> capisce: but they have 3 hour labs where they can help me
03:07:25 <dminuoso> maerwald: It's super easy to write a lot of spaghetti code.
03:07:33 <maerwald> in any language
03:07:37 <dminuoso> maerwald: C promotes it more than others.
03:07:42 <capisce> well, learning about ST in Haskell is probably less hassle than getting to a decent level in C without shooting yourself in the foot all the time
03:07:44 <maerwald> maybe, I am not sure
03:08:00 <chorhizo> I should mention, I am planning on doing my dissertation in haskell
03:08:04 <maerwald> I would C rather describe as "nice, but a waste of time", unless you really need that power
03:08:06 <chorhizo> which is 50% of the year
03:08:18 <chorhizo> so maybe doing it in haskell will help with that, too
03:08:28 <capisce> I'd argue Haskell gives you more power
03:08:35 <maerwald> not over low-level details, no
03:08:37 <capisce> C might give you more performance though
03:09:07 <maerwald> capisce: I found ST not to be that complicated
03:09:19 <capisce> nope, it's not complicated
03:09:20 <maerwald> State is more confusing imo :P
03:10:54 <capisce> in Haskell you might struggle getting some types to match, in C you'll struggle with segmentation faults
03:11:19 <maerwald> sure, C is debug-driven
03:11:25 <dminuoso> The difference is that Haskell gives you such errors up front
03:11:31 <dminuoso> In C you just have to *hope* that it will crash when you run it.
03:11:32 <capisce> but he would get a lot more guidance in C of course
03:11:35 <dminuoso> Or run valgrind a lot.
03:11:44 <maerwald> nah, most such errors are hidden behind the GHC runtime
03:11:58 <maerwald> and cannot happen in the first place
03:12:15 <chorhizo> so I guess it's just a bit of a risk
03:12:24 <chorhizo> if I hit a roadblock and get fucked, I fail the unit
03:12:31 <dminuoso> chorhizo: well you have the problem either way.
03:12:42 <maerwald> chorhizo: choose something you are comfortable with
03:12:47 <maerwald> not something "cool"
03:12:56 <dminuoso> chorhizo: It's just easier to shoehorn spaghetthi into a C compiler, breaking any and every principle to make things work kind of.
03:13:00 <maerwald> bad idea for a dissertation imo
03:13:12 * hackage weigh 0.0.9 - Measure allocations of a Haskell functions/values  http://hackage.haskell.org/package/weigh-0.0.9 (ChrisDone)
03:13:25 <chorhizo> maerwald: this isn't for the dissertation, haven't really decided on that yet.
03:13:51 <chorhizo> dminuoso: makes sense
03:14:39 <maerwald> mind you, haskell doesn't enforce program structure though, it just enforces types
03:15:01 <dminuoso> chorhizo: If you ever need inspiration, consider this (mostly) complete C compiler: https://bellard.org/otcc/otcc.c
03:15:21 <manjaroCinnamon> Hello everyone!
03:15:26 <chorhizo> In all fairness, I still have 5 months till university starts. I'm learning more Haskell every day so maybe I'll just wait and see how good I am by then.
03:15:44 <chorhizo> dminuoso: lmao
03:15:55 <chorhizo> code golf tier
03:15:57 <qqwy> A while back I read a paper that defined, in Haskell, datatypes to do vector, matrix and general tensor mathematics in a type-safe way
03:16:13 <qqwy> in such a way that if you used scalars or lower-dimension structures, they would automatically be promoted to the proper kind
03:16:20 <qqwy> to allow a certain operation to happen
03:16:35 <qqwy> (In a manner similar to what Matlab or R allow you to do)
03:17:00 <qqwy> I now unfortunately cannot find the paper again; I have no idea what this kind of feature is called
03:17:06 <dminuoso> chorhizo: And a version that produces an elf binary: https://bellard.org/otcc/otccelf.c
03:17:08 <dminuoso> =)
03:17:11 <qqwy> so I hope maybe someone here might remember it ^^'
03:17:12 * hackage weigh 0.0.10 - Measure allocations of a Haskell functions/values  http://hackage.haskell.org/package/weigh-0.0.10 (ChrisDone)
03:18:18 <chorhizo> dminuoso: I guess elf binary is it compiled?
03:18:18 <[exa]> chorhizo: most compiler courses are basically about "how do I survive fle&bison, SSA, see patterns for optimizations, and emit code". Doing the same in Haskell is trivial, and you'll lean to more tree-ish intermediates instead of standard BBs
03:19:16 <dminuoso> chorhizo: So a traditional C compiler would not produce a ready binary. In reality GCC only compiles into object files. It's then the linkers job to link them together into an executable format that your kernel can run.
03:19:43 <chorhizo> [exa]: I think they go into fairly complex details, as I've heard they provide us with a parser, and something to convert machine instructions to a binary or something
03:19:48 <dminuoso> (The object code too has to be in some specified format, which is usually ELF too)
03:20:15 <chorhizo> dminuoso: oh that makes sense, cool
03:20:20 <[exa]> chorhizo: btw what's the topic of your dissertation?
03:20:40 <chorhizo> [exa]: no idea, got a 'short' list of about 5 topics
03:20:45 <chorhizo> start my final year in Oct
03:21:42 * hackage weigh 0.0.11 - Measure allocations of a Haskell functions/values  http://hackage.haskell.org/package/weigh-0.0.11 (ChrisDone)
03:22:44 <[exa]> chorhizo: you're deciding on dissertation topic in the 3rd year of phd?
03:23:04 <chorhizo> [exa]: haha no, it's a bachelors dissertation
03:23:21 <[exa]> oh so. :D
03:23:25 <qqwy> [exa]: Yes, there is a very large lack of Parser Combinators in Compiler Constructions courses
03:23:27 <qqwy> or books, for that matter
03:24:08 <qqwy> The Dragon Book is still 'the guide', but it explains techniques of 30+ years ago, and only covers how to build a compiler in an imperative language that does not have higher-order-functions.
03:24:21 <[exa]> qqwy: it's even more frustrating when a decent miniature variant of Parsec can be put together in 50LoC and one Alternative instance
03:24:29 <qqwy> Indeed ^^'
03:24:51 <[exa]> aaaaand yes, dragon book, the thing obsoleted by LLVM
03:24:58 <[exa]> (and parsec)
03:24:59 <qqwy> I am very happy that when I followed the C++ course at my university, the teacher asked me because of my enthousiasm to explain how to build a Parser Combinator in C++
03:25:10 <qqwy> which was... possible, although somewhat verbose
03:25:20 <[exa]> lol
03:25:49 <qqwy> (C++14 solves a lot of that by (ab)using 'auto', and C++17 finally has proper product types and maybes support)
03:26:19 <[exa]> variadic templates yay
03:27:10 <qqwy> If you're interested: https://github.com/Qqwy/cc_pc/tree/master/final_example
03:27:10 <maerwald> there are parser combinators for C too
03:27:21 <qqwy> (It's far from perfect, of course)
03:27:38 <maerwald> https://github.com/abiggerhammer/hammer
03:28:04 <qqwy> maerwald: I know there is spirit for C++. In C I'd expect not being able to work with lambdas seriously hampers you. Unless you use nonstandard C that allows inline functions, of course
03:28:24 <qqwy> ooh! interesting!
03:28:51 <[exa]> qqwy: is there some reasonable way to overload the ';' in C++ better than what boost spirit did with >>'s ?
03:30:19 <MrLawrence> Hello, using this https://hackage.haskell.org/package/ncurses but have not managed to find any documentation, is there _really_ no documentation for this?
03:30:48 <[exa]> MrLawrence: you might want to use 'brick' package btw
03:31:34 <[exa]> MrLawrence: but the 'ncurses' API should iirc be 1:1 copy of ncurses' functions, which have their own manual
03:34:11 <[exa]> MrLawrence: btw this isn't satisfactory? https://hackage.haskell.org/package/ncurses-0.2.16/docs/UI-NCurses.html
03:39:21 <MrLawrence> ooh, thanks [exa] !
03:57:12 * hackage hailgun 0.4.1.7 - Mailgun REST api interface for Haskell.  http://hackage.haskell.org/package/hailgun-0.4.1.7 (cdepillabout)
04:06:52 <merijn> hmm, Map doesn't have a version of mapWithKey that lets me return Nothing to delete an element?
04:07:40 <merijn> Ah, mapMaybeWithKey
04:12:12 <qqwy> Back! :-)
04:14:55 <merijn> phadej: ping? with tree-diff how can I check if there's any actual differences?
04:16:27 <tomlambda> How do you get the Maybe b out of a ReaderT a Maybe b?
04:16:27 <qqwy> I think I remembered what the concept was called
04:16:31 <qqwy> 'Abelian Functors'
04:17:05 <qqwy> (The concept I refer to is automatic promotion of scalars/vectors/matrices to a higher order á la Matlab/R, and type-safe multiplication of these together)
04:17:15 <qqwy> Still unable to find the paper again though
04:17:47 <cocreature> tomlambda: runReaderT
04:17:56 <cocreature> tomlambda: but ofc you’ll have to supply the "a"
04:18:03 <qqwy> ... ah, I remembered it wrong
04:18:05 <qqwy> I found it again!
04:18:30 <merijn> Anyone know how I can restart an AppVeyor test build?
04:18:59 <qqwy> it is 'Naperian Functors'
04:19:28 <cocreature> qqwy: there is at least a paper with that name :)
04:19:36 <qqwy> https://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/aplicative.pdf
04:19:44 <qqwy> ^ that one is the paper I was referring to :-)
04:19:50 <qqwy> Very happy to have found it again ^.^
04:19:58 <tomlambda> cocreature - Thanks
04:21:08 <tomlambda> So am I right in saying that the shared environment is achieved within the readerT monad by nesting binds and then at the top level when function you run your computation through this environment and supply the shared context?
04:22:19 <hongminhee> Are there any recommended lints for styles (things like spacing and indentations)?
04:22:45 <qqwy> tomlambda: Yes :-)
04:22:45 <tomlambda> Also is ExceptT just an either where the plumbing to construct a Left and Right is taking care of behind the throwError and return functions?
04:22:52 <tomlambda> :)
04:23:11 <hongminhee> I've found tools like style canner and hstyle, all they look unmaintained for several years
04:23:21 <cocreature> tomlambda: well it’s the transformer version of Either
04:23:44 <merijn> hongminhee: Not really
04:24:02 <merijn> hongminhee: No one agrees on one universal style, so style linters tend to hardly see adoption
04:24:07 <qqwy> hominghee: Use spaces over tabs :P
04:24:09 * qqwy jokes
04:24:19 <merijn> hongminhee: hlint has some style comments, but not a lot, iirc
04:24:37 <hongminhee> yes, we're indeed already using hlint :-)
04:24:48 <merijn> I don't even use a consistent style, tbh. I use whatever looks best in a specific case
04:27:33 <tomlambda> Is there a version of note :: a -> Maybe b -> Either a b    which can be used to call throwError  or return in the context of a ExceptT based on the maybe?
04:28:23 <qqwy> Also, writing Haskell like this (https://files.slack.com/files-pri/T9897FQBS-FA38LLP36/103503) is fun, but don't overdo it :p
04:28:24 <merijn> tomlambda: That's just fromMaybe :)
04:28:45 <merijn> :t \x -> maybe (Left x) Right
04:28:46 <lambdabot> a -> Maybe b -> Either a b
04:28:48 <merijn> Eh, maybe I mean
04:28:51 <cocreature> protolude has a version of "note" that’s generalized to MonadError
04:29:47 <merijn> qqwy: You can't see that link without accounts/logging in
04:30:03 <merijn> I recommend using lpaste.net for sharing things
04:30:30 <qqwy> merijn: Oh, I did not realize
04:30:34 <qqwy> let me re-host it
04:31:03 <tomlambda> merijn - thanks!
04:31:32 <merijn> tomlambda: maybe and fromMaybe tackle about 90% of usecases for Maybe ;)
04:31:42 <qqwy> Hmm, this link should work: https://slack-files.com/T9897FQBS-FA38LLP36-5d4378edff
04:43:58 <JALSDKJALS> Hey guys, can somone tell me why my programm doesn't terminate on CTRL-C, the handler gets executed but the program doesn't end
04:43:58 <JALSDKJALS> https://pastebin.com/vC1ShrLa
04:44:52 <[exa]> JALSDKJALS: does the handler somehow cause the program to actually terminate?
04:45:15 <[exa]> if you catch SIGINT, there's no more SIGINT that would kill the program for you
04:45:53 <merijn> [exa]: His handler call exitSuccess, though
04:46:21 <merijn> JALSDKJALS: Have you double checked by explicitly sending SIGINT via "kill"?
04:47:14 <[exa]> ^C should do SIGINT correctly. anyway I see that exitWith only throws ExitCode and doesn't do actual exit()
04:47:36 <merijn> [exa]: Maybe his terminal is screwing up
04:47:53 <merijn> [exa]: And he doesn't appear to be catching ExitCode
04:47:57 <merijn> Oh!
04:48:02 <merijn> Actually, good catch
04:48:16 <[exa]> the point is, what catches ExitCode in interrupt handler?
04:48:29 <merijn> JALSDKJALS: THose handlers run in a totally independent thread, so the ExitCode exception doesn't ever kill the main thread, so it doesn't exit
04:49:18 <merijn> JALSDKJALS: Note that the docs in System.Exit explicitly say it has to be called from the main thread
04:49:20 <tomlambda> Is there a way to sequence function runExceptT on a bunch of functions that return ExceptT
04:49:35 <merijn> tomlambda: eh, sequence? :p
04:49:38 <tomlambda> *calls
04:49:38 <merijn> :t sequence
04:49:39 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
04:49:54 <tomlambda> haha
04:49:58 <JALSDKJALS> merijn: So what's the point of forever?
04:50:03 <JALSDKJALS> If you can't exit it
04:50:13 <tomlambda> Good question
04:50:23 <merijn> JALSDKJALS: You can, but only from the thread running it
04:51:10 <tomlambda> merijn - so in my case would m be a list of functions that return ExceptT
04:51:13 <Guest45048>  ANYONE WITH SENDER THAT ENTER INBOX OFFICE 365 WANNA TRADE GOOD DEAL
04:51:14 <Guest45048>  ANYONE WITH SENDER THAT ENTER INBOX OFFICE 365 WANNA TRADE GOOD DEAL
04:51:14 <Guest45048>  ANYONE WITH SENDER THAT ENTER INBOX OFFICE 365 WANNA TRADE GOOD DEAL
04:51:15 <Guest45048>  ANYONE WITH SENDER THAT ENTER INBOX OFFICE 365 WANNA TRADE GOOD DEAL
04:51:27 <JALSDKJALS> merijn: What would you recomment for a interuptable repl?
04:51:39 <JALSDKJALS> Sorry, my grammar is a bit off today
04:51:47 <cocreature> JALSDKJALS: note that GHC throws an exception on sigint by default
04:52:05 <JALSDKJALS> forever supresses it
04:52:10 <merijn> JALSDKJALS: Does not
04:52:27 <cocreature> the exception is thrown to your main thread, if you run forever in that it will kill it
04:52:28 <tomlambda> merijn - I think you may have given the wrong sequence
04:52:40 <merijn> JALSDKJALS: Anyway, I didn't bother testing it, but: http://lpaste.net/365399
04:52:48 <tomlambda> There are sequence instances in traversable and prelude
04:53:08 <merijn> tomlambda: You need to be more precise about what you want, then
04:53:31 <tomlambda> Yes that is my fault :)
04:54:11 <tomlambda> Although if I knew exactly the right questions to ask I wouldnt be a beginner
04:56:44 <pavonia> tomlambda: `ExceptT e m' is a monad. If all actions use the same `e' and `m', you can combine them using do-notation or other monad combinators
04:57:18 <pavonia> and call runExceptT on the final result
04:58:12 * hackage Network-NineP 0.4.3 - High-level abstraction over 9P protocol  http://hackage.haskell.org/package/Network-NineP-0.4.3 (SergeyAlirzaev)
05:10:34 <Bhailey> Hey
05:11:56 <ongy> got a gcc/ghc error in the assembler stage, anyone got an idea http://lpaste.net/365400 ?
05:13:00 <cocreature> ongy: https://ghc.haskell.org/trac/ghc/ticket/15068
05:14:02 <cocreature> ongy: afaik it’s only produces if you enable dwarf debug info, so as a short-term workaround you can disable that
05:14:09 <merijn> Anyone aware of a generic based pretty-printer?
05:14:27 <cocreature> merijn: pretty-show is not good enough?
05:14:28 <merijn> Or some way to nicely linewrap the output of show
05:14:52 <merijn> cocreature: Ah, maybe
05:25:27 <ongy> cocreature: what's the easiest way to do that?
05:25:47 <ongy> huh, removing -g it seems
05:25:52 <ongy> ok, that's easy. Thx for the pointer
05:58:43 <Bhailey> Hi Erstarrung
05:58:52 <Erstarrung> Hi
06:05:40 <Bhailey> What is the language you speak normally?
06:05:51 <Erstarrung> French
06:05:53 <Erstarrung> Why?
06:06:36 <MrLawrence> Hello guys, this snippet https://pastebin.com/raw/wwkCv02i does not seem to work but I can't figure out why, any thoughts?
06:08:33 <Bhailey> Your nickname sounds German
06:08:39 <merijn> MrLawrence: Because the result of applying 'head' to [a] is a value of type 'a' and you can't apply head to that
06:09:17 <Erstarrung> Bhailey, it does. It comes from a title of one of Schubert's Winterreise Lieder
06:09:21 <merijn> MrLawrence: You're *trying* to use 'head' first as "[[a]] -> [a]" and then as "[a] -> a", but that doesn't match the type of applyTwice
06:09:27 <MrLawrence> but I can do head (head [[1, 2], [3, 4]])
06:09:43 <Erstarrung> MrLawrence, yeah, because both usages of head will not have the same type signature in that case
06:09:43 <merijn> MrLawrence: applyTwice claims the function has type "a -> a", which head doesn't
06:10:05 <MrLawrence> I did play with the types though, and GHCi complained about it
06:11:42 * hackage colorful-monoids 0.2.1.1 - Styled console text output using ANSI escape sequences.  http://hackage.haskell.org/package/colorful-monoids-0.2.1.1 (minad)
06:12:44 <Bhailey> So you are a fan of Schubert?
06:13:07 <Erstarrung> I don't know if I'm a fan but I quite enjoy his collection of Lieder :p
06:13:33 <dminuoso> MrLawrence: `applyTwice :: forall a. (a -> a) -> a -> a` means, pick some type for `a`, substitute it in the type.
06:13:49 <dminuoso> MrLawrence: If you pick a ~ Int, then the type becomes (Int -> Int) -> Int -> Int
06:13:51 <Erstarrung> And they're well-written, vocally-wise, thus very pleasant to sing
06:14:03 <dminuoso> MrLawrence: If you pick String, then the type becomes (String -> String) -> String -> String
06:15:40 <MrLawrence> Well, I get that - but I don't get why this little code won't work https://pastebin.com/raw/Lxxp0St2
06:16:24 <dminuoso> MrLawrence: Let's pick a ~ Int for the same of argument.
06:16:25 <spruit11> Somehow it needs a type like (forall a. f a -> a) -> (f (f a)) -> a . Or something like that.
06:16:43 <spruit11> Neat.
06:16:58 <dminuoso> MrLawrence: so you get `f :: [Int] -> Int` right?
06:17:47 <dminuoso> MrLawrence: if `x :: [Int]`, then `(f x) :: Int` (by application of f), but how do you then apply `f` to an Int? You just said that `f :: [Int] -> Int`.
06:17:47 <spruit11> Like, does ([a] -> a) -> ([[a]] -> a) do it?
06:17:58 <fishythefish> spruit11: with RankNTypes you could give it (forall a. [a] -> a) -> [[b]] -> b
06:19:20 <MrLawrence> Thing is head takes [a] and that allows for [..] [[...] [[[...]]] and so on.
06:20:38 <fishythefish> yes, but what allows head to operate on all of those is that it has type `forall a. [a] -> a`, and when we invoke it, we choose what `a` to use
06:21:00 <MrLawrence> Mmm, why isn't that shown when I do :t head
06:21:04 <fishythefish> however, in applyTwice :: forall a. ([a] -> a) -> [[a]] -> a, you're choosing what `a` is *once* and using that for all subsequence invocations
06:21:17 <dminuoso> MrLawrence: The `a` is the same in the entire expression.
06:21:26 <dminuoso> MrLawrence: You have a single universal quantification over the entire type.
06:21:28 <dminuoso> That is
06:21:37 <fishythefish> MrLawrence: there's an implicit `forall` by convention
06:21:38 <dminuoso> forall a. ((a -> a) -> a -> a)
06:21:50 <dminuoso> forall a. (([a] -> a) -> [a] -> a)
06:22:01 <spruit11> ^ no
06:22:31 <spruit11> forall a. ([a] -> a) -> ([[a]]->a) ?
06:22:41 <fishythefish> spruit11: that's what he wrote
06:22:49 <spruit11> Oh right.
06:23:08 <dminuoso> MrLawrence: That is, sure `a` might itself be a list. But it also might not (!)
06:23:22 <dminuoso> MrLawrence: forall says "for every choice of `a`
06:23:42 <MrLawrence> So in the second application of head it assumes that the type `a` is [Num] and so when presented with [1, 2, 3] it can't take 1 as `a`?
06:24:19 <dminuoso> MrLawrence: Let's say `Int` for simplicity.
06:24:21 <fishythefish> not [Num], but essentially, yes
06:25:12 <MrLawrence> Right, so when I apply it in the interpreter like head (head [[1, 2], [3, 4]]) each head has a different conception of `a`.
06:25:30 <fishythefish> yup
06:26:35 <MrLawrence> So this applyTwice is only useful for types that don't deal with different types, roughly speaking
06:26:36 <dminuoso> MrLawrence: `head :: forall a. [a] -> a` during unification, the outer becomes implicitly `head @[Int]` and the inner becomes `head @[[Int]]` (assuming that type inference forced that (Num a => a) to be Int
06:26:53 <MrLawrence> Yeah , got it. Thanks.
06:27:02 <dminuoso> Actually wait thats wrong
06:27:05 <dminuoso> :t head
06:27:06 <lambdabot> [a] -> a
06:27:16 <dminuoso> MrLawrence: @Int and @[Int] respectively
06:27:19 <fishythefish> it's head@Int and head@[Int] but yeah
06:27:34 <fishythefish> (er, with spaces where needed)
06:28:03 <fishythefish> MrLawrence: you can make it work, but you need to enable RankNTypes
06:28:14 <fishythefish> the signature applyTwice :: (forall a. [a] -> a) -> [[b]] -> b would work
06:41:04 <zezeri> can anyone point me into the right direction? I am trying to combine two integer lists into one integer list and alterate each element, so that [1,2,3] and [4,5,6] combine into [1,4,2,5,3,6].  I started by doing combine list1 list2 = head(list1) : head(list2) : []  However that only works for the first 2 elements obiously. How can I combine this with recursion? can anyone point me in the right direction?
06:42:33 <tomlambda> How do we conditionally halt the computation and return an error if we are in a Do block and are binding the results of multiple calls to runExceptT
06:42:34 <dminuoso> zezeri: You could with the induction perspective: Start with the base case.
06:43:09 <zezeri> thank you, dminuoso, will try that :)
06:43:23 <dminuoso> zezeri: And then don't use `head` but rather use pattern matching
06:43:47 <dminuoso> zezeri: https://gist.github.com/dminuoso/d813339c8f12c1eb075042d8feffb78e
06:44:14 <tomlambda> Essentially I am trying to avoid staircasing when pattern matching on the either result of runExceptT within the do block
06:44:48 <dminuoso> zezeri: and then carefully consider how you want to treat situations when the lists are of different lengths, that is `zipping (x:xs) []` and `zipping [] (x:xs)`
06:48:12 * hackage palette 0.3 - Utilities for choosing and creating color schemes.  http://hackage.haskell.org/package/palette-0.3 (jeffreyrosenbluth)
06:56:41 <zezeri> fuse list1 list2 = (head(list1) : head(list2) : fuse (tail list1) (tail list2) )
06:56:45 <zezeri> my solution :)
06:58:42 <dminuoso> zezeri: now replace using `head` and `tail` by just pattern matching into x:xs and y:ys :)
06:59:03 <dminuoso> fuse (x:xs) (y:ys) = x : y : fuse xs ys
06:59:45 <zezeri> alright will look into this :D
06:59:53 <zezeri> this "x:xs" syntax et confuses me still a bit
06:59:55 <zezeri> need to read a bit more
07:00:14 <zezeri> thank you for all the input :)
07:00:25 <jchia_3> tomlambda: When you're in an ExceptT, doesn't throwError result in failing early, skipping the rest of the block?
07:01:13 <dminuoso> zezeri: A list [1,2,3] is actually just syntax sugar for 1:(2:(3:[]))
07:01:38 <dminuoso> zezeri: so x:xs matches a list constructed by some `x` prepended to `xs` using (:)
07:06:09 <jchia_3> If your multiple calls to runExcept T is combined into one, you will get the "early exit" effect
07:08:12 * hackage groot 0.0.1.0 - Command line utility to manage AWS ECS resources  http://hackage.haskell.org/package/groot-0.0.1.0 (alonsodomin)
07:10:55 <spruit11> > let id x = x in id
07:10:57 <lambdabot>  error:
07:10:57 <lambdabot>      • No instance for (Typeable p0)
07:10:57 <lambdabot>          arising from a use of ‘show_M316763653381040194213979’
07:11:10 <spruit11> Weird.
07:13:42 <Taneb> :t let id x = x in id
07:13:43 <lambdabot> p -> p
07:16:24 <EvanR> spruit11: normally, the error would be No instance for (Show (p -> p))
07:16:37 <EvanR> however in lambdabot
07:16:53 <EvanR> > show (\False -> True)
07:16:55 <lambdabot>  "<Bool -> Bool>"
07:17:10 <EvanR> it works when Typeables are involved
07:19:43 <spruit11> Ah.
07:21:12 * hackage ekg-carbon 1.0.10 - An EKG backend to send statistics to Carbon (part of Graphite monitoring tools)  http://hackage.haskell.org/package/ekg-carbon-1.0.10 (OliverCharles)
07:26:42 * hackage ekg-bosun 1.0.13 - Send ekg metrics to a Bosun instance  http://hackage.haskell.org/package/ekg-bosun-1.0.13 (OliverCharles)
07:27:42 * hackage relational-query 0.11.1.0 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.11.1.0 (KeiHibino)
07:29:03 <griffin> Does anyone know when there's likely to be an LTS stackage with GHC 8.4?
07:29:53 <fr33domlover> Hi I have a question about URI parsing not specific to Haskell but maybe someone knows? I have a URI that looks like this: scheme:x/..// i.e. a rootless path, if I resolve-dot-segments I get: scheme:/   which has a path with 2 empty segments but it's not really an absolute path with a single empty segment, so the meaning of the URI has changed? I'll closely follow the RFC's algorithm to check what it does in
07:29:55 <fr33domlover> this case, just interesting that this case is not mentioned anywhere (empty segments are allowed and have a distinct meaning and must not be removed before removing-dot-segments) just wondering if anyone else ever thought of this :p
07:30:26 <fr33domlover> s/not really/now really
07:31:12 * hackage psqueues 0.2.7.0 - Pure priority search queues  http://hackage.haskell.org/package/psqueues-0.2.7.0 (JasperVanDerJeugt)
07:52:12 * hackage diff3 0.3.1 - Perform a 3-way difference of documents  http://hackage.haskell.org/package/diff3-0.3.1 (OliverCharles)
07:54:28 <JayKobe6k> Is there an article somewhere about common pitfalls when working with attoparsec? I managed to write a parser that never terminates, and I have no idea where to start
07:55:21 <cocreature> JayKobe6k: not sure about an article but if you show us the code we might be able to help
07:56:06 <JayKobe6k> cocreature: I'm trying to parse a subset of regex: https://github.com/Jacoby6000/FunCheck/blob/fdaeb4db079840460a1a3c7667999e7425fcb08c/parse-regex/src/FunCheck/Parse/Regex.hs
07:56:14 <JayKobe6k> Right now I'm fine with a naive implementation
08:00:33 <cocreature> JayKobe6k: how can I reproduce the looping parser?
08:04:30 <Gobert> hey guys im exporting three modules and GHC complains and says `The export item <module-name> exports nothing`
08:05:07 <Gobert> one of the three modules has `()` after its module name like `module Blah () where`
08:06:32 <JayKobe6k> cocreature: http://lpaste.net/365405
08:08:05 <cocreature> JayKobe6k: that produces "Partial _" rather than an infinite loop
08:08:27 <Gobert> what does `()` mean in a module name and where can I read up on it?
08:09:09 <cocreature> Gobert: "import ModuleName ()" means that you don’t want to import any identifiers from ModuleName so the only thing that will be imported are instances
08:09:12 * hackage simple-smt 0.8 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.8 (IavorDiatchki)
08:09:31 <JayKobe6k> cocreature: if you're on master, that's because I remoeved the looping parts in the master branch for some reason. You gotta go 2 commits back
08:09:34 <Gobert> cocreature: It seems when I try to re-export that module, ghc is saying I'm exporting nothing
08:10:12 <cocreature> Gobert: well if you aren’t importing any identifiers, then there is nothing to reexport
08:11:25 <cocreature> JayKobe6k: two commits back is 8dee21d62b248c0090a60cb9e83c8ac8f0c1b473 which doesn’t even compile
08:11:28 <Gobert> cocreature: ah so the dodgy-exports pragma is just doing its job
08:11:42 <Gobert> and it's not necessarily a bad export
08:11:47 <JayKobe6k> you need this commit fdaeb4db079840460a1a3c7667999e7425fcb08c
08:12:07 <cocreature> Gobert: well it’s a useless export
08:12:12 * hackage plot-light 0.3.3 - A lightweight plotting library, exporting to SVG  http://hackage.haskell.org/package/plot-light-0.3.3 (ocramz)
08:12:29 <Gobert> cocreature: so what should/can I do instead?
08:12:51 <Gobert> I'm removing autoexporter from a codebase
08:13:05 <cocreature> Gobert: depends on what your goal is? you could actually include some identifiers in the import list
08:13:12 * hackage smtLib 1.0.9 - A library for working with the SMTLIB format.  http://hackage.haskell.org/package/smtLib-1.0.9 (IavorDiatchki)
08:13:15 <cocreature> or just remove the module
08:13:35 <fr33domlover> I checked the URI RFC algorithm and indeed the dot segment removal entirely changes the meaning of the URI that's weird
08:14:01 <tomlambda> What do you guys think of this code I tried to improve it after the last round of feedback from here ... http://lpaste.net/365406
08:14:11 <fr33domlover> scheme:/x/..///y    beecomes scheme://y    i.e. y was in the path but now y is the authority (domain name)
08:15:05 <Gobert> cocreature: when you say a useless export
08:15:17 <Gobert> cocreature: could you elaborate a little more?
08:15:50 <cocreature> Gobert: it’s literally just that, reexporting a module that you imported with an empty import list is equivalent to not reexporting it
08:17:06 <Gobert> cocreature: there are a bunch of instances in that module, how does one access them if you don't reexport them?
08:17:21 <cocreature> instances are implicitely exported
08:19:42 <cocreature> JayKobe6k: the problem is orParser, andParser and opt. each of them recurses on regex without consuming any input so you get an infinite loop of regex -> lit -> orParser -> regex -> …
08:19:52 <JayKobe6k> ah
08:20:35 <Gobert> cocreature: so therefore all you need to do is import the module with the instances, but you don't need to explicitly list it in`module Some module (moduleA, moduleB) where`
08:20:47 <cocreature> Gobert: yep
08:21:00 <Gobert> cocreature: thank you, would this be in the GHC docs?
08:21:09 <cocreature> dunno
08:21:29 <cocreature> instances are best thought of as global things of which you can’t control visibility
08:21:56 <cocreature> that’s not entirely true if you use orphan instances (which is one reason why those are frowned upon) but it’s still a good mental model
08:22:33 <isovector> hey all -- just published a ghc proposal to allow type applications for overloaded literals: https://github.com/ghc-proposals/ghc-proposals/pull/129
08:22:37 <isovector> would love to hear feedback!
08:25:34 <cocreature> isovector: nice! “If accepted, I (isovector) who will implement the change.” you should probably remove the “who” in that sentence
08:26:14 <isovector> good catch
08:26:29 <JayKobe6k> cocreature: any advice for how to solve my problem?
08:29:34 <cocreature> JayKobe6k: I’d probably use https://hackage.haskell.org/package/megaparsec-6.5.0/docs/Text-Megaparsec-Expr.html#v:makeExprParser for this. if you want to implement this manually (or have to because you can’t switch away from attoparsec which doesn’t provide this iirc) then you have to factor your grammar such that you avoid recursing without consuming input
08:30:29 <JayKobe6k> cocreature: Alright, I'll look in to it.. Alternatively, if there's a regex parser already out there which has a simple structure I could just use the existing one
08:30:47 <cocreature> not sure if there is any, sry
08:30:48 <JayKobe6k> I couldn't find anything that didn't seem overly complicated though
08:30:56 <JayKobe6k> aight, no problem
08:30:59 <EvanR> why does it need to be simple
08:31:08 <EvanR> as opposed to working on a large class of regex
08:31:45 <JayKobe6k> I just want something which provides me the regex AST
08:32:01 <JayKobe6k> without a bunch of extra cruft
08:33:41 <EvanR> yeah i just made an expression parser with megaparsec, wasn't bad
08:34:23 <dminuoso> Is there some easier trick to "partially apply" the second argument than `signing = flip sign (getSecret c)`?
08:34:36 <JayKobe6k> cocreature: megaparsec definitely looks like a better fit, based on their readme
08:34:40 <dminuoso> Or should I just write my own `sign' = flip sign` and then use `sign' (getSecret c)` ?
08:34:42 <JayKobe6k> thanks for the headsup
08:36:55 <cocreature> dminuoso: (`sign` getSecret c)
08:57:34 <byorgey> shapr: ah!  I totally forgot I put mustardwatch in that assignment.  I think at the time I *thought* I was referencing Alice in Wonderland (to go with the theme of the assignment).
08:58:06 <byorgey> shapr: but as now established, there is no mustard watch in Alice in Wonderland, only a butter watch
08:58:24 <cheater> hi
08:58:35 <byorgey> hi cheater
08:58:43 <cheater> when using tasty, is it possible to only run one specific test? or to have it list all tests and exit without running them?
08:59:06 <merijn> cheater: Yes, and yes
08:59:13 <merijn> cheater: Try running your test executable with -h
08:59:33 <cheater> i can't, i uh, the way it's done we get ghci and we run a function in that
08:59:45 <cheater> basically main
08:59:55 <merijn> cheater: I dunno if it's supported that way
09:00:03 <cheater> and main calls out to defaultMainWithIngredients
09:03:28 <Meo2aing> How would you write in point-free style the following function:
09:03:28 <Meo2aing> foo x y = if bar? x then qux y else if bar? y then qux x else frob
09:04:01 <habolabo> ...
09:04:31 <cheater> uhm... is it possible to set argv when i'm in IO?
09:04:36 <Meo2aing> So if the predicate is true for the LEFT arg, then we apply a function to the RIGHT arg, and vice versa. I can't come up with a succinct point-free version.
09:06:21 <spruit11> There's an expression to point-free-style compiler somewhere on the webs.
09:07:08 <spruit11> http://pointfree.io/
09:07:14 <Meo2aing> spruit11: I'm not sure it will output an optimal version though (unless I've missed something and they got strong AI working :P)
09:07:35 <Meo2aing> but thanks for the pointer, I'll try that
09:19:24 <EvanR> set argv? o_O
09:26:43 <lyxia> @pl foo x y = if bar x then qux y else if bar y then qux x else frob
09:26:43 <lambdabot> foo = ap (ap . (. qux) . if' . bar) (flip flip frob . flip (if' . bar) . qux)
09:27:01 <lyxia> that looks so good.
09:27:13 <barrucadu> flip flip frob
09:27:26 <EvanR> tgf if-then-else syntax
09:27:29 <thebnq> :t if'
09:27:30 <lambdabot> error:
09:27:31 <lambdabot>     • Variable not in scope: if'
09:27:31 <lambdabot>     • Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
09:27:51 <byorgey> How would I write that in point-free style?  I wouldn't.
09:28:45 <thebnq> what if' is that referring to?
09:29:00 <EvanR> :t bool
09:29:01 <lambdabot> a -> a -> Bool -> a
09:37:59 <dminuoso> :t frob
09:38:00 <lambdabot> error:
09:38:00 <lambdabot>     • Variable not in scope: frob
09:38:00 <lambdabot>     • Perhaps you meant ‘from’ (imported from Control.Lens)
09:38:04 <dminuoso> Oh heh.
09:38:19 <dminuoso> :t flip flip
09:38:20 <lambdabot> b -> (a -> b -> c) -> a -> c
09:39:28 <undefbeh> anyone here working on haskell professionally? I mean getting paid for it?
09:39:46 <dminuoso> Im getting paid for it, but Haskell is not in my job description.
09:40:00 <dminuoso> Or do you mean working on GHC?
09:40:28 <undefbeh> I dont know. I honestly dont find a reason to learn haskell because its jobs are very low
09:40:31 <undefbeh> in quanityt
09:40:34 <undefbeh> quantity*
09:40:50 <mnoonan> lots of people here use it professionally (myself too)
09:41:06 <undefbeh> haskell or something that requires haskell?
09:41:30 <undefbeh> like python jobs are mostly towards either pure python (scripting) or web development (flask etc.)
09:41:32 <EvanR> there is a good reason to learn haskell even if you dont think you can get a dedicated job using it
09:41:36 <mnoonan> I'm not sure what you mean?
09:41:42 <undefbeh> EvanR: such as?
09:41:57 <habolabo> undefbeh: have you learned to eat?
09:42:06 <undefbeh> nope
09:42:08 <undefbeh> natural
09:42:09 <undefbeh> :D
09:42:37 <thebnq> some people say they learn language X better because they learnt haskell
09:42:39 <dminuoso> undefbeh: I think learning Haskell improves your skills as a developer in general, even if you don't use it professionally.
09:42:46 <EvanR> haskell helps you reason about programming more precisely, you will have more confidence that what you wrote will work. haskell could be thought of training wheels for this because the type system tells you where you went wrong
09:42:49 <undefbeh> honestly I am 23 and I cant live off my parents money anymore. I need to get decent job in programming. I was researching for languages to learn and haskell showed up
09:42:53 <boxscape> if a case cannot happen because of the types, but GHC doesn't know it, is the canonical way to handle this to lits the case anyway and make it produce a descriptive error?
09:42:56 <EvanR> when you move to python, you take the training wheels off
09:43:00 <undefbeh> dminuoso: but its functional right
09:43:01 <boxscape> s/lits/list
09:43:10 <EvanR> but now you know how to ride
09:43:17 <dminuoso> undefbeh: Yes. Functional paradigms are (re-)visiting popular languages nowadays for good reason.
09:43:31 <undefbeh> EvanR: nice perspective
09:43:50 <undefbeh> so I should learn haskell before python?
09:43:52 <undefbeh> correct?
09:43:56 <EvanR> ive noticed a lot of people start with dynamic languages, and after many years still write failing code
09:43:59 <dminuoso> undefbeh: Depends on what your goal is really.
09:44:02 <EvanR> hence the whole test paradigm
09:44:03 <dminuoso> undefbeh: I'd say learn both.
09:44:19 <undefbeh> but I wanna earn. earning good is my end goal dminuoso
09:44:24 <dminuoso> undefbeh: In whatever order you prefer. I think learning Haskell earlier is better because it tends to be harder the more "traditional" languages you have picked up
09:44:34 <undefbeh> ah I see
09:44:51 <undefbeh> so it will help me in learning C and python later on right?
09:44:59 <EvanR> reasoning precisely is hard
09:44:59 <dminuoso> Not so much for C actually.
09:45:03 <undefbeh> or it will be useless due to its nature (dynamic vs functional)
09:45:11 <EvanR> but you have to do it no matter what language oyu use
09:45:12 <mnoonan> tbh you might not appreciate some of the benefits of haskell until you've been bitten badly by bugs in nasty c++ or python codebases :|
09:45:12 <undefbeh> why not for C?
09:45:20 <dminuoso> undefbeh: It will be quite helpful because you will approach problems differently.
09:45:39 <dminuoso> undefbeh: Well C's very nature is the extreme opposite of almost anything what Haskell is about.
09:45:47 <undefbeh> haskell has good future like python?
09:45:53 <undefbeh> python demand is increasing day by day
09:45:59 <xaxaac> C is stupid
09:46:05 <EvanR> i have managed to go back to C and program like its haskell, as much as is possible :)
09:46:10 <undefbeh> dminuoso: I dont wanna learn C for coding. wanna learn it to find bugs haha
09:46:36 <undefbeh> C++ or java is where I will be coding professionally.
09:46:37 <mnoonan> if you're just looking for maximizing job prospects, it seems like you should learn javascript. *shrug*
09:46:40 <undefbeh> instead of C
09:46:41 <thebnq> you need to learn C to understand computation in reality
09:46:50 <undefbeh> mnoonan: yea I was thinking about that
09:47:07 <EvanR> haha C and reality
09:47:20 <EvanR> it literally runs on the C virtual machine
09:47:24 <dminuoso> undefbeh: Another aspect is, the reason I can write Haskell professionally is because I have convinced my boss to try it out. So basically Im creating a Haskell job in a place where there was none.
09:47:35 <undefbeh> what distro / OS do you guys use to code in haskell (whats your main OS)? and preferred OS.
09:47:40 <dminuoso> undefbeh: So that's another aspect - it has a lot of good aspects that make it viable to introduce it into existing companies.
09:47:48 <EvanR> undefbeh: OSX
09:47:50 <undefbeh> dminuoso: haha nice
09:48:41 <dmj`> undefbeh: NixOS
09:48:45 <undefbeh> nice. it seems like I need to spend a lot of money for macbook. I get a lot of recommendations for macbook for coding
09:48:56 <dminuoso> Macbooks suck, but they are still the best there is.
09:48:58 <undefbeh> dmj`: cool. did you try arch ?
09:49:13 <undefbeh> dminuoso: do you use windows?
09:49:22 <exarkun> apple is probably about 10 minutes away from abandoning the desktop altogether
09:49:32 <EvanR> good windows books are also expensive
09:49:32 <dminuoso> undefbeh: No I use a macbook. Im quite annoyed by a lot of things, but it's less frustrating than Windows or Linux machines.
09:49:35 <dmj`> undefbeh: yea, better haskell experience on nixos than arch imo
09:49:52 <undefbeh> dmj`: I have used arch. for like 2 years ++
09:50:00 <undefbeh> would you recommend me switching to nixOS?
09:50:29 <dmj`> undefbeh: I can’t speak for anyone else but myself, but I’ve found using a macbook pro and ssh’ing into a nixos machine to be ideal.
09:50:38 <undefbeh> why better experience thou? just curious
09:51:06 <dmj`> undefbeh: simpler setup, haskell package infra on nixos is heavily used as well.
09:51:12 * undefbeh after seeing every haskell developer using macOS, feels like getting macbook would be the right choice.
09:52:02 <EvanR> its really good for many other things too
09:52:14 <EvanR> worth the investment
09:52:19 <undefbeh> so there goes my 10 months of saving
09:52:26 <undefbeh> for a macbook i5
09:52:33 <exarkun> undefbeh: you'd really do just fine with a used thinkpad and pretty much any linux distro
09:52:36 <EvanR> hopefully your macbook can earn you the 10 months of savings back in 1 month
09:52:42 <cheater> when using tasty, is it possible to only run one specific test? or to have it list all tests and exit without running them? someone suggested running the test with -h, but that doesn't display anything actually.
09:52:48 <exarkun> undefbeh: you're going to have frustrations no matter what you pick
09:52:51 <ddellacosta> can someone help me understand what super-basic thing I'm doing wrong here that I don't understand? http://lpaste.net/365411
09:52:57 <undefbeh> exarkun: really? if so, It would be great since money is really tight on me
09:53:36 <exarkun> undefbeh: and the fact that trendy bay area developers like to show off how much money they make by buying the latest apple gadget 3 times a year only means that owning a macbook will give you the external appearance of being a gainfully employed developer, it won't actually make you one
09:54:22 <undefbeh> haha nice one
09:54:23 <EvanR> appearances can be good
09:54:29 <undefbeh> exarkun: what distro are you using ?
09:54:55 <exarkun> undefbeh: ubuntu, primarily out of laziness (which is often a pretty good reason)
09:55:05 <undefbeh> exarkun: tried arch?
09:55:07 <exarkun> as I said, you will have problems no matter what you pick.  ubuntu certainly has its fair share.
09:55:20 <exarkun> no, I've never owned a machine with arch installed.
09:55:27 <undefbeh> exarkun: which DE?.
09:56:11 <EvanR> now for kicker, to learn haskell you dont need to buy all this stuff
09:56:26 <EvanR> lets get started.. and on topic! :)
09:56:27 <undefbeh> and also to develop professionally?
09:56:37 <exarkun> undefbeh: whatever canonical randomly picks as the default
09:56:50 <undefbeh> exarkun: using it inside a VM?
09:57:12 * hackage nix-diff 1.0.2 - Explain why two Nix derivations differ  http://hackage.haskell.org/package/nix-diff-1.0.2 (GabrielGonzalez)
09:57:26 <exarkun> undefbeh: ... no?
09:58:16 <undefbeh> so yeah.. EvanR its time to learn haskell
09:58:22 <EvanR> ^
09:58:31 <dminuoso> undefbeh: All you need is GHC (maybe through stack), and a good book.
09:58:34 <EvanR> truer words were never spoken
09:58:50 <undefbeh> what IDE / text editor would you recommend me for haskell (your preferred one?)
09:59:02 <exarkun> whichever you are comfortable with
09:59:03 <undefbeh> dminuoso: recommend me good guides / books pleasae
09:59:11 <undefbeh> I am comfortable in vim
09:59:17 <exarkun> great, go with that
09:59:18 <dminuoso> undefbeh: CIS 194 seems to be highly regarded in this channel (and free)
09:59:29 <dminuoso> undefbeh: http://www.seas.upenn.edu/~cis194/fall16/
09:59:32 <undefbeh> I see
09:59:33 <mnoonan> does anybody know off the top of their heads when "Monoid a => Monoid (IO a)" was added?
09:59:35 <undefbeh> thanks a lot!
09:59:42 <dyl> Discussion question: why is Haskell not a good application scripting language?
10:00:00 <dyl> I’m not sure myself but I would rather have a Python, Lua, or Scheme scripting extension.
10:00:20 <dyl> It seems like the problem is that Haskell often requires a lot of “machinery setup” by way of types and definitions.
10:00:20 <exarkun> dyl: Because familiarity?
10:00:23 <EvanR> what is scripting
10:00:24 <dyl> Ehhh
10:00:43 <dyl> Leta say you have a complex C/C++ application which vends a scripting interface.
10:00:44 <exarkun> Yea.  Python happily lets you write something that's 10% broken.
10:00:46 <dyl> For automation purposes.
10:01:09 <exarkun> Maybe "scripting" is defined as "a program that it's okay if it's broken"
10:01:15 <EvanR> maybe youre asking about a DSL
10:01:17 <dyl> So you’re working with something where nearly EVERYTHING is mutation, and you probably have a single line prompt
10:01:21 <dyl> No, I’m not,
10:01:29 <dyl> and I’m not talking about in a new system.
10:01:47 <EvanR> a small language specifically for programming a subsystem, not for creating a whole app that runs on an OS
10:01:50 <dyl> I’m talking about in an existing system that has scripting tacked on by exposing routines to a higher level language.
10:01:51 <nshepperd> i think embedding haskell in an application is nontrivial
10:02:02 <dyl> That too, but beyond that
10:02:11 <nshepperd> lua is easy, it's just a library, so people do it a lot
10:02:11 <dyl> I don’t feel the entire ML family is suited to this purpose.
10:02:21 <dyl> I love ML family languages but there are places they’re not ideal.
10:02:34 <EvanR> well, the compilation model gets in the way of doing dynamic loading of code
10:02:38 <dyl> Probably the best case I’ve seen of this was embedded Guile.
10:02:47 <dyl> (With optional Python.)
10:02:59 <dminuoso> dyl: Why not just accept a bytestring and jmp right into it? Requires no interpreter at all!
10:03:02 <EvanR> so, maybe scripting is a bad word for obscuring the need to do dynamic loading of code
10:03:15 <dyl> Lisp’s Ball-of-Mud syntax model is a lot more flexible in this use case.
10:03:22 <dyl> Eh, I don’t think so EvanR
10:03:26 <dminuoso> (Also I promise it's very portable outside of Java)
10:03:35 <EvanR> i really dont see syntax as the issue
10:04:05 <EvanR> if we dont like the huge preamble to set something up in the module in haskell, thats the DSL thinga gain
10:04:12 <EvanR> haskell syntax for the program itself is great
10:04:42 <EvanR> we just dont have the proper environment  to run the program in
10:04:52 <nshepperd> I think haskell would be a great scripting language for an application, but i've never done it because embedding ghc is big effort
10:04:54 <dyl> Yes.
10:05:04 <dyl> It could be, but it would require a lot of work.
10:05:07 <EvanR> and dynamic loading is not happening
10:05:08 <dyl> It would be a very thick layer.
10:05:18 <nshepperd> and making libraries available and stuff
10:05:21 <dyl> Whereas with Python or Scheme you can just expose C FFI stubs.
10:05:24 <dyl> And call it a day.
10:05:37 <dyl> See: Blender, coot, etc...
10:05:52 <EvanR> they have better dynamic loading
10:06:03 <dyl> I’m not sure what you mean by that..?
10:06:19 <dyl> I’m not confident I know, rather. I think I do.
10:06:25 <dyl> Can you clarify?
10:06:43 <EvanR> i'm saying the same thing you are
10:07:00 <EvanR> or what nshepperd is saying, better embedding
10:07:24 <EvanR> not because of the language itself i think, just the implementation
10:17:04 <ddellacosta> (trying again 'cause I think I asked at a bad time) can someone help me understand what super-basic thing I'm doing wrong here that I don't understand? http://lpaste.net/365411
10:18:09 <glguy> ddellacosta: area :: e -> Double, but your implementation on line 9 doesn't necesarily return a double
10:18:37 <ddellacosta> I tried with type variables in place of Double too and got the same thing though
10:18:42 <ddellacosta> (see commented code)
10:18:59 <ddellacosta> sorry, ignore the line with `Shape` in it, that was another experiment
10:19:05 <jle`> ddellacosta: that's a different problem too
10:19:09 <jle`> if area :: e -> b
10:19:13 <glguy> Replacing it with a variable wouldn't help, that means it has to produce a type that it doesn't know anything about
10:19:14 <jle`> then that means that area can return a value of *any* b
10:19:24 <ddellacosta> ah, okay, just must have been similar enough that I thought it was the same error
10:19:27 <jle`> that's what the type `e -> b` means
10:19:36 <ddellacosta> jle`: okay that makes sense, and actually that's why I figured making it `Double` would solve it
10:19:43 <jle`> it can be instantiated with any e or any b
10:19:56 <ddellacosta> so okay I think I get it--because in the actual instance it's still more general than `Double` it won't work, huh? Per glguy's point
10:20:19 <ddellacosta> whereas if I make it too general (in the class definition) it's also a problem
10:20:37 <jle`> ddellacosta: what's the type of `area` for (Circle r) ?
10:21:07 <ddellacosta> yeah actually, I think for the purposes of this little example I'd make it double, so like `(Circle r) -> Double`, ideally
10:21:53 <pavonia> ddellacosta: Think about what would happen if the caller passes a value of type Circle [String]
10:22:04 <ddellacosta> so I was hoping I could represent this in the class definition as something like `(Shape s) -> Double`, or actually (ideally) `(Num b) => (Shape s) -> b`
10:22:40 <ddellacosta> pavonia: right okay...that's helpful. So I need to make `Circle`'s type more concrete too for this to make sense huh
10:22:46 <jle`> ddellacosta: you can still write a `Circle r -> Double`
10:22:51 <jle`> if you have some constraints on the 'r'
10:23:00 <jle`> it looks like you already have constraints on the 'r' anyway
10:23:07 <ddellacosta> jle`: in the instance def?
10:23:07 <jle`> since you use 'pi', which requires a Floating constraint
10:23:14 <ddellacosta> ah right
10:23:46 <jle`> so your instance is really already Floating r => Shape (Circle r)
10:23:56 <ddellacosta> right, gotcha
10:24:03 <jle`> if you bump it up to RealFloat r => Shape (Circle r) then you can use realToFrac
10:24:25 <ddellacosta> okay cool--thanks jle`, glguy, pavonia, I see now where I was fuzzy
10:24:41 <ddellacosta> will go back to the drawing board and play with this more
11:17:15 <hololeap> i'm reading Parallel and Concurrent Computing in Haskell, and i'm the applications for GPU, multi-computer, and cloud computing (but i'm pretty unfamiliar with these and the jargon surrounding them)... can anyone tell me the latest state of development of haskell in these areas? i came across Glasgow Distributed Haskell, but the page for it seems really old
11:17:28 <hololeap> s/i'm the/i'm interested in the
11:20:16 <Cale> hololeap: The latest stuff related to distributed computing in Haskell is probably the Cloud Haskell stuff
11:20:40 <Cale> (distributed-process and its related packages)
11:21:27 <Cale> https://wiki.haskell.org/Cloud_Haskell -- there are links to a bunch of info here
11:21:32 <Cale> https://skillsmatter.com/skillscasts/3523-cloud-haskell -- this talk is really good
11:21:53 <Cale> (unfortunately you have to log in to watch it, but accounts are free)
11:22:48 <hololeap> Cale: cool, thanks. that's a lot of good info
11:23:16 <Cale> I don't know if this stuff has any commercial users
11:23:37 <Cale> But it looks pretty cool anyway
11:24:34 <Cale> hololeap: As for SMP concurrency and parallelism, the story there is much more stable
11:25:48 <Cale> (and the book you already found will tell you about it)
11:26:02 <Cale> For GPU programming, perhaps check out http://hackage.haskell.org/package/accelerate
11:29:08 <hololeap> interesting... it would be cool if all of these technologies could have a unified interface
11:30:34 <Cale> They're different enough that I'm not sure that really makes sense.
11:31:55 <Cale> But Accelerate for example, has a number of backends
11:32:40 <Cale> as does distributed-process -- but since the applications and the kinds of problems you'll have to cope with are very different in each, it doesn't necessarily make sense to unify them
11:33:32 <Cale> For example, you don't usually worry about what happens when GPUs disappear in the middle of running your program, but for a distributed application, you definitely want to deal with the case of servers dropping / loss of network connectivity.
11:34:24 <Cale> But perhaps if you have access to remote GPUs, you could use the two things together.
11:35:53 <hololeap> i see
11:38:18 <Hafydd> I would like my program to keep running if the CPU disappears.
11:41:02 * [exa] thinking about the ways to 'disappear' a CPU
11:42:09 <XorSwap> pull it out
11:43:34 <hololeap> just wrap it in a Maybe
11:47:42 <[exa]> traditional computing :: CPU. Parallel computing :: [CPU]. Distributed computing :: [Maybe CPU]. Quantum computing :: Either CPU (CPU -> Void)
11:51:39 <hololeap> was the last one not supposed to make sense?
12:08:21 <crestfallen> hi I'm confused by how this subsequences func evaluates. true to form I'm trying to write out by hand the output. the concat always throws me off in a recursion https://ptpb.pw/xXRS  please see what I'm trying to write out
12:09:53 <[exa]> crestfallen: map (x:) prepends x to _all_ elements of the list
12:11:09 <newsham> > map (100:) [[1,2],[3],[4,5,6]]
12:11:11 <lambdabot>  [[100,1,2],[100,3],[100,4,5,6]]
12:13:20 <albeit> I have a computation "applied :: MonadState Foo m => ExceptT Bar m ()". If I have a "foo :: Foo", how can I executed the state monad with foo and get ":: ExceptT Bar m Foo"??
12:13:42 * hackage sparrow 0.0.1.5 - Unified streaming dependency management for web apps  http://hackage.haskell.org/package/sparrow-0.0.1.5 (athanclark)
12:14:12 <crestfallen> thanks, but the list initially is [1,2,3] so map is not being called on a list of lists, but on (xs) which is [2,3], right? [exa] newsham
12:14:48 <isovector> it's being called on subseqs, which returns a list of lists
12:15:34 <crestfallen> so that is determined in the type signature and not in the definition of map, then isovector ?
12:15:57 <crestfallen> in the subseqs type signature
12:16:52 <crestfallen> > map (1:) [[2,3]]
12:16:53 <lambdabot>  [[1,2,3]]
12:17:26 <crestfallen> map (1:) [[2,3],[2],[3]]
12:17:42 <[exa]> crestfallen: it's called on subseqs [2,3], not on just [2,3]
12:17:46 <crestfallen> > map (1:) [[2,3],[2],[3]]
12:17:48 <lambdabot>  [[1,2,3],[1,2],[1,3]]
12:18:36 <[exa]> crestfallen: the logic of that function is "all subsequences of list of length N+1 are all subsequences without the +1'th element, and all subsequences with the +1th element"
12:19:55 <crestfallen> [exa], recently it was explained to me that the function is a node (++) and the subexpressions are leaves. so on that line which has precedence?
12:20:21 <[exa]> node?
12:20:48 <dmwit> albeit: `applied >> get :: MonadState Foo m => ExceptT Bar m Foo`
12:20:49 <crestfallen> yeah, ie the evaluation is a tree structure
12:20:54 <dmwit> albeit: But your question is a bit confused, I think.
12:21:04 <newsham> (subseq xs) ++ (map (x:) (subseq xs))   <- precedence of ++
12:21:05 <crestfallen> with precedence rules
12:21:17 <[exa]> crestfallen: well you can look at that like trees, but I can't see where you get the precedence there
12:21:43 <dmwit> albeit: Presumably what you actually want is an `Except Bar Foo` instead. In which case have a look at `mapExceptT` and `runStateT`.
12:22:31 <crestfallen> [exa] I'd like to write that out so I can keep track of the evaluation , if possible
12:23:11 <crestfallen> newsham, sorry I didn't catch your last point
12:23:17 <XorSwap> @hoogle (*>)
12:23:17 <lambdabot> Prelude (*>) :: Applicative f => f a -> f b -> f b
12:23:17 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
12:23:17 <lambdabot> Diagrams.Prelude (*>) :: Applicative f => f a -> f b -> f b
12:23:25 <[exa]> crestfallen: well you almost got it, except you somehow omitted the 'map' in your trace
12:24:12 * hackage sparrow 0.0.1.6 - Unified streaming dependency management for web apps  http://hackage.haskell.org/package/sparrow-0.0.1.6 (athanclark)
12:24:35 <[exa]> crestfallen: see here:  subseqs [1,2,3] = subseqs [2,3] ++ map (1:) (subseqs [2,3]) -- first recurse to subseqs [2,3]
12:25:31 <newsham> crestfallen: here is your example written out in more detail.  http://lpaste.net/365414
12:25:59 <crestfallen> [exa] newsham thanks kindly ! working on those
12:26:10 <newsham> oops.. thats not quite right.
12:27:01 <newsham> sorry, i just took your example and added stuff without realizing you had mistakes in it
12:27:19 <crestfallen> newsham any edits appreciated
12:27:57 <albeit> dmwit: Yes, definitely a confused question! I want to run the computation and get the new state but have it potentially terminate early.
12:28:12 <dminuoso> ertes: Dont want to sidetrack. Monoid instance of IO?
12:28:24 * dminuoso is a bit confused
12:28:45 <dminuoso> I mean that's suggesting there'd be some mempty
12:28:46 <dmwit> albeit: In which case you probably want `StateT Foo (Except Bar)` instead of `ExceptT Bar (State Foo)` as your monomorphised monad.
12:29:01 <dmwit> albeit: ...and also in which case, the answer to your question is just `execStateT`.
12:29:17 <[exa]> dminuoso: 'return mempty' ?
12:29:17 <dmwit> ?unmtl StateT Foo (Except Bar) ()
12:29:17 <lambdabot> Foo -> Except Bar ((), Foo)
12:29:26 <dmwit> ?unmtl ExceptT Bar (State Foo) ()
12:29:26 <lambdabot> ExceptT Bar (State Foo) ()
12:29:44 <dmwit> ?unmtl ErrorT Bar (State Foo) ()
12:29:44 <lambdabot> Foo -> (Either Bar (), Foo)
12:29:46 <dminuoso> [exa]: No nevermind! He just revealed the missing bit, it was just implied for `IO ()`
12:29:47 <newsham> crestfallen: this isnt your homework, is it? :)
12:29:53 <dminuoso> [exa]: Not `IO a`
12:30:40 <[exa]> dminuoso: okay :]
12:31:22 <newsham> http://lpaste.net/365415
12:31:32 <dmwit> albeit: and the answer to the question-as-asked is this:
12:31:35 <crestfallen> newsham, I'm 56 years old , hardly :)
12:31:51 <crestfallen> thanks
12:31:59 <newsham> sure thing.  does that make sense to you?
12:32:05 <dmwit> \s -> mapExceptT (\m -> do (a, s') <- runStateT m s; return (return s'))
12:32:15 <crestfallen> burning my hand with green tea ...
12:34:14 <newsham> its equational reasoning.. each step just replaces something with something else its equal to..  although I skip over the steps of how builtin functions "map", ":" and "++" work...
12:34:49 <ertes> dminuoso: instance Monoid SimpleIO where mempty = SimpleIO (pure ()); mappend (SimpleIO c) (SimpleIO d) = SimpleIO (c *> d)
12:34:51 <newsham> like line 6 uses the equation at line 2 to replace the first half of the right hand side
12:34:59 <crestfallen> newsham, really appreciate it... one moment
12:35:15 <dminuoso> ertes: Yeah I know. But until you talked about IO () it sounded like you wanted some `instance Monoid (IO a)`
12:35:22 <dminuoso> Which had me completely confused
12:35:46 <newsham> unfort i have to head out the door now.. good luck and enjoy
12:36:04 <crestfallen> so you start with the final member of the list?
12:36:09 <albeit> dmwit: Thanks! Still trying to make sense of mapExceptT, but working through it
12:36:24 <ertes> dminuoso: well, you could do this:  instance (Monoid a) => Monoid (IO a)
12:36:35 <ertes> dminuoso: you can do this for every Applicative
12:36:59 <ertes> instance (Monoid a) => Monoid (F a) where mappend = liftA2 (<>); mempty = pure mempty
12:37:01 <dminuoso> ertes: Yeah.. I mean.. ah well it's all good. Just wasn't sure what the goal was - but it's clear now anyway.
12:37:08 <ertes> ok =)
12:40:07 <Boarders> I am trying to learn openGL and have been following this: https://www.cs.hs-rm.de/~panitz/hopengl/skript.pdf
12:40:13 <Boarders> (I realise it is very out of date)
12:40:23 <Boarders> from it I have this code: http://lpaste.net/365416
12:40:29 <Boarders> but it displays no points for me
12:40:46 <Boarders> anyone have any ideas what I am doing wrong?
12:42:31 <crestfallen> newsham, I see much of it. still working... I heard richard bird writes well on equational reasoning
12:43:56 <[exa]> Boarders: you might want to set a drawing color, and there's a slight possibility that the points are out of view (try with (x,y,z-20) )
12:44:19 <[exa]> Boarders: also the point size might be different, but I hope the default is the reasonable 1.
12:44:21 <Boarders> ok, I'll give both a try
12:44:22 <Boarders> thanks
12:45:14 <[exa]> Boarders: also it looks like you're not swapping the buffers (if that's needed with glut)
12:45:49 <albeit> dmwit: Would it be cleaner/more correct o have the "applied :: (MonadState Foo m, MonadError Bar m) => m ()" instead?
12:46:11 <crestfallen> newsham, that's very interesting thanks KINDLY
12:46:16 <Boarders> exa: sorry I'm new to graphics what does that mean?
12:46:17 <[exa]> Boarders: add 'flush' on the bottom of displayPoints, it works like charm
12:46:22 <Boarders> yeah that fixed it
12:46:28 <Boarders> I saw it on a different tutorial
12:46:29 <Boarders> thanks
12:47:11 <[exa]> Boarders: after you draw stuff to backbuffer, you need to swap it with the front buffer so that it's displayed for a moment (while you're drawing to the second buffer)
12:47:26 <[exa]> (google double buffering, they'll have a nice picture about flickering)
12:48:42 <Boarders> ah, cool
12:48:43 <Boarders> thanks
12:49:09 <[exa]> also there's https://learnopengl.com/ now
12:49:10 <crestfallen> newsham, are you still available ? just some questions about your technique
12:49:53 <[exa]> crestfallen: you're on IRC, don't ask to ask. :]
12:50:58 <crestfallen> [exa] word. new*sham has the last element of the list for starters here : http://lpaste.net/365415    and ...
12:51:35 <crestfallen> why did s/he start with the last element ?
12:52:41 <[exa]> crestfallen: because that's how the actual computation makes sense. The recursion in fact starts from the first, but can't evaluate much with that before having results from the rest of the list
12:52:52 <[exa]> crestfallen: (/me making a new version)
12:56:58 <boxscape> is there a way to have a closed data family?
12:57:09 <boxscape> using the syntax from closed type families doesn't seem to work
12:58:15 <crestfallen> [exa], sorry you're writing another paste?
12:58:56 <boxscape> actually nevermind apparently someone asked this on stackoverflow a month ago
12:59:00 <[exa]> crestfallen: really explicit version http://lpaste.net/1158326652229386240
12:59:13 <dminuoso> boxscape: https://stackoverflow.com/a/49436255
12:59:15 <crestfallen> excellent [exa] !! thanks, looking
12:59:33 <boxscape> dmiles: yeah that's what I just found as well, thanks :)
12:59:42 <boxscape> oops
12:59:50 <knupfer> Where can I find the function of type `String -> Q Exp` which is used in [e| ... |]  ?
12:59:51 <boxscape> dminuoso ^
13:00:16 <knupfer> I want to write a QQ which manipulates a Q Exp emitted by [| |]
13:01:51 <dminuoso> knupfer: The module you imported the QuasiQuoter e from?
13:02:39 <knupfer> dminuoso: I'm talking about the quotation from TH, like [| 1 + 2 |]
13:02:52 <knupfer> [| |] is shorthand for [e|  |]
13:04:00 <knupfer> It's from the TH pragma, but I can't find this function, perhaps it's nowhere exported?
13:04:42 <knupfer> My goal is to quote an haskell expression, make some simplifications on the ast and reify it back.
13:05:20 <knupfer> Unfortunately it's not possible with rewrite rules, because I'll move value strings to Symbols.
13:07:37 <dpyro> using Data.Aeson, how can I get a sum datatype like Field = A | B to encode as "field": "a" and decode from the same?
13:07:50 <dpyro> assuming the particular value in this case is A / "a"
13:08:11 <knupfer> dminuoso: any idea?
13:13:31 <dminuoso> knupfer: Right now Im wondering whether that documentation is possibly out of date.
13:13:57 <dminuoso> knupfer: Looking at the parser, [|, [p|, [t| and [d| are specially parsed. So this is somehow rigged into GHC.
13:14:17 <dminuoso> knupfer: But I dont see any case for [e| here
13:14:46 <dminuoso> knupfer: Wow nevermind weirdness. The lexer does this.
13:15:20 <knupfer> dminuoso: and is this function somehow accessible? perhaps in GHC ?
13:18:07 <fishythefish> dpyro: write ToJSON/FromJSON instances for it
13:18:40 <knupfer> or will I have to write:   $(optimize [| ... |])
13:18:51 <knupfer> I hoped to be able to avoid that
13:19:04 <dpyro> fishythefish: i have ToJSON and FromJSON  with genericParseJSON / genericToEncoding defaultOptions {constructorTagModifier = lowerFirst}
13:19:06 <knupfer> where optimize :: Q Exp -> Q Exp
13:19:15 <dpyro> it seems to work for decoding but not encoding
13:20:06 <fishythefish> dpyro: you can write manual instances
13:20:27 <dpyro> i know, but since i can do it for decoding i was hoping i can do it for encoding using the options
13:22:17 <fishythefish> dpyro: then you probably want to check out the sumEncoding option
13:26:11 <dpyro> 👌
13:27:13 * hackage hledger-ui 1.9.1, hledger 1.9.1, hledger-lib 1.9.1, hledger-api 1.9.1, hledger-web 1.9.2 (SimonMichael): https://qbin.io/cox-aol-gcqy
13:28:41 <dminuoso> knupfer: What I have discovered so far, is that [||] actually gets desugared into.. something
13:30:40 <knupfer> ok?
13:30:57 <dminuoso> knupfer: Okay nevermind. Im completely lost. Plenty of magic happening there. =)
13:32:26 <kalt> kosmikus: I'm reading this gist and wondering if there was a way to defined the inverse: https://gist.github.com/kosmikus/3db332604190637bc93cede5031ea0e3
13:32:32 <dminuoso> knupfer: compiler/deSugar/DsMeta.hs is where things start happening..
13:32:57 <kalt> kosmikus: ie. go from Person I to Person Maybe
13:33:59 <knupfer> dminuoso: at least I've found two persons on SO contemplating the same question.
13:34:14 <knupfer> It seems that it's practically not possible.
13:34:16 <kalt> kosmikus: it seems like it should be trivial... hmap seems to have the signature I'm looking for, but it's not
13:34:43 <kosmikus> kalt: one moment, I have to look at that gist again
13:34:58 <knupfer> The ASTs are quite different, they propose haskell-src-exts (which is quite buggy).
13:38:00 <kosmikus> kalt: to . hcoerce . hmap (Just . unI) . from
13:39:57 <kosmikus> kalt: I've added it as a comment to the gist
13:44:02 <kalt> kosmikus: ooohhh... let me work out a more general signature to understand what's going on ;)
13:44:10 <kalt> kosmikus: thank you so much!
13:44:34 <albeit> If I have "foo :: MonadError FooError m => m ()" and "bar :: MonadError BarError m => m ()", and "barToFoo :: BarError -> FooError", how can I call bar from foo?
13:47:13 * hackage bloodhound-amazonka-auth 0.1.2.1 - Adds convenient Amazon ElasticSearch Service authentication to Bloodhound.  http://hackage.haskell.org/package/bloodhound-amazonka-auth-0.1.2.1 (MichaelXavier)
13:50:27 <kosmikus> kalt: you're welcome. glad I could help.
13:51:40 <jle`> albeit: i don't think there is a way in general
13:51:49 <jle`> albeit: because of | m -> e
13:51:55 <newsham> crestfallen: i'm back now
13:52:17 <jle`> albeit: each 'm' is only allowed to have exactly one 'e'
13:52:20 <jle`> for a MonadError instance
13:52:53 <jle`> hm, actually sorry, that's not a real reason.  since they are both forall m'd
13:53:17 <jle`> but i'm looking at the methods in the MonadError typeclass and noen of them really give you a way to interchange the 'e'
13:56:56 <albeit> jle`: Okay, thanks. Is there a recommended way to get early-termination errors to bubble-up to calling functions that may have their own error type?
13:57:43 <jle`> you can use ExceptT FooError m and ExceptT BarError m, maybe
13:57:48 <jle`> since that type gives you a way to flip the e's
13:57:58 <dminuoso> knupfer: Okay Im convinced I've found the code responsible. It all happens in the desugarer: https://github.com/ghc/ghc/blob/master/compiler/deSugar/DsMeta.hs#L1207-L1347
13:58:13 <dminuoso> knupfer: So it looks like it's truly rigged into GHC
13:58:56 <hololeap> i don't understand why seq has the type "a -> b -> b" instead of "a -> ()" ... does anyone have any insights into why it's designed this way?
13:58:59 <dminuoso> GHC code is surprisingly readable if you start making sense of the abbreviations..
13:59:08 <jle`> albeit: also you can use 'Either SomeException' as well
13:59:20 <jle`> that's actually what the SomeException type was designed for
13:59:26 <jle`> that bubbly behavior
13:59:48 <dminuoso> hololeap: how would you use that?
13:59:50 <jle`> SomeException is actually just a normal Haskell data type without any built in compiler magic, it's just a utility type
14:00:00 <dminuoso> hololeap: that's basically equivalent to a very expensive unit.
14:00:56 <hololeap> to force evaluation on the argument
14:01:10 <dminuoso> hololeap: yeah but how would you use that?
14:01:37 <dminuoso> ($!) :: (a -> b) -> a -> b
14:01:39 <dminuoso> f $! x = ???
14:01:56 <dminuoso> hololeap: let's say your `seq` had the type `a -> ()`, use it.
14:02:07 <jle`> hololeap: 'seq' doesn't mean "evaluate this"
14:02:15 <hololeap> in Parallel and Concurrent Programming in Haskell, the first example of seq is `seq y ()` which forces the evaluation of y and returns ()
14:02:19 <jle`> that would probably break haskell
14:02:23 <jle`> hololeap: that doesn't force y
14:02:38 <albeit> jle`: Hmm interesting. Is it okay to use it for exceptions that aren't terminal, but just need attention?
14:02:51 <jle`> hololeap: it sets up a trigger that, when you evaluate that (), it will also evaluate 'y'
14:03:02 <hololeap> oh
14:03:05 <jle`> hololeap: it doesn't actually evaluate the y, it just ties the evaluation of 'y' with the evaluation of the resulting ()
14:03:09 <dminuoso> hololeap: it sequences evaluation of `y` before (). That is, it's strict in its first argument.
14:03:18 <jle`> so when you evaluate the (), then ghc will also evaluate y
14:03:29 <hololeap> ok... i didn't realize that
14:03:36 <jle`> albeit: SomeException is pretty much an open Either
14:03:37 <hololeap> that makes more sense then
14:03:58 <dminuoso> would `seq (!a) b = b` be a correct implementation?
14:04:32 <hololeap> if you're asking me, i have no idea
14:04:49 <jle`> dminuoso: foo !x = y is just sugar for foo x = x `seq` y
14:05:05 <jle`> dminuoso: bang patterns is just sugar for seqing your arguments with the result
14:05:11 <dminuoso> Heh.
14:05:36 <spoonm> :t seq
14:05:37 <lambdabot> a -> b -> b
14:05:40 <dminuoso> jle`: well.. `seq x y = case y of _ -> y` maybe?
14:05:41 <spoonm> k
14:05:55 <jle`> so yeah `mySeq !x y` is just sugar for `mySeq x y = x `seq` y`
14:05:58 <int-e> dminuoso: Only in STG, not in Haskell.
14:05:59 <jle`> dminuoso: that doesn't force anything
14:06:13 <spoonm> is that a strict thing?
14:06:13 <jle`> seq is the compiler magic
14:06:27 <dminuoso> jle`, int-e: I see. Thanks. :)
14:06:41 <jle`> spoonm: yes, read up earlier for a description on how it behaves :)
14:06:59 <spoonm> I see
14:08:47 <dminuoso> jle`: That thought was provoked by remembering that someone once said that execution is essentially forced by case statements in GHC.
14:09:00 <dminuoso> Or "evaluation" rather if you want.
14:09:49 <jle`> dminuoso: yeah, but by the pattern matching
14:09:55 <jle`> you can implement seq on a per-type basis that way
14:10:13 <jle`> seq :: () -> a -> a; seq x y = case x of () -> y
14:10:20 <jle`> that would be seq for ()
14:10:40 <jle`> so you actually could implement normal seq using hololeap's seq this way
14:11:08 <jle`> seq for Maybe would be seq x y = case x of Nothing -> y; Just _ -> y
14:11:40 <jle`> the compiler magic is that haskell's seq is polymorphic
14:11:52 <jle`> but a typeclass-based seq is similar to the idea behind the deepseq library
14:12:11 <benzrf> jle`: this doesn't quite hold up, though
14:12:19 <benzrf> seq kinda breaks the denotational semantics, even
14:12:24 <benzrf> when you use it on functions
14:12:41 <jle`> oh yeah, this case statement method only helps with seq for ADT's
14:13:10 <jle`> so seq for functions is out of this picture
14:13:16 <jle`> more compiler magic :'(
14:13:41 <benzrf> iirc the denotational semantics actually does not distinguish between undefined and const undefined
14:13:43 <benzrf> but
14:13:55 <benzrf> > (undefined :: Int -> Int) `seq` "ok"
14:13:57 <lambdabot>  "*Exception: Prelude.undefined
14:13:59 <benzrf> > (const undefined :: Int -> Int) `seq` "ok"
14:14:01 <lambdabot>  "ok"
14:14:21 <benzrf> i.e. we don't have function extensionality
14:14:58 <benzrf> well... i guess to define whether we "have function extensionality" you'd need to already have some notion of equality on other types... that might exist, but i dont actually know what im talking about, so nvm :>
14:15:36 <rckd71> how can i catch exceptions thrown by Data.Text.Encoding.decodeUtf8?
14:16:08 <glguy> rckd71: Better not to have to; use the decode function that doesn't throw them
14:16:23 <benzrf> rckd71: docu says "For more control over the handling of invalid data, use decodeUtf8' or decodeUtf8With."
14:16:38 <jle`> @let import qualified Data.Text.Encoding as T
14:16:40 <lambdabot>  Defined.
14:16:48 <jle`> :t T.decodeUtf8'
14:16:49 <lambdabot> BSC.ByteString -> Either Data.Text.Encoding.Error.UnicodeException Data.Text.Internal.Text
14:17:01 <jle`> oops
14:17:09 <rckd71> yes, i know. i just want to know how to handle such cases in general. what if i use a lib that uses decodeUtf8 somewhere?
14:17:20 <jle`> rckd71: the lib is screwing you over
14:17:39 <jle`> there are hacky ways around it but none of them are reliable
14:17:49 <rckd71> hmm ok
14:17:53 <benzrf> rckd71: you can do it from IO: http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Exception.html
14:18:10 <benzrf> so you can use that if you are forced to, as in your hypothetical - but you really shouldn't use this if you can avoid it
14:18:11 <jle`> spoon is one of those hacky ways
14:18:12 <jle`> @where spoon
14:18:12 <lambdabot> I know nothing about spoon.
14:18:17 <rckd71> so i have to live with the feeling that there could be an exception be thrown out of nowhere?
14:18:17 <jle`> @hackage spoon
14:18:18 <lambdabot> http://hackage.haskell.org/package/spoon
14:18:24 <benzrf> :( spoon
14:18:37 <jle`> :(
14:18:54 <benzrf> rckd71: yes, in the same sense that you have to live with the feeling that you could have a sigkill out of nowhere :)
14:18:57 <jle`> if you're in IO then you can use evaluate + deepseq to try to flesh it out
14:19:16 <jle`> but really there are many ways a library you use can screw you over because of certain design decisions
14:19:20 <jle`> this is just one way, heh
14:19:38 <jle`> s/flesh/flush
14:19:53 <benzrf> anyway yeah, exceptions are kinda an ugly part of haskell
14:20:05 <rckd71> ok, i just read about that and it frightened me
14:20:10 <benzrf> hahaha
14:20:23 <rckd71> :-D
14:20:32 <jle`> Exceptions are pretty nice i think
14:20:37 <benzrf> yeah?
14:20:45 <jle`> yeah, they're a useful tool
14:20:57 <jle`> it's just 'using bottom for control flow' that is the real ugly thing
14:21:05 <benzrf> well, i guess there are cases where they make sense
14:21:09 <jle`> which is what is going on here
14:21:43 <jle`> partial functions is the real ugliness here i think
14:22:00 <rckd71> i dont like the fact that an unobstrusive function like decodeUtf8 with a signature of ByteString -> Text can throw my total app out of the window
14:22:01 <rckd71> :-D
14:22:12 <benzrf> rckd71: that's true of any signature in any turing-complete language
14:22:15 <jle`> and without Exceptions we wouldn't have a way to work with them at all
14:22:17 <benzrf> infinite loops can already do that
14:22:30 <benzrf> or sys.exit
14:22:56 <benzrf> well, ok, i guess there's a difference
14:23:15 <benzrf> in the sense that inf loops or sys.exit are justifiably unexpected behavior
14:23:45 <jle`> i think infinite loops are safe to throw into the same category
14:23:58 <jle`> a library might promise an Int -> Bool, but if you try to evaluate it, it'll kill your program
14:23:58 <rckd71> decodeUtf8' is what i would expect as the default behavior
14:24:04 <benzrf> yeah
14:24:09 <benzrf> that seems like poor library design
14:24:10 <jle`> rckd71: indeed
14:24:24 <benzrf> i guess the answer is just - in general, expect total app crashing from any function which you should expect to possibly fail but which has a supposedly total signature
14:24:39 <benzrf> in which case: offering such a signature as default is just poor design
14:24:41 <benzrf> >:\
14:24:59 <ystael> benzrf: partial functions are a historical artifact which modern Haskell practice unequivocally rejects
14:25:07 <ystael> see ClassyPrelude for a Prelude alternative containing no partial functions
14:25:07 <benzrf> yeah
14:25:37 <benzrf> well - "partial functions" in the sense of throwing exceptions
14:25:55 <benzrf> partial functions in general are all over the place :)
14:25:58 <rckd71> what you mean with "partial functions" exactly?
14:26:07 <benzrf> functions which are undefined on some input
14:26:13 <jle`> rckd71: functions that do not have defined results for all input
14:26:24 <rckd71> ok thanks
14:26:29 <jle`> like decodeUtf8, head, foo x = foo x
14:26:33 <benzrf> jle`: my phrasing is stronger under intuitionistic logic ;)
14:26:44 <jle`> ;)
14:27:27 <jle`> most haskell intuition is sort of built around the assumption that partial functions don't exist
14:27:44 <jle`> and really haskell doesn't provide too good of tools for really working with partial functions
14:27:57 <benzrf> somewhere in the back of my head a strawman of robert harper is shaking his cane
14:28:04 <fishythefish> still more intuition can be gained by writing code to avoid partial functions as much as possibl
14:29:58 <nshepperd> partial function such as `div`
14:31:24 <benzrf> > 3 `div` 0
14:31:26 <lambdabot>  *Exception: divide by zero
14:31:27 <benzrf> ouch
14:32:11 <rckd71> hmmm
14:32:18 <jle`> > succ ()
14:32:20 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
14:32:24 <benzrf> s u c c
14:32:53 <spruit11> :t succ
14:32:54 <lambdabot> Enum a => a -> a
14:33:07 <benzrf> rckd71: here "defined" roughly means "terminates resulting in a value"
14:33:11 <spruit11> :t ()
14:33:12 <lambdabot> ()
14:33:26 <spruit11> I don't get it?
14:33:34 <fishythefish> () is the name of both the value and the type
14:33:39 <benzrf> but like i said, i think people are missing partiality lurking all over the place
14:33:41 <benzrf> :t sort
14:33:42 <lambdabot> Ord a => [a] -> [a]
14:33:47 <benzrf> this is not a total function!
14:33:50 <benzrf> > sort (repeat 1)
14:33:58 <lambdabot>  mueval: ExitFailure 1
14:34:11 <benzrf> laziness complicates everything
14:34:14 <spruit11> No, why does `succ ()` give that error?
14:34:22 <benzrf> the denotational semantics of haskell are rather subtle
14:34:23 <[exa]> spruit11: it's the same error as succ True
14:34:31 <jle`> spruit11: believe it or not, that's actually an Enum law
14:34:40 <jle`> `succ maxBound` must be undefined
14:34:41 <benzrf> spruit11: () is maxed out & cannot be increased
14:34:47 <fishythefish> spruit11: it's a bounded type and you can't exceed the amx
14:34:48 <fishythefish> max*
14:34:52 <jle`> > maxBound :: ()
14:34:53 <benzrf> haha sorry for the dogpile
14:34:54 <lambdabot>  ()
14:34:59 * [exa] introduces a new voidish smiley
14:35:04 <[exa]> > [()..()]
14:35:06 <lambdabot>  [()]
14:35:14 <rckd71> xD
14:35:37 <fishythefish> > [(), () .. ()]
14:35:39 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
14:35:56 <benzrf> also, i think the correct definition of "partial" is probably pretty subtle in lazy languages
14:36:05 <Ariakenom> fishythefish: but why ....
14:36:26 * fishythefish shrugs
14:36:47 <spruit11> Oh, is `()` also a type synonym?
14:36:54 <fishythefish> no, it's just a type
14:37:08 <benzrf> is fst partial, since it is undefined on something non-bottom?
14:37:10 <spruit11> Why does it fall into the `Enum` class then?
14:37:10 <benzrf> > fst (undefined, 1)
14:37:13 <lambdabot>  *Exception: Prelude.undefined
14:37:14 <[exa]> it just has the same name as its only constructor
14:37:17 <jle`> spruit11: someone wrote an instance
14:37:26 <jle`> spruit11: Enum is an open typeclass, so you can write an instance for any type you want
14:37:27 <Ariakenom> the sort wasn't about lazy though. It was about finiteness not being expressed
14:37:31 <fishythefish> spruit11: same reason anything else is an Enum :P
14:37:35 <spruit11> Oh right. Duh.
14:37:57 <benzrf> Ariakenom: not sure what you mean
14:38:08 <fishythefish> Ariakenom: but in a strict language, you wouldn't be able to supply an infinite list to sort in the first place
14:38:14 <[exa]> spruit11: so that functions that want to enumerate on stuff can be downcasted to dumb&simple cases easily
14:38:37 <dyl> :t Data.ByteString. accursedUnutterablePerformIO
14:38:38 <lambdabot> error:
14:38:38 <lambdabot>     Not in scope: data constructor ‘Data.ByteString’
14:38:38 <lambdabot>     Perhaps you meant one of these:
14:38:41 <Ariakenom> fishythefish: It's still the same thing as div _ 0 though
14:38:53 <fishythefish> it's true that if we could express the constraint "this list is finite", laziness wouldn't be an issue, but it's laziness that enables that pathological behavior
14:39:03 <Ariakenom> benzrf: I just didn't understand the laziness problem
14:39:22 <fishythefish> Ariakenom: it's the same in that they're both partial, but div _ 0 is partial whether your language is lazy or strict
14:39:25 <dyl> :t Data.ByteString.Internal. accursedUnutterablePerformIO
14:39:26 <benzrf> oh - yeah, i really meant "existence of infinite data" rather than "general lazy evaluation"
14:39:27 <lambdabot> error:
14:39:27 <lambdabot>     Not in scope: data constructor ‘Data.ByteString.Internal’
14:39:27 <lambdabot>     Perhaps you meant one of these:
14:39:28 <benzrf> sry
14:39:41 <benzrf> it's just that in haskell the former is sort of a consequence of the latter i guess
14:39:42 <dyl> :t Data.ByteString.Internal.accursedUnutterablePerformIO
14:39:43 <lambdabot> IO a -> a
14:40:09 <Ariakenom> fishythefish: And sort doesn't have to be partial just because it's lazy.
14:40:28 <Ariakenom> And can be partial if defined for an iterator or whatever in a strict language
14:40:50 <fishythefish> dyl: I don't see "unsafe" anywhere, so that function must be kosher, right?
14:41:08 <fishythefish> Ariakenom: I'm not contesting either of those claims
14:41:24 <dyl> XorSwap pointed it out, the documentation string is great
14:41:30 <dyl> ( https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L566 )
14:41:30 <fishythefish> I'm saying lazy evaluation enables you to supply an infinite list, which is one of the reasons sort might fail
14:41:54 <benzrf> fishythefish: actually i don't think infinite data is necessarily a consequence of laziness
14:42:05 <benzrf> you can give lazy operational semantics to a total language
14:42:19 <Ariakenom> precisely
14:42:34 <benzrf> so Ariakenom is right, i was a bit off :)
14:43:07 <fishythefish> benzrf: again, that's not a claim I'm making
14:43:16 <Ariakenom> something something codata
14:43:17 <benzrf> also uh s/a total language/a language with only finite types/
14:43:20 <fishythefish> the point is that eager evaluation of a list would *prevent* infinite lists
14:43:45 <benzrf> well, you did just say "lazy evaluation enables you to supply an infinite list"
14:43:46 <fishythefish> laziness doesn't guarantee that sort is partial, but it allows for infinite lists as input
14:44:32 <Ariakenom> the inlinePerformIO comment below is also good
14:44:32 <fishythefish> I suppose this is a precedence issue
14:44:42 <fishythefish> I should have said "permit" rather than "enable" perhaps
14:44:48 <fishythefish> something else might still disallow it
14:44:52 <benzrf> depending on your definition of laziness, laziness is a prerequisite for infinite data, but it's certainly not sufficient
14:44:54 <benzrf> yeah
14:44:56 <fishythefish> yeah
14:45:59 <Ariakenom> Does that definition make any sense though?
14:46:05 <suzu> is there some know pattern for transforming functions of (r -> m a) to (r -> m' a) given some transforming function (m a -> m' a)
14:46:17 <fishythefish> suzu: function composition
14:46:41 <suzu> okay. but suppose that it is (r1 -> r2 -> r3 -> m a) to (r1 -> r2 -> r3 -> m' a)
14:46:58 <fishythefish> still function composition, after you supply r1, r2, r3
14:47:00 <benzrf> Ariakenom: what definition?
14:47:07 <fishythefish> er, r1 and r2
14:47:09 <Ariakenom> laziness
14:47:12 <Ariakenom> data Range = {start::Int, step::Int, stop::Int} -- You can sort some of these
14:47:33 <Ariakenom> But we were talking of lists
14:47:44 <Ariakenom> So I'll go sleep
14:47:50 <suzu> oh i think you are right
14:47:52 <suzu> i am silly
14:48:01 <suzu> i was doing this with typeclass recursion :l lmao
14:48:50 <benzrf> Ariakenom: well, i didn't give a specific definition (and i don't actually know the proper definition >w>) but i was vaguely thinking something like "terms corresponding to infinite data cannot be eagerly evaluated, so if you think of 'lazy' as meaning 'not eager'..."
14:48:58 <benzrf> yeah aight that's probably wrong
14:49:00 <benzrf> ;v;
14:49:21 <suzu> err wait, this doesn't exactly work
14:50:08 <suzu> (undefined :: (m a -> m' a)) . (undefined :: (r1 -> r2 -> r3 -> m a)) doesn't work
14:50:27 <fishythefish> suzu: no, because the right type is really r1 -> (r2 -> r3 -> m a)
14:50:39 <suzu> right
14:50:41 <jle`> suzu: you can't use (.) directly
14:50:50 <jle`> but it works if you supply r1 and r2 first
14:50:52 <fishythefish> so you can partially apply it to r1 and r2
14:50:57 <jle`> or also you can always just write the new function
14:50:59 <fishythefish> or just manually apply the transforming function to the result
14:51:05 <suzu> i don't want to supply r1 and r2
14:51:14 <suzu> i want the value to be a function expecting an r1 and r2
14:51:16 <jle`> foo x y z = mama (rma x y z)
14:51:31 <jle`> suzu: you can use a lambda or just normal function syntax
14:51:36 <suzu> i also don't want to do it by hand as i have a number of functions that are of this form or similar
14:51:41 <suzu> with differing arity
14:51:52 <fishythefish> @pl \transform f -> \r1 r2 r3 -> transform (f r1 r2 r3)
14:51:52 <lambdabot> (.) . (.) . (.)
14:52:13 <spruit11> Boobies!
14:52:25 <jle`> suzu: if you want to re-use code, you can define a single supercompose function
14:52:33 <jle`> :t comp3 f g x y z = f (g x y z)
14:52:34 <lambdabot> error:
14:52:35 <lambdabot>     parse error on input ‘=’
14:52:35 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
14:52:48 <jle`> :t \f g x y z -> f (g x y z)
14:52:50 <lambdabot> (t1 -> t2) -> (t3 -> t4 -> t5 -> t1) -> t3 -> t4 -> t5 -> t2
14:52:57 <suzu> hmm
14:53:00 <jle`> you can even make it an operator if you are feeling fancy :)
14:53:06 <jle`> it's sometimes called .::
14:53:47 <suzu> i do need to define a version for each arity, yeah?
14:54:00 <jle`> yes, otherwise it wouldn't really make sense
14:54:00 <suzu> one for funcs expecting 3 args before `m a`, one for 4 args. etc
14:54:03 <jle`> what type would it even have
14:54:13 <suzu> hmm
14:54:20 <suzu> i might stick with my typeclass then
14:54:49 <suzu> which recurses on (r -> a) where a has an instance
14:54:54 <suzu> and has a typefamily for the return type
14:55:10 <suzu> this works for an infinite number of arguments though it is kinda dumb
14:56:36 <jle`> sounds like 90% of haskell solutions :)
14:57:13 <jle`> fwiw quickcheck does a similar trick
14:57:19 <jle`> printf might too
14:57:27 <suzu> yep i'm doing the same thing
14:57:36 <suzu> iirc quickcheck does it on `Testable`
14:57:45 <suzu> and Printf has a similar class yup
15:06:08 <jle`> suzu: alternatively you can also pre-curry all your functions
15:06:19 <jle`> er, pre-uncurry
15:07:29 <fishythefish> you again run into the issue of handling each arity separately, though, right?
15:10:24 <jle`> yes but not if your functions were all written uncurried in te first place, ocaml syle ~
15:12:54 <fishythefish> wait, ocaml doesn't write its functions uncurried by default
15:13:21 <fishythefish> wait, does it?!
15:13:28 <lyxia> no they don't
15:13:40 <fishythefish> phew
15:13:51 <fishythefish> I've been writing ocaml for work for months and I was scared for a minute
15:18:12 * hackage haskell-src-exts-util 0.2.3 - Helper functions for working with haskell-src-exts trees  http://hackage.haskell.org/package/haskell-src-exts-util-0.2.3 (PepeIborra)
15:20:25 <albeit> If I'm using Control.Exception.Catch, and I have a function that can throw different types of exceptions, how can I catch multiple types?
15:21:36 <albeit> Whoops, found the answer, I can use a Handler and catches
15:27:28 <suzu> i think the monomorphism restriction is biting me and i don't know how to get it off my case
15:27:50 <dyl> NoMonomorphismRestriction?
15:27:54 <suzu> i have a `let foo = ... :: Foo a => a -> Bar b`
15:28:22 <suzu> it wont let me create [foo x1, foo x2] which would be [Bar b] but x1 and x2 are not the same type
15:28:24 <nshepperd> put the type sig separately
15:28:38 <nshepperd> let foo :: Foo a => a -> Bar b; foo = ...
15:28:49 <suzu> that's different?
15:29:03 <suzu> can i do that in a do-block?
15:29:18 <dyl> Well, what you wrote initially was a type annotation on the right hand side
15:29:18 <nshepperd> yeah
15:29:25 <dyl> Versus separately it’s on the name on the left hand side.
15:29:36 <suzu> a type _annotation_ and a type _declaration_ are different?
15:29:46 <suzu> ah i think i understand
15:29:49 <zachk> are 40-50 line functions considered bad?
15:29:59 <nshepperd> 'let foo = ... :: Foo a => a -> Bar b' is 'let foo = (... :: Foo a => a -> Bar b)'
15:30:03 <suzu> the declaration type is calculated from the annotations in the body and is being monomorphism restricted
15:30:05 <dyl> I would say a declaration is a particular type of annotation.
15:30:19 <dyl> One that annotates a top level symbol.
15:30:23 <suzu> so i need to fix the type at the 'top level' here
15:30:27 <suzu> and not on the bohdy
15:30:28 <suzu> body *
15:30:31 <dyl> On the left side of the =
15:30:40 <dyl> So, as a distinct declaration.
15:31:16 <dyl> You can also use unsafeBloodForTheTypeGod.
15:31:40 <dyl> When you run the program it will eject your CD drive. Allow 3 drops of blood to fall on the read head and reinsert.
15:31:42 <suzu> lmao
15:31:42 * hackage genvalidity-containers 0.4.0.0 - GenValidity support for containers  http://hackage.haskell.org/package/genvalidity-containers-0.4.0.0 (Norfair)
15:31:46 <dyl> The program will then typecheck.
15:32:06 <iqubic> What are we talking about? IO a -> a?
15:32:08 <suzu> moving the type annotation to the top level worked
15:32:08 <dyl> Specifically RealWorld will be mutated such that you now exist in a world where it would have typechecked all along.
15:32:18 <dyl> This is how language extensions are deisgend.
15:32:26 <suzu> i choose to live in the reality where my incorrect code typechecks, yes.
15:32:27 <dyl> This is also why FP profs go through so many postdocs.
15:32:51 <iqubic> Is it just me or is Gitter going slowly?
15:32:52 <mniip> RealWorld doesn't exist
15:32:55 <mniip> you only observe the State#
15:32:56 <dyl> You cannot even imagine the tragic loss of life necessary to bring FlexibleInstances into the world.
15:33:24 <suzu> accursedUnutterablePerformIO tho
15:33:29 <dyl> Entire departments lying cold on the floor, the coffee pots full and yet untouched, not even the faintest clatter of that one guys mechanical keyboard...
15:33:40 <suzu> shamelessUnspeakableDisastrousConsequences
15:33:54 <dyl> GHC = Glasgow Haskell Cult
15:35:29 <iqubic> See, IO a -> a is a terrible idea for every reason there is.
15:36:20 <zachk> it's nice for debug trace
15:36:38 <iqubic> :t trace
15:36:40 <lambdabot> error: Variable not in scope: trace
15:36:45 <iqubic> :t print
15:36:47 <lambdabot> Show a => a -> IO ()
15:37:07 <fishythefish> iqubic: http://hackage.haskell.org/package/base-4.11.1.0/docs/Debug-Trace.html
15:37:12 <iqubic> What is the type signature of Debug.Trace?
15:37:14 <dyl> :t Debug.Trace.trace
15:37:16 <lambdabot> String -> a -> a
15:37:17 <mniip> % :t trace
15:37:18 <yahb> mniip: String -> a -> a
15:37:24 <iqubic> Yeah, that is the thing I wanted.
15:37:30 <zachk> they should call unsafePerformIO coReturnIO
15:37:30 <iqubic> How does that work?
15:37:41 <mniip> zachk, instance Comonad IO
15:37:49 <fishythefish> iqubic: look at the source: http://hackage.haskell.org/package/base-4.11.1.0/docs/src/Debug.Trace.html#trace
15:38:44 <iqubic> Yeah, that's cool.
15:39:04 <iqubic> mniip: Is there actually a comand IO instance?
15:39:13 <mniip> no
15:39:16 <zachk> iirc bytestring uses unsafePerformIO internally, and maybe STM as well
15:39:47 <mniip> zachk, bytestring, text, Array, what not
15:40:27 <iqubic> mniip: Why isn't there a Comonad instance?
15:40:35 <iqubic> For IO I mean.
15:40:46 <mniip> because it's not a comonad
15:40:54 <mniip> there's no function of type IO a -> a
15:40:59 <mniip> ;)
15:41:06 <iqubic> I am co-familiar with comonads.
15:41:07 <zachk> you could make one, I don't know if it would have any real world use though
15:41:31 <mniip> zachk, it might have RealWorld use though
15:41:51 <fishythefish> :t undefined :: IO a -> a
15:41:52 <lambdabot> IO a -> a
15:41:57 <fishythefish> :thinking:
15:42:22 <zachk> :t unsafePerformIo
15:42:24 <lambdabot> error: Variable not in scope: unsafePerformIo
15:42:31 <zachk> :t unsafePerformIO
15:42:32 <lambdabot> error: Variable not in scope: unsafePerformIO
15:42:35 <mniip> % :t unsafePerformIO
15:42:35 <yahb> mniip: IO a -> a
15:42:37 <zachk> :9
15:42:45 <zachk> what bot does % goto
15:42:48 <fishythefish> yahb
15:42:59 <mniip> the one that replies
15:43:05 <zachk> that would be extract and duplicate could just use return from the monad instance
15:43:15 <zachk> whats yahb offer?
15:43:16 <fishythefish> now check the comonad laws :P
15:43:24 <mniip> yahb is a proper ghci session
15:43:29 <zachk> oh
15:43:38 <mniip> not using a language-level sandbox
15:44:24 <mniip> e.g it has :i and :set
15:44:29 <mniip> and IO as well as GHC.Prim
15:44:45 <iqubic> What is GHC.Prim?
15:45:09 <zachk> ghc specific primitive operations and types iirc
15:45:24 <iqubic> I see.
15:45:56 <mniip> everything goes to GHC.Prim eventually
15:46:05 <mniip> % :i Int
15:46:08 <yahb> mniip: data Int = I# Int# -- Defined in `GHC.Types'; instance Eq Int -- Defined in `GHC.Classes'; instance Ord Int -- Defined in `GHC.Classes'; instance Show Int -- Defined in `GHC.Show'; instance Read Int -- Defined in `GHC.Read'; instance Enum Int -- Defined in `GHC.Enum'; instance Num Int -- Defined in `GHC.Num'; instance Real Int -- Defined in `GHC.Real'; instance Bounded Int -- Defined in `GHC.Enum'; instan
15:46:15 <mniip> % :i Int#
15:46:15 <yahb> mniip: data Int# :: TYPE 'GHC.Exts.IntRep -- Defined in `GHC.Prim'
15:47:21 <zachk> % :i [a]
15:47:21 <yahb> zachk: ; <interactive>:1:2: error: parse error on input `a'
15:47:37 <zachk> do list's goto Prim as well?
15:48:31 <mniip> no that's wired in GHC.Base iirc
15:48:33 <mniip> % :i []
15:48:33 <yahb> mniip: data [] a = [] | a : [a] -- Defined in `GHC.Types'; instance Alternative [] -- Defined in `GHC.Base'; instance Applicative [] -- Defined in `GHC.Base'; instance Eq a => Eq [a] -- Defined in `GHC.Classes'; instance Functor [] -- Defined in `GHC.Base'; instance Monad [] -- Defined in `GHC.Base'; instance MonadPlus [] -- Defined in `GHC.Base'; instance Monoid [a] -- Defined in `GHC.Base'; instance Ord a =>
15:48:48 <mniip> ^ that's a lie :p
15:48:56 <mniip> it's not defined anywhere
15:50:25 <mniip> ah hmm
15:50:28 <mniip> it is defined after all
15:56:42 * hackage genvalidity 0.5.0.1 - Testing utilities for the validity library  http://hackage.haskell.org/package/genvalidity-0.5.0.1 (Norfair)
16:11:05 <gg> hello
16:13:00 <zachk> hi
16:16:14 <suzu> is there a way to pattern match on an existential value and enforce a typeclass constraint on it?
16:18:52 <hpc> the website for it is down right now, but that's the existential typeclass antipattern
16:19:31 <glguy> The anti-pattern isn't using that feature at all, the anti-pattern is about a particular library design
16:21:38 <dyl> hpc: Everyone reinvents the ETC antipattern :)
16:21:45 <dyl> It’s a part of the process... a rite of passage.
16:23:20 <hpc> suzu: perhaps with more information we can help you come up with something that gets what you need without a ton of boilerplate?
16:25:24 <suzu> yeah so what i've got here is a list of values that have a Foo instance
16:26:03 <suzu> data Thing = forall a. Foo a => MkThing a
16:26:20 <suzu> and then a list [MkThing a, MkThing b, MkThing c...]
16:26:42 <suzu> i want to pull that value out, map over it, and then put it back in
16:26:56 <suzu> and promise to GHC that the new value does have a Foo instance
16:28:09 <suzu> so i've got something like: f (MkThing v) = MkThing newV
16:28:46 <suzu> uhh or rather
16:28:56 <suzu> f (MkThing v) = MkThing $ makeNewValue v
16:29:25 <suzu> now i don't know what the type of v is, only that it has a Foo instance. so i need makeNewValue to work with only that assumption
16:29:55 <fishythefish> is Foo an existing typeclass you're stuck with, or did you write it to describe an interface?
16:30:17 <suzu> but it can't. it needs a Bar instance. I personally know that the value in there has a Bar instance -- is there a way to tell GHC to assert that there is a Bar witness?
16:30:28 <suzu> i'm not stuck with foo - i wrote it
16:31:52 <fishythefish> can you make Foo a datatype instead?
16:32:30 <suzu> n..o i can't
16:32:46 <fishythefish> e.g. if class Foo a where bar :: a -> Bool, convert that to data Foo = Foo { bar :: Bool }
16:33:08 <fishythefish> then you would just have [Foo]
16:34:08 <suzu> i can't do that in this situation
16:34:16 <suzu> i'm using the typeclass to do some type-level transformation shenanigans
16:34:24 <suzu> it won't work as a data type
16:36:24 <suzu> i think this might be impossible
16:36:42 <suzu> i probably can't add a typewitness without ghc claiming that's illegal
16:37:20 <suzu> i suppose the only way to do this is to use a value-level dict to carry the constraint around
16:42:12 * hackage hoist-error 0.2.0.0 - Some convenience facilities for hoisting errors into a monad  http://hackage.haskell.org/package/hoist-error-0.2.0.0 (schalmers)
16:43:42 * hackage genvalidity-hspec 0.6.0.1 - Standard spec's for GenValidity instances  http://hackage.haskell.org/package/genvalidity-hspec-0.6.0.1 (Norfair)
16:50:38 <boxscape> is there a more trivial Constraint than () ~ ()?
16:51:05 <boxscape> just trying to find a placeholder constraint
16:51:46 <boxscape> actually, it looks like () counts as a constraint
16:51:51 <boxscape> strange, but fair enough, I'll take that
16:52:04 <fishythefish> if you mean () => ... that's an empty set of constraints
16:52:11 <boxscape> ohhh
16:52:15 <boxscape> that makes much more sense, thanks
16:52:23 <boxscape> I thought it was unit
16:53:03 <fishythefish> I think the fact that unit looks like an empty tuple was a conscious choice :)
16:53:11 <boxscape> you may have a point there
16:55:14 <hpc> :k () :: Constraint
16:55:15 <lambdabot> error: parse error on input ‘::’
16:55:18 <hpc> :(
16:55:21 <boxscape> :k (() :: Constraint)
16:55:22 <lambdabot> Constraint
16:55:28 <hpc> nice
16:57:12 <boxscape> so we now have (), (), (), and '(), and they all mean very different things
17:01:05 <Eduard_Munteanu> Heh.
17:01:35 <Eduard_Munteanu> :k ''()
17:01:37 <lambdabot> error: parse error on input ‘'’
17:01:43 <Eduard_Munteanu> :k '()
17:01:43 <XorSwap> :k '()
17:01:44 <lambdabot> ()
17:01:44 <lambdabot> ()
17:02:08 <Eduard_Munteanu> Technically there's ''() too.
17:02:45 <boxscape> hm, and I guess kind level () (the kind of '()) is different from type level () (the type of ())?
17:03:06 <Eduard_Munteanu> Yeah.
17:04:50 <Eduard_Munteanu> McCarthy must spin in his grave seeing how Haskell managed to type what are essentially just parens. :P
17:15:52 <nshepperd1> boxscape: i would consider them to be the same thing, now that TypeInType is a thing, i think
17:16:20 <nshepperd1> Although it's quite weird
17:17:23 <boxscape> hm, it's always a bit confusing in haskell considering the kind of Type is Type
17:20:57 <nshepperd> eg. this compiles with TypeInType http://lpaste.net/365420
17:22:43 <boxscape> I see
17:22:50 <nshepperd> which doesn't really prove that much but it's enough for me to accept that types and values can coexist as inhabitants of the 'same' type
17:23:04 <boxscape> yeah, that makes sense
17:31:37 <nshepperd> other stupid tricks with TypeInType: 'undefined :: *' is valid now
17:33:15 <nshepperd> λ> instance Show Type where { show _ = "a type" }
17:33:20 <nshepperd> λ> unsafeCoerce 4 :: *
17:33:24 <nshepperd> a type
17:35:29 <boxscape> I'm doing a bunch of type level programming right now, but I haven't really figured out yet what TypeInType would be useful for
17:37:08 <nshepperd> i don't really know either
17:37:49 <nshepperd> in my paste above it was required to be able to put a type family ("Unit") on the right of a kind signature ::
17:38:09 <boxscape> okay
17:39:15 <nshepperd> in that case the compiler told me 'use TypeInType for this!'
17:39:36 <nshepperd> so I guess if it ever becomes relevant to you, you'll know because ghc will tell you so :p
17:40:05 <boxscape> I guess so, that's pretty much how I figured out when I needed the other 20 extensions at the top of my current file
17:43:03 <nshepperd> haha
17:57:55 <dyl> TypeInType: Allow kinds to be used as types, including explicit kind variable quantification, higher-rank kinds, kind synonyms, and kind families. Implies DataKinds, KindSignatures, and PolyKinds.
17:58:33 <dyl> “Allow kinds to be as intricate as types, allowing explicit quantification over kind variables, higher-rank kinds, and the use of type synonyms and families in kinds, among other features.”
18:01:14 <boxscape> hm, interesting. I suppose I know what to do if I ever require kind level programming
18:01:33 <masaeedu[m]> I have a suspicion that all foldable, applicative monoids have a free traversable instance
18:01:37 <masaeedu[m]> but I can't figure out how to write the instance constraints
18:01:55 <masaeedu[m]> ```
18:01:56 <masaeedu[m]> instance (Applicative f, Monoid f a, Foldable f) => Traversable f where ...
18:01:57 <masaeedu[m]> ```
18:02:02 <masaeedu[m]> it doesn't like `Monoid f a` there
18:02:09 <masaeedu[m]> `forall a. Monoid f a`?
18:02:35 <lyxia> Applicative is already monoid-like
18:03:23 <boxscape> Monoid (f a), maybe? seems like you're treating Monoid as though it takes two arguments
18:03:24 <boxscape> :k Monoid
18:03:25 <lambdabot> * -> Constraint
18:04:14 <masaeedu[m]> yup, i think that was it
18:04:42 <masaeedu[m]> Monoid (f a)
18:05:44 <masaeedu[m]> lyxia: The instance I'm trying to express is the following in JS; `const sequence = A => foldl(A.lift2(b => a => append(b)(of(a))))(A.of(empty))`
18:06:02 <masaeedu[m]> where `A` is the applicative instance dictionary
18:06:27 <masaeedu[m]> `of` is `pure`, `empty` and `append` are `mempty` and `mappend`
18:08:35 <dminuoso> I have some `data Attribute = User ByteString | Pass ByteString | Addr IPv4 | Prompt Word32`. Im looking for ways to create a kind of type-safe map from some [Attribute] - what are my options?
18:09:48 <dminuoso> (The data type is simplified, in reality it's a union type of 80 similar constructors)
18:18:02 <masaeedu[m]> > s = foldl (liftA2 $ \b a -> mappend b (pure a)) (pure mempty)
18:18:04 <lambdabot>  <hint>:1:3: error:
18:18:04 <lambdabot>      parse error on input ‘=’
18:18:04 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
18:18:23 <masaeedu[m]> uh, not sure how to get it to display the type
18:19:19 <boxscape> :t foldl (liftA2 $ \b a -> mappend b (pure a)) (pure mempty)
18:19:20 <lambdabot> (Applicative f1, Applicative f2, Monoid (f1 a), Foldable t) => t (f2 a) -> f2 (f1 a)
18:20:03 <masaeedu[m]> right
18:20:06 <masaeedu[m]> so it's inferring all the right constraints
18:20:21 <masaeedu[m]> now i just need to somehow stuff it into the `sequence` of a traversable instance
18:21:45 <boxscape> so just do 'sequenceA = <your code>"?
18:22:06 <boxscape> (whoops, mismatched quotes)
18:22:50 <masaeedu[m]> ```
18:22:51 <masaeedu[m]> instance (Applicative f, Foldable f, Monoid (f a)) => Traversable f where sequenceA = foldl (liftA2 $ \b a -> mappend b (pure a)) (pure mempty)
18:22:52 <masaeedu[m]> ```
18:23:54 <masaeedu[m]> I get some kind of error about being unable to deduce monoid
18:29:17 <boxscape> I think you need to have Monoid (<the other functor> a), not (f a), but not sure how to actually write that at the moment
18:31:27 * masaeedu[m] sent a long message: masaeedu[m]_2018-05-01_01:31:04.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/mrxRFkyORHSUTNIYUfuqyAHp>
18:32:13 * masaeedu[m] sent a long message: masaeedu[m]_2018-05-01_01:31:51.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/bVEbtQbeCdYXdABrDtuXQNNd>
18:34:14 <masaeedu[m]> question is, is this a lawful instance
18:36:51 <masaeedu[m]> it also feels like i should be able to delete one of my constraints, because i'm only really using the `pure` of the `Applicative` I'm demanding to provide a free traversable
18:37:38 <masaeedu[m]> *`Applicative t` I'm demanding
18:40:50 <masaeedu[m]> unfortunately, my standard practice of recursively enabling every extension mentioned in a compiler error hsa failed me here
18:41:45 * masaeedu[m] sent a long message: masaeedu[m]_2018-05-01_01:41:23.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/AMdZfvLnEHTPkChBwEnhrcux>
18:44:49 <masaeedu[m]> maybe I need some kind of newtype wrapping to avoid the `Monoid (t a)`
18:44:57 <masaeedu[m]> which seems to confuse the compiler
19:01:35 <Eduard_Munteanu> masaeedu[m], that's surely overlapping
19:02:22 <masaeedu[m]> Sorry, I'm not familiar with what this means
19:02:34 <masaeedu[m]> does it mean it's impossible to write such an instance?
19:03:09 <Eduard_Munteanu> masaeedu[m], you probably need OverlappingInstances and it might be a bad idea.
19:07:50 <masaeedu[m]> it might be a bad idea to try and write this instance at all, or to write it the specific way I'm doing?
19:08:15 <masaeedu[m]> if the latter, what's a more idiomatic way to do it?
19:09:10 <Eduard_Munteanu> masaeedu[m], at all, you should probably write specific instances for what you need.
19:11:12 <masaeedu[m]> that's a shame, I thought it would be possible to express this in Haskell
19:11:27 <masaeedu[m]> I supposed you'd have to use newtype wrappers to make things unambiguous
19:12:03 <Eduard_Munteanu> masaeedu[m], you can use a newtype to provide such an instance
19:12:34 <Eduard_Munteanu> instance ... => Traversable (FromFoldable t)
19:13:47 <Eduard_Munteanu> That no longer overlaps with anything.
19:14:43 <dyl> I wish it were possible with newtypes to explicitly derive instances from the base type.
19:14:56 <dyl> If say I want to keep the original instances for certain classes.
19:15:08 <dyl> I mean I know it can be done, but it’s a bit of a pain.
19:15:37 <dyl> Opt-in newtype instance inheritance, basically
19:15:51 <Eduard_Munteanu> dyl, are you aware of GeneralizedNewtypeDeriving?
19:15:57 <dyl> Oh does that do that?
19:15:59 <dyl> Makes sense.
19:21:52 <dmwit> albeit: Yes, but you will still need to think about whether you intend that to be `StateT s (Except e)` or `ExceptT e (State s)`, as they have different meanings.
19:23:11 <dyl> What about StexceptT st (Exstate ts)?
19:24:00 <dyl> Not to mention ExstateT ts (Stexcept st)
19:25:10 <iqubic> Is StexceptT different from ExceptT?
20:05:20 <adam5> GE NES IS ... XBOX, NINTENDO, SEE... TEN NES SEE.... now see Silicon in Genesis: proof you are in the Matrix, in virtual reality--and how it will end disease, hunger, and help us build Heaven. http://DOUCI.ML/FINALE.html
20:08:11 <capisce> adam5: have you run it through a proof checker?
20:47:48 <professor_rocket> exit
20:58:22 --- mode: ChanServ set +o glguy
20:58:22 --- mode: glguy set +q *!*@139.162.161.37
22:16:49 <dyl> adam5: uhhhhh
22:16:51 <dyl> What?
22:16:58 <Axman6> it's spam, ignore it
22:17:24 <dyl> Axman6: that aside... 65 WAT
22:18:48 <dyl> Axman6: untreated schizophrenia?
22:31:44 <Axman6> spam
22:37:20 <iqubic> How long until dependent Haskell becomes a thing?
22:39:19 <iqubic> I know you can do interesting things with dependent types like make a pair type whose inhabitants are (a, b) where a > b.
22:39:36 <iqubic> for some (ord a, b).
22:44:52 <dyl> Frontier
22:44:55 <dyl> Frontier
22:45:04 <dyl> Frontieeer psychiatrist
22:45:32 <MarcelineVQ> he was white as a sheet
22:45:39 <dyl> And he also made false teeth.
22:46:21 <dyl> MarcelineVQ: if you didn’t think Wildflower was quite as good, listen to Subways on a pair of good headphones or a surround system.
22:46:30 <dyl> The way it plays with the channels is incredibly satisfying.
22:47:00 <dyl> <it moves around>
22:47:19 <dyl> On cheap headphones it just doesn’t work.
22:47:22 * hackage HCodecs 0.5.1 - A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files.  http://hackage.haskell.org/package/HCodecs-0.5.1 (Mokosha)
22:47:32 <dyl> On a good amplified set of cans or surround system it’s magical.
22:47:45 <dyl> It feels like you’re spinning.
22:48:21 <dyl> I wasn’t into it, then I threw it on my amplifier/cans, and I couldn’t stop grinning.
22:48:48 <dyl> It’s even better with full room 7.1 surround
22:49:00 <dyl> It’s less a song than an art piece.
22:49:16 <dyl> (Which does mean it’s not good on its own as a song,)
22:49:20 <dyl> (but...)
22:49:48 <iqubic> Is this the haskell channel, or the talk about songs/sound channel?
22:51:21 <dyl> This is Late Nite Haskell
22:51:26 <MarcelineVQ> dyl: I don't really like avalanches. But I really like frontier psychiatrist
22:51:27 <Axman6> delivdefinitely the former
22:51:28 <dyl> It gets lazier.
22:51:35 <Axman6> dyl: it's mid afternoon
22:51:41 <dyl> MarcelineVQ: they’re easier to appreciate with better audio systems.
22:51:45 <Axman6> bloody americans
22:51:47 <dyl> What they do isn’t really music.
22:51:53 <dyl> Axman6: u wot mate?
22:51:58 <dyl> ;-)
22:52:01 <Axman6> mate, take it to #haskell-blah
22:52:25 <dyl> Axman6 :: Either Buzzkill Right
22:52:38 <dyl> (It’s the latter.)
22:53:07 <dyl> Mid afternoon... are you in AUS?
22:53:20 <dyl> Or do I just have no concept of time?
22:53:22 <Axman6> yes
22:53:45 <dyl> Well, that answers neither question yet both.
22:53:51 <dyl> Apologies.
22:54:33 <iqubic> dyl: Usually people use the Left type to repersent the failiures, an the Right type to repersent the success. So Axman6 probably right.
22:54:44 <dyl> That was the joke.
22:54:50 <iqubic> but then again, I don't care what we talk about here.
22:55:14 <iqubic> dyl: I know. I liked the joke.
22:55:28 <dyl> You shouldn’t have. It was horrible.
22:55:29 <dyl> ;)
22:56:13 <iqubic> eh. It was good.
22:58:21 <dyl> For some definition of good...
22:59:57 <dyl> What is the official song of Haskell?
23:00:17 <MarcelineVQ> tachyon
23:03:53 <dmj`> dyl: eye of the tiger
23:28:32 <dyl> It’s the, I of the tiger
23:28:47 <dyl> It’s also a tiger
23:43:37 <dminuoso> Good morning. I have a list of a data type that is basically a massive union `data Attribute = User ByteString | Pass ByteString | Addr IPv4 | Prompt Word32` (simplified). I want to transform my [Attribute] into some type safe map where I could specify (pseudo code) `get "User"` and I'd get some [ByteString] or equivalent back.
23:44:06 <dminuoso> Now I realize this won't be possible directly. Im willing for anything equivalent that at least gives me the same type safety guarantees.
23:45:43 <cocreature> dminuoso: just write a fold that inserts the values in a map?
23:45:59 <dminuoso> cocreature: A single map?
23:46:00 <cocreature> oh nvm, now I see the problem
23:46:17 <cocreature> I’d just make multiple sets
23:46:19 <cocreature> or lists
23:46:31 <dminuoso> cocreature: There's around 80 constructors or so..
23:47:07 <dminuoso> Is this SYB territory? Should I be looking for some Generic based solution?
23:47:46 <dminuoso> Also I dont want to have to scan the list 80 times just to extract all possible constructors.
23:47:56 <dminuoso> Ideally I want this to be done in O(n(
23:50:33 <dminuoso> To make things more annoying there's some data constructors that have multiple fields. And to top it all off, it's an external library.
23:53:32 <dminuoso> Would this be a dependently typed map?
23:54:02 <dminuoso> https://hackage.haskell.org/package/dependent-map-0.2.4.0/docs/Data-Dependent-Map.html
