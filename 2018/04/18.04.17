00:00:05 <pimlu> could be that if you want
00:00:21 <pimlu> my trouble is I don't know how to handle the cycles with already seen nodes
00:00:25 <vaibhavsagar> you can have a set of visited nodes
00:00:29 <dminuoso> honky: A problem with Compose, is that the composition of two monads is not necessarily a monad.
00:00:50 <cocreature> honky: well it depends on what you do in that s -> (a,s) function and what you want to print. if you use >>= (or do notation which will desugar to that) you need a Monad instance
00:01:49 <vaibhavsagar> pimlu: suppose you have `data Graph a = Graph { vertices :: Set a, edges :: a -> Set a }`
00:02:24 <pimlu> vaibhavsagar: I guess my problem is, I can write code to make this work using a set of seen nodes, but my idea feels like a bastardization of an imperative DFS designed to work in haskell
00:02:32 <pimlu> rather than traditional haskell code
00:02:39 <honky> cocreature: hrm, i guess i'd need at least (*>) in order to print and then calculate the new state, right?
00:03:01 <Boomerang> What if you use the set of vertices that already exists and "tag" the nodes as visited.
00:03:04 <vaibhavsagar> pimlu: algorithms that depend on mutable state usually feel like that in Haskell land
00:03:12 <frerich> pimlu: I think given that your graph may have cycles, keeping track of seen vertices makes perfect sense.
00:03:15 <vaibhavsagar> but they are a good and useful starting point
00:03:33 <pimlu> frerich: yeah, I think it's necessary too, I just don't know how to make it pretty/maintainable
00:04:01 <frerich> pimlu: If you like, you could make it 'Haskellish' by using a 'State (Set a)' or so, i.e. not passing the set of seen vertices around explicitely. It's still really just a set behind the scenes though. :-)
00:04:05 <Boomerang> Using vaibhavsagar's type, you can set `a` to be `(Bool, b)` where you can "tag" a node as visited
00:04:10 <dminuoso> honky: What's wrong with just `StateT A IO` anyway?
00:05:13 <pimlu> yeah, true
00:05:30 <vaibhavsagar> what do you want the output of your DFS to be?
00:05:45 <cocreature> honky: I’d say stick to StateT s IO rather than trying to use Compose unless you have a good reason not to
00:05:47 <vaibhavsagar> does it have to be ordered?
00:06:04 <honky> dminuoso: well that's what i'm in, but i have a `state` action that is mostly IntMap.alterF :: Functor f => (Maybe a -> f (Maybe a)) -> Key -> IntMap a -> f (IntMap a)
00:06:12 <pimlu> order doesn't matter
00:06:51 <vaibhavsagar> just a Set of vertices then?
00:06:57 <pimlu> nah, a list
00:07:00 <frerich> pimlu: For this kind of 'travese structure, keep track of seen nodes' problem, I always end up with 'f = evalState (go startPos) Set.empty' and 'go' is a function of type 'Pos -> State (Set Pos) a' and it does 'do { seen <- get; if pos `Set.member` seen then doThis else do { modify (Set.insert pos); doSomethingForUnseen } }'
00:07:05 <pimlu> as long as there exists an order of adjacents that a DFS could product the output
00:07:15 <vaibhavsagar> so you want it to be partially ordered
00:07:26 <pimlu> basically, I just am constraining this to not allow a BFS as valid output as a thought problem
00:07:36 <honky> dminuoso + cocreature: and since alterF works in any functor, i was thinking there might be a way to sneak some stdout into the (Maybe a -> f (Maybe a))
00:07:39 <pimlu> because I know how to do that without too much ugliness
00:08:23 <vaibhavsagar> and do we get a starting vertex for the DFS?
00:08:27 <pimlu> yeah
00:08:37 <pimlu> so technically with the starting vertex and a -> [a] as the adjacents
00:08:41 <pimlu> it would be deterministic
00:08:48 <vaibhavsagar> not necessarily
00:09:00 <vaibhavsagar> because Sets don't have an order
00:09:10 <pimlu> that's why the function returns a list
00:09:24 <honky> cocreature: i'll try out the StateT constructor method, just wanted to understand how the Compose idea would work -- sounds like there would be some way?
00:09:28 <vaibhavsagar> no, that's not enough
00:09:42 <vaibhavsagar> I take a vertex a and feed it to my edges function
00:09:50 <vaibhavsagar> what do I get back? a Set
00:10:01 <pimlu> from the type a -> [a]? I don't think so
00:10:05 <frerich> pimlu: This is a function I once wrote for finding all pieces on a board which are 'connected' (i.e. which are adjacent) and which belong to a given player: http://lpaste.net/7990299020801081344 -- I think it wouldn't take a lot of adjustments to make that work for you.
00:10:14 <vaibhavsagar> I thought you said I could have a -> Set a if I wanted
00:10:37 <pimlu> yeah, so that's why I changed the types back when I said "with the starting vertex and a -> [a] as the adjacents"
00:10:37 <vaibhavsagar> okay, that makes things easier
00:10:47 <pimlu> I see where we got mixed up
00:11:00 <cocreature> honky: Compose is an alternative to StateT if you don’t need monadic operations. it won’t solve the “how do I embed (s -> m (a, s))” function magically
00:11:03 <Unhammer> I have a bunch of "growth rates", functions of type Celcius→Gram→Double , I'm looking up their names in a table, collecting some other stuff and eventually applying them. Currently kind of like https://repl.it/repls/HilariousImpishShell – but is this the best way to represent things when you have a class of functions of the same signature like that?
00:11:15 <cocreature> honky: if you’re already in StateT then Compose won’t buy you anything
00:11:45 <Unhammer> ie. simple "data M = A|B|C" and a handwritten dispatcher
00:11:48 <pimlu> frerich: thanks, I'll check that out
00:13:36 <honky> cocreature: k, thanks for the help!
00:13:50 <frerich> Unhammer: I think you could drop the data constructors for `Model` and just have something like `newtype Mode = Model { rate :: Celsius -> Gram -> Double }'. That way, you could do the 'dispatch' in 'main' directly.
00:14:02 <fishythefish> Unhammer: if the only purpose of Model is to select a function, you could just pass in the function as a parameter instead
00:14:56 <marmistrz> Is it possible to disable the -Wall flag on a per-file basis (I'm currently using Stack)
00:15:17 <marmistrz> I have a file, which is autogenerated by Happy, so it yields a ton of warnings
00:15:44 <marmistrz> though, I'd like to have -Wall for the rest of my project
00:17:20 <cocreature> marmistrz: you can add an OPTIONS_GHC pragma to the file but afaik you have to disable individual warnings since there is no -Wno-all
00:18:39 <Unhammer> frerich, like
00:18:42 <Unhammer> parsemodel "Foo112" = Just (Model rate_foo112)
00:18:44 <Unhammer> ?
00:18:55 <Cale> I wonder if you can do something like -w -W to get something pretty close
00:19:22 <Cale> -W apparently includes a bunch of nonstandard warnings
00:19:48 <robstr> What is the recommented way of reading a configuration file ?
00:19:53 <Cale> but given that the file is generated, -w on its own is probably fine :P
00:20:07 <Cale> robstr: What format does the configuration file have?
00:20:21 <robstr> Cale: I'm free, maybe yaml but doesnt matter
00:20:38 <robstr> Cale: something that is flexible and nice to use :)
00:20:40 <Cale> There are definitely yaml and json libraries
00:20:44 <Unhammer> that does seem simpler, thanks frerich
00:20:47 <cocreature> I’ve often used the "yaml" lib for config files
00:21:03 <Cale> For json, probably aeson
00:21:06 <robstr> cocreature: ty, i will give it a try :)
00:21:27 <Boomerang> You could checkout dhall! :D
00:22:21 <Ariakenom> pimlu, if you want FP feeling graph algorithms you can definitely look at the suggested fgl for inspiration.
00:22:32 <frerich> Unhammer: Yes, that's the idea (fishythefish was suggesting the same idea :-)
00:23:09 <Ariakenom> dhall is a cool config language. as such I've never used it
00:23:11 <fishythefish> yup, modulo the wrapping in a Model type
00:24:41 <honky> cocreature: the StateT constructor worked, thanks!
00:27:15 <honky> cocreature: huh i didn't need the liftIO, i don't get why...
00:27:40 <cocreature> honky: take a look at the type of the StateT constructor
00:27:49 <cocreature> the "m" will just be "IO" in your case
00:28:56 <Unhammer> :)
00:32:08 <vaibhavsagar> pimlu: https://gist.github.com/vaibhavsagar/5d787d7f142180172482311870f0816d
00:32:43 <honky> cocreature: i see that, but i'm calling StateT in the do block of a StateT (I.IntMap [Char]) IO (), i thought i'd need liftIO in there...
00:33:09 <cocreature> :t StateT
00:33:10 <lambdabot> (s -> m (a, s)) -> StateT s m a
00:33:25 <cocreature> honky: you pass it a function (s -> IO (a, s)) and it gives you back a StateT s IO a
00:33:30 <cocreature> no need for liftIO
00:34:18 <cocreature> you would need liftIO if you were trying to embed something of type IO a in StateT s IO a directly
00:34:39 <honky> cocreature: ah ok my mind had stopped at the IO (a,s), thanks!  too tired i guess...
00:46:38 <marmistrz> cocreature, and would it be possible to have *two* libraries in a stack project?
00:46:47 <pimlu> vaibhavsagar: thanks, I think I understand
00:47:12 <marmistrz> something like https://zerobin.net/?e890cb542001fdad#WEioExtwB8mATw3cJceVQiHAOO25/uKi4f3an4oMlLQ=
00:49:02 <vaibhavsagar> pimlu: great :)
00:49:20 <cocreature> marmistrz: it seems like your question is more “can I have two libraries in a cabal package”. a stack project can consist of multiple cabal packages. the answer to that is mostly no, newer versions of Cabal support internal libraries and you can have multiple of those but since they’re internal they often don’t help
00:57:59 <robstr> Is is possible to use `catch` for all exceptions ?
00:58:33 <merijn> robstr: Yes, just catch SomeException
00:59:17 <marmistrz> cocreature: thanks, I think I'll just end up adding -Wall to individual files using GHC OPTIONS
00:59:55 <merijn> -Wall all the things!
01:03:57 <robstr> merijn: Ok, I'm using the websocket (wuss) package, http://lpaste.net/364902 but it is complaining Ambiguous type variable ‘e0’ arising from a use of ‘catch’
01:04:39 <merijn> robstr: It's because it can't infer the type from your lambda
01:05:03 <t__> hi
01:05:05 <merijn> robstr: If you have a handler with an explicit signature it'd work. Or you can change the lambda to "\(SomeException _) -> return ()"
01:05:24 <merijn> :t Control.Exception.catch
01:05:26 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
01:06:11 <merijn> robstr: The 2nd argument of catch can accept any exception. The lambda you gave can except *any* type. So it could be trying to catch literally any exception. So it's complaining it's ambiguous which type you *are* trying to catch
01:08:19 <hk_> hi
01:08:44 <robstr> merijn: makes sense, thank you really much
01:08:50 <robstr> and now it compiles ;)
01:09:15 <merijn> robstr: This is why I usually make sure my handlers are defined in a where block with explicit type signature to avoid the problem :)
01:11:18 <robstr> merijn: I will try to remember this :P
01:12:57 <merijn> robstr: In general any error including "ambiguous type" just means "shit's to polymorphic and I'm refusing to guess which type you meant, add some type signatures"
01:14:55 <robstr> merijn: yea but i did (\_ :: SomeException ....) but this was not ok (missed the import and did not read the long error message) haha
01:16:14 <robstr> Today I received `Parallel and Concurrent Programming in Haskell`, I heared only good stuff about it... maybe this book will give me more insights to exception handling in haskell :P
01:17:28 <tian_> that animal book?
01:18:45 <ertes> i finally sat down and benchmarked attoparsec against a hand-crafted MaybeT (State ByteString):  a small structural PNG validator (check header, existence of certain chunks, CRC, etc.)
01:18:53 <merijn> "that animal book" could be literally any O'Reilly book
01:19:10 <ertes> accepting a PNG file takes about the same time for both of them
01:19:22 <ertes> however, the hand-crafted parser is much faster at *rejecting*
01:19:58 <robstr> tian_: haha yea the fish one :P
01:20:50 <ertes> i also benchmarked against 'binary':  it's also as quick as the other two at accepting, but has the worst rejection performance
01:28:06 <cocreature> robstr: note that catching all exceptions is usually a bad idea. you end up doing things like catching things like UserInterrupt and break Ctrl+C to exit your program
01:28:47 <jackcrfs> newbie question: do u recommend using OverloadedStrings, seems to make things easier?
01:29:14 <merijn> jackcrfs: I think most people don't have strong opinions on it
01:29:18 <Ariakenom> cocreature, Is there a Exception for all synchronous then?
01:29:31 <merijn> jackcrfs: The extension itself is fine if it simplifies things, but there's a bunch of questionalbe instances
01:29:48 <merijn> Ariakenom: Snoyberg has a library for that, I think
01:30:04 <cocreature> Ariakenom: not really, the safe-exceptions package tries to do that but there is nothing that enforces that you use exceptions in the way it expects
01:30:09 <merijn> @hackage safe-exceptions
01:30:09 <lambdabot> http://hackage.haskell.org/package/safe-exceptions
01:30:35 <ertes> here is the benchmark, if anyone cares: https://gist.github.com/esoeylemez/fdb96b409e90fbbe99385995b7d3d3ce
01:30:36 <Ariakenom> that's too bad
01:30:38 <ertes> the results are at the bottom
01:31:07 <jackcrfs> would putting {-# LANGUAGE OverloadedStrings #-} at top of file only affect the current file?  if that's so, I might trial and error on a per file basis?
01:31:27 <merijn> jackcrfs: Yes, that only affects the current file
01:31:52 <jackcrfs> thanks!
01:32:01 <tsahyt> jackcrfs: to enable an extension globally, you need to put it into the cabal file
01:32:16 <jackcrfs> thanks!
01:32:29 <tsahyt> see here for a guide to enabling extensions https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/how-to-enable-extensions
01:32:53 <jackcrfs> thanks
01:33:30 <robstr> cocreature: true,
01:33:51 <Ariakenom> safe-exceptions' readme seems nice
01:36:27 <merijn> jackcrfs, tsahyt: tbh, I (and many others) feel that enabling an extension globally is a Bad Idea (TM)
01:36:39 <tsahyt> I generally dislike it too
01:36:54 <tsahyt> OverloadedStrings is one of those which I don't mind to enable globally, but I still prefer to do it on a per module basis
01:37:12 <cocreature> you can take default-extensions from my cold dead hands
01:37:24 <tsahyt> especially in projects that make pervasive use of (e.g.) Text literals, global OverloadedStrings makes some sense I suppose
01:37:59 <jackcrfs> personally I don't like doing too much things in global too.
01:38:09 * hackage rdf4h 3.0.3 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-3.0.3 (RobStewart)
01:41:23 <lemmih> cocreature: Are you one to talk to about llvm-hs-pretty?
01:41:36 <cocreature> lemmih: I guess so :)
01:41:50 <jackcrfs> er, a VERY stupid question.... after I import Data.Text; I can ":t length", but I cannot ":t Text", why?
01:42:14 <vaibhavsagar> jackcrfs: I don't think `Text` is a constructor
01:42:16 <cocreature> jackcrfs: because :t gives you the type of a value and Text is a type not a value
01:42:26 <jackcrfs> ah.
01:42:42 <power-fungus> I have seen that in System.Random, there is no instance (Random a, Random b) => Random (a,b). Why is this the case?
01:42:45 <lemmih> cocreature: I'd like to improve the test suite but I'm not sure which properties can be tested. Testing the parsing/printing round trip seems nigh impossible.
01:42:48 <jackcrfs> so if I know Data.Text.Text is a type, how do I find out more about it in the interpreter?
01:43:14 <vaibhavsagar> jackcrfs: :k
01:43:33 <jackcrfs> thanks
01:43:35 <power-fungus> jackcrfs: :i Text
01:44:10 <liste> power-fungus: there's no instances for any compound types
01:44:27 <liste> power-fungus: no Maybes etc either
01:44:34 <power-fungus> liste: I see that. but Why?
01:45:19 <lemmih> cocreature: Think it would be worth it to do something tricky like sorting defintions such that module asts can be compared both before and after pretty-printing?
01:47:33 <cocreature> lemmih: yeah that’s probably a good idea. I’ve thought about doing something like that but haven’t gotten around to it so far
01:48:02 <Logio> power-fungus: taking multiple random numbers and combining them is usually a tricky business
01:49:15 <merijn> cocreature: One step closer to solving your warning issue with new-build ;)
01:49:54 <Logio> power-fungus: for instance, (Random a) => Random (a, a) can be very different from (Random a, Random b) => Random (a,b), math-wise
01:50:02 <lemmih> cocreature: What's a good way to normalize a module? It feels kinda awkward to define an Ord instance for Definitions.
01:50:09 * hackage HMap 1.3.0 - Fast heterogeneous maps and unconstrained typeable-like functionality.  http://hackage.haskell.org/package/HMap-1.3.0 (AtzeVanDerPloeg)
01:50:10 <frerich> My son recently devised a nice method for coming up with random numbers: he thinks of a random number, but then - instead of choosing it - he immediately thinks of a _different_ random number. :-)
01:50:24 <cocreature> lemmih: it might be best to just rountrip the textual IR through LLVM and let it take care of sorting
01:50:33 <cocreature> but I haven’t thought through the details
01:50:57 <lemmih> cocreature: Testing the full parse/print/parse round trip uncovered a typo in llvm-hs-pretty, btw. But lots of other tests also fail because of defintions that have been reordered. :-/
01:51:21 <lemmih> cocreature: Hm, interesting. I'll try.
01:51:41 <power-fungus> logio: why that? All random computations give another random generator that can be used to generate something random a different type next
01:52:39 <power-fungus> I dont see the problem with defining such instances in the manner like in https://stackoverflow.com/questions/13669803/generate-random-tuples-haskell#13669958
01:53:07 <cocreature> lemmih: it’s also not only ordering that causes problems, e.g., for metadata you also have the option of defining things inline vs defining them separately and referencing them via their id
01:53:33 <Logio> power-fungus: I'm not saying it's computationally incorrect to do, I'm saying that you need to know what kind of properties you need from your tuples of random numbers
01:54:55 <Ariakenom> more so than you need for your other (Random a=>a)?
01:55:20 <cocreature> merijn: nice!
01:55:23 <Taneb> Random (a, a) could always return pairs of the same thing, like fmap (\x -> (x, x)) random
01:55:40 <Taneb> Heck, Random (a,b) could use the same seed for both a and b
01:56:07 <Logio> as an example, if your PRNG does not repeat (has a state of a single previous number), it is very hard to generate coordinates on a plane from a single generator
01:56:50 <Ariakenom> obviously the random number for Int should be 4. It's verified random.
01:57:27 <merijn> I have a new PR that has the actual GHC and haddock filtering stuff in there together with Alex's haddock fixes. (The only issue is that Alex's changes might have broken custom-setup?), but if you don't need that it'd be nice if you can test it
01:57:31 <Logio> if you take two consecutive random numbers from the same generator in that case, you will never generate a point on the diagonal (i.e. (a, b) with a == b)
01:58:06 <merijn> cocreature: (Un?)fortunately flag changes still trigger rebuilds of all local packages, but I'm 1) not sure if that's easily fixable and 2) not even sure whether that's undesirable
01:58:24 <merijn> cocreature: But for all non-local dependencies it's working great for me
02:00:58 <zincy> Whats best practice for using *> vs >>
02:01:05 <merijn> cocreature: And as long as packages don't have -Werror in their ghc-options it properly ignores warning flags too
02:01:18 <merijn> zincy: toss a coin and pick one ;)
02:01:18 <cocreature> merijn: sounds pretty good!
02:01:32 <merijn> cocreature: https://github.com/haskell/cabal/pull/5266
02:01:59 <cocreature> zincy: if you’re polymorphic in the type use *> since it’s more general, otherwise it doesn’t matter but to keep things simple I just always use *>
02:02:04 <merijn> zincy: *> is the most general one, but out of habit I often end up using >>
02:02:10 <Ariakenom> zincy, const (*>)
02:02:25 <merijn> Somehow I find >> nicer looking combined with >>=
02:02:35 <merijn> But at that point you have a Monad constraint anyway
02:03:39 <merijn> cocreature: Next up, my prototype for properly doing error/warning highlighting in vim with new-build :p
02:04:10 <zincy> Thanks!
02:04:39 <cocreature> merijn: and only a year after you’ve started this odyssey you can stop procrastinating and get back to writing the code you’re supposed to write ;)
02:04:49 <merijn> zincy: Basically, >> probably wouldn't have existed, except we happened to invent Monad before Applicative :p
02:04:55 <dminuoso> merijn: *> should be learned over >> as a beginner I think, because it helps see that the mere sequencing works with Applicative already =)
02:05:02 <merijn> cocreature: It's amazing how productive you are when you procrastinate from writing your thesis
02:05:45 <merijn> cocreature: See, I just expect to be hailed as a hero and get bought free beer at the next FP conference I attend :p
02:05:57 <merijn> Taking one for the team, etc. :p
02:06:01 <lemmih> cocreature: Are 'withModuleFromAST' and 'moduleAST' complete?
02:06:17 <cocreature> lemmih: complete in what sense?
02:07:29 <lemmih> cocreature: Is '(\m -> withModuleFromAST cxt m moduleAST) :: Module -> IO Module' roughly the identity function ?
02:07:59 <lemmih> I use it to normalize the AST but definitions are going missing.
02:08:20 <cocreature> do you have an example?
02:08:42 <cocreature> LLVM sometimes throws away stuff that you don’t use
02:09:27 <lemmih> The COMDATs in tests/input/global.ll disappear somewhere in the parse/print/parse cycle.
02:10:14 <cocreature> hm could just be a bug. a good first step is to test if roundtripping via "opt -S" also throws them away
02:10:44 <cocreature> if it does then there is probably little we can do about it, if it doesn’t open an issue and I’ll try to take a look at it
02:12:30 <lemmih> Ah, I think I got it. It's a bug in llvm-hs-pretty. Phew.
02:12:57 <lemmih> COMDATs aren't referenced in globals so they're thrown out by llvm.
02:13:25 <cocreature> yeah makes sense
02:18:21 <mircublue123> ..
02:18:21 <Unhammer> I liked http://reasonablypolymorphic.com/blog/higher-kinded-data – but how would one access the field that failed to validate (e.g. to log it, or to tell the user what's wrong)?
02:19:17 <cocreature> lemmih: depending on what you see as the goal of llvm-hs-pretty it is very reasonable for it to not throw out unreferenced things. so far it’s mostly targetted at debugging and for that it’s often useful to jut get a more readable version of the AST
02:20:05 <dminuoso> Unhammer: Same idea. Generics let you get field names.
02:20:36 <lemmih> cocreature: But '@g36 = external global i32, comdat($com1)' should not be printed as '@g36 = external global i32' which is currently the case.
02:20:55 <cocreature> heh right, that does look like a bug :)
02:21:27 <dminuoso> Unhammer: Or you could just use `Either String` and keep the field name in the error message somehow.
02:23:31 <Unhammer> ooh that was simple :)
02:24:16 <Unhammer> I first tried putting Either in there, but couldn't figure out how to make all those instance GValidate's handle lefts and rights
02:24:23 <dminuoso> Unhammer: I think it's somewhat cleaner if you use generics though.
02:24:28 <dminuoso> It's less redundant and gives you more freedom.
02:24:45 <Unhammer> yeah, except I'll have to first learn how it all works =P
02:25:10 <Unhammer> I don't understand half of it yet :)
02:25:31 <dminuoso> Unhammer: Do you understand typeclasses and context well enough?
02:27:47 <Unhammer> typeclasses sure, contexts no idea, this is the first time I've opened the docs to GHC.Generic
02:29:01 <Unhammer> or, I see what FlexibleContexts brings
02:29:06 <dminuoso> Unhammer: Oh by context I just mean using `(F a) => F (G a a)` for example
02:29:15 <dminuoso> Unhammer: As a way to kind of "recurse" into types
02:29:46 <Unhammer> oh, so that's what that's called :)
02:29:56 <dminuoso> Unhammer: The left portion of `=>` is called context
02:30:16 <dminuoso> Or rather the whole construct `(...) =>`
02:33:42 <dminuoso> Unhammer: It just boils down to: GHC provides you with two function `from` and `to` that convert a Haskell object into a generic form, and an associated type `Rep` that has the same shape as the generic representation.
02:33:57 <merijn> hmm, is there a lens that maps an (a -> m a) over State?
02:34:43 <Taneb> merijn: what do you mean by that?
02:34:49 <lemmih> cocreature: Sigh, some constant folding is happening somewhere which generates a repeating (and thus) invalid floating point number. Not sure if doing a full parse/print/parse cycle is worth it.
02:35:44 <cocreature> lemmih: yeah all these little annoying things are why I haven’t bothered doing this so far ;)
02:35:52 <Unhammer> that makes it a bit clearer, thanks dminuoso. I guess I should play around with it some more
02:36:02 <merijn> Taneb: I have a lens to an 'a' inside MonadState m and want to a function "a -> m a" (where 'm' is the same MonadState) to update the 'a'
02:36:40 <merijn> There's (<~) but that just runs an action without passing in the initial value
02:36:57 <Taneb> So... Lens' s a -> (a -> m a) -> StateT s m ()
02:37:16 <merijn> Something along those lines, yeah
02:37:41 <kuribas> merijn: something like zoom?
02:37:42 <kuribas> :t zoom
02:37:44 <lambdabot> Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
02:37:56 <dminuoso> Unhammer: The beauty of that associated type is that you suddenly get compile time guarantees about generic code, which is amazing. :)
02:38:01 <merijn> kuribas: That doesn't look like what I'm asking for at all?
02:38:27 <lemmih> cocreature: 7 tests still fail now. 4 because meta data gets shifted around, 2 because of comdats, 1 because of the float issue.
02:38:28 <Taneb> Zoom hits the keywords but it's not the right thing
02:38:34 <Taneb> merijn: I can't think of anything, sorry :(
02:39:15 <lemmih> cocreature: Oh well, I'll just submit PRs for the missing parts I found so far.
02:39:28 <merijn> I can just use <~ but then I'm redundantly reading the data on the right hand
02:40:36 <lemmih> cocreature: It'll probably be easier to add new tests which are executed. Then the output before and after pretty-printing can be easily compared.
02:40:51 <merijn> Taneb: Basically, right now I have this: http://lpaste.net/364913 but that's ugly as sin
02:41:18 <merijn> kuribas: With zoom I still need some way to apply a monadic function to the current state
02:41:40 <Unhammer> hm, compared to the compile-time guarantee of 90 pages of <te<m<pl<a>te>> errors I'm used to from C++, that does sound cool =P
02:41:44 <merijn> I can do "zoom (projectState . fileMappings) $ do ..." but then what is '...'?
02:42:42 <merijn> I suppose that has the upside of shortening things to "id <~ M.delete <$> use currentFile <*> use id", but that's not particularly amazing either
02:43:08 <__marco> Hello. I was looking at the library safe-money with zero knowledge of Haskell. At the paragraph[1] the author talk about a "compiler error" when different currencies are mixed. Is this actually a real compile error or just a runtime check? What are these "BTC" and "JPY" from the language point of view? Are they instances or types or something else Haskell specific?
02:43:14 <__marco> [1] https://ren.zone/articles/safe-money#currency-conversion
02:43:43 <Ariakenom> machinedgod, actual compile time error
02:43:44 <merijn> I need a monadic version of %= or a function version of <~ . Seems weird no one else ever needed those
02:44:01 <Ariakenom> __marco, actual compile time error
02:44:49 <__marco> Ariakenom: And what about "JPY" are they types? Because I interpreted them as instances, but as long as I know compiles checks for types, not instances
02:44:53 <Ariakenom> __marco, "BTC" and "JPY" are types..
02:45:12 <Ariakenom> __marco, the article doesn't lie :)
02:45:12 <merijn> __marco: Note that Haskell doesn't really have a notion of "instances" the way that most OO languages do
02:45:20 <__marco> Ariakenom: Ok, this makes sense to me
02:45:33 <merijn> __marco: There's no such thing as instances subtyping some existing type
02:46:02 <__marco> merijn: unfortunately I speak OO only
02:46:13 <merijn> __marco: Basically, it's using a common trick called "phantom types", which is a generic datatype where the generic type isn't used anywhere
02:46:51 <merijn> __marco: I assume some (made up, because I forgot proper Java) syntax like "class List<T> { T head; List<T> tail; };" makes sense to you?
02:47:09 <__marco> merijn: yep
02:47:17 <EveryTian> what does that "phantom types" mean?
02:47:32 <merijn> __marco: Right, so a phantom type would be doing something like "class Dense<T> { int value; };"
02:47:45 <merijn> EveryTian: Phantom, because it doesn't "have a body" :)
02:47:46 <kuribas> merijn: is the "a" part of the state?
02:47:51 <merijn> kuribas: Yes
02:47:56 <EveryTian> Oh, I see
02:48:25 <__marco> merijn: thanks for the explanation.
02:48:42 <Ariakenom> __marco, "BTC"is ofc not a value with the type String. But just share's the syntax.
02:48:52 <merijn> __marco: So, the generic T isn't actually used in the runtime value there. But it still exists for the typechecker and the same way you can't do concatenate List<Integer> with List<Bool> you can't add two Dense types with different generic parameters
02:49:10 <__marco> I see
02:49:33 <__marco> very interesting and that library seems very nice, hence my interest
02:50:53 <kuribas> merijn: MonadState s m => Lens' s a -> (a -> m a) -> m ()  ?
02:51:03 <merijn> kuribas: yeah
02:51:47 <merijn> Like the paste I can approximate it with <~, but that just feels really redundant
02:58:04 <tian___> nick tian_
02:58:13 <cibHaskell> "hi"
02:58:16 <tian___> sorry...
02:58:20 <dminuoso> Unhammer: Here is an example implementation: https://gist.github.com/dminuoso/82b57e761c53ed540478db1117be1451
02:59:43 <dminuoso> Unhammer: This is something that C++ simply cant do. You get compile time reflection about types. =)
03:00:29 <dminuoso> Unhammer: You can try this with `toErrs $ User (Just "Isaac Newton") Nothing` or `User Nothing Nothing`
03:01:35 <cibHaskell> "I am using parsec to implement a Number parser. And it supports both float and int, but I can only parse either int or float, how to combine them? Here is my code https://gist.github.com/Icarus0xff/da57a3214362de7ed197dc16b9cd2121"
03:04:08 <dminuoso> By the way. Is there any way around the type application in this? `symbolVal @f Proxy` seems kind of silly.
03:05:43 <electrocat> cibHaskell: so you want you parser to try float and if that fails try int right?
03:06:30 <ertes> cibHaskell: note that (p <|> q) only tries q, if p fails *and consumes no input*
03:06:37 <pi3r> Does someone know why foldl1' is not defined in Data.Foldable ?
03:06:38 <ertes> cibHaskell: you need to use 'try'
03:07:41 <electrocat> ertes: i thought it does try q but continuing from where it already consumed the output
03:08:07 <ertes> cibHaskell: the maximally proper way to do this is to this is:  parseDecimal = do di <- try (many1 digit <* char '.'); …
03:08:34 <kuribas> merijn: zoom l (get >>= f >>= put) ?
03:08:36 <dminuoso> Okay Im really not sure what the purpose of the Proxy is in here..
03:08:40 <ertes> wow, i butchered that sentence
03:08:47 <ertes> electrocat: that would be rather weird
03:09:14 <dminuoso> `symbolVal :: forall n proxy. KnownSymbol n => proxy n -> String` with `class KnownSymbol (n :: Symbol)`
03:09:18 <Unhammer> dminuoso,  nice! thanks
03:09:29 <dminuoso> How could you possibly make a proxy without type applications here?
03:09:44 <electrocat> ertes: that would be weird, but i think that is what happens whithout `try`
03:10:47 <Unhammer> unfortunately, we're still on 7.10 at work :-S
03:10:51 <ertes> cibHaskell: rationale: a parser should always use 'try' up to the point where it's certain that its grammar is desired…  for example a float parser, upon seeing digits and a decimal point, is sure that this is supposed to be a float number…  if the parse fails *after* the decimal point, then it's ok for the whole composite parser to fail (it shouldn't try the integer parser and then report an integer error)
03:11:00 <Unhammer> so I don't get to do TypeApplications yet
03:11:02 <ertes> electrocat: no, if p consumed input, the whole thing just fails
03:11:12 <dminuoso> Unhammer: Okay uh let me figure out how to make that Proxy then.
03:12:36 <dminuoso> Unhammer: Oh you just use `symbolVal (Proxy :: Proxy f)`
03:12:52 <electrocat> ertes: that seems counterintuitive to me with how Alternative works
03:13:36 <Unhammer> what is MetaSel?
03:13:56 <dminuoso> Unhammer: Load the thing into GHCi, and run `:kind! Rep User`, let me know when you have done that
03:14:08 <Unhammer> : Not in scope: data constructor ‘MetaSel’
03:14:31 <cibHaskell> thanks, let me have a try.
03:15:27 <dminuoso> Unhammer: Did you `:l` the file?
03:15:46 <ertes> electrocat: imagine (traverse_ char "blah" <|> traverse_ char "rm")
03:16:00 <ertes> electrocat: with the semantics you thought it had, if would successfully parse "blrm" as "rm"
03:16:20 <dminuoso> Unhammer: Ohh sec. Back then Generics looked different
03:16:26 <ertes> electrocat: the first parser would consume "bl", then fail, then the second parser would consume "rm" and succeed
03:16:50 <ertes> electrocat: it's a possible semantics, but a rather unnatural and potentially dangerous one
03:19:39 * hackage vector-text 1.1.2 - Text implementation based on unboxed char vector.  http://hackage.haskell.org/package/vector-text-1.1.2 (danilo2)
03:19:46 <electrocat> ertes: that is what i assumed what would happen, but does this mean that failure is stateful and the entire parser would fail?
03:20:26 <ertes> electrocat: yes, this parser wouldn't actually accept "rm"
03:20:39 * hackage prologue 3.1.6 - Better, more general Prelude exporting common utilities.  http://hackage.haskell.org/package/prologue-3.1.6 (danilo2)
03:22:00 <ertes> electrocat: the two most common variants are automatic backtracking (appar, attoparsec) and manual backtracking (virtually every other parsing library)
03:22:51 <shallowncallow> why does the haskell book take up 1000+ fucking pages (pardon my French)? does it actually take 1000 fucking pgs to learn haskell, or will cis be enough for someone experienced with functional programming? i use 'fucking' because i really don't want to read 1000+ fucking pages of anything... ever.
03:23:36 <ertes> shallowncallow: the haskell book is extremely slow, and i always recommend CIS 194 over it
03:25:05 <ertes> shallowncallow: alternatively check out:
03:25:07 <ertes> @where pih
03:25:07 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
03:25:11 <ertes> err
03:25:13 <ertes> @where pih2
03:25:13 <lambdabot> I know nothing about pih2.
03:25:19 <chorhizo> shallowncallow: I lost my mind after 5 pages and did cis194 in a week, I think I can skip to page 800 now.
03:25:38 <ertes> shallowncallow: ah, it is the second edition…  yeah, this one ^
03:25:57 <dminuoso> Unhammer: Can you give me the generic representation of a record on that GHC version?
03:26:21 <chorhizo> shallowncallow: you can just use huttons uni courses too tbf
03:27:15 <electrocat> ertes: disallowing those sementics seems unnecesary to me, it feels like breaking the Alternative instance :p but i get it, thanks for the explanation
03:27:21 <electrocat> semantics*
03:28:19 <shallowncallow> ertes, chorhizo: thank god. i've been working through cis, but seeing the haskell book's reputation as "(almost) the haskell bible" has made me wonder if i'm missing out
03:28:31 <shallowncallow> i'm assuming it's geared towards people who are entirely new to FP / imperative programmers, and takes so long to cover stuff because of that?
03:28:34 <dminuoso> Unhammer: Reason Im asking is, as far as I can tell it seems impossible in base-4.8 to generically get the selector name.
03:28:36 <ertes> shallowncallow: also keep in mind that "haskell book" is just a marketing trick…  there is nothing official about this book…  it's just another book, and the real title is "haskell programming from first principles", commonly abbreviated HPFFP
03:30:23 <dminuoso> shallowncallow: I have not observed any particular book to be considered "the haskell bible" by any standard.
03:30:38 <greentrophy[m]> How do I async in a ReaderT a IO monad? I'm in a ReaderT Env IO () and have another ReaderT Env IO () I want to call asynchronously... I think I need async from the lifted-async package, but I'm not sure how to use it.
03:30:40 <dminuoso> shallowncallow: There seem to be numerous decent books, each for a different audience.
03:31:19 <ertes> greentrophy[m]: ReaderT (\x -> async (runReaderT c x))
03:32:53 <shallowncallow> dminuoso: HPFFP seems to have quite a reputation as the best, most up-to-date haskell book around, at least on r/haskell
03:33:30 <dminuoso> shallowncallow: If you have a good background (especially in FP), then the Gentle Introduction paired with the 2010 Haskell Report is hard to beat.
03:33:33 <ertes> shallowncallow: it doesn't have quite the same reputation here, even though the hype bleeds over sometimes
03:34:12 <kuribas> dminuoso: except the monad part.  I found it really unhelpful.
03:34:41 <ertes> shallowncallow: hutton's book on the other hand is, as far as i can tell, universally praised
03:34:49 <kuribas> dminuoso: not gentle at all
03:34:55 <ertes> shallowncallow: and not based on hype, but actual substance
03:35:07 <dminuoso> kuribas: Like I said, if you have the appropriate background. The name is misleading indeed.
03:35:19 <dminuoso> ertes: https://www.amazon.de/Programming-Haskell-Graham-Hutton/dp/1316626229 this one?
03:35:27 <ventonegro> shallowncallow: It's not hype, it's a good book.
03:36:19 <ertes> dminuoso: assuming that this is the second edition yes…  the official page is:
03:36:21 <ertes> @where pih
03:36:21 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
03:36:57 <merijn> ertes: The thing is, I don't think Hutton's book and HPFFP have the same goal. From what I've seen from the Hutton book it's nice, but just not as helpful as HPFFP for "real" Haskell
03:37:27 <ertes> merijn: i haven't read it, and that's why i generally recommend CIS 194
03:37:47 <merijn> ertes: Hutton's book seems to nicely cover "writing elegant haskell code", but not so much "how do I do something useful in the wider Haskell ecosystem"
03:38:02 <ertes> merijn: does HPFFP cover that?
03:38:21 <merijn> ertes: HPFFP is far more comprehensive in that it covers, quickcheck, testing, transformers, the basics of parsing libraries
03:38:32 <chorhizo> ertes: I think so, but it's a 300 page book vs 1300
03:39:36 <ertes> why is it so massive?  even covering most of the more popular libraries seems like it should be possible in 500 pages
03:39:50 <merijn> ertes: Because it's VERY thorough and has lots of exercises
03:39:58 <chorhizo> Yeha pretty much
03:40:13 <chorhizo> I just prefer to smash into walls and figure stuff out myself a bit more
03:40:19 <merijn> ertes: When I say it's comprehensive, I mean it's *comprehensive*
03:41:20 <merijn> ertes: I'm not arguing whether that's good or bad, that depends on the person. But from what I've seen (admittedly, I've only been backseat reading while my girlfriend is trying to learn) and I don't think there's a single thing I can think off that isn't covered at some point (at least for the topics/libraries covered so far)
03:41:52 <ertes> merijn: i should probably review it, but i'm honestly not willing to spend the money
03:42:03 <ventonegro> You could give HFFP to a BASIC programmer and if they did the exercises along the way, they could get a haskell job afterwards
03:42:04 <merijn> ertes: Ask Chris if you can get a review copy?
03:42:48 <ventonegro> (that includes unlearning BASIC first)
03:42:49 <ertes> merijn: he isn't particularly fond of me after my repeated and ongoing stack bashing =)
03:42:56 <merijn> ertes: Anyway, there's some choices in the chapter/subject ordering I'm not personally a fan off, because (despite claiming to not require prior programming experience) that ordering is only really useful to people who already programming
03:43:29 <hvr> ertes: so I take you're from the heap camp? :)
03:43:29 <cocreature> stack bashing is about as annoying and useless as cabal or nix bashing
03:43:42 <merijn> cocreature: Word.
03:43:49 <ertes> hvr: haha
03:44:10 <merijn> I wish people would refrain from commenting on people's build tools unless asked explicitly
03:44:19 <ertes> cocreature: yeah, i don't really do it anymore, but my opinion on it hasn't changed
03:44:28 <merijn> A simple "sorry, I don't use X" suffices
03:44:39 <ertes> yep, that's what i do these days
03:44:49 <cocreature> ertes: that’s fine just don’t impose your opinion on people that don’t ask for it
03:44:54 <hvr> merijn: still, if their choice of build-tool is the cause of their problems; it's only fair to point it out
03:45:45 <ertes> however, one issue i have with HPFFP is that it does include a stack sales pitch…  it's understandable from a commercial standpoint, but it still loses points for me because of that
03:46:06 <ertes> if it's so comprehensive, it should cover cabal-install
03:46:37 <chorhizo> ertes: I'm scared to ask what's wrong with stack
03:46:39 * hackage aeson-diff-generic 0.0.3 - Apply a json-patch to any haskell datatype.  http://hackage.haskell.org/package/aeson-diff-generic-0.0.3 (KristofBastiaensen)
03:46:45 <cocreature> dunno focusing on one build tool seems pretty reasonable regardless of which one you choose
03:46:45 <merijn> hvr: Well, last night someone ran into a stack issue at work and someone started saying "delete stack" as resolution to that problem. Which is unhelpful for that person
03:46:48 <hvr> merijn: i.e. I often can offer solutions to user problems, but that may involved using a different build-tool; should I refrain from helping ?
03:47:29 <merijn> hvr: No, but unconstructive "I have an issue with stack" 'delete stack, it sucks', is helping no one and just makes the entire community more toxic
03:47:44 <ertes> chorhizo: i don't like its design, but honestly i don't want to go into any details right now
03:47:52 <cocreature> hvr: if you actually propose a solution using a different build tool that’s fine but 90% of the comments are “don’t use stack, you wouldn’t have this problem with cabal, …” which are not useful to anyone
03:48:14 <cocreature> (90% of the comments in general, not yours specifically”
03:48:16 <cocreature> )
03:48:23 <hvr> cocreature: well, if I propose a solution I'm usually ready to guide them through how to do it ;)
03:48:47 <merijn> chorhizo: Basically, stack is rather dogmatic about how it should be used, and if that doesn't fit your workflow everything becomes very painful.
03:48:48 <kuribas> dminuoso: I did have it, I was already progamming in ocaml.  It's just the monad part which IMO was totally not helpful in any way.  It just starts with the monad laws :)
03:49:30 <kuribas> dminuoso: I mean, you cannot assume a new reader to already know what a monad is?
03:49:34 <cocreature> it’s not like problems magically go away if you switch to a different build tool, you’re mostly just trading the kind of problems you’ll encounter :)
03:49:37 <chorhizo> merijn: ah fair enough.
03:49:43 <kuribas> dminuoso: in this time it's more likely though...
03:50:04 <Taneb> (the main thing I don't like about stack is the name)
03:50:09 <dibblego> stack bashing is an important and necessary activity
03:50:16 <Taneb> (but that's the least important thing, really)
03:50:46 <Unhammer> dminuoso,  like λ> from (User (Just "me") (Just 42))
03:50:47 <hvr> Taneb: too bad they didn't go w/ yesod-install ;->
03:50:48 <Unhammer> M1 {unM1 = M1 {unM1 = M1 {unM1 = K1 {unK1 = Just "me"}} :*: M1 {unM1 = K1 {unK1 = Just 42}}}}
03:50:50 <Unhammer> ?
03:52:47 <Taneb> Anyway we should all be building our Haskell with makefiles
03:53:21 <merijn> Taneb: Way ahead of you!
03:53:37 <chorhizo> Why not port it to the jvm then we can implement maven
03:53:44 <chorhizo> The greatest package manager
03:53:59 <tdammers> clearly, npm is where it's at
03:54:11 <merijn> tbh, cabal-install makes all other build-tools I've ever used look like shit
03:54:40 <chorhizo> merijn: is that new? Ive heard horror stories of pre stack cabal
03:56:17 <merijn> chorhizo: I've only had cabal issues in the *actual* "cabal hell" era. After that it was fine if you knew what you did. 90% of the "cabal hell" claims after that time are just "my dependencies are incompatible and now things won't compile!!" complaints. And unlike 90% of all other build tools cabal-install is trivial to build and install as a user without root
03:56:44 <merijn> You should try and manage python dependencies without root, it's a fucking pain and nothing works. Same for basically every other language I've used
03:56:55 <Myrl-saki> How was GHC bootstrapped?
03:56:58 <Myrl-saki> Did they like, start with Hugs, then made a GHC, then every succeeding GHC is bootstrapped by GHC-1?
03:57:11 <merijn> Myrl-saki: No, GHC and Hugs aren't chronologically related
03:57:20 <Myrl-saki> merijn: Oh okay.
03:57:24 <merijn> Myrl-saki: The very first Haskell compiler was written by Lennart in Lazy ML
03:57:36 <merijn> Myrl-saki: AFAIK GHC was bootstrapped using that compiler
03:57:49 <merijn> Or maybe some other compiler bootstrapped with Lennart's compiler
03:58:22 <Myrl-saki> merijn: So, assuming that there's no such thing as cross compiling, then my dep tree could go as deep as that?
03:58:41 <merijn> Myrl-saki: Then you'd have to cross-compile Lazy ML ;)
03:58:47 <clever> Myrl-saki: there is also the issue that modern ghc needs relatively modern ghc features to build
03:58:59 <chorhizo> merijn: ah fair.
03:59:01 <clever> Myrl-saki: so you have to go thru each major upgrade of ghc
03:59:05 <Myrl-saki> clever: Yep, hence I said dep tree. :P
03:59:17 <merijn> Myrl-saki: Realistically you build a custom GHC with via-C enabled and bootstrap by compiling to C, manually fixing the C, then using that to bootstrap GHC
03:59:38 <Myrl-saki> merijn: How does one do the codegen?
03:59:42 <cocreature> iirc someone tried to bootstrap GHC not too long ago and wrote a blogpost
04:00:08 <Taneb> I've always been tempted, never got round to it
04:00:14 <cocreature> https://elephly.net/posts/2017-01-09-bootstrapping-haskell-part-1.html
04:00:16 <merijn> Myrl-saki: What do you want to bootstrap on?
04:00:20 <_d0t> ohai. Is there a way to throw an http error in servant when using ServerT with a custom monad stack?
04:01:02 <Myrl-saki> merijn: I was playing around with MIPS, because my router is MIPS and has SSH, but it's not worth it. Just wanting to learn for the sake of learning.
04:02:04 <ph88> anyone know if it's possible to traverse the current item and the next item at the same time with traversal lens ?
04:02:22 <merijn> Myrl-saki: That sounds both impossible and very educational :p
04:02:27 <kuribas> ph88: what's a current item?
04:02:47 <merijn> Myrl-saki: But if you want any serious feedback on how to bootstrap GHC you might wanna mail ghc-dev@ or visit #ghc
04:02:52 <kuribas> ph88: you mean like zip l (tail l) for a traversal?
04:02:53 <Myrl-saki> merijn: Of course, I won't run it on the router itself, it only has 16 MB of RAM. :P
04:03:30 <clever> Myrl-saki: then i dont see much point in bootstrapping ghc on it, but instead focusing on cross-compiling
04:03:43 <clever> Myrl-saki: angerman has been working on cross-compiling stuff lately
04:04:23 <alp> _d0t, if your custom monad stack has a suitable notion of errors, you can throw a descriptive error like `ClientNotFound "someclientid"`, and when you use `hoistServer` to go from your monad stack to `Handler`, you take care of converting any error into a suitable http response with the status code you want etc.
04:05:01 <Myrl-saki> clever: On that topic, architecturally, how much change would need to be done on Nixpkgs to accept cross-compiled binaries?
04:05:15 <_d0t> alp: is there an example for this somewhere?
04:05:36 <clever> Myrl-saki: that is also exactly what angerman is working on, getting nix+ghc to cross-compile from linux to windows
04:06:00 <clever> Myrl-saki: so you can just spit out a finished binary, without ever involving the target cpu
04:06:04 <Myrl-saki> clever: :D Cool. Let's continue the talk on #nixos
04:08:13 <alp> _d0t, e.g: data AppError = ClientNotFound String ; type M = ExceptT AppError IO ; m2handler :: M a -> Handler a ; m2handler a = do { res <- runExceptT a ; case res of { Left (ClientNotFound c) -> throwError $ err404 { errBody = "Client " ++ show c ++ " could not be found" } ; Right a -> return a } }
04:08:16 <alp> or something along those lines.
04:08:22 <cocreature> ph88: that sounds like it probably violates the traversal laws since you would traverse the same element twice
04:08:25 <_d0t> alp: thanks!
04:09:29 <alp> _d0t, https://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#using-another-monad-for-your-handlers talks about hoistServer, https://haskell-servant.readthedocs.io/en/stable/cookbook/using-custom-monad/UsingCustomMonad.html illustrates it with ReaderT, all we're doing here is doing the same with ExceptT CustomErrorType
04:09:58 <alp> as the custom monad.
04:11:34 <kuribas> Do CMS or ecommerce programs exist in haskell, or are you supposed to roll your own?
04:12:18 <ertes> kuribas: i know of clckwrks
04:12:26 <ph88> cocreature, with list it can be done with   zip <*> tail   but i have a tree structure
04:12:26 <kuribas> ertes: is it usable?
04:12:42 <ph88> kuribas, yes exactly
04:13:07 <ertes> kuribas: it's a CMS based on happstack, and as far as i know the happstack web site is built on it
04:13:49 <kuribas> ph88: you can cheat with partsOf
04:14:07 <Entroacceptor> it's more like a framework
04:14:28 <kuribas> ph88: there's a new package for tree traversals: https://hackage.haskell.org/package/tree-traversals
04:18:09 <kuribas> isn't happstack old?
04:20:01 <Taneb> kuribas: it seems to be still active
04:20:02 <merijn> @hoogle (a -> Bool) -> a -> Maybe a
04:20:03 <lambdabot> Control.Monad.Plus partial :: (a -> Bool) -> a -> Maybe a
04:20:03 <lambdabot> Agda.Utils.Maybe filterMaybe :: (a -> Bool) -> a -> Maybe a
04:20:03 <lambdabot> Agda.Utils.Maybe.Strict filterMaybe :: (a -> Bool) -> a -> Maybe a
04:20:28 <hpc> (it is old though)
04:20:42 <ph88> kuribas, what can i do with partsOf to make that happen ?
04:20:48 <kuribas> :t partsOf
04:20:49 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
04:21:31 <ph88> to get two items at the same time
04:21:47 <ph88> i like to modify the first item (the second is like a lookahead)
04:21:57 <ph88> modifier :: a -> a -> a
04:22:13 <dminuoso> Unhammer: No I actually mean `:kind! Rep User`
04:23:23 <ph88> > let lst = [0..4] in zip <*> tail $ lst
04:23:26 <lambdabot>  [(0,1),(1,2),(2,3),(3,4)]
04:23:53 <kuribas> over (partsOf each) (\l -> zipWith (+) l (tail l)) (5, 2, 4)
04:23:57 <kuribas> > over (partsOf each) (\l -> zipWith (+) l (tail l)) (5, 2, 4)
04:23:59 <lambdabot>  (7,6,4)
04:25:32 <ph88> oh that's nice
04:26:04 <ph88> i have also this:
04:26:06 <ph88> > (Left True,[Right "Hello"], Just (Left False),"another string",("and",("some","more"))) & partsOf template %~ (reverse :: [Char] -> [Char])
04:26:09 <lambdabot>  (Left True,[Right "erome"],Just (Left False),"mosdnagnirts r",("eht",("onao"...
04:26:10 <kuribas> not lawful probably
04:26:51 <kuribas> ph88: sounds like something comonadic
04:27:15 <ph88> i don't know what a comonad is
04:27:45 <ph88> i like to combine those two snippets of code
04:28:21 <ziman> hello, I think there should be warnings in my code but "stack build" does not show any (not even after "stack clean"). I couldn't find anything relevant in --help or google; is there a hidden way to get all warnings?
04:28:30 <hth> comonad?
04:29:58 <ph88> each :: Traversal s t a b        template :: forall s a. (Data s, Typeable a) => Traversal' s a
04:30:10 <liste> ziman: what does your package.yml or *.cabal file look like?
04:30:28 <liste> package.yaml*
04:30:43 <kuribas> ph88: eh, use template instead of each?
04:30:56 <liste> I had to all -Wall and -Werror to ghc-options in package.yaml
04:31:04 <ph88> kuribas, and then use    (\l -> zipWith (+) l (tail l))   instead of    reverse ?
04:31:21 <liste> (though -Werror is optional)
04:31:23 <kuribas> yes
04:31:32 <ph88> but that lambda function seems like it's taking a list  .. reverse takes a single element
04:32:07 <ziman> liste: oh, I see what you mean; the flags are there (-Wall namely) -- the thing is that I got the warnings for lots of files, I fixed one, reran "stack build" and now there are none
04:32:38 <ziman> it feels like stack does not want to bother me with warnings I've already seen but I want to see them again :)
04:32:41 <liste> weird
04:32:47 <ph88> maybe it's because of the %~ in between
04:33:36 <Putonlalla> Add `-fforce-recomp` to your options, ziman.
04:34:02 <Putonlalla> You can remove it once all the warnings have been addressed.
04:35:34 <ph88> > > (Left True,[Right "Hello"], Just (Left False),"another string",("and",("some","more"))) & partsOf template (\l -> zipWith (+) l (tail l))
04:35:37 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
04:35:40 <kuribas> ph88: it turns the traversal into a list and back.
04:35:42 <ph88> > (Left True,[Right "Hello"], Just (Left False),"another string",("and",("some","more"))) & partsOf template (\l -> zipWith (+) l (tail l))
04:35:45 <lambdabot>  error:
04:35:45 <lambdabot>      • Couldn't match type ‘Integer’ with ‘[Integer]’
04:35:45 <lambdabot>        Expected type: [[Integer]]
04:36:05 <ziman> Putonlalla: thank you, I'll try it
04:38:59 <ph88> > (Left True,[Right "Hello"], Just (Left False),"another string",("and",("some","more"))) & partsOf template ( (\l -> zipWith (++) l (tail l)) :: [String] -> [String] )
04:39:02 <lambdabot>  error:
04:39:02 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
04:39:02 <lambdabot>        Expected type: [Char] -> [[Char]]
04:39:18 <kuribas> ph88: what are you trying to do?
04:39:37 <cibHaskell> hi
04:40:05 <ph88> kuribas, trying to get output like (Left True,[Right "Hello"], Just (Left False),"another stringand",("andsome",("somemore","more")))
04:40:45 <ziman> Putonlalla: that did not help but I think it may be a feature of Stack -- it seems that it won't show me the warnings unless I make a syntax error in the file (so that it shows the error + other warnings from that file)
04:41:01 <quicksilver> zipWith + tail isn't going to work on finite lists
04:41:16 <quicksilver> it won't know what to do with the trailing item
04:41:27 <quicksilver> you might try zipWith ... (init l) (tail l)
04:41:42 <Unhammer> dminuoso,  http://termbin.com/kao2
04:41:54 <ph88> kuribas, that was what i'm trying to do in the example code. After that step works with strings i want to try it on types like these https://bpaste.net/show/b61881b53d11 where i have the current "T" (which i want to modify) based on the itself and the next "T"
04:42:32 <kuribas> quicksilver: it just ignores those
04:42:49 <kuribas> > zipWith (+) [1, 2] [3, 4, 5]
04:42:51 <lambdabot>  [4,6]
04:42:53 <quicksilver> oh
04:42:57 <quicksilver> my apologies :)
04:43:40 <kuribas> ph88: parts of takes a traversal and creates another traversal
04:44:36 <ph88> kuribas, yes that's good ... i think with partsOf and template i can make a traversal over only the type i need
04:45:12 <nshepperd> :t \xs -> evalState (Control.Applicative.Backwards.forwards $ traverse (\x -> Control.Applicative.Backwards.Backwards $ ((,) x
04:45:13 <lambdabot> error:
04:45:14 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
04:45:18 <kuribas> ph88: zipWith f l (tail l) just pairs the element with the next using function f
04:45:39 <nshepperd> eh
04:45:52 <dminuoso> Unhammer: https://gist.github.com/dminuoso/1b1f545ea555a8091fc71cbfc8db0381
04:45:58 <kuribas> ph88: so it creates a new list, which gets converted back into a traversal.?
04:46:06 <nshepperd> @let ziptailf xs = evalState (Control.Applicative.Backwards.forwards $ traverse (\x -> Control.Applicative.Backwards.Backwards $ ((,) x <$> get) <* put (Just x)) xs) Nothing
04:46:08 <lambdabot>  .L.hs:161:8: error:
04:46:08 <lambdabot>      Not in scope: ‘Control.Applicative.Backwards.forwards’
04:46:08 <lambdabot>      No module named ‘Control.Applicative.Backwards’ is imported.
04:46:52 <kuribas> ph88: so instead of traversing over each element, you are traversing over all the parts as a list in one time.
04:47:36 <dminuoso> Unhammer: Note that this of course will need additional tweaks. But if you understand the rather simple idea behind it, you can do it yourself. :)
04:47:40 <Unhammer> WOW
04:47:47 <Unhammer> that's so cool
04:48:31 <kuribas> ph88: the output list should have the same number of elements, but it doesn't really.
04:48:37 <kuribas> ph88: so the last element is unchanged.
04:48:59 <ph88> yes the last one should stay unchanged
04:49:27 <nshepperd> :t ziptailf
04:49:28 <lambdabot> Traversable t => t a -> t (a, Maybe a)
04:49:38 <Unhammer> λ> toErrs $ User Nothing Nothing
04:49:41 <Unhammer> ["name","age"]
04:49:41 <nshepperd> > ziptailf [1..5]
04:49:42 <Unhammer> =D  =D =D
04:49:43 <lambdabot>  [(1,Just 2),(2,Just 3),(3,Just 4),(4,Just 5),(5,Nothing)]
04:49:53 <nshepperd> ph88 ^^
04:50:07 <ph88> kuribas, i supplied (++) as f, types didn't line up
04:50:11 <dminuoso> Unhammer: The only requirement is that an instance Generic exists (which deriving gives you for free)
04:50:16 <kuribas> ph88: so "each" is the original traversal which partsOf works on, and (+) is the functions which combines the two elements.
04:50:58 <kuribas> ph88: if your original part has type "a", f should have type "a -> a"
04:51:09 <kuribas> ph88: erm a -> a -> a
04:51:33 <ph88> kuribas, i think template will take a traversal and create a lens that allows me to change specific types only in the original structure
04:51:56 <kuribas> ph88: I don't know template...
04:52:10 <ph88> https://hackage.haskell.org/package/lens-4.16.1/docs/Data-Data-Lens.html#v:template
04:52:13 <ph88> it's this one
04:53:03 <kuribas> ph88: so (++) would work with strings
04:53:52 <ph88> yes !!
04:55:50 <kuribas> > (Left True,[Right "Hello"], Just (Left False),"another string",("and",("some","more"))) & over (partsOf template) ((\l -> zipWith (++) l (tail l)) :: [String] -> [String] )
04:55:53 <lambdabot>  (Left True,[Right "Helloanother string"],Just (Left False),"another stringan...
04:56:53 <ph88> thank you :D
04:57:08 <ph88> seems that i was missing "over"
04:57:27 <kuribas> yes
04:58:04 <ph88> i will now try to use this technique on types like these https://bpaste.net/show/b61881b53d11
04:58:07 <ph88> be back later
05:03:29 <dminuoso> `x :: Either String a`, `y :: Either String b` , `f :: a -> b -> c`, how do I turn this into `Either [String] c` elegantly? Do I have to manually pattern match?
05:04:03 <lyxia> liftA2
05:04:17 <lyxia> oh you need the bit on the left...
05:04:19 <dminuoso> Yeah.
05:04:36 <merijn> dminuoso: You want Validation
05:04:57 <merijn> https://hackage.haskell.org/package/either-5/docs/Data-Either-Validation.html
05:05:17 <dminuoso> merijn: Ah! I tried getting too much mileage from Either it seems. Thank you for the hint.
05:05:54 <merijn> dminuoso: Validation doesn't have a valid monad instance, so the applicative for Either is different
05:07:45 <merijn> kuribas: Incidentally, your zoom suggestion doesn't work, because then I lose the ability to modify the rest of the state
05:08:59 <kuribas> merijn: I thought you only needed to modify part?
05:09:33 <kuribas> merijn: you can modify the rest of the state after the zoom?
05:09:38 <merijn> kuribas: "MonadState s m => Lens' s a -> (a -> m a) -> m ()". zoom changes the 'm'
05:10:04 <kuribas> :t zoom
05:10:05 <lambdabot> Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
05:10:16 <merijn> kuribas: I only modify part, but I need access to the rest to decide how to modify
05:10:46 <dminuoso> merijn: Interesting to see another Applicative that is not a Monad.
05:10:59 <kuribas> merijn: I don't see how you access the rest from (a -> m a)
05:11:08 <merijn> ZipList, Validation, Async, Const k
05:11:16 <merijn> kuribas: "MonadState s m"?
05:11:29 <kuribas> ah, right...
05:14:28 <dminuoso> merijn: I mean its immediately obvious why it's not a monad either. This is a strangely uncomfortable feeling.
05:14:54 <merijn> dminuoso: :)
05:17:13 <kuribas> merijn: (l .=) =<< join (uses l f)
05:18:41 * dminuoso includes `either` and suddenly has to instally 27 transitive dependencies from mtl to stm..
05:19:08 <dminuoso> This is quite over the top..
05:19:52 <merijn> dminuoso: Blame edwardk and semigroupoids :p
05:20:38 <ph88> kuribas, from the code we had i made this function https://bpaste.net/show/669f4ba0d209 .. the type signature was infered by ghci .. any ideas why there is a constraint Typeable on b ?
05:20:49 <kuribas> ph88: from template
05:22:28 <tabaqui2> wow, just understand that '>>= f' = 'join . fmap f'
05:23:01 <tabaqui2> little bit of enlightment
05:23:32 <merijn> tabaqui2: And "join" = ">>= id" :)
05:23:55 <tabaqui2> merijn: by definition :)
05:23:59 <merijn> The cabal data directory stuff only works when something is "cabal install"-ed, I suppose?
05:25:13 <dminuoso> merijn: Hehe. Well its closer to maybe 15 but still crazy. Guess realistically most projects tend to somehow have profunctors/bifunctors/semigroups at least. So if I added this to an existing project, chances are it's only grab 1-2 packages.
05:25:32 <dminuoso> And I kind of fail at writing proper English today.
05:27:13 <Boomerang> tabaqui2: It's even more obvious when using the list versions of join, bind and fmap: `concatMap f = concat . map f`
05:27:15 <kuribas> :t \f -> (_1 .= ) =<< join (uses _1 f)
05:27:16 <lambdabot> (Field1 s s b b, MonadState s m) => (b -> m b) -> m ()
05:27:35 <merijn> kuribas: At this point the "ugly way" is less ugly :p
05:27:43 <kuribas> merijn: what's the ugly way?
05:28:21 <merijn> kuribas: http://lpaste.net/364913
05:28:38 <kuribas> merijn: why is that ugly?
05:28:49 <merijn> Duplicates the lens for input and result
05:29:06 <reactormonk> I'm trying to build myself some hlist typelevel magic... https://gist.github.com/reactormonk/dbecb9a594c0f18cceaeb6a05db754fc - how would I write a constraint that proves me that each element in an hlist shares a type?
05:29:20 <rckd> merijn what is "use"?
05:29:24 <rckd> :D
05:29:35 <merijn> Unrelatedly: I wish process had a builtin method for silencing stdout/stderr instead of needing to manually open /dev/null
05:29:37 <kuribas> merijn: ghc could optimize that away
05:29:43 <merijn> rckd: From lens
05:29:52 <reactormonk> ... I'm basically traing to fulfill the fundep on line 12 pot -> effect
05:30:07 <merijn> Passing NoStream to CreateProcess tends to have the child erroring out
05:31:21 <kuribas> merijn: nvm...  I don't see why that's bad...
05:32:05 <kuribas> I don't find that ever more obscure combinators increase readability...
05:32:39 <merijn> kuribas: I don't either, but this seems a fairly obvious one, lens has way more obscure ones
05:52:36 <hth> e
05:53:22 <hth> can we import stack test module in ghci?
05:55:51 <Boomerang> hth, try: stack repl my-test-suite
05:56:03 <Psybur> Is there a language "purer" than Haskell? Like that goes even more extreme and has no partial functions in its spec?
05:56:10 <Boomerang> Where my-test-suite is the name of the test-suit
05:56:33 <dminuoso> Aren't tests just regular Haskell programs?
05:56:38 <liste> Psybur: there's languages with actually total functions, like Agda and Idris
05:56:42 <liste> Psybur: and Coq
05:56:51 <liste> Psybur: with totality checkers
05:58:08 <Psybur> liste, cool, will check those langs out
05:58:44 <liste> Psybur: Coq is actually a proof assistant which doubles as a programming language
05:59:04 <liste> Idris is a general-purpose programming language, Agda is something in between
05:59:44 <Psybur> Blah, "general purpose." What if my problems arent general? ;D
06:02:06 <merijn> cocreature: I don't suppose you've worked with new-build and cabal-install's data-dir stuff combined?
06:03:11 <jophish> Is There any better way to encode a version in a module name than with underscores
06:03:48 <Boomerang> You can spell it out! No more numbers :D
06:03:52 <jophish> I'm updating my vulkan bindings, and having "Graphics.Vulkan.VK_VERSION_1_1" and "..._1_0" seems a litte odd
06:03:54 <jophish> haha
06:04:05 <jophish> Graphics.Vulkan.OnePointZero
06:04:17 <Boomerang> That looks great :D
06:04:18 <jophish> I suppose I could have: Graphics.Vulkan.One.Zero
06:05:21 <merijn> oh, looks like new-run might be data-dir aware!
06:06:52 <cjay-> spelled out digits with lexical sorting D:
06:07:56 <jophish> Could be G.V.Version11 and Version10
06:08:06 <jophish> but what if they get to version ten
06:12:04 <Boomerang> Graphics.Vulkan.Major1.Minor0.Patch5
06:12:14 <Boomerang> Undescore are probably better though
06:13:25 <Taneb> gl uses Graphics.GL.Core32 etc, completely ignoring the number separators
06:13:47 <Taneb> I don't know if that's an optionf or Vulkan though
06:15:19 <cocreature> merijn: sry no, I’m not even sure I’ve used data-dir without new-build
06:16:01 <jophish> there are only 1.1 and 1.0 at the moment :)
06:16:08 <jophish> Hey Taneb, how's things?
06:16:29 <Taneb> jophish: pretty good, how's you?
06:17:39 <jophish> Boomerang: cchalmers Taneb TMVector. You guys switched from Slack to freenode or something :)
06:17:45 <merijn> cocreature: Looks like the good news is: If you use new-run it Just Works (TM) :)
06:17:58 <jophish> Taneb: going well, enjoying the warm weather lots
06:19:21 <cocreature> merijn: great :)
06:32:33 <sudoreboot[m]> I'm struggling to understand why Control.Category.id takes no arguments. I thought I'd be able to define id in my instance of Category in terms of Prelude.id but since Prelude.id takes one argument that's not possible
06:33:02 <sudoreboot[m]> There must be something I'm missing here
06:34:22 <rotcev> when using list comprehensions with a specific range defined, is there a way to skip indexes upon a certain condition, or should i rethink how im trying to solve my problem?
06:34:27 <Taneb> sudoreboot[m]: what is your type?
06:34:29 <rotcev> i.e a finite list
06:34:48 <Taneb> > [x | x <- [1..10], x `mod` 3 /= 0] -- rotcev
06:34:51 <lambdabot>  [1,2,4,5,7,8,10]
06:34:53 <Unhammer> is there something like the "ghc-pkg dot" command for the local modules in a project?
06:34:54 <Taneb> Like that, rotcev?
06:35:17 * sudoreboot[m] sent a long message: sudoreboot[m]_2018-04-17_13:34:55.txt <https://matrix.org/_matrix/media/v1/download/matrix.org/BTJnBfybQZVBQqMrjeFtEFKM>
06:35:23 <Unhammer> I mean, just the tree of Foo imports Bar imports Fie in ./src/*.hs or whatever
06:37:51 <rotcev> Taneb: eh, not really, more like if the datatype is a certain value, i would like to skip 2 indices, otherwise only increment one time. currently i have http://lpaste.net/5105807630576648192 but i could also refactor it to something like this: http://lpaste.net/9143030434450374656
06:38:02 <rotcev> i am also wondering if maybe i could use unfold for this problem
06:38:33 <Taneb> sudoreboot[m]: so MyFunc is a wrapped function type
06:39:04 <Taneb> Prelude.id is a plain function, values of type MyFunc a b are functions with a wrapper around them
06:39:52 <ertes> does GHC do anything clever for ByteString if i use pattern-matching with OverloadedStrings?
06:41:21 <ni291187> hi
06:41:36 <ni291187> new to ITV
06:41:44 <ni291187> irc*
06:42:03 <ni291187> trying how things work here
06:42:23 <sudoreboot[m]> Taneb: But shouldn't the identity of a wrapped function type be that same wrapped function type?
06:42:46 <cocreature> Unhammer: https://github.com/yav/graphmod
06:43:38 <sudoreboot[m]> I also see Bartosz Milewski in [this video](https://youtu.be/hrNfkP8iKAs?t=624) defining id this way
06:44:11 <hexagoxel> is there something like "(a -> (x | y | z)) -> [a] -> ([x], [y], [z])" ? I.e. `partition`, but more general, and if possible for arbitrary arities?
06:45:16 <electrocat> ertes: i believe overloadedStrings juist does Eq comparison for pattern matching
06:45:47 <ertes> electrocat: ok thanks…  i was hoping that it would do some form of prefix-tree search
06:52:02 <reactormonk> Control.Arrow gives me a b c -> a b c' -> a b (c, c'), but I'm looking for Semigroup c => a b c -> a b c -> a b c - any idea?
06:53:07 <Putonlalla> Don't you get that for free via the `Functor` instance, reactormonk?
06:53:38 <Boomerang> hexagoxel: I think the tuple package might be helpful here :)
06:53:42 <reactormonk> Putonlalla, Semigroup instance for Functor?
06:53:42 <hexagoxel> :t arr (uncurry (<>))
06:53:43 <lambdabot> (Monoid c, Arrow a) => a (c, c) c
06:53:44 <dfeuer> Putonlalla: what Functor instance?
06:53:46 <sudoreboot[m]> Taneb: Ah, the definition was supposed to be: `id = MyF (Prelude.id)`
06:53:52 <dfeuer> hexagoxel++
06:54:16 <merijn> reactormonk: Why are you working with arrows?
06:54:16 <Ariakenom> :t fmap (uncurry (<>))
06:54:17 <lambdabot> (Monoid b, Functor f) => f (b, b) -> f b
06:54:20 <Unhammer> cocreature,  thanks, exactly what I wanted =D
06:54:25 <merijn> reactormonk: Do you really have functions?
06:54:34 <reactormonk> merijn, yeah, I do. Problem solved without Arrows.
06:54:35 <cocreature> :t \f g -> uncurry (arr (<>)) . (f &&& g)
06:54:37 <lambdabot> Monoid a1 => (a2 -> a1) -> (a2 -> a1) -> a2 -> a1
06:54:53 <merijn> reactormonk: I was about to say, functions have a Monoid instance and should thus have semigroup too :)
06:55:14 <dfeuer> Oh, well, with *functions* you can do all sorts of things.
06:55:19 <merijn> reactormonk: You know what's even better? The function instance is recursive so it generalises to functions with any number of arguments :)
06:55:33 <reactormonk> merijn, <3
06:55:52 <merijn> reactormonk: My favourite Monoid/semigroup :D
06:56:02 <cocreature> :t \f g -> uncurry (arr (<>)) <<< (f &&& g)
06:56:03 <lambdabot> Monoid c => (a -> c) -> (a -> c) -> a -> c
06:56:15 <cocreature> :t (<<<)
06:56:16 <lambdabot> forall k (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
06:56:25 <merijn> cocreature: That seems like a really complicated way to write mappend?
06:56:48 <hexagoxel> Boomerang: which module specifically? my question seems to require arbitrary sums to, and `tuple` package does not do those, does it?
06:57:01 <hexagoxel> s/to/too/
06:57:01 <merijn> :t mappend `asAppliedTo` (undefined :: a -> b)
06:57:03 <lambdabot> Monoid b => (a -> b) -> (a -> b) -> a -> b
06:57:30 <cocreature> :t \f g -> arr (uncurry (<>)) <<< (f &&& g)
06:57:31 <lambdabot> (Monoid c, Arrow cat) => cat a c -> cat a c -> cat a c
06:57:35 <cocreature> that’s what I was looking for
06:57:40 <cocreature> messed up the order of arr and uncurry
06:58:58 <Boomerang> I was looking at the SequenceT in particular, along with the State monad or something like that. But actually it might be the opposite you need, I'll think about it a bit more :)
07:00:43 <reactormonk> I can't derive an instance for Semigroup without having a Monoid?
07:01:35 <merijn> reactormonk: In ghc-8.4 and later you can't, no
07:01:42 <merijn> reactormonk: eh, wait, other way around
07:01:46 <cocreature> sure you can, you can’t have Monoid without Semigroup
07:01:53 <merijn> reactormonk: Semigroup is a superclass of Monoid, not the other way around
07:01:57 <reactormonk> merijn, exactly. that's why I'm wondering.
07:01:58 <cocreature> but you can’t derive either of those without GND
07:02:16 <reactormonk> I have deriving instance Semigroup
07:03:05 <cocreature> that’s not going to work without GND
07:03:27 <cocreature> well it compiles with DeriveAnyClass as well but won’t produce anything useful
07:03:44 <merijn> cocreature: What's the point of DeriveAnyClass anyway?
07:04:04 <cocreature> merijn: it looks prettier than empty instance decls :)
07:07:30 <cocreature> tbh I’m surprised I haven’t seen more problems caused by people using DeriveAnyClass
07:07:39 <cocreature> iirc GHC even suggests using it
07:07:57 <cocreature> I guess luckily most people use -Wall
07:13:39 <chorhizo> cocreature: is -Wall needed? I haven't used it in what I've done so far
07:14:29 <cocreature> chorhizo: I highly recommend it, you can always turn off specific warnings that you don’t like but most of the warnings are really useful
07:16:21 <merijn> chorhizo: I'd say -Wall is mandatory for everything
07:17:23 <cocreature> having the compiler help me is the reason why I write Haskell in the first place, so having it help me even more by enabling -Wall makes sense :)
07:18:24 <LeoniusMonk> hey guys. Very basic question. Say I have many functions that I want to chain but every function should have access to a previous functions result. What do you use? Is it just a matter of packaging all the data into one type and then using something like Maybe to chain the computation? Is something like the State monad used to further abstract this concept?
07:18:47 <nshepperd> even with -Wall i'd expect people to come in with problems occasionally due to classes with recursive default definitions
07:18:59 <nshepperd> but i guess there aren't that many of those
07:19:22 <LeoniusMonk> full disclosure Ruby developer here and I want to bring Haskell concepts into my workflow.
07:19:33 <cocreature> nshepperd: if you have a MINIMAL pragma you’ll still get a warning iirc
07:19:39 * hackage madlang 4.0.2.7 - Randomized templating language DSL  http://hackage.haskell.org/package/madlang-4.0.2.7 (vmchale)
07:19:50 <nshepperd> oh, that's a thing? neat
07:19:54 <merijn> nshepperd: Yup
07:20:10 <cocreature> :i shows you the minimal definition
07:20:15 <merijn> nshepperd: https://hackage.haskell.org/package/base-4.11.0.0/docs/Prelude.html#t:Eq
07:20:24 <merijn> nshepperd: See "minimal complete definition"
07:20:27 <cocreature> disclaimer: I implemented that feature in ghci so it probably doesn’t work
07:20:31 <merijn> nshepperd: That's a pragma which is checked by GHC
07:20:34 <nshepperd> does the warning work across multiple classes, like if I defined ap = <*> = ap?
07:20:36 <dysfun> LeoniusMonk: maybe performs early termination in the event that a step fails. is that the flow you want?
07:20:42 <merijn> nshepperd: Probably not
07:21:04 <LeoniusMonk> dysfun:  My methods may return an error object of some sort
07:21:13 <dysfun> that would be Either rather than Maybe
07:21:17 <dysfun> but the same logic
07:21:24 <cocreature> LeoniusMonk: sounds like some kind of foldM?
07:21:40 <dysfun> cocreature: right, my initial reading i thought it sounded like a fold
07:21:57 <merijn> LeoniusMonk: And you wanna basically collect all errors?
07:25:25 <ph88> how do i print something for each element of a traversable? while keeping track of the item index ?
07:25:41 <adjofun> LeoniusMonk: http://lpaste.net/364924
07:25:57 <Taneb> ph88: something with StateT Int IO?
07:26:01 <chorhizo> merijn: cocreature, if wall is so important, should it not be default? Or can you apply it to an entire project from one reference somehow?
07:26:14 <cocreature> chorhizo: add it to the ghc-options section in your cabal file
07:26:26 <cocreature> chorhizo: but yeah personally I agree that it should be the default
07:26:27 <merijn> chorhizo: If you use cabal (or stack, presumably) you can specify it package wide, yeah
07:28:23 <ph88> Taneb, it's a structure with Data constraint .. im using lens biplate
07:29:50 <chorhizo> Good to know, cheers
07:30:57 <Taneb> ph88: there's a way to turn a Traversal into an IndexedTraversal but I don't know it off the top of my head
07:31:27 <Taneb> If you just want to print them, you can do "mapM_ print"
07:31:42 <cocreature> "indexing" iirc
07:31:47 <cocreature> https://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Indexed.html#v:indexing
07:32:51 <Taneb> cocreature: that's the one :)
07:33:00 <Taneb> I thought it was "reindexed" but that's something else completely
07:37:10 <orbisvicis> What are my options for a pattern guard like: (pattGuard && boolGuard) || boolGuard
07:38:54 <kuribas> hmm, when it comes to ecommerce or CMS, haskell seems quite poor.
07:38:57 <orbisvicis> as far as I know there's no way to express boolean or in guards so this would have to be multiple function expressions or wrapped in a boolean guard sub expression (let/where)
07:41:03 <ph88> Taneb, mapM_ is for Foldable .. i have a traversal with lens
07:41:50 <Taneb> :t mapMOf_
07:41:51 <lambdabot> Monad m => Getting (Sequenced r m) s a -> (a -> m r) -> s -> m ()
07:41:54 <Taneb> :t mapMOf_ traversed
07:41:55 <lambdabot> (Traversable f, Monad m) => (a -> m r) -> f a -> m ()
07:41:58 <Taneb> :t mapMOf_ traversed print
07:42:00 <lambdabot> (Show a, Traversable f) => f a -> IO ()
07:42:08 <Taneb> :t mapMOf_ biplate print
07:42:09 <lambdabot> Data s => s -> IO ()
07:42:13 <dminuoso> orbisvicis: Wait a second. Are you talking about pattern guards or boolean guards?
07:42:23 <Taneb> ph88: it'll work (more or less)
07:42:57 <lemurs> :t head . map $ id [1..5]
07:42:58 <lambdabot> error:
07:42:58 <lambdabot>     • Couldn't match type ‘[a0] -> [b0]’ with ‘[c]’
07:42:58 <lambdabot>       Expected type: (a0 -> b0) -> [c]
07:43:10 <lemurs> :t head [1]
07:43:11 <lambdabot> Num a => a
07:44:00 <orbisvicis> dminuoso: a function guard that uses both with boolean or
07:44:34 <dminuoso> orbisvicis: I was just confused because Haskell has a distinct notion of something called "pattern guard"
07:44:51 <merijn> dminuoso: Distinct in what way?
07:45:09 * hackage sql-words 0.1.6.0 - SQL keywords data constructors into OverloadedString  http://hackage.haskell.org/package/sql-words-0.1.6.0 (KeiHibino)
07:45:41 <kuribas> anybody would like to help port prestashop to haskell? ;-)
07:47:26 <malade_mental> kuribas: why not, but we remove the client part :p
07:48:35 <dminuoso> merijn: Maybe I just dont understand the pseudo syntax involved there.
07:48:58 <kuribas> malade_mental: what client part?
07:49:00 <dminuoso> I mean the whole construct `pat <- infixexp` is a pattern guard right?
07:49:16 <merijn> dminuoso: Yes, but in what sense is it distinct from "regular" guards?
07:51:41 <dminuoso> merijn: It's just syntactically distinct from boolean guards.
07:51:54 <dminuoso> Im trying to understand what `(pattGuard && boolGuard) || boolGuard` is supposed to onvey
07:52:23 <merijn> dminuoso: "pattern guard and boolean guard succeed" OR "other boolean guard succeeds"
07:52:29 <orbisvicis> dminuoso: pattern guards and bool guards are both guards that can be mixed:
07:52:30 <orbisvicis> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13
07:52:48 <recursion-ninja> How do I download the cabal-2.2 binary for my Ubuntu system? I have cabal-2.0 installed on the system. I tried downloading and building cabal-install but I get linking errors related to -fPIC or -pie & -r being incompatible.
07:53:07 <orbisvicis> just not in the way I want
07:53:43 <lemmih> dminuoso: I found it confusing as well.
07:55:58 <dminuoso> orbisvicis: So if the pattern guard fails, what would happen to any bindings? Bottom?
07:57:21 <orbisvicis> the same thing when a boolean guard fails (I see a pattern guard as a boolean guard that tests a pattern as well as introduces local bindings)
07:58:19 <orbisvicis> oh I see what you mean
08:00:17 <orbisvicis> dminuoso: well thats a scoping issue so potentially solvable but a moot point since haskell can't do that anyway
08:00:19 <ph88> Taneb, i get a big list of () when i use   mapMOf_ biplate debugToken     (debugToken :: T -> String)
08:01:13 <Saizan> orbisvicis: (not . null $ [() | pattGuard , boolGuard ]) || boolGuard
08:01:19 <ph88> [(),(), ..]
08:03:11 <orbisvicis> heh scoping ^
08:04:33 <orbisvicis> tbh i don't think i'd ever want to use something like that though
08:04:41 <Taneb> ph88: oh, use mapMOf without the underscore isntead
08:05:19 <aarvar> ph88: because String = [Char], and then m = []?
08:06:14 <recursion-ninja> How do I download the cabal-2.2 binary for my Ubuntu system? I have cabal-2.0 installed on the system. I tried downloading and building cabal-install but I get linking errors related to -fPIC or -pie & -r being incompatible.
08:06:38 <ventonegro> recursion-ninja: There is a handy PPA for Ubuntu
08:06:52 <sclv> there are also binaries here, but i don't know if they're compat: https://www.haskell.org/cabal/download.html
08:06:58 <ventonegro> recursion-ninja: https://launchpad.net/~hvr/+archive/ubuntu/ghc
08:08:24 <ph88> Taneb, that gives me a type error  https://bpaste.net/show/d890fe69ac24
08:08:31 <recursion-ninja> ventonegro: I'll try the ppa
08:08:43 <Taneb> :t mapMOf biplate
08:08:44 <lambdabot> (Typeable a, Monad m, Data t) => (a -> m a) -> t -> m t
08:09:05 <Taneb> :t mapMOf biplate (\x -> [show x])
08:09:06 <lambdabot> Data t => t -> [t]
08:09:53 <Taneb> ph88: ack, it's going to be trying to modify them as well, I forgot that
08:10:46 <Taneb> :t \top -> top ^.. biplate . to (undefined :: Int -> String)
08:10:47 <lambdabot> Data s => s -> [String]
08:10:58 <Taneb> ph88: try something like that? I think I was overcomplicating things
08:11:12 <orbisvicis> dminuoso: I guess that's why all guards are AND'ed together and additional function definitions are implicit boolean OR - introduce new scoping
08:12:15 <ph88> Taneb, my debugToken function goes into  undefined ?
08:12:24 <ph88> it doesn't match type signature though
08:13:23 <Taneb> ph88: I'm pretending T is Int
08:13:30 <Taneb> (also I'm really tired and probably messing up)
08:13:36 <ph88> it's ok
08:14:12 <dminuoso> orbisvicis: On an unrelated note, that particular example of `(a && b) || b` was just (poorly) made up right?
08:14:30 <ph88> nice one Taneb seems to work well
08:15:43 <Taneb> I got there eventually :)
08:15:48 <helichopter> hey guys, if i have a set of values and functions of different types, like [ "string", 1, (+) ] is there a way for me to build a map that maps from a type to the values of that type?
08:17:21 <dminuoso> helichopter: It's called "a module" :P
08:17:45 <lyxia> https://hackage.haskell.org/package/dependent-map https://hackage.haskell.org/package/type-map
08:30:54 <orbisvicis> dminuoso: not really, I wanted to merge two function definitions that share the same code, and do that twice within an instance declaration (I don't think you can use/where at the instance scope)
08:33:54 <orbisvicis> dminuoso: also, I meant (a && b) || c
08:36:13 * hackage freq 0.0.0 - TBA  http://hackage.haskell.org/package/freq-0.0.0 (chessai)
08:44:10 * hackage constrictor 0.1.1.0 - strict versions of many things in base  http://hackage.haskell.org/package/constrictor-0.1.1.0 (chessai)
08:48:50 <dmwit> helichopter: https://hackage.haskell.org/package/dependent-map-0.2.4.0/docs/Data-Dependent-Map.html ?
08:53:04 <BernhardPosselt> whats an example for BiFunctor? a Pair?
08:54:36 <Akii> :i Bifunctor
08:54:43 <Akii> has a lot of instances
08:54:56 <Akii> Either, I think functions are a Bifunctor as well
08:55:01 <Akii> maybe
08:55:17 <BernhardPosselt> why maybe?
08:55:25 <BernhardPosselt> or how does Maybe have an instance?
08:55:31 <Akii> nah, "maybe a bifunctor"
08:55:34 <Akii> I was wrong
08:55:36 <BernhardPosselt> i see :)
08:55:38 <Akii> http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html
08:55:46 <Akii> if you look at the instances
08:56:03 <BernhardPosselt> shouldnt there be an NFunctor as well :D?
09:00:25 <EvanR> a function isnt a bifunctor because its contravariant in the first type param
09:00:43 <EvanR> this is where profunctor comes in
09:01:46 <Akii> yeah confused those
09:01:59 <Akii> but there isn't an instance Profunctor (->)?
09:02:20 <lyxia> there is
09:02:39 <Akii> hm couldn't find that but oh well
09:03:42 <lyxia> Profunctor ((->) LiftedRep LiftedRep)  it's not very visible because of these kinds
09:03:49 <lyxia> https://hackage.haskell.org/package/profunctors-5.2.2/docs/src/Data-Profunctor-Unsafe.html#line-191
09:11:30 <BernhardPosselt> i suppose variance has a difference meaning without subtyping
09:11:53 <BernhardPosselt> different*
09:18:39 * hackage pandoc-lens 0.6.3 - Lenses for Pandoc documents  http://hackage.haskell.org/package/pandoc-lens-0.6.3 (BenGamari)
09:18:42 * hackage butcher 1.3.1.0 - Chops a command or program invocation into digestable pieces.  http://hackage.haskell.org/package/butcher-1.3.1.0 (lspitzner)
09:23:38 <nkaretnikov> Is it a good idea to place my library modules under GHC.Prim.Something if my library heavily relies on primops, or is it specifically just for the GHC compiler?
09:24:52 <geekosaur> I'd leave the whole GHC hierarchy for the compiler
09:26:03 <ertes> nkaretnikov: if it's supposed to be safe, just use names you would normally use…  for unsafe stuff "*.Internal" is a common convention
09:30:22 <steazyde> hello?
09:31:24 <lemmih> It's me?
09:33:41 <steazyde> I'm new to haskell and got some exercies from uni, I have no idea what exactly it is tho and am struggeling to find how it works, could anyone maybe answe me some questions regarding this http://lpaste.net/364929 ?
09:34:15 <lemmih> steazyde: How about following a tutorial first to get the basics down?
09:34:42 <steazyde> I'm not really struggeling with basic how to's since I have experience in c#
09:34:51 <steazyde> but I'm not even sure w/e this is called and look it up
09:35:01 <Hjulle> Is it possible to make QuickCheck allow, but ignore slow test cases? Something like prop_asdf x = within 100 (maybeSlowPart x) ==> some_prop x, except that ==> requires the first argument to be Bool, not Property.
09:35:10 <lemmih> steazyde: C# is a bit different from Haskell, though.
09:35:58 <steazyde> I know but for example this fieldA, is it supposed to be an Array or List? As what is it definde so I could look it up, I need to cross check values and maybe if it is possible edit some of those variables.
09:36:10 * hackage machinecell 4.0.1 - Arrow based stream transducers  http://hackage.haskell.org/package/machinecell-4.0.1 (HidenoriAzuma)
09:36:13 <steazyde> im referencing this http://lpaste.net/364929
09:36:24 <lemmih> steazyde: 'fieldA' is a function.
09:36:39 <lemmih> steazyde: Lists look like this:
09:36:42 <lemmih> > [1..5]
09:36:44 <lambdabot>  [1,2,3,4,5]
09:37:09 <steazyde> Hm ok
09:37:26 <mnoonan> steazyde: the definition of fieldA is in the snippet you shared; those lines at the end define it for various inputs
09:37:30 <lemmih> steazyde: Following a Haskell tutorial will very quickly teach you the difference between lists, arrays and functions.
09:39:30 <steazyde> Ok, well I just figured out my problem, I was miss typing the function hence it wasn't working, lol
09:42:17 <chorhizo> steazyde: fyi there's also another channel #haskell-beginners you can use
09:48:40 <Hjulle> Is there a specific QuickCheck channel or is this the best place to get answers on QuickCheck internals? Perhaps a mail on cafe or a stackoverflow question would be better?
09:53:03 <lyxia> Hjulle: here, the haskell-cafe mailing list, and the QuickCheck issue tracker
09:53:56 <lyxia> there is also a googlegroup linked in the readme but I have never been there
10:27:02 <lyxia> Hjulle: you can use 'discard' after a timeout
10:27:26 <Hjulle> lyxia: How would I do that?
10:29:30 <Akii> does anyone know where Spacemacs determines what intero version to install? I have absolutely no clue.
10:29:43 <Akii> it's installing 1.20 where I'd like to have 1.40
10:31:11 <cocreature> Akii: there is an intero-package-version variable
10:31:25 <Akii> uuuh
10:31:39 * hackage sbp 2.3.16 - SwiftNav's SBP Library  http://hackage.haskell.org/package/sbp-2.3.16 (markfine)
10:32:04 <cocreature> Akii: but I’m not sure where you’re getting 1.40 from, afaict 0.1.30 is the latest unreleased version
10:32:22 <Akii> :o I saw some 1.40 yesterday somewhere
10:32:35 <cocreature> and updating your emacs packages is probably a better idea than just changing the version number
10:32:54 <cocreature> otherwise you might end up with incompatible versions of the emacs integration and the intero executable
10:34:23 <Akii> oh, hey, look, 143 packages to update
10:34:28 <Akii> I had no idea this was a thing
10:35:28 <Akii> man stone age I tell you
10:35:42 <Akii> I've been purposely avoiding pandoc v2
10:35:47 <Akii> because it has this new monad
10:35:57 <Akii> but I guess that can't be helped anymore
10:38:09 <Akii> welp, thanks again
10:40:27 <cocreature> avoiding updates is usually not a good long term strategy :)
10:43:17 <Akii> yeah I just ignored that so hard. Because I never really wanted to dig more into spacemacs since with every update I hit some bugs (like I did just now again..)
10:43:27 <Akii> even reset to some commit hash
10:43:34 <Akii> but I think it's good now
10:44:19 <Akii> GHC 8.2 hyp
10:44:20 <Akii> e
10:45:31 <glguy> You're hyping the previous version of GHC?
10:46:47 <Akii> well it's an upgrade for me :D
10:47:11 <magicman_> @hoogle swapMVar_
10:47:12 <lambdabot> No results found
10:48:31 <magicman_> Hrm. I guess I could just void that.
10:48:50 <KaHaSt> typetetris added to the channel by simon.fromme
10:50:34 <ertes> is there a library to convert storable Vector to ByteString?  ideally even directly from storable MVector
10:58:10 <zincy> Hmm I keep getting this msg after a few rounds of building and running my server locally -  auction-server-exe: Network.Socket.bind: resource busy (Address already in use)
10:58:31 <Psybur> zincy, maybe you have a zombie process
10:58:43 <exarkun> zincy: Do you have `netstat`?
10:58:56 <exarkun> zincy: If so, it will probably show you some TIME_WAIT or CLOSE_WAIT sockets still using the port.
10:59:05 <exarkun> zincy: They'll expire in 2 minutes.
10:59:25 <exarkun> zincy: You can avoid having to wait by setting SO_REUSEADDR on your listening socket.
10:59:26 <zincy> Yeah I have netstat
10:59:47 <exarkun> (Basic BSD sockets behavior, faithfully exposed by Haskell)
10:59:50 <zincy> I am getting really odd behaviour where only one socket can connect at once
10:59:58 <zincy> to the server
11:00:21 <exarkun> Unless you took steps to support concurrent connections, that's to be expected.
11:00:43 <zincy> There are a bunch of CLOSE_WAITS
11:00:48 <zincy> What does that mean
11:01:08 <exarkun> https://www.google.com/search?q=tcp+state+diagram&num=20&tbm=isch&source=iu&ictx=1&fir=y-pF_t4h3aaMkM%253A%252C9GWFtQLKmVLrSM%252C_&usg=__hJ-42a0HfbH2WbhjkVkDbEDLjvc%3D&sa=X&ved=0ahUKEwiSzZfr8cHaAhWpdN8KHWiGCe8Q9QEIKzAA#imgrc=y-pF_t4h3aaMkM:
11:01:22 <monochrom> w00t haha
11:01:37 <exarkun> I highly recommend https://www.amazon.com/UNIX-Network-Programming-Richard-Stevens/dp/0139498761
11:02:12 <woodson> Hey guys, I miso package with nix and when I get in my shell and run ghcjs-pkg list it shows me a version lower then the one that I downloaded with nix-env
11:02:12 <woodson> can anyone help with this?
11:02:12 <zincy> Thats on my list of to reads
11:02:52 <exarkun> Chances are there is some higher level Haskell library that will help you accomplish your goals while somewhat isolating you from these low-level details
11:03:43 <zincy> Yeah I am only using the websockets library atm
11:13:32 <zincy> So weird some small change I made to the code seemed to break the servers ability to handle websocket connections on a lower lvl
11:18:58 <jared-w> Does anyone know why I can't make a (..) function? I know .. is reserved for [a..b] syntax, but why isn't it available elsewhere?
11:20:01 <glguy> [a..b] would be the single element list containing the value  a..b
11:20:31 <glguy> reservedop → .. | : | :: | = | \ | | | <- | -> | @ | ~ | =>
11:21:52 <ZeuPiark> bye
11:22:13 <lemmih> ZeuPiark: Bye!
11:41:09 <iqubic> What's the correct way to write the factorial fuction with fix?
11:44:14 <glguy> fix (\_ n -> product [1..n])
11:44:34 <monochrom> >:)
11:45:19 <monochrom> http://www.luschny.de/math/factorial/FastFactorialFunctions.htm
11:45:26 <monochrom> Please don't use product [1..n].
11:46:07 <glguy> fix (\rec acc i -> if i == 0 then acc else rec (acc*i) (i-1)) 1
11:47:31 <iqubic> I see. so the function passed into fix gives either the rule to generate the next step in the process, or the end condition.
11:47:35 <aarvar> glguy: you're missing a seq aren't you?
11:47:42 <Akii> I can't figure out how to pandoc anymore
11:47:54 <Akii> anyone got an idea how to runPure after readMarkdown?
11:48:36 <Akii> that was so easy before
11:48:44 <glguy> aarvar: It wouldn't change anything, GHC knows how to do strictness analysys
11:50:06 <glguy> well, I guess that depends on which type you're running this at, for Int it's fine
11:50:15 <iqubic> :t para
11:50:16 <lambdabot> Plated a => (a -> [r] -> r) -> a -> r
11:50:24 <iqubic> that's not what I wanted.
11:50:47 <aarvar> glguy: does it work in this case though?
11:50:51 * aarvar goes to test it
11:50:52 <glguy> yeah
11:53:47 <Akii> oh no, hackage, don't die, not now
11:53:58 <jared-w> glguy: ah, that's true. Forgot about how tha tmight make the syntax too ambiguous
11:54:25 * hackage butcher 1.3.1.1 - Chops a command or program invocation into digestable pieces.  http://hackage.haskell.org/package/butcher-1.3.1.1 (lspitzner)
11:55:31 <masaeedu[m]> Is there such a thing as a "weak isomorphism"?
11:55:40 <iqubic> :t merge
11:55:42 <lambdabot> error: Variable not in scope: merge
11:55:47 <iqubic> Oh, alright.
11:56:10 <masaeedu[m]> that is, a pair of morphism between two types whose composition is always `id` for all values of the first type, but not necessarily so for values of the second
11:56:46 <masaeedu[m]> e.g. `Map`s and pair lists
11:57:07 <masaeedu[m]> `toList . fromList` is always `id` for any `Map`, but not necessarily so for any pair list
11:57:25 <iqubic> This is my favorite version of mergesort. http://dpaste.com/3S26855
11:57:27 <jared-w> https://math.stackexchange.com/questions/1283582/does-this-notion-of-weak-isomorphism-exist-in-literature looks like it might be what you're looking for?
11:57:51 <jared-w> iqubic: lol, because of the naming of everything?
11:57:52 <iqubic> I don't even fully understand how that merge sort works.
11:58:21 <iqubic> see this: https://gist.github.com/jtobin/ec5bb67a1ca2fed9c461
11:58:24 <jared-w> hylo => fold . unfold (if you squint a little)
11:58:34 <iqubic> It will help you grok the code better.
11:58:37 <masaeedu[m]> jared-w: I saw that in the search results, but I don't really understand what the notation means
11:58:57 <masaeedu[m]> or what a magma is
11:59:00 <aarvar> glguy: looks like it works for Int but not Integer
11:59:02 <jared-w> ahh okay, let me translate that to haskell a little bit :)
11:59:17 <jared-w> A magma is a monoid but with less information in the structure
11:59:32 <aarvar> or no, maybe it does work for integer too
11:59:42 <jared-w> In math, most algebraic structures (monoid, magma, semigroup, etc), are defined as tuples
11:59:57 <iqubic> But the question is: could you write merge without explicit recursion, by using one of those recursion schemes?
12:00:28 <iqubic> merge :: [a] -> [a] -> [a]
12:00:33 <jared-w> so (N, *, 1)  <-- the monoid over natural numbers with mappend = (*), mempty = 1
12:01:03 <iqubic> where the inputs are both sorted, and so is the output.
12:01:40 <jared-w> so the forall thing is saying, roughly, that eta ( x <> y) = squiggle(x) <> squiggle(y)
12:02:13 <masaeedu[m]> how would i build a mental correspondence between magmas and my more pedestrian example of `toList . fromList = id`, but `fromList . toList != id`
12:03:04 <masaeedu[m]> when the OP there says `(M,∘)`, is that the empty and append of a monoid?
12:03:09 <masaeedu[m]> or monoidy thing
12:03:19 <jared-w> It's a magma, so it has less structure than a monoid
12:03:34 <jared-w> a magma doesn't have an identity element and it doesn't have the same associative guarantees that a semigroup does
12:03:50 <jared-w> so you have some set of things M and the magma operation •
12:04:31 <jared-w> you can substitute semigroup whenever you see magma and get something pretty close :)
12:04:35 <aarvar> masaeedu[m]: you mean partial isomorphisms?
12:05:03 <masaeedu[m]> ok
12:05:30 <masaeedu[m]> that operation being `M -> M`
12:05:33 <jared-w> yes
12:06:17 <masaeedu[m]> aarvar: I'm not sure, haven't heard of those
12:06:25 <jared-w> It's not quite related to what you want but it's very similar
12:06:53 <jared-w> The thing that's tripping me up a little bit is you seem to want a monoid like structure that's not associative. However that's already a thing
12:07:08 <jared-w> `a . b != b . a` in general for monoids or semigroups
12:07:31 <EvanR> you mean thats not commutative?
12:07:36 <masaeedu[m]> well that's the thing, i'm not sure I really want it limited to monoids
12:07:40 <jared-w> err, yeah, I always mix those two up, m'bad
12:07:45 <EvanR> o_O
12:07:47 <jared-w> (also those dots should be <> whoops)
12:07:48 <masaeedu[m]> `Iso` is a very general thing
12:07:48 <EvanR> blasphemy
12:08:30 <masaeedu[m]> it just means there's a way to lift values in one domain into and out a codomain while ensuring you get the same thing out
12:08:34 <jared-w> EvanR: I'm pretty deaf so I've never really heard them outloud. To me they rhyme a lot and they're both about very similar things so I never was able to fully separate the two out in my head
12:08:48 <masaeedu[m]> but it seems like it's too strong a demand, because some things will only obey that in one direction
12:09:07 <masaeedu[m]> as with `Map k a` and `[(k, a)]`
12:09:34 <jared-w> right, I see what you're saying. I'm almost positive there's this nifty little math thing for that but I've got no idea what it's called off the top of my head
12:10:16 <masaeedu[m]> monoids and semigroups etc. is something different (as far as I understand) because it's talking about a binary operation on two values in a single domain
12:10:26 <masaeedu[m]> and laws concerning that operation
12:12:57 <Lears> masaeedu[m]: aren't you just looking for homomorphisms? Functions with the same structural properties as isomorphisms that aren't necessarily bijective.
12:13:07 <jared-w> yeah, I got a bit confused for a second there and mixed up what you were saying and the SO answer, m'bad
12:14:04 <masaeedu[m]> nno worriesJjared-w ::
12:14:42 <masaeedu[m]> i blame my keyboard
12:14:47 <jared-w> lol
12:15:05 <jared-w> iqubic: did you figure out the recursion schemes thing yet?
12:17:51 <aarvar> masaeedu[m]: https://ncatlab.org/nlab/show/split+monomorphism
12:18:16 <jared-w> mergesort = hylo toList toTree, essentially. You turn a sorted list into a tree (think the first half of the bottom up merge sort algorithm). Then you turn the tree into a list and at every fork you merge the left and right lists
12:19:41 <masaeedu[m]> aarvar: Cool, from what i'm reading that's exactly it
12:20:18 <jared-w> of course it's on nLab.. :)
12:20:34 <masaeedu[m]> I actually remember seeing something about sections and retractions in some haskell library
12:20:36 <masaeedu[m]> i wish i could remember which one
12:20:38 <aarvar> I couldnt find it on wikipedia
12:20:52 <chorizo> jared-w, so does that unfold the input into a tree, then fold it into a list?
12:21:32 <jared-w> Yeah, that's what hylo does. Unfold the input with your coalgebra function, then fold the input with your algebra function
12:21:45 <chorizo> that's actually insane lol
12:22:10 <chorizo> pretty sure I'll never get to the point where I can think of something like that
12:22:42 <iqubic> Are we discussing the merge sort?
12:22:55 <jared-w> yeah
12:22:56 <chorizo> yeah
12:23:29 <iqubic> I haven't figured it out.
12:23:32 <jared-w> It's not too bad; it definitely breaks your brain a bit, but after a while it'll come naturally
12:23:43 <jared-w> (not that it comes naturally to me yet lol)
12:24:32 <iqubic> What I'm wondering is if there is a way to write "merge :: [a] -> [a] -> [a]" without explicit recursion
12:24:51 <jared-w> ahh right
12:24:58 <chorizo> reading the type signature for hylo
12:25:03 <chorizo> is confusing me to no end
12:25:18 <monochrom> Theorem: Every function is a hylo.  (Not that you always want it that way.)
12:25:36 <EvanR> iqubic: use fix? :)
12:25:46 <chorizo> monochrom, oh, is it provable?
12:25:46 <Taneb> I did define "mergesort" as a hylomorphism successfully a few months ago
12:26:03 <masaeedu[m]> iqubic: is `merge` `zip`?
12:26:04 <sl2c> EvanR: i think the main trouble is actually that it's usually defined symmetrically and can pull from either list
12:26:25 <jared-w> chorizo: edwardk mentioned at one point that hylo was turing complete. Not sure if that's true or if I hread him wrong, but it's definitely interesting to think about
12:26:31 <iqubic> masaeedu[m]: No because both input lists are sorted, and so is the out put.
12:26:38 <sl2c> but there should be a way to do it as a fold of one list with an intermediate state of the other one
12:26:48 <iqubic> What?!?
12:26:52 <monochrom> The proof is cheesy: There exists a suitable intermediate data structure custom-made for your function.
12:26:59 <jared-w> lol
12:27:12 <jared-w> Either way, don't read the type of ghylo,` hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b` is much more understandable
12:27:39 * hackage semver-range 0.2.7 - An implementation of semver and semantic version ranges.  http://hackage.haskell.org/package/semver-range-0.2.7 (thinkpad20)
12:27:58 <jared-w> (f b -> b)  is the algebra. You fold a container of b's into a single b.  (a -> f a) is the unfold. You unfold a starting seed into a container of a's
12:28:06 <chorizo> I think I need to think about unfold a bit, I haven't used it at all
12:28:17 <jared-w> then, giving a starting value to kick the whole thing off, hylo will first unfold then fold, resulting in a b :)
12:28:21 <chorizo> do we know what toList and toTree would be?
12:28:36 <jared-w> http://dpaste.com/3S26855
12:28:39 * hackage vector-text 1.1.3 - Text implementation based on unboxed char vector.  http://hackage.haskell.org/package/vector-text-1.1.3 (danilo2)
12:28:45 <chorizo> unfold is like, unfoldr (/2) 50 = [50, 25, 12, ...] right?
12:28:59 <chorizo> jared-w, thanks
12:28:59 <jared-w> > unfoldr (/2) 50
12:29:01 <lambdabot>  error:
12:29:01 <lambdabot>      • Couldn't match type ‘Integer’ with ‘Maybe (a, Integer)’
12:29:01 <lambdabot>        Expected type: Integer -> Maybe (a, Integer)
12:29:11 <jared-w> not quite, but that's the moral idea behind it :)
12:29:30 <iqubic> :t unfold
12:29:31 <lambdabot> error:
12:29:32 <lambdabot>     • Variable not in scope: unfold
12:29:32 <lambdabot>     • Perhaps you meant one of these:
12:29:39 <chorizo> :t unfoldr
12:29:40 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:29:56 <monochrom> There is a corresponding theorem for imperative programming under weakest precondition predicate transformer.  Its proof is is similar: There exists an intermediate state space custom-made for your program.
12:30:07 <masaeedu[m]> how does it turn the `f a` into an `f b`?
12:30:59 <monochrom> Their value though is theoretical: They are normal-form theorems.  If you want to prove something like "every function satisfies blah semantically", you just have to prove "every hylo satisfies blah semantically".
12:31:20 <Taneb> masaeedu[m]: by fmap'ing hylo ;)
12:31:27 <iqubic> > unfoldr (\x -> if x > 0 then Just (x `div` 2, x `div` 2) else Nothing) 512
12:31:30 <lambdabot>  [256,128,64,32,16,8,4,2,1,0]
12:31:39 <iqubic> See it works like that.
12:31:45 <sl2c> chorizo: you're thinking of iterate
12:31:49 <sl2c> > iterate (/2) 50
12:31:51 <lambdabot>  [50.0,25.0,12.5,6.25,3.125,1.5625,0.78125,0.390625,0.1953125,9.765625e-2,4.8...
12:31:52 <Taneb> masaeedu[m]: hylo f g gives us a function a -> b, and we just need a function f a -> f b to define it
12:32:00 <Taneb> masaeedu[m]: luckily there's fmap (hylo f g)!
12:32:02 <sl2c> > (iterate (/2) 50) :: [Int]
12:32:04 <lambdabot>  error:
12:32:04 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
12:32:04 <lambdabot>      • In the first argument of ‘iterate’, namely ‘(/ 2)’
12:32:12 <sl2c> > (iterate (`div`2) 50) :: [Int]
12:32:14 <lambdabot>  [50,25,12,6,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
12:32:15 <jared-w> `unfoldr (if continue then compute next step else stop)` is the general idea
12:32:29 <Taneb> masaeedu[m]: this works because the functor will have a case that doesn't contain any data, so the fmap is trivial (like an empty list)
12:32:29 <iqubic> Which is more or less what I did.
12:32:38 <jared-w> It's exactly what you did :p
12:32:49 <Taneb> > fmap (error "nope") []
12:32:52 <lambdabot>  []
12:32:55 <Taneb> > fmap (error "nope") Nothing
12:32:57 <lambdabot>  Nothing
12:33:01 <chorizo> does unfoldr have any benefit over something like takeWhile (condition) $ iterate (f) x
12:33:02 <Taneb> > fmap (error "nope") (Left 10)
12:33:04 <lambdabot>  Left 10
12:33:08 <iqubic> > unfoldr (\x -> if x > 0 then Just (x, x `div` 2) else Nothing) 512
12:33:10 <lambdabot>  [512,256,128,64,32,16,8,4,2,1]
12:33:31 <Taneb> masaeedu[m]: so, any functor you'd use, either is sufficiently lazy so it doesn't matter that it never stops, or it reaches a case that's trivial to fmap with
12:33:34 <jle`> chorizo: the thing you make can be of a different type than your 'state'
12:33:58 <Taneb> masaeedu[m]: does this make things a little clearer?
12:34:01 <Akii> oh.... em... geee. Nix has built my project
12:34:20 <jared-w> > unfoldr (\x -> if x > 0 then Just (x, "hello") else Nothing) 1
12:34:22 <lambdabot>  error:
12:34:22 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘0’
12:34:22 <lambdabot>      • In the second argument of ‘(>)’, namely ‘0’
12:34:23 <chorizo> jle`, oh I see, so you can unfold a list into a tree structure, for example
12:34:30 <jle`> oh no that's what i mean
12:34:33 <jared-w> whoops
12:34:42 <dsal> when are packages added to stackage LTS?
12:34:46 <jle`> chorizo: i mean that iterate takes a seed of type 'a' and produces a list of a's
12:34:49 <jared-w> no I'm tired and I spaced out on the type signature, m'bad :p
12:34:56 <jle`> chorizo: unfoldr takes a seed of type 'a' and produces a list of b's
12:35:10 <monochrom> When the next LTS is defined?
12:35:16 <jle`> iterate traces the progression of a seed itself
12:35:26 <masaeedu[m]> it makes things a little clearer, but i've started out in a total fog
12:35:30 <masaeedu[m]> :)
12:35:31 <monochrom> I mean LTS sounds like one of those write-once read-many things.
12:35:32 <chorizo> jle`, oh I see
12:35:42 <dsal> monochrom: So like, 12.0?
12:35:57 <monochrom> I don't actually track stack news.
12:36:04 <jle`> chorizo: iterate takes a (a -> a), but unfoldr takes (a -> Just (b, a))
12:36:05 <dsal> A new package I use just got added.  It's in nightly.  Just wondering how the progression works.
12:36:09 <chorizo> jle`, so instead of unfolding int -> [int] you could do int -> [bool]
12:36:24 <chorizo> jle`, while with iterate you couldn't
12:36:26 <jared-w> :t unfoldr -- right
12:36:28 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:36:32 <jle`> chorizo: yeah.  but you were on the right track
12:36:41 <monochrom> But it's pretty common knowledge that Stack LTS is immutable.
12:36:46 <jle`> chorizo: it's basically iterate + takeWhile/map, for lists
12:36:52 <chorizo> jle`, ah that's cool. I hadn't really looked at iterates signature fully
12:37:03 <jared-w> :t iterate
12:37:04 <lambdabot> (a -> a) -> a -> [a]
12:37:15 <jle`> i think unfoldr for lists can be just an iterate + takeWhile + map, but it's probably less efficient
12:37:22 <dsal> monochrom: Heh, I know it's not going to retroactively add to an LTS.  Just wondering if it'd add to an 11.x, 12.0, or whether something else has to happen.
12:37:33 <jle`> in case you want to re-compute things for your stopping condition and your map
12:37:37 <monochrom> Ah then I don't know.
12:37:47 <chorizo> is there a reason iterate can't be (a -> b) -> a -> [b], can b not be equal to a?
12:37:56 <chorizo> because you can do unfoldr with a -> [a]
12:37:58 <jle`> chorizo: where do you get the new 'a' from?
12:38:21 <jle`> you only have one a to work with ever, in that case
12:38:38 <jle`> so the only implementations are \f x -> [], or \f x -> [f x], or \f x -> [f x, fx]
12:38:58 <jle`> basically \f x -> replicate N (f x)
12:38:59 <EvanR> types are great at revealing how things dont make sense
12:39:16 <EvanR> revealing how things dont make sense is great
12:39:44 <iqubic> yep. yep. yep.
12:39:57 <chorizo> jle`, I think I'm thinking about this incorrectly, if you have one a, a isn't a value it's a type right?
12:40:06 <aarvar> unless you frequently don't make sense and would rather pretend otherwise
12:40:13 <jle`> chorizo: yeah, but you only have one value of type 'a'
12:40:20 <jle`> where would you get a second one from?
12:40:20 <EvanR> aarvar: i guess that could be bad
12:40:39 * hackage prologue 3.1.7 - Better, more general Prelude exporting common utilities.  http://hackage.haskell.org/package/prologue-3.1.7 (danilo2)
12:40:42 <jle`> for iterate, you get it from applying the function to get a new 'a'
12:41:06 <EvanR> > iterate f x
12:41:07 <chorizo> right, but in unfoldr apply a function to it right?
12:41:08 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
12:41:18 <jle`> chorizo: what do you mean?
12:41:37 <jle`> look at the function types that iterate and unfoldr take
12:41:38 <EvanR> ^ why iterate must take (a -> a)
12:41:44 <jle`> (a -> a), and (a -> Maybe (b, a))
12:41:52 <jle`> both of them return "new a's" for you to repeatedly apply the function to
12:42:04 <chorizo> oh I see
12:42:06 <chorizo> :t unfoldr
12:42:07 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:42:12 <jle`> otherwise the only thing you can do is repeatedly apply the 'a' you got
12:42:21 <jle`> er, repeatedly apply the functio to the same 'a' you got
12:42:25 <chorizo> I see what you mean now, it's the Maybe (a, b) that allows it
12:42:27 <jle`> and then you will just get the same 'b' every time
12:42:32 <chorizo> is that why it has a tuple?
12:42:34 <iqubic> I'm watching this introduction to recursion schemes right now. https://www.youtube.com/watch?v=i5A2Amfcir8
12:42:49 <helichopter> lyxia, thanks for the recommendations. i'm trying to use your type-map, do you know how I can have keys of different arity?
12:42:51 <chorizo> I should probably just go an research this instead of spamming this channel lol
12:43:09 <jared-w> I like the spam
12:43:15 <jared-w> it keeps me from going to class and being bored
12:43:21 <chorizo> haha
12:43:41 <jle`> chorizo: unfoldr repeatedly updates a seed (the 'b') with the function, and accumulates the resulting a's that get emitted along the way
12:44:00 <iqubic> iterate is (unfoldr \f x -> Just (x, f x))
12:44:03 <iqubic> More or less.
12:45:10 <lyxia> helichopter: what do you mean
12:45:26 <chorizo> iqubic, that's what I thought, that makes sense
12:45:43 <Emblis> How come this is not acceptable syntax? val <- read getLine :: Int
12:46:10 <chorizo> jle`, I might just go and implement both, I think I get it now though
12:46:11 <jle`> Emblis: it's acceptable in do notation
12:46:18 <jle`> oh
12:46:18 <cocreature> it also has a type error
12:46:23 <jle`> yes, it's acceptable syntax
12:46:30 <jle`> it's just a type error
12:46:56 <jle`> but it's not accepted at the top level, since `.. <- ..` only makes sense in do notation
12:47:07 <helichopter> lyxia, I'd like to do something like TM.insert @[Integer] [1,0] emptyS . TM.insert @[Integer -> Integer -> Integer] [(+), (*)] emptyS
12:47:12 <Emblis> I am aware of that it only works in a do notation
12:47:19 <Emblis> I fail to see where the type error is tho
12:47:23 <jle`> yes, so it is acceptable syntax
12:47:32 <jle`> Emblis: check the types :)
12:47:37 <jle`> what is the type of 'read' ?
12:47:41 <jle`> what is the type of 'getLine' ?
12:47:43 <jle`> are they compatible?
12:49:08 <Emblis> It is ok if I bind it and then read the binded value, I was hopping to avoid that suggar
12:49:10 <jle`> hint: if you try writing that in code, ghc will typecheck it and tell you why the types are incompatible
12:49:23 <jle`> in the resulting type error
12:49:43 <EvanR> you can :t read and :t getLine in ghci to see what the issue is pretty clearly
12:50:27 <Emblis> Thank you, I see the issue. Just strugging with how to correct it now :)
12:50:31 <jle`> Emblis: by the way, you can lift any (a -> b) function to work in an IO a
12:50:42 <jle`> by using fmap :: (a -> b) -> (IO a -> IO b)
12:50:53 <EvanR> fmap f maps f over an IO action
12:50:55 <jle`> read :: String -> Int
12:51:01 <jle`> fmap read :: IO String -> IO Int
12:51:05 <EvanR> or any functor value
12:52:15 <chorizo> welp I'm just dumb, I didn't realise iterate has to be a -> a because it's doing f ( f ( f (...
12:52:36 <EvanR> yeah i told lambdabot to say so
12:52:43 <TheMaster876> #Noob
12:52:49 <jared-w> hah, it happens :)
12:52:56 <Emblis> Thank you for your help :D
12:53:52 <lyxia> helichopter: TM.insert @[Integer] [1,0] . TM.insert @[Integer -> Integer -> Integer] [(+), (*)] $ emptyS   seems to compile
12:58:23 <jle`> chorizo: not dumb!  the reason why we use haskell is to let the compiler figure things like this out for us, so we don't have to :)
12:58:37 <iqubic> Why do so many people call Scala Functional?
12:58:52 <iqubic> Isn't it closer to OOP?
12:59:08 <chorizo> iqubic, can't you use it purely functionally?
12:59:30 <iqubic> sure.
12:59:55 <helichopter> lyxia, oh duh sorry, i was composing incorrectly. thank you!
13:00:15 <jared-w> It's more of a culture thing. Scala *can* be functional, but it can also be a "better java", so you end up with this huge culture rift
13:00:45 <jared-w> Those who treat Scala as a "tolerable haskell on the JVM" and those who treat Scala as a "less shitty Java" and the two never touch each other or communicate with eachother as doing so is a sin :p
13:00:51 <hexagoxel> they also call haskell functional, but clearly it is the best imperative language out there.
13:01:12 <chorizo> I think you'll find prolog is a btter imperative language
13:01:25 <lyxia> helichopter: don't hesitate to open an issue if you think something's missing
13:01:52 <helichopter> okay, thank you!
13:01:53 <jle`> calling a language functional/imperative etc. is not really a rigorous thing
13:02:11 <jle`> usually it is done to reflect the intention of language authors or users or educational material
13:02:19 <EvanR> call it functional when you want it to sound good
13:02:24 <EvanR> call it imperative when you want it to sound bad
13:02:45 <chorizo> call it go when you want it to sound terrible
13:02:49 <EvanR> unless this is python
13:02:53 <iqubic> EvanR: lol. so c++ is bad?
13:03:14 <jle`> does anyone think it is good?
13:03:14 * EvanR areyouserious.jpg at iqubic 
13:03:34 <jle`> i feel like the highest people regard c++ is as a necessary evil
13:04:01 <jared-w> Even the language creator is like "yeah, somewhere deep inside of this monstrosity is a much nicer language waiting to escape"
13:04:23 <chorizo> still can't tell what I prefer, c or c++
13:04:34 <EvanR> like a sculture of shit trapped inside an amorphous pile of shit?
13:04:41 <aarvar> jared-w: scala is tolerable for some generous definition of tolerable
13:04:54 <jared-w> I prefer C because it's not trying to pretend it's something it's not
13:05:09 <jared-w> C: "I'm a prettier and more portable assembly. Come at me bro, I'll eat your children"
13:05:17 <monochrom> Oh but it pretends to be close to hardware.
13:05:27 <jared-w> s/hardware/PDP11 ;)
13:05:33 <aarvar> jared-w: Scala: Something something dependent types scala is like idris
13:05:41 <hexagoxel> can't shoot yourself in the foot if your foot is immutable
13:05:46 <jared-w> lol. Do people actually say that?
13:05:51 <aarvar> yes
13:05:55 <jared-w> ಠ_ಠ
13:05:58 <monochrom> My criterion is if it doesn't tell me the carry flag it is not close to hardware.
13:06:02 <EvanR> immutable feet... brilliant
13:06:08 <jared-w> truly
13:06:25 <chorizo> monochrom, I code in nand gates, is that low enough
13:06:44 <jared-w> no, hardware is a lie
13:06:51 <EvanR> the boolean completeness of nand is all the rage right now
13:06:56 <aarvar> jared-w: while meanwhile, odersky is still trying to solve basic problems like how to define equality
13:07:04 <zachk> nor gates for the win
13:07:11 <monochrom> \∩/
13:07:15 <iqubic> I just realized why Fix is a thing. Data List a = Nil | Cons a (List a) and Data Tree a = Leaf a | Node (Tree a) a (Tree a) have different shapes. Fix gives you a way to fudge the two to give them the same shape, therefore allowing you to operate on them both with cata and ana and whatever.
13:07:17 <aarvar> because he wants scala to be OO and won't just accept that the "haskell" solution is better
13:07:31 <jared-w> equality is a highly non-basic problem to solve, tbh
13:07:38 <aarvar> er, I mean boolean equality
13:07:39 * jared-w glares vaguely at HoTT
13:07:41 <dysfun> scala is an interesting exercise in solving for arbitrary constraints
13:07:47 <jared-w> There we go :p
13:07:49 <aarvar> equivalence really, not equality
13:08:06 <EvanR> a random function of type A -> A -> Bool really
13:08:10 <chorizo> iqubic, oh, is that what fixed point recursion is used for?
13:08:30 <chorizo> did learn about the y-combinator and other stuff in a lamba calc course but didn't really see the use lol
13:08:32 <jle`> iqubic: yeah, it abstracts over recursive adts :)
13:08:39 <iqubic> I'm not sure. I'm still trying to grok this stuff.
13:08:41 <aarvar> jared-w: but if you're really bored, google scala dependent types
13:08:53 <iqubic> jle`: that's what I just realized.
13:08:56 <aarvar> see what you can find
13:09:07 <jle`> chorizo: y-combinator doesn't quite exist in haskell, and it isn't necessary
13:09:08 <EvanR> aarvar: from an industrial language designers perspective i can imagine being discouraged at knowing all about how haskell works, because if it does something good, you might say "people can just use haskell if they want that, no need to replicate it"
13:09:12 <jle`> but 'fix' can be useful
13:09:30 <chorizo> jle`, yeah, but fix uses fixed point recursion right?
13:09:31 <freeman42x]NixOS> any ideas why this code would be flaky? http://lpaste.net/364939 (except the fact that it is a thin wrapper around a C library) the window title is never obtained and the windows width is flaky, for some windows it is correct, for some windows it just shows width 1
13:09:35 <aarvar> EvanR: well, prior to eta, scala still had the jvm
13:09:50 <aarvar> EvanR: also, scala has exactly that problem now, but with people using Kotlin instead
13:09:59 <jle`> chorizo: fix is just a normal higher-order function
13:10:05 <jle`> fix f = f (fix f)
13:10:26 <EvanR> @src fix
13:10:26 <lambdabot> fix f = let x = f x in x
13:10:31 <EvanR> better
13:10:41 <jared-w> I like to think of it as: fix allows you to abstract over the structure part of structural recursion
13:11:09 <chorizo> hmm, little over my head atm, might have to look at that another time
13:11:11 <jared-w> So you can define things that work recursively without worrying about exactly how the recursion bit works
13:11:25 <zincy> I am getting a bug that is really tough to track down - do runtime exceptions get printed to stdout in haskell?
13:11:28 <jle`> chorizo: fix f = f (fix f), it works just like any other higher order function :)
13:11:31 <EvanR> fix is much harder to use than actual recursion though
13:11:33 <jared-w> "is this linear recursion? Is the structure something with branches? Is this a map defined inductively?" who cares?
13:11:43 <jle`> fix (1:) = 1 : (fix (1:))
13:11:53 <jared-w> > fix (1:)
13:11:55 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:12:02 <jle`> > head (fix (1:))
13:12:03 <monochrom> I think it is not so much fix and Fix themselves being useful as re-factoring your function and your type into open recursion being useful.  Because with open recursion you can now combine things in new ways, and/or you can replace fix by memoization.
13:12:04 <lambdabot>  1
13:12:05 <jared-w> > fix (:1) note that this won't work
13:12:07 <lambdabot>  error:
13:12:08 <lambdabot>      • Couldn't match expected type ‘t0 -> t1 -> t2 -> t3 -> t4 -> t’
13:12:08 <lambdabot>                    with actual type ‘[a0]’
13:12:20 <aarvar> jared-w: fix abstracts over general recursion though
13:12:24 * EvanR waits for someone to do fix error
13:12:36 <iqubic> jared-w: That's because (:1) makes no sense.
13:12:44 <jle`> chorizo: fix f is just f (f (f (f (f (f ...
13:12:46 <jared-w> > fix error "haskell is broked"
13:12:48 <lambdabot>  error:
13:12:48 <lambdabot>      • Couldn't match expected type ‘[Char] -> t’
13:12:48 <lambdabot>                    with actual type ‘[Char]’
13:12:53 <monochrom> For example Data Types a la Carte begins by re-factoring to open recursion.  Suddenly you can have extensible things.
13:13:13 <iqubic> :t fmap
13:13:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:13:46 <jared-w> iqubic: it doesn't make sense, but a lot of people get used to the idea that you can write (+1) or (1+) in a operator selection and it works pretty much the same so sometimes it's nice to remember that there's a technical difference :p
13:14:18 <EvanR> a lot of people get used to the idea that + takes any number of args you want
13:14:40 <monochrom> Scheme certainly perpetuates that.
13:14:44 <iqubic> EvanR: Those darn lispers
13:14:56 <jared-w> those little schemers
13:15:05 <monochrom> It's cute, to be sure.
13:15:08 <chorizo> > fix (1+)
13:15:12 <lambdabot>  *Exception: <<loop>>
13:15:16 <monochrom> But because of that, you lose currying.
13:15:18 <chorizo> I'm a genius
13:15:29 <jared-w> You sure added them ones damn fast though :)
13:15:59 <EvanR> lim (\x -> sin x)
13:16:24 <aarvar> as x approaches what?
13:16:30 <EvanR> infinity
13:16:39 <aarvar> also, should make it point free
13:16:39 <jle`> chorizo: in the semantic view, fix (1+) actually makes sense
13:16:50 <jle`> chorizo: since (1+) (undefined) = undefined
13:16:52 <monochrom> Then again ironically their way of adding back currying takes advantage of vararg to figure out what you what so it works fine again.
13:17:07 <jle`> chorizo: a fixed point is a value for `f` where `f x = x`
13:17:23 <jle`> so undefined is a valid fixed point for (1+), since (1+) undefined = undefined
13:17:48 <kuribas> EvanR: that limit doesn't exist
13:17:50 <monochrom> We also require "fix" to stick to the least one of all possible fixed points.
13:17:52 <AlexIsEpic> Hey everybody. I have a begginer question. I have a data type defined as a Map Integer [CustomData], called DT. How would I got about adding an entry to the list of custom data given a key?(trying to mimic a multimap)
13:18:09 <monochrom> And the criterion for "less" is "less information".
13:18:22 <nkaretnikov> when working at the primop level, what would happen if i confused the states inside IO $ \s -> ... ?
13:18:23 <jle`> AlexIsEpic: insertWith
13:18:33 <EvanR> domain theory to justify production freeze ups always goes over well with management
13:18:51 <jle`> AlexIsEpic: you can insertWith (++) [x]
13:19:13 <masaeedu[m]> is this fix point of floored division 0
13:19:25 <EvanR> "you see theres a topological interpretation of semidecidability"
13:19:27 <masaeedu[m]> > fix (/ 2)
13:19:30 <lambdabot>  *Exception: <<loop>>
13:19:43 <jle`> AlexIsEpic: if you want a bit more control, you can use 'alter'
13:19:51 <iqubic> > fix (and true)
13:19:52 <monochrom> So for example "x = 0 * x" has many solutions, among which bottom gives you the least information, therefore fix (\x -> 0 * x) = bottom.
13:19:53 <lambdabot>  error:
13:19:53 <lambdabot>      • Couldn't match expected type ‘a -> a’ with actual type ‘Bool’
13:19:53 <lambdabot>      • Possible cause: ‘and’ is applied to too many arguments
13:20:15 <monochrom> Err I guess not many.  bottom and 0.
13:20:17 <jle`> AlexIsEpic: alter (\case Nothing -> [x]; Just xs -> x:xs)
13:20:23 <aarvar> nkaretnikov: who knows :)
13:20:29 <iqubic> > fix (True and)
13:20:31 <jle`> er, alter (\case Nothing -> Just [x]; Just xs -> Just (x:xs))
13:20:33 <lambdabot>  error:
13:20:33 <lambdabot>      • Couldn't match expected type ‘([Bool] -> Bool) -> a -> a’
13:20:33 <lambdabot>                    with actual type ‘Bool’
13:20:46 <jle`> AlexIsEpic: but insertWith is the simplest way to do this
13:21:35 <iqubic> What is the type signature of cata?
13:21:54 <monochrom> masaeedu[m]: (/2) is not even floored division.
13:22:05 <AlexIsEpic> jle`: Would you mind checking out my code? I could show it to you through pastebin
13:22:12 <AlexIsEpic> jle`: I'm getting a type mismatch
13:22:22 <jle`> just paste it :)
13:22:28 <nkaretnikov> aarvar: i'm hoping to get a more detailed response :)
13:22:29 <jle`> if not me then someone else will see it
13:22:45 <aarvar> nkaretnikov: would depend on how you confused them I guess
13:22:55 <aarvar> and what the compiler feels like doing
13:23:21 <masaeedu[m]> `div 2`?
13:23:23 <AlexIsEpic> jle`: https://dpaste.de/QbaG I've pasted the relevant parts. The addSquare is where my problem is
13:23:31 <masaeedu[m]> i'm not sure i'm understanding what a fixpoint is correctly
13:23:44 <EvanR> > (-3) `div` 2
13:23:46 <lambdabot>  -2
13:24:04 <masaeedu[m]> based on what i've got in my head anything is a fixpoint of `id`
13:24:05 <jle`> masaeedu[m]: a fixed point for f is a value x where f x = x
13:24:13 <monochrom> No, instead, you are still missing the "least" part and the "less information" part.
13:24:21 <jle`> except, there is more than one fixed point for a lot of functions
13:24:37 <jle`> 'id' is an example of a function with multiple fixed points
13:24:47 <EvanR> > iterate (`div` 2) 99
13:24:49 <lambdabot>  [99,49,24,12,6,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
13:24:54 <EvanR> > iterate (`div` 2) (-99)
13:24:56 <lambdabot>  [-99,-50,-25,-13,-7,-4,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1...
13:25:04 <jle`> maerwald: so, the real question is, *which* fixed point does 'fix f' return?
13:25:07 <masaeedu[m]> `> 5 `div` 2 `div` 2 `div` 2 `div` 2
13:25:08 <jle`> * masaeedu[m]
13:25:12 <nkaretnikov> aarvar: okay, let's get concrete: f arr i = IO $ \s -> case readWord8Array# arr i s of (# s', wi #) -> (# s', W8# wi #) i can see myself returning (# s, W8# wi #) instead, what might happen? i could test of course, but testing only shows the presence of bugs not their absence :)
13:25:21 <iqubic> No. No. No. What the heck is this? Factorial is a Hylomorphism?!?!
13:25:26 <masaeedu[m]> should be 0
13:25:41 <jared-w> iqubic: why wouldn't it be? :p
13:25:41 <monochrom> And you're neglecting bottom.
13:25:41 <EvanR> > (-1) `div` 2
13:25:43 <lambdabot>  -1
13:26:00 <masaeedu[m]> ok, so does that mean `0` is a fixpoint of `div 2`?
13:26:07 <jle`> of `div` 2, yes
13:26:15 <jle`> (`div` 2)
13:26:18 <EvanR> 0, -1, and bottom
13:26:25 <masaeedu[m]> ok, that makes sense
13:26:28 <aarvar> nkaretnikov: hmm
13:26:29 <iqubic> How does the hylo function convert from an f a to an f b?
13:26:30 <jared-w> iqubic: it's also a fold (left fold more precisely)
13:26:30 <jle`> (`div` 2) has multiple fixed points
13:26:42 <jared-w> > foldl (*) 1 [1..10]
13:26:45 <lambdabot>  3628800
13:26:48 <jared-w> :t hylo
13:26:49 <lambdabot> error: Variable not in scope: hylo
13:27:00 <masaeedu[m]> so there's some special fixpoint we're driving at
13:27:00 <jle`> ^ in that example, [1..10] is the anamorphism
13:27:06 <iqubic> hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
13:27:09 <masaeedu[m]> that `fix` will find
13:27:10 <zincy> Could the following cause a runtime exception?
13:27:10 <masaeedu[m]> if it's there
13:27:10 <zincy> -instance ToJSON AuctionAction where -  toJSON a = toJSON $ show $ toJSON a
13:27:16 <jle`> and and foldr (*) 1 is the catamorphism
13:27:19 <aarvar> nkaretnikov: okay, so if you later didn't use the second element of the result, the array might never get read
13:27:22 <aarvar> I think
13:27:34 <jle`> AlexIsEpic: you need to insertWith the [p]
13:27:37 <iqubic> How does [1..10] make an ana?
13:27:38 <jle`> AlexIsEpic: note the type of insertWith
13:27:41 <jared-w> anyway, the point is that `factorial = hylo product (enumFromTo 1 n)` should work
13:27:42 <aarvar> er, I mean if you never use the word that gets read
13:27:48 <jle`> iqubic: [1..10] is unfoldring to 10
13:27:56 <jared-w> iqubic: [1..10] desugars to enumFromTo 1 10 which is just sugar over an unfold :)
13:28:12 <jle`> > unfoldr (\x -> if x <= 10 then Just (x, x + 1) else Nothing) 1
13:28:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:28:15 <iqubic> can I see [1..10] written as an unfold?
13:28:19 <iqubic> Oh, I see.
13:28:27 <AlexIsEpic> jle`: If I do that same code but with [p] I still get a mismatch
13:28:33 <jle`> can you paste the error
13:28:48 <nkaretnikov> aarvar: i guess the meta-question i'm asking is this: "what's the purpose of state in the compiler, and what does it keep track of?"
13:28:51 <aarvar> nkaretnikov: e.g. if you had 3 <$ arr i, that could reduce to IO $ \s -> (s, 3)
13:29:08 <jared-w> @let hylo f g = f . fmap (hylo f g) . g
13:29:09 <lambdabot>  Defined.
13:29:12 <nkaretnikov> aarvar: see above
13:29:21 <jared-w> :t product
13:29:22 <lambdabot> (Num a, Foldable t) => t a -> a
13:29:27 <jle`> AlexIsEpic: and ah yeah, i misread, it shouldn't be [p]
13:29:30 <jle`> but it would definitely help to see the error
13:29:34 <AlexIsEpic> jle`: https://dpaste.de/byu4
13:29:34 <jle`> that's the most important part :)
13:29:38 <AlexIsEpic> this is the error with [p]
13:29:46 <pikajude> :t hylo
13:29:47 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
13:29:55 <iqubic> How the heck does that work?
13:30:03 <jle`> AlexIsEpic: oh yes the error is that insertWith takes a map
13:30:03 <iqubic> How did you just get that type signature?
13:30:09 <jle`> but you're giving it a Level
13:30:14 <jared-w> > hylo (foldr (*) 1) (unfoldr (\x -> if x <= 10 then Just (x, x+1) else Nothing) 1)
13:30:16 <lambdabot>  error:
13:30:16 <lambdabot>      • Couldn't match expected type ‘a -> [a]’
13:30:16 <lambdabot>                    with actual type ‘[Integer]’
13:30:23 <AlexIsEpic> jle`: But Level is defined as a Map
13:30:26 <jle`> "Couldn't match expected type Map ... with actual type Level"
13:30:26 <jared-w> oh whoops
13:30:33 <jle`> AlexIsEpic: yes, but it is not a Map
13:30:36 <jared-w> > hylo (foldr (*) 1) (unfoldr (\x -> if x <= 10 then Just (x, x+1) else Nothing) 1) 1
13:30:38 <lambdabot>  error:
13:30:38 <lambdabot>      • Couldn't match expected type ‘Integer -> [Integer]’
13:30:38 <lambdabot>                    with actual type ‘[Integer]’
13:30:45 <jle`> AlexIsEpic: it's a different type
13:30:47 * jared-w flips desk
13:30:48 <jle`> AlexIsEpic: it's a type that contains a Map
13:31:00 <monochrom> nkaretnikov: That state creates fictional data dependency to ensure preservation of effect order so that if you have "getLine >> putStrLn bye" the compiler won't feel like re-ordering them (or even skipping getLine altogether).
13:31:01 <aarvar> nkaretnikov: it makes sure the compiler doesn't reorder things
13:31:04 <jle`> AlexIsEpic: are you familiar with algebraic data types?
13:31:07 <petrolifero[m]> :t cadr
13:31:08 <lambdabot> error: Variable not in scope: cadr
13:31:13 <jle`> data MyType = MyConstr Int | MyOtherConstr Bool
13:31:18 <jle`> that creates a type with two constructors
13:31:20 <iqubic> petrolifero[m]: what are you trying to do?
13:31:22 <jle`> one contains an Int, and the other contains a Bool
13:31:30 <jle`> AlexIsEpic: MyType is *not* an Int
13:31:39 <jle`> AlexIsEpic: it is a type that contains an Int if it was made with the MyConstr constructor
13:31:46 <jle`> you have the same situation there
13:31:48 <AlexIsEpic> jle`: Oh, ok. I understand this
13:32:01 <jle`> your Level type just contains a Map if made with the LevelData constructor
13:32:01 <EvanR> is there a way to fork(2) a haskell program
13:32:02 <jle`> but it is not a Map
13:32:04 <AlexIsEpic> But then how would I go about fixing it? I though that pattern matching to LevelData would fix it
13:32:17 <iqubic> EvanR: Try ForkIO?
13:32:18 <EvanR> forkProcess seems to be doing a lot else to prepare for the fork, i presume slowing things down
13:32:27 <jle`> AlexIsEpic: you can pattern match on LevelData to get the Map, yes
13:32:31 <jle`> AlexIsEpic: you do that, and call the map 'lvl'
13:32:38 <jle`> AlexIsEpic: but you don't give 'lvl' to insertWith
13:32:48 <jle`> lvl is the map
13:32:52 <jle`> but you gave it (LevelData lvl)
13:32:56 <jle`> which is a Level
13:33:15 <jle`> that would be like, if a function expects an Int, and you have an Int 'x', you gave the function ('h', x) instead
13:33:28 <merijn> EvanR: Of course forkProcess is doing lots of stuff, because forking a random Haskell process is so dangerously unsafe there's almost no way to do it and make it work
13:33:38 <EvanR> really
13:33:39 <AlexIsEpic> jle`: I see what you mean but I don't quite know what to do to
13:33:48 <AlexIsEpic> what to do*
13:33:49 <EvanR> why is it so different from forking a random C process?
13:33:54 <nkaretnikov> is there a way to see module hierarchy of hackage packages? like, can i see everything under Data.*?
13:34:01 <jle`> AlexIsEpic: say you want to add 'x' to 4
13:34:11 <jle`> AlexIsEpic: and you wrote MyConstructor x  + 4
13:34:14 <jle`> or ('h', x) + 4
13:34:18 <jle`> how can you fix that, to just add x to 4?
13:34:21 <merijn> EvanR: Forking random C process is also dangerously unsafe and almost impossible to do right
13:34:26 <EvanR> o_O
13:34:30 <jle`> * (MyConstructor x) + 4
13:34:40 <monochrom> No, hackage doesn't show you the hierarchy.
13:34:41 <merijn> EvanR: Well, let me rephrase
13:34:44 <jle`> how would you fix that, knowing that 'x' is already just an Int and can be directly added to 4?
13:34:59 <merijn> EvanR: Forking a C *multithreaded* C process is dangerously unsafe and almost impossible to do right
13:35:00 <AlexIsEpic> jle`: Remvoe the "MyConstructor" ?
13:35:07 <iqubic> How does one take "Data List a = Nil | Cons a List" and write it with Fix instead?
13:35:09 <monochrom> And the hierarchy is misleading to begin with.  Consider: Data.Machine and Control.Lens, not Control.Machine and Data.Lens.
13:35:09 <jle`> AlexIsEpic: can you type it out for me
13:35:38 <jle`> iqubic: do you mean data List a  = Nil | Const a (List a) ?
13:35:42 <AlexIsEpic> Well if I know that x is an Int, then I can do just (x + 4) right?
13:35:46 <jle`> AlexIsEpic: yes
13:35:47 <jle`> same thing here
13:35:49 <iqubic> jle`: Yes.
13:35:49 <merijn> EvanR: If you fork(2) a process while *ANY* thread holds *ANY* mutex (say, glibc holds a mutex for malloc) that mutex will never be released and your forked process will deadlock
13:35:58 <iqubic> How would you right that with Fix?
13:35:58 <jle`> AlexIsEpic: if you know lvl is a map, you can just do M.insertWith .. ... .. lvl
13:36:02 <monochrom> There has been talks of merging Data and Control into one single Abstraction.
13:36:09 <iqubic> *write
13:36:10 <jle`> iqubic: note the recursive call to List
13:36:13 <jle`> * (List a)
13:36:16 <merijn> EvanR: Since fork only forks the current thread and thus the thread holding the lock will never be able to release it in the child
13:36:19 <jle`> iqubic: and replace it with a parameter
13:36:23 <EvanR> merijn: and... is this the default situation for a ghc program. multiple threads
13:36:25 <jle`> ListF b a = Nil | Cons a b
13:36:30 <iqubic> sure.
13:36:36 <jle`> iqubic: instead of directly recursively calling, replace the recursive call with a type parameter
13:36:50 <merijn> EvanR: Even the unthreaded runtime uses multiple threads, yes, for safely dealing with FFI calls
13:37:06 <jle`> iqubic: so for example, data Tree = Leaf a | Branch [Tree a]
13:37:07 <EvanR> well fork me
13:37:17 <jle`> iqubic: the recursive call is the Tree a in Branch [Tree a]
13:37:29 <iqubic> I see we have a rose tree.
13:37:30 <jle`> iqubic: so make it a parameter: data TreeF b a = Leaf a | Branch [b]
13:37:43 <AlexIsEpic> jle`: https://dpaste.de/Yv2X this still gives me the same map error
13:37:44 <EvanR> i guess java has teh same issue with forking?
13:37:45 <jle`> iqubic: sometimes people like to give the type parameter a cute name
13:37:47 <iqubic> Cool. And then where does Fix come in?
13:37:56 <nkaretnikov> monochrom: that's why i've asked in fact. i'm thinking whether data is redundant, but i'm having trouble finding a suitable prefix. could you help me perhaps? i've been thinking to hijack GHC.Prim since my package is very ghc-specific and uses GHC.Prim heavily, but now i don't see it's a good idea. should i go with Data.Prim.* instead or something?
13:38:12 <jle`> iqubic: data List a = Nil | Const a (List a)   ==>  data ListF lista a = Nil | Cons a lista
13:38:26 <aarvar> nkaretnikov: go with IDontKnow.Prim
13:38:36 <iqubic> Sure. But I'm not seeing how to add Fix to that.
13:38:40 <jle`> data Tree a = Leaf a | Branch [Tree a] ==> data Tree treea a = Leaf a | Branch [treea]
13:38:55 <nkaretnikov> aarvar: while i appreciate the joke, it doesn't add much value to the discussion
13:39:01 <jle`> oh sorry, i wrote that wrong, the parameter should be the second argument
13:39:06 <jle`> data ListF a lista = Nil | Cons a lista
13:39:10 <masaeedu[m]> I just found out about curry's paradox from trying to follow all these fix gymnastics
13:39:10 <aarvar> nkaretnikov: I think it adds plenty of value. Names hardly matter
13:39:15 <jle`> and the original type is FixF (ListF a)
13:39:18 <aarvar> I was only half joking
13:39:29 <masaeedu[m]> it's like a fixpoint combinator for english
13:39:30 <Emblis> Anyone up for talking Monads with me? I have this big fluffy abstract idea of what a monad is but not what a monad "is" :)
13:39:33 <aarvar> what's the package name? you could just use that
13:39:33 <iqubic> How does Fix come into play?
13:39:36 <jle`> AlexIsEpic: what's the error?
13:39:43 <jle`> iqubic: oh sorr,y i menat Fix (ListF a)
13:39:49 <jle`> iqubic: Fix f = f (Fix f)
13:39:58 <EvanR> Emblis: sounds like the wrong way to go about talking about monads
13:40:01 <jle`> so what's going on is that it's basically providing itself as the "parameter"
13:40:10 <AlexIsEpic> jle`: https://dpaste.de/Ufsm
13:40:13 <ShalokShalom2> which posts do you recommend to see the benefits of maybe and either compared to try/catch?
13:40:24 <Emblis> EvanR how would you recommend going about it?
13:40:27 <jle`> iqubic: data ListF a lista = Nil | Cons a lista
13:40:43 <jle`> iqubic: so Fix (ListF a) = ListF a (Fix (ListF a))
13:40:48 <iqubic> Oh I see.
13:40:49 <jle`> it's basically plugging in 'itself' for lista
13:40:58 <iqubic> Yeah, that makes sense.
13:41:06 <jle`> AlexIsEpic: note that it's the opposite error now
13:41:15 <jle`> before, you gave a Level when it expected a Map
13:41:15 <EvanR> Emblis: avoid the subject entirely, out of caution
13:41:24 <monochrom> nkaretnikov: It seems precedences uses Data.Primitive e.g. http://hackage.haskell.org/package/primitive
13:41:24 <jle`> AlexIsEpic: now, you gave a Map when it expected a Level
13:41:25 <shapr> Emblis: might be easier to use a bunch of specific instances of the abstraction
13:41:26 <EvanR> lets talk about functors instead
13:41:31 <nkaretnikov> aarvar: the package name is too long. but it'll contain algorithms. i think i'll just go with algorithm/algorithm based what i see on hackage.
13:41:32 <aarvar> Emblis: function f : * -> * such that you can compose functions of the form a -> f b
13:41:32 <masaeedu[m]> "If this sentence is true, then Germany borders China". If the sentence is true, it's both the case that the sentence is true and that it implies germany borders china. Hence the sentence is true, and germany borders china
13:41:33 <shapr> oh, I like where EvanR is going
13:41:33 <nkaretnikov> monochrom: ^
13:41:41 <jle`> AlexIsEpic: it's saying that 'M.insertWith ....' is a Map
13:41:48 <jle`> AlexIsEpic: but the type signature expects to returna  Level, not a map
13:41:53 <masaeedu[m]> I wonder if there's a "programming" equivalent of the paradox
13:41:53 <laudecay> hello! why isn't Data.Sequence.deleteAt a thing that works? It says that that function doesn't exist in Data.Sequence
13:41:54 <shapr> yeah, easiest is monoid -> functor -> applicative -> monad
13:41:58 <laudecay> it's in the documentation though
13:42:03 <jle`> AlexIsEpic: so, how can you convert a Map into a Level?
13:42:12 <AlexIsEpic> jle`: addSquare c h p (LevelData lvl) = (LevelData (M.insertWith (++) p [Square c h] lvl))
13:42:13 <AlexIsEpic> Like so?
13:42:17 <jle`> does that work?
13:42:20 <AlexIsEpic> yes
13:42:21 <aarvar> shapr: why not category -> functor -> monad?
13:42:21 <laudecay> is there a way to delete the first instance of an ADT from a Seq of them?
13:42:22 <merijn> EvanR: Incidentally, this is why fork is deprecated in posix
13:42:23 <EvanR> monoids might be a tangent
13:42:25 <aarvar> or even category -> monad
13:42:29 <jle`> hooray :D
13:42:35 <EvanR> merijn: oh really? ...
13:42:36 <aarvar> maybe monoids before category though..
13:42:39 <monochrom> I agree with EvanR.  Functor first, if anything.
13:42:45 <aarvar> and maybe Ord before Monoid
13:42:46 <glguy> laudecay: You must use the documentation for version of the package you're using, each version is potentially different
13:42:56 <AlexIsEpic> Thank you so so much. Our prof sucks big time and this is proving to be pretty challenging
13:42:57 <laudecay> oh no there are /multiple/ Data.Sequence????
13:43:01 <EvanR> merijn: what is the new way to "fork exec" something
13:43:10 <jle`> for me i would just learn about types, until you understand those types well enough to use them regularly
13:43:13 <merijn> EvanR: The recommended way to start a new process is posix_spawn
13:43:14 <laudecay> glguy: https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Sequence.html is the docs i'm looking at
13:43:20 <jle`> and then when you learn about Monad, it's 'trivial'
13:43:33 <glguy> laudecay: OK, that's version 0.5.11.0. Which version are you trying to use locally?
13:43:34 <jle`> the thing about learning monad first is that you're also learning about different types too that are all foreign to you
13:43:39 <nkaretnikov> monochrom: based on roman's experience, i think i'll go with that. my package will also nicely fit into this hierarchy. thanks!
13:43:45 <jle`> but if those types are alreadyfamiliar to you, the fact that they are a monad is clear
13:43:48 <laudecay> glguy: how do i look at that? I'm using Stack on arch linux
13:43:52 <safindaskar> i consider creating my own programming language. what should i choose? separate SUM TYPE and PRODUCT TYPE like in ML (SML, OCAML) or SUM OF PRODUCTS TYPE like in Haskell? is there any good article comparing this methods? why haskell chose monolitic "SUM OF PRODUCTS" at the first place?
13:43:54 <Emblis> If I write asdf = do return "asdf" it is a monad due to the do notation. But what does it practically mean compared to simply asdf = "asdf"?
13:44:00 <Welkin> laudecay: oh god, stack *and* arch?
13:44:08 <glguy> laudecay: someone who uses stack can probably help you there
13:44:16 <jle`> Emblis: it's actually not a monad due to the do notation
13:44:21 <laudecay> glguy: GHCi, version 8.0.2: http://www.haskell.org/ghc/  :? for help, is that relevant?
13:44:24 <aarvar> safindaskar: could you use more caps?
13:44:29 <laudecay> Welkin: surprisingly the most easy to maintain
13:44:30 <jle`> Emblis: the monad comes from the fact that you use the 'return' function
13:44:32 <aarvar> the regular text is too small for me to read
13:44:36 <jle`> return :: Monad m => a -> m a
13:44:47 <Emblis> I see, my misstake
13:44:52 <jle`> do notation is just sugar
13:45:02 <jle`> you are right that 'asdf = do "asdf"' is the same as 'asdf = "asdf"'
13:45:02 <Zipheir> asdf = "asdf" is just :: String
13:45:04 <glguy> laudecay: You're likely using 0.5.7.1
13:45:17 <laudecay> glguy: so this is a version that doesn't have it then. how would i update?
13:45:25 <jle`> Emblis: 'return' is implemented differently for every instance of Monad, so this is the same as, say
13:45:28 <jle`> asdf = Just "asdf"
13:45:29 <masaeedu[m]> I'd avoid do notation for a while
13:45:31 <jle`> or asdf = Return "asdf"
13:45:31 <masaeedu[m]> it only confused me when I was starting out
13:45:37 <jle`> er, asdf = Right "asdf"
13:45:41 <jle`> or asdf = ["asdf"]
13:45:45 <jle`> depending on which instance you are talking about
13:46:03 <masaeedu[m]> working with simple functions is tedious but it keeps things clear
13:46:08 <jle`> for lists, return x is different from x because return for lists is the singleton list function
13:46:18 <iqubic> So cata and ana and such only work if you have a recursive data struture, right?
13:46:23 <jle`> for lists, `return x` is `[x]`
13:46:29 <jle`> iqubic: not necessarily
13:46:34 <EvanR> jle`: caution, people can get confused about the difference between x and [x]
13:46:34 <iqubic> What if you just want straight up loops, like do this 5 times?
13:46:37 <jle`> they're just only interesting if you have a recursive data structure
13:46:39 <jle`> EvanR: good point!
13:46:43 <woodson> anyone familiar with nix and cabal?
13:46:49 <jle`> iqubic: check out 'Const'
13:46:56 <EvanR> not to mention x and (x), lisp again
13:46:57 <Emblis> But if I instead do asdf f = "asdf" ?
13:46:58 <merijn> woodson: You mean both or either/or? :p
13:47:09 <merijn> woodson: Also, do you mean Cabal or cabal-install? :p
13:47:23 <woodson> merijn, exactly
13:47:37 <maerwald> haha
13:48:11 <woodson> I tried install miso but I noticed that when i run ghcjs-pkg list I have a different miso version than the one in my nix-env
13:48:29 <woodson> anyone knows how I can fix this?
13:48:36 <jared-w> "don't worry guis, ghcjs is pretty easy to use, trust me, it's just typing commands n shit"
13:49:29 <EvanR> ghcjs doesnt have a siri interface yet?
13:49:29 <laudecay> gdi i have completely fucked my haskell install
13:49:46 <woodson> ??
13:50:25 <Welkin> laudecay: use a non-arch linux distro, and use cabal new-* or cabal + nix
13:50:53 <Emblis>  /msg Welkin how goes the book?
13:51:16 <Emblis> Sometimes I hate IRC :D
13:51:45 <chorizo>  /msg Emblis me too
13:52:11 <EvanR> /msg look no space
13:52:20 <chorizo> \o/
13:52:49 <Emblis> :)
13:53:30 <safindaskar> please answer me!
13:54:19 <chorizo> safindaskar, I think you should create a fusion of prolog and brainfuck
13:54:24 <chorizo> that would be a productive language
13:55:04 <Welkin> profuck?
13:55:10 <chorizo> we have a winner
13:56:15 <safindaskar> fuck like a pro...
13:56:16 <monochrom> or brainlog
13:56:52 <safindaskar> so, sum of products or separate sum and products?!
13:58:02 <safindaskar> /look
13:59:08 <iqubic> How would profuck work?
13:59:19 <safindaskar> maybe there is some channel for deep discussions about type systems? (not about caps or brainfuck)
13:59:20 <monochrom> Consider: What if you wrote this Haskell code? "data Whee = W (Int, Bool)"
13:59:36 <Welkin> safindaskar: #typetheory ?
13:59:39 <iqubic> Alright. Makes sense.
13:59:43 <Welkin> I now there is #categorytheory
13:59:48 <Welkin> know*
14:01:18 <merijn> Welkin: Generally type theory is considered on-topic here if it's not interrupting anything more directly haskell-y
14:01:31 <jared-w> There's also #proglangdesign but there's quite a few people on there more interested in OOP and other types of stuff than our "purer" interests :p
14:01:37 <merijn> safindaskar: I assume you've got a copy of TaPL already?
14:01:48 <merijn> safindaskar: If not, that'd be a good starting point
14:02:55 <EvanR> you can get a pirate of it easily
14:03:31 <iqubic> What is TaPL?
14:03:39 <merijn> @where tapl
14:03:39 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
14:03:59 <merijn> iqubic: Types and Programming Languages, the de facto standard book on learning type theory and how to implement type checkers
14:08:37 <jared-w> really need to start reading that at some point...
14:08:46 <jared-w> I have it on my e-shelf along with like 500 other things
14:09:42 <Welkin> e-shelf?
14:09:43 <Welkin> lol
14:09:48 <Welkin> is this the 1990's?
14:10:29 <merijn> jared-w: What I like about it is that you can go as far as you like, the first dozen or so chapters are fairly straightforward and simple (well, if you're comfortable with Haskell they should be), after that you can just read until however complex you wanna make things
14:10:43 <jared-w> nice, good to know :)
14:11:51 <EvanR> if youre comfortable with haskell, youll wonder why half the stuff in that book is not in haskell
14:12:13 <Welkin> knowing haskell isn't enough
14:12:22 <Welkin> you need to understand logic syntax
14:12:34 <Welkin> which caused me to stop at chapter 2
14:12:37 <EvanR> you need to understand 1337
14:12:52 <jared-w> I'm a huge TCS nerd tho so I'll be fine lol
14:13:29 <Welkin> oh yeah, and the book uses ML for examples, right?
14:13:32 <Welkin> SML*
14:14:23 <EvanR> waiting for an elixir-style surge in ML interest among web shops
14:14:33 <EvanR> ML with ruby syntax
14:14:56 <jared-w> ughhhh
14:15:18 <jared-w> it's funny cause my coworker regularly cites haskell's syntax as one of the bigger dealbreakers for him
14:15:28 <Welkin> lol
14:15:30 <EvanR> ok, haskell with ruby syntax
14:15:35 <jared-w> another reason he tends to talk about erlang if he's going to talk about a FP language
14:15:35 <Welkin> haskell has the best syntax of any language o.o
14:15:42 <Welkin> everything else looks ugly by comparison
14:16:03 <Welkin> well, lisp is fine too
14:16:04 <jared-w> idk
14:16:14 <jared-w> I tend to think Agda looks a little prettier than Haskell
14:16:19 <EvanR> of course if you wait 6.3 more years, it will be standard to want to have everything in some random other syntax. just like js was only accepted because of its C syntax
14:16:35 <jared-w> (: vs :: and the glorious usage of Unicode)
14:16:39 <jared-w> and misfix operators are kinda cool :p
14:16:57 <EvanR> agda is great for exposing the absurd arbitrariness of what unicode encoded
14:17:02 <merijn> I think you mean mixfix, but misfix is a nice typo
14:17:03 <safindaskar> merijn: thanks, i just checked TaPL. it talks about sums and products separately. it says nothing about "sum of product"
14:17:10 <merijn> EvanR: Oh god
14:17:18 <chorizo> I just typed in agda language
14:17:22 <chorizo> what is that monstrosity
14:17:23 <merijn> EvanR: I'm having flashbacks to summer school introduction to Agda
14:17:30 <jared-w> agda is beautiful ಠ_ಠ
14:17:40 <EvanR> half of the alphabet in subscripts
14:17:46 <EvanR> not the other half
14:17:53 <chorizo> jared-w, this is what I saw https://i.ytimg.com/vi/Sbfcq3yOx0I/maxresdefault.jpg
14:17:59 <merijn> EvanR: Fucking Ulf Norell writing out an example for us in emacs, we copying him and getting confused our code doesn't work
14:18:01 <jared-w> lol
14:18:21 <jared-w> that's the ugliest agda I've ever seen in my life
14:18:32 <merijn> EvanR: "oh, yeah, I forgot to tell you that's not an ascii pipe, it's a unicode pipe..." '...you fooking wut?'
14:18:52 <jared-w> does agda do unicode normalization?
14:19:26 <EvanR> i like shapecatcher.com where you draw a stroke and get 100 unicode characters that all look the same
14:19:32 <monochrom> Beautiful math there :)
14:19:36 <safindaskar> monochrom: "data Whee = W (Int, Bool)" - well, yes, i can write this. so what? yes, this is possible to emulate sum types using sum of product types (SoP). and it possible to emulate SoP using sum types. so, of course ML way and Haskell way both will go. but still what is more beautiful?
14:19:37 <fishythefish> safindaskar: if you have sums and you have products, you get sums of products for free
14:19:43 <jared-w> https://www.fsd.it/wp-content/uploads/2015/12/PragmataPro_darin-morrison-agda.png this is more representitive of what Agda actually looks like
14:20:10 <monochrom> safindaskar: Have you considered the fact that "W undefined" is a possible value in Haskell but not in SML?
14:20:44 <EvanR> merijn: try drawing an incredibly straight vertical stroke on there
14:20:58 <jared-w> chorizo: or this :p https://github.com/HoTT/HoTT-Agda/blob/master/old/Univalence.agda
14:21:47 <chorizo> jared-w, I kinda like that I guess
14:22:03 <jared-w> see? Pretty! Plus you get to do crazy shit like define a heart emoji operator
14:22:05 <chorizo> jared-w, but at that point why not just write a parser for LaTeX
14:22:14 <Tuplanolla> That'll change once you try using it, chorizo.
14:22:16 <chorizo> then we can code in god tier equasions
14:22:41 <chorizo> Tuplanolla, hey who knows, maybe I'll confirm my thesis with it :^)
14:22:51 <chorizo> and then promptly find a bridge
14:22:56 <jared-w> Well most agda IDEs already allow you writing out a lot of unicode symbols using latex names
14:23:20 <laudecay> oh god this is hell
14:23:25 <laudecay> does anyone arch + haskell
14:23:35 <jared-w> yeh
14:23:36 <laudecay> i'm asking also in #archlinux but idk may as well try here too
14:23:38 <chorizo> laudecay, I mean, I'm on manjaro which is similar
14:23:43 <Welkin> laudecay: no, and for good reason
14:23:46 <laudecay> chorizo: jared-w stack: error while loading shared libraries: libHSCabal-2.0.1.0-ghc8.2.2.so: cannot open shared object file: No such file or directory
14:23:54 <Welkin> laudecay: arch gave a fat middle finger to ghc
14:23:55 <laudecay> i'll happily swap off of stack i just want things to work
14:24:00 <laudecay> Welkin: really? :(
14:24:01 <safindaskar> monochrom: "Have you considered the fact that "W undefined"" - no, but this is not important for me
14:24:06 <jared-w> standard recommendation is: 1) delete everything haskell. 2) fuck the normal repos. 3) thou shalt use stack and stack only. 4) never ever use `stack install` for anything
14:24:21 <laudecay> jared-w: how do i get "everything" because i tried that
14:24:22 <Welkin> jared-w: you mean, use nix + cabal, or cabal new-*
14:24:23 <Welkin> not stack
14:24:37 <jared-w> On Arch, no. Nix doesn't even work on arch correctly :p
14:24:47 <chorizo> huh, manjaro actually have their own packages that are a bit less cutting edge than arch, I wonder if that's why it works fine for me
14:24:47 <dsal> jared-w: why no stack install?
14:24:50 <dsal> I think I did that for a thing.
14:24:50 <merijn> jared-w: cabal + ghc bindist should work fine, though
14:25:03 <Welkin> lol jared-w
14:25:07 <Welkin> just dump arch
14:25:09 <laudecay> r u d e i feel called out
14:25:11 <jared-w> stack install is actually "stack build and then copy this random shit into my ~/.stack path" which you never want to do
14:25:15 <merijn> jared-w: Because that's worked fine on literally every *nix from BSD, macOS to whatever ridiculous old linux for me so far
14:25:23 <laudecay> ive been on arch since the 11th grade i cant leave now
14:25:33 <dsal> jared-w: I *feel* like I want that.  :)
14:25:34 <laudecay> also classes, i have no time for a reinstall on janky hardware right now
14:25:41 <chorizo> laudecay, who knows, maybe you're only in 12th grade now
14:25:43 <Welkin> laudecay: I am happily running openSUSE Tumbleweed (rolling distro)
14:25:51 <Welkin> everything works
14:26:03 <chorizo> tumbleweed... rolling distro... I like it
14:26:08 <jared-w> dsal: You don't :p  if you want a binayr available globally, make that binary available globally. If you want your libraries, stack takes care of the path for you with normal `stack build`
14:26:18 <jared-w> If you want compiler tools, there's `stack build --copy-compiler-tools`
14:26:20 <merijn> laudecay: My recommended install approach on *nix is to just download a GHC bindist, build cabal-install yourself and use that. Alternatively, install GHC via stack
14:26:22 <jared-w> stack install just fucks you up :p
14:27:39 <laudecay> oh heck
14:28:18 <jared-w> and if you have pandoc or xmonad or anything like that installed from the AUR or normal repos, that's what is causing all of your pain
14:28:20 <Welkin> merijn: installing ghc with stack means you are stuck using stack
14:28:22 <jared-w> (or shell shock)
14:28:50 <jared-w> Welkin: nah you can just use the ghc binary out of a stack path once you have it installed, why not?
14:29:03 <dsal> I run xmonad from OS packages.  It... mostly works.
14:29:39 <jared-w> Everything X is dark territory on osx so :p
14:29:44 <laudecay> chorizo: sophomore in college but idk
14:29:51 <laudecay> merijn: stack isn't working though
14:30:01 <laudecay> and yeah i got rid of pandoc that was being sad
14:30:01 <dsal> On my work Linux box, that is.  On OS X, I just suffer the OS X interface.
14:30:10 <laudecay> merijn: stack's getting this library error
14:30:58 <jared-w> laudecay: you can just use pandoc-bin from the AUR
14:31:35 <jared-w> laudecay: I'm suspecting that if you got rid of pandoc, you didn't fully purge all of the haskell packages from your computer which would be why stack is getting the library error
14:31:44 <laudecay> jared-w: how do i purge them?
14:31:45 <zincy> Is there a version of show which doesn't escape special chars in JSON?
14:31:48 <jared-w> Either that or you screwed up your config files for the project somewhere somehow
14:31:57 <laudecay> there were none, it's def the libraries
14:31:58 <merijn> Welkin: Well yes, but there's no point in attempting to start tooling flamewars and thus I try and avoid that. I wish you would too
14:32:09 <dsal> zincy: show does what the Show instance says to do.
14:32:22 <laudecay> im like this close to writing my own deleteAt for seq lmao
14:33:22 <Welkin> laudecay: what are you using Sequence for?
14:33:23 <chessandgo> Im converting my simple one file haskell project to using stack, and I was wondering exactly how depencies work when specified in package.yaml
14:33:27 <laudecay> Welkin: a fast queue
14:33:34 <chessandgo> if I have import Database.HDBC
14:33:36 <Welkin> laudecay: just use two lists
14:33:49 <Welkin> it has amortized constant run time
14:33:55 <laudecay> Welkin: i really don't want all that overhead, plus some of the specialized features in seq are really really good for my needs
14:33:59 <Welkin> sequence is not the best queue
14:34:03 <chessandgo> and import Database.HDBC.Sqlite3, do I specify both of them respectively in the yaml, or do I only have to list HDBC as a depency
14:34:24 <Welkin> laudecay: there is no overhead
14:34:31 <laudecay> Welkin: i mean the overhead of writing code
14:34:37 <Welkin> if you need a priority queue, there are already implementations of those
14:34:41 <jared-w> laudecay: you'll want to do something like `sudo pacman -Rns haskell-*` and make sure you don't have cabal or ghc installed (sudo -Rns that as well)
14:34:45 <Welkin> laudecay: it is literally one line of code
14:34:51 <jared-w> Then stack should work fine
14:34:52 <Welkin> and the interface is a few more
14:34:58 <jared-w> (as long as you use a static binary of stack)
14:35:01 <laudecay> it's not that either, i need to be able to partition it, get the first instance of something defined by a boolean function, like
14:35:15 <Welkin> data Queue a = Queue [a] [a]
14:35:18 <laudecay> there's just a lot of fun stuff that comes with Seq that i don't get natively from two lists
14:35:27 <Welkin> Seq is a very fun container (one of my favorite)
14:35:34 <Welkin> but you can easily make your own performant Queue
14:39:45 <chorizo> is there a simple reason why let port = getLine >>= show wouldn't work?
14:40:34 <laudecay> ok so everything is uninstalled
14:41:07 <monochrom> @type getLine >>= show
14:41:08 <laudecay> Welkin: i just need many of the features of Seq that already exist and really don't want to spend the time playing with the whole "two lists" bit
14:41:08 <lambdabot> error:
14:41:08 <lambdabot>     • Couldn't match type ‘[]’ with ‘IO’
14:41:08 <lambdabot>       Expected type: String -> IO Char
14:41:20 <laudecay> jared-w: so there are no haskell packages on my system
14:41:25 <monochrom> Type error is the reason why. Dare I say utter disrepect of types.
14:41:34 <laudecay> or cabal
14:41:50 <laudecay> and yet still that stack/missing Cabal error
14:42:18 <laudecay> brb computer about to die, i might disappear for 20 minutes sorry
14:42:26 <jared-w> so you have a haskell project with a stack config setup and 'stack build' fails?
14:43:49 <sm> don't be disrespectin' the types!
14:44:15 <monochrom> Data.Sequence comes with GHC, nothing to install, no dependency chasing to worry about. No?
14:44:40 <monochrom> But of course God knows how Stack works in mysterious ways to test your faith.
14:45:04 <jared-w> (yes but if `stack build` doesn't work right it probably means the stack/cabal config files are setup wrong)
14:45:31 <chorizo> monochrom, yeah slight lapse in brain power there, I was trying to do port <- getLine then read port :: Int
14:45:41 <chorizo> but pointfree, didn't work as intended
14:45:54 <merijn> chorizo: FYI, you probably wanna replace read with readMaybe from Text.Read
14:45:56 <monochrom> Do not attempt pointfree prematurely.
14:46:08 <jared-w> And when in doubt, feel free to ask the robot to do it for you :p
14:46:17 <chorizo> merijn, yeah, I'm just testing stuff out for now
14:46:38 <chorizo> first try at an actual project, I can already feel the wall
14:47:50 <sm> [ Abandon Hope All Ye Who Enter Here ]
14:48:10 <cheater> hi
14:49:09 <freeman42x]NixOS> got a question about X11 wrapper: https://stackoverflow.com/q/49887999/750216
14:51:56 <GobiGobi> What is going on in this record syntax? https://pastebin.com/knKHWdaw
14:52:25 <glguy> GobiGobi: Which part do you not understand?
14:53:18 <GobiGobi> Transacton is a datatype not a constructor
14:53:58 <jared-w> newtype Foo = Foo String  -- this works
14:53:59 <glguy> GobiGobi: You might have misunderstood what a constructor is,
14:54:04 <fishythefish> GobiGobi: yes, and that's a type signature
14:54:08 <glguy> constructors are the capitalized names
14:54:17 <jared-w> newtype Foo = Foo { unFoo :: String } -- Same thing but in record syntax
14:54:57 <chorizo> jared-w, except you can call unFoo Foo to get the string right?
14:55:01 <GobiGobi> What's happening in this record syntax? https://pastebin.com/knKHWdaw
14:55:11 <GobiGobi> Transaction is a datatype not a constructor
14:55:14 <fishythefish> GobiGobi: check the logs, you got a couple answers while you were gone
14:55:20 <GobiGobi> oh ok
14:55:39 <jared-w> chorizo: you can pattern match on the Foo to get the String in either one, unFoo is just a partial function that's defined as `unFoo (Foo x) = x`
14:55:40 <glguy> GobiGobi: Transaction is in fact a constructor. You can tell because it's capitalized. the stuff after :: is a type
14:56:02 <chorizo> jared-w, yeah thats right
14:56:07 <jared-w> record syntax is just an ugly hack to make convenience functions for you easily :)
14:56:22 <GobiGobi> cheers
14:57:54 <fishythefish> uh to be clear
14:58:03 <fishythefish> Transaction is a type constructor, not a value constructor
15:01:36 <GobiGobi> still a bit confused
15:01:37 <GobiGobi> https://pastebin.com/ZUHjZ004
15:02:44 <chessandgo> why does stack do this to me
15:02:45 <chessandgo>     HDBC-sqlite3 must match >=2.3.3.1, but the stack configuration has no specified version
15:02:48 <chessandgo>                  (latest matching version is 2.3.3.1)
15:02:53 <chorizo> GobiGobi, data Ledger h a = Ledger (NewestFirst [] (Transaction h a))
15:02:59 <chorizo> if I'm wrong someone please correct me lol
15:03:13 <chessandgo> is that not what stack wants?
15:03:49 <Welkin> chessandgo: end the stack confusion and just use cabal
15:03:50 <glguy> chessandgo: stack makes selecting package versions your job. Every package you're using needs to be handpicked via the resolver or extra-deps list
15:04:03 <Welkin> use cabal new-build and you don't have to do anything
15:04:06 <Welkin> it should just work
15:04:35 <fishythefish> GobiGobi: it'll be helpful to have the definition of NewestFirst, but the important thing to know is that NewestFirst and [] mean different things on line 3 than they do on line 6
15:05:17 <GobiGobi> that's the issue NewestFirst isn't defined in that module
15:05:29 <GobiGobi> which is prob my source of confusion
15:05:40 <fishythefish> GobiGobi: where does it come from?
15:05:59 <Welkin> chessandgo: also, I keep reading your name is "cheese and go"
15:06:40 <sm> chessandgo: it's saying, "there's not a new-enough HDBC-sqlite in the stackage resolver you've asked me to use. There is one on hackage though."
15:06:44 <chessandgo> Welkin: am I doin this the right way or the wrong way: I have a single file any everything works when I run ghc on it. I thought switching to a build system was the "right thing"
15:06:55 <sm> it probably also suggested to enable that by adding it to your stack.yaml
15:07:18 <Welkin> chessandgo: cabal is the only build system for haskell
15:07:24 <sm> Welkin: please stop
15:07:38 <Welkin> chessandgo: stack is a wrapper around cabal that is very opinionated
15:07:54 <GobiGobi> fishythefish: I'm not sure
15:07:57 <GobiGobi> https://github.com/input-output-hk/cardano-sl/blob/develop/wallet-new/test/unit/UTxO/DSL.hs
15:08:10 <laudecay> ok jared-w sorry i am back! uh yeah i dont have a stack config idk how to make that work
15:08:35 <jared-w> what does your project directory look like?
15:08:39 <chessandgo> but my package.yaml says has "    HDBC-sqlite3 must match >=2.3.3.1, but the stack configuration has no specified version
15:08:42 <chessandgo>                  (latest matching version is 2.3.3.1)
15:08:45 <chessandgo> thanks copy paste
15:08:47 <laudecay> it's just two .hs files, one imports the other
15:08:53 <chessandgo> it has "- HDBC-sqlite3 >= 2.3.3.1
15:09:04 <chessandgo> in it, so im not sure what its complaining about
15:09:07 <Welkin> you'll have to learn how cabal config works https://www.haskell.org/cabal/users-guide/
15:09:21 <laudecay> Welkin: me? or chessandgo
15:09:22 <jared-w> so you don't have a package.yaml anywhere?
15:09:25 <Welkin> both
15:09:25 <laudecay> jared-w: nope
15:09:33 <laudecay> i was just using like the systemwide stack thing
15:09:33 <jared-w> that would be why stack doesn't work for you :)
15:09:35 <laudecay> oh
15:09:38 <fishythefish> GobiGobi: https://github.com/input-output-hk/cardano-sl/blob/8d25c2ad3ca2354af8f8c43a2972d1b9a31bf440/core/Pos/Util/Chrono.hs
15:09:39 <Welkin> like I said, stack is a wrapper around cabal, so regardless, you need to understand how cabal works
15:09:41 <laudecay> hmmmm how do i set that up
15:09:44 <Welkin> stack just adds a lot of noise
15:09:50 <laudecay> Welkin: : (
15:09:51 <jared-w> `stack new myprojectname`
15:09:56 <laudecay> i just want my code to worrrrrkkkk
15:09:58 <laudecay> okay dope
15:09:59 <GobiGobi> fishythefish: how did you find that so fast?
15:10:04 <sm> chessandgo: the quick fix, if you're using stack globally, is to add that package to your install command line
15:10:10 <fishythefish> GobiGobi: github searched the repo for NewestFirst
15:10:21 <laudecay> jared-w: claude@elgar paxos $ stack new paxos
15:10:22 <laudecay> stack: error while loading shared libraries: libHSCabal-2.0.1.0-ghc8.2.2.so: cannot open shared object file: No such file or directory
15:10:30 <laudecay> i am doin a big heck :(
15:11:00 <GobiGobi> fishythefish: Cheers
15:11:16 <jared-w> No idea how you managed to do that tbh, but I can guarantee you would've messed up cabal even worse :)
15:11:21 <chessandgo> sm: im not sure exactly what you mean by that. Install it locally with cabal, or use my packagemanager to install it?
15:11:26 <laudecay> jared-w: aaaaaaaaaaaaaaaaaaaaa
15:11:37 <laudecay> any tips to unfuck my shit
15:11:46 <sm> chessandgo: I'd like to help but it's pretty noisy in here. Chat me if you like
15:11:55 <chorizo> laudecay, rm -rf
15:12:03 <laudecay> chorizo: sudo rm -rf /* ?
15:12:04 <jared-w> I'd just try uninstall stack completely, rm -rf ~/.stack, and then download a static stack binary, put it in /usr/local/bin, and then in your home directory run `stack new myNewProject`
15:12:08 <Welkin> laudecay: https://wiki.archlinux.org/index.php/Haskell#Problems_with_linking
15:12:10 <chorizo> laudecay, thank you
15:12:17 <sclv> oh no, its arch?
15:12:21 <sclv> yeah, arch is awful
15:12:22 <Welkin> yes
15:12:24 <jared-w> sclv: unfortunately :p
15:12:41 <laudecay> wait Welkin what do i do with that
15:12:54 <sm> arch linux, #haskell's kryptonite! :)
15:12:57 <Welkin> laudecay: deal with arch being dumb, or switch to a different distro
15:12:58 <sclv> laudecay: unfortunately you have to read it to understand what's going on
15:13:07 <sclv> it explains that arch does very bad things with haskell packaging
15:13:12 <sclv> and gives a number of ways to survive it
15:13:33 * chessandgo is trying to figure out how to PM someone with irssi
15:13:36 <jared-w> Arch is great with Haskell idk what y'all bitch about. Just don't use any of the package managers and use either cabal new-build or stack and don't have any haskell in your global path ¯\_(ツ)_/¯
15:13:39 <Welkin> chessandgo: /msg
15:13:43 <laudecay> still same problem jared-w
15:13:52 <jared-w> chessandgo: /query person hi this is the message
15:13:56 <laudecay> maybe i'll try installing cabal?
15:13:58 <sclv> jared-w: right. if you don't use any arch installed elements of haskell you can just use your own binary
15:14:21 <Welkin> I though even if you use your own bindist is a still a problem
15:14:27 <jared-w> sclv: which is, honestly, what I'd recommend for basically any distro with Haskell anyway... Like, why would you use the distro packages for haskell?
15:14:27 <sclv> i guess jared-w has the most hands-on experience with the arch haskell situation of anyone, so maybe you could sort it out with him in pm
15:14:47 <sclv> jared-w: yeah, generally i agree. but i do feel like installing ghc and cabal via the distro is usually safe
15:14:47 <Welkin> jared-w: bootstrapping
15:14:50 <sclv> arch makes even that screwy
15:14:59 <Welkin> I installed the distro packages for my system to compile ghc myself
15:15:06 <jared-w> yeah, that's unfortunate
15:15:31 <jared-w> Arch really shouldn't just blatently disregard official advice for certain packages. Like, they still follow advice for LaTeX and they do that completely differently than everyone else
15:15:53 <sclv> yeah its wild to me that so many people have trouble with their distribution practices for haskell
15:15:53 <jared-w> I swear that most of this comes from the maintainers having a giant hate boner for haskell
15:15:56 <sclv> and they just don't listen
15:16:20 <sclv> it used to be the premier distro for haskell dev like 15 years ago too
15:16:22 <jared-w> "haskell is fine, it's just a whole program optimizer so statically link everything, k?"
15:16:27 <hvr> jared-w: if that's the case, why waste time packaging haskell at all? ;)
15:16:37 <sm> I do notice they are the only distro with an up to date version of hledger
15:16:38 <jared-w> hvr: ¯\_(ツ)_/¯
15:16:50 <sm> maybe if we had an arch haskell maintainer in here, they could explain it
15:16:52 <sclv> sm: not even nix? :-)
15:17:01 <sm> well, gnu/linux distro
15:18:03 <jared-w> sm: I think they've explained it pretty clearly on forums and other stuff before
15:18:09 <GobiGobi> fishythefish: I'm still confused with the NewestFirst Type
15:18:33 <jared-w> iirc "every sane language supports dynamic linking. It's clearly superior. If your language doesn't it's dumb and we're fine with breaking it if it means you get your shit together" was the tl;dr I took from it
15:18:34 <sm> explaining to the internet isn't the same as explaining in here
15:18:51 <fishythefish> GobiGobi: let's simplify it to `newtype NewestFirst f a = NewestFirst (f a)`
15:19:09 <GobiGobi> fishythefish: does the f a correspond to [] (Transaction h a)
15:19:25 <fishythefish> GobiGobi: yes, f corresponds to [] and a corresponds to Transaction h a
15:19:56 <GobiGobi> so how is it possible to have NewestFirst []
15:20:00 <fishythefish> so a `NewestFirst [] (Transaction h a)` is just a wrapped `[Transaction h a]`
15:20:23 <GobiGobi> Ohhhhh
15:20:35 <fishythefish> if that list is empty, then the value is `NewestFirst []`
15:21:32 <GobiGobi> why is it not written like NewestFirst [Transaction h a]
15:21:51 <fishythefish> GobiGobi: because it's not always a list - that's what the f parameter is for
15:22:23 <GobiGobi> oh so f represents a functor?
15:22:34 <glguy> f is a type variable, doesn't have to be a Functor instance
15:22:53 <glguy> The type   [Int].  can be written as  [] Int
15:23:05 <fishythefish> the newtype itself doesn't require f to be a functor, but certain uses of it might
15:23:12 <glguy> [] is a type with kind * -> *, and Int is a type with kind *, so it's OK to apply [] to Int
15:23:39 <GobiGobi> glguy: but only on the type level correct?
15:23:47 <chorizo> :t []
15:23:48 <lambdabot> [a]
15:24:00 <fishythefish> in the type `NewestFirst [] (Transaction h a)`, we're not supplying `[] (Transaction h a)` (i.e. `[Transaction h a]`) to `NewestFirst`, we're supplying `[]` and `Transaction h a` as the two arguments to `NewestFirst`
15:24:06 <glguy> On the value level [] is something else, right. The two namespaces of types and values are separate
15:24:33 <chorizo> ah. that's cool.
15:24:47 <chorizo> is there a way to look it up?
15:24:49 <chorizo> @type []
15:24:50 <lambdabot> [a]
15:24:57 <fishythefish> :k []
15:24:58 <lambdabot> * -> *
15:27:52 <aarvar> jared-w: "if your language needs whole program optimization to be fast then clearly it sucks"
15:28:00 <laudecay> OH MY GOD I FIGURED IT OUT
15:28:18 <laudecay> there were like 180 haskell packages installed with yaourt.
15:28:26 <laudecay> and that's where the bork was coming from.
15:28:29 <laudecay> everything works now.
15:30:21 <fishythefish> ew, yaourt
15:31:29 <laudecay> oookay jared-w so i ran stack new, now what?
15:31:47 * jared-w knew it was the fucking haskell packages
15:31:54 <jared-w> Also use aura instead of yaourt ;)
15:32:08 <jared-w> Anyway, laudecay, you're going to want to cd inside the new directory and run `stack build`
15:32:24 <jared-w> you should see some output "someFunc" or what not, that means your haskell program compiled and ran correctly
15:35:24 <GobiGobi> fishythefish: if you ae supplying `[]` and `Transaction h a` as the two arguments to `NewestFirst` why does [] work at the value level
15:35:50 <GobiGobi> because [] :: [a] ?
15:35:55 <fishythefish> GobiGobi: the type and value namespaces are separate
15:36:10 <GobiGobi> or rather [] :: [] a ?
15:36:11 <fishythefish> at the type level, [] :: * -> * is a type constructor
15:36:16 <fishythefish> at the value level, [] :: [a]
15:36:33 <GobiGobi> fishythefish: that makes more sens enow
15:41:57 <laudecay> jared-w: it's complaining about dependencies?
15:42:12 <jared-w> with just a stack build and you didn't change any files?
15:42:52 <laudecay> https://hastebin.com/iqequbiluz.sql
15:43:00 <laudecay> oh no i put my code in
15:43:16 <jared-w> Well that's going to break a few things :)
15:43:25 <jared-w> open up your package.yaml file that stack made for you
15:43:25 <laudecay> like i replaced Lib in src/ with my library, and i replaced Main in app/ with my main file
15:43:39 <laudecay> yeah i'm looking at that, i'm not sure how to add this stuff
15:43:45 <laudecay> wait why am i importing the state monad wtf
15:44:19 <jared-w> go down to line ~20 or so where "dependencies" are. Put all the packages you need to import in there
15:44:20 <laudecay> ok whatever yeah how do I add Data.Sequence?
15:44:32 <laudecay> literally just Data.Sequence under where it says base? or
15:44:34 <jared-w> it's in the containers package, so put containers in the dependencies list
15:45:07 <jared-w> then you're going to want lens in the dependencies as well if you're using that
15:45:09 <laudecay> oh huh okay
15:45:20 <jared-w> and the mtl package
15:45:57 <jared-w> (for the state monad)
15:46:19 <GobiGobi> fishythefish: thanks a lot, saved me headache
15:46:30 <fishythefish> no problem
15:47:33 <jared-w> then `stack build` to get everything built and ready and your project will be built and ran
15:48:17 <helichopter> does anyone know how I can use non-concrete type applications? I have a function, [ expandNode :: forall t . Node t -> t ] is there a way for me to use @t in my function definition?
15:48:40 <laudecay> YAAAASSSSSSS I HAVE THE OLD ERRORS FROM GHC
15:48:44 <laudecay> bless u jared-w
15:48:47 <laudecay> you are great
15:48:52 <jared-w> ya welk
15:49:09 <jared-w> remember kiddos, haskell packages on arch are cancer. Use stack or cabal new-package /dropmic
15:50:17 <laudecay> yay back to debugging
15:50:20 <laudecay> this is good :3
15:50:27 <laudecay> back to types i am so happy now
15:51:17 <jared-w> try out `stack build --file-watch` as well
15:51:25 <chorizo> is there ever not a reason to run and develop off of ghci for small projects? I have it built but stack ghci is so easy
15:51:27 <jared-w> it'll automatically build stack every time you make a change and save a file
15:51:53 <jared-w> nah, ghci all the things. GHCi being awesome is one of the main reasons our IDE tooling sucks so much
15:52:00 <EvanR> lol
15:52:05 <chorizo> figured as much
15:52:12 <EvanR> ghci is incredibly good enough?
15:52:16 <chorizo> ghci is pretty amazing
15:52:25 <EvanR> it doesnt even have color
15:52:34 <chorizo> hey... that's a good point
15:52:37 <chorizo> why isn't that a thing?
15:52:44 <EvanR> you havent implemented it yet
15:52:47 <sl2c> sounds like maybe a good summer of code project imho
15:52:50 <jared-w> you can pipe shit through color for ghci if you want to
15:52:51 <sm> chorizo: I like ghcid -c 'stack ghci'
15:53:02 <chorizo> sm, what does that do?
15:53:05 <jared-w> it just tends to break a lot
15:53:08 <chorizo> man I can't implement anything
15:53:16 <sm> like --file-watch, but faster and more readable
15:53:29 <sm> can run your tests too
15:53:36 <jared-w> It essentially runs the type checker every time you save a file and then pretty prints the output
15:53:42 <fishythefish> helichopter: that should work as you wrote it
15:53:58 <chorizo> ghcid command not found
15:54:04 <sm> stack install ghcid
15:54:11 <chorizo> naa jared-w has scared me
15:54:17 <chorizo> I'm on manjaro which is basically arch
15:54:27 <chorizo> wait stack
15:54:29 <chorizo> I can do that
15:54:38 <sm> deep breaths!
15:54:43 <sm> you can do it!
15:55:01 <helichopter> fishythefish: i get "Not in scope: type variable 't'"
15:55:02 <jared-w> stack build ghcid --copy-compiler-tools ಠ_ಠ
15:55:09 <chorizo> it's an annoying habit to split up all the lines I type
15:55:12 <sm> er, I do not know your arch situation and I will not be responsible for what ensues
15:55:18 <helichopter> i saw a blog post about typeapplications that had a similar example, but when I tried to compile it, it gave the same the error
15:55:51 <jared-w> (stack install ghcid is technically fine, but stack build --copy-compiler-tools is more robust and nicer)
15:56:03 <chorizo> yeah it didn't work so
15:56:06 <chorizo> lets see if that works
15:56:33 <glguy> helichopter: To use type variables (for much at all) in explicit type applications, you'll need to be using ScopedTypeVariables extension
15:56:49 <chorizo> interesting.. 'Invalid option `--copy-compiler-tools'
15:56:57 <jared-w> ah whoops, it's not plural
15:57:13 <jared-w> stack build --copy-compiler-tool ghcid will do the trick
15:57:28 <fishythefish> helichopter: well, you'll want ScopedTypeVariables to bring it into scope but the syntax is valid
15:58:04 <jared-w> now as long as you're on that stack LTS, `stack exec -- which ghcid` will find ghcid correctly
15:58:28 <jared-w> and then there's no more bitching about broken paths ಠ_ಠ
15:58:53 <chorizo> I have no idea what that did, but it looks promising /home/james/.stack/snapshots/x86_64-linux-tinfo6-nopie/lts-11.5/8.2.2/bin/ghcid
15:59:16 <jared-w> yup cool
15:59:19 <chorizo> that didn't add ghcid to my path, is there an extra step?
15:59:23 <jared-w> no, it's just magic
15:59:31 <jared-w> instead of `ghcid ...` just run `stack exec -- ghcid ...`
15:59:52 <chorizo> I love running stuff that I have no idea what it's doing
16:00:11 <Welkin> chorizo: you would love windows
16:00:23 <jared-w> think of it as namespacing for paths. `stack exec --` is essentially saying "load up my stack path and then do the rest of what I type as a normal shell command"
16:00:43 <chorizo> huh that's cool
16:01:29 <jared-w> --copy-compiler-tool just knows a specific directory that's namespaced to your LTS so that you only need to build your IDE tools once per version instead of once per project :)
16:01:30 <chorizo> damn that's awesome
16:01:38 <chorizo> it literally shows me errors instantly
16:01:44 <jared-w> ikr
16:01:57 <chorizo> cheers sm & jared-w
16:02:10 <jared-w> almost better than popup errors in your text editor lol
16:02:29 <helichopter> glguy, fishythefish, thanks guys!
16:02:46 <chorizo> shoutout to my mum, I couldn't have achieved this without you either
16:03:16 <jared-w> lol, go mum
16:06:55 <sm> chorizo yes! number one haskell dev tool! :)
16:08:00 <Welkin> your mom?
16:16:19 <chorizo> I swear I spend more time trying to think of what to build rather than actually building it, too much choice, too little time
16:20:42 <EvanR> goos
16:20:56 <EvanR> good, haskell is doing its part to stop crappy software from being written :)
16:21:00 <hpc> hah
16:21:14 <EvanR> through analysis paralysis
16:21:45 <chorizo> you got me
16:24:31 <iqubic> how can I get nix to build my haskell projects?
16:25:18 <Welkin> iqubic: https://github.com/Gabriel439/haskell-nix
16:25:47 <jared-w> Do you use arch linux?
16:26:52 <EvanR> on one hand, it sucks how much we have to deal with arch in here. on the other hand, at least some people are using haskell on arch at all, instead of being like "its not arch-like so must be bad"
16:28:00 <Welkin> jared-w: will haskell platform work on arch?
16:28:36 <jared-w> Welkin: the only thing wrong with arch + haskell is the dynamic linking caused by the arch repositories (and the arch user repos)
16:29:00 <jared-w> If you don't have dynamic linking it's just another linux distro; not even particularly oddly laid out, either. I'd be shocked if HP didn't work
16:29:59 <EvanR> be careful what youd be if HP didnt work
16:30:01 <jared-w> The problem people tend to run into is that the package managers they use are fantastic at solving dependencies, so when the dynamic linking thing happened, if they had pandoc installed already, or shellshock, or some other haskell thing their system update just suddenly grew by +90 packages and +350-500 MB in size for no reason
16:30:02 <cheater> hi
16:30:07 <cheater> how do i convert Float to Double?
16:30:14 <EvanR> realToFrac
16:30:18 <cheater> thanks
16:30:35 <chorizo> EvanR, the human hoogle
16:30:43 <jared-w> lol
16:31:00 <EvanR> @hoogle Float -> Double
16:31:01 <lambdabot> Extra floatToDouble :: Float -> Double
16:31:01 <lambdabot> Numeric.Extra floatToDouble :: Float -> Double
16:31:01 <lambdabot> Llvm.Types widenFp :: Float -> Double
16:31:35 <chorizo> @hoogle Real a, Frac b => a -> b
16:31:35 <lambdabot> package base
16:31:35 <lambdabot> package bytestring
16:31:35 <lambdabot> package containers
16:31:41 <chorizo> hmm
16:31:41 <jared-w> Welkin: if you're going to suggest HP to people on arch (although stack or new-build really is the better option), do make sure they follow step 3 for the install steps. Arch has PIE executables
16:32:23 <DigitalKiwi> You know other than glguy occasionally having to tell people to be a little less off-topic at times this channel is pretty laid back. props
16:32:34 <Welkin> I need to find the best solution for how anyone can isntall haskell for my book
16:32:45 <Welkin> I initially was goin to say "haskell platform" and still want to say that as the default
16:32:54 <Welkin> but even I ran into a minor issue with libtinfo
16:33:05 <Welkin> and the whole PIE thing with extra steps is dumb
16:33:20 <Welkin> osx and windows should just work with the platform though
16:33:30 <chorizo> Welkin, you're writing a book?
16:33:33 <Welkin> yes
16:33:41 <Welkin> haskellroguelike.com
16:34:16 <yushyin> with arch linux it’s best to not use the distributed packages for development stuff, always having the newest shiny ghc does not work well for most stuff on hackage or stackage. I use stack and let it handle all haskell packages even ghc, works for me.
16:34:40 <cheater> what bit size is Float on 64-bit and 32-bit machines?
16:34:42 <Welkin> I want to make sure they have the latest ghc and cabal
16:34:44 <chorizo> Welkin, huh, that's pretty cool
16:34:45 <jared-w> yushyin: it's not even the new shiny thing; it's just that arch uses dynamic linking for everything and refuses to obey pin package suggestions
16:34:46 <DigitalKiwi> Other channels have rules like no "lol", no mention of any other distro/language/etc, no more than 3 lines, no learning to use the bot, or else get b&. also you're really friendly and helpful
16:35:06 <yushyin> jared-w: well it’s also ghc which sucks a bit on dynamic libraries
16:35:39 <jared-w> True, but arch could do things slightly less than the most unrecommended way possible...
16:36:09 <chorizo> DigitalKiwi, what channels are those? I'd get banned in a second... lol
16:36:30 <jared-w> (like, seriously, dynamic linking will break stuff that's explicitly pinned because Pacman tried to do cabal's job and will do it worse?)
16:36:34 <DigitalKiwi> I stopped using the arch haskell repo in my VM because it was always down
16:36:38 <EvanR> chorizo: Float is ieee single precision, Double is double precision
16:36:44 <EvanR> cheater:
16:37:14 <DigitalKiwi> chorizo most people here would be banned from various channels heh
16:37:42 <EvanR> cheater: but the report says Float and Double are actually implementation defined
16:37:53 <EvanR> hypothetically
16:38:23 <EvanR> DigitalKiwi is right
16:38:43 <jared-w> Welkin: the easiest 1-step "recite the incantations and thou shalt have a haskell" is probably just going to be stack tbh. I know you hate it, though :p
16:38:45 <yushyin> jared-w: it is a bit problematic yes, but I can also understand the arch linux haskell maintainer to want dynamics libs but it just don’t work with ghc
16:38:53 <aarvar> DigitalKiwi: or already have been banned :)
16:39:06 <EvanR> the ops do a really good job at moderating this channel, and the people do a good job at not letting it devolve into standard internet jerry-springer-show
16:39:21 * aarvar <-- banned from #scala
16:39:34 <chorizo> to be fair, if you want somewhere that's more formal, the mailing lists seem pretty good
16:39:35 <Welkin> jared-w: I am using cabal new-* in my book
16:39:46 <EvanR> but lets not go through all the particular channels and shit talk them here
16:39:46 <yushyin> jared-w: you cannot even build ghc in such a way that it uses dynamic linking by default, so that’s why arch linux users have to edit cabal config files ;(
16:40:21 <jared-w> which is why it's even more hilarious to me that they did that. To specifically go out of your way to break an entire language ecosystem and then bitch at them for doing the wrong thing is just... ¯\_(ツ)_/¯
16:40:41 <jared-w> Welkin: Ah okay, cool! I'll have to go through your book sometime and follow the instructions with my n00b hat on and see if I run into difficulties :)
16:41:53 <EvanR> Welkin: using curses or what
16:42:29 <Welkin> EvanR: vty
16:42:38 <cheater> EvanR: sure, i'm just wondering what single precision and double precision end up being
16:42:49 <EvanR> those are specific things
16:42:52 <cheater> on 32-bit, is float 32 and double 64?
16:43:00 <cheater> or 16 and 32?
16:43:04 <EvanR> it doesnt matter what the bitness of the computer is
16:43:15 <cheater> it does too!
16:43:29 <monochrom> Oh great.
16:43:40 <Clint> risky bitness
16:43:42 <EvanR> double wa 64 bits on the x87 floating point extension
16:43:51 <cheater> OK
16:43:55 <EvanR> was*
16:44:00 <EvanR> back in 16 bit era
16:44:24 <cheater> hmm.. so on x64, is float 64 bits?
16:44:29 <EvanR> no
16:44:39 <cheater> so why am i getting different numbers.. i wonder
16:44:47 <EvanR> single precision is 32 bits, double precision is 64, half is 16
16:44:59 <EvanR> quad is 128
16:45:12 <yushyin> jared-w: it’s also just one particular trusted user who is in charge for ghc and most haskell packages. Would be great if he could join here and we could tell him that ghc and its ecosystem is just not ready for dynamic builds (and may will never be)
16:45:23 <cheater> i have a quickcheck test that fails on 32-bit but apparently (?) runs on 64-bit (i can't confirm as i don't have a 64-bit machine handy)
16:45:37 <EvanR> well, the bitsize is the same but
16:45:52 <cheater> maybe the internal representation is different in some way
16:46:03 <EvanR> unlikely
16:46:10 <cheater> if you're on a 64 bit machine, would you like to run the tests on freer-2.4.1 to see if they pass?
16:47:15 <EvanR> whats the command to run tests
16:50:35 <cheater> cabal test
16:50:37 <cheater> i guess
16:51:06 <cheater> cabal unpack freer; cd freer-0.2.4.1; cabal sandbox init; cabal configure --enable-tests; cabal install --enable-tests; cabal test
16:51:26 <cheater> or some related steps in stack that i don't know
16:52:19 <EvanR> failed to build
16:52:52 <EvanR> http://lpaste.net/479778650468646912
16:53:41 <monochrom> Perhaps you need to "cabal update" first.
16:53:56 <EvanR> just tried that, same error
16:54:22 <EvanR> except for the cabal out of date warning
16:55:01 <EvanR> youd think this was a stackified project
16:55:14 <EvanR> i dont see a stack file
16:55:38 <monochrom> Oh, missing "cabal install --dependencies-only"
16:55:41 <sclv> right
16:55:43 <sclv> was just going to say
16:56:31 <EvanR> if i try that is says All the requested packages are already installed: Use --reinstall if you want to reinstall anyway.
16:57:09 <EvanR> threw in an --enable-tests and now its installing stuff
16:57:40 <monochrom> Oh!
16:58:26 <monochrom> Because the test section has dependencies not in the library section.
17:00:32 <EvanR> cheater: which test fails?
17:00:45 <EvanR> (still waiting for it to compile the universe)
17:01:15 <cheater> the one that uses testMultiReader
17:01:42 <cheater> (there's only one like that)
17:02:32 <EvanR> testMultiReader f n == ((f + 2.0) + fromIntegral (n + 1))
17:03:33 <EvanR> heh f stands for float
17:04:56 <EvanR> the test runs two nested Readers, asks for both environments, and does fromIntegral (v1 + (1::Int)) + (v2 + (2::Float))
17:05:39 <EvanR> so its testing that equals ((v2 + 2.0) + fromIntegral (v1 + 1))
17:05:57 <EvanR> what values does it fail on
17:06:45 <EvanR> 1 of 1 test suites (1 of 1 test cases) passed.
17:07:26 <EvanR> + is commutative with floats
17:08:59 <EvanR> Int is the one that is different on 32 vs 64 bit
17:11:20 <monochrom> Then again 1::Int is unproblematic.
17:11:30 <monochrom> How large is v1?
17:11:40 <EvanR> its a test input so could be anything
17:12:02 <monochrom> Then again it is just comparing x+y with y+x so who cares what's in x and y.
17:12:11 <EvanR> right
17:12:49 <EvanR> i just noticed the parentheses so its literally the same thing but commuted
17:13:16 <EvanR> maybe cheater is running the test on a machine without commutative floats
17:13:19 <EvanR> lol
17:14:51 <EvanR> @check x + y == y + x
17:14:54 <lambdabot>  *** Failed! Falsifiable (after 1 test):
17:15:11 <EvanR> EXPLAIN
17:16:08 <EvanR> @check \x y -> x + y == y + x
17:16:10 <lambdabot>  +++ OK, passed 100 tests.
17:16:18 <EvanR> @check \x y -> x + y == y + (x :: Float)
17:16:20 <lambdabot>  +++ OK, passed 100 tests.
17:17:16 <EvanR> does GHC exploit commutativity when optimizing float arithmetic ...
17:17:27 <Xal> -0 + 0 = -0, 0 + -0 = 0
17:17:46 <EvanR> > (-0) + 0 == 0 + (-0)
17:17:48 <lambdabot>  True
17:17:54 <EvanR> > (-0) + 0 == (0::Float) + (-0)
17:17:56 <lambdabot>  True
17:18:06 <Xal> iee754 makes -0 == 0
17:18:47 <EvanR> > (1/0) == (1/(-0))
17:18:50 <lambdabot>  False
17:18:51 <EvanR> \o/
17:20:39 <EvanR> no x==y -> f x == f y for you
17:21:05 <Welkin> @check \a -> a
17:21:07 <monochrom> These are dark times.
17:21:08 <lambdabot>  error:
17:21:08 <lambdabot>  • Ambiguous type variable ‘p0’ arising from a use of ‘myquickcheck’ prevents...
17:21:20 <Welkin> @check \a -> a :: Int
17:21:22 <lambdabot>  error:
17:21:23 <lambdabot>  • No instance for (STestable Int) arising from a use of ‘myquickcheck’ • In ...
17:21:25 <monochrom> myquickcheck eh?
17:21:28 <Welkin> @check \a -> a :: Int -> Int
17:21:30 <lambdabot>  error:
17:21:31 <lambdabot>  • No instance for (STestable Int) arising from a use of ‘myquickcheck’ • In ...
17:21:34 <Welkin> lol
17:21:39 <EvanR> return a Bool
17:21:51 <Welkin> @check \a -> a :: Bool -> Bool
17:21:53 <lambdabot>  *** Failed! Falsifiable (after 1 test and 1 shrink):
17:21:53 <lambdabot>  <Bool -> Bool> True
17:22:03 <Welkin> lol what
17:22:22 <monochrom> Wait, True is a counterexample?!
17:22:34 <EvanR> i dont know whats True anymore
17:22:34 <Welkin> @check \a -> a == True :: Bool -> Bool
17:22:37 <lambdabot>  error:
17:22:37 <lambdabot>  • Couldn't match expected type ‘Bool -> Bool’ with actual type ‘Bool’ • Poss...
17:22:51 <EvanR> @check \a -> a == True
17:22:53 <lambdabot>  *** Failed! Falsifiable (after 5 tests):
17:22:53 <lambdabot>  False
17:23:00 <Welkin> @check \a -> a == a :: Bool -> Bool
17:23:02 <lambdabot>  error:
17:23:02 <lambdabot>  • Couldn't match expected type ‘Bool -> Bool’ with actual type ‘Bool’ • Poss...
17:23:18 <Welkin> @check \a -> (a == a) :: Bool -> Bool
17:23:20 <lambdabot>  error:
17:23:20 <lambdabot>  • Couldn't match expected type ‘Bool -> Bool’ with actual type ‘Bool’ • Poss...
17:23:21 <iqubic> if a then not a.
17:23:25 <Welkin> o.o
17:23:47 <EvanR> your annotation is inside the lambda
17:23:57 <monochrom> Oh, I see, the counterexample is really "(\ _ -> False) True".
17:24:04 <Welkin> @check (\a -> a == a) :: Bool -> Bool
17:24:06 <lambdabot>  +++ OK, passed 100 tests.
17:24:12 <epta> is there anyone who can help with nix question. I usually generate default.nix and shell.nix using cabal2nix, and everything works fine on osx, but on nixos I got this error: attribute ‘binary-orphans_0_1_7_0’ missing
17:24:27 <Welkin> epta: there is #nixos
17:32:54 <EvanR> @check \x y z -> (x::Float) + (y + z) == (x + y) + z
17:32:56 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 5 shrinks):
17:32:56 <lambdabot>  -3.3078988 -6.920674 1.0639719
17:33:43 <EvanR> shrinkage is great
17:34:37 <Welkin> even in the pool?
17:37:38 <EvanR> what is yahb
17:38:08 <EvanR> a tweaked lambdabot?
17:38:28 <lyxia> yet another haskell bot
17:38:37 <EvanR> i cant seem to find its code anywhere
17:41:38 <EvanR> i almost forgot there was such a thing as closed source :)
17:43:02 <DigitalKiwi> what's that
17:48:50 <geekosaur> https://github.com/mniip/xsBot, looks like
17:49:05 <geekosaur> although I don't see the ghci sandbox plugin
17:49:08 <mniip> what
17:49:14 <mniip> that's not it
17:49:18 <geekosaur> oh
17:49:31 <mniip> the backend is https://github.com/mniip/sandbox
17:49:40 <mniip> https://github.com/mniip/sandbox/tree/master
17:49:55 <geekosaur> well, I was looking for the bot itself, and xsbot@...
17:50:51 <DigitalKiwi> oh no you summoned mniip now we are doomed
17:51:02 <Welkin> russian hackers
17:51:06 <mniip> ah
17:51:18 <geekosaur> meanwhile my browser hates me today so taking forever to find anything
17:51:23 <mniip> welll the IRC frontend is a bunch of mess that I've been looking to rewrite for a while
17:51:33 <geekosaur> (just wait a few minutes while I swap that tab back in...)\
17:52:19 <DigitalKiwi> your browser hates you? my internet was dead for an hour and a half today :(
17:53:31 <geekosaur> that's the more common case
17:53:47 <geekosaur> although really things have improved of late, I actually get to use wired now at least sometimes
17:54:01 <geekosaur> (had given up and was using expen$ive cellmodem)
17:54:32 <DigitalKiwi> I don't even have that as an option :( it was horrible!
17:58:12 <mniip> DigitalKiwi, my internet died in 2012 :(
18:00:29 <iqubic> anyone use emacs to edit haskell code?
18:00:35 * DigitalKiwi
18:01:02 <iqubic> What packages do you use in emacs to edit haskell code?
18:01:28 <Xal> haskell-mode and ghc
18:02:27 <iqubic> Why haskell-mode? What things about it attract you?
18:03:15 <sm> it, uh, highlights your source
18:03:25 <DigitalKiwi> I use spacemacs and it has haskell and helm *shrug*
18:03:44 <rotaerk> macs in space
18:04:47 <iqubic> How do you interact with ghci when coding?
18:06:44 <DigitalKiwi> I haven't gotten all fancy with it
18:08:02 <iqubic> What do you do?
18:09:36 <DigitalKiwi> I don't use ghci much and when I do it's just from a terminal I'm probably not the best person to ask about successfully using ghci
18:11:24 <cheater> hi
18:11:34 <cheater> when compiling a library, how can i make ghc use less memory?
18:11:51 <sm> @quote FAQ memory
18:11:51 <lambdabot> FAQ says: To build/link on low memory machines: use -j1, +RTS -M500m -RTS, and/or build fewer dependencies at once. Avoid swapping, it's too slow.
18:13:08 <monochrom> And switch to 32-bit GHC but I think you're already.
18:13:29 <monochrom> OTOH 32-bit GHC has its speed bumps.
18:13:59 <cheater> yeah, i am already
18:14:06 <cheater> any idea how i can set those things in nix?
18:14:13 <sm> hell no
18:14:52 <sm> well, what command are you using to compile the library ?
18:14:58 <cheater> nix-build
18:15:06 <monochrom> I bought a new laptop for more spacious memory for GHC.
18:15:40 <monochrom> No, I was kidding.  GHC is nothing compared to Chrome.  I bought the new laptop for more spacious memory for Chrome. :)
18:15:47 <rotaerk> cheater, paste your default.nix?
18:16:01 * sm wouldn't mind a new laptop for faster GHC compilation
18:16:16 <monochrom> To be sure, GHC benefits from it too as a side effect.
18:16:43 <cheater> rotaerk: can't, it's from a work repo thing
18:17:06 <monochrom> The CPU is also an Intel 8th gen Core-i7 so -j4 actually works.
18:17:07 <rotaerk> cheater, okay, well ... here's mine https://github.com/Rotaerk/vulkanTest/blob/master/default.nix
18:17:19 <cheater> let me look, thank you!
18:17:55 <rotaerk> cheater, note that on lines 27-30, I am using overrideCabal on the vulkan-api library, and one of the attributes I specify is configureFlags
18:18:04 <rotaerk> this lets me pass cabal flags
18:19:00 <monochrom> Recently I had to test a computationally intensive Haskell program from my student on my laptop.  (Homework I gave.)  Student said it took 2 seconds on his computer.  On my laptop it was instantaneous.
18:19:17 <sm> monochrom: what did you get ?
18:19:31 <monochrom> I mean, finally the prof's computer is faster than the students', for once. :)
18:19:37 <cheater> rotaerk: ok, hm, so..
18:19:53 <rotaerk> hrm, wasn't there a cabal flag for passing flags to ghc
18:19:55 <rotaerk> can't find it
18:19:56 <monochrom> Dell Inspiron 7xxx 13-inch.  8GB RAM.
18:20:15 <sm> nice
18:20:22 <cheater> rotaerk: i would do something like this? fake = overrideCabal ( FOO super.fake) { ... }
18:20:25 <cheater> what goes in FOO?
18:20:45 <cheater> (can i just omit FOO?)
18:21:03 <rotaerk> cheater, let's take this over to #nixos
18:21:12 <cheater> ok rotaerk thank you
18:22:57 <monochrom> But yeah RAM is the bottleneck for your -j10000!!!!
18:23:26 <cheater> so those ghc options above, what cabal field do they go in?
18:23:56 <sm> --ghc-options='+RTS 500m -RTS' possibly
18:24:35 <rotaerk> ah yea that's it
18:24:35 <sm> but more importantly, -j1, which I think is a native cabal flag
18:26:11 <cheater> sm: what does "native cabal flag" mean here?
18:26:40 <sm> a flag to pass to cabal (not ghc)
18:27:00 <rotaerk> cabal build --help
18:27:08 <rotaerk> shows what -j does
18:27:11 <sm> well, you could pass it to ghc too I think. But you don't have to because cabal has it.
18:27:30 <rotaerk> ah it also shows how you do the GHC options there
18:27:36 <rotaerk> it just says PROG instead of GHC
18:27:47 <rotaerk> well, ghc not GHC
18:27:56 <cheater> sm, ah
18:29:57 <cheater> so -j1 is passed to cabal configure, right?
18:30:22 <cheater> because i see a nix thing for passing flags to cabal configure, but not for passing flags anywhere else right now
18:31:16 <sm> no, I think it would be to cabal build or cabal install
18:31:23 <cheater> hm
18:32:50 <rotaerk> hence:  <rotaerk> cabal build --help
18:33:05 <dmwit> monochrom: Not to burst your bubble, but... could this be a ghci vs. compiled thing?
18:33:58 <DigitalKiwi> dmwit !
18:34:07 * dmwit waves vaguely in DigitalKiwi's direction
18:34:18 <DigitalKiwi> you're alive!
18:34:26 <dmwit> It's good to be back. =)
18:35:02 <DigitalKiwi> are you a zombie
18:35:24 <dmwit> Yes. I am the first to survive cryogenic freezing and revival.
18:36:08 <DigitalKiwi> well I mean there's kind of a religion based on a guy who did it a few thousand years ago...it's kind of a big deal
18:37:58 <monochrom> dmwit: The student said compiled.
18:38:36 <monochrom> Actually the program is brute-forcing something so on ghci it should take minutes.
18:42:34 <byorgey> DigitalKiwi: only the Gospel of Thomas mentions cryogenic freezing, that is non-canon
18:43:46 <DigitalKiwi> well it is my head-canon and that's all that matters hmph
18:44:20 <dmwit> My head-canon is that people who say "head-canon" actually mean "head cannon".
18:44:49 <sl2c> @type head canon
18:44:51 <lambdabot> error:
18:44:51 <lambdabot>     • Variable not in scope: canon :: [a]
18:44:51 <lambdabot>     • Perhaps you meant ‘anon’ (imported from Control.Lens)
18:45:20 <monochrom> Weak head canon form :)
18:47:26 <sl2c> your headcanon is weak and will not survive the winter
18:49:32 <DigitalKiwi> it's spring though! he says, knowing there's a good chance of snow tomorrow
18:50:39 * hackage gtk-strut 0.1.2.0 - Libary for creating strut windows with gi-gtk  http://hackage.haskell.org/package/gtk-strut-0.1.2.0 (eyevanmalicesun)
19:02:44 <cheater> sm, monochrom, even with -M500m it still does this:
19:02:45 <cheater> cc1: out of memory allocating 65536 bytes after a total of 2671759360 bytes
19:03:03 <cheater> why would it allocate 2.6 GB of ram if i tell it to only do 500 megabytes?
19:03:07 <cheater> what's going on?
19:06:58 <sm> cheater: that sounds like a haskell package which includes some C, and it's actually gcc running out of memory
19:07:52 <sm> so now you get to figure out what flags will limit gcc's ram usage
19:08:13 <sm> that seems quite a lot
19:10:21 <cheater> yeah... it does
19:11:02 <sm> http://jkroon.blogs.uls.co.za/it/scriptingprogramming/preventing-gcc-from-trashing-the-system might help
19:11:38 <sm> in your shoes, I would try to get cabal/ghc to show verbose output, grab the actual gcc command line and troubleshoot that
19:14:31 <cheater> sm, well it's weird, because this lib doesn't seem to be doing any FFI?
19:14:33 <cheater> https://github.com/TaktInc/fake/blob/master/src/Fake/Provider/Person/EN_US.hs
19:14:40 <cheater> it breaks when compiling this
19:14:45 <cheater> looks like vanilla haskell to me..
19:15:02 <cheater> also i grepped the source code and it doesn't *seem* to have any ffi use.. what do you think?
19:15:49 <sm> uh.. maybe ghc always calls gcc as part of compiling hs files ? I forget
19:16:01 <geekosaur> it doesn't
19:16:08 <geekosaur> not for many years
19:16:13 <EvanR> ffi could be placed there by CPP or by TH
19:16:15 <rotaerk> it would call gcc for the CPP (if you're using that), wouldn't it?
19:16:30 <geekosaur> but not cc1, which is the actual C compiler
19:17:03 <cheater> so where does cc1 come from? it's weird
19:17:06 <EvanR> doesn't the linker use **** amounts of memory
19:17:13 <Xal> that file doesn't have any CPP, just really long lists
19:17:21 <geekosaur> EvanR, that' ld, not cc1
19:17:26 <geekosaur> cc1 is the C compiler itself
19:17:35 <EvanR> right but could ld be causing oom
19:17:38 <sm> well from the look of that file, femaleFirstName is doubtless the problem.. does it improve if you comment out most of that
19:17:42 <geekosaur> sigh
19:18:01 <geekosaur> yes, cc1 is there just to confuse you, it can't mean something is actually reading C code and generating asm
19:18:10 <geekosaur> which is what cc1 does
19:18:14 <Xal> ghc should /really/ not run out of memory when handling a large list at compile time
19:18:22 <sm> (maleFirstName too)
19:18:50 <cheater> here's the build log http://lpaste.net/364944
19:19:02 <EvanR> if its not even running cc1 ...
19:19:16 <geekosaur> I yield
19:19:32 <cheater> the log says it's running cc1
19:19:36 <EvanR> oh
19:19:36 <geekosaur> ^
19:19:51 <geekosaur> cc1, which parses C code and generates asm, is running otu of memory
19:19:52 <cheater> or rather
19:19:52 <cheater> cc
19:19:54 <cheater> not cc1
19:19:59 <geekosaur> not cpp, not ld, not ghc
19:20:00 <Xal> how the hell is a list of 1000 names using 2.5gb of memory
19:20:14 <cheater> it probably just means "first invokation of cc"
19:20:15 <sm> the OverloadedStrings instance perhaps
19:20:16 <Xal> hold on I'm going to cabal2nix this
19:20:22 <EvanR> the names must be quite long
19:20:22 <geekosaur> ...
19:20:22 <geekosaur> whatever
19:20:36 <cheater> this is fairly insane
19:20:48 <iqubic> So what the is the best way to connect to ghci when running emacs, and using nix to build everying thing.
19:21:04 <geekosaur> keep diffing, you;ll find some way to explain away the cc1 executable
19:21:09 <geekosaur> digging
19:21:16 <Xal> nix is doing something weird
19:21:18 <cheater> yeah i'm at a loss right now
19:21:25 <cheater> why are you saying cc1 though? is that really a thing?
19:21:34 <cheater> i don't even have an executable called cc1 in my $PATH
19:21:36 <EvanR> cc1 is an actual program in the gcc system
19:21:38 <cheater> just cc
19:21:46 <geekosaur> [18 02:02:23] <cheater> cc1: out of memory allocating 65536 bytes after a total of 2671759360 bytes
19:21:46 <cheater> where would cc1 be located?
19:21:48 <sm> well for example maybe SingleWord's OverloadedStrings thing uses C ?
19:21:56 <geekosaur> an executable which calls itself cc1 is reporting out of memory
19:22:08 <cheater> geekosaur: any idea where it is?
19:22:20 <geekosaur> but we're all despierately trying to fun reasons for that to be anything except the cc1 executable that is in gcc's lib dir
19:22:27 <EvanR> you have a different PATH when youre compiling sometimes
19:22:29 <geekosaur> the thing that actually compiles C code for gcc
19:22:40 <geekosaur> yay, another way to try to have it be anything else
19:22:40 <Clint> that's not a fun reason
19:22:45 <Xal> cheater: alright I can't reproduce this.  just built it with nix derivation http://lpaste.net/364945 and it built fine
19:22:49 <rotaerk> lol
19:23:11 <sm> Xal: ghc version ?
19:23:15 <sm> oh
19:23:23 <Xal> 8.2.2
19:24:37 <EvanR> i mean that explains why you cant just see cc1 with where
19:24:39 <EvanR> er which
19:25:00 <cheater> EvanR: true
19:25:15 <EvanR> i mean it might explain
19:27:05 <cheater> ok... so why is this thing running gcc?
19:27:09 <cheater> if you look at the source..
19:27:15 <cheater> there doesn't seem to be any ffi, anywhere
19:27:28 <cheater> the dependencies listed in the .cabal seem to be things that don't use the ffi either
19:27:41 <EvanR> dependencies of dependencies
19:27:45 <cheater> :S
19:27:59 <cheater> hmm..
19:28:03 <sm> cheater: are you able to confirm that the long lists are the trigger ? also your ghc version ?
19:28:05 <geekosaur> pyanfar Z$ gcc --print-file-name=cc1
19:28:05 <geekosaur> /usr/lib/gcc/x86_64-linux-gnu/4.8/cc1
19:28:17 <cheater> sm: i don't know, i think nix builds it with 8.0.2
19:28:26 <cheater> sm: but i don't exactly know how to check
19:28:38 <geekosaur> and I am pretty sure Data.Text *does* use FFI, extensively
19:28:39 <cheater> geekosaur: right, i just did find /usr --iname cc1 and it found it too
19:28:58 <rotaerk> use nix-shell, and then which gcc
19:29:00 <geekosaur> and if that list is [Text] then it may be trying to be celever
19:29:03 <geekosaur> *clever
19:29:14 <cheater> so now maybe i should just put a wrapper around cc1 telling it to behave
19:29:18 <cheater> what do you think?
19:29:43 <cheater> but that's pretty insane. can i make cabal give ghc some sort of options?
19:29:48 <cheater> i think someone mentioned something here
19:29:58 <rotaerk> cheater, that's what --ghc-options does
19:30:16 <cheater> er
19:30:20 <cheater> i meant give gcc options
19:30:31 <rotaerk> that's what --ghc-options=-optc= does
19:30:37 <cheater> right
19:30:51 <cheater> so we have this here
19:30:52 <cheater> http://jkroon.blogs.uls.co.za/it/scriptingprogramming/preventing-gcc-from-trashing-the-system
19:30:53 <rotaerk> or optl for linker, etc
19:31:06 <cheater> and it says...
19:31:06 <sm> cheater: to confirm it's the longs lists, comment out most of them
19:31:07 <cheater> --param ggc-min-expand=20 --param ggc-min-heapsize=32768
19:31:19 <cheater> sm: i can't, i would have to override where that comes from
19:31:37 <cheater> let me try stuffing those --param things in the nix code first, and see if that still keeps on blowing up
19:31:37 <sm> you'd have to clone the package locally and build it, yes
19:31:42 <cheater> yeah
19:32:07 <rotaerk> cheater, that's easy enough to do with the relSourceOverrides and whatnot that you saw in my default.nix
19:32:13 <sm> the fewer layers of tooling between you and the failure, the easier
19:32:25 <cheater> rotaerk: yeah, i know
19:35:22 <sm> SingleWord: https://github.com/TaktInc/fake/blob/master/src/Fake/Provider/Lang.hs, FGen: https://github.com/TaktInc/fake/blob/master/src/Fake/Types.hs
19:37:46 <sm> no obvious C usage there.
19:40:26 <cheater> hmm... so now i get..
19:40:28 <cheater> cc1: error: invalid --param name ‘gcc-min-expand’
19:40:28 <cheater> cc1: error: invalid --param name ‘gcc-min-heapsize’
19:40:39 <cheater> so apparently, cc1 is to be tamed some other way
19:41:21 <cheater> oh... ggc, not gcc
19:41:35 <cheater> why the hell is it "ggc"
19:41:38 <cheater> i hate computers
19:41:50 <hodapp> ggc?
19:42:04 <cheater> yeah, it's ggc.
19:42:22 <xaxaac> is adding more RAM out of the question?
19:42:33 <cheater> apparently, GGC is the GCC GC.
19:42:45 <cheater> xaxaac: it's 4 am. stores are closed.
19:42:45 <sm> xaxaac: pfff! it's ALWAYS out of the question
19:43:59 <sm> I know this will not help in any way, but I too can not reproduce. :)
19:45:15 <cheater> maybe you have enough ram
19:45:35 <sm> I watched top, it didn't get that big
19:46:54 <cheater> ok so according to ps, gcc is getting the ggc params
19:48:04 <cheater> and it crashed
19:48:19 <cheater> it's still allocating cc1: out of memory allocating 65536 bytes after a total of 2738909184 bytes
19:48:27 <cheater> ...2.7 gb
19:51:25 <sm> I now see it dies when building the profiling version
19:52:19 <cheater> ohh
19:52:22 <cheater> maybe i can disable that
19:52:35 <cheater> also, i just tried giving gcc -O0, let's see what that does
19:53:04 <xaxaac> feh, only 2.7gb? you aren't running 256gb ram? /s
19:56:13 <blankhart> what is meant when it says, on the page, https://wiki.haskell.org/The_Fibonacci_sequence, sec 2.2.3, "The fix used here has to be implemented through sharing, fix f = xs where xs = f xs, not code replication, fix f = f (fix f), to avoid quadratic behaviour."
19:57:30 <cheater> good question
19:57:33 <cheater> no idea :S
19:57:35 <blankhart> oh is the idea that GHC will reuse lazily computed values if it is written one way, but recompute them if another?
19:59:18 <sm> cheater: this was reported months ago: https://github.com/TaktInc/fake/issues/4
19:59:32 <cheater> oh hell yeah
19:59:38 <cheater> disabling profiling worked
20:00:07 <sm> also, I confirm that the c compiler runs and uses a lot of ram when compiling that module for profiling. It peaked at 800M here though
20:00:20 <cheater> sm, thank you
20:00:29 <cheater> i am in your debt again
20:00:29 <sm> victory ?
20:00:41 <cheater> this battle has been won
20:00:43 <sm> \o/
20:00:50 <cheater> the war continues
20:01:28 <sm> lessons learned: remember to check issue tracker
20:01:51 <cheater> i just assumed my pc was too old
20:01:59 <cheater> it's usually a good assumption
20:02:18 <cheater> you're right though
20:04:13 <rotaerk> cheater, nice
20:07:07 <anon136> What is the difference between a polymorphic type and an overloaded type? The book I'm reading makes them sound like they are pretty much the same thing.
20:07:47 <dmwit> It is probably trying to distinguish between parametric polymorphism (the exact same code runs on many types) and ad-hoc polymorphism (the type helps determine what code to run).
20:08:01 <monochrom> I have never heard of overloaded type.
20:08:20 <monochrom> Overloaded value, yes.  Type, no.
20:08:41 <dmwit> For example, consider the "length of a list" function: it counts the exact same thing no matter what type of elements there are in the list. Meanwhile, the "sum of a list" function will execute different code for addition depending on what type of number elements a list has.
20:08:51 <anon136> I'll quote the book "A type that contains one or more class constraints is called overloaded."
20:09:16 <monochrom> Oh, that.
20:09:31 <mniip> huh, never heard that terminology?
20:09:32 <rotaerk> https://www.haskell.org/tutorial/classes.html  this thing says that ad-hoc polymorphism *is* overloading
20:09:50 <mniip> anon136, what book is that if I may ask?
20:10:03 <monochrom> Yeah, we say contrained type or say nothing at all.
20:10:16 <anon136> "Programming in haskell" by Graham Hutton (second edition)
20:13:22 <anon136> dmwit: Yea it uses Length as an example for polymorphic and (+) (*) negate and abs as examples for overloaded.
20:14:48 <blankhart> these concepts are combined i think in OOP languages, where polymorphism is used to overload class methods
20:15:18 <blankhart> by polymorphism in that context meaning a subtyping relationship
20:16:25 <dmwit> anon136: Okay. Are the two concepts clear to you, or is there still some confusion? If there is still some confusion, can you say what you don't understand yet?
20:17:47 <cheater> what is an overloaded type in haskell?
20:18:44 <Axman6> 'a' is pretty overloaded #usenewtypevariablenames
20:19:16 <blankhart> haskell overloads identifiers through typeclass constraints or data families, so a constrained type parameter could be said to be an "overloaded type" (this is how i understood it) but maybe also a data family?
20:20:20 <dmwit> cheater: Any type which mentions a typeclass constraint.
20:22:45 <monochrom> No, OOP's "polymorphism" refers to something like overloaded types (but not quite).  OOP does not have Haskell's polymorphism.  For example, OOP does not have a->a.  (BaseClass->BaseClass does not qualify.)
20:23:30 <monochrom> By the time you point at Java's <T>, that's learned from Haskell SML etc due to Phil Wadler.
20:23:34 <anon136> dmwit: I guess not. The first example you gave matches up pretty closely to what he calls "polymorphic types" but I dont see any evidence that what he calls "overloaded types" match the description for "ad-hoc polymorphism". But I don't suppose it's as important as all this. I'm just going to keep reading. Thanks for the assist. :)
20:24:53 <geekosaur> didn't Wadler introduce that description? in the paper where he introduced typeclasses?
20:25:26 <Axman6> does A foo<A>(A a) {return a;} not count?
20:25:48 <monochrom> Yes.
20:26:07 * Axman6 rereads and actually understands what was written
20:26:44 <monochrom> https://twitter.com/mosheroperandi/status/856946180810354688
20:26:52 <DigitalKiwi> the graham hutton book is one of my favorites, he has a lot of papers on his website too
20:27:31 <geekosaur> @google making ad hoc polymorphism less ad hoc
20:27:31 <lambdabot> https://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf
20:27:40 <geekosaur> which indeed refers to it as overloading
20:27:53 <Axman6> monochrom: that post should've been a turning point for Go, but I think some people saw it and thought "Hey, that's really neat" and moved on without understanding how not neat it actually is
20:28:11 <dmwit> monochrom: C++ templates are great, we should do more of those, but without compiler support.
20:28:13 <blankhart> polymorphism is an overloaded word
20:28:37 <Axman6> dmwit: gotta keep the compiler fast!
20:28:55 <geekosaur> there was also a pre-Haskell version that actually used a keyword OVERLOADS iirc
20:29:25 <monochrom> "class Eq a overloads (==) :: a -> a -> Bool"?
20:30:00 <geekosaur> it looked like a preprocessor, all uppercase keywords for CLASS and OVERLOADS (== instance)
20:30:00 <geekosaur> possibly for Miranda
20:30:30 <monochrom> I think I see why I didn't like the name "overloaded type".
20:30:57 <monochrom> "Bounded a => a" can be view two ways.
20:31:15 <iqubic> It can?
20:31:29 <spear2> import Linear (V3) --> V3 "Data constructor not in scope"?
20:31:41 <monochrom> I like the top down way.  Start with an all-encompassing "forall a. a" and constrain, limit it down to "forall a. Bounded a => a"
20:31:41 <mniip> that imports the tycon
20:31:44 <geekosaur> spear2, import Linear (V3(..))
20:31:45 <mniip> try (V3(..))
20:32:03 <Axman6> (V3) only imports the type, not its constructors
20:32:05 <geekosaur> (type constructor and all associated data constructors)
20:32:05 <spear2> ah ty :)
20:32:25 <monochrom> But there is also the bottom-up way.  "forall a. Bounded a => a" is the union of Int, Bool, Double, ... all those instances.
20:32:25 <Axman6> to be explicit you could also use (V3(V3))... but don
20:32:29 <Axman6> 't
20:33:34 <monochrom> But I like explicit.
20:34:08 <mniip> monochrom, uhhh that's not...
20:34:31 <mniip> hmm
20:34:36 <monochrom> :)
20:35:21 <mniip> is there a problem with that bottom-up way in regards to naturality of the profunctor end square?
20:35:22 <geekosaur> it's the kind of explicit that likes to bite you in the butt without warning, because you forget you only imported one constructor when there are several
20:35:29 <Axman6> "Int `isA` Bool` => True, got it, thanks!
20:38:44 <anon136> True > False = True... really haskell, I went into STEM to avoid ideology...
20:39:20 <iqubic> :t isA
20:39:21 <lambdabot> error:
20:39:21 <lambdabot>     • Variable not in scope: isA
20:39:21 <lambdabot>     • Perhaps you meant ‘iso’ (imported from Control.Lens)
20:40:56 <mniip> > compare EQ GT
20:40:59 <lambdabot>  LT
20:41:42 <monochrom> In STEM, T is full of ideologies. E is not entirely free of them either.
20:42:48 <mniip> True > False... that's like one of the philosphical assumptions of S here
20:43:41 <dsal> Can anyone explain this to me?  https://hackage.haskell.org/package/HUnit-approx-1.1.1.1/docs/Test-HUnit-Approx.html
20:43:45 <dsal> I don't understand ?epsilon
20:43:57 <geekosaur> it's an implicit parameter
20:44:05 <dsal> How does that work?
20:44:12 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=implicitparams#extension-ImplicitParams
20:44:23 <monochrom> OTOH, "false is stronger than true" is in M and logic.  We say "p is stronger than q" iff p implies q.  Now let p=false, q=true... :)
20:44:54 <geekosaur> I've used them the same way, in fact exactly that way --- passing in an implicit epsilon for comparisons
20:46:09 <geekosaur> STEM's full of ideology anyway
20:47:42 <geekosaur> because humans are
20:48:31 <anon136> You guys thought entirely too hard about my silly little remark. Haha. I love it.
20:49:08 * geekosaur has been thinking about a generalization of that topic quite a bit recently. https://www.sciencedaily.com/releases/2018/03/180305111533.htm being one recent example of it
20:49:23 <geekosaur> and it's all through biological and medical sciences
20:49:40 <geekosaur> "we already know it works this way, it cant be doing that oh wait"
20:56:31 <dsal> expected: 0.0\n but got: NaN\n (maximum margin of error: 1.0e-4)
20:56:32 <dsal> boo
20:56:34 <dsal> thanks, geekosaur
20:59:42 <cheater> dmwit: ah, ok
21:16:09 * hackage warp-tls 3.2.4.3 - HTTP over TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.2.4.3 (KazuYamamoto)
21:34:56 <spear2> does anyone know is qtah compatible with the cabal new-build system?
21:36:07 <spear2> i get undefined references during gcc Linkage
21:40:08 <DigitalKiwi> did we ever find out what Admin Snafu did to hackage?
21:49:33 <cocreature> DigitalKiwi: he did promise a postmortem
21:50:06 <DigitalKiwi> I didn't find anything on reddit or mailing lists
21:50:51 <cocreature> so far it hasn’t been published afaik
21:53:14 <DigitalKiwi> Well that makes me feel better about not finding it. I want to know what happened!
21:58:35 <geekosaur> best bet is probably asking in #haskell-infrastructure
22:00:02 <cocreature> or just learn to be a bit more patient, I’m sure everyone needs some time to relax after that :)
22:00:46 <cocreature> spear2: what’s the error?
22:03:47 <DigitalKiwi> yeah I don't care enough to bother them lol it hasn't even been a week
22:06:09 <EvanR> the command to rm -rf / on the hackage computer was sitting there and the cat walked on ENTER
22:06:27 <EvanR> i heard
22:06:50 <geekosaur> probably more like "uh, I meant to do that on the staging machine" :p
22:10:17 <spear2> cocreature: http://lpaste.net/8633510694530056192
22:11:26 <cocreature> spear2: huh weird, which version of cabal are you using?
22:14:16 <iqubic> EvanR: Is actually a thing that happened?
22:14:22 <EvanR> lol
22:14:32 <iqubic> Don't you need root permission to nuke / ?
22:14:32 <EvanR> i made that up, but maybe
22:14:48 <iqubic> At least "sudo rm -rf /"
22:14:58 <spear2> cocreature: cabal-install version 2.2.0.0 compiled using version 2.2.0.1 of the Cabal library
22:15:02 <spear2> is the output of cabal --version
22:15:03 <EvanR> of course they were logged in a root
22:15:10 <EvanR> as
22:15:17 <iqubic> Why? Who leaves a root shell open?
22:15:35 <EvanR> ive heard of this happening, usually preceded by or justified by "i know what i'm doing"
22:16:00 <cocreature> spear2: sry, not sure what’s going on there. new-build shouldn’t be incompatible in the sense that it produces linking errors where old build doesn’t so I suspect something has gone wrong somewhere™
22:19:19 <geekosaur> info tables going missing is really weird, unless for some reason qtah isn't listing some modules as exports
22:43:07 <iqubic> My favorite part of FP is that it makes mathematical sense.
22:43:48 <iqubic> in C you'd write "x = x + 1" but subtract x from both sides and you get "0 = 1"
22:44:10 <iqubic> that can't happen in Haskell. Or any other functional programming langauage.
22:45:44 <fishythefish> oh, it can happen in other functional languages
22:46:49 <iqubic> How often do recursive data structures come up in actual code?
22:46:55 <fishythefish> all the time
22:47:34 <cocreature> ever used a list?
22:47:41 <vaibhavsagar> iqubic: data List a = Nil | Cons a (List a)
22:48:19 <vaibhavsagar> data Tree a = Nil | Node a (Tree a) (Tree a)
22:49:16 <vaibhavsagar> data RoseTree a = Node a [RoseTree a]
22:49:17 <DigitalKiwi> modern versions of rm also require an extra flag to do do that on /
22:49:45 <EvanR> yes quite silly
22:49:48 <fishythefish> --no-preserve-root
22:50:19 <EvanR> how can you effectively shoot yourself in the foot if the safety is on
22:50:55 <fishythefish> with unsafeCoerce, of course
22:50:58 <DigitalKiwi> macos rm doesn't have that flag in the manual at least
22:51:28 <DigitalKiwi> I'm not going to try it in the name of science though sorry
22:52:54 <geekosaur> that's a gnuism, os x has freebsd userspace
22:53:27 <DigitalKiwi> I'm like 90% sure it only even exists in gnu because of ubuntu
22:53:48 <geekosaur> make that "linux" and I'll agree :)
22:54:08 <DigitalKiwi> and if it doesn't don't tell me otherwise because it helps feed my hatred of ubuntu
23:03:31 <dminuoso> > ('a','b','c') & partsOf each .~ "xyz"
23:03:34 <lambdabot>  ('x','y','z')
23:04:27 <dminuoso> How does this work? What mechanism picks each individual item from "xyz" ?
23:07:05 <boj> i suppose it's a list?
23:07:56 <dminuoso> boj: Well I thought (.~) was just set, which replaces the target of a lens with a constant value.
23:10:03 <cocreature> dminuoso: partsOf turns a traversal into a lens to a list of the elements in that traversal
23:11:52 <boj> :t partsOf each
23:11:53 <lambdabot> (Each s t b b, Functor f) => LensLike f s t [b] [b]
23:19:36 <aka_> Is there any tutorial on how to derive Monad? Especially when Monad is derivable?
23:20:14 <cocreature> aka_: you generally can’t derive Monad with the exception of GeneralizedNewtypeDeriving
23:20:55 <aka_> Say I enabled GeneralizedNewtypeDeriving, when will it work?
23:21:15 <cocreature> if you have a newtype for a type that is already an instance of Monad
23:21:17 <aka_> For example, I have: newtype Parser a = Parser (String -> (a, String))
23:21:51 <dminuoso> aka_: Well there is a Monad instance for `((->) a)` but I dont think thats what you want..
23:21:59 <cocreature> that’s not going to work, there is a Monad instance for String -> a but not for String -> (a, String)
23:22:08 <aka_> I see
23:22:25 <cocreature> or rather there is a monad instance for ((->) String)
23:22:38 <dminuoso> aka_: The GeneralizedNewtypeDeriving is just for gaining back access to instances you had before newtype wrapping.
23:23:26 <aka_> "gaining back access to instances you had before newtype wrapping" <- this really explains a lot
23:24:12 <cocreature> and don’t let GHC trick you into enabling DeriveAnyClass for deriving Monad instances :)
23:24:27 <aka_> haha, already tried : )
23:24:37 <cocreature> DeriveAnyClass just generates empty instances
23:24:56 <aka_> exactly what I saw in the dump : )
23:25:16 <aka_> which made me more confused
23:26:06 <aka_> Can I say DeriveAnyClass is kind of derive classes by force, even when it really can't
23:26:42 <cocreature> it’s just syntactic sugar for empty instance dcls
23:27:08 <aka_> what would be the use case for empty instance dcls
23:27:17 <cocreature> classes that have default implementations
23:27:18 <geekosaur> default methods provided via generics
23:27:20 <nshepperd> DeriveAnyClass is deriving instances by hoping that you don't need to do anything because the class author wrote sufficient default method implementations
23:27:21 <cocreature> e.g. FromJSON
23:27:21 <dminuoso> aka_: There's just no uniformity to derive Applicative/Monad. Take for instance `data List a = Cons a (List a) | Nil`
23:27:21 <geekosaur> usualy
23:27:27 <dminuoso> aka_: There is two valid Applicative instances.
23:28:11 <dminuoso> aka_: (If you dont know what the second is, this is useful practice)
23:29:13 <vaibhavsagar> there's only one valid monad instance though, right?
23:31:02 <lsund> q
23:31:41 <aka_> "There's just no uniformity to derive Applicative/Mona" <- this cures my misconception about deriv.  For List a, the <*> can apply [a->b] either to the head or to the tail, thus two Applicative, am I right?
23:33:00 <dminuoso> aka_: Nope. There are two Applicative instances with different behaviors. Try it out and see if you can figure it out yourself.
23:34:05 <dminuoso> aka_: If you prefer you can write them for [] directly.
23:38:15 <aka_> correct me if I'm wrong
23:38:24 <aka_> given fs :: [a -> b] and as :: [a]
23:38:28 <aka_> Applicative can be either
23:38:32 <aka_> fs <*> as = concat [map f [a] | f <- fs]
23:38:34 <aka_> or
23:38:36 <aka_> fs <*> as = map ($) zip fs as
23:39:22 <aka_> the first one should be fs <*> as = concat [map f as | f <- fs]
23:39:55 <dminuoso> aka_: Well ignoring that you use the Monad instance of [] to define the Applicative instance on the first.. but yeah.
23:40:23 <dminuoso> aka_: The tricky thing is: You can write Monad instances that typecheck for both. One will be lawful, the other not.
23:41:49 <dminuoso> cocreature: Are you aware of any special cases where generically deriving Monad is possible?
23:43:05 <aka_> dminuoso: These are still a bit unfamiliar to me. But your question really helped me understand the limit of "deriv". Thank you so much! I'm gonna practice more.
23:43:39 <dminuoso> aka_: Well list comprehensions are just list monads in disguise. =)
23:43:55 <cocreature> dminuoso: not aware of any but I never bothered researching it. I’m sure you can find special cases
23:44:18 <cocreature> the fact that there is no unique Monad instance also doesn’t mean you can’t make one possible instance
23:44:32 <cocreature> we also derive things like Ord which have multiple implementations for most types
23:44:38 <dminuoso> aka_: Functor can be generically derived though (given some conditions that can luckily be verified at compile time with generics)
23:46:03 <dminuoso> cocreature: Well the possible implementations have some kind of uniformity. That is they all follow a simple pattern
23:47:23 <cocreature> that doesn’t really matter if you want to implement a mechanism for deriving. what matters is that the implementations you derive are somewhat uniform
23:48:48 <aka_> Is there a systematic way for people like me to determine if something is derivable?
23:50:53 <Ariakenom> aka_, if a Class is derivable in general. Or if a Class is derivable for some type?
23:51:08 <aka_> for some type
23:51:18 <dminuoso> aka_: If GHC has a DeriveX extension, then it's derivable :P
23:51:29 <jle`> aka_: both of those definitions of <*> don't quite make sense in a vacuum
23:51:46 <jle`> aka_: you have to consider them in terms of pure and fmap :)
23:52:07 <dminuoso> DeriveGeneric, DeriveTraversable, DeriveFoldable, DeriveLift, DeriveDataTypeable, DeriveFunctor..
23:53:08 <aka_> dminuoso: Just had a look at the list of extensions. Again, you helped me a lot.
23:53:09 <dminuoso> aka_: Beyond that Eq/Ord/Show of course. :)
23:57:02 <aka_> jle`: You are right. I should have started by defining pure. But since Functor is generically derivable, we can assume there is a default one?
23:57:05 <vaibhavsagar> can I enable language extensions for lambdabot?
23:57:32 <jle`> aka_: Functor is unique, but Applicative isn't
23:57:34 <jle`> vaibhavsagar: no
23:57:38 <vaibhavsagar> :'(
23:57:43 <jle`> aka_: pure and <*> actually come in pairs
23:57:48 <vaibhavsagar> but muh TypeApplications
23:57:49 <jle`> aka_: they are inseparable
23:58:04 <jle`> or well, technically not, but in normal haskell they are, heh
23:58:18 <jle`> aka_: it's like how it doesn't make sense to talk about a Monoid without both mempty and mappend
23:58:28 <jle`> aka_: and the choice of 'mappend' you pick determines what 'mempty' is
23:58:40 <jle`> aka_: for example, for Int's, if you pick mappend = (+), then mempty = 0
23:58:43 <aka_> Just confirmed, both of them are MINIMAL. I really missed it
23:58:49 <jle`> if you pick mappend = (*), then mempty = 1
23:59:10 <jle`> they are a package deal
23:59:29 <jle`> aka_: your two <*>'s actually come with different pure's
