00:00:01 <EvanR> not literally that simple, lock would need to 1. read the set, 2. check for the name, 3. if its there, retry. if its not, write updated set to the tvar
00:00:29 <EvanR> in an atomically
00:01:44 <EvanR> update is outside the atomicallys
00:01:48 <EvanR> STM rox
00:02:20 <jle`> dminuoso: there is only an instance for (a,a,a)
00:02:30 <jle`> and (a,a)
00:02:36 <jle`> there is no (a,b) instance
00:03:21 <jle`> dminuoso: ('a', 1 :: Int) is (Char, Int), so it tries to unify (Char, Int) with (a,a)
00:03:24 <EvanR> dminuoso: and again... update would need to be in a subtask that may crash, and the release is done by the "monitor" or supervisor whether or not it completes
00:03:54 <jle`> ('a', 1) is Num a => (Char, a), so it tries to unify Num a => (Char, a) with (a,a), which only happens when Char ~ a
00:04:03 <jle`> but that can't satisfy the Num constraint
00:04:42 <EvanR> a regular bracket is a good start, then you can think about timeout
00:05:13 * hackage gmpint 0.1.0.6 - GMP integer conversions  https://hackage.haskell.org/package/gmpint-0.1.0.6 (vmchale)
00:05:46 <dminuoso> jle`: Ah I understand. Thank you.
00:06:25 <jle`> no problem!
00:06:55 <EvanR> bracket_ getLock releaseLock (timeout 1000000 launchMissiles)
00:07:55 <dminuoso> If I was a nuclear missile manufacturer, I would hire out of irc.freenode.net #haskell
00:08:05 <dminuoso> Lots of missile experience here.
00:08:15 <vaibhavsagar> only with not launching them though
00:08:43 <EvanR> we suck at mutually assured destruction
00:10:04 <EvanR> dminuoso: what happens in LDAP if two client access the same user at the same time..
00:10:34 <EvanR> what happens if you cross the streams
00:11:21 <dminuoso> EvanR: A virtual sticker "don't cross the streams" shall be put into the MOTD in all our servers.
00:11:57 <dminuoso> EvanR: There is only one system that is allowed to write to the LDAP server, and that's the system Im in the process of replacing.
00:12:18 <EvanR> so, you dont know. like egon :)
00:12:49 <EvanR> youre trying to stop something from happening, but you dont know what
00:15:18 <dminuoso> EvanR: Worst case would be: system 1 fetches `user1`, increments an attribute by one. In parallel system 2 fetches `user1`, increments the same attribute by one. Both write back, race condition complete.
00:16:21 <EvanR> since (+1) is a lattice morphism... and the results are the same... thats an unusual worst case
00:17:23 <EvanR> its unusually ok
00:17:35 <dminuoso> You lost me there.
00:17:47 <EvanR> you described an "eventually consistent" situation
00:17:52 <EvanR> doesnt matter that its a race
00:18:53 <EvanR> oh
00:19:02 <EvanR> they arent sending (+1)
00:19:12 <EvanR> they are both writing (x+1) not x+2
00:19:18 <dminuoso> Right.
00:19:22 <EvanR> nevermind, bad
00:20:48 <av_> Gooooood morning haskell!  The package description of machines says "There is a lot of flexibility when building a machine in choosing between empowering the machine to run its own monadic effects or delegating that responsibility to a custom driver." -- is that an exclusive or, or can I can I have both in the same machine? if so, how? Maybe it's too early in the morning, but I just can't get my head around
00:20:54 <av_> this.
00:21:55 <jle`> machines
00:22:12 <jle`> now that's a name i've not heard in a long time
00:22:18 <EvanR> how do they work
00:22:56 <EvanR> jle`: speaking of which, i looked up "auto" yesterday
00:23:09 <jle`> hehe i suppose i shouldn't be talking
00:23:44 <jle`> that was a fun experiment
00:25:14 <dminuoso> EvanR: The thing is, Im pretty sure that I could do this lockfree. But I don't want this creeping up behind me for some edge case I haven't thought about, or some future change. It's far easier to reason about this if I can pretend I have atomicity.
00:26:50 <dminuoso> Especially here lock contention is not going to be an issue, since parallel updates to a single user should never happen.
00:26:58 <dminuoso> The problem is just the weight of the word "should"
00:27:29 * dminuoso prefers software to always do the right thing, not most of the time
00:28:01 <EvanR> why do you think you dont need locks?
00:29:22 <EvanR> only computer in the universe running only one program that is accessing LDAP, but dont you have many threads
00:32:16 * hackage gmpint 0.1.0.7, fast-arithmetic 0.3.3.7 (vmchale): https://qbin.io/shots-kent
00:34:09 <dminuoso> EvanR: Ah well, in the end I want atomicity because I want to build in some logic to validate records before saving them. Parallel writes could screw that up anyway.
00:34:19 <dminuoso> 09:06            EvanR | bracket_ getLock releaseLock (timeout 1000000 launchMissiles)
00:34:24 <dminuoso> Time to launch some missiles. =)
00:34:33 <dminuoso> After all, I should only launch missiles if no armistice has been signed.
00:35:05 <EvanR> make sure you check if armistice has been signed inside the atomically
00:35:31 <dminuoso> EvanR: Well the body of `atomically` is semi-atomically (up to the fact that only my server has access)
00:35:40 <dminuoso> ertes-w: err not body of atomically. the body of bracket
00:35:49 <dminuoso> And wow! weechat behaves so weird..
00:35:52 <EvanR> i was joking
00:35:57 <dminuoso> Oh. :)
00:39:47 <Axman6> jle`: I was just taking a look at your blog and noticed that you haven't updated your copyright year at the bottom of the page since 2016!
00:44:26 * MarcelineVQ copies it
00:44:51 * Axman6 copies it and waits 68 years before using it
00:45:20 <MarcelineVQ> It's okay, fair use, we're fair people so we can use.
00:45:23 <Axman6> or however long it is that disney's managed to convince the US is a sensible time to wait for Walt to really, truly be dead
00:45:35 <EvanR> don't lie, youre the Axman6 from 68 years in the future who has disposed of the original
00:45:54 <MarcelineVQ> EvanR, if he was that wouldn't be a smart play to point it out
00:46:34 <Axman6> that's Axman62
00:46:41 <MarcelineVQ> do people still eat a lot of corn in your future?
00:47:25 <MarcelineVQ> just don't ask about Axman7, there used to be an Axman9, all I'm gonna say
00:48:26 <EvanR> coming this summer, Ayman and Azman
00:49:01 <Axman6> "... because map Axman [7,8,9] ..."
00:49:40 <Axman6> back in the day we used have `map (succ|pred) nick day`
00:49:50 <Axman6> which is why my backup nick is Bynbo7
00:50:06 <MarcelineVQ> Blimblor33
00:50:10 <Axman6> (it's registered so y'all stay off)
00:50:33 <Axman6> > text $ map pred "MarcelineVQ"
00:50:36 <lambdabot>  L`qbdkhmdUP
00:50:43 <Axman6> > text $ map succ "MarcelineVQ"
00:50:47 <lambdabot>  NbsdfmjofWR
00:50:57 <Axman6> sounds like a fun distro
00:51:20 * av_ will come back in 68 years for an answer to his question
00:51:24 <Ariakenom> Is updating copyright years something you should actually do though? Is there some source?
00:51:48 <Axman6> ¯\_(ツ)_/¯
00:52:38 <Axman6> I was a patent examiner, not a copyright attorney =)
00:53:38 <EvanR> av_: i havent met many people who could explain machines
00:54:15 <Axman6> yeah machines is pretty crazy (in the most things Ed writes is crazy but is actually really good kind of way)
00:54:36 <Axman6> you might want to have a look at streaming, I found it mugh easier to follow (though still not trivial)
00:55:00 <av_> oh dear, and I thought I was good at mathematics
00:55:20 <vaibhavsagar> > text $ map succ "vaibhavsagar"
00:55:22 <lambdabot>  wbjcibwtbhbs
00:55:32 <vaibhavsagar> > text $ map pred "vaibhavsagar"
00:55:35 <lambdabot>  u`hag`ur`f`q
00:55:38 <vaibhavsagar> nice
00:55:43 <MarcelineVQ> welp
00:55:52 <vaibhavsagar> you people can have these, I don't want them
00:55:58 <ventonegro> Should be good for encrypting keysd
00:56:16 <EvanR> rot1
00:56:27 <vaibhavsagar> > text $ map pred "hunter2"
00:56:30 <lambdabot>  gtmsdq1
00:56:36 <vaibhavsagar> cool
00:56:49 <vaibhavsagar> time to change my password on all the socials
00:56:52 <EvanR> better than rot13, you can use more than once without defeating itself
00:57:15 <MarcelineVQ> my pass is 148 chars long, in a scant few decades this will be enough of a clue for some artifical agent to guess it
00:57:47 <vaibhavsagar> it's a tweet+handle?
00:57:59 <vaibhavsagar> 140 char tweet, 8 char handle
00:58:02 * EvanR does a DDOS by claiming to have it be 2047 chars long
00:58:19 <Axman6> vaibhavsagar: ha, "u`hag`ur`f`q" is great
00:58:30 <MarcelineVQ> you boys are full of beans tonight
00:58:38 <vaibhavsagar> :D
00:58:39 <Axman6> it's like shorthand for 14 year old speak
01:00:03 <vaibhavsagar> > text $ map (pred . pred) "vaibhavsagar"
01:00:06 <lambdabot>  t_g`f_tq_e_p
01:00:15 <vaibhavsagar> I like it
01:00:17 <dminuoso> Öt pred
01:00:20 <dminuoso> :t pred
01:00:21 <lambdabot> Enum a => a -> a
01:01:54 <vaibhavsagar> :t text
01:01:55 <lambdabot> String -> Doc
01:02:16 <MarcelineVQ> > text $ map (chr . (`mod` 122) . join (*) . ord . pred) "vaibhavsagar"
01:02:18 <lambdabot>  BPuB@B"BQ
01:02:46 <vaibhavsagar> that is an interesting arrangment of ASCII
01:03:07 <EvanR> suspicious
01:03:15 <vaibhavsagar> :t join (*)
01:03:17 <lambdabot> Num a => a -> a
01:03:42 <vaibhavsagar> > join (*) 5
01:03:46 <lambdabot>  25
01:04:00 <EvanR> wat
01:04:03 <MarcelineVQ> it's (^2) for cool kids
01:04:22 <Axman6> > join (++) "Hello! "
01:04:25 <lambdabot>  "Hello! Hello! "
01:04:40 <EvanR> oh function monad
01:05:23 <vaibhavsagar> aka a really fancy SKI calculus interpreter
01:05:43 <vaibhavsagar> that's the applicative instance though, no idea what the monad instance signifies
01:07:26 <EvanR> (r -> (r -> a)) -> r -> a can really only do one thing
01:08:03 <vaibhavsagar> @djinn (r -> (r -> a)) -> r -> a
01:08:04 <lambdabot> f a b = a b b
01:08:47 <EvanR> :t (\a b = a b b)
01:08:49 <lambdabot> error:
01:08:49 <lambdabot>     parse error on input ‘=’
01:08:49 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
01:08:52 <EvanR> :t (\a b -> a b b)
01:08:53 <lambdabot> (t1 -> t1 -> t2) -> t1 -> t2
01:09:02 * EvanR goin the hell to sleep
01:11:19 <av_> EvanR: see, it's \EvanR -> sleep, not \EvanR = sleep :)
01:14:16 * hackage servant 0.13.0.1, servant-client-core 0.13.0.1, servant-server 0.13.0.1 (phadej): https://qbin.io/remove-ex
01:17:13 * hackage servant-client 0.13.0.1 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.13.0.1 (phadej)
01:28:24 <zipper> Hey, I'm having touble with haskell-stack-ghc in emacs to get hs working with flyckeck.
01:28:32 <zipper> "Suspicious state from syntax checker haskell-stack-ghc: Flycheck checker haskell-stack-ghc...
01:28:34 <zipper> "
01:28:59 <zipper> From reading around this is caused by having conflicting versions of ghc
01:29:13 <dminuoso> How is Zipper different from lenses? Both seem to be about splitting data into "whats in focus" and "whats out of focus"
01:29:22 <zipper> is there something else because I've tried uninstalling all  conflicting versions
01:31:15 <Darwin226> Here's a puzzle. I want to write something like `newtype RepWrapper a = RepWrapper (Rep a)` and then write a `Generic (RepWrapper a)` instance that just uses the inner Rep
01:31:28 <Darwin226> The problem is the extra type parameter on Rep
01:32:00 <Darwin226> I can make it either universal or existential in the RepWrapper type which lets me implement either `from`, or `to` functions
01:32:04 <Darwin226> but I can't do both
01:32:21 <Darwin226> Any ideas how to solve this?
01:45:14 <quicksilver> dminuoso: lenses are a more thoroughly developed concept
01:45:26 <quicksilver> they are composable 'zippler-like' things
01:46:22 <quicksilver> it's the fact that they are composable and they have a big library of interesting functions which work polymorphically over lense (and other optics) which makes them useful
01:46:56 <merijn> I don't think lenses are zipper-like, tbh
01:47:08 <merijn> They're more like really complicated versions of Traversable
01:49:30 <phadej> don't zippers let you "move around" the structure, that's not possible with lenses - somewhat different "domain"
01:49:51 <dminuoso> phadej: well Traversal can "move around"
01:50:19 <merijn> dminuoso: Not really, though
01:50:31 <dminuoso> merijn: lack of direction?
01:51:06 <merijn> dminuoso: Well, in what sense can a Traversal move around according to you?
01:52:09 <alp> I think the "zipper-like" aspect was more about how you can "focus" on some part of a structure.
01:52:13 <dminuoso> merijn: In the sense that a Traversal focuses on each smaller part of the entire thing
01:52:42 <merijn> dminuoso: You can't do something like "shift focus from current point to it's neighbour" with optics
01:52:42 <dminuoso> alp: more than that. I mean both lenses and zippers have the notion of "splitting into the smaller thing, and the larger thing with a hole"
01:55:02 <cocreature> dminuoso: the useful part about zippers is that you can move the focus around
01:55:14 <quicksilver> right, what everyone said
01:55:16 <cocreature> e.g. you can move around in a tree
01:55:34 <quicksilver> but they do share the notion of accessing a part and letting you modify it
01:55:50 <quicksilver> also https://github.com/ekmett/zippers
01:56:04 <dminuoso> Maybe it's just the comonadicness that Im thinking about
01:57:00 <quicksilver> what I was trying to say is that lenses are something algebraic - they are actually composable and operable
01:57:16 <quicksilver> whereas zippers are - generally - a notion from papers without a clear algebra
01:57:48 <quicksilver> when I used zippers a few years ago I ended up hand rolling them becuase there wasn't any sensible way to do them generically
01:58:01 <quicksilver> and certainly no sensible way to compose them generically
02:02:42 <dysfun> you think it's bad in haskell, you should see clojure's zippers :/
02:08:13 * hackage tomlcheck 0.1.0.23 - Command-line tool to check syntax of TOML files  https://hackage.haskell.org/package/tomlcheck-0.1.0.23 (vmchale)
02:10:43 <merijn> Anyone know what the correct procedure for nuking the new-build store is to not break everything?
02:14:48 <vaibhavsagar> merijn: what are you worried about breaking?
02:15:08 <merijn> vaibhavsagar: The package db thinking things are installed which aren't in the store because I nuked it
02:15:15 <vaibhavsagar> all the dependencies are in ~/.cabal/store anyway AFAIK
02:15:25 <cocreature> so far nuking .cabal/store has worked for me
02:15:32 <cocreature> it’s just really annoying to have to do that
02:15:46 <merijn> cocreature: Well, I need to get rid of a lot of junk and old versions
02:16:09 <merijn> cocreature: FYI I saw someone who had a beta script which would GC the store, only keeping dependencies for specified new-build projects
02:16:51 <cocreature> that doesn’t help you if you managed to break your store :)
02:17:02 <merijn> cocreature: True
02:18:34 <merijn> hmmm
02:18:45 <merijn> My debug prints aren't happening...suspicious...
02:21:12 * hackage timestamp 0.1 - Space-efficient Unix timestamp and utilities  https://hackage.haskell.org/package/timestamp-0.1 (OShev)
02:21:52 <Unhammer> Hi, I'm trying to use doctest-discover, but getting some errors because my package depends on both zip-conduit and xlsx, which in turn depends on zip-archive, and zip-archive and zip-conduit both define Codec.Archive.Zip.
02:22:05 <Unhammer> The main executable compiles and runs fine
02:22:10 <Unhammer> but not the testsuite
02:22:18 <merijn> Unhammer: You'll have to use packageimports to disambiguate
02:22:32 <merijn> Unhammer: Also, yell at one or both of the maintainers for fucking things up
02:26:17 <Unhammer> oh, never knew about PackageImports, that's at least good that there's an escape hatch for situations like this :)
02:28:06 <Unhammer> but of course it wasn't that simple …
02:28:15 <Unhammer> it seems to be getting past that step, but now I'm getting lots of errors that look like conduit got installed twice with different hashes: http://termbin.com/ng5hs
02:28:19 <clamchowder> A basic question: what is the right way to write the following program: read a number from stdin, print the cumulative sum to stdout, then wait for the next number from stdin?
02:28:47 <lemmih> clamchowder: What have you tried so far?
02:28:59 <clamchowder> for example: stdin: 3, stdout: 3, stdin: 2, stdout: 5 and so on
02:29:44 <vaibhavsagar> clamchowder: store the value so far in a variable, read an input, add it to the variable, print out the value, and loop
02:29:52 <merijn> Unhammer: Are you using cabal-install? If yes, are you using sandboxes or new-build?
02:30:12 <clamchowder> lemmih: I know given a list of numbers i can just do an mapAccumL but not sure how to do it with IO
02:30:34 <Unhammer> oh, but think I see what's going on; after stack 1.6 I should've deleted .stack-work since it now puts packages from my weird configuration in the ~/.stack
02:30:44 <clamchowder> lemmih: i.e. how to have a state changeable with io
02:31:14 <cocreature> clamchowder: write your code as a recursive function that has the current value as an argument
02:31:23 <lemmih> clamchowder: Imagine something like: let fn n = print n >> fn (n+1) in fn 0
02:31:34 <adjofun> clamchowder: did you look at foldM?
02:32:26 <clamchowder> vaibhavsagar: vaibhavsagar: i know how to do what you say imperatively like in python but not in haskell
02:33:19 <cocreature> clamchowder: you can translate most loops that modify local variables into recursive functions that take the variables that are being modified as arguments
02:33:44 <adjofun> > foldM (\a b -> let x = a+b; print x; return x) 0 [3,2,1]
02:33:47 <lambdabot>  <hint>:1:36: error: parse error on input ‘;’
02:33:51 <adjofun> =(
02:34:34 <Taneb> cocreature: what exceptions to this are there? Just ones that use arrays?
02:35:03 <cocreature> Taneb: as long as you ignore performance it even works for arrays
02:35:23 <Taneb> Yeah, there's that log-n overhead
02:35:29 <clamchowder> cocreature: i see what you mean. i need to try it out
02:37:43 * hackage timestamp 0.1.0.1 - Space-efficient Unix timestamp and utilities  https://hackage.haskell.org/package/timestamp-0.1.0.1 (OShev)
02:38:42 <vaibhavsagar> @let cumulative = let {loop v = do {x <- read <$> getLine; let {v' = v + x}; print v'; loop v';}} in loop 0
02:38:45 <lambdabot>  Defined.
02:39:04 <vaibhavsagar> curly brace syntax is the worst
02:39:04 <adjofun> clamchowder: http://lpaste.net/364678
02:39:36 <xpika1> Is it possible to apply a setter on a prism that returns an error if nothing applies
02:39:41 <clamchowder> cocreature: yeah that works. Thanks.
02:41:48 <clamchowder> adjofun: thank, but your paste does not seem to read from stdin
02:43:15 <cocreature> xpika1: what do you mean by “apply a setter on a prism”? using the prism as a setter?
02:43:49 <WhatisRT> hi! is there some way to build a library with cabal where I can exactly specify the name of the library I want to build? The library exposes an ffi which I want to manually link later, and cabal appends lots of junk to the name of the library
02:43:56 <clamchowder> vaibhavsagar: thanks. that's how i did it too
02:45:32 <WhatisRT> I would also like to drop some other stuff in the name, but that is secondary
02:47:40 <merijn> WhatisRT: Just...rename the resulting library file?
02:47:43 * hackage swagger2 2.2.2 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-2.2.2 (phadej)
02:48:49 <WhatisRT> merijn: I want to do that automatically
02:49:15 <WhatisRT> or is the appended stuff predictable over every build on every system?
02:50:55 <adjofun> clamchowder: http://lpaste.net/364679
02:59:01 <clamchowder> adjofun: nice - i didn't know you can do `lines stdin`. Thanks
02:59:42 <adjofun> clamchowder: you are welcome =)
03:12:15 <marvin3> read <$> getLine is readLn
03:23:04 <maerwald> will a dependency like 'unix' make sure that my library doesn't compile on windows=
03:23:13 <maerwald> or is there a way to force it off on windows
03:23:14 <ditadi> Hey guys, I'm using Text.Pretty.Simple to color my ghci outputs.  However, this only shows part of large record.  Is there a way to scroll up in ghci or to make it render entire record in such a way that I can scroll up with my terminal emulator?
03:23:25 <maerwald> like make the project fail to compile
03:26:51 <lyxia> maerwald: if os(windows)   buildable: False   (which unix does too)
03:27:06 <maerwald> ah
03:40:43 * hackage prologue 3.1.4 - Better, more general Prelude exporting common utilities.  https://hackage.haskell.org/package/prologue-3.1.4 (danilo2)
03:41:11 <maerwald> mh, building ghc-7.10 wth 8.0.2 seems problematic
03:45:18 <Unhammer> I'm still getting http://termbin.com/9481 even after a "rm -rf .stack-work". "stack build" still installs conduit in .stack-work (and successfully builds), then "stack test" fails because (the same version of) conduit is installed both in .stack-work and in ~/.stack/snapshots. How does "stack build" manage this fine, while "stack test" doesn't? Is it because doctest runs rungch?
03:46:13 * hackage ngx-export 1.4.1 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-1.4.1 (lyokha)
03:47:24 <cocreature> Unhammer: how have you set up doctests?
03:48:04 <Unhammer> http://termbin.com/2yq0
03:48:25 <cocreature> Unhammer: consider using the cabal-doctest package
03:48:26 <maerwald> ghc fails to build, great http://lpaste.net/2770215654941261824
03:50:50 <Unhammer> does that require a recentish cabal version?
03:50:52 <Unhammer> cabal: Ignoring unknown section type:
03:50:54 <Unhammer> custom-setup
03:51:15 <cocreature> iirc custom-setup was added in 1.24 which is really not that recent :)
03:51:42 <cocreature> and it’s a warning not an error, so it’ll probably work even for older versions
04:04:29 <Unhammer> welp I managed to "fix" it for now by simply doing
04:04:31 <Unhammer> stack exec ghc-pkg -- unregister --package-db=$HOME/.stack/snapshots/blah/pkgdb counduit
04:04:33 <Unhammer> (and similarly with its dependents)
04:12:56 <cocreature> Unhammer: cabal-doctest didn’t help?
04:17:07 <Unhammer> the "Simple example" said you needed custom-setup, so I gave up …
04:18:38 <cocreature> as I said, it’s a warning not an error
04:18:44 <Unhammer> if we're gonna require newer cabals, I guess we'll upgrade all the way to one that includes https://github.com/haskell/cabal/issues/2327
04:18:59 <Unhammer> ok, guess I should try it anyway …
04:19:03 <cocreature> there is a big difference between 1.24 and 2.2
04:19:47 <Unhammer> but where would I then specify that setup requires cabal-doctest?
04:20:07 <Unhammer> I'm guessing cabal-doctest would become a hard requirement of the whole lib
04:20:20 <Unhammer> if it's needed for Setup.hs
04:20:26 <ertes-w> helo
04:20:42 * hackage aeson-extra 0.4.1.1 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.4.1.1 (phadej)
04:24:16 * hackage servant-swagger-ui-core 0.3, servant-swagger-ui 0.3.0.3.13.2, servant-swagger-ui-redoc 0.3.0.1.21.2, servant-swagger-ui-jensoleg 0.3 (phadej)
04:31:13 * hackage path-extra 0.1.2 - Some extensions to Chris Done's path library, for use with urlpath and attoparsec-uri.  https://hackage.haskell.org/package/path-extra-0.1.2 (athanclark)
04:54:05 <reactormonk> Anyone got some good tutorial on hlists in haskell? I already know how they work in Scala, but I don't know how to properly write the functional dependencies.
04:58:43 * hackage urlpath 8.2.0 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-8.2.0 (athanclark)
05:05:32 <lts> Unhammer: I looked into the approach you pointed out previously of using runST to do modifications in the leaves of a B+Tree ; so did you mean that I'll use runST to traverse till the head of the linked list (of leaves) and propogate the changes ?
05:07:38 <Unhammer> meant using an "imperative" method inside ST, then returning an updated tree into pure code
05:08:19 <lts> oic
05:08:20 <Unhammer> i can't remember what your problem was exactly, but something like inserting a node in between two others in a linked list?
05:08:30 <lts> yes
05:08:32 <Unhammer> so you'd have to change the parent pointer
05:09:33 <lts> yes, so currently I'm not using pointers, simply passing the entire data type: https://github.com/shivansh/goDB/blob/master/src/BPlusTree.hs#L17
05:15:23 <Unhammer> well, traversing to the top each time will be slow if you have to do it a lot :) especially on building the initial tree from a list or something, I'd say it makes sense to do it with an STArray, then perhaps return the frozen/pure tree
05:17:43 * hackage markup 4.1.0 - Abstraction for HTML-embedded content  https://hackage.haskell.org/package/markup-4.1.0 (athanclark)
05:21:21 <adjofun> reactormonk: I guess this paper can serve as a tutorial: http://okmij.org/ftp/Haskell/HList-ext.pdf
05:31:11 <maerwald> ghc-7.10 fails to build with 7.8.4: http://lpaste.net/8944530987493097472
05:31:16 <maerwald> so how are you supposed to build it
05:31:34 <Psybur> 7.8.3? :D
05:31:37 <ertes-w> lts, Unhammer: the 'vector' library is almost always better for arrays
05:33:11 <Unhammer> oh you can use that in ST too, nice
05:35:44 <reactormonk> adjofun, oi.
05:42:03 <atdmpz> /part
05:42:06 <atdmpz>  
05:52:43 * hackage eternity-timestamped 0.3 - Automatic timestamping for Eternity  https://hackage.haskell.org/package/eternity-timestamped-0.3 (OShev)
05:58:43 * hackage product-isomorphic 0.0.3.2 - Weaken applicative functor on products  https://hackage.haskell.org/package/product-isomorphic-0.0.3.2 (KeiHibino)
06:06:21 <nh> whatever happened to the monad.reader
06:12:34 <veverak> hi folks, I have list of strings, any tip how to nicely print it with format  "order -> string \n"  ?
06:12:53 <veverak> ["a","b","c"] to " 1 -> a \n 2 -> b \n 3 -> c \n"
06:13:18 <lemmih> veverak: Do you know about list comprehensions?
06:13:51 <lemmih> > zip [1..] ["a","b","c"]
06:13:53 <veverak> not much
06:13:54 <lambdabot>  [(1,"a"),(2,"b"),(3,"c")]
06:13:55 <veverak> oh, I see
06:14:05 <lemmih> > unlines ["line 1", "line 2", "line 3"]
06:14:08 <lambdabot>  "line 1\nline 2\nline 3\n"
06:15:45 <maerwald> > ["line 1", "line 2", "line 3"] >>= (++ "\n")
06:15:48 <lambdabot>  "line 1\nline 2\nline 3\n"
06:16:03 <maerwald> so just extend that function to whatever you want to print it nicely
06:16:06 <veverak> putStrLn $ unlines $ map (\(x,y) -> show x ++ " -> " ++ show y) $ zip [1..]( map file cmds )
06:16:19 <veverak> hmm
06:16:32 <maerwald> don't use unlines :>
06:16:55 <veverak> I am not sure unlines would make it prettier
06:17:05 <maerwald> use the monad instance
06:17:27 <maerwald> and don't use list comprehension (also use monad instance) :P
06:17:43 * hackage influxdb 1.5.2 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-1.5.2 (MitsutoshiAoe)
06:18:00 <lemmih> mapM_ putStrLn [ show x ++ " -> " ++ show (file y) | (x,y) <- zip [1..] cmds ]
06:18:59 <lemmih> veverak: There are many ways of writing the same things. They're all equally correct. Pick the style you like the best.
06:19:53 <maerwald> pick the simplest style, not the one you like best
06:20:11 <veverak> I am trying to explore various styles
06:20:14 <veverak> to increase knowledge
06:20:19 <veverak> to be able to pick the best
06:20:20 <veverak> :)
06:22:32 <maerwald> well, depends if you are just writing for the sake of enjoying writing or for the sake of your code being readable
06:22:39 <maerwald> those are 2 conflicting things
06:24:05 <tdammers> not necessarily
06:24:13 <tdammers> I, for one, enjoy writing maintainable code
06:24:56 <veverak> maerwald: code being readable
06:25:26 <veverak> I believe only for that to happend is to try various methods in projects that are for fun
06:25:31 <veverak> so you got experience with them
06:25:40 <ayako> :t zipWithM_
06:25:42 <lambdabot> Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()
06:25:47 <maerwald> tdammers: most people don't
06:26:00 <maerwald> writing maintainable code is an art and can be very cumbersome
06:27:06 <maerwald> and you need a lot of feedback
06:27:11 <tdammers> well, most of the code I write I intend to keep working on for more than a day, so writing messy code would be an idiotic thing to do
06:27:35 <maerwald> *you* intend to keep working ;)
06:27:38 <tdammers> yes
06:27:40 <maerwald> so you write for yourself
06:27:47 <maerwald> you're the maintainer
06:27:49 <tdammers> I consider my future self just another collaborator
06:27:54 <maerwald> ah
06:28:10 <tdammers> because in practice, it tends to boil down to exactly that
06:28:10 <maerwald> I want to read your code now :P
06:28:23 <tdammers> :D
06:30:21 <sm> tdammers: how much documentation (haddocks..) do you write ?
06:30:40 <maerwald> I expect him to write lhs
06:30:49 <maerwald> :D
06:30:57 <sm> comments/haddocks/READMEs/lhs/doctests..
06:31:19 <maerwald> concept papers, architecture backlog, ...
06:31:58 <sm> well, I mean to ask about in-or-near-code docs particularly
06:32:25 <sm> I haddock almost everything, but of course sometimes I see code that's blissfully free of docs and I'm.. envious
06:32:36 <Taneb> I know what it's like to try to understand code I wrote yesterday and I don't like it
06:32:40 <maerwald> meeting logs, presentation videos, google talks
06:32:45 <Taneb> I need to get better at writing maintainable code by habit
06:33:14 <maerwald> Taneb: rm -rf /usr/bin/pointfree -- start with that
06:33:59 <zincy> How do I make the following an instance of the Eq typeclass ``` newtype Client = Client (Text, WS.Connection)```?
06:34:17 <zincy> I tried  newtype ```instance Eq Client where   (Client (x, _)) == (Client (y, _) = x == y```
06:35:09 <lemmih> zincy: Didn't that work?
06:36:27 <zincy> I get ```parse error on input '=' perhaps you need a let in a do block
06:36:55 <ayako> you missed a paren
06:37:50 <zincy> Thanks! Was indeed the parenthesis.
06:38:12 <dminuoso> That looks like a truly unlawful implementation.
06:38:23 <zincy> What would be the simplest way of encoding a value of that type to a Json
06:38:45 <zincy> I am wondering if there is a way of auto deriving the toJSON typeclass instance provided by Aeson
06:38:47 <Taneb> maerwald: being able to translate code into pointless style is an important skill, almost as important as knowing when not to
06:39:04 <lemmih> zincy: toJSON (Client (x,_)) = toJSON x
06:39:12 <dminuoso> zincy: What are you asking. Why not use the generic implementation from Aeson?
06:39:24 <maerwald> I don't see how that is a skill, either it makes sense naturally or it's just golfing
06:39:39 <maerwald> golfing is not an important skill
06:39:46 <merijn> dminuoso: Equality doesn't have laws, though, except maybe the implied commutativity, reflexivity and transitivity
06:40:01 <zincy> dminuoso - yes I tried to do this however my attempt failed
06:40:04 <merijn> dminuoso: And that one has all of those
06:40:10 <dminuoso> merijn: I was thinking about substitution.
06:40:34 <dminuoso> merijn: if `g a /= g b` while `a == b` then this is weird.
06:43:50 <zincy> What does the first keyword do here - is toJSON a type provided by some library and this is pattern matching on its type constructor?  ```toJSON (Client (x,_)) = toJSON x```
06:44:06 <zincy> Sorry value constructor I mean
06:44:10 <dminuoso> *data constructor
06:44:28 <zincy> Is value constructor == data constructor
06:44:53 <lemmih> zincy: toJSON is part of the aeson library.
06:45:23 <dminuoso> zincy: We have data constructors and type constructors. Formally we have no value constructors, though if someone uses that terminology they probably mean `data constructors`
06:52:18 <merijn> dminuoso: I use value constructors to contrast with type constructors sometimes
07:23:34 <zincy> Has anyone used Miso here before? Getting an error I dont understand related to websockets.
07:30:22 <cocreature> zincy: I’ve used it before but either way you are going to get a better answer if you just ask your question directly :)
07:40:54 <exarkun> how do I handle errors from Network.Socket (eg from socket, connect)?
07:41:39 <zincy> Thanks cocreature! Managed to resolve it myself :)
07:42:44 <maerwald> someone forked my library!
07:42:47 * maerwald gets excited
07:43:04 <maerwald> soon there will be lots of money
07:43:36 <zincy> What is the idiomatic way of passing data between server <-> client using websockets is it through the use of JSON?
07:43:58 <Ariakenom> exarkun, you catch the exception?
07:44:23 <chisui> zincy: depends on your usecase but generally yes.
07:44:29 <exarkun> Where is the documentation for what exceptions result from socket errors?
07:44:46 <exarkun> not on https://hackage.haskell.org/package/network-2.6.3.5/docs/Network-Socket.html as far as I can tell
07:44:47 <zincy> Thanks chisui!
07:45:39 <chisui> zincy: if you want to minimize the payload you can use something like protocol buffers
07:45:47 <chisui> https://developers.google.com/protocol-buffers/
07:50:24 <ertes-w> exarkun: that's an unfortunate shortcoming of the documentation…  the network library throws IOException
07:51:32 <ertes-w> exarkun: the way to distinguish certain errors from others is neither straightforward nor portable…  you need to extract the errno information from the exception, for which you need to import a GHC module to access IOException's constructor (i don't remember which one)
07:52:27 <ertes-w> exarkun: the 'unix' module might provide more portable access
07:52:43 <ertes-w> s/module/package/
07:53:07 <ertes-w> ("more portable" in that it works for most systems that aren't windows)
07:53:30 <exarkun> Yea.  I can deal with the errnos, just unclear about the Haskell representation.  `IOException` sounds like the answer, I'll try that, thanks.
07:54:11 <leah2> around 2009 i could open a .hs file in emacs and just load it into a ghci, without defining a project or anything. is that still possible, and how?
07:55:13 * hackage path-extra 0.2.0 - URLs without host information  https://hackage.haskell.org/package/path-extra-0.2.0 (athanclark)
07:56:45 <byorgey> leah2: it is still possible.  I recommend installing intero.  If you don't have a project defined it just uses the global stack workspace or something like that.
07:56:54 <leah2> ok, i'll try that
07:57:10 <leah2> if it uses 'stack ghci' or something that would be fine
07:57:21 <byorgey> yes, that's what it does
07:57:25 <byorgey> I often open .hs files that aren't part of a project (e.g. solving competitive programming problems)
07:57:46 <leah2> yes, i'm teaching a course and we just have a bunch of snippets at first
07:58:03 <jackcrfs> :byorgey  just curious, a Haskell competition?
07:58:34 <byorgey> jackcrfs: no, just stuff on https://open.kattis.com/
07:58:49 <byorgey> Haskell is one of the many languages it accepts.
07:59:20 <jackcrfs> i am on my second day of learning H - so u feel Haskell gives u advantage?
08:00:21 <byorgey> jackcrfs: for many problems, especially the easier ones, using Haskell is an advantage since you can express the solution as a concise pipeline of functions transforming the input into the output
08:00:56 <byorgey> but for more difficult problems that require algorithms and data structures that are typically expressed with mutation, I find it harder to figure out how to use Haskell effectively
08:02:07 <jackcrfs> nice to hear, on my second day I am impressed by lazy eval on lists and stuff, v elegant; but my eyes started watering when Text can be strict or lazy or not, and I couldnt serialize a dict of strings because of some type issues
08:03:46 <Ariakenom> Oh kattis. I've done some stuff there. Probably a Haskell or 2
08:03:46 <jackcrfs> i appreciate Haskell forcing me to think hard, eg io String is different from String because one is immutable, and mathematically and for compiler they mean totally different things
08:04:16 <jackcrfs> but that learning curve is steep
08:05:21 <leah2> hmm, intero mode locks up here oO
08:05:31 <jackcrfs> i plan to stick to this chat room and all the tutorials i can find... but it is fun like no other language
08:05:32 <adjofun> jackcrfs: it pays off =)
08:05:35 <leah2> ah no, it extracts another ghc -.-
08:11:16 <ertes-w> jackcrfs: IO is one of my favourite features of haskell, and i strongly recommend that you learn how to use it properly
08:11:18 <ertes-w> @where iotut
08:11:19 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
08:11:24 <ertes-w> jackcrfs: ^ here is a good starting point
08:11:36 <jackcrfs> thanks! grateful!
08:12:43 * hackage primitive-checked 0.6.3.0 - primitive functions with bounds-checking  https://hackage.haskell.org/package/primitive-checked-0.6.3.0 (andrewthad)
08:14:08 <jchia_1> Question about system architecture. So, I have higher-level functions calling lower-level functions. There are many layers. As I descend the layers, higher-level config param values and things read from external files are translated into lower-level params, yet lower-level functions may still need certain higher-level params.
08:14:09 <jchia_1> Sometimes the param translation is done by reaching into nested records. Sometimes it's done by calling pure functions. Sometimes it's a combination of the above two.
08:14:14 <jchia_1> One problem that often shows up is that I often end up with a function that takes many arguments. If not, the function may involve tedious code reaching multiple levels into a record to get a param value it needs to use.
08:14:19 <jchia_1> What are some techniques to simplify this type of code? I feel like there are too many thin wires connecting my layers causing a lot of cognitive load.
08:16:13 * hackage heap 1.0.4 - Heaps in Haskell  https://hackage.haskell.org/package/heap-1.0.4 (eberlm)
08:16:31 <adjofun> jchia_1: sounds like you need a ReaderT monad, and some lenses =)
08:17:06 <leah2> i think i just want inf-haskell
08:17:34 <jchia_1> adjofun: That's what I suspected, but I think at different layers I need ReaderT with different environment. Also each environment type can be thought of to contain multiple params. How do I express these two things?
08:17:52 <ertes-w> jchia_1: one technique i use is to abstract over representation types
08:18:19 <ertes-w> jchia_1: data Measurements a = Meansurements { mMin :: a, mAvg :: a, mMax :: a }
08:18:45 <ertes-w> this is a Functor and Traversable, so it's easy to convert, say, Measurements Text -> Measurements Double
08:18:46 <ertes-w> etc.
08:19:18 <exarkun> Why does `-threaded` make a difference to the number of open file descriptors I can have in a single-threaded program?
08:19:45 <ertes-w> jchia_1: this primarily calls for abstraction, not ReaderT – in fact you might find yourself writing much more verbose code with ReaderT
08:20:15 <ertes-w> exarkun: the threaded RTS uses threads internally as well as providing real threading for haskell threads
08:20:39 <ertes-w> exarkun: for example if you use System.Timeout, there will be a separate timeout thread, and you will have threaded GC as well
08:20:43 * hackage urlpath 9.0.0 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-9.0.0 (athanclark)
08:21:42 <exarkun> So ... the non-threaded RTS uses select() (limited to max fd 1024) to implement I/O operations (even if there is no multiplexing) and the threaded RTS ... just blocks (no max fd)?
08:24:00 <ertes-w> exarkun: no, the threaded RTS still uses multiplexing (more likely epoll/kqueue than select()), but you should expect it to use a bunch of extra FDs due to the way it's designed…  i don't know the details, but a -threaded program usually has more than one thread even if you don't use -N or fork any yourself
08:24:10 <ertes-w> exarkun: this is especially true if you use the FFI
08:26:13 * hackage b9 0.5.44 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.44 (SvenHeyll)
08:26:28 <exarkun> I'm not worried about extra FDs.  I just ran into "file descriptor 1024 out of range for select (0--1024). Recompile with -threaded to work around this." (in a program that certainly tries to use fd>=1024) and I want to understand what the runtime is doing.
08:26:37 <ertes-w> exarkun: this is why with -threaded you can use System.Timeout even with FFI functions…  without -threaded timeouts can only be handled when the foreign function returns control to GHC's RTS
08:26:49 <ertes-w> oh
08:27:04 <ertes-w> ok, sorry, i misinterpreted your question then
08:27:13 <exarkun> sorry I should have included that in the question probably.
08:28:39 <ertes-w> are there any kernel interfaces that can't handle FDs ≥ 1024?
08:28:48 <byorgey> leah2: yeah, intero takes a little while to boot up the first time, but it's fast after that
08:29:08 <leah2> it doesnt seem to like working outside a stack project
08:29:09 <dminuoso> What mechanism causes a top level unsafePerformIO to be executed at the right time?
08:29:10 <exarkun> ertes-w: well, select(), of course :)
08:29:21 <leah2> i think good old inf-haskell is fine for my purposes
08:29:27 <byorgey> ok.
08:29:54 <exarkun> it seems like single-threaded RTS didn't get updated to epoll/kqueue/etc when the threaded RTS did, maybe?
08:29:55 <ertes-w> exarkun: does the non-threaded one actually use it?  i know the threaded one doesn't
08:30:02 <ertes-w> yeah, sounds like it
08:30:19 <ertes-w> well, one more reason not to use the non-threaded one =)
08:30:20 <dminuoso> Or is it actually the first time I use a top level binding that it's unsafePerformIO'd?
08:30:21 <exarkun> so fundamentally threaded and non-threaded RTS are doing the same thing here, they are just incidentally using different syscalls for readiness notification
08:30:26 <exarkun> indeed
08:30:43 <ertes-w> dminuoso: as soon as you evaluate it
08:30:47 <exarkun> thanks
08:31:10 <ertes-w> exarkun: not quite…  the threaded one behaves differently
08:31:34 <dminuoso> ertes-w: Ah. Does GHC guarantee it won't re-evaluate at all costs?
08:31:35 <exarkun> ertes-w: in general, yea.  but I mean in my particular case, where I am not using any threading in the application?
08:32:14 <ertes-w> exarkun: as i said (timeout c) behaves differently depending on which RTS you pick, and there are no haskell threads involved (GHC has a built-in timer system)
08:33:18 <ertes-w> dminuoso: not by any specification, but NOINLINE is a de-facto standard approach, so it's unlikely that the GHC devs will mess with that
08:33:56 <ertes-w> dminuoso: there are a *lot* of caveats though…  be sure to read the entirety of the System.IO.Unsafe module
08:34:02 <ertes-w> (the docs, not the source)
08:34:28 <exarkun> ertes-w: okay thanks
08:40:43 * hackage markup 4.2.0 - Abstraction for HTML-embedded content  https://hackage.haskell.org/package/markup-4.2.0 (athanclark)
08:41:12 * hackage plural 0.0.2 - Pluralize  https://hackage.haskell.org/package/plural-0.0.2 (fresheyeball)
08:41:55 <zincy> What is a JSVal type actually representing within the jsaddle library for GHCJS?
08:42:29 <zincy> Or more specifically why is such a type necessary?
08:45:36 <Whimwham> hi
08:46:13 <Whimwham> hellll900000099
08:47:30 <Whimwham> anyoneeeeee
08:48:26 <electrocat> hello?
08:48:27 <Whimwham> from where r u people???
08:48:45 <hexagoxel> zincy: it is a reference to a foreign (JS) value. how would you avoid that? marshal every value? seems inefficient.
08:49:30 <zincy> What do you mean by marshal?
08:49:33 <Whimwham> i use turmux how to scroll up in irssi
08:50:12 <electrocat> page up
08:51:12 <Whimwham> lol cant previous command is shown just like arrow key in comp.
08:52:03 <hexagoxel> zincy: translate between js values and haskell ones. if you have some js object that always has three fields of certain types, you could define some equivalent haskell `data`, and convert to that to get some type-save, native value.
08:53:13 * hackage wai-middleware-content-type 0.6.1.2 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.6.1.2 (athanclark)
08:55:01 <Whimwham> who is god
08:55:11 <byorgey> Whimwham: are you learning Haskell?
08:55:50 <Whimwham> nope
08:56:14 <jchia_1> I wish there were such a thing as typeclass synonym so that I can reexport a typeclass with a different name to avoid name clashes.
08:56:26 <byorgey> Whimwham: would you like to?  https://www.haskell.org/
08:56:36 <byorgey> Whimwham: this channel is for discussing the Haskell programming language.
08:56:50 <Putonlalla> I know how to make size-tagged vectors, but how can I make a set of such vectors while retaining the tags?
08:57:13 * hackage monadcryptorandom 0.7.2.1 - A monad for using CryptoRandomGen  https://hackage.haskell.org/package/monadcryptorandom-0.7.2.1 (ThomasDuBuisson)
08:57:29 <Whimwham> i searched it in the interndt about top irc channel...so i got here
08:57:50 <JuanDaugherty> at least hs is top in something
08:58:12 <JuanDaugherty> even if it's irc troll magnetism
08:58:36 <byorgey> I don't think Whimwham was trolling, just clueless
08:58:56 <byorgey> and probably bored.
08:59:09 <adjofun> I thought Twitch has top irc chans =^)
08:59:40 <byorgey> maybe Whimwham had already visited all the bigger IRC chans, and was working down the list =P
08:59:54 <DigitalKiwi> 1700+ users and nobody uses haskell :|
09:00:03 * JuanDaugherty wonders how often people run ghc in safe mode
09:00:21 <systemfault> Perhaps he thought it was #AskHell
09:00:56 <jle`> Axman6: thanks for the tip!
09:01:44 <humanoyd> {-# LANGUAGE ExistentialQuestions #-}
09:02:07 <DigitalKiwi> haskell isn't even a real language it has all these extensions zomg!
09:03:41 <adjofun> still waiting for {-# LANGUAGE ArtificialIntelligence #-}
09:04:08 <yorick> why does stack need GHC just for making a build plan?
09:05:04 <DigitalKiwi> probably because it uses cabal and cabal needs ghc?
09:05:29 <jackcrfs> Working on the IO tutorial on vex.net.  Look at signature of >>=, got me thinking whether -> is an “operator” and what is the “operator precedence rule” for ->?
09:06:02 <ertes-w> {-# DeriveWIM #-}
09:06:40 <jackcrfs> normally a -> b -> c means I just take last one as output (return val), is that all there’s to it?
09:07:02 <ertes-w> jackcrfs: a -> b -> c = a -> (b -> c)
09:07:18 <jackcrfs> o.O
09:07:28 <ertes-w> jackcrfs: a "binary function" is really a "unary function" (or just "function") that returns a function
09:07:46 <ertes-w> jackcrfs: correspondingly:  f x y = (f x) y  -- apply f to x, then y to the resulting function
09:07:51 <Putonlalla> :t undefined :: (->) a ((->) b c)
09:07:54 <lambdabot> a -> b -> c
09:08:07 <jackcrfs> ok, digestinf
09:08:11 <jackcrfs> digesting
09:08:16 <ertes-w> jackcrfs: that's currying in a nutshell
09:08:26 <ertes-w> :t replicate
09:08:28 <lambdabot> Int -> a -> [a]
09:08:31 <ertes-w> :t replicate 4
09:08:33 <lambdabot> a -> [a]
09:08:37 <ertes-w> :t replicate 4 'x'
09:08:39 <lambdabot> [Char]
09:08:43 * hackage sparrow 0.0.1.4 - Unified streaming dependency management for web apps  https://hackage.haskell.org/package/sparrow-0.0.1.4 (athanclark)
09:08:44 <merijn> jackcrfs: The literal answer to your question "what is the operator precedence for (->)?" is simple: "infixr 0" :)
09:08:54 <merijn> jackcrfs: You can see it by running ":i (->)" in ghci
09:09:16 <adjofun> jackcrfs: also, thanks to certain isomorphism, you can think of -> as logical implication
09:09:41 <merijn> I think you guys are giving all sorts of neat info about (->), but not actually answering the concrete question about precedence :)
09:10:23 <ertes-w> jackcrfs: that's why you can write (map (replicate 4))…  (replicate 4) is the function that takes an element and returns a list of that element repeated 4 times
09:10:38 <ertes-w> (replicate 4) is already that function, so you don't need to give 'map' an awkward wrapper
09:10:45 <jackcrfs> i think I understood 30%, i captured and will dig in.... grateful for all the pointers
09:10:54 <adjofun> merijn, jackcrfs: strongest, from right to left =:)
09:11:34 <jackcrfs> tks!
09:12:19 <ertes-w> jackcrfs: the first thing to keep in mind is that in haskell *every* function takes *exactly* one argument, so you have two options to represent higher-arity functions:  1. it takes a tuple, 2. it takes the first argument and returns a function that takes the second argument
09:12:48 <ertes-w> for the most part we go with the second option
09:16:13 * hackage hapistrano 0.3.5.4 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.3.5.4 (juanpaucar)
09:22:34 <jackcrfs> i am lost
09:23:38 <jackcrfs> :t take gives Int -> [a] -> [a]
09:23:40 <lambdabot> error: parse error on input ‘->’
09:23:56 <jackcrfs> take 3 would be list -> list
09:24:33 <jackcrfs> that I understand because take eats the first arg and return another function
09:24:58 <ddellacosta> jackcrfs: what in particular is confusing?
09:25:03 <jackcrfs> but that seems to say -> took the leftmost item first?
09:25:21 <jackcrfs> whereas I heard someone say priority is right side first?
09:26:04 <jackcrfs> jackcrfs: a -> b -> c = a -> (b -> c)
09:26:30 <jackcrfs> i think the above means do the rightmost things first?
09:27:19 <ddellacosta> jackcrfs: maybe you're thinking about right associativity in function composition?
09:27:53 <jackcrfs> rightmost first would mean take 2 “apple” equal take (2 “apple”)?  that cant be right
09:28:01 <adjofun> jackcrfs: priority applies to disambiguation from type `a -> b -> c` to type `a -> (b -> c)`, function application is another matter
09:28:09 <adjofun> :t take 5
09:28:09 <jackcrfs> ahhhhh
09:28:11 <lambdabot> [a] -> [a]
09:28:17 <adjofun> :t take
09:28:19 <lambdabot> Int -> [a] -> [a]
09:28:54 <jackcrfs> disambiguation from
09:28:57 <jackcrfs> type?
09:29:03 <jackcrfs> what is THAT??
09:29:43 * hackage xmlbf 0.4 - XML back and forth! Parser, renderer, ToXml, FromXml, fixpoints.  https://hackage.haskell.org/package/xmlbf-0.4 (RenzoCarbonara)
09:29:51 <jackcrfs> :t 1
09:29:53 <lambdabot> Num p => p
09:30:07 <jackcrfs> ha?  we have a bot listening to code?
09:30:44 <jackcrfs> got to say its amazing
09:30:54 <jackcrfs> :t iterate
09:30:56 <lambdabot> (a -> a) -> a -> [a]
09:31:09 <adjofun> that is, you can read type of function `take` as "give me Int, and I will give you a function from list of some type to a list of same type", as opposed to "Give me an Int and a list of some type, and I will give to you a list of same type""
09:31:22 <adjofun> yeah, lambdabot is pretty cool
09:31:57 <jackcrfs> i get this part
09:32:56 <jackcrfs> i just dont get when i need to know a -> b -> c = a -> (b -> c)
09:33:09 <jackcrfs> its ok i dont get it but i am
09:33:27 <Ariakenom> what would happen if you had (a->b)-c   ?
09:33:49 <jackcrfs> not sure i know how to parse when people chain >>= and -> and those /s lambda
09:33:54 <ddellacosta> https://wiki.haskell.org/Partial_application
09:34:18 <Ariakenom> jackcrfs, you want to apply a single a, right? And you want a (b->c) back?
09:34:38 <ddellacosta> jackcrfs: the point is, in general if you have a function a -> b -> c, if you provide a, then you'll get back a function with the type b -> c
09:34:52 <adjofun> jackcrfs: oh, you mean -> in lambdas and cases, as in (\x -> x) and "case x of something -> whatever"?
09:34:53 <jackcrfs> OH!
09:35:00 <Ariakenom> With ((a->b) ->c) You need to apply a (a->b) first. And get a (c) back.
09:35:04 <jackcrfs> obvious now
09:35:49 <jackcrfs> u all been saying same thing to me
09:36:04 <ddellacosta> jackcrfs: sometimes it takes multiple different angles for this stuff to sink in! I know how it is :-D
09:36:11 <jackcrfs> somehow brain didnt parse that signature
09:36:21 <jackcrfs> now it glaringly obvious
09:36:37 <jackcrfs> speaking of which
09:37:07 <jackcrfs> whenever i cant parse a haskell code , would peeking into .hi or calling some tools help?
09:37:29 <[exa]> peeking to ghci and asking it :t and :i usually helps
09:37:40 <jackcrfs> the compiler obviously can pretty print the parse tree in theory
09:38:08 <jackcrfs> can i see the syntax tree in all its glory?
09:38:28 <[exa]> ghc has options to terminate after parsing
09:38:41 <jackcrfs> great, will try
09:38:59 <[exa]> you won't be happy
09:39:17 <[exa]> (parser pun kindof intended)
09:39:30 <jackcrfs> i been hearing it pays off haha
09:39:54 <adjofun> jackcrfs: you really shouldn't do that, if you have only a couple of days of experience in haskell, it WILL scare you =:)
09:40:18 <jackcrfs> it already scares me but i am
09:40:21 <jackcrfs> still here
09:40:25 <dyl> -ddump-parsed-ast?
09:40:39 <dyl> But yeah
09:40:47 <dyl> There be dragons in the AST!
09:41:02 <jackcrfs> i will adopt lazy evaluation when appropriate ...
09:41:48 <[exa]> jackcrfs: anyway what was the problematic expression?
09:42:02 <Boomerang> Another simple way to look at it: `f :: a -> b -> c` `f a :: b -> c` `f a b :: c`
09:43:32 <jackcrfs> there is an example on vex net that chains reading two lines and putting them back out
09:44:15 <jackcrfs> i wanted to understand how to parse with all those -> >>= and \s with little punctuation to break them
09:44:27 <jackcrfs> its just an academic exercise
09:45:23 <jackcrfs> no worries, day time I am paid to write python; what is better to take a break by learning Haskell???
09:46:10 <adjofun> jackcrfs: \s and -> are part of lambda syntax. Dont confure function type annotations (f :: a -> b) with lambda syntax (f = (\x -> x+x))
09:46:15 <jackcrfs> i am enjoying this and no one will penalize me if i take too long to parse a line or two.  makes me feel good
09:46:17 <adjofun> confuse*
09:46:55 <jackcrfs> AHHHHHH
09:47:43 <jackcrfs> that lambda arrow was poking my subconscious ribs, now that u say it - u saved my life haha
09:49:15 <adjofun> jackcrfs: note that there is also something called "case statements", which look like this: "case x of 1 -> ...; otherwise -> ..."
09:50:12 <adjofun> this is analogous with switch statement, just with other keywords and syntax
09:50:15 <Boomerang> For the mix of lambdas (\x -> ...) and binds (>>=), you read from left to right: `f >>= \x -> g >>= \y -> h x y` ~ `f >>= (\x -> (g >>= (\y -> (h x y))))`
09:51:27 <Garmy> adjofun: "otherwise" in a case statement?
09:51:28 <jackcrfs> great!  if u guys taught my first year computer class, I might have gone on for a PhD
09:51:42 <Garmy> expression, I mean
09:52:51 <adjofun> > let x = 2 in case x of 1 -> print "whatever"; otherwise -> print "not 1"
09:52:54 <lambdabot>  <IO ()>
09:53:03 <adjofun> damn it
09:53:40 <ertes-w> > case 2 of 1 -> print "nah"; _ -> "yah"
09:53:43 <lambdabot>  error:
09:53:43 <lambdabot>      • Couldn't match expected type ‘IO ()’ with actual type ‘[Char]’
09:53:43 <lambdabot>      • In the expression: "yah"
09:53:49 <ertes-w> > case 2 of 1 -> "nah"; _ -> "yah"
09:53:52 <Garmy> I see... Didn't know that worked.
09:53:52 <lambdabot>  "yah"
09:54:05 <ertes-w> don't use 'otherwise' there!
09:54:08 <Boomerang> adjofun: By the way `otherwise` in a case statement is not quite the same as otherwise in guards
09:54:18 <Garmy> > case 2 of 1 -> "nah"; otherwise -> "yah"
09:54:19 <pc7> okay
09:54:21 <lambdabot>  "yah"
09:54:25 <adjofun> I believe, `otherwise` is defined somethere as `True`
09:54:28 <ertes-w> Garmy: i repeat: don't use 'otherwise'!
09:54:42 <dyl> > :t otherwise
09:54:45 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
09:54:46 <dyl> :t otherwise
09:54:46 <Boomerang> > case 2 of 1 -> 0; otherwise -> otherwise
09:54:47 <lambdabot> Bool
09:54:49 <Psybur_> @src otherwise
09:54:49 <lambdabot> otherwise = True
09:54:50 <lambdabot>  2
09:54:51 <pc7> whatsup
09:54:54 <dyl> @src (.)
09:54:55 <lambdabot> (f . g) x = f (g x)
09:55:01 <dyl> Aw.
09:55:08 <Boomerang> > case 2 of 1 -> 0; otherwise -> otherwise
09:55:12 <lambdabot>  2
09:55:18 <pc7> hey
09:55:32 <dyl> @src GHC.Prim.RealWorld
09:55:32 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:55:38 <dyl> :t GHC.Prim.RealWorld
09:55:41 <lambdabot> error:
09:55:41 <lambdabot>     Not in scope: data constructor ‘GHC.Prim.RealWorld’
09:55:41 <lambdabot>     No module named ‘GHC.Prim’ is imported.
09:55:49 <pc7> exit
09:55:53 <pc7> shutdown
09:55:56 <Psybur_> dyl, no hacking the world please
09:56:06 <jackcrfs> :q
09:56:10 <dyl> > fix error
09:56:13 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
09:56:17 <Psybur_> lmao
09:56:30 <Boomerang> adjofun: Yes `otherwise` is defined as True, but in a case statement you're matching anything and shadowing the definition of `otherwise`
09:56:57 <dyl> Why does otherwise even typecheck in that situation?
09:57:13 <dyl> Oh, it's a shadowing binding.
09:57:30 <ertes-w> > let 1 = 3 in 1 + 1
09:57:31 <Garmy> That makes sense now
09:57:33 <lambdabot>  7
09:58:02 <dyl> > let x = 2 in case x of 1 -> 1; otherwise -> otherwise
09:58:05 <lambdabot>  2
09:59:07 <jackcrfs> that was fun, have to go, be back tomorrow, bye
09:59:16 <adjofun> ertes-w: wait, what?
10:00:00 <dyl> let 1 = 5 in 1 + 1
10:00:02 <dyl> > let 1 = 5 in 1 + 1
10:00:05 <lambdabot>  2
10:00:09 <dyl> hmmm.
10:00:22 <dyl> > let 1 = 3 in 1 + 1
10:00:25 <lambdabot>  2
10:00:40 <dyl> Where did that 7 come from?
10:00:57 <ertes-w> a mystery, a mystery
10:04:21 <adjofun> > let 😀 = 5 in 😀 + 😀
10:04:23 <lambdabot>  <hint>:1:5: error: parse error on input ‘😀’
10:04:27 <adjofun> =(
10:04:29 <jle`> @let _ + _ = 7 in 2 + 4
10:04:29 <lambdabot>  Parse failed: Parse error: in
10:04:43 <jle`> > let _ + _ = 7 in 2 + 4
10:04:46 <lambdabot>  7
10:06:19 <pdxleif> @hoogle (MonadError e m, MonadIO m) => m (Either e a) -> m a
10:06:20 <lambdabot> Rest.Error orThrowWith :: MonadError a m => m (Either e b) -> (e -> a) -> m b
10:06:20 <lambdabot> HsDev.Util liftThrow :: (Show e, MonadError e m, MonadCatch m) => m a -> m a
10:06:20 <lambdabot> Control.Monad.Error.Lens catches :: MonadError e m => m a -> [Handler e m a] -> m a
10:42:37 <dyl> [exa] "It is literally possible in many APL systems that an expression such as A+ C can be interpreted as A(+(C)) for one instance of execution and as (A)+(C) for another."
10:42:47 <dyl> 🙃
10:47:05 <DigitalKiwi> APL the language so elitist it required a separate keyboard
10:48:05 <dyl> DigitalKiwi at that time it was unlikely you would even own your own computer.
10:48:13 <dyl> The keyboard would come with the workstation you'd be using.
10:48:43 <dyl> Also, APL wasn't originally a programming language.
10:49:03 <DigitalKiwi> so elitist you couldn't even use it without being in the elite club!
10:49:12 <dyl> It was originally a mathematical notation for working with linear algebra, weirdly enough.
10:50:12 <Ivan__1> DigitalKiwi: now there are two dialects (J and K) of APL that do not require special keyboards
10:50:45 <Ivan__1> besided one always can use compose key, and the most modern terminal are capable to show UTF-8 symballs
10:50:53 <DigitalKiwi> I've only met one person that's ever used it
10:51:06 <dyl> Well, it is 50+ years old.
10:51:17 <dyl> J/K are more common.
10:51:21 <Psybur_> Oh geez, please dont code anything in J :D
10:51:41 <dyl> Don't worry I'm just writing a dialect of APL that is entirely in emoji.
10:51:45 <dyl> It'll be way nicer than J.
10:52:00 <dyl> It has a REPL (SMS fees may apply).
10:52:11 <DigitalKiwi> I can't tell if you're serious
10:52:18 <dyl> Oh, I'm serious.
10:52:28 <DigitalKiwi> I'm terrified
10:52:35 <dyl> I'm reading old APL papers right now.
10:52:36 <ertes-w> we have most of APL as domain-specific languages in haskell, so …
10:52:42 <dyl> Parsing is a huge pain if you want to compile it down.
10:53:07 * Ivan__1 missing J ranks for Applicatives in Haskell 
10:54:13 * hackage pointfree-fancy 1.1.1.6 - Tool for refactoring expressions into pointfree form  https://hackage.haskell.org/package/pointfree-fancy-1.1.1.6 (vmchale)
10:58:19 <dyl> Ivan__1 http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/apl-extabs.pdf
11:00:20 <DigitalKiwi> 8 references in a 2 page paper 1 of which included the 8 references...
11:00:38 <dyl> It's not a full paper, just an extended abstract.
11:01:24 <dyl> Here's the paper: https://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/aplicative.pdf
11:02:38 <DigitalKiwi> 2 pages of references in a 27 page paper
11:03:16 <cn28h> how much does haskell tend to change across major releases of GHC? should I expect this to be more like python where there might be serious compatibility concerns, or more like gcc where I can probably build code across major relases without much trouble?
11:03:27 <DigitalKiwi> I guess the numbers work out better
11:03:45 <cocreature> cn28h: somewhere in between probably
11:03:57 <cn28h> hm, all right
11:04:00 <lyxia> stuff breaks but not at runtime
11:04:48 <pdxleif> I'm confused about the mtl vs transformers situation.
11:04:53 <Ivan__1> dyl: thanks, I am reading it
11:05:06 <cocreature> pdxleif: it’s not mtl vs transformers, mtl builds on top of transformers
11:05:43 * hackage bronyradiogermany-common 1.0.0.0 - Common types and URIs for the BronyRadioGermany API bindings.  https://hackage.haskell.org/package/bronyradiogermany-common-1.0.0.0 (implementation)
11:06:18 <pdxleif> Ah, hrm. To me it seemed I could import either Control.Monad.Reader, or Control.Monad.Trans.Reader, but my code stays the same.
11:06:29 <pdxleif> acid-state uses the former, servant uses the latter...
11:07:21 <cocreature> pdxleif: Control.Monad.Trans.Reader provides the ReaderT type, Control.Monad.Reader provides the MonadReader typeclass and reexports the ReaderT type from Control.Monad.Trans.Reader
11:09:17 <danielo515> Hello, is this a good place for haskell beginner questions ?¡
11:09:28 <Ivan__1> dyl: I will dig more into the article, but from fast search it seems they implement only "unary" reranking "1, "2, etc, but not the reranking of dyadik operators, like +"(3,4)
11:09:31 <cocreature> danielo515: yes!
11:09:43 * hackage bronyradiogermany-streaming 1.0.0.0 - Streaming interface for the BronyRadioGermany API.  https://hackage.haskell.org/package/bronyradiogermany-streaming-1.0.0.0 (implementation)
11:09:50 <pdxleif> ah, thanks
11:10:15 <Ivan__1> s/dyadik/dyadic/
11:12:49 <humanoyd> I feel https://www.willamette.edu/~fruehr/haskell/evolution.html is missing an ST monad version
11:13:49 <jle`> danielo515: yes it is!
11:14:33 <danielo515> Thanks
11:14:45 <EvanR> just now realizing how absurd it is to simply http post uncaught exceptions to the web
11:14:46 <danielo515> I am trying to define a recursive function on GHCI, is it even possible ?
11:14:53 <danielo515> I want to use pattern matching
11:15:11 <jle`> danielo515: it is, but you have to be careful about multi-line input
11:15:31 <jle`> you would need to include it all in the same "line", which you can do using semicolons or :set +m
11:15:44 <danielo515> So I can not just define one part, hit enter and then the other one ?
11:16:01 <jle`> yeah, in ghci, that works like one binding, and then another binding that shadows the last
11:16:13 * hackage gmpint 0.1.0.8 - GMP integer conversions  https://hackage.haskell.org/package/gmpint-0.1.0.8 (vmchale)
11:16:21 <jle`> if you turn on multiline input then pressing enter will actually leave you in the same command
11:16:46 <jle`> (you'd have to press enter twice to see the result)
11:16:56 <danielo515> This is what I'm trying:
11:17:00 <danielo515> concat [] = "" concat (x:xs) = (show x) ++ (concat xs)
11:17:02 <jle`> (this only works for 'let x = 5...' yype bindings)
11:17:04 <danielo515> dam
11:17:10 <jle`> danielo515: yeah can do that with the semicolons
11:17:15 <danielo515> concat [] = ""
11:17:19 <jle`> concat [] = ""; concat (x:xs) = show x ++ concat xs
11:17:20 <danielo515> concat (x:xs) = (show x) ++ (concat xs)
11:17:34 <danielo515> I'm doing it on two separate lines, ok I'll try with semicolons
11:18:22 <danielo515> Good! it worked with semi colons
11:18:26 <danielo515> Many thanks
11:19:28 <cocreature> danielo515: you can also enter multiline-mode by typing :{ followed by enter into ghci and exit it with :} once you’re done
11:19:40 <byorgey> danielo515: in general, though, I would recommend putting such functions into a .hs file and then using :load to load it into ghci
11:20:00 <byorgey> then you can :reload (or just :r ) after you edit the file
11:21:08 <danielo515> Yes, that is a better approach, but I just wanted to try a fast idea
11:26:35 <cemerick> I seem to remember seeing either an available extension or a proposal for supporting numeric separators. Am I mistaken?
11:28:27 <lyxia> cemerick: https://github.com/ghc-proposals/ghc-proposals/pull/76
11:29:36 <dyl> Wait...
11:29:58 * lyxia waits.
11:30:20 <dyl> ¯\_(ツ)_/¯
11:30:23 <dyl> One fun idea though:
11:30:41 <dyl> Some kind of hackathon where you can only use languages in the 40-50 range of the TIOBE index.
11:30:54 <dyl> ...hm that'd just end up all being Scheme and Clojure.
11:31:00 <dyl> Or Ocaml.
11:31:01 <dyl> </3
11:31:15 <dyl> I want to see a hackathon using exclusively obscure or obsolete languages.
11:31:26 <cemerick> lyxia: thank you, yes. Looks like it's planned for 8.6: https://ghc.haskell.org/trac/ghc/wiki/LanguagePragmaHistory
11:31:30 <dyl> Probably won't happen as it wouldn't be useful for sponsors to recruit from.
11:41:24 <ertes-w> "welcome to the first lazy k hackathon, the first hacking meetup with a dedicated psychiatrist…  have fun, share your ideas, and may god have mercy on your soul!"
11:43:57 <Rembane> :D
11:46:32 <Hijiri> is there a way to map over a C++ future
11:47:06 <EvanR> first convert it to a haskell future
11:47:16 <Rembane> And then you'll be in the past.
11:47:55 <EvanR> then fmap it
11:50:36 <Psybur_> f(uture)map!
11:51:49 <chisui> data Future a = NotYet?
11:52:45 <chisui> data Past a = TooLate
12:04:07 <zincy> My Miso front end app is receiving websocket msgs from echo tests online but not from the haskell server I wrote. The confusing thing is that I can see the msgs from my server coming in through chrome dev tools?
12:05:20 <DigitalKiwi> dyl obscure or obsolete you say? so scala is on the table? :|
12:05:50 <ertes-w> what's a future again?
12:05:58 <ertes-w> in haskell terms, please
12:06:12 <chisui> a promise of a value
12:06:15 <dyl> DigitalKiwi zing!
12:06:23 <dyl> Perl8.org used to redirect to scala.org
12:06:29 <ertes-w> chisui: that didn't help
12:06:39 <dyl> er, scala-lang.org*
12:06:44 <ertes-w> what would the haskell API of "futures" look like?
12:07:30 <dyl> ertes-w forkIO + M/TVar?
12:07:52 <dyl> forkIO + MVar is probably plenty for most cases.
12:08:07 <dyl> I think edwardk had a promises library.
12:09:20 <exarkun> Async?
12:09:47 <exarkun> https://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html
12:09:59 <geekosaur> one could argue IO is already futures...
12:10:00 <byorgey> http://hackage.haskell.org/package/promises
12:10:06 <exarkun> geekosaur: Yea.
12:10:22 <exarkun> True and proper futures are more than _just_ a promise of a result
12:10:28 <zincy> Figured it out for some reason a websocket message must be wrapped in quotes
12:11:07 <EvanR> apply a function to a future, fmap :: (a -> b) -> IO a -> IO b. handle the result of a future, (>>=) :: IO a -> (a -> IO b) -> IO b, brilliant
12:12:48 <Ariakenom> promise task = do {m<-newEmptyMVar; forkIO (task>>=putMVar m); return m}
12:13:14 <Ariakenom> is the gist afaik
12:14:02 <Ariakenom> or maybe just a possibly empty mvar with no specification of producer
12:14:34 <EvanR> why are mvars involved?
12:14:56 <DigitalKiwi> dyl are we looking at the same tiobe index because scheme is in the 51-100 and clojure is 30 but haskell is 42
12:14:59 <Ariakenom> to block
12:15:06 <EvanR> IO a can also block
12:15:59 <Ariakenom> return m could be return (readMVar m) sure
12:16:24 <EvanR> so the answer is, so you dont do the task more than once
12:16:48 <EvanR> in which case its like async
12:17:16 <Ariakenom> You start a thread to do task and block on the result at a later date. Async works too.
12:17:46 <Ariakenom> works better
12:17:48 <EvanR> or unsafeInterleaveIO
12:18:04 <dyl> Does anyone else just never use return and always write pure?
12:18:51 <Ariakenom> not interleave, you want to run it right away and not lazily
12:19:55 <EvanR> you could implement it as, unsafeInterleaveIO followed by evaluate
12:21:14 <Ariakenom> You want it to run asynchronously though
12:21:58 * EvanR brains explode
12:22:23 <EvanR> pesky time, cant everything just happen at once
12:23:26 <Ariakenom> So you couuuld spark it
12:25:15 <Ariakenom> :t par
12:25:16 <lambdabot> error:
12:25:17 <lambdabot>     • Variable not in scope: par
12:25:17 <lambdabot>     • Perhaps you meant one of these:
12:26:51 <zincy> How do I decode a lazy bytestring into a string?
12:27:48 <EvanR> Data.Text.Lazy.Encoding
12:27:57 <EvanR> then unpack the Text
12:28:00 <ertes-w> zincy: String or Text?
12:28:30 <zincy> ideally to Text
12:28:39 <EvanR> then forget the unpack step
12:28:43 <ertes-w> zincy: then half of what EvanR said
12:28:54 <ertes-w> dyl: i always use 'pure'
12:31:11 <ertes-w> Ariakenom: that looks like a poor version of 'async'
12:32:02 <ertes-w> so then futures are "what async does" (promises + IO)
12:36:24 <ertes-w> i don't quite understand the utility of edwardk's library…  when would you use it as opposed to simple laziness?
12:36:46 <Ariakenom> yes. like Is aid async would be better. a better impl than mine is promise=async
12:36:56 <EvanR> ertes-w: which library?
12:37:04 <ertes-w> EvanR: 'promises'
12:40:00 <EvanR> it looks like they can play nice with IO and have a way to recover
12:40:37 <ertes-w> "play nice with IO"?  "recover"?
12:41:43 <EvanR> play nice with IO, you can wrap pure values in a promise or wrap an MVar in a promise. it also can be used in ST. recover = provide default values for broken promises or get a catchable exception BrokenPromise when something goes wrong
12:42:08 <ertes-w> that's sounds like Maybe to me
12:42:15 <EvanR> demand works even without IO
12:42:32 <ertes-w> that sounds even more like Maybe =)
12:42:40 <EvanR> Maybe a cant do IO
12:42:58 <ertes-w> neither can Promise/Lazy
12:43:01 <EvanR> if you say, combine it with IVars... thats what this is
12:43:33 <ertes-w> Lazy is ST, but with runPromise* instead of runST
12:43:37 <EvanR> it can because it has unsafePerformIOs in there
12:43:49 <EvanR> ST or IO
12:44:23 <ertes-w> i don't understand, but let me ask differently…  what's a concrete application of this that can't be done with a lazy Maybe value?
12:45:15 <EvanR> you can use demand to get a pure value, and provide it to a pure function...
12:45:45 <ertes-w> that's only part of an application…  who provides the promise?
12:46:44 * hackage bronyradiogermany-common 1.0.0.1 - Common types and URIs for the BronyRadioGermany API bindings.  https://hackage.haskell.org/package/bronyradiogermany-common-1.0.0.1 (implementation)
12:46:45 <EvanR> a driver or something with an eventual answer from the internet
12:47:12 <EvanR> by itself Maybe can do all this
12:47:14 <EvanR> cant*
12:47:34 <ertes-w> how would the driver do the IO?  before entering runPromise*?
12:47:56 <EvanR> i noticed the Promise ctor is exported
12:48:17 <EvanR> you can wrap an MVar
12:48:56 <ertes-w> so you're suggesting to use Promise without Lazy as an MVar carrier?
12:49:02 <nkaretnikov> is there a library that makes it easy to writing haskell code with (in-place) mutation? to express imperative algorithms, like quicksort, etc. not like this: https://stackoverflow.com/questions/7717691/why-is-the-minimalist-example-haskell-quicksort-not-a-true-quicksort but behind a nice dsl
12:49:54 <EvanR> Maybe by itself cant do this stuff, MVar by itself cant do this stuff
12:50:18 <EvanR> youd have to add unsafe* to get IO or purity respectively
12:50:34 <ertes-w> nkaretnikov: the 'vector' library?  all current DSLs are imperative…  if you want something nicer than that, you'll have to be patient until linear types make it into GHC
12:50:35 <lemmih> nkaretnikov: Mutable references and mutable arrays have decent apis.
12:50:57 <kw> Why does Haskell use '=>' in constraints? If you're reading it as logical implication, it seems like for superclass/subclass it should be flipped ('subclass => superclass' or 'superclass <= subclass'), while for expressions that are fully determined by their constraints and vice-versa it should be '<=>'.
12:51:11 <Tuplanolla> I recommend `Vector` with `ST`, nkaretnikov. It's quite nice to use.
12:51:23 <ertes-w> EvanR: but then Promise is just unsafe
12:51:27 <EvanR> kw: i think pure script does reverse it for the class
12:51:39 <ertes-w> EvanR: i sure as hell can use unsafePerformIO with MVar
12:51:50 <ertes-w> because 'demand' is just that
12:51:52 <EvanR> yeah but do you want to
12:52:07 <EvanR> i would rather have a lib do it, like IVar does
12:52:13 <ertes-w> EvanR: what's the difference?  i'm just writing "demand" instead of "unsafePerformIO"
12:52:14 <EvanR> with an API
12:52:34 <ertes-w> EvanR: the "proper" way to use this library is to ignore the Promise constructor
12:52:43 <EvanR> unsafePerformIO behind an API has supposedly been verified and i cant screw up
12:53:43 <kw> EvanR: That's good to know, but any idea why Haskell does as it does?
12:53:43 * hackage beam-core 0.7.2.0 - Type-safe, feature-complete SQL query and manipulation interface for Haskell  https://hackage.haskell.org/package/beam-core-0.7.2.0 (TravisAthougies)
12:53:49 <EvanR> kw: however, if you read the left side of => in class declarations as the top of a logical rule, it could make sense. because those rules go both ways
12:54:26 <EvanR> a good reason not to have both <= and => is that <= is less than or equal to
12:54:30 <ertes-w> EvanR: the thing is: the 'unsafePerformIO' is not in 'demand', but in 'promise'
12:54:43 <EvanR> you need a real good reason to expand into useful ascii
12:54:58 <ertes-w> EvanR: if you use 'promise' you can't have IO, but if you replicate its behaviour, then it's unsafe
12:56:01 <EvanR> ertes-w: in passing i suspect the second arg to the ctor will be doing secret IO, find "drive"
12:56:20 <ertes-w> EvanR: yeah, exactly
12:56:23 <EvanR> final verdict, this lib is totally undocumented and we have no idea what its supposed to be doing
12:56:39 <ertes-w> i get what it's doing, i just can't think of a use cae
12:56:40 <ertes-w> case
12:56:50 <ertes-w> that's why i'm asking
12:57:38 <ertes-w> kw: instance (Num a) => Num (F a)  -- a (Num a) instance entails a (Num (F a)) instance…  of course it's not really all that logical of a syntax (strictly speaking in classes it should be reversed)
12:57:49 * EvanR looks at "promise" and inscrutible guts of ruby on rails... causes nervous breakdown
12:58:11 <kw> EvanR: Good point. Although Haskell doesn't really seem to mind using the same symbols as long as the name spaces are completely disjoint.
12:58:12 <EvanR> ertes-w: it is logical
12:58:46 <ertes-w> kw: in constraints it's even more sensible, because type classes can be thought of as a mechanism for passing implicit arguments
12:58:50 <EvanR> if a "is a monoid" then Maybe a "is a monoid"
12:59:02 <haskell-noob> hi peeps
12:59:11 <EvanR> the algorithm uses that rule backwards, which is fine
12:59:17 <EvanR> thats logic programming
12:59:30 <ertes-w> EvanR: sure, i'm talking about the inconsistent use of (=>)
12:59:38 <ertes-w> class (Monoid a) => Group a
12:59:42 <ertes-w> that's non-sense
12:59:47 <ertes-w> from a logical standpoint
12:59:55 <haskell-noob> hi peeps
13:00:13 <ertes-w> hi haskell-noob
13:00:17 <haskell-noob> is it possible to zip two lists of different length?
13:00:19 <EvanR> thats the same thing as i just said, so i must be wrong
13:00:29 <kw> ertes-w: Suppose that your class declaration for monoid is 'class Monoid a => Semigroup a'.
13:00:30 <ertes-w> > zip [1,2,3] [10..]
13:00:33 <lambdabot>  [(1,10),(2,11),(3,12)]
13:00:53 <ertes-w> haskell-noob: ^ zips are truncated to the shorter list
13:01:04 <haskell-noob> for example, b = [addone, subtractone] c = [1,2,3,4,5,6]
13:01:13 * hackage bronyradiogermany-streaming 1.0.0.1 - Streaming interface for the BronyRadioGermany API.  https://hackage.haskell.org/package/bronyradiogermany-streaming-1.0.0.1 (implementation)
13:01:14 <Tuplanolla> Consider `(Eq a, Eq b) => Eq (a, b)` versus `Eq (a, b) => (Eq a, Eq b)`, ertes-w.
13:01:25 <haskell-noob> zip b c = [addone 1, subtractone 2, addone 3, subtractone 4, ...]
13:01:35 <EvanR> class or instance
13:01:44 <ertes-w> haskell-noob: 'cycle' the function list
13:01:57 <haskell-noob> ertes-w: I tried that but it gave me an infinite sequence
13:02:03 <ertes-w> > zipWith ($) (cycle [succ, pred]) [10,20,30,40,50,60]
13:02:06 <lambdabot>  [11,19,31,39,51,59]
13:02:35 <Tuplanolla> The former reads "given equality on a and b, it is possible to construct equality on (a, b)".
13:02:38 <kw> ertes-w: or 'class Semigroup a -| Monoid a' if you want to avoid '⇐'.
13:03:11 <ertes-w> Tuplanolla: i agree with the *instance* notation, but the *class* notation is backwards
13:03:25 <EvanR> the class notation shouldnt be reversed either
13:03:42 <haskell-noob> ertes-w: wonderful, thanks!
13:03:44 <EvanR> its a different sense entirely from instance
13:04:10 <Tuplanolla> I don't see the difference, ertes-w.
13:04:14 <EvanR> it needs a superclass requirement judgement
13:04:58 <ertes-w> i wish we had superclass instances as regular members
13:05:13 <ertes-w> class Monoid a where { instance Semigroup a; mempty :: a }
13:05:13 <EvanR> => <= |- and -| are just going to cause more confusion since they both transcend the application to class hierarchies
13:05:43 * hackage beam-migrate 0.3.1.0 - SQL DDL support and migrations support library for Beam  https://hackage.haskell.org/package/beam-migrate-0.3.1.0 (TravisAthougies)
13:06:04 <ertes-w> that's how most proof assistants do it, it makes sense while avoiding the notation controversy, and on top of that it's also more convenient when you have lots of superclasses
13:06:51 <EvanR> passes the smell test i think
13:08:04 <kw> ertes-w: That would be a very nice way to sidestep the issue.
13:10:59 <kw> I do think that in general constraints have it backwards (e.g. 'forall a. Num a => a + a' ‒ 'a + a' implies that 'a' must be a Num).
13:11:44 <ertes-w> kw: i think you're mixing up levels there
13:12:06 <EvanR> by the time you get to a+a, indeed a must be Num, since you provided the instance
13:12:26 <ertes-w> (Monoid a) => [a] -> a  -- given a (Monoid a) instance and an [a], you can have 'a'
13:12:50 <EvanR> => is a type sig basically a function arrow
13:13:14 <EvanR> see also Num a => Num b => a -> b -> Integer
13:13:50 <EvanR> => in a type sig is*
13:15:37 <kw> Oh, yes, you're right.
13:15:48 <kw> Oops.
13:18:48 <kw> EvanR: Analogy to the constraint being an argument Haskell sneaks in there for you makes the most sense to me.
13:21:44 <haskell-noob> How do I define the Eq operator for a new datatype?
13:21:55 <EvanR> the superclass constraint is also snuck in, at some point, when you have instance Mother a => Daughter a where
13:23:28 <lemmih> haskell-noob: Deriving it is easiest.
13:23:35 <geekosaur> haskell-noob, most of the time we let the compiler derive it. but if the point here is to define it yourself, think a bit
13:24:59 <EvanR> but it breaks down in class, because its analogous to the rule... given A is a type <long line> Maybe A is a type, (and this is the only way for Maybe A to be a type)
13:25:26 <EvanR> this isnt a function, it can be run backwards
13:26:58 <glittershark> hey all - is there a kind-level version of Void somewhere? is that even possible?
13:27:13 * hackage beam-sqlite 0.3.2.0 - Beam driver for SQLite  https://hackage.haskell.org/package/beam-sqlite-0.3.2.0 (TravisAthougies)
13:27:26 <glittershark> from another angle, is there a type-level bottom for use with DataKinds?
13:27:51 <glittershark> I want to prove that a particular type parameter is uninhabited (but the type parameter doesn't have kind *)
13:28:39 <EvanR> we established a couple days ago that every kind is inhabited thanks to polykinds
13:29:10 <EvanR> and it matters when you go to type families which can "match" on such nonsense
13:29:29 <gentauro> how do you define the following type definition (OCaml) in Haskell => type ('a, 'b) foo = 'a -> 'b?
13:29:56 <jle`> glittershark: there is a type-level "undefined"
13:30:04 <jle`> that inhabits every kind
13:30:09 <jle`> it's in GHC.TypeLits
13:30:33 <jle`> if a type family ever evaluates to it then it's a compile time error
13:30:33 <glittershark> oh cool
13:30:37 <glittershark> oh, TypeError
13:30:40 <glittershark> yeah
13:31:03 <glittershark> I'm not sure if I'm asking the right question here though
13:31:05 <glittershark> so let's say I have http://lpaste.net/364698
13:31:22 <pdxleif> Is there a preference for writing:
13:31:23 <pdxleif> liftIO (runReaderT action db) >>= maybeError err404
13:31:24 <pdxleif> vs
13:31:32 <glittershark> and I want to give the 'xx' type in a code path that could only ever return 'FooC'
13:31:32 <pdxleif> Handler $ ExceptT $ maybeToRight err404 <$> runReaderT action db
13:31:41 <glittershark> oops, didn't capitalize the constructors there
13:31:43 <glittershark> you get the point though
13:32:11 <jle`> not sure i understand, what's your use case?
13:32:19 <jle`> or, what sort of usage/code path are you talking about
13:32:24 <gentauro> whats happening with all the people who joins? :)
13:32:45 <glittershark> that's a lot of backstory, lol
13:32:49 <pdxleif> gentauro: the matrix gateway reset or something?
13:33:02 <geekosaur> yeh, that's matrix.org rejoining
13:33:29 <glittershark> TypeError (Text "Unreachable type") might work here actually. Will report back
13:34:33 <gentauro> pdxleif: I'm just reading people joining :D
13:34:34 <glittershark> nah, that just triggers an error at the call site
13:34:42 <glittershark> because it's not an abstraction away
13:34:42 <dagano> i struggle with basic recursion patterns .. i have an initial bitvector v, and a list of strings ... for each string in the list, i want to update the bitvector .. was thinking this was a fold initially. does that sound like the right pattern?
13:35:02 <glittershark> yep dagano
13:35:07 <glittershark> fold over the strings
13:35:13 * hackage saltine 0.1.0.1 - Cryptography that's easy to digest (NaCl/libsodium bindings).  https://hackage.haskell.org/package/saltine-0.1.0.1 (amx)
13:35:15 <glittershark> with the bitvector as the accumulator
13:35:24 <fishythefish> gentauro: data Foo a b = Foo (a -> b), newtype Foo a b = Foo (a -> b), or type Foo a b = a -> b, depending on what you want
13:36:03 <dagano> glittershark: yeah that's the idea .. i want the ultimate result to be the bitvector that has "seen" all of the strings
13:36:08 <caryoscelus> hello. i've got one (perhaps somewhat boring) question: is https://wiki.haskell.org/How_to_write_a_Haskell_program generally up-to-date and doesn't miss anything important in the very recent developments?
13:40:48 <lemmih> caryoscelus: It doesn't talk about stack much but otherwise it seems fairly up-to-date.
13:41:59 <Tuplanolla> Looks fine, caryoscelus.
13:42:19 <Tuplanolla> It should mention package versioning though.
13:42:23 <dagano> ok so my "bitvector" is actually just a list of bool and i have a fcn to update and yield a new one (set_add :: [Bool] -> String -> [Bool]) ... how do i "fold" this over my list of strings if (foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b) .. it looks like the type doesn't match?
13:42:56 <dagano> holy crap ... just used a \x y -> set_add y x and it finally compiled
13:43:20 <caryoscelus> lemmih: anything specific that would complement it without being way too specific?
13:46:34 <whatsupboy> DO Haskell have official Docker image ?
13:52:43 * hackage OddWord 1.0.2.0 - Provides a wrapper for deriving word types with fewer bits.  https://hackage.haskell.org/package/OddWord-1.0.2.0 (RobinKay)
13:54:43 * hackage tweet-hs 1.0.1.37 - Command-line tool for twitter  https://hackage.haskell.org/package/tweet-hs-1.0.1.37 (vmchale)
14:05:46 <whatsupboy> not able to load my haskell file when using haskell on docker using haskell's Offcial docker image
14:05:52 <whatsupboy> any help ?
14:06:03 <Rembane> whatsupboy: Gief more info plx!
14:07:13 * hackage hpath 0.9.1 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.9.1 (maerwald)
14:07:38 <whatsupboy> Rembane:  I have downloaded a haskell docker image not sure if its is really official by Haskell but its written as official in dockerhub then I am running that docker image and my ghci loads there I want to use :l to use my exixting haskell programs which I am unable to do
14:08:14 <Rembane> whatsupboy: Have you added your directory with all your Haskell source files as a volume?
14:10:29 <whatsupboy> Rembane:  Oh, sorry and Please tell me is there is really haskell offcial image ?
14:14:38 <Rembane> whatsupboy: I think the commercialhaskell folks have one. I don't know how official it is though.
14:20:13 * hackage gmpint 0.1.0.9 - GMP integer conversions  https://hackage.haskell.org/package/gmpint-0.1.0.9 (vmchale)
14:30:40 <EvanR> you think you want checked exceptions? scroll to the bottom of curls manpage
14:30:56 <EvanR> now THOSE are exceptions
14:31:19 <EvanR> its a scary world out there
14:31:34 <sudoreboot[m]> Does anyone know of anything close to an arrowized FRP equivalent architecture template to Elm's? Not "TEA arrowized", but something similarly thought through.
14:32:31 <EvanR> aiui elm is not frp at all? its just a model, view, and thing which updates the model (which then updates the view)
14:33:20 <EvanR> the model is just data and the view is just a function
14:35:05 <EvanR> Yampa is a well known arrowized FRP
14:38:10 <sudoreboot[m]>  > aiui elm is not frp at all? its just a model, view, and thing which updates the model (which then updates the view)
14:38:10 <sudoreboot[m]> I know.
14:38:36 <sudoreboot[m]> What I'm looking for is an architecture similarly opinionated to TEA, for arrowized FRP
14:39:05 <sudoreboot[m]> (or MFRP for that matter)
14:45:47 <fresheyeball> friendly challenge
14:46:00 <fresheyeball> let compose = foldr (.) id
14:46:14 <fresheyeball> can we define `fold` in terms of `compose`?
14:46:50 <fresheyeball> because
14:46:58 <fresheyeball> compose = appEndo . fold . fmap Endo
14:51:44 <fishythefish> :t ($ mempty) . compose . fmap mappend
14:51:45 <lambdabot> (Functor t, Foldable t, Monoid c) => t c -> c
14:51:47 <caryoscelus> fresheyeball: what do you mean in terms of? does "flip (compose . fmap mappend) mempty" qualify?
14:52:06 <fishythefish> cf. difference lists/Hughes lists
14:52:44 <fresheyeball> caryoscelus: yes!
14:52:48 <fresheyeball> thank you
14:53:05 * fishythefish slinks away
14:57:37 <caryoscelus> np ;)
14:58:06 <lyxia> I know how to solve the orphan instance problem. Put instances on a blockchain.
14:58:32 <lyxia> Only one instance per type!
14:59:25 <hpc> i write all of my orphan instances with kubernetes
15:01:14 <mniip> hpc, not agile enough
15:01:16 <caryoscelus> hmm, i've got one more infrastructure question: is leksah worth trying or should i just go with emacs? or something else?
15:01:21 <caryoscelus> i'm not considering plugins for famous ides and the two things i'm mostly interested in a new editor are direct types and expression evaluation possibilities
15:06:34 <sm> what's direct types ?
15:08:35 <caryoscelus> direct ((types and expression) evaluation)*
15:09:22 <caryoscelus> i.e. not having to switch to ghci and do :r or otherwise copy-paste code from ghci
15:10:36 <caryoscelus> i'm fairly comfortable with that, but i thought this might be a good moment to switch to something with even better workflow
15:12:36 <sm> there's no standout tool for this.. if you're already in emacs, I'd go with that
15:13:53 <caryoscelus> i'm not on emacs (i think it does support expression evaluation, right?), it just seems to be one of defaults answers to editor questions
15:15:15 <caryoscelus> (i might be a bit naive, but i think emacs users are not supposed to ask such questions ^_^)
15:16:59 <sm> there's no standout tool even in emacs. :) There's haskell-mode + ghc-mod, intero, some fork of intero..
15:17:14 <glguy> dante
15:17:18 <sm> thank you
15:18:23 <sm> some people have had good luck with vscode, others with atom, I like IDEA and it works on a good day
15:19:53 <sm> if on mac, haskell for mac is definitely worth a look
15:20:45 <caryoscelus> i've tried one ide written in js once and it ate my ram. although it was kinda good for what it did, it's not worth it for me
15:25:15 <EvanR> Mr. T Ate My Ram
15:55:10 <michalrus> “Note that TSem has no concept of fairness, and there is no guarantee that threads blocked in waitTSem will be unblocked in the same order; in fact they will all be unblocked at the same time and will fight over the TSem. Hence TSem is not suitable if you expect there to be a high number of threads contending for the resource.”
15:55:15 <michalrus> What would be suitable? :)
15:57:34 <EvanR> MVar has a fairness guarantee
15:58:36 <EvanR> I'm told it performs better too, over STM when theres high contention
15:59:07 <hpc> contention with STM leads to lots of recomputation, instead of things just waiting politely
15:59:24 <hpc> STM performs best when it is correct in anticipating computations won't interfere
16:00:29 <mniip> is MVar the one where there's a linked list of reading threads/contexts?
16:01:30 <hpc> data MVar a = MVar (MVar# RealWorld a)
16:01:31 <hpc> maybe?
16:02:17 <EvanR> MVars how do they work
16:02:33 <EvanR> you can't explain it
16:03:07 <hpc> magnets
16:03:21 <hpc> MVar# is an EmptyDataDecl
16:03:52 <hpc> personally, i start with MVar before looking for something more specialized
16:03:57 <ddellacosta> https://memegenerator.net/img/instances/81651248/mvars-how-do-they-work.jpg
16:04:06 <ddellacosta> sorry, couldn't resist
16:04:09 <hpc> "i need something with an MVar, that does blah blah blah... oh, Chan"
16:04:14 <EvanR> hahaha
16:04:22 <ddellacosta> I blame EvanR
16:04:33 * ddellacosta runs away
16:04:58 <mniip> 1523487776 [02:02:56] <hpc> MVar# is an EmptyDataDecl
16:04:59 <mniip> ?
16:05:01 <mniip> it's primitive
16:05:20 <EvanR> mvar is implemented in C, in the runtime
16:05:46 * hpc doesn't look at ghc code much :P
16:05:50 <EvanR> theres details in the paper Concurrent Haskell but I'm not sure if the latest is different
16:07:20 <zachk> if a thread dies or is killed while executing an STM action, is the STM vars still safe or can they be locked after that?
16:07:58 <lyxia> it should be safe
16:10:06 <hpc> zachk: STM doesn't do locks :P
16:10:23 <hpc> if the vars weren't written to, it's as if nothing ever happened
16:10:27 <zachk> oh
16:10:31 <hpc> if they are and it conflicts with another transaction, that transaction retries
16:10:45 <malade_mental> Hi, can somebody explain me this syntax : matrix 4 4 $ \(i,j) -> 2*i - j = (  7  6  5  4 )
16:10:46 <hpc> (if the killed transaction finishes, which it won't)
16:10:55 <malade_mental> this is present in the Data-Matrix documentation
16:11:43 <xplat> is there an easy way to pre-generate some template haskell splices in case they use something heavyweight you may not want to include in your build (i.e. clang-pure)
16:11:46 <xplat> ?
16:11:48 <hpc> malade_mental: looks like the right hand side of the equals sign is a graphical representation of the matrix (i assume there are three similar lines below it?)
16:12:01 <malade_mental> yes it is
16:12:10 <hpc> malade_mental: and the left side is the expression that generates it
16:12:21 <hpc> with coordinates 1,1 at the bottom-left?
16:12:22 <hpc> weird
16:12:39 <malade_mental> no, it isn't this hpc
16:13:10 <hpc> malade_mental: do you have a link to the docs?
16:13:22 <malade_mental> I understand it as if "j" was at each column an element from "(7 6 5 4)"
16:13:25 <malade_mental> http://hackage.haskell.org/package/matrix-0.3.6.1/docs/Data-Matrix.html#v:safeSet
16:13:37 <malade_mental> (not this anchor)
16:14:04 <hpc> oh, the lines are above, that makes more sense
16:14:13 <hpc> so yeah, take that bottom column
16:14:21 <malade_mental> aaah
16:14:21 <malade_mental> ok
16:14:22 <malade_mental> xD
16:14:28 <hpc> i = 4, and going left-to-right j increases from 1 to 4
16:14:35 <malade_mental> yup I'm getting it now
16:33:08 <arahael> what language is this" (what is an .ag file?): https://github.com/carliros/Simple-San-Simon-Functional-Web-Browser/blob/9b035cb91f127910c07fb6c1b652577642b81a20/src-ag/FSTreeFase2.ag
16:34:37 <hpc> looks like it has to do with uu-parsinglib
16:34:58 <arahael> curious - thanks.
16:38:39 <geekosaur> https://hackage.haskell.org/package/uuagc
16:42:27 <arahael> interesting - thanks.
16:46:09 <maerwald> err, did someone break the network package?
16:55:44 <zenen> Hi everyone, I'm working on an assignment involving solving x number of cases, where x is retrieved as input and each case requires reading a variable number of lines given by the first line of each case.
16:56:41 <zenen> I'm trying to write a function which calls an IO subprogram depending on the number given in the first line of the input, is this possible in a functional framework?
17:02:57 <jle`> yes, but you might want to rephrase your thinking
17:03:01 <jle`> you don't need to 'call' an IO subprogram
17:03:05 <jle`> you can 'return' an IO subprogram
17:03:17 <jle`> ioBasedOnNumber :: Int -> IO ()
17:03:30 <Average-user> Does anyone have a repository using stack bench, to use as example?
17:03:35 <jle`> a different Io action is returned based on what number you give
17:05:27 <zenen> I'm calling doCase :: IO () as the subprogram
17:06:54 <jle`> zenen: write an IO action to get the number
17:07:05 <jle`> and then write a function Int -> IO ()
17:07:24 <jle`> or you can just do it all directly together as one big action i suppose
17:07:38 <jle`> doCase = do
17:07:41 <jle`>     x <- readLine
17:07:45 <jle`>     ... stuff with x ...
17:08:37 <johnw> does anyone know how to disable ASLR on macOS High Sierra?  I'm trying to use Data.Compact.writeCompact and unsafeReadCompact. It works fine on Linux, but SEGV's on mac.
17:09:22 <hpc> disabling ASLR is up there with setting your root password to ""
17:09:26 <maerwald> cabal sandboxes were added in which version?
17:10:08 <johnw> hpc: well, considering Linux isn't using it at all, I think I can live
17:11:00 <hpc> aslr has been enabled by default in the linux kernel since 2005
17:11:15 <maerwald> the changelog has a gap before 1.18
17:11:19 <maerwald> so it's unclear to me
17:11:19 <johnw> I wonder why unsafeReadCompact is working there then
17:11:30 <johnw> considering that even the Haddocks say it won't work with ASLR
17:11:56 <hpc> what you want to do is find a way to write your code that works with aslr
17:12:07 <johnw> i have no control over the compact library
17:12:11 <hpc> rather than disabling low-level security features
17:12:36 <hpc> use another library maybe?
17:14:35 <johnw> and btw, I wasn't asking about disabling ASLR for the entire system
17:14:57 <johnw> just that clang-5.0 no longer accepts the -no-pie flag on 10.13, so I was wondering if anyone know of how it's done these days
17:16:09 <sudoreboot[m]> How do I generate a package.yaml file? I've searched extensively without result. Is there a default template?
17:16:35 <glguy> sudoreboot[m]: You don't need one, most projects use a .cabal file, which is what package.yaml generates
17:17:04 <sudoreboot[m]> It's just that stack's documentation assumes you have one
17:17:34 <lyxia> stack's default template has a package.yaml
17:17:44 <glguy> johnw: It looks like the reason it might work on linux is that the libraries there are not universally compiled with pie enabled like they are on mac
17:17:49 <lyxia> it's used with "stack new mypackage-name"
17:17:55 <glguy> err, pic
17:18:12 <johnw> it's indeed pie
17:18:16 <sudoreboot[m]> I guess I screwed up by choosing the simple template
17:18:34 <johnw> in High Sierra they even removed DYLD_NO_PIE
17:18:43 * hackage buildbox 2.1.9.4 - Rehackable components for writing buildbots and test harnesses.  https://hackage.haskell.org/package/buildbox-2.1.9.4 (BenLippmeier)
17:18:49 <sclv> maerwald: 1.18
17:18:54 <glguy> I mean pic as it pertains to libraries compiled by GHC
17:18:55 <lyxia> sudoreboot[m]: look in .stack/templates/new-template
17:19:17 <sudoreboot[m]> lyxia: Thanks
17:19:23 <glguy> On linux the static libraries ghc makes don't enable pic, on mac everything uses it
17:19:25 <johnw> ah
17:22:12 <zenen> help i'm drowning in a sea of functionality
17:25:34 <Welkin> you need some disfunctionality?
17:25:46 <Welkin> what planet are you from?
17:26:01 <zenen> i need my OOP back
17:26:23 <marvin3> heretic
17:26:40 <Welkin> go to the toilet and you will get to see it again
17:27:23 <maerwald> OOP is nice sometimes
17:27:31 <maerwald> but most of the time it's not
17:27:50 <Welkin> I dislike stupid abstractions
17:28:13 <maerwald> also, people don't do OOP these days, they use microservices and scatter their program across the network, because it's so much easier to maintain
17:28:20 <Welkin> that's not to say that haskell or functional programming is 100% good either
17:28:23 <maerwald> and such scale!
17:28:27 <zenen> haskell seems nice, I just left learning it to the last possibly moment so its really overwhelming
17:28:33 <zenen> possible*
17:29:12 <ddellacosta> first someone needs to tell me what OOP is then maybe I can tell you if it's nice or not
17:29:25 <Welkin> ddellacosta: java
17:29:34 <ddellacosta> Welkin: not nice
17:29:50 <fishythefish> 1980 - Alan Kay creates Smalltalk and invents the term "object oriented." When asked what that means he replies, "Smalltalk programs are just objects." When asked what objects are made of he replies, "objects." When asked again he says "look, it's all objects all the way down. Until you reach turtles."
17:29:50 <zenen> well java sucks regardless
17:29:55 <ddellacosta> that was easy
17:30:05 <ddellacosta> now maybe we can work on defining "functional programming"
17:30:17 <ddellacosta> fishythefish: so well put
17:30:19 <zenen> programming that doesn't involve side-effects
17:30:22 <johnw> the objectification of programs
17:30:49 <Welkin> ddellacosta: lambda calculus
17:31:18 <ddellacosta> Welkin: seems reasonable
17:31:25 <Welkin> zenen: no, effects are not generally part of the definition
17:31:30 <Welkin> it is more broad than that
17:32:25 <ddellacosta> the nice thing about starting with the lambda calculus is that it encompasses lisp as well as ML-family and descendants
17:35:47 <zenen> okay so, this is the the input that I'm working with:
17:36:36 <zenen> The first input line contains a positive integer, n, indicating the number of polycakes used in the ritual. This is followed by n data sets, each representing a single slicing of a polycake. The first line of each set consists of two integers, V (3 ≤ V ≤ 10) and Y (-1000 ≤ Y ≤ 1000), representing the number of vertices in the polycake and the y-coordinate of the horizontal cut, respectively. (Recall that the equation of a line para
17:36:36 <zenen> llel to the X-axis is of the form y=k.) The next V lines each contain two integers, x and y (-1000 ≤ x, y ≤ 1000), the Cartesian coordinates of the vertices of the polycake, in counter-clockwise order.
17:37:28 <zenen> Can someone give me an idea of how you would tackle the input of this problem functionally?
17:39:43 * hackage hpath 0.9.2 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.9.2 (maerwald)
17:42:57 <ddellacosta> zenen: what are you asking exactly--how you'd import that data in order to process the values in Haskell?
17:43:14 <ddellacosta> sounds like you're talking about some kind of CSV?
17:44:17 <zenen> the points are space separated
17:45:22 <zenen> i understand how to get lines, separate them into lists with "words" and use them as integers
17:45:50 <ddellacosta> okay so it's not about getting the data in--you're asking about how to structure a computation using that data?
17:45:54 <zenen> yea
17:47:07 <ddellacosta> okay, unfortunately I don't know what a polycake is so not sure I can be much help there, I'm sorry
17:47:51 <zenen> its a set of x,y coordinates
17:47:54 <ddellacosta> the way you describe it, it sounds alternately like a graph-like structure, or an equation
17:47:57 <ddellacosta> ah okay
17:49:11 <ddellacosta> so, what are you actually trying to do/solve?
17:50:11 <zenen> essentially, calculating the perimeters of two halves of a polygon, split along a horizontal line
17:51:36 <zenen> the first line of input gives a number of cases, each case contains a first line of "[number of vertices] [y-intercept for line]"
17:52:11 <zenen> the following lines are the x,y coordinates for each vertex
17:53:16 <pdxleif> Is there a preference for pure vs return? I've been using pure, but then I see commits like https://github.com/acid-state/acid-state/commit/0f0377f9709241af6e11cf3c42598183d8bc244f
17:53:48 <illiriex> exit
17:53:50 <ddellacosta> zenen: I'm not understanding what the "y-intercept for line"/"horizontal cut" is doing, can you explain, or point me at something online about this?
17:54:30 <ddellacosta> zenen: which is to say, do you intend to use that to calculate the perimeters of the two halves?
17:54:48 <pdxleif> Oh, I see it's to support older GHC - https://github.com/acid-state/acid-state/pull/91#issuecomment-368234428
17:54:54 <zenen> yes.
17:55:01 <ddellacosta> (in some fashion, I had assumed the pairs of coordinates/vertices were more important there...?)
17:55:37 <zenen> imagine a square with points at (1,1),(1,-1),(-1,-1),(-1,1)
17:55:44 <ddellacosta> this is probably where not understanding what a polycake is, is hindering me...haha
17:55:48 <ddellacosta> zenen: okay, with you so far
17:55:50 <johnw> which #ifdef will tell whether my Haskell file is being compiled on Linux?
17:56:15 <zenen> the y-intercept could be given as 0, which would put it directly through the middle of the square
17:56:43 <johnw> ah, __linux__
17:56:46 <ddellacosta> zenen: I see, so is the point that it divides the volume of the polygon equally in some fashion?
17:56:54 <zenen> and the values returned would be 3.0 and 3.0, as they are the perimeters of the squares on the top and the bottom
17:57:02 <ddellacosta> okay
17:57:16 <zenen> yes, the crux of the assignment is to see if the perimeters are equal or not
17:57:17 <ddellacosta> yeah, I think I'm starting to see, although I'm assuming regular polygons I guess
17:57:40 <zenen> the polygons are simple and convex
17:58:07 <marvin3> pdxleif, return makes the IO code superficially resemble that of an imperative languages. whether that is a pro or con is up for debate, but, IIRC, that was the main reason why it was named return
18:01:28 <malade_mental> Hi, I have a Matrix, and I'd like to replace every item of this matrix by a submatrix, which will depend on the value of the item it replaces
18:02:36 <zenen> sidenote: why does foo = words inputString work, but first = read $ head foo throw an error?
18:02:51 <jle`> zenen: what error?
18:03:14 <malade_mental> how to do thism I try to use fold but this seems to be a dead end
18:03:23 <jle`> malade_mental: what matrix type are you using?
18:03:30 <jle`> from what library?
18:03:37 <malade_mental> Data.Matrix jle`
18:03:46 <malade_mental> from the matrix library
18:04:23 <jle`> oh interesting
18:04:30 <zenen> jle`: Ambiguous type variable 'a1' arising from a use of 'read'
18:05:41 <malade_mental> I think I could manage this with lists jle` but I think this library is more accurate for what I'm trying to do
18:05:50 <jle`> malade_mental: Matrix has a Functor instance
18:06:02 <jle`> so you can just use fmap it
18:06:09 <jle`> and then 'flatten' might give you the right behavior
18:06:20 <jle`> zenen: that error means that ghc can't figure out what type you want to read things into
18:06:27 <jle`> zenen: read :: Read a => String -> a
18:06:37 <malade_mental> ty jle`
18:06:39 <jle`> so, every instance of Read gets to define the function differently
18:06:42 <ddellacosta> zenen: assuming I understand the problem, seems like you want to start by dividing the pairs of coordinates into two separate collections based on using the horizontal cut as a predicate in some way, and then generate a perimeter value from each collection, at the end comparing the two...as a first pass
18:07:00 <jle`> zenen: for example, the instance of Read for Int is completely different than the instance of Read for Double
18:07:13 * hackage servant-xml 1.0.1.2 - Servant support for the XML Content-Type  https://hackage.haskell.org/package/servant-xml-1.0.1.2 (fosskers)
18:07:16 <jle`> zenen: that error is ghc saying that it doesn't know what instance (and what function) to use
18:07:47 <jle`> zenen: usually in practice this isn't ana ctual problem, because you usually use the result somewhere so ghc can use type inference to figure out
18:08:11 <jle`> zenen: also just checking, where are you typing this in?  ghci?
18:08:50 <zenen> no, i'm writing the program separately and compiling with ghc
18:09:18 <jle`> ah okay.  yeah, in most programs, you'll end up using 'first' somewhere, and ghc will be able to tell what type you want from type inference
18:09:35 <jle`> but if you never use it anywhere, then there's no way for ghc to know which instance of Read you want to use
18:09:42 <jle`> remember, every single 'read' for every single type is a completely different function
18:09:51 <jle`> there's read :: String -> Int, read :: String -> Bool, read :: String -> Double, etc.
18:10:01 <jle`> they are completely different functions, they just happen to have the same textual identifier
18:10:24 <jchia> geekosaur: Yesterday when I asked, "I wonder why packages like binary and store don't document their serialization format.", you said, "so they can change it", but how does explicit documentation of the format prevent changing the format? If they want to change the format, they just need to update the documentation and do a major version bump.
18:10:30 <jle`> so if you just type 'read "hello"', there's no way for ghc to know which of the several hundreds and thousands and more 'read's you want
18:10:40 <zenen> hm, okay. So if I write more then the problem will resolve itself?
18:10:53 <jle`> if you use the result anywhere, ghc will probably be able to tell
18:11:04 <jle`> you can also give it a manual type annotation, as well
18:11:06 <marvin2> zenen, adding signature for your function (always a good practice) will likely fix the error
18:11:26 <marvin2> because ghc will be able to infer what read it needs to compile the code
18:11:31 <geekosaur> jchia, it's not just "not documented", it's "we explicitly don't document" which I recall being somewhere in the binary package. more specifically, "don't do anything that depends on the format, because we may need to change it without warning"
18:11:37 <zenen> i'm doing this in a let statement
18:11:54 <jle`> if it's not a top level binding, it's better practice usually to just let type inference do its job
18:11:59 <jle`> > let x = read "123" in x + 100
18:12:02 <lambdabot>  223
18:12:16 <jle`> there, ghc properly knows that you want (read :: String -> Int)
18:12:42 <jle`> er, that might not have been a good example
18:12:46 <jle`> > let x = read "True" in x || False
18:12:49 <lambdabot>  True
18:13:01 <xplat> it's not like not documenting the format will keep people from doing things that break if it changes tho
18:13:10 <geekosaur> sigh
18:13:20 <xplat> like, uh, serializing something to a file
18:13:24 <geekosaur> yes, I udnerstand that you believe there is precisely one right way to handle this situation
18:13:28 <xplat> that's not a temp file
18:13:40 <geekosaur> I also understand that not everyone agrees that there is precisely one right way to handle it
18:14:00 <geekosaur> if you want to complain that the maintainers of binary don't think like you do, complain to them.
18:14:09 <fishythefish> cf. "implementation-defined" vs "unspecified" in c++
18:14:49 <xplat> anyway, rather than complaining about it i just use binary-serialise-cbor instead
18:15:08 <zenen> ddellacosta, I'm having more trouble figuring out what functions to create in order to solve n cases, with m lines each
18:16:24 <zenen> what does the "in" keyword do compared to ommiting it?
18:16:36 <xplat> which uses a well-defined, rfc-specified serialization format that can even be read from other languages
18:17:11 <geekosaur> zenen, almost everything in Haskell is an expression, not a "statement"
18:17:39 <geekosaur> "do" expressions can pretend to be statements' "let" without "in" is part of that.
18:17:51 <geekosaur> @undo do { let { a = 5}; foo a }
18:17:51 <lambdabot> let { a = 5} in foo a
18:18:39 <geekosaur> feh, that ' was supposed to be ;
18:18:41 <xplat> if you use 'let' without 'in' and you're in a 'do' block, the 'let' scopes over the rest of the 'do' block and the scope is also part of the same do block
18:19:07 <xplat> when you aren't using 'rec' anywhere in the block it's basically the same as just using 'in do' at the end
18:19:15 <xplat> but it can be different when 'rec' is there
18:22:26 <jle`> Average-user: my backprop library has a stack bench
18:22:36 <jle`> or well, a bench in the cabal package
18:25:43 * hackage inchworm 1.0.2.2 - Inchworm Lexer Framework  https://hackage.haskell.org/package/inchworm-1.0.2.2 (BenLippmeier)
18:26:45 <zenen> okay, so when you're declaring the signature for a function, what does the (Num a) => portion do?
18:31:01 <jle`> myFunction :: a -> a is a polymorphic function that works for values of *any* type
18:31:14 <jle`> so you get myFunction :: Int -> Int, myFunction :: Double -> Double, etc.
18:31:21 <jle`> whatever it takes in, it returns someting of the same type
18:31:38 <jle`> myOtherFunction :: Num a => a -> a is the same thing, except you can only pick types that are instances of the Num typeclass
18:32:02 <jle`> so you can do myOtherFuntion :: Int -> Int, myOtherFunction :: Double -> Double, but not, say myOtherFunction :: Bool -> Bool
18:32:24 <jle`> it's called a typeclass constraint
18:32:49 <zenen> okay, that makes sense.
18:32:56 <jle`> if you're on ghci you can actually check what these functions look like with given types
18:33:04 <jle`> if you enable :set -XTypeApplications
18:33:17 <Lears> Stylewise, what are people's thoughts on f <*> g vs. \x -> f x (g x)? I used to find the former hard to read, but recently I'm finding cases where it seems a big enough improvement (e.g. removing lambdas and noise from dense expressions of nested brackets) for me to seriously consider inflicting it upon open source projects.
18:33:18 <jle`>  :t negate @Int
18:33:28 <jle`>  -> negate @Int :: Int -> Int
18:33:36 <jle`>   :t negate @Bool
18:33:39 <jle`>   -> type error
18:33:49 <MarcelineVQ> :t +d negate
18:33:50 <lambdabot> Integer -> Integer
18:34:17 <jle`> Lears: your asusmption is that removing lambdas is an improvement?
18:34:35 <MarcelineVQ> jle`: +d will use the extended default rules to get you a defaulted signature in case TypeApplications is too big a hammer
18:34:43 <jle`> i used to use f <*> g a lot when i first started, but now i would never do it
18:34:47 <jle`> i wouldn't be caught dead doing it :)
18:35:00 <jle`> MarcelineVQ: just wanted to help show that negate has different types, so you can try it out
18:35:08 <jle`> you can try out negate @Double, negate @Float, negate @Integer
18:35:11 <jle`> and see that they all work
18:35:13 * hackage servant-tracing 0.1.0.1 -   https://hackage.haskell.org/package/servant-tracing-0.1.0.1 (ChrisCoffey)
18:35:16 <jle`> but negate @String will not
18:35:40 <Lears> Not always jle`; I'm using plenty of lambda elsewhere. But in these particular cases they look a lot more cluttered.
18:35:53 <jle`> i don't think there's a single situation where f <*> g is more readable than the explicit pointful alternative
18:36:28 <jle`> #cmv
18:36:56 <jle`> or some other alternative that involves giving functions names
18:37:19 <jle`> there will never be a point where f <*> g is immediately understandable without having to mentally typecheck things in your head
18:37:49 <pavolzetor> hello, how do you do type punnig within foundation?
18:37:53 <pavolzetor> punning
18:38:05 <ReinH> Call it s or starling ;)
18:38:17 <jle`> and why would you want to force everyone who reads your code to basically emulate a typechecker in their head to understand your code
18:38:44 <jle`> Lears: your code might look "cleaner" and less noisy, but it will definitely be less readable
18:38:56 <ReinH> Or, you know, ap
18:39:39 <marvin2> jle` you feel pretty strongly about this
18:39:45 <ReinH> I do like Applicative for working with Reader for some things.
18:39:48 <marvin2> maybe it is just me, but f <*> g seems like a pretty common idiom
18:40:29 <jle`> can you think of a situation where f <*> g is more readable than the pointful or explicitly named form?
18:40:30 <caryoscelus> jle`: while i don't especially like <*> myself, i don't think it cannot be immediately understandable if you do it enough
18:40:48 <jle`> caryoscelus: you have to be able to recognize that f and g are functions
18:40:51 <jle`> and that the result is a function
18:41:09 <jle`> you can't do this without looking at the context and typechecking it in your head
18:41:13 * hackage buildbox 2.1.10.1 - Rehackable components for writing buildbots and test harnesses.  https://hackage.haskell.org/package/buildbox-2.1.10.1 (BenLippmeier)
18:41:18 <jle`> unless you rely on the names of f and g
18:41:25 <Welkin> jle`: http://www.lisperati.com/landoflisp/panel60.html
18:41:33 <Welkin> you mean this?
18:41:56 <jle`> ;)
18:42:29 <jle`> i use <*> all the time, it is pretty prevalent in my code
18:42:41 <Welkin> jle`: all you need is ap and const
18:42:43 <jle`> but i'll still take a few seconds to parse <*> when it's used by functions
18:42:44 <Welkin> who needs anything else?
18:42:49 <marvin2> jle`, I can't think of a situation where f <*> g would NOT be more readable than the alternative. maybe if I named non-functions f and g I'd think differently
18:43:38 <jle`> doTheThing x = something x (somethingElse x)
18:43:56 <jle`> doTheThing = something <*> somethingElse
18:44:03 <caryoscelus> well, if your f and g are in fact complex expressions, then it sure requires some thought, but if you have so complex expressions on one line you'll likely have to spend some time on mental parsing anyway
18:44:04 <jle`> most haskellers would understand both
18:44:13 <jle`> but they would probably understand the first much faster
18:45:01 <MarcelineVQ> to take the issue a step further, it's when they're more than one <*> is where the mental gears are going to have to grind, especially if there's . thrown in there
18:45:03 <jle`> especially if they are reading the codebase for the first time
18:45:13 <jle`> *or* re-reeading code they wrote six months later
18:45:23 <jle`> what would you rather see when you return to your code after leaving it for six months?
18:45:39 <Welkin> jle`: that is exactly the reason I avoid cleverness and golfing
18:46:00 <Welkin> to avoid asking myself "wtf was I thinking when I wrote this?" a year later
18:46:02 <Lears> This won't make much sense without context, but I've pasted some choice cases where I've had to ponder: http://lpaste.net/364700
18:46:30 <marvin2> it would only be less readable if you did not know that something and somethingElse were functions, and if their names didn't suggest they were functions
18:52:18 <zenen> alright, so I have a list of (x,y) coordinates, and I'm trying to see if sequential pairs of them cross over a certain y coordinate
18:52:27 <caryoscelus> Lears: would be much more readable to put "runLayout .." into a function. still presents a choice of what to use, but the choice between more easily-understandable parenthesis version and parenthesisless <*> version would be more obvious
18:53:50 <zenen> what's the haskell equivalent of iterating through a list?
18:54:17 <Welkin> zenen: iterating through a list
18:54:25 <zenen> would it be something along the lines of pattern matching on x:y:xs?
18:54:30 <Welkin> what do you think iteration is?
18:54:35 <Welkin> it is a form of recursion
18:54:49 <Welkin> so using a recursive function is equivalent to looping
18:54:55 <Welkin> or you can use a fold, of course
18:54:57 <Welkin> or map
19:01:27 <Lears> caryoscelus: That's complicated by tl, tr, bl and br all being different types, and having no nice way to jump between them and C T L, C T R, etc
19:03:49 <freeman42x]NixOS> can `eval = fst $ runState` be also used to define: https://github.com/tonymorris/fp-course/blob/master/src/Course/State.hs#L105 ?
19:05:24 <dsal> Is this a reasonable way to get a Monoid to compile on nightly?     instance Semigroup Helmert where (<>) = mappend
19:05:46 <dsal> Though I guess it probably feels better to do it the other way around.
19:07:24 <Lears> freeman42x]NixOS: runState :: s -> (a, s), so applying fst is a type error.
19:07:40 <dsal> Yeah, I'm going to do it the other away.  That makes a lot more sense.
19:09:03 <dsal> Is there a thing I can reference when I send this pull request?  Something about how a Monoid has to explicitly be a Semigroup now?
19:09:25 <dysfigured> i'm coming from javascript, it has a 'native' event loop to handle async things, python and perl have them as separate libraries i think, C you have to implement everything yourself, how can i conceptualize how haskell/ghc deals with async i/o and stuff? is it just a side effect of it's natural lazy-eval?
19:09:30 <freeman42x]NixOS> Lears, sorry, I meant to say `exec sa s = fst $ runState sa s`
19:09:30 <Lears> freeman42x]NixOS: Looks like you can define it point-free with runState if you use the blackbird combinator (...) = \f g x y -> f (g x y)
19:09:36 <dsal> Er, damnit.  For backwards compatibility, I still have to implement mappend.
19:13:13 * hackage rattletrap 4.0.8 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-4.0.8 (fozworth)
19:16:29 <zenen> alright, I'm a little bit lost. I'm trying to implement a function that takes a sequential list of xy coordinates, and divides them into two groups according to whether or not they're greater or less than a y value
19:16:54 <zenen> the hard part is that if two sequential points cross the y value, I need to add the intersection two both groups
19:17:02 <zenen> is there any way to implement this with a filter?
19:21:03 <Jie> Can I ask for help? I have this piece of code here http://lpaste.net/364702 that doesn't work
19:21:48 <Jie> I get an error "Could not deduce (Flight f0) arising from a use of ‘check’"
19:21:48 <geekosaur> "doesn;t work" doesn't tell anyone much
19:22:07 <glguy> Yes you can ask for work. You should actually include the error message you don't understand in the paste, don't paraphrase it for us
19:22:35 <glguy> Jie: You might be misunderstanding what typeclasses are for
19:22:38 <geekosaur> also it looks to me like you're an OO programmer trying to use typeclasses as OOP classes. they aren't, and it won't work
19:22:58 <Jie> I'm not a OO programmer but it is my first time defining a class
19:23:23 <Psybur> Jie you probably want records instead of classes
19:23:59 <Jie> the problem is, I have two types of records, coming from two different modules
19:24:10 <Jie> I'm trying to write a function that will work on both types
19:24:17 <nshepperd> zenen: pattern matching on x:y:xs is a good way to write a recursive function that works on pairs of elements, yes
19:26:47 <Jie> Am i correct in guessing that flights :: (Flight f) => i -> [f] is not enough to guarantee that flights will always give out a list of Flights?
19:27:39 <zenen> nshepperd: how would I keep track of the first value of the list to compare it to the last?
19:28:17 <dsal> This thing defines two monoids (that broke because of the semigroup thing).  I figured while I was in there, I'd add monoid law tests for them.  They shall not pass.
19:28:23 <nshepperd> zenen: oh, this is supposed to be a closed polygon?
19:28:40 <zenen> nshepperd, yes
19:29:27 <zenen> should I just append the first value to the end of the list before processing it?
19:29:35 <nshepperd> that's what I would do, I think
19:31:21 <geekosaur> Jie, the type signature is a contract. Your code has to honor it, by producing something known to have that instance.
19:32:06 <nshepperd> zenen: since you're really concerned with line segments here, maybe it would make sense to preprocess the list by making a list of pairs first?
19:32:29 <nshepperd> [a, b, c] -> [(a, b), (b, c), (c, a)]
19:32:42 <nshepperd> then you can filter the segments easily
19:33:15 <zenen> hmm
19:34:14 <Psybur> Jie, well it could be an empty list
19:34:17 <jle`> Jie: flights will generate a list of 'f', where f is any instance of Flight that the user wants
19:34:21 <zenen> yea that makes sense.
19:34:27 <Jie> geekosaur, the code definitely would, but I still get a compilation error which I don't understand...
19:34:31 <Jie> here http://lpaste.net/364702#a364703
19:35:13 <jle`> Jie: that error happens when ghc can't pick which instance you want
19:35:44 <jle`> Jie: remember that every instance of 'Flight' gets to define arrivalAirport however it wants
19:35:45 <Jie> between which ones? There is only one instance of Flight
19:36:00 <jle`> Jie: so the choice of which Flight instance will determine what string you have, the result of 'check'
19:36:03 <Psybur> Jie, oh you didnt make instances for your classes? :D
19:36:33 <jle`> Jie: you aren't really allowed to say "pick the only instance", since tpyeclass instances are global
19:36:41 <Jie> Not yet, because I want airportConflicts to work for any inctance
19:36:50 <jle`> any instance of Flight, right?
19:37:04 <Psybur> Or is that what you said is coming in from the other module and not shown here in the code
19:37:19 <jle`> Jie: know that airportConflicts will return a *different* result, depending on which Flight instance you give it
19:37:24 <jle`> depending on which Flight instance it uses
19:37:42 <jle`> do you see why?
19:38:10 <jle`> that's why ghc gives you that error
19:38:34 <jle`> or well, not directly why
19:38:45 <Jie> Is there a way to make the flight function from Itinerary guarantee that it gives out a [Flight], for any instance fo Itinerary/Flight?
19:38:53 <jle`> there is no such thing as a [Flight]
19:39:14 <jle`> Flight is not a type you can have values of
19:39:16 <jle`> it's a typeclas
19:39:24 <Jie> Yes, sorry, I meant [Flight f]
19:39:29 <jle`> that is also not a type
19:39:34 <Jie> or rather (Flight f) => [f]
19:39:34 <jle`> that you can have values of
19:39:47 <jle`> yes, that's what it does right now
19:40:03 <jle`> it gives a list of f, for *any* Flight instance that the *caller* asks for
19:40:23 <Jie> right, that's what I need
19:40:26 <jle`> for a type like flights :: Flight f => i -> [f], the *caller* of flights gets to pick which f they want
19:40:32 <jle`> so, that's already what you have
19:40:36 <jle`> the caller gets to decide what instance
19:41:05 <Jie> Right, but can't I make airportConflicts for for any instance?
19:41:05 <jle`> so that's the problem here in line 9 -- the caller has to pick the instance of Flight, but there is indication of what it wants to pick
19:41:30 <jle`> yes, but you have to somehow indicate what instance you want
19:42:02 <Jie> Does that mean you can't make a function f :: (Num a, Monoid b) => a -> b
19:42:16 <Jie> that would work for any Num and Monoid?
19:43:17 <Jie> Or do I have to somehow include the class definition of Flight into Itinerary?
19:43:32 <orbisvicis> I'm pattern matching many inputs, each to modify a different field of a type. Is there any way to reduce code duplication ?
19:44:23 <lyxia> show an example
19:45:50 <johnw> for megaparsec, is it better to parse strict text or lazy text?
19:47:15 <ReinH> johnw:  o/
19:47:20 <johnw> hi!
19:48:17 <zenen> how can I map a list with a function that takes multiple inputs
19:48:19 <ReinH> Jie: can you turn ANY instance of Num into ANY instance of Monoid?
19:48:36 <Jie> Sure, \ _ -> []
19:48:45 <Jie> well ok, not any instance of mooned, good point
19:48:54 <Jie> monoid*
19:49:06 <mud> :t const mempty
19:49:08 <lambdabot> Monoid a => b -> a
19:49:25 <Jie> ah, thanks :)
19:49:29 <mud> Though that's a fairly useless function really
19:49:55 <Jie> of course, but that's fine :)
19:50:00 <orbisvicis> lyxia: http://lpaste.net/364704
19:51:15 <lyxia> oh tricky
19:52:28 <lyxia> do 1,2,3 really have to be runtime values
19:53:14 <lyxia> and is Z always a single constructor with fields of the same types
19:53:51 <jle`> Jie: you can make such a function
19:53:55 <orbisvicis> lyxia: yes & yes
19:54:13 <dsal> zenen: what do you mean?  Functions take one input.
19:54:20 <jle`> Jie: your function will work for any instance of Flight, but when you actually use 'flights', you have to specify which instance you want in the moment
19:55:05 <zenen> dsal: multiple arguments, sorry. Namely, the value and the next sequential value in the list
19:55:10 <Jie> not really, I can use fmap any time I have a functor without knowing which instance I have
19:55:29 <jle`> Jie: can you though?
19:55:55 <dsal> zenen: It's not totally clear what you want to do.  In general, a function takes one argument and returns one value... but can you give an example of what you're trying to do?
19:56:17 <jle`> Jie: check out a similar situation to yours:
19:56:18 <zenen> I'm trying to make a list of pairs
19:56:26 <jle`> roundTrip = show . read
19:56:33 <jle`> roundTrip :: String -> String
19:56:39 <jle`> Jie: do you see why that causes issues as it is?
19:56:58 <jle`> @let roundTrip :: String -> String; roundtrip str = show (read str)
19:57:00 <lambdabot>  .L.hs:159:1: error:
19:57:00 <lambdabot>      The type signature for ‘roundTrip’ lacks an accompanying binding
19:57:00 <lambdabot>      |
19:57:05 <jle`> @let roundTrip :: String -> String; roundTrip str = show (read str)
19:57:08 <lambdabot>  Defined.
19:57:23 <jle`> oops, that's a bit unfortunate that it works, but it's not supposed to heh
19:57:39 <jle`> but do you see why it's iffy?
19:57:42 <rotaerk> > roundTrip "5"
19:57:42 <Jie> it does work though haha ^^
19:57:44 <zenen> dsal: something like [1,2,3] -> [(1,2),(2,3)]
19:57:45 <lambdabot>  "*Exception: Prelude.read: no parse
19:57:54 <jle`> Jie: heh, yeah, but it's kind of a bad coincidence
19:57:57 <jle`> Jie: what do you think it does?
19:58:13 <jle`> what do you think the roundTrip function does when it is given a string?
19:58:16 <dsal> > let p a = zip a (tail a) in p [1, 2, 3]
19:58:18 <lambdabot>  [(1,2),(2,3)]
19:58:19 <marvin2> > let xs = [1,2,3] in zip xs (tail xs)
19:58:22 <lambdabot>  [(1,2),(2,3)]
19:58:26 <Jie> right, it doesn't know what to read it into
19:58:58 <jle`> yes, there is no hint in the type for type inference to do its job
19:59:09 <jle`> you have to figure out a way to tell ghc which read instance you want to use
19:59:19 <lyxia> orbisvicis: there's stuff you can do with generics indeed, but what do you say of this http://lpaste.net/364705
19:59:27 <dsal> > let p a = zipWith (+) a (tail a) in p [1, 2, 3]
19:59:27 <jle`> one way is to include it in a type signature, so the caller can say
19:59:30 <lambdabot>  [3,5]
19:59:51 <jle`> @let roundTrip' :: String -> (a, String); roundTrip' str = let x = read str in (x, show x)
19:59:52 <lambdabot>  .L.hs:165:26: error:
19:59:52 <lambdabot>      • No instance for (Read a) arising from a use of ‘read’
19:59:52 <lambdabot>        Possible fix:
20:00:01 <jle`> @let roundTrip' :: Read a => String -> (a, String); roundTrip' str = let x = read str in (x, show x)
20:00:03 <lambdabot>  .L.hs:165:42: error:
20:00:03 <lambdabot>      • Could not deduce (Show a) arising from a use of ‘show’
20:00:03 <lambdabot>        from the context: Read a
20:00:16 <jle`> @let roundTrip' :: (Show a, Read a) => String -> (a, String); roundTrip' str = let x = read str in (x, show x)
20:00:18 <lambdabot>  Defined.
20:00:26 <jle`> > roundTrip' "5" :: (Int, String)
20:00:26 <zenen> dsal, marvin2 thanks!
20:00:28 <lambdabot>  (5,"5")
20:00:38 <jle`> > roundTrip' "True" :: (Bool, String)
20:00:41 <lambdabot>  (True,"True")
20:00:42 <jle`> > roundTrip' "True" :: (Int, String)
20:00:45 <lambdabot>  (*Exception: Prelude.read: no parse
20:01:08 <Psybur> Jie, I think more might be wrong with your code after you fix your instance issue? heh unless this new error message is actually related to the change I made :D https://glot.io/snippets/f01b5bjo5t
20:01:14 <dsal> Current yak:   Try to build my thing with --resolver=nightly.  Fails due to lib that doesn't build against nightly due to Monoid v. semigroup.  Fixed that.  Used checkers to validate their monoid laws.  Fails.  Filed bug.  Realized they may just want semigroup.  Sees checkers doesn't support semigroup.  Added semigroup support to checkers…
20:01:19 <marvin2> zenen cool thing about it is that it works on infinte list
20:01:22 <marvin2> > let xs = [1..] in zip xs (tail xs)
20:01:25 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
20:01:52 <jle`> Jie: alternatively, you can have the function some dummy argument to specify the type you want
20:02:32 <VitorCBSB> Hey buds, I'm trying to draw a julia set (ASCII), but it's not drawing anything? I couldn't find the mistake in my code, could someone lend me a hand please: http://lpaste.net/364706
20:02:51 <jle`> @let roundTrip'' :: forall dummy a. (Show a, Read a) => dummy a -> String -> String; roundTrip'' _ str = (show :: a -> String) (read str)
20:02:52 <lambdabot>  Defined.
20:02:52 <zenen> cool! can you break it down a little more for me? I'm having trouble parsing what you did
20:03:00 <Jie> jle, that's probably helpful
20:03:23 <jle`> > roundTrip'' (Nothing :: Maybe Int) "6"
20:03:27 <lambdabot>  "6"
20:03:41 <jle`> > roundTrip'' (Proxy :: Proxy Bool) "True"
20:03:42 <zenen> actually gimme a sec to play with it
20:03:44 <lambdabot>  "True"
20:03:49 <zenen> i'm gonna try and figure it out
20:03:55 <marvin2> zenen zip takes two lists and turns them into a list of pairs. we zipped a list with its own tail
20:04:08 <jle`> Jie: i think in your case the first way might make sense, you can return a list of the flights that fail
20:04:39 <jle`> Jie: airportConflicts :: (Itinerary i, Flight f) => i -> [f]
20:04:58 <zenen> oh shit i think I see what happened
20:05:14 <zenen> so basically, taking the tail basically offsets the list by one
20:05:31 <marvin2> yes
20:05:53 <zenen> neat!
20:06:19 <jle`> Jie: alternatively, once you start writing the instances, you might start realizing that the type of 'flights' is not actually what you want
20:07:05 <jle`> Jie: it might be that you don't want itinerary to return *any* instance of Flight that the caller wants
20:07:12 <jle`> Jie: you might want it to return a *specific* instance
20:07:35 <slaterr> is parsec still the parser to use?
20:07:42 <jle`> Jie: in fact, as it is written, the only possible implementation of 'flights' for any possible instance is 'flights _ = []'
20:07:57 <jle`> slaterr: megaparsec is the modern parsec
20:08:13 * hackage buildbox 2.1.11.1 - Rehackable components for writing buildbots and test harnesses.  https://hackage.haskell.org/package/buildbox-2.1.11.1 (BenLippmeier)
20:08:16 <jle`> i think parsec dev stalled and megaparsec is the fork that is being actively maintained
20:08:42 <slaterr> it is mostly backward compatible?
20:09:12 <jle`> its inteface is consistent with the modern haskell ecosystem
20:09:16 <Jie> instances of Itinerary will be records that do contain record Flight
20:09:18 <orbisvicis> lyxia: yeah, that's a good idea
20:09:19 <jle`> it's more of an update
20:09:36 <jle`> Jie: of specific Flight instances?
20:09:49 <jle`> or polymorphic records of any possible Flight instance the user might ask for?
20:09:51 <dsal> OK.  checkers now supports testing semigroups.  Not that it matters because the library I depend on that breaks monoid laws also breaks semigroup laws.  But I can see that without the distraction of the monoid laws it breaks now.
20:10:33 <zenen> what's the problem with calling list' = list:(head list)
20:10:33 <dsal> zenen: zipWith lets you substitute your own function in there
20:10:37 <dsal> :t zipWith
20:10:38 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
20:10:52 <jle`> zenen: what are the types, of everything?
20:11:15 <jle`> zenen: if list is [a]
20:11:21 <zenen> Integers
20:11:23 <jle`> zenen: then (:) :: [a] -> [[a]] -> [[a]]
20:11:30 <jle`> zenen: not quite integers
20:11:33 <jle`> most of them are lists
20:11:53 <zenen> how do i make an integer into a singleton list
20:11:58 <jle`> [x]
20:12:08 <jle`> > [1]
20:12:11 <lambdabot>  [1]
20:12:13 <dsal> zenen: What's the bigger picture here?
20:12:57 <zenen> I'm trying to duplicate the first tuple in a list onto the end of the list
20:13:14 <jle`> you'd probably use ++ for that then
20:13:22 <Jie> jle, thank you for your help, I will explore different ways
20:13:25 <lyxia> VitorCBSB: look at the number of iterations for each cell
20:13:34 <lyxia> VitorCBSB: they never reach 50
20:13:36 <jle`> Jie: if you try to write an instance, you will see the issue immediately :)
20:13:58 <zenen> jle`, yep that does it
20:14:07 <dsal> > let xs = [1, 2, 3] in xs <> take 1 xs
20:14:08 <jle`> Jie: it might be more likely that any instance of Itinerary can produce only a *specific* instance of Flight
20:14:09 <lambdabot>  [1,2,3,1]
20:14:18 <zenen> what's the difference between ++ and :
20:14:23 <lyxia> VitorCBSB: set the imaginary part to 0 and you can see some output, so the issue is probably that the grid is not fine enough.
20:14:27 <jle`> zenen: look at the types
20:14:38 <dsal> :t (:)
20:14:39 <lambdabot> a -> [a] -> [a]
20:14:48 <dsal> :t (++)
20:14:49 <lambdabot> [a] -> [a] -> [a]
20:14:51 <jle`> that's always the answer in haskell
20:14:53 <jle`> follow the types
20:15:21 <Jie> jle` yes, I see you're right
20:15:28 <slaterr> zenen did you figure it out just by looking at the types?
20:16:14 <jle`> Jie: if that is the case you might want to look into multiparameter typeclasses and functional dependencies
20:16:17 <zenen> FOLLOW THE TYPES
20:16:30 <jle`> class Itinerary f i | i -> f where
20:16:37 <jle`> er
20:16:39 <zenen> in my severely sleep deprived state, I have ascended to another plane
20:16:47 <jle`> class Flight f => Itinerary f i | i -> f where
20:16:52 <jle`>   flights :: i -> [f]
20:16:53 <dsal> zenen: Also, note that my implementation of your thing also works for infinitely long lists.  heh
20:17:01 <dsal> > let xs = [1..] in xs <> take 1 xs
20:17:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:17:14 <jle`> Jie: an 'Itenerary X Y' is a class that says itinerary Y can produce flights of type X
20:17:19 <dsal> the list goes onto infinity, and then has a 1 right after ∞
20:17:52 <jle`> Jie: and the fundep ensures that each itinerary type has a specific flight type associated with it
20:18:19 <VitorCBSB> lyxia: Ah... maybe? Maybe the limit (< 2) is too small? I'm looking at another code that uses 47 as the limit (https://github.com/AnotherKamila/composing_fractals/blob/master/Fractals.hs).
20:18:26 <zenen> :t (<>)
20:18:27 <lambdabot> Monoid m => m -> m -> m
20:18:41 <Jie> very nice
20:18:49 <dsal> > let xs = [1..7] in xs ++ take 1 xs
20:18:52 <lambdabot>  [1,2,3,4,5,6,7,1]
20:18:58 <dsal> I tend to not use ++
20:19:02 <jle`> Jie: if you don't have the fundep (class Itinerary f i where ...) then you run into the same problems
20:19:09 <jle`> or well, you run into the same problem that you originally asked about
20:19:21 <Jie> That compiles
20:19:31 <jle`> but you at least solve the deeper second problem about flights being too polymorphic :)
20:19:56 <zenen> how do I load functions into ghci from a text file
20:20:01 <dsal> :l
20:20:07 <lyxia> VitorCBSB: yeah that's another thing you could tweak
20:20:07 <VitorCBSB> lyxia: Strangely, I can print the mandelbrot set just fine by just moving the parameters to the correct place.
20:20:09 <dsal> Or :{ and :}
20:20:41 <zenen> ahaha I thought those were emoticons
20:21:31 <lyxia> VitorCBSB: The Mandelbrot set is pretty thick
20:22:34 <Jie> Thanks again jle`
20:23:07 <VitorCBSB> lyxia: Uggh... I think I'll try sleeping on it, it's pretty late here. Thanks for the help, I appreciate it. :)
20:23:32 <zenen> yea you guys are so helpful
20:24:07 <zenen> this irc makes me want to learn haskell more than my 4 month university course did
20:27:10 <Cale> zenen: also you can give the source file as an argument to ghci on the commandline
20:27:25 <Cale> zenen: (and then :r to reload it whenever you save changes)
20:33:18 <lyxia> orbisvicis: http://lpaste.net/364707
20:43:09 <pavonia> What's the best way to debug Binary instances? When running the `get' parser, I just get "not enough bytes" which is not too helpful
20:44:13 <jle`> there might be able to run the parser with some more diagnosticcs
20:44:25 <jle`> you can also try trace debugging
20:44:30 <glguy> pavonia: Using label :: String -> Get a -> Get a  and isolate
20:45:32 <pavonia> label looks promising, thanks
20:46:15 <orbisvicis> lyxia: wow I'm definitely going to be avoiding that
21:07:20 <Axman6> zenen: it's worth remembering most university courses which use haskell are not really intended to teach you haskell, but some other topic
21:09:47 <jackcrfs> newbie question.  is there a "canoncial documentation" for Haskell?  I intuitively thought I should see something like doc for Prelude for 7.x and 8.x; but at least from haskell.org things look a bit different; am I expected to run haddock on the Haskell source tar bar?
21:09:51 <jackcrfs> tar ball?
21:10:28 <glguy> You can get package documentation on hackage: eg http://hackage.haskell.org/package/base-4.11.0.0/docs/Prelude.html
21:10:46 <jackcrfs> thanks, but how does that relate to haskell version string i.e. 8.2?
21:11:50 <jackcrfs> hm, I take it there is NO logical relationship then?  8.2 would refer to the language itself, before Prelude is loaded?
21:11:55 <mud> jackcrfs: There is a 1-1 mapping between base versions and GHC versions, but you pretty much have to look up the list
21:11:55 <glguy> You can run "ghc-pkg list" to see the versions of packages that come with GHC, like base
21:12:01 <jackcrfs> i see
21:12:11 <glguy> https://www.haskell.org/platform/contents.html
21:12:15 <glguy> This is pretty handy
21:12:51 <jackcrfs> ah! ghc-pkg list has a diff list for package under ghc-8.2.2 directory
21:12:51 <mud> Ah, nice that is a good list
21:13:21 <jackcrfs> because those are in system wide path; whereas things I installed are in my homedir
21:13:54 <jackcrfs> oh and the web list is helpfull too
21:22:27 <Axman6> hackage is the cannonical location for haskell package documentation
21:33:25 <zenen> pointAtY :: ((Int,Int),(Int,Int)) -> Int -> (Int,Int)
21:33:44 <zenen> what should I change this two if the values in the output might be fractional?
21:34:31 <dsal> Ick, too many tuples.
21:34:50 <dsal> Not enough information to really understand, though.  What do you need to do with all those ints?
21:36:07 <zenen> They're all coordinates, I'm trying to find a point on a line between two points given a Y value
21:36:25 <zenen> also:
21:36:29 <zenen> pointAtY :: (Fractional a) => ((a,a),(a,a)) -> a -> (a,a)
21:36:37 <zenen> I'm learning!!
21:44:56 <dsal> The question was lower level than that.   :)  What operations are you performing on stuff?
21:54:43 <jhrcek> Where can I found source code for GHC User guide (as published at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/)?
21:54:58 <jhrcek> I found some typos and I'd like to submit PR with corrections..
21:56:22 <jchia> I want to express a heterogeneous list of elements that all satisfy a certain constraint C. Then I want to map a function (f :: forall a. C a => a -> b) over the heterogeneous list to get a [b]. Is there a package I can use? Maybe using dynamic typing (Data.Dynamic) with '[Dynamic]', deferring type-checking to run-time and being careful not to cause a run-time type error in practice entails more readable code?
21:58:37 <jchia> I like static typing, but sometimes the code needed to express certain ideas is really quite complicated.
21:59:19 <jchia> And complicated code takes longer to write and is harder to maintain.
21:59:26 <nshepperd> first ask yourself why you need to do that instead of applying the function first before creating the list
22:00:23 <zenen> if I have a function a->b->c, how do I map it to different a values in a list for a given b
22:01:06 <nshepperd> then if you still need to do it you can wrap each item in the list in a gadt: data SomeC where { SomeC :: C a => a -> SomeC }. then your list will be [SomeC]
22:01:33 <dsal> zenen: What do you mean "in a list"?
22:01:43 <nshepperd> but usually 'heterogenous list constrained by a typeclass' is an antipattern
22:01:59 <dyl> It sounds like a list of existential.
22:02:06 <dyl> Existential.
22:02:11 <dyl> Existentials* Christ
22:02:46 <nshepperd> yeah, existential, not really heterogenous in the same way as a HList is
22:02:47 <zenen> dsal, pointAtY :: (Fractional a) => ((a,a),(a,a)) -> a -> (a,a)
22:02:48 <dsal> zenen: Can you give an example?
22:02:55 <dyl> What nshepperd suggested is what I’d do.
22:03:17 <dyl> Heterogenous dynamically, but do you really need dynamic typing at runtime, or just dispatch?
22:03:17 <jhrcek> jchia: you might want to check out existential types: https://github.com/PacktPublishing/HaskellCookbook/blob/master/Ch_10-Working_with_Advanced_Haskell/working-with-existentials/src/Main.lhs
22:03:38 <zenen> i want to apply this function to a list of lines in the form ((a,a),(a,a)), but with a given value for the second argument
22:03:49 <dsal> :t flip lookup
22:03:51 <lambdabot> Eq a => [(a, b)] -> a -> Maybe b
22:04:14 <Cale> zenen: map (\x -> f x y) xs, where f :: a -> b -> c, and y :: b, and xs :: [a]
22:05:10 <dsal> "given value for the second argument" sounds like your arguments might be backwards.
22:05:38 <jchia> nshepperd: In Python there 3 similar, related, classes (command base class) that have constructors with slightly different signatures. In Haskell I have 3 similar functions that need to create Python objects of these classes. I prefer using one function to bridge Haskell and python for the construction rather than make 3 slightly-different ones because the only difference is some list that I need to make to give to a CPython function. My 3 Haskell functions c
22:05:43 <Cale> But yeah, if you have a choice of the order of arguments to f, perhaps consider swapping them around
22:05:55 <zenen> aight
22:05:57 <Cale> So that then you'd be able to write map (f y) xs
22:06:00 <halogenandtoast> Any suggestions on this, when I run `stack install hpack-convert` I'm getting `Hpack/Util.hs:106:21: error: Couldn't match type '[[FilePath]]' with '([[FilePath]], b0)'`
22:06:26 <halogenandtoast> Is there some sort of known incompatibility?
22:07:27 <cocreature> halogenandtoast: take a look at the issue tracker, e.g., https://github.com/yamadapc/hpack-convert/pull/16
22:07:41 <Cale> zenen: A general style rule of thumb (which actually sometimes extends beyond style to performance) is that generally you want the arguments to a function to be in order of increasing expected variation -- so the more "constant-like" or "configuration-like" arguments go first, and then the ones which vary more rapidly are at the end.
22:08:07 <dsal> There's flip when it doesn't work out, but that's kind of akward.
22:08:10 <dsal> :t flip
22:08:11 <lambdabot> (a -> b -> c) -> b -> a -> c
22:08:25 <Cale> I usually prefer to just write a lambda to using flip
22:08:31 <cocreature> Cale++
22:08:33 <halogenandtoast> cocreature: yeah looks like that covers the issue
22:08:37 <zenen> Sounds like a good rule
22:08:48 <zenen> it created an error though
22:08:51 <zenen> No instance for (Fractional Int) arising from a use of ‘pointAtY’
22:09:07 <halogenandtoast> But unmerged since February :(
22:09:11 <Cale> ah, well, that means that you're using something like (/) on an Int
22:09:31 <zenen> I am
22:09:32 <cocreature> halogenandtoast: yeah that project doesn’t seem to be maintained particularly actively
22:09:37 <Cale> If you want integer division, that's div
22:09:37 <dsal> zenen: this is why I was asking you what you were doing with those values.  :)
22:09:48 <dsal> :t (/)
22:09:50 <lambdabot> Fractional a => a -> a -> a
22:09:53 <nshepperd> zenen: You probably want to use Double or something for these geometric calculations, instead of Int
22:09:54 <Cale> If you want fractional division, you'll have to convert the numbers to some fractional type first
22:10:02 <Cale> fromIntegral works well for that
22:10:07 <nshepperd> zenen: or maybe Rational if you need it to be exact
22:10:09 <halogenandtoast> Guess I can install from source. Thanks cocreature
22:10:18 <Cale> :t fromIntegral
22:10:19 <lambdabot> (Num b, Integral a) => a -> b
22:10:30 <Cale> ^^ converts from any integer-like type to any numeric type at all
22:12:21 <Cale> (or yeah, if just using Double or something in the first place makes more sense, you can just do that)
22:12:44 <dsal> I'm stuck in dimensional.  It's got a type 'dimensionless' that's all in my way.
22:14:41 <zenen> well, :%s/Int/Double/g worked
22:15:41 <zenen> i'm so close to done
22:20:21 <dsal> My checkers PR is failing on older GHCs.  Is there a way to handle this in code?  https://travis-ci.org/conal/checkers/builds/365418411?utm_source=github_status&utm_medium=notification
22:20:26 <dsal> (no Data.Semigroup)
22:21:45 <cocreature> dsal: add a conditional dependency on the semigroups package
22:23:25 <dsal> Hmm...  I don't know how to do that.  It seems that stopping support for newer versions on older compilers might be a good option.
22:24:02 <cocreature> depends on whether the maintainer is fine with that :)
22:26:09 <dsal> Yeah.  I'm done throwing patches around for the evening.  I spent way too long trying to figure out how to get a small "dimensionless" value.  I don't know how this thing works.
22:32:20 <zenen> how would I go about making a function that takes [(1,2),(3,4)] and [5,6] as inputs and outputs ([(1,5),(3,6),(5,6)],[(2,5),(4,6),(5,6)])
22:33:01 <zenen> there's gotta be a better way
22:34:25 <zenen> i'm dying inside
22:34:26 <cocreature> zenen: not sure what the general pattern is here, what should be the result of [(1,2),(3,4)] and [5,6,7]?
22:35:05 <EvanR> failing the IQ test
22:35:40 <cocreature> heh, I’m fine with that :)
22:36:27 <zenen> there's no general pattern
22:36:43 <zenen> there's just a geometric one
22:36:50 <EvanR> guessing, the question is, whats the result of [(1,2),(3,4),(5,6)] [7,8,9]
22:37:00 <zenen> I have two lines: | |
22:37:13 <zenen> I am drawing a line between them: |-|
22:37:55 <zenen> and I need to separate the upper and lower halves
22:39:11 <zenen> okay there's a better way to explain this
22:39:13 <cocreature> you want a function that takes [(1,2), (3,4)] and [5,6] as inputs and produces ([(1,5), (3,6), (5,6)], [(2,5), (4,6), (5,6)]). what should be the result of that function if I apply it to [(1,2), (3,4)] [5,6,7]
22:41:40 <zenen> I have two lines, which are recorded as a tuple of coordinates
22:42:04 <zenen> I have two points which exist along those lines
22:43:18 <zenen> and I need to find some way to create two new sets of lines
22:44:59 <EvanR> a line as the unending horizon, a point as a distant bird
22:47:23 <zenen> EvanR, now you're speaking my language
22:50:43 * hackage rio 0.1.1.0 - A standard library for Haskell  https://hackage.haskell.org/package/rio-0.1.1.0 (MichaelSnoyman)
23:25:13 * hackage monad-logger 0.3.28.4 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.28.4 (MichaelSnoyman)
23:28:45 <frerich> Hi all! I'm currently toying with a 'new' (to me) approach to writing turn-based games in Haskell. Instead of having the UI be the 'driver' of the application, I'd like to make the 'Engine' the driver. My idea was that the Engine asks the current player for the next move, but since the current player might be remotely connected, I need to pass some sort of function which should be invoked once a turn was made (i.e. I cannot block).
23:29:07 <frerich> Is there a common 'pattern' for this in Haskell - is this 'Next function to call once the remote side made a move' a continuation? :-)
23:34:16 <EvanR> board game, so you have a list of moves, initially empty. the current board is a fold over the moves, starting with the initial board. the rules determine whether a move in question may be allowed to be stacked on
23:34:54 <EvanR> the move list is the source of truth
23:35:22 <EvanR> e.g. in chess, castling legality cant be verified using just a board
23:36:42 <frerich> Yeah, that's what I have right now. It all works very well -- but now I'd like to allow games over the internet. I.e. one (or maybe both) player is remotely connected. And a player could be a human player or a CPU. So my idea was that each 'player' of a game needs to provide a function like 'Game -> IO Move', i.e. the engine asks a player for its next move. And then the engine can validate (and potentially reject) that.
23:37:53 <EvanR> central server?
23:41:36 <frerich> Yeah, that's what I'm trying to do. I think my central question is whether it would be better to have a synchronous 'Game -> IO Move' function for each player, which blocks until the player returned a move, or whether it would be better to have an asynchronous function which just means 'it's your turn, please decide on a move' and that function gets an argument passed which should be invoked to actually perform the move.
23:42:40 <EvanR> is there ever any race to see which player moves first
23:43:22 <frerich> No, one player after the other does a move. I.e. the engine would first ask the first player for his move, propagate that to all others, then ask the next player and so on.
23:46:06 <EvanR> i experimented with this model, its a bit inside out with respect to yours. each player is running this game locally. they cant make an illegal move because it stops them locally. this includes, not their turn.
23:47:10 <EvanR> what you can do is... make a legal move by sending it to the central server. which is relayed to everyone. or you can get a legal move from the server to apply locally
23:47:35 <EvanR> the beauty of it is the server doesnt have to actually know anything about the game
23:47:55 <EvanR> cheating is stopped locally
23:48:23 <EvanR> this is all easy if the game is totally turn based, no race to see who plays next, like uno
23:49:06 <EvanR> but, i solved it for non turn based too. including real time death match
23:49:35 <boj> how do you trust locally verified data to be correct?
23:50:09 <dminuoso> boj: They were verified. Why wouldn't you trust them!
23:50:12 <EvanR> there is no verified data
23:50:38 <EvanR> you get moves, which you must verify
23:52:11 <[exa]> frerich: in fact you're hitting distributed database consistency problems
23:52:12 <boj> so you have to trust who you are playing with and assume they won't cheat somehow
23:52:44 <EvanR> thats the exact opposite thing
23:52:57 <EvanR> you dont trust them or assume they wont cheat
23:53:15 <EvanR> for turn based, thats the whole point of verification
23:53:32 <EvanR> you must also verify, in a different way, attempts to move made by the local user
23:53:32 <boj> what happens if 3 of 4 players reject another player's move, because it was actually illegal?
23:53:51 <EvanR> which player are you?
23:54:02 <EvanR> the cheater?
23:54:05 <boj> yeah
23:54:14 <boj> let's say i modified the packet before it went over the wire
23:54:25 <EvanR> or just run your own client
23:54:29 <boj> sure
23:55:04 <EvanR> you tried an illegal move, which for turn based would be obviously cheating. so they could have the option to end the game
23:55:12 <EvanR> and blame you
23:55:32 <boj> yeah, i suppose it is that simple
23:55:49 <EvanR> for deathmatch, its more subtle because it could happen due to lag
23:55:57 <EvanR> i have a fixup for that
23:57:53 <EvanR> the central server needs a bit more stuff to act as an arbiter of moves, and can help "race losers" reverse their choices
23:58:11 <EvanR> this involves a "current turn" counter
23:58:21 <jle`> just gotta crdt it up
23:58:56 <EvanR> heh
