00:00:30 <jle`> the pure that corresponds with your first <*> is different than the pure that corresponds with your second
00:00:33 <cocreature> % :set -XTypeApplications
00:00:34 <yahb> cocreature:
00:00:39 <cocreature> vaibhavsagar: you can for yahb :)
00:00:48 <dminuoso> aka_: The problem with `pure` is that it's more than just a type.
00:00:51 <cocreature> % :t (+) @ Int
00:00:51 <yahb> cocreature: Int -> Int -> Int
00:01:13 <vaibhavsagar> ooh, very nice
00:01:23 <jle`> % :t fmap @[]
00:01:24 <yahb> jle`: (a -> b) -> [a] -> [b]
00:01:54 <vaibhavsagar> % :t pure @IO
00:01:54 <yahb> vaibhavsagar: a -> IO a
00:02:18 <vaibhavsagar> yahb isn't on #haskell-beginners though :'(
00:02:42 <cocreature> I don’t get the purpose of that channel anyway, asking beginner questions here is just fine
00:02:53 <[exa]> is there some reliable way to get the ordering of the type arguments?
00:03:12 <jle`> [exa]: :set -fprint-explicit-foralls
00:03:18 <[exa]> oh nice
00:03:22 <jle`> % :set -fprint-explicit-foralls
00:03:22 <yahb> jle`:
00:03:32 <jle`> % :t fmap
00:03:32 <yahb> jle`: forall {f :: * -> *} {a} {b}. Functor f => (a -> b) -> f a -> f b
00:04:02 <vaibhavsagar> % import Data.Coerce
00:04:02 <yahb> vaibhavsagar:
00:04:12 <[exa]> % :t fmap @Maybe @Int @Int
00:04:12 <yahb> [exa]: (Int -> Int) -> Maybe Int -> Maybe Int
00:04:29 <vaibhavsagar> % :set -XScopedTypeVariables
00:04:31 <yahb> vaibhavsagar:
00:04:37 <jle`> % :t fmap @_ @_ @Bool
00:04:38 <yahb> jle`: forall {w1 :: * -> *} {w2}. Functor w1 => (w2 -> Bool) -> w1 w2 -> w1 Bool
00:04:47 <jle`> w1/w2, yikes
00:05:04 <[exa]> jle`: I guess this only works in newer ghci?
00:05:08 <cocreature> w as in wildcard probably :)
00:05:12 <jle`> it works correctly
00:05:22 <jle`> it just obliterates the previous type variable names
00:05:41 <[exa]> oh, TypeApplications
00:06:30 <vaibhavsagar> % :t coerce (traverse @_ @Identity @_ @_)
00:06:31 <yahb> vaibhavsagar: forall {w1 :: * -> *} {b} {w2} {w3}. (Traversable w1, Coercible b ((w2 -> Identity w3) -> w1 w2 -> Identity (w1 w3))) => b
00:06:57 <[exa]> anyways, is there a way to pass in a typeclass dictionary? (just like in Core)
00:07:14 <vaibhavsagar> ScopedTypeVariables + TypeApplications
00:07:33 <Ariakenom> :t partsOf
00:07:35 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
00:08:20 <vaibhavsagar> % let fmapDef :: forall t a b. Traversable t => (a -> b) -> t a -> t b; fmapDef = coerce (traverse @t @Identity @a @b)
00:08:20 <yahb> vaibhavsagar:
00:08:25 <vaibhavsagar> % :t fmapDef
00:08:26 <yahb> vaibhavsagar: forall {t :: * -> *} {a} {b}. Traversable t => (a -> b) -> t a -> t b
00:08:49 <vaibhavsagar> [exa]: does ^ answer your question?
00:09:25 <[exa]> O_O
00:12:19 <[exa]> took some time to parse. which exact part is the dictionary?
00:15:20 <vaibhavsagar> `t` is
00:16:04 <vaibhavsagar> but if you mean convering a typeclass constraint into an explicit record of functions, I don't know how to do that
00:18:20 <jle`> you can use 'Dict', which more or less literally contains the typeclass dictionary at runtime
00:18:40 <dminuoso> Let's say I have a type `T s t a b x` and I want to write an Applicative instance that abstracts over `a`, are there tricks to do this without newtype wrapping?
00:18:42 <jle`> a 'Dict (Num a)' more or less literally carries around the Num dictionary for 'a' at runtime
00:18:53 <jle`> dminuoso: what is an Applicative instance that abstracts over 'a'
00:19:02 <jle`> do you mean pure :: a -> T s t a b x ?
00:19:06 <dminuoso> jle`: Yeah
00:19:18 <jle`> yeah you'd have to newtype
00:19:26 <jle`> to get an Applicative instance with that pure
00:19:44 <jle`> [exa]: Dict from the constraints library
00:21:09 * hackage mime-mail-ses 0.4.1 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.4.1 (MichaelSnoyman)
00:21:45 <dminuoso> jle`: It would be kind of cool if I could write `instance Applicative (T s t _ b x)` :|
00:22:09 <jle`> dminuoso: one big problem with that is that it really destroys type inference
00:22:27 <jle`> requiring a strict parameter order is the only way type inference and instance resolution can work soundly
00:22:43 <[exa]> vaibhavsagar,jle` thanks!
00:23:08 <jle`> dminuoso: for example, let's say you could write instance Functor (_, b)
00:23:25 <jle`> dminuoso: then what would fmap (f :: a -> a) (xy :: (a, a)) do?
00:23:50 <jle`> would it match the Functor (b, _) instance, or the Functor (_, b) instance?
00:26:45 <dminuoso> jle`: Well it could still be constrained to having only one instance per type. I mean if you were only allowed to have one `instance C T (s t a b x)` for any possible "choice of hole"
00:27:44 <dminuoso> So that `instance C (T s t _ b x)` and `instance C (T s t a _ x)` would be disallowed.
00:28:08 <dminuoso> jle`: But I dont know enough about type inference to make any smart remarks here.
00:35:49 <cocreature> if you can have only one instance anyway, why not just order the type parameters such that they match the instances you want to have?
01:15:39 * hackage hlint 2.1.3 - Source code suggestions  http://hackage.haskell.org/package/hlint-2.1.3 (NeilMitchell)
01:43:33 <merijn> I have decided I am a damn visionary
01:44:01 <merijn> This is like the 5th GHC proposal I've made that got shot down and magically turns into a proposal everyone is ravingly enthusiastic about 2 years later >.>
01:45:05 <vaibhavsagar> is this CompileTimeLiterals?
01:45:42 <merijn> vaibhavsagar: Yeah
01:46:14 <cocreature> merijn: tbf I’m not sure “ravingly enthusiastic” characterizes the responses accurately :)
01:46:15 <vaibhavsagar> yeah, sucks when people don't recognise a good idea until someone else has it
01:46:50 <merijn> cocreature: I read 2 very enthusiastic comments on reddit and have made up my mind that this is the overall opinion! >.<
01:47:05 <merijn> Reality be damned!
01:47:40 <cocreature> at least when it comes to the implementation, there seems to be quite a bit of disagreement
01:49:58 <merijn> cocreature: Yeah, that NEVER happens in the haskell community... :p
01:50:35 <cocreature> ;)
01:52:52 <merijn> On an entirely unrelated note: Any cabal-install and new-build users willing to live on the bleeding edge? ;)
01:56:07 <slevin> hola. i'm looking for some pretty computer monitoring software for linux. want to install on all my servers and have a webpage/app where i can view basic info. any suggestions?
01:56:25 <merijn> slevin: Sounds like you're in the wrong channel?
01:56:55 <slevin> merijn: might be. should i try in offtopic maybe?
02:01:22 <tdammers> so many bikes to be shed. so many yaks to be shaved.
02:08:39 * hackage sized-grid 0.1.0.0 - Multidimensional grids with sized specified at compile time  http://hackage.haskell.org/package/sized-grid-0.1.0.0 (edwardwas)
02:24:21 <marmistrz> Is it any concise way to apply a function to one of the fields of a data record?
02:24:24 <marmistrz> I have something like this: https://repl.it/repls/GratefulSereneViruses
02:24:45 <merijn> marmistrz: You sound like you want lens
02:25:39 * hackage cabal2spec 2.1 - Convert Cabal files into rpm spec files  http://hackage.haskell.org/package/cabal2spec-2.1 (PeterSimons)
02:30:30 <merijn> hmmm, anyone got a clever way to write:
02:30:38 <merijn> @hoogle (a -> Bool) -> a -> Maybe a
02:30:38 <lambdabot> Control.Monad.Plus partial :: (a -> Bool) -> a -> Maybe a
02:30:39 <lambdabot> Agda.Utils.Maybe filterMaybe :: (a -> Bool) -> a -> Maybe a
02:30:39 <lambdabot> Agda.Utils.Maybe.Strict filterMaybe :: (a -> Bool) -> a -> Maybe a
02:31:37 <jle`> merijn: \p x -> mfilter p (Just x) ?
02:31:52 <jle`> x <$ guard (p x) ?
02:32:08 <jle`> it's definitely a pattern that i've seen come up a lot and i usually just use one of those
02:32:19 <merijn> ah, I didn't think of that version with guard
02:34:52 <Ariakenom> const . const Nothing
02:35:49 <merijn> That's...a pretty useless implementation of that type
02:36:56 <Ariakenom> Wow. How rude :p
02:39:41 <marmistrz> merijn, it looks complicated :) I don't have nesting here, it looks to me like simply writing auxiliary functions is easier than messing with lenses :)
02:40:18 <merijn> marmistrz: Yeah, lens can be intimidating, there's microlens which is less huge and intimidating (and can be drop-in replaced by lens later)
02:40:37 <merijn> marmistrz: And you can just use the small subset you care about and pretend the rest doesn't exist
02:42:10 <ventonegro> marmistrz: Your build times will thank you
02:42:31 <marmistrz> :) thanks, I'll take a look
02:43:33 <Ariakenom> :t over
02:43:35 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
02:43:36 <kuribas> lenses aren't hard to use, are they?
02:43:40 <merijn> ventonegro: That's what incremental build are for
02:43:58 <merijn> kuribas: As soon as you want to do anything non-trivial they're pretty confusing
02:44:08 <kuribas> mostly they are "operation optic data"
02:44:17 <kuribas> the errors can be confusing though
02:44:45 <merijn> kuribas: Figuring out how to fit pieces together to do what you want is hard and not helped by the million of cryptic operators and types
02:45:13 <kuribas> yeah, microlens is probably a better start
02:45:44 <kuribas> also because the aweful documentation
02:46:17 <Ariakenom> "over _field (+1) record" would be the relevant incantation?
02:46:20 <kuribas> For example Choice: "The generalization of Costar of Functor that is strong with respect to Either. Note: This is also a notion of strength, except with regards to another monoidal structure that we can choose to equip Hask with: the cocartesian coproduct."
02:46:31 <kuribas> that doesn't mean a thing to me...
02:46:36 <Ariakenom> So they's need over and some way to get _field
02:48:02 <kuribas> Ariakenom: it will apply (+1) to the target of _field inside record, and return the whole modified record.
02:50:19 <Ariakenom> Yes. I was thinking about what marmistrz needed.
02:51:59 <kuribas> Is the reason lenses are traversals so you can compose them with (.) ?
02:53:17 <Ariakenom> How would you recommend marmistrz get _field?
02:54:52 <kuribas> Ariakenom: what was the question?
03:06:28 <chorhizo> Is the state monad as simple as I think it is, just being able to set state, get state, modify state, without having an actual concrete value to interact with?
03:08:10 <jle`> chorhizo: depends on what you are talking about when you say 'concrete value'
03:08:37 <kuribas> chorhizo: the state monad is basicly (state -> (state, a))
03:08:59 <jle`> kuribas: that's the reason for van laarhoven lenses
03:09:09 <jle`> kuribas: you can implement traversals differently
03:09:37 <jle`> but the van laarhoven encoding lets you compose them with (.)
03:09:53 <jle`> also not all lenses are traversals
03:10:26 <chorhizo> kuribas: oh? I thought it was state to (a, state)
03:10:37 <fishythefish> chorhizo: (a, b) and (b, a) are isomorphic
03:10:41 <chorhizo> Isn't a the result of what you look up or do to state?
03:10:42 <kuribas> :t state
03:10:43 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
03:10:56 <kuribas> chorhizo: yes, that's right
03:11:02 <jle`> kuribas: you can define traversals in a way that (.) won't work with them
03:11:10 <jle`> so just being a traversal doesn't mean you can use (.)
03:11:18 <ventonegro> chorhizo: The state monad is just a big function waiting for the initial state to do something
03:11:40 <kuribas> jle`: and also because it generalises lenses, prisms and traversals?
03:11:51 <jle`> traversals don't generalize lenses
03:11:57 <jle`> it's the opposite actually
03:12:13 <jle`> er, wait, sorry
03:12:17 <jle`> let me make sure
03:12:20 <kuribas> jle`: isn't a traversal more general?
03:12:39 <kuribas> a lens is a traversal, but not the other way
03:12:43 <jle`> yeah, you're right, i mixed it up :)
03:12:55 <jle`> but, prisms and traversals are also not generalizations of one or the other
03:13:22 <jle`> prisms are not a genearliation of traversals, and traversals are not a generalization of prisms
03:13:42 <kuribas> I see, because a prism can create data...
03:14:12 <chorhizo> I think I understand state, just need to use it, cheers
03:14:16 <fishythefish> every Lens' is a Traversal' and every Prism' is a Traversal', no?
03:14:20 <Taneb> All prisms are traversals, though
03:14:20 <jle`> yeah sorry, i was wrong earlier when i said not all lenses are traversals, but i think you saw that
03:14:48 <kuribas> all optics then?
03:14:57 <jle`> but yeah, my point was that the fact that all lenses are traversals isn't why you can compose them with (.)
03:15:10 <jle`> the composition with (.) comes from how you encode your lenses
03:15:14 <jle`> and your traversals, and your prisms, etc.
03:15:24 <kuribas> yeah, and the order of arguments in a traversal...
03:15:26 <kuribas> :t traverse
03:15:27 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
03:15:37 <jle`> what you just gave is just one possible encoding of a traversal
03:15:39 <jle`> but there are others
03:16:15 <jle`> you might be confusing traversals with a specific encoding of them
03:17:06 <jle`> in lens/optics, a traversal is an abstract interface
03:17:26 <jle`> (forall f. Applicative f => (a -> f b) -> s -> f t) is just one possible implementation/encoding of a Traversal s t ab
03:17:59 <petrolifero[m]> :t car
03:18:01 <lambdabot> error:
03:18:01 <lambdabot>     • Variable not in scope: car
03:18:01 <lambdabot>     • Perhaps you meant one of these:
03:18:06 <jle`> it happens to be the one chosen by the library, because it can be composed using (.)
03:18:09 <jackcrfs> newbie question:
03:18:11 <jackcrfs> newbie question, I am trying to understand do a lookup 2 times.  In fact, I have num2eng = [(1, "one")]; eng2germ = [("one", "eins")]; then I execute ghci>lookup (lookup 1 num2eng) eng2germ; it fails, what should I do?
03:18:13 <jle`> so the causality is backwards
03:18:48 <jle`> jackcrfs: what is the error?
03:19:05 <jackcrfs> Couldn't match type ‘[Char]’ with ‘Maybe [Char]’
03:19:13 <kuribas> jackcrfs: the lookup can fail
03:19:24 <jackcrfs> lookup (Maybe "one") eng2germ would fail too.
03:19:33 <jle`> jackcrfs: ah yes, check the type of lookup
03:19:37 <jackcrfs> whereas lookup "one" eng2germ works
03:19:38 <jle`> it returns a Maybe String here
03:19:44 <jackcrfs> I don't know what to do with the extra Maybe
03:19:52 <jle`> how familiar are you with ADT's?
03:20:01 <jle`> you can mattern match on it
03:20:03 <jackcrfs> it's like my 4th day on Haskell, so no, I am sorry
03:20:08 <jle`> no need to be sorry
03:20:37 <jle`> adt's are a pretty fundamental/foundational concept, but they aren't usually the first thing introduced
03:20:42 <jackcrfs> I was thinking looking 2 times is a nice little problem to solve, and I want to undertand that Maybe/Just thing
03:20:55 <jackcrfs> looking up 2 times, I mean.
03:20:57 <kuribas> jackcrfs: case lookup 1 num2eng of Nothing -> Nothing; Just x -> lookup x eng2germ
03:20:58 <jle`> yeah, i'd wait until you learn about algebraic data types and Maybe
03:21:03 <jle`> and baout pattern matching
03:21:15 <jle`> or if you want to learn now, you can look up pattern matching on ADT's
03:21:17 <jackcrfs> o.O
03:22:00 <jle`> but any haskell course worth its salt will be talking about ADT's pretty thoroughly pretty early
03:22:15 <jle`> so if you're following a course, it's probably not too far away
03:22:22 <jackcrfs> there is no simple way to remove the Maybe?  I get the advantage, when "Maybe" gets passed around it retains the knowledge that somewhere down in the call stack, an exceptional circumstance is expected, so deal with it.
03:22:26 <jle`> there is a simple way
03:22:32 <jle`> it's pattern matching
03:22:40 <kuribas> jackcrfs: yes, see my answer
03:23:01 <jackcrfs> ok ok, I have a Haskell book, I thought I will play around too; I bet it's a few chapters down...
03:23:05 <jle`> but it's hard to understand pattern matching until you understand ADT's
03:23:18 <jle`> and how Maybe as two constructors, and how constructors can have values in them, etc.
03:23:32 <jle`> *has
03:23:39 * hackage formatting 6.3.4 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-6.3.4 (ChrisDone)
03:23:43 <jle`> but yeah, once you learn what an ADT is, pattern matching on them is pretty simple :)
03:23:48 <ventonegro> jackcrfs: Which book do you have?
03:23:51 <jackcrfs> i am learning on my own, so I am all over the place
03:24:21 <jle`> if you're making your own path, then the 'next step' i'd probably suggest is learning about ADT's and pattern matches
03:24:24 <jackcrfs> Programming in Haskell; Hutton, Graham
03:24:41 <ventonegro> jackcrfs: second edition? :)
03:24:57 <jackcrfs> yes, 2nd ed
03:25:06 <ventonegro> jackcrfs: nice
03:25:33 <jackcrfs> I am a toddler in every sense, thanks for bearing with me.
03:27:30 <jle`> we have all been there :)
03:27:55 <jackcrfs> gotcha say this channel is one of the most friendly i have seen
03:28:26 <chorhizo> Just wait untill later
03:29:01 <jackcrfs> gotcha go, bye now.
03:29:04 <ventonegro> jackcrfs: Just don't call monads pipes and you will be fine
03:36:08 <tdammers> specifically, don't call them smart pipes with side effects
03:38:42 <chorhizo> SPWSE, catchy. I mean, at least elementary monads kind of act like that...
03:40:09 <marble_visions> hi all, reading lyah and i've come across this: https://pastebin.com/zPhBsQnz but I can't do "import Control.Monad.Instances ... :t (->)" ghci gives me a parse error
03:40:17 <quicksilver> they're clearly horses riding through burritos
03:40:21 <quicksilver> small horses, obviously
03:41:34 <marble_visions> i may not be escaping -> properly, but ticks and backticks don't work either
03:42:47 <dminuoso> @let instance Functor ((->) r) where fmap f g = (\x -> f (g x))
03:42:48 <lambdabot>  .L.hs:158:10: error:
03:42:48 <lambdabot>      Duplicate instance declarations:
03:42:48 <lambdabot>        instance [safe] Functor ((->) r) -- Defined at .L.hs:158:10
03:42:49 <dminuoso> marble_visions: Parses fine for me.
03:43:15 <dminuoso> marble_visions: Oh. :t (->) doesnt work because (->) is not a function.
03:43:31 <dminuoso> marble_visions: It's a type level construct! So if you want to know its "type", use :k to ask for its kind.
03:43:38 <kuribas> ventonegro: don't call the containers either
03:43:49 <dminuoso> :k (->)
03:43:51 <lambdabot> TYPE q -> TYPE r -> *
03:44:04 <ventonegro> kuribas: containerised smart pipes?
03:44:20 <kuribas> :)
03:46:14 <JavaSucksMan> ok... curious... why isn't the kind of (->)   *->*->*   ?
03:46:21 <dminuoso> JavaSucksMan: Levity polymorphism.
03:46:38 <dminuoso> JavaSucksMan: It's to allow unboxed and unlifted things in there too.
03:46:58 <dminuoso> so that you can have: `f :: Int# -> Int` for example
03:47:12 <JavaSucksMan> hmmm beyond my pay grade
03:48:39 <marble_visions> dminuoso: oooh right
03:48:43 <marble_visions> let me check.
03:51:00 <marble_visions> so can -> be viewed as a type constructor? and applying a concrete type to is, producing a concrete type, make :t work ? for example :k (->) ... :t (->) Int Int
03:51:02 <dminuoso> JavaSucksMan: The kind of Int is: `Int :: *` right? Unboxed types have kinds different from * :)
03:51:11 <iqubic> :t (->)
03:51:12 <lambdabot> error: parse error on input ‘->’
03:51:14 <dminuoso> marble_visions: Yes. Although the word "concrete type" is so overloaded..
03:51:26 <dminuoso> marble_visions: But no regarding the last part.
03:51:33 <dminuoso> marble_visions: Does `:t Maybe Int` make sense?
03:52:30 <quicksilver> if you think the kind of (->) is * -> * -> * you have the correct intuition
03:52:47 <dminuoso> ^- this is close enough to the truth to get started.
03:53:06 <marble_visions> quicksilver: i saw it, but didn't arrive at that conclusion myself. maybe i need to go back to kinds
03:53:31 <marble_visions> dminuoso: :t Maybe Int no, but let a = Just 5 ... :t a does make sense
03:54:02 <dminuoso> marble_visions: Alright! So what about `:t Either String Int` ?
03:54:34 <marble_visions> dminuoso: in plain english, i'm asking for the type of a type..
03:54:36 <dminuoso> marble_visions: For the same reason it doesn't make sense. `:t` expects something from the "value" universe. But `Either`, `Either String` and `Either String Int` are all from the type universe. :)
03:54:45 <marble_visions> where i should be asking about the type of an expression
03:54:51 <dminuoso> marble_visions: We call types of types "kinds"
03:55:36 <marble_visions> right
03:55:56 <marble_visions> dminuoso: quicksilver: thanks! i'm off to read about kinds :)
03:57:40 <marble_visions> lambdabot: help!
03:57:51 <marble_visions> does it evaluate haskell stuff?
03:58:02 <marble_visions> lambdabot: !help
03:58:04 <dminuoso> > putStrLn "Hello World"
03:58:06 <lambdabot>  <IO ()>
03:58:11 <fishythefish> > 1 + 2
03:58:13 <lambdabot>  3
03:58:26 <marble_visions> > let a = Just 4
03:58:29 <lambdabot>  <no location info>: error: not an expression: ‘let a = Just 4’
03:58:36 <marble_visions> > a = Just 5
03:58:37 <lambdabot>  <hint>:1:3: error:
03:58:38 <lambdabot>      parse error on input ‘=’
03:58:38 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
03:58:47 <MasseR> > let a = Just 4 in a
03:58:49 <lambdabot>  Just 4
03:58:57 <MasseR> You need to give it a full expression
03:59:20 <fishythefish> @let foo = Just 4
03:59:21 <lambdabot>  Defined.
03:59:22 <fishythefish> > foo
03:59:25 <lambdabot>  Just 4
03:59:39 <fishythefish> @undefine
03:59:39 <lambdabot> Undefined.
04:00:00 <dminuoso> marble_visions: By the way: To me it was helpful to think of typeclasses as a "collection/bag/container/group/set" of types. Each `instance` declaration specifies that some types are inside the given "class". So whatever comes to the right to `instance C` must be a type-level construct. :)
04:01:07 <merijn> hmm, is it just me or do if/then/else in do blocks look really awful?
04:01:22 <marble_visions> dminuoso: nice, didn't look at it that way
04:01:39 <chorhizo> merijn: they look really awful
04:02:12 <chorhizo> merijn: so do multiple guards on different pattern matches, although I think I do that too much because I'm bad at hask
04:03:33 <merijn> aww, rats... bool has the bool argument in the wrong position :\
04:03:39 <marble_visions> > let a = [1,2,3,4] in map (+1) a
04:03:40 <dminuoso> marble_visions: Some classes for example hold types of kind * -> *, for example: `class Functor (f :: * -> *) where ...`
04:03:41 <lambdabot>  [2,3,4,5]
04:03:46 <marble_visions> awesome.
04:04:26 <dminuoso> marble_visions: Which means each type you declare is in Functor must have the kind (* -> *). That explains why something like `class Functor Either` cant work :)
04:04:30 <dminuoso> *`instance Functor Either`
04:04:53 <marble_visions> right
04:04:58 <dibblego> https://hackage.haskell.org/package/hask-0/docs/Hask-Category.html
04:05:13 <dibblego> "instance Functor Either where" :)
04:05:20 <dminuoso> Heh. :)
04:05:58 <dibblego> merijn: not just you, I use bool, which is a) a function b) has the arguments in the correct order
04:06:09 <merijn> dibblego: Wrong order for me
04:06:39 <merijn> dibblego: bool coming last makes it hard to pass a do blocks nicely as results
04:06:51 <dibblego> I don't know what that means :)
04:07:08 <dibblego> Bool coming last is consistent with other functions, such as foldr, either, maybe
04:07:15 <merijn> dibblego: I want to write "bool predicate falseBranch $ do {...}"
04:07:21 <dibblego> it makes lots of uses much easier
04:07:29 <fishythefish> it's a choice based on how you use it; having the Bool go last means you can e.g. map a choice over [Bool]
04:07:31 <merijn> dibblego: I'm not saying it's inconsistent, I'm saying it makes this exact code annoying to write
04:07:37 <dibblego> ok
04:07:58 <merijn> Because surrounding a do block with ( ) and passing that as argument is ugly as sin
04:08:15 <dibblego> boolBackwards = …
04:08:34 <merijn> hmm, I can probably get by by naming the do stuff in a let binding
04:08:54 <fishythefish> > let ifThenElse p t e = bool e t p in ifThenElse True 2 3
04:08:56 <lambdabot>  2
04:10:11 <tdammers> merijn: http://hackage.haskell.org/package/utility-ht-0.0.14/docs/Data-Bool-HT.html#v:if-39-
04:13:10 <dminuoso> marble_visions: Here are possible meanings of the expression "concrete type": Monomorphic type. Inhabitated type. `TYPE a` kinded type. Opposite of abstract type. The type of concrete for construction.
04:13:44 <dminuoso> marble_visions: Annoyingly `(->)` happens to require two `TYPE a` kinded types..
04:14:32 <hpc> :k (->)
04:14:33 <lambdabot> TYPE q -> TYPE r -> *
04:17:56 <iqubic> I'm not sure how that differs from (* -> * -> *)
04:18:09 <dminuoso> iqubic: * is the kind of lifted types.
04:18:18 <dminuoso> Int# for example is an unlifted type.
04:18:45 <dminuoso> iqubic: If that kind was used then `Int# -> Int` would be ill-kinded. It was allowed because of hacks
04:18:57 <iqubic> not sure what the # is there.
04:19:10 <dminuoso> iqubic: Part of the name. (Oh and its also unboxed, not just unlifted)
04:19:13 <hpc> iqubic: it's just another letter you can use in identifiers, if you turn on MagicHash
04:19:19 <hpc> (which is poorly named, there's no magic in that hash)
04:19:32 <hpc> by convention, the most primitive parts of the language end in '#'
04:20:00 <dminuoso> iqubic: (Though the convention is that types ending with '#' are unlifted)
04:20:06 <dminuoso> With most of them also unboxed.
04:20:27 <merijn> dminuoso: I'm pretty sure unlifted means unboxed in this context
04:20:41 <dminuoso> merijn: ByteArray#
04:21:12 <merijn> dminuoso: How is ByteArray# not unboxed?
04:22:41 <dminuoso> merijn: Afaik its heap allocated
04:22:50 <merijn> dminuoso: ByteArray# is an unboxed pointer
04:23:11 <aarvar> well then Int is an unboxed pointer too :)
04:23:58 <dstolfa> aarvar: pointers aren't integers and their sizes aren't guaranteed to be the same, so no
04:24:11 <aarvar> dstolfa: not what I meant
04:24:39 <aarvar> I mean, Int is represented with a pointer
04:24:56 <dstolfa> aarvar: ah
04:24:58 <dstolfa> aarvar: misread that
04:25:07 <dstolfa> aarvar: sorry :)
04:25:09 <merijn> aarvar: I strongly disagree, but at this level everything is vague enough that I can't formulate why
04:25:33 <dstolfa> merijn: well, if you look at it simply from a PoV of type theory, it's easy to see why it's not true
04:25:46 <dstolfa> different rules apply, haskell is strongly typed so you don't get to bypass them
04:25:54 <dstolfa> at least i think it's strongly typed throughout?
04:26:00 <aarvar> easy to see why what's not true?
04:26:05 <merijn> strongly typed is an ill-defined term
04:26:10 <dstolfa> merijn: it's really not
04:26:17 <dstolfa> merijn: it just means that you don't have non-explicit type conversion
04:26:21 <merijn> dstolfa: Ok, please tell me the definition of strongly typed, then :)
04:26:25 <dstolfa> merijn: i just did
04:26:28 <aarvar> what is type conversion
04:26:45 <merijn> dstolfa: So C, Java, and C++ are not strongly typed?
04:26:46 <dstolfa> aarvar: |- e : A -> B
04:26:49 <dstolfa> merijn: correct.
04:26:49 <Ariakenom> what's :k ByteArray# ?
04:26:52 <dstolfa> merijn: they're statically typed
04:27:00 <merijn> dstolfa: Typing is by definition static
04:27:14 <dstolfa> merijn: not necessarily
04:27:21 <dstolfa> merijn: a type is any expression that has a property
04:27:21 <aarvar> dstolfa: yes necessarily
04:27:29 <merijn> dstolfa: It really is, though
04:27:42 <aarvar> @google dynamic languages are static languages
04:27:43 <lambdabot> https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/
04:28:37 <merijn> TaPL, chapter 1, page 1: "A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute." <-
04:28:38 <dstolfa> aarvar: alright i see the distinction you're making. let me rephrase then. C, Java and C++ are loosely typed which means that the type checker is not able to verify whether or not a cast is valid
04:28:42 <aarvar> dstolfa: and how does "|- e : A -> B" define what a type conversion is
04:29:01 <dstolfa> aarvar: because you have an expression that takes type A and returns type B
04:29:11 <merijn> dstolfa: Note the fact that this definition says "syntactically", i.e. you have to be able to determine at compile (i.e. statically) the typing of a program
04:29:11 <dstolfa> aarvar: otherwise you can't cast
04:29:13 <aarvar> dstolfa: haskell can't verify whether or not a cast is valid either?
04:29:23 <merijn> aarvar: Haskell doesn't have a cast
04:29:29 <aarvar> unsafeCoerce
04:29:34 <aarvar> !
04:29:38 <merijn> aarvar: Pretty sure that's not standard Haskell
04:29:42 <dstolfa> aarvar: that's why i said i don't know if it's true that it's strongly typed throughout
04:29:42 <aarvar> alright, fine
04:29:48 <merijn> aarvar: i.e. not part of the language spec
04:29:57 <dstolfa> merijn: also, you can do dynamic type checking too
04:29:59 <aarvar> merijn: fair enough
04:30:04 <aarvar> dstolfa: no you cant
04:30:08 <dstolfa> aarvar: yes, yes you can
04:30:09 * hackage indexed-list-literals 0.2.0.0 - Type safe indexed list literals  http://hackage.haskell.org/package/indexed-list-literals-0.2.0.0 (DavidMD)
04:30:09 <merijn> dstolfa: No, you can do "runtime tag checking"
04:30:10 <aarvar> that's not type checking
04:30:24 <aarvar> dstolfa: and there are plenty of expressions from A to B
04:30:26 <merijn> dstolfa: Which is not type checking in the sense that all of computer science uses the term
04:30:28 <dstolfa> aarvar: type checking is recursively applying rules you've defined for certain properties
04:30:29 <GobbyGobbyGoblin> why does (:[]) work?
04:30:30 <aarvar> you haven't defined what  "type conversion" is at all
04:30:41 <dstolfa> aarvar: take type A return type B is type conversion from A to B
04:30:48 <dstolfa> it should be pretty straightforward?
04:30:53 <fishythefish> GobbyGobbyGoblin: same concept as (+ 1) except with (:) instead of (+) and [] instead of 1
04:30:55 <aarvar> dstolfa: no, it's not
04:31:05 <aarvar> that's not how you would write the rule
04:31:28 <dstolfa> aarvar: no, this isn't how you would write the rule in a real language. this is how you would write a rule to demonstrate the idea
04:31:29 <aarvar> you mean e : A implies e : B?
04:31:39 * hackage avro 0.3.0.0 - Avro serialization support for Haskell  http://hackage.haskell.org/package/avro-0.3.0.0 (alexeyraga)
04:31:50 <GobbyGobbyGoblin> fishythefish: cheers
04:31:51 <dstolfa> aarvar: no, i don't
04:31:57 <aarvar> then I have no idea what you mean
04:31:58 <Ariakenom> implicitly was a key word somewhere above I think.
04:32:13 <merijn> dstolfa: I would strongly urge yu to first read Harper's post that aarvar linked else this discussion is pointless
04:32:30 <aarvar> Ariakenom: right, the conversion needs to be implicit of course
04:32:42 <aarvar> but haskell converts forall a. a -> a to Int -> Int, implicitly!!
04:32:48 <aarvar> it must be loosely typed!
04:33:03 <merijn> dstolfa: The fact that all of the "dynamic" languages have decided to hijack terminology and use it wrong does not magically invalidate the definitions that have been used in computer science for decades
04:33:10 <dstolfa> aarvar: that's not at all what i said
04:33:18 <dstolfa> merijn: right, i used the definition most people are familiar with
04:33:23 <spoonm> I have some f :: a -> b -> b and a g :: b -> b, I thought I could do g . f to get a a -> b -> b, but I get an error, am I understanding these things wrong?
04:33:26 <dstolfa> merijn: if you go full type theory, then yes
04:33:29 <aarvar> lol
04:33:30 <kuribas> aarvar: a is a typevariable, so it stands for a type.
04:33:31 <dstolfa> you do need to statically type
04:33:32 <aarvar> "full type theory"
04:33:39 <kuribas> aarvar: Int in that case.
04:33:43 <kuribas> aarvar: there is no conversion
04:33:50 <dstolfa> aarvar: there's a distinction in practice between runtime type checking and compile time type checking
04:34:08 <dstolfa> aarvar: if all you care is about a typesystem that has its rules and you can apply the recursive rules, then yes, you need to statically type by definition
04:34:09 <merijn> spoonm: in 'g . f' you pass the result of applying 'f' to one argument as input to 'g'
04:34:10 <aarvar> kuribas: um, I was engaging in reductio ad absurdum
04:34:26 <merijn> spoonm: However, 'g' expects a 'b', and 'f' applied to one argument returns 'b -> b'
04:34:31 <merijn> spoonm: So the types don't match up
04:34:33 <dstolfa> aarvar: if you want runtime canonical types that help you with things like CCFI, then that definition doesn't hold
04:34:36 <aarvar> kuribas: also, there is a conversion. It converts forall a. a -> a by applying the function to Int
04:34:49 <dstolfa> i should have defined my terminology before saying anything
04:34:51 <dstolfa> mea culpa
04:34:53 <merijn> aarvar: It doesn't
04:34:54 <dstolfa> but i digress
04:35:00 <merijn> aarvar: That's an implementation detail of GHC
04:35:10 <merijn> aarvar: In Haskell the language that entire notion does not exist
04:35:24 <aarvar> presumably it will in dependent haskell
04:35:31 <kuribas> aarvar: it doesn't apply a function, it unifies a variable and a type
04:35:40 <merijn> aarvar: Specifically, that's how System F_ω works
04:36:00 <merijn> aarvar: No, because for dependent types you need the opposite
04:36:05 <aarvar> merijn: huh?
04:36:06 <kuribas> aarvar: it's a bit similar, but the semantics for unification and function application are different.
04:36:20 <aarvar> kuribas: are you familiar with dependent types?
04:36:31 <kuribas> aarvar: a bit
04:37:16 <aarvar> kuribas: while merijn is correct that it's not part of the haskell language, you can understand a value of type forall a. f a as being a function from a type `a` to a value of type `f a`
04:37:27 <aarvar> where the argument is implicit
04:37:35 <aarvar> and irrelevant
04:38:22 <aarvar> and in fact, that's how GHC's core language works
04:38:28 <aarvar> (except the argument is made explicit)
04:38:34 <kuribas> aarvar: you mean from a value of type 'a'?
04:38:38 <aarvar> kuribas: no
04:38:43 <Ariakenom> {a::Type}-> (x::a) -> (y::a)
04:38:46 <aarvar> from a value `a` of type `Type`
04:38:47 <aarvar> yes, that
04:38:51 <spoonm> merijn: ah I see, you're right
04:39:29 <aarvar> so when you write `id 3`, GHC compiles that to `id @Int 3`
04:39:45 <merijn> aarvar: Well, that's a bad example, since 3 isn't Int :)
04:39:50 <aarvar> also, there's now the TypeApplications exstension which lets you write the latter
04:39:55 <aarvar> merijn: you're right
04:40:12 <spoonm> merijn: what if I do something like (\e -> g . f e), would that give me a -> b -> b? hmm
04:40:15 <aarvar> replace Int and 3 with Bool and True
04:40:27 <merijn> spoonm: Yes
04:40:31 <spoonm> \o/
04:40:36 <kuribas> aarvar: a value of type forall a. f a is not (necessarily) a function.
04:40:40 <spoonm> thanks, m8
04:40:48 <aarvar> kuribas: sure it is
04:41:05 <aarvar> kuribas: it's a function (a : Type) -> f a
04:41:09 <kuribas> "Maybe Int" is not a function
04:41:16 <aarvar> kuribas: correct
04:41:18 <aarvar> I didn't say it was
04:41:26 <aarvar> `Maybe Int` is a type
04:41:32 <dstolfa> but i thought everything is a function in haskell!
04:41:33 * dstolfa ducks
04:41:48 <aarvar> Nothing : (a : Type) -> Maybe a is a function
04:42:06 <[exa]> dstolfa: don't worry there can be a function hidden under that :]
04:42:11 <aarvar> dstolfa: nope. and you still haven't explained what strongly vs weakly typed means
04:42:13 <kuribas> aarvar: well, "Nothing" is not a function
04:42:18 <aarvar> kuribas: yes it is
04:42:27 <kuribas> > Nothing 3
04:42:29 <lambdabot>  error:
04:42:30 <lambdabot>      • Couldn't match expected type ‘Integer -> t’
04:42:30 <lambdabot>                    with actual type ‘Maybe a0’
04:42:32 <aarvar> > Nothing @INt
04:42:34 <dstolfa> aarvar: again, strongly typed means that there exists no conversion between 2 types that is not visible inside the typing rules
04:42:35 <lambdabot>  <hint>:1:9: error: parse error on input ‘@’
04:42:35 <aarvar> > Nothing @Int
04:42:37 <lambdabot>  <hint>:1:9: error: parse error on input ‘@’
04:42:40 <dstolfa> aarvar: loosely typed is everything else
04:42:40 <aarvar> ugh, how do I enable extensions
04:42:45 <[exa]> aarvar: use yahb with %
04:42:54 <aarvar> % Nothing @Int
04:42:54 <yahb> aarvar: Nothing
04:43:01 <aarvar> kuribas: see, function
04:43:02 <[exa]> :]
04:43:03 <aarvar> I applied it to Int
04:43:25 <aarvar> (@ overrides the invisibility of the argument)
04:44:13 <aarvar> % 3 @Int
04:44:13 <yahb> aarvar: ; <interactive>:165:1: error:; * Cannot apply expression of type `p0'; to a visible type argument `Int'; * In the expression: 3 @Int; In an equation for `it': it = 3 @Int
04:44:16 <aarvar> :(
04:44:25 <[exa]> aarvar: 3 is (fromInteger 3)
04:45:05 <aarvar> % (3 :: forall a. Num a) @Int
04:45:06 <yahb> aarvar: ; <interactive>:166:17: error:; * Expected a type, but `Num a' has kind `Constraint'; * In an expression type signature: forall a. Num a; In the expression: 3 :: forall a. Num a; In the expression: (3 :: forall a. Num a) @Int
04:45:10 <aarvar> woops
04:45:12 <dstolfa> aarvar: if i have a conversion Byte -> Int somewhere, when my typing rule will say that i must have had an expression that in fact has a type of |- e : Byte -> Int, where -> is not implication but notation for "takes Byte gives Int". and again, this is *not* what you would actually do for a language, it's the minimal thing, albeit a bit iffy that i could think of to demonstrate the idea
04:45:13 <aarvar> % (3 :: forall a. Num a => a) @Int
04:45:13 <yahb> aarvar: 3
04:45:16 <aarvar> there
04:46:12 <kuribas> is there a good reason to use acid-state over a database?
04:46:24 <aarvar> dstolfa: haskell has a function Byte -> Int
04:46:30 <aarvar> it's just not applied implicitly
04:46:32 <Ariakenom> the statement "3 is (fromInteger 3)" needs better notation
04:46:44 <aarvar> yet it does apply (forall a. a -> a) -> Int -> Int implicitly
04:46:46 <lemmih> kuribas: Ease of use.
04:47:08 <aarvar> Ariakenom: fromInteger (3 @Integer)
04:47:11 <aarvar> :)
04:47:16 <[exa]> Ariakenom: yeah it seems fixpointish that way. :]
04:47:39 <dstolfa> aarvar: yeah, and that's fine. as i said, this is not what you would do in a real language because it's a terrible rule, but the most dull thing that would demonstrate the idea i thought of at this point
04:48:00 <kuribas> lemmih: sacrificing performance?
04:48:00 <aarvar> dstolfa: but how is haskell strongly typed while Java isn't
04:48:44 <lemmih> kuribas: acid-state performs better in some situations, worse in others.
04:48:48 <dstolfa> aarvar: because java lets you cast something to an object and then to another class all together without any checks at compile time
04:48:50 <Ariakenom> 3 is fromInteger 3#Integer ?
04:49:16 <aarvar> dstolfa: okay, so because haskell doesn't have unsafeCoerce. Now I get it
04:49:28 <shiona> aarvar: The usual answer is "because X does some implicit casting that Y does not"
04:49:51 <aarvar> shiona: right, but he's arguing something else xd
04:49:57 <Ariakenom> > (3::Int) + (3::Float)
04:49:59 <lambdabot>  error:
04:50:00 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Float’
04:50:00 <lambdabot>      • In the second argument of ‘(+)’, namely ‘(3 :: Float)’
04:50:04 <shiona> ah, true
04:50:22 <aarvar> shiona: the original argument was over whether it's a precise notion
04:50:43 <kuribas> aarvar: haskell has some features which are explicitly labeled unsafe and with a big warning in the documentation.  Java and other languages have unsafe operations as standard behaviour.
04:50:45 <aarvar> Ariakenom: you could easily write a (+) function that would work there though
04:50:48 <dstolfa> aarvar: well, the original argument arose because i didn't define what i was talking about and started throwing terms around :)
04:50:51 <Boomerang> > 3 + unsafeCoerce 'a'
04:50:53 <lambdabot>  error:
04:50:53 <lambdabot>      Variable not in scope: unsafeCoerce :: Char -> a
04:51:14 <aarvar> dstolfa: and yes, you didn't define that by "type" you meant something other than "type" :)
04:51:35 <Ariakenom> aarvar, at least in C it's defined from coercion though.
04:51:47 <kuribas> aarvar: so yes, haskell allows you to shoot yourself in your foot at your own risk, but it doesn't encourage it.
04:52:06 <shiona> kuribas: I wouldn't consider a naming convention of functions part of the typesystem of the language
04:52:33 <aarvar> shiona: but unsafe functions aren't part of the language standard
04:52:47 <shiona> well that surely changes things
04:52:47 <kuribas> shiona: it isn't?
04:52:55 <aarvar> shiona: indeed it doesn't :)
04:53:02 <merijn> Most aren't
04:53:07 <merijn> But unsafePerformIO is
04:53:09 <aarvar> oh
04:53:12 <merijn> It's part of the FFI chapter
04:53:18 <Boomerang> The non-technical distinction between C or Java and Haskell's type system that I like is that types in C or Java are mainly intended for the machine (to represent it in memory), whereas in Haskell it's intended for the programmer (to help them reason about code) :)
04:53:28 <aarvar> merijn: well then you can define unsafeCoerce
04:53:36 <aarvar> so unsafeCoerce is part of the language too :)
04:53:44 <kuribas> Boomerang: also for the IDE
04:53:51 <merijn> How do you define unsafeCoerce using unsafePerformIO?
04:53:59 <aarvar> merijn: with IORef
04:54:09 <kuribas> Boomerang: to help in refactoring stuff
04:55:32 <Boomerang> Right that is useful too, but it seems that IDE use types to get the information they need, not that languages use types to help IDEs. But I could be wrong, maybe some languages think about types to help IDEs
04:55:49 <Ariakenom> :t let coerce = (undefined :: a -> b) in coerce (3::Int) :: String
04:55:50 <lambdabot> String
04:55:58 <adjofun> Boomerang: but that is not true. Haskell types are intended for the compiler to check correctness, it just happens that this types correspond to logic.
04:56:27 <dminuoso> Ariakenom: `TYPE LiftedRep`
04:56:39 <dminuoso> Oh.. I was not fully scrolled.
04:56:41 <Ariakenom> heh
04:56:46 <aarvar> merijn: unsafePerformIO (newIORef Nothing) has type forall a. Maybe a
04:57:01 <Ariakenom> Took me a few seconds to realize it was about ByteArray#
04:57:01 <aarvar> then you can write in Just ("hello") and read it out as a Maybe Bool
04:57:15 <aarvar> (don't ask why I put parens there)
04:57:26 <dstolfa> aarvar: why'd you put parens there?!
04:57:56 <quicksilver> (be careful)
04:58:01 <quicksilver> (you might get (stuck))
04:58:09 <dstolfa> quicksilver: is this the real lisp
04:58:11 * quicksilver nods
04:58:11 <adjofun> Boomerang: You probably meant something along the lines of "C or java types don't encode enough information for compiler to check for correctness"
04:58:12 <dstolfa> quicksilver: is this just haskelly?
04:59:02 <aarvar> merijn: er, I mean forall a. IORef (Maybe a)
04:59:38 <Boomerang> adjofun: What I had in mind (and probably badly paraphrased) was the way the motivation for types is explained in Type Driven Development with Idris
05:00:02 <Ariakenom> btw IDEs don't want static types but static namespaces
05:00:09 <Boomerang> adjofun: Obviously the Haskell compiler still needs to be able to represent values in memory just like C and Java compilers do
05:00:19 <Ariakenom> and OO objects bundle those
05:00:33 <dstolfa> Ariakenom: IDEs mostly just want a language without compilation units and headers like C/C++ have :P
05:00:34 <aarvar> merijn: so the problem arises from the fact that the type argument gets erased and the same ref gets shared at multiple types
05:00:48 <helichopter> if i'm writing a function declaration, and I want my function to take a parameterized type, whose parameter itself is a type (like Integer or String as opposed to 1 or "string"), and return a value of that type (like 1 or "string"), what would that look like?
05:00:57 <hpc> Ariakenom: that's a really succinct way of phrasing something ive wondered about for a while
05:00:59 <Boomerang> But in C and Java, types are mainly seen as an obstacle the programmer as to deal with in order for their program to work
05:01:24 <Boomerang> Not something they can rely on to actually help them write code
05:01:33 <Boomerang> *has
05:01:35 <hpc> (why ide featuresets vary so wildly)
05:01:57 <adjofun> Boomerang: dumb compiler vs smart compiler =:)
05:02:01 <Ariakenom> hpc, glad to hear it.
05:02:27 <Boomerang> :)
05:03:00 <aarvar> helichopter: what do you mean by "take a parameterized type, whose parameter itself is a type"
05:03:11 <adjofun> Boomerang: Again, this is just because you cant look at type of function in C, and infer much from it. `launchMissiles` is still my favourite example of it.
05:03:38 <lemmih> helichopter: Sounds a bit like the Default class.
05:03:43 <dstolfa> adjofun: void (*launchMissles)(void); :)))))))
05:04:00 <Ariakenom> Lisps tend to be dynamically typed with static namespaces right?
05:04:13 <Boomerang> unsafePerformIO launchMissiles -- :D
05:04:22 <aarvar> Ariakenom: weren't you paying attention? there's no such thing as dynamic types
05:04:27 <dstolfa> history repeats itself
05:04:27 <aarvar> you mean "unityped"
05:05:04 <adjofun> dstolfa, Boomerang: Better off launching them with your own hands then =:)
05:05:04 <tdammers> the confusion comes from how people mean different things when they say "type"
05:05:05 <dstolfa> aarvar: so just curious -- what would be a good term for canonical runtime types that aid the runtime in certain things?
05:05:08 <aarvar> adjofun Boomerang: well, also Java doesn't have higher kinds, so you have to copy/paste if you want type safety
05:05:16 <dstolfa> aarvar: i don't have a good name for it
05:05:19 <aarvar> dstolfa: tags?
05:05:28 <reactormonk> Is there something similar to foo@(head : tail) for HLists? Aka capture the whole list, but also head?
05:05:38 <dstolfa> aarvar: that might work, or properties...?
05:05:39 <aarvar> dstolfa: classes?
05:05:46 <dstolfa> aarvar: classes will confuse every OOP person ever
05:05:56 <aarvar> dstolfa: they're already hopelessly confused
05:06:06 <aarvar> OOP doesn't exist either
05:06:40 <aarvar> dstolfa: class probably wouldn't confuse them though
05:06:56 <lemmih> reactormonk: The straightforward way doesn't work?
05:06:58 <aarvar> since most of those languages allow reflection
05:07:01 <fishythefish> reactormonk: foo@(HCons head tail)?
05:07:03 <Boomerang> reactormonk: Something like foo@(a :+: b :+: HNil) ? I don't know which HList you're using :)
05:07:04 <aarvar> so classes really are checkable at runtime
05:07:15 <dstolfa> aarvar: good point. also screw terminology :(
05:07:23 <dstolfa> aarvar: everyone has their own name for this particular thing
05:07:33 <reactormonk> lemmih, on typelevel. Sorry, forgot to mention that. Writing an instance signature.
05:07:45 <adjofun> terminology needs explicit namespaces IMHO
05:07:50 <aarvar> lol
05:08:01 <dstolfa> adjofun: but what is a namespace? C++ namespace?
05:08:03 * dstolfa hides
05:08:12 <aarvar> there's no such thing as dynamic `TypeTheory.type`s
05:08:47 <Boomerang> reactormonk: You might need DataKinds: myHList ~ ('HCons head tail)
05:08:48 <aarvar> the type theorists shouldn't get to hog the word "type"
05:09:06 <dstolfa> aarvar: the confusion arises when you talk about runtime "types" in conjunction with a typing system
05:09:10 <reactormonk> Boomerang, that makes undecidableinstances yell at me :-(
05:09:14 <dstolfa> aarvar: this often arises in the domain of CFA
05:09:14 <helichopter> aarvar, I'd like to build a tree of Nodes where each Node has an associated type, but not an actual value, so I'd want to construct it with Node Integer instead of Node 1
05:09:19 <dstolfa> aarvar: and it's annoying
05:09:28 <merijn> reactormonk: So enable UndecidableInstances?
05:09:31 <Ariakenom> Namespaces.Namespace.Control.Concurrent.Parallel.Future.FutureFactory
05:09:34 <aarvar> helichopter: so you want a data structure containing types?
05:10:07 <helichopter> aarvar, I think so yes
05:10:56 <aarvar> helichopter: you could use singletons..but there's a good chance this is an instance of the xy problem
05:11:54 <Boomerang> helichopter: What do you intend on doing with the types in the nodes of your tree?
05:12:03 <dstolfa> aarvar: would this be ambiguous to you in any way: "an allocation belongs to a class which corresponds to the canonical type specified in the source language/IR" as a replacement for dynamic "types" or runtime "types"?
05:12:30 <merijn> There's no "Functor f => f (a -> b) -> a -> f b" hidden somewhere, is there?
05:12:42 <helichopter> Boomerang, using them as the keys in a map from type -> values/functions of that type
05:12:55 <dstolfa> if the language is unityped, they're all the same. if it's C or C++, it would be things like "int", "long", "uintptr_t", a struct or something along the lines
05:13:06 <merijn> helichopter: Types are erased at compile time, so they don't exist at runtime
05:13:13 <merijn> helichopter: So you can't use them as keys in a map
05:13:38 <lemmih> helichopter: Maybe you want to use TypeReps.
05:13:39 <dstolfa> merijn: i was just discussing with aarvar how to call the thing people usually call runtime "types", see above
05:13:54 <cocreature> merijn: it’s in lens™
05:13:56 <cocreature> :t (??)
05:13:57 <lambdabot> Functor f => f (a -> b) -> a -> f b
05:14:02 <merijn> dstolfa: "tags" is common terminology
05:14:17 <aarvar> merijn: well, the map could exist on the type level
05:14:20 <merijn> I would've expected <&> but that doesn't do what I want
05:14:23 <dstolfa> merijn: i've never seen anyone call it a tag amongst the compiler engineers i know
05:15:00 <aarvar> dstolfa: and we know compiler engineers are all experts
05:15:11 <dstolfa> merijn: in fact, -frtti (runtime type information) in clang/clang++ might trigger you :>
05:15:13 <merijn> cocreature: Not sure that operator improves things :p
05:15:19 <dstolfa> merijn: no but i have to work with some
05:15:31 <dstolfa> merijn: and i'd like to avoid confusion and actually not mix a type with the notion of a tag
05:15:31 <merijn> cocreature: I just dislike doing "foo <*> pure blah"
05:15:34 <dstolfa> and have it be clear to them
05:16:06 <Boomerang> helichopter: If you want to go from a type to value, I think you could use type classes. class MyValue a where getValue :: a; intance MyValue Int where myValue = 42
05:16:09 <cocreature> merijn: I’ve used fmap ($x) f in the past but it’s not pretty either
05:16:30 <aarvar> helichopter: maybe you could share your original problem
05:16:35 <Boomerang> s/myValue/getValue/
05:16:39 <dstolfa> aarvar: aehm, i pinged merijn by accident: < dstolfa> merijn: no but i have to work with some
05:17:08 <aarvar> helichopter: but you might consider forall a. Tree (Foo a) -> a
05:17:09 * dstolfa didn't get enough sleep
05:17:17 <aarvar> er no, nvm
05:18:01 <Boomerang> :t \f x -> f <*> pure y
05:18:02 <lambdabot> Applicative f => f (Expr -> b) -> p -> f b
05:18:21 <aarvar> ...
05:18:45 <Boomerang> :t f
05:18:46 <lambdabot> FromExpr a => a
05:19:03 <aarvar> :t \f x -> f <*> pure x
05:19:04 <lambdabot> Applicative f => f (a -> b) -> a -> f b
05:19:07 <aarvar> there you go
05:19:38 <Boomerang> How? Was f not defined as something else earlier?
05:19:53 <cocreature> Boomerang: you used 'y' instead of 'x'
05:20:04 <Boomerang> oh :o
05:20:09 <Boomerang> I see, sorry about that
05:20:40 <cocreature> how do I get optparse-applicative to print something more useful than “Missing: (COMMAND | COMMAND | COMMAND | COMMAND | COMMAND)” when I don’t supply a command?
05:20:42 <merijn> Boomerang: The entire point was that that way to write it looks ugly :)
05:20:48 <cocreature> e.g. the actual command names would be nice
05:21:09 <merijn> cocreature: Seems like you forgot to specify names?
05:21:48 <adjofun> cocreature: metavar
05:22:10 <merijn> cocreature: lpaste your parser?
05:22:44 <cocreature> https://gist.github.com/cocreature/e4409b91c9f038dca35cfd2fc08dcf1c
05:22:59 <Boomerang> It doesn't look too bad to me, or are you trying to use it in a pointfree style? :)
05:23:05 <cocreature> I’m already passing the string to `command`, why doesn’t it just suggest that?
05:23:15 <merijn> That looks wrong
05:23:49 <merijn> cocreature: I've always written a single hsubparser which takes all command in one go
05:24:03 <cocreature> oh right, let me try that
05:24:06 <merijn> cocreature: I wonder if this <|> approach with multiple hsubparser's is producing this weirdness
05:25:15 <adjofun> cocreature: because reasons. You can use `metavar` there, and maybe poke devs about it.
05:25:32 <merijn> cocreature: Also seems like you could avoid a whole bunch of redundant datatypes by just returning IO () directly from parser
05:25:49 <cocreature> now I just get "Missing: COMMAND", I guess I’ll just throw prefShowHelpOnError
05:26:22 <CartelCobana> What is going on with Set.\\ ? https://pastebin.com/hegqWdE8
05:26:24 <merijn> hmm, yeah I'm getting the same missing "COMMAND" now, I seem to remember it working right before
05:26:25 <cocreature> merijn: I know but I find the additional indirection helps keeping things organized
05:27:28 <cocreature> adjofun: metavar still won’t give me the different commands, right? it will just let me replace "COMMAND" by something else
05:28:45 <adjofun> cocreature: yes. You can replace "Missing: (COMMAND | COMMAND | COMMAND | COMMAND | COMMAND)" with "Missing: (roundtrip | check | smt | cfg | inductive-template)"
05:28:49 <cocreature> anyway showHelpOnEmpty works
05:29:15 <cocreature> adjofun: right but then I need to duplicate the info on which commands are available
05:29:56 <CartelCobana> Anybody knows what Set.
05:30:06 <CartelCobana> Anybody knows what Set.\\ does here? https://pastebin.com/hegqWdE8
05:30:09 * hackage constraints-emerge 0.1 - Defer instance lookups until runtime  http://hackage.haskell.org/package/constraints-emerge-0.1 (isovector)
05:30:23 <cocreature> CartelCobana: have you looked at the docs of Set.\\?
05:30:58 <CartelCobana> Yep im in Data.Set and I'm not seeing anything
05:31:25 <Boomerang> https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Set.html#v:-92--92-
05:32:03 <CartelCobana> I'm really sorry guys, that was a dumb question
05:32:08 <cocreature> CartelCobana: you can use hoogle to find things https://hoogle.haskell.org/?hoogle=(%5C%5C)%20module%3AData.Set
05:32:15 <Boomerang> (I typed Set.\\ in https://hoogle.haskell.org)
05:32:16 <CartelCobana> it's literally at the top of the docs
05:32:17 <CartelCobana> apologies
05:33:04 <Boomerang> CartelCobana: Searching straight in hackage is not always easy, especially when different versions of a package expose different APIs
05:33:14 <Boomerang> (too slow :/)
05:38:31 <merijn> Monadic loops: Fix or explicit recursion? Some part of my brain keeps telling me explicit recursion can trigger space leaks, but I'm not sure when that happens and whether I should worry about it
05:40:29 <dminuoso> merijn: Regarding our earlier discussion: What meaning do you have in mind about "unboxed"?
05:42:02 <merijn> dminuoso: primitive values the compiler can directly use without going through an indirection. ByteArray# is a pointer to an allocation that's directly usable. It's boxed equivalent would be "Ptr a" where you have to first go through the indirection to get a raw poitner
05:43:16 <Ariakenom> Int is a pointer to an allocation that's directly usable?
05:43:22 <dminuoso> merijn: It's not directly usable because you have that indirection to the heap. GHC internally (and in various places in official documentation) consistently considers ByteArray# boxed: https://github.com/ghc/ghc/blob/master/compiler/types/Type.hs#L253-L254
05:44:00 <cocreature> Ariakenom: no, Int# is
05:44:02 <dminuoso> https://github.com/ghc/ghc/blob/master/compiler/types/Type.hs#L287
05:45:26 <Ariakenom> data D = D Int -- double indirection to int? D Int# -- one indirection?
05:45:30 <dminuoso> From the GHC manual: "Most types in GHC are boxed, which means that values of that type are represented by a pointer to a heap object."
05:46:53 <dminuoso> And equivalently: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
05:47:17 <Ariakenom> Ah Int is lifted and ByteArray# isn't
05:49:07 <merijn> dminuoso: Maybe I misunderstood what ByteArray# is
05:50:42 <dminuoso> merijn: And I misremembered that a suffix # meant unlifted. It seems to just imply "primitive" based on the GHC manual.
05:50:52 <merijn> Any comments on how to make this code look nicer? Specifically the if/then/else and the let/in for the recursion look kinda bad: http://lpaste.net/732088248028889088
05:51:14 <Ariakenom> Is there an unboxed bytearray?
05:52:47 <dminuoso> Ariakenom: Unlifted tuples?
05:54:29 <Ariakenom> dminuoso, I want runtime length.
05:56:28 <cocreature> unboxing and variable sizes don’t go together very well
05:59:43 <Ariakenom> what are the issues?
06:02:41 <merijn> No brilliant suggestions how to rewrite that loop?
06:05:03 <Ariakenom> merijn, you don't want the else-case uninlined?
06:06:12 <merijn> Ariakenom: No clue what you mean by that
06:22:45 <Ariakenom> merijn, binding (the do-block you have in the else-case) in the let-block
06:25:30 <Ariakenom> that might not be too clear either. owrds are too hard
06:26:50 <zincy> When does it make sense for the id of elements in a collection to be an Integer vs a Hash?
06:26:57 <zincy> Hash of the contents I mean
06:28:51 <lemmih> zincy: Always use an ID number if you have it.
06:31:20 <chorhizo> Hey, I'm trying to find an excuse to get ghc packaged at work. There is a set of a million rows I need to parse with a few complex rules, would ghc be fast and easy for something like that?
06:31:35 <chorhizo> I could just smash it in Java but I wonder if I can get away with haskell
06:32:23 <merijn> chorhizo: Should be easy, grab a streaming library (conduit, pipes, or machines). Write a simple parser using attoparsec, plug the two into each other and cobble the entire thing together in a day
06:32:37 <merijn> chorhizo: Then rejoice with it being trivial to maintain and parallelise :p
06:33:10 <zincy> lemmih - so stay away from hashes?
06:35:58 <merijn> chorhizo: In fact, I would say that with the current Haskell ecosystem this tasks sounds like it was designed to exhibit exactly how amazing haskell is :p
06:36:06 <lemmih> zincy: Or consider ID numbers to be the perfect hashes.
06:37:36 <zincy> Even if you a running multiple server instances that need to share the state?
06:39:40 <chorhizo> merijn: that's what I was hoping you'd say...
06:40:01 <chorhizo> It would be a one use script but it's for something mission critical
06:40:09 * hackage constraints-emerge 0.1.1 - Defer instance lookups until runtime  http://hackage.haskell.org/package/constraints-emerge-0.1.1 (isovector)
06:40:27 <Ariakenom> zincy, https://en.wikipedia.org/wiki/Universally_unique_identifier
06:40:38 <chorhizo> I'll try it out on some test data tonight and see how it goes, thanks
06:41:09 <Ariakenom> but hashes are great too
06:41:42 <lemmih> zincy: If you already have ID numbers which are globally unique then you should use them.
06:41:42 <Ariakenom> depends on the context
06:42:37 <chorhizo> merijn: it would be parsing xml rows though, not sure if that makes it much harder
06:43:28 <merijn> chorhizo: xml-conduit already has some tools for parsing xml in a streaming method
06:43:42 <chorhizo> Would I just need to ask them to package stack, then run stack through the company proxy?
06:43:59 <chorhizo> Ok cool,
06:44:21 <merijn> chorhizo: I don't use stack, so no clue. Personally I tend to just install the GHC bindist, build cabal from scratch then use cabal
06:44:48 <merijn> chorhizo: All of which works fine without root access and cabal-install should Just Work if you set the proxy config right
06:44:53 <cocreature> you shouldn’t have to ask them to package either stack or cabal, both work without root
06:45:26 <cocreature> the fact that Haskell tooling works just fine without being root is one of the more underappreciated facts about using Haskell
06:45:33 <merijn> cocreature: Word.
06:45:42 <chorhizo> They might get mad if I just install stuff from the wild west
06:45:53 <chorhizo> On winblows unfortunately
06:46:04 <chorhizo> Unless I could install stack through mingw
06:51:25 <zincy> So lets say the element of the map DS represents an auction - any server instance could create a new auction. If you give Int IDs then does each server take the Max Number and then increment? If all the servers are not perfectly synced then surely you will get a collision very quickly?
06:53:33 <adjofun> chorhizo: why don't you just get a Haskell Platform?
06:54:28 <Ariakenom> zincy, pick a random 128 bit number. collision is negligible.
06:55:18 <Ariakenom> hash collisions are also a thing.
06:55:26 <zincy> oh my random Int
06:55:32 <zincy> Why didnt I think of that omg
06:56:50 <reactormonk> If I have ghc-options set in a library, does that affect my binary at all?
06:57:08 <merijn> reactormonk: No, executables have a separate ghc-options field
06:58:37 <zincy> Thanks
06:58:38 <cocreature> zincy: if you go down that route, just pick a lib for uuid v4.
07:00:10 <zincy> cocreature - you mean for random number gen?
07:00:30 <cocreature> zincy: uuid v4 is a standard for randomly generated IDs
07:01:12 <cocreature> https://hackage.haskell.org/package/uuid-1.3.13/docs/Data-UUID-V4.html
07:01:41 <zincy> Cheers!
07:05:46 <zincy> I should use hashmap insteat of a map right?
07:06:14 <zincy> As the former would enforce unique keys?
07:07:38 <Ariakenom> zincy, they behave the same
07:08:02 <zincy> So why the difference in name?
07:08:06 <cocreature> if you have a Hashable instance the only difference is performance and there is no clear answer as to which one performs better
07:08:13 <cocreature> because one is based on hashes and the other isn’t
07:09:00 <zincy> ah ok
07:12:59 <cocreature> phadej: do you happen to have some helpers for tasty-hunit lying around that handle colors correctly? the fact that tasty-hunit (haven’t tracked down whether the problem is in tasty or hunit) colors the error itself means that the beginning of the diff is also colored which is a bit annoying
07:13:29 <cocreature> phadej: helpers for tree-diff that is, sry completely forgot to mention what I was talking about :)
07:23:52 <Boomerang> What would you expect x to be (using Given from reflection) in : x = give @Int 5 $ give @Int 2 $ given @Int
07:23:56 <Boomerang> 5 or 2?
07:24:21 <Boomerang> The answer is 5, can anyone explain to me why that's the case?
07:27:12 <Taneb> Boomerang: I don't think you can rely it on being either across different versions of GHC
07:28:34 <Boomerang> I've been trying to not nest them but I noticed something weird happening in our test suite. Then only thing I can think is happening is that they end up being nested somehow
07:29:01 <Taneb> I'm personally against the use of Given in anything serious
07:29:07 <Taneb> It's a really fragile piece of machinery
07:29:56 <Boomerang> Well we're kind of using it all over the place ^^
07:32:43 <cocreature> stop doing that :)
07:33:13 <phadej> cocreature: I prepend "setSGRCode []" before I output something which I mean to color myself
07:33:40 <cocreature> phadej: ah that’s useful, thanks!
07:33:42 <phadej> cocreature: in golden helper I do that, but probably not anywhere else
07:37:32 <reactormonk> When exactly are FunDeps resolved? https://gist.github.com/reactormonk/ea20719a11ba28aa04a042fcb2aee278
07:48:06 <phz_> oh my
07:48:09 <phz_> I HATE persistent
07:48:41 <phz_> I’m using the insertBy function to insert something and get a Left if it’s violating uniqueness properties (primary key, mostly)
07:48:51 <phz_> seems like persistent doesn’t allow me to do that
07:49:12 <phz_> I get an error about getByValue stating there’s no Unique
07:49:19 <phz_> (isn’t a primary key a unique?)
07:50:55 <zincy> How do I get faster compiler times when using nix-build in a miso / GHCJS project?
07:54:35 <aarvar> edwardk: finally bothered to add the ideas from my naperian package to adjunctions: https://github.com/ekmett/adjunctions/pull/49
07:58:16 <DigitalKiwi> aarvar monads are like burritos
08:08:39 <humanoyd> Is there a quick way to find out which packages on hackage have not been updated to work with GHC 8.4? (something like sort by upload date would work too)
08:12:09 * hackage gmpint 0.1.0.11 - GMP integer conversions  http://hackage.haskell.org/package/gmpint-0.1.0.11 (vmchale)
08:16:52 <phz_> seriously
08:17:06 <phz_> I want to get something with persistent
08:17:21 <phz_> where I changed the type of the primary key
08:17:25 <phz_> persistent doesn’t know how to do this
08:17:31 <phz_> I think I’m just going to drop persistent
08:17:37 <phz_> and use something that works
08:25:39 * hackage Hastodon 0.3.2 - mastodon client module for Haskell  http://hackage.haskell.org/package/Hastodon-0.3.2 (syucream)
08:32:12 <rckd71> hey guys, dump question: how can i change a specific index of a record field? lets say i got   Person { pets = ["miau", "wuff", "hoar"] }   is there an easy way to change "wuff" to something else with record syntax?
08:36:04 <hexagoxel> rckd71: with lens you can make that concise, with just record syntax i don't think there is a particularly neat solution.
08:36:53 <Taneb> rckd71: this is what lens is for
08:38:49 <cocreature> tbh you probably shouldn’t be using lists if you want to do that often
08:39:56 <dpyro> what would be the best way to do a datatype that has some regular values and some state values?
08:40:16 <rckd71> hmm im just learning haskell basics by building a simple card game. now im in the situation where i have to change the cards on a players hand. i heard about lense but never used it. maybe i give it a try now
08:40:38 <dpyro> i'm looking into Control.Monad.State but should the monad be the datatype, or should i try to put the datatype in the monad?
08:42:05 <dpyro> i'm also not sure why State has two typevars
08:42:09 <dpyro> instead of just one
08:43:11 <fr33domlover> dpyro, one is the type of the state, the other is the value returned from the monadic action
08:43:18 <joncfoo> Anyone here get `codex` to work instead of `hasktags` in haskell-mode?
08:43:27 <adjofun> :i State
08:44:07 <dpyro> fr33domlover so do i directly call "runState", "evalState" as the consumer of the datatype?
08:44:24 <dpyro> or do i wrap those methods with the ones i want on the datatype?
08:45:37 <fr33domlover> dpyro, what exactly do you want to do? a typical example is that you have some "do" block running in State (or StateT) and you apply runState or execState or evalState to that
08:47:09 <dpyro> so could i do a `getNextValueAndUpdate :: State MyClientState → value` ?
08:47:24 <dpyro> of course then i'm not sure where the next state goes
08:48:31 <fr33domlover> dpyro, when you're "inside" the State monad, you use functions like "put" and "get" and "gets" and "modify" to manipulate the state
08:50:32 <fr33domlover> dpyro, think of "State s a" as a composition of functions that manipulate some state and some return value, and you pass some initial and state maybe some initial value, apply that composition and get the final resulting state and value
08:51:45 <ni291187> ciao
08:52:06 <fr33domlover> You don't extract values out of the State computation in the middle of it; you extract the value in the end when you run the whole monadic action on some initial state
08:52:11 <fr33domlover> Hi ni291187
08:52:16 <dpyro> 🤔
08:52:36 <dpyro> starting to get it, found some examples at the bottom of the state docs so i'll try to much with those
08:54:41 <Taneb> merijn: your recurring question: with -XMonadComprehensions, \a p -> [a | p a]
08:54:56 <Taneb> Works for any alternative ;)
08:55:11 <Taneb> (that is also a monad)
09:06:17 <Zemyla_> What are the changes from base 4.10.1.0 to 4.11.0.0?
09:10:12 <lyxia> Zemyla_: you can take a look at base's changelog https://hackage.haskell.org/package/base-4.11.0.0/changelog
09:14:41 <cocreature> Taneb: oh neat, I completely missed the fact that guard has been generalized to Alternative in base 4.8 and this thereby no longer requires MonadPlus
09:16:03 <chorhizo> Is there a good ftp library for haskell? I found this but I'm not sure if it's old or good or? https://hackage.haskell.org/package/ftphs-1.0.9.2/docs/Network-FTP-Client.html
09:16:24 <dsal> Anything ftp must be old and not good.
09:16:59 <dsal> chorhizo: A reputable author wrote that.  Does it fail you in some way?
09:16:59 <chorhizo> I guess I'd need to ssh to view the file and path then use ftp to grab it
09:17:33 <fr33domlover> chorhizo, it looks good to me
09:17:35 <chorhizo> dsal: I haven't tried it but there isn't much info on using ftp when I Googled it, I'll give it a shot
09:17:57 <dsal> Because nobody should be using FTP after 1997.
09:18:35 <chorhizo> dsal: wait why not
09:18:48 <chorhizo> How am I supposed to transfer files from a server to my pc?
09:19:04 <ArchieT> Help! TypeFamilies DataKinds
09:19:32 <ystael> chorhizo: We are successfully using https://hackage.haskell.org/package/ftp-client
09:20:01 <fr33domlover> chorhizo, you *can* use ftp. to tranfer your files though a more common way these days may be ssh/scp
09:20:05 <ystael> because sometimes we have to integrate with vendors who don't know that it's no longer 1997
09:20:25 <fr33domlover> chorhizo, or rsync over ssh
09:21:00 <ArchieT> I have a datatype, with nullary constructors
09:21:19 <ArchieT> I have a type family parametrized with it's datakind
09:21:21 <chorhizo> fr33domlover: huh, that's good to know. I might try using that then
09:21:43 <DigitalKiwi> chorhizo http://mywiki.wooledge.org/FtpMustDie
09:21:59 <ArchieT> I want to parametrize a field of that type family in a parametrized datatype
09:22:04 <glguy> ArchieT: If you have a question about some code, put the code on a pastebin service so we can see it
09:22:15 <ArchieT> So I need a parametrized constructor
09:22:28 <ArchieT> Constructor parametrized with a kind other than a type
09:23:21 <fr33domlover> ArchieT, it's a bit confusing to read, paste some code ^_^
09:23:24 <ArchieT> I'm not sure if it requires code illustration
09:23:45 <ArchieT> You need one?
09:24:08 <ArchieT> I think I can explain it without one
09:24:08 <fr33domlover> ArchieT, even fake code showing how you'd imagine it
09:24:34 <ArchieT> Ok, will try to prepare an example
09:24:34 <chorhizo> DigitalKiwi: I see.. Just thought I'd try to implement an ftp client for the heck of it, maybe I'll use something else..
09:25:25 <cocreature> chorhizo: if all you want is to transfer some files from a server to your pc, just serve them using an http server
09:27:45 <chorhizo> cocreature: I'm sorry, what do you mean just serve them using an http server? Like, just make them available?
09:28:02 <cocreature> chorhizo: run an http server on the server and use some http lib to download them
09:31:18 <chorhizo> Cocreature: Huh, that seems simple, I'll try that
09:32:33 <fr33domlover> chorhizo, if it's for private/internal/backend use, scp/rsync may be easier, more flexible
09:32:54 <fr33domlover> (ssh key gives you auth, and you can recursively grab directories etc. etc.)
09:34:38 <ArchieT> My laptop battery is almost dead and guys keep making fun of erasing my part of whiteboard, I think I need to find some computer (I am on a mobile and writing code is unpleasant on either a phone or a sheet of paper)
09:36:44 <fr33domlover> ArchieT, throw exceptions at those guys
09:37:02 <fr33domlover> Exceptions that they can't handle
09:38:34 <zincy> Whats the safe way toi convert a string to an int (Form validation in Miso)?
09:39:10 <dsal> > readEither "1" :: Either String Int
09:39:11 <fr33domlover> :t maybeRead
09:39:12 <lambdabot> error: Variable not in scope: maybeRead
09:39:13 <lambdabot>  error:
09:39:13 <lambdabot>      • Variable not in scope: readEither :: [Char] -> Either String Int
09:39:13 <lambdabot>      • Perhaps you meant one of these:
09:39:18 <dsal> lame
09:39:23 <fr33domlover> :t readMaybe
09:39:24 <dsal> > Data.Text.readEither "1" :: Either String Int
09:39:25 <lambdabot> error: Variable not in scope: readMaybe
09:39:26 <lambdabot>  error:
09:39:26 <lambdabot>      Not in scope: ‘Data.Text.readEither’
09:39:26 <lambdabot>      No module named ‘Data.Text’ is imported.
09:39:34 <fr33domlover> ^_^
09:39:43 <dsal> lambdabot offers no safety.
09:41:19 <lemmih> > fmap fst $ listToMaybe $ reads "123" :: Maybe Int
09:41:21 <lambdabot>  Just 123
09:41:23 <lemmih> > fmap fst $ listToMaybe $ reads "bad" :: Maybe Int
09:41:25 <lambdabot>  Nothing
09:42:06 <dsal> Text.Read is quick and easy.
09:42:17 <ArchieT> DataKinds, TypeFamilies, GADTs. types X,Y,Z,W. data D = A|B|C. type family F (p::D) where F A=X ; F B=Y ; F C=Z. type M (p::D) = (M p,W). data N where N :: (p::D) → N. Error: Expected type but is kind D.
09:42:25 <zincy> Thanks
09:42:46 <zincy> Exactly what I needed :)
09:42:57 <dsal> You can do Either String or Maybe
09:43:16 <dsal> Though I guess Either String isn't as useful as you'd hope.
09:43:52 <dsal> Left "Prelude.read: no parse"
09:44:22 <dsal> I think the next version of GHC replaces that string with "Nope, arse"
09:47:10 <fr33domlover> ArchieT, idk much about datakinds but aren't you doing dependently typed stuff there?
09:47:12 <fr33domlover> like,
09:47:27 <fr33domlover> defining type family members based on data constructor values
09:48:03 <ArchieT> Deadline is tomorrow, I need to finish this and I am stuck at this :(
09:48:09 <fr33domlover> p can be * or * -> * etc.
09:48:26 <ArchieT> Yeah
09:48:27 <fr33domlover> but can p be a conrete type? idk
09:48:32 <fr33domlover> never saw such a thing
09:48:52 <fr33domlover> ArchieT, what's the task you've been given
09:49:31 <EvanR> type M (p::D) = (M p,W) isnt this an infinite type
09:49:31 <fr33domlover> ArchieT, how about you move D into the type level?
09:50:12 <ArchieT> My project, implementation of 3 man chess
09:50:30 <EvanR> ...,W),W),W)
09:50:50 <ArchieT> *(F P,W) sorry
09:51:05 <ArchieT> *p
09:51:21 <fr33domlover> ArchieT, why do you need a type family where the argument is a data constructure (is that even possible)
09:51:42 <ArchieT> How can I move it onto the type level
09:51:49 <ArchieT> They are nullary constructors, like, an enum
09:52:06 <fr33domlover> ArchieT, I mean if yo get A/B/C values at runtime
09:52:11 <fr33domlover> Then this is impossible
09:52:12 <EvanR> data N where N :: (p::D) → N, why not data N where N :: D → N
09:52:31 <fr33domlover> if you get A/B/C at compile time,
09:52:33 <ArchieT> To be precise, it's: data FigType = King | Queen | …
09:52:40 <ArchieT> The D type
09:53:33 <EvanR> fr33domlover: type family where arguments are types of course, A B C are types here
09:53:42 <EvanR> not runtime
09:54:08 <fr33domlover> EvanR, but data D = A | B | C
09:54:21 <fr33domlover> so A/B/C are data constructors there
09:54:21 <EvanR> and D is a kind
09:54:24 <EvanR> DataKinds
09:54:27 <fr33domlover> ah ok
09:54:29 <ArchieT> Why shouldn't it be possible? Like, you could have a type family "Tuple" parametrized with, like, a non-negative integer type
09:54:41 <ArchieT> The integer type could be a datatype for Peano
09:54:47 <fr33domlover> EvanR, so with DataKinds you can define D like that and it's a kind?
09:54:52 <EvanR> yes
09:55:10 <EvanR> and ArchieT is really talking about a peano kind, and each number is a type
09:55:41 <ArchieT> Oh, I forgot
09:56:01 <ArchieT> F A= 'X …
09:56:11 <ArchieT> Promoted
09:56:12 <EvanR> that should matter
09:56:14 <EvanR> shouldnt*
09:56:44 <EvanR> X is already a type
09:57:32 * fr33domlover still doesn't know much about kinds, he'd probably implement chess as a runtime 8x8 board, although the idea of a build time type level chess game sounds cool :p
09:58:22 <EvanR> you vs the type checker, a game of chess
09:58:33 <ArchieT> Nooo, it's gonna be at runtime
09:58:54 <EvanR> you didnt answer my question
09:59:03 <ArchieT> I just need a type for move vectors parametrized with a FigType
09:59:20 <EvanR> so i guess the question is, whats your actual problem now
10:00:04 <ArchieT> Which one?
10:00:10 <EvanR> :|
10:00:30 <fr33domlover> ArchieT, move vectors?
10:00:39 <EvanR> for great justice
10:02:14 <ArchieT> That a datatype constructor cannot be parametrized with a datatype value, and the whole problem... eh, I'll see how much battery do I have on my laptop
10:02:30 <EvanR> haskell does not have dependent types
10:02:47 <EvanR> you cant pass values to type families or type constructors
10:03:04 <EvanR> you just cant
10:03:20 <EvanR> (yet)
10:03:28 <fr33domlover> ArchieT, a type family is like a function on types. If you're working with values, perhaps just use a regular plain old function?
10:03:50 <EvanR> type families take types and return types, not values
10:04:21 <EvanR> data types are parameterized by other types, not values
10:04:25 <fr33domlover> Btw I discovered injective type familities recently
10:05:13 <fr33domlover> Which is nice :p
10:05:34 <fr33domlover> Had some use case for that recently, can't recall what it was
10:06:55 <pavonia> Isn't data type promotion pretty much like dependent types?
10:07:13 <ArchieT> Ré.
10:07:13 <geekosaur> no
10:07:14 <ArchieT> but can such a function return a type?
10:07:26 <EvanR> ArchieT: no
10:07:34 <geekosaur> because data type promotion is not identity
10:07:35 <EvanR> types dont exist at runtime
10:07:50 <ArchieT> actually, type families support values as parameters. It's just that datatype constructors don't.
10:07:57 <EvanR> no they dont
10:08:23 <ArchieT> https://github.com/ArchieT/ThreeManChess/blob/master/src/ThreeManChess/Engine/Move.hs here is everything
10:08:25 <fr33domlover> ArchieT, what do you need the type family for exactly?
10:08:32 <marble_visions> all, a haskell newbie here. i want to do some programming in parallel to theory reading. what's the easiest way make myself a subtype of Natural? seems like dependent types in haskell is an advanced topic. i don't want to go there just yet, i just need my "data Points = 1|2|3|4|5"-like functionality
10:08:39 <geekosaur> if you promote data Foo = FooA | FooB, the type FooA is not the same as the value FooA. and the type FooA is of kind Foo, not kind *, so it doesn;t have values
10:08:58 <marble_visions> should I go with data Points = One | Two | Three.. ?
10:09:06 <marble_visions> and then use ord
10:09:24 <EvanR> ArchieT: what is your problem, your question
10:09:37 <fr33domlover> marble_visions, when I started I was doing stuff like write a program that remembers a number and lets you modify it and display it using the terminal :p
10:09:41 <fr33domlover> Dumb things like that
10:09:48 <EvanR> at this point we are just telling you facts that youre ignoring, and spinning wheels without getting anywhere
10:10:03 <dminuoso> marble_visions: What do you mean by "subtype"
10:10:14 <ArchieT> marble_visions: also a newbie here, that's exactly what I am doing in this project of mine
10:10:14 <cocreature> marble_visions: depends on how many numbers you represent, obviously having thousands of constructors is really unwieldly but if you have 5, then that’s a reasonable solution
10:10:35 <fr33domlover> Personally I found that messing with type stuff early was bad for me because you get errors and fail to build, get frustrated
10:10:51 <fr33domlover> With just simple IO program you get a result that runs and talks back quickly
10:10:54 <fr33domlover> Which is motivating
10:11:06 <cocreature> marble_visions: if you have more, you can use something like "newtype MyInt = MyInt Int" and have a smart constructor "myInt :: Int -> Maybe MyInt" that returns Nothing if the value is out of range
10:11:14 <marble_visions> dminuoso: meaning that the values of the type i want to create are all values of type Positive
10:11:38 <marble_visions> cocreature: oooh, that's interesting
10:11:56 <EvanR> haskell doesnt have subtypes, but you can have a type which embeds into your original
10:12:09 <marble_visions> dminuoso: in my case my type will have the values 1,2,3,4 and 5
10:12:19 <EvanR> smart constructors like myInt can be used to guarantee properties
10:12:25 <EvanR> at runtime at least
10:12:28 <dminuoso> EvanR: They just push it into runtime.
10:12:30 <dminuoso> Yeah.
10:13:00 <ArchieT> EvanR: have you seen the Move.hs? (30 lines)
10:13:06 <EvanR> yes
10:13:09 <cocreature> you can always throw TH at literals to get compile-time validation
10:13:21 <fr33domlover> (You can still do compile time validation of constant numbers using TH, by the way)
10:13:34 <marble_visions> alright, i'll have a go at smart constructors, if i start getting wrapped up, i'll switch to One | Two.. and carry on. thanks all!
10:13:37 <marble_visions> TH?
10:13:38 <fr33domlover> Oops cocreature already said that :p
10:13:44 <dminuoso> marble_visions: Template Haskell
10:13:57 <marble_visions> oh, right.
10:13:59 <cocreature> marble_visions: for 5 values, I’d just go with One | Two | …
10:13:59 <fr33domlover> marble_visions, if you're just starting, forget about TH for now
10:14:32 <marble_visions> fr33domlover: i've come across it when playing with yesod
10:15:14 <cocreature> (or probably C1 | C2 | … since I find that easier to read)
10:15:21 <fr33domlover> marble_visions, ah yes Yesod uses it a lot
10:16:39 <dminuoso> :t liftA2 (,)
10:16:40 <lambdabot> Applicative f => f a -> f b -> f (a, b)
10:16:41 <dminuoso> :t mzip
10:16:42 <lambdabot> error:
10:16:43 <lambdabot>     • Variable not in scope: mzip
10:16:43 <lambdabot>     • Perhaps you meant one of these:
10:16:52 <dminuoso> mzip :: m a -> m b -> m (a, b)
10:17:07 <EvanR> :t liftM2 (,)
10:17:08 <lambdabot> Monad m => m a -> m b -> m (a, b)
10:17:28 <ArchieT> EvanR: so, I want to be able to create a StateMove that would be (Before, BoundMove) where BoundMove would be (Move, Pos) where Move would be dependent on FigType because for a Bishop, a Move would be a Vector of type like (DiagonalDirection, Count), for a Queen it would be like (LinearDirection, Count), for a rook it would be like (StraightDirection, Count), for a king it would be like the KingMove in Move.hs
10:18:19 <cocreature> dminuoso: now do munzip :P
10:18:55 <EvanR> ArchieT: ok
10:20:36 <dminuoso> munzip m = (fst <$> m, snd <$> m)
10:20:38 * dminuoso shrugs
10:21:09 <dminuoso> Something tells me there is more to it than this.
10:21:50 <cocreature> oh I’m stupid
10:28:19 <ArchieT> still here
10:29:17 <EvanR> so what is your current problem
10:29:49 <fr33domlover> ArchieT, personally I think I'd model a move as a pair of origin coord and destination coord, and the player ID
10:30:17 <fr33domlover> Then check if the origin coordinate really has a figure that player owns
10:30:24 <fr33domlover> And the move is valid for that figure
10:30:46 <reactormonk> I get a compiler error here: https://gist.github.com/reactormonk/191e88094e7a221ad9d3df591bb09094 - when I add a fundep to HasRecipe - effect target pot -> deps it binds to the wrong types. Without the fundep, I get an ambiguous type.
10:31:16 <ArchieT> there is no player id needed, its in the state
10:31:24 <ArchieT> and for 3manchess:"in the round"
10:31:26 <ArchieT> one move can be executed in multiple ways
10:32:02 <fr33domlover> ArchieT, sure I just mean a human makes a move like "move the piece at (x1,y1) to (x2,y2) and you could model it like that
10:32:34 <EvanR> are you trying to fix an particular error or
10:32:38 <EvanR> what are you stuck with
10:32:56 <EvanR> or do you want people here to do the project for you
10:32:58 <ArchieT> and also because of a specific thing in this variant, "moats" it matters to analyze both possible ways for a knight move for example
10:33:27 <fr33domlover> ArchieT, if you want to work with typed moves perhaps you could use a GADT for that?
10:33:34 <EvanR> both ways for a knight to move ?? :S
10:33:37 <fr33domlover> in place of those data kinds and stuff
10:33:42 <ArchieT> one move can be executed in multiple ways
10:33:57 <mjhoy> I have a naive question. Why does `show undefined` typecheck? Isn't the Show constraint not fulfilled/resolved?
10:34:08 <EvanR> :t show undefined
10:34:10 <lambdabot> String
10:34:11 <fr33domlover> (ArchieT, even if the board can turn, you can still use coordinates)
10:34:26 <mjhoy> right, why isn't that an error?
10:34:39 <ArchieT> i explain the fundaments for my problem with type system
10:34:43 <EvanR> :t let x = undefined in (show x, x)
10:34:44 <lambdabot> (String, b)
10:34:44 <ArchieT> in place of data kinds… hmm
10:35:15 <EvanR> :t show `asAppliedTo` undefined
10:35:16 <lambdabot> Show a => a -> String
10:35:33 <fr33domlover> ArchieT, a GADTs of moves that has a specific move type for each figure type?
10:35:39 <fr33domlover> *a GADT
10:35:50 <EvanR> mjhoy: well it would be an error if you wanted to know what the string is
10:36:09 <fr33domlover> idk if it's a good idea ArchieT just mentioning the possibility
10:36:11 <lyxia> mjhoy: there are defaults
10:36:33 <mjhoy> How does `undefined` get evaluated... what Show instance gets executed? (does that make sense?)
10:36:35 <ArchieT> one more thing about the game is that here are moves which can be executed with two horizontal ways and one vertical/diagonal way
10:36:44 <ArchieT> hmm… I need to try using GADTS
10:36:47 <EvanR> youre not evaluating or executing anything
10:36:47 <ArchieT> *GADTs
10:36:52 <ArchieT> for that
10:36:53 <ArchieT> will see if I manage to fit it in GADTs
10:36:57 <EvanR> just type checking
10:37:06 <mjhoy> Or, when you do try to evaluate it
10:37:21 <fr33domlover> mjhoy, evaluation will give an error
10:37:23 <EvanR> > show undefined
10:37:26 <lambdabot>  "*Exception: Prelude.undefined
10:37:35 <jle`> mjhoy: defaulting causes it to be ()
10:37:35 <EvanR> lol
10:37:46 <fr33domlover> undefined is kind of like an unsafe version of Proxy a
10:37:46 <dminuoso> mjhoy: It defaults to ()
10:37:52 <jle`> mjhoy: that is a good question, though
10:37:56 <EvanR> i was trying to prove that
10:38:00 <EvanR> but couldnt
10:38:33 <dminuoso> mjhoy: You can observe that if you enable say -ddump-simpl and then try `show undefined`
10:38:46 <mjhoy> I think the model in my head is wrong... I'm picturing some (show x) = ??? instance getting called, where x happens to be undefined, and wondering where that instance is
10:39:05 <EvanR> > show ()
10:39:07 <lambdabot>  "()"
10:39:10 <jle`> mjhoy: your model is correct, it's actually one that a lot of people have problems grasping
10:39:16 <jle`> the missing picture is defaulting
10:39:21 <mjhoy> hmm ok.
10:39:28 <dminuoso> mjhoy: Basically the thing is this:
10:39:30 <dminuoso> :t undefined
10:39:31 <lambdabot> a
10:39:32 <jle`> it's treated as show (undefined :: ())
10:39:36 * [exa] wonders
10:39:49 <[exa]> yes about exactly undefined :: ()
10:39:50 <mjhoy> Defaulting is part of the typechecker?
10:39:58 <jle`> it's a part of haskell
10:39:59 <EvanR> Show is actually part of extended default rules
10:40:03 <jle`> oh nevermind
10:40:35 <[exa]> hm, why does show (undefined :: ()) fail?
10:40:39 <jle`> mjhoy: but yeah, it's a trick that haskell/ghc has to use to get a lot of naive code to compile without requiring annotations
10:40:45 <[exa]> afaik the show instance doesn't have to touch the bottom right?
10:40:50 <EvanR> but it does
10:40:59 <jle`> mjhoy: for example, consider the type of ^
10:41:01 <EvanR> show () = "()"
10:41:01 <jle`> :t (^)
10:41:02 <lambdabot> (Num a, Integral b) => a -> b -> a
10:41:19 <jle`> the two arguments can have different types, so knowing one type doesn't tell you the other
10:41:23 <[exa]> oic, it pattern matches it
10:41:26 <[exa]> thanks :]
10:41:33 <jle`> so what happens if you do (3 :: Double) ^ 2   ?
10:41:44 <jle`> what type is the 2?
10:41:58 <jle`> type inference can't help because there is no clue to what type 2 should be
10:42:07 <jle`> since either side of ^ can have different types
10:42:18 <jle`> with defaulting, ghc just arbitrarily picks (2 :: Integer)
10:42:27 <jle`> so that this can compile without extra annotations
10:42:46 <mjhoy> OK, that makes a lot of sense. I didn't realize Show had that too.
10:42:48 <EvanR> defaulting does help at the very beginning when experimenting or demonstrating on the REPL
10:42:54 <jle`> mjhoy: actually, you can observe the defaulting for () and show in ghci
10:42:59 <EvanR> but then it becomes surprising, like right now
10:42:59 <jle`> mjhoy: if you turn on :set -Wall
10:43:07 <jle`> mjhoy: it'll warn you whenever defaulting happens
10:43:10 <EvanR> i dont really understand defaulting to ()
10:43:26 <EvanR> > read "()"
10:43:26 <jle`> on my ghci if i :set -Wall and show undefined, i get a warning "Defaulting the following constraint to type '()'"
10:43:28 <lambdabot>  ()
10:43:41 <dminuoso> mjhoy: Its not about Show.
10:43:49 <jle`> specifically the warning is :set -Wtype-defaults
10:44:08 <EvanR> https://prime.haskell.org/wiki/Defaulting
10:44:09 <dminuoso> Or.. is it?
10:44:11 <jle`> mjhoy: there's actually just a list of types that ghc tries one-by-one until it finds one that would work/compiles
10:44:20 <jle`> mjhoy: by default (heh) it's (), Integer, Double
10:44:29 <jle`> so it's not just Show, yes
10:44:47 <jle`> i believe you can extend this list on a per-module basis, but it's not exactly considered standard or encouraged practice
10:44:47 <EvanR> () is only tried with extended default rules
10:45:33 <dminuoso> So it's numeric, Show, Eq, Ord and Defaulting that default
10:45:40 <dminuoso> with ExtendedDefaultRules
10:45:44 <mjhoy> I see. It's not even about typeclasses then, any forall a.?
10:45:45 <jle`> it doesn't have anything to do with typeclasses
10:45:50 <lyxia> defaulting is such an ugly mechanism
10:45:51 <jle`> it just tries specific types
10:45:57 <mjhoy> ah.
10:46:01 <EvanR> it only tried with specific type classes
10:46:02 <dminuoso> jle`: It does
10:46:06 <EvanR> not any class
10:46:22 <jle`> oh huh
10:46:36 <EvanR> > 3.14
10:46:38 <lambdabot>  3.14
10:46:39 <jle`> i thought it just tried them out for all ambiguous cases
10:46:41 <EvanR> not ()
10:46:50 <jle`> that's becuase () doesn't have a Fractional instance
10:46:59 <jle`> if it did, then it would be ()
10:47:08 <dminuoso> jle`: In the report 4.3.4, a condition for defaulting is:
10:47:09 <EvanR> ok
10:47:10 <dminuoso> at least one of these classes is a numeric class, (that is, Num or a subclass of Num), and
10:47:22 <jle`> @let instance Num () where _ + _ = (); _ * _ = (); _ - _ = (); fromInteger _ = ()
10:47:23 <lambdabot>  .L.hs:158:10: warning: [-Wmissing-methods]
10:47:23 <lambdabot>      • No explicit implementation for
10:47:23 <lambdabot>          ‘abs’ and ‘signum’
10:47:26 <jle`> > 5
10:47:28 <lambdabot>  5
10:47:31 <EvanR> Num will default without extended defaulting
10:47:34 <jle`> oh weird it worked on my ghci
10:47:42 <jle`> > 1 + 1
10:47:44 <lambdabot>  2
10:47:59 <jle`> those were all () on my ghci i promise :'(
10:48:04 <EvanR> class MyClass a where wont default
10:48:12 <jle`> @let instance Num () where _ + _ = (); _ * _ = (); _ - _ = (); fromInteger _ = (); abs _ = (); signum _ = ()
10:48:13 <lambdabot>  Defined.
10:48:16 <jle`> > 1 + 1
10:48:18 <lambdabot>  ()
10:48:23 <EvanR> o_O
10:48:26 <mjhoy> nice
10:48:33 <jle`> @let instance Fractional () where _ / _ = (); recip _ = (); fromRational _ = ()
10:48:34 <lambdabot>  Defined.
10:48:36 <jle`> > 3.14
10:48:38 <lambdabot>  ()
10:48:41 <EvanR> apparently default is not just adhoc, but inconsistently applied
10:48:50 <jle`> this is consistent with what i said earlier, though
10:48:55 <jle`> it tries out (), then Integer, then Double
10:49:06 <EvanR> unless theres a missing method? O_O
10:49:15 <jle`> oh that was just because lambdabot rejects bindings with warnings
10:49:27 <jle`> so the first instance declaration was never cmomitted to lambdabot
10:49:58 <EvanR> jle`: i dont think it will try Double
10:50:04 <EvanR> for Num
10:50:11 <jle`> it won't, because Integer works
10:50:12 <jle`> so it stops there
10:50:27 <jle`> but if there's a situation where neither () nor Integer works, it'll try Double
10:50:35 <EvanR> according to this random blog post, the rule is "default Num Integer"
10:50:52 <EvanR> perhaps with extended, () gets inserted at the beginning of every default list?
10:51:03 <jle`> i get defualting for MyClass in ghci
10:51:11 <jle`> @let class MyClass a where myClass :: ()
10:51:12 <lambdabot>  .L.hs:172:9: error:
10:51:12 <lambdabot>      • Could not deduce (MyClass a0)
10:51:12 <lambdabot>        from the context: MyClass a
10:51:14 <jle`> oops
10:51:16 <jle`> @let class MyClass a where myClass :: a
10:51:17 <lambdabot>  Defined.
10:51:22 <jle`> @let instance MyClass () where myClass = ()
10:51:24 <lambdabot>  Defined.
10:51:25 <jle`> > myClass
10:51:27 <lambdabot>  ()
10:51:40 <jle`> @let class MyOtherClass a where myOtherClass :: a
10:51:41 <lambdabot>  Defined.
10:51:48 <jle`> @let instance MyOtherClass Double where myOtherClass = 3.14
10:51:49 <lambdabot>  Defined.
10:51:52 <jle`> > myOtherClass
10:51:54 <lambdabot>  3.14
10:52:04 <jle`> @let instance MyOtherClass Integer where myOtherClass = 10
10:52:05 <EvanR> without extensions?
10:52:05 <lambdabot>  Defined.
10:52:12 <dminuoso> jle`: That seems inconsistent.
10:52:18 <jle`> > myOtherClass
10:52:19 <lambdabot>  10
10:52:25 <jle`> this follows what I said before
10:52:35 <jle`> "first it tries (), then Integer, then Double, until it finds one that works"
10:52:39 <mjhoy> > 3.14
10:52:42 <lambdabot>  ()
10:52:46 <EvanR> without extensions, without specifying default rules?
10:52:49 <mjhoy> > undefined / undefined
10:52:51 <lambdabot>  ()
10:52:53 <dminuoso> jle`: Both the Haskell report and the manual state that defaulting should only trigger if a) under regular rules:  At least one of the classes Ci is numeric. (the classes with the ambiguous types in them)
10:53:01 <jle`> EvanR: yeah, like I just did it now in lambdabot
10:53:01 <dminuoso> and b) under extended defaulting rules:  At least one of the classes Ci is numeric, or is Show, Eq, or Ord.
10:53:17 <EvanR> jle`: well... lambdabot has all the extensions on
10:53:47 <jle`> yeah, it worked on my ghci with no extensions
10:53:53 <jle`> except for whatever is default
10:54:10 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4 https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extension-ExtendedDefaultRules
10:54:18 <anon136> Is there a better way to write both a functions definition and it's type on a single line than using a semi colon like this "add :: Int -> Int -> Int -> Int; add a b c = a + b + c"?
10:54:58 <geekosaur> anon136, no
10:55:00 <dminuoso> geekosaur: Ah I was looking at an outdated manual it seems!
10:55:11 <dminuoso> geekosaur: So it seems the rule C3 was abolished. :)]
10:55:11 <jle`> ah, okay
10:55:13 <anon136> geekosaur: thanks
10:55:16 <jle`> i turned on -XNoExtendedDefaultRules
10:55:19 <jle`> and it doesn't work
10:55:30 <EvanR> extensions by default
10:55:36 <EvanR> and chicks for free
10:55:59 <jle`> so ok, by default in ghc, you can expect "always try (), then Integer, then Double" to be true
10:56:14 <jle`> that explains the behavior for MyOtherClass
10:56:17 <dminuoso> jle`: Not always based on geekosaur's most recent link.
10:56:24 <EvanR> extended defaults extension is default
10:56:36 <dminuoso> jle`: The class needs to be "interactive" (the definition appears to be missing) at least,
10:56:40 <jle`> hm, oh!
10:56:46 <jle`> there is a hidden constraint
10:56:50 <jle`> how sneaky
10:56:54 <dminuoso> Actually.. then again..
10:56:54 <EvanR> what o_O
10:56:56 <geekosaur> interactive is defined elsewhere, under the ghci part
10:56:58 <dminuoso> The interactive classes (only relevant when ExtendedDefaultRules is in effect) are: any numeric class, Show, Eq, Ord, Foldable or Traversable.
10:57:00 <jle`> myOtherClass :: MyOtherClass a => a
10:57:04 <jle`> *but*, if i call it in ghci
10:57:12 <jle`> it gives a (Show a, MyOtherClass a) => a
10:57:13 <dminuoso> This again reads like MyOtherClass is _not_ interactive.
10:57:25 <dminuoso> Id say there is a bug. Either in defaulting or the manual.
10:57:28 <jle`> MyOtherClass is not interactive, but there is an extra constraint on Show, which *is* interactive
10:57:46 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#interactive-classes
10:57:56 <geekosaur> oh, right next to the one I pasted earlier
10:58:00 <jle`> > myOtherClass
10:58:02 <lambdabot>  10
10:58:03 <jle`> > even myOtherClass
10:58:05 <dminuoso> jle`: Where does the Show come from?
10:58:05 <lambdabot>  True
10:58:13 <geekosaur> ghci
10:58:20 <jle`> hm wait no that disproves it
10:58:23 <jle`> :t even
10:58:24 <dminuoso> geekosaur: ^- consider the most recent example using even
10:58:24 <lambdabot> Integral a => a -> Bool
10:58:25 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#using-a-custom-interactive-printing-function
10:58:34 <dminuoso> Oh hah again
10:58:38 <jle`> okay, 'even myOtherClass' working has thrown away that theory
10:58:43 <geekosaur> lambdabot also imputes one, since it wants to show the result
10:58:59 <jle`> since to type variable is constrained by Show in the case of 'even myOtherClass'
10:59:05 <jle`> s/to/no
10:59:09 * hackage safe-money 0.5 - Type-safe and lossless encoding and manipulation of money, fiat currencies,crypto currencies and precious metals.  http://hackage.haskell.org/package/safe-money-0.5 (RenzoCarbonara)
10:59:41 <jle`> something fishy is happening here
10:59:50 <dminuoso> :t even myOtherClass
10:59:51 <lambdabot> Bool
10:59:59 <geekosaur> "Keep only the groups in which at least one of the classes is an interactive class (defined below)."
11:00:04 <geekosaur> "at least one", not "all"
11:00:30 <jle`> geekosaur: that only applies to the type variables that we are trying to default
11:00:40 <dminuoso> @let v :: Bool; v = myOtherClass
11:00:42 <lambdabot>  .L.hs:187:5: error:
11:00:42 <lambdabot>      • No instance for (MyOtherClass Bool)
11:00:42 <lambdabot>          arising from a use of ‘myOtherClass’
11:00:51 <dminuoso> @let v = myOtherClass
11:00:53 <lambdabot>  Defined.
11:00:55 <dminuoso> :t v
11:00:56 <lambdabot> error:
11:00:56 <lambdabot>     Ambiguous occurrence ‘v’
11:00:56 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.v’,
11:01:02 * dminuoso sighs
11:01:06 <geekosaur> :t L.v
11:01:07 <lambdabot> MyOtherClass a => a
11:01:33 <jle`> right, so if you try to *show* that, then you have an interactive class constraining 'a'
11:01:44 <jle`> but if you take 'even' of that, you only have (Integral a, MyOtherClass a) => a
11:01:58 <marmistrz> Is it possible to get a colorful output in stack test without --file-watch?
11:02:00 <jle`> Show is not introduced on 'a'
11:02:06 <marmistrz> I'm currently using: stack test --file-watch --test-arguments "--color"
11:02:09 <dminuoso> jle`: but Integral, which is numeric
11:02:28 <jle`> oh yeah
11:03:09 <jle`> @let class ConsumeOtherClass b where consumeOtherClass :: MyOtherClass a => a -> ()
11:03:11 <lambdabot>  .L.hs:188:9: error:
11:03:11 <lambdabot>      • Could not deduce (ConsumeOtherClass b0)
11:03:11 <lambdabot>        from the context: (ConsumeOtherClass b, MyOtherClass a)
11:03:28 <jle`> oh that doesn't have to be a typeclass
11:03:38 <jle`> @let consumeOtherClass :: MyOtherClass a => a -> ()
11:03:39 <lambdabot>  .L.hs:187:1: error:
11:03:39 <lambdabot>      The type signature for ‘consumeOtherClass’
11:03:39 <lambdabot>        lacks an accompanying binding
11:03:42 <jle`> @let consumeOtherClass :: MyOtherClass a => a -> (); consumeOtherClass _ = ()
11:03:44 <lambdabot>  Defined.
11:03:49 <jle`> > consumeOtherClass myOtherClass
11:03:51 <lambdabot>  error:
11:03:51 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘consumeOtherClass’
11:03:51 <lambdabot>        prevents the constraint ‘(MyOtherClass a0)’ from being solved.
11:03:59 <jle`> okay everything makes sense now
11:04:28 <jle`> actually not sure if this makes sense, becuase Integral is what forced defaulting, but Integral is not an interactive typeclass
11:04:47 <dminuoso> jle`: it is an interactive typeclass by definition
11:04:49 <dminuoso> " any numeric class"
11:04:56 <jle`> oh i see
11:05:07 <jle`> i only saw the monospaced font list
11:05:12 <dminuoso> And numeric class is, as per Haskell 2010 report, any class that is Num or a subclass of Num.
11:05:13 <jle`> all is resolved :)
11:05:21 <jle`> my eyes went straight to the monospace
11:05:32 <dminuoso> Ah heh
11:05:46 <dminuoso> geekosaur: Thank you
11:05:49 <zincy> What does <# from the Miso library do? Anyone know?
11:08:23 <manjaroi3> for doing scp downloads in haskell, it would probably be better to use a lib like https://hackage.haskell.org/package/libssh2-0.2.0.6 rather than just generating the shell command and running it through a more known package I guess?
11:09:16 <manjaroi3> oh wait that libssh2 package seems fairly old, seems good i'll try it out
11:10:19 <dminuoso> zincy: https://github.com/dmjio/miso/blob/master/ghcjs-src/Miso/Effect.hs#L71-L73
11:14:00 <shapr> zincy: are you able to load it into ghci and get the type?
11:21:56 <napping> Is something like [x] the best way of getting an expression with a type of the form "proxy a" given a variable "x::a"
11:22:48 <dminuoso> :t Proxy
11:22:49 <lambdabot> forall k (t :: k). Proxy t
11:22:51 <dminuoso> napping: ^-
11:23:29 <dminuoso> > typeRep (Proxy :: Proxy (Maybe Int))
11:23:31 <lambdabot>  Maybe Int
11:24:21 <napping> dminuoso: How do I make a 'Proxy a' given a variable with type 'a'? Proxy implents applicative, but `pure` needs a type signature to not be ambiguous
11:25:14 <dminuoso> napping: (Proxy :: Proxy a), or if you have TypeApplications (Proxy @a)
11:26:34 <napping> I was hoping to avoid ScopedTypeVariables (or putting an explicit signature)
11:26:58 <napping> various other packages with proxy types define a 'toProxy :: a -> Proxy a'
11:27:56 <dminuoso> napping: Yeah you could write that too. I mean it's just toProxy _ = Proxy
11:28:09 * hackage ghcid 0.7 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.7 (NeilMitchell)
11:28:41 <napping> I guess it doesn't hurt to sprinkle copies of that around utility modules
11:28:55 <napping> It's not an orphan instance, after all
11:34:40 <zincy> Thanks guys
11:35:27 <zincy> Not sure I understand what the need for representing effects as a type in the Miso api is
11:36:05 <zincy> Is it for chaining actions and model updates?
11:46:46 <chorizo> Hey, I'm trying to use this, but I'm not exactly sure how to, I think I'm supposed to use 'withSSH2User', with (Session -> IO a) being input with the 'scpReceiveFile' function, but that is (Session -> FilePath -> FilePath -> IO Integer) so that doesn't work? Or can I do some crazy flip where I make it FilePath -> FilePath -> Session -> IO Integer and can curry it?
11:46:51 <chorizo> oh, https://hackage.haskell.org/package/libssh2-0.2.0.6/docs/src/Network-SSH-Client-LibSSH2.html#sessionInit
11:47:11 <JavaSucksMan> im trying to get stack setup to run in a strange environment, but it seems to to not be able to create or find stack.yaml
11:47:18 <JavaSucksMan> gorry details: http://lpaste.net/364975
11:47:56 <JavaSucksMan> is there a place where i can find a basic stack.yaml file?
11:48:50 <bergey> chorizo: I'd do something like withSSH2User (\session -> scpRecieveFile session file1 file2)
11:49:13 <bergey> That's usually how I call bracket-like functions like `withSSH2User`
11:49:23 <chorizo> bergey, ah. that makes a lot of sense, thanks!
11:49:57 <johnw> ocharles: hiya
11:59:40 <bergey> JavaSucksMan: That error looks to me like it's trying to get the list of stackage snapshots, from https://s3.amazonaws.com/haddock.stackage.org/snapshots.json
11:59:54 <JavaSucksMan> and it aint there
12:00:05 <bergey> The page is signed by Baltimore CyberTrust Root; I have no idea where the CA error is coming from.
12:01:23 <absence> is there something like the maybe function for lists?
12:01:30 <JavaSucksMan> i just downloaded the binary and ran it....   stack --version
12:01:31 <JavaSucksMan> Version 1.6.5, Git revision 24ab0d6ff07f28276e082c3ce74dfdeb1a2ca9e9 (5514 commits) x86_64 hpack-0.20.0
12:02:50 <JavaSucksMan> oops... im wrong.... the stackage snapshots ARE there
12:04:23 <JavaSucksMan> Im more noticing the whining about the CA on the last line
12:04:26 <bergey> Can you download the file with curl?  Maybe your "strange environment" doesn't have this CA registered?
12:05:01 <JavaSucksMan> the json came in fine with wget
12:05:33 <JavaSucksMan> mostly "strange environment" means "no root" ;-)
12:06:21 <bergey> [shrug] The CA was my only idea.
12:06:53 <JavaSucksMan> im new to stack.... first line says:
12:06:55 <JavaSucksMan> Writing implicit global project config file to: /chroot/home/greatmar/.stack/global-project/stack.yaml
12:07:03 <JavaSucksMan> but the file doesn't show up
12:07:40 <JavaSucksMan> I'm guessing the config somehow includes the CA path for whatever stack's equivalent of curl/wget is
12:08:21 <bergey> I think it's the other way around.  It gets the list of stackage snapshots, and picks one (probably the latest) to include in the global stack.yaml.
12:08:29 <JavaSucksMan> cat somebot just give me a vanilla .stack/global-project/stack.yaml and I can try to shove it in?
12:09:39 <bergey> https://gist.github.com/bergey/89e242902cadb3acdcec10ede44a77b9
12:11:16 <JavaSucksMan> bergey: thanks, but...
12:11:16 <JavaSucksMan>  (InternalException (HandshakeFailed (Error_Protocol ("certificate has unknown CA",True,UnknownCa))))
12:11:20 <JavaSucksMan> still
12:12:19 <bergey> This is usually the point where I start grepping the stack source, or searching github isssues .....
12:12:33 <JavaSucksMan> I'm going to give up... in two days I'll be back to my non-strange environment.  (and figure out why I can ssh back home)
12:13:39 <JavaSucksMan> then I can burnout my brain on understand type theory instead of burning out my brain on irritating security problems
12:16:44 <absence> @pl \x -> do { pure x }
12:16:45 <lambdabot> (line 1, column 10):
12:16:45 <lambdabot> unexpected '{'
12:16:45 <lambdabot> expecting variable, "(", operator or end of input
12:16:52 <bitemyapp> JavaSucksMan: Can you navigate to stackage.org on that computer?
12:17:00 <absence> is that a bug?
12:17:01 <bitemyapp> JavaSucksMan: seems reasonably common to me: https://www.google.com/search?q=(InternalException+(HandshakeFailed+(Error_Protocol+(%22certificate+has+unknown+CA%22%2CTrue%2CUnknownCa))))&oq=(InternalException+(HandshakeFailed+(Error_Protocol+(%22certificate+has+unknown+CA%22%2CTrue%2CUnknownCa))))&aqs=chrome..69i57.453j0j7&sourceid=chrome&ie=UTF-8
12:20:02 <geekosaur> absence, no
12:20:13 <geekosaur> @. pl undo \x -> do { pure x }
12:20:13 <lambdabot> pure
12:20:44 <JavaSucksMan> bitemyapp: yes.. with a cert warning
12:23:38 <absence> geekosaur: nice, is there a plugin to handle case x of { ... } as well?
12:24:08 <geekosaur> no
12:24:09 <geekosaur> what gegneric mechanism do you think handles that in a point-free fashion?
12:25:39 <absence> geekosaur: would have to be special cases rather than generic, but maybe that's not supported since you ask
12:26:00 <absence> geekosaur: e.g. convert pattern matching on Maybe to use of the maybe function
12:26:15 <geekosaur> there are a very few things it knows about. it doesn't know how to do it for general types
12:26:54 <Tuplanolla> Consider `@plens`...
12:27:09 <bitemyapp> JavaSucksMan: what's the warning?
12:27:26 <bitemyapp> the *.fpcomplete.com cert is clean for me.
12:27:39 <absence> geekosaur: a few things it knows about for case statements? because i just get errors when i use curly braces
12:27:40 <bitemyapp> Issued on March 27th, 2018
12:28:05 <geekosaur> a few things it knows about in general. it doesn;t handle case at all
12:28:27 <absence> ah, got it
12:29:59 <iqubic> Haskell only uses curly braces for records, right?
12:31:14 <geekosaur> iqubic, and when you can't use layout, as when giving lambdabot or ghci one-liners
12:32:06 <iqubic> Oh you can do {line 1; line 2; line 3}?
12:32:37 <geekosaur> yes
12:32:59 <geekosaur> but note that let uses layout as well, so you need an extra set of braces in do { line1; let {x = ...}; line2}
12:33:18 <Tuplanolla> If you peek inside GHC, you'll find a lot of that, iqubic.
12:34:45 <chorizo> Tuplanolla, is there a reason for it?
12:34:59 <geekosaur> SPJ doesn't like layout for some reason
12:35:41 <chessandgo> is yesod the best bet for using websockets, even if the program isnt (or isnt much) of a webapp
12:36:31 <geekosaur> as coding style peculiarities go, it's not as bad as peole who name all types T and all classes ZC and require fully qualified names (which badly messes up haddock documentation...)
12:38:28 <lyxia> are there more that one person doing this
12:38:54 <iqubic> Can someone check my understanding of Fix here?
12:39:07 <geekosaur> I'd expect everyone sticks to the prevailing style, which is SPJ's
12:39:19 <iqubic> Data RoseTree a = Tree a [RoseTree a]
12:39:27 <geekosaur> if I'm contributing to a codebase, I use the style I find already there, not my usual one
12:39:39 <iqubic> Data RoseTreeF a r = Tree a [r]
12:39:55 <geekosaur> because it's @#$^%* annoying to everyone if the style changes every few lines
12:39:57 <iqubic> Data RoseTree = Fix RoseTreeF
12:40:07 <iqubic> is that correct?
12:40:28 <lyxia> iqubic: yes
12:40:38 <lyxia> oh wait
12:40:44 <lyxia> Fix (RoseTreeF a)
12:40:55 <iqubic> Yeah, I thought it'd be like that.
12:41:11 <iqubic> And then I can use that in cata and ana and such?
12:41:29 <Tuplanolla> Are you using `recursion-schemes`, iqubic?
12:42:00 <iqubic> I'm learning about them. I'm not sure I see how using cata and ana is better than fold and unfold.
12:42:10 <iqubic> *foldr and unfoldr.
12:42:29 <Tuplanolla> There's a TH module for doing that conversion.
12:43:16 <iqubic> And the Fix data type is not something I see a use for beyond being a generic recursive data type for use with cata and ana.
12:46:13 <iqubic> What's this about a TH module I hear?
12:47:09 <jle`> cata and ana *are* foldr and unfoldr
12:47:19 <jle`> except they work for your trees too, not just lists
12:47:38 <jle`> imagine making a new data type and having to re-define foldr and unfoldr from scratch every time
12:47:44 <jle`> instead of just using a generic one that already works
12:47:48 <jle`> what kind of world would that be
12:47:56 <iqubic> How does foldr differ from traverse?
12:48:07 <jle`> look at the types
12:48:11 <iqubic> :t foldr
12:48:12 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:48:17 <iqubic> :t traverse
12:48:18 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:48:27 <jle`> your question should really be how are foldr and traverse similar
12:48:41 <iqubic> Yes. That is what I want to know.
12:48:42 <jle`> because from their types alone they seem to be completely different
12:48:52 <EvanR> how are they similar, good question
12:49:04 <ddellacosta> can't you derive Foldable and get those "for free" jle` ?
12:49:08 * EvanR waits for iqubic to answer
12:49:14 <jle`> ddellacosta: not unfoldr
12:49:23 <iqubic> EvanR: I don't know how they are similar.
12:49:24 <ddellacosta> jle`: right, gotcha
12:49:27 <EvanR> me neither
12:49:29 <jle`> and also we're talking about a slightly different version of foldr than the one from Foldable
12:49:41 <EvanR> more like, are they?
12:49:47 <iqubic> we are? What foldr are we talking about?
12:49:58 <jle`> one that isn't 'sequential', but rather collapses constructors recursively
12:50:13 <jle`> the foldr Foldable that is generic for all Foldable's is basically a foldr . toList
12:50:22 <jle`> it's a foldr over the list of all items inside the Foldable
12:50:43 <jle`> whereas cata is a way to recursively collapse all constructors in a value
12:50:51 <jle`> so it respects the 'tree' structure
12:50:51 <iqubic> Right. I see.
12:50:58 <jle`> foldr is just traverse where f ~ State b
12:51:14 <jle`> or rather, traverse_
12:51:32 <jle`> actually hm that's more foldl
12:51:34 <jle`> nvm
12:51:39 * hackage fake 0.1.1 - Randomly generated fake data  http://hackage.haskell.org/package/fake-0.1.1 (DougBeardsley)
12:51:41 <iqubic> Now you have lost me. When did State enter the picture?
12:51:42 <jle`> fake
12:51:54 <iqubic> How are foldr and foldl different?
12:52:00 <jle`> one of the common tricks with Traversable is, if you pick a different 'f', you get different functions completely
12:52:01 <jle`> :t traverse
12:52:03 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:52:05 <EvanR> how does it guarantee the data is fake
12:52:16 <jle`> and you can implement a lot of other library functions or common functions on data types by cleverly picking 'f'
12:52:23 <jle`> the Applicative
12:52:51 <jle`> foldl, in specific, is what you get when you pick f ~ State b (with traverse_)
12:53:04 <iqubic> :t traverse_
12:53:06 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
12:53:25 <jle`> and foldMap is what you get when you pick f ~ Const m
12:53:31 <jle`> and fmap is what you get when you pick f ~ Identity
12:53:48 <iqubic> (a -> State b b) -> t a -> State b () is foldl?
12:54:01 <jle`> yes
12:54:21 <jle`> remember that State s a is (s -> (a, s))
12:54:27 <iqubic> Yes, I get that.
12:54:43 <jle`> hm actually it's more (a -> State b ()) -> t a -> State b ()
12:54:50 <jle`> :t foldl
12:54:51 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
12:54:57 <chorizo> I'm getting some cut off exception from running this ssh lib, '*** Exception: FILE', any idea what could be happening?
12:54:57 <iqubic> I see.
12:55:01 <jle`> and also remember ((),b) is b
12:55:07 <iqubic> Yes. I know.
12:55:17 <iqubic> :t traverse_
12:55:18 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
12:55:25 <iqubic> :t traverse
12:55:27 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:55:41 <jle`> traverse with State is actually closer to mapAccumL
12:55:59 <jle`> but foldl is a 'simplified' version of mapAccumL
12:56:24 <iqubic> (a -> Identity b) -> t a -> Identity (t b) is fmap.
12:56:35 <iqubic> That's cool. It totally is.
12:56:36 <jle`> but yeah, essentially foldl is what happens when you do 'traverse_' with State b as your Applicative
12:56:45 <jle`> iqubic: mhm, check out foldMap too
12:56:47 <Cale> iqubic: http://cale.hn.org/share/Folds.svg might help with understanding the way that foldr and foldl are different
12:56:55 <jle`> :t foldMap
12:56:56 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
12:57:06 <Cale> (but doesn't say much about traverse)
12:57:15 <jle`> (a -> Const m b) -> t a -> Const m (t b)
12:57:22 <jle`> since Const m a is just 'm'
12:57:26 <jle`> that's (a -> m) -> t a -> m
12:57:42 <iqubic> Which isn't quite fmap.
12:57:46 <iqubic> :t fmap
12:57:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:58:08 <iqubic> as the end result is of kind * instead of * -> *
12:58:18 <iqubic> f b is not m
12:59:55 <iqubic> Why do foldr1 and foldl1 exist?
13:00:26 <iqubic> :t scanr
13:00:27 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
13:00:33 <Cale> Because sometimes you don't have a suitable initial element
13:00:39 <iqubic> What the heck does that thing do?
13:00:39 <Cale> For example, with maximum or minimum
13:00:58 <Cale> It computes the right folds of each of the tails of the list
13:01:59 <iqubic> Alright so can I see an example of this being applied?
13:02:22 <iqubic> Of scanl or scanr.
13:02:44 <EvanR> your reverting to a previous state, where you ask a multitude of questions that you can answer easily for yourself in ghci
13:03:04 <Cale> scanl tends to be the more useful one
13:03:05 <iqubic> EvanR: Sorry.
13:03:12 <Cale> > scanl (+) 0 [1..10]
13:03:14 <lambdabot>  [(),()]
13:03:20 <EvanR> ROFL
13:03:21 <Cale> ... what
13:03:21 <iqubic> Err.
13:03:25 <Cale> @undefine
13:03:25 <lambdabot> Undefined.
13:03:26 <Cale> > scanl (+) 0 [1..10]
13:03:28 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
13:03:34 <chorizo> very interesting
13:03:38 <Cale> okay, someone was screwing around with definitions :)
13:03:50 <EvanR> + is a bit difficult to see...
13:03:51 <geekosaur> yes, someone was playing with defaulting
13:04:02 <geekosaur> and created a Num instance for () just to mess with everyone
13:04:03 <iqubic> > scanr (+) 0 [1..10]
13:04:05 <lambdabot>  [55,54,52,49,45,40,34,27,19,10,0]
13:04:14 <iqubic> What the heck is that?
13:04:18 <lyxia> > scanl (+) a [b,c,d]
13:04:20 <lambdabot>  [a,a + b,a + b + c,a + b + c + d]
13:04:26 <EvanR> > scanl (:) [] [1,2,3,4]
13:04:28 <lambdabot>  error:
13:04:28 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
13:04:28 <lambdabot>        Expected type: [a] -> [a] -> [a]
13:04:44 <Cale> That's [1+...+10+0, 2+...+10+0, 3+...+10+0, ..., 10, 10+0]
13:04:51 <iqubic> I see.
13:04:54 <Cale> oops
13:05:02 <Cale> That's [1+...+10+0, 2+...+10+0, 3+...+10+0, ..., 10+0, 0]
13:05:05 <EvanR> we just need a different example for scanl than +
13:05:25 <Cale> Well, it might be clearer if we chose a different list of inputs
13:05:25 <EvanR> because its commutative
13:05:30 <iqubic> Why is it that "scanl . reverse = scanr"? Is it just the examples we are picking?
13:05:35 <Cale> > scanl (+) 0 [1,20,300,4000]
13:05:37 <lambdabot>  [0,1,21,321,4321]
13:05:42 <Cale> > scanr (+) 0 [1,20,300,4000]
13:05:44 <lambdabot>  [4321,4320,4300,4000,0]
13:06:02 <iqubic> Now why are those different?
13:06:10 <EvanR> > scanl (+) 0 (reverse [1,20,300,4000])
13:06:11 <lambdabot>  [0,4000,4300,4320,4321]
13:06:27 <Cale> scanl gives you the foldl of each of the initial segments of the list
13:06:38 <Cale> scanr gives you the foldr of each of the tails of the list
13:07:00 <Cale> @src scanl
13:07:00 <lambdabot> scanl f q ls = q : case ls of
13:07:00 <lambdabot>     []   -> []
13:07:00 <lambdabot>     x:xs -> scanl f (f q x) xs
13:07:05 <Cale> @src scanr
13:07:05 <lambdabot> scanr _ q0 []     = [q0]
13:07:05 <lambdabot> scanr f q0 (x:xs) = f x q : qs
13:07:05 <lambdabot>     where qs@(q:_) = scanr f q0 xs
13:07:12 <EvanR> > scanl (flip (:)) [] [1,2,3,4]
13:07:14 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1]]
13:07:30 <Cale> > scanr (:) [] [1..4]
13:07:30 <iqubic> :t mapAccumr
13:07:31 <lambdabot> error:
13:07:31 <lambdabot>     • Variable not in scope: mapAccumr
13:07:31 <lambdabot>     • Perhaps you meant one of these:
13:07:32 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
13:07:43 <iqubic> :t mapAccumR
13:07:44 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
13:07:48 <Tuplanolla> That autocorrection was pretty good.
13:07:59 <iqubic> Alright, what the heck does that do?
13:08:18 <EvanR> what the hask
13:08:18 <iqubic> :t foldr
13:08:20 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:08:40 <iqubic> mapAccumR confuses the heck out of me.
13:08:44 <chorizo> is there a way to show the current throughput on the network device that a program is using? (in haskell)
13:09:17 <Cale> mapAccumR is kind of like mapping a stateful function over the list
13:09:29 <iqubic> yeah, it really is.
13:09:37 <Cale> So in that type signature, a is like your "state" type
13:09:51 <Cale> the list is of values of type b
13:09:52 <iqubic> traverse_ with State b as applicative is close to mapAccumL
13:09:58 <Cale> and the resulting list has values of type c
13:10:28 <Cale> so the function you give it takes the "current state", and an element of the list, and produces a "new state" as well as the replacement for that element
13:10:37 <iqubic> I see how that works.
13:11:53 <shapr> Is there a utility to reformat indented Haskell source to brace-using code?
13:12:08 <iqubic> no. Haskell doesn't use braces.
13:12:15 <EvanR> bzzt
13:12:16 <Cale> iqubic: yes it does
13:12:27 <EvanR> iqubic -$400
13:12:32 <iqubic> Well yeah, but not oftet
13:12:39 <iqubic> *often
13:12:47 <Cale> shapr: I believe ghc might come with one... but I'll have to look :)
13:13:08 <cocreature> I vaguely recall there being an open issue for that
13:13:38 <EvanR> i love how haskell braces can confound unreasonable anti-haskell arguments about hating indentation
13:13:52 <EvanR> among other ways haskell can confound unreasonable arguments
13:13:55 <shapr> EvanR: yeah, but that only works if I can automatically convert from one to the other, right?
13:14:02 <EvanR> haha
13:14:16 <iqubic> Haskell braces are not that useful. When are braces used in production cod?
13:14:19 <shapr> I have a friend who would like to learn Haskell, but finds indentation .. disorienting.
13:14:21 <aarvar> EvanR: idk, unreasonable arguments seem to work pretty well
13:14:26 <EvanR> lol
13:14:43 <Cale> oh, I was thinking of the tool which undoes literate Haskell perhaps.
13:14:44 <EvanR> not saying they dont work
13:14:51 <shapr> If there's a tool to convert back and forth, I'd like to try it.
13:15:03 <Cale> I think *someone* has written something at some point.
13:15:25 <cocreature> the tool that converts to braces is called “spj”
13:15:30 <shapr> :-P
13:15:48 <Cale> I remember there was a blind user who wanted to use Haskell and needed such a tool.
13:16:21 <shapr> delYsid` perhaps?
13:16:22 <johnw> Cale: delYsid perhaps?
13:16:24 <johnw> haha
13:16:33 <shapr> :-)
13:17:36 <iqubic> not delYsid`
13:17:44 <iqubic> At least I don't think.
13:17:54 <iqubic> https://delysid.org/index.html
13:18:46 <shapr> delYsid`: how you doin?
13:20:03 <shapr> I wonder if HaRe can refactor brace-using code?
13:20:45 <infandum>  /exit
13:23:37 <marmistrz> Is it possible to get a colorful output in stack test without --file-watch?
13:23:50 <marmistrz> I'm currently using: stack test --file-watch --test-arguments "--color", but this doesn't exit when the tests finish
13:24:04 <marmistrz> OTOH without --file-watch I get no colors in the terminal
13:25:39 * hackage streamdeck 0.0.1 - Control library for the Elgato Stream Deck  http://hackage.haskell.org/package/streamdeck-0.0.1 (wuest)
13:25:52 <Akii> I'm so confused: http://lpaste.net/364979
13:25:54 <Akii> locally it builds
13:28:12 <EvanR> turtle tutorial says "String is deprecated in favor of Text in modern Haskell code"
13:28:26 <EvanR> ill have to digest this idea
13:29:34 <Akii> xD
13:29:48 <EvanR> "faq: some libraries still use String, what do i do"
13:30:03 <EvanR> like, the entire stdlib
13:30:16 <EvanR> i feel like im reading fan fiction about haskell
13:30:23 <hc> why?
13:30:33 <EvanR> is there a real movement to use Text everywhere?
13:30:43 <hc> Doesn't it make sense?
13:31:06 <geekosaur> if strings are short enough or you're doing things thta fusse well, String is still a win
13:31:16 <geekosaur> and it's still more convenient for quick and dirty stuff
13:31:23 <geekosaur> *that fuse well
13:31:29 <hc> please define "short enough"; what are the advantages in these cases?
13:31:50 <EvanR> its a lot of revolution to go through without also going in and renaming Text to String
13:31:57 <Cale> fwiw, we use Text for pretty close to everything where I work
13:32:09 <hc> same here
13:32:14 <EvanR> and doing something so we get the same conveniences of String by default
13:32:19 <Cale> Text also has better semantics in several cases
13:33:07 <Akii> wat so if Stack doesn't have the dependency I need Nix won't build it? And if so, why does it build locally
13:33:16 <EvanR> the Text library is great, but you have to go through a song and dance before you can use it
13:33:45 <EvanR> if were writing fan fiction ill want that in my chapter
13:33:59 <EvanR> er, that you can just use it without a song and dance
13:34:54 <EvanR> its like, elixir has two "list" types, one from erlang and a new one everyone likes more
13:35:03 <EvanR> and you have to do conversions
13:35:06 <hc> I agree it'd be nice to have "Text" by default
13:35:22 <davean> EvanR: yes, any it seems everyone has agreed to just drop String and use Text universally in my experience - which is great
13:35:27 <EvanR> this kind of thing adds exponential slowdown to my brain
13:35:41 <davean> EvanR: so forget String exists - it doesn't show up anywhere any mroe
13:35:47 <hc> Haskell is still evolving a lot.... probably part of the reason things like that exist
13:35:49 <shapr> Yeah, Text only
13:35:50 <EvanR> o_O
13:36:15 <davean> When was the last time you saw a String you didn't specify yourself?
13:36:21 <hc> davean: well... some i/o functions like... Data.Text.IO(!).readFile still use it
13:36:45 <hc> So you need to specify the path to a file as a *string* and are returned an IO Text
13:36:46 <davean> hc: mmm, and are sorta incorrect for it
13:36:59 <hc> what to use instead?
13:37:00 <davean> hc: So if you want to actually support the files that exist, you have to avoid them anyway
13:37:09 <davean> hc: theres Unix stuff if you're on unix
13:37:28 <davean> String fails hard for filenames :/
13:37:33 <hc> yeah...
13:37:40 <hc> still seems to be the normm, though
13:37:44 <EvanR> Text only, everyone is on board, so all code from now on will be somewhat bloated by doing conversions from String where it appears. in 2099 when String is replaced with Text, now all code must be rewritten
13:37:56 <davean> mmm, Well, to get anything done I had to deal with String not being correct for filenames a LONG time ago
13:38:02 <EvanR> (Text is also fail for filenames)
13:38:13 <davean> Yes
13:38:17 <EvanR> abstract filepath proposal, but thats another story
13:38:21 <davean> The correct type for filenames is Bytestring
13:38:31 <EvanR> :(
13:38:39 <hc> I wonder why filenames were ever made Strings
13:38:52 <hc> I mean, this means a lot more conversion overhead at the FFI level
13:38:52 <davean> hc: I have no fucking clue who made that amazingly braindead decision :/
13:38:56 <geekosaur> convenience. and ByteString is relatively young
13:39:17 <davean> hc: Its probably the biggest "WTF" in Haskell I've encountered
13:39:25 <davean> hc: it doesn't even make the beginnings of conceptual sense
13:39:26 <pertl> I try to run "stack setup" on OS X and get caught by a bug with gcc + CUDA (https://github.com/commercialhaskell/stack/issues/3741) does anybody know a workaround to?
13:39:36 <EvanR> luckily its a wtf you dont have to deal with at the very beginning of learning haskell
13:39:50 <EvanR> which it would be if you made it abstract or similar
13:39:50 <davean> EvanR: I encoutnered it in my first few weeks
13:39:58 * hc learnt haskell long after the monads and bytestrings were invented
13:40:12 <davean> https://hackage.haskell.org/package/posix-paths
13:40:39 * EvanR writes a new programming language and leaves all yall in the dust
13:40:55 <hc> EvanR: will it be a dsl for haskell? =)
13:41:05 <EvanR> coffeehaskell
13:41:07 <EvanR> totally different
13:41:08 <hc> heh
13:41:53 <EvanR> it will be vaguely ruby syntax, and just use CPP to convert to haskell. and be the next killer app
13:42:03 <hc> will it use String or Text?
13:42:06 <EvanR> and Text will be called String
13:42:14 <aarvar> EvanR: covfefe haskell
13:43:22 <EvanR> actually the other demon on my shoulder says that its strictly better to not have primitive string, and have a choice between string libraries
13:43:38 <EvanR> unfortunately everything defacto uses strings as currency in programming and you need them to all be the same :(
13:44:23 <geekosaur> pertl, I'd suspect that Apple's gcc wrapper is outputting multiple version numbers. you might be able to put a wrapper script in $PATH, but no guarantee stack will use it while installing ghc
13:44:24 <JavaSucksMan> once you hit the OS, it's all octet arrays ;-)
13:45:08 <EvanR> 7 bit bytes though
13:45:18 <EvanR> you have to admit
13:46:30 <JavaSucksMan> when was the last time you actually saw a seven bit byte?
13:47:06 <davean> JavaSucksMan: This morning I think?
13:47:25 <EvanR> idris has them
13:47:52 <EvanR> family of binary words indexed by number of bits
13:47:54 <davean> JavaSucksMan: the better question is when I last saw 9 bit bytes
13:48:41 <JavaSucksMan> In ancient history I worked on the Intellivison... had a ten-bit opcode space.
13:48:50 <JavaSucksMan> we called them decls
13:49:04 <JavaSucksMan> (the five-bit units were nicls)
13:49:12 <EvanR> rofl
13:49:28 <JavaSucksMan> OK... where did you see a nine-bit byte?
13:50:04 <JavaSucksMan> as long as i got you laughing... I made a major rite of passage for a Haskell programmer.
13:50:11 <JavaSucksMan> http://alumnus.caltech.edu/~mklein/warez/unsafePerformMeow.png
13:51:18 <[exa]> 9bit bytes are in all your tiny CPUs handling your overflows
13:52:17 <JavaSucksMan> if it's not addressable, it don't count  (I'm feeling ornery)
13:55:25 <geekosaur> DECsystem 10 and 20
13:56:13 <[exa]> hm, is there any descendant of KansasLava? or should I just use that one for designing vhdl?
13:56:14 <geekosaur> 36 bit words, sub-addressible in 3-bit chunks so 6- and 9-bit subregisters were common. the 9-bit form was commonly used when interchanging data with systems with 8-bit bytes
13:57:05 <EvanR> i heard the babylonians had 60-bit
13:57:46 <JavaSucksMan> come on guys... I worked hard on this...
13:57:47 <JavaSucksMan> http://alumnus.caltech.edu/~mklein/warez/tuple-cat.png
13:57:56 <EvanR> to avoid, among other things, the year 0000 problem
14:01:01 <oak-> [exa]: http://www.clash-lang.org/
14:01:33 <oak-> I have no experience using it though, only read some white papers out of curiosity
14:02:39 * hackage paths 0.2.0.0 - Library for representing and manipulating type-safe file paths  http://hackage.haskell.org/package/paths-0.2.0.0 (HerbertValerioRiedel)
14:03:09 <[exa]> oak-: oh nice, thank you very much!
14:22:09 <danilo2> Hi guys! Is there any way to silent warnings that a top level function doesnt have a type signature IF AND ONLY IF that top level function was generated from TH splice?
14:31:36 <dpyro> what's the haskell way to do an associated type? example in another lang I would have something like `interface Foo { type ResultType; methods... }`
14:32:58 <pavonia> There are associated data types for type classes
14:37:57 <dpyro> it doesn't seem like i can associate a type without having to use a typevar
14:38:29 <dpyro> i would like having data X = ..., X specifies one and only one type
14:38:50 <dpyro> so data RequestX = ... contains a data ResponseX type
14:39:00 <[exa]> dpyro: you can do that using multiparameter typeclasses (and functional dependencies)
14:39:21 <[exa]> they can be viewed as relations on types
14:39:35 <glguy> dpyro: There's no namespacing, if you want to define two types you'd just do that at the top level
14:39:54 <glguy> data ResponseX = ...; data RequestX = ...{using ResponseX}...
14:40:28 <johnw> is it possible, given an IORef a, to somehow determine the "unique address" of that IORef? I want to do this for debugging output, to make it easier to find out where a cyclic reference begins
14:40:29 <dpyro> [exa]: i have that so far but i'm not sure how to define the thing for ResponseX within RequestX
14:40:46 <[exa]> dpyro: why'd you want to define it in requestX?
14:40:57 <dpyro> if i define RequestX at the toplevel, it takes the inner declaration not as a link but as a new declaration
14:41:12 <dpyro> i don't necessarily, i just want to associate the type without a free typevar
14:41:39 <dpyro> i.e. RequestX is only associated with ResponseX and that never changes
14:42:43 <[exa]> do you have any example of how you would like to use that?
14:43:22 <[exa]> I don't quite get the thing with the free typevar tbh
14:44:58 <dpyro> i mean it seems like i have to do class Request a b | a → b
14:45:09 <dpyro> and then instance RequestX ResponseX where
14:45:18 <[exa]> dpyro: anyway, single-line instance HasResponse RequestX ResponseX would probably do that for you right?
14:45:45 <geekosaur> johnw, not easily
14:45:56 <geekosaur> an IORef wraps an STRef wraps a MutVar#
14:45:57 <dpyro> can i do that without a where?
14:47:52 <[exa]> dpyro: afaik yes, empty instance for an empty class
14:48:02 <[exa]> maybe it will require some extensions enabled
14:48:50 <[exa]> (anyway, if you didn't read the related "Typing the technical interview" yet, do it now :] )
14:49:17 <fishythefish> (and then reimplement it with type families)
14:49:37 <dpyro> i can't learn haskell with theory first
14:49:41 <dpyro> i need examples
14:49:50 <dpyro> i never understood monads with just theory
14:50:08 <fishythefish> dpyro: pretty sure you're in the majority
14:50:52 <dpyro> well i remember reading LYAH and it kept going on about how special and cool monads were while trying to lay down some big foundation for it
14:51:09 <dpyro> and it really made it more confusing, didn't touch haskell again for years
14:51:41 <[exa]> yes, that article is full of examples
14:52:16 <dpyro> https://aphyr.com/posts/342-typing-the-technical-interview ?
14:52:49 <[exa]> yes
14:52:53 <chorizo> dpyro, yeah just reading about monads is hard
14:53:07 <chorizo> still not got it
14:54:33 <dpyro> i'm just using them without thinking about them, hah
14:54:42 <dpyro> at some point a light will flick and i will GET IT
14:54:46 <dpyro> and then i can read all the theory
14:54:58 <dpyro> but until my brain has figured out why, it does not care about how
14:55:33 <nkaretnikov> chorizo: it’s just an interface — a way to overload useful operations. Plus laws.
14:55:55 <fishythefish> chorizo: multiple people have told me they found http://mightybyte.github.io/monad-challenges/ useful
14:56:02 <chorizo> nkaretnikov, haha yeah, I think I actually do understand it, it's just actually using it is difficult
14:56:26 <jle`> chorizo: the main thing that helped for me was to stop thinking about it as using monads and just start using normal types
14:56:31 <chorizo> building an scp downloading tool for myself, pretty fun monads
14:56:51 <jle`> if you're building an scp downloading tool, chances are you aren't actually "using monads"
14:56:53 <jle`> but rather, using IO
14:56:54 <jle`> and similar types
14:57:23 <jle`> or different types
14:57:29 <chorizo> yeah but IO is monadic right?
14:57:32 <fishythefish> "using monads" doesn't intrinsically make your code better or idiomatic or special
14:57:49 <jle`> chorizo: i wouldn't really say so
14:58:05 <fishythefish> monads are just a way to answer the question "where do I find a function f a -> (a -> f b) -> f b"
14:58:06 <jle`> chorizo: lists are monads, but using them doesn't really involve doing anything monadie
14:58:18 <jle`> have you ever used a list in Haskell?
14:58:25 <jle`> lists are just types with normal functions as their interface
14:58:29 <nkaretnikov> chorizo: play around in ghci with >>=, >>, and return using different types. Partially apply stuff and use :t to see if it still makes sense. Look at how list and maybe instances are implemented.
14:58:35 <jle`> they also happen to have a Monad instance, but that's only incidental
14:58:48 <jle`> if you want to learn how to use lsits, would you read a monad tutorial?
14:58:49 <fishythefish> chorizo: IO is an instance of Monad, but it would work just fine even if the Monad typeclass didn't exist
14:58:53 <jle`> would you "learn monads" to learn how to use lists?
14:59:06 <fishythefish> monadic functions just give us a useful framework for manipulating IO values since they happen to be an instance of Monad
14:59:07 <jle`> do you think pattern matching, using ++, etc. on lists is "using monads"?
14:59:08 <chorizo> hah, I've been through a fair amount of stuff, I think I mostly get it
14:59:24 <jle`> if you're working with IO, chances are you aren't really doing anything with monads at all
14:59:25 <chorizo> it's just hard because even if i think I understand it, I haven't really used it enough to know how to use it
14:59:28 <jle`> you're just using IO as a normal type
14:59:55 <jle`> chorizo: yeah, my point was to not confuse learning how to use IO with learning how to "use monads"
15:00:07 <jle`> IO is a specific type with a very rich interface/API
15:00:18 <jle`> and most of it has nothing to do with monads
15:00:22 <chorizo> jle`, ah, that makes sense. I guess after this I'll build a game or something and use State or something
15:00:37 <chorizo> I don't really know many beyond state, writer and reader
15:00:40 <jle`> yeah, the skills you need to know to work with IO aren't "monad skills"
15:00:42 <chorizo> and I don't really know what they do.
15:00:43 <jle`> they are IO skills
15:00:47 <jle`> chorizo: and, that's okay
15:00:55 <jle`> there's no point really in learning monads for the sake of learning monads
15:01:00 <jle`> at least at first
15:01:35 <jle`> chorizo: if you want to write a useful IO program, learn how to use IO
15:01:39 <chorizo> jle`, ah cool. what are the kinds of projects that benefit the most from monads? just everything?
15:01:41 <jle`> not learn how to use monads
15:01:51 <jle`> chorizo: i mean, almost all Haskell programs use lists, right?
15:01:56 <chorizo> I mean this is going to be a ton of parsing, loops
15:02:23 <jle`> chorizo: parsing, loops, stuff like that, are things that are made possible by types that provide them
15:02:31 <jle`> not "because monad"
15:02:32 <chorizo> yeah I mean I know that do x <- [1..10] is monadic and uses the monad instance of list
15:02:34 <chorizo> (i think)
15:02:54 <jle`> the usefulness you are ascribing to monads are actually the usefulness from those specific types
15:03:00 <jle`> those types are all useful for doing useful things
15:03:15 <pdxleif> @hoogle Read a => FilePath -> IO a
15:03:15 <lambdabot> Prelude readIO :: Read a => String -> IO a
15:03:16 <lambdabot> System.IO readIO :: Read a => String -> IO a
15:03:16 <lambdabot> NumericPrelude.Base readIO :: Read a => String -> IO a
15:03:20 <chorizo> jle`, sorry, what do you mean 'those types are all useful for doing useful things'
15:03:22 <jle`> the fact that they have monad instances aren't the thing that make sthem useful
15:03:29 <jle`> chorizo: for example, the State type is useful for keeping track of state
15:03:37 <chorizo> right
15:03:38 <jle`> but that comes from the actual type itself
15:03:41 <jle`> not from the fact that it's a Monad
15:03:47 <jle`> being a Monad doesn't give it state abilities
15:03:57 <chorizo> that is something I was thinking...
15:04:02 <fishythefish> and importantly, all the things you can do with the Monad instance, you could do without it
15:04:10 <chorizo> what makes it special then? I've heard great things about monads and how powerful and useful they are
15:04:19 <jle`> chorizo: State is a useful type
15:04:20 <chorizo> or is that a 'you will find out later young paddawan'
15:04:22 <jle`> because it is useful
15:04:25 <jle`> *not* because it's a Monad
15:04:26 <Tuplanolla> It's the hype system, not the type system, chorizo.
15:04:38 <chorizo> haha
15:04:44 <jle`> chorizo: that's like saying "i hear that tools are powerful.  what makes tools useful?"
15:04:55 <jle`> a hammer isn't useful "because it's a tool"
15:05:00 <jle`> it's useful because...well, of what it specifically is
15:05:06 <jle`> its shape, its composition, etc.
15:05:07 <chorizo> am I wrong in saying that a key part of monads is their composability?
15:05:09 <chorizo> or am i way off
15:05:45 <jle`> depends on what you mean by composability
15:05:53 <jle`> even if you aren't off, it might not be a useful way of looking at things
15:06:07 <jle`> chorizo: when people say "monads are powerful", they don't mean that the fact that somethingis a monad makes it powerful
15:06:17 <jle`> or well, sometimes they do
15:06:37 <jle`> chorizo: but State, IO, List, Reader, etc. are all useful types
15:06:41 <jle`> not because they are monads
15:06:48 <jle`> but because the types themselves are useful for doing useful things
15:06:56 <chorizo> yeah I understand what you're saying
15:06:57 <fishythefish> monads are powerful only because so many powerful types happen to be monads
15:07:05 <chorizo> remove their instance of monad and they would still be useful
15:07:19 <chorizo> but monad is so generic and applies to so many areas that it is 'powerful'
15:07:35 <jle`> there are two different things going on here, and it's a bit subtle
15:07:45 <jle`> on one hand, the specific monad itself could be a powerful tool
15:07:58 <jle`> on the other hand, the *concept* of unifying them all under a monadic interface is also a powerful tool
15:08:31 <jle`> because it enables code re-use, and equational reasoning
15:08:55 <chorizo> right, but I've also heard that monads can be said to be their own 'model of computation'
15:09:07 <chorizo> that's some hype statement right there
15:09:19 <jle`> sure maybe, but i don't think that's a particularly useful statement
15:09:31 <fishythefish> moreover, you can define methods that are implemented in terms of the monadic interface rather than the details of a particular type
15:09:34 <chorizo> yeah neither, what you've said pretty much sums up what I wasn't understanding
15:09:48 <fishythefish> so you can leverage polymorphism to implement useful functions that work for a variety of types
15:10:30 <jle`> but yeah, day-to-day, you don't really "use monads" in the sense that they are monads, you use specific types with their specific functionality, which has nothing to do with their monadness
15:10:49 <chorizo> fishythefish, yeah that makes sense, so I guess in the end, when I realise I need to use monads, it will be obvious at that point that there's probably a better way of doin git
15:11:01 <jle`> usually the only people that work with monads on a polymorphic level are library developers, not application developers
15:11:09 <fishythefish> chorizo: no, there's nothing wrong with using monads
15:11:19 <fishythefish> it's just that you don't need to try so hard to use them
15:11:40 <jle`> chorizo: you never "need to use monads" -- you might find a *specific type* helpful
15:11:58 <jle`> for example, if you need a container of items, you wouldn't think "oh i need a monad", you might think "i can use a list here"
15:12:04 <jle`> not because it's a monad, but because it's useful for holding things
15:12:09 <jle`> (to an extent)
15:12:22 <jle`> and, if you need to specify an IO action, you wouldn't think "oh i need a monad for IO"
15:12:29 <jle`> you'd think "oh i need the IO type, a type designed for specifying IO actions"
15:12:39 <jle`> note that in these cases, you don't "need the monad".  you need a specific type
15:12:49 <jle`> the fact that they are monads plays zero part in why you would pick them
15:12:56 <johnw> geekosaur: yeah, I see that...
15:13:14 <chorizo> right, but if I needed to evaluate and run multiple IO I would have to remember that it's a monad right?
15:13:18 <johnw> geekosaur: I thought that maybe because they have an Eq instance, maybe I could get at that uniquely identifying bit of info
15:13:29 <jle`> chorizo: no, you would just remember the API of IO
15:13:49 <jle`> every type comes with functions for manipulating that type
15:14:04 <jle`> sequencing IO actions is just a function provided by the IO type that lets you combine IO actions
15:14:06 <geekosaur> johnw, the Eq instance uses a low level thing to compare MutVar# addresses. there may be something else exposable, but I wouldn't want to rely on it
15:14:07 <chorizo> jle`, so what you're trying to say, is everyone scares the beginners shouting about monad heaven and how scary they are
15:14:23 <johnw> geekosaur: no reliance here, this is solely for debugging
15:14:33 <fishythefish> (to be fair, a substantial chunk of the IO interface is given by the Monad instance)
15:14:48 <chorizo> when in reality it's just... an abstract concept that allows you to do some cool stuff
15:14:54 <fishythefish> chorizo: of course - this is a well known problem
15:14:54 <jle`> fishythefish: yeah but that's more of a discoverability thing
15:15:09 <geekosaur> chorizo, newcomers tend to vastly overrate monads. they're an abstraction, one which happens to be abstract enough that it's hard to figure out for most people
15:15:28 <jle`> chorizo: i wouldn't say that 'monads allow you to do some cool stuff'
15:15:31 <fishythefish> jle`: agreed - I'm just saying that even if you only try to use the IO API without touching Monads, you will end up encountering the Monad instance regardless
15:15:32 <maerwald> geekosaur: only in the haskell community I believe
15:15:33 <jle`> the types themselves are cool
15:15:34 <geekosaur> and yet almost absurdly simple once you do figure it out
15:15:40 <maerwald> because people tend to overcomplicated things
15:15:42 <jle`> IO is a cool type, Maybe is a cool type
15:16:00 <jle`> *abstracting over different monads* does allow you to do some neat stuff with code reusability
15:16:11 <jle`> but "abstracting over different monads" is different than "monads"
15:17:01 <jle`> when people set out to figure out what the big deal is about monads, they often confuse the two
15:17:47 <jle`> they think that the fact that something is a monad gives it special abilities
15:17:53 <chorizo> I mean, at least when I was using random, io and state stuff, it was just confusing that you can have something return Something x and then it's useless until you use something like evalBla (Something x)
15:17:53 <jle`> or that being a monad makes a type special
15:18:04 <jle`> chorizo: yes, but that's not because they are monads
15:18:07 <jle`> chorizo: that's because of the type itself
15:18:19 <chorizo> oh, I see. I guess those types just lend themselves to being monads
15:18:21 <jle`> the quirk you are observing doesn't have to do with monads
15:18:25 <jle`> it's just the specific type
15:18:43 <chorizo> right it's like data Random = { evalRandom :: something -> something }
15:18:44 <jle`> that's like saying "something i noticed when using monads is that you can pattern match on [] to check if a list is empty"
15:19:07 <jle`> when like...that observation...is completely unrelated to monads... it's just a remark about using lists
15:19:17 <maerwald> how is c-inline th code compiled?
15:19:32 <jle`> chorizo: don't associat ethat pattern with monads
15:19:33 <chorizo> yeah, so people get mixed up between properties that are common on monadic instances, and actual monadic properties/uses
15:19:40 <jle`> chorizo: that "you have to evalBla for monads"
15:19:46 <jle`> becuase it's not true for most monads
15:19:52 <jle`> and it's also true for many non-monads
15:19:56 <jle`> it is completely unrelated to monadness
15:20:01 <chorizo> yeah I realised from this talk
15:20:16 <chorizo> that stuff I thought was monadic is just boring old data types
15:20:23 <jle`> yeah, you get it :)
15:20:30 <chorizo> woo
15:20:33 <jle`> or well, the types themselves are interesting
15:20:37 <jle`> the monadic part is the boring part ;)
15:21:03 <jle`> being a monad is literally the least interesting thing about IO
15:21:04 <chorizo> I'm waiting for a blogpost titled 'Monads are boring, data types are intesting'
15:21:13 <jle`> well not literally, but close
15:21:33 <jle`> GHC's IO type is really a work of art, a triumph of modern engineering
15:21:43 <jle`> to reduce it to looking at its Monad instance is a real shame
15:21:44 <chorizo> that good? Whats so special?
15:21:53 <danilo2> Hi guys! Is there any way to silent warnings that a top level function doesnt have a type signature IF AND ONLY IF that top level function was generated from TH splice?
15:22:00 <jle`> for one, it allows you to treat IO actions as first-class values
15:22:07 <jle`> so you can manipulate them like normal values
15:22:17 <maerwald> manipulate?
15:22:32 <jle`> yes
15:22:56 <jle`> use them as normal values in functions, just like any other value
15:23:03 <jle`> return them from functions
15:23:32 <jle`> basically it's similar to the innovation of 'first-class functions' (being able to use functions as normal values), except applied to io actions
15:24:27 <HKei> I wouldn't say the Monad part is "uninteresting". You don't have to call it `Monad` per se, but you need some sort of API for sequentiality. Haskell didn't really have that before monads were introduced
15:24:52 <jle`> sure but the API for sequentiality is one of the least interesting things about IO
15:24:54 <fishythefish> it's uninteresting because that functionality is provided by the type whether or not the Monad typeclass exists
15:25:03 <jle`> IO is a rich type with a lot of features
15:25:18 <jle`> being able to sequentially compose IO actions is as mundane as + for integers
15:25:40 <jle`> er, + for real numbers, maybe
15:25:45 <Logio> jle`: one might say it is exactly the same kind of mundane
15:25:55 <Logio> a monoid
15:26:07 <jle`> "real numbers are so interesting!!!"
15:26:11 <jle`> *proceeds to only talk about +*
15:26:13 <HKei> they are though?
15:26:40 <Cale> HKei: It would have the monad operations even if we didn't use the word Monad or make any effort to abstract over them. The more interesting innovation is actually not the monad part, but that IO is a type at all.
15:26:47 <HKei> Sure, you can do more with them than adding them together, but learning how to add two reals is a good start.
15:27:07 <maerwald> Cale: are you sure it's the first language that has given that a type?
15:27:08 <jle`> yes it's useful
15:27:09 <Cale> Monad is to IO what Num is to Integer
15:27:17 <jle`> but my point isn't that it isn't useful
15:27:24 <fishythefish> and note that most people learn to add two reals without ever learning that real numbers form a group under addition
15:27:27 <Cale> maerwald: Not entirely sure
15:27:31 <jle`> my point is that among the other things that IO can do, its Monad interface is among the least interesting
15:27:33 <Cale> maerwald: Seems possible.
15:28:03 <Cale> Earlier versions of Haskell didn't have the IO type
15:28:10 <HKei> jle`: That's certainly true as far as comparisons to imperative languages are concerned, because there you'd usually want to highlight the stuff that's actually different
15:28:12 <jle`> which is why i say it is 'uninteresting', in the sense it is 'least interesting'
15:29:35 <Cale> and it just so happened that the change from using Response -> Request sort of continuation passing style stuff to using a dedicated type of IO actions happened at around the same time as the Monad interface was introduced. It's possible that the latter inspired the former, but it could have happened separately regardless (in either order)
15:30:07 <fishythefish> the sheer variety of Monads is testament to how uninteresting the Monad interface is
15:30:23 <jle`> cute :)
15:30:38 <Cale> Well, that makes it somewhat uninteresting, but it's also part of why it's a useful notion
15:31:11 <HKei> I'd say an abstraction that has only a handful of instances is the rather uninteresting thing
15:31:17 <Cale> The usefulness of such an interface is the product of the number of instances of it that we can write with the number of polymorphic functions and use-cases for it that we can come up with.
15:31:18 <fishythefish> it's a bit tongue in cheek - in the extreme that the Monad interface is the *only* interesting aspect, one might ask why we bother having more than one Monad
15:32:17 <fishythefish> I think this is what jle` was talking about before - it's worth separating the questions of how interesting in the interface is and how interesting the concept of abstracting over that interface is
15:32:34 <Cale> There are just enough operations which work with arbitrary monads, and just enough examples of monads to make it interesting
15:32:45 <fishythefish> beginners seem drawn to grokking the interface rather than the idea that it's the abstraction that is important
15:33:00 <Cale> If you wouldn't abstract over the interface, I would tend to assume it's not worth talking about it
15:33:19 <fishythefish> indeed, that's what we often tell beginners :)
15:33:44 <fishythefish> use types as types - don't worry about Monad until you've seen enough that the abstraction is useful
15:33:51 <Cale> Right
15:34:06 <Cale> You need enough examples of monads before the Monad type class makes sense as an idea.
15:34:42 <Cale> and before that point, it's almost not worth the mention that those things happen to be monads, apart from the foreshadowing :)
15:35:50 <Cale> (well, if you're diving in off the deep end and trying to get real work done, then perhaps it's worth knowing that you can substitute the given type for m in any of the things that have a (Monad m) constraint, just so that you have a shot at finding the operations you need.)
15:36:50 <jle`> yeah, but that's basically the same thing as figuring out if you can use (/) :: Fractional a => a -> a -> a for your type
15:37:32 <jle`> s/but//
15:38:17 <Cale> yes
15:38:38 <Cale> You don't actually have to understand the Monad class properly to be able to know that :)
16:16:38 <dsal> Does haskell ever decide to strictly evaluate something for resource reasons?  e.g. "I'm out of memory, better think through some thunks" ?
16:17:22 <lyxia> no
16:17:40 <dsal> So always my responsibility to not blow stuff up?
16:17:41 <aarvar> dsal: who says that would save memory?
16:17:57 <dsal> Yeah, I guess that makes sense.
16:18:01 <jle`> yeah, remember that the point of lazy evaluation is to use less memory
16:18:49 <johnw> how do I pass CPP options for GHC to the cabal configure command?
16:18:51 <jle`> i mean, that's not "the point"
16:18:53 <johnw> it doesn't accept --cpp-options
16:19:00 <jle`> but it's one of the intended benefits :)
16:19:08 <aarvar> dsal: it's also your responsibility in a strict by default language
16:19:40 <dsal> heh
16:19:54 <aarvar> adding strictness can cause space leaks too
16:19:54 <dsal> I was just wondering if there was any kind of de-thunking heuristic.
16:20:05 <johnw> is it --cpphs-options?
16:20:19 <jle`> dsal: there are, that's what the strictness analyzer does
16:20:31 <dsal> Is that a compile phase?
16:20:35 <dsal> Or a separate thing?
16:21:27 <aarvar> the compiler checks if something is used strictly, and if it is can unlift it
16:21:48 <dsal> What does it mean for something to be used strictly?
16:21:58 <aarvar> always evaluated
16:22:22 <aarvar> so if you have a thunk that doesn't really need to be a thunk, it can get rid of it (hopefully)
16:23:09 <dsal> What would something that's always evaluated look like?
16:23:13 <johnw> nope, not cpphs
16:23:17 <dsal> i.e., how do it know/
16:24:32 <aarvar> dsal: foo :: Int -> Int; foo x = x + 3
16:24:52 <aarvar> + for Int is strict, so it always evaluates x
16:24:55 <aarvar> so foo is strict as well
16:25:08 <geekosaur> johnw, -optP iirc
16:26:11 <dsal> aarvar: Thanks, that makes sense.  How do I know that + is strict for Int?  (I'm running out of questions soon because I have to catch a train)
16:26:28 <johnw> geekosaur: thanks, I just ended up defining a flag
16:26:42 <aarvar> dsal: well, (+) is implemented in terms of more primitive operations
16:26:51 <fishythefish> dsal: because passing undefined as either argument causes the result to be undefined
16:27:01 <fishythefish> f is strict iff f _|_ = _|_
16:27:47 <aarvar> dsal: the fact that primitive integer addition is strict is presumably built into the compiler, and then it can infer the rest from there
16:28:25 <hpc> and to help for things that take multiple parameters, \_ -> _|_ = _|_
16:28:29 <aarvar> dsal: er, no, it's actually encoded in the type
16:28:49 <aarvar> the primitive operation takes unboxed ints, and thus has to be strict
16:29:02 <dsal> Oh, that makes sense.
16:30:13 <aarvar> dsal: then once it knows that foo is strict, it can compile it into a function which takes an unboxed int, rather than a thunk
16:32:27 <dsal> Thanks.  This is helpful.
16:32:41 <dsal> Is there something that spits out a report of some sort of these decisions?
16:33:18 <geekosaur> -ddump-stranal?
16:33:41 <geekosaur> or -ddump-str-signatures to just show the result, I think
16:34:47 <dsal> Yeah, thanks.
16:35:45 <sqooq> mother of god
16:35:55 <sqooq> pls someone help me
16:36:02 <sqooq> i'm about to throw my laptop against the wall
16:36:09 <iqubic> @define compute fs = xs where xs = fmap ($ xs) fs
16:36:11 <lambdabot>  Defined.
16:37:06 <iqubic> > compute [length, (!! 0), \x -> x !! 0 + x !! 1]
16:37:09 <lambdabot>  [3,3,6]
16:37:25 <iqubic> :t computer
16:37:25 <sqooq> actually nevermind
16:37:27 <lambdabot> error:
16:37:27 <lambdabot>     • Variable not in scope: computer
16:37:27 <lambdabot>     • Perhaps you meant ‘compute’ (line 160)
16:37:31 <sqooq> i don't think i could be helped
16:37:35 <sqooq> i have to deal with this on my own
16:37:36 <iqubic> :t compute
16:37:38 <lambdabot> Functor f => f (f b -> b) -> f b
16:37:45 <fishythefish> you certainly can't be helped if you never ask a question ;)
16:37:51 <Zemyla> I've seen that function called loeb before.
16:37:57 <sqooq> fishythefish: idk how to even word it
16:38:03 <iqubic> Yeah. That's right Zemyla
16:38:15 <iqubic> I'm watching a comonad talk on YouTube
16:38:24 <sqooq> i'm trying to write an algorithm that finds a path that goes through every node within a graph
16:38:33 <sqooq> and
16:38:51 <sqooq> i keep going in a mental loop, idk how to go forward
16:39:16 <Axman6> :t let f x = let x' = fmap ($ x')  x in f
16:39:18 <lambdabot> <no location info>: error:
16:39:18 <lambdabot>     not an expression: ‘let f x = let x' = fmap ($ x')  x in f’
16:39:34 <iqubic> > compute [(!! 2), \x -> x !! 0 + x !! 2, length]
16:39:36 <Axman6> :t let f x = let x' = fmap ($ x')  x in x' in f
16:39:36 <lambdabot>  [3,6,3]
16:39:37 <lambdabot> Functor f => f (f b -> b) -> f b
16:40:30 <iqubic> Yeah, so the the compute function I wrote is weird, because you have access to the answers of all the computations when performing any one given computation.
16:41:51 <fishythefish> sqooq: are you trying to implement an existing hamiltonian path algorithm or write your own?
16:43:06 <fishythefish> > compute [last] -- sorta, iqubic
16:43:10 <lambdabot>  [*Exception: <<loop>>
16:43:55 <iqubic> > compute [length, sum]
16:43:58 <lambdabot>  [2,*Exception: <<loop>>
16:44:10 <iqubic> Wait, what!?!
16:44:54 <Axman6> looks like an infinite loop to me
16:45:36 <iqubic> yes, but it gets the length just fine.
16:47:08 <mniip> :t compute
16:47:09 <lambdabot> Functor f => f (f b -> b) -> f b
16:47:14 <mniip> loeb?
16:48:16 <iqubic> yes
16:48:42 <iqubic> I'm watching a video on comonads, and that was brought up.
16:49:22 <Psybur> :t fromJust
16:49:24 <lambdabot> Maybe a -> a
16:49:47 <Psybur> :t compute [fromJust]
16:49:48 <lambdabot> error:
16:49:48 <lambdabot>     • Couldn't match type ‘Maybe b’ with ‘[b]’
16:49:48 <lambdabot>       Expected type: [b] -> b
16:50:20 <Psybur> ops
16:50:29 <Psybur> :t compute (Just fromJust)
16:50:32 <lambdabot> Maybe b
16:51:02 <iqubic> loeb fs = fix $ \xs -> fmap ($ xs) fs
16:51:10 <iqubic> That's also cool
16:51:31 <iqubic> :t let loeb fs = fix $ \xs -> fmap ($ xs) fs in loeb fs
16:51:32 <lambdabot> error:
16:51:32 <lambdabot>     • Variable not in scope: fs :: f (f b -> b)
16:51:32 <lambdabot>     • Perhaps you meant one of these:
16:51:51 <iqubic> does it have the right type at least?
16:52:12 <fishythefish> :t \fs -> fix $ \xs -> fmap ($ xs) fs
16:52:14 <lambdabot> Functor f => f (f b -> b) -> f b
16:52:26 <iqubic> Ah, cool. So it is loeb
16:53:21 <sqooq> fishythefish: my own i guess
16:53:30 <sqooq> i don't care how efficient it is
16:53:32 <sqooq> i just want it to work
16:53:37 <fishythefish> sqooq: good, because it's NP-complete :P
16:53:41 <sqooq> i was going to just go through ever path until it succeeds
16:53:53 <fishythefish> well, in a graph with cycles, there are infinitely many paths
16:54:15 <fishythefish> you'll want to keep track of what you've visited
16:54:20 <sqooq> you back track when you've visited a node already
16:54:48 <sqooq> but the sequence you're building is seperate from the places you've been
16:55:02 <fishythefish> why?
16:55:03 <sqooq> so you have to undo your sequence when you reach an alreadyvisited point too
16:55:22 <sqooq> fishythefish: am I wrong with that?
16:56:04 <fishythefish> sqooq: the set of visited nodes should be the path you've built up, no?
16:56:27 <woodson> Anyone familiar with the miso framework?
16:57:26 <sqooq> fishythefish: o you're right, for whatever reason I was thinking if you visit, you visit it forever
16:57:31 <sqooq> but if you backtrack, you unvisit
16:57:33 <fishythefish> right
16:57:41 <sqooq> ok that simplifies things then
16:57:44 <sqooq> let me try again
16:57:53 <sqooq> I've been trying to do this for hours
16:58:01 <sqooq> I seriously don't know why I can't wrap my mind around it
16:58:09 <sqooq> I've drawn graphs and manually done it as a human
16:58:10 <sqooq> so Like
16:58:13 <sqooq> I get what should occur
16:58:19 <sqooq> but still i mess up
16:58:23 <sqooq> AGHHH
16:59:06 <ph88> hey Taneb are you around ?
17:02:08 <mroutis> do you guys use vim or emacs (for editing haskell)? or you just don't care and haskell didn't affect your decision at all?
17:02:34 <cozachk> vim or sublime text
17:02:47 <fishythefish> vim, but haskell wasn't part of that decision
17:02:50 <cozachk> mostly sublime text these days for nice tabs
17:02:51 <zfnmxt> I use spacemacs :^)
17:03:19 <zfnmxt> i like it way more than just vim :)
17:03:37 <fishythefish> i keep meaning to try spacemacs but i'd have to relearn my hotkeys
17:04:06 <zfnmxt> fishythefish: hotkeys = vim keybindings?
17:04:37 <fishythefish> zfnmxt: no, the ones for buffer manipulation, help text, etc.
17:04:45 <fishythefish> i understand evil-mode :P
17:04:56 <zfnmxt> Was just checking :P
17:05:03 <chorizo> zfnmxt, spacemacs is nice :)
17:05:42 <danilo2> Hi guys! Is there any way to silent warnings that a top level function doesnt have a type signature IF AND ONLY IF that top level function was generated from TH splice?
17:14:14 <iqubic> I use Emacs.
17:16:44 <chorizo> with stack do you usually not need to change the .cabal file? It's in my .gitignore automatically but I have to change the .cabal file to add deps..
17:16:54 <chorizo> probably something to do with the dreaded arch
17:18:22 <sqooq> cozachk: vim but looking to switch to emacs with a vim mode/vim bindings
17:18:35 <sqooq> mainly because i find vim's extensions lacking
17:18:38 <sqooq> they either are buggy
17:18:45 <sqooq> just not that good
17:18:48 <sqooq> don't exist
17:18:49 <sqooq> etc.
17:21:15 <chorizo> sqooq, that's what I did, evil bindings work really well, for me at least.
17:21:37 <sqooq> ye, I tried spacemacs once but I really hated it.
17:21:50 <chorizo> yeah I kind of dislike how much longer it takes to open
17:22:00 <chorizo> I use to jump around and open and close vim constantly
17:22:00 <sqooq> I dont' like emacs as a concept in general tbh
17:22:15 <chorizo> but now I just use one window of emacs and jump around a project, and do the rest with vim
17:22:18 <lyxia> chorizo: no you shouldn't need to touch the .cabal file
17:22:46 <marvin2> sqooq what did you hate about it?
17:23:01 <sqooq> marvin2: too bulky
17:23:07 <sqooq> too slow
17:23:14 <sqooq> shit documentatino
17:23:26 <marvin2> there's spacemacs-base
17:23:59 <sqooq> marvin2: maybe
17:26:44 <iqubic> sqooq: emacs has some of the best documentation out of all the text editors I use.
17:27:07 <sqooq> iqubic: emacs maybe, spacemacs, in my limited experience, no
17:27:10 <sqooq> but remember, I'm an idiot
17:27:12 <sqooq> so
17:27:31 <sqooq> What's that notation in haskell to give a name to the whole strcute, and the pattern too??
17:27:42 <sqooq> like g@(x:xs) or somethign?
17:27:55 <chorizo> yeah
17:28:02 <marvin2> that's it
17:28:05 <sqooq> ok thanks
17:28:55 <chorizo> I swear that first time I saw a line like func g@(x:y:xs) = a <$> b <*> c was like, I'm never learning this
17:32:05 <sqooq> wait, how do I know when i'm done traversing
17:32:09 <sqooq> fishythefish:
17:32:20 <sqooq> omg now i'm losing my memory
17:32:42 <fishythefish> sqooq: well, if you've visited as many nodes as there are total in your graph, you've found a path
17:33:38 <fishythefish> otherwise, if there are no adjacent nodes to descend into, you need to backtrack
17:33:44 <fishythefish> and if you can't backtrack, then you give up
17:36:18 <sqooq> fishythefish: ok i did that, can't tell if it's just taking really long, or if i messed up somewhere and it's hanging
17:36:38 <fishythefish> sqooq: i mean, this is gonna be a very slow algorithm
17:36:45 <fishythefish> you should start by testing small graphs
17:37:58 <sqooq> ok it seemingly works for the super trivial case
17:38:03 <sqooq> of a chain
17:38:05 <sqooq> 3 numbers
17:38:42 <sqooq> it also works for a diamond
17:38:45 <sqooq> so maybe it does work
17:38:47 <sqooq> wow it's REALLY slow
17:38:51 <sqooq> then
17:40:16 <sqooq> kek i've waited 2 minutes
17:40:23 <sqooq> still can't caluclate a graph with 15 nodes
17:40:36 <sqooq> i have a feeling it's getting stuck in some special moment
17:40:42 <sqooq> the graphs not even that complex, it has 1 loop
17:41:44 <fishythefish> well, it's not just the number of nodes it has, it's how connected they are
17:42:26 <fishythefish> while your program is running, draw your 15-node graph on a piece of paper and try tracing out all the paths via the DFS algorithm you just implemented
17:42:31 <fishythefish> that might help demonstrate the complexity
17:43:06 <sqooq> i have it here
17:43:08 <sqooq> maybe the loop
17:43:20 <sqooq> I think that's why I previously wanted a seperate visitation list from sequence list
17:43:29 <sqooq> because I somehow thought loops would mess up?
17:43:48 <fishythefish> what are you looping over?
17:44:07 <sqooq> there's a loop in the graph
17:44:17 <sqooq> idk i just checked it and it shouldn't cause problems so idk
17:44:18 <fishythefish> loops in the graph are fine
17:44:26 <sqooq> it's pretty straight forward graph minus the loop
17:44:36 <sqooq> maybe I should give it an eaiser starting point
17:44:47 <sqooq> o boy
17:44:49 <sqooq> exception
17:44:55 <sqooq> non exhaustive pattern :thinking:
17:45:10 <fishythefish> you should be able to catch that at compile time
17:45:20 <sqooq> o nvm i gave it value that's not in graph
17:46:56 <sqooq> o it gets stuck on the small easy graph depending on starting value too
17:47:02 <sqooq> i wonder what's going on
17:48:59 <sqooq> fishythefish: also if there is no path, how does it know to stop
17:49:27 <fishythefish> sqooq: because eventually it will have exhausted all possible paths and none of them will have been long enough
17:49:40 <sqooq> but how will it know that
17:50:04 <fishythefish> what is "it"?
17:50:23 <sqooq> idk
17:50:28 <sqooq> the algorithm
17:50:36 <spruit11> That thing?
17:50:48 <sqooq> O nvm I think i can do it
17:50:56 <fishythefish> if you're at a node with no unvisited adjacent nodes, then either you've actually found a path or you need to backtrack
17:50:57 <sqooq> no i can't
17:51:09 <fishythefish> if you're at a node with unvisited adjacent nodes, then you try descending into each one
17:51:29 <sqooq> here's the thing, if you backtrack, you unvisited nodes, so you can visit them again
17:51:33 <sqooq> so the thing will go on forever
17:51:47 <OmegaDoug> When defining modules in Haskell, do the file names need to match the folder structure? That was the only way I was able to get this error (http://lpaste.net/364983) to go away to it seems to be the case
17:51:59 <fishythefish> how are you implementing backtracking? I figured you were just doing this recursively
17:52:01 <geekosaur> yes
17:52:07 <sqooq> fishythefish: recursively
17:52:30 <fishythefish> sqooq: right, so say you're in node A and it has two unvisited neighbors B and C
17:52:41 <iqubic> haskell on nix seems rather complex
17:53:13 <fishythefish> sqooq: you descend into each of those and perform your recursion
17:53:24 <fishythefish> you don't descend into B, backtrack, then try B again
17:53:38 <sqooq> fishythefish: o I thought that's what you do
17:53:46 <sqooq> well you don't try B
17:53:48 <sqooq> you try the next
17:53:52 <sqooq> But let's say you backtracka gain
17:53:57 <sqooq> then you can try B again
17:53:58 <sqooq> OOOOO
17:54:07 <sqooq> ok yeah I think my program is already good then?
17:54:09 <sqooq> idk why it hangs
17:54:15 <fishythefish> because this algorithm is very slow
17:54:27 <fishythefish> you can add some output to watch its progress
17:54:35 <sqooq> but 5 elements??
17:54:36 <fishythefish> i don't recommend jumping from 3 nodes to 15 nodes
17:54:41 <fishythefish> how many edges?
17:54:49 <sqooq> 5 edges
17:55:08 <fishythefish> (also is this directed or undirected?)
17:55:08 <sqooq> here, scrutinize my code
17:55:11 <sqooq> i must be doing something wrong
17:55:17 <sqooq> I don't have a case for when everything fails anyways
17:55:19 <sqooq> http://lpaste.net/364986
17:55:22 <sqooq> undirected
17:55:46 <fishythefish> a typesig would be helpful
17:56:04 <fishythefish> I don't know what data structures you're using to represent the graph, edges, nodes, etc.
17:56:04 <sqooq> :t motherofgof
17:56:06 <lambdabot> error: Variable not in scope: motherofgof
17:56:08 <sqooq> rip
17:56:27 <sqooq> apparently M.IntMap [M.Key] -> M.Key -> [M.Key] -> Int -> [M.Key]
17:57:19 <sqooq> really though
17:57:21 <sqooq> motherofgod :: M.IntMap [Int] -> Int -> [Int] -> Int -> [Int]
17:58:21 <iqubic> What's the right way to open a ghci prompt with all the dependecies loaded when using this: https://github.com/Gabriel439/haskell-nix
17:59:19 <fishythefish> sqooq: what is melem
17:59:32 <iqubic> So I'm having nix build all the stuff. I want to know how to load up ghci with all the correct libraries in scope.
18:00:06 <sqooq> fishythefish: shh, we don't talk about melem. It returns value at a key in the Map
18:00:12 <sqooq> which is a list
18:00:23 <sqooq> I'm using adjacency list representation of undirected graph
18:00:23 <fishythefish> ah, I take it that's where the inexhaustive pattern match was
18:00:37 <sqooq> fishythefish: actually no, that can't be it
18:00:50 <sqooq> I defined it to give a nonsensical result for a case that should never happen
18:01:06 <iqubic> :t melem
18:01:07 <lambdabot> error:
18:01:07 <lambdabot>     • Variable not in scope: melem
18:01:07 <lambdabot>     • Perhaps you meant one of these:
18:01:10 <sqooq> so maybe it's the nonsensical result that causes inexhaustive pattern on my motherofgod function
18:01:16 <sqooq> iqubic: I defined it
18:01:22 <sqooq> it's just melem = M.findWithDefault []
18:01:25 <fishythefish> sqooq: yeah I see the problem
18:01:31 <sqooq> fishythefish: me too
18:01:45 <sqooq> I'm backtracking and then calling the function, but hte function will once again go across all elements
18:01:48 <sqooq> getting stuck forever
18:01:49 <fishythefish> right
18:01:56 <fishythefish> you should be backtracking by returning up to the parent
18:01:57 <sqooq> :(
18:02:09 <sqooq> what do you mean by that?
18:02:15 <sqooq> I go back to the right level
18:02:24 <sqooq> it's just that the `f` function checks all the values once gaain
18:02:32 <fishythefish> you do not go back to the right level
18:02:43 <sqooq> are you sure that's the problem?
18:02:48 <fishythefish> your stack should be exactly as deep as the path you have already traversed
18:03:06 <sqooq> I think i go back to the right level, it's just that the `f` function will go back through what's already been through
18:03:11 <sqooq> because i call motherofgod on it again
18:03:15 <fishythefish> what do you mean by "level"?
18:03:19 <fishythefish> i'm assuming you mean recursion depth
18:04:14 <sqooq> fishythefish: ok so at some n, it gets a list say [1,2,3], let's say none have been visited, it uses 1 as the next function call. Now when 1 fails, it backtracks back to "n", in order to try the next
18:04:25 <sqooq> but the way I have it defined, it just goes through [1,2,3] all over again
18:04:40 <sqooq> so it will go back in 1, fail, come back out, and so on for infinity
18:04:54 <sqooq> going back to the parent of n isn't the right thing to do, because i still havenn't tried 2 and 3
18:05:02 <sqooq> idk how to fix this
18:05:05 <fishythefish> sqooq: except you're not coming back out of the recursion, you're just restoring the values to the previous state
18:05:28 <fishythefish> of course you don't go back to the parent of n, you just return a failure result and you're back in n
18:05:37 <sqooq> failure result???
18:05:51 <fishythefish> sure, you could use Maybe
18:05:56 <fishythefish> return Nothing if no path exists
18:06:01 <fishythefish> return (Just path) if you find one
18:06:11 <sqooq> you've completely lost me now
18:06:30 <fishythefish> let's try something simpler - imagine implementing DFS for a tree
18:06:32 <sqooq> not because I don't understand Maybe
18:06:53 <sqooq> what kind of tree?
18:06:58 <fishythefish> any kind
18:07:00 <fishythefish> binary, whatever
18:07:00 <sqooq> a binary tree would be easy as fuckign fuck
18:07:05 <fishythefish> n-ary if you want
18:07:19 <fishythefish> say you're at a leaf node and the value there isn't the one you're searching for
18:07:28 <fishythefish> you don't make a recursive call back to the parent
18:07:36 <fishythefish> you just return a value that signals you didn't find what you wanted
18:07:41 <fishythefish> and let the parent deal with it
18:07:48 <fishythefish> same idea here
18:08:19 <sqooq> idk
18:08:25 <sqooq> wouldn't it be easier to just return empty list
18:08:31 <sqooq> a tree is much simpler
18:08:45 <iqubic> If I'm using nix to build my haskell projects, then how shall I go about launching ghci with the right deps?
18:09:02 <fishythefish> sqooq: not really, you're basically using the same algorithm
18:09:17 <fishythefish> the only difference is whether a node is considered a leaf is determined dynamically
18:09:25 <fishythefish> a node is a leaf if all of its neighbors have already been visited
18:10:18 <boj> iqubic: go through https://github.com/Gabriel439/haskell-nix
18:10:33 <iqubic> I have. I don't recall it mentioning ghci.
18:10:48 <fishythefish> sqooq: you probably want `motherofgod :: M.IntMap [Int] -> Int -> [Int] -> Int -> Maybe [Int]`
18:10:58 <boj> iqubic: ideally you'd just run nix-shell in your project, and then use ghci inside that shell
18:11:55 <sqooq> fishythefish: no i'm implementing a hamiltonian algorithm
18:12:01 <sqooq> hamiltonian doesn't make sense for a tree
18:12:09 <fishythefish> sqooq: no, but you're implementing it essentially by DFS
18:12:15 <iqubic> boj: Does that work?
18:12:21 <fishythefish> instead of searching for a value, you're descending until you have a path long enough
18:12:29 <fishythefish> instead of leaf nodes, you have nodes with no unvisited neighbors
18:12:57 <boj> iqubic: assuming you set things up correctly. your shell.nix would load the package.nix you generated with cabal2nix, and pull in all the deps you need
18:13:14 <fishythefish> my point is that you should only be making recursive calls as you go "deeper", you don't make recursive calls coming back up
18:13:16 <sqooq> treedfs Empty        = []
18:13:17 <sqooq> treedfs (Node n a b) = n : (treedfs a) ++ (treedfs b)
18:13:26 <sqooq> way easier
18:13:37 <sqooq> fishythefish: ok i'll take your word
18:13:43 <sqooq> but what happens with the Nothings
18:13:43 <fishythefish> sqooq: that's not a dfs
18:13:47 <sqooq> or the Maybe's in general
18:14:04 <iqubic> Do I need a shell.nix? What would look like?
18:14:09 <fishythefish> sqooq: if you get a `Just` value, that means you have a path and you can return it (or keep looking for others if you want)
18:14:21 <sqooq> fishythefish: hwaaaat
18:14:23 <fishythefish> if you get a `Nothing`, it means that recursive call was a dead end
18:14:27 <sqooq> i probably look so stupid to you
18:14:29 <sqooq> but like
18:14:36 <sqooq> The function itself will return a maybe
18:14:40 <sqooq> so how will the steps
18:14:47 <sqooq> do stuff with the maybe
18:15:03 <fishythefish> well, pattern matching would be simplest
18:15:03 <iqubic> The steps themselves include recursive calls, right?
18:15:16 <fishythefish> you make a recursive call, pattern match on the result
18:15:27 <sqooq> and do what??
18:15:33 <fishythefish> what I just said
18:15:42 <sqooq> i don't get it tbh
18:15:44 <fishythefish> if you get a `Nothing`, move on because that recursive call didn't find a path
18:15:50 <fishythefish> if you get a `Just`, then you're done
18:15:52 <sqooq> yes but what does moving on mean?
18:16:23 <fishythefish> sqooq: depends, if you have other neighbors left to descend into, it means descend into those
18:16:29 <sqooq> fishythefish: agh i think i got it now
18:16:37 <fishythefish> if recursing into all of the neighbors produces Nothing, then you yourself return Nothing in order to backtrack
18:16:41 <sqooq> at the level of the parent
18:16:49 <sqooq> the `f` function will go through the list of adjacencies
18:16:54 <sqooq> and pattern match
18:17:07 <fishythefish> yes
18:17:12 <sqooq> If it's Just, then we win, if it's Nothing, try the next,
18:17:20 <sqooq> I still have some things in my head that arent' clear
18:17:21 <fishythefish> yes
18:17:23 <sqooq> but let me try implementing
18:17:36 <fishythefish> in practice, you would map your recursion over all of the unvisited adjacencies
18:17:46 <fishythefish> and then check to see if any of the results were Just
18:17:57 <orion> Why are instance types required to be of the form (T a1 ... an) by default?
18:17:58 <sqooq> you can't map to do that though can you?
18:18:03 <sqooq> or I guess I could do one fmap
18:18:08 <sqooq> but fmap returns a list?
18:18:12 <sqooq> (for list)
18:18:41 <sqooq> yeah i think i'd have to recurse manually, maybe a fold can handle it
18:18:50 <sqooq> because i need to just return something
18:18:55 <fishythefish> fmap and map are the same for lists
18:19:00 <sqooq> like if it's all Nothings, then return Nothing
18:19:02 <fishythefish> you're (f)mapping over the list of adjacencies
18:19:11 <fishythefish> right
18:19:15 <sqooq> fishythefish: I know I'm just saying, fmapping over the list of adjacencies will make a list, which is bad
18:19:23 <fishythefish> sqooq: no, that's not bad
18:19:24 <sqooq> I think I need to fold
18:19:28 <fishythefish> you still need to process that list
18:19:39 <sqooq> how do I process the list!
18:19:43 <sqooq> an fmap!?
18:19:44 <sqooq> lol
18:19:52 <fishythefish> a fold would work
18:19:55 <sqooq> ye
18:19:56 <fishythefish> you could filter
18:20:00 <fishythefish> there are many options
18:20:06 <sqooq> nah i think folding from the getgo is the best move
18:20:08 <sqooq> that's what I was saying
18:20:11 <sqooq> filter could work
18:20:23 <sqooq> wait what does filter do when it can't find a result? empty list right?
18:20:45 <fishythefish> personally, I recommend you use catMaybes
18:20:54 <fishythefish> yeah, empty
18:21:03 <sqooq> yeah filter would make things messier because not only woul i need the filter part, i'd have to pattern matcch for empty... blah blh
18:21:12 <fishythefish> :t catMaybes
18:21:13 <lambdabot> [Maybe a] -> [a]
18:21:16 <sqooq> i think i'm gonna just do explicit recursion for now
18:21:27 <fishythefish> ^ that takes a list of maybe values and returns a list of the values wrapped in Just
18:21:46 <fishythefish> so if the result of that is empty, return Nothing
18:21:51 <fishythefish> otherwise, return Just the head of that list
18:22:34 <fishythefish> :t listToMaybe
18:22:35 <lambdabot> [a] -> Maybe a
18:29:12 <sqooq> i'm stuck
18:29:12 <zfnmxt> fishythefish: How does catMaybes return a list of values wrapped in Just?
18:29:27 <zfnmxt> Oh.
18:29:30 <fishythefish> > catMaybes [Nothing, Just 1, Nothing, Just 3]
18:29:32 <lambdabot>  [1,3]
18:29:32 <zfnmxt> I misunderstood what you wrote.
18:29:40 <fishythefish> yeah, I meant "which were wrapped in Just"
18:29:48 <zfnmxt> I thought you meant catMaybes :: [Maybe a] -> Maybe [a]
18:29:51 <zfnmxt> Like sequence or something :)
18:30:36 <fishythefish> sqooq: what are you stuck on?
18:30:44 <sqooq> nothing makes sense now
18:31:18 <sqooq> idk what to even say
18:31:20 <sqooq> i'm so
18:31:22 <sqooq> broken
18:31:30 <zfnmxt> sqooq: What are you working on?
18:31:38 <fishythefish> sounds like you should be in a teen band
18:31:48 <fishythefish> what does your code look like now?
18:32:24 <sqooq> fishythefish: it doesn't
18:32:31 <sqooq> i just wrote catmaybes and the other thign
18:32:34 <sqooq> but like
18:32:36 <sqooq> nothing's happening
18:33:03 <sqooq> it's assuming it will get maybes so it can return it,
18:33:09 <sqooq> but it never gets maybes
18:33:13 <sqooq> because it's assuming it gets maybe
18:33:34 <sqooq> maybe my helper function just has to maybe?
18:33:41 <sqooq> How does the sequence of visited notes play into this
18:33:43 <sqooq> ?
18:33:46 <sqooq> notes?
18:33:49 <sqooq> nodes?
18:33:50 <sqooq> nodes
18:33:52 <sqooq> vertices
18:34:02 <fishythefish> you keep saying "it" and I don't know what that means each time you say it
18:34:51 <zfnmxt> Are you just doing a toList for a tree?
18:34:59 <sqooq> idk what it means either LMAO
18:36:28 <sqooq> ye idk i'm back to Tabula Rosa
18:36:33 <sqooq> i'm so hopelessly confused
18:36:45 <sqooq> Tabula Rasa (?)
18:38:38 <iqubic> sqooq: What is your current issue?
18:39:21 <geekosaur> "rasa", yes
18:39:25 <byorgey> Tabula Rosa = rose slate
18:39:53 <sqooq> iqubic: unemployment
18:39:55 <sqooq> depression
18:40:03 <sqooq> anger at not being able to implement this algorithm
18:40:09 <iqubic> sqooq: I meant with the code. XD
18:40:13 <sqooq> o
18:40:24 <sqooq> iqubic: find path that goes through ever vertex of a graph
18:40:28 <sqooq> undirected graph
18:40:46 <iqubic> I get what the task is. What specific issues are preventing you from implementing it.
18:41:00 <sqooq> my stupidity
18:41:14 <sqooq> idk how to backtrack
18:41:23 <sqooq> i can't figur eit out it's driving me nuts iqubic, pls help
18:41:29 <sqooq> i'm gonna cry
18:41:30 <iqubic> Can I see what you have so far?
18:41:42 <sqooq> i deleted everything
18:41:48 <sqooq> i can show you what I know to be flawed
18:41:53 <sqooq> it's somewhere in here
18:41:56 <iqubic> Well that's not very helpful.
18:42:04 <zfnmxt> You were doing it with DFS?
18:42:13 <sqooq> http://lpaste.net/364986
18:42:21 <sqooq> zfnmxt: i guess
18:42:40 <sqooq> iqubic: i'm literally stuck beyond stuck
18:42:52 <sqooq> I know what needs to be done but I have no clue how to do it
18:42:57 <sqooq> the hwole Maybe thing confused me more I think
18:43:00 <byorgey> can you visit the same vertex more than once?
18:43:06 <sqooq> byorgey: nope
18:43:10 <sqooq> god i wish
18:43:36 <zfnmxt> Imma try to solve it myself for fun :)
18:43:43 <sqooq> -_-
18:43:49 <byorgey> That is called a hamiltonian path.  Finding one is an NP-complete problem.
18:43:54 <sqooq> byorgey: i know
18:44:00 <byorgey> ok. =)
18:44:01 <iqubic> NP-complete?
18:44:06 <zfnmxt> byorgey: Oh yeah
18:44:17 <iqubic> What is the type signature we are aiming for?
18:44:27 <sqooq> byorgey: thanks though, that information like 5 hours ago would have been a life saver
18:44:31 <zfnmxt> Then you can't DFS it can you
18:44:36 <sqooq> my friend and i were trying to find an underlying pattern
18:44:41 <sqooq> like a theorem or something
18:44:48 <iqubic> I have been itching to get back to haskell, and this seems like a good way to do that.
18:44:51 <sqooq> until i found out that it was a hamiltonaian path problem
18:44:55 <iqubic> What is the type signature we want?
18:45:01 <sqooq> so you have no choice but to just make an algoirthm for it
18:45:03 <byorgey> Of course you can still write a brute force function to try all possibilities, it will just be slow
18:45:03 <fishythefish> [16:53:14]  <fishythefish>	sqooq: good, because it's NP-complete :P
18:45:19 <sqooq> iqubic: I literally don't know, because there are potentially many state variables you have to pass around
18:45:29 <byorgey> fishythefish: heh
18:45:52 <iqubic> What does the data declaration of your graph look like?
18:45:53 <sqooq> fishythefish: that wasn't 5 hours ago, i knew it was hamiltonian then too
18:45:59 <sqooq> I knew before joinging chat
18:46:14 <iqubic> data Graph a = ...?
18:46:18 <iqubic> What is ... there.
18:46:29 <sqooq> iqubic: what do you mean by that? I'm doing an adjacency list representation, using IntMap for efficiency
18:46:42 <zfnmxt> I'm a noob, but could you do something nice with the nondeterministic list monad?
18:46:44 <sqooq> ignnore that question
18:46:56 <sqooq> it's type Graph a = IntMap [Int]
18:47:01 <sqooq> remove a sorry
18:47:02 <zfnmxt> And just have it kill off any potential path with a repeated node?
18:47:32 <sqooq> zfnmxt: maybe
18:47:36 <sqooq> I don't know anymore
18:47:38 <sqooq> i wanna cry
18:47:39 <iqubic> What the heck is an InMap?
18:47:55 <fishythefish> IntMap is essentially Map Int
18:47:59 <sqooq> IntMap is a Map but using Int as keys, which adds some efficiency
18:48:06 <zachk> if it isn't a homework problem or a personal challenge, there are a few graph libraries on hackage. Might want to check them out sqooq
18:48:38 <sqooq> zachk: i couldn't find one with hamiltonian, and quite frankly idk how to use them
18:49:00 <sqooq> at this point i want to implement it personally just for that satisfaction
18:49:04 <sqooq> i've put too much into this
18:49:05 <zfnmxt> Does the speed matter?
18:49:17 <sqooq> zfnmxt: ideally yes, but I literally don't care anymore
18:49:20 <zachk> oh, I bruteforced the traveling salesman problem with opengl output using gloss in about 120 loc a few years ago
18:49:26 <sqooq> I just want to see it work already dear god
18:49:33 <zachk> do you need it to loop?
18:49:44 <fishythefish> if seeing a sketched solution isn't cheating, here's something off the top of my head: http://lpaste.net/364988
18:51:02 <zachk> sqooq, you could just list all the permutations of the vertices and filter out the path's that aren't valid, its kind of slow and you can blow stack most likely past say 12 vertices
18:53:51 <sqooq> i'm going to cry
18:54:29 <Zipheir> sqooq: Relax and take a walk or something!
18:55:58 <sqooq> Zipheir: there's no time
18:56:01 <sqooq> i only have 2 hours
18:56:05 <sqooq> until bedtime
18:56:14 <sqooq> fishythefish: if this works I kill you
18:56:17 <fishythefish> k
18:56:55 <sqooq> fishythefish: it doesn't work
18:57:07 <sqooq> or rather
18:57:12 <sqooq> o it does wokr
18:57:16 <sqooq> it just depends on starting valu
18:57:18 <sqooq> it just depends on starting value
18:57:34 <sqooq> but I guess one could just fmap the algorithm across all starting values
18:57:34 <fishythefish> yeah, that's because that adjacency list representation is really directed
18:57:54 <fishythefish> oh, yeah, you could easily tweak it to try all starting values
18:57:56 <sqooq> fishythefish: what? there's only one adjacency list representation
18:58:03 <fishythefish> i didn't test that code extensively, i just wanted to give you an idea
18:58:08 <fishythefish> the path is also presented backward
18:58:24 <sqooq> or you mean adjacency list itself is too directed?
18:59:13 <fishythefish> sqooq: an undirected graph is just a directed graph in which edge undirected edge is represented by two directed edges, one in each direction
18:59:27 <fishythefish> the representation you/I are using is really directed because e.g. M.fromList [(0, [1]), (1, [])] is directed
18:59:48 <fishythefish> ^ in that example, you can find a path starting at 0, but not starting at 1
19:01:22 <zachk> sqooq: something like: filter isValidPath . permutations $ vertexList
19:01:50 <sqooq> fishythefish: well 1 should connect to 0 too
19:01:54 <sqooq> all the inputs i give are like that
19:02:01 <fishythefish> sqooq: in an undirected graph, yes
19:02:08 <fishythefish> i'm saying it doesn't *have* to with this representation
19:02:26 <sqooq> yes but starting value still matters even with my undirected graphs
19:02:27 <fishythefish> so you might see issues from that as well depending on your input graph
19:02:33 <fishythefish> of course starting value still matter
19:02:36 <fishythefish> matters*
19:02:38 <zachk> and is validPath (firstVertex:secondVertex:restOfList) = check and see if first vertex connects to second vertex and then recurse on isValidPath (secondVertex:restOfVertexList) and write the base cases
19:02:40 <sqooq> but fmapping is easy way
19:02:47 <sqooq> but then the function is being called a lot
19:02:55 <sqooq> probably super inefficient but it still seems to work instantly
19:02:57 <sqooq> even for high N's
19:02:58 <fishythefish> it's being called a lot anyway
19:03:00 <zachk> sqooq how many vertices?
19:03:41 <zachk> i gtg, night
19:04:23 <sqooq> fishythefish: ok can you please explain how this works
19:04:40 <sqooq> because i don't think this is what I thought you were saying
19:04:42 <fishythefish> sqooq: it's essentially the same approach you were trying to implement; which part is confusing?
19:06:07 <sqooq> wow it is the same
19:06:13 <sqooq> this is magic
19:07:44 <fishythefish> sqooq: updated http://lpaste.net/364988 to try all starting nodes
19:07:53 <sqooq> fishythefish: o shoot this algorithm, at least the fmapping, gives solutions twice in different orders
19:07:57 <sqooq> reverse order
19:08:01 <sqooq> o let me see how you did it
19:08:07 <fishythefish> right, if A-B-C is a path, so is C-B-A
19:08:38 <fishythefish> i have it written to only produce the first path, if any, but it's easy enough to have it return all paths insteda
19:08:40 <fishythefish> instead*
19:09:43 <sqooq> Vye i'd like to see all paths
19:09:59 <sqooq> too bad it repeats twice so some bigger graphs take even longer
19:11:48 <zfnmxt> sqooq: http://lpaste.net/364990
19:11:50 <zfnmxt> Does that work?
19:12:42 <fishythefish> sqooq: here it is with all paths: http://lpaste.net/364991
19:13:11 <zfnmxt> I made sure to use catMaybes :^D
19:14:00 <sqooq> fishythefish: that's identical to mine lmao
19:14:58 <fishythefish> it's the same as my previous one, except Maybe [Node] changes to [[Node]] (and firstJust consequently changes to concatMap)
19:15:04 <fishythefish> concat*
19:15:05 <sqooq> anyway I can get every double sum from a list
19:15:12 <freeman42x]NixOS> is esqueleto using tuples for data returned from database? is it not using some data type with proper names?
19:15:16 <sqooq> [1,2,3,4] -> [3,5,7]
19:15:19 <sqooq> easily
19:15:30 <sqooq> writing explicitly has a bunch of silly cases to cover
19:15:57 <fishythefish> > let f x = zipWith (+) x (tail x) in f [1, 2, 3, 4]
19:15:59 <lambdabot>  [3,5,7]
19:16:11 <sqooq> wow u smart
19:16:42 <fishythefish> every haskeller should know the fibonacci trick :P
19:16:53 <fishythefish> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
19:16:55 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:18:14 <davean> go Rein
19:18:18 <davean> bah
19:18:30 * fishythefish consoles davean 
19:21:23 <iqubic> is that fibs function zipping with itself?
19:21:36 <fishythefish> fibs isn't a function but essentially yes
19:21:49 <fishythefish> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
19:21:50 <lambdabot>  Defined.
19:21:51 <fishythefish> :t fibs
19:21:52 <lambdabot> Num a => [a]
19:25:16 <sqooq> lol i knew this would be slow
19:25:23 <sqooq> but goddamn it's slow
19:25:46 <fishythefish> i mean it's like
19:25:52 <fishythefish> O(n!) in the edges or something
19:26:33 <fishythefish> there are known faster approaches
19:29:14 <marvin3> isn't fibs definition above basically memoizing?
19:29:34 <sqooq> fishythefish: kek i did this to solve problem
19:29:38 <sqooq> it definitely does not solve the problem
19:29:43 <sqooq> which means there's some underlying pattern
19:29:50 <sqooq> which is what my friend and I tried to find for days now
19:29:58 <sqooq> but we gave up and decided to just do hamiltonian
19:30:04 <sqooq> https://www.codewars.com/kata/square-sums/coffeescript
19:30:09 <sqooq> fuck this problem ^
19:33:26 <fishythefish> sqooq: pretty sure the way to solve that is with a hamiltonian path
19:33:29 <iqubic> Yes, that is a hard problem.
19:33:32 <fishythefish> afaik there aren't any math tricks that help
19:34:37 <iqubic> relevent numberphile video: https://www.youtube.com/watch?v=G1m7goLCJDY
19:35:19 <iqubic> 9:06 on this very topic. No code or anything, just pure number stuff.
19:36:18 <iqubic> it's a 9 min and 6 sec video on this topic.
19:38:16 <blinkhard> i was using fibs to learn about f-algebras and recursion schemes like this http://lpaste.net/364992
19:38:39 <blinkhard> does anyone have color on the performance difference reflected in the comment?  f-algebras were slower than the zip version
19:39:31 <redrapscallion> can anyone help explain this statement that I found in the typeclassopedia?
19:39:34 <redrapscallion> > pure (+) <*> [2,3,4] <*> pure 4
19:39:36 <lambdabot>  [6,7,8]
19:40:12 <iqubic> How the heck did you define fibs with a hylo?
19:40:33 <lyxia> blinkhard: this hylo doesn't fuse
19:40:39 <lyxia> because cata and ana are recursive
19:41:15 <blinkhard> ok, thanks that is what i thought - not a stack versus heap thing
19:42:07 <iqubic> :t \alg coalg -> coalg . (fmap $ hylo alg coalg) . alg
19:42:08 <lambdabot> error:
19:42:08 <lambdabot>     Variable not in scope: hylo :: (a -> f a1) -> (f b -> c) -> a1 -> b
19:42:41 <lyxia> another problem is that `fib` is too lazy.
19:42:50 <iqubic> :t let hylo = \alg coalg -> coalg . (fmap $ hylo alg coalg) . alg in hylo
19:42:52 <lambdabot> Functor f => (a -> f a) -> (f b -> b) -> a -> b
19:42:56 <iqubic> there we go.
19:43:04 <iqubic> I think I may have fixed the hylo issue.
19:43:52 <sqooq> iqubic: jesus, my friend linked me right before you did
19:43:53 <lyxia> that one still doesn't inline alg and coalg well.
19:43:56 <sqooq> i'm watching now
19:43:59 <sqooq> this has been killilng me
19:44:18 <sqooq> fuck this problem if there's no pattern, and you just have to do an efficient hamiltonian
19:44:59 <lyxia> hylo alg coalg = go where go = coalg . fmap go . alg   -- here the body is specialized for a given alg and coalg
19:45:17 <iqubic> lyxia: that's literally what I just wrote.
19:45:24 <lyxia> it's not
19:46:22 <anon136> Why do some functions like this one "swap (x,y) = (y,x)" differentiate t and t1 like this "swap :: (t1, t) -> (t, t1)" while others like this one "twice f x = f (f x)" just read as all the same type "t" like this "twice :: (t -> t) -> t -> t"?
19:46:51 <lyxia> GHC doesn't know how to optimize hylo applied recursively to alg and coalg
19:47:17 <iqubic> What I wrote and what you wrote should be the same thing.
19:48:07 <iqubic> Now my question is this: "Where is the base case in that hylo definition?"
19:48:08 <blinkhard> lyxia's version gives performance about 2x the original but still much slower than the zipped version
19:48:11 <lyxia> feel free to look at the core
19:48:48 <iqubic> How does the execution of that hylo function ever end? How do we reach a result ever?
19:49:15 <blinkhard> here http://lpaste.net/364992
19:49:32 <lyxia> when coalg produces a ZeroF, fmap doesn't call its argument.
19:50:37 <iqubic> Oh, I see. That makes sense.
19:51:23 <iqubic> How does nthFibAlg work?
19:52:03 <geekosaur> anon136, because swap doesn't force everything to be the same type, and twice does
19:52:27 <geekosaur> f (f x) means the first and second calls to f must be receiving the same type, so all the same t
19:52:46 <geekosaur> swap doesn't care, it just swaps them without examining them and thereby without forcing their types
19:53:34 <lyxia> iqubic: https://www.reddit.com/r/haskell/comments/7ntkkn/stalking_a_hylomorphism_in_the_wild/ds4kmt5/ here's something a wrote about this difference on a similar case
19:54:56 <anon136> geekosaur: but if I do something like "twice double 2" that works perfectly fine but double and 2 are different types no?
19:55:25 <geekosaur> double is the f. double is not the result of calling (double 2)
19:55:46 <blinkhard> thank you lyxia this is helpful
19:56:23 <anon136> geekosaur: OOH because double once resolved will become the same type as 2
19:56:33 <geekosaur> ...?
19:57:02 <geekosaur> the type of 'double' is not the same as the type of the value produced by applying 'double' to something
19:57:05 <anon136> geekosaur: sorry for some reason the type system is very hard for me to wrap my head around
19:57:20 <geekosaur> 2 and the value produced by (double 2) must be the same type.
19:57:33 <geekosaur> this means double :: t -> t, possibly with some constraint on t
19:57:48 <geekosaur> (in Haskell, that constraint is at least (Num t))
19:57:49 <anon136> geekosaur: right yea thats what I meant, I think
19:58:13 <anon136> geekosaur: atleast im pretty sure it was the insight my brain was grasping at
19:59:04 <geekosaur> also, even this is not always true, but the situations where it isn't are rare and very advanced polymorphic cases
20:00:48 <geekosaur> (advanced enough that the language can't even infer those types for you, but you can write them manually.)
20:02:11 <anon136> geekosaur: I read this chapter on "types and classes" so slowly and so many times and still it is confusing.
20:02:48 <geekosaur> reading isn;t really enough, in my opinion. Play around with it in ghci, ask it the types of things
20:03:02 <geekosaur> build your own functions and ask it the types it's using
20:03:30 <geekosaur> there are some useful extensions for this: if you do:  :seti -XScopedTypeVariables -XPartialSignatures
20:03:32 <monochrom> Basically you need to be logical and do highschool algebra.  http://www.vex.net/~trebla/haskell/prerequisite.xhtml
20:03:42 <anon136> yea there was like a little exam thing at the end of the chapter and that's the only question I didn't get right so I think it'
20:03:53 <anon136> it's good enough to move on, ill take that advice
20:04:03 <geekosaur> then you can write an expression and, where you want to know what type something in the middle of an expression is, wrap it in ( ...expression here... :: _)
20:04:04 <monochrom> "logical" as in symbolic formal logic, not as in "intuitive makes sense".
20:04:36 <geekosaur> and it will tell you the type it's going to use for _ there
20:05:00 <lyxia> blinkhard: I think what kills performance here is that you go "up and down the stack", by doing work after the recursive call to construct a tuple.
20:05:19 <geekosaur> another trick is that, if you know something is needed but you have no idea what, just write _ for it
20:05:27 <geekosaur> and it'll tell you the type of the thing it wants there
20:05:35 <anon136> geekosaur: haha ok I bet that will come in handy
20:05:36 <geekosaur> > _ + 2
20:05:39 <lambdabot>  error:
20:05:39 <lambdabot>      • Found hole: _ :: a
20:05:39 <lambdabot>        Where: ‘a’ is a rigid type variable bound by
20:06:02 <geekosaur> but in lambdabot you need to be using a /query or /msg session to see the whole message
20:06:08 <geekosaur> @more
20:06:08 <lambdabot> Plugin `more' failed with: Prelude.init: empty list
20:06:20 <anon136> ill do it in ghci
20:06:22 <geekosaur> yehm didn;t think it stuffed the rest in @more :(
20:06:22 <redrapscallion> geekosaur: wow I never knew that feature existed
20:07:36 <geekosaur> and it does often help to just go on and come back later whne you know more about what's going on
20:07:48 <geekosaur> there's a lot going on and its hard to learn all at once
20:08:00 <blinkhard> is this inherent in the use of recursion schemes (hylos), lyxia?
20:08:25 <blinkhard> withdrawn
20:09:20 <anon136> Is the heavy reliance on recursion a handicap with Haskell? When I was studying other languages recursion was usually frowned upon when looping would suffice since it tended to eat up a ton of memory.
20:09:47 <monochrom> Not a handicap. Our compilers are not dumb.
20:09:59 <monochrom> Even Scheme interpreters/compilers are not dumb.
20:10:01 <jle`> anon136: the reason why recursion is 'bad' in other languages is because of how languages implement function calls
20:10:21 <monochrom> Instead, we frown upon dumb interpreters/compilers such as javascript's and python's etc.
20:10:21 <ertes> anon136: recursion is a virtue in a language that properly supports it
20:10:25 <jle`> anon136: recursion is not inherently memory-eaty
20:10:50 <jle`> anon136: it's just that a lot of languages implement function calls that make recursion inadvertently memory-eaty
20:10:52 <monochrom> Look up "tail-call optimization".
20:11:11 <monochrom> And note that most of us don't call it an optimization, we call it "who wouldn't do it?"
20:11:21 <anon136> monochrom: ok I will, thanks.
20:11:22 <jle`> anon136: think about why you assume that recursion eats up memory
20:11:31 <ertes> anon136: most other languages value simple stack traces over better abstraction features
20:11:32 <anon136> because each instance has state
20:11:37 <monochrom> Even gcc -O2 does tail-call optimization.
20:11:40 <jle`> anon136: each instance?
20:11:51 <anon136> like each recursion
20:11:54 <ertes> anon136: (in a recursion-heavy paradigm stack traces aren't as useful, so you would go for other debugging features)
20:12:21 <anon136> I mean it makes sense in my head but im not sure how to put it to words.
20:12:50 <jle`> anon136: yeah, you might be working with some implicit assumptions, too
20:12:58 <jle`> in most languages, function calls are implemented using a call stack
20:13:00 <geekosaur> some of this is that in a functional language, it;s much easier to do tail calls
20:13:19 <monochrom> Every time something make sense in your head, if you bet $1 you're wrong, you would be a millionaire by now.
20:13:21 <jle`> anon136: when you call a new function, it allocates all of the variables the function uses in the call stack
20:13:22 <anon136> jle`: yea that makes sense, and you end up with a very tall stack with some recursion that goes for a long time
20:13:26 <geekosaur> and the way Haskell in particular does evaluation, you aren't actually doing "recursion" or making "calls" as such
20:13:27 <monochrom> And not just you. Basically most people.
20:13:29 <jle`> anon136: right
20:13:34 <jle`> anon136: but, haskell doesn't use a call stack
20:13:43 <jle`> anon136: haskell functions aren't evaluated using call stacks
20:13:49 <jle`> anon136: so, the entire issue is moot
20:13:58 <geekosaur> in fact there's a certain similarity to the other discussion that was going on in here earlier, with respect to trees
20:14:02 <blinkhard> lyxia, is there a recursive call in the f-algebra version?  it seemed to me that the code was constructing a recursive data structure
20:14:03 <anon136> jle`: what does it use in stead?
20:14:14 <lyxia> blinkhard: no, it should be possible to write a fast fib with hylo, see for example https://stackoverflow.com/questions/49135351/deforestation-in-a-hylomorphism I'm still trying to figure out how to apply that technique to fib
20:14:21 <monochrom> But isn't it cute? Every time you think up some idea, hedge against it with a $1-bet-I'm-wrong.  If you are wrong, you win $1; if you are right, you're right.  Either way you win something.
20:14:23 <jle`> the reason recusion is 'bad' in most other languages is because they use call stacks to implement funciton calls, which is inherently bad for recursion unless you use optimization
20:14:31 <lyxia> blinkhard: hylo is the recursive function
20:14:48 <jle`> but ghc haskell doesn't use call stacks, so that's all completely bypassed
20:14:49 <blinkhard> ah yes, fair enough
20:15:01 <ertes> anon136: GHC uses something called a "spineless tagless g-machine", but i wouldn't blame you for not knowing what that is =)
20:15:12 <jle`> anon136: haskell evaluation is basically tree/graph reduction
20:15:15 <blinkhard> (my head was still in my original version which just made it typecheck)
20:15:20 <geekosaur> anon136, it builds a call graph as a tree, then evaluates leaves of the tree as their values are needed. so there's no actual recursion as such, just a "what do I need next". which means there is a "pattern stack" controlling the "what's needed next", but this doesn't behave like a call stack
20:15:28 <ertes> anon136: in any case tail calls are free in haskell, and not as an optimisation, but as a fundamental feature of how evaluation works
20:15:32 <geekosaur> it too can overflow, but under different circumstances than recursion
20:15:32 <anon136> ertes: sounds like something in hillary clintons closet
20:15:44 <jle`> anon136: evaluating a haskell expression is reducing a tree/graph node-by-node
20:15:54 <monochrom> Haskell spends much memory iff you ask for it or you misuse laziness.
20:15:58 <jmcarthur> monochrom: I have a circle of friends where bets like that are commonplace.
20:16:39 <jle`> anon136: but, the main deal is, the reason recursion is 'bad' in most languages is because that's how call stacks work normally, and haskell doesn't have a call stack, so...there's no reason to fear recursion
20:17:00 <jle`> most CS students are indoctrinated immediately with 'recursion is bad'
20:17:00 <anon136> haha you guys are awesome but I feel it would be unfair for me to ask you to explain all this stuff in enough detail for me to really wrap my head around it
20:17:08 <redrapscallion> anon136: also, since haskell is lazy, nothing gets evaluated until it needs to get evaluated (unless you make it strict)
20:17:15 <anon136> I would owe you tuition.
20:17:31 <kennp> jle`: no call stack? even for the main function which has side effects (i.e. IO) ?
20:17:40 <ertes> anon136: the technical explanation wouldn't be too helpful at this point anyway…  but there is a simple enough high-level explanation once you understand the basics of haskell
20:17:42 <jle`> kennp: main is not a function
20:17:52 <jle`> so why would it have a call stack
20:17:54 <anon136> I'm definitely going to stick a pin in all of it though and come back and figure it all out someday. once i finish this book at minimum.
20:17:57 <ertes> anon136: so this would be the time where you get intrigued and start doing CIS 194 =)
20:17:59 <ertes> @where cis194
20:18:00 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
20:18:16 <anon136> Thanks everyone for the assists.
20:18:50 <monochrom> I'm really tired of "recursion consumes space".  I mean sure non-tail recursion consumes space.  But gcc -O2 has been doing TCO for 20 years so come on why are people still making 40-year-obsolete assertions
20:19:10 <jle`> monochrom: it's the monkey-and-ladder situation
20:19:28 <monochrom> It's like saying "you need to make punch cards to use a computer"
20:19:36 <ertes> monochrom: because they haven't seen functional languages yet…  you can't really blame them, because school has taught them that imperative OOP is the way to go
20:19:38 <anon136> In my case it's just reading bad information gets repeated.
20:19:53 <jle`> ertes: monochrom's point is that recursion doesn't consume space even in imperative oop languages
20:19:54 <jmcarthur> Non-tail recursion is the more difficult thing to implement, even. Tail calls are just jumps.
20:20:03 <kennp> jle`: o.O.... er.... I suppose u mean compiled Haskell does not need the kind of call stack glue, even if the language looks like function calls (recursive or not)?
20:20:24 <geekosaur> no call stack
20:20:35 <monochrom> Not even interpreted Haskell.
20:20:41 <jle`> kennp: take a moment to question why you think a call stack is useful or needed for anything
20:20:49 <jle`> kennp: do you think it is some fundamental programming concept
20:20:50 <ertes> jle`: it does in the ones people use:  python, ruby, even the supposedly FP-friendly javascript (ECMA5, the one that people actually use)
20:21:12 <redrapscallion> jle`: hmm, doesn't a call stack allow you to get a lot more debugging info when the program crashes?
20:21:21 <jle`> ertes: mhm, i can't claim to be in perfect agreement with the statement
20:22:13 <iqubic> What is a paramorphism? I understand that the least out of the main recursion schemes.
20:22:15 <sqooq> fishythefish: in the step in which the Nothings are pruned and you only take the first Just, is there any possible way to keep the other Justs?
20:22:20 <kennp> I suppose if you write in assembly, no such thing as auto generated call stack stub; even if you make the distinction between register and memory
20:22:24 <monochrom> To be sure some kind of stack or equivalent is required.  The bottomline is that you need something for the continuation, and the continuation can grow (depending on the nature of your code).
20:22:40 <jmcarthur> I've always felt like it's a bit disingenuous to say Haskell has no call stack. It does, and it even works basically the same way as in other languages. It's just that its use appears to differ because thunks are everywhere.
20:22:46 <geekosaur> redrapscallion, https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.11.0.0/GHC-Stack.html
20:22:46 <monochrom> But it doesn't have to be Peter Naur's call stack.
20:22:49 <sqooq> I tried doing it myself but the types are tricky because the function itself must return a maybe single list of nodes
20:22:56 <ertes> jle`: python values call stacks too much, and JS has to force proper tail calls onto implementors per standard, because for some unfathomable reason most interpreters still suck…  and who knows when it will actually be implemented
20:23:02 <ertes> err
20:23:07 <ertes> s/call stacks/stack traces/
20:23:08 <sqooq> if I change the type then I have to like do some fancy concatting and stuff, I can't get it to work
20:23:14 <fishythefish> sqooq: sure, use catMaybes, or just filter isJust
20:23:15 <jle`> i'd call what ghc haskell uses as an evaluation stack
20:23:19 <jle`> it's not associated with function calls
20:23:25 <jle`> it's associated with reduction/evaluation
20:23:34 <jmcarthur> It so happens most of the function calls are just "enter thunk".
20:23:42 <fishythefish> sqooq: but if you want to track multiple paths, it makes more sense to use [[Node]] rather than [Maybe [Node]]
20:23:51 <jmcarthur> If you write OCaml and use lazy everywhere you end up with a stack that looks similar.
20:24:02 <monochrom> But tail calls don't need to grow the continuation. This is Compiler Writing 101.
20:24:14 <monochrom> So basically Guido fails that course.
20:24:15 <jle`> it's not useful to think of haskell as using a call stack because it isn't really linked to anything being 'called'
20:24:18 <lyxia> blinkhard: how does the performance change if nthFibAlg takes an Int argument instead
20:24:48 <sqooq> fishythefish: also looking at your function, there's no nothing that's returned, you prune out the options that were already visited from the getgo
20:24:53 <sqooq> I think the Maybe is redundant
20:25:01 <jle`> there is a 'stack', but it's filled by evaluations, not by function calls
20:25:02 <kennp> so anyone can think of a way to make Haskell croak on "stack overflow"? o.O, guess not.
20:25:21 <iqubic> Sure.
20:25:23 <kennp> I remember the days I had to tune the JVM stack size all the time
20:25:32 <fishythefish> iqubic: a paramorphism is like a catamorphism, but in addition to the result of folding the subobject, you get access to the subobject itself
20:25:38 <redrapscallion> kennp: it's easy to make Haskell stack overflow if you don't use tail call optimization
20:25:46 <jle`> haskell's evaluation stack can "overflow", but the evaluation stack lives with the rest of the normal heap
20:25:52 <fishythefish> sqooq: the Maybe is not redundant
20:25:53 <iqubic> fishythefish: Can I get an example of that?
20:25:54 <jle`> so it's really a heap overflow
20:26:02 <fishythefish> > listToMaybe . catMaybes [Nothing, Nothing]
20:26:04 <lambdabot>  error:
20:26:04 <lambdabot>      • Couldn't match expected type ‘a -> [a1]’ with actual type ‘[a0]’
20:26:04 <lambdabot>      • Possible cause: ‘catMaybes’ is applied to too many arguments
20:26:11 <fishythefish> > listToMaybe . catMaybes $ [Nothing, Nothing]
20:26:11 <kennp> =)
20:26:13 <lambdabot>  Nothing
20:26:15 <monochrom> I think Graham Hutton's way of calculating a compiler and calculating an iterative interpreter gets you TCO for free, you don't even do anything special.
20:26:21 <iqubic> :t listToMaybe
20:26:22 <lambdabot> [a] -> Maybe a
20:26:27 <jle`> kennp: in other languages, stack space and heap space are considered separate things
20:26:29 <jmcarthur> kennp: You have to pass a flag to bound the stack size because nowadays the stack can grow dynamically, but you can use a lot of stack by making a long chain of unevaluated thunks and then evaluating it all at once.
20:26:39 <iqubic> :t catMaybes
20:26:40 <lambdabot> [Maybe a] -> [a]
20:26:48 <iqubic> I see how that works.
20:26:48 <ertes> for some reason in the context of haskell i don't like to use the term "call" at all
20:27:06 <ertes> i don't associate function application with "something happening"
20:27:25 <monochrom> Yeah sqrt 4 equals 2.  Equals.  What return? :)
20:27:27 <jle`> kennp: haskell 'evaluation' and reduction happens in the normal stack, so a 'stack overflow' is really just a 'heap overflow'
20:27:28 <jmcarthur> ertes: This is what jle` was trying to impress upon me a a minute ago. I think this is the right way to think about Haskell.
20:27:40 <jle`> s/the normal stack/the normal heap
20:27:42 <kennp> jle`: =)
20:27:44 <fishythefish> let suffices :: [a] -> [[a]]; suffices = para (\_ xs acc -> xs : acc) []
20:27:45 <jmcarthur> I just don't want to lean too heavily on it when talking about whether there is a call stack at all.
20:27:52 <fishythefish> iqubic: ^
20:27:57 <mniip> haskell does have stack overflosw though
20:27:58 <sqooq> fishythefish: but Nothing is never returned, right?
20:28:03 <sqooq> It's always "Just" something
20:28:13 <sqooq> so we're just working with lists of values here
20:28:19 <jmcarthur> mniip: Not really anymore. By default you can just cause the stack to use up all your memory.
20:28:33 <fishythefish> sqooq: if unvisited is empty then you get
20:28:40 <fishythefish> > listToMaybe . catMaybes $ []
20:28:42 <lambdabot>  Nothing
20:28:43 <jle`> "evaluation stack" and heap aren't fundamentally separated in ghc haskell like they are in languages with call stacks
20:28:46 <jle`> from what i remember
20:28:52 <monochrom> No I think the default is "stack is such-and-such percent of RAM".
20:28:58 <iqubic> fishythefish: What does suffices do?
20:29:04 <ertes> ironically i've been using GHC for more than ten years now, and i still haven't quite figured out when i get a stack overflow as opposed to a heap overflow =)
20:29:06 <monochrom> err, s/ is / is bounded by /
20:29:08 <mniip> jmcarthur, there's a stack limit RTS parameter
20:29:10 <fishythefish> iqubic: gives you the proper suffices of a list
20:29:29 <sqooq> fishythefish: agh I see
20:29:36 <jmcarthur> mniip: yup
20:29:40 <monochrom> But the stack is a heap object.
20:29:54 <kennp> monochrom: so that stack is global?
20:29:56 <monochrom> (and is growable)
20:30:01 <sqooq> so back to my original question, anyway to make this return all the result
20:30:02 <sqooq> so back to my original question, anyway to make this return all the results
20:30:04 <ertes> but i'm not even sure i care, because it basically doesn't happen to me anymore
20:30:10 <jmcarthur> jle`: The fact that the stack is on the heap doesn't really have anything to do with this way of thinking about it as not a call stack, though.
20:30:10 <jle`> disclaimer, most of my knowledge about anything comes from this series of blog posts
20:30:10 <monochrom> No, every thread gets its own stack, too.
20:30:12 <jle`> http://blog.ezyang.com/2011/04/the-haskell-heap/
20:30:27 <iqubic> How does that para thing even work.
20:30:27 <fishythefish> sqooq: didn't I provide a paste that did that already?
20:30:41 <jmcarthur> jle`: It's on the heap so that it can start small and grow as necessary, to keep threads lightweight.
20:30:41 <lyxia> blinkhard: actually the zip test is just measuring list lookups because the list is a constant that doesn't get reevaluated
20:30:51 <fishythefish> sqooq: http://lpaste.net/364991
20:31:00 <monochrom> But I write single-thread programs mostly, so it's usually "the" stack.
20:31:25 <jle`> jmcarthur: that's fair, i should probably phrase all of this differently
20:31:26 <fishythefish> iqubic: https://stackoverflow.com/a/13317563 has a decent explanation
20:31:46 <sqooq> fishythefish: no i mean at the pruning level
20:31:48 <blinkhard> lyxia, i see, i have found it is hard to craft a good criterion benchmark.  (conforming type signatures didn't move the needle)
20:31:56 <sqooq> right now what happens is that if a solution is found, the rest are ignored for that n
20:32:05 <sqooq> but it's possible that the same starting n, can have multiple solutions
20:32:11 <ertes> iqubic: listPara :: ([a] -> a -> r -> r) -> r -> [a] -> r  -- get not only the head element, but also the remainder of the list
20:32:12 <monochrom> Anyway this is why I prefer "continuation stack".
20:32:29 <sqooq> fishythefish: wait
20:32:34 <sqooq> I haven't seen this paste before
20:32:37 <sqooq> you changed it!
20:32:45 <ertes> iqubic: paramorphisms are a generalisation of this to arbitrary algebraic data types
20:32:50 <fishythefish> sqooq: I did not
20:32:54 <monochrom> Although, this smells like a tactic of "avoid pointless debates by switching to a word that nobody understands" :)
20:33:08 <fishythefish> sqooq: you're thinking of http://lpaste.net/364988
20:33:35 <fishythefish> sqooq: I did change that one at some point to support trying all starting nodes rather than making you specify one
20:33:49 <sqooq> well see, you're not using maybe!
20:33:54 <fishythefish> I know?
20:34:00 <sqooq> i thought you said
20:34:08 <fishythefish> pretty sure if you check the logs you'll see that
20:34:16 <sqooq> o i guess all you said is "it's not redundant"
20:34:28 <fishythefish> [19:12:20]  <fishythefish>	sqooq: here it is with all paths: http://lpaste.net/364991
20:35:02 <mniip> jmcarthur, also if I'm not mistaken ffi in-out calls do consume "actual stack" space :P
20:35:20 <sqooq> fishythefish: is concat.map different from concatMap
20:35:29 <sqooq> because I SWEAR I just tried that and it didn't work
20:35:33 <sqooq> I changed the type and everything
20:35:37 <blinkhard> lyxia, whoa. http://lpaste.net/364992
20:35:41 <dsal> :t concat.map
20:35:43 <lambdabot> Foldable ((->) [a1]) => (a1 -> a2) -> [a2]
20:35:43 <dsal> :t concatMap
20:35:45 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
20:35:45 <mniip> sqooq, yes
20:35:45 <fishythefish> sqooq: concat'ing the result of map is the same as just using concatMap
20:35:53 <sqooq> and did exactly as you did with the first condition of if statement
20:35:57 <mniip> :t (concat .) . map
20:35:58 <lambdabot> (a1 -> [a2]) -> [a1] -> [a2]
20:36:00 <fishythefish> but it's not the same as concat . map
20:36:01 <sqooq> [node:prefix]
20:36:19 <sqooq> :thinking:
20:36:30 <blinkhard> subtle change to nthFibZip to account for your point that this was a criterion/memoization issue
20:36:33 <sqooq> concating the result of map is the same as using concatMap, but it's not the same as concat.map
20:36:46 <sqooq> why does this seem like a contradiction?
20:36:49 <fishythefish> concatMap f = concat . map f, but that's not the same as saying concatMap = concat . map
20:37:23 <monochrom> yeah, concat . (map f)  /=  (concat . map) f
20:37:24 <geekosaur> sqooq: (concat . map) f vs. concat . (map f)
20:37:40 <ertes> sqooq: (concat . map) f xs = concat (map f) xs
20:37:45 <monochrom> Intuition and word mincing always lead to contradictions.
20:37:58 <lyxia> blinkhard: oh yes that's one way to fix that
20:38:11 <geekosaur> natural language isn't very good at nesting
20:38:30 <lyxia> blinkhard: another is to pass -fno-full-laziness to disable the offending optimization (but of course that may break other things)
20:38:32 <ertes> it's also not very composable =)
20:39:03 <monochrom> Example of word mincing: "The empty list is empty. The empty string is empty.  Therefore empty list equals empty string."
20:39:06 <ertes> (except in some languages in the sense of rindfleischetikettierungsüberwachungsaufgabenübertragungsgesetz)
20:39:19 <monochrom> Actually reasoning example from my students.
20:39:39 <sqooq> ok I see now
20:39:39 <fishythefish> monochrom: you need to teach them about transitivity
20:39:40 <sqooq> thanks
20:39:42 <sqooq> dang I was so close
20:39:46 <sqooq> I had the right idea just did it wrong
20:39:52 <fishythefish> the correct conclusion is "empty list *is* empty string"
20:39:57 <monochrom> People complain that symbolic logic is a meaningless symbol game.
20:40:16 <fishythefish> i love meaningless symbol games
20:40:25 <fishythefish> when you've failed to grok your math classes, they let you get the right answers anyway
20:40:34 <ertes> @let please = id
20:40:35 <lambdabot>  Defined.
20:40:39 <shachaf> @quote formalist
20:40:40 <lambdabot> SaulGorn says: A formalist is one who cannot understand a theory unless it is meaningless.
20:40:42 <monochrom> But I look at how people play that game wiht oh-so-meaningful words I just illustrated, and I prefer the meaningless symbol game.
20:40:54 <monochrom> At least the symbol game actually have predictive power.
20:41:15 <monochrom> Natural language oh-so-meaningful word game gives you religions only.
20:41:46 <monochrom> And yes what people consider "meaningful" is stiil no less game than symbolic logic.
20:42:07 <freeman42x]NixOS> How to compare for equality Data.Text.Internal.Lazy.Text and [Char]? https://stackoverflow.com/q/49912333/750216
20:42:34 <blinkhard> i'd just forgot the ghc command, lyxia.  using it instead of my version above slows everything down and actually flips the relative order of the results
20:42:38 <Cale> You need to use pack from Data.Text.Lazy
20:43:27 <freeman42x]NixOS> Cale, see the question, I tried that, still different types
20:43:33 <monochrom> > please sin (pi/6)
20:43:35 <lambdabot>  0.49999999999999994
20:43:45 <ertes> so…  as for why i actually switched to the #haskell buffer half an hour ago: can i rely on let-floating for monomorphic values in a 'where' block of a top-level function, as long as i don't refer to any application-specific values?
20:44:22 <Cale> freeman42x]NixOS: It seems you used Data.Text.pack
20:44:37 <Cale> At least, that's what I gather from the error message you gave.
20:44:47 <Cale> It's hard to tell because you used it unqualified
20:44:59 <ertes> Cale, freeman42x]NixOS: you should actually prefer to convert the Text value to String in this case
20:45:17 <sqooq> fishythefish: thanks btw
20:45:21 <sqooq> <3
20:46:14 <fishythefish> no problem
20:46:32 <lyxia> blinkhard: http://lpaste.net/364994 here's another algebra and a handwritten function for two more benchmarks
20:47:09 * hackage simpleconfig 0.0.9 - Short description of your package  http://hackage.haskell.org/package/simpleconfig-0.0.9 (AlexeyKotlyarov)
20:47:40 <blinkhard> thank you for this and your many helpful comments (as always!), lyxia. i am tuckered but will study what you sent. nite
20:47:50 <lyxia> nite
20:49:06 <freeman42x]NixOS> Cale, I used Data.Text.Lazy . Added to the question
20:49:08 <ertes> so that's what simpleconfig does…  i was wondering
20:49:23 <geekosaur> heh
20:49:51 <ertes> apparently it has done that since the first release in january
20:50:14 <iqubic> I think it's a misconfigured cabal file.
20:50:33 <Cale> freeman42x]NixOS: Oh, then try the other?
20:50:47 <freeman42x]NixOS> Cale, lol xD
20:52:24 <freeman42x]NixOS> ertes, the question is only asking about equality of those 2 types. IMO. I do not understand why an Internal type is being used by esqueleto
20:52:43 <Cale> freeman42x]NixOS: It's only reported that way because that's where the type is defined
20:52:57 <Cale> It gets re-exported by the Data.Text.Lazy module
20:53:35 <freeman42x]NixOS> Cale, oh, I see
20:54:16 <ertes> freeman42x]NixOS: i didn't actually look at the code, i was just making a minor note about comparing (xs :: Text) to (ys :: String)…  it requires conversion, and unless you need the Text version of ys converting xs to String is much cheaper and potentially even free
20:54:50 <Cale> Actually, is the thing you're dealing with even a String for sure?
20:55:55 <freeman42x]NixOS> Cale, one of them is a [Char] for sure
20:59:29 <freeman42x]NixOS> I tried [Value (fromStrict $ pack currentWindowTitle)] == previousLogItem but it still gives same error: Couldn't match type ‘Data.Text.Internal.Lazy.Text’ with ‘Text’
20:59:52 <freeman42x]NixOS> the value on the left should have been converted to Lazy Text
21:00:19 <Cale> freeman42x]NixOS: You're trying to convert it to a lazy text and probably succeeding, but maybe you wanted to convert it to a strict text?
21:00:49 <freeman42x]NixOS> ehm, the thing on the right is lazy
21:01:10 <Cale> It would help if we knew the types of anything you were using :)
21:02:12 <freeman42x]NixOS> sorry, not used to reporting Haskell code issues
21:02:23 <freeman42x]NixOS> I did mention that the type on the left is [Char]
21:02:45 <freeman42x]NixOS> and the one on the right is what the error says
21:02:53 <freeman42x]NixOS> Data.Text.Internal.Lazy.Text
21:03:12 <freeman42x]NixOS> but apparently you are right, converting the other way around worked
21:08:35 <freeman42x]NixOS> sorry about that, the error was very confusing
21:17:09 * hackage aeson-generic-compat 0.0.1.2 - Compatible generic class names of Aeson  http://hackage.haskell.org/package/aeson-generic-compat-0.0.1.2 (KeiHibino)
22:02:40 <sajan12122> !bin 517805
22:02:56 <sajan12122> !chk 4342562950488229 0321 615
22:04:31 --- mode: ChanServ set +o glguy
22:04:33 --- mode: glguy set +q *!*@gateway/web/freenode/ip.103.255.5.86
22:08:25 <IMRAN4> !bin 517805
22:09:14 <IMRAN4> hello all friend
22:09:20 <IMRAN4> hi
22:09:49 <aka_> hi
22:10:50 <aka_> Is there a Haskell implementation of Futamura projections? Say I implemented an interpreter in haskell, is there lib I can use to generate a compiler?
22:12:04 --- mode: glguy set +q *!*@103.255.5.86
22:15:27 <Cale> glguy: any idea what that shenanigans is?
22:16:38 <fishythefish> aka_: I've seen type-level proofs of the projections, but I've never seen a lib for implementing them
22:17:05 <fishythefish> also, I never fail to read that as "Futurama projections"
22:17:18 <geekosaur> probably the same bot that gets the ''ciao' '!list' stuff every so often
22:17:31 <geekosaur> that nobody's been able to figure out because it doesn't respond to us
22:17:45 <geekosaur> (warez bot, almost certainly)
22:19:49 <aka_> fishythefish: I just saw this article https://gist.github.com/tomykaira/3159910 mentioning PyPy and RPython doing that. I was wondering if there is anything similar in Haskell.
22:38:09 * hackage text-ldap 0.1.1.12 - Parser and Printer for LDAP text data stream  http://hackage.haskell.org/package/text-ldap-0.1.1.12 (KeiHibino)
22:40:51 <aka_> Does GHC provide API to output the binary of a runtime function?
22:41:42 <edwardk> aka_: no
22:46:32 --- mode: glguy set -qqo *!*@103.255.5.86 *!*@gateway/web/freenode/ip.103.255.5.86 glguy
22:55:24 <dminuoso> Can a function type A -> B in Haskell can be considered Hom(A, B) in Hask?
22:57:33 <fishythefish> insofar as Hask can be considered a category
22:58:12 <fishythefish> strictly speaking, A -> B the type would be an object of the category
22:58:23 <fishythefish> its set of values would be Hom(A, B)
22:58:33 <fishythefish> (or is Hask enriched over itself?)
23:06:22 <dminuoso> fishythefish: Alright. Thanks.
23:11:12 <dminuoso> fishythefish: Uh.. so the Hom functor is just Reader? :o
23:11:29 <fishythefish> yup
23:26:06 <dminuoso> fishythefish: So many things are falling into places, this is a warm fuzzy feeling. :)
23:26:27 <fishythefish> :)
23:30:37 <dminuoso> If Hask(a, -) is just (Reader a), then I guess Hask(-, a) is the Contravariant (Op a), and Hask(-, -) the Profunctor (->) ?
23:33:05 <fishythefish> mhm
23:40:28 <dminuoso> Given: instance Functor (Reader a) where fmap f = (f .); instance Contravariant (Op a) where contramap f = (. f); instance Profunctor (->) where dimap l f r = r . f . l; lmap f = (f .); rmap f = (. f);
23:40:38 <dminuoso> Kind of looks right
23:41:16 <dminuoso> think I got the arguments of dimap from there. should be `dimap l r f = r . f . l` I think
23:43:27 <fishythefish> yup
23:44:45 <fishythefish> dimap specializes to dimap :: (a -> b) -> (c -> d) -> (b -> c) -> (a -> d), so with more suggestive names:
23:45:09 <fishythefish> dimap ab cd bc = cd . bc . ab
23:45:23 <dminuoso> ah that looks better indeed
23:45:33 <dminuoso> Kind of hoped for (. bc .) but ah well :D
23:45:49 <fishythefish> heh, that notation reflects the intuition at least
23:47:13 <dminuoso> @pl dimap bc ab cd = cd . bc . ab
23:47:13 <lambdabot> dimap = (flip (.) .) . (.)
23:47:21 <dminuoso> Oh yes. That's more like it!
23:48:46 <fishythefish> those parameters look out of order
23:49:19 <dminuoso> :k Profunctor
23:49:20 <lambdabot> (* -> * -> *) -> Constraint
23:49:31 <fishythefish> @pl dimap ab cd bc = cd . bc . ab
23:49:31 <lambdabot> dimap = flip ((.) . (.)) . flip (.)
23:49:41 <Ariakenom> maybe it would be better with a flip (.) operator?
23:50:19 <dminuoso> @pl dimap ab cd = cd . bc . ab
23:50:19 <lambdabot> dimap = flip (.) . (bc .)
23:52:21 <fishythefish> alternative view: rmap = (.) (from Reader), and lmap = flip (.) (from Op), and we must have dimap f g = lmap f . rmap g, so dimap f g = (. f) . (g .)
23:53:41 <dminuoso> oh yeah thats pretty cool actually. Though I personally think I prefer `rmap f = (f .)` and `lmap g = (. g)`
23:55:41 <statusfailed> Are there any neat lensy ways to do a sum over a field? e.g.: f [("a", 1), ("b", 1), ("c", 1)] -> [("a", 1), ("b",2), ("c",3)]
