00:36:56 <dpyro> how should I go about doing a string valued enumeration? i see stuff like deriving Enum or Data, Typed but I dont know which to use and how
00:39:08 <merijn> dpyro: What does "string valued enumeration" mean?
00:39:37 <dpyro> data State = Buy | Sell to represent "state": "buy" or "sell" in JSON
00:40:01 <merijn> dpyro: You probably wanna have a look at aeson
00:40:28 <dpyro> i am using that now, i'm just wondering if there is haskell standard way to do this
00:40:44 <dminuoso> Mmm, what is the purpose of `class Typeable a => Data a` ?
00:41:43 <merijn> dminuoso: "I wanna write Python in Haskell"
00:42:11 <merijn> dminuoso: I'm only half joking :p
00:43:43 * hackage haskell-gi 0.21.1 - Generate Haskell bindings for GObject Introspection capable libraries  http://hackage.haskell.org/package/haskell-gi-0.21.1 (inaki)
00:44:02 * dminuoso sighs as hackage is again slow as heck, giving random 502..
00:45:17 <merijn> dminuoso: hvr is looking at it in #haskell-infrastructure if you have time to troubleshoot where the 502's are coming from (i.e. CDN or origin machine)
00:45:40 <tsahyt> is there some commonly accepted way to extend compiled haskell code with more haskell code? i.e. some kind of plugin architecture?
00:46:12 <dpyro> like a category?
00:46:22 <dpyro> from obj-c/swift?
00:46:45 <lemmih> tsahyt: There's the plugins package but I don't think it's a good idea to use it.
00:47:12 <liste> also hint for interpreting Haskell sources at runtime
00:47:17 <liste> @hackage hint
00:47:17 <lambdabot> http://hackage.haskell.org/package/hint
00:47:30 <merijn> tsahyt: dons' thesis is about writing plugins for Haskell
00:47:40 <dminuoso> dpyro: What do you mean?
00:47:57 <tsahyt> I suppose hint could work for a decent amount of things. but it being interpreted comes with some drawbacks I suppose, e.g. lack of strictness analysis
00:47:59 <robstr> Morning, I struggle moving from IO to different monad, https://gist.github.com/rsoeldner/445845265399aaf63fa5b6c57585bcfb This does not compile, If i got it right, because of the `m` in where, do i need forall ? (hope this makes sense :P)
00:48:30 <merijn> robstr: The 'm' in the where clause is *not* the same as the one on line 1
00:48:46 <robstr> merijn: yea but how can i say this, with forall ?
00:48:48 <dminuoso> merijn: Very well. Is the amount of 404s a known issue?
00:48:48 <tsahyt> merijn: is that thesis finished and available somewhere?
00:48:55 <merijn> robstr: You'll want to enable "ScopedTypeVariables" to make that work, consult the GHC manual on the extension
00:49:08 <merijn> tsahyt: Well, the plugins library covers it
00:49:22 <merijn> dminuoso: I dunno, I haven't been online since friday :p
00:49:44 <tsahyt> oh
00:49:58 <merijn> tsahyt: Thesis is here: https://pdfs.semanticscholar.org/92f6/f7b25a91eba0fb7ac981a9a3e7f8ac8155aa.pdf
00:50:26 <robstr> merijn: thank you
00:53:57 <tsahyt> merijn: thanks!
00:54:09 * hackage jwt 0.8.0 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.8.0 (StefanSaasen)
00:54:09 <jchia> Question about NUMA: I really want a certain thread to stay on a certain CPU core when running a certain "IO ()" and use memory from a certain memory node (accessing memory from a non-local node is expensive). Is there anything in GHC or the RTS that allows me to do this? If I just use a green thread, I think the RTS will just schedule it on different cores and spoil the memory access.
00:55:01 <merijn> jchia: I don't think the RTS currently has that, but it would be super cool if you hacked on that!
00:55:39 * hackage geodetics 0.0.5 - Terrestrial coordinate systems and geodetic calculations.  http://hackage.haskell.org/package/geodetics-0.0.5 (PaulJohnson)
00:56:47 <merijn> jchia: You might wanna look into if using a bound thread together with an FFI call to the linux thread pinning API will work for you
00:57:07 <merijn> jchia: But I dunno enough details of how bound threads and OS thread play together
00:57:28 <jchia> merijn: I think I could even go further and fork the process.
00:57:56 <Ariakenom> hm what about forkOn?
00:58:00 <merijn> jchia: You could, but I don't think it'd be necessary
00:58:46 <merijn> Ariakenom: forkOn doesn't specify the resulting thread is a bound one, so it might get migrated
00:59:22 <Ariakenom> It will not get migrated between capabilities.
00:59:26 <lemmih> jchia: the -qa RTS flag pins OS threads to CPU cores.
00:59:48 <Ariakenom> Which, iiuc, implies it won't be moved to other cores.
01:00:15 <jchia> merijn: I think memory placement-wise, it'll be even cleaner to fork the process. Memory that has already been allocated already have a designated memory node, so you can't help accessing it remotely if the thread is on a different node. Different bits of existing data just happens to be on different memory nodes. Now, if I fork the process and package the data the child needs to do its processing, then the child can just use the local memory node for all its
01:00:40 <jchia> lemmih: I think I could use -qa to restrict the RTS to one node, but that means wasting half the machine.
01:00:50 <jchia> (I have a two-node NUMA machine)
01:02:07 <lemmih> jchia: You sure? I thought it just pinned each HEC to a core.
01:03:04 <jchia> lemmih: It says '--numa[=<node_mask>]', so it sounds like a designation of which nodes the RTS is allowed to use.
01:04:11 <jchia> lemmih: OK, that's a different option. Not sure what exactly '-qa' does. Description is very brief. Do you know?
01:04:39 <lemmih> jchia: Pretty sure it just pins each HEC to a specific core.
01:04:48 <merijn> jchia: You probably want #ghc and/or the #ghc-dev mailing list :)
01:05:01 <merijn> jchia: Also, please contribute a doc patch explaining things after you figure it out ;)
01:06:28 <Ariakenom> afaik forkOn gives you a lightweight thread that won't move.
01:07:09 <Ariakenom> Oh no, capabilities can move. so yeah -qa for control.
01:08:11 <Ariakenom> Then they can't (if pinning supported by OS).
01:08:14 <lemmih> jchia: Hm, maybe that flag was replaced by --numa in newer ghcs.
01:12:13 <sophiag> if i'm only using GeneralizedNewtypeDeriving for stock instances, e.g. Eq, would DerivingStrategies actually do anything differently? i've heard people refer to the former as "unsafe" but assume they must be referring to instances like Foldable or Functor
01:12:46 <merijn> sophiag: You can abuse GND to do bad things, but it requires you actively trying to break shit
01:13:25 <sophiag> merijn: i'm not sure i even know where the line is anymore :)
01:15:14 <merijn> sophiag: See for example: https://stackoverflow.com/questions/12665779/even-more-generalized-newtype-deriving
01:15:22 <sophiag> anyway, i assume my assumption is correct as it's almost tautological given how DerivingStrategies works and i also can't imagine any malformed instances in these cases. the ones i've seen to make that claim about GND were ones i would assume could at least be, well lousy, if not unsafe
01:15:37 <cocreature> sophiag: note that enabling GeneralizedNewtypeDeriving won’t change how stock instances are derived
01:17:16 <tdammers> especially Show, which is inconvenient occasionally
01:17:23 <sophiag> cocreature: i meant if i'm only using it for stock instances then how i'd use DerivingStrategies wouldn't change anything at all
01:17:58 <sophiag> and i'm actually not even using it for Show or Read! although that's perhaps because i am doing some weird things there :p
01:18:22 <sophiag> merijn: p sure that's very similar to the example i'm thinking of (also from Philip on SO)
01:18:50 <sophiag> more unsafe as in "why would you have thought this would be okay?"
01:19:10 * hackage immortal 0.3 - Spawn threads that never die (unless told to do so)  http://hackage.haskell.org/package/immortal-0.3 (RomanCheplyaka)
01:21:08 <superlinux> hello. why this expression is not being solved? 153.5689-truncate(153.5689)  . I have a type mismatch
01:23:57 <dminuoso> superlinux: can you show us the concrete error message you are getting?
01:24:14 <tsahyt> > 153.5689 - truncate 153.5689
01:24:15 <sophiag> superlinux: truncate returns an Integral. it seems you want `round`
01:24:17 <lambdabot>  error:
01:24:17 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M281931186192...
01:24:17 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
01:24:20 <tsahyt> oh
01:24:36 <sophiag> or floor/ceiling depending
01:25:10 <tsahyt> floor would be the closest to truncate, except for the type
01:25:12 <dminuoso> sophiag: That won't change a bit. They all have the same type signature.
01:25:39 <sophiag> dminuoso: i thought they were reversed
01:25:44 <dminuoso> :t round
01:25:45 <lambdabot> (Integral b, RealFrac a) => a -> b
01:25:46 <dminuoso> :t truncate
01:25:47 <lambdabot> (Integral b, RealFrac a) => a -> b
01:25:51 <dminuoso> :t ceiling
01:25:52 <lambdabot> (Integral b, RealFrac a) => a -> b
01:25:55 <tsahyt> > (153.5689 :: Double) - fromIntegral (truncate 153.5689)
01:25:57 <lambdabot>  0.5689000000000135
01:26:31 <tsahyt> the annotation is probably not needed because of defaulting. I suppose the error above was something else
01:26:47 <sophiag> dminuous: sorry, confused for a sec
01:27:59 <Ariakenom> > snd (properFraction 153.5689)
01:28:01 <lambdabot>  0.5689000000000135
01:28:14 <tsahyt> well that's a good thing to know about
01:28:36 <superlinux> yes! I saw the 135 which I did not mention. I know it's CPU registers thingy
01:29:11 <superlinux> I mean I did not mention them in the expression above
01:29:38 <sophiag> ah, `snd . decodeFloat` was what i was thinking of
01:30:21 <Wizek> lemmih: hey, are you around today as well?
01:31:09 * hackage th-reify-compat 0.0.1.4 - Compatibility for the result type of TH reify  http://hackage.haskell.org/package/th-reify-compat-0.0.1.4 (KeiHibino)
01:31:23 <merijn> superlinux: See: http://0.30000000000000004.com/
01:32:24 <Axman6> that's awesome
01:32:36 <superlinux> merijn, SWeeeT! awsome page. :)
01:32:42 <superlinux> I am going to share it
01:32:49 <sophiag> thanks ieee 754 :p
01:33:23 <superlinux> I know basiclly about the issue from the past. but this page says it all
01:33:50 <lemmih> Wizek: Yeah.
01:33:55 <merijn> If you want arbitrary precision, there's Rational but it'll be a lot slwoer
01:34:44 <Wizek> lemmih: great! So you asked yesterday why not do (c :: *) here: https://gist.github.com/Wizek/08f44a19b7b4f596d31b7c0038056df8
01:36:02 <Wizek> lemmih: so, maybe that could make sense, but my reasoning for choosing `c :: * -> * -> *` was so that I can express polymorphic datatypes that are parameterised on the maplike type constructor. Not sure if I can do that with `*`
01:36:37 <lemmih> Wizek: Sure you can. Just like your first class with the functional dependencies.
01:37:09 * hackage th-data-compat 0.0.2.6 - Compatibility for data definition template of TH  http://hackage.haskell.org/package/th-data-compat-0.0.2.6 (KeiHibino)
01:37:40 <Wizek> lemmih: hmm, so using 3 class parameters then?
01:37:56 <stiell> In Intero, what is the annoying thing that just displays "foobar :: forall t. t" at the bottom line, and how do I disable it? It seems to be slow and misbehaving, hindering other interactions with Emacs while it's thrashing about.
01:38:02 <lemmih> Wizek: No, just one.
01:38:14 <dminuoso> stiell: Sometimes killing intero helps.
01:38:37 <amosbird> Hello
01:38:40 <dminuoso> stiell: Ive been personally super annoyed by the frequency of incorrectness. Atom with ghc-mod felt far more reliable.
01:38:45 <Wizek> lemmih: not sure I follow how. Could you show me?
01:38:46 <dminuoso> Maybe ghc-mod/ghcid are better backends
01:38:47 <amosbird> how do you think of clojure?
01:39:17 <Wizek> dminuoso: I've had good experiences with ghcid over the last years
01:39:21 <tdammers> amosbird: I found it interesting and promising at first, but disappointing overall
01:39:28 <lemmih> Wizek: Just remove the kind signature and remove the Con type.
01:39:29 <tdammers> amosbird: highly personal though.
01:39:44 <amosbird> tdammers: which part of clojure disappoints you most ?
01:39:52 <dminuoso> Wizek: Its probably my only option as it stands right now, since ghc-mod is not (officially) available for more recent GHC versions (which I want to use
01:40:10 <Wizek> dminuoso: )
01:40:40 <Ariakenom> close to sending a pull request to http://0.30000000000000004.com/ to change rational example to "0.1 + 0.2 :: Rational"
01:41:18 <tdammers> amosbird: lack of static types, bad documentation, and how "live coding" is embraced to the point that it's practically mandatory
01:41:58 <Wizek> lemmih: but if I remove Con, won't I have to change the type to `lookup :: Key c -> c (Key c) (Val c) -> Maybe v`?
01:41:59 <merijn> bleh, naming things is way to hard >.>
01:42:03 <amosbird> huh, I wasn't aware that clojure doesn't have static types
01:42:35 <lemmih> Wizek: Nope, just lookup :: Key c -> c -> Maybe (Val c)
01:42:57 <sophiag> lol, i use clojure a lot and not only does it not have static types its users have an odd anti-intellectual inferiority complex about languages that do
01:44:30 <Wizek> sophiag: inferiority? So they thing other languages are superior?
01:45:05 <Wizek> lemmih: wait a second, something's odd here
01:46:00 <sophiag> they think users of statically typed languages are elitist, but *i* think people who espouse that view are generally those who have never been able to figure out a type system well enough to use it...i mean, considering how many people use both dynamic and statically typed languages and avoid those flame wars
01:46:41 <Wizek> sophiag: how many?
01:47:13 <merijn> I don't suppose someone has bothered to make a Text based wrapper around process?
01:47:15 <sophiag> i don't think it helps when people refer to languages as untyped (unityped is a different, funnier, story). the problem is a lot of people who've only used dynamic languages seem to think they don't interact with types when they really do. so like clojure has option gradual typing and, in my experience, gradual typing sucks. but if you're writing numeric library code...like in the bootstrapped parts of the compiler...you need to 
01:47:46 <sophiag> Wizek: how many? idk, most? in anger? less
01:47:54 <sophiag> personally, i do
01:48:30 <cocreature> merijn: process-extras has Text and ByteString wrappers iirc
01:48:53 <Wizek> sophiag: but you do have a preference for using one over the other, or do you not? Perhaps even a strong preference?
01:49:22 <tdammers> there's also the problem that haskellers (or typed-FP programmers) and clojurists (or dynamic-language programmers in general) mean completely different things when they say "type"
01:49:47 <sophiag> Wizek: in what Rich Hickey calls "real code," i.e. crud apps, i very much prefer static typing
01:50:25 <sophiag> but many of my personal projects involve source transformation that's very difficult in statically typed languages
01:50:30 <dminuoso> So here is a question. I find myself in a little mess of having String, ByteString and Text floating around at the same time. Some of it is due to libraries, though I managed to eliminate most String usages with OverloadedStrings already.
01:50:39 <sophiag> there's a reason we can't just have a fancy macro system in haskell
01:50:50 <dminuoso> But it is annoying when you have things like [(Text, [ByteString])] thrown in your face.
01:51:00 <Wizek> lemmih: hmm, so considering that way, how would I be able to write something like this? `MyData Map.Map`, `MyData HashMap.Map`, `MapLike map => MyData map`?
01:51:19 <dminuoso> So my question is: How do you folks deal with such situations?
01:51:33 <merijn> dminuoso: Suck it up and realise how much worse things are in my C code :p
01:51:48 <sophiag> tdammers: rich hickey himself has admitted he never spent the time to learn haskell or a similar language (despite basing all his lazy functions in clojure on those from Data.List) so when he rails on static typing he's definitely referring to c++, java, and c#...
01:51:52 <merijn> dminuoso: Also, immediately convert to what you want at the boundaries of your application logic
01:52:24 <sophiag> and ironically "real code" is when you talk to a database...but almost all dbs are statically typed :p
01:52:59 <tdammers> sophiag: yes, and that actually pains me a lot - I mean, he's got all the right ideas in place, but utterly fails to see how Haskell implements most of them better than clojure does
01:53:05 <tdammers> (fsvo "better", obv)
01:53:08 <Wizek> lemmih: where, say, `data MyData map = MyData (map Int String) (map Char Bool)`
01:54:57 <lemmih> Wizek: Doesn't that work?
01:56:07 <merijn> Man, I really wish Control.Exception had a generic "newtype Exception = Exception String" so I can write my first pass without worrying about creating exception types and naming them...
01:56:09 * hackage timestamp 0.1.1 - Space-efficient Unix timestamp and utilities  http://hackage.haskell.org/package/timestamp-0.1.1 (OShev)
01:56:14 <Wizek> lemmih: well, I'd need to refactor a bit to be able to try your suggestion, but just thinking about it, if `c :: *`, then `map :: *`, so it won't be able to be applied to `Int, String`, no?
01:56:21 <lemmih> Wizek: Oh, I see. Then you probably want something like: class MapLike c where lookup :: k -> c k v -> Maybe v
01:57:10 <Wizek> alright, where do we get k and v into scope?
01:57:16 <Wizek> lemmih: ^
01:58:27 <lemmih> Wizek: In the signature for 'lookup'.
01:59:02 <Wizek> I have a hunch that GHC won't aggree with that, but let me try
01:59:14 <Taneb> lemmih: you can't define an instance of MapLike Map there (lookup needs an Ord constraint on k)
01:59:53 <lemmih> Yeah, add constraints as required.
02:00:34 <lemmih> Either Ord or Eq+Hashable if you want hashmaps.
02:02:52 <Ariakenom> merijn, me too.
02:04:37 <cocreature> merijn: yes please!
02:04:49 <Taneb> Hmm, does ConstraintKinds allow us to make classes of kind Constraint -> Constraint? Or (* -> Constraint) -> Constraint?
02:05:37 <Wizek> lemmih: brb and gonna try your suggestion soon
02:09:13 <Taneb> Oooh, it does
02:11:15 <merijn> Taneb: You can do pretty much arbitrarily complex constraints with ConstraintKinds
02:11:30 <merijn> Taneb: Here's some neat abuse: https://gist.github.com/merijn/6130082
02:12:41 <tsahyt> is there some non-lensy way to quickly construct isX functions to filter a collection for values that match a constructor?
02:12:42 <Taneb> merijn: oh wow, that's impresisve
02:13:00 <tsahyt> since sdl2 does not have any lenses apparently
02:13:14 <tsahyt> though I suppose I could just generate them myself
02:13:22 <merijn> tsahyt: You could just write lenses in your own package? :)
02:13:36 <merijn> tsahyt: Oh, is the collection a list? (Or are you okay with making it a list)
02:13:52 <frerich> tsahyt: [x | x@(Ctor _) <- xs]
02:13:57 <tsahyt> merijn: it's an FRP event stream. so internally it's basically a Maybe
02:14:06 <Taneb> merijn: it can be any MonadPlus, with mfilter
02:14:08 <merijn> > [x | x@Left{} <- [Left True, Right 1, Left False, Right 5]]
02:14:10 <lambdabot>  [Left True,Left False]
02:14:22 <merijn> :t mfilter
02:14:23 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
02:14:35 <merijn> Taneb: No, because then you first need to write the "isX" function again
02:14:43 <merijn> Taneb: Which was what he wanted to avoid
02:14:49 <Taneb> I think if you use -XMonadComprehensions you can use the comprehension syntax like that
02:14:55 <tsahyt> Event is also not an instance of monad, and thus no MonadPlus either
02:15:14 <tsahyt> I can of course just do a quick and dirty pattern match in a lambda, but that's very verbose
02:15:37 <tsahyt> I think I'll just generate the lenses instead
02:16:06 <tsahyt> lens is a transitive dependency already anyhow, thanks to sdl2 pulling in linear
02:16:21 <Taneb> tsahyt: I mean, the collection has to be a MonadPlus, not the element type
02:16:33 <tsahyt> Taneb: that is the collection
02:17:19 <Taneb> SDL.Event.Event?
02:17:30 <tsahyt> it's Event SDL.Event
02:17:34 <tsahyt> the outer being from wires
02:17:41 <tsahyt> so it's an FRP event stream of SDL events
02:17:42 <Taneb> Oh, ah
02:17:50 <tsahyt> the naming is a bit unfortunate I suppose
02:18:17 <tsahyt> well it'll be Event EventPayload, so that's nicer
02:18:39 * hackage clifm 0.3.1.0 - Command Line Interface File Manager  http://hackage.haskell.org/package/clifm-0.3.1.0 (pasqu4le)
02:22:02 <[exa]> lemmih: mind a question about LHC? you said there are problems with getting all haskell to work, can you elaborate on that a bit? Are there more problems in front-end (some unimplemented interfaces etc) or back-end (unimplemented parts of runtime) ?
02:23:14 <lemmih> [exa]: The name resolution, type-checking, and desugaring code has only been completed for a small subset of Haskell.
02:23:41 <tsahyt> the lens solution works nicely at least, now I can do filterE (is _KeyboardEvent) allEvents, and receive a stream of only keyboard events for further use :)
02:25:26 <marble_visions> hi all, why would I have visibility of y inside the lambda here? (taken from learn you a haskell) https://pastebin.com/BCXGKhNH
02:25:45 <merijn> marble_visions: Well, why wouldn't you?
02:25:57 <lemmih> marble_visions: Are you asking why you want it or why it is that way?
02:26:14 <[exa]> lemmih: (reason I'm asking: currently trying to gather any usuable info about instances from ghc output, so I was hoping for anyone who had better luck with that)
02:26:58 <lemmih> [exa]: Don't count on LHC being usable in any way for a very long time.
02:27:03 <[exa]> marble_visions: no one shadowed the variable so it's just magically there :]
02:27:40 <[exa]> lemmih: don't worry :]
02:28:27 <marble_visions> merijn: lemmih: [exa]: i am wondering why it works like that. so maybe lyah hasn't yet covered visibility rules
02:28:50 <merijn> marble_visions: Variables are in scope for the entire function body
02:30:03 <cocreature> marble_visions: unless you shadow a variable, you can always access variables from an outer scope from a nested scope
02:30:42 <marble_visions> merijn: cocreature: ooh. right
02:30:44 <marble_visions> thanks!
02:31:52 <merijn> hmm, attoparsec has no combinator for "accept anything except X", does it?
02:34:26 <cocreature> merijn: it does have notChar/notWord8
02:34:30 <cocreature> but no general noneOf
02:34:46 <srk> takeWhile (/='x')
02:34:49 <merijn> cocreature: I'm looking more for "notString"
02:35:10 <merijn> srk: That only works for single characters. I basically want to skip each line not starting with a specific prefix
02:35:20 <srk> right
02:38:14 <hc> Hi all.
02:38:41 <hc> There's a package I use, hs-captcha. The maintainer is not reachable. Sending mails to the address shown on hackage bounce, and his website is offline
02:38:45 <hc> 2018-04-16 11:31:43 H=(tangible.anticapcha.com) [63.246.154.233] F=<inkabpmqwge@anticapcha.com> rejected RCPT <jan@janesperer.de>
02:38:48 <hc> *** /var/log/nginx/access.log ***
02:38:48 <hc> oops
02:38:51 <hc> 84.161.173.251 88.198.67.213 - - TLSv1.2/DHE-RSA-AES256-GCM-SHA384 [16/Apr/2018:11:31:43 +0200] "POST / HTTP/1.1" 405 166 "-" "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko"
02:38:56 <hc> https://hackage.haskell.org/package/hs-captcha  <-- that package
02:39:09 <hc> What's the procedure in such cases? I'd wanted to ask him if he could add his package to stackage
02:40:03 <vaibhavsagar> hc: if there's a github, raise an issue there
02:40:18 <hc> unfortunately, there isn't one
02:40:27 <vaibhavsagar> you can open an issue at https://github.com/haskell-infra/hackage-trustees
02:40:38 <vaibhavsagar> and/or post in the haskell-cafe mailing listg
02:41:08 <shiona> https://github.com/IreneKnapp/hs-captcha ?
02:41:09 <vaibhavsagar> oh wait
02:41:42 <hc> hmm, will have to check if that's the same
02:41:45 <hc> Thank you in any case :)
02:41:51 <vaibhavsagar> if you want to add it to stackage, I think you need to raise an issue in https://github.com/fpco/stackage
02:42:06 <hc> Jup, I've added a few packages to stackage, but I want to speak with the maintainer/author first
02:42:26 <vaibhavsagar> haskell-cafe would be the place then I think
02:42:38 <vaibhavsagar> if you can't find a way to contact them otherwise
02:45:15 <dminuoso> What's the reason for the guaranteed range of [-2^29..2^29-1] of Int?
02:45:55 <dminuoso> Why not ^31
02:46:27 <lemmih> dminuoso: To allow Haskell implementations more freedom.
02:46:50 <dminuoso> lemmih: In what sense? What use would Haskell make of the remaining 2 bits?
02:47:02 <lemmih> dminuoso: Tagging was once a popular way of telling pointers and non-pointers apart.
02:47:10 <Taneb> dminuoso: https://stackoverflow.com/questions/7786662/bit-size-of-ghcs-int-type
02:47:24 <dminuoso> Ahh, thank you both.
02:47:36 <hc> vaibhavsagar: I verified the github package matches the hackage package. Hence I created an issue
02:47:53 <vaibhavsagar> great, hopefully you get a response soon
02:50:32 <gentauro> hi all :) Does anybody know why so many haskellers use "hungarian notation?", like "consoleIO" and "unsafe ..." I mean, doesn't Haskell have the best type system?
02:50:52 <gentauro> dbJSONResponse
02:51:04 <gentauro> mkRequest
02:51:05 <merijn> hmm, there's also no attoparsec combinator that tries a parse without consuming it, is there?
02:51:08 <gentauro> and a lot more ...
02:51:24 <dminuoso> gentauro: `unsafe` prefixes at least are supposed to be mental checks, since the effects of such functions is not easily visible in the type system.
02:51:36 <gentauro> dminuoso: good point
02:52:16 <gentauro> dminuoso: I tend to use {-# LANGUAGE Safe #-} everywhere
02:52:52 <gentauro> whenever I run into a "not safe", I try to place it in it's own "nasty" module (everything marked as Trustworthy)
02:53:28 <gentauro> that way, I know what to look into if something doesn't work as expected
02:53:36 <gentauro> (isolate side-effects)
02:54:26 <gentauro> back to my initial question, like Monads, Functor, everything seems to be pre-/postfixed ...
02:55:16 <WhatisRT_> gentauro: That's just functions describing what they're doing
02:56:59 <WhatisRT_> even though most of the time you can infer what a function does by knowing its type, this doesn't help you when you're reading code (and don't have a system that shows types available)
02:57:24 <gentauro> I understand the need for record fields, due to shadowing of functions
02:57:52 <gentauro> WhatisRT_: isn't it the reason we spend time specifiying the signatures?
02:58:01 <gentauro> I even do it sometimes with inner functions
02:58:08 <merijn> gentauro: The problem is they collide with other names
02:58:19 <merijn> gentauro: i.e. "mapM" can't be called "map", because map already exists
02:58:21 <WhatisRT_> example: putStr and putStrLn
02:58:39 <dminuoso> And fmap cant be called map because.. yeah why actually?
02:59:00 <merijn> dminuoso: fmap was called map in the past
02:59:03 <gentauro> that's another, one. I would love if I could specify all signatures at the top (or bottom) of a file, but in a group (pretty much as the .H / .C separation in C/C++)
02:59:08 <merijn> dminuoso: But they changed it to be easier to learn
02:59:17 <merijn> gentauro: Eh, you can?
02:59:28 <merijn> gentauro: Signatures don't have to be with the declaration
02:59:37 <gentauro> merijn: you sure?
02:59:42 <gentauro> :)
02:59:42 <merijn> gentauro: You can even do multiple values on a single line
03:00:06 <dminuoso> merijn: Considering the sheer amount of type inference diagnostics, "no instance for ..." and skolem type variable bugs I had to endure in my first weeks, I think `map` having some overly generic type wouldn't have been my worry. :P
03:00:13 <merijn> > let x, y, z :: Int; x = 1; y = 2; z = 3 in (x,y,z)
03:00:15 <lambdabot>  (1,2,3)
03:00:31 <Taneb> gentauro: that style used to be a lot more common
03:00:31 <dminuoso> The word `skolem` was especially scary back then.
03:01:03 <gentauro> merijn: I tend to use (like in OCaml) let ... in let ... in
03:01:49 <merijn> gentauro: That's generally considered bad style, tbh. The only reason I use "let .. in" is lambdabot not supporting multi-line bindings
03:02:13 <gentauro> merijn: wow
03:02:17 <gentauro> you actually can :D
03:02:28 <gentauro> I keep mixing elm and haskell cos of the similar syntax ;)
03:02:54 <Taneb> Elm and Haskell are surprisingly different languages sometimes
03:03:00 <gentauro> most time when I reach a file, I really don't want to see implementation details
03:03:11 <gentauro> I just want to see what's in it for me (type signatures and so)
03:03:30 <gentauro> and I know I could go to the documentation, but most of the time, I just jump around code
03:03:59 <WhatisRT_> I'm having a weird problem with stack: my project was supposed to be building a library and an executable, but stack suddenly stopped building the library (I didn't change anything in the configuration)
03:04:03 <gentauro> Taneb: Indeed ...
03:04:46 <gentauro> one thing I have is list and signatures ( : and :: which are opposite in the languages )
03:04:52 <cocreature> WhatisRT_: you mean it stopped building the library even if you change things in it?
03:04:56 <gentauro> I have = I hate
03:05:04 <WhatisRT_> cocreature: yes
03:05:32 <WhatisRT_> I even deleted my .stack-work folder and rebuilt everything, no library in there
03:05:48 <cocreature> WhatisRT_: does your executable depend on the lib?
03:06:06 <gentauro> WhatisRT_: have you defined the LTS?
03:06:25 <gentauro> resolver lts-11.5 ...
03:06:36 <WhatisRT_> it should depend on the lib
03:06:45 <WhatisRT_> yes, I have a resolver
03:06:48 <cocreature> WhatisRT_: so how exactly are you checking whether it’s rebuilding the lib?
03:06:55 <gentauro> and that didn't change right?
03:07:14 <WhatisRT_> I'm looking if there is a library in the .stack-work folder
03:09:09 <WhatisRT_> but it isn't even touching the source files for my library
03:09:29 <WhatisRT_> is there some way to manually tell stack to build my lib?
03:09:31 <cocreature> have you specified exposed/other-modules correctly?
03:10:08 <cocreature> you can run "stack build packagename:lib"
03:10:59 <WhatisRT_> I did not specify any exposed or other modules
03:11:40 <cocreature> are you using a package.yaml file? otherwise you have to specify those
03:12:20 <WhatisRT_> I'm using a package.yaml, yes
03:12:55 <cocreature> hm I’m running out of ideas. is your repo available publically somewhere?
03:14:21 <WhatisRT_> cocreature: yes, https://github.com/Darkas/tenkei/tree/master/haskell
03:14:43 <WhatisRT_> that's the folder
03:16:05 <WhatisRT_> it will probably not build because we do some custom stuff in there, but these are the files at least
03:16:46 <cocreature> it does build the lib for me
03:17:01 <cocreature> are you sure you haven’t just missed the file?
03:17:17 <cocreature> there’s a lot of stuff in .stack-work :)
03:18:16 <WhatisRT_> there is absolutely no library in there
03:19:04 <WhatisRT_> i.e. find .stack-work/dist -name 'libHShaskell-test-lib*.dylib' gives me nothign
03:19:47 <cocreature> I get a .stack-work/install/x86_64-linux-tinfo6-nopie/lts-11.2/8.2.2/lib/x86_64-linux-ghc-8.2.2/tenkei-haskell-0.1.0.0-8WRKfotO92P1OwouqWdhyb/libHStenkei-haskell-0.1.0.0-8WRKfotO92P1OwouqWdhyb.a
03:20:31 <WhatisRT_> even without the extension I get nothing
03:20:48 <cocreature> oh so the test lib is missing
03:21:13 <WhatisRT_> this worked yesterday, and I only changed source files...
03:23:11 <WhatisRT_> hm, could it be that it tries to build the library after it builds the executable?
03:23:16 <cocreature> ah no I do get the lib, it just seems like stack is trying to build the executable first (there is no dep on the lib) which fails due to a linking lib
03:23:26 <cocreature> s/linking lib/linking error/
03:23:30 <cocreature> if I remove the executable it works fine
03:23:49 <WhatisRT_> ok, so I have to keep that in mind
03:24:05 <WhatisRT_> lets see if it works that way
03:24:06 <cocreature> if you do want to build it after the lib, add a dependency
03:24:43 <WhatisRT_> to what? dependency: lib?
03:25:19 <cocreature> to the build-depends section of the executable
03:26:14 <tabaqui2> wow, first order logic based on free monads is much more powerfull than on GADT's
03:26:34 <cocreature> s/build-depends/dependencies/ since you’re using a package.yaml rather than a *.cabal file
03:28:29 <WhatisRT_> cocreature: but what do I add to the dependencies? I tried lib and library, which don't seem to work
03:28:38 <cocreature> WhatisRT_: haskell-test-lib
03:30:04 <WhatisRT_> cocreature: thanks, that worked!
03:36:23 <zincy> Silly question but what was the point in making List an instance of monad - I get that monads are a useful abstraction for effects and failure but why collections?
03:37:28 <lemmih> zincy: Do you see how list comprehensions are useful?
03:39:09 <electrocat> zincy: it allows for a form of non-deterministic computation
03:39:09 <WhatisRT_> zincy: it's additional functionality, why wouldn't you have that available?
03:39:14 <zincy> lemmih - yes
03:39:37 <zincy> Maybe I havent gone through the list monad examples properly
03:39:57 <zincy> I guess its hard to know why something is useful if you dont understand it
03:40:28 <Taneb> > do {x <- [1,2,3]; y <- [4,5,6]; guard (x * y >= 8); return (x,y)}
03:40:31 <lambdabot>  [(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
03:40:32 <zincy> So are list comprehensions sugar for the do notation?
03:40:44 <[exa]> yes
03:40:52 <Taneb> zincy: the do notation is already sugar, they are both sugar for the same thing
03:41:12 <zincy> So how would I completely desugar a list comprehension?
03:41:26 <zincy> To just >>=
03:41:29 <gentauro> doesn't do always lift up to IO?
03:41:38 <gentauro> and list comprehension are rather pure
03:41:42 <[exa]> nope
03:42:08 <[exa]> (there's no reason why IO would be special for that syntax)
03:42:11 <WhatisRT_> monads are unrelated to pureness
03:42:21 <zincy> Here we go - https://stackoverflow.com/questions/8029046/removing-syntactic-sugar-list-comprehension-in-haskell
03:42:25 <lemmih> gentauro: do-notation works for all monads, IO or otherwise.
03:42:41 <gentauro> roger
03:43:10 <[exa]> gentauro: you'll probably find a bunch of State examples
03:43:33 <Putonlalla> List comprehensions can also be generalized to any `Monad`.
03:43:48 <Taneb> zincy: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11 gives an example of how to translate list comprehensions to list functions
03:43:49 <guest_> I am getting this error http://lpaste.net/364865 what is meant by `      NB: ‘State’ is a type function, and may not be injective` this line and how to ` enable AllowAmbiguousTypes`?
03:43:51 <WhatisRT_> for do notation, I would recommend not using it until you can desugar it
03:44:28 <Taneb> zincy: for list comprehension to do-notation, see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#monad-comprehensions
03:44:30 <lemmih> guest_: Can you show us the code?
03:44:41 <WhatisRT_> use >>= until you are in a situation where you suddenly realize that do makes your code a lot easier
03:44:47 <[exa]> Putonlalla: really? (quick test with maybe failed here)
03:44:59 <zincy> Taneb - :) Thanks
03:45:20 <lemmih> guest_: You don't want to enable AllowAmbiguousTypes. You might want ScopedTypeVariables, though. But show us the code.
03:45:29 <Taneb> zincy: do bear in mind that do-notation is itself sugar for using (>>=)
03:45:37 <guest_> lemmih : http://lpaste.net/364866 here is that function
03:45:56 <Taneb> do {x <- foo; y <- bar; return (x + y)} => foo >>= \x -> bar >>= \y -> return (x + y)
03:46:01 <guest_> lemmih : how to enable AllowAmbiguousTypes
03:46:35 <lemmih> guest_: You sure that's all the code? Isn't that function nested inside another function?
03:47:33 <gentauro> Have any of you read Escaping Hell with Monads -> https://philipnilsson.github.io/Badness10k/escaping-hell-with-monads/
03:47:37 <gentauro> reallyd good read
03:48:11 <zincy> Taneb - So both the do syntax and list comprehensions use the same monad comprehensions you linked to?
03:48:19 <guest_> lemmih all the types ServiceRequest, Frame, are strings and StateMachineException is exception type defined like as first example of http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html
03:48:27 <Putonlalla> Enable `MonadComprehensions`, [exa].
03:48:59 <zincy> gentauro - Yeah thats the beauty of the bind method it hides the machinery for the monad instance away
03:49:04 <Putonlalla> That's useful maybe once a year.
03:49:06 <[exa]> Putonlalla: oh thanks!
03:50:02 <lemmih> guest_: Could you paste the entire context of the code?
04:10:45 <zincy> Say I have different record types which have fields representing IDs - am I better to name the fields typeaId and typebId or should I enable the extension for duplicate record fields and call them all "id"
04:12:06 <chisui_> I wouldn't use "id" since it shadows the prelude version
04:16:34 <zincy> Thanks
04:27:28 <dfeuer> Ping Cale.
04:28:01 <dminuoso> zincy: You could define them in different modules and import them qualified.
04:31:17 <dminuoso> zincy: Since GHC 8.0 we also have DuplicateRecordFields (as part of OverloadedRecordFields) I believe, if you need to have duplicate field labels.
04:31:24 <dminuoso> Just as additional options.
04:32:29 <gentauro> does {-# LANGUAGE ... #-} have any impact on performance (better or worse)?
04:32:49 <zincy> dminuoso - Yeah I was wondering whether I should use that extension or just give the fields a more specific name as in personID
04:33:09 <lemmih> gentauro: Kinda depends on which extensions you enable.
04:33:41 <dminuoso> lemmih: Are there any pragmas that, just by being activated, can change performance characteristics?
04:33:50 <dminuoso> I'm thinking OverloadedStrings at least might have the potential
04:33:57 <lemmih> dminuoso: Strict and StrictData can change things quite a bit.
04:34:36 <Putonlalla> At least `NoMonomorphismRestriction` and `MonoLocalBinds` may have an effect on specialization, dminuoso.
04:35:03 <dminuoso> Ah good point on both.
04:36:53 <Boomerang> For `OverloadedStrings`, my understanding is that it just add `fromString` to all literal Strings, so if it gets inlined, I would expect to have no difference in performance.
04:36:57 <gentauro> OverloadedStrings came to my mind as well
04:37:15 <gentauro> but it depends on how you work with strings
04:37:28 <gentauro> lazy list vs bytearrays
04:38:24 <Boomerang> Right, but the choice of Text vs String vs ByteString vs other is independent of the use of the OverloadedStrings pragma, I thought the question was just about the pragma
04:39:10 <merijn> Is there a version of many that avoids the intermediate list being built?
04:39:12 <merijn> :t many
04:39:13 <lambdabot> Alternative f => f a -> f [a]
04:40:22 <cocreature> merijn: which intermediate list are you referring to?
04:40:34 <merijn> cocreature: The result list, I guess
04:40:40 <dminuoso> Boomerang: My thinking is just that type inference might lead to polymorphism in situations, defeating sharing/caching.
04:40:47 <merijn> cocreature: I was thinking of the result as the intermediate list in "void $ many foo"
04:40:56 <dminuoso> I dont feel comfortable enough to formulate a specific case, it was just a feeling.
04:42:09 <cocreature> merijn: there is skipMany in various parser combinator libs but afaik there’s nothing in base
04:42:54 <Boomerang> dminuoso: Right, if you expose a top level function that is polymorphic `IsString s => s -> r` instead of `Text -> r` then yeah that might influence performance.
04:44:33 <Boomerang> The most common use of OverloadedStrings that I have seen wasn't to get polymorphism for a string type, but rather to be able to write literal string for whichever type more easily.
04:45:17 <dminuoso> Boomerang: Right, you mean being able to apply `f :: Text -> f` to "Hello World" ?
04:46:07 <Boomerang> Yeah for example, in the case I would expect OverloadedString to have no influence over performance
04:46:45 <dminuoso> Boomerang: Strictly speaking that depends on the optimization levels though, doesn't it?
04:47:36 <dminuoso> I mean with no simplifier passes, you would pay for the extra fromString roundtrip.
04:47:46 <Boomerang> Possibly, literal inlining seems like a straight forward optimization, but you can have a look at -ddump-simpl to see what GHC does
04:50:54 <veverak> so, I have [(a,b)] and I would like to 'map' function over it
04:51:12 <veverak> however, the function is  a -> b -> c
04:51:19 <veverak> not (a,b) -> c
04:51:20 <dminuoso> :t uncurry
04:51:22 <lambdabot> (a -> b -> c) -> (a, b) -> c
04:51:23 <dminuoso> :t curry
04:51:24 <lambdabot> ((a, b) -> c) -> a -> b -> c
04:51:25 <veverak> dminuoso: thanks!
04:51:42 <quicksilver> > map (uncurry (+)) [(1,2),(3,4),(5,5)]
04:51:44 <lambdabot>  [3,7,10]
04:52:11 <marvin3> > zipWith (+) [(1,2),(3,4),(5,5)]
04:52:13 <lambdabot>  error:
04:52:13 <lambdabot>      • No instance for (Num (Integer, Integer))
04:52:13 <lambdabot>          arising from a use of ‘e_1123455’
04:52:27 <marvin3> ignore that!
04:52:37 <dminuoso> I wonder whether you could do that with lenses
04:53:01 <quicksilver> a more typical lens question would be 'apply a function to the first part of the pair only'
04:53:20 <quicksilver> otherwise just changing map to traverse hardly feels like 'rewriting with lenses'
04:54:01 <merijn> quicksilver: Sounds like more of a Bifunctor question than a lens one, tbh
04:54:27 <merijn> > map (first (+1)) [(1,2),(3,4),(5,5)]
04:54:29 <lambdabot>  [(2,2),(4,4),(6,5)]
04:54:50 <hpc> lens generalizes further than Bifunctor does
04:55:00 <quicksilver> ok, but lenses give you a standard way of building things 'like first'
04:55:04 <hpc> a more more typical lens question would be 'apply a function to just this record element'
04:55:53 <dminuoso> My point was not that lenses were a better way. It was just a random thought whether lens (thinking about Control.Lens.Traversal) would have some way to express `map (uncurry (+)) [(1,2),(3,4),(5,5)]`
04:56:15 <Boomerang> dminuoso: Alright, I just did a quick -ddump-simpl, and it looks like there is a `cast` from String -> Text remaining in there. With -O2, it's gone. So I guess don't forget to compile with O2 :)
04:56:37 <dminuoso> Boomerang: Ah thanks, I wanted to test that later - guess I dont have to.
04:57:12 <Boomerang> I did a simple Text.putStrLn "Hello World". In the -O2 version, even the call to putStrLn gets inlined :D
04:57:57 <quicksilver> well
04:58:04 <quicksilver> > traverse  %~ (uncurry (+)) $ [(1,2),(3,4),(5,5)]
04:58:06 <lambdabot>  [3,7,10]
04:58:10 <quicksilver> ^^ dminuoso
04:58:21 <quicksilver> > (traverse . _1) %~ (+1) $ [(1,2),(3,4),(5,5)]
04:58:23 <lambdabot>  [(2,2),(4,4),(6,5)]
04:58:29 <dminuoso> quicksilver: Well I specifically meant the uncurry portion :P
04:58:32 <quicksilver> feels more like it leads somewhere interesting
04:58:37 <dminuoso> quicksilver: Or `zipWith` rather.
05:00:06 <veverak> hmm
05:00:10 <veverak> so many quaternion libs
05:00:28 <veverak> anybody got any favourite for usage as rotation representation?
05:00:53 <KaHaSt> Test
05:01:21 <spruit11> Success.
05:03:22 <KaHaSt> simon.fromme updated the channel header to: Relay-Channel für den IRC channel #haskell.
05:03:24 <KaHaSt> Alle Nachrichten, die hier reingeschrieben werde, werden unter dem User `KaHaSt` im IRC-channel gepostet.
05:10:27 <samwan> Came here because of a gist about this channel of a week ago, figured out this is a cool community. Time to learn Haskell although I will probably never have any productive use for it
05:11:11 <hpc> even if it doesn't, it'll make you better at whatever languages you do end up using
05:11:52 <samwan> I was planning to learn LISP for years now but always found new excuses not to. I assume the languages should be fairly similar
05:12:05 <samwan> I mean, from a workflow point of view, not syntax
05:12:18 <hpc> lisp lets you get away with a lot more
05:12:32 <hpc> it's not static-typed, and stuff like set! are too easy to use
05:12:40 <adjofun> lisp is impure, right?
05:12:44 <hpc> if your goal is to learn to write in a purely functional way
05:12:51 <adjofun> that is, launchMissiles is relevant
05:13:20 <marvin3> lisp (as in CL) and haskell couldn't be further apart. lisp is mostly imperative, dynamically typed and strict, haskell is purely functionaly, statically typed, lazy
05:13:28 <hpc> i learned lisp after haskell, and when you've got good habits lisp is very similar
05:13:40 <hpc> but everyone else in my class struggled with it because they tried to write it like C or java
05:13:43 <Ariakenom> is there a replace function on String?
05:14:54 <Ariakenom> [(String,String)] -> String -> String
05:15:12 <lemmih> Not in Prelude, I think.
05:16:13 <hpc> Ariakenom: there's one for Text, and some regex libs
05:16:29 <hpc> oh, and https://hackage.haskell.org/package/extra-1.6.5/docs/Data-List-Extra.html#v:replace
05:17:00 <hpc> (also HasCallStack has an amusing implementation)
05:18:04 <Ariakenom> Too bad. Wanted something for quick one liner on cmd line
05:28:04 <zincy> Say I wanted to have a monadic action that took a Maybe value and an IO action and then returned a new IO action - how would I achieve this? Monad transformers?
05:29:16 <quicksilver> you don't need to do anything special to achieve that
05:29:20 <Psybur> zincy, that sounds a bit like the XY problem. What exactly are you trying to achieve?
05:29:21 <quicksilver> that's just something you can do.
05:30:09 * hackage safe-coerce 0.1.0.0 - A friendly shorthand for an old friend  http://hackage.haskell.org/package/safe-coerce-0.1.0.0 (kcsongor)
05:31:17 <zincy> websocket server - I want to broadcast a new msg to rest of clients only if the message received could be parsed to a Just Value
05:31:55 <zincy> http://lpaste.net/364868
05:44:17 <Psybur> zincy, something like this? https://glot.io/snippets/f0660emub5
05:45:53 <Psybur> Thats just using Maybe, not sure if Im missing the mark here :D
05:47:34 <zincy> Psybur - Yes! Thanks
05:47:52 <zincy> Thats the key piece - Maybe (IO ())
05:48:21 <zincy> This Haskell rabbit hole gets more fun the further down you go
05:48:52 <veverak> <3
05:50:11 <Psybur> Anytime zincy, glad I could help
05:52:04 <electrocat> Psybur: lol what's the use of that package?
05:52:09 <zincy> What does   pure $ putStrLn msg evaluate to in the case of msg being Nothing
05:52:13 <electrocat> it just calls unsafeCoerce
05:52:37 <electrocat> woops, wrong link, nvm
05:53:12 <Psybur> zincy, it wont get that far if parse returns Nothing
05:53:16 <merijn> That's a *bad* package
05:53:25 <Psybur> merijn, Data.Maybe is bad? :D
05:53:27 <merijn> acme-safe-coerce, sure
05:53:36 <merijn> Psybur: No, the safe-coerce one just uploaded
05:53:48 <zincy> PsyBur - Ah of course
05:54:05 <Psybur> zincy, do you know what a do block looks like desugared?
05:54:21 <zincy> Let me try and desugar what you posted
05:57:43 <zincy> f s = \s -> parse s >>= (\msg -> pure $ putStrLn msg)
05:57:52 <zincy> Correct?
05:57:54 <electrocat> merijn: yeah, why even bother making that a package? xD
05:58:08 <Psybur> f s = parse s >>= pure . putStrLn
05:58:17 <Psybur> Yes
05:58:18 <merijn> electrocat: Also it collides with actual safe coerce
05:58:26 <Psybur> Now what does >>= look like for Maybe?
05:58:33 <merijn> :t Data.Coerce.coerce
05:58:34 <lambdabot> Coercible a b => a -> b
05:58:38 <electrocat> right
05:58:56 <Psybur> Nothing >>= _ = Nothing
05:59:04 <Ariakenom> "f s = \s ->" was one s too many
05:59:45 <Psybur> See that _? That means that the rest of the chain is dropped
06:00:02 <zincy> (>>=) Nothing _ = Nothing             (>>=) (Just a)  f = Just (f a)
06:01:38 <zincy> Ah yes so we return nothing without calling the second argument to >>=
06:01:47 <Psybur> Yes
06:03:11 <zincy> So we can conditionally evaluate an IO action by passing a function that returns an IO action to bind along with a maybe value
06:04:12 <merijn> zincy: Yes, IO is just another first class value to manipulate
06:07:41 <zincy> On stephen diehls blog he talks about Haskell having an 'io system' and the fact some languages dont
06:07:53 <zincy> Is this a direct reference to IO being a first class value?
06:08:09 <merijn> Yes, no, maybe?
06:08:31 <electrocat> i wonder why there is a Data.Type.Coercion and Data.Type.Equality, they seem highly similar
06:09:17 <merijn> electrocat: What seems similar about them?
06:12:19 <electrocat> Coercion seems to work with a type class, while equality is just reflection, that look like the only difference
06:12:19 <[exa]> zincy: I guess he refers to the fact that the underlying IO syscalls are slightly more wrapped by RTS than usual
06:17:37 <cocreature> electrocat: *.Coercion is for converting between different types that have the same runtime representation. *.Equality allows you to work with type equalities, i.e., with statements about which types are the same
06:19:22 <electrocat> ah i see
06:19:30 <electrocat> and Equality implies Coercion but not the other way around
06:22:38 <Ariakenom> GHC does asynchronous IO, right? More than slightly wrapped.
06:24:33 <chisui_> electrocat: you don't need coercion if the types are the same
06:24:52 <tsahyt> now this is strange, the Hackage page of reactive-banana-gi-gtk lists an upper version bound on reactive-banana, but the cabal file in the git repository does not, which according to git blame hasn't been touched since First Commit.
06:25:06 <tsahyt> and now reactive-banana-gi-gtk on Hackage doesn't compile with the new r-b version :/
06:25:15 <tsahyt> or rather it's not compatible
06:25:19 <electrocat> chisui_: yeah true
06:25:44 <tsahyt> I'll see whether it actually compiles, perhaps it's time to open an issue
06:28:00 <tsahyt> the version I get from cabal get has the version bounds too. apparently the author has uploaded it with bounds for some reason.
06:30:09 * hackage servant-pagination 2.1.0 - Type-safe pagination for Servant APIs  http://hackage.haskell.org/package/servant-pagination-2.1.0 (KtorZ)
06:30:39 * hackage mp 1.0.2 - Music player for linux.  http://hackage.haskell.org/package/mp-1.0.2 (piotrborek)
06:32:14 <quicksilver> Ariakenom: the runtime most people use is threaded, rather than asynchronous, but it does have an IO manager to multiplex IO efficiently over thread scheduling
06:32:49 <quicksilver> there was a historic runtime which was unthreaded and use cooperative threading which is similar to asynchronous techniques
06:33:16 <tsahyt> is the stackage haddock theme publicly available somewhere? I've come to prefer it over the Ocean theme in some ways, and would like to use it on my local docs
06:33:29 <merijn> quicksilver: I wouldn't be so sure most people use the threaded runtime
06:33:37 <merijn> quicksilver: Consider how it's not the default
06:34:05 <Ariakenom> Yeah. I agree with what you said. Just not sure on the temrinology.
06:34:16 <byorgey> has anyone ever seen an error where cabal new-build refuses to install something because it infers the custom Setup.hs needs Cabal <= 1.24, but Cabal-2.x is installed?
06:34:44 <byorgey> I'm getting it trying to build the exact-combinatorics package (which is, to be sure, somewhat old).
06:35:03 <merijn> byorgey: No, but I also know that custom setup breaks lots of stuff
06:35:15 <byorgey> The strange thing is I have no idea how cabal decides that exact-combinatorics needs Cabal <= 1.24, since the .cabal file definitely doesn't say that
06:35:26 <byorgey> merijn: yeah, I'm becoming more and more aware of that
06:35:27 <merijn> byorgey: And I'm not sure cabal-2.x is backwards compatible with all custom setups
06:35:32 <cocreature> byorgey: I’m vaguely recalling that packages without a custom-setup section get a Cabal <= 1.24 constraint
06:35:50 <byorgey> cocreature: ah, that would explain it!  Let me see if adding such a section helps
06:36:00 <Ariakenom> The threading is cooperative and IO asynchronous from a assembly perspective. It's implicit and synchronous at the Haskell level though.
06:36:41 <merijn> Ariakenom: From an assembly perspective there's no such thing as "asynchronous"
06:36:42 <cocreature> byorgey: note that this section will just be ignored by older versions of Cabal so adding it shouldn’t break the build for those versions
06:36:50 <quicksilver> merijn: oh isn't it? I'm rusty.
06:37:04 <merijn> quicksilver: You only get the threaded runtime if you compile with -threaded
06:37:13 <merijn> quicksilver: OTOH even the unthreaded runtime uses multiple threads
06:37:16 <cocreature> every two years someone proposes to make the threaded runtime the default, everyone agrees and nothing happens
06:37:22 <merijn> quicksilver: So it all depends on what you're trying to say
06:37:24 <quicksilver> I recall that but I'd someone invented the idea that the threaded runtime was the default
06:37:25 <Ariakenom> Sure. OS then.
06:37:46 <merijn> cocreature: to be fair, the threaded runtime can introduce some major performance regressions too
06:37:49 <locallycompact> Hi, I'm using these functions from Req, parseUrlHttp and parseUrlHttps https://hackage.haskell.org/package/req-1.0.0/docs/Network-HTTP-Req.html#v:parseUrlHttp
06:38:04 <cocreature> merijn: sure, but I still think it would be a better default
06:38:04 <locallycompact> What do I do if I don't know in advance which one I have?
06:38:04 <merijn> cocreature: parallel GC is killing for some workloads
06:38:14 <byorgey> cocreature: that did it, thanks!!
06:38:18 <byorgey> cocreature++
06:38:23 <locallycompact> When Url Http and Url Https don't line up
06:38:28 <cocreature> byorgey: nice!
06:38:38 <phadej> merijn: it's easily turned off, or reduced to few capacities only (GHC-8.2)
06:38:46 <merijn> phadej: Sure
06:38:53 <merijn> phadej: But it took me a week to figure that out
06:40:20 <phadej> merijn: https://www.reddit.com/r/haskell/comments/83e6dq/need_advice_on_compile_and_runtime_options_for/
06:41:06 <phadej> maybe if that were asked on StackOverflow, it would be better googable
06:41:16 <phadej> *googleable
06:41:31 <merijn> phadej: You'd still first have to figure out that that's the issue :)
06:41:40 <fresheyeball> anyone want to join me in #xmonad?
06:42:19 <Wizek> Anyone knows how I could enable call stacks for all functions within a haskell app as if I added the HasCallStack constraint to all bindings?
06:42:19 <phadej> merijn: if you come from JVM background, I think that shouldn't come to surprise that you need to tune the VM/RTS/GC
06:42:51 <phadej> and if you come from Ruby/Python/... than defaults are already better ;)
06:43:05 <Psybur> Does anybody know any good resources for using cloud haskell in AWS?
06:43:40 <phadej> cocreature, byorgey, Cabal <1.25
06:43:53 <phadej> <= (and >) constraints are fishy!
06:44:00 <Psybur> Im trying really hard to get away from Scala and Apache Spark D:
06:44:04 <byorgey> phadej: fair enough =)
06:44:05 <cocreature> phadej: huh, how so?
06:44:18 <byorgey> presumably  <= 1.24  does not allow  1.24.1
06:44:23 <phadej> it doesn't
06:44:23 <byorgey> for example
06:44:29 <cocreature> ah
06:44:55 <kuribas> Psybur: why?
06:45:29 <kuribas> Psybur: from what I've seen, cloud haskell seems more like akka than spark...
06:45:41 <cocreature> Wizek: you can’t. there is an open issue https://ghc.haskell.org/trac/ghc/ticket/13360
06:46:09 <Psybur> kuribas, because it's built on Scala, which sucks.
06:46:23 <Psybur> It uses null
06:46:33 <Psybur> Its not pure
06:46:35 <Wizek> cocreature: ah, too bad
06:47:13 <Psybur> Wonder if I could write my own Spark on top of cloud haskell heh
06:47:51 <phadej> Psybur: have you seen inline-java and what Tweag people have done to make Haskell run in Spark clusters?
06:48:50 <[exa]> put that way, it sounds a bit like organized crime
06:49:12 <kuribas> Psybur: I found this: https://hackage.haskell.org/package/sparkle-0.7.4
06:49:30 <Psybur> Isnt this just bindings to the scala library?
06:50:53 <kuribas> it creates a jar file.  See the explantion under "How it works"
06:51:05 <kuribas> But basicly yes.
06:51:22 <Psybur> Seems dirty :D
06:51:48 <Wizek> cocreature: but at least I know not to look for this anymore, thanks for sharing the ticket
06:52:09 <Wizek> I hope it will be implemented sometime
06:52:12 <cocreature> Wizek: I’m just being selfish and hope that now you’re tempted to implement it :P
06:52:14 <cocreature> heh
06:52:27 <Wizek> haha
06:52:34 <cocreature> success!
06:52:43 <kuribas> Psybur: recreating spark in haskell would be major undertaking.
06:52:49 <kuribas> Psybur: but please do it :)
06:53:37 <Psybur> Im wondering if Cloud Haskell would be a good place to build off of
06:53:40 <Wizek> cocreature: do you think it's hard to implement? Is implementation the only thing missing, or are other conceptual kinks or agreements also missing?
06:53:51 <Psybur> iirc spark used to use akka under the hood
06:53:58 <Psybur> And if youre saying cloud haskell is like akka
06:54:04 <cocreature> Wizek: I honestly have no idea, I did read the discussions at some point but it’s been too long :)
06:54:32 <kuribas> Psybur: yeah, cloud haskell would be a good start.
06:56:13 <Wizek> cocreature: Wanna re-read it and summarize it for us? ;) It's likely less work for someone who already did it once compared to someone who sees it for the first time. ;)
06:56:28 <cocreature> Wizek: sry, I need to get some work done :)
06:57:01 <Wizek> Understandable, same here.
07:15:06 <zincy> How do I evaluate the IO action returned at the end wrapped in the Maybe ? -(Maybe AuctionAction -> Maybe (IO ()))      -> Maybe AuctionAction -> Maybe (IO ())
07:16:05 <zincy> Or in other words what function takes a Maybe (IO ()) and returns the IO ()
07:17:14 <maerwald> that's a very broad question
07:17:16 <frerich> zincy: Maybe you want just pattern matching on 'Just'. Or you could use the 'maybe' function - but what if the given `Maybe (IO ())` is actually Nothing - what behaviour would you expected?
07:17:24 <maerwald> an empty IO action
07:17:32 <maerwald> but we don't really know
07:18:03 <zincy> Would code help?
07:18:19 <frerich> zincy: If you enter 'Maybe a -> a' into e.g. Hayoo, it will tell you that there's 'fromJust'.
07:18:33 <aueuaio> zincy: you can use fromMaybe and provide a default IO action to be used instead if the Maybe actually is Nothing
07:19:00 <Psybur> :t maybe
07:19:02 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:19:35 <maerwald> :t flip maybe id
07:19:36 <lambdabot> b -> Maybe b -> b
07:19:43 <zincy> ah right I was being to specific with my hoogle searches
07:19:46 <zincy> *too
07:20:28 <Taneb> :t asum :: Maybe (IO a) -> IO a
07:20:30 <lambdabot> Maybe (IO a) -> IO a
07:20:40 <zincy> So is the IO () literally just a way of saying an IO action that is empty and is a placeholder for doing nothing?
07:20:52 <Psybur> % asum (Just (putStrLn "dude"))
07:20:52 <yahb> Psybur: dude
07:20:57 <maerwald> zincy: no
07:20:57 <Psybur> % asum Nothing
07:20:58 <yahb> Psybur: *** Exception: user error (mzero)
07:21:04 <zincy> So return the IO () on the case of a Nothing
07:21:18 <maerwald> IO () -- does not mean the action is empty
07:21:32 <maerwald> it's just an empty value you get on execution
07:21:37 <Taneb> Psybur: I don't like the Alternative instance for IO but it is a thing that exists
07:21:58 <maerwald> it could be an empty IO action... or not, the type doesn't tell you
07:22:10 <Psybur> % asum (Nothing :: Maybe (IO ()))
07:22:10 <yahb> Psybur: *** Exception: user error (mzero)
07:22:11 <frerich> zincy: Note that 'putStrLn "Hello"' yields a value of type 'IO ()'. And very often, 'main' in a Haskell program is declared to be of type 'IO ()'. Neither of those typically does 'nothing'. :-)
07:22:23 <electrocat> IO has alternative?
07:22:44 <zincy> maerwald - so on execution the IO () is an io action that wont give anything back
07:22:49 <zincy> on execution
07:22:57 <aarvar> it gives back a value of type ()
07:23:07 <maerwald> zincy: yeah, kinda
07:23:12 <zincy> frerich - good point
07:23:12 <aarvar> but there's only one such value, so the value's useless
07:23:36 <Psybur> > fromMaybe Nothing
07:23:38 <lambdabot>  error:
07:23:38 <lambdabot>      • No instance for (Typeable a0)
07:23:38 <lambdabot>          arising from a use of ‘show_M21043545635300326978270’
07:23:41 <zincy> right so its not really empty because the action will yield an empty tuple on execution
07:23:51 <zincy> which is still a value
07:23:59 <aarvar> the point is that the action can still do things
07:24:06 <zincy> I guess thats a way of ensuring every IO action evals to something
07:24:09 <Psybur> % fromMaybe (pure ()) (Just (putStrLn "dude"))
07:24:10 <yahb> Psybur: dude
07:24:11 <dminuoso> zincy: Right. () just holds no information.
07:24:21 <Psybur> % fromMaybe (pure ()) Nothing :: IO ()
07:24:21 <yahb> Psybur:
07:24:31 <aarvar> zincy: right. It's the equivalent of "void" in other languages
07:24:40 <zincy> ah gotcha
07:24:45 <Psybur> zincy, I think fromMaybe (pure ()) is what you want?
07:24:48 <aarvar> except the idea of void is dumb. It should be ()
07:25:41 <dminuoso> zincy: In an interesting way () is the same as what C or C++ might call "void" (which confusingly is _not_ the same as Haskells Void).
07:25:56 <aarvar> dminuoso: thanks for repeating what I said
07:26:02 <dminuoso> Oh sorry. I actually didnt see that. :)
07:26:07 <zincy> Interesting
07:26:08 <aarvar> :)
07:26:41 <dminuoso> zincy: You can think of it as this: `data Unit = Unit`
07:26:49 <aarvar> data () = ()
07:29:31 <Psybur> % fromMaybe mempty (Just (putStrLn "dude"))
07:29:32 <yahb> Psybur: dude
07:29:40 <Psybur> % fromMaybe mempty Nothing
07:29:41 <yahb> Psybur: ()
07:29:47 <Psybur> % fromMaybe mempty Nothing :: IO ()
07:29:48 <yahb> Psybur:
07:30:19 <Psybur> zincy, does that work?
07:30:30 <zincy> It compiled ... :)
07:30:42 <Taneb> Isn't "fromMaybe mempty" just "fold"?
07:30:50 <Taneb> % fold (Just (putStrLn "dude"))
07:30:50 <yahb> Taneb: dude
07:30:56 <Taneb> % fold Nothing
07:30:56 <yahb> Taneb: ()
07:31:01 <Taneb> % fold Nothing :: IO ()
07:31:01 <yahb> Taneb:
07:31:01 <Psybur> Good point
07:31:03 <aarvar> what is yahb
07:31:08 <Psybur> yet another haskell bot?
07:31:09 <aarvar> what happened to lambdabot
07:31:14 <Psybur> > "sup"
07:31:16 <lambdabot>  "sup"
07:31:17 <Taneb> lambdabot doesn't like to do IO
07:31:25 <Taneb> yahb seems to so far
07:31:50 <Psybur> :t fold
07:31:51 <lambdabot> (Monoid m, Foldable t) => t m -> m
07:32:00 <dfeuer> Cale?
07:32:37 <barbi> is it possible to represent a list of any kinds of lists and also non list items in haskell? i want to be able to have this list [[1,2],4,[[[[[5]]]]]] etc'
07:33:45 <Psybur> barbi, why do you want to have that list?
07:33:47 <Taneb> data BarbiTree a = Node a | Tree [BarbiTree a] -- not quite what you're after but it might be close
07:33:50 <barbi> because in here there is a problem that i cant represent https://rosettacode.org/wiki/Flatten_a_list
07:33:52 <ertes> is there a kind of standard package for CRC32?
07:34:07 <aarvar> Taneb: isn't that exactly it?
07:34:22 <aarvar> I was about to hit enter and say the same thing
07:34:37 <Psybur> https://rosettacode.org/wiki/Flatten_a_list#Haskell
07:34:44 <Taneb> aarvar: it's not really a "list" so to speak
07:35:04 <aarvar> Taneb: then neither is what he asked for
07:35:15 <Taneb> aarvar: true
07:35:39 <Psybur> > [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]
07:35:41 <lambdabot>  error:
07:35:42 <lambdabot>      • No instance for (Num [[[Integer]]])
07:35:42 <lambdabot>          arising from a use of ‘e_112345678’
07:36:16 <barbi> Psybur: thanks don't know why i didnt look at it :-)
07:36:31 <Psybur> I dont think you can have this structure verbatim in Haskell
07:36:34 <barbi> but it is a specific answer. can i do it for a different list?
07:37:14 <barbi> can i flatten any kind of list? even if i dont know it's input before?
07:37:21 <aarvar> wdym?
07:37:37 <barbi> the solution there is specific to the problem
07:37:54 <byorgey> barbi: the elements in any Haskell list must all have the same type.
07:37:59 <barbi> it has all the constructors ad the input of the problem has if i understand it well
07:38:11 <barbi> ad = as
07:38:44 <barbi> i want to make ant list (of Ints) but i want it to be in any input i throw on it
07:38:45 <byorgey> "flattening a list" doesn't really make sense in Haskell.
07:38:52 <barbi> abt = any
07:39:16 <aarvar> barbi: can you give an example of what you want?
07:39:19 <barbi> no matter about the sense. just want to know if it's possible :)
07:39:24 <Eduard_Munteanu> :t concat
07:39:25 <lambdabot> Foldable t => t [a] -> [a]
07:39:26 <barbi> yes please wait
07:39:27 <zincy> Psybur - Ok tested it and everything works perfectly!
07:39:31 <Eduard_Munteanu> Er.
07:39:36 <Psybur> aww yiss
07:39:37 <byorgey> barbi: I understood "I want to make a list of Ints".  I do not understand "I want it to be in any input I throw on it".
07:39:45 <Cale> dfeuer: hey, I'll have a look in a moment :D
07:39:48 <Eduard_Munteanu> > concat [[1,2], [2], [3,3], [4,6,7]]
07:39:49 <zincy> Thans
07:39:51 <lambdabot>  [1,2,2,3,3,4,6,7]
07:39:54 <tdammers> I would argue that "list" doesn't really make sense in most languages, or at least it doesn't mean the same thing it means in Haskell
07:40:01 <Cale> dfeuer: (I saw your email a short while ago)
07:40:50 <tdammers> but other than that, flattening a list of list of things into a list of things does make sense, see ^
07:40:55 <Psybur> zincy, did you end up using fromMaybe or fold?
07:41:03 <barbi> byorgey: i want the function "flatten" to flatten ant list of lists of Int's (or just Int alone without list), in any order which i can't know till i give the function this list
07:41:09 <Psybur> % fold (Just (putStrLn "dude"))
07:41:09 <yahb> Psybur: dude
07:41:15 <Psybur> % fold Nothing :: IO ()
07:41:15 <yahb> Psybur:
07:41:20 <barbi> byorgey: ant = any
07:41:32 <dfeuer> Cale: cool. Any thoughts?
07:41:36 <aarvar> barbi: the elements in a list have to have the same type
07:41:41 <tdammers> barbi: what Eduard_Munteanu said, basically
07:41:51 <Psybur> Maybe (IO ()) is a monoid and foldable, so you can use fold here :D
07:41:56 <tdammers> barbi: you can "flatten" a list of lists of things into a list of things using concat
07:42:34 <aarvar> Psybur: no it isn't
07:42:37 <tdammers> barbi: but because things and lists of things aren't the same type, you cannot have nested lists of variable nesting depth - [[1], 2], for example, will not typecheck
07:42:45 <Psybur> :t fold
07:42:46 <lambdabot> (Monoid m, Foldable t) => t m -> m
07:42:48 <aarvar> Psybur: A type can't be foldable
07:42:49 <aarvar> kind error
07:42:53 <Psybur> Whoops
07:43:02 <Psybur> Maybe is foldable and IO () is a monoid :D?
07:44:30 <Cale> dfeuer: Seems cool... I wonder if this could be used to freeze a DMap of mutable arrays...
07:44:52 <ertes> how do i see the reverse dependencies of a package again?
07:44:59 <ertes> (on hackage)
07:45:11 <Taneb> ertes: packdeps.haskellers.com ?
07:45:13 <Psybur> aarvar, that better? ;p
07:45:36 <barbi> tdammers: in the example from the link (https://rosettacode.org/wiki/Flatten_a_list#Haskell) it has a specific input. so it solve this specific problem. it is not generalized. maybe i'll have a more deep list or another Int alone, or another 12 elements of Ints as a list inside the input. the question is: can i flatten any input list i'll thow on the function from the link above (of course i need to change it that i
07:45:37 <barbi> t could do it)
07:46:54 <Taneb> barbi: in Haskell a list cannot contain both 4 (an Int) and [5] (a list of Ints) because Ints and lists of Ints are different types
07:47:06 <barbi> for example if my input is [[[[[[[[[[[[[[]]]]]]]]]]]]],1,[[[1,2],[3,4]]]] in the in the input also
07:47:23 <aarvar> barbi: if your input is impossible, no you can't do anything to it :)
07:47:24 <Psybur> Theres no way to make a list instance for int and make it a singleton list? :D
07:47:40 * hackage PyF 0.5.0.0 - Quasiquotations for a python like interpolated string formater  http://hackage.haskell.org/package/PyF-0.5.0.0 (guibou)
07:47:48 <Taneb> Psybur: I mean sure we can use the Applicative instance to get us a Num instance
07:48:05 <Taneb> Is it worth it though?
07:48:20 <Cale> barbi: Your problem will be that this input isn't a sensible Haskell list.
07:48:21 <ertes> Taneb: thanks…  this tool seems to only consider reverse dependencies that have strict version bounds, which is not what i need
07:48:52 <dfeuer> Cale: it seems plausible, but I haven't tried it.
07:49:16 <barbi> but the input from the exercise itself is not sensible' no? is this list a normal list in haskell? [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []] no, but the code there solve this list.
07:49:20 <Cale> barbi: Your choices are either to make a tree data type which corresponds more closely to the "lists" available in scheme, or else to do the more sensible thing and take a list of lists as a parameter, turning them into a single list.
07:49:34 <aarvar> barbi: the example input isn't a list
07:49:40 <aarvar> it's a Tree [Int]
07:49:42 <ertes> barbi: your input is really a tree disguising itself as a list
07:50:42 <barbi> OK so can i have a Tree [Int] which can solve any kind of input to the function? (of course all is Int's ot empty lists ot numbers alone)
07:50:56 <barbi> ot = or
07:51:00 <Psybur> barbi, you mean any shape?
07:51:23 <Psybur> Yes that should work
07:51:29 <barbi> i mean this: [[],3,[4,5],-1,[[[[[1,2],[2,5]]]]],[[[[[[[[[[]]]]]]]]]]]
07:51:33 <Putonlalla> This sounds like a job for lens heresy!
07:51:34 <barbi> for example
07:51:34 <Taneb> ertes: Tree Int rather than Tree [Int] I think
07:51:53 <Taneb> Um
07:51:54 <Putonlalla> @let instance (Applicative f, Num a) => Num (f a) where fromInteger = pure . fromInteger
07:51:55 <lambdabot>  .L.hs:171:10: warning: [-Wmissing-methods]
07:51:55 <lambdabot>      • No explicit implementation for
07:51:55 <lambdabot>          ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
07:51:55 <ertes> aarvar: ^ forwarding
07:52:05 <Cale> barbi: That expression on its own won't typecheck. In Haskell, all the elements of a list must have the same type.
07:52:06 <barbi> any kind of this list (which is Tree [Int])
07:52:08 <Putonlalla> > view (each . each . each) [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]
07:52:10 <lambdabot>  error:
07:52:10 <lambdabot>      • No instance for (Num [[[Integer]]])
07:52:10 <lambdabot>          arising from a use of ‘e_112345678’
07:52:19 <Psybur> barbi, yes, itll work with any Tree [Int] and I think it should work with any Tree
07:52:21 <Taneb> Putonlalla: the issue is the list itself isn't typechecking
07:52:32 <Psybur> Why is it Tree [Int] and not Tree [a]
07:52:52 <aarvar> Psybur: not the point
07:53:08 <ertes> this is really s-expressions
07:53:10 <Cale> barbi: So the solution is to invent (or obtain from the libraries) some type which encompasses the various possible things which can occur inside a "list" in the original problem.
07:53:39 <barbi> yes
07:54:03 <ertes> data SExp a = List [SExp a] | Word a
07:54:07 <Putonlalla> > view (each . each . each) [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []]
07:54:10 <lambdabot>  [1,2,3,4,5,6,7,8]
07:54:14 <Putonlalla> Yes!
07:54:20 <barbi> i want to throw on it a list (or Tree [Int] as you said) of any deep ot length and it should flatten it
07:54:32 <Cale> Putonlalla: did you make an instance of Num for lists?
07:54:41 <aarvar> clearly
07:54:45 <ertes> @let data SExp a = List [SExp a] | Word a  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
07:54:47 <lambdabot>  Defined.
07:54:50 <Putonlalla> The one above, Cale.
07:55:15 <Psybur> > view (each . each . each) [[1], 2, [[3, 4], 5], [[[[]]]], [[[6]]], 7, 8, []]
07:55:18 <lambdabot>  [[1],[2],[3],[4],[5],[],[6],[7],[8]]
07:55:37 <ertes> barbi: ^ define and use this type as your AST (the 'deriving' generates a few useful instances for you)
07:55:40 <barbi> Putonlalla: is it workd for any kind of "list" i will throw on it?
07:55:53 <Putonlalla> No, barbi. It's a big mess.
07:55:58 <barbi> ah :)
07:56:00 <aarvar> Putonlalla: way to go causing confusing :)
07:56:01 <Putonlalla> Do what ertes told you.
07:56:09 <aarvar> *confusion
07:56:34 <ertes> barbi: i think Putonlalla is just golfing =)
07:56:48 <reactormonk> Any cabal utility to gather license files for dependencies?
07:57:15 <aarvar> now make IsList and Num instances for SExp
07:57:21 <Cale> barbi: In Haskell, numeric constants are polymorphic, and so if you add an instance telling the compiler how to treat numbers as lists, it can typecheck the funny tree-like list from the problem
07:57:29 <Cale> > [[1], 2, [[3, 4], 5], [[[[]]]], [[[6]]], 7, 8, []]
07:57:31 <lambdabot>  error:
07:57:31 <lambdabot>      • No instance for (Num [[[[()]]]])
07:57:31 <lambdabot>          arising from a use of ‘e_112345678’
07:57:43 <Cale> > [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []] :: [[[Int]]]
07:57:45 <lambdabot>  error:
07:57:45 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[a0]’
07:57:45 <lambdabot>      • In the expression: []
07:57:49 <Cale> lol
07:57:52 <Putonlalla> :t confusing beginners
07:57:53 <lambdabot> error:
07:57:53 <lambdabot>     • Couldn't match type ‘Doc’
07:57:53 <lambdabot>                      with ‘(a
07:57:57 <Cale> > [[1], 2, [[3, 4], 5], [[[]]], [[[6]]], 7, 8, []] :: [[[[Int]]]]
07:57:59 <lambdabot>  error:
07:57:59 <lambdabot>      • No instance for (Num [[Int]]) arising from the literal ‘1’
07:57:59 <lambdabot>      • In the expression: 1
07:58:10 <Cale> nope, haha, whatever
07:58:17 <Cale> oh, it got removed
07:58:24 <Cale> Well, that's for the best anyway
07:59:14 <aarvar> > [[1,2,3], 5, [7]]
07:59:16 <lambdabot>  error:
07:59:17 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_112357’
07:59:17 <lambdabot>      • In the expression: e_112357
07:59:34 <aarvar> huh
07:59:58 <aarvar> I added instance (a ~ Bool) => Num [a]
08:00:11 <aarvar> shouldn't I get Integer != Bool?
08:00:14 <aarvar> or did it get removed
08:00:15 <aarvar> oh well
08:00:30 <Cale> Someone probably did an @undefine a few moments ago
08:00:36 <Cale> by the looks of it
08:00:54 <Putonlalla> My second joke was also ruined by that.
08:01:10 <aarvar> @let instance (a ~ Bool) => Num [a] where fromInteger = const [True]
08:01:11 <lambdabot>  .L.hs:163:10: warning: [-Wmissing-methods]
08:01:11 <lambdabot>      • No explicit implementation for
08:01:11 <lambdabot>          ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
08:01:29 <Putonlalla> This won't work, because lambdabot has `-Werror`, aarvar.
08:01:39 <Cale> I was thinking of giving a Num instance for lists that simulated polynomials, but then decided it was too much typing
08:01:41 <aarvar> @let instance Num Bool where fromInteger = const False
08:01:43 <lambdabot>  .L.hs:163:10: warning: [-Wmissing-methods]
08:01:43 <lambdabot>      • No explicit implementation for
08:01:43 <lambdabot>          ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
08:02:03 <aarvar> Putonlalla: what?
08:02:07 <barbi> thanks for all the help. i don't think i understand it all, but maybe something is added to my brain :-)
08:02:08 <aarvar> oh
08:02:09 <aarvar> I see
08:02:20 <aarvar> eh, too lazy to type out all the methods
08:02:42 <Putonlalla> @undefine
08:02:42 <Putonlalla> @instance instance Num Bool where fromInteger = const False; (+) = (+); (*) = (*); abs = abs; signum = signum
08:02:42 <lambdabot> Undefined.
08:02:42 <lambdabot> Maybe you meant: instances instances-importing
08:02:47 <Putonlalla> @let instance instance Num Bool where fromInteger = const False; (+) = (+); (*) = (*); abs = abs; signum = signum
08:02:47 <lambdabot>  Parse failed: Parse error: instance
08:02:55 <Putonlalla> I can't...
08:02:58 <Putonlalla> @let instance Num Bool where fromInteger = const False; (+) = (+); (*) = (*); abs = abs; signum = signum
08:02:59 <lambdabot>  .L.hs:158:10: warning: [-Wmissing-methods]
08:03:00 <lambdabot>      • No explicit implementation for
08:03:00 <lambdabot>          either ‘negate’ or ‘-’
08:03:05 * Putonlalla out.
08:03:13 <Cale> lol
08:03:16 <Cale> @undefine
08:03:16 <lambdabot> Undefined.
08:03:26 <aarvar> Putonlalla: you need to work on your lambdabot skills
08:03:41 <Cale> barbi: Yeah, we just ran off on a tangent moreso than helped ;)
08:03:42 <aarvar> I write all my code without line breaks as practice for when I need to use the bot
08:03:54 <Psybur> Blah I keep getting x instance of y backwards. How do I get it straight? Like instance Semigroup a => Monoid (Maybe a), is this the Semigroup a => Maybe a instance for Monoid?
08:04:05 <Psybur> Or is it the other way around heh
08:04:45 <aarvar> Psybur: the name of the thing being defined always comes after the =>
08:04:53 <aarvar> so yes, that defines the Monoid instance
08:05:09 <Psybur> So its the Monoid instance for Maybe a?
08:05:43 <Cale> Psybur: Yeah, the instance being defined is one for Monoid (Maybe a)
08:05:56 <Cale> Psybur: and it requires an instance of Semigroup a to be present in order to work
08:06:26 <barbi> is there a site with problems (from easy to hard) specific for haskell?
08:07:10 <Cale> barbi: I'm not sure it's exactly what you're looking for, but there are homework exercises in the CIS194 course here: http://www.cis.upenn.edu/~cis194/spring13/lectures.html
08:07:24 <barbi> thenks Cale
08:07:26 <frerich> barbi: A colleague recently reported he had a lot of fun with http://exercism.io/languages/haskell/exercises
08:07:29 <barbi> *a :)
08:07:50 <Psybur> and instance Foldable Maybe, you say that this defines the Foldable instance for Maybe?
08:08:08 <Cale> Some people also like doing the Project Euler exercises, but a lot of those require you to know a bunch of mathematics to be really successful at them.
08:08:21 <Akii> Hi! Anyone got a guide for converting a stack project to cabal? Need it for nix.
08:08:28 <Cale> (and it's mostly number theory)
08:08:31 <aarvar> frerich: "To run the test suite, execute the following command:"
08:08:51 <aarvar> let the stack/nix/cabal wars continue
08:09:09 <Cale> Akii: hmm... don't stack projects typically come with a .cabal file anyway?
08:09:22 <sclv> Cale: newer ones often use an hpack file instead
08:09:27 <Cale> oh, right
08:09:37 <sclv> but I think "all" that should need to happen is to generate a cabal file from the hpack in that case
08:09:44 <Cale> "convenient"
08:10:05 <sclv> i don't know the best "single" command to do this with just stack :-/
08:10:10 <sclv> i would like to know!
08:10:32 <sclv> but I do know that _at least_ "stack sdist" which creates the tarball should create a cabal-installable tarball, so will necessarily put the converted file in the tarball
08:10:55 <sclv> also you can set the --pvp-bounds flag there to "both"
08:11:02 <Cale> Does the hpack executable itself provide a way?
08:11:05 <sclv> which will put info from the snapshot into the bounds
08:11:18 <barbi> frerich: thank you too :)
08:11:25 <sclv> i think the whole point of the hpack executable is to provide a way, but I've never use it :-)
08:11:39 * Cale uses nix-shell to try to determine the answer
08:12:31 <aarvar> Akii: there's also a stack2nix tool I think
08:12:32 <Akii> also I definitely don't want to start another war, I've just been told that Cabal works best with Nix
08:12:40 <Akii> really? O.o
08:12:44 <sclv> (the hpack way won't gen bounds though, while the sdist way will, which is useful, since you'll want to use those bounds with cabal2nix)
08:12:47 <aarvar> I haven't used it, but yes
08:13:02 <Akii> ah from IOHK
08:13:02 <aarvar> I think I tried to install it on nixos and it didn't build :(
08:13:44 <sclv> anyway, "stack sdist" with whatever options you want, then unpacking the tarball given is certainly _one way_ to generate the cabal file :-)
08:14:41 <Akii> sclv I need to somehow incorporate that into a dev workflow though >_>
08:14:43 <aarvar> Akii: and the comment about stack/cabal wars was in response to exercism.io
08:14:49 <Akii> ah ok
08:15:01 <sclv> Akii: once you have the cabal file, you can convert the stack over to just using the cabal file
08:15:04 <Cale> Akii: Well, you're using nix, so you could make a derivation which does that.
08:15:09 <aarvar> which I was going to look at, but it says to use stack, and I never got stack working on nixos
08:15:33 <sclv> oh i see, this is a 3rd party lib you want to depend on, but which uses stack?
08:15:40 <sclv> not something you intend to develop yourself?
08:15:40 <Akii> Cale started with Nix like 2 days ago; I've the server up and running and all that's left to migrate are my "production" haskell services
08:15:50 <sclv> (and it says for some reason its not cabal installable but stack installable only?
08:15:51 <sclv> )
08:16:04 <sclv> (or its your own lib you intend to develop?)
08:16:06 <Akii> nope nope, my private projects are all written with stack
08:16:41 <sclv> lots of projects are both cabal and stack buildable
08:16:51 <sclv> as long as they have a .cabal file that works, then they're cabal buildable
08:16:58 <Akii> well I do have that
08:17:01 <sclv> ok
08:17:06 <sclv> then in theory you don't need to "convent"
08:17:09 <sclv> "convert"
08:17:16 <Akii> that'd be awesome
08:17:21 <aarvar> sclv: key words being "that works"
08:17:26 <sclv> the only issue would be if the bounds in the cabal file are wrong
08:17:29 <aarvar> if it works then it works, yes
08:17:36 <sclv> and you can fix those up in the cabal file yourself
08:17:40 <sclv> or with gen-bounds
08:18:08 <Boarders> Is there any way I can have record fields that are determined by other fields (I want this so I can use RecordWildCards to gives names to these functions without passing an argument)
08:18:24 <sclv> also if you use a haskell nix package set i think it picks out a set of consistent bounds anyway?
08:18:28 <sclv> but i am not an expert in that stuff
08:18:43 <aarvar> sclv: I think stack2nix takes versions from stack, in which case it should build with nix even if the cabal bounds are wrong?
08:18:54 <aarvar> but idk
08:20:12 <Akii> thank you all for the input
08:23:47 <barbi> in this: import Data.Tree (Tree(..), flatten)
08:23:55 <barbi> what is the (..) thing?
08:24:12 <dminuoso> barbi: Imports all of Tree's constructors/methods.
08:24:27 <barbi> thanks dminuoso
08:24:55 <dminuoso> barbi: Oh and field names (if its a record)
08:25:21 <lemmih> Boarders: No.
08:26:05 <dminuoso> barbi: Or rather more concisely: if `Tree` is a class, then this imports T and its methods. If `Tree` is a type, then this imports T and its constructors and field names that are currently in scope.
08:26:21 <jle`> that is definitely less concise ;)
08:26:31 <dminuoso> Oh heh.
08:26:38 <jle`> but more helpful :)
08:26:38 <dminuoso> Should have said "precisely" :)
08:28:59 <Cale> sclv, Akii: I made a meme to express my thoughts on all of this https://i.imgur.com/U34gN3N.jpg
08:30:40 <zincy> How would I abstract out the following?  fromMaybe (pure ()) (f)     fromMaybe (pure ()) (g)   -  with something like      g p = [ fromMaybe (pure ()) f | f <-p ]
08:31:52 <Psybur> :t sequence
08:31:53 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
08:32:39 <frerich> Cale: That would be one step before 'Architecture'?: http://www.linuxno.de/_data/gallery/nwl7/DSCN7825.JPG
08:32:52 <Cale> frerich: hahaha
08:33:54 <jle`> zincy: looks like traverse_
08:34:06 <Psybur> :t traverse_
08:34:07 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
08:34:38 <Psybur> traverse_ fold [Just (putStrLn "dude"), Nothing]
08:34:45 <Psybur> > traverse_ fold [Just (putStrLn "dude"), Nothing]
08:34:47 <lambdabot>  <IO ()>
08:34:50 <Psybur> % traverse_ fold [Just (putStrLn "dude"), Nothing]
08:34:50 <yahb> Psybur: dude
08:35:09 <dminuoso> travers_ was one of those things that made me appreciate how things fit together in Haskell.
08:35:17 <dminuoso> It's quite satisfying to do something like `traverse_ print stuff`
08:35:30 <jle`> zincy: oh sorry i misread
08:35:31 <fmg> Hello, Haskell god/desses: I have a question about the internals of (Mega)Parsec. I posted it to StackOverflow, since it seemed a bit long for chat. I'm posting a link here in the hope of attracting attention to my issue: https://stackoverflow.com/questions/49861020/propagation-of-megaparsec-errors-through-continuations (If this is not an appropriate use of the #haskell channel, please tell me!)
08:35:38 <jle`> i thought you said 'maybe (pure ()) f'
08:35:42 <jle`> since f is a common function name, heh
08:36:34 <jle`> :t fromMaybe (pure ())
08:36:35 <lambdabot> Applicative f => Maybe (f ()) -> f ()
08:36:45 <frerich> jle`: I was about to make a joke about how there is not a single function listed by Hayoo which is actually called 'f', so it does not seem to be common at all. I foolishly forgot about http://hackage.haskell.org/package/haskore-0.2.0.8/docs/Haskore-Melody-Standard.html#v:f ;-)
08:36:47 <jle`> then yeah that's sequence_
08:36:56 <jle`> or sequence
08:36:58 <Psybur> :t sequence_
08:36:59 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
08:37:08 <jle`> frerich: ;)
08:38:12 <Psybur> zincy, so youre saying you have a list of Maybe (IO ()) and youre trying to run all of them?
08:39:14 <zincy> :t sequence
08:39:15 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
08:39:23 <zincy> :t sequence_
08:39:25 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
08:39:39 <zincy> Psybur - Yes
08:39:49 <Psybur> % traverse_ fold [Just (putStrLn "dude"), Nothing]
08:39:49 <yahb> Psybur: dude
08:40:06 <Psybur> I think thats what you want
08:40:19 <Cale> fmg: Seems like an appropriate use, but if I answer you, it will be here, rather than on SO :)
08:40:45 <Psybur> % traverse_ fold [Just (putStrLn "dude"), Nothing, Just (putStrLn ".")]
08:40:45 <yahb> Psybur: dude; .
08:41:01 <jle`> zincy: you can also use catMaybe to get all of the just values out, and then sequence
08:41:12 <jle`> > catMaybes [Just 2, Just 3, Nothing, Just 1]
08:41:14 <lambdabot>  [2,3,1]
08:41:20 <jle`> :t sequence_ . catMaybes
08:41:21 <lambdabot> Monad m => [Maybe (m a)] -> m ()
08:41:48 <zincy> What is fold doing
08:41:54 <Psybur> Thats actually what I used in my first example https://glot.io/snippets/f0660emub5
08:42:05 <jle`> zincy: interesting thing is that the Applicative/Monad laws ensure that sequencing 'pure ()' is the same as not having the action there at all
08:42:08 <Psybur> @src fold
08:42:09 <lambdabot> Source not found. My brain just exploded
08:42:37 <jle`> zincy: so if you just get rid of the Nothing's, it's the same as replacing the nothing's with pure ()'s
08:42:49 <jle`> that's why laws are helpful :)
08:43:04 <zincy> Ah
08:43:27 <zincy> jle - is that because pure () is the identity?
08:43:45 <jle`> yeah, sequence_ [x,y,z] = x *> y *> z
08:44:03 <jle`> and x *> y *> z is the same as x *> pure () *> y *> z
08:44:15 <jle`> pure is required to not add any effects
08:44:22 <Cale> fmg: Seems more like an oversight than a design decision to me, if that's the case.
08:44:38 <Psybur> zincy, https://glot.io/snippets/f06azhdjuf
08:44:44 <zincy> :t fold
08:44:46 <lambdabot> (Monoid m, Foldable t) => t m -> m
08:44:54 <zincy> :t foldr
08:44:55 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:45:12 <zincy> So fold just lifts the type?
08:45:21 <jle`> fold here is fromMaybe (pure mempty)
08:45:29 <jle`> which works because () has a Monoid instance
08:45:54 <Psybur> zincy, https://hackage.haskell.org/package/base-4.11.0.0/docs/src/Data.Foldable.html#fold
08:45:55 <jle`> fold is basically mconcat, generalized to more containers
08:46:00 <jle`> if you're familiar with mconcat
08:46:18 <jle`> here it's treating Maybe like it was a list with 0 or 1 elements
08:46:36 <jle`> > mconcat ["hello", "world", "goodbye"]
08:46:38 <lambdabot>  "helloworldgoodbye"
08:46:41 <jle`> > mconcat (Just "hello")
08:46:44 <Cale> fmg: I can vaguely imagine it having something to do with space performance, but I'm not sure I can see how.
08:46:46 <lambdabot>  error:
08:46:48 <lambdabot>      • Couldn't match expected type ‘[a]’
08:46:51 <fmg> Cale: Worth raising an issue in the repo? Justified?
08:46:52 <lambdabot>                    with actual type ‘Maybe [Char]’
08:46:54 <jle`> s/mconcat/fold heh
08:46:54 <Taneb> > fold Nothing :: Product Double
08:46:56 <zincy> :t mconcat
08:46:56 <lambdabot>  Product {getProduct = 1.0}
08:46:57 <lambdabot> Monoid a => [a] -> a
08:47:04 <Cale> fmg: You could at least ask about it there.
08:47:49 <Psybur> > foldr mappend mempty $ Just 1
08:47:51 <lambdabot>  error:
08:47:51 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M550826608090...
08:47:51 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
08:48:07 <Cale> fmg: I'm looking at the code for megaparsec, and it looks a little different from yours
08:48:09 <jle`> zincy: mconcat [x,y,z] = x <> y <> z
08:48:20 <jle`> where <> is monoid append
08:48:28 <zincy> I understand fold now but not in the context of
08:48:28 <jle`> so like ++ for lists
08:48:28 <zincy> % traverse_ fold [Just (putStrLn "dude"), Nothing, Just (putStrLn ".")]
08:48:28 <yahb> zincy: dude; .
08:48:32 <fmg> Cale: Sounds good. I'll wait a while to see if I get any bites on SO, so that I don't have the same question (and possible answers) scattered over different sites.
08:48:45 <Psybur> :t foldr mappend mempty
08:48:46 <lambdabot> (Monoid b, Foldable t) => t b -> b
08:48:48 <jle`> zincy: yes, so fold (Just (putStrLn "dude")) is putStrLn "dude"
08:48:51 <zincy> Right so all monads are also monoids
08:48:55 <Psybur> > foldr mappend mempty $ Just ()
08:48:57 <lambdabot>  ()
08:48:58 <jle`> not all monads are monoids
08:49:08 <jle`> zincy: but 'IO a' in specific has a Monoid instance
08:49:16 <Psybur> () in this case is a monoid
08:49:26 <Taneb> jle`: it is possible to write (Applicative f, Monoid a) => Monoid (f a)
08:49:37 <jle`> indeed
08:49:45 <Psybur> And so is Monoid a => Maybe a
08:49:53 <Taneb> Although this isn't the Monoid (IO a) instance
08:49:53 <zincy> so traverse_ would evaluate each lifted io action
08:49:55 <Cale> fmg: Oh, I guess I can think of one thing...
08:50:01 <jle`> Taneb: it actually is :O
08:50:10 <Psybur> Whoops, IO () is a monoid
08:50:23 <Taneb> jle`: ah, I'm getting mixed up with the Alternative instance which I was talking about earlier today, I think
08:50:30 <jle`> zincy: be careful not to generalize things you can do with IO vs. things you can do with all monads
08:50:53 <fmg> Cale: Confession: I didn't look closely at the MegaParsec version. Added the (Mega) mostly for marketing purposes.
08:50:54 <Cale> fmg: Generally the way that Parsec parsers work is that once they consume a nonzero amount of the input, they're designed to commit to whatever branch of the sum they're on.
08:51:16 <jle`> it's a common pitfall actually
08:51:30 <jle`> "oh, this type has X feature, and it is a monad?  it must be that all monads have X"
08:51:35 <zincy> > foldr mappend mempty $ Nothing
08:51:36 <Cale> fmg: So perhaps it was regarded as confusing to report errors from another branch of the sum, when the parser was already committed to one particular branch.
08:51:37 <lambdabot>  ()
08:51:44 <jle`> that's like saying "oh, the number 9 is dividible by 3?  it must mean that all numbers are divisible by 3!"
08:51:50 <Psybur> () `mappend` mempty
08:51:54 <Psybur> > () `mappend` mempty
08:51:56 <lambdabot>  ()
08:52:07 <fmg> Cale: Then why do the 'consumed' continuations even take a 'ParseError' argument?
08:52:37 <Psybur> Seems like fold might be doing more work than fromMaybe?
08:53:06 <jle`> fold for Maybe is fromMaybe mempty
08:53:27 <Cale> fmg: You mean the cerr continuation? That only gets applied in the case that there is an error...
08:53:40 <Psybur> Its foldMap id
08:54:04 <jle`> sure, but fromMaybe x is just maybe x id
08:54:14 <jle`> some people actually prefer maybe x id over fromMaybe x
08:54:37 <monochrom> Probably just to avoid another import line :)
08:54:53 <jle`> Psybur: foldMap = maybe mempty, http://hackage.haskell.org/package/base-4.11.0.0/docs/src/Data.Foldable.html#line-274
08:55:09 <fmg> Cale: No, I totally mean cok. It has signature (a -> State s u -> ParseError -> m b)
08:55:19 <dfeuer> Because maybe is more general, and also because it's in the prelud.
08:55:23 <dfeuer> e.
08:55:24 <Cale> hmm
08:55:25 <Boarders> church encoded version is nicer imo
08:55:39 <Cale> okay, that's also different in MegaParsec :D
08:55:46 <Cale> Lemme go find the Parsec code
08:55:53 <jle`> it's also weird when the name of a function is longer than its definition
08:56:00 <jle`> fromMaybe x
08:56:02 <jle`> maybe x id
08:56:04 <Taneb> :t traverseOf
08:56:05 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
08:56:07 <zincy> So calling traverse_ over a list of Maybe (IO a) wouldn't actually evaluate the actions it would just lift the type? So to evaluate them all you would call sequence on the result right?
08:56:16 <Taneb> (the definition of traverseOf is id)
08:56:17 <jle`> zincy: traverse_ is a map + sequence
08:56:36 <fmg> Cale: https://hackage.haskell.org/package/parsec-3.1.13.0/docs/src/Text.Parsec.Prim.html#ParsecT
08:56:37 <jle`> zincy: you're right that you need to sequence the result, but traverse includes the sequence
08:56:39 <Cale> yeah
08:56:41 <Cale> I see
08:56:42 <zincy> ah
08:56:45 <zincy> cool
08:56:45 <monochrom> @type traverse_
08:56:47 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
08:56:48 <jle`> zincy: traverse f x = sequence (fmap f x)
08:56:54 <zincy> So where is the sequence call happening - traverse_ f = foldr ((*>) . f) (pure ())
08:56:57 <Cale> I'm not sure there's actually a good reason for that continuation to take a ParseError
08:57:04 <Cale> seems a bit odd anyway
08:57:09 <zincy> :t (*)
08:57:09 * hackage shellwords 0.1.1.0 - Parse strings into words, like a shell would  http://hackage.haskell.org/package/shellwords-0.1.1.0 (PatrickBrisbin)
08:57:10 <lambdabot> Num a => a -> a -> a
08:57:14 <zincy> :t (*>)
08:57:15 <lambdabot> Applicative f => f a -> f b -> f b
08:57:35 <fmg> Cale: Another point to add to my hypothetical github issue.
08:57:58 <jle`> zincy: that's what the (*>) is
08:58:02 <jle`> sequence_ [x,y,z] = x *> y *> z
08:58:12 <Cale> fmg: Have a look at Megaparsec's version of the same: https://hackage.haskell.org/package/megaparsec-6.5.0/docs/src/Text-Megaparsec-Internal.html#ParsecT
08:58:32 <Cale> fmg: Instead of passing along an error, it seems to pass along "Hints"
08:58:41 <jle`> zincy: sequence_ is *>-ing together all of the items in a container
08:58:57 <jle`> zincy: so you can say that the sequence is "inlined"
08:58:58 <Cale> fmg: I suspect the purpose is the same though
08:59:23 <jle`> if a type is a Functor, then traverse_ f = sequence_ . fmap f
08:59:31 <Cale> fmg: If you scroll up a bit in the Megaparsec version, you'll find the Hints type and some documentation about what it's for
08:59:37 <jle`> but sequence_/traverse_ has to be defined for types that aren't Functor's
08:59:49 <jle`> so it can't directly use fmap
09:00:13 <jle`> similarly, for lists, traverse_ f = sequence_ . map f
09:00:18 <jle`> but sequence_ has to be defined for types that aren't lists
09:00:27 <jle`> since only lists can use 'map'
09:01:31 <fmg> Cale: Ok. Thought understanding Parsec before MegaParsec would be the way to go. Maybe not! I'd like to find some parser in the Parsec library where the cok continuation actually gets passed a nonempty ParseError sequence...
09:01:32 <Cale> fmg: So the idea is that if the first thing doesn't manage to consume input before failing, it still can report information about what it was looking for.
09:02:07 <Cale> fmg: But of course, if the first thing consumes input, the second isn't supposed to be used at all anyway
09:03:27 <Cale> Pretty fiddly
09:05:18 <Cale> fmg: So we pass the merge of the "errors" along in the neok continuation, just because if the eok continuation happens to fail without consuming input, the error it reports will want to know what things to report that the parser was expecting beforehand.
09:06:14 <Cale> fmg: It's probably better to think of these 'error' things as containing information about what set of things the parser was expecting to see.
09:06:20 <fmg> Cale: Right. That justifies having a ParseError argument in eok...
09:09:08 <Cale> fmg: For example, have a look at the implementation of (<?>) whose job it is to set that explicitly.
09:09:34 <Cale> https://hackage.haskell.org/package/parsec-3.1.13.0/docs/src/Text.Parsec.Prim.html#%3C%3F%3E (all the work happens a few lines down in 'labels')
09:10:33 <Cale> So yeah, the terminology is just a little confusing.
09:14:48 <fmg> Cale: In Parsec, label doesn't touch cok.
09:16:08 <Cale> fmg: ah, good point
09:16:42 <Cale> fmg: I suspect that's because if it failed after having consumed input here, the hints about what were supposed to come next are the ones from that later point it was at when it failed
09:18:15 <fmg> Cale: But in MegaParsec, cok is massaged in the pLabel function (<?> is defined in terms of this). Seems like a nice idea of MegaParsec for cerr and eerr to take a ParseError parameter while cok and eok take Hints, instead.
09:18:37 <woodson> has anyone tried using concur ?
09:20:41 <Cale> fmg: yeah
09:23:42 <fmg> Cale: gotta go to a meeting. Huge thanks for your help!!
09:30:07 <pbodev1> test
09:30:38 <shapr> Is there a list of other libraries along the lines of conal's checkers and drew's quickcheck-classes?
09:31:20 <shapr> pbodev1: your test has passed
09:32:05 <jle`> @check test
09:32:07 <lambdabot>  +++ OK, passed 100 tests.
09:35:44 <pbodev1> shapr: it was soo quiet :))
09:37:39 <Wizek> lemmih: So, I've had success with the latest iteration of the MapLike class. This seems to type check and work:  https://gist.github.com/Wizek/09f6f4d22a4047f6c4e07e49e25f369a
09:38:49 <dmj`> which base did FTP land in again?
09:39:52 <Wizek> lemmih: but I'm a bit concerned with the accumulation of constraints on the class methods. Is there any way to sidestep that?
09:40:42 <Wizek> Because as it stands this class doesn't seem to be very extensible with instances: new instances will likely require new constraints on the class methods too
09:41:30 <jle`> Wizek: you can make it a multi parameter typeclass
09:41:56 <jle`> class MapLike (k :: *) (m :: * -> * -> *) | m -> k
09:42:04 <jle`> then the constraints would go on the instance declarations
09:42:19 <jle`> instance Ord k => MapLike k (Map k) where ...
09:42:42 <jle`> hm, same for the 'v'
09:43:53 <Wizek> jle`: yeah, I've been experimenting in that direction too: https://gist.github.com/Wizek/08f44a19b7b4f596d31b7c0038056df8 . So you mean something like the first or second here?
09:44:40 <jle`> yeah, those could work
09:45:32 <jle`> the second one would cause you trouble
09:45:38 <jle`> but the first and third one are probably useful
09:46:19 <Wizek> hmm, I remember having trouble with all 3 of these, not sure by this point what the problem was
09:47:03 <jle`> i know the feeling
09:47:05 <lemmih> Wizek: This kind of golfing is fun but I don't think it's worth abstracting over maps in production code, fyi.
09:47:22 <jle`> i tell myself i'll write down my thoughts next time but i never do
09:48:09 <Wizek> lemmih: this is actually supposed to solve a very practical problem, I promise!
09:48:10 <hyperisco> figure out what new useful instances are possible to decide whether the generalisation is worth it
09:48:29 <hyperisco> also be careful to consider how else you might do the same thing
09:49:04 <albeit> If I'm using Network.Socket.ByteString.Lazy.sendAll, how do I know when the data is actually sent? Is it even possible to know, given it's lazy?
09:49:23 <jle`> if you're actually doing this for something useful, then maybe consider looking at a how the mono-traversable library han
09:49:27 <jle`> since it has a map-like typeclass
09:49:28 <albeit> It seems like if I call it twice, the first send works, but the receiver never gets the second send.
09:50:20 <hyperisco> if there is no definition polymorphic to the constraint then it is a useless parameter
09:51:09 <hyperisco> useless as an abstraction… possibly useful as abbreviation. I've done that.
09:51:17 <Wizek> lemmih: one of the instances is containing this: https://hackage.haskell.org/package/vcache-trie Which is very nice for transparent ACID persistance, but for testing purposes it makes much of my code impure by requiring a DB connection to to be passed in when constructing a map
09:51:36 <Wizek> lemmih: so I want to make these functions polymorphic so they can accept Data.Map too
09:52:08 <Wizek> And all should be identical sans persistence and purity.
09:53:01 <hyperisco> so sounds like abbreviation then
09:53:29 <hyperisco> you want to write  lookup  instead of  Trie.lookup  or  Map.lookup
09:55:29 <jle`> Wizek: also note that if you only want to lookup/insert, then that is all implementable in terms of 'at'
09:55:38 <jle`> if you just define or provide 'at'
09:55:49 <jle`> 'update' too
09:56:02 <Wizek> Much is implementable through at, yes
09:56:07 <jle`> just not functions like fromList
09:57:50 <Wizek> jle`: I think I remember! With a multi param class, if I have `MyData Map.Map`, `MyData HashMap.Map`, would I write `MapLike map k v => MyData map`? IIRC I've had problems with that k and v there at one place
09:58:11 <jle`> what would MyData be
09:58:29 <jle`> oh, yeah, that's how you'd write it
09:58:57 <jle`> but i'm not sure where it is an issue
10:03:52 <Psybur> :t Map.Map
10:03:54 <lambdabot> error:
10:03:54 <lambdabot>     Not in scope: data constructor ‘Map.Map’
10:03:54 <lambdabot>     No module named ‘Map’ is imported.
10:04:33 <[exa]> maybe you meant
10:04:36 <Wizek> Psybur: it's in the Data.Map package
10:04:37 <[exa]> :k Map
10:04:38 <lambdabot> error:
10:04:38 <lambdabot>     Not in scope: type constructor or class ‘Map’
10:04:38 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
10:04:49 <[exa]> :k M.Map
10:04:50 <lambdabot> * -> * -> *
10:05:03 <[exa]> qualified as M
10:06:29 <Psybur> Where does MapLike come from? All I can see is something from monad-memo
10:07:32 <Psybur> Or would you be rolling your own D:
10:08:46 <Wizek> Psybur: if you read back, I've been experimenting with writing this: https://gist.github.com/Wizek/09f6f4d22a4047f6c4e07e49e25f369a
10:10:18 <equwal> I got >:k Map to work, do >import Data.Map first
10:10:42 <equwal> Doesn't really help, as it is Map :: * -> * -> *
10:11:22 <Wizek> jle`: btw, this could be a definition: `data MyData map = MyData (map Int String) (map Char Bool)`
10:11:41 <gentauro> does anybody know where to find the logo from Simon Marlows t-shirt? -> https://www.youtube.com/watch?v=sT6VJkkhy0o
10:12:00 <gentauro> (combination of Facebook logo + lambda
10:12:02 <gentauro> )
10:12:37 <Wizek> jle`: and yeah, I'm starting to remember further that the type error for `MapLike map k v => MyData map` was something like `Cannot unify 'map k v' with 'map k0 v0'`
10:12:48 <Wizek> for the 3-param type class
10:13:25 <Wizek> jle`: And that makes sense, doesn't it? As `MapLike map k v => MyData map` does want to choose single mono types for both k and v, doesn't it?
10:14:09 * hackage gi-webkit2 4.0.16 - WebKit2 bindings  http://hackage.haskell.org/package/gi-webkit2-4.0.16 (inaki)
10:14:44 <Wizek> jle`: `MapLike map (forall k. k) (forall v. v) => MyData map` Could something like this make sense semantically here?
10:15:01 <Wizek> And would this need QuantifiedConstraints?
10:15:30 <lsund> getCurrentTime returns 5:15PM instead of 19:15PM like my system clock and `date` in shell. What can be the cause for this?
10:15:49 <Wizek> lsund: It returns UTC time
10:16:00 <Wizek> lsund: UTCTime, to be more precise
10:16:07 <Eduard_Munteanu> @hoogle zoned
10:16:07 <lambdabot> Data.Time.LocalTime zonedTimeToLocalTime :: ZonedTime -> LocalTime
10:16:07 <lambdabot> Data.Time.LocalTime zonedTimeToUTC :: ZonedTime -> UTCTime
10:16:07 <lambdabot> Data.Time.LocalTime zonedTimeZone :: ZonedTime -> TimeZone
10:16:38 <lsund> ok
10:17:09 <lsund> Thanks!!!
10:17:40 <Eduard_Munteanu> @hoogle localtime
10:17:40 <lambdabot> Data.Aeson.Encoding localTime :: LocalTime -> Encoding' a
10:17:40 <lambdabot> Data.Aeson.Encoding.Internal localTime :: LocalTime -> Encoding' a
10:17:40 <lambdabot> FRP.Yampa localTime :: SF a Time
10:18:06 <cocreature> lsund: you can use "getZonedTime" instead
10:18:10 * hackage gi-webkit2 4.0.17 - WebKit2 bindings  http://hackage.haskell.org/package/gi-webkit2-4.0.17 (inaki)
10:18:37 <cocreature> which is just a wrapper around getCurrentTime, getTimeZone and utcToZonedTime
10:19:24 <Akii> trying to build my project with nix/cabal: http://lpaste.net/8608131273216491520 Anyone got an idea what goes wrong? Don't even know if this is because of nix or Cabal at this moment.
10:20:07 <cocreature> Akii: the version of base is tied to the version of GHC
10:20:18 <cocreature> https://wiki.haskell.org/Base_package has a mapping between the two
10:20:39 <albeit> If I read from a socket using conduits, does it make sense to temporarily store the data in a Chan or just consume it in a sink directly?
10:22:05 <Akii> oh my
10:22:11 <Akii> how did this ever build with stack
10:22:51 <sclv> stack probably was tied to an old lts that pulled in an old ghc
10:23:05 <cocreature> I’m not sure where that constraint is coming from, https://hackage.haskell.org/package/datetime-0.3.1 doesn’t seem to have it
10:24:31 <cocreature> Akii: can you show us the stack config?
10:25:17 <Akii> sure http://lpaste.net/364881
10:26:29 <cocreature> interesting, lts 9.21 has GHC 8.0.2 which comes with base 4.9
10:27:42 <Akii> maybe it's related to nix?
10:27:58 <Akii> I just through the cabal file into cabal2nix and tried building it
10:28:02 <cocreature> maybe, I’m failing to see where that base < 4.9 constraint is coming from
10:29:20 <sclv> ok, what's the cabal file?
10:29:35 <sclv> i bet it has the constraint on base in it
10:30:02 <cocreature> afaict it’s trying to build the datetime in version 0.3.1 package which only has a < 5 constraint on base
10:30:49 <Akii> sclv nope
10:31:34 <Akii> http://lpaste.net/5102596876234915840
10:31:44 <cocreature> (things are going to be painful if GHC ever upgrades the version number of base to 5.x)
10:32:00 <Akii> didn't bother to fill out githubuser so nothing really makes sense :P
10:35:07 <sclv> weird
10:35:35 <Akii> hm
10:36:56 <Akii> maybe it's a dependency of datetime
10:37:02 <cocreature> I feel like it’s some really silly thing but I can’t find it :/
10:37:20 <Akii> nope
10:38:09 <Akii> and this time I haven't even gotten to the fsnotify dependency
10:40:27 <cocreature> Akii: can you show us the *.nix files you’re using?
10:40:50 <Akii> those are secret!
10:40:54 <Akii> nah jk, coming up
10:41:18 <Akii> http://lpaste.net/5697214315019370496
10:41:43 <Akii> http://lpaste.net/364882
10:42:33 <cocreature> Akii: and <nixpkgs> points to something reasonably up2date I assume?
10:44:27 <Akii> cocreature just to be sure: how would I check that?
10:44:35 <Akii> nix-channel update or smth?
10:45:20 <cocreature> by default it uses your channel which you can update using "nix-channel --update" but you can also set the path to <nixpkgs> using the NIX_PATH env var
10:46:34 <Akii> I did the update, didn't really say much other than it created 2 symlinks
10:46:42 <Akii> but also didn't fix the problem
10:46:56 <Akii> had to use sudo though
10:47:08 <cocreature> then I’m out of ideas, sry :/
10:47:49 <Cale> What's the problem?
10:48:03 <cocreature> Cale: http://lpaste.net/8608131273216491520
10:48:19 <cocreature> Cale: the weird part is that datetime doesn’t seem to have a base < 4.9 constraint
10:48:51 <Cale> One of its dependencies might?
10:49:02 <Akii> nope, checked that
10:49:20 <cocreature> also the build should fail for the deps in that case, no?
10:49:36 <Cale> ah, yeah, probably
10:50:35 <cocreature> huh I can reproduce this with "nix run nixpkgs.haskellPackages.datetime"
10:51:15 <Cale> I was just trying similar from the nix repl
10:51:22 <Cale> yep
10:52:55 <int-e> pff. "How would you use a robot?" "I would use it to ask my mom really hard math questions."
10:52:58 <cocreature> ah it’s the test suite
10:53:06 <int-e> (oops, maybe this wasn't the right channel)
10:53:10 <cocreature> apparently the constraint on hackage is only based on the bounds of the lib
10:53:12 <cocreature> which are < 5
10:53:18 <cocreature> but the test suite has a < 4.9 constraint
10:53:24 <Cale> ahhh
10:54:15 <cocreature> Akii: try disabling the test suite
10:54:16 <Cale> Well, I know what I'd do in our funky reflex-platform world of nix :D
10:54:58 <cocreature> https://github.com/Gabriel439/haskell-nix/tree/master/project3#tweaking-haskell-projects has some examples of how you can do that
10:56:05 <barbi> can you please give an example how this type is usefull?
10:56:06 <barbi> type Pair a = (a,a)
10:56:15 <barbi> where can i use it?
10:56:33 <monochrom> Two endpoints of an interval?
10:57:10 <barbi> well i want another thing/ how can i use now Pair a. what should i do?
10:57:36 <monochrom> Use it as though you were using (a,a) directly?  Because type synonym?
10:57:49 <Cale> cocreature: ahh, dontCheck exists in nixpkgs :)
10:57:52 <iqubic> barbi: What are you trying to do?
10:58:02 <zincy> What data structure should I use for a list of things that need to be searched frequently by Id
10:58:11 <barbi> i dont understand how can i use it in type decleration.
10:58:26 <Akii> cocreature will try
10:58:27 <barbi> in a function
10:58:30 <iqubic> Just use (a,a) instead.
10:58:56 <Cale> cocreature, Akii: I can confirm that applying dontCheck to the datetime derivation fixes it.
10:59:04 <aarvar> zincy: a Map?
10:59:06 <cocreature> zincy: Data.Map/Data.IntMap/Data.HashMap
10:59:26 <barbi> for example i understnad this: type Mozes = [Int] so now i can have: mozes :: int -> Mozes
10:59:27 <zincy> Thanks guys!
10:59:46 <barbi> how do i use Pair a?
11:00:15 <Cale> barbi: try  foo :: Pair Int
11:00:18 <Cale> foo = (4,5)
11:00:30 <barbi> OH thanks!
11:00:58 <Cale> diagonal :: a -> Pair a
11:01:03 <Cale> diagonal x = (x,x)
11:01:41 <aarvar> diagnol = join (,)
11:01:54 <aarvar> *diagonal
11:04:42 <Akii> Cale how do you apply this dontCheck?
11:05:36 <Akii> oh, wait I think I see it
11:07:30 <cocreature> Akii: I’ve linked some exapmle code above
11:07:51 <Akii> currently trying to adapt that: http://lpaste.net/364886
11:07:51 <zincy> How do hashmaps work, is the key a hash of the value?
11:08:12 <monochrom> You just give the key.  Hashing is done for you.
11:08:13 <Akii> however unsuccessful so far
11:09:00 <cocreature> Akii: you forgot the "inherit config" part
11:09:48 <zincy> monochrom - thanks
11:10:16 <Akii> oh :D
11:10:17 <zincy> I guess hashmap is more performant than normal maps but I am not sure why
11:10:50 <Akii> oh boy, things are happening
11:11:11 <Cale> zincy: Well, it depends on how the thing gets used. I've seen Data.Map beat Data.HashMap sometimes. Really you have to test.
11:11:12 <Akii> and now it compiles everything, but I guess that's normal
11:11:35 <Akii> pretty sure it'll fail on fsnotify xD eventually
11:12:28 <Akii> thank you Cale and cocreature !
11:12:31 <Cale> zincy: The main thing which helps hashtables beat tree-based things is memory locality -- you can store an array of the buckets together, so repeated accesses are more likely to hit the cache.
11:12:41 <Guillaum> zincy: internaly, hashmap (in unordered-containers) use a kind of tree with a really large number of childs per node. So each time you go down one level of the hierarchy, you divid by something like 16 the number of node to check. On the other hand, Map from containers only divid by 2 (as far as I know). Second point, hashing an expression once and comparing the hash N times can be quicker than
11:12:47 <Guillaum> comparing an expression N times.
11:12:48 <Cale> zincy: HashMap is like a tree of hashtables though.
11:13:28 <Cale> Yeah, though hashing isn't free -- I've had it be the case that doing a bunch of Ord comparisons was cheaper than hashing the key to look up.
11:14:01 <Guillaum> Cale: obviously, it really depends on your datastructure ;) And your point about cache is perhaps the most important reason ;)
11:14:12 <zincy> Oh my I don't even know what a hashtable is I should really learn the basics of data structures
11:14:36 <Cale> Asymptotically it's a bit of a wash: any hash which can distribute things into n buckets takes at least O(log n) time to compute.
11:15:04 <Cale> But often people ignore that n, and call it O(1) anyway, which is a bit funny.
11:15:26 <Guillaum> zincy: be careful, there is multiples way hash based structure can be implemented, as a tree, or an array with collision (this is what is implemented in language with mutation, such as python, C++, ...)
11:17:09 <Guillaum> Cale: well, complexity is something difficult ;) We always ignore memory, constant factor and "roughly O(1) stuffs"
11:17:09 <Akii> one question remains: how does Cabal figure out what versions to use? Stack has like their fixed versions but here I just said: install these packages; I don't care which version
11:17:22 <sclv> the constraints tell it
11:17:31 <Akii> yeah but I defined none
11:17:33 <sclv> it looks at a package, and the transitive dep closure
11:17:40 <sclv> well then it tries the latest possible
11:17:43 <Guillaum> Akii: it takes a best candidate which satisfy constraints
11:17:53 <Akii> and that's a cabal thing? unrelated to nix?
11:17:54 <sclv> also constraints will flow down from the nix-packages repo often
11:18:02 <sclv> right
11:18:05 <sclv> the solver is standard cabal
11:18:13 <sclv> but if you use the nix haskell packages repo, that has fixed versions
11:18:22 <Guillaum> (Akii, in this context, nix does not have any solver, it is more like stack, a snapshot)
11:18:41 <Akii> aha! starting to get the bigger picture
11:19:35 <sclv> i don't remember what drives the versions in nix
11:19:58 <Akii> getting a lot of clang "-nopie" warnings
11:20:02 <Akii> why is there no pie in clang?
11:20:06 <sclv> if its just warnings that's safe
11:20:18 <Akii> yeah but but but the pie!
11:20:28 <sclv> pie = position independent executables
11:20:31 <Akii> oh
11:20:31 <Guillaum> sclv: the current channel, imagine a big static list of package and associated version
11:20:35 <sclv> there's a maze of settings of different compiers
11:20:37 <Akii> wow
11:20:45 <sclv> for who enables pie-hardening or not
11:20:56 <sclv> and ghc tries to pass the right flags so it works with them
11:21:10 <sclv> and sometimes it might be configured to pass flags that aren't necessary and you get warnings
11:21:39 * hackage shakers 0.0.46 - Shake helpers.  http://hackage.haskell.org/package/shakers-0.0.46 (markfine)
11:21:44 <sclv> Guillaum: right. i just mean i don't remember if the maintainers try to keep it close to a stackage lts release, or just do their own thing entirely, or what policies they have
11:23:28 <Guillaum> sclv: (I don't really know for the haskell package in nix, but for most other packages, maintainers decide to bump the version on a per package basis)
11:23:49 <ph88> is it possible to do a traverse with lens in pairs? so if input is A, B, C, D. To get (A, B), (B, C), (C, D)
11:28:02 <Psybur> Lets say I have a list of tuples of maybes. How would I modify asuml to turn [(Nothing, Just 2), (Just 1, Just 3)] into (Just 1, Just 2) ?
11:28:20 <Psybur> :t asuml
11:28:21 <lambdabot> error:
11:28:21 <lambdabot>     • Variable not in scope: asuml
11:28:21 <lambdabot>     • Perhaps you meant ‘asum’ (imported from Data.Foldable)
11:28:25 <Psybur> :t asum
11:28:26 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
11:28:57 <Psybur> Maybe just unzip
11:29:17 <jle`> Wizek: that's a kind error earlier
11:30:15 <jle`> Wizek: or, er, depending on how you'd unify it
11:30:55 <jle`> Wizek: if you do MyData map = MyData (map Int String) (map Char Bool), then the constraint would be (MapLike map Int String, MapLike map Char Bool) => MyData map -> ...
11:31:52 <Garmy> Psybur, it should return a tuple and not a list?
11:32:02 <zincy> If I am using IntMap and want to insert an item with a key that is not currently taken, what would be the best way of achieving this? I am not even sure if Ints are the best keys to represent an Id for each item?
11:32:04 <Psybur> Yes
11:32:05 <Garmy> Whoops, misread
11:32:31 <Wizek> jle`: hmm, interesting. Is this duplication necessary though? `MapLike map Int String, MapLike map Char Bool`
11:33:15 <jle`> oh sorry, i mistyped
11:33:34 <jle`> (MapLike (map Int String) Int String, MapLike (map Char Bool) Char Bool) =>
11:34:10 <lemmih> zincy: You could lookup the largest key. Either with maxViewWithKey or findMax.
11:34:23 <Cale> zincy: You might be able to use lookupMax
11:34:25 <Garmy> Psybur: You could make an Alternative instance for "(Alternative a, Alternative b) => Alternative (a, b)"?
11:34:45 <jle`> and, yes it would be, until we get that new QuantifiedConstrains extension in ghc :)
11:34:48 <Cale> Be careful: findMax will error if you apply it to an empty Map
11:34:51 <jle`> which should be arriving any month now
11:35:27 <Wizek> jle`: hmm, interesting that I wasn't sure if I would find QC useful, and here I am, stumbling into a potential usecase.
11:36:02 <jle`> yeah, you'd write something like (forall k v. SomeConstraintsOnKAndV => MapLike (map k v) k v)
11:36:16 <jle`> hm, alternatively you can have type families giving the constraints
11:36:22 <Psybur> > > Data.IntMap.insertWith (flip const) 1 3 $ Data.IntMap.insert 1 2 $ Data.IntMap.empty
11:36:25 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
11:36:26 <Psybur> > Data.IntMap.insertWith (flip const) 1 3 $ Data.IntMap.insert 1 2 $ Data.IntMap.empty
11:36:27 <jle`> so if you have class MapLike m where
11:36:28 <lambdabot>  fromList [(1,2)]
11:36:38 <jle`> type KeyCosntr m :: * -> Constraint
11:36:44 <jle`> type ValConstr m :: * -> Constraint
11:36:55 <Psybur> Is that what youre asking for zincy?
11:37:00 <jle`> then you'd have instance MapLike Map where type KeyConstr Map = Ord
11:37:02 <Psybur> Insert a value if the key doesnt already exist?
11:37:12 <Taneb> > au (bimapping (_Wrapping First) (_Wrapping First)) foldMap [(Nothing, Just 2),(Just 1, Just 3)] -- Psybur
11:37:13 <jle`> type ValConstr Map = ()
11:37:15 <lambdabot>  (Just 1,Just 2)
11:37:41 <Psybur> :t au
11:37:42 <lambdabot> Functor f => AnIso s t a b -> ((b -> t) -> f s) -> f a
11:37:57 <Psybur> What is this sorcery
11:38:08 * hackage key-state 0.2.0 - Manage key and button states and statuses  http://hackage.haskell.org/package/key-state-0.2.0 (jxv)
11:39:17 <Taneb> Psybur: honestly I've never used it before
11:39:24 <jle`> Wizek: and you'd have insert :: (KeyConstr m k, ValConstr m v) => k -> v -> m k v -> m k v
11:39:52 <Taneb> Basically, it's mapping First over each of the tuple elements, doing a fold, and then mapping getFirst
11:40:10 <Taneb> I don't quite understand how it works myself
11:42:42 <Wizek> jle`: Let's go back a bit. Why would you write `MapLike (map Int String) Int String` instead of `MapLike map Int String`? Why not have `MapLike :: (* -> * -> *) -> * -> * -> Constraint`?
11:43:05 <Taneb> Wizek: IntMap is a thing
11:43:09 * hackage checksum 0.0 - Compute and verify checksums of ISBN, IBAN, etc.  http://hackage.haskell.org/package/checksum-0.0 (HenningThielemann)
11:43:28 <jle`> Wizek: that's hwo the fundep version works
11:43:39 * hackage shakers 0.0.47 - Shake helpers.  http://hackage.haskell.org/package/shakers-0.0.47 (markfine)
11:43:42 <jle`> class MapLike m k v | m -> k, m -> v
11:44:02 <jle`> k and v have to be inferrable from 'm'
11:44:08 <jle`> like MonadState s m | m -> s
11:44:15 <jle`> that's why (State s) is an instance of MonadState, and not State
11:44:22 <jle`> we have instance MonadState s (State s)
11:44:52 <Wizek> Taneb: fair point
11:45:54 <jle`> and if you had some newtype IntState a = IS { runIS :: Int -> (a, Int) }
11:46:02 <jle`> you could write instance MonadState Int IntState where ...
11:46:24 <jle`> the point of the fundep is that the 'm' should give you enough information to determine the s/k/v
11:46:32 <Wizek> :i MonadState
11:46:42 <jle`> no :i in lambdabot
11:46:49 <dpyro> if i have a `f Maybe a` and i want to modify the a, how would I go about that?
11:46:54 <dpyro> something like fmap.fmap ?
11:47:00 <jle`> but class MonadState s m | m -> s where get :: m s; put :: s -> m ()
11:47:08 <jle`> dpyro: do you mean f (Maybe a) ?
11:47:14 <Guillaum> jle`: can any fundep can be written using a type family or there is some which cannot?
11:47:14 <dpyro> yes
11:47:15 <jle`> or actually f Maybe a ?
11:47:24 <dpyro> f (Maybe a)
11:47:25 <jle`> Guillaum: type families is more powerful than fundeps i believe
11:47:34 <jle`> dpyro: if f is a Functor, you can (fmap . fmap)
11:47:41 <Guillaum> jle`: thanks.
11:48:28 <dpyro> that's just crazy enough to work :D
11:48:31 <jle`> :t (fmap . fmap)
11:48:32 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
11:48:39 <jle`> dpyro: you can think of it as fmap lifts a function up one level of functor
11:48:40 <Akii> currently wondering if classy-prelude dropped `fork`
11:48:43 <jle`> so fmap twice lifts a function twice
11:48:52 <jle`> fmap :: (a -> b) -> (f a -> f b)
11:49:08 <dpyro> \o/
11:49:10 <jle`> fmap . fmap :: (a -> b) -> (g (f a) -> g (f b))
11:49:25 <jle`> fmap . fmap . fmap :: (a -> b) -> (h (g (f a)) -> h (g (f b))) etc.
11:50:39 * hackage preamble 0.0.61 - Yet another prelude.  http://hackage.haskell.org/package/preamble-0.0.61 (markfine)
11:51:32 <dpyro> now is there a way to extend a data type? say it has 3 fields, for a different data type you want those same 3 fields and 2 more
11:51:45 <jle`> yes
11:51:54 <dpyro> what's the haskelly way?
11:52:01 <jle`> data HasAFooPlusMore = HAFPM Foo Int
11:52:21 <dpyro> so its nesting?
11:52:49 <jle`> yeah nesting is one way
11:53:40 <Akii> I can tell Cabal to use a certain GHC version by adjusting the dependency `base` right?
11:54:54 <sclv> no
11:55:00 <sclv> cabal uses whatever ghc is in the path
11:55:10 <sclv> you can pass a -with-ghc=XXX flag
11:55:14 <sclv> to direct to another binary elsewhere
11:56:20 <Akii> okay because my build is failing
11:56:27 <Akii> it actually got to the point where it builds my thing
11:56:39 <Akii> but I assume `fork` is no longer in classy-prelude
11:56:47 <Akii> so this must be a version thing
11:57:05 <Akii> which is why I wanted it to build on roughly the versions I use with stack
11:58:15 <Akii> meanwhile I just go up with stack to see if I can reproduce and fix
11:58:36 <Wizek> I wonder, do a few/some/many people define? `type a :$ b = a b`
11:58:48 <Welkin> Akii: you can use cabal (new-)freeze to pn exact dependencies
11:59:30 <Welkin> pin*
11:59:33 <Welkin> no guessing required
11:59:34 <Akii> yeah but I have this weird stack / cabal mix atm
11:59:39 <Welkin> get rid of stack
11:59:42 <Welkin> just use cabal new-*
11:59:47 <Akii> :D
11:59:47 <Welkin> or use nix with cabal
11:59:57 <Akii> that's what I'm trying to do
12:00:09 <Akii> I'll get there eventually
12:00:34 <Welkin> cabal new-* requires no effort at all
12:00:38 <Welkin> just type cabal new-build
12:00:42 <Welkin> and it is done
12:00:57 <Akii> that will magically convert my stack project? ^^
12:01:08 <sclv> nope :-)
12:01:16 <Welkin> cabal new-build uses a new dependency resolver
12:01:27 <Welkin> try it and see how it works
12:01:43 <sclv> yes, if you read the scrollback they've been doing that already
12:01:48 <sclv> we're further in the process now
12:01:50 <Welkin> you can specify a few versions of some packages in your cabal file
12:01:52 <Welkin> then let it do the rest
12:02:04 <Welkin> sclv: I don't have any scrollback
12:02:35 <sclv> fair nuff
12:02:46 <Akii> good old IR
12:02:47 <Akii> C
12:03:18 <sclv> probably better to try to update the project to work with the latest versions than to push the version deps back imho
12:03:43 <Akii> yeah, thought so as well; I pushed up stack to the latest thing now
12:03:53 <Akii> fix the errors then see if it compiles with cabal, then stick to cabal
12:20:41 <fresheyeball> hey
12:20:46 <fresheyeball> hey
12:21:09 <fresheyeball> do all functions that can be defined in terms of foldl suffer from the same performance problems addressed by foldl' ?
12:21:36 <fresheyeball> would nub infact be better as nub' with strictness in there?
12:21:58 <merijn> fresheyeball: Almost all of them, yes
12:22:11 <fresheyeball> merijn: that is highly disturbing
12:22:14 <merijn> fresheyeball: nub is a bad example, because nub is terrible *anyway* ;)
12:22:27 <fresheyeball> merijn: why is nub terrible?
12:22:35 <Welkin> O(n^2) performance
12:22:40 <merijn> fresheyeball: Yes, and people repeatedly advocate for removing foldl renaming foldl' to foldl, but people are too afraid of breaking shit
12:22:44 <merijn> And yes, nub is quadratic
12:23:04 <fresheyeball> merijn: its faster than (Set.toList . Set.fromList) no?
12:23:19 <Welkin> that is linear
12:23:22 <merijn> fresheyeball: Almost definitely not, except for trivially small data sets
12:23:22 <Welkin> so not at all
12:23:34 <Welkin> fromList and toList run in linear time
12:23:34 <Welkin> o.o
12:23:37 <Welkin> much faster
12:23:38 <merijn> Welkin: Not linear, O(n log n), but still
12:23:44 <fresheyeball> how can the Set version be faster??? wtf?
12:23:52 <merijn> fresheyeball: Because Set requires Ord
12:24:13 <fresheyeball> ah
12:24:16 <merijn> fresheyeball: So it's basically "sort + filter duplicates" and after sorting the duplicates is linear, so the total is O(n log n)
12:24:33 <merijn> fresheyeball: nub only has an Eq constraint, so it has to pairwise compare *all* elements
12:24:45 <fresheyeball> I see
12:24:58 <fresheyeball> so who wants to write a big ass library of this?
12:25:05 <fresheyeball> Data.Foldable.BestPractices
12:25:11 <fresheyeball> WHO!?
12:25:15 <Welkin> the Doctor
12:25:19 <merijn> fresheyeball: Tekmo and he already did ;)
12:25:23 <merijn> @hackage foldl
12:25:23 <lambdabot> http://hackage.haskell.org/package/foldl
12:25:34 <Welkin> also, there is no such thing as "best practices"
12:25:45 <Welkin> you can't make such a generalization
12:25:48 <merijn> fresheyeball: So there you go, problem solved ;)
12:26:08 <dsal> What kind of thing breaks in foldl -> foldl' ?
12:26:32 <Welkin> "best practices" are for dum dums who don't want to think for themselves and don't want to accept responsibility when something goes wrong
12:26:33 <merijn> dsal: Probably nothing, but people are paranoid and conservative
12:26:54 <fresheyeball> merijn: WOOOOOO!!!!!!!
12:26:59 <fresheyeball> WOOOOO!!!!!!!
12:27:06 <fresheyeball> HELL YEAH!
12:27:10 <dsal> Makes sense.  We should break things.  Down with ++
12:27:17 <dsal> RMA return
12:27:26 * dsal makes protest signs
12:27:33 <Welkin> I pretty much always use <> anyway
12:28:08 <fresheyeball> merijn: is the Fold type basically a Transducer?
12:28:18 <Welkin> what is a transducer?
12:28:24 <Welkin> some clohure thing?
12:28:26 <Welkin> clojure*
12:28:30 <merijn> fresheyeball: I think transducers are more general, but it's a subset of the notion, yes
12:28:44 <merijn> fresheyeball: transducers can also do "map", etc.
12:28:52 <fresheyeball> merijn: ok
12:29:06 <fresheyeball> Welkin: https://github.com/hypirion/haskell-transducers
12:29:08 <merijn> fresheyeball: You'd probably be interested in the conduit, pipes, and/or machines libraries for streaming data
12:29:09 * hackage wolf 0.3.44 - Amazon Simple Workflow Service Wrapper.  http://hackage.haskell.org/package/wolf-0.3.44 (markfine)
12:29:34 <fresheyeball> merijn: I use conduit right now, but its not the problem at hand
12:30:14 <albeit> With Pipes, is it possible to select which Consumers receive a stream item based on the item itself?
12:30:19 <fresheyeball> Welkin: tranducers are a method of composing reducers (the a -> b -> b part of folds) and then running them efficiently together
12:30:31 <merijn> albeit: No
12:30:43 <fresheyeball> so instead of doing multiple foldls, you can do it in one pass with composition
12:30:53 <fresheyeball> that is how I use/think of them anyway
12:30:58 <merijn> fresheyeball: Right, that's what foldl tries to do, yes
12:31:01 <fresheyeball> I think they are more fundimental than that
12:31:23 <cheater> hi
12:32:40 * hackage warped 0.0.5 - Warp and Wai Library.  http://hackage.haskell.org/package/warped-0.0.5 (markfine)
12:33:23 <sqzlh> hi, does conduit offer some kind of stateful abort function/counter? I want the stream to stop, as soon, as n elements, which fulfill a property p, have been processed.
12:33:26 <cheater> i have a stack project. when i stack build, one of the dependencies fails to install. i think it's due to data corruption. how can i delete what stack has for that one dependency, and resume the build again, without restarting the complete stack build? this has been building for a good 3 hours.
12:33:49 <fresheyeball> cheater: rm -rf .stack-work
12:34:09 <fresheyeball> thats all I know to do
12:34:19 <cheater> fresheyeball: as i said, this has taken 3 hours to build, so i don't want that, i want to delete just stuff that has to do with the single dependency
12:34:21 <fresheyeball> if your build is 3 hours you have bigger problems
12:34:31 <cheater> yeah tell me something i don't know, it's not my project
12:34:37 <fresheyeball> why does it take so long?
12:34:39 <fresheyeball> cheater: haha
12:34:43 <sm> you can use find to locate directories for that specific package and delete those
12:35:02 <Welkin> cheater: delete stack and use cabal new-*
12:35:08 <sm> try  stack exec -- ghc-pkg unregister PKG  first though
12:36:31 <merijn> Cabal's data directory stuff doesn't work if I don't "cabal install" the package, right? i.e. if I "cabal (new-)run" the file won't be in the right directory?
12:37:20 <Welkin> new-run doesn't work yet
12:37:29 <Welkin> you have to run the binary directly
12:37:46 <Welkin> it's under dist-newstyle/
12:37:56 <merijn> Welkin: Eh, yes it does
12:37:57 <cheater> i would appreciate if the trolling could stop because i'm doing this for work and i'm not having fun here :-/
12:38:06 <Welkin> merijn: since what version?
12:38:14 <merijn> Welkin: Since some version of HEAD
12:38:16 <sclv> it sort of works in 2.2
12:38:23 <sclv> idk the latest latest
12:38:23 <cheater> sm: i tried that but now stack is complaining that the directory cannot be found.
12:38:50 <sm> cheater: done the unregister [-f] too ? and stack clean ?
12:39:21 <cheater> sm: i can't stack clean because that would undo 3 hours of compiling
12:39:27 <Welkin> cheater: I don't see any trolling. I am being serious when I say get rid of stack and use cabal
12:39:35 <Welkin> or even switch over to nix
12:39:42 <cheater> no, you're not. please stop this, or i'll ad you to ignore
12:39:50 <Welkin> it is pretty crazy how many people I have seen recently with stack problems
12:39:58 <sclv> that might be sound advice in general but somebody in the middle of a problem they need to solve now for work related stuff is not in a position to heed it
12:40:11 <zincy> For IntMap what is the correct method to use just to update a value at a given key ? There seems to be insert, update  and adjust
12:40:13 <Welkin> cheater: I don't care if you ignore me. Go ahead.
12:40:26 <cheater> there
12:40:39 <sm> cheater: why is it taking 3 hours ? can you get more memory ?
12:40:41 <cheater> sm i think this doesn't have to do with cabal
12:40:51 <cheater> sm: it's 9 pm. shops are closed.
12:41:01 <sm> eg, by building on a vps
12:41:24 <cheater> can we please skip the part where we try to optimize the build time
12:41:37 <sclv> ok, so what's the rror about can't find a directory, specifically
12:42:06 <cheater> 1 sec.. let me try something else first. instead of removing the directory, i'll try removing the .stack-work inside that directory, rather than the whole .stack-work
12:42:28 <sm> anyway, if .stack-work is that valuable, I'd certainly take a copy of it.. then keep digging to understand its format enough to let stack proceed. I can tell you I had success removing a problem package this way when stack clean didn't fix it
12:43:28 <cheater> yeah i did make a copy :)
12:43:39 * hackage cautious 0.0.0.0 - Keep track of warnings and errors during calculations.  http://hackage.haskell.org/package/cautious-0.0.0.0 (NickskeVdb)
12:44:13 <Tuplanolla> Did you try `stack exec ghc-pkg -- unregister $broken-dependency`, cheater?
12:44:38 <cheater> ok, so, removing that package completely gave me an error right away, but removing that package's .stack-work seems to not give me errors.. yet
12:44:49 <cheater> Tuplanolla: no, i haven't. i'll try that if what i did right now fails!
12:45:15 <cheater> Tuplanolla: i know 0 about stack and not so much about ghc-pkg
12:45:25 <cheater> so err .... yeah
12:46:47 <cheater> it seems to be humming along nicely so far
12:46:53 <cheater> thanks for the help sm & co :)
12:47:09 <sm> np
12:47:46 <toblorone> hi, my haskell is very rusty. For an api im writing it would be nice to construct a list of actions with do notation. Is this possible / advisable?
12:48:37 <monochrom> That's very vague. The only correct answer is "it depends".
12:48:45 <sm> what's wrong with list notation ?
12:49:08 <cheater> toblorone: it's possible, but it's not necessarily the best way to do this
12:49:32 <monochrom> No actually the only correct answer is "what do you mean?"
12:49:47 <cheater> sm: i assume his api is not declarative and idempotent (few things are), and therefore keeping actions in a list does not ensure ordering of execution
12:50:12 <cheater> and this means in turn that you might be getting unexpected results
12:50:13 <toblorone> sm: nothing wrong per se. I guess doing it without explicit list notation has several benefits: 1) doesn't tie me to actually using a list to represent the sequence of actions, 2) the api is slightly less verbose
12:50:35 <cheater> toblorone: what api are you talking about? what sorts of actions?
12:52:49 <toblorone> cheater: im declaratively building a data structure whose fields might need to refer to one another. Almost like an ORM or something.
12:53:45 <cheater> aha
12:54:06 <cheater> well, if there are data dependencies, then a monad is a good idea
12:55:09 * hackage audacity 0.0.1.3 - Interchange with the Audacity sound signal editor  http://hackage.haskell.org/package/audacity-0.0.1.3 (HenningThielemann)
12:57:24 <cheater> ok, nice, it seems that dep built correctly
12:58:13 <toblorone> yeah, so i was thinking each entry to the "schema" would be a monadic action that could later be evaluated to produce the data structure, complete with validation. And more specifically this interface is to generate high level interfaces for registers in embedded environments. So very similar to an ORM actually
12:58:39 * hackage rtcm 0.2.16 - Haskell bindings for RTCM.  http://hackage.haskell.org/package/rtcm-0.2.16 (markfine)
12:59:51 <cheater> i'll be honest, it sounds like you're reaching for techniques you don't understand too well yet. you might end up having a bad time.
13:00:15 <cheater> you can define values that are self-referential in haskell without any specific notation, just using let
13:00:20 <sm> sounds like a haskeller :)
13:00:30 <toblorone> eh... im not sure if thats the case.... I was pretty well versed in haskell a few years ago but haven't touched it in a while
13:00:56 <cheater> > let { x = (1, 2, y); y = (x, x) } in y
13:00:58 <lambdabot>  error:
13:00:58 <lambdabot>      • Occurs check: cannot construct the infinite type:
13:00:58 <lambdabot>          a2 ~ (a1, b1, (a2, b2))
13:01:03 <cheater> something like that
13:01:09 <cheater> except with ADTs
13:01:13 <cheater> obviously :)
13:07:09 * hackage audacity 0.0.2 - Interchange with the Audacity sound signal editor  http://hackage.haskell.org/package/audacity-0.0.2 (HenningThielemann)
13:07:37 <dfeuer> Ahhhh.... Now I understand my problem.... I never ate breakfast! Or lunch.
13:07:40 <dfeuer> Ughhh
13:07:47 <Welkin> bindings to audacity? O.o
13:07:52 <Taneb> I'd recommend not not eating
13:07:53 <dfeuer> Cale: did you see my latest emails?
13:09:53 <monochrom> If it is not too late for brunch, have brunch.  If it is too late for that, have high tea.
13:10:01 <Welkin> eat second lunch
13:12:39 * hackage alsa-pcm 0.6.1 - Binding to the ALSA Library API (PCM audio).  http://hackage.haskell.org/package/alsa-pcm-0.6.1 (HenningThielemann)
13:15:55 <Cale> dfeuer: yep, I'll check it out at some point soon
13:22:42 <zincy> Is there anyway to change a type synonym for an Int to an Int?
13:23:14 <Cale> zincy: what
13:23:34 <Cale> zincy: type synonyms are not actually new types
13:23:42 <Cale> they're just new names for existing types
13:23:55 <geekosaur> > "x" :: String
13:23:57 <lambdabot>  "x"
13:24:02 <geekosaur> > "x" :: [Char] -- same
13:24:04 <lambdabot>  "x"
13:24:32 <geekosaur> that is not a cast, "::" is not "casting". they're exactly the same type
13:26:06 <monochrom> Use an editor to change type names.
13:26:23 <Akii> man so many breaking changes.. what replaces Text.Megaparsec.Text? O.o
13:27:37 <Akii> pandoc as well :(
13:27:38 <Akii> :D
13:27:49 <Akii> like I've been developing an app from the last century
13:28:25 <monochrom> If you are not using punch cards yet, you are not last century.
13:28:27 <geekosaur> just using a library from last century
13:28:35 <zincy> Thanks
13:30:15 <Akii> anyone by chance knows why spacemacs would insist on installing intero v 1.20?
13:30:30 <monochrom> lambda calculus is from two centuries ago, too.
13:32:01 <monochrom> Err, one century.
13:35:21 <dsal> In what ways are  String and [Char] different?
13:35:36 <dsal> hslint doesn't like me using [Char] even when that's what I actually mean.
13:36:28 <monochrom> They are different coding styles.
13:36:48 <monochrom> hlint comments on coding styles.
13:36:49 <geekosaur> hlint is often ... opinionated
13:36:51 <dsal> I mean, are there any actual differences?  Can instances be different?
13:36:57 <geekosaur> they can't
13:37:14 <monochrom> Only difference is coding style.
13:38:39 <dsal> OK.  That's one of the places where I'd like to be able to hint at hlint a bit.  I generally like its opinions, but typically I don't say [Char] when I mean String.  I'm intending to communicate a list of Chars.
13:39:30 <maerwald> hlint also gives wrong suggestions that are not semantically the same
13:40:34 <monochrom> I never bothered to use hlint, but I heard that some command line options exist to turn off some checks.
13:40:53 <pavonia> maerwald: Do you have an example?
13:41:09 <geekosaur> it also supports pragmas implemented as ANNs
13:41:19 <geekosaur> pavonia, it's a heuristic checker. heuristics can be wrong
13:42:27 <pavonia> I thought it works with hard-coded rules
13:42:43 <geekosaur> you can both disable rules and add new ones
13:43:31 <geekosaur> and the "rules" are heuristics; it's not a compiler, it doesn't really understand complex code, the rules are "if it looks like this then ..." but sometimes it just happens to look like that while being something else
13:44:01 <geekosaur> heuristic checkers always have this problem. original Bell Labs lint for C had its own failure modes
13:44:09 <maerwald> pavonia: I think one of them is this one https://github.com/quchen/articles/blob/master/fbut.md#a-op-is-not-x---a-op-x
13:44:13 <maerwald> I don't find the bug report
13:44:25 <maerwald> also wrt pointless style
13:44:44 <maerwald> https://github.com/quchen/articles/blob/master/fbut.md#f-x---is-not-f--x---
13:45:22 <pavonia> Thanks
13:45:24 <maerwald> it just randomly throws suggestions at you to make your code "shorter"
13:45:30 <maerwald> no matter what that actually means
13:46:22 <geekosaur> yeh, there's some bad suggestions in there. and some that are really intended for novices and rather annoying to experienced Haskellers
13:46:35 <geekosaur> a number of whom basically refuse to use hlint because of them
13:47:26 <dpyro> does anyone know how to disable the `clang: warning: argument unused during compilation: '-nopie' [-Wunused-command-line-argument]` warning constantly present on any compiling with stack build/stack test? i am on macos for reference
13:47:51 <sqooq> can I parse one thing once, just to make sure one condition satisfies, then if that succeeds, parse the whole thing again but actually interpreting it?
13:48:45 <sqooq> or like
13:48:54 <sqooq> i guess the real question is "can I backtrack entirely?"
13:49:27 <statusfailed> What database/SQL libraries (like Persistent, hasql ...) can also generate table DDL?
13:49:46 <statusfailed> (and migrations, ideally)
13:50:08 <sqooq> fml
13:50:13 <sqooq> I was so close to cglory
13:50:25 <monochrom> sqooq: Perhaps keep the original input and write two parsers?
13:50:34 <geekosaur> you can save and restore the current parser location iirc
13:51:37 <pavonia> "GHC only inlines fully applied functions, i.e. when all parameters in the definition are filled with values." <-- Is this also true if you explicitly give an INLINE pragma?
13:51:58 <monochrom> I think yes.
13:52:09 * hackage sbp 2.3.15 - SwiftNav's SBP Library  http://hackage.haskell.org/package/sbp-2.3.15 (markfine)
13:52:25 <pavonia> That's interesting
13:53:09 * hackage extra 1.6.6 - Extra functions I use.  http://hackage.haskell.org/package/extra-1.6.6 (NeilMitchell)
13:53:09 <geekosaur> dpyro, I suspect that's in ghc's settings file somewhere
13:53:35 <geekosaur> but if stack is managing your ghc, changing it could see stack revert it unexpectedly
13:55:10 <sqooq> monochrom: I mean I guess that can work, but how can I only make the second parser work if the first parser does?
13:55:46 <monochrom> If the first parser says no, don't even run the second parser?
13:56:26 <sqooq> :thinking:
13:56:33 <sqooq> monochrom: this feels wrong but ok lmao
13:56:36 <sqooq> that can work
13:56:40 <statusfailed> the "beam" library looks pretty close to what I want; anybody used it?
13:56:58 <sqooq> if curious here's what I'm trying to parse/not parse "[!!x[!!]]"
13:57:01 <sqooq> that's good
13:57:09 <sqooq> "[!!x[x!]]" that's bad
13:57:21 <monochrom> I personally would not even do this two-pass thing.  I would parse to an abstract syntax tree (or parse error), then interpret the abstract syntax tree (if it exists).
13:57:24 <sqooq> no two x's, but there can be brackets netween
13:57:37 <sqooq> so it's hard to determine
13:57:44 <sqooq> if there have been more than one x
13:57:51 <sqooq> I don't think regular BNF accomodates it
13:57:57 <sqooq> unless I'm not thinking hard enough
13:59:56 <monochrom> There are criterions uncheckable by context-free grammars.
14:00:05 <monochrom> err, criteria! damn English
14:00:07 <sqooq> I was thinking I could parse the x giving all the cases that could come after it, but then backtrack and ignore that part
14:00:29 <monochrom> in which case you do the check after obtaining the abstract syntax tree but before you start interpreting.
14:00:37 <sqooq> like `x <*> undoThisWhenDone (bang <|> leftbrack <*> bang)`
14:00:46 <monochrom> or rather, people do that.
14:01:20 <monochrom> In any case you always need to think harder.
14:01:30 <sqooq> I mean I've thought of things
14:01:33 <sqooq> but I don't want to do them
14:01:46 <sqooq> like what you said, I considered it, I didn't think to just literally check using an if or whatever
14:01:59 <sqooq> by "what you said" I mean, writing 2 parsers
14:02:16 <sqooq> I can parse once ignoring brackets, in which case checking if there are more than one x's is a piece of cake
14:03:01 <sqooq> then if that succeeds, parse again witha  grammar that technically allows more than one x, but because of the first parse, won't ever get that case
14:03:33 <sqooq> or ye, I can check the structure after parsing too, that works
14:03:38 <sqooq> it's just a tre
14:03:39 <sqooq> tree
14:04:12 <sqooq> Idk how fmapping over a tree works, but if it goes in "order" of leaves, as I would expect, then I can just carry state and prevent the doubling case
14:04:34 <monochrom> Actually I think this can be checked by a context-free grammar.
14:05:08 <sqooq> idk, there are too many cases where it can appear
14:05:20 <monochrom> But the grammar will look like you have two copies of the same rules, except that one copies wants an x and the other copy wants no x.
14:05:21 <sqooq> even `[!!x]x` <- Bad
14:05:39 * hackage gnss-converters 0.3.32 - GNSS Converters.  http://hackage.haskell.org/package/gnss-converters-0.3.32 (markfine)
14:05:41 <sqooq> monochrom: see a similar thing happened when I had a more complex grammar, and eventually I realized it was recursive
14:05:52 <sqooq> meaning, I would have to write a rule for an infinite amount of cases
14:06:23 <sqooq> two of the rules looked like inverses of each other
14:06:43 <sqooq> but then I realized I needed to have yet another rule almost exactly like the other, but handling the case of starting a new branch right after another
14:06:49 <sqooq> and then and then and then, and so on
14:07:07 <sqooq> monochrom: maybe this case is different, let me try
14:07:11 <sqooq> sorry for spamming chat
14:07:38 <spruit11> Yah, be sorry.
14:09:24 <sqooq> yeah I can't figure it out
14:09:27 <sqooq> seemingly too many cases
14:10:09 <sqooq> I could easily do this, if I could just parse ahead without consuming
14:10:09 * hackage postgresql-connector 0.2.5 - Initial project postgresql-connector from stack  http://hackage.haskell.org/package/postgresql-connector-0.2.5 (markfine)
14:10:29 <sqooq> there's got to be a way to do that, i'm gonna check the docs
14:10:39 <sqooq> it's like "try" but succeeding instead of failing
14:11:44 <monochrom> No, there is no pre-made "rewind if yes".  But you can write one with getInput and setInput.
14:15:22 <Tuplanolla> This is pretty wacky.
14:15:22 <Tuplanolla> @check \ f -> liftA2 (==) f (f . f . f) :: Bool -> Bool
14:15:25 <lambdabot>  +++ OK, passed 100 tests.
14:15:31 <sqooq> monochrom: lookAhead???
14:15:40 <sqooq> I forgot to mention I'm using megaparsec
14:15:48 <sqooq> It seems to sort of work, but I need to alter the rule I made for it
14:17:06 <sqooq> almost there
14:17:31 <sqooq> hmm
14:18:34 <monochrom> @type \f -> liftA2 (==) f (f . f . f)
14:18:36 <lambdabot> Eq a => (a -> a) -> a -> Bool
14:19:00 <monochrom> @type \f -> liftA2 (==) f (f . f . f)  :: Bool -> Bool
14:19:00 <sqooq> I think I just can't fix one case now
14:19:01 <lambdabot> (Bool -> Bool) -> Bool -> Bool
14:19:14 <sqooq> `rest = (Leaf Rest <$ symbol "x") <* lookAhead (many eitherbrace *> (bangOrCont))`
14:19:44 <sqooq> is what I ended up writing. "Cont" is actually another thing besides "!", it's "-", I didn't mention it early since it's replaceable always with !
14:20:05 <sqooq> the only case it doesn't seem to handle is something like "[! ! x]"
14:20:30 <sqooq> there's still only 1 x, but it fails
14:20:31 <lyxia> @check \f -> liftA2 (==) f (f . f . f) :: Int -> Bool
14:20:33 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 2 shrinks):
14:20:34 <lambdabot>  <Int -> Int> -1
14:20:42 <lyxia> @check \(Fn f) -> liftA2 (==) f (f . f . f) :: Int -> Bool
14:20:44 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 11 shrinks):
14:20:45 <lambdabot>  <fun> 0
14:20:58 <lyxia> -_-''
14:22:31 <lyxia> How old is lambdabot's quickcheck
14:23:10 <sqooq> this seems so hacky but I think it works
14:23:53 <sqooq> I had to parse eof, but because eof doesn't automatically return the right type, I had to make it return my tree type, so i just picked one randomnly since it never actually gets used, since I'm using lookAhead XD
14:25:17 <sqooq> Ok, despite this I think this is best solution
14:32:09 * hackage shakers 0.0.48 - Shake helpers.  http://hackage.haskell.org/package/shakers-0.0.48 (markfine)
14:33:45 <sqooq> So does lookAhead/try allow for more than Context-free, but less than context sensitive :thinking:???
14:33:55 <sqooq> because I'm pretty sure I couldn't encode this in BNF alone
14:37:00 <monochrom> lookAhead a fixed number of times stays within context-free.
14:37:50 <Tuplanolla> Are you confusing CF with LL(k) for some k, sqooq?
14:39:03 <monochrom> try stays within context-free too because non-deterministic pushdown automaton.
14:40:24 <monochrom> But you're embedding this in Haskell, you can introduce arbitrary recursions and/or extra parameters that easily exceed context-free, even exceed context-sensitive, and land you right into Turing-completeness.
14:42:27 <monochrom> Regarding a practical parser for this, you can add a parameter or state variable to remind yourself "have I seen an X before?"
14:44:03 <monochrom> But I think I can prove (via pushdown automaton) that adding a state variable of 2 possible states stays within context-free.
14:45:03 <sqooq> what if I lookAhead (many braces)
14:45:05 <sqooq> like I did
14:45:08 <monochrom> Because adding one such state variable just means duplicating your state transition diagram.  Roughly speaking.
14:45:26 <sqooq> then again, the only reason it looks ahead many braces is to ignore htem
14:45:35 <sqooq> it's almost like I'm considering braces white space, and only looking for bangs
14:45:47 <sqooq> so I guess it's still context-free (?)
14:46:02 <sqooq> looking for ONE bang, I should say
14:46:39 * hackage hlint 2.1.2 - Source code suggestions  http://hackage.haskell.org/package/hlint-2.1.2 (NeilMitchell)
14:48:04 <monochrom> Don't bother writing a grammar carefully for this.  It is going to be very annoying.  Just add a state variable.
14:48:44 <sqooq> monochrom: I'm already done
14:48:46 <sqooq> lookAhead works
14:49:00 <monochrom> That is pretty inefficient.
14:49:26 <sqooq> you think?
14:49:33 <sqooq> inefficient enough for me to be worried?
14:49:58 <monochrom> It is also difficult for your maintainer to maintain.
14:50:40 <sqooq> i am my maintainer LMAO
14:51:51 <EvanR> myself 6 months from now is a real asshole, i will do what i want with this code
14:52:22 <EvanR> f that guy
14:52:41 <sqooq> monochrom: To get a state variable I have to stack with a State transformer right?
14:53:21 <monochrom> megaparse already provides user state
14:53:48 <monochrom> and like I said you don't even have to use that, you can just use a parameter.
14:54:00 <sqooq> what do you mean use a parameter? how would that work?
14:54:15 <sqooq> Sorry if that's a stupid question, but like the parser goes without me so to speak, no?
14:54:47 <sqooq> by parameter you mean a function variable right???
14:55:23 <monochrom> f 0 = 0;  f x = f (x-1)
14:55:37 <monochrom> That code is decreasing a state variable until it hits 0.
14:55:46 <sqooq> ok that's what I thought you meant
14:55:58 <sqooq> I guess I'm thinking too much
14:56:09 <sqooq> Thinking that the parser is in it's own world and can't connect with a called in variable
14:56:13 <sqooq> but I see now
14:56:16 <sqooq> Ok I'll do that
14:57:35 <zincy> Im not sure how I should use the type system to represent and send api errors to clients? Should I read up on the either type?
14:58:17 <monochrom> Does the client receive a type?  Does the client receive a value?
14:59:52 <monochrom> WTH is API anyway?
15:00:30 <zincy> Full stack haskell so client server share types
15:01:04 <zincy> I dont like the word api either
15:01:11 <zincy> server
15:01:49 <dstolfa> diskless cloud of serverless docker swarms maintained by kubernetic cyborgs with a blockchain that was reinforcement learned through deep neural networks
15:02:03 <dstolfa> am i doing this right ma?
15:02:16 <monochrom> Yes.
15:02:48 <monochrom> I guess mercury delay tubes are in again if you're going diskless.
15:02:59 <dstolfa> monochrom: webscale.
15:03:56 <sqooq> monochrom: how do I make the parser fail?
15:04:00 <sqooq> using the variable
15:05:11 <sqooq> I wrote an if statement using the variable, which is Bool, right? But like what do I do for the undesireable case? And sorry if it's that I need to just go in the megaparsec and learn how to force an error, just making sure that that's NOT what I'm supposed to do first before doing it
15:05:54 <monochrom> megaparsec has ways of raising errors.
15:06:12 <monochrom> The most basic one (without your own error message) is Alternative's empty.
15:08:04 <sqooq> monochrom: see, that's the best thing to do I think. Since the errors are already really good. I was about to figure out how to do customFailure, which requires changing the error type from Void, to who knows what. SO I would have gone looking to learn about all that stuff.
15:08:08 <sqooq> when I could just do empty lmao
15:16:44 <sqooq> i can't figure it out rip :(
15:17:27 <sqooq> The same function that uses the Bool, is the one that should somehow update it...
15:28:30 <sqooq> Nvm it's two functions that do different things
15:28:35 <sqooq> but it still doesn't work, not sure why
15:29:27 <sqooq> o I never update it
15:29:30 <sqooq> ye Idk how to update it
15:30:12 <chisui> sqooq what was the question?
15:30:25 <sqooq> chisui: trying to parse something a bit hard
15:30:38 <sqooq> can't have more than one x after another
15:30:41 <sqooq> but ignoring brackets
15:31:13 <sqooq> like `[! ! x [x !]]` this would be wrong. But BNF doesn't handle it. monochrom suggested I carry state around.
15:31:42 <sqooq> but Idk how to actually call a function thus updating the state
15:32:15 <sqooq> because the "x" parser just returns the return type, in my case a Tree
15:33:12 <sqooq> I think monochrom was wrong. I think I need an embedded state, either megaparsec's own, or a monad stack.
15:33:25 <chisui> hm, I don't know. Maybe a validation pass after parsing?
15:33:25 <sqooq> because the update of state happens on monadic bind
15:34:01 <sqooq> chisui: I was technically doing something very similar by using lookahead, but was informed that would be innefficient. Which is true.
15:34:12 <monochrom> Perhaps megaparsec's user state is more convenient.
15:36:27 <sqooq> monochrom: do you think a regular variable could work. I could still be just stupid here. You see the problem right? The x parser is the one to both react to the variable and "update" it. But updating the variable just means passing it into another function, but there's no other function to call. The x parser is just a parser type, it just returns Parser (Tree Rhythm).
15:37:02 <monochrom> Right.
15:38:02 <sqooq> Ok. I have to go now
15:38:37 <sqooq> When I get back i'll decide if to use megaparsec's state, or just use the lookAhead and be innefficient.
15:38:44 <sqooq> Thanks, bye
15:40:42 <monochrom> You can always decide to not change existing code.
15:49:45 <johnw> sqooq: megaparsec's own state will be better than StateT
15:50:00 <johnw> if you have to use state
15:55:41 <sqooq> johnw: I don't think megaparsec's state allows me to put my own data in it >:(
15:56:04 <sqooq> I think they may have removed it
15:57:00 <monochrom> Yikes.
15:57:27 <glguy> There's a MonadParsec instance for StateT, however, so maybe the intention is for you to use StateT if you needed that functionality
15:57:55 <sqooq> >Eliminated built-in user state since it was not flexible enough and can be emulated via stack of monads.
15:58:10 <sqooq> yup they removed it, have to use regular stateT stack
15:58:26 <sqooq> god I haven't worked with monad transformers in a hot minute. I remember it was a pain last time
15:58:41 <sqooq> but it was also my first time, so maybe I just made it more complicated than it is
15:58:44 <geekosaur> state was always a hack because state transformers didn't work right with backtracking in original parsec
15:59:10 <jle`> sqooq: most of your parser code will probably be the same
15:59:11 <glguy> It matters where in the "stack" you put StateT
15:59:14 <sqooq> geekosaur: well I'd be using state to avoid backtracking, so I guess I won't have any issues liek that
15:59:22 <johnw> sqooq: ah, looks like you're right
15:59:39 * hackage checkers 0.4.10 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.4.10 (ConalElliott)
15:59:50 <sqooq> I remember last time there were 2 libraries
15:59:53 <sqooq> which do people tend to use
15:59:59 <sqooq> mtl and there was another
16:00:17 <jle`> transformers is the actual transformers library
16:00:22 <dsal> woo.  my checkers change is in
16:00:25 <jle`> mtl just re-exports the transformers from transformers
16:00:32 <jle`> mtl doesn't provide any monad transformers itself
16:00:38 <jle`> it is not even a monad transformer library
16:00:39 * hackage b9 0.5.46 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.5.46 (SvenHeyll)
16:00:56 <jle`> names are werid :)
16:01:05 <sqooq> wait what
16:01:12 <sqooq> so mtl doesn't do anything?
16:01:24 <jle`> mtl provides generic interfaces over many monads
16:01:33 <jle`> that's all
16:01:48 <c_wraith> mtl provides classes and instances in terms of the contents of transformers
16:01:54 <jle`> maybe i will start thinking of mtl as "monad typeclass library"
16:02:14 <sqooq> so that's still worthy
16:02:19 <sqooq> so I should use mtl then
16:02:42 <jle`> if you want to work with parsers as if they had state, then mtl is a good choice
16:02:52 <jle`> mtl isn't about monad transformers, but being able to work polymorphically over different stateful monads
16:03:03 <jle`> or work polymorphically over different 'logging' monads, etc.
16:04:00 <sqooq> :thinking:
16:04:09 <DigitalKiwi> hehe, which do people use more, mtl or the one that is used so little the name escapes me ;)
16:04:10 <jle`> transformers has the actual monad transformers, but mtl re-exports them for convenience
16:04:34 <jle`> to me, mtl and transformers solve pretty different problems
16:04:39 <jle`> if i want monad transformers, i use transformers
16:04:43 <jle`> if i want monad typeclasses, i use mtl
16:05:00 <sqooq> do i use Lazy state or Strict
16:05:08 <sqooq> I seem to recall someone telling me to never use one or the other
16:05:23 <sqooq> but idk if they knew if they were talking about, and I can't remember which of the two options it was
16:05:37 <sqooq> idk if they knew if they were if talking if about LOL
16:05:45 <jle`> flip a coin
16:06:40 <sqooq> so it doesn't matter...
16:06:40 <glguy> For use with megaparsec you'd want .Strict
16:06:59 <johnw> is it better to use lazy Text or strict Text with megaparsec?
16:07:09 <jle`> you mean as the input?
16:07:13 <johnw> yeah
16:07:39 * hackage b9 0.5.47 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.5.47 (SvenHeyll)
16:13:00 <sqooq> this is probably a stupid question
16:13:23 <sqooq> but since "put" wipes the result, now I get type errors
16:13:27 <sqooq> but not sure how to fix
16:13:43 <sqooq> do I just repeat the line that returns the proper type...that can't be right
16:14:14 <sqooq> because I have to get the Bool, then use it to perform parsing, then if that succeeds, put a new Bool
16:15:32 <sqooq> NVM
16:15:33 <dmj`> jle`: "mtl isn't about monad transformers”, thought I read a blog post about this somewhere …
16:15:34 <sqooq> got it
16:15:58 <sqooq> If anyone's curious, I pattern matched against the bool and then for the case that requires put, i do the putting first,  then perform the parse
16:16:06 <sqooq> now let's see if this baby even works
16:16:43 <jle`> dmj`: ;)
16:17:51 <sqooq> wait
16:17:55 <sqooq> do i embed the state in the parser
16:17:58 <sqooq> which is what I did
16:18:01 <sqooq> or vice versa
16:18:04 <sqooq> now idk how to unwrap lmao
16:18:13 <johnw> it affects the effects
16:18:33 <johnw> if you want state to be preserved across the parser's definition of <|>, then state should be outside
16:18:49 <johnw> if you only want state from the successfully parsing path, then state should be inside
16:19:00 <monochrom> Are you doing "StateT Parser"?  Are you doing "ParserT State"?
16:20:31 <monochrom> johnw: I think this state should be rollbacked when backtracking, because it is a boolean state to remember "I have seen X before" for a language which allows an X to appear in many places but globally only one occurrence of X.
16:20:52 <johnw> monochrom: sounds right
16:21:33 <sqooq> nvm got it
16:21:38 <sqooq> I was doing ParserT State
16:21:41 <sqooq> the test failed
16:21:47 <sqooq> It fails on one "x"
16:21:53 <sqooq> probably my mistake
16:21:56 <sqooq> I'M SO LATE
16:21:58 <sqooq> ok gotta go bye
16:34:40 * hackage sampling 0.3.3 - Sample values from collections.  http://hackage.haskell.org/package/sampling-0.3.3 (JaredTobin)
16:59:01 <lookaway> How can I block all incoming and outgoing except a certain port using iptabels ?
17:02:40 <glguy> lookaway: This channel is for the Haskell programming language specifically, not general system admin questions. Sorry!
17:11:43 <ph88> how can i traverse something in pairs (getting two items at a time). I would like to use lens biplate
17:13:04 <jle`> can you give an example
17:13:18 <jle`> of something you would awnt to traverse
17:13:22 <jle`> and what pairs you would want to observe
17:44:09 * hackage extensible-effects 2.5.3.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-2.5.3.0 (shergill)
17:51:12 <Axman6> :t upon (zip `ap` tail)
17:51:14 <lambdabot> (Applicative f, Data a, Indexable [Int] p) => p [(a, a)] (f [(a, a)]) -> [a] -> f [a]
17:51:32 <Axman6> > [1,2,3,4] ^.. upon (zip `ap` tail)
17:51:34 <lambdabot>  []
17:51:46 <Axman6> hmm
17:53:05 <Axman6> > [1,2,3,4] ^.. to (zip `ap` tail) . each
17:53:07 <lambdabot>  [(1,2),(2,3),(3,4)]
17:53:16 <Axman6> ph88: ^ ?
17:53:31 <Axman6> hmm, not a traversal though
17:55:19 <Axman6> also probably not the right pairs
17:56:55 <Axman6> @Hoogle Int -> Traversal [a] [b] [a] [b]
17:56:55 <lambdabot> Maybe you meant: hoogle google
17:57:01 <Axman6> @hoogle Int -> Traversal [a] [b] [a] [b]
17:57:01 <lambdabot> Control.Reference.Generators fromTraversal :: (forall f . Applicative f => (a -> f b) -> s -> f t) -> Traversal s t a b
17:57:02 <lambdabot> Language.Haskell.Tools.AST.Helpers nodesWithRange :: (Biplate (Ann node dom stage) (Ann inner dom stage), SourceInfo stage) => RealSrcSpan -> Simple Traversal (Ann node dom stage) (Ann inner dom
17:57:02 <lambdabot> stage)
17:57:02 <lambdabot> Lens.Micro singular :: HasCallStack => Traversal s t a a -> Lens s t a a
17:57:22 <ph88> jle`, i have a few types like this https://bpaste.net/show/b61881b53d11 i want to traverse all the "T" types (they will be in the leafs of the rose tree structure), i like to conditionally modify them, so i want to apply a function that takes two T's and returns a possibly modified first T
17:58:30 <ph88> the order should the order in which leafs are found when doing a depth first tree traversal
17:58:52 <ph88> Axman6, yes the output shape looks good, but my input is a rose tree and not a list
18:00:21 <Axman6> well, partsOf template (I think) will probably get you a long way
18:00:58 <ph88> template ?
18:01:23 <ph88> i have another function that can already traverse the tree and check if a type match and then change the value of it https://bpaste.net/show/f8e30368c1a9
18:01:29 <Axman6> >(Left True,[Right Just (Left False)) ^.. partsOf template :: [Either Bool String]
18:01:36 <Axman6> > (Left True,[Right Just (Left False)) ^.. partsOf template :: [Either Bool String]
18:01:38 <lambdabot>  <hint>:1:36: error: parse error on input ‘)’
18:01:49 <ph88> i don't know how the function works which i just pasted though
18:01:52 <Axman6> > (Left True,[Right "Hello"], Just (Left False)) ^.. partsOf template :: [Either Bool String]
18:01:54 <lambdabot>  error:
18:01:54 <lambdabot>      • Couldn't match type ‘[a1]’ with ‘Either Bool String’
18:01:54 <lambdabot>        Expected type: [Either Bool String]
18:02:42 <Axman6> > (Left True,[Right "Hello"], Just (Left False)) ^.. partsOf template :: [Bool]
18:02:44 <lambdabot>  error:
18:02:44 <lambdabot>      • Couldn't match type ‘[a1]’ with ‘Bool’
18:02:44 <lambdabot>        Expected type: [Bool]
18:02:54 <Axman6> > (Left True,[Right "Hello"], Just (Left False)) ^. partsOf template :: [Bool]
18:02:56 <lambdabot>  error:
18:02:56 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘template’
18:02:56 <lambdabot>        prevents the constraint ‘(Data b0)’ from being solved.
18:03:03 <Axman6> bleh, anyway
18:04:37 <ph88> what's that template ?
18:04:58 <Axman6> partsOf template (can) give you a traversal of type Data a => Traversal' a [T]
18:05:03 <Axman6> https://hackage.haskell.org/package/lens-4.16.1/docs/Data-Data-Lens.html
18:05:20 <Axman6> finds all accurrences of a in something of type s
18:05:35 <ph88> ah ye that's good
18:05:41 <ph88> how do i get them by two though ?
18:05:43 <Axman6> and partsOf gives you a list of all the values pointed to by the traversal
18:06:05 <ph88> eventually i need to output a new tree with those changed leafs
18:06:06 <Axman6> that I"m not sure, but you could easily do that in a non-lens way
18:07:00 <ph88> is that a thing to generate a new data structure while traversing ?
18:07:42 <Axman6> so any modification you make to the list returned by partsOf will be reflected in the structure
18:07:58 <Axman6> trying to find the mind trippy example
18:08:22 <ph88> ok
18:08:33 <ph88> i have already the Data constrained on all my types
18:08:56 <ph88> (that wasn't in the first paste by the way, but i have)
18:09:05 <Axman6> > (Left True,[Right "Hello"], Just (Left False),"another string",("and",("some","more"))) & partsOf template %~ (reverse :: [Char] -> [Char])
18:09:07 <lambdabot>  (Left True,[Right "erome"],Just (Left False),"mosdnagnirts r",("eht",("onao"...
18:09:26 <Axman6> > (Left True,[Right "Hello"], Just (Left False),"another string",("and",("some","more"))) & partsOf template %~ (reverse :: [String] -> [String])
18:09:27 <lambdabot>  (Left True,[Right "more"],Just (Left False),"some",("and",("another string",...
18:10:39 <Axman6> a.k.a, find _all_ the strings in my data, and reverse their order across the whole structure - this is essentially what you're aasking for, find all the T's, and apply modifications to them
18:11:18 <freeman42x]NixOS> how can I check the type of some symbol (or expression) as part of a (bigger) block of code?
18:12:02 <ph88> Axman6, that's awesome :D
18:13:29 <ph88> Axman6, my "reverse" function would have a type signature of  :: String -> String -> String   where the output string is the first string, so basically the second string is one lookahead
18:13:49 <ph88> (it's not a reverse function, but what takes the place of the current reverse)
18:14:31 <ph88> freeman42x]NixOS, you can put a type signature (maybe you need extension FlexibleContexts or so) and then you put a _ in the signature and the compiler will infer the type for you
18:16:54 <freeman42x]NixOS> ph88, do you happen to have some example/article? I need to apply it to something like: ref <- newIORef =<< statusIconNewFromStock stockSave to figure out what ref and newIORef are
18:18:01 <geekosaur> @index newIORef
18:18:01 <lambdabot> Data.IORef
18:18:36 <ph88> freeman42x]NixOS, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#typed-holes
18:19:55 <freeman42x]NixOS> ph88, thank you
18:19:57 <ph88> oh i actually meant this https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#partial-type-signatures
18:20:09 <freeman42x]NixOS> geekosaur, cheers, I see, so it is part of the library
18:20:15 <ph88> first is about holes in values, second holes in signature .. you can put _ in both places
18:20:55 <ph88> eh no sorry i'm confused you don't need an extension for that to work
18:21:02 <ph88> i always got _ to work without extra extension
18:23:46 <freeman42x]NixOS> ph88, the thing is if I rename icon to _ for example and compile it does not show the type of the hole. I think this might be because it is in a bigger function or something
18:23:57 <freeman42x]NixOS> I never seen type holes not working in small functions
18:24:22 <ph88> Axman6, perhaps there is a way to take the "tail" of the tree? and then zip it again with the original tree? ok i'm talking in terms of list .. but just for the idea
18:24:56 <ph88> freeman42x]NixOS, you can also search here https://hoogle.haskell.org/?hoogle=newIORef
18:25:51 <ph88> freeman42x]NixOS, you can load your program in ghci and type:   :t (statusIconNewFromStock stockSave)
18:27:03 <freeman42x]NixOS> yup, but what I need is ref from: ref <- newIORef =<< statusIconNewFromStock stockSave , would need some more stuff to do
18:27:32 <ph88> freeman42x]NixOS, when you have  newIORef :: a -> IO (IORef a)   then    the "a" will be the type of what i just said on my previous line in irc
18:28:18 <ph88> suppose   statusIconNewFromStock stockSave :: IO String    then   ref :: IO (IORef String)
18:29:53 <ph88> Axman6, just throwing some ideas out there i found at https://www.reddit.com/r/haskell/comments/2znj5o/staggered_zip_or_fold_with_2_elements_at_a_time/
18:30:17 <geekosaur> freeman42x]NixOS, turn on PartialTypeSignatures and ScopedTypeVariables extensions, then (ref :: _) <- ...
18:31:51 <freeman42x]NixOS> oh, cool
18:32:13 <ph88> freeman42x]NixOS, yes i was getting at that but geekosaur knows best :p
18:32:28 <freeman42x]NixOS> I'll try now, this is the code that used to work before: https://i.imgur.com/kVgxLIx.png when `icon` was of IconSomethingType
18:33:34 <geekosaur> freeman42x]NixOS, you have an IORef containing an icon, not an icon
18:33:39 <geekosaur> you have to use readIORef to get the icon
18:33:53 <geekosaur> why are you using an IORef here?
18:35:34 <freeman42x]NixOS> geekosaur, to keep the poor trays from dieing via garbage collection https://github.com/gtk2hs/gtk2hs/issues/60#issuecomment-70382510
18:35:52 <freeman42x]NixOS> sorry, I am way behind in reading and following, catching up
18:36:00 <geekosaur> then you need to always use readIORef, or find a different way to hold the object
18:36:59 <Axman6> ph88: "my "reverse" function would have a type signature of  :: String -> String -> String" You probably want to make sure that that function is of type T -> T -> T (or (T,T) -> T) to make sure the Data.Data magic works properly
18:38:09 <geekosaur> also, this is only at one remove; letting the IORef go out of scope lets the object go out of scope. you need to rethink this, probably
18:38:15 <geekosaur> you are trying to emulate global variables
18:38:22 <geekosaur> you don;t get global variables.
18:38:44 <geekosaur> IORef is not a magic way to  be a global variable, just as it is not a way to transparently be a mutable variabe
18:39:57 <ph88> Axman6, yes that makes sense
18:41:02 <ph88> Axman6, perhaps i could zip the tree with itself with lens ? there is a package Control.Lens.Zipper .. i never used it though
18:41:23 <freeman42x]NixOS> geekosaur, are you saying hat the IORef can only be used once or?
18:41:36 <ph88> but then i still need that "tail" function for the second tree
18:42:38 <ph88> > zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip
18:42:40 <lambdabot>  error:
18:42:40 <lambdabot>      Variable not in scope: zipper :: ([Char], [Char]) -> Integererror:
18:42:40 <lambdabot>      • Couldn't match type ‘Ratio (Ratio (Ratio Integer))’
18:42:44 <geekosaur> freeman42x]NixOS, no, I am saying (a) every time you want to use the thing inside it, you need to use readIORef (b) just stuffing something into an IORef does not make it immortal, if the IORef goes out of scope then it will be garbbage collected and if that is the only reference to the thing stored in it, then that also will be gc-d
18:44:02 <ph88> > import Control.Lens.Zipper
18:44:03 <freeman42x]NixOS> geekosaur, I got b) from the ticket. so use readIORef, got it, I think. Thank you
18:44:04 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
18:44:16 <Axman6> possibly @import?
18:44:25 <Axman6> can't remember if you can import new modules or not
18:44:37 <ph88> i think i've seen it before
18:44:43 <ph88> @import Control.Lens.Zipper
18:44:43 <lambdabot> Unknown command, try @list
18:45:41 <Axman6> > Control.Lens.Zipper.zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip
18:45:43 <lambdabot>  error:
18:45:43 <lambdabot>      Not in scope: ‘Control.Lens.Zipper.zipper’
18:45:43 <lambdabot>      No module named ‘Control.Lens.Zipper’ is imported.
18:46:31 <ph88> that's just the example from that page  .. anyway
18:46:44 <ph88> just an idea .. not sure if this makes much sense
18:46:47 <geekosaur> "nicre". doesn't tell you what's going on or hopw to use it, sticks in a "-- Necessary." without saying why...
18:46:59 <geekosaur> (which relates to what I was trying to tell you)
18:52:08 <geekosaur> @let import Control.Lens.Zipper -- but not sure lb has it available for import
18:52:08 <lambdabot>  .L.hs:54:1: error:
18:52:08 <lambdabot>      Could not find module ‘Control.Lens.Zipper’
18:52:08 <lambdabot>      Perhaps you meant
18:52:15 <geekosaur> that would be a "no"
19:14:32 <plugin> @type unsafeCoerceConstraint
19:14:38 <lambdabot> error:
19:14:38 <lambdabot>     Variable not in scope: unsafeCoerceConstraint
19:21:19 <plugin> say I had a class `(Foo x, Foo y) => Bar baz x y where barIt :: blah` and an GADT `data SomeT where SomeT:: (Foo a) => a -> SomeT`
19:24:08 <plugin> how could I convince GHC that an instance `Bar baz x y` exists for (SomeT a :: x, SomeT b :: y) using unsafeCoerceConstraint?
19:24:40 <c_wraith> no.
19:25:56 <c_wraith> an instance of Bar would be looked up by the triple (bar, x, y)
19:26:21 <c_wraith> even if you know x and y are instances of foo, that doesn't help looking up the instance of Bar
19:27:15 <plugin> Okay, I what if I provide a value of `baz`?  `Bar Baz x y`?
19:27:27 <c_wraith> it needs all 3 types.
19:28:26 <plugin> I have them, the issue is that two of them are locked behind an existential and I don't quite see how to indicate that they have that instance.
19:28:46 <c_wraith> you don't have the types.
19:29:02 <c_wraith> you have a proof that the type is an instance of Foo
19:29:18 <c_wraith> that's a very different thing.
19:31:36 <plugin> and the only way to have `Bar baz x y` is if `Bar bas x y` follows from `Foo x`, `Foo y` for some baz?
19:32:21 <c_wraith> superclasses don't contribute to class resolution at all.
19:32:39 <c_wraith> err, instance resolution.
19:33:24 <c_wraith> instance resolution uses only the type variables present in the class declaration.
19:33:49 <dmwit> plugin: I believe that would be sufficient: if there were an `instance (Foo x, Foo y) => Bar Baz x y` lying around, and you had extracted `Foo x` and `Foo y` from existentials, you could rely on `Bar Baz x y` being available.
19:34:21 <c_wraith> as long as no overlapping instances exist I suppose.
19:35:29 <plugin> Ok, I thought so, but I can't seem to convince GHC that the instance `Bar Baz x y` exists once I pattern match on `SomeT`
19:35:50 <dmwit> Time for an MCVE. =)
19:36:05 <plugin> MCVE?
19:36:15 <dmwit> minimal, complete, verifiable example
19:36:36 <dmwit> An acronym I picked up from spending a lot of time on StackOverflow. Some more writing on it here: https://stackoverflow.com/help/mcve
19:36:46 <dmwit> ?paste the result online and send us a link
19:36:46 <lambdabot> Haskell pastebin: http://lpaste.net/
19:36:52 <plugin> ahhh, if only it were that easy!  i've been trying to figure out this problem for weeks!
19:37:11 <dmwit> Oh, nobody ever claimed making an MCVE was *easy*. That would be daft.
19:37:58 <c_wraith> if you are sure your instance is good, just unsafeCoerce x and y to known types such that the instance is resolved.
19:38:35 <dfeuer> Thus far I've found only one thing overlapping instances are good for, and that doesn't involve any code that uses them.
19:39:08 <plugin> I've tried that as well, unsafeCoerce gets me cannot deduce `Baz bar x0 y0`
19:39:36 <dfeuer> class DelayedError msg ; instance TypeError msg => DelayedError msg
19:40:01 <dfeuer> Now if I write a function foo :: TypeError msg => ..., I will get a type error for its definition, because GHC hates hypotheticals.
19:40:03 <dmwit> I'd love to give you more advice, but as it stands, I don't actually know what you tried, and neither does anybody else in the channel.
19:40:19 <dmwit> Except *possibly* for you, and even there I'm not super convinced. =P
19:40:34 <dfeuer> But if I write a function bar :: DelayedError msg => ..., it works fine because GHC won't reduce the constraint, fearing that something will overlap.
19:40:36 <dfeuer> It's horrible.
19:41:35 <plugin> Yeah, I know, i've tried more than a few things.  let me see if I can get an old MCVE that is still representative of the problem
19:49:05 <redrapscallion> does anyone here have any experience with Spock + blaze-html? I just want Spock to use blaze-html to output a simple web page, but I can't seem to figure out how I'm supposed to integrate blaze-html's Html type with Spock's ActionCtxT type
19:49:29 <redrapscallion> or am I going about it in the wrong way?
19:51:16 <sqooq> I'm back
19:52:32 <crank> hi
19:53:28 <sqooq> Idk if anyone who was helping me earlier is still here, but I'm like 90% sure I got the state manipulation right
19:53:28 <sqooq> But it's like the parser is ignoring it
19:53:31 <sqooq> I did ParserT State
19:53:37 <sqooq> Idk if somehow the order here is messing it up
19:53:49 <sqooq> I swear I'm doing the actual computation right...
19:54:30 <pavonia> sqooq: Got some example code?
19:55:29 <sm> redrapscallion: good question.. not obvious
19:55:39 <sm> in older Spock, there was a blaze function
19:56:06 <redrapscallion> sm: yeah, I saw that, but it doesn't exist in the version I'm using :(
19:56:54 <sm> and no changelog to explain
19:57:47 <sm> you could use http://hackage.haskell.org/package/Spock-lucid instead
19:59:00 <sm> or look at its code at least
19:59:31 <sm> http://hackage.haskell.org/package/Spock-lucid-0.4.0.1/docs/src/Web-Spock-Lucid.html#lucid
20:00:11 <crank> l
20:00:14 <freeman42x]NixOS> any ideas where I could find the equivalent of this but for Linux? https://hackage.haskell.org/package/Win32-2.6.2.0/docs/Graphics-Win32-Window-ForegroundWindow.html (a way to get foreground window and check its title for example)
20:00:18 <redrapscallion> sm: yeah, it's pretty short, so it looks like it's something that I should've been able to figure out myself
20:00:18 <sm> or use an easy framework like yesod 8-]
20:00:31 <crank> hmm
20:00:46 <crank> exit
20:00:49 <crank> exit
20:00:50 <sqooq> pavonia:
20:00:50 <sqooq> http://lpaste.net/364893
20:00:52 <sqooq> I tried flipping it to StateT Parser
20:00:57 <crank> exit
20:01:02 <sqooq> but idk how
20:01:18 <sqooq> because Parser takes one more argument, the return type
20:01:49 <sqooq> o wait
20:01:56 <sqooq> i guess it uses the return type f stateT
20:02:01 <sm> in haskell, short does not imply easy to figure out, I find :)
20:02:10 <redrapscallion> sm: so what exactly is the high-level approach for this?
20:02:42 <redrapscallion> sm: I mean, it's only two lines of code -- but if I had to do it myself, how would I start?
20:03:12 <sm> redrapscallion: well, do you have to use blaze-html ? or can you use lucid ?
20:03:31 <redrapscallion> sm: I'm not restricted to blaze-html, but I'd prefer to use it because there's more documentation for it.
20:03:56 <pavonia> sqooq: Where's the problem exactly?
20:04:02 <sqooq>   • Expecting two fewer arguments to ‘StateT Bool (Parser Void String)’
20:04:26 <sm> ok, just  not as well supported in Spock apparently.. well I guess you translate this lucid code to blaze, it's probably quite similar. Or, look at the old Spock blaze function
20:05:37 <sm> https://hackage.haskell.org/package/Spock-0.6.0.0/docs/src/Web-Spock-Core.html#blaze
20:05:40 <pavonia> sqooq: You should start with giving all your functions type signatures
20:05:45 <sqooq> pavonia: It's supposed to not parse "[! x [x !]]" but it doesn't
20:05:52 <sqooq> but it does... I mean
20:06:00 <sqooq> It's supposed to not parse that, but it parses successfully
20:06:37 <redrapscallion> sm: oh. I just took my time to properly read it, and it's so damn simple
20:06:57 <freeman42x]NixOS> made it into a SO question: https://stackoverflow.com/q/49869233/750216
20:07:11 <redrapscallion> sm: there's a function to convert Html -> String, and so all I had to do was convert String -> Text and then Text -> ActionCtxt through Spock
20:07:11 <sqooq> o i figured out how to flip, derp. It's Parsec not Parser
20:07:19 <sqooq> I was referening my own type synonym within the type synonym
20:08:57 <sqooq> Switching it fixes it!!!
20:09:10 <sqooq> Idk why though. If anyone could illuminate that, that would be great.
20:09:21 <pavonia> sqooq: Your Parser Type looks very strange, token type is Void??
20:09:44 <sqooq> pavonia: no, it's the Error type, apparently Void is standard if you don't want to do custom errors.
20:09:54 <sqooq> since the library provides good errors already
20:10:20 <sm> redrapscallion: cool. Haskell libs are too often this way, unfortunately - well factored and flexible but non-obvious how to put together
20:10:28 <pavonia> Oh it's Megaparsec
20:10:30 <sqooq> pavonia: this is megaparsec btw
20:10:33 <sqooq> ye sorry lol
20:10:36 <sqooq> should have mentioned that
20:14:57 <sm> I suppose instead of a clearly marked well-travelled road to a town, it's a maze of deer trails all over a mountain
20:16:17 <sm> with mysterious kung-fu monks at the top
20:16:20 <redrapscallion> sm: probably a side-effect of popular languages always having paragraphs and paragraphs of docs, but i'm super unused to actually reading the source code to figure out something works
20:17:23 * sm would file a bug
20:19:59 <redrapscallion> sm: ehh, that's too much work. I just need to grok how Haskell's libraries work (and monads... eventually) and then I'll be set to maybe make something useful.
20:25:32 <sm> I'll do it. This is a travesty. https://github.com/agrafix/Spock/issues/142
20:52:20 <freeman42x]NixOS> is it possible to specify Stackage dependencies to be obtained using Nix under stack.yaml?
22:00:23 <cocreature> freeman42x]NixOS: no, stack will always fetch Haskell deps itself
22:00:59 <freeman42x]NixOS> cocreature, thank you, that is all I wanted to hear
22:03:33 <cocreature> freeman42x]NixOS: maybe https://github.com/input-output-hk/stack2nix is what you’re looking for?
22:06:53 <freeman42x]NixOS> that would do if it was working :) https://github.com/input-output-hk/stack2nix/issues/48#issuecomment-320450640
22:07:46 <cocreature> seems like you can just use the master branch?
22:08:20 <robstr> Morning
22:08:33 <iqubic> Why not just learn nix and skip the middle step here?
22:09:32 <freeman42x]NixOS> cocreature, I tried, building took about 40 minutes, didn't work, same error
22:09:55 <freeman42x]NixOS> iqubic, that is exactly what I am doing, bye bye Stack
22:10:32 <iqubic> What guide are you using?
22:10:56 <freeman42x]NixOS> iqubic, for what?
22:11:32 <iqubic> for learning to integrate nix and stack.
22:14:03 <freeman42x]NixOS> iqubic, oh, I am giving up on Stack, that's what I meant, wasted too much of my life with it
22:14:44 <johnw> freeman42x]NixOS: I've never used stack, and Nix has caused me to never want to
22:15:02 <johnw> I do use cabal during development, since Nix has no concept of incremental builds yet
22:15:20 <johnw> my latest discovery is haskellPackages.developPackage
22:15:30 <johnw> which allows you to only need a package.yaml, and not having to list any dependencies in your default.nix file
22:15:40 <johnw> example: https://github.com/jwiegley/hnix/blob/master/default.nix
22:15:59 <iqubic> Does anyone have a good guide on nix + haskell that I can look at?
22:16:03 <freeman42x]NixOS> johnw, that it awesome
22:16:05 <johnw> iqubic: that's a great question, since most of the current guides are outdated
22:16:08 <cocreature> iqubic: https://github.com/Gabriel439/haskell-nix
22:16:15 <johnw> iqubic: the default.nix I just posted is a great way to get started
22:16:47 <johnw> with that in your project's directory, type "nix-shell" to do development (using cabal), or "nix-build" to build it with Nix
22:17:09 * hackage gi-webkit2 4.0.18 - WebKit2 bindings  http://hackage.haskell.org/package/gi-webkit2-4.0.18 (inaki)
22:17:12 <johnw> also, none of the guides right now (including Gabriel's) make any mention of developPackage
22:17:20 <johnw> I think it's too new
22:17:31 <iqubic> yeah, I suppose
22:18:19 <cocreature> gabriel does accept PRs afaik :)
22:18:28 <johnw> nice
22:18:37 <iqubic> What's the point of hpack?
22:18:39 <johnw> yeah, he's pretty helpful about that stuff, I just haven't written anything
22:18:48 <johnw> hpack reduces repetition, mainly
22:18:54 <johnw> and lets you use some yaml shortcuts
22:19:05 <johnw> i really like using it
22:23:47 <johnw> iqubic: example: https://github.com/jwiegley/hnix/blob/master/package.yaml
22:32:59 <sclv> can you use developPackage with a cabal instead of an hpack file?
22:33:09 <ClaudiusMaximus> argh. parsing left-associative operators (+ - / and juxtaposition for multiplication, no '*' symbol, right-associative ^) seems to be hard.  any tips?  i had something that parsed most expressions with juxtaposition but the operators were right-associative (making '-' counterintuitive/wrong)
22:33:50 <johnw> sclv: absolutely
22:34:14 <johnw> sclv: in fact, I keep the generated .cabal file around, because for whatever reason right now it hugely speeds up invoking nix-shell
22:34:21 <ClaudiusMaximus> now i have something that parses left associative, but without juxtaposition working (it wants to juxtapose 'a' with '+' in a + b, which obviously isn't going to work)
22:34:25 <johnw> ClaudiusMaximus: which parsing library are you using?
22:34:47 <ClaudiusMaximus> johnw: parsec, but i'd be happy to switch if there's something that would work better
22:34:50 <johnw> if it's parsec, see chain1l, if it's megaparsec, they have a convenient expression builder, same with trifecta
22:35:15 <johnw> for example: https://github.com/jwiegley/hnix/blob/master/src/Nix/Parser/Operators.hs#L68
22:35:21 <johnw> this parses all of the operators of the Nix language
22:35:32 <ClaudiusMaximus> johnw: i tried with chain1l, but the operator parser accepting the empty string seems to be problematic
22:36:05 <ClaudiusMaximus> https://github.com/jwiegley/hnix/blob/master/src/Nix/Parser/Operators.hs#L84 looks promising, hm
22:36:46 <johnw> I have more data in that table than you would need
22:36:59 <johnw> so that I can introspect precedence and associativity later
22:37:23 <johnw> there's probably duplication in there, though, it grew orangically from another parser
22:38:13 <dminuoso> Mmm. Is `foldr @[] f x l` a hylomorphism?
22:38:15 <cocreature> ClaudiusMaximus: https://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Expr.html is often helpful
22:38:31 <cocreature> or https://hackage.haskell.org/package/megaparsec-6.5.0/docs/Text-Megaparsec-Expr.html#v:makeExprParser if you’re using megaparsec
22:38:38 <johnw> dminuoso: no, it's a catamorphism
22:38:51 <johnw> :t foldr
22:38:53 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
22:38:55 <dminuoso> johnw: Well I can see that.. but..
22:39:09 <johnw> dminuoso: to be hylo, you'd need the ana aspect
22:39:41 <ClaudiusMaximus> i need something that can parse "abc-zw+xy" as (((a*b)*c)-(z*w))+(x*y)
22:39:50 <dminuoso> johnw: Reading this paper a hylomorphism is a function h ∈ A -> C whose call tree is isomorphic to a cons list.
22:40:17 <dminuoso> That is "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire"
22:41:01 <johnw> hylo is cata . ana. the cata part we know: folds a structure down to a value using an algebra f a -> a. The ana part "unfolds" to build up a structure from a seed, using a co-algebra a -> f a
22:41:17 <johnw> composing them together goes from seed to result
22:41:31 <johnw> with the use of a structure to build the algorithm between (with the hope that it the optimizer will fuse it away)
22:45:18 <iqubic> What are we talking about here? What is a cata, and an ana? Are there any guides for these around?
22:46:09 <johnw> in the Haskell world it's called "recursion schemes"
22:46:28 <johnw> https://medium.com/@jaredtobin/practical-recursion-schemes-c10648ec1c29
22:46:49 <johnw> the paper he mentioned is a more authoritative source
22:48:15 <iqubic> If I want to use nix, instead of cabal or stack, what emacs package should I use?
22:48:48 <johnw> what do you mean?
22:49:31 <iqubic> I know that I shouldn't use intero, because that requires stack, which I'm not using.
22:49:51 <johnw> ah
22:49:57 <johnw> i just use haskell-mode and it's cabal integration
22:50:04 <iqubic> I want to know what emacs package will help me work with haskell code when using straight nix.
22:51:15 <dminuoso> johnw: Well formally if you already have a list, you could think of it being produced as the result of an unfold though, couldnt you?
22:51:27 <dminuoso> johnw: Or is that composition with the hopes of fusion the key thought here?
22:52:01 <iqubic> Well, I don't understand why the Fix datatype is a thing that exists.
22:52:05 <ClaudiusMaximus> oh nevermind.  my problem runs deeper - my grammar is ambiguous because i use | | bracketing to denote absolute values, and it doesn't know that out of the many ways to pair them up, to pick the pairing that parses successfully (or error if there is no unique successful parse) :(
22:52:11 <jackdk> iqubic I have had some success with dante but it needs emacs25 and has been a bit funky at times
22:52:16 <johnw> it's really about the composition of a recursion scheme over an f-algeba, and a co-recursion scheme over an f-coalgebra
22:52:22 <jackdk> https://github.com/jyp/dante/
22:52:25 <johnw> if you have both, and glue them together, you get hylo
22:52:39 <iqubic> jackdk, I have tried dante, but I haven't found it useful.
22:53:04 <iqubic> Why is Fix a thing?
22:53:14 <iqubic> like what is the purpose of it.
22:53:20 <dminuoso> iqubic: For the same reason that `fix` is a thing.
22:53:25 <johnw> Fix allows type recursion without stating it in the type
22:53:30 <iqubic> Fix f = f (Fix f)
22:53:32 <dminuoso> iqubic: It's a way to talk about recursion without re cursion.
22:53:46 <iqubic> Yeah I never understood the basic fix functiono.
22:53:53 <dminuoso> iqubic: It's the same thought just on a type level.
22:54:00 <johnw> Like, if you wanted a structure where you had Maybe (Maybe (Maybe ...)), without knowing ahead of time how many layers of Maybe there would be, then Fix would be your solution
22:54:04 <jackdk> iqubic that's the only one I know, sorry
22:54:27 <iqubic> johnw: How would you end that stack of Maybe?
22:54:41 <johnw> iqubic: you could use such a thing to encode the natural numbers :)
22:55:01 <iqubic> johnw: That's what the medium artical you linked does.
22:55:06 <johnw> Int ≅ Fix Maybe
22:55:12 <johnw> well, >0
22:55:17 <johnw> err, >=0
22:55:22 <dminuoso> The relationship between natural numbers and lists was one of the most revealing things I have stumbled across. =)
22:55:31 <johnw> it's all about induction
22:55:50 <iqubic> data ListF a r =
22:55:53 <iqubic> nilF
22:56:11 <iqubic> | ConsF a r
22:56:22 <iqubic> deriving (Show, Functor)
22:56:49 <iqubic> type List a = Fix (ListF a)
22:56:52 <johnw> iqubic: here's a real world example: https://github.com/jwiegley/hnix/blob/master/src/Nix/Expr/Types.hs#L55
22:57:09 <iqubic> How the heck does that list definition thing work?
22:57:15 <johnw> having the expression type expressed as an F-algebra like this has given our project some very nice flexibility
22:57:34 <johnw> iqubic: you should code up some of the traditional list functions and work it through
22:57:52 <johnw> grokking recursion through Fix/fix is an illimunating path to tread
22:58:41 <iqubic> I can't do that because I don't have a good emacs package to work with Haskell in.
22:58:55 <dminuoso> iqubic: You do not need a good emacs package to work with Haskell in.
22:58:58 <fishythefish> iqubic: if you expand the Fix, you get something like List a = ListF a (ListF a (ListF a ...))). The inhabitants of this type will be a series of (ConsF a)s ultimately applied to a NilF
22:59:01 <iqubic> I should get a Haskell + Emacs workflow.
22:59:02 <dminuoso> You just need an editor with syntax highlighting as minimum.
22:59:27 <iqubic> fishythefish: Where did the r go?
22:59:38 <dminuoso> iqubic: remember `fix` ?
22:59:47 <iqubic> A bit.
22:59:52 <iqubic> Not really though.
22:59:55 <fishythefish> iqubic: the `r` is the thing to the right of each `ListF a`
23:00:17 <iqubic> I know that. But how does that factor into what a list actually is.
23:00:39 <fishythefish> iqubic: give me an [a] and I'll translate into a List a
23:00:41 <iqubic> johnw: What do you use for haskell development in emacs?
23:01:01 <iqubic> fishythefish: [1,2,3]
23:01:13 <fishythefish> ConsF 1 (ConsF 2 (ConsF 3 NilF)))
23:01:22 <iqubic> Oh, I see.
23:01:27 <iqubic> I see how that works.
23:01:31 <dminuoso> iqubic: It's a mistake to think you can't develop Haskell without intero + bells and whistles. Quite a bunch of the experienced Haskellers develop just on plain emacs/vim/neovim with crazy language plugins, intero/ghc-mod/ghcid.
23:01:43 <iqubic> Why not just use this:
23:01:44 <dminuoso> Based on reading the mailing lists and this channel :)
23:02:04 <fishythefish> iqubic: of course, there's actually the constructor for `Fix` appearing at each level of the recursion, but that's essentially boilerplate
23:02:11 <iqubic> data List a = Nil | Cons A (List A)
23:02:17 <iqubic> why not just use that?
23:02:37 <fishythefish> you could
23:02:40 <iqubic> Why bother with the ListF definition?
23:02:54 <iqubic> What is the point that the medium artical is driving at?
23:03:06 <fishythefish> well, in some cases, you might prefer to not have explicit recursion
23:03:18 <dminuoso> iqubic: data ListF a r = NilF | ConsF a r deriving (Show, Functor)
23:03:22 <dminuoso> Is recursion free right?
23:03:37 <iqubic> Yes.
23:03:43 <guest> I have functions a,b,c, d and transition function  `f =  a >>= b >>= c >>= d`, here any one of the a,b,c and d can throw excption, how can I implement exception in this situation?
23:03:43 <fishythefish> but IMO the real utility is that if you have a function which should apply to recursive datatypes generally, then you can take a (Fix f) as an argument rather than specializing for each recursive type
23:03:49 <dminuoso> type List a = Fix (ListF a)
23:03:57 <dminuoso> Voila. I made a recursive thing without talking about recursion.
23:04:03 <iqubic> I see.
23:04:26 <iqubic> And then we get.
23:04:46 <iqubic> cons x xs = Fix (ConsF x xs)
23:05:20 <iqubic> and
23:05:38 <fishythefish> right, you can define "constructors" corresponding to each actual constructor of the underlying functor
23:05:39 <iqubic> nil = Fix  NilF
23:06:20 <iqubic> And that let's you ignore the Fix constructor altogether.
23:06:44 <iqubic> What the heck is the point of using the Fix constructor in the first place if you just factor it out?
23:06:53 <fishythefish> it allows you to ignore it while you're building stuff up
23:06:54 <dminuoso> iqubic: The core idea is abstraction over recursion.
23:06:59 <fishythefish> you might still see it in pattern matches
23:07:08 <jle`> iqubic: you can take advantage of people who write functions for Fix-made things
23:07:17 <jle`> so isntead of writing your own functions for your list type
23:07:26 <jle`> someone else wrote functions polymorphic for all 'Fix f's
23:07:34 <jle`> and you can just use those instead
23:07:55 <iqubic> Wait, you can write functions forall f. Fix f?
23:08:21 <iqubic> What good would that be?
23:08:30 <jle`> yeah, that's the whole point
23:08:40 <dminuoso> iqubic: A function that can work on *any* recursive structure?
23:08:41 <jle`> so you do'nt have to write them youself
23:08:44 <dminuoso> What good that would be?
23:08:45 <fishythefish> it's a general framework for recursion
23:08:51 <fishythefish> see Data.Fix
23:08:53 <jle`> someone else wrote it for you, you can just re-use their code
23:09:20 <jle`> for example, if you made list using Fix f, you automatically get a foldr and unfoldr function, since someone wrote those to work for all Fix f
23:09:58 <jle`> iqubic: think of something simpler -- would you write a list type for just lists of ints?
23:10:05 <iqubic> No.
23:10:09 <iqubic> I would not.
23:10:10 <jle`> data IntList = IntNil | IntCons Int IntList
23:10:22 <jle`> right, because you'd ahve to define length, fold, map, etc.
23:10:29 <jle`> for every single type of list you write
23:10:43 <jle`> but what if instead you wrote a polymorphic list that contained any type you wanted
23:10:52 <jle`> then you can write length, foldr, map, etc. to work on lists of any type
23:10:58 <jle`> length :: forall a. [a] -> Int
23:11:09 <iqubic> So this time the thing we are abstracting out is the recursion that defines a list, and not the type of the list elements?
23:11:15 <fishythefish> ^ just as this allows us to generalize over the element type, Fix allows us to abstract over the recursive structure itself
23:11:31 <guest> I have functions a,b,c, d and transition function  `f =  a >>= b >>= c >>= d`, here any one of the a,b,c and d can throw excption, how can I implement exception in this situation?
23:11:49 <jle`> yeah, recursion-schemes and data-fix are basically full of functions that work on forall f. Fix f
23:11:56 <dminuoso> Is there a way to get explicit forall in GHCi when using :t/:i/etc?
23:12:06 <jle`> just like Data.List is full of functions that work on forall a. [a]
23:12:14 <iqubic> so the generalized unfold would work for a Fixified list or a Fixified tree?
23:12:15 <jle`> dminuoso: :set -fprint-explicit-for<tab> ?
23:12:20 <jle`> iqubic: mhm
23:12:21 <iqubic> How is that possible?
23:12:39 <dminuoso> jle`: Oh that's great thanks. I need to work through those settings I think.
23:13:40 <iqubic> Where is the source for fold and unfold that work over all Fix f?
23:13:43 <fishythefish> iqubic: loosely, the Functor instance for the underlying ___F type says what to do with each constructor you might encounter, while the Fix functions generally say how to recurse
23:13:52 <jle`> another stylistic benefit of recursion-schemes based writing is that you oftne do'nt have to use explicit recursion in your code, so it leads to cleaner code too
23:13:59 <dminuoso> guest: If you are in IO, you can use Control.Exception. Beyond that monad transformers can tackle this.
23:14:11 <jle`> iqubic: from http://hackage.haskell.org/package/data-fix-0.2.0/docs/Data-Fix.html, the generic fold is 'cata'
23:14:17 <fishythefish> and unfold is `ana`
23:14:43 <iqubic> :t fold
23:14:44 <lambdabot> (Monoid m, Foldable t) => t m -> m
23:14:51 <iqubic> :t unfold
23:14:52 <lambdabot> error:
23:14:52 <lambdabot>     • Variable not in scope: unfold
23:14:52 <lambdabot>     • Perhaps you meant one of these:
23:14:52 <jle`> cata :: forall f. Functor f => (f a -> a) -> Fix f -> a
23:14:57 <jle`> cata for lists is 'foldr'
23:15:05 <iqubic> What is the ana for lists?
23:15:09 <jle`> for the data ListF a r = NilF | ConsF a r
23:15:15 <jle`> it's unfoldr
23:15:22 <iqubic> :t unfoldr
23:15:23 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
23:15:38 <iqubic> What the heck does that do?
23:15:38 <jle`> notice that Maybe (a, b) is exactly ListF a b
23:15:44 <jle`> iqubic: it lets you build a list
23:15:48 <iqubic> How?
23:15:50 <jle`> from an initial seed
23:16:05 <iqubic> Can I get an example of that?
23:16:06 <jle`> > unfoldr (\x -> Just (show x, x+1)) 1
23:16:09 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17"...
23:16:24 <iqubic> why is the maybe needed there?
23:16:30 <jle`> to know when to stop
23:16:45 <guest> dminuoso : how can I throw exception in function a where f = a >>= b >>= c >>= d?
23:16:47 <jle`> > unfoldr (\x -> if x < 4 then Just (x,x+1) else Nothing) 1
23:16:50 <lambdabot>  [1,2,3]
23:16:58 <iqubic> Alright. I see.
23:17:02 <fishythefish> compare ListF a b = NilF | ConsF a b with Maybe (a, b) = Nothing | Just (a, b)
23:17:17 <jle`> iqubic: the (b -> Maybe (a, b)) takes a seed and returns a new item to put in your list, plus the updated seed
23:17:31 <iqubic> I see the relationship.
23:17:38 <jle`> and if you plug in ListF to the type signatre for ana
23:17:52 <iqubic> :t ana
23:17:53 <lambdabot> error:
23:17:53 <lambdabot>     • Variable not in scope: ana
23:17:53 <lambdabot>     • Perhaps you meant one of these:
23:17:59 <jle`> ana :: Functor f => (a -> f a) -> Fix f -> a
23:18:05 <jle`> er
23:18:11 <jle`> ana :: Functor f => (a -> f a) -> a -> Fix f
23:18:23 <jle`> ana :: (a -> ListF a b) -> a -> Fix ListF
23:18:38 <jle`> sorry
23:18:39 * hackage hoogle 5.0.17.3 - Haskell API Search  http://hackage.haskell.org/package/hoogle-5.0.17.3 (NeilMitchell)
23:18:40 <fishythefish> uh
23:18:44 <jle`> ana :: (a -> ListF b a) -> a -> Fix ListF
23:18:57 <iqubic> Oh, I see.
23:18:57 <fishythefish> Fix (ListF b)*
23:19:00 <jle`> thanks :)
23:19:16 <iqubic> I see.
23:19:37 <jle`> cata :: Functor f => (f a -> a) -> Fix f -> a
23:20:00 <jle`> foldr :: (ListF a b -> b) -> Fix (ListF a) -> b
23:20:27 <iqubic> > unfoldr (\x -> Just (show x, x+1)) 1
23:20:29 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17"...
23:20:42 <iqubic> Can you right that with an ana? How hard is the conversion there?
23:20:51 <iqubic> write*
23:21:08 <jle`> ana (\x -> ConsF (x + 1) (show x)
23:21:17 <jle`>                       )
23:21:34 <iqubic> what?!?! that's nearly the same thing.
23:21:54 <fishythefish> exactly :)
23:21:57 <jle`> yes, that's what i mean when i say that ana for lists is exactly unfoldr, they're the same function
23:22:01 <fishythefish> (modulo the conversion between the types)
23:22:14 <jle`> except ana works for *any* Fix f
23:22:17 <jle`> not just lists
23:22:27 <iqubic> Can you show me an ana for a different Fix f?
23:23:04 <jle`> i gotta go, but i'm sure some people here can, and there are some good blog posts too :)
23:24:05 <iqubic> https://medium.com/@jaredtobin/practical-recursion-schemes-c10648ec1c29
23:24:29 <iqubic> I'm reading this currently and it has links to a few other things.
23:25:03 <jle`> one nice thing about writing recursion schemes style is that if you can leverage cata/ana/etc., then you can turn code that might otherwise have used explicit recursion into code that doesn't
23:25:08 <jle`> which cuts out like 90% of potential bugs
23:25:16 <jle`> since explicit recursion is bug city
23:25:40 <iqubic> But this doesn't let you do any sort of looping or anything like that.
23:25:51 <jle`> it abstracts over the loping
23:25:54 <jle`> look at cata
23:26:00 <jle`> and how it relates to foldr
23:26:09 <iqubic> Is foldr even a loop?
23:26:32 <jle`> it's an iteration, which might have been what you meant
23:26:32 <mathZ> :src foldr
23:26:45 <jle`> it repeatedly calls a function for every item in the list
23:26:47 <mathZ> :t foldr
23:26:48 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
23:27:05 <jle`> if you didn't use foldr, you might have to explicitly use recursion
23:27:09 <iqubic> cata, ana, hylo, and para, can't replace for loops or while loops or anything like that.
23:27:22 <vaibhavsagar> why not?
23:27:25 <jle`> what do you mean by 'for loop' and 'while loop'
23:27:49 <jle`> i'm saying they can replace explicit recursion
23:27:55 <jle`> so let's say you watn to write a function that sums every item in a list
23:27:57 <iqubic> But not in all cases.
23:28:08 <jle`> you could write sum [] = 0; sum (x:xs) = x + sum xs
23:28:20 <jle`> but that uses explicit recursion
23:28:38 <jle`> but, using foldr/cata, you can write sum = foldr (+) 0
23:28:49 <jle`> no explicit recursion, much less likely to have a bug
23:28:57 <jle`> iqubic: yes, not in all cases.  that's why i said "if you can leverage ..."
23:29:23 <jle`> not "you can always leverage..." :)
23:29:45 <iqubic> I see.
23:29:59 <jle`> writing a function with explicit recursion, you open yourself up to a huge class of potential bugs
23:30:17 <jle`> but in situations where you can utilize cata/ana/etc., you can write the same function without explicit recursion
23:30:31 <jle`> and cut out a huuuuge class of potential bugs
23:30:46 <jle`> (not in all situations.  but in situations where you can utilize them.)
23:30:50 <vaibhavsagar> and potentially get better performance
23:31:30 <jle`> when i write recursive data types, i often just jump straight to the recursion schemes version because i know that if i write any functions for my type, it migt end up involving explicit recursion
23:31:41 <jle`> and i don't trust myself to write explicit recursion unless i absolutely have to
23:31:44 <jle`> gives me the peace of mind
23:32:29 <jle`> my code might still have bugs, but the space where bugs can pop up is dramatically reduced
23:32:34 <jle`> and it's one less thing to worry about
23:39:12 <honky> in StateT, there's no way to do IO from inside the state update function, right?  (state :: Monad m => (s -> (a, s)) -> StateT s m a)
23:39:47 <crobbins> i guess stack's templates aren't pinned to a resolver? you only get the latest?
23:40:11 <honky> even when MonadIO m
23:42:54 <honky> if i really wanted to print to stdout in there, is there a different option?
23:43:15 <dminuoso> honky: where do you want IO to be? in the s or a?
23:44:08 <honky> dminuoso: umm...  well s is pure, i just want to be able to print to stdout inside the (s -> (a,s)) i provide
23:44:58 <cocreature> honky: you could use get and put rather than modify
23:45:18 <cocreature> honky: or use the StateT constructor
23:45:28 <liste> honky: is it for debugging, or actual output?
23:45:33 <cocreature> % :i StateT
23:45:35 <yahb> cocreature: type role StateT nominal representational nominal; newtype StateT s (m :: * -> *) a = StateT {runStateT :: s -> m (a, s)}; -- Defined in `Control.Monad.Trans.State.Lazy'; instance [safe] (Functor m, MonadPlus m) => Alternative (StateT s m) -- Defined in `Control.Monad.Trans.State.Lazy'; instance [safe] (Functor m, Monad m) => Applicative (StateT s m) -- Defined in `Control.Monad.Trans.State.Lazy'; i
23:46:37 <honky> liste: debugging, but also practicing my understanding of how to do things...
23:47:02 <liste> :t trace -- can be used for debugging, but not the other thing :)
23:47:04 <lambdabot> error: Variable not in scope: trace
23:47:09 <liste> Debug.Trace.trace *
23:48:53 <cocreature> traceShowM is also often handy
23:49:02 <honky> cocreature: thanks, in this case i have reason to want to use `state` -- my update function is IntMap.alterF
23:49:29 <reactormonk> I wanted to write a foo :: m () -> m (), where I can control if the effect passed to foo when I run the monad transformer - how would I do that? I would like to run it in the original context, concerning exceptions.
23:49:45 <cocreature> honky: the StateT constructor is literally the monadic version of "state" so take a look at that
23:54:37 <honky> cocreature: hmm, something like StateT \s -> liftIO $ print "hi" >> return (a,s)?
23:54:54 <cocreature> yep
23:55:09 <pimlu> I'm trying to find an easy way to do a DFS on a graph with cycles in haskell
23:56:05 <pimlu> is that difficult in haskell? so far I've found a 25 page paper describing how to do it
23:56:06 <honky> cocreature: k thanks!  i also got a hint that i might be able to use the Compose functor, but couldn't figure out a direction to take that, does that sound like anything to pursue?
23:56:21 <Axman6> pimlu: have you looked at fgl?
23:56:44 <pimlu> I'm trying to write it myself, not use a library
23:57:00 <cocreature> honky: Compose doesn’t give you a Monad instance for the resulting type so if you need that it won’t work
23:57:18 <dminuoso> pimlu: Is the graph directed or undirected?
23:57:31 <pimlu> directed in my case, but ideally the algorithm wouldn't care
23:57:37 <pimlu> er, undirected in my case, sorry
23:57:51 <vaibhavsagar> pimlu: have you seen fgl?
23:58:07 <pimlu> lol I'm trying to write it myself
23:58:34 <vaibhavsagar> what data structure are you using to represent your graph?
23:58:38 <honky> cocreature: er i don't know if i need that?  i just want stdout from inside (s->(a,s))  :)
23:58:50 <vaibhavsagar> you can do a DFS the same way you would in any other language
23:58:58 <vaibhavsagar> same with a BFS
23:59:28 <pimlu> vertices are of type Set a, edges are of type a -> [a]
23:59:54 <vaibhavsagar> why aren't your edges a -> Set a?
