00:01:28 <naniii> how does Cloud Haskell compare to OTP with erlang/elixir? is it as good or not worth the effort? i ask because, given its claim of being erlang-style concurrency in haskell, i sure haven't heard much about it (and i assume it would be a noteworthy development if as good as erlang's; best of both worlds sort of thing)
00:02:57 <Axman6> I haven't seen many people using it, I think mainly because it (used to be) difficult to set up the communication side of things, at least last time I looked
00:03:31 <Axman6> I don't think there's anything _wrong_ with it, and it does have some advantages over the erlang version (types).
00:03:45 <Welkin> naniii: based on a presentation I watched from someone who uses it in production, cloud haskell is strictly better than erlang, except if you need to run millions of simple operations all at once
00:04:02 <Welkin> cloud haskell is erlang with a good type system
00:04:21 <Axman6> doesn't look like there's been much work on it since 2016
00:05:04 <Welkin> look on youtube and you'll find a presentation on it
00:05:12 <EvanR> whats a simple operation
00:05:38 <EvanR> doing an addition, or sending a message to a process
00:07:18 <EvanR> also, is there a library which gives you erlang process management on top of say async
00:07:33 <EvanR> without necessarily having remote processes like cloud haskell
00:08:11 <[exa]> dminuoso: renamer?! /me doing "oh lord" face
00:09:30 <cocreature> obviously fixity is part of renaming
00:09:50 <cocreature> rename infixl to infixr
00:13:33 <naniii> Welkin: so, 9 times out of 10, there's no reason for a haskeller to pick up erlang for its famed OTP anymore? "virding's first rule" has been broken?
00:14:45 <EvanR> haskell runtime is really good if all your threads are on 1 machine
00:14:52 <[exa]> naniii: what's virding's first rule? (googling it returns "college rules, xvideos" which is apparently not what erlang is about)
00:15:04 <EvanR> however you have to make the monitoring tree yourself
00:15:38 <naniii> [exa]: erlang co-creator rvirding claims, "Any sufficiently complicated concurrent program in another language contains an ad hoc informally-specified bug-ridden slow implementation of half of Erlang."
00:16:39 <[exa]> oh cool.
00:16:54 <EvanR> yeah of half of the erlang VM
00:16:59 <johnw> I'm at a point where I'm using AllowAmbiguousTypes, TypeApplications and UndecidableInstances everywhere, and I'm starting to feel like I'll never be clean again
00:17:04 <EvanR> but luckily not the erlang programming language
00:17:21 <isovector> johnw: that feeling goes away, and you'll start feeling dirty when you are not programming excluslvely at the type level :)
00:17:27 <johnw> haha
00:18:02 <[exa]> maybe wait for haskell2020 when we'll need "NoUndecidableInstances" for legacy stuff
00:18:03 <johnw> the problem is that it works and is insanely convenient, but at the same time it feels like something so very wrong is happening
00:18:20 <isovector> johnw: wrong how?
00:18:27 <dminuoso> johnw: UndecidableInstances seems perfectly fine to me.
00:18:29 <johnw> i don't know, morally wrong?
00:18:39 <johnw> I'm used to Coq where even overlapping instances is perfectly fine
00:18:50 <dminuoso> johnw: I mean, as long as the type system is sound..
00:19:14 <CodeKiwi> naniii that's a funny quote
00:19:27 <fishythefish> CodeKiwi: https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule
00:19:41 <CodeKiwi> it used to be about common lisp
00:19:49 <CodeKiwi> fishythefish ya
00:20:12 <dpyro> How can I create a single arbitrary value of a datatype that implements Arbitrary in QuickCheck?
00:20:20 <johnw> so, right now I'm using free-effects, not to govern the effects of the monad I'm in, but to allow me to report errors in a flexible way, so that you can plumb now error events throughout the code without changing anything. However, it means that the phantom type which carries the list of possible error types is ambiguous in most cases, because it often doesn't appear directly in in any of my arguments or my return type
00:20:59 <isovector> @dpyro: generate $ arbitrary @MyType
00:20:59 <lambdabot> Unknown command, try @list
00:21:15 <dpyro> do i include the @ symbol?
00:21:34 <isovector> dpyro: no, not if the type is inferrable
00:21:52 <dpyro> is that equivalent to (arbitrary :: MyType)?
00:22:27 <isovector> dpyro: yeah almost, except `:: Arbitrary MyType`
00:22:32 <johnw> i mean, what it means is that my type is literally now a full fledged argument, because it relates to runtime dispatch
00:22:37 <isovector> the keyword is "TypeApplications" if you want to go read about it :)
00:23:12 <isovector> johnw: do you have an example of how you're dispatching against this error type?
00:23:23 <johnw> isovector: yeah, let me make a little example
00:23:30 <johnw> I can't tell whether I'm being clever, or evil
00:23:37 <dpyro> ooh ty isovector
00:32:44 <CodeKiwi> fishythefish thanks for the link, I knew the original quote but didn't remember the name of it
00:34:09 * hackage perhaps 0 - Perhaps, a monad  http://hackage.haskell.org/package/perhaps-0 (EdwardKmett)
00:35:19 <EvanR> nice version number
00:36:17 <isovector> edwardk: corresponding changes coming to `constraints`? :D
00:42:54 <edwardk> isovector i just spent 8 hours working on backwards compatibility for a glorified Maybe
00:43:04 <johnw> isovector: ok, here it is: https://github.com/jwiegley/notes/blob/master/haskell/FreerErrors.hs
00:43:10 <edwardk> going to sleep before i consider mangling constraints
00:43:53 <isovector> good idea
00:44:22 <edwardk> on the plus side it works back to 7.2 with _everything_ i can think of now
00:44:49 <edwardk> so much cpp
00:45:21 <edwardk> used it as a pair programming exercise to show the other guy a bit of how painful backwards compatibility can be
00:45:26 <isovector> edwardk: i'd love to see a blog post or something about how you go about doing that stuff
00:45:29 <johnw> isovector: never mind, this is over engineered. There is nothing gained over just having these possible errors be each methods of another effect in 'm'
00:45:56 <edwardk> isovector well there are 20-30 patches there giving a timelapse view into the process
00:46:40 <isovector> johnw: still trying to grok this
00:46:47 <johnw> I think what motivated this design is that I want to be able to add "frames" of information for error reporting, while only knowing ahead of time that the notion of frames exist, and not what they might contain
00:50:20 <Ariakenom> Has edwardk considered live streaming any more? I remember a mention in a pair programming thread.
00:51:29 <edwardk> Ariakenom: slowly working up to it. basically i've been throwing open those pair programming sessions to anybody who wants to join, but not recording things for posterity. that way i can be free to make mistakes with limited consequences
00:52:47 <mniip> ooh
00:52:55 <mniip> what kind of things are you pair programming
00:54:09 <edwardk> over the last few days i've probably put in a good 12 hours of work with others on things like adapting a pretty printer for llvm from wl-pprint-text to prettyprinter, setting up a new project, some work on a bidirectional style typechecker, this partial thing, which i started mostly from scratch several hours ago, etc.
00:54:41 <edwardk> last week was getting unpacked-unordered-containers written (but not shipped) as it didn't pay out very well
00:55:18 <edwardk> and the setting up of a project for a rather less ambitious little bootstrap compiler for coda
00:55:29 <edwardk> thats the thing i'm starting to toy with now
00:56:41 <mniip> oh I think I remember coda
00:57:37 <edwardk> basically looking to work on more of the typechecking aspects and less of the editor bits
00:58:55 <edwardk> that said i admit i spent a day or two wasting time making sure my pretty printers were set up optimally ;)
00:59:28 <Ariakenom> what were they doing wrong?
00:59:52 <cocreature> edwardk: oh can we expect a PR for llvm-hs-pretty? I was thinking of doing that myself but hadn’t gotten around to it so far
01:00:51 <edwardk> cocreature: well, i have a module that is basically a port of llvm-hs-pretty from wl-pprint-text to prettyprinter that adds actual ansi styling, but i'm currently developing it in-repo for my project and adding coloring, etc. as i go
01:01:10 <cocreature> ah fair enough
01:01:47 <edwardk> and i realized part way through that i could write something that'd be nice for you, or i could write something that'd hook in better with stuff like my detection code for the width of the terminal and if i'm writing to an ansi screen, etc.
01:02:20 <edwardk> https://github.com/ekmett/coda/blob/master/src/Coda/LLVM.hs <- might be something you may want to steal
01:02:27 <edwardk> and just generalize 'function'
01:02:30 <cocreature> thanks, I’ll take a look
01:02:35 <edwardk> that style of argument passing is a bit safer
01:02:48 <edwardk> because you can make traversable types that directly correspond to the length of the argument list
01:03:43 <edwardk> https://github.com/ekmett/coda/blob/11af3261c3198d4fc4d20f04ffd78b8b3ab04f14/src/Coda/Console/Pretty/LLVM.hs is basicallt the llvm-hs-pretty code w/ color
01:04:12 <edwardk> and some minor improvements in removing unnecessary spaces
01:04:23 <edwardk> i've been meaning to clean more of those up as i go
01:06:41 <edwardk> https://usercontent.irccloud-cdn.com/file/RVdfqtGR/llvm-color.png
01:07:20 <cocreature> what’s your usecase for coloring LLVM IR? just to ease debugging?
01:07:59 <edwardk> honestly? i wanted to make sure the pipeline i was going to use for the rest of the language stuff in line had the color handling right, and yeah, it makes a repl experience where you show the llvm ir a bit nicer
01:08:31 <edwardk> i mostly decided i wanted nothing to do with something with an wl-pprint-text dependency when i saw that IsString instance.
01:08:39 * hackage OpenGLRaw 3.3.0.1 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-3.3.0.1 (SvenPanne)
01:08:55 <handicraftsman> Okkie lol
01:09:09 <handicraftsman> (checked out matrix, sorry for poking)
01:09:34 <edwardk> so i removed it as a transitive dependency, which necessitated inlining llvm-hs-pretty -- and i switched it over to prettyprinter as part of making all the pretty printing in the app more consistent
01:13:10 <edwardk> cocreature: i figured adding the annotations hurt nothing
01:13:37 <cocreature> sure
01:13:40 <edwardk> fixing up the spacing is harder than adding semantic annotations
01:23:33 <reactormonk> Is there a hashmap with a Both monoid instance somewhere in hackage? Basically a newtype with a whole lot function aliases.
01:24:14 <ontanj> hi! i'm new to haskell and trying to evaluate a function returning a list and adding an element to the beginning of the list, ie (x:match(a b c)). but the compiler complains that match is not a list but a function, how do i solve this?
01:25:08 <isovector> ontanj: maybe try `x : match a b c`
01:25:32 <s4ke> ontanj: haskell brackets are different to java/c/c++
01:25:34 <dminuoso> ontanj: It might be very helpful to not think about "evaluating a function" :)
01:25:47 <dminuoso> In the future
01:28:23 <ontanj> but it seems like an evaluation is what i'm after since it now says i have a function instead, but i see you point
01:28:51 <ontanj> anyway here's the proper code `Just x:match wc (wc:ps) xs`, this didn't work either
01:29:09 <dminuoso> ontanj: It's a precedence issue
01:29:28 <ontanj> right
01:29:39 <dminuoso> ontanj: Function application has highest precende, so your code parses as:
01:30:23 <fr33domlover> Q: I want to do a foldlM (or foldrM) on a Data.Map.Map but use both the keys and values, however there is no foldlMWithKey, what would be the nicest way to do that? Idea 1: use Map.toList and foldlM that list; Idea 2: Map each (k,v) pair into a function (a -> m a) and fold the result using (>=>) to get a chained (a -> m a) of all of them, and finally apply it to some initial value
01:30:38 <fr33domlover> Just curious how other people would do it
01:30:45 <fr33domlover> :)
01:31:01 <johnw> you can just do your regular fold, but produce an action as the result
01:31:02 <dminuoso> ontanj: (Just x):(match wc (wc:ps) xs)
01:31:14 <dminuoso> I think.
01:31:18 <f-a> my pc rebooted during a cabal install and now I am getting "truncated tar archive" errors
01:31:24 <f-a> should I axe .cabal?
01:31:40 <cocreature> fr33domlover: I’d just go with Map.toList
01:31:41 <johnw> foldl' (\action x -> action >>= \acc -> ... another action ...) (return z) xs
01:31:50 <johnw> yeah, or go with Map.toList haha
01:31:52 <merijn> f-a: You should figure out where the tar is downloaded too and nuke that
01:32:28 <fr33domlover> Thanks cocreature, johnw :)
01:32:34 <dminuoso> ontanj: The thing is, evaluation does not happen the way you probably think it does. :)
01:33:06 <ontanj> dminuoso: i see, but precedence is set with (), right?
01:33:19 <f-a> thanks merijn
01:33:33 <dminuoso> ontanj: Well () lets you associate things explicitly. Nothing more.
01:34:02 <dminuoso> ontanj: f g a = (f g) a /= f (g a)
01:34:07 <merijn> f-a: Because that error sounds like it get cut-off mid download and is now getting confused by "I've got a tar file, but it's broken", so nuking it should just redownload
01:34:09 * hackage vulkan-api 1.1.2.0 - Low-level low-overhead vulkan api bindings  http://hackage.haskell.org/package/vulkan-api-1.1.2.0 (achirkin)
01:34:16 <quicksilver> johnw: fr33domlover: or if you have Lens stuff on your mind, there is itraverse_ from TraversableWithIndex
01:34:38 <dminuoso> ontanj: The thing is, operators themselves have precedence and associativity.
01:35:00 <dminuoso> (:) for example has infixr 5
01:35:29 <f-a> merijn: worked \o/
01:35:36 <dminuoso> So once you start mixing function application and operators, then you have to be careful that things work out the right way. Usually a mistake will result in a type error (like you have gotten)
01:36:42 <ontanj> dminuoso: ok thanks, i'll have to think about this
01:37:16 <dminuoso> > Just 1:[]
01:37:18 <lambdabot>  [Just 1]
01:37:20 <dminuoso> > Just (1:[])
01:37:21 <lambdabot>  Just [1]
01:37:30 <dminuoso> ontanj: ^- as a little demonstration of your issues. :)
01:38:16 <quicksilver> ah, the well known "monkey with sun visor" term
01:39:36 <Wizek> Hey, anyone around who has some experience with Data.Dependent.Map?
01:40:02 <ontanj> dminuoso: it compiles now! thanks!
01:41:19 <Wizek> Or someone who can help out by showing me working example usage?
01:41:33 <Wizek> https://github.com/mokus0/dependent-map/pull/16
01:41:50 <Wizek> the example in the readme doesn't compile, and the updated example doesn't compile either.
01:43:00 <Wizek> Or anyone knows of a similar package alternative that might be better supported?
01:43:16 <merijn> Wizek: Well, what are you trying to do?
01:44:10 <dminuoso> ontanj: Do you know about ($) ?
01:44:58 <Wizek> merijn: in the most immediate layer, to make something like this compile: `fromList [Foo :=> 'c', Bar :=> True]`
01:45:43 <fr33domlover> quicksilver, cool good to know it exists
01:46:47 <Wizek> merijn: a layer above that, I'd like to try a reflex architecture where I I'm using EventWriter in conjunction with some Map that allows me to name the events that propagate upward.
01:48:08 <Wizek> merijn: but since events are of different type, I can't use a regular map, so I was thinking DMap might help out here, but maybe not?
01:49:19 <merijn> Wizek: Or...you just define a sumtype for different things and use that?
01:50:56 <Wizek> merijn: sounds way to restricting. As events bubble up different events are supposed to be able to be added
01:51:23 <merijn> Wizek: tbh, this description is too vague for me to really say anything useful :)
01:51:41 <Wizek> merijn: so I'd need to define lots of different sum types for that, wouldn't I?
01:52:03 <merijn> Why?
01:52:20 <merijn> Wizek: How many different result types are you gonna have in the end?
01:53:59 <Wizek> merijn: not sure about the end, as I'd like to keep this open-ended, extensible. But currently I have about 5-10 different kinds of events that can go upwards, and at different parts of the application, different subsets of those can be triggered
01:54:23 <merijn> Wizek: Yeah, but do all those events carry different typed data or just a few?
01:54:36 <Wizek> merijn: different
01:55:16 <merijn> And what do you do with them when they are triggered?
01:55:48 <dpyro> is there a way to use a literal number in the place of a type parameter?
01:56:21 <merijn> dpyro: Yes, with a whole bunch of caveats, depending on what you wanna do with them :)
01:56:54 <dpyro> i want to enforce a certain length on a bytestring
01:57:09 <dpyro> is there any reasonable way to do that?
01:57:39 <merijn> dpyro: Depends on how much suck still qualifies as reasonable ;)
01:58:07 <ontanj> dminuoso: yes, i know about $, it solved the problems!
01:58:13 <cocreature> dpyro: "newtype ByteStringN (n :: Nat) = ByteStringN ByteString" and then a bunch of smart constructors and wrappers for the bytestring API that enforce correct usage is one approach
01:59:07 <dpyro> is there anyway to inherit all the bytestring methods?
01:59:19 <dpyro> or do i have to manually unpack or pack to use it?
01:59:30 <merijn> dpyro: There is no inheritance, so: No
01:59:45 <merijn> dpyro: In fact, the entire point of newtype is explicitly to *not* allow that
01:59:59 <dpyro> true, as opposed to type
02:00:07 <cocreature> just copying the methods also won’t work. you need to tell GHC how the operations affect the length
02:00:10 <dpyro> i just wish there was a way to automatically unpack it
02:00:50 <Wizek> merijn: well, that depends quite a bit on the events themselves. Some are handled in a parent widget, some are bubbled further upward, and processed at the top.
02:00:58 <cocreature> dpyro: you can use "coerce"
02:01:19 <Wizek> merijn: Do you have experience with Reflex or some other FRP library?
02:01:43 <dpyro> ooh this coerce function looks likes what i want
02:01:55 <cocreature> but you still have to write the proper type sigs
02:02:01 <merijn> Wizek: Only a bit with netwire, and a bit of others
02:02:12 <dpyro> that's fine, i just don't want to have boilerplate repacking
02:02:38 <dpyro> i will try coerce and smart constructors, thanks
02:03:57 <dpyro> do i use GHC.TypeLits.Nat for Nat?
02:08:33 <cocreature> yep
02:19:40 <merijn> ugh, IOException is really obnoxious to deal with...
02:23:55 <Ariakenom> merijn, yes please solve
02:53:11 <dminuoso> Why are exceptions and logging so hard in Haskell... :(
02:53:27 <merijn> dminuoso: In what way?
02:54:14 <reactormonk> Is there something like GeneralizedNewtypeDeriving for functions? I wanna forward all functions to the underlying implementation.
02:55:09 <Taneb> reactormonk: not really? You can kind of use Data.Coerce, though
02:58:01 <crick__> Can I ask a non haskell question here?
02:58:16 <crick__> I am just stuck with one problem.
02:59:20 <maerwald> dminuoso: well, because we don't have checked exceptions for once
02:59:57 <maerwald> logging is just an annoyance that forces you into mtl or similar
03:00:09 <crick__> I asked it on ##algorithms but no one is responding...
03:01:57 <kuribas> crick__: sure ask, but you can also try #programming
03:03:05 <crick__> Okay, like I thought a lot but couldn't get it. Just curious to know how to go about thinking.
03:04:54 <crick__> So there are n temples, we know there closing times C1, C2, ...Cn. We also know the distances between pair of temples D(p,q). It's also mentioned that D(p,q) is not equal to D(q,p). Propose and algorithm to visit maximum number of temples knowing that you would be denied entry if you visit a temple after its closing time.
03:05:11 <crick__> I don't know whether its NP hard like hamiton path problem.
03:12:27 <fendor> is it safe and sensible to empty a broadcast TChan?
03:14:29 <fendor> use case: n threads write to a broadcast TChan and at a specific time, i want to read all messages so far and process them, can this be done?
03:18:49 <cocreature> fendor: just call tryReadTChan until you get back Nothing
03:21:10 <fendor> cocreature, isnt it possible, that the n threads write faster than i can read? or are these blocked when i read?
03:21:44 <fendor> cocreature, also, i am not married to the idea of using tchan, is tqueue more suited? or simple tvars?
03:22:47 <cocreature> if you care about that, you could always lock the whole TChan
03:23:12 <cocreature> but I’m not sure why you would want that. if your writers are faster, you better make sure you keep reading
03:23:30 <cocreature> also in that case you probably want a bounded chan
03:24:54 <mniip> fendor, you could push a separator into the queue
03:25:01 <mniip> and read from it until you encounter the separator
03:31:17 <fendor> mniip, that does not sound nice :D
03:32:52 <fendor> cocreature, well, we have ticks, we want to read at a specific time all messages that have been sent through the TChan. Bounded is not suited, imo because it probbaly has the same issue, if the reads are faster than the writes
03:33:22 <fendor> locking down the tchan might be acceptable, since the other threads would just wait and then continue, right?
04:01:19 <kuribas> what are the minimum RAM requirements for a haskell app?  (say a webapp)
04:01:36 <merijn> "It Depends (TM)"
04:01:41 <dibblego> 12 jigglydoos
04:01:50 <Akii> webapp that does nothing? few MB? >_>
04:02:36 <Ariakenom> send socket "<html></html>"
04:03:35 <Akii> dibblego: at least 14 jigglydoos, I'd say
04:06:07 <kuribas> does haskell run on embedded?
04:06:18 <merijn> kuribas: Yes, no, maybe
04:06:23 <kuribas> I suppose it should run well on a raspberry pi...
04:06:37 <merijn> RPi is hardly embedded according to most people's definition
04:06:39 <phadej> kuribas: most our internal services run with <100MB heap; few have larger (they keep stuff in memory); actual residency is larger, but compatible
04:07:11 <phadej> and yes, you can run haskell on RPi, PITA is compiling it to run there
04:07:26 <kuribas> yeah, that will be slow
04:07:50 <kuribas> or cross-compiling
04:07:50 <tdammers> I'm running a haskell web app on a VPS with 128MB RAM
04:07:57 <tdammers> but it's, uhm, challenging
04:08:16 <kuribas> or cross compiling using an emulator...
04:08:19 <phadej> I have run Haskell web-apps in heroku, they had 256MB limit then - they just worked :)
04:09:00 <tdammers> I've also run haskell stuff on a physical machine with 512MB RAM and a Pentium 4 CPU, and that worked OK
04:09:18 <kuribas> I suppose for <100MB rust is better.
04:11:30 <kuribas> tdammers: challenging how?
04:12:31 <tdammers> kuribas: avoiding the OOM killer, leaving enough RAM for the apache running in front of it, etc.
04:13:40 <kuribas> tdammers: but you can limit the memory for ghc?
04:19:50 <merijn> tdammers: Why run Apache instead of something smaller like nginx?
04:20:09 * hackage lens-utils 1.4.5 - Collection of missing lens utilities.  http://hackage.haskell.org/package/lens-utils-1.4.5 (danilo2)
04:20:15 <merijn> kuribas: Not really, but why would you need to?
04:20:30 <merijn> kuribas: You don't wanna compile on the VPS anyway
04:21:11 <kuribas> or lighttpd
04:21:35 <quicksilver> depending what the constraints are I'd say use a frontend proxy service
04:22:01 <quicksilver> and have your low memory VPS just run the bare haskell webapp with as little extras as you can
04:22:11 <quicksilver> but it does depend what you wre trying to do
04:23:26 <kuribas> merijn: -Msize
04:29:39 <merijn> kuribas: That doesn't mean it will succeed
04:31:26 <tdammers> well, apache pretty much because I know my way around it, and it was already in place
04:32:01 <tdammers> including stuff like caching, TLS, a bunch of rewrites, static file serving, etc.
04:32:17 <tdammers> nginx can do all that too ofc, but with apache I wouldn't have to look anything up
04:32:47 <tdammers> quicksilver: constraints for this one are pretty much "I have this $15/yr VPS, and I'm gonna make it as useful as I possibly can"
04:32:58 <quicksilver> tdammers: cloudfront free tier?
04:33:18 <tdammers> quicksilver: no.
04:33:36 <quicksilver> ok :)
04:33:56 <merijn> quicksilver: $15/year doesn't sound free to me :p
04:34:07 <tdammers> cheap local VPS service that did a bunch of stunt offerings years ago to attract a critical mass of customers
04:34:30 <quicksilver> that wasn't what I meant
04:34:34 <quicksilver> I should have been more explicit
04:34:50 <tdammers> oh, you mean I *should* use cloudfront
04:35:00 <quicksilver> "Instead of using a local apache for those reasons, did you consider instead using the cloudfront free tier to do your caching and TLS and static files"
04:35:13 <quicksilver> and that frees up more RAM on the VPS for haskell.
04:35:13 <tdammers> I did, and dismissed the idea immediately
04:37:52 <SneakySeb> Why? The free tier sounds like better value.
04:38:01 <SneakySeb> You get more than 256MB of RAM.
04:38:17 <tdammers> for starters, I consider the entire CDN concept broken by design, and cloudfront even more so
04:38:46 <CodeKiwi> for only $60 you can get a really nice vps at digitalocean :|
04:38:54 <quicksilver> ok. Well that's very interesting but it would be offtopic for me to ask you here why :)
04:39:04 <SneakySeb> I wouldn't consider it broken; clearly it does work. It's just not as rock-solid as a service which has dedicated hardware.
04:39:09 <CodeKiwi> $5/mo
04:39:51 <tdammers> SneakySeb: it breaks assumptions of trust, integrity, identity, etc.
04:40:00 <CodeKiwi> linode has decent too I think they have more ram maybe shrug...I like do better
04:40:26 <SneakySeb> tdammers: Wake up; when you rent a server, all of those things are inherently broken anyway.
04:40:39 * hackage int-multimap 0.1.1 - A data structure that associates each Int key with a set of values  http://hackage.haskell.org/package/int-multimap-0.1.1 (OShev)
04:41:13 <SneakySeb> You going to try to tell me someone can't take your hard drive out and put it under a microscope?
04:41:36 <CodeKiwi> oooh oooh I know this answer
04:41:38 <tdammers> SneakySeb: not the same level of brokenness though
04:41:47 <merijn> Anyway, this is offtopic here
04:41:49 <CodeKiwi> dm-crypt
04:41:58 <CodeKiwi> or ecryptfs
04:41:59 <tdammers> yes, it is, very much so
04:42:02 <SneakySeb> VPS is fine... if they're not overselling it. That's one thing you know can't be done with a dedicated server; they can't oversell your CPU or RAM resources. Just your internet... and that, they don't seem to do so often.
04:42:03 <CodeKiwi> or w/e you want
04:42:43 <SneakySeb> tdammers: When VPS is truly broken, it tends to correlate with the tendency for the provider to oversell... causing instability and latency for example...
04:44:05 <SneakySeb> Everything electronic is ultimately broken. It's amazing we have cars that drive us six laps around the planet without bursting into flames...
04:45:27 <SneakySeb> I mean, we truly are dealing with luck, here. Someone sprays some residual layer of chemical into a resistor... luck causes it to be resistive within spec for some years after.
04:46:15 <SneakySeb> We've seen CPUs with radioactive contamination and caps which explode within six months of being engineered... lucky that doesn't happen often!
04:47:58 <SneakySeb> If a cap dies in your dedicated server, unlucky for you...
04:48:03 <CodeKiwi> tin whiskers
04:48:10 <SneakySeb> Indeed.
04:48:23 <tdammers> well, spontaneous human combustion is a thing, how are you going to mitigate that?
04:48:26 <CodeKiwi> old caps
04:48:32 <SneakySeb> Seen those, too.
04:48:38 <hpc> tdammers: spontaneous human moisturization, obviously
04:49:06 <CodeKiwi> there's another one I can't even be sure exists I think it has to do with purple boards :| foggy memory
04:49:14 <SneakySeb> Tin whiskers and some transistors, several thousand volts leaked to the case... mmmm, zzzzzap!
04:49:48 <SneakySeb> Well, purple things are typically not all that UV stable... it seems like it'd degrade during curing to me.
04:50:07 <SneakySeb> It's just one of those colours, too close to UV in frequency.
04:50:57 <SneakySeb> For some reason green is fine... even though that means it is technically absorbing the UV, rather than reflecting it. Weird that.
04:51:17 <CodeKiwi> at the rate we're going though it's more likely the self driving cars will kill you than the hardware failing
04:52:22 <SneakySeb> Well, sure, they're possible to hijack... but they can have hardware failures themselves.
04:53:08 <SneakySeb> Technically it is the hardware failures which make them possible to hijack, and thus self-driving cars become a weapon for assassinations... I wonder how the U.S. will cope when the debate is no longer on whether guns should be legal, but on whether cars should be legal...
04:54:09 <SneakySeb> Eh, we could go back to the stone age and ask if a rock should be legal, because you can use rocks to kill people... that's what this generation has turned into. We should've never banned the asbestos.
04:54:40 <CodeKiwi> which do you see more likely, some idiot programmer designing something that causes accidents, or hardware spontaneously failing (AND the software not handling this situation in a way that doesn't kill someone)
04:54:56 <CodeKiwi> my bets on human failure
04:55:36 <SneakySeb> CodeKiwi: Well, they are both typically caused by human failure. A transformer winding, for example, will typically be wound by some human in a sweatshop in China.
04:56:04 <CodeKiwi> so even when it's a hardware problem it's still the human fault ;p
04:56:10 <SneakySeb> They may use machinery to wind it, but it is by their judgement that the winding ceases.
04:56:30 <SneakySeb> CodeKiwi: Much of the time, sure... Have you seen bigclivedotcom on Youtube?
04:56:48 <CodeKiwi> no, I've seen the name tho
04:57:06 <SneakySeb> He takes apart electronic components, and explains them. I've learnt a fuck tonne from him... I could probably make my own USB phone charger.
04:57:45 <SneakySeb> You can see how components fail by watching his channel... it's usually by error... dodgy workmanship, or a poor design...
04:57:45 <CodeKiwi> he's the ave of electronics
04:57:54 <SneakySeb> Yes.
04:58:51 <dminuoso> SneakySeb: A fully spec conform USB charger?
04:59:10 <Peaker> Hey, why does adding a build-depends to my .cabal file causes a rebuild of everything when trying to incremental-build? :(
04:59:57 <SneakySeb> Having said that, this is not the only piece of the equation. All of our PSUs are rated at 120-240V, on an AC cycle, so you can expect peak of 1.4x that in + and -... so you might have caps rated 200V rather than 120V for North America, because they have to expect that 1.4x boost... and then some... However, let's say you have some heavy machinery on the same power circuit, your equipment
04:59:57 <SneakySeb> might see occasional peaks of noise that go above the exceeded rating...
05:00:08 <SneakySeb> So it could even be the power supply which causes failure.
05:01:36 <phadej> Peaker: because it's conservative
05:01:42 <SneakySeb> This is why we switch surge protectors, because those are what saves us from those surges... but even surge protectors have some luck built into them; the more transient voltages they shunt, and the more regular the transients become, the less out of luck you are!
05:01:46 <Peaker> phadej, :-(
05:02:01 <phadej> Peaker: "how often you edit you code compare to how often you add dependencies" :)
05:02:22 <Peaker> phadej, that only speaks of how much worse it could have been, not how bad it is now :)
05:02:44 <merijn> Peaker: Are you using new-build?
05:03:00 <phadej> Peaker: take e.g. CPP, adding dependencies changes macro definitions - one have to go thru all files again
05:03:00 <Peaker> merijn, don't think so, is it "cabal new-build" ?
05:03:06 <merijn> Peaker: Yeah
05:03:15 <Peaker> phadej, but if the CPP result is the same, it can stop after CPP
05:03:42 <phadej> Peaker: well, there it's a spot where "there's only limited amount of people working on GHC"
05:03:53 <sp__> I have a question. If I have a Lazy.ByteString. How can I drop the 1st line ? I tried BL.dropWhile (/= '\n') but it does not allow me to compare Char with Word8
05:03:58 <phadej> Peaker: help is always welcome!
05:04:12 <Peaker> the problem with build systems is that everyone gets my pet peeves about correctness wrong, even shake (and to a lesser extent even tup)
05:04:38 <SneakySeb> Peaker: So you need to convert '\n' to Char or Word8... meaning you want '\n' :: Char or '\n' :: Word8, right?
05:04:42 <Peaker> phadej, and specifically, the build system inside ghc is sooo terrible :( I contributed once.. it was painful
05:05:04 <sp__> SneakySeb: I need '\n' to be Word8
05:05:07 <merijn> Peaker: new-build is considerably more aggressive about caching things. To the point where I have a hard time making it "uselessly" rebuild things when I want it to >.>
05:05:25 <SneakySeb> sp__: ... and what is the type of `'\n' :: Word8`?
05:05:34 <merijn> sp__: Repeat after me: ByteString is not a string, ByteString is not a String"
05:05:54 <merijn> sp__: The question "drop the 1st line of a ByteString" almost certainly means you should *not* be using ByteString
05:06:30 <chkl[m]> You could use ` fromIntegral.fromEnum` to convert from Char (which is an enum) to Word8 which is an integral type.
05:07:07 <Peaker> merijn, cool
05:07:25 <phadej> sp__: check 'Char8' module - and read the disclaimer
05:07:29 <merijn> Peaker: Speaking of which, I need people to beta-drive a cabal patch that reduces it's useless rebuilding :p
05:07:41 <sp__> phadej: ok
05:07:46 <merijn> chkl[m]: That is a *horrible* idea
05:07:54 <Peaker> merijn, "cabal configure" works but "cabal new-configure" fails complaining about falsely missing deps
05:08:14 <Peaker> merijn, is it a totally separate universe of packages?
05:08:44 <merijn> Peaker: hmm, you shouldn't need to "new-configure" in most cases
05:08:57 <chkl[m]>  > chkl[m]: That is a \*horrible\* idea
05:08:57 <phadej> Peaker: I recommend reading the http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html through
05:08:58 <chkl[m]> Always open for criticism, what's so terrible about it?
05:09:23 <opqdonut> there is no guarantee the char ordering matches the ascii codepoint
05:09:30 <opqdonut> there is some guarantee Data.Char.ord does that
05:09:31 <Peaker> merijn, new-build fails in the same way
05:09:37 <merijn> Peaker: new-configure is for specifying "permanent" flags, like --enable-profiling.
05:09:43 <merijn> Peaker: hmm, which cabal-install version?
05:09:53 <kuribas> is there a way to make a constraint from value equality at compile time?
05:09:57 <merijn> Peaker: And can you lpaste the error
05:10:08 <Peaker> cabal-install 2.0.0.1 on Cabal 2.0.1.0
05:10:28 <kuribas> like say class MyClass m where test :: Bool
05:10:35 <kuribas> then lift test to compile time?
05:10:57 <Peaker> merijn: http://lpaste.net/2789286911758303232
05:11:05 <merijn> Peaker: new-build uses a nix-style approach of tagging package with a hash of their transitive dependencies, which means you can have many different versions of the same package installed without conflicting. So it's basically like everything is automatically sandboxed, but you share dependencies across sandboxes
05:11:30 <merijn> Peaker: Ah, are you perhaps using local packages not on hackage? :)
05:11:35 <Peaker> merijn, indeed I am
05:12:00 <merijn> Peaker: You'll wanna create a cabal.project file and specify their paths there and it should Just Work (TM)
05:12:13 <merijn> Peaker: Something like: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/cabal.project
05:12:31 <merijn> Peaker: Actually, you should only need that first line
05:12:32 <Peaker> can it be in the directory of on of the packages?
05:12:42 <Peaker> I see it can, cool
05:13:17 <merijn> Peaker: And phadej's suggestion of skimming the new-build docs is good
05:13:37 <Peaker> merijn, it's auto-created cabal.project.local? It's there and I didn't create it
05:13:45 <merijn> Peaker: new-configure creates one
05:13:56 <Peaker> is it where I wanna add a "packages" line?
05:14:06 <merijn> Peaker: cabal.project is intended to be committed in your repo. cabal.project.local can provide local overrides
05:15:04 <merijn> Peaker: "It Depens", if both packages are in a single repo, cabal.project with relative path will make it trivial for people to check out and build. If you have separate repos and only wanna use the "development" version of a dependency on your machine, then .local
05:15:13 <kuribas> if I have a class method with no variables, it could be evaluated at compile time right?
05:15:57 <Peaker> merijn, I see, and I support a project file cannot reference a dependency's project file
05:16:00 <Peaker> suppose*
05:17:31 <merijn> Peaker: No, because that doesn't really make sense. Although I think there's some plans to allow things like "including" project files in each other, but that's not something that exists right now
05:18:19 <merijn> Peaker: actually, you can also use optional-packages, which will use the local path *if* it exists or try to get the dependency from Hackage if not
05:18:39 <Peaker> merijn, nice, seems to be chugging along with my deps now
05:20:01 <Peaker> merijn, thanks!
05:20:36 <merijn> Peaker: The package hashing is a bit conservative at the moment, so it's a bit to paranoid about "when should dependencies be rebuilt?", so if you like living on the edge and use GHC 8.0-8.4 you could help beta-test this patch: https://github.com/haskell/cabal/pull/5266
05:21:02 <merijn> So far it "Works On My Machine" ;)
05:21:56 <Boarders> does record wildcards unpack nested records?
05:22:10 <merijn> Boarders: I'm 95% sure it doesn't
05:23:56 <gentauro> will try again :) Is there a way for Aeson to decode to an Either JSON_A JSON_B?
05:24:19 <Peaker> gentauro, you from (FromJSON a, FromJSON b) => Either a b ?
05:32:32 <gentauro> Peaker: yes, where is that?
05:32:41 <gentauro> or rather said, how to use it :)
05:33:15 <gentauro> the REST service I'm calling either return { success: true} or { error: (details) }
05:35:39 * hackage tuple-sop 0.2.0.0 - functions on n-ary tuples using generics-sop  http://hackage.haskell.org/package/tuple-sop-0.2.0.0 (ferdinandvw)
05:37:31 <Peaker> gentauro, (Left <$> getA) <|> (Right <$> getB)
05:37:51 <dminuoso> Uh?
05:39:05 <dminuoso> gentauro: Just a straight `decode` should be enough.
05:40:54 <dminuoso> gentauro: aeson comes with an `instance (FromJSON a, FromJSON b) => FromJSON (Either a b) where ...`
05:42:24 <phadej> dminuoso: it's not Left <$> a <|> Right <$> b instance
05:43:35 <phadej> for {success: } or {error:... } one have to write code manually
05:44:28 <phadej> withObject "Response" $ \obj -> (Right <$> obj .: "success") <|> (Left <$> obj .: "error")
05:45:20 <dminuoso> phadej: Ah... so that instance is actually for straight up serializing Either into { "Left": ... } or { "Right": ...  }
05:45:27 <dminuoso> I didn't realize this. :)
05:45:37 <gentauro> dminuoso: Expected type: IO (Either Error Success) and Actual type: IO (Maybe a0) when using "decode". I will give Peaker approach a try
05:46:01 <gentauro> dminuoso: yeah, I want my Error into Left and my Success into Right
05:46:16 <phadej> dminuoso: yes, similar, but instead of success/error there are Left/Right
05:46:39 <phadej> and in fact it's strict so there shouldn't be other keys
05:46:41 <phadej> see http://hackage.haskell.org/package/aeson-1.3.1.0/docs/src/Data.Aeson.Types.FromJSON.html#line-1172
05:49:10 <gentauro> phadej: with your approach, I need to create Response to contain Error / Success?
05:49:28 <gentauro> ... withObject "Response" $ \obj -> ...
05:51:39 * hackage tuple-sop 0.2.0.1 - functions on n-ary tuples using generics-sop  http://hackage.haskell.org/package/tuple-sop-0.2.0.1 (ferdinandvw)
05:52:53 <the_2nd> Is it possible to define some funtion f :: (a -> b) -> b in such a way, that it both accepts a (a -> b) returning b and (a -> IO b) returning IO b? Or will I have to define two functions for that?
05:53:08 <the_2nd> e.g. a -> b being a pure or impure callback
05:53:30 <opqdonut> you can define a type class for those
05:53:45 <opqdonut> class Callback c where run :: c -> a -> IO ()
05:53:46 <opqdonut> for instance
05:53:58 <opqdonut> and then instances for (a -> b) and (a -> IO b)
05:54:19 <the_2nd> but then I always have the IO impurity?
05:54:31 <the_2nd> maybe abstract it to Monad?
05:54:37 <opqdonut> that's not possible
05:54:55 <opqdonut> to be able to run the IO callback run needs to have an IO type (or a MonadIO constraint or something)
05:55:29 <opqdonut> you could do something like `myFunctionThatTakesACallback :: Monad m => (a -> m b) -> m ()`
05:55:32 <the_2nd> and there's no way to have a special non-IO case where the function itself becomes pure?
05:55:36 <opqdonut> so abstract the whole thing over the monad
05:55:44 <opqdonut> and then use the Identity monad for the pure case
05:55:47 <opqdonut> that's the other option
05:55:52 <the_2nd> yeah that's what I meant at xx:54:09 :)
05:56:11 <opqdonut> yeah
05:56:39 <opqdonut> and then you can of course define a version `myFunctionWithPureCallback :: (a -> b) -> whatever` that does the Identity wrapping for the user
05:58:07 <the_2nd> looks good, thanks :)
05:58:59 <opqdonut> this pattern of abstracting over monad is quite common actually
06:16:16 <Peaker> cabal new-run doesn't run? "Up to date" and nothing
06:16:28 <merijn> Peaker: You need to specify the command to run
06:16:51 <merijn> Peaker: so if your executable is Lamdu it'd be "cabal new-run Lamdu"
06:17:28 <Peaker> merijn, that does nothing too
06:17:31 <merijn> -v0 if "Up to date" annoys you (new-run will (re)build your code if it's changed after last building)
06:17:33 <dmwit> Peaker: Yeah, a release with an incomplete new-run slipped through the cracks.
06:17:55 <dmwit> Peaker: I believe the latest release has a working new-run. Anyway it definitely works in master.
06:17:55 <merijn> Peaker: Ah, wait you have 2.0, yeah new-run was faulty in that
06:20:51 <dmwit> the_2nd: You definitely need two functions. Luckily if you make one work for any monad, the other can just be a call to `coerce`.
06:21:28 <dmwit> coerce :: ((a -> Identity b) -> Identity b) -> ((a -> b) -> b) -- ;-)
06:28:37 <mclark1129> When using stack, is it possible to reference local packages?  I want to share some code between multiple projects without copying pasting or symlinks.
06:31:10 * hackage int-multimap 0.1.1.1 - A data structure that associates each Int key with a set of values  http://hackage.haskell.org/package/int-multimap-0.1.1.1 (OShev)
06:33:56 <ziman> mclark1129: it should be possible with extra-deps: https://docs.haskellstack.org/en/stable/yaml_configuration/#packages-and-extra-deps
06:35:41 <mclark1129> Ok great. Thanks ziman.
06:42:50 <ventonegro> Reader, to use or not to use...
06:46:59 <cocreature> ventonegro: Reader on its own is rarely more convenient then explicit parameter passing ime. if you already have some monad transformer stack than adding a ReaderT to that might be convenient
06:48:12 <Psybur> Does this DSL make sense for an automated trader? https://hastebin.com/fojiqotaxe.rb
06:48:34 <Psybur> Or more specifically does it look like it would fit the free + interpreter pattern logically?
06:50:25 <cocreature> you might want to remove Done if you use it with free
06:50:37 <cocreature> but either way it should fit
06:51:12 <cocreature> whether it makes sense I don’t know. if you can express the things you care about in it then it probably does, if you can’t then it doesn’t :)
06:52:44 <Psybur> I guess Ill see how it works. Im just a little wary of the first three constructors having the same types, and then having to chain three getters to pass info to them
06:53:46 <ventonegro> cocreature: Yeah, I am wondering just because I will need the data only a few functions down the call stack
06:54:04 <cocreature> Psybur: you could factor the first three constructors into a single constructor that then takes another argument of type "data Op = Open | Cancel | Close"
06:54:09 <ventonegro> ... And I didn't want to pass it everywhere
06:55:28 <Psybur> cocreature, but I cant figure out what I would call that new constructor heh
06:55:36 <Psybur> "DoTheThing"
06:55:52 <Psybur> Perform? heh
06:56:31 <cocreature> naming things is hard :)
06:57:47 <Psybur> I think Execute will work
06:58:37 <ziman> cocreature already gave you a name in "data Op = ..." :)
06:59:59 <Psybur> Not the Op part
07:00:12 <Psybur> The new consolidated constructor in the DSL functor :D
07:00:29 <cocreature> you can call it "Op" as well ;)
07:01:24 <dminuoso> Op is just Hom_Hask(-, a) :o
07:02:20 <Psybur> Hows this? :D https://hastebin.com/powucinemo.sql
07:03:36 <dminuoso> Can I assume Hask = Set for the purpose of various category theory topics that require Set?
07:03:51 <dminuoso> Or are there things that set them apart?
07:04:21 <dminuoso> (Or rather.. are they isomorphic?)
07:06:18 <Ariakenom> Is it possible to write this Free function? Free Monoid = List; Free Monad = ...
07:06:18 <glittershark> the general accepted wisdom is Hask is set plus Bottom
07:07:19 <glittershark> ie every set has an extra member ⊥ representing exceptional or non-terminating computations
07:07:28 <Psybur> Free Monad = Free?
07:07:38 <dminuoso> glittershark: Well I have to pretend bottom doesn't exist, otherwise there are no terminal or initial objects..
07:07:46 <glittershark> dminuoso: most people do :)
07:07:50 <Ariakenom> Psybur, yes I omitted it due to name collision
07:07:51 <dminuoso> So a lot of universal constructions would disappear..
07:08:10 <glittershark> yeah the existence of bottom is sorta the crux of the whole "Hask isn't a category" argument
07:08:11 <Psybur> FreeM? :D
07:08:24 <glittershark> or at least the argument that Hask isn't truly closed cartesian
07:08:28 <dminuoso> glittershark: fast and loose reasoning is morally correct!
07:08:38 <glittershark> haha
07:09:27 <glittershark> but yes, from what I've heard (and I'm not a mathematician) most people consider Hask without bottom to be isomorphic to Set
07:12:41 <adjofun> isn't categories isomorphic to Set called topoi?
07:14:39 * hackage skeletal-set 0.1.0.0 - Skeletal set - a set with equivalence relation different from equality  http://hackage.haskell.org/package/skeletal-set-0.1.0.0 (PavloKerestey)
07:20:00 <Peaker> doh, after upgrading cabal-install to 2.2.0.0, it fails to new-build Lamdu :(  http://lpaste.net/1853771360275267584
07:21:22 <merijn> Peaker: I'm 90% sure I know the issue
07:21:32 <merijn> Peaker: nodejs-exec:setup.Cabal>=1.8 && <1.25) <- this looks like you have a custom setup?
07:21:45 <Peaker> there's build-type: Custom yeah
07:21:47 <merijn> Peaker: There was a solution, but I rofgot
07:21:50 <merijn> hvr: ping?
07:22:28 <Peaker> nodejs-exec has: cabal-version:       >=1.8  (no upper bounds)
07:22:28 <merijn> Peaker: Have a quick look at this ticket and see if that explains: https://github.com/haskell/cabal/issues/4288
07:23:00 <merijn> Peaker: Recent cabal has started tracking dependencies of Setup.hs independently of the rest of the package
07:23:17 <Peaker> so it assumes some very conservative thing?
07:23:22 <merijn> Peaker: Yeah
07:24:33 <merijn> Peaker: Assuming your Setup.hs is fairly straightforward it should be fairly simple to add a proper setup-depends and make it work
07:25:21 <Peaker> merijn, yeah, that seems to be it, thanks!
07:29:25 <Peaker> I hit "TODO: add support for multiple packages in a directory" despite not having multiple packages in a directory...
07:29:42 <merijn> Peaker: Running which command?
07:29:51 <Peaker> cabal new-build in lamdu
07:30:08 <merijn> Ah, try "new-build all"?
07:30:21 <Peaker> what does that do? Forget caches?
07:30:38 <merijn> ah, no, that's probably not it
07:30:58 <Peaker> it does seem to be building dependencies now
07:31:07 <merijn> Peaker: You have multiple cabal files in the same directory?
07:31:15 <Peaker> nope
07:31:48 <merijn> I don't think I've seen that error. What does your directory layout look like and your cabal.project (if any)
07:32:35 <Peaker> devel/deps-lamdu/<dependency>/<dependency>.cabal, and devel/lamdu/Lamdu.cabal, with a cabal.project.local file in devel/lamdu referring to Lamdu.cabal and the deps
07:33:12 <merijn> hmm
07:34:46 <merijn> Interesting, according to source comments you should not be able to hit that case :p
07:36:25 <Peaker> merijn, well, in the mean time it's building all the deps, maybe it'll work
07:36:36 <Peaker> is there a nice utility like "timeit" for pure copmputations? I want to hook my ekg server to timings of relevant pure computations
07:36:41 <GobiGobi> Hey guys why are sum types with record syntax a bad thing?
07:36:48 <Peaker> (To wrap a pure computation with unsafePerformIO of a time measurement)
07:36:58 <GobiGobi> and how does removing the record syntax fix the issue?
07:37:07 <merijn> Peaker: I don't think you can reliably do that without a lot of work?
07:37:20 <Peaker> GobiGobi, the fields generate partial functions that blow up at runtime if they're used at the wrong time without any compile-time detection of the issue
07:37:22 <merijn> GobiGobi: The record accessor will accept all constructors
07:37:32 <Peaker> merijn, if I reduce to NF?
07:37:44 <GobiGobi> is there a concrete example I can look at?
07:38:00 <merijn> GobiGobi: "data Foo = Foo { accessor1 :: Int, accessor2 :: Bool } | Bar { accessor1 :: Int }"
07:38:04 <LysergicDreams> I'm trying to expect an exception thrown during CSV record generation in HSpec. But I can only catch it if I do `evaluate (Csv.runParser . Csv.parseRecord $ Csv.toRecord someValue)`. For some reason just doing "evaluate (Csv.toRecord someValue) `shouldThrow` ..." doesn't work. Anyone have an idea why?
07:38:06 <Peaker> merijn, something like: measure thunk = unsafePerformIO (timeit (evaluate[or evaluateNF] thunk ?))
07:38:12 <merijn> GobiGobi: Now if I use "accessor2" you might accidentally crash
07:38:53 <GobiGobi> merijn: do you mean if you use "accessor2" on Bar, you may crash?
07:39:05 <merijn> Peaker: I think this might be a question for the mailing list or reddit, because I dunno enough details to say
07:39:09 <merijn> GobiGobi: Right
07:42:44 <GobiGobi> merijn: So basically in a function like "test :: Foo -> Bool" which uses "accessor2" to access the bool, "Foo" could be either "Foo" or "Bar" and this is where the possibility of crashing exists?
07:50:38 <merijn> GobiGobi: Right
07:50:47 <GobiGobi> merijn: thanks!
07:51:11 <GobiGobi> may the gods rain crypto upon you
07:51:32 <fr33domlover> s/gods/ghc
07:52:09 * hackage etc 0.3.2.0 - Declarative configuration spec for Haskell projects  http://hackage.haskell.org/package/etc-0.3.2.0 (RomanGonzalez)
07:56:56 <Peaker> merijn, new-build all works, new-build gives the multiple packages error
08:00:43 <merijn> Peaker: Are you calling new-build from a directory with a cabal file?
08:01:01 <Peaker> merijn, yes, devel/lamdu has the project file, cabal file, and that's where I try to run
08:01:46 <merijn> hmmm, odd. So basically, when you have multiple packages listed it needs to know which one to build (or all of them), but if you're in a directory with a cabal file it should default to that package
08:08:58 <dyl> Weird cabal question.
08:09:19 <dyl> Is it possible to have *global* haddock built for any package I install (in any sandbox/new project)?
08:09:42 <dyl> Hackage is very inconsistent with docgen but I'd like to have it all in one place and not scattered throughout projects.
08:20:09 * hackage int-multimap 0.2 - A data structure that associates each Int key with a set of values  http://hackage.haskell.org/package/int-multimap-0.2 (OShev)
08:28:39 * hackage pedersen-commitment 0.2.0 - An implementation of Pedersen commitment schemes  http://hackage.haskell.org/package/pedersen-commitment-0.2.0 (sdiehl)
08:32:09 * hackage expiring-containers 0.1.1.1 - Expiring containers  http://hackage.haskell.org/package/expiring-containers-0.1.1.1 (OShev)
08:37:05 <lseactuary> anyone here good at recursions? little stuck on one
08:37:09 * hackage simple-vec3 0.4.0.2 - Three-dimensional vectors of doubles with basic operations  http://hackage.haskell.org/package/simple-vec3-0.4.0.2 (DmitryDzhus)
08:37:16 <lseactuary> asking on the off topic channel but no one seems to be there
08:37:26 <woodson> Hi everyone, I building a drag and drop file upload using ghcjs ffi and I would like to be able to pass the file that got dropped in browser to my haskell code. I wondering if I can pass the file through ffi or my only option is to actually have a haskell server and send the file to the server?
08:37:57 <woodson> lseactuary: just post your problem
08:38:48 <lseactuary> cool here it is: http://lpaste.net/8522320034255601664
08:38:58 <lseactuary> im trying to model the "pass" bit. the rest is working and correct.
08:39:15 <lseactuary> e.g. if you are on floor 0, and press floor 3, you should pass floor 1 and 2. hence the recursion.
08:39:27 <lseactuary> but im unsure how to "update" the value to ensure 2 "pass" events.
08:40:42 <lseactuary> as currently it is just taking the final floor to "pass" through which is wrong
08:43:23 <woodson> lseactuary: what language is this? Also why dont you split your move, pass and wait functions into actual separate functions
08:43:31 <woodson> just so it can be a bit more visible
08:43:49 <fr33domlover> woodson, i never used ghcjs but if regular JS code can access a file you pick from the local filesystem, it seems likely that Haskell code compiled to browser JS should be able to do that too?
08:43:54 <lseactuary> woodson it is CSP language. yup this is the notation to split it out.
08:44:26 <lseactuary> its less the notation im worried above, im not understanding how to actually write the recursion. i can always play about with the syntax if i get an idea of what needs to happen
08:46:14 <woodson> fr33domlover, I can access the file through Javascript FFI but I would like to process process the file without having to read it on javascript ends
08:46:32 <woodson> because I will need to process zip files that might contain folders too
08:47:00 <woodson> and dont want to have to use Javascript FFI and would like to let haskell handle that part
08:47:45 <fr33domlover> woodson, hmm i hope someone with ghcjs experience has advice for you, i don't have the knowledge to help unfortunately
08:48:55 <woodson> fr33domlover, thanks for reply! last question can I send a file through websockets? I have never done in haskell just wondering how it would be done?
08:51:43 <fr33domlover> woodson, I'm guessing you can send *anything* over websocket! Check out the API of the relevant Hackage package
08:51:57 <fr33domlover> For example, I'm writing a web app with Yesod
08:52:05 <fr33domlover> If I wanted websockets,
08:52:12 <woodson> lseactuary, so the pass function is not working but the move and wait are fine?
08:52:17 <fr33domlover> I'd probably check if some yesod-websocket package exists :p
08:52:24 <lseactuary> woodon - yup
08:56:07 <lseactuary> woodson shall i explain my logic? i feel im almost there just some small thing is blocking me :/
08:56:07 <woodson> fr33domlover, ok I will have to checkout the servant-websocket then. Then again it will be like making my own server...
08:56:35 <woodson> lseactuary, yes please because I am not familiar with the syntax
08:57:25 <woodson> I am just trying to figure out where the recursion happens but these declaration pass.l?Floors:diff(below(newFloor,FLOOR),below(currentFloor,FLOOR))?up
08:57:30 <woodson> are confusing me
08:57:36 <lseactuary> ah
08:57:38 <lseactuary> PM or here?
08:57:41 <fr33domlover> woodson, are you trying to use ghcjs to make a file upload thing just on client side, browser JS?
08:58:09 <woodson> lseactuary, here is fine someone else might be able to help too
08:58:16 <lseactuary> oki
08:58:21 <lseactuary> i just refreshed the paste ill explain
08:58:35 <lseactuary> basically it works with the -- stuff removed
08:59:18 <lseactuary> so you start at floor 0. you select say floor 3. floor 3 is scheduled. that is what wait is doing. if you select floor 0 you stay at 0 i.e. move never happens
08:59:24 <woodson> fr33domlover, the thing is that I will just allow people to drop a file or zip file and then I will use my small library to do some parsing for them and allow them to download the newly formatted data
08:59:36 <lseactuary> move takes the parameters current floor and new floor
08:59:51 <lseactuary> lets focus on just new floor > current floor as the other case is just the reverse
08:59:59 <lseactuary> so you depart from the current floor
09:00:05 <woodson> fr33domlover: so, there wont really be any browser interaction except for uploading and downloading
09:00:07 <lseactuary> you arrive at the new floor
09:00:11 <lseactuary> and then wait at the new floor
09:00:15 <lseactuary> so that works nicely
09:00:28 <lseactuary> while you are traveling, you will pass other floors and not stop
09:00:33 <lseactuary> that is the piece im trying to model in
09:00:44 <lseactuary> if you were on floor 0 and went to floor 1 you dont "pass" any floor
09:01:03 <lseactuary> if you were on floor 0 and went to floor 3 you passed floor 1 and 2 (hence the recursion as its 2 pass events)
09:01:21 <lseactuary> woodson - make sense? any line of syntax i should explain?
09:01:55 <fr33domlover> woodson, ah I see? Well I guess a general idea would be: (1) figure out how in browser JS you cab grab the file, process it and signal thw browser to allow the user to store the result (2) figure out how to do that in Haskell with GHCJS
09:02:06 <woodson> lseactuary, ok so whats the current output that you are getting
09:02:07 <woodson> ?
09:02:14 <fr33domlover> woodson, idk either of these though :p
09:02:16 <lseactuary> the pass function doesnt work
09:02:23 <lseactuary> if i dash it out, the rest works
09:02:24 <fr33domlover> *see!
09:02:40 <lseactuary> i.e. i can go select -> schedule -> depart -> arrive -> etc.
09:02:48 <rodarmor> I'm writing a parsec parser, but I'm kind of at a loss on how to test it. I'd like to pass in a string and assert that it produces the expected output, and that some of the string is unparsed. Is there a good example of this somewhere I can check out?
09:03:34 <lseactuary> above(f,fs) is just the set of floors above a given floor
09:04:30 <lseactuary> above(0,{0,1,2,3}) = {1, 2, 3}
09:04:33 <lseactuary> above(3-1,{0,1,2,3})
09:04:38 <lseactuary> = {3}
09:04:41 <fr33domlover> rodarmor, (1) you may want to use megaparsec instead (2) you can use QuickCheck to write properties
09:04:46 <lseactuary> so diff({1,2,3},{3}) is {1, 2}
09:04:50 <lseactuary> i.e the floors the lift will pass
09:05:41 <woodson> lseactuary: ok so the purpose of the pass is just to keep track of what floor the user passed, so to consider a pass it would currentFloor + 2
09:05:43 <woodson> correct?
09:05:46 <lseactuary> right
09:06:19 <woodson> So, why do you need pass to be recursive?
09:06:38 <rodarmor> fr33domlover: Thanks! Is megaparsec better or more actively maintained?
09:06:43 <woodson> can move not do this
09:06:49 <APic> Good old functional Programming-Languages.
09:06:52 <woodson> and just have pass as a tracking function?
09:06:58 <lseactuary> because if you start on floor 0 and want to go to floor 3 it would be select->schedule->depart->pass->pass->arrive right?
09:06:59 <fr33domlover> rodarmor, afaik it's better in every way :p
09:07:33 <rodarmor> fr33domlover: Cool, I'll check it out
09:08:09 <woodson> Ah, I see. I was considering move as pass as well
09:08:14 <lseactuary> :)
09:08:19 <woodson> so select->schedule->depart->move->move->arrive
09:08:26 <woodson> and just track floors with pass
09:08:38 <lseactuary> move = depart + pass + arrive events
09:08:52 <woodson> hmm ok
09:09:07 <lseactuary> i mean i think im close
09:09:12 <woodson> move is just one execution A -> B
09:09:18 <lseactuary> but actually i dont think we need minFloor, maxfloor
09:09:22 <lseactuary> can just use Floors
09:09:32 <lseactuary> as there are cases remember where pass is not needed
09:09:36 <lseactuary> e.g. travel from floor 0 to 1
09:09:44 <lseactuary> you still depart/arrive but dont pas
09:09:49 <lseactuary> so better to have another function imo
09:09:55 <lseactuary> but im clueless how to "update" the value
09:10:03 <woodson> lseactuary, this is why I said that
09:10:05 <lseactuary> shall i show you what i did
09:10:27 <woodson> sure
09:10:57 <lseactuary> http://lpaste.net/8522320034255601664
09:11:00 <lseactuary> updated in attempt 2
09:12:09 <lseactuary> diff({1,2,3},{3}) = {1, 2}
09:12:16 <lseactuary> hence i take the head of the sequence i.e. the 1
09:12:22 <lseactuary> but then how to tell it to take 2?
09:13:10 <lseactuary> oh wait wont this work
09:13:23 <lseactuary> updated
09:13:47 <LysergicDreams> I'm trying to expect an exception thrown during CSV record generation in HSpec. But I can only catch it if I do `evaluate (Csv.runParser . Csv.parseRecord $ Csv.toRecord someValue)`. For some reason just doing "evaluate (Csv.toRecord someValue) `shouldThrow` ..." doesn't work. Anyone have an idea why?
09:14:41 <lseactuary> woodson - also im not sure how to tackle the cases of up/down in the Passing function :/
09:14:45 <lseactuary> if we seperate it
09:14:46 <woodson> lseactuary, 2 will always be the last value of the difference
09:14:53 <lseactuary> yeah
09:14:57 <lseactuary> i added this logic :)
09:14:59 <woodson> {1,2,3,4} = {1.2,3}
09:15:01 <woodson> 3
09:15:06 <lseactuary> yup
09:15:33 <lseactuary> added to the doc
09:17:27 <lseactuary> woodon but pass takes a direction hence not sure ive done this right
09:17:46 <woodson> why do you need the min floor and max floor?
09:17:58 <woodson> in Pass
09:18:15 <lseactuary> are you looking at attempt 2?
09:18:20 <lseactuary> (scroll down :))
09:18:44 <woodson> ahh
09:19:59 <woodson> what is card?
09:20:15 <lseactuary> size of a set e.g. card({1,2,3,6}) = 4
09:20:39 <woodson> hmm ok better now
09:21:31 <woodson> --     Passing(Floors) =
09:21:31 <woodson> --        if card(Floors) > 0
09:21:31 <woodson> --        then pass.l?newFloors:head(seq(Floors))?up
09:21:31 <woodson> --        else Passing(diff(Floors,newFloors))
09:21:45 <woodson> ok this is where the issue is right?
09:21:48 <lseactuary> yup
09:21:51 <woodson> ok
09:22:00 <lseactuary> lift.csp:90:50-63: Unexpected token else
09:22:02 <woodson> so you are passing a set of floors
09:22:16 <lseactuary> yu
09:22:18 <lseactuary> yup
09:22:20 <lseactuary> but
09:22:28 <lseactuary> head(seq(...))
09:22:31 <lseactuary> will take the first element
09:22:39 <lseactuary> e.g. lets saw currentFloor = 0, newFloor = 3
09:22:40 <lseactuary> then
09:22:49 <lseactuary> Passing(diff(above(currentFloor,FLOOR), above(newFloor-1,FLOOR)))
09:22:56 <lseactuary> is just Passing({1,2})
09:23:05 <lseactuary> so
09:23:09 * hackage stack-network 0.1.0.0 - A program for extending Stack to add distributed capabilities  http://hackage.haskell.org/package/stack-network-0.1.0.0 (mcgroas)
09:23:19 <lseactuary> head(seq({1,2)) = 1
09:23:55 <woodson> pass.l? <-- will execute pass again?
09:24:10 <woodson> because you need to go to two
09:24:14 <lseactuary> then Passing(diff({1,2},1)) = Passing({2}}
09:24:29 <lseactuary> card({2}) > 0 so yes it will go through again
09:24:33 <lseactuary> then it will be empty so stop
09:25:17 <woodson> else Passing(diff(Floors,newFloors))
09:25:21 <lseactuary> ye
09:25:23 <woodson> wouldnt it call this again
09:25:25 <lseactuary> ye
09:25:29 <woodson> since its emppty
09:25:47 <lseactuary> oh
09:26:36 <lseactuary> hmm what should happen once the set is empty
09:26:43 <lseactuary> arrive?
09:27:01 <woodson> 0 -> 3
09:27:02 <dented42> How can I tell package.yaml (or a cabal file) what module to use as the Main entry point?
09:27:12 <lseactuary> see my updated code :)
09:27:15 <woodson> 0 pass -> 1 pass -> 2 -> pass 3 -> arrive
09:27:33 <lseactuary> right but i cant write arrive in the Passing function
09:27:36 <woodson> you need something to check that you arrived in the pass
09:27:48 <dented42> going `main: Thing/Tests.hs` tells it what file to compile, but it seems to be complaining that the module is called `Thing.Tests` instead of `Main`.
09:28:01 <lseactuary> woodson - add the parameter newFloor?
09:28:08 <woodson> yes
09:28:23 <woodson> it should be your base case
09:28:26 <lseactuary> ok
09:28:27 <lseactuary> 2 min\
09:28:31 <woodson> to stop the recursion
09:28:46 <lseactuary> right
09:28:48 <lseactuary> smartie :)
09:29:08 <dented42> Must I rename my module or is there a way to get it to do the right™ thing?
09:29:12 <ggVGc> when was package.yaml introduced?
09:29:23 * paulvictorraj
09:29:27 <dyl> dented42 main-is?
09:29:29 <dented42> ggVGc: sometime in the past year or so.
09:29:35 <ggVGc> ah, that explains it
09:29:41 <ggVGc> thanks
09:29:46 <ggVGc> looks good
09:29:52 <glguy> ggVGc: package.yaml is part of hpack and is optional, you can delete it and keep the generated .cabal file
09:29:58 <ggVGc> yeah I know
09:30:07 <dyl> dented42 I'm pretty sure you want "Main-Is: ...", not "Main: ..."
09:30:08 <ggVGc> but I've been wanting something like packag.yaml before
09:30:10 <ggVGc> so I'm happy :)
09:30:19 <dented42> dyl: for package.yaml it's 'main'.
09:30:28 <dyl> Oh, no idea for package.yaml ¯\_(ツ)_/¯
09:30:55 <dented42> but for the cabal file, setting main-is still causes it to complain
09:31:20 <dented42> ah, unless I've done something extremely stupid
09:31:21 <dented42> hang on
09:31:53 <woodson> dented42: arent you supposed to tell it just the file name
09:32:06 <woodson> and specify the directory with source-dirs:
09:33:01 <dented42> woodson: yes, but the module itself is called NDP.Tests
09:33:40 <hobaloba> is there a haskell clock app i can look at?
09:33:47 <woodson> dented42: so, main: NDP.Tests
09:33:53 <woodson> and source-dir: whatever
09:34:08 <woodson> That didnt work?
09:35:12 <lseactuary> woodon - can you check my attempt2?
09:35:13 <dented42> yes but (given the source-dir of 'test-suite') the module NDP.Tests corresponds to the path test-suite/NDP/Tests.hs
09:35:29 <lseactuary> it still doesnt seem to like the Passing function
09:40:17 <woodson> lseactuary, whats the error? The logic looks much better now
09:40:24 <lseactuary> lift.csp:91:34-46: Unexpected token within
09:40:39 * hackage eq 4.2 - Leibnizian equality  http://hackage.haskell.org/package/eq-4.2 (ryanglscott)
09:41:30 <woodson> is that even an error in your recursion?
09:41:32 <lseactuary> its something wit hthis line: Passing1(newFloor, diff({passingFloors},Floors))
09:41:36 <woodson> that sounds like syntax error
09:41:48 <edwardk> someone in here the other day asked if i'd be willing to do live coding sessions. https://hangouts.google.com/call/7sCky7q742URlq1Oj1eJAAEE -- i want to play around with commutative monads and probability for a couple hours if anybody wants to join
09:42:38 <lseactuary> woodson - syntax looks okay :/
09:42:44 <Ariakenom> That was me I guess. Same day for me though :)
09:43:08 <edwardk> Ariakenom: =)
09:43:12 <woodson> ya, lift.csp:91:34-46: Unexpected token within <-- this must definitely be a parsing error
09:43:54 <lseactuary> woodon its this line
09:43:55 <lseactuary>  else arrive.l!newFloor!up
09:44:08 <lseactuary> i wonder if arrive is correct
09:44:50 <lseactuary> oh i think i know
09:45:19 <lseactuary> woodson - so i will need 2 passing functions right?
09:45:21 <lseactuary> like i ddi?
09:48:56 <woodson> lseactuary, I dont know the syntax so I am not too sure about that
09:48:57 <woodson> but
09:49:03 <lseactuary> oki
09:49:06 <woodson> since your recursion base case
09:49:17 <woodson> is checking whether you arrived or not
09:49:26 <lseactuary> ah i removed it
09:49:29 <lseactuary> that was the error
09:49:29 <woodson> I dont think that you will need the arrive function
09:49:40 <lseactuary> now im figuring out data type errors
09:50:02 <woodson> lseactuary, lol then you will have to figure that out
09:50:07 <lseactuary> :)
09:50:08 <woodson> def cant help with that
09:50:17 <lseactuary> yup thats cool i can do syntax stuff
09:50:20 <lseactuary> can i ask for one more help
09:50:29 <lseactuary> like you helped me then i can write the function
09:50:33 <lseactuary> it should be shorter/simpler
09:51:22 <woodson> sorry, I didnt get that? You want help making the function shorter/simpler?
09:51:28 <lseactuary> not this one :)
09:51:38 <lseactuary> i am trying to model something else on the lifts am stuck
09:51:42 <lseactuary> if we can do what we just did
09:51:44 <lseactuary> i can figure out syntax
09:51:49 <lseactuary> but not sure im even modeling it right
09:51:56 <lseactuary> if you can help with the logic i can figure out how to write it
09:52:15 <lseactuary> btw updated the code
09:52:21 <lseactuary> so you can see i removed arrive
09:52:31 <lseactuary> data type errors now though but ill debug
09:52:43 <woodson> I'm about to make breakfast now, I you can just post and see if anyone else can help and when I'm I can maybe help
09:52:47 <woodson> or just ping me later
09:53:26 <woodson> are you on slack?
09:53:36 <lseactuary> not on slack :/
09:53:43 <lseactuary> but ill be around for a few more hours
09:54:01 <woodson> I'm also on the haskell slack
09:54:05 <lseactuary> ah
09:54:07 <woodson> you can leave messages there
09:54:10 <lseactuary> ah
09:54:14 <lseactuary> i will try to get
09:54:17 <woodson> and I can read them later
09:54:25 <lseactuary> oki otherwise ill be here just incase that doesnt work
09:54:43 <woodson> ok, just ping me later in a couple hours
09:54:52 <woodson> good luck!
09:54:59 <lseactuary> oki :)
09:55:00 <lseactuary> thanks!
09:55:10 * hackage pretty-relative-time 0.0.0.0 - Pretty relative time  http://hackage.haskell.org/package/pretty-relative-time-0.0.0.0 (Norfair)
10:02:48 <hobaloba> can you... inline?.. a type annotation?
10:04:24 <lyxia> (x :: Type Of X)  ?
10:06:09 * hackage tagged-transformer 0.8.1 - Monad transformer carrying an extra phantom type tag  http://hackage.haskell.org/package/tagged-transformer-0.8.1 (ryanglscott)
10:08:21 <Psybur> What do you call something that allows something else to run until it decides to not let that something run anymore? :D
10:09:11 <Psybur> whileM scheduler $ do
10:09:11 <Psybur> ?
10:11:34 <Saturated_fart> quit
10:31:41 <cocreature> Psybur: I’d try to find a name that conveys _what_ it checks to decide if the loop should continue
10:32:15 <cocreature> Psybur: "whileM scheduler" doesn’t tell me anything about what "scheduler" is supposed to do
10:32:20 <Psybur> @hoogle (Monad m) => [m] -> m
10:32:21 <lambdabot> Data.Edison.Seq.ListSeq lheadM :: (Monad rm) => [a] -> rm a
10:32:21 <lambdabot> Data.Edison.Seq.ListSeq rheadM :: (Monad rm) => [a] -> rm a
10:32:21 <lambdabot> Control.Monad.HT repeat :: (Monad m) => m a -> m [a]
10:32:34 <cocreature> that’s a kind error
10:32:47 <Psybur> @hoogle (Monad m) => [m a] -> m a
10:32:48 <lambdabot> Control.Monad.HT repeat :: (Monad m) => m a -> m [a]
10:32:48 <lambdabot> Control.Monad.Tools repeatM :: Monad m => m a -> m [a]
10:32:48 <lambdabot> Data.Edison.Seq.ListSeq ltailM :: (Monad rm) => [a] -> rm [a]
10:33:20 <cocreature> Psybur: what should that return if I apply it to an empty list?
10:33:46 <Psybur> @hoogle (Monad m) => [m a] -> Maybe (m a)
10:33:47 <lambdabot> Control.Monad.Loops unfoldM :: Monad m => m (Maybe a) -> m [a]
10:33:47 <lambdabot> Agda.Utils.Maybe allJustM :: Monad m => [m (Maybe a)] -> m (Maybe [a])
10:33:47 <lambdabot> Data.Edison.Seq.ListSeq lview :: (Monad rm) => [a] -> rm (a, [a])
10:34:26 <cocreature> Psybur: now the type makes sense but what do you want it to do? :)
10:35:14 <cocreature> :t listToMaybe -- ^ that has the right type but I suspect you’re looking for something else
10:35:15 <lambdabot> [a] -> Maybe a
10:35:51 <Psybur> Im in a do block creating some free monadic value. In the do block I have an operation that returns a list of operations in my dsl. Im wondering if I can just chain them with >> ?
10:36:09 <ph88> does anyone know why lts 8 and 10 were created? they don't have an unique ghc version
10:36:10 <Psybur> foldr (>>) mempty doesnt seem right :D
10:36:14 <cocreature> :t sequence_
10:36:15 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
10:36:20 <cocreature> maybe you’re looking for that?
10:36:52 <cocreature> ph88: because a sufficiently large amount of time had passed since the last lts :)
10:38:28 <ph88> ah ok
10:41:08 <cocreature> ph88: iirc the goal is a new lts every 3 months
10:42:35 <Psybur> cocreature, so going back to whileM, something along the lines of trade shouldTrade = whileM shouldTrade $ do ... ?
10:42:49 <cocreature> yeah
10:43:22 <lseactuary> anyone know how to get {{Int}} -> {Int}
10:43:43 <cocreature> lseactuary: what is {{Int}} supposed to be?
10:43:49 <Psybur> > mconcat [[1,2],[3,4]]
10:43:51 <lambdabot>  [1,2,3,4]
10:44:03 <Psybur> > join [[1,2],[3,4]]
10:44:05 <lambdabot>  [1,2,3,4]
10:44:36 <lseactuary> cocreature: you see the error here? http://lpaste.net/8522320034255601664
10:44:48 <lseactuary> i dont get why Floors :: {{Int}}
10:44:53 <lseactuary> that is not how i modelled it...
10:45:15 <cocreature> you seem to have a hard time accepting that this is a channel for Haskell questions
10:46:19 <lseactuary> just trying to understand the data types
10:46:27 <lseactuary> you can tell me generally then i can implement in my language
10:47:14 <Wolf480pl> Hello. Is there a reason why there's no instance (Monad m, MonadState s m) => MonadReader s m ?
10:47:24 <sjjssjjeejej> But at the end of the day language doesn't matter much, unless its specified for a particular job.. do you people agree?
10:48:37 <cocreature> Wolf480pl: that would make it impossible to have both Reader and State in your transformer stack and have the instances work out properly
10:48:45 <shapr> sjjssjjeejej: it depends on what you're doing
10:49:10 <Wolf480pl> cocreature, even if that instance was in a different module that one would only import when necessary?
10:49:29 <shapr> sjjssjjeejej: I could accomplish business goals in much less time using Haskell, but no one else here would be able to maintain the code I create.
10:49:38 <Wolf480pl> IMO being able to use local in MonadState would be handy
10:49:53 <cocreature> Wolf480pl: that would be an orphan instance which are generally frowned upon
10:50:05 <shapr> sjjssjjeejej: I see commercial programming as a community-centric task, and the entire organization needs to be change-friendly.
10:50:08 <Wolf480pl> what is an orhpan instance?
10:50:16 <shapr> sjjssjjeejej: what do you think about that?
10:51:03 <cocreature> Wolf480pl: an instance that is not declared in the same module as the class or the type
10:51:30 <cocreature> Wolf480pl: instances should best be thought of as global things that will leak everywhere
10:52:48 <cocreature> Wolf480pl: that said I agree that a version of "local" for MonadState would be nice but that could just be added as a separate method which would avoid the problems
10:53:24 <monochrom> sjjssjjeejej: The language matters whether or not I reach the end of the day at all.
10:53:33 <sjjssjjeejej> But people do have other options, to go with traditional and easier approach which might consume loads of time.
10:54:14 <Wolf480pl> cocreature, is there a reason why instances don't have names that would let us explicitely include or exclude them from imports?
10:55:36 <ph88> i have  import Text.Megaparsec.Text (Parser)   how can i re-export the type Parser ?
10:55:48 <shapr> sjjssjjeejej: time to market can make a big difference in income
10:55:52 <aarvar> Wolf480pl: yes. That would break coherence
10:56:06 <Wolf480pl> what's coherence?
10:56:11 <aarvar> Wolf480pl: there can be multiple ways to derive the same instance, and coherence ensures that all of those produce the same result
10:56:17 <shapr> sjjssjjeejej: have you read the series "Worse is Better" by Richard Gabriel?
10:56:32 <monochrom> A long time ago the purpose of classes and instances did not require naming or even having a choice at all.  For example you expect at most one way == is done to a type like Int.
10:57:08 <Wolf480pl> really? that's a weird assumption IMO
10:57:10 * hackage bv-little 0.1.1 - Efficient little-endian bit vector library  http://hackage.haskell.org/package/bv-little-0.1.1 (recursion_ninja)
10:57:14 <aarvar> Wolf480pl: e.g. if you want to derive Eq [String], you could either 1. use the Eq a => Eq [a] instance or 2. first use the Ord a => Ord [a] instance to derive Ord [String], then derive Eq [String] via the superclass relation
10:57:38 <monochrom> When you do a test like "if x==5 then ..." no one wants to be explicit about "is that using monochrom's equality algorithm or is that using cocreature's version?"
10:57:56 <cocreature> clearly my version is superior
10:58:16 <Wolf480pl> when using foldl, noone wants to be explicit about whether to use version from Data.Functor or Data.Map
10:58:31 <ystael> monochrom: obviously you should give an explicit homotopy between monochrom's equality path and cocreature's :p
10:58:41 <monochrom> FWIW you and I are speaking English and we didn't even begin with a negotiation protocol of whether it's Queen's English or Trump's English.
10:58:49 <aarvar> Wolf480pl: huh?
10:58:56 <monochrom> If you say that this is weird then sure.
10:59:11 <Wolf480pl> uh, Data.Foldable I mean
10:59:29 <Psybur> monochrom has the best words, believe me.
10:59:41 <sjjssjjeejej> No shapr, tell Me about it
10:59:49 <Wolf480pl> anyway, my point is, there are many definitions of foldl, and sometimes ghci is upset because it doesn't know which one I want to use
11:00:04 <Wolf480pl> I don't want to tell it explicitely which one I want, yet sometimes I have to
11:00:10 <Wolf480pl> it could be the same with ==
11:00:12 <cocreature> Wolf480pl: you can imagine other systems where you don’t have typeclass coherence and can name instances and pass them explicitely, e.g., scala’s implicits. it’s really more of a design decision that Haskell has made
11:00:28 <shapr> sjjssjjeejej: check it out here: https://www.dreamsongs.com/WorseIsBetter.html
11:01:04 <shapr> sjjssjjeejej: I think it does a good job of bringing up specific instances related to "the language doesn't matter much"
11:01:30 <lseactuary> anyone know how to flatten {{a}} -> {a}
11:01:40 <lseactuary> {A} being a set of A
11:02:45 <aarvar> Does anyone know how to make cookies?
11:04:04 <cocreature> lseactuary: can you please accept that this channel has a topic and your questions don’t relate to it? asking an offtopic question once is fine but you’re pretty much only asking offtopic questions
11:04:23 <lseactuary> but data types is not off topic right?
11:04:24 <Psybur> :t mconcat
11:04:25 <lambdabot> Monoid a => [a] -> a
11:04:31 <Psybur> :t join
11:04:32 <lambdabot> Monad m => m (m a) -> m a
11:04:38 <cocreature> {A} is not a Haskell type so your question is not related to Haskell
11:05:10 <lseactuary> k
11:05:35 <cocreature> besides Psybur has given you the Haskell answer multiple times by now :)
11:07:09 <sjjssjjeejej> Okay, let's take an example. You can create a simple web application using abcde, a number of languages but when you want an application to do a specific task say, learn from its previous operations and manipulate data sets by itself, would you choose a language or go with the easily available, less hectic and Understandable by others?
11:07:17 <monochrom> But of course since the Haskell answer does not solve the non-Haskell question, the answer is ignored.
11:08:58 <aarvar> sjjssjjeejej: the language obviously matters if one language lets you write a fraction of the code in a fraction of the time with a fraction of the bugs
11:09:15 <shapr> sjjssjjeejej: Is abcde one of the common lisp web frameworks?
11:09:27 <glittershark> "understandable by others" isn't an objective measure
11:09:39 <glittershark> nobody is born understanding Java
11:09:55 <glittershark> familiarity is relative
11:09:59 <aarvar> glittershark: haven't you heard? "OOP" is objectively more intuitive for humans
11:10:06 <glittershark> haha
11:10:06 <shapr> oy
11:10:11 <aarvar> said one of my cs teachers, more or less
11:10:16 <tdammers> well, it's true
11:10:17 <glittershark> :(
11:10:33 <tdammers> at least for the trivial example programs where objects actually happen to resemble the things you're modeling
11:10:38 <aarvar> I still don't know what OOP is, but that makes me a crazy person
11:10:54 <cocreature> we all model animals in our programs, right?
11:11:02 <cocreature> and cars, don’t forget cars
11:11:09 <aarvar> and shapes
11:11:13 <tdammers> yes, animals, shapes, cars, and organization charts
11:11:19 <shapr> sjjssjjeejej: When I was self-employed, most of my clients wanted a particular task to be done by the computer, my Haskell code solutions usually took much less time to create than clients' on-staff Java programmers, so it was cheaper for them to pay me to complete the tasks.
11:11:20 <aarvar> and people
11:11:27 <tdammers> although shapes are somewhat frowned upon
11:11:35 <aarvar> class Corporation extends Person
11:11:39 <tdammers> aarvar: no, not people. human resources at best.
11:11:58 <aarvar> tdammers: I didn't mean to imply that employees are people
11:12:05 <glittershark> lol
11:12:06 <tdammers> aarvar: ah, OK, fair enough then
11:12:40 <shapr> sjjssjjeejej: I don't know if all programming languages can be equally productive given the right coder, but *I* can be extremely productive in Haskell.
11:12:52 <Psybur> aarvar, you mean people dont think that what we are is the result of function composition every time quantum? They dont think that the person they were a second a go is not the same person they are now? :{
11:13:23 <ph88> how can i make code conditional on the GHC version or even stack LTS version? do i need CPP ?
11:13:32 <glittershark> ph88: yep
11:13:33 <Psybur> My name is John! My name is Sue! Am I lying?
11:13:35 <shapr> I once had to convert thousands of ms.doc files to a particular custom xml flavor, the client's staff coder gave up after a coupla months. I did it in a weekend.
11:13:46 <aarvar> Psybur: physicists seem to think everything is a function of time, but they're just ivory tower academics
11:13:55 <cocreature> ph88: cpp or conditionals in your cabal file to decide which module you use
11:14:15 <glittershark> I definitely model the world as an FRP chain in my mind, idk about you guys
11:14:21 <glittershark> you never cross the same river twice blah blah blah
11:14:30 <shapr> sjjssjjeejej: ok, I've decided on an answer. The language used is *extremely* important, because you will discover one that's powerful for *you*, and that won't be the same language for everyone.
11:14:50 <glittershark> I do recognize the danger of referencing Rich Hickey in #haskell, though >.>
11:15:14 * glittershark just wants to watch the world burn
11:15:31 <aarvar> shapr: let's not fall into the trap of thinking that some people are somehow inherently more suited to using certain languages
11:15:50 <shapr> aarvar: what do you think is closer to reality?
11:16:09 <aarvar> people are more productive with languages they're more familiar with
11:16:25 <aarvar> but given equal familiarity, some languages are always going to be more productive
11:16:30 <glittershark> yeah people tend to think they're incapable of learning a new programming language once they've learned the first
11:17:03 <shapr> Hm, I was far more productive with Python than Java, even in the first week of use.
11:17:07 <glittershark> also "productive" is more than just "easy to implement features" it's also "easy to change your mind"
11:17:16 <shapr> Took me a bit longer to be productive with Haskell, but it's a larger jump in productivity.
11:17:31 <aarvar> it's worth noting that most people who prefer java aren't familiar with haskell, while most people who favor haskell are familiar with alternatives
11:17:44 <shapr> Yeah, speed of change of the codebase is my priority, that way I can explore different solutions.
11:18:00 <aarvar> shapr: I also had a cs teacher who claimed that the average programmer is too dumb for FP
11:18:01 <glittershark> I'd love to have a conversation with someone who knows haskell well and chooses to use something else
11:18:29 <shapr> aarvar: I disagree with that teacher.
11:18:39 <aarvar> then again, he also thought FP meant using unicode
11:18:40 <glittershark> ie something in a different paradigm, not like ocaml or something
11:18:45 <glittershark> lol
11:18:50 <aarvar> and that the most important thing in programming is choosing good variable names
11:19:00 <glittershark> nooooo
11:19:34 <aarvar> his favorite lecture was to rant about how "cout" should be named "characterOut"
11:19:59 <shapr> I had those instructors when I went back to finish my bachelor's degree. When I left they started teaching Haskell.
11:20:09 <aarvar> ouch
11:20:26 <glittershark> where is haskell being taught these days?
11:20:54 <shapr> aarvar: I convinced them to improve the quality of their instructors.
11:20:54 <glittershark> I tend to think of academic compsci education as being heavily OO/imperative
11:21:07 <aarvar> shapr: can I ask why you went back? I don't want to finish my degree
11:21:30 <shapr> aarvar: I knew I was missing math, I got more of that. I was also curious if I was missing anything else in the coding theory world.
11:21:43 <shapr> I
11:21:44 <aarvar> lol
11:21:52 <aarvar> like what an "object" is?
11:21:55 <shapr> I learned a few things in the CS world, but mostly I picked up all the math I could extract from the instructors.
11:22:09 <aarvar> I still haven't learned what OOP is
11:22:11 <shapr> Nah, I understand OOP
11:22:27 <aarvar> something something behavior and data something
11:22:55 <shapr> OOP has good uses, but combining those good uses can easily go badly.
11:23:05 <aarvar> I don't believe you
11:23:09 <shapr> ok
11:23:20 <aarvar> I'm not convinced OOP exists
11:23:27 <aarvar> in which case it can't have good uses
11:23:29 <glittershark> @hoogle (a -> b -> c) -> (a -> c -> d) -> a -> b -> d
11:23:29 <lambdabot> Numeric.MixedTypes.Literals convertFirstUsing :: (a -> b -> b) -> (b -> b -> c) -> (a -> b -> c)
11:23:29 <lambdabot> Numeric.MixedTypes.Literals convertSecondUsing :: (a -> b -> a) -> (a -> a -> c) -> (a -> b -> c)
11:23:29 <lambdabot> Data.Function.Pointless (~>) :: (a -> b) -> (c -> d) -> ((b -> c) -> (a -> d))
11:23:41 <glittershark> hmm
11:23:43 <shapr> aarvar: have you read Luca Cardelli's theory of objects?
11:23:50 <aarvar> no
11:23:59 <glittershark> is this isomorphic to (=>=) for Store?
11:24:21 <aarvar> what is (=>=)?
11:24:23 <glittershark> :t (=>)
11:24:24 <lambdabot> error: parse error on input ‘=>’
11:24:25 <glittershark> oops
11:24:31 <glittershark> :t (=>=)
11:24:32 <lambdabot> error:
11:24:32 <lambdabot>     • Variable not in scope: =>=
11:24:32 <lambdabot>     • Perhaps you meant one of these:
11:24:48 <aarvar> cokleisli composition or something?
11:24:54 <glittershark> it's the version of >=> for comonads
11:24:54 <glittershark> yeah
11:25:05 <aarvar> ah I get it, switch the > and =
11:25:09 <glittershark> yep
11:25:13 <shapr> aarvar: Try reading luca cardelli's writings on objects. You'll understand objects, and be able to point out cases where they're being misused in production code.
11:25:17 <aarvar> stupid operators
11:25:19 <glittershark> I pronouce it "co-fish" out loud
11:25:20 <aarvar> haskell is so unreadable!
11:25:26 <aarvar> too much unicode
11:25:35 <glittershark> which confuses my coworkers bc it sounds like "go-fish"
11:25:43 <aarvar> shapr: I'm skeptical, but ok
11:26:04 <shapr> aarvar: if you read those and are still convinced objects don't exist, I would very much like to hear why :-)
11:26:15 <aarvar> shapr: also, is haskell object oriented?
11:26:32 <shapr> aarvar: I wouldn't call it that
11:26:35 <glittershark> StateT is object oriented :)
11:26:43 <aarvar> ew, it's a whole book?
11:26:47 <aarvar> I was expecting a paper
11:27:03 * shapr shrugs
11:27:05 <shapr> learning is hard
11:27:11 <glittershark> anyway does anyone know if there's a newtype that lets me compose a comonad on top of a functor?
11:27:19 <aarvar> especially for people as dumb as programmers
11:27:43 <glittershark> I'm looking for instance Functor f, Comonad w => Comonad (Compose w f) but don't know if that's just not possible
11:27:53 <shapr> aarvar: be nice
11:28:02 <shapr> ad hominem attacks aren't helpful
11:28:05 <aarvar> shapr: sorry, I learned that in school
11:28:38 <aarvar> shapr: and was parodying it
11:28:45 <monochrom> I agree with reading Cardelli too.
11:29:07 <monochrom> After reading it, you will understand why OOP requires more math and more PhD than FP.
11:29:56 <monochrom> Our "newtype Fix f = Fix (f (Fix f))" is laughably trivial compared to the fixed points required by OOP.
11:30:07 <aarvar> glittershark: monads don't compose, but you want a comonad to compose with a functor to get a comonad?
11:30:09 <Psybur> http://lucacardelli.name/TheoryOfObjects.html ?
11:30:20 <monochrom> Yeah!
11:30:22 <glittershark> aarvar: I thought about it harder and realized it was impossible
11:30:38 <glittershark> you can't get extract if your data type is in a functor
11:30:54 <monochrom> I need to bookmark it and refer my students to it.
11:31:10 <glittershark> and then thought about it even harder-er and realized I don't even want a functor anyway, so it's fine
11:31:19 <monochrom> They're thinking FP is hard.  I'll have to show them how much more mathematical OOP is!
11:31:23 <Psybur> wait wut, the link to the ebook is a link to the file system
11:31:59 <monochrom> Oh haha
11:32:18 <monochrom> I guess that's what "private" means.
11:32:19 <ph88> hey guys, did i do something wrong with this CPP statement?  https://bpaste.net/show/50e51b2dcf18  i'm on LTS 11.6  and  ghc gives me a warning about that import ..
11:32:43 <monochrom> "I keep forgetting where my file is.  Let me put the local-disk URL on my web page."
11:32:59 <Psybur> $80 hardcover damn
11:33:18 <Psybur> no paperback :{
11:33:18 <Newbieman> Can somebody help me with this assignment i have? I don't really know how to continue http://lpaste.net/3991149972429996032   I have to define a function, but am not allowed to use zipwith or fold or anything besides basic operators
11:33:50 <Psybur> Newbieman, just copy the source of zipwith and fold and name them something else :D?
11:34:19 <monochrom> I have found paperback on amazon.ca but it's cdn$246
11:34:31 <monochrom> Then again Kindle edition is also that price.
11:34:34 <Newbieman> Psybur no looking up allowed, and is it even possible to define a function inside a function?
11:34:54 <aarvar> Newbieman: of course it is
11:35:12 <Psybur> > let x = 1 in dude x where dude = id
11:35:14 <lambdabot>  <hint>:1:21: error: parse error on input ‘where’
11:35:16 <aarvar> functions are just values
11:35:59 <Psybur> > let x = 1; dude = id in dude x
11:36:01 <lambdabot>  1
11:37:19 <monochrom> Yeah stupid languages like C brainwashed people to never think of nested function definitions.
11:37:26 <Newbieman> ah I understand
11:37:31 <Newbieman> so if I write let
11:37:32 <monochrom> (Are ad langua attacks OK?)
11:38:00 <Newbieman> let e [code] /break d [code] /break in thats 2 functions right? I hope that makes sense
11:38:30 <monochrom> Well your e and d are lists.
11:38:43 <monochrom> and your r a number
11:38:51 <aarvar> shapr: if you buy me the book I'll read it :)
11:39:27 <ph88> how can i see which ghc is used in my stack project ?
11:39:28 <Newbieman> monochrom you mean in the code I posted?
11:39:43 <monochrom> Yeah
11:39:59 <shapr> aarvar: inter library loan?
11:40:21 <shapr> That's how I did "try before buy" for some of my more expensive books.
11:40:37 <monochrom> I don't actually want to figure out what erfolg is supposed to do.
11:40:45 <aarvar> hm, maybe
11:40:59 <monochrom> Ah but this one is "try and then too broke to buy" :)
11:41:31 <shapr> I coughed up the money for Hamming's style book and Coxeter's introduction to geometry after reading a copy at the library.
11:41:50 <Newbieman> monochrom its for an assignment, so maybe I should rephrase my question how can I make r just be the number that is the sum of the list e, if that makes sense.
11:42:02 <monochrom> r = sum e ?
11:42:11 <Newbieman> not allowed to use sum
11:42:30 <Newbieman> have to use list comprehension or recursion
11:42:53 <monochrom> Then I would want to read the original homework question verbatim unabridge no-middle-man.
11:43:00 <Newbieman> It's in german
11:43:15 <monochrom> Because students always convert every homework question into XYZ problems.
11:43:31 <shapr> ich habe keine ahnung!
11:43:33 <monochrom> I may even bet $1 that summing is unnecesssary.
11:43:37 <shapr> ik begrijp het niet!
11:45:09 <ph88> is this condition ok   #if __GLASGOW_HASKELL__ >= 822   to check if i use the ghc version of  https://www.stackage.org/lts-11.6  ??
11:45:11 <aarvar> Newbieman: implement sum yourself then
11:45:19 <aarvar> or foldl'
11:53:01 <Newbieman> I guess I can try without summing
11:53:15 <ph88> do i have to do something special with stack flags to turn on CPP or something ?
11:53:16 <dyl> Newbieman I would just implement a fold function.
11:53:25 <dyl> Any recursive solution you come up with will end up being a fold specialized over (+).
12:02:00 <monochrom> You can always show people the original homework question so they can suggest a better strategy.
12:02:21 <dyl> Hm: I'm noticing that the https://hackage.haskell.org/packages/browse page takes quite a bit longer to load than it perhaps ought to.
12:02:36 <dyl> It takes long enough I wonder if it's doing some kind of full recomputation.
12:03:03 <dyl> NEEDS MORE CACHING.
12:04:42 <hc> use a caching wai middleware?
12:05:24 <dyl> Also, I have a sort of general non-specific question. For a given ADT, is it possible to derive a type with an Enum instance that consists of only the "constructor tags"?
12:05:27 <AndreasPK> I think it sends all entries when you load the site
12:05:39 <dyl> e.g. data Foo = A Int | B Char ⇒ data FooTags = A' | B'
12:05:41 <dyl> In some sense.
12:05:53 <dyl> And how would one be able to use such a thing in a fruitful manner?
12:08:21 <cocreature> ph88: {-# LANGUAGE CPP #-}
12:08:39 <ph88> cocreature, i got that in the files that use macros
12:10:45 <AndreasPK> dyl: What's the use case there compared to matching on (A {})?
12:11:52 <dyl> AndreasPK none really just curiosity
12:11:55 <dyl> A more serious question:
12:12:05 <dyl> Is it possible to use typeclasses as kinds in the context of associated types?
12:12:21 <dyl> e.g. if I want to have class Foo a where { data Bar a :: Ord }
12:13:00 <dyl> I know Ord :: * -> Constraint
12:13:04 <dyl> :/
12:18:45 <marmistrz> Does Haskell have any counterpart of Rust's `if let`?
12:18:45 <marmistrz> https://doc.rust-lang.org/book/first-edition/if-let.html
12:19:08 <marmistrz> I want to check if x :: Either Error () is an error, if it is, print some error message, otherwise do nothing
12:20:09 <Psybur> :t either
12:20:10 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:21:46 <Psybur> > either putStrLn (return ()) (Left "fugg")
12:21:48 <lambdabot>  error:
12:21:48 <lambdabot>      • Couldn't match type ‘()’ with ‘IO ()’
12:21:48 <lambdabot>        Expected type: b0 -> IO ()
12:22:34 <orzo> is there a way to query using Generic/Typeable whether a type has an instance of some class?
12:22:37 <Psybur> > either putStrLn (const (return ())) (Left "fugg")
12:22:39 <lambdabot>  <IO ()>
12:22:48 <Psybur> % either putStrLn (const (return ())) (Left "fugg")
12:22:48 <yahb> Psybur: fugg
12:23:04 <Psybur> % either putStrLn (const (return ())) (Right ())
12:23:04 <yahb> Psybur:
12:23:29 <Psybur> marmistrz, does that help?
12:23:44 <marmistrz> yeah, but it seems even more verbose than the pattern match ;)
12:24:13 <Psybur> Well then whats wrong with pattern matching? :D
12:24:17 <AndreasPK> marmistrz: Are you interested in the value or just if theres an error? For the later there is fromLeft too
12:24:38 <orzo> hm, would what i'm asking for imply the principle of excluded middle in haskell's logic system?
12:24:39 <marmistrz> AndreasPK, Right () means that there was no error, so I want to ignore it
12:24:50 <marmistrz> If I have Left err, I basically want to print err
12:25:29 <AndreasPK> Pattern match might be less noise in that case
12:25:40 <marmistrz> Psybur, simply Rust's if let Left(x) = val { foo(x) } is beautifully concise in this case
12:26:14 <marmistrz> basically, a wrapper for either would be some way out but for one occurrence, there's no use
12:28:09 <AndreasPK> marmistrz: What does that do for right values? Nothing?
12:28:36 <marmistrz> AndreasPK, nothing
12:28:44 <glm> Is there a good way to count the elements in a conduit stream?
12:28:46 <Psybur> marmistrz, Rust is imperative right
12:30:18 <marmistrz> It looks like Control.Arrow.left does what I need
12:30:58 <Younder> games in Haskel. Cool
12:31:02 <AndreasPK> orzo: I think you might want to check https://hackage.haskell.org/package/ifcxt out, it's afaik as close as you can get without compiler plugins
12:31:04 <edwardk> hrmm, we probably should add And/Or/Xor monoids to Data.Bits or Data.Monoid
12:31:41 <Psybur> marmistrz, anyway you could write out the arrow version for me? :D
12:31:50 <orzo> thanks AndreasPK
12:32:11 <marmistrz> left (error "test") (Left "aa")
12:32:17 <marmistrz> left (error "test") (Right "bb")
12:32:41 <orzo> AndreasPK: that would suite my purposes just fine
12:32:49 <Psybur> > Control.Arrow.left (error "test") (Left "aa")
12:32:51 <lambdabot>  Left *Exception: test
12:33:04 <Psybur> :t error "test"
12:33:05 <lambdabot> a
12:33:16 <Psybur> :t Control.Arrow.Left
12:33:17 <lambdabot> error:
12:33:17 <lambdabot>     Not in scope: data constructor ‘Control.Arrow.Left’
12:33:17 <lambdabot>     Perhaps you meant one of these:
12:33:21 <Psybur> :t Control.Arrow.left
12:33:22 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
12:34:06 <marmistrz> I actually need (b -> IO c) -> (Either b d) -> IO (Either c d)
12:34:09 <Welkin> Younder: what games?
12:34:52 <Younder> I am more of a heterogeneous programmer myself. I would do the keyboard control in C.
12:35:29 <Younder> If I needed to respond to key-codes.
12:35:40 <Welkin> Younder: use the SDL bindings
12:35:45 <Welkin> it's like writing C in haskell
12:35:51 <Welkin> well, the low-level bindings
12:36:02 <Welkin> I do not like the high-level wrapper with a made-up API
12:36:13 <Welkin> SDL.Raw
12:36:55 <shapr> edwardk: twitch.tv?
12:37:00 <dyl> Well, this is annoying.
12:37:03 <maerwald> Younder: if you want a lot of pain
12:37:10 <dyl> I have a class with two functions: power :: a -> a -> Int and reduce :: a -> a -> Maybe a
12:37:28 <dyl> Whenever power a b == 0, reduce a b == Just _
12:37:33 <edwardk> shapr: might be the next step. so far i'm just doing hangouts and the like
12:37:36 <dyl> but there's no nice way to express that in the type.
12:37:47 <shapr> edwardk: I'd like to try that too, if you find a good setup, I want to know
12:37:47 <edwardk> less worry about preserving everything for posterity
12:37:49 <dyl> And bundling them together would be a little weird semantically.
12:38:15 <Welkin> hangouts for what?
12:38:23 <Welkin> live-coding haskell libraries?
12:38:55 <edwardk> we did spend ~3 hours working a couple hundred examples of commutative semigroups/applicatives in haskell and how to make a nice free monad given a commutative applicative
12:39:05 <edwardk> welkin: yeah
12:39:27 <edwardk> welkin: its been an active experiment of mine
12:39:39 <ph88> does anyone know why i get this import error? https://bpaste.net/show/ee2760afa2ec i'm on lts-11.6 with should be with ghc 8.2.2
12:40:16 <Welkin> ph88: dump stack and use cabal
12:40:24 <Welkin> and install your own ghc versions
12:40:26 <Welkin> it is much easier
12:40:32 <ph88> i only know stack
12:40:34 <cocreature> ph88: what makes you think that module exists?
12:40:35 <Welkin> remove needless abstraction and problems from your life
12:40:43 <cocreature> ph88: https://hackage.haskell.org/package/megaparsec doesn’t list it
12:40:57 <shapr> Welkin: stack is easier for beginners, it installs ghc for you
12:41:04 <edwardk> when i can think again i'll probably want to work up a detailed gibbs/hmc sampling monad using this stuff and get applicative do and the commutativity trick to make it fast
12:41:04 <ph88> cocreature, i don't think it exist, why does ghc try to compile it ?
12:41:25 <Welkin> stack is easy in the way that rails is easy. It is easy to get setup and started, then once you want to do anything non-trivial you are screwed
12:41:41 <Welkin> installing ghc is super easy
12:41:42 <AndreasPK> marmistrz: There is bitraverse: bitraverse print (\_ -> return ()) (Left "foo")
12:41:46 <Welkin> install haskell platform with one click
12:41:47 <Welkin> done
12:41:50 <Welkin> it takes a second
12:41:54 <edwardk> stack works pretty well right up until you need backpack :(
12:42:14 <Welkin> also, stack has been breaking pretty badly for a lot of users recently
12:42:23 <Welkin> as evidenced by all of the calls for help in this channel
12:42:28 <edwardk> i still use stack for a fair bit of my window dev needs
12:42:41 <Welkin> I used to use stack for everything
12:42:46 <Welkin> I switched to cabal new-*
12:42:50 <AndreasPK> marmistrz: But if that's really better than a pattern match is another question!
12:42:52 <Welkin> and nix for a few things
12:43:11 <cocreature> ph88: what’s the output of "stack ghc -- --version" (run from the within your project)?
12:43:31 <ph88> The Glorious Glasgow Haskell Compilation System, version 8.2.2
12:43:37 <shapr> Welkin: are you using cabal 2.2?
12:44:21 <Welkin> shapr: yes
12:45:23 <cocreature> ph88: take a look at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html?highlight=__glasgow_haskell__#standard-cpp-macros I think you got your version numbers wrong
12:45:32 <cocreature> ph88: e.g. in the example 6.2 corresponds to 602
12:45:48 <cocreature> ph88: but it also looks like you should be testing for the version of megaparsec rather than the version of ghc
12:46:00 <sclv> right on both counts :-)
12:46:27 <ph88> cocreature, i thought with    __GLASGOW_HASKELL__ >= 822   i check for ghc version 8.2.2 or higher  .. and if that doesn't match go to the #elif ..
12:48:03 <cocreature> ph88: read the docs :)
12:48:10 <fangednoumena> Greetings, everyone.
12:48:42 <ph88> oh i see
12:48:53 <AndreasPK> marmistrz: If you use that pattern often MonadError or ExceptT give you catchError which should do exactly what you want.
12:48:56 <ph88> it's not (xyz) but (xyy) o_O
12:49:15 <sclv> yeah, you're checking for 8.22 !
12:49:35 <cocreature> but really checking for the ghc version is almost certainly the wrong thing to do here
12:49:48 <marmistrz> AndreasPK, I'm actually using ExceptT, but it's at the top level now
12:49:50 <marmistrz> :)
12:50:01 <marmistrz> yeah, the bitraverse is much less readable than the match
12:50:25 <AndreasPK> I'm a big fan of writing dumb code
12:52:45 <Welkin> the data oriented design approach
12:55:26 <AndreasPK> I guess that is a fair way to view it. It's mostly driven by the experience of "This obscure function does exactly what I need!" and forgetting what it does until I read/need it the next time.
13:04:37 <oo_miguel> hmm .. having an array of foo::[IO Bool] , I Want to execute them one by one until i get True or get out of elements... I am trying something like: or <$> foo, but this returns an array of Bools instead of a single one..
13:06:11 <jle`> oo_miguel: you're looking for something like findM
13:06:30 <geekosaur> foldM?
13:06:38 <jle`> you can also write something using some generic combinators using MaybeT
13:07:13 <shapr> silly question, is there a way to apply a constructor with four arguments to a list of four items?
13:07:16 <jle`> :t runMaybeT . asum . fmap (MaybeT . (guard =<<))
13:07:17 <lambdabot> error:
13:07:17 <lambdabot>     Variable not in scope: runMaybeT :: f0 a0 -> c
13:07:17 <lambdabot> error:
13:07:27 <jle`> @let import Control.Monad.Trans.Maybe
13:07:28 <lambdabot>  Defined.
13:07:30 <jle`> :t runMaybeT . asum . fmap (MaybeT . (guard =<<))
13:07:31 <lambdabot> error:
13:07:31 <lambdabot>     • Couldn't match type ‘()’ with ‘Maybe a’
13:07:31 <lambdabot>       Expected type: Bool -> m (Maybe a)
13:07:49 <jle`> shapr: no, not really, without pattern matching
13:08:04 <shapr> I thought as much, but I was hoping
13:08:12 <jle`> there is a way to do it probably with typeclass hackery
13:08:20 <jle`> but there's no standard way in the standard libs
13:08:57 <glittershark> the problem is mostly around proving that the list actually *has* 4 elements at the type level
13:09:15 <jle`> :t runMaybeT . asum . fmap (MaybeT . fmap guard)
13:09:16 <lambdabot> (Functor t, Monad m, Foldable t) => t (m Bool) -> m (Maybe ())
13:09:31 <orzo> you could make a sum type that consists of progressively more applied applications
13:09:39 <shapr> I wrote some hacky parsers in my Tuesday Haskell class and ended up with [Text] that I want to put into a record
13:09:44 <glittershark> ie (a -> a -> a -> a -> b) -> [a] -> b is probably impossible
13:09:57 <jle`> orzo: ^ result is Nothing if the list ran out of elements, and Just () if not
13:10:01 <jle`> sorry, * oo_miguel
13:10:28 <oo_miguel> jle`: np, thank you!
13:10:37 <glittershark> (a -> a -> b) -> Vec 2 a -> b is doable but
13:10:40 <jle`> shapr: usally i just (\[x,y,z,a] -> Foo x y z a)
13:10:44 <jle`> if i know the list has four elements
13:10:53 <oo_miguel> jle`: I have to tinkg about your answer, but thank you very much
13:10:57 <oo_miguel> think
13:10:59 <shapr> jle`: I'll try that, thanks
13:11:03 <glittershark>  :t guard
13:11:21 <glittershark> aww
13:11:24 <glittershark> :t guard
13:11:26 <lambdabot> Alternative f => Bool -> f ()
13:11:36 <jle`> guard turns the Bool into the Maybe (), that can be used with MaybeT and asum
13:11:54 <glittershark> guard b = if b then pure () else empty ?
13:12:13 <jle`> yes
13:12:19 <glittershark> :+1:
13:12:33 <jle`> and asum for MaybeT tries things out until you get a Just/pure
13:12:39 <glittershark> yep
13:13:01 <Ariakenom> edwardk, was gonna test when I realized it's time to update my ghc :p "Unsupported extension: ApplicativeDo"
13:13:06 <glittershark> asum = foldr (<|>) empty
13:16:48 <Mylo> I want to create a poker solver using counterfactual regret minimization. Will Haskell be fast enough, or should I just stick to c++
13:17:39 * hackage google-oauth2 0.3.0.0 - Google OAuth2 token negotiation  http://hackage.haskell.org/package/google-oauth2-0.3.0.0 (PatrickBrisbin)
13:19:25 <Ariakenom> also spent a good few minutes confused before I noticed there was no ApplicativeDo pragma
13:19:42 <shapr> Just ApplicativeDo It!
13:20:10 <Welkin> Mylo: stick to assembly
13:20:57 <glguy> Mylo: If you haven't written performance sensitive Haskell before it will be a learning experience
13:21:06 * shapr laughs
13:21:10 <bendo> :D
13:21:48 <shapr> I had to use BangPatterns yesterday to get checkers to approve a monoid instance for a binary tree.
13:21:59 <glittershark> wh
13:22:00 <maerwald> there are not many articles/tutorials/whatever for writing performant haskell code
13:22:20 <maerwald> so you are alone, where in C++ you can probably find a lot of tutorials
13:22:37 <shapr> maerwald: eh, it's not so bad these days
13:22:44 <Welkin> just litter your code with {-# UNPACK #-} and bangs and deepseq
13:22:45 <Welkin> :D
13:22:46 <maerwald> shapr: proof
13:23:27 <shapr> maerwald: does it count to put "haskell performance tuning" into google?
13:23:37 <Mylo> @Welkin I know a lot of C++, but I was just wondering if haskell could handle it
13:23:37 <lambdabot> Unknown command, try @list
13:23:48 <shapr> I learned a bunch reading Simon Marlow's Parallel and Concurrent book
13:24:11 <bendo> solving project euler in haskell can be sometimes performence fun
13:24:12 <Welkin> in haskell, correctness is priority # 1
13:24:18 <maerwald> Welkin: lolwat
13:24:25 <Welkin> you can still get good performance though
13:24:28 <shapr> I thought research was priority #1 in Haskell?
13:24:37 <maerwald> correctness is nowhere near priority #1
13:24:52 <Welkin> okay, if you put it that way, yes, research is #1
13:24:52 <maerwald> high-level and abstraction and research, sure
13:25:06 <Welkin> I am talking about for the programmer who uses it to build software
13:25:09 <maerwald> some very simple things in base are horribly incorrect
13:25:18 <Welkin> maerwald: then they should be fixed
13:25:21 <maerwald> lol
13:25:39 <shapr> aw, mylo bailed out :-(
13:25:54 <shapr> maerwald: do you mean head and other possible errors?
13:25:58 <shapr> hi Myloq
13:26:05 <Myloq> shapr Hery
13:26:07 <Myloq> Hey*
13:26:14 <maerwald> shapr: more like file IO and filepath handling
13:26:14 <Welkin> free(Myloq)
13:26:50 <shapr> Myloq: Haskell can certainly do counterfactual regret minimization, but I'll be surprised if there are already libraries that do that.
13:27:28 <bendo> Myloq: https://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-3000 <- check goals
13:27:29 <Myloq> shapr I didn't expect libraries to do it
13:27:32 <shapr> Myloq: I do think it's likely that you'd be able to make big changes in Haskell code in less time than a roughly equivalent C++ codebase.
13:27:53 <Myloq> shapr thanks man :)
13:28:36 <Myloq> Haskell still confuses me more than it should. I context switch too much between haskell and C++
13:28:37 <shapr> I've heard the professional Haskell performance people say it's not hard to get Haskell code to be about 200% the speed of C code
13:28:54 <maerwald> what?
13:29:05 <Myloq> Issue is I don't know how to make this algorithm declarative shapr
13:29:17 <Myloq> Could be a research paper probably
13:29:20 <shapr> is there a description of the algorithm?
13:29:51 <maerwald> shapr: the only professional I've seen trying to be as fas as C/C++ has failed
13:30:10 <Welkin> maerwald: given the fact that c and c++ compilers can be very stupid
13:30:19 <maerwald> and much worse than a factor of 2
13:30:24 <Welkin> it shouldn't be hard to produce faster code than them
13:30:41 <shapr> maerwald: got links?
13:30:52 <maerwald> shapr: https://github.com/RaphaelJ/friday#benchmarks
13:30:57 <maerwald> that code is seriously hand-optimized
13:31:46 <shapr> hm, do C compilers automatically produce SIMD instructions?
13:31:56 <Welkin> lol
13:32:03 <Welkin> openCV is using SIMD in that benchmark
13:32:06 <Welkin> how is that comparable?
13:32:36 <shapr> maerwald: I really don't know, do C compilers produce SIMD instructions?
13:32:53 <maerwald> I have no idea and I also have no idea if his assumption is true
13:34:00 <shapr> maerwald: so the refinement is, Haskell code is difficult to tune to be as fast as SIMD using code.
13:34:19 <maerwald> shapr: if his assumption is even true
13:34:30 <shapr> sure, agreed
13:34:41 <shapr> but we could find out!
13:35:06 <Myloq> shapr http://wwwf.imperial.ac.uk/~dturaev/neller-lanctot.pdf
13:35:47 <Myloq> I actually want to create a Pot Limit Omaha solver
13:35:54 <Myloq> With some abstractions
13:36:14 <Myloq> In haskell, because I think it's a good fit for the project, but not necessarily speed wise
13:36:26 <maerwald> shapr: so, all "performance comparisons" I've seen so far are trivial 20 loc algorithmic crap on SO or so
13:36:29 <maerwald> except this library
13:36:53 <shapr> hm, I guess all my advent of code implementations also fit into 20 loc algorithmic crap
13:36:58 <Welkin> if you want to know about haskell performance, ask Cale about his RPG
13:36:59 <shapr> maerwald: what about the warp web server?
13:37:12 <maerwald> shapr: I have no idea
13:37:17 <Welkin> warp is fast for sure
13:37:22 <Welkin> only nginx beats it
13:37:49 <Welkin> but according to davean it has a bug that can cause memory to leak, although I have had warp severs running for many years now without ever going down
13:37:51 <shapr> maerwald: I think the original research paper on warp showed it beating most web servers
13:37:55 <Welkin> oh yeah
13:38:01 <Welkin> file handles or something
13:38:47 <maerwald> shapr: link?
13:39:23 <glittershark> maerwald:
13:39:24 <Welkin> http://www.aosabook.org/en/posa/warp.html
13:39:24 <glittershark> http://www.aosabook.org/en/posa/warp.html
13:39:25 <Welkin> there is that
13:39:25 <shapr> maerwald: http://simonmar.github.io/bib/papers/web-server-jfp.pdf
13:39:27 <glittershark> ha
13:39:28 <glittershark> dang
13:39:41 <shapr> I was thinking of the fast web server simon marlow wrote
13:40:28 <maerwald> shapr: I only see a comparison to apache
13:40:59 <maerwald> and it doesn't even say what version etc
13:41:55 <maerwald> doesn't really look like an extensive performance comparison
13:42:08 <shapr> ok, what about the url glittershark and Welkin posted?
13:43:10 <Welkin> it has a comparison to nginx
13:45:40 <shapr> maerwald: I'd say there's sufficient doubt in either direction, more benchmarks needed.
13:46:15 <maerwald> also, for web servers there is plays much more into the performance imo (as in: architecture decisions)
13:46:31 <shapr> plays?
13:46:33 <maerwald> I'd rather focus on non-trivial algorithms
13:46:42 <shapr> maerwald: oh, have you benchmarked any?
13:46:44 <maerwald> friday is very nice for that
13:46:57 <maerwald> yes, but the implementations were not 1:1
13:47:13 <maerwald> mostly, my C parser was magnitudes faster
13:47:22 <maerwald> while I just used attoparsec in haskell
13:47:30 <shapr> Do you think that's because of the indirection of the GHC runtime system?
13:47:48 <maerwald> I think it's just because I heavily hand-optimized the C parser
13:47:57 <maerwald> you won't understand a single line
13:48:01 <shapr> Did you profile the Haskell code? I'm curious what parts cost the most time.
13:48:07 <shapr> I believe you, no proof needed.
13:48:29 <maerwald> well, attoparsec, I don't remember the details as I didn't consider that a proper comparison
13:48:38 <shapr> maerwald: does that mean you've started using inline-c after profiling slow code?
13:48:47 <glittershark> ugh
13:48:51 <shapr> hm, would be interesting to see the details
13:49:02 <glittershark> is there any way to call a TH macro in GHCi?
13:49:14 <glittershark> trying to write a doctest that uses one
13:49:31 <maerwald> shapr: parsing was reading a 120mb mesh file into vertices
13:49:38 <maerwald> then construct half-edges out of it
13:50:04 <shapr> would be interesting to see the source
13:50:47 <shapr> glittershark: I think the separate compilation step will require you to define the TH in a separate file and then import that into GHCi
13:50:53 <glittershark> awwwww
13:51:01 <shapr> at least *I* don't know a way to do that
13:51:09 <Welkin> you could write it in lisp
13:51:16 <glittershark> lol thanks
13:51:22 <shapr> glittershark: oh hey, I think you might be able to
13:51:34 <shapr> run the Q monad and get the result?
13:51:37 <glittershark> I just want to `makeLenses` :'(
13:51:44 <maerwald> shapr: I could pm it to you, but the implementations are really not 1:1
13:51:56 <shapr> maerwald: aw, it's not up on github?
13:51:59 <maerwald> but I would say at that time I had not much more haskell experience than C experience
13:52:02 <shapr> would make for an interesting post
13:52:14 <maerwald> and doing it fast in C was still very easy for me
13:52:45 <maerwald> shapr: sure it's on github, I just don't want to post it here ;)
13:52:51 <shapr> aw, ok
13:54:54 <glittershark> shapr: can't seem to make it happen, unfortunately :(
13:55:14 <glittershark> the doctest parser is interpreting the line as an expected result
13:55:19 <glittershark> rather than as a line of input
13:55:32 <glittershark> I'll just define the dang lenses by hand
14:07:20 <ph88> is it possible to pattern match head and tail on Text with overloadedstrings ?
14:08:13 <jle`> ph88: you can use something like ViewPatterns or PatternSynonyms
14:08:36 <jle`> ph88: the 'point' of normal pattern matching is to allow you to match on constructors, but Text's constructors aren't 'head and tail'
14:09:21 <jle`> ph88: you can use ViewPatterns with uncons
14:09:57 <jle`> ph88: myFunction (uncons->Just(x,xs)) -> ...
14:11:12 <ph88> oh that's nice
14:13:15 <ph88> how can i pattern match on the empty Text ?
14:16:35 <glittershark> Control.Lens has an 'Empty' pattern synonym which I would use
14:16:50 <glittershark> but that's a lens dependency
14:17:07 <jle`> ph88: uncons->Nothing
14:17:09 <Welkin> say hello to an extra 30 minute compile time :D
14:17:15 <glittershark> haha
14:17:19 <glittershark> fine if you're already depending on it
14:17:42 <jle`> ph88: i think there might be a compiler optimization that rewrites that to not require two unconses
14:18:05 <ph88> ah ok was wondering about that ^^
14:18:11 <jle`> ph88: but also
14:18:21 <jle`> you could just do myFunction (uncons->Just(x,xs)) = ...
14:18:24 <jle`> and myFunction _ = ...
14:18:33 <jle`> since if it's not Just then it's Nothing
14:20:35 <jle`> ph88: with OverloadedStrings, a pattern on "hello" just desugars to T.unpack->"hello"
14:20:42 <orbisvicis> if my module description and two module functions share the same documentation, is there any way for haskell to link that documentation ?
14:21:18 <glittershark> orbisvicis: yeah, hackage has named sections
14:21:21 <glittershark> haddock, sorry
14:21:40 <glittershark> make a standalone comment block with a $something header
14:21:50 <glittershark> then put $something in the docs for the module header and the two functions
14:22:10 <ph88> jle`, if it desugars does that mean it's not possible to make a program without String ?
14:22:16 <ph88> Text only
14:22:20 <jle`> ph88: it is
14:22:27 <glittershark> at least I think so, though reading https://www.haskell.org/haddock/doc/html/ch03s05.html maybe that's only in the export list...
14:22:29 <jle`> i'm saying that that's how OverloadedStrings desugars
14:22:53 <orbisvicis> seems to be only the export list, $something in the module header is a parse error
14:22:54 <jle`> but you can write your program without OverloadedStrings
14:23:52 <glittershark> aww
14:23:58 <glittershark> copy-paste it is :(
14:25:31 <edwardk> jle`: isn't it worse than that? iirc it encodes as (fromString "hello" ==) -> True -- IsString has no way to check a string baked in
14:26:58 <orbisvicis> glittershark: well you are right, the docs mention named chunks as "part of the module description"... but I can't figure it out, or maybe I need a newer haddock ?
14:27:07 <glittershark> hmm
14:28:07 <jle`> edwardk: oh, you're right
14:28:11 <jle`> edwardk: i was thinking of IsList
14:28:30 <edwardk> i try not to think of IsList
14:28:31 <edwardk> =)
14:37:38 <zachk> is there a way to get lens to work over sum types? would I have to handcode the lenses?
14:43:04 <johnw> zachk: that's what Prisms do
14:43:59 <zachk> oh
14:44:15 <zachk> can they be created automagically using TH?
14:44:27 <johnw> $(makePrisms ''Foo)
14:44:38 <dpyro> so question: what's the purpose of things along the lines of "Liftings to unary and binary type constructors"
14:46:22 <jle`> dpyro: what kind ò things do you mean
14:46:34 <jle`> *what kind of things do you mean
14:46:48 <dpyro> a lot of 3rd party libraries i'm using have a lot of functions for lifting to unary and binary constructors
14:47:00 <dpyro> i'm not sure what role that fulfills
14:47:02 <jle`> what do you mean by 'lifting to unary and binary consturctors'
14:47:14 <jle`> can you give a specific example
14:47:48 <dpyro> for example in Data.Aeson you have `class FromJSON1 f` which is described as "Lifting of the FromJSON class to unary type constructors."
14:48:20 <jle`> ah
14:48:23 <jle`> yes, those are in base too
14:48:29 <dpyro> in Test.QuickCheck.Arbitrary there's a `class Arbitrary1` with a similar description
14:48:39 <dpyro> so i think i'm missing a whole idiom here
14:48:43 <dpyro> i am a haskell newb :)
14:49:50 <jle`> hm, i'm not sure exactly, but one benefit might be ti help with writing normal FromJSON instances
14:50:34 <jle`> use as an intermediate class
14:50:41 <dpyro> the type signature in this case is `liftArbitrary :: Gen a -> Gen (f a)`
14:50:53 <dpyro> it seems to be in generic and derivable class stuff
14:51:04 <dpyro> where you make your own datatypes then derive on the library
14:51:28 <jle`> yeah, it's probably used to help write polymorphic instances for FromJSON
14:51:30 <lyxia> dpyro: they encode a constraint like "forall a. Arbitrary a => Arbitrary (f a)"
14:51:45 <dpyro> ooo
14:51:55 <lyxia> That you can't express otherwise without an extension that doesn't exist yet.
14:51:56 <dpyro> can you give an example of it being used?
14:52:15 <dpyro> so its moving the type constraint into the functor?
14:52:16 <jle`> the instance of FromJSON (Product f g a) uses it
14:52:37 <jle`> data Product f g a = Pair (f a) (g a)
14:52:47 <jle`> although i guess that one doesn't need FromJSON1
14:55:15 <lyxia> dpyro: Fix is an example. Look at those constraints https://hackage.haskell.org/package/recursion-schemes-5.0.2/docs/Data-Functor-Foldable.html#t:Fix
14:56:03 <lyxia> or when you're making "functor-functor" records https://www.benjamin.pizza/posts/2017-12-15-functor-functors.html
14:56:23 <dpyro> ty lyxia
14:56:26 <jle`> dpyro: it might be mostly used day-to-day for Generics, since generics is basically functor manipulation
14:57:42 <lyxia> (this blogpost doesn't actually talk about these _1 classes, but you'd need them if you tried to implement Show/ToJSON/Arbitrary/etc.)
14:58:05 <lyxia> it's not really used for generics
14:59:09 <lyxia> The fact that GHC.Generic is made of functors is only to allow Generic1 but that approach is really limited.
14:59:57 <jle`> aw man
15:00:06 <jle`> i see the FromJSON1 instance used for the Rec constructor
15:01:23 <Welkin> what's with the 1?
15:02:19 <lyxia> it's the arity of its parameter
15:02:46 <johnw> FromJSON1 is for type formers, like Maybe
15:05:10 <lyxia> I'm pretty sure it's only used as the closest approximation to   (forall a. FromJSON a => FromJSON (f a))   and it will be made obsolete by QuantifiedConstraints.
15:05:10 <jle`> i wonder, will the Blah1 typeclasses become obsolete when QualifiedConstraints lands
15:05:36 <lyxia> <3
15:05:49 <jle`> ty for fixing my typo too heh
15:11:15 <inkbottle> I've got some code that does compile, with a function taking Float; but the execution failed with "non-exhaustive patterns"; so I put "error (show x)"; and that says "NaN"; How could it have compiled the first time?
15:13:56 <lyxia> what does the function look like
15:15:55 <inkbottle> lyxia: I think I've found something: there is an "atan" inside the code... I need to check what sort of numbers come out of there (https://stackoverflow.com/questions/44379638/round-nan-in-haskell)
15:16:38 <zachk> are you pattern matching on a float or just using round on it, inkbottle ?
15:16:46 <jle`> inkbottle: the type system doesn't quite help with NaN in Floats, unfortunately
15:18:28 <inkbottle> zachk: I'm not doing the same thing as in the "link"; but it gave me a hind about how it could have compiled... Plus the possible origin of the NaN
15:19:02 <zachk> inkbottle, maybe post your code to http://lpaste.net so we can look at it
15:19:42 <inkbottle> zachk: why not, beware it's ugly; I do that in a minute
15:19:53 <zachk> aight
15:22:56 <zachk> can I compose regular lens's with prisms?
15:23:04 <johnw> zachk: yes
15:23:51 <johnw> zachk: many examples of using them here: https://github.com/jwiegley/putting-lenses-to-work/blob/master/putting-lenses-to-work.pdf
15:24:21 <jle`> zachk: that's the beauty of it :)
15:24:40 <jle`> zachk: if you look at the diagram on the lens documentation, you can see what the composition of lens and prism turns into
15:24:58 <jle`> zachk: it's their mutual parent in the tree
15:25:10 <jle`> well, any mutual parent
15:25:44 <lyxia> or check out this one http://oleg.fi/gists/posts/2017-04-18-glassery.html
15:26:04 <jle`> zachk: http://hackage.haskell.org/package/lens
15:26:40 <jle`> zachk: you can see that Lenses and Prisms are both children of Traversal, Fold, and Setter
15:26:53 <jle`> or i guess ancestor if you read it the arrow direction
15:27:15 <jle`> which means you can use them as folds, setters, and traversals
15:27:25 <jle`> (if you compose them)
15:28:20 <inkbottle> zachk: http://lpaste.net/6465149343648186368
15:29:04 <inkbottle> I'm trying to make a 10 degree rotation
15:29:56 <inkbottle> and trying to compute what should be the value of the pixel at a float, float point
15:30:17 <inkbottle> I don't know why the code is so ugly :)
15:31:11 <inkbottle> the cabal file is the same as the github one
15:31:29 <inkbottle> I compiled it with stack
15:32:09 <inkbottle> I removed the versions constraint in cabal file, seems to work as well
15:35:20 <glguy> inkbottle: Do you know what NaN is?
15:35:56 <inkbottle> glguy: got an idea, yes
15:36:19 <Welkin> > 0/0
15:36:21 <lambdabot>  NaN
15:36:23 <Welkin> :D
15:36:31 <glguy> Well Nan isn't == 0, < 0 , or > 0, so you'll need to handle the case for a value such as NaN when you implement sigint on line 75
15:37:08 <shapr> even better, NaN /= NaN
15:37:09 <jle`> > signum (0/0)
15:37:11 <lambdabot>  NaN
15:37:18 <jle`> i don't know what i expected
15:37:31 <shapr> > signum (0/0) == signum (0/0)
15:37:33 <lambdabot>  False
15:37:34 <Welkin> > Infinity
15:37:35 <lambdabot>  error:
15:37:36 <lambdabot>      • Data constructor not in scope: Infinity
15:37:36 <lambdabot>      • Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natural)
15:37:37 <glguy> > truncate (0/0) :: Int
15:37:40 <lambdabot>  0
15:37:50 <Welkin> > 1/0
15:37:52 <lambdabot>  Infinity
15:38:07 <Welkin> > (1/0)/(1/0)
15:38:09 <shapr> I'm kinda excited about linear types in GHC
15:38:09 <lambdabot>  NaN
15:38:12 <jle`> @let pattern Infinity <- isInfinite->True where Infinity = 1/0
15:38:12 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
15:38:19 <jle`> is pattern synonyms not enabled
15:38:28 <jle`> @let pattern Infinity <- (isInfinite->True) where Infinity = 1/0
15:38:29 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
15:38:30 <droplet> @hoogle a -> [a]
15:38:31 <lambdabot> Prelude head :: [a] -> a
15:38:31 <lambdabot> Prelude last :: [a] -> a
15:38:31 <lambdabot> Data.List head :: [a] -> a
15:38:33 <jle`> :(
15:38:43 <jle`> 💧 what were you looking for?
15:38:46 <jle`> * droplet
15:38:51 <Welkin> o.o
15:38:51 <jle`> first three results might not be too helpful heh
15:38:59 <jle`> :t (:[])
15:39:00 <lambdabot> a -> [a]
15:39:02 <jle`> behold the robot monkey operator
15:39:04 <Welkin> you typed an emoji
15:39:05 <inkbottle> glguy: but I should know why I get a NaN in the first place
15:39:10 <droplet> i was hoping for something like singleton
15:39:16 <jle`> 💧 i usually use (:[])
15:39:20 <droplet> or return, specialised for lists
15:39:22 <Welkin> lol what
15:39:24 <droplet> ah nice
15:39:34 <jle`> 💧 i don't like using pure/return
15:39:37 <Welkin> jle`: do you know you are typing a rain drop emoji?
15:39:49 <jle`> oh haha it must be my emoji plugin for my irc client
15:40:02 <iqubic> What does (:[]) do?
15:40:06 <jle`> i don't like using pure/return here unless it's in a 'applicative' or 'monad' context
15:40:09 <jle`> iqubic: guess :)
15:40:12 <glguy> iqubic: There's no way to know
15:40:23 <droplet> right, that's why i was hoping for a more specific version
15:40:34 <Welkin> iqubic: (\ a -> Cons a Nil)
15:40:50 <Welkin> where Cons is : and Nil is []
15:40:51 <jle`> 💧 any version you find will probably be longer than (:[]), which mgiht be why there isn't one
15:41:17 <droplet> fair enough, thanks!
15:41:40 <iqubic> right, that makes sense.
15:41:50 <iqubic> (:[]
15:42:05 <Welkin> it's a function section
15:42:11 <Welkin> \ a -> a : []
15:42:29 <dmj`> iqubic: its the monkey operator (:[])
15:42:42 <iqubic> It's a one element list, right?
15:42:47 <Welkin> yes
15:43:34 <iqubic> Why is that useful?
15:44:23 <Welkin> if you want to construct a single element list
15:44:46 <Welkin> you could use pure or return if you are operating inside of a List context
15:44:55 <Welkin> but this is more explicit
15:47:50 <dpyro> is there a way to have a function that supports both ByteString and ByteString.Lazy as the argument?
15:48:39 <johnw> dpyro: I would support Lazy, then make a non-Lazy variant that just composes in fromStrict
15:48:55 <dpyro> i'll try that then
15:48:56 <johnw> a way to seamlessly support both I don't know of
15:49:24 <johnw> long ago I wrote a stringable library to try to solve this, but ended up really never using it
15:52:59 <ph88> how can i turn Text into  Tokens s  to give to string' function?  https://hackage.haskell.org/package/megaparsec-6.5.0/docs/Text-Megaparsec-Char.html#v:string-39-
15:54:22 <xacktm> ph88: maybe you need a Text -> String function?  like T.unpack ?
15:54:42 <ph88> maybe ..
15:54:56 <ph88> there is an instance of  "Tokens Text" though ..
15:55:50 <xacktm> what is the error?
15:56:24 <ph88> https://bpaste.net/show/c691efdedd7e
15:56:32 <ph88> txtt :: T.Text -> f T.Text
15:58:11 <ph88> xacktm, ^
16:03:36 <xacktm> ph88: maybe the caller of txtt is requesting String, or you're not calling txtt right? not sure
16:03:55 <ph88> it could be that ..
16:04:08 <ph88> but i don't see a caller mentioned in the error message
16:04:46 <xacktm> what happens when you T.unpack it?
16:06:26 <ph88> xacktm, the  s  ?
16:06:31 * xacktm <-- has not used megaparsec
16:06:42 <xacktm> yeah, M.string' (T.unpack s)
16:07:17 <ph88> https://bpaste.net/show/bfa4bc792f1c
16:08:19 <xacktm> hm
16:08:24 <ph88> oh it works now
16:08:35 <ph88> it was part of the type of Parser
16:08:38 <xacktm> waht did you do?
16:08:51 <ph88> the   f   in   txtt :: T.Text -> f T.Text
16:08:56 <ph88> i changed the type of Parser
16:09:04 <ph88> type Parser = M.Parsec Int T.Text
16:09:18 <ph88> thanks for your help
16:09:41 <xacktm> still don't understand, but np %)
16:10:48 <ph88> xacktm,  txtt :: T.Text -> (M.Parsec Int String) T.Text   <-- expanded type when i got the error
16:11:07 <xacktm> ahh ok
16:11:31 <xacktm> I really should learn monad transformers
16:12:09 * edwardk is stuck on something stupid. i have a package for commutative applicatives/semigroups/etc. that i want to write, but the name 'commutative' is taken. suggestions for a name? =)
16:12:33 <zachk> magmoidal
16:13:05 <zachk> inkbottle, line 65 you could also get a divide by zero error
16:13:06 <CodeKiwi> commutative-ng
16:13:19 <edwardk> zachk: that'd probably imply that you dropped associativity. dropping associativity and picking up commutativity would give the name 'mobile'
16:13:20 <fishythefish> edwardk: abelian is free
16:13:30 <edwardk> fishythefish: thats been the one i've been thinking about taking
16:13:36 <CodeKiwi> Commutative
16:13:43 <edwardk> CodeKiwi: *shudder*
16:13:52 * CodeKiwi evil laugh
16:14:07 <fishythefish> edwardk: I'm hesitant to start applying the term "abelian" to all commutative structures, but if you have (semi)groups in there, I guess you can justify it
16:14:18 <xacktm> ph88: maybe you can use ScopedTypeVariables so the type resolution works automatically instead of manually specifying Parser
16:15:22 <xacktm> (or maybe you're already doing something better, just throwing ideas out there)
16:15:23 <edwardk> right now i'd need a Commutative class for commutative applicatives and a CommutativeSemigroup, and then CommutativeMonoid, something that works for commutative Apply instances, etc.
16:15:34 <ph88> edwardk, http://www.thesaurus.com/browse/commutative
16:15:36 <edwardk> then i can package the free monad given a commutative applicative in there
16:16:01 <CodeKiwi> just call it commie
16:16:07 <edwardk> ph88: sadly none of those have anything to do with the mathematical concept
16:16:12 <johnw> edwardk: is there any reason Free has no Generic instances?
16:16:15 <edwardk> commutativity is one thought
16:16:22 <edwardk> johnw: no
16:16:34 <edwardk> feel free to add Generic/Generic1
16:16:36 <johnw> invitation accepted
16:16:39 <CodeKiwi> edwardk you could always just track down the person that has it and get rid of them
16:16:49 <ph88> xacktm, i think i'm supposed to specify it myself
16:16:51 <fishythefish> edwardk: or commuting
16:17:00 <edwardk> CodeKiwi: SPJ frowns on me eliminating community members by force.
16:17:10 <CodeKiwi> don't ask don't tell
16:17:23 <xacktm> ph88: ok
16:17:33 <CodeKiwi> you could assume his identity, nobody will even know he's gone
16:17:38 <fishythefish> "commuting" already sees use in "commuting operators", "commuting observables", etc. so maybe that's more appropriate than "abelian", which is normally only applied to group-like structures
16:17:47 <ph88> edwardk, is there anything that combines lens with GHC.Generics instead of Data ?
16:17:51 <edwardk> commuting, commutes, commutativity, etc.
16:18:06 <CodeKiwi> transit
16:18:08 <fishythefish> "commuting" also follows the trend of being an adjective :P
16:18:10 <ph88> metro
16:18:40 <edwardk> ph88: there was a GHC.Generics.Lens that had a form of uniplate in it, but ryanglscott and glguy took my toy away because that 'uniplate' didn't match the behavior of Data.Data.Lens.uniplate
16:18:57 <edwardk> ph88: there is an issue to reinstate it in some form, i think
16:19:25 <fishythefish> obviously the right solution is to define the mmutative package and take the dual /s
16:19:32 <CodeKiwi> glguy is such a fun hater gosh why is he like this :P
16:19:58 <lyxia> ph88: have you seen generic-lens
16:20:20 <edwardk> inclined to just call the package 'abelian' and have keep the names 'Commutative' etc. for the classes involved
16:20:54 <ph88> edwardk, what about a form of biplate/template ?
16:20:58 <ph88> lyxia, noes
16:21:13 <edwardk> ph88: that was in the module before
16:22:45 <edwardk> https://hackage.haskell.org/package/lens-4.4/docs/Generics-Deriving-Lens.html is the old one
16:24:00 <edwardk> it had 'tinplate' in it, which could look for Typeables, but lacked the 'hit map' machinery that the Data.Data.Lens stuff has, which improves performance by avoiding walks into structures that it can prove do not contain transitively the type you are looking for
16:25:32 <johnw> edwardk: what should the GHC version minimum be for Generic and Generic1?
16:25:49 <edwardk> 7.2 and 7.6 respectively
16:25:54 <johnw> thanks
16:26:03 <edwardk> see the 'perhaps' code i wrote last night for reference =)
16:26:14 <edwardk> btw to go below 7.6 you need generic-deriving, etc.
16:26:18 <johnw> link?
16:26:25 <edwardk> so it might just make sense to go with 7.6 for both
16:26:46 <johnw> good idea
16:26:50 <edwardk> http://hackage.haskell.org/package/perhaps https://github.com/ekmett/perhaps
16:27:00 <johnw> ah, literally perhaps
16:27:08 <lyxia> Can you even derive Generic1 for Free? I thought that's only for types of kind (* -> *)
16:27:11 <edwardk> i don't remember the current version floor for 'free'
16:27:24 <edwardk> (Free f) gets the Generic1 instance
16:27:29 <edwardk> using the Generic1 for 'f'
16:27:37 <texasmynsted> anybody here use SHIM (Superior Haskell Interaction Mode) with vim?
16:28:45 <lyxia> ah right.
16:28:46 <edwardk> johnw: anyways, https://github.com/ekmett/perhaps/blob/master/src/Control/Monad/Perhaps.hs might serve as a decent field guide for how to support ancient versions, it builds back to 7.2 and bends over backwards to support everything like Typeable all the way through all the awkward teething pain eras where you had to do it by hand
16:29:16 <johnw> considering that Generic hasn't been there until now, I'm not feeling too backward bendy
16:29:17 <edwardk> wrote it last night and spent a few hours pair programming with a guy who wanted to know more about backporting haskell code
16:29:21 <edwardk> yeah
16:33:50 <Guest67676> I'm reading Real World Haskell and I've gotten stuck trying to understand a code snippet. https://pastebin.com/u5j5eCnP What's the deal with pre : case suf? That doesn't make syntactical sense to me. Clearly suf is the case distinguisher, so why doesn't leaving out the "pre :" work? My brain just can't parse it
16:34:28 <fishythefish> Guest67676: read case of ... as one unit
16:34:34 <fishythefish> then (pre :) is applied to that whole expression
16:35:06 <Guest67676> you can DO that?
16:35:15 <Guest67676> I must admit that's cool
16:35:28 <Gigabitten> k there's my normal name
16:35:57 <lyxia> everything is an expression
16:35:57 <CodeKiwi> I was digging the 666
16:36:03 <fishythefish> Gigabitten: pretty much everything is an expression
16:36:21 <Gigabitten> so it's saying cs = pre : case suf of yadayada?
16:36:23 <Gigabitten> I just got it
16:36:24 <Gigabitten> thanks
16:36:27 <fishythefish> > 0 + if True then 1 else 2
16:36:29 <lambdabot>  1
16:36:46 <Gigabitten> there was a switch that turned on in my head. I've got it now. thanks fishy
16:36:51 <fishythefish> Gigabitten: yes, but read that as `cs = pre : (case suf of yadayada)`
16:37:32 <Gigabitten> yup! that's the way I was thinking about it.
16:38:13 <Gigabitten> fishy, why does that work?
16:38:24 <johnw> edwardk: https://github.com/ekmett/free/pull/171
16:38:25 <Gigabitten> I just got done parsing one thing and now I can't parse this
16:38:36 <fishythefish> Gigabitten: do you understand how `cs = case suf of yadayada` would work?
16:38:53 <fishythefish> same thing, but `pre` is consed to the result
16:40:29 <Gigabitten> yeah there were only two things I didn't understand about the function and cs = case suf of yadayada cleared it up. cs is equal to pre (stuff before newline) cons stuff after newline, and then stuff after newline is recursively checked for more newlines
16:40:49 <Gigabitten> why did I say "stuff after newline" when I could have just said "suf"
16:40:51 <Gigabitten> you get the idea
16:41:31 <Gigabitten> although it seems not very optimal to check like this, since why would there be more than one different kind of newline in a string
16:42:47 <fishythefish> Gigabitten: but on the other hand, you do need to support handling all the different line terminators
16:43:13 <fishythefish> in any case, most instructive code isn't designed to be optimal, it's designed to teach code patterns
16:43:23 <Gigabitten> yeah that's true
16:43:25 <Gigabitten> fishythefish: if I throw that "> 0 + if True then 1 else 2" stuff
16:43:32 <Gigabitten> oh I forgot to finish the message
16:43:40 <Gigabitten> if I throw it in ghci it gives a parse error
16:43:53 <fishythefish> Gigabitten: the ">" at the start is to tell lambdabot to evaluate it
16:43:54 <dogui> Should this program really fail, or is it a limitation of GHC? (class C a; class C a => B a; class C a => A a; instance A a => B a)
16:43:58 <fishythefish> omit it if you're in ghci
16:44:02 <Gigabitten> oh lol that explains everything thanks
16:44:21 <Gigabitten> I waasn't aware of that. that clears it up
16:45:02 <Gigabitten> man this IRC is so helpful and good at explaining things. huge thank you.
16:45:06 <dpyro> is there a built-in way to unpack a value from a newtype?
16:45:23 <johnw> Data.Coerce.coerce
16:45:26 <fishythefish> coerce
16:45:44 <lyxia> or declare it as a record
16:46:05 <dpyro> do i need some kind of type annotation?
16:46:07 <fishythefish> or pattern match
16:46:13 <johnw> you shouldn't need one
16:46:23 <dpyro> i get an error such as Couldn't match representation of type ‘a0’ with that of ‘BC.ByteString’ arising from a use of ‘coerce’
16:46:28 <dpyro> when trying to implement an instance
16:46:41 <dpyro> for: instance ToJSON HexString where toEncoding h = toEncoding $ coerce h
16:46:52 <johnw> is toEncoding polymorphic?
16:47:19 <dpyro> toEncoding :: a -> Encoding
16:47:19 <fishythefish> for something like that you could also consider GND instead
16:47:52 <dpyro> GND?
16:47:56 <johnw> well, you could be calling any other toEncoding there
16:47:59 <johnw> cerce doesn't know that
16:48:22 <dpyro> ahh, so toEncoding does not automatically inherit the class definition's type signature?
16:48:43 <johnw> your implementaiton of toEncoding might be calling *any other* instance's toEncoding
16:48:52 <johnw> which is totally reasonable to do
16:48:54 <fishythefish> if it doesn't *have* to be builtin, you can take a look at the `ala` function
16:51:18 <johnw> edwardk: new free release? :)
16:51:45 <edwardk> i take it you wrote that because you needed it? ;)
16:51:53 <johnw> yeah
16:52:14 <edwardk> i have no objection to releasing. currently trying to figure out how one sets up twitch for streaming
16:52:23 <johnw> I want to make hnix's expression type parametric in the variable type, so I want to move from Fix NExprF to Free NExprF a, to make substitution just bind
16:52:26 <edwardk> so if i'm distracted thats why
16:52:31 <johnw> but I rely on Generic for tons of instances
16:52:38 <edwardk> makes sense
16:55:47 <boxscape> is there a way to tell runghc of where it should look for .hs files to import?
16:58:45 <inkbottle> zachk, jle`: Thanks for the help with the NaN; cat teleportation machine is still a work in progress https://pasteboard.co/HiaqsQa.png
16:58:49 <edwardk> looks like i may need to switch laptops if i'm going to do livecoding using twitch, this thing is more than a bit underpowered. my work laptop is more than fast enough, but its not the one i use for day to day stuff
16:59:06 <edwardk> my vr laptop is fast enough, but its running windows and, well, just no.
17:01:03 <fishythefish> inkbottle: totally read that as a "NaN-cat teleportation machine"
17:01:11 <sqooq> does anyone in here use yi
17:01:43 <CodeKiwi> ni
17:02:10 <johnw> edwardk: I don't even know what twitch is
17:02:33 <fishythefish> johnw: twitch.tv, popular site for streaming video games
17:02:37 <Welkin> johnw: it's an abomination that amazon bought about 4 years ago
17:02:38 <fishythefish> but people stream other stuff now too
17:02:53 <Welkin> it's amazon's youtube (but streaming)
17:03:16 <fishythefish> it's not amazon's youtube
17:03:21 <fishythefish> the point of twitch isn't to upload videos
17:03:32 <Welkin> that is why I said for streaming
17:03:35 <Welkin> and you have video on demand
17:03:39 <CodeKiwi> it's to have hot girls flash titties and play video games and get tips
17:03:40 <fishythefish> youtube has streaming now too
17:03:41 <Welkin> so you, you can upload videos
17:03:45 <Welkin> of course
17:03:46 <johnw> and apparently it has edwardk's attention
17:03:47 <Welkin> they have to comepete
17:04:01 <Welkin> twitch uses go, btw
17:04:01 <Welkin> lol
17:04:09 <Welkin> shapr ^
17:04:31 <sm> twitch owns content you stream there, am I right ?
17:04:36 <CodeKiwi> well that settles it I'm learning go now if such esteemed organizations as twitch use it
17:04:38 <Welkin> no idea
17:04:52 <fishythefish> saying you can upload videos to twitch by streaming them is like claiming to be a time traveler because you travel at the rate of 1 second per second
17:04:56 <CodeKiwi> what amazing websites have haskell made none checkmate
17:05:25 <lyxia> boxscape: -ipath/to/src/
17:05:31 <CodeKiwi> fishythefish I have this amazing trick I close my eyes and when I open them again it's 4 hours into the future
17:05:39 <boxscape> thanks lyxia
17:05:42 <Welkin> not 8?
17:05:49 <CodeKiwi> no
17:05:49 <sm> CodeKiwi: ouch you wound us
17:06:08 <CodeKiwi> I'm lucky to sleep more than 3 hours
17:06:10 <Welkin> sm: why you no ludum dare?
17:06:16 <Welkin> oh yeah
17:06:23 <Welkin> last night was fucked for sleeping for me
17:06:34 <sm> Welkin: ack >:| because I'm writing budgeting tools
17:06:39 <Welkin> the god damn airporthad planes flying super low from 1 am to around 6 am
17:06:40 <Welkin> fuck them
17:06:59 <Welkin> doing who knows what
17:07:01 <Welkin> flying in circles
17:07:18 <sm> Welkin: are you dare-ing ?
17:07:20 <Welkin> no
17:07:26 <Welkin> but I am making games
17:07:34 <Welkin> and rapidly doing a game course
17:07:37 <sm> good!
17:08:04 <Welkin> ld is technically over
17:08:09 <Welkin> the lisp game jam is still going all week though
17:08:21 <sm> when does the haskell game jam start, again ?
17:08:23 <Welkin> although I'm not making the games in haskell :P
17:08:34 <Welkin> there is no such thing
17:08:37 <Welkin> someone has to create it
17:08:42 <sm> that is totally a thing and if I keep saying it it will happen
17:08:53 <Welkin> perhaps
17:08:57 <Welkin> summer is a good time to do it
17:09:09 <johnw> I feel like I derailed actual Haskell conversation by asking for a pop culture definition
17:09:17 <johnw> op fail
17:09:22 <APic> *shrug*
17:10:15 <Welkin> I think there are two issues though with games in haskell
17:10:28 <Welkin> 1) lack of libraries beyond opengl and sdl bindings
17:10:29 <johnw> I wonder if freer-simple has good performance
17:10:36 <Welkin> 2) uncertainty about how to structure the code
17:10:53 <Welkin> which could make a game jam hard unless there are some resources provided
17:11:28 <sm> only if you have too-high expectations!
17:11:34 <Welkin> also, writing opengl code for a game jam is pretty ridiculous
17:11:48 <Welkin> if you only have 2-3 days to make a complete game
17:12:48 <Welkin> it seems like the obvious answer for how to structure the code is use an ECS
17:13:10 <dyl> Hey all,
17:13:46 <dyl> I’m implementing a shift reduce algorithm which proceeds by a sliding window of width three from the right side (but we can say left without loss of generality)
17:14:11 <dyl> I’m wondering if a zipper approach is the right way to handle navigating the token sequence, when I need a 3 wide window
17:14:15 <zachk> inkbottle, you might want to use a rotation matrix to rotate vectors, you can hand unroll the 2x2 matrix operations out so you don't need any matrix support code
17:14:23 <dyl> Except at the last step when only two tokens remain, then it’s always a reduction.
17:14:43 <dyl> The reductions are always (T, T) ⇒ T though.
17:15:02 <dyl> The question is whether to reduce the current and rightmost production.
17:15:06 <CodeKiwi> johnw no worries I totally didn't screenshot that and hold it for future reference for blackmail purposes
17:15:11 <zachk> inkbottle, also the error in you doing the rotation could be from having to figure out the signs for the various quadrants, using ASTC
17:15:12 <inkbottle> zachk: yes, good idea
17:15:13 <dyl> So when considering l, c, r,
17:15:17 <johnw> hmm
17:15:20 <dyl> I either shift left, or reduce c r
17:15:30 <dyl> This process builds a binary tree.
17:16:03 <dyl> I’m not sure of a recursion scheme that encapsulates this behavior nicely, so I was thinking of a zipper.
17:16:18 <dyl> Also after every reduce, I restart at the rightmost.
17:16:41 <dyl> In my current code I do this using pattern matching so I just reverse the list and match (r:c:l:rest)
17:16:57 <dyl> If only (r:l:[]) then I always reduce or emit an error.
17:17:14 <inkbottle> zachk: what is ASTC
17:17:18 <dyl> A single element is the base case, and zero elements is a trivial error case
17:17:24 <johnw> dyl: can you "view" your data structure as something which has the exact form you need?
17:17:53 <dyl> johnw a pair of lists (or Seq rather) would work
17:18:18 <dyl> At each step I either reduce the two rightmost elements of the current 3-window
17:18:23 <dyl> Or shift the window left 1
17:18:23 <zachk> inkbottle, all students take calculus, or the order of the sign changes for trig functions as you go from quadrant to quadrant
17:18:34 <johnw> if you can define an F-Algebra that encodes the structure of your problem, then you could use the recursion-schemes library on it, as a catamorphism of a particular "inductive scheme" so to speak
17:18:39 <dyl> If I each the left end of the sequence and it produces a shift then it is also an error.
17:18:51 <johnw> you just need to give an instance of the Base type family which provides the view type
17:18:56 <dyl> I’m not remotely sure what that F-Algebra would be.
17:19:04 <johnw> a functor
17:19:06 <zachk> i forget the exact details, but quadrant 1 was sin cos and tan , quadrant 2 was just sin, quadrant 3 was tan, and quadrant 4 was cos
17:19:09 <dyl> I know that.
17:19:16 <dyl> I mean I don’t know what it would look like structurally.
17:19:17 <johnw> a functor that encodes one step of your reduction
17:19:24 <dyl> What I’m implementing is a form of pairwise syntactic analysis.
17:19:31 <dyl> Hmm
17:19:33 <johnw> data Step r l c r = HaveMore r l c r | AtEnd r l c
17:19:39 <johnw> dunno how it should look
17:19:49 <johnw> but find a type that says exactly what your two conditions are
17:20:00 <johnw> then see if you can cast that as a base functor for your actual recursive type
17:20:08 <dyl> Well it’s not quite two conditions.
17:20:18 <dyl> But that makes sense.
17:20:30 <johnw> in Coq this would just be called a recursion scheme
17:20:36 <johnw> sorry, an induction scheme
17:20:43 <johnw> but in Haskell we encode it with types
17:20:50 <dyl> I mentioned recursion schemes because they seemed the right approach
17:20:51 <inkbottle> zachk: that first attempt was really a mess; but it was mostly a first encounter with images
17:21:00 <dyl> But I’m not sure if zippers over Vector might be easier.
17:21:09 <dyl> This is line by line so the token count is never too high.
17:21:11 <johnw> yeah, since recursion schemes divide data representation from recursion, you just need a custom type to "split" the two aspects in the right way
17:21:23 <dyl> Okay, I’ll think about it and come back.
17:21:31 <johnw> but yeah, zippers is another approach
17:21:40 <johnw> i don't think they come with a recursion principle though
17:22:07 <zachk> inkbottle, if you don't need to process images just display them, gloss and gloss-devil I think might be nice for you, has easy image manipulation and is 2d opengl
17:22:13 <dyl> It’s pretty much a series of scans from the right, so I want to avoid rebuilding everything every time.
17:22:26 <dyl> Each scan continues until the binding power between l and c is less than c and r
17:22:31 <dyl> And then reduces c and r
17:22:42 <dyl> Otherwise, I shift, unless the powers are equal and also zero (or Nothing)
17:22:47 <dyl> In which case it’s an error
17:23:22 <dyl> I have a pair of tables encoded as power :: a -> a -> Int (or Maybe Int, though I use 0)
17:23:35 <dyl> And reduce :: a -> a -> a
17:24:07 <dyl> a here is an instance of PairwiseReducible and such a type represents the head of a constructor for some ADT representing tokens/AST
17:24:16 <dyl> It’s a grammar consisting entirely of operators.
17:24:22 <dyl> Zero means does not bind.
17:24:46 <dyl> Literal numbers are considered nilary operators.
17:25:20 <dyl> The goal is to build a binary AST of the bindings of operators for evaluation.
17:25:24 <dyl> (Its APL.)
17:25:41 <dyl> (But it’s all in emoji, though that’s disjoint from this problem.)
17:26:08 <dyl> There are some weird cases such as a numeric literal and numeric literal binding with maximum strength to form strand notation for a vector.
17:27:07 <dyl> e.g. 1 2 x 3 4 ⇒ 1 2 x (3 4) ⇒ (1 2) x (3 4) ⇒ (1 2) (x (3 4) ⇒ ((1 2) (x (3 4)))
17:27:20 <inkbottle> zachk: it's definitely to process them; I'll sure will do better next time; rotation matrices seem a good idea, and generally speaking matrices seem a good idea
17:27:47 <zachk> inkbottle, nice work overall
17:27:52 <dyl> I’ve been leaning towards zippers as it seems like it might be easier to plumb errors that way.
17:27:57 <zachk> the code was decent
17:28:23 <inkbottle> zachk: thanks a lot ;-)
17:28:32 <zachk> dyl, are you inspired to write Ayypl from emojicode?
17:28:52 <inkbottle> zachk: I really thought it was a mess
17:28:53 <dyl> No.
17:29:10 <dyl> Dirty Algol syntax has no place in the future of emoji based programming :p
17:29:16 <dyl> (I jest)
17:29:20 <zachk> inkbottle, the very bottom of it looked messy other then that it was quite readable
17:29:26 <zachk> dyl, :)
17:29:31 <dyl> I was actually inspired by previously considering an emoji based malbolge
17:29:42 <dyl> But I decided APL would be more fun.
17:29:52 <dyl> And actually useful in some twisted way.
17:30:26 <dyl> AyyPL will be superior to Emojicode.
17:30:49 <dyl> :p
17:31:07 <CodeKiwi> and just think if you imessage people your programs you'll be helping detect the bugs that crash iphones!
17:31:49 <dyl> And useful programs can fit in a single tweet.
17:32:22 <dyl> It’s been a very interesting dumb project to pursue. Lots of interesting papers.
17:32:23 <Welkin> only if it's apl
17:32:31 <dyl> It is APP.
17:32:31 <Welkin> lol
17:32:33 <dyl> APL*
17:32:36 <Welkin> AAPL?
17:32:54 <CodeKiwi> AGPL
17:32:55 <dyl> I’m basing it on Rationalized APL for the most part.
17:32:59 <dyl> AyyPL*
17:33:01 <dyl> 👽
17:33:31 <Welkin> alien apples?
17:33:34 <dyl> ... /usr/bin/👽
17:34:03 <Welkin> sub-typed homesick alien?
17:52:14 <hexfive> if i have an "f :: (Some a) => a -> b", and an "e :: (Some a, Some b) => Either a b", is it possible to make a version of either like "both :: (Some a, Some c, Some d) => (a -> b) -> Either c d -> b" ?
17:52:35 <hexfive> not sure if this is even something that should be done if it can be :\
17:53:59 <hexfive> ideally it would work for any constraint, not just Some. i think constraintkinds is sort of what i'm looking for? still a relative beginner though so i'm unsure :)
17:54:06 <fishythefish> hexfive: can you give an example of such an f?
17:55:08 <fishythefish> or do you mean that b is a fixed type throughout, not a type variable?
17:55:31 <hexfive> contrived example: "f :: Maybe a -> Bool , f (Just _) = True"
17:56:07 <hexfive> the idea is that b is a fixed type (though the construct should work forall b)
17:56:19 <fishythefish> if it's a fixed type, then don't use a type variable for it; let's call it B instead
17:56:31 <hexfive> ah, but it should work for all bs
17:56:58 <fishythefish> this whole thing should work for any particular choice of B, but that's not what your type signature is saying
17:57:10 <hexfive> ?
17:57:15 <fishythefish> if `f :: Some a => a -> b`, then it needs to produce a value inhabiting every type b
17:57:28 <hexfive> right
17:57:47 <fishythefish> this is almost certainly not what you want
17:58:07 <fishythefish> the only values inhabiting every type are things like `undefined` and `error _`
17:58:25 <fishythefish> typically called "bottom"
17:59:58 <hexfive> im confused
18:00:01 <hexfive> gimme a sec
18:00:25 <lfairy> Can someone please upload something to Hackage? Just want to confirm that hackagebot is working correctly :)
18:01:24 <johnw> maybe edwardk will upload free :)
18:02:16 <edwardk> johnw is subtle =)
18:03:06 <johnw> just a little bit ;) next I'll forward you a twitch link of me imploring you
18:03:21 <Welkin> twitch plays hackage?
18:03:41 <edwardk> almost have the twitch stuff running on my machine, but this little 1.2 ghz or whatever macbook isn't really kitted out for it, so its groaning
18:05:03 <Welkin> yeah
18:05:09 <Welkin> you will need more cores for streaming
18:05:25 <Welkin> build a ryzen 7 machine
18:05:27 <Welkin> or threadripper
18:05:35 <johnw> core i9
18:05:40 <Welkin> AMD!
18:05:43 <johnw> INTEL!
18:05:56 <edwardk> time to go hackintosh
18:06:15 <Welkin> edwardk: have you tried gnome shell lately?
18:06:18 <johnw> I think I'm going NixOS for my next desktop
18:06:19 <Welkin> it's really good now
18:06:41 <johnw> i've literally been waiting for 7 years for Apple to come out with a desktop I want to actually buy
18:07:01 <johnw> too much Haskell to be compiled
18:07:22 <johnw> sadly, too many packages break with 8.4.2 for me to upgrade just yet :(
18:08:20 <johnw> the new Semigroup requirement is going to take some time
18:08:57 <johnw> peace
18:08:57 <acowley> johnw: I gave up waiting for Apple to make a desktop and now have a little NixOS machine with an okay GPU..
18:09:54 <acowley> johnw: The downside is the ability to fix/tweak every piece of software running on the thing.
18:11:18 <CodeKiwi> does edwardk dress in a crop top when he codes
18:11:31 <edwardk> only when the tips are flowing
18:12:29 <CodeKiwi> nice
18:13:19 <hexfive> fishythefish: https://repl.it/repls/LoneSuburbanDevicedriver
18:21:39 <fishythefish> hexfive: you can't do what you're asking, but I'm also not convinced that type signature is actually what you want
18:21:43 <fishythefish> what is the purpose of this function?
18:23:11 <hexfive> my use case is making an instance for a particular either of the typeclass both type variables are constrained by
18:23:18 <hexfive> so
18:23:30 <fishythefish> no, no, I mean, what would `both is e` actually do?
18:23:50 <hexfive> ?
18:24:00 <hexfive> that depends on the implementation / typeclass
18:24:27 <fishythefish> `either f g e` check if `e` is a `Left x` or a `Right y`. if it's the former, it produces `f x`; if it's the latter, it produces `g y`
18:24:33 <fishythefish> can you provide a similar description of `both`?
18:26:47 <fishythefish> do you really just want `both f = either f f`?
18:26:52 <hexfive> yep
18:27:22 <hexfive> im kinda scratching my head because it just seems like an edge case of either, but id like the helper for brevit when using either in point free style
18:27:39 <hexfive> s/brevit/brevity
18:27:39 <edwardk> giving up on getting the streaming stuff setup on this laptop. i have a resurrected "backup" laptop that has a lot more power i could switch to, though
18:29:33 <fishythefish> hexfive: okay, so now let's revisit your type signature. You want to produce a `b`, but the only way to get that is to produce an `a` and apply your `a -> b` to it. However, you have no `a`
18:29:47 <CodeKiwi> kickstarter to get edwardk a new computer so he can cam for us
18:30:58 <hexfive> fishythefish: i have an (x a) and a function that will go from (x a => a -> b)
18:31:15 <hexfive> is that not enough?
18:31:22 <fishythefish> hexfive: x a is not a value, it's a constraint
18:31:32 <hexfive> sry, x a => a
18:31:35 <fishythefish> saying that a implements the interface of X is not the same as having an a
18:31:46 <fishythefish> where is your (x a => a)?
18:31:57 <jasondockers> I asked someone for resources on learning haskell and they mentioned a book with a title similar to "principles of programming" that is "pretty recently released".. any idea what they may have been referring to?
18:32:30 <fishythefish> @where haskellbook
18:32:31 <lambdabot> http://haskellbook.com
18:32:35 <fishythefish> jasondockers: maybe that ^ ?
18:33:52 <jasondockers> fishythefish, thanks
18:33:53 <hexfive> fishythefish: i think im misunderstanding how typeclasses work, i've run into similar confusion before. would "hmm :: (x a, x b, x c) => Either a b -> c" be possible?
18:34:08 <jasondockers> fishythefish, yeah, that's likely it
18:34:09 <fishythefish> hexfive: again, no, there's nothing in there that allows you to produce a c
18:34:12 <hexfive> where "hmm (Left a) = a"
18:34:42 <jasondockers> 60 dollars?! dear lord
18:34:48 <hexfive> couldn't c be either an a or a b ?
18:35:01 <fishythefish> hexfive: sure, but it could also be any other type implementing X
18:35:19 <hexfive> does it need to be the same concrete type in all cases? i think this is my point of confusion
18:35:22 <jasondockers> how was "haskell programming from first principles" received by the community?
18:35:39 <Xal> it's pretty widely considered the best introduction to the language
18:35:54 <hexfive> oh
18:35:56 <hexfive> ohhh
18:35:57 <fishythefish> hexfive: whoever calls your function will get to choose what the type variables are specialized to
18:35:58 <hexfive> i get it now
18:36:02 <fishythefish> you don't get to do it in your definition
18:36:14 <Xal> if you absolutely don't want to pay, "real world haskell" and "learn you a haskell" are available online for free
18:36:30 <CodeKiwi> also the book on wikibooks
18:36:31 <hexfive> yeah because then, "f :: Int -> a ; f 1 = 0 ; f 3 = "hello"" would be possible
18:36:36 <CodeKiwi> https://en.wikibooks.org/wiki/Haskell
18:37:08 <Xal> have a taste of haskell from any of the above, but haskellbook convers many more modern topics and (IMO) gives you a better understanding of the language "from first principles"
18:37:20 <Xal>  the first chapter is free iirc so you can't really go wrong there
18:37:23 <CodeKiwi> and this http://dev.stephendiehl.com/hask/ and a bunch of other things...
18:37:50 <jasondockers> Thanks
18:38:03 <CodeKiwi> and ofc the haskell report
18:38:13 <fishythefish> jasondockers: this channel's opinion of that book varies throughout the day as different people log on
18:38:23 <fishythefish> plenty of people like it, but a fair number would advise you to consider hutton's book instead
18:38:36 <CodeKiwi> fishythefish isn't that the one that some people freaked out about some of the authors
18:38:40 <fishythefish> you're not gonna get a universally correct answer
18:38:43 <CodeKiwi> I love huttons book
18:39:03 <Xal> rule of thumb: whatever I say or think is universally correct while I'm around to hear it
18:39:12 <jasondockers> it takes until page 430 to write a factorial function?
18:39:15 <fishythefish> CodeKiwi: probably
18:39:16 <CodeKiwi> the craft of functional programming is nice too
18:39:31 <jasondockers> There are 2000 pages nearly, wow
18:39:48 <CodeKiwi> I don't think there's any one right book for anyone :|
18:40:04 <CodeKiwi> tho I haven't read the haskellbook.com one so meh
18:40:45 <CodeKiwi> there are so many books I won't ever read all of the books I want to :(
18:40:56 <Xal> the curse of every reader
18:41:33 <CodeKiwi> this is useful http://cheatsheet.codeslower.com/CheatSheet.pdf
18:42:31 <jasondockers> I want to read three books right now :'(
18:42:34 <CodeKiwi> there are easily hundreds of papers relevant to haskell alone
18:42:49 <jasondockers> four*
18:43:03 <jasondockers> wait, no. five books. anyway I'll stop spamming the channel
18:44:09 <CodeKiwi> those are rookie numbers
18:44:45 <Welkin> cookies
18:46:47 <CodeKiwi> jasondockers I liked the write yourself a scheme in 48 hours too and there's another one someone made that's a bit newer but not as in depth and that stephendiehl.com site has a few cool things too
18:47:14 <Xal> haskell really shine in writing compiler-like things
18:47:17 <Xal> shines*
18:48:09 <Xal> there is a downside to this
18:48:25 <Xal> if ever you go back to a language without sum types, you will be in a state of constant pain and suffering
18:48:36 <Xal> you have gazed into the abyss
18:50:22 <Welkin> Xal: that really depends
18:50:36 <Welkin> if you work with a language with no types, then it isn't big of a problem
18:50:42 <Welkin> for example, in lua, all you need is a table
18:50:49 <Welkin> pretty much the same story in javascript
18:51:12 <Welkin> although you have add-on type systems for js like Flow (Ocaml-like types) and typescript (kind of shitty, weird OO-style types)
18:51:18 <CodeKiwi> even I wouldn't write a compiler in lua
18:51:31 <Welkin> you have lpeg
18:51:39 <Welkin> lots of people write languages/DSLs in lua
18:52:32 <CodeKiwi> masochists
18:52:52 <Welkin> you can't exactly use haskell as a scripting language embedded in C
18:53:26 <Xal> you talk about dsls in an embedded language, but don't mention scheme? :P
18:53:39 <Welkin> sure
18:53:40 <jasondockers> Welkin, I mean, you could
18:53:41 <Welkin> chicbi scheme
18:53:44 <Welkin> chibi scheme
18:53:46 <Welkin> or chicken scheme
18:54:18 <Welkin> chicken scheme even has sdl bindings
18:54:25 <CodeKiwi> or chez or gambit or mit or plt or racket or or or
18:54:41 <CodeKiwi> I think there are more scheme implementations than people that use scheme
18:54:50 <Welkin> you can't embed all of those inside of C
18:54:59 <Welkin> chibi scheme is specially made to be embedded
18:55:04 <Welkin> chicken compiles to C
18:55:11 <CodeKiwi> so does gambit
18:55:41 <marvin3> typeless is even worse than no sum types.. it is like saying you don't like burned finger so here's scortched earth instead
18:55:56 <Welkin> marvin3: it's really not
18:56:03 <Welkin> types don't make or break programming
18:56:09 <CodeKiwi> and I think chez does too...
18:56:15 <jasondockers> they just make it easier
18:56:31 <Welkin> sometimes, given the type system, it can make certain things impossible
18:56:41 <Welkin> like heterogenous arrays
18:56:48 <jasondockers> Welkin, what's that
18:56:57 <Welkin> there is always a trade-off
18:57:06 <Welkin> but yes, geenrally type systems give more benefits than downsides
18:58:41 <Welkin> for a rectangle, I need position and size
18:58:54 <Welkin> to draw a texture, I need the texture, the quad, and the position
18:59:39 <Welkin> as opposed to just a single pre-defined render function
18:59:56 <Welkin> wrong channel
19:02:16 <crestfallen> hi anyone help me get rid of this warning message? http://lpaste.net/365218
19:02:48 <CodeKiwi> jasondockers in lua you could have this table {foo = "bar"; baz = 1; high = low} everything in it is a different type
19:04:27 <acowley> crestfallen: You need to indent the lines beginning with `show`
19:04:54 <Welkin> so you get row polymorphism, heterogenous containers, optional parameters, default parameters for free
19:04:59 <CodeKiwi> in this isolated case low is actually nil but if it was defined outside of there it could be a reference to something else
19:05:02 <Welkin> it's a very different way of programming than haskell
19:05:07 <Welkin> but it's also quite powerful
19:05:30 <Welkin> very much like the lisp/scheme way of doing things
19:05:40 <CodeKiwi> lua actually has a fair amount of utility for functional programming
19:05:45 <Welkin> it has tco
19:05:49 <Welkin> and built-in coroutines
19:05:52 <Welkin> and metatables, so yeah
19:06:01 <CodeKiwi> it's also influenced a lot by scheme so it makes sense
19:06:13 <CodeKiwi> proper lexical scoping etc.
19:07:25 <CodeKiwi> there's even a hs-lua thing! :P
19:11:04 <iqubic> Does haskell have lexical scoping?
19:11:06 <crestfallen> acowley, thanks usually that's a tab warning or similar right?
19:13:00 <Welkin> iqubic: of course
19:13:01 <acowley> crestfallen: It's a bit tricky in this case. What you've done is defined your own function called `show`. The warnings you might get are for an under-defined instance (like what you got), a missing type signature on your accidental `show` function, and shadowing the name from Prelude.
19:13:17 <acowley> crestfallen: But no errors!
19:13:37 <crestfallen> shadowing , hmm, thanks. its a book example acowley
19:14:07 <CodeKiwi> iqubic there are several fairly widespread languages without good scoping
19:14:41 <acowley> crestfallen: It's all perfectly fine, but getting indentation wrong in Haskell will often lead to surprises. It's something you always have to watch out for.
19:15:09 <acowley> It's another reason Haskellers are fond of having warnings enabled
19:16:49 <Welkin> javascript does not have lexical scoping before es6
19:17:02 <Welkin> the `var` keyword is not lexically scoped
19:17:20 <Welkin> so it can leak into the outer scope
19:17:40 <Welkin> C89 for-loop values are also not lexically scoped
19:17:44 <CodeKiwi> I'd guess the list of languages that do things right is probably longer than the list that do it wrong, so it's quite unfortunate that some of the most popular ones are so crapy :|
19:18:01 <Welkin> luckily no one uses C89
19:19:11 <iqubic> Does haskell do the right thing?
19:19:27 <Welkin> yes
19:19:36 <CodeKiwi> cough lua is c89 cough
19:27:08 <crestfallen> acowley, thanks. hey also what is this brak term in last where statement? why is that used?
19:27:13 <crestfallen> https://ptpb.pw/rFbE
19:27:41 <crestfallen> ie why was it named that?
19:28:09 <acowley> bracket
19:28:37 <crestfallen> got it thanks
19:36:42 * hackage hvega 0.1.0.0 - Create Vega and Vega-Lite visualizations.  http://hackage.haskell.org/package/hvega-0.1.0.0 (DouglasBurke)
20:53:42 * hackage incremental-parser 0.2.5.4 - Generic parser library capable of providing partial results from partial input.  http://hackage.haskell.org/package/incremental-parser-0.2.5.4 (MarioBlazevic)
21:00:12 * hackage incremental-parser 0.3 - Generic parser library capable of providing partial results from partial input.  http://hackage.haskell.org/package/incremental-parser-0.3 (MarioBlazevic)
21:26:57 <dsal> When I ask emacs to load a file outside of a project... what does it do?  I'm kind of surprised that I don't have quickcheck in my repl.
21:28:48 <dsal> Oh, it appears to be 'cabal repl'
21:39:10 <dmj`> dsal: that’s  configurable
21:39:39 <dsal> i assume so.  I was just confused because 'ghci' and 'stack ghci' both did what I expected.
21:40:10 <MarcelineVQ> stack ghci won't always do what you expect, but stack exec ghco should
21:40:12 <MarcelineVQ> *ghci
21:40:47 <MarcelineVQ> depending on your expecations I suppose :>
22:19:29 <enterprisey> So I have a record type with two fields and its lenses; how can I use the lenses to get a tuple of the two fields?
22:21:47 <cocreature> enterprisey: https://hackage.haskell.org/package/lens-4.16.1/docs/Control-Lens-Unsound.html#v:lensProduct not the warning in the docs
22:21:54 <enterprisey> wonderful, ty
22:25:17 <dpyro> if i have a newtype HexStringN (n :: Nat) = HexStringN HexString, how do i access that n typelit in a smart constructor I make for HexStringN?
22:25:51 <cocreature> dpyro: add a KnownNat constraint and use natVal
22:26:04 <dpyro> i know some of those words!
22:32:27 <CodeKiwi> edwardk I just watched a talk of yours; sehr gut!!
22:34:02 <CodeKiwi> bitemyapp I watched a talk of yours too it was good. don't listen to anyone that says you're not nice (they're probably right but don't listen to them ;) )
22:36:15 <alp> dpyro, https://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-TypeLits.html#g:2 see 'natVal' there. If you give it, say a 'Proxy n' for some n :: Nat, it gives you back the Integer value that corresponds to that type-level natural number
22:36:49 <dpyro> oh, so proxy lets you proxy a type variable into a normal value?
22:37:47 <dminuoso> dpyro: a proxy is just an old trick for explicit type application.
22:37:57 <alp> it gives you a way to have values that "point to" types.
22:38:10 <dminuoso> dpyro: That is, if you understand TypeApplications, then you understand the point of proxy.
22:39:05 <dpyro> ok, well now i have something to study in the next few hours, thanks 😃
22:39:26 <alp> data Proxy (t :: k) = Proxy -- given a type t of kind k, there's only one (non bottom) value of type 'Proxy t'. so it's effectively a way to refer to the type 't' through a value :)
22:39:38 <dminuoso> dpyro: The rational is rather simple.
22:39:41 <dminuoso> Lets say you have some
22:39:43 <dminuoso> :t fmap
22:39:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:40:10 <dminuoso> And you simply want to use `fmap` and specify what `f` is, but you dont want to specify a full type signature..
22:42:40 <dpyro> 🤔
22:43:18 <dpyro> why would you need to specify a type signature in the first place?
22:43:33 <dpyro> i assume the 1st function parameter would parameterize it
22:47:42 * hackage type-natural 0.8.1.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.8.1.0 (HiromiIshii)
23:23:42 * hackage hpc-threshold 0.1.0.1 - Configurable code coverage threshold for Haskell  http://hackage.haskell.org/package/hpc-threshold-0.1.0.1 (eckyputrady)
23:25:50 <dminuoso> dpyro: Take `read` for example.
23:26:29 <dminuoso> So any universally quantified type, like read's type, can be thought of an abstraction over a type variable.
23:26:35 <dminuoso> :t read
23:26:36 <lambdabot> Read a => String -> a
23:26:47 <dminuoso> more explicitly: read :: forall a. Read a => String -> a
23:27:45 <dminuoso> dpyro: The type itself can be be thought of a function taking one type parameter, named `a`
23:32:25 <dminuoso> dpyro: Internally read even needs a type parameter. So you'd have to do something like `read @Int "foo"`. GHC just does this @Int passing for you behind the scenes.
23:33:52 <dminuoso> dpyro: So the thing is, at some point type inference might not be able to infer the types that have to go there. Normally you'd then have to fling around enough full type signatures to guide GHC, but it might be annoying to specify full type signatures for complicated functions.
23:33:57 <dminuoso> Especially if all you intend to say is
23:34:00 <dminuoso> :t fmap
23:34:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:34:17 <dminuoso> ^- "I just want to specify f to be Maybe, I dont want to talk about the rest"
23:35:21 <dminuoso> % > let n = pure 1 in fmap @[] (+1) n
23:35:22 <yahb> dminuoso: ; <interactive>:22:1: error: parse error on input `>'
23:35:59 <dminuoso> % let n = pure 1 in fmap @[] (+1) n
23:35:59 <yahb> dminuoso: [2]
23:36:02 <dminuoso> % let n = pure 1 in fmap @Maybe (+1) n
23:36:03 <yahb> dminuoso: Just 2
23:36:05 <dminuoso> % let n = pure 1 in fmap @Either (+1) n
23:36:06 <yahb> dminuoso: ; <interactive>:27:25: error:; * Expecting one more argument to `Either'; Expected kind `* -> *', but `Either' has kind `* -> * -> *'; * In the type `Either'; In the expression: fmap @Either (+ 1) n; In the expression: let n = pure 1 in fmap @Either (+ 1) n
23:36:35 <dminuoso> % let n = pure 1 in fmap @(Either String) (+1) n
23:36:35 <yahb> dminuoso: Right 2
23:36:40 <dminuoso> dpyro: Hope you get the idea here.
23:36:49 <mniip> you can say @(Either _)
