00:14:29 <ertes-w> hllo
00:15:59 <osa1> we don't have anything in base to get hex/bin representation of integrals and float/double, right?
00:22:17 <mlehmk> osal: https://www.google.de/search?q=haskell+show+hexadecimal
00:22:20 <cocreature> osa1: for integrals there is showIntAtBase
00:25:32 <osa1> > showIntAtBase 10 chr 33 ""
00:25:34 <lambdabot>  "\ETX\ETX"
00:25:37 <osa1> how do I use it?
00:27:12 <cocreature> > showIntAtBase 10 intToDigit 33 ""
00:27:14 <lambdabot>  "33"
00:27:18 <cocreature> > showIntAtBase 10 intToDigit 16 ""
00:27:20 <lambdabot>  "16"
00:27:25 <cocreature> > showIntAtBase 16 intToDigit 33 ""
00:27:27 <lambdabot>  "21"
00:27:33 <osa1> > showIntAtBase 16 intToDigit 33 ""
00:27:35 <lambdabot>  "21"
00:31:13 * hackage warp 3.2.20 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.2.20 (KazuYamamoto)
01:12:36 <dpyro> dminuoso: now i see the usefulness of quantifying just one type
01:12:45 <dpyro> i've been in situations where i wanted to do something akin to that
01:12:47 <dpyro> many thanks!
01:15:01 <dminuoso> dpyro: *deciding on a universally quantified type.
01:20:40 <dminuoso> dpyro: An interesting example of where Proxy can be useful is this
01:20:44 <dminuoso> :t Data.Bits.finiteBitSize
01:20:45 <lambdabot> FiniteBits b => b -> Int
01:21:41 <dminuoso> dpyro: So essentially this is the Haskell version of C/C++ `sizeof` - you don't actually need a value, that's just a historical artifact.
01:23:24 <tdammers> > printf "%04x" 33 -- wonder if that works
01:23:26 <lambdabot>  error:
01:23:26 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M416326296667...
01:23:26 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
01:23:32 <tdammers> oh, right
01:23:39 <tdammers> > printf "%04x" 33 :: String -- wonder if that works
01:23:41 <lambdabot>  "0021"
01:23:44 <tdammers> yay
01:23:47 <dminuoso> dpyro: A slightly more modern version would have a signature like: `FiniteBits b => proxy b -> Int`, so that you could do: `finiteBitSize (Proxy :: Proxy Float)` which would be the kind of equivalent of `sizeof float` if you want. That proxy has the sole purpose of somehow passing a type through the value system. =)
01:24:09 <dminuoso> dpyro: And a better version would use type applications directly, so you could use `finiteBitSize @Float`
01:24:50 <dpyro> so with Proxy you never have to construct an actual value then?
01:25:08 <dminuoso> dpyro: Right. You just want to somehow pass a reified type.
01:25:09 <dpyro> what would be the type signature of your last version of finiteBitSize?
01:30:15 <setre> how can I modify a htmml document to replace relative img urls with absolute ones?
01:30:20 <setre> *html
01:32:36 <dminuoso> dpyro: forall b. FiniteBits b => String
01:33:43 <dminuoso> dpyro: a somewhat silly example: https://gist.github.com/dminuoso/676ce3865f6ddbb2c3ab4ac22b7cf159
01:33:53 <dminuoso> dpyro: So you just go `showType @Int` and you get "Int" back
01:35:03 <dpyro> the example is really helpful actually, thanks
01:35:17 <dpyro> 😊
02:09:05 <rightfold> What should the argument passed to the -xq RTS flag look like? No matter what argument I pass, it says it's outside of the allowable range.
02:09:11 <cocreature> is there some simple library that provides zippers for binary trees?
02:09:29 <rightfold> The documentation doesn't say whether it should be in bytes or kibibytes, or whether a unit name may appear, etc
02:10:29 <Franciman> Is there a way to use pipes in a push-based way?
02:10:42 <Franciman> so that the consumer runs its logic only when it receives a new value?
02:12:09 <rightfold> Oh, it should be passed without a space
02:13:58 <Taneb> cocreature: I don't know of any but I'm trying to work out what that would look like...
02:14:09 <Taneb> ([(a, BTree a)], BTree a)?
02:14:36 <Boarders> Does anyone know if it is possible to have a function: Tagged s a -> s a?
02:14:43 <cocreature> Taneb: I want with https://gist.github.com/cocreature/c715e06ba286482a8b7d019c2401ad1c
02:14:47 <cocreature> *went
02:14:51 <Boarders> where :k s :: * -> *
02:15:08 <Taneb> cocreature: oh yeah, that has the advantage over mine in that it actually works ;)
02:15:26 <cocreature> Taneb: who needs working code anyway :)
02:15:50 <Taneb> Boarders: I don't believe it is
02:15:58 <cocreature> Boarders: that doesn’t make sense where do you get the value from?
02:16:08 <Taneb> Consider Tagged () :: Tagged VoidF () where data VoidF
02:16:09 <Boarders> yeah fair enough
02:16:15 <Taneb> *data VoidF a
02:16:34 <Taneb> There are values of Tagged VoidF () (like Tagged ()) but none of VoidF ()
02:17:35 <Taneb> However it possible if there's an Applicative (or even a Pointed) constraint on s, in which case it's pure . unTagged
03:33:42 * hackage ihaskell-hvega 0.1.0.0 - IHaskell display instance for hvega types.  http://hackage.haskell.org/package/ihaskell-hvega-0.1.0.0 (DouglasBurke)
03:54:42 * hackage sorted-list 0.2.1.0 - Type-enforced sorted lists and related functions.  http://hackage.haskell.org/package/sorted-list-0.2.1.0 (DanielDiaz)
03:57:12 * hackage web3 0.7.0.0 - Ethereum API for Haskell  http://hackage.haskell.org/package/web3-0.7.0.0 (akru)
03:58:42 * hackage csound-expression-dynamic 0.3.3 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.3.3 (AntonKholomiov)
03:59:42 * hackage csound-expression-typed 0.2.2.0 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.2.2.0 (AntonKholomiov)
04:00:43 * hackage csound-expression 5.3.2 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-5.3.2 (AntonKholomiov)
04:01:42 * hackage csound-sampler 0.0.9.0 - A musical sampler based on Csound  http://hackage.haskell.org/package/csound-sampler-0.0.9.0 (AntonKholomiov)
04:03:42 * hackage csound-catalog 0.7.2 - a gallery of Csound instruments.  http://hackage.haskell.org/package/csound-catalog-0.7.2 (AntonKholomiov)
04:16:41 <zincy> Is it good practice for modules to require the consumer to call the exposed function with types from inside the module? Or should the module parse simpler args into its own internal types?
04:17:12 <merijn> zincy: I don't know what you mean by that?
04:18:00 <Ariakenom> As a general note, if you need more precise types you should define more precise types.
04:22:14 <zincy> merijn - Should the exposed function of a module accept arguments comprised of its own internal types?
04:22:44 <zincy> merijn - As this would require other modules that import the said function to also import its types?
04:22:50 <zincy> I feel like this may be too coupled
04:26:20 <gentauro> wow, yesterday I learned never to use "records" in Sum Types :o
04:26:31 <lavalike> why is that?
04:26:47 <gentauro> data Names = FooBar { foo :: Int, bar :: Char } | Baz String | Qux
04:27:12 <gentauro> because you can do this => foo Qux (it compiles, but crashes on runtime) :o
04:27:16 <gentauro> I didn't knew that !!!
04:27:27 <gentauro> why is this even allowed in Haskell?
04:27:31 <maerwald> write a getter with Maybe
04:27:40 <maerwald> why not
04:28:00 <maerwald> haskell is not a total language
04:28:03 <lavalike> haha foo :: Names -> Int is not complete
04:28:33 <gentauro> the code should be using "the curried tuple syntax" => data Names = FooBar Int Char | Baz String | Qux
04:29:17 <maerwald> then you don't have foo and bar
04:29:21 <merijn> gentauro: Pretty sure -Wall warns you about that
04:29:22 <gentauro> jep
04:29:27 <gentauro> merijn: no
04:29:34 <gentauro> and it's dissapointing
04:29:37 <maerwald> a warning would be odd
04:29:38 <merijn> No? hmm
04:29:40 <gentauro> speacially when you are showcasing code
04:29:51 <gentauro> there are always somebody who know a bit more of Haskell than you :)
04:29:55 <maerwald> then it should warn about any non-total function
04:30:25 <capisce> I haven't seen anyone use records in sum types before, I guess for this exact reason
04:30:27 <tsahyt> I'd use FooBar Int Char, and recover foo and bar as functions returning Maybe Int and Maybe Char respectively
04:30:42 <maerwald> capisce: I have
04:30:45 <ertes-w> i use record sum types
04:30:47 <maerwald> and it's fine
04:30:48 <gentauro> maerwald: is there a flag for that? I normall use "-Wall -Werror"
04:30:58 <maerwald> gentauro: for what
04:31:00 <capisce> maerwald: seems error-prone
04:31:02 <ertes-w> and i wouldn't want that warning either…  i would disable it
04:31:09 <maerwald> capisce: programming is error prone
04:31:13 <tsahyt> ertes-w: do you do anything to prevent the case where you're accessing a field that doesn't exist?
04:31:18 <gentauro> and that catches most stuff. The "Weverything" is not an option as it shows to much stuff
04:31:24 <ertes-w> tsahyt: statically?  no
04:31:29 <capisce> some programming is more error prone than other programming
04:31:35 <gentauro> which mostly I can't do anything about since most Haskell packages are "Trustworthy"
04:31:45 <ertes-w> tsahyt: well, my coding style prevents it:  i use those field names only in pattern-matching and construction
04:31:59 <maerwald> capisce: and some programming is still correct, no matter if someone considers it error prone ;)
04:32:00 <capisce> but if you keep it contained instead of offering it as a public API I guess there could be use cases where it's convenient
04:32:10 <tsahyt> ertes-w: I shy away from it because I don't trust myself to not screw it up
04:32:13 <ertes-w> so i never run into the partiality issue
04:32:30 <Guest25083> why this code http://lpaste.net/365227 gives error `Multiple declarations of ‘c’`?
04:32:31 <maerwald> capisce: even as public API it may be fine
04:32:32 <gentauro> do anybody know if there is a "flag" to catch this?
04:32:32 <maerwald> it depends
04:32:43 <gentauro> I mean, I wouldn't want to do it again ;)
04:32:47 <ertes-w> gentauro: just don't do it
04:32:54 <ertes-w> … if you feel that unsafe about it
04:32:59 <gentauro> like I said "pretty embarrassing" :D
04:33:14 <capisce> maerwald: seems like inviting pain
04:33:23 <maerwald> capisce: why?
04:33:29 <maerwald> that's an over-generalization that's not useful
04:33:57 <tdammers> avoiding partial functions is generally considered a good idea, all else being equal
04:33:59 <gentauro> ertes-w: yes, and as a human I might forget it. That's why I want it as a "new flag" so if I forget, I get punished by the compiler ;)
04:34:01 <lemmih> Guest25083: Because you declared 'c' twice. Once on line 2 and again on line 8.
04:34:17 <tsahyt> using lens alleviates the partiality problem though
04:34:19 <maerwald> tdammers: wrapping everything in Maybe in internal API is just dumb
04:34:26 <ertes-w> gentauro: you could post a feature request for GHC
04:34:31 <tsahyt> using makeLenses on a record sum types generates traversals
04:34:38 <Guest25083> lemmih : in other languages like c I can do like this,
04:34:45 <tdammers> who says wrapping everything in Maybe is the only alternative?
04:35:00 <lemmih> Guest25083: Haskell is not like C.
04:35:09 <maerwald> head is fine, people should stop whining about it
04:35:18 <maerwald> haskell is not a total language
04:35:30 <maerwald> if you use it wrong, your program will crash, yes
04:35:32 <gentauro> "totally" agree :P
04:35:33 <Guest25083> lemmih : so two data object cant have  the same member name?
04:35:41 <lemmih> Guest25083: Nope.
04:35:56 <gentauro> Guest25083: Nah, Haskell is very "Hungarian notation" in a way
04:36:08 <Guest25083> lemmih : is there is reason this is like this?
04:36:09 <capisce> not everyone reads the documentation, the best APIs are self documenting
04:36:18 <ertes-w> Guest25083: history
04:36:27 <maerwald> capisce: how do exceptions document themselves?
04:36:38 <tdammers> head is most definitely not fine, mostly because there's really hardly ever a reason to use it
04:36:48 <Guest25083> ertes-w: can you please elaborate
04:36:54 <maerwald> over-generalization
04:36:56 <marvin3> head is pretty horrible. and there's seldom a reason to use
04:37:00 <marvin3> it
04:37:06 <gentauro> tdammers: why not use list that warranties that there always is an element?
04:37:35 <tdammers> gentauro: if that is actually an invariant, then yes, otherwise no
04:37:41 <ertes-w> Guest25083: for the most part we still have the original record system, and people can't really agree on how to fix the field name issue
04:37:53 <tdammers> and if it is an invariant, then you can write a nonEmptyHead :: NonEmptyList a -> a
04:37:54 <gentauro> Data.List.NonEmpty
04:38:06 <capisce> if your API provides payload :: Packet -> Data then people will probably assume they can use it without first having to call hasPayload
04:38:11 <marvin3> head is acceptable when you can't easily replace it with pattern matching and when you are 100% sure your list has at least one element. those situations are rare
04:38:12 <tdammers> and if it's not, then you really need to be prepared for the empty list case
04:38:28 <Ariakenom> I use head$do{...} for searches with List.
04:38:43 <tdammers> marvin3: when you are 100% sure your list has at least one element, you should probably be using a different data structure
04:38:56 <tdammers> Ariakenom: what if your search yields no results?
04:38:57 <ertes-w> Guest25083: in a language like haskell that heavily relies on type inference, disambiguating field names is surprisingly difficult
04:39:09 <merijn> tdammers: Often that's a lot of annoying bookkeeping since all your APIs tend to work on lists
04:39:22 <marvin3> tdammers, some functions guarantee they will return a list with at least one element
04:39:28 <Ariakenom> tdammers: boom. some logic error, non recoverable.
04:39:55 <Guest25083> ertes-w : thanks
04:40:03 <Ariakenom> usually one off affairs though
04:42:30 <tdammers> marvin3: then arguably, those functions should not return a plain old list
04:42:36 <tdammers> marvin3: bake the guarantee into the types
04:43:53 <maerwald> that's just annoying for internal API
04:45:01 <boxscape> in idris, you can write something like "data Vect : Nat -> Type -> Type where". Can you do this in Haskell? When I try to write "data Vect :: Nat -> * -> *", ghc thinks I'm talking about the multiply operator.
04:45:06 <maerwald> that's just for people too lazy to read documentation (and that bites them when it comes to IO)
04:45:26 <merijn> boxscape: Enable KindSignatures
04:45:39 <boxscape> merijn: I have
04:45:52 <boxscape> (Also I forgot a "where" at the end of that haskell code, which I also have in my file)
04:45:54 <merijn> hmm, that's odd. Do you have TypeInType enabled?
04:46:11 <boxscape> ah, yes, I had it enabled. Disabling it makes it work. Thanks
04:47:22 <marvin3> tdammers, there are functions like that in prelude too. group returns [[a]], not [Data.List.NonEmpty a]
04:50:53 <merijn> Is there a generic "tree" diff library?
04:55:53 <merijn> Specifically, I don't care about being able to apply a diff, I just want to be able to easily visualise difference between two large, but mostly similar datatypes
04:57:55 <cocreature> merijn: tree-diff?
04:58:21 <cocreature> at least that’s what I’m using for test suites and I’m quite happy with it
04:59:37 <ertes-w> tdammers: for many searches it's infeasible to prove within haskell that there is at least one result
05:00:12 <ertes-w> 'head' is an easy way to resolve the dilemma: "i know there is at least one result, but i don't want to prove it"
05:04:24 <boxscape> there was a proposal as a github issue on (I think) April 1st to replace :: with :, does anyone have the link to that?
05:04:52 <cocreature> boxscape: Set.fromList
05:04:56 <cocreature> ahrg
05:04:59 <cocreature> boxscape: https://github.com/ghc-proposals/ghc-proposals/pull/118
05:05:02 <boxscape> thanks
05:05:20 <cocreature> I guess I could have had more embarassing things in my clipboard than Set.fromList :)
05:05:28 <boxscape> true
05:09:13 * hackage hs-multiaddr 0.1.4 - Multiaddr library  http://hackage.haskell.org/package/hs-multiaddr-0.1.4 (CMCDragonkai)
05:09:40 <merijn> cocreature: All that PHP code you're secretly working on? ;)
05:10:51 <merijn> cocreature: Also, as new-build user: Do you think new-build should more aggressively cache local packages? Right now any change in config (such as --ghc-option) will trigger a rebuild of all local packages
05:11:48 <merijn> cocreature: I'm looking into making it more like my patch for non-local dependencies (i.e. flag changes that don't change output won't trigger a rebuild). OTOH, that also means that adding warning flags won't trigger rebuilds either
05:12:35 <cocreature> merijn: it would certainly be nice if it was better at catching things but it’s admittedly not something that has been particularly problematic for me
05:12:48 <cocreature> also it is kind of nice to get rebuilds for warning flags
05:12:56 <cocreature> there is a reason you enable those flags after all
05:14:28 <zincy> What is a  non-type variabe argument?
05:14:47 <merijn> cocreature: Well, one of the reasons I'm doing this is because I have a prototype project to highlight warnings/errors in vim with new-build (so like hdevtools, ghc-mod, etc.) but that specifies some flags to cabal, so each time I run "new-build" or that tool I end up rebuilding all local packages due to the change :p
05:15:26 <merijn> cocreature: Plus, if you specify -Werror it should force rebuilding for warning flag changes, so locally it shouldn't affect things too much
05:16:01 <cocreature> merijn: given that GHC itself also doesn’t rebuild if you just change warning flags iirc it probably makes sense to do the same in cabal
05:20:39 <CodeKiwi> merijn would vimdiff work for what you want?
05:21:31 <cocreature> CodeKiwi: how does vimdiff help you with seeing ghc errors?
05:22:21 <merijn> cocreature: I think he was replying to my generic diff question, although it doesn't make sense as suggestion for that either
05:22:26 <CodeKiwi> ^
05:22:35 <cocreature> ah it does at least make slightly more sense for that :)
05:22:53 <CodeKiwi> do not question my inanity
05:24:40 <CodeKiwi> and yeah I don't know the circumstance of what merijn needed to diff if needed an actual library for something or just needed to view something himself for something and not everyone knows vimdiff :P
05:25:24 <CodeKiwi> https://www.xkcd.com/1053/
05:26:42 * hackage hpc-threshold 0.1.0.2 - Ensure the code coverage is above configured thresholds  http://hackage.haskell.org/package/hpc-threshold-0.1.0.2 (eckyputrady)
05:27:01 <merijn> CodeKiwi: I have a huge complicated Haskell data structure and I'm trying to compare it, so text based diff introduces too much noise
05:27:37 <cocreature> merijn: just use tree-diff ;)
05:27:42 <merijn> cocreature: I am right now
05:27:53 <merijn> Or rather, I'm adding 15 billion ToExpr instances so I can try to :p
05:28:06 <cocreature> at least they’re derivable if you have Generic instances :)
05:28:51 <merijn> cocreature: Yeah, I'm mostly just declaring empty orphans
05:28:57 <merijn> but ShortByteString is screwing me over
05:29:11 <merijn> I guess I should complain to phadej about a missing instance :p
05:29:23 <cocreature> or be nice and make a PR :)
05:30:13 <CodeKiwi> merijn oic
05:35:13 * hackage hpc-threshold 0.1.0.3 - Ensure the code coverage is above configured thresholds  http://hackage.haskell.org/package/hpc-threshold-0.1.0.3 (eckyputrady)
05:38:25 <merijn> cocreature: bleh, I wish it'd just recursively derive instance for all Generic instance instead of telling me 1 compile failure at a time >.>
05:39:38 <maerwald> do we have a knowledgebase for design patterns? I'm thinking of something like this http://dev.stephendiehl.com/hask/ which is less focused on concepts and features, but on ways to express a certain problem
05:44:36 <ddellacosta> maerwald: I haven't seen such a thing but it occurs to me that stuff like this would be a good addition too: http://dev.stephendiehl.com/types_behavior.pdf
05:45:06 <lseactuary> can someone help me on this logic please? http://lpaste.net/7812450841754861568
05:45:24 <lseactuary> my code works, but basically once you select again, it errors out / the process stops and im not sure why.
05:46:11 <merijn> lseactuary: That...does not look like haskell
05:46:28 <ddellacosta> oh man I had the same thought...haha
05:46:44 <ddellacosta> I'm impressed
05:47:25 <merijn> It looks like it might parse as Haskell, but tbh if you want people to invest time and help you might wanna clean that code up and make it more readable first
05:47:56 <Ariakenom> Pretty sure it's not Haskell.
05:48:06 <Ariakenom> So don't be too impressed :)
05:48:41 <merijn> Ah, yes, the -> at the end of line 3 convinces me it
05:48:45 <Ariakenom> I was lseactuary was doing some Elixir or something around here earlier
05:48:46 <merijn> *it's not Haskell
05:48:55 <merijn> because that's not legal syntax
05:50:23 <lseactuary> its not the syntax i am worried about - just not getting why in the second select it is stopping
05:50:38 <lseactuary> the way i have set the code up, it should execute the move function again
05:50:44 <lseactuary> so i dont understand where i have gone wrong
05:51:44 <dminuoso> merijn: It's CSP
05:52:08 <dminuoso> I think?
05:52:11 <lseactuary> yup
05:53:04 <lseactuary> this is the problem: https://imgur.com/a/R01kj4c
05:53:09 <lseactuary> and i dont see how this even makes sense
05:53:11 <lseactuary> given the code...
05:53:35 <lemmih> lseactuary: #haskell might be the wrong place to ask.
05:53:50 <lseactuary> where do you recommend?
05:53:55 <lseactuary> other channels pointed me here
05:54:07 <merijn> eh, why would they point you here?
05:54:12 <lseactuary> to discuss the logic
05:54:13 <cocreature> and this channel has repeatedly told you that your questions are offtopic
05:54:19 <cocreature> yet you keep coming back here
05:54:21 <lseactuary> if we can discuss the logic then i can write the code
05:54:32 <lseactuary> well i asked in offtopic but people reply here
05:54:35 <lemmih> lseactuary: Write the logic in Haskell and we might be able to help. :P
05:55:14 <cocreature> the fact that other channels don’t answer your question, doesn’t mean you should ask it here
05:55:57 <dminuoso> "I wanted to buy a Ford, but all the other places didn't have a salesman available. So I came to this VW shop. Why won't you sell me a Ford?
05:56:04 <CodeKiwi> we should direct him to the other channels
05:56:22 <CodeKiwi> dminuoso I bought a mini at an acura dealership :P
05:56:43 <CodeKiwi> and I sold it at a ford one!
06:02:26 <Ariakenom> I have a proposal for THE basic numeric type. Scrap your floats, 0.1+0.2=0.3! Use Rationals with unbounded numerator and bounded denomenator. No overflow, memory usage proportional to (log) magnitude, handles basic math ok. Buy now for half price.
06:03:00 <merijn> Ariakenom: You can use 0.1 to create rationals
06:03:01 <maweki> I have a problem and I don't understand what I am doing wrong. I want to define a typeclass DS a where a should both be Foldable and Show. So  "class (Show a, Foldable a) => DS a where" but I get "Expected kind ‘* -> *’, but ‘a’ has kind ‘*’". If I only say a is Show or a is Foldable it works, but not with both.
06:03:06 <merijn> > 0.1 :: Rational
06:03:08 <lambdabot>  1 % 10
06:03:32 <merijn> Ariakenom: Since any finite floating point literal has a rational representation :p
06:03:34 <lseactuary> ye but it is interesting
06:03:36 <lseactuary> :)
06:04:01 <cocreature> Ariakenom: memomry usage proportional to log magnitude is not correct
06:04:52 <Ariakenom> merijn: literals are fromRational not floating
06:05:14 <cocreature> oh bounded denomenator I can’t read
06:05:21 <Ariakenom> cocreature: :)
06:05:48 <Ariakenom> so you get rounding errors and even underflow
06:07:33 <merijn> cocreature: 33 ToExpr instances later, I manage to run GHC out of type-checking cycles... :p
06:07:56 <Ariakenom> But only when you exceed the denomenator. So you can have a precision of 2^(-64) or 2^(-256) or whatever
06:09:05 <lemmih> maweki: How can it both be Foldable and Showable?
06:10:04 <lemmih> maweki: Foldable is for things like [] and Maybe, etc.
06:10:34 <maweki> lemmi: Oh. So the parameter of the foldable type needs to be showable?
06:13:39 <dminuoso> :k Foldable
06:13:40 <lambdabot> (* -> *) -> Constraint
06:13:44 <dminuoso> :k Show
06:13:45 <lambdabot> * -> Constraint
06:14:19 <maweki> dminuoso: oh. Okay. Thanks. Didn't know about :k. :)
06:15:41 <dminuoso> maweki: Foldable talks about something of the shape (* -> *). For example `instance Foldable []`. `instance Foldable Maybe`, `instance Foldable (Either a)` or `instance Foldable ((,) a)`
06:17:05 <dminuoso> maweki: You could say that `Show` only works for nullary type constructor, whereas Foldable only works for unary type constructors.
06:17:47 <dminuoso> maweki: There's some interesting intution coming from that. Notably that `[]` is a Functor, but not `[Int]`. So the functorial nature is about the list type constructor, not any particular list type.
06:31:09 <merijn> phadej: ugh...tree-diff really needs an easy way to create instance for a type using just Generic instead of needing to define instance for all types inside... >.>
06:32:16 <cocreature> merijn: how is that supposed to work? should it just not diff the types inside?
06:33:23 <merijn> cocreature: Well if it's possible to have a Generic implementation for ToExpr it could just use that generic function, rather than the ToExpr instance
06:34:02 <cocreature> merijn: well but then you wouldn’t have any way to provide manual instances
06:34:31 <merijn> cocreature: I'm not saying that should be the default
06:34:40 <merijn> I'd just like it to be an option
06:34:58 <cocreature> fair enough
06:35:16 <merijn> cocreature: 'cause I'm now approach 100 lines of "instance ToExpr Foo" and not seeing the end any time soon
06:37:08 <cocreature> you sure seem to have a lot of types :)
06:37:13 <merijn> Ah, looks like it's 98
06:37:22 <merijn> cocreature: I don't, but Cabal fucking does >.>
06:40:58 <merijn> cocreature: On the brightside, it works! \o/
06:42:50 <cocreature> heh, I’m glad I won’t have to deal with you being mad at me because it didn’t work :)
06:49:38 <rotcev> question, regarding lazy evaluation, are there any performance penalties for using the "sequence" function, or does the function do the transformation while the traversable is being evaluated?
06:51:11 <dminuoso> rotcev: What exactly do you mean "while the traversable is being evaluated" ?
06:51:37 <rightfold> On Ubuntu, where llvm-config is actually named llvm-config-3.9, how can I tell GHC that llvm-config is named llvm-config-3.9?
06:51:45 <rightfold> When compiling with -fllvm.
06:52:24 <ventonegro> rightfold: Create a symlink from llvm-config-3.9 to llvm-config
06:52:35 <cocreature> I don’t think GHC calls llvm-config?
06:53:49 <cocreature> a grep in the GHC source seems to agree
06:53:51 <rightfold> GHC complains it can't find LLVM, because Ubuntu suffixes all the binaries with "-3.9"
06:54:22 <cocreature> rightfold: right it calls llvm binaries but it calls llc not llvm-config afaik
06:55:08 <rotcev> dminuoso: i think it is hard for me to explain myself, maybe i will ask again when i think of a better way
06:55:13 <dminuoso> rotcev: The "evaluation" is meant figuratively. For example if you have `replicate 3 getLine :: [IO String]`, then sequence turns that into `IO [String]`
06:55:49 <cocreature> rightfold: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html?highlight=optc#forcing-options-to-a-particular-phase has the options for setting the path to opt and llec
06:55:51 <cocreature> *llc
06:56:34 <rotcev> dminuoso: indeed, i was wondering if sequence happens to do that without having to move over the entire list again
06:56:43 <rotcev> if that makes sense
06:56:55 <dminuoso> rotcev: what do you mean by "again"
06:57:52 <dminuoso> rotcev: NonEmpty is perhaps a simple example to look at
06:57:54 <dminuoso>   traverse f ~(a :| as) = liftA2 (:|) (f a) (traverse f as)
06:57:55 <rotcev> say i provide some function that will eventually return [Just 1, Just 2, Just 3], and i apply sequence to that function, will the [Just 1, Just 2, Just 3] be evaluated first, and then transformed into Just [1, 2, 3]
06:58:01 <rotcev> or does it happen on the fly
06:59:27 <rightfold> cocreature: thanks, -pgml{c,o} seem to work to some extent
06:59:58 <dminuoso> > sequence . repeat $ putStr "Hi"
06:59:59 <lambdabot>  <IO [()]>
07:00:08 <dminuoso> rotcev: ^- Try that out. It should answer your question.
07:01:03 <oo_miguel> Any suggestions where to read about "forall"? Just from looking at some examples I do not understand how it works..
07:01:27 <merijn> cocreature: btw, had you tried the flag-filter PR?
07:01:42 <cocreature> merijn: no, haven’t gotten around to it so far
07:01:43 <rotcev> dminuoso: thanks
07:02:04 <dminuoso> rotcev: Do you understand how lists are represented in Haskell?
07:02:31 <merijn> cocreature: ok, just curious if you'd run into any issues if you did, because I just did a "unless someone complains I'm merging this" update :p
07:02:38 <rotcev> dminuoso: i am not sure i understand your question
07:02:54 <cocreature> merijn: I’ll make sure to complain if I run into problems :)
07:03:28 <dminuoso> rotcev: a list is not a fundamental builtin storage device like in other languages. A list is basically just this: `data List a = Cons a (List a) | Nil`
07:03:56 <dminuoso> rotcev: So it's just data constructors. Functions that operate on lists pattern can match on data constructors, which causes evaluation of the spine.
07:04:38 <rotcev> dminuoso: ah interesting
07:05:02 <rotcev> then the answer to your question is no :) i didn't know that
07:06:03 <dminuoso> rotcev: [1,2,3] is just syntax sugar for: `1:(2:(3:[])))`, which using my notation would be written as: Cons 1 (Cons 2 (Cons 3 Nil))
07:06:19 <dminuoso> Note that these last two are pretty much equivalent, (:) is just infix Cons. :)
07:06:42 <rotcev> ah, is (:) also defined that way in the source?
07:06:56 <rotcev> if so that makes a lot of sense, as i was familiar with the first sugar you just showed
07:08:32 <rotcev> dminuoso: thanks a lot, that is cool
07:11:42 * hackage friendly 0.1.0.0 - Attempt to pretty-print any input  http://hackage.haskell.org/package/friendly-0.1.0.0 (EdskoDeVries)
07:13:10 <dminuoso> rotcev: Well GHC.Types has some
07:13:12 <dminuoso> data [] a = [] | a : [a]
07:20:35 <dminuoso> rotcev: (This is not safe or guaranteed to work) https://gist.github.com/dminuoso/6a2b6e11184396eb702fb1d409d5c6eb
07:25:27 <ertes-w> oo_miguel: here is a tutorial: https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
07:27:50 <dminuoso> rotcev: So regarding your initial question: For lists, sequence be `foldr f (pure []) where f x ys = liftA2 (:) x ys`
07:28:41 <dminuoso> rotcev: It's a bit tricky to explain, it's best understood by manually doing the reduction.
07:30:51 <rotcev> dminuoso: thanks again, very helpful
07:39:09 <sqooq> :q
07:50:01 <boxscape> is there a good introduction to dependent types in Haskell?
07:50:44 <merijn> boxscape: Idris :p
07:51:18 <merijn> boxscape: tbh, attempting to do dependently typed things in haskell generally leads to pain (hence the singletons paper being called Hasochism...)
07:51:37 <merijn> boxscape: The singletons paper and GHC manual are good starting point for advanced type abuse, but it will not be pleasant
07:51:45 <boxscape> okay, thanks
07:53:12 <jchia_1> merijn: I concur. I don't know why people want to do it though. For fun?
07:54:40 <boxscape> Personally, I'm trying to see if I can write a wrapper around accelerate which makes the sizes of arrays type-safe, which I figure shouldn't require too many features of depedent types
07:54:54 <jchia_1> I spent a lot of time trying to make a type-level solution and didn't find a good solution. In the end I used TH.
07:54:58 <boxscape> so it seems like something that should be doable in haskell
07:55:04 <jchia_1> (for a recent project)
07:55:14 <ertes-w> jchia_1: some things are naturally dependent, so it would be nice to be able to do it in haskell, but the complexity quickly grows out of proportion, as soon as you need anything more than simple reflection
08:02:07 --- mode: wolfe.freenode.net set +o ChanServ
08:15:46 <srhb> Is it possible to inspect what was passed as -with-rtsopts (eg. the defaults) in a built executable?
08:15:59 <srhb> I can do trial and error but urgh. :-)
08:20:59 <lemmih> srhb: I don't think so.
08:21:34 <srhb> lemmih: Sadface. Thanks. :)
08:21:39 <lemmih> srhb: What are you up to nowadays?
08:21:54 <srhb> lemmih: Oh, you remember me. I'll never forget that embarrassing day when I didn't know you were the author of acid-state.
08:21:57 <srhb> :-)
08:22:07 <lemmih> haha, I'll never forget.
08:22:26 <srhb> lemmih: Same. I work with obsidian systems now. Yourself? Back in Denmark?
08:24:24 <lemmih> srhb: Cool. Yeah, I'm back at ucph, finishing my bachelor's before heading out again.
08:25:20 <lemmih> srhb: Is that the same Obsidian Systems that Cale works at?
08:25:28 <srhb> lemmih: It is :)
08:33:12 * hackage Hastodon 0.4.0 - mastodon client module for Haskell  http://hackage.haskell.org/package/Hastodon-0.4.0 (syucream)
08:36:00 <chasm> hihi - I'd like to be able to code to a lens-based interface, e.g., "color :: Lens' Thing Color" etc, without having to define the lenses, and allowing for alternate definitions when the time comes... is Backpack the only way to code to such an interface without defining it?
08:36:41 <ertes-w> chasm: classes (e.g. makeFields) is another option
08:44:12 * hackage persistable-types-HDBC-pg 0.0.2.0 - HDBC and Relational-Record instances of PostgreSQL extended types  http://hackage.haskell.org/package/persistable-types-HDBC-pg-0.0.2.0 (KeiHibino)
08:49:42 * hackage persistable-types-HDBC-pg 0.0.3.0 - HDBC and Relational-Record instances of PostgreSQL extended types  http://hackage.haskell.org/package/persistable-types-HDBC-pg-0.0.3.0 (KeiHibino)
08:52:26 <eacameron> Is there a rule of thumb when to use coerce instead of a newtype constructor/pattern match directly?
08:52:31 <eacameron> In terms of performance.
08:52:39 <glguy> Use coerce when it's more efficient to do so
08:52:47 <eacameron> glguy: When is that?
08:53:01 <glguy> When you're not just using the newtype constructor on its own
08:53:47 <glguy> 'MyNewtype' vs 'map MyNewtype'
08:54:03 <eacameron> glguy: Ah perfect. Ok I suspected something like that.
08:55:09 <eacameron> I like using newtype constructors directly when possible for readability but don't want to hit performance unnecessarily.
08:55:18 <chasm> ertes-w: ah, I see... "class HasColor t where color :: Lens' t Color; myFunc :: HasColor t => ...etc...", then supply the instance later? thx
09:23:58 <sub0_> hi
09:24:04 <isovector> hi
09:24:12 <sub0_> is there a minMax function that returns (min, max) tuple?
09:24:50 <isovector> `minMax as = (minimum as, maximum as)`  :)
09:25:58 <sub0_> I have x, y, and I want min and max. something nicer than let min' = min x y; max' = max x y
09:26:15 <sub0_> let (min', max') = minMax x y
09:26:29 <sub0_> I have a feeling such a function doesn't exist but just wanted to make sure
09:26:39 <isovector> nope
09:27:51 <kuribas> :t min &&& max
09:27:52 <lambdabot> Ord b => b -> (b -> b, b -> b)
09:28:55 <kuribas> :t minimum &&& maximum
09:28:56 <lambdabot> (Ord c, Foldable t) => t c -> (c, c)
09:29:12 <isovector> :t curry (uncurry min &&& uncurry max)
09:29:13 <lambdabot> Ord a => a -> a -> (a, a)
09:31:39 <kuribas> does arrow notation gets used?
09:31:46 <kuribas> arrow do
09:31:56 <kuribas> I haven't seen much code use it
09:32:46 <isovector> kuribas: the only example i can think of is hxt: https://hackage.haskell.org/package/hxt
09:36:42 * hackage fake 0.1.1.1 - Randomly generated fake data  http://hackage.haskell.org/package/fake-0.1.1.1 (DougBeardsley)
09:36:58 <mark0_> hi
09:38:10 <mark0_> I have a question regarding this code
09:38:11 <mark0_> https://stackoverflow.com/q/49843681/7159163
09:38:18 <mark0_> Is there a cleaner way to do it/
09:38:19 <mark0_> ?
09:38:38 <mark0_> (btw its mark721 but idk how to change username on this lol)
09:39:17 <mark721> ok done
09:39:20 <mark721> any ideas?
09:39:29 <lemmih> mark721: Those functions aren't clean enough?
09:39:42 <mark721> lemmih: idk i was just thinking its not that nice imho
09:39:51 <mark721> but if u think its good enough then i guess my answer is closed?
09:39:56 <lemmih> mark721: In what way is it not nice?
09:40:08 <mark721> i mean
09:40:16 <mark721> i have my exam tomorrow and i dont feel i like the look of it
09:40:17 <mark721> lol
09:40:49 <mark721> ok nvm
09:41:00 <lemmih> I think the code is totally fine.
09:41:12 <Clint> that was strange
09:41:21 <lemmih> Just add type signatures and documentation.
09:52:23 <shapr> For a class I'm teaching I defined a datatype and asked the students to write their own Enum instance: data Week = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
09:52:30 <shapr> My manually built Enum instance errors out on [Monday .. ] but works fine if I use "deriving Enum" instead, what's different about the deriving magic?
09:54:36 <lyxia> you could look at the difference with -ddump-deriv
09:55:10 <lemmih> shapr: How did you write the Enum instance?
09:55:37 <shapr> Is there some way I can see the code that results from "deriving Enum" ?
09:55:53 <lyxia> -ddump-deriv
09:56:01 <Taneb> shapr: presumably the derived one defines "enumFrom"
09:57:59 <shapr> Taneb: oh, that makes sense, I only implemented toEnum and fromEnum
10:01:02 <fishythefish> enumFrom has a default implementation, though
10:01:17 <fishythefish> toEnum + fromEnum is the minimal definition, isn't it?
10:04:14 <glguy> No, while toEnum and fromEnum are the only two methods that don't have default implementations you'd need to implement more than that
10:04:44 <glguy> That displayed minimal implementation in the haddocks is inferred, unfortunately. That might be worth fixing
10:05:11 <fishythefish> oh, `enumFrom x  = map toEnum [fromEnum x ..]` probably fails once you hit an index that's too high
10:05:13 <dyl> johnw I'm looking into using an f-algebra as you mentioned, the main issue I'm seeing is managing the 'original' state.
10:05:25 <glguy> I guess it varies by type what the minimum implementation is going to be
10:05:35 <dyl> e.g. as soon as I find a triple suitable for reduction, I want to produce a new original sequence and start again.
10:05:55 <dyl> What I'm doing is taking a set of leaf nodes and iteratively building a binary tree structure atop them.
10:06:01 <shapr> section 6.3.4 of the haskell report says: "enumFrom and enumFromThen should be defined with an implicit bound" but Enum does not require Bounded
10:06:05 <glguy> shapr: Check out the part in haddock that says: For any type that is an instance of class Bounded as well as Enum, the following should hold:
10:06:15 <dyl> I'm wondering if there's perhaps a better way to approach this that makes updating the original state and performing another pass more natural.
10:06:46 <glguy> shapr: If your type has a bound you have to do a little extra work. You don't have to actually make the Bounded instance, however
10:07:40 <dyl> LET THE JOINS, HIT THE FLOOR
10:07:44 <dyl> LET THE JOINS, HIT THE FLOOR
10:07:45 <shapr> yeesh
10:07:53 <dyl> LET THE JOINS, HIT THE FLOOOOOOOOR
10:08:01 <shapr> this is a bit much
10:08:01 <dyl> Wheeee....
10:08:11 <dyl> That was what, 200-300 joins?
10:08:29 <shapr> glguy: does that mean deriving Enum quietly also derives Bounded?
10:08:47 <orbisvicis> question about list append and foldl. So lists are linked and you should always do a:[..] rather than [..] ++ [a], since for any two lists of total length N, l1 ++ l2 goes through all N elements. But with foldl you have an unevaluated expression of either: "([] ++ [e1]) ++ [e2] ..." or "... e2:(e1:[])". In terms of perfermance, this both go through N elements where N is the length of the list, so they
10:08:48 <glguy> shapr: No, it means that the derived code is aware of the bound
10:08:53 <orbisvicis> are equivalent? In fact, would foldl' be actually worse?
10:09:11 <glguy> orbisvicis: ++ doesn't go through the elements of the second list
10:09:29 <dyl> In any case, as anything I asked is now way out of anyone's buffer.... I'm wondering if there's a good way to model transformation of a list into a binary tree.
10:09:38 <dyl> Zippers/f-algebra approaches seem viable,
10:09:43 <dyl> but I'm not sure which would be a better approach.
10:09:52 <dyl> Maybe I need to go back to Okazaki :p
10:10:25 <CodeKiwi> dyl I disable joins/parts here it helps ;P
10:10:29 <shapr> thanks for the typeclass instance help
10:10:35 <dyl> I don't include joins/parts in my ZNC buffers.
10:10:46 <dyl> playback buffers*
10:10:49 <dyl> But, they appear during active usage.
10:10:53 <orbisvicis> glguy: ok that makes sense. But in the foldl case of individual elements both approaches go through N elements
10:11:54 <glguy> orbisvicis: with foldl one creates a list that would take time linear in the length of the list to evaluate and the other would take quadratic time to evaluate completely
10:13:35 <orbisvicis> glguy: you mean this is quadratic: "([] ++ [e1]) ++ [e2] ..." and this is linear: "... e2:(e1:[])" ? (or where you referring to foldl') ?
10:13:41 * dyl thinks he needs to work through implementing everything in Okazaki.
10:13:47 * dyl to shake off the rusrt.
10:13:49 <dyl> rust*
10:13:55 <dyl> (Please don't make Rust jokes...)
10:13:57 <glguy> orbisvicis: Right
10:15:35 <orbisvicis> glguy: why? I can see quadratic in the foldl' case because each "l ++ [e]" is immediately evaluated to a new list, which then has to be iterated over entirely for the next ++, and so on
10:16:03 <orbisvicis> but in lazy foldl, "([] ++ [e1]) ++ [e2] ..." is equivalent to "[] ++ [e1] ++ e2", and can't this be done in a single pass ?
10:16:25 <glguy> orbisvicis: The question's only interesting if you're going to evaluate the resulting list. foldl' and foldl doesn't really matter in this case
10:16:31 <glguy> seq of a list only forces the first eleemnt
10:17:09 <glguy> If you're going to ignore the result of the foldl then its constant time, the foldl won't even process the list
10:17:24 <fishythefish> it doesn't even force the first element, it forces the leftmost constructor
10:21:22 <orbisvicis> oh I see, but I will be evaulating the entire resulting list
10:22:07 <glguy> If you're evaluating the entire list then you'll pay the full time of processing N^2 / 2 cons cells with ++
10:24:40 <fishythefish> orbisvicis: if you're interested in fixing the performance issues with left-associated appends, look up difference lists (AKA Hughes lists)
10:27:09 <CodeKiwi> dyl what does a rust programmers typical work day look like? First they get to the office, and then they Go
10:27:42 <orbisvicis> I don't understand why "l1 ++ l2 ... ++ lN" isn't linear. If ++ was left associative "((l1 ++ l2) ++ l3)" it could be optimized but it is right associative - "(l1 ++ (l2 ++ l3))" - and isn't this linear?
10:28:22 <glguy> The associativity of ++ is irrelevant here
10:28:24 <Guest61273> orbisvicis: Which kind of linearity are you speaking about?
10:28:31 <glguy> That has to do with how x ++ y ++ z is parsed
10:30:03 <orbisvicis> O(n), I guess. Ok so x ++ y ++ z is parsed as (x ++ (y ++ z)), and this only has to iterate the lists x and y, and that is O(n), right?
10:30:18 <Adluc> Hello, guys, is this correct way to use parallel? ((+1) <$> [1,2,3]) `using` (parListChunk 100 rpar)
10:30:19 <Guest61273> orbisvicis: What does O(n) mean?
10:30:29 <[exa]> orbisvicis: it's lazier than you think
10:31:00 <orbisvicis> [exa]: well I'm assuming the result will be evaluated
10:31:35 <Guest61273> orbisvicis: You should probably learn more about what you are measuring with your O(n)...
10:32:02 <[exa]> orbisvicis: basically, you can assume that "popping" an element from the beginning of the resulting list will be O(1). It's easily seen from the definition of ++
10:33:54 <droplet> @hoogle [a -> b] -> a -> [b]
10:33:55 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
10:33:55 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
10:33:55 <lambdabot> GHC.OldList map :: (a -> b) -> [a] -> [b]
10:34:32 <[exa]> :t flip (<*>)
10:34:33 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
10:35:05 <droplet> :t flip (<*>) . pure
10:35:06 <lambdabot> Applicative f => a -> f (a -> b) -> f b
10:35:24 <[exa]> yes, and the flip was unnecessary (my bad)
10:35:43 <droplet> :t (<*>) . pure
10:35:44 <lambdabot> Applicative f => (a -> b) -> f a -> f b
10:35:49 <orbisvicis> [exa]: what does that have to do with the complexity of fully evaulated ++ ?
10:37:55 <orbisvicis> anyway my question is: why is fully evaulated (l1 ++ l2) ++ l3) O(n^2) when it is equivalent to (l1 ++ (l2 ++ l3)) which is O(n)
10:38:07 <glguy> ([1] ++ [2]) ++ [3] ==> (1 : ([] ++ [2]) ++ [3] ==> 1 : (([] ++ [2]) ++ [3])
10:38:17 <glguy> it's only equivalent in the value, not the process to produce the value
10:38:47 <glguy> See how producing that first element required *both* uses of ++ to inspect their first arguments?
10:38:49 <cocreature> Adluc: you probably want to use a smaller chunk size than 100 if you only have 3 elements :)
10:39:32 <Adluc> cocreature: just trying in ghci, I have it as an assignment in school to determine if amdhal's law apply, and in this case plot speedup depending on chunks
10:40:08 <Adluc> determining ideal chunk size
10:41:25 <Adluc> its quite fun showing teacher oneliner that does everything he explains on 3 different classes with bullshit interfaces in java :D
10:42:25 <[exa]> Amdhal's law wasn't much about block sizes, was it?
10:44:48 <Adluc> idea is to plot 3d chart with X - threads num, Y - block size, Z - wall clock time
10:45:35 <Adluc> and come up with some conclusion :D
10:45:58 <Adluc> [exa]: idk, doesnt matter, will figure it out
10:46:32 <[exa]> you might want to try Criterion for benchmarking btw
10:46:55 <[exa]> it nicely avoids statistical measurement errors
10:48:06 <orbisvicis> glguy: I see, btw where's ++'s definition? I also assume there's a good reason the compiler doesn't rewrite ((l1 ++ l2) ++ l3) and (l1 ++ (l2 ++ l3))
10:48:24 <glguy> orbisvicis: There's nothing for the compiler to rewrite
10:48:37 <glguy> that expression never appears in your code
10:49:05 <orbisvicis> yeah that's true
10:49:08 <glguy> You can click the [source] links in the documentation
10:49:41 <Guest61273> Adluc: The first two ought to be attainable somewhat from the specifications of your machine; for X, don't go too high above the number of cores your processor has unless each task involves plenty of IO and isn't CPU-bound, for Y, in a language without garbage collection my suggestion would be to use a cache profiler. GC doesn't help you much there, but you could try somewhere around your L2
10:49:41 <Guest61273> cache size...
10:50:31 <cocreature> Adluc: oh and you probably want rseq instead of rpar in your example
10:53:13 <Adluc> Guest61273: thanks for notes, each task is pure, so I guess the cache size will corellate with chunk size, will post here back results
11:11:13 <tabaqui1> do you know some good way to pass monadic stack inside of child thread?
11:11:21 <tabaqui1> MonadWriter for example
11:12:57 <Clint> is there a good way to derive Semigroup across ghc 8.{0,2,4}?
11:14:40 <lyxia> Clint: via generics, see semigroups, one-liner-instances, generic-data
11:15:39 <Clint> lyxia: thanks, I seem to have misread the problem
11:41:02 <juanOsorio> guys hi, i've been sitting for quite a while trying to understand whats the difference between these two fibonacci implementations. namely fib and fib'. fib' allows me to compute fib' 100 quite fast while the other implementation is quite inefficient. but I do not have the understanding to grasp what is happening there, what is also different between these two. Here's the pastie
11:41:08 <juanOsorio> https://www.pastiebin.com/5ae0cb2cdca58
11:43:55 <fishythefish> juanOsorio: the difference is that fib' computes the fibonacci sequence by walking it: you start with 0 and 1, then generate the next element by summing the two previous ones until you get to the desired index
11:44:00 <phadej> juanOsorio: try to expand the expressions for say `fib 4`
11:44:03 <fishythefish> fib is the naive recursive implementation
11:44:18 <phadej> you'll see why fib is slower
11:44:31 <phadej> doing calculation by hand is the best way here
11:44:39 <fishythefish> ^
11:45:39 <fishythefish> it also illustrates nicely why the time to compute `fib n` with a naive recursive approach is O(fib n)
11:45:56 <phadej> fib 2 = fib 1 + fib 0; fib 3 = fib 2 + fib 1 = fib 1 + fib 1 + fib 0; fib 4 = ...
11:46:45 <juanOsorio> thanks guys! ill try it then by hand and look at your comments again <3
11:47:00 <phadej> (i made a type, but you'll spot it)
11:49:42 <CodeKiwi> where have I seen that code before
11:51:29 <juanOsorio> fib 3 is also = fib 1 + fib 0 + fib 1 right? you just reordered it
11:53:04 <rrTornado> juan0sorio: Here's a simple way to think about it. A function X is faster than function Y in getting the answer when it does less work to get the answer.
11:53:56 <rrTornado> Less work usually means running fewer calculations. See how fib' manages that.
11:54:05 <juanOsorio> hmm. I just cant wrap my head around the very last line. fib' f1 f2 n = fib' f2 (f1 + f2) (n - 1)
11:54:40 <crestfallen> hi my book says an empty list denotes failure. The use of valid on the list comprehension doesn't seem to do anything here: https://ptpb.pw/tq3O
11:55:52 <cocreature> crestfallen: what do you mean by “doesn’t seem to do anything”? can you provide some example input for eval as well as the output you expect and the one you actually get?
11:56:35 <crestfallen> I commented out the valid prerequisite (what do you call that?) and it worked the same. thanks cocreature
11:56:39 <cocreature> it’s also a rather weird choice to use lists for failures, we have a special datatype for that called Maybe
11:56:49 <cocreature> which can only contain 0 or 1 element
11:57:04 <crestfallen> yes the book says this about the use of Maybe here ....
11:57:26 <cocreature> crestfallen: eval (Val (-15)) will give you an empty list so everything else will also be empty
11:57:52 <crestfallen> failure within eval could also be handled by using the Maybe type, but we prefer to use the list type because...
11:57:57 <rrTornado> juan0sorio: Try evaluating the value of fib' 0 1 n for different values of n.
11:57:59 <cocreature> because?
11:58:06 <crestfallen> the comprehension notation then provides...
11:58:15 <crestfallen> a convenient way to define the eval function
11:58:43 <cocreature> you can use do notation or if you enable the MonadComprehensions extension even the same syntax
11:59:01 <crestfallen> notation?
11:59:16 <cocreature> do notation
11:59:18 <crestfallen> this is a book, I'm just following the example
11:59:26 <cocreature> right I’m saying the book is wrong :)
11:59:38 <cocreature> or at the very least not idiomatic
11:59:38 <crestfallen> hutton second edition
12:00:06 <crestfallen> I can't follow your advice but thanks..
12:00:23 <cocreature> do x <- Just 1; y <- Just 2 <- pure (x + y)
12:00:24 <cocreature> > do x <- Just 1; y <- Just 2 <- pure (x + y)
12:00:27 <lambdabot>  <hint>:1:1: error:
12:00:27 <lambdabot>      Parse error in pattern: do x <- Just 1
12:00:27 <lambdabot>                                 y <- Just 2
12:00:33 <cocreature> > do x <- Just 1; y <- Just 2; pure (x + y)
12:00:35 <lambdabot>  Just 3
12:00:41 <crestfallen> I was asking why valid is used since a boolean is not returned anywhere
12:00:59 <cocreature> valid is used to filter elements in the list
12:01:31 <cocreature> so if "valid o x y" returns False the result will not be included in the list
12:02:48 <cocreature> > [1 | False]
12:02:50 <lambdabot>  []
12:02:53 <cocreature> > [1 | True]
12:02:55 <lambdabot>  [1]
12:02:59 <cocreature> ^ crestfallen that example might be helpful
12:03:07 <zincy> I am using the maybe function and this is the inferred type signature is this repetition a code smell ? maybe :: Maybe AuctionTXout      -> ((AuctionTXout -> IO (Maybe AuctionTXout))          -> Maybe AuctionTXout)      -> Maybe (AuctionTXout -> IO (Maybe AuctionTXout))      -> Maybe AuctionTXout
12:04:06 <crestfallen> ok the func valid assumes that there is no negative number as argument. note my example at the bottom of the paste would return True with valid. thats why I was confused.
12:04:13 <fishythefish> juanOsorio: that line is saying "suppose f1, f2 are the 0th and 1st elements of the fibonacci sequence and we want the nth element; to get that, we can instead start the sequence with f2, (f1 + f2) and get the (n-1)th element`
12:04:47 <crestfallen> cocreature, ^^
12:04:59 <juanOsorio> oh oh. I think I get im getting it!
12:04:59 <rrTornado> As far as I can see the behavior is correct. The eval function returns a result only if the inputs are valid.
12:05:00 <cocreature> crestfallen: right, "valid" returns true but in the recursive call you will eventually call "eval (Val (- 15))"
12:05:05 <rrTornado> Non negative.
12:05:14 <cocreature> crestfallen: and in that case n > 0 will be False, so you’ll get back the empty list
12:05:40 <rrTornado> And running a list comprehension from elements of an empty list will return an empty list.
12:05:46 <crestfallen> thanks yeah its up to the user
12:06:04 <crestfallen> right thanks rrTornado cocreature
12:07:34 <LysergicDreams> I want to make a separate daemon & TUI that are running on the same machine to send data between each other. What's the best method for this? Network.Sockets?
12:10:43 <marmistrz> Is there any way to write it in a more monadic, flat style?
12:10:43 <marmistrz> https://zerobin.net/?f081415fb970fa4b#LJm7WrRQwG7JipUuJS47plDB85LY7FkPeu67oQnTbyg=
12:11:00 <marmistrz> The code is moving so much to the right, it looks quite similar to manual matching of maybes
12:11:17 <marmistrz> I'm working in ExceptT Error (Reader Env) a
12:15:05 <lyxia> for the second one, write a function   MonadError e a => Maybe a -> e -> m a
12:15:13 <lyxia> for the second case ^
12:15:28 <lyxia> third*
12:16:53 <akfp> how do I find which package transitively depends on "entropy" in my project?
12:18:24 <lyxia> akfp: http://packdeps.haskellers.com/reverse/entropy maybe this helps narrow it down?
12:20:12 <cocreature> akfp: are you using stack or cabal?
12:20:26 <akfp> stack
12:20:42 <cocreature> you can use "stack dot" to get a graph of your dependencies
12:21:02 <lyxia> marmistrz: you could also define a function to deconstruct TFn or return Nothing, and then use that function I mentioned for the second case too.
12:21:19 <cocreature> or "stack dot --external"
12:22:27 <marmistrz> lyxia, by Maybe a -> e -> m a you mean a function, which will check throw an error and deconstruct the Maybe, as well?
12:25:37 <LysergicDreams> marmistrz: I'd also split your case into separate functions so that all the code to handle every expression isn't in one huge function: https://zerobin.net/?5e929feec5adc42e#tcVsLAYvqJXz3MFiBKOLkN/b9X9kbrVXRKhsI7OJEXQ=
12:26:07 <hexagoxel> marmistrz: you don't even need a separate function to follow that advice. (types, ret) <- case exptype of [..pattern match or error..]; [.. code that uses types, ret ..]
12:26:40 <hexagoxel> things stay flat that way, without new functions
12:28:43 <rrTornado> For the Maybe case, you can use the maybe function
12:30:07 <rrTornado> Nvm. Type won't make sense.
12:33:45 <juanOsorio> people. I finally understood the fib' implementation, I love you guys haha.
12:36:36 <marmistrz> hexagoxel, that's a great piece of advice!
12:36:37 <marmistrz> thanks
12:37:13 <marmistrz> LysergicDreams, this doesn't seem more readable to me ;) but this I'll keep this in mind
12:37:16 <marmistrz> thanks anyway
12:57:20 <dyl> Is there any general pattern I should look at for building trees from lists? (or more generally one functor from another, with the same elements?)
12:58:07 <dyl> It's not quite a natural transformation, as it can fail.
12:58:45 <dyl> It is however invertible (flattening a tree is trivial).
12:59:42 * hackage gtk-sni-tray 0.1.1.0 - A standalone StatusNotifierItem/AppIndicator tray  http://hackage.haskell.org/package/gtk-sni-tray-0.1.1.0 (eyevanmalicesun)
13:16:42 * hackage hOpenPGP 2.6.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-2.6.1 (ClintAdams)
13:28:54 <chessandgo> Im hoping to use websockets (and eventually secure websockets) for my applicate, although it is not a web app. perhaps there will be a primative webfront end, but it is not a webapp
13:29:00 <chessandgo> should I use yesod or https://hackage.haskell.org/package/websockets-0.10.0.0/docs/Network-WebSockets.html
13:33:54 <lyxia> dyl: if partiality's the problem you can switch to a category of partial functions.
13:37:23 <dyl> lyxia hm?
13:39:50 <lyxia> I mean you can still use natural transformations as a starting point, failure is not a problem.
13:40:51 <dyl> I'm not sure what you mean by "switch" to a category of partial functions though.
13:43:24 <lyxia> I mean to consider the category where objects are types and morphisms are partial functions (a -> Maybe b), with kleisli composition (>=>).
13:44:13 <lyxia> and functors over this category, and natural transformations between them.
13:46:16 <fatahland> where can i get help with irc?
13:46:25 <fatahland> a channel here maybe?
13:47:02 <Sulis> What kind of help with irc?
13:47:54 <fatahland> i can't get into some channels (like #emcas or #archlinux32) because it tel me that: Cannot join channel (+r) - you need to be identified with services
13:48:08 <fatahland> *#emacs
13:48:21 <fatahland> but i did this. i registerd myself
13:48:35 <Sulis> Are you currently identified with nickserv?
13:48:35 <fatahland> i got mail and paste the command it gave me here
13:48:38 <fatahland> yes
13:48:57 <glguy> fatahland: You can perhaps ask in #freenode. This channel is specifically for discussing the Haskell programming language
13:49:24 <fatahland> glguy: great this what i asked for thanks :-)
13:51:02 <CodeKiwi> he's not identified
13:52:27 <fatahland> CodeKiwi: how do you know?
13:52:36 <fatahland> when i enter here it itell me that i am
13:52:38 <Sulis> he's registered by not verified
13:53:10 <Sulis> *but not
13:59:10 <CodeKiwi> now he is
14:02:40 <fatahland> just updating the helped me there :)
14:02:44 <fatahland> *they
14:02:49 <fatahland> and it's OK now
14:03:11 <fatahland> CodeKiwi: how do you see it?
14:03:43 <Sulis> fatahland: you can ask nickserv for information about a nick
14:03:49 <CodeKiwi> check your queries ;P
14:03:55 <fatahland> Sulis thanks :)
14:04:30 <CodeKiwi> a /whois shows different
14:14:11 <brisbin> has anyone ever been able to get hpc coverage information from doctests? as far as i can tell, the problem is it uses ghci, and -fhpc is incompatible with byte-code interpreter (which seems reasonable), but i'm wondering if there is any weird workaround like an option to tell ghci to save/compile/execute instead
14:14:11 <sssilver> do you ever find yourselves returning functions?
14:14:56 <sssilver> I'm not digging the whole returning a function business
14:15:10 <sssilver> why return a perfectly good function if you can just invoke it
14:16:43 <orion_> Is it possible to label the fields in a GADT?
14:16:48 <glittershark> orion_: yep
14:16:55 <sclv> sssilver: maybe you don't have all the information to invoke it yet
14:16:55 <orion_> glittershark: What's the syntax for that?
14:16:56 <sclv> just some
14:17:12 <glittershark> data Foo where { Bar :: { x :: Int, y :: Int } -> Foo }
14:17:14 <sclv> so you partially apply it to the data you have, returning a new function that can then be used repeatedly over a whole set of data
14:17:44 <glittershark> the brackets after the where are stand-ins for newlines
14:17:47 <sssilver> sclv: well I would then just wait until I have all the information, and invoke it
14:17:52 <sssilver> what's wrong with that?
14:18:08 <glittershark> so like `data Foo where \n Bar :: { x :: Int, y :: Int } -> Foo`
14:18:20 <edwardk> brisbin: if you use -fobject-code that should help get you out of the byte-code interpreter. haven't tried it for hpc though.
14:18:43 <sclv> sssilver: consider if you want to map a function over a list
14:18:50 <sclv> how do you construct the function you map?
14:18:55 <CodeKiwi> brisbin !
14:18:58 <sclv> often, by composing functions and data to create a new function
14:19:26 <sssilver> sclv: I define a function that takes some input and returns an output, sure
14:19:33 <sssilver> sclv: I don't view that as "returning a function"
14:19:45 <sclv> but you can define it by partially applying another function
14:19:48 <sssilver> I view that as "passing a function" which makes a lot more sense to me
14:19:52 <sclv> or composing functions
14:19:59 <sclv> you don't need to write an explicit lambda
14:20:54 <CodeKiwi> <-- DigitalKiwi @ brisbin
14:23:10 <brisbin> edwardk: nice, i'll try that. it made my examples no longer compile due to missing imports, but that should be solvable. it no longer gave me a warning about ignoring -fhpc, so that's promising
14:23:14 <brisbin> CodeKiwi: hey!
14:23:32 <sssilver> hmm maybe I'm just programming incorrectly
14:23:37 <sssilver> I never find myself returning a function
14:23:41 <sssilver> and yet everything seems to be working
14:23:42 <CodeKiwi> edwardk did you see I watched one of your talks, actually two of your talks, very nice
14:24:33 <CodeKiwi> edwardk and I feel you lied to me in one of them because you said you were on irc like 24 hours a day but it's been a really long time :|
14:24:54 <sssilver> CodeKiwi: he didn't specify what planet he was logging in from
14:24:56 <sssilver> did he?
14:26:22 <CodeKiwi> 90% sure he is on Earth
14:27:29 <sssilver> CodeKiwi: "In the face of ambiguity, refuse the temptation to guess"
14:28:10 <CodeKiwi> shouldn't you Go back to work :|
14:28:54 <orion_> glittershark: That worked. Thanks!
14:29:00 <glittershark> orion_: yay! glad to hear it
14:29:04 <glittershark> yw
14:29:18 <edwardk> CodeKiwi: i'm herre aren't i? =)
14:29:29 <edwardk> CodeKiwi: i just don't reply very often unless i have something to say
14:29:59 <edwardk> been trying to figure out how to get a decent twitch stream to work for haskell coding
14:30:14 <brisbin> edwardk: still no coverage info with -fobject-code -fhpc in doctest arguments. do you think i should open an issue somewhere?
14:30:33 <edwardk> well, the program its 'running' is ghc basically, right?
14:30:34 <lavalike> edwardk: what issues are you having?
14:31:00 <CodeKiwi> he doesn't flash enough skin so he's not getting enough tips to get a new computer
14:31:19 <edwardk> lavalike: my macbook is way underpowered for encoding video and still programming, so i'm currently waiting for an adapter to arrive that'll let me capture hdmi video on another machine and stream from there
14:31:24 <Logio> edwardk: "twitch plays lambdabot" ?
14:31:48 <enterprisey> What's the difference between newtype T a b = T (a, b) and newtype T a b = T { f :: (a, b) }?
14:32:01 <edwardk> man, now i want a lambdabot for the chatroom =)
14:32:01 <enterprisey> as in, is there any difference typewise
14:32:02 <lavalike> edwardk: ah that's definitely a good solution, obs does provide gpu rendering which helps on even a puny macbook air
14:32:05 <glittershark> enterprisey: the latter gives you f :: T a b -> (a, b)
14:32:11 <edwardk> enterprisey: you have f  =)
14:32:13 <glittershark> enterprisey: no difference typewise
14:32:17 <enterprisey> glittershark: ah wonderful
14:32:22 <enterprisey> ty
14:32:24 <Ariakenom> I was asking for a twitch stream the other day but got pair programming. Happy with the result though.
14:32:49 <edwardk> lavalike: tried using 'gameshow' first, but it was just too slow encoding. i ate like 87% of my cpu and was dropping frames like mad
14:33:05 <CodeKiwi> edwardk ssh to server and code there?
14:33:10 <edwardk> i have a couple of beefy windows machines for graphics stuff, and i can repurpose one of them
14:33:14 <glittershark> edwardk: you tried using Open Broadcaster Software?
14:33:39 <glittershark> oh just noticed lavalike also mentioned obs, oops
14:33:54 <lavalike> edwardk: if you are willing try OBS with 'Apple VT H264 Hardware Encoder' in Settings > Output, after a long series of test runs it worked well for me, it even captured an external big monitor and streamed it without issues
14:34:12 <edwardk> thats the encoder i'm using through gameshow which in theory uses the same backend
14:34:13 * hackage haskell-igraph 0.5.0 - Haskell interface of the igraph library.  http://hackage.haskell.org/package/haskell-igraph-0.5.0 (kaizhang)
14:34:18 <glittershark> anyway the last time I used obs for streaming music production it seemed fairly lightweight even on my 3 year old macbook
14:34:23 <lavalike> yeah it's the apple apis
14:34:48 <lavalike> I only tried OBS and the one that starts with a W, Wiresomething?
14:34:51 <Ariakenom> OBS Studio is the "latest version" of OBS
14:35:26 <edwardk> anyhow the adapter thingy should arrive tomorrow or so
14:35:44 <edwardk> just in time for me to start traveling way too much to actually use it for anything for the next few months
14:35:52 <lavalike> cool, what is your twitch channel name?
14:35:56 <edwardk> ekmett
14:36:18 <edwardk> i had the account set up before, just for watching critical role and the like with my wife
14:36:48 <Ariakenom> critical role :+1:
14:36:54 <AndreasK> +2
14:37:44 <edwardk> its all the benefit of having a d&d game without having to actually 'play' and stress out about it ;)
14:38:33 <lavalike> edwardk: twitch has this default in https://www.twitch.tv/ekmett/dashboard/settings that doesn't save your broadcasts, which is a bummer for people not in your same timezone, if you can, enable it, they stick around a couple weeks after the live broadcast this way :)
14:38:56 <edwardk> so far my only broadcasts have been 40 seconds of me going 'nope, thats not working'
14:39:09 <lavalike> gotta save those for posterity haha
14:39:18 <edwardk> i figured i should try to rig up twitch or youtube live or something after realizing that in the last week or so i've done maybe a dozen hours of pair programming online
14:40:00 <lavalike> https://www.twitch.tv/garybernhardt does a nice show every once in a while
14:40:24 <CodeKiwi> phrasing!
14:40:35 <lavalike> and then there's https://www.twitch.tv/stephen_wolfram/videos/all that is also interesting, that I know of
14:40:59 <Ariakenom> followed, thanks!
14:41:32 <lavalike> haskell is not very well represented (:
14:43:02 <Ariakenom> ekmett is the perfect representative. Fulfils all preconceptions :p
14:45:12 <CodeKiwi> young, hot, flirtatious, not afraid to show some skin and female?
14:45:40 <edwardk> oh, sweet. i can talk to twitch chat from IRC, so i _can_ set up a lambdabot for the chat room
14:46:12 * hackage free 5.0.2 - Monads for free  http://hackage.haskell.org/package/free-5.0.2 (JohnWiegley)
14:46:14 <Ariakenom> CodeKiwi, yes. I know Haskell though so my preconceptions might be biased by reality.
14:46:21 <edwardk> CodeKiwi: to be fair, they have put in place guidelines about dresscode and stuff that makes that characterization a _bit_ dated
14:46:31 <lavalike> edwardk: yeah! twitch chat is crippled irc really
14:47:19 <CodeKiwi> https://11tx7b411ycc3zja3v2vhqz9-wpengine.netdna-ssl.com/wp-content/uploads/2015/11/Productivity-methods-.jpg
14:52:00 <Ariakenom> OMEGAK #haskell-memes when?
14:53:47 <chessandgo> if I a list of values (or entities in this case), that can have varying structure, should I use the the heterogenous list extension, create a datatype to express this, or handle this all explicitly
14:54:55 <Ariakenom> chessandgo, probably needs more details.
14:55:07 <zachk> chessandgo, I would lean towards using an algebraic datatype that is a sum type to do it
14:56:27 <Ariakenom> anyway. edwardk I did some perfectly reasonable "instance Commutative IO -- LIES" testing. And ApplicativDo seems finicky. Anything to consider that I'm probably missing?
14:56:42 <glittershark> some haskell programmers when faced with a problem around heterogenous data think "I know, I'll use existentials!". Then they have two problems.
14:57:10 <chessandgo> Ariakenom: its going to representing an entity, which can have or have not certain fields
14:57:15 <shachaf> i,i Now they have a problem, but they don't know what it is.
14:57:22 <chessandgo> like a character vs an animal, one would ahve an inventory field
14:57:35 <glittershark> ho! subtype relationships
14:57:53 <glittershark> chessandgo: depending on how comfortable you are with type hierarchy vinyl might be nice
14:58:00 <glittershark> sorry not type hierarchy
14:58:10 <glittershark> meant to write "type level programming" but my brain farted
14:58:11 <dyl> What is the better approach glittershark?
14:58:28 <glittershark> dyl: depends
14:58:37 <dyl> I’m not saying existentials is good, I’ve fallen into that trap in many languages.
14:58:45 <dyl> I’m just curious what is generally an appropriate solution.
14:58:55 <glittershark> sum types are fine tbh
14:59:32 <dyl> Doesn’t seem like that would cover the same use cases.
14:59:41 <dyl> When a sum type works it’s usually the simplest and best approach.
14:59:50 <glittershark> yes
15:00:07 <glittershark> I tend to think of SomeException as the "canonical" existential
15:00:24 <dyl> What about when you want a heterogenous collection of things that are all instances of the same typeclass?
15:00:38 <dyl> In other languages you would use an erasure pattern, but I suspect there’s a better way.
15:00:57 <glittershark> well the big question there is why you want that heterogenous collection
15:01:04 <dyl> True.
15:01:06 <glittershark> and also the nature of the heterogeneity
15:01:23 <glittershark> like is it truly open or is it just a list of 6 things you might want to shove in there
15:01:30 <glittershark> if the latter, probably still a sum
15:01:37 <dyl> Let’s say it’s open.
15:01:45 <dyl> The closed case is almost always best done with a sum type.
15:01:51 <zachk> say the heterogenuous collection stores all the entities in a game
15:02:03 <dyl> Or a bunch of “things which can be rendered”
15:02:08 <zachk> yea
15:02:11 <glittershark> open as in you're writing a library and want users to be able to store their own data structures in your collection
15:02:11 <dyl> e.g. instances of some Renderable class
15:02:15 <glittershark> well, haskell is lazy
15:02:17 <glguy> If it's open , you can use a record
15:02:25 <dyl> I would personally use records
15:02:27 <johnw> I just used SomeException last night to solve the "thing which can be rendered" problem
15:02:31 <dyl> I’m just trying to interrogate the solution space
15:02:35 <glittershark> why not store the return type of `render` in the list?
15:02:46 <johnw> since it's an open set, and I needed consumers to have access to the original types
15:03:11 <glittershark> yeah I tend to approach this problem as an application developer rather than a library developer, since that's what I use haskell for
15:03:56 <glittershark> and in an application "go add a constructor to the sum" is a totally fine way of adding a possible type to something like this
15:04:53 <glittershark> that said
15:04:56 <dyl> In an application context you nearly always have a closed set of things though.
15:04:57 <glittershark> records are nice
15:05:11 <dyl> In a library context it’s usually not so, or if it is it’s a hidden detail.
15:05:25 <glittershark> yeah for things that are truly open (like SomeException) I think existentials make some amount of sense
15:06:19 <ProfAnderson> I'm not MYSTIC, but MUSCULAR because I'm a CARNIVORE and regularly BULLRUN in my PRISM.
15:07:04 <dexterfoo> I have a haskell program. It calls a C function using FFI: void my_c_function(void(*callback)()); The callback is a Haskell function. "my_c_function" calls pthread_create and then immediately returns. some time later it decides to call the Haskell callback from the background pthread. is this legal?
15:09:08 <boj> dexterfoo: can you come up with any reasons why it wouldn't be?
15:09:50 <glittershark> dexterfoo: from reading https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#multi-threading-and-the-ffi it looks like as long as you `foreign import ccall safe` you should be fine
15:10:16 <glittershark> I've definitely passed function pointers to FFI functions that've been called in another thread and nothing's exploded yet
15:10:52 <ProfAnderson> Take the MAINWAY to Room 641A and you will find the ANT CATALOG for SENTRY EAGLE.
15:11:25 --- mode: ChanServ set +o glguy
15:11:25 --- mode: glguy set +q *!*@207.244.109.180
15:11:29 <dexterfoo> boj: The Haskell runtime might not be ready for the callback to be called at any arbitrary time
15:12:02 <glittershark> dexterfoo: I'm pretty sure `foreign export` sets up all the machinery to properly hook into the RTS
15:12:55 <dyl> ProfAnderson: you here to talk about Haskell or just reference as many NSA programs as possible?
15:13:57 <zachk> dyl, he's been quieted for now
15:14:02 <dexterfoo> glittershark: thanks, i'm reading that page
15:14:59 <boj> dexterfoo: what kind of case would the haskell runtime not be ready?
15:15:21 <glittershark> while it's GCing, potentially?
15:15:50 <boj> it would block?
15:16:44 <glittershark> well yeah ok I'm just saying the question isn't totally crazy
15:17:09 <boj> sure, i was trying to picture what kind of cases there were myself
15:17:12 * hackage crypto-enigma 0.0.2.12 - An Enigma machine simulator with display.  http://hackage.haskell.org/package/crypto-enigma-0.0.2.12 (Orome)
15:18:07 <dexterfoo> right. i want to make sure that callbacks are allowed to be used like this, and not just for "sort" style callbacks that are used immediately or always from the current thread
15:18:44 <chessandgo> glittershark: im new(ish) to type level programming, but the concept seems easy to understand
15:19:28 <chessandgo> im not exactly sure how my situation is solved by that, however
15:21:10 <boj> dexterfoo: ah, that does sound tricky. i suppose you'd have to spawn a haskell thread as well? not sure how C would get back to the caller otherwise
15:24:03 <abprof> If anyone has liquidhaskell working with stack please let me know how you did it :) It won't check my whole project and I get "cannot satisfy -package-id..."
15:24:27 <dyl> Oh man, I need to get around to playing with Liquid Haskell
15:24:50 <abprof> dyl: That's exactly what I'm thinking
15:25:26 <lyxia> I had it working a few months ago. Can you paste your command line?
15:26:18 <abprof> lyxia: I have it in the readme here: https://github.com/Michael-Boyle/testproject
15:26:32 <Welkin> haha
15:26:36 <Welkin> I read that as Micheal Bay
15:26:41 <Welkin> he's a programmer now?
15:26:46 <Welkin> Michael Bay*
15:27:02 <abprof> Welkin: There is an expected amount of explosion in that repo ;)
15:27:07 <dyl> He must be an Erlang programmer
15:27:13 <dyl> Because he insists everything blow up fast
15:27:33 <dyl> (Who are we kidding Michael Bay would use Node.js)
15:27:38 <tomlambda> How do you show all stdout from a readProcess call?
15:29:18 <dyl> lyxia any suggestions to get into Liquid Haskell btw? Beyond the papers which are on my backlog.
15:29:33 <abprof> dyl: Javascript is elegant and powerful and clean like Michael bay
15:29:42 <lyxia> dyl: go on their slack channel, they're really helpful
15:29:43 <dyl> I had been aware of it, but only properly saw some of it earlier this year.
15:30:17 <dyl> Ahh didn’t know they had a slack, noted.
15:30:18 <Welkin> who uses slack?
15:30:24 <Welkin> I thought there was a mass exodus to discord
15:30:33 <dyl> I also just met a few of the people involved in the project earlier this year and they were wonderful people.
15:30:43 <dyl> One of those projects that I lack the background for but really want to get into more.
15:30:46 <Welkin> although everyone should just use irc
15:30:49 <dyl> ^
15:31:10 <glittershark> no gifs in irc /s
15:31:50 <Welkin> people who moved from irc to slack got fucked after slack decided to remove irc-slack compatibility/bridges
15:32:00 <Welkin> I bet the same will happen with discord in a couple years
15:32:05 <dyl> Slack is good for teams, IRC for communities imo.
15:32:05 <dyl> I just prefer IRC though. Many of my first programming projects when I was starting out were IRC related.
15:32:16 <Welkin> slack is for businesses who want to pay for irc
15:32:25 <dyl> Writing an IRC bot is a very fun way to keep yourself engaged, and there are so many options for things to implement.
15:32:43 <dyl> I’ve never really seen a bridge that worked that great.
15:33:40 <abprof> My first 'big'ish project was an irc bot in python
15:33:45 <lyxia> abprof: sorry I don't think I can help :/ but try asking the LH people!
15:33:50 <dyl> Same, but in Ruby (I know right!)
15:33:52 <dyl> ?*
15:33:52 <lambdabot> Maybe you meant: v @ ? .
15:34:12 <dyl> This was over decade ago though.
15:34:22 <Welkin> my first real programs were irc scripts in mircscript
15:34:34 <abprof> thanks lyxia :) will do
15:34:40 <dyl> Writing an IRC bot got me into netcode though, which got me into C
15:35:02 <dyl> The first programming text I ever bought was Steven’s UNIX Network Programming. I still have it and treasurecit.
15:35:33 <abprof> writing an irc bot pushed me toward haskell since it was a small project but still excessively difficult to maintain
15:35:56 <abprof> in python, that is.
15:35:59 <CodeKiwi> glittershark I still manage giffs
15:36:01 <Welkin> Steven's UNIX
15:36:06 <Welkin> reminds me of Steven Universe
15:36:52 <dyl> I went Ruby ⇒ C ⇒ Erlang ⇒ Haskell as main focuses
15:37:00 <dyl> With a bunch of Python and other languages as needed in between.
15:37:09 <dyl> But those were the ones I was really into for the first few years.
15:37:21 <Welkin> what no lisp?
15:37:31 <glittershark> Python -> PHP -> Ruby -> Scala -> Clojure -> Elixir -> Haskell :)
15:37:31 <dyl> Oh, between the Erlang and Haskell
15:37:35 <dyl> I did SICP
15:38:01 <dyl> These days I usually play around in Haskell or Scala, and otherwise use whatever suits the task best.
15:38:16 <dyl> Current new language focus is on APL.
15:38:28 <glittershark> ooh, apl
15:38:31 <dyl> I couldn’t get into Elixir
15:38:32 <Welkin> aapl
15:38:38 <dyl> I just kept wanting to write Erlang
15:38:42 <Welkin> just call your language apple
15:38:53 <glittershark> I mean, it does stand for A Programming Language
15:38:53 <dyl> No, it’s AyyPL (AKA 👽)
15:39:06 <Welkin> then I can make a language orange
15:39:09 <dyl> (I’m currently working on an emoji based APL dialect)
15:39:12 <Welkin> and then you can compare apple and orange
15:39:22 <dyl> I’m like 30 papers into the literature currently ;__;
15:40:20 <dyl> It’s amazing, it’s like reading CS research in a time machine. My favorite detail has been a couple papers that went something like “now, this is a bit of an uncommon idea, so let’s include a primer... <BNF notation>”
15:40:32 <dyl> A world where general LR parsing doesn’t exist.
15:40:41 <dyl> Just operator precedence and recursive descent.
15:40:44 <Welkin> reading haskell papers from the 1990s
15:41:00 <dyl> Most of the APL papers are 70s. Some late 60s.
15:41:05 <CodeKiwi> Welkin that's a really elaborate and long intricate con, I like it!
15:41:09 <dyl> They’re all really bad fuzzy scans.
15:41:24 <Welkin> use OCR on them
15:41:26 <dyl> You can tell they were overprinted to include code samples because the code samples are skewed on the page.
15:41:37 <dyl> I don’t read papers on screen really.
15:41:40 <dyl> I just print them out.
15:41:42 <Welkin> then typeset them
15:42:08 <Welkin> people do this with novels
15:42:14 <Welkin> they scan and OCR them, then fix them by hand
15:42:21 <Welkin> and distribute them in plaintext + other formats
15:42:34 <dyl> Yeah. But I can just print them out.
15:42:38 <Welkin> it's a good way to preserve them
15:42:40 <abprof> speaking of emojis, what do you guys think about fancy characters in source code a la agda?
15:42:47 <Welkin> abprof: I hate it
15:42:54 <dyl> I don’t mind them much, with a proper input method.
15:42:55 <Welkin> it's impossible for me to type anything other than ascii
15:42:59 <dyl> I’m used to LaTeX.
15:43:06 <dyl> So I just use a LaTeX input method.
15:43:22 <glittershark> I wrote my first Agda over the weekend
15:43:32 <dyl> I also have a couple dozen &sub; style substitutions on all of my devices.
15:43:43 <dyl> e.g. ∀ ∃ ε etc
15:43:44 <glittershark> with agda2-mode in emacs it's pretty much no different than writing haskell with pretty-chars
15:43:52 <glittershark> \forall and forall aren't that different to type, in the end
15:43:54 <Welkin> yeah, I avoid that too
15:44:02 <Welkin> I tried using that mode that converts as you type
15:44:05 <glittershark> and \bN and Nat are the same number of keypresses!
15:44:06 <Welkin> it was a pain in the ass
15:44:09 <Welkin> it never does what you want it to
15:44:18 <hpc> in agda, value : type and Σ [value \: fn] are two different colon characters
15:44:28 <Welkin> then you have to get it set up on whatever machine you are using to use it
15:44:28 <hpc> er, Σ[
15:44:32 <Welkin> it's just useless
15:44:33 <dyl> 😂
15:44:57 <glittershark> I don't know agda very well at all so I don't know what the second is :P
15:45:03 <dyl> https://twitter.com/t3xtm0de/status/600711130324008961
15:45:30 <glittershark> I literally got stuck on a proof of \forall {n m} -> n - m + m \== n
15:45:32 <glittershark> so uh
15:45:35 <glittershark> lol
15:45:42 <glittershark> something something cong suc
15:46:00 <glittershark> anyway this is #haskell not #agda
15:46:05 <abprof> I liked how it looked but I had an issue with similar characters
15:48:24 <Welkin> vietcong?
15:49:22 <dyl> The big problem with Agda is that it’s not webscale.
15:49:31 <dyl> And the language makes it really hard to write a webserver.
15:49:35 <Welkin> is that it is illegible
15:49:48 <dyl> Someone actually did that though...
15:49:50 <dyl> https://github.com/larrytheliquid/Lemmachine
15:50:04 <abprof> my project is LTS-10.0 but a dependency of the project is LTS-9.6, will this cause weird problems?
15:50:15 <Welkin> yeah?
15:50:22 <Welkin> and there is a javascript backend for idris
15:50:29 <Welkin> but no one cares
15:50:34 <Welkin> because who would use it?
15:50:40 <glittershark> I'd use it
15:51:31 <enterprisey> the silliest question on earth
15:51:35 <enterprisey> view _1 is just fst right
15:51:58 <Welkin> yes but it works on any iterable thing
15:51:59 <Welkin> I think
15:52:07 <enterprisey> :t view _1
15:52:08 <Welkin> n-tuples
15:52:08 <lambdabot> (Field1 s s b b, MonadReader s m) => m b
15:52:12 <Welkin> fst only works on pairs
15:52:19 <Welkin> does it work on lists too?
15:52:26 <enterprisey> nah, that'd be head
15:52:28 <Welkin> > view _1 [1,2,3]
15:52:30 <lambdabot>  error:
15:52:30 <lambdabot>      • Could not deduce (Num a0)
15:52:30 <lambdabot>        from the context: (Num a, Field1 [a] [a] t t)
15:52:46 <Welkin> > view _1 (1,2)
15:52:48 <lambdabot>  1
15:52:51 <Welkin> > view _1 (1,2,3,4,5)
15:52:53 <lambdabot>  1
15:52:56 <Welkin> > fist (1,2,3,4)
15:52:58 <lambdabot>  error:
15:52:58 <lambdabot>      • Variable not in scope:
15:52:58 <lambdabot>          fist :: (Integer, Integer, Integer, Integer) -> t
15:52:58 <Welkin> > fst (1,2,3,4)
15:53:00 <lambdabot>  error:
15:53:00 <lambdabot>      • Couldn't match expected type ‘(a, b0)’
15:53:00 <lambdabot>                    with actual type ‘(Integer, Integer, Integer, Integer)’
15:53:01 <Welkin> see
15:53:04 <enterprisey> I see
15:53:24 <Tuplanolla> It works on things with finite fields, but not in the sense of abstract algebra.
15:53:47 <Tuplanolla> The name is a funny coincidence.
15:55:35 <Welkin> fst and snd are pretty uselss most of the time
15:55:40 <Welkin> pattern matching does the job better
15:58:20 <maerwald> :t fst . snd
15:58:21 <lambdabot> (a, (c, b)) -> c
15:58:44 <Welkin> that reminds me of caddadaddadr in lisp
16:00:28 <glittershark> here's a question
16:00:35 <Welkin> just ask
16:00:40 <Welkin> don't announce it
16:00:41 <glittershark> how horrible would it be to define `type f :$ g = f g`
16:00:47 <glittershark> aww be nice
16:01:02 <Welkin> we already have that
16:01:03 <Welkin> Compose
16:01:12 <hpc> Compose is type-level (.)
16:01:16 <hpc> i thought
16:01:21 <glittershark> no this isn't for functors
16:01:30 <glittershark> this is literally just ($) for types
16:02:05 <glittershark> x :: Vector :$ Either String Int
16:02:11 <glittershark> vs x :: Vector (Either String Int)
16:02:19 <Welkin> oh god no
16:02:21 <Welkin> please no
16:02:23 <glittershark> there we go
16:02:27 <Welkin> $ is abused enough as it is
16:02:28 <glittershark> that's the reaction I expected to elicit
16:02:31 <glittershark> :P
16:02:53 <Welkin> by people with an irrational aversion to parentheses
16:03:12 <glittershark> hi, I'm glittershark, and I have an irrational aversion to parentheses
16:03:16 <dyl> . . $ ⇐ dot dot goose
16:03:29 <glittershark> :t (.).(.).(.)
16:03:31 <lambdabot> (b -> c) -> (a1 -> a2 -> a3 -> b) -> a1 -> a2 -> a3 -> c
16:03:42 <dyl> Isn’t that :::.?
16:04:07 <Welkin> double blackbird?
16:04:17 <Welkin> there is a library for all of these composion functions already
16:04:20 <dyl> Singing in the dead of night~
16:04:32 <glittershark> http://hackage.haskell.org/package/data-aviary-0.4.0/docs/Data-Aviary-Birds.html
16:04:38 <Welkin> https://hackage.haskell.org/package/data-aviary-0.4.0/docs/Data-Aviary-Birds.html
16:04:43 <dyl> Take these stupid functions and learn to apply
16:04:51 <dyl> All your life, you were only waiting for your monads to be free
16:04:58 <Welkin> and here is the troll version https://hackage.haskell.org/package/data-emoticons-0.1.0/docs/Data-PopCulture-Emoticons.html
16:05:23 <glittershark> as if Data.Aviary.Birds wasn't already a troll version
16:05:44 <dyl> It’s higher order trolling.
16:05:44 <glittershark> this is just double troll
16:05:46 <glittershark> and I love it
16:05:46 <ystael> dyl: i groaned on the inside
16:05:57 <Welkin> the only one I see as valid to have a name is the blackbird
16:06:02 <glittershark> it's trolling in the category of trolls
16:06:08 <glittershark> yeah blackbird is nice
16:06:17 <dyl> A trolloid in the category of endotrolls*
16:06:21 <glittershark> I'm still trying to get my coworkers to let me define (...) = (.).(.)
16:06:30 <glittershark> omfg dyl
16:06:30 <zachk> isn't it more like troll fishing?
16:06:32 <ystael> the question is is it a left derived troll or a right derived troll
16:06:36 <Welkin> lol, `id` is called `idiot`
16:06:43 <dyl> Jokers to the left of me, clowns to the right
16:07:05 <glittershark> https://hackage.haskell.org/package/bifunctors-5/docs/Data-Bifunctor-Joker.html
16:07:18 <ystael> please someone give a conference talk on trollological algebra
16:07:38 <glittershark> as in all of haskell, if there's a pun to be made in the naming of a function, edwardk has published it as a library
16:07:39 <dyl> Wait sorry it’s clowns to the left, jokers to the right
16:07:46 <dyl> Got to get my McBride right
16:07:51 <edwardk> =)
16:07:59 <edwardk> mcbride named it, i just kept the name
16:08:08 <Welkin> edwardk: named what?
16:08:10 <dyl> I was just about to link bifunctors and thinking to myself
16:08:12 <glittershark> true, for that one
16:08:18 <dyl> “Edwardk is going to show up suddenly.”
16:08:21 <Welkin> oh, Joker?
16:08:21 <edwardk> mind you that same package has a 'Biff' type so that i can have a bifunctor-functor-functor wrapper. so it logically has a type named 'Tannen' to go with it.
16:08:21 <dyl> Every time!
16:08:32 <dyl> I just saw that, love it.
16:08:41 <dyl> https://hackage.haskell.org/package/bifunctors
16:08:42 <glittershark> oh is *that* where tannen comes from!
16:08:45 <dyl> For those wondering.
16:08:50 <edwardk> its really the same construction as 'Cayley' with a slight moral difference in its usage pattern
16:09:32 <dyl> Still one of my favorite (trollish) papers:
16:09:33 <dyl> https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf
16:09:35 <glittershark> it's hit the point where "ed kmett that cheeky bastard" is a meme in our office
16:09:49 <edwardk> =)
16:09:52 <glittershark> last time it was around `hasn't`
16:10:01 <dyl> “This article considers whether ’tis nobler in the mind to suffer the slings and arrows of outrageous fortune, or to take arms against a C of troubles.”
16:10:21 <edwardk> there is also 'is' and 'isn't' in the Control.Lens.Extras
16:10:21 <dyl> Godspeed, you glorious bastard [McBride].
16:10:38 <dyl> There’s also “don’t” in ACME.Dont
16:10:46 <dyl> It... doesn’t.
16:10:57 <MarcelineVQ> don't it?
16:11:48 <dyl> They don’t think it be like it is, but it do.
16:13:07 <dyl> edwardk: we need to send you undercover with an alias into the JavaScript community
16:13:51 <glittershark> it takes a fine hand to turn "naming things is hard" into "naming things is fun"
16:14:20 <dyl> The FP community largely solves the hard naming problem by just delegating the problem to mathematicians.
16:14:42 <dyl> If only that worked for caching too.
16:15:22 <dyl> glittershark: I find the trick to naming things (which I use to avoid getting stuck when working on my own projects) is to just use silly but consistent names.
16:15:37 <dyl> Don’t take them too seriously, just make sure there is some internal consistency to them.
16:16:15 <dyl> Or I pick a theme for a project and name from there. For example: a city, and then use landmarks or street names from that city.
16:16:20 <fishythefish> similarly, cache invalidation is solved by always treating your cache as invalid
16:16:20 <dyl> Renaming/refactoring is easy.
16:16:21 <shachaf> Is that one type in profunctors still called Forget?
16:16:53 <dyl> edwardk: how often do you get emails from people using your libraries in production(
16:16:56 <dyl> ?*
16:16:56 <lambdabot> Maybe you meant: v @ ? .
16:17:11 <shachaf> Looks like it.
16:17:40 <shachaf> You have to watch out when you give a type a joke name around edwardk.
16:17:56 <maerwald> we have Joker, right?
16:18:24 <dyl> Joker, Clown, Biff, and Tannen
16:18:33 <dyl> Noticeable lack of Marty and McFly
16:18:59 <dyl> edwardk: it just occurred to me that Biff and Tannen actually work really well as his character was based on Trump
16:19:06 <dyl> So it fits the theme somewhat.
16:20:08 <maerwald> https://hackage.haskell.org/package/bifunctors-5.5.2/docs/Data-Bifunctor-Joker.html
16:20:11 <maerwald> bifunctor it was
16:21:18 <maerwald> Batman is missing though
16:21:43 <fishythefish> Batmen to the left of me, Jokers to the right?
16:21:56 <dyl> Sounds like Two-Face is involved.
16:22:21 <dyl> We’ll also need a poisonId function.
16:22:43 <zachk> mr freeze!
16:22:51 <dyl> ICE. IS NICE.
16:26:32 <CodeKiwi> I'm not saying I'm batman but nobody has ever seen us in the same room together
17:05:31 <dyl> CodeKiwi: I’m not saying I’m Nancy Reagan, but no one has ever seen us in the same room together.
17:06:11 <CodeKiwi> and they never will
17:06:46 <Welkin> Lamar Burton
17:06:59 <Welkin> LeVar*
17:07:08 <abprof> I'm not saying I'm self respect b
17:07:08 <Welkin> haha
17:07:16 <Welkin> his real first name is Levardis
17:07:37 <Sulis> O.o
17:07:56 <Welkin> and he played Kunta Kinte?
17:08:38 <Sulis> and...
17:08:52 <Sulis> himself in TBBT
17:09:32 <dyl> (:).($) in the sky~
17:09:52 <Welkin> lucy in the sky with diamonds?
17:10:06 <dyl> No, cons-apply in the sky
17:10:48 <Welkin> moon men?
17:11:07 <Welkin> https://www.youtube.com/watch?v=TgqiSBxvdws
17:11:16 <Welkin> obviously ripped off of Lucy in the sky with diamonds
17:12:10 <dyl> Tricky Dick in the sky, for the prez it’s not a crime
17:12:12 <dyl> Take a look
17:12:14 <dyl> I’m not a crook
17:12:24 <Welkin> is that lil' wayne?
17:12:44 <dyl> No, it’s my horrible Richard Nixon take off of the Reading Rainbow theme.
17:16:17 <dyl> Read it in the Futurama version of his voice
17:16:41 <dyl> (And imagine harmonies from Headless Agnew)
17:22:52 <demonslayer[m]> No superheroes anywhere...nope just fappers and people that dont work for me
17:38:17 <Axman6> demonslayer[m]: you ok?
17:42:27 --- mode: glguy set -q *!*@207.244.109.180
18:13:43 <droplet> @hoogle Monad m => m a -> m [a]
18:13:44 <lambdabot> Control.Monad.HT repeat :: (Monad m) => m a -> m [a]
18:13:44 <lambdabot> Control.Monad.Tools repeatM :: Monad m => m a -> m [a]
18:13:44 <lambdabot> Data.Edison.Seq.ListSeq ltailM :: (Monad rm) => [a] -> rm [a]
18:20:06 <byorgey> droplet: you may be looking for 'many'
18:20:11 <byorgey> @type many
18:20:12 <lambdabot> Alternative f => f a -> f [a]
18:23:32 <droplet> ah, thanks!
18:24:14 <droplet> hm, i'm doing this in the IO monad and that doesn't seem to work in this particular case...
18:25:19 <droplet> actually never mind, i'm not entirely sure what i want this to look like
18:26:07 <jle`> 💧 yeah, it helps to think about what operation you actually want
18:26:14 <jle`> 💧 maybe something like replicateM ?
18:26:20 <jle`> :t replicateM 10
18:26:21 <lambdabot> Applicative m => m a -> m [a]
18:27:58 <byorgey> or maybe some sort of whileM/untilM sort of thing?
18:29:01 <byorgey> jle`: are those... tears?
18:29:25 <jle`> it's my irc client's emoji text replace
18:29:30 <jle`> when i type out droplet 's name
18:29:32 <jle`> with a colon, heh
18:29:42 <byorgey> hahaha, I see =)
18:29:51 <jle`> i wonder why i even have that enabled ...
18:30:29 <jle`> :t fmap fromJust . runMaybeT . many . MaybeT
18:30:30 <lambdabot> Monad f => f (Maybe a) -> f [a]
18:30:56 <jle`> fromJust is always safe because many always 'succeeds', but i'm kind of sad that there's no way to express this in the type system
18:37:56 <droplet> jle: yeah i was looking for some kind of infinite replicateM
18:38:12 <jle`> 💧 'forever' ?
18:38:15 <jle`> :t forever
18:38:16 <lambdabot> Applicative f => f a -> f b
18:38:34 <jle`> 💧 unless you want to collect the results
18:38:39 <droplet> yeah i want the results
18:38:46 <jle`> there is an issue with this for IO
18:38:59 <droplet> what's the specific issue, out of interest?
18:39:26 <jle`> technically, any `IO [a]` has to execute all of its effects/actions *before* you can access the results
18:39:41 <jle`> the exception is lazy IO, which is tricky
18:39:45 <droplet> hmm but it was fine with replicateM
18:39:46 <droplet> ah
18:40:27 <jle`>  droplet: the picture you had might have been being able to bind an infinite list, and, as you *evaluate* each item in the list, IO happens as a side-effect
18:40:31 <jle`> as an implicit side-effect
18:40:45 <jle`> you might be able to see why that might be problematic
18:40:57 <droplet> yeah
18:41:03 <jle`> your IO is triggered remotely by simply pattern matching on the result
18:41:20 <droplet> is that also why replicateM 10000 took time to start displaying results?
18:41:38 <jle`> yeah
18:41:47 <droplet> but replicateM 10 started instantly and took time between each result
18:41:51 <jle`> one analogy that I sometimes fall back to is the Monad instance for Maybe
18:41:57 <pavonia> droplet: What are you trying to implement that needs to handle infinte lists with IO?
18:42:06 <jle`> % :t replicateM @Maybe 100
18:42:07 <yahb> jle`: Maybe a -> Maybe [a]
18:42:25 <jle`> to be able to access the *head* of the result, you have to be able to know that *all* of the actions return Just
18:42:32 <jle`> because you have to know if the Maybe you get is Just or Nothing
18:42:42 * hackage warp 3.2.21 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.2.21 (KazuYamamoto)
18:42:44 <jle`> and there isn't any way to know that unless you seqeunce 'all' of the Maybe's
18:42:56 <droplet> pavonia: it doesn't really need to, i was just curious to see if i could
18:42:57 <jle`> there is no way to just get the head first without going through all 10000 Maybe sequences
18:43:16 <droplet> jle`: that makes sense!
18:43:18 <jle`> because in order to even get the head, you have to figure out if the result is Nothing or Just
18:43:39 <jle`> IO is the same, in that the results you get might depend on the effects some time down the line, so you have to resolve all of the effects before you can get at the results
18:43:48 <jle`> > isJust $ forever Nothing
18:43:50 <lambdabot>  False
18:43:53 <jle`> oops
18:43:58 <jle`> > isJust $ forever (Just 1)
18:44:00 <lambdabot>  *Exception: <<loop>>
18:44:22 <jle`> > head <$> replicateM 1000000 (Just 1)
18:44:24 <lambdabot>  Just 1
18:44:28 <jle`> > head <$> replicateM 100000000000000 (Just 1)
18:44:35 <lambdabot>  mueval-core: Time limit exceeded
18:44:36 <lambdabot>  mueval: ExitFailure 1
18:45:12 * hackage wai-app-file-cgi 3.1.6 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-3.1.6 (KazuYamamoto)
18:45:15 <jle`> 💧 lazy IO is a sort of hack to allow the sort of behavior you are thinking of, but it's considered unsafe for all but the most simple usages
18:45:20 <droplet> i see!
18:45:39 <droplet> i didn't know about the @Maybe syntax you used earlier
18:45:45 <droplet> is that documented somewhere?
18:45:56 <jle`> it's the TypeApplications syntax
18:46:12 <Axman6> it's pretty new and super handy
18:46:28 <jle`> if you want to experiment with IO-unsafely-executed-based-on-evaluation-of-values, the behavior you want is given by unsafeInterleaveIO in System.IO.Unsafe
18:46:43 * hackage mighttpd2 3.4.3 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.4.3 (KazuYamamoto)
18:47:10 <jle`> and the fact that it's called "unsafe" should give you a hint that it could definitely result in unexpected consequences
18:47:41 <droplet> yeah i think i'll leave that for now!
18:48:01 <droplet> so in the replicateM 10 case for IO, why was it still taking time between printing each list element
18:48:10 <droplet> if it had to compute them all beforehand
18:48:11 <jle`> 💧 "meaningful sequential/composabe IO by demand" is the problem that pipes/conduits was meant to solve, but in the simple case, it's probably best to just use a recursive function
18:48:21 <jle`> 💧 hm, that I am unsure of
18:48:41 <jle`> it might be the that the IO action you gave was already 'lazy IO'/unsafeIntereaveIO'd
18:48:50 <jle`> what was the action you tested?
18:50:09 <droplet> it was creating a random graph, then finding the largest clique in it
18:50:55 <jle`> hm, maybe one thing is that the IO action itself was short, but evaluating the result after the initial IO took a while
18:51:02 <jle`> maybe one possiblity, i mean
18:51:29 <jle`> i'm not sure how "lazy" fmap is, but if you fmap a complex function over a simple IO action, it might perform the IO immediately but take a while when youa ctually show the result
18:51:45 <droplet> yeah, that would match this
18:51:45 <jle`> let me test ...
18:52:21 <jle`> yeah, that seems to be what happens
18:52:40 <jle`> if i do x <- sum . enumFromTo 1 <$> readLn on my ghci
18:52:49 <jle`> the IO part ends as soon as I give a number
18:52:52 <jle`> but when i print x, it takes a while
18:53:57 <jle`> % bigSum <- sum . enumFromTo 1 <$> return 1000000
18:53:57 <yahb> jle`:
18:54:01 <jle`> % bigSum
18:54:02 <yahb> jle`: 500000500000
18:54:10 <jle`> darn you yahb for being so fast
18:54:16 <jle`> % bigSum <- sum . enumFromTo 1 <$> return 100000000000
18:54:17 <yahb> jle`:
18:54:19 <jle`> % bigSum
18:54:21 <yahb> jle`: *** Exception: heap overflow
18:55:03 <jle`> 💧 this is why 'evaluate' is sometimes useful from Control.Exception
18:55:22 <jle`> or 'evaluate . force', if your data type is nested and has an NFData instance
18:55:52 <jle`> evaluate makes sure that the evaluation of the result happens at the same time as the IO effects, and blocks IO until evaluation is done
18:56:07 <jle`> % bigSum <- evaluate . sum . enumFromTo 1 =<< return 100000000000
18:56:08 <yahb> jle`: *** Exception: heap overflow
18:56:46 <jle`> so if you do `replicateM 10 . evaluate`, it'll block until the IO happens and the results are evaluated (to whnf)
18:56:58 <jle`> % :t replicateM 10 . evaluate
18:56:58 <yahb> jle`: a -> IO [a]
18:59:58 <jle`> % :t replicateM 10 . (evaluate =<<)
18:59:59 <yahb> jle`: IO a -> IO [a]
19:12:07 <abprof> Any news on dependent haskell? The ghc wiki entry hasn't been edited in 5 months, it seems
19:19:12 * hackage crc 0.1.0.0 - Implements various Cyclic Redundancy Checks (CRC)  http://hackage.haskell.org/package/crc-0.1.0.0 (MichaelXavier)
19:19:30 <Welkin> matrix problems again huh
19:20:18 <ackthet> life is just a series of matrix problems
19:34:42 * hackage tweet-hs 1.0.1.39 - Command-line tool for twitter  http://hackage.haskell.org/package/tweet-hs-1.0.1.39 (vmchale)
20:05:12 <blonkhart> ever since the struggle from the womb
20:05:21 <blonkhart> (etymology joke anyone?)
20:24:56 <sqooq> quit
20:25:07 <sqooq> woops
20:27:02 <Zipheir`> But I don't want to quit. :(
20:27:24 <abprof> :[
20:48:22 <ania123> hi all
20:51:16 <ania123> is here any english speaker
20:52:52 <rotaerk> ania123, most people here speak english
20:53:59 <CodeKiwi> rotaerk are you sure about that how can you say that I have only heard like...3 people here speak ever
21:57:07 <enterprisey> How does the (Ord a, Ord b) => Ord (a, b) instance work? Does it compare on the first member first, then go to the second member to break ties?
21:57:14 <enterprisey> I assume so, but I can't find the source code on stackage
21:57:43 <cocreature> enterprisey: yep that’s exactly how it works
22:00:57 <enterprisey> excellent
22:02:36 <enterprisey> from some testing by hand, I believe that https://stackoverflow.com/a/28191224/1757964 always gives lists in ascending order
22:02:52 <enterprisey> if xs is in ascending order - does this seem correct?
22:10:51 <jle`> @tell blonkhart i get it
22:10:51 <lambdabot> Consider it noted.
22:11:12 * hackage teardown 0.4.1.0 - Build safe and composable teardown sub-routines for resources  http://hackage.haskell.org/package/teardown-0.4.1.0 (RomanGonzalez)
22:11:29 <mniip> %% :info Ord
22:11:30 <yahb> mniip: http://qp.mniip.com/y/47
22:11:50 <jle`> enterprisey: yes, that's how tails works
22:11:54 <enterprisey> wonderful
22:11:56 <enterprisey> ty
22:12:01 <jle`> > tails "hello"
22:12:01 <mniip> oh good golly
22:12:02 <lambdabot>  ["hello","ello","llo","lo","o",""]
22:12:12 <mniip> I think I've updated libc and now it's broken
22:12:45 <jle`> %% mapM_ putStrLn . replicateM 10 $ "01"
22:12:45 <yahb> jle`: http://qp.mniip.com/y/48
22:12:51 <jle`> oops
22:18:16 <Zipheir> tails output on strings always looks like a fading echo.
22:22:29 <johnw> perhaps fadingEcho would be a reasonable alternate name
22:23:51 <CodeKiwi> > fadingEcho = tails
22:23:53 <lambdabot>  <hint>:1:12: error:
22:23:53 <lambdabot>      parse error on input ‘=’
22:23:53 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
22:24:07 <CodeKiwi> :(
22:25:11 <Zipheir> fadingEcho is the alternate function that transforms fadingEcho "I'm an idiot" into tails "You're an idiot"
22:26:57 <mniip> fixed the libc
22:28:08 <mniip> enterprisey, regarding your qquestion about source on hackage
22:28:15 <mniip> see the deriving instance here: https://hackage.haskell.org/package/base-4.4.1.0/docs/src/GHC-Classes.html
22:28:19 <jle`> %% mapM_ putStrLn . replicateM 10 $ "01"
22:28:20 <yahb> jle`: http://qp.mniip.com/y/52
22:28:31 <jle`> neat
22:29:15 <clodeindustrie> hi there complete Haskell rookie here, I am trying to use Database.PostgreSQL.Simple but without success, I don't seem to be doing the translation from Pg type to Haskell type properly http://lpaste.net/365238
22:29:31 <mniip> the derived instance for a single-constructor datatype always goes like
22:29:50 <mniip> compare (Con a1 a2 a3) (Con b1 b2 b3) = compare a1 b1 <> compare a2 b2 <> compare a3 b3
22:30:26 <mniip> using, of course, the Ordering monoid
22:30:29 <CodeKiwi> yeah well I haven't written a lua program in years and have been trying hard to learn haskell for a few months  but really for years and today I had an idea for a program and I wrote it while sleep deprived in lua in a few hours and I tried doing it in haskell and got like 5 lines written and they're not even right so definitely am idiot :(
22:30:54 <mniip> CodeKiwi, what's the program
22:31:01 <clodeindustrie> Examples I have used don't seem to be doing anything special compares to what I am doing
22:31:05 <CodeKiwi> http://lpaste.net/2876139607274029056
22:32:25 <CodeKiwi> I'm like 99% sure that is nothing like how I would have done it years ago so maybe something has changed in my noggin
22:33:13 <mniip> CodeKiwi, hold on let me sketch up a thing
22:33:39 <cocreature> clodeindustrie: what exactly is causing problems? do you get a compile error, a runtime error, what’s the full error message, …?
22:34:12 <clodeindustrie> The error message is at the top of my http://lpaste.net/365238
22:34:15 <clodeindustrie> when compiling
22:34:26 <clodeindustrie> scratch that, it's when running the app
22:35:21 <cocreature> clodeindustrie: try adding a type annotation to bookmark on line 59
22:35:53 <cocreature> clodeindustrie: currently you are calling putStrLn on it which tells GHC that bookmark must be of type String = [Char] so it tries to decode res as a list of Chars
22:42:46 * hackage bitwise 1.0.0.1, bitwise 0.2 (ClaudeHeilandAllen): https://qbin.io/intel-thong
22:43:05 <clodeindustrie> cocreature: ha, nice, I thought it was something along those lines but didn't know where exactly
22:43:21 <clodeindustrie> cocreature: so something like this forM_ res $ \(bookmark) -> putStrLn bookmark::Bookmark
22:43:31 <cocreature> you need parenthesis around the type annotation
22:43:50 <cocreature> and this type annotation will result in a type error since now bookmark :: Bookmark but putStrLn expects something of type String
22:44:12 <cocreature> so you first need to convert bookmark to a String using "show" or you can use "print" which is just "putStrLn . show"
22:46:03 <clodeindustrie> cocreature: ! cool, in my head the conversion to string was done implicitely because I derive Show on Bookmark, I was wrong :)
22:46:23 <cocreature> clodeindustrie: Haskell never does implicit conversions
22:46:47 <clodeindustrie> yay that works
22:46:58 <clodeindustrie> thanks a lot cocreature
22:47:24 <clodeindustrie> good thing to know [15:46] <cocreature> clodeindustrie: Haskell never does implicit conversions
22:58:07 <mniip> CodeKiwi, http://tcpst.net/668c
22:58:12 <mniip> simple enough
22:59:27 <CodeKiwi> I haven't even heard of most of those language extensions
23:07:05 <mniip> but you can write fancy stuff like
23:07:18 <mniip> convert @"KB" (Unit @"GB" 10)
23:07:30 <mniip> (I think, I haven't gotten TypeApplications in this ghci)
23:10:35 <abprof> Every time I think I'm getting the hang of this language someone posts something like mniip just did
23:10:48 <mniip> haha
23:10:57 <dminuoso> CodeKiwi: You will soon enough. These things should be in the next Haskell report by default :P
23:11:27 <CodeKiwi> I haven't even finished the first one
23:11:47 <mniip> abprof, you know, there was a talk (by, iirc, bitemyapp) titled "How to learn haskell in under 5 years"
23:12:02 <CodeKiwi> yeah it was him I watched it the other day
23:12:10 <mniip> https://www.youtube.com/watch?v=Bg9ccYzMbxc
23:12:17 <mniip> oops
23:12:28 <dminuoso> In all fairness, mniip's code doesn't look too hard to grasp.
23:12:29 <abprof> haha that's gold
23:12:45 <mniip> it's hardly a joke though
23:12:50 <mniip> there's so much to this language...
23:13:37 <mniip> I've been 5 years in and I think I can see the end, but there's still so much to learn
23:13:47 <boj> yeah, seriously
23:14:11 <jle`> i'll be sad the day i learn 'all of haskell'
23:14:18 <dminuoso> It's one of the things I like about Haskell. Not the fact that it's so deep, but that you can write meaningful programs _without_ any of these crazy features.
23:14:25 <mniip> jle`, worry not, new haskell will be made
23:14:47 <mniip> it is made continuously
23:14:53 <abprof> I was excited for dependenthaskell since I was told it would consolidate many of the advanced features of the language into a more approachable format
23:15:23 <dminuoso> I tried wrapping my head around TypeInType.. it's so confusing..
23:15:43 <jle`> TypeInType makes things kind of less confusing to me i think
23:15:52 <jle`> no such thing as a 'kind' anymore
23:15:57 <jle`> it's all just types :)
23:16:10 <cocreature> types all the up instead of turtles all the way down
23:16:11 <jle`> (this is a lie)
23:16:35 <jle`> types all the way up, except for one frustrating final wall
23:17:41 <mniip> hmm, in ghci, can you load "another" module?
23:18:06 <mniip> like, leaving everything in scope and adding symbols from another module
23:18:39 <jle`> isn't that what normal importing/:l does?
23:19:01 <mniip> no doesn't look like :l does that
23:19:39 <mniip> also it isn't really a module per se
23:19:41 <mniip> just a haskell file
23:19:49 <CodeKiwi> I'm really tired I need to sleep and look at this later, thanks mniip I'll try and make sense of it in the morning or w/e I wake up
23:19:59 <noan> Morning folks. I was wondering if anyone knew of a decent graphics lib for haskell? Was thinking of writing a little game engine or something and wanted to get something like an SDL wrapper or whatever
23:20:03 <noan> Any thoughts?
23:20:27 <cocreature> mniip: :module + Mod.hs?
23:20:37 <abprof> not practical, but this would be really awesome noan: https://hackage.haskell.org/package/reflex-sdl2
23:20:48 <mniip> that doesn't work for me
23:21:06 <cocreature> what’s the error?
23:21:09 <abprof> I don't even know if that library works, I haven't tried it
23:21:13 <mniip> syntax:  :module [+/-] [*]M1 ... [*]Mn
23:21:14 <abprof> Just a thought
23:21:26 <cocreature> oh remove the .hs
23:21:47 <mniip> same error
23:22:36 <noan> abprof, thanks XD
23:22:40 <cocreature> mniip: huh, maybe try :add?
23:22:54 <mniip> oh that works
23:23:08 <cocreature> but :module + Mod should at least complain a missing module rather than a syntax error
23:23:56 <abprof> noan: I do what i can XD
23:25:13 <fishythefish> mniip, cocreature: any chance the file begins with a lowercase letter? you'll only get a missing module error if it starts with a capital, like a module name should
23:25:36 <fishythefish> filename begins*
23:25:59 <mniip> fishythefish, yeah
23:26:05 <cocreature> ah yeah good catch
23:26:05 <mniip> it's not a valid "module"
23:31:10 <mniip> hmm
23:31:20 <mniip> thinking of adding lpaste support yo yahb
23:31:57 <mniip> to*
23:32:28 <cocreature> you might want to make sure that lpaste will keep running or use github gists instead otherwise. chris recently said he will shut it down if nobody takes it over
23:32:47 <mniip> doesn't really matter what pastebin site it is
23:33:00 <mniip> I'm devising the technological solution
23:33:14 <cocreature> right I’m just saying, save yourself the work of first implementing it for lpaste only to then have to migrate it :)
23:33:34 <mniip> not sure if replacing a URL can be considered migrating :P
23:34:33 <dminuoso> jle`: Well so far the only truly confusing construct without it is TYPE
23:34:59 <dminuoso> I wonder whether you can actually construct such things in plain Haskell with TypeInType
23:35:22 <jle`> what things?
23:36:11 <dminuoso> Well TYPE is some weird `Kind -> Box` construct
23:36:44 <dminuoso> If that notation makes any sense.
23:36:54 <jle`> are you talking about levity polymorphism?
23:37:41 <dminuoso> :k (->)
23:37:42 <lambdabot> TYPE q -> TYPE r -> *
23:37:51 <dminuoso> jle`: ^- if you look closely `TYPE` should not be able to exist.
23:38:28 <jle`> % :k (->)
23:38:28 <yahb> jle`: (->) :: TYPE q -> TYPE r -> *
23:38:38 <jle`> dminuoso: hm, why do you say so?
23:38:42 <jle`> % :set -XTypeInType
23:38:43 <yahb> jle`:
23:38:45 <jle`> % :k (->)
23:38:45 <yahb> jle`: (->) :: TYPE q -> TYPE r -> *
23:39:16 <dminuoso> jle`: In what universe does `TYPE` live? Is it a kind level construct?
23:41:07 <jle`> it's just on the same level as normal types
23:41:29 <jle`> there is just one level of types/kinds/etc., in TypeInType
23:42:04 <dminuoso> jle`: I know. I was just saying without TypeInType it should not be able to exist.
23:42:22 <jle`> ah yeah.
23:43:03 <jle`> i remember we had somethign called 'sorts'?
23:43:55 <dminuoso> Right, that's the universe above kinds.
23:44:03 <dminuoso> And all kinds we have and love have sort "box"
23:46:59 <dminuoso> Or spelled "BOX" I believe
23:47:24 <dminuoso> https://ghc.haskell.org/trac/ghc/wiki/GhcKinds o.o
23:47:42 * hackage pandoc-citeproc 0.14.3.1 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.14.3.1 (JohnMacFarlane)
23:55:33 <robstr> morning :)
23:58:07 <raxor199> morning to you :)
