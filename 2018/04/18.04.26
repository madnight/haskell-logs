00:03:16 <nshepperd> :k TYPE
00:03:17 <lambdabot> error:
00:03:18 <lambdabot>     Not in scope: type constructor or class ‘TYPE’
00:03:45 <jle`> % :k TYPE
00:03:45 <yahb> jle`: TYPE :: RuntimeRep -> *
00:04:52 <nshepperd> hm
00:05:21 <nshepperd> that kind certainly doesn't make sense without TypeInType
00:07:15 <nshepperd> * = TYPE LiftedRep :: *
00:11:02 <nshepperd> :t Nothing :: Maybe *
00:11:03 <lambdabot> error:
00:11:03 <lambdabot>     Not in scope: type constructor or class ‘*’
00:11:03 <lambdabot> error:
00:30:35 <dminuoso> nshepperd: the best part about it is the name "TYPE"
00:47:35 <dminuoso> By th eway, is a CoProfunctor a thing?
00:48:17 <dminuoso> I mean that would be some `class CoProfunctor f where dimap f a d -> f b c -> (d -> c) -> (b -> a)` right?
00:48:39 <dminuoso> @let class CoProfunctor f where codimap :: f a d -> f b c -> (d -> c) -> (b -> a)
00:48:40 <lambdabot>  Defined.
00:51:37 <dibblego> that looks like Profunctor with the type constructor flipped
00:53:36 <dminuoso> dibblego: How is that Profunctor?
00:53:41 <dminuoso> I mean what if we just looked at say
00:53:56 <dminuoso> @let class CoFunctor cf where cofmap :: f a -> f b -> a -> b
00:53:57 <lambdabot>  .L.hs:163:9: error:
00:53:57 <lambdabot>      • Could not deduce (CoFunctor cf0)
00:53:57 <lambdabot>        from the context: CoFunctor cf
00:54:00 <dibblego> with the type constructor flipped
00:54:30 <dminuoso> @let class CoFunctor cf where cofmap :: cf a -> cf b -> a -> b
00:54:31 <lambdabot>  Defined.
00:55:02 <dminuoso> Mmm this is just a regular functor isnt it?
00:55:16 <dibblego> I have no idea what that is.
00:55:40 <dibblego> functor f is (a -> b) -> f a -> f b, with identity and composition laws
00:55:51 <dminuoso> I got an idea. If this is a category theory thing, edward must have a library with this in it.
00:59:21 <dminuoso> Mmm, some books use cofunctor to simply denote covariant functor.
00:59:37 <dminuoso> or contravariant actually
01:02:46 <liste> that doesn't sound right :/
01:06:30 <cocreature> dminuoso: maclane does not approve ):mac
01:06:33 <cocreature> *:)
01:07:57 <dminuoso> cocreature: Mmm. Is `f a -> f b -> a -> b` possibly a thing though for some particular choice of `f` ?
01:07:57 <JuanDaugherty> functor is highly context dependent why wouldn't co be?
01:08:32 <cocreature> dminuoso: do you mean (f a -> f b) -> a -> b instead?
01:08:54 <dminuoso> Mm. Oh it would have to be, yeah.
01:09:28 <cocreature> I somewhat doubt that’s a thing for non-trivial choices of f
01:13:32 <tsahyt> is there some way to tell GHC to flatten out the runtime representation of nested records?
01:14:03 <cocreature> tsahyt: {-# UNPACK #-}
01:14:16 <tsahyt> ah so that will also unpack an entire "sub"record?
01:14:47 <cocreature> it will only unpack one level, if you want to unpack the values in that record as well, you need to add unpack pragmas there too
01:14:55 <cocreature> also note that your fields must be strict for this to work
01:14:59 <merijn> tsahyt: unpack removes the pointer indirection to a field inside a record
01:15:12 <tsahyt> cocreature: yes, I expected as much
01:15:22 <merijn> tsahyt: So if you unpack all datatypes transitively in your record it should flatten the entire thing, yes
01:15:38 <tsahyt> speaking of unpack, what if I have a type variable in a field. e.g. data Foo = { foo :: {-# UNPACK #-} !a }
01:15:45 <merijn> tsahyt: You can't
01:15:46 <tsahyt> umm, Foo a on the left hand side
01:15:51 <merijn> tsahyt: You'll get a compile error
01:15:52 <cocreature> meh, why is their no Map.fromListWithA
01:16:08 <merijn> cocreature: What's the type you're wanting for that?
01:16:28 <tsahyt> merijn: last time I tried I didn't get an error
01:16:30 <tsahyt> let's see
01:16:43 <cocreature> merijn: Applicative f => (b -> b -> f b) -> [(a, b)] -> f (Map a b)
01:17:16 <cocreature> I’ll just do it separately but it feels like this should exist
01:17:30 <tsahyt> merijn: nope, compiles just fine
01:17:32 <merijn> cocreature: Can't you repurpose one of the ridiculously general functions
01:17:42 <tsahyt> using GHC 8.2.2
01:17:50 <tsahyt> I know that it at least used to give an error, I've seen it before
01:18:01 <merijn> tsahyt: That's...odd, can you check the kind of Foo in GHC?
01:18:10 <tsahyt> * -> *
01:18:32 <merijn> heh
01:18:35 <merijn> That seems wrong
01:18:40 <merijn> can you lpaste the code?
01:18:42 * hackage http-reverse-proxy 0.6.0 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.6.0 (MichaelSnoyman)
01:18:54 <jle`> cocreature: fromListWith + sequence
01:19:00 <jle`> *sequenceA
01:19:03 <cocreature> jle`: right that’s what I’m doing now
01:19:07 <tsahyt> merijn: it's just data Foo a = Foo { foo :: {-# UNPACK #-} !a, bar :: {-# UNPACK #-} !a }
01:19:38 <jle`> doesn't sound too bad
01:19:47 <merijn> tsahyt: Yes, but I'm too lazy to type that to try :p
01:19:53 <tsahyt> heh okay
01:20:09 <jle`> although it might need to be Monad f
01:20:27 <cocreature> yeah, I ended up with "fromListWithA combine xs = sequence (Map.fromListWith (\x y -> join (liftA2 combine x y)) (map (second pure) xs))"
01:20:35 <tsahyt> merijn: http://lpaste.net/365242
01:20:47 <cocreature> which seems sufficiently complicated that it would be nice for it to exist already :)
01:21:09 <jle`> if you named something like
01:21:25 <merijn> tsahyt: I'm really suspicious about what's going on here
01:21:39 <jle`> liftA2' f x y = join (liftA2 f x y), then it might not be too bad
01:21:42 * hackage yesod-bin 1.6.0.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.6.0.1 (MichaelSnoyman)
01:22:00 <tsahyt> merijn: well I for one would gladly accept if GHC was smart enough to specialize data constructors now to do unpacking
01:22:02 <cocreature> tsahyt: I’ve never seen that give an error
01:22:04 <jle`> but yeah i geuss it might feel messy even though the underlying idea is clean
01:22:06 <tsahyt> but I haven't heard anything about it
01:22:24 <merijn> cocreature: I have
01:22:30 <merijn> cocreature: It was really annoying
01:22:45 <tsahyt> cocreature: I might be misremembering, but I certainly did get errors or at least warnings from {-# UNPACK #-}. it might have been with nonstrict fields, but I think it was with polymorphic ones
01:23:02 <cocreature> I vaguely remember the error for nonstrict fields
01:23:42 <merijn> tsahyt, cocreature: Looks like unpack only happens with -O
01:23:52 <cocreature> right
01:24:01 <tsahyt> oh
01:24:11 <osa1> UNPACK pragma only works with -O. with -O0 UNPACK is ignored and no warnings are generated
01:24:22 <osa1> (I know it's bad, IIRC there's a ticket about this)
01:24:32 <cocreature> osa1: ah ok
01:26:01 <tsahyt> I suppose there's also no way to generate specialized code for data constructors?
01:26:04 <osa1> https://ghc.haskell.org/trac/ghc/ticket/11270
01:26:12 <tsahyt> i.e. no way to have my cake and eat it too
01:26:22 <osa1> heh, it's my ticket
01:27:28 <merijn> osa1: It's a sign you should go fix it! ;)
01:27:59 <osa1> merijn: tbh this sounds very easy to fix, not sure why I haven't yet!
01:28:13 <tsahyt> does unpacking work in sum types?
01:28:13 <cocreature> osa1: famous last words :)
01:28:18 <osa1> haha :)
01:28:30 <osa1> tsahyt: not yet
01:28:34 <tsahyt> okay
01:28:38 <osa1> tsahyt: https://phabricator.haskell.org/D2424
01:29:13 <tsahyt> hm intero doesn't spit out the warning either
01:29:33 <osa1> does it use ghci? there's no way to get UNPACK warnings in GHCi at the moment
01:29:36 <merijn> tsahyt: Presumably because intero builds with -O0 to compile faster
01:29:43 <osa1> or that
01:29:53 <cocreature> both probably :)
01:29:54 <tsahyt> I've tried setting -O, but it tells me that it conflicts with --interactive
01:29:56 <tsahyt> and thus ignores it
01:30:18 <tsahyt> I suppose that would be fixed if the first ticket here was fixed :)
01:30:24 <osa1> yeah
01:30:33 <tsahyt> I generally rely on ghci/intero to give me all warnings
01:30:33 <osa1> show some support in the ticket if you need it fixed!
01:30:43 <merijn> ghci totally gives unpack warnings and supports -O, you just need to run it with -fobject-code
01:31:12 <tsahyt> merijn: what does that do again?
01:31:24 <merijn> tsahyt: it...uses object code? :p
01:31:52 <merijn> tsahyt: By default ghci runs interpreted bytecode, rather than compiling and loading machine code, but it can compile and load machine code just fine
01:32:00 <merijn> Just gotta ask nicely
01:32:01 <tsahyt> ah yes
01:32:41 <tsahyt> I suppose that'd be slower though?
01:32:47 <tsahyt> compiling I mean
01:32:49 <tsahyt> not running it
01:32:51 <merijn> yes
01:32:57 <tsahyt> makes sense that it isn't the default then
01:33:32 <cocreature> it is slower for the initial load but reloading is often faster
01:33:52 <merijn> tsahyt: On the upside -fobject-code works with FFI code, can reuse existing object code (at least with new-repl)
01:33:52 <tsahyt> might be worth trying it out then
01:34:58 <cocreature> I’m doing stepwise printf debugging by unsafePerformIOing getLine, please send help
01:35:23 <jle`> cute :)
01:36:10 <merijn> cocreature: You did realise ghci had a stepwise debugger built in, yes? :p
01:36:36 <cocreature> merijn: yeah but I use it so rarely that every time I would like to use it I’ve forgotten everything and I’m too lazy to look it up :)
01:37:10 <merijn> Seems like now would be the time? :p
01:37:23 <cocreature> nah, already found the bug :)
01:37:47 <merijn> cocreature: naah, you've just found the thing that at first appears to be the bug, but secretly isn't!
01:38:26 <cocreature> heh
01:44:46 <tsahyt> all I know about it is :break and :step, and the latter always takes me for an hour long ride through some evaluation chain that sheds no light on what I actually wanted to know
01:45:30 <tsahyt> ghci's debugger has certainly honed my trace debugging skills, as well as my "stare at the code until it tells you what's wrong" skills.
01:46:48 <Ariakenom> Ah, Feynman debugging.
01:48:31 <Ariakenom> http://wiki.c2.com/?FeynmanAlgorithm
01:55:28 <ertes-w> helo
02:01:11 <Ariakenom> halloj
02:10:32 <osa1> staring at the code is underrated. I fix bugs all the time with that method.
02:10:50 <osa1> not having a good debugger helps developing staring-at-the-code skills
02:12:49 <ertes-w> i have no idea what a good debugger for haskell would even look like
02:13:33 <capisce> pretty
02:13:49 <osa1> breakpoints on expressions, good heap inspector, stepping evaluation...
02:14:09 <merijn> osa1: Don't forget "rewind"
02:14:35 <ertes-w> i guess being able to stop evaluation and inspect values in scope might be helpful
02:14:46 <osa1> right. gdb does that these days and it's immensely useful.
02:14:46 <ertes-w> i do that with 'error'
02:14:59 <ziman> i sometimes would like to evaluate expressions in the environment of a function (at a "breakpoint"); having pure and small functions is nice but when you need to provide heaps of environment to call them, they're not that useful to debug
02:15:30 <ertes-w> i haven't tried gdb yet, mostly because having to compile seriously messes up my workflow
02:18:01 <marvin3> it would be nice if Debug.Trace was not implemented as a library so that it can do things haskell code can't (print things that don't have Show constraint)
02:30:55 <lortabac> Hello, does anyone know if data-default is still maintained?
02:32:09 <merijn> alexbiehl: ping?
02:32:53 <merijn> lortabac: Why wouldn't it be? Also, Default is a bad class anyway
02:33:04 <dminuoso> osa1: Isn't reverse debugging extremely costly though?
02:33:48 <osa1> dminuoso: I don't think so, I've been using rr a lot lately and never found it too slow although it's certainly slower than running the program wihtout rr
02:34:17 <dminuoso> osa1: Do your record straight from main though?
02:34:17 <lortabac> merijn: I know it is a bad class. But I think I have a valid use-case for it
02:34:28 <osa1> dminuoso: yep, the whole program
02:34:36 <osa1> it's certainly less costly than how I would otherwise
02:34:52 <osa1> I usually need reversing from the crash, instead of forwarding from the beginning
02:35:01 <osa1> especially if the program runs for minutes before the crash
02:35:12 <Boarders> why is it considered a bad class, isn't it just pointed types?
02:35:17 <osa1> "how I would debug otherwise"*
02:35:25 <merijn> Boarders: Pointed is also a bad class :)
02:36:01 <Boarders> why do you think so?
02:36:14 <merijn> Boarders: No laws, so you can usefully reason about code using it
02:36:42 <Boarders> ah ok
02:36:53 <Boarders> I was just thinking they are algebras for the Maybe monad so sort of reasonable
02:36:57 <Boarders> but idk
02:37:11 <lortabac> merijn: In my case I just want to initialize a record with whatever values
02:37:55 <merijn> lortabac: So just define a default record?
02:38:06 <lortabac> I need this for lots of records
02:38:12 <lortabac> so it's quite boring
02:38:36 <lortabac> I am kind-of simulating row-polymorphism
02:38:37 <merijn> You still have to write Default instances for each record
02:39:09 <lortabac> I have some record updates that I want to apply to all the records that have certain fields
02:39:23 <lortabac> but I cannot do this on record creation (I think)
02:39:53 <lortabac> I suppose data-default can derive instances generically
02:43:26 <ertes-w> lortabac: you could try to factor your types better
02:43:37 <ertes-w> if you have a lot of overlapping information, factor it out
02:45:28 <lortabac> ertes-w: I could, but I would get extremely nested structures
02:45:50 <ertes-w> lortabac: is that a problem?
02:45:58 <lortabac> it's an event-sourcing system, where I store all the different versions
02:46:54 <lortabac> I guess in the long term the nesting could go too far
02:47:20 <lortabac> once I reach version 23, I risk having 22 levels of nesting :)
02:49:13 <lortabac> with my current solution, the complexity of dealing with the records is only in the projections
02:49:42 <lortabac> then the functions that use the data deal with flat records
03:01:11 <ertes-w> lortabac: so it's basically a backwards-compatible type, where new versions only add new fields
03:02:02 <lortabac> ertes-w: add, remove, or rename fields
03:02:18 <ertes-w> lortabac: rename?  why would you rename fields?
03:04:08 <lortabac> because I derive lots of instances generically, the public interface is somehow tied to the implementation
03:05:30 <lortabac> so if I need to rename a field in the JSON response of the API, I rename it in the record as well
03:06:35 <lortabac> an alternative could have been to handle this kind of things at serialization level, I am not sure what is the best solution
03:06:40 <ertes-w> lortabac: you should probably avoid having a tight coupling between interfaces and implementation
03:07:10 <lortabac> ertes-w: yes I agree, but there
03:07:15 <ertes-w> lortabac: that would probably also give you the opportunity to support legacy interfaces using the latest implementation
03:07:18 <lortabac> is too much boilerplate
03:07:49 <ertes-w> lortabac: in other words: if you receive a V3 packet, *translate* it into a V7 packet instead of using a V3-specific type
03:08:23 <ertes-w> lortabac: (this kind of boilerplate is one reason i no longer use acid-state)
03:08:24 <lortabac> ertes-w: yes, that's the alternative I was thinking of
03:08:50 <lortabac> but it doesn't solve the problem completely
03:09:10 <lortabac> because you still have to deal with the historical data
03:09:46 <lortabac> so you have to do the job twice, at the public interface and at deserialization
03:32:49 <humanoyd> What is the difference between `point` from Pointed and `pure`?
03:34:50 <Taneb> humanoyd: Pointed has less laws than Applicative and as such admits more instances
03:38:47 <humanoyd> Taneb: thx
03:57:12 <ertes-w> humanoyd: if the type is also Applicative, then (point = pure)…  if not, then i would expect the law (∀ f x. fmap f (point x) = point (f x)), but it's not actually documented
03:57:21 <ertes-w> if that's not a law, then Pointed is kind of a bullshit class
03:57:35 <ertes-w> (the same way as Default)
03:57:48 <Taneb> ertes-w: I think that law comes for free
03:57:56 <merijn> Taneb: How so?
03:58:24 <ertes-w> actually i just saw that Pointed isn't even a subclass of Functor
03:58:36 <Taneb> merijn: I vaguely remember it being pointed out, can't remember the justification
03:59:01 <merijn> ertes-w: Right, which is why so many people think Pointed is, heh, pointless
03:59:52 <ertes-w> yeah…  i don't remember ever needing it…  i've rather needed the exact opposite in the past:  Apply from semigroupoids
04:02:25 <fishythefish> Taneb: it's a free theorem for the type
04:03:20 <merijn> fishythefish: No, because pointed is not required to be a functor
04:03:59 <Taneb> merijn: I was taking a Functor constraint to be implicit in the expression of that rule
04:04:16 <fishythefish> if it's not a Functor instance, then that law is moot
04:04:25 <merijn> fishythefish: Which is why Pointed is a bad class
04:04:35 <fishythefish> in any case, this depends on which implementation of Pointed we're talking about
04:04:55 <fishythefish> e.g. https://hackage.haskell.org/package/category-extras-0.53.1/docs/Control-Functor-Pointed.html
04:05:28 <fishythefish> merijn: at no point am I defending Pointed as a useful type; just explaining the justification for Taneb's claim
04:05:47 <fishythefish> typeclass*
04:10:19 <Ariakenom> :i S.Set
04:10:44 <ertes-w> lortabac: here is a DataKinds-based approach that might work for you: https://gist.github.com/esoeylemez/cb2b0e54815d2770a97a287d14a599c1
04:10:57 <ertes-w> lortabac: note the ugly standalone-deriving clauses though
04:11:20 <ertes-w> lortabac: for some classes you might be able to define the instances inductively
04:11:30 <Taneb> merijn: I don't think anyone's denying that Pointed is a bad class
04:18:12 * hackage incremental-parser 0.3.1 - Generic parser library capable of providing partial results from partial input.  http://hackage.haskell.org/package/incremental-parser-0.3.1 (MarioBlazevic)
04:21:04 <marmistrz> Is there any idiomatic way to handle conversions between custom types?
04:21:45 <marmistrz> I mean something similar to Into/From in Rust, maybe something like `class From a b`
04:22:24 <ertes-w> marmistrz: functions are always idiomatic, for zero-cost conversions you can sometimes use Data.Coerce, and for everything else you can use lenses/isos
04:22:53 <ertes-w> marmistrz: i believe there is also a Convertible class somewhere, but it's not commonly used, because it's kind of a non-sense class
04:23:10 <marmistrz> ertes-w, what's wrong with a Convertible class?
04:24:21 <marmistrz> I don't think writing typeX2typeY for any types I need is a clean approach
04:25:37 <fishythefish> well, you'd still have to write that function in order to write the instance
04:27:19 <ertes-w> marmistrz: you could call it a "notational convenience" class…  there is no inherent reason for it to be a class
04:27:22 <Taneb> marmistrz: most of the time it's clearer to write some obvious functions and then chain those together when you use them
04:27:34 <ertes-w> marmistrz: i can't think of an example, where you would abstract over it
04:27:47 <ertes-w> and if you never abstract over it, why have a class in the first place?
04:28:22 <ertes-w> marmistrz: in fact with type inference in mind you might end up giving up the "notational convenience" as well
04:28:28 <Taneb> e.g. it makes sense to convert a Char to an Int, an Int to an Integer, and an Integer to a Double, but not really a Char to a Double, but if you really want to do that you can do fromInteger . toInteger . fromEnum (or fromIntegral . fromEnum)
04:29:06 <Taneb> There are a bunch of classes that allow for conversions in specific case
04:29:15 <jchia_3> marmistrz: Under some circumstances, you can use GHC.Generics with Data.Coerce, like this: "to . coerce . from". Both sides need to have Generic instance.
04:29:19 <Taneb> Like the Num class gives you Integer -> X
04:29:31 <Taneb> Enum gives you X -> Int and Int -> X
04:29:39 <Taneb> Integral gives you X -> Integer
04:30:03 <jchia_3> For example, you can use "to . coerce . from" to convert between "(Int, Char)" and "data Foo = Foo Int Char"
04:30:06 <Taneb> Real gives you Fractional gives you Rational -> X, Real gives you X -> Rational
04:30:15 <Taneb> There's some more dotted about too
04:33:47 <jchia_3> Can scotty be used to send a large response incrementally in chunks? If so, is it done using 'stream'?
04:34:38 <jchia_3> Or maybe 'responseStream'?
04:41:06 <lortabac> ertes-w: thanks!
04:41:55 <lortabac> I don't care the standalone deriving clauses
04:42:30 <lortabac> it's not too bad
04:44:37 <ertes-w> lortabac: i still think the compositional approach is better…  note that you don't necessarily have to give every combination of fields a name; sometimes using good old tuples is the best way
04:48:21 <lortabac> ertes-w: if the nested structures are only used internally, that's ok
04:48:52 <merijn> Right, time for my daily recruitment drive: Any new-build users willing to beta test some stuff? :p
04:49:58 <lortabac> ertes-w: but I wouldn't like to have to write complew JSON instances manually, or having to remember how to access a given field everywhere in the code
04:51:17 <lortabac> ertes-w: I think I will give a try to the solution in your gist, it looks neat
04:58:28 <static> guys why i cant compare values in     funk k ((ke,va):ta)   like this if (k==ke). I get error : No instance for (Eq k) arising from a use of ‘==’
04:58:50 <merijn> static: The items in your list must be comparable
04:58:57 <static> yes
04:59:17 <merijn> static: Well, you haven't told GHC that :)
05:00:47 <Ke> are you perhaps doing https://www.haskell.org/hoogle/?hoogle=lookup
05:00:49 <reactormonk> I've got an Applicative context (Gen from hedgehog) and I would like to generate an (a -> b) by combining a few generated (a -> b) using the Monoid instance of b. How do I do that in the applicaitve context of Gen? I'm certain there's a nice way which lets me traverse over things, but I'm not 100% there yet.
05:02:28 <mniip> fascinating
05:02:37 <mniip> ghc can't read a file if it can't fstat it
05:10:58 <Ariakenom> reactormonk: liftA2 mappend?
05:11:24 <dminuoso> What is a rank 3 type?
05:11:42 <dminuoso> Or rather.. how do I measure the rank of a type?
05:11:56 <liste> dminuoso: the level of forall nesting
05:13:33 <dminuoso> liste: Mmm so `((forall a. a -> a) -> ()) -> () would be a rank 3 type?
05:14:03 <liste> I don't think so, but not 100% sure
05:14:04 <merijn> dminuoso: Don't think so, that still only has 2 foralls
05:14:14 <merijn> dminuoso: The implicit outer one and the function one
05:16:06 <Ariakenom> It's nesting of forall scopes within forall scopes
05:16:10 <dminuoso> merijn: Uh what's the implicit outer one?
05:17:25 <AboutDoubts> hello there
05:17:37 <Ariakenom> halloj
05:17:41 <Ferdirand> someOtherInt :: ((forall a. a -> a) -> Integer) -> Integer
05:17:49 <Ferdirand> internet says that ertes says that this is rank3
05:17:53 <AboutDoubts> I missunderstand Monad mix Gen : https://pastebin.com/kMNm7aji
05:18:25 <AboutDoubts> If I want to do later a 'take 3' of that list I would have errors
05:18:54 <AboutDoubts> can I do....
05:19:09 <AboutDoubts> take return (genlistaPos)
05:19:14 <AboutDoubts> take 3 return (genlistaPos)
05:20:40 <Ariakenom> :t take
05:20:41 <lambdabot> Int -> [a] -> [a]
05:21:16 <dminuoso> Ahh the GHC manual has some information
05:21:18 <dminuoso> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arbitrary-rank-polymorphism
05:28:12 * hackage intero 0.1.31 - Complete interactive development program for Haskell  http://hackage.haskell.org/package/intero-0.1.31 (ChrisDone)
05:29:02 <tomlambda> Whilst using Conduit how do run a cmd and then return its stdoutput string on completion?
05:33:38 <merijn> tomlambda: conduit-extra has Data.Conduit.Process for dealing with subprocesses
05:35:40 <tomlambda> merijn - Yes thanks I am using that module however I am not sure how to return stdout from a child process when the process exits from within a monad
05:40:21 <Boomerang> How would I combine a bunch of Either à la `msum`, something like: f [Left err, Right 3, Right 2] = Right 2; f [Left a, Left b] = [a, b] ?
05:40:40 <Boomerang> I can write that function, just wondering if there's already one? :-)
05:41:09 <cocreature> Boomerang: that doesn’t look like it could typecheck [a] and Either b c won’t unify
05:41:11 <Boomerang> I meant `2`, not `Right 2
05:41:31 <cocreature> that still won’t work, in one case you’re returning a list in the other you aren’t
05:41:35 <Boomerang> But something like `Monoid b => Either b c` should, no?
05:41:54 <cocreature> can you write down what you would like the type of "f" to be?
05:42:45 <Boomerang> Mmh, 2 secs
05:43:39 <Boomerang> I think I know what I want
05:48:23 <Boomerang> So I've played around with the Monad instance of These before, where you basically have "warnings" that accumulate, and as soon as you have an error it stops
05:49:04 <Boomerang> I'd be interested in an Alternative like Either where the error are all shown if no Right was found
05:49:08 <dminuoso> Boomerang: look into Validation
05:49:25 <dminuoso> Boomerang: Note that it's easy to see why you couldn't make a Monad instance for that.
05:50:36 <Boomerang> I do understand why monad is not possible, but Alternative might be?
05:50:47 <merijn> Boomerang: Right, Validation is the one you want :p
05:51:03 <dminuoso> Boomerang: It's not possible to be lawful.
05:51:23 <merijn> dminuoso: Yes it
05:51:32 <merijn> dminuoso: Validation *has* an Alternative instance
05:51:51 <dminuoso> merijn: Sorry. My brain parsed that as "I do not understand why monad is not possible"
05:51:58 <merijn> Boomerang: https://hackage.haskell.org/package/either-5/docs/Data-Either-Validation.html
05:51:59 <Boomerang> Alright I'll checkout Validation, at first glance it doesn't seem to have an Alternative instance though
05:52:22 <Boomerang> Oh it does! :D
05:52:24 <merijn> Boomerang: There's two validations around, one with super billions of lenses and edwardk's either package
05:52:26 <Boomerang> Great :D
05:52:42 <Boomerang> Yeah I was looking at the other one
05:52:59 <Boomerang> Thanks
05:53:20 <boxscape> hm, I feel like I'm managing to throw something together with depedent types that more or less works while at the same time feeling like I have no idea what I'm doing...
05:54:10 <cocreature> merijn: either also provides lenses (or prims/isos) if you want to be pedantic :)
05:54:13 * hackage uniprot-kb 0.1.2.0 - UniProt-KB format parser  http://hackage.haskell.org/package/uniprot-kb-0.1.2.0 (zmactep)
06:00:52 <boxscape> is there an easier way to do type level computation in ghci than writing something like :t undefined :: <computation>?
06:01:36 <cocreature> boxscape: :kind!
06:02:29 <boxscape> hm, that doesn't seem to be quite what I want. That's the kind of the result type, but I want the result type itself
06:02:57 <cocreature> boxscape: note the ! at the end
06:03:02 <cocreature> that should show the normalized type
06:03:17 <boxscape> ahh, thank you!
06:11:56 <mniip> looks like ghc can't read code from a pipe after all!
06:12:15 * hackage yesod-bin 1.6.0.2, yesod-test 1.6.3, yesod-core 1.6.4 (MichaelSnoyman)
06:12:39 <dmwit> Yeah, I've been annoyed by that, too. It also doesn't gracefully handle /proc/fd.
06:12:46 <mniip> well
06:12:49 <dmwit> It *really* likes being able to know the name of the file it's reading.
06:12:59 <mniip> I went the long way and intercepted fstat
06:13:08 <mniip> hGetPosn: unsupported operation (Illegal seek)
06:15:44 <merijn> mniip: pipes don't support seek
06:15:50 <mniip> yeah
06:17:12 <merijn> Right, it's "wait 5 hours for CI tests to finish"-o' clock
06:17:50 <merijn> cocreature: There is now an even newer and more experimental branch for you to try :p
06:35:46 <kuribas> asheshambasta: hi.   I got your message but I was in the shop...
06:38:22 <asheshambasta> hey, saw your email too — haven't had the time to check it out though
06:46:31 <Psybur> When you use forall, are you restricting a type to be a single polymorphic type that meets the criteria instead of being any type that can fit the criteria?
06:46:45 <Putonlalla> No.
06:47:07 <Putonlalla> Polymorphic means universally quantified.
06:49:28 <ziman> depends on which side you're looking from :)
06:51:23 <dmwit> I don't understand the question.
06:52:01 <dmwit> I also don't understand the proposed answers. =P
06:56:05 <boxscape> all polymorphic functions have an implicit forall anyway, right?
06:56:22 <dmwit> Generally, if you have a value of type `forall x. t`, then the way you use it is to choose another type `t'` that does not have any `forall`s in it, replace all the `x`s in `t` with `t'`, and then use the thing as if it had this replaced type.
06:57:38 <dmwit> And yes, Haskell's love of implicit forall complicates the discussion a little, because it makes it difficult to distinguish between closed types that are implicitly quantified and open types that have no quantification but refer to a variable that's in the context.
07:00:23 <kuribas> does a datatype have implicit forall?
07:00:42 <kuribas> I know you can have a forall with existential quantification
07:02:47 <dmwit> If you're talking about data declarations (like `data Foo a = Bar a a (Foo a)` or whatever), then no, there's no implicit forall there. The `a` on the left of the equation is the binding site. But the type of `Bar` does have a forall in it.
07:04:17 <Putonlalla> The quantification is on the kind level since our arguments are types there.
07:04:40 <Putonlalla> (Assuming `PolyKinds`.)
07:04:58 <kuribas> where the forall?
07:05:36 <dmwit> here: `Bar :: forall a. a -> a -> Foo a -> Foo a`
07:06:28 <boxscape> Is there a canonical pronunciation for ~ in Constraints?
07:06:43 <kuribas> ah right, the constructor
07:06:54 <dmwit> boxscape: "is" or "equals", maybe
07:07:12 <boxscape> that does sound reasonable
07:07:40 <kuribas> unifies with?
07:08:48 <boxscape> Does haskell do unification? In the error messages it's always called "match"
07:10:04 <ironChicken> the version of servant that stack has installed for me doesn't have hoistServer. i'm utterly baffled by mmorph's hoist in general, and <https://hackage.haskell.org/package/servant-0.13.0.1/docs/Servant-Utils-Enter.html> in particular. anyone know of any examples of how to use this (deprecated) Servant.Utils.Enter API?
07:12:27 <alp> ironChicken, pretty much the same: enter <transformation from 'm a' to 'n a'> <handlers in the monad 'm'>
07:12:54 <alp> ironChicken, the tutorial for that version covers it, have you read it?
07:13:58 <alp> ironChicken, https://haskell-servant.readthedocs.io/en/v0.11.0.1/tutorial/Server.html#using-another-monad-for-your-handlers
07:14:25 <alp> (you can switch the version of servant for which you're viewing the tutorial with that little dropdown at the bottom left)
07:17:48 <cocreature> merijn: how do you manage to find the time for this is a mystery to me :)
07:18:12 * hackage wai-middleware-throttle 0.2.2.1 - WAI Middleware for Request Throttling  http://hackage.haskell.org/package/wai-middleware-throttle-0.2.2.1 (dfithian)
07:21:10 <jchia_3> I'm writing some kind of RPC server over websocket where the client sends requests that correspond to specific functions I need to call together with the params. What should the type for a request look like? A sum type that I pattern match for calling the right function? Is there a more elegant way?
07:21:37 <jchia_3> I will need to deserialize the request string/blob into this type.
07:21:45 <glittershark> sum type seems like the obvious solution
07:23:06 <EvanR> data Request = LaunchMissiles | PhoneHome Number Message | ...
07:23:19 <tomlambda> Why cant I call traceshow on a string within a monadic action ... instead my program only compiles when trace show is called on the whole monadic action?
07:23:37 <hexagoxel> jchia_3: will you end up re-inventing the cloud-haskell approach?
07:23:38 <jchia_3> I suppose my main focus is a type to minimize the boilerplate for deserializing.
07:23:53 <jchia_3> because the client is python
07:24:20 <glittershark> Aeson has support for generics
07:24:20 <jchia_3> the serialization scheme needs to be something easily realizable in Python
07:24:25 <EvanR> can python read json ? :)
07:24:32 <glittershark> so you could use JSON, yeah
07:24:58 <jchia_3> yes, but I'm wondering whether the derived instances will have convoluted json structure.
07:25:18 <glittershark> Aeson's generic JSON instances can be configured
07:25:21 <hexagoxel> jchia_3: ah, with python you can probably disregard what i said.
07:25:32 <jchia_3> I think the format will not be unreasonably convoluted.
07:26:12 * hackage publicsuffix 0.20180426 - The publicsuffix list exposed as proper Haskell types  http://hackage.haskell.org/package/publicsuffix-0.20180426 (wereHamster)
07:27:26 <jchia_3> I'll use a sum type with generic instance and derive the FromJSON instance for it.
07:27:37 <EvanR> you can control the json that gets produced
07:27:45 <EvanR> and how to parse it from haskell
07:28:10 <EvanR> to suit the sensibilities of python
07:28:38 <jchia_3> EvanR: Do you mean by specifying options to Data.Aeson.TH.deriveJSON?
07:28:55 <EvanR> i meant by writing aeson code
07:29:09 <EvanR> functional programming
07:29:33 <EvanR> but maybe you can also control it through generics too not sure
07:30:23 <ironChicken> alp: thanks, i can't believe i didn't notice that drop-down!
07:31:28 <jchia_3> EvanR: OK. I hope hand-written deserialization code won't be necessary. The sum type will have many parts. Hand-crafting deserialization code for them won't be fun.
07:32:21 <alp> ironChicken, no worries =) it's not all that visible to be honest.
07:34:08 <jchia_3> Now, if I have different variants of a call, e.g. "data Request = DumpLog | DumpLogTimeRange Timestamp Timestamp | DumpLogVerbosity Verbosity | DumpLogVerbosityTimeRange Timestamp Timestamp', I wonder if there's some smart representation to reduce repetition.
07:34:49 <jchia_3> Perhaps "data Request = DumpLogVerbosity (Maybe Verbosity) (Maybe (Timestamp, Timestamp)) | ..."?
07:38:03 <dmwit> tomlambda: Show us what you tried.
07:38:08 <dmwit> ?paste
07:38:08 <lambdabot> Haskell pastebin: http://lpaste.net/
07:39:40 <ProofTechnique[m> jchia_3: https://github.com/quchen/prettyprinter/blob/master/prettyprinter-ansi-terminal/src/Data/Text/Prettyprint/Doc/Render/Terminal/Internal.hs#L243 The approach used in prettyprinter may be instructive
07:40:19 <dmwit> jchia_3: maybe something like `data Request = DumpLog [Filter] | {- non-DumpLog commands -}; data Filter = Range Timestamp Timestamp | Verbosity Verbosity`
07:44:04 <reactormonk> I'm using hedgehog, is there already a way to select 0 to x elements of an existing list?
07:44:26 <reactormonk> ... subsequence
07:46:43 <jchia_3> ProofTechnique[m, dmwit: OK
07:59:16 <greymalkin> Does anyone know of an example of how to use Aeson with an "external" lookup table? e.g. one API endpoint returns a lookup table, and the second one uses the keys from the first.  It would be preferable not to have to create an intermediate type with only the keys.
08:04:37 <lyxia> greymalkin: I don't have an example but my advice is to not try to implement FromJSON, just write a toplevel function, and use the withObject/with*, (.:)/(.:?)/parseField* combinators, some of which are in Data.Aeson.Types.
08:04:46 <dyl> greymalkin: so in other words your schema isn’t known until runtime?
08:04:50 <ptek> greymalkin depending on your problem, you might parse the result of the first API call into a Aeson.Value
08:04:51 <dyl> ^
08:04:57 <dyl> ^ lyxia *
08:06:01 <dyl> Think of Aeson as in two phases: ByteString/String -> Value, and FromJSON a => Value -> a
08:06:19 <dyl> You can’t implement FromJSON when you don’t know the schema/type statically.
08:06:23 <dyl> So just don’t bother with doing so.
08:07:39 <ptek> also, dyl is right. greymalkin, could you maybe explain the "external" lookup table better?
08:07:49 <ptek> ^ maybe an example?
08:08:02 <dyl> It sounds like the schema is vended separately from the data itself.
08:08:13 <dyl> This is common in some REST JSON API building tools.
08:09:08 <dyl> For example: http://www.django-rest-framework.org/api-guide/schemas/
08:09:16 <dyl> Swagger is the big one.
08:09:50 <dyl> I guess now it’s “OpenAPI”
08:10:49 <dyl> Or in a simpler case, imagine one endpoint returns an ID-keyed dict of user attributes, and another returns a set of user IDs relevant to some query.
08:12:11 <greymalkin> It's more a 'data-driven' schema.  One table is symbols '{ "XYZ" : { "name" : "ExWhyZee", "precision" : 42 }, ... }' And the second call references those symbols: '{ "time" : "2018-04-26T16:08:55Z", "samples" : [ { "symbol" : "XYZ", "value" : 123.456 } ] }'
08:12:29 <ptek> dyl, yeah, I have seen swagger before, but I wander what greymalkin is actually trying to solve
08:13:51 <greymalkin> I'll need `data Sample = Sample Symbol Scientific` types rather than `Sample Text Scientific` ... I'm going to try breaking out of FromJSON instances for this, though; as per the recommendations.
08:13:52 <dyl> greymalkin: if the most sensible “parsed” representation of the JSON is dicts/lists
08:14:00 <dyl> Then use dicts/lists :p
08:14:22 <dyl> It seems like sunsets of your JSON have statically definable types though.
08:14:25 <dyl> subsets*
08:15:38 <dyl> The type you parse the JSON into needs to be general enough to cover the possible values. The most general is dicts(maps)/lists, so it might be fruitful to start there.
08:16:19 <dyl> Plus you’ll get a little more insight into how Aeson works doing so, and understanding your tools better is in my book always a plus :).
08:20:12 <delYsid`> Any idea why stack insists on rebuilding hakyll every time I build my hakyll site?  That takes a few minutes, which is not really useable.
08:21:11 <ventonegro> Doesn't happen to me
08:21:35 <ventonegro> (not very helpful, I know)
08:21:57 <cocreature> delYsid`: there is a bug in stack that causes this. it’s fixed in the 1.7rc iirc
08:22:59 <delYsid`> ah
08:23:00 <sm> yup
08:23:14 <delYsid`> upgrade said I have the latest binary, so I guess I'll wait.
08:23:24 <sm> where's that 1.7 release I wonder
08:25:48 <cocreature> sm: making a release immediately after the RC defeats the purpose of having an RC :)
08:26:37 <sm> true, but it has been a while
08:26:50 <delYsid`> ahhh, "stack ghc site" is a nice workaround.
08:27:23 * sm is anxious to see hpack warnings go away
08:27:44 <cocreature> looks liket here is a draft release since yesterday whatever a draft release is supposed to be https://github.com/commercialhaskell/stack/releases/tag/untagged-e15c55dc21c59b698ed7
08:28:44 <guillaum3> I have a constraint on a GADT constructor, such as (Foo t t' ~ 'True) => A t -> B t' -> MyType. However, constraint error are really uninformative ("could not match type False with True"). See for yourself: https://gist.github.com/guibou/ba4b42a9f11a9c7084345c06ac4a4288 Is there an alternative ?
08:28:50 <ptek> greymalkin you could turn this a little on its head, and use some functions to transform this. So after parsing the table of symbols into Values, you could try to use the values when decoding samples into your table and look up the symbol by its name from the aforementioned table
08:29:42 <lyxia> guillaum3: Use TypeError in GHC.TypeLits
08:31:49 <bodie_> what is the runtime cost of haskell ffi?
08:32:44 <bodie_> also, does haskell on windows depend on pthread or other gnu libraries?
08:33:03 <mniip> it does depend on libgmp at least
08:35:28 <lyxia> guillaum3: a type family IfErr :: * -> [*] -> Bool -> Constraint, that is () if True, or an informative TypeError if False.
08:37:45 <gh77bfb24> Hello, I need to implement a very simple GUI interface for my Haskell program. Just need some textboox to write, some drop down menu and some buttons. Preferably multi-platform but if it's Windows only that's fine too. Which should I go for? Prefer something with a rather low and flat learning curve.
08:40:00 <ertes-w> gh77bfb24: your main issue will be building the library for windows
08:41:21 <gh77bfb24> Why do I have to build it? Can't I download some packaged library and use that?
08:45:50 <bodie_> is it reasonably possible to ship a game for windows based on haskell?
08:47:39 <lortabac> gh77bfb24: there is fltkhs, I have never used it but it has ease of installation in its goals
08:51:52 <dmj`> gh77bfb24: web apps are pretty cross platform
08:52:14 <dmj`> gh77bfb24: you can also put it inside electron if you want native
08:57:42 <gh77bfb24> Thanks guys.
09:01:54 <mniip> cocreature, :add doesn't let me have multiple "main" modules
09:06:20 <mniip> basically
09:06:45 <mniip> I'm hacking together a lamdabot-esque "load this bunch of code into scope" thing for yahb
09:07:36 <mniip> considering I already implemented paste-as-file emulation
09:11:43 <mniip> behold:
09:12:13 <mniip> % :load http://tcpst.net/6ujw.hs
09:12:14 <yahb> mniip: [1 of 1] Compiling Main ( http:/tcpst.net/6ujw.hs, interpreted ); Ok, one module loaded.
09:12:20 <mniip> % :browse
09:12:20 <yahb> mniip: hello :: [Char]
09:17:32 <Larryhelp> Hello everyone, beginner question: I am supposed to swap each pair of elements in a list, and leave the last one as it is if the list contains an uneven amount of elements. Such that [1..9] would return [2,1,4,3,6,5,8,7,9] . I am NOT allowed to use List functions like map, i am supposed to solve it primarily using pattern matching and/or recursion. I just cant make it work. Any advice?
09:18:27 <mniip> Larryhelp, what have you tried?
09:18:37 <Larryhelp> g1 xs = (\[a,b] -> [b,a]) xs
09:18:40 <Larryhelp> is as close as i get
09:18:49 <Larryhelp> but that only works for 2 elements..
09:19:24 <Ariakenom> good start!
09:19:29 <mniip> that's pretty convoluted but not wrong
09:19:52 <mniip> Larryhelp, for recursion you usually need to think of a base case and an induction step
09:20:44 <Larryhelp> ive also tried to add g1 (x:[]) = x to somehow catch the last element, but so far, none of this gets me closer
09:20:59 <mniip> Larryhelp, suppose the input list xs is very long
09:21:18 <mniip> namely it has at least 2 elements at the front
09:21:26 <mniip> ie. xs = a:b:rest
09:21:30 <Larryhelp> by saying that you mean splitting xs into (x:xs)?
09:21:35 <Larryhelp> oh yeah
09:21:51 <kudomarkos> Hello I am here again.
09:22:14 <kudomarkos> I used shuffle of Test.QuickCheck
09:22:25 <kudomarkos> but it givesme Gen [a] type
09:22:31 <mniip> Larryhelp, g1 xs would have to begin with b and then a, right?
09:22:38 <kudomarkos> how can i liberate the [a] ???
09:22:52 <mniip> and what would go after the a?
09:23:00 <mniip> the procedure applied to the rest of the list
09:23:05 <kudomarkos> UnGen Gen [a] makes me.... IO [a], which is wrost
09:23:10 <kudomarkos> worse*
09:23:29 <mniip> you could write an equation:  g1 (a:b:rest) = b:a:(g1 rest)
09:23:30 <lemmih> kudomarkos: You most likely don't want to do that.
09:23:39 <mniip> not only this is a valid equation but this also is valid haskell code
09:23:53 <lemmih> kudomarkos: What are you trying to achieve?
09:24:22 <kudomarkos> lemmih I have two Lists.. I want to shuffle them (separetely) and then ZIP them
09:24:43 <lemmih> kudomarkos: Test.QuickCheck is not the right module to use.
09:24:45 <kudomarkos> but i only have Data.List and Test.QuickCheck so I can't use Random
09:25:01 <kudomarkos> so I tried to shuffle them.. with that..
09:25:10 <kudomarkos> :t shuffle
09:25:11 <lambdabot> [a] -> Gen [a]
09:25:11 <Larryhelp> @mniip doing exatly that leaves me with  Non-exhaustive patterns in function g1. so im assuming im missing the base case?
09:25:11 <lambdabot> Unknown command, try @list
09:25:14 <lemmih> kudomarkos: Why do you only have Data.List and Test.QuickCheck?
09:25:31 <mniip> Larryhelp, exactly
09:25:38 <lemmih> kudomarkos: Is this homework? Are you supposed to write your own 'shuffle' function?
09:25:49 <bodie_> lol
09:25:57 <kudomarkos> lemmih: because they are the 'rules' of my homework. Hahaha,
09:26:15 <kudomarkos> yeah, I tried to write shuffle'
09:26:28 <mniip> Larryhelp, in general this is how you write recursive functions in haskell. You identify how to make an arbitrarily large case slightly smaller, and then you identify the smallest base cases you can stop at
09:26:37 <kudomarkos> with a lot of i<-choose(0,length list) ... etc
09:26:46 <kudomarkos> and then recreate the list
09:26:59 <kudomarkos> but then i found shuffle into Test.QuickCheck
09:27:17 <lemmih> kudomarkos: Then just do the homework. You're wasting your time trying to find a shortcut. The easiest way to do homework is simply to learn what your teacher is trying to teach you.
09:27:23 <kudomarkos> but shuffle makes my problem bigger with Gen [a]
09:27:31 <mniip> lemmih, depends on the teachier ;)
09:27:50 <kudomarkos> lemmih: what?
09:28:19 <Larryhelp> mniip so im trying to make it stop when a:[] appears, meaning the last element is reached. trying (a:[]) = a:[] doesnt quite solve the exhaustive pattern yet though.
09:28:35 <boxscape> lemmih: It sounds like the homework doesn't specify whether you're supposed to write your own shuffle function or not
09:28:42 <mniip> Larryhelp, that's not the only base case that can occur
09:28:59 <Larryhelp> oh
09:29:06 <kudomarkos> Ok there is no way to transform Gen [a] to [a] without using UnGen (which transforms to IO [a] ) ??
09:29:10 <Larryhelp> g1 [] = []?
09:29:14 <mniip> sure
09:30:37 <Larryhelp> thanks you very much. I am concluding from this that i just blatantly overlooked the base cases. Should probably pay more attention to them. Thank you!
09:30:49 <boxscape> kudomarkos: Any function that does something random will have a result in IO if it doesn't take a seed as argument, which appears to be the case with shuffle
09:30:55 <Cale> kudomarkos: Well, what do you mean by "transform"? Do you want to run the generator, obtaining a random list?
09:31:04 <Cale> kudomarkos: Where are you running it from?
09:31:21 <Cale> You can easily run it from inside another Gen.
09:32:41 <Cale> If you have e.g.  genList :: Gen [a], then inside a do-block, you can write  xs <- genList  and then  xs :: [a]  in what follows in that block.
09:32:56 <lemmih> boxscape: I highly doubt they intended for Test.QuickCheck.shuffle to be high-jacked.
09:33:05 <kudomarkos> Cale... no.. ..because if i use shuffle... to mix the first list, and use again shuffle the second list.. if I use zip with them i will get Gen [(Gen a,Gen a)]
09:33:12 <Cale> The do-block as a whole will then have type Gen b for some type b (it will match whatever the type of the last action is in it)
09:33:13 <kudomarkos> and it looks terrible
09:33:34 <Cale> kudomarkos: Yeah, that seems like you're not running things you probably wanted to be running
09:34:16 <Cale> kudomarkos: A value of type Gen a is not like a value of type a, rather it's a program which if you were to run it, would produce a value of type a (randomly) each time.
09:35:08 <Cale> (and moreover, can be tuned to control the "sizes" of the values obtained in a particular way)
09:36:02 <kudomarkos> But i thought if i write: do i<-genAList it makes me the same... i will be a Gen [a]...
09:36:14 <Cale> i :: [a]
09:36:41 <Cale> but then the entire (do i <- genList; ... use i here ...) :: Gen b
09:37:11 <Cale> The type of a do-block always matches the type of the action on its last line.
09:37:12 <kudomarkos> uhmm :: <------ Is it that a thing as casting?
09:37:18 <Cale> That means "has type"
09:37:48 <kudomarkos> I think i am lost. I am going to reread you
09:37:55 <kudomarkos> wait a while I want to understand
09:40:31 <kudomarkos> Cale
09:40:41 <kudomarkos> but ... e.g
09:41:30 <kudomarkos>  do i<-genList1         j<-genList2         and then.. i::[a] j::[a]     return zip i j
09:41:36 <kudomarkos> that is a lie!
09:41:54 <kudomarkos> i is Gen [a]... not [a]
09:42:25 <kudomarkos> I will try... but i am sure it will be a desaster..
09:42:29 <boxscape> should probably be   return (zip i j)
09:42:56 <boxscape> since
09:42:58 <boxscape> :t return
09:42:59 <lambdabot> Monad m => a -> m a
09:43:05 <boxscape> return is a function that only takes a single argument
09:43:07 <Cale> kudomarkos: Why would i :: Gen [a]?
09:43:46 <Cale> kudomarkos: It's the result of executing genList1, and presumably genList1 :: Gen [a], not Gen (Gen [a]), unless something is weird.
09:45:06 <boxscape> What I'm guessing is you did something like  do {i <- genList1; return i}, saw that this expression has type Gen [a], and because of that think that i :: Gen [a]?
09:45:41 <kudomarkos> boxscape because return put INTO a box something... (the box is GEN), isn't?
09:45:56 <kudomarkos> That's the way I was taught... return put INTO a box
09:46:15 <boxscape> that's essentially correct. But in that case, i :: [a], and (return i) :: Gen [a].
09:46:25 <Cale> kudomarkos: return takes a value and produces an action which if you run it, always produces that value
09:46:36 <Cale> kudomarkos: (and does nothing else)
09:47:06 <boxscape> the box analogy can get a bit weird if you're looking at things other than lists and such
09:47:12 <Cale> So, e.g.  return 5 :: Gen Integer  is one of these random generators which happens to always produce the number 5
09:47:33 <Cale> (it's guaranteed random because I selected it by rolling a die ;)
09:47:39 <bodie_> lol
09:48:06 <Cale> So if we then execute that action like  x <- return 5
09:48:10 <Cale> x will be 5
09:48:43 * hackage texmath 0.10.1.2 - Conversion between formats used to represent mathematics.  http://hackage.haskell.org/package/texmath-0.10.1.2 (JohnMacFarlane)
09:48:45 <Cale> You usually wouldn't write that, a similar idea is expressed more plainly with  let x = 5
09:48:46 <kudomarkos> will be 5 or Gen 5?
09:48:54 <Cale> Gen 5 doesn't make sense
09:49:06 <Cale> Gen is a type-level thing
09:49:17 <Cale> x will be an integer there though, not a Gen
09:49:22 <kudomarkos> :( ok... I hate not be able to speak well english, sorry
09:49:23 <dyl> It's a randomly selected 5 from the set of all 5s.
09:49:24 <Cale> return 5 :: Gen Integer
09:49:38 <Cale> :t return
09:49:39 <lambdabot> Monad m => a -> m a
09:49:46 <Cale> So in this case, m = Gen
09:49:55 <Cale> and return :: a -> Gen a
09:50:05 <boxscape> :t return :: Int -> Gen Int
09:50:06 <lambdabot> Int -> Gen Int
09:52:42 <dminuoso> Wew.
09:52:44 <dminuoso>     • Cannot instantiate unification variable ‘a0’with a type involving foralls:(forall r. (a -> r -> r) -> r -> r) -> Logic aGHC doesn't yet support impredicative polymorphism
09:52:56 <kudomarkos> I don't understand anything
09:53:03 <kudomarkos> look these please: https://paste.ubuntu.com/p/D4qMFfSjbr/
09:53:16 <kudomarkos> could you tell me which concept i missunderstood, please?
09:54:45 <boxscape> what happens when you try to run that?
09:54:59 <ProofTechnique[m> kudomarkos: What's the problem?
09:55:14 <Cale> kudomarkos: 1) you're trying to execute i :: [(Integer, Integer)] there
09:55:26 <Cale> but the do-block is meant to be a Gen action, not a list
09:55:32 <dminuoso> @let newtype Logic a = Logic { unLogicT :: forall r. (a -> r -> r) -> r -> r }
09:55:33 <lambdabot>  Defined.
09:55:33 <Cale> So, you're not allowed to write that there
09:55:35 <dminuoso> @let @let logic :: (forall r. (a -> r -> r) -> r -> r) -> Logic a; logic = undefined
09:55:35 <lambdabot>  Parse failed: Parse error: @
09:55:41 <kudomarkos> I don't want to execute, i want to zip it with j!!
09:55:41 <dminuoso> @let logic :: (forall r. (a -> r -> r) -> r -> r) -> Logic a; logic = undefined
09:55:42 <lambdabot>  .L.hs:162:9: error:
09:55:42 <lambdabot>      • Cannot instantiate unification variable ‘a0’
09:55:42 <lambdabot>        with a type involving foralls:
09:55:42 <kudomarkos> :(
09:55:45 <dminuoso> Can someone tell me what's going on here?
09:55:45 <Cale> 2) you missed some parens around the argument to return
09:55:59 <Cale> You just wanted to write  return (zip i j)
09:56:23 <kudomarkos> parents around ¿return...?
09:56:36 <boxscape> parens, i.e. parentheses, ()
09:56:40 <kudomarkos> ahm
09:56:47 <kudomarkos> return $ zip i j
09:56:50 <kudomarkos> better?
09:56:52 <Cale> yes, that'll do
09:57:05 <Cale> also, the lines of your do-block don't look aligned in that paste
09:57:11 <kudomarkos> but why do you said i was executing i?...
09:57:21 <kudomarkos> Cale, yeah, i paste them wrong
09:57:24 <ProofTechnique[m> i::[(Integer,Integer)]
09:57:29 <Cale> Because that's what it means to write a value on its own inside a do-block
09:57:39 <Cale> It means "execute this action, and discard the result"
09:57:41 <dyl> "i :: [(Integer,Integer)]" is here the same as just writing "i"
09:57:47 <dyl> Just with a type annotation.
09:58:10 <Cale> and so you're trying to execute i there, which would make sense if we were using the list monad, but not when we're using the Gen monad.
09:58:56 <Cale> If you want to make sure of the types of i and j, you can annotate them where they occur in the expression with return
09:59:20 <Cale> return $ zip (i :: [(Integer, Integer)]) (j :: [Maybe Pieza])
10:00:10 <kudomarkos> then :: means "be for a while another thing"
10:00:25 <Cale> It means "has this type"
10:00:32 <dyl> :: is not a cast.
10:00:33 <Cale> x :: t means that x has type t
10:00:46 <ProofTechnique[m> That is very much not what that means
10:00:57 <Cale> If you use it in an expression, the compiler will constrain the type of x to t
10:01:17 <kudomarkos> but if I write i<-choose(1,3) .... and later i write i::[(Integer,Char,Integer)]
10:01:18 <Cale> If x would be polymorphic, this might determine its type more precisely.
10:01:25 <kudomarkos> it will be the same lie
10:01:31 <Cale> The compiler will complain
10:01:39 <kudomarkos> will it???
10:01:41 <kudomarkos> o.O
10:01:41 <Cale> because the type annotation you gave won't work
10:01:47 <boxscape> > (4 :: Int) :: Double -- it will
10:01:49 <lambdabot>  error:
10:01:49 <lambdabot>      • Couldn't match expected type ‘Double’ with actual type ‘Int’
10:01:49 <lambdabot>      • In the expression: (4 :: Int) :: Double
10:02:18 <Cale> :: tells the compiler which type you expect something to be, and it will check this for you
10:02:32 <kudomarkos> wow
10:02:32 <ptech> And if you're wrong, it will scream at you
10:02:45 <kudomarkos> hehehe
10:02:47 <kudomarkos> xD
10:03:01 <kudomarkos> but It will let me then to zip them
10:03:02 <Cale> It can also constrain the types of polymorphic things
10:03:17 <kudomarkos> only because it has sense 'inside' the Gen
10:03:25 <Cale> So if the expression could have more than one type, you can inform the compiler which of the possible types you want it to have
10:03:46 <kudomarkos> ah
10:03:53 <habolabo> forgive me... (inp, _,_,_) <- runInteractiveProcess "gnome-terminal" [] Nothing Nothing; but I'm unable to pipe any input in
10:04:15 <kudomarkos> so... i::Position    or i::(Integer,Integer)    when I wrote Position is a tuple of Integers..
10:04:24 <Cale> habolabo: Does gnome-terminal even read from its stdin?
10:04:24 <kudomarkos> I tell it WHICH it must be in that case
10:04:55 <Cale> kudomarkos: Well, for example, it might have otherwise had a type like (Num a) => (a,a)
10:05:00 <boxscape> Position and (Integer, Integer) are the same thing, since you defined one to be the other with your type declaration
10:05:01 <ptek> kudomarkos: unless Position is an alias for (Integer,Integer), it should complain
10:05:10 <Cale> kudomarkos: You might have a generator which could produce any type of numbers
10:05:23 <Cale> kudomarkos: (or pairs of numbers of any type)
10:05:39 <Cale> and then you might want to say "Oh, I want them to be Integer specifically"
10:06:38 <habolabo> Cale: that's a good question.. let me check. i'm just trying to spawn and persist a new window
10:07:04 <kudomarkos> Ahmmmmm ok ok, very cool
10:07:09 <kudomarkos> I understand THAT part
10:07:10 <kudomarkos> :D
10:07:14 <kudomarkos> thanks
10:07:28 <kudomarkos> I will continue doing generators in my homework
10:07:32 <kudomarkos> thanks so much!! :D
10:07:42 <Cale> no problem
10:12:44 <dsal> I'm sketching together a blog post and a collateral example, I need to convert an Int to an Int8.  I have the following implementation:
10:12:45 <dsal> runGet getInt8 (B.pack [toEnum $ x Data.Bits..&. 0xff])
10:12:52 <dsal> Does that look distractingly stupid?
10:14:36 <lemmih> dsal: I would just use 'fromIntegral :: Int -> Int8'.
10:14:40 <opqdonut> err yeah
10:14:43 <dsal> heh
10:14:52 <Cale> dsal: Usually I would import the operators from Data.Bits in a way that I could use them unqualified. But yeah, also, why not fromIntegral?
10:15:00 <dsal> Thanks.  That seemed like I went through too much.
10:15:21 <dsal> This is not an important part of the topic, so fromIntegral seems way more sensible.
10:15:50 <opqdonut> fromIntegral even has the same overflow behaviour
10:15:54 <dsal> Great!
10:15:57 <opqdonut> > fromIntegral 1000 :: Int8
10:15:59 <lambdabot>  -24
10:17:11 <stites> hey all -- I'm running into a double-free exception in this FFI library I'm working on and I'm wondering how I to go about debugging it
10:18:33 <stites> I thought I knew were the bug was, but my attempts at writing around this bug haven't been to fruitful, so I could use an extra pointer or two (pun intended)
10:19:12 <mniip> well, the C part can be debugged with gdb
10:19:29 <Wizek> Anyone knows how/if it's possible to extend the Foo GADT in this code https://github.com/mokus0/dependent-map/pull/16#issuecomment-384380287 with `ANum :: Num n => Foo n` to allow polymorphic values in `dependent-map`s?
10:25:14 <stites> thanks @mniip. So I've never debugged with gdb. Is there a resource you could direct me to? Also, do I have to desugar whatever cabal is running?
10:25:42 <mniip> oh hm
10:25:44 <cocreature> stites: you could also try valgrind
10:25:58 <glittershark> I've had *lots* of luck valgrinding haskell FFI
10:26:23 <glittershark> super easy and the output is very clear
10:26:49 <cocreature> yeah I was quite surprised with how well it works
10:28:02 <glittershark> if you do want to use gdb stites, just `gdb the-program` and enter `run`
10:28:11 <glittershark> it'll break as soon as it hits the segfault
10:28:20 <stites> awesome. Okay, I'll look into these
10:28:23 <glittershark> then you can use `bt` to examine the stacktrace
10:29:10 <stites> cool -- yeah, of course, cabal is just running a binary so there's nothing fancy there.
10:29:15 <stites> thanks everyone!
10:29:22 <glittershark> :+1:
10:29:30 <glittershark> good luck!
10:30:31 <Assistant> Good Evening everyone. I am able to extract the first elements in the inner lists in a list of lists (will post code after this). What do i need to extend to make it extract the first inner elements in a list of list of lists? (Sorry, confusing, example on the way)
10:30:37 <Assistant> firsts [] = [] firsts [(x:xs)] = [x] firsts ((x:xs):xss) = x: firsts xss -- this gets me [1,4] out of [[1,2,3],[4,5,6]]. Why cant i extend it to get me [1,4,1,4] out of [[[1,2,3],[4,5,6]],[[1,2,3],[4,5,6]]]
10:30:57 <Psybur> Is it possible to use the `type` keyword as a way to do something like "type a; type b; type c = (a,b); data a b = Foo a | Bar b | Baz c"
10:31:30 <Psybur> Rather, is there some way to do that
10:32:10 <boxscape> is there a notation for type level character literals?
10:32:21 <lemmih> Assistant: Your code works for me.
10:32:43 <lemmih> > let firsts [] = []; firsts ((x:xs):xss) = x : firsts xss in firsts [[1,2,3],[4,5,6]],[[1,2,3],[4,5,6]]
10:32:44 <lambdabot>  <hint>:1:85: error: parse error on input ‘,’
10:32:54 <lyxia> boxscape: nope :(
10:32:56 <lemmih> > let firsts [] = []; firsts ((x:xs):xss) = x : firsts xss in firsts [[1,2,3],[4,5,6],[1,2,3],[4,5,6]]
10:32:57 <lambdabot>  [1,4,1,4]
10:33:01 <boxscape> hm, okay
10:33:50 <glittershark> > let firsts [] = []; firsts ((x:xs):xss) = x : firsts xss in [[[1,2,3],[4,5,6]],[[1,2,3],[4,5,6]]] >>= firsts
10:33:51 <lyxia> Psybur: I don't understand what that does
10:33:52 <lambdabot>  [1,4,1,4]
10:34:01 <boxscape> I'm guessing type level String literals also don't work?
10:34:04 <glittershark> Assistant: for the double-nested list case
10:34:13 <glittershark> boxscape: -XDataKinds gives type level string literals
10:34:16 <glittershark> but calls them Symbols
10:34:25 <habolabo> Cale: thanks, gnome-terminal doesn't read stdin.
10:34:27 <boxscape> oh, you're right, I should've just tried it :D
10:35:09 <boxscape> (Just assumed it was going to be a non-standard notation for some reason)
10:35:17 <Assistant> lemmih: its supposed to work in a list of list of lists (u're missing the outer [] in your example) and glittershark: what exactly did you change? i cant spot it.
10:35:31 <glittershark> Assistant: I used (>>=)
10:35:38 <glittershark> [] is a monad
10:35:50 <glittershark> :t (>>=) @[]
10:35:51 <lambdabot> error:
10:35:51 <lambdabot>     Pattern syntax in expression context: >>=@[]
10:35:51 <lambdabot>     Did you mean to enable TypeApplications?
10:35:56 <glittershark> aww come on lambdabot
10:36:14 <Assistant> i havent seen this one yet, ill look it up. But cant i just add some sort of :xsss and extend the functionality this way?
10:36:24 <glittershark> well the type is different
10:36:32 <glittershark> :t [[[1,2,3],[4,5,6]],[[1,2,3],[4,5,6]]]
10:36:33 <lambdabot> Num a => [[[a]]]
10:36:42 <glittershark> :t [[1,2,3],[4,5,6]],[[1,2,3],[4,5,6]]
10:36:42 <lambdabot> error: parse error on input ‘,’
10:36:53 <ski> Assistant : (a) your definition of `firsts' can be simplified; (b) what would the type of `firsts' be, to be able to handle both your examples ?
10:37:08 <glittershark> :t [[1,2,3],[4,5,6],[1,2,3],[4,5,6]]
10:37:09 <lambdabot> Num a => [[a]]
10:37:34 <ski> (btw, `... >>= firsts' here is the same as `concatMap firsts (...)', you may want to look up `concatMap')
10:37:38 <ski> @type concatMap
10:37:39 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
10:38:23 <ski> @type concatMap :: (a -> [b]) -> [a] -> [b]  -- or forcing it to work only with lists, rather than any `Foldable' collection type
10:38:25 <lambdabot> (a -> [b]) -> [a] -> [b]
10:38:57 <ski> Psybur : perhaps you can clarify what you want ?
10:39:23 <Assistant> hmm.. i feel hesitant using the >>= monad, considering we havent really used those things before. The task is intended to work with pattern matching.
10:39:32 <Assistant> Although you are correct, it is working this way.
10:40:30 <aarvar> what's the >>= monad?
10:41:09 <ski> glittershark mentioned the list monad, the `[]' monad, as in e.g. the type `[Integer]', or `[(Bool,String)]'
10:41:55 <glittershark> :t (>>=) :: [a] -> (a -> [b]) -> [b]
10:41:56 <lambdabot> [a] -> (a -> [b]) -> [b]
10:42:18 <ski> (those latter two are syntactic sugar for `[] Integer', and `[] ((,) Bool String)'. `[]' here is the type constructor of lists, it can be read aload as "list of". `(,)' is the type constructor for pairs. `Integer' and `Bool' are also type constructors)
10:42:51 <ski> `(>>=)' is one of the key operations that all monads must support
10:43:24 <ski> Assistant : but feel free to ignore monads, for now. `concatMap' (with arguments in opposite order) will work just as fine ..
10:43:56 <ski> Assistant : .. any response to my (a) and (b) points, above ?
10:44:12 * hackage stylish-haskell 0.9.1.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.9.1.0 (JasperVanDerJeugt)
10:45:47 <Assistant> ski im not sure as to how to simplify the function, and to b): im sure i just need to apply my existing function to every element in the outer, added one. Im primarily trying to do so using pattern matching. simply applying map firsts xs will work just fine, and i will do that if i cant get the solution im looking for, but finding a solution only using Pattern matching is my goal here.
10:46:55 <Assistant> map firsts xs obviously works if i continue the nesting. im trying to move away from map and instead extend my definitions in the first place.
10:47:39 <delYsid`> I have a sum type with a function ident :: Type -> Text and want to write a FromJSON instance (for Data.Yaml) to construct when I see a string equal to the identifier.  Something like parseJSON (String s) = asum $ map check [minBound .. maxBound] where check mod = guard (ident mod == s) >> pure mod -- this works, but dont know how to set an informative error message when no candidate matched.  It currently just says "empty" when it
10:47:39 <delYsid`> fails.  Is there a better way to do this?
10:48:26 <ski> Assistant : as for (b), ok, if you want to avoid `map' (or similar), you can do that
10:48:31 <glittershark> delYsid`: well `asum` can be thought of as `foldr (<|>) empty`
10:48:46 <glittershark> delYsid`: so you could replace it with that, then change the `empty` to an error message
10:49:01 <delYsid`> ah
10:49:58 <chorizo> You guys think taking a compilers course is a good idea? Looks crazy hard
10:50:20 <Welkin> only if you want to
10:50:33 <Assistant> ski ive tried extending it to something like (((x:xs):xss):xsss) = (x:xs): firsts xsss but that doesnt come close. Im not sure how else to look at it
10:50:38 <ski> Assistant : as for (a), what would happen if you feed `firsts' a singleton list (containing a list with at least one element), *if* your middle defining equation for `firsts' was striked out ? (i want you to think about this first, rather than immediately trying it out)
10:50:40 <dyl> chorizo: personally yes
10:50:43 <dyl> Compilers are fun :p
10:50:44 <cocreature> chorizo: chose courses based on what interests you, not based on how hard they are
10:50:45 <boxscape> why can you only derive standalone instances for GADTs?
10:50:46 <chorizo> Welkin: makes sense
10:50:47 <dyl> (My opinion.)
10:50:55 <dyl> But choose based on your interests as cocreature said.
10:51:04 <Welkin> I have started courses and then dropped them
10:51:05 <Welkin> a lot
10:51:07 <dyl> Though sometimes you won’t know how interesting something is until you try it.
10:51:14 <Welkin> both in college and for free online courses
10:51:28 <Welkin> sometimes it just isn't what you wanted
10:51:31 <chorizo> dyl: cocreature: yeah it's hard. not sure how much I'm interested, apparently at my uni it's like a soul destroying amount of work
10:51:58 <Welkin> for college courses where you are paying a ton of money, don't choose courses based on what other people tell you to take
10:52:00 <dyl> Compilers are tricky but imo character building
10:52:03 <delYsid`> glittershark: thanks
10:52:08 <Welkin> choose what will make you happiest (out of your options)
10:52:11 <dyl> Compilers courses usually also combine a lot of things from many areas.
10:52:28 <Welkin> you can always learn anything on your own
10:52:30 <Welkin> at your own pace
10:52:32 <chorizo> dyl: yeah the problem is I've got another 2 long projects in the first semester, and adding compilers, with the dissertation
10:52:34 <chorizo> coul dbe too much.
10:52:46 <dyl> chorizo: this isn’t the CMU compilers course, right?
10:52:52 <chorizo> nah, I'm in the UK
10:52:52 <dyl> That one is ACTUALLY soul destroying :p
10:52:59 <Assistant> ski : hmm. im guessing its removing its ability to process those singleton lists.
10:53:13 <dyl> Compilers is usually a lot of work. If you have a lot of work already don’t overload.
10:53:21 <chorizo> dyl: from the people I've talked to, it's a crazy amount of work, and everyone gets terrible marks
10:53:26 <dyl> The only times I’ve had to withdraw from courses it was because I overloaded.
10:53:39 <dyl> Compilers just isn’t a class you can do projects at the last minute.
10:53:56 <dyl> You need to be coming back to your projects all the time, and there are many different concerns at play.
10:54:10 <dyl> Meaning: you have to write many different types of code for different facets of the system.
10:54:21 <Assistant> ski: but my definitions cant even handle those lists without nesting. Now im confused.
10:54:48 <dyl> Parsers, codegen, and typechecking are all their own little niches and the same style won’t translate.
10:54:54 <dyl> Now do them all in the same project :p
10:54:56 <chorizo> dyl: yeah I'm not sure. Maybe I can look at some lectures from a uni. I thought about writing the compiler in haskell, not sure if theyll allow that (most people do it in C)
10:55:09 * dyl is about to start his PhD in PL and is excited to build compilers.
10:55:11 <dyl> So I’m biased.
10:55:21 <chorizo> dyl: PL?
10:55:25 <dyl> Programming Languages
10:55:30 <glittershark> dyl: congrats!
10:55:42 <chorizo> dyl: pretty cool, not sure if I could ever hack a PhD lol
10:55:42 <Assistant> ski: nvm it can. i misinterpreted your question. :-)
10:55:50 <cocreature> boxscape: afaik it’s because Haskell2010 doesn’t support GADTs so allowing deriving for GADTs would be an extension an GHC has this weird obsession with sticking to the standard unless you enable extensions
10:55:53 <dyl> I find toy compilers one of the most satisfying things to work on, personally
10:55:53 <aarvar> writing a compiler in C?
10:55:59 <dyl> There’s something really rewarding about it.
10:56:00 <aarvar> sounds like hell
10:56:02 <dyl> But it is very hard.
10:56:08 <chorizo> dyl: what do you like about it?
10:56:15 <Assistant> ski: i dont know whats changing though if i happened to remove the middle definition.
10:56:16 <chorizo> aarvar: that's what I've heard lol
10:56:19 <dyl> I’m not just working inside the tools I have
10:56:23 <dyl> I’m building my own tools
10:56:37 <dyl> I’m defining my own ways to cast spells and summon the spirits in the box
10:56:38 <ski> Assistant : for the moment (for tha (a) point), i'm only considering your former example, with two levels of lists, not the latter with three levels
10:56:40 <dyl> ;)
10:56:49 <aarvar> how do you even write a compiler in C
10:56:51 <dyl> It’s hard to explain, it’s just very rewarding.
10:56:56 <dyl> aarvar: patiently
10:56:59 <boxscape> cocreature: hm, I see, thanks
10:57:00 <aarvar> with no native support for sum types
10:57:00 <Welkin> aarvar: yacc and flex
10:57:04 <aarvar> and the language is a damn sum type
10:57:14 <ski> Assistant : well, do you know that the syntax `[x,y,z]' is "syntactic sugar", is shorthand notation ?
10:57:29 <dyl> Discriminated unions aarvar
10:57:44 <dyl> Or some other representation.
10:58:02 <dyl> A compiler is a fun program to write because you can then use it to write more programs.
10:58:13 <dyl> It does something meaningful without needing a “real world” application.
10:58:20 <dyl> And your users are programmers. :p
10:58:24 <aarvar> you'll still end up doing casts won't you?
10:58:27 <chorizo> dyl: yeah but nobody will ever use my compiler
10:58:30 <Assistant> ski so you are saying there is no point in having it? that explains why i cant think of anything changing. That helped, thanks.
10:58:33 <chorizo> because it will be completely useless
10:58:37 <dyl> Doesn’t matter to me.
10:58:42 <aarvar> if statements and casts, yuck
10:58:42 * hackage stylish-haskell 0.9.1.1 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.9.1.1 (JasperVanDerJeugt)
10:58:54 <dyl> It’s about personal satisfaction.
10:58:57 <ski> Assistant : i'm saying there is no point in having what ?
10:59:08 <aarvar> and can you even use recursion?
10:59:19 * aarvar imagines writing a type checker as a while loop
10:59:20 <dyl> ...yes?
10:59:34 <dyl> You probably wouldn’t want to, as you’d likely overflow the stack.
10:59:38 <Assistant> ski the middle definition. I removed it, to see what u were talking about, and the function still works like before
10:59:42 <aarvar> dyl: that's what I meant
10:59:42 * hackage runmany 0.1.3 - Run multiple commands, interleaving output and errors  http://hackage.haskell.org/package/runmany-0.1.3 (JohnWiegley)
10:59:43 <dyl> But you can rewrite your recursion into a loop and stack.
10:59:51 <dumptruckman> Is there a library similar to mueval that is cross platform?
10:59:57 <cocreature> dyl: If you don’t mind me asking, which are do you plan to focus on in your phd?
10:59:59 <aarvar> trampolines, yay
11:00:09 <dyl> cocreature: huh?
11:00:22 <cocreature> dyl: s/are/area/ sry :)
11:00:43 <dyl> cocreature: my current focus/direction is on considering programming language tools and environments from a more user centric design perspective. So, somewhere between PL and HCI.
11:00:51 <dyl> But I’m specifically interested in tools used in academia.
11:01:04 <dyl> Because I use them every day and they blow chunks and when I see problems I want to fix them.
11:01:18 <cocreature> dyl: so I can complain to you about the usability of theorem provers? :)
11:01:27 <dyl> But, not so much focusing on hardcore theory, moreso on the user facing side of things.
11:02:14 <dyl> cocreature: well, maybe. Today probably not haha.
11:02:33 <ski> "My reasoning was simple, by writing a Haskell  compiler in Haskell I will double my language learning speed since I will not only have to learn how to program in it by forcing myself to complete a non-trivial project, but also its subtle semantics and  dark corners since I actually needed to implement it correctly."
11:02:41 <dyl> What I’m concerned with is how bad anti-patterns propagate in academia, which I see as a fault in the tools being badly designed for academic use cases.
11:02:48 <chorizo> ski:  who said that lol
11:03:00 <ski> "Writing a compiler is also doubly efficient to begin with, since if you self-compile improvements not only give you a better optimizer, but also speed up your self-compiled compiler. All in all I figure I was making very good use of my time. For some reason, when I explain my reasoning to other people they look at me like I am crazy, but I can detect no flaw in my logic."
11:03:16 <dyl> Do it in lisp first :p
11:03:20 <dyl> Haskell would be a nightmare
11:03:28 <dyl> I tried implementing a STG ⇒ LLVM compiler.
11:03:30 <Welkin> write your language using racket
11:03:32 <aarvar> you mean compile lisp first right?
11:03:36 <Welkin> it's a language for making your own language
11:03:38 <dyl> For example cocreature: what I affectionately call “Dropbox Folder Full of Pythons” problem.
11:03:38 <cocreature> dyl: sounds interesting, I wish you all the best for your phd!
11:03:44 <aarvar> write the compiler in haskell
11:03:50 <chorizo> dyl: yeah, but c vs haskell building a compiler
11:03:51 <chorizo> what would be worse
11:03:54 <ski>   -- John Meacham, author of JHC, <http://www.repetae.net/computer/jhc/>,<http://www.repetae.net/computer/jhc/jhc.shtml> (scroll down to "The story of jhc")
11:03:59 <ski> chorizo ^
11:04:00 <aarvar> chorizo: c is infinitely worse
11:04:03 <dyl> But the big problem is that labs tend to have one or two people who can code, but most of the code is copy pasted.
11:04:11 <chorizo> I'd be building a compiler similar to c but more limited in scope
11:04:15 <dyl> The assumption being “well the code is in a nature paper’s supplements so it must be good”.
11:04:28 <chorizo> I think I'll ask the lecturer if I can do it in haskell, if I can I'll do it, if not, fuck that
11:04:31 <dyl> And also increasingly code is published in supplements or as part of the publication.
11:04:36 <dyl> So this tendency is accelerating.
11:04:45 <dyl> There’s a lot of write only code too.
11:04:50 <aarvar> chorizo: do you have to compile a C-like language?
11:04:56 <bodie_> academia is bad, not news :P
11:05:03 <Welkin> for compilers courses, don't they usually force you to implement a simple subset of C?
11:05:03 <aarvar> probably more worthwhile to implement a functional one
11:05:05 <chorizo> aarvar: yes
11:05:16 <Welkin> I'd rather write a lisp using lisp
11:05:21 <dyl> And these days you might choreograph your  rig with a computer, analyze your data with a computer, visualize your data with a computer...
11:05:26 <ski> Assistant : "the middle definition. I removed it, to see what u were talking about," (well, i did ask you to *think* about the matter before trying it out, didn't I ? ;), "and the function still works like before" -- so, *why* does your function (appear) to work as before ?
11:05:34 <dyl> I think all of these scripts/programs ought to be published.
11:05:35 <aarvar> Welkin: I'd rather make a dependently typed language using haskell
11:05:45 <dyl> They’re essential to reproducibility l.
11:05:59 <dyl> But for that to happen, academics need to learn to code better.
11:06:08 <dyl> But academics are like cats, they won’t do what you tell them.
11:06:12 <Welkin> aarvar: too much work
11:06:25 <aarvar> dyl: but for that, they need to quit using python
11:06:26 <dyl> So I’m interested in the approach of designing tooling and environments that employ tight feedback loops to encourage good behavior,
11:06:30 <dyl> They won’t though.
11:06:33 <bodie_> that's what idris is anyway
11:06:35 <aarvar> why
11:06:39 <aarvar> but idris sucks
11:06:41 <aarvar> :)
11:06:42 <dyl> You could build THE perfect programming language and no one would migrate to it.
11:06:44 <bodie_> :D
11:06:47 <dyl> Because of the opportunity cost.
11:06:57 <cocreature> dyl: we recently did a collaboration with some material scientists here and tried to formally verify their code, the things I’ve seen …
11:06:57 <bodie_> the real opportunity cost is to NOT use my perfect language
11:06:57 <Welkin> you don't choose a language based on spec sheets
11:06:59 <Welkin> no one does
11:07:07 <dyl> The only tools you’ll get people to adopt have to strictly benefit and not interfere.
11:07:25 <dyl> You can’t push people to a new language, but you can encourage better habits in the language they use with assistant style tools.
11:07:30 <Welkin> also, no one language is best for any given task
11:07:30 <dyl> And no: notebooks do not fix this.
11:07:40 <dyl> You’ve just shoved the Dropbox folder of scripts inside a single container.
11:07:49 <dyl> And worse yet, many academic notebooks aren’t even linear.
11:07:49 <aarvar> dyl: or you could tell them to grow up and learn haskell
11:07:57 <dyl> Evaluating from the top down won’t reproduce ._.
11:08:08 <dyl> No.
11:08:17 <dyl> The crux is that coding is a form of communication.
11:08:22 <Assistant> i cant figure it out, ski.
11:08:22 <dyl> It’s not just for computers, it’s for people.
11:08:35 <Welkin> human music!
11:08:43 <dyl> Other people need to be able to grok your code and understand the intent.
11:08:45 <Welkin> beep boop beep! beep boop beep!
11:08:48 <ski> Assistant : also, i'd like to know whether you know about the syntactic sugar i mentioned ..
11:08:58 <aarvar> all the more reason to use a sane language based on mathematics
11:09:02 <dyl> aarvar: you can’t though. They won’t learn it.
11:09:09 <dyl> aarvar: PyRet :p?
11:09:11 <chorizo> I think my decision just became impossible, how unfortunate
11:09:14 <dyl> Pyret*
11:09:23 <bodie_> just throw types on it!  look how successful typed lisps are
11:09:26 <chorizo> I'll just take it and switch if it's impossible
11:09:28 <aarvar> dyl: at least in this case we're talking about people who don't consider themselves programmers
11:09:33 * ski . o O ( "slap them over tha haid with the Lisp manual" )
11:09:41 <aarvar> what's amazing is programmers who complain about having to learn programming
11:09:42 <dyl> aarvar right, you've hit the nail on the head
11:09:46 <dyl> One of the things I often say
11:09:49 <Welkin> ski: which lisp?
11:09:56 <dyl> There are more people who use math than there are mathematicians,
11:09:56 <Welkin> 1.5? common lisp? scheme? racket?
11:10:07 <ski> Welkin : i dunno, perhaps T or Dylan ?
11:10:09 <dyl> and there are more people who use programming languages than there are programmers.
11:10:11 <aarvar> dyl: well, teach it in grade school
11:10:17 <dyl> That's the goal of Pyret.
11:10:23 <dyl> Pyret is a very cool project.
11:10:28 <Welkin> what's that?
11:10:31 <dyl> And it does many of the things you're talking about.
11:10:33 <aarvar> is it a python thing?
11:10:34 <dyl> It's a language meant for teaching.
11:10:55 <dyl> https://www.pyret.org
11:10:55 <Assistant> ski no, i dont know about it
11:11:05 <aarvar> looks like a functional language with "python inspired syntax"?
11:11:11 <Welkin> lol
11:11:11 <aarvar> not sure what the point of that is, but ok
11:11:17 <dyl> Specifically, read the "Why Pyret"
11:11:17 <Welkin> looks like the racket symbol
11:11:22 <dyl> Yup.
11:11:27 <dyl> The name Pyret = Python + Racket
11:11:39 <dyl> And it's a lambda crossbone :p
11:11:44 <Welkin> I don't dig the syntax at all
11:11:51 <dyl> It's not meant for programmers.
11:11:56 <aarvar> first bullet point "we wanted to experiment with syntax"
11:11:57 <Welkin> look like python mixed with javascript
11:12:00 <aarvar> really?
11:12:23 <dyl> The goal is for it to be usable in a lower school context within other topics (physics, math, etC).
11:12:24 <aarvar> is syntax really the thing holding people back from learning?
11:12:28 <Welkin> wtf? O.o
11:12:31 <ski> Assistant : ok, so the list `[x,y,z]' is really an abbreviation for the notatation `x : (y : (z : []))', `[]', is the empty list, and `:' adds a *single* element in front of a list (which becomes the tail of the new list)
11:12:34 <Welkin> this is a frankenstein's monster language
11:12:40 <dyl> aarvar You're overemphasizing syntax.
11:12:45 <Welkin> it mixes together python, javascript, ocaml, and who knows what else?
11:12:45 <aarvar> dyl: no, they are
11:12:46 <Welkin> coq?
11:12:56 <aarvar> dyl: it's the first thing they talk about
11:13:09 <dyl> It's intended to be a 'first language'.
11:13:13 <dyl> Not to appeal to existing programmers.
11:13:19 <aarvar> I understand that
11:13:23 <ahri> how can I pass options along to ghci when going via `cabal new-repl`? With stack I'd use `--ghci-options`
11:13:23 <dyl> So it's similar to a lot of other languages you would transition to.
11:13:38 <aarvar> dyl: superficially
11:13:40 <ski> Assistant : but because `:' has been declared as "right associative", we can drop the brackets, getting `x : y : z : []' (this is similar to how `(a * b) + c' can be written as `a * b + c', dropping the brackets)
11:13:45 <aarvar> and why would we want anyone to transition to python
11:14:00 <aarvar> as for using programming in other school contexts, combine programming and math into a single subject
11:14:04 <greymalkin> Update on the dynamic JSON schema: I went ahead and implemented a light "FromJSONLookup" typeclass which wraps the parser in a ReaderT.
11:14:06 <aarvar> problem solved
11:14:14 <bodie_> just teach C
11:14:20 <dyl> aarvar The goal is for Pyret to be usable within the context of other classes, not just math.
11:14:39 <dyl> It's a tool, rather than what is being directly taught.
11:14:48 <Welkin> I think scheme or racket is a better first language
11:15:15 <Assistant> ski I dont think i understand what this has to do with my question :/ cant get the connection
11:15:22 <ski> Assistant : so, in particular a singleton list, like `[(x:xs)]', which is the same thing as `[x:xs]', is really shorthand for `(x:xs) : []'. now, taking your last defining equation `firsts ((x:xs):xss) = x : firsts xss', if we feed `firsts' a list `[a:as]'
11:15:33 <dyl> The design is also driven by feedback from actual real world use.
11:15:36 <aarvar> dyl: programming would be usable in other classes just as math is
11:15:40 <dyl> Namely in high school, CS1 type courses.
11:15:45 <dyl> aarvar Yes.
11:15:54 <ski> Assistant : then `x' becomes `a', `xs' becomes `as', and, importantly, `xss' becomes `[]', the empty list !
11:16:01 <aarvar> dyl: why does that require this weird language with too much emphasis on syntax?
11:16:15 <dyl> You're obsessed with the syntax :p.
11:16:17 <aarvar> bullet point #2 "We wanted to build a really great run-time system for the Web browser. "
11:16:21 <aarvar> no, I'm reading what they write
11:16:21 <Welkin> the great part about lisp is that is almost has no syntax
11:16:23 <dyl> And not why it's designed the way it is.
11:16:27 <ski> Assistant : so `firsts [a:as]' becomes, by the third definig equation, `a : firsts []' ..
11:16:33 <dyl> And yes, the reason it has a web runtime is cost driven.
11:16:34 <ski> Assistant : and i must leave, i hope this helps
11:16:38 <dyl> It needs to run on very very cheap hardware.
11:16:39 <bodie_> trying to get people who aren't interested in being good to start being good is a non-starter
11:16:41 <ski> Assistant : have fun
11:16:45 <dyl> And many schools only have chromebook style devices.
11:17:20 <aarvar> dyl: you're telling me chromebooks are too slow to compile hello world in other languages?
11:17:43 <dyl> They don't even expose a compiler, let alone shell.
11:17:55 <aarvar> okay, too slow to interpret it?
11:17:55 <dyl> And in a teaching environment, why would you even want to expose "compiling" at all?
11:18:14 <mniip> can't run what you can't install :p
11:18:37 <dyl> You would use it in a context such as: https://code.pyret.org/editor
11:18:47 <aarvar> I'm having a hard time seeing how syntax and performance are the main problems that need to be solved for educational languages
11:19:01 <Welkin> lisp already solved the syntax problem
11:19:09 <dyl> aarvar One kind of trivial but indicative example, say you're learning math.
11:19:16 <dyl> You don't want a language where = and := are conflated.
11:19:18 <Welkin> even lua or javascript is simple enough
11:19:20 <dyl> It can be confusing.
11:19:27 <aarvar> Welkin: or just some sort of lambda calculus
11:19:32 <aarvar> er, typed lambda calculus
11:19:33 <aarvar> I meant
11:19:40 <aarvar> without all the syntactic sugar of haskell
11:19:43 <bodie_> luna lang seems nice
11:19:43 <Welkin> you don't even need types
11:19:48 <dyl> But in a classroom context you're not trying to teach lambda calculus, you're trying to do other things.
11:19:59 <Welkin> types are not fundamental in programming
11:20:04 <dyl> No, but types can be pedagogically useful in building a mental model.
11:20:07 <bodie_> I think that's more the direction to go if you want to teach people how to reason about programs
11:20:09 <dyl> You don't need to know they're there though.
11:20:21 <bodie_> not ML python frankenstein
11:20:43 <Welkin> if I was teaching kids to program, I would choose racket
11:20:53 <dyl> Yes, which is where this comes from originally.
11:21:09 <aarvar> dyl: why aren't you trying to teach lambda calculus? Extended with primitive arithmetic perhaps
11:21:27 <dyl> "One of the enduring lessons from the Racket project is that no full-blown, general-purpose programming language is particularly appropriate for introductory education. By the time a language grows to be useful for building large-scale systems, it tends to have accumulated too many warts, odd corners, and complex features, all of which trip up students."
11:21:50 <dyl> There's a whole explanation of why not Racket.
11:22:05 <aarvar> great, use a syntactically simpler version of haskell with a simpler prelude
11:22:26 <bodie_> why not rust?
11:22:28 <bodie_> :P
11:22:31 <dyl> You're underestimating how much a small error in such a language could throw you into the deep end.
11:22:35 <Welkin> I find that to be a huge problem with teaching haskell
11:22:43 <aarvar> Welkin: syntax?
11:22:43 <dyl> Isolating the user from complex errors unless they're doing complex things is important.
11:22:44 <Welkin> the types are so convoluted from the start in prelude
11:22:48 <aarvar> oh, prelude
11:22:48 <Welkin> the syntax is fine
11:22:50 <dyl> Also, I would choose SML over Haskell for pedagogy.
11:22:55 <dyl> If I had to pick something in that family.
11:22:59 <aarvar> Welkin: make a custom educational prelude
11:23:00 <Welkin> as soon as you want to talk about types, you will have a touch time
11:23:02 <Welkin> tough*
11:23:24 <dyl> Compartmentalizing features of the language is one of the things the Scheme/Racket family does well, and something that is done in Pyret as well.
11:23:50 <dyl> The moment you have a Haskell program and make one mistake, you might get an utterly incomprehensible error message invoking a dozen concepts you don't know.
11:24:03 <Welkin> after using lisps, I also realize that precendence rules are insane in haskell
11:24:08 <dyl> ^
11:24:10 <dyl> Utterly and totally.
11:24:13 <dyl> Now try Agda ;)
11:24:13 <Welkin> you have to learn all of the combinators and how they work
11:24:17 <Welkin> it is impossible to teach in a sane way
11:24:35 <Welkin> basically, just use lots of parens and write lisp in haskell
11:24:40 <aarvar> ^
11:24:44 <Welkin> until you have a year of experience with them
11:24:46 <aarvar> no ($) etc
11:24:50 <Welkin> and can start removing the parens
11:24:51 <dyl> Pyret is basically what would happen if you took a slimmed down Racket #lang for teaching,
11:24:57 <dyl> and then added a more algol/python-esque syntax.
11:25:04 <Welkin> that is one thing I dislike about haskell
11:25:06 <aarvar> Welkin: maybe a few operators like (:)
11:25:06 <dyl> Because balancing parens is a waste of time at that level.
11:25:15 <Welkin> if there was any complaint, it would be the precendence rules
11:25:18 <dyl> And a rich set of keywords is more conducive.
11:25:45 <dyl> Being able to have predicates, tests, and documentation as their own syntactic forms also encourages recognizing them as distinct concepts.
11:25:51 <aarvar> Welkin: well, an editor ought to be able to automatically insert parens if you don't want to memorize precedence
11:26:08 <dyl> If you figure that out, publish ;p.
11:26:14 <aarvar> so this is really a symptom of representing code as text rather than ASTs
11:26:15 <sm> helium is a haskell implemenation with racket-style learning dialects
11:26:47 <aarvar> dyl: why are they distinct concepts?
11:27:03 <dyl> aarvar distinct from your own code.
11:27:11 <aarvar> why
11:27:19 <dumptruckman> ooh, this is a fun convo
11:27:25 <dyl> Lisps tend to blur everything together because you can use the same syntactic forms (often by defining your own) for everything.
11:27:41 <Welkin> which is a strong point in my mind
11:27:42 <aarvar> I don't like lisp, Welkin does
11:27:49 <dumptruckman> the racket learning dialects are pretty cool
11:27:55 <Welkin> because the syntax is nearly invisible
11:28:02 <dyl> It's a strong point for someone who knows some programming to start understanding programs at a deeper level.
11:28:07 <Welkin> you can see the meaning instead
11:28:08 <dyl> But it's not good for introductory teaching.
11:28:25 <aarvar> I had a classmate tell me higher order functions are too hard for CS 101
11:28:28 <dyl> dumptruckman I'm evangelizing Pyret currently. aarvar isn't having it :p.
11:28:34 <Welkin> have you seen How To Design Programs?
11:28:43 <Welkin> it uses a teaching language that is a dialect of racket
11:28:45 <dumptruckman> haven't heard of Pyret
11:28:46 <Welkin> I think it does a very good job
11:28:48 <dyl> "Pyret is driven by the How to Design Programs (HtDP) philosophy of programming education; one could almost view it as a language designed to make teaching from HtDP comfortable."
11:28:50 <dyl> ^
11:29:11 <dumptruckman> oh cool
11:29:22 <dyl> It's literally *meant* to be used with HtDP.
11:29:48 <dumptruckman> programming languages and pedagogy interest me a lot and if I go for a PhD I think that's what I want to pursue
11:30:03 <aarvar> dyl: you know what, I spoke too soon
11:30:11 <aarvar> I hadn't scrolled down and looked at all of these examples
11:30:15 <aarvar> now I think it's even worse
11:30:16 <dumptruckman> woah what
11:30:18 <dyl> Read the "Why" page, it justifies everything rather thoroughly.
11:30:20 <dyl> Also hah.
11:30:23 <dumptruckman> it's like a bastard mix of haskell and python
11:30:28 <aarvar> look at the for each loop
11:30:30 <aarvar> wtf
11:30:38 <aarvar> for each(str from [list: "Ahoy", "world!"]):
11:30:48 <aarvar> that's supposed to be good for learning?
11:30:56 <Welkin> haha
11:31:08 <aarvar> I mean, seriously?
11:31:08 <Welkin> how about '("Hello" "world")
11:31:29 <dumptruckman> i think the ' will trip people up
11:31:33 <Welkin> okay
11:31:39 <dyl> The syntax generalizes
11:31:40 <Welkin> list ("hello" "world")
11:31:45 <dyl> e.g. for fold(sum from 0, number from [list: 1,2,3,4]):
11:31:46 <Welkin> same thing
11:31:52 <aarvar> how is that easier than foreach ["Hello", "world"] (\s -> ...)
11:32:06 <dyl> It's not about "easier" in terms of code golfing, it's about consistency.
11:32:16 <aarvar> it's about meaningless syntax
11:32:39 <aarvar> complicated meaningless syntax for that matter
11:32:42 <dyl> See above:
11:32:43 <dyl> fold(lam(sum, number): sum + number end, 0, [list: 1,2,3,4])
11:32:46 <dyl> Same thing.
11:32:56 <dyl> There is parity between the functional and iterative formulations, the former being just sugar.
11:35:18 <dyl> aarvar also, because the syntax accommodates each/fold/...
11:35:31 <dyl> It's a general looping construct, not a for-each loop.
11:35:39 <aarvar> what if...you just had functions
11:36:02 <dyl> That's all each is, a function.
11:36:26 <aarvar> k, explain "for each(str from [list: "Ahoy", "world!"]):" to me
11:36:27 <dyl> In the for expression, the function being called is in the block.
11:36:48 <dyl> for each string from the list "Ahoy", "world" do ...
11:36:55 <dyl> Exactly what it looks like.
11:37:05 <aarvar> why are for and each separate things
11:37:07 <aarvar> what is for by itself
11:37:24 <dyl> Sugar for lambda and apply.
11:37:36 <dyl> https://www.pyret.org/docs/latest/Expressions.html#%28part._s~3afor-expr%29
11:37:47 <aarvar> for f(x from y): blah becomes f y (\x -> blah) ?
11:37:51 <aarvar> why not just use the latter
11:38:08 <dyl> Clarity.
11:38:12 <dyl> For someone who is a non-programmer.
11:38:16 <aarvar> obscurity
11:38:30 <aarvar> yes, teach programming to non-programmers by hiding the programming?
11:39:03 <aarvar> why not just teach the fundamental concept of functions
11:39:46 <dyl> How are these exclusive?
11:39:49 <dyl> And how do you prioritize?
11:39:57 <dyl> Have you ever taught children programming?
11:40:13 <dyl> It really doesn't go the way you imagine it will.
11:40:28 <dyl> You can't teach it like an undergrad course.
11:40:40 <bodie_> surely children will take to python-ML-frankenstein like a duck takes to water
11:41:15 <dyl> Better than using Python directly, with no ADTs, no simple data types, inheritance forced up front...
11:41:21 <dyl> Teaching in Python is _horrid_.
11:41:26 <bodie_> yeah, python is bad
11:41:27 <aarvar> we agree python is terrible
11:41:35 <aarvar> so lets use this other language which is partially inspired by python
11:41:37 <aarvar> ...
11:41:38 <bodie_> python and java shouldn't be taught
11:41:54 <dyl> But the syntax is relatively clear and for whatever reason people take clear block-based syntax.
11:42:00 <megaTherion> bodie_: instead?
11:42:10 <dyl> Java is even more horrid.
11:42:11 <aarvar> dyl: kind of like how people find objects to be more intuitive
11:42:14 <bodie_> literally anything except python and java
11:42:16 <bodie_> lol
11:42:21 <dyl> Sure, but that doesn't mean that you want to introduce inheritanc.
11:42:26 <megaTherion> php o.o
11:42:30 <aarvar> dyl: that was sarcasm
11:42:31 <dyl> You can have objects without introducing inheritance and use sums insteads.
11:42:38 <dyl> But, unfortunately, that's kind of true.
11:42:45 <aarvar> but fortunately, it's not
11:42:53 <aarvar> it's some bullshit people made up
11:43:01 <dyl> I mean "objects" in a very vague sense.
11:43:04 <bodie_> I don't acknowledge the existence of php
11:43:14 <dyl> People like to think of their programs as consisting of nouns which verb.
11:43:26 <aarvar> says who?
11:43:31 <aarvar> maybe they were just taught to think that way
11:43:33 <bodie_> dyl -- I like the way Go inverts that into verbs that verb nouns ;)
11:43:49 <dyl> bodie_ Ew... Go.
11:43:54 <bodie_> verbs are things, and nouns are things that verbs operate on.
11:44:45 <bodie_> I'm trying to teach my wife SICP
11:44:55 <dyl> bodie_ do you know about #lang sicp in Racket :)?
11:45:06 <dyl> Helps avoid all of the little differences in SICP scheme and any other dialect.
11:45:14 <bodie_> nope, we're just using guile in geiser
11:45:26 <bodie_> that sounds convenient
11:45:34 <dyl> https://docs.racket-lang.org/sicp-manual/index.html
11:45:36 <dyl> It is very convenient.
11:45:48 <dyl> I did SICP in mit scheme, I had a field day trying to adapt things.
11:45:58 <bodie_> Go is good because it's stupid simple and doesn't let you push the envelope.
11:46:08 <dyl> bodie_ counterpoint: interface{}
11:46:15 <bodie_> nobody should use that type
11:46:20 <dyl> I get that it's a language for an office full of warm bodies.
11:46:31 <dyl> But a BASIC generics system could have made it in.
11:46:48 <bodie_> "haha, just use hand-coded template codegen! what are you, lazy?"
11:46:57 <Welkin> you don't need generics if you don't use types
11:47:01 <bodie_> lol
11:47:07 <dyl> "Just use gyp, what are you lazy?"
11:47:13 * dyl shudders
11:47:28 <dyl> The problem is that lack of generics makes writing any kind of sane container impossible.
11:47:30 <bodie_> I think they were overestimating their audience and hoping for someone to provide a good community implementation of type-driven templates.
11:47:40 <fr33domlover> What do you think about teaching programming from scratch as "you write functions in the mathematical sense and the computer does the computation" versus "you write instructions for the computer to execute"? is there a good way to teach both with the same language, or do you start with one, and which one do you pick
11:47:48 <bodie_> there are a handful of okay container codegen packages for go.
11:47:59 <Welkin> fr33domlover: both approachs can work
11:48:04 <dyl> fr33domlover it depends on the context, but both can work
11:48:10 <Welkin> I personally started with learning about hardware and assembly
11:48:12 <dyl> If you're using programming in a math class, the former is useful.
11:48:14 <Welkin> and think that worked best for me
11:48:18 <bodie_> but in general Go users aren't really trying or needing to take it to that level.  most of the bigbrains have probably already emigrated
11:48:28 <dyl> If you're using it to run analysis on some data for a social studies class, then the latter is better.
11:48:36 <dyl> Get you a language that can do both.
11:48:51 <dyl> Go is just... such a disappointment.
11:49:05 <bodie_> it's pragmatic and boring
11:49:12 <bodie_> has its place imo
11:49:18 <dyl> I looked at Go with optimism and left disgusted. I looked at Swift with morbid horror, and left pleasantly surprised.
11:49:37 <fr33domlover> Welkin, dyl hmmmm personally I started with the "instructions to execute" thing, I guess most people do, but much later I discovered functional programming matches my mind much much more than instructions and OOP
11:49:37 <dyl> It does, but I don't think it meets it's design goals: it's just not a good language.
11:49:51 <bodie_> when I use Go I feel like I'm being forced to write poetry in 4th-grade english
11:50:16 <bodie_> it's not for me to enjoy though
11:50:34 <bodie_> it's for people to use to lead people who _aren't_ poets
11:50:41 <bodie_> which it is okay at.
11:50:43 <dyl> bodie_ my name is Cow, and wen its nite, or wen the moon, is shiyning brite, and all the men, haf gon to bed -, i stay up late., i lik the bred.
11:50:45 <dyl> ^ actual Go
11:50:54 <bodie_> lol
11:51:03 <bodie_> no, too convoluted.  refactor.
11:51:19 <bodie_> cow no sleep, eat bread.
11:51:21 <dyl> type Bred interface { lik() }
11:52:19 <Welkin> that reminds me of trying to write chinese sentences in haskell
11:52:23 <aarvar> "If you're using it to run analysis on some data for a social studies class, then the latter is better"
11:52:26 <Welkin> by aliasing all the function names
11:52:26 <aarvar> why?
11:52:28 <Welkin> it doesn't work well
11:52:39 <Welkin> because of restrictions on variable abd type names
11:52:42 <Welkin> and constructors
11:52:46 <Welkin> Uppercase vs lowercase
11:52:50 <bodie_> fr33domlover, I think you have to stay conscious that you are using an abstraction layer over a machine.  to me, functional semantics collide with that necessity
11:52:51 <dyl> In any case, bodie_ / aarvar, whether you like the language or not, it is being worked on with feedback from real world usage in classrooms.
11:52:53 <Welkin> it would works wonderful in racket though
11:53:00 <dyl> User studies!
11:53:16 <bodie_> I personally favor learning C first and then discovering that there are easier and simpler ways to reason about things
11:53:22 <aarvar> bodie_: isn't the point of abstraction that you *don't* need to be conscious of that?
11:53:26 <fr33domlover> bodie_, but that shouldn't matter when you just learn how to "tell the computer to compute stuff"
11:53:28 <Welkin> bodie_: you mean assembly
11:53:33 <dyl> This is one thing I think most programmers don’t get, coming from an engineering mindset. People are messy, they’ll take your flawless diamond of a system and beat it against the wall.
11:53:36 <fr33domlover> how it works inside is a technical detail
11:53:39 <dumptruckman> I also looked at Go with optimism and left disgusted.
11:53:44 <dyl> User studies are essential to understand how something is actually used.
11:53:44 <Welkin> you can mostly skip over C, or just use it as a stepping stone to a higher level language
11:53:54 <bodie_> well, my point was that all computer languages are not sufficient abstractions
11:53:56 <dyl> I did Ruby ⇒ C ⇒ Erlang initially lol
11:54:01 <dumptruckman> sorry... HI, I'm dumptruckman. I also looked at Go with optimism and left disgusted.
11:54:08 <exarkun> dyl: with a twenty year feedback loop (or longer) incorporating the career outcomes of the pedagogy?
11:54:09 <dumptruckman> can we turn this into a support group?
11:54:14 <Welkin> dumptruckman: and you are an addict?
11:54:24 <bodie_> hence "stay conscious that you are using an abstraction layer", not "learn to think in total abstraction"
11:54:32 <dyl> exarkun: that would be cool. Assuming career outcomes are a good metric, which I don’t think they are.
11:54:34 <bodie_> that sounds very painful
11:54:34 <aarvar> dyl: because social science is so realiable
11:54:37 <dumptruckman> I am addicted to constantly finding a new programming language
11:54:39 <dyl> The goal isn’t “teach programming to get a job”
11:54:47 <exarkun> dyl: well you'd have to factor a lot of stuff into "career outcome"
11:54:49 <DollarAkshay> Hey Im trying to install the language server on VSCode. When i do a `stack install` I get an error `Error parsing targets: The specified targets matched no packages.Perhaps you need to run 'stack init'?`
11:54:51 <bodie_> hi, my name is Bodie and I'm tired of using Go as my daily driver D:
11:54:54 <exarkun> dyl: not just salary or something simple like that
11:55:01 <dyl> It’s “teach programming as a skill for approaching problems and learning”
11:55:11 <exarkun> dyl: say, positive impact on society through technological activity
11:55:15 <aarvar> well, most programmers still haven't learned said skill
11:55:19 <fr33domlover> I learned coding for the first time when I wrote scripts in SimCity 3000 scenario editor :p in university they started with Java in the very first CS intro course, idk if that was a good idea (I already knew C++ by then so it wasn't new to me, but i guess to many people it was all new)
11:55:24 <dyl> “Yeah but do they get good jobs” is so cynical and nihilistic to me.
11:55:29 <dyl> It’s just not a meaningful metric.
11:55:32 <dyl> That’s not the point of school.
11:55:43 <aarvar> well, unfortunately it now is the point of school
11:55:45 <dyl> And that’s why we had PascalSxhools and JavaSchools
11:55:46 <aarvar> which is why school is so useless
11:55:56 <dyl> Then maybe we shouldn’t keep reinforcing it?
11:55:59 <dyl> Just a thought?
11:56:05 <Welkin> I used to be more into finding the latest and greatest language
11:56:06 <aarvar> I didnt say we should?
11:56:12 <dumptruckman> It IS the point of coding bootcamps though
11:56:14 <bodie_> school isn't the real problem here
11:56:20 <dumptruckman> If people want to look at it that way, they should go to bootcamp, not school
11:56:37 <Welkin> but recently I have realized I am very happy with haskell, various schemes/racket, lua, and c
11:56:38 <bodie_> neither is industry, unless your goal is just to make as many people as employable as possible
11:56:40 <dyl> Ideally an education is about learning how to learn.
11:56:52 <dumptruckman> Hell, they don't really teach you how to program in university
11:56:53 <fr33domlover> I think one goal at the very beginning is to make people feel that telling the computer what to do is a breeze, it's high level and even fun to explore
11:56:55 <dyl> Not learning a trade or skill. That’s what a trade school, boot camp, apprenticeship, etc is for
11:56:59 <Welkin> rust is one to look out for too
11:57:14 <aarvar> but if that's what education were about, it wouldnt be about grades and degrees
11:57:16 <bodie_> fr33domlover, why?
11:57:18 <Welkin> if a language doesn't bring my joy, I throw it away
11:57:23 <dumptruckman> Welkin: I feel the same way... When I discovered Haskell I fell in love with FP
11:57:28 <Welkin> the MariKondo approach to programming
11:57:29 <dyl> Rust is a welcome addition to the Simula su tree of the C family :p
11:57:42 <dyl> Controversial opinion: Objective-C is good.
11:57:47 <dumptruckman> But then was disappointed that most other languages don't have the nice things Haskell has
11:57:51 <aarvar> Welkin: you're happy with haskell? what?
11:57:54 <aarvar> haskell sucks
11:58:00 <dyl> Avoid success at all costs!
11:58:13 <aarvar> it succeeded at that!
11:58:17 <dyl> Shit!
11:58:31 <fr33domlover> bodie_, because if it feels tedious, heavy, complex, it will make people hate it. and the truth is that it can and should be fun and feel nice, so i think it's important to find a way to deliver than feeling right from the beginning, it's the first impression people get
11:58:33 <zachk> oo must have something to it if it's so successful
11:58:34 <aarvar> it was so successful that they had to ruin it by adding type families
11:58:34 <dyl> Haskell (or rather GHC) is more of a playground for new ideas.
11:58:39 <DollarAkshay> Hey Im trying to install the language server on VSCode. When i do a `stack install` I get an error `Error parsing targets: The specified targets matched no packages.Perhaps you need to run 'stack init'?`
11:58:40 <dyl> Much like Lisp.
11:58:51 <dyl> Type families are wonderful though...
11:58:57 <zachk> I wish most other languages had features from haskell
11:58:59 <dyl> I mean, horrible
11:59:07 <aarvar> dyl: other then the part where they make every kind inhabited
11:59:10 <fr33domlover> bodie_, complex things are hard and feel hard, but simple things should feel nice and simple
11:59:10 <aarvar> thanks to stuck type families
11:59:18 <aarvar> among other oddities
11:59:27 <dumptruckman> I guess Haskell is just ahead of its time much like Lisp was
11:59:36 <Welkin> sometimes I get frustrated with the way other people use haskell to make monstrously complex programs
11:59:42 <Welkin> I prefer a minimalist approach
11:59:42 <dyl> You know what was ahead of its time?
11:59:44 <dyl> Eiffel.
11:59:52 <lemmih> DollarAkshay: Did you run 'stack init'?
11:59:54 <zachk> smalltalk was way ahead of it's time
11:59:57 <dumptruckman> Not smalltalk
11:59:59 <dumptruckman> hah yeah
12:00:04 <dyl> Yes smalltalk :p
12:00:06 <bodie_> C felt nice and simple when I learned it at about 13 y/o.  what's hard is system APIs
12:00:07 <aarvar> and haskell is more like an old broken playground which people try to add new toys to anyway because there's no better alternative
12:00:08 <dyl> Hence why I like ObjC
12:00:13 <dyl> C + smalltalkisms
12:00:19 <dumptruckman> aarvar: yeS!
12:00:22 <dyl> A much more pure OO approach than C++
12:00:25 <dumptruckman> that's exactly how I feel
12:00:27 <Welkin> strings in C are a pain lol
12:00:28 <bodie_> nothing is simpler than structs and functions
12:00:32 <dyl> C++ is an octopus made by nailing extra legs to a dog.
12:00:45 <DollarAkshay> I am super new to Haskell. Is stack something like npm ?
12:00:46 <zachk> dyl, but where do they get the legs from?
12:00:46 <dumptruckman> That's why I'm really hopeful for Eta
12:00:52 <bodie_> yeah, but null-terminated byte arrays are simple
12:00:55 <dyl> aarvar: haskell is like one of those massive wooden castleish playgrounds
12:01:00 <dumptruckman> DollarAkshay: yes, something like that
12:01:00 <dyl> You can keep bolting more shit on it
12:01:03 <aarvar> dumptruckman: eta? what?
12:01:03 <dyl> And it just gets more fun.
12:01:04 <zachk> DollarAkshay, stack is a build system over cabal
12:01:07 <aarvar> eta is haskell
12:01:11 <zachk> cabal is kind of like npm
12:01:14 <dumptruckman> I know
12:01:17 <dumptruckman> but it runs on the JVM
12:01:22 <DollarAkshay> Hmm okay
12:01:22 <aarvar> even worse :)
12:01:25 <dumptruckman> and it has access to that whole ecosystem
12:01:28 <Welkin> zachk: cabal is nothing like npm
12:01:28 <Welkin> o.o
12:01:32 <Welkin> not even close
12:01:32 <dyl> Zachk please for the love of god don’t let it be like npm
12:01:34 <zachk> :(
12:01:34 <DollarAkshay> Im just trying to get a formatter working with VSCode
12:01:36 <Welkin> it isn't a package manager
12:01:40 <dyl> cabal install left-pad
12:01:42 <bodie_> lol
12:01:43 <zachk> haven't used npm that much
12:01:44 <Welkin> cabal new-* is a package manager of sorts though
12:01:45 <DollarAkshay> So that when I save it formats like eslint
12:01:53 <DollarAkshay> Any advice ?
12:02:00 <bodie_> stop thinking in terms of js
12:02:01 <bodie_> lol
12:02:04 <Welkin> haha
12:02:07 <dyl> ^
12:02:14 <dyl> JavaScript is the mind killer.
12:02:19 <delYsid`> hmm, can I somehow convert a lazy bytestring into a "normal" bytestring?
12:02:25 <dyl> - Muad’dib
12:02:27 <Rembane> delYsid`: Yes!
12:02:28 <dumptruckman> Hey, ES6 and newer isn't so bad
12:02:29 <Welkin> delYsid`: toStrict
12:02:41 <dyl> When you need a linter to use your language safely
12:02:44 <dyl> your language is broken.
12:02:44 <dumptruckman> Anything old can sadad
12:02:46 <aarvar> delYsid`: nope, once you have a lazy thing you're stuck for life
12:02:52 <aarvar> you can never evaluate it
12:02:58 <dyl> But hey, JS is at least better than PHP.
12:03:06 <bodie_> I'm pretty hopeful about Rust but I'm having challenges accepting that it's a good idea.
12:03:12 <dumptruckman> it's not hard to be better than PHP
12:03:25 <dyl> I’m excited about Rust in a freestanding platform environment with no runtime
12:03:28 <Welkin> bodie_: it feels really complicated compared to dong an equivalent thing in C
12:03:29 <dyl> Say, embedded
12:03:33 <Welkin> but is a huge improvement over c++
12:03:37 <aarvar> whatever happened to ATS
12:03:46 <DollarAkshay> None of you here use  a linting tool for haskell ?
12:03:50 <Welkin> delYsid`: no
12:03:51 <DollarAkshay> like hlint ?
12:03:52 <Welkin> DollarAkshay: no
12:03:53 <dumptruckman> I just hate the C stdlib
12:03:55 <Welkin> we don't need it
12:03:57 <DollarAkshay> WOW
12:03:58 <sclv> DollarAkshay: most haskell devs don't use auto-formatters because we like to do a lot of manual things to our formatting to make it line up
12:04:10 <bodie_> that's true Welkin, but it constantly catches me when I would carelessly do something dumb, and it has a nicer type system than C, too imo
12:04:11 <sclv> for vscode have you looked at haskelly? https://marketplace.visualstudio.com/items?itemName=UCL.haskelly
12:04:16 <DollarAkshay> Hmm Interesting
12:04:18 <sclv> lots of people like hlint actually
12:04:20 <sclv> you can learn from it
12:04:24 <hc> haskell is too expressive to need auto-formatters, one might argue =)
12:04:24 <sclv> but it doesn't do formatting
12:04:29 <aarvar> there's hindent
12:04:32 <dumptruckman> I used Atom for Haskell primarily
12:04:34 <Welkin> the only toolls I use are: the compiler, the build system, and syntax highlighting
12:04:35 <dumptruckman> I was pretty happy with it
12:04:36 <sclv> and you shouldn't take _all_ its advice, but tune the advice and learn from it
12:04:37 <Welkin> that's it
12:04:38 <DollarAkshay> @sclv Yeah Im trying all of that, but kinda stuck
12:04:38 <lambdabot> Unknown command, try @list
12:04:38 <Welkin> that's all you need
12:04:41 <exarkun> I let emacs indent my haskell code.  Does that make me a loser?
12:04:50 <sclv> i mean using inline formatting is great
12:04:52 <bodie_> I like the idea of using Rust in a dumb way, but in practice I always manage to dig my way down into horrible types and edge cases
12:05:00 <dyl> Quick, look! An emacs vs vim discussion!
12:05:00 <aarvar> I use hindent for most code
12:05:02 <sclv> to help get indentation right typically
12:05:03 <exarkun> And I let ghci tell me about type errors I make.  I'm pretty dumb though.
12:05:05 <bodie_> emacs /thread
12:05:08 <dyl> (for some definition of "discussion")
12:05:08 <aarvar> sometimes I format things myself though
12:05:12 <sclv> but yeah, hindent is very opinionated and stopped being configurable
12:05:15 <dyl> vim <esc>:q
12:05:22 <sclv> so autoformatting vs machine-assisted manual formatting is the issue
12:05:22 <dyl> Let's not.
12:05:27 <sclv> most people prefer the latter
12:05:38 <DollarAkshay> Hmm interesting
12:05:43 <Welkin> emacs haskell-mode does everything you need
12:05:52 <dyl> I wish there was a better haskell mode for vim.
12:05:55 <dyl> It is better in emacs.
12:05:57 <Welkin> auto-indentation cycling and syntax highlighting
12:06:12 <dumptruckman> does it have a built in repl by default?
12:06:18 <Welkin> dyl: just use vim keybindings in emacs o.o
12:06:23 <bodie_> code reviewers prefer opinionated autoformatting
12:06:26 <Welkin> ghcid exists
12:06:27 <Welkin> and ghc-mod
12:06:29 <bodie_> just sayin'
12:06:30 <Welkin> and all kinds of other things
12:06:32 <Welkin> I din't use any of them
12:06:35 <dyl> I'm more interested in the language-server model than the old fashioned mode model in general.
12:06:42 <dyl> Compilers are in some sense (functional) databases.
12:06:44 <dumptruckman> what is that anyway?
12:06:46 <sclv> i prefer using a repl in a terminal to the built-in emacs repl
12:06:48 <dyl> They do a lot more than just compile programs.
12:06:49 <bodie_> all LSP implementations are terrible
12:07:02 <Welkin> bodie_: Kumpy Space Princess?
12:07:04 <dyl> Also, Emacs would be much better if it wasn't Emacs lisp.
12:07:04 <sclv> basically because indirecting ghci thru the emacs repl can lead to occasional frustration
12:07:06 <Welkin> bodie_: Lumpy Space Princess?
12:07:11 <bodie_> language server protocol
12:07:12 <sclv> especially with long/interactive output, etc
12:07:17 <dyl> bodie_ sadly yes
12:07:21 <dyl> I mean it in a more general sense.
12:07:22 <aarvar> sclv: don't you have to :r to reload then though?
12:07:27 <sclv> yes i do
12:07:28 <dyl> The model, not the implementation.
12:07:28 <aarvar> or can you get it to do it automatically on save
12:07:32 <sclv> i don't see why that's hard :-)
12:07:35 <bodie_> it's definitely a cool concept but in practice it's just another pile of kludge and headache
12:07:39 <bodie_> programming already has so much of that
12:07:43 <sclv> i type a while, save, switch focus, then hit up-arrow-return
12:07:56 <dyl> bodie_ the key idea I think is that the compiler is the single source of truth.
12:07:58 <aarvar> unless you typed things in before
12:08:08 <aarvar> then it's multiple up arrows or :r
12:08:11 <DollarAkshay> Also one more question. Does Haskel treat arthemetic operators like +, -, * and / as infix functions ?
12:08:11 <dyl> It has all of the relevant information.
12:08:18 <bodie_> which part of gcc contains the truth about a particular program?
12:08:25 <sclv> and that works when i'm not in a repl, but just the console
12:08:35 <Welkin> I don't like too much automation, because it will always break at some point, or will secretly do something you don't expect
12:08:36 <dyl> bodie_ gcc is a bad example.
12:08:39 <chaosmasttter> > 1 + 2
12:08:39 <sclv> and instead of :r up-arrow takes me to like "cabal new-build"
12:08:39 <bodie_> ;)
12:08:40 <aarvar> sclv: meanwhile I do , s b, which is even worse :)
12:08:40 <lambdabot>  3
12:08:52 <bodie_> I think it's a good example.
12:08:53 <dstolfa> the thing that holds the truth of a program is the microarchitecture, if we stop there that is :)
12:08:55 <dyl> bodie_ I've also managed to jettison gcc entirely. clang-lyfe.
12:08:58 <sclv> i confess i miss focus-follows-mouse since i'm in os-x
12:09:01 <sclv> but cmd-tab isn't much worse
12:09:04 <Welkin> I even use bash scripts to do certain things like deploy servers
12:09:12 <dumptruckman> DollarAkshay: yes
12:09:19 <dyl> Welkin you know what's worse than npm?
12:09:19 <dyl> gulp.
12:09:26 <aarvar> sclv: os-x doesn't have that?
12:09:41 * aarvar has pretty much never used a mac
12:09:41 <bodie_> please, no more javascript
12:09:42 <sclv> not by default, no
12:09:57 <dyl> I use Magnets and Contexts on OS X.
12:09:58 <bodie_> I actually want web browsers to entirely go away
12:10:04 <dumptruckman> modern JS has nice things though
12:10:10 <aarvar> wat
12:10:17 <dyl> dumptruckman: But it also has JS.
12:10:23 <Welkin> dumptruckman: except const being a lie, and no tco
12:10:25 <DollarAkshay> dumptruckman So how does the + function actually add numbers then ?
12:10:34 <bodie_> the browser is the thing that should not be
12:10:38 <Welkin> and ===
12:10:39 <dumptruckman> DollarAkshay: i don't know what you mean
12:10:43 <dyl> DollarAkshay it doesn't, it just creates a thunk :p (jk)
12:10:43 <DollarAkshay> If + is a function then what does it use inside that function ?
12:10:53 <aarvar> depends on the type
12:11:05 <bodie_> god only knows
12:11:07 <bodie_> is the real answer
12:11:10 <dyl> :t (+)
12:11:11 <lambdabot> Num a => a -> a -> a
12:11:12 <aarvar> but it uses +# for Ints
12:11:15 <dumptruckman> modern JS destructuring and rest operators are bae
12:11:20 <bodie_> no haskell users understand haskell
12:11:23 <dyl> If you say "are bae" one more time
12:11:29 <aarvar> :t (+#)
12:11:30 <lambdabot> error:
12:11:30 <lambdabot>     • Variable not in scope: +#
12:11:30 <lambdabot>     • Perhaps you meant one of these:
12:11:36 <aarvar> :t (GHC.Prim.+#)
12:11:37 <lambdabot> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
12:12:03 <dyl> :k GHC.Prim.RealWorld
12:12:04 <lambdabot> *
12:12:07 <dyl> Shocking.
12:12:31 <sclv> DollarAkshay: lots of the primitive types have operations written as "primitives" that use underlying c code
12:12:48 <aarvar> dyl: why is that shocking?
12:12:52 <dyl> Facetiousness.
12:12:53 <Ariakenom> DollarAkshay, does it need something inside the function? The compiler could just treat that function as a primitive. It just looks like a function to us.
12:12:54 <aarvar> :k State#
12:12:55 <lambdabot> error:
12:12:55 <lambdabot>     Not in scope: type constructor or class ‘State#’
12:12:55 <lambdabot>     Perhaps you meant one of these:
12:12:58 <DollarAkshay> Interesting
12:12:58 <aarvar> ugh
12:13:06 <dyl> :k GHC.Prim.State#
12:13:07 <lambdabot> * -> TYPE ('GHC.Types.TupleRep '[])
12:15:34 <dyl> So, unrelated to all of this, I'm still not sure how to nicely represent this tree building process.
12:15:49 <dyl> I can model it, but I'm trying to find The Most Haskell Way^(TM)
12:15:59 <DollarAkshay> Thanks a lot everyone :) I shall take another shot at Haskell
12:16:10 <aarvar> DollarAkshay: http://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.Num.html#line-68
12:16:25 <Ariakenom> dyl, have you tried abstract nonsense?
12:16:32 <dumptruckman> man...
12:16:36 <aarvar> dyl: anamorphism
12:16:42 <dumptruckman> if I could have OneNote on linux my dev life would be so much nicer
12:16:53 <runeks> Does anyone know if the machine code generated for the following two function
12:17:25 <dyl> Well, I am trying to see if I can model it as an algebra.
12:17:35 <aarvar> dyl: *coalgebra
12:17:58 <dyl> I should be clear about what I'm doing: https://dfns.dyalog.com/n_parse.htm
12:18:06 <dyl> It's this process (pairwise reduction) for syntactic analysis.
12:18:15 <dyl> I'm trying to find a *neat* way to model this functionally :p.
12:18:30 <dyl> Just writing a plain old shift-reduce state machine is boring.
12:18:32 <Welkin> dyl: Anit?
12:18:40 <bodie_> trying to play sudoku? :P
12:18:42 <runeks> s will differ?: “f(x)=let a=2 in x*a” versus “f(x)=x*2”
12:18:54 <sclv> DollarAkshay: https://github.com/ghc/ghc/blob/efd70cfb4b0b9932a880ab417d75eaf95da3d5e6/compiler/codeGen/StgCmmPrim.hs#L1214
12:19:06 <sclv> is where this specific thing actually happens in this case
12:19:14 <dyl> I am basically considering two elements of the list from the right (three with the lookahead)
12:19:22 <dyl> and then shifting the window, or reducing the two elements
12:19:29 <dyl> But I'm not sure how to model this nicely as a fold.
12:19:33 <sclv> so its not even using underlying c code via ffi or "cmm" (which is an internal c-like language) but generating the machine op directly
12:19:52 <Welkin> dyl: just use an explicit recursive function
12:20:03 <Welkin> I don't think it is worth it to be clever with folds
12:20:09 <dyl> It's not about worth it :p.
12:20:34 <dyl> This is Haskell! I have to overthink and overcomplicate the problem!
12:20:39 <dyl> https://www.youtube.com/watch?v=nrIPxlFzDi0
12:22:06 <sclv> dyl: what about some variant on the old "zip `ap` tail" trick?
12:22:24 <Ariakenom> runeks: I don't see why they would. Why do you ask?
12:22:53 <dyl> sclv which trick?
12:23:19 <sclv> if you want to consider elements of a list in context, you zip the list with its tail
12:23:29 <sclv> > zip `ap` tail $ [1..3]
12:23:31 <lambdabot>  [(1,2),(2,3)]
12:23:44 <runeks> Ariakenom: I believe I read somewhere that let expressions are allocated differently from function arguments, but I’m not sure, that’s why I ask
12:23:49 <dyl> Oh, that.
12:23:53 <sclv> so you could fold over a contextified list
12:23:58 <dyl> I was more thinking about how to do this with zippers.
12:24:04 <dyl> And also, every time I reduce I start back from the end.
12:24:09 <dyl> And it's more like a list of trees.
12:24:26 <sclv> ok so what about using a free comonad?
12:24:41 <Ariakenom> runeks: ok. can't help you with that sorry
12:24:42 * dyl is woefully underexposed to comonads.
12:24:48 <sclv> where (limited) context comes from the duplicate operation
12:25:13 <sclv> basically think of it as a functor `f` with the additional property that you have `f a -> f (f a)`
12:25:21 <Welkin> comonads are pretty cool
12:25:24 <Welkin> but you don't need them
12:25:28 <sclv> such that this `duplicate` gives you back each element with a surrounding, potential local context
12:25:50 <dyl> Well, I'll write something naive first and then seek help rethinking it.
12:25:55 <sclv> and then if you duplicate and then extract back out the "point" (i.e. the location of each)
12:26:06 <sclv> then you get back to the original structure
12:26:14 <sclv> so its a well-behaved generalization of the zip tail trick actually
12:26:19 <sclv> but it works on nice trees and things
12:26:28 <sclv> and you can generate many useful ones "freely"
12:26:47 <sclv> zippers and comonads are actually very tightly related
12:26:55 <dyl> That I am aware of.
12:27:04 <dyl> I need to refresh a lot of my memory haha.
12:27:39 <sclv> (right, you don't "need" a lot of this stuff to do it, i agree. but this is explicitly a convo about looking for "fun" ways to do things)
12:27:46 <dyl> Isn't the zipper of any tree-like thing always a comonad anyhow?
12:27:50 <sclv> yes
12:27:51 <dyl> That it is :p.
12:28:18 <dyl> I'm trying to, basically, work my way around a forest, and stick trees together.
12:28:18 <sclv> i often find that where i used to reach for zippers, just writing comonads explicitly is often a more straightforward approach
12:28:25 <dyl> With a shift-reduce type process.
12:28:31 <bodie_> I've been looking at haskell from the outside for years now and I still don't think I understand the point of these semantic constructs.
12:28:42 <bodie_> I just don't really see the utility.
12:28:42 <aarvar> runeks: the compiler will optimize the let away anyway in that case
12:28:45 <dyl> bodie_ at their best they're point-free
12:28:47 <sclv> bodie_: that's because you're looking at haskell from the outside!
12:28:59 <bodie_> it's also WHY I'm looking at it from the outside :P
12:29:03 <sclv> once you start programming in earnest they arise
12:29:03 <dyl> bodie_ have you tried looking at CoHaskell from the inside?
12:29:09 <sclv> i mean you can avoid them and write haskell
12:29:19 <sclv> and then start looking for more "elegant" ways to do certain things
12:29:25 <sclv> and then the motivation presents itself
12:29:53 <runeks> aarvar: I assumed so. But what if it didn’t, would it make a difference?
12:30:12 <bodie_> but I can just do those things in a simple and pragmatic way instead of using type theory.
12:30:19 <sclv> ok, then do that
12:30:24 <sclv> also there's no type theory involved
12:30:35 <sclv> this is categorical constructs, a separate discipline
12:30:43 <bodie_> if I can just do that, then why would I want to do it the way you're describing?
12:30:50 <sclv> i mean i prefer to do it my way
12:30:50 <bodie_> I'm just trying to see the point here
12:30:52 <sclv> if you don't want to learn it
12:30:55 <sclv> then don't
12:30:56 <cool_penguins> hey guys
12:31:00 <sclv> and don't ask about it
12:31:09 <bodie_> I mean maybe I don't want to learn it because I don't understand why I would want to lol
12:31:10 <sclv> i don't feel the need to preach to you about it
12:31:17 <sclv> bodie_: ok, then don't understand
12:31:18 <sclv> *shrug*
12:31:21 <bodie_> XD
12:31:38 <aarvar> runeks: not sure xd
12:31:45 <bodie_> this gives me the answer to my question ;)
12:31:45 <aarvar> but I think so?
12:31:54 <Welkin> bodie_: that's the research side of haskell
12:32:07 <sclv> no its not just research
12:32:10 <Welkin> you don't *need* any of the abstractions
12:32:19 <sclv> i mean i'm among a number of people who use this stuff for practical and not research purposes
12:32:25 <aarvar> you dont need any abstraction at all. Never use functions
12:32:26 <sclv> you don't have to, but its not just research anymore
12:32:27 <Welkin> they can be useful, if you understand them and if everyone else working on the code does too
12:32:32 <aarvar> but then you're not really programming are you
12:32:33 <bodie_> aarvar, good point
12:32:42 <Welkin> I use haskell to build software, not do research
12:32:48 <sclv> so do i
12:32:55 <sclv> and i like to use comonads to do it on occasion!
12:33:06 <aarvar> Welkin: I hope you don't use monads
12:33:09 <dyl> One fun research problem: how many large Haskell libraries/programs are there that haven't been kmetted?
12:33:16 <Welkin> I don't even like typeclasses beyond the basic ones provided by base
12:33:21 <Welkin> lol
12:33:22 <aarvar> dyl: not enough :)
12:33:31 <dyl> kmetted being the verb which implies a single dependency suddenly resulting in semigroupoids, free, adjunctions, kan-extensions, lens,... all coming along for the ride.
12:33:32 <aarvar> woops, I mean too many
12:33:35 <hexagoxel> DollarAkshay: i don't use vscode, but there is https://marketplace.visualstudio.com/items?itemName=MaxGabriel.brittany
12:33:45 <aarvar> I clearly can't understand negatives
12:33:52 <dyl> There really should just be an umbrella package called "kmett" that pulls them all in.
12:34:01 <aarvar> kmett-prelude
12:34:07 <dyl> kmettlude.
12:34:13 <boxscape> Prekmett
12:34:23 <dyl> kiskmett
12:34:25 <aarvar> Postkmett
12:34:29 <dminuoso> cokmett.
12:34:32 <cool_penguins> Anyone here use ghc-mod?
12:35:07 <hexagoxel> `brittany` is more configurable than hindent. with master/the upcoming next release, it will even support "inline config" that affect single functions.
12:35:20 <infandum> On the subject of "holding a reference": f = sum xs; where xs = [1..10000000] is bad because it builds it all in memory. But what if it's more unpredictable? For instance, f a = b; where b = g a c; c = h a, here a needs to be used twice and is there such a serious punishment in space and time usage to make it clearer instead of f a = g a $ h a or the like?
12:35:50 <dminuoso> dyl: either-5 is that. You touch it, and you get half of edwards libraries for free as transitive dependencies!
12:35:59 <Welkin> hexagoxel: is it named after a waifu?
12:36:13 <bodie_> okay so honestly the reason I came to look at haskell was that I bumped into type walls in rust where its type system wasn't as expressive as I wanted it to be.
12:36:20 <dyl> Can you imagine if all of Edward's libraries suddenly disappeared from hackage?
12:36:27 <bodie_> like its enum is very boring.
12:36:28 <dyl> It would be infinitely worse than the left-padpocalypse.
12:36:29 <jle`> infandum: f = sum xs where xs = [1..100000000] doesn't necesarilly build the entire list in memory
12:36:35 <aarvar> infandum: in your first example, xs won't be held in memory unless you use it somewhere else
12:36:57 <bodie_> I like the safety and control aspects, and I like that it's straightforward to reason about runtime behaviors.
12:36:58 <dyl> dminuoso None of us would be entirely sure how to reimplement all of them.
12:37:04 <aarvar> well, in theory it could be, but it wont
12:37:06 <bodie_> and machine-assisted
12:37:29 <infandum> aarvar: I was referring to https://wiki.haskell.org/Memory_leak#Holding_a_reference_for_a_too_long_time
12:37:48 <aarvar> infandum: the key in that example is that xs is used twice
12:37:48 <Welkin> bodie_: the great thing about haskell is that you can use it however you want. You can use all the extensions and crazy abstractions you want. Or you can be minimalistic and restrict yourself to a subset of the available featureset (which is huge), or something in-between
12:38:07 <infandum> aarvar: Oh sorry, I missed that
12:38:16 <infandum> well yeah, then something like that haha
12:38:18 <aarvar> infandum: and one operation runs before the other
12:38:23 <bodie_> what I'm interested in is having straightforward runtime behaviors that I can easily reason about when reviewing someone's code.
12:38:26 <dyl> {-# LANGUAGE OneWithEverything #-}
12:38:30 <Welkin> lol
12:38:36 <Welkin> runtime behavior is not easy to reason about
12:38:38 <Welkin> being a lazy language
12:38:43 <dyl> non-strict ;p.
12:38:45 <aarvar> infandum: so sum has to evaluate xs, but it has to be kept in memory after that to evaluate product
12:38:51 <bodie_> that doesn't sound useful
12:39:06 <Welkin> laziness by default is extremely useful
12:39:06 <dyl> If you want to reason about runtime behavior more, get ready to love exclamation points!
12:39:09 <bodie_> but you guys like to write software in it, so I must be missing something.
12:39:13 <dyl> (and even that's just WHNF)
12:39:29 <dyl> bodie_ Doing Haskell is kind of like doing mathematics, or going to the gym regularly.
12:39:33 <dyl> It's painful but it eventually becomes an addiction.
12:39:36 <dminuoso> bodie_: Well in the end you have to understand the underlying execution model for any language.
12:39:48 <dyl> And you can express things you can't in other languages and toy with ideas.
12:39:54 <bodie_> it is my understanding that Haskell allows you to control runtime behaviors as much as you choose to.
12:39:54 <dminuoso> bodie_: Most folks coming from other languages just have the advantage of _already being experienced_ in their favourite language/implementation.
12:40:00 <aarvar> dyl: disagree that it's painful
12:40:01 <Welkin> bodie_: yes, you can
12:40:02 <dyl> But, personally, I wouldn't use it in production, mainly because I wouldn't be able to keep myself from going down rabbit hole.s
12:40:02 <hexagoxel> Welkin: eh, no. not sure if i'd want someone to name a formatter after me, of all things :)
12:40:06 <Welkin> you can make everything strict if you want
12:40:07 <dyl> Painful in a good way aarvar.
12:40:08 <dminuoso> bodie_: But no undergrad will have a clue how to judge real performance characterstics looking at any code.
12:40:10 <infandum> aarvar: Sure, and the solution is that xs is like a loop here, so you can just "loop" twice. What is xs was instead a very complicated matrix multiplication or the like?
12:40:31 <bodie_> what if I'm lucky enough and clever enough to acquire clever teammates?
12:40:44 <Welkin> cleverness is not a virtue
12:40:48 <bodie_> lol
12:40:51 <dyl> laziness is a virtue.
12:40:54 <dyl> ;p
12:41:04 <dyl> (for some definition of laziness)
12:41:08 <aarvar> infandum: well, do you want to share the result or not?
12:41:24 <Welkin> anyway, haskell is nice because it lets you very easily control whether you want lazy or strict evaluation
12:41:31 <bodie_> I think I'm getting the idea.
12:41:34 <Welkin> in most languages you don't have that option, and adding laziness is hard
12:41:35 <bodie_> Maybe I will check it out.
12:41:47 <bodie_> So far I've only had to use haskell that someone else wrote (not very well)
12:41:48 <Welkin> making things strict in haskell is pretty easy
12:41:48 <dyl> sclv Any thoughts/links on how I would approach using comonads/zippers to do this contextual sliding down a list?
12:41:51 <dminuoso> bodie_: You can reason a lot just by looking at types, which is a really great advantage of purity and parametricity. Add in some laws like those from Functor/Applicative/Monad, then it's fairly easy to just jump into some random code and gain some pretty strong insights.
12:41:59 <dyl> I'm trying to find some appropriate blog posts to get myself back into the swing of things.
12:42:06 <infandum> aarvar: I suppose both functions would need that same input...
12:42:10 <dyl> dminuoso ^
12:42:27 <dyl> If you know something is a Monoid for example, you already know most of how it's going to be used.
12:42:29 <aarvar> infandum: if the question is how to get haskell to not share things, it can be tricky
12:42:35 <dminuoso> bodie_: It makes refactoring a real breeze compared to most other languages.
12:42:45 <infandum> I just wish it could somehow be consumed efficiently by both other functions using the same input
12:42:58 <aarvar> fusion?
12:42:59 <Welkin> it's true that there is a lot of extra overhead in using haskell that requires a lot of dedication to learning new ideas and just getting used to it
12:43:16 <infandum> like how Control.Foldl works, but with anything, not just a foldable
12:43:18 <Welkin> is it worth it in the end? You get to decide, but it was definitely worth it for me
12:43:24 <Welkin> it even changed how I program in all other languages
12:43:28 <Welkin> for the better
12:43:43 <bodie_> how hard is it to build sound systems in Haskell?  I feel like it would be very hard to reason about how a system is going to behave.  let's say I'm building a service network
12:43:53 <dyl> Languages everyone should learn even if they never use them: Scheme, Haskell, Erlang, Prolog and Smalltalk.
12:43:58 <aarvar> infandum: going back to the sum/product example, it's possible to fuse the operations and compute the sum and product at the same time
12:44:02 <bodie_> I don't want a weirdly complicated runtime getting in the way.  that's even a hesitation with like, erlang
12:44:04 <dyl> These are languages that will teach you new ways to think about problems.
12:44:05 <aarvar> so that you only iterate through the list once
12:44:06 <Welkin> bodie_: because you control if something is strict or lazy, you have very fine control over it
12:44:08 <runeks> aarvar: I believe the third bullet point here was what I was referring to: https://github.com/quchen/stgi/blob/master/README.md#pitfalls
12:44:09 <dminuoso> bodie_: Well Haskell definitely is easier to reason about because of lawful abstractions and the ability to separate pure and impure code.
12:44:13 <aarvar> infandum: is that what you're talking about?
12:44:16 <dyl> bodie_ Erlang is amazing M3.
12:44:17 <dyl> <3*
12:44:20 <dyl> I <3 Erlang.
12:44:32 <dyl> The Erlang runtime is your friend.
12:44:36 <Welkin> erlang is very cool, but I just have never found a use case for it
12:44:36 <infandum> aarvar: Sure, with Control.Foldl I can do that easily on a foldable, but I mean on any shared object, but that's too dreamlandy
12:44:39 <runeks> Ie. that the value in the let binding will be allocated on the heap, as opposed to on the stack
12:44:45 <bodie_> runtimes are neat, but less runtime is simpler.
12:45:00 <jle`> bodie_: sound systems are easier in haskell, i think, than any other language
12:45:01 <bodie_> simpler is easier to reason about and make sound
12:45:02 <dyl> Welkin anything user-facing over the internet you need to be reliable.
12:45:07 <aarvar> infandum: well, you can have a general notion of fold for any sort of recursive type
12:45:16 <jle`> haskell's runtime isn't necessarily difficult to reason about
12:45:18 <dminuoso> jle`: -Coq :P
12:45:23 <Welkin> dyl: I have had warp (haskell) servers running for several years now
12:45:28 <Welkin> without ever crashing or rebooting
12:45:33 <bodie_> it's really just a question of when things are going to get evaluated right?
12:45:38 <bodie_> is there a decent debugger?
12:45:40 <dyl> Welkin Nothing has yet come close to Erlang's quality for writing servers (especially when there are many nodes and not just one server), imo.
12:45:42 <jle`> bodie_: in practice, not really
12:45:53 <dyl> It's a language made for a purpose, and it's very good for that purpose.
12:45:54 <jle`> bodie_: it's easy to write strict code when it makes more sense, and easy to write lazy code when it makes more sense
12:45:56 <dminuoso> bodie_: Well the notion of "when things are going to get evaluated" dont really matter. Or they shouldn't.
12:46:04 <dminuoso> (Beyond space leaks)
12:46:14 <jle`> bodie_: usually you write lazy code in the situation where it's easy to understand, and in other situations, you write strict code (when it's easier to understand)
12:46:15 <bodie_> that doesn't make sense to me
12:46:20 <infandum> aarvar: Yes, but let's say xs is a matrix and instead of product * sum it's a matrix multiplication of a transformation of xs with another transformation of xs
12:46:20 <bodie_> okay
12:46:28 <Welkin> laziness can lead to greater efficiency
12:46:29 <bodie_> oh, I see dminuoso
12:46:32 <infandum> I'm pretty sure it's impossible in any language
12:46:34 <cocreature> how can I see for which functions GHC decides to include the definitions in the interface file?
12:46:35 <bodie_> because of purity
12:47:03 <mpickering> cocreature: --show-iface
12:47:03 <Welkin> and simpler code
12:47:11 <cocreature> mpickering: perfect, thanks!
12:47:16 <bodie_> I guess that I do a lot of the work to make things sound myself without machine assistance.
12:47:17 <aarvar> infandum: depends on how the two operations consume the matrix. And how the matrix is represented
12:47:20 <mpickering> You run that on the interface file
12:47:32 <mpickering> or you can use -ddump-simpl and see which definitions have unfoldings
12:47:39 <bodie_> hm.
12:47:50 <infandum> aarvar: Representation would be: https://hackage.haskell.org/package/sparse-linear-algebra-0.2.9.9
12:47:55 <dminuoso> bodie_: You get certain guarantees. For example `a >> b` for some `a :: IO ()` and `b :: IO ()` guarantees that the action in `a` will be sequenced before `b`
12:48:02 <bodie_> dyl, would you ever consider using Haskell in the same space you'd use erlang?
12:48:04 <jle`> bodie_: writing haskell means that you have to think about less
12:48:10 <dyl> bodie_ Hmm, maybe.
12:48:14 <dyl> Depends on the task at hand.
12:48:15 <jle`> in terms of runtime and IO and state etc.
12:48:34 <dyl> It looks like this isn't really happening much anymore?
12:48:34 <dyl> http://haskell-distributed.github.io
12:48:39 <jle`> by that i mean there's less you have to hold in your mind when you program
12:48:44 <jle`> things are *less* complicated
12:48:47 <infandum> aarvar: transformation would be matrix multiplications and scalar multiplication
12:48:54 <bodie_> I am definitely not experienced enough thinking about haskell to try it for this new project but I think I can see a bit of the value proposition at least.  Maybe I'll give it a little try.
12:49:02 <aarvar> infandum: and the desired result is what?
12:49:04 <bodie_> Any suggestions on a starting project to learn from?
12:49:06 <dminuoso> bodie_: Why not try it for the new project anyway! :)
12:49:10 <infandum> aarvar: Another matrix
12:49:11 <dminuoso> Learn as you go.
12:49:12 <bodie_> Because it needs to work.
12:49:23 <aarvar> infandum: I mean, how do you want this other matrix to be computed
12:49:41 <infandum> aarvar: Matrix multiplication
12:49:48 <infandum> Lots of matrix multiplication haha
12:49:53 <bodie_> not only does it need to work, I need to lead other people to work on it.
12:50:01 <aarvar> the question was about sharing. What do you want to be shared?
12:50:08 <aarvar> or not shared
12:50:12 <GobiGobi> Hey guys, I'm currently using `stack test` on a project to check for errors. It takes ages, is there a way to speed this up?
12:50:27 <dyl> Random musing: do you think Haskell programmers like spicy foods on average more than programmers in general?
12:50:28 <dminuoso> GobiGobi: travis-ci? :P
12:50:28 <infandum> aarvar: Like above
12:50:38 <dyl> Programmers in general tend to like spicy foods more than the general population.
12:50:46 <aarvar> GobiGobi: write a proof in coq so you don't have to test it?
12:50:54 <infandum> aarvar: f b = c; where d = g b; c = h b d
12:51:11 <dminuoso> GobiGobi: Why not profile your tests?
12:51:22 <infandum> g and h are functions that do matrix multiplication and inversions and scalar multiplication
12:51:27 <dyl> Live dangerously: delete all of your tests.
12:51:33 <GobiGobi> dminuoso: profile meaning?
12:51:39 <dminuoso> GobiGobi: rts profiling.
12:51:40 <GobiGobi> aarvar: lol
12:51:44 <infandum> aarvar: but b, d, and c are all matrices
12:51:51 <dminuoso> GobiGobi: a test is just a haskell program. surely it must be profilable.
12:51:57 <dyl> Profiling means analyzing the behavior of a program at runtime.
12:52:05 <dyl> e.g. how long is spent in call sites
12:52:18 <dyl> How many times a function is called
12:52:20 <dyl> That kind of thing
12:52:49 <dyl> If you had some program behaving slowly you might profile it to find the call sites responsible for most of the time spent
12:52:51 <dminuoso> GobiGobi: If things get slow the rule of thumb is: Profile. Understand cause. Improve code (if applicable)
12:52:53 <infandum> aarvar: Also, the entire matrix is used in the end, there's no "only one column" or whatnot
12:52:56 <dyl> so you can pin down where you ought to optimize.
12:53:03 <GobiGobi> dyl: thanks
12:53:04 <dminuoso> GobiGobi: In that order. The first step is not optional.
12:53:09 <dyl> Profiling is what you always do before optimizing.
12:53:16 <dyl> Never optimize without profiling first :p
12:53:19 <GobiGobi> dimuoso: Thanks, that seems currently out of my scope for now
12:53:24 <dminuoso> GobiGobi: It's super easy.
12:54:22 <dminuoso> GobiGobi: `stack test --profile` =)
12:55:29 <GobiGobi> dminuoso: thanks
12:56:44 <Welkin> GobiGobi: 隔壁？
12:57:05 <GobiGobi> Welkin: Negative
12:58:33 <Welkin> GobiGobi: 戈壁
12:59:53 <Welkin> is it a joke about ocaml?
12:59:54 <bodie_> one last question: why would I want to use haskell instead of ocaml or some other ML?
13:00:04 <Welkin> bodie_: ocaml and ml suck :/
13:00:10 <Welkin> sml*
13:00:25 <Welkin> haskell allows effects in the type system
13:00:33 <Welkin> in ocaml everything is essentially in IO
13:00:56 <mpickering> lyxia: Have you used generic-random with data types defined as the fixpoint of a functor?
13:01:00 <Welkin> plus the syntax is horribly ugly
13:01:15 <mpickering> Does genericArbitraryRec do the right thing in this case? or how can I control the size
13:05:31 <aarvar> bodie_: higher kinds
13:05:45 * hackage mattermost-api-qc 40900.0.0, mattermost-api 40900.0.0 (JonathanDaugherty): https://qbin.io/proxy-bali
13:05:46 <aarvar> higher level of abstraction
13:06:12 * hackage matterhorn 40900.0.0 - Terminal client for the Mattermost chat system  http://hackage.haskell.org/package/matterhorn-40900.0.0 (JonathanDaugherty)
13:19:08 <delYsid`> wow, a 140MB executable static site generator, heh.
13:19:17 <Sonarpulse> "Conflicting family instance declarations" bu bu bu they conincide
13:19:23 <Sonarpulse> I can't tell the instance thing that can I?
13:22:07 <dyl> sclv Looks like sublist zippers aren't comonads.
13:22:17 <sclv> hrm
13:22:23 <dyl> Just an interesting note.
13:25:32 <dyl> sclv you can't meaningfully define extract for a sublist zipper.
13:25:46 <dyl> But any single-element zipper naturally forms a comonad.
13:26:21 <sclv> not sure what you mean by sublist zipper -- one where the "focused element" is a full sublist?
13:26:24 <sclv> haven't seen those before
13:26:29 <dyl> Yes.
13:26:36 <dyl> Think of a "sliding window" through a list.
13:26:40 <sclv> right
13:26:46 <sclv> i don't even think of that as a zipper tbh
13:26:56 <dyl> It's a little forced.
13:27:06 <sclv> rather i'd see it as a single element and a sublist given by the zipper context itself
13:27:14 <dyl> The issue is that I want to traverse a list (from the right, but reversed wlog) in triples
13:27:25 <dyl> and then either shift the window over, or reduce the right pair
13:27:35 <dyl> and by this process form a binary tree (which IS a comonad)
13:27:36 <sclv> reduce the right pair mean?
13:27:56 <dyl> Look at the worked example here, the diagrams: https://dfns.dyalog.com/n_parse.htm
13:28:09 <dyl> say your window is (l, c, r)
13:28:24 <dyl> when bindingPower l c < bindingPower c r, you reduce c and r
13:28:39 <dyl> And otherwise you shift, unless they're equal and both zero, in which case you have an error.
13:28:46 <sclv> ah gotcha
13:28:56 <dyl> It's a bottom up tree building process.
13:29:12 <dyl> So, it makes sense to start from a list of leafs.
13:30:12 * hackage battleplace 0.1.0.2 - Core definitions for BattlePlace.io service  http://hackage.haskell.org/package/battleplace-0.1.0.2 (quyse)
13:31:12 <dyl> sclv However, for the iteration over the list bit, there's no need to use zippers.
13:31:32 <dyl> The thing is that I want to reduce a pair, and then iterate the result, so I was hoping for a nicer abstraction for that.
13:31:45 <dyl> And a zipper containing before and after is exactly the state I need to build the new list.
13:31:53 <dyl> So, it might be nicer that way.
13:32:32 <bodie_> primer on hkt?
13:32:44 <dyl> I'm not sure if a zipper/comonad is appropriate for building the trees though.
13:32:48 <dyl> Might be a bit forced.
13:41:17 <lyxia> mpickering: I haven't tried, but that shouldn't be a problem when using genericArbitraryRec + an explicit base case.
13:42:13 <mpickering> How does the automatic resizing work? Because the recursive part is from "Fix" which doesn't branch
13:42:55 <mpickering> I can try though if you think it will work. I only started using the library a little while ago
13:44:59 <lyxia> There's nothing to decide whether to resize, that's for the user to say explicitly by choosing genericArbitraryRec instead of the other variants.
13:45:11 <mpickering> ok
13:45:32 <lyxia> (then it divides the size by the number of fields of the chosen constructor)
14:02:36 <boxscape> I'm messing around with the singletons library. Is there any way I can make test3 here work? I think I understand why it doesn't work, since the type signature requires it to a generic k, whereas it's actually going to return a specific k, but is there a type signature that works here?http://lpaste.net/365272
14:02:43 <boxscape> let me post that link again http://lpaste.net/365272
14:02:47 <boxscape> was'nt formatted correctly
14:02:57 <boxscape> (at least in my client)
14:03:48 <Cale> boxscape: You'd need to wrap Test in some sort of existential
14:04:29 <boxscape> I understand what that means in principle, but I'm not sure what that means in a haskell context.
14:04:35 <Cale> data SomeTest = forall k. SomeTest (Test k)
14:04:39 <boxscape> I see
14:04:51 <boxscape> okay I'll try to do something with that
14:05:09 <Cale> So then you can have  test3 :: Integer -> SomeTest
14:05:16 <boxscape> okay
14:05:54 <Cale> test3 k = case toSing k of SomeSing (SNat :: Sing k) -> SomeTest (Test :: Test k)
14:06:23 <Cale> Of course, we're just reinventing the original singleton type and SomeSing
14:06:45 <boxscape> right... that makes sense
14:08:14 <Cale> You could also write that in GADT style:
14:08:21 <Cale> data SomeTest where
14:08:31 <Cale>   SomeTest :: Test k -> SomeTest
14:08:50 <boxscape> oh, you don't need forall in that case?
14:09:07 <Cale> Well, it's implicit
14:09:07 <boxscape> I guess that makes sense considering my Test definition doesn't need it either
14:09:10 <boxscape> right
14:09:26 <Cale> The important thing is that we're "discarding" the k
14:11:53 <boxscape> so If I have a SomeTest, is there some way I can use a function like f :: Test k -> Test k with it?
14:13:20 <Cale> boxscape: By locally unpacking it
14:13:27 <Cale> and then wrapping it up again
14:13:45 <boxscape> okay, that makes sense, thanks
14:14:31 <mpickering> lyxia: Is there a sensible way to debug why a generator is generating a massive expression tree?
14:17:27 <dyl> mpickering have you tried turning it off and on again?
14:18:59 <johnw> mpickering: are you weighting the constructors?
14:19:12 * hackage htoml-megaparsec 1.1.0.4 - Parser for TOML files  http://hackage.haskell.org/package/htoml-megaparsec-1.1.0.4 (vmchale)
14:20:24 <mpickering> johnw: Do you mean with a probability or using the sized mechanism to descrease the size appropriately on each recursive call?
14:20:52 <mpickering> I think I am going both but it's difficult to tell using this library
14:25:11 <johnw> mpickering: well, when I write these generators using Arbitrary, I find I need to weight toward those that will lead to smaller trees
14:25:31 <johnw> otherwise, without weighting it may choose those lead to combinatorial explosion too easily
14:25:35 <mpickering> ok, that makes sense
14:25:47 <mpickering> but I thought the sized mechanism was supposed to deal with that mainly
14:26:06 <johnw> perhaps so, I don't think I've used that approach
14:26:24 <johnw> for example: https://github.com/jwiegley/linearscan-hoopl/blob/master/test/Generated.hs#L23
14:26:32 <mpickering> The problem with using the frequencies is that you are likely to get quite small trees?
14:26:34 <johnw> that generates programs in a fake assembly language
14:26:47 <johnw> i used it to generate billions of such programs, and I think I use both frequency and sized
14:27:08 <johnw> how likely depends on the frequency values :)
14:27:37 <johnw> uh, ahem, you totally don't see me using unsafeCoerce in there, no you don't
14:27:51 <mpickering> thanks for the pointer. I'll try adding some frequencies and see if that helps the matter
14:28:20 <johnw> the other thing you could do is write a shrinker
14:28:27 <johnw> so that it prunes out the uninteresting stuff
14:52:07 <lyxia> mpickering: one guarantee that I make is that if all of the involved types are derived with genericArbitraryRec and stop at size 0, then the generated values should have a number of constructors close to the original size parameter (up to a constant factor).
14:52:31 <lyxia> But that assumption is easily broken, e.g. if there are lists or tuples.
14:57:17 <lyxia> handwritten generators with explicit frequencies are still state of the art
15:11:20 <muyfine> I'm running a warp server that kicking off some work that runs forever and I'm trying to figure out how to handle the client going away
15:11:29 <muyfine> http://lpaste.net/365274
15:11:56 <muyfine> if I  curl localhost:3000 that - the warp request thread continues to run
15:13:14 <boj> muyfine: what is your goal here?
15:13:30 <muyfine> to shutdown the request thread when the connection goes away
15:14:07 <muyfine> do I need to set up stuff with onClose and onOpen handlers?
15:15:00 <boj> muyfine: you probably want to avoid 'forever' and add a condition for the loop to stop
15:16:31 <muyfine> boj: what condition can I check to tell me that the connection is no longer present?
15:17:13 <muyfine> (the forever is contrived to make a simple example - there's a more involved worker piece running)
15:19:00 <boj> does the client need a response? or is it just starting the job? if the latter, you could run the job using forkIO
15:19:36 <muyfine> client will need a response
15:19:42 * hackage mattermost-api 40900.1.0 - Client API for Mattermost chat system  http://hackage.haskell.org/package/mattermost-api-40900.1.0 (JonathanDaugherty)
15:20:12 * hackage mattermost-api-qc 40900.1.0 - QuickCheck instances for the Mattermost client API library  http://hackage.haskell.org/package/mattermost-api-qc-40900.1.0 (JonathanDaugherty)
15:20:24 <boj> does it need the answer to the job results? if it takes longer than the timeout the connection will close
15:20:42 * hackage matterhorn 40900.0.1 - Terminal client for the Mattermost chat system  http://hackage.haskell.org/package/matterhorn-40900.0.1 (JonathanDaugherty)
15:20:54 <boj> then you have to consider long polling, or giving it a job id to poll for later
15:21:14 <muyfine> is there no way to determine that a client is no longer connected to a thread?
15:21:46 <boj> the moment the response is sent?
15:22:28 <muyfine> I curled that above snippet, and the thread runs indefinitely - is there nothing I could do to determine that there no more connected client?
15:22:44 <boj> yeah, that's because you have an infite loop. it will never finish
15:23:29 <muyfine> so I can't share fate with the incoming request?
15:23:51 <muyfine> e.g., race runForever handleRequest
15:24:16 <muyfine> and have my request thread torn down when there's no longer a client to receive its response?
15:24:52 <boj> if you fork the job loop it should then be tied to the client thread
15:25:40 <EvanR> you can tie the fate of a thread with the fate of a handle by using a finalizer
15:26:06 <EvanR> each handle should have at least one of these dedictated "fate" threads
15:26:15 <EvanR> you can tie the fate of two threads together using async
15:26:26 <boj> maybe look into using mvar as a semaphore to signal the req thread to send
15:26:29 <muyfine> boj: change the setFork?
15:27:00 <muyfine> which looks like is void . forkIOWithUnmask
15:27:40 <EvanR> yuck use async
15:28:19 <boj> ah yeah, async
15:28:25 <muyfine> EvanR: so use an async call here: https://www.stackage.org/haddock/lts-11.6/warp-3.2.19/Network-Wai-Handler-Warp.html#v:setFork
15:28:46 <boj> naw, just use async in your request handler
15:29:53 <muyfine> my application is using async - race calls - just the request handler thread never dies
15:30:50 <muyfine> which is why I'm trying to figure out how to kill that thread in the example code
15:31:09 <dyl> All this talk of tying fate and threads is reminding me of Greek mythology.
15:31:22 <mpickering>  lyxia yes there are lists
15:31:50 <johnw> dyl: it would be funny if the async library had been written by three sisters
15:31:59 <boj> muyfine: your example isn't really great since the body is a blocking infinite loop
15:33:39 <dyl> I want to run a study on spicy food appreciation/tolerance and programming language of choice.
15:33:55 <dyl> It is known that programmers tend to like spicy food more than the general population but I wonder if it differs by language.
15:34:16 <boj> probably not :)
15:34:42 <dyl> Math people also tend to really like spicy food.
15:34:57 <dyl> So maybe the intersection (functional programmers being a large subset) do even more consistently than both groups individually.
15:35:21 <boj> "i was once a java programmer, but the moment i jumped to haskell my spicy food tolerance jumped!"
15:36:19 <johnw> lol
15:36:46 <sl2c> i really like spicy food and i'm a mathematician who's about to get a programming job but that's just one datum
15:36:49 <hpc> now that i think about it, this applies to me too
15:36:57 <hpc> even the timing is right
15:37:20 <hpc> although maybe some of it is around the same time i started working near some good restaurants
15:39:49 <EvanR> i dont understand the combination of "request causes a job that never ends" and "client wants the result of the job as response"
15:40:50 <EvanR> is it supposed to stream precisely until the client shuts down the connection? or what
15:41:38 <laudecay> hiya i'm using this black box grading system to check my code for this assignment, and i'm importing Data.Sequence, but it's not finding !? or deleteBy.
15:41:55 <laudecay> could i be importing it wrong? this is the line in question: import Data.Sequence hiding (unfoldr, length, reverse, filter)
15:42:23 <Cale> You might be importing a different version of the package than you were expecting
15:42:26 <laudecay> and this is the compiler output on the remove system https://hastebin.com/izixemobuz.css
15:42:28 <laudecay> oh HECK
15:42:59 <laudecay> because i just rewrote this entire gd project to make it so i didn't have to use Control.Lens, since this remote system doesn't have it installed
15:43:03 <laudecay> oh noooooooo
15:43:12 <laudecay> i guess i can implement deleteBy but it's gonna be SO slow
15:43:17 <EvanR> your blackbox sucks
15:43:28 <EvanR> at least you should know a priori what is available on it?
15:43:34 <EvanR> before doing the work?
15:43:42 <laudecay> oh trust me i know
15:43:43 <EvanR> just saying
15:43:44 <laudecay> i wish right
15:44:00 <Cale> You can just replace seq !? n with lookup n seq
15:44:14 <laudecay> Cale: that was the thing that was originally erroring
15:44:22 <laudecay> I tried like namespace-ing them both too
15:44:26 <Cale> and... I'm not sure what deleteBy is
15:44:28 <laudecay> Data.Sequence.(!?)
15:44:41 <EvanR> :t deleteBy
15:44:42 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
15:44:52 <laudecay> er deleteAt sorry
15:44:56 <laudecay> :t deleteAt
15:44:57 <lambdabot> error:
15:44:57 <lambdabot>     • Variable not in scope: deleteAt
15:44:57 <lambdabot>     • Perhaps you meant one of these:
15:45:01 <laudecay> it's like indexed deletion
15:45:06 <laudecay> ah yes one of these:
15:45:12 <Cale> oh, you can implement deleteAt efficiently using splitAt
15:45:14 <laudecay> :t Data.Sequence.deleteAt
15:45:15 <lambdabot> Int -> Seq.Seq a -> Seq.Seq a
15:45:17 <laudecay> whee
15:45:23 <Cale> :t Data.Sequence.splitAt
15:45:24 <lambdabot> Int -> Seq.Seq a -> (Seq.Seq a, Seq.Seq a)
15:45:33 <laudecay> oh then i just join them?
15:45:36 <Cale> yeah
15:45:37 <laudecay> dope i'll do that
15:45:39 <EvanR> if you had splitAt why would you not have deleteAt
15:45:48 <laudecay> i dunno if splitAt exists on this server but *shrug*
15:45:54 <Cale> EvanR: because laudecay is using a slightly older version of the package
15:45:56 <laudecay> idk i'm in hell tho
15:46:05 <laudecay> how do i deal with lookup tho? Cale
15:46:17 <EvanR> do you have access to the docs and or versions of what is installed
15:46:17 <Cale> (something before 0.5.8)
15:46:23 <Cale> laudecay: lookup exists
15:46:36 <Cale> import qualified Data.Sequence as Seq
15:46:48 <Cale> import Data.Sequence (Seq)
15:47:21 <Cale> oh, might want to add stuff like (|>) and other infix operators to the second import
15:47:45 <Cale> But yeah, do that and use  Seq.lookup
15:47:58 <Cale> Every version of Data.Sequence has had that function. :)
15:48:27 * EvanR waits for "Data.Sequence on this server doesn't have any of the functions"
15:48:35 <Cale> oh, or wait
15:48:41 <laudecay> oh wait for real cool
15:48:49 <Cale> Perhaps it was called index before
15:48:52 <laudecay> EvanR: i have no documentation at all
15:49:13 <Cale> ah, right
15:49:13 <EvanR> yell show me the docs at your professor
15:49:16 <dyl> sl2c: I’ve recently graduated from “likes spicy food” to “my friends can’t eat my food because it’s too spicy”
15:49:34 <Cale> Only index existed before 0.5.8
15:49:41 <dyl> I order 13/10 at my local Thai place.
15:49:59 <Cale> But be careful with that because it throws an error if the index is out of bounds, rather than producing a Maybe result
15:50:14 <dyl> Which often results in way too much chili, so sometimes I just get the oil soaked chili flakes they use on the side in a little condiment container.
15:50:14 <EvanR> is thai food technically on topic in here or
15:50:16 <laudecay> EvanR: it's a random outside service
15:50:23 <dyl> EvanR: sorry :p
15:50:30 <hpc> at least talk about curry
15:50:39 <laudecay> Cale: heck, i definitely need the Maybe thing
15:50:48 <dyl> I would totally eat at any restaurant serving a “Haskell Curry”
15:50:49 <laudecay> because i set the index to -1 in like an error case so that i can get nothing
15:51:03 <dyl> Though it would probably contain bananas, contact lenses, and barbed wire.
15:51:07 <Cale> laudecay: You can just check the bounds beforehand if you like.
15:51:25 <laudecay> Cale: https://hastebin.com/iwexarotaf.css
15:51:30 <laudecay> why is it like this
15:51:37 <dyl> How does Haskell not have an official curry?
15:51:45 <dyl> We need to crowdsource this over in -offtopic.
15:51:50 <laudecay> it has an official uncurry
15:51:52 <Cale> Or you can splitAt again, and use viewL or something
15:51:59 <EvanR> it does, someone in here gave me the recipe in here about 10 years ago
15:52:18 <laudecay> wait how do i make deleteAt from splitAt
15:52:27 <Cale> laudecay: you're simply using a version of the containers package before 0.5.8
15:52:34 <dyl> EvanR please forward it to -offtopic
15:52:45 <dyl> I am now going to work on designing a Haskell2010 Curry.
15:52:48 <Cale> You splitAt, and drop one element from one side, and then >< them together again
15:53:10 <laudecay> okay yeah i misunderstood what splitAt did
15:53:14 <laudecay> okay ill try that
15:54:08 <Cale> You can also use splitAt and viewl to implement lookup
15:55:07 <Cale> the constant factors will be worse, but it'll be asymptotically equivalent
15:58:34 <laudecay> uhhhhghghghgh no i need as fast as possible
15:58:36 <laudecay> this is :(
16:02:58 <codedmart> Is it possible to create a `ThreadId` from `Int` or `String`. I am writing a job queue and use `forkIO` to run a job. I would like to save the `ThreadId` in the database but pull it back out of the database and kill a thread if need be.
16:03:02 <EvanR> Sequence is not as fast as possible
16:03:16 <EvanR> codedmart: o_O
16:03:37 <EvanR> no, but you can create your own identifiers and an ID to ThreadID mapping
16:03:56 <EvanR> ThreadID is abstract for a reason
16:04:15 <codedmart> Not sure I follow how that would work totally>
16:04:37 <codedmart> I get the own identifiers.
16:05:00 <EvanR> when you create a thread, generate a new identifier x and put the threadID and x together in a table
16:05:10 <EvanR> now you can go both ways
16:05:28 <boxscape> Is there a way to generate singletons for    data Test (k :: Nat) = Test ? I'm getting this: http://lpaste.net/365275
16:05:46 <EvanR> if the process ends, the table goes away. your custom identifiers provably go nowhere and mean nothing
16:05:48 <boxscape> (although that has the same Type with GADT syntax)
16:05:59 <EvanR> hopefully
16:06:04 <EvanR> (UUIDs can help)
16:06:35 <codedmart> EvanR: What do you mean table? Like in an MVar or?
16:06:49 <codedmart> Sorry just trying to grasp the connection.
16:08:04 <EvanR> putting thread IDs directly in a database (in a way that you could actually use) would be like putting pointers in a database
16:08:27 <EvanR> codedmart: the simplest would be [(ThreadID, UUID)] but also the slowest
16:08:37 <codedmart> Oh I don't know I have the option to do that. I am using persistent/esqueleto.
16:08:53 <EvanR> to do what
16:09:07 <EvanR> i'm not talking about a database table
16:09:19 <EvanR> i have failed
16:09:40 <codedmart> Yeah I am totally missing something. Are we not talking about a database?
16:09:51 <EvanR> here is a faster version of [(a,b)]
16:09:52 <EvanR> https://hackage.haskell.org/package/bimap-0.3.0/candidate/docs/Data-Bimap.html
16:10:04 <codedmart> Yes I got that.
16:10:34 <EvanR> you keep a bimap of threadIDs to UUIDs in your process, and update it when you fork new threads
16:10:37 <EvanR> or kill them
16:10:42 <EvanR> keep UUIDs in the database
16:10:53 <EvanR> alternatively, what are you really trying to do
16:11:05 <codedmart> OK I think I understand.
16:11:09 <codedmart> I appreciate your help.
16:12:53 <laudecay> oh no this is so awful
16:15:15 <codedmart> What I am trying to do?
16:18:46 <laudecay> oh no im just bitching about my code
16:18:48 <laudecay> sorry lol
16:22:21 <boxscape> hm, I just spent trying to understand how things work with a simplified problem and then realized that my "simplified" problem has constrains that make it harder than the actual problem
16:22:39 <boxscape> s/spent/spent a couple hours
16:23:39 <Rembane> This operator lets me pick <|> the first working action. Is there an operator out there that forces both operators to work ... hey, isn't <*> generally defined like that?
16:23:54 <Cale> Rembane: indeed it is
16:23:57 <jle`> boxscape: you should also enable SCopedTypeVariables if you're using singletons th
16:24:07 <Cale> Rembane: also see liftA2/liftM2
16:24:36 <boxscape> jle': yeah I just realized that a few minutes ago, shouldn't make a difference for that though. I just tried to make the code as minimal as possible, removing all unneeded extensions
16:24:40 <Rembane> Cale: Thank you!
16:25:21 <boxscape> (I mean shouldn't make a difference as far as the error message goes)
16:37:42 * hackage backprop 0.1.5.2 - Heterogeneous automatic differentation (backpropagation)  http://hackage.haskell.org/package/backprop-0.1.5.2 (jle)
16:45:02 <codedmart> If I want to run two different IO's but pass the results of both to a function. Like >>= but with 2.
16:46:12 <sl2c> codedmart: either do notation or ((,) <$> io1 <*> io2) >>= (uncurry f)
16:46:49 <codedmart> Hmm... I thought there was a prettier way. OK thanks.
16:47:19 <sl2c> there might be but honestly do notation is probably the clearest
16:49:19 <codedmart> Fair enough, thanks again
16:49:23 <jle`> codedmart: do notation was invented for situations like this :)
16:49:29 <sl2c> so like {x1 <- io1; x2 <- io2; f x1 x2}
16:49:44 <codedmart> Yeah I just like to be clever and see new tricks when I can.
16:49:55 <jle`> codedmart: if your combining function is not IO (like, an a -> b -> c), you can use liftA2 or  <$>/<*>
16:50:00 <jle`> codedmart: being clever is generally considered a bad idea
16:50:22 <codedmart> OK maybe being clever was the wrong terminology.
16:50:24 <codedmart> But yet
16:50:28 <codedmart> yes I mean
16:50:40 <jle`> % :t liftA2 @IO
16:50:42 <yahb> jle`: (a -> b -> c) -> IO a -> IO b -> IO c
16:51:28 <sl2c> % :t IO
16:51:29 <yahb> sl2c: ; <interactive>:1:1: error:; * Data constructor not in scope: IO; * Perhaps you meant `I#' (imported from GHC.Exts)
16:51:45 <jle`> IO is not normally a value with a type
16:51:57 <jle`> usually you see it as a type constructor
16:54:06 <boxscape> % :k IO
16:54:06 <yahb> boxscape: IO :: * -> *
16:55:40 <boxscape> is there any chance of ghci using Type instead of * at some point?
16:56:02 <sl2c> isn't there an extension to make ghc use Type instead of *
16:56:26 <boxscape> You can use it if you import Data.Kind, but ghci will still desplay kinds with *
16:56:49 <boxscape> I've heard people say you need the TypeInType extension to use it, but I don't think that's the case anymore
16:58:39 <boxscape> s/desplay/display
17:04:38 <Lemmingz95> Anyone know of any resources for dealing with time in arrowized FRP (specifically Yampa). Essentially making it easy to create signal transformers that hold one value for t seconds and then another?
17:08:15 <solrach> hi!  newbie here...i have a recurrent error with stack install...this is the place to ask?
17:12:27 <solrach> ok
17:15:37 <boxscape> solrach: I would say it is the place to ask
17:16:58 <boxscape> solrach: you can try #haskell-stack as well
17:17:11 <solrach> i have this message on stack instal whatever...Exception was: HttpExceptionRequest Request {   host                 = "s3.amazonaws.com"
17:17:42 <solrach> on windows 10 ..sorry, thats what i have now.
17:19:02 <boxscape> haven't used stack in quite a while, but maybe try stack update?
17:20:11 <solrach> ok.. i try
17:20:38 <fishythefish> solrach: do you require http_proxy or https_proxy by any chance?
17:21:37 <solrach> I use stack because with cabal i have a lot of weird errors with the required versions...
17:22:07 <boxscape> fishythefish: I would guess that it's more that stack itself uses http_proxy
17:22:26 <solrach> fishythefish, nop...how im supossed to use that
17:22:29 <boxscape> if that's where that constructor is from
17:22:47 <fishythefish> boxscape: no, I mean that if you're on a system that requires you to explicitly proxy (e.g. I have to do this at work), and you fail to specify that in the env, then you'll get such an error
17:23:08 <boxscape> ohh, okay
17:24:41 <solrach> fishythefish, no
17:26:42 <solrach> stack update with same error here...
17:27:06 <solrach> Exception was: HttpExceptionRequest Request {   host                 = "s3.amazonaws.com"
17:29:16 <fishythefish> solrach: can you paste the full error somewhere? what does `env | grep proxy` show?
17:30:07 <boxscape> @where paste
17:30:08 <lambdabot> Haskell pastebin: http://lpaste.net/
17:30:11 <boxscape> ^ you can paste here
17:32:58 <jared-w> sup
17:39:58 <solrach> well...you ask  hoogle>stack update Selected mirror https://s3.amazonaws.com/hackage.fpcomplete.com/ Downloading timestamp Exception HttpExceptionRequest Request {   host                 = "s3.amazonaws.com"   port                 = 443   secure               = True   requestHeaders       = [("Accept-Encoding",""),("Cache-Control","no-transform")]   path                 = "/hackage.fpcomplete.com/timestamp.json"   queryString     
17:43:57 <fishythefish> @tell solrach what happens if you try to fetch that resource with wget or curl? `wget https://s3.amazonaws.com/hackage.fpcomplete.com/timestamp.json` or `curl -X GET https://s3.amazonaws.com/hackage.fpcomplete.com/timestamp.json`
17:43:57 <lambdabot> Consider it noted.
17:47:08 <jared-w> Anyone wanna potentially code-gulf or look over my code for funsies? I wrote a single-layer neural network to go over the MNIST dataset for a homework assignment and I'm wondering how I could improve it further :)  http://lpaste.net/4449106834665504768
18:35:43 * hackage servant-tracing 0.1.0.2 -   http://hackage.haskell.org/package/servant-tracing-0.1.0.2 (ChrisCoffey)
19:06:31 <deepfire> are Struct{..} patterns expected to be strict, even if no field is used?
19:07:16 <deepfire> (sorry, -XRecordWildCards are implied)
19:07:57 <Axman6> well, it will evaluate far enough to tell which constructor is used (a.k.a, weak head normal form)
19:09:12 * hackage persistable-types-HDBC-pg 0.0.3.1 - HDBC and Relational-Record instances of PostgreSQL extended types  http://hackage.haskell.org/package/persistable-types-HDBC-pg-0.0.3.1 (KeiHibino)
19:09:29 <deepfire> I see.. I'm into fixIO right now, so I guess it's complicated..
19:09:46 <deepfire> Axman6: good point, thank you!
19:36:10 <boxscape> so I just restarted my computer, and now some code with Proxies and singletons that just worked a few minutes ago doesn't work anymore. I'm also noticing that ":t Proxy :: Proxy Int" now tells me "Proxy * Int" whereas in a fresh ghci instance it just says "Proxy Int". Any idea why  that might be?
19:37:41 <MarcelineVQ> if in linux "restarted and now ..."  usually has to do with paths
19:40:15 <boxscape> hm, i suppose that's possible
19:40:44 <boxscape> It might also be some ghci setting that I maybe set before but don't have now, but I don't know what it would be
19:45:21 <boxscape> Hm, restarted ghci, now it's "Proxy Int" again. Very strange.
19:45:36 <boxscape> oh wait
19:45:44 <boxscape> I set some exlicit kind flag because of the error message I got
19:45:46 <boxscape> that would be why
19:46:04 <boxscape> still have to figure out why the code doesn't work, but that explains why the kind of Proxy was weird
19:46:13 <boxscape> (-fprint-explicit-kinds)
19:49:40 <EvanR> :k Proxy
19:49:42 <lambdabot> k -> *
19:50:24 <EvanR> that is to say, forall k . k -> *
19:50:47 <boxscape> okay, the code doesn't work because I forgot to set KindSignatures in ghci. I thought I'd enabled all the flags, but apparently I forgot that one
19:50:57 <EvanR> boxscape: Proxy is polykinded, and it happens that in some tools (haddock, your ghci?) polykinded types are displayed inconsistently
19:51:10 <EvanR> Proxy * Int just means , k = *
19:51:21 <boxscape> EvanR: nope, it was just ghci showing me the type and kind at the same time, because of -fprint-explicit-kinds
19:51:24 <EvanR> Proxy Int means, i am not showing what kind I'm at, probably *
19:52:01 <EvanR> i'm saying both look right
19:52:19 <boxscape> both?
19:52:25 <boxscape> Proxy * Int and Proxy int?
19:52:27 <EvanR> yes
19:52:55 <boxscape> okay, I think I see what you mean, yeah
19:53:18 <EvanR> indeed in Proxy Int k must be *
19:53:39 <EvanR> and i presume at some point this was decided to be elided because its painfully obvious
19:53:59 <EvanR> you also elide what type is chosen for certain things in normal polymorphism
19:54:01 <EvanR> :t map
19:54:02 <lambdabot> (a -> b) -> [a] -> [b]
19:54:21 <EvanR> :t map `asAppliedTo` (id :: Int -> Int)
19:54:23 <lambdabot> (Int -> Int) -> [Int] -> [Int]
19:54:33 <EvanR> maybe im off on that one
19:54:51 <boxscape> Not sure which elision you're referring to in that case
19:54:56 <EvanR> me neither
19:55:01 <EvanR> nevermind
19:55:04 <MarcelineVQ> you may be thinking of  map :: forall {a} {b}. (a -> b) -> [a] -> [b]
19:55:47 <EvanR> i was thinking ^that = typeOf(map) Int Int
19:55:58 <EvanR> which we dont have syntax for so nevermind
19:57:07 * EvanR goes to read about explicit type application syntax
19:57:14 <MarcelineVQ> map @Int @ Int :: (Int -> Int) -> [Int] -> [Int] ?
19:57:25 <EvanR> :t map @Int @Int
19:57:26 <lambdabot> error: parse error on input ‘@’
19:57:35 <MarcelineVQ> % :t map @Int @Int
19:57:35 <yahb> MarcelineVQ: (Int -> Int) -> [Int] -> [Int]
19:58:08 * EvanR does a flip
19:58:13 <MarcelineVQ> that's not quite what ghcc gives me yahb, you silly goose, but it'll do
20:01:54 <MarcelineVQ> % :set -fprint-explicit-foralls -fprint-explicit-kinds
20:01:55 <yahb> MarcelineVQ:
20:02:05 <MarcelineVQ> % :k Proxy
20:02:05 <yahb> MarcelineVQ: Proxy :: forall {k}. k -> *
20:02:19 <MarcelineVQ> % :t Proxy
20:02:19 <yahb> MarcelineVQ: forall {k} {t :: k}. Proxy k t
20:02:31 <EvanR> whats with the { }
20:02:36 <MarcelineVQ> Oh? hmm, wonder what ghc yahab's using
20:04:12 <MarcelineVQ> I'd be lying if I could tell you for sure, as I understood { } are for type variables that aren't applicable by the user, but map is map :: forall {a} {b}. (a -> b) -> [a] -> [b]  and you can   @   a and b just fine
20:04:39 <MarcelineVQ> best to check the manual and hope that section is up to date :X
20:07:38 <MarcelineVQ> the heck, where did the documentation for fprint-explicit-foralls and fprint-explicit-kinds go :X
20:09:13 <droplet> https://downloads.haskell.org/~ghc/master/users-guide/using.html#ghc-flag--fprint-explicit-foralls
20:09:23 <droplet> is this what you're looking for?
20:09:32 <MarcelineVQ> yes, weird, link must be broken for me
20:11:02 <MarcelineVQ> yeah, it's broken on latest, master seems okay
20:12:08 <MarcelineVQ> 'it' being the links for -fprint-* here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html
20:12:39 <MarcelineVQ> and all the rest it looks like hehe, at least master's fine
20:14:27 <droplet> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html#ghc-flag--fprint-explicit-foralls
20:15:12 <MarcelineVQ> yeah it exists, the link to it from the flag page was broken. thank you :>
20:15:54 <droplet> ah right - the link just above for verbosity options works for me instead
20:16:26 <MarcelineVQ> EvanR: this is where my confusion about { } is coming from  https://downloads.haskell.org/~ghc/8.2-latest/docs/html/users_guide/glasgow_exts.html#visible-type-application  "When printing types with -fprint-explicit-foralls enabled, type variables not available for visible type application are printed in braces."
20:16:57 <EvanR> how can they be not available
20:18:13 <EvanR> i mean where does available and unavailable come from
20:18:17 <EvanR> the idstinction
20:22:51 <MarcelineVQ> it shows how they can not be with an example, appearantly my confusion about { } being inconsistent was because I should be using  :type +v  to ask about these things, :type is somehow imprecise, idk :(
20:22:58 <MarcelineVQ> % :type +v map
20:22:58 <yahb> MarcelineVQ: forall a b. (a -> b) -> [a] -> [b]
20:23:06 <MarcelineVQ> % :type +v map (+1)
20:23:07 <yahb> MarcelineVQ: forall {b}. Num b => [b] -> [b]
20:23:23 <MarcelineVQ> % :type +v map @Int Int
20:23:23 <yahb> MarcelineVQ: ; <interactive>:1:10: error:; * Data constructor not in scope: Int :: Int -> b; * Perhaps you meant variable `int' (imported from Text.PrettyPrint.HughesPJ)
20:23:30 <MarcelineVQ> % :type +v map @Int @Int
20:23:30 <yahb> MarcelineVQ: (Int -> Int) -> [Int] -> [Int]
20:23:37 <MarcelineVQ> % :type +v map (+1) @Int
20:23:37 <yahb> MarcelineVQ: ; <interactive>:1:1: error:; * Cannot apply expression of type `[b0] -> [b0]'; to a visible type argument `Int'; * In the expression: map (+ 1) @Int
20:23:51 <MarcelineVQ> that ended up wordier than I planned, sorry channel.
20:26:01 <MarcelineVQ> % :type +v (map (+1) :: Num b => [b] -> [b]) @Int  -- it's about signatures, EvanR, for making the difference I guess
20:26:01 <yahb> MarcelineVQ: Num Int => [Int] -> [Int]
21:18:13 * hackage warp 3.2.22 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.2.22 (KazuYamamoto)
21:25:12 * hackage language-ats 1.2.0.9 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.2.0.9 (vmchale)
21:57:47 <taktoa> is there a haskell package that implements `malloc` and `free` in terms of a `MutableByteArray#` (e.g.: so that you can do manual memory management in pure code); ideally with Word32 offsets instead of pointers
21:59:41 <taktoa> (yes I know that question is ridiculous, and any sane person would probably just use the C FFI)
22:01:57 <taktoa> hmm, there's Foreign.Marshal.Pool, which is not far from what I want, but also not great
22:05:56 <EvanR> but how would you mutate the array with pure code...
22:08:23 <taktoa> EvanR: ST
22:08:31 <EvanR> also would the bookkeeping state of the manager (that malloc and free modify) be normal haskell data or what
22:08:44 <taktoa> it would be inside the MutableByteArray#
22:09:09 <EvanR> i love it
22:09:26 <EvanR> C in any language ftw!
22:09:49 <taktoa> the point is to allow people to make mutable data structures with indirections without causing the GHC garbage collector to choke on too many `MutVar`s
22:10:02 <taktoa> and to keep them contiguous in memory
22:10:37 <EvanR> and without going through the FFI
22:10:39 <taktoa> yeah
22:10:53 <taktoa> kind of like compact regions except there's no cost of serializing
22:11:11 <EvanR> and its mutable
22:11:13 <taktoa> yeah
22:11:17 <taktoa> and the space efficiency is better because you use offsets instead of pointers
22:13:12 <taktoa> actually the bookkeeping state could be normal haskell data that you just keep inside a MutVar# along with the MutableByteArray#, though that will be a bit less efficient
22:17:18 <myname_> QUIT
23:02:52 <dminuoso> :t catchJust
23:02:54 <lambdabot> Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
23:03:04 <dminuoso> Why does this use (e -> Maybe b) rather than (e -> Bool)
23:03:45 <dminuoso> The example from the docs seems a bit silly (if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)
23:06:12 * hackage hw-kafka-client 2.4.4 - Kafka bindings for Haskell  http://hackage.haskell.org/package/hw-kafka-client-2.4.4 (alexeyraga)
23:07:56 <cocreature> dminuoso: because otherwise you might need to duplicate work
23:08:15 <cocreature> dminuoso: e.g. let’s say you do some pattern matching in e -> Bool, you probably need to do the same pattern match to get from e to b later on
23:08:25 <cocreature> dminuoso: and the latter function will then be partial
23:09:34 <dminuoso> cocreature: Ah okay.
23:11:39 <cocreature> dminuoso: it’s basically the same reason why mapMaybe can be preferable to map + filter
23:12:26 <Axman6> taktoa: you should talk to edwardk about this, he's done some really scare hacks to similar things for succinct data structures IIRC
23:12:39 <Axman6> see the struct package
23:13:13 <cocreature> iirc struct is more about reducing indirections than manual memory allocation
23:16:43 * edwardk looks up
23:17:50 <edwardk> i have nothing for manual memory allocation except some fiddly code for working with mmaps
23:18:57 <edwardk> i now have lambdabot running on twitch chat, but don't know enough about the arcane processes that int-e followed to get so much stuff marked trusted/safe on lambdabot here
23:19:30 <edwardk> sadly lambdabot was taken so i had to take lambda_bot
23:26:58 <zomg> edwardk: ooh, TwitchPlaysHaskellDev? :P
23:27:20 <edwardk> zomg: more like i plan on streaming some live coding at some point
23:27:27 <zomg> heh
23:27:46 <zomg> I was already about to congratulate you for taking the jobs of all haskell devs because it could all just be crowdsourced from twitc chat now
23:28:06 <edwardk> external capture card arrived, now i can actually code at the same time i'm producing video, waiting for the mic because it doesn't like the one on my headset when i'm streaming to the other machine
23:28:40 <zomg> OBS didn't like your setup?
23:29:14 <edwardk> using an hd60s to stream from my mac so i can record off the windows machine next to it, which has waaay more power and can easily compress the stream.
23:29:29 <zomg> ah :)
23:29:36 <edwardk> the difference is that it was taking like 83% of my processor to do it on the mac. it takes like 7% on the windows machine to the side
23:29:55 <zomg> OBS is probably way more stable on Windows anyway, I hear it's a bit bad on MacOS
23:30:15 <edwardk> currently using gameshow rather than obs directly, just because i rather liked the preview abilities, etc.
23:30:29 <edwardk> we'll see if the crashes get to be too bad
23:31:34 <zomg> never heard of that one but looks alright
23:33:03 <edwardk> i also played around with the elgato streaming software that came with the capture card, which isn't bad, but was flaky. (i have like 12+ sound devices on this machine, a bunch of video sources, etc. because its the one i use for vr and a bunch of other experiments)
23:35:24 <zomg> 12+ sound devices? That is... impressive I guess? :D
23:36:40 <edwardk> its just silly, but each vr headset wants to provide one, then the external speakers, etc. then all the random mixing software shows up as some other device, then the capture card, various jacks on the case...
23:36:52 <zomg> ah :P
23:37:18 <zomg> yeah now that you mention it I have a few of them as well although most of them come from the internal soundcard
23:37:54 <zomg> and half of them are disabled because I don't use them (like my webcam's microphone which is total trash)
23:38:25 <edwardk> yeah i turn off all the ones i can, but i still need to use the ones on the vive or oculus, etc. occasionally
