00:02:41 <Xal> I frequently find myself using lens to view things inside MVars, TMVars and such
00:03:02 <Xal> I haven't found a really ergonomic way to do this
00:03:47 <Xal> normally I'd have to do (^. c) <$> (readTVar $ a ^. b) which really feels like it should be easier
00:04:16 <Xal> ideally I'd like to be able to have some sort of "fmapped view" operator
00:04:33 <Xal> so I could do a^^.b.c and get a value of type STM a back
00:04:41 <Xal> does such a thing already exist?
00:05:55 <EvanR> all that for fmap f . readTVar ?
00:06:28 <Xal> well the issue is I have nested TVars that I'd like to be able to access with lenses
00:06:54 <EvanR> yuck
00:07:56 <Xal> err, not necessarily nested tvars, but some nested structures INSIDE tvars that are more conveniently accessed through lenses
00:08:32 <EvanR> thats f
00:08:50 <dpyro> well i only need 2 lengths
00:08:53 <Xal> my main issue is that lenses typically compose from left to right (a^.b.c) but once I have to deal with fmapping over functors it goes right to left
00:09:00 <dpyro> 1, if really need to
00:10:05 <EvanR> dpyro can you elaborate on what youre doing with the 2 lengths
00:11:08 <dpyro> a standard ethereum hash is 64 bytes while an ethereum address is 40 bytes (first 24 bytes are implicitly 0)
00:11:29 <dpyro> i need to print and read them as strings, but otherwise i need to be able to compare bytes
00:11:47 <dpyro> the only ops i would do on them is set and compare for equality
00:11:55 <EvanR> set?
00:12:03 <dpyro> erm construct
00:12:36 <EvanR> do you really need the 40 one if its 64 with 24 zeros
00:13:14 <dpyro> no, but i wont ever be comparing hashes against addresses
00:13:20 <dpyro> if i do its an error
00:13:33 <EvanR> oh its two different things
00:13:45 <EvanR> you should make 2 newtypes
00:13:57 <dpyro> i am right now
00:14:04 <dpyro> but i'd like to also constrain the size
00:14:17 <EvanR> you can do that in the smart ctor for each
00:14:29 <EvanR> data Addr = Addr { unAddr :: ByteString }
00:14:35 <dpyro> smart ctor?
00:14:38 <EvanR> data Hash = Hash { unHash :: ByteString }
00:14:46 <EvanR> but dont export Addr or Hash
00:15:10 <dpyro> ahh, like a private constructor with a public factory method thingy
00:15:15 <dysfun> https://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf # this paper is fantastic. it's making me reconsider the virtues of lisp
00:15:26 <EvanR> makeAddr :: ByteString -> Maybe Addr -- would be programmed to fail if not 40 bytes
00:15:31 <EvanR> yes
00:16:38 <EvanR> thx dysfun reading now
00:16:49 <davean> dysfun: You might be vaguely interested that theres a library that impliments, and makes it easy to impliment, large Words of specific sizes, https://hackage.haskell.org/package/data-dword-0.3.1.2 , but you don't really want to do math on them so I don't think you care too much
00:17:42 <dysfun> davean: wrong 'd' :)
00:17:55 <davean> dysfun: d?
00:18:02 <dysfun> you wanted dpyro
00:18:10 <davean> Oh, woops, yes
00:18:21 <davean> you litterly look the same to me
00:18:57 <dysfun> we have literally two letters in common, one of which isn't in the same place and we're different lengths, but ok ;)
00:19:13 <Cale> Puzzle: Can anyone think of a class all of whose correct instances will be identical in terms of the actual term you write, but for which no default implementation can be provided, even with DefaultSignatures.
00:19:48 <Cale> I ran into such a thing the other day.
00:19:52 <dpyro> woo nice davean
00:20:22 <dpyro> also we don't look the same davean 😤
00:20:41 <davean> Look, I'm 3 hours past my bed time, lots of things blend together ATM :)
00:20:57 <Cale> In particular, my example was with this class:  class Implies c d where implies :: c a :- d a
00:21:20 <Cale> Every instance will look like  instance Implies C D where implies = Sub Dict
00:22:01 <Cale> but you can't actually write that default, even with DefaultSignatures, because you have no way to write the condition that would make it valid
00:58:02 <dpyro> i'm seeing the phrase "lifting" a lot
00:58:08 <dpyro> what does that mean?
00:58:15 <dpyro> maybe i need to start lifting 🤔
00:58:26 <EvanR> bro, do you even
00:58:52 <EvanR> here is one usage
00:58:54 <EvanR> :t fmap
00:58:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:59:31 <EvanR> if you write that as Functor f => (a -> b) -> (f a -> f b) you can see that this lifts a function into the 'f' universe
01:00:10 <EvanR> its actually baked into the names of the binary versions
01:00:14 <EvanR> :t liftA2
01:00:15 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
01:00:20 <EvanR> :t liftM2
01:00:21 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:00:45 <jle`> there isn't really a formal definition of lifting that unifies all usages of it
01:00:50 <jle`> it's mostly informal
01:01:06 <jle`> it somewhat informally means to move something into a different context
01:01:54 <EvanR> an infamous one being... "RealWorld is deeply magical. It is primitive but not unlifted"
01:06:30 <dpyro> does that mean you can think of it as converting an (a → b) into an Functor f ⇒ (f a → f b) ?
01:07:09 <EvanR> that works, if you could swap the order of the Functor f and (a -> b)
01:07:57 <EvanR> :k (a -> b) -> (forall f . Functor f => f a -> f b)
01:07:58 <lambdabot> error: Not in scope: type variable ‘a’
01:07:58 <lambdabot> error: Not in scope: type variable ‘b’
01:07:58 <lambdabot> error: Not in scope: type variable ‘a’
01:08:05 <EvanR> :k forall a b . (a -> b) -> (forall f . Functor f => f a -> f b)
01:08:06 <lambdabot> *
01:08:10 <EvanR> duuude
01:09:14 <EvanR> :k (a -> b) -> (Functor f => f a -> f b)
01:09:16 <lambdabot> error: Not in scope: type variable ‘a’
01:09:16 <lambdabot> error: Not in scope: type variable ‘b’
01:09:16 <lambdabot> error: Not in scope: type variable ‘f’
01:09:31 <EvanR> ... yeah so you need foralls in the right places
01:09:57 <nshepperd1> :t fmap :: forall a b . (a -> b) -> (forall f . Functor f => f a -> f b)
01:09:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:10:09 <nshepperd1> Checks out
01:10:25 <EvanR> what the heck
01:15:24 <EvanR> i like that wadler paper luu
01:15:36 <EvanR> uhg
01:15:42 <EvanR> i like that wadler paper linked earlier
01:16:22 <EvanR> he mentions "free data structures" which he defines as data structures which are equal if and only if they are constructed the same way
01:16:47 <EvanR> which includes list and trees, but not sets
01:18:41 <EvanR> x:xs == y:ys means x==y and xs==ys. {x} U xs == {y} U ys doesnt imply x==y for instance
01:22:27 <tsahyt> Is there someone with sdl2/OpenGL experience here? I'm trying to follow the open.gl tutorial in Haskell, but I can't get this triangle to show up on the screen. https://gist.github.com/tsahyt/4865fe04e94570d4af1b5ecaf374b886
01:25:03 <EvanR> tsahyt: you have drawArrays 0 3
01:25:29 <EvanR> shouldnt 0 be a constant specifying what kind of primitive to interpret the data as
01:25:48 <EvanR> like GL_TRIANGLES
01:25:52 <tsahyt> EvanR: drawArrays Triangles 0 3
01:26:21 <EvanR> oh
01:27:06 <tsahyt> for reference, here's the example code, using GLEW rather than SDL but otherwise it should be the same https://github.com/zuck/opengl-examples/blob/master/Examples/Triangle/main.cpp
01:27:13 <EvanR> are you showing both sides of the triangle
01:27:32 <EvanR> so winding doesnt matter
01:28:09 <tsahyt> I should probably try running that code and see whether this actually produces what the tutorial claims
01:28:47 <EvanR> would be ironic if the shaders are bad, since that would be verbatim
01:28:51 <EvanR> not translated
01:29:36 <tsahyt> can't hurt to check them
01:29:55 <tsahyt> the C++ program produces the a white triangle as expected
01:30:05 <EvanR> does your gl lib throw an exception of there is a problem loading the shader
01:30:29 <tsahyt> I've checked the compile status of both, and of the program, everything returns true as expected
01:31:08 <EvanR> you did did you
01:31:44 <tsahyt> well I can add that code back in, let's see
01:31:49 <EvanR> probably should gist the shader source too
01:33:10 <tsahyt> https://gist.github.com/tsahyt/7cc83b9a3d8d4e5d4121c9fe4a14b3c6 and https://gist.github.com/tsahyt/4b5b27f84555cb48b85fe2a94340d29c
01:34:46 <tsahyt> both compile fine
01:35:29 <EvanR> usually i have to adjust the version comment
01:36:15 <tsahyt> I've taken that verbatim from the tutorial
01:36:26 <EvanR> well... doesnt matter
01:36:41 <EvanR> theres no version comment which works for everyone
01:37:06 <EvanR> which is annoying, because there is shader code that works for everyone other than that
01:37:47 <EvanR> i make sure to check and throw every time i compile and link
01:38:01 <EvanR> cuz... otherwise you get black screen effect
01:39:10 <tsahyt> link status and validate status are also true
01:39:23 <EvanR> probably not your problem then
01:42:47 <tsahyt> hm I had glEnableVertexAttribArray and glVertexAttribPointer switched compared to the C++ version, but that made no difference either :/
01:48:14 <tsahyt> no errors are recorded either.
01:49:11 <EvanR> since my program works on the exact same demo, but uses GLFW, i suspect its got to do with your use of SDL
01:49:36 <tsahyt> hm but e.g. setting the clear color to blue works just fine
01:49:41 <tsahyt> it's as if the call to drawArrays never happened
01:51:20 <EvanR> disable the clear
01:51:40 <tsahyt> same result
01:51:41 <EvanR> earlier i thought mayb you are showing after clearing
01:51:57 <EvanR> but not really
01:52:22 <EvanR> gotta love opengl!
01:52:38 <tsahyt> it's not like vulkan makes this easier
01:52:39 * hackage tidal 0.9.9 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.9.9 (AlexMcLean)
01:52:47 <EvanR> i imagine not
01:52:54 <tsahyt> there's this which uses the same libraries https://github.com/haskell-game/sdl2/blob/master/examples/OpenGLExample.hs
01:53:19 <tsahyt> it works too
01:53:44 <tsahyt> but it doesn't use a VBO
02:00:23 <EvanR> how the heck are they using glAttribPointer and passing ina literal pointer to some array in memory
02:00:38 <EvanR> some sort of wacky trick
02:03:55 <EvanR> also they arent usign core 3 2 or VAO so its relying on classic GL behavior
02:04:05 <EvanR> which i dont fully understand
02:04:47 <tsahyt> hm, there is one difference left between my version and the C++ one, and that's that I don't initialize GLEW. I was under the impression that I'd only need that for extensions. might that be the problem?
02:04:54 <tsahyt> the OpenGL bindings don't provide anything for it as far as I can tell
02:05:59 <EvanR> i am using edk `gl' which does all that for you so not sure
02:07:53 <tsahyt> hmm when I comment out the glew lines from the C++ source, it segfaults
02:08:46 <EvanR> your bindings are probably doing glew-like stuff for you behind the scenes
02:10:41 <tsahyt> I don't see where they would do that
02:10:56 <tsahyt> the sdl bindings don't as far as I can tell
02:11:43 <EvanR> it wouldnt be in SDL
02:12:06 <EvanR> it would be spooky unsafePerformIOs in the gl bindings
02:12:20 <tsahyt> that would be very spooky indeed
02:12:32 <EvanR> that is how `gl' works
02:16:46 <tsahyt> considering that I do net get a segfault, you might be right
02:20:10 <EvanR> the C++ one works?
02:20:45 <tsahyt> yes
02:20:50 <tsahyt> unless I get rid of the glew stuff of course
02:21:13 <EvanR> strace both and compare :)?
02:25:48 <tsahyt> this might be more useful https://apitrace.github.io/
02:27:46 <tsahyt> nice, now I have a trace of all GL API calls of both versions :)
02:32:35 <tsahyt> EvanR: got it! and it's an annoying problem indeed. when loading the vertex data into the buffer, the C++ version uses sizeof on the array, giving 24 bytes. I was using the vector length instead, which is just 6 elements. so I simply had no triangle to draw
02:40:41 * hackage tidal-midi 0.9.9 - MIDI support for tidal  http://hackage.haskell.org/package/tidal-midi-0.9.9 (AlexMcLean)
02:42:52 <tsahyt> :r
02:42:58 <tsahyt> wrong window
02:45:12 * hackage aivika 5.7 - A multi-method simulation library  http://hackage.haskell.org/package/aivika-5.7 (DavidSorokin)
02:48:05 * hackage aivika-transformers 5.7 - Transformers for the Aivika simulation library  http://hackage.haskell.org/package/aivika-transformers-5.7 (DavidSorokin)
03:21:58 <solene> Hello, I have a problem installing persistent with cabal, it fails with the following Error log => https://pastebin.com/L7U3nB1C
03:22:19 <solene> I'm not a haskell developer, I'm not sure if it's a common error due to a mistake of me or if it's worth reporting
03:33:59 <Cale> solene: Looks like the MonadBaseControl instance for ResourceT got removed in version 1.2.0 of the resourcet package.
03:34:59 <solene> Cale, In fact I'm building persistent-2.7.0 which seems to be old. it's a dependency of git-annex and it fails here, I don't know why it's pulling an old version of te library though :(
03:35:00 <Cale> solene: But persistent doesn't have an upper bound in its dependencies for that package, and so it ought to.
03:35:07 <solene> 2.7.1 compiles
03:35:52 <Cale> Yeah, persistent-2.7.0 apparently needs its dependencies updated so that cabal knows it needs resourcet < 1.2.0
03:35:54 <solene> maybe this explains ? => persistent-2.7.0 (latest: 2.8.2) (via: esqueleto-2.5.3 persistent-sqlite-2.6.4)
03:36:21 <solene> can I fix this with a cabal command line flag ?
03:36:42 <Cale> You might be able to, but it could probably be considered a bug
03:37:14 <Cale> --constraint=resourcet<1.2.0
03:37:17 <Cale> should help
03:38:10 <Cale> Though more likely you just want to put that in the constraints in the .cabal file for your project and let cabal install the dependencies in a sandbox
03:38:13 <solene> Cale, I will try the flag, I added in git-annex.cabal the  resourcet (<1.2) dpeendency
03:38:22 <Cale> yeah
03:38:49 <solene> I'll report this to git-annex and they will know what to do with this. Is it a esqueleto bug ?
03:46:56 <kuribas> don't TypeFamilies make functional dependencies obsolete?
03:47:17 <kuribas> I find TypeFamilies to be more explicit, and thus clearer.
03:49:41 <kuribas> And I am often confused what the arrow means.
03:52:39 <cocreature> one downside of type families is that they complicate type signatures, e.g. MonadState Int m => m () vs (MonadState m, StateType m ~ Int) => m ()
03:54:07 <cocreature> and if you have multiple functional dependencies it can be awkward to encode them in type families
04:15:45 * hackage data-diverse 3.0.0.0 - Extensible records and polymorphic variants.  http://hackage.haskell.org/package/data-diverse-3.0.0.0 (louispan)
04:23:14 <electrocat> coincidentally, i've developed a way of encoding functional dependencies as type families
04:23:30 <electrocat> would be cool if that ends up in GHC some day
04:30:09 * hackage data-diverse-lens 3.0.0.0 - Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which  http://hackage.haskell.org/package/data-diverse-lens-3.0.0.0 (louispan)
04:34:01 <thblt> Hi!  I'm trying to run a hello world as a script, with the stack shebang magic, like this: #!/usr/bin/env stack \n
04:34:01 <thblt> -- stack --resolver=lts-11.5 --install-ghc runghc
04:34:01 <thblt>  
04:34:59 <thblt> and it takes more than 1s just to display hello world.  Replacing the shebang with runghc brings that down to ~120ms, which is better although still a lot.  Any tips on improving that?
04:40:20 <cocreature> thblt: I don’t think there’s any way to improve this short of digging in the stack source code and seeing if some of the overhead can be avoided
04:41:43 <thblt> cocreature: thanks!
04:44:03 <michalrus> ! null.asInstanceOf[AnyRef] eq null
04:44:23 <michalrus> Oh, wrong channel.
04:58:23 <kuribas> cocreature: right, that first type signature looks nicer.
05:00:56 <hc> Hi all, suppose I want to ensure via the type system that a cryptographic nonce only be used once. Is this possible somehow? :-)
05:04:28 <kuribas> hc: use a phantom type, User | NotUsed ?
05:06:10 * kuribas probably needs more information...
05:09:25 <hc> kuribas: https://hackage.haskell.org/package/saltine-0.1.0.1/docs/Crypto-Saltine-Core-Box.html#v:box
05:09:35 <hc> "It is infeasible for an attacker to decrypt the message so long as the Nonce is not repeated."
05:09:45 <hc> Which means if I accidentally use the same nonce twice, I have a real problem
05:10:16 <hc> So I just wondered if it is possible to express that constraint via the type system
05:11:09 <kuribas> hc: generate it, then use it only once?
05:11:21 <kuribas> hc: if you don't return the nonce, it can never be used.
05:11:34 <kuribas> thanks to purity
05:17:28 <hc> That's what I'm doing right now (or so I hope)
05:17:53 <hc> But I have no guarantee since I don't know how to express that constraint via the type syste
05:17:56 <hc> m
05:20:40 <Ferdirand> something with rank-2 types, kinda like ST is doing, maybe ?
05:21:18 <kuribas> hc: something like this: safeNonce :: (Nonce -> IO a) -> (IO a), safeNonce f = newNonce >>= f
05:21:33 <kuribas> hc: if a doesn't contain Nonce, it cannot escape.
05:22:41 <kuribas> erm, well it could, if you store it in a IORef...
05:24:22 <kuribas> better safeNonce: (Nonce -> a) -> IO a
05:25:28 <spruit11> Can't you just inject a nonce into a monad and then never expose it anymore?
05:26:45 <kuribas> safeNonce f = f <$> newNonce
05:26:58 <lyxia> linear types!
05:31:18 <hc> lyxia: -v please?
05:34:39 <lyxia> linear types in Haskell are still work-in-progress, but the idea is exactly to express in the type system that some values should only be used once.
05:34:57 <exarkun> yay linear types
05:35:25 <Tuplanolla> Doing what Massiv does for array representations would get you `data Status = Fresh | Stale` and `data Surely s = Surely Nonce`. Alas, ensuring the single-use policy would require doing everything through functions of type `(Surely Fresh, a) -> (Surely Stale, b)`, which would be annoying.
05:35:54 <Tuplanolla> This would require either carrying a state token or secretly maintaining a mutable reference.
05:36:06 <hc> so if I define a function "newNonce :: forall s. IO Nonce s" and a data type "data Nonce s = Nonce ByteString"
05:36:17 <hc> Then I just need a "consumer" that requires a different s each time it is used
05:36:55 <hc> i.e., "printNonce :: eachTimeADifferent s. Nonce s -> IO ()"
05:37:14 <hc> so "printNonce nonce1" typechecks, but "printNonce nonce1 >> printNonce nonce1" won't typecheck
05:43:48 <lyxia> there is a new function type,   printNonce :: Nonce -o IO ()   that says it uses its argument only once
05:43:53 <nkaretnikov> anyone familiar with rust here? i've recently (re-)learned that rust has some features making concurrent programming easier. e.g., some types indicate that you cannot share values of such a type between threads, or something like that. does haskell have a similar library or something?
05:44:23 <lyxia> I don't remember what construct makes a new Nonce only usable once though, but it's all in the paper or tweag.io's blogposts.
05:44:29 <nkaretnikov> lyxia: did they decide to go forward with the -o for ascii instead of other alternatives?
05:44:41 <nkaretnikov> or is it still debatable?
05:45:06 <phadej> nkaretnikov: rust "concentrates" on making mutation "safe" in concurrent setting. It's not very Haskell-liky.
05:45:16 <lyxia> I'm sure they won't use  -o
05:45:55 <phadej> https://github.com/ghc-proposals/ghc-proposals/pull/111 uses ->.
05:46:12 <phadej> .. > The type of linear functions from A to B is written A ->. B (see Syntax).
05:47:11 <Tuplanolla> In case of a disagreement, pick the worst option.
05:47:14 <nkaretnikov> phadej: re mutation: i could imagine something like this useful with tvar and such, but i need to re-read the rust book first
05:47:21 <nkaretnikov> Tuplanolla: hahaha
05:48:19 <phadej> nkaretnikov: tvar is completely different, it's transactional memory. Borrow-checker won't help you to maintain "consistent view" if the shared state.
05:48:25 <phadej> tvar is made to be shared
05:49:28 <nkaretnikov> phadej: oh, well... :) i'll read the book than come back with more questions later, then!
05:53:43 * hackage prologue 3.1.5 - Better, more general Prelude exporting common utilities.  http://hackage.haskell.org/package/prologue-3.1.5 (danilo2)
05:57:09 * hackage data-diverse-lens 3.0.0.1 - Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which  http://hackage.haskell.org/package/data-diverse-lens-3.0.0.1 (louispan)
05:59:03 <sm> thblt: I had an idea they improved that a bit. Try latest stack release, and stack script rather than stack runghc
06:13:27 <thblt> sm: thanks, tried both, with no serious improvements.  I guess I'll stick to zsh for scripting for now :-)
06:16:21 <sm> thblt: a pity. It takes 0.8s here. (macos, stack-git)
06:17:49 <sm> however, it has the advantage over a shell script that you can compile it, and then it takes 0.02s
06:24:14 <slevin> hola everybody
06:25:02 <slevin> anybody have some good resources (papers, links) on the benefits of using haskell (and/or monads) for achieving security?
06:25:55 <Tuplanolla> What kind of security are you after, slevin?
06:26:47 <kuribas> @hoogle Functor f => (a -> f b) -> (c, a) -> f (c, b)
06:26:48 <lambdabot> Control.Functor.HT mapFst :: Functor f => (a -> f c) -> (a, b) -> f (c, b)
06:26:48 <lambdabot> CLaSH.Util firstM :: Functor f => (a -> f c) -> (a, b) -> f (c, b)
06:26:48 <lambdabot> Control.Functor.HT mapSnd :: Functor f => (b -> f c) -> (a, b) -> f (a, c)
06:28:28 <slevin> Tuplanolla: i'm writing a js interpreter with monads, and therefore arguing about the security benefits of statically-typed functional programming
06:28:57 <slevin> Tuplanolla: it doesn't have to be about benefits of monads, rather FP in general
06:33:00 * hackage hw-kafka-client 2.4.3 - Kafka bindings for Haskell  http://hackage.haskell.org/package/hw-kafka-client-2.4.3 (alexeyraga)
06:33:46 <slevin> nothing, people? :(
06:34:43 <Tuplanolla> Your question is too vague.
06:35:35 <slevin> alright how about this: "why should you use haskell for writing interpreters?"
06:36:15 <slevin> edit: "why should you use haskell for writing secure interpreters"
06:36:41 <yyyyy> slevin: trivial to represent the target language AST on the type system?
06:37:04 <thblt> sm: of course, but the point of having scripts is not having to compile them :-)  I'm running NixOS, I suspect that doesn't help stack performance
06:37:06 <yyyyy> not sure about the second one though. What's a secure interpreter?
06:37:46 <slevin> there is easy to find material on why it's easier to write correct code with haskell, and by extension, writing secure programs
06:38:25 <slevin> arguments can include type system, state mgmt and formal verification techniques
06:38:33 <yyyyy> while I don't disagree with the general idea, I'm not sure I would sell an interpreter written in Haskell immediatelly as secure.
06:39:12 <yyyyy> I don't even know what it means. Maybe it guarantees that it will never segfault interpreting your code?
06:39:33 * adjofun looks at launchMissiles
06:39:40 <yyyyy> Or that the code will not be tampered with?
06:39:53 <sm> thblt: related: https://github.com/commercialhaskell/stack/issues/2885
06:39:53 <maerwald> slevin: it's not that easy
06:39:58 <yyyyy> Those things would not come as default
06:40:05 <slevin> im writing about browser security, where the js interpreter is a popular attack vector. they are huge and written in C++.
06:40:07 <yyyyy> You have to think how to do them
06:40:09 <maerwald> slevin: formal verification is not easier in haskell
06:40:13 <maerwald> not at all
06:40:41 <yyyyy> Maybe you can do formal verification in Agda and then FFI to your Haskell interpreter, but that will not be a Haskell property
06:40:45 <slevin> an interpreter isn't by some magic secure since it's written in haskell, but it's aruable eaiser to write one
06:40:50 <fendor> morning, although I am scared to start a holy flame war, what is the recommended monads transformer library?
06:41:04 <maerwald> you're simplifying a very complicated domain
06:41:23 <cocreature> fendor: transformers/mtl
06:41:28 <kuribas> I believe noadays mtl and transformer use the same code
06:41:30 <adjofun> slevin: you can write js interpreter in any language, but host language wont make JS spec any different
06:41:53 <fendor> cocreature, ok, nice, will do that
06:42:16 <cocreature> kuribas: no they don’t. transformers provides the actual transformers, mtl reexports the types from transformers and provides type classes that abstract over those transformers
06:42:16 <fendor> cocreature, i have read that we want to put mtl to a rest, is that true?
06:42:17 <slevin> adjofun: that's besides the point
06:42:24 <cocreature> fendor: that would be news to me
06:42:36 <cocreature> and I highly doubt it
06:42:46 <adjofun> slevin: just checking that you aren't worried about eval() =:)
06:43:01 <fendor> and why is mtl preferred over monads-tf for example?
06:44:02 <kuribas> mtl and transformers are pretty standard
06:44:08 <kuribas> never heard of monads-tf
06:44:34 <slevin> maerwald: could you elaborate?
06:44:51 <maerwald> slevin: on what
06:45:06 <slevin> "you're simplifying a very complicated domain"
06:45:28 <maerwald> yes, security and formal verification is more complicated than "hey, we have a functional language with a great type system"
06:45:39 <maerwald> and haskell is not very good for that
06:46:01 <maerwald> no verified compiler, you have no idea what code comes out of it
06:46:13 <slevin> maerwald: i was giving examples on low-handing arguments commonly used for fp
06:46:18 <maerwald> you're just talking about high-level verification, which has little meaning if you do actual security stuff
06:46:23 <slevin> low-hanging*
06:46:25 <maerwald> see seL4 or the everest project
06:46:51 <slevin> i am not talking about verification. i think you missed my question
06:47:00 <kuribas> maerwald: it's not worse than mainstream languages.  In fact it's much better
06:47:17 <maerwald> kuribas: no idea what that means
06:48:00 <kuribas>  <maerwald> and haskell is not very good for that
06:48:30 <slevin> i am looking for material on why complex applications written in haskell could be more secure
06:48:46 <maerwald> slevin: they are not
06:49:14 <slevin> maerwald: they COULD be, and i think many people would argue so
06:49:22 <maerwald> there is no consistent argument for it
06:49:28 <adjofun> maervald: I googled "everest project", and got some stuff about raising women executives in corporations, are you sure that is connected with verification? =:)
06:49:28 <maerwald> it's just a feeling people have
06:49:34 <slevin> that it's at least easier
06:49:45 <maerwald> it isn't
06:50:05 <maerwald> adjofun: https://project-everest.github.io/
06:50:50 <slevin> maerwald: alright, that's interesting. could you elaborate?
06:50:57 <maerwald> you might also find this interesting https://ts.data61.csiro.au/projects/TS/
06:51:14 <zincy> When using nix how do I specify in the cabal config that there is an exposed module? Getting app/Main.hs:2:8:     Could not find module ‘Lib’
06:51:28 <kuribas> haskell offers more ways to encode invariants in your program than mainstream languages do.
06:51:31 <maerwald> slevin: the topic is too complicated to elaborate in a few sentences
06:51:32 <slevin> many argue that the statically typed functional paradigm makes it more difficult to make bugs like buffer overflows, format-string vulnerabilities, and use-after-free errors
06:51:40 <slevin> do you disagree?
06:51:56 <slevin> maerwald: understood. i am just looking for some concrete arguments
06:52:07 <maerwald> slevin: you can have memory safety in different ways
06:52:15 <maerwald> and that is just a tiny part of security
06:52:21 <kuribas> It doesn't make your programs automatically secure, but it does make it does offer more tools to do so.
06:52:40 <maerwald> slevin: when you write security programs you want to be as close to the emitted machine code as possible
06:52:50 <maerwald> check F* and their C code extraction project
06:53:06 <maerwald> haskell is the opposite of that
06:53:14 * hackage csound-expression-opcodes 0.0.4.0 - opcodes for the library csound-expression  http://hackage.haskell.org/package/csound-expression-opcodes-0.0.4.0 (AntonKholomiov)
06:53:14 <maerwald> you have no idea what comes out of it
06:53:34 <maerwald> how can you prove anything about your program if you have no control over the low level
06:53:36 <maerwald> you can't
06:54:07 <kuribas> following that reasoning only assembly language is secure.
06:54:11 <maerwald> so you need a way that your high level proofs translate to the low level
06:54:17 <maerwald> kuribas: no.
06:54:34 <yyyyy> If you can prove your compiler, not only assembly, kuribas
06:54:58 <slevin> maerwald: interesting point!
06:55:02 <kuribas> prove what?
06:55:09 <kuribas> That buffer overflows aren't possible?
06:55:11 <slevin> prove the correctness, i assume
06:55:14 <yyyyy> prove that it will emit according to spec
06:55:22 <kuribas> that the semantics are identical?
06:56:07 <yyyyy> yeah, though then you will reach "but then you have to prove the processor"
06:56:30 <yyyyy> that it will execute only what's passed to it according to spec
06:56:55 <slevin> prove the correctness of process: "sounds good, doesn't work"
06:56:59 <maerwald> slevin: here is a formally proven kernel https://sel4.systems/
06:57:08 <maerwald> they would never use haskell
06:57:13 <slevin> sorry, meant processor*
06:57:14 <adjofun> and then you'll need to prove laws of physics as applied to processors =:)
06:57:34 <yyyyy> it's a bottomless pit
06:57:42 <kuribas> even so, I'd say human errors account to much more security flaws than compiler bugs.
06:57:42 <maerwald> slevin: there's a lot material there too
06:57:45 <slevin> maerwald: thanks! that could be good mention
06:57:50 <yyyyy> actually for haskell it's a bottomful pit :p
06:58:26 <yyyyy> (bad pun)
06:58:30 <slevin> on verification, "high assurance implementation" is good buzzword
06:58:39 <slevin> yyyyy: ^^
07:00:28 <maerwald> slevin: also, the everest project has a ton of papers
07:00:46 <slevin> maerwald: was just looking at it. very good stuff, thanks
07:01:04 <adjofun> slevin: first hit in google on that buzzword is paper about bad consequences of assuming high assurance =:)
07:01:33 <slevin> adjofun: ooo, ty
07:02:07 <adjofun> "Critical and catastrophic failures in high assurance systems" doesn't sound too good to me =:)
07:02:13 <maerwald> you might find robigalia interesting too... there are attempts to write a rust based ecosystem around seL4
07:02:24 <maerwald> rust is actually more interesting wrt security
07:02:25 <slevin> adjofun: can you link it? not sure which you mean
07:03:02 <slevin> maerwald: because of the type system, or the low-level control?
07:03:14 <maerwald> memory safety guarantees
07:03:21 <maerwald> while still being low-level
07:03:27 <slevin> ah, yes ofc
07:03:46 <maerwald> although, the emitted llvm IR code is not that pleasanet I've heard
07:03:50 <adjofun> ieeexplore.ieee.org/iel5/32/36131/01717472.pdf
07:04:42 <adjofun> this paper basically says "no matter how highly assured your systems, if there are people in them, then your efforts are in vain" =:)
07:05:11 <slevin> but if i were to shift the question away from security, to ease of implementation. how would you argue the benefits of using monads for adding and testing new security mechanisms to an interpreter?
07:05:25 <maerwald> the only thing wrt security where haskell shines are parser combinators
07:05:30 <maerwald> yes, they are relevant for that
07:05:40 <maerwald> check http://langsec.org/
07:05:45 <yyyyy> maerwald: rust is all the rage now when it comes to security, but it cannot yet touch Ada SPARK, by a large margin.
07:06:12 <maerwald> but then again, there are already parser combinator libraries in C ;)
07:06:31 <maerwald> written by those langsec people afair
07:07:16 <yyyyy> I think the selling point of haskell should not be security but expressiveness
07:08:00 <slevin> yyyyy: you might be right
07:08:20 <slevin> maerwald: thanks, ill look into langsec. see they hav a lot of papers
07:09:23 <maerwald> slevin: another thing you might want to look at is "information flow control"
07:09:35 <maerwald> there are even some attempts in haskell to do that with arrows and monads
07:09:51 <onaka[m]> I wonder, would the fact that the compiler spits out random stuff be a kind of security win in certain situations, like for instance if no two binaries are the same, how are you going to inject anything into them reliably? I mean, I'm a dabbler at this kind of stuff so I know just enough to make an ass out of myself, so please don't crucify me.
07:10:00 <maerwald> slevin: https://hackage.haskell.org/package/mac
07:10:03 <slevin> having simple monadic interpreter would make it simple to add and test new security mechanisms, no? for instance, if i would add want to add some taint-analysis to mitigate xss (example technique), why would the monads help
07:10:29 <maerwald> and https://hackage.haskell.org/package/lio
07:10:34 <yyyyy> maerwald: but couldn't you sneak unsafePerformIO to write out to an IORef within it? How do you enforce no one does it?
07:10:54 <slevin> maerwald: good point. i've actually looked at some information flow and taint analysis
07:10:57 <yyyyy> Or to an external file.
07:10:59 <maerwald> http://www.cse.chalmers.se/~russo/publications_files/haskell11.pdf
07:11:08 <maerwald> https://pdfs.semanticscholar.org/7940/e17145bd607e46971fc6940d78cc2ad08dc5.pdf
07:11:24 <maerwald> sorry, I've read about those topics for months, so I could dump you a crapload of papers :P
07:12:03 <yyyyy> Or abort the information and catch its contents from within by using `throw`
07:12:28 <slevin> onaka[m]: injecting code into binaries is trivial, even with strange binaries. the point of entry can easily be manipulated and even arbitrary payloads can be injected
07:13:02 <yyyyy> if the answer to `unsafePerformIO` and `throw` are developer discipline then it's no better than C with guidelines.
07:13:48 <yyyyy> A house full of elegant porcelain built atop a hidden button-activated treadmill
07:13:56 <slevin> maerwald: ty! the info flow links are golden
07:14:25 <yyyyy> (and I love Haskell, just curious over how those things would be enforced)
07:14:59 <maerwald> slevin: Jif is also interesting
07:15:10 <maerwald> https://www.cs.cornell.edu/jif/
07:15:14 <maerwald> quite mature
07:18:27 <kuribas> yyyyy: except that in C every operation would be marked unsafe.
07:19:51 <kuribas> yyyyy: and haskell programmers try to avoid unsafe operations as much as possible.
07:21:32 <kuribas> if you actually want to run untrusted code, then the typesystem isn't enough.
07:26:53 <chisui> Is there a way of disabling specific warnings for a module? I have -Wall set in my cabal file but I want to get rid of the orphan warnings for Arbitrary instances in my Tests. Is There a way to only disable -Worphans for the module these instances are defined is?
07:26:57 <fendor> zincy, you still have the problem with cabal and nix?
07:27:22 <davean> kuribas: there is SafeHaskell, its a start
07:27:28 <davean> kuribas: it enforces the type system ;)
07:27:40 <kuribas> chisui: {-# OPTIONS_GHC -fno-warn-orphans #-}
07:27:55 <kuribas> chisui: put it on top of the module file.
07:28:14 <kuribas> davean: ah, nice :)
07:28:23 <chisui> kuribas: nice, thanks
07:29:06 <chisui> does this -fno-warn- prefix work for any warning?
07:29:13 <davean> chisui: most
07:35:36 <lyxia> the new style options is -Wno-orphans
07:37:12 <ertes> slevin: your original question (i didn't read through the whole backlog) can easily be answered without any papers:  a common interpreter and compiler design in haskell (including GHC itself) is to translate the complicated source language into a minimal core language (ideally with well-defined semantics) that is easy to understand and reason about…  then you do all the transformations on that core language, and you do so using pure
07:37:12 <ertes> functions for the most part
07:38:45 <ertes> slevin: haskell facilitates this design by providing powerful ADTs and laziness…  the latter allows you to write the whole compilation/interpreter pipeline using pure functions, and it's still efficient as well as responsive
07:39:48 <ertes> slevin: only the final step (translating the ADT into an IO action) actually gets real-world effects involved, and then it's still highly controlled, because IO is not a side-effecting language, but you actually compose programs from smaller components
07:41:45 <ertes> slevin: just take GHC as an example: it's a massive and complicated piece of software, yet you rarely read about security issues despite the fact that the devs manage to get new and exciting non-trivial features into it in every major release (~ every 6-12 months)
07:44:59 <slevin> maerwald: yyyyy: thanks for the material, i've got a bit if reading to do ;)
07:45:21 <slevin> ertes: very good point. i think using ghc as an example is very nice. thanks!
07:45:53 <ertes> slevin: also from my skimming of the backlog i get the impression that a lot has been said about *proving* security, which is a different topic
07:46:45 <slevin> ertes: yes, i am not looking to implement any verification techniques, but it's worth mentioning somewhere
07:46:51 <ertes> haskell is not a proof assistant, it's just a good programming language…  in theory GHC-haskell is as expressive as a dependently typed language, but it's not very practical for more complicated proofs
07:47:33 <ertes> so yeah, you get safety and security just from the way it's designed and the kind of idioms you typically use
07:48:29 <ertes> even if you use IO heavily and do a lot of mutation, if you avoid global state, you can still use equational reasoning with haskell
07:48:57 <seequ__> Is there a good TCP server library?
07:49:44 <ertes> seequ__: you can use the 'network' library directly and build your own abstractions, but for processing streams you might be interested in a streaming framework
07:49:58 <ertes> seequ__: i believe pipes-network has ready-made TCP server stuff
07:50:09 <ertes> seequ__: there is a lot of conduit-based stuff, too
07:50:19 <DigitalKiwi> twisted *ducks*
07:50:43 <ertes> seequ__: and just to mention my personal favourite: i would use machines, but if you use that, you'll most likely have to write the TCP/server-related stuff yourself, because there are fewer support libraries for it right now
07:52:21 <davean> ertes: us people using machines need to get to releasing stuff using it
07:52:29 <klv> Hello. I'm a Haskell newbie. I'd need some guidance in how to divide a list of elements (prime factors) into a list of lists.. Illustrated: [2, 2, 3, 5] yields [[2, 2], [3], [5]].
07:52:55 <ongy> :t group
07:52:57 <lambdabot> Eq a => [a] -> [[a]]
07:53:12 <ongy> ^ klv Try that one
07:53:18 <ertes> davean: agreed, i'm planning to release some of my stuff, but it's just a lot of work to collect all of it into a consistent library and write useful documentation =/
07:54:52 <klv> Woah ongy, I've missed it
07:54:59 <gymcap[m]> I'm used to programming in AutoHotKey
07:55:05 <klv> I think I can use that, thanks :)
07:55:20 <davean> ertes: I bet us machine users are duplicating each other's work :/
07:55:26 <gymcap[m]> Can i ask what kinds of things you can do with haskell?
07:55:39 <ertes> davean: yeah, most likely
07:55:41 <EvanR> wow there are machines users?
07:55:59 <ertes> gymcap[m]: haskell is a general-purpose language
07:56:15 <davean> EvanR: I've got some pretty big things built on machines
07:56:39 <davean> EvanR: it's a nice model when you get past just streaming
07:57:07 <ertes> EvanR: me too…  basically our whole monitoring system is built on it, and i have lots of little data processors using concurrent-machines
07:57:39 <ertes> BTW, concurrent-machines is one of my favourite libraries on hackage =)
07:59:20 <davean> ertes: what monitoring?
08:00:06 <ertes> davean: our infrastructure: event monitors, graphs, notification stuff, etc.
08:01:35 <EvanR> cool
08:02:18 <davean> ertes: for ...?
08:02:35 <davean> also, ertes, concurrent? Limiting ourselves to one computer I see ;)
08:02:49 <davean> (I'm working on a distributed systems library using machines)
08:02:56 <EvanR> the days since accident involving an intern realtime animated chart
08:22:24 <michieldc> Hi guys, I'm struggling a bit with a basic Yesod application. I used this handler from a Youtube video (http://lpaste.net/7018640185650839552) but the compiler says "Empty do block" on line 7. What's wrong?
08:24:11 <onaka[m]> I'm no expert, but doesn't $ basically put a ( where it's placed, and a a ) at the end of the line? Or at least that's how it was explained to me somewhere. (that is not exactly what it does, but yeah)
08:24:39 <onaka[m]> michieldc:  so if you do that, you're essentially doing ( do), which seems to me like it wouldn't work?
08:25:53 <michieldc> It works in the video it seems
08:27:30 <onaka[m]> I wonder if this is for a very old version of GHC?
08:27:44 <michieldc> Wait, do i need to turn on Template Haskell in my cabal file?
08:28:02 <onaka[m]> If someone with actual experience could chime in, that would be grand.
08:29:50 <onaka[m]> Don't know anything about that, but it looks like it's doing a lot of that whole $(...) stuff that https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell says is a part of template Haskell.
08:29:52 <xiaohei> If I pattern match on a list with (x:xs), how do I know when x is the first element of the list?
08:29:53 <davean> Yah, that looks like a templateHaskell issue
08:30:07 <davean> michieldc: you should turn on tempalte Haskell
08:30:22 <lemmih> xiaohei: It's that way by definition.
08:30:25 <davean> (I don't use Yesod, because I don't like how it works, so thats just my Haskell knowlege talking)
08:31:14 <michieldc> davean: yeah, that seems to be working
08:33:12 <xiaohei> lemmih: I am doing an exercise, I want to capitalize a paragraph, I need to capitalize the first word and the words right after a period-space. I can do it for the period-space part, but have no idea how to do that with the first word.
08:34:09 <octarin> Hi.
08:34:32 <lemmih> xiaohei: let (x:xs) = "paragraph" in toUpper x : xs
08:34:59 <octarin> I’ve read about immutable arrays that the query time is linear in the size of the array.
08:35:33 <lemmih> octarin: That's not so for all immutable arrays.
08:35:58 <davean> Thats not even true of persistent arrays
08:36:35 <davean> octarin: Actually, I have no idea what that would be true for
08:36:46 <lemmih> I think he's talking about Data.Array.Diff.
08:36:54 <octarin> Data.Array
08:37:48 <lemmih> octarin: Indexing an ordinary immutable array is O(1) as expected.
08:38:27 <octarin> for example if i define primes n = array (1,n) $ (1,False) : map (\u -> (u, isPrime u)) [2..n]
08:38:28 <xiaohei> lemmih: But I need to put in the same function the code capilizing the first word of *each* paragraph, which is a single string. Your suggestion only works for the first paragraph.
08:38:50 <octarin> and I take for example primes1000 = primes 1000
08:39:01 <davean> lemmih: oh, Data.Array.Diff is a naive implimentation - there are fast ones
08:39:06 <octarin> will the access time be in O(1) after one update ?
08:39:09 <davean> and ... doesn't even exist anymore
08:39:10 <lemmih> xiaohei: Great. Add the code you have for capitalizing after period-space and you're done, right?
08:39:47 <ertes> davean: huh?  what makes you think that using concurrency means your application isn't distributed?  in fact i don't know how to do distributed applications *without* concurrency
08:39:49 <lemmih> octarin: Access is always O(1).
08:40:29 <lemmih> octarin: Update is O(n), though.
08:40:55 <davean> ertes: concurrent-machines is syncronous-local
08:41:03 <lemmih> (Unless you use diff arrays which you really shouldn't do)
08:41:38 <octarin> so for example if I check primes1000 ! 293, and then I do it again, will the 2nd query will be in O(1) ?
08:42:01 <ertes> davean: sure, it's one component, and it makes talking to lots of services/hosts at the same time very easy
08:42:37 <lemmih> octarin: Yep, access is always O(1).
08:42:39 <davean> ertes: I don't see it as a building block to a distributed machines network even
08:43:35 <ertes> davean: me neither, but it's a very useful component in a larger system, and it facilitates doing things with many connections in a streaming fashion
08:43:49 <xiaohei> lemmih: Seems right... but I am restricted to using the capitalizeWord function in the capitalizeParagraph function.
08:44:15 <davean> ertes: Yes, I was poking fun at limiting the scale of your machines code to a single system scope
08:44:21 <lemmih> xiaohei: Alright. So what's the problem?
08:44:39 <ertes> davean: the joke didn't work, because it's not true
08:44:51 <ertes> in fact i found it slightly insulting =)
08:44:55 <davean> ertes: Thats a discussion a bit to complicated for this channel
08:45:14 <xiaohei> lemmih: capitalizeWord takes a String -> String, not like toUpper
08:45:39 <lemmih> xiaohei: I still don't see the problem.
08:45:54 <xiaohei> lemmih: capitalizeParagraph :: String -> String
08:45:54 <xiaohei> capitalizeParagraph [] = []
08:45:54 <xiaohei> capitalizeParagraph xs = capitalizeWord xs
08:46:26 <lemmih> xiaohei: You can use lpaste.net to paste the code.
08:47:26 <lemmih> xiaohei: It's easier for us to help you if you explain what you want to do and what you've tried so far.
08:48:46 <xiaohei> lemmih: http://lpaste.net/364788, this is the current implementation, it capitalizes the first word of each paragraph(separated by period-space) except the first one.
08:49:51 <xiaohei> lemmih: Please refresh the page, I add the capitalizeWord function.
08:50:36 <lemmih> xiaohei: That code isn't valid. Are you sure you copied it correctly?
08:51:42 <onaka[m]> Wouldn't it make sense to split the paragraph by ". " and then just apply the capitalization to each sentence?
08:52:07 <onaka[m]> Then join it back with like unwords or something?
08:52:17 <xiaohei> lemmih: Sorry, I edited it, now it works.
08:53:41 <lemmih> xiaohei: And your homework assignment says you must have those two functions?
08:54:37 <xiaohei> lemmih: Yes, it is required to use the capitalizeWord function.
08:56:58 <lemmih> xiaohei: So it works fine expect the first word of the paragraph is not capitalized, right?
08:57:47 <xiaohei> lemmih: Right.
08:58:04 <ertes> @let broken p f = go where go xs' = case break p xs' of (xs1', []) -> f xs1'; (xs1', x : xs2') -> liftA2 (\xs1 xs2 -> xs1 ++ x : xs2) (f xs1') (go xs2')
08:58:06 <lambdabot>  Defined.
08:58:09 <xiaohei> Maybe I misinterpret the requirement for the capitalizeWord function, because now my implementation is actually capitalizing the entire string.
08:58:13 <lemmih> xiaohei: And you have a function that can capitalize a word. How about combining them?
08:58:31 <lemmih> xiaohei: solution xs = capitalizeParagraph (capitalizeWord xs)
08:58:31 <ertes> > (broken (== ' ') . ix 0 %~ toUpper) "abc def ghi"
08:58:33 <lambdabot>  "Abc Def Ghi"
08:59:00 <xiaohei> lemmih: I already did that as you can see from the code.
08:59:28 <xiaohei> lemmih: Oh, seem differnt.
09:00:23 <xiaohei> lemmih: But I still don't know how to pattern match it.
09:00:40 <lemmih> xiaohei: You don't.
09:00:49 <lemmih> Err, you don't pattern match it.
09:01:28 <lemmih> xiaohei: The first word in the paragraph is capitalized due to a different rule.
09:01:39 <ertes> > (broken (== '.') . partsOf (traverse . filtered isLetter) . ix 0 %~ toUpper) "sentence one. sentence two."
09:01:41 <lambdabot>  "Sentence one. Sentence two."
09:01:49 <Mitsos101> Hello everyone! How do I write something like this C function in Haskell: http://lpaste.net/364791 ? Basically, a pure function that has static variables that change with each function call. (The operations are obviously more complicated than finding the sum of the integers in [l,r])
09:02:07 <xiaohei> lemmih: But how do I put the code in the same function?
09:02:41 <lemmih> Mitsos101: It's not pure, then. :)
09:02:42 <EvanR> Mitsos101: thats going to be tricky
09:03:04 <xiaohei> lemmih: I can't do: capitalizeParagraph (capitalizeWord string)
09:03:12 <EvanR> lemmih: its possible to be pure anyway
09:03:34 <EvanR> Mitsos101: is your C function reentrant?
09:03:42 <manek> Hi guys! Is there any standard function like `liftA2` but one that uses join after the result is created (its first function returns monadic action rather than just value) ?
09:03:43 <Mitsos101> But f(l,r) will always return the same values
09:03:55 <EvanR> if not, even your C function is not pure
09:04:23 <[exa]> manek: what type would you like it to have?
09:04:40 <manek> [exa]: (a -> b -> f c) -> f a -> f b -> f c
09:04:54 <lemmih> xiaohei: Sure you can. I believe in you.
09:05:36 <ertes> manek: unfortunately no…  you need to apply 'join' yourself
09:05:52 <[exa]> this action had a name though
09:06:39 <manek> ertes, [exa] : hmm what is its name? I would need it for 2, 3 and 4 components and I would like to generlize it
09:06:43 <Mitsos101> EvanR: It's not reentrant
09:07:44 * [exa] searching for the paper
09:08:47 <EvanR> Mitsos101: http://lpaste.net/364792
09:09:07 <lyxia> manek: some call it bind2 but it's not in any common package.
09:09:09 <xiaohei> lemmih: Thank you.
09:09:26 <ertes> manek: if your combination functions are of the form (a -> F r), (a -> F (b -> F r)) and (a -> F (b -> F (c -> F r))), you can write a variant of (<*>) that uses 'join', and then you can write a combinator/class that turns (a -> b -> c -> F r) into (a -> F (b -> F (c -> F r)))
09:09:40 <ertes> manek: but it's not going to be as pretty as just applying 'join' explicitly
09:10:02 <EvanR> Mitsos101: i made two versions of this, depending on where the mvar comes from
09:10:22 <EvanR> now its even usable from different threads, unlike C
09:11:29 <[exa]> lyxia nailed it, iirc I saw it as 'bindA2'
09:11:31 <EvanR> the burden is on the programmer to make sure the full function is pure, otherwise the behavior of unsafePerformIO will wreck havoc
09:11:47 <Mitsos101> EvanR: By the way, how could I simply translate the while loops?
09:11:52 <ertes> manek: (<!*>) :: (Monad m) => m (a -> m r) -> m a -> m r;  infixl 4 <!*>
09:12:01 <EvanR> you could
09:12:11 <EvanR> by using a State monad on the inside
09:12:36 <EvanR> well, it would be a pain in the ass since you have 3 variables
09:12:54 <ertes> lenses can help with that
09:13:18 <EvanR> im not sure its worth it
09:13:27 <ertes> > execState (do _1 += 5; _2 += 7) (10,20,30)
09:13:28 <EvanR> over just rewriting it in haskell
09:13:29 <lambdabot>  (15,27,30)
09:13:34 <ertes> probably not =)
09:20:55 <Mitsos101> EvanR: This is how the cost function for a dynamic programming optimization is written. Basically, you have a mutable data structure in the function and you take advantage of the fact that many calls for f(l,r) have the same left/right endpoints. I'm not sure if it can be rewritten in Haskell easily
09:21:15 <EvanR> no i mean the calculation in the body
09:22:13 <byorgey> Mitsos101: dynamic programming can be rewritten in Haskell easily, but not using mutable data structures.
09:22:24 <int-e> Mitsos101: How big is the range of possible values of l (and r) going to be?
09:22:24 <byorgey> You use lazy immutable data structures instead.
09:22:46 <EvanR> while(r0 < r) s += ++r0;, what this is doing is adding r-r0 to s, and then setting r0 to r
09:23:14 <EvanR> but i see you do something else if r0 > r
09:23:26 <EvanR> so theres a few cases to consider, case analysis (guards)
09:23:40 <EvanR> only one of each pair of while loops would happen
09:23:42 <Mitsos101> EvanR: yes, of course, you could just do return r * (r+1) / 2 - l * (l + 1) / 2 instead of all that, but it's something more complicated usually
09:24:05 <int-e> Mitsos101: I mean if it isn't too large then precomputing the sums [0..i] f(i)  should be a decent approach. You can even exploit laziness so that not all f are computed right away
09:24:25 <EvanR> if C style is really a benefit, you can also use inline C
09:24:50 <EvanR> the pure bodies of pure functions are usually nicer to express with haskell and not C
09:24:59 <Mitsos101> int-e: l,r <= 10^5, but f(l,r) isn't necessarily invertible. e.g. counting inversions in the subsegment [l,r] using a BIT
09:25:25 <edwardk> Figured I should mention this in here at least once, there is a https://gitter.im/haskell-pair-programming gitter where we've been coordinating haskell pair programming sessions (I'd prefer it be IRC, but others started it on gitter)
09:27:16 <EvanR> yeah, r0' = r, l0' = l, s' = s + abs (r - r0) - abs (l - l0), or such
09:27:53 <EvanR> or maybe not abs, see i cant even understand the C code :)
09:28:27 <Mitsos101> EvanR: using inline C is a good idea, but I think I'll never learn how to write many competitive programming algorithms in Haskell if I do that
09:28:35 * hackage aivika-distributed 1.3 - Parallel distributed discrete event simulation module for the Aivika library  http://hackage.haskell.org/package/aivika-distributed-1.3 (DavidSorokin)
09:28:43 <Mitsos101> EvanR: f(l,r) calculates the sum of l, l + 1, l + 2, ..., r
09:29:33 <EvanR> so, thats how you can use mutable variables in a pure function as long as its pure. as far as style goes, maybe you want to ask about a more complicated C algorithm
09:29:50 <EvanR> another thing you want to look at is using unboxed ints
09:30:47 <Mitsos101> Is there any way to simply translate the while loop?
09:31:00 <EvanR> ertes showed some lenses
09:31:17 <EvanR> earlier. but youre getting farther away from the goal of high performance right?
09:31:19 <lemmih> Mitsos101: For learning, you would be much better off writing idiomatic Haskell.
09:32:48 <EvanR> iterateWhile :: Monad m => (a -> Bool) -> m a -> m a   from monad-loops
09:32:58 <EvanR> might work
09:33:23 <EvanR> or whileM_
09:33:50 <EvanR> none of the above wins you a write-C-in-any-language contest except perhaps inline C
09:33:56 <lemmih> edwardk: Thanks.
09:34:54 <Mitsos101> lemmih: I agree, but many times I find myself unable to figure out a Haskell (functional) algorithm with the same asymptotics as a C++ (imperative) algorithm
09:36:02 <ertes> Mitsos101: this might not satisfy you, but as far as my experience goes there is always a way that is at worst worse a logarithmic factor
09:36:18 <ertes> *worse by
09:36:42 <EvanR> and the constant may make that useless, or irrelevant an effectively constant time
09:36:54 <ertes> also to be fair sometimes an imperative approach is just the best approach (e.g. some sorting algorithms)
09:37:42 <ertes> you can use those approaches in haskell, but even then they will not look much like the C/C++ variant of the same algorithm, because the way you implement control in haskell is different
09:40:55 <tsahyt> is there a library somewhere for products that have a Storable instance?
09:42:31 <ertes> tsahyt: if you need them for arrays and don't need pinned memory, there are Unbox instances for tuples with Data.Vector.Unboxed(.Mutable)
09:42:56 <lyxia> https://hackage.haskell.org/package/gstorable
09:43:57 <Mitsos101> ertes: I don't care how it looks, it just seems a bit strange that something like this can't be easily translated
09:44:10 <tsahyt> now that's a nice package to have. I wish I had known about that last summer when I spent an entire day just writing storable instances
09:44:23 <tsahyt> ertes: unboxed vectors aren't laid out in memory the way I'd need them
09:44:31 <ertes> Mitsos101: you might be underestimating the level of difference between haskell and C
09:44:47 <tsahyt> ertes: this is about having a vector of vertex information for OpenGL, e.g. Vector (Vertex3 Float, TexCoord2 Float)
09:44:50 <EvanR> Mitsos101: but... that is easily translated
09:45:05 <EvanR> and ends up being faster than your code because it doesnt need to increment 1 by 1
09:45:39 <ertes> tsahyt: check out the 'linear' library
09:45:41 <tsahyt> ertes: I noticed that when I have this, almost all information I'd need to do the binding between data and attributes is available in types, so I started working on a typeclass/family for that. and now I remembered that (,) doesn't have storable
09:45:55 <EvanR> someone else was working on a lib to do the same thing
09:46:00 <tsahyt> ertes: how would that help? vectors there are heterogeneous
09:46:02 <ertes> tsahyt: there are Storable instances for all the vector types, so you can use them with OpenGL
09:46:06 <tsahyt> homogeneous*
09:46:13 <EvanR> now who was it...
09:46:14 <ertes> tsahyt: ah
09:46:26 <tsahyt> what I need is glueing the vertex and texcoord stuff together so it's laid out one after the other in memory
09:46:28 <ertes> tsahyt: you could just use multiple buffers
09:46:38 <tsahyt> yeah but where's the fun in that :P
09:46:41 <Mitsos101> EvanR: Yes, this specific example can be easily retranslated, but it's not necessarily s += l0++; or something like that
09:46:50 <tsahyt> but I guess I'll just write a product type then
09:47:17 <EvanR> Mitsos101: sorry its the only example you gave
09:47:41 <tsahyt> on a related note, why do (,) etc not have Storable instances (provided the elements do)?
09:47:50 <ertes> tsahyt: note that with something like gstorable you need to actually study the Storable instances it generates
09:48:12 <EvanR> for line-by-line style of C++ and haskell, i dont miss the former. i think we are really talking about style here
09:49:13 <Mitsos101> EvanR: Sorry, my fault, I said "e.g. counting inversions in the subsegment [l,r] using a BIT" before, which is essentially the same approach
09:49:14 <ertes> tsahyt: things like padding might happen, if the field types ask for it
09:49:24 <ertes> (for memory alignment)
09:50:26 <ertes> tsahyt: also check out 'linear' anyway…  it has lots of utility functions for OpenGL, including things like perspective matrices and such =)
09:51:15 <ertes> and it's all readily usable with buffers and uniforms
09:52:59 <tsahyt> ertes: I've used linear several times before and quite like it. right now I'm trying to learn opengl as such. I just got sidetracked by how horrible the glVertexAttribPointer API is
09:55:44 <EvanR> tsahyt: yeah somebody in #haskell-game was working on a library which used types to straighten out the formats needed for that function
09:55:53 <EvanR> or thats one of the things their library dide
09:55:56 <EvanR> did
09:56:06 <tsahyt> do you happen to remember what library that was?
09:58:19 <EvanR> no but look at gpipe
09:58:24 <EvanR> (it might have been gpipe)
10:00:52 <tsahyt> okay thanks!
10:13:40 <edwardk> lemmih: i've been using it as a bit of a forcing function to drive me to get stuff done on open source projects
10:21:30 <lemmih> edwardk: Is it selfish of me to primarily want to do pair programming on my own projects?
10:22:13 <edwardk> lemmih: its what i do. i figure injecting fresh blood into that community is more important than being super accomodating of wanting to work on everybody else's projects
10:22:34 <edwardk> once there is a critical mass then it can figure out its mores and whatnot
10:22:55 <edwardk> as it is, its worked out to give me someone to talk to as i work on code a couple of times a week
10:23:06 <edwardk> i'm particularly bad at the handing over control part of pair programming =)
10:23:24 <edwardk> and google hangouts isn't the most collaborative editing environment
10:23:53 <dpyro> what would be the best way to define a string representation of a binary datatype?
10:24:44 <edwardk> does it need to be human readable?
10:25:22 <EvanR> the kids love base64
10:25:42 <EvanR> but by using unicode you can do way better
10:26:16 <zincy> Should I use the state monad as an abstraction for the state of a server?
10:27:33 <cocreature> zincy: depends on the server but ime servers are usually multithreaded (or will eventually need to be so even if they’re not right now) so you’re better off keeping your state in a TVar/MVar
10:28:04 <EvanR> state monad isnt an abstraction for the state of something, its an abstraction for doing short algorithms which can read and write a state
10:28:07 <zincy> Yeah the app I have written already uses Mvar
10:29:08 <zincy> So is the state monad just for enabling the composition of functions which depend on state?
10:29:25 <EvanR> doesnt have to be functions
10:29:38 <EvanR> it lets you combine state actions
10:30:19 <zincy> Why don't you just pass in and return the state with each function normally?
10:30:33 <zincy> Then use normal composition
10:30:56 <cocreature> because that can be annoying and easy to get wrong, e.g., you might accidentally return the old instead of the updated state
10:31:33 <EvanR> if you have several steps, you will have that many state variables, and you need to keep them straight. whats worse is you might have "loops" and now what
10:32:28 <EvanR> so you might be able to use State to write your handler code, but you will need to keep it somewhere between requests, like an MVar
10:32:37 <zincy> Ah ok
10:32:46 <EvanR> it being your state
10:33:20 <zincy> So if I have a type representing state just keep it to the Mvar
10:33:28 <zincy> in the context of server state
10:33:56 <EvanR> if youre using an MVar, you probably want *all* server state in that one mvar
10:33:57 <zincy> Why is it called mutable variable
10:34:05 <zincy> we dont have mutations ;/
10:34:16 <EvanR> MVar is mutable
10:34:32 <zincy> I thought all haskell code is pure
10:34:37 <EvanR> but i call it a multithreaded variable
10:34:54 <EvanR> might be aprocryphal
10:36:39 * hackage tidal-midi 0.9.10 - MIDI support for tidal  http://hackage.haskell.org/package/tidal-midi-0.9.10 (AlexMcLean)
10:37:38 <EvanR> zincy: MVars can only be accessed using IO, which is like haskell's "sin-bin" for stuff that isn't pure. Luckily, IO code is still pure, which is great
10:42:01 <zincy> So if state here is a list of clients to broadcast a msg to - readMVar state >>= broadcast msg
10:42:32 <EvanR> sure
10:42:53 <zincy> Why does MVar State need to be a monad? Is it because we don't know what its value is
10:43:07 <EvanR> its not a monad
10:43:09 <zincy> as another thread could have changed it
10:43:30 <zincy> the left hand side of bind needs to be a monad right?
10:43:40 <EvanR> you can only access it with IO actions though. because yeah they didnt know how to do it any other way :)
10:44:00 <EvanR> readMVar myMyVar is an action
10:44:10 <EvanR> IO is a monad
10:44:27 <EvanR> myMVar*
10:44:56 <zincy> so the monadic action on the left returns a monad - IO myVar
10:44:58 <zincy> right?
10:45:08 <zincy> Only after bind is called
10:45:29 <zincy> And bind has the logic to lift the value out of the monad
10:45:34 <EvanR> IO MyStateType ?
10:45:59 <EvanR> the action, when executed, yields a MyStateType
10:46:02 <zincy> Yeah thats what is returned by the expression readMVar myMvar
10:46:19 <EvanR> which you need to handle with a handler, which you provide to >>=
10:46:51 <zincy> readMVar returns an IO stateType tho
10:46:52 <EvanR> its a lot like javascript callbacks
10:47:29 <EvanR> no
10:47:38 <EvanR> yes, IO MyStateType
10:47:55 <EvanR> when executed, itll read the mvar and give you a MyStateType
10:48:15 <EvanR> the key is abstracting over this whole "when executed" this
10:48:16 <EvanR> thing
10:49:19 <zincy> When is the MyStateType lifted out of the IO monad?
10:49:20 <EvanR> getCurrentTime :: IO UTCTime, when executed, gives you the time when it is executed. its not a particular timestamp by itself. its a command
10:49:37 <EvanR> its also not a function
10:49:58 <zincy> How can it not be a function?
10:50:10 <EvanR> theres no arrow, theres no argument given...
10:50:16 <zincy> So readMVar is not a function?
10:50:24 <EvanR> its like typing `date' at the command line
10:50:29 <EvanR> :t readMVar
10:50:31 <lambdabot> error: Variable not in scope: readMVar
10:50:46 <EvanR> wtf... readMVar :: MVar a -> IO a, so yes its a function
10:51:26 <lemmih> :t Control.Concurrent.readMVar
10:51:27 <lambdabot> GHC.MVar.MVar a -> IO a
10:52:08 <EvanR> but you see applying readMVar doesnt cause the side effect of reading anything
10:52:24 <EvanR> youre just setting up a command
10:52:30 <donjoe2> hello people [20:43] <donjoe_> i am a beginner and i ll ask some questions here. hope nobody minds if the questions are silly or fluent :) [20:45] <donjoe_> First case: So we define the following: [20:45] <donjoe_> foo = 2 [20:45] <donjoe_> this has type :: Num a => a. Ok, easy enough [20:46] <donjoe_> foo a = 2 has type :: Num a => t -> a. Ok [20:47] <donjoe_> but, foo 1 = 2 has type :: (Eq a, Num a, Num a1) => a -> a1 [20:47] <donj
10:52:42 <donjoe2> sorry
10:53:10 <zincy> Dont worry, go for it
10:54:26 <zincy> So returning an IO action just gives you the means to retrieve the value inside the Mvar?
10:54:34 <donjoe2> foo = 2 ; has type :: Num a => a. Ok, easy enough
10:54:37 <donjoe2> foo a = 2 ; has type :: Num a => t -> a. Ok
10:54:41 <donjoe2> foo 1 = 2 ; has type :: (Eq a, Num a, Num a1) => a -> a1
10:54:42 <EvanR> correct
10:54:44 <donjoe2> .... wtf ... ?
10:54:51 <zincy> Thanks
10:54:56 <lemmih> donjoe2: Why is that wtf?
10:55:03 <donjoe2> for my question
10:55:11 <donjoe2> foo 1 = 2 ... its type ...
10:55:13 <donjoe2> i dont get it
10:55:26 <EvanR> zincy: the IO action is a first class value, you could put it in a container for example
10:55:27 <Tuplanolla> > let foo 1 = 2 in foo 2
10:55:30 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function foo
10:55:30 <EvanR> and use it later
10:55:31 <lemmih> donjoe2: It takes a number as an argument and returns a numer.
10:55:34 <zincy> EvanR - so how is the call to bind the actual 'command' to read the MVar?
10:55:52 <lemmih> donjoe2: So the type is 'a -> a1' where 'a' and 'a1' are numbers.
10:55:56 <zincy> sorry * not how - is
10:56:13 <EvanR> no comprende
10:56:21 <donjoe2> @lemmih: what about (Eq a, Num a, Num a1) ?
10:56:21 <lambdabot> Unknown command, try @list
10:56:25 <donjoe2> lemmih: what about (Eq a, Num a, Num a1) ?
10:56:47 <donjoe2> why Eq ?
10:56:49 <zincy> How is the returned IO action evaluated
10:56:55 <EvanR> executed?
10:56:57 <zincy> call to bind?
10:56:59 <zincy> yeah
10:57:01 <zincy> execute
10:57:03 <zincy> d
10:57:13 <EvanR> main = launchMissiles
10:57:24 <EvanR> if you run the program, launchMissiles will be executed
10:57:29 <EvanR> if you dont, it wont
10:57:35 <lemmih> donjoe2: Those are class constraints. They're a bit advanced so I would suggest learning other parts of Haskell until you're more comfortable.
10:58:16 <zincy> So before execution IO actions are first class values
10:58:17 <Ariakenom> donjoe2, foo 1 = 2 is an equation where the argument is equal to 1. equal thus Eq
10:58:25 <Tuplanolla> Your `foo 1 = 2` translates to `foo x = if x == 1 then 2 else error "Non-exhaustive patterns in function foo"`, donjoe2.
10:58:47 <EvanR> also when the time comes to execute them, they are values. that is how the runtime system knows what to do
10:59:13 <EvanR> though we are now mixing a couple different vaguely defined notions of value
10:59:22 <EvanR> expressions vs runtime object
10:59:31 <zincy> the run time system doesnt care about haskell values though right
10:59:52 <zincy> since its lower level
11:00:07 <EvanR> sort of, you can imagine the runtime system knowing about the structure of your ADTs, but not the source names or any types whatsoever
11:00:43 <EvanR> Ints have honest to god machine ints in them
11:01:07 <zincy> Im confused about why IO has a type variable
11:01:20 <EvanR> tells you what the action yields
11:01:24 <donjoe2> I think I got it.
11:01:26 <zincy> Would IO SomeType just mean that it will on execution be of the someType
11:01:34 <zincy> ah ok
11:01:35 <EvanR> no
11:01:59 <EvanR> you get SomeType back
11:02:30 <zincy> yeah so evaluate IO action which is IO SomeType and the action will yield a value of SomeType
11:02:56 <EvanR> yes and if SomeType is not (), then youll have to do something with it before you got a complete program
11:02:59 <EvanR> since main :: IO ()
11:03:10 <zincy> ah
11:03:25 <EvanR> which is why you need >>=
11:03:37 <zincy> So IO () means this function is an IO action which yields nothing
11:03:49 <EvanR> effectively nothing. () has no information
11:03:52 <donjoe2> I asked because I saw that "fact 1 = 1;  fact n = n * (fact (n - 1))" has type :: (Eq a, Num a) => a -> a, while I was expecting only :: Num a => a -> a
11:04:47 <lemmih> donjoe2: Imagine: fact n = if n == 1 then 1 else n * fact (n-1)
11:04:48 <EvanR> IO () actions are like, fire-and-forget actions. you dont need to be there to see what it returns
11:04:48 <zincy> why do we need >>= in this context? Is it because if our program relies on the result of an IO action >>= allows us to access the result?
11:05:00 <EvanR> since it will be () and useless
11:05:07 <lemmih> donjoe2: That function uses '==' which requires the 'Eq' constraint.
11:05:11 <Tuplanolla> Numbers are kind of silly in how you need equality to pattern match on them.
11:06:00 <EvanR> zincy: look at the type of >>=, it lets you build more complex actions from simpler ones and a handler
11:06:05 <donjoe2> lemmih: so anytime patter matching is included, Eq is used?
11:06:21 <klv> some (equivalent, almost identical) list comprehensions seem to make a larger memory footprint than a filter () [] counterpart. is this correct?
11:06:25 <lemmih> donjoe2: No, just pattern matching on literals.
11:06:40 <donjoe2> I see. thx
11:07:10 <zincy> So >>= means we can compose IO actions?
11:07:28 <EvanR> sort of yes
11:07:42 <EvanR> its called sequencing
11:08:28 <zincy> This brings us full circle
11:08:39 <EvanR> readMVar v >>= \x -> print x
11:08:40 <zincy>   forever $ do    { msg <- WS.receiveData conn ;    readMVar state >>= broadcast msg }
11:09:18 <EvanR> not do notation desugars to >>= \_ ->
11:09:23 <EvanR> note*
11:09:36 <zincy> So in both uses of bind here - both args result in an IO action
11:10:00 <EvanR> yeah, and they are being sequenced
11:10:17 <zincy> Thanks
11:10:28 <zincy> This has been enlightening
11:11:06 <EvanR> and forever <all that> is an IO action
11:11:09 <zincy> I think the key is to remember that an IO action is a first class value which will yield some type on execution
11:11:22 <EvanR> ^
11:11:34 <EvanR> you graduate haskell 1st grade
11:11:42 <zincy> :D thanks
11:11:59 <Cheery> I did read about dictionary passing, but there's one detail that I ended up staring at
11:12:14 <zincy> Im gonna go and build some stuff now, speak soon
11:12:32 <Cheery> if I got \x -> (x+1, x+2, x+3)
11:12:54 <Cheery> it could be that I would have to pass three dictionaries
11:13:25 <Cheery> but how does the type end up being just? Num t => t -> (t, t, t)
11:13:39 <jle`> Cheery: you don't pass three different dictionaries
11:13:39 <lyxia> The compiler simplifies constraints
11:13:46 <Cheery> rather than.. (Num t, Num t, Num t) =>
11:13:53 <EvanR> > (\x -> (x+1, x+2, x+3) 2 :: (Int,Integer,Float)
11:13:55 <lambdabot>  <hint>:1:48: error:
11:13:55 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:14:04 <EvanR> > (\x -> (x+1, x+2, x+3)) 2 :: (Int,Integer,Float)
11:14:06 <lambdabot>  error:
11:14:06 <lambdabot>      • Couldn't match type ‘Int’ with ‘Integer’
11:14:06 <lambdabot>        Expected type: (Int, Integer, Float)
11:14:14 <EvanR> you cant get 3 dictionaries after all
11:14:27 <EvanR> since x has one type
11:14:33 <jle`> Cheery: note that dictionary passing is an implementation detail
11:14:50 <jle`> and Num t => t -> (t, t, t) is just an extended hindley milner
11:14:55 <jle`> it's about type checking
11:15:35 <Cheery> any papers describing the constraint simplification?
11:15:39 <EvanR> did you want (Num a, Num b, Num c) => Integer -> (a,b,c) ?
11:16:09 <jle`> Cheery: https://kseo.github.io/posts/2017-01-02-hindley-milner-inference-with-constraints.html
11:16:34 <Cheery> EvanR: given the expression, that would fail to make sense. the arguments and return type for (+) must be equal.
11:16:50 <EvanR> youre right
11:16:54 <EvanR> nvm
11:17:23 <keegans> hello, i'm trying to get the list of cookies out of the CookieJar in Network.HTTP as seen here : https://hackage.haskell.org/package/http-client-0.1.0.0/docs/src/Network-HTTP-Client-Types.html#CookieJar
11:17:30 <Cheery> jle`: thanks. that paper appeared earlier, but I started reading from the wrong end.
11:17:37 <keegans> looks like a record with an expose field that holds the cookies -- but i can't call expose on it for some reason
11:17:49 <Cheery> (did a search and studied the subject before coming up here)
11:18:34 <jle`> but yeah, be careful not to confuse dictionary passing (an implementation of typeclasses) with the actual concept of typeclasses and their typechecking
11:18:50 <lemmih> keegans: Did you import the module?
11:19:14 <Cheery> jle`: I'm studying how these ideas transform when brought into subtyped ML
11:19:27 <keegans> lemmih: yes, i think i figured it out though
11:19:34 <keegans> it seems destroyCookieJar does what i want
11:19:42 <keegans> poorly named imo i immediately looked over it
11:20:11 <Cheery> I also got http://okmij.org/ftp/tagless-final/index.html in the reading list.
11:21:23 <Cheery> I would be kind of happy if I discover some sort of setting that supports computer algebra.
11:21:43 <Cheery> mostly I care about polynomials, autodifferentiators, complex numbers/quaternions and linear algebra.
11:22:26 <Cheery> but kind of realised it'd save a lot of effort if there was a nice way to implement computer algebra on top of a type-inferred language.
11:23:50 <cocreature> keegans: the name probably comes from “destructor” but I agree it is confusing
11:24:29 <keegans> cocreature: :D it works though
11:24:37 <keegans> i guess it means smash the jar
11:24:40 <keegans> to get all the cookies
11:24:44 <Cheery> I've thought that Haskell's typeclasses would have been only "halfway there"
11:25:43 <Cheery> but now it looks like they're almost capable of producing statically typed computer algebra systems that'd still be friendly for user to use.
11:25:52 <Tuplanolla> Have you tried Axiom, the cas, Cheery?
11:26:20 <Cheery> Tuplanolla: coming from that direction, did studies on it early this year.
11:26:37 <Tuplanolla> Does it have a working user interface yet?
11:27:24 <cocreature> keegans: if you have something like "data T = C { getV :: V }", "C" is called “constructor” and "getV" is often called “destructor”. "createCookieJar" and "destroyCookieJar" are wrappers around the constructor and destructor so I would assume that the names are chosen for that reason
11:28:33 <Cheery> Tuplanolla: well.. I managed to try it out. But I'd guess it's not friendly to an ordinary user anymore.
11:29:29 <Tuplanolla> I tried to use it some years ago, but it kept crashing on me.
11:29:48 <cocreature> interesting, I had never even heard of axiom
11:42:03 <ackthet> is there a reason kind is represented by *
11:43:01 <dsal> Asterisks are very kind.
11:43:57 <blankhart> i think of it as "any type" (like regular expression) as opposed to a specific kind Bool (consisting of only types True and False)
11:44:09 <jle`> ackthet: kind is not represented by *, but the kind of inhabitable types is
11:44:51 <MarcelineVQ> it can be :(
11:45:08 <jle`> and yeah i always thought of it as vaguely evoking a wildcard, even though it doesn't really behave like one
11:45:09 <ackthet> so * represents any type
11:45:14 <jle`> not any type
11:45:20 <jle`> Maybe :: * -> *
11:45:30 <jle`> Either :: * -> * -> *
11:45:36 <jle`> but Bool :: *
11:46:19 <blankhart> right, as a type; to be clear in my example Bool was a kind (as with DataKinds)
11:47:30 <jle`> ackthet: kinds are the "type" of types, to aid in typechecking what is a valid type
11:47:48 <jle`> it's how we can say that you can't do something like 'Maybe Either'
11:48:07 <jle`> * is the kind for things like Int, Bool, (), Maybe Double, Either String Float
11:48:10 <ackthet> kindchecker
11:48:19 <jle`> yeah, 'kindchecking' :)
11:49:11 <ongy> kindly checking the kinds
11:49:20 <jle`> would you kindly please
11:49:52 <jle`> i don't like to use * anymore though
11:49:54 <ackthet> bitemyapp needs to work 'would you kindly' references into ch11
11:50:02 <jle`> if you import Data.Kind, then you can use 'Type' as a kind
11:50:08 <jle`> Maybe :: Type -> Type
11:51:56 <jle`> * is kind of weird as a name because it breaks the normal operator vs prefix identifier rules in haskell
11:52:43 <jle`> it even breaks the normal rules of constructor vs. non-constructor type operators
11:52:58 <jle`> and i can't imagine how much more complicated it makes parsing, heh
11:57:22 <ackthet> >kind of weird
11:57:24 <ackthet> good one
11:57:57 <ackthet> but yeah, its a bit odd, i think Type -> Type makes a bit more sense I guess
11:58:06 <jle`> ty
11:58:33 <ackthet> thanks
11:59:17 <Cale> It's kind of a remnant of the syntax of Miranda in a way. It used various numbers of *'s as type variables
11:59:24 <blankhart> is a "type constructor" of kind * -> * also correctly referred to as a "type"? i hadn't really thought about this before
11:59:48 <Cale> Everything at the type level is usually referred to as a type
12:00:33 <Cale> The thing which distinguishes type constructors is that their names typically start with an uppercase letter or colon, and it's possible to match against them with instances.
12:01:03 <blankhart> i see.  but does Data.Kind's "Type" only refer to simple types because it aliases kind *?
12:01:14 <ackthet> (I've never seen a type start with a colon)
12:01:51 <Cale> ackthet: That happens for infix type constructors
12:02:31 <Cale> Though I suppose now with TypeOperators that restriction has been lifted
12:02:39 <ackthet> ahh
12:03:01 <Cale> (and we gave up the ability to have infix type variables to get it...)
12:03:09 * hackage language-ecmascript 0.18 - JavaScript parser and pretty-printer library  http://hackage.haskell.org/package/language-ecmascript-0.18 (AndreyChudnov)
12:05:32 <nshepperd> :k GHC.Prim.Int#
12:05:33 <lambdabot> TYPE 'GHC.Types.IntRep
12:05:43 <nshepperd> hmm, this is new
12:06:27 <DrAwesomeClaws> im way too drunk to be here right now
12:07:05 <nshepperd> ah, this is the liftedness polymorphism stuff
12:07:18 <jle`> 'levity'
12:07:27 <nshepperd> type * = TYPE 'LiftedRep
12:08:56 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#levity-polymorphism
12:11:31 <nshepperd> :k (->)
12:11:32 <lambdabot> TYPE q -> TYPE r -> *
12:11:35 <nshepperd> neat
12:12:04 <vin-ivar> lc
12:23:37 <nshepperd> so now we can have Num instances for Int#, I guess
12:24:18 <nshepperd> so that I can pretend I'm writing SSA assembler
12:43:13 <orbisvicis> I'm using (Integral a) which becomes GHC.Word.Word32 and GHC.Word.Int32. Is there some extension to allow both simultaneously without fromIntegral ?
12:45:08 <manek> lyxia, ertes, [exa]: thank you for answering my question with the bind2, bind3 functions. It helped a lot. I wanted to thank you earlier but I was traveling with train and I lost my connetion!
12:45:41 <zincy> Is a sum type of record types a bad idea?
12:45:58 <manek> zincy: why it would be bad idea?
12:46:28 <zincy> I'm not sure I just remember reading somewhere it was
12:46:28 <lyxia> orbisvicis: can you paste an example of code you want to generalize
12:46:37 <cocreature> manek: because it can lead to partial record selectors
12:47:36 <zincy> cocreature: What is a good alternative?
12:48:37 <cocreature> zincy: one option is to use "data A = A { a :: Int }; data B = B { b :: Int }; data C = CA A | CB B" instead of "data C = A { a :: Int } | B { b :: Int }"
12:48:49 <cocreature> but that can often be rather annoying to use
12:49:39 * hackage csound-expression 5.3.0 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-5.3.0 (AntonKholomiov)
12:49:56 <cocreature> another option is to only use pattern matching and not use record updates and record selectors for these types but it’s easy to accidentally use them anyway
12:50:15 <orbisvicis> lyxia: http://lpaste.net/364806
12:51:51 <manek> cocreature: Oh, if you want the selectors then what I do always is `data A = A {_fooa :: Int, _bara :: Int}; data B = B {_foob :: Int, _barb :: Int }; data S = SA A | SB B` then its safe and its the best solution in 99% of cases
12:52:14 <zincy> Whats SA?
12:52:19 <zincy> and SB?
12:52:34 <zincy> Just an arbritrary name for data constructor?
12:53:09 * hackage data-diverse-lens 3.0.0.2 - Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which  http://hackage.haskell.org/package/data-diverse-lens-3.0.0.2 (louispan)
12:53:09 <cocreature> manek: right that’s the first solution I showed but it is often annoying to have to introduce more layers of nesting
12:53:48 <orbisvicis> oh example, hmm surprisingly, this *does* work:
12:53:54 <orbisvicis> let {x = truncate 4.1; y=x::GHC.Word.Word32; z=x::GHC.Int.Int32}
12:54:30 <lyxia> sounds like NoMonomorphismRestriction kicked in
12:54:50 <lyxia> why are Border and Rectangle not using the same types
12:55:10 <manek> cocreature: but yeah, some automation here would be awesome
12:55:58 <cocreature> I just want a way to disable record selectors and record updates while still being able to use record fields in pattern matches and on constructors and probably most importantly for purposes of documentation
12:57:49 <orbisvicis> lyxia: Border could use GHC.Int.Int32 also used by Graphics.X11.Xlib.Types.Rectangle but GHC.Int.Int32 seemed too low-level. Should I use Int32 in Border ?
12:58:27 <orbisvicis> especially since Border is exported by the module
12:59:47 <lyxia> I'm not sure actually.
13:00:10 <cocreature> Int32 doesn’t seem particularly low-level
13:00:51 <orbisvicis> it's not a C type ?
13:00:54 <geekosaur> I wonder if that means they're expectimg border to be a rectangle of some kind instead of X11's notion of it being a width in pixels associated with the window rectangle
13:01:27 <geekosaur> orbisvicis, it's a CInt which is a type synonym for Int32
13:01:32 <lyxia> orbisvicis: BTW these should be imported via Data.Word and Data.Int
13:01:43 <geekosaur> which is why it's showing the internal type (GHC.Int.Int32)
13:01:56 <gazanga> in "Similarly, verify that the number of expressions that evaluate successfully increases
13:01:57 <gazanga> to 10,839,369 if the numeric domain is generalised to arbitrary integers. Hint: modify
13:01:57 <gazanga> the definition of valid ." what is arbitrary integers?
13:02:08 <cocreature> CInt is not a type synonym, it’s a newtype wrapper
13:03:27 <gazanga> or what is the difference between integer and arbitrary one
13:03:31 <orbisvicis> lyxia: btw it was caused by MonomorphismRestriction
13:03:47 <geekosaur> gazanga, it's relaxing whatever constraint is on the original, which nobody can know just from what you have said so far
13:04:37 <gazanga> geekosaur: please wait, more information is coming :-)
13:04:47 <geekosaur> presumably "valid" is setting some limit on what values are permitted, and it's telling you to remove the limit
13:06:00 <zincy> cocreature - does the use of lenses get around the issue of partial record selectors?
13:07:17 <cocreature> zincy: no
13:07:17 <gazanga> geekosaur: here it is http://lpaste.net/364807
13:08:19 <geekosaur> gazanga, as I said. "arbitrary" there means any integer, as opposed to some specific range of integers as specified by the original program
13:08:38 <gazanga> Ok thanks geekosaur
13:08:50 <cocreature> "valid Sub x y = x > y" could suggest that it’s currently restricted to non-negative integers
13:08:54 <zincy> What problem do lenses solve? Inconvenience of field updates?
13:09:10 <geekosaur> also see "Div"
13:09:25 <geekosaur> but that one would be harder, potentially (not seeing the rest of the program)
13:09:50 <gazanga> yes so i need to change from Int to Double maybe
13:10:22 <gazanga> i have a target number (the result) so i'll see if i'm right :-)
13:10:22 <cocreature> I highly doubt that, it says you’re supposed to generalise it to arbitrary _integers_
13:10:27 <cocreature> not Doubles
13:10:33 <nshepperd> does makeLenses not do the right thing on sum types of record fields?
13:10:38 <gazanga> ahh ok so jjust negatives
13:10:51 <gazanga> i will try :)
13:11:13 <cocreature> nshepperd: what’s the right thing there? not generate anything?
13:11:35 <nshepperd> I would expect it to generate a prism for the field that is only in one branch of the sum
13:11:45 <nshepperd> or would that be a traversal...
13:11:56 <cocreature> you only get a prism if there is only one field for that constructor
13:12:00 <cocreature> otherwise you can’t review
13:12:11 <nshepperd> yeah, traversal, if there are multiple fields
13:44:01 <ertes> tsahyt: everything about OpenGL is horrible…  it's not a .NET-network-API-level atrocity, but it's still horrible
13:44:27 <EvanR> i cant wait until vulkan fixes it all!
13:45:28 <ertes> vulkan is expensive (much more code), but way better designed in almost every respect…  and you can already use it; i think there is even a gl-style haskell binding =)
13:59:46 <occulti> Hi
14:16:21 <drownedinmonads> I have a monad of type IO (StateT PureMT (ReaderT Context Render) a) and I would like to use ask in it
14:16:30 <drownedinmonads> I can't figure out the types to get ask to work though
14:16:37 <drownedinmonads> any pointers?
14:17:46 <geekosaur> sounds like you missed a bind somewhere
14:17:47 <jle`> drownedinmonads: that's not quite a monad
14:18:00 <geekosaur> can you show the code in question?
14:18:55 <drownedinmonads> geekosaur: yes 1s
14:19:01 <drownedinmonads> jle`: what do you mean?
14:19:38 <jle`> ask :: MonadReader r m => m r, or ReaderT r m r, depending on if you're using transformers or mtl
14:19:55 <jle`> it's an action for monad 'm', but what you gave isn't something that fits that shape
14:20:47 <drownedinmonads> geekosaur: https://hastebin.com/dupizagevi.hs
14:20:47 <jle`> but yeah, posting the code will really help clarify
14:21:20 <jle`> is this a toy example?  what are you trying to actually do?
14:21:26 <jle`> but yeah, IO has no MonadReader instance
14:21:44 <geekosaur> that's not enough context. the real question is why the value is still wrapped in IO (...)
14:21:54 <drownedinmonads> it's just the minimal example; I'd like to use ctx in an IO action
14:21:55 <geekosaur> which suggests you missed something somewhere leading up to this
14:22:01 <jle`> drownedinmonads: in real life you probably are never going to get something like IO (StateT PureMT (ReaderT Context Reader) a)
14:22:29 <jle`> drownedinmonads: can you show how you get such a value?
14:22:42 <jle`> how did it show up in your code?
14:23:00 <jle`> it's not really something that is supposed to happen
14:23:05 <drownedinmonads> tl;dr I'm trying to create a texture on gpu and need the context to know the dimensions to allocate
14:23:10 <drownedinmonads> I'm writing a renderere
14:23:42 <drownedinmonads> but if you think this is awkward af it probably is and I should probably rethink this
14:24:06 <jle`> drownedinmonads: why don't you work with StateT PureMT (ReaderT Context Reader) a instaed
14:24:14 <jle`> since *that* has a MonadReader instance for sure
14:24:34 <drownedinmonads> the texture allocation is IO is all
14:25:28 <drownedinmonads> oh but I think I can put the IO as a
14:26:56 <geekosaur> I think we need to see the code that got you here
14:27:07 <geekosaur> it feels like you did a let ... = ... where you needed to do ... <- ...
14:29:20 <drownedinmonads> I have waaay too much code for that. Thank you for the advice jle` ! I will try to revise this at a higher level.
14:29:52 <Cale> wait what?
14:29:55 <Cale> oh
14:30:44 <Cale> drownedinmonads: btw, I think you messed up your description of what your monad was perhaps
14:31:13 <Cale> drownedinmonads: If your types actually have IO on the outside like that, then you won't be able to ask, because you're writing an IO action which just happens to return an action in some other monad.
14:31:59 <Cale> drownedinmonads: Perhaps you meant to have something like  StateT PureMT (ReaderT (Context Render) IO) a ?
14:32:34 <Cale> drownedinmonads: You can use liftIO to turn IO actions into actions of that monad.
14:32:45 <iqubic> What is the point of fix? Why do we need a thing of type:
14:32:52 <iqubic> :t fix
14:32:54 <lambdabot> (a -> a) -> a
14:33:30 <drownedinmonads> Cale: ty I will look into liftIO
14:34:29 <iqubic> Shouldn't liftIO just do the "right thing"™?
14:36:17 <Garmy> iqubic: You can use fix for recursion with lambda expressions, for example.
14:36:23 <Cale> iqubic: It sort of packages up what recursion is.
14:36:50 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
14:36:53 <geekosaur> iqubic, fix is a form of implicit recursion
14:36:55 <Cale> is the factorial function, for example
14:37:17 <Cale> > fix (\xs -> 1:xs)
14:37:20 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:38:57 <Cale> iqubic: In practice, it can sometimes be convenient when you want to loop inside a do-block
14:39:05 <Cale> Where you might've done something like
14:39:17 <Cale> let loop n = do ... loop (n-1) ...
14:39:23 <Cale> loop k
14:39:35 <Cale> you can instead write
14:40:09 <Cale> er, well, that's still awkward because you have an argument :D
14:40:30 <Cale> Let's say you don't, so it's more like
14:40:46 <Cale> let loop = do ... loop ...
14:40:47 <iqubic> How do you loop with fix?
14:40:48 <Cale> loop
14:40:53 <Cale> Then you can write:
14:40:57 <Cale> fix $ \loop -> do
14:41:00 <Cale>  ... loop ...
14:41:20 <iqubic> what would that do?
14:41:47 <Cale> It would be the same as the let above, where you recursively define loop, and then use it immediately
14:41:58 <Cale> (I'm assuming this is inside a do-block)
14:42:15 <Garmy> Cale: Why awkward? Your factorial has an argument too
14:42:37 <Cale> Garmy: Only syntactically, because there will be a do-block and then you have an argument way at the end
14:42:58 <Cale> You might want to flip fix in that case
14:43:03 <Cale> (though that's hard to read)
14:43:28 <Garmy> "flip fix 5 (\f n -> …)" - heh
14:43:34 <Cale> yeah
14:48:57 <EvanR> theres the ?? trick
14:49:27 <EvanR> ive got it lying around somewhere
14:50:01 <keegans> https://pastebin.com/7YLDriMN <- how can I avoid this?
14:50:09 <keegans> also any other suggestions are welcome :D
14:50:55 <iqubic> Why is that bad?
14:51:36 <EvanR> let (??) = flip fmap in fix ?? 5 ?? (\i loop -> ...)
14:51:58 <keegans> iqubic: oh, i just assumed that you weren't supposed to do that
14:52:10 <keegans> but ok
14:52:20 <EvanR> fix ?? 5 ?? 'z' ?? (\i c loop -> ...)
14:52:45 <EvanR> couldnt tell you how it works
14:52:46 <iqubic> :t (??)
14:52:48 <lambdabot> Functor f => f (a -> b) -> a -> f b
14:53:07 <Garmy> EvanR: Uses the functor instance for ((->) a)?
14:53:11 <EvanR> right
14:53:21 <EvanR> very cute
14:55:14 <EvanR> indeed, (??) = flip (.)
14:56:03 <EvanR> i find it a bit miraculous the precedence works out
14:58:58 <MarcelineVQ> keegans: there are things like this that avoid the conversion  https://hackage.haskell.org/package/MissingH-1.4.0.1/docs/Data-String-Utils.html#v:strip  idk if it's actually better than making the Text or not
15:01:53 <keegans> MarcelineVQ: i've figured out that i can use `remove s = filter (\x -> x /= '\n' && x /= '\r' && x /= '\t') s` instead
15:01:56 <keegans> for this specific use case
15:05:15 <byorgey> keegans: that can be simplified to   remove = filter (`notElem` "\n\r\t")
15:05:46 <keegans> byorgey: nice!
15:05:48 <keegans> thanks
15:06:03 <keegans> is there a nice way to do this ? : `map (\x -> if x == '\r' then ' ' else x) s`
15:06:10 <keegans> it just looks for a \r and replaces it with a space
15:06:31 <keegans> unfortunately i can't do `replace . remove` anymore because it will do a remove before a replace?
15:06:39 <keegans> switching the composition around doesn't seem to fix it
15:06:41 <keegans> strange
15:06:59 <Garmy> EvanR: Now I don't understand how (??) works any more
15:07:07 <byorgey> keegans: the order should make a difference
15:07:25 <byorgey> keegans: I can't think of a nicer way to replace \r with space
15:07:34 <EvanR> haha
15:07:54 <EvanR> your saturday haskell puzzler brought to you by
15:08:02 <Garmy> Because the values themselves are not inside any functor or functions.
15:08:42 <Garmy> It really looks like a ((->) a) problem though, especially with the ordering of the arguments in the lambda
15:10:55 <Garmy> Also, how would you give "loop" new arguments inside the lambda?
15:11:50 <keegans> byorgey: how do I type `strip = filter (`notElem` "\n\r\t")` ? i'm getting an error message that says the argument needs to be typed, it's very confusing
15:12:06 <EvanR> Garmy: well, if i did it right, youd just give it two arguments
15:12:17 <keegans> https://pastebin.com/1BE5A4yi
15:12:35 <keegans> in a repl it works fine and the type is String -> String as I would expec
15:12:42 <keegans> typing it to String -> String doesn't solve anything
15:12:43 <geekosaur> keegans, first thing to suspect there is always monomorphism restriction
15:13:27 <byorgey> keegans: do you have the  OverloadedStrings extension turned on?
15:13:29 <keegans> geekosaur: right, so how do i type it ?
15:13:33 <keegans> yes, i do
15:13:34 <EvanR> Garmy: what i gave you was wrong. but there is something similar i am still looking for
15:13:57 <Garmy> EvanR: Yes, I just tested it :/
15:13:58 <byorgey> keegans: that's why then.  Try using   ("\n\r\t" :: String)
15:14:14 <aje> moo
15:14:21 <geekosaur> simplest here is to specify the type of string you're working with, yes
15:14:35 <keegans> oh i am so stupid i wrote `(`notElem` "\n\r\t" :: String)`
15:14:39 <keegans> lol
15:14:39 <aje> any cardano devs around?
15:14:52 <byorgey> keegans: the problem is that with OverloadedStrings enabled, "\n\r\t" could have any type which is an instance of IsString, and notElem takes any Foldable type as input, and GHC can't tell what type you want in between
15:16:23 <keegans> yeah that makes sense
15:20:20 <EvanR> @let (??) = flip
15:20:22 <lambdabot>  Defined.
15:20:50 <EvanR> > fix ?? 'c' ?? "str" $ (\loop x y -> y)
15:20:52 <lambdabot>  error:
15:20:52 <lambdabot>      Ambiguous occurrence ‘??’
15:20:52 <lambdabot>      It could refer to either ‘Lens.??’,
15:21:08 <EvanR> @let (??-) = flip
15:21:10 <lambdabot>  Defined.
15:21:15 <EvanR> > fix ??- 'c' ??- "str" $ (\loop x y -> y)
15:21:18 <lambdabot>  "str"
15:21:28 <EvanR> :t fix ??- 'c' ??- "str" $ (\loop x y -> loop x y)
15:21:29 <lambdabot> c
15:22:06 <EvanR> Garmy: supposed to be flip, not flip (.), and gotta end with $
15:22:41 <Garmy> I see.
15:23:37 <bbarker> of all the Haskell tutorials, is there one that might be particularly good for someone who already knows some functional programming (coming from Scala)?
15:23:53 <EvanR> @where gentle introduction
15:23:53 <lambdabot> http://www.haskell.org/tutorial/
15:24:17 <bbarker> EvanR, thanks for the suggestion!
15:24:24 <Tuplanolla> If you already know all the tricks and only want a tour, LYH might be for you, bbarker.
15:24:39 <EvanR> i kind of recommend that to anybody who knows programming
15:24:52 <EvanR> i liked it, coming from C and PHP
15:24:59 <ertes> bbarker: well, honestly any tutorial will do, because even among functional languages haskell is very different
15:25:07 <Garmy> EvanR: And now I understand :)
15:25:15 <EvanR> lol
15:25:21 <Welkin> bbarker: most people who think they know functional programming don't know anything about it at all
15:25:23 <ertes> bbarker: also i think scala isn't really that much of an FP language
15:25:26 <Welkin> for most definitions
15:25:36 <EvanR> most people dont know shit
15:25:39 <Welkin> scala is nothing like haskell
15:25:42 <Welkin> unless you used scalaz
15:25:47 * EvanR throws the mic
15:26:07 <bbarker> yeah it lacks purity; I do use Cats, some - hoping to use it more (Cats is similar to Scalaz I gather)
15:26:07 <ertes> EvanR, Welkin: you two would make a great old-school hip-hop band =)
15:26:29 <EvanR> scala zed <3
15:26:45 <ertes> bbarker: what scala really lacks in relation to haskell is laziness and IO
15:26:53 <ertes> lack of purity can be compensated
15:29:04 <shapr> I'll really love laziness when I get around to that.
15:29:08 <bbarker> it has some laziness (lazy val and lazily evaluated collections, in some cases), but yeah I don't know haskell, so maybe you mean something else. Neither Idris nor Scala are lazy by default, but I haven't heard many complaints about Idris (though it doesn't have many users)
15:29:18 <woodson> hey guys I am trying to put a break on a specific line in ghci but I always get "No breakpoints found at that location."
15:29:29 <woodson> anyone might have an idea why ?
15:29:38 <woodson> I also imoorted the file in ghci
15:30:05 <ertes> bbarker: lack of laziness is probably one of the primary reasons i'll never switch to idris
15:30:06 <bbarker> I hadn't really associated the notion of laziness with the notion of functional thought, I guess ... thoug there is certainly some correlation of the feature sets in languages
15:30:12 <EvanR> i complain about idris
15:30:16 <ertes> bbarker: or rather it not being default
15:30:38 <ertes> bbarker: laziness really changes your style of programming
15:30:39 <EvanR> for instance to write a sum you have to do accumulating parameters!
15:30:54 <ertes> bbarker: in fact i have trouble programming in languages that aren't lazy by default
15:30:59 <Welkin> ertes: lol, it's true
15:31:11 <bbarker> that might be bad, I already get sad when I can't program in Scala
15:31:14 <bbarker> =P
15:31:18 <Welkin> when I tried to write a fibonacci generator in purescript, I thought "why doesn't this work!"
15:31:21 <Welkin> No laziness!
15:31:26 <Welkin> it's one line in haskell
15:31:37 <ertes> bbarker: pick up any book/tutorial you like…  if you're already familiar with something, you can always just skip the section
15:31:43 <Welkin> I just get so used to everything being lazy be default
15:31:46 <Welkin> that I don't think about it
15:31:53 <EvanR> its easy to get eager behavior when you start with laziness, but not really the other way around
15:31:56 <Welkin> and in other languages it is a huge pain to make anything lazy
15:32:32 <bbarker> ok, well thanks for the suggestions and the pointers. I agree laziness has been one of the few features in Scala that has actually given me bad memories - it isn't great there.
15:32:39 <ertes> bbarker: personally i recommend CIS 194
15:32:41 <ertes> @where cis194
15:32:41 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
15:32:44 <paf31> Using lazy lists you should only have to defer the outermost cons
15:34:02 <bbarker> Welkin, yeah that makes sense
15:36:28 <Welkin> bbarker: didn't get enough excitement from the price is right, eh?
15:36:32 <Welkin> now you want to try haskell
15:36:38 <shapr> Welkin: what?
15:36:46 <Welkin> o.o
15:36:48 <Welkin> bob barker
15:36:52 <shapr> oh
15:36:56 * Clint twitches.
15:36:57 <EvanR> lol
15:37:10 <Welkin> remember to get your pets spayed or neutered!
15:37:21 * shapr starts reading cardano
15:37:51 <centril> In the Types as Propositions POV, where does GHC.Constraint come in - likewise with the LambdaCube...
15:37:59 <centril> ?
15:39:00 <EvanR> constraints are like predicates parameterize by types
15:39:06 <ertes> centril: Constraint is haskell-specific…  most proof assistants use a more explicit form of implicit information passing
15:39:38 <EvanR> you have Num Int, but not Num Char (usually)
15:39:51 <EvanR> its like a judgment
15:40:03 <ertes> centril: in type theory Constraint would just be Type, and something like Num would be a regular product type that is implicitly passed to functions by the compiler
15:40:16 <centril> ertes: sure, implicit arguments a la Agda & Idris..?
15:40:29 <ertes> centril: yeah (though idris has a class system, too)
15:40:36 <centril> ertes: sure
15:40:44 <EvanR> except instances must be unique, unless those proof assistants
15:40:48 <EvanR> unlike*
15:40:55 <ertes> centril: classes completely disappear on their way to the core language, and they are replaced by explicit dictionary passing
15:40:58 <EvanR> and unlike idris
15:41:34 <Arcaelyx> centril: Oh hai
15:41:50 <ertes> centril: where a "(Monoid A) dictionary" is really just a value of type (Monoid A), where:  data Monoid a = Monoid { mappend :: a -> a -> a, mempty :: a }
15:41:52 <EvanR> which makes it possible to auto prove or disprove the constraint
15:41:59 <centril> ertes: sure sure; I know that =)  but there is no deeper thing about Constraints being some sort of 3. to 1. values, and 2. types
15:42:12 <centril> ?
15:42:25 <ertes> centril: not really…  they can be expressed in terms of the core language, and there you'll find nothing special
15:42:52 <EvanR> but propositions as types has nothing to do with runtime implementation ...
15:43:01 <EvanR> why are we talking about dictionary passing
15:43:29 <centril> EvanR: mmh yeah -- that's my thinking also
15:43:48 <ertes> because type theory has nothing of that sort…  a "constraint" in type theory is just another premise
15:44:20 <ertes> your proof assistant might provide a convenience feature like haskell's class system, but there is no TT counterpart
15:44:34 <centril> ertes: how do you express coherence in core tho?
15:44:55 <EvanR> if "something has type T" is  a judgment, you can see "something has instance for C" has a second universe of judgments available in haskell, which can also be auto proven or disproven like typing can
15:45:23 <ertes> centril: haskell-style coherence is not something that can be enforced formally
15:46:14 <centril> ertes: why is that? Rust does the same here also
15:46:18 <centril> Arcaelyx: hai!
15:46:51 <ertes> centril: consider that just importing a module with an empty import list can cause compilation to fail
15:47:13 <ertes> … because of the open world principle
15:47:53 <ertes> how would you formally enforce no overlaps without basically implementing TT within TT?
15:48:11 <centril> ertes: TT refers to haskell core?
15:48:17 <ertes> TT = type theory
15:48:21 <centril> oh
15:48:26 <Welkin> it's not a crying face?
15:48:37 <centril> ertes: I haven't thought about it deeply, but interesting question.
15:49:24 <ertes> centril: another aspect is that it's simply not necessary…  classes are a convenience feature, and they're probably better handled that way
15:49:44 <centril> ertes: that makes sense
15:49:57 <centril> ertes: on a separate note... I forgot if Haskell does monomorphize type classes and parametric polymorphism by default... does it (like Rust) ?
15:50:02 <EvanR> thats not a very haskelly attitude
15:50:38 <EvanR> whole programs are written with typeclasses, imagine the code for that if done manually
15:50:44 <ertes> centril: i don't know what that means, but haskell has an optimisation called specialisation, which instantiates statically and makes dictionaries disappear
15:51:06 <EvanR> stuff you cant really do in explicit (non unique) dictionary passing languages
15:51:09 <ertes> centril: pretty much like C++ template instantiation
15:51:25 <centril> ertes: OK; so Haskell does monomorphize then, like Rust.
15:51:42 <ertes> centril: another thing haskell does is inlining, which also makes dictionaries disappear as a side effect most of the time
15:52:00 <ertes> centril: so yeah, type classes can be free, if you want them to be
15:52:16 <centril> ertes: I assume Haskell doesn't do specialization with RankNTypes / ExistentialQuantification  ?
15:52:23 <ertes> centril: correct
15:52:39 <centril> great
15:53:00 * centril hasn't done any serious amount of Haskell for some time
15:53:07 * centril misses it.
15:53:25 <ertes> well, it's at your fingertips…  just do some haskell again =)
15:53:54 <centril> ertes: I've been busy trying to do language design on Rust =P I'd like to bring ConstraintKinds to Rust eventually
15:54:58 * hackage miso 0.19.0.0 - A tasty Haskell front-end framework  http://hackage.haskell.org/package/miso-0.19.0.0 (DavidJohnson)
15:55:44 <centril> ertes: would be interesting to try to rewrite Haskell's runtime in Rust
15:56:20 <ertes> i haven't had a use case for rust yet
15:57:30 <ertes> centril: will rust ever have higher-kinded polymorphism?  or does it have it already?
15:59:28 <centril> ertes: Rust recently accepted an unimplemented RFC on "generic associated types" (associated type constructors), https://github.com/rust-lang/rfcs/blob/master/text/1598-generic_associated_types.md   but it is not fully HKTs
16:00:17 <Welkin> I think that is true for many people ertes
16:00:28 <Welkin> rust is the cool new language, but no one has a reason to use it
16:00:29 <Welkin> haha
16:00:43 <Welkin> I even started learning it, but can't come up with a project to use it on except bulding a game engine
16:01:09 <ertes> well, to be fair rust is not really appealing to me anyway…  it lacks all my favourite features from haskell
16:01:22 <Welkin> I just like the memory model
16:01:27 <ertes> most importantly IO and laziness
16:01:30 <Tuplanolla> I'm also in that camp. The only use for manual memory management I have is high performance scientific computing, which Rust is unsuitable for.
16:01:32 <Welkin> it does feel a lot like writing c++ to me
16:01:43 <ertes> i'd rather wait for linear types in haskell honestly
16:01:47 <ertes> they're on their way
16:01:59 <Welkin> ertes: is there a proposal yet?
16:02:09 <shapr> Welkin: lots of good reasons to use rust
16:02:10 <centril> ertes:  so with GATs you could have:    Foo::Bar<Baz>   essentially equivalent to   Bar Foo Baz   with class Foo x where type Foo x y :: *;
16:02:11 <ertes> Welkin: yeah
16:02:21 <Welkin> and will it allow us to avoid using the GC?
16:02:30 <centril> Welkin: https://github.com/ghc-proposals/ghc-proposals/pull/111
16:03:17 <ertes> oh yeah, and that instantiation syntax makes my stomach turn =)
16:03:33 <centril> ertes: I thought we were above Wadler's law :P
16:04:21 <ertes> centril: i actually believe that syntax is more important than most people realise
16:04:53 <ertes> for example haskell allows custom operators and uses the quietest syntax possible for function application, and that facilitates great EDSLs
16:04:57 <centril> I guess it depends on if you need the latency requirements of Rust and that much control over memory.  I do miss GADTs, HKTs, monads and currying from Haskell
16:05:10 <centril> ertes: Yes agreed; Haskell is syntactic nirvana
16:05:32 <centril> but Rust is great cause it allows you to build kernels and such without sacrificing soundness
16:05:40 <ertes> centril: and honestly i don't understand why language designers, even those that are actually inspired by haskell, ever seem to learn that lesson
16:05:51 <ertes> *never
16:06:02 <centril> but if you don't have those requirements, use Haskell
16:06:56 <centril> ertes: There are a lot of people who don't like layout syntax; Rust was also initially inspired and written in OCaml;
16:07:24 <Welkin> ertes: if you use racket, you can make up your own syntax :D
16:07:32 <ertes> centril: that's not a binary choice…  if you've ever read SPJ's haskell code you *know* that layout syntax in haskell is entirely optional =)
16:07:53 <centril> ertes: truthfully I haven't read SPJ's haskell code
16:07:58 <centril> ertes: but I know it is optional
16:08:04 <centril> but most people don't know that
16:08:20 <centril> but I like layout syntax a lot
16:09:24 <centril> In the design of Rust there's often talk about the "complexity budget", where arguments such as "we have affine typing and traits and stuff, so we can't introduce strange unfamiliar syntax because it would take to much of the complexity budget"
16:09:37 <centril> with arguments*
16:09:58 <ertes> i'm really talking about much more basic things
16:09:59 <keegans> https://github.com/mrkkrp/req/blob/bf30c68ea0c74c10c94db5dd088e9f6fb07075ff/Network/HTTP/Req.hs#L1238 how can I pass a cookieJar parameter to my request to authenticate another request ? (see : https://pastebin.com/PJG1btjS )
16:10:05 <ertes> function application, instantiation, etc.
16:10:21 <ertes> f(x,y) is just so anti-currying
16:10:41 <ertes> F<A> is anti-kinds and also anti-currying
16:10:56 <ertes> rust should just copy what haskell does
16:11:02 <Welkin> centril: oh, did you seen this? https://vorner.github.io/2018/04/08/Dark-side-of-ergonomics.html
16:11:26 <Xal> who would have guessed making the most used concept in your language syntactically simple was a good idea?
16:11:28 <centril> ertes: yes sure, I agree; I would have preferred Haskell syntax. I believe this is to placate Java's generics / Scala
16:11:29 <Welkin> also, rust is infiltrated by the node/js people who are trying to make it more like javascript and the node ecosystem, which is... bad
16:11:38 <Lears> I would kinda like f(x,y) syntax if the language reserved a special curry character like the \cdot we use in maths, so f(x,*) = \y -> f(x,y) and f(*,y) = \x -> f(x,y)
16:11:55 <centril> Welkin: I've read that one
16:12:06 <ertes> Lears: f (x, y) in haskell does exactly what it would do in other languages:  it passes a tuple
16:12:26 <ertes> Lears: but in haskell it's not special application syntax…  the actual application is the juxtaposition, and tuples are an actual type
16:12:29 <centril> ertes: interestingly, Rust has been moving closer to Haskell wrt. the type system; but not syntactically
16:12:38 <ertes> in other words: you can do that in haskell…  but you don't have to
16:13:25 <centril> ertes: Laziness has never been one of the selling cards of Haskell to me; but it's one of your favorite features... how come?
16:13:50 <ertes> centril: it makes data transformations more composable
16:13:56 <Welkin> keegans: why would you pass cookies from one request to another?
16:14:02 <centril> ertes: go on =)
16:14:03 <Xal> being able to have bottom in your data structure and not caring because a later step throws it away is great
16:14:33 <Lears> Right ertes, my point was less about the tupled arguments and more about this special currying syntax I'd like to have even in haskell.
16:14:34 <keegans> Welkin: the first endpoint authenticates me and gives me cookies, the second request needs to use those cookies to gain proper access to the page
16:14:38 <Welkin> you can access the cookies in each request
16:14:44 <ertes> centril: i don't need special abstractions for lists, streams, trees, etc.
16:14:49 <keegans> right, but i have to set them in the second
16:14:50 <Welkin> the cookies are not stored?
16:15:00 <keegans> are they? i haven't checked. i assumed the state was reset
16:15:04 <keegans> let me see
16:15:08 <ertes> centril: if i want to do a tree search, i can construct the tree first and then search through it, without having to actually compute the tree
16:15:13 <Welkin> in the browser they are
16:15:23 <Welkin> I expect for an http cient, there should be an option
16:15:42 <ertes> centril: laziness is also at the center of value recursion in FRP
16:16:01 <centril> ertes: ah yes, true.  What do you think about Idris's approach?
16:16:22 <Welkin> keegans: also, you set cookies in the header
16:16:26 <ertes> centril: laziness is likely one of the reasons i'll never switch to idris
16:16:45 <ertes> which is really sad, because it has all the other features i'd love to have in haskell
16:16:59 <centril> Welkin: honestly, the nodejs people, while not so great at language design bring knowledge about how to popularize things and package managers
16:17:01 <Welkin> keegans: https://en.wikipedia.org/wiki/HTTP_cookie
16:17:29 <centril> ertes: Yeah Idris is looking pretty cool to me
16:17:30 <keegans> Welkin: yeah but that would be abstracted away using the cookie jar mechanic
16:17:43 <keegans> i would just need to set the request cookie jar to my cookie jar
16:17:46 <keegans> then it would be handled for me
16:17:49 <centril> ertes: but Idris does have syntactically light weight opt-in laziness?
16:17:49 <Welkin> I don't know anything about how the req library works
16:17:54 <Welkin> but you would just set the Cookie header
16:18:09 <ertes> centril: it would need something like the opposite of -XStrict* in haskell
16:18:17 <ertes> centril: because i would need to opt in *all the time*
16:18:38 <centril> ertes: that seems feasible technically
16:19:19 <centril> ertes: Idris doesn't seem to have as good support for deriving tho... can't  GeneralizedNewtypeDeriving your way to composing your monad stack
16:19:40 <ertes> centril: that's ok, i'm not a heavy user of monad stacks =)
16:19:47 <ertes> but i do use deriving a lot
16:20:03 <centril> ertes: wat. Monad stacks are great =O =P
16:20:36 <ertes> centril: i use transformers in the more traditional sense:  i use them to transform monads whenever i need to
16:20:46 <ertes> centril: what i don't use is "application monads"
16:21:05 <centril> ertes: "application monads"?
16:21:13 <centril> ertes: like XMonad ?
16:21:18 <centril> one monad to bind them all...?
16:21:30 <ertes> you know those highly transformed monads that people need to type-alias, and then they use them everywhere?
16:21:44 <ertes> they're especially common in web frameworks
16:22:43 <centril> ertes: like this?  ReaderT r (StateT s (ExceptT e (WriterT w m))) a
16:22:50 <ertes> type App = ReaderT Blah (StateT Blubb (ExceptT …)))))))))))))))))
16:22:52 <ertes> yeah
16:23:24 <centril> ertes: I usually use a newtype over those
16:23:43 <ertes> newtype doesn't solve the core problem: IMO it's bad design
16:23:48 <ertes> it's monolithic
16:24:15 <ertes> my code more often looks like this:  do …; …; evalStateT …; …; …
16:24:37 <ertes> or, because it's me, more likely like this:  lowerCodensity $ do …; …; evalStateT …; …; …
16:24:38 <centril> ertes: well... a type checker wants a lot of shit... configuration options (reader), the environment (state), typing errors (except), and logging messages (writer)
16:24:38 <ertes> =)
16:25:03 <ertes> that's ok, use them whenever you need them…  just don't use them *everywhere*
16:25:10 <centril> plus, if you throw in Lens, it becomes pretty enticing ;)
16:25:14 <ertes> and only use those that you actually need
16:25:29 <centril> ertes: Yeah I agree =)
16:25:51 <centril> ertes: what do you think about writing code generic over   (MonadState s m, ..) => ..   ?
16:26:00 <ertes> most of my stuff is functions and bare IO, and that makes it very easy to understand and maintain
16:26:23 <ertes> effect classes are useful whenever you write generic code
16:26:49 <ertes> i use them, but far less frequently than i used to
16:27:07 <ertes> the thing is:  the moment you abstract over MonadState instead of just a regular function, you *force* the user to use a state monad
16:27:13 <centril> ertes: I've heard rumours that it slows down code compared to StateT ?
16:27:25 <ertes> so now if i don't want the state monad, i have to wrap everything by runStateT/execStateT
16:27:37 <ertes> nah, specialisation happens
16:28:11 <ertes> well, it *can* slow down code
16:28:14 <centril> ertes: well... usually runStateT/execStateT  happens at boundaries
16:28:42 <ertes> c :: (MonadState S m, MonadIO m) => m ()  -- variant 1
16:28:51 <ertes> f :: S -> IO S  -- variant 2
16:29:26 <ertes> c can have f's performance, but you're relying on a number of optimisations, and they don't always kick in
16:29:55 <centril> Welkin: I've never been particularly fond of lisps, darn parenthesis...
16:30:10 <ertes> about boundaries: i have them everywhere because i tend not to use global transforms
16:30:17 <ertes> centril: let me give you an example
16:30:18 <centril> ertes: right
16:30:34 <EvanR> if youre worried about speed... you got more good reasons not to want transformers
16:31:10 <ertes> centril: i'm a heavy user of Codensity for exception control and other CPS-related things, so i'm tempted to write (c :: Codensity IO A) rather than (c :: (A -> IO r) -> IO r)
16:31:36 <ertes> but it has almost always bitten me, so i write the non-transformed variant at boundaries, because i can always just apply Codensity to transform them
16:31:58 <centril> ertes: CPS never stuck with me
16:32:08 <ertes> centril: you know withFile?
16:32:19 <Welkin> centril: try racket. you will love it
16:32:31 <centril> ertes: sure
16:32:43 <monochrom> I am happy to learn that Racket Scheme has an equivalent of withFile too.
16:33:10 <Welkin> racket is not scheme any more
16:33:15 <ertes> centril: withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r  -- this is CPS, and you would normally use it like this:  withFile fp m (\h -> …)
16:33:21 <Welkin> I don't think you can call it scheme
16:33:47 <ertes> centril: however, this gets cumbersome if you have to open multiple files, especially if the number of files to open is dynamic, say when you get a list of paths
16:33:57 <centril> ertes: feels similar to  catchError :: m a -> (e -> m a) -> m a   ?
16:34:24 <ertes> centril: not quite, because with 'catch' the second argument is not the normal continuation
16:34:41 <Welkin> ertes: how would you handle configuration for a web server without using ReaderT other than explicitly having to pass around the configuration object?
16:34:44 <ertes> centril: think more of 'bracket' or 'finally'
16:34:47 <Welkin> it's just more convenient
16:34:49 <monochrom> The unwashed mass get used to withFile by throwing $ at it.  withFile fp m $ \h -> do ...
16:34:52 <centril> ertes: ah
16:34:55 <ertes> Welkin: i would explicitly pass it
16:35:09 <monochrom> To be fair, I do that too and not bother to use Cont or Codensity.
16:35:14 <centril> ertes: that sounds very not convenient
16:35:17 <ertes> centril: Codensity flips that control around:  do h <- Codensity (withFile fp m); …
16:35:45 <centril> ertes: clearly I need to study more abstract nonsense ;)
16:35:46 <ertes> centril: do h1 <- Codensity (withFile fp1 m1); h2 <- Codensity (withFile fp2 m2); …
16:36:03 <EvanR> theres several configuration techniques
16:36:09 <ertes> centril: but now that it's just a regular action with the CPS implicit, you can do stuff like this:
16:36:14 <monochrom> But now you have to tag a lot of lines with liftIO though.
16:36:37 <ertes> centril: do listOfHandles <- traverse (\fp -> Codensity (withFile fp m)) listOfFiles; …
16:36:55 <ertes> centril: all the CPS levels collapse into just a sequence of actions
16:37:10 <monochrom> Hrm!
16:37:11 <EvanR> Oleg style reflection, kmett style reflection, implicit params, put it in a global IVar
16:37:15 <monochrom> @type traverse
16:37:16 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:37:27 <centril> ertes: I think I need to read more about CPS in general =)
16:37:32 <Welkin> implicit params feel dirty to me
16:37:35 <EvanR> just freakin pass it around
16:37:41 <centril> it has been the monad I've avoided learning about so far
16:37:41 <Welkin> I don't know why jle` loves them so much
16:37:43 <ertes> centril: something like 'finally' also turns from "wrapping" with a cleanup action more into "registering" a cleanup action
16:38:03 <ertes> centril: CPS is really useful once you master it =)
16:38:05 <monochrom> Hrm interesting.
16:38:14 <centril> ertes: I bet =)
16:38:32 <monochrom> No, not just interesting. That's krad!
16:38:39 <ertes> centril: you can also use ContT for all this…  Codensity is just a slightly safer variant of ContT
16:38:42 <centril> Welkin: is implicit params any different than Agda style implicit arguments btw?
16:38:59 <Welkin> I don't know Agda
16:39:02 <ertes> centril: Codensity is like ContT, but without most of the continuation effects
16:39:19 <monochrom> I think you can try my http://www.vex.net/~trebla/haskell/cont.xhtml for a Cont tutorial.
16:39:36 <centril> ertes: clearly I have some reading to do.
16:39:48 <centril> but not now cause I have other papers to read.
16:39:54 <monochrom> P.S. I no longer recommend callCC.
16:40:04 <Welkin> monochrom: please set a line length (max-width) for the text on that page :(
16:40:20 <monochrom> Why?
16:40:30 <Welkin> it is hard to read when it goes from end to end on the screen
16:40:35 <ertes> monochrom: because not everybody has a tiling window manager =)
16:40:48 <Welkin> 12 words per line is about right
16:40:53 <monochrom> Everyone wants a different width.
16:40:58 <Welkin> no
16:41:04 <ertes> monochrom: (more seriously because it's better typography to wrap at something like 80ex-100ex)
16:41:05 <Welkin> there is a standard for what is easy to read
16:41:10 <EvanR> can you make it 79 char column pls
16:41:17 <hpc> imo Cont is rarely useful on its own, as important as it is to know
16:41:18 <centril> monochrom: I would cut the line width in half
16:41:20 <EvanR> Welkin: really...
16:41:21 <monochrom> My solution is I write ordinary <p> and you adjust your browser window width and it works perfectly.
16:41:23 <ertes> monochrom: 80-100 is standard for books for good reason
16:41:25 <Welkin> 2-3 alphabets length
16:41:31 <hpc> usually the things you use it for, it's better to just bake the continuation(s) in
16:42:17 <hpc> like parser combinator types, which will typically have at least 3 continuations (consume input, fail, eof)
16:42:38 <Tuplanolla> > how to resize window
16:42:40 <lambdabot>  error:
16:42:40 <lambdabot>      Ambiguous occurrence ‘resize’
16:42:40 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.resize’,
16:43:28 <Tuplanolla> > how to resize window
16:43:30 <lambdabot>  error:
16:43:30 <lambdabot>      • Ambiguous type variable ‘p0’ arising from a use of ‘to’
16:43:30 <lambdabot>        prevents the constraint ‘(Profunctor p0)’ from being solved.
16:43:40 <Tuplanolla> These imports make no sense.
16:44:11 <Welkin> :t how
16:44:12 <lambdabot> p1 -> p2 -> p3 -> p4 -> Doc
16:44:16 <Welkin> :t to
16:44:17 <lambdabot> (Contravariant f, Profunctor p) => (s -> a) -> Optic' p f s a
16:44:18 <monochrom> Yeah I can see why people are afraid of resizing their browser windows. Because they have to learn Profunctor for that, as lambdabot is showing.
16:44:20 <Welkin> :t resize
16:44:21 <lambdabot> Int -> Gen a -> Gen a
16:44:24 <Welkin> :t window
16:44:25 <lambdabot> b
16:44:26 <Welkin> O.o
16:45:08 <Welkin> I'm not going to resize my entire browser for a single website
16:45:18 <Welkin> I fullscreen everything for a reason
16:45:19 <EvanR> lordy
16:45:51 <hpc> my machine has a monitor for each website, all of different sizes
16:45:56 <EvanR> would you like monochrom to change the font to helvetica too
16:46:05 <ertes> <monochrom> No, not just interesting. That's krad! ⇐ were you referring to the Codensity stuff?
16:46:18 <monochrom> I actually have empirical evidence to support my claim that everyone wants a different width.
16:46:37 <monochrom> Because the majority of my students write lines of code that are 200 columns long.
16:46:55 <monochrom> They, too, fullscreen everything for a reason.  And that reason is to annoy me and my TAs.
16:47:30 <monochrom> And BTW everyone has a different aspect ratio for their fullscreens so meh.
16:47:34 <Welkin> I may fullscreen emacs, but I split the screen
16:47:52 <EvanR> the rosetta stone used width 100% so that is the only right answer here
16:48:02 <monochrom> ertes: Yeah the "traverse (\fp -> Codensity (withFile ..."
16:51:52 <monochrom> OK how about this, let's resolve this economically.  You can pay me money for setting a set width.  I'll obey the highest bidder.
16:52:15 <jared-w> monochrom: lol I'm about to lead a group for my capstone and I'm definitely going to set a hard lint on 150 cols in the CI purely for that reason
16:52:23 <monochrom> And I heard that I can rip more money if the payment rule is "the highest bidder pays what the second higher bidder names".
16:52:28 <EvanR> what kind of free software is that
16:52:42 <ertes> monochrom: 1 cent for 90ex
16:52:55 <ertes> euro-cent
16:53:09 <EvanR> 0.9 cents for 80 cols
16:54:06 <ertes> monochrom: how long does the auction run?
16:54:49 <monochrom> I haven't thought about that.  But I certainly want in the ballpark of tens of euros, not mere cents.
16:54:53 <Tuplanolla> What's the typographic unit for the width of an l? I'm putting 1 EUR for 420 of those.
16:55:14 <jared-w> rem or em, I believe?
16:55:44 <EvanR> that would be M
16:55:48 <EvanR> not l
16:56:06 <loginoob> I really want to understand when people say "strong type", "weak type", "dynamic typed", "static typed" or any other type. I want to understand it so that i can perfectly judge what is the type system of a lanugage. Is it statically typed or weakly typed or dynamically typed
16:56:12 <EvanR> this is so offtopic it hurts, and not in a good way
16:56:13 <loginoob> Can someone please help me? I don't know where to ask this question and i know this is off topic here.
16:56:22 <loginoob> I also searched on google but i got confused
16:56:36 <monochrom> dynamic and static are easy. They refer to how late types are checked.
16:56:48 <jared-w> static == at compile time, dynamic == at runtime
16:57:09 * hackage algebraic-graphs 0.1.1.1 - A library for algebraic graph construction and transformation  http://hackage.haskell.org/package/algebraic-graphs-0.1.1.1 (snowleopard)
16:57:15 <ertes> dynamic typing is really orthogonal to static typing
16:57:15 <loginoob> what is the type system for javascript for example
16:57:18 <EvanR> weak types are what people call systems they judge inferior somehow
16:57:28 <ertes> a language can be statically typed (or not) and support dynamic typing (or not)
16:57:28 <jared-w> loginoob: javascript has very weak very dynamic typing
16:57:42 <EvanR> strong types are what people call systems they think are unnecssary
16:57:45 <loginoob> so what is untyped language
16:57:51 <monochrom> weak would be "w00t everything is a string! everything can be used as a boolean!".  strong typing is string != int != boolean != character != list != set != multiset != ...
16:57:53 <jared-w> assembly is one :p
16:57:55 <ertes> loginoob: strong typing means that you can't add an Int to a Double without explicit conversion
16:58:09 <BoogieMan_> @pl 3
16:58:09 <lambdabot> 3
16:58:10 <loginoob> also is there a better place to ask all these kind of questions?
16:58:13 <monochrom> As an example mathematicians use dynamic weak typing.
16:58:17 <ertes> loginoob: haskell is statically, strongly typed and supports dynamic typing
16:58:26 <ertes> > (3 :: Integer) + (4 :: Double)
16:58:28 <loginoob> so that i don't hurt people in a bad way here
16:58:28 <lambdabot>  error:
16:58:28 <lambdabot>      • Couldn't match expected type ‘Integer’ with actual type ‘Double’
16:58:28 <lambdabot>      • In the second argument of ‘(+)’, namely ‘(4 :: Double)’
16:58:38 <ertes> > fromInteger (3 :: Integer) + (4 :: Double)
16:58:40 <lambdabot>  7.0
16:58:51 <BoogieMan_> @pl f (g x) (g y)
16:58:52 <lambdabot> f (g x) (g y)
16:58:55 <EvanR> loginoob: i was talking about the debate about the width of monochrom's site
16:59:11 <BoogieMan_> @pl f (g 3) (g y)
16:59:11 <lambdabot> f (g 3) (g y)
16:59:30 <loginoob> EvanR: oh sorry
16:59:36 <ertes> loginoob: also these aren't attributes of the individual types themselves, but of the language's type system
16:59:37 <BoogieMan_> @pl f (g 3) (g 4)
16:59:37 <lambdabot> f (g 3) (g 4)
17:00:04 <Welkin> loginoob: all type systems are static type systems. dynamic vs static is a lie.
17:00:16 <BoogieMan_> Help with pointfree implementaion of "on"?
17:00:20 <loginoob> ertes: so if i can do 2+"s" which gives me "2s" is that an example of dynamic type?
17:00:26 <Welkin> strong vs weak means that once a type has been decided for a value, it cannot change in a strong type system, but it can in a weak one
17:00:49 <ertes> loginoob: that's an example of weak typing
17:00:58 <ertes> loginoob: i.e. implicit type conversion
17:01:00 <EvanR> or do you get 25
17:01:08 <loginoob> lol
17:01:13 <loginoob> ertes: ok
17:01:14 <EvanR> wouldnt that be cool
17:01:23 <ertes> loginoob: alternatively this can just be a feature of the (+) operator itself…  you can actually have that in haskell, and it would be both strong and static
17:01:33 <BoogieMan_> Anyone?
17:01:44 <Welkin> BoogieMan_: bueller?
17:01:46 <loginoob> EvanR: definitely for people in JS land
17:02:15 <EvanR> strong and weak arent very well defined, its really a thing you hear in informal, unproductive language wars
17:02:20 <BoogieMan_> on f g x y = f (g x) (g y)
17:02:21 <ertes> @pl \f g x y = f (g x) (g y)
17:02:21 <lambdabot> (line 1, column 10):
17:02:21 <lambdabot> unexpected "="
17:02:21 <lambdabot> expecting pattern or "->"
17:02:28 <ertes> @pl \f g x y -> f (g x) (g y)
17:02:28 <lambdabot> join . ((flip . ((.) .)) .) . (.)
17:02:31 <ertes> BoogieMan_: ^
17:02:34 <Welkin> I like to categorize type systems as "good" and "bad"
17:02:35 <ertes> have fun =)
17:02:41 <EvanR> and ugly
17:02:50 <loginoob> ertes: would that be an example of polymorphism in haskell?
17:02:57 <BoogieMan_> Thats awful
17:02:59 <loginoob> about the + you said
17:03:03 <monochrom> and the so-utter-ugly-it's-beautiful
17:03:15 <ertes> loginoob: yeah, more specifically class-based polymorphism
17:03:18 <EvanR> that pointless combinator has more . than anything
17:03:22 <BoogieMan_> I have (.g) . f . g
17:03:40 <BoogieMan_> It works
17:03:44 <loginoob> ok got it
17:03:45 <ertes> @let class Add a b c | a b -> c where (.+.) :: a -> b -> c
17:03:46 <lambdabot>  Defined.
17:04:06 <ertes> @let instance Add Integer String String where i .+. s = show i ++ s
17:04:08 <lambdabot>  Defined.
17:04:15 <ertes> > (3 :: Integer) .+. "blah"
17:04:15 <Welkin> deian: you are missing a 'b'!
17:04:17 <lambdabot>  "3blah"
17:04:22 <ertes> loginoob: ^
17:04:26 <deian> :)
17:06:11 <Welkin> rather than endless analyze programming languages, contrasting an comparing them, just use them
17:06:31 <loginoob> ohh nice
17:06:42 <Welkin> you will be happier
17:07:30 <Welkin> leave that to the gyrocologists
17:08:33 <deian> i'm trying to add support for quasi-quoting a new language into haskell; what's the best way to load a .o file that provides the symols for FFI-ed functions? ghc<8.4.2 TH's addForeignFile doesn't take RawObjects
17:10:22 <BoogieMan_> @type flip
17:10:23 <lambdabot> (a -> b -> c) -> b -> a -> c
17:10:40 <BoogieMan_> @type flip flip
17:10:42 <lambdabot> b -> (a -> b -> c) -> a -> c
17:10:54 <jared-w> Anyone know of a haskell clone of expect? (the obscure tk scripting thing). There's libexpect which is just a wrapper around it but it hasn't been updated since 2012 and looks pretty bitrotted...
17:11:07 <Welkin> what is expect?
17:11:57 <jared-w> It's a tk scripting thing; pretty cool
17:12:13 <jared-w> I currently am considering using it for scripting mass testing of student code that needs to be run in a qemu VM
17:12:46 <geekosaur> it's used to script TUI stuff that won't run correctly over a pipe
17:12:51 <jared-w> it essentially works as a loop that reads in stdin from a terminal, spawns a process, and uses regex to scan for the right input spot and then you can send in text or commands or whatnot from stdout
17:13:05 <jared-w> right, what geekosaur said :p
17:14:07 <EvanR> you can also use it to automate builds of linux
17:14:14 <EvanR> which involve a lot of question answering
17:14:49 <jared-w> I'd ideally love it if I had some way to robustly go through an entire directory tree and execute the same scripts in every single codebase, collect errors and what not and then give me a nice output in a file somewhere. Expect can do that sort of thing combined with shell scripts but it'll be a pain to write in the robustness I'm needing (it /is/ student code after all; the happy path is not going to happen
17:14:51 <jared-w> very often lol)
17:25:34 <jared-w> Guess one doesn't exist. Ah well... I wonder how hard it would be to write my own
17:26:55 <orbisvicis> lyxia: do you remember that generics lpaste you showed me a few days ago? I want to map over a data type and found I could do it pretty simple with gmapT but iirc your paste had a lot of support work, typeclasses/instance definitions
17:29:39 <lyxia> uh, I remember a bit, what about it?
17:34:21 <orbisvicis> ah nevermind just found it... and my eyes still glaze over a bit heh
17:36:20 <jared-w> orbisvicis: have a link? I'm curious now :)
17:37:21 <orbisvicis> http://lpaste.net/364707
17:39:14 <jared-w> ah, looks like lyxia essentially built everything up from scratch; the source code for gmapT should be similarly terrifying :)
17:40:32 <orbisvicis> oh ok
17:42:07 <jared-w> https://hackage.haskell.org/package/base-4.11.0.0/docs/src/Data.Data.html#gmapM
17:46:49 <nkaretnikov> folks, what's the easiest way of printing  MutableByteArray# RealWorld?
17:47:24 <jared-w> My gut instinct is to reach for Debug.trace; but my first question is to wonder why the hell you need to do that in the first place
17:47:40 <lyxia> That can be made shorter with one-liner / generics-sop
17:48:54 <jared-w> Can it be made into... one line? :p
17:53:46 <nkaretnikov> jared-w: if you responded to me, then i'm specifically looking for a way to use normal printing functions: print/putStrLn
17:58:33 <geekosaur> the problem with printing that is that haskell has no idea what ti is. and, for that matter, neither does anyone here
18:00:41 <geekosaur> it's raw mutable memory in IO. so, you were expecting to see what exactly from it?
18:05:31 <Cale> You could peek a bunch of bytes off it and print them
18:06:08 <Cale> but not exactly safe/easy to do that from a Show instance
18:10:28 <rkennedy> Is it possible to write a `instance KnownNat a => Num (Proxy a)`, or something similar, which might indicate a supercompiling problem for GHC to solve? Is that a problem which is being worked on?
18:11:39 <keegans> https://stackoverflow.com/questions/7726742/how-to-escape-characters-in-haskells-text-regex-library does anyone know a proper solution to that ?
18:11:50 <albatross> guys, is there a function that does Int -> Text?
18:11:55 <keegans> i.e. i need a "\((\d+)\)"
18:12:04 <keegans> which would match "(100)"
18:12:47 <keegans> albatross: what does it need to do-- convert an integer to a Text?
18:12:58 <keegans> e.g.: 1 -> "1"
18:13:04 <albatross> keegans yes
18:13:30 <keegans> import qualified Data.Text as T
18:13:35 <keegans> T.pack $ show 1
18:13:52 <albatross> thanks keegans let me try that
18:16:45 <nkaretnikov> geekosaur, Cale: i'm trying to write a foldlM over it, here's a sketch of my inner function: `let f s i arr = case readWord8Array# arr i s of (# s, wi #) -> print (W# wi)`. the problem here is that to make it work, i need to also propagate a value of type State#, which is unlifted, so adding `>> return s` here wouldn't work? what do i do? by grepping through the ghc testsuite, i've found some examples, but they always
18:16:45 <nkaretnikov> freeze the array first in order to index it. i'd like to avoid that.
18:17:48 <nkaretnikov> ignore `arr` here, it will be in scope, it's just me testing stuff in ghci
18:18:09 * hackage invertible 0.2.0.5 - bidirectional arrows, bijective functions, and invariant functors  http://hackage.haskell.org/package/invertible-0.2.0.5 (DylanSimon)
18:19:00 <nkaretnikov> geekosaur, Cale: the usual trick for dealing with these functions is to use IO $ \s -> and pass s (the state) directly. however, once within IO ..., I can't use print. :\
18:20:07 <jared-w> What are you working on that needs completely unpacked magicHash stuff? Just curious
18:20:29 <nkaretnikov> geekosaur, Cale: i've tried writing it differently, but do i <- IO $ ... ; print i also doesn't work :(
18:20:30 <geekosaur> this feels like you're going about it the wrong way
18:20:50 <nkaretnikov> jared-w: i'm trying to implement insertion sort as close to a c implementation as possible, as an education exercise
18:20:59 <geekosaur> s there is always some variant of RealWorld because you're poking under the covers of IO
18:21:32 <geekosaur> (unless you were trying to be polymorphic to ST as well, in which case I think you have even bigger problems)
18:21:53 <nkaretnikov> geekosaur: i understand, i just don't know how to jump from within IO...
18:22:23 <nkaretnikov> geekosaur: anyway, let me show you my unfinished implementation. it's horrible, please don't laugh :)
18:23:00 <jared-w> No educational code is so bad it should be laughed at :)
18:23:13 <nkaretnikov> you'll see :) give me a sec
18:23:55 <geekosaur> anyway the way you do this is you promote the wi out (IO $ \s -> case readWord8Array# arr i s of (# s
18:23:56 <geekosaur> er
18:24:45 <geekosaur> anyway the way you do this is you promote the wi out, which I think is: wi' <- IO $ \s -> case readWord8Array# arr i s of (# _, wi #) -> wi
18:25:21 <nkaretnikov> geekosaur: doesn't work! that's exactly what i've tried
18:25:22 <geekosaur> hm, wait, no
18:25:26 <nkaretnikov> one sec
18:26:00 <geekosaur> lemme look at this again, it's annoying
18:26:09 <geekosaur> but that is in fact the wrong thing to feed to the IO constructor
18:27:02 <nkaretnikov> geekosaur: https://gist.github.com/nkaretnikov/fceb8f959ce869e3cf54355e4072681f the algorithm might be wrong, ignore all that. the problematic definition is at XXX
18:27:10 <nkaretnikov> is marked with XXX, i mean
18:27:17 <geekosaur> overthinking this, I suspect
18:27:47 <nkaretnikov> also, i mention a testsuite file that has some relevant code
18:28:35 <nkaretnikov> try uncommenting the def'n, you'll get a very confusing error message
18:28:52 <nkaretnikov> so i've been trying to work around it by writing foldM_
18:28:56 <geekosaur> yeh, this is overbaked. wi' <- IO $ readWord8Array# arr i
18:29:31 <geekosaur> I think
18:29:57 <nkaretnikov> geekosaur: look at line 112, isn't it the same?
18:30:43 <geekosaur> oh, right, it's complaining about liftedness
18:33:17 <geekosaur> unfortunately I have no idea how the new liftedness stuff works. I did this some years ago but that was before general unlifted types were added :(
18:33:55 <nkaretnikov> okay, anyone else? :)
18:33:59 <nkaretnikov> Cale: ?
18:34:03 <geekosaur> I suspect freezing exists for this pretty much, though
18:34:44 <nkaretnikov> that's my guess as well. note that indexByteArray returns a pure value, and there's no way to index mutable stuff in ghc.prim
18:38:09 <geekosaur> there is not a lot you can do with unlifted types
18:38:54 <nkaretnikov> AndreasK: ^ see the link above, which is related to the question i asked on #ghc yesterday.
18:54:36 <jared-w> I feel like it's worth pointing out that you can more or less exactly implement insertion sort mutably without having to use primitives at all
18:58:41 <nkaretnikov> jared-w: sure, could you elaborate?
19:08:20 <nkaretnikov> jared-w: how would swap inplace?
19:08:22 <nkaretnikov> you*
19:08:47 <jared-w> https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Mutable.html  there's as wap function in here
19:12:08 <nkaretnikov> jared-w: :) i've been told to use vector before. iiuc, vector is built on these primitives
19:12:37 <nkaretnikov> jared-w: so i'm just making my life hard for education purposes :)
19:12:52 <nkaretnikov> anyway, i made it work. not the print stuff, but the algorithm, it seems
19:13:12 <jared-w> You can always look through the vector code to see how it's built if you want to :)
19:13:51 <jared-w> But I can get the educational value aspect :)
19:14:53 <nkaretnikov> fwiw, i've updated the gist
19:46:18 <redrapscallion> in regards to type families, what exactly is meant when they say "type families support ad-hoc overloading of data types"?
19:57:48 <dfeuer> Ping Cale.
20:12:56 <jared-w> redrapscallion: you can think of type families as essentially functions that act on types
20:58:13 <vivit> So what's the simplest way to convert, for example,  Just 1  into  1 ?
20:59:14 <jared-w> simplest? fromJust. Best? Generally a case expression. Something like `case foo of Just x -> x; Nothing -> (do something here)`
21:02:48 <MarcelineVQ> just came in so commenting without context but: fromMaybe is simple and safe
21:09:59 <matsurago> hmm it's similar to Java's Optional.getOrElse() !
21:10:19 <jared-w> ah right, fromMaybe, forgot about that one
21:10:55 <jared-w> This grading is taking foreverrrr ಠ_ಠ
21:11:01 <Welkin> or else what?
21:11:24 <Welkin> :t fromMaybe
21:11:25 <lambdabot> a -> Maybe a -> a
21:11:26 <Welkin> :t maybe
21:11:26 <jared-w> Welkin: .getOrElse(default_value), I assume :p
21:11:27 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:12:52 <matsurago> jared-w: yea, Optional<T>.getOrElse(T defaultValue) in Java
21:13:35 <jared-w> yeah, so that's what fromMaybe does:   fromMaybe defaultValue maybeThing
21:13:54 <Welkin> when I started on this scotty project, I used too much abstraction out of habit, making it too similar to yesod
21:14:08 <Welkin> now I removed several layers of needless abstraction and it is much nicer
21:14:27 <jared-w> nice.  Yeah that premature abstraction problem is a real thing in haskell lol
21:14:28 <Welkin> I may even forgo using ReaderT
21:14:30 <Welkin> which I never do
21:15:01 <jared-w> What layers did you remove? Comonadic Freer mtl-bbq codensity? /s
21:15:09 <blankhart> i heard about YAGNI as a lines of code thing but i think it is well applied to abstraction
21:15:17 <Welkin> it really helps that I am using postgresql-simple, so much of the complexity that often lives in my endpoint handlers can be moved into the queries
21:15:39 <matsurago> abstraction though enables flexibility
21:16:36 <Welkin> jared-w: no config stored in ReaderT, no separate functions for endpoints
21:16:58 <Welkin> also, my handlers are only 2 lines: query database and render template
21:17:13 <Welkin> the queries are prewritten using raw sql
21:18:16 <bitemyapp> ackthet: that's a good idea.
21:18:27 <Welkin> of course I still need to use liftIO because scotty uses a monad stack internally
21:19:37 <Welkin> I like minimalist programming
21:19:49 <jared-w> matsurago: abstraction is abstraction. If it enables flexibility, that's good, if it doesn't, that's bad. It doesn't inherently enable flexibility on its own :)
21:20:37 <jared-w> nice nice, not bad. I'm not quite a fan of raw SQL inside programming languages but, honestly... it's not the worst thing ever
21:21:34 <Welkin> it really isn't
21:21:44 <Welkin> I have looked into opaleye before
21:21:58 <Welkin> and it does give you type safe queries, and "if it compiles, it will work"
21:22:06 <Welkin> which you do not have at all with postgresql-simple
21:22:17 <Welkin> but then again, it uses profunctors and arrow syntax O.o
21:22:24 <Welkin> and gets very complex very fast
21:22:57 <Welkin> it is bult on top of postgresql-simple
21:23:40 <Welkin> I may use opaleye (or a similar library) at some point if I have a sufficiently complex project
21:23:57 <jared-w> Well you don't need the arrow syntax, but yeah
21:25:38 <jared-w> I do prefer keeping a lot of my data validation for databases... inside the database, where it belongs. Definitely a fan of verification both ways though
21:25:51 <Welkin> I am really enjoying that here, yes
21:25:57 <Welkin> and I set up triggers to handle updating timestamps
21:26:05 <Welkin> so my application doesn't need to know anything about it or care
21:26:07 <jared-w> triggers are the best
21:26:26 <jared-w> like, DBs have 35 years of figuring out how to solve entire classes of problems. Who are we to completely disregard that valuable knowledge, eh?
21:26:32 <Welkin> postgres has a ton of cool functionality that you don't get access to if you use an ORM
21:28:20 <Welkin> there is even a sql quasiquote available
21:28:31 <Welkin> although it has a few quirks/edge cases
21:28:38 <Welkin> I'm okay using multi-line strings
21:28:41 <jared-w> I can imagine. SQL isn't exactly easy to parse lol
21:28:47 <Welkin> which I did not know you could do properly in haskell until recently
21:29:01 <Welkin> "hello \
21:29:02 <jared-w> I find the syntax of it ugly as fuck tho :|
21:29:05 <Welkin>  \world"
21:29:12 <Welkin> will be "hello world"
21:29:33 <Welkin> better than mconcat ["hello ", "world"]
21:29:49 * jared-w secretly prefers that to an extent
21:29:59 <Welkin> I've written it both ways now
21:30:04 <jared-w> I guess it beats shell where you have to immediately de-indent everything if you start a multiline string
21:30:05 <Welkin> I prefer the slashes
21:30:24 <Welkin> it would be nice to have better multi-line string support
21:30:29 <matsurago> Isn't ++ works as well ?
21:30:39 <Welkin> yes, that is what mconcat does matsurago
21:30:43 <jared-w> Well yeah but that's not true multiline strings, that's just concatenating strings
21:30:46 <Welkin> just with less noise
21:31:08 <jared-w> you can also do "foo" <> " " <> "bar"  but meh
21:42:58 <Lears> > 't':'h':'e':' ':'t':'r':'u':'e':' ':'m':'u':'l':'t':'i':'l':'i':'n':'e':' ':'s':'y':'n':'t':'a':'x':[]
21:43:00 <lambdabot>  "the true multiline syntax"
21:50:03 <Wizek> Welkin, jared-w haven't read all the scroll back, but isn't a quasi-quoter a good solution for multiline strings? I almost always use one of those.
21:50:21 <Wizek> Some even support de-indenting the string
21:50:59 <jared-w> quasi-quoters tho. Seems like solving a paper cut by sending in nukes lol
21:51:40 <Wizek> jared-w: How do you mean? Seems to be a lighter syntax than many of the alternatives here.
21:52:06 <jared-w> Lighter syntax, perhaps, but using template haskell isn't really a lightweight solution persay
21:53:14 <Wizek> jared-w: You mean in terms of compile time?
21:54:09 <jared-w> Just in terms of how lightweight the solution is. You're invoking an entirely separate AST, completely getting rid of any portability the hasekll code potentially had (it can no longer be cross compiled for one), and the gain is... slightly nicer multi-line syntax, in a subjective sense? :p
21:56:02 <Wizek> jared-w: do you cross compile often?
21:56:25 <Wizek> I would say it's quite objectively a lighter/nicer multiline syntax :)
21:56:48 <jared-w> no, and I suspect most people don't, but it is a concern to think about in general. It's like, would you bring in all of Lens just to use ^. once in one single function? Maybe, maybe not? ¯\_(ツ)_/¯
21:58:02 <Wizek> sure, I guess that depends on how many times you want multiline strings
21:58:11 <Wizek> For me the limit is 2.
21:58:33 <Wizek> if I have 2 instances of multiline strings in a project I generally reach for https://hackage.haskell.org/package/interpolatedstring-perl6-1.0.0/docs/Text-InterpolatedString-Perl6.html or similar :)
22:00:32 <jared-w> do you often have a lo of multiline strings?
22:02:42 <nshepperd> if you're writing a library, it's not "do you cross compile often" it's "do the users of your library cross compile ever"
22:09:51 <jared-w> And even if they don't now, hopefully you'd want your library usable in case it became more common in the future :)
22:10:02 <jared-w> (like for mobile development, for example)
22:14:51 <Welkin> quasiquotes in lisp are amazing
22:15:06 <Welkin> it would be nice if we didn't have template haskell, and had lisp qq instead
22:15:23 <jared-w> agreed. Lisp has excellent support for quoting. Almost like it's a first class citizen in the language design and vision or something... :p
22:15:48 <Welkin> I don't even need html combinators in racket
22:15:52 <jared-w> Welkin: we'd likely have to have homoiconic syntax in Haskell to really have support for that sort of first class quoting
22:15:58 <Welkin> I just use qq directly to write the html
22:16:12 <jared-w> heh, I suppose that works :p
22:17:03 <Welkin> well, to write the AST which later gets converted into html
22:17:09 <Welkin> actual html*
22:22:05 <jared-w> Do you have any example code of that?
22:23:59 <nshepperd> i like templatehaskelll just fine, but it needs more sensible cross compiler support :<
22:24:32 <jared-w> Does it have any? lol
22:24:48 <nshepperd> maybe once ghc gets -target and the ability to distinguish packages in the registry by target
22:25:10 <jared-w> Part of the problem, iirc, is it requires an entirely separate AST that has to be kept in sync; something that the trees that grow thing is supposed to fix once it lands in ~GHC 8.6?
22:25:20 <jared-w> oh ghc is going to get -target? nice
22:25:22 <nshepperd> jared-w: iirc there's a flag where you can supply a command to run the template haskell on your target device
22:25:50 <nshepperd> i don't know how well it works
22:26:03 <hapticFeels> Anyone have any experience building up a recursive descent parser over a stream of tokens using parser combinators? I've been trying to figure out where to go. I'm building up a two-phase "compiler" for a class project. So far I've finished the lexer, but I'm having trouble getting the parser to work. Conceptually it should be very simple, define the AST for the grammar, define a function for each of the nonterminal symbols in the
22:26:03 <hapticFeels> grammar. I want to avoid using existing combinator libraries since this is a class project, and I'd like to udnerstand the process for myself.
22:27:55 <nshepperd> like -fsome-flag-name="ssh my-raspberry-pi copy over the binary and execute it"
22:28:36 <nshepperd> jared-w: someone in the channel suggested -target would happen, i don't know anything about it
22:29:36 <jared-w> ah cool, well here's hoping it does :)
22:30:08 <cocreature> I think -target is moritz angerman’s long-term plan
22:30:41 <nshepperd> once we have it though, the solution seems to me: first compile with -target=native, dump splices, compile with -target=$target and TH spliced in
22:32:26 <cocreature> I’m not sure it’s that simple. if you do IO in TH, -target might not be sufficient
22:34:24 <Welkin> jared-w: https://docs.racket-lang.org/pollen/index.html
22:34:25 <nshepperd> why not?
22:35:21 <cocreature> nshepperd: e.g. you could imagine some IO to figure out something about the system you’re compiling for
22:35:26 <nshepperd> (the behaviour with this *is* slightly different than the current hack, because the current cross-TH runs "as if on the target platform" with target word sizes and so on. but imo any code that relies on that is Evil)
22:35:56 <nshepperd> yeah that sort of IO I would count as evil
22:36:34 <cocreature> fair enough, I’m tempted to agree but that doesn’t change the fact that I’m pretty sure it’s out there :)
22:36:59 <nshepperd> that's fundamentally anti-cross-compilation behaviour
22:37:00 <cocreature> perhaps more reasonable are things like custom setups. there it’s fairly common to query the system in some way
22:38:00 <jared-w> Welkin: did you write Practical Typography? Or is that in the link to pollen?
22:44:06 <nshepperd> cocreature: that sort of thing would be ok as long as the TH accepts a command line flag or something to point it to the location of target headers or whatever
22:44:39 <jared-w> ah, I see not; still, Pollen is a fascinating project. I've seen it a time or two and I enjoy it every time :)
22:47:09 * hackage monad-logger 0.3.28.5 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.28.5 (MichaelSnoyman)
22:47:38 <cocreature> nshepperd: right my point is not that it’s not possible to fix it but rather that a lot of Haskell packages wouldn’t work without modifications
22:48:10 <nshepperd> that is probably true
22:52:15 <jle`> Welkin: i like implicit params :3
22:52:31 <jle`> every other style requires explicitly tagging the return type somehow
22:52:51 <jle`> or arguments
23:15:14 <Welkin> jared-w: I did not write practical typography. Different person. I have read it though. And I am using pollen to write my book on haskell
23:57:26 <dpyro> i'm trying to use aeson (Data.Aeson) and i'm not sure how to go about dealing with very large numbers in json that are transmitted as strings
23:58:42 <dpyro> I tried using Scientific and Natural for my fields datatypes, but aeson is still expecting an unquoted number value
23:58:42 <reactormonk> dpyro, what are your concerns, and what are the problems you ran into?
23:58:48 <yaw> new here. I don't even have a compiler installed :D
23:59:27 <reactormonk> yaw, https://haskell-lang.org/get-started
23:59:59 <cocreature> dpyro: you could first decode it to a string and then call readMaybe
