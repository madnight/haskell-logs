00:03:32 <Geraldus> Hi friends!@
00:03:55 <Geraldus> Since recent NixOS upgrade (I'm on unstable Nix channel) I'm facing issues with my Haskell setup
00:04:05 <Geraldus> ere is an output, stack yaml and cabal file contents https://gist.github.com/geraldus/13a7cbd39038e43e6f54566a0668f5ee
00:04:11 <Geraldus> Any clues?
00:07:26 <laudecay> ok i have (a -> a) -> b -> b and a -> (a, Maybe c), and I want b -> (b, Maybe c)
00:07:37 <cocreature> Geraldus: you can’t built haddock 2.19 with ghc 8.2, you need 8.4
00:07:38 <laudecay> is this like... lift?
00:08:00 <laudecay> listM
00:08:04 <laudecay> er liftM
00:08:28 <Geraldus> cocreature: Oh, very important notice!
00:08:58 <Geraldus> Now I need to understand what causes this dependency
00:09:05 <Cale> @djinn ((a -> a) -> b -> b) -> (a -> (a, c)) -> (b -> (b, c))
00:09:05 <lambdabot> -- f cannot be realized.
00:09:14 <cocreature> probably nixpkgs is just screwed up
00:09:16 <laudecay> woah what's that do
00:09:20 <cocreature> or at least the version of nixpkgs that you use
00:09:21 <Cale> writes functions
00:09:22 <laudecay> @djinn
00:09:23 <lambdabot> Cannot parse command
00:09:24 <laudecay> what
00:09:25 <Cale> based on their type
00:09:30 <laudecay> w o a h
00:09:34 <laudecay> that is incredible
00:09:42 <Geraldus> cocreature: Yeah
00:09:51 <laudecay> i mean i guess i could also
00:09:55 <Walther> are there any easy ways to optimize `stack build` ? I'm trying to poke together a relatively simple site with hakyll and the builds take like 8 minutes because it compiles the entirety of pandoc, hakyll, etc on every build even if the site.hs itself is rather simple
00:10:13 <laudecay> @djinn ((a -> a) -> (b -> b)) -> (a -> (a, c)) -> (b -> (b, c))
00:10:13 <lambdabot> -- f cannot be realized.
00:10:16 <laudecay> hnng
00:10:27 <laudecay> @djinn ((a -> a) -> (b -> b)) -> (a -> (c, a)) -> (b -> (c, b))
00:10:28 <lambdabot> -- f cannot be realized.
00:10:33 <laudecay> that's fake news
00:10:35 <Cale> The problem is, you don't have an a at all.
00:10:43 <laudecay> ?
00:10:52 <cocreature> Walther: it shouldn’t rebuild pandoc and hakyll, are you deleting some stack directories in between builds?
00:10:56 <Cale> Okay, let's start trying to write this thing
00:11:01 <Cale> Suppose we have
00:11:12 <Cale> f :: (a -> a) -> (b -> b)
00:11:17 <Geraldus> cocreature: Is there a way to check this hypothesis?
00:11:19 <Cale> g :: a -> (c,a)
00:11:23 <Cale> x :: b
00:11:42 <Cale> and our goal is to produce something of type (c,b)
00:11:46 <Walther> cocreature: nope. I've installed stack via homebrew, and I followed the instructions here https://jaspervdj.be/hakyll/tutorials/01-installation.html
00:11:51 <laudecay> huh
00:11:53 <laudecay> what
00:12:12 <cocreature> Walther: can you show us your stack.yaml?
00:12:17 <Cale> laudecay: These are just the types of the arguments to the function you want
00:12:33 <Cale> (and the type of its putative result)
00:12:37 <laudecay> yeah, i'm just going brain dead :(
00:12:52 <Cale> The only way to get something of type c here would be to apply the function g
00:13:02 <Cale> So we need to obtain something of type a
00:13:02 <Walther> cocreature: https://walther.guru/temp/stack.yaml
00:13:12 <laudecay> i mean isn't a -> (c,a) just like (c,) . (a -> a)
00:13:24 <Walther> cocreature: also https://walther.guru/temp/veetiphotos.cabal
00:13:40 <cocreature> Geraldus: figure out which version of nixpkgs you’re using and take a look at how haddock is defined there
00:13:44 <laudecay> i guess i also have uh b -> a
00:13:50 <Cale> Well, we can take g and compose it with snd if you like
00:13:59 <Cale> snd . g :: a -> a
00:14:06 <Cale> but this won't help us to get a value of type c
00:14:14 <laudecay> fst . g ?
00:14:28 <Cale> fst . g :: a -> c
00:14:38 <Cale> that might help us, except that we have nothing of type a available
00:14:56 <Cale> we can apply f to snd . g
00:15:04 <Cale> f (snd . g) :: b -> b
00:15:15 <Cale> but that gets us no closer to having a value of type c
00:15:15 <cocreature> Walther: can you show us the full output of a rebuild?
00:15:24 <laudecay> i mean i can get a thing of type a, i have a function that goes b -> a
00:15:42 <Cale> We didn't provide one though
00:15:49 <enterprisey> how can I write a proper constraint for casting something of type `a b c`? If I do Typeable (a b c), it complains about no constraint for Typeable b0
00:15:52 <Cale> @djinn (b -> a) -> ((a -> a) -> b -> b) -> (a -> (a, c)) -> (b -> (b, c))
00:15:53 <lambdabot> f a b c d =
00:15:53 <lambdabot>     case c (a d) of
00:15:53 <lambdabot>     (_, e) -> (b (\ f -> f) d, e)
00:15:57 <laudecay> wow
00:16:02 <laudecay> incredibleeeee
00:16:19 <Walther> cocreature: https://walther.guru/temp/veetiphotos-stack-build.txt
00:17:14 <EvanR> in soviet haskell, types program for you
00:17:16 <cocreature> Walther: and if you run "stack build" in the same folder after that it rebuilds pandoc?
00:17:29 <laudecay> hold on uh Cale why are there 4 arguments
00:17:37 <laudecay> instead of 3?
00:17:47 <laudecay> shouldn't 4 things in the type signature be 3 arguments
00:17:56 <EvanR> the last pair of parens isnt necessary
00:17:59 <Walther> haddock-library-1.4.5: build
00:18:01 <Walther> Progress: 0/5
00:18:07 <Walther> yep, restarts building everything
00:18:12 <Walther> without having deleted anything
00:18:14 <EvanR> (b -> a) -> ((a -> a) -> b -> b) -> (a -> (a, c)) -> b -> (b, c)
00:18:27 <Cale> laudecay: (b -> a), ((a -> a) -> b -> b), (a -> (a, c)), b
00:18:39 <Cale> that's 4
00:19:03 <laudecay> ooohhh
00:20:51 <laudecay> so that (\ f -> f), is that just id?
00:20:53 <cocreature> Walther: huh that’s weird. which version of stack are you using?
00:22:08 <laudecay> wait how do i apply a function to the first member of a tuple
00:23:25 <Walther> cocreature: Version 1.6.5, Git revision 24ab0d6ff07f28276e082c3ce74dfdeb1a2ca9e9 (5514 commits) x86_64 hpack-0.20.0
00:23:25 <liste> :t first -- laudecay
00:23:26 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
00:23:29 <Cale> Note that djinn only gives you *a* function of the appropriate type, but if there's more than one, it might not be the one that you want
00:23:51 <laudecay> Cale: oh it was really close, I was able to get a correct function, it's just a bit ugly.
00:24:01 <laudecay> extractMessage p = case getDeliverable (nqueue p) of (n', e) -> (setNQueue n' p, e)
00:24:24 <laudecay> i could flip setNQueue and apply it to the first member of getDeliverable
00:24:33 <laudecay> liste: what's that mean?
00:25:01 <liste> laudecay: it's a function that applies a function over the first element of a tuple
00:25:12 <liste> > first (+1) (3,7)
00:25:14 <lambdabot>  (4,7)
00:25:17 <laudecay> woah!!
00:25:26 <laudecay> so then
00:25:42 <cocreature> Walther: looks like this was a bug https://github.com/commercialhaskell/stack/issues/3899 it’s probably fixed in the 1.7 release candidate
00:25:49 <laudecay> first (flip setNQueue $ p) (getDeliverable (nqueue p)
00:25:52 <laudecay> wow
00:26:06 <EvanR> arrows strike again
00:26:17 <Walther> cocreature: ah, always lovely to hit an upstream bug :D Thanks <3
00:26:26 <liste> Data.Bifunctor has another "first"
00:26:29 <liste> it's better IMO
00:26:33 <laudecay> now to get it point-free :3
00:26:45 <laudecay> does lambdabot do point-free
00:26:55 <laudecay> @lambdabot where are you documented :(
00:26:55 <lambdabot> Unknown command, try @list
00:26:57 <liste> @pl (\a b -> a + b)
00:26:57 <lambdabot> (+)
00:27:05 <laudecay> @pl extractMessage p = first (flip setNQueue $ p) (getDeliverable (nqueue p)
00:27:05 <lambdabot> (line 1, column 19):
00:27:05 <lambdabot> unexpected " "
00:27:05 <lambdabot> expecting operator
00:27:14 <laudecay> @pl \p -> first (flip setNQueue $ p) (getDeliverable (nqueue p)
00:27:14 <lambdabot> (line 1, column 60):
00:27:14 <lambdabot> unexpected end of input
00:27:14 <lambdabot> expecting variable, "(", operator or ")"
00:27:21 <laudecay> oh hec
00:27:22 <liste> you're missing a )
00:27:26 <laudecay> @pl \p -> first (flip setNQueue $ p) (getDeliverable (nqueue p))
00:27:26 <lambdabot> ap (first . flip setNQueue) (getDeliverable . nqueue)
00:27:33 <laudecay> wew lad
00:28:04 <EvanR> wacky
00:28:11 <laudecay> :t ap
00:28:12 <lambdabot> Monad m => m (a -> b) -> m a -> m b
00:28:18 <laudecay> this is above me
00:28:19 <EvanR> well that ones not bad
00:28:29 <laudecay> that's actually gorgeous
00:28:47 <laudecay> EvanR: I'm following your suggestions and wow my code is so much better now
00:28:50 <liste> :t (<*>)
00:28:51 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:29:03 <liste> ap is just <*> specialized to Monad
00:29:03 <laudecay> what's the precedence of <*>
00:29:20 <cocreature> % :i (<*>)
00:29:21 <yahb> cocreature: class Functor f => Applicative (f :: * -> *) where; ...; (<*>) :: f (a -> b) -> f a -> f b; ...; -- Defined in `GHC.Base'; infixl 4 <*>
00:29:25 <laudecay> W O W
00:29:33 <laudecay> :i (<*>)
00:29:35 <laudecay> ?
00:29:38 <laudecay> oh hec
00:29:42 <liste> laudecay: it's ghci's :info
00:29:59 <laudecay> wow this is adorable
00:30:09 <laudecay> i love haskell when i dont have to be good at it for a class
00:30:39 <mniip>  % is ghci pretty much
00:31:19 <laudecay> like just gloriously sucking at this and learning at my own pace is so fun
00:31:23 <laudecay> this is the best programming language
00:31:38 <laudecay> ive been coding for like almost 12 hours holy god
00:31:44 <EvanR> me too
00:31:47 <laudecay> ok time to take a break and sleep
00:31:48 <EvanR> about to die
00:31:57 <laudecay> im not even tired or caffeinated
00:32:07 <laudecay> but i'm getting worse at everything
00:32:17 <laudecay> how am i not bored yet
00:32:20 <laudecay> god bless haskell
00:43:25 <tsahyt> say I've got some function with a MonadError Error1 constraint, and the function I'm using it has an MonadError Error2 constraint where Error2 subsumes Error1 (there's a constructor dedicated to Error1 values). What would be the cleanest way to wrap the potential error of the called function in the caller?
00:44:42 <tsahyt> I've found ways to do this with concrete transformer stacks, e.g. withExceptT, but nothing that works when I don't specify ExceptT in the type
00:45:26 <laudecay> @pl extractMessage p = first ((flip setNQueue) p) $ (getDeliverable (deliverable p)) (nqueue p)
00:45:26 <lambdabot> extractMessage = ap (first . flip setNQueue) (liftM2 getDeliverable deliverable nqueue)
00:46:33 <enterprisey> any ideas on writing a pattern match for values of type `a b c`?
00:46:50 <enterprisey> Is this even possible?
00:47:10 <tsahyt> enterprisey: are all of these fully polymorphic?
00:47:30 <tsahyt> if so I don't think you can do that. you need some constructor to match on after all
00:47:36 <enterprisey> well, I know that there are three possibilities: n C O, n O O, and n O C
00:47:41 <enterprisey> this makes sense
00:47:48 <liste> and "n" is polymorphic?
00:48:03 <enterprisey> yeah
00:48:13 <liste> then there's no constructors to match
00:48:36 <liste> you need a concrete type to get constructors
00:48:41 <tsahyt> enterprisey: are you trying to match on the type?
00:48:52 <enterprisey> I believe so
00:49:08 <enterprisey> actually, I think there's something I can do so I don't have to solve this problem
00:49:20 <liste> good
00:49:44 <tsahyt> that'd be preferable I suppose. otherwise you can do this with typeclasses, but it's not going to be pretty
00:55:33 <tsahyt> hm, it looks like I'll actually have to go with a master error type :/
00:57:10 <tsahyt> the exceptions package doesn't look like it gives me what I'd need either
00:57:33 <tsahyt> or perhaps it does
00:58:00 <tsahyt> ah but I lose the type level information of which exceptions can be thrown
01:25:52 <cocreature> tsahyt: one option is to use something like classy prisms, i.e., (MonadError e m, AsError1 m) => m a, (MonadError e m, AsError2 m) => m a. you can then just accumulate these constraints and resolve them when you choose the concrete monad
01:26:23 <tsahyt> of course there's a lens solution :P
01:26:32 <tsahyt> I guess I'll have to look into classy prisms
01:27:07 <cocreature> eh I screwed that up, that should be AsErro1 e, and AsError 2 e
01:28:16 <cocreature> lens just popularized the approach. you could imagine "class AsError1 e where asError1 :: Error1 -> e"
01:28:31 <tsahyt> shouldn't that be the other way round?
01:28:33 <tsahyt> e -> Error1
01:29:43 <cocreature> no, AsError1 expresses the fact that you can throw Error1s
01:30:01 <cocreature> so you need some way to convert them to the more general type
01:30:08 <tsahyt> ah right
01:30:39 <tsahyt> but eventually I still need some ADT that collects all the possible errors, which has all these AsErrorN instances
01:30:45 <cocreature> right
01:31:25 <cocreature> https://github.com/gwils/next-level-mtl-with-classy-optics/blob/master/Slides.pdf is a pretty good overview of that approach
01:31:39 <tsahyt> hmm. for now I've just created such a type manually, flattened out the possible errors, and am throwing them like that. I might switch to the lensy solution if this becomes unwieldy
01:33:23 <tsahyt> I might need to do that pretty soon actually, those C libraries underneath can fail at any inopportune moment :/
01:33:40 <tsahyt> though opengl usually fails either silently or spectacularly
01:42:39 * hackage hw-prim 0.5.0.3 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.5.0.3 (haskellworks)
01:43:46 <Taneb> Something I feel from recursion-schemes is foo :: (Recursive a, Corecursive b) => (forall x. Base a x -> Base b x) -> a -> b; foo = embed . fmap (foo f) . project
01:44:04 <Taneb> Which lets us write List.map without either explicit recursion or corecursion
01:47:45 <jophish> ahh, what happened to https://github.com/RyanGlScott/bytestring-trie
01:53:21 <cocreature> jophish: are you maybe looking for https://github.com/wrengr/bytestring-trie ?
01:55:02 <jophish> cocreature: yeah, but that URL in particular is wanted by my build system :)
01:55:11 <jophish> github should be an immutable append only store
01:55:20 <jophish> everything*
01:57:02 <Taneb> (or at least that could be a 301 rather than a 404)
02:13:23 <cocreature> jophish: where did you get that url from? it’s not the source-repo on the hackage package
02:17:39 * hackage hadolint 1.6.5 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.6.5 (lorenzo)
02:20:07 <cocreature> ah it contained a fix for 8.4
02:33:56 <leifm> I'm trying to make a function to do the following:
02:34:20 <leifm> Apply, discarding the value of the first argument.
02:34:32 <leifm> e.g.
02:34:39 * hackage unliftio 0.2.7.0 - The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)  http://hackage.haskell.org/package/unliftio-0.2.7.0 (MichaelSnoyman)
02:34:59 <leifm> (1 :. 2 :. 3 :. Nil) *> (4 :. 5 :. 6 :. Nil)
02:35:09 <leifm> evaluates to
02:35:41 <leifm> (4 :. 5 :. 6 :. 4 :. 5 :. 6 :. 4 :. 5 :. 6 :. Nil)
02:36:02 <leifm> Where *> is the name of the function
02:36:07 <leifm> You can see the code at https://github.com/tonymorris/fp-course/raw/master/src/Course/Applicative.hs
02:36:18 <leifm> I came up with:
02:36:30 <leifm> (*>) = lift2 (flip const)
02:36:47 <leifm> But the solution is:
02:37:02 <leifm> (*>) = lift2 (const id)
02:37:17 <leifm> They're functionally identical, so why is one used over the other?
02:37:32 <liste> leifm: random chance
02:37:46 <liste> your instructor ended up with one, you ended up with the other
02:38:43 <leifm> Alright, so there's absolutely no difference between (const id) and (flip const)?
02:38:54 <leifm> Once it compiles, I guess
02:40:44 <liste> nope
02:41:04 <liste> you could derive one from the other with pen and paper
02:41:27 <leifm> I still don't understand how (const id) works, so probably not.
02:41:39 <leifm> But thanks anyway!
02:41:40 <liste> const id is just (\x y -> y) (\x -> x)
02:42:05 <liste> then you can use abstraction and application to make it flip const
02:42:43 <liste> which is (\x y z -> x z y)(\y -> y)
02:43:05 <liste> oh wait
02:43:13 <liste> (\x y z -> x z y)(\x y -> y)
02:48:42 <ZeuPiark> hello
02:49:01 <leifm> liste: Thanks, I get it now
03:12:39 * hackage safe-money 0.6 - Type-safe and lossless encoding and manipulation of money, fiat currencies,crypto currencies and precious metals.  http://hackage.haskell.org/package/safe-money-0.6 (RenzoCarbonara)
03:12:40 <ffwacom> You mena haskelll???
03:22:53 <hc> hmm?
03:49:25 <ph88> cocreature, i found the part of my code that brings ghc into a loop. It has some data types who refer to each other in a cycle (though this was possible with the old lts version) https://imgur.com/a/nM6vsbw
03:49:36 <ph88> took some time to visualize this ..
03:51:07 <cocreature> ph88: and it’s just the datatype decls that cause the problem or functions operating on these types, instance decls, …?
03:51:20 <ph88> cocreature, that i have yet to figure out !
03:51:31 <ph88> good point
03:51:46 <ph88> right now i comment/uncomment types and functions at the same time
03:52:09 <cocreature> also it seems very likely that it should be possible to further simplify those types
03:52:09 * hackage hmatrix 0.19.0.0 - Numeric Linear Algebra  http://hackage.haskell.org/package/hmatrix-0.19.0.0 (DominicSteinitz)
03:52:46 <ph88> cocreature, why and how further simplify? they represent parts of the grammar as it's found in the standard
03:53:32 <cocreature> ph88: I don’t mean simplify in the sense that you preserve what the code does but simplify while still being able to reproduce the compile time problems
03:56:28 <ph88> cocreature, ah yes i was thinking about this as well .. so in the picture with nodes/edges there are several cycles .. i was thinking about breaking up those cycles. Is that what you have in mind too ?
03:58:51 <cocreature> yeah, remove some edges until you can remove the types alltogether
03:58:58 <ph88> ok
04:02:38 <ph88> ok it's not a problem with the data types it seems .. each type has one instance .. i'll work my way onto that
04:03:36 <cocreature> reducing GHC regressions to small test cases is painful work but ime once you’ve done that GHC devs are often quite helpful in actually diagnosing and fixing the issue :)
04:09:44 <ph88> cocreature, i looked into the ghc bugtracker .. there are a few bugs about this .. most of them reported 8 years ago. I suspect if they will be fixed it will be good for my program too
04:11:15 <cocreature> a few bugs about what?
04:12:09 <cocreature> given that your program seems to have regressed somewhat recently, I doubt bug reports from 8 years ago have anything to do with it
04:12:09 <ph88> https://ghc.haskell.org/trac/ghc/ticket/5448
04:14:10 * hackage zifter 0.0.1.7 - zifter  http://hackage.haskell.org/package/zifter-0.0.1.7 (Norfair)
04:18:10 * hackage hmatrix-sundials 0.19.0.0 - hmatrix interface to sundials  http://hackage.haskell.org/package/hmatrix-sundials-0.19.0.0 (DominicSteinitz)
04:38:44 <ph88> does ghc have a tool for CI ?
04:40:32 <liste> ph88: what kind of tool? compiling on different ghc versions at once?
04:40:41 <ph88> yes
04:41:21 <ph88> i thought it mind be interesting to use it for GHC tickets too .. so people can see the compiler output for test cases for different versions of ghc
04:45:50 <cinimod> `stack --nix upload packages/gsl` is giving me
04:46:03 <cinimod> `This server does not accept packages with 'license' field set to e.g. AllRightsReserved. See https://hackage.haskell.org/upload for more information about accepted licenses.`
04:46:29 <cinimod> But the cabal file has `license:            GPL`
04:57:03 <cocreature> cinimod: try GPL-2
04:59:37 <cinimod> That works but the documentation says otherwise: https://hackage.haskell.org/package/Cabal-2.2.0.1/docs/Distribution-License.html
05:00:00 <cinimod> Thanks
05:00:20 * hackage hmatrix-gsl 0.19.0.0 - Numerical computation  http://hackage.haskell.org/package/hmatrix-gsl-0.19.0.0 (DominicSteinitz)
05:02:39 * hackage hmatrix-glpk 0.19.0.0 - Linear Programming based on GLPK  http://hackage.haskell.org/package/hmatrix-glpk-0.19.0.0 (DominicSteinitz)
05:07:52 <marmistrz> EvanR, re: zip', there actually exists such a zip in the hackage
05:07:53 <marmistrz> https://hackage.haskell.org/package/safe-0.3.17/docs/Safe-Exact.html
05:16:39 * hackage wild-bind-x11 0.2.0.3 - X11-specific implementation for WildBind  http://hackage.haskell.org/package/wild-bind-x11-0.2.0.3 (debugito)
05:28:09 * hackage hmatrix-sparse 0.19.0.0 - Sparse linear solver  http://hackage.haskell.org/package/hmatrix-sparse-0.19.0.0 (DominicSteinitz)
05:29:09 * hackage hmatrix-special 0.19.0.0 - Interface to GSL special functions  http://hackage.haskell.org/package/hmatrix-special-0.19.0.0 (DominicSteinitz)
05:31:09 * hackage hmatrix-tests 0.19.0.0 - Tests for hmatrix  http://hackage.haskell.org/package/hmatrix-tests-0.19.0.0 (DominicSteinitz)
06:09:20 <chorhizo> Hey, I need to have a 'board' for a game of sorts, and need to update and broadcast the updated board every 100ms. Am I right in thinking I should use the state monad for this?
06:09:50 <chorhizo> there are asyncronous events from clients that will change how the board is updated
06:15:28 <lyxia> you could also use a shared variable
06:23:37 <chorhizo> lyxia, oh ok, I'll have a look at that
06:27:00 <zincy> How would I create a new clock value? data Clock = Clock { currentTime ::  UTCTime }
06:27:24 <zincy> All the functions I would think of return an IO Clock
06:28:23 <liste> what type is Clock? I can't find it in "time" package
06:28:54 <liste> is just that the definition?
06:28:57 <liste> wrapper over UTCTime
06:29:15 <zincy> I made it up
06:29:35 <liste> @let data Clock = Clock { currentTime ::  UTCTime }
06:29:36 <lambdabot>  .L.hs:158:35: error:
06:29:36 <lambdabot>      Not in scope: type constructor or class ‘UTCTime’
06:29:36 <lambdabot>      |
06:30:13 <zincy> getCurrentTime is in (Time) import Data.Time.Clock
06:30:26 <liste> yes
06:30:42 <liste> with it you can get the current time
06:30:56 <lyxia> chorhizo: I mean something like TVar in stm.
06:30:58 <liste> then you can just do Clock <$> getCurrentTime and that'd be IO Clock
06:31:13 <liste> though the name Clock is confusing
06:31:23 <liste> because it's just a single point in time, not a clock
06:31:30 <zincy> How would I get just a clock without the IO
06:31:38 <Garmy> What is a Clock for, in your case?
06:31:39 <zincy> yeah true
06:31:53 <chorhizo> lyxia, oh ok, I wonder if there's anything in Control.Concurrent.Chan i could use
06:31:54 <liste> zincy: by wrapping an UTCTime you construct in a Clock
06:32:12 <zincy> Its just an example for a record data type where there is a timestamp field
06:32:55 <zincy> you mean pattern match on the IO constructor?
06:33:06 <liste> zincy: no
06:33:32 <Garmy> Clock :: UTCTime -> Clock
06:33:45 <fr33domlover> zincy, you can have a record with a field of type Clock
06:33:52 <liste> zincy: Clock (UTCTime (ModifiedJulianDay 0) (secondsToDiffTime 0))
06:34:01 <liste> zincy: that way you have a Clock object
06:34:47 <lyxia> chorhizo: I don't know the difference actually
06:36:16 <zincy> What I am trying to do is get the current time so  Clock { currentTime = getCurrentTime :: IO UTCTime } but obviously that wont work
06:36:32 <zincy> sorry  Clock { currentTime = getCurrentTime }
06:36:34 <liste> zincy: you need to get the current time in IO
06:36:47 <zincy> How do I do that?
06:36:57 <liste> zincy: do currentTime <- getCurrentTime; foo (Clock currentTime); ...
06:37:33 <zincy> Yeah
06:37:47 <jmcarthur> zincy: A way to look at it is I think you are trying to create a Clock from an IO UTCTime, but you can't do that. You could instead create an IO Clock from an IO UTCTime.
06:38:34 <liste> zincy: note that in that do block there "currentTime :: UTCTime"
06:38:45 <liste> the "<-" took the time out of IO
06:40:05 <zincy> The confusing thing is that none of the functions in my code return an IO ()
06:40:20 <zincy> So now I have to figure out where to put this IO action
06:41:21 <cinimod> I am trying to upload my documentation to hackage
06:41:29 <jmcarthur> Whatever executes getCurrentTime is going to need to return IO. There's no getting out of that (other than hiding the IO in a newtype or something, but that doesn't make anything fundamentally different)
06:41:29 <cinimod> `cabal upload --publish -d hmatrix-sundials-0.19.0.0-docs.tar.gz`
06:42:19 <cinimod> https://www.irccloud.com/pastebin/gdfEmPr9/
06:42:29 <cinimod> But cabal is not playing
06:42:58 <cinimod> https://www.irccloud.com/pastebin/rhu69c6u/
06:45:08 <jmcarthur> zincy: If you want to keep IO out of your functions, then instead of them getting the current time themselves they could take the time as an argument.
06:58:39 * hackage hmatrix-gsl 0.19.0.1 - Numerical computation  http://hackage.haskell.org/package/hmatrix-gsl-0.19.0.1 (DominicSteinitz)
07:20:17 <ilya_yanok> I've just bumped into something that looks like optimizer bug in GHC 8.2.2, http://lpaste.net/365137
07:20:45 <ilya_yanok> it gives different results when compiled with -O0 and -O1 (or -O2)
07:21:20 <ilya_yanok> is it known/fixed?
07:24:04 <hpc> @lpaste
07:24:04 <lambdabot> Haskell pastebin: http://lpaste.net/
07:29:19 <fakenullie> Roskonnadzor blocked half of the internet including lpaste in attempt to block telegram
07:29:56 <ilya_yanok> what about github?
07:30:54 <fakenullie> GitHub seems to work
07:31:02 <lemmih> ilya_yanok: A smaller case is simply: main = print $ 0.0 * (-1.0)
07:31:36 <ilya_yanok> https://gist.github.com/yanok/0eb3fe660634378a85d4819d1c931ff0
07:32:10 <ilya_yanok> I copied my example to GH, but lemmih already gave a simpler one
07:33:07 <lemmih> ilya_yanok: I'm not sure it's a bug. Floating point numbers are weird. 0.0 = -0.0.
07:33:52 <ilya_yanok> Uh, ok
07:34:19 <lemmih> It kinda sucks that you can detect whether optimizations are enabled, though. :)
07:34:36 <hpc> eh, it's floats
07:35:08 <hpc> you can afford to be a bit imprecise with them
07:35:19 <lemmih> @define isOptimized = show (0.0 * (-1.0)) == "0.0"
07:35:20 <lambdabot>  Defined.
07:35:30 <lemmih> > isOptimzied
07:35:30 <ilya_yanok> but 1/0.0 != 1/(-0.0)
07:35:32 <lambdabot>  error:
07:35:32 <lambdabot>      • Variable not in scope: isOptimzied
07:35:32 <lambdabot>      • Perhaps you meant ‘isOptimized’ (line 157)
07:35:37 <lemmih> > is Optimized
07:35:39 <lambdabot>  error:
07:35:39 <lambdabot>      • Variable not in scope: is :: t0 -> t
07:35:39 <lambdabot>      • Perhaps you meant one of these:
07:35:46 <dminuoso> hpc: Fine, but only if some -fast-math flag exists that makes non-IEEE 754 FP arithmetic opt in.
07:36:00 <lemmih> > isOptimized
07:36:02 <lambdabot>  False
07:36:17 <hpc> dminuoso: ppsh, specs are more like suggestions :P
07:36:35 <hpc> wait a minute, this isn't #perl
07:36:37 * hpc gasps
07:42:39 * hackage hedis-config 1.0.0 - Easy trivial configuration for Redis  http://hackage.haskell.org/package/hedis-config-1.0.0 (AlekseyUymanov)
07:53:03 <LysergicDreams> In previous languages, I've mostly done unit testing. I'm finding it kind of hard to figure out when I should be using property testing instead. Is there a good resource that goes into that?
08:06:58 <lemmih> LysergicDreams: Well, you should use property testing whenever possible.
08:07:20 <fr33domlover> LysergicDreams, i don't know much about that but iirc property testing is when you describe a property and then inputs are randomly generated and the property is tested on them, so it's really nice to use whenever you can
08:07:32 <fr33domlover> because hundreds of test cases can be generated for free
08:08:06 <LysergicDreams> Right, I guess the hard part for me is looking at code and being like "these properties!"
08:09:01 <LysergicDreams> Like I understand how to property test & the benefits, but I guess I just find it hard to switch to that mindset
08:10:06 <LysergicDreams> It's easy for me to look at code & say "these are the edge cases that should be unit tested"
08:10:46 <fr33domlover> LysergicDreams, it's just a special case of getting used to pure functional languages
08:12:44 <lemmih> LysergicDreams: Properties are basically your expectations. You definite have expectations but they might not be completely verbal in your head. For example 'read.show = id' is something I expect to be true for types that I've defined myself.
08:13:36 <lemmih> LysergicDreams: That '\x set-> x `member` insert x set' holds true is an expectation I have of set libraries.
08:14:21 <lemmih> LysergicDreams: You basically write down all the "obvious" things that are true about your library.
08:16:24 <chorhizo> Hey, for a 2d list that I need to be able to change and access elements in relation to another point, an array would be better right?
08:17:01 <chorhizo> kind of a stupid question, but going from arrays being the #1 in imperative to lists and arrays being a more specific thing is confusing me
08:17:32 <fr33domlover> chorhizo, I say start with the most simple thing such as lists
08:17:41 <fr33domlover> and you'll gradually learn what to use when
08:18:08 <fr33domlover> the specific choice of container is a time and space optimization (well, and can help avoid space leaks)
08:18:11 <LysergicDreams> fr33domlover, lemmih: thanks for the feedback
08:18:31 <chorhizo> fr33domlover, that makes sense, thanks
08:18:45 <fr33domlover> chorhizo, but otherwise list, array, vector etc. have a lot in common so you could just start with lists
08:20:28 <ilya_yanok> there is also Seq
08:20:57 <ilya_yanok> array and vector are awkward in pure functional setting
08:22:11 <lemmih> Data.Vector isn't all that awkward, imo.
08:22:58 <ilya_yanok> I mean it's either updates are not cheap or you have to put all your code to IO/ST
08:23:55 <chorhizo> yeah interestingly enough I think I can just get away with not storing this in a 2d structure
08:24:10 <chorhizo> I think just a contiguous list of points is fine which fixes that
08:26:33 <fr33domlover> chorhizo, iirc if you use Data.Array you can use an array in which the index is a pair of coordinates and at runtime it's still just a plain 1d array while in the code it convenietly feels like a 2d array without the n*y+x tricks etc. (but i'm unsure about that, correct me if i'm wrong)
08:26:42 <fr33domlover> but that's just a little side note
08:27:05 <chorhizo> huh that's cool
08:27:32 <fr33domlover> chorhizo, that's because in Haskell there's a typeclass for the index iirc? while in C etc. it's plain integer
08:28:29 <chorhizo> makes sense, so I guess you could somehow create an instance for index for like a 20d array
08:30:08 <fr33domlover> chorhizo, https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Ix.html
08:30:14 <fr33domlover> yeah I guess you can
08:38:05 <jgznrj> Hello, I'm trying to follow Haskellbook ch31 fingerd example but when I type: sudo `stack exec which debug` and entered my password nothing happens.
08:38:34 <jgznrj> I'd appreciate any advice on this
08:39:19 <jgznrj> no prompt appears so I can't type: telnet localhost 79
08:41:18 <lemmih> jgznrj: What's the name of your executable?
08:42:12 <jgznrj> that's debug
08:42:35 <lemmih> jgznrj: Then you probably want: stack exec debug.
08:43:22 <lemmih> jgznrj: 'which' is a tool for locating a command/executable.
08:43:41 <lemmih> Oh, now I see.
08:44:04 <jgznrj> There is two executable set in fingerd.cabal
08:44:10 <lemmih> That commmand should work. What do you mean by nothing happens?
08:44:30 <lemmih> You're returned to the command prompt?
08:44:38 <jgznrj> no prompt appears. Just an empty line
08:44:42 <jgznrj> on my terminal
08:45:00 <lemmih> Isn't that to be expected? That means your program is running.
08:45:46 <jgznrj> ah.. ok. Then should I open another terminal to type "telnet localhost 79"?
08:45:49 <jgznrj> I will try
08:46:36 <jgznrj> oh..
08:46:40 <jgznrj> Working
08:47:01 <jgznrj> I'm a complete noob to linux and network
08:47:09 <jgznrj> Many thanks lemmih
08:47:16 <jgznrj> :D
08:48:49 <jgznrj> The book also says ".. you'll connect to it from a new terminal like so"
08:53:45 <donjoe3> I have the following
08:53:52 <donjoe3> may :: (Int, Int) -> Maybe ([Int], Int)
08:53:55 <donjoe3> may Nothing = Nothing
08:53:59 <donjoe3> may Just (a,b) = Just ([a,b], 1)
08:54:17 <donjoe3> It gives error "may has diff number of arguments"
08:54:29 <lemmih> donjoe3: There are a few different issues with that code.
08:54:29 <lyxia> may (Just (a, b))   <- that's one pattern
08:54:31 <[exa]> donjoe3: well, that error can be solved by putting parens about (Just ...)
08:55:05 <[exa]> donjoe3: second issue: how can (Int, Int) be Nothing ?
08:56:08 <donjoe3> hmm. so when Maybe is used, is it necessary to have any "Nothing" in any pattern?
08:56:45 <lemmih> donjoe3: What's the type of the first argument to 'may'?
08:57:00 <[exa]> donjoe3: you're using Maybe for the argument type (the function can take both Nothing and (Just ...)), but you say something completely different in the type signature
08:57:51 <donjoe3> I understand
08:58:06 <donjoe3> So, when would one use Maybe in parameters?
08:58:11 <donjoe3> what scenario?
08:58:54 <lemmih> donjoe3: Can you tell me what you think the type of the first argument to 'may' is?
08:59:16 <glguy> donjoe3: Use a (Maybe A) parameter any time you can handle either having or not having an A parameter
09:01:04 <donjoe3> lemmih: I understood that it is an (Int, Int). So I must not use "Nothing" or "Just " in parameters.
09:01:18 <[exa]> donjoe3: or the other way :]
09:01:41 <donjoe3> glguy: so if I want a function with variable number of parameters, I'd think of Maybe?
09:01:41 <[exa]> (make it (Maybe (Int, Int) )
09:01:58 <glguy> donjoe3: There's no "function with variable number of parameters"
09:02:01 <chorhizo> if I have a data type with like, 5 fields in record format, and I want to update one of these fields and return it, is there a better way than just pattern matching?
09:02:29 <chorhizo> I get the feeling that might be lens territory but it's a big library just to do that..
09:02:31 <glguy> chorhizo: There's record update syntax
09:02:43 <glguy> bump x = x { someField = someField x + 1 }
09:02:48 <chorhizo> glguy, oh thanks, I'll have a look
09:03:22 <donjoe3> glguy: Then I don't get what you mean by " Use a (Maybe A) parameter any time you can handle either having or not having an A parameter"
09:03:48 <glguy> You still have the same number of parameters, what changes is whether or not you get an A value
09:04:17 <donjoe3> could you give an example?
09:04:25 <donjoe3> 2 usage cases?
09:04:40 <glguy> :t showFFloat
09:04:41 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
09:04:55 <glguy> > showFFloat Nothing pi ""
09:04:57 <lambdabot>  "3.141592653589793"
09:05:02 <glguy> > showFFloat (Just 3) pi ""
09:05:04 <lambdabot>  "3.142"
09:06:49 <donjoe3> > showFFloat (Just 4) pi ""
09:06:51 <lambdabot>  "3.1416"
09:08:44 <jchia_1> For addressing the record problem, if I take the lens approach using makeLenses on my records with weird field names that start with underscore (e.g. _name, _age), how can I non-manually get Data.Csv.FromRecord and ToRecord instances for the records with non-weird column names (e.g. name, age)?  With aeson, I can use deriveJSON with fieldLabelModifier, but with cassava, I don't see anything.
09:08:55 <[exa]> donjoe3: generally any parameter that you would use to knowingly pass null in C/java
09:09:09 * hackage language-rust 0.2.0.27 - Parsing and pretty printing of Rust code  http://hackage.haskell.org/package/language-rust-0.2.0.27 (harpocrates)
09:09:32 <donjoe3> and an example with Maybe in the return?
09:09:40 <jchia_1> If I just try to derive generically I think I'll get column names that start with underscore.
09:09:46 <[exa]> :t lookup   --donjoe3
09:09:47 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
09:10:20 <[exa]> donjoe3: it finds a  in a list of (a,b); returns Nothing on failure
09:11:09 <donjoe3> exa: and in case it is found, it returs "Just x" or "x" is enough?
09:11:16 <[exa]> donjoe3: lookup 2 [(1,"test"), (2,"foo")] == Just "foo",  looking up 3 would return Nothing
09:11:42 <[exa]> it has to return Just x, simply "x" is a different type than Nothing and the types must be fixed
09:11:52 <donjoe3> Hmmm. makes sense
09:12:04 <lyxia> jchia_1: genericParseRecord and genericToRecord take an Options parameter
09:12:54 <donjoe3> And could it work if we had "data Maybe a = Nothing | a" as definition?
09:12:55 <[exa]> if you're coming from imperative languages, you can view "Just" as a marker for "this is not null: "
09:12:59 <lyxia> jchia_1: the haddocks are awful but fieldLabelModifier is an exported field so you can use that with record update syntax on defaultOptions
09:13:30 <[exa]> donjoe3: no, the data definition expects proper data constructor names as a first thing in each field
09:14:05 <donjoe3> Ok, I meant "data Maybe a = Nothing | Num a"
09:14:21 <[exa]> donjoe3: also, if you would then use just '3', it would be ambiguous -- with your definition, it could have type 'Int', or 'Maybe Int' or even 'Maybe (Maybe Int)'
09:14:55 <[exa]> yes that would work, except the "Num" name is traditionally used for something a bit different :]
09:15:24 <donjoe3> I see
09:16:53 <donjoe3> Ok. Another example. I have foo :: (Int, [(Int, Int, Int)]) -> Maybe ([Int], Int)
09:16:57 <donjoe3> foo (0, [(0,0,0)]) = Nothing
09:17:00 <donjoe3> foo (n, [(a,s,d)]) = Just ([1,1,2], 1)
09:17:15 <donjoe3> Error: Non-exhaustive patterns in function
09:17:51 <rotaerk> donjoe3, what if the argument is (5, [(0,0,0),(1,2,2)])
09:17:53 <[exa]> why not try it curried?
09:18:10 <[exa]> ....or (5, []).
09:19:54 <donjoe3> hmm
09:19:55 <jchia_1> lyxia: Thanks
09:20:06 <donjoe3> actually the program loads. that error is coming from something else
09:20:15 <cheater> if i have those definitions, what type would i assign to a function called repeatVecN that repeats a single element n times? http://lpaste.net/365138
09:20:58 <[exa]> donjoe3: well the fact that the function is not defined for all cases _is_ a run-time error, so it will load and fail when the problem is hit
09:21:09 <lyxia> cheater: forall n. (... n) => a -> Vec n a
09:21:47 <donjoe3> I understand. Ok, thanx. And excuse my ignorance. I've been doing Haskell for less than 1 week.
09:22:07 <rotaerk> what's (... n)? actual syntax or just you omitting boring details?
09:23:02 <[exa]> donjoe3: it also seems that you're mixing tuples with lists a bit. tuples are fixed-size (e.g. (a,b,c) for 3-vectors), lists have variable size from 0 to infinity
09:23:14 <bnineninecortez> join
09:23:35 <[exa]> donjoe3: but I possibly just don't see the intended result :]
09:23:38 <lyxia> rotaerk: omitting details
09:24:19 <rotaerk> k just making sure
09:24:48 <donjoe3> I know that. What I don't know is how can I understand that from the type, say "may :: (Int, Int) -> Maybe ([Int], Int)" the parameter is a tuple or a function which takes 1 parameter
09:25:32 <[exa]> donjoe3: in that case the parameter is a tuple of 2 ints
09:25:55 <donjoe3> How can you know for sure?
09:26:24 <cheater> lyxia: what details would i put there?
09:26:27 <[exa]> donjoe3: it's written there. the function types are always ( parameter -> return value )
09:27:03 <rotaerk> donjoe3, (a,b) is never a function that takes a parameter a and returns a value of type b; it's always a 2-tuple
09:27:27 <donjoe3> oh, the function would have to be (Int -> Int). Silly me
09:27:55 <cheater> lyxia: that doesn't type.
09:28:25 <lyxia> cheater: a type class that matches on n and produces the vector of the right length
09:29:25 <fr33domlover> Persistent question: I upgraded to persitent 2.8.2 and it has this BaseBackend type family, I updated my code to make it build but I have this new constraint, is there a way to remove it? https://dev.seek-together.space/s/fr33domlover/r/persistent-migration/s/src/Database/Persist/Migration.hs#L-217
09:29:48 <fr33domlover> nevermind I'll ask again when this ping timeout mess is over :p
09:29:50 <freeman42x]NixOS> got a question about finding window PID: https://stackoverflow.com/q/49968223/750216
09:30:49 <lyxia> cheater: or a singleton constraint https://stackoverflow.com/questions/49709113/replicate-function-for-a-length-indexed-list-using-ghc-typelits-and-singletons
09:30:54 <fr33domlover> Persistent question: I upgraded to persitent 2.8.2 and it has this BaseBackend type family, I updated my code to make it build but I have this new constraint, is there a way to remove it? https://dev.seek-together.space/s/fr33domlover/r/persistent-migration/s/src/Database/Persist/Migration.hs#L-217
09:31:05 <donjoe3> And could I use both Nothing and Just in the same pattern?
09:31:08 <fr33domlover> The SchemaVersionGeneric type is not exported
09:31:19 <fr33domlover> So I don't like that it's used in a constraint
09:31:24 <fr33domlover> Idk if it's a big deal tbh
09:31:26 <donjoe3> say, in 2 different "if" cases
09:31:57 <donjoe3> My guess is "yes". Am I Right?
09:32:01 <lemmih> donjoe3: I don't understand your question.
09:32:33 <donjoe3> foo x = if something then (Just x) else Nothing
09:32:39 * hackage propellor 5.3.5 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-5.3.5 (JoeyHess)
09:33:00 <donjoe3> does that have any sense?
09:33:09 <lemmih> donjoe3: That code looks just fine.
09:33:19 <lemmih> > if True then Just 10 else Nothing
09:33:21 <lambdabot>  Just 10
09:34:48 <donjoe3> > if True then 2 else Nothing
09:34:50 <lambdabot>  error:
09:34:50 <lambdabot>      • No instance for (Num (Maybe ())) arising from a use of ‘e_12’
09:34:50 <lambdabot>      • In the expression: e_12
09:35:13 <donjoe3> so if and else must return same type
09:35:14 <donjoe3> ?
09:35:22 <lemmih> donjoe3: Yes.
09:35:44 <donjoe3> is it because if and else are actually implemented as function in haskell?
09:36:40 <donjoe3> or because if would make the program "impure" if they could return different types?
09:36:51 <rotaerk> not a function, but it's an expression; both branches of it have to produce a value of the same type
09:37:50 <donjoe3> I was curios what's the point of this behavior?
09:38:09 <rotaerk> the point of what
09:38:11 <lemmih> donjoe3: It's because Haskell is statically typed.
09:38:34 <donjoe3> if "print_a_char" then 'a' else 1
09:38:40 <donjoe3> this would not be possible
09:38:52 <[exa]> ofcourse. but you can use Either
09:38:53 <lemmih> donjoe3: What would the type of that expression be?
09:38:54 <pavonia> If both branch results could have different types, you'd have expressions with a different type depending on the value of the condintion
09:39:03 <rotaerk> > if True then putStrLn "a" else putStrLn "b"
09:39:05 <lambdabot>  <IO ()>
09:39:05 <lemmih> donjoe3: Would it be a number or a character?
09:39:18 <donjoe3> pavonia: And that is not possible?
09:39:41 <pavonia> Not in Haskell
09:39:48 <donjoe3> I understand now
09:40:01 <[exa]> donjoe3: you don't want the type signature of your function change unpredictably during the computation, that would obliterate all advantages of static typing
09:40:02 <donjoe3> Because predefining the type would be useless
09:40:12 <donjoe3> Yeah, makes sense
09:40:14 <[exa]> donjoe3: but you can do that using Either
09:40:48 <[exa]> again it only needs a bit of value tagging so that the compiler knows which result variant you're talking about
09:41:02 <[exa]> e.g.:
09:41:34 <[exa]> :t \x -> if x then Left 5 else Right "asasda"
09:41:35 <lambdabot> Num a => Bool -> Either a [Char]
09:42:13 <[exa]> that function takes a boolean, and returns either the numeric 'a', or [Char] (which is String)
09:42:19 <johnw> How is Haskell at optimize a "record of functions" compared to using a type class?
09:43:07 <donjoe3> exa: But why would one need something like this? Is it so that Haskell has more flexibility?
09:43:08 <aarvar> @let data IsIntOrChar a where IsInt :: IsIntOrChar Int; IsChar :: IsIntOrChar Char
09:43:09 <lambdabot>  Defined.
09:43:25 <cocreature> johnw: https://mpickering.github.io/posts/2018-03-20-recordsvstypeclasses.html seems relevant
09:43:44 <johnw> great, thanks!
09:44:07 <johnw> i'm in a case right now where type classes are not the right choice, abstraction wise, but I've been using them solely for the specialization effect
09:44:17 <aarvar> > let foo :: IsIntOrChar a -> a; foo x = case x of IsInt -> 1; IsChar -> 'a' in foo IsInt
09:44:19 <lambdabot>  1
09:44:26 <[exa]> johnw: afaik in the current typeclass implementation the dictionaries are just functions that pattern-match on types; I guess you can make it a bit faster if your usecase is not as general
09:44:29 <cocreature> the gist of that blogpost is that GHC only does specialization of records in the same module
09:44:40 <cocreature> wheras typeclasses will be specialized across modules
09:44:57 <aarvar> [exa]: there's no pattern matching on types. What?
09:45:08 <lol-md5> GNU = GNU's Not Unix. I'm trying to turn this into anonymous recursion. Here's what I have:
09:45:20 <lol-md5> (\x -> x x)(\f -> f f ++ "'s Not Unix")
09:45:22 <lol-md5> is this correct?
09:45:30 <[exa]> aarvar: not in front-end haskell ofcourse. :]
09:45:46 <aarvar> [exa]: not anywhere?
09:46:05 <[exa]> lemme double-check
09:46:07 <aarvar> the types all get erased, so I don't know how they would be pattern matched
09:46:22 <lemmih> lol-md5: 'f' is a String, not a function.
09:47:01 <aarvar> johnw: a typeclass compiles to a record of functions
09:47:56 <lol-md5> lemmih, ok, maybe haskell isn't the right language to encode this joke
09:47:56 <cheater> lyxia: i don't understand how that would work with the type class
09:48:43 <lemmih> lol-md5: (\x -> x x)(\f -> f ++ "'s Not Unix") should work.
09:49:01 <aarvar> lol-md5: you need to use an Isorecursive type to make the y combinator typecheck
09:49:37 <[exa]> aarvar: oh it's behind a coercion, silly me.
09:49:44 <lemmih> > fix (\f -> "GNU (aka " ++ f ++ ") is Not Unix")
09:49:46 <lambdabot>  "GNU (aka GNU (aka GNU (aka GNU (aka GNU (aka GNU (aka GNU (aka GNU (aka GNU...
09:49:56 <aarvar> [exa]: what's behind a coercion?
09:51:16 <lol-md5> :t fix
09:51:17 <lambdabot> (a -> a) -> a
09:52:18 <rotaerk> fix f = let x = f x in x
09:52:30 <lol-md5> oh fix is the fixed point comb?
09:53:23 <lol-md5> hm
10:01:40 <lol-md5> with "GNU (aka GNU (aka GNU (aka GNU (aka GNU (aka GNU (aka GNU (aka GNU (aka GNU...", the name of the acronym is known before it is evaluated
10:02:01 <lol-md5> is there a way to get haskell stuck at 's Not Unix, and then work its way up to GNU, but never stop?
10:03:08 <lemmih> Where would the 'G' come from?
10:06:09 * hackage crdt 10.0 - Conflict-free replicated data types  http://hackage.haskell.org/package/crdt-10.0 (cblp)
10:06:20 <Shmo> > map read ["64","48"]
10:06:23 <lambdabot>  [*Exception: Prelude.read: no parse
10:06:28 <Shmo> Why doesn't that work?
10:06:55 <lemmih> > map read ["64", "48"] :: [Int]
10:06:57 <lambdabot>  [64,48]
10:07:02 <lemmih> > map read ["64", "48"] :: [Bool]
10:07:04 <lambdabot>  [*Exception: Prelude.read: no parse
10:07:15 <Shmo> Ooh, I see
10:07:33 <Shmo> map (x -> read x :: Integer) ["64","48"]
10:07:41 <Shmo> > map (x -> read x :: Integer) ["64","48"]
10:07:43 <lambdabot>  error:
10:07:43 <lambdabot>      Pattern syntax in expression context: x -> read x :: Integer
10:08:04 <lemmih> > map (\x -> read x :: Integer) ["64","48"]
10:08:06 <cheater> can someone help me write a simple function that'll take a single value and put it in a Vec (indexed by Nat) n times?
10:08:06 <lambdabot>  [64,48]
10:08:13 <cheater> without using external libraries
10:08:17 <cheater> i'm not sure how to do this
10:08:47 <Shmo> Oh, wow, lemmih , thank you.  Here I go again thinking I see something deep only to realize I'm a complete newb
10:11:20 <DigitalKiwi> sounds like homework coming from someone named cheater :P
10:12:14 <Shmo> Me, DigitalKiwi ?  Flattered, but I'm 35 and learning on my own
10:12:55 <DigitalKiwi> well I was talking to cheater but if you identify as a cheater then well who am I to judge
10:12:59 <ddellacosta> cheater: maybe this is helpful? http://www.parsonsmatt.org/2017/04/26/basic_type_level_programming_in_haskell.html
10:13:05 <Shmo> Oh, hahaha!
10:13:11 <lol-md5> lemmih the G would be unresolved
10:13:17 <lol-md5> since it is in real life
10:13:21 <ddellacosta> not sure if that's more than you're trying to do from your description
10:13:31 <lol-md5> you could say FNU = FNU's Not Unix, to the same effect
10:14:41 <cocreature> cheater: you’re probably going to have to make a typeclass for that and then do typeclass induction on the Nat
10:14:51 <fr33domlover> Hmmm did something in GHC 8.2 change about type families? I'm building yesod-auth-account and getting "Couldn't match type ‘UserAccount db0’ with ‘UserAccount db’" and "NB: ‘UserAccount’ is a type function, and may not be injective"
10:16:51 <fr33domlover> It's like 'db' is used in type sig of a class method but it's not recognized as the same 'db' from the 'class .... db ... where
10:18:36 <cocreature> fr33domlover: hm are you sure that it’s yesod-auth-account that’s causing problems? matrix claims that it builds successfully with 8.2 https://matrix.hackage.haskell.org/package/yesod-auth-account
10:19:02 <absence> does anyone know what the correct way to pass rts arguments via stack exec is? the examples i find on the web don't work, i.e. "stack exec -- echo hello +RTS -p" results in "hello"
10:19:03 <fr33domlover> cocreature, yeah I checked there but I'm getting an error
10:19:28 <fr33domlover> cocreature, i'll try a clean build again idk
10:19:44 <cocreature> fr33domlover: showing us the full error might also be helpful
10:19:52 <lemmih> absence: Replace 'echo hello' with the program that you want to run. :)
10:20:18 <cocreature> absence: do you want to pass the rts arguments to stack exec itself or to the program that you run via stack exec?
10:22:55 <lemmih> absence: Oh, you're saying that stack ate the RTS flag? I'm not seeing that. Maybe your stack is old.
10:23:40 <fr33domlover> cocreature, http://lpaste.net/365142
10:25:01 <fr33domlover> cocreature, there's a fundep master->db but for some reason it's like it doesn't see it suddenly
10:25:20 <fr33domlover> or at least it seems so if I'm reading the type sigs in that error right
10:30:26 <absence> cocreature: i want to send rts arguments to my program, not stack itself
10:31:31 <absence> lemmih: i think it's a windows thing, 1.6.5 isn't that old
10:31:41 <lemmih> absence: 'stack exec -- echo hello +RTS -p' gives the expected result for me. Are you sure it doesn't work for you?
10:33:08 <cocreature> fr33domlover: interesting, it looks like the type mismatch occurs before it unifies master and master0 so at that point the fundep won’t help. but I have no idea why that’s the case
10:33:14 <cocreature> fr33domlover: maybe try 8.4?
10:33:32 <absence> lemmih: nm, i found it. "stack exec --rts-options -p echo hello" produces "hello +RTS -p -RTS"
10:34:34 <fr33domlover> cocreature, hmm yeah i'll try. i was using stackage lts 6.5 (ghc 7.10.3) and made a leap straight to 11.5 (ghc 8.2.2) and now getting the error. i'll try ghc 8.4. any ideas how i could further debug that thing? /me tries with ghc 8.4
10:34:44 <absence> lemmih: you can see from the output that the original with -- and +RTS doesn't work, it just produces "hello"
10:35:10 <lemmih> absence: Peculiar that Windows differ from Linux/Mac in this regard.
10:38:31 <absence> lemmih: ah, it's a ghc bug
10:39:21 <absence> lemmih: fixed in 8.2, probably my stack exe isn't built with that
10:40:24 <cocreature> fr33domlover: ah so the problem appears to be that "master" is also not deducible from the type signature since it’s only used as an argument to MonadRoute
10:40:49 <cocreature> hm no that’s wrong
10:42:28 <cocreature> I’m failing to come up with a minimal example that suffers from the same problem
10:43:46 <lyxia> HandlerT now ignores it second argument https://hackage.haskell.org/package/yesod-core-1.6.3/docs/Yesod-Core-Handler.html#t:HandlerT
10:44:35 <cocreature> oh so the problem is the new version of yesod-core
10:44:45 <cocreature> I was following the haddock link which points to an older version
10:44:49 <cocreature> yeah then it makes sense
10:45:07 <cocreature> ^ fr33domlover in case you missed it
10:45:14 <sqooq> hi
10:47:45 <fr33domlover> lyxia, cocreature, thanks! You think that's the issue? I'll try to switch to "type HandlerFor site" and see if it helps
10:48:20 <cocreature> fr33domlover: yep from the new HandlerT type family you can’t deduce what "master" is supposed to be so you can’t apply the fundep to figure out "db"
10:48:33 <cocreature> HandlerFor won’t help since it also doesn’t tell you what "master" is
10:48:46 <fr33domlover> cocreature, hmmmmmm what do I do then?
10:53:45 <cocreature> fr33domlover: I don’t know enough about yesod to answer that. https://github.com/yesodweb/yesod/commit/61c887f5014f3090ce5237609237edfa26eafcb2#diff-0c28e3f67478f198b35c41e78c806b39 might be helpful as an example of how to adapt to the new API
10:54:12 <fr33domlover> Thanks cocreature
11:18:51 <absence> i'm profiling a program that causes insane amounts of memory allocation (2 GB/s), but max residency is only 2 MB. half of the allocation is by this line: https://github.com/michaelt/streaming/blob/master/src/Data/Functor/Of.hs#L26 is there a trick to make it allocate less, or do i just have to make sure it's called less often?
11:20:53 <hpc> ghc is good at massive allocation, most of the time it's just a register increment
11:20:55 <lemmih> absence: Did you enable optimizations? And how much time is spent in GC?
11:21:07 <hpc> as long as all the data stays young it gets cleaned up efficiently too
11:21:58 <johnw> keep your data looking healthy and young
11:22:01 <DigitalKiwi> what would happen if you ran that on say a raspberry pi with 1gb of ram would it fail or would it GC sooner or?
11:22:17 <hpc> max residency is the number to look at for "actual" memory use
11:22:33 <hpc> the allocation number is more along the lines of measuring your bus bandwidth
11:23:22 <DigitalKiwi> oh so it's really only like 2MB so not a problem
11:23:29 <hpc> yeah
11:23:30 <absence> lemmih: good question! is optimisation enabled by default in stack? it spends a little less than half the execution time in gc
11:23:35 <EvanR> retire confirmed old data to compact regions retirement community!
11:23:55 <EvanR> dont let them be driving around at all hours
11:24:44 <DigitalKiwi> OLD DATA IS PEOPLE -- charlton heston
11:25:11 <hpc> i am not an object, i am a free variable!
11:25:32 <EvanR> the old data compactor
11:25:35 <DigitalKiwi> I was really impressed earlier someone explained Maybe to someone and didn't bring up boxes
11:25:37 <EvanR> for you
11:25:39 <DigitalKiwi> eggs*
11:25:55 <hpc> r2, shut down the garbage collector on cpu0
11:25:59 <hpc> no, shut them all down, hurry!
11:27:11 <DigitalKiwi> dude that movie is like 40 years old how are we supposed to catch that reference
11:27:45 * DigitalKiwi whistles innocently since soylent green is older...shhh
11:27:54 <EvanR> the amount of money still being made on it
11:28:25 <hpc> DigitalKiwi: my other reference was the prisoner, which is one of the first "popular" tv shows ever
11:28:42 <DigitalKiwi> heh
11:29:01 <hpc> the last episode of that show was the super bowl before the super bowl
11:29:09 <DigitalKiwi> I thought it sounded familiar but I couldn't have told you from where
11:29:22 <hpc> and then the big twist was onscreen for a 0.25s long shot, and it made everyone mad
11:29:44 <DigitalKiwi> oh it's british
11:29:48 <hpc> yeah
11:30:52 <DigitalKiwi> If it's not monty python or a few of their comedy shows/comedians I don't know it...I've never seen Dr Who but I have read a bit about it
11:31:34 <DigitalKiwi> I'm sure there are other exceptions :|
11:32:32 <EvanR> :t concat (intersperse x xs)
11:32:33 <lambdabot> error:
11:32:33 <lambdabot>     • Couldn't match type ‘Expr’ with ‘[a]’
11:32:33 <lambdabot>       Expected type: [[a]]
11:33:05 <EvanR> :t concat (intersperse "x" ["x1", "x2", "x3"])
11:33:06 <lambdabot> [Char]
11:33:26 <EvanR> why is this utility not a thing by default
11:33:48 <EvanR> 96% of all js code is split and join
11:34:42 <cocreature> EvanR: are you looking for intercalate?
11:34:50 <cocreature> :t intercalate
11:34:50 <DigitalKiwi> why is <some feature in js> not a common thing in hs?
11:34:51 <lambdabot> [a] -> [[a]] -> [a]
11:34:57 <cocreature> :t \x xs -> concat (intersperse x xs)
11:34:58 <lambdabot> [a] -> [[a]] -> [a]
11:35:10 <cocreature> at least the types work out :)
11:35:12 <EvanR> > intercalate ":" (map show [1..4])
11:35:13 <DigitalKiwi> s/feature/idiom/
11:35:14 <lambdabot>  "1:2:3:4"
11:35:17 <EvanR> yes
11:36:11 <EvanR> i lose track after forgetting for the 100th time whether to use intersperse or interleave
11:36:38 <DigitalKiwi> what do they do
11:36:44 <EvanR> no idea
11:36:51 <zezeri> hello :)
11:37:09 * EvanR does glue = intercalate and moves on
11:38:44 <DigitalKiwi> http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-List.html#v:intersperse
11:38:49 <johnw> even unsplit would have been more memorable
11:39:45 <DigitalKiwi> there's words/unlines
11:40:02 <DigitalKiwi>  /unwords
11:42:24 <EvanR> interceded, interchain, intercluster, interconnect, intercouple, interfuse, intergraft, interknit in this dictionary they could had added for good measure
11:42:39 <EvanR> that do random other stuff
11:44:30 <opqdonut> interject
11:44:36 <DigitalKiwi> I have no idea what any of those should do without looking at the type :|
11:45:12 <Tuplanolla> There's no shortage of options in `aspell -d en_US dump master | grep '^inter' | sort`.
11:45:48 <EvanR> we need a whole acme-interfunctions
11:56:37 <zezeri> Unable to start C:\Program Files\Haskell Platform\8.2.2\bin/ghc.exe (error code: 193)
11:56:42 <zezeri> Anyone know why this happens?
12:03:59 <sclv> ZeuPiark: look at that path. why is the last slash backwards?
12:04:09 <sclv> or rather, not backwards
12:19:42 <dpyro> man, there is 0 documentation for Network.Wai.Test!
12:47:31 <infinisil> dpyro: Write some!
12:47:54 <dpyro> i dont know how to use it outside the test it has!
12:55:42 <dpyro> is there anyway to convert a ClientM a → Request for servant-client?
12:55:42 <hackage> ACTION validity-aeson 0.2.0.0, validity 0.5.0.0, genvalidity-aeson 0.2.0.0, genvalidity 0.5.0.0, validity-time 0.2.0.0, validity-text 0.3.0.0, validity-scientific 0.2.0.0, validity-path 0.3.0.0, validity-containers 0.3.0.0, validity-bytestring 0.3.0.0, genvalidity-bytestring 0.2.0.0, genvalidity-vector 0.2.0.0, genvalidity-uuid 0.1.0.0, genvalidity-unordered-containers 0.2.0.0, genvalidity-time 0.2.0.0, genvalidity-text 0.5.0.0, genvalidity-scientific 
12:56:28 <dmj`> dpyro: you’re supposed to just call runClientM :: ClientM a -> ClientEnv -> IO (Either ServantError a)
12:56:53 <dpyro> i'm trying to test a client without having to fork a whole server
12:57:23 <dpyro> hspec-wai seemst to want urls and  wai-extras wants a Request
12:58:13 <dmj`> dpyro: why not just use servant-client functions in the hspec it blocks, and have the server run in a separate thread
12:59:13 <dpyro> with hspec-wai i can just do with (return app) $ describe ...
12:59:32 <dmj`> dpyro: so you want to evaluate the server handlers
12:59:34 <dpyro> i just dont want to spin up a whole server in a different thread with its own port etc.
12:59:44 <dpyro> i want to test the client
12:59:50 <dpyro> the server is just a stub response thingy
12:59:56 <dmj`> dpyro: I do that, it’s more realistic imo, since its a real round trip
12:59:57 <dpyro> that i used to generate the client functions
13:00:11 <dpyro> alrighty
13:18:23 <nshepperd> DigitalKiwi: a Maybe is like an egg that might hatch into an animal or might be rotten?
13:19:08 <DigitalKiwi> yeah don't count your maybes before they hatch
13:19:28 <EvanR> a thunk is like an egg that might hatch into a WHNF or be bottom
13:22:09 <edwardk> wow, this instance terrifies me: http://hackage.haskell.org/package/wl-pprint-text-1.1.1.1/docs/Text-PrettyPrint-Leijen-Text-Monadic.html#v:-36-fIsStringm
13:22:53 <EvanR>  fromString = string . T.pack ?
13:23:23 <nshepperd> and fmap is a magic wand that lets you manipulate the baby animal before it's been born
13:24:46 <EvanR> maybe there should be a haskel tutorial for wizards
13:25:25 <EvanR> matrix.org taking a shit on IRC again
13:25:29 <Clint> choo choo
13:25:50 <hpc> surely they could act like a regular node on the network somehow, and have normal netsplits
13:26:14 <Clint> yes, because normal netsplits aren't annoying at all
13:26:25 <hpc> well they're way fewer lines
13:26:43 <nshepperd> aren't normal netsplits exactly the same?
13:26:56 <Clint> depends how your client detects netsplits
13:26:58 <nshepperd> you see everyone on the other partition as having quit/joined
13:26:58 <hpc> a haskell tutorial for wizards would be pretty funny
13:27:20 <EvanR> wait i think they already have that
13:27:27 <[exa]> edwardk: whoa monadic ppr looks cool
13:27:38 <edwardk> hpc: like how you first take thy eye of newt and insert it into the boiling water...
13:27:44 <[exa]> hpc: "lower your wizardry expectations to plain monads"
13:28:15 <EvanR> thats witches edwardk
13:28:18 <EvanR> different
13:28:21 <edwardk> [exa]: well, right now its causing me to rip out code that transitively depends on this package lest that instance find its way into scope
13:29:09 <edwardk> EvanR: how often would you say the matrix pseudo-netsplit problem kicks in?
13:29:51 <edwardk> EvanR: just soliciting feedback because we added the matrix stuff a while back and never really checked around to see if it was a pain point in practice.
13:29:58 <EvanR> when they are really having issues, it can happen constantly
13:30:25 <EvanR> when it seems to be working, maybe every few days. or once a week?
13:30:56 <edwardk> k. will try to keep a closer eye on it
13:31:27 <EvanR> what was your issue with that IsString Doc instance
13:31:30 <edwardk> given the number of users on the other side i'm not in a hurry to say 'failed experiment' or anything, but its good to know the level of pain.
13:32:16 <edwardk> EvanR: instance IsString (MyDataType a) -- oh crap overlap
13:32:18 <EvanR> (i've actually noticed very few netsplits in recent history)
13:32:46 <srid> Does anyone why automatic deriving of `Read` on GADT doesn't work here?  https://www.irccloud.com/pastebin/FuBpow2O/a.hs
13:33:11 <srid> (full ghc error) https://www.irccloud.com/pastebin/rSUerSHK/
13:33:18 <EvanR> how is instance IsString Doc and instance IsString (MyDataType a) overlapping
13:33:27 <edwardk> IsString (m Doc)
13:33:36 <edwardk> m = MyDataType, a = Doc
13:34:08 <EvanR> oh i see it at the bottom now
13:34:25 <EvanR> yeah that makes no sense
13:35:41 <lyxia> srid: how should it instantiate a
13:35:43 <edwardk> [a] -- has an IsString instance with a context a ~ Char.. Given a [Doc]  in scope, both of those instances overlap and want to do different things. the IsString String instance wants to force Doc ~ Char into scope and would fail but only after backtracking, while the m Doc one wants to make a singleton list...
13:36:21 <EvanR> we need a DoWhatIMean extension
13:36:38 <EvanR> and program everything with string literals!
13:36:38 <srid> lyxia:  `read :: a`? (`a` has a Show and Read instance, per line 11,12)
13:36:49 <srid> and line 9
13:37:08 <nshepperd> srid: what should 'read "Stuff []" :: Stuff' contain
13:37:28 <nshepperd> where are you going to get a Show and Read dictionary from, and for what type
13:38:41 <srid> `a` will be arbitrary, as long as they have a Read/Show instance you can construct `Foo Whatever` and put it in Stuff
13:38:52 <nshepperd> it can't be arbitrary
13:39:00 <srid> That's what `forall.` achieves, no?
13:39:08 <DigitalKiwi> edwardk I wouldn't even know there was a problem with it if you weren't talking about it since I disabled join/parts which is what most people do if they are bothered by that kind of thin ;)
13:39:19 <crestfallen> EvanR et al if I could ask some questions based on chat the other day regarding the laziness of (:) and it being the node of an AST  -- using fishy*thefish example ...
13:39:48 <srid> Essentially I'm writing a todo list, where individual items can be values of different types (customizable in future ,via plugins)
13:40:03 <nshepperd> srid: case matching on Stuff grants the ability to read/show a type
13:40:11 <srid> A GADT would be suitable here, as I can do `MkItem JournalType` and then later `MkItem FoodLogType`
13:40:18 <crestfallen> @let myPred = not . myPred
13:40:20 <lambdabot>  Defined.
13:40:31 <srid> but I want to keep the x in `MkItem x` as a discrete type to do stuff
13:40:31 <nshepperd> where does that come from, in 'case read "Stuff []" of { Stuff _ -> ... }'
13:40:32 <lyxia> srid: If you read "Stuff [MkFoo 3]", should it be an Int, Integer, Word, Natural, or something else?
13:40:45 <edwardk> EvanR: i'm pretty sure mightybyte wrote an acme-dwim package with a DoWhatIMean typeclass. i just don't think he ever shipped it
13:40:49 <crestfallen> > head (0 : filter myPred [1..]
13:40:51 <lambdabot>  <hint>:1:30: error:
13:40:51 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:40:58 <crestfallen> > head (0 : filter myPred [1..])
13:41:00 <lambdabot>  0
13:41:05 <trcc> Hi everyone. I have an issue with Haskell not terminating a process when using terminateProcess. I do not get any errors. http://lpaste.net/4827089657797804032
13:41:26 <EvanR> crestfallen: whats the question
13:41:33 <crestfallen> one sec
13:42:15 <srid> nshepperd: lyxia: Ya, I see what you mean. In my application, `x` will be a set of known types. "Stuff [MkFoo JournalType, MkFoo FoodLogType]" etc.
13:42:18 <crestfallen> > myPred 1
13:42:25 <lambdabot>  mueval-core: Time limit exceeded
13:42:25 <lambdabot>  mueval: ExitFailure 1
13:42:49 <EvanR> :t myPred
13:42:51 <lambdabot> a -> Bool
13:43:17 <EvanR> ah predicate
13:43:34 <srid> nshepperd: lyxia For some background context, I had been using JSON to encode/decode values; but that fails with GADTs (there is no automatic aeson deriving for GADTs), so I figured I just use show/read instead of json ...
13:43:39 <crestfallen> first I don't understand why s/he used @let myPred = not . myPred
13:43:45 <srid> It works mostly, but breaks down at `read`
13:43:52 <EvanR> crestfallen: its a bool test that freezes up
13:44:03 <EvanR> because its badly recursive
13:44:20 <srid> Also, `Stuff` doesn't have a type variable, as it is a stuff is _disparate_ types.
13:44:27 <srid> s/stuff is/stuff of/
13:45:20 <EvanR> they used myPred to demonstrating filtering by a broken function, and how it didnt cause any problems in the end due to laziness
13:46:09 <lyxia> srid: use a sum type if you know what they are
13:46:12 <crestfallen> thanks Evans so you were talking about (:) as a node in the AST ...
13:46:17 <crestfallen> EvanR
13:46:37 <srid> lyxia: That's what I'm using already, but I want to be able to pass around the individual types to functions. sum type constructors won't fit the bill
13:46:48 <EvanR> _ : _ yes
13:47:03 <srid> eg: `rendeUI :: IsTask x => x -> m ()`
13:47:17 <crestfallen> where we had x : filter (/= x) (rmdups xs)   ...
13:47:37 <crestfallen> you said (:) was in the highest spot
13:47:46 <crestfallen> so on the rhs ..
13:48:02 <crestfallen> what is the node on the rhs ? in the filter expression?
13:48:04 <lemmih> trcc: Did you read the documentation for 'terminateProcess'?
13:48:20 <trcc> Yes. I think it has to do with my if inside launch maestro
13:48:25 <trcc> lemmih
13:48:40 <EvanR> (filter (/= x)) (rmdups xs)
13:48:53 <EvanR> the space in the middle there is a node
13:49:21 <trcc> lemmih: hmm no.. Still cannot get it to work. Works if I just keep it all in main without invoking other functions, so must be something related to that
13:50:21 <EvanR> f x y z = ((f x) y) z
13:50:32 <nshepperd> srid: well the short answer is that sort of Read instance for an existential is impossible
13:50:46 <lemmih> trcc: If you keep what in main?
13:50:49 <crestfallen> the space ok that's interesting
13:51:16 <srid> hmm, alright. thanks nshepperd and lyxia.
13:51:24 <lyxia> srid: what's wrong with rendeUI :: SumType -> m ()
13:51:29 <srid> it is sad to not be able to use GADTs because no aeson deriving
13:51:33 <nshepperd> you're asking the 'read' function to conjure up from nowhere an instance for both Read and Show for an unknown type
13:51:36 <trcc> lemmih just do:  hdl <- fmap Just $ spawnCommand "Java -jar resources/maestro.jar >> MaestroProcessOutput" instead of hdl <- launchMaestro
13:51:44 <EvanR> you could think of fun application as a left assoc operator... f x y z = f @@ x @@ y @@ z
13:51:51 <EvanR> but we use blank space instead
13:52:09 <srid> lyxia: it prevents a plugin like model. now you have the UI for all plugins in a case block of a single monolithic function
13:52:11 <Xal> what if we instead used a box
13:52:13 <crestfallen> so if I really cast out the idea of a stack, that I learned in scheme (I had the idea in scheme in error as well?) I can start thinking like this.
13:52:25 <EvanR> scheme has the same thing
13:52:42 <crestfallen> the AST idea?
13:52:46 <lemmih> trcc: That very much should not be the case. Try figuring out exactly which part of 'launchMaestro' that makes it fail.
13:53:13 <crestfallen> I was thinking about it wrong, while "writing" the output of scheme programs
13:53:18 <EvanR> yeah scheme code exists as an AST. though it becomes tough to use it to reasonable what the program will do
13:53:22 <crestfallen> longhand
13:53:29 <lemmih> trcc: And you're sure your command will terminate if it is sent SIGTERM?
13:53:31 <EvanR> to reason*
13:53:47 <lemmih> trcc: If you aren't sure, you can test it from the command line.
13:54:14 <crestfallen> got it. I think I learned a bad habit in scheme because I never fully understood the "longhand output" in exercises
13:54:24 <EvanR> i am not sure what longhand output is
13:54:36 <trcc> lemmih: yes. I can easily send a kill
13:54:39 <crestfallen> one moment
13:54:49 <lemmih> trcc: SIGTERM is not the same as SIGKILL.
13:55:48 <EvanR> also understanding lisp code as it evaluates in terms of syntax only is tough, i now know for sure instead of just assuming that i am ignorant
13:56:19 <EvanR> because you have to know if the code was already evaluated, (quote x y z) vs (x y z)
13:56:55 <crestfallen> here is not the best example I have : https://ptpb.pw/ZzGq
13:57:28 <trcc> hmm lemmih I think threaddelay causes it to fail
13:57:48 <EvanR> ok
13:57:53 <EvanR> yeah you arent showing enough steps
13:58:24 <EvanR> (+ (* 1 13) (* -1 8)) ; -> 5 is skipping the step (+ 13 -8)
13:58:31 <lemmih> trcc: Did you verify that the java program responds to SIGTERM after 2 seconds?
13:58:40 <lyxia> srid: you can try to look for libraries of extensible sums/open union types, although it's all quite experimental.
13:58:45 <trcc> lemmih: I am going to try now. Sec
13:59:21 <EvanR> you can do the same "longhand" analysis in haskell, as long as you use normal order evaluation and not eager evaluation like scheme
13:59:42 <trcc> lemmih: kill -SIGTERM pid works fine
14:00:23 <crestfallen> yeah I don't even want to look at that. you exposing to the idea of the node/leaf in the AST is big. thanks.. oh , if you don't mind would you supply an example of that based on our discussion of (:) ?
14:00:32 <crestfallen> exposing me*
14:00:46 <EvanR> the scheme code is even more obviously a tree haha
14:01:01 <EvanR> ok
14:01:03 <crestfallen> the normal order example that is
14:01:34 <Xal> crestfallen: you can single-step through code in ghci
14:02:29 <lemmih> trcc: Strange. terminateProcess should just send that signal. Does waiting for the process to finish just hang?
14:02:38 <crestfallen> Xal, thanks please hold that thought and let me see what Evan*R comes up with
14:02:54 <EvanR> http://lpaste.net/365149
14:03:31 <trcc> lemmih: it is a server, so not interested in waiting. Seems like threadDelay causes it
14:04:33 <EvanR> if it was scheme, you would have computed the argument to head first
14:04:56 <EvanR> here it was delayed, and even then still not fully evaluated
14:05:43 <lemmih> trcc: Your example program is not a server. Maybe the signal is sent in a background thread which doesn't get to run because your app immediately quits.
14:06:17 <trcc> lemmih: i'll try a delay after terminateprocess
14:06:40 <lemmih> trcc: Try waiting for a little while.
14:07:49 <crestfallen> ok that is different from how I used to laboriously write out the "Stack" with each new recursion being written to the rhs of the previous one. so here with no recursion line 5 has just ghci forcing the return of the head 0 ?
14:08:59 <EvanR> by stack do you mean the intermediate states of the gcd computations?
14:09:25 <EvanR> your examples dont actually show explicit recursion, since gcd never appears twice
14:09:30 <trcc> lemmih: just tried: SpawnCommand, sleep 2 sec, terminateProcess, sleep 2 sec. Same result, process is still there
14:09:42 <crestfallen> does your example mean that ghci provides just two cases and no case , i.e. no chance , to evaluate the filter exp?
14:10:02 <lemmih> trcc: Try actually using 'waitProcess'.
14:10:14 <crestfallen> sorry I need to paste a better example
14:10:42 <EvanR> the example shows step 1, replace `head (stuff)` with the definition of the head function, but where the parameter has (stuff) substituted
14:10:56 <lemmih> trcc: Also, try other spawning 'sleep 10'.
14:11:09 <EvanR> which is what you should also have been doing with gcd, only after you fully computed the arguments first
14:11:50 <trcc> lemmih: cannot find the waitProcess function
14:12:07 <EvanR> ill give you an example with more steps
14:12:31 <lemmih> trcc: Eh, waitForProcess.
14:13:09 <lemmih> trcc: Are you using Windows, btw?
14:13:18 <trcc> lemmih: mac
14:13:40 <crestfallen> so it carries the parameter ( value 0 ) into the case statement
14:14:24 <crestfallen> (on line 5)
14:14:33 <EvanR> the parameter is not 0
14:14:40 <EvanR> the parameter is (0 : filter f [1..])
14:14:48 <EvanR> which is not fully evaluated
14:15:16 <trcc> lemmih: waitForProcess does not make a change. The application terminates, but the java process is still there
14:15:45 <crestfallen> right its only evaluated enough to see that x = 0
14:15:54 <EvanR> it didnt even
14:16:08 <EvanR> it evaluated enough to see that the argument is _:_ and not []
14:16:13 <lemmih> trcc: Well, that means that the process /does/ get terminated. Your java app might have spawned another process.
14:16:16 <EvanR> and returned whatever was on the left of :
14:16:20 <EvanR> does not care if its 0
14:16:27 <EvanR> or 99
14:16:29 <crestfallen> that's interesting thanks
14:17:00 <trcc> lemmih: working from mwe http://lpaste.net/365151 . If that is the case, why does it work with kill -SIGTERM?
14:18:36 <lemmih> trcc: You're sending the signal to the process spawned by java, not the process spawned by your app.
14:19:41 <crestfallen> but EvanR can it be said that the head function wouldn't even see the rhs of (:) there?
14:19:48 <crestfallen> since you wrote _ : _
14:20:32 <EvanR> it won't
14:20:34 <crestfallen> " it evaluated enough to see that the argument is _:_ and not []  "
14:20:45 <EvanR> and i updated the example to match on (x:_) so yeah
14:20:51 <trcc> lemmih: so the process spawned by my app using spawnCommand returns a different pid than then process by manually invoking Java -jar Maestro.jar in the terminal?
14:20:57 <EvanR> it never looks at _
14:21:12 <crestfallen> sorry didn't see that. thanks very helpful!
14:21:38 <lemmih> trcc: Oh yes, you're actually spawning a shell. You spawn a shell and run 'Java -jar resources/maestro.jar >> MaestroProcessOutput' in that shell.
14:22:31 <trcc> hmm any idea on how to get the handle on the Java process then? Manually look it up?
14:23:20 <trcc> ahh lemmih, the >> was the issue!
14:23:38 <trcc> after removing >> MaestroProcessOutput it works
14:23:50 <lemmih> trcc: Do the piping manually.
14:24:12 <trcc> can you point me to how? If not, that is fair enough.
14:24:20 <trcc> thank you for your time no matter what :)
14:25:06 <lemmih> trcc: Open the output file and then use, say, runProcess with that handle for 'stdout'.
14:25:58 <lemmih> trcc: 'runProcess' is much like 'spawnProcess'. It just takes a few more arguments (leave most of them as Nothing) and it doesn't spawn a shell for you.
14:27:40 <trcc> lemmih: but doesn't runProcess what for the process to finish?
14:28:05 <trcc> wait(
14:28:08 <trcc> *
14:28:21 <lemmih> Nope.
14:28:29 <trcc> great. Thank you! i'll try that
14:28:38 <EvanR> crestfallen: http://lpaste.net/365152
14:29:22 <crestfallen> still wondering , does _ mean "no matter what is here " or does it mean "don't look here at all " EvanR like say with \_ -> True
14:29:25 <crestfallen> oh thanks looking at that
14:30:01 <zezeri> does anyone know how to resolve the famous "error code 2 " after installing haskell on windows.
14:30:15 <EvanR> crestfallen: _ is the "don't care" pattern, anything matches it
14:31:12 <crestfallen> I can relate to don't care !
14:31:28 <crestfallen> looking at paste
14:36:20 <zezeri> how can i set the $PATH$  in windows?
14:39:17 <EvanR> crestfallen: I added a second experiment which involves an infinite list, which shows how lazy evaluation can be exploited
14:39:46 <k0ral> is there such a thing as an injective 'Map a b' ?
14:40:09 <k0ral> if not, how would you emulate it ?
14:40:10 <EvanR> wait... about to run out the door, rewriting
14:40:58 <crestfallen> thanks so much !
14:41:09 <crestfallen> EvanR,
14:43:50 <EvanR> ok
14:44:34 <pavonia> k0ral: You could have Set of the codomain elements with your Map and check via smart constructors whether a new element maps to a value already present in the Set
14:44:57 <EvanR> in enumFrom 5 !! 2, or ((!!) (enumFrom 5) 2), with eager evaluation youd first fully evaluate enumFrom 5. which is
14:45:00 <EvanR> > enumFrom 5
14:45:02 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
14:45:07 <EvanR> infinite
14:46:26 <EvanR> with lazy evaluation enumFrom 5 is deferred until needed to decide which case to go with
14:47:49 <crestfallen> EvanR, thanks I thought you left. plenty of homework...
14:47:55 <EvanR> i am leaving now
14:47:59 <crestfallen> pax
14:54:07 <k0ral> pavonia: can't we do better than relying on a dynamic check at insertion/construction ?
14:56:07 <k0ral> maybe a bimap ?
14:56:50 <pavonia> Bimap only works for bijections
14:57:13 <pavonia> Or you make wrap the domain type into Maybe
15:01:20 <lyxia> Both Bimap and a Map with a Set like you describe represent partial injective functions
15:02:05 <lyxia> You can map backwards with Bimap but that's not the difference between an injection and a bijection
15:03:44 <zezeri> anyone here who could help me a bit with the initial setup?
15:03:47 <zezeri> been trying for hours
15:03:50 <zezeri> and keep getting errors
15:03:59 <zezeri> really frustrating and i am not sure what i am doing wrong.
15:05:33 <k0ral> bonus question: can we teach the type system about the uniqueness of a set of elements ? So that as soon as I have witnessed it, I can write total function that rely on the uniqueness (rather than using Maybe all over my code)
15:06:46 <pavonia> lyxia: But don't you need an extra element in the domain for the codomain values that do not have a corresponding domain value?
15:08:26 <zezeri> anyone :)?
15:09:20 <trcc> I am trying to create a show instance for a type synonym (type MaestroOffline = IO (Bool), but I am not getting the expected. Code and error here: http://lpaste.net/365157. Anyone up for giving it a quick look?
15:10:35 <Xal> trcc: Show is of type a -> String, so you can't put a do-block there
15:10:47 <Xal> that would make Show :: a -> IO String
15:10:52 <trcc> ahh of course
15:10:55 <trcc> thank you Xal
15:11:24 <trcc> Xal: so what I am trying to do is not really possible, or is there some way?
15:11:58 <Xal> make it a regular function from MaestroOffline -> IO String
15:12:20 <trcc> So no way of creating a show instance, correct?
15:12:37 <Xal> no
15:12:45 <trcc> Thank you.
15:13:06 <Xal> if you could give us some more context for why you need a Show instance for this type, I could propose an alternative
15:14:31 <trcc> Xal: I am invoking a get request on a server. If it responds, then it is online. If not (timeout), it is offline. This I convert to IO (bool), and I just want to print whether it is offline or not.
15:15:16 <lyxia> pavonia: you can formalize partial functions with domain A and codomain B simply as certain subsets of (AxB), no need to carry an extra element around
15:15:24 <Xal> Make a type MaestroOffline = Bool, and then make an instance Show MaestroOffline
15:15:32 <Xal> I'll write an example
15:17:24 <lyxia> zezeri: there doesn't seem to be many windows users around at this time
15:18:45 <Xal> trcc: http://lpaste.net/365158
15:19:08 <zezeri> lyxia: thank you, good to know :)
15:19:12 <Xal> this way, the newtype MaestroOffline = MaestroOffline Bool signals that your Bool is really meant to signal if the server is down
15:19:25 <Xal> Show is pure, and you can fmap it over an IO MaestroOffline
15:19:45 <trcc> Thank you!!!
15:20:27 <trcc> Great big difference in reading about Haskell and actually writing some... About time I started writing instead of reading I think
15:20:45 <lyxia> zezeri: I think there are some during daytime in Europe, and otherwise, you may have more luck on the Haskell-cafe mailing list
15:21:18 <zezeri> alright, lyxia thank you anyways :) Going to try again tommorrow. Have a great night!
15:30:28 <serendependy> A quick question about (the dreaded) unsafePerformIO - is it "safe" to use to catch exceptions "pure" code? This is for a personal project so I'm ok with some immorality, as long as it works
15:33:26 <hpc> serendependy: sometimes
15:33:44 <hpc> serendependy: you have to be very careful about how you catch exceptions in pure code, because of "when" the exception happens
15:34:00 <hpc> serendependy: there are some libraries that probably already solve this for you in other ways, like spoon i think?
15:34:14 <lyxia> there's also no guarantee which one you'll get if there are many exceptions
15:34:38 <hpc> yeah, spoon is perfect
15:34:45 <hpc> catches exceptions, turns them into Maybe and whatnot
15:35:02 <serendependy> hpc: Does it change anything that the only exceptions are thrown by error - i.e. no IO is done at all?
15:35:35 <hpc> no
15:35:38 <serendependy> lyxia: In my case I don't care what the exception was - but catching and converting to maybes sounds nice, I'll check spoon out
15:35:46 <hpc> error exceptions are regular exceptions
15:36:52 <serendependy> I see, thanks. I'm following along some ML code in Haskell and the different ways exceptions are done in the two languages bit me about 90% of the way through
15:36:53 <hpc> ah, there it is
15:36:54 <hpc> https://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Exception.html#t:ErrorCall
15:37:11 <hpc> that's the exact exception that gets generated
15:38:29 <serendependy> Great, thanks for your help!
15:39:03 <hpc> take a look at the instance list for Exception at some point, it's pretty informative
15:42:22 <trcc> I am looking a function (IO (a) -> IO ()) -> IO (a) -> IO (a). It should take e.g. an putStrLn function and an IO (a) value, execute the putStrLn function and return the IO (a) value. Does such a function exist? I cannot find it on hoogle, but I might be doing the search wrong
15:43:05 <trcc> Could also be (a -> IO ()) -> IO (a) -> IO (a)
15:43:44 <trcc> example: http://lpaste.net/365162
15:45:24 <lyxia> putStrLn is not IO a -> IO () though
15:45:51 <trcc> No, it is string -> IO () right?
15:46:02 <lyxia> it is
15:53:13 <trcc> lyxia: http://lpaste.net/365164 that is what I was thinking.
15:53:58 <jle`> trcc: be careful, that one executes 'x's actions twice
15:54:40 * hackage alg 0.2.1.0 - Algebraic structures  http://hackage.haskell.org/package/alg-0.2.1.0 (MatthewFarkasDyck)
15:54:46 <trcc> ahh. So I should do a wrapping of v instead
15:55:29 <trcc> hmm
15:55:37 <jle`> trcc: you can use <$
15:55:43 <trcc> magicFunction2 f x = x >>= (\v -> f v >> return v)
15:55:43 <jle`> like (\v -> v <$ f v)
15:55:55 <jle`> or (\v -> f v <$ v)
15:56:03 <jle`> er, (\v -> f v $> v)
15:56:15 <trcc> ah did not know that operator. Thank you
15:57:37 <trcc> jle`: cannot really find that operator. WHere is it located?
15:57:53 <jle`> Data.Functor
15:58:44 <trcc> Thanks
15:58:52 <jle`> no problem!
16:02:10 <trcc> jle`: just a follow up quesiton: ($>) :: Functor f => f a -> b -> f b: the f is IO ?
16:02:18 <jle`> yeah
16:02:22 <trcc> perfect
16:02:41 <jle`> the functor instance for IO "re-maps" the result of an action
16:03:03 <jle`> so `myAction $> v` is a new action with the same effects as myAction, except the result is ignored and replaced with 'v'
16:03:38 <trcc> Thanks. Made it look much better in my code
16:03:50 <jle`> glad it was helpful!
16:03:58 <trcc>   offline <- isOffline >>= (\v -> showIsOffline v $> v)
16:04:14 <jle`> hm in that case i would have probably just written
16:04:17 <jle`>   offline <- isOffline
16:04:22 <jle`>   showIsOffline offline
16:04:27 <trcc> hehe tht is what I did
16:04:29 <jle`> would have the same effect
16:04:39 <jle`> and is maybe a little more readable, heh
16:04:42 <trcc> but I wanted to play around a bit :)
16:05:03 <trcc> seems like a common use case, I would have expected there to be a function for this
16:05:23 <trcc> such that it would just be: offline <- magicFUnction isOffline showIsOffline
16:06:01 <jle`> you're right, it's kind of common
16:06:28 <jle`> it resembles ruby's #tap method
16:06:47 <jle`> but it's probably not common enough to warrant its own named method
16:07:01 <jle`> there are a lot of small utility functions that fall somewhere along that line :)
16:07:14 <trcc> hehe yes
16:27:32 <sqooq> dear god help me?
16:28:34 <spruit11> Which one?
16:29:31 <sqooq> I'm using megaparsec to parse, because I want good errors. It makes good errors using Either. but I want to parse separate things and then combine them in different ways. I can do this with functor, applicative, nmonad, and carry the error. but either only shows the first error
16:33:03 <sqooq> Ideally I think I should like append all errors.
16:36:09 * hackage bindings-GLFW 3.2.1.1 - Low-level bindings to GLFW OpenGL library  http://hackage.haskell.org/package/bindings-GLFW-3.2.1.1 (Mokosha)
16:38:22 <pavonia> Is there an alternative to Data.Binary.Get which allows arbitrary forward and backward jumps in the read data stream?
16:38:50 <clio> just paratrooping in, but what is the best book to study haskell over the summer?
16:39:14 <clio> sorry if this is offtopic, but i heard you guys are extra nice over here :)
16:40:29 <Xal> people seem to like "Haskell Programming from first Principles"
16:40:46 <pavonia> I liked Real World Haskell. Not sure if this is still up to date, though
16:40:48 <MarcelineVQ> haskell from first principles or Programming in Haskell 2nd edition, Thinking Functionally with Haskell is often reccomended but idk if that's a book about learning haskell or about learning to think functionall, with haskell :>
16:41:55 <fr33domlover> pavonia, jumps? how do you determine how much tp jump? hmm possibly it would just be equivalent to reading everything into a (possibly lazy) bytestring and then parsing the bytestring, with binary or attoparsec or anything else
16:42:15 <sqooq> Ok I made my own Either type but this does not feel right
16:42:22 <sqooq> Had to constrain the error as monoid
16:42:34 <clio> tnx, ill check them out, will return after few study sessions, bye :D
16:42:38 <fr33domlover> clio, *personally* I used the Haskell Wikibook and it was amazing
16:42:53 <clio> noted
16:42:55 <pavonia> fr33domlover: The (relative or absolute) offsets to jump to are determined by the read data
16:43:50 <MarcelineVQ> haskell wikibook is full of great stuff for sure
16:44:29 <fr33domlover> pavonia, ah I see. Then you could just read the data into a bytestring first (perhaps lazy? so that if you don't have big jumps, you don't get a big chunk of data in memory at once) and parse the bytestring
16:45:06 <joshua> hi
16:47:04 <pavonia> fr33domlover: Keeping all data in memory isn't a problem, the files to parse are small (< 1MB). My problem is that I have to parse parts of the final data structure and from time to time make out order jumps to other parts of the data to get the full structure, which Get doesn't support
16:47:49 <pavonia> I could have an intermediate data structure which is the same as the final one but with the gaps not filled yet, but this leads to a lot of boilerplate
16:48:28 <pavonia> And having several type variables for the gaps isn't nice either
16:52:08 <fr33domlover> pavonia, yeah I understand. if you really really don't want any intermediate structure, try using attoparsec's controls of the input string. iirc it keeps the entire parsed input for jumping back in case of failed parse attempts, so you don't lose anything by using that input to make your jumps
16:53:23 <ertes> pavonia: one approach is:  data ParserF x = ParserJump x Int | ParserGet (Get x)
16:53:35 <ertes> pavonia: then your parser monad is (Free ParserF)
16:53:36 <fr33domlover> pavonia, also note that you can use lookAhead etc. stuff of Binary.Get
16:53:43 <fr33domlover> If that helps
16:54:05 <fr33domlover> (But that jumps only forward, not backward)
16:54:15 <ertes> pavonia: it requires you to write a controller loop that alternates between jumps and runGets
16:54:36 <sqooq> pls respond
16:55:05 <sqooq> I made monoid but this is so bad, I couldn't even append newline to separate them, and it's not like you know which error is for what
16:55:10 <ertes> pavonia: (Get itself does not support seeking)
16:55:21 <sqooq> maybe I should just leave standard Either functionality and have it only pass on the first error
16:55:28 <pavonia> fr33domlover: lookAhead seems to be a simple solution. In attoparsec, any specific functions to look at?
16:55:39 * hackage ca 0.0.0.1 - Cellular Automata  http://hackage.haskell.org/package/ca-0.0.0.1 (MatthewFarkasDyck)
16:56:39 <pavonia> ertes: That Free ParserF would be the underlaying monad of another parser library like megaparsec then?
16:57:03 <ertes> pavonia: note that Get also supports backtracking these days, so you can simply use its Alternative instance
16:57:18 <ertes> pavonia: no, Free ParserF *is* your parser monad, if you follow that approach
16:57:28 <ertes> pavonia: the idea is that (Free F) is basically F, but with breakpoints
16:58:25 <fr33domlover> pavonia, hmmm nope nothing specific i can think of, but ertes has a great point, your parser would have to look like alternating between parsing runs and jumps, even if you don't use Free
16:58:26 <ertes> so (Free IO) is IO with breakpoints, and (Free Get) is Get with breakpoints, but you can also use a sum functor (ParserF) to have extra actions that are not supported by the underlying monad F
16:58:29 <ertes> in this case an action for seeking
16:59:16 <ertes> pavonia: i can write a super-small example, if you need one
17:00:04 <fr33domlover> pavonia, basically you apply your parser until you have to jump. Then you finish parsing, make the jump in the bytestring, and start parsing again at the new spot
17:01:00 <pavonia> ertes: I've never used free monads, but it sounds interesting. So let me try it myself first, I'll come back to you if that doesn't lead to anything useful
17:01:21 <ertes> yeah, and that's exactly what Free does here: it gives you that "breakpoint" (where you stop parsing and do something else, and then continue parsing)
17:01:51 <pavonia> `free' is the package to look at?
17:02:02 <ertes> pavonia: yeah
17:02:23 <pavonia> Okay, thanks so far for the ideas
17:02:39 <ertes> pavonia: perhaps do this exercise first:  runFreeIO :: Free IO a -> IO a  -- it should run the given (Free IO)-action, but each time it encounters a breakpoint it should print "break"
17:03:05 <Profpatsch> I can construct the free structure by differentiating over the class functions like this:
17:03:07 <Profpatsch> -- Monoid   mappend :: (a, a) -> a  & mempty :: a
17:03:09 <Profpatsch> --          a^2                     + a
17:03:11 <Profpatsch> -- List a = Cons a (List a)         | Nil
17:03:13 <Profpatsch> --  d/da    a * List a              + 1
17:03:15 <Profpatsch> right?
17:03:38 <Profpatsch> But I’m a bit lost, because a function a -> a  would then be a^1, which is 1 again when differentiated.
17:03:53 <Profpatsch> e.g. for Group:
17:03:55 <Profpatsch> -- Group    Monoid      & inverse :: a -> a
17:03:57 <Profpatsch> --          a^2 + a     + a^1
17:03:59 <Profpatsch> --  d/da    2a  + 1     + 1
17:04:21 <Profpatsch> Maybe I’m misunderstanding mappend already?
17:04:58 <ertes> pavonia: here is an example action you can use runFreeIO on:  example :: Free IO (); example = liftF (putStrLn "hello!" *> putStrLn "world!") *> liftF (putStrLn "end")
17:07:35 <Clint> when did 01-index.tar appear and what is its significance?
17:13:51 <hpc> pavonia: (don't let this distract you from learning Free, but when you're feeling comfortable with it there's a neat related idea for the fix function)
17:15:50 <sqooq> pls rspond
17:16:00 <sqooq> i wanna finish my code 😩
17:17:27 <Profpatsch> sqooq: Check out https://hackage.haskell.org/package/either-4.4.1/docs/Data-Either-Validation.html
17:18:41 <Profpatsch> Someone’s sitting in the train. :)
17:20:11 <Profpatsch> Or hm, is Monoid really a^2+a + a?
17:20:38 <Profpatsch> Because mappend is returning another a in covariant position?
17:20:49 <abnormalprofits> liquid haskell seems really cool. Is it used for serious things or just a toy?
17:21:01 <Profpatsch> Would (a, a) -> (a, a) be a^2+a^2 then?
17:21:13 <Profpatsch> Maybe I should ask in #haskell-lens. :P
17:24:17 <sqooq> Profpatsch: this is literally exactly what I wroite
17:24:20 <sqooq> It's not that nice though
17:24:37 <sqooq> I mean I got lucky that megaparsec automatically puts newline at the end of the error, so the appends don't get messsy
17:24:53 <sqooq> but thy're still one line after the other, and you can't tell for which error the lines are for
17:24:54 <sqooq> and
17:25:03 <sqooq> idk none of this feels right a moi
17:25:11 <sqooq> 😩
17:27:20 <pavonia> ertes: Does this look about right? http://lpaste.net/365166
17:32:36 <ertes> pavonia: yeah, that's right
17:33:34 <ertes> pavonia: now extend your language a bit:  data MyF x = Abort | RunIO (IO x);  runMy :: Free MyF a -> IO (Maybe a)
17:34:06 <ertes> pavonia: (MyF needs a Functor instance…  it's trivial, so you can just derive it using DeriveFunctor)
17:35:05 <ertes> pavonia: now the way you embed the IO action 'c' is (liftF (RunIO c)), but you have access to an extra action separate from IO actions:  liftF Abort
17:35:31 <ertes> pavonia: and 'runMy' is your interpreter…  it decides what Abort means (although it doesn't have much of a choice in this case)
17:41:23 <sebastianrkg> I'm having a hell of time trying to get inline-c working inside my project, getting `gcc.exe' failed in phase `Linker'. (Exit code: 1)
17:41:58 <sebastianrkg> I tried inline-c out in a separate test project and it worked easily
17:43:46 <sebastianrkg> I'm using Stack in both cases, though in the big project I'm using lts-9.9
17:44:12 <sebastianrkg> I'm not sure where to begin with debugging this issue
17:44:18 <sebastianrkg> (PhysicsEvaluator.o):fake:(.text+0x17cf): undefined reference to `inline_c_External_PhysicsEvaluator_0_2a82bb4977c08dd1acae8e7debd1225984d62412'
17:44:29 <sebastianrkg> ^ that's another part of the error message
17:46:39 * hackage lens-toml-parser 0.1.0.2 - Lenses for toml-parser  http://hackage.haskell.org/package/lens-toml-parser-0.1.0.2 (henrytill)
17:55:41 <pavonia> ertes: Stupid example but I think I've got the idea now :)  http://lpaste.net/365167
17:56:21 <jchia> Record/lens question: If I have modules A and B which respectively define "data Dog = Dog { _dogName :: Text, ...}" and "data Cat = Cat { _catName :: Text, ...}", and I use makeFields in the modules A and B on Dog and Cat respectively, will I just get two different HasName classes, one in each module, so that if I use the 'name' lens from a module C that imports A and B, I'll still have to say A.name or B.name to disambiguate?
17:59:15 <siwica> Is there some Haskell networking library that gathers data structures and parthers for application layer protocols? I need to write a parser for one and wonder if there are any haskell coding-standards I can adhere to?
18:00:11 <ertes> pavonia: great, have fun =)
18:00:59 <pavonia> Thanks
18:01:41 <ertes> jchia: you get separate ones…  a simple fix is a common convention: to define your types in a *.Types module
18:03:38 <sqooq> I gave up and just stuck with Either
18:03:39 <ertes> siwica: common approaches include attoparsec for text-based protocols and 'binary' for binary protocols, although they are fairly similar
18:03:42 <sqooq> Only first error shows
18:03:46 <sqooq> whatever
18:03:57 <sqooq> I can't thing how better to do it without getting really messy with minimal benefits
18:04:56 <ertes> sqooq: one option is (ExceptT e [])
18:07:05 <ertes> ah, not quite, sorry
18:07:37 <nkaretnikov> is there a blog template for hakyll that i can reuse and that's readable on mobile?
18:08:35 <siwica> ertes: Ok, it would be a binary protocol in my case. Are there canonical abstractions for network protocol parsers/datastructures or would I just write something totally independent of anything else?
18:09:53 <siwica> E.g. something similar to Scapy in Python...
18:10:48 <ertes> siwica: if the protocol is under your control, you can get pretty much everything for free by using autogenerated 'binary' instances
18:11:15 <ertes> siwica: if it's not you'll have to write the translation as Get and Put actions
18:12:03 <ertes> siwica: even if the protocol is under your control, 'binary' does not support protocol versioning, so you might want to use something like 'safecopy'
18:14:13 <sebastianrkg> what's the best way to upgrade a project's Stack lts version? I have some lines in my stack.yaml I still want (e.g. the reference to a local package I'm using as a dependency), so just deleting stack.yaml and stack init'ing won't work
18:15:00 <siwica> ertes: It's not under my control but there exists a spec that I guess is unlikely to change. Is there some way to specify the binary serialization of some header field manually and get the parser for free?
18:15:38 <infinisil> sebastianrkg: Um, just change the resolver entry?
18:15:41 <jackdk> sebastianrkg: just change the snapshot line and see how the build goes?
18:16:02 <jackdk> depending on the cabal file you may need to relax constraints
18:16:47 <sebastianrkg> ah, no way to make it solve for me ;/ fair enough
18:21:06 <ertes> siwica: just check out the 'binary' library…  it's basically a combination of a parsing and rendering library, but specifically for binary data with ready-made actions for things like "big-endian Word32"
18:22:11 <siwica> ertes: Ok, that sounds very useful. Thank you! I will have a look.
18:23:16 <ertes> siwica: for example a PNG chunk parser looks like this:  do len <- word32be; typDat <- getByteString (fromIntegral len); let (typ, dat) = B.splitAt 4 typDat; crc <- word32be; …
18:29:30 <siwica> ertes: Ok, that seems very elegant! I was gonna go with attoparsec at first, but this maybe easier.
18:29:39 <siwica> * may be
18:37:11 <sebastianrkg> fixed my inline-c linker issue, just needed to upgrade to the newest version. Something funky about inline-c in lts-9.9
18:38:58 <jchia> ertes: Yeah, but if the project is big, using a single Types module to contain all the types is messy.
18:39:48 <jchia> A big project has different modules addressing different things
18:39:58 <jchia> each has its central types
18:48:25 <sjakobi> siwica, siwica: According to https://github.com/haskell-perf/serialization cereal offers better deserialization performance than binary, in case that's important. If parsers and serializers cannot be derived one might even go the route of postgresql-binary and combine binary-parser and strict-bytestring-builder. I haven't used the latter two myself though.
18:49:29 <siwica> sjakobi: Thanks, I will have a look at is aswell!
19:08:09 * hackage status-notifier-item 0.2.0.0 - A wrapper over the StatusNotifierItem/libappindicator dbus specification  http://hackage.haskell.org/package/status-notifier-item-0.2.0.0 (eyevanmalicesun)
19:21:25 <shapr> Is there a way to get ghci to tell me which pattern isn't being handled in a non-exhaustive input error?
19:27:39 * hackage gtk-sni-tray 0.1.0.0 - A standalone StatusNotifierItem/AppIndicator tray  http://hackage.haskell.org/package/gtk-sni-tray-0.1.0.0 (eyevanmalicesun)
19:29:00 <Cale> shapr: hmm... normally that's a compile-time thing
19:30:28 <Cale> You can turn on -fwarn-incomplete-patterns (or just -W or -Wall), and it ought to tell you which patterns are missing. You could also use Debug.Trace.trace to print the thing you were casing on.
19:33:24 <iqubic> Yeah, I think missing patterns are one of the only ways that you can get a haskell run-time error
19:37:39 * hackage fast-arithmetic 0.6.0.1 - Fast functions on integers.  http://hackage.haskell.org/package/fast-arithmetic-0.6.0.1 (vmchale)
19:40:09 * hackage status-notifier-item 0.2.1.0 - A wrapper over the StatusNotifierItem/libappindicator dbus specification  http://hackage.haskell.org/package/status-notifier-item-0.2.1.0 (eyevanmalicesun)
19:42:09 <clodeindustrie> hi there, beginner question, trying to print the result of a postgres query in a forM_ but getting a "variable not in scope" error http://lpaste.net/365168
19:42:22 <clodeindustrie> Am I missing something obvious?
19:42:50 <glguy> You have to import forM_ to us it
19:42:51 <glguy> use*
19:43:24 <clodeindustrie> (－‸ლ)
19:43:27 <mathZ> What is the relation between haskell and Functional Analysis in math ?
19:43:57 <clodeindustrie> glguy: well thanks for that, as I said, beginner question :D
19:46:13 <mathZ> I know it is a noob and big question :)
19:54:29 <nshepperd> http://lpaste.net/365170 << people keep saying parsec doesn't have incremental parsing, so i implemented it
19:55:08 <pacak> How do I go about specifying default command with optparse-applicative? Suppose there are commands "foo" and "bar", how do I make it to handle cases when command is missing as if "foo" was specified?
19:55:48 <pacak> using subparser stuff <|> fooCommand works, but messes up help
19:58:06 <DigitalKiwi> nshepperd way to prove them wrong
19:58:59 <DigitalKiwi> does megaparsec have it
20:00:48 <nshepperd> doesn't look like it
20:00:53 <DigitalKiwi> nshepperd does this work for other things like what else can we get you to do if we keep saying something opposite
20:01:06 <DigitalKiwi> megaparsec doesn't have incremental parsing
20:01:23 <nshepperd> megaparsec doesn't have the monadic Stream thing that lets me do this :(
20:01:43 <DigitalKiwi> magaparsec doesn't have monadic stream thing
20:01:49 <DigitalKiwi> what else do we need to say it doesn't
20:01:53 <nshepperd> haha
20:02:11 <DigitalKiwi> sounds like you've got your work cut out for you see you in a few hours
20:02:16 <iqubic> https://github.com/enomsg/vim-haskellConcealPlus What do you haskellers think of this thing?
20:02:52 <nshepperd> forbid me to rewrite the whole megaparsec library and it'll be done by teatime
20:02:55 <DigitalKiwi> conceal don't feel don't let them know
20:03:13 <DigitalKiwi> nshepperd it can't be done!
20:04:48 <DigitalKiwi> iqubic I saw someone with that on twitter I was going to go looking for one for emacs at some point to try out it's kind of nifty I guess
20:05:41 <Welkin> you can get clippy (the microsoft word assistant) for emacs
20:05:42 <iqubic> Yeah, I tried to find an emacs version. I really want an emacs version of that.
20:05:50 <iqubic> Haven't found that yet.
20:05:56 <DigitalKiwi> Welkin thanks i'll pass
20:06:00 <Welkin> lol
20:10:07 <DigitalKiwi> https://wiki.haskell.org/Emacs/Unicode_symbols
20:10:54 <Welkin> is that so you can type an orc wearing a helmet made of testicles?
20:17:57 <DigitalKiwi> that's just my chin don't fat shame me!
20:18:46 <DigitalKiwi> note: this is a joke I do not have a double chin
20:22:41 <DigitalKiwi> I don't know where you put that setting in spacemacs config :
20:32:56 <iqubic> I wish I knew too.
20:37:11 <anon136> I have this algorithm that compares each of the elements in 2 lists to each other to check for similarity. So, how close are each of the first elements to each other, how close are each of the second elements to each other and so on. Here it is: "compareLists xs xs' = [abs (x - y) | (x, y) <- zip xs xs']" Is there a better way than zipping the two lists into tuples like that?
20:38:31 <anon136> It feels like I managed to throw an unnecessary extra step in there.
20:40:04 <DigitalKiwi> I figured it out it goes in the spacemacs file in (defun dotspacemacs/user-config ()) towards the end
20:40:09 <DigitalKiwi> iqubic ^
20:40:22 <iqubic> Oh, nice.
20:40:34 <iqubic> Does it work as expected?
20:41:21 <fishythefish> anon136: compareLists xs xs' = zipWith (\x y -> abs (x - y))
20:41:39 <anon136> fishythefish: thanks!
20:41:51 <fishythefish> er, sorry, `compareLists = ...`
20:42:17 <fishythefish> you could even do `compareLists = zipWith ((abs .) . (-))` but that's less clear IMO
20:42:39 <DigitalKiwi> seems to I guess, sometimes it doesn't load the unicode one right away, either SPC SPC haskell-mode or opening the file from within spacemacs fixes. like if I `emacs src/file.hs` it shows ascii at first but if I already had emacs open and open the file it's fine...meh
20:42:41 <Welkin> pointless form
20:42:44 <Welkin> is pointless
20:44:23 <iqubic> DigitalKiwi: Did that unicode thing work as expected?
20:46:33 <DigitalKiwi> I mean yeah they're different now :)
20:46:52 <iqubic> Can I see a screenshot?
20:47:15 <anon136> fishythefish: can't seem to get it to work. that's just normal ghci code?
20:47:53 <fishythefish> anon136: my first one was a typo - you need to omit xs and xs'
20:47:54 <Welkin> anon136: forgot the xs and xs'
20:48:00 <Welkin> or add them
20:48:15 <[Leary]> I like the blackboard-bold sets for types, iqubic. Imo the unicode arrows they use don't look very good though. I use ligatures for them instead, e.g. https://i.imgur.com/KWaON0U.png
20:50:06 <anon136> cool I got it now. thanks.
20:50:42 <iqubic> [Leary]: What do you mean by "blackboard-blod"?
20:51:20 <[Leary]> That's what the style of capital used to denote the integers with Z or reals with R is called.
20:51:55 <iqubic> Is that vim or emacs? I'm trying to get something that works with emacs if possible.
20:52:18 <iqubic> But all in all, I love you xmonad/terminal theme.
20:52:50 <iqubic> Also, you seem to have only changed the arrows, and not the whole of everything.
20:53:22 <DigitalKiwi> iqubic http://i.imgur.com/X8bh4Eb.png
20:53:33 <[Leary]> My screenshot is vim. I haven't tried emacs but I gather it can be run in terminal, so if you use a ligature capable terminal like kitty it should be possible.
20:53:50 <iqubic> What is a ligature?
20:54:05 <Welkin> combinations of letters as one letter
20:54:11 <Welkin> like ae and fi
20:54:17 <Welkin> but one character instead of 2
20:54:20 <Welkin> sometimes ff
20:54:33 <Welkin> also, in terms of haskell, it can mean -> as a single character
20:54:36 <Welkin> or >>=
20:55:04 <iqubic> Cool
20:55:42 <iqubic> DigitalKiwi: Why are you creating your own BST?
20:56:23 <DigitalKiwi> that's from someones github for the okasaki book
20:57:56 <iqubic> Does haskell have short hand for XOR, like it does & and |?
20:58:13 <Welkin> shorthand?
20:58:23 <Welkin> use the bit operations library
20:59:02 <nkaretnikov> is there a difference between _ <- ... vs void $ ...? will the former force?
20:59:59 <glguy> There can be a minor performance difference, one will use (>>) and the other will use (>>=)
21:00:10 <iqubic> :t void
21:00:12 <lambdabot> Functor f => f a -> f ()
21:00:18 <iqubic> Why is that a thing?
21:01:13 <Axman6> saves you having to write _ <- somethinngWhichReturnsSomethingThatIDon'tCareAbout
21:01:15 <Welkin> because sometimes you need to use `() <$ f`
21:01:22 <Welkin> maybe you need () for IO ()
21:01:31 <[Leary]> iqubic: you can use /= as XOR.
21:01:34 <Welkin> iqubic: https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Bits.html
21:01:48 <Axman6> I most commonly use it to make GHC quiet about ignoring return values
21:02:26 <iqubic> :t absure
21:02:27 <lambdabot> error:
21:02:27 <lambdabot>     • Variable not in scope: absure
21:02:27 <lambdabot>     • Perhaps you meant ‘absurd’ (imported from Data.Void)
21:02:36 <iqubic> :t absurd
21:02:37 <lambdabot> Void -> a
21:02:51 <iqubic> see that's what I think of when I see void in haskell
21:02:51 <Axman6> :t maybe False absurd
21:02:52 <lambdabot> Maybe Void -> Bool
21:03:41 <iqubic> How does that work?
21:03:45 <iqubic> :t maybe
21:03:46 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:03:57 <iqubic> Oh, I see.
21:04:33 <iqubic> What would "maybe False absurd" return?
21:06:45 <[Leary]> Re void, sometimes you just don't care about the inner values or their types, only the Funtor structure. There's a nice use case at the bottom of the screenshot I linked earlier, actually.
21:07:43 <iqubic> Yeah I don't use xmodan so I don't know how that works.
21:09:36 <[Leary]> Basically I have four different types inside Maybe, and I want to return Just something iff one of the four is holding a value, so I void them all in order to make them typecheck for <|>.
21:20:24 <iqubic> :t (<|>)
21:20:26 <lambdabot> Alternative f => f a -> f a -> f a
21:20:40 <iqubic> How do you put the types into the Maybe?
21:32:45 <[Leary]> Well, I'm not wrapping them manually. The values came from calling handleMessage four times with layouts of different types, and it Maybe returns an updated version of a layout.
21:34:06 <Axman6> iqubic: maybe False absurd IIRC is guaranteed to return False, since it's not possible to create something of type Maybe Void which has a Just constructor (except if you have undefined :: Maybe Void or Just undefined, both of which you shouldn't do)
21:39:51 <iqubic> But I shouldn't do that ever, right?
23:43:09 <VicyHou> @help
23:43:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:43:20 <VicyHou> list
23:43:24 <VicyHou> @list
23:43:24 <lambdabot> What module?  Try @listmodules for some ideas.
23:43:32 <VicyHou> @help list
23:43:32 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
23:43:43 <vaibhavsagar> VicyHou: what are you trying to do :)?
23:45:49 <liste> VicyHou: you can send private messages to lambdabot too
23:58:42 <hn00b> Hi, I've started learning haskell recently and wonder why the Monad method (>>=) has forall in its type signature. I.e., it is declared as "forall a b. m a -> (a -> m b) -> m b" why is forall needed? as opposed to: "m a -> (a -> m b) -> m b".
23:59:31 <liste> hn00b: if you leave out the forall it's just implicit
