00:00:22 <liste> so "m a -> (a -> m b) -> m b" is really "forall a b. m a -> (a -> m b) -> m b"
00:00:33 <liste> (given that "m" comes from the outer scope)
00:01:15 <fishythefish> any free type variable in a signature is implicitly qualified by a prenex forall
00:01:21 <fishythefish> quantified*
00:01:30 <hn00b> Is there any situation when one would use forall explicitly?
00:01:39 <liste> hn00b: yes, some compiler extensions
00:01:42 <liste> like RankNTypes
00:01:46 <fishythefish> sure, if you wanted a RankNType, or for ScopedTypeVariables, etc.
00:02:27 <fishythefish> in general, if the default scope of the type variable is not what you want it to be
00:02:56 <cocreature> or if the implict order is not the one you want
00:02:59 <Axman6> newtype NT m n = NT (forall a. m a -> n a) is one example, it makes explicit that the function contained inwide a natural transformation from m a to n a cannot know anything about a
00:07:31 <hn00b> Axman6 ... can you please elaborate the example a little more -- the function is :: m a -> n a, right? Why can it not know about a?
00:09:53 <fishythefish> hn00b: the function has to work `forall a`
00:10:01 <fishythefish> this is parametric polymorphism - you can't introspect the type
00:12:28 <jchia> I want to make a module 'CustomPrelude' exporting Control.Lens qualified where if I import CustomPrelude in another module A, I can refer to Control.Lens as L, e.g. with 'L.view'. Not possible?
00:12:48 <Axman6> not possible
00:13:03 <Axman6> you can't reexport a module with a different name
00:13:51 <jchia> OK
00:14:02 <hn00b> Thank you! L8r
00:15:57 <dminuoso> Are there some representative servant applications to look at? Im struggling a bit with how to organize types, handlers and everything into files, hoping to find some good idiomatic examples.
00:26:10 <hc> dminuoso: if you find anything, I'd also be interested in that
00:32:40 <Axman6> dminuoso: not sure how idomatic it is, but this is one of the services I've written which is open source: https://github.com/data61/aemo-webservice
00:34:44 <woodson> hey guys, I am trying to upgrade my aeson package with nix and I keep on getting this error
00:34:45 <woodson> Setup: Encountered missing dependencies:
00:34:45 <woodson> base-orphans >=0.5.3 && <0.7
00:34:45 <woodson> builder for '/nix/store/g856fq9wajpw37bdjvp78hsqddxbyal7-aeson-1.3.1.0.drv' failed with exit code 1
00:34:45 <woodson> error: build of '/nix/store/g856fq9wajpw37bdjvp78hsqddxbyal7-aeson-1.3.1.0.drv' failed
00:35:10 <woodson> I have base-orphans >= 0.5.3
00:35:23 <woodson> So, I dont understand why its not picking it up
00:36:30 <dminuoso> Axman6: Ah that's great thank you. My code doesn't look much different in terms of structure, guess Im on the right track then. :)
00:37:25 <cocreature> woodson: what exactly do you mean by “I have base-orphans >= 0.5.3”?
00:37:49 <cocreature> woodson: maybe you’re trying to use base-orphans 0.7?
00:39:16 <woodson> cocreature: So, after getting that error I simply install the base-orphans package with this command "nix-env -f "<nixpkgs>" -iA haskellPackages.base-orphans"
00:39:26 <woodson> which got me the base-orphans 0.7
00:39:38 <cocreature> right so there’s your problem
00:39:45 <cocreature> 0.7 is not < 0.7
00:40:32 <woodson> cocreature: thats the only version that nix-env -f "<nixpkgs>" -qaP -A haskellPackages | grep base-orphans
00:40:44 <woodson> the command above offers me
00:41:30 <cocreature> the easiest solution is probably to just disable the test suite of aeson
00:42:04 <dminuoso> On an unrelated question: If you care neither of the performance, nor about boundaries (semantically I can only get numbers from 1-100), would you pick Integer over Int?
00:42:31 <jchia> Apart from possible performance difference, traverse and mapM should do the same thing, correct?
00:42:32 <woodson> cocreature: How can I disable it?
00:42:39 <hc> Ideally you'd pick a dependent type that?
00:42:53 <hc> that only accepts numbers from 1-100
00:43:00 <dminuoso> jchia: Correct.
00:43:02 <cocreature> woodson: take a look at https://github.com/Gabriel439/haskell-nix/tree/master/project3#tweaking-haskell-projects
00:43:34 <jchia> dminuoso: I suppose I can say the same about ifor & iforM from lens?
00:43:42 <dminuoso> hc: Yeah.. my thought is to simply pick an Integer since it's morally more correct. The fact that I have this semantic limitation is rather arbitrary.
00:44:39 <dminuoso> jchia: I cannot answer that question.
00:45:08 <jchia> question for #haskell-lens, perhaps
00:46:47 <cocreature> dminuoso: I’d definitely pick Int, you might not care about performance now but it just seems silly to use Integer when you don’t need it
00:53:28 <vasiliy_san> Hi everyone, I have a quick question about STM. Given two code snippets below, does it makes sense to move veryLongComputation out of STM monad (as in the snippet #2)? I know that in general one shouldn't run long computation inside of STM, but does that rule applies to the scenario below (where I first read values and then produce a final result based on previously read values)?
00:53:29 <vasiliy_san> atomically $ do a <- readTVar a0
00:53:29 <vasiliy_san>                 b <- readTVar b0
00:53:29 <vasiliy_san>                 return (veryLongComputation a b)
00:53:29 <vasiliy_san> ---
00:53:29 <vasiliy_san> (a, b) <- atomically ((,) <$> readTVar a0 <*> readTVar b0)
00:53:29 <vasiliy_san> let res = veryLongComputation a b
00:56:34 <mniip> to me it seems that the two snippets have no semantic differences
00:57:10 <Axman6> vasiliy_san: well, it comes down to what semantics you want, do you want the computation of veryLongComputation to be valid at the time the transaction succeeds or are you ok with the computation possibly having out of date data by the time it's finished
00:57:20 <Axman6> though, without forcing the first example these are the same
00:57:52 <mniip> Axman6, you're not locking the TVar are you
00:59:12 <mniip> also referential transparency and whatnot
01:06:31 <[exa]> lemmih: mind a few more questions about LHC? what happens if 2 'library' modules share a definition name? when merging the Core modules there's a simple 'coreDecls a ++ coreDecls b' so I'd expect a name collision
01:07:36 <vasiliy_san> All right, I think I understood the difference between snippets and why my question wasn't specific enough. So if the only thing I care about is that 'a' and 'b' were read atomically then snippet (2) will cause less "retries" in a situation when there is some concurrency.  Snippet 2 guarantees that resulting value is "fresh" or "valid" just after completion of the atomically call.
01:07:42 <Axman6> sure, but by the time veryLongComputation has been computed the values contained in a and b may haver changed, so I think what vasiliy_sanwas after was: atomically (do a <- readTVar a0; b <- readTVar b0; let res = veryLongComputation a b in res `seq` pure res)
01:07:58 <[exa]> lemmih: oic, the names are prefixed by module id.
01:08:04 <Axman6> vasiliy_san: I think as you wrote them those two snippets are the same
01:08:30 <Axman6> but I think you meant for the first snipper to be closer to the one I just wrote above)
01:09:39 <Axman6> snippet*
01:09:59 <vasiliy_san> Axman6: Aaaahhh. yes. Thanks! Didn't think about lazinesses
01:10:43 <Axman6> right, so the only thing you need to think about is if you're ok with the values in a0 and b0 having changed by the time you get the result of veryLongComputation
01:12:00 <vasiliy_san> Axman6: I got it. Thank you for your help.
01:12:19 <Axman6> in most cases this is usually ok, unless you do something silly like read from the variables later in another atomically call and expect them to be the same
01:12:26 <Axman6> no worries
01:43:39 * hackage hgis 1.0.0.0 - Library and for GIS with Haskell  http://hackage.haskell.org/package/hgis-1.0.0.0 (vmchale)
01:49:24 <nkaretnikov> Could you suggest to read anything that _properly_ explains when it’s okay to use unsafe* functions and coerce?
02:01:32 <jle`> it's always okay to use coerce
02:01:55 <cocreature> at least if you assume roles are properly specified
02:01:57 <jle`> reasons to use unsafe* functions differ for every unsafe function
02:02:23 <jle`> nkaretnikov: it's not quite like 'unsafe' is a technical term
02:02:50 <jle`> every unsafe* function is different and has different situations where you should use them
02:03:07 <adjofun> nkaretnikov: what is "okay" for you? In general, if you want more speed, and understand *horrific* consequences of breaking referential transparency, segfaults, and unpredictable behaviour, then go for it =:)
02:03:50 * adjofun went to coerce `putStrLn` to Word8
02:04:01 <AndreasK> coerce or unsafe coerce
02:10:17 <cocreature> AndreasK: how about coerce coerced to the type of unsafeCoerce using unsafeCoerce?
02:10:23 <cocreature> :)
02:12:28 <tdammers> "unsafe" generally just means "this may violate something you take for granted"
02:13:06 <merijn> "here there be dragons"
02:13:12 <adjofun> So, I coerced `unsafeCoerce` to IO (a -> a), and got `id`. Is this an achievement? =:)
02:13:20 <merijn> Except, it's not always the obvious red dragon biting your face off kind of dragons
02:13:28 <tdammers> indeed
02:13:49 <merijn> Sometimes it's the subtle copper dragon that likes to twiddle random bits in your address space with 10% probability and only when you are not actively debugging...
02:14:01 <tdammers> yeah
02:14:30 <merijn> adjofun: Doing something dangerous with unsafeCoerce is never an achievement :p
02:14:37 <tdammers> "this fails 0.1% of the time, and only on production deployments, and almost exclusively on weekends, in the middle of the night"
02:14:41 <merijn> adjofun: Using unsafeCoerce to do something *not* dangerous is an achievement :p
02:15:08 <nkaretnikov> jle`: that's what i'm asking about. i haven't encountered a detailed explanation, with dos and do-nots. adjofun: of course, i don't want segfaults, but they exist for a reason, and i'd like to understand why.
02:15:40 <merijn> For all our talk about Haskell being safe, it turns out the baby crib is littered with death rays...but we hid them under the blanket, so it's probably fine ;)
02:15:53 <nkaretnikov> so far, my strategy has been "just avoid them and you'll be fine", but it's not an answer
02:16:00 <cocreature> nkaretnikov: you’re going to have to be more specific on which unsafe function you’re interested in
02:16:11 <nkaretnikov> cocreature: the more the better
02:16:33 <merijn> nkaretnikov: In reality "unsafe" is code for "you need to know implementationd etails to some extent to talk about what this does and how you could potentially use it safely"
02:17:05 <cocreature> for unsafePerformIO, the primary safe usecase is probably the FFI
02:17:06 <nkaretnikov> merijn: i get that, but i'd like to see examples.
02:17:22 <merijn> nkaretnikov: Are you somewhat familiar with the terms "inlining" and "common subexpression elimination"?
02:17:31 <nkaretnikov> merijn: yes
02:18:00 <merijn> nkaretnikov: Right, so in the case of unsafePerformIO the issue is that IO is defined to avoid those two ever causing issues with when and how often IO actions get run
02:18:41 <merijn> nkaretnikov: So, unsafePerformIO removes those protections, which means GHC will happily inline or eliminate duplicates, which means your IO may now run 0 or more times and you have no reliable way of knowing which it will be
02:19:29 <merijn> nkaretnikov: So if you're 100% abso-positively sure it doesn't matter that something gets run multiple (or not at all), for example when you're calling a simple C function with no global state, then it'd be fine to unsafePerformIO it
02:19:46 <nkaretnikov> merijn, cocreature: wait, wait. don't list all of that here. there must be a blogpost that covers this, i assume. even if i learn this now from you here, i won't be able to point others to this.
02:20:02 <cocreature> be the one that writes the blogpost :)
02:20:13 <merijn> nkaretnikov: I'm not sure whether there is a blogpost about this sorta stuff, tbh
02:20:31 <cocreature> I also don’t think it makes sense to cover everything called unsafe* in the same context
02:20:35 <merijn> And I don't do well with writing up long prose. I'm better at interactive IRC explanation and then telling others to write it up :p
02:20:50 <cocreature> the reasons for using them are mostly completely unrelated
02:20:58 <tdammers> in fact, I think the existing documentation pretty much contains the relevant information already
02:21:27 <nkaretnikov> cocreature, merijn: that's what i expected :) well, okay, i might write it, but it'd probably take me months.
02:21:35 <nkaretnikov> tdammers: you mean the haddocks?
02:22:00 <cocreature> tdammers: they don’t really mention why you would want to use them iirc, only when it is safe to do so
02:22:30 <merijn> nkaretnikov: Some general recommendations I have, assuming you haven't done them (not specific to unsafe*) is: read the Haskell 2010 Report, it is one of the most readable languages specs out there and you can learn a lot from it, and 2) read the GHC user manual, it is rather in-depth and detailed and, honestly, probably the most underrated Haskell document around
02:22:54 <cocreature> the haddocks are definitely also worth a read
02:23:06 <merijn> nkaretnikov: Spending a bunch of time skimming the docs in ghc-prim is also educational, but probably requires a bit of understanding about compilers to get the most value
02:23:18 <adjofun> merijn: I read something about unsafe IO functions, I remember this because of in the article author explained`unsafeDupablePerformIO` as creating a bootleg version of a world =:)
02:23:39 <tdammers> nkaretnikov: yes
02:24:00 <merijn> adjofun: I dislike the "RealWorld passing" explanation of IO, tbh
02:24:14 <merijn> adjofun: Because it breaks down the second you use forkIO
02:24:23 <tdammers> cocreature: yes, but I'd argue if you can't infer whether it would be safe to use them from the documentation provided, then you probably shouldn't be using them
02:24:30 <nkaretnikov> cocreature, merijn: i've read bits of those. probably need to read more. i was hoping for some easily digestible material tbh
02:24:35 <DigitalKiwi> haddock is pretty tasty
02:25:12 <adjofun> merijn: any pointers to relevant material about cloning the Universe? =:)
02:25:47 <merijn> nkaretnikov: The GHC user manual is fairly digestible in my experience? The Report I don't remember as well, but I recall it's mostly fine if you know a bit of (E)BNF. And if you don't, probably should learn the basics of reading BNF anyway, it will be useful for the rest of your life :p
02:27:46 <DigitalKiwi> pfft, no language that people use for real problems has a bnf
02:28:04 <merijn> nkaretnikov: I'm mostly recommending tangentially related readings, because as mentioned before, "understanding unsafe*" is really more about gaining a deeper understanding of GHC and how it works operationally. Speaking of which, I also *highly* recommend reading the STG paper, which, despite it's intimidating name is very readable
02:29:13 <merijn> nkaretnikov: In terms of FP it really only requires you to understand, closures, lambda, function application, and pattern matching. A bit of understanding of assembly and/or C (stuff like stacks, registers, etc.) helps, but I don't think is required
02:29:18 <nkaretnikov> merijn: yeah, i can read bnf. re the paper: is that the one by spj that's mentioned in quchen's talk?
02:29:46 <merijn> nkaretnikov: This one: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.3729&rep=rep1&type=pdf
02:29:57 <merijn> nkaretnikov: It's by SPJ and I can see quchen mentioning it, yes
02:30:04 <DigitalKiwi> merijn I don't like you right now
02:30:36 <DigitalKiwi> merijn I had the link ready to send I scrolled up to see if anybody had sent it and then you did :|
02:30:49 <nkaretnikov> merijn: i know all of that, but i cannot really explain what a closure is despite reading about them several times.
02:30:53 <adjofun> speaking of STG, I recently read a Nikolay Durov's paper about implementation of Telegram's cryptocurrency, and in their realisation of TVM for smart contracts it is pointed, that STG is mappable to TVM. I assume, this will be just another backend for GHC?
02:31:02 <merijn> DigitalKiwi: :)
02:31:31 <nkaretnikov> adjofun: what? do you have a link?
02:32:22 <merijn> nkaretnikov: I can't really explain the term well either :p Don't worry too much about it. As long as you understand "when we return a function referring to a local variable, we need a way to store that variable somewhere before this function returns, or the function we returned will crash"
02:33:18 <merijn> DigitalKiwi: I have that link bookmarked since I refer people to it so often :p
02:33:33 <nkaretnikov> merijn: so is it like a stack?
02:33:55 <nkaretnikov> merijn: i guess it's a general concept that can be implemented this way, right?
02:33:56 <DigitalKiwi> merijn yeah well I don't have it bookmarked and I found it before you so ha! :(
02:35:31 <merijn> nkaretnikov: The paper basically deals with "lazy functional languages don't look a lot like what CPUs are designed for" (i.e. C) and thus "how can we translate something lazy functional to something CPUs deal better with?"
02:35:36 <adjofun> nkaretnikov: https://www.docdroid.net/JtdY7Jg/ton.pdf
02:36:48 <merijn> nkaretnikov: It introduces both a minimal, lazy, functional language (like I said, only closures, lambda's, pattern matching and function application) and "VM" to run that language, then a bit about how you can implement that VM on a CPU. Similar to how C's behaviour is defined in relation to the "C abstract machine"
02:39:04 <nkaretnikov> merijn: yeah, i'll definitely read it. i love this stuff.
02:39:25 <DigitalKiwi> I was perusing the ghc repo on github and what are all of the C files used for?
02:39:36 <merijn> DigitalKiwi: The runtime system is implemented in C
02:39:56 <nkaretnikov> merijn: but first i should finish "implementing functional languages: a tutorial" by spj and david lester
02:40:05 <DigitalKiwi> I don't know much about the rts
02:40:13 <AndreasK> cocreature: Well thats just cheating
02:40:20 <merijn> Mainly for 2 reasons: 1) makes it easier to port the runtime to different languages" and 2) we've got one that performs well, so why rewrite it
02:40:50 <DigitalKiwi> the rts is like the garbage collector and...other things?
02:40:51 <merijn> DigitalKiwi: the RTS is basically the code responsible for implementing garbage collection, memory allocation, thread management, timers, etc.
02:40:56 <merijn> DigitalKiwi: Yeah
02:43:25 <AndreasK> All the pointer wrangling gets shoved into the RTS
02:44:51 <DigitalKiwi> so when ghc compiles does most of the intermediate stuff happen in memory or does it write it places
02:45:25 <AndreasK> DigitalKiwi: Most is in memory. I think assembly is written to temp files before it's turned into binaries
02:45:26 <merijn> DigitalKiwi: afaik it's basically all in memory until it outputs binaries
02:45:50 <merijn> Actually, yeah, I think asm gets dumped to tempfiles
02:46:23 <AndreasK> But the passes before that happen on data structures in memory
02:47:26 <AndreasK> DigitalKiwi: If your really interested there are the -ddump-<thing> variety of flags which output the intermediate stages
02:48:10 <DigitalKiwi> those are mostly for debugging I guess then
02:48:24 <AndreasK> Yeah, but also helpful for optimization at times
02:49:09 * hackage data-diverse-lens 3.1.0.0 - Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which  http://hackage.haskell.org/package/data-diverse-lens-3.1.0.0 (louispan)
02:49:38 <DigitalKiwi> someone used the core the other day to show that two different implementations of a function were actually turned into the same thing
02:49:58 <AndreasK> DigitalKiwi: Things like that yes
02:52:11 <AndreasK> DigitalKiwi: Also good to check if you want to know if functions get specialized and the like
02:52:57 <DigitalKiwi> specialized?
02:54:09 <AndreasK> DigitalKiwi: When you write code using type classes ghc can sometimes determine which class will be used. So it will optimize for that "special" use case.
02:54:25 <DigitalKiwi> oh
02:55:39 <AndreasK> DigitalKiwi: For example if you write add f :: (Num x); f x = x + 1
02:56:08 <AndreasK> Without specialization/inlining the code will have to get the (+) function from the Num instance used and call that.
02:56:38 <AndreasK> If we only ever call it with Int we can skip that check and directly use (+) for Int
02:58:33 <kuribas> tell asheshambasta: hi!
02:58:47 <kuribas> asheshambasta hi
02:59:01 <DigitalKiwi> so say it specializes it, and then later on you use add somewhere with something not an Int, will that cause a performance regression in the place that was using it before?
03:01:05 <ventonegro> DigitalKiwi: Only the call sites that pass Int would be specialised
03:01:20 <kuribas> DigitalKiwi: no, because it specializes it to any type which is used (at ghc's discretion).
03:01:47 <ventonegro> (in this example)
03:02:35 <AndreasK> DigitalKiwi: As ventonegto said no. It keeps the polymorphic version around, but creates a specialized version on top of that. So it will pretty much never make performance worse. At worst it falls back to the "regular" version.
03:03:51 <ventonegro> DigitalKiwi: This is an nstance of a more general code generation technique called partial program evaluation
03:05:35 <ventonegro> DigitalKiwi: Because typeclass restrictions are conceptually just extra arguments
03:09:02 <DigitalKiwi> huh, neat
03:13:41 <kuribas> you can also force ghc to specialize with the SPECIALIZE pragma
03:15:51 <DigitalKiwi> I still have too many books to read to worry about that :|
03:17:31 <kuribas> DigitalKiwi: you don't need to worry about it, the defaults are usually good enough.
03:17:38 <kuribas> but it's nice to know when you need super speed.
03:19:32 <DigitalKiwi> specialize all the things!
03:21:58 <kuribas> well, it is a trade of for code size
03:22:46 <zezeri> any windows haskell users here?
03:23:02 <zezeri> have been trying to solve an issue for 2 days
03:23:17 <zezeri> would be super grateful if anyone could lend me a hand here
03:23:18 <tdammers> zezeri: probably; but why don't you just ask your question?
03:23:34 <zezeri> so i am trying to install the haskell platform
03:23:40 <[exa]> zezeri: don't ask to ask just ask
03:24:14 <zezeri> when i install the full version, then
03:24:30 <zezeri> 1) "create ghci process failed with error 2" after trying to launch whci
03:24:38 <zezeri> 2) starting ghci via cmd does not work
03:24:55 <[exa]> does 2] give any useful error?
03:25:13 <zezeri> it says "ghci" is not found, aka not a known program
03:25:57 <[exa]> try finding it in the directory structure and executing it directly (you probably just don't have it in PATH)
03:27:38 <zezeri> Alright, will try this now :)
03:54:04 <isovector> is there a way i can disable defaulting?
03:54:27 <isovector> i have OverloadedStrings on, and an trying to get `print "hello"` to fail with an ambiguous Show constraint
03:54:38 <isovector> (assuming this is caused by defaulting?)
03:54:56 <cocreature> no it’s caused by the type of print not being polymorphic
03:55:11 <isovector> `print :: Show a => a -> IO ()` sure looks polymorphic
03:55:14 <cocreature> eh wait I can’t read, sry
03:55:18 <cocreature> I somehow read print as putStrLn
03:55:26 <isovector> yeah, no worries :)
03:55:50 <cocreature> have you enabled ExtendedDefaultRules?
03:56:02 <marvin3> it looks like defaulting is disabled, string literal doesn't default to any of the supported string types
03:56:37 <isovector> that's okay; i'm explicitly trying to get it to fail for writing a ghc test
03:56:55 <Taneb> isovector: "default ()" as a top-level declaration
03:57:11 <cocreature> or -Wtype-defaults -Werror=type-defaults
03:57:26 <isovector> Taneb: that did it. thanks!
03:58:30 <Taneb> isovector: section 4.3.4 of the Haskell 2010 standard
03:58:43 <Taneb> Especially the last sentence, "The empty default declaration, default (), turns off all defaults in a module."
03:59:16 <cocreature> I’m still not sure why defaulting comes into play here unless you explicitely enable ExtendedDefaultRules
03:59:47 <isovector> cocreature: well with overloaded strings on, "a" becomes `"a" :: IsString a => a -> String`
03:59:59 <merijn> cocreature Pretty sure that's redundant, -Werror should also enable the warning
04:00:13 <opqdonut> isovector: surely just `IsString a => a`?
04:00:15 <isovector> or something along those lines
04:00:15 <isovector> yeah
04:00:26 <isovector> going cross eyed here :)
04:00:36 <cocreature> isovector: right but I thought GHC doesn’t default IsString a => a?
04:00:49 <cocreature> merijn: I can never remember if it is :)
04:00:57 <isovector> apparently it defaults it to `String` at least in some circumstances
04:01:03 <merijn> cocreature: I had to dig through the GHC code to do flag filtering :p
04:01:17 <merijn> isovector: Are you sure it's defaulting and not just inferring?
04:01:38 <cocreature> ah the user guide mentions defaulting
04:01:49 <cocreature> not sure how I managed to miss that so far
04:02:01 <isovector> merijn: reasonably sure. `print` is polymorphic in its parameter, and `"foo"` should be polymorphic in its return type
04:02:07 <cocreature> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-string-literals
04:14:39 <zezeri> C:\Program Files\Haskell Platform\8.2.2
04:14:44 <zezeri> where is the ghci.exe usually located at?
04:16:41 <zezeri> C:\Program Files\Haskell Platform\8.2.2\winghci in here it is not
04:17:01 <zezeri> C:\Program Files\Haskell Platform\8.2.2\bin
04:17:03 <zezeri> in here it isnt either
04:17:11 <hc> Are you using the haskell platform directly, or stack?
04:18:12 <hc> stack can manage all ghc installations for you so you needn't worry about them ( https://docs.haskellstack.org/en/stable/README/ )
04:18:34 <hc> then you just do "stack ghci" to call ghci
04:19:06 <zezeri> i am using haskell platform https://www.haskell.org/platform/windows.html
04:19:51 <zezeri> if i start cmd and put in "stack ghci" it starts downloading haskell 8.2.2 again. Although I have already installed it
04:20:36 <marvin3> if you want to use stack you don't need haskell platform
04:21:45 <Boarders> possibly very dumb but what is the difference between multiway if and guards?
04:23:31 <merijn> Boarders: multiway if is 1) an extension and 2) can appear anywhere expressions can
04:23:40 <Boomerang> Boarders: You can only put guards on functions/variable definitions and case statements if I recall correctly. Multiway if is just an expression form of guards. Mutliway if is equivalent to `case () of () | guard1 = .. | guard2 = ...`
04:23:44 <merijn> Boarders: Guards are standard and can only appear in definitions
04:24:10 <Boarders> ah I see
04:24:11 <Boomerang> (I meant `->` instead of `=`)
04:24:12 <Boarders> thanks!
04:24:18 <hpc> guards can appear anywhere there's a pattern match, doesn't have to be a "definition" per se
04:24:29 <hpc> > (\x | True -> x) "guards"
04:24:32 <lambdabot>  <hint>:1:5: error: parse error on input ‘|’
04:24:46 <hpc> or maybe you're right :(
04:24:46 <merijn> hpc: Pretty sure they can't appear in lambda's
04:24:54 <merijn> hpc: But you're right that they can appear in case-of too
04:24:54 <Boomerang> > let x | isJust = Just 5 in x
04:24:56 <lambdabot>  error:
04:24:57 <lambdabot>      • Couldn't match expected type ‘Bool’
04:24:57 <lambdabot>                    with actual type ‘Maybe a0 -> Bool’
04:25:11 <merijn> Boarders: isJust is not a Bool
04:25:24 <Boomerang> > let x | isJust x = Just 5 in x
04:25:27 <lambdabot>  *Exception: <<loop>>
04:25:39 <merijn> I could've told you that was going to happen :p
04:25:43 <Boomerang> hehe
04:26:42 <hc> The recommended way these days is to use stack infavour of the haskell platform afaik
04:26:54 <zezeri> alright so i uninstall haskell platform
04:26:57 <merijn> hc: That depends on who you ask
04:27:01 <zezeri> and then install stack
04:27:05 <hc> merijn: yeah...
04:27:14 <hc> merijn: who would say otherwise?
04:27:29 <merijn> I wouldn't recommend stack, but then I wouldn't recommend platform either
04:27:35 <dminuoso> hc: You dont need stack. cabal with new-build gets you quite far too..
04:27:53 <Taneb> (I tend to just install the GHC binary and then bootstrap cabal)
04:27:58 <s4ke> hey guys... i've got some problems with TemplateHaskell
04:27:58 <merijn> Taneb++
04:28:23 <s4ke> what's the equivalent for complex types to ''Int
04:28:29 <s4ke> i want to do something along the lines of
04:28:37 <s4ke> $(mkEvalTasks [''MyInt, ''Int, ''MaybeGrid, ''MaybeGridList])
04:28:53 <s4ke> where i don't want to write a type declaration for each composite type
04:28:57 <hc> merijn: I'm using stack for a (small) commercial project. I'm very interested in arguments against it
04:28:59 <merijn> s4ke: Can you not use a quasiquoter to get the quoted types?
04:29:10 <s4ke> merijn: <- TH newbie
04:29:18 <Taneb> hc: eh, it's a tool, if it works for you, great
04:29:22 <opqdonut> yeah
04:29:25 <Taneb> I've just never found it necessary for me :)
04:29:26 <s4ke> i am a newbie i mean
04:29:27 <merijn> hc: Stack has a very rigid workflow it expect you to use, if that workflow doesn't match what you want everything is an uphill struggle
04:29:33 <Boomerang> [t|Complex Double|] or AppT ''Complex ''Double
04:29:44 <merijn> hc: And stack's workflow very clearly doesn't match how I like to work
04:29:51 <boj> hc: i don't think any of us non-stack using people are against it, it's just that we use other tools we find preferable
04:30:01 <s4ke> Boomerang : sec
04:30:02 <zezeri> as a windowsuser
04:30:12 <zezeri> who is a beginner
04:30:16 <zezeri> what would be most suitable?
04:30:18 <hc> boj: yeah. I thought so, I just like to increase my situational awareness ;-)
04:30:30 <hc> merijn: what does your workflow look like? What do you use? nix?
04:30:33 <zezeri> So far i have tried platform (core & full) and have had massive issues with both (obv that is probably on me)
04:30:37 <merijn> hc: new-build
04:30:46 <hc> oh ok
04:30:54 <s4ke> Boomerang: i am working on names though
04:31:01 <s4ke> or wont that work?
04:31:36 <opqdonut> hc: I have no issues with stack, and I like how it lets me keep old projects alive and upgrade to a newer resolver when I want to
04:31:37 <s4ke> hmm nvm makes sense
04:31:54 <opqdonut> merijn: btw what's this "stack workflow"?
04:32:15 <merijn> opqdonut: Forcing everything to be defined in terms of projects and snapshots
04:32:21 <opqdonut> ah ok
04:32:27 <opqdonut> well that feels pretty natural to me
04:32:38 <s4ke> another question:
04:32:50 <opqdonut> but yeah it's that convenient for ad hoc use
04:32:58 <s4ke> i am getting an error talking about a function not being available at reify
04:33:14 <merijn> opqdonut: I'm sure it feels natural to you and many people, but having to use "stack <exe>" all the time just gets in my way and annoys me. As does having to learn random new formats and having to track snapshots and then work-around stuff not being in snapshots, etc. yet
04:33:18 <s4ke> nvm...
04:33:20 <s4ke> :D
04:33:30 <Boomerang> s4ke: Is it possible for you to paste code and error somewhere like lpaste?
04:33:34 <Boomerang> Oh :)
04:34:02 <merijn> opqdonut: I'm comfortable with cabal and ghc, I had almost no issue before sandboxes, and 0 issues after sandboxes, so I'm to curmudgeony to change. new-build otoh is just "cabal, but better"
04:34:20 <opqdonut> merijn: right, and I haven't had a chance to try out new-build yet
04:34:46 <merijn> opqdonut: If people prefer stack, fine. But I dislike the active "stack is the only tool" advocating or people insinuating that there is community consensus that stack is "the only way to work"
04:34:46 <opqdonut> but I definitely like snapshots, because I have a couple of haskell projects that I work on ~once a year, and I like to keep them functioning
04:35:01 <cocreature> tbh new-build and stack feel more similar than different in most areas
04:35:07 <opqdonut> yeah I've heard that
04:36:28 <Boomerang> s4ke: I got the example without quasiquote wrong, it should be: AppT (ConT ''Complex) (ConT ''Double)
04:36:48 <Boomerang> But you can check by just doing `runQ` of the QuasiQuote in ghci :)
04:38:11 <phadej> opqdonut: for some things stack's default "snapshot" works. remember that Cabal had freeze files for long time too. Also for me cabal new-build works better to bring "over an year old projects" up to date than with stack, YMMV
04:38:29 <opqdonut> sounds like I should try new-build then
04:38:35 <opqdonut> but maybe I'll wait for another while...
04:39:20 <phadej> cat stack.yaml | sed 's/ - / /' > cabal.project
04:39:38 <phadej> and some manual cleanup: works.
04:39:53 <phadej> the only "problem" is that with cabal new-build you have to manage your GHC installation
04:40:03 <phadej> that also where YMMV, if that's an issue or not
04:40:09 <merijn> phadej: I consider that a feature
04:40:43 <Boomerang> stack exec -- cabal new-build # :D
04:40:43 <phadej> merijn: but not all people ;)
04:40:57 <opqdonut> kinda related to this, I'm teaching a haskell course right now. the fact that stack pulls in the given version of ghc is so nice
04:41:09 <merijn> phadej: Sure, that's why I don't insist on everyone using new-build
04:41:13 <opqdonut> since people have various distros with various old versions of ghc available
04:41:24 <merijn> opqdonut: Just tell them to use the GHC bindists?
04:41:47 <merijn> opqdonut: That's what I've been using for years, because more than half the machines I need to install GHC on I don't have root on anyway
04:41:54 <zezeri> So
04:42:00 <zezeri> There are multiple options
04:42:02 <zezeri> cabal
04:42:02 <srhb> Clearly we need just another level of abstraction that you can either --cabal, --cabal-new, --stack, or --nix :P
04:42:03 <zezeri> stack
04:42:03 <opqdonut> that might work, but it's definitely more work than just running "stack build"
04:42:05 <zezeri> and platform
04:42:06 <zezeri> correct?
04:42:10 <merijn> Also makes it easy to use/have multiple GHC versions in parallel and portable to basically any unix system around
04:42:13 <zezeri> (as in the options that are used usually)
04:42:14 <boj> well, anyways. there are a lot of options
04:42:17 <zezeri> for windows
04:42:22 <phadej> zezeri: platform is just a way to get stack and cabal and ghc :)
04:42:38 <zezeri> ahhh that makes sense :)
04:42:46 <zezeri> i did install platform
04:42:53 <zezeri> and when i do cmd.exe and "stack ghci"
04:42:59 <zezeri> it starts downloading haskell again O_o
04:43:04 <zezeri> which is really confusing
04:43:17 <boj> that would be confusing
04:43:18 <phadej> merijn: note, for students "./configure && make install" might be too much
04:43:29 <phadej> undergrads in particular
04:43:29 <zezeri> I just want to be able to compile haskell and also use the UTest stuff.
04:43:31 <zezeri> sigh
04:43:45 <merijn> phadej: It depends on the students, our undergrads are definitely expected to be able to manage that sorta thing without supervision
04:43:49 <phadej> also on Windows it's PITA
04:43:50 <dminuoso> phadej: Why would you want stack *and* ghc?
04:44:00 <dminuoso> I mean stack comes with a global project so...
04:44:25 <cocreature> dminuoso: because stack and cabal are bad at different things so I use both :)
04:44:31 <boj> dminuoso: hindishgt man. easy to say from the shoes of someone comfortable with the ecosystem
04:44:51 <zezeri> java, c++ have been soooo much easier to setup than haskell
04:45:06 <zezeri> that might just be me though
04:45:14 <dminuoso> zezeri: Are you sure? What build system does "C++" ship with?
04:45:18 <boj> i guess i assume people asking "which is better?" is a newb to the ecosystem (maybe not the language)
04:45:20 <dminuoso> zezeri: What package management does "C++" ship with?
04:45:27 <dminuoso> zezeri: What dependency management system..
04:45:28 <merijn> zezeri: C++ is such a PITA, tbh
04:45:43 <dminuoso> zezeri: C++ is the definition of "do it yourself".
04:45:46 <hc> well, both C++ and java come with IDEs
04:46:05 <opqdonut> errr?
04:46:09 <merijn> hc: Pretty sure that when I spent 1.5 hours compiling clang++ it didn't come with an IDE
04:46:12 <opqdonut> more like there are IDEs that come with java/c++?
04:46:15 <opqdonut> yeah
04:46:41 <hc> merijn: pretty sure when I last did windows development, Visual C++ did come with an ide =)
04:46:42 <dminuoso> hc: But yes. The C++/Java IDE market is much better, but the industry has been investing a lot of money over many decades in there. Not too surprising.
04:46:53 <hc> okay, that was in 2000, haven't looked at C++ since
04:46:59 <merijn> hc: No, the Visual C++ IDE came with a compiler
04:47:13 <dminuoso> hc: C++ itself is just a standard with no reference implementation.
04:47:25 <hc> that's comparing apples to oranges, though :)
04:47:25 <merijn> dminuoso: Theoretically, so is Haskell :p
04:48:09 <hc> Maybe we need Visual Haskell =)
04:48:19 <hc> Or (IsVisual l, IsHaskell h) h ;p
04:48:51 <dminuoso> hc: Anyway. C++ has a pretty horrid toolchain support. Just consider that there are no unified ways to publish libraries packages, to use dependencies, build things..
04:49:05 <boj> hc: you make a valid point. i recall taking a CS course in the late 90s and some students didnt even understand they OS they were using, let alone than an IDE and compiler were two different things
04:49:09 <dminuoso> A completely unstable ABI makes things fun too
04:50:42 <dminuoso> merijn: Speaking of which, when will we get a new report?
04:51:04 <merijn> No clue
04:51:29 * cocreature resists the urge to rant about how a new report is doomed to fail
04:51:59 <boj> what is a "new report"?
04:52:37 <opqdonut> haskell report
04:52:40 <opqdonut> i.e. the haskell standard
04:53:04 <boj> i thought that was going to happen in like 2020?
04:53:26 <boj> what is your role in that merijn?
04:53:38 <merijn> boj: Eh, nothing? :p
04:54:03 <boj> well that is confusing. why would dminuoso ask you? :p
04:55:36 <merijn> I'm just that cool and popular :)
04:55:53 <dminuoso> Except for category theory
04:55:56 <dminuoso> =P
04:56:30 <dminuoso> So I've pulled another red herring. I thought understanding the Yoneda lemma would improve my Haskell - but not really.
04:56:59 <merijn> dminuoso: You know what improves your Haskell?
04:57:06 <dminuoso> Writing Haskell? =)
04:57:09 * hackage hpc-threshold 0.1.0.0 - Small utility for validating whether HPC result is above defined thresholds  http://hackage.haskell.org/package/hpc-threshold-0.1.0.0 (eckyputrady)
04:57:26 <merijn> I was gonna say "less obessing over abstract nonsense, and more writing Haskell", so...yeah
04:57:28 <boj> i've found that coding boring production systems has improved my haskell
04:57:51 <dminuoso> But honestly, I actually just stepped into Yoneda out of raw curiosity.
05:10:29 <zezeri> does anyone know how i can fix the issue with haskell platform?
05:10:31 <zezeri> on windows
05:10:35 <zezeri> would like to be able to start/find ghci
05:10:44 <zezeri> and, you know, compile haskell files :P
05:11:02 <hc> Well just use stack if you ask me
05:11:28 <hc> (or did I miss something?)
05:11:32 <marvin3> zezeri stack works nicely on windows. it will even install ghc for you
05:12:05 <zezeri> "create ghci process failed with error 2"
05:12:07 <zezeri> getting this error
05:12:30 <zezeri> and if i try to start with cmd.exe "ghci" it says program not found
05:12:59 <marvin3> try stack ghci, assuming you installed stack
05:14:25 <cocreature> zezeri: which version of the haskell platform have you installed?
05:16:29 <zezeri> the latest
05:16:41 <zezeri> aka 8.22 cocreature
05:16:52 <cocreature> zezeri: have you tried starting ghci from the msys shell?
05:19:05 <zezeri> msys2.exe?
05:19:15 <zezeri> or mingw64.exe
05:19:15 <zezeri> ?
05:19:20 <cocreature> the former probably
05:19:30 <cocreature> but I’m not a windows users so I’m sadly just guessing here :/
05:19:50 <zezeri> ok started it. which command would I put in to start it?
05:19:59 <zezeri> just "ghci" gives me nothing
05:20:08 <cocreature> nothing as in command not found?
05:22:26 <merijn> Nothing as frustrating as 2 pieces of code that almost, but not quite cleanly generalise...
05:22:27 <zezeri> -bash: ghci: could not find this command
05:22:32 <zezeri> this is what im getting
05:22:49 <cocreature> hm sorry not sure where the platform installs ghci to
05:23:01 <merijn> cocreature: It does if it installs GHC
05:23:11 <merijn> cocreature: However, platform on windows doesn't update $PATH
05:23:31 <cocreature> merijn: I said I don’t know where it install ghci to not whether it installs ghci :)
05:23:37 <merijn> OTOH, I have no clue how he's running bash and where that is getting it's path from
05:23:40 <merijn> ah
05:24:05 <marvin3> zezeri do you have just the platform installed? stack? both?
05:24:08 <cocreature> we really need some more windows users here to help people
05:24:41 <zezeri> marvin3
05:24:42 <zezeri> https://www.haskell.org/platform/windows.html
05:24:44 <zezeri> i have installed this
05:24:46 <zezeri> the "full" version
05:24:54 <zezeri> it seems to include stack, cabal  etc
05:25:30 <merijn> yeah, but you have to tell your shell how to find them
05:25:36 <merijn> zezeri: Also, how are you running bash?
05:25:51 <merijn> And which windows?
05:25:52 <marvin3> cygwin probably
05:25:57 <zezeri> Windows 10
05:26:49 <merijn> marvin3: Yeah, but I don't think platform installs GHC within cygwin. It ships with a cygwin (or msys? or whatever)compiler/linker used by GHC, but the end user doesn't use ghc via cygwin, afaik
05:27:19 <zezeri> blob:https://imgur.com/c79ab74f-f9c8-4071-a9e6-f61a1724be4e
05:27:44 <merijn> You copied that link too early
05:27:45 <zezeri> link above is trash
05:27:46 <zezeri> https://i.imgur.com/gDeDzEO.jpg
05:27:48 <zezeri> this one works
05:28:20 <merijn> zezeri: Don't open those msys/mingw things directly
05:28:41 <marvin3> ghc will not recognize cygwin paths, but as far as just running ghci goes it should work after he updates PATH
05:28:51 <merijn> zezeri: If you go up to that 8.2.2 directory, is there any ghc/ghci executable there?
05:29:18 <merijn> I'd just run PowerShell and try running ghci via absolute path first, then fix the path within powershell
05:41:16 <zezeri> merijn no there is no ghci.exe
05:41:21 <zezeri> not in the bin folder inside of 8.22
05:41:26 <zezeri> and neither in the 8.22 root folder
05:41:29 <zezeri> kind of weird
05:41:31 <zezeri> am reinstalling now...
05:42:30 <zezeri> C:\Program Files\Haskell Platform\8.2.2\bin is empty
05:42:58 <zezeri> C:\Program Files\Haskell Platform\8.2.2 contains only the uninstallers
05:43:10 <cocreature> zezeri: maybe try the  core installer rather than the full installer? the website explicitely recommends using that for most usecases
05:43:50 <zezeri> ok i will try core now
05:51:17 <zezeri> just installed core
05:51:23 <zezeri> it was missing ghci too O_o
05:51:25 <zezeri> this is weird af
05:51:37 <zezeri> now reinstalling and seeing what happens.  mfw.
05:53:41 <cocreature> zezeri: does it have ghc itself?
05:54:57 <maerwald> What do people use for financial numbers?
05:54:57 <zezeri> wasnt there either
05:55:04 <zezeri> tried both Full and Core
05:55:24 <cocreature> I wonder if you might just be looking at the wrong directory
05:56:47 <fr33domlover> How does one choose between throwing exceptions and ExceptT? In my code it seems I always use ExceptT, and throw actual exceptions only when using existing code that works that way (for example responses in Yesod)
05:58:10 <fr33domlover> Every time I have some algorithm / monadic action / etc. in which some actions can fail, I usually use Except or ExceptT on top
05:58:30 <fr33domlover> I wonder what are the recommended cases for actual 'throw'
05:58:36 <dminuoso> fr33domlover: MonadThrow maybe?
05:58:44 <marvin3> zezeri try stack, it will manage ghc installation for you, and set all the necessary environment variables.  https://docs.haskellstack.org/en/stable/README/
05:59:25 <fr33domlover> dminuoso, well MonadThrow is real throwing of exceptions yeah, as opposed to ExceptT which is sort of just a wrapper of Either
05:59:30 <marvin3> you don't need to uninstall what you have now to try it, it will create its own independent ghc installation
06:00:47 <fr33domlover> dminuoso, I feel like I always end up using ExceptT, it feels clean and works so well and captures the errors via types
06:01:28 <merijn> fr33domlover: So, what's the problem?
06:01:36 <fr33domlover> I know there are cases like async exceptions, throwing between threads, catching an exception based on type etc.
06:01:52 <fr33domlover> merijn, I just wonder in which cases one should prefer real exceptions :p
06:02:09 <merijn> fr33domlover: In applications where you can't be arsed to deal with errors
06:02:12 <fr33domlover> And whether perhaps some people prefer them in cases where I prefer ExceptT
06:02:12 <zezeri> marvin3 does include the HUnit module? (used for autotests)
06:03:01 <merijn> fr33domlover: For example, if you have a server running some loop over client input, what do you do when the network connection to the client fails? This can be somewhere nested pretty far from your network loop. So, just throw an exception and let the network loop deal with it
06:03:18 <marvin3> zezeri HUnit is part of stackage, so it will be installed the first time you try to use it
06:04:40 <fr33domlover> merijn, hmmm I see
06:09:44 <dminuoso> fr33domlover: I think it's a deeper topic. Are you talking about errors or exceptions?
06:09:53 <dminuoso> fr33domlover: And also, do you have IO in your stack already or not?
06:12:34 <zezeri> marvin3: So you would recommend just using stack instead of platform for less issues overall? And It would pe possible to install or Use HUnit without too many complications?
06:12:39 <marmistrz> How can I force evaluation of a non-monadic function in the IO monad?
06:12:40 <marmistrz> https://zerobin.net/?de7331cb8281cf07#f2himlKgjiWDSl4lR2ynFSOvGfKZVCcrVR60kFImFKY=
06:13:08 <fr33domlover> dminuoso, I'm mean errors in general. Yeah I guess it's a deeper topic. Often I use Except on pure code and ExceptT when it's on top of IO. I guess I'll just continue with this approach, use ExceptT until it's inconvenient and then use exceptions instead (throwing the result of ExceptT is trivial; just need to have an Exception instance for the error type I use)
06:13:19 <marmistrz> Use case: the foo function just checks if everything is sane, erroring out if there's something bad in the input, doing nothing if the input is ok
06:13:25 <maerwald> If you are in IO and have IO related failure, just throw an exception already and document it
06:13:47 <merijn> marmistrz: Honestly, the best solution is simply: Don't use error
06:14:29 <marmistrz> merijn, using error would simplify the code a great deal, since if I don't use error here, I'll just propagate the error to the top and print it there
06:14:44 <merijn> marmistrz: If you wanna do early termination on error and you're in IO then I'd say: use either exitFailure (to exit the program) or throwIO with an error instead of "error"
06:14:56 <marmistrz> merijn, the problem is that foo is not evaluated at all
06:15:00 <marmistrz> foo is not in IO
06:15:47 <merijn> marmistrz: And you can't have foo simply be Either or Maybe?
06:15:56 <marmistrz> merijn, I can, but it will complicate the code
06:16:02 <marmistrz> that's just a sanity check function
06:16:21 <fr33domlover> marmistrz, ah that depends on how foo is used and by whom!
06:16:25 <merijn> You can use "evaluate", but never good ever comes from this
06:16:27 <marvin3> zezeri `stack install HUnit' would do it. I like using stack because my years old projects that use older libraries and/or ghc versions still work and I'm not forced to update the code just to make them buildable again
06:16:55 <fr33domlover> If it's an internal function you can do whatever you like, but if someone else uses it they may prefer the Maybe/Either version
06:17:00 <fr33domlover> So it's nice to provide both
06:17:21 <dmwit> marmistrz: What is the type of `foo`?
06:17:23 <maerwald> marvin3: that's not a good thing. You should update your codebase
06:18:07 <marmistrz> dmwit, in the actual code it will be something like `ASTNode -> ()`
06:18:31 <marmistrz> if the function suceeds, then the AST is sane (has correct types), we can continue interpreting the AST
06:18:45 <dmwit> marmistrz: Right. So, just make it `ASTNode -> Bool` instead. Where you would call `error`, write `False`; where you would write `()` put `True` instead.
06:19:09 <dminuoso> fr33domlover: So you are not talking about exceptions?
06:19:29 <dmwit> marmistrz: Then in `main` you can be explicit: `unless (foo ast) (fail "aaaaa")`.
06:19:30 <fr33domlover> when (astIsBad ast) $ throwIO SomethingHere
06:19:31 <marmistrz> dmwit, this would require me to explicitly handle cases when some of the child nodes in the AST are ill-formed
06:19:49 <dmwit> marmistrz: Correct. Handle them.
06:20:03 <dmwit> marmistrz: Why is that hard?
06:20:18 <marmistrz> merijn, thanks for pointing the evaluate, that seems to do the trick
06:20:20 <dminuoso> fr33domlover: I'd say ExceptT over IO for *errors* is wrong.
06:20:28 <marmistrz> dmwit, extra work?
06:20:49 <marmistrz> it's a once-use project, no one is ever going to use it
06:21:00 <dmwit> marmistrz: I don't believe you. Currently you write e.g. ```foo child1 `seq` foo child2 `seq` foo child3 `seq` ()```. Instead you can write `foo child1 && foo child2 && foo child3`.
06:21:04 <dmwit> Looks like strictly less work to me.
06:21:39 <marmistrz> Oh, I forgot to say one thing
06:21:51 <marmistrz> The sanity check will run in a StateT + Reader Monad
06:22:16 <fr33domlover> dminuoso, what's the difference though? I write some ExceptT code with 100% convenience, apply runExceptT to that and if someone wishes, they can apply (either throw id) to the result and throw the error as an exception etc.
06:22:24 <marmistrz> so I'll just have something sanityCheck (EAdd a b) = do {sanityCheck a; sanityCheck b}
06:22:52 <fr33domlover> I just mean ExceptT allows me to write my code encoding the possibility of error in the type
06:23:08 <dmwit> marmistrz: andM acts = and <$> sequence acts; sanityCheck (EAdd a b) = andM [sanityCheck a, sanityCheck b]
06:23:09 * hackage hasbolt-extras 0.0.0.7 - Extras for hasbolt library  http://hackage.haskell.org/package/hasbolt-extras-0.0.0.7 (ozzzzz)
06:23:12 <merijn> marmistrz: That looks like it'd just be "traverse sanityCheck" if you make sanityCheck do the "right" thing using IO
06:23:16 <fr33domlover> If the user of my library code wants to hide the error behind the exception mechanism, they easily can
06:23:19 <marvin3> maerwald, I prefer to update my codebase when I want to. if I have to do a small change to my code and have to get things up and running quickly the last thing I want to do is waste time tracking down resolving all the changes (and dealing with potential package conflicts that did not exist when I wrote the code). guaranteed build is a great thing
06:24:26 <dmwit> marmistrz: (...or just use a short-circuiting monad in the first place)
06:24:54 <marmistrz> merijn, there's the thing that I also sometimes need to do some monadic actions, such as ask/get/put/modify/local, so I don't really see how I could use traversable in the monadic contexxt
06:25:10 <merijn> eh, how so?
06:25:12 <merijn> :t traverse
06:25:13 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
06:25:26 <fr33domlover> I feel like exceptions, while having the extra features ExceptT can't have, also have the weakness that their presence is not encoded in types; a given IO action can throw *anything*. That's why exception masking etc. exists, it lets you catch/block any exception in the cases you need to. With ExceptT you don't need to worry about that, you clearly see the error in the type. It feels like a nicer default to
06:25:28 <fr33domlover> me, maybe it's just in my head idk ^_^
06:25:38 <merijn> > traverse `asAppliedTo` put
06:25:40 <lambdabot>  error:
06:25:40 <lambdabot>      • No instance for (Typeable f0)
06:25:40 <lambdabot>          arising from a use of ‘show_M266650220898220951326835’
06:25:45 <fr33domlover> (I do use throw sometimes; but mostly my default is ExceptT)
06:25:48 <merijn> :t traverse `asAppliedTo` put
06:25:49 <lambdabot> (MonadState a f, Traversable t) => (a -> f ()) -> t a -> f (t ())
06:26:04 <merijn> marmistrz: Works just fine
06:26:07 <dmwit> fr33domlover: I have a similar reservation about exceptions. Your only hope is that the documentation is good, correct, and up-to-date. That is frustrating.
06:26:22 <marmistrz> Actually, what's the idea behind `f` in the signature of traverse?
06:26:26 <marmistrz> I don't really get it
06:26:29 <merijn> marmistrz: In fact, "I need to do some monadic action while traversing" is literally the reason traverse exists
06:27:03 <merijn> marmistrz: For when you wanna map some applicative action over a type
06:27:09 <merijn> :t traverse print
06:27:10 <lambdabot> (Show a, Traversable t) => t a -> IO (t ())
06:27:19 <merijn> :t traverse `asAppliedTo` print
06:27:20 <lambdabot> (Show a, Traversable t) => (a -> IO ()) -> t a -> IO (t ())
06:27:30 <fr33domlover> there's also:
06:27:33 <fr33domlover> :t foldrM
06:27:34 <lambdabot> (Monad m, Foldable t) => (a -> b -> m b) -> b -> t a -> m b
06:27:51 <dminuoso> fr33domlover: Well there is a group of folks that think it's a bit silly. The reason being: IO already implies "this thing could fail/error out"
06:28:13 <byorgey> marmistrz: (a -> f b) -> t a -> f (t b)  says, if for each 'a' you can produce a 'b' (while having some sort of f-effects) then you can map over a whole t-structure, turning all the a's into b's and collecting all the f-effects
06:28:26 <byorgey> it's like an effectful fmap.
06:29:47 <dminuoso> fr33domlover: Thing is it just doesn't compose well or easily.
06:29:57 <marmistrz> Looking at the documentation, I can't implement Traversable for a single Monad - in this case `StateT Store (Reader Env) a`
06:30:19 <merijn> marmistrz: That's not the traversable, that's the applicative you're traversing with
06:30:20 <marmistrz> I need to support all kinds of applicatives, and I greatly depend on the Monad I'm using during the transformation
06:30:27 <merijn> marmistrz: The Traversable is your expression type
06:30:29 <fr33domlover> dminuoso, I get your point! But I'm with dmwit, I prefer ExceptT and if you prefer to hide the error from the type, you can (either throw id) and it's as if there's no ExceptT in the code at all
06:30:51 <fr33domlover> dminuoso, so you really don't lose anything
06:30:55 <zezeri> marvin3 platform seems to install stack automatically
06:31:03 <marmistrz> merijn, if I want to traverse the AST, I need to implement for t=AST traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
06:31:23 <merijn> Right
06:31:26 <marmistrz> this quantifies for all applicatives, in particular monad
06:31:27 <marmistrz> *monads
06:31:40 <merijn> marmistrz: So?
06:31:49 <marmistrz> I'm using a single, very specific monad, so that I can accumulated the declarations, definitions etc
06:32:16 <marmistrz> I'm doing different actions in different nodes of the AST
06:32:21 <dminuoso> fr33domlover: It's not really hidden though.
06:32:22 <dminuoso> fr33domlover: If IO doesn't scream "potentially throws in a mysterious number of ways" to you..
06:33:05 <fr33domlover> dminuoso, well yeah I didn't mean that as criticism, just saying you can easily turn ExceptT into throwing an exception
06:34:05 <marvin3> zezeri, does "stack ghci" work?
06:35:30 <marvin3> haskell platform installing stack seems kind of backwards. one the features of stack is that it manages ghc installations for you, including ability to have multiple versions installed simultaneously
06:36:35 <marmistrz> Oh, I actually can't even try implementing Traversable for my type, since all the BNFC-generated types have kind *, and Traversable need * -> *
06:36:48 <jaarod2> gustaf why aperture priority over manual?
06:36:59 <zezeri> marvin3 when i do that, it seems to want to download haskell again ? (via cmd) But platform is supposed to have installed haskell already. And I would not want a double instalation
06:38:02 <marvin3> zezeri, that is what stack does, installs ghc required to build current project. it only does that once, assuming you don't create a project that uses newer version. after that you can just uninstall platform
06:38:40 <marvin3> personally I'd just remove haskell platform all together, and installs stack from the link I pasted earlier. and you should have haskell up and running quickly
06:40:16 <zezeri> so would you recommend me to deinstall platform and then do clean install of stack?
06:40:35 <zezeri> Or rather keep platform installed, launch stack and let it download haskell and then deinstall platform? Marvin3
06:41:54 <marvin3> doing a clean stack install always worked for me, so that is what I recommend
06:43:34 <zezeri> ok marvin3 i will try this and simultaneously pray that it does it :D
06:43:36 <marvin3> zezeri, neat thing about stack is that, if years from now, you try to rebuild your project on a newly installed OS, "stack install" will automatically downloaded required ghc version, and all the packages that your project depends on
06:44:12 <dminuoso> fr33domlover: Well I just feel that Haskell has no first-class solutions to elegantly handle "errors/exceptions" (and logging)
06:44:40 * hackage hapistrano 0.3.5.5 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.3.5.5 (juanpaucar)
06:44:42 <dminuoso> None of the solutions are obvious "this is a clean, type-safe and extensible/composable way to do it" candidates
06:45:04 <dminuoso> It's the main thing that annoys me about Haskell.
06:47:59 <fr33domlover> dminuoso, i wonder if some approach with mtl and typeclasses and lenses could help with that! hmmm could be interesting to try
06:48:54 <fr33domlover> like, instead of concrete exception types, each error could be a typeclass or something like that (generated with TH)
06:49:27 <fr33domlover> and then the "any code can throw any exception" thing can have a typed alternative
06:51:57 <hvr> marvin3: and if you're lucky it may even work
06:52:39 <hvr> marvin3: but in general there's a good chance it will not work if the OS you developed against originally has evolved enough over the years
06:53:42 <hvr> marvin3: it takes already a bit of work to keep old GHCs working on newer linux distros; it didn't come for free supporting GHCs back till GHC 7.0 on Debian 9 & Ubuntu 18.04
06:53:44 <marvin3> hvr, it has better chance of working than anything else.
06:53:50 <hvr> marvin3: no it doesn't
06:53:50 <zezeri> marvin3 https://www.stackage.org/stack/windows-x86_64-installer
06:53:53 <zezeri> this one, right?
06:54:18 <hvr> marvin3: feel free to believe it though and bet your business on it
06:54:21 <marvin3> hvr it does. if ghc doesn't work on newer OS, then no stack alternative will work either
06:54:30 <hvr> marvin3: wrong again
06:54:43 <marvin3> hvr please explain
06:54:47 <marvin3> zezeri yes
06:55:03 <hvr> marvin3: ever heard of Nix?
06:56:12 <zezeri> alright, installing now. i did "stack ghc" I hope this is correct, too? It is now downloading  ghc 8.2.2
06:56:32 <marvin3> hvr, nix is great. but that is far beyond the scope stack, and also not available on all the OSes. I was comparing stack to haskell-based solutions, ie cabal-new
06:56:36 <dminuoso> fr33domlover: The least annoying solution I have used so far is simply MonadThrow/MonadCatch because it let's me, the consumer, pick the exception monad.
06:57:12 <marvin3> cabal-new doesn't even try to manage ghc, it just hopes whatever you have installed works with the project you're trying to build
06:57:12 <dminuoso> Maybe things will become clearer with experience, I dont know.
06:57:56 <hvr> marvin3: well, cabal new-build has various features to allow you to get software to build that build years ago; if I tried that w/ Stack it would fail epically
06:58:19 <marvin3> hvr not in my experience
06:58:25 <hvr> marvin3: like, I can happily build stuff that worked w/ GHC 7.0.4 only
06:58:33 <hvr> marvin3: on today's distros
06:58:59 <hvr> Stack simply doesn't support that
06:59:22 <hvr> it might, but it's not a priority for stack developers
06:59:27 <hvr> so it doesn't
06:59:40 * hackage cpsa 3.5.0 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-3.5.0 (mliskov)
06:59:48 <marvin3> hvr, can't say I tried building stuff with decade old ghc versions, of course stack wouldn't work there, it didn't even exist then. but decade from now? it should work, assuming ghc still works on the OS you're using
07:00:18 <hvr> marvin3: let's talk in 10 years again, then ;)
07:00:45 <fr33domlover> dminuoso, yeah I use that too (when I don't use ExceptT lol)
07:00:51 <zezeri> please let it work now. im considering performing a sacrifical murder to please haskell.
07:01:05 <marvin3> hvr let's ;)
07:01:24 <Psybur> Anybody familiar with trading? Whats a good way to model market, limit, stop and trailing orders? Should I stick them all into one Order data type? Some orders have trigger prices, some get filled immediately. Dont know if something like data Order = Order { units, orderType, maybeTriggerPrice} is clean
07:01:25 <hvr> marvin3: but you'll notice that if stack still exists then, it won't be better than the alternatives
07:01:50 <hvr> marvin3: ther's no magic sauce to stack
07:02:10 * fr33domlover thinks hvr prefers cabal (new-)build
07:02:21 <Psybur> Or would something like data Order = MarketOrder {...} | LimitOrder { ...} | StopOrder {...} etc be better?
07:02:24 <hvr> fr33domlover: what gave it away? :)
07:02:31 <Zemyla> Psybur: Create a Trigger type, that way it's easir when you need to extend.
07:03:04 <sigma_severin> is #haskell-blah no longer?
07:03:07 <fr33domlover> hvr, readMindOf "hvr" :: IO ()
07:03:09 <fr33domlover> ^_^
07:03:29 <Cale> sigma_severin: I don't know, but #haskell-offtopic exists :)
07:03:33 <[exa]> Psybur: if the conditions get harsher (which they usually do) you'll want to reimplement a tiny subset of prolog btw
07:03:59 <Psybur> [exa], no idea what that entails :D
07:04:32 <marvin3> hvr, it is better than haskell-based alternatives. again, it is the only one that manages parallel ghc installations for you. you can argue that nix is even better, but how does nix help you if you also have to build on windows?
07:04:47 <Taneb> Psybur: it entails entailments ;D
07:04:56 <merijn> marvin3: "manages parallel ghc installations" <- what's there to manage, tbh
07:04:58 <cocreature> sigma_severin: haskell-blah turned on obligatory ssl which pissed some people off so now we have haskell-blah which requires ssl and  haskell-offtopic which doesn’t
07:05:04 <dminuoso> Is there some trick to dry up Proxy? I basically just want to do `serve @AccountAPI serveAccounts` rather than `serve (Proxy :: Proxy AccountAPI) serveAccounts`
07:05:14 <hvr> marvin3: well, I've seen Stack install broken GHC installs
07:05:15 <merijn> marvin3: Just install multiple GHCs and change your path to use whichever you want?
07:05:17 <[exa]> Psybur: that you will want to embed a better trigger function than just (>= 5usd)
07:05:38 <hvr> marvin3: so call me unimpressed with its ability to poorly manage ghc installs
07:05:39 <marvin3> merijn, and when I upgrade OS? do that all over again. instead of just doing "stack install"
07:05:45 <cocreature> dminuoso: Proxy @AccountAPI?
07:05:53 <Cale> cocreature: Another difference is that the mod list is the same between #haskell and #haskell-offtopic
07:05:59 <hvr> marvin3: moreover, I've about 20 GHC versions installed side by side, via `apt`
07:06:03 <merijn> marvin3: My GHC installs aren't touched by my OS?
07:06:04 <dminuoso> cocreature: I was hoping to get rid of that artificial proxy entirely
07:06:10 <hvr> marvin3: stack doesn't even come close to that
07:06:15 <cocreature> dminuoso: that would require changes to serve
07:06:22 <marvin3> hvr, for someone who doesn't use stack it seems that you have hit every edge case bug scenario
07:06:30 <Psybur> [exa], well I'd be using a Strategy that runs every candle that would create orders based on market conditions and IO. Trigger is more like a trigger price for limits and stops
07:06:35 <marvin3> I never experienced stack breaking my ghc installation
07:06:49 <Psybur> Market orders dont have a trigger, but the others do.
07:06:53 <hvr> marvin3: I sometimes have to help out people using Stack ;-)
07:07:04 <mnoonan> marvin3: for context, realize that hvr is a core cabal developer :)
07:07:22 <dminuoso> cocreature: Mmm, I guess Ill use TypeApplications on Proxy then like you said.
07:07:24 <dminuoso> cocreature: Thanks.
07:07:33 <hvr> marvin3: so by construction I get confronted with lots of bug scenarios
07:07:35 <Cale> https://www.tweag.io/posts/2017-11-10-nix-on-wsl.html -- for people interested in using nix on windows
07:08:31 <hvr> marvin3: and the one time I thought to myself, let's use Stack to install GHC on a platform for which I was too lazy to build a GHC from scratch, it failed me ;)
07:09:05 <hvr> (it was a  suse enterprise  linux )
07:09:18 <cocreature> Cale: ah good to know
07:10:29 <Cale> https://github.com/reflex-frp/reflex-platform/issues/177
07:10:42 <marvin3> hvr, we have completely different experience with stack, then. everything worked smoothly for me on every OS I tried. I am a relative new stack user though,  I was still using cabal sandboxes half a year ago
07:10:48 <Cale> It seems like this guy managed to get it to work well enough to run reflex-platform even
07:12:05 <marvin3> hvr, if most of the issues you describe happened a while ago then perhaps things have improved since then, and stack started delivering its promises
07:12:39 <hvr> marvin3: not sure, the frequency by which I encounter people running into issues has stayed about the same
07:12:50 <merijn> marvin3: stack just uses the linux distro approach to fixing issues "throw lots of human effort at it until it goes away"
07:13:06 <marvin3> if increasing number of people are using it, and same number of people are complaining, then things have improved
07:13:27 <hvr> marvin3: but don't get me wrong; I'm not claiming that cabal new-build is perfect either; I'd rather claim both tools suck in their own specific ways
07:15:23 <merijn> hvr: Like the fact that new-build's caching ensures that every local package ALWAYS gets rebuild no matter how irrelevant the flag changes are >.>
07:15:36 <hvr> merijn: didn't you fix that? :)
07:15:43 <maerwald> marvin3: a responsible maintainer of a library updates his codebase as fast as possible. stack has a detrimental effect on this paradigm, unfortunately
07:15:46 <merijn> hvr: No, only for non-local dependencies
07:16:11 <maerwald> which is not the fault of stack, but of how people use it
07:16:14 <merijn> hvr: For local dependencies it ignores the hash, it just caches the package configuration and rebuilds if that changes
07:17:22 <merijn> hvr: I plan to see if I can fix that, but that'd probably involve some non-trivial fiddling with the file-monitor logic to make it support predicates on file changes so it can conditionally trigger rebuilds and ignore "trivial" changes
07:17:58 <merijn> hvr: OTOH, the non-local problem was much bigger, as you usually have like <10 local packages and rebuilding 100+ transitive dependencies when a flag changed is even more depressing :p
07:19:09 * hackage stackage2nix 0.7.0 - Convert Stack files into Nix build instructions.  http://hackage.haskell.org/package/stackage2nix-0.7.0 (typeable)
07:21:47 <merijn> hvr: Also, I'm still trying to sucker people here into beta-testing that fix :p
07:24:23 <merijn> Actually, looks like the filemonitor mostly supports what I need already, I just need to go on expedition and find out where to change things
07:26:35 <cocreature> hvr: the trick is to just use multiple tools and switch to another one if you hit the case where the one you’re currently trying to use sucks :)
07:30:11 <Taneb> The fun begins when you find some Haskell that comes not with a cabal file or a stack.yaml or a default.nix but with a Makefile
07:34:32 <dminuoso> Taneb: We can use cmake too! https://bitbucket.org/arrowd/cmake-findcabal
07:37:12 <maerwald> cool, a project with zero documentation
07:41:46 <shapr> maerwald: are you looking at my github repos again?
07:41:49 <shapr> @quote github
07:41:49 <lambdabot> Sketch says: <icculus> [9b] I hear GitHub is down again. Building a fully decentralized system that relies on a single entity is pretty great.
07:46:29 <maerwald> :o
07:48:10 <shapr> I do wish checkers had more fluffy docs
07:48:20 <shapr> perhaps I'll put up a PR
07:50:04 <byorgey> FLUFFY!!!!
08:14:51 <reactormonk> I've got a nested data structure which is approx. (x, [(y, [(z, a)])]) - how can I build an indexed lens traversal here? x, y, and z would be the indexes here.
08:15:53 <Psybur> Does this make sense as the functor for a trading DSL? https://hastebin.com/osiyobixad.vbs
08:15:55 <cocreature> reactormonk: so you want an indexed traversal into `a` indexed by `z`?
08:16:39 <reactormonk> cocreature, traversing over (y, [(z, a)]) should be indexed by x, over (z, a) should be indexed by y etc.
08:16:51 <reactormonk> ehh, indexed by (x, y) instead of just y
08:19:32 <cocreature> reactormonk: seems like you should be able to just use itraversed with the instance for tuples and then compose traversals with <., <.> and .>
08:20:33 <reactormonk> cocreature, with "approx." I mean it's a record. Lens it to a tuple first?
08:20:55 <jchia_1> Psybur: Do you mean for a Free monad? Not sure what it means concretely by OpenOrder and ClosePosition, but don't you need to know the time & market data to decide whether to OpenOrder or to ClosePosition? In that case, why are they different things? How do you read the time or market data?
08:20:57 <cocreature> reactormonk: in that case just write your own indexed traversal similar to the one for tuples
08:21:59 <reactormonk> cocreature, I'd assume implement TraversableWithIndex for my custom type?
08:22:25 <cocreature> reactormonk: or just write something of type IndexedTraversal …
08:22:45 <cocreature> IndexedTraversals are first class values just like lenses or whatever, no need to use a typeclass for them
08:22:46 <jchia_1> Psybur: If you're just recording a series of order activities, then Hold seems like a useless Nop.
08:23:00 <Psybur> jchia_1, I suppose closing a position is placing an order in the opposite direction and not necessarily a special operation
08:23:48 <cocreature> reactormonk: if you show us the type you actually care about, it might be possible to be a bit more specific :)
08:24:09 <Psybur> And I suppose I dont need a noop constructor, that could just be handled by the inerpreter
08:25:13 <reactormonk> cocreature, nah, it just went from "I need this" to "this could be useful" because I took another look at the original code and realized I could also solve it another, more straightforward way - involving less lenses.
08:25:22 <reactormonk> Gotta open that lens over tea study group at work
08:25:54 <cocreature> reactormonk: we all know that everything is better with more lenses
08:26:02 <Psybur> Is there value in a DSL thats just "OpenOrder, Throw, Done"? heh
08:26:05 <jchia_1> Psybur: What is this for? Are you trying to use Free monad? If it's just a series of fixed order activites, you could just use a dumb list. If it's something that reacts to the environment (time, market data, position), then it seems like there should be a item for reading them and separately an item for placing orders.
08:26:08 <reactormonk> cocreature, mostly job security :D
08:28:13 <Psybur> Wouldnt getting the market data be outside the realm of TradingOperations? Wouldt it be better if the market data would be fetched in the interpreter and then passed into the respective trading operation functions
08:28:43 <Psybur> In backtesting, the market data would be fetched from a file, in live it would be fetched with a web request
08:28:46 <jchia_1> Psybur: I don't know. Depends on what you mean by 'TradingOperations' and what it's supposed to do.
08:29:27 <Psybur> I was thinking the market data was captured in the market type in: OpenOrder ((market,[order],[position]) -> orderResponse) next
08:29:37 <Psybur> Maybe market should be marketdata instead
08:30:23 <Psybur> Or should it be a function of (market -> marketdata) heh
08:30:41 <jchia_1> Psybur: Then not just use a simple function like the one you package in OpenOrder? What do you want to use TradingOperation for?
08:31:02 <jakov> hello I am new to haskell, and I was curious as how to generate a million {{{{{{{{}}}}}}}} nested brackets.  recursive_print :: Int -> Int -> [Char]
08:31:03 <jakov> recursive_print max_num cur_num
08:31:03 <jakov>   | max_num <= cur_num   = "{}"
08:31:03 <jakov>   | otherwise            = "{" ++ recursive_print max_num (cur_num + 1) ++ "}"
08:31:10 <Psybur> If I set my project up like this, would it be easier to extend it later?
08:31:51 <mpickering> Is there an elegant way to combine together a folding function and summarising function, s -> a -> m s, a -> t into s -> [a] -> m (s, t)
08:32:24 <jakov> This is my first try, but the program halts.
08:32:43 <cocreature> mpickering: I’m not sure how that’s supposed to work, how do you get a t if I give you an empty list?
08:32:59 <mpickering> If it's an instance of Monoid
08:33:00 <Psybur> Using Free + Interpreter. Id have different interpreters for live, practice, backtest. But maybe they really do just need a function of MarketData -> ([order])
08:33:24 <cocreature> ah
08:33:49 <jchia_1> Psybur: It all depends on what you want to do with it. I suppose if I were to express using Free monad an automatic trading strategy that can be simulated and actually used for live trading, I would maybe give it a way to read the environment (time, market data, etc), a way to record state, a way to read state, a way to get its position and a way to place and cancel orders.
08:34:30 <jchia_1> not sure what to do about the 'DSL' part, though.
08:38:06 <Psybur> Im just confused on where "reading the environment" fits into this pattern. What benefit do I get from giving that its own constructor?
08:40:28 <cocreature> mpickering: not sure how elegant that is but with the foldl lib you can use the following: "\f g s -> foldM ((,) <$> FoldM f (pure s) pure <*> F.generalize (F.foldMap g id))"
08:40:43 <cocreature> mpickering: with F being Control.Foldl
08:41:17 <mpickering> looks nice enough, thanks
08:48:21 <zezeri> so I have installed stack on windows now and i can run ghci through it.
08:48:36 <reactormonk> Can't get my mind aligned... I've got HashMap (x, y, z) a and I want HashMap x (HashMap y (HashMap z a))
08:49:00 <zezeri> Any windows stack users that could help me with this?
08:49:03 <zezeri> Could not find module `Test.HUnit'
08:49:09 <zezeri> How to i load this module?
08:49:24 <reactormonk> zezeri, did you create your project with `stack new`?
08:50:16 <zezeri> no i just opened cmd.exe, entered "stack ghci" and then ":l myhaskellfile"
08:50:19 <zezeri> reactormonk
08:52:03 <cocreature> zezeri: try running "stack build HUnit" and restart stack ghci
08:52:09 <reactormonk> zezeri, https://www.stackage.org/lts-11.6/hoogle?q=HUnit -> https://www.stackage.org/haddock/lts-11.6/HUnit-1.6.0.0/Test-HUnit.html <- URL tells me it's in HUnit, so stack build HUnit
08:54:20 <jakov> Excuse me, could you please give me a hint as to what's the best way to generate a million nested brackets like this {{{{{{}}}}}} ? I have tried a recursive function with ++ and concat, but it hangs up.
08:55:17 <jakov> The program takes too long. As you can think, i am new to haskell :)
08:55:18 <reactormonk> jakov, first, wtf. second, tried some explicit streaming library?
08:55:46 <reactormonk> Usually, the laziness does the streaming for you, but it can't always do it for you.
08:55:48 <Psybur> jchia_1, so your current "state" is going to be recorded by a trading server. Does it still make sense to have a way to modify state? I can understand getting state
08:56:03 <hc> Hi all, what's the idiomattic way of writing forM_ [1 .. count] $ const $ do ...
08:56:13 <hc> s/ttic/tic/
08:56:39 * hackage lens-utils 1.4.3 - Collection of missing lens utilities.  http://hackage.haskell.org/package/lens-utils-1.4.3 (danilo2)
08:56:54 <Boarders> replicate 5 '{' ++ replicate 5 '}'
08:57:01 <jakov> @reactormonk No, i haven't.
08:57:01 <lambdabot> Unknown command, try @list
08:57:01 <cocreature> missing lens utils? I thought lens contained everything
08:57:20 <jakov> Thanks, i'll try it out !
08:57:25 <zezeri> this did it thank you so much cocreature!
08:57:30 <zezeri> finally it loads it without errors :)
08:59:37 <merijn> hc: replicateM
08:59:43 <merijn> :t replicateM
08:59:44 <Boarders> hc: what about something like replicateM_
08:59:45 <lambdabot> Applicative m => Int -> m a -> m [a]
08:59:51 <Boarders> beat me to it
08:59:58 <merijn> oh, yes, I suppose replicateM_ is better
09:00:03 <merijn> :t replicateM_
09:00:04 <lambdabot> Applicative m => Int -> m a -> m ()
09:00:14 <zezeri> walso thanks to marvin3, reactormonk
09:00:27 <zezeri> had spent hours trying to get this to work :D
09:00:33 <zezeri> now for actually learning the language :)
09:07:18 <lsund> Hi Anyone use postgresql-simple? How to convert between DATE, TIME and TIMESTAMP types in SQL to haskell types?
09:10:09 * hackage half 0.3 - Half-precision floating-point  http://hackage.haskell.org/package/half-0.3 (EdwardKmett)
09:11:45 <lonokhov> lsund: http://hackage.haskell.org/package/postgresql-simple-0.5.3.0/docs/Database-PostgreSQL-Simple-FromField.html#t:FromField docs have mappings for pg/haskell types
09:12:45 <lsund> Ah, I see now. Thanks for the pointer
09:24:44 <isBEKaml> Hi, is there any way I can see the list of available resolvers installed on my machine?
09:24:52 <isBEKaml> something like: stack list resolvers ?
09:27:48 <lyxia> isBEKaml: https://github.com/commercialhaskell/stack/issues/1614 ?
09:29:52 <cocreature> the stack 1.7 release candidate has a "stack ls snapshots" command
09:30:22 <isBEKaml> lyxia: Ah, indeed. So, it's not available on stable release yet. Thanks!
09:30:41 <isBEKaml> I'll wait for the next release then. I'm on stack 1.6.5
09:37:26 <marmistrz> I have a weird error while trying to add a dependency in stack:
09:37:26 <marmistrz> text-format-heavy must match -any, but the stack configuration has no specified version (latest matching version is 0.1.5.0)
09:37:26 <marmistrz> needed since interpreter is a build target.
09:37:59 <marmistrz> I don't really understand, 0.1.5.0 is a pretty find version to be matched by any
09:38:01 <cocreature> marmistrz: sounds like text-format-heavy isn’t in the stackage snapshot you’ve chosen. you need to add it to the extra-deps section in your stack.yaml
09:38:43 <marmistrz> cocreature, it's not there even in the latest nightly
09:38:51 <marmistrz> Stackage Nightly 2018-03-12 (ghc-8.2.2)
09:38:55 <cocreature> marmistrz: right that’s why you need to add it to extra-deps
09:39:27 <marmistrz> cocreature, is it possible to add it to extra deps with a version "any"?
09:39:31 <cocreature> no
09:39:38 <cocreature> stack tries to give you reproducible buidls
09:39:43 <cocreature> so you have to specify the version
09:40:10 <marmistrz> thanks
09:41:00 <infandum> I want to add a progress bar to my program and the libraries look good for that. But -- how can a lazy language have a progress bar? At what step does one add a percentage?
09:42:42 <lyxia> what does that have to do with laziness?
09:44:04 <[exa]> infandum: that's a good philosophical question. What's the computation you're doing btw?
09:44:37 <marmistrz> ... developing in Haskell on Arch Linux is so painful... There are no IDE integrations apart from the Haskell IDE Engine that work with GHC 8.2.
09:45:02 <marmistrz> But it works poorly when your distribution does Haskell dynamically-linked
09:45:04 <marmistrz> So you
09:45:08 <infandum> lyxia: Like, If I have a step done "calculated matrix" or something like that, it would print that step out immediately because the computation is delayed until it's needed which is unpredictable to know when it ends
09:45:15 <oak-> I use Stack on Arch Linux
09:45:30 <[exa]> marmistrz: suggestion is to completely avoid Arch packages
09:45:47 <marmistrz> [exa], the thing is that HIE fails miserably when you try to use it with a cabal package
09:46:07 <[exa]> infandum: you can easily force the computation using e.g. `seq` or any other kind of strict evaluation
09:46:11 <marmistrz> Even if you use it with ghc-pristine, it insist that the packages are not htere
09:46:44 <marmistrz> If you use stack, HIE works somehow but you get quirks like that "this package is not in the snapshot"
09:46:55 <lyxia> infandum: tracking progress makes your computation impure. you don't just take a pure function and stick a progress bar on it
09:47:48 <infandum> lyxia: Yeah, it would require IO to print
09:47:56 <ranberry> Is lens-aeson a good tool to try and convert an arbitrarily nested json bytestring into a map? Or am I using the library completely wrong?
09:48:27 <infandum> exa: That could alter the memory usage immensely, though
09:48:40 <wz1000> marmistrz: i use arch and have ghc-static installed and cabal installed through `stack install cabal` and hie works with cabal projects for me
09:49:12 <lyxia> ranberry: you could do that with just aeson
09:49:48 <[exa]> infandum: well if your results are large and you need them computed before printing out the progress, they need some storage. You can also output them (which forces the computation as well)
09:50:01 <lyxia> ranberry: lenses would be more useful to update the Value
09:52:30 <nshepperd_> You can sprinkle an impure function that increments a progress counter when things are evaluated throughout your program
09:52:41 <nshepperd_> Ala debug.trace
09:53:07 <infandum> exa: Not necessarily: "fmap (f2 . f1) ls" for a function and saying "f1 is done" then "f2 is done" I don't think should be strict, and a progress bar here in a lazy language is pretty much impossible (right?).
09:58:19 <[exa]> infandum: so you want your program to report that 50% of the work is done after f1 finishes?
10:01:49 <nshepperd_> This is one of the times when impurity is correct, since you are explicitly wanting to measure operational stuff (performance)
10:19:43 <Big_G> Is there a standard way to have two `IO ()`s going on at the same time
10:21:17 <[exa]> possibly forkIO, it depends on how parallel you want it
10:21:27 <johnw> Big_G: async is the preferred way
10:21:43 <johnw> it handles a lot of the plumbing for you, which forkIO does not
10:22:28 <iamrecursion> Is it possible to set the indentation that results from an `encode` call using `yaml`?
10:22:51 <iamrecursion> I was looking through the Aeson options, but I didn't see anything pertinent
10:24:33 <Big_G> Is that true in all cases johnw? The two IO () have nothing to do with eachother beyond having some network calls and us wanting to not have the system wait while they happen.
10:30:09 <johnw> Big_G: I'd still say it's true, because async exceptions can happen at any time, anywhere, and async gives you a sane know of knowing which thread will be reporting them
10:34:03 <oo_miguel> I am playing with concurrency as explained in real world haskell: chapter 24 and it seems that the example merge sort algorithm (without any pseq or par) already uses all my cores and performs even better than the other 2 versions... is this possible that things changed that much since ghc 6... and is there sitll any use for `par` and `pseq` or am I doing somehting horrbibly wrong if I get such results?
10:37:10 <marmistrz> wz1000, thanks, I think I'll try that out when I do one more project in Haskell. I'm too deep in stack right now to move :)
10:54:50 <cocreature> oo_miguel: can you show us the code? GHC doesn’t do automatic parallelization so I would be surprised if it uses all your cores for anything useful (the garbage collector might use all cores but that’s often actually slower than having it run on one core only)
10:57:03 <barlin> hey there, is there a way to define data constructors without declaring the data type? Let's say I have: data Foo = Bar | Baz. Could Bar or Baz reference a predefined data constructor?
10:57:42 <oo_miguel> cocreature: http://lpaste.net/365187
10:59:39 <oo_miguel> in fact i get almost the same results with all 3 examples given at the top in the comment... around ~2 seconds always +/-0.3seconds
10:59:44 <Clint> barlin: what
11:00:09 * hackage sdl2-ttf 2.1.0 - Bindings to SDL2_ttf.  http://hackage.haskell.org/package/sdl2-ttf-2.1.0 (MikolajKonarski)
11:02:05 <barlin> What I'm trying to get at is if I could define one data constructor and then reuse that constructor for mulitple data types? Sorry, pretty fresh, so this might be a stupid question
11:04:06 <cocreature> oo_miguel: you might want to benchmark sorting the same array, I’m getting rather large fluctuations based on which random array got created
11:04:16 <cocreature> oo_miguel: also I would recommend to use criterion for the benchmarks
11:05:14 <lyxia> barlin: you could hack something with PatternSynonyms, but the short answer is no.
11:05:51 <oo_miguel> cocreature: ok, thank you for both valuable suggestions. just want to make sure i understand two more things.. 1st) you stated that the test "1" uses only one core, and my other 7 cores do only garbage collection, right? this still holds true if I call it with -N8 right?
11:06:40 <oo_miguel> 2nd) when I do the sorting with -sstderr I get some info about the timings.  example: GC      time   11.174s  (  1.367s elapsed). what do both this values mean?
11:06:59 <oo_miguel> like cpu time and REAL clock time?
11:07:30 <barlin> ok thanks for the lead :)
11:07:30 <oo_miguel> 1.4s * 8cpu = ~ 12seconds ?
11:08:04 <oo_miguel> or do the values refer to something else?
11:08:11 <cocreature> that should be it
11:08:27 <cocreature> and to 1, that’s true. GHC won’t run things in parallel if you don’t tell it to
11:09:32 <oo_miguel> tell it (how) to do it with `par` right?
11:09:42 <cocreature> par or forkIO
11:09:47 <oo_miguel> ah right
11:09:50 <oo_miguel> ok thank you very much
11:10:50 <cocreature> oo_miguel: btw if you’re trying to learn parallelism in Haskell, simon marlow’s book is probably a better choice than rwh
11:11:39 * hackage fsnotify 0.2.1.2 - Cross platform library for file change notification.  http://hackage.haskell.org/package/fsnotify-0.2.1.2 (RomanCheplyaka)
11:14:19 <oo_miguel> cocreature: I am trying to learn haskell in generall but parallelism is also one of main main interests. I read lyah, upenn cis 194 and im just finishing rwh (i know its heavily outdated but i like it) so far.. I wanted to have a look at the NICTA couse as next.. but I will definitely have a look at the book you are recommending too, thanks
11:14:47 <cocreature> @where thebook
11:14:47 <lambdabot> I know nothing about thebook.
11:14:50 <cocreature> @where the book
11:15:02 <cocreature> hm I thought lambdabot had it stored
11:15:11 <albeit> Is there a shorter way of checking if something uses a specific constructor of a sum datatype, other than using a case?
11:15:35 <cocreature> oo_miguel: https://web.archive.org/web/20180117182938/http://chimera.labs.oreilly.com/books/1230000000929/index.html there you go
11:16:16 <oo_miguel> cocreature: great
11:20:39 * hackage unliftio-pool 0.2.0.0 - Data.Pool generalized to MonadUnliftIO.  http://hackage.haskell.org/package/unliftio-pool-0.2.0.0 (BardurArantsson)
11:51:09 * hackage lens-utils 1.4.4 - Collection of missing lens utilities.  http://hackage.haskell.org/package/lens-utils-1.4.4 (danilo2)
11:53:09 * hackage type-interpreter 0.1.4 - Interpreter for Template Haskell types  http://hackage.haskell.org/package/type-interpreter-0.1.4 (vapourismo)
12:04:35 <infandum> exa: Something like that, yeah
12:07:06 <[exa]> infandum: you'll need to put the side effect there somehow
12:09:47 <[exa]> infandum: my first try would probably be to transform f1/f2 to IO actions that can print the progress as a side effect, and run them like 'pure ls >>= f1 >>= f2'
12:10:56 <lyxia> albeit: if you have a prism, you could write "is _Constructor". Otherwise "case ... of Constructor{} -> ..." record syntax can be useful here.
12:16:25 <ph88> cocreature, i'm trying to cut the cycles in my grammar .. but it's difficult because there are just so many. I know that if i cut at "DiscreteRange" and "SimpleExpression" GHC compiles again successfully .. but then i still don't know exactly which cycle(s) cause the problem. Here is a list with all paths between those data types https://bpaste.net/show/b88ea8f112fd
12:18:32 <ph88> by the way i'm pretty sure it's because of the constraints i'm putting, for example:  instance (Rule f ShiftOperator) => Rule f ShiftExpression where
12:28:14 <isBEKaml> @where haskellbook
12:28:15 <lambdabot> http://haskellbook.com
12:28:20 <isBEKaml> Right, that one
12:32:00 <maerwald> how do people represent financial values?
12:32:31 <Welkin> I imagine a joke about business people
12:32:33 <Welkin> what values?
12:32:35 <Welkin> they don't have any
12:32:36 <Welkin> :D
12:33:21 <maerwald> I mean, numerically. In addition, you have the problem of currencies
12:33:55 <maerwald> and I suspect even Integer may not be very well suited
12:34:22 <Welkin> scientific?
12:34:30 <maerwald> no
12:34:37 <Welkin> it depends on what you want
12:35:00 <maerwald> I'm talking about financial industry
12:35:10 <Welkin> what does that even mean?
12:35:13 <Welkin> it could mean a million things
12:35:19 <maerwald> ok
12:35:26 <Welkin> are you dealing with 0.0000000001 dollars?
12:36:06 <AndreasK> I would expect most large institutions to have their own closed source things for that
12:36:57 <ixxie> floats for sure
12:37:00 <Welkin> very possibly using symbolic computations
12:37:13 <ixxie> otherwise you have a problem with conversions etc.
12:37:19 <Welkin> and storing everything in exact values
12:38:09 * hackage brick 0.36.2 - A declarative terminal user interface library  http://hackage.haskell.org/package/brick-0.36.2 (JonathanDaugherty)
12:41:11 <maerwald> Welkin: you mean they just write their own AST for numerical operations and never use stuff like Num?
12:42:03 <maerwald> examples?
12:42:23 <Welkin> I don't have any examples
12:42:28 <Welkin> I could ask my friend who works in HFT
12:42:43 <Welkin> I don't know any details, it's just a guess
12:47:53 <maerwald> @hackage safe-money
12:47:53 <lambdabot> http://hackage.haskell.org/package/safe-money
12:48:06 <maerwald> I wonder how professional that solution is
12:48:45 <Welkin> what do you mean by that?
12:49:00 <Welkin> if it works, then it works
12:50:58 <[exa]> maerwald: you might want to google up some cobol manual, they have a lot of knowledge about representing financial values
12:51:45 <Welkin> or you can search npm for a professional money library written by professionals
12:51:50 <maerwald> lol
12:51:53 <[exa]> but generally it's fixed-precision arithmetic on _very_ long integers and _very_ well specified rounding for each operation
12:51:55 <Welkin> professionally
12:51:56 <[exa]> Welkin: lol
12:52:25 <maerwald> maybe they represent it as a string and do string arithmetic on it
12:52:26 <isBEKaml> I think there may be something in hledger that you can use. You may find something since it deals with money/accounts
12:52:37 <maerwald> ah
12:52:40 <maerwald> sm: ping :P
12:52:41 <ixxie> [exa]: why long ints?
12:52:48 <ixxie> [exa]: why not floats?
12:53:05 <Welkin> floats suck for precision
12:53:18 <[exa]> ixxie: let's say you want add 0.001% interest each day
12:53:27 <[exa]> which translates to (*1.00001)
12:53:34 <[exa]> which floatputers view as (*1)
12:54:32 <[exa]> the rounding problem isn't very simple as well, there are gazillion rounding rules in each financial system, bitcoin's only been hitting the top so far
12:54:53 <Welkin> holy crap
12:54:55 <[exa]> so most math operators are basically ternary
12:55:04 <Welkin> maerwald: the author fo that library wrote a very long essay on it here https://ren.zone/articles/safe-money
12:55:23 <maerwald> nice
12:55:34 <DigitalKiwi> his resume looks super resume too
12:55:36 <ixxie> [exa]: I don't see why that should necessarily be the case though, it just depends on how the float rounding is handeled
12:55:55 <Welkin> DigitalKiwi: lol, he is using Edward Tufte's layout and styling
12:56:07 <DigitalKiwi> who dat
12:56:21 <[exa]> ixxie: in case of Float you don't have much choices tbh, except for reimplementing the float
12:56:42 <DigitalKiwi> well if we can't use float surely we can use double
12:57:09 <DigitalKiwi> it's twice as good amirite
12:57:32 <fishythefish> double your precision, double your fun
12:57:34 <[exa]> wow tufte wow
12:57:47 <ixxie> I guess I am asking why floats are not really rational numbers in the end, because I always thought of a float as an Int % 10**n
12:57:52 <Welkin> DigitalKiwi: you must have never used latex to write a paper o.o
12:57:56 <Welkin> otherwise you would know tufte
12:58:07 <DigitalKiwi> I have never used latex period
12:58:47 <Welkin> he https://www.edwardtufte.com/tufte/
12:59:06 <Welkin> he did a lot of work in the layout and communication of information
12:59:33 <Welkin> there are lots of latex templates for his layouts
13:00:34 <DigitalKiwi> well his website sucks
13:00:42 <Welkin> lol
13:00:48 <[exa]> +1
13:00:55 <[exa]> also the typesetting
13:00:56 <Welkin> he designs books/papers
13:00:58 <Welkin> not websites
13:01:20 <Welkin> plus, his website is fine
13:01:25 <Welkin> it is much better than most websites
13:01:25 <[exa]> but his pics/figures are insane-level good
13:02:10 <Welkin> haha wow
13:02:16 <Welkin> there is a musical score with a dance notation
13:02:19 <Welkin> didn't see that before
13:02:31 <maerwald> https://hackage.haskell.org/package/hledger-lib-1.5.1/docs/Hledger-Data-Types.html#t:Quantity
13:02:35 <maerwald> seems hledger uses Decimal
13:03:19 <Welkin> and it looks like Decimal is a wrapper for Integer
13:03:20 <Welkin> :P
13:04:40 <DigitalKiwi> is that a wrapper for bc?
13:07:35 <maerwald> so, how about this... use Decimal for representing the values and for representing an amount (in terms of currency) use a wrapper around decimal with a phantom symbol type, so you can force functions to only take currency amounts of the same type
13:07:56 <maerwald> similar to what the Path library does wrt Path Abs vs Path Rel
13:08:15 <Ariakenom> https://hackage.haskell.org/package/safe-money
13:08:25 <Ariakenom> Rational > Deciaml always though?
13:08:26 <maerwald> Ariakenom: I've already linked to that earlier
13:08:33 <DigitalKiwi> there's no bullet list like stalin's bullet list! haha
13:09:05 <Ariakenom> my bad
13:09:17 <Tuplanolla> Very bad.
13:09:40 <DigitalKiwi> Ariakenom gosh don't you pay attention to the conversation from 20 minutes ago
13:09:57 <[exa]> maerwald: currency conversions are _not_ lossless operations
13:10:05 <maerwald> [exa]: exactly
13:10:27 <maerwald> with a phantom symbol type you can statically enforce your program to not use different currencies in the same function
13:11:03 <[exa]> that could work if you lift currency symbols to types, yes
13:11:11 <maerwald> add :: Amount a -> Amount a -> Amount a
13:11:19 <maerwald> so whether a is USD or whatever doesn't matter
13:11:46 <maerwald> 'add' then simply operates on the underlying values
13:11:52 <Tuplanolla> Clearly you need to gather a free representation of the financial arithmetic you're about to do and then analyze it to see if it admits a lossless interpretation.
13:12:04 <maerwald> it's not really idiot proof, but better than having a Num instance imo
13:12:08 <Welkin> yeah!
13:12:15 <Welkin> programming the Dr. Dre way
13:12:18 <Welkin> like a phantom
13:12:29 <Welkin> call them Dre types
13:12:33 <Welkin> :D
13:12:40 <maerwald> can we be serious?
13:12:50 <Tuplanolla> I was somewhat serious.
13:12:56 <orbisvicis> how do I find my (system) version of data.map.lazy ?
13:12:59 <Tuplanolla> It's not a bad idea by any means.
13:13:15 <Welkin> orbisvicis: check your version of containers
13:13:27 <DigitalKiwi> https://www.edwardtufte.com/tufte/fineart wtf, 500 for the dog pictures? I've deleted worse pictures I took
13:13:29 <Welkin> ghc-pkg list
13:14:17 <DigitalKiwi> err, better, but you know what I mean
13:14:30 <orbisvicis> ok thanks
13:15:03 <AndreasK> Welkin: I used latex and tufte didn't ring a bell for me. But then I only ever picked whatever template and used that.
13:15:29 <AndreasK> Also I'm terrible with remembering names which surely didn't help either
13:17:59 <DigitalKiwi> who are you again?
13:18:20 <orbisvicis> how do I define a function not provided by older versions of a module (which uses the module version if available) ?
13:18:54 <Welkin> orbisvicis: just upgrade your package o.o
13:18:59 <glguy> You can use CPP or Template Haskell to detect the absense
13:19:04 <Welkin> you can use the CPP
13:20:05 <Tuplanolla> Does GHC have its own `cpp` or does it delegate to the system `cpp`?
13:23:35 <Welkin> I bet the ghc user's guide can answer that
13:25:53 <Tuplanolla> Are you sure?
13:28:02 <DigitalKiwi> no that's why it's a bet :P
13:28:11 <DigitalKiwi> Welkin how much are you wagering
13:28:22 <Welkin> nothing
13:28:26 <Welkin> because I am just guessing
13:28:39 * hackage composition-prelude 1.4.0.0 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.4.0.0 (vmchale)
13:28:44 <DigitalKiwi> you're no fun :(
13:29:39 * hackage composition-prelude 1.4.0.1 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.4.0.1 (vmchale)
13:34:46 <jle`> maerwald: there's a type-safe currency library that came out maybe half a year ago that seemed pretty nice
13:35:04 <jle`> maerwald: https://hackage.haskell.org/package/safe-money
13:35:26 <Welkin> hahahaha
13:35:27 <DigitalKiwi> laugh
13:35:32 <Welkin> I can't tell if jle is joking
13:35:44 <[exa]> :]
13:35:47 <jle`> https://ren.zone/articles/safe-money
13:35:57 <Tuplanolla> Probably not.
13:36:07 <jle`> oh sorry i didn't look back far enough in the scrollback, heh
13:36:58 <[exa]> jle`: don't worry it's pretty common today
13:37:40 <maerwald> maybe because half of the conversation was about latex and other weird stuff :P
13:46:31 <Ariakenom>  Has anyone heard of safe-money?
13:46:48 <chewzerita> Yes!  Saw it on HN recently
13:49:51 <DigitalKiwi> https://news.ycombinator.com/item?id=16593529
13:53:18 <infinisil> Yeah, I saw it a year or so ago, and just again on hackernews recently
13:53:37 <Welkin> and you saw it in here 4 times today
13:53:59 <infinisil> Hah
13:54:17 * Ariakenom tried to make joke
13:58:08 <pavonia> Is a Vector Word8 as space-efficient as a ByteString?
13:58:44 <Welkin> no
13:58:47 <Welkin> Vectors are boxed
13:58:57 <Welkin> Bytetrings are unboxed sequences afaik
13:59:24 <Guest92> what do u guys thin k of this https://news.ycombinator.com/item?id=16852788
13:59:37 <pavonia> Welkin: What about the unboxed variant of Vector?
14:00:56 <Welkin> https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html
14:01:18 <Welkin> ByteString uses packed Word8 unboxed arrays
14:04:00 <Welkin> I am not certain
14:04:13 <Welkin> but I expect ByteString to perform better than unboxed vectors of word8
14:06:07 <dukedave> Before I go down a rabbit hole, can someone confirm whether the `'S` and `'D` things here are to do with Template Haskell?
14:06:10 <dukedave> https://github.com/LumiGuide/haskell-opencv/blob/a3396ad74475eb16c78e9b3d3fc7b669c757f29c/opencv-examples/src/face-detect.hs#L52
14:06:10 <jle`> time to benchmark
14:06:27 <jle`> dukedave: ah yeah, not template haskell
14:06:29 <jle`> that's DataKinds
14:06:44 <dukedave> Ooh, okay, another thing I don't know about!
14:07:00 <jle`> dukedave: luckily, datakinds is much simpler than TH
14:07:10 <Welkin> Vector uses a lot of typeclasses
14:07:16 <Welkin> which could definitely slow it down
14:07:25 <jle`> dukedave: the type decalration `data Bool = False | True` declares the type Bool with value constructors False and True
14:07:46 <jle`> dukedave: it also declaraes a *kind* Bool with the *type* constructors 'False and 'True
14:07:47 <dukedave> jle`: oh, okay, that's good to hear! Is the ` (h ::: w ::: Z) (Proxy :: Proxy 3) (Proxy :: Proxy Word8) ` stuff on line 62 also datakinds?
14:08:07 <jle`> dukedave: the 3 is DataKinds
14:08:20 <jle`> the h ::: w ::: Z is just normal haskell values
14:08:24 <jle`> (:::) is a constructor
14:08:35 <jle`> so it's like (h : w : []), essentially
14:08:50 <pavonia> Welkin: Do type classes impact runtime performace too? I thought they are only slowing down the compilation process
14:08:51 <jle`> you just might not be used to constructors that are operators
14:09:17 <dukedave> jle`: probably the latter, I'm just coming back to Haskell after a long time away
14:09:18 <jle`> but you use them often -- like (:) for lists :)
14:09:48 <jle`> (::) is a type signature, so using (:::) is admittedly a little confusing
14:09:55 <jle`> *defining a constructor called (:::)
14:10:10 <Welkin> pavonia: it require a lookup for the methods in the dictionary
14:10:14 <dukedave> Hoogle doesn't like it either :\
14:10:27 <Welkin> but who knows how ghc optimizes
14:10:32 <Welkin> it could be doing anything to it
14:11:51 <jle`> dukedave: it might be a part of the opencv library itself
14:12:52 <ph88> how do only the type check pass ?
14:13:41 <dukedave> jle`:  ah, yep, found it! https://github.com/LumiGuide/haskell-opencv/blob/a3396ad74475eb16c78e9b3d3fc7b669c757f29c/opencv/src/OpenCV/TypeLevel.hs#L12
14:13:51 <dukedave> Thanks for the DataKinds tip, I'll go read up
14:14:00 <jle`> no problem :)
14:25:04 <ph88> i have code like     instance (Rule f A, Rule f B, Rule f C) => Rule f Z where   (many of those)   GHC really has a hard time with this, what can i do about it ?
14:25:25 <ph88> it's also circular those depending constraints
14:28:13 <pavonia> Hard time in what way?
14:31:10 <ph88> pavonia, takes a long time
14:31:42 <ph88> changes in those "constraint dependencies" or whatever they are called impact compile time significantly
14:31:57 <ph88> first i thought GHC was stuck but now i think i just didn't have the patience to wait for hours
14:33:21 <pavonia> Ah yes, type class inference really slows down compilation
14:33:24 <jle`> ph88: re: earlier, doing only typecheck pass, if it's a single file you can -fno-code, but for projects, -O0 seems to get similar times for me
14:33:47 <jle`> s/similar times/similar to no-code
14:34:12 <ph88> ok ok
14:34:31 <ph88> pavonia, do you know what i can do about it ?
14:34:45 <pavonia> No, sorry
14:35:29 <EvanR> the chapter on subtyping in TAPL says something interesting
14:35:32 <Welkin> ph88: don't use so many type classes
14:36:22 <ph88> Welkin, so many hours invested in this code .. it would be terrible to change it
14:36:24 <EvanR> essentially a particular feature being proposed would cause the behavior of a program to depend on which "derivation" (of well typedness) that the compiler decided to use
14:36:59 <EvanR> since the programmer only writes programs and not derivations, this would cause the language to be unpredictable and uncontrollable
14:37:10 <pavonia> Not sure if GHC caches inferred instances, so perhaps grouping common constraints into new ones helps?
14:37:27 <pavonia> If not it would make it even worse :p
14:37:28 <donjoe2> So I have to implement Dijkstra Shortest path on haskell. What should be my approach, coming form javascript language?
14:37:30 <ph88> pavonia, grouping ?
14:37:54 <EvanR> the particular feature isnt important, but this issue is presented as being bad. I read that and was like "ah but in dependent types we are asking the programmer to do derivations basically"
14:38:05 <EvanR> why the hell shouldnt they
14:38:06 <Welkin> donjoe2: that same way you do it in any language
14:38:23 <EvanR> answer, because its annoying. we want the compiler to do all the work for us
14:38:42 <donjoe2> welkin: does not look same to me. everything is immutable here. how would I keep track of what's visited or not, etc...?
14:39:10 <Welkin> donjoe2: make a new object with the updated information
14:39:13 <Welkin> simple
14:39:22 <Welkin> immutable vs mutavle makes zero difference here
14:39:33 <EvanR> mutacle
14:39:38 <pavonia> ph88: Like in your case if you use the same constraint several times, you could add a new class for the constraints (Rule f A, Rule f B, Rule f C) so that GHC hasn't to go down these three all the time again
14:40:10 <ph88> pavonia, each has their own unique set of constraints
14:40:11 <Welkin> in fact, there is zero difference in how you program it
14:40:50 <Welkin> just update the graph and the implemenation of the data structure takes care of the rest
14:41:31 <ph88> pavonia, each arrow that points to something, that something is a constraint https://imgur.com/a/nM6vsbw
14:41:36 * byorgey disagrees with Welkin, there is a difference in how you program it.
14:41:51 <byorgey> donjoe2: mutable variables can be translated into arguments to a recursive function
14:42:16 <byorgey> every time you would iterate a loop and change a variable, it turns into a recursive call with a new value for the parameter
14:42:47 <pavonia> ph88: Oh wow
14:43:01 <donjoe2> I see
14:43:12 <DigitalKiwi> ph88 don't fall trap to sunk (time) cost fallacy
14:43:23 <Welkin> mutable vs immutable and loop vs recursion is an implemenation detail
14:43:25 <donjoe2> And should I implement Graph for that? Or I can do without it just fine?
14:43:35 <ph88> DigitalKiwi, what trap ?
14:43:36 <Welkin> the algorithm is the same
14:43:39 <EvanR> so in the design of a safe language, you have to decide how much you can get away with being done by the compiler. in the extreme case, the user writes all derivations of well typedness
14:43:51 <byorgey> Welkin: at a sufficiently high level perhaps, but it is not helpful to say that to someone asking about it.
14:43:59 <EvanR> and we say this is bad. but look at the test driven development world
14:44:08 <EvanR> change code, all the tests break
14:44:21 <EvanR> and this is considered good
14:44:29 <Welkin> lol
14:44:40 <Welkin> TDD is completely stupid
14:44:46 <Welkin> how do you even know what code you are going to write?
14:44:48 <Welkin> you don't
14:44:55 <byorgey> Welkin: donjoe2 was obviously asking about implementation, so implementation details are important.  If the question was "how does Dijkstra's algorithm work", then I agree the distinction is not important at that point.
14:45:24 <Welkin> it bloats your codebase for no realized benefit whatsoever
14:45:44 <Welkin> in my experience, it make development at least 3x or even 10x slower
14:45:48 <donjoe2> byorgey's right
14:45:49 <EvanR> do you think replacing tests with arcane proofs would be better?
14:46:14 <Welkin> that is engineering
14:46:18 <Welkin> there are trade-offs
14:46:22 <Welkin> choose your poison
14:46:28 <Welkin> and the best balance in context
14:46:31 <byorgey> Welkin: your signal-to-noise ratio is getting dangerously low.
14:48:05 <DigitalKiwi> ph88 https://en.wikipedia.org/wiki/Escalation_of_commitment
14:48:19 <EvanR> i guess it would be better to replace tests with beautiful proofs
14:48:42 <Welkin> lol DigitalKiwi
14:48:44 <ph88> pavonia, i'm considering to put those instances in a separate module so that it doesn't have to be compiled. With -O2 it takes forever but with -O0 my code compiles in 35 seconds
14:49:49 <ph88> DigitalKiwi, ya ok
14:49:54 <Welkin> ph88: don't be afraid to throw away code
14:50:02 <Welkin> any good programmer throws away most of their code
14:50:13 <ph88> Welkin, i wouldn't even know how to write the code in a different way
14:50:17 <Welkin> otherwise it will never get better
14:50:52 <Welkin> do an experiment
14:51:06 <EvanR> i've reported measures of progress in meetings in "number lines deleted", usually not appreciated
14:51:33 <ystael> EvanR: we love big fat red minuses on PRs
14:51:46 <DigitalKiwi> just delete all of the code
14:52:20 <zachk> if it's deleted code or it was never written code, then that code is 100% guaranteed to have 0 bugs in it :)
14:52:44 <DigitalKiwi> speaking of, does anyone work at facebook or twitter I need you to do something...
14:52:44 <EvanR> oh good one, you can report "number of lines of code we didnt write and never will"
14:54:07 <EvanR> also, when reporting progress for haskell code, shouldnt we really report number of expressions or something, instead of lines
14:54:57 <abprof> expressions / line
14:54:59 <DigitalKiwi> I was just thinking if you base estimation of number of bugs based on lines of code, does that mean haskell has more bugs per lines of code or less bugs? :|
14:56:39 * hackage ghc-typelits-natnormalise 0.6 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  http://hackage.haskell.org/package/ghc-typelits-natnormalise-0.6 (ChristiaanBaaij)
15:00:23 <ph88> pavonia, i use this code to make the parser and the generator at the same time https://bpaste.net/show/80761f3aabde it's very convenient because they will stay exactly the same and i don't have to write it twice. But now that GHC is slow, i have to write twice ??
15:00:57 <EvanR> number of bugs per expression
15:01:28 <EvanR> the ones between expressions are tricky to count that way
15:02:52 <sssilver> I've just read that Haskell "first appeared" in ~1990, which is kinda weird coz the world already had C++ by that time
15:03:04 <sssilver> I thought Haskell was coming from like 70ies
15:03:26 <boj> why is that weird with regards to C++?
15:03:58 <EvanR> sssilver: did you see this one http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
15:04:38 <sssilver> EvanR: nah, thanks for linking!
15:05:03 <sssilver> boj: well the world already had a language that could do it all in almost any paradigm you please and with all the performance
15:05:03 <EvanR> i have yet to see a contemporary report of what these functional language people thought of C++
15:05:14 <ph88> does anyone know if i can get the same result (not having to write parser and generator code twice) like this https://bpaste.net/show/80761f3aabde using another technique? perhaps TH ?
15:05:19 <EvanR> i assume they werent impressed
15:05:26 <kudomarkos> Good Night Everybody
15:05:57 <boj> sssilver: clearly not everything, or FP language desingers wouldn't have bothered :)
15:05:58 <kudomarkos> I have a really big doubt about (\k .... ) to write a function
15:06:03 <pavonia> ph88: Did that slowdown happen in a newer GHC version?
15:06:18 <ph88> pavonia, yes it started when i updated LTS from 8.4 to 10.2
15:06:20 <EvanR> i saw the wadler one where he blasts lisp. i'd love to see someone take apart C++
15:06:43 <sssilver> EvanR: can you link that one? super interesting
15:06:48 <DigitalKiwi> what did he say about lisp
15:06:58 <kudomarkos> I try to made a function :: [(Integer,Integer)] -> (Integer -> Integer) Can someone help me, please
15:07:20 <EvanR> https://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf
15:07:44 <pavonia> ph88: Hhm, that's very unfortunate
15:08:34 <DigitalKiwi> how dare he pick on scheme guy steele is a national treasure
15:08:42 <EvanR> haha
15:09:31 <fishythefish> kudomarkos: let's call your function `mapToFun :: [(Integer, Integer)] -> Integer -> Integer`. What should `mapToFun m x` do?
15:10:35 <DigitalKiwi> where's the paper where he goes after https://en.wikipedia.org/wiki/Alice_(software)
15:10:59 <fishythefish> sssilver: your argument seems to apply not just to Haskell, but to any language which appeared after C++. Do you consider all such languages to be pointless as well?
15:11:36 <spruit11> sssilver: lookup Lisp, SASL, Miranda, Gopher, Haskell. That's about the lineage.
15:11:43 <EvanR> we are so lucky that C++ wasnt the last of the next 700 languages
15:11:54 <kudomarkos> fishythefish: if the list of the tuples was [(4,5),(12,8)] then mapToFun 4 will give 5
15:12:11 <fishythefish> kudomarkos: right, so what does `mapToFun m x` need to do?
15:12:11 <kudomarkos> and, mapToFun 12 will give 8
15:12:20 <DigitalKiwi> C++ wasn't even FP until 14 according to wikipedia
15:12:35 <hpc> fishythefish: ppsh, any language which appeared after lisp
15:12:35 <DigitalKiwi> err, sorry, C++11
15:12:43 <fishythefish> kudomarkos: also, what would `mapToFun [(4, 5), (12, 8)] 0` produce?
15:13:25 <aarvar> according to a cs teacher I had, "C++ is really powerful"
15:13:35 <EvanR> in the beginning, there was lisp and it was perfect. then it continually became replaced with a stready stream of worse languages :)
15:13:36 <sssilver> I look at it from the angle of "so much time was wasted creating these other programming languages instead of working on C++"
15:13:36 <fishythefish> hpc: tbh everything after the difference engine was overkill
15:13:59 <fishythefish> sssilver: what about the angle of "look how much time was saved by working in a language this isn't C++"
15:14:02 <fishythefish> that*
15:14:04 <aarvar> lol
15:14:15 <hpc> the analytical engine would have succeeded if babbage knew about kickstarter
15:14:23 <kudomarkos> I guess recursion, but i don't know, I try to write: mapToFun m x = (\k .... but i don't know how to pick with recursion all the list and make a RECURSION of "if .... then..... else ...."
15:14:30 <EvanR> and 3d printers
15:14:32 <aarvar> sssilver: go create a purely functional dependently typed version of C++ for us please
15:14:54 <aarvar> with garbage collection
15:14:57 <DigitalKiwi> we should all just use m-x butterflies
15:15:04 <kudomarkos> fishythefish: mapToFun only have 1 parameter. The list
15:15:10 <fishythefish> kudomarkos: you have two cases: write `mapToFun [] x` and `mapToFun [(y:ys)] x`
15:15:13 <hpc> does C++ support sharding?
15:15:14 <sssilver> why would you want garbage collection when you have RAII?
15:15:30 <kudomarkos> fishythefish: no. It is only one parameter
15:15:36 <fishythefish> kudomarkos: if we're nitpicking, all functions only have 1 parameter, but your type signature is `[(Integer, Integer)] -> Integer -> Integer`, so we can treat it as having two
15:15:47 <aarvar> sssilver: GC can be faster? Also, cyclical data structures
15:15:52 <Welkin> sssilver: except c++ is a disaster and is *not* performant at all if you use any of its features
15:15:53 <kudomarkos> No
15:16:07 <jamesbvaughan> Is there a way to access Xresources in Haskell? I'm pretty new here and couldn't find anything googling around or on hackage.
15:16:10 <Welkin> a relevant talk from cppcon https://www.youtube.com/watch?v=rX0ItVEVjHc
15:16:15 <kudomarkos> It is [(Integer,Integer)] -> (Integer -> Integer)
15:16:21 <fishythefish> kudomarkos: yes, that's the same thing
15:16:26 <kudomarkos> it returns a type function
15:16:29 <aarvar> sssilver: and as Welkin says, C++ is slow
15:16:29 <fishythefish> a -> b -> c is a -> (b -> c)
15:16:39 <Welkin> the good parts of c++ are just C
15:16:44 <hpc> :t undefined :: a -> (b -> c)
15:16:45 <lambdabot> a -> b -> c
15:16:46 <boj> jamesbvaughan: i don't think there is a specific library
15:16:57 <hpc> Welkin: the good parts of C are just algol
15:17:44 <Welkin> lol
15:18:04 <aarvar> what are the good parts of javascript?
15:18:14 <hpc> aarvar: the parts i can do in css instead
15:18:35 <Welkin> aarvar: the parts that come from scheme
15:18:47 <hpc> that too
15:18:47 <kudomarkos> fishythefish: i can't see it :(
15:19:05 <hpc> kudomarkos: it's how haskell works - functions are curried
15:19:07 <Welkin> javascript should have been lua
15:19:26 <DigitalKiwi> aarvar read the book to find out
15:19:32 <Welkin> or just scheme itself
15:19:52 <DigitalKiwi> Welkin for once I agree with you (wrt lua)
15:19:58 <kudomarkos> so...
15:20:14 <hpc> kudomarkos: if it helps, it's a design decision and not something you need to work out from everything else you know about programming
15:20:21 <fishythefish> kudomarkos: what's the type of (+)?
15:20:40 <fishythefish> (specializing to Integer if you want)
15:21:27 <aarvar> sssilver: the real question is why people continued to work on C++ after ML came out a year later or whatever
15:21:33 <kudomarkos> fingerzam: Integer->Integer->Integer
15:21:39 <kudomarkos> fishythefish:
15:21:48 <ph88> https://ghc.haskell.org/trac/ghc/wiki/Performance/Compiler#Derivinginstances
15:21:58 <fishythefish> kudomarkos: so I'm guessing you mean that it takes two Integers and produces an Integer
15:22:10 <fishythefish> but I claim that (+) has type Integer -> (Integer -> Integer)
15:22:12 <kudomarkos> yes
15:22:12 <spruit11> ML is way older than C++.
15:22:17 <fishythefish> :t ((+) (1 :: Integer))
15:22:18 <lambdabot> Integer -> Integer
15:22:20 <aarvar> sssilver: er, C, not C++
15:22:46 <fishythefish> kudomarkos: in fact, these are the same, since all functions are curried: (+) 1 2 is the same as ((+) 1) 2
15:23:06 <sssilver> ML is nice
15:23:08 <Welkin> lambda calculus is from the 1930's
15:23:12 <systemfault> Probably because they didn't want to wait an hour for their ML program to run... Computers were not that fast back then...
15:23:17 <sssilver> but ML is slow
15:23:19 <Welkin> and so is functional programming
15:23:30 <aarvar> or, why did Turing create the Turing machine when lambda calculus already existed?
15:23:31 <kudomarkos> yes, well... But how can it works for my list of integers?
15:23:35 <Welkin> arguably functional programming is the first kind of programming invented
15:23:47 <aarvar> sssilver: it is?
15:24:21 <spruit11> At least when C came out ML compilers were very slow.
15:24:22 <fishythefish> kudomarkos: so back to the original problem: you have two cases: `mapToFun [] x = ...` and `mapToFun ((k, v) : tl) x = ...`
15:24:48 <kudomarkos> ¿¿???
15:24:53 <kudomarkos> I don't have x
15:24:58 <kudomarkos> I ask for x
15:25:09 <fishythefish> kudomarkos: your function has type [(Integer, Integer)] -> Integer -> Integer
15:25:13 <spruit11> Roots in Lisp or even SECD. At least three orders slower.
15:25:19 <fishythefish> m is the [(Integer, Integer)] and x is the Integer input
15:26:04 <ph88> how can i specify that i want to compile all .hs files from a subdirectory in my cabal file ?
15:26:14 <fishythefish> kudomarkos: if you really want, you can instead write `mapToFun [] = \x -> ...` and `mapToFun ((k, v) : tl) = \x -> ...` but that's uglier IMO
15:26:29 <iqubic> Does haskell have any notion of existential qualifiers? Like "there exists"?
15:26:46 <Welkin> ph88: source-directories
15:26:48 <fishythefish> quantifiers*
15:27:10 <iqubic> I know it has forall, but that's universal quantification.
15:27:14 <fishythefish> iqubic: yes, but there isn't an `exists.` equivalent to `forall.`
15:27:30 <ph88> Welkin, you mean hs-source-dirs ?
15:27:57 <Welkin> ph88: yes
15:28:27 <iqubic> fishythefish: What do you mean? How do you do existential quantification in haskell?
15:28:28 <lemmih> ph88: You have to enumerate all the modules.
15:28:38 <Welkin> https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=hs%20source%20dirs#pkg-field-hs-source-dirs
15:28:54 <Welkin> iqubic: using rank-2 types
15:29:01 <Welkin> iqubic: nested foralls, basically
15:29:02 <EvanR> data A = forall a . A (B a)
15:29:09 <kudomarkos> uhm = (\x<-((k,v):tl),x==k,->v)
15:29:17 <kudomarkos> fishythefish: ??? that's right?
15:29:21 <fishythefish> iqubic: GADTs are a good way, but you can use higher-rank foralls
15:29:23 <EvanR> is the confusing shorthand
15:29:27 <Welkin> iqubic: look at ST for an example
15:29:29 <fishythefish> iqubic: historically, there's also stuff like http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ExistentialQuantification
15:29:37 <ph88> lemmih, manually ?
15:29:38 <iqubic> I see.
15:29:44 <fishythefish> kudomarkos: that's not valid syntax
15:29:54 <lemmih> ph88: Yep.
15:30:29 <kudomarkos> uhm = (\x<-[(k,v)| (k,v)<-((k,v):tl),x==k,->v)
15:30:37 <kudomarkos> uhm = (\x<-[(k,v)| (k,v)<-((k,v):tl),x==k],->v)
15:31:42 <kudomarkos> uhmf better? :(
15:31:58 <fishythefish> kudomarkos: I urge you to just write `mapToFun m x = ...` instead
15:32:08 <fishythefish> you seem to be mixing up lambdas, guards, and list comprehensions?
15:33:39 <kudomarkos> fishythefish: i only know to create functions with (\f ) notation very very basically
15:33:51 <kudomarkos> but not with a lot of ifs..
15:33:57 <fishythefish> kudomarkos: okay, so don't use lambdas if you're not comfortable with them
15:34:17 <iqubic> What is the notation being used in uhm?
15:34:37 <kudomarkos> lambda is a greek letter, what are u talking about? ( Sorry for my bad english )
15:34:52 <fishythefish> kudomarkos: a lambda is the \x -> ... syntax
15:35:18 <kudomarkos> My teacher ask me to do it. They are homework
15:35:36 <kudomarkos> but i dont have examples of that in my book
15:35:39 <iqubic> fishythefish: in uhm you have the first arrow going the other way. "\x <-". What is that syntax?
15:35:50 <EvanR> its crazy how many lambdas are conserved by having point free and sections
15:36:17 <fishythefish> kudomarkos: if you *must* use lambdas, writing `mapToFun m x = ...` is the same as writing `mapToFun m = \x -> ...`
15:36:31 <fishythefish> you're getting multiple syntactic features mixed up, so I urge you to write the former and then translate to the latter at the end
15:36:41 <iqubic> EvanR: What are sections?
15:36:42 <EvanR> i rarely use lambdas at this point
15:36:50 <EvanR> :t (+ 1)
15:36:51 <lambdabot> Num a => a -> a
15:36:55 <EvanR> :t (1 +)
15:36:56 <lambdabot> Num a => a -> a
15:38:02 <iqubic> How does that save lambdas?
15:38:04 <dpyro> in servant is there anyway to make a QueryParam mandatory such that it does not require a Maybe functor for the parameter and its rejected if all the mandatory params aren't provided to the server?
15:38:13 <iqubic> doesn't it just make a garbled mess?
15:38:19 <fishythefish> iqubic: because e.g. instead of writing \x -> 1 + x, you can write (1 +) instead
15:38:46 <iqubic> Yes, I get that.
15:38:49 <Welkin> it's sugar for a lambda
15:39:26 <EvanR> you saved it because you did not sacrifice one with your \ key, which splats it on your screen like an endangered butterfly
15:39:32 <dpyro> ^
15:39:41 <dpyro> \ makes me think of windows paths which makes me cry
15:41:06 <jle`> ph88: you can use hpack, which auto-detects modules for your cabal file
15:41:36 <ph88> ah ok
15:41:59 <kudomarkos> mapToFun m x = \x -> v<-m... i don't know how to continue.. you tell me I shouldn't be written list syntax into lambdas..
15:42:18 <jle`> ph88: but i think automatic detection might be an all-or-nothing thing
15:42:48 <EvanR> you mean mapToFun m = \x ->
15:43:16 <kudomarkos> EvanR: but fishythefish urged me ..
15:43:31 <kudomarkos> I am very lost
15:43:34 <EvanR> pointing out your extra x makes no sense
15:44:05 <kudomarkos> EvanR: it is an idea of fishythefish...
15:44:23 <kudomarkos> Could you tell me the advice in another way?
15:44:23 <maerwald> https://hackage.haskell.org/package/safe-money-0.6/docs/Money.html#t:Dense am I correct that you cannot retrieve the 'currency' at value level?
15:44:23 <fishythefish> kudomarkos: I urge you to write `mapToFun m x = ...` instead of `mapToFun m = \x -> ...`. You're writing `mapToFun m x = \x -> ...` which is completely different
15:45:01 <kudomarkos> uhm
15:45:39 * hackage yesod-media-simple 0.2.0.1 - Simple display of media types, served by yesod  http://hackage.haskell.org/package/yesod-media-simple-0.2.0.1 (MichaelSloan)
15:45:51 <EvanR> different yes, but completely? :)
15:45:53 <kudomarkos> mapToFun m x = \k -> v, (k,v)<-m
15:46:21 <kudomarkos> mapToFun m x = \k -> v, (k,v)<-m, k==x
15:46:23 <kudomarkos> now?
15:47:15 <zachk> is that supposed to be a do block kudomarkos ?
15:47:15 <kudomarkos> better?
15:47:17 <spruit11> Just show him.
15:47:26 <fishythefish> spruit11: it's an assignment
15:47:34 <dpyro> never mind for my issue, found Required!
15:47:37 <EvanR> maerwald: why not?
15:47:46 <spruit11> He'll do more assignments then.
15:48:11 <fishythefish> spruit11: it's an ethical issue; I'm not providing a solution for which he is getting academic credit
15:48:12 <maerwald> EvanR: how would you
15:48:25 <fishythefish> kudomarkos: that code doesn't compile, the syntax is garbled
15:48:32 <spruit11> Endlessly coaching someone until he sees the light is not teaching. Just show him so he can do the other excercises.
15:48:46 <fishythefish> kudomarkos: can you write the solution without lambdas? we can talk about how to convert to using lambdas afterward
15:49:02 <fishythefish> spruit11: I'm not his teacher
15:49:02 <Welkin> spruit11: it's called the socratic method, and it's the only way to help someone learn
15:49:06 <lemmih> spruit11: He should follow a tutorial. There would be no issue showing him solutions to tutorial exercises.
15:49:06 <kudomarkos> fishythefish: https://wiki.haskell.org/Anonymous_function <------------ lambda syntax
15:49:09 <Welkin> giving them the answer is not helpful
15:49:29 <EvanR> maerwald: oh you mean the Symbol not the number. uhm...
15:49:30 <fishythefish> kudomarkos: I know what a lambda is, I'm saying since you seem to be confused about them, it would be better to implement the solution without lambdas first
15:50:22 <Welkin> lambdas are more fundamental than any other form
15:50:24 <lemmih> spruit11: But getting credit for an assignment that someone else wrote for you is plagiarism.
15:50:27 <Welkin> every function is a lambda
15:50:38 <Welkin> so learning and using lambdas early is important
15:50:41 <kudomarkos> :( I am fustrated.
15:50:49 <maerwald> EvanR: there is: denseCurrency :: KnownSymbol currency => Dense currency -> Text
15:50:57 <EvanR> maerwald: try symbolVal ?
15:51:00 <maerwald> I wonder if that is what I want
15:51:08 <maerwald> then I would compare Text, hmm
15:51:10 <EvanR> KnownSymbol is what youll need
15:51:20 <fishythefish> kudomarkos: okay, so let's do it in pieces, without lambdas at first
15:51:22 <EvanR> :t symbolVal
15:51:24 <lambdabot> error: Variable not in scope: symbolVal
15:51:30 <fishythefish> kudomarkos: start with `mapToFun [] x = ...`
15:51:32 <kudomarkos> fishythefish: i gave you the link because I can't know more about the syntax but what i search on google. My book doesn't tell me
15:51:38 <EvanR> KnownSymbol n => proxy n -> String
15:52:03 <EvanR> you may have to choose the n using ScopedTypeVars
15:52:30 <EvanR> why this info is only in the type level :(
15:52:57 <jle`> EvanR: you never need ScopedTypeVariables
15:53:11 <jle`> it's always only a convenience thing
15:53:14 <EvanR> i beg your pardon
15:53:50 * EvanR adjusts monocle
15:54:30 <kudomarkos> fishythefish: mapToFun [] x = error "No tuples"
15:54:32 <shachaf> Is that true?
15:54:45 <shachaf> I think it's true but I've seen cases that have need pretty clever workarounds.
15:54:48 <fishythefish> kudomarkos: okay, good. Next, how about the case where the list is nonempty?
15:55:42 <jle`> unless you count AmbiguousTypeVariable situations
15:55:45 <jle`> it's a mechanical process
15:56:14 <EvanR> could have sworn that i could not get stuff to check when putting sigs in where clauses, unless i brought some type vars into scope
15:56:25 <jle`> hm, i think maybe now that a lot of API's are starting to rely on AmbiguousTypeVariables, the picture is more complicated
15:56:31 <kudomarkos> that's what i want to know!!! It could be 600000000 tuples or 500000 or 3 tuples, but i can't do IF..THEN..ELSE.. of all of them, and If I work with variables.. well you tell me it doesn't compile
15:56:40 <jle`> but the 'proxy n ->' situation can easily always be done mechanically without scoped type variables
15:56:48 <fishythefish> kudomarkos: the usual way to handle this is by recursion
15:56:55 <kudomarkos> NO
15:56:56 <EvanR> ok that much i can believe
15:57:11 <kudomarkos> That's what i told you eons ago
15:57:18 <fishythefish> if a list is nonempty, it must be the result of a cons, so we can match `mapToFun [(k, v) : kvs] x = ...`
15:57:49 <kudomarkos> fishythefish: ok, good night. Thanks a lot.
15:58:01 <Welkin> wtf just happened?
15:58:43 <lemmih> No good deed goes unpunished, I guess.
15:59:01 <fishythefish> oh well
15:59:03 <fishythefish> on to the next one
15:59:09 * hackage minio-hs 1.0.0 - A Minio Haskell Library for Amazon S3 compatible cloudstorage.  http://hackage.haskell.org/package/minio-hs-1.0.0 (MinioDevTeam)
15:59:30 <EvanR> over 9000 tuples
15:59:40 <spruit11> Yah well. I used to be a teacher and I tell you to just show the solution. Students can then figure out why it works themselves and move on.
15:59:58 <spruit11> Now you just managed to frustrate someone.
16:00:41 <MarcelineVQ> If learning doesn't cause frustration you're not learning, you're just memorizing.
16:00:42 <fishythefish> spruit11: look, if it doesn't violate your ethical boundaries to give him the solution, I can't stop you
16:01:17 <fishythefish> but if you're gonna play the "I'm a teacher" card, help teach instead of heckling from the backseat
16:01:30 <spruit11> I don't know enough Haskell.
16:01:30 <hpc> we're careful to avoid giving homework answers because a number of people here teach haskell specifically
16:01:40 <EvanR> even better, give them the wrong solution, then they learn doubly
16:01:49 <hpc> i remember once someone joined and accidentally met their teacher here
16:02:01 <Welkin> people also try to get us to do their homework for them
16:02:04 <Welkin> that's not okay
16:02:05 <hpc> (fortunately not about homework for that guy's class)
16:02:07 <Welkin> and a waste of our time
16:02:08 <fishythefish> hpc: was it yorgey's course or something else?
16:02:16 <EvanR> thats what were talking about actually, i think
16:02:34 <hpc> i forget whose it was, but it was either the guy was reading ahead or was curious about something else
16:09:04 <gazanga> me again with graham hutton book. in this code graham implement putStr http://lpaste.net/365196 of course i have to not understand something so i come always here :-). what i dont understand is what happend at the base case when the recursion stops. for example if i do putstr "1", at first it putChar 1 and continue to putstr with xs which is [], so now the recursion ends with empty string which get back-- return ()
16:09:05 <gazanga> which is IO () type. so back to the outer function after we putChar 1, we get back from putstr xs the IO () and nothing happens. it is just exit and we have our string on the screen. in the unpure code it always did something with the base case. for example in fold, it + 0 the base case or it got back the empty list which now back to the start filled with elements. here it seems to left alone and do nothing.
16:10:10 <fishythefish> gazanga: that's because in the pure case, you're building up a value ex nihilo, so you need to e.g. have a starting value of 0 to compute the sum
16:10:31 <fishythefish> in the IO case, you already have a running terminal, so all you need to do is append to it in the recursive case or do nothing in the base case
16:10:54 <jle`> gazanga: note that the recursion doesn't actually print any strings
16:11:04 <jle`> gazanga: what you are defining is essentially:
16:11:29 <jle`> putStr ['h','i'] = putChar 'h' >> putChar 'i' >> return ()
16:11:36 <jle`> you are defining a new IO action
16:11:39 <jle`> you are not performing any IO
16:11:56 <jle`> your putStr function defines a new IO action that consists of putting each character consecutively
16:12:07 <jle`> the base case is just that putStr [] is the no-op IO action
16:12:16 <fishythefish> ^ and from this point of view, "return ()" is the same as 0 in the sum and ">>" is like +
16:12:22 <jle`> gazanga: this *is* pure code
16:12:31 <jle`> putStr is a pure function
16:12:50 <fishythefish> the IO type allows us to manipulate "real-world actions" as pure values, which is very powerful
16:13:25 <Welkin> pure doesn't mean no effects
16:13:31 <Welkin> it means controlled and known effects
16:13:39 <fishythefish> your code isn't doing anything impure like writing output to the terminal; the Haskell runtime does that when it evaluates the result of your code
16:14:35 <kudomarkos> manTofun ((x,y),xs) = /k if x==k then ->v else manTofun xs
16:14:53 <spruit11> Almost.
16:15:10 <kudomarkos> <Welkin> people also try to get us to do their homework for them
16:15:15 <kudomarkos> that's wrong Wel
16:15:41 <fishythefish> kudomarkos: close, but there are a few mistakes: you want ((x, y) : xs) because it's a cons, not a tuple
16:15:50 <fishythefish> the lambda syntax is \k -> if ...
16:15:54 <jle`> it is true that some times people come here to get us to do their homework for them
16:16:07 <jle`> but nobody is saying that that is what *you* are doing
16:16:07 <fishythefish> and correspondingly there should be no `->` before the v
16:16:21 <EvanR> pure functions dont cause side effects or depend on the context you use them in
16:16:31 <fishythefish> [15:34:56]  <kudomarkos>	My teacher ask me to do it. They are homework
16:16:50 <gazanga> i don't understand those lines:
16:16:51 <gazanga> 02:11 <jle`> you are defining a new IO action
16:16:51 <gazanga> 02:11 <jle`> you are not performing any IO
16:16:54 <EvanR> which is hard to explain because... thats just "a function" as defined in maths
16:17:08 <gazanga> but i am writing to the screen
16:17:10 <fishythefish> gazanga: to use a cooking analogy, an IO value is a recipe, not the action of doing the cooking
16:17:12 <gazanga> im outputing
16:17:13 <jle`> gazanga: you aren't writing to the screen
16:17:14 <EvanR> i dont have a definition for pure not-functions yet
16:17:19 <fishythefish> you are not writing to the screen, the Haskell runtime is when it executes your code
16:17:19 <jle`> gazanga: you are returning a new IO action
16:17:32 <fishythefish> EvanR: constants? :P
16:17:39 <kudomarkos> fishythefish: yeah, but my teacher doesn't teach me about recursion in lambdas. AND, the [(Integer,Integer)]-> (Integer,Integer)
16:17:52 <kudomarkos> is a SIMPLEST exercise I wrote here
16:17:57 <jle`> gazanga: putStr is a function that takes a string and returns an IO action
16:17:57 <fishythefish> kudomarkos: recursion in lambdas works the same way as recursion without lambdas
16:18:04 <jle`> gazanga: purely
16:18:04 <fishythefish> this is why i'm trying to get you to not use lambdas at first
16:18:04 <kudomarkos> the real Homework is about pieces of chess
16:18:07 <fishythefish> and we can add them in later
16:18:15 <jle`> gazanga: putStr itself does not do any IO, it just *defines* an IO action
16:18:24 <spruit11> nqueens?
16:18:34 <fishythefish> kudomarkos: and the type is not [(Integer,Integer)]-> (Integer,Integer); it's [(Integer,Integer)]-> Integer -> Integer
16:18:35 <Welkin> kudomarkos: it sure sounds like you want us to do your homework for you, particularly now
16:18:51 <Welkin> go calm down and come back later when you have a clear head
16:18:55 <gazanga> jle`: can you explain what is "purley"?
16:18:56 <kudomarkos> fishythefish: but if i don't know lambda syntax, and when i Google it It is very poor.. what can i do? I am not lazy, and you really fustrate me
16:19:07 <fishythefish> kudomarkos: because we can teach you how to use lambdas
16:19:13 <fishythefish> the problem is you don't know how to solve the function without lambdas
16:19:15 <gazanga> in this example of course
16:19:17 <fishythefish> and that's the first priority
16:19:21 <jle`> gazanga: it takes a string and returns an IO action
16:19:25 <jle`> gazanga: it's the same Io action every time
16:19:47 <jle`> gazanga: it's a pure function in that putStr mystring returns the same IO action every time, and it computs that IO action without doing any side effects
16:21:03 <gazanga> and who is doing the action at the end if all i return ia a action but not command it to do the action?
16:21:04 <kudomarkos> I don't know is something I already know
16:21:11 <gazanga> ia = is
16:21:28 <fishythefish> gazanga: the Haskell runtime when you execute your code
16:21:34 <shachaf> Why can proxy n -> always be done mechanically?
16:21:58 <glittershark> gazanga: the "main" function
16:21:58 <shachaf> Hmm, I should think up one of the examples where it's tricky.
16:22:14 <fishythefish> gazanga: you're just typing up a recipe; the runtime is the chef
16:22:16 <jle`> shachaf: if the 'n' comes from the top-level type signature then you can make a recursive binding using the value itself
16:22:20 <gazanga> i dont understand why it is so strange. why i'm not executing it and i need to tell haskell that i just return to you IO () and you will do the rest. why is this so starnge?
16:22:33 <jle`> gazanga: what do you mean by strange?
16:22:49 <jle`> gazanga: you are defining an IO action
16:22:55 <jle`> the same way you'd, say, define a number
16:23:01 <jle`> sum [1,2,3] = 1 + 2 + 3
16:23:02 <EvanR> its tough to show how C is not exactly like this
16:23:11 <gazanga> in c langauge i just printf something. i'm not telling the runtime that you will print something later. i just do it.
16:23:24 <EvanR> but you are...
16:23:29 <Welkin> gazanga: in C, every single function is in IO
16:23:34 <jle`> gazanga: in haskell we don't directly do IO, we just describe IO
16:23:35 <glittershark> gazanga: lazy evaluation :)
16:23:39 <Welkin> everything is IO something
16:23:44 <jle`> gazanga: that's one reason why haskell is different than c
16:23:47 <EvanR> when you type printf, it doesnt print anything. you have to compile and run the program
16:23:53 <EvanR> which is you feeding it to the runtime
16:24:00 <jle`> gazanga: are you asking why the design decision was made to make things like this?
16:24:09 <gazanga> yes!
16:24:18 <gazanga> it is strange :)
16:24:19 <spruit11> I think that would be the better answer too.
16:24:24 <Welkin> referential transparency
16:24:31 <Welkin> so you can encode the effects in the type system
16:24:31 <EvanR> what C doesnt have are suspended actions that have the meaning of delay
16:24:36 <Welkin> and have easy control over them
16:24:40 <glittershark> well first off imagine a function that prints "hello" to the screen
16:24:48 <glittershark> sayHello = putStrLn "hello"
16:24:55 <glittershark> that function is of type IO ()
16:25:01 <EvanR> that is not a function >:(
16:25:12 <glittershark> well it's a CAF but whatevs
16:25:34 <Welkin> sayHello _ = putStrLn "I'm a function"
16:25:35 <Welkin> :D
16:25:38 <glittershark> I'm trying to approach this from a C programmer perspective
16:25:40 <spruit11> Not only, Haskell used to have streaming IO, from input stream to output stream. But that was very clumsy. The IO monad solved it better.
16:25:41 <EvanR> i feel like thats a core difference
16:25:56 <Welkin> haskell is not c
16:26:00 <glittershark> the point is, Haskell has a guarantee that whenever you call a function with the same arguments you get the same result
16:26:00 <jle`> gazanga: the benefit is that you can treat and manipulate IO as a first-class value
16:26:09 <jle`> gazanga: in C, you can't "store" a print command and pass it to a function
16:26:28 <jle`> gazanga: and you can't store print statements in a list, and re-combine many statements in different order, manipulate them purely, etc.
16:26:30 <Welkin> jle`: function pointers :D
16:26:41 <gazanga> do you have example for a c and haskell situation when it is fruifull to use haskell over c?
16:26:42 <EvanR> you can pass in a pointer to a nullary function
16:26:56 <gazanga> *fruitfull
16:26:58 <EvanR> in C. that would be the same thing
16:26:58 <jle`> yes, it's possible with some trickery
16:27:01 <Welkin> gazanga: the 2 languages are completely different and for different use cases
16:27:01 <glittershark> yeah I'm trying to compare this to the OCaml idiom of defining functions of type () -> () for 0-arity side-effecting functions
16:27:06 <Welkin> comparing them is absolutely pointless
16:27:07 <jle`> gazanga: in a big picture, or just reguards to IO?
16:27:08 <glittershark> since Ocaml isn't pure or lazy
16:27:20 <Welkin> that is like asking to compare a sandwich with a hammer
16:27:24 <jle`> gazanga: for me, haskell is about its strong type system guartuneeing safety/correctness, and also maintainability
16:27:47 <jle`> gazanga: if i were to work on a complex C program and then step away from it for a few months, and then come back to try to refactor it in a non-trivial way
16:27:54 <jle`> gazanga: this would be impossible to me, or at least a LOT of hard work
16:27:55 <gazanga> not in the big picture. i need to see a real example how in haskell it is different and how it is usefull over c?
16:27:57 <EvanR> who invented the idea of a -> doing stuff when you eval it :)
16:28:02 <Welkin> all of the cliche reasons to use language X over language Y are bullshit anyway
16:28:08 <Welkin> every single language claims to have the same benefits
16:28:12 <jle`> gazanga: it would take me a week maybe to even figure out the structure of the program
16:28:17 <jle`> before i can start doing any real work
16:28:24 <Welkin> "maintainability, fewer bugs, faster development, blah blah blah"
16:28:26 <glittershark> EvanR: what is "eval" :P
16:28:27 <mathZ> Haskell is good but which real app(s) are developed using haskell ?
16:28:35 <glittershark> mathZ: I use Haskell at work
16:28:37 <jle`> gazanga: for haskell, jumping back into a complex project after months is really easy, becase the type system helps you
16:28:49 <jle`> mathZ: does facebook count as an app?
16:28:49 <EvanR> glittershark: evaluate, like sin(3) = 0.14112
16:29:07 <edwardk> mathZ: pandoc, the language i work on at work for smart contracts, all of the spam fighting at facebook, there are a few things =)
16:29:07 <Welkin> if you need someone to convince you to use haskell, then don't use it
16:29:08 <mathZ> I just know xmonad
16:29:10 <Welkin> because you don't get it
16:29:18 <Welkin> you don't choose a language based on spec sheet comparisons
16:29:22 <jle`> mathZ: http://facebook.com
16:29:26 <glittershark> EvanR: I'm joking, but: sin(3) = new Thunk(() => doCalculations())
16:29:30 <mathZ> Great
16:29:31 <Welkin> you are choosing the ecosystem, the community, the syntax, the tools, everything
16:29:35 <gazanga> jle`: for example how is this usefull over C?
16:29:35 <jle`> glittershark: you're confusing the implementation with the denotation
16:29:36 <gazanga> 25 <jle`> gazanga: in C, you can't "store" a print command and pass it to a function
16:29:47 <EvanR> glittershark: oh i thought you were gazanga
16:29:47 <glittershark> I'm being facetious
16:29:55 <EvanR> youre confusing me with jokes
16:29:59 <glittershark> haha
16:30:00 <Welkin> I like haskell because it feels right and is fun to use
16:30:02 <gazanga> EvanR: different person :)
16:30:11 <jle`> gazanga: i wrot ea blog post on the benefits of IO actions as first-class valuesa  few years back
16:30:13 <jle`> gazanga: https://blog.jle.im/entry/first-class-statements.html
16:30:15 <Welkin> there are obvious technical benefits, but those don't matter
16:30:22 <Welkin> it's why tons of people still use ruby or javascript
16:30:27 <Welkin> even though the languages are crap
16:30:37 <glittershark> aww ruby is fun
16:30:39 <Welkin> and not to mention, c++
16:30:44 <Welkin> which is the king of crap possibly
16:30:44 <glittershark> smalltalk 4 dayz
16:30:56 <jle`> Welkin: what do you think the 'c' stands for
16:31:15 <EvanR> no language bashing
16:31:27 <glittershark> yeah be nice
16:31:33 <EvanR> unless its wadler 1987
16:31:34 <fishythefish>  jle`: ++b
16:31:41 <EvanR> doing it
16:31:50 <jle`> fair :)
16:31:51 <mathZ> seems you donot mention python which is used in many AI projects ?
16:31:52 <edwardk> i write haskell because its the best vehicle for large scale code reuse I have today, and has comparatively few massive blindspots in terms of the thoughts i can think in the language
16:32:05 <gazanga> i thank you all again. you are very nice and patient people and explain to me like i'm 5 and this is great. thank you very much!
16:32:06 <fishythefish> c++ has sequence points just so they can justify having (++b)++ as a language
16:32:11 <edwardk> mathZ: tensorflow is used in many AI projects. python is used as glue on top of it
16:32:12 <Welkin> mathZ: ruby, python, js, whatever, they are all about the same
16:32:31 <mathZ> yeah
16:32:42 <gazanga> jle`: i'll read it :)
16:32:44 <EvanR> 3 different inheritance mechanisms :)
16:32:56 <mathZ> Can haskell be used in AI ?
16:33:03 <EvanR> inheritance roulette
16:33:27 <Welkin> any programming language can be used for AI
16:33:28 <jle`> mathZ: as a language, there isn't anything stopping it in particular, and i think there are actually benefits in the languag edesign for AI.  however, the ecosystem is definitely not there yet
16:33:30 <Welkin> it's all just code
16:33:47 <jle`> Welkin: some languages can get in the way, or help make things easier
16:33:48 <Welkin> lisp is historically the AI language
16:33:51 <mathZ> jle`: i see
16:33:58 <Welkin> also, ML is not AI
16:34:09 <glittershark> haskell has a *ton* of potential for AI imo, with stuff like accellerate and linear etc.
16:34:12 <Welkin> it is statistics
16:34:13 <jle`> mathZ: the practical answer is, you probably can't do cutting edge AI in Haskell today, but mostly because of ecosystem reasons, not language reasons
16:34:14 <glittershark> just needs a killer app
16:34:31 <glittershark> probably like 5-10 years off but
16:34:33 <glittershark> I have my hopes up :)
16:34:35 <EvanR> AI, damn AI and statistics
16:34:36 <mathZ> yeah
16:34:39 <edwardk> mathz: yes. fun fact: i turned down a solicited offer to write a book on programming neural networks in haskell about 5 years ago. backpropagation is done through automatic differentiation. i have a nice library for that in haskell. deep learning is just a slightly more creative use of backpropagation
16:34:48 <kudomarkos> manTofun ((x,y),xs) = \k -> if x==k then \k->v else manTofun xs
16:34:58 <glittershark> oh edwardk I forgot who you were for a sec
16:35:07 <kudomarkos> can i return in the if an (\k->v)
16:35:07 <mathZ> edwardk: Great
16:35:08 <DigitalKiwi> I thought ML was just the name they started using to get away from the problems with the AI winter
16:35:08 <glittershark> I was like "wait didn't ekmett write ad... OH"
16:35:12 <Welkin> glittershark: you thought he was edward scissorhands?
16:35:21 <kudomarkos> or without the \
16:35:25 <glittershark> idk maybe there's another edward k :P
16:35:34 <jle`> there's an ed k
16:35:43 <jle`> who used to be on this channel pretty often
16:36:46 <jle`> Ed Kellett
16:36:57 <EvanR> how confusing
16:37:00 <Welkin> there is http://www.datahaskell.org/
16:37:01 <glittershark> that's a nameclash if I've ever heard one
16:37:05 <jle`> that might be why he left :(
16:37:09 <DigitalKiwi> ed...ward
16:37:11 <glittershark> aww that's a bummer
16:37:24 <glittershark> if haskell can fit two simons we can fit two ed k's
16:38:06 <DigitalKiwi> why are there so many aquatic species here
16:38:12 <DigitalKiwi> you're making the bird nervous
16:38:14 <fishythefish> kudomarkos: it's just `then v`
16:38:22 <edwardk> jle`: yeah it was maximally confusing
16:38:25 <Welkin> DigitalKiwi: the birds outside won't stop chirping
16:38:38 <EvanR> there can be only one
16:38:46 <DigitalKiwi> and it's like 5 in the morning and you're trying to go to sleep I hate that
16:38:47 <EvanR> cue queen
16:38:53 <edwardk> the only way it could have been worse if the Edward A. Kmett lawyer from california started popping up around here.
16:39:02 <Welkin> there are tensorflow bindings for haskell too
16:39:12 <edwardk> Then you'd have to distinguish us by length of hair
16:39:22 <Welkin> and https://github.com/HuwCampbell/grenade
16:39:24 <jle`> or by your accents
16:39:36 <Welkin> so there is quite a bit of activity in ML/Deep Learning in haskell
16:40:03 <jle`> you 'can do' AI in haskell, and I do it.  but there are limitations without further breakthroughs in the ecosystem
16:40:13 <Welkin> edwardk: I always wondered how to pronounce your last name
16:40:19 <Welkin> is the K silent or voiced?
16:40:23 <jle`> i say it like comet
16:40:38 <Welkin> like kermit?
16:40:43 <edwardk> i have some stuff i was playing around with for using GANs trained earlier by tensorflow on a GPU, but i never did get around to packaging up
16:40:45 <Welkin> ...the frog
16:40:46 <DigitalKiwi> Many researchers in AI in the mid 2000s deliberately called their work by other names, such as informatics, machine learning, analytics, knowledge-based systems, business rules management, cognitive systems, intelligent systems, intelligent agents or computational intelligence, to indicate that their work emphasizes particular tools or is directed at a particular sub-problem.
16:40:56 <edwardk> like kermit minus the 'r' sound
16:41:13 <edwardk> its not easy being green
16:41:20 <glittershark> edwardk: in case you need an extra push, I'd probably be interested in that :)
16:41:20 <hpc> it's not easy being geen?
16:41:24 <fishythefish> edwardk: you should pass the bar and invade his channel instead
16:41:28 <fishythefish> study adjunction law
16:41:29 <jle`> edwardk: is the 'e' still rhotic then?
16:41:32 <fishythefish> request kan-extensions on cases
16:41:35 <DigitalKiwi> edwardk it's funny because your name is green
16:41:48 <fishythefish> fight for continuance-passing style
16:42:08 <jle`> fishythefish: "your client broke the monad laws"
16:42:08 <DigitalKiwi> and my name is red and I'm fricken pissed about it because it's not even a nice red :|
16:42:09 <johnw> yeah, edwardk is bright green here too :)
16:42:16 <CodeKiwi> hmm
16:42:19 <johnw> DigitalKiwi is puce here
16:42:20 <CodeKiwi> I'M GREEN
16:42:25 <edwardk> glittershark: its really not in a reusable form at the moment. mostly been playing with it to mock up GANs for a bunch of graphics stuff, then try to substitute them in for things i can't run fast enough
16:42:33 <fishythefish> jle`: not a bad writing prompt
16:42:46 <fishythefish> jle`: it's like when people imagine the guy who actually monitors /etc/sudoers shows up
16:42:58 <jle`> i think cartesian closed comics did something like that once
16:43:30 <jle`> https://ro-che.info/ccc/5
16:43:36 <glittershark> edwardk: ah yeah that's fine, I can't exactly justify asking you for *more* contribution to the haskell open source ecosystem :P
16:43:52 <hpc> be good and type in your passwords correctly, or sudo-santa will change all your line endings
16:43:58 <edwardk> glittershark: it helps to know someone is interested in it, though.
16:44:17 <glittershark> :)
16:45:05 <glittershark> my company has a python-focused data science team and a Haskell engineering team, and are interested in figuring out how to bridge that gap
16:45:52 <edwardk> hpc: i read that as sudo-sempai, and it got all sorts of weird
16:46:16 <fishythefish> confirmed weeb \o/
16:46:23 <Welkin> glittershark: with ihaskell notebooks
16:46:58 <jle`> glittershark: are you on https://gitter.im/dataHaskell/Lobby ?
16:47:45 <hpc> edwardk: i had a great joke ready, but shockingly there's no command or package named "notice" ;)
16:48:01 <glittershark> Welkin: we've got those :) datasci is playing around with them and seem to be having fun
16:48:09 <edwardk>  /NOTICE me sempai
16:48:18 <glittershark> jle`: I am now
16:48:27 <Squarism> glittershark, Seen tweag.io ? They have some ipython haskell bridge
16:48:44 <CodeKiwi> edwardk get out :|
16:49:17 <Welkin> what is gitter.im?
16:49:21 <glittershark> ooh Squarism looking into this now, thanks
16:49:29 <Welkin> yet another closed irc clone?
16:49:31 <Welkin> like slack?
16:49:43 <CodeKiwi> yeah
16:49:47 <edwardk> Welkin yeah its basically a git-flavored irc clone.
16:49:50 <Welkin> great, no reason to ever use it
16:49:50 <edwardk> er github
16:50:05 <CodeKiwi> I don't even like github
16:50:06 <edwardk> I lurk in https://gitter.im/haskell-pair-programming/Lobby to set up pair-programming sessions.
16:50:21 <EvanR> i'm starting an effort to move this channel to AOL instant messenger, anybody with me?
16:50:23 <edwardk> but thats about all i use it for. (i have irccloud set up to talk to it, so i never actually leave IRC)
16:50:23 <Welkin> CodeKiwi: don't even use git
16:50:37 <Welkin> what about mercurial?
16:50:43 <Welkin> or fossil?
16:50:46 <Welkin> or darcs?
16:50:49 <EvanR> or darcs
16:50:50 <EvanR> ^
16:51:14 <CodeKiwi> I'm not even good at using git these days, I have stuff on bitbucket and now gitlab
16:51:26 <Welkin> no one really understands git
16:51:28 <edwardk> Welkin: i moved to github and saw about a 7000% increase in the number of patches sent my way. not in a hurry to return to the dark ages =)
16:51:29 <Welkin> except linus
16:51:37 <glittershark> git is just hipster blockchain
16:51:56 <hpc> the way most people use it, git is just svn with crappy verbs
16:51:56 <glittershark> > blockchain before it was cool
16:51:56 <Welkin> I think you can use mercurial on github
16:51:58 <lambdabot>  error:
16:51:58 <lambdabot>      Variable not in scope: blockchain :: t0 -> t1 -> t2 -> t3 -> terror: Var...
16:51:58 <lambdabot>      • Variable not in scope: it
16:52:04 <Welkin> hpc: that is the way I use it
16:52:05 <glittershark> oh shush
16:52:10 <jle`> edwardk: thanks for letting me know about irc.gitter.im
16:52:15 <Welkin> except you have religious wars like "rebase" or "merge"
16:52:22 <Welkin> rebase is bad, m'kay
16:52:25 <envjjjjj> good lambdabot
16:52:25 <hpc> (svn has a lot of issues, but fantastic cli verbs)
16:52:40 <EvanR> https://git-man-page-generator.lokaltog.net/
16:52:45 <Welkin> Jon Blow said that git can't handle binary blobs very well, which is one reason he uses svn
16:52:54 <hpc> rebase: for when you want version control without controlling your versions
16:53:24 <Welkin> he also works with repos that are 85 GB
16:53:56 <hpc> binary blobs should go in something that specializes in documents
16:53:58 <CodeKiwi> https://medium.freecodecamp.org/so-yeah-we-tried-slack-and-we-deeply-regretted-it-391bcc714c81
16:54:01 <Zipheir> hpc: You said it.
16:54:14 <hpc> (ones that work like source control are rare, but exist)
16:54:14 <ctvrty> mfw
16:54:28 <ctvrty> i swear that was unrelated edwardk, wasn't calling you a weeb :p
16:56:39 <edwardk> ctvrty: i used to run an anime import/export business. i probably qualify if anybody does ;)
16:57:08 <glittershark> TIL edwardk is a weeb
16:57:30 <EvanR> where do i go to understand how the heck Show's precedence-aware-choice-of-putting-parens-or-not works
16:57:49 <glittershark> showsPrec?
16:57:50 <CodeKiwi> EvanR f off we're talking about anime
16:57:52 <edwardk> that said, i have probably reduced to a 1-anime-a-year diet, so i doubt i qualify any more
16:58:00 <edwardk> EvanR: look at the Text.Show haddocks
16:58:30 <Welkin> edwardk: but can that anime be 1000 episodes long?
16:58:41 <hpc> that's pushing it even for anime
16:58:51 <ooo_miguel> can i use the type from the signature somehow? as: writeFile "test" (show (mempty::a))
16:58:54 <ctvrty> lmao
16:59:08 <edwardk> Welkin: not into one piece or naruto =P
16:59:11 <glittershark> ooo_miguel: ScopedTypeVariables and an explicit `forall`, then yes
16:59:41 <ooo_miguel> glittershark: thanks!
16:59:49 <glittershark> yw :)
17:00:38 <edwardk> i probably have read a rather absurd number of manga, and wuxia/xianxia light novels and the like that readily exceed that number of issues, though.
17:00:45 * edwardk realizes he isn't helping his case.
17:00:53 <glittershark> yeah was gonna say
17:01:04 <glittershark> even at 1 anime/year you still definitely qualify
17:01:39 <ph88> is there a ghc options to stop compiling when there was an error found in a module ?
17:01:49 <glittershark> non sequitir: is there some sort of canonical way to demote types in a promoted data-kind back to their respective term?
17:02:02 <hpc> ghc --it-is-already-the-default-behavior
17:02:04 <CodeKiwi> Welkin still watching this talk lol
17:02:08 <edwardk> glittershark: that is sort of the point of the singletons package
17:02:12 <Welkin> CodeKiwi: which one?
17:02:18 <glittershark> I'm currently getting by with `class Demote k (a :: k) where demote :: a` but...
17:02:23 <glittershark> aww ok
17:02:23 <hpc> actually ghc -it-is-already-the-default-behavior, it uses bsd flags ;)
17:02:24 <CodeKiwi> cppcon https://www.youtube.com/watch?v=rX0ItVEVjHc
17:02:27 <Welkin> oh haha
17:02:31 <Welkin> it's a good talk
17:02:35 <glittershark> I was worried singletons would be the answer
17:02:46 <glittershark> I don't think I can sell that much TH to my team :/
17:02:46 <Welkin> the Q&A at the end is amusing
17:02:51 <hpc> ph88: do you have something like -fdefer-type-errors on?
17:02:55 <edwardk> glittershark: i personally usually use the reflection package then make manual instances of Reifies that lower the types that inhabit the lifted kind to their respective terms
17:02:59 <CodeKiwi> everyone keeps talking here so I have to keep pausing it and I do other things too :(
17:03:03 <ph88> hpc, no
17:03:16 <glittershark> edwardk: is Reifies equivalent to the Demote I gave above?
17:03:35 <hpc> can you describe what it's doing in more detail?
17:03:46 <glittershark> ah, yep, looks like it
17:04:14 <glittershark> bummer that it's proxy based, but I guess TypeApplications is still a baby
17:04:17 <edwardk> https://github.com/ekmett/rounded/blob/c89f2a70fdef477916235f1e800e99432eec77dd/src/Numeric/Rounded/Rounding.hs is a fairly stereotypical example
17:04:51 <glittershark> edwardk: this is exactly what I was looking for, thanks
17:05:00 <edwardk> proxies work across more versions of ghc and don't force me to AllowAmbiguousTypes which is something i don't like as it covers up actual errors i have in practice
17:05:05 <glittershark> I was mostly just looking for a typeclass in the ecosystem I could import rather than defining my own
17:05:19 <glittershark> edwardk: yeah I can't argue with that on principle, only on taste :)
17:06:51 <edwardk> http://hackage.haskell.org/package/hyperloglog-0.4.2/docs/Data-HyperLogLog.html is another example, but it just uses Nat to reify the number of buckets
17:07:16 <glittershark> ah, beautiful
17:07:55 <edwardk> The rounded code i linked first could use reflection to pick the number of bits of mantissa and the rounding mode for MPFR
17:08:16 <edwardk> i typically wind up using reflection for simple parameters like that, where usually its a type i know at compile time but every so often i need it to be dynamic
17:08:22 <glittershark> yep
17:08:32 <glittershark> that's exactly what we're doing with "demote"
17:08:59 <glittershark> well, that and they float around as a phantom on a GADT
17:09:57 <glittershark> I kinda like "reifies" as a word better than "demote" too
17:10:12 <EvanR> phantom types glittering off the shoulder of a GADT
17:10:51 <edwardk> the other way that i use it a lot is when i need to build up a very complicated value level expression, and then have a type that depends on it. like tabulating the transition function of a DFA as a monoid. the DFA is fixed and becomes part of the type, but its built as a complicated data type in its own right
17:11:00 <ph88> hpc, there was a module with an error in it .. after that module was finished compiling ghc started to compile the Main module
17:11:10 <edwardk> i use this to avoid many of the usecases for dependent types
17:11:22 <glittershark> hmm!
17:11:31 <edwardk> as long as i can follow a sort of stack discipline, reify/reflect work well
17:11:55 <edwardk> and at the same time they let me write instances that depend on values in scope
17:12:21 <glittershark> yeah I remember someone saying at some point that there's some wild unsafeCoerce of typeclass dictionaries going on under the hood of reflect
17:12:32 <glittershark> but hey,
17:13:00 <glittershark> "instances that depend on values in scope" seems *great*
17:13:08 <edwardk> its one unsafeCoerce that simon himself has said he'd be willing to bake into ghc as it forms well-typed core, its just you can't express the type it has in the surface language
17:13:20 <glittershark> :0
17:13:55 <glittershark> well that's cool
17:14:19 <edwardk> i sat down with austin to do so a few years back, but i got distracted with teaching simon lenses, and that ate up most of the time i had set aside for it
17:14:21 <EvanR> yeah can we get reflection as some sort of language feature or primitive instead of being unsafeCoerce
17:14:40 <glittershark> EvanR: that's sorta what I was getting at earlier, like...
17:14:54 <edwardk> ultimately i think the benefit of having simon himself give that talk about lenses was worth the trade-off, but eventually we should get around to getting it into ghc.
17:15:02 <glittershark> it seems to me like `Reifies` or something like it could be something you get free instances for like Typeable with -XDataKinds
17:15:13 <edwardk> the main pain point is that there is more than one rather similar language feature that makes use of something kinda like Reifies
17:15:14 <Welkin> edwardk: lenses added to base?
17:15:22 <glittershark> lol
17:15:24 <Welkin> or to replace records? Or what
17:15:28 <edwardk> e.g. if you look at Data.Constraint.Nat from `constraints`.
17:15:39 <edwardk> Welkin: this was way back when simon gave his introductory talk about lenses
17:16:19 <edwardk> anyways the Data.Constraint.Nat stuff needs something substantially similar to reflection, but without the quantifier. that version is sound due to the fact that the inputs are singletons, not because of generativity of the types involved
17:16:25 <glittershark> edwardk: I was literally yesterday working through proof of arithmetic properties of peano numerals as an Agda learning exercise, so this module is fortuitous :P
17:16:47 <glittershark> edwardk: you mean without the fundep? or what do you mean by quantifier?
17:17:30 <edwardk> the quantifier is what makes reifies/reflect sound. the uniqueness of '2 + 3' is what makes the stuff in Data.Constraint.Nat sound ;)
17:17:54 <edwardk> by quantifier i mean
17:18:05 <EvanR> does a combination of \ and -> have a precedence
17:18:14 <EvanR> or something
17:18:22 <edwardk> reify :: a -> (forall s. Reifies s a => Proxy s -> r) -> r; reflect :: Reifies s a => p s -> a
17:18:28 <EvanR> higher than application
17:18:44 <glittershark> ahh, yeah
17:18:50 <glittershark> so you can't give your own s
17:18:56 <edwardk> EvanR: no. they aren't 'operators' they are symbols in the grammar of the language. you only deal with precedence when you get to the expression/pattern terms
17:19:03 <glittershark> is there a version of that that's simplified with TypeInType?
17:19:14 <EvanR> i mean if you were trying to show lambdas mixed with other operators
17:19:26 <edwardk> glittershark: not sure how it'd simplify things.
17:19:33 <EvanR> if you dont put parens it would not parse
17:19:34 <glittershark> like my instinct post TypeInType would be to define Reifies k (a :: k)
17:19:41 <EvanR> but you dont always have to put parens
17:19:56 <edwardk> glittershark: give it a shot and tell me how it goes
17:20:00 <glittershark> haha
17:20:08 <glittershark> I'll try :)
17:20:33 <edwardk> that was honest curiosity, not dismissal of the approach
17:20:49 <glittershark> I eventually read it as such
17:21:01 <glittershark> positive intent assumed :)
17:21:14 <glittershark> I'm gonna poke at it!
17:22:44 <edwardk> meanwhile i'm sitting here trying to figure out a name for https://www.reddit.com/r/haskell/comments/8d5apd/ann_constraintsemerge_defer_instance_lookups/dxkqzt8/
17:22:57 <edwardk> so i can finally package it and forget about it
17:24:58 <glittershark> so many options
17:25:09 <glittershark> Potential wasn't mentioned in that thread
17:25:16 <edwardk> thats good
17:25:17 <glittershark> ie "it's a Potential String"
17:25:45 <glittershark> I do agree that Partial is already taken by partial vs total
17:26:24 <nshepperd> what does it mean that Data.Constraint.Nat is sound?
17:26:34 <nshepperd> if you can still define plusNat incorrectly
17:27:47 <edwardk> you can visually inspect the library for correctness, think of it as an extra component in your trusted code base. check the laws stated as properties of natural numbers, check the implementation implements those properties, then treating the library as a black box you can build atop it without having to trust your own code's reasoning
17:28:33 <nshepperd> oh ok, so you mean that plusNat itself could be built into ghc, not the unsafeCoerce that lets you define it
17:29:48 <nshepperd> that makes sense
17:30:20 <nshepperd> and I sort of do that already using the various type checker plugins that put these entailments wherever they are needed
17:34:46 <inkbottle> In "img@Image {..}", what does the ".." stand for?
17:35:21 <CodeKiwi> Welkin the comments are lulz
17:35:41 <jle`> inkbottle: RecordWildCards
17:35:58 <jle`> inkbottle: it's sugar for shadowing all of the record accessors with the contents of img
17:35:58 <inkbottle> jle`: got it, thanks
17:36:47 <CodeKiwi> Welkin I could see how people don't like it if they don't know what he's talking about
17:37:41 <inkbottle> jle`: (Would have had a hard time finding it all by myself)
17:37:52 <CodeKiwi> Welkin I can't find it right now but one time I had a lua program written in two different ways and even there dod was able to have significant performance gains
17:37:58 <jle`> inkbottle: yes, i can see how that would be hard to google ;)
17:38:45 <inkbottle> jle`: and it's not a "standard" operator either
18:11:15 <texasmynsted> If I want very tight integration between ghci and an editor, what is the best way?  I am thinking in terms of what I have heard people describe for clojure.
18:19:09 <jle`> inkbottle: note that it's not quite an operator :)
18:19:28 <inkbottle> no, indeed
18:25:37 <sophiag> someone mentioned the other day that there are stock quickcheck properies for comonads, but i can't find them. i would expect them to be in Test.QuickCheck.Classes but no :(
18:28:55 <lyxia> no there aren't
18:29:04 <lyxia> but they're easy enough to define when you need them
18:30:48 <Guest67676> could I have some help with this little snippet real quick? I'm clearly doing something horribly wrong but I can't work out what it is https://pastebin.com/RQNEmZm9
18:30:49 <jle`> duplicate . duplicate = fmap duplicate . duplicate
18:31:00 <jle`> extract . duplicate = id
18:31:01 <Guest67676> oh great my username
18:31:04 <jle`> i think that's it?
18:31:16 <Big_G> What have you all found to be the best IDE (or equivalent setup) for Haskell development?
18:31:23 <jle`> Guest67676: what makes you think you are doing something horribly wrong?
18:31:41 <Guest67676> jle`: well it's giving me an error, so
18:31:47 <jle`> Guest67676: what's the error?
18:33:16 <Xal> Big_G: emacs is pretty common here
18:33:42 <Xal> though it is definitely not batteries-included
18:34:03 <Guest67676> jle`: kinda long to just paste here, here you go https://pastebin.com/rKi8AfSs
18:34:19 <Big_G> Yeah, I'm using emacs with intero right now. It's much better than vanilla but leaves a lot to be desired.
18:34:46 <Xal> have you used ghc-mod?
18:35:20 <sophiag> lyxia: thanks! p sure you were the one who told me something along those lines, but i must not remember exactly what you said
18:35:27 <Xal> I haven't used intero at all actually, I should probably take a look at it.  ghc-mod has worked for me so far
18:35:44 <jle`> Guest67676: 'couldn't match expected type 'a' with actual type 'Double''
18:35:46 <lyxia> sophiag: I just said you can do it :)
18:35:56 <jle`> Guest67676: that's basically saying you are mixing up Double's with non-Double's
18:36:20 <jle`> Guest67676: in particular, on line 7
18:36:32 <jle`> Guest67676: it looks like you might have added line 6 to try to fix this
18:36:33 <sophiag> lyxia: ha. isn't that obvious tho? are there typeclasses where that's not possible?
18:36:39 <jle`> Guest67676: but if you did, you'd have to remove Line 7 too
18:37:32 <Guest67676> oh yeah, uh, there's an idea I had to fix that
18:37:37 <Guest67676> but it doesn't work either
18:38:11 <jle`> Guest67676: why not?
18:38:13 <Guest67676> why can't I change mySum(k:ks) = fromIntegral k + mySum ks to mySum((Integral k):ks) = fromIntegral k + mySum ks
18:38:25 <Guest67676> it seems like it should match integers specifically in that case
18:38:28 <Guest67676> er, integrals I guess
18:38:33 <jle`> Guest67676: that's not quite how pattern matching works
18:38:38 <jle`> you can only pttern match on constructors
18:38:42 <lyxia> sophiag: I think most people don't realize how easy it actually is to do
18:38:49 <jle`> but mySum (k:ks) = romINtegral k + mySum ks should be fine
18:38:56 <Big_G> I used ghc mod a while back in my vim days but can't say I really dove into it. Any recommendations Xal?
18:39:16 <Guest67676> uh, haven't seen that function
18:39:21 <jle`> sorry, fromIntegral :)
18:39:25 <jle`> ssh lag
18:39:37 <Guest67676> wait it was a typo
18:39:59 <sophiag> lyxia: that's...odd
18:40:00 <Xal> Big_G: other than that, nope!  I don't think it gets a whole lot better than intero or ghc-mod
18:40:03 <Guest67676> wait, doesn't fromIntegral not work on doubles? then when I pass a double to the function it won't work
18:40:11 <Guest67676> or is it overloaded to do nothing in the double case
18:40:20 <jle`> Guest67676: fromIntegral works on doubles
18:40:25 <jle`> oh sorry
18:40:27 <jle`> yes, it doesn't :)
18:40:35 <Guest67676> lol
18:40:42 <jle`> Guest67676: okay, let's take a step back and try to figure out what you actually want to do
18:40:45 <jle`> you want mySum :: [a] -> Double
18:40:54 <jle`> you want mySum to take a list of any type, and return a Double?
18:40:58 <jle`> do you think that makes sense as a function?
18:41:18 <Guest67676> huh, you're right
18:41:28 <jle`> about what?
18:41:36 <jle`> i just asked to help clarify what you want, heh
18:41:49 <jle`> that might be what you want, but it's good to think about what it is you really want
18:41:57 <Guest67676> it doesn't make sense to try to take a list of anythings and add them up
18:42:46 <Guest67676> should I just make two separate functions, one for ints, one for doubles?
18:42:53 <jle`> Guest67676: what do you want to do in the end?
18:43:05 <Guest67676> I want to take a list of numbers and spit out an average.
18:43:25 <jle`> what type would that have?
18:43:33 <EvanR> so it will have to support / right
18:43:53 <Guest67676> Double, since averages of course can be non-ints
18:43:58 <EvanR> hmm i wonder what kind of law a generalized "average" would have
18:44:20 <jle`> Guest67676: i mean, what type would that function have?
18:45:28 <Guest67676> Oh, it would be like... [general number type] -> Double? I don't even know what the general number type even is. I tried using Real but that didn't work
18:45:46 <EvanR> oh lord no
18:45:49 <EvanR> general number type!!
18:45:52 <EvanR> no
18:45:57 <nshepperd> why can't the output number type be the same as the input
18:46:19 <Guest67676> because I want it to work on ints too and the average of ints isn't necessarily an int
18:46:26 <EvanR> you have a choice of number types https://github.com/haskellcats/haskell-numbers
18:46:34 <jle`> Guest67676: yeah, it doesn't quite make sense to make an averaging function that works on both Integers and Doubles
18:46:50 <EvanR> some of them satisfy certain operations, some dont
18:46:51 <jle`> Guest67676: you'd have to probably write a separate "integral averaging" function and a "factional averaging" function
18:46:56 <jle`> *fractional
18:47:04 <Guest67676> ok, that makes more sense lol
18:47:12 <jle`> Guest67676: my suggestion, first try writing average :: [Double] -> Double
18:47:22 <Guest67676> coming from other languages it makes sense to just have the same function do different things depending on the types it gets
18:47:35 <Guest67676> I guess that was the disconnect
18:47:40 <jle`> Guest67676: yeah, that's something you can gain with typeclasses in haskell
18:47:42 <EvanR> you are probably thinking, just "promote" an Integer to a Double, and average those
18:48:03 <jle`> Guest67676: the difference is that you'd have to treat all input types "uniformly"
18:48:09 <jle`> with respect to any typeclass restraints you have
18:48:18 <EvanR> anything that can be converted to Double would work, but now the question is does that conversion make sense
18:48:30 <EvanR> and haskell reveals this conundrum to you up front
18:48:34 <nshepperd> oh, well Real would be the type of things that you can convert to Double
18:48:45 <nshepperd> typeclass*
18:48:54 <EvanR> yes
18:49:19 <Guest67676> So how would I specify that in my code?
18:50:10 <jle`> Guest67676: you could make it polymorphic for all Real's
18:50:13 <EvanR> avg :: Real a => [a] -> Double
18:50:15 <jle`> like average :: Real a => [a] -> a
18:50:27 <Guest67676> Oh! That makes sense.
18:50:39 <jle`> or you can make it polymorphic for all Integral's, and pick a result type, like Integral a => [a] -> Double
18:50:48 <jle`> but yeah, i'd recommend writing [Double] -> Double first
18:50:49 <nshepperd> jle`: that wouldn't work, Real doesn't let you divide
18:50:58 <jle`> nshepperd: ah yes, good point
18:51:05 <Guest67676> wait what? why can't you divide reals?
18:51:08 <jle`> RealFrac
18:51:10 <nshepperd> average :: (Real a, Fractional b) => [a] -> b
18:51:15 <nshepperd> would be the most general
18:51:18 <EvanR> you can convert to Double
18:51:22 <jle`> Guest67676: you can, but it's just the Real typeclass
18:51:28 <jle`> Guest67676: numbers in haskell are a bit janky ;)
18:51:33 <jle`> the numeric typeclasses, i mean
18:51:52 <EvanR> well, the organization may be a bit off, but these issues cant be solved with a reorganization
18:52:04 <EvanR> different number technology is different, theres no hierarchy
18:52:11 <nshepperd> Guest67676: Real means that the type is a subset of the real numbers, more or less
18:52:20 <monochrom> Yeah first order of business is to stop denying that class is not type.
18:52:26 <EvanR> it means it has a rational conversion routine
18:52:29 <nshepperd> Guest67676: Integers are real numbers, but you can't divide them
18:52:54 <Guest67676> oh. uh, that's odd
18:53:04 <EvanR> Real = toRational. Fractional = /
18:53:27 <EvanR> RealFrac = floor
18:53:39 <EvanR> Floating = sin, cos, exp, log
18:54:32 <Guest67676> so I'm a bit lost now
18:55:04 <Guest67676> is a function that takes a list of reals and gives an average possible or not?
18:55:27 <EvanR> [Double] -> Double
18:55:41 <Guest67676> oh wait I see
18:55:42 <Guest67676> I'm silly
18:55:43 <EvanR> possible
18:55:55 <Guest67676> [Double] -> Double and then just convert inputs to doubles
18:55:59 <Guest67676> got it
18:56:06 <EvanR> if that is what you wish :)
18:56:22 <Guest67676> ty lol
18:56:23 <EvanR> just dont try to prove that that makes sense
18:56:24 <monochrom> There is no "list of reals".
18:56:53 <Guest67676> uh, I hope you're not referring to cantor diagonalization
18:56:59 <monochrom> No.
18:57:02 <Guest67676> ok lol
18:57:19 <EvanR> > realToFrac (2^64) :: Double
18:57:21 <lambdabot>  1.8446744073709552e19
18:57:34 <EvanR> > realToFrac (2^128) :: Double
18:57:36 <lambdabot>  3.402823669209385e38
18:57:47 <EvanR> > realToFrac (2^1024) :: Double
18:57:49 <lambdabot>  Infinity
18:57:53 <Guest67676> heh
18:57:56 <Guest67676> good job lambdabot
18:58:02 <jle`> > 2**1024
18:58:03 <lambdabot>  Infinity
18:58:31 <EvanR> converting stuff to Double may not be accurate, in the worst case non sensical
18:58:50 <Guest67676> hmm
18:59:23 <nshepperd> technically true, but the cases in which you want to use an average but Double is not sufficient are probably quite rare
18:59:37 <EvanR> but your latest plan has made more sense than anything else weve covered
19:00:02 <Guest67676> wait that means you can't build an average function for huge lists of doubles, since you'd have to convert the length of a list to a double if you wanted to take the sum divided by the length
19:00:03 <EvanR> yes, Double is our machine god
19:00:28 <monochrom> How huge is "huge"?
19:00:29 <jle`> Guest67676: yes, you can convert ints to doubles easily
19:00:36 <jle`> using fromIntegral
19:00:45 <EvanR> the length of the list is an integer... which will be exact up to what 2^52
19:00:48 <Guest67676> yeah but won't it cause issues with huge ints?
19:00:49 <EvanR> in Doubles
19:00:57 <nshepperd> that's ok, you can't build an average function for lists of 2^1024 elements of any type
19:00:59 <Axman6> Ints are 64 bit
19:01:05 <Axman6> > maxBound :: Int
19:01:07 <lambdabot>  9223372036854775807
19:01:19 <Guest67676> I guess you've kinda just gotta accept that the numbers can only get so big
19:01:29 <Axman6> if you have that many numbers to average, you're going to run into troubles with the Doubles before the Ints
19:01:30 <EvanR> i dont accept that
19:01:33 <nshepperd> since you'll run out of pointers
19:01:41 <monochrom> You can start using Rational instead.
19:02:05 <EvanR> [Rational] -> Rational is also well defined, and will be exact
19:02:22 <EvanR> but still wont complete any time soon for list of size 2^52
19:02:30 <Guest67676> decent point. is the toRational function also always well-defined?
19:02:40 <jle`> > toRational (0/0)
19:02:42 <lambdabot>  (-26965397022934738615939577861835371004269654684134598591014512173659901370...
19:02:48 <Guest67676> ok no other than that
19:02:52 <EvanR> > toRational (sqrt 2 :: CReal)
19:02:54 <lambdabot>  *Exception: CReal.toRational
19:02:57 <EvanR> no
19:02:59 <Guest67676> damn it
19:03:36 <monochrom> Oh I guess you can start using CReal too.
19:03:57 <Welkin> cereal
19:04:05 <EvanR> > sum [1, 2, sqrt 2 :: CReal] / 3
19:04:07 <lambdabot>  1.4714045207910316829338962414032326928566
19:04:14 <Axman6> I don't thing CReals are guaranteed to terminate in quite a lot of cases, right?
19:04:16 <EvanR> sum [1, 2, 3.0] / 3
19:04:16 <monochrom> I suspect all of these "what if huge list" "what if this" "what if that" are all hypothetical.  Do you actually need them?
19:04:19 <EvanR> > sum [1, 2, 3.0] / 3
19:04:21 <lambdabot>  2.0
19:04:27 <Welkin> lol monochrom
19:04:30 <EvanR> > sum [1, 2, sqrt 2] / 3
19:04:30 <Welkin> what a silly question
19:04:32 <lambdabot>  1.4714045207910316
19:04:36 <Welkin> the answer is almost always no
19:04:43 <monochrom> Because if you actually needed one of them, you would be so much more quantitative than "what if huge".
19:04:47 <nshepperd> for the ordinary use case of summing a bunch of ints or floats, toRational is just fine
19:04:57 <Guest67676> yeah lol that's what I was figuring
19:05:07 <monochrom> The answer depends on the question. The solution depends on the problem. There is no one-size-fits-all.
19:05:15 <Welkin> monochrom: it's called a mumu!
19:05:31 <EvanR> at least we dont have the answer depends on the question and the question depends on the answer
19:05:33 <Welkin> muumuu*
19:06:19 <Guest67676> I like and dislike how programming is so insanely complicated like this. my question boiled down to "what type signature should I use for a generalized average function" and it blew up into like 20 minutes of discussion
19:06:51 <EvanR> you discovered a sort of truth, that a generalized average function may not make sense
19:06:58 <monochrom> Yeah, next time try "what type signature should I use for the halting problem" too.
19:07:11 <nshepperd> we'll never know if that's because the problem is complicated or because we are
19:07:19 <Welkin> Guest67676: programming is not complicated at all
19:07:25 <Welkin> people *make* it complicated for no reason
19:07:25 <monochrom> Like you actually believe that if the question is short than the answer is also short.
19:07:44 <Welkin> it comes down to moving informations around in memory
19:07:47 <Welkin> that's about it
19:07:51 <Welkin> information*
19:08:30 <Welkin> and yes, trying to generalize as much as possible will always lead to problems and confusing useless abstractions
19:08:36 <monochrom> If you're even contemplating using floating point numbers, first order of business is in what order you should add those numbers in the first place.  This is even before you consider division.
19:08:45 <Guest67676> that feels like it must be a logical fallacy in the same vein; just because people simplify down to atoms doesn't mean solving world hunger is easy
19:09:20 <Welkin> Guest67676: world hunger is a social problem, not a technological one
19:09:24 <Welkin> technology is easy
19:09:32 <Welkin> people are hard
19:09:40 <monochrom> And on the other side, using Rational has its huge economic requirements.  You need more time and more memory.
19:10:01 <Guest67676> Yeah I guess I see your point, if there were no problems to solve programming would be easy because it would never be invented
19:10:20 <Guest67676> but I can't really figure out how to extract any more meaning from that statement
19:10:25 <monochrom> Computing is going to be more complicated than math because you are always trading one resource for another.
19:11:08 <monochrom> Even if it's just the theory of computing.
19:11:16 <Guest67676> it's like a math problem where the more you use variables in your equation the worse the answer is so you have a new math problem on top of the first one
19:11:19 <Welkin> monochrom: that ties into data oriented design, which I linked to a video of earlier
19:11:35 <Welkin> when programming, you can't pretend that the computer is this magic thing with endless resources
19:11:47 <Guest67676> hey Turing did exactly that and he did well for himself
19:11:55 <Guest67676> uh, there's no Kappa here
19:12:06 <Guest67676> just know that was sarcasm
19:12:16 <MarcelineVQ> monkaS
19:12:21 <EvanR> we also discovered why this problem is so trivial in javascript
19:12:26 <Guest67676> heh
19:12:29 <EvanR> because they only have 1 number type, Double
19:12:53 <Welkin> speaking of javascript
19:13:07 <Welkin> I think I'm finally going to write my own utility library
19:13:09 <Guest67676> you know when I first looked at this problem I thought for sure that strong typing was just giving me issues. it's nice to see that clearly I was giving myself issues with the question I was asking.
19:13:18 <Guest67676> I have to go now but thanks for the awesome insights guys
19:13:21 <Welkin> strong typing?
19:13:24 <Welkin> you mean typing?
19:13:35 <EvanR> welk typing
19:13:36 <Welkin> "weak typing" is just no types at all
19:13:49 <Welkin> javascript treats strings like numbers sometimes
19:13:54 <Welkin> and True can be equal to 1
19:14:10 <Welkin> actually, python does this too
19:14:12 <Welkin> totally stupid
19:14:29 <Guest67676> yeah but there are still some types you can't implicitly convert between which means it must have typing still
19:14:30 <monochrom> How about GUT typing so it unifies the strong force and the weak force
19:14:30 <Welkin> so you either have types, or you don't
19:14:32 <Guest67676> ok seriously I gotta go
19:15:06 <EvanR> to get an "average force"
19:15:23 <EvanR> average typing
19:15:59 <monochrom> On second thought, clearly "GUT typing" is redundant like "ATM machine" :)
19:18:09 <EvanR> i created a problem for myself in this toy language, when you write numerals like 3 3.0 or 3.3 the expression exists in the AST as a scientific. it could be considered either an Integer or Double. and now i dont know what kind of arithmetic + does
19:18:13 <monochrom> Oh how about this.  The lambda cube is our grand unified theory of types.  Half of it are non-dependent types, the other half are dependent types.  So why don't we hijack and shift the terminology.  The non-dependent half are all weak typing, the dependent half are all strong typing.
19:18:22 <EvanR> for this reason alone i need an entire type system :(
19:18:25 <CodeKiwi> Welkin I couldn't even finish listening to this one guys "question"
19:18:38 <monochrom> So basically we just raise the bar.  Even Haskell is weak typing.  You have to go Agda for strong typing. :)
19:19:34 <EvanR> just because i didnt want to be like javascript
19:20:21 <Welkin> CodeKiwi: LOL!
19:20:24 <EvanR> and i cant use scientific arithmetic because 1 / 3 would bottom
19:20:24 <Welkin> I know who you mean
19:20:38 <Welkin> the really old guy who talks really slow
19:21:03 <Welkin> and takes about 2 minutes to say (in many more words) that he disagrees with the whole 1 hour talk
19:22:40 <EvanR> what are you talking about
19:23:40 <monochrom> An Old Man. Might not be Gary Old Man.
19:23:52 <EvanR> complaining about the speed of information in one particular video? how monomorphic :)
19:24:08 <monochrom> Heh yeah
19:31:30 <CodeKiwi> Welkin yeah I was reading the comments throughout the video and determined he is the guy that is why word starts slow
19:33:05 <CodeKiwi> the comments are wack like...ugh I dislike people. also why do people think that anyone there wants to hear their "question" people came to listen to the speaker not you :|
19:33:25 * CodeKiwi says boldly into the void
19:35:58 <iqubic> :k Void
19:35:59 <lambdabot> *
19:36:03 <iqubic> :t void
19:36:04 <lambdabot> Functor f => f a -> f ()
19:36:13 <iqubic> Which void do you speak into?
19:36:25 <iqubic> CodeKiwi: ^^^
19:36:28 <CodeKiwi> EvanR the guy starts talking at about 1:16 or so https://www.youtube.com/watch?v=rX0ItVEVjHc for several minutes during a q&a basically disagrees with the speaker
19:36:51 <ludat> hi everyone, is there something like `type` but for typeclasses? for example, writing `MyAlias m => m Int` means `MonadIO m, MonadReader Int m, MonadTrow m => m Int`
19:36:52 <CodeKiwi> that's 1 hours 16 min
19:37:53 <MarcelineVQ> ludat: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ConstraintKinds
19:38:56 <MarcelineVQ> should let you write   type MyAlias m = (MonadIO m, MonadReader Int m, MonadThrow m)
19:40:58 <CodeKiwi> the speaker who gave a very practical real world example of his industry usage of C++ and various things they do to get the most performance on embedded devices and also keeping development overhead (ie. compile time and shit bugs) low. by not using STL etc. and most people are like "well why do they even use C++ then!" >.> even after he clearly stated they'd be better off (performance) using asm, but due to constraints (time, developers) they
19:40:58 <CodeKiwi>  have to use other tools
19:41:31 <CodeKiwi> anyway it was a good talk, avoid the comments :|
19:41:55 <CodeKiwi> Welkin this is all your doing
19:42:06 <IAmBill> Anyone know anything about implementing virtual hardware?
19:42:10 <ludat> MarcelineVQ: that's exactly what I was looking for, thanks!
19:42:21 <IAmBill> Meaning, I'd like to trick Windows into thinking that a second monitor is connected to the computer
19:42:35 <IAmBill> I don't know if that's possible without somehow cracking into the display driver
19:43:10 <IAmBill> Or if anyone is aware of any open source software that does this already, I'd love to hear about it
19:44:12 <CodeKiwi> I saw someone did that with an vga end that they wired right
19:44:50 <IAmBill> Yeah, I know how to trick the pin-out of a DVI or VGA into making the display driver think there is a display connected
19:44:59 <IAmBill> But I was hoping for something purely software based
19:45:07 <CodeKiwi> it was for a headless mac mini that got pissy if it didn't have a monitor but it was headless so they wired the pins together on an detached cable end
19:45:13 <IAmBill> As it'd be something I'd like to distribute
19:45:59 <CodeKiwi> idk
19:46:13 <IAmBill> Thanks for your input
19:46:30 <CodeKiwi> np sorry I don't know more
19:59:09 * hackage GLFW-b 3.2.1.0 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-3.2.1.0 (Mokosha)
20:02:10 <CodeKiwi> Welkin https://www.youtube.com/watch?v=16ZF9XqkfRY
20:09:29 <anon136> My book was like "and now I am going to show you how to crack a caesar cipher" but I was like "like hell you do before I figure it out myself first". It's dirty and gross but I figured it out and it feels good. https://pastebin.com/ffFLPjk1
20:10:31 <EvanR> here it is on lpaste http://lpaste.net/365197
20:10:34 <anon136> And now I can continue reading without feeling ashamed.
20:11:42 <anon136> wow lpaste looks much nicer, thanks
20:12:00 <EvanR> i have one floating around that cracks RSA
20:13:09 * hackage yesod-form-bootstrap4 0.1.1 - renderBootstrap4  http://hackage.haskell.org/package/yesod-form-bootstrap4-0.1.1 (ncaq)
20:13:18 <EvanR> i mean, brute force and takes "forever" unless you turn down the parameters
20:13:40 <anon136> that's pretty cool
20:14:14 <anon136> im excited to see how the book does it now compared to how i figured it out
20:15:14 <EvanR> what book
20:15:43 <anon136> programming in haskell second edition by gaham hutton
20:15:56 <CodeKiwi> I just OTP everything before I encrypt it
20:16:47 <EvanR> md5 encryption?
20:17:26 <Xal> anon136: you might like cryptopals https://cryptopals.com/
20:17:53 <Xal> if you like learning through figuring it out yourself, that is
20:18:19 <Xal> also cryptopals breaks a whole bunch of crypto that's used a ton today in later chapters
20:19:09 <anon136> Xal: awesome that seems really cool. I've messed around with project euler a bit for that reason.
20:21:00 <EvanR> your table of numbers like 0.2 0.1 and 7 heh
20:21:09 * hackage yesod-form-bootstrap4 1.0.0 - renderBootstrap4  http://hackage.haskell.org/package/yesod-form-bootstrap4-1.0.0 (ncaq)
20:23:17 <CodeKiwi> I was pleasntly surprised I remembered my project euler password after like 6+ years...
20:24:13 <anon136> EvanR: yea it's not very clearly labeled. It's the percentage that each letter is represented in the english language.
20:24:45 <anon136> EvanR: I had to pull that part from the book and it's just called "table" there.
20:25:55 <EvanR> i get so annoyed with people using percentages as-is, like characters yelling "over 900000%!"
20:26:15 <EvanR> i have no idea how many actual zeros are involved
20:27:06 <CodeKiwi> well in context you will see that over 9000 is quite a lot
20:27:14 <anon136> EvanR: Hey. It always makes your profits seem bigger if you put them in terms of percent instead of multiples.
20:27:37 <EvanR> they should use parts per billion then
20:28:17 <EvanR> lol did 900000% end up being 9000
20:28:19 <CodeKiwi> it's over 9000 ppb
20:28:31 <CodeKiwi> it just got dropped in translation
20:28:47 <anon136> bitcoin over 9000 tonight
20:29:00 <CodeKiwi> under 300 tomorrow
20:35:26 <CodeKiwi> hey has anyone heard of this https://github.com/k0001/safe-money
20:35:44 <EvanR> came up in here recently
20:35:58 <CodeKiwi> oh neat
20:36:26 <EvanR> maybe just hackage notification
20:44:21 <EvanR> @hoogle floor :: Double -> Double
20:44:22 <lambdabot> No results found
20:45:22 <EvanR> is there a standardish package with a floating point floor
20:59:22 <EvanR> https://www.reddit.com/r/haskell/comments/7sgwaz/floornan_returns_an_arbitrary_value/dt8puy0
20:59:37 <EvanR> > 3.999999999999999 == (4.0 :: Float)
20:59:39 <lambdabot>  True
20:59:53 <EvanR> not False like in the reddit comment...
21:07:33 <EvanR> kind of amazing TAPL has pretty much no info on type classes
21:07:34 <CodeKiwi> platform dependent?
21:07:57 <CodeKiwi> > 3.999999999999999 == (4.0 :: Double)
21:07:58 <lambdabot>  False
21:08:57 <Axman6> CodeKiwi: thewy have a good blog post about the design of the library, it's very sensible and solves a lot of problems
21:09:37 <CodeKiwi> I wonder if it was on hacker news too
21:09:37 <EvanR> wait what...
21:11:11 <CodeKiwi> EvanR what?
21:11:43 <EvanR> the same comparison (Float) would give True or False on different machines? how
21:12:28 <EvanR> is it a different in parsing decimal or
21:12:31 <EvanR> difference
21:12:58 <CodeKiwi> how many bits are used to represent a float can change
21:13:12 <EvanR> what
21:13:16 <EvanR> 32
21:14:20 <CodeKiwi> hell on lua there's only one number type and it's a compile time setting what they're represented as
21:14:53 <EvanR> this is haskell
21:14:58 <CodeKiwi> anyway point is you can't compare floating point numbers for exactness
21:15:08 <EvanR> everyone says that and are wrong
21:15:24 <EvanR> its not like the equality test is an RNG
21:15:58 <EvanR> each number has a unique rep and it just compares the bits, unless its 0 == -0
21:16:00 <CodeKiwi> it's not a problem specific to haskell
21:16:30 <EvanR> if that reddit comment is to be trusted, it must be a difference in parsing decimal
21:16:48 <EvanR> decodeFloat (3.99999999999999 :: Float)
21:16:52 <EvanR> > decodeFloat (3.99999999999999 :: Float)
21:16:54 <lambdabot>  (8388608,-21)
21:16:58 <EvanR> > decodeFloat (4 :: Float)
21:17:00 <lambdabot>  (8388608,-21)
21:17:04 <woodson> Hey guys, I am trying to install aeson 1.3.0 with nix and I getting this error http://lpaste.net/365198. Can anyone help please?
21:17:38 <CodeKiwi> there are numbers that don't even exist in floating point numbers on computers ...
21:17:54 <EvanR> :|
21:18:28 <boj> woodson: you may need to use a specific channel, or pin to a specific nixpkgs commit you know works. if you are on unstable there is no guarantee everything on hackage will work for you
21:18:30 <CodeKiwi> you cannot compare floating point numbers directly and expect meaningful results you have to use a delta
21:18:35 <EvanR> the goal here is understanding of float behavior, not generation of new float fan fiction
21:18:44 <CodeKiwi> https://en.wikipedia.org/wiki/IEEE_754
21:18:48 <EvanR> thats incredibly wrong and popular to say
21:18:55 <CodeKiwi> ok
21:19:33 <woodson> boj: I am just starting with nix. How do you know which specific channel that I should be using?
21:19:35 <EvanR> exactly what do you accomplish by using a delta
21:20:12 <CodeKiwi> depends on what you're actually trying to do
21:20:45 <EvanR> "you can't do equality tests on floats. you have to use a delta" is this thing people say, much like "have to tried signed distance field fonts"
21:20:53 <boj> woodson: i think the default install puts you on the "unstable" branch. there's not really a way to know which channel you should be on, it depends on your requirements. you may want to try to build against the 17.09, or 18.03 branches to see if it works before doing anything else though
21:21:00 <EvanR> its like an atomic piece of language
21:21:14 <EvanR> have you*
21:21:22 <CodeKiwi> I don't know what you're trying to prove
21:23:02 <iqubic> Use Coq for proofs.
21:23:52 <EvanR> i am reading ieee754's spec, section 5.7 is about comparisons
21:24:19 <EvanR>  Comparisons are exact and
21:24:19 <EvanR> never overflow nor underflow
21:24:55 <CodeKiwi> https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1350006.4
21:25:13 <CodeKiwi>  Float is implementation-defined; it is desirable that this type be at least equal in range and precision to the IEEE single-precision type. Similarly, Double should cover IEEE double-precision.
21:25:49 <EvanR> if you consider a float to be a value in some range, +/- 1/2 ULP, and you want a "within delta" equality test, then that is what == already does
21:26:00 <EvanR> yes i know that line of the haskell report
21:26:13 <EvanR> thats what ghc does, its float and double like in C
21:26:26 <EvanR> 32-bit 64-bit
21:29:02 <EvanR> funny 5.6 is binary to decimal conversion
21:29:45 <CodeKiwi> well sounds like you know more than me
21:30:40 <nshepperd> EvanR: maybe the actual answer is 'that person did the calculation on an intel cpu with buggy ieee754 implementation' :)
21:30:57 <EvanR> :(
21:31:16 <CodeKiwi> ty since I couldn't find information about that existing :|
21:31:35 <Axman6> :t sequence . sequence
21:31:36 <lambdabot> (Monad t, Monad m, Traversable m, Traversable t) => m (t a) -> m (t a)
21:35:00 <iqubic> :t sequence
21:35:01 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
21:35:02 <nshepperd> that looks like an exciting operator
21:35:09 <nshepperd> > (sequence . sequence) [[1,2],[3,4]]
21:35:11 <lambdabot>  [[1,1,2,2],[1,1,2,4],[1,1,3,2],[1,1,3,4],[1,4,2,2],[1,4,2,4],[1,4,3,2],[1,4,...
21:35:23 <iqubic> What does that do?
21:36:13 <woodson> boj: nixos-17.09 seem to have worked. However, when I get in my shell environment and execute ghcjs-pkg list it is still showing the old aeson-0.9.0
21:36:38 <EvanR> :t sequence . sequence . sequence
21:36:39 <lambdabot> (Monad t, Monad m, Traversable m, Traversable t) => t (m a) -> m (t a)
21:36:52 <woodson> boj, Am I missing something else?
21:37:02 <iqubic> How does this type signature even work?
21:37:29 <iqubic> :t sequence . sequence . sequence . sequence
21:37:30 <lambdabot> (Monad t, Monad m, Traversable m, Traversable t) => m (t a) -> m (t a)
21:38:28 <iqubic> What does sequence even do?
21:39:07 <texasmynsted> is there an online haskell repl where more than one person can type into it at the same time?
21:39:41 <texasmynsted> like codeshare.io but where one can execute the code.
21:43:23 <EvanR> if not that sounds like a cool project
21:48:59 <boj> woodson: ghcjs is a weird one. my team uses the reflex
21:49:15 <boj> woodson: reflex-platform specific nix setup
21:49:26 <Welkin> iqubic: just what the type signature says it does
21:49:44 <boj> woodson: they have a sane ecosystem built up around ghcjs
21:49:55 <johnw> iqubic: sequence can be seen to "propagate" an effect.  For example, sequencing t (Maybe a) to Maybe (t a) causes any Nothing inside the 't', to make the whole thing become Nothing.  But if everything is Just, then result is Just.
21:50:40 <woodson> boj: The thing is that I am trying out the miso framework
21:51:02 <Welkin> woodson: that is basically elm or react/redux
21:51:09 <Welkin> the elm architecture
21:51:15 <Welkin> reflex is FRP
21:51:38 <woodson> Welkin: yea I know that
21:51:55 <cocreature> woodson: isn’t this the same error that you showed us yesterday? you should be able to fix it by just disabling the test suite of aeson
21:52:38 <woodson> cocreature: If look a bit I actually managed to install it
21:52:52 <woodson> the problem is that its not reflecting on my ghcjs-pkg list
21:53:10 <boj> woodson: you still have to specify what it pulls in to the shell
21:53:14 <cocreature> ghcjs is tied quite deeply to aeson, you can’t just upgrade aeson like any other package
21:53:59 <boj> woodson: something like, nix-shell -p "ghcjs.withPackages (pkgs: [ pkgs.aeson ])"
21:54:29 <woodson> boj, isnt that already handle through my default.nixfile?
21:54:58 <boj> woodson: you tell me :)
21:55:01 <woodson> cocreature: so, does that mean that I can't upgrade it?
21:55:14 <cocreature> afaik yes
21:55:19 <woodson> boj, then yes I am already pulling it in through my default.nix
21:55:28 <cocreature> bit I’d recommend using ghcjs head which comes with a newer version of aeson
21:55:32 <cocreature> *but
21:56:40 <woodson> hmm.. I wonder why they wouldnt keep up with aeson versions
21:57:07 <cocreature> ghcjs 7.10 isn’t really maintained anymore at this point
21:57:44 <woodson> cocreature: what about ghcjs 8.0?
21:57:54 <cocreature> that’s what nixpkgs calls ghcjs head
21:58:03 <cocreature> as I’ve mentioned that should come with a newer version of aeson
21:58:59 <woodson> ok thank you
22:00:42 <EvanR> so for decimal strings around 4.0, the decimal to binary conversion should be "exactly rounded"
22:00:59 <EvanR> so that reddit comment from like last month should be wrong
22:01:28 <cocreature> someone’s wrong on the internet!
22:01:43 <EvanR> indeed
22:02:22 <EvanR> the comment is wrong, which could improve to either they are wrong or the computer is wrong
22:02:52 <EvanR> or both wrong in a way that doesnt cancel
22:03:15 <woodson> hey cocreature: I just looked at the the nix file for miso https://github.com/dmjio/miso/blob/master/release.nix
22:03:31 <woodson> and it is pulling the ghcjs head
22:04:12 <woodson> I'm wondering why did it pull ghcjs 7.10 for me ..
22:04:37 <cocreature> which command did you run?
22:04:57 <woodson> I followed the Readme.md
22:05:00 <woodson> nix-build
22:05:23 <cocreature> that will use default.nix not release.nix
22:07:30 <woodson> so I'm supposed to explicitly tell it to build the realease.nix?
22:08:59 <cocreature> I wouldn’t try building anything in the miso repository directly, you want to write an application using miso, not hack on miso itself, right?
22:09:13 <EvanR> ieee specifies that sqrt -0 = -0... wtf
22:09:17 <EvanR> > sqrt (-0)
22:09:19 <lambdabot>  -0.0
22:10:38 <EvanR> the spec is surprisingly short
22:13:17 <EvanR> goal number 1 of the standard ... facilitate movement of existing code for the variety of other floating point systems to this one... might explain a few things
22:16:53 <cocreature> woodson: https://github.com/dmjio/miso#nix is probably the part of the readme that you should be looking at
22:17:10 <cocreature> woodson: you might want to update the miso revision and change ghcjs to ghcjsHEAD
22:17:50 <woodson> concreature: yes, I already thanks
22:18:17 <woodson> did**
22:22:51 <nshepperd> > (-0)**0.3
22:22:53 <lambdabot>  0.0
22:23:00 <nshepperd> > (-0)**0.5
22:23:01 <lambdabot>  0.0
22:23:22 <nshepperd> ‾\(o_O)/‾
22:25:25 <EvanR> who knows what ** does
22:33:01 <dibblego> const . const $ 0
22:34:22 <KozmicLuis> Hi, I have a not so important question
22:34:29 <KozmicLuis> if there's (>=>) :: (a -> m b) -> (b -> m c) -> (a -> m c) (???) :: (a -> m b) -> (b -> c) -> (a -> c) Kleisli composition
22:34:55 <KozmicLuis> is there something that allows me to compose the resulting function from >=> to a regular function (a -> b)
22:35:14 <KozmicLuis> and get (a -> c) ? as a result?
22:36:42 <cocreature> KozmicLuis: that can’t work, let’s say m = IO, then you could compose () -> IO () with id :: () () to get () -> ()
22:36:47 <KozmicLuis> for example failure1 >>= failure2 (??? what is this) fmappingFunction
22:36:50 <cocreature> KozmicLuis: you can compose them to a -> m c
22:37:10 <KozmicLuis> oh that's right, mbad
22:37:24 <cocreature> :t \f g -> fmap f . g
22:37:25 <lambdabot> Functor f => (a1 -> b) -> (a2 -> f a1) -> a2 -> f b
22:37:33 <cocreature> is that what you’re looking for?
22:37:40 <cocreature> well I guess you swapped the functions in your type signature
22:37:47 <KozmicLuis> a -> mc from composing f >=> g (???) h and get (a -> m c)
22:38:30 <KozmicLuis> I know I could just use whatever operator there is for (flip (.)) and as the last function add (fmap f)
22:39:00 <KozmicLuis> but I'm looking for an already existing operator that does such composition
22:39:13 <EvanR> flip (.), have you gone mad
22:39:28 <cocreature> I don’t think there is an existing operator for this
22:39:31 <KozmicLuis> I'm using Elm so there's >> and <<
22:39:42 <cocreature> at least none that’s reasonably popular
22:39:46 <KozmicLuis> << is equivalent to (.) in haskell
22:40:14 <cocreature> https://hackage.haskell.org/package/flow-1.0.12/docs/Flow.html#v:.-62- has flip (.)
22:40:17 <KozmicLuis> so you see I'm building a snake game and I have
22:41:18 <KozmicLuis> move >> feed >> boundCollision >=> selfCollision >> Maybe.map maybeSpawnApple >> Maybe.withDefault (initialState, Cmd.none)
22:41:33 <KozmicLuis> (>=>) is a custom operator I did from haskell's kleisli comp
22:41:56 <KozmicLuis> but >> Maybe.map f just seems like I could convert this to an operator that would allow me to just do (???) f
22:42:24 <KozmicLuis> and I was wondering if haskell had one
22:42:31 <cocreature> more operators don’t make things better necessarily :)
22:43:10 <EvanR> i disagree with the rationale on flow
22:43:55 <EvanR> <| will be familiar with people who know unix pipes ... except its the opposite direction and pipes compose programs not apply them...
22:44:29 <KozmicLuis> Elm has pipes in both directions
22:44:32 <EvanR> the only answer is clearly to start writing all code vertically
22:44:33 <Xal> there's a reason function composition goes in the direction it does
22:44:36 <KozmicLuis> I was thinking just ditch the composition
22:45:03 <KozmicLuis> and do f |> g |> h >=> i |> fmap j |> unpack
22:45:16 <KozmicLuis> I forgot the x |> a the beginning
22:45:31 <KozmicLuis> and replace >=> with >>=
22:45:35 <KozmicLuis> sorry
22:45:36 <EvanR> it saysy ou might want <. (which is the same as normal .) in case you want to compose IO functions... beause it puts the last function first... why...
22:46:51 <KozmicLuis> so, does this look good? gameLoop state = state |> move |> feed |> collisionSelf >>= collisionBounds |> Maybe.map maybeSpawnApple |> Maybe.widthDefault (initialState, Cmd.none) ?
22:46:59 <KozmicLuis> this is ofc Elm
22:47:14 <EvanR> it looks bad for haskell
22:47:31 <EvanR> i really try to discourage $ chains
22:47:37 <boj> if your goal is to make a long one liner, then sure... good job. if your goal is to make readable code, you have failed
22:47:46 <Welkin> dolla chain gang
22:47:57 <Xal> holla holla get dolla
22:48:49 <Xal> I'd break that up into a few logically-connected functions, and use pointfree style to make it obvious they're just chains of functions
22:49:19 <EvanR> composition rather than $-ing is provably easier to refactor
22:49:19 <KozmicLuis> well, move and feed could be its own function, the two collisions as well, and leave the ones at the end
22:49:27 <Welkin> Elm doesn't have >>=
22:49:33 <Welkin> it has andThen
22:49:41 <KozmicLuis> so it ends up as movement >> collision >> spawnApple >> unpack
22:49:53 <KozmicLuis> I did (>>=) = flip Maybe.andThen
22:50:20 <KozmicLuis> but I guess people unfamiliar with haskell will not understand
22:51:02 <EvanR> its better to stick with the familiar language already established in your context than to try clever bikeshedding
22:51:16 <EvanR> especially if its ultimately arbitrary, like the direction
22:51:21 <KozmicLuis> if this were haskell tho
22:51:26 <KozmicLuis> would it read better to do
22:51:58 <KozmicLuis> unpack . spawnApple <=< collision2 <=< collision1 . move
22:52:13 <KozmicLuis> oh I forgot there's only one <=<
22:53:07 <EvanR> this is the Maybe monad?
22:53:12 <KozmicLuis> yes
22:54:59 <KozmicLuis> I'm starting to think it'd be better to use Either
22:55:26 <KozmicLuis> and end up Either IntialState NewState
22:55:44 <EvanR> your line of code there will not work
22:56:02 <EvanR> since . binds tighter than <=<
22:56:17 <EvanR> which i had to look up
22:57:04 <Xal> it would be really nice to have a ghci command that lists the precedences of infix functions in scope
22:57:51 <EvanR> perhaps sorted by precedence? :)
22:59:13 <Xal> maybe it could make a table with operators of equal precedence being in the same row
22:59:58 <EvanR> what about assoc!
23:00:15 <EvanR> split into 3 columns one for each associativity
23:00:26 <EvanR> make it so
23:00:30 <dminuoso> Just to verify. `type a = '[F]`, here a is a list of types (with a single element in it) right?
23:02:12 <cocreature> dminuoso: yep
23:02:34 <EvanR> a being a metavariable for valid type names :)
23:02:51 <dminuoso> EvanR: Yeah.
23:04:22 <f-a> hello. I use the PATH trick to use different ghc versions when needed. Is it sensible to use the same trick with cabal executables? Or do I risk making a mess?
23:08:20 <jle`> hm, why would you need to switch out cabal executables?
23:08:46 <jle`> dminuoso: just a note, 'a' is not a valid name for a type synonym
23:09:07 <jle`> ah i missed EvanR's comment
23:09:11 <EvanR> wahahaha
23:09:18 <jle`> i am missing a lot of things today :)
23:09:35 <f-a> jle`: to replicate exactly what another person that I am tutoring has on a different machine
23:09:36 <jle`> was just odd because dminuoso was particular enough to capitalize the F
23:14:23 <Welkin> is this book any good?
23:14:23 <Welkin> https://compilers.iecc.com/crenshaw/
23:14:41 <Welkin> it's all plaintext, which is awesome
23:15:18 <EvanR> brb getting my glowing green terminal
23:15:55 <fishythefish> Welkin: I've heard good things about it, the main downside for people being that it's old and in Pascal
23:15:59 <cocreature> yet another compiler book that focuses on parsing …
23:16:32 <Welkin> lol cocreature
23:16:37 <Welkin> I noticed that too
23:16:50 <Welkin> if I want to learn how to write a compiler, I should just ignore parsing and lexing, right?
23:16:56 <Welkin> just use alex and happy
23:17:05 <cocreature> or some parser combinator lib or whatever
23:17:19 <cocreature> parsing is just a really boring problem for the most part imho
23:17:21 <Xal> EvanR: I couldn't find any previous requests for it, so I made a feature-request on the trac
23:17:23 <EvanR> Welkin: from the names of all the chapters, this is a book about parsing rather than compiling
23:17:30 <cocreature> yet every compiler course/book seems to spend an enormous amount of time on it
23:17:52 <fishythefish> parsing is a boring problem *now* but for a long time, compiler development focused on it because they problem space wasn't well studied and parser generators/combinators didn't exist
23:18:21 <Xal> ironically most major compilers have gone back to just writing recursive-descent parsers by hand
23:18:52 <EvanR> so was it a trivial task for them to write the rest of the compiler? lol
23:19:25 <Xal> gcc used to use a yacc parser but LALR(1) is just not a good fit for C
23:20:02 <fishythefish> Chandler Carruth mentions this (regarding the red dragon book) at the start of https://www.youtube.com/watch?v=FnGCDLhaxKU
23:20:23 <fishythefish> EvanR: well yes and no
23:20:38 <fishythefish> if your language is glorified assembly, you don't need to put as much work into the backend of the compiler
23:20:56 <EvanR> even the name of yacc (compiler compiler) belies the belief that were pretty much done once you have managed to parse the source
23:20:59 <Welkin> fishythefish: then why are c compilers so bad?
23:21:11 <fishythefish> and since backend compiler optimizations are pointless if you can't parse a language, it's not surprising that there was so much focus on parsing and grammars
23:21:26 <fishythefish> Welkin: ?
23:21:43 <Welkin> they can't even do the most trivial optimizations
23:22:10 <EvanR> i can confirm that they can do the most trivial optimizations
23:22:24 <fishythefish> the most trivial optimization is a no-op, so if you're gonna make blanket statements like that, you better back them up
23:22:44 <Welkin> a video I linked earlier today
23:22:48 <Welkin> well several actually
23:22:52 <Welkin> that go deep into detail
23:23:18 <EvanR> you can review the unoptimized and optimized asm output from gcc to see a huge difference
23:23:18 <Welkin> the cppcon Mike Acton talk was a good one
23:23:29 <fishythefish> happy to take a look if you link them, but you'll forgive me if I don't dig through logs to find your evidence
23:23:31 <EvanR> for normal looking C code
23:23:54 <Xal> I wouldn't exactly call modern compilers "stupid": https://godbolt.org/g/PgN612
23:24:04 <Welkin> fishythefish: https://www.youtube.com/watch?v=B2BFbs0DJzw
23:24:26 <Welkin> this is a short video
23:24:28 <Welkin> funny too
23:24:32 <EvanR> Xal: o_O
23:24:57 <EvanR> this kind of analysis must be breaking some impossibility theorems
23:24:59 <Welkin> and here is the long (1+ hour) conference talk that goes into deep detail about it https://www.youtube.com/watch?v=rX0ItVEVjHc
23:25:23 <Welkin> I like what Mike Acton says: "The compiler is a tool, not a magic wand"
23:25:24 <EvanR> how do you manage to learn anything watching 1+ hour videos in a row o_O
23:25:38 <fishythefish> I agree, compilers are tools, not magic
23:25:47 <fishythefish> I don't think I claimed at any point that C compilers are optimal
23:25:47 <Welkin> and how it can only do 1% to 10% of the optimizations
23:26:09 <EvanR> 10% of all possible optimizations are being done -- einstein
23:26:36 <Welkin> watch the first video, it's actually hilarious
23:26:45 <nshepperd> is that why people get so excited about lisp? because they imagine that writing compilers is all about parsing?
23:26:54 <Welkin> during a normal programming stream Casey runs into this weird bug in the compiler
23:27:00 <EvanR> someone told me yesterday that a top physicist proved that 95% of everything cant be comprehended
23:27:01 <Welkin> and stop everything he is doing to find out why
23:27:39 * hackage access-token-provider 0.1.0.0 - Provides Access Token for Services  http://hackage.haskell.org/package/access-token-provider-0.1.0.0 (mtesseract)
23:28:29 <Axman6> Welkin: does he figure out the bug he introduced?
23:28:36 <nshepperd> EvanR: "Your brain only uses 10% of all possible optimizations at any time"
23:28:41 <Axman6> he forgot to make one of the y's an x...
23:29:37 <Lowl3v3l> EvanR: he didn't. You know how i know? because you can't possibly comprehend what you dont comprehend ;)
23:29:47 <Welkin> Axman6: it is not a bug he introduced, it is a problem with microsoft's c compiler
23:29:56 <Welkin> that can't do a very simple optimization
23:30:25 <EvanR> Lowl3v3l: you cannot argue this point. 1. it is a *fact*. 2. if he was wrong someone would call him out on it
23:30:25 <Axman6> pretty sure I saw him introduce a bug though
23:30:28 <EvanR> QED
23:30:45 <EvanR> that is the world we live in
23:31:03 <EvanR> Xal: that popcnt optimization is done even on -O1
23:31:22 <EvanR> much less -O5 (O_o)
23:31:52 <Xal> I wonder what other mystery instructions x86 has to offer in its many extensions...
23:32:26 <nshepperd> Lowl3v3l: you don't have to comprehend every thing in the set to comprehend the set
23:32:47 <EvanR> on -O1 clang is solving the halting problem to determine that program is executing a popcnt
23:32:51 <Lowl3v3l> EvanR: i can and i do argue this point. firstly, physics can not PROVE anything. Secondly you can't prove ANYTHING about something that you do not comprehend. Thirdly : We do not even know how much stuff there is , so noone can claim a percentage on this anyway. I conclude that i don't believe a physicist claimed this, every physicist i met was to much of a logical person for such an incredibly flawed argument ;)
23:33:19 <Welkin> science is about disproving things
23:33:40 <EvanR> Lowl3v3l: i'm not sure if you would be surprised or not the number of things people tell me that some scientist stated in some silly book or on PBS
23:33:41 <Lowl3v3l> nshepperd yeah. But in order to claim "this set is the set of INCOMPREHENSIBLE!!!! things" you need to prove this proposition for every element in the set ;)
23:34:01 <EvanR> i pretty much believe they heard this
23:34:15 <nshepperd> Lowl3v3l: https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument
23:34:46 <Lowl3v3l> nshepperd: physics can not prove a thing. formal systems are something different from nature
23:34:53 <EvanR> popsci is 1. doesnt have to be science 2. people think its scientific
23:34:56 <nshepperd> meh
23:35:00 <[exa]> physics?
23:35:15 <EvanR> and its frightening
23:35:28 <nshepperd> who says they were using physics just because they were a physicist
23:35:28 <Xal> this line of discussion always leads to a misinterpretation of godel's incompleteness theorem...
23:36:11 <Lowl3v3l> Xal: yeah, i consider this a proven theorem in itself xD
23:36:11 <EvanR> once you misinterpret incompleteness theorems, you automatically win the argument and its over
23:36:24 <EvanR> its like hitler
23:36:42 <Welkin> adolf lincler?
23:36:42 <nshepperd> Lowl3v3l: nevertheless the fact that you can prove things about the set of real numbers without enumerating every real number should cause you to reevaluate your above claims
23:37:02 <Lowl3v3l> nshepperd :  nope. Since nature is not a formal system.
23:37:46 <nshepperd> not with that attitude
23:37:55 <CodeKiwi> Welkin one thing about the Acton video is that the clang compiler did a better job than msvc
23:37:57 <Axman6> Welkin: yeah that video is pretty bad
23:38:00 <dminuoso> Welkin: That's not entirely true. Although falsifiability is crucial for science, I think it's having decent models and predictions that are the basis of science.
23:38:12 <Axman6> CodeKiwi: isn't that usually true these days?
23:38:13 <dminuoso> The ability to say: "Well, if I apply this much force to this object, then this/that happens"
23:38:24 <CodeKiwi> probably
23:39:01 <CodeKiwi> a lot of the reason c or c++ is considered fast is just because of the amount of work put into the compilers
23:39:04 <Axman6> particularly when it comes to C, and MS seem to have been pretty slow adding all the C++0x and C++1y features last I was following this stuff
23:39:53 <dminuoso> CodeKiwi: The reality however is just that "C and C++" are fast if you are a developer that understands algorithms, your language, your compiler and your hardware.
23:40:08 <Xal> what I got from that video was that MS is bad at compilers
23:40:08 <EvanR> 1. microsoft replaces msvc with clang, 2. replaces windows kernel with linux kernel. 3. replaces shit gui with even worse open source desktop and sells it under the name Genuine Linux
23:40:12 <dminuoso> Remove one of those, and chances are C and C++ are not so fast..
23:40:22 <CodeKiwi> dminuoso pretty much sums up the acton video
23:40:50 <EvanR> (R)
23:40:50 <Xal> clearly the best course of action is to make a language that scares away the bad programmers
23:41:15 <dminuoso> CodeKiwi: Dont have the full backlog, which video is that?
23:41:18 <Lowl3v3l> Xal: just convince all good coders to use assembly or fortran! :D
23:41:20 <Welkin> not algorithms
23:41:25 <Xal> and there should be a "containment language" where the bad programmers write inconsequential things
23:41:25 <CodeKiwi> https://www.youtube.com/watch?v=rX0ItVEVjHc
23:41:27 <Welkin> understanding data is more important
23:41:46 <EvanR> how about instead (or at the same time) a decoy language which attracts bad programmers
23:41:53 <Xal> php
23:41:54 <Welkin> EvanR: you mean c++?
23:41:54 <EvanR> no names here
23:41:56 <dminuoso> EvanR: JavaScript?
23:41:56 <CodeKiwi> which one is haskell
23:41:56 <Welkin> :P
23:41:58 <EvanR> stahp
23:42:03 <CodeKiwi> is this the nerd sniping one
23:42:19 <Xal> no, we don't even have theorem proving
23:42:21 <Welkin> haskell?
23:42:28 <Welkin> no one programs in that
23:42:32 <Welkin> that's all academics
23:43:11 <CodeKiwi> I never finished school I guess that's why I haven't made anything in haskell :(
23:43:35 <Xal> as usual, the real humour is in the comment section:
23:43:35 * CodeKiwi too cool for school
23:43:37 <Xal> "...and that's why I keep writing macros instead of tiny helper functions"
23:43:50 <EvanR> o_O
23:44:02 <Welkin> well, if they are using lisp
23:44:10 <EvanR> they mean, to get inlining
23:44:42 <EvanR> you should also spell your variables as short as possible to avoid clogging up the tubes
23:44:48 <Lowl3v3l> :D
23:44:48 <Xal> `inline` everywhere in C is a really bad code smell
23:45:03 <dminuoso> Xal: Actually the vast majority of C and C++ developers dont understand inline.
23:45:17 <dminuoso> `inline` has actual influence on linkage.
23:45:25 <dminuoso> Which is why it's _actually_ used.
23:46:24 <Xal> isn't it just external linkage?
23:46:26 <dminuoso> No.
23:46:38 <dminuoso> Xal: For C refer to: https://stackoverflow.com/a/216546
23:48:47 <CodeKiwi> if it's not in K&R is it even real
23:49:14 <Xal> that's a really informative stackoverflow answer, thanks dminuoso
23:49:50 <fishythefish> CodeKiwi: it better be, or we're gonna have issues with braces
23:50:35 <Welkin> does anyone have a link to a guide on using alex and happy to make a simple language?
23:50:39 <CodeKiwi> leave my overbite alone
23:51:02 <Xal> Welkin: http://dev.stephendiehl.com/fun/index.html ?
23:51:06 <cocreature> Welkin: tbh for a simple language I’d go with megaparsec instead
23:51:44 <Xal> I don't think it covers Alex/Happy until after parser combinators though
23:51:51 <Welkin> I found this https://gnuu.org/2009/09/18/writing-your-own-toy-compiler/
23:52:02 <Welkin> but for flex and bison
23:52:12 <CodeKiwi> I too was told to avoid alex/happy
23:52:40 <dminuoso> Welkin: https://www.haskell.org/alex/doc/alex.pdf
23:52:41 <augustus> how to read ">>="
23:52:46 <dminuoso> augustus: "bind"
23:52:54 <EvanR> yacc / bison is great
23:53:05 <EvanR> it feels like the 80s
23:53:18 <EvanR> and you get a very fast parser
23:53:33 <CodeKiwi> https://youtu.be/b01Bnr1aXt8
23:53:35 <dminuoso> augustus: Or do you mean "what does (>>=) mean" ?
23:53:40 <[exa]> yacc feels like m4 on steroids sometimes
23:53:43 <Xal> it's read "bind"
23:54:01 <[exa]> need a feature? yeah create a macro that rewrites the output
23:54:11 <Xal> I just write my compilers in m4
23:54:13 <EvanR> >>= = "and then"
23:54:19 <Xal> eventually it just expands out to x86
23:54:27 <dminuoso> Im quite curious how GHC redoes the parse tree for fixity..
23:54:43 <CodeKiwi> EvanR that link was for you
23:55:32 <[exa]> dminuoso: a quite reasonable way is to read the expressions as lists, split on operators and solve that out of parsing. but I think happy supports something more brutal
23:56:34 <dminuoso> [exa]: From what I heard GHC blindly assumes some fixity, does its parse tree and then restructure that parse tree in a later pass when it has seen fixity declarations.
23:56:35 <CodeKiwi> dminuoso probably in the near 4000 line parser.y https://github.com/ghc/ghc/blob/master/compiler/parser/Parser.y
23:56:58 <augustus> thx, I just want to know the ">>=" symbol's name and I've get the answer here.
23:58:51 <[exa]> dminuoso: yeah that'd be similar (lists can be created by infixl everything). special syntax (if/lambdas) is parsed first afaik
23:59:50 <dminuoso> [exa]: Ah. Apparently it's the renamer that does this.
