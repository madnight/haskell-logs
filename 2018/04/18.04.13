00:00:22 <cocreature> especially if your goal is just documentation, prefixing record fields is not so bad
00:00:26 <frerich> Yeah, it's like a new word in a language and you go have to figure out what it means and what functions are applicable and such.
00:05:53 <DigitalKiwi> You know, almost every example in the history of ever deals with the concept of People and Animals. How many programs has anyone ever actually needed to do that? :|
00:06:20 <frerich> DigitalKiwi: Everytime you need to write an example! :-)
00:06:59 <DigitalKiwi> Aren't the old ones enough?! :P
00:08:04 <DigitalKiwi> https://github.com/bavardage/Kiloseconds Though now I think there should be something like this but for People and Animals instead of Kiloseconds
00:08:07 <frerich> I'm confident someone was desperate enough to write a paper doing a statistical analysis of the terms and topics used in example programs.
00:08:47 <EvanR> RIP hackage
00:08:58 <EvanR> long live haskell
00:09:16 <dminuoso> jle`: Ah that's an interesting way to look at it.
00:09:23 <DigitalKiwi> This is what we get for mocking the javascript people
00:10:02 <Reshi> Hey with conduit's `sourceFile`, the input file is read in chunks of `defaultChunkSize` (Data.ByteString). How can I wait until the whole file is read / combine the chunks. These are large json files which need to be parsed.
00:10:27 <jle`> Reshi: what do you mean by wait until the whole file is read?
00:13:46 <Reshi> jle`: not really wait, but combine the chunks into one ByteString. Aeson fails with `Error in $: not enough input` because I am piping: `sourceFile largeFile .| parse` and `parse :: ConduitM ByteString MyOutputType m ()`. It works fine if the input file is below 32K (defaultChunkSize)
00:15:10 <jle`> what library is giving parse?
00:15:19 <geekosaur> there's an adapter for that, isn't there?
00:16:17 <jle`> Reshi: where is 'parse' from?
00:16:26 <Reshi> jle`: Using aeson: `parse = mapC (either error id . eitherDecode)`
00:16:47 <jle`> oh yes that's your problem
00:17:06 <jle`> are you using this as a part of a larger stream, or is your final result the parsed thing?
00:17:42 <Reshi> jle`: I am then rendering that parsed thing into another JSON format and writing it to another file
00:18:19 <jle`> if that's the case then conduit doesn't really help you
00:18:30 <jle`> just read the file completely, parse the thing, convert it, write it
00:18:54 <Reshi> jle`: Oh, there are also multiple directories of these files
00:19:10 <jle`> right, but you're just using 'sourceFile largeFile' ?
00:19:38 <Reshi> jle`: I can use Conduit to go through these directories, but will not use sourceFile then. Just open the file and read it one by one
00:19:45 <Reshi> will that work?
00:19:49 <jle`> the point of conduit with filesystem IO is to control how and when you incrementally read from a file
00:20:05 <jle`> and you can operate on the chunks as they come and determinstically control when new reads happen
00:20:12 <jle`> in your case you want to just read the entire contents and process it
00:20:32 <jle`> that's sort of not really the point of conduit
00:20:45 <jle`> you might as well just use normal IO actions
00:21:25 <jle`> you might be able to hack this behavior together, but you're pretty much using the library for the opposite of the thing it was intended for :)
00:22:02 <jle`> if you use conduit to go through the directories then you can use iterM to do the read-and-write thing for each filepath it sees
00:22:48 <Reshi> jle`: thanks for clarifying this, I will try that :D
00:22:50 <jle`> iterM :: (a -> m ()) -> Conduit a a m (), you can throw this in your stream of filepaths if that's the route you decide to go to
00:23:09 <jle`> but yeah, if you're just going to read the entire file completely before doing anything, that's the opposite of the point of conduit, heh
00:27:27 <Myrl-saki> AHHHHH hackage is down ahhhhhh
00:27:42 <dminuoso> Use stackage.
00:27:53 <Myrl-saki> dminuoso: Nix uses hackage.
00:28:13 <dminuoso> Myrl-saki: Can you configure nix to use a different mirror?
00:28:13 <Myrl-saki> I didn't even know hackage had downtimes until now.
00:28:16 <Myrl-saki> Anyone got any info?
00:28:39 <Myrl-saki> dminuoso: I think so, but that'd require a full rebuild of the package set.
00:29:18 <dminuoso> Myrl-saki: https://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5acf0988f84e8204e95a4c47
00:29:42 <Myrl-saki> Woah
00:29:53 <Myrl-saki> It's been a day. Damn.
00:30:06 <Myrl-saki> dminuoso: Thanks.
00:31:21 <Myrl-saki> dminuoso: Will they provide more info once it's fixed?
00:31:29 <Myrl-saki> Just for curiosity reasons.
00:33:31 <Onaka> Any kind of ETA on getting hackage back up? Is this even the right place to ask?
00:33:40 <DigitalKiwi> There's a reddit post
00:33:51 <Onaka> Or alternatively can someone point me to an alternative repository?
00:33:55 <nshepperd> i'm lost without my hackage docs
00:34:03 <DigitalKiwi> https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
00:34:32 <Onaka> Thank you kindly.
00:34:55 <DigitalKiwi> It answers a lot of questions
00:36:40 <Myrl-saki> DigitalKiwi: Thanks!
00:37:07 <cocreature> Onaka: recent versions of cabal should automatically fall back to mirrors
00:37:31 <DigitalKiwi> It has been decided that gbaz1 is now to be called Admin Snafu
00:38:07 <Onaka> I was more looking for the documentation, but the reddit post answered that.
00:38:13 <Onaka> Even if I wasn't exactly clear.
00:41:05 <Myrl-saki> I just decided to compile Rust instead.
00:42:53 <DigitalKiwi> That's a bit extreme I'm sure hackage will be back before you can transition to Rust ;p
00:43:21 <Myrl-saki> DigitalKiwi: Lmao. :P
00:43:40 <Myrl-saki> DigitalKiwi: Nah, I want to make armv7l Nix packages for people who might need it.
00:44:06 <Myrl-saki> DigitalKiwi: That and make a .img of my RasPi which has everything I need TM.
00:47:12 <jle`> i wonder why ghc still recommends rank-2 types even though it is deprecated
00:49:06 <dminuoso> I love the last remark on prime.haskell.org/wiki/RankNTypes
00:49:10 <dminuoso> "The type system is arguably too complicated for Joe Programmer to understand, but that is true of many type systems, and perhaps it does not matter too much: in practice, Joe Programmer usually works by running the compiler repeatedly, treating the compiler as the specification of the type system. Indeed, a good deal of the complexity of the type system (especially Section 6) is there to accommodate
00:49:12 <dminuoso> programs that "ought" to work, according to our understanding of Joe's intuitions."
00:49:33 <cocreature> jle`: because you haven’t submitted a patch to change it ;)
00:50:13 <dminuoso> Myrl-saki: You can also donate your free CPU cycles to merijin. I hear he needs a lot these days rebuilding cabal 20 times a day.
00:50:40 <dminuoso> merijn even.
00:50:57 <Myrl-saki> dminuoso: Wtf. For what?
00:52:30 <adjofun> dminuoso: where can I download some CPU cycles? =:)
00:53:09 <dminuoso> adjofun: I hear Amazon EC2 has an unlimited supply.
00:53:11 <DigitalKiwi> on the sister site of downloadmoreram.com
00:58:56 <unclechu> hey guys, i'm seeing '503 connection timed out' error on the hackage for at least two days
00:59:04 <unclechu> is this known issue?
00:59:37 <bjobjo> https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
01:00:13 <bjobjo> you can try the mirrors listed in the OP
01:03:43 <frerich> I think what's really interesting is how computer people can be so toxic when other people write bad code and/or ask 'stupid' questions. But at the same time, they always seem to be really understanding and forgiving when someone admits a mishap when configuring a production system. :-)
01:06:13 <DigitalKiwi> oh he's definitely an idiot but we love him anyway ;)
01:09:23 <givemepointfree> @pl iterate (+ a) b
01:09:24 <lambdabot> iterate (a +) b
01:09:41 <adjofun> frerich: I guess that is because of nurtured sense of effectiveness, which is really close to someone feelings. For example, I facepalm at /r/CrappyDesign2/ almost at 1 Hz, because I can't imagine someone designing THOSE not as a joke
01:09:54 <givemepointfree> im going to kill myself
01:15:11 <akegalj> Maybe its already known problem, but seems hackage is down (I am getting 503).
01:15:48 <akegalj> aha, I see on reddit there is already an issue.
01:18:03 <DigitalKiwi> why that is not in the topic I don't know :(
01:18:07 <occulti> Hi all
01:18:16 <occulti> is hackage.haskell.org down?
01:18:21 <DigitalKiwi> https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
01:32:44 <merijn> No compilations running and I've got a GHC process taking up 15GB...that's not right
01:50:16 <cocreature> merijn: sounds like a ghci process that’s been running for a while :)
01:50:47 <merijn> cocreature: But how would it get that big, then?
01:51:18 <cocreature> merijn: ghci has a memory leak
01:51:25 <merijn> Because this entire machine has been idle for like 12 hours until now
01:51:36 <cocreature> https://ghc.haskell.org/trac/ghc/ticket/14336
01:58:02 <Boomerang> In template-haskell, how should I use the `bang` function? I would like to generate a pattern match with strict annotations, how should I go about it? :)
01:58:22 <henry18700> \part
02:01:03 <Boomerang> Oh it looks like there's a `bangP` function, I'll try that! :D
02:03:19 <cocreature> Boomerang: bang is for datatype declarations
02:04:01 <Boomerang> Right, `bangP` sounds like what I'm after. Do I need to make sure somehow that `BangPatterns` is enabled, or will TH do that for me?
02:04:44 <cocreature> iirc you need to enable it but just try it out :)
02:04:59 <jle`> Boomerang: it should just emit the syntax of a bang pattern
02:05:28 <jle`> so you still need BangPatterns to actually have that syntax interpreted as legal
02:06:10 <Boomerang> I am already emitting to level declarations with TH, would it be reasonable to also emit Language extensions pragmas?
02:06:24 <jle`> language extensions can only happen at the top of a file
02:06:26 <Boomerang> Or would you recommend I just add the extension manually at the call site?
02:07:09 <jle`> yeah, the extension needs to be enabled at the file that uses it
02:07:28 <jle`> s/at/for
02:07:59 <Boomerang> I see TH can check if an extension is enabled, it can't add more though, can it?
02:08:45 <jle`> as far as i know, yes; TH is limited to just returning haskell syntax
02:09:02 <jle`> so even if you returned a language pragma, it'd be a language pragma in the middle of the file
02:09:08 <ertes-w> helo
02:09:15 <jle`> helo
02:11:11 <Boomerang> jle`: Mmmh, since TH already has a function `addTopDecls`, it's clearly able to generate code outside of the slice it instantiated in. It seems like adding pragma isn't too far off :)
02:11:53 <jle`> oh hey, i didn't know about those, that's neat :)
02:12:25 <Boomerang> Yeah it's very neat! :D
02:12:41 <jle`> oh, that doesn't mean add at the top of the file
02:12:49 <jle`> i think it just means add as a top-level declaration
02:13:10 <Boomerang> Yes, that's what I understood too, it's so close in functionality though...
02:14:17 <jle`> i feel like adding a top level declaration vs. a language pragma at the top of the file are pretty different
02:14:47 <jle`> hm
02:14:53 <jle`> but i see what you mean about jumping out of the splice
02:15:38 <Boomerang> You're probably right. The extensions is most likely a different compile stage (since that's where TemplateHaskell is enabled in the first place)
02:16:01 <Boomerang> No worries, I'll just have to enable BangPatterns manually then! :)
02:16:16 <Boomerang> Thanks for your help!
02:17:14 <jle`> no problem!
02:20:18 <Boomerang> For some reason it's seems to be working without the pragma declaration!!! I'll have to test that some more to make sure that's actually the case
02:30:00 <Taneb> Boomerang: what does -ddump-splices emit
02:31:32 <Boomerang> Taneb: It emits the bangs, but no compile issue. I have tried adding a test function: `test :: () -> (); test !_ = ()` and that one fails to compile. So somehow the template-haskell generated bangs are not interpreted the same way as handwritten ones
02:57:09 <Taneb> Boomerang: that feels like a (relatively harmless) bug
02:57:46 <Boomerang> Maybe it's intended. You want never want to use `BangP` (or others) without the extension enabled
02:58:00 <Boomerang> *would never want
03:08:44 <Boomerang> Taneb: I have just checked by printing all the enabled extensions in TH before and after my top level declaration using bang patterns. Neither list contains BangPatterns, so it's pretty much much magic that this works as far as I'm concerned :p
03:19:24 <Taneb> Boomerang: it definitely feels odd to have code that works differently if you run the TH first with -ddump-splices
03:40:00 <tulipar> I have a question about free structures.  As far as I understood it a normal way to define it is to have a data structure capturing the operations and an homomorphism that "translates" it
03:40:40 <tulipar> Is it correct to say that the homomorphism (interpreter function) applied to the datastructure always has to satisfy the laws of the typeclass?
03:43:45 <kqr> how is hackage these days? I'm not actively involved with haskell at the moment, but specifically today I have needed it a few times and it's been down all day :(
03:44:05 <merijn> kqr: Still recovering from human error yesterday
03:44:18 <merijn> kqr: If you have a recent cabal-install it should fail-over to one of the mirrors
03:44:23 <zincy> When using Aeson to encode a type to JSON how do I ensure the end result is wrapped in quotes. The aim is to send this JSON over a websocket. However the client is receiving an object in the message bytestream as opposed to a stringified json.
03:45:22 <kqr> merijn, ah. i'm mostly visiting it from the browser. i think i'm downloading packages from stackage heh
03:45:42 <merijn> kqr: Use the stackage docs for now until the machine is restored fully
03:45:52 <liste> zincy: is it about the whole message or just one part?
03:46:04 <zincy> Whole message
03:46:21 <liste> zincy: why is the client receiving the message as an object bad? sounds like the client library is doing the deserialization implicitly
03:46:39 <chisui_> Is there a way to have hlint run as part of a cabal build?
03:47:25 <zincy> Yeah that would make sense. I am using Miso as the front end framework (GHCJS). When it receives the object it throws an error when trying to parse it
03:47:57 <liste> zincy: what error?
03:47:57 <zincy> rts.js:8904 uncaught exception in Haskell thread: SyntaxError: Unexpected token n in JSON at position 1 rts.js:8904 SyntaxError: Unexpected token n in JSON at position 1     at JSON.parse (<anonymous>)     at h$$abb (out.js:53050)     at h$runThreadSlice (rts.js:9928)     at h$runThreadSliceCatch (rts.js:9880)     at h$mainLoop (rts.js:9875)     at rts.js:3690     at runIfPresent (rts.js:3708)     at onGlobalMessage (rts.js:3749) rts.j
03:48:20 <liste> zincy: what does the json look like?
03:48:38 <zincy> {"name":"bob"}
03:49:00 <liste> just that? in the http traffic?
03:49:14 <liste> that looks like valid http
03:49:20 <liste> valid json*
03:49:23 <zincy> Yeah but when its wrapped in quotes there are no issues
03:49:41 <liste> so something outputs {name:"bob"}?`
03:49:46 <liste> that's not json at all
03:49:56 <zincy> Yeah
03:50:02 <liste> and aeson should never output that
03:50:16 <lemmih> zincy: Looks like someone is sending you a JS object.
03:50:32 <zincy> Someone?
03:50:53 <lemmih> Who sends you {name:"bob"}?
03:50:59 <zincy> Me
03:51:16 <zincy> I am developing the client and server locally
03:51:23 <lemmih> zincy: Well, don't. That's not valid JSON.
03:51:26 <liste> hmm, if aeson really outputs that, it's a bug in aeson
03:52:34 <osa1> zincy: show us the code
03:53:06 <zincy> sure
03:55:07 <zincy> server - http://lpaste.net/364748
03:55:18 <zincy> client - http://lpaste.net/2611453322715987968
03:56:31 <reactormonk> Is it possible to execute TH statements in ghci?
03:56:44 <reactormonk> I usually get reify errors.
03:57:17 <lemmih> zincy: Can you show us where you create {name:"bob"}?
03:57:19 <osa1> which hackage mirror to browse documentation?
03:57:46 <DigitalKiwi> Apparently everyone clicked those lpaste at once because I got a 503 the first time on one of them heh
03:58:03 <DigitalKiwi> osa1 stackage.org
03:58:16 <osa1> ty
03:58:30 <DigitalKiwi> np
03:58:34 <zincy> Hackage is down right? Not sure what to give you
03:59:27 <lemmih> zincy: Can you tell us anything about how you create {name:"bob"}?
03:59:36 <zincy> Sure
03:59:52 <lemmih> zincy: Did you write it by hand or did you use a library?
03:59:59 <zincy> So the name bob comes from the first msg sent on the client dside
04:00:03 <osa1> zincy: the aseon code you use: `object [ "name" .= ... ]` won't generate invalid json like that
04:00:18 <zincy> this first msg is parsed by the server and results in a client name
04:00:37 <lemmih> zincy: But how did you create the string '{name:"bob"}' ?
04:00:46 <zincy> this name and ws connection form a client value and are added to the list of clients
04:01:10 <zincy> the server then attempts to encode the client that has just connected to json and send it back to the client
04:01:33 <zincy> it should be a valid json of key name where the value is the clients name
04:01:35 <lemmih> zincy: All of that stuff doesn't really matter. What matters is how you got '{name:"bob"}'.
04:01:54 <lemmih> It's not valid JSON so you didn't use aeson to create it.
04:02:12 <zincy> Line 150
04:02:24 <kqr> merijn, thanks!
04:02:55 <zincy> Uses the client value to try  to encoe the json
04:02:58 <lemmih> zincy: Line 150 is a comment.
04:03:04 <zincy> line 141 prints the result to stdout
04:03:20 <zincy> Are you looking at the server side code
04:03:40 <chisui_> Can someone point me to good resources about setting up productive haskell development environments with Nix and Vim?
04:04:19 <lemmih> zincy: I'm looking at the code you pasted for the server.
04:05:00 <zincy> line 148 sorry
04:05:15 <zincy> encodes
04:05:29 <zincy> and then 139 prints to stdout
04:07:33 <lemmih> zincy: And that prints '{name:"bob"}' to the screen?
04:09:32 <zincy> Yes line 139 prints {"name": "Bob"} to the screen
04:09:51 <lemmih> zincy: Aha! {"name": "Bob"} is /very/ different from {name: "Bob"}.
04:10:34 <lemmih> zincy: {name: "Bob"} is wrong but {"name": "Bob"} is correct.
04:11:21 <zincy> So do you think the issue is solely related to the client side
04:11:24 <lemmih> zincy: So where does {name: "Bob"} come from? Or did that never exists in the first place?
04:11:43 <zincy> Thats the name of the client which is connected
04:11:55 <zincy> the name is parsed from the first msg they send
04:12:09 <lemmih> zincy: Do you see the difference between {name: "Bob"} and {"name": "Bob"} ?
04:12:27 <zincy> Yes
04:12:32 <zipnoob> One is JSON :P
04:12:45 <zincy> Sorry for the confusion I didn't type it out properly :/
04:12:46 <lemmih> zincy: The first version is causing you problems. We're trying to figure out where it comes from.
04:12:56 <zincy> ooh
04:13:05 <zincy> Its always been the second version
04:13:07 <lemmih> zincy: We're trying to find the code that generates {name: "Bob"}. That code is wrong and needs to be fixed.
04:13:28 <lemmih> zincy: Ah! Then there should be no problem.
04:13:32 <zincy> Sorry thats my terrible typing
04:14:31 <lemmih> zincy: Is there still a problem?
04:14:44 <zincy> The issue is that on the client I can't print the json to stdout
04:15:00 <lemmih> Why can't you?
04:15:37 <lemmih> (I'm assuming stdout on the client means something like console.log)
04:15:45 <zincy> As soon as the message is received on the client I get
04:15:45 <zincy> uncaught exception in Haskell thread: SyntaxError: Unexpected token n in JSON at position 1 rts.js:8904 SyntaxError: Unexpected token n in JSON at position 1     at JSON.parse (<anonymous>)     at h$$abp (out.js:53152)     at h$runThreadSlice (rts.js:9928)     at h$runThreadSliceCatch (rts.js:9880)     at h$mainLoop (rts.js:9875)     at rts.js:3690     at runIfPresent (rts.js:3708)     at onGlobalMessage (rts.js:3749) rts.js:9031 when 
04:16:11 <lemmih> zincy: And what input caused that error? What does the JSON look like?
04:16:43 <zincy> Its the {"name": "Bob"} json from the server which throws that err on the client
04:17:10 <lemmih> zincy: I don't think that is so. Could you print out the string before you parse it as JSON?
04:18:33 <zincy> Print out the string on the server?
04:19:11 <lemmih> zincy: No, in the client. Also, which datatype should '{"name": "Bob"}' be parsed as in the client?
04:19:52 <zincy> At the moment I am just trying to parse it as a Message which is a synonym for MisoString which is a synonym for String
04:20:02 <dminuoso> Mmm. How comes Haskell does not specify the exact encoding? As far as I can tell the report specifies "Unicode" rather than a specific unicode encoding..
04:20:03 <lemmih> zincy: Well that definitely won't work.
04:20:26 <merijn> dminuoso: Future-proofness I guess
04:20:28 <zincy> However it isnt the decoding I dont think that is causing this err
04:20:38 <merijn> dminuoso: What if the whole world switches what encoding they like to use
04:20:48 <lemmih> zincy: {"name": "Bob"} can't be decoded as a string.
04:23:52 <lemmih> zincy: If your client expects a string, just send it a string.
04:24:37 <zincy> Updated the client pastebin
04:24:58 <zincy> Added another call to print the message to line 61
04:25:23 <zincy> Still doesn't print the json , just throws that error I posted
04:25:45 <zincy> So would wrapping the json in quotes be enough?
04:25:47 <pavonia> dminuoso: Unicode encoding of what?
04:26:55 <merijn> pavonia: I'm assuming source files
04:26:58 <lemmih> zincy: Don't do it manually. Aeson can encode strings to JSON.
04:27:26 <pavonia> Ah
04:28:47 <chindy> Is hackage currently not available for anyone else?
04:29:02 <eelis_> chindy: down since yesterday: http://auto-status.haskell.org/
04:29:49 <chindy> so it is down, i see
04:30:59 <zincy> lemmih - Is the issue that line 39 on the server code calls object and not string?
04:33:27 <zincy> Oh that worked!
04:34:03 <zincy> I just changed line 39 to toJSON (Client (Name, _)) = toJSON name
04:34:11 <matsurago> hi, what is the recommended test suite for Haskell ?
04:34:32 <zincy> When I did the call to object manually it didn't result in a string
04:34:43 <zincy> I think that was the root of the problem right?
04:37:37 <reactormonk> Is there something like zipper for aeson? Looking to mess around with Value
04:41:17 <zincy> lemmih - Thanks for your help. I am extremely grateful!
04:41:46 <lyxia> matsurago: hspec or tasty
04:43:56 <matsurago> lyxia: thanks!
04:47:13 * hackage primitive-checked 0.6.3.0 - primitive functions with bounds-checking  http://hackage.haskell.org/package/primitive-checked-0.6.3.0 (andrewthad)
04:47:16 * hackage buildbox 2.1.11.1, buildbox 2.1.10.1, inchworm 1.0.2.2, buildbox 2.1.9.4 (BenLippmeier): https://qbin.io/idle-prague
04:47:19 * hackage hpath 0.9.2, hpath 0.9.1 (maerwald): https://qbin.io/secure-hence
04:47:21 * hackage influxdb 1.5.2 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-1.5.2 (MitsutoshiAoe)
04:47:23 * hackage beam-sqlite 0.3.2.0, beam-migrate 0.3.1.0, beam-core 0.7.2.0 (TravisAthougies): https://qbin.io/beef-malawi
04:47:26 * hackage bronyradiogermany-streaming 1.0.0.1, bronyradiogermany-common 1.0.0.1, bronyradiogermany-streaming 1.0.0.0, bronyradiogermany-common 1.0.0.0 (implementation): https://qbin.io/su-sb
04:47:27 * hackage plural 0.0.2 - Pluralize  http://hackage.haskell.org/package/plural-0.0.2 (fresheyeball)
04:47:30 * hackage sparrow 0.0.1.4, wai-middleware-content-type 0.6.1.2, markup 4.2.0, urlpath 9.0.0, path-extra 0.2.0, markup 4.1.0, urlpath 8.2.0 (athanclark)
04:47:31 * hackage heap 1.0.4 - Heaps in Haskell  http://hackage.haskell.org/package/heap-1.0.4 (eberlm)
04:47:33 * hackage gmpint 0.1.0.9, tweet-hs 1.0.1.37, gmpint 0.1.0.8, pointfree-fancy 1.1.1.6 (vmchale)
04:47:35 * hackage xmlbf 0.4 - XML back and forth! Parser, renderer, ToXml, FromXml, fixpoints.  http://hackage.haskell.org/package/xmlbf-0.4 (RenzoCarbonara)
04:47:37 * hackage b9 0.5.44 - A tool and library for building virtual machine images.  http://hackage.haskell.org/package/b9-0.5.44 (SvenHeyll)
04:47:40 * hackage servant-xml 1.0.1.2 - Servant support for the XML Content-Type  http://hackage.haskell.org/package/servant-xml-1.0.1.2 (fosskers)
04:47:41 * hackage servant-tracing 0.1.0.1 -   http://hackage.haskell.org/package/servant-tracing-0.1.0.1 (ChrisCoffey)
04:47:43 * hackage rattletrap 4.0.8 - Parse and generate Rocket League replays.  http://hackage.haskell.org/package/rattletrap-4.0.8 (fozworth)
04:47:46 * hackage monadcryptorandom 0.7.2.1 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.7.2.1 (ThomasDuBuisson)
04:47:48 * hackage eternity-timestamped 0.3 - Automatic timestamping for Eternity  http://hackage.haskell.org/package/eternity-timestamped-0.3 (OShev)
04:47:50 * hackage hapistrano 0.3.5.4 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.3.5.4 (juanpaucar)
04:47:51 <adjofun> is this now a hackage channel? =:)
04:47:53 * hackage monad-logger 0.3.28.4, rio 0.1.1.0 (MichaelSnoyman): https://qbin.io/oven-horny
04:47:56 * hackage OddWord 1.0.2.0 - Provides a wrapper for deriving word types with fewer bits.  http://hackage.haskell.org/package/OddWord-1.0.2.0 (RobinKay)
04:47:58 * hackage product-isomorphic 0.0.3.2 - Weaken applicative functor on products  http://hackage.haskell.org/package/product-isomorphic-0.0.3.2 (KeiHibino)
04:48:01 * hackage saltine 0.1.0.1 - Cryptography that's easy to digest (NaCl/libsodium bindings).  http://hackage.haskell.org/package/saltine-0.1.0.1 (amx)
04:48:11 <merijn> @where ops
04:48:11 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
04:48:21 <merijn> Maybe kick hackage until it's a bit more stable and quiet?
04:48:34 <yogsototh[m]> apparently :)
04:49:34 <caryoscelus> apparently hackage wants to tell us that it's in different state of being down than before
04:50:15 <quicksilver> hmm
04:50:21 <quicksilver> well let's give it a moment
04:50:23 <quicksilver> I could just quiet it
04:50:31 <quicksilver> but perhaps it's finished its splurge
04:51:00 <quicksilver> since I've been summoned to the channel, has anyone used any of the haskell neural network libraries?
04:52:20 <frerich> https://hackage.haskell.org/package/containers works again :-)
04:55:36 <statusbot> Status update: Hackage has been successfully restored and is operational again. In case you notice any remaining issues please let us know. More information will be published on http://blog.hackage.haskell.org soon.  Thank you for your patience. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5acf0988f84e8204e95a4c47
04:55:55 <brynedwards> Woo
04:59:54 <frerich> The last two time stamps on https://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5acf0988f84e8204e95a4c47 are confusing - isn't 12:25AM _later_ than 11:55AM or is this some funny AM/PM quirk I'm missing?
05:00:56 <hpc> frerich: https://hackage.haskell.org/package/tardis
05:01:15 <merijn> frerich: According to email I've seen the restore was (mostly?) finished last night
05:01:40 <merijn> frerich: However, people involved were tired and didn't wanna flick the switch carelessly and break things *again*
05:01:42 <frerich> Ah, so 12:25AM is late at night (like, 0:25h)!
05:01:55 <merijn> frerich: tbh, I dunno which is which
05:01:59 <merijn> I don't get AM/PM
05:02:27 <hpc> no, that's right
05:02:38 <hpc> ugh, i forgot that 12:01 AM is earlier than 11:01 AM
05:02:58 <hpc> AM starts just after midnight, but you don't roll over to 1:00 for another hour
05:03:01 <merijn> See, that's why every sensible country uses 24h clocks
05:03:59 <hpc> yeah
05:04:36 <matsurago> Hspec looks like a really clean framework
05:05:26 <merijn> matsurago: tbh, I dislike the pseudo english DSL it uses, but YMMV
05:06:28 <hpc> should be fine as long as you only do things the "grammar" expects
05:07:23 <hpc> i agree that tests should look like code though
05:13:39 * hackage ini 0.3.6 - Quick and easy configuration files in the INI format.  http://hackage.haskell.org/package/ini-0.3.6 (ChrisDone)
05:23:58 <ertes-w> hspec is the one where you write inline tests, isn't it?
05:24:00 <dminuoso> hpc: Rubyists have unlearned the ability to write code. "Is there some DSL trick to reverse an array?"
05:24:40 <dminuoso> Though the actual tests are code. HSpec just adds some DSL sugar to structure them
05:24:40 <DigitalKiwi> merijn it's pretty simple https://www.timeanddate.com/time/am-and-pm.html
05:24:57 <merijn> ertes-w: hspec is the one with the pseudo-english DSL
05:25:28 <ertes-w> merijn: is that all it offers?
05:25:29 <merijn> DigitalKiwi: I know it's simple, but I never encounter am/pm in daily life so I still have to think and remember the 12:00 nonsense
05:25:42 <merijn> ertes-w: Seems pretty much similar to tasty otherwise, yes
05:26:05 <ertes-w> ok, then i'll stick with tasty =)
05:26:49 <ertes-w> when i think of pseudo-english DSLs i think of COBOL
05:27:26 <merijn> ertes-w: Well, check the first few examples and see for yourself: https://hspec.github.io/
05:27:40 <DigitalKiwi> merijn oh, well I'm just a dumb american that has to use all of the systems :P
05:27:49 <ertes-w> that's disgusting
05:27:57 <merijn> ertes-w: Exactly :)
05:28:30 <dminuoso> ertes-w: What do you use? hunit?
05:28:38 <ertes-w> dminuoso: tasty + QuickCheck most of the time
05:28:39 <dminuoso> Handwritten?
05:28:40 <merijn> dminuoso: tasty, he just said :)
05:28:49 <merijn> dminuoso: tasty wraps hunit
05:28:58 <merijn> (as does hspec, I think?)
05:29:04 <dminuoso> Ah never heard of tasty, got it.
05:29:09 <ertes-w> i migrated to tasty from test-framework, and to QuickCheck from smallcheck
05:29:23 <ertes-w> i still think smallcheck is superior though
05:29:36 <merijn> ertes-w: Bonus: If you use tasty and Travis I wrote a small library to get fancy output on Travis ;)
05:29:51 <ertes-w> merijn: nice…  i gotta set up travis one of these days
05:30:13 <merijn> ertes-w: hvr's multi-ghc-travis does that basically automatically for you
05:30:15 <ertes-w> it's just that i don't really need it myself, and i'm not receiving lots of contributions
05:31:08 <ertes-w> merijn: thanks…  maybe i'll just sit down and do it during my holidays
05:31:12 <merijn> ertes-w: As long as your cabal files work you just gotta added tested-with for relevant GHC versions and it takes care of everything for you
05:31:15 <merijn> ertes-w: https://github.com/haskell-ci/haskell-ci
05:31:22 <ertes-w> ah, nice
05:31:22 <isovector> is there a way to debug inferred roles? i am trying to mark a role as phantom but GHC says it must be nominal :/
05:31:33 <merijn> ertes-w: Takes care of: testing multiple GHC versions, caching, etc.
05:32:14 <merijn> ertes-w: And https://hackage.haskell.org/package/tasty-travis-0.2.0.1/docs/Test-Tasty-Travis.html
05:32:16 <reactormonk> Fun with lenses... [D] where D has a lens for `foo`. How do I access that? [d] ^.. foo gives me an error
05:32:20 <ertes-w> merijn: i'll probably adapt it slightly to use nix…  i believe you explained the basic idea of travis being basically a VM in the past
05:32:53 <ertes-w> reactormonk: is [d] the singleton list of 'd'?
05:33:06 <reactormonk> ertes-w, no, just an illustration
05:33:13 <reactormonk> The real case got about 100 elements
05:33:19 <ertes-w> reactormonk: but it's a list?
05:33:23 <reactormonk> Yep
05:33:35 <ertes-w> reactormonk: then:
05:33:37 <reactormonk> think map (\d -> d ^. foo) [d]
05:33:43 <ertes-w> :t traverse :: Traversal [a] [b] a b
05:33:45 <lambdabot> Applicative f => (a -> f b) -> [a] -> f [b]
05:34:29 <ertes-w> > (traverse . _2 %~ toUpper) (zip [1,2,3] "abc")
05:34:32 <lambdabot>  [(1,'A'),(2,'B'),(3,'C')]
05:35:04 <ertes-w> > zip [1,2,3] "abc" ^.. traverse . _2
05:35:06 <lambdabot>  "abc"
05:35:22 * dminuoso smiles as "english looking DSL" was replaced with "alien looking lens-DSL"
05:35:52 <ertes-w> heh…  lenses kinda are an alien concept with vague similarities to familiar things =)
05:36:38 <[exa]> ...with vague similarities to weird utf8 characters.
05:36:59 <ertes-w> > (partsOf (traverse . filtered isUpper) %~ reverse) "Sony Playstation"
05:37:02 <lambdabot>  "Pony Slaystation"
05:37:04 <ertes-w> my favourite =)
05:37:26 <dminuoso> [exa]: It's just the approximation of the written alien language.
05:37:45 <Psybur> Is someone taking an IQ test? heh
05:38:01 * DigitalKiwi failed
05:38:11 <[exa]> dminuoso: i want to believe aliens speak in lenses
05:38:19 <Psybur> Decipher this alien language given this translated phrase!
05:38:23 * frerich giggles over 'Pony Slaystation'
05:38:46 <reactormonk> IQ test? I've got 90 of a 100, that's good, right?
05:39:22 <dminuoso> Your IQ test is positive? Im sure there's medication for that.
05:39:26 <ertes-w> aliens encrypt with prime numbers, play go and program in lambda calculus…  as for their natural language, it's probably quantum homotopy type theory
05:39:53 <dminuoso> Is quantum homotopy type theory a thing?
05:39:54 <Psybur> coquantum cohomotopy
05:40:20 <matsurago> I don't know about tasty, but HSpec gives some cool Green/Red feedback with numbers how many tests succeeded/failed, and also how come they failed, like Expected: 8 but was 7
05:41:14 <dminuoso> matsurago: Pretty sure you get that last from all the frameworks.
05:42:57 <DigitalKiwi> plot twist: we're all green/red color blind
05:43:36 <merijn> matsurago: So does tasty, though
05:43:39 * hackage buildbox 2.2.1.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.2.1.1 (BenLippmeier)
05:43:55 <DigitalKiwi> sigh already I miss the time hackage was down
05:48:14 <ertes-w> matsurago: if you like it, stick with it…  hspec is popular from what i can tell
05:48:30 <ertes-w> tasty uses a much more concise and symbolic DSL
05:48:35 <ertes-w> that's what i prefer
05:49:09 * hackage wl-pprint-text 1.1.1.1 - A Wadler/Leijen Pretty Printer for Text values  http://hackage.haskell.org/package/wl-pprint-text-1.1.1.1 (IvanMiljenovic)
05:49:59 <matsurago> ertes-w: I like the fact I was able to use HSpec in just 10 minutes having no previous experience with testing frameworks in Haskell
05:53:09 * hackage shimmer 0.1.3.2 - The Reflective Lambda Machine  http://hackage.haskell.org/package/shimmer-0.1.3.2 (BenLippmeier)
05:58:39 * hackage tdigest 0.2 - On-line accumulation of rank-based statistics  http://hackage.haskell.org/package/tdigest-0.2 (phadej)
06:00:10 * hackage tdigest-Chart 0.2 - Chart generation from tdigest  http://hackage.haskell.org/package/tdigest-Chart-0.2 (phadej)
06:05:19 <nkaretnikov> in c, some algorithms modify data using pointers. how do i model this in haskell _as close as possible_? if i have void f(char *s, int len), what would be the haskell version of this? even if i'm using iorefs and such, i need to provide the result, but how do i ensure that no copying takes place? e.g., f :: IO (IORef [a]) -> Int -> ???
06:05:55 <merijn> nkaretnikov: Well, you can modify pointers in Haskell? :)
06:06:16 <nkaretnikov> merijn: not sure what you mean
06:06:21 <merijn> nkaretnikov: I assume you wanna do some sorta vector/array style operations?
06:06:37 <nkaretnikov> merijn: yes, i'm implementing insertionsort using iorefs
06:06:41 <nkaretnikov> merijn: well, trying to implement
06:06:42 <merijn> nkaretnikov: the FFI has an interface for pointers and using them, but you probably just want arrays/vectors with mutation?
06:06:59 <nkaretnikov> merijn: yeah, i'd rather not go into ffi
06:07:01 <merijn> nkaretnikov: IORef is the wrong way to go here. You probably wanna have a look at the vector package
06:07:05 <merijn> @hackage vector
06:07:05 <lambdabot> http://hackage.haskell.org/package/vector
06:07:09 <ertes-w> nkaretnikov: typically the haskell version would look like this:  Int -> Text -> Text
06:07:12 <merijn> nkaretnikov: There's mutable vector types in there
06:07:30 <ertes-w> nkaretnikov: if you really want to use the C paradigm, then what merijn said
06:07:33 <nkaretnikov> merijn: but they probably use c under the hood somewhere, right?
06:07:41 <ertes-w> IORef/Vector/TVar/…
06:07:50 <nkaretnikov> ertes-w: yeah, it's just an educational exercise
06:07:51 <merijn> nkaretnikov: No
06:08:12 <nkaretnikov> merijn: how is in-place modification done, then?
06:08:38 <nkaretnikov> merijn: i mean, that the whole point of this. basically, i want to have my own vector here, so i can see what's going on.
06:08:47 <nkaretnikov> merijn: like with as little code as possible
06:09:17 <merijn> nkaretnikov: GHC has support for allocating pointers and mutating them, I'm pretty sure it's just built on top of that
06:09:44 <nkaretnikov> merijn: haven't heard of this, could you point me to the relevant section of the manual?
06:10:23 <cemerick_> so hackage is back, but some docs that were there previously now aren't
06:10:26 <merijn> nkaretnikov: Well, there's the "dark magic & voodoo" module, which exposes all sorts of internals/primitives supported by GHC
06:10:44 <merijn> cemerick_: Yes, not all modifications have been restored, afaik
06:10:46 <nkaretnikov> merijn: does it  have a name? :)
06:10:49 <merijn> nkaretnikov: https://hackage.haskell.org/package/ghc-prim-0.5.1.1/docs/GHC-Prim.html
06:10:55 <nkaretnikov> merijn: ah, the prim one
06:11:04 <merijn> nkaretnikov: GHC.Prim for all your foot mutilating needs ;)
06:11:05 <Iceland_jack> <jle`> Iceland_jack: in what way is it a generalization of GND ?
06:11:05 <Iceland_jack> jle`: If you derive via the underlying representation of the newtype, you get the same as GND
06:11:10 * hackage massiv 0.1.6.0 - Massiv (Массив) is an Array Library.  http://hackage.haskell.org/package/massiv-0.1.6.0 (lehins)
06:11:21 <cemerick_> merijn: ok; bizarre then that the status page is all green
06:11:38 <Iceland_jack>     newtype Age = A Int deriving newtype Num
06:11:39 <Iceland_jack> becomes
06:11:39 <Iceland_jack>     newtype Age = A Int deriving Num via Int
06:11:43 <ertes-w> nkaretnikov: basically there are two kinds of pointers in haskell:  bare ones (Ptr), and RTS-aware ones (ForeignPtr)
06:12:00 <ertes-w> nkaretnikov: only Ptr is really faithful to the C paradigm:  you allocate and then you free
06:12:09 <nkaretnikov> ertes-w: sorry, what's the difference? i've used ffi maybe two times and that was years ago
06:12:36 <ertes-w> nkaretnikov: despite its name ForeignPtr has nothing to do with the FFI…  it's basically just a garbage-collected pointer
06:12:48 <ertes-w> a pointer with finalisers
06:13:10 <ertes-w> typically in haskell you allocate a ForeignPtr and leave freeing it to GC
06:13:13 <nkaretnikov> merijn: and how do i get the benefits of the haskell type system if i use prim? or do i just hide it behind a sane interface and that;s it?
06:13:40 <nkaretnikov> ertes-w: so it's sort of similar to a smart pointer in cpp?
06:13:41 <merijn> nkaretnikov: Well, you lose a bit of type benefits when using it, yes
06:13:58 <merijn> nkaretnikov: Yes, ForeignPtr is similar to std::shared_ptr
06:14:02 <ertes-w> nkaretnikov: you should keep one thing in mind: you can't do C entirely in haskell, because IO has something called async exceptions…  in C this is safe:  ptr = malloc(…); free(ptr
06:14:19 <ertes-w> but in haskell this can lead to a memory leak, if between those actions an async exception is thrown
06:14:38 <Taneb> Iceland_jack: your twitter is both fun to read and frightening
06:14:40 <ertes-w> therefore you have to use one of the CPS-style variants or learn how to do exception-masking properly
06:14:49 <nkaretnikov> merijn: https://hackage.haskell.org/package/ghc-prim-0.5.1.1/docs/src/GHC.Prim.html#byteSwap%23 so is it actually an in-place byte swap?
06:14:57 <merijn> nkaretnikov: Or you use libraries like vector which hide the problems behind a convenient interface :)
06:15:15 <ertes-w> nkaretnikov: for dealing with arrays i strongly recommend that you just use the vector library
06:15:28 <nkaretnikov> :)
06:15:28 <ertes-w> those vectors are GCed, but that's really something you'd want in haskell
06:15:32 <merijn> nkaretnikov: Pretty sure that one runs on a register
06:15:43 <Iceland_jack> Taneb: Thanks!
06:15:43 <Iceland_jack>   I guess . .
06:15:48 <ertes-w> otherwise you'll have to deal with all those haskell-specific caveats of doing explicit deallocation
06:15:54 <Taneb> (meant it as a compliment, don't worry)
06:15:59 <Iceland_jack> :)
06:16:01 <merijn> ertes-w: Sure, but doing all the dirty things yourself is educational
06:16:10 <merijn> ertes-w: As long as you realise you're doing it for education
06:16:10 <ertes-w> yeah, true
06:16:26 <ertes-w> nkaretnikov: then first step: read the Control.Exception module carefully
06:16:44 <ertes-w> especially the stuff about async exceptions and masking
06:17:06 <ertes-w> after that you will find everything you need in Foreign.Marshal and Foreign.Storable
06:17:48 <Ulrar> Hi, just in case, anyone knows of a lib to create iso files ? (cd9660)
06:18:07 <Ulrar> Ideally without any interaction with the filesystem
06:19:44 <quicksilver> well https://hackage.haskell.org/package/b9 can do it but no idea if it can do it straight to memory without FS
06:21:24 <quicksilver> no it doesn't, it just uses genisoimage
06:21:43 <Ulrar> As I understand it, it needs LXC anyway
06:22:32 <Ulrar> I'm hoping to build a unikernel through rumprun (since halvm doesn't support anything else than Xen), so I wouldn't have any fs or lxc support
06:24:14 <ertes-w> Ulrar: do you need an actual VM?  i generally run haskell programs as linux containers
06:24:33 <ertes-w> (with s6-svscan as PID 1)
06:24:34 <Ulrar> Yeah, I'm not using container, that's exactly what I'm trying to avoid
06:24:52 <Ulrar> But worse case I can just have the iso generation somewhere else
06:26:00 <Ulrar> maybe the helper I'll have on the hypervisor can take the files through it's api and generate an iso before starting the VM, that doesn't sound too crazy
06:27:20 <nkaretnikov> merijn: and which il should i dump (stg, core) in order to see that modifications are done in place? or should i go straight to asm for that?
06:27:41 <merijn> tbh I never really look at stg or core that often
06:28:34 <nkaretnikov> asm is an easy answer, but i expect there'll be a lot of it, so i'd rather not go there
06:28:52 <ertes-w> nkaretnikov: if you use Storable operations or suitable primitives, you can pretty much just trust that it's done in-place
06:29:16 <nkaretnikov> ertes-w: no-no-no :) "trust, but verify"
06:29:30 <ertes-w> nkaretnikov: neither core nor STG will reveal it…  you need to get down to the C-- level to really see it
06:29:45 <nkaretnikov> oh, i forgot that c-- exists
06:30:03 <ertes-w> even STG is still a functional language
06:30:32 <ertes-w> C-- is the highest level where you can see actual stack/heap operations
06:31:39 <nkaretnikov> also, a related question: assuming my program just uses ghc.prim and just does sorting of ints (the primitive ones), and i use the pinned versions of arrays, does it mean i don't need to worry about ghc pauses?
06:31:48 <nkaretnikov> like if i only have a single array which is pinned
06:32:04 <nkaretnikov> will gc never happen?
06:33:09 <ertes-w> nkaretnikov: BTW, if those primitives don't do in-place operations, that would be a bug…  those are primitives involved in FFI communication, and that wouldn't work if GHC would create copies instead of overwriting
06:33:43 <nkaretnikov> i guess threadscope or some other profiling tool will show it, but i'm just trying to understand
06:33:59 <ertes-w> nkaretnikov: pinning is orthogonal to GC…  the only way to keep GC out is by using bare pointers
06:34:22 <ertes-w> (or whatever primitives they are based on)
06:36:00 <ertes-w> nkaretnikov: pinning means that the memory won't be moved by GC, so you can reliably pass it to foreign functions
06:36:26 <nkaretnikov> ertes-w: right, but isn't moving related to collecting?
06:37:04 <nkaretnikov> ertes-w: it's a copying gc, right? so i assume that if there's no need to copy, then there's no need to collect, no?
06:37:14 <nkaretnikov> or something like that
06:38:09 * hackage sax 0.1.0.0 - Monadic streaming parser based on xeno xml parsing library  http://hackage.haskell.org/package/sax-0.1.0.0 (dredozubov)
06:38:26 <ertes-w> nkaretnikov: the RTS will do GC by moving memory, yes, but that doesn't mean it doesn't happen for pinned memory…  it just means that pinned memory has to be handled specially
06:39:09 <ertes-w> nkaretnikov: for example ByteStrings use pinned memory, and they GCed like everything else
06:39:11 <infandum> I did a test: x = [1..10000000]; sum' $ mappend x x (sum' is a strict sum). I noticed that when x is a list it takes 4 seconds and when x is a Sequence it takes 24 seconds. I think the discrepency is that Sequence is strict so it creates both sequences in memory and then appends them then sums, while the list does not have any in memory and just sums like a loop. However, I'm always told and it seems like it'
06:39:31 <infandum> s always faster to use mappend with Sequence rather than list for big data. Why is that?
06:39:43 <merijn> nkaretnikov: Sequence isn't strict, but it probably doesn't allow fusion as much
06:39:47 <merijn> eh
06:39:51 <nkaretnikov> ertes-w: okay... but could you elaborate on this? i mean, what does ghc need to do then?
06:39:56 <merijn> s/nkaretnikov/infandom
06:40:00 <nkaretnikov> :)
06:40:13 <merijn> infandum: With lists your sum probably lets fusion kick in and the entire list gets optimised out
06:40:32 <infandum> the sum' = foldl' (+) 0
06:40:56 <ertes-w> infandum: the way you use 'x' it's most likely allocated, too
06:41:22 <ertes-w> nkaretnikov: i can't sorry…  i'm one of the more "trusting" users =)
06:41:40 <infandum> So it's all because of fusion?
06:41:45 <nkaretnikov> ertes-w: too bad :( any takers?
06:42:10 <infandum> Is the only way to see which list like structure is best is to benchmark every single structure?
06:42:14 <ertes-w> infandum: try this:  sum' (mappend [1..10000000] [1..10000000])
06:42:25 <nkaretnikov> i guess i'll just ask the devs
06:43:02 <infandum> ertes-w: Still 4 seconds
06:43:05 <ertes-w> infandum: i don't think fusion happens here
06:43:06 <infandum> this is in ghci
06:43:12 <infandum> btw
06:43:31 <ertes-w> infandum: nah, you'll develop an intuition for it
06:43:31 <ertes-w> nkaretnikov: you should ask on haskell-cafe
06:44:07 <nkaretnikov> ertes-w: that's the last resort. i'm trying to avoid email as much as possible
06:44:21 <infandum> ertes-w: My intuition was always: If you need mappend or mconcat, use sequences, then if you don't need that but need many accessions, use vectors, otherwise use lists.
06:44:27 <ertes-w> infandum: don't benchmark with GHCi
06:45:31 <infandum> I do know that mappend with sequences is much, much faster than with vectors for sure
06:46:11 <ertes-w> infandum: that intuition is wrong
06:46:11 <ertes-w> infandum: lists are great at right-associated mappend
06:46:22 <infandum> It's just hard to tell when the computational complexity is there for both sequences and lists yet the benchmarking "does not agree" with those asymptotics.
06:46:37 <ertes-w> infandum: if you use that, then it all comes down to how you *consume*
06:46:57 <ertes-w> infandum: not necessarily; vectors use stream fusion, so your appends may just get optimised away completely
06:46:57 <ertes-w> again it comes down to how you consume them
06:47:28 <infandum> ertes-w: In my programs they are usually consumed many different ways
06:47:54 <ertes-w> Seq is great if you need to append with arbitrary associativity and access random elements, especially the head and the last
06:48:20 <ertes-w> vectors are great for whole-vector operations and very fast random access
06:48:47 <ertes-w> lists are great for pure streaming and right-associative appends (which is really a special case of streaming) and element-by-element consumption
06:49:12 <infandum> ertes-w: And what are they bad at?
06:50:13 <ertes-w> infandum: with your example from above i get the following timings:
06:50:39 <ertes-w> main = print (foldl' (+) 0 (mappend [1..10000000] [1..10000000]))  --   real 0.272  user 0.265  krnl 0.003  cpu% 98%  mem 4m  ./test
06:51:06 <ertes-w> main = let xs = [1..10000000] in print (foldl' (+) 0 (mappend xs xs))  --     real 0.964  user 0.793  krnl 0.170  cpu% 99%  mem 627m  ./test
06:51:20 <ertes-w> compare especially the memory consumption
06:51:41 <ertes-w> infandum: lists are bad at random access, sharing and anything that associates to the left
06:51:55 <ertes-w> (xs ++ ys) ++ zs  -- bad for lists
06:52:08 <ertes-w> xs ++ (ys ++ zs)  -- good for lists
06:52:16 <cloudhead> hey is there any reason why a list specified with [0..10] would make the program not terminate, but with [0,1,2,3,4,5,6,7,8,9,10] it terminates?
06:52:39 * hackage massiv 0.1.6.1 - Massiv (Массив) is an Array Library.  http://hackage.haskell.org/package/massiv-0.1.6.1 (lehins)
06:52:49 <merijn> cloudhead: Yeah, if you bollocksed up the termination condition :p
06:52:56 <merijn> > [1,1..10]
06:52:59 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
06:54:03 <ertes-w> cloudhead: it's unlikely, but [0..10] also has an effect on defaulting, because there is an Enum constraint in addition to a Num constraint
06:54:14 <infandum> ertes-w: What about something like Map.fromListWith mappend?
06:54:15 <cloudhead> merijn: hmm it's exactly [0..10]
06:54:30 <merijn> cloudhead: Sounds like something else is going wrong
06:54:34 <cloudhead> ah shit, wait
06:54:39 <cloudhead> it might be the defaulting
06:54:55 <cloudhead> because I'm creating time values eventually
06:54:55 <infandum> ertes-w: I know lists are worse there, but why?
06:54:57 <cloudhead> NominalDiffTime
06:55:12 <ertes-w> cloudhead: or a weird Enum instance
06:55:22 <merijn> cloudhead: ...I dunno what you're using that list for but I'm already scared
06:55:30 <cloudhead> merijn: :D
06:55:40 <ertes-w> infandum: it depends on your use case
06:55:54 <ertes-w> infandum: lists can be great even for some of the stuff you would usually do with Map
06:55:56 <cloudhead> merijn: I'm creating a list of NominalDiffTime
06:56:00 <cloudhead> from a list of ints
06:56:24 <infandum> ertes-w: Specifically for that function though, Map.fromListWith mappend
06:56:33 <ertes-w> > [0..2] :: [NominalDiffTime]
06:56:36 <lambdabot>  error:
06:56:36 <lambdabot>      Not in scope: type constructor or class ‘NominalDiffTime’
06:56:48 <ertes-w> @botsnack
06:56:48 <lambdabot> :)
06:56:51 <infandum> It's a function I use a TON and it is noticably faster with sequences, so I never use lists and keep them as sequences whenever I need that
06:57:41 <ertes-w> infandum: i'm a fairly regular user of Map K (Set A), so i use (M.fromListWith mappend) quite a lot
06:57:47 <infandum> looking at the code, it uses foldlStrict
06:57:55 <pavonia> When adding a lot of single bytes to a lazy bytestring, I end in a structure like (Chunk x (Chunk y ...)) which seems to be very inefficent. How would you usually handle this to get a more efficent storage?
06:57:55 <infandum> sorry, with Data.Map.Strict
06:58:23 <infandum> ertes-w: Yes, but set concatenation there is probably a lot faster than list concatenation
06:58:28 <ShalokShalom> there are different meanings to the word just
06:58:34 <ertes-w> infandum: but i can't really summarise all the information you need to make an educated decision in an IRC conversation
06:58:34 <ertes-w> infandum: this subject could fill a whole book
06:58:35 <lemmih> pavonia: Use the builder.
06:58:38 <cloudhead> merijn: I just fixed it by doing ([1..10] :: [Int])
06:58:44 <ShalokShalom> which one is meant in the maybe type?
06:58:46 <infandum> I'm just having trouble understanding how concatenation behaves differently (I assume it's because of the consumption)
06:58:48 <ertes-w> pavonia: Builder
06:58:48 <cloudhead> but don't understand what it was doing before
06:58:52 <merijn> cloudhead: Was this in ghci?
06:59:01 <cloudhead> merijn: nope in a test
06:59:03 <ertes-w> infandum: *probably*…  it depends on the use case
06:59:31 <pavonia> lemmih, ertes-w: Okay, looking at that
06:59:57 <merijn> cloudhead: Then you should turn on -Wall for your tests, because -Wtype-defaults warns about defaulting
07:00:08 <cloudhead> merijn: arrrgh
07:00:13 <cloudhead> merijn: yeah this is it I think
07:00:31 <cloudhead> [1..10] :: [NominalDifftime] -- every nano second of 10 years or something
07:00:35 <merijn> Repeat after me: Always use -Wall. Always use -Wall. Always use -Wall :)
07:00:39 <ertes-w> cloudhead: it looks a lot like an Enum instance is running wild, so it would be great if you could figure out what it defaults to and check if there is really a bug
07:00:53 <cloudhead> merijn: I am using -Wall, I think I might have disabled the type default warnings
07:01:07 <merijn> cloudhead: Welp, now you know why you shouldn't ;)
07:01:16 <ertes-w> that's really weird behaviour for NominalDiffTime
07:01:31 <ertes-w> i would have expected it to enumerate in seconds
07:01:45 <ertes-w> because that would be consistent with Num/Enum of Double
07:01:46 <cloudhead> yes exactly
07:01:56 <cloudhead> because     1 :: NominalDiffTime == 1s
07:02:01 <merijn> tbh, the Enum of Double is vile, though
07:02:15 <ertes-w> they probably just derived the Enum instance
07:02:30 <ertes-w> NominalDiffTime is just a wrapper around Integer IIRC
07:03:05 <ertes-w> merijn: i wouldn't mind having a separate EnumSteps class
07:03:20 <ertes-w> but…  you know…  history =)
07:03:34 <merijn> I think we should remove the Enum instance of Double
07:03:52 <merijn> We're on a roll with backwards incompatible ecosystem changes, lets kill that one too
07:04:11 * hackage bdcs 0.4.0 - Tools for managing a content store of software packages  http://hackage.haskell.org/package/bdcs-0.4.0 (clumens)
07:05:12 <cloudhead> succ (MkNominalDiffTime a) = MkNominalDiffTime (succ a)
07:05:16 <cloudhead> and 'a' is Pico :)
07:05:38 <fendor> > fromEnum (0.0 / 0.0)
07:05:41 <lambdabot>  0
07:05:59 <fendor> > fromEnum (0.0 / 0.0) == 0
07:06:02 <lambdabot>  True
07:06:03 <fendor> sweet
07:06:36 <ertes-w> merijn: i use enumFromThen* notation a lot with fractional types…  if you remove (Enum Double), please add (EnumSteps Double), where EnumSteps is a variant of Enum without default increments =)
07:06:52 <fendor> > fromEnum (0.0 / 0.0) == fromEnum 0
07:06:55 <lambdabot>  True
07:07:01 <fendor> > fromEnum (0.0 / 0.0) == fromEnum 0.0+
07:07:03 <fendor> > fromEnum (0.0 / 0.0) == fromEnum 0.0
07:07:03 <lambdabot>  <hint>:1:38: error:
07:07:04 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:07:06 <lambdabot>  True
07:07:39 <fendor> > fromEnum (1.0 / 0.0) == fromEnum (0.0 / 0.0)
07:07:42 <lambdabot>  True
07:07:42 <fendor> wtf
07:08:43 <merijn> Looks like NaN and Infinity convert to 0
07:09:00 <merijn> > fromEnum (read "Infinity" :: Double)
07:09:03 <lambdabot>  0
07:09:10 <merijn> yup
07:09:18 <merijn> > 1.0/0.0
07:09:21 <lambdabot>  Infinity
07:09:32 <merijn> > fromEnum (read "NaN" :: Double) -- not sure this works
07:09:35 <lambdabot>  0
07:10:49 <ertes-w> > round (read "Infinity" :: Double) :: Integer
07:10:52 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
07:11:15 <maerwald> ertes-w: huh
07:11:16 <merijn> Interesting
07:11:22 <maerwald> what number is that
07:11:37 <ertes-w> there you go, the digits of infinity =)
07:11:43 <maerwald> omg!
07:11:47 <frerich> All of them?!
07:11:53 <ShalokShalom> how do you mean the 'just' in the maybe type?
07:11:53 <ertes-w> apparently infinity starts with 1 =)
07:12:04 <maerwald> this is scary :D
07:12:09 <ShalokShalom> there are different definitions for the word 'just'
07:12:10 <ertes-w> maerwald: it's just an arbitrary large number – larger than the largest Double
07:12:16 <ShalokShalom> I try to make sense of it
07:12:45 <ertes-w> ShalokShalom: data Bool = False | True  -- every value of type Bool is either of the shape False or of the shape True
07:13:17 <ertes-w> ShalokShalom: data Maybe a = Nothing | Just a  -- every value of type (Maybe a) is either of the shape Nothing or of the shape (Just x), where (x :: a)
07:13:39 <maerwald> define "either" :P
07:13:50 <ertes-w> ShalokShalom: also keep in mind that haskell is case-sensitive…  'Just' means something very different from 'just'
07:14:10 <ShalokShalom> I mean how the word just is mean here in a literal sense
07:14:20 <ShalokShalom> I can reason about 'some' in ocaml
07:14:31 <ShalokShalom> how does that make sense in Haskell?
07:14:34 <maerwald> is this about church encoding?
07:15:38 <ertes-w> ShalokShalom: it doesn't…  it's just the word that stuck with us
07:16:03 <ShalokShalom> oO
07:16:17 <ShalokShalom> thanks
07:16:20 <maerwald> Option<T> is nicer too, I agree
07:16:38 <ertes-w> ShalokShalom: i think of "just" not as "only", but "actual" or "indeed"
07:16:39 <ShalokShalom> well, its more to get any sense out of it
07:16:43 <merijn> ertes-w: How does "Just" not make sense? Seems perfectly sensible to me?
07:17:12 <ShalokShalom> ertes-w: ah, more what I wanted to know
07:17:12 <maerwald> it's really a very bad name for it
07:17:18 <ShalokShalom> english is my second language
07:17:20 <ertes-w> ShalokShalom: haskell is almost three decades old…  apparently the haskell committee didn't have the imagination to come up with Some =)
07:17:25 <fendor> Nan is equal to infinity, thats a nice idea!
07:17:28 <ShalokShalom> ah I see
07:17:54 <ertes-w> Just (get used to it) =)
07:18:01 <ShalokShalom> :)
07:18:11 <fendor> in that sense, are Doubles not kind of cyclic? When you reach a number so big it is inifinity, you are suddenly at 0 again
07:18:23 <ertes-w> merijn: it makes sense to me, but i can see how a non-native english speaker *could* get confused by it
07:18:33 <merijn> fendor: You don't, though?
07:18:40 <merijn> > (1.0/0.0) + 1
07:18:41 <ertes-w> merijn: because "just" has more than one meaning, and in one of them it totally makes sense
07:18:43 <lambdabot>  Infinity
07:18:55 <merijn> fendor: Infinity + something is still Infinity
07:19:23 <fendor> merijn, but if i do (fromEnum (1.0 / 0.0) + 1) == 1
07:19:30 <fendor> > (fromEnum (1.0 / 0.0) + 1) == 1
07:19:32 <lambdabot>  True
07:19:50 <merijn> fendor: That's not Infinity + 1, though
07:20:04 <merijn> That's "(0 :: Int) + 1"
07:20:06 <fendor> merijn, no, of course not, but this enum definition is still funny
07:20:09 <ertes-w> ShalokShalom: however, haskell is kinda known for hip-hopping the english language…  for example how Right is the word for "correct" or "successful", and what's the opposite?  well, Left of course =)
07:20:23 <merijn> fendor: The Enum definition of Double is evil and morally wrong, tbh
07:20:27 <ertes-w> ShalokShalom: you get used to it =)
07:20:40 <merijn> ertes-w: That's not just English, though
07:20:45 <frerich> ShalokShalom: I understand 'Just' in this case the same was as 'Simply'. I.e. a value of type 'Maybe Bool' could be 'Simply True' or 'Nothing'.
07:20:55 <frerich> s/was/way/
07:20:57 <merijn> ertes-w: Left has been associated with evil and wrong since roman times :p
07:21:39 <ertes-w> hahaha
07:21:57 <ertes-w> if rust is dubstep, haskell is old-school hip-hop =)
07:22:12 <fendor> merijn, also, fromEnum will overflow if the number is too big
07:22:23 <merijn> fendor: Enum itself is fairly questionable too, yes
07:22:39 <ertes-w> @let da = id
07:22:40 <ShalokShalom> I just see, that the word just is also used for 'accurate'
07:22:41 <lambdabot>  Defined.
07:22:44 <ShalokShalom> I think thats it
07:22:50 <ertes-w> check out this beat…
07:22:50 <ertes-w> > fix `da` error
07:22:53 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
07:22:55 <occulti> Hackage is BACK :D
07:22:57 <ertes-w> lambdabot: don't be shy, mate
07:23:21 <fendor> :t da
07:23:23 <lambdabot> a -> a
07:23:27 <fendor> @info da
07:23:27 <lambdabot> da
07:23:30 <ShalokShalom> a bit overengineered :)
07:23:32 <ertes-w> fendor: see above
07:23:41 <fendor> ertes-w, i see
07:23:41 <ertes-w> i Just defined it =)
07:23:48 <fendor> looked weird :D
07:23:56 <ertes-w> da = id = ($)
07:24:10 <ShalokShalom> Just like discriminated unions
07:24:28 <merijn> attoparsec is still the fastest parser around, right?
07:24:36 <ShalokShalom> As I first read this, I was like: Why should anyone discriminate these poor unions? :O
07:24:53 <ertes-w> merijn: honestly i'd question that, because attoparsec insists on backtracking
07:25:15 <merijn> ertes-w: ok, so what's faster, then? :)
07:25:27 <merijn> Preferably not too dependency heavy
07:25:28 <ertes-w> merijn: do you need incremental input?
07:25:38 <ShalokShalom> there are about a dozen of different names for them, why choose one word thats well known for something like this destructive in the whole world xD
07:25:41 <merijn> ertes-w: Naah
07:26:01 <ertes-w> merijn: then you can't get much faster than (StateT ByteString Maybe)
07:26:14 <merijn> ertes-w: Yeah...I'll just use attoparsec then
07:26:36 <ertes-w> merijn: you could try trifecta and just avoid its error-reporting stuff
07:26:40 <merijn> I don't need speed *that* badly
07:26:56 <ertes-w> it's basically attoparsec, but with error reporting and without the insistence on backtracking
07:27:18 <merijn> ertes-w: I wonder if anyone has benchmarked those two against each other
07:27:43 <ertes-w> merijn: be the first to do it!
07:27:47 <merijn> Anyway, now it's gym time
07:27:53 <merijn> ertes-w: I've already got a herd of yaks
07:28:00 <merijn> Multiple, actually
07:28:10 <ertes-w> i wouldn't be blown away to find that trifecta is actually faster than attoparsec
07:28:35 <ertes-w> merijn: megaparsec could be faster, too
07:28:35 <merijn> ertes-w: I don't think trifecta has blitting operators, though?
07:28:44 <ertes-w> blitting?
07:30:41 <merijn> ertes-w: This suggests megaparsec is only faster in some cases: https://markkarpov.com/post/megaparsec-more-speed-more-power.html
07:30:53 <merijn> ertes-w: The ability to grab entire chunks of Text/ByteString
07:31:19 <merijn> ertes-w: i.e. takeWhile
07:31:47 <ertes-w> merijn: i'm pretty sure it has that
07:31:57 <ertes-w> would be quite odd if it didn't
07:32:09 <merijn> megaparsec has it now, yeah
07:32:14 <merijn> Trifecta afaik doesn't
07:32:43 <merijn> Anyway, problem for later
07:33:03 * frerich feels like a made man (in the mafia sense) after getting notified that Stephen Diehl starred one of his GitHub repos
07:33:33 <frerich> Stephen Diehl, in case you are here: you make me very happy. :)
07:34:28 <merijn> frerich: It's not that hard apparently, I managed that by stealing one of Lennart's libraries and make like 3-4 lines of changes :p
07:34:59 <frerich> merijn: Don't burst my bubble - in this case, it's my own package! :-)
07:35:05 <merijn> \o/
07:35:07 <merijn> Which one?
07:35:28 <frerich> It's really only a Template Haskell exercise I did a few years ago: https://github.com/frerich/catamorphism
07:35:49 * ertes-w feels like a badass after coercing SPJ to make his treat-undefined-variables-like-holes feature optional =P
07:36:45 <merijn> ertes-w: pfft, real men hack features like that in themselves :p
07:38:01 <ertes-w> merijn: then i'll never be a real man, because that feature made me crazy
07:38:42 <ertes-w> no PHP weak typing bullshit ever came even close to the level of interference it had with my workflow =)
07:39:41 <merijn> ertes-w: Well, it mostly broke my workflow by breaking my fix to my workflow
07:39:54 <merijn> i.e. -fdefer-typed-holes
07:40:36 <frerich> A while ago I had another of these 'Oh my god I just received holy bytes' moments - it was when I noticed that this 'Doug McIlroy' writes emails in an interesting way. So I looked up who he is and what he did: https://en.wikipedia.org/wiki/Douglas_McIlroy
07:40:59 <frerich> (He sometimes writes to haskell-cafe)
07:42:05 <frerich> I don't mean to say that I felt like a japanese school girl who's finally in the same room as her big pop star crush.
07:42:07 <frerich> but it was close.
07:43:53 * earthy had that with Steven Bourne a couple of years back
07:44:57 <ShalokShalom> what rule of thumb do you use, in order to distinguish between the maybe type and >>=?
07:45:06 <earthy> er. Stephen Richard 'Steve' Bourne, apparently, according to wikipedia
07:46:21 <ShalokShalom> so, when use what?
07:48:43 <ertes-w> "As of 2007 he is an Adjunct Professor of Computer Science at Dartmouth College."
07:48:49 <ertes-w> an adjunct professer…
07:48:57 <robstr> ShalokShalom: maybe I misunderstand you, but >>= is bind related to a monad and Maybe is a type - But im still on the learning track here too :P
07:49:22 <ShalokShalom> railway oriented programming?
07:49:28 <ShalokShalom> how is that called here?
07:50:08 <frerich> ertes-w: His emails are very easy to notice because it appears he uses 40 columns or so. Very narrow (by today's standards).
07:52:01 <robstr> ShalokShalom: I didn't hear railway oriented programming before, but after a short google i thing you mean something like fail fast chaining ?
07:52:17 <ShalokShalom> might be?
07:52:42 <Athas> frerich: that's narrow by 70s standards, too!
07:53:22 <ventonegro> Category Theory for Programmers should have included an example like https://jneem.github.io/merging/
07:53:23 <ertes-w> frerich: i watched a talk called "emacs for writers" (it's not haskell-related, but a very entertaining case study), and the presenter had some interesting historical remarks…  apparently a famous writer (i forgot who) still uses wordstar, a DOS word processor
07:53:30 <robstr> ShalokShalom: check this page http://learnyouahaskell.com/a-fistful-of-monads
07:54:19 <ertes-w> frerich: if you use something like that along with ridiculously old hardware as your MUA, you might be tempted to use such a style
07:55:53 <DigitalKiwi> Maybe he just does it for no reason other than we're all talking about it?
07:56:58 <ShalokShalom> robstr: this is what I mean: https://www.youtube.com/watch?v=PFWYwr7Hhhg&list=PLEoMzSkcN8oNiJ67Hd7oRGgD1d4YBxYGC#
07:57:03 <ShalokShalom> oh no
07:57:19 <ShalokShalom> 38:35
07:57:39 <DigitalKiwi> Banish this person!
07:57:44 <ShalokShalom> thanks for the link
07:57:51 <ertes-w> DigitalKiwi: no, apparently he does it for one of the reasons we generally prefer editors like emacs and vim:  being productive with little distraction
07:58:25 <ertes-w> of course it doesn't quite help that i have my IRC client in emacs =)
07:59:37 <DigitalKiwi> Nah, using 40 columns has more to it than that.
08:00:06 <DigitalKiwi> 40 columns makes a statement!
08:00:07 <robstr> ShalokShalom: yea read this page, there are smaller articles outside but i highly recomment the book "Haskell programming from first principles" by christopher allen and julie moronuki - but its large :P
08:00:56 <robstr> ShalokShalom: or "Realworld Haskell"
08:01:31 <ShalokShalom> I mean, how to distinguish between maybe and that kind of error handling shown in this video?
08:01:31 <ShalokShalom> when to use what?
08:01:46 <ShalokShalom> I mean a rule of thumb
08:01:50 <ShalokShalom> thy
08:02:09 * hackage diagrams-lib 1.4.2.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.4.2.1 (BrentYorgey)
08:02:40 <ertes-w> ShalokShalom: error handling is kind of a huge topic in haskell, because we insist so much on doing it properly…  correspondingly there are many approaches and no general rule of thumb
08:02:58 <ertes-w> ShalokShalom: in pure settings you can use any monad that supports failure:  Maybe, Either, [], …
08:03:32 <ertes-w> ShalokShalom: if IO is involved, you would typically use IO exceptions, but sometimes it makes sense to put a layer on top of it like MaybeT
08:03:34 <ShalokShalom> Either? Lists support failure?
08:03:40 <ShalokShalom> And they are monads?
08:03:49 <ertes-w> ShalokShalom: sure, the empty list can represent failure
08:04:05 <ShalokShalom> how do you call that type of error handling in the video?
08:04:06 <ertes-w> > do x <- [1,2,3]; y <- [4,5,6]; guard (x + y == 5); pure (x + y)
08:04:09 <lambdabot>  [5]
08:04:11 <ertes-w> > do x <- [1,2,3]; y <- [4,5,6]; guard (x + y == 500); pure (x + y)
08:04:11 <ShalokShalom> at 38:35
08:04:13 <lambdabot>  []
08:04:27 <ShalokShalom> I am particularly interested in that
08:04:43 * ertes-w can't watch videos right now
08:06:01 <robstr> ShalokShalom: It's normal monadic behaviour relaying on maybe or either afaik but i still do not know f#
08:08:03 <robstr> ShalokShalom: you should invest the time in understanding either and the maybe monad
08:09:56 <ertes-w> it would help if you would use proper capitalisation…  experienced haskellers can tell the difference from context, but beginners usually can't
08:11:06 <robstr> makes sense, next time - thank you
08:12:09 * hackage stratosphere 0.21.0 - EDSL for AWS CloudFormation  http://hackage.haskell.org/package/stratosphere-0.21.0 (jdreaver)
08:16:50 <AWizzArd> I am seeing `instance (Functor m, Monad m) => Applicative (StateT s m) where` and wonder why `Functor m` is explicitly listed. By saying `Monad m` – don’t we implicitly say it’s okay to call fmap on m?
08:17:39 <Taneb> AWizzArd: that didn't used to be the case, sadly
08:18:05 <AWizzArd> Taneb: okay so in the past it had to be done explicitly. But is this still so with GHC 8.2 or 8.4?
08:18:41 <Taneb> AWizzArd: it's not necessary, but it also doesn't break things
08:18:56 <Taneb> So I guess they just left it in
08:19:11 <Taneb> (especially as transformers still supports older versions of GHC)
08:20:19 <AWizzArd> Okay good, makes sense then.
08:22:39 * hackage gnuplot 0.5.5.2 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.5.5.2 (HenningThielemann)
08:24:38 <Athas> Regarding the Semigroup/Monoid change, is there a solution that 1) is warning-free on GHC 8.4; 2) works on GHC 8.2; 3) does not use CPP?
08:24:38 <Athas>  
08:24:46 <Athas> I currently use a solution that satisfies (2) and (3).
08:25:03 <phadej> base-compat-batteries
08:25:29 <phadej> and depnds on what warnings you want to avoid
08:26:16 <Athas> I have some 'Data.Monoid' imports that GHC 8.4 warns are unnecessary.
08:26:33 <Athas> base-compat-batteries looks interesting...
08:26:35 <phadej> those you can solve with base-compat(-batteries)
08:26:57 <phadej> without batteries semigroups stuff is compat down to GHC-8.0, with -batteries all the way to 7.0
08:27:04 <Athas> Looks like base-compat-batteries is not on Stackage.  Maybe base-compat is enough?
08:27:13 <Athas> Alright, good.  I only need 8.0.
08:27:14 <phadej> you need 0.10
08:27:19 <phadej> for semigroups stuff
08:27:36 <phadej> which isn't either on stackage yet
08:27:38 <Athas> Damn, Stackage only has base-compat 0.9.3.
08:27:58 <phadej> https://github.com/fpco/stackage/issues/3493
08:29:51 <ShalokShalom> https://github.com/ShalokShalom/Elchemist/blob/master/Game.fs#172
08:30:13 <ShalokShalom> ertes-w: robstr ^
08:30:24 <Athas> How frustrating.  Maybe I can hack it instead.  Or require GHC 8.4...
08:30:35 <phadej> extra-deps: ...
08:30:37 <ShalokShalom> I mean line 171 going on
08:30:37 <ShalokShalom> you can see the implementation of >>= in line 131
08:30:40 <phadej> there is install plans for 8.2
08:30:44 <phadej> there are*
08:31:24 <ShalokShalom> this is how I like to handle errors
08:34:10 <Athas> Looks like I can just replace my 'import Data.Monoid' with 'import Data.Semigroup'.  Works and is warning-free in both GHC 8.4 and 8.2.
08:36:26 <ShalokShalom2> hi again
08:36:29 <ShalokShalom2> wifi died
08:36:51 <ShalokShalom2> did i miss an answer? :)
08:37:23 <lemmih> ShalokShalom2: What's the question?
08:40:29 <ertes-w> ShalokShalom2: i looked at the code…  what's the question?
08:40:58 <ertes-w> ShalokShalom2: also is it an F# or a haskell question?  (it makes a huge difference)
08:41:06 <Ivan__1> infandum: 14:38: try   sum' $ toList $ mappend x x -- in the case x is a Sequence. The definition of foldl' in Data.Sequence seems to be rather misterious...
08:41:13 <byorgey> Athas: yes, and that should work on older GHCs too if you require the 'semigroups' package
08:41:59 <Athas> I wonder why I even bother supporting older GHCs, though.
08:42:58 <ertes-w> Athas: some people are stuck with old GHCs, so i generally go back two major versions, sometimes only one
08:43:12 <byorgey> it's up to you.  I was just pointing out the possibility.
08:43:32 <shapr> I'm giving a Haskell intro at southside hackerspace chicago this Sunday at 1pm, if you're in town, come on over!
08:44:15 <shapr> I still wish we didn't have the confusion of stack / cabal / haskell platform, would make new installs easier.
08:44:25 <Athas> ertes-w: if I were writing a library, sure, that's useful.  But I'm writing an application.  There was one time where I my build servers could not run the newest GHC due to a GHC bug, but I think that's the only time I actually exploited multi-GHC-version-support.
08:44:42 <Athas> shapr: just tell them what to use.  (Stack.)
08:45:10 <shapr> yeah, that's what I'm going to suggest, but I wish stack weren't so cruddy about bounds checking.
08:45:55 <dumptruckman> Can someone tell me what is wrong here? https://pastebin.com/BcPaaG9p
08:45:58 <Athas> Does that matter for a Haskell intro?
08:46:06 <shapr> Athas: probably not
08:46:25 <Athas> dumptruckman: what are you doing?
08:46:31 <[exa]> dumptruckman: what platform are you doing that on?
08:46:40 <[exa]> dumptruckman: esp. looking at SIGUSR1 value etc. :]
08:46:59 <[exa]> oh windows.
08:47:39 <[exa]> dumptruckman: doesn't look like an error at all, btw
08:47:51 <dumptruckman> hmm ok
08:48:17 <dumptruckman> Failed to install unix-2.7.2.2
08:48:19 <desertjellyfish> hello
08:48:35 <desertjellyfish> is it possible to install haskell to a specific folder
08:48:58 <[exa]> desertjellyfish: yes, in many different ways
08:49:00 <desertjellyfish> Ive tried stack setup --prefix PATH
08:49:05 <desertjellyfish> but it failed :(
08:49:24 <desertjellyfish> how [exa] ?
08:50:09 <davean> desertjellyfish: I mean "haskell" isn't a thing, but any particular thing related to Haskell,yes
08:50:38 <[exa]> desertjellyfish: do you have the error message?
08:51:09 <dumptruckman> So that log doesn't give any clues to why unix-2.7.2.2 was unable to be installed?
08:51:10 <desertjellyfish> Invalid option `--prefix'
08:51:21 <[exa]> dumptruckman: http://hackage.haskell.org/package/unix
08:52:36 <[exa]> dumptruckman: it's simply unsupported, there's no unix on windows. maybe there might be an alternative that I'm not aware of
08:52:49 <dumptruckman> Hmm.. previously it said installing mingw+msys would help
08:53:13 <desertjellyfish> davean: humm
08:53:39 * hackage vulkan-api 1.1.1.0 - Low-level low-overhead vulkan api bindings  http://hackage.haskell.org/package/vulkan-api-1.1.1.0 (achirkin)
08:54:08 <[exa]> desertjellyfish: you might want to take a look at stack help setup
08:54:38 <desertjellyfish> ok
08:55:15 <ShalokShalom2> ertes: is this possible in Haskell?
08:55:30 <[exa]> iirc it's --stack-root (maybe someone more stack-ish will correct that)
08:55:32 <ShalokShalom2> lemmih: how to do this error handling in Haskell?
08:55:48 <lemmih> ShalokShalom2: data Result a = Success a | Failure String
08:56:00 <ShalokShalom2> ?
08:56:11 <lemmih> ShalokShalom2: It's pretty much exactly the same as in F#.
08:56:12 <ShalokShalom2> this: https://github.com/ShalokShalom/Elchemist/blob/master/Game.fs#172
08:56:16 <robstr> ShalokShalom2: yea this is possible, you must check Either or Maybe
08:56:23 <ShalokShalom2> 172 - 178
08:57:30 <lemmih> ShalokShalom2: There's no real difference. You can even use '>>=' if you want.
08:58:09 <ertes-w> ShalokShalom2: what you're seeing there is regular Maybe in haskell
08:58:39 <ShalokShalom2> implementation is in line 131
08:58:58 <[exa]> btw isn't there a better composition syntax for a list of >>= ?
08:59:02 <ShalokShalom2> i guess thats the same function binding in both, F# and Haskell?
08:59:35 <ShalokShalom2> ertes-w: so how is Option different from Maybe then?
08:59:49 <robstr> ShalokShalom2: https://hackage.haskell.org/package/base-4.11.0.0/docs/Control-Monad.html#v:-62--62--61-
08:59:56 <ShalokShalom2> thy
09:00:12 <lemmih> ShalokShalom2: It isn't. Same concept, difference languages.
09:00:15 <ertes-w> @let isqrt x = (foldr (\(r, s) go -> case compare s x of EQ -> Just r; GT -> Nothing; LT -> go) Nothing . iterate (\(r, s) -> (r + 1, s + 2*r + 1)) (0, 0)
09:00:15 <lambdabot>  Parse failed: Parse error: EOF
09:00:16 <lemmih> *different
09:00:22 <ertes-w> @let isqrt x = (foldr (\(r, s) go -> case compare s x of EQ -> Just r; GT -> Nothing; LT -> go) Nothing . iterate (\(r, s) -> (r + 1, s + 2*r + 1))) (0, 0)
09:00:25 <lambdabot>  Defined.
09:00:34 <ertes-w> > map isqrt [0..5]
09:00:36 <lambdabot>  [Just 0,Just 1,Nothing,Nothing,Just 2,Nothing]
09:00:45 <ertes-w> ShalokShalom2: this is an integer square root function
09:01:03 <ertes-w> taking the sqrt twice yields the fourth root, but both steps may fail
09:01:07 <ShalokShalom2> lemmih: So >>= is the very same as Maybe?
09:01:10 <ertes-w> > isqrt 16 >>= isqrt
09:01:13 <lambdabot>  Just 2
09:01:16 <ShalokShalom2> why do both look so different?
09:01:20 <ertes-w> > isqrt 9 >>= isqrt
09:01:23 <lambdabot>  Nothing
09:01:35 <ShalokShalom2> you mean same implementation and different sugar?
09:01:39 <ertes-w> ShalokShalom2: for Maybe (>>=) is exactly the same as in the code you posted
09:02:15 <lemmih> ShalokShalom2: You know that '>>=' is a function and 'Maybe' is a type constructor, right?
09:02:23 <ShalokShalom2> yes, what i mean?
09:02:38 <ShalokShalom2> so Option is the type constructor in F#
09:03:05 <ShalokShalom2> and i can use >>= here in Haskell exactly as in F#?
09:03:15 <ShalokShalom2> so, how the code shows?
09:03:21 <ShalokShalom2> thy
09:04:02 <lemmih> ShalokShalom2: I don't understand your question.
09:05:36 <occulti> When to expect a Haskell course in Udemy?
09:06:33 <ertes-w> ShalokShalom2: the code you pasted is heavily inspired by haskell…  they are trying to get some of haskell's features in F#
09:07:09 * hackage tidal 0.9.8 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.9.8 (AlexMcLean)
09:07:15 <Ivan__1> ShalokShalom2: >>= is a polymorphic function of type (Monad m) => m a -> (a -> m b) -> m b
09:07:34 <dumptruckman> anyone know if there's been improvements to getting GHC 8 working on WSL?
09:07:35 <ertes-w> of course ultimately trying to use monads in F# is a doomed endeavour, because F# doesn't support higher-kinded polymorphism
09:08:46 <Ivan__1> ShalokShalom2: this type reads in words: given a type constructor m, which happend to be a monad (it doesn't matter here what it is), >>= constructs an element of (m b) from an element in (m a) and a map ( a -> m b)
09:09:12 <ertes-w> s/type constructor/type/
09:10:01 <Ivan__1> in the case isqrt 9 >>= isqrt, you have (m = Maybe) , (isqrt 9 :: Maybe Int), (isqrt :: Int -> Maybe Int)
09:10:22 <Ivan__1> ertes-w: thaks )
09:10:32 <Ivan__1> s/thaks/thanks/
09:10:33 <ertes-w> Ivan__1: note that their code is in F#…  their notion of (>>=) is not polymorphic, and they don't have access to higher-kinded polymorphism in the first place
09:11:02 <ertes-w> this is the type ShalokShalom2 has:  (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
09:12:18 <ertes-w> and i kinda like to stress that F# does *not* have monads, because people like to advertise it so much =)
09:13:06 <Ivan__1> this terrible F# from Microsoft Buisness )
09:14:07 <ertes-w> the problem is that higher-kinded polymorphism doesn't play well with their .NET run-time system…  as to why they didn't make it an F#-exclusive feature i have no idea
09:14:22 <ertes-w> they probably thought that monads are just about having nice syntax for (>>=)
09:14:48 <Ivan__1> As far as I understand .NET is based on OOP
09:15:00 <ertes-w> yeah, pretty much
09:15:13 <Ivan__1> it would be difficult to connect it higher-kind polymorphism...
09:15:39 <Ivan__1> s/it/it to/
09:15:41 <quicksilver> to be fair microsoft also employs people to work on GHC :)
09:15:53 <sgraf812> Well, technically they have higher-kinded types at least in terms of reified generics
09:16:03 <Ivan__1> "Microsoft Buisness" was alussion on "Mircrosoft Research"
09:16:12 <sgraf812> `ArrayList<>` is a thing, as is `Dictionary<,>`
09:16:35 <ertes-w> i do think microsoft is doing some great work in language research…  apparently they're even involved in a proof assistant called 'lean', which looks very nice
09:16:49 <ertes-w> and yes, lean works on linux and even has an emacs interface =)
09:17:33 <ertes-w> i wouldn't be surprised if they started to put a lot more focus on functional languages in the future and slowly move away from OOP
09:18:46 <ertes-w> sgraf812: i should note that i haven't touched F# in a long time…  can you abstract over those now?
09:18:52 <davean> ertes-w: what suggests that change of course for them?
09:19:08 <ertes-w> i.e. the equivalent of (forall (m :: * -> *)) in haskell
09:19:57 <sssilver> I came here to complain about how tired and sick I am of programming in Golang at work
09:19:59 <sssilver> this is hell
09:20:03 <ertes-w> davean: it's a feeling…  if you take a look at their research there is a lot in the context of FP
09:20:16 <davean> sssilver: Ick, golang. Its the worst
09:20:27 <sssilver> people repeatedly tell me how enums are useless "never needed them in 40 years of programming", etc
09:20:39 <sssilver> it's just so cringe
09:20:52 <glguy> This isn't the place to complain about programming in Go at work
09:21:09 <sssilver> :(
09:21:15 <ertes-w> sssilver: #haskell-offtopic is a nice place for this
09:21:28 <ertes-w> i complain about ansible about twice every week there =)
09:36:01 <DigitalKiwi> glguy with his hat all ominous
09:37:03 <jle`> woo hoo hackage is back :)
09:48:27 <vilu> In my cabal file I have a library which contains all the logic, a small executable section that only references the library in a main method and finally a test section that tests the library.
09:49:05 <vilu> However I'm getting missing modules when building executable and test sections, do I really have to add ALL the dependencies in EACH of the section?
09:52:21 <ShalokShalom2> Ivan__1: Thanks
09:53:30 <ShalokShalom2> ertes-w: So, after all this complicated hick hack the simple answer to my question is: Yes :D
09:54:53 <ShalokShalom2> why is it so complicated to give a simple answer on a simple question?
09:55:24 <ShalokShalom2> ertes-w: about the F# exclusive feature: i am not sure, while I think thats a nice idea
09:55:50 <ShalokShalom2> there is an implementation called higher, while its unmaintained since 2016
09:56:26 <ShalokShalom2> ertes-w: and you might like to look into fsharp plus, it is full with monads :)
09:56:55 <ertes-w> ShalokShalom2: or i just stick with haskell =)
09:57:08 <ertes-w> i have no reason to use a .NET language
09:57:19 <ShalokShalom2> Ivan__1: .Net was/is from the very beginning planned and designed to host different languages, in contrary to the JVM
09:58:21 <ShalokShalom2> which is also the reason, why Generics and TCO are there on one side and not on the other one
10:01:32 <ShalokShalom2> i am simply mention this, since you state monads are not there
10:01:52 <ShalokShalom2> and fsharp has other compilers too, like fez and fable
10:01:59 <ShalokShalom2> so not only dotnetcore
10:02:26 <xplat> vilu: which modules is it complaining about?  you should definitely be adding base to all of them ...
10:02:42 <vilu> In this case it was a logging module.
10:03:05 <vilu> Which was not directly referenced in the executable
10:03:39 <vilu> So in the library I used a logger library.
10:03:52 <vilu> The executable was only a main method importing one method from the library
10:04:10 <vilu> yet it failed to compile because it said that it couldn't find the logging module.
10:07:06 <dsal> I've got three PRs out for two haskell libs.  I should do this more.
10:11:24 --- mode: glguy set -bbbb *!*@80.96.206.110 *!*@165.16.66.186 *!*@185.121.168.22 *!*@2a03:b0c0:1:d0:*
10:11:25 --- mode: glguy set -o glguy
10:16:25 --- mode: ChanServ set -b topaz*!*@*
10:18:40 * hackage hledger-web 1.9.1 - Web interface for the hledger accounting tool  http://hackage.haskell.org/package/hledger-web-1.9.1 (SimonMichael)
10:23:40 <xplat> vilu: okay, i created a sample project just to be sure i wasn't tripping.  i think probably your exe and test projects are trying to recompile the library's modules instead of using them from the library
10:24:01 <xplat> vilu: it's probably safest to give them separate source directories so that can't happen
10:24:37 <vilu> Ok, yeah they do reside in the same directory
10:24:46 <xplat> vilu: and make sure that all the modules your library is exporting are listed in exposed-modules: for the library as well
10:24:53 <vilu> That I did
10:25:04 <vilu> also while on the subject, the other-modules section makes little sense to me.
10:25:16 <vilu> It feels quite redundant.
10:25:32 <vilu> So just to recap, in every package ALL modules need to be explicitly named somewhere?
10:25:41 <vilu> Either as export, other or in the main?
10:26:12 <xplat> yeah.  it's intentionally redundant, i'm probably not the best person to ask to justify that decision as it's not one i would make myself -_-
10:26:30 <vilu> Hehe fair point.
10:27:00 <vilu> The documentation though sometimes is a bit sparse so you see these things as a beginner and you kind of assume that there is another reason that's not written down and that you're not seeing.
10:35:05 <vilu> The documentation though sometimes is a bit sparse so you see these things as a beginner and you kind of assume that there is another reason that's not written down and that you're not seeing.
10:35:09 <vilu> sorry
10:39:01 <dsal> I've resorted to commenting on my commit comments to try to explain super simple concepts to myself: https://github.com/dustin/haprs/commit/9164df3145e4ab92e11c659dfad2331a903f9d5e
10:41:39 * hackage data-tree-print 0.1.0.1 - Print Data instances as a nested tree  http://hackage.haskell.org/package/data-tree-print-0.1.0.1 (lspitzner)
10:45:09 * hackage multistate 0.8.0.0 - like mtl's ReaderT / WriterT / StateT, but more than onecontained value/type.  http://hackage.haskell.org/package/multistate-0.8.0.0 (lspitzner)
10:49:16 <vilu> dsal can it be that you have the type definition a bit off here?
10:49:42 <vilu> Also a bit of a beginner there but the monad definition looks a bit off.
10:50:10 <vilu> But maybe I'm missing something?
10:50:25 <dsal> vilu: how do you mean?  I'm sure it's possible I'm wrong. :)
10:51:21 <dsal> This property verifies I can read what I show (and get back where I started)
10:52:11 <vilu> Right, so pure for me is something that lifts a value into an applicative context.
10:52:35 <vilu> In your definition it looks more like a function, that takes an a then a r and gives you an a
10:53:05 <dsal> So, const?
10:53:12 <vilu> If you change your functions from a -> r -> a to a -> r a
10:53:27 <ski> > pure 0 1
10:53:29 <lambdabot>  0
10:54:07 <dsal> It's a function monad, though I couldn't find the definition last night, so I just pasted what others said here.
10:54:19 <vilu> Okay well it is kind of true.
10:54:33 * ski . o O ( environment/input/reader )
10:56:44 <vilu> I do think it's easier to understand it though if you differentiate a type constructor from a function.
10:57:47 <vilu> I tend to think of functors, monads etc as containers of values and then the >>= signature makes sense imho.
10:58:21 <ski> i'm not sure it's that helpful to call it "function monad" (or "function applicative") .. since it's about a particular mode of using functions (as opposed to other modes)
10:59:21 <ski> in particular, it's about "distributing" some "input" / "read-only state", "downwards" into a computation, and, perhaps, locally changing what is passed on into some subcomputations
11:00:19 <dsal> Where is this defined/named?
11:00:49 <ski> i like the term "environment" (cf. environment variables in Operating Systems). i think some of the early papers (Wadler) called it "input" (only passed into a computation, not out of, like `Writer' or `State')
11:00:59 <ski> where is what defined/named ?
11:02:34 <ski> > sequence [(2 +),(2 *),(2 ^)] 3
11:02:36 <lambdabot>  [5,6,8]
11:03:07 <ski> the environment `3' is distributed to all the three component actions in the list given to `sequence'
11:04:19 <dsal> Where is this >>= defined?  I'm not even sure what to look at.
11:04:23 * ski missed dsal's paste(?), fwiw
11:05:14 <dsal> @pl \x -> f x == x
11:05:15 <lambdabot> (==) =<< f
11:05:16 <kuribas> vilu: the container analogy works for some types, but fails for a lot.
11:05:57 <dsal> That's how I found it, and it does what I wanted, but I wanted to look a little deeper into it.
11:06:02 <vilu> Agreed, do you have another analogy that fits better?
11:06:08 <kuribas> vilu: for example the Const Functor doesn't contain any value of the Functor type variable.
11:06:21 <kuribas> vilu: not really
11:06:28 <vilu> It was the analogy that helped me get started to understand Functors and Monads.
11:06:28 <dsal> ski: this was right before you joined: https://github.com/dustin/haprs/commit/9164df3145e4ab92e11c659dfad2331a903f9d5e
11:06:36 <vilu> eventually the analogy wasn't needed anymore.
11:06:56 <Lears> @djinn (r -> a) -> (a -> r -> b) -> (r -> b)
11:06:56 <lambdabot> f a b c = b (a c) c
11:08:08 <kuribas> vilu: they way I see a Functor is that it lifts a function from the type of values to another type.
11:08:17 <kuribas> vilu: so like a container on the type level.
11:08:44 <kuribas> vilu: I see those, Functor, Monad, etc... more as type level structures.
11:09:26 <kuribas> vilu: on the type level, container makes sense.
11:09:53 <vilu> Agreed
11:10:14 <kuribas> vilu: so Functor transforms (a -> b) into (f a -> f b)
11:10:52 <vilu> I like that explanation
11:13:19 <kuribas> vilu: and monadic bind is like function application, but the second argument of the function is decorated with the monad type.
11:13:57 <dsal> I'm living mostly in pragmatic code.  functor/applicative as container has mostly worked for me.  I haven't concentrated in enough areas that are different to internalize enough things.
11:14:01 <Ariakenom> :t (<*>)
11:14:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:14:29 <Ariakenom> :t (>>=)
11:14:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:14:48 <kuribas> :t (flip ($))
11:14:49 <lambdabot> a -> (a -> c) -> c
11:14:50 <ski> (a "container" of type `Const c a' always contains zero values of type `a'. for `Identity a', it's always one. for `Maybe a' and `Either e a', it's zero or one)
11:15:02 <Ariakenom> :t (&)
11:15:04 <lambdabot> a -> (a -> b) -> b
11:15:58 <Ariakenom> :t join
11:15:59 <lambdabot> Monad m => m (m a) -> m a
11:16:06 <xplat> > "dlrow olleh" & reverse
11:16:09 <lambdabot>  "hello world"
11:16:37 <ski> dsal : i was thinking `instance Monad ((->) rho)' was in `Control.Monad.Reader' (in the `mtl' package), but i don't see it there, only the `MonadReader rho ((->) rho)'
11:16:41 <EvanR> "world bye"
11:16:44 <kuribas> ski: what value does (+1 :: Int -> Int) contain?
11:16:53 <Ariakenom> I feel like monad vs applicative would be hard to express as application of contained types using bind
11:16:53 <Taneb> ski: it's in base now I think?
11:17:07 <xplat> ski: it's more likely in base, but if not it's in transformers
11:17:13 <Ariakenom> versus join
11:17:16 <xplat> or base-orphans
11:17:25 <xplat> certainly not mtl
11:17:46 <ski> kuribas : one value for every value of `Int' (the input type), obviously(?). cf. `Bool -> a', aka `(a,a)' being an (ordered) container containing exactly two `a's
11:18:18 <ski> xplat : yeah, i was suspecting so, but couldn't guess at the module
11:18:36 <Taneb> ski: instance Monad ((->) rho) has been in base since base has had haddocks
11:19:32 <kuribas> ski: and (putStrLn)?
11:19:34 <xplat> probably in Control.Monad?  bare possibility of Data.Function.
11:19:38 <ski> Taneb : i'm probably confusing it with another instance
11:20:08 <kuribas> ski: or (putStrLn "hello world")
11:20:12 <Taneb> ski: Monoid env => Monad ((,) env) is more recent
11:20:26 <ski> dsal : see <https://hackage.haskell.org/package/base-4.11.0.0/docs/src/GHC.Base.html#line-804> and <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/mtl-2.2.2/src/Control.Monad.Reader.Class.html#line-104>
11:20:34 <EvanR> kuribas: are you asking for semantics of IO
11:20:50 <xplat> kuribas: you can fit (+1) into the container analogy pretty easily: it contains one Int for each Int
11:21:20 <kuribas> EvanR: no, I am asking how IO would fit into the container analogy.
11:21:30 <ski> kuribas : monads which involve state are harder to fit into this conception, i agree
11:21:30 <EvanR> dont
11:21:44 <xplat> kuribas: but if you're going to look at IO you should look at like, which strings are contained in getContents
11:21:57 <EvanR> stahp
11:22:03 * ski smiles
11:22:13 <xplat> it gets pretty terrible tho
11:22:25 <kuribas> Also the container analogy carries like zero information about Monads, Functors...
11:23:09 <Welkin> fuck monads o.o
11:23:21 <maerwald> Yes
11:23:35 <spruit11> Burn Wadler's beard!
11:23:36 <Ariakenom> :t fuck monads
11:23:38 <lambdabot> error: Variable not in scope: fuck :: t0 -> t
11:23:38 <lambdabot> error: Variable not in scope: monads
11:23:41 <Welkin> the longer I have been using functional languages (and haskell) and hearing about monads nonstop from everyone and their dog
11:23:44 <maerwald> Might be pleasurable
11:23:55 <Welkin> I'm really tired of hearing about monads all the time
11:24:05 <maerwald> I like functors
11:24:07 <Welkin> they are nothing special
11:24:17 <Welkin> they aren't even fundamental to functional programming
11:24:21 <EvanR> "I don't have to take this. I'm going home" -- Welkin
11:24:22 <michalrus> Umm, I can’t have type-level let with arguments? :( E.g. `forall r a. ((r a) ~ IO (Either Text a))` results in `Occurs check: cannot construct the infinite type`.
11:24:25 <Welkin> it's not like lambda calculus
11:24:41 <maerwald> You can't abuse functors for antipatterns like transformers
11:24:54 <kuribas> Welkin: it's a convenient way to structure IO
11:25:04 <Welkin> it's just a damn interface
11:25:11 <EvanR> whats the problem
11:25:36 <maerwald> Shots fired
11:25:42 <Ariakenom> monads are discussed a lot due to their pedagogical properties
11:26:08 <Welkin> and for the ability for people to use buzzwords
11:26:11 <maerwald> Hold my beer, let's settle this outside
11:26:13 <Welkin> and make up monad analogies
11:26:45 <Ariakenom> Monad battle? Monad battle!
11:26:58 <Welkin> you have people talking about how "Promises are monads! Use monads in javascript!"
11:27:01 <Welkin> what!?
11:27:23 <hvr> ...can you bring arrows to a monad fight?
11:27:23 <EvanR> "jQuery is a monad"
11:27:31 <nshepperd1> A monad a day keeps the side effects away
11:27:44 <maerwald> Monads are complexity. So the last thing I try to do when I model my data
11:28:06 <maerwald> Whenever I can avoid monads, I do
11:28:12 <Ariakenom> > monad = complexity
11:28:14 <lambdabot>  <hint>:1:7: error:
11:28:15 <lambdabot>      parse error on input ‘=’
11:28:15 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:28:25 <Welkin> maerwald: and type classes
11:28:38 <maerwald> Applicative have less complexity
11:29:04 <Welkin> type classes seem to be the tool of choice for people who are addicted to extra complex, over-engineered solutions
11:29:22 <maerwald> But haskellers don't care about complexity, they just care about abstraction
11:29:40 <Ariakenom> does "complexity Applicative < complexity Monad" typecheck?
11:29:42 <EvanR> type classes are also useful to people who like logicprogramming
11:30:04 <EvanR> which shouldnt be offensive to people "in the trenches"
11:30:19 <kuribas> maerwald: you don't "model" a monad.  You just notice that your code happens to have the monad pattern, and use that information to simplify the code with all the nice stuff haskell provides.
11:30:24 <Welkin> I'm talking about applications
11:30:30 <Welkin> not research or experiments
11:30:39 <EvanR> "apps"
11:30:43 <EvanR> sounds tastey
11:31:54 <EvanR> this channel is publically logged and your rage will be recorded for all time for all to see. Including God when the time comes
11:31:55 <maerwald> kuribas: when I realize I need to create a monad instance for my data type, I think twice about it and try to remodel it just to avoid that instance
11:32:09 * hackage persistent 2.8.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.8.2 (psibi)
11:32:13 <maerwald> Monads are just too powerful!
11:32:26 <kuribas> maerwald: that doesn't make much sense
11:32:34 <kuribas> maerwald: perhaps an example?
11:32:49 <maerwald> Parsers
11:33:11 <[exa]> Let's play a game: name a language without an informally specified ad-hoc implementation of typeclasses.
11:33:31 <maerwald> If you need the monad instance in a parser, you are doing some complicated shit
11:33:35 <EvanR> OCaml
11:33:43 <[exa]> lol ok you win
11:33:55 <implementation> [exa]: Russian
11:34:00 <maerwald> Or
11:34:03 <implementation> aww, I'm too late
11:34:12 <maerwald> You are using it because you can
11:34:19 <[exa]> implementation: don't worry ou receive the linguistic prize :D
11:34:34 <implementation> yay \o/
11:34:36 <maerwald> (and you could express it it in applicative)
11:34:52 <[exa]> but wait... класс тыпов... found them, sorry.
11:35:02 <Welkin> [exa]: type classes are useful, but they are heavily abused by some, which makes for horrible code
11:35:42 <dyl> Welkin it's a good compromise vs full ML modules though I think.
11:35:54 <EvanR> i wonder if you could implement C with just type classes, wouldnt that be interesting
11:35:54 <Welkin> dyl: I don't know about ml modules
11:35:56 <dyl> Imagine how heavily abused modules would be... and the myriad conventions for their use...
11:35:57 <Ariakenom> like that damn committee? Enum Float
11:35:58 <[exa]> Welkin: that is probably a common destination for any feature whatsoever
11:36:23 <dyl> EvanR That's kind of the design goal of Swift.
11:36:25 <EvanR> modules dont have the backtracking logic solver thing
11:36:27 <dyl> Though it's a little higher level than C.
11:36:48 <dyl> Swift "protocols" are typeclass-ish (though far less powerful than typeclasses in GHC)
11:36:57 <EvanR> backtracking is the wrong word
11:37:05 <Welkin> rust traits are essentially typeclasses
11:37:33 <Welkin> of course java (and c#?) has interfaces
11:37:36 <Welkin> and c++, too
11:39:34 <implementation> Brainfuck doesn't have typeclasses
11:39:54 <[exa]> I saw a typeclass implementation for C++ in norri somewhere
11:40:40 <dsal> go's interfaces are a lot like typeclasses, except they box values.
11:43:30 <c_wraith> I could swear go interfaces bind to values, not types.
11:44:21 <MarcelineVQ> I used to use typeclasses a lot but it turns out I don't spend a lot of time typing so my wpm didn't change much.    Come to think of it, if coders are paid per line them both meanings of typeclasses are worthless to them.
11:44:28 <maerwald> Let's simplify it: go interfaces suck
11:44:29 <dsal> A go interface is a product type with a type and a value.  It's weird because you get into this half-null situation where the type is known, but the value isn't, so the value of the interface variable ≠ nil, but you get nil dereferences, and if you try to print it, it says "nil"
11:44:51 <maerwald> dsal: haha, exactly
11:45:07 <maerwald> That has actually led to weird bugs
11:45:08 <c_wraith> wow, that sounds painful.
11:45:09 <dsal> Well, the advantage to boxing them is that I can have a [Interface].  I can't do that in haskell.  :(
11:45:37 <dsal> The half-nil thing confuses people because it leads to weird bugs when the type is inferred.
11:45:38 <c_wraith> you can do it in ghc, we just work hard to avoid it
11:45:42 <MarcelineVQ> sounds like a  sigma type, is go a dependent language where it always depends?
11:46:16 <c_wraith> you just don't get auto-boxing.
11:46:18 <MarcelineVQ> oh no, I guess it's like, reverse of that, since in sigma the type depends on the value, bleh
11:47:09 <MarcelineVQ> ?depends always it where language dependent a go is type, sigma a like sounds
11:47:09 <lambdabot> Unknown command, try @list
11:53:49 <DigitalKiwi> sssilver knows go :|
11:53:58 <ReinH> I don't think it's fair to say that go's interfaces are like typeclasses. Typeclasses are principled ad-hoc polymorphism.
11:54:20 <ReinH> They are resolved at compile-time.
11:54:38 <dsal> Interfaces are resolved at compile time for the most part.
11:54:39 <EvanR> non ad-hoc ad-hoc
11:55:04 <ReinH> You have to use reflection to do anything generic-like with go interfaces.
11:55:13 <ReinH> Which is a runtime cost.
11:55:21 <ReinH> And it's slow too.
11:55:37 <[exa]> ReinH: the compile time statement doesn't hold as well in haskell, although in much less cases than in other languages
11:56:01 <ggVGc> the best thing about Go, is that you can generate it with haskell
11:56:08 <[exa]> ReinH: polymorphic recursion is an example
11:56:12 <[exa]> ggVGc: +1 lol
11:56:16 <dyl> The best thing about Go is that I don't have to use it.
11:56:24 <ReinH> [exa]: fair point
11:56:29 <dsal> It depends on what you're doing, though.  If you have a function that just wants to write stuff, it takes an io.Writer and any type that complies with that interface works fine.  There's no reflection necessary and it's resolved at compile time.  The function doesn't even have to know what the underlying type is.
11:56:31 <Welkin> it's replacing node, at least
11:56:36 <Welkin> is that progress?
11:56:39 <dyl> I don'
11:56:43 <dyl> I don't think it's replacing node.
11:56:53 <dyl> And, honestly, Go might be the perfect language for that sort of programmer.
11:56:56 <dsal> It's displacing node some.  I never understood why that made sense to anyone.
11:56:56 <Welkin> it is in many places
11:56:58 <EvanR> elixir?
11:57:04 <Welkin> people are switching from node to go or rust
11:57:10 <dyl> node ⇒ rust, lol.
11:57:11 <hyperisco> :t takeWhile
11:57:12 <lambdabot> (a -> Bool) -> [a] -> [a]
11:57:24 <ReinH> Interfaces are closer to structural types.
11:57:25 <Welkin> and switching from rails to pheonix/elixir
11:57:27 <hyperisco> why are these functions not based on Traversable?
11:57:28 <dyl> I would much rather people be using Elixir on the backend, as Erlang/BEAM is very cool BUT...
11:57:28 <ReinH> Than to typeclasses.
11:57:29 <Welkin> which isn't much better o.o
11:57:39 <[exa]> node->whatever is a great development tbh
11:57:41 <EvanR> they are better
11:57:45 <glguy> hyperisco: You can't filter with traversable
11:57:53 <dyl> [exa] node->PHP?
11:57:56 <dyl> You sure?
11:58:00 <dyl> ;p
11:58:02 <Welkin> cgi and perl?
11:58:09 <EvanR> performance wise and "the pile of crap hasnt been written in this language yet"
11:58:14 <[exa]> c'mon guys it's not 1990
11:58:15 <hyperisco> glguy, I was thinking about it slightly wrong. Thanks.
11:58:17 <[exa]> :D
11:58:33 <dyl> I'd much rather Node people be using an Erlang type language though.
11:58:39 <EvanR> how does rust factor into web development whatsoever
11:58:42 <dyl> Don't need to trust them to handle errors well (which they wont).
11:58:45 <Welkin> EvanR: it doesn't
11:58:46 <dyl> EvanR Exactly.
11:58:56 <hyperisco> glguy, I was moreso thinking that once you have foldr then you have a list, then you can do listy things
11:58:59 <Welkin> it's just that the rust community has attracted a lot of js users
11:59:02 <Welkin> they are filtering over
11:59:04 <hyperisco> of course then your result is a list
11:59:06 <Welkin> and writing web servers o.o
11:59:19 <EvanR> elixir makes more sense than rust for that
11:59:19 <dyl> The "node programmer" cohort is basically the programming equivalent of that group of your coworkers who try every new fad diet and now don't eat gluten.
11:59:19 <ReinH> Traversable is about maintaining structure, so you can't use it to do things that modify structure.
11:59:37 <dyl> Elixir makes a hell of a lot more sense for web backends, especially with websockets.
11:59:46 <ReinH> If you're willing to give up the structure, you can just use toList from Foldable.
11:59:48 <dyl> Using Rust just seems... why?
11:59:53 <Welkin> dyl: too bad the language sucks
11:59:59 <Welkin> just use erlang if you want erlang/beam
12:00:01 * dyl uses plain Erlang. 
12:00:17 <systemfault> Rust is the first actual competitor to C++ in 25 years..
12:00:19 <dyl> I don't really want Ruby style syntax slapped on top of my Erlang.
12:00:22 <dsal> I've never tried any of the other languages over beam.  erlang seems fine to me.
12:00:22 <EvanR> if you are attracted to rust from js, why are you not attracted to haskell. i guess because you already wouldve been by now
12:00:31 <dyl> systemfault and would you write a webserver in c++?...
12:00:32 <[exa]> dyl: the usecase is "I'd go with c++ but I don't need the foot shooting"
12:00:39 * hackage tuple-sop 0.1.0.0 - functions on n-ary tuples using generics-sop  http://hackage.haskell.org/package/tuple-sop-0.1.0.0 (ferdinandvw)
12:00:40 <systemfault> dyl: I wouldn't.
12:00:48 <dyl> Yeah, and if you're even thinking "I'd go with C++..." in a web context
12:01:01 <dyl> Your decision-making process is already suspect.
12:01:02 <sssilver> somebody in this channel said "sssilver knows go"
12:01:12 <sssilver> way to bully me
12:01:16 <[exa]> dyl: for a webserver that needs to run on tiny stuff?
12:01:23 <Tuplanolla> Can you take this drivel to #haskell-offtopic?
12:01:33 <dyl> Yes.
12:01:36 <[exa]> agreed.
12:01:40 <EvanR> have you tried Crystal lang? oh sorry
12:01:45 <Tuplanolla> Thanks.
12:02:08 <Welkin> Tuplanolla: way to make a value judgement about our discussion
12:02:19 <ReinH> Ok. Can you take this discussion to off topic?
12:02:31 <EvanR> Tuplanolla evaluated the discussion, and it was bottom
12:04:12 <ReinH> hyperisco: You can get filter if you have a bit more behavior: filter p = foldMap (\a -> if p a then pure a else mempty), which requires Applicative f and Monoid (f a). You really only need Pure and Pointed, but neither are in fashion.
12:04:34 <DigitalKiwi> sssilver lol, sorry
12:04:54 <ReinH> (and Foldable f)
12:05:22 <hyperisco> I've just been writing a lot of code today and wasn't thinking straight
12:05:56 <ReinH> hyperisco: Ok. I think it's interesting though regardless. :)
12:06:00 <hyperisco> there are several functions based on splitting a structure at some point
12:06:20 <hyperisco> take, break, span, drop, so on
12:06:50 <hyperisco> that is the sort of abstraction I am after, which isn't exactly Foldable or Traversable
12:07:00 <hyperisco> nor Witherable
12:07:02 <EvanR> or splitting a Map at a key, which is great
12:07:10 <hyperisco> yes, sure
12:07:50 <hyperisco> so there is a familiar idea of having some sequence-like structure, and it is splittable
12:08:21 <EvanR> meaning, there is a concat operation which reverses the splitting/
12:08:39 <EvanR> is this a monoid with subtraction (monus)
12:08:53 <hyperisco> maybe there is, not sure, presumably
12:09:15 <EvanR> there must be something that explains what splitting means
12:09:31 <hyperisco> agreed
12:09:32 <EvanR> because f a -> Split (f a) could be anything
12:09:54 <hyperisco> depends on how you describe the sequence-like structure as to whether you need a concat to explain split
12:10:13 <EvanR> what other way do you explain split
12:10:31 <EvanR> other than case by case examples
12:10:53 <hyperisco> I am worried about split first
12:11:15 <EvanR> thats what were talking about
12:12:09 <hyperisco> I don't know what the type of split should be
12:12:45 <EvanR> its kind of like the same question as, what should a type class look like that can do "lookup" where i dont tell you what lookup means
12:13:10 <hyperisco> I gave several examples already
12:13:17 <EvanR> "but its obvious that all thes 6 things support lookup"
12:13:27 <EvanR> by example
12:13:37 <EvanR> they just dont agree on a type
12:14:40 <hyperisco> a formulation other than concat is if you can determine if a sequence is a suffix or prefix of another
12:14:48 <EvanR> does it always split into 2
12:14:52 <hyperisco> I don't know
12:15:07 <EvanR> "sometimes" :)
12:15:13 <EvanR> "at least"
12:15:55 <hyperisco> if you split a rose tree on a node I am not quite sure what that would be
12:16:11 <Welkin> kissed by a rose?
12:16:22 <Welkin> kiss from a rose*
12:16:25 <Welkin> oh seal
12:16:36 <EvanR> decomposing a rose tree, i am reminded of one-hole contexts
12:16:47 <EvanR> it splits into two, but not two rose trees.
12:17:08 <richardsd[m]> Hello there
12:18:37 <hyperisco> that recent deriving via paper got me thinking about this stuff
12:19:39 <hyperisco> because you can choose a few features and give efficient instance implementations, under a newtype
12:19:39 * hackage miniutter 0.4.7.0 - Simple English clause creation from arbitrary words  http://hackage.haskell.org/package/miniutter-0.4.7.0 (MikolajKonarski)
12:19:46 <dyl> I'd like to make a suggestion for Hackage: the star scoring system is currently in lambdas... but shouldn't it be in kinds?
12:19:54 <dyl> e.g. *, then * -> *, then * -> * -> *...
12:21:56 <hyperisco> class Splittable a e | a -> e where split :: Monad m => (e -> m Bool) -> a -> m (a, a); join :: a -> a -> a
12:22:34 <hyperisco> isn't so clear where the "sequence-like" comes from
12:23:39 * hackage asset-bundle 0.1.0.0 - A build-time Cabal library that bundles executables with assets  http://hackage.haskell.org/package/asset-bundle-0.1.0.0 (deech)
12:23:42 <hyperisco> hm, also there is a worthwhile distinction between the scanning splits and the indexed splits
12:23:59 <hyperisco> dropWhile/takeWhile/etc scans, because it has to test each element, but drop/take/etc are indexed
12:24:13 <hyperisco> so for certain types there is a more efficient implementation
12:25:26 <hyperisco> then for containers like Map, if you're splitting on a key you can be more efficient as well
12:25:37 <hyperisco> maybe there isn't really a happy one-fits-all
12:26:39 * hackage butcher 1.3.0.1 - Chops a command or program invocation into digestable pieces.  http://hackage.haskell.org/package/butcher-1.3.0.1 (lspitzner)
12:40:47 <zincy> Whats the standard function for parsing a bytestring to JSON using Aeson?
12:40:54 <zincy> sorry from JSON
12:41:21 <Welkin> fromJSON toJSON
12:41:46 <zincy> Say I have the following as a bytestring - "(\"Xena\",\"Xena\")"
12:42:04 <Welkin> > fromJSON "lol" :: String
12:42:06 <lambdabot>  error:
12:42:06 <lambdabot>      Variable not in scope: fromJSON :: [Char] -> String
12:42:43 <zincy> Ok so convert bytestring to string then call fromJSON on it?
12:43:02 <Welkin> > Data.Aeson.Generic.fromJSON "lol" :: String
12:43:04 <lambdabot>  error:
12:43:05 <lambdabot>      Not in scope: ‘Data.Aeson.Generic.fromJSON’
12:43:05 <lambdabot>      No module named ‘Data.Aeson.Generic’ is imported.
12:43:08 <Welkin> meh
12:43:09 <Welkin> no
12:43:18 <Welkin> use bytestring directly
12:43:45 <Welkin> https://hackage.haskell.org/package/aeson-1.3.0.0/docs/Data-Aeson.html#t:FromJSON
12:44:11 <EvanR> zincy: this question seems garbled. "(\"Xena\",\"Xena\")" isnt valid json
12:44:33 <EvanR> you cant parse t
12:44:36 <Welkin> god damn it
12:44:36 <EvanR> it
12:44:40 <Welkin> these docs are !!!
12:44:45 <nkaretnikov> https://www.irccloud.com/pastebin/x1nDB855/
12:44:56 <nkaretnikov> any help with this? trying to print a mutable array
12:45:23 <Welkin> wtf happened!?!?!
12:45:28 <Welkin> why are so many docs missing?
12:45:31 <zincy> EvanR - Thats true thanks
12:45:33 <Welkin> or these functions are gone
12:45:39 <nkaretnikov> i'm pretty sure that i have to hack around this somehow, maybe freeze the array first or something, but it would be nice to understand why it happens
12:45:40 <Welkin> was there some huge change to aeson?
12:45:46 <EvanR> hackage was down for a few days
12:45:49 <EvanR> maybe there was dataloss
12:45:57 <Welkin> http://hayoo.fh-wedel.de/?query=fromJSON
12:46:00 <Welkin> that gives me the correct result
12:46:06 <Welkin> the hackage docs are fucked though
12:46:21 <zincy> For Hackage I am looking at an older version of the Aeson docss
12:46:53 <EvanR> i dont see anything wrong
12:46:56 <Welkin> Data.Aeson.Generic doesn't exist though
12:46:57 <Welkin> wtf?
12:47:36 <EvanR> always a better idea to generate docs locally anyway
12:47:44 <EvanR> to get at hidden modules
12:48:03 <Welkin> https://hackage.haskell.org/package/aeson-1.3.0.0/docs/Data-Aeson.html#v:fromJSON
12:48:06 <Welkin> jesus
12:48:09 <Welkin> there we go
12:49:04 <Welkin> zincy: that is what you want
12:50:44 <EvanR> zincy's question needs to be redacted to make sense
12:51:04 <Welkin> > Data.Aeson.fromJSON "lol" :: Result String
12:51:07 <lambdabot>  error:
12:51:07 <lambdabot>      Not in scope: ‘Data.Aeson.fromJSON’
12:51:07 <lambdabot>      No module named ‘Data.Aeson’ is imported.
12:51:11 <EvanR> at first it wasnt clear if they were going to bytestring or from, now its not clear whether they are dealing with json
12:51:19 <Welkin> lol
12:51:22 <Welkin> maybe csv?
12:51:59 <EvanR> the best data format of all time
12:58:00 <zincy> oh fromJSON takes a Value
12:58:16 <zincy> How do I go from a string to aeson Value?
12:58:18 <EvanR> think of Value as "json"
12:58:34 <zincy> Ah right
12:59:20 <zincy> Maybe parseJSON
12:59:24 <EvanR> decode :: FromJSON a => ByteString -> Maybe a
12:59:48 <EvanR> Value for example has a FromJSON instance
13:00:38 <zincy> So how does decode know what type a is?
13:00:44 <Welkin> context
13:00:44 <EvanR> it doesnt, its your choice
13:00:46 <zincy> Or how do we supply it? Type annotation?
13:00:47 <Welkin> or you tell it
13:00:51 <EvanR> yes
13:00:57 <EvanR> or it might be inferred
13:01:03 <EvanR> if its ambiguous, it wont compile
13:01:06 <zincy> In type signature would that suffice?
13:01:07 <Welkin> generally you don't want to annotate it
13:01:09 <EvanR> yes
13:01:10 <Welkin> it should be inferred
13:01:17 <zincy> Ah
13:01:30 <Welkin> all top-level definitions should have type signatures
13:01:35 <Welkin> that should be enough
13:01:35 <EvanR> if it cant figure it out, youll know
13:01:36 <zincy> Ok what if I have a list of possible types it may decode to
13:01:58 <Welkin> zincy: then specify it explicitly
13:01:59 <EvanR> well, you can do (decode x, decode x, decode x, decode x)
13:02:05 <EvanR> to get 4 different results
13:02:12 <zincy> and then filter out the Nothings?
13:02:25 <EvanR> no
13:02:37 <EvanR> what are you really trying to do
13:03:07 <zincy> Writing a client side app that has a type called Action that is a sum type
13:03:14 <zincy> Action type is used to update app state
13:03:29 <zincy> websocket msg comes in as JSON and could be any one of set of possible actions
13:03:36 <EvanR> so you might want to implement FromJSON for Action
13:03:43 <EvanR> you dont have multiple types after all, its 1 sum type
13:03:53 <zincy> ooh I like it
13:04:09 * hackage aws-cloudfront-signed-cookies 0.2.0.0 - Generate signed cookies for AWS CloudFront  http://hackage.haskell.org/package/aws-cloudfront-signed-cookies-0.2.0.0 (chris_martin)
13:04:53 <EvanR> there are examples in there for "parsing" a Value to either get your type (Action) or fail, that is how FromJSON works
13:06:21 <EvanR> you can also convert to Action manually by decoding to get a Value and use a normal function on it
13:06:34 <EvanR> you can also generate FromJSON instances using Generic technology
13:07:25 <zincy> hmm I guess manually deriving is better for learning at first right
13:07:48 <EvanR> writing a Value -> Parser a  is good to be able to do
13:08:02 <EvanR> Value -> Parser Action in this case
13:08:41 <EvanR> you will learn Applicative and Monad for parsing, if you dont already know how
13:08:50 <EvanR> (and Functor)
13:09:08 <zincy> cool thanks
13:18:05 <dsal> Much of my code that does stuff like this is littered with <|>
13:24:05 <dsal> Looks like I don't do any of that with JSON, though.  Wonder how I managed that.
13:24:19 <OtterCoder> Hi! I can't figure out how to edit getMessages in this example to allow me to return my new, more complex message type: http://lpaste.net/364770
13:24:52 <OtterCoder> Every example I can find anywhere just shows single field return.
13:26:06 <ZeuPiark> hell
13:26:23 <OtterCoder> ?
13:26:27 <lemmih> OtterCoder: What's your new, more complex message type?
13:27:10 <OtterCoder> lemmih: The original just returned a string. I have a data structure now. I'm just trying to learn all this.
13:27:43 <EvanR> your FromRow looks right
13:27:44 <lemmih> OtterCoder: What's wrong with the code you have?
13:28:12 <OtterCoder> Couldn't match expected type ‘a1 -> Message’
13:28:21 <OtterCoder> with actual type ‘Database.SQLite.Simple.Internal.RowParser a0’
13:29:02 <lemmih> OtterCoder: Which line?
13:29:17 <OtterCoder> Line 51
13:29:30 <OtterCoder> It's yelling about fromRow.
13:30:11 <lemmih> OtterCoder: Drop the 'fmap (map fromRow)' stuff. 'query_' will do that for you.
13:30:12 <OtterCoder> Am I maybe importing a definition from the sqlite module that's overriding what I've got?
13:31:08 <OtterCoder> Ok... I don't know how to pull it apart. It starts yelling about random lines in the do monad when I do...
13:31:34 <dsal> It's difficult for us to imagine what you're seeing.
13:32:00 <EvanR> my crystal ball works great, i just dont want to spoil it for you
13:32:03 <lemmih> OtterCoder: Show us the code.
13:32:15 <OtterCoder> dsal: Sorry. I'm just at a loss for what to describe. I've got the entire program pasted.
13:32:22 <lemmih> OtterCoder: It's only a single line so you can just post it here.
13:32:31 <EvanR> OtterCoder: also lpaste the full error response
13:33:22 <OtterCoder> http://lpaste.net/364771
13:34:03 <lemmih> OtterCoder: Delete the 'fmap (map fromRow)' stuff and show us the new code.
13:35:09 <lemmih> OtterCoder: The definition for 'getMessages' is just a single line. You can post it here in chat.
13:36:18 <OtterCoder> getMessages :: Handler [Message]
13:36:30 <OtterCoder> I'm so overwhelmed.
13:36:45 <Welkin> HAndler?
13:36:51 <Welkin> what are you using?
13:36:55 <OtterCoder> Servant
13:36:58 <lemmih> OtterCoder: Ignore the type signature. Just paste the definition. And please remove newlines such that it only takes up a single line.
13:37:15 <Welkin> OtterCoder: don't start with servant if you are not already very experienced with haskell and http
13:37:18 <OtterCoder>         getMessages = liftIO $ withConnection dbfile $ \conn -> query_ conn "SELECT name, text FROM messages"
13:37:18 <Welkin> use scotty
13:37:46 <lemmih> OtterCoder: Excellent! Does that code work?
13:38:06 <OtterCoder> Welkin: I've done toy stuff in Haskell before, and I'm pretty handy with Elm, but this is another level.
13:38:52 <OtterCoder> lemmih: No, Here's the errors at the end of the paste: http://lpaste.net/364772
13:39:22 <lemmih> OtterCoder: Great. We fixed one issue and can now deal with the next.
13:39:59 <dsal> I've never used this SQLite API.  Now I want to.
13:40:25 <Welkin> dsal: sqlite-simple?
13:40:25 <OtterCoder> lemmih:  Oh. I hadn't thought that was better when I was floundering on my own.
13:40:34 <lemmih> OtterCoder: Now you correctly query the messages from the database but you haven't defined how to render them.
13:40:36 <dsal> Welkin: Yeah, or any others.
13:40:44 <Welkin> dsal: I am uisng postgresql-simple
13:40:46 <Welkin> it is amazing
13:40:48 <Welkin> very good docs
13:40:51 <dsal> I've been wanting to do that, too.
13:40:53 <dsal> "good docs" you say?
13:41:00 <Welkin> https://hackage.haskell.org/package/postgresql-simple
13:41:01 <Welkin> yes
13:41:05 <Welkin> actual docs
13:41:09 <Welkin> not just generated crap
13:41:19 <Welkin> *and* there is postgresql-simple-migrations
13:41:22 <Welkin> to handle all migrations
13:41:35 <Welkin> https://hackage.haskell.org/package/postgresql-simple-migration
13:41:51 <lemmih> OtterCoder: What's the mime-type of a Message?
13:41:52 <dsal> Nice.  Thanks.  I've heard good things about this one as well.  Haven't used a database at home in a while.  SQLite and Postgres have always been my RDBMS favorites.
13:42:03 <OtterCoder> lemmih: application/json
13:42:52 <OtterCoder> Ok. Hang on.
13:43:05 <OtterCoder> Oh!
13:43:21 <OtterCoder> I think I'm seeing where to go.
13:48:39 * hackage micro-recursion-schemes 5.0.2.1 - Simple recursion schemes  http://hackage.haskell.org/package/micro-recursion-schemes-5.0.2.1 (vmchale)
13:58:01 <dsal> One of the PRs I sent to get this package working on stack latest made it only work on stack latest.  :(  Hopefully the package itself makes it into stack shortly, though.
13:58:26 <dsal> (s/latest/nightly/g)
14:01:42 * hackage gmpint 0.1.0.10, fast-arithmetic 0.4.0.0 (vmchale): https://qbin.io/clubs-fleece
14:12:39 * hackage language-ats 1.2.0.7 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.2.0.7 (vmchale)
14:33:19 <pile> 123
14:33:57 <spruit11> 456
14:34:52 <pile> Glad to see so quiet
14:36:25 <pile> ChanServ
14:37:12 <infinisil> > take 3 . map chr $ [55..]
14:37:14 <lambdabot>  "789"
14:37:57 <pile> Hey ;)
14:47:09 * hackage shellwords 0.1.0.0 - Parse strings into words, like a shell would  http://hackage.haskell.org/package/shellwords-0.1.0.0 (PatrickBrisbin)
14:55:07 <dsal> Is there a way to offline all docs I care about?
14:55:12 <Welkin> yes
14:55:14 <Welkin> build with haddock
14:55:25 <dsal> Is that just per-project?  I suppose that'd be OK.
14:55:39 <Welkin> I think there might be a way to set it up in some config file to always build
14:55:53 <Welkin> cabal should have some kind of option for that I would assume
14:56:06 <dsal> Related, does hoogle have a way to tell me what package contains results?
14:56:30 <Welkin> https://www.haskell.org/cabal/users-guide/nix-local-build.html?highlight=haddock#haddock-options
15:05:34 <c> Lq
15:11:02 <davean> da-x_: YOu can set it in cabal's config for globally building them
15:13:33 <Welkin> davean: is that the same as what I linked?
15:15:09 <davean> Welkin: not at all, because you specified a per-project file.
15:15:26 <davean> You'd have to set that in every cabal.project
15:15:41 <davean> and that only relates to new-*
15:16:45 <Welkin> okay
15:17:01 <Welkin> so you mean set it in your global cabal config
15:18:01 <Welkin> I see something in ~/.cabal/config under haddock-options
15:19:03 <Welkin> https://www.haskell.org/cabal/users-guide/installing-packages.html?highlight=haddock#setup-haddock
15:19:13 <Welkin> that's all I found in the guide so far
15:25:11 <hc> Hi all, could someone please trigger the doc build for the saltine package?
15:25:17 <hc> on hackage, I mean
15:25:36 <Welkin> o.o saltine
15:25:44 <Welkin> docs fail to build all the time
15:25:53 <Welkin> you have to build them yourself and upload them if you want them updated
15:26:03 <Welkin> otherwise just build them locally and don't bother
15:26:26 <hc> The hackage maintainers have the possibility to run the doc build independently of the real build
15:26:38 <hc> building saltine fails on hackage due to a native lib dependency
15:27:28 <glguy> hc: there you go
15:27:34 <hc> Thanks! :-)
15:43:58 <octopus__> Hey
15:51:39 * hackage pointfree-fancy 1.1.1.7 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-fancy-1.1.1.7 (vmchale)
15:56:09 <mckeankylej> does anyone know of a better way of producting void when you have a refl that something is equal even when it isnt? This is my best attempt but its not very general. https://gist.github.com/mckeankylej/299606a6b3328f4360d230eb05198192
15:57:34 <lyxia> mckeankylej: \case {}
15:57:39 * hackage influxdb 1.6.0 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-1.6.0 (MitsutoshiAoe)
15:59:13 <mckeankylej> lyxia: thanks that worked
15:59:38 <lyxia> :)
16:03:48 <mckeankylej> lyxia: the problem now is if you make a bad pokemon such as Pokemon Grass Grass it doesnt fail to compile it just gives an non exhaustive pattern match warning
16:04:55 <glguy> mckeankylej: What're you trying to do with that constraint?
16:06:35 <mckeankylej> glguy: so the idea is a pokemon has two types and the type types cant be the same
16:06:48 <mckeankylej> the two types*
16:07:30 <shapr> chessai just wrote something to do that today
16:07:51 <shapr> like, exactly that Pokemon thing
16:08:16 <mckeankylej> shapr: me and chessai are good friends :)
16:08:19 <shapr> oh ok
16:08:23 <mckeankylej> we are talking in teamspeak rn
16:08:24 <glguy> mckeankylej: I added a comment to your gist
16:09:14 <mckeankylej> "thats a powerful solution"
16:09:23 <mckeankylej> - taktoa (remy goldschmidt)
16:12:58 <lyxia> mckeankylej: doesn't it warn?
16:13:51 <lyxia> it does with -Wall.
16:26:36 <zincy> If I have to derive a typeclass manually because of one data constructor in a sum type what is the concise way of doing so?
16:27:06 <hpc> add it to the deriving list of the data definition
16:27:30 <zincy> Tried that - getting -No instance for (Show (WebSocket Message))       arising from the first field of ‘HandleWebSocket’         (type ‘WebSocket Message’)     Possible fix:       use a standalone 'deriving instance' declaration,         so you can specify the instance context yourself
16:29:30 <lyxia> zincy: what is the difference between "derive automatically" and "derive manually"
16:29:43 <lyxia> isn't the latter just "implement"
16:30:20 <zincy> Not sure what you mean
16:31:01 <lyxia> "derive manually" sounds like an oxymoron.
16:31:08 <Welkin> you type with your fingers
16:31:39 <zincy> Not sure I follow - manually implies less automation
16:31:51 <zincy> so yes more typing
16:33:32 <lyxia> zincy: anyway... is WebSocket a type you defined?
16:33:57 <zincy> Its defined by the library called Miso which I am using
16:34:53 <zincy> If I ... implement an instance of show for Websocket will I be able to ... derive my Show instance for the Action type
16:35:06 <lyxia> yes
16:35:39 <lyxia> it's strange they don't implement it in the first place
16:36:00 <zincy> How do you learn how typeclasses are derived by GHC?
16:37:10 <fishythe_> depends on which typeclasses you're talking about and which mechanism you're using to derive them
16:38:04 <lyxia> you can see the generated code by using GHC's -ddump-deriv option
16:43:04 <zincy> Thanks!
17:07:13 <zincy> How does Aeson know how to derive FromJSON typeclasses from record types when the {-# LANGUAGE DeriveAnyClass             #-} is enabled?
17:11:56 <EvanR> deriving a class using that extension just generates a stub instance for that type
17:12:43 <zincy> Whats a stub instance?
17:12:59 <EvanR> none of the methods are implemented specifically for that type
17:13:14 <EvanR> it will use default implementations
17:13:52 <EvanR> like
17:14:21 <EvanR> instance MyClass MyType where {}
17:15:39 <zincy> So the language extension has its own set of default implementations?
17:16:01 <EvanR> no, the defaults are defined in the class
17:16:43 <zincy> So what does the DeriveAnyClass extension do?
17:17:19 <EvanR> lets you put deriving (WhateverClass)
17:17:56 <zincy> So what is the normal set of restrictions on that classes you can define?
17:18:03 <zincy> *the
17:18:11 <EvanR> the class you can derive?
17:18:14 <zincy> yes
17:18:22 <EvanR> theres a special set of them defined by the language standard
17:18:33 <EvanR> Eq, Ord, Show, Enum, etc
17:19:33 <zincy> Ah right, so normally you can't derive external library typeclasses?
17:19:41 <EvanR> correct
17:19:46 <nshepperd1> zincy: the default FromJSON implemention probably uses the Generic instance for your typeclass
17:19:48 <zincy> Thanks makes perfect sense
17:19:54 <nshepperd1> Er, for your type
17:20:17 <EvanR> the special ones become useful code according to hard coded strategies
17:20:39 <zincy> What do you mean by hard coded strategies?
17:20:58 <nshepperd1> You can find the exact definition in the source code for the aeson package, wherever the typeclass is defined
17:21:14 <EvanR> zincy: have you ever written an Eq instance?
17:21:25 <zincy> Once :D
17:21:46 <EvanR> whatever you did, there is a hard coded strategy to do that for you
17:21:59 <EvanR> you activate it with deriving (Eq)
17:22:08 <EvanR> there is another one for Ord
17:23:19 <zincy> Ah ok, awesome
17:23:21 <EvanR> deriving AnyClass results in an instance you can control with code, in the class definition
17:23:30 <EvanR> where Generic might help
17:24:17 <zincy> Im having trouble defining an instance for show for a type imported from an external library
17:24:54 <EvanR> oh yeah ?
17:25:18 <zincy> WebSocket - https://github.com/dmjio/miso/blob/b3ec1a98bcae511ebd43f7953ffc36592149aab9/ghcjs-src/Miso/Subscription/WebSocket.hs
17:25:25 <EvanR> https://wiki.haskell.org/Orphan_instance
17:27:43 <zincy> Is that article telling me to wrap the WebSocket type in a new type?
17:28:04 <EvanR> well you havent told me exactly the problem yet
17:28:13 <EvanR> but what you said would work
17:31:55 <zincy> I am struggling to import the data constructor for the type
17:32:06 <zincy> src/Main.hs:70:8: Not in scope: data constructor ‘WebSocket’
17:32:25 <zincy> Even though I am importing the module in which its defined
17:32:25 <zincy> import           Miso.Subscription.WebSocket
17:32:26 <EvanR> did they export it
17:33:05 <EvanR> looks like yes they did
17:33:22 <EvanR> all 4 of them, none of which are WebSocket
17:34:02 <zincy> Oh they are the data constructors
17:34:19 <zincy> I was confusing types and data constructors I think
17:34:41 <EvanR> type ctor constructs a type, as in Maybe Char
17:34:56 <EvanR> data ctor constructs a value
17:35:04 <EvanR> as just Just 'c'
17:35:08 <EvanR> as in
17:35:39 <zincy> Types are made instances of TypeClasses though right ? not values
17:35:50 <EvanR> yes
17:35:53 <zincy> Well concrete types
17:36:40 <EvanR> so youre getting some error about some code
17:37:02 <zincy> oh
17:37:14 <zincy> Think I was trying to pattern match on the type name
17:37:15 <zincy> oops
17:41:15 <kamil___> anyone could help me with something related to cryptography? i know it isn't connected to haskell but u guys are always op with knowledge
17:43:22 <fishythefish> kamil___: off topic for the channel, but message me if you want
17:44:11 <EvanR> also #crypto
17:50:08 <dschubba> Hello haskellers. I want to understand the development of some features from its historic point of view. I would be pleased to know in wich version of GHC each language extension was added, Is there a way to do this with no so much pain?
17:52:23 <fishythefish> dschubba: http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html
17:52:56 <fishythefish> each section tells you which version of ghc added support for the given extension
17:55:14 <dschubba> Oh, this is what I was looking for. I was sure that I saw this before. Thanks for your answer!
18:11:18 <caryoscelus> hmm, can anyone suggest what extension could allow ghc to infer class-constrained types (hopefully i'm using right terminology) for functions?
18:11:46 <caryoscelus> example: sayHello = putStrLn "Hello" is allowed without explicit type
18:12:02 <caryoscelus> fancyGet = get is not
18:12:34 <lyxia> NoMonomorphismRestriction
18:13:08 <lyxia> the issue is with function definitions with no arguments on the LHS
18:13:41 <caryoscelus> lyxia: thanks!
19:26:49 * hackage serverless-haskell 0.4.3 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.4.3 (AlexeyKotlyarov)
20:37:56 * hackage dynamic-graph 0.1.0.12 - Draw and update graphs in real time with OpenGL  http://hackage.haskell.org/package/dynamic-graph-0.1.0.12 (adamwalker)
20:42:19 * hackage sdr 0.1.0.11 - A software defined radio library  http://hackage.haskell.org/package/sdr-0.1.0.11 (adamwalker)
21:30:36 <Focu5> hello
21:30:48 <Focu5> can somebody help me understand recursion schemes
21:31:14 <Focu5> in particular how to go from a functor to Fix f
21:31:24 <Focu5> the code im working on is here https://repl.it/repls/NarrowNumbTitle
21:32:03 <Focu5> my brain just refuses to comprehend
21:47:34 <Cale> Focu5: I might be able to help
21:47:56 <Cale> Focu5: I'm not sure I understand the question though...
21:48:26 <Cale> fixify doesn't quite make sense
21:50:57 <Cale> Focu5: What did you hope for fixify to do?
21:51:50 <Focu5> i want to take a ConsF ConsF ... ConsF type and convert it to a Fix ConsF so i could use it with cata
21:51:56 <Focu5> basically i want to just use cata
21:52:04 <Focu5> but i feel like im missing something
21:53:06 <iqubic> What is cata? I feel like an uniformed person.
21:53:21 <Focu5> a more generalized fold
21:53:28 <iqubic> How so?
21:53:42 <iqubic> :t cata
21:53:44 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
21:53:52 <iqubic> What the heck is Mu?
21:54:03 <iqubic> :t foldr
21:54:05 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
21:54:08 <Cale> Mu is what is called Fix in Focu5' module
21:54:28 <Cale> So let's look at how we'd write foldr in terms of cata
21:54:39 <iqubic> Really? Did Focu5 write cata?
21:54:42 <yasoumain> how do i represent a float as a hex
21:54:47 <Cale> If we have a function ListF a b -> b
21:54:58 <Cale> Say f :: ListF a b -> b
21:55:18 <iqubic> Sorry, I actually have to go now.
21:55:20 <Cale> then f will act somehow on Nil, and somehow on ConsF a b
21:55:26 <iqubic> sorry I can't be around.
21:55:30 <Focu5> cata and others are from a paper on recursion schemes (the famous banana paper)
21:55:41 <iqubic> I need to read that.
21:55:47 <blankhart> https://bartoszmilewski.com/2013/06/10/understanding-f-algebras/
21:55:56 <Cale> That is, say we have
21:56:01 <Cale> f Nil = x
21:56:08 <Focu5> you can see this blog to have a better understanding http://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/
21:56:13 <Cale> f (ConsF a b) = g a b
21:56:30 <Cale> Then we have x :: b, and g :: a -> b -> b
21:56:37 <Cale> which look a lot like the arguments to foldr
21:56:57 <Cale> and in fact, foldr g x will be the same thing as cata f
21:57:09 <Cale> well, modulo the way in which we're encoding the list
21:57:28 <yasoumain> hi
21:57:34 <Cale> There's a correspondence between [a] and Fix (ListF a) which is given by
21:57:40 <Cale> fromList [] = In Nil
21:57:53 <Cale> fromList (x:xs) = In (ConsF x (fromList xs))
21:58:10 <Cale> and of course, we can just as easily go the other way
21:58:13 <yasoumain> i need someone to explain me how do i print a float as a hex?
21:58:51 <Focu5> ok, i think i was being to general in getting Fix ConsF
21:59:11 <Focu5> is it possible to use fmap to "fixify" any functor?
21:59:39 <Cale> Well, I don't know what your "fixify" function was meant to be, but it's a type error as written
21:59:50 <Focu5> or well any fixed point encoded functor (i think is the term)
22:00:22 <Cale> yasoumain: Example? You mean you want to render 1/16 as 0.1?
22:00:22 <Focu5> fixify was meant to take any least fixed pointer functor type such as ConsF and turn it into a Fix f
22:00:32 <Focu5> since i looked at recursion-schemes library
22:00:51 <Cale> You're not meant to use ConsF on its own so much
22:01:07 <Focu5> and it seems to be able to just work (with converting to the base functor and then Fix ing it)
22:01:12 <blankhart> ConsF is a data constructor, not a type
22:01:12 <Cale> You're meant to take the fixed point of it, and then you cata on the resulting structures.
22:01:18 <Cale> er
22:01:22 <Cale> sorry, yes, ListF
22:01:56 <Cale> ListF a is the thing whose fixed point is isomorphic to the type of lists
22:02:02 <Cale> (of values of type a)
22:02:23 <yasoumain> n - 0x10000000000055
22:02:42 <yasoumain> if i printed n  it will give me the decimel
22:03:00 <Cale> You can use showHex from Numeric
22:03:01 <yasoumain> how do i convert dec to hex
22:03:03 <Cale> :t showHex
22:03:04 <lambdabot> (Show a, Integral a) => a -> ShowS
22:03:11 <Focu5> ok that makes sense
22:03:20 <Cale> > showHex 0xcafebabe ""
22:03:23 <lambdabot>  "cafebabe"
22:03:34 * hackage unliftio-pool 0.1.0.1 - Data.Pool generalized to MonadUnliftIO.  http://hackage.haskell.org/package/unliftio-pool-0.1.0.1 (BardurArantsson)
22:04:14 <yasoumain> ty ^^
22:04:31 <Focu5> then im just wondering how recursion-schemes does it where it uses a typeclass and faimily to convert from simple type to it's least fixed point functor and then to Fix f
22:04:58 <Cale> Focu5: If you have a recursively-defined algebraic data type (which doesn't use polymorphic recursion or anything too fancy like that), it's easy to pull out the corresponding thing that you'd apply Fix to, by replacing all the recursive occurrences of the data type with a new parameter
22:05:08 <Cale> e.g. if we have
22:05:55 <Cale> data Nature a = Rock a | Stream a (Nature a) | Bush (Nature a) (Nature a)
22:06:10 <Cale> Then you'd get:
22:06:28 <Cale> data NatureF a b = RockF a | StreamF a b | BushF b b
22:06:57 <Cale> and so it's pretty easy to see that Fix (NatureF a) is effectively the same thing as Nature a
22:07:17 <blankhart> Focu5, i think the only general way to create an actual value of type Fix f is to have a data constructor for f a that does not depend on a
22:07:28 <Focu5> ok
22:07:47 <blankhart> that cannot be achieved parametrically because there is no guarantee that f has a data constructor independent of a
22:08:22 <Cale> We could do something like Compose Maybe f
22:08:40 <Focu5> because to me it seems that since Nature a and Fix (NatureF a) are essentailly the same thing it should be reasonable to have a generic way to go from one to the other, but i think im getting too general
22:09:37 <Cale> Yeah, there's not an easy way to automatically construct that relationship. You might be able to write a bunch of Template Haskell to do it.
22:09:54 <blankhart> see the blog post above where it says: You might ask yourself: Are there any values of the type Fix ExprF at all? Is this type inhabited? It’s a good question and the answer is yes, because there is one constructor of ExprF that doesn’t depend on a.
22:10:00 <Focu5> so the reason recursion-schemes can go from say [a] to Fix (ListF a) and then cata is because it's using ad hoc polymorphism with the Base class
22:10:45 <blankhart> isn't Fix (ListF a) a kind error?
22:10:54 <Cale> or... not-quite-parametric polymorphism anyway :)
22:11:24 <Cale> (I usually don't like referring to type classes as ad-hoc polymorphism -- they're sort of a substitute for it)
22:11:25 <Focu5> yes
22:11:44 <Cale> blankhart: no, because ListF has two type parameters
22:11:46 <Focu5> it should be Fix ListF i think
22:11:57 <Focu5> er yeah there are two
22:11:59 <Cale> Fix :: (* -> *) -> *
22:12:06 <Cale> ListF :: * -> * -> *
22:12:07 <Focu5> ListF a b so ListF a is the functor
22:12:12 <Cale> ListF a :: * -> *
22:12:18 <Cale> Fix (ListF a) :: *
22:12:19 <blankhart> oh yeah i see
22:13:37 <Focu5> ok i understand it much better
22:13:41 <Focu5> thanks all
22:14:50 <yasoumain> hi
22:15:24 <yasoumain> i tried to use showHex, it worked but not on the float number
22:15:29 <yasoumain> 9.02035903560806
22:15:50 <yasoumain> i just need the hex of that nnumber by haskell
22:17:06 <yasoumain> it should look like 0xXXXX
22:17:16 <yasoumain> starting with 0X
22:18:55 <yasoumain> can some one help me
22:22:28 <robstr> yasoumain: https://hackage.haskell.org/package/base-4.11.0.0/docs/Numeric.html#v:showHex maybe showHFloat ?
22:24:23 <yasoumain> reading it now,,
22:25:32 <yasoumain> 9.02035903560806
22:26:38 <yasoumain> i need this number to tuen hex and look loike 0xSOMETHING
22:27:07 <pikajude> is there a library for insertion-order sets
22:27:11 <pikajude> or should I just use a Map
22:33:14 <blankhart> Cale, if you could express in a constraint that you had a valid recursively defined ADT (i.e., one with a termination condition) you could write fixify, no?  but the typeclass defining the constraint would consist of a function with the signature of fixify.
22:34:15 <dpyro> is there anything like a fixed length byte array in haskell? i want to enforce that all bytestrings that are of that type are a certain length
22:35:11 <blankhart> i.e., just to say that fixify is available only for recursively defined ADTs
22:35:44 <blankhart> they are the same assertion
22:37:02 <yasoumain> i have this error now Module ‘Numeric’ does not export ‘showHFloat’
22:40:04 <robstr> yasoumain: yea I saw this too, I'm still not familiar with the haskell ecosystem, this is included in base 4.11 but you could check out https://hackage.haskell.org/package/FloatingHex
22:43:29 <yasoumain> ty robstr
22:45:28 <robstr> yasoumain: you can search for functions on hoogle.haskell.com
22:59:51 <cocreature> *hoogle.haskell.org
23:01:38 <EvanR> dpyro: its possible to build something like that, but i dont see a package for it
23:01:54 <EvanR> unless you want to use Vect n Word8
23:02:23 <cocreature> which isn’t such a bad representation
23:02:52 <cocreature> although iirc vector-sized doesn’t provide unboxed vectors which is a bit annoying
23:03:02 <EvanR> its not a bad interface
23:03:25 <EvanR> but the linked list backend is pretty bad
23:03:56 <cocreature> oh I thought of vector-sized which is a wrapper around the vector package but I guess that type is called Vector not Vect
23:04:34 <ZeuPiark> hello
23:06:02 <dpyro> 🤔
23:06:47 <EvanR> so theres two packages... vector-sized and sized-vector...
23:07:31 <dpyro> 🤔🤔🤔
23:07:40 <EvanR> i see diamond ?
23:08:10 <EvanR> https://hackage.haskell.org/package/vector-sized-1.0.0.0/docs/Data-Vector-Sized.html
23:08:30 <EvanR> this uses the "stuff you can do in haskell i was thinking of"
23:08:36 <EvanR> this uses the "stuff you can do in haskell" i was thinking of
23:15:29 <cocreature> "sized-vector" is apparently deprecated in favor of "sized" which also seems to take a newtype approach although it seems to be more flexible on which type is wrapped
23:25:19 <Cale> dpyro: I usually wouldn't recommend putting that kind of information at the type level in Haskell though -- at least if you end up wanting to do type level arithmetic, that way leads to madness.
23:35:34 <jle`> it doesn't really require dependent types unless you want dynamically changing sizes
23:35:55 <jle`> but fixed length types if they are known at compiletime are more or less the same as using tuples
23:36:07 <jle`> basically data V5 a = V5 a a a a a
23:36:53 <jle`> if you work with or produce things of different sizes then you will start stepping into the dependent type world
23:38:13 <EvanR> i dont think that scales if chose e.g. size 256 or 4096
23:38:51 <EvanR> also you can easily hardcode a size like 256 into a smart constructed newtype over ByteString
23:39:01 <EvanR> but what if you didnt want to hard code the number
23:42:10 <jle`> EvanR: i mean that doing size 256/size 4096 has an API that is pretty much the same as if you were writing it out like data V5 a = V5 a a a a a
23:42:35 <jle`> but yeah, if you *don't* want to hard code the number, then you are going down the road to dependent types
23:42:50 <EvanR> V5 a a a a a has no api
23:43:06 <jle`> but if your situation is hard-coded sizes (which is often the case) then it should be fine
23:43:10 <EvanR> i mean, its \x y z u v -> ...
23:43:32 <EvanR> a 4096 tuple probably wouldnt be fine
23:44:00 <jle`> yeah, having a vector with a length parameter that is hard-coded is more or less the same as constructing a type with a hard-coded inherent length
23:44:20 <jle`> it's not a particularly magical type
23:44:25 <EvanR> you could say its isomorphic
23:44:47 <jle`> yeah, my point is that using it doesn't require any fancy mechanisms or dependent types
23:44:51 <EvanR> but they have wildly different APIs and performance
23:45:44 <jle`> mhm, yes, it will be different.  but using it isn't any harder or easier than any other haskell type in particular, and is something a beginner haskeller should be comfortable with
23:46:06 <EvanR> my followup was, no it doesnt need dependent types. but it might not need dependent types if you just want a fixed size, but the size of only known at runtime
23:46:21 <jle`> it's only when you don't hard-code the lengths, or write code polymorphic over lengths, or manipulate lengths/changing lengths, then you mights tart needing dependent types
23:46:35 <EvanR> for instance the reflection paper uses "arithmetic mod N" as an example of this
23:47:27 <EvanR> you want to do arithmetic mod N in this area of the code, but N is determined somewhere near the beginning of the program, maybe from a config file
23:48:04 <jle`> yeah, but that's something i'd attach with a warning, it's not quite a beginner level technique
23:48:08 <EvanR> you dont need different Ns to interact
23:48:24 <EvanR> i agree
23:48:26 <jle`> but using fixed length vectors if the lengths are hard-coded is as basic as using any other beginner haskell type
23:49:07 <jle`> it might be something i would probably recommend to a haskell newbie without reservation
23:49:24 <jle`> if they are comfortable using normal vectors or Data.Map already
23:49:30 <EvanR> we should have asked if the length was fixed, only known at compile time, only known at runtime, etc
23:50:16 <EvanR> and if it was like 4, use a tuple. or 4096
23:50:25 <EvanR> or 16777216
