00:00:00 <dpyro> in json I can receive something like "makerTokenAmount": "164000000000000000", but i want to save it as a numeric type
00:00:10 <yaw> reactormonk: thanks. I'll go through that. haskell is my target for this year. I hope to experience programming in a different way. being doing OOP all my life.
00:00:14 <dpyro> a field like makerTokenAmount :: Natural does not work
00:00:41 <reactormonk> yaw, oh yes, you'll have to unlearn a whole lot of things. Got a few good resources at hand too?
00:01:04 <reactormonk> dpyro, you'll probably have to write a manual decoder for that field.
00:01:23 <Wizek> Which of these MapLike typeclass declaration do you think makes more sense?  https://gist.github.com/Wizek/08f44a19b7b4f596d31b7c0038056df8
00:01:50 <yaw> IRC, of course! and other free resources I find online. but I until I get banned for asking stupid questions I'm going to throw my Learning Tantrum here :|
00:02:09 <yaw> reactormonk: ^
00:02:37 <dpyro> üò¢
00:02:38 <lemmih> Wizek: How about using indexed types?
00:02:48 <Wizek> lemmih: hmm, let me see
00:02:59 <dpyro> i really wish aeson had more examples in its documentation
00:03:13 <reactormonk> dpyro, so do I. https://artyom.me/aeson
00:03:24 <Wizek> lemmih: do you mean type families?
00:03:38 <dpyro> üòç reactormonk
00:04:04 <reactormonk> dpyro, what's it look like? It's a link, with some documentation about aeson.
00:04:22 <dpyro> having to deal with templates and generics and instances all at once is a bit much for a newbie
00:04:27 <lemmih> Wizek: https://wiki.haskell.org/GHC/Type_families#An_associated_type_synonym_example
00:05:14 <dpyro> this is still more examples than the aeson doc has
00:05:22 <reactormonk> Exactly.
00:07:32 <reactormonk> yaw, I'd recommend a book. Otherwise you might miss an important piece of the puzzle. https://haskell-lang.org/documentation https://www.haskell.org/documentation
00:07:37 <Wizek> lemmih: wouldn't that require concrete type choices for key and value types in the instance declarations?
00:07:59 <Wizek> lemmih: or can I still leave the associated key and value types polymorphic?
00:09:53 <reactormonk> dpyro, you could also decode it into a datatype where that field is a string, and then later write the new decoder based on the old one.
00:11:56 <lemmih> Wizek: The key and value type would be determined by the collection. Just like your class with functional dependencies.
00:14:49 <Wizek> hmm, okay, I hope to try that soon
00:15:56 <dpyro> i'm trying to avoid that, reactormonk
00:26:05 <dpyro> woah, Parser is the *parse result* in aeson
00:26:17 <dpyro> that makes things a lot clearer but that is an incredibly receptive name
00:26:21 <dpyro> *deceptive
00:39:26 <yaw> reactormonk: sure, thanks :)
00:42:34 <Wizek> lemmih: This seems to compile: https://gist.github.com/Wizek/08f44a19b7b4f596d31b7c0038056df8#file-hs-L11-L16
00:42:41 <Wizek> lemmih: Did you mean it like this?
00:50:03 <lemmih> Wizek: Why not let 'c' have kind '*' ?
00:59:15 <runeks> Anyone else unable to open https://ghc.haskell.org because a secure connection can‚Äôt be established?
01:00:19 <lemmih> Ah, someone forgot to renew the certificate. It tends to bite people in the butt since it has to be done every three months.
01:00:54 <lemmih> I wonder who's responsible for that server.
01:01:33 <runeks> lemmih: Does it use a free certificate?
01:01:50 <lemmih> Yeah, it uses letsencrypt.
01:03:27 <jle`> yes, let's
01:03:37 <runeks> I see. I‚Äôd like to donate a longer lasting certificate, if possible.
01:04:46 <lemmih> letsencrypt isn't bad and renewable is completely automated. Someone just forgot to configure it correctly. :-/
01:05:01 <runeks> Perhaps a good solution would also be to disable HTTPS redirect, so I can type ‚Äúhttp‚Äù first and I will just arrive at the unencrypted site
01:05:36 <runeks> Or perhaps I just need to be a bit more patient and use a Google‚Äôs cache :)
01:08:07 * hackage ghc-tcplugins-extra 0.2.5 - Utilities for writing GHC type-checker plugins  http://hackage.haskell.org/package/ghc-tcplugins-extra-0.2.5 (ChristiaanBaaij)
01:14:02 <Franciman> Hi
01:14:32 <Franciman> I'd like to monitor a UNIX named pipe and read all the data written to it as soon as it is avaible. How can I do it?
01:18:51 <lemmih> Franciman: They behave kinda like files, don't they?
01:19:04 <Franciman> yes
01:19:27 <Franciman> so my question becomes, how can I wait until a file has some data to be read?
01:20:52 <Franciman> for example I tried using readFile. But it doesn't wait for data to be avaible, it simply returns an empty string
01:22:52 <lkurusa> the underlying system call blocks until data is available
01:24:31 <Franciman> hm, then I don't understand what's happening
01:25:13 <lkurusa> is it a named pipe (FIFO) or an anonymous pipe?
01:25:21 <Franciman> named pipe
01:25:33 <Franciman> I created it with `mkfifo` command
01:26:36 <lkurusa> is anyone writing to the pipe?
01:26:45 <Franciman> no
01:26:54 <Franciman> if sombody writes to the pipe, everything is ok
01:27:10 <Franciman> it returns what was written. But if nobody is writing, I'd like to block
01:27:25 <lkurusa> well I think the issue here is that `readFile` reads the file lazily
01:27:47 <lkurusa> so when you actually need the data it doesn‚Äôt block (stops the system call from blocking with `O_NONBLOCK`)
01:28:09 <Franciman> I print the data, afterwards
01:28:14 <[exa]> Franciman: you might want to run strace on the process to see what haskell actually does to your pipe
01:28:16 <Franciman> and it's the empty string
01:28:38 <Franciman> oh I see
01:28:49 <Franciman> ok thanks
01:28:52 <Franciman> I shall try
01:29:14 <[exa]> the probability of misinterpretation of pipe output if read as a file is high tbh
01:29:36 <lkurusa> look for `open` to your named pipe, and `read` with the `fd` returned by the `open` previously
01:31:01 <ongy> named pipes are a bit weird when empty and no write fd was openend on them. There may be some interaction there
01:31:57 <[exa]> yep. also no idea if haskell tries to nonblock it
01:32:12 <[exa]> (when it's considered to be a file, not a socket)
01:33:47 <[exa]> Franciman: if everything fails, try breaking it the oldschool way with fdRead from System.Posix.IO
01:34:17 <lkurusa> ahh yeah, nothing like some brute force on a rainy sunday :-)
01:36:39 * hackage ghc-typelits-natnormalise 0.5.10 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  http://hackage.haskell.org/package/ghc-typelits-natnormalise-0.5.10 (ChristiaanBaaij)
01:36:42 <Franciman> ok thanks
01:45:35 <AndreasK> nkaretnikov: hmm?
01:57:39 * hackage ghc-typelits-knownnat 0.4.2 - Derive KnownNat constraints from other KnownNat constraints  http://hackage.haskell.org/package/ghc-typelits-knownnat-0.4.2 (ChristiaanBaaij)
02:17:14 <kqr> wee
02:17:16 <kqr> oops
02:17:18 <kqr> sorry
02:19:50 <lemmih> kqr: No worries. Spontaneous outbursts of joy is an unavoidable consequence of Haskell.
02:29:17 <kqr> irony is I haven't used haskell in many months now
02:29:47 <kqr> aside from a tiny parser I had to write quickly ‚Äì that was too good a fit to pass up
02:30:26 <lemmih> Delayed onset is a side-effect of laziness.
02:30:44 <lemmih> You probably made a thunk months ago and didn't force it until today.
03:23:44 <juan__> hi everyone! I just started learning Haskell and came upon a weird error :(
03:25:08 <juan__> well, most likely not weird, but my understanding of the language is still very limited, anyways.. im trying to write a function that removes all ocurrences of x from a list xs
03:26:37 <lemmih> juan__: Yeah?
03:26:56 <juan__> my bordercase is remFunc _ [] = [], and my function body is remFunc x xs
03:27:18 <lemmih> Looks good so far.
03:28:39 <juan__> | y /= x = [y] ++ renFunc x (tail xs) | otherwise = [] ++ remFunc x (tail xs)
03:28:45 <juan__> where y = head xs
03:30:02 <juan__> it just worked. I had a dumb typo :D
03:30:05 <cocreature> I would recommend to use pattern matching to get y instead of head/tail
03:30:20 <lemmih> juan__: Try writing the code without using 'head' and 'tail'.
03:30:20 <juan__> how would I do that?
03:30:27 <cocreature> i.e. remFunc x (y : xs) | y /= x = ‚Ä¶
03:33:37 <juan__> I need then to change the head of the function right? I mean I cannot use RemFunc x xs and then write somewhere (y : xs)
03:34:39 <cocreature> right
03:35:14 <cocreature> you have one case starting with remFunc _ [] and one case starting with remFunc x (y : xs)
03:35:15 <juan__> ty<3
03:50:07 <mikail_> noob problem : I just installed ghc on my haskell system and I want to compile and run this Haskell file: https://github.com/simonmar/parconc-examples/blob/master/rpar.hs. However when I run ghc-8.2.2 -O2 rpar.hs -threaded I get lots of Could not find module X errors. Do I have to set up some sort of path?
03:50:27 <mikail_> *on my Linux system*
03:51:20 <Tuplanolla> Where is `Control.Parallel` from, mikail_?
03:52:24 <mikail_> Tuplanolla, that's a good question. I installed ghc on my Arch Linux system using my package manager - how can I find out where it installed everything?
03:53:19 <Tuplanolla> https://hoogle.haskell.org/?hoogle=Control.Parallel
03:53:40 <Tuplanolla> It's from the `parallel` package, which I reckon you haven't installed.
03:54:24 <mikail_> ok I think I know what the problem is now
03:54:46 <Tuplanolla> You can run `ghc-pkg list` to see your installed packages.
03:54:52 <mikail_> so I am just trying to run this file without a proper environment - I haven't run cabal or stack
03:55:02 <mikail_> which would pull all the dependencies down
03:55:37 <mikail_> so either I run stack build in this repo or I install cabal globally on my system
03:56:39 <Tuplanolla> Since you installed GHC via the package manager, just Cabal should do.
03:57:07 <mikail_> I actualy ran stack build in this repo so I have a sandboxed environment
03:57:29 <mikail_> but now when I run stack exec ghc -O2 rpar.hs -threaded I get Invalid option `-O2'
03:57:35 <dtornabene> hello all, just a quick question, I'm curious if anyones read the new haskell book by manning, Get Programming with Haskell and if so what their opinion is....
03:57:58 <Tuplanolla> Try `stack exec ghc -- -O2 -threaded rpar.hs`.
03:59:31 <mikail_> Tuplanolla, yes that worked thanks. However when I run the program I get rpar: user error (Pattern match failure in do expression at rpar.hs:17:3-5)
03:59:57 <mikail_> https://github.com/simonmar/parconc-examples/blob/master/rpar.hs
04:00:12 <Tuplanolla> The program expects one argument.
04:00:27 <mikail_> gotcha!
04:00:35 <mikail_> thanks Tuplanolla for your help!
04:04:39 * hackage csound-expression-typed 0.2.1.0 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.2.1.0 (AntonKholomiov)
04:11:11 * hackage csound-expression 5.3.1 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-5.3.1 (AntonKholomiov)
04:31:35 <mikail_> I am running this program on my machine which has 8 cores but I don't see the performance improvements as indicated in the book. I ran my program using the following commands:./rpar 1 +RTS -N8, ./rpar 2 +RTS -N8, ./rpar 3 +RTS -N8
04:31:50 <mikail_> for the last run, I should see the program run in under 1 second
04:32:00 <mikail_> but i see them all running around the 2 second mark
04:35:25 <spear2> are there any frontends for Diagrams + Linear or some other Haskell math libraries?
04:35:36 <[exa]> mikail_: can you see that it actually uses more cores? (try time and compare user vs. wall time)
04:36:29 <mikail_> [exa], I have the top command running the background and I can see all the cores being utilised but the performance improvements are not seen
04:36:42 <lemmih> mikail_: Look at the difference between the first time printed and the last time printed.
04:37:48 <mikail_> AHHH!! what a dummy. Yes you guys are right. Sorry I was reading it wrong - it's all good
04:39:46 <sordina> Hi all!
04:40:02 <sordina> What's a good choice for streaming system processes these days?
04:41:07 <sordina> A short description of the desired usecase here:
04:41:09 <sordina> http://lpaste.net/4742076672868614144
04:42:50 <lemmih> I'd go with System.Process + 1 or 2 helpers.
04:43:06 <sordina> Any existing helpers that would be recommended?
04:43:13 <maerwald> I'd go with unix package
04:43:25 <maerwald> keep it low-level
04:43:25 <sordina> It's just so fiddly mucking around with configuring the handles etc
04:43:47 <lemmih> sordina: You're making a lot of implicit decisions in your usecase. I'm not sure if there are any libraries that cater exactly to what you want.
04:44:13 <sordina> lemmih: Yes definitely making a bunch of implicit decisions
04:44:35 <sordina> Just wondering if that style of code is enabled by any existing packages
04:45:28 <sordina> I'm not set on it being done the way I've sketched it, but it would be amazing to:
04:45:35 <sordina> Not have to pattern match on handles
04:45:50 <sordina> Not have to run isEOF functions
04:46:10 <lemmih> Why do you need to do those things?
04:46:16 <sordina> Not have to call explicitly recursive code when things aren't failing
04:46:52 <sordina> lemmih: Using System.Process?
04:46:56 <lemmih> Yeah.
04:47:19 <sordina> I don't believe there's any way to construct the program I've written without doing all of those things when just using System.Process
04:47:24 <sordina> Happy to be wrong though!
04:47:53 <lemmih> 9 times out of 10, if you pattern match on a Handle then you're doing something wrong.
04:48:49 <sordina> Seems like great intuition
04:48:57 <sordina> That's why it's rubbing me the wrong way
04:49:20 <[exa]> mikail_: cool :]
04:49:38 <sordina> to be clear, I'm not matching on the handle's internals, just on the Maybe Handles returned by createProcess, etc.
04:50:11 <lemmih> sordina: Why not use one of the higher level functions?
04:50:30 <sordina> Which one do you recommend taking a look at?
04:50:40 <sordina> I had a look at all of them and couldn't see one that matched.
04:51:02 <lemmih> That depends on what you want to do. If you don't care about stderr/exit-codes, see 'readProcess'.
04:51:59 <sordina> I do care about exit codes, and I want to process stdout as it appears
04:52:22 <lemmih> If you really do need non-standard CreateProcess options, just create a helper to return the correct types.
04:52:39 <sordina> This is the toy project I'm building this time round for reference: https://github.com/sordina/logody#logdog
04:53:38 <sordina> lemmih: I've written many helpers to do this in the past. I make small mistakes with them almost every time and take a while to debug them.
04:54:24 <sordina> If you're sugesting that there are no high-level libraries for interacting with streaming system processes in this fashion then I might publish one.
04:54:42 <sordina> But I'd hate to do it if there's one already out there!
04:55:09 <lemmih> I don't think there's a library that has the functionality in your usecase. If there is, I haven't heard of it.
04:55:35 <sordina> thanks for your help :)
04:58:33 <n3tburst> hi! noob question: i am trying to install some packages with stack: stack install intero QuickCheck stack-run.  However, stack gives me version conflicts, and I don't understand what it is trying to say
04:58:55 <n3tburst> In the dependencies for stack-run-0.1.1.4: conduit-1.3.0.2 from stack configuration does not match >1.1 && <1.3 (latest matching version is 1.2.13.1)
04:59:52 <n3tburst> seems like it finds a correct version, but then complains? can somebody point me in the right direction on how to deal with issues like these?
05:04:37 <lemmih> n3tburst: You could add 'allow-newer: true' in your stack.yaml
05:06:09 * hackage texbuilder 0.1.4.1 - View your latex output while editing  http://hackage.haskell.org/package/texbuilder-0.1.4.1 (xaverdh)
05:07:59 <mikail_> got to say, that Simon Marlow's book: Parallel and Concurrent Programming in Haskell is really good
05:08:24 <n3tburst> lemmih: thanks. are there any caveats in doing so? what is the actual cause of the error message?
05:10:01 <lemmih> n3tburst: stack-run is super old (from 2012) and depends on a version of conduit which is no longer in stack.
05:10:56 <lemmih> n3tburst: allow-newer ignored the version requirements and tries to build it against a newer version of conduit. It's quite likely that it'll fail.
05:12:16 <lemmih> n3tburst: Why do you want stack-run, btw? Can't you just use 'stack exec' ?
05:13:49 <n3tburst> lemmih: ahh that makes sense. I am trying to get haskelly to work (visual studio code extension), and it says to in the installation instructions it says to :  stack install intero QuickCheck stack-run
05:15:47 <zincy_> I thought Cabal was just a package manager but it seems to have a build command?
05:17:02 <lemmih> n3tburst: Issue #72 on their github talks about this exact issue.
05:22:08 <n3tburst> lemmih: doh! embarassing i didnt find that. i will try the workaround. thanks!
05:22:21 <lemmih> zincy_: Cabal also does sandboxing, runs tests, generates documentation, creates new projects from templates, etc. It has many hats.
05:29:39 <zincy_> So actually a lot of overlap between stack and cabal
05:29:54 <zincy_> What use does extra dependencies serve in the stack.yaml?
05:35:45 <lemmih> zincy_: https://docs.haskellstack.org/en/stable/faq/#i-need-to-use-a-different-version-of-a-package-than-what-is-provided-by-the-lts-haskell-snapshot-im-using-what-should-i-do
05:36:43 <lemmih> zincy_: Stack uses cabal. It's not like they're alternatives to each other.
05:44:09 * hackage simple-ui 0.1.0 - UI library for terminal.  http://hackage.haskell.org/package/simple-ui-0.1.0 (piotrborek)
06:01:01 <nkaretnikov> AndreasK: nevermind :)
06:03:09 * hackage simple-ui 0.1.1 - UI library for terminal.  http://hackage.haskell.org/package/simple-ui-0.1.1 (piotrborek)
06:36:39 * hackage mp 1.0.0 - Music player for linux.  http://hackage.haskell.org/package/mp-1.0.0 (piotrborek)
06:41:39 * hackage http-client 0.5.12.1 - An HTTP client engine  http://hackage.haskell.org/package/http-client-0.5.12.1 (MichaelSnoyman)
06:41:41 * hackage mp 1.0.1 - Music player for linux.  http://hackage.haskell.org/package/mp-1.0.1 (piotrborek)
06:59:39 * hackage rakuten 0.1.1.1 - The Rakuten API in Haskell  http://hackage.haskell.org/package/rakuten-0.1.1.1 (matsubara0507)
07:07:28 * hackage chatwork 0.1.3.2 - The ChatWork API in Haskell  http://hackage.haskell.org/package/chatwork-0.1.3.2 (matsubara0507)
07:09:39 * hackage transient 0.6.0.0 - composing programs with multithreading, events and distributed computing  http://hackage.haskell.org/package/transient-0.6.0.0 (AlbertoCorona)
07:18:35 * hackage load-font 0.1.0.1 - A cross platform library for loading bundled fonts into your application  http://hackage.haskell.org/package/load-font-0.1.0.1 (deech)
07:45:52 <keegans> `get :: Integer -> IO String` and `session :: String -> Maybe [Session]`, how can i compose these using `map (session . get) [0..pages]`?
07:50:35 <keegans> ok i figured it out `  a <- sequence $ map get [0..pages]
07:50:37 <keegans>   return $ map session a`
07:50:39 <keegans> seems really nasty though
07:52:39 * hackage transient-universe 0.5.0.0 - Remote execution and map-reduce: distributed computing for Transient  http://hackage.haskell.org/package/transient-universe-0.5.0.0 (AlbertoCorona)
07:53:01 <keegans> hmm then i need to go from `IO [Maybe [Session]]` -> `IO Maybe [Session]`
07:53:09 <keegans> concat perhaps
07:54:53 <Garmy> Why an "IO (Maybe [Session])" and not an "IO [Session]" though?
07:57:09 <plugin> I have a question about handling more than one existentially wrapped argument with a continuation:  specifically, how can it be done?  This gist works for the canonical unary case, can someone advise on the binary case?  https://gist.github.com/o1lo01ol1o/2f6695c0bc6e092d84293fc82094bd4f
07:57:13 <keegans> Garmy: this has the potential to fail
07:57:18 <keegans> should i not be using Maybe?
07:57:42 <Garmy> I am just wondering when it would ever be Nothing.
07:57:57 <keegans> if the web request fails
07:58:03 <keegans> or if the scrape fails
07:58:39 <Garmy> Meaning if any "session" returns Nothing?
07:59:01 <keegans> right
07:59:22 <keegans> why is `concatMap session a` not Maybe [Session]
07:59:37 <keegans> `session :: String -> Maybe [Session]` and `a <- sequence $ map get [0..pages]`
08:00:39 <Garmy> :t concatMap
08:00:41 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
08:00:57 <keegans> wat de fuk
08:00:59 <keegans> https://hackage.haskell.org/package/base-4.11.0.0/docs/Prelude.html#v:concatMap
08:01:06 <keegans> no wait, yeah that's right
08:01:29 <Garmy> Because session is not (a -> [b]), but (a -> Maybe [b])
08:01:40 <Garmy> Try "sequence"
08:01:43 <Garmy> :t sequence
08:01:44 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
08:02:55 <keegans> `(concat . concat) $ sequence $ map session a` -> `[Session]`
08:03:06 <keegans> so what happens if one of the sessions is Nothing?
08:03:07 <occulti> Hi
08:04:15 <Garmy> "sequence" chains a sequence of monad values together, so the usual Maybe monad stuff happens; when one of the values is Nothing, the result is Nothing.
08:04:17 <occulti> Does the understanding of Turing machines important (not necessary) to better grasp Haskell (and by extension, the function programming underlying concepts)
08:04:37 <keegans> Garmy: but now i'm not returning a Maybe from the function
08:04:44 <cocreature> occulti: not really
08:04:55 <keegans> hmm let me just play around with this in the repo quickly to wrap my head around it
08:05:20 <occulti> cocreature: many claim so
08:05:52 <cocreature> occulti: do they? I‚Äôve never heard anyone claim that understanding turing machines is important for grasping Haskell
08:05:58 <keegans> `sequence [Just 1, Just 2, Nothing]` -> `Nothing` that makes sense-- but Session cannot be a Nothing, but Maybe Session can be a nothing, so in my [Session], what happens if one of them is Nothing, is it a []?
08:06:18 <keegans> [] being an empty list of Session
08:07:31 <Garmy> Your session function returns a "Maybe [Session]". That can be either "Just [...]" or "Nothing".
08:08:11 <Garmy> Since you map that over a [String], you get a [Maybe [Session]], which is a list of Maybes.
08:08:23 <Ariakenom> lambda calculus is probably a more popular theory to recommend to better grasp haskell.
08:09:27 <Garmy> "sequence" then turns your "[Maybe [Session]]" into a "Maybe [[Session]]", which you just need to concatenate.
08:10:41 <Garmy> "concat $ mapM sessions a" would do the same thing as "concat $ sequence $ map sessions a" (mapM is the same as sequence . map)
08:11:07 <keegans> Garmy: but i'm returning a [Session] in the end, right
08:11:13 <keegans> so are the Nothings just thrown away ?
08:12:05 <Garmy> I thought you wanted a "Maybe [Session]" (`IO Maybe [Session]`)
08:12:32 <keegans> i do
08:12:40 <keegans> but right now I have a [Session] somehow
08:13:04 <Garmy> I made a mistake above, I meant "concat <$> mapM sessions a"
08:13:46 <Garmy> How did you get the [Session]?
08:14:10 <keegans> i am really not sure what is happening right now i will send the code
08:14:24 <keegans>   a <- sequence $ map get [0..pages]
08:14:26 <keegans>   return $ (concat . concat) $ sequence $ map session a
08:14:31 <keegans> that gets me the IO [Session]
08:14:40 <keegans> but i want a `IO (Maybe [Session])`
08:14:50 <keegans> also i will change that to mapM
08:15:07 <keegans> session :: String -> Maybe [Session]
08:15:11 <Garmy> :t concat
08:15:12 <lambdabot> Foldable t => t [a] -> [a]
08:16:24 <Garmy> Since Maybe is a Foldable, one of the concats concatenates the Maybe away.
08:16:56 <keegans> `concat $ mapM session a`
08:17:02 <keegans> now i just get a [[Session]]
08:17:16 <Garmy> Only use one concat, not two, and use fmap: return $ concat <$> sequence (map session a)
08:17:38 <keegans> oh !!
08:17:40 <keegans> i see now
08:17:42 <Garmy> return $ concat <$> mapM session a
08:18:05 <fr33domlover> Hello! Is there a way to write a function    (Monad m, Functor f) => (a -> m b) -> f a -> m (f b)    it's sort of like fmap except it returns the result inside monad m
08:18:14 <keegans> thank you for your help Garmy
08:18:23 <fr33domlover> (If f is required to me a Monad, does that change the answer?)
08:18:39 <cocreature> :t traverse
08:18:40 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:18:51 <cocreature> ^ fr33domlover that‚Äôs probably about as close as it gets
08:19:05 <fr33domlover> Oh right cocreature I'm silly :p
08:19:08 <fr33domlover> Thank you :)
08:19:36 <keegans> is there a better way to do this: https://pastebin.com/8e489GVt as well ?
08:19:40 <[exa]> :t flip forM
08:19:41 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
08:19:59 <[exa]> oh okay that's only with Monad
08:20:13 <rotaerk> :t mapM
08:20:14 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
08:21:09 * hackage number-length 0.2.1.0 - Number of digits in a number in decimal and hexadecimal representation.  http://hackage.haskell.org/package/number-length-0.2.1.0 (PeterTrsko)
08:23:39 * hackage wilton-ffi 0.2.0.0 - Haskell modules support for Wilton JavaScript runtime  http://hackage.haskell.org/package/wilton-ffi-0.2.0.0 (Wilton)
08:31:57 <Nouv> Could anyone take a look at this and tell me why I'm being an idiot please https://hastebin.com/veganomaba.hs
08:32:39 <lemmih> Nouv: Can you tell me the type of 'getArgs'?
08:32:58 <Nouv> lemmih: IO [String]?
08:33:08 <Nouv> According to hoogle
08:33:19 <jchia_1> keegans: If you have a buildHelper :: ((Integer, String), Integer) -> Status, you can write build as "build (x, y) = buildHelper <$> ((,) <$> x <*> y)"
08:33:27 <lemmih> Nouv: Right. And you need something of type [String], right?
08:33:46 <Nouv> lemmih: I .. I think?
08:34:39 <keegans> jchia_1: much thanks
08:34:39 * hackage transient-universe-tls 0.1.1.0 - transient with secure communications  http://hackage.haskell.org/package/transient-universe-tls-0.1.1.0 (AlbertoCorona)
08:34:44 <jchia_1> If you have "buildHelper :: (Integer, String) -> Integer -> Status", then you can write "build' (x, y) = buildHelper <$> x <*> y"
08:34:55 <jchia_1> Not sure if it's better, depends on the purpose of your code.
08:35:12 <lemmih> Nouv: IO in Haskell is a bit different than other languages. Following a tutorial really helps.
08:35:41 <lemmih> Nouv: But to quickly get you unstuck, you need to do: args <- getArgs; let x = case args of ...
08:36:14 <Nouv> lemmih: Thank you, I'll try that.  And yes, I really should read tutorials again.  Thanks :)
08:36:20 <bwe> > :t functionC x y = if (x > y) then True else False -- how comes GHC to assume x and y as same type while a user may specify different ones?
08:36:22 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
08:36:37 <lemmih> Nouv: Learn You A Haskell For Great Good is amazing. http://learnyouahaskell.com/input-and-output
08:36:39 <bwe> http://lpaste.net/364838
08:36:51 <Nouv> lemmih: That's actually the page I just opened! :D
08:38:46 <lemmih> bwe: You can't compare things that aren't of the same type.
08:38:57 <lemmih> bwe: It would be like comparing apples to oranges. :P
08:39:05 <[exa]> "both round!"
08:39:10 <lemmih> :t (>)
08:39:11 <lambdabot> Ord a => a -> a -> Bool
08:39:19 <bwe> Ah!
08:40:00 <[exa]> bwe: if you'd like the variables to be a slightly more independent, you'd need to add some coercion or auto-conversion of one, but that would massively break generality
08:40:08 <[exa]> bwe: better let the user do that
08:40:47 <kuribas> :t unsafeCoerce
08:40:48 <lambdabot> error: Variable not in scope: unsafeCoerce
08:40:58 <kuribas> :t coerce
08:40:59 <lambdabot> error:
08:40:59 <lambdabot>     ‚Ä¢ Variable not in scope: coerce
08:40:59 <lambdabot>     ‚Ä¢ Perhaps you meant ‚Äòcoerced‚Äô (imported from Control.Lens)
08:41:09 <[exa]> (thank god, coercions not in scope)
08:41:14 <[exa]> ( :] )
08:41:30 <bwe> [exa]: Working through haskellbook here; thanks for the detour with coercion, but I resist it =).
08:43:48 <kuribas> in scheme: (eq? 1 1.0) => #f
08:45:19 <kuribas> scheme has four different kinds of equal: eq? eqv? equal? =  .  Haskell has only one
08:49:24 <maerwald> Sounds like Javascript
08:49:39 * hackage transient 0.6.0.1 - composing programs with multithreading, events and distributed computing  http://hackage.haskell.org/package/transient-0.6.0.1 (AlbertoCorona)
08:49:59 <Boomerang> @let eq a b = toRational a == toRational b
08:50:00 <lambdabot>  Defined.
08:50:12 <Boomerang> > eq (1 :: Int) (1.0 :: Double)
08:50:14 <lambdabot>  True
08:50:19 <Boomerang> :t eq
08:50:20 <lambdabot> (Real a1, Real a2) => a1 -> a2 -> Bool
08:52:18 <kuribas> maerwald: no, scheme doesn't do implicit conversions
08:54:37 <kuribas> maerwald: except for numbers
08:55:57 <kuribas> scheme is a lot more consistent than javascript
08:56:39 * hackage lock-file 0.7.0.0 - Provide exclusive access to a resource using lock file.  http://hackage.haskell.org/package/lock-file-0.7.0.0 (PeterTrsko)
09:07:51 <arw> ghc.haskell.org uses an invalid security certificate. expired some 12h ago.
09:08:29 <arw> (just FYI)
09:09:00 <glguy> arw: The infrastructure people know about it, it'll be fixed soon
09:11:25 <arw> k, thx
09:16:32 <Darkyen> Hi! I have a question/problem. I have data type with named parameters (data Foo = Foo {one::Int, two::Int}). I use function/name `one`, but I don't use `two`. Ghc warns that `two` is unused, so I would like to do something like "Foo { one::Int, _::Int}" or "Foo {one::Int, Int}" but neither compiles. What is the correct way to fix this?
09:18:45 <pavonia> Perhaps define `Foo Int Int' and `one' as an extra function
09:18:50 <glguy> If you never use the second parameter you can remove it
09:19:55 <glguy> GHC won't warn about _ prefixed names like _two, either
09:20:07 <Darkyen> I use the parameter itself in pattern matches, just not by name
09:21:11 <Darkyen> pavonia: I liked the descriptiveness of named parameters, but this is also a possibility
09:21:48 <glguy> You could start using record syntax in your patterns, too
09:22:10 <lemmih> Darkyen: You can also fix it by compiling with -w. :)
09:22:35 <Darkyen> underscores work, thanks! Do underscores have any special meaning in haskell? (Even in conventions)
09:23:54 <Darkyen> lemmih: I don't want to suppress warnings (I assume that is what -w does), but thanks :)
09:25:26 <[exa]> Darkyen: lenses exploit them a lot
09:28:41 <Darkyen> [exa]: I see. So if I don't use lenses, it shouldn't create a code-wtf if I underscore some names
09:30:05 <jle`> yeah, the only thing underscore names do is have ghc not warn you for being unused
09:30:23 <Darkyen> Great, thanks!
09:31:00 <rotaerk> hmm I read this recently https://making.pusher.com/latency-working-set-ghc-gc-pick-two/, and the SO post it references:  https://stackoverflow.com/questions/36772017/reducing-garbage-collection-pause-time-in-a-haskell-program/36779227#36779227
09:31:08 <Tuplanolla> Plain underscores have more special properties.
09:31:31 <rotaerk> the responder on the SO post suggests compact regions might help, but I'm not sure how that would help if the queue is long-lived *and* changing over time
09:31:39 * hackage load-font 0.1.0.2 - A cross platform library for loading bundled fonts into your application  http://hackage.haskell.org/package/load-font-0.1.0.2 (deech)
09:33:09 <rotaerk> he suggests a compact region per *message*, but that doesn't make much sense because the message isn't exactly composed of many individual pieces
09:33:29 <[exa]> rotaerk: gc-less haskell is being worked on
09:33:51 <rotaerk> you mean for a future GHC release?
09:34:14 <keegans> i'm storing some things in a redis database, i was using hmset to set a couple of keys as a hashmap but it's tedious to convert
09:34:24 <keegans> so i just derived Read and Show on my struct and i serialize it to a string
09:34:26 <[exa]> more likely a completely different backend
09:34:28 <keegans> is that a terrible idea ?
09:35:18 <[exa]> keegans: not at all
09:35:43 <keegans> ok good :D, they are not very big and only contain String and Integer so i assumed it was fine
09:35:59 <[exa]> keegans: the usual sanity check is that Show output should be haskell-parseable, which might be a problem if you want your data to be concise
09:36:07 <[exa]> s/concise/compact
09:36:37 <[exa]> yeah, perfect.
09:38:10 <rotaerk> [exa], is there anything you can link about how that's going?
09:38:17 <rotaerk> not finding anything by googling
09:39:25 <jle`> keegans: it isn't too bad, but it might become a bottleneck down the line if the strings are long.  most likely not though
09:42:26 <rotaerk> I'm thinking the best solution to that pusher queue problem might just be one giant array
09:43:09 <rotaerk> and since the messages are variable length ByteStrings, just make it an array of bytes, where each ByteString is just a sequence of bytes ending in a null terminator
09:43:47 <rotaerk> then you only have one big object, no major impact on GC (apart from the sheer size of data to be copied from active to inactive memory)
09:44:15 <[exa]> rotaerk: we're doing it as a piece of research here, not public yet
09:44:22 <rotaerk> ah
09:54:23 <domenkozar> Couldn't match type ‚Äò*‚Äô with ‚Äò[*]‚Äô
09:54:39 <domenkozar> what kind is [*]
09:54:47 <rotaerk> list of *-kinded types
09:55:37 <[exa]> rotaerk: we've got some defunctionalization results, closest thing now is probably LHC
09:56:09 * hackage base-compat-migrate 0.1.0.0 - Helps migrating projects to base-compat(-batteries).  http://hackage.haskell.org/package/base-compat-migrate-0.1.0.0 (AdamBergmark)
09:56:36 <domenkozar> rotaerk: thanks
10:21:10 <fr33domlover> is there a function that works like <|> and can be applied to Either a b?
10:21:52 <EvanR> :t Left 'c' <|> Right 9
10:21:53 <lambdabot> error:
10:21:53 <lambdabot>     ‚Ä¢ Could not deduce (Control.Monad.Trans.Error.Error Char)
10:21:53 <lambdabot>         arising from a use of ‚Äò<|>‚Äô
10:22:11 <EvanR> :t (<|>)
10:22:12 <lambdabot> Alternative f => f a -> f a -> f a
10:22:18 <EvanR> o_O
10:22:28 <rotaerk> [exa], happen to know how much of the GC pause is due to traversal time (i.e. number of GC objects in the reachable-object graph) and how much is due to copying time (i.e. total amount of live data)
10:22:33 <rotaerk> ?
10:22:40 <fr33domlover> :t except (Left 'c') <|> except (Right 'd')
10:22:41 <lambdabot> error:
10:22:42 <lambdabot>     ‚Ä¢ Variable not in scope: except :: Either Char b0 -> f a
10:22:42 <lambdabot>     ‚Ä¢ Perhaps you meant data constructor ‚ÄòExceptT‚Äô (imported from Control.Monad.Except)
10:22:51 <fr33domlover> :t Except (Left 'c') <|> Except (Right 'd')
10:22:53 <lambdabot> error:
10:22:53 <lambdabot>     ‚Ä¢ Data constructor not in scope: Except :: Either Char b0 -> f a
10:22:53 <lambdabot>     ‚Ä¢ Perhaps you meant ‚ÄòExceptT‚Äô (imported from Control.Monad.Except)
10:23:00 <rotaerk> as in, would eliminating the traversal, while retaining the amount of data, help that much
10:23:34 <rotaerk> just trying to think of how to work around this problem in GHC; obviously that GC-less research project is not going to be done any time soon
10:24:41 <rotaerk> I'm *thinking* reducing traversal would help a *lot*, because otherwise Compacts would be pointless
10:24:57 <fr33domlover> EvanR, there's an Alternative instance for ExceptT but not for either
10:24:58 <rotaerk> I'll just have to test it at some point
10:25:05 <fr33domlover> *Either
10:33:13 <EvanR> fr33domlover: but thats not the error i got
10:36:38 <fr33domlover> EvanR, yeah idk why it gives than error, i'm guessing ghc is being smart there and seeing that Error type from transformers? (which is deprecated)
10:38:30 <cocreature> the problem is the orphan Alternative instance for Either in https://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control.Monad.Trans.Error.html
10:38:45 <bwe> > const :: a -> b -> a; const = undefined -- "const *must* return the first value" ist this statement true? if why?
10:38:47 <lambdabot>  <hint>:1:21: error: parse error on input ‚Äò;‚Äô
10:39:51 <cocreature> bwe: ‚Äúif const returns a value, it must be the first‚Äù is a bit more accurate. it can do things like loop forever or call "error" and never return any value
10:40:20 <pavonia> cocreature: Is there a specific problem with that instance or the general problem with orphan instances?
10:41:15 <cocreature> pavonia: I was just pointing out the reason for the error message EvanR and fr33domlover have been discussing
10:41:36 <bwe> cocreature: how does it happen that is must be the first value and *not* only the type of the first value?
10:42:04 <cocreature> bwe: because you can‚Äôt make up a value of an arbitrary type "a"
10:42:18 <cocreature> so the only way to produce such a value is to use the one that‚Äôs been given to you
10:42:40 <pavonia> cocreature: Oh, I misread that, I thought Error would not be in scope
10:43:04 <pavonia> (i.e. not loaded because of that orphan instance)
10:43:15 <bwe> cocreature: Can you ask me a question by its answer from me you can check whether I understand it =)?
10:43:49 <cocreature> bwe: does the same property hold for a specialized version of const "constInt :: Int -> b -> Int"?
10:44:31 <Tuplanolla> Does this deceptive example make sense to you, bwe?
10:44:41 <Tuplanolla> :t kunst
10:44:42 <lambdabot> a -> b -> a
10:44:44 <Tuplanolla> > kunst (error "First") (error "Second")
10:44:47 <lambdabot>  *Exception: Second
10:44:55 <bwe> cocreature: No. It can make out the return type without knowing the first argument.
10:45:43 <bwe> cocreature: Parametricity precludes a polymorphic type?
10:46:57 <bwe> Tuplanolla: If cocreature validates my answer, maybe. Can you make up a concise question for me?
10:47:20 <Tuplanolla> I just did.
10:49:19 <cocreature> bwe: your answer is correct but I‚Äôm not entirely sure what you mean by ‚Äúmake out the return type‚Äù. what matters is that it‚Äôs easy to produce a value of type Int whereas you can‚Äôt produce a value of some polymorphic type variable "a"
10:50:34 <cocreature> ‚Äúparametricity precludes a polymorphic type‚Äù also sounds wrong, parametricity allows you to reason about things with polymorphic types, it doesn‚Äôt prelude them
10:50:43 <bwe> cocreature: a -> b -> a -- return type a must match input argument a; there is no way other than the return type a can match input argument type a than returning the first argument itself.
10:51:31 <bwe> Tuplanolla: I don't understand your example/question. Would you mind giving me a second chance by rephrasing it?
10:52:33 <Tuplanolla> I have a polymorphic `const` (called `kunst` to avoid a naming conflict) that seemingly returns the second argument. How is this possible?
10:53:54 <bwe> Tuplanolla: I read `a` type as the first from the right in the type definition. So I assume it returns parametrically polymorphic type a.
10:54:22 <bwe> Tuplanolla: You write, it would `seemingle return the second argument`. Which would mean `b`. Did I get you right?
10:54:55 <Tuplanolla> Yes.
10:56:00 <bwe> Tuplanolla: Where do I see that it returns the second argument, then?
10:56:19 <Tuplanolla> Look at the example I provided.
11:00:49 <bwe> `kunst` takes `a` as an argument returning a function that takes `b` as an argument. Since `b` is an exception, the function raises the Exception "Second".
11:01:22 <Tuplanolla> > kunst (error "First") (error "Third")
11:01:24 <lambdabot>  *Exception: Second
11:01:52 <Tuplanolla> It's actually all smoke and mirrors. The definition of `kunst` itself throws the exception.
11:02:35 <Tuplanolla> :t error "Anything" -- The moral of the story is that every type is inhabited by exceptions.
11:02:37 <lambdabot> a
11:03:20 <Tuplanolla> Your reasoning is otherwise always solid.
11:03:45 <bwe> Appreciated.
11:06:40 <jared-w> Every lifted type if we're feeling especially pedantic :)
11:08:10 <Tuplanolla> Pedantic is good!
11:10:18 <bwe> > let kunst' :: a -> b -> a; kunst' x y = error "dolphin"
11:10:20 <lambdabot>  <no location info>: error:
11:10:21 <lambdabot>      not an expression: ‚Äòlet kunst' :: a -> b -> a; kunst' x y = error "dolph...
11:10:47 <bwe> however, > kunst' raises the Exception "dolphin"
11:11:17 <bwe> even if the return type had been Int instead of a
11:11:38 <bwe> Tuplanolla: thanks for that lesson.
11:20:46 <spear2> how do i change version of cabal
11:22:06 <spear2> does ghc-pkg unregister remove a package?
11:27:44 <JackTheEngineer> Hello ! I am new to haskell and i am reading up on some tutorials and books.
11:28:45 <JackTheEngineer> When reading tutorials, it seems they are all running on GHC 7.10, so i am wondering if i should use ghc 7 or ghc 8 ?
11:29:41 <JackTheEngineer> What are the changes, the version 8 introduced, and how dependency breaking is it ?
11:30:22 <sclv> spear2: what do you mean change version
11:30:47 <sclv> Also, unregister doesn‚Äôt delte files, just removes from package db
11:31:47 <spear2> sclv: i installed the latest cabal version and cabal --version still shows the old
11:33:22 <spear2> sclv: http://lpaste.net/5828384441600311296
11:34:04 <sclv> spear2: the bin was installed in your ~/.cabal/bin dir typically
11:34:19 <sclv> You need to copy it or add it to the path
11:35:09 <spear2> sclv: .cabal/bin is already on path
11:35:34 <sclv> It might be shadowed
11:35:37 <spear2> doesn't contain cabal
11:35:58 <sclv> ok, did you install cabal-install or just cabal
11:36:08 <sclv> The former gives the executable
11:36:20 <spear2> cabal install Cabal
11:36:35 <spear2> cabal install cabal cabal-install doesn't seem to work anymore it just gives an error and says "did you mean Cabal?"
11:37:12 <glguy> spear2: No, delete that 3rd word
11:37:36 <spear2> ah ok
11:37:44 <spear2> cabal install Cabal cabal-install
11:37:45 <spear2> lol
11:37:52 <glguy> No, just cabal install cabal-install
11:41:34 <Ariakenom> > let kunst a b = seq b a in kunst (error "a") (error "b")
11:41:36 <lambdabot>  *Exception: b
12:06:12 <sqooq> how do I use megaparsec. It wants an error parameter. What is recommended to put there, and how do I use it?
12:08:12 <[exa]> rotaerk: no idea but I'd blame copying. Why won't you use a DSL for the gc-less stuff?
12:08:28 <Garmy> sqooq: Use Void from Data.Void unless you know what you're doing.
12:08:43 <sqooq> Garmy: ok that's what I'm doing
12:08:59 <sqooq> But I don't understand what it means, does that mean no error messages will pop out? Because that would suck.
12:09:11 <Garmy> No, you still get useful error messages.
12:10:28 <sqooq> Garmy: ok thanks
12:10:40 <sqooq> Do you want to help me with my parsing too? I have a really hard line in my BNF
12:10:48 <Garmy> I can try :)
12:10:54 <sqooq> where constructing the data depends on what's being parsed
12:11:04 <sqooq> but from what's being parsed there's no real way to tell
12:11:13 <Welkin> with linear types, will arrays/vectors automatically use ST (or something else) to update in-place by default?
12:11:46 <sqooq> http://lpaste.net/6110515775213142016
12:12:01 <sqooq> this doesn't compile whatsoever but I think I'm more or less on the right track, except for the hard line part
12:12:08 <tsahyt> Welkin: I thought you wouldn't need ST for that then?
12:12:18 <sqooq> referring to the end of "r := value ! | [ r r r* ] | value [ t t t* (] ! | ! ])"
12:12:24 <tsahyt> you're guaranteed to never use the old value anymore after all
12:12:36 <tsahyt> so you can silently mutate without causing any problems
12:12:42 <Welkin> so, unsafePerformIO
12:12:51 <tsahyt> no idea how it will work in practice
12:13:13 <sqooq> o shoot i forgot to worry abou whitespace
12:15:15 <sphalerite> is there a "playground" sort of thing like https://play.rust-lang.org/ for Rust which I can use to show a sample for a question I have?
12:15:35 <sqooq> I updated to include my types file
12:15:39 <Garmy> sqooq: Are the square brackets part of the bnf?
12:16:11 <Welkin> sphalerite: post to lpaste, then load the code into lambdabot
12:16:11 <woodson> hey guys. Question, in ghci how do you debug or try to figure out some value thats within a type if it doesnt have the instance Show
12:16:32 <woodson> and the type is from a library
12:16:38 <Welkin> woodson: derive Show
12:16:44 <woodson> of course not a code that you implemented
12:16:50 <geekosaur> sphalerite, also try.haskell.org albeit limited, and ideone.com and a few other sites can do Haskell code
12:16:52 <Welkin> derive an orphan instance for Show using generic deriving
12:17:31 <sqooq> Garmy: Yes.
12:17:36 <sqooq> well, part of my grammar
12:17:39 <blankhart> sphalerite, or repl.it
12:17:57 <sqooq> Garmy: sorry it's so bad and unfinished.
12:18:08 <woodson> Welkin, oh wow ok thanks.
12:18:20 <Welkin> woodson: enable StandaloneDeriving and use deriving instance Show TheType
12:18:29 <sqooq> taking perhaps a bad approach by writing it intuitively first and then filling in everything else later
12:18:58 <Garmy> Can you give me an example value to parse?
12:20:42 <sphalerite> geekosaur: try.haskell.org doesn't have sharing like the playground. ideone seems good, thanks!
12:20:47 <sqooq> Garmy:   "! ^3 ! [ v'3 ! v1 ! ] ^4 !"
12:21:44 <sqooq> Basically, there is 1 less value for every point. Points are "!". Values always come between two points. Brackets enclose at least 2 items, items can include brackets/branches themselves. AND values ignore brackets, but points do not.
12:22:09 <sqooq> Meaning, "! ^3 [ ! ..." is equivalent to "! [ ^3 ! ...."
12:22:27 <Garmy> sphalerite: rextester.com would be another.
12:22:40 <Garmy> It even has a chat, I think.
12:22:56 <sqooq> Honestly I could just enforce that all values directly prefix points.
12:23:28 <sqooq> but if it's possible to have it how I initially intended, that would be cool. Pretty sure the BNF satisfies that, but constructing the functions is really hard.
12:23:45 <Garmy> What is it for?
12:23:53 <sqooq> music stuff, par usual
12:24:50 <sqooq> I'm actually updating an old library of mine. I had a more simple, yet more complex version. It's been a while and i've made lots of changes to how I think and work. Eventually I'd like both versions to be able to be used. I also made my own parser for the first, and I had zero errors, so it's really bad.
12:25:07 <sqooq> zero error handling that is
12:25:12 <sqooq> it just returned [] LMAO
12:25:16 <sqooq> if it ran into problems
12:25:21 <Garmy> Heh
12:26:56 <sqooq> test
12:27:04 <sqooq> i might disconnect, I'm going to the bathroom
12:27:53 <Welkin> sqooq: must be dangerous
12:28:26 <MarcelineVQ> well shielded
12:28:28 <alexashka> good day - can someone help me translate this list comprehension into a regular function please? I'm writing me an infinite loop somewhere and I can't figure it out - [(f a, s2) | (f, s1) <- cs1 s, (a, s2) <- cs2 s1]
12:29:31 <alexashka> without using bind, just fmaps :)
12:29:51 <cocreature> you can‚Äôt replace binds with fmaps
12:29:54 <MarcelineVQ> you need concatMap or bind to translate most list comprehensions
12:29:55 <cocreature> at least not in general
12:30:00 <rotaerk> [exa], I'm not really sure what you mean by using a domain specific language for the gc-less stuff
12:30:10 <alexashka> right, concatMap is just concat and fmap so that's fine
12:30:17 <MarcelineVQ> that aside it's hard to say what's wrong without knowing f and cs1 and cs2 etc
12:30:57 <geekosaur> maybe lpaste the code you've come up with?
12:30:59 <rotaerk> [exa], implement an embedded DSL to provide a nice interface to some low-level manual memory management details?
12:31:00 <geekosaur> @paste
12:31:00 <lambdabot> Haskell pastebin: http://lpaste.net/
12:32:44 <lstdgtfp> are there any good guides on how to use 'stack solver'?
12:32:55 <lstdgtfp> I'm completely failing to get something to build with very simple dependencies
12:33:02 <lstdgtfp> (base, mtl, and containers)
12:33:10 <lstdgtfp> s/containers/collections
12:33:29 <alexashka> http://lpaste.net/364846 - here we go
12:33:33 <monochrom> I haven't heard of "collections". Perhaps it should really be "containers".
12:38:13 <alexashka> MarcelineVQ: f is a simple function a -> b, s1 and s2 are strings. cs1 and cs2 are [(a, String)]
12:38:14 <sqooq> back
12:38:29 <cocreature> alexashka: "p2 s" in your translation should be "p2 s1" afaict
12:39:35 <alexashka> cocreature: arrgggh - yes that seems to be it!!!
12:39:35 <matterbridge-bot> test
12:40:16 <alexashka> cocreature: yes that was it thank you - any suggestions on fixing the readability nightmare that caused this in the first place?
12:40:40 <glguy> matterbridge-bot: This isn't a test channel, and bridge bots to other chat services aren't welcome
12:41:31 <choriz> alexashka: you can use do notation instead and desugar the list comprehention
12:41:39 <cocreature> alexashka: the list comprehension doesn‚Äôt look too bad but yeah I‚Äôd probably use do notation instead
12:42:00 <alexashka> cocreature: well the whole point is to derive applicative by only using the functor ;)
12:42:25 <cocreature> alexashka: right but you can still use do notation for []
12:42:31 <choriz> I mean, by doing () <- within the list comprehention that's using do notation behind the hood
12:42:47 <Garmy> sqooq: I tried to send you a message
12:42:50 <cocreature> alexashka: because [] already does have a Monad instance
12:42:50 <lstdgtfp> monochrom: Right you are! Thanks
12:43:19 <alexashka> cocreature: right, that seems like cheating a bit doesn't it? In the applicative  universe, one should not be able to assume there are monads
12:44:05 <alexashka> cocreature: for practical intents and purposes - you're absolutely right :)
12:44:30 <cocreature> not sure what you mean by ‚Äúapplicative universe‚Äù
12:44:42 <cocreature> either something is an instance of Monad in which case you can make use of that fact or it isn‚Äôt
12:44:46 <cocreature> [] is so why not use it
12:44:53 <Welkin> steven universe is an applicative?
12:45:46 <alexashka> cocreature: I'm out of depth here - I mean to say one should be able to rerive applicative instances for anything that's a functor, never using any monads
12:45:51 <alexashka> derive*
12:47:03 <nkaretnikov> reading okasaki: "Instead of merging the heaps in one right-to-left or left-to-right pass using foldr or foldl, merge the heaps in [log n] passes, where each pass merges adjacent pairs of heaps." i know what foldr and foldl do, but what about the other option, how do i do that? and how's it better?
12:47:31 <cocreature> alexashka: you can even define the Applicative instance using the Monad instance of the same type if there is one
12:47:45 <cocreature> e.g. (<*>) = ap; pure = return
12:48:00 <nkaretnikov> or is the list type in sml different from the one in haskell?
12:48:18 <alexashka> cocreature: right, so for syntax purposes, that works well. For 'theoretical' purposes of learning things properly - I'm building things up from functor to applicative to monad, step by step
12:48:23 <sqooq> Garmy: are you getting my messages now?
12:48:52 <alexashka> cocreature: what I'm doing may very well be completely unnecessary and restrictive :)
12:49:31 <cocreature> alexashka: even for theoretical purposes there is nothing wrong with doing that. the Monad instance is just giving a name to functions that you could define elsewhere, e.g., you can just inline the definition of >>= in your Applicative instance. have you won anything by doing so? I don‚Äôt think so
12:50:14 <cocreature> alexashka: and even if you want to define the Applicative instance without using >>= of the same type, there is absolutely nothing wrong with using it on another type, e.g., on [] as I suggested
12:51:43 <alexashka> cocreature: fair enough, I feel like we've come full circle :)
12:52:40 <cocreature> alexashka: my point is that you seem to be trying to respect some artificial restriction which is a) not particularly well-defined (e.g. inlining definitions suddenly means you respect your restriction) and b) it‚Äôs not an interesting restriction from either a theoretical or a practical standpoint
12:55:12 <[exa]> rotaerk: what's the thing that you're trying to get without gc pauses?
12:55:29 <[exa]> rotaerk: for most of the reasonable stuff ivory helps a lot
12:55:39 * hackage catamorphism 0.7.0.0 - Exposes a Template Haskell function for generating catamorphisms.  http://hackage.haskell.org/package/catamorphism-0.7.0.0 (frerich)
12:59:38 <rotaerk> [exa], I'm not currently working on something that needs it, but I would like to build a game.  I was thinking about how I *would* address that problem in the blog post I linked, about Pusher and its big queue of items
13:01:18 <rotaerk> [exa], if you haven't read it:  they're receiving messages and maintaining a log in memory of all the messages they've received, with a max length of 200k (if it's full, they pop off the oldest)
13:01:59 <rotaerk> and they found that the lengths of the GC pauses were proportional to the max size of the queue
13:02:19 <rotaerk> because, well, in every GC, it iterates over every item in the queue, and it copies the whole thing
13:02:23 <[exa]> serialize the queue to raw data?
13:02:51 <rotaerk> you can eliminate the iteration by using a byte array ... since that's just one big data item
13:03:01 <rotaerk> but you aren't eliminating the copying of it that occurs every GC cycle
13:03:13 <[exa]> even with a very foreign one?
13:03:33 <[exa]> btw how applicable are the linear haskell paper results now?
13:03:33 <rotaerk> oh, you mean use a foreign array that is invisible to the GC?
13:03:53 <[exa]> yeah, if copying is the problem, just move it away
13:04:34 <[exa]> since apparently there's no other way (except the packed tree in that paper, about which I'm not sure if it can be deployed easily)
13:05:13 <rotaerk> and I can imagine this could be a problem for games too, that might want to maintain a bunch of data structures containing game-objects and such in memory, yet have consistent framerates
13:05:21 <rotaerk> (random GC pauses in a realtime game ... ugh)
13:06:01 <[exa]> game state is usually relatively small so you can get away with triggering gc manually
13:06:37 <rotaerk> hmm perhaps
13:07:41 <MarcelineVQ> gc isn't as forgiving on a console, so if you're ever intending ports you'd want memory fully controlled from the start
13:08:26 <rotaerk> if I were considering targeting a console, I'd just not use haskell at all, I think
13:08:38 <rotaerk> because don't most consoles support only one or two specific languages
13:08:56 <rotaerk> usually C++
13:09:46 <rotaerk> hmm hadn't heard of Ivory; neat
13:12:02 <Welkin> rotaerk: you mean fo the SDK?
13:12:10 <Welkin> that shouldn't matter
13:12:20 <Welkin> if the SDK is in c++, you can use a C ffi
13:12:28 <Welkin> also
13:12:41 <Welkin> lisp was used in Uncharted and The Last of Us for a lot of the scripting
13:13:24 <rotaerk> yea, but haskell doesn't really make sense as a *scripting* language
13:13:38 <rotaerk> scripting is generally something that's interpreted
13:14:50 <rotaerk> it's done for the sake of being able to change certain logic without having to recompile your C++ code, and it's done so that gameplay can be expressed in a higher-level/friendlier language that less-programming-savvy designers can use
13:15:03 <rotaerk> and I don't really see haskell as filling that niche
13:15:11 <Welkin> lol, lisp for designers?
13:15:24 <Welkin> I don't think that is a valid use case
13:15:35 <rotaerk> well, maybe THAT company is structured differently
13:15:43 <Welkin> the programmers used lisp
13:15:46 <Welkin> for the AI and levels
13:15:54 <Welkin> well, they wrote their own dsl
13:16:16 <rotaerk> ah k; well, some game companies let the designers write gameplay scripts
13:16:29 <rotaerk> I think Firaxis uses lua for that
13:16:43 <Welkin> they have horrible performance in civ 5 and 6
13:16:47 <Welkin> no idea how it is that bad
13:16:52 <Welkin> they must be doing something wrong
13:28:09 <redrapscallion> I have a default stack project, and I have the file directory like this : src/Views/MyModule.hs
13:28:27 <redrapscallion> and I want MyModule to have the module name Views.MyModule rather than MyModule
13:28:43 <Welkin> just rename it in your module declaration
13:29:00 <redrapscallion> I get a "File name does not match module name" when I do that
13:29:22 <Welkin> when and where?
13:29:56 <Welkin> do you include the module in your .cabal under other-modules: Views.MyModule ?
13:30:03 <redrapscallion> ah, that's it.
13:31:54 <redrapscallion> Welkin: yep, that solved it.
13:34:57 <spear2> how to get rid of broken packages
13:35:18 <Welkin> rm -rf /
13:35:29 <sm> [stack exec --] ghc-pkg unregister PKG
13:38:03 <spear2> i have to type each one by hand?
13:38:32 <Welkin> if you use cabal new-build, that will never be an issue
13:38:57 <redrapscallion> spear2: are your packages in ~/.cabal?
13:39:46 <spear2> redrapscallion: i think so, i just ran ./install.sh from https://gitlab.com/khumba/qtah
13:40:26 <spear2> it ran a bunch of cabal commands with force install
13:40:38 <spear2> tried installing the linear package and everything is broken
13:40:43 <Welkin> spear2: why didn't you just install it through cabal? https://hackage.haskell.org/package/qtah-qt5
13:40:59 <spear2> Welkin: would that allow me to run the qtah-example?
13:41:09 <Welkin> https://hackage.haskell.org/package/qtah-examples
13:41:20 <spear2> i just followed what the README said to do in the repo
13:48:15 <redrapscallion> spear2: try initing a cabal sandbox and installing it again (without the .sh script)
13:48:40 <Welkin> spear2: better yet
13:48:44 <Welkin> use cabal new-build
13:48:51 <Welkin> and forget about sandboxes
13:49:35 <redrapscallion>  
13:54:22 <zincy> Stuck on a weird bug - I am encoding and decoding json client and server side - the decoded json is successfully received by the client, but the client cannot decode and parse the same encoded json back
13:54:54 <zincy> The types are the same on client and server and both derive the ToJSON and FromJSON typeclasses from Aeson
13:55:10 <lemmih> You sure you're encoding/decoding the same structure?
13:55:34 <zincy> Yep
13:56:06 <lemmih> Can you print out the JSON before parsing it?
13:57:52 <zincy> hmm that might be it - "\"{\\\"tag\\\":\\\"CreateAuctionAction\\\",\\\"contents\\\":{\\\"auctionStartTimestamp\\\":\\\"0200\\\",\\\"initialValue\\\":1,\\\"createdBy\\\":\\\"Argo\\\",\\\"maxNumBids\\\":3}}\""
13:58:06 <Welkin> too many slashes O.o
13:58:17 <Welkin> and you have a cat face at the end
13:58:22 <zincy> How did that happen hmm
13:58:34 <zincy> Cat troll
13:58:39 <lemmih> zincy: Looks like you're calling 'show' somewhere.
13:59:05 <zincy> putStrLn instead of print Ill try that
14:00:50 <zincy> Here it is with a show call removed "{\"tag\":\"CreateAuctionAction\",\"contents\":{\"auctionStartTimestamp\":\"0200\",\"initialValue\":1,\"createdBy\":\"Argo\",\"maxNumBids\":3}}"
14:01:35 <lemmih> zincy: It has still been show'ed once too many. It might be a quirk of how you're printing it out or it might be the source of your problem.
14:02:19 <lemmih> zincy: If you try to parse that string as a JSON object, it'll fail.
14:07:37 <zincy> You hit the nail on the head. I sent the valid JSON from an online echo client and it was parsed correctly by my local server.
14:07:57 <zincy> So now I need to figure out where my client is adding the extra show call
14:08:23 <zincy> Thanks so much you save me a lot of time
14:08:26 <geekosaur> you used print instead of putStrLn, maybe?
14:09:01 <geekosaur> oh, sorry, already came up
14:09:23 <zincy> Yeah the parsing step is failing which is the main issue
14:09:48 <zincy> But thats because the client is calling show before sending
14:22:42 <GautamS> is haskell the classiest programming language
14:22:46 <dmj`> can State be considered a Bifunctor
14:23:11 <jle`> dmj`: 's' is both covariant and contravariant
14:23:32 <jle`> s -> (a, s)
14:26:16 <byorgey> GautamS: yes, because it introduced type classes
14:26:47 <Welkin> type classes are bad, m'kay?
14:27:07 <byorgey> m'kay
14:27:10 <dmj`> jle`: so yes then‚Ä¶ seems Bifunctor needs both arguments to be covariant
14:27:44 <jle`> yeah
14:28:00 <jle`> and Profunctor is, first contravariant, second covariant
14:28:28 <byorgey> dmj`: you can think of it as a little-b bifunctor over the right categories (i.e. a category of isomorphisms and a category of functions), but not a Bifunctor
14:30:53 <Boarders> in Control.Monad why is there not (<<) = flip (>>)?
14:31:43 <Boarders> There is *> and <* in Control.Applicative and you have >>= and =<< and both >=> and <=<
14:31:51 <Welkin> yes, you can use <*
14:31:57 <Welkin> flip (>>) is semantically different
14:32:08 <Welkin> just use <*
14:32:13 <Welkin> it's what you want most likely
14:33:10 <byorgey> Boarders: ideally, we shouldn't even have >>, only *>.  It's just historical accident.
14:33:12 <zincy> Figured it out - The extra show call from from the Miso library I was using to send the websocket msg from in the client. Turns out that it calls JSON.stringify in the GHCJS FFI on anything you send. Does anyone else find that strange?
14:33:54 <Welkin> zincy: ask dmj` about it
14:34:17 <Welkin> also, I don't find it strange
14:34:25 <Welkin> you need to stringify data before sending it as json
14:34:33 <Welkin> over a network
14:34:37 <lemmih> zincy: That should be fine if you're handing it plain JSON.
14:35:16 <dmj`> jle`, byorgey: StateT s (Writer [ContT IO () a]) (), so no functors here?
14:36:44 <byorgey> dmj`: that should be functorial in 'a' I think
14:36:58 <zincy> lemmih - The documentation should make this clear right? Shouldn't have to read the source code to figure it out?
14:37:23 <dmj`> zincy: miso assumes serialization uses json, it‚Äôs also faster to go directly from FromJSON a => JSString -> Value -> a (and back), then to go by way of ByteString, but using something like Array should be better
14:38:28 <dmj`> zincy: The FromJSON / ToJSON should give that away
14:38:34 <dmj`> but yes documentation is lacking
14:39:40 <dmj`> zincy: https://haddocks.haskell-miso.org/Miso-Subscription-WebSocket.html#v:websocketSub
14:42:40 <dmj`> zincy: so what are you building ? :)
14:43:26 <dfeuer> Ping Cale
14:44:49 <zincy> dmj` - Full stack haskell app for decentralised auctions
14:47:00 <dmj`> zincy: nice, nice, nice. Is it public yet? Also are you using the isomorphic / pre-rendering support?
14:47:05 <zincy> dmj - Whats your github name?
14:47:23 <dmj`> zincy: dmjio
14:47:32 <jle`> zincy: look at the maintainer for the miso repo ;)
14:47:38 <zincy> dmj - not yet but hopefully one day
14:47:47 <zincy> wow look at my luck its you :)
14:48:33 <zincy> Whats isomorphic prerendering support?
14:49:03 <dmj`> zincy: heh, just means I hang out on irc too much ;)
14:49:05 <zincy> The front and back end share the same types and actions but I split them into different repos. Not sure if that is a good idea
14:49:10 <zincy> haha
14:49:45 <zincy> Keep up the great work with Miso btw
14:52:22 <dmj`> zincy: it‚Äôs for good SEO, if you want it to be public-facing. More info here: https://github.com/dmjio/miso#isomorphic The HTML will be sent immediately from the server and GHCJS‚Äôs 1MB of js will be downloaded asynchronously. If you visit https://haskell-miso.org on your phone, you‚Äôll see the page load immediately, but the blue bar will still be loading slowly until the 1MB is downloaded and cached. Basically it gets around
14:52:22 <dmj`> the complaint that GHCJS‚Äôs static asset size is too large. If you do it right, your app could be usable w/ js disabled. In fact, you can disable js on haskell-miso.org and it will look the same.
14:52:25 <dmj`> zincy: thanks :)
14:56:15 <dmj`> zincy: you could put the shared types in a common folder, and add a `hs-source-dirs: common`, and then disable the web server build if you‚Äôre using ghcjs, and disable the website build if using ghc.
14:57:20 <dmj`> zincy: this cabal file shows how to do that, https://github.com/dmjio/miso/blob/master/examples/haskell-miso.org/haskell-miso.cabal#L16-L25
14:58:24 <zincy> ooh thanks
14:59:36 <albeit> Is there a package that implements ":: Map t Int" but with zero values disallowed?
15:00:00 <Welkin> use a smart constructor for the map
15:00:14 <Welkin> or create a newtype that disallows values below 1
15:00:20 <dpyro> is there a way to specify a custom literal conversion?
15:00:49 <albeit> Welkin: But wouldn't I also need to re-implement things like insertWith?
15:01:17 <lyxia> dpyro: implement Num?
15:01:42 <Welkin> albeit: some kind of dependent type would help here
15:01:58 <zincy> dmj - In the case of an isomorphic monorepo how would it be deployed?
15:03:00 <dpyro> lyxia: is there a version for strings?
15:04:02 <lyxia> no
15:04:10 <hpc> IsString, but it needs a language extension
15:04:13 <hpc> i forget which one though
15:04:37 <dmj`> zincy: Highly recommend nix for deployments (and for dev / testing / CI as well). For https://haskell-miso.org I have it on a NixOS server in my apartment. I just ssh in, clone the repo, add the module to /etc/nixos/configuration.nix, then do a sudo nixos-rebuild switch. NixOS will auto setup a systemd unit, nginx load balancer, ssl cert w/ lets encrypt. Moving to nixops digital ocean right now though
15:04:52 <hpc> the extension expects you to use it for things like Text where it's obviously still a string in some sense
15:05:00 <hpc> iirc
15:05:33 <dmj`> zincy: https://github.com/dmjio/miso/blob/master/examples/haskell-miso.org/nix/module.nix
15:07:10 <lyxia> Oh did you mean OverloadedStrings?
15:07:19 <lyxia> I thought you were asking about Num String...
15:14:26 <zincy> dmj - thanks!
15:15:58 <dmj`> zincy: for sure! Any other ?‚Äôs we have a slack, other nixperts on there as well. Do you think you‚Äôll need to target mobile?
15:22:09 * hackage wires 0.2.1 - Functional reactive programming library  http://hackage.haskell.org/package/wires-0.2.1 (esz)
15:53:11 <dpyro> could I do something like "dropHexPrefix :: String | Text -> Text" in haskell?
15:54:33 <chisui> dpyro: do you mean or by |?
15:54:53 <dpyro> either String or Text
15:55:40 <chisui> you could write `dropHexPrefix :: Either String Text -> Text`
15:56:28 <chisui> alternatively you could create a typeclass: `class CanDropHexPrefix a where dropHexPrefix :: a -> a`
15:57:04 <chisui> with instances `instance CanDropHexPrefix String where ... instance CanDropHexPrefix Text`
15:58:33 <dpyro> i was hoping haskell would essentially let me do an ad-hoc typeclass that way
16:00:04 <chisui> If you don't want to create your own classes you can try to express dropHexPrefix only with operations that both String and Text support and add them as constraints
16:01:44 <dpyro> ü§î
16:04:58 <chisui> If you don't care about performance you could use IsList to convert inputs to string
16:20:34 <jle`> dpyro: (Either String Text) is pretty much a literal interpretation of (String | Text)
16:21:56 <jle`> dpyro: custom literals are more or less what quaisquoters are
16:22:05 <chisui> > type a :| b = Either a b
16:22:07 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äòtype‚Äô
16:22:13 <jle`> @let type (||) = Either
16:22:15 <lambdabot>  Defined.
16:22:29 <dpyro> i used IsString and that was good enough for me ‚ò∫Ô∏è
16:28:54 <sqooq> test
16:35:45 <ertes> are there any good text trie libraries?  there is bytestring-trie, but it's, you know, for ByteString
16:38:58 <sqooq> memo-trie
16:39:10 <sqooq> jk i don't even know what a trie is
16:39:44 <dfeuer> sqooq, that can be googled.
16:44:19 <sqooq> dfeuer: psh, you think I'm smart?
16:44:25 <sqooq> i can't read
16:59:28 <ertes> there are lots of trie implementations, but most of them don't really seem to understand why one would use a trie in the first place
17:00:02 <dfeuer> ertes: eh?
17:00:13 <ertes> even really basic trie-specific operations like "give me all the suffixes of this sequence" are sometimes missing
17:07:57 <dpyro> what would be the haskell version of enumerations?
17:08:10 <dibblego> data Bool = True | False | FileNotFound
17:09:03 * sm learns something new about Bool!
17:09:30 <Welkin> damn you George Boole!
17:09:46 <ertes> dpyro: algebraic data types (ADTs) are enumerations, where every tag can carry payload values called fields, so any ADT without fields is an enumration
17:10:21 <Welkin> even ones with fields are still
17:10:29 <Welkin> I don't see a difference
17:10:41 <Welkin> they are just enumerations with a number of fields
17:10:43 <Welkin> some have 0
17:10:46 <Welkin> others have more than 0
17:11:24 <Welkin> so a sum is always a sum of products, by that definition
17:11:36 <Welkin> data Bool = True | False would be a sum of products
17:11:37 <ertes> dpyro: what we call pattern-matching is an extension of 'switch' statements in other languages, where you don't just match the enum tag, but you also name the fields
17:11:49 <dpyro> ooh, i forgot about ADTs!
17:12:09 <Welkin> dysfigured: not the security company
17:12:16 <Welkin> dpyro: ^
17:12:25 <dysfigured> dpyro: do you weechat?
17:12:32 <dysfigured> err Welkin sorry
17:12:36 <Welkin> o.o
17:12:37 <Welkin> what
17:12:39 <ertes> dpyro: data Maybe a = Nothing | Just a  -- this is a binary enum, where the Just tag contains an additional value of type 'a', like an extended Bool
17:12:47 <dysfigured> Welkin: what irc client do you use
17:13:00 <Welkin> irssi
17:13:04 <dpyro> ertes: i got it, i just genuinely forgot about ADTs since I don't think of them like that
17:13:11 <dpyro> i think of them as type union thingies
17:13:23 <ertes> dpyro: yeah, it's the same concept really
17:13:34 <ertes> "tagged union", "enums with payloads", ‚Ä¶
17:19:09 * hackage judy 0.4.1 - Fast, scalable, mutable dynamic arrays, maps and hashes  http://hackage.haskell.org/package/judy-0.4.1 (MarkWotton)
18:05:34 <alei> Whenever I try to rebuild a project that includes pandoc, stack rebuilds haddock-library and pandoc from scratch, which is very time-consuming. Is there a way I can get it to only build once?
18:06:18 <Welkin> alei: don't use stack
18:06:22 <Welkin> use cabal new-build
18:07:26 <alei> Welkin: All right, I'll give that a shot.
18:09:39 * hackage http-date 0.0.7 - HTTP Date parser/formatter  http://hackage.haskell.org/package/http-date-0.0.7 (KazuYamamoto)
18:09:57 <sm> alei: that's odd
18:10:35 <sm> changing between regular/test/bench builds can do that
18:11:56 <alei> sm: What's odder is that after a few builds, stack refuses to build at all until I remove ~/.stack, same thing as this guy https://github.com/jaspervdj/hakyll/issues/629
18:18:04 <sclv> the rebuilds are a known bug with stack
18:18:46 <sclv> https://github.com/commercialhaskell/stack/issues/3899
18:19:11 <sclv> (basically its internal-library support is not all there)
18:22:44 <alei> I see, thanks.
18:46:45 <sm> oh interesting, I wonder if this explains why my hakyll script started endlessly rebuilding the same deps
18:47:27 <MarcelineVQ> pretty likely
18:48:39 * hackage hakaru 0.6.0 - A probabilistic programming language  http://hackage.haskell.org/package/hakaru-0.6.0 (z)
19:39:15 <sqooq> why doesn't "float = (fromIntegral <$> L.decimal) <|> L.float" work
19:39:20 <sqooq> megaparsec
19:39:30 <sqooq> i tried flipping the order too
19:41:25 <johnw> don't L.decimal and L.float want another argument?
19:41:40 <johnw> by "doesn't work" do you mean it doesn't compile, or it doesn't parse, or it parses incorrectly?
19:41:55 <sqooq> it compiles, it parses, it parses incorrectly
19:42:09 <sqooq> for the ordering I have there, it ignores the float possibility. So ignores everything after decimal
19:42:26 <johnw> sure
19:42:27 <sqooq> Flipping it, makes it so that integers causes failure, and only floats parse
19:42:36 <johnw> try L.float <|> ...
19:42:45 <sqooq> I did
19:42:50 <sqooq> error on integers
19:43:11 <sqooq> It's obvious what i'm trying to accomplish right? Because there might be another way idk
19:43:26 <sqooq> I want "3" and "3.4" to both parse as floats
19:43:30 <sqooq> pretty simple
19:43:48 <johnw> i wouldn't expect try float <|> ... to error on integers
19:43:57 <sqooq> it does :(
19:44:05 <sqooq> float2 =  L.float <|> (fromIntegral <$> L.decimal)
19:44:15 <johnw> add dbg "foo" in front of each parser
19:44:23 <johnw> float2 =  dbg "float" L.float <|> (fromIntegral <$> dbg "decimal" L.decimal)
19:45:56 <sqooq> float> IN: '3'
19:45:58 <sqooq> float> MATCH (CERR): '3'
19:46:00 <sqooq> float> ERROR:
19:46:02 <sqooq> float> 1:2:
19:46:04 <sqooq> float> unexpected end of input
19:46:06 <sqooq> float> expecting '.', 'E', 'e', or digit
19:46:30 <johnw> now I'd change it to dbg "float" (try L.float)
19:46:35 <johnw> see if it ever gets to the decimal parser
19:47:27 <sqooq> do what now?
19:47:48 <sqooq> the flipped version is
19:47:51 <sqooq> decimal> IN: "3.5"
19:47:53 <sqooq> decimal> MATCH (COK): '3'
19:47:55 <sqooq> decimal> VALUE: 3.0
19:47:57 <sqooq> Right 3.0
19:47:57 <johnw> why did the "try" version say
19:48:00 <johnw>  what*
19:48:14 <sqooq> the what?
19:48:23 <johnw> float2 =  dbg "float" (try L.float) <|> (fromIntegral <$> dbg "decimal" L.decimal)
19:48:25 <sqooq> O i thought you were saying "try this"
19:48:31 <sqooq> I never tried the try version lmao
19:49:21 <sqooq> agh it works
19:49:31 <sqooq> What does try do? try and then backtrack?
19:49:39 <johnw> when you have a <|> b, and a fails *after consuming input*, then b is never tried
19:49:51 <johnw> "try" causes it not to consume the input on failure, which then causes it to try b
19:50:19 <sqooq> agh
19:50:21 <sqooq> ok thanks
19:50:29 <johnw> it's in the docs for <|> btw
19:51:31 <sqooq> ok
19:51:52 <sqooq> johnw: one more question. Using the "parse" function, after successfully parsing, it ignores all trailing input.
19:51:55 <johnw> the idea here is that after 'a' fails, it wouldn't make sense to even try 'b' where 'a' had left off
19:51:57 <sqooq> Imo it should fail
19:52:03 <johnw> append your parser with <* eof
19:52:38 <sqooq> eof only succeeds at the end of input :thinking:
19:52:44 <johnw> exactly
19:52:50 <johnw> == there can't be trailing input
19:53:03 <sqooq> agh got it
19:53:07 <sqooq> wow thanks
20:00:07 <EvanR> > floatToDigits 10 1e22
20:00:09 <lambdabot>  ([1],23)
20:00:11 <EvanR> > floatToDigits 10 1e24
20:00:13 <lambdabot>  ([1],25)
20:00:15 <EvanR> > floatToDigits 10 1e23
20:00:17 <lambdabot>  ([9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9],23)
20:00:21 <johnw> everyone loves floating point
20:00:26 <EvanR> o_O
20:02:33 <johnw> powers of 10 don't map comfortably into powers of 2
20:02:39 * hackage fast-arithmetic 0.5.0.0 - Fast functions on integers.  http://hackage.haskell.org/package/fast-arithmetic-0.5.0.0 (vmchale)
20:03:11 <EvanR> > 1e23
20:03:13 <lambdabot>  9.999999999999999e22
20:03:39 <EvanR> oh ok i though it was a weirdness of floatToDigits
20:04:00 <johnw> EvanR: Have you seen http://www.itu.dk/~sestoft/bachelor/IEEE754_article.pdf
20:04:09 <EvanR> > decodeFloat 1e23
20:04:11 <lambdabot>  (5960464477539062,24)
20:04:34 <EvanR> > 5960464477539062 * 2^24
20:04:36 <lambdabot>  99999999999999991611392
20:05:30 <EvanR> i remember a blog post or something with that title but not a paper
20:20:22 <EvanR> thanks this paper ought to keep my busy for a while
21:11:18 <Axman6> > 1e23 :: Scientific
21:11:20 <lambdabot>  error:
21:11:20 <lambdabot>      Not in scope: type constructor or class ‚ÄòScientific‚Äô
21:11:23 <Axman6> :(
21:15:59 <EvanR> dammit where is lambdabots docs
21:16:31 <johnw> lambdabot: where are your docs!
21:16:54 <Eango> what is good GUIs libraries in haskell easy to use
21:16:59 <Eango> making chess game
21:20:17 <dmj`> Eango: terminal or web app?
21:21:30 <Eango> probably just terminal
21:21:42 <Eango> arent most web apps have to be compiled to javascript
21:22:01 <Illumine> Where can I go to learn haskell?
21:22:09 <dmj`> Eango: I‚Äôve heard good things about brick
21:22:31 <dmj`> Illumine: http://dev.stephendiehl.com/hask/ is good, but moreso a reference
21:22:35 <johnw> Illumine: I still like this site personally: http://learnyouahaskell.com/
21:23:04 <johnw> dmj`: how things
21:23:19 <Illumine> The second one says it expects previous programming experience? I don't have any previous programming experience, would I be able to understand the concepts in this book eitherway?
21:24:02 <dmj`> johnw: hey, things good :)
21:24:25 <Eango> dmj: ty i think thats exactly waht im looking for
21:24:33 <Eango> looks easy 2 use
21:26:11 <Eango> alright peace my dudes imma get 2 work :S
21:33:29 <jchia> Can the LANGUAGE pragma be used to turn off an extension?
21:33:56 <jchia> i have default-extensions defined in the cabal file and want to turn off certain extensions at a source-file level
21:37:33 <sclv> jchia: don‚Äôt use language, use the options_ghc pragma
21:38:11 <sclv> then -XNoZZZ where ghc is the extension
21:38:29 <sclv> Or rather where ZZZ is the ghc extension
21:39:07 <geekosaur> actually, "No" prefix works in the LANGUAGE pragma too, or should
21:43:33 <jchia> geekosaur: Yes, I just found out that the 'No' works. I thought it didn't work earlier but I probably had a typo.
21:44:13 <jchia> Why does TypeFamilies imply MonoLocalBinds? Is it just a convenience given with the assumption that people usually want MonoLocalBinds when they use TypeFamilies?
21:44:54 <geekosaur> iirc typechecking gets a lot slower without it
21:45:26 <jchia> geekosaur: Do you mean typechecking with TypeFamilies but without MonoLocalBinds is slow?
21:45:55 * geekosaur is looking or the relevant manual snippet
21:46:50 <geekosaur> but basically yes, if let is fully generalized then typechecking type family applications has to work through lets, if MonoLocalBinds is on then the nearest let usually puts a clamp on it
21:47:48 <jchia> geekosaur: So if you define a type family in module A with UndecidableInstances, and you use the type family in module B but module B does not use MonoLocalBinds, typechecking can be slow?
21:48:10 <jchia> typechecking when compiling module B, to be specific
21:49:04 <jchia> but without UndecidableInstances in module A, it doesn't matter whether module B uses MonoLocalBinds?
21:49:40 <geekosaur> er?
21:50:10 <geekosaur> TypeFamilies means arbitrary type functions. Undecidable complicates things more but is not espefcially relevant hre
21:50:46 <jchia> geekosaur: I once had some module A that have some complicated type families that compiles only with UndecidableInstances.
21:51:09 <geekosaur> ...
21:51:30 <jchia> I got a warning somewhere, I think in another module, about MonoLocalBinds
21:53:17 <geekosaur> apparently it now takes 5 minutes to load a page from downloads.haskell.org :(
21:55:54 <geekosaur> that should have nothing to do with UndecidableInstances, only with TypeFamilies. I'd expect the warning to be because ghc used to just force it on for you in that case
21:57:05 <jchia> OK
21:58:16 <geekosaur> arbitrary type functions are fairly expensive for type checking, MonoLocalBinds reduces the cost a bit and most people don't notice the difference in behavior
22:00:19 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-MonoLocalBinds talks about why at the very end. apparently it's not just expense but predicability, and it points you to a pair of paprts and a blog post
22:00:24 <geekosaur> *papers
22:01:42 <jchia> It is recommended here that TypeFamilies be enabled by default: https://hackage.haskell.org/package/rio. It turns out that two of my source files stopped compiling after I turned on TypeFamilies (even when not really needed). It was because of the MonoLocalBinds that got brought along. I had to disable MonoLocalBinds or add explicit type annotation to fix the code.
22:03:21 <geekosaur> when documentation starts talking about predicability issues, you probably don't want to disable it. Explicit type annotation probably works just as well.
22:04:24 <geekosaur> I mean, if it works for you then it works, but don't be too surprised if you start getting weird type errors.
22:04:31 <nshepperd> i don't think i've ever noticed the effect of MonoLocalBinds being turned on
22:05:02 <geekosaur> I should say "then oit works for now" --- but if this is anything like ImpredicativeTypes then a new ghc release could lead to weird errors.
22:05:03 <jchia> geekosaur: Yeah, that's what I'm doing, the lazy way just for fun by getting the inferred type under NoMonoLocalBind.
22:05:41 <geekosaur> "impredicative" basically means "type inference can get completely lost in the weeds"
22:05:52 <geekosaur> as far as this is concerned
22:08:52 <dudeman123> On trying to use cabal to install the heap package I get the following: Data/Heap/Internal.hs:33:8:     Could not find module ‚ÄòData.Semigroup‚Äô     It is a member of the hidden package ‚ÄòSemigroup-0.0.7@Semig_3Me0dEvKsFE0hiCKQRgKsQ‚Äô.     Perhaps you need to add ‚ÄòSemigroup‚Äô to the build-depends in your .cabal file.     Use -v to see a list of the files searched for.
22:09:03 <dudeman123> What's going on?
22:10:13 <sclv> bad bounds in the heap package
22:10:18 <sclv> you're on an old base that didn't yet include heap
22:10:25 <sclv> erm include semigroup
22:10:29 <sclv> but heap assumes base does
22:10:45 <dudeman123> sclv: Thanks, so how do I update?
22:10:56 <cocreature> the version of base is tied to the version of GHC
22:10:58 <sclv> semigroup was added to base in 4.9
22:11:03 <cocreature> so you need to upgrade GHC to at least 8.0
22:11:12 <sclv> alternately force an earlier version of heap.
22:12:25 <sclv> if you use heap-1.0.3 you should be ok
22:12:48 <sclv> (you can also file a bug report against their github repo indicating that their base bounds are incorrect in the latest
22:12:50 <sclv> )
22:16:52 <johnw> sclv: \o/!
22:17:15 <sclv> ?
22:17:24 <johnw> it's an emotive hi
22:17:52 <sclv> o hai
22:19:00 <EvanR> > ((-1) / (-0))
22:19:02 <lambdabot>  Infinity
22:19:07 <EvanR> ok good
22:28:01 <EvanR> he uses the phrase "an NaN" on page 22
22:28:11 <EvanR> how awkward
22:36:09 * hackage digit 0.5.2 - A data-type representing digits 0-9 and other combinations  http://hackage.haskell.org/package/digit-0.5.2 (qfpl)
22:45:24 <dudeman123> Okay thanks, I've sorted the update of ghc though now I get this... Building library for HCodecs-0.5.. [1 of 7] Compiling Codec.ByteString.Builder ( src/Codec/ByteString/Builder.hs, dist/build/Codec/ByteString/Builder.o )  src/Codec/ByteString/Builder.hs:99:10: error:     ‚Ä¢ No instance for (Semigroup Builder)         arising from the superclasses of an instance declaration     ‚Ä¢ In the instance declaration for ‚ÄòMonoid Build
22:45:40 <dudeman123> What does it mean?
22:45:56 <dudeman123> Also, I'm on ghc 8.4.1
22:50:00 <cocreature> dudeman123: looks like the HCodecs package (at least in version 0.5) doesn‚Äôt support GHC 8.4
22:52:16 <cocreature> given that HCodecs has last been updated in 2014 it might be a good idea to find a different package
22:52:39 <cocreature> ah but the version on github has been updated https://github.com/giorgidze/HCodecs
22:56:20 <juhp> Is there a function (or name) for `\ m m' = isNothing m == isNothing m'` ?
22:58:12 <jle`> juhp: like just comparing if two Maybe's are the same constructor?
22:58:24 <juhp> jle`: yep
22:58:43 <EvanR> :t isNothing
22:58:44 <lambdabot> Maybe a -> Bool
22:58:51 <juhp> right maybe a more a general function hmm
22:59:12 <jle`> you can write a generic "compare if the same constructor" with Data.Data and Data.Generics stuff, but it's probably not too worth it
22:59:20 <juhp> right
22:59:22 <dudeman123> cocreature: Thanks, that resolved it.
22:59:24 <juhp> Just wondered
22:59:50 <juhp> Well can't have names for everything I guess...
22:59:58 <geekosaur> :t (==) `on` isNothing
23:00:00 <lambdabot> Maybe a -> Maybe a -> Bool
23:00:48 <jle`> @let import Data.Data
23:00:49 <lambdabot>  Defined.
23:00:54 <jle`> :t (==) `on` toConstr
23:00:55 <lambdabot> Data a => a -> a -> Bool
23:01:09 <jle`> downside is that these are less polymorphic than possible
23:01:16 <jle`> :t \x y -> isNothing x == isNothing y
23:01:17 <lambdabot> Maybe a1 -> Maybe a2 -> Bool
23:01:41 <dmj`> :t comparing isNothing
23:01:43 <lambdabot> Maybe a -> Maybe a -> Ordering
23:01:46 <jle`> :t \x y -> toConstr x == toConstr y
23:01:47 <lambdabot> (Data a2, Data a1) => a1 -> a2 -> Bool
23:01:49 <Guest33092> these are function signture for my functions http://lpaste.net/364859 when I try to do this it gives error in GHCI http://lpaste.net/364860
23:01:55 <jle`> @let sameConstr x y = toConstr x == toConstr y
23:01:57 <lambdabot>  Defined.
23:02:00 <jle`> > sameConstr Nothing (Just 3)
23:02:02 <lambdabot>  error:
23:02:02 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚ÄòsameConstr‚Äô
23:02:02 <lambdabot>        prevents the constraint ‚Äò(Data a0)‚Äô from being solved.
23:02:08 <juhp> ah
23:02:11 <jle`> > sameConstr (Just True) (Just "hello")
23:02:13 <lambdabot>  True
23:02:20 <jle`> > sameConstr (Just True) (Nothing :: Maybe Int)
23:02:22 <lambdabot>  False
23:02:37 <juhp> okay
23:02:57 <jle`> > sameConstr (Left "hello" :: Either String Int) (Left 15 :: Either Int Bool)
23:02:59 <lambdabot>  True
23:03:08 <juhp> ah
23:03:16 <juhp> I see, tricky
23:03:28 <jle`> but yeah, it's probably a fairbairn threshold kinda thing
23:03:28 <juhp> jle`: thanks, that's pretty interesting
23:03:40 <juhp> okay
23:04:01 <jle`> you can do the same thing with GHC.Generics but it's not as built-in
23:04:11 <juhp> Thanks jle`, just wondered if it was some idiom
23:04:15 <juhp> okay
23:04:28 <jle`> "(==) `on` f" is a common idiom that fits with this
23:04:35 <juhp> okay
23:04:40 <jle`> and it should work as long as both Maybe's are the same type
23:05:07 <jle`> > ( (==) `on` isNothing )  (Just True) (Just "hello")
23:05:09 <lambdabot>  error:
23:05:09 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äò[Char]‚Äô with ‚ÄòBool‚Äô
23:05:09 <lambdabot>        Expected type: Maybe Bool
23:05:14 <jle`> > ( (==) `on` isNothing )  (Just True) (Just False)
23:05:16 <lambdabot>  True
23:05:30 <juhp> I didn't know `on`
23:05:45 <juhp> cool
23:05:50 <jle`> (f `on` g) x y = f (g x) (g y)
23:06:04 <jle`> or as it's sometimes written:
23:06:11 <jle`> ((*) `on` g) x y = g x * g y
23:06:25 <jle`> @src
23:06:25 <lambdabot> src <id>. Display the implementation of a standard function
23:06:27 <jle`> @src on
23:06:27 <lambdabot> (*) `on` f = \x y -> f x * f y
23:06:34 <juhp> aha
23:07:28 <juhp> cool, didn't know that either..., thanks
23:08:03 <jle`> no problem!  it's often used for higher order functions like sortBy/maximumBy/groupBy/etc.
23:08:34 <juhp> I see, nice
23:08:42 <jle`> > sortBy (compre `on` negate) [1..10]
23:08:45 <lambdabot>  error:
23:08:45 <lambdabot>      ‚Ä¢ Variable not in scope: compre :: b -> b -> Ordering
23:08:45 <lambdabot>      ‚Ä¢ Perhaps you meant ‚Äòcompare‚Äô (imported from Data.Ord)
23:08:49 <jle`> > sortBy (compare `on` negate) [1..10]
23:08:52 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
23:09:07 <Guest33092> these are function signture for my functions http://lpaste.net/364859 when I try to do this it gives error in GHCI http://lpaste.net/364860
23:09:17 <johnw> > sortOn negate [1..10]
23:09:19 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
23:09:27 <johnw> does less comparisons
23:09:38 <johnw> I mean, less calls to negate
23:09:44 <juhp> okay
23:10:07 <jle`> Guest33092: hard to say without seeing actual code
23:10:30 <johnw> another form (which is also less eficient) is:
23:10:34 <johnw> > sortBy (comparing negate) [1..10]
23:10:37 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
23:10:40 <jle`> Guest33092: oh, i see
23:10:50 <johnw> this one has the benefit of being monoidal
23:10:58 <johnw> so you can merge comparisons
23:11:10 <jle`> Guest33092: yeah, it's an inherent issue with GHCI, a <- atomically newTChan, there is no hint for type inference to know what type of chan 'a' is
23:11:17 <jle`> Guest33092: in normal code, type inference would do the trick
23:11:28 <juhp> :t comparing
23:11:29 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
23:11:29 <jle`> but GHCi has to commit to a type before it sees that you use 'a' with example
23:11:36 <jle`> juhp: comparing f = compare `on` f
23:11:38 <johnw> > sortBy (comparing even <> comparing negate) [1..10]
23:11:40 <lambdabot>  [9,7,5,3,1,10,8,6,4,2]
23:11:45 <juhp> okay
23:11:47 <jle`> Guest33092: one thing you can do is manually give a type anniotation
23:11:56 <Guest33092> jle` how to make TChan of type String?
23:12:00 <jle`> Guest33092: a :: TChan String <- atomically newTChan
23:12:11 <jle`> Guest33092: or a <- atomically (newTChan @String)
23:12:23 <jle`> or a <- atomically newTChan :: IO (TChain String)
23:12:36 <juhp> johnw: okay that's nice, thanks
23:12:48 <jle`> Guest33092: note that this issue doesn't happen very often in actual haskell source code
23:12:58 <jle`> since in normal source code, ghc can 'look ahead' to see where you use 'a'
23:13:07 <jle`> but in ghci, the ability to look into the future is not yet implemented
23:14:45 <EvanR> curious
23:14:45 <johnw> jle`: but if it's implemented in the future, then that should be enough, if ghci can look there
23:14:59 <EvanR> > (-3) ** 3
23:15:01 <lambdabot>  -27.0
23:15:07 <EvanR> > (-3) ** 3.1
23:15:09 <lambdabot>  NaN
23:15:31 <EvanR> does it check for integer power or
23:15:37 <johnw> EvanR: that is interesting
23:16:09 <EvanR> this issue is on page 32 of the paper you linked
23:16:22 <johnw> oh, imagine that
23:16:28 <johnw> I haven't read that paper in a long time
23:16:29 <EvanR> i am surprised by the -27
23:17:44 <EvanR> > 0 ** 0
23:17:46 <lambdabot>  1.0
23:17:51 <EvanR> of course
23:23:37 <Guest33092> jle` Thank you
23:23:47 <Guest33092> jle` It works
23:28:19 <jle`> no problem!
23:31:21 <tomsen> forM someList $ (\key value -> do putStrln key ++ " " ++ value) this seems to give me [()], can i make this IO () somehow?
23:31:36 <tsahyt> tomsen: by using forM_
23:32:12 <tomsen> tsahyt: this results in [()] aswell :<
23:32:51 <lemmih> tomsen: Try it again. :)
23:33:03 <tsahyt> :t forM_ [("a","b")] $ \(key, value) -> putStrLn (key ++ " " ++ value)
23:33:04 <lambdabot> IO ()
23:33:33 <tomsen> args, ok. guess my problem has deeper root. thanks to both of you
23:34:23 <tsahyt> tomsen: note there are some other changes in what I wrote. forM_ expects an (a -> b), not an (a -> b -> c). and I also put parentheses around the argument to putStrLn
23:45:13 <tomsen> tsahyt: got it working with your suggestion. the tuple pattern match, forM_ and sth else was the problem. i should stop avoiding this indenting for syntax. thx again
