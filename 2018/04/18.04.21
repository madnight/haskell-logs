00:00:26 <EvanR> yeah as relevant as that blog may be i only linked to it for the picture :)
00:00:27 <fishythefish> well, neither is a prerequisite for the other
00:00:48 <crestfallen> dang I need to review foldr
00:01:13 <fishythefish> EvanR: too bad the tree isn't even the one I'd expect
00:01:35 <fishythefish> squaring is desugared, but also (+) is right-associated ._.
00:01:36 <crestfallen> yeah I read to just learn CT as needed
00:01:48 <EvanR> true... wtf
00:02:55 <crestfallen> but can you people just glance at that tautology checker and see what it does?
00:03:32 <fishythefish> crestfallen: at a glance, it doesn't compile
00:04:42 <fishythefish> but it seems the intent is to perform all possible substitutions of booleans for variables in an expression and check that you get True no matter what
00:05:12 <crestfallen> it won't compile?
00:05:32 <fishythefish> `substs p` depends on `vs`, and I don't see `vs` defined
00:06:19 <fishythefish> you can load the code to confirm this
00:06:41 <crestfallen> I fixed 50-51 hold on pls
00:06:49 <crestfallen> *53
00:09:11 <crestfallen> oh there's a where statement missing from line 61
00:09:35 <EvanR> compilers are great
00:09:54 <fishythefish> crestfallen: are you typing out the gist? just copy and paste your code
00:10:17 <fishythefish> (and I hope your code exists somewhere other than the lpaste, because then you can test it)
00:10:46 <EvanR> oh i was hoping that compiler was telling you about all these problems
00:11:14 <crestfallen> actually I lost code when I pasted that somehow
00:12:01 <crestfallen> well that's the showroom version
00:15:07 <crestfallen> another question is I don't understand how Assoc and find work together. find works internally in the Assoc datatype?
00:16:11 <EvanR> Assoc is an alias for a list type
00:16:17 <EvanR> so yes
00:17:15 <EvanR> type Assoc k v = [(k,v)]
00:17:34 <EvanR> everywhere you see Assoc x y you can imagine it says [(x,y)]
00:19:32 <crestfallen> so find returns the keys of a table. I don't see what table it is
00:19:47 <EvanR> :t find
00:19:48 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
00:19:52 <nh> when using stack in the global project context, is there a way for when it inevitably moans about 1billion extra things needing to be added to extra-deps to automatically add them to the yaml
00:20:17 <fishythefish> EvanR: find is defined locally in this case
00:20:18 <EvanR> er
00:20:23 <EvanR> find :: Eq k => k -> Assoc k v -> v
00:21:00 <fishythefish> crestfallen: in `find k t`, `k` is the key you're looking for and `t` is the "table"
00:21:01 <EvanR> does not seem to return the keys
00:21:42 <fishythefish> it provides the first value in the table corresponding to that key and blows up if that key isn't in the table
00:21:43 <crestfallen> sorry I meant values, in this case [True,True,False] what have you
00:22:25 <crestfallen> correct?
00:22:34 <fishythefish> no
00:22:37 <fishythefish> it turns a single value (or errors)
00:22:41 <fishythefish> returns*
00:23:08 <fishythefish> the type makes this clear - it returns v, not [v] - but so does the implementation
00:23:45 <EvanR> you can try doing find 'c' [('a',True),('b',True),('c',False)] in ghci and see for yourself
00:24:14 <EvanR> and find 'c' [] for good measure
00:24:34 <fishythefish> and `find 'a' [('a', True), ('a', False)]`
00:25:03 <crestfallen> ok yeah It's just line 38 that uses it
00:25:47 <fishythefish> crestfallen: you understand that you can test `find` yourself and play around with it, right? you don't have to just use it somewhere else in that file
00:26:14 <EvanR> load the file in ghci
00:26:42 <EvanR> if you make changes, do :r in ghci to reload it
00:26:50 <crestfallen> fishythefish, yeah thanks...  but its not likely to be used while checking for tautologies. I mean, why would it be used?
00:27:29 <EvanR> line 38 seems pretty critical
00:27:41 <fishythefish> crestfallen: because you have a list of associations from variables to Bools, so when you encounter a Var in your expression tree, you use `find` to work out what to substitute for it
00:27:58 <EvanR> it seems very likely to be use
00:28:13 <crestfallen> yeah I see its used in the recursive aspect
00:28:26 <fishythefish> no, it is not used recursively
00:28:53 <EvanR> its the only way substituting into variables happens... which is part of the point of this exercise?
00:29:11 <fishythefish> but whether or not you think `find` should be used to check for tautologies, you were confused about what it does - the solution to this is to load the file and play around with the function
00:29:36 <fishythefish> trying to grok everything by just reading code is *harder*
00:30:08 <crestfallen> but it comes after the logical values And Or etc. so in that regard it is applied recursively?
00:30:31 <fishythefish> what do you mean `after`?
00:30:44 <EvanR> eval is used recursively
00:30:45 <fishythefish> `eval` is applied recursively, `find` is not
00:31:04 <fishythefish> and what `eval` does has no effect on what `find` does
00:33:10 <crestfallen> thanks a lot fishythefish EvanR  really appreciate it.
00:34:02 <EvanR> hmm
00:34:29 <EvanR> @define f x = x && not x
00:34:30 <lambdabot>  Defined.
00:34:36 <EvanR> er
00:34:43 <EvanR> @define f x = not (x && not x)
00:34:44 <lambdabot>  .L.hs:161:1: warning: [-Woverlapping-patterns]
00:34:44 <lambdabot>      Pattern match is redundant
00:34:44 <lambdabot>      In an equation for ‚Äòf‚Äô: f x = ...
00:34:48 <EvanR> @undefined
00:34:48 <lambdabot> Undefined.
00:34:51 <EvanR> @define f x = not (x && not x)
00:34:52 <lambdabot>  Defined.
00:34:55 <EvanR> f True
00:34:58 <EvanR> > f True
00:35:00 <lambdabot>  error:
00:35:00 <lambdabot>      Ambiguous occurrence ‚Äòf‚Äô
00:35:00 <lambdabot>      It could refer to either ‚ÄòDebug.SimpleReflect.f‚Äô,
00:35:08 <EvanR> NEVERMIND
00:35:15 <c_wraith> > L.f True
00:35:16 <lambdabot>  True
00:35:37 <EvanR> > L.f False
00:35:39 <lambdabot>  True
00:35:43 <EvanR> > L.f undefined
00:35:45 <lambdabot>  *Exception: Prelude.undefined
00:35:56 <EvanR> what a tautology
00:36:36 <fishythefish> I mean, a tautology with a single variable has to just be `id` in disguise, right?
00:37:00 <EvanR> const True?
00:37:05 <fishythefish> > const True False
00:37:07 <lambdabot>  True
00:37:10 <fishythefish> not a tautology
00:37:15 <c_wraith> that's decidedly not const True
00:37:23 <c_wraith> > const True undefined
00:37:25 <lambdabot>  True
00:38:21 <fishythefish> oh wait, ignore me
00:38:29 <fishythefish> i'm confusing things
00:38:46 <EvanR> can it be rearranged to work...
00:39:08 <EvanR> because "x && not x is False no matter what"
00:39:23 <EvanR> or vice versa
00:39:28 <fishythefish> well
00:39:35 <fishythefish> are you talking about lifted or unlifted bools here
00:39:45 <EvanR> lifted
00:39:52 <fishythefish> then it's not False no matter what
00:40:12 <jle`> every time i get a github notification i get excited that it might be one of my many pr's getting reviewed
00:40:18 <jle`> but it never is :(
00:40:26 <EvanR> ok
00:40:56 <jle`> this is why i decided to never ever use any external packages for my projects
00:42:09 * hackage vulkan 2.0.0.1 - Bindings to the Vulkan graphics API.  http://hackage.haskell.org/package/vulkan-2.0.0.1 (jophish)
00:48:09 * hackage one-liner-instances 0.1.2.1 - Generics-based implementations for common typeclasses  http://hackage.haskell.org/package/one-liner-instances-0.1.2.1 (jle)
01:20:39 * hackage mwc-probability-transition 0.2.0.0 - A Markov stochastic transition operator with logging  http://hackage.haskell.org/package/mwc-probability-transition-0.2.0.0 (ocramz)
01:29:38 <dpyro> i'm back again! is anyone familiar with servant-client? when i use type StubAPI = BaseAPI :> "thing" ; stubAPI :: Proxy StubAPI; getAPI = client subAPI it typechecks
01:30:32 <dpyro> but if i insert BaseAPI :> Header "Api-Key" Text :> "thing" the type changes to ClientM ClientM StubAPI instead of ClientM StubAPI
01:30:37 <dpyro> i can't find any docs on this :(
01:31:54 <cocreature> dpyro: aren‚Äôt you missing the Verb at the end?
01:32:16 <dpyro> my bad, i do have that i was just trying to fit it into irc
01:32:25 <cocreature> also it would probably be helpful if you can show us some minimal example of the code that‚Äôs producing the problem
01:32:29 <dpyro> :> Get '[JSON] DataType
01:32:35 <dpyro> ok
01:37:27 <dpyro> hopefully this is a better picture of what's going on, cocreature: https://pastebin.com/DhiJMZ3G
01:42:57 <cocreature> dpyro: where is ParadexNonce coming from?
01:43:39 * hackage hw-prim 0.5.0.2 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.5.0.2 (haskellworks)
01:43:42 <dpyro> it is imported from a neighboring file cocreature and is a standard data =
01:44:00 <dpyro> deriving show eq fromjson tojson generic
01:44:19 <nh> how is (..) from list constructions defined (like [1..10] or ['a'..'z'])
01:45:30 <fishythefish> > enumFromTo 1 10
01:45:32 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
01:45:33 <cocreature> dpyro: you just need to change the type of getNonce to Maybe Text -> ClientM ParadexNonce
01:45:35 <fishythefish> > enumFromTo 'a' 'z'
01:45:37 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
01:45:42 <cocreature> dpyro: the Maybe Text argument corresponds to the header
01:45:45 <fishythefish> nh: ^
01:45:52 <nh> ah so its just infix enumFromTo?
01:45:57 <nh> neat
01:46:01 <fishythefish> not infix, it's not an operator
01:46:01 <Garmy> nh: http://hackage.haskell.org/package/base-4.11.0.0/docs/Prelude.html#v:enumFrom
01:46:06 <fishythefish> but it desugars
01:46:12 <Garmy> There are a few variations on that function
01:46:37 <dpyro> üòç
01:46:40 <nh> ah right its sugar, i didn't think about that
01:46:42 <dpyro> ty cocreature, that worked
01:46:44 <nh> interesting, thanks
01:48:09 * hackage base 4.11.1.0 - Basic libraries  http://hackage.haskell.org/package/base-4.11.1.0 (HerbertValerioRiedel)
01:55:39 * hackage mwc-probability-transition 0.3.0.0 - A Markov stochastic transition operator with logging  http://hackage.haskell.org/package/mwc-probability-transition-0.3.0.0 (ocramz)
01:59:39 * hackage base-noprelude 4.11.1.0 - "base" package sans "Prelude" module  http://hackage.haskell.org/package/base-noprelude-4.11.1.0 (HerbertValerioRiedel)
02:08:09 * hackage mwc-probability-transition 0.3.0.1 - A Markov stochastic transition operator with logging  http://hackage.haskell.org/package/mwc-probability-transition-0.3.0.1 (ocramz)
02:21:26 <solidus-river> hey, all, i'm trying to get the vulkan package to compile / install on windows, does anyone have any tips for dealing with native linking / libraries and headers in windows with haskell libs?
02:24:37 <cocreature> solidus-river: I‚Äôm not really familiar with Haskell development on windows but --extra-lib-dirs and --extra-include-dirs are probably come in handy
02:24:39 * hackage mwc-probability-transition 0.3.0.2 - A Markov stochastic transition operator with logging  http://hackage.haskell.org/package/mwc-probability-transition-0.3.0.2 (ocramz)
02:44:39 * hackage mwc-probability-transition 0.3.0.3 - A Markov stochastic transition operator with logging  http://hackage.haskell.org/package/mwc-probability-transition-0.3.0.3 (ocramz)
03:22:09 <cinimod`> Is there a tool (probably written by Neil Mitchell) that tells you whether your LANGUGE pragmas are unnecessary?
03:25:08 <lemmih> hlint?
03:27:34 <cinimod`> nix-env -f /Users/dom/nixpkgs -iA haskellPackages.hlint
03:27:56 <cinimod`> collision between ‚Äò/nix/store/g0np3j37r0ggh6jqrq8drfgjbav90ghn-BlogLiterately-0.8.6.1/lib/links/libHScmdargs-0.10.20-KCeyMG0dLWIAP5PCFvYJUT-ghc8.2.2.dylib‚Äô and ‚Äò/nix/store/65mzqlwzblg45fqs8w2546qqzng6i8lv-hlint-2.1.1/lib/links/libHScmdargs-0.10.20-KCeyMG0dLWIAP5PCFvYJUT-ghc8.2.2.dylib‚Äô; use ‚Äònix-env --set-flag priority NUMBER PKGNAME‚Äô to change the priority of one of the conflicting packages
03:28:16 <cinimod`> Perhaps I should ask on the #nixos channel
03:28:48 <cinimod`> Why is life never simple?
03:38:23 <JuanDaugherty> because a) life occurs in a domain of existence that is inherently complex and b) simplicity is a property of the mind which you are failing to detect
03:39:49 <JuanDaugherty> to the correctly perceiving mind, authentic and profound simple truths abound
03:41:39 <cinimod`> hlint did not detect that I didn't need `{-# LANGUAGE RecordWildCards #-}` :(
03:41:46 <cinimod`> Life is cruel and unforgiving
03:42:02 <lemmih> cinimod`: How about -Wall?
03:42:02 <JuanDaugherty> stuff is pretty simple in the intergalactic spaces
03:42:25 <cocreature> lemmih: -Wall doesn‚Äôt warn about unused pragmas
03:42:51 <cinimod`> I am building with --pedantic
03:50:53 <zincy> I just found debug.trace :) - How do you guys debug?
03:53:06 <dysfun> println!
03:54:02 <cocreature> zincy: I use Debug.Trace fairly often
04:55:11 <zincy> Does anyone know how to conditionally render a view in Miso?
05:00:46 <tomjaguarpaw> Does anyone have any idea about this: https://stackoverflow.com/questions/49955451/haddock-fails-because-main-is-defined-in-multiple-files
05:09:42 <Plato[m]> I'm trying to use Nix with Haskell and emacs. I use "callCabal2Nix" in my default.nix. It seems to work, mostly. However, I get a weird error about Couldn't match type ‚Äòtext-1.2.3.0:Data.Text.Internal.Lazy.Text‚Äô with ‚ÄòLazyText.Text‚Äô
05:17:43 <Cale> Plato[m]: I'm guessing that LazyText comes from a qualified import of Data.Text.Lazy?
05:18:02 <Plato[m]> Cale: Correct.
05:18:24 <Cale> Plato[m]: The explicit package qualification there is a hint that two versions of the text package somehow ended up visible
05:18:49 <Plato[m]> Ah, I see.
05:19:10 <Cale> Try ghc-pkg list (from inside a nix-shell, if you can)
05:19:39 <Plato[m]> text-1.2.3.0 appears twice.
05:19:43 <Cale> hmmm
05:19:52 <Cale> Under the same heading, or different ones?
05:20:30 <Plato[m]> Ah, it's under $HOME/.ghc and /nix/store/.../ghc-8.2.2. Maybe I can just clear ~/.ghc and try again.
05:20:35 <Cale> aha
05:20:46 <Cale> I suspected that would be it actually
05:21:03 <Plato[m]> No idea where this stuff from ~/.ghc comes from.
05:21:39 <Cale> That's your user-installed packages independent of nix
05:21:44 <Plato[m]> Nice, it works now. Thanks Cale!
05:22:00 <maerwald> that's what happens if you use too many tools
05:22:06 <Cale> It would probably be nice to have a flag for building GHC which would make it ignore that path
05:58:02 <Nils_> Hi. I am playing around with OverloadedLabels and DuplicateRecordFields to make it possible to re-use record fields (e.g. #name person) but cannot seem to get it working. I am following Stephen Diehl's setup (http://dev.stephendiehl.com/hask/#overloadedlabels), but receive the following error: http://lpaste.net/365080 . I am using stack, and have just now tried with lts-15 (ghc 8.2.2) and nightly-2018-04-21 (ghc 8.4.1). Has anyone enc
05:58:47 <Nils_> I remember making it work at some earlier time, but do not remember the details. Any suggestions would be very welcome - thanks a lot in advance!
06:00:30 <lyxia> Nils_: use TypeApplications (and ScopedTypeVariables), fromLabel = getField @x
06:02:21 <lyxia> I'm not sure how this could have ever worked
06:05:37 <Nils_> @lyxia - It works! Thank you so very much. Did anything change since this is required now (unlike in Stephen's example), or am I missing something?
06:05:37 <lambdabot> Unknown command, try @list
06:07:50 <Nils_> lyxia - It works! Thank you so very much. Did anything change since this is required now (unlike in Stephen's example), or am I missing something?
06:08:45 <lyxia> It doesn't seem like anything changed.
06:09:15 <lyxia> I just made a PR to fix that https://github.com/sdiehl/wiwinwlh/pull/164
06:18:41 <AxelAlex> What are some times when exceptions should be used? To me exceptions seem like they go against the philosophy of making illegal states unrepresentable, but I am also new to haskell so there is probably something I am missing.
06:21:07 <lyxia> When you're doing IO, most of the state is outside your control
06:21:30 <lyxia> things can fail for so many reasons
06:23:35 <lyxia> so if you tried to produce a sum type of errors, it would only keep getting bigger, and in many cases you don't care about handling them in the first place
06:27:14 <lyxia> Two more: asynchronous exceptions seem unavoidable, and sometimes making all illegal unrepresentable is simply not worth the trouble.
06:29:16 <AxelAlex> I see, thanks.
06:29:45 <EvanR> if you're making an IO library of sorts, then i think it can make sense to throwIO something when things get a little kookoo. others may disagree
06:30:53 <EvanR> you can also throw an exception in an impossible situation, impossible by virtue of your invariants you set up, but inside the module theres no way to avoid an impossible case
06:32:06 <EvanR> like, users of the module have a total lookup function Key -> Container -> Value, (not Maybe Value). but inside the module you used a normal Data.Map, and lookup returns a Maybe
06:32:12 <EvanR> but Nothing is impossible
06:32:51 <lyxia> ^ that's so inspirational.
06:33:14 <jcjf> haha
06:33:14 <EvanR> i actually dont know a good way to handle that, but you could throw an exception
06:35:27 <blankhart> illegal state is not the same as error state, when we are talking about making illegal state unrepresentable through expressive types and smart constructors. exceptions represent error state.
06:36:10 <EvanR> error "impossibru"
06:36:56 <EvanR> would indicate a bug in your proof of impossible, so an error of sorts. but not users fault
06:39:04 <EvanR> theory: crashing could be 1. users fault, 2. authors fault 3. third party fault in case youre accessing some remote thing, which fails. but we dont have 3 different ways to crash :(
06:41:31 <EvanR> and neither does anyone else i know of
06:44:56 <blankhart> oh, i think i misunderstood, the question is when to crash versus propagate up and not crash.
06:47:52 <EvanR> i think the question was, why do exceptions exist given you can write haskell code that never needs to crash or fail in any way
06:48:21 <EvanR> answer, bad given
06:48:30 <Geraldus> Hi folks!
06:49:07 <Geraldus> I'm facing strange errors after my NixOS upgrade
06:49:21 <hc> did you upgrade to 18.03 yet?
06:49:45 <blankhart> yeah i was thinking about "exception" as it's used in ExceptT
06:49:47 <Geraldus> hc: I'm on unstable chanell
06:50:06 <Geraldus> Setup: Encountered missing dependencies: Cabal ^>=2.2.0 && ^>=2.0.0,
06:50:30 <Geraldus> Can't figure out what's wrong
06:55:11 <marmistrz> I'm using mtl, I've mentioned it as a dependency in my package.yaml
06:55:30 <marmistrz> I'm occasionally getting errors about not matching types from the *transformers* package
06:55:31 <ph88> cocreature, this is a part of the compiler output (the last part) https://bpaste.net/show/0181ba1b0e37 does this mean ghc is stuck in the simplifier stage ?
06:55:34 <marmistrz> What's going on?
06:55:43 <marmistrz> AFAIK, transformers is a different, conflicting package
07:03:22 <cocreature> ph88: looks like it
07:04:09 <cocreature> Geraldus: sounds like you‚Äôre probably using a Cabal version that‚Äôs too old
07:05:05 <Geraldus> cocreature: Hi!
07:05:09 * hackage haskell-gi-base 0.21.1 - Foundation for libraries generated by haskell-gi  http://hackage.haskell.org/package/haskell-gi-base-0.21.1 (inaki)
07:05:16 <cocreature> hey :)
07:05:32 <Geraldus> cocreature: Looks like there's something wrong with `nix: packages` from my stack.eaml
07:07:12 <cocreature> Geraldus: looks more like one of your package has a constraint that is not met by your version of Cabal rather than a bug in stack‚Äôs nix integration
07:07:55 <cocreature> but it‚Äôs a bit hard to say without seeing the full error and the stack.yaml file and probably also the cabal file
07:08:07 <Geraldus> cocreature: yeah
07:10:38 <lyxia> marmistrz: mtl reexports types from transformers
07:10:57 <marmistrz> lyxia, that explains much, thanks!
07:20:24 <aueuaio> hi guys, this is the first time i use stack with a custom Setup.hs (i simply added a preSDist hook that prints a line to stdout but i would like to use it to generate some text files before stack creates the source tarball with sdist); i added the custom-setup field and build-type: Custom to my package.yaml but it doesn't seem to work, running 'sta
07:20:24 <aueuaio> ck sdist .' does not print the expected line (it doesn't seem to use my Setup.hs at all) and gives me a 'Warning: In getPackageArgs: custom-setup in use, but no dependency map present' and then 'Could not find custom-setup dep: Cabal' and 'Could not find custom-setup dep: base'. Does anyone have any idea how to fix this? Here are the contents of my
07:20:25 <aueuaio>  Setup.hs and the relevant lines of my package.yaml: http://lpaste.net/365084
07:20:25 <aueuaio>  i have stack 1.6.5
07:21:36 <cocreature> aueuaio: can you show us the generated cabal file? I wonder if hpack is translating things weirdly here
07:23:22 <cocreature> aueuaio: nvm looks like you‚Äôre out of luck https://github.com/commercialhaskell/stack/issues/2741
07:23:55 <cocreature> stack sadly doesn‚Äôt work particularly well with custom Setup.hs
07:24:15 <aueuaio> oh well, i missed that, thank you
07:24:44 <aueuaio> i'll consider using cabal directly then
07:33:37 <srid> What's the recommended way to change a particular node in a rose tree (`Data.Tree`)? `fmap` works but is inefficient--once I locate the particular node in question I'd just skip processing its children (but fmap will go over all nodes regardless).
07:35:02 <EvanR> sounds like a job for lens
07:35:08 <bbrodriguez> hey i just have a comment but i have been doing project euler for some more exercises aside from the books and it almost feels like haskell is cheating :)   a 1-liner for solutions that take 10 or more in other languages
07:35:17 <EvanR> or a hand made functional reference
07:36:13 <EvanR> its only cheating if allowing everybody to do it would ruin everything
07:36:36 <cocreature> srid: if that‚Äôs an operation you need to perform often, you might want to consider storing only node ids in your tree and then having a separate map from node ids to the node data
07:36:49 <srid> EvanR: i don't understand. how would lens work with this recursive data structure?
07:37:09 <EvanR> to modify a point in a tree, lens can do that
07:37:20 <EvanR> you have to know exactly where though
07:37:25 <srid> The tree is used to represent text outliner, basically. I'm prototyping this app, and it involves adding, deleting, rearranging nodes in the tree.
07:37:43 <EvanR> lens can do all kinds of stuff
07:45:21 <srid> Yea, interesting: https://www.schoolofhaskell.com/user/davorak/code-snippets/zipper-tree-examples
07:45:41 <srid> Though it looks little more complex than saving the path from root to node x.
07:47:14 <EvanR> zipper, yeah. but its more efficient
07:50:24 <tomjaguarpaw> Is it possible to have a constraint on a type instance?
07:51:46 <liste> tomjaguarpaw: you mean "instance Foo a => Bar a where..." ?
07:52:02 <liste> Bar Baz*
07:52:16 <tomjaguarpaw> type instance Foo a => Bar a
07:52:19 <Tuplanolla> Probably talking about type families, in which case the answer is no, liste.
07:52:47 <tomjaguarpaw> Isn't that strange, given that you can have constraints on a class with a type family inside it?
07:55:30 <lyxia> https://arxiv.org/abs/1706.09715 Constrained Type Families ICFP 2017
08:05:39 * hackage yesod-auth-oauth2 0.5.0.0 - OAuth 2.0 authentication plugins  http://hackage.haskell.org/package/yesod-auth-oauth2-0.5.0.0 (PatrickBrisbin)
08:22:09 * hackage th-format 0.1.2.0 - Template Haskell based support for format strings  http://hackage.haskell.org/package/th-format-0.1.2.0 (mtesseract)
08:29:01 <tomjaguarpaw> Actually I can just let the constraints be picked up at the use site.  I was assuming I could use type variables in the constraints in the associated type, but I can't.
08:32:15 <jophish> Hey Tom, how's things?
08:37:15 <tomjaguarpaw> Oh quite fabulous.  How are you?
08:37:56 <jophish> I'm enjoying life here a lot!
08:38:21 <tomjaguarpaw> That's great to hear!
08:38:41 <tomjaguarpaw> How is Haskell flourishing where you are?
08:39:22 <jophish> I'm giving a talk at the next haskell meetup here
08:39:35 <jophish> someone has requested a talk about writing a small CPU in Clash
08:40:16 <tomjaguarpaw> Oh nice
08:46:48 <marmistrz> Is there anything I could use instead of a Functor for a non-higher-kinded-type
08:46:49 <marmistrz> ?
08:47:13 <marmistrz> I mean, I have data Foo = I Integer | B Bool | N
08:47:26 <cocreature> marmistrz: which operation do you want to perform on that type?
08:48:12 <marmistrz> I basically want to abstract from writing a custom pretty-printing declaration
08:49:18 <cocreature> sounds like you might be looking for GHC.Generics but you‚Äôre still quite vague
08:49:56 <marmistrz> Well, I think I'm overcomplicating :D
08:50:24 <marmistrz> So, what I actually want to do is pretty printing a data type
08:50:54 <marmistrz> So that when I have `myfun (I 32)` I just want to print `32`, not `I 32`
08:51:18 <marmistrz> Is there anything that would derive such pretty printing for me without having to write separate functions?
08:51:26 <marmistrz> these are trivial, but it's manual code that has to be maintained
08:52:07 <byorgey> marmistrz: no.  At least, nothing that would require writing less code than implementing it manually.
08:52:11 <cocreature> how exactly do you want to pretty print? just omit constructor names for unary constructors?
08:52:29 <marmistrz> cocreature, yes
08:53:16 <cocreature> you could do that with GHC.Generics but if you only have a single type with 3 constructors, then byorgey is certainly right that the code required for that would be more tan the boilerplate you‚Äôd have to write otherwise
08:54:29 <cocreature> marmistrz: but note that this can also easily become ambigous, e.g. data Foo = I1 Integer | I2 Integer
08:54:46 <cocreature> if you omit those constructor names you‚Äôve lost potentially important information
08:56:25 <marmistrz> thanks!
08:56:50 <tsahyt> data stored in pinned memory does not get copied by the generational GC either, right? e.g. say you've got a large bytestring or something, that shouldn't affect GC times
08:58:09 * hackage utf8-validator 0.1.0.0 - Constant-space UTF8 validator for ByteStrings  http://hackage.haskell.org/package/utf8-validator-0.1.0.0 (edwardgeorge)
08:58:52 <marmistrz> and is it possible to have multiple matches collapsed into one? Something like this: https://zerobin.net/?661b0cef28326523#Tg2P1OGNXtYkX38USnx2KnRUxx3rlghNIqxQgIn0PzY=
09:00:04 <marmistrz> I mean something similar to this in Rust: https://doc.rust-lang.org/book/second-edition/ch18-03-pattern-syntax.html#multiple-patterns
09:05:54 <cocreature> marmistrz: not yet but maybe soon :) https://github.com/ghc-proposals/ghc-proposals/pull/43
09:49:09 * hackage shake-ats 1.8.0.2 - Utilities for building ATS projects with shake  http://hackage.haskell.org/package/shake-ats-1.8.0.2 (vmchale)
09:49:54 <nkaretnikov> ^^ wow, someone actually does write ats projects? :)
09:53:22 <newuser2894> hi there
10:00:22 <chorhizo> is there a fairly basic, decent to use graphics library for haskell?
10:00:36 <chorhizo> thought about making networked tron but I know graphics arn't it's strong suit
10:08:31 <fr33domlover> chorhizo, there's plenty of graphics stuff
10:09:11 <fr33domlover> chorhizo, there's diagrams and there's more 2d stuff and there's opengl and lots of higher level 3d stuff on top
10:11:42 <chorhizo> fr33domlover, yeah I thought so, it just seems like nobody can make their mind up what graphics libraries to use. I'll try gloss i guess
10:12:12 <fr33domlover> chorhizo, idk what tron is tbh so idk what you need exactly
10:12:31 <chorhizo> fr33domlover, it's like snake but with 2+ people
10:12:38 <chorhizo> with an infinite trail
10:12:57 <fr33domlover> chorhizo, so you just need a simple 2d graphics library like SDL?
10:13:12 <fr33domlover> There are SDL bindings iirc, you could try those
10:13:25 <fr33domlover> Or maybe Haskell has some alternative to offer idk
10:13:45 <fr33domlover> Your needs are simple then, so explore and make it a fun experience to try stuff!!
10:14:16 <juri_> is there a PCI access library for haskell?
10:16:47 <dmwit> What does Google say about that?
10:16:59 <HiS_InfernaL_Maj> !
10:20:46 <fr33domlover> juri_, (1) https://hackage.haskell.org/packages and Ctrl-F in your browser and see if PCI brings up anything (2) web search (3) if you find nothing and no answer here, then there's probably none :p
10:26:18 <zincy> Say I return this from a View in Miso   - div_  []     [  view1 , view2 ] - How would I conditionally include view 2 in the list?
10:27:17 <ph88> cocreature, do you have some advise on how i could split up my code ?
10:27:56 <pavonia> zincy: (view1 : [view2 | condition])
10:28:42 <juri_> darn. doesn't look like it.
10:29:25 <cocreature> ph88: just remove half of the code and see if it‚Äôs still slow and continue doing that until you find what‚Äôs causing problems
10:29:33 <ph88> ok
10:29:39 <marmistrz> cocreature, thanks!
10:32:36 <zincy> pavonia : Thanks! What is the name of the | operator
10:33:33 <pavonia> It's not an operator, the whole list is called list comprehension
10:34:09 <pavonia> Usually you use it with a generator list like [ 2*x | x <- [1..10], odd x]
10:36:38 <zincy> So we can use | without <- ?
10:37:01 <hpc> > ["yes" | [1, 2, 3, 4, 5]]
10:37:03 <lambdabot>  error:
10:37:03 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚ÄòBool‚Äô with actual type ‚Äò[Integer]‚Äô
10:37:03 <lambdabot>      ‚Ä¢ In the expression: [1, 2, 3, 4, ....]
10:37:21 <hpc> ah, right
10:37:23 <hpc> guess not
10:37:38 <hpc> > do {[1, 2, 3, 4, 5]; pure "yes"} -- what it would translate to, if that worked
10:37:40 <lambdabot>  ["yes","yes","yes","yes","yes"]
10:40:04 <Eduard_Munteanu> Expressions without '<-' are taken as guards.
10:40:46 <Eduard_Munteanu> > [1 | False]
10:40:48 <lambdabot>  []
10:41:00 <hpc> > [1 | True]
10:41:02 <lambdabot>  [1]
10:41:25 <Eduard_Munteanu> @undo [ x | x <- f, p x ]
10:41:25 <lambdabot> concatMap (\ x -> if p x then [x] else []) f
10:41:50 <hpc> @do concatMap (\ x -> if p x then [x] else []) f
10:41:50 <lambdabot> concatMap (\ x -> if p x then [x] else []) f
10:42:05 <hpc> do {x <- f; guard (p x); pure x}
10:43:12 <marmistrz> Is it possible to rewrite the following code into something fold-alike?
10:43:13 <marmistrz> https://zerobin.net/?e56c6c03a59e49bf#hEGIWdhGr6+cM/mHsxeC7rl2AnP5sqL4/W8jKEPp0Pk=
10:43:26 <Eduard_Munteanu> The guard translation is more accurate for arbitrary monad comprehensions.
10:43:36 <marmistrz> It is almost a fold, apart from the fact that the final call is an argument to another function
10:43:51 <marmistrz> `withEnv env = local (const env)` in my code
10:46:27 <Eduard_Munteanu> :t foldrM ?f ask
10:46:28 <lambdabot> (Monad m2, MonadReader r m1, ?f::a -> m1 r -> m2 (m1 r), Foldable t) => t a -> m2 (m1 r)
10:46:51 <Eduard_Munteanu> :t foldrM
10:46:52 <lambdabot> (Monad m, Foldable t) => (a -> b -> m b) -> b -> t a -> m b
10:47:57 <Eduard_Munteanu> :t ask >>= \e -> foldrM ?f e ?xs
10:47:58 <lambdabot> (?xs::t a, ?f::a -> b -> m b, Foldable t, MonadReader b m) => m b
10:51:39 * hackage X11 1.9 - A binding to the X11 graphics library  http://hackage.haskell.org/package/X11-1.9 (DanielWagner)
10:53:44 <Eduard_Munteanu> :t runContT . mapM (ContT . ?withVar)
10:53:45 <lambdabot> forall k (t :: * -> *) a b (m :: k -> *) (r :: k). (?withVar::a -> (b -> m r) -> m r, Traversable t) => t a -> (t b -> m r) -> m r
10:54:13 <Eduard_Munteanu> That might be nicer if you can refactor into that form.
10:54:52 <Eduard_Munteanu> That combinator really needs a name.
10:58:28 <marmistrz> Eduard_Munteanu, what's the ?withVar ?
11:00:05 <Eduard_Munteanu> marmistrz, withVar is continuation passing style thing that does createVar and substVars, e.g.  withVar :: (ID, Value) -> (Var -> Interpreter a) -> Interpreter a
11:00:31 <Eduard_Munteanu> Er, just createVar.
11:04:54 <Eduard_Munteanu> :t runContT . mapM (ContT . asks ?withVar)
11:04:55 <lambdabot> forall k (t :: * -> *) r1 b (m :: k -> *) (r2 :: k). (?withVar::r1 -> (b -> m r2) -> m r2, Traversable t) => t r1 -> (t b -> m r2) -> m r2
11:05:42 <Eduard_Munteanu> Ah, but you keep those in the Interpreter, nevermind. Just use the foldrM above.
11:05:43 <HiS_InfernaL_Maj> any ccv2
11:08:39 * hackage ats-pkg 2.10.0.11 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-2.10.0.11 (vmchale)
11:10:09 * hackage massiv-io 0.1.3.0 - Import/export of Image files into massiv Arrays  http://hackage.haskell.org/package/massiv-io-0.1.3.0 (lehins)
11:16:46 <tsahyt> is -funbox-strict-fields implied by -O2?
11:18:40 <marmistrz> Is there a variant of zip which will return an error/maybe if the lists don't have equal lengths?
11:18:42 <cocreature> tsahyt: afaik no
11:18:49 <tsahyt> hm okay
11:18:53 <cocreature> tsahyt: -funbox-small-strict-fields is enabled
11:19:00 <tsahyt> oh
11:19:05 <tsahyt> when is a field small?
11:19:38 <cocreature> <= pointer size
11:19:57 <EvanR> marmistrz: that seems a bit odd because it would have to traverse the whole of both lists before outputting anything
11:20:07 <marmistrz> EvanR, I'll traverse them anyway
11:20:23 <EvanR> better would be to guarantee they are the same size before using zip
11:20:30 <EvanR> some other way
11:21:04 <tsahyt> okay, thanks
11:21:39 * hackage cdeps 0.1.0.0 - Extract dependencies from C code.  http://hackage.haskell.org/package/cdeps-0.1.0.0 (vmchale)
11:21:50 <EvanR> traversing the whole of both lists before outputting anything will use much more resources than consuming the zip lazily
11:25:09 <nshepperd_> You could make a variant of zip that puts the error at the end of the output list, crashing your program only if it depends on the lists being the same length
11:25:47 <EvanR> ah
11:26:42 <EvanR> zip' :: [a] -> [b] -> [(a,b)]
11:27:11 * hackage hadolint 1.6.4 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.6.4 (lorenzo)
11:27:22 <EvanR> zip' [1,2] [3,4,5] = (1,3):(2,4):error ":((("
11:27:30 <EvanR> zip' [1,2] [3,4] = (1,3):(2,4):[]
11:27:50 <nshepperd_> Yep
11:29:44 <EvanR> or data HmmZip a b = Zip a b (HmmZip a b) | Wronggg | EndOfList
11:32:21 <marmistrz> EvanR, hoogle doesn't show zip' anywhere
11:32:36 <EvanR> you didnt write it yet
11:32:42 <marmistrz> :)
11:35:51 <gbd_628> Hey all, quick question about Stack (version 1.6.5) and Cabal (version 2.0.0.1). When I try "stack init" in a new package, I get this error: "Unable to parse cabal file [path]: FromString "unexpected '{'" (Just 20)" whenever I try to include haddock's latex markup support in the cabal file's "description:" field. E.g., "\(\frac{a}{b}\)". What's going on? Can I fix it?
11:36:30 <gbd_628> The Stack documentation implies that it will work on top of any set of valid cabal packages, the Cabal documentation explicitly states that Hackage syntax is allowed in the description field, the Hackage documentation states that it includes limited support for Latex syntax, namely the Latex syntax "\(" and "\)" for introducing mathematical formulae. I tried escaping the curly brackets in the cabal file but I just got essentially th
11:37:46 <gbd_628> (Oops, I meant "haddock", not "hackage".)
11:38:39 <sclv> gbd_628: i suspect you may fare better with the stack 1.7 release candidate?
11:38:46 <sclv> Not sure tho
11:41:06 <gbd_628> ok, thx. in lieu of a better solution I guess I'll try that.
11:42:10 <gbd_628> The most annoying thing is that I can't find any info about the answer online; googling "Unable to parse cabal file" with quotes yields <100 results, and none of them are very helpful. (i think there's an xkcd about this...)
11:51:00 <EvanR> so Text is better than String, and Scientific is better than Rational right
11:51:32 <EvanR> for dealing with decimal
11:52:40 <EvanR> lovin it
11:54:05 <ddellacosta> well, this certainly seems like a rather indirect way for the author to learn Haskell: https://github.com/ghc-proposals/ghc-proposals/pull/127
11:54:13 <ddellacosta> it's amusing how dedicated they are to the proposal
11:56:13 <chorhizo> 'I think the purpose of do notation is to build imperative algorithms.'
11:56:35 <EvanR> actually
11:56:58 <EvanR> notation to help writing in "DSL"s might not be bad, Idris has something for this
11:57:06 <EvanR> but it goes beyond do notation
11:57:43 <EvanR> it lets you hijack lambda syntax for example
12:00:20 <gbd_628> Well, that's a real Parker Square of a pull request :D
12:01:03 <Tuplanolla> I like proposals, even if they are silly.
12:01:42 <EvanR> I like proposals especially if they are a modest one
12:04:24 <gbd_628> me too, which is why i called it a parker square--it's the mascot of giving things a go, even/especially if you are brand new & inexperienced
12:05:04 <sqooq> how do I include a library that's just on my computer, in another project?
12:05:07 <sqooq> as a depend
12:06:27 <cocreature> sqooq: are you using cabal or stack?
12:06:31 <sqooq> stack
12:06:39 * hackage wl-pprint 1.2.1 - The Wadler/Leijen Pretty Printer  http://hackage.haskell.org/package/wl-pprint-1.2.1 (NoamLewis)
12:06:53 <cocreature> sqooq: just add the path to the lib as another entry in the packages section
12:07:04 <cocreature> or add it as an extra-dep
12:07:45 <sqooq> I think I did that
12:08:17 <sqooq> causes error "Invalid dependency"
12:09:52 <cocreature> which of the two options did you try?
12:10:03 <sqooq> le premier
12:10:17 <cocreature> can you show us the stack.yaml and the full error message?
12:10:36 <sqooq> I put the path under "dependencies:" in the packaage.yaml file
12:10:50 <sqooq> with a dash
12:10:55 <sqooq> - /path/to/it
12:11:27 <cocreature> you need to add it to the packages section in your stack.yaml
12:11:35 <sqooq> o
12:11:40 <cocreature> and then you can add the name of the lib to the dependencies section in package.yaml
12:12:57 <sqooq> agh, ok danke
12:15:26 <sqooq> does it now ignore the package itself?
12:15:32 <sqooq> it can't seem to find any of it
12:16:07 <cocreature> not sure what you mean by that
12:16:42 <sqooq> like before, any file I made in /src was automatically compiled as the lirbary
12:16:49 <sqooq> so I could load them up in ghci
12:17:03 <sqooq> now it's like the package I added by filepath is the only package that's loading
12:17:21 <sqooq> So I guess I have to also add the og package under packages: as well
12:17:25 <cocreature> yes
12:18:53 <sqooq> now it can't find it
12:18:56 <sqooq> god I hate stack
12:20:06 <EvanR> in this piece of documentation, what do you think "parens" does https://hackage.haskell.org/package/megaparsec-6.5.0/docs/Text-Megaparsec-Expr.html
12:21:10 <EvanR> \expr -> do{ char '('; e <- expr; char ')'; return e} or...
12:23:20 <EvanR> or whitespace, or optional () or...
12:23:32 <EvanR> why isnt it defined here ;_;
12:25:12 <cocreature> EvanR: probably something like https://hackage.haskell.org/package/megaparsec-6.4.1/docs/Text-Megaparsec-Char-Lexer.html#v:symbol
12:26:08 <cocreature> optional parenthesis won‚Äôt work afaict
12:26:15 <cocreature> you‚Äôll produce an infinite loop that way
12:26:41 <EvanR> :|
12:26:47 <Tuplanolla> If you submit an issue, it should be fixed within hours, EvanR.
12:27:20 <EvanR> so the expression example will only parse when you put parens everywhere
12:27:55 <EvanR> at least you dont have to put them around the numbers
12:28:26 <cocreature> EvanR: no you don‚Äôt need parenthesis
12:28:28 <Tuplanolla> You shouldn't need parentheses when precedence is clear.
12:28:52 <EvanR> but a term is defined as
12:28:52 <cocreature> that would kind of defeat the purpose of makeExprParser
12:28:54 <EvanR> term = parens expr <|> integer <?> "term"
12:29:11 <cocreature> yes but why do you care about term? you‚Äôre parsing expr
12:29:21 <EvanR> its the input to makeExprParser
12:29:52 <EvanR> its mutually recursive
12:29:55 <cocreature> term are the base cases in the precedence sensitive parser produces by makeExprParser
12:30:14 <cocreature> one basecase are literals, the other is expressions wrapped in parenthesis
12:30:38 <cocreature> makeExprParser then builds a parser that lets you combine those base cases based on the operators and the precedences specified in table
12:30:39 <EvanR> so you cant write 1 + 2 + 3
12:30:43 <cocreature> you can
12:31:22 <EvanR> er ok
12:31:34 <cocreature> that‚Äôs 3 terms combined using the `binary "+" (+)` operators specified in the table
12:31:46 <EvanR> so parens are optional after all
12:32:23 <cocreature> right my point was that "parens" must enforce that parens are present
12:32:51 <cocreature> the optionality comes from the <|> and the internals of makeExprParser
12:33:33 <cocreature> to make it a bit more clear "term = expr <|> integer" will produce an infinite loop
12:34:41 <EvanR> ok it luckily works out
12:35:06 <EvanR> now im trying to determine where to put parens in a more complex system of possible terms
12:35:53 <EvanR> here they dont allow them around numbers
12:36:11 <EvanR> oh maybe they do...
12:36:17 <cocreature> they do
12:38:19 <EvanR> so term represents an atomic thing which would appear as operands
12:39:39 * hackage ghci 8.4.2 - The library supporting GHC's interactive interpreter  http://hackage.haskell.org/package/ghci-8.4.2 (HerbertValerioRiedel)
12:44:34 <EvanR> is invisible function application an operator in this regime
12:46:38 <cocreature> yep just don‚Äôt consume anything (or consume spaces if your parsers don‚Äôt consume trailing spaces)
12:47:09 * hackage ghc-boot 8.4.2 - Shared functionality between GHC and its boot libraries  http://hackage.haskell.org/package/ghc-boot-8.4.2 (HerbertValerioRiedel)
12:47:15 <EvanR> groovy
12:48:39 * hackage ghc-boot-th 8.4.2 - Shared functionality between GHC and the @template-haskell@library  http://hackage.haskell.org/package/ghc-boot-th-8.4.2 (HerbertValerioRiedel)
12:57:39 * hackage integer-gmp 1.0.2.0 - Integer library based on GMP  http://hackage.haskell.org/package/integer-gmp-1.0.2.0 (HerbertValerioRiedel)
13:24:10 <sqooq> how do I do a newline
13:24:12 <sqooq> in ghci
13:24:14 <sqooq> print
13:25:38 <rotaerk> sqooq, put a \n in the string?
13:27:16 <chorhizo> if you're trying to put a \n in a string straight in then it wont work, you have to use putStrLn "bla\n"
13:28:04 <sqooq> ok
13:28:08 <sqooq> let me see thanks
13:28:21 <verement> @src putStrLn
13:28:21 <lambdabot> putStrLn s = do putStr s; putChar '\n'
13:29:39 * hackage reactive-banana-automation 0.1 - home (etc) automation using reactive-banana  http://hackage.haskell.org/package/reactive-banana-automation-0.1 (JoeyHess)
13:30:13 <chorhizo> > "abc\n"
13:30:15 <lambdabot>  "abc\n"
13:31:01 <sqooq> > putStr "hi\ndoes\n\it work?
13:31:03 <lambdabot>  <hint>:1:20: error:
13:31:03 <lambdabot>      lexical error in string/character literal at character 'i'
13:31:06 <sqooq> > putStr "hi\ndoes\n\it work?"
13:31:08 <lambdabot>  <hint>:1:20: error:
13:31:08 <lambdabot>      lexical error in string/character literal at character 'i'
13:31:19 <sqooq> rip
13:31:22 <chorhizo> > putSTrLn "hi\nhi"
13:31:23 <pavonia> Sure it does
13:31:24 <lambdabot>  error:
13:31:25 <lambdabot>      ‚Ä¢ Variable not in scope: putSTrLn :: [Char] -> t
13:31:25 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
13:31:27 <chorhizo> > putStrLn "hi\nhi"
13:31:29 <lambdabot>  <IO ()>
13:31:32 <sqooq> lolol
13:31:35 <chorhizo> > eval $ putStrLn "hi\nhi"
13:31:37 <lambdabot>  error:
13:31:37 <lambdabot>      ‚Ä¢ Variable not in scope: eval :: IO () -> t
13:31:37 <lambdabot>      ‚Ä¢ Perhaps you meant ‚Äòival‚Äô (imported from Data.Number.Interval)
13:31:41 <chorhizo> in ghci it works.
13:31:43 <sqooq> lolololololol/
13:31:47 <sqooq> yes it does
13:31:53 <sqooq> Thanks
13:40:58 <EvanR> hmm so to parse sections... look for operators at the far left or far right of a parenthesized group
13:41:47 <EvanR> :t (f x y +)
13:41:48 <lambdabot> error:
13:41:48 <lambdabot>     Ambiguous occurrence ‚Äòf‚Äô
13:41:48 <lambdabot>     It could refer to either ‚ÄòDebug.SimpleReflect.f‚Äô,
13:43:03 <EvanR> ill take that as a "parse succeeded"
13:43:21 <monochrom> Yeah
13:44:05 <monochrom> :t (logBase 2 10 +)
13:44:06 <lambdabot> Floating a => a -> a
13:47:10 * hackage language-docker 5.0.0 - Dockerfile parser, pretty-printer and embedded DSL  http://hackage.haskell.org/package/language-docker-5.0.0 (lorenzo)
14:15:57 <rotaerk> :t (((id `id`) `id`) `id`)
14:15:58 <lambdabot> a -> a
14:16:44 <EvanR> whats this, the shell game
14:20:21 <EvanR> finding it hard to reconcile syntax like expr.foo.bar with spaces-get-consumed after anything automatically
14:21:11 <EvanR> and space-means apply
14:21:58 <EvanR> but apparently they have it in pure script or elm or one of those
14:29:50 <EvanR> seems like everything-consume-its-own-leading-space strategy is needed to distinguish f . g from f .g and x.name
14:30:58 <Rembane> In Purescript <<< is composition and . is only used for record access.
14:31:42 <EvanR> hmm ok
14:32:14 <Dynasty> >> and << are also composition operations in F#
14:32:22 <Dynasty> I actually really like the notation
14:32:37 <Dynasty> it makes it clear which function is invoked first
14:33:27 <EvanR> whereas the same notation in haskell would mislead you into thinking which is involved first
14:33:42 <EvanR> depending on the associativity
14:34:05 <Rembane> I really like the dot-notation for composition, it's so un-noisy.
14:34:17 <Dynasty> I've also found the pipe operation in F# to be very useful
14:34:22 <Dynasty> |>
14:34:32 <EvanR> if only we had \circ on a bog standard keyboard
14:34:36 <Dynasty> It's not used very much in Haskell as far as I can tell
14:34:44 <Rembane> Dynasty: What's the types for |>?
14:34:59 <EvanR> |> is flip ($)
14:35:04 <Dynasty> Rembane: here's the definition:
14:35:05 <Dynasty> let (|>) x f = f x
14:35:05 <Rembane> Ah, &
14:35:16 <Rembane> EvanR, Dynasty: Thank you!
14:35:21 <Rembane> :t (&)
14:35:22 <lambdabot> a -> (a -> b) -> b
14:35:30 <EvanR> its used a lot in elixir
14:35:32 <Rembane> :t ($)
14:35:33 <lambdabot> (a -> b) -> a -> b
14:35:49 <Rembane> EvanR: Soon you want a whole APL keyboard!
14:36:35 <EvanR> i find |> as "pipe" confusing because... in a unix pipeline foo | bar | baz the result is a process with input going to foo and output coming from baz
14:36:36 <Dynasty> Actually I agree with the \circ thing. I've seen people use more unicode symbols in Coq and Mathematica
14:36:55 <EvanR> but f (g (h x)), which you get with |>, isnt that
14:37:01 <EvanR> its just output
14:37:45 <EvanR> it commits to the input too early
14:38:30 <EvanR> so |> shouldnt be called composition, at least
14:38:50 <Dynasty> I find pipeline code easier to read, since it clearly shows what code is executed first. With the $ stuff in Haskell you have to read it inside-out
14:39:16 <Rembane> I usually mix them. :D
14:39:17 <EvanR> you shouldnt read it inside out :)
14:39:27 <Rembane> You have to read my code from all directions!
14:40:51 <EvanR> > head $ map (+1) $ (4:repeat undefined ++) $ (99:) $ []
14:40:53 <lambdabot>  error:
14:40:53 <lambdabot>      The operator ‚Äò++‚Äô [infixr 5] of a section
14:40:53 <lambdabot>          must have lower precedence than that of the operand,
14:41:06 <EvanR> > head $ map (+1) $ ((4:repeat undefined) ++) $ (99:) $ []
14:41:08 <lambdabot>  5
14:41:09 <freeman42x]NixOS> got a question about types lining up, in this case the lambda being passed to another function is in IO so I do not know how to call the function with the lambda which takes a lambda without IO in it: http://lpaste.net/365098
14:41:22 <EvanR> head comes first
14:41:30 <EvanR> in two ways
14:41:53 <EvanR> undefined, 99, and [] are irrelevant
14:42:22 <lemmih> freeman42x]NixOS: Change the definition of 'followTreeUntil'.
14:43:35 <freeman42x]NixOS> lemmih, to followTreeUntil :: Display -> (Window -> IO Bool) -> Window -> IO Window ?
14:43:41 <lemmih> freeman42x]NixOS: Yep.
14:44:13 <freeman42x]NixOS> but then cond w in the guard won't be Bool, it will be IO Bool, I don't know how to change it
14:45:26 <Dynasty> I think it's basically a culture difference. Haskell emphasizes point free code, and F#, Elixir and Elm emphasize pipelines
14:45:34 <lemmih> freeman42x]NixOS: It seems you already know how to manage IO. If you wanted to do something with the 'String' from 'getFocusedWindowTitle2', how would you do it? How would you get the 'String' from 'IO String' ?
14:45:58 <Dynasty> Personally, I don't like the point free style unless the point free version is very simple
14:46:45 <freeman42x]NixOS> lemmih, I'd use leString <- someIOString
14:47:00 <EvanR> Dynasty: note i dont like $ chains... but i was just pointing out that you really should not read that from right to left
14:47:09 <EvanR> because lazy evaluation, not because of point free or not
14:47:10 <lemmih> freeman42x]NixOS: Great! Can you do the same with 'cond' to get the Bool?
14:47:48 <freeman42x]NixOS> lemmih, I don't know where I'd put that since I do not see any do notation
14:48:00 <EvanR> $ is infixr, so the first $ "happens" first in that chain
14:48:05 <EvanR> not the last $
14:48:06 <lemmih> freeman42x]NixOS: You don't see any do-notation in 'followTreeUntil'?
14:48:29 <freeman42x]NixOS> lemmih, there is one but not on the cond branch
14:48:38 <EvanR> its precisely as if you did x |> h |> g |> f
14:48:49 <EvanR> h(x) happens first
14:49:02 <EvanR> (in elixir)
14:49:57 <EvanR> ok not precisely but the direction is still "left to right"
14:50:03 <lemmih> freeman42x]NixOS: Can you change the definition of 'go' to use do-notation? How about: go w = do thisWindowIsGood <- cond w; if thisWindowIsGood then ... else ... ?
14:55:01 <EvanR> hmm LiberalTypeSynonyms is not saving from this particular hell:
14:55:03 <freeman42x]NixOS> lemmih, thank you, now I got what you meant
14:55:20 <EvanR> type Parser = Parsec Char Void
14:55:25 <EvanR> foo :: Operator Parser Expr
14:55:43 <EvanR> Parser needs 1 argument... but it gets one in the definition of Operator
14:57:06 <EvanR> only way i have found to get it to compile is to delete foo's type sig
14:57:29 <EvanR> until now... because i changed something so types are ambiguous without one!
15:01:49 <freeman42x]NixOS> lemmih, like this? http://lpaste.net/365100 still getting a parse error there, not obvious what I am doing wrong
15:04:24 <lemmih> freeman42x]NixOS: You need to add more spaces such that 'match' is aligned to the right of 'go'.
15:05:34 <freeman42x]NixOS> lemmih, thank you, so obvious after the fact, I need to get used to this :)
15:11:27 <zamrir> can someone please explain why my 'getline' function id wrong? http://lpaste.net/365101
15:12:24 <EvanR> because getLine is not a list of chars
15:12:44 <EvanR> er, getline is not a list of chars. so you cant do c : getline to prepend a char
15:13:01 <donjoe2> "Could not find module ‚ÄòData.List.Split‚Äô". How do I install this?
15:13:24 <fishythefish> donjoe2: install the `split` library
15:13:24 <EvanR> the package is called split
15:13:50 <donjoe2> can i install it with apt?
15:14:29 <EvanR> probably a bad idea if you can
15:14:32 <donjoe2> if not, where should I place the package?
15:14:37 <fishythefish> that depends on your distro, but you probably want to use a haskell dependency manager
15:15:44 <fishythefish> stack and cabal-install are two options
15:16:39 <donjoe2> ghc-pkg cannot do that?
15:17:21 <EvanR> it cant downloand install it for you no
15:17:34 <EvanR> with one command
15:17:38 <donjoe2> i downloaded the archive
15:17:40 <zamrir> EvanR: thanks, so why is this OK? http://lpaste.net/365101 (second function there)
15:17:48 <donjoe2> can ghc-pkg install it?
15:18:08 <zamrir> EvanR: or what is the difference bwtween those 2?
15:18:36 <donjoe2> or do i do "runhaskell Setup.hs" ?
15:18:49 <EvanR> zamrir: its not really ok. but the difference is... you treated getline as a [Char] in one case, and an IO action that returns a [Char] in another
15:19:09 <EvanR> donjoe2: the program youre looking for is cabal
15:19:26 <EvanR> (or stack)
15:20:12 <zamrir> EvanR: so i can do (x:xs) if both x and xs are IO action (or Chars of course)?
15:20:18 <EvanR> no
15:20:32 <EvanR> :t (:)
15:20:33 <lambdabot> a -> [a] -> [a]
15:20:39 <zamrir> seperatly i mean
15:20:47 <zamrir> id they both Cahe i can do that
15:20:56 <zamrir> and also if they both IO action i can do that
15:21:03 <zamrir> id = if
15:21:10 <zamrir> Char
15:21:11 <EvanR> you cant do it if they are IO actions, you cant do it if they are both Chars
15:21:27 <EvanR> a -> [a] -> [a] tells you when and only when you can do it
15:22:26 <EvanR> if a=Char, then (:) :: Char -> [Char] -> [Char]
15:22:43 <EvanR> > 'c':"ccc"
15:22:45 <lambdabot>  "cccc"
15:22:48 <zamrir> from thi signature how the second function works? its not IO String -> IO [String]
15:23:18 <EvanR> in the second function, c::Char and xc::[Char]
15:23:30 <zamrir> or IO Char -> IO [Char]
15:23:45 <EvanR> IO is not allowed with : at all
15:23:49 <zamrir> Ah i thought it's IO
15:23:56 <EvanR> not even close
15:24:00 <zamrir> :)
15:24:29 <zamrir> you said before it's not really OK. why it's not really OK?
15:25:04 <zamrir> this example is from grahm hutton book
15:25:10 <zamrir> (the working one)
15:25:26 <Rembane> :t fmap
15:25:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:25:45 <zamrir> *graham
15:25:55 <EvanR> zamrir: maybe its not that bad then ...
15:26:01 <zamrir> :-)
15:26:27 <EvanR> but getline2 does recursion for every character but must eventually return to do c:xc
15:26:43 <EvanR> so it will build up a chain of thunks
15:27:12 <EvanR> the longer the line, the more memory it will use
15:27:47 <EvanR> basically this wont let you process the line lazily
15:27:55 <zamrir> ah you mean it's not efficient? it's OK for now i think. it's a tutorial of haskell so i think it just want to clear some things without worry for now for efficiency
15:28:10 <zamrir> he, no it :-)
15:28:30 <EvanR> i guess so
15:28:48 <zamrir> thanks a lot EvanR :-)
15:30:09 * hackage temporal-media 0.6.3 - data types for temporal media  http://hackage.haskell.org/package/temporal-media-0.6.3 (AntonKholomiov)
15:30:46 <zamrir> EvanR: well last question for now (i think) how would you do the getline function so that it will not build chain of thunks?
15:31:34 <EvanR> you would have to either restructure your processing to allow IO to happen interleaved with processing, or use "lazy IO"
15:32:07 <EvanR> theres a few libs for the first one, pipes, conduit
15:32:22 <zamrir> ah it's advanced for me i think.
15:32:35 <EvanR> if the lines are not long, its fine
15:32:44 <zamrir> ok
15:33:12 <EvanR> if the lines are long, well, have you ever used the program "notepad.exe" :)
15:33:32 <EvanR> you might have to kill it if you accidentally open a file with long lines
15:33:32 <zamrir> yes i did, iwrap lines :-)
15:34:12 <zamrir> i don't remember it was happend to me
15:34:22 <zamrir> (maybe i didn't have long lines)
15:35:25 <EvanR> you can also use IO operations from Data.Text or Data.ByteString to get lines
15:37:01 <zamrir> in the book it has this line: (The actual definition for getChar is built into the GHC system.). is this mean that it's not implemented in haskell? also why?
15:37:26 <EvanR> getChar is a primitive IO action
15:37:37 <EvanR> it interfaces with the outside world
15:38:17 <Xal> zamrir: how do you think getchar() in C is implemented :P
15:38:36 <Xal> every time you have to do something IO related that's primitive, you need to go down a layer of abstraction
15:38:41 <Xal> in C's case, you need a system call
15:39:33 <Xal> http://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.IO.Handle.Text.html#hGetChar
15:39:37 <zamrir> OK so Bool is also a prmitive but it's defined in haskell because it doesn't belong to IO?
15:39:57 <EvanR> Bool isn't a primitive really
15:39:57 <Xal> Bool isn't really a primitive, it's just a regular haskell type
15:40:11 <zamrir> what is the definition of primitive?
15:40:32 <EvanR> not composed of other pieces
15:40:35 <Xal> something that has to be implemented with compiler-specific haskell
15:40:38 <EvanR> thats my theory
15:42:18 <donjoe2> now i've got the following error
15:42:20 <donjoe2> "Could not find module ‚ÄòData.List.Utils‚Äô
15:42:21 <donjoe2>     Perhaps you meant
15:42:21 <donjoe2>       Data.List.Split (needs flag -package-key split-0.2.2@split_2HX8EqgvDIgHYwxogxhVQv)
15:42:21 <donjoe2>       Data.List.Split (from split-0.2.3.3@split_GQcN2UKVYcC99nSV46ay10"
15:42:29 <donjoe2> i just installed split
15:42:30 <EvanR> maybe a better definition here is, "has no definition in the language"
15:43:27 <fishythefish> donjoe2: Data.List.Utils comes from the MissingH package, not split
15:44:03 <zamrir> thank you again :-)
15:44:11 <zamrir> also Xal :)
15:44:19 <donjoe2> what about Data.List.Split ? That's what is used in the program
15:44:35 <fishythefish> As we said before, Data.List.Split comes from the split package
15:45:04 <donjoe2> so if I installed split, why it gives "Util" missing? I dont use that
15:45:25 <fishythefish> do you have `import Data.List.Utils` anywhere in your code?
15:46:19 <donjoe2> I feel so dumb right now
15:46:37 <donjoe2> After I installed split, I was running another program which required Util
15:46:47 <donjoe2> :(
15:46:56 <Xal> sounds like you need some stack
15:47:02 <donjoe2> It works now. Thx
15:52:42 <zamrir> well i have another question regarded the getline. for example if i have this string "1" at first getChar give 1 to variable c. then it is asking what is c. is it '\n'? NO, so it moves to getline again and now it gets '\n' so again it asks what is c and now it is the new line so it returns IO String which is just the [], so now i come back to the outer function and variable xc get the IO String whych is [], and then
15:52:42 <zamrir>  i return c (which is 1 and also if i understnad well it's IO Cahr) : xc (which is IO String). but you said i cant make IO : IO
15:53:06 <zamrir> this is the function again (second one): http://lpaste.net/365101
15:53:23 <EvanR> incorrect
15:53:45 <EvanR> in  c <- getChar  c is not an IO Char
15:53:48 <EvanR> c is a Char
15:54:12 <EvanR> :t 'w'
15:54:13 <lambdabot> Char
15:54:15 <Xal> when you use <- it "unboxes" the inner type from the monad
15:54:17 <zamrir> OK but the return function return IO
15:54:18 <EvanR> :t getChar
15:54:19 <lambdabot> IO Char
15:54:42 <Xal> zamrir: c = getChar returns an IO Char, c <- getChar returns a Char
15:54:56 <Xal> you can only use <- in "do" blocks because it "unboxes" stuff from monads
15:55:00 <EvanR> theres no unboxing... no monads... its just the difference between a physical character (Char), and a command to get a character
15:55:09 <Cale> I don't know what code you're reading exactly, but xc had better not be an IO String if you're giving it as an argument to (:)
15:55:16 <donjoe2> let f 0 y = []; f x y = x:y in foldr f [] [4,6,0,1] ..... Why does this return [4,6] and not [4,6,1] ?
15:55:27 <EvanR> yes we tried to go over that already a few times
15:55:37 <Xal> EvanR: yes, but it can be a useful intuition
15:55:41 <zamrir> EvanR: you are funny :-D
15:55:43 <EvanR> gross
15:56:19 <EvanR> IO Char is not some character that can magically do IO or something, its a command
15:56:32 <Cale> Yeah, it's usually better to think of the difference between IO String and String as being like the difference between /bin/ls and a listing of the files in your home directory
15:56:33 <Xal> yes, it's an IO action that produces a Char when "performed"
15:57:00 <Xal> thinking of `IO a` as a "box that returns a when performed" can be useful
15:57:09 <EvanR> perform a box!
15:57:17 <Xal> you know what I mean
15:57:21 <EvanR> containers explain everything !
15:57:36 <Xal> don't burrito me
15:57:54 <zamrir> so in the return (c:xc) it returns IO but when i'm in the do notation with the <- thing it again "come back" to Char without IO?
15:57:56 <EvanR> think of a parser as a box... with a guy in there who can parse stuff
15:58:33 <Cale> zamrir: When you write  v <- x  in a do-block, it means "execute the action x, and call whatever its result is v"
15:58:49 <Cale> zamrir: So if x :: IO a, then v :: a
15:59:17 <Cale> and then the do-block as a whole will itself be an IO action (of some type which is the same as the last action in it)
15:59:37 <zamrir> i think i almost understand what you are telling me :-)
15:59:52 <EvanR> do notation is sugar that becomes >>=
16:00:02 <EvanR> (>>=) :: IO a -> (a -> IO b) -> IO b
16:00:09 <EvanR> thats why it goes from IO Char to Char
16:00:24 <EvanR> c is the argument to that handler function
16:00:28 <monochrom> Boxing is wrong.  Even "it's a music box" is wrong.  A music box plays the same song again and again.  getChar doesn't return the same character again and again.
16:00:35 <Cale> Yeah, if for some reason, you're more comfortable with (>>=), then you can understand it that way:  do v <- x; <stmts>  is the same as  x >>= (\v -> do <stmts>)
16:01:02 <Cale> monochrom: But a jukebox...
16:01:07 <zamrir> EvanR: can you please give exmaple function for this type signature?
16:01:11 <monochrom> But people will do everything to hold on to their flawed box analogy.
16:01:31 * EvanR hides under a box
16:01:47 <EvanR> don't run this box please
16:01:47 * Rembane sits on said box
16:01:56 * Xal jumps into a box using pure
16:02:34 <EvanR> think of parentheses as a box
16:02:42 <Xal> think of boxes as burritos
16:02:50 <EvanR> that magically dont do anything if you put more and more boxes, its equivalent to one box
16:03:00 <EvanR> very special kind of box
16:03:28 <Xal> think of haskell as a box that holds the data your program with produce
16:03:42 <chorhizo> these are the analogies I've been lacking
16:03:49 <chorhizo> it all makes sense now :^)
16:04:01 <EvanR> in the beginning, there was nothing... in a box. then god put stuff in it
16:04:11 <chorhizo> I think of haskell more more like a big fish... little fish... cardboard box
16:04:16 <monochrom> Is this a Haskell channel or a Harry Potter channel?  Why are people attributing magic to boxes?
16:04:20 <Rembane> Y'all need to program more in APL. It has some serious boxes!
16:04:38 <zamrir> are you all mathematicians?
16:04:55 <chorhizo> I am a boxematician
16:05:05 <monochrom> Then again the very reason you chose programming is because you can't do science.
16:05:09 <Cale> I have a BMath degree in pure mathematics, but I'm working as a Haskell programmer.
16:05:18 <con-ji> i'm just a bored undergrad trying to learn this weird language
16:05:27 <chorhizo> con-ji, same
16:05:44 <con-ji> sup fam, what year/major(s)?
16:06:12 <chorhizo> on an internship at the moment, but 3rd year in sept, comp sci
16:06:14 <Cale> Haskell programmers are applied logicians who spend all their time proving trivial theorems in ever more interesting ways in an inconsistent intuitionist logic.
16:06:17 <Xal> con-ji: you must be mistaken
16:06:20 <Xal> this is the box channel
16:06:27 <con-ji> ah my bad
16:06:31 <con-ji> i'm a bored boxdergrad
16:06:36 <chorhizo>  /join #box-channel
16:07:04 <EvanR> i see how object oriented programming was auto successful
16:07:16 <con-ji> and neat chorhizo, im starting mine halfway thru may - cs + math 3rd yr
16:07:21 <EvanR> its a generalization of box oriented
16:09:33 <EvanR> i seem to be missing a megaparsec IRC channel
16:10:29 <Rembane> Cale: I can relate to that.
16:11:45 <con-ji> i put some haskell in a box but then i knocked it over, is my code gonna be ok
16:12:24 <chorhizo> I don't think so, I think you need to port it to fortran
16:12:43 <EvanR> i strayed from the tradition of consuming all whitespace after each thing in megaparsec... and now nothing works or makes sense :(
16:12:51 <EvanR> for the last 6 hours
16:13:30 <EvanR> i wonder if they baked this tradition into an assumption of makeExprParser
16:20:42 <Zipheir`> Monad == A box without hinges, key or lid.
16:21:22 <Zipheir`> But golden >>=ings inside are hid.
16:23:10 <fishythefish> monads are eggs
16:23:20 <DigitalKiwi> https://xkcd.com/1838/ obviously cueball just needs a box
16:26:14 <ggVGc> does eggs form a monad?
16:27:36 <DigitalKiwi> the incredible monadable egg
16:27:42 <EvanR> you cant put anything into an egg, you can only hatch it. that would be comonads
16:28:38 <DigitalKiwi> https://youtu.be/8liZzROplmk
16:29:33 <fishythefish> yeah but it's not a comonad either because you can't put an egg inside an egg
16:30:12 <DigitalKiwi> i dunno ostrich eggs are quite large
16:30:31 <Rembane> Are Matryoshka dolls comonads?
16:30:35 <EvanR> http://worrydream.com/AlligatorEggs/
16:30:45 <zamrir> i don't understand why it is importand to seperate Char from IO Char (etc'). why there is distinction from "pure" to "unpure" types? is there maybe an example for a proccess that benefit from this?
16:31:31 <Rembane> zamrir: Knowing that a function won't fire the missiles is quite powerful. And if the function doesn't have the IO type, it generally won't have any side effects.
16:31:38 <fishythefish> zamrir: a Char doesn't change each time you evaluate it
16:32:33 <Maxdamantus> do { a <- getChar; b <- getChar; c <- getChar; print [a, b, c] }
16:33:04 <fishythefish> something of type Char must be a constant character; but getChar :: IO Char can produce a different character each time it's invoked
16:33:29 <monochrom> zamrir: If "x :: Char" then x is the same character every time.  So x should not be reading from stdin.  This is a design choice of Haskell.
16:34:22 <monochrom> The benefit is that if f c = [c,c] then f x = [x,x].
16:34:33 <jle`> zamrir: a 'Char' and an 'IO Char' are different things
16:34:54 <jle`> zamrir: one is a Char, and the other is a description of an IO action that makes a Char
16:34:56 <DigitalKiwi> these egg commercials are funny
16:35:08 <monochrom> Whereas other languages like SML and Scheme make a difference between [getChar, getChar] and f getChar and forbids equational reasoning.
16:35:09 * hackage redland 0.2.0.2 - Redland RDF library bindings  http://hackage.haskell.org/package/redland-0.2.0.2 (defanor)
16:35:29 <jle`> zamrir: the benefit is a big-picture thing from being able to work with IO actions as first-class values
16:35:34 <jle`> instead of as magic
16:35:41 <monochrom> I guess it's less clumsy if I used a lambda instead of introducing f.
16:36:14 <Zipheir`> Theoretical question: Is there any meaningful way to evaluate for x, y :: IO Char, x == y?
16:36:18 <monochrom> So, in Haskell: (\c -> [c,c]) x = [x,x].  This doesn't hold in other languages.
16:36:38 <zamrir> jle`: what do you mean by "as magic"?
16:36:40 <monochrom> And of course if you say this benefit sacrifices something else, sure.
16:37:05 <Maxdamantus> Zipheir`: not without introspecting the `IO Char` values.
16:37:10 <jle`> zamrir: in other languages, IO actions are not something you can treat as first-class values
16:37:15 <jle`> zamrir: as soon as you 'reach' them, they are executed
16:37:19 <EvanR> i still havent really figured out what `getline` would mean in ruby
16:37:24 <jle`> if you try to pass them as values, they are executed
16:37:40 <jle`> zamrir: you can't, say, have a function that takes an IO action, and returns a new IO action that represents doing the same one twice
16:37:45 <jle`> doTwice x = x >> x
16:37:46 <Maxdamantus> Zipheir`: and if you did allow introspection, you'd still have to decide what equality means.
16:37:59 <monochrom> Yeah in other languages people have to wrap an extra layer of lambda to pass around an IO action.
16:38:07 <jle`> doTwice doesn't take a Char, it takes a description of an IO action
16:38:14 <jle`> and it returns a *new* description
16:38:19 <jle`> from the description that it receives
16:38:36 <jle`> zamrir: if IO actions are first class values, you might have a bunch of ways to write a [IO a] -> IO [a]
16:38:36 <Zipheir`> Maxdamantus: Right, that's what I thought.
16:38:52 <jle`> zamrir: an [IO a] -> IO [a] takes a list of IO actions, and returns a new one that produces a list of results
16:39:06 <EvanR> ok yeah... in any language, i dont think anybody thinks that Chars should be doing IO actions every time you look at them...
16:39:18 <jle`> zamrir: the function implementor has an option of how to combine those actions to create a new one
16:39:18 <EvanR> they should just be values
16:39:25 <jle`> zamrir: this isn't something you can express in other languages
16:39:30 <jle`> at least not without heavy machinery
16:40:00 <Maxdamantus> EvanR: presumably it wouldn't be an issue with the `Char`, but how you get the `Char`.
16:40:02 <jle`> zamrir: for example, sequence :: [IO a] -> IO [a] takes a list of IO actions and produces a new one where the effects of the list are all done in order
16:40:29 <jle`> but you could imagine doParallel :: [IO a] -> IO [a], which takes a list of IO actions, and returns a new one that does them all in parallel
16:40:42 <Maxdamantus> in Haskell, `a` doesn't mean to evaluate anything .. it just evaluates to the value of the variable.
16:40:49 <jle`> zamrir: this is only possible beucas eyou can "pass a list of IO acitons", because IO actions are just normal values
16:41:01 <jle`> zamrir: in other languages, you can't just pass [IO a], you have to pass a list of the results
16:41:09 <jle`> and already there, you lose control of how you can manipulate them
16:41:21 <EvanR> yeah we passed into a world of nonsense... in other languages you might see () -> Char, and this is not a Char either. but you do IO everytime you "run" the function
16:41:22 <Maxdamantus> but in Scala (and based on what I read above, presumably SML/Scheme), `a` might be a definition which gets evaluated.
16:41:37 <Maxdamantus> actually, `a` could be a definition in Haskell too, so it's kind of a matter of mutability.
16:41:38 <EvanR> nobody has Char that does IO
16:41:42 <jle`> you can even imagine a sequence :: [IO a] -> IO [a], that does all of the actions "twice"
16:41:58 <Maxdamantus> well, of side effects, at least.
16:42:26 <jle`> zamrir: in the end you get a lot of benefit from treating IO actions as first-class values you can manipulate, combine, pass around, etc. without any side effects
16:43:01 <DigitalKiwi> zamrir did you say you're reading the graham hutton book?
16:43:09 <zamrir> well you sort of blown my mind. i will save all you wrote for later reading.
16:43:23 <zamrir> yes i'm on grham hutton book
16:43:38 <zamrir> *graham
16:43:49 <DigitalKiwi> he does a great job of explaining monads etc. better than all of the blog posts etc.
16:44:08 <EvanR> note were not really talking about monads, but the IO API
16:44:16 <zamrir> i'm in the begginig of part 2 of his book when he starts the IO thing.
16:44:16 <EvanR> and the IO types
16:45:02 <DigitalKiwi> it's all eggs all the way down amirite
16:46:31 <monochrom> On that note, Hutton still begins with World->(a,World) :)
16:46:48 <Rembane> Old school!
16:47:45 <Zipheir`> Hutton's pretty clear on Monad, but his exposition of Applicative and Monoid could be better.
16:48:27 <EvanR> if () -> World is a function which, when evaluated, causes unclear unaccounted side effects and returns a world. can i have a World -> () which destroys the universe
16:48:49 <EvanR> and compose them in a cycle
16:48:51 <DigitalKiwi> please try
16:49:07 <Rembane> EvanR: Isn't that hinduism? Just compose the right gods in the right order.
16:49:15 <monochrom> heh
16:49:29 <Xal> think of the universe as a box
16:49:36 <Rembane> I think of it as an egg
16:49:37 <DigitalKiwi> or an egg?
16:49:46 <monochrom> DigitalKiwi: I prefer: It's lasagna all the way down :)
16:50:13 <DigitalKiwi> http://galactanet.com/oneoff/theegg_mod.html
16:50:29 <spruit11> You people sure it's not mochito?
16:50:47 <DigitalKiwi> I don't even know what mochito is so I'm not sure
16:51:10 <Zipheir`> tequila + Cheetos?
16:51:19 <monochrom> Perhaps you mean: mojito, mosquito
16:51:23 <DigitalKiwi> misspell mojito?
16:51:28 <Maxdamantus> I just think of it as a magical thing that knows how to run `IO t` values.
16:51:39 <DigitalKiwi> no, definitely an egg
16:51:48 <EvanR> its deeply magic, as documented
16:52:05 <EvanR> deeply magical
16:52:06 <DigitalKiwi> get your maths and logic out of here! we're cooks
16:53:24 <zamrir> OK i think i don't understand well what do you mean "side effects". if i have function p that gets a string "str" and when i do in GHCi p "str" i get "str" in return. this is not a side effect?
16:54:34 <spruit11> Ah right, it's mojito?
16:54:37 <jle`> ghci is a repl
16:54:57 <jle`> if you do it in a normal haskell file, nothing will be printed
16:55:08 <jle`> ghci outputs 'str' because it's useful for debugging
16:55:22 <jle`> not because that is an actual side-effect of 'p'
16:55:29 <zamrir> do you mean by "normal haskell file" to main = ...?
16:55:38 <Maxdamantus> If you give ghci a `String`, it will print it. If you give ghci an `IO String`, it will run the `IO String` value and print the result.
16:55:39 <jle`> yes, anywhere that is not a REPL
16:56:50 <Maxdamantus> If you give ghci a `Fish`, it will eat for a day. If you give ghci an `IO Fish`, ..
16:57:05 <zamrir> what is side effect? i want to distinct it from actions that don't have side effects.
16:57:11 <DigitalKiwi> what if you give it lasagna
16:57:12 <Zipheir`> Maxdamantus: Lifelong loop of fish-eating?
16:57:25 <Maxdamantus> Zipheir`: potentially. It's up to ghci.
16:57:40 <Zipheir`> zamrir: What is the value of 2 + 2?
16:57:42 <Maxdamantus> Your `IO Fish` might never actually get a fish though.
16:57:47 <zamrir> 4
16:58:03 <Zipheir`> zamrir: What is the value of writing "2 + 2" on a piece of paper?
16:58:16 <zamrir> 2 + 2 (?)
16:58:25 <DigitalKiwi> side effect is an additional effect that is not what you intended, it can be hidden and not obvious what the effect is, that's why they're bad
16:58:51 <zamrir> (the question maek is not an operator . it's me asking you if im right)
16:59:09 <EvanR> whats the value of 2++
16:59:10 <Zipheir`> zamrir: In Haskell it would be IO ()
17:00:50 <EvanR> 2++; 2 + 2
17:00:53 <EvanR> 6
17:01:32 <zamrir> EvanR: how can it be?
17:01:37 <EvanR> side effects
17:01:49 * EvanR drops the mic
17:01:55 <zamrir> :-D
17:02:21 <dstolfa> EvanR: effects, coeffects, side effects!
17:03:18 <zamrir> EvanR: where can i write this for execution? (2++; 2 + 2)
17:03:32 <zamrir> in ghci it's not working
17:03:44 <fishythefish> > 2 Ôºã 2
17:03:46 <lambdabot>  6
17:03:53 <fishythefish> hmm, works for me
17:04:00 <chorhizo> wait what
17:04:10 <zamrir> what is this?
17:04:10 <chorhizo> > 2 + 2
17:04:12 <lambdabot>  4
17:04:15 <zamrir> the big Plus
17:04:38 <zamrir> ah i'm on emacs so i see symbols. what is there in between 2 and 2?
17:05:15 <EvanR> i see it as a +
17:05:20 <chorhizo> same
17:05:20 <EvanR> but slightly bigger
17:05:25 <zamrir> yes.
17:05:29 <zamrir> what is this?
17:05:38 <EvanR> shenanigans
17:05:47 * fishythefish whistles innocently
17:05:53 <DigitalKiwi> lulz
17:05:59 <zamrir> > 2 + 2
17:06:01 <lambdabot>  4
17:06:08 <zamrir> what is the difference from this?
17:06:18 <EvanR> apparently 2++ is illegal in C, unfortunate missed opportunity for hilarity
17:07:00 <Clint> > (2 Ôºã 2) - (2 + 2)
17:07:02 <lambdabot>  error:
17:07:02 <lambdabot>      Variable not in scope: (Ôºã) :: Integer -> Integer -> a
17:07:03 <fishythefish> if you want hilarity, just put something like `#define true false` in a header other people use
17:07:08 <Clint> aww
17:07:21 <EvanR> zamrir: fishythefish defined a rogue version of + which gives 2+2 = 6
17:07:27 <EvanR> behind the scenes
17:07:39 <fishythefish> ~magic~
17:07:39 <zamrir> ah...
17:08:08 <DigitalKiwi> PAY NO ATTENTION TO THE EGG BEHIND THE CURTAIN
17:08:16 <EvanR> when he did that at intel people were not amused
17:08:40 <fishythefish> hey, i got a few chuckles from amd
17:08:52 <DigitalKiwi> chortle
17:11:47 <zamrir> have a good night all of you and thanks for your answers throghout the (in my area) night :-).
17:11:57 <DigitalKiwi> ta
17:19:39 * hackage reactive-banana-automation 0.1.1 - home (etc) automation using reactive-banana  http://hackage.haskell.org/package/reactive-banana-automation-0.1.1 (JoeyHess)
17:20:00 <EvanR> what is the difference between skipMany (char ' ') and L.space (skipMany (char ' ')) empty empty
17:20:22 <EvanR> the first one sometimes works, the second one freezes me up...
17:22:27 <lyxia> megaparsec's space must not be applied to a parser that may accept an empty string
17:22:58 <EvanR> space or L.space
17:23:15 <lyxia> whichever takes three arguments
17:24:07 <EvanR> so what kind of parser is it expected?
17:24:20 <EvanR> one that skips 1 or more space?
17:24:25 <lyxia> yeah
17:24:32 <EvanR> ... ok
17:25:17 <EvanR> whats the benefit of that over just using a skip zero or more space parser
17:26:14 <pavonia> When converting between numeric formats, is there a rule of thumb when to use fromEnum/toEnum as opposed to fromIntegral?
17:26:26 <pavonia> *numeric values
17:27:57 <lyxia> EvanR: I think they're the same
17:28:23 <hpc> pavonia: use fromIntegral to tell the reader your intent is to convert between numbers
17:28:31 <lyxia> I guess it might look more uniform to go through L.space every time you create a new parser
17:28:38 <hpc> pavonia: use fromEnum/toEnum to tell the reader your intent is to convert from an enumeration to an index of it
17:28:44 <hpc> pavonia: (the reader of your code, that is)
17:29:41 <pavonia> Okay
17:29:45 <hpc> (in obnoxiously tweetable form, "make code look like what it does")
17:30:16 <pavonia> I thought there may be a semantic or performance difference perhaps
17:30:23 <DigitalKiwi> DefinitelyDoesNotLaunchTheNukes()
17:30:30 <hpc> most of that constant time stuff vanishes with -O2
17:30:38 <hpc> and if it doesn't and you care, discover that during profiling
17:31:32 <hpc> throws ButIAmLeTired
17:31:35 <hpc> DigitalKiwi: ^
17:50:52 <grossghost> karma brisbin
18:08:39 <laudecay> are there any guides online for how to improve your haskell writing skills
18:08:47 <laudecay> because i feel like i'm writing imperative code for a lot of this
18:08:52 <laudecay> and it's soooooo ugly aaaaaaa
18:08:56 <laudecay> i mean it works but
18:08:58 <laudecay> ew
18:14:51 <GodotMisogi> laudecay: Any examples?
18:15:14 <laudecay> i'm somewhat embarrassed of this code
18:16:48 <laudecay> GodotMisogi: it's also a class assignment and I dunno about sharing it
18:17:21 <GodotMisogi> Oh, what's the assignment?
18:17:25 <laudecay> paxos
18:17:39 <laudecay> in any language, and i picked haskell, because i wanted to get better at haskell
18:17:56 <laudecay> i guess i'll start with the overall structure that i'm using... i'm basically unfoldr
18:17:58 <laudecay> fuck
18:18:22 <EvanR> right i remember this
18:18:32 <EvanR> you insisted on doing everything imperatively
18:18:42 <laudecay> unfoldr'ing a series of state transitions onto a datatype thing
18:18:49 <laudecay> EvanR: i don't know any other way lol
18:19:00 <GodotMisogi> laudecay: I did the same thing for an NLP assignment
18:19:04 <EvanR> great time to learn
18:19:13 <GodotMisogi> But I used it to learn Haskell from scratch
18:19:15 <laudecay> EvanR: tryin' :P
18:19:29 <laudecay> GodotMisogi: i took a class last year thankfully but it was sorta 101
18:19:52 <laudecay> i managed to clean things up a lot with lenses but oh god paxos has so many moving parts
18:21:18 <laudecay> but yeah anyway the unfoldr thing is real pretty but the rest of it is pretty much just imperative.
18:21:29 <laudecay> like 12 lines in the "where" bit
18:22:10 <laudecay> i'm using some foldrs and maps and stuff but wow wrapping all these maybe's is terrible
18:22:15 <laudecay> i think i'm doing something wrong
18:22:44 <Hijiri> Surprised to see this on cppreference http://en.cppreference.com/w/cpp/algorithm/execution_policy_tag
18:22:55 <chewzerita> is dependent typing a meme or actually useful (aka should i switch from haskell to idris?)
18:24:34 <Hijiri> is thing being a meme a meme
18:24:57 <vibrant> Yes
18:25:03 <EvanR> take the fixed point of taking the fixed point
18:25:16 <laudecay> EvanR: I don't understand
18:25:37 <EvanR> nvm
18:26:06 <Hijiri> in haskell the fixed point of taking the fixed point would be bottom
18:26:19 <laudecay> wow i don't know what that means either
18:26:20 <Hijiri> or, the least fixed point
18:26:24 <laudecay> oh god i suck so much at this
18:26:30 <Hijiri> because any constant function would be a fixed point
18:27:03 <Hijiri> wait, that doesn't make sense
18:27:13 <Hijiri> nevermind
18:28:09 <Hijiri> I think in haskell it would just be badly typed
18:28:26 <Hijiri> since the function type and argument type would have to be the same
18:28:42 <lyxia> :t fix fix
18:28:43 <lambdabot> error:
18:28:43 <lambdabot>     ‚Ä¢ Occurs check: cannot construct the infinite type: a ~ a -> a
18:28:43 <lambdabot>       Expected type: a -> a
18:29:00 <EvanR> laudecay: probably not the simplest starting project to get functional experience with
18:29:09 <laudecay> fair
18:29:17 <Hijiri> write a FPS MMO in haskell
18:29:21 <laudecay> idk i have done other projects but
18:29:32 <laudecay> nothing at this scale? and i don't know how to structure code this big in haskell
18:31:43 <EvanR> how do you structure code this big in other languages
18:32:00 <Hijiri> put all code in Paxos.cpp
18:32:02 <laudecay> i mean object-oriented and just... imperative stuff
18:32:11 <EvanR> and that works?
18:32:27 <laudecay> yeah but i'm doing the same thing here and it is /not/ going well
18:32:45 <EvanR> i am skeptical about the "yeah" part
18:32:55 <laudecay> i'm just passing data structures around really grossly in lieu of having like class methods or something
18:33:17 <EvanR> you basically want to use scoped global vars, separated into classes
18:33:36 <EvanR> when you think of something new to do, create a new class, in order to use mutable variables to store it in?
18:34:02 <laudecay> and when i need to do a series of actions to a data structure... instead of something like p.thing++; p.foo = bar;, i'll do like 3 rounds of p' = over foo (something) p
18:34:11 <laudecay> uhhhhh wdym like "something new to do"
18:34:42 <EvanR> the next part of the project that you identifier should be separated
18:34:45 <EvanR> identified
18:34:52 <laudecay> wait what do you mean
18:35:03 <laudecay> you lost me a while ago
18:35:42 <EvanR> this is my understanding of "good" large scale OOP methodology for 1 programmer
18:35:56 <laudecay> oh i thought you had changed subjects im sorry
18:36:02 <laudecay> yes that's accurate-ish
18:36:21 <EvanR> lots of classes, separated concerns, lots of "global" mutable vars scoped to each class
18:36:25 <laudecay> modular design as much as possible, if something has to do with one object only then you put it in a class method or instance method
18:36:28 <laudecay> yeah that
18:36:41 <EvanR> well, now you have the opportuntity to take "modular" seriously
18:37:26 <laudecay> so you think the solution is just making functions everywhere
18:37:48 <laudecay> taking something out of the network queue? function. putting something in? function.
18:37:52 <laudecay> okay i think that could probably work
18:38:10 <laudecay> like instead of having 12 lines in a where clause, i just compose some functions that i wrote?
18:38:51 <EvanR> the concept of a queue is not a function, its a data structure
18:38:58 <EvanR> do you have one?
18:39:21 <laudecay> i'm using a sequence because i need the elemIndexL
18:39:40 <laudecay> but like a function to edit the current state in a way that takes something out of the queue and processes it
18:39:45 <EvanR> you implemented your queue using Data.Sequence... is your queue in its own file with the reusable methods in there
18:39:48 <laudecay> i think is what i meant
18:39:54 <EvanR> or are you using Data.Sequence everywhere directly
18:40:03 <laudecay> oh i'm using Data.Sequence directly
18:40:08 <EvanR> is it messy
18:40:13 <laudecay> not too messy
18:40:19 <laudecay> it's definitely not the worst thing in my code
18:40:43 <laudecay> Data.Sequence has literally every nice function I could dream of
18:40:48 <laudecay> which is helping the messiness
18:40:48 <EvanR> well, whether or not its messy, its going against your idea that stuff should be in its own module accessed through an interface ("class methods")
18:41:29 <laudecay> hmmm.... so I'd have a whole separate file just to deal with one aspect of the overall state datatype?
18:41:33 <EvanR> if you are doing operation x, which uses at least 2 things from Data.Sequence in more than 1 place, you are missing a place to clean it up
18:41:42 <EvanR> how many files do you have?
18:41:45 <laudecay> two
18:42:08 <laudecay> one's a parsing library to get everything loaded into these data structures and packaged up into the PaxosState datatyle
18:42:09 <EvanR> ime thats absurd for even a small haskell program
18:42:14 <laudecay> oh really? huh
18:42:37 <laudecay> okay i'll start working on making everything really modular as soon as i finish debugging and testing what i have now
18:42:46 <laudecay> that'll really help make this nicer damn
18:43:23 <laudecay> thank you so much!!!
18:43:24 <EvanR> if you have a PaxosState data type... assuming this is not already too big... then thats yet another module you will want an API for
18:43:37 <EvanR> instead of messing with directly everywhere
18:43:52 <laudecay> PaxosState is what i'm unfoldr'ing on
18:44:05 <laudecay> it incorporates literally all information about the state of the simulation
18:44:24 <laudecay> it has 3 maps of various datatypes, some random ints, and that sequence
18:44:44 <laudecay> is that too big? i could definitely prettify by adding some extra files.
18:44:57 <EvanR> well if to do something with it requires 3 levels of lenses, and youre doing this more than once, your missing an opportunity to put the access operations away in a module
18:45:08 <EvanR> if doing something with it*
18:45:22 <laudecay> ok yeah i will definitely be doing that.
18:45:31 <laudecay> thank you so so so much holyshit
18:45:56 <laudecay> an excerpt from my code: "    p' = over props (update (Just.(over rejectedcount (+1))) pn) p"
18:46:07 <laudecay> welcome to H e cK
18:46:21 <EvanR> whatever that does, you can name it something saner and put it behind an API
18:46:50 <laudecay> that increments the number of rejections one proposer has gotten, when it receives a rejection message
18:46:58 <laudecay> it needs some love.
18:47:00 <EvanR> then, your unfoldr function itself can probably benefit from a DSL that has operations (implemented in yet another module) to operate on the state, without doing p' =
18:47:10 <laudecay> DSL?
18:47:23 <EvanR> something like a custom monad
18:47:34 <laudecay> g u e s s who barely knows how to monad
18:48:08 <laudecay> wait wait wait i might actually understand how to do this
18:48:10 <laudecay> omg
18:49:09 <laudecay> from wikipedia: "In addition, the join function characterizes monads:"
18:49:16 <laudecay> so do i just have to figure out how to implement join?
18:49:21 <EvanR> custom monads can be implemented by hand, using monad transformers, or using free monads. the idea is to create yet another API to make it easy to write the algorithm, not doing everything directly
18:49:41 <EvanR> including not using State monad operations directly
18:49:51 <EvanR> or whatever it may be
18:50:01 <laudecay> okay
18:50:05 <laudecay> im going to go read about monads
18:50:07 <EvanR> join is really beside the point here
18:50:26 <EvanR> i am really talking about the API
18:50:46 <laudecay> how would i like define "return" on these
18:51:04 <EvanR> return is usually the most trivial thing
18:51:31 <laudecay> i think i really just want do notation here? is that right?
18:51:54 <EvanR> back to what i was saying, imagine you want to "increment the number of rejections for client i" ... then you can have this in your API:  incrementRejectionCount :: ClientID -> MyMonad ()
18:52:08 <laudecay> ooooo okay
18:52:30 <EvanR> and in your algorithm... yes in do notation... you would have a line that looked like incrementRejectionCount i
18:52:36 <laudecay>     return  :: a -> m a <- so this just gives some like idk identity paxosState?
18:52:40 <EvanR> not gobbledegook
18:52:54 <laudecay> and a :: () ?
18:53:02 <laudecay> what even does () mean i see it everywhere
18:53:06 <EvanR> return :: a -> MyMonad a does nothing
18:53:11 <EvanR> o_O
18:53:17 <EvanR> () is the unit type
18:53:29 <EvanR> @src ()
18:53:29 <lambdabot> data () = ()
18:53:54 <laudecay> so i suppose return x is "i want to wrap x in my monad!"
18:54:16 <laudecay> i guess i don't understand a lot here oh no
18:54:23 <EvanR> it creates an action (in your custom DSL) which doesnt do anything and returns x
18:54:33 <EvanR> which you need sometimes
18:55:14 <laudecay> ohhh wait the Yet another haskell tutorial makes sense
18:55:21 <laudecay> ok i might be good for a bit brb
19:08:42 * hackage gtk2hs-buildtools 0.13.4.0, cairo 0.13.5.0 (HamishMackenzie): https://qbin.io/sticky-closes
19:10:42 * hackage glib 0.13.6.0, pango 0.13.5.0 (HamishMackenzie): https://qbin.io/let-knows
19:12:42 * hackage gio 0.13.5.0, gtk3 0.14.9 (HamishMackenzie): https://qbin.io/locate-shown
19:45:09 * hackage scroll 1.20180421 - scroll(6), a roguelike game  http://hackage.haskell.org/package/scroll-1.20180421 (JoeyHess)
19:46:45 <laudecay> why is this case in my case expression erroring out? SentPrep (fromJust (_num mess))
19:47:10 <laudecay> SentPrep Int is a | type and (_num mess) has type Maybe Int
19:47:26 <lyxia> what if _num mess = Nothing ?
19:47:34 <laudecay> it can't be in this context
19:47:42 <laudecay> (yeah i know i know bad code i'm going to clean it up later)
19:48:05 <DigitalKiwi> seen in a comment 10 years later
19:48:07 <laudecay> it's giving me a parse error
19:48:16 <laudecay> i mean this is due next month so :P
19:48:18 <lyxia> give the error message
19:48:26 <laudecay> /home/claude/distsys/paxosproj/app/Main.hs:80:23: error: Parse error in pattern: _num
19:48:33 <laudecay> heck
19:48:36 <lyxia> this is a pattern?
19:48:41 <laudecay> yeah it's in a case statement?
19:48:43 <lyxia> _num is not a constructor
19:49:01 <laudecay> oh this is the context sorry SentPrep (fromJust (_num mess)) ->
19:49:17 <lyxia> fromJust is also not a constructor
19:49:19 <laudecay> SentPrep is the constructor, i just want to check that it's a specific value of SentPrep
19:49:28 <laudecay> is case not the way to do that?
19:49:40 <laudecay> i thought i could pattern-match on specific values for like an integer
19:50:46 <lyxia> there's too little context for me to guess what you are trying to do.
19:51:07 <lyxia> How are SentPrep, _num, and mess defined?
19:51:58 <laudecay> _num is a Maybe Int field in the NetMessage datatype, which mess is an instance of. SentPrep
19:52:12 <laudecay> SentPrep is defined here: data ProposerState = Idle | SentPrep Int | SentAcc Int | Consensus Int deriving (Show)
19:52:54 <laudecay> I want to check that the proposer's state (_mystate p) is SentPrep (fromJust $ _num mess)
19:53:05 <laudecay> i could probably just use an if statement
19:53:31 <lyxia> case .. of SentPrep n | Just n == _num mess ->
19:53:49 <laudecay> oh mixing guards and cases wild
19:53:56 <lyxia> you can't use functions like that in patterns, it confuses the parser
19:54:02 <laudecay> ohhhh makes sense.
19:54:21 <lyxia> You might want to look at ViewPatterns https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#view-patterns too
19:54:34 <lyxia> it might be close to what you had in mind
19:54:37 <laudecay> i will add it to my list of haskell things to learn
19:54:39 <laudecay> thank you so much
19:55:18 <lyxia> but guards are the standard way to check for equality after some pattern matching
19:55:44 <laudecay> i think im going to go for an if statement, i only care about this one case
19:55:55 <lyxia> yeah that works too
19:56:03 <laudecay> otherwise i'd have to repeat code in the "otherwise" of the guards, and in the _ -> of the case
19:56:17 <laudecay> having to derive Eq, but that's not the end of the world
19:56:19 <lyxia> uh
19:56:51 <lyxia> you can have only _ and no otherwise guard
19:57:02 <laudecay> oh really?
19:57:11 <laudecay> itll just short circuit and work?
19:57:13 <laudecay> d o p e
19:57:19 <lyxia> yeah it just falls through
19:57:21 <laudecay> i'll add that to my list of things to fix once this works
19:57:23 <laudecay> wow that's pretty
19:57:37 <lyxia> :)
20:25:39 * hackage prologue 3.2.0 - Better, more general Prelude exporting common utilities.  http://hackage.haskell.org/package/prologue-3.2.0 (danilo2)
20:56:27 <EvanR> egg on my face... i finally got my parser to accept f x y as function application, and cooperates with . and .foo
20:56:55 <Xal> this would have been so much easier if you thought of the parser as a box
20:57:12 <EvanR> but then in K[a b c], theres only one value inside the brackets, because its application
20:57:25 <EvanR> not space separated expressions
20:58:26 <EvanR> i suck at syntax
21:00:38 <laudecay> ok so one last question before ~prettyfying time~
21:01:41 <laudecay> unfoldr has type (b -> Maybe (a, b)) -> b -> [a]  right
21:02:08 <laudecay> is there some kind of other function like this where I could also get access to the final b
21:02:28 <laudecay> like idk maybe (b -> Maybe (a, b)) -> b -> ([a], b)
21:03:47 <EvanR> -> [(a,b)] might be better
21:03:58 <laudecay> yeah you right
21:04:09 <laudecay> and just map fst over it to get what i originally had i guess
21:04:21 <EvanR> which you can already do with unfoldr, just put the b in the (a,)
21:04:32 <EvanR> a = (a1,b)
21:04:56 <laudecay> so the type would end up being more like
21:05:11 <EvanR> map fst will work if you only want to look at the a
21:05:25 <laudecay> (b -> Maybe ((a,b), b) -> b -> [(a,b)]
21:05:26 <EvanR> but if you want to look at both, mapping fst and snd will be expensive
21:05:39 <laudecay> er i fucked up whatever
21:05:49 <laudecay> i care about all the a's and just the last b
21:06:18 <EvanR> then chew through all (a,b) and ignore all but the last b
21:06:29 <laudecay> wdym chew through
21:06:44 <EvanR> whatever consumer youre passing the list to
21:08:22 <EvanR> and remember to build each (a,b) with evaluated information
21:08:32 <laudecay> o ok
21:08:46 <EvanR> because if you only look at the last b, you may end up doing a huge computation at the very end
21:10:18 <laudecay> why is that bad necessarily
21:10:25 <laudecay> i only care about the runtime as a whole
21:11:07 <EvanR> memory use will be higher and higher until you finally decide to look at something
21:11:15 <laudecay> hmm
21:11:17 <EvanR> more memory in use, slower GC
21:11:17 <laudecay> good point
21:12:15 <laudecay> ok i know the answer is going to be lenses but how would i go from ((a, b), c) -> ((a,b,c), c)
21:12:44 <EvanR> the answer is going to be drop the (,,) and make a record
21:12:51 <suzu> let foo ((a, b), c) = ((a,b,c), c)
21:12:58 <suzu> ;D
21:13:00 <laudecay> bless u suzu
21:13:05 <laudecay> i am so dumb
21:13:06 <EvanR> or that...
21:13:22 <EvanR> but after a certain amount of tuples you need records
21:13:49 <suzu> anything over 2-tuples probably means you should use a real structure
21:13:58 <EvanR> this also lets you put strict fields, to help with the evaluating part
21:14:08 <laudecay> yeah that's the only tuple-y thing i'm doing though
21:14:11 <laudecay> oh yeah maybe
21:14:43 <laudecay> so what i just put ! in front of it?
21:14:48 <laudecay> in the constructor?
21:15:00 <suzu> if your code doesn't look at values as it processes and looks at the end rather, you'll accumulate a lot of work as you process
21:15:07 <laudecay> yeha EvanR told me
21:15:13 <suzu> yeah bangpatters will work but they only evaluate one step
21:15:31 <laudecay> oh no
21:15:37 <suzu> unless you pattern match
21:15:39 <laudecay> how do i make it do all the wya
21:15:39 <suzu> you will be fine in this case
21:15:41 <laudecay> wya
21:15:43 <laudecay> way
21:15:54 <suzu> let foo ((!a, !b), !c) = ((a,b,c), c)
21:15:55 <suzu> should be fine
21:16:04 <suzu> in general to fully evaluate something you use 'deepseq'
21:16:34 <laudecay> woooah
21:16:39 <suzu> which recurses into a value and force each sub-value
21:16:44 <laudecay> hnng
21:16:56 <laudecay> scary
21:17:02 <suzu> so for a list it will evaluate the spine to get [_, _, _...], then deepseq each element
21:18:15 <laudecay> woahhhh
21:22:33 <suzu> > [undefined] `seq` 1
21:22:35 <lambdabot>  1
21:22:44 <suzu> > [undefined] `deepseq` 1
21:22:46 <lambdabot>  error:
21:22:46 <lambdabot>      Variable not in scope: deepseq :: [a0] -> Integer -> t
21:24:38 <suzu> i forget how to import modules / use lambdabot tbh
21:24:50 <suzu> but that should spit an error
21:33:39 <laudecay> thats wild
21:34:20 <laudecay> what do it mean: Failed to load interface for Control.Lens
21:34:22 <laudecay>     Perhaps you meant Control.Seq (from parallel-3.2.1.1)
21:34:25 <laudecay> this is concerning
21:34:35 <laudecay> does this remote machine not have Control.Lens?
21:40:09 <suzu> it means you don't have Control.Lens
21:40:11 <suzu> ;P
21:40:18 <suzu> you
21:40:31 <suzu> you'll* need to install lens or microlens or some other package
21:40:46 <laudecay> alright yeah i think i am in hell
21:40:57 <suzu> cabal hell?
21:41:01 <laudecay> we have to test our code on this website kattis? sorta like hackerrank. basically a black box
21:41:05 <laudecay> it doesn't have freaking lenses.
21:41:13 <suzu> gg
21:41:22 <laudecay> i'm /this/ close to pasting all of control.lens into my file
21:41:28 <laudecay> oh also you can only submit one file hahahahahahhahahahahhahahahah
21:41:32 <laudecay> aaaaaaaaaaaaaaaaaaaaaaaaaaaa
21:41:49 <EvanR> you probably dont need to use deepseq
21:42:29 <suzu> oh yeah you certainly don't. bangpatterns should be fine
21:42:34 <EvanR> the normal way to make sure stuff is evaluated is to construct it evaluated... with strict fields, bang patterns, $!, or seq
21:46:56 <laudecay> oh my GOD they don't have LENSES
21:46:58 <laudecay> OH NO
21:48:35 <Xal> lenses are just a concept, you don't need a library to "use" them
21:49:02 <laudecay> i guess i could diy over and view and set
21:49:07 <laudecay> but that is making me so sad
21:49:34 <Xal> what machine are you programming on that you can't install libraries?
21:49:39 <laudecay> fuck it time to DIY
21:50:03 <laudecay> i'm programming on my desktop, i'm submitting/testing to a hackerrank-like black box grading system
21:50:42 <Xal> those are pretty useless, yeah
21:50:51 <laudecay> i feel
21:51:14 <EvanR> theres also lighter weight lens-like thingies: https://github.com/haskellcats/semantic-editor-combinators
21:51:27 <EvanR> mix and match
21:52:37 <Xal> does it really get lighter-weight than lenses? Functor f => (a -> f b) -> s -> f t
21:52:48 <EvanR> yes
21:53:22 * Xal thinks of a way to relate lenses to the box analogy
21:53:57 <EvanR> there is absolutely no way, its way too general as i show in that article
21:54:35 <Xal> NO! EVERYTHING IS A BOX!
21:55:07 <Myrl-saki> lol
21:55:10 <Myrl-saki> IO is a box.
21:55:33 <EvanR> imagine if boxes were isomorphic to bitstrings... now lenses will let you edit the individual bits in a box, even though there arent any
21:55:40 <EvanR> amazing... why whats the point of the box
21:55:42 <DigitalKiwi> egg
21:55:50 <DigitalKiwi> we decided earlier they are eggs
21:55:52 <Xal> imagine a box as some sort of box
21:56:18 <abnormalprofits> Dang i had just grasped the burrito
21:56:20 <Myrl-saki> Xal: Like, a Taco box, or just a normal box?
21:56:27 <Myrl-saki> abnormalprofits: Gah, dammit. s/Taco/burrito/
21:56:33 <Myrl-saki> FFS, I was so close
21:56:44 <Xal> imagine a burrito as a box that you can eat
21:56:47 <EvanR> if programming languages were fast food, haskell would obv have to be taco bell
21:57:05 <EvanR> what its burritos, boxes, and whatnot
21:57:15 <EvanR> with*
21:57:22 <Myrl-saki> Based on the data, a Functor is everything that starts with a B.
21:57:26 <nisstyre> EvanR: except it would be a taco place where you can get tacos that don't taste like sewage
21:57:35 <abnormalprofits> EvanR: and that burning feeling inside
21:57:37 <Xal> imagine a burrito as a sort of monad that you can eat
21:57:50 <Myrl-saki> Xal: Have we gone full circle
21:57:55 <nisstyre> and also tequila to go with it, the tequila is all of the extra extensions
21:58:19 <EvanR> #haskell open late night
21:59:41 <Myrl-saki> EvanR: Our ancestors survived a lot of death-causing events, just to arrive to... this.
22:02:23 <DigitalKiwi> it's as great as when steve jobs described objects as people
22:02:33 <DigitalKiwi> aarvar link us plz
22:02:41 <nisstyre> DigitalKiwi: that sounds delightful
22:02:49 <nisstyre> is there a recording of him explaining that?
22:02:50 <DigitalKiwi> aarvar I wouldn't want to quote you out of conext
22:05:44 <DigitalKiwi> https://www.rollingstone.com/culture/news/steve-jobs-in-1994-the-rolling-stone-interview-20110117 -- totally not aarvar
22:06:53 <EvanR> way past the heyday of lambaMOO
22:06:59 <EvanR> where people actually were objects
22:07:04 <EvanR> er, are
22:08:23 <DigitalKiwi> according to some people certain people are still objectified :|
22:15:43 <laudecay> i'm trying to diy Control.Lens
22:16:03 <laudecay> how would i make over, or something like it?
22:16:29 <laudecay> i basically just want getters and setters and a way to apply functions inside of ADTs
22:16:40 <laudecay> but I can't import Control.Lens.
22:18:33 <EvanR> did you see my link
22:18:51 <laudecay> oh no i didnt
22:18:52 <laudecay> looking now
22:27:50 <utdemir> Hey. As a library author, is there any way for me to register an IO action to run before users 'main'?
22:28:26 <EvanR> sneaky sneaky
22:28:29 <Xal> laudecay: does this help? http://lpaste.net/365117
22:29:01 <EvanR> utdemir: before, during, or after the other sneaky library authors IO action?
22:29:26 <utdemir> EvanR: Fair enough. Any one is fine.
22:29:43 <pavonia> In Data.Binary.get there's no way to read data out of order, right?
22:29:46 <EvanR> there's actually no such mechanism
22:30:06 <nshepperd> what's wrong with asking the user to put initFoo at the start of their main
22:30:09 <EvanR> utdemir: however libraries are known to put top level NOINLINEd unsafePerformIOs
22:30:22 <utdemir> EvanR: I understand that it sounds horrible, but currently I am saying "call this function as the first thing in your 'main'".
22:30:23 <EvanR> which does not satisfy your requirement
22:30:39 <utdemir> EvanR: Why doesn't it satisfy my requirement?
22:30:46 <EvanR> it wont run before main does
22:30:52 <laudecay> oh wow that's cute Xal
22:31:09 <laudecay> i like it but unfortunately i have already written EvanR's link's solution
22:31:17 <nshepperd> do you actually need to run before main or do you just need some initialization that only runs once
22:31:18 <EvanR> the right way is what nshepperd said, or to use a bracket like the java bindings
22:31:21 <EvanR> runJava
22:32:39 <utdemir> Okay. So, which one do you think is better; a bracket or an IO action?
22:32:40 <Xal> laudecay: I should really compile all my competitive-programming haskell stuff into one module
22:33:23 <EvanR> they are both IO actions the user must choose where to use. it depends on what they do which one makes more sense
22:34:09 * hackage gtk 0.14.9 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.14.9 (HamishMackenzie)
22:34:15 <EvanR> bracket lets you do cleanup, under the best of circumstances at least
22:35:20 <utdemir> EvanR: Thanks, in this case I am going to create a simple `IO ()`. Thank you.
22:36:12 <EvanR> sanity reigns again
22:36:18 <utdemir> :D.
22:38:31 <Xal> type Box a = IO a
22:41:35 <EvanR> type Box a = a
22:55:08 <enterprisey> Is there a fast way to use the Arrow functions to apply a function to the middle element of a 3-tuple?
22:55:26 <enterprisey> Of course f *** g *** h only works on (a, (b, c))
22:59:13 <Cale> nope, they only deal with pairs
22:59:57 <Cale> But (\(x,y,z) -> (x, f y, z)) is probably clearer anyway
23:00:32 <enterprisey> sounds reasonable
23:07:36 <EvanR> or you could use my symmetric monoidal towers of hanoi TH program which swaps your arguments around until theyre in the right positions for arrows to do stuff!
23:08:03 <cocreature> enterprisey: you could also use lens if you‚Äôre familiar with that, e.g. over _2
23:09:06 <enterprisey> EvanR: this project already uses too much TH, I don't want to destroy our compilation times even more lol
23:09:14 <enterprisey> cocreature: thanks! will try
23:14:26 <enterprisey> :t over _2
23:14:27 <lambdabot> Field2 s t a b => (a -> b) -> s -> t
23:14:36 <sqooq> I'm having a wee bit o trouble with megaparsec
23:14:57 <cocreature> :t over _2 :: (b -> b') -> (a,b,c) -> (a,b',c)
23:14:58 <lambdabot> (b -> b') -> (a, b, c) -> (a, b', c)
23:14:58 <sqooq> the "signed" parser in the Lexer module takes a space consumer argument, but I don't want to consume any space
23:15:10 <cocreature> enterprisey: lens type signatures can be a bit scary :)
23:15:20 <enterprisey> cocreature: indeed lol
23:15:21 <sqooq> I put "empty" but I think that just makes it error no matter what
23:15:45 <enterprisey> there's an entry in my fortune file where the bot answers a query with "Getting a s t a b" and the person responds "I don't want to be getting a stab, no thanks"
23:16:46 <cocreature> sqooq: empty is a parser that fails without consuming input, you want one that succeeds without consuming input
23:16:50 <cocreature> sqooq: e.g. pure ()
23:17:30 <sqooq> cocreature: huh
23:17:35 <sqooq> pure ()
23:18:02 <sqooq> hmm, i guess that does work
23:18:12 <sqooq> it could have been anything though right?
23:18:35 <cocreature> not really, you‚Äôve noticed yourself that "empty" doesn‚Äôt work
23:18:58 <sqooq> I mean wrapped in parser
23:19:04 <sqooq> but I just tested and it doesn't work
23:19:14 <cocreature> can you show us the code?
23:19:45 <sqooq> cocreature: no I'm just saying pure 3 didn't work
23:19:49 <sqooq> pure () worked fine
23:19:56 <cocreature> ah
23:20:01 <cocreature> well pure 3 is a type error
23:20:06 <sqooq> why tho
23:20:14 <cocreature> take a look at the type signature of signed
23:20:21 <cocreature> and then take a look at the type of pure 3
23:20:22 <Cale> EvanR: You joke, but at one point when working on arrowized FRP, we actually had a preprocessor for the proc/do syntax using a modified Arrow type class that cared a fair amount about doing such manipulations efficiently. I still don't know if there's a particularly good algorithm for finding a short or shortest path.
23:20:23 <cocreature> :t pure 3
23:20:25 <lambdabot> (Num a, Applicative f) => f a
23:20:40 <cocreature> () is not an instance of Num
23:20:42 <sqooq> I see
23:20:45 <sqooq> Thanks
23:20:54 <sqooq> figured it was just m a
23:21:28 <EvanR> not today its not
23:21:52 <Cale> EvanR: (i.e. in the graph of associations and permutations of a word with edges corresponding to applications of associators and commutators)
23:22:51 <EvanR> well, i came up with what seemed like a good algorithm
23:25:52 <EvanR> Cale: example... https://i.imgur.com/O46KjPm.png
23:27:26 <EvanR> doesnt take long to compile, but i dont know if theres a shorter solution.
23:27:59 <Cale> EvanR: well, that diagram shows swaps, but not reassociations -- the assumption is that you can only swap pairs, so it's like a tree sort where one of the operations is to swap the two branches of your binary tree node, and the others are rebalancing operations.
23:28:12 <Cale> (but not necessarily applied to balance the tree)
23:29:24 <EvanR> when you swap two branches of a binary tree node... how does it get unbalanced
23:29:33 <Cale> If you started with a tree like (((a,b),(c,d)),((e,f),(g,h))), you could get to (((e,f),(g,h)),((a,b),(c,d))) in one swap at the top level
23:30:03 <EvanR> yeah i only had flat one level
23:30:14 <Cale> It doesn't necessarily get unbalanced -- we don't actually care about balance, only attaining the particular target permutation of the leaves and association
23:30:40 <EvanR> the whole situation seems a bit nutty to be honest
23:31:09 <EvanR> like a game were playing, getting something done with these arbitrary restrictions
23:32:40 <EvanR> was there a benefit to your arrowized environment?
23:34:37 <Cale> Actually, it didn't matter all *that* much, because we actually generated a dependency graph *anyway*, and then data would flow directly where it needed to, without all the tupling and untupling.
23:34:49 <Cale> But it would affect the efficiency of the construction of that graph
23:35:33 <EvanR> did that have to be regenerated periodically or was it computed once at boot
23:36:40 <Cale> Well, it would have to be regenerated only when you constructed a new piece of the network, which did happen in the middle of runtime due to higher order FRP primitives.
23:38:36 <Cale> Just replacing the Arrow class with something that looked more like the definition of a symmetric monoidal category, and making use of the new operations to reassociate and swap instead of arr in order to be able to do that analysis made our game run 6 times faster, even before we did any optimisation of the graph which was aware of the FRP operations. (Just eliminating all the construction and deconstruction of tuples)
23:40:39 * hackage vulkan 2.1.0.0 - Bindings to the Vulkan graphics API.  http://hackage.haskell.org/package/vulkan-2.1.0.0 (jophish)
23:40:41 <Cale> But it's tricky to get the rest of the potential optimisations to actually help as much as you might think -- the more time you spend optimising the data flow graph, the better the network might run, but you also paid up-front, and it's hard to make those tradeoffs correctly.
23:41:43 <Cale> So Ryan decided against continuing with the Arrow route with Reflex. There's still maybe something to be gained there, but it's hard.
23:42:42 <EvanR> backend analysis benefits aside, was the arrow interface (or its replacement) at all nice to work with?
23:43:10 <EvanR> i see how you can get safety from it too but
23:45:48 <Cale> It's annoying relative to Conal-style FRP with Event and Behavior types, but not the end of the world.
23:46:52 <EvanR> that has its own can of worms, like multiplexing everything that could affect something into one event
23:47:23 <Cale> Well, the Arrow approach doesn't help with that
23:47:25 <EvanR> reminiscent of the tupling and untupling cost you fixed
23:48:04 <Cale> In fact, Arrow makes all your dependencies even *more* explicit, if anything.
23:48:17 <Cale> (that's kind of the point of it)
