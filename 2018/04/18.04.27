00:05:43 <jle`> is there a unicode symbol i can use as a variable name that looks like the numeral 0
00:05:53 <jle`> it's ugly but it's internal code hehe
00:06:21 <Axman6> > text $  filter isSymbol [minBound..]
00:06:23 <lambdabot>  $+<=>^`|~¬¢¬£¬§¬•¬¶¬®¬©¬¨¬Æ¬Ø¬∞¬±¬¥¬∏√ó√∑ÀÇÀÉÀÑÀÖÀíÀìÀîÀïÀñÀóÀòÀôÀöÀõÀúÀùÀûÀüÀ•À¶ÀßÀ®À©À™À´À≠ÀØÀ∞À±À≤À≥À¥ÀµÀ∂À∑À∏ÀπÀ∫ÀªÀºÀΩÀæÀøÕµŒÑŒÖœ∂“Ç÷ç÷é÷è...
00:06:35 <Axman6> > text $ drop 20 $ filter isSymbol [minBound..]
00:06:37 <lambdabot>  ¬±¬¥¬∏√ó√∑ÀÇÀÉÀÑÀÖÀíÀìÀîÀïÀñÀóÀòÀôÀöÀõÀúÀùÀûÀüÀ•À¶ÀßÀ®À©À™À´À≠ÀØÀ∞À±À≤À≥À¥ÀµÀ∂À∑À∏ÀπÀ∫ÀªÀºÀΩÀæÀøÕµŒÑŒÖœ∂“Ç÷ç÷é÷èÿÜÿáÿàÿãÿéÿè€û€©€Ω€æﬂ∂‡ß≤‡ß≥‡ß∫‡ßª‡´±‡≠∞‡Ø≥‡Ø¥‡Øµ...
00:06:48 <Axman6> somewhere in there there's probably something
00:07:11 <jle`> %% filter isSymbol [minBound..]
00:07:14 <yahb> jle`: http://qp.mniip.com/y/53
00:07:24 <jle`> oops i broke it
00:07:51 <jle`> i'm sorry
00:07:59 <Axman6> :|
00:13:38 <jle`> i'm just going to use greek zeta
00:15:24 <Axman6> jle`: is this for a blog post?
00:15:37 <Axman6> because you have the best blog posts
00:16:12 <jle`> it's not for a blog post heh it's just for some internal code
00:16:21 <Axman6> :'(
00:16:34 <jle`> i'm adding an extra parameter name to some functions but a lot of them all have 'z' already defined :'(
00:16:55 <jle`> but the parameter is supposed to represent a zero of some kind
00:17:01 <jle`> i could just type out 'zero' but that's boring isn't it
00:17:44 <Axman6> we need like a type level Num class, with a type level fromInteger (or fromNat)
00:18:54 <jle`> singletons has one
00:19:15 <jle`> but probably what you are talking about is polymorphic type level int literals
00:27:21 <dminuoso> jle`: ùüò
00:28:20 <Ariakenom> polymorphic type literals ... crazy x :: Num a => Vec (n::a)
00:29:39 <Ariakenom> Although coming from Java types (maxBound : Bounded a => a) was crazy
00:34:44 <Ariakenom> Are there other as cool bullet points to impress people from Java
00:36:17 <liste> Ariakenom: Maybe vs null is a big one
00:36:22 <ertes-w> helo
00:36:22 <liste> no more NPEs
00:37:04 <jle`> dminuoso: thanks
00:37:11 * jle` laughs evilly
00:37:27 <ertes-w> Ariakenom: easy and cheap concurrency, easy parallelism, very quiet syntax, incredibly easy EDSLs, ‚Ä¶
00:37:46 <Ariakenom> "When you have some x::Int then you for sure have an int. Well ..."
00:38:32 <Ariakenom> I feel syntax is hard to sell early. It's gonna look strange and take time to parse anyway.
00:38:36 <ertes-w> Ariakenom: and of course the ecosystem‚Ä¶  there is probably a package for almost everything you might need‚Ä¶  if it's not on hackage, you'll likely find it in some repo
00:38:38 <dminuoso> jle`: ùìπùìµùìÆùì∑ùìΩùîÇ ùì∏ùìØ ùìØùìæùì∑ ùìΩùì∏ ùì´ùìÆ ùì±ùì™ùì≠ ùîÄùì≤ùìΩùì± ùìæùì∑ùì≤ùì¨ùì∏ùì≠ùìÆ
00:38:56 <Ariakenom> ertes-w: Java has a package or 2 as well
00:38:59 <Cale> ertes-w: Is that really any different for Java though?
00:39:03 <jle`> i wonder what the vim digraph for that is
00:39:40 <ertes-w> Ariakenom, Cale: i'm mentioning this, *because* you'll find a package for almost anything for java, and that's a huge selling point
00:39:52 <ertes-w> when i started with haskell the story was very different
00:39:57 <Cale> ah, that's fair
00:40:34 <Cale> It used to be a major point against Haskell that there weren't many libraries, so although the language was great, it was a lot of work to do anything with it.
00:43:33 <ertes-w> oh, and we have much cheaper and cleaner abstractions, both syntactically and at run-time‚Ä¶  try not to make it sound like OOP is garbage ‚Äì it is, but java programmers don't like to hear that =)
00:44:40 <Ariakenom> I don't want vague stuff though. I wanted maxBound type stuff.
00:45:23 <Ariakenom> Polymorphic literals I'd count. 5 :: Num a => a
00:46:29 <quicksilver> Ariakenom: I think the biggest thing compared to java is the fact that computations and IO actions are both values; they can be abstracted
00:46:35 <liste> modern Java is far less OOP-crazy these days, class hierarchies are a thing of the past
00:46:41 <quicksilver> so you can separate an algorithm from its innards
00:46:45 <liste> it's mostly just interfaces and implementations now
00:46:54 <quicksilver> it's a little hard to come up with a really concise example of that
00:47:12 <quicksilver> but you can remove boilerplate from haskell code in a way which makes Java programmers weep, when they get it.
00:47:19 <dminuoso> quicksilver: The biggest thing is that you dont have to shoehorn abstractions into OOP when Java has nothing in its toolbag.
00:47:25 <Ariakenom> quicksilver: Can you phrase that as a terse, concrete bullet point?
00:47:33 <quicksilver> Ariakenom: I don't think so :)
00:47:37 <dminuoso> quicksilver: Just think of AbstractSingletonProxyFactoryBean
00:47:53 <quicksilver> dminuoso: well, 'shoehorning into OOP' is annoying but it mostly leads to syntactic overhead
00:48:02 <quicksilver> ... syntactic overhead is annoying.
00:48:13 <quicksilver> what actually bothers me is that the type system can't cope with the abstraction.
00:48:30 <dminuoso> It distracts from what you are trying to do: write code to solve a problem. Suddenly your problem becomes juggling with these shoehorned abstractions that Java calls "patterns"
00:48:35 <quicksilver> as for you second point, the AbstractSingletonProxyFactoryBean are partly cultural
00:48:40 <ertes-w> Ariakenom: the least vague thing i can think of is concurrency‚Ä¶  haskell is mature concurrency; i mean erlang-levels of mature
00:48:44 <quicksilver> not entirely a fact about the language.
00:48:59 <quicksilver> on the concurrency point - concurrency is so much easier when everything is immutable by default.
00:49:31 <Ariakenom> Cheap threads are bullet pointable. Maybe STM with guards against side effects like nesting them incorrectly.
00:49:41 <quicksilver> the haskell community has its own cultural failings analogous to AbstractSingletonProxyFactoryBean though
00:49:52 <ertes-w> Ariakenom: i like to point out that STM in haskell is leaps and bounds ahead of every other implementation i've seen
00:49:55 <quicksilver> our cultural failing is "clever" packages on hackage which try to solve all the problems at the type level
00:50:05 <quicksilver> which leads to error messages which are just impossible to 'sell' to normal developers
00:50:12 <Cale> Ariakenom: I'm not sure, maybe Java can do this now, but one thing that's really nice about type classes vs. interfaces (at least as I remember them being in Java) is that you can easily express that two types must not only be instances of the type class, but also need to be the same
00:50:18 <quicksilver> they just look at the error and ask how can you seriously work with this?
00:50:23 <dminuoso> quicksilver: The problem with AbstractSingletonProxyFactoryBean is that at the end it's just trying to mimic partial function application
00:50:24 <Cale> :t (<)
00:50:25 <lambdabot> Ord a => a -> a -> Bool
00:50:25 <Ariakenom> STM with guards ... at compile time
00:50:48 <dminuoso> quicksilver: The difference is that haskell cleverness is by choice. AbstractSingletonProxyFactoryBean is because Java lacks tools.
00:50:50 <dysfun> quicksilver: at the same time, some of these modules are really useful and couldn't reasonably be done without type level hackery
00:50:55 <ertes-w> Ariakenom: specifically the Alternative instance of STM is something i haven't seen in any other language
00:50:58 <dysfun> e.g. freer
00:51:07 <dysfun> but freer errors are unreal
00:51:27 <dysfun> i went straight back to monad transformers after about a day
00:51:53 <dminuoso> Haskell question. Why is Logic called Logic? I mean this just looks like church lists to me.
00:51:56 <robstr> Hey, I have many executables in my cabal file and all depend on the (nearly) exact same dependencies, is there a way to specify these _globally_ ?
00:52:31 <ertes-w> Ariakenom: a funny piece of trivially (source: SPJ): apparently the C# developers have tried and failed for two years to implement STM‚Ä¶  the a student did it in one weekend for haskell =)
00:52:36 <ertes-w> *trivia
00:52:53 <Ariakenom> ertes-w: Could probably do "getQueue c <|> return 0" as a bullet point example.
00:53:37 <ertes-w> Ariakenom: perhaps combine it with async:  atomically (waitSTM thread1 <|> waitSTM thread2 <|> takeTMVar someVar)
00:53:50 <ertes-w> 'return' is not very compelling
00:54:10 <ertes-w> "i could do that with if/then/else"
00:54:34 <Ariakenom> ertes-w: Yes it's reasonable to expect getQueue to have a non blocking variant
00:55:35 <ertes-w> Ariakenom: perhaps even something like this:  atomically (waitSTM someThread <|> do x <- takeTMVar someVar; guard (x > 5); pure x)
00:56:14 <ertes-w> this will block (proper block, not busy-loop-block) until either the thread dies or someVar's value changes
00:56:48 <quicksilver> dysfun: they're really useful and they are important research and they are how we progress
00:56:49 <Ariakenom> Much better. Because it will not visibly take the MVar until the value changes.
00:56:52 <quicksilver> dysfun: and they're fun!
00:57:06 <ertes-w> Ariakenom: *and* satisfies the constraint
00:57:10 <quicksilver> dysfun: but... they absolutely do not help you convert software engineers used to other languages
00:57:51 <Ariakenom> the TVar* why do you have an M there? :p
00:57:52 <Boomerang> robstr: I think hpack support that (using the same list of dependencies for multiple executables)
00:58:04 <quicksilver> dysfun: for example, the lens ecosystem which is elegant and important and absolutely production ready, gives error messages "at a different level of abstraction" from the simplicity of the code it lets you write.
00:58:18 <ertes-w> Ariakenom: another one of my favourite features of haskell is IO: because of the way it works you can create domain-specific control constructs‚Ä¶  even 'catch' is a regular function in haskell, and you can easily create your own
00:58:42 <ertes-w> Ariakenom: because it's a TMVar, not a TVar ;)
00:58:51 <jle`> yeah i definitely wouldn't pick an ecosystem fight vs a java programmer
00:58:54 <Ariakenom> I see.
00:59:18 <ertes-w> Ariakenom: this transaction commits, as soon as the TMVar has a value that also satisfies (> 5)
00:59:26 <adjofun> quicksilver: convert software engineers to another formats with ffmpeg =:)
00:59:59 <quicksilver> :)
01:00:03 <robstr> Boomerang: thank you I will look into it
01:00:12 <ertes-w> Ariakenom: (of course with STM TMVar is really just TVar . Maybe‚Ä¶  TMVar is just convenience)
01:00:37 <Boomerang> robstr: I think the latest stack uses hpack by default, so if you're already using stack, it should be easy to get that working :)
01:00:39 <Ariakenom> I want bullet points tereness though.
01:01:00 <jle`> ooh i can use „Äá
01:01:33 <jle`> or maybe ‚Å∞, i wonder if that is usable as a variable name
01:02:04 <jle`> > generalCategory '‚Å∞'
01:02:06 <lambdabot>  OtherNumber
01:02:16 <jle`> @let ‚Å∞ = "zero"
01:02:16 <lambdabot>  Parse failed: Illegal character ''\8304''
01:02:30 <jle`> > generalCategory '„Äá'
01:02:32 <lambdabot>  LetterNumber
01:02:39 <jle`> @let „Äá = "zero"
01:02:40 <lambdabot>  Parse failed: Illegal character ''\12295''
01:02:53 <kyagrd> any IHaskell users/developers? there isn't a seperate channel for IHaskell right?
01:03:23 <pavonia> What is LetterNumber?
01:03:36 <ertes-w> Ariakenom: "custom control constructs", e.g. for easy searches:  do x <- fetch "foo" <|> fetch "bar" <|> liftIO (readFile "baz.txt"); y <- list [1..10]; guard (somePredicate x y); pure (f x + y)
01:03:43 <jle`> pavonia: an oxymoron, apparently
01:04:10 <jle`> > filter ((== LetterNumber) . generalCategory) [minBound..]
01:04:12 <lambdabot>  "\5870\5871\5872\8544\8545\8546\8547\8548\8549\8550\8551\8552\8553\8554\8555...
01:04:20 <ertes-w> Ariakenom: Codensity is one of my favourites, but it's kinda hard to explain, if you don't know haskell already =)
01:04:23 <jle`> > text $ filter ((== LetterNumber) . generalCategory) [minBound..]
01:04:25 <lambdabot>  ·õÆ·õØ·õ∞‚Ö†‚Ö°‚Ö¢‚Ö£‚Ö§‚Ö•‚Ö¶‚Öß‚Ö®‚Ö©‚Ö™‚Ö´‚Ö¨‚Ö≠‚ÖÆ‚ÖØ‚Ö∞‚Ö±‚Ö≤‚Ö≥‚Ö¥‚Öµ‚Ö∂‚Ö∑‚Ö∏‚Öπ‚Ö∫‚Öª‚Öº‚ÖΩ‚Öæ‚Öø‚ÜÄ‚ÜÅ‚ÜÇ‚ÜÖ‚ÜÜ‚Üá‚Üà„Äá„Ä°„Ä¢„Ä£„Ä§„Ä•„Ä¶„Äß„Ä®„Ä©„Ä∏„Äπ„Ä∫Íõ¶ÍõßÍõ®Íõ©Íõ™Íõ´Íõ¨Íõ≠ÍõÆÍõØêÖ
01:04:26 <lambdabot> ÄêÖÅêÖÇêÖÉêÖÑêÖÖêÖÜêÖáêÖàêÖâêÖä...
01:04:34 <jle`> whoda thunk
01:05:01 <Ariakenom> I don't know codensity and would like a non bullet point explanation :)
01:05:05 <dminuoso> "right kan extension of a Profunctor along itself"
01:05:10 <Ariakenom> (and I know Haskell)
01:05:17 <dminuoso> Ariakenom: ^- it's so clear and simple!
01:05:42 <ertes-w> Ariakenom: newtype Codensity m a = Codensity { runCodensity :: forall r. (a -> m r) -> m r }
01:05:54 <robstr> Boomerang: I just skipped stack and try nix & cabal new-build :)
01:06:07 <ertes-w> Ariakenom: withFile "blah.txt" ReadMode :: forall r. (Handle -> IO r) -> IO r
01:06:23 <ertes-w> Ariakenom: Codensity (withFile "blah.txt" ReadMode) :: Codensity IO Handle
01:06:33 <ertes-w> Ariakenom: do you see what happened?
01:07:04 <Ariakenom> g2g, few mins
01:07:16 <ertes-w> sorry for scaring you away
01:07:25 <Ariakenom> :p meeting
01:07:37 <dminuoso> ertes-w: This looks closely related to Yoneda
01:07:54 <kuribas> is it possible to lift a constant value to a type (datakind)?
01:10:24 <jle`> kuribas: constant as in, known at compiletime?
01:10:31 <kuribas> yeah
01:10:40 <jle`> no
01:10:45 <Wizek> Is something like this possible with TH? `deriveGEq ''(Foo n)`
01:10:47 <kuribas> like a constant method in a typeclass
01:10:47 <jle`> but if you know it at compiletime then you can just write it
01:10:53 <kuribas> it's in a class
01:10:59 <dminuoso> Mmm http://comonad.com/reader/2011/free-monads-for-less-2/ I think I can almost grok this :)
01:11:10 <jle`> if you know it at compiletime then you can just type it in directly at the type level
01:11:21 <jle`> in the source code
01:11:30 <jle`> kuribas: can you show an example?
01:11:40 <ertes-w> dminuoso: it is
01:11:50 <kuribas> jle`: http://hackage.haskell.org/package/aeson-1.3.1.0/docs/Data-Aeson.html#t:ToJSONKeyFunction
01:12:03 <kuribas> I need to discriminate based on the constructor of ToJSONKeyFunction.
01:12:05 <jle`> in general ghc has no built in method for converting back and forth between datakind-lifted types and the original values
01:12:12 <kuribas> One is a (type) error, the other a valid usage.
01:12:13 <jle`> that's because to ghc, the two things are completely unrelated
01:12:21 <jle`> the singletons library provides a typeclass to link the two
01:12:23 <kuribas> yeah, except for strings
01:12:26 <ertes-w> dminuoso: F is really just the church encoding of Free
01:12:32 <jle`> kuribas: strings and symbols are also completely unrelated
01:12:41 <jle`> to ghc
01:12:53 <ertes-w> dminuoso: of course the post has deeper explanations, but if all else fails, just think of it as church =)
01:12:58 <dminuoso> ertes-w: "F" what?
01:13:02 <kuribas> jle`: but I can convert them?
01:13:05 <jle`> but the difference is that ghc libs provide functions to convert between the two ad-hoc
01:13:21 <dminuoso> ertes-w: Oh you mean newtype F f a = F { runF :: forall r. (a -> r) -> (f r -> r) -> r } ?
01:13:22 <kuribas> from type to value, the other way I don't know...
01:13:25 <ertes-w> dminuoso: ah, i guess you haven't come that far in the post yet‚Ä¶  it builds up to F
01:13:29 <ertes-w> dminuoso: yeah
01:13:57 <jle`> kuribas: the other way is someSymbolVal
01:14:00 <kuribas> jle`: I could create my own class with that information
01:14:21 <jle`> kuribas: yeah, you can create your own methods to convert between types and values of your choosing
01:14:28 <jle`> er, your own functions
01:14:37 <jle`> you could link Bool the type with Either () () the kind
01:14:41 <jle`> (or Bool the kind)
01:14:45 <jle`> but those are just manual ad-hoc functions
01:15:04 <jle`> the singletons package just provides a typeclass that unifies those functions under the same name
01:15:25 <dminuoso> ertes-w: Well I've had much success in applying the Feynman algorithm to understanding CT problems.
01:15:41 <kuribas> jle`: I just need to know if toJSONKey generates a string or a Value
01:15:50 <jle`> kuribas: you can create your own ad-hoc function to bring the constructors of ToJSONKeyFunction to the type level
01:15:51 <ertes-w> dminuoso: (Codensity m) has the same effect on m: it only m-binds when there are actual m-effects, otherwise it's just pure functions (that also why the Monad instance doesn't actually require (Monad m))
01:16:03 <jle`> kuribas: but there isn't any other way than to handle both situations
01:16:15 <jle`> it would essentially be the same as pattern matching on the constructor
01:16:18 <kuribas> ok.  I'll eagerly await dependend types :)
01:16:40 <jle`> i don't think dependent types would help here either
01:16:45 <jle`> you probably can't get any better than pattern matching
01:17:04 <dminuoso> ertes-w: It's quite amazing how all these concepts I've been dabbling in for the past few months are so closely interrelated. It seems as if this can be seen as an indication that we're on the right abstraction.
01:17:36 <jle`> kuribas: my discussion earlier was assuming dependent types already
01:17:38 <ertes-w> dminuoso: welcome to wonderland =)
01:17:54 <jle`> kuribas: reifying the constructors to the type level and then acting on that is basically the same thing as pattern matching
01:18:19 <jle`> kuribas: and if the value of ToJSONKeyFunction is known, like you say it is, then you can just pattern match on it immediately in your source file
01:18:45 <jle`> kuribas: pattern matching on the constructors of a ToJSONKeyFunction reveals to you and to the compiler if the result is Text or Value
01:19:03 <kuribas> but ToJSONKeyFunction is a value level function, not a type level function?
01:19:26 <jle`> kuribas: yes, but pattern matching on the constructor reveals with type it is acting on
01:19:46 <jle`> if you match and see ToJSONKeyText, you know it's returning a Text
01:19:54 <jle`> if you match and see ToJSONKeyValue, you know it's returning a Value
01:20:12 <kuribas> for each instance separately?
01:20:18 <Ariakenom> ertes-w: So it's "with" patern. Basically a "a". what is gained over runCodensity :: (a -> b) -> b ? Functor etc instances?
01:20:32 <jle`> kuribas: for each instance it is case-by-case
01:20:37 <ertes-w> Ariakenom: sorry, i don't understand the question
01:20:39 <jle`> kuribas: because which one it is is not a part of the typeclass
01:20:51 <kuribas> than I might as well create my own KeyFunction class
01:20:57 <kuribas> which only uses string
01:21:06 <jle`> kuribas: ToJSONKeyFunction is actually already a cleverly disguised dependent sum
01:22:05 <kuribas> jle`: I don't think I'm following...
01:22:26 <kuribas> jle`: you are suggesting to use a type family?
01:22:48 <jle`> oh i'm saying that you won't get any more information out of here with dependent types, because it's already somewhat approximating the power of dependent types
01:23:00 <kuribas> jle`: I could do it in TH...
01:23:27 <jle`> but i'm also not sure exactly what you want to do with the information about the constructor of ToJSONKeyFunction
01:23:38 <jle`> do you want to use the constructor as a constraint?
01:23:45 <kuribas> jle`: I need to create a String, not a Value
01:24:06 <kuribas> jle`: so in effect, my typeclass only works on half the ToJSONKey instances
01:24:16 <kuribas> the other ones should be a type error.
01:24:22 <jle`> ah
01:24:35 <Ariakenom> In "runCodensity :: forall r. (a -> m r) -> m r" why "m r" and not "b"? To do "Functor m => Functor (Codensity m a)"?
01:24:56 <jle`> kuribas: so you want to use it as some sort of constraint
01:25:07 <kuribas> jle`: yeah, exactly
01:25:10 <jle`> in that case yeah, real dependent types would probably help
01:25:41 <jle`> yeah, you can't access the constructor to use as a cosntraint
01:25:43 <kuribas> jle`: currently I have a runtime error if it returns a Value, but that's ugly
01:26:27 <jle`> yeah, making another class is one way
01:26:45 <jle`> or making an open type family, but that's essentially the same thing
01:26:51 <ertes-w> Ariakenom: Codensity is basically a restricted ContT‚Ä¶  you could define it like this:  newtype Codensity m a = Codensity { runCodensity :: forall r. ContT r m a }
01:27:00 <jle`> it's just not something that typeclass was meant to give you
01:27:24 <Ariakenom> Don't know ContT
01:27:35 <jle`> the promise of toJSONKey is "you have to handle whatever type return we give you"
01:27:42 <kuribas> jle`: if aeson had encoded it as a type level constraint, it would have worked.  I suppose aeson didn't need it.
01:27:46 <jle`> it's essentially something similar to an existential type
01:27:51 <kuribas> jle`: yeah
01:28:14 <ertes-w> Ariakenom: ok, then ignore the last statement‚Ä¶  let's look at withFile: its purpose is to give you a handle, but make sure that it is closed after a certain block of code‚Ä¶  that's why it uses continuation-passing style
01:28:18 <ertes-w> :t withFile
01:28:19 <lambdabot> error:
01:28:20 <lambdabot>     ‚Ä¢ Variable not in scope: withFile
01:28:20 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
01:28:23 <ertes-w> :t System.IO.withFile
01:28:24 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> IO r) -> IO r
01:28:29 <ertes-w> ugly‚Ä¶
01:28:45 <ertes-w> Ariakenom: withFile :: forall r. FilePath -> IOMode -> (Handle -> IO r) -> IO r
01:28:49 <jle`> kuribas: yeah i suppose in a language with full dependent types you could pattern match on the value as a constraint
01:29:02 <kuribas> jle`: a typesafe way would be to create a StringKeyFunction class with TH, but many people dislike TH...
01:29:13 <ertes-w> Ariakenom: withFile takes a path and IOMode, but instead of just returning the Handle, it takes a continuation, and it makes sure that when the continuation returns, the handle is closed
01:29:35 <ertes-w> Ariakenom: makes sense so far?
01:29:35 <jle`> singletons etc.'s lift-to-type functionality is only for runtime lifting
01:29:38 <Ariakenom> or, crucially, throws exception.
01:29:54 <jle`> but you want a compiletime reification, which i don't think is possible in haskell
01:30:00 <ertes-w> Ariakenom: i'll be back in a few minutes
01:30:26 <kuribas> I dislike the way many aeson values are encoded...
01:30:29 <jle`> not without manually writing something for every possible influence
01:30:36 <jle`> *instance
01:30:48 <jle`> kuribas: a typechecker plugin might help, or TH maybe
01:30:57 <jle`> s/maybe//
01:31:04 <kuribas> jle`: yeah, it would still require a declaration for each instance.  But it would be total at least :)
01:31:25 <jle`> a typechecker plugin can fetch the constraint from thin air at compileitme
01:31:53 <jle`> a ToJSONKeyIsText a => ... constraint
01:32:24 <jle`> but yeah there is no convenient solution at this time, i don't think
01:32:26 <kuribas> jle`: is that possible?
01:32:45 <jle`> it should be possible, if the instance is in scope for the plugin to inspect the constructor of
01:32:55 <kuribas> I'll just keep the error then...
01:33:06 <jle`> the typeclass would have a text-parsing method
01:33:13 <jle`> but you would write no instances by hand
01:33:24 <jle`> the typechecker plugin would generate those instances on the fly at compiletime
01:33:37 <jle`> still not super satisfying though and probably overkill
01:34:01 <kuribas> yeah
01:34:08 <jle`> as far as i know there isn't a convenient way to do what you are saying in haskell, and you are limited by the design of the typeclass in the library.  but it might be worth asking around on SO or reddit maybe
01:34:34 <jle`> still, there have been some interesting new typechecker plugins that have come out recently, and one day it might be seen as a normal thing to do
01:34:50 <jle`> (generating instances for phantom typeclasses on the fly)
01:34:51 <kuribas> the good thing is that the error will likely trigger sooner than later
01:35:00 <jle`> famous last words
01:37:23 <ertes-w> Ariakenom: back‚Ä¶ does withFile make sense?
01:37:39 <jle`> i feel weird saying that haskell has no simple solution for this.  but probably, the simple solution would be to change the typeclass.  but the complications are from the fact that the typeclass is provided to us and is not something we can change
01:37:44 <Ariakenom> ertes-w: sure
01:38:09 <ertes-w> Ariakenom: exercise: how do you open two files at the same time using withFile?
01:38:13 <kuribas> jle`: exactly.  So I'll provide another TH function then for autoderiving this instance.
01:38:37 <jle`> who knows, might be a good opportunity to learn how to write typechecker plugins :)
01:38:46 <kuribas> is that already possible?
01:38:52 <jle`> yes, for years now
01:39:06 <kuribas> ah :)  looks rather heavyweight though...
01:39:14 <jle`> it might be
01:39:20 <jle`> i've been looking for an excuse to learn myself, heh
01:39:24 <Ariakenom> \a b f -> withFile a (withFile b f)
01:39:28 <jle`> just never have gotten around to it...
01:39:46 <jle`> also typechecker plugins right now are a little annoying because they always trigger recompilation
01:40:17 <ertes-w> Ariakenom: correct‚Ä¶  and you probably already see the problem with that:  if you have to open lots of files, you'll get lots of levels like that
01:40:31 <jle`> * withFile b . f
01:40:58 <ertes-w> Ariakenom: in particular: how do you open a whole bunch of files from a list [FilePath]?
01:41:22 <ertes-w> Ariakenom: oh, you have a type error there, but you got the basic idea
01:41:54 <ertes-w> Ariakenom: it should be:  withFile fp1 m1 (withFile fp2 m2 . f)
01:42:03 <mniip> huh
01:42:06 <mniip> did my httpd die
01:42:11 <jle`> potentially
01:42:38 <Ariakenom> I ignored the modes on purpose
01:42:41 <mniip> looks like that's what happened as the rest of the infra is intact
01:43:00 <mniip> looks like there was a libc update that segfaulted everything that was not updated/recompiled for it
01:43:30 <Ariakenom> something along the lines of foldl (\f a -> f . withFile f) id
01:44:25 <ertes-w> Ariakenom: yeah, something like that‚Ä¶  not quite as easy as:  hs <- traverse (`openFile` ReadMode) fps
01:45:23 <ertes-w> Ariakenom: and that's where Codensity comes in
01:47:48 <Ariakenom> *drumroll*
01:48:30 <ertes-w> Ariakenom: Codensity (withFile fp m) :: Codensity IO Handle  -- the CPS is gone
01:50:28 <ertes-w> Ariakenom: opening two files:  do h1 <- Codensity (withFile fp1 m1); h2 <- Codensity (withFile fp2 m2); f h1 h2
01:50:57 <ertes-w> Ariakenom: do hs <- traverse (\fp -> Codensity (withFile fp ReadMode)) fps; ‚Ä¶
01:52:22 <Ariakenom> makes sense
01:52:24 <isovector> ertes-w: neat! i've never seen codensity described like this before. when do the finalizers for `withFile` happen?
01:53:21 <Ariakenom> isovector: He needs a runCodensity "runCodensity do {withFile..; withFile...}"
01:53:29 <ertes-w> isovector: like onions: in reverse order
01:53:29 <Ariakenom> Then it's clear?
01:53:59 <ertes-w> also usually you would just use lowerCodensity :: (Applicative m) => Codensity m a -> m a
01:54:00 <isovector> ertes-w: but like, when you do `runCodensity`? or the end of the do block?
01:54:25 <Ariakenom> isovector: all files are open for the entire runCodensity.
01:54:42 <ertes-w> isovector: lowerCodensity transforms the implicit CPS into an IO action, which cleans up at the end
01:54:43 <Ariakenom> although they can be nested for smaller scopes
01:54:46 <isovector> got it. so it flattens out pyramids of doom. cool
01:54:52 <ertes-w> isovector: so basically at the end of your lowerCodensity block
01:55:03 <ertes-w> yeah, that's one way to put it =)
01:55:19 <ertes-w> isovector: you can also register cleanup actions, and they will be run in reverse order
01:55:34 <ertes-w> cFinally :: IO a -> Codensity m ()
01:55:46 <ertes-w> cFinally cleanup = Codensity (\k -> k () `finally` cleanup)
01:56:15 <ertes-w> cAtExit :: IO a -> Codensity m ()  -- run the action at the end unless an exception is thrown
01:56:29 <ertes-w> cAtExit action = Codensity (\k -> k () <* action)
01:56:40 <isovector> that's cool as hell
01:57:00 <isovector> how does it related to ResourceT?
01:57:01 <ertes-w> you can do pretty crazy shit with it
01:57:16 <kvothe176> hi..how do I make some type defined in a haskell library derive from the read typeclass?
01:57:56 <ertes-w> isovector: it's a lightweight version of ResourceT: you can use it when you don't need to clean up early
01:58:07 <dminuoso> kvothe176: Check out StandaloneDeriving
01:58:57 <dminuoso> kvothe176: Be sure to read about the implications of orphan instances though.
02:00:26 <kvothe176> dminuso: will look it up..thanks
02:06:45 <dminuoso> ertes-w: By the way.. magit is so amazing.. why didn't I try emacs earlier *sniff*
02:07:08 <fakenullie> Because now you're hooked
02:08:20 <ertes-w> dminuoso: yeah, keep an eye on my gushing in #haskell-offtopic‚Ä¶  recently i found another nice feature =)
02:08:22 <fakenullie> Every other editor vcs is a joke in comparison
02:09:04 <ventonegro> dminuoso: Welcome, brother https://stallman.org/saintignucius.jpg
02:09:46 <dysfun> i had to comment out magit from my Caskfile to get my config to install on this machine
02:10:13 <Ariakenom> sparks are "transparent futures without side effects" I guess
02:12:30 <kvothe176> how do I make some type derive from the read typeclass if my type does not expose its data constructors?
02:12:55 <isovector> kvothe176: you're trying to give a read instance for it?
02:14:21 <kvothe176> isovector: yup
02:15:55 <dminuoso> kvothe176: Generics are probably an option..
02:16:15 <isovector> i think before we get into "how" we should probably ask "why"
02:16:35 <ertes-w> kvothe176: if the type is under your control, you can derive anything you want, even if you don't export the constructors
02:16:53 <kvothe176> the type is defined in a library i'm using
02:17:00 <isovector> what's the type?
02:17:03 <ertes-w> kvothe176: and if it isn't, you shouldn't be doing this in the first place
02:17:37 <kvothe176> Crypto.PubKey.Curve25519.PublicKey
02:17:49 <ertes-w> kvothe176: yeah, don't do it
02:18:53 <ertes-w> kvothe176: orphan instances are a bad idea in general, and trying to derive Read for PublicKey just amplifies the badness
02:19:05 <jle`> kvothe176: the library is trying to tell you that it only wants you to make a value of that type in a specific way
02:19:19 <isovector> kvothe176: https://www.stackage.org/haddock/lts-11.6/cryptonite-0.25/Crypto-PubKey-Curve25519.html#v:publicKey -- there is an instance here for Strings, so this thing provides the read functionality you want
02:19:29 <kvothe176> okay makes sense
02:20:02 <jle`> this happens a lot whenever you have abstract data types
02:20:10 <jle`> like Data.Map's Map
02:34:42 * hackage cautious 0.1.0.0 - Keep track of warnings and errors during calculations.  http://hackage.haskell.org/package/cautious-0.1.0.0 (NickskeVdb)
02:40:36 <kuribas> why do people find haskell difficult, when C++ is infinitely more complicated?
02:40:50 <kuribas> I haven't got any of these questions right: http://cppquiz.org/quiz/question/188
02:40:56 <isovector> familiarity
02:41:24 <kuribas> the more advanced haskell stuff I know, the easier it gets.
02:41:24 <Putonlalla> Does anyone not find C++ difficult as well, kuribas?
02:41:40 <kuribas> Putonlalla: well... I suppose so
02:42:15 <isovector> kuribas: and to be fair, this C++ quiz is on the fringe of the language
02:42:41 <kuribas> yeah.  There is this question where the answer says that most compilers get it wrong...
02:43:56 <Boarders> the C++ story for almost everything seems much more difficult than haskell imo
02:44:24 <kuribas> this question: http://cppquiz.org/quiz/question/162
02:44:25 <Boarders> regardless of how many wars are had over stack vs cabal I have found none of it as difficult as building hard C++ projects
02:45:06 <kuribas> ghc may be slow, but C++ is just as slow
02:46:12 <Boarders> my experience is also that the documentation in C++ manages to be worse than hackage pages
02:46:26 <Boarders> which is mindblowing given the relative scales of the languages
02:47:02 <kuribas> hackage isn't to bad
02:47:09 <kuribas> at least you get types :)
02:47:26 <Boarders> yeah, it is underrated when you don't have it
02:47:48 <Boarders> python has amazing documentation but it is still made difficult by just not having types
02:48:02 <Boarders> "what does pop return again, if anything?"
02:48:18 <Boarders> for every function you use
02:48:51 <kuribas> yes, I find the wall of text approach in python less appealing.
02:48:59 <dminuoso> kuribas: I once found a spec conform trick to mutate the value of a constexpr expression.
02:49:15 <dminuoso> Which uses a whole battery of subtle details in the specs.
02:51:16 <Putonlalla> This reminds me of how it's impossible to implement the standard `vector` such that it is possible to `push_back` its first element into itself as required by the standard.
02:54:38 <dminuoso> kuribas: http://b.atch.se/posts/non-constant-constant-expressions/
02:54:53 <dminuoso> From that a whole library arose.. https://github.com/DaemonSnake/unconstexpr
02:55:53 <mniip> "You finished with 6.63 out of 10.0 possible points"
02:56:06 <mniip> sounds good to me
02:56:35 <othd> what kind of signature is this `decodeWord :: Decoder s Word` in https://hackage.haskell.org/package/cborg-0.2.0.0/docs/Codec-CBOR-Decoding.html
02:58:30 <lemmih> othd: What do you mean?
02:59:15 <othd> lemmih : I mean whats is s in this `Decoder s Word`
02:59:43 <Cale> That s is an arbitrary type which is never filled in.
02:59:56 <Cale> It's part of the trick that ST uses to make runST safe
02:59:58 <Cale> :t runST
02:59:59 <lambdabot> (forall s. ST s a) -> a
03:00:13 <Cale> It'll eventually be that s there
03:02:18 <jle`> othd: you can think of it as meaningless/phantom
03:02:55 <jle`> othd: one way i sometimes think about those s's is that actions sharing the same 's' can be sequenced under the same mutable context
03:03:17 <jle`> which gives you things like (>>) :: Decoder s a -> Decoder s b -> Decoder s b
03:03:24 <jle`> you can only sequence two Decoder's if they have the same 's'
03:03:40 <jle`> so you can't, say, (>>) a Decoder s with a Decoder t
03:06:17 <othd> jle : if it is meaningless why they added there?
03:06:44 <jle`> it's phantom
03:07:14 <jle`> in practice i usually think of them like indicating a shared mutable context
03:07:41 <jle`> so for (>>) :: Decoder s a -> Decoder s b -> Decoder s b, the two input Decoder s's all operate under the same mutable environment
03:07:56 <jle`> you can kind of think of it like preventing you from mixing them up
03:08:37 <jle`> that's uh, not exactly 'why' it's there, but it's how i think about it day to day
03:09:23 <jle`> under this interpretation, it means that you can't sequence a 'Decoder s' action with a 'Decoder t' action; the two don't share the same mutable context
03:10:22 <Darwin226> Hey, can someone help me with this? I'm trying to read a ZonedTime from a string with this `parseTimeOrError True defaultTimeLocale "%F %T%Q%Z" "2018-04-27 10:57:32.864625+02" :: ZonedTime`
03:10:40 <Darwin226> I get an extremely helpful "no parse" error (are you kidding me?)
03:11:03 <dminuoso> Cale: Is there any relationship between ST and Yoneda?
03:11:07 <Darwin226> Or maybe someone can point me to a time parsing package that isn't terrible
03:11:32 <ertes-w> othd: it's there for the same reason as with ST
03:12:13 <ertes-w> othd: ST actions can only be run, if they are fully polymorphic in the type 's' (runST demands this), and that makes it impossible to leak resources
03:13:50 <ertes-w> runST :: forall a. (forall s. ST s a) -> a  -- there is no way to unify 's' with any part of 'a', because that would lead to a chicken/egg issue:  you can't be fully polymorphic in 's', if you've committed to an 'a' and that 'a' has 's' somewhere in it
03:14:17 <ertes-w> othd: in simpler terms you can't return any value from the ST action that has an 's' somewhere in it
03:20:29 <Cale> dminuoso: I don't expect anything...
03:22:43 <adjofun> Darwin226: this works for me: parseTimeOrError True defaultTimeLocale "%F %T%Q%z" "2018-04-27 10:57:32.864625+0200" :: ZonedTime
03:24:25 <Darwin226> adjofun: Ok. I can't really chose the string format so I'll need a way to parse it without those two zeros, but thanks. That's extremely helpful
03:24:39 <Darwin226> Now I know where the problem is at least
03:25:45 <adjofun> Darwin226: are you sure you need to `error`, when you got no parse for that string?
03:26:57 <Darwin226> adjofun: I mean, I'm just playing with it in the repl so it doesn't matter how the error manifests
03:27:14 <Darwin226> but I assume that I can't get more info about the error than what I get in the error message
03:32:24 <Boarders> probably very stupid question, is it possible to have a record type like: data Record = R {blah :: (forall m. Monad m => ReaderT String m)}
03:34:00 <mniip> no
03:34:10 <mniip> (forall m. Monad m => ReaderT String m) :: * -> *
03:34:21 <mniip> record fields have to be of kind *
03:35:30 <Boarders> I could have (forall m. Monad m => ReaderT String m ())} though?
03:35:35 <cocreature> yes
03:35:39 <cocreature> if you enable RankNTypes
03:35:48 <Boarders> thanks
03:51:55 <kuribas> or data Record a = R {blah :: (forall m. Monad m => ReaderT String m a)}
03:55:17 <reactormonk> How come there's no bifunctor instance for IO? with exception on the other side. Not lawful?
03:55:39 <Cale> :k Bifunctor
03:55:40 <lambdabot> (* -> * -> *) -> Constraint
03:55:44 <Cale> :k IO
03:55:45 <lambdabot> * -> *
03:55:55 <Cale> It's a kind error
04:00:09 <reactormonk> Ah, so it would be a semi-mono-bifunctor. Got it.
04:04:01 <Cale> ... whatever that means :)
04:07:32 <Boarders> semi-mono-bifunctor
04:07:35 <Boarders> good grief
04:18:04 <quicksilver> I think what you mean is can you write newtype IOWithExplicitExceptions e a = mkIOWEE (IO a)
04:18:25 <quicksilver> with the intended meaning that the bifunctor part on the 'e' maps over exceptions which might be thrown
04:19:38 <dminuoso> :t catch
04:19:39 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
04:19:51 <dminuoso> reactormonk: ^- well there's this..
04:20:29 <quicksilver> certainly one reason you can't is that it's not parametric
04:20:34 <quicksilver> because of the class constraing
04:20:45 <quicksilver> but I'm not sure if it also violates other laws even if we overlook parametricity
04:46:16 <tamasgal> hey guys, can anyone quickly help me with a weird behaviour regarding a Jenkinsfile (script) and docker images?
04:46:26 <tamasgal> i am sitting on this problem for days now...
04:46:38 <cocreature> how do I import a constructor without the type if they have the same name?
04:46:46 <cocreature> tamasgal: that doesn‚Äôt sound like a Haskell question
04:46:55 <tamasgal> damn sorry, wrong channel :D
04:47:02 <tamasgal> this should go into #jenkins, sorry
04:47:13 <cocreature> np, good luck :)
04:47:29 <tamasgal> tnx ;)
05:28:36 <maerwald> is there a compelling example of using arrows in the context of parsers?
05:29:01 <dminuoso> arrows are so 2017
05:32:09 <adjofun> I thought, math trends change in periods much more than 1 year =:)
05:32:54 <quicksilver> maerwald: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.80.9967&rep=rep1&type=pdf
05:33:09 <quicksilver> arrows were actually very 1996
05:33:41 <Boarders> what year are profunctors?
05:33:41 <quicksilver> I think there is another paper somewhere which uses arrows to build an invertible parser
05:34:17 <quicksilver> I find arrows often the wrong abstraction because they embed generalised functions
05:34:38 <quicksilver> if I'm trying to find something usefully composable for optimisation, say, then it needs to be more limited
05:42:26 <ertes-w> maerwald: arrow parsers never really caught on, but optparse-applicative has an arrow variant
05:47:49 <cocreature> the use of arrows in optparse-applicative is more of a hack to let you name intermediate results before ApplicativeDo was a thing
05:50:28 <ertes-w> indeed, there is nothing that really makes use of the Arrow capabilities
05:52:01 <Ariakenom> ApplicativeDo seems a bit finicky. I suppose I would need to look at what exact algorithm it uses?
05:52:02 <ertes-w> anyway, the thought of having to use arrow style for parsers makes my skin crawl‚Ä¶  there'd better be a substantial advantage, and the fact that a parser arrow could eliminate branches early is not really good enough
05:52:41 <ertes-w> Ariakenom: ApplicativeDo is kind of a hack of its own‚Ä¶  what we really need is idiom brackets, but no idea if we'll ever have them
05:53:42 * hackage ats-format 0.2.0.26 - A source-code formatter for ATS  http://hackage.haskell.org/package/ats-format-0.2.0.26 (vmchale)
05:54:04 <ey8vbhd84> Hello, if I must write a relatively simple piece of software that is not concurrent, and I have the option between an object-oriented language and a functional language like Haskell, why would you choose Haskell and why?
05:55:29 <ey8vbhd84> *why would you choose Haskell?
05:56:08 <ertes-w> ey8vbhd84: because it's functional
05:56:25 <ertes-w> there is no application where i would prefer OOP over FP
05:56:48 <Ariakenom> and why?
05:57:54 <ey8vbhd84> That's the conundrum I am in unfortunately. For an assignment I have been forced to use Haskell, and also to engage in a comparative analysis of other paradigms. The thing is I am a priori forced to justify Haskell and the functional approach as the right tool. However, I actually disagree and would otherwise use an object-oriented language, but I am constrained to choose the functional and Haskell.
05:57:57 * fatahland
05:59:38 <Ariakenom> ey8vbhd84: I actually started gathering a few bullet points earlier today. http://lpaste.net/365286
05:59:39 <ertes-w> ey8vbhd84: FP has cheaper and more domain-specific abstractions‚Ä¶  in particular it avoids the AbstractServiceManagerFactory deal by providing abstractions that are meaningful
05:59:53 <boxscape> Not something that's strictly necessary for FP, but one thing I always miss when I use OO languages is Haskell's type system that catches errors at compile time
06:00:59 <maerwald> ey8vbhd84: that sounds odd
06:01:04 <ertes-w> ey8vbhd84: in fact haskell is actually an excellent choice, because it takes FP further than most other FP languages‚Ä¶  things that would normally be language features are regular library functions in haskell, including loops and exception handling
06:01:19 <Ariakenom> Although the points are meant to be explained orally. Maybe you can understand
06:01:33 <maerwald> ey8vbhd84: your exercise suggests you are forced into an unscientific approach
06:01:44 <maerwald> tell your professor it's wrong
06:03:11 <Psybur> Is HIndent a widely used formatting tool? It drastically changed how my code is laid out while stylish haskell doesnt seem to do much heh
06:03:38 <ey8vbhd84> ertes-w: Mhm, well I am actually not constrained to choose Haskell, I could go for another functional language. I am just forced to use a functional approach to the problem when in actual fact OOP seems to be either equally as good or superior.
06:03:39 <ertes-w> Psybur: i use haskell-mode and my own sense for aesthetics
06:03:54 <maerwald> ey8vbhd84: use OCaml then, which has oop features
06:03:59 <maerwald> or Scala
06:04:17 <ey8vbhd84> The application I am supposed to develop is a very simple text editor, yet I am forced to use functional and justify it over object-oriented and other paradigms.
06:04:33 <maerwald> totally unscientific
06:04:45 <ertes-w> ey8vbhd84: normally i would suggest that you learn FRP for this task, but it has a learning curve of its own that might not fit into whatever time constraints you have
06:05:08 <ertes-w> ey8vbhd84: FRP is a much more natural approach than OOP to interactive systems, in particular user interfaces
06:05:28 <ertes-w> ey8vbhd84: if you want to know what it buys you, watch one of ryan trinkle's videos on 'reflex'
06:05:30 <maerwald> natural?
06:05:51 <ertes-w> ey8vbhd84: his company is using haskell and FRP for web frontend development
06:07:00 <ey8vbhd84> Right. Yeah, I am time constrained and also constrained about the structure of the project. I have come here looking for any possible reasons by which you would decide to use a functional language over an OOP language for the implementation of a simple text editor. Esoteric and complex reasons are almost out of the question since we have not covered Haskell very deeply, and their usage in the context is unlikely.
06:07:50 <maerwald> ey8vbhd84: very easy: use a language where you have sufficient examples on the problem and already existing and powerful solution, which you can examine and use for your own solution
06:08:18 <ertes-w> maerwald: OOP represents UIs as state machines with event callbacks, FRP represents them as time-varying values with first-class events, which avoids the whole callback spaghetti problem‚Ä¶  you can never forget to update a text field with FRP, because "updating" isn't something you do in FRP in the first place
06:09:02 <Psybur> Also, the universe itself is FRP, not OOP :D?
06:09:12 * hackage clifm 0.4.1.0 - Command Line Interface File Manager  http://hackage.haskell.org/package/clifm-0.4.1.0 (pasqu4le)
06:09:17 <ertes-w> Psybur: QFRP =)
06:09:33 <maerwald> ertes-w: I'm aware, but that's not more "natural" to me, just "better" or "more elegant"
06:09:40 <Psybur> Quantum frp? :D
06:10:13 <ey8vbhd84> Frankly, to me it just looks like the decision you would make between VHS and Betamax.
06:11:00 <ertes-w> ey8vbhd84: not at all‚Ä¶  you know how the complexity of an OO UI grows superlinearly the more stuff you add?  with FRP it grows linearly
06:11:01 <ey8vbhd84> For such a simple software solution, going functional for practical reasons relating to the implementation seem nonexistent.
06:11:15 <ertes-w> ey8vbhd84: although for this very simple problem perhaps
06:11:44 <ertes-w> ey8vbhd84: your problem is really too simple to get a real feeling for the difference‚Ä¶  you won't be using any crazy abstractions here
06:11:47 <Akii> this conversation makes me wanna look into UI programming with Haskell >_>
06:11:48 <Taneb> ey8vbhd84: one thing that a functional style might make really easy in this specific example is infinite undo/redo
06:11:48 <maerwald> exactly, for a simple project you won't notice a lot of difference
06:11:57 <maerwald> haskell gets interesting for long-time projects, imo
06:12:45 <ertes-w> ey8vbhd84: i'd still use FRP even in this case, but the cost of learning it might be prohibitive for you
06:12:51 <maerwald> because as ertes-w said, complexity grows different and not just wrt UI, also maintenance and bughunting in general
06:13:03 <kuribas> IMO programming with event loops gets messy  really quick
06:13:11 <maerwald> but initial complexity is usually way higher in haskell
06:13:32 <kuribas> there's a small learning curve for FRP, but you get the benefits really quick
06:13:34 <maerwald> it just grows slower
06:13:35 <ey8vbhd84> I see. I have heard that functional languages normally result in shorter more concise source code, and more predictable behaviour. If I am optimizing for stability and predictability, and easy of maintenance, wouldn't going functional over object-oriented make sense?
06:13:46 <kuribas> maerwald: it isn't
06:13:49 <ertes-w> ey8vbhd84: one area where you could benefit from haskell is data structures‚Ä¶  but if you use a UI toolkit there is really no need to deal with that yourself
06:13:52 <maerwald> kuribas: I disagree
06:14:31 <ertes-w> ey8vbhd84: background: for a text area a very good data structure is called a "rope", in haskell typically a finger-tree of text chunks
06:15:29 <ertes-w> ey8vbhd84: yes, and you kinda always optimise for at least some of those =)
06:15:56 <maerwald> https://hackage.haskell.org/package/yi-rope-0.10/docs/Yi-Rope.html
06:16:12 <ey8vbhd84> Yeah, but if I was going to put those as my priorities I guess functional would have a sharper edge.
06:16:59 <ertes-w> ey8vbhd84: you should probably take a look at haskell outside of the context of your assignment‚Ä¶  if nothing else, it will give you a new perspective on programming and also on OOP
06:17:01 <ey8vbhd84> The reason for the simple text editor is that a "fictitious cryptography company is skeptical of widely available software, so they want to develop their own simple text editor for very basic functionality".
06:18:05 <maerwald> ey8vbhd84: is this in any way related to security?
06:18:10 <ertes-w> ironically one of the haskell features i miss most in other languages is IO
06:18:49 <kuribas> ertes-w: but they have plenty of it!  everything is IO!
06:19:05 <ertes-w> kuribas: no, they have some ad-hoc side effect system‚Ä¶  they don't have IO
06:19:28 <Psybur> ertes-w, why is that ironic? That's like a big feature of haskell heh
06:19:38 <maerwald> ey8vbhd84: if you just care about arguments for FP in terms of security you might want to look at https://arxiv.org/abs/1201.5728 although most of it is nonsense
06:19:47 <ertes-w> Psybur: because IO is often portrayed as evil
06:20:10 <Psybur> The IO monad?
06:20:34 <maerwald> but those arguments usually appeal to FP people
06:21:04 <ey8vbhd84> maerwald: Thanks. I think the security of the software will be determined by its exposure. If it is running without any connection to the net, why would using a functional language make it less likely to suffer an attack than an object-oriented one?
06:21:06 <ertes-w> Psybur: IO happens to be a monad, but that's not really relevant
06:21:26 <ertes-w> ey8vbhd84: text editors open files from untrusted sources
06:21:40 <ertes-w> ey8vbhd84: something like syntax highlighting could very well have a security problem
06:21:52 <Psybur> ertes-w, I mean are you saying people think IO in haskell is evil, or how I/O is handled in other programs is evil
06:21:55 <maerwald> and those problems are totally orthogonal to programming paradigm ;)
06:22:09 <ey8vbhd84> Yeah exactly.
06:22:26 <maerwald> your assignment is odd
06:22:28 <Psybur> I suppose since you said IO you mean the haskell flavor
06:22:38 <ertes-w> imagine you would have to write a syntax highlighter in C without yacc/bison
06:22:53 <maerwald> imagine you would have to write a crypto library in haskell :P
06:23:11 <Psybur> crypto needs strict memory management. Is that hard in haskell?
06:23:16 <maerwald> there was a post on haskell-cafe about it listing all the problems with crypto in haskell
06:23:19 <maerwald> which is a lot
06:23:28 <ertes-w> maerwald: cryptonite and most of thomas dubuisson's libraries are written in pure haskell
06:23:51 <ertes-w> maerwald: it's much harder to write timing-resistant haskell than timing-resistant C, but it's possible
06:23:56 <maerwald> and has been examined by security researchers?
06:23:58 <Boarders> ~~~timing based attacks~~~
06:24:17 <ertes-w> maerwald: not sure, but they are widely used
06:24:47 <ertes-w> (correction: it's not entirely pure haskell‚Ä¶  some of the low-level stuff is written in C)
06:25:00 <Boarders> afaik the kinds of issues with secure code in haskell is not something that would easily be operationalisable as a attack you could perform
06:25:14 <maerwald> "widely used" is not very compelling =)
06:25:49 <ertes-w> it isn't‚Ä¶  also i'm not suggesting to write crypto code in haskell, i'm just saying it's possible
06:26:08 <maerwald> people wrote kernels in javascript
06:26:50 <maerwald> ey8vbhd84: https://mail.haskell.org/pipermail/haskell-cafe/2015-February/118059.html might be interesting
06:27:16 <ertes-w> anyway, low-level security is not a very compelling reason to prefer haskell‚Ä¶  it's high-level security where haskell starts to shine
06:27:34 <ertes-w> but that's not really haskell-exclusive‚Ä¶  it's a matter of not producing giant state machines
06:27:37 <maerwald> high-level security means nothing if it doesn't carry over to the low level
06:28:06 <ertes-w> feel free to use C for low-level stuff and switch to haskell one level above it
06:29:20 <maerwald> there are more interesting languages than haskell for security
06:29:30 <maerwald> especially wrt high-level
06:35:01 <ertes-w> you could go fully dependent
06:35:24 <ertes-w> unfortunately none of the dependent languages are really ready for production
06:35:43 <dminuoso> Psybur: Crypto needs far more. Ill claim that you cant securely do crypto in Haskell.
06:36:16 <Psybur> dminuoso, so then any crypto packages in Haskell should be avoided?
06:37:00 <maerwald> that too, but also have a proper compiler (compare with CakeML)
06:37:21 <Psybur> ertes-w, are you referencing idris/agda?
06:37:26 <maerwald> rather F*
06:37:32 <maerwald> which is *actually* security focused
06:37:42 <maerwald> not just "look, we are FP"
06:37:43 <dminuoso> Psybur: Well part of the problem is that if you don't control code generation in every single bit of detail, you'll just introduce side channels left and right.
06:38:10 <ertes-w> Psybur: idris‚Ä¶  agda is not really suitable for programming
06:38:23 <maerwald> idris is not security focused either
06:38:38 <ertes-w> it doesn't have to be‚Ä¶  you can establish security properties through the type system
06:38:44 <maerwald> it has to be
06:38:46 <dminuoso> Psybur: In a nutshell certain code paths need to run in constant worst time. Even things like sharing where a computation is memoized might break your neck because it leaks information.
06:38:57 <maerwald> the type system is maybe 5% of the problems you have in security
06:39:23 <ertes-w> maerwald: what are the issues you couldn't catch on the type level?
06:39:30 <Psybur> Is F* pure?
06:39:30 <dminuoso> Psybur: Also you basically need to painfully avoid caches usually, so you need extremely tight control over memory.
06:39:40 <maerwald> Psybur: it has Tot functions
06:40:06 <maerwald> Psybur: http://www.fstar-lang.org/tutorial/
06:41:06 <maerwald> ertes-w: adherence to spec, timing issues, code generation, compiler correctness, input validation as formal languages, ...
06:42:18 <dminuoso> Psybur: Crypto needs exact control over machine instructions. Haskells evaluations model doesn't fit that. =)
06:42:32 <dminuoso> That is if you want to do crypto the right way.
06:43:26 <ertes-w> maerwald: idris is at a point where it could be self-hosted, but it doesn't have a commercial budget and the interest groups to make it happen‚Ä¶  all of those issues could be covered by idris
06:43:41 <maerwald> I believe F* to be already ahead
06:44:46 <ertes-w> would F* appeal to a haskell programmer?
06:45:32 <ertes-w> as a haskell programmer i want lightweight, flexible syntax, cheap ADTs, concurrency, etc.
06:45:50 <maerwald> probably too early
06:46:03 <maerwald> it's more proof and security centered
06:46:47 <ertes-w> what kind of code would you write in F* right now?  and can i FFI into it?
06:47:14 <dminuoso> Psybur: Even a JITed language like Java on HotSpot has the potential to seriously leak information into side channels. Curiously the potential to leak information increases as the JIT compiler gets better.
06:48:02 <maerwald> ertes-w: a verified TLS implementation ;)
06:48:23 <Psybur> ~maerwald++
06:48:45 <dminuoso> maerwald: verified up to what?
06:49:09 <maerwald> low-level verification is still not done afaik
06:49:20 <maerwald> they are working on extracting C code though
06:49:29 <dminuoso> maerwald: You'd have to verify runtime behavior, cache behavior - this goes down into hardware.
06:49:37 <maerwald> F* currently compiles to F# or OCaml
06:49:44 <ertes-w> maerwald: i'm intrigued, and if i can FFI into it from haskell, i don't mind giving it a shot
06:49:50 <maerwald> dminuoso: they don't do that yet
06:49:57 <ertes-w> oh
06:50:09 <ertes-w> well, i guess FFIing into ocaml might be possible
06:53:02 <maerwald> https://github.com/mitls/mitls-fstar
06:57:20 <jchia_3> I have a function foo :: IO [a] -> IO (). It takes an upstream [a] and does some IO with each a (in reality outputting it on the network). For performance and low memory usage I don't want the upstream to realize the [a] all at once before foo does any of its own processing. I want the foo to process the a one by one while the upstream is producing them. How should I change the signature? I'm trying to keep it general and avoid committi
06:57:20 <jchia_3> ng to a library like pipes or conduit. I can't use foo :: [IO a] -> IO () because then the upstream a's lose their sequential relationship.
06:58:02 <dminuoso> Mmm, I wonder whether unsafeInterleaveIO could be useful there
07:01:40 <lemmih> jchia_3: IO (Maybe a) -> IO (), perhaps.
07:06:02 <ertes-w> jchia_3: does (foo xs *> foo ys = foo (xs ++ ys)) hold for all xs, ys?
07:07:04 <ertes-w> jchia_3: if yes using the streaming framework of your choice:  forever (await >>= liftIO . foo . pure)
07:07:48 <ventonegro> maerwald: Would you know how F* compares to ATS?
07:10:30 <jchia_3> ertes-w: Yes. await from conduit?
07:10:44 <maerwald> ventonegro: no idea
07:11:15 <ventonegro> maerwald: ok
07:13:56 <GobiGobi> is there a flag I can pass `stack test` to ignore warnings and continue with the testing?
07:14:24 <jchia_3> GobiGobi: I have only used --keep-going with 'build' but maybe it also works with 'test'?
07:14:34 <ertes-w> jchia_3: conduit, machines, pipes, ‚Ä¶
07:14:38 <GobiGobi> jchia_3: thanks I'll give it a go
07:14:46 <ertes-w> jchia_3: my personal preference is machines
07:15:23 <jchia_3> ertes-w: I know and have used conduit. machine seems more general and I would like to understand it.
07:16:03 <jchia_3> Is there some tips for understanding machines coming from conduit?
07:20:07 <ertes-w> jchia_3: the basic idea is that you first create "plans":  see the Data.Machine.Plan module
07:20:40 <ertes-w> jchia_3: then you 'construct' the plan, which turns it into a MachineT‚Ä¶  those are the stream processors that you compose (via e.g. (~>))
07:20:53 <ertes-w> jchia_3: at the end you usually use runT_
07:21:31 <ertes-w> jchia_3: example:  runT_ (construct (yield 1 *> yield 2 *> yield 3) ~> repeatedly (await >>= liftIO . print))
07:21:41 <ertes-w> jchia_3: where repeatedly = construct . forever
07:21:44 <jchia_3> On this page, in the documentation at the top, they mention a type variable 'i' but it's not in the signature. Is that a typo? http://hackage.haskell.org/package/machines-0.6.3/docs/Data-Machine-Plan.html
07:22:37 <ertes-w> jchia_3: it's rather poorly worded‚Ä¶  in most cases you would use (k = Is i)
07:22:44 <reactormonk> I have a hanging test, how would you debug that one? Pretty sure I smuggled an infinite recursion somewhere.
07:23:33 <jchia_3> ertes-w: Do I need to understand Mealy, MealyT and Moore? I'm wondering if I need to read some papers.
07:23:35 <ertes-w> jchia_3: a value of type (PlanT (Is i) o m a) is a stream processor that consumes values of type 'i' and produces values of type 'o', and results in a value of type 'a'
07:23:43 <ertes-w> jchia_3: no
07:23:56 <ertes-w> jchia_3: they can be useful, but are extra
07:24:23 <jchia_3> ertes-w: OK. I asked because they look like names of people, maybe from some theoretical CS paper.
07:25:37 <ertes-w> jchia_3: they are, and those are useful types, but they aren't really helpful at this point
07:26:46 <Ariakenom> It's about Mealy and Moore state machines I suppose?
07:27:06 <ertes-w> yeah
07:27:22 <jchia_3> ertes-w: OK. I'm trying to learn it starting with these slides. http://aloiscochard.github.io/slides/2016-machines.html
07:29:05 <phadej> those slides are good, they get you started with `machines` nicely
07:33:19 <zbs> >let x = 5
07:34:48 <zbs> @help
07:34:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:35:03 <zbs> > 4 + 5
07:35:05 <lambdabot>  9
07:35:15 <zbs> > x
07:35:17 <lambdabot>  x
07:35:49 <zbs> @pl let foo x y = (+)
07:35:49 <lambdabot> (line 1, column 18):
07:35:49 <lambdabot> unexpected end of input
07:35:49 <lambdabot> expecting variable, "(", operator, ";" or "in"
07:35:59 <zbs> > let foo x y = (+)
07:36:01 <lambdabot>  <no location info>: error: not an expression: ‚Äòlet foo x y = (+)‚Äô
07:36:22 <zbs> @pl let foo x y = x + y
07:36:22 <lambdabot> (line 1, column 20):
07:36:22 <lambdabot> unexpected end of input
07:36:22 <lambdabot> expecting letter or digit, variable, "(", operator, "+", "-", ";" or "in"
07:36:31 <zbs> > let foo x y = x + y
07:36:33 <lambdabot>  <no location info>: error: not an expression: ‚Äòlet foo x y = x + y‚Äô
07:43:43 <Boarders> I have part of a servant website and for one of the pages it parses a file and then renders some of that to the screen
07:44:43 <Boarders> I am a bit unsure when the handler actually does the parsing and if it is cached after the first request etc
07:44:55 <Boarders> what is the best way to find that sort of thing out?
07:48:39 <c_wraith> Boarders: usually it depends entirely on how you lay out the code.  Do you pass the server an action that reads and parses the file, or do you read and parse the file to create the action to pass to the server?
07:49:23 <Boarders> currently the latter
07:49:26 <alp> yeah you'll want to do that (parsing etc) before spinning up the server, and then give the ready-to-be-used data to your handlers
07:49:46 <alp> no magic sharing happens
07:50:06 <alp> even though you could have a caching middleware
07:50:07 <Boarders> so is the thing to have a parsing action which your handler and main function share and use bang patterns in the parsing?
07:50:14 <Boarders> (sorry if this is a dumb question)
07:50:33 <Boarders> and then run this action before starting up the server?
07:50:37 <Boarders> or will that still run the action twice
07:51:13 <c_wraith> Make the parsing entirely separate from the handler, and just pass data.  There's no need to use any strictness-related features.
07:51:29 <Boarders> ok thanks
07:54:12 * hackage patat 0.6.1.1 - Terminal-based presentations using Pandoc  http://hackage.haskell.org/package/patat-0.6.1.1 (JasperVanDerJeugt)
07:58:07 <cocreature> what does ‚ÄúIDLE.IDLE‚Äù represent in a ghc profile?
07:58:21 <cocreature> is that time spent waiting for IO?
07:58:26 <Taneb> It looks like a modernist emoji
08:19:13 <vaibhavsagar> hi, how do I make GHC accept unicode?
08:20:09 * eschnett GHC optimizes this function very well:
08:20:11 <eschnett> vdot0 :: Num a => a -> V.Vector a -> V.Vector a -> a
08:20:12 <eschnett> vdot0 r xs ys = r + V.sum (V.zipWith (+) xs ys)
08:20:24 <byorgey> vaibhavsagar: it already accepts unicode.  Are you getting a specific error?
08:20:32 <vaibhavsagar> > print "ü§†"
08:20:34 <lambdabot>  <hint>:1:8: error:
08:20:34 <lambdabot>      lexical error in string/character literal at character '\129312'
08:20:46 <vaibhavsagar> I'm getting the same thing on 8.4.1
08:20:51 <eschnett> if i put the V.Vector (Data.Vector) into a newtype, it's still optimized. However, if I put it into a data constructor, GHC doesn't seem to fuse the loops any more. is there a way around this?
08:25:39 <byorgey> vaibhavsagar: I think the problem is not that GHC doesn't accept Unicode at all, but rather that it does not accept *all* Unicode codepoints
08:25:51 <glguy> vaibhavsagar: You can replace it with \129312 in your code
08:25:55 <byorgey> vaibhavsagar: this issue looks relevant: https://ghc.haskell.org/trac/ghc/ticket/8524
08:26:51 <byorgey> for example,  putStrLn "√©"   works just fine for me
08:27:33 <boxscape> still trying things with singletons, is there a way to make nat2nt work without Introducing a data family? http://lpaste.net/365295
08:27:51 <reactormonk> Ok, WTF. I'm getting "<interactive>: lost signal due to full pipe: 11" when trying to debug some infinite loop via ghci
08:28:56 <reactormonk> I tried inserting a whole lot of trace statements, but I couldn't see any of them fire. I'm starting to go out of options.
08:31:00 <csauce> Does anyone have an up-to-date guide to building programs for profiling with cabal-install? I can't seem to get it to enable profiling, or run the program and producing data
08:31:36 <lemmih> csauce: --enable-executable-profiling doesn't work?
08:32:52 <csauce> lemmih: I ran cabal install --enable-executable-profiling and it seems to install correctly
08:33:21 <csauce> lemmih: then I ran: cabal exec executable +RTS -psh -RTS args
08:33:47 <reactormonk> TIL Semigroup deriving isn't worth shit
08:34:09 <lemmih> csauce: You probably want 'cabal exec -- executable +RTS -psh -RTS' or something.
08:34:22 <lemmih> csauce: Otherwise you're asking to profile cabal.
08:35:48 <csauce> lemmih: Okay, I got that to work - had to do: cabal exec -- executable +RTS -p -s -h -RTS
08:36:14 <vaibhavsagar> byorget: that works, thanks!
08:36:52 <vaibhavsagar> *byorgey, oops
08:37:05 <concaveirc> Anyone know something like `space1` in megaparsec that does not parse newlines?
08:37:27 <concaveirc> Or at least a quick expression?
08:37:39 <csauce> lemmih: Is there a reason to use run over exec? I'm a bit confused by the differents or the need for --
08:37:57 <vaibhavsagar> lemmih: cool to see new commits on lhc!
08:38:22 <bas_> Hi everyone. Hacking in haskell on my free friday afternoon. I don't know how okay it is to just ask a question here: but I can not seem to find this with googling. I like to write some type signature before implementing their bindings. Is there some syntax to do so? I know in Scala we have the ??? operator for "not implemented yet"
08:38:53 <concaveirc> bas_ undefined
08:38:54 <byorgey> bas_: it is very okay to just ask a question here!
08:39:02 <shapr> bas_: welcome!
08:39:18 <bas_> I knew it should be possibvle!
08:39:23 <bas_> shapr, byorgey Thanks!
08:40:05 <lemmih> csauce: I don't know the difference between 'cabal run' and 'cabal exec'.
08:40:05 <boxscape> you could also just write f :: <Type>; f = f
08:40:06 <shapr> byorgey: silly question, is the mustardwatch stuff a reference to something? I couldn't find it on google
08:40:29 <boxscape> (but admittedly that's not a good idea)
08:40:41 <edwardk> there's a cabal exec?
08:40:55 <vaibhavsagar> concaveirc: you can copy the definition of `space` and replace `isSpace` with something else: http://hackage.haskell.org/package/megaparsec-6.5.0/docs/src/Text-Megaparsec-Char.html#space
08:40:59 <csauce> lemmih: Ok, thanks for your help!
08:41:03 <shapr> edwardk: I nominate you for the cabal executive committee
08:41:32 <concaveirc> vaibhavsagar: That would work. Any ideas about some applicative/guard magic?
08:41:42 <edwardk> ah its for working in sandboxes
08:41:48 <shapr> neat
08:41:51 <vaibhavsagar> concave: just copy isSpace: http://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.Unicode.html#isSpace
08:41:59 <vaibhavsagar> *concaveirc ^
08:42:20 <edwardk> tells you how often i use the classic sandboxes =)
08:42:26 <vaibhavsagar> maybe you could use (\c -> isSpace c && c /= '\n')
08:42:50 <vaibhavsagar> cabal sandboxes are pretty great for self-contained stuff
08:42:58 <vaibhavsagar> that's how we got IHaskell working on CoCalc
08:43:00 <concaveirc> vaibhavsagar: I will try both.
08:43:10 <edwardk> i've moved to new-build instead of the old sandboxes
08:43:24 <vaibhavsagar> I don't think those are self-contained though
08:43:38 <vaibhavsagar> most things are in ~/.cabal/store IIRC
08:43:38 <edwardk> dist-newstyle contains all the stuff you build
08:43:58 <vaibhavsagar> cabal sandboxes also contain all dependencies I think
08:44:04 <edwardk> and stuff placed outin the store is placed there consistently with the flags used for it
08:44:07 <edwardk> yes
08:44:20 <edwardk> which means that the sandboxes have to compile lens separately =)
08:44:38 <vaibhavsagar> their deploy process is essentially copying a directory to different machines
08:44:41 <edwardk> whereas with new-build they share the lens builds if they are built with the same options, nothing breaks
08:45:17 <edwardk> fair. if that is the deployment model you want, then thats a usecase for a sandbox
08:45:33 <vaibhavsagar> there's no new-style sandboxing though, right?
08:45:40 <edwardk> its not my preferred model for local dev though, because of the aforementioned wasted rebuilds
08:45:52 <vaibhavsagar> that makes sense
08:46:03 <edwardk> no idea, mainly because i've never had the need to use it
08:46:58 <edwardk> i'm kinda stuck using new-build because its the only thing i have that supports all the backpack craziness i've come to like
08:47:11 <vaibhavsagar> new-build is quite nice in other ways as well
08:47:38 <AWizzArd> What 1-2 libs are the best to handle config files in Haskell? Dhall?
08:47:47 <edwardk> i'm just sad that i have to keep typing new-foo every time. i kinda wish there was a flag i could set in a cabal file or a project file that says 'use new'
08:48:37 <vaibhavsagar> edwardk: have you seen https://github.com/aisamanra/cab?
08:48:47 <glguy> I can wait for ng-build
08:48:56 <glguy> or whatever even newer progression we might one day see
08:48:57 <edwardk> hahaha
08:49:08 <vaibhavsagar> newer-build
08:49:39 <vaibhavsagar> AWizzArd: have you seen https://hackage.haskell.org/package/configurator-ng?
08:49:58 <AWizzArd> vaibhavsagar: not yet, thx for the suggestion, will have a look
08:50:14 <glguy> This is what I use for config https://glguy.net/config-demo/
08:50:44 --- mode: glguy set -o glguy
08:52:12 <jchia_3> ertes-w, phadej: I've gone through the slides. Is there a way to adapt between conduit and machines? E.g. I have a conduit "Source m o" and I want to use it in a MachineT.
08:53:11 <jchia_3> I have some existing conduit code that I would like to reuse when I write a MachineT.
08:53:31 <ertes-w> jchia_3: yeah, there is, but i have the code at home
08:53:49 <AWizzArd> glguy: will also have a look at this, thx.
08:54:02 <ertes-w> jchia_3: i'll paste it once i'm at home
08:54:06 <jchia_3> ertes-w: Thanks
08:54:36 <ertes-w> jchia_3: in fact i'll just turn it into a library
08:55:13 <AWizzArd> glguy: https://downforeveryoneorjustme.com/glguy.net
08:55:20 <glguy> just you
08:55:20 <jchia_3> ertes-w: Cool. There aren't many machines packages on hackage.
08:55:40 <AWizzArd> glguy: I thought so too, but that website also believes it might be down for others.
08:56:34 <glguy> AWizzArd: Looks like ipv4 might be misconfigured somewhere, ipv6 works :)
08:56:42 * hackage duration 0.1.0.0 - A tiny compile-time time utility library inspired by zeit/ms  http://hackage.haskell.org/package/duration-0.1.0.0 (ryotakameoka)
08:57:11 <glguy> AWizzArd: The packages are:  https://hackage.haskell.org/package/config-value  https://hackage.haskell.org/package/config-schema
08:57:23 <boxscape> AWizzArd:  isup.me is a shorter url for the same page
08:57:33 <glguy> value is just the language, schema is an optional way to specify schemas
08:58:02 <AWizzArd> boxscape: plus there are 500 other services that essentially do the same.
09:02:33 <glguy> AWizzArd: try again?
09:05:07 <AWizzArd> glguy: works, thx
09:05:45 <glguy> AWizzArd: note that you can edit the example file at the bottom and try reparsing it
09:19:35 <orion_> If I have a function (Foo -> Bar -> IO Baz), how can I lift the entire thing to (Foo -> Bar -> m Baz)?
09:20:39 <mniip> (lift .) . f
09:20:52 <mniip> fmap (fmap lift) f
09:21:07 <dminuoso> (fmap . fmap . lift) f
09:22:19 <orion_> Thanks.
09:26:34 <orion_> mniip: (lift .) . f :: MonadTrans t => a1 -> a2 -> t IO a3 <-- I was expecting "a1 -> a2 -> m a3".
09:27:11 <glguy> orion_: Then replace lift with the thing you wanted
09:28:15 <orion_> hrm
09:28:31 <dminuoso> (fmap fmap fmap fmap lift) f
09:28:41 * dminuoso scratches his head
09:34:11 <glguy> dminuoso: I don't think that one is the same
09:34:33 <glguy> fmap ` fmap ` fmap ` fmap ` liftIO
09:36:49 <glguy> but of all the things typed so far, this was probably the right answer: fmap (fmap liftIO) :: MonadIO m => (a -> b -> IO c) -> a -> b -> m c
09:41:12 * hackage git-annex 6.20180427 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-6.20180427 (JoeyHess)
09:44:30 <dminuoso> glguy: Oh you're right. It should have been `fmap fmap fmap liftIO`
09:44:44 <dminuoso> :t (fmap fmap fmap liftIO)
09:44:45 <lambdabot> (Functor f2, Functor f1, MonadIO m) => f1 (f2 (IO a)) -> f1 (f2 (m a))
09:46:30 <spruit11> > dup x = (x,x)
09:46:32 <lambdabot>  <hint>:1:7: error:
09:46:32 <lambdabot>      parse error on input ‚Äò=‚Äô
09:46:32 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
10:01:44 <newsham> > let dup x = (x,x) in dup "test"
10:01:46 <lambdabot>  ("test","test")
10:05:32 <ZeuPiark> hello
10:09:26 <csauce> edwardk: Thanks, that discussion is helpful. Will have to try using new-build more extensively
10:18:44 <ph88> what can be done with the dwarf debug information for haskell program ?
10:29:27 <byorgey> shapr: http://girard.perso.math.cnrs.fr/mustard/article.html
10:29:52 <byorgey> shapr: I'm curious where your question came from though.  Did I mention mustardwatches at some point?
10:30:14 <byorgey> Or are you asking whether Girard's paper itself was a reference to something else?
10:36:30 <byorgey> based on my memories of Disney's Alice in Wonderland from my childhood, I wondered if it might have been a reference to that
10:36:54 <byorgey> but I just pulled out my copy of Alice's Adventures in Wonderland and found the tea-party, and it turns out mustard is not even mentioned.
10:37:04 <byorgey> there is *butter* in the watch (and tea), not mustart
10:37:06 <byorgey> *mustard
10:44:49 <MarcelineVQ> Many people don't even like mustard, this is one of the secret evils of the world.
10:47:22 <dyl> MarcelineVQ what!?
10:52:28 <dyl> Heresy!
11:34:44 <spruit11> let d x = (x,x) in (d.d.d.d.d.d.d.d) x
11:34:57 <spruit11> let d x = (x,x) in (d.d.d) x
11:35:08 <spruit11> Ow.
11:35:45 <spruit11> Sorry for that. ghci has no problem with that.
11:36:15 <spruit11> let d x = (x,x) in (d.d.d) 1
11:36:21 <spruit11> ?
11:36:27 <spruit11> > let d x = (x,x) in (d.d.d) 1
11:36:29 <lambdabot>  (((1,1),(1,1)),((1,1),(1,1)))
11:36:36 <spruit11> Ah.
11:37:02 <spruit11> :t let d x = (x,x) in (d.d.d) 1
11:37:03 <lambdabot> Num b => (((b, b), (b, b)), ((b, b), (b, b)))
11:37:44 <spruit11> :t let d x = (x,x) in (d.d.d.d) 1
11:37:45 <lambdabot> Num b => ((((b, b), (b, b)), ((b, b), (b, b))), (((b, b), (b, b)), ((b, b), (b, b))))
11:37:57 <metahumor> you can also private msg lambdabot =)
11:38:11 <spruit11> How do I do that?
11:38:28 <[exa]> spruit11: irc clients usually support some kind of /msg command
11:38:28 <Sose> /query lambdabot should work in most clients
11:38:30 <metahumor> "/msg lambdabot > let d x = (x,x) in (d . d . d) 1
11:39:02 <[exa]> spruit11: also, you probably have a ghci at hand, don't you. :D
11:39:34 <EvanR> running software on your own computer?
11:39:46 <EvanR> have you heard of the cloud?
11:39:52 <EvanR> its someone elses computer!
11:42:49 <spruit11> Pretty hardened.
11:44:26 <[exa]> "so it's not a literal cloud?"
11:48:03 <dyl> EvanR I have it on good authority that the Cloud is actually located in Montana.
11:48:11 <dyl> It‚Äôs the only place it could fit. They‚Äôve got a big sky.
11:48:56 <EvanR> badum-CHING
11:50:04 <dysfun> "it's in the sky sheep"
11:50:10 <dyl> Am I the only one that thinks Amazon naming their VR AWS service ‚ÄúSumerian‚Äù is a little on the nose?
11:51:55 <Psybur> dyl, I dont get it
11:52:51 <boxscape> (asked a few hours ago w/o response) I'm playing around with singletons, is there a way to make nat2nt work without the extra data family?
11:52:55 <boxscape> http://lpaste.net/365295
11:54:26 <dyl> Psybur: Snow Crash
11:54:35 <jle`> boxscape: type families are not necessarily injective, but data families are
11:54:50 <jle`> it means that just because (Foo x ~ Foo x), it doesn't necessarily mean that (x ~ x)
11:54:51 <Psybur> Never read it
11:54:56 <jle`> and ghc can't make that deduction
11:55:12 <jle`> boxscape: try specifying NatTuple as injective using -XTypeFamilyDependencies and see if it makes a difference
11:55:21 <boxscape> will try, thanks
11:56:05 <EvanR> er, Foo y ~ Foo x => y ~ x?
11:56:16 <EvanR> x ~ x goes withousaying right
11:56:26 <fishythefish> boxscape: intuitively, because `type` just gives you type synonyms, a type family applied to two different types can give you the same result
11:56:33 <fishythefish> `data` generates new types, so you get injectivity
11:57:48 <EvanR> or jle is using two different x's
11:58:05 <boxscape> that does make sense, I just felt like the fact that nat2nt' can be implemented seems to indicate that you can write that function in general, and having to introduce a data family seems strange
11:58:42 <jle`> EvanR: yeah that's right :)
11:58:57 <EvanR> this are the kind of theories haskell has driven me to
11:59:25 <jle`> boxscape: sometimes data families are just used superficially as 'injective type families'
11:59:33 <boxscape> ok
11:59:37 <jle`> back in the day, before we had type family dependencies
11:59:49 <jle`> the main difference here is that the data family is basically an injective version of your type familyt
12:00:09 <EvanR> boxscape is asking if you can produce a tuple of 0s of size equal to a given type level nat... without using data families
12:00:25 <EvanR> i'm wondering the same thing right now
12:00:41 <EvanR> seems like you should be able to
12:00:49 <boxscape> it works fine with a dependency, so that's nice
12:00:57 <jle`> woo hoo
12:02:02 <EvanR> instead of NatTuple you could use Vect n Nat right
12:03:20 <boxscape> I suppose that would probably be equivalent. The reason I have this type is mostly because it's a simplified version of me trying to generate Accelerate shapes from a typelevel list of Nats
12:03:51 <EvanR> oh its a type level list
12:03:58 <boxscape> no, it's not
12:04:02 <boxscape> just in my actual problem it is
12:04:07 <boxscape> not in this simplified version
12:04:31 <boxscape> I figured testing stuff with SZero and SSucc would be easier than testing with SNil and SCons
12:06:12 * hackage pandoc 2.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-2.2 (JohnMacFarlane)
12:07:55 <boxscape> It's nice to be doing stuff again where you know it works once it compiles
12:33:10 <tomlambda> What does runMaybeT do?
12:33:16 <tomlambda> :t runMaybeT
12:33:17 <lambdabot> error: Variable not in scope: runMaybeT
12:33:26 <glittershark> :t Control.Monad.Trans.Maybe.runMaybeT
12:33:27 <lambdabot> Control.Monad.Trans.Maybe.MaybeT m a -> m (Maybe a)
12:33:41 <EvanR> MaybeT m a -> m (Maybe a)
12:33:55 <leshow> I have a foo :: Int -> Cont r Int, I can't figure out how to run it. I've never used continuation monad before
12:34:04 <leshow> I tried runCont $ foo 100
12:34:07 <EvanR> it interprets a MaybeT m action in the m monad
12:34:16 <EvanR> which results in a Maybe
12:35:13 <EvanR> (i love it when the answer is almost obvious from the type sig)
12:35:45 <c_wraith> leshow, you're going to have to describe the error further. maybe a type error?
12:36:09 <tomlambda> evanR - :) Why isnt there an EitherT?
12:36:17 <EvanR> there was at some point
12:36:19 <c_wraith> leshow, it looks like you need more arguments.
12:36:21 <leshow> There isn't an error, it's just not fully applied
12:36:27 <EvanR> but now its called ExceptT
12:36:37 <leshow> I thought runCont was supposed to 'run' a continuation
12:36:43 <leshow> I'm just a bit confused haha
12:37:10 <c_wraith> leshow, it assembles continuation-passing pipeline, but you need to provide it with the final step.
12:37:32 <leshow> say I didn't want to pass in another uncompleted function, I just want it to evaluate
12:37:51 <tomlambda>  :t Control.Monad.Trans.ExceptT
12:37:55 <c_wraith> leshow, then it's a function. evaluating it will give you a function.
12:38:09 <tomlambda> :t Control.Monad.Trans.ExceptT
12:38:10 <lambdabot> error:
12:38:11 <lambdabot>     Not in scope: data constructor ‚ÄòControl.Monad.Trans.ExceptT‚Äô
12:38:11 <lambdabot>     Perhaps you meant ‚ÄòControl.Monad.Except.ExceptT‚Äô (imported from Control.Monad.Except)
12:38:22 <tomlambda> :t Control.Monad.Except.ExceptT
12:38:24 <lambdabot> m (Either e a) -> ExceptT e m a
12:38:25 <EvanR> Control.Monad.Except
12:38:30 <leshow> It evalueates to a Cont r Int, is there a way to use id or something to get the Int out, assuming it returned it
12:38:42 <EvanR> :t Control.Monad.Except.runExceptT
12:38:43 <lambdabot> ExceptT e m a -> m (Either e a)
12:39:04 <c_wraith> leshow, that's like asking how to get the Int out of Reader r Int
12:39:24 <EvanR> tomlambda: youll notice a lot of these "run" functions are really just unwrappers for a newtype
12:39:44 <c_wraith> leshow, there isn't one. you need to provide the argument before there becomes one.
12:39:50 <EvanR> to the point that people often name newtype unwrappers "runsomething" even when it doesnt make sense :)
12:40:08 <EvanR> :t runIdentity
12:40:09 <lambdabot> Identity a -> a
12:40:21 <leshow> c_wraith: I'm not explaining very well. I saw a slide in a video where on Eta where they wrapped a runCont and continuation in 'trampoline' and produced a value
12:40:33 <spruit11> What who be the smallest expression to grow the type term the largest?
12:40:37 <spruit11> *would
12:40:56 <c_wraith> leshow, ultimately you can't do this without picking a monomorphic type for r
12:40:59 <spruit11> So, there's dup. But can you do better?
12:41:30 <ZeuPiark> hello
12:41:33 <c_wraith> leshow, if you want an Int back, you need to pick r ~ Int, and probably pass id as that argument as the docs say.
12:41:58 <tomlambda> EvanR - Why newtype unwrapper and not just unwrapper?
12:42:12 <tomlambda> Not sure why its specific to newtype
12:42:29 <tomlambda> newtype just means only one data constructor right?
12:42:36 <EvanR> monad transformers are implemented as newtypes
12:42:44 <tomlambda> But multiple type constructors
12:42:54 <EvanR> no
12:43:14 <c_wraith> tomlambda, it's more subtle than that. there are implications wrt strictness and pattern matching.
12:44:11 <leshow> {-
12:44:13 <leshow> let (mut a, mut b) = (0, 1);
12:44:13 <EvanR> you could call a non-newtype data type unwrapper "runSomething" if you want
12:44:15 <leshow> while n > 0 {
12:44:17 <leshow>     let temp = a + b;
12:44:19 <leshow>     a = b;
12:44:21 <leshow>     b = temp;
12:44:23 <leshow>     n--;
12:44:25 <leshow> }
12:44:27 <leshow> -}
12:44:29 <leshow> woops
12:44:31 <leshow> sorry
12:44:59 <tomlambda> ah ok makes sense
12:45:23 <tomlambda> What abstraction should I use for sequencing IO actions that yield an Either?
12:45:38 <tomlambda> Im thinking the ExceptionT but not sure
12:45:59 <c_wraith> ExceptT, I think?
12:46:04 <EvanR> there is liftEither in Control.Monad.Except
12:46:09 <boxscape> @unmtl ExceptT (IO String)
12:46:10 <lambdabot> ExceptT (IO String)
12:46:15 <boxscape> is there a IOT?
12:46:28 <glittershark> ExceptT IO String
12:46:34 <glittershark> @unmtl ExceptT IO String
12:46:35 <lambdabot> ExceptT IO String
12:46:39 <c_wraith> boxscape, that would have time travel problems.
12:46:44 <boxscape> ah, fair enough
12:46:47 <glittershark> monad transformers have kind (* -> *) -> * -> *
12:46:56 <boxscape> yeah I got the parens wrong didn't I
12:46:58 <glittershark> yep
12:47:05 <glittershark> :)
12:47:08 <tomlambda> So If I am using an ExceptT IO string where do I specify the Either types left and right types?
12:47:13 <EvanR> tomlambda: if you really want that, then convert all your IO actions that return Either to be ExceptT e IO instead
12:47:17 <glittershark> oh actually oops
12:47:24 <glittershark> it's ExceptT e IO String
12:47:26 <glittershark> where e is the Left type
12:47:30 <boxscape> ah, that makes sense
12:47:38 <boxscape> @unmtl ExceptT String IO Int
12:47:38 <lambdabot> ExceptT String IO Int
12:47:40 <boxscape> meh
12:47:44 <glittershark> :t Control.Monad.Trans.Except.ExceptT
12:47:45 <lambdabot> m (Either e a) -> ExceptT e m a
12:47:59 <EvanR> but youre getting close to transformer pergatory
12:48:07 <EvanR> purgatory*
12:48:11 <tomlambda> Whats transformer purgatory?
12:48:50 <EvanR> transformers are addictive, once you use one over IO you start wanting to use more and more
12:49:11 <EvanR> in the end, IO can already do all the things youre equipping it with
12:49:37 <glittershark> ReaderT r IO is nice
12:49:47 <EvanR> r -> IO is nice :)
12:49:54 <glittershark> ha
12:49:58 <glittershark> I call isomorphism
12:50:22 <tomlambda> haha is there a rehab centre
12:50:30 <tomlambda> *center#
12:50:38 <boxscape> effects libraries, maybe?
12:50:44 <glittershark> FreeT?
12:50:47 <EvanR> you have to set up your own tower of transformers over IO and then figure out MonadBaseControl
12:50:55 <EvanR> before you can be let out of rehab
12:51:09 <EvanR> and use r -> IO a
12:51:28 <tomlambda> Can I stack a transformer on a transformer
12:51:31 <glittershark> sure
12:52:04 <glittershark> :t Control.Monad.Trans.Except.runExceptT . flip Control.Monad.Trans.Reader.runReaderT 5
12:52:05 <lambdabot> Num r => ReaderT r (ExceptT e m) a -> m (Either e a)
12:52:46 <spruit11> > let t f = f.f in let d x = (x,x) in (t.t) d 1
12:52:51 <lambdabot>  error:
12:52:52 <EvanR> that doesnt stack a transformer on a transformer, that applies a transformer to a monad
12:52:55 <lambdabot>      ‚Ä¢ Occurs check: cannot construct the infinite type: b ~ (b, b)
12:52:59 <lambdabot>        Expected type: b -> b
12:53:13 <spruit11> That's a bit of a pity. Ah well.
12:53:16 <EvanR> compose vs apply
12:53:25 <fishythefish> spruit11: what do you expect that to do?
12:53:36 <glittershark> it was more about demonstrating how to un-stack once you stack
12:53:51 <spruit11> Tuple exponentially. But it doesn't go through the type checker.
12:53:52 <EvanR> oh yeah i didnt even read it
12:54:26 <fishythefish> spruit11: of course; d is a -> (a, a), not a -> a
12:54:29 <EvanR> you can do ExceptT e (ReaderT Config IO a)
12:54:38 <spruit11> Yah sure.
12:54:42 * hackage rattletrap 4.0.9 - Parse and generate Rocket League replays.  http://hackage.haskell.org/package/rattletrap-4.0.9 (fozworth)
12:54:54 <EvanR> but to compose it would be like... ExceptT e `o` ReaderT Config IO
12:55:25 <EvanR> no thats wrong :(
12:55:31 <EvanR> youd need type level .:
12:55:43 <spruit11> I am looking at small expressions to generate ridiculously large type terms.
12:55:57 <glittershark> I know the real answer is "read the dang core" but... how good is GHC's CSE?
12:56:40 <glittershark> does `foo (bar x) (bar x)` definitely let-float the call to bar?
12:56:49 <EvanR> in general i would be scared of CSE in haskell
12:57:30 <glittershark> because of strictness / laziness?
12:57:33 <fishythefish> spruit11: I think that's unlikely to work
12:57:38 <EvanR> because i am already scared of assuming the different instances of an expression will not be shared
12:58:04 <glittershark> man seq is just the worst :(
12:58:41 <boxscape> what's CSE short for?
12:58:46 <glittershark> common sub-expression
12:58:49 <boxscape> I see
12:58:56 <fishythefish> ...elimination
12:59:00 <EvanR> consider sometimes you want a computation to restart rather than take up huge memory so it can be used a second time down the road
12:59:01 <glittershark> yeah
12:59:27 <dminuoso> glittershark: In reality CSE is opt-in via sharing with let/where
12:59:34 <glittershark> aww
12:59:34 <EvanR> when you dont, you can do let yourself
12:59:41 <glittershark> I want GHC to do that for me is the thing
12:59:50 <glittershark> introducing local variables requires naming those local variables
12:59:54 <glittershark> and naming things is hard
13:00:01 <EvanR> if it does it for you, then you have to opt out with a nullary lambda wrapper thingie
13:00:05 <dminuoso> glittershark: It can create invisible space leaks..
13:00:12 <glittershark> yeah, all fair
13:00:12 <EvanR> damned if you do damned if you dont
13:00:18 <Psybur> :t fix $ (,) 1
13:00:19 <lambdabot> error:
13:00:19 <lambdabot>     ‚Ä¢ Occurs check: cannot construct the infinite type: b ~ (a, b)
13:00:19 <lambdabot>       Expected type: (a, b) -> (a, b)
13:00:21 <fishythefish> spruit11: the size of your type basically has the size of your expression as an upper bound (modulo a proportionality factor)
13:00:32 <EvanR> i prefer lets over () -> a wrappers
13:00:32 <spruit11> That's not true,
13:00:34 <fishythefish> a type that grows past that is probably going to run into the occurs check
13:00:37 <fishythefish> i.e. it's infinite
13:00:47 <fishythefish> (this is not a rigorous argument; I'm just spitballing)
13:00:58 <spruit11> The size of a type is exponential in the size of the term.
13:01:01 <dminuoso> glittershark: You might find a look at GHCs source code of interest: https://github.com/ghc/ghc/blob/ghc-8.4/compiler/simplCore/CSE.hs
13:01:21 <glittershark> oh, nice
13:01:34 <glittershark> god I love GHC's source
13:01:38 <glittershark> so well commented <3
13:01:46 <spruit11> > let d x = (x,x) in let q = d.d.d.d in let w = q.q.q.q in w 0
13:01:52 <lambdabot>  mueval-core: Time limit exceeded
13:02:04 <spruit11> Exponential. Trivially.
13:02:05 <fishythefish> spruit11: well, I guess depending on whether you expand the let bindings before or after your measure the size
13:03:04 <spruit11> But I wanted it to grow faster.
13:03:05 <lyxia> :t let d x = (x,x) in let q = d.d.d.d in let w = q.q.q.q in w 0
13:03:12 <lambdabot> Num b => ((((((((((((((((b, b), (b, b)), ((b, b), (b, b))), (((b, b), (b, b)), ((b, b), (b, b)))), ((((b, b), (b, b)), ((b, b), (b, b))), (((b, b), (b, b)), ((b, b), (b, b))))), (((((b, b), (b, b)),
13:03:12 <lambdabot> ((b, b), (b, b))), (((b, b), (b, b)), ((b, b), (b, b)))), ((((b, b), (b, b)), ((b, b), (b, b))), (((b, b), (b, b)), ((b, b), (b, b)))))), ((((((b, b), (b, b)), ((b, b), (b, b))), (((b, b), (b, b)), (
13:03:12 <lambdabot> (b, b), (b, b)))), ((((b, b), (b, b)), ((b, b), (b, b))), (((b, b), (b, b)), ((b, b), (b, b))))), (((((b, b), (b, b)), ((b, b), (b, b))), (((b, b), (b, b)), ((b, b), (b, b)))), ((((b, b), (b, b)), ((
13:03:12 <lambdabot> b, b), (b, b))), (((b, b), (b, b)), ((b, b), (b, b))))))), (((((((b, b), (b, b)), ((b, b), (b, b))), (((b, b), (b, b)), ((b, b), (b, b)))), ((((b, b), (b, b)), ((b, b), (b, b))), (((b, b), (b, b)), (
13:03:12 <lambdabot> (b, b), (b, b))))), (((((b, b), (b, b)), ((b, b), (b, b))), (((b, b), (b, b)), ((b, b), (b, b)))), ((((b, b), (b, b)), ((b, b), (b, b))), (((b, b), (b, b)), ((b, b), (b, b)))))), ((((((b, b), (b, b))
13:03:14 <lambdabot> [1644 @more lines]
13:03:19 <glittershark> hahaha
13:03:22 <lyxia> "oops"
13:03:26 <boxscape> that's quite a few more lines
13:03:31 <Psybur> @more
13:03:31 <lambdabot> Plugin `more' failed with: Prelude.init: empty list
13:03:33 <boxscape> sorry for the ping, @lines
13:03:40 <boxscape> unfortunate name
13:04:48 <tomlambda> oh snoyman says "It is almost always wrong to wrap an ExceptT, EitherT, or ErrorT around an IO-based transformer stack."
13:06:25 <tomlambda> Does this mean I shouldnt convert my IO Either into a ExceptionT
13:06:36 <tomlambda> https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices
13:07:25 <spruit11> I could get this to work in an untyped language. "let t f = f.f in let d x = (x,x) in (t.t) d 1" but ah well.
13:07:40 <spruit11> Still interested.
13:08:09 <boxscape> can you do that with unsafeCoerce or does that not affect the occurs check?
13:08:34 <spruit11> No idea.
13:09:11 <lyxia> spruit11: can you give that a recursive type? what would it look like?
13:09:46 <spruit11> Dunno. I just tried it in my own language, and that works. But no idea how to type it.
13:10:25 <spruit11> It was my first try at creating hyperexploding types. For fun. I didn't think it over.
13:10:33 <lyxia> Oh I see what's going on.
13:10:45 <boxscape> hm, it compiles with unsafeCoerce wrapped around a few expressions, but doesn't show any output in ghci, probably because it wraps it in some weird default IO type
13:11:03 <glittershark> it's possible you're unsafeCoercing to ()
13:11:10 <boxscape> ah, yeah, that's probably it
13:11:13 <glittershark> and then `IO ()` is a no-print for ghci
13:11:28 <glittershark> and it's not failing because it's never actually evaluating anything
13:12:39 <boxscape> coercing it into a Bool makes it "False", for what it's worth :D
13:13:02 <glittershark> lol
13:13:07 <glittershark> I bet that's just 0
13:13:09 <glittershark> in memory
13:13:15 <boxscape> no, Int is some random large number
13:13:28 <glittershark> fun with pointer casts
13:13:38 <glittershark> Int is usually more than one word
13:13:48 <glittershark> so the first byte of the memory is probably 0
13:13:53 <boxscape> guess I should try Word8
13:14:03 <boxscape> uhm
13:14:06 <jle`> tomlambda: i wouldn't take that as a hard and fast rule, but, ther eis no reason to turn an IO EIther into an ExceptT with IO unless you do repeated binds or other typeclass functions with it
13:14:23 <glittershark> what is the recommended way of doing ListT-esque things?
13:14:32 <glittershark> I'm currently grappling with 4 nested calls to `for_
13:14:44 <glittershark> and would love to pyramid-of-doom a little less
13:14:47 <jle`> tomlambda: if you have just one IO (Either e a), then there is no reason to turn it into an ExceptT e IO a, unless you are doing short-circuit monadic binding, <|>-ing, applicativeing, etc.
13:14:48 <boxscape> Word8 is 283610525616. How does that work?
13:14:56 <Psybur>  % unsafeCoerce (return () :: IO ()) :: Bool
13:14:58 <Psybur> % unsafeCoerce (return () :: IO ()) :: Bool
13:14:58 <yahb> Psybur: True
13:15:05 <jle`> tomlambda: the stance in that article is that even in that case, you shouldn't do it
13:15:14 <Psybur> % unsafeCoerce (return () :: IO ()) :: Int
13:15:14 <yahb> Psybur: 1099511628032
13:15:15 <jle`> tomlambda: or actually, the article is a little softer than that
13:15:18 <boxscape> I guess it has probably something to do with the Show instance of Word8
13:15:32 <boxscape> @ unsafeCoerce (return () :: IO ()) :: Word8
13:15:36 <boxscape> er
13:15:39 <boxscape> I meant %
13:15:43 <boxscape> % unsafeCoerce (return () :: IO ()) :: Word8
13:15:43 <yahb> boxscape: 1099511628032
13:15:46 <boxscape> nice
13:15:50 <Psybur> % unsafeCoerce (return () :: IO ()) :: [Int]
13:15:50 <yahb> Psybur: [[Segmentation fault]
13:15:55 <tomlambda> jle - thanks
13:15:58 <jle`> tomlambda: if you're just using ExceptT as a newtype wrapper to get convenient short circuiting in a single location, it's useful.  the article is saying that your entire application's context should not be ExceptT over IO
13:16:25 <jle`> tomlambda: it doesn't say anything really about local usage of ExceptT as a convenient sugar for short circuit binding, it's talking more about high level application architecture
13:16:27 <Psybur> % unsafeCoerce (return () :: IO ()) :: String
13:16:36 <yahb> Psybur: "[Segmentation fault]
13:16:53 <jle`> tomlambda: but also of course there is nothing wrong with an IO Either, and wrapping it in ExceptT is pointless unless you do something that only ExceptT can do
13:17:14 <tomlambda> jle -  I have multiple functions that return IO Either
13:17:30 <jle`> tomlambda: that does happen, yes
13:17:39 <jle`> tomlambda: but do you want to sequence them all together?
13:17:59 <boxscape> glittershark:  I think the first byte is actually 40 in the case of the first expression, since coercing it to Word8 and adding 0 results in 40
13:18:00 <jle`> the local usage of ExceptT is mostly useful to avoid ugly nested pattern matching
13:18:07 <tomlambda> Yes
13:18:27 <jle`> then yeah, it might be useful to use ExceptT locally as 'sugar' to get around nested pattern matching
13:18:40 <glittershark> boxscape: fascinating! an adventure into GHC's tagged data type representation :)
13:18:48 <boxscape> yeah
13:18:49 <jle`> tomlambda: if you wrap and immediately unwrap
13:19:17 <jle`> tomlambda: if you never sequence them after each other or run into a nested pattern matching situation, then yes, you should not wrap it in ExceptT.
13:19:31 <jle`> just because you have an IO Either doesn't mean you should immediately wrap it
13:20:02 <jle`> but doing it locally (immediate wrap/unwrap) can be useful to clean up nested pattern matches
13:20:20 <jle`> your functions would still return IO (Either e a), but when you want to sequence them, you wrap them
13:20:25 <jle`> *wrap the results
13:21:19 <jle`> the article speaks mostly about using ExceptT as a part of your overall application context, from an architecture standpoint.  in this regard though, the article has been highly contested in the past
13:21:47 <jle`> it can be considered opinionated
13:22:32 <tomlambda> jle - Thanks!
13:22:36 <jle`> no problem!
13:37:43 <dminuoso> Are there advantages to using conduit over raw Network.Socket if Im just dealing with miniature packets wrapped in udp (50-200 octets each)?
13:38:31 <EvanR> it seems to me that is not a stream processing situation
13:39:00 <EvanR> each datagram is small enough to be a whole value, fully materilzied
13:39:09 <EvanR> materialized
13:40:17 <EvanR> if "dealing with" a packet is something you can do asynchronously, just fork a thread to "deal with" it and coordinate all the threads with concurrent haskell
13:41:45 <EvanR> if its synchronous, even simpler...
13:42:01 <dminuoso> EvanR: I can do either really..
13:42:36 <dminuoso> EvanR: The only relevant bit is that I may get duplicate packets, which I have to sort in a way to only process them once.
13:43:24 <EvanR> if you have an IO action that blocks until it gets a whole datagram, you can simply put that in a processing loop. which may include consulting your duplicate database
13:44:37 <dminuoso> I mean I'd love for this to be fully concurrent. The processing involves quite a bit of IO, so it might take up to 10-20ms to fully process a package. Most of that is just sleeping.
13:44:42 <EvanR> ive seen simple stuff like thing get blown out of proportion with enterprise integration patterns and its like... why
13:45:12 <EvanR> then yeah at some point in your loop, forkIO or async fork a thread to do the rest of the work
13:45:28 <EvanR> and return to blocking waiting
14:03:40 <jle`> .quit
14:03:51 * jle` exeunt
14:11:26 <darkkkserj> hj
14:11:28 <darkkkserj> hi
14:19:20 <habolabo> what's the proper form of "zipWith f $ unzip list"
14:19:26 <habolabo> i can't find it x_x
14:20:41 <EvanR> :t unzip
14:20:42 <lambdabot> [(a, b)] -> ([a], [b])
14:20:55 <EvanR> :t curry
14:20:57 <lambdabot> ((a, b) -> c) -> a -> b -> c
14:21:45 <EvanR> :t uncurry
14:21:46 <lambdabot> (a -> b -> c) -> (a, b) -> c
14:21:58 <habolabo> :x
14:22:03 <habolabo> ty
14:22:43 <EvanR> :t map (uncurry f) . unzip
14:22:44 <lambdabot> error:
14:22:44 <lambdabot>     ‚Ä¢ Couldn't match type ‚Äò([a], [b])‚Äô with ‚Äò[((), ())]‚Äô
14:22:44 <lambdabot>       Expected type: [(a, b)] -> [((), ())]
14:23:04 <EvanR> fruit
14:23:08 <monochrom> Omit the unzip if you already have map (uncurry f)
14:24:13 <sl2c> :t map (uncurry f)
14:24:14 <lambdabot> (FromExpr b2, Show b1, Show a) => [(a, b1)] -> [b2]
14:24:30 <sl2c> :t f
14:24:31 <lambdabot> FromExpr a => a
14:24:45 <sl2c> :t map . uncurry
14:24:46 <lambdabot> (a -> b1 -> b2) -> [(a, b1)] -> [b2]
14:25:56 <EvanR> this is your brain on functions taking pairs instead of being curried
14:28:53 <monochrom> I suppose everything would be more elegant if you replaced [(a,b)] by [forall r. (a -> b -> r) -> r]? XD
14:30:10 * EvanR computes the churchified list of churchified pairs
14:30:17 * EvanR gives up
14:30:30 <monochrom> Heh
14:31:08 * EvanR goes to get some churchifried chicken
14:59:00 <Ariakenom> Floating point issues boy do I have the cure for you! Just use a rational of (Integer, Int). Unbounded magnitude, linear memory, and 0.1+0.2=0.3!
15:00:42 * hackage stack 1.7.1 - The Haskell Tool Stack  http://hackage.haskell.org/package/stack-1.7.1 (borsboom)
15:02:37 <MarcelineVQ> you madman
15:03:06 <iqubic> Dependent types deeply confuse me.
15:03:53 <boxscape> which part iqubic?
15:04:11 <iqubic> Just about all it.
15:05:18 <boxscape> The biggest hurdle I've had is that it doesn't seem like there's really a good, up-to-date tutorial on how to use them in Haskell, which I suppose makes sense given that it's constantly changing
15:05:26 <boxscape> (At least I haven't found one)
15:05:33 <boxscape> though the singletons paper was quite helpful
15:07:07 <iqubic> Yeah. I would like to use them in Haskell. I'm also learning Coq on the side which has dependent types build it.
15:08:13 <EvanR> Ariakenom: just don't divide by 3 !
15:08:33 <EvanR> oh i thought you were doing mantissa exponent in base 10
15:09:10 <EvanR> also 0.1 + 0.2 = 0.3 is overrated
15:12:51 <EvanR> dminuoso: after reading all about IP, it seems like a Network.Socket datagram socket  almost directly gives you this "IO action that blocks until you get 1 message"
15:13:26 <EvanR> message protocol over TCP eat your heart out
15:14:15 <Ariakenom> EvanR: Let's day you're doing spreadsheets. What number-type do your users get to use?
15:14:56 <EvanR> natural numbers only, as god intended
15:15:54 <dminuoso> EvanR: Honestly I could love with that. There ought to be not much time between reading one datagram off the socket, and forking a handler.
15:15:57 <dminuoso> live with that!
15:16:15 <EvanR> probably not
15:17:14 <EvanR> just make sure your read buffer is big enough for the max size of your message and discard anything that came through that is too big
15:17:44 <EvanR> bigger than expected / bigger than the biffer
15:21:25 <aarvar> boxscape: maybe no such tutorial exists because haskell doesn't have them
15:21:37 <aarvar> and faking them is just too painful
15:21:47 <MarcelineVQ> it does exist <_<https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html
15:22:02 <dminuoso> EvanR: Mmm. what happens if I read less than what was sent in the datagram?
15:22:10 <aarvar> MarcelineVQ: funny
15:22:15 <dminuoso> will those bytes be still there, or do I only get to recvFrom once?
15:23:53 <aarvar> when did people quit talking about faking dependent types and just start calling them dependent types?
15:25:36 <dstolfa> aarvar: runtime types!
15:25:37 * dstolfa ducks
15:25:49 <aarvar> runtime dependent types!
15:25:52 <dstolfa> oh boy
15:26:10 <dminuoso> ruby has those.
15:26:20 <aarvar> lol
15:26:55 <iqubic> What the heck are runtime types?
15:27:03 <dstolfa> iqubic: they're like types, at runtime you know
15:27:19 <dstolfa> like, idk, int at runtime
15:27:29 <ryantrinkle> anyone have a nice way to monadically fail in the Data.Map.fromListWith's combining function?
15:27:31 * dstolfa seriously ducks now
15:27:45 <dminuoso> ^- and that is duck typing.
15:27:50 * dminuoso hides
15:27:51 <dstolfa> dminuoso: :)))))))))
15:27:52 <aarvar> ryantrinkle: what does "monadically fail" mean
15:28:19 <ryantrinkle> aarvar: specifically, throwError
15:28:34 <ryantrinkle> currently, i'm constructing a map full of actions, then sequencing it
15:28:41 <ryantrinkle> but that's a bit gross
15:29:20 <ryantrinkle> what i'd really like is something like Map.fromListWithM :: (v -> v -> m v) -> [(k, v)] -> m (Map k v)
15:29:42 <smaller_infinity> Actions as in some type of function?
15:29:54 <aarvar> fromListWithM f = sequence . fromListWith f
15:29:58 <aarvar> xd
15:30:10 <ryantrinkle> aarvar: right; that's what i'm doing now
15:30:21 <ryantrinkle> it's just a bit gross to rebuild the structure
15:31:31 <aarvar> use a lazy map?
15:31:34 <Ariakenom> dstolfa is somehow below the floor
15:32:09 * dstolfa thinks it's running time
15:41:46 <AndreasK> ryantrinkle: Can't you just sequence the list before putting it into the map?
15:42:50 <AndreasK> Oh right the combining thing
15:48:38 <AndreasK> ryantrinkle: You could use foldM and alterF
15:48:53 <setre> I'm trying to use xml-html-conduit-lens even though I'm a beginner at haskell and lens. it's really hard because I can't find many examples. My end goal is making a function which takes a html fragment and modifies relative image links to absolute ones. Any pointers?
15:48:58 <shapr> byorgey: I just solved the second week of cis194, and mustardwatch is part of the solution
15:49:00 <shapr> thus my question
15:49:09 <shapr> and then I got distracted by work :-)
16:14:39 <o_miguel> I understand that: foo :: forall a. a -- foo's type is the intersection of all types (so it contains only bottom). But I can not quite imagine what kind of intersection the followin is: bar :: forall a. (a->b)
16:15:39 <fishythefish> b is implicitly quantified with a prenex forall b.
16:15:47 <fishythefish> so this is the intersection of all function types
16:16:32 <o_miguel> ok so my bar is equivalent to : forall a b. (a->b) right?
16:17:19 <Maxdamantus> o_miguel: missing comma, but yes.
16:17:27 <o_miguel> which is equivalent to just bar:: a->b ?
16:17:31 <fishythefish> yup
16:17:46 <o_miguel> but i do not see why the intersection of all function types contains all function types...
16:18:07 <fishythefish> it doesn't
16:18:41 <fishythefish> all values are semantically bottom
16:18:45 <o_miguel> ah so it does only contain the functions that get bottom as input and output bottom
16:18:48 <o_miguel> ook
16:18:58 <fishythefish> no, the function need not receive bottom as input
16:20:19 <o_miguel> maybe I do not understand how function types get intersected...
16:21:07 <o_miguel> i have sets of function types, right?
16:21:20 <o_miguel> ah
16:22:42 <fishythefish> we're playing a game: I pick two types a and b, and you give me a function of type a -> b. Can you pick one function that you can always answer with no matter what my choices of a and b are?
16:22:42 <boxscape> considering `reverse' is a bijection, is it possible to write it using only injective functions?
16:22:44 <o_miguel> and I create one set of (a->b) for every possible a, there is?
16:22:55 <boxscape> (Interestingly, that's not even a contrived question, it's actually relevant for what I'm trying to do)
16:23:01 <fishythefish> boxscape: every bijection is an injection
16:23:17 <fishythefish> o_miguel: no, you're quantifying over both a and b, not just a
16:23:18 <o_miguel> fishythefish: i could always use id for instance
16:23:20 <boxscape> right but I'm trying to convince ghc ;)
16:23:39 <fishythefish> o_miguel: id does not have type a -> b
16:23:41 <boxscape> and ghc doesn't know that reverse is a bijection
16:23:55 <fishythefish> how are you encoding bijections?
16:24:30 <o_miguel> fishythefish: hhm maybe something like:  const undefined
16:24:42 <o_miguel> flipping it
16:24:43 <fishythefish> o_miguel: yes, const undefined works
16:24:52 <boxscape> I'm thinking about whether I can write a type family Reverse that takes type family lists and has a type family dependency, to prove its injectivity fishythefish
16:25:04 <boxscape> the one provided by singletons doesn't have that
16:25:24 <boxscape> s/type family lists/type level lists
16:25:43 <o_miguel> fisheryfish.. ok guess there are not many other possibilities I could pick..
16:25:50 <fishythefish> boxscape: are you looking for https://ghc.haskell.org/trac/ghc/wiki/InjectiveTypeFamilies?
16:26:44 <o_miguel> I guess I begin to understand it
16:27:12 <boxscape> fishythefish: I don't think so... It looks like this introduces type family dependencies, which I know about (since today), but the question is how I actually write the type family so that ghc doesn't complain (the usual way of writing reverse with ++ seems out, since ++ isn't injective)
16:27:42 <fishythefish> (++) is injective
16:27:53 <fishythefish> as a function of one argument
16:28:24 <boxscape> hm, that is true... I was only thinking of two arguments, but maybe this works, I guess I should try it anyway
16:28:31 <fishythefish> so you could maybe defunctionalize, but I haven't thought about this too deeply
16:28:39 <boxscape> hm, okay
16:31:25 <fishythefish> btw, I wouldn't call writing reverse with (++) usual, merely naive
16:31:27 <isovector> sorry, just caught the tail of this. defunctionalize what?
16:32:13 <boxscape> fishythefish: that's fair. The first alternative I was thinking of was writing it with foldr, which has the same problem, I think
16:32:49 <o_miguel> hmmm. lets take: forall a. ([a]->[a]). as another example... the resulting set should contain [Int]->[Int] and [String]->[String] ... right? but I do not see what sets are intersected here.
16:33:06 <boxscape> isovector: I'm trying to write a type level version of Reverse and convince ghc that it's injective, and fishythefishsaid maybe you could defunctionalize (++) since it's injective with one argument
16:33:26 <fishythefish> o_miguel: it's the intersection of the sets [Int]->[Int], [String]->[String], etc.
16:33:42 * hackage beam-core 0.7.2.1 - Type-safe, feature-complete SQL query and manipulation interface for Haskell  http://hackage.haskell.org/package/beam-core-0.7.2.1 (TravisAthougies)
16:35:29 <Sonarpulse> where is the identity functor lens?
16:35:36 <o_miguel> is the intersection of  A->B  and C->D    equal to intersection (A.C) -> intersection (B,D) ?
16:35:53 <isovector> Sonarpulse: isn't it just `id`?
16:36:00 <o_miguel> because I do not get how to "intersect" the function types
16:36:01 <fishythefish> o_miguel: no
16:36:07 <Sonarpulse> isovector: for Identity?
16:36:09 <Sonarpulse> maybe
16:36:13 <Sonarpulse> I'll try
16:36:18 <fishythefish> assuming those type variables are implicitly quantified with prenex foralls, then those functions types are the same
16:36:29 <isovector> oh, like you want to fiddle with inside an `Identity`?
16:36:55 <zachk> @type returnIO
16:36:56 <lambdabot> error:
16:36:57 <lambdabot>     ‚Ä¢ Variable not in scope: returnIO
16:36:57 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
16:37:02 <zachk> @type mfix
16:37:03 <lambdabot> MonadFix m => (a -> m a) -> m a
16:37:09 <zachk> @src mfix
16:37:09 <lambdabot> Source not found. Just try something else.
16:37:51 <Sonarpulse> isovector: oh it's traverse
16:37:55 <Sonarpulse> there's just one cannonical one
16:45:00 <duairc> Is there a name for a Profunctor-shaped thing that's neither Divisible nor Applicative on their own, but is necessarily both at the same time in their respective arguments? i.e., for which you can implement something like a combined divide/liftA2 that would look like: (z -> (x, y)) -> (a -> b -> c) -> p x a -> p y b -> p z c ?
16:48:45 <duairc> I mean I want to call it Proapplicative, but that doesn't seem to be a thing
16:48:54 <duairc> I'm wondering if there's a good reason for that
16:54:02 <o_miguel> ok one more try: forall a. ([a]->Bool) is the intersection of [Int]->Bool and [String]->Bool and [Bool]->Bool.. etc... and it will contain them all because we intersect only over the "output" type?
16:54:34 <fishythefish> intersections do not contain all of their components
16:54:37 <fishythefish> you're thinking of a union
16:55:58 <o_miguel> fishythefish: I do not understand why [a]->Bool contains [String]->Bool, when i intersect it.. because it looks like an union to me
16:56:12 <fishythefish> [a] -> Bool does not contain [String] -> Bool
16:57:46 <o_miguel> so my misconception is the following: null :: [a] -> Bool, and I can use it as [String] -> Bool
16:58:11 <fishythefish> that's because [String] -> Bool contains [a] -> Bool
16:58:19 <o_miguel> haha
16:58:20 <o_miguel> ok
16:58:21 <fishythefish> an intersection is always contained in each of its components
16:58:28 <o_miguel> I have to rethink it then
16:58:30 <o_miguel> thank you
17:00:49 <Sonarpulse> isovector: relatedly, (functor is to traversable and lens) as natural transformation is to ??? and ???
17:02:01 <o_miguel> aaaah I think/hope I understand  ... [a]->Bool is a subset of [String]->Bool, so I can use functions of type [a]->Bool everywhere I would need a function of [Int]->Bool or [String]->Bool because they are obviously in both of this sets!!
17:02:44 <boxscape> Isn't [a]->Bool a superset of [String]->Bool?
17:02:48 <o_miguel> this makes perfect sense, thank you fishythefish
17:03:10 <fishythefish> boxscape: no, everything that is an [a] -> Bool can be used as a [String] -> Bool but not vice versa
17:03:12 <o_miguel> boxscape: that is what was misleading me the complete evening. but its exactly the other way round
17:03:40 <o_miguel> now forall makes sense (at least the few appliactions I encountered so far)
17:03:54 <boxscape> okay, yeah, I can see why it  wouldn't be a superset
17:08:25 <zachk> I am currently perusing the oleg paper from '2005 on oo-haskell, and I was wondering what the current state of the art for object oriented programming in haskell is, also is there a hackage package for oleg's oo-haskell?
17:12:15 <[Leary]> Unless my interpretation of "injective on one argument" is wrong, (++) isn't. Since e.g. [1,1] ++ [1,1..] = [1] ++ [1,1..], and forall x, y, forall infinite z: z ++ x = z ++ y.
17:17:05 <boxscape> that's a good point Leary
17:17:29 <boxscape> or two good points, rather
17:18:20 <boxscape> I guess that's why you can't have a a
17:18:21 <boxscape> oops
17:18:55 <boxscape> can't have a type family instance like "TypeF <lhs> = TypeF <rhs>"
17:19:02 <boxscape> maybe
17:19:14 <boxscape> if you want it to be injective, that is
17:34:22 <boxscape> I suppose if you include infinite lists, reverse itself also isn't injective, since all infinite lists map onto bottom
17:36:59 <boxscape> on the other hand, if you only want to write Reverse for finite lists up to a certain length, making it injective is trivial (though cumbersome). That might be what I'll end up doing.
17:39:29 <boxscape> would be nice if I could do it for finite lists of arbitrary length while including infinite lists, but I'm sure if that's possible
17:39:38 <boxscape> s/including/excluding
17:48:07 <dyl> Well this is a fun surprise.
17:48:17 <dyl> I guess I‚Äôm implementing marching cubes now.
17:48:43 <dyl> Academia is chaotic and hectic but it‚Äôs nice to have so many distinct and interesting subprojects.
17:49:00 <dyl> And by ‚Äúimplement‚Äù I mean ‚Äúrip off Paul Bourke‚Äù.
17:49:09 <dyl> As is tradition.
17:49:36 <aarvar> why would you ever want an infinite []?
17:49:43 <aarvar> that's what Stream is for
17:50:09 <aarvar> lists should just be assumed to be finite
17:50:34 <boxscape> aarvar I can assume that, but I'm not sure how I can convince ghc to assume that
17:51:22 <dyl> aarvar: you can‚Äôt assume [] will be finite though.
17:51:31 <aarvar> dyl: I just did
17:52:03 <aarvar> oh well, better remove reverse from the prelude since it's a partial function then
17:52:10 <dyl> Not from the type anyhow.
17:53:14 <aarvar> dyl: right, you can't enforce it in haskell
17:53:35 <boxscape> would be nice if reverse at least gave you an error message when it encounters an infinite list, but alas, the halting problem...
17:53:38 <aarvar> you can't enforce the absence of bottom, but you can still pretend it doesn't exist
17:57:23 * hackage mapalgebra 0.1.0 - Efficient, polymorphic Map Algebra.  http://hackage.haskell.org/package/mapalgebra-0.1.0 (fosskers)
18:02:24 <EvanR> aarvar: you want [] instead of stream when you sometimes want the stream to end :)
18:02:44 <aarvar> EvanR: but when is that?
18:03:04 <aarvar> "possibly infinite lists" aren't very useful
18:03:31 <EvanR> any sufficiently long list is indistinguishable from infinite!
18:04:17 <EvanR> i think you are complaining about the lack of "definitely finite" list in haskell
18:04:26 <EvanR> not the other two cases
18:04:31 <aarvar> wasn't really complaining
18:04:47 <boxscape> definitely finite lists exist, things like Vec n a
18:04:57 <aarvar> if I'm complaining about anything, it's that people use [] when they should be using Stream
18:05:32 <EvanR> theres something to be said about having something that works quickly without having to import anything and do bureaucracy
18:05:42 <aarvar> boxscape: only if you can enforce that n is finite :)
18:05:45 <EvanR> like list you assume is infinite, or assume is finite
18:05:57 <boxscape> aarvar: erm.. that's a good point
18:06:01 <EvanR> or number you assume is non negative
18:06:16 <davean> "aarvar "possibly infinite lists" aren't very useful" <-- they seem useful for any finite prefix?
18:06:24 <aarvar> EvanR: only reason [] is more convenient is because it's in base
18:06:28 <aarvar> so base/prelude is lacking
18:06:31 <aarvar> as always
18:06:32 <EvanR> right
18:06:48 <EvanR> but i think it always will
18:07:00 <EvanR> based on empirical evidence of every other languages equivalent of a prelude
18:07:26 <EvanR> which calls to attention not just the features your language has, but the ergonomics of getting to them
18:07:30 <EvanR> design wise
18:08:03 <EvanR> having a backpack style subprogram to set up the oneliner is an extreme example
18:08:22 <EvanR> or the paper which spends 95% of the space introducing the programming language
18:10:44 <EvanR> you can have the default environment be permanently stuck in the wrong gear, or have a sophisticated mini language to modify the environment first :(
18:22:45 <boxscape> Is it possible to do something like this? GHC tells me "Duplicate instance declarations" http://lpaste.net/365312
18:23:37 <boxscape> actually, I guess that shouldn't be possible, considering types are removed at runtime
18:23:39 <glguy> boxscape: No, those instances both have identical heads
18:23:47 <boxscape> okay
18:23:53 <glguy> and instances are resolved at compile time, so it's not related to erasing of types
18:24:01 <boxscape> ah
18:24:46 <glguy> It doesn't matter what constraints you put on the left side of the =>, those aren't used during instance resolution
18:25:01 <boxscape> I see
18:27:39 <boxscape> Guess I'll just not make it showable then if there's no SingI instance of dims
18:40:21 <aarvar> boxscape: did you mean to put overlapping instead of overlaps?
18:40:34 <boxscape> maybe, I don't really know how those pragmas work
18:40:50 <aarvar> though it wont do what you want anyway
19:18:48 <iqubic> Is it just me or is this channel oddly quiet?
19:26:47 <Clint> shhhh
19:29:34 * lambdabot sets mode +q iqubic!*@*
19:41:31 * hackage dtab 1.1 - Harmonix (Guitar Hero, Rock Band) DTA/DTB metadata library  http://hackage.haskell.org/package/dtab-1.1 (mtolly)
20:11:51 <pikajude> @djinn (a, f b) -> f (a, b)
20:11:51 <lambdabot> -- f cannot be realized.
20:11:55 <pikajude> oh
20:18:58 <glguy> :t uncurry (fmap . (,))
20:18:59 <lambdabot> Functor f => (a1, f a2) -> f (a1, a2)
20:20:16 <glguy> sequenceA :: Applicative f => (a , f b) -> f (a,b)
20:21:07 <glguy> sequenceAOf _2 :: Functor f => (a,f b) -> f (a,b)
20:58:39 <matsurago> Is there any chart how the version of Base package is connected to the GHC version?
20:59:32 <c_wraith> I wish I knew of one.
21:05:31 <albeit> If I have a function "foo :: ExceptT FooError m ()" that is called from "bar :: ExceptT BarError m ()", is there a clean way to lift(?) the FooError into a BarError?
21:06:40 <c_wraith> albeit: there's mapExcept
21:06:53 <c_wraith> albeit: err, mapExceptT
21:08:20 <albeit> c_wraith: Ah great! I think withExceptT is exactly what I was looking for
21:09:00 <c_wraith> albeit: oh, hah.  yes, that's exactly it
21:11:51 <Guest91> What's the most convenient haskell emacs setup?
21:13:18 <c_wraith> I think my setup is the most convenient, but I expect 100% of non-me people to disagree.  Such is the nature of emacs. :)
21:14:42 <c_wraith> my setup is certainly not the easiest.  So...  yeah, I dunno.  Some people really like spacemacs, and it has a haskell layer iirc
21:16:36 <Guest91> Right, I don't want to try to integrate spacemacs layer into my current setup. Any overall packages to use? I'm currently just using haskell-mode.
21:18:18 <c_wraith> that's what I'm using.  There are a lot more advanced things, but I'm happy with basic syntax highlighting and indentation help.  I'm not a very devout emacs user - I use a terminal for everything else. :)
21:21:51 <Guest91> Haha, I live in emacs. I'll install indiscriminately and hope for the best, thanks.
21:30:53 <Guest91> In case anyone else cares, Intero seems to be the move.
21:31:11 <c_wraith> If you're using stack, yeah.
21:40:06 <glguy> matsurago: This helps: https://www.haskell.org/platform/contents.html
21:40:14 * hackage persistable-types-HDBC-pg 0.0.2.1 - HDBC and Relational-Record instances of PostgreSQL extended types  http://hackage.haskell.org/package/persistable-types-HDBC-pg-0.0.2.1 (KeiHibino)
21:48:05 <matsurago> glguy: wow, thanks!
21:58:12 <jared-w> jle`: I realize this is super late, but I found this page that might be useful: https://www.compart.com/en/unicode/based/U+0030
21:59:17 <jared-w> ùü∂  <-- "mathematical monospace digit zero" U+1D7F6. Now that's the evil shit people use when they hate the future maintainer ;)
22:17:45 <Hafydd> Hahah.
22:18:18 <jle`> jared-w: thank you :)
22:18:23 <jle`> > generalCategory 'ùü∂'
22:18:25 <lambdabot>  DecimalNumber
22:18:30 <jle`> it counts as a number :(
22:18:33 <jared-w> damnit
22:18:55 <jle`> > let ùü∂ = "hi" in ùü∂
22:18:57 <lambdabot>  <hint>:1:5: error: lexical error at character '\120822'
22:19:06 <jared-w> lol
22:19:17 <jared-w> > generalCategory 'ùüé'
22:19:19 <lambdabot>  DecimalNumber
22:19:20 * hackage haskell-import-graph 1.0.4 - create haskell import graph for graphviz  http://hackage.haskell.org/package/haskell-import-graph-1.0.4 (ncaq)
22:19:23 <jle`> i ended up using greek zeta
22:19:28 <jle`> (lowercase)
22:19:33 <jared-w> > generalCategory 'ùüò'
22:19:35 <lambdabot>  DecimalNumber
22:19:37 * jared-w gives up
22:19:48 <jared-w> y u gotta be so correct, Haskell?
22:25:20 <jared-w> Greek zeta will work though :)
22:51:01 <iqubic> :t generalCategory
22:51:02 <lambdabot> Char -> GeneralCategory
22:51:28 <iqubic> Why is that a thing that exists?
22:54:45 <jared-w> ¬Ø\_(„ÉÑ)_/¬Ø
22:55:00 <jared-w> > genrealCategory 'a' -- seems to be vaguely useful I suppose?
22:55:02 <lambdabot>  error:
22:55:02 <lambdabot>      ‚Ä¢ Variable not in scope: genrealCategory :: Char -> t
22:55:02 <lambdabot>      ‚Ä¢ Perhaps you meant ‚ÄògeneralCategory‚Äô (imported from Data.Char)
22:55:16 <jared-w> > generalCategory 'a' -- once more, with spelling‚Ñ¢
22:55:18 <lambdabot>  LowercaseLetter
22:55:29 <rotaerk> > generalCategory 'Ë¶ã'
22:55:30 <lambdabot>  OtherLetter
22:55:44 <spoonm> > generalCategory '¬ß'
22:55:45 <lambdabot>  OtherPunctuation
22:55:56 <iqubic> What is this: ‚Ñ¢?
22:56:00 <spoonm> oddly specific for a generalFucntion
22:56:10 <iqubic> Yeah, I suppose.
22:56:51 <spoonm> > generalCategory 'ÔΩÅ'
22:56:52 <lambdabot>  LowercaseLetter
22:58:25 <iqubic> > generalCategory '¬Ω'
22:58:27 <lambdabot>  OtherNumber
22:58:41 <iqubic> Yeah, that seems oddly specific
22:59:24 <ddellacosta> I have what is kind of more a math question than a Haskell question exactly, but this still seems like an appropriate place to ask so: if you can consider a sum type to also mean 'or', and consider a product type to also mean 'and', is there any formal way to talk about the relationship between those alternate conceptions?
22:59:56 <iqubic> Sure. This sounds like the Howard-Curry correspondence.
23:00:08 <iqubic> Thougt it might be something else.
23:00:51 <iqubic> because you aren't really proving anything, or using propesitions as types.
23:01:34 <iqubic> Actually a better repersentation of this would be an isomorphism.
23:02:10 <ddellacosta> Yeah, that sounds more like what I was getting at. If it is an isomorphism, is there any way we can more precisely characterize that isomorphism's structure?
23:07:34 <jared-w> in an algebraic sense, analytic sense, or category theory sense? Saying an isomorphism exists isn't super interesting; it's what you do with it and how you describe it that tends to be the fun part, but that's often domain specific
23:07:52 <jared-w> (at least, from what I've seen)
23:10:19 <cocreature> ddellacosta: there are proof assistants such as coq which exploit this. you write your theorem as a type and proof the theorem by providing a term of that type
23:21:42 <iqubic> cocreature: That's what I meant when I said it was the Howard Curry Correspondence
23:22:29 <iqubic> That basically says that types and propositions are isomorphic.
23:29:44 <ddellacosta> iqubic: yeah I went and read more about that and the first example in Wikipedia was what I asked about :-p
23:29:58 <ddellacosta> cocreature: thanks! That's very interesting
23:30:02 <edwardk> just as an fyi i'm trying out the twitch stream as a dry run https://www.twitch.tv/ekmett
23:30:13 <jle`> nice :)
23:30:19 <ddellacosta> wow!!
23:31:17 * hackage marihana 0.2.2.0 - Minimal tool to make your blog in Haskell  http://hackage.haskell.org/package/marihana-0.2.2.0 (suzukeno)
23:32:00 <edwardk> there is a discord you can use for live voice chat. unfortunately it'll be about 10-20 seconds ahead of the video on the twitch stream
23:32:24 <edwardk> the link is below the video on my stream
23:32:39 <edwardk> right now i'm working through the creation of an 'abelian' package on the stream
23:34:12 <cocreature> huh I‚Äôm too stupid to find the link
23:34:28 <jle`> it's a hyperlinked image
23:34:41 <edwardk> click the discord image
23:34:46 <cocreature> ah there it is
23:34:46 <edwardk> sorry i'll include the link as well
23:34:48 <cocreature> thanks
23:48:16 <azo> would haskell be a good first introduction to functional programming?
23:49:56 <pavonia> Yes
23:52:35 <azo> thanks
23:57:17 * hackage katip-kafka 0.0.1 - Katip scribe to send logs to Kafka  http://hackage.haskell.org/package/katip-kafka-0.0.1 (AlekseyUymanov)
