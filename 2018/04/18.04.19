00:23:07 <Ariakenom> statusfailed, hm what's that pony slaystation lesns example?
00:23:42 <nshepperd> statusfailed: you want scanl1Of!
00:23:44 <nshepperd> > scanl1Of (traverse . _2) (+) [("a", 1), ("b", 1), ("c", 1)]
00:23:47 <lambdabot>  [("a",1),("b",2),("c",3)]
00:24:33 <Ariakenom> :t scanl10f
00:24:34 <lambdabot> error:
00:24:34 <lambdabot>     • Variable not in scope: scanl10f
00:24:34 <lambdabot>     • Perhaps you meant one of these:
00:24:44 <Ariakenom> :t scanl1of
00:24:45 <lambdabot> error:
00:24:46 <lambdabot>     • Variable not in scope: scanl1of
00:24:46 <lambdabot>     • Perhaps you meant one of these:
00:24:49 <Ariakenom> blargh
00:25:22 <nshepperd> I didn't actually know that was a thing, but I guessed its existence based on the pattern of lots of fooOf functions which are "foo, but with an optic"
00:25:54 <nshepperd> :t scanl1Of
00:25:56 <lambdabot> LensLike (State (Maybe a)) s t a a -> (a -> a -> a) -> s -> t
00:32:09 <nshepperd> > over (partsOf (worded . _head)) reverse "sony playstation"
00:32:11 <lambdabot>  "pony slaystation"
00:33:09 * hackage debian-build 0.10.1.1 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.10.1.1 (KeiHibino)
00:33:41 <liste> > over (partsOf (worded . _head)) (const "p") "sony playstation"
00:33:43 <lambdabot>  "pony playstation"
00:35:33 <Ariakenom> :t over (partsOf _2) (scanl1 (+))
00:35:34 <lambdabot> (Num b, Field2 s t b b) => s -> t
00:35:42 <nshepperd> a pony slaystation sounds like an unfortunate place u.u
00:35:45 <Ariakenom> > over (partsOf _2) (scanl1 (+)) [("a", 1), ("b", 1), ("c", 1)]
00:35:47 <lambdabot>  error:
00:35:47 <lambdabot>      • No instance for (Field2 [([Char], Integer)] () Integer Integer)
00:35:47 <lambdabot>          arising from a use of ‘e_121111’
00:38:13 <nshepperd> you need a traverse in there to access each elemtn of the list
00:38:23 <nshepperd> :t over (partsOf (traverse . _2)) (scanl1 (+))
00:38:24 <lambdabot> (Num b2, Field2 a b1 b2 b2, Traversable t) => t a -> t b1
00:44:58 <Ariakenom> thx
00:52:53 <lemmih> \quit
01:09:04 <angerman> Is there a more idiomatic version of `value ^. key "packages" . _Object <&> (^. key "version" . _String)`? Basically get the `packages` key, and modify each member by extracting the `version`. `{ “packages”: { “x”: { …, “version”: “1234”, … }, “y”: { …, “version”: “1234”, … }, … }` -> `{ “x”: “1234”, “y”: “1234”, … }`
01:09:54 <merijn> angerman: Yes: A where block and storing stuff into intermediate variables :p
01:10:49 <angerman> merijn: let me rephrase: a more idiomatic /lens/ version :D
01:11:53 <quicksilver> 'modify' each member?
01:12:58 <angerman> quicksilver: well with `value ^. key “packages”` I would get `{ “x”: { …, “version”: “1234”, … }, … }`.
01:13:22 <angerman> quicksilver: but I’m only interested in the `”version”` part of each member.
01:13:41 <quicksilver> does it not just all compose?
01:13:56 <quicksilver> key "packages" . _Object . traverse . key "version" . _String
01:14:10 <quicksilver> I feel that I don't quite have your scenario straight in my head
01:14:17 <quicksilver> but it seems like it should all compose...
01:14:59 <angerman> quicksilver: traverse will extract the versions and concatenate them. E.g. in this case: “12341234”.
01:16:01 <angerman> quicksilver: basically turn `{ “packages”: { “x”: { “version”: “1234” }, “y”: { “version”: “1234” } }` -> `{ “x”: “1234”, “y”: “1234” }`
01:24:37 <quicksilver> oh right
01:25:17 <quicksilver> then I think your version is fine.
01:25:49 <quicksilver> I recall thinking in the past that there was a missing piece in my understanding of lens which is: it's an excellent query language, but how are you supposed to build up new structures with the results?
01:26:00 <quicksilver> I mean the answer to the last part is just 'use haskell, duh'
01:26:13 <quicksilver> but it feels like a comparable set of combinators for repackaging the output is potentially useful
01:26:22 <quicksilver> compare xquery and XSL
01:26:37 <quicksilver> I also recall thinking that I probably didn't understand well enough :)
01:27:05 <quicksilver> (see also graphQL, which lets you specify the 'shape' of your output at the same time as you query)
01:27:59 <angerman> quicksilver: Good. So I’m apparently not missing any obvious link :D
01:30:14 <quicksilver> see also hxt, which lets you build XML queries up using a combinator language and then package the result in new XML
01:30:45 <quicksilver> there is a common thread between these 'query and rebuild' tasks that I haven't spent enough time on to find answers to.
01:30:49 <merijn> quicksilver: hxt is notoriously confusing and opaque, though
01:30:59 <quicksilver> it's no worse than lens, IMO
01:31:09 <quicksilver> it just has less of a community of people around to help you
01:31:16 <merijn> ugh
01:31:26 <merijn> ok, so readMaybe isn't exported in 7.4
01:31:26 <quicksilver> I mean it's *much* worse than lens in terms of theoretical elegance.
01:31:35 <merijn> I have no alternative other than using the horrible reads?
01:31:37 <quicksilver> but the theoretical elegance of lens didn't actually help me understand using it in practice.
01:31:50 <quicksilver> it's a one line function. write it.
01:32:11 <quicksilver> I wrote readMaybe in every single project I wrote until it made it into the core library
01:32:20 <merijn> quicksilver: Yeah, but reads always makes me think and it hurts :p
01:33:23 <angerman> merijn: the parser you have may not be the parser you want :p
01:33:50 <quicksilver> if you can't be with the parser you love, you may as well love the parser you're with.
01:34:26 <merijn> quicksilver: I didn't have to love it until all the Travis CI tests for 7.4 started coming back failing because of QoL shit that wasn't exported in 7.4 yet
01:34:44 <merijn> Like, the fixity of <> and . screwing you over
01:38:55 <merijn> Somewhat relatedly, I'm looking for some brave souls using new-build and GHC 8.0-8.4 :p
01:41:10 <angerman> merijn: new-build and 8.4 … pretty much what I use on a daily basis.
01:42:01 <merijn> angerman: I have a PR I've been using for a few days that reduces the amount of rebuilding you get when specifying ghc-options, but it'd be nice if it gets testing outside just my machine :p
01:43:06 <angerman> your options filter stuff?
01:43:14 <merijn> angerman: Yeah
01:43:30 <angerman> merijn: kk. I’ll keep that in mind when I rebuild cabal.
01:47:57 <zebra> someone want to join the Mossad? https://www.r-u-ready.xyz/
01:58:35 <jchia> I'm trying to build a package in my project with "stack build --executable-profiling --library-profiling". While one of the external dependencies, cpython-2.7, is being built, I get an error "module ‘CPython.Types.Code’ cannot be found locally".
01:58:36 <jchia> CPython.Types.Code is from the package cpython-2.7, so the error message makes no sense. What can I do?
01:59:43 <jchia> I think my '~/.stack' directory is corrupted and every time weird things like this happen, I don't have a better fix than to nuke it.
02:03:39 * hackage int-multimap 0.1.0.1 - A data structure that associates each Int key with a set of values  http://hackage.haskell.org/package/int-multimap-0.1.0.1 (OShev)
02:03:54 <dminuoso> For the sake of argument, if I wanted to do unsafeIOToSTM, is there a way to release resources if a transaction is aborted?
02:04:00 <merijn> Hmm, design question: If I have a bunch of IO that relies on being run from within a certain directory, so I explicitly pass this directory everywhere and wrap things with "withCurrentDirectory" OR do I just assume to be in the right directory in every IO action and wrap things in a withCurrentDirectory at the outermost level
02:04:08 <dminuoso> (Im trying to figure out what I could do with this primitive)
02:04:29 <merijn> dminuoso: If the resources are GCed, sure. If you relying on malloc and plain pointers: you're boned
02:05:04 <jchia> merijn: What about just using absolute paths for everything?
02:05:15 <merijn> jchia: Not possible
02:05:45 <merijn> jchia: I'm dealing with external programs that expect to be in the right CWD (think things like cabal and git)
02:05:48 <dminuoso> merijn: Fair enough.
02:06:33 <dminuoso> merijn: Well I was rather thinking in terms of abstract resources with `bracket_`
02:06:46 <dminuoso> But I guess Im still boned.
02:07:03 <merijn> dminuoso: That might work, not sure
02:08:30 <merijn> jchia: Else I would not need to change working dir at all :)
02:08:54 <jophish> merijn: I'm sure you've considered this but just in case: you know you can set the cwd of external programs
02:09:09 * hackage eternity-timestamped 0.4 - Automatic timestamping for Eternity  http://hackage.haskell.org/package/eternity-timestamped-0.4 (OShev)
02:10:15 <merijn> jophish: Sure, but I'm running them a lot of times in the same directory over program lifetime. Hence why I'm considering just saying "screw it" and doing a single change above, but then if you move the lower code out of that dir change it'd break
02:10:56 <dminuoso> merijn: I dont quite understand STM though. It _looks_ like a rebranded IO.
02:11:05 <dminuoso> The source code is very interesting.
02:11:17 <merijn> dminuoso: Have you considered just reading the STM paper? ;)
02:11:47 <dminuoso> merijn: The one from Harris/Marlow/Jones/Herlihy?
02:11:56 <merijn> dminuoso: The one linked in the stm docs
02:12:05 <merijn> I forget by who
02:12:06 <jophish> merijn: if they give sensible error messages then it's probably OK
02:12:36 <dminuoso> merijn: Oh yeah thats the one. No I actually the implementation.
02:12:43 <dminuoso> From a usage point of view STM is rather simple
02:12:51 * dminuoso a verb there
02:13:00 <jophish> you could always make an IO newtype with an existential parameter to make sure they don't escape instead
02:13:25 <dminuoso> Just seeing this made me stare: unsafeIOToSTM :: IO a -> STM a; unsafeIOToSTM (IO m) = STM m
02:13:47 <jophish> dminuoso: it's unsafe for a good reason though :)
02:13:50 <merijn> dminuoso: You might also be interested in the Lazy Functional State Threads paper
02:14:04 <ertes> dminuoso: imagine one massive MVar that holds the value of all of your mutable variables…  then you can think of 'atomically' as one massive 'modifyMVar' on that variable
02:14:08 <merijn> dminuoso: Which shows that ST and IO are just specialisations of an underlying State monad
02:14:51 <Ariakenom> ertes, that doesn't have the right semantics
02:15:01 <Ariakenom> wrt blocking
02:15:27 <ertes> oh, true
02:15:50 <ertes> dminuoso: scratch that…  imagine a brilliant concurrency pattern…  then STM is that pattern
02:16:27 <ertes> well, haskell STM is
02:16:46 <Taneb> :D
02:17:45 <ertes> interestingly the MVar metaphor fits quite well for STM in other languages
02:18:52 <dminuoso> merijn: Ah that's the paper justifying the ST monad, right?
02:23:07 <ertes> atomically (waitSTM async1 <|> waitSTM async2 <|> takeTMVar someVar >>= putTMVar resultVar)
02:23:33 <ertes> put either the value of the thread async1, the thread async2 or the TMVar someVar into resultVar, whichever occurs first…  sleep until one of them occurs
02:24:00 <ertes> this is such a powerful ability, and you pretty much can only do that in haskell
02:24:56 <ertes> i could gush over haskell's STM all day =)
02:25:16 <Ariakenom> Maybe I lied about the god-lock. if retry is drop lock and sleep, is that correct?
02:25:32 <merijn> Ariakenom: STM is optimistic locking
02:26:27 <Ariakenom> Don't care about performance characteristics in this comparison
02:27:54 <dminuoso> ertes: That looks pretty slick.
02:27:54 <Ariakenom> alternative would have to drop lock sleep and then try the alternative
02:28:18 <dminuoso> ertes: You dont seem to be talking about synchronization at all. This is pretty cool :)
02:28:38 <ertes> dminuoso: this is actually basic…  STM is both a Monad and an Applicative, so you can compose as you wish
02:29:08 <ertes> dminuoso: atomically (do (x <- waitSTM async; check (x > 10)) <|> takeTMVar someVar >>= putTMVar resultVar)
02:29:54 <ertes> dminuoso: put either the value in someVar or the result of 'async' into resultVar, but in the latter case only if the value is (> 10)
02:30:04 <ertes> … whichever occurs first
02:30:10 <phz_> hey, with persistent, is there a way to tell it to stop logging to stdout every request it sees?
02:30:14 <dminuoso> ertes: Im guessing check is just some `when (condition) retry` ?
02:30:23 <ertes> dminuoso: yeah, check = guard
02:30:25 <ertes> :t guard
02:30:26 <lambdabot> Alternative f => Bool -> f ()
02:30:39 <ertes> dminuoso: well, s/when/unless/
02:30:48 <dminuoso> ertes: Is `guard = check` for STM?
02:30:50 <dminuoso> Actually
02:30:53 <dminuoso> Let me look myself
02:30:55 <dminuoso> :)
02:30:58 <ertes> do it =)
02:31:01 <Ariakenom> ertes, yes! I could gush over STM all day too, it's a nice argument for purity.
02:31:37 <dminuoso> empty = retry =)
02:31:43 <ertes> Ariakenom: the reason i could is that STM is such a joke in every other language i checked, because non of them have anything corresponding to (Alternative STM)
02:32:26 <ertes> dminuoso: i'm pretty sure 'check' and 'retry' are only there for historical reasons
02:32:28 <dminuoso> ertes: The coolest thing I've noticed so far, is how Haskell automatically tracks accesses. Retry is so cheap since the implementation won't spin if it does not have to..
02:32:42 <Ariakenom> Do tell. For me it's mostly purity controlling the effects and types making sure you don't nest atomically
02:32:51 <ertes> dminuoso: that's right, however that one is not a haskell-exclusive feature
02:32:57 <Ke> 659933
02:33:31 <zincy_> How should I go about getting haskell to call a bash script with args and then access env variables set by the called bash script?
02:33:36 <ertes> Ariakenom: you can nest atomically, except you have to use a different function:  'id' =)
02:33:51 <merijn> dminuoso: Basically, the nice thing about STM is that the more fine-grained your transactions, the faster it becomes :)
02:34:09 <ertes> Ariakenom: STM is a monad, so you can receive an STM action through a TMVar and execute it in the same transaction
02:34:10 <merijn> zincy_: That's not possible
02:34:25 <ertes> join . takeTMVar :: TMVar (STM a) -> STM a
02:34:28 <merijn> zincy_: Environment variables only ever flow from parent process to child process, not the other way around
02:34:42 <Ariakenom> ertes, you can nest STM a yes. But nesting atomically would lead to write effects leaking on retry and stuff.
02:34:44 <merijn> zincy_: Unless you make the bash script write the variables out, then parse and set them in the parent
02:35:06 <ertes> Ariakenom: you're probably talking about a different kind of nesting
02:35:21 <ertes> in my view for all intents and purposes "nesting" is 'join'
02:35:25 <zincy_> merijn - so the haskell process is the parent here?
02:35:49 <Ariakenom> ertes, nesting STM yes. nesting "atomically x :: IO a" no
02:36:07 <merijn> zincy_: Yes
02:36:18 <Ariakenom> like taking the one-true-locl- while holding the lock
02:36:39 <ertes> zincy_: you can wrap the shell script using an outer script that prints the environment variables to a certain FD at the end
02:36:49 <Ariakenom> in the view of atomically as withMVar
02:37:12 <zincy_> ertes - whats FD?
02:37:26 <ertes> zincy_: sh -c 'script.sh; env -0 >&4'  # something like this
02:37:36 <ertes> zincy_: file descriptor
02:37:56 <ertes> err, that won't work
02:38:09 <ertes> zincy_: sh -c 'source script.sh; env -0 >&4'  # more like this
02:38:45 <ertes> of course this can only work, if script.sh is an actual shell script, and it's written in bourne shell syntax
02:38:51 <zincy_> So what does that cmd do?
02:39:14 <fr33domlover> phz_, you can control logging using MonadLogger instance
02:39:27 <fr33domlover> Use NoLoggingT and it won't log anything at all
02:39:46 <merijn> Or just use filterLogging
02:40:14 <ertes> zincy_: this is really unixy stuff, and there are loads of tutorials out there, so i'll keep it to an overview:  the way this works is that you open a pipe in haskell and then fork into the above command, duplicating the write end to FD number 4, then you can read the environment variables through the read end of the pipe, as soon as the program is finished
02:40:50 <merijn> phz_: Use something like this: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Schema.hs#L140-L142
02:40:58 <zincy_> ertes - thanks a lot
02:41:03 <ertes> zincy_: BTW, i can'T help but sensing an XY problem here
02:41:23 <ertes> zincy_: why do you need to observe the environment variables of a shell script?
02:41:45 <merijn> phz_: I filter based on verbosity flags on the commandline so I can toggle persistent's logging on demand
02:42:04 <Boarders> does anyone know how I write a handler for servant in order to serve a folder of assets?
02:42:09 * hackage timestamp 0.2 - Space-efficient Unix timestamp and utilities  http://hackage.haskell.org/package/timestamp-0.2 (OShev)
02:42:26 <zincy_> ertes - yes, yes - So the goal is to call a shell script from haskell and gain access to its output
02:42:49 <ertes> zincy_: its output?  you mean its stdout/stderr output?
02:43:06 <fr33domlover> Boarders, most likely if there's a ready way to do that, it must be in some package like servant-static etc.
02:43:13 <fr33domlover> so look for something like that
02:43:28 <zincy_> ertes - I guess - is reading stdout the best thing to do if the shell script is performing some parsing
02:43:39 <cocreature> Boarders: https://hackage.haskell.org/package/servant-server-0.13.0.1/docs/Servant-Utils-StaticFiles.html
02:43:44 <merijn> zincy_: What are you trying to actually do?
02:44:25 <Boarders> cocreature: thanks!
02:44:51 <zincy_> Run a haskell server that posts transactions to another locally running server and then parse the output of those posted transactions
02:45:21 <merijn> zincy_: Right, so that sounds like nothing relating to environment variables and everything to do with just reading stdout/stderr :p
02:45:26 <ertes> zincy_: a running server?  so you're not executing the other program from haskell?
02:45:31 <merijn> zincy_: Which is, incidentally, much simpler
02:45:56 <zincy_> Both servers are haskell servers
02:46:14 <ertes> zincy_: is one of them run by the other?  or do they run independently?
02:46:15 <chorhizo> Huh, I'd never heard of an XY problem. Good to know
02:46:20 <zincy_> indepedent
02:46:33 <ertes> zincy_: now that's a completely different problem
02:46:40 <merijn> zincy_: Use sockets
02:46:57 <zincy_> The other server doesnt have networking :D
02:47:01 <ertes> zincy_: there are a number of ways to make two haskell processes talk to each other…  a surprisingly easy way in haskell is to do it through an HTTP API
02:47:11 <merijn> zincy_: There's unix sockets that talk over the filesystem
02:47:12 <zincy_> I have time constraints so looking for the most expediant solution
02:47:15 <ertes> zincy_: sockets aren't necessarily networking
02:47:19 <zincy_> oh
02:47:38 <merijn> zincy_: For process on the same machine unix sockets are the way to go (assuming you don't care about supporting windows)
02:47:42 <ertes> zincy_: do you know how HTTP works?
02:47:53 <zincy_> Not really
02:48:11 <ertes> zincy_: you could use raw sockets, but it will involve more coding
02:48:13 <merijn> I don't think I'd recommend HTTP over just a socket + binary or a parser
02:48:44 <dminuoso> unix domain sockets are kind of underused in the world..
02:48:45 <ertes> i'd recommend HTTP, because you can use ready-made libraries that take care of everything, including request parameterisation
02:48:59 <ertes> (note that you can use HTTP over unix sockets)
02:49:10 <phz_> fr33domlover, merijn: oh
02:49:13 <phz_> ok, thanks
02:49:18 <phz_> NoLoggingT
02:49:23 <phz_> from Control.Monad.Logger, I suppose?
02:49:29 <merijn> ertes: Yeah, but many times you can also just do "deriving Binary" and just forward data structures directly
02:49:40 <ertes> merijn: you can do that with HTTP
02:49:48 <ertes> i'm not suggesting any particular data encoding
02:50:02 <merijn> phz_: Personally I'd use LoggingT and use filterLogger like I did to decide logging level at runtime without needing to recompile
02:50:16 <zincy_> Which solution would be easier to implement
02:50:16 <merijn> ertes: At that point what does HTTP add?
02:50:16 <dminuoso> merijn: is deriving Binary save between haskell processes?
02:50:23 <phz_> merijn: yeah that’s a good idea
02:50:33 <dminuoso> merijn: Or rather, is it a stable format?
02:50:35 <merijn> dminuoso: As long as they use the same version of binary and the library for the datatype
02:50:46 <dminuoso> Ah cool :)
02:50:48 <ertes> merijn: scotty and http-conduit
02:50:59 <merijn> dminuoso: Binary is stable across machines/process, but not across library versions
02:51:03 <ertes> merijn: writing a simple HTTP server in haskell is a 4-liner
02:51:10 <ertes> and the corresponding client is a 1-liner
02:51:17 <dminuoso> merijn: Even cross OS?
02:51:22 <merijn> dminuoso: Although you could implement a custom Get/Put instead of using binary and then it'd be stable
02:51:25 <merijn> dminuoso: Yes
02:51:29 <dminuoso> That sounds nifty.
02:51:35 <merijn> dminuoso: At least, it's a bug if it's not :p
02:51:57 <dminuoso> Right. Just like we pretend bottom doesn't exist, we tend to pretend bugs dont exist..
02:52:00 <ertes> merijn: you also get concurrency for free, because it's handled by scotty/warp
02:52:21 <merijn> ertes: But now I'd have to learn scotty/warp
02:52:45 <ertes> merijn: only scotty, and seriously you can learn it just by looking at the example on the hackage page =)
02:53:06 <ertes> learning scotty originally took me like 2 minutes
02:53:38 <zincy_> So when you say http you mean just get the servers to talk to each other locally through http?
02:53:50 <ertes> yeah
02:53:54 <zincy_> I think I said the wrong thing
02:53:57 <zincy_> sorry guys
02:53:59 <zincy_> :/
02:54:16 <zincy_> Its actually a server and a shell script that are communicating
02:54:24 <kuribas> there is also spock...
02:54:39 <zincy_> At least I started a good discussion
02:54:46 <Akii> spock is pretty complicated compared to scotty imo
02:54:54 <ertes> zincy_: the important question is whether the script runs independently or not
02:54:58 <Akii> unnecessarily so
02:55:06 <ertes> kuribas: too complicated for APIs
02:55:25 <kuribas> servant then?  It seems to be tailored for APIs
02:55:26 <zincy_> yes independent
02:55:56 <Profpatsch> So, I have a little Semigroup for interleaving stuffs
02:55:59 <Profpatsch> newtype Sep a = Sep { unSep :: a -> a }
02:56:01 <Profpatsch> instance Semigroup a => Semigroup (Sep a) where
02:56:03 <Profpatsch>   (Sep f) <> (Sep g) = Sep
02:56:05 <Profpatsch>     $ \sep -> f sep <> sep <> g sep
02:56:07 <Profpatsch> http://lpaste.net/365002
02:56:08 <ertes> zincy_: so you have a long-running server-like shell script?
02:57:00 <Profpatsch> But in order to construct Seps (on the lowest level), I need const: ((Sep . const) "foo") :: Sep Text
02:57:09 <Profpatsch> This feels wrong.
02:57:25 <Profpatsch> Maybe there is a better representation I don’t see?
02:57:40 <zincy_> Oh boy its not a shell script
02:57:46 <merijn> Profpatsch: Can't you just use the regular function semigroup + intercalate?
02:57:52 <zincy_> Its a haskell script that talks to a running server instance
02:58:03 <ertes> Profpatsch: the representation is fine, as far as i understand your abstraction, but you can help your coding style a bit by giving it an IsString instance
02:58:08 <merijn> zincy_: You keep changing the question and I think at this point nobody (possible including you) knows what you want
02:58:19 <zincy_> merijn - I know
02:58:30 <ertes> Profpatsch: instance (IsString a) => IsString (Sep a)
02:58:51 <zincy_> merijn - where do you start when you don't know what you are even trying to achieve
02:59:04 <merijn> Profpatsch: as in, your semigroup appears to just be "mconcat . intersperse (const mySep) $ [f,g,h]"
02:59:15 <ertes> zincy_: explain your application
02:59:26 <ertes> zincy_: "application" as in the purpose, not the program
02:59:38 <Profpatsch> merijn: Being able to represent intersperse as fold was my goal.
02:59:43 <Profpatsch> or sconcat
02:59:52 <Profpatsch> mconcat gives a,b,c, in this example
02:59:58 <Profpatsch> while semigroup gives a,b,c
03:00:02 <Profpatsch> (note the trailing comma)
03:00:17 <Profpatsch> ertes: Hm, right.
03:00:22 <zincy_> ertes - auction application that posts transactions to a blockchain
03:00:31 <merijn> > intersperse 0 [1..5]
03:00:33 <lambdabot>  [1,0,2,0,3,0,4,0,5]
03:00:38 <merijn> Profpatsch: Looks right to me
03:00:53 <ertes> Profpatsch: why do you need it to be functions anyway?  you can just reuse (instance (Semigroup b) => Semigroup (a -> b)) if needed
03:01:04 <ertes> Profpatsch: oh, nevermind, i got it =)
03:01:59 <Profpatsch> ertes: My end goal is expressing the nixos module system as a fold/fold1. :)
03:02:15 <Profpatsch> That means all option types have to be some kind of Semigroup
03:02:50 <Profpatsch> e.g. the lines type, which combines all strings given in different configuration files and interleaves '\n'
03:03:04 <ertes> zincy_: so i suppose the "other server" is your interface to the blockchain?
03:04:19 <Profpatsch> ertes: I tried Semigroup a => Semigroup (a -> Sep a) originally, which would have a nicer instantiation, but sadly overlaps with (a -> b)
03:05:00 <Profpatsch> So maybe what I really want is an instance Semigroup (a -> a) => … or something?
03:05:17 <Profpatsch> Haven’t thought about that.
03:05:20 <Taneb> Profpatsch: are you aware of the Endo newtype?
03:05:21 <ertes> Profpatsch: the way you wrote it was fine
03:05:39 <Taneb> Although I guess it's not quite what you're after
03:06:19 <ertes> Profpatsch: couldn't you just render to a sequence first and at the very end apply intercalate?
03:06:30 <Profpatsch> Taneb: Endo encodes the associativity of (.), right?
03:06:49 <Taneb> Profpatsch: yeah
03:07:06 <ertes> Profpatsch: the semigroup has a touch of elegance, but otherwise doesn't really do much…  at worst it might even have a negative effect on performance
03:07:37 <Profpatsch> ertes: I guess what I’m trying to do is remove special-casing.
03:07:49 <zincy_> ertes - correct
03:08:14 <ertes> zincy_: it probably has a well-defined API, and its docs will hopefully tell you how to use it properly
03:08:39 <Profpatsch> But thanks for telling me the idea behind the Semigroup is solid. :)
03:09:01 <Profpatsch> Even though I don’t think a Monoid makes sense in this case.
03:09:12 <ertes> zincy_: this is financial stuff, so be sure to understand what you're doing first…  mistakes can be expensive here
03:12:39 <zincy_> ertes - agreed - just a test net however
03:27:09 * hackage type-natural 0.8.0.1 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.8.0.1 (HiromiIshii)
03:38:23 <Boarders> cocreature: do you know how I incorporate the link you provided: https://hackage.haskell.org/package/servant-server-0.13.0.1/docs/Servant-Utils-StaticFiles.html with other Handlers that I have?
03:39:09 <alp> use 'Raw'
03:39:12 <cocreature> Boarders: it’s just a regular handler like any other so you can combine them with :<|>
03:39:32 <alp> Boarders, see https://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#serving-static-files
03:39:59 <Boarders> ok, I'm probably just confused
03:41:36 <alp> what's going on?
03:42:46 <Boarders> I have a route like: type GetAssetsR = "assets" :> QueryParam "file-name" FilePath :> Raw (I am not super familiar with Servant so could already have gone wrong)
03:43:21 <cocreature> looks reasonable so far :)
03:44:17 <ertes> @let True --> y = y; False --> _ = True; infixr 1 -->
03:44:18 <lambdabot>  Defined.
03:44:21 <ertes> i wish this was predefined
03:45:27 <Boarders> and I want to add it to some existing handlers I have which are of the form: App a, where a is the endpoint return type
03:45:40 <alp> Boarders, hmm do you really want the filename in query param? would you rather want that handler to serve requests that e.g look like: GET /assets/foo.jpg ?
03:45:42 <Boarders> and type App = ReaderT Context Handler
03:46:07 <alp> instead of GET /assets?file-name=foo.jpg
03:47:01 <Boarders> I only went for this as I want it to server everything in this folder including anything someone adds at a later date
03:47:12 <alp> ok then just do this:
03:47:14 <Boarders> and I don't know how to do that otherwise 0_o
03:47:22 <alp> type GetAssetsR = "assets" :> Raw
03:47:59 <alp> serveAssets = serveDirectoryXXX "path/to/assets/on/disk"
03:48:02 <alp> and you're good to go
03:48:13 <alp> serveAssets is the handler for that Raw route
03:50:35 <Boarders> alp: I'm just not sure how I make it uniform with the handlers I have of the form: ServerT MyRoutes (ReaderT Context Handler)
03:51:03 <alp> servant makes sure you can join those
03:51:53 <alp> if you have type API = RouteA :<|> RouteB, serveA :: ServerT RouteA SomeMonad, serveB :: ServerT RouteB SomeMonad, then serveA :<|> serveB makes sense, and moreover it has type ServerT MyRoutes SomeMonad
03:52:18 <alp> in your case, RouteB would be "assets" :> Raw, serveB would be the call to one of the serveDirectory functions that cocreature linked you to
03:53:37 <alp> err, type MyRoutes = RouteA :<|> RouteB   , not API, sorry.
04:07:24 <Boarders> alp: this is the kind of thing I am getting: http://lpaste.net/365004
04:08:17 <Boarders> any ideas?
04:10:05 <alp> Boarders, what if you leave out all the 'lift's?
04:10:15 <alp> and put "Tagged" instead?
04:10:27 <alp> don't remember if it's required
04:10:27 <alp> hang on
04:11:57 <alp> Boarders, alright, so let me explain what's going on
04:13:11 <michalrus> Hmm, in Tasty or HUnit, how can I print something and have it displayed under a proper test name? Something like `info "We got this far"` or something.
04:13:27 <alp> serveDirectoryWebApp and friends are all meant to be used when the monad is servant's 'Handler'. so you can do one of two things: use 'hoistServer' just on your other handlers to "bring them back to Handler" and stick ":<|> serveDirectoryWebApp ..." next to that
04:14:51 <alp> or replace the call to serveDirectoryWebbApp "..." by: Tagged (staticApp some_settings)
04:15:09 <alp> this is basically just a wai Application, wrapped in "Tagged" to carry the monad in which other stuffs run around
04:15:37 <alp> so that we can "pretend" static file servers and what not run in that monad as well
04:15:43 <Boarders> alp: I see, thanks. There is a hoist server elsewhere so I'll try splitting off where I am combining the servers
04:16:16 <alp> right, either combine "Raw" at the last time, or put together a Tagged SomeMonad Application that serves your files yourself, by looking at how the existing ones are defined: https://hackage.haskell.org/package/servant-server-0.13.0.1/docs/src/Servant-Utils-StaticFiles.html#serveDirectoryWebApp
04:16:32 <alp> we should in fact maybe have more polymorphic definitions in there
04:16:44 <alp> maybe, maybe not, not sure.
04:21:10 <Boarders> thanks a lot for your help btw alp, I appreciate it!
04:21:24 <alp> no worries
04:21:46 <alp> note that there's a #servant channel, where your questions are less likely to get lost, if you want.
04:22:13 <Boarders> cool;
04:31:39 * hackage expiring-containers 0.1.0.2 - Expiring containers  http://hackage.haskell.org/package/expiring-containers-0.1.0.2 (OShev)
04:50:25 <chorhizo> Hey, I've started developing this and was wondering if anyone had some advise on the style of haskell. I know there's too much in that one function, but apart from that are there any truly terrible things I'm doing? https://github.com/PotterJam/HaskSCP/blob/master/app/Main.hs
04:55:55 <lyxia> it looks okay
04:57:00 <tht> chorhizo: I consider everyone has his own style
04:57:52 <reactormonk> Is there a way to figure out why an instance hasn't been picked? I'm doing some hlist-related things and I don't know why a certain instance could not be picked.
04:58:00 <jophish> hexagoxel: How is iridium these days
04:58:08 <jophish> I've had some trouble building it
04:58:08 <tht> chorhizo: Just think `findFileToRequest` function is in a littel mess
04:59:23 <tht> chorhizo: well it's also easy to be understood..
05:02:04 <adjofun> chorhizo: you are relying on lazy io for interactiveness, that can blow up in your face. You already using Text, use it for interactions too.
05:03:24 <tht> chorhizo: and u can also use less `putStrLn`
05:17:31 <beefjoe> How can I write this in Haskell
05:17:31 <beefjoe> https://screenshotscdn.firefoxusercontent.com/images/c3bc13f2-b3a2-4e68-859f-0647316261ad.png
05:18:38 <shiona> > sqrt(3**2 + 4**2)
05:18:40 <lambdabot>  5.0
05:19:16 <shiona> :t (**)
05:19:17 <lambdabot> Floating a => a -> a -> a
05:19:28 <tht> :t (^)
05:19:29 <lambdabot> (Num a, Integral b) => a -> b -> a
05:19:49 <shiona> sqrt(3^2 + 4^2)
05:19:52 <shiona> > sqrt(3^2 + 4^2)
05:19:54 <lambdabot>  5.0
05:20:02 <liste> > √(3^2 + 4^2)
05:20:04 <lambdabot>  <hint>:1:1: error: parse error on input ‘√’
05:20:16 <liste> :(
05:20:32 <liste> why doesn't it parse
05:20:49 <liste> > let (√) = sqrt in √(3^2 + 4^2)
05:20:49 <tht> liste: just no this func
05:20:51 <lambdabot>  <hint>:1:19: error: parse error on input ‘√’
05:22:31 <beefjoe> hmm
05:23:14 <Boomerang> > let (√) = sqrt in (√) (3^2 + 4^2)
05:23:16 <lambdabot>  5.0
05:23:31 <liste> is it about fixity?
05:24:57 <Boomerang> I guess, I'm kind of surprise you can define an infix function `√` that only takes 1 argument
05:26:00 <tht> i think infix operator can have a fixity
05:26:53 <beefjoe> so would this
05:26:54 <beefjoe> https://screenshotscdn.firefoxusercontent.com/images/8aee01c0-665e-41c6-87ce-cc492a68ab9b.png
05:27:00 <beefjoe> pi * (3/2(a+b) - sqrt(a*b))
05:27:02 <beefjoe> ?
05:28:12 <cocreature> beefjoe: you’re missing a * between 3/2 and (a+b)
05:28:24 <beefjoe> oh right
05:28:25 <beefjoe> thanks
05:28:44 <lyxia> reactormonk: the only way now is to replay it by hand after understanding the rules explained in the manual https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overlapping-instances
05:32:57 <chorhizo> tht: adjofun: thanks, what do you mean I can use less putStrLn? And how am I using lazy io for interactiveness? I'm not really sure what I'm doing..
05:35:53 <reactormonk> lyxia: not even using using overlapping instances here - posted it on SO: https://stackoverflow.com/questions/49920911/why-is-an-instance-not-picked
05:37:07 <adjofun> chorhizo: by using `putStrLn` and `getLine` from Prelude you are using String-based lazy IO. Because it is lazy, it can mess up your interactivity with your program. Just replace them with their counterparts from strict Text, and never ever use lazy IO, or at least use it with understanding and caution.
05:38:00 <adjofun> i.e don't use lazy IO for interactive input
05:38:25 <chorhizo> adjofun: ah great. The lazy io is because the functions the library provides produces lazy byte strings
05:38:37 <donjoe2> can someone explain me how to guess the type of "g f = f (g f)"
05:38:48 <chorhizo> Maybe there is a way to convert this to non lazy? Then I can remove that
05:38:49 <donjoe2> I cannot reason it out
05:39:09 <lyxia> reactormonk: The overlapping instance section is just where the rules happen to be documented, but they are still useful outside of that context.
05:39:15 <Taneb> donjoe2: how many arguments (at least) does f take?
05:39:30 <Taneb> i.e. what is the most it has been given there?
05:39:42 <donjoe2> that's all the info I have
05:39:56 <donjoe2> doesnt matter what F or G is
05:40:04 <Taneb> donjoe2: you can work this out from what you have
05:40:14 <adjofun> chorhizo: toStrict =)
05:40:53 <lamba_> hello! Does anyone know if there's a way to conditionally have code available if a package exists? I mean for example the linear package doesn't have a Random instance for Vec because they don't want to add the random package as a dependency. Is there a way to tell ghc expose this piece of code if this package exists?
05:41:16 <lamba_> so that you don't force the user to pull the random dependency. But if it exists you get these extra goods
05:42:40 <adjofun> donjoe: define this in ghci, then type ":t g" =:)
05:42:47 <lemmih> lamba_: You can do this with flags in the cabal file.
05:42:57 <chorhizo> adjofun: thanks for your help
05:43:15 <adjofun> chorhizo: you are welcome =)
05:43:15 <cocreature> the problem with using flags for this is that you can’t depend on a package being built with a specific flag
05:43:44 <lamba_> oh so like with profiling?
05:44:35 <lamba_> is there documentation somewhere I can find?
05:44:38 <tht> g :: (t -> t) -> t
05:45:15 <lamba_> why isn't this more widely used
05:45:26 <lamba_> for example why doesn't the linear library do this
05:45:42 <lamba_> if their only reason is not having random as a dependency
05:46:01 <lemmih> lamba_: It's generally a bad thing to do for the reason cocreature said.
05:46:02 <cocreature> because it doesn’t work properly for a lot of use cases as I’ve just explained :)
05:46:49 <lamba_> alright sorry I just didn't realize that was a large issue
05:47:03 <lyxia> reactormonk: HasRecipeCase False target ((Recipe effect target deps)  doesn't match  HasRecipe False M4 (Recipe _ M1 _ ': _)
05:48:06 <cocreature> lamba_: let’s say I write a library that only works with linear build with the random flag. there is no way to express this in my cabal file so every user of my lib will manually have to tell cabal to build linear with that flag
05:48:21 <donjoe2> adjofun: I want to reason it out.
05:48:47 <lamba_> oh no I meant it automatically detects that you have random as a dependency
05:48:52 <lamba_> the user using the library
05:48:54 <cocreature> that’s not possible
05:49:22 <cocreature> as in: it’s not possible today, I haven’t thought about the problems you would run into if you try to implement it
05:50:04 <lamba_> there's the problem of being unintuitive
05:50:50 <lamba_> hmmm actually im not sure
05:51:02 <lyxia> reactormonk: btw have you considered defining HEq as a closed type family
05:51:27 <lamba_> if you're going to use random it must be one of your packages
05:51:44 <adjofun> donjoe2: should `g` and `f` have same types to typecheck? *hinting*
05:51:51 <lamba_> for example but that's 1 case there's probably others that would cause problems
05:52:02 <Taneb> adjofun: I'm working it through with donjoe2 in private messages
05:52:13 <lamba_> overlapping instances when you get an unrelated package for example
05:52:57 <Taneb> lamba_: I believe Rust's cargo tool can do something a bit like this
05:53:50 <lamba_> it's almost like having lazy dependencies
05:54:56 <hc> Hi all, I would like to limit the memory per request to a few kilobytes in servant. Any ideas how to do that? :-)
05:54:59 <hc> The idea is to make memory exhaustion attacks a little less easy
05:55:43 <cocreature> hc: you can limit memory allocation but not memory residency afaik
05:56:05 <hc> cocreature: all I need is to say something like: if the http body for a JSON request is >8k, drop it
05:56:16 <hc> I did that with a manual WAI application
05:56:24 <hc> s/manual/manually written low level/
05:56:29 <alp> you'll want to read about warp's settings and GHC's RTS options, I guess.
05:56:35 <phadej> so you can it with servant, if you can extract the "fence" as wai middleware
05:56:40 <hc> yeah, maybe, but it really is *per request*
05:56:48 <cocreature> oh I thought you want to limit the memory of the thread that processes the request
05:56:51 <hc> oh, use a middleware
05:56:52 <liste> hc: use WAI middleware for that?
05:56:52 <hc> interesting.
05:57:00 <hc> thank you, that
05:57:04 <hc> 's a good idea (-:
05:57:50 <hc> Which middleware would you recommend? Is there a readily available module for this?
06:15:30 <tht> WAI?
06:15:39 * hackage constraints-emerge 0.1.2 - Defer instance lookups until runtime  http://hackage.haskell.org/package/constraints-emerge-0.1.2 (isovector)
06:16:44 <liste> tht: Web Application Interface
06:17:00 <liste> tht: that web apps rely on and web servers fulfill
06:17:04 <ibrahims> hello people, i have a silly question. i thought comparing Proxy data would give some indication as to what is the return type of a function like a singleton but it does not seem to be the case. To elaborate, (natVal p1 > natVal p2) does not seem to be evidence of anything about the types of the expression that follows. any directions?
06:17:19 <tht> liste: thanks~
06:18:53 <reactormonk> lyxia: no, I haven't... I'll have to look that up. I copypastad the source from the HList package.
06:18:57 <zukonake> Hey guys, how do I access constants from C using FFI? If I simply define it as for example something :: Word8 then it segfaults, but if I turn the actual C constant into a function that returns the value, then it's working. So how do I do it to make it work with consts?
06:19:35 <lemmih> zukonake: Can you show us the code?
06:20:29 <cocreature> zukonake: you probably need to use Ptr Word8 instead of Word8
06:20:59 <zukonake> Hmm, I'll try
06:21:32 <lemmih> zukonake: Actually, for constants, you might have to use hsc2hs.
06:22:03 <cocreature> depends on your meaning of “constant” I suppose :)
06:22:52 <zukonake> but then hsc2hs just generates haskell code doesn't it? So it should be possible without any additional stuff like that. Also I tried to but it defined my module as Main and I couldn't get it to work, anyway I'm gonna try using the Ptr
06:23:32 <lemmih> zukonake: No, it generates a C program which then generates a Haskell program with the values of your constants in it.
06:23:54 <cocreature> if it’s a constant as in a global variable, then a Ptr should work
06:24:10 <cocreature> if it’s some kind of #define then you’re going to have to use hsc2hs
06:24:35 <reactormonk> lyxia: ah, beautiful. Found the mismatch, thanks for the help!
06:25:35 <zukonake> Wait, is there no way to unwrap the value from Ptr without having it as IO?
06:25:52 <cocreature> you can always unwrapPerformIO your way to glory :)
06:26:15 <cocreature> eh *unsafePerformIO
06:26:27 <cocreature> the FFI is one of the very few places where unsafePerformIO can actually be reasonable
06:26:36 <zukonake> I tried and it still segfaults
06:26:53 <cocreature> can you show us the code?
06:27:10 <lemmih> zukonake: You need to import the address of the constant.
06:27:34 <merijn> zukonake: I recommend making sure that 1) you've read the FFI chapter (chapter 8) of the report, 2) reading the GHC manual section on FFI and 3) Have a look at the CApiFFI extension
06:27:39 <merijn> lemmih: Not with CApiFFI
06:27:56 <merijn> lemmih: That lets you import constants and CPP values
06:30:50 <cocreature> oh neat, apparently I always missed the CApiFFI extension when browsing the report
06:30:54 <NinjaTrappeur> Hi! I am trying to list all the exported symbols from a hackage library. I wonder if anybody here already done that, I have some ideas but I have trouble to evaluate their complexity (I never digged in GHC)...
06:31:03 <NinjaTrappeur> I found 3 ways to do that so far: parsing both hackage .cabal file and source tarball, using cabal install to get the package and using GHC's package DB to get the exported modules then parse again the tarball to get the symbols for each module, using cabal install to get the library and GHC's internal API to get the exported symbols for each module.
06:31:21 <NinjaTrappeur> So far, I am privileging the first solution. Do you have any suggestions of a better solution, any remarks on the solutions listed?
06:31:44 <merijn> cocreature: CApiFFI isn't in the report, only in the GHC manual
06:31:59 <merijn> cocreature: Which is why you should skim the GHC manual every 2 or so releases to catch anything you missed ;)
06:32:00 <cocreature> merijn: eh yeah, dunno why I wrote report :)
06:32:22 <merijn> GHC manual is the most tragically underutilised document out there when it comes to Haskell :p
06:32:23 <cocreature> it’s kind of annoying thet half of the ffi docs are in the report and half are in the user guide
06:32:56 <merijn> NinjaTrappeur: Have you looked into how Haddock does this?
06:33:20 <merijn> NinjaTrappeur: Also, Hoogle
06:33:57 <NinjaTrappeur> merijn, not yet, sounds like a good idea.
06:34:12 <dmwit> NinjaTrappeur: If you're willing to install it (as it sounds from "using GHC's package DB to get the exported modules") you can ask ghci what symbols a module exports with `:browse`.
06:34:15 <merijn> NinjaTrappeur: Because seems to me that both do something like that
06:34:28 <merijn> NinjaTrappeur: Maybe you can even piggy-back on hoogle's database generation?
06:34:32 <reactormonk> I'm getting a warning on no explicit associated type, but things still compile - can this blow up at runtime?
06:34:37 <merijn> NinjaTrappeur: Not sure what you're trying to do?
06:34:50 <reactormonk> ... because I don't know how to write it.
06:34:51 <dmwit> reactormonk: No, but it can blow up at compile time.
06:34:56 <zukonake> here is my code cocreature https://pastebin.com/RiWuCd3F it segfaults at "something"
06:35:31 <NinjaTrappeur> dmwit, great idea, thanks!
06:35:50 <cocreature> zukonake: you need to use "&value" instead of "value"
06:35:57 <dmwit> reactormonk: But I'm a bit surprised: I would expect if you did not fill out an associated type, there would be some method in the class which could not typecheck.
06:36:19 <dmwit> reactormonk: (Or, if none of the class's methods mention the associated type, why is it there at all?)
06:36:42 <zukonake> Ohh I see, I think it indeed works now, thanks
06:36:50 <NinjaTrappeur> merijn, I am trying to create an "example database". Basically, I want to parse hoogle libraries and find places on hoogle where they are used. A kind of example-oriented documentation. (I am only working on the stackage subset to start)
06:38:05 <merijn> NinjaTrappeur: Hoogle is available as a library, so probably you wanna build on top of that
06:38:08 <merijn> @hackage hoogle
06:38:08 <lambdabot> http://hackage.haskell.org/package/hoogle
06:38:09 <dmwit> NinjaTrappeur: What will you do about conflicting symbols? e.g. Data.Map and Data.Set both export `insert`; you're going to have to do, like, actual Haskell parsing and name resolution to know which is which...
06:38:53 <merijn> hmm, the library seems a bit scarce
06:39:24 <cocreature> merijn: does it still only expose an interface where you pass cli args?
06:39:41 <merijn> cocreature: Looks like it
06:40:35 <NinjaTrappeur> dmwit, yes that's why I am looking for a potential shortcut here. If there isn't any, then yes, I'll probably have to parse the haskell code with haskell-src, but i would prefer not doing that...
06:41:38 <NinjaTrappeur> merijn, thanks, you're right, I should dig in both hoogle and haddock. Thanks for the advice
06:46:27 <reactormonk> dmwit: https://gist.github.com/d895d46335c09c744ca318b99b075602 the instance on line 102
06:46:58 <reactormonk> It's not all typed out yet (SubSelect), so that's maybe why it doesn't blow up in my face yet.
06:57:49 <dmwit> NinjaTrappeur: No, you misunderstood my objection.
06:59:39 <dmwit> NinjaTrappeur: Even after you know all the symbols each module exports, you *still* have to parse and name-resolve to build your example database.
07:00:10 <dmwit> NinjaTrappeur: Because when you take a chunk of code, and want to mark it as an example for (say) `Data.Map.insert` because it mentions `insert` in the chunk, you need to know whether that `insert` is actually `Data.Map.insert` or not.
07:03:04 <NinjaTrappeur> dmwit, yes, I actually plan to proceed in several pass. First I'll generated the general symbol table for each library containing the exported modules and symbols. Then, for each library AND application source file (referrenced by stackage), I'll have to parse the file and generate another database indexing the positions (file, line, col) of every symbol referrenced by the symbol table generated during the
07:03:06 <NinjaTrappeur> first pass.
07:03:42 <NinjaTrappeur> sorry for the broken english, I did not proof read my message, that was a mistake.
07:04:47 <NinjaTrappeur> (I'll be happy if I manage to implement the first pass by the end of the month, I have not though about the practical details of the second pass yet...)
07:12:38 <dmwit> reactormonk: Right. I expect when you attempt to implement `recipe` you will find that writing a function which takes an `HList (RDeps blah blah)` and does anything interesting with it will be very difficult before you say what `RDeps` does to `blah blah`.
07:13:47 <dmwit> reactormonk: I also suspect that, unless you're trying to learn how to do type-level programming, you are making a very big mistake. =P
07:16:23 <sclv> NinjaTrappeur: the generated hoogle input file for each package from haddock lists all exported modules and symbols. you can just get it from package/docs/package.txt on hackage like so: http://hackage.haskell.org/package/comonad-5.0.3/docs/comonad.txt
07:17:45 <dmwit> oh neat
07:23:00 <reactormonk> dmwit: mistake as in? Doing typelevel programming in the first place?
07:23:26 <c_wraith> "mistake" as in trying to do something at the type level that's way easier at the value level
07:24:44 <reactormonk> c_wraith: can't have arbitrary hlists at value level though :-(
07:47:06 <c_wraith> reactormonk: from what I can tell from your SO question, you're trying to build a crafting system in the type system using instance resolution to do the job of determining whether the current ingredients can make a target item. Even if you get it all working properly, that will only work in cases where the target and your current ingredients are known at compile-time.  That doesn't sound all that useful.
07:51:03 * hackage language-ats 1.2.0.8 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.2.0.8 (vmchale)
07:52:09 <zfnmxt> I'm getting a non-exhaustive pattern match for f. How is that even possible? http://lpaste.net/365013
07:52:18 <zfnmxt> The "f xs" should match everything...
07:53:08 <c_wraith> zfnmxt: the second "let" means you're shadowing the previous definition
07:53:34 <c_wraith> zfnmxt: only use one let if you're defining multiple equations for a single binding
07:54:03 <zfnmxt> Oh :)
08:03:45 <lyxia> reactormonk: was the mistake that the two 'target' were not supposed to be equal?
08:04:16 <reactormonk> lyxia: yeah.
08:18:31 <Putonlalla> > not⠀False
08:18:33 <lambdabot>  True
08:18:35 <Putonlalla> > not⠀True
08:18:37 <lambdabot>  True
08:18:44 <Putonlalla> Nice job, lambdabot.
08:19:18 <c_wraith> the joke is ruined by the fact that my irc client doesn't have a glyph for that unicode character
08:21:03 <NinjaTrappeur> sclv, wow, that's amazing, thanks! The parser is even already implemented in hoogle's Input.Haddock module. That's just perfect!
08:21:22 <Putonlalla> You need Braille in your life, c_wraith.
08:31:09 * hackage cli-setup 0.2.0.4 - Helper setup scripts for packaging command-line tools.  http://hackage.haskell.org/package/cli-setup-0.2.0.4 (vmchale)
08:31:09 <iqubic> c_wraith: I don't see it either.
08:34:08 <iqubic> Putonlalla: What font are you using to get Braille?
08:34:15 <Putonlalla> Noto Sans, iqubic.
08:34:34 <Putonlalla> It's supposed to be the blank pattern, which is apparently not a space.
08:34:47 <glguy> If things are working you won't see it, the glyph should be blank
08:44:29 <iqubic> ⠀⠀⠀
08:44:40 <iqubic> So that message is blank?
08:45:10 <iqubic> That's the Braille character.
09:01:24 <dminuoso> Given some type `T :: * -> * -> *`, if there is an `instance Functor (T x)`, does that necessarily imply the existence of some Bifunctor or Profunctor for T?
09:02:42 <glguy> no
09:03:02 <Putonlalla> Bifunctors are counterexamples to that, dminuoso.
09:03:04 <glguy> Just as given some T :: * -> *, that doesn't imply either a Functor or Contravariant instance for T
09:03:10 * hackage foldl 1.4.0 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.4.0 (GabrielGonzalez)
09:03:32 <Putonlalla> (Often.)
09:03:57 <glguy> dminuoso: Consider: data T a = MkT (a -> a)
09:04:41 <dminuoso> glguy: Ah. So basically every type parameter must be exclusively either in positive or negative position.
09:04:54 <glguy> Yeah
09:06:40 <Putonlalla> There's also one case where both can coexist, dminuoso.
09:09:39 * hackage xml-isogen 0.3.0 - Generate XML-isomorphic types  http://hackage.haskell.org/package/xml-isogen-0.3.0 (typeable)
09:26:42 <rotcev> hi everyone, I assume I'm having some bad thought process, but I would like to clean up one of my large ADTs by breaking it down into a smaller one. I notice that FieldRef, MethodRef, and InterfaceMethodRef all have very similar properties and I was wondering if there is a nice way to 'abstract' these types into another ADT. here is my code http://lpaste.net/3359272962208301056
09:26:47 <rotcev> perhaps I am thinking about this the wrong way
09:28:02 <rotcev> i would still like to be able to reference these types through the type Constant, but i am not sure if that is exactly possible... Obviously it is possible to just create a new data type and replace those three records, but it doesn't achieve the functionality i'm looking for
09:29:58 <lyxia> rotcev: http://lpaste.net/6170785925996478464
09:32:14 <rotcev> lyxia: i kind of see now... thanks a lot
09:32:35 <lyxia> yw
09:35:21 <woodson> anyone knows how to append values to a JSVal type of ghcjs??
09:37:09 * hackage fmt 0.6 - A new formatting library  http://hackage.haskell.org/package/fmt-0.6 (Artyom)
09:37:32 <shapr> oh YEAH?
09:41:42 * hackage shake-ext 2.11.0.1, ats-pkg 2.10.0.8, shake-ats 1.8.0.1 (vmchale)
09:42:42 * hackage hs2ats 0.3.0.1, dependency 0.1.0.11 (vmchale): https://qbin.io/feed-lime
09:45:14 <lyxia> hackage: good bot
09:48:02 <toblorone> does anyone use vs-code for haskell work? I can't seem to get the intellisense to work.
09:51:06 <zipper> Say you have two arrays X and Y and you want to check whether any of X is in Y. Is there a name for these two? Like is any element in set X in set Y. Is there a name for these two sets?
09:51:36 <lyxia> nonempty intersection?
09:52:02 <zipper> Well I'm looking for better varnames for the two than X and Y
09:52:04 <marble_visions> stack ghci ---- Prelude> :t 4 >>>> 4 :: Num p => p
09:52:09 <zipper> *variable names
09:52:25 <lyxia> intersecter and intersectee
09:52:36 <marble_visions> systemwide ghci ----- Prelude> :t 4 >>>>> 4 :: Num a => a
09:53:00 <rotcev> is there a way to have different types for a field in a two different record constructors under the same data type declaration? or am I stuck with having to use different names
09:53:01 <lyxia> Just kidding. I can't think of good names.
09:53:04 <marble_visions> any interesting story as to why one says Num p and the other Num a?
09:53:11 <rkennedy> How can I determine if 'readTQueue' is single wake up, the way 'takeMVar' claims to be
09:53:23 <glguy> marble_visions: No, the names don't matter
09:54:14 <lyxia> rotcev: you can already do that
09:54:15 <zipper> Also I'm checking whether any of
09:54:17 <zipper> not all of
09:54:20 <zipper> like a subset
09:54:22 <marble_visions> glguy: i know, but why have changed it in stack's release
09:54:31 <marble_visions> have they*
09:54:35 <glguy> marble_visions: stack doesn't have anything to do iwth it
09:55:33 <zipper> lyxia: LOL I wonder if they'll catch these names in code review
09:55:34 <toblorone> rotcev: with standard haskell i think you're stuck. there are some libraries and proposals that address this issue though, like: http://nikita-volkov.github.io/record/
09:55:39 <zipper> I've literally decided to go with them
09:55:47 <rotcev> lyxia: if i do http://lpaste.net/5816180322093498368 the compiler complains with http://lpaste.net/8935592997341364224
09:56:05 <rotcev> toblorone: thanks i will read that
09:58:23 <glguy> rotcev: The record fields can't have different types, they need to match so that the resulting record accessor function can have a type
09:59:00 <rotcev> glguy: i had figured something like that :) just wanted to know if there were any weird things i could do to get around that
10:04:05 * Taneb has flights for Zurihac!
10:07:57 <Caliban> @pl \a b -> liftA2 (&&) (a<=) (<=b)
10:07:57 <lambdabot> (. flip (<=)) . liftA2 (&&) . (<=)
10:10:26 <glguy> even better: \a b c -> a <= c && c <= b
10:13:38 <cocreature> Taneb: looking forward to meeting you there! :)
10:15:09 * hackage vulkan 2.0.0.0 - Bindings to the Vulkan graphics API.  http://hackage.haskell.org/package/vulkan-2.0.0.0 (jophish)
10:16:00 <Boomerang> Taneb: :D
10:23:17 <kudomarkos> Hello Everybody
10:23:54 <cocreature> hey kudomarkos
10:25:01 <kudomarkos> cocreature :D
10:25:14 <kudomarkos> I try to do a short version of this
10:25:18 <kudomarkos> can you help me?
10:25:45 <cocreature> just ask your question and stick around for a bit
10:25:52 <kudomarkos> https://pastebin.com/EKC2phBB
10:26:16 <kudomarkos> the question is... how can i do that: min list or []
10:26:26 <kudomarkos> because min [] gives error
10:26:55 <dminuoso> :t []
10:26:57 <lambdabot> [a]
10:27:11 <dminuoso> kudomarkos: ^- The problem is that there is only instance Ord a => Ord [a]
10:27:37 <glguy> let xs = [min [(a,b) | (a,b)<-[(5,2),(4,2),(2,2),(1,2)], b==2, a<4 ]] in if null xs then Nothing else Just (min xs)
10:27:49 <cocreature> kudomarkos: you probably want "minimum" rather than "min"
10:28:09 <kudomarkos> yes minimum, sorry
10:28:18 <cocreature> kudomarkos: but "minimum []" will also give you an error. what should be the minimum of an empty list?
10:28:37 <dminuoso> bottom is quite minimal!
10:28:44 <kudomarkos> xD
10:29:00 <kudomarkos> I know, it is for that i Reapeat the list in the if...
10:29:20 <kudomarkos> but it was an example, the real list is longer.... and i don't want to Repeat it
10:29:37 <cocreature> kudomarkos: so what’s the error you’re getting?
10:29:43 <dminuoso> Okay pretty cool. So Yoneda lemma can be used to show that continuation passing style is equivalent to non-continuation passing style..
10:29:55 <dminuoso> This thing is awesome. :)
10:30:10 <kudomarkos> cocreature: no, i don't have error, it is only it looks very long
10:30:32 <cocreature> you can use a "let" to avoid the repetition, e.g., let xs = [1,2,3] in if null xs then [] else [minimum xs]
10:30:49 <kudomarkos> ah, ok, cocreature
10:31:03 <kudomarkos> that's the answer i was asking THANKS :D
10:37:39 * hackage bv-sized 0.4.0 - a BitVector datatype that is parameterized by the vector width  http://hackage.haskell.org/package/bv-sized-0.4.0 (benselfridge)
10:41:25 <chorhizo> I've asked this before, but the library I'm using to do file transfer (scp) isn't giving me status metrics, is there a way to fake this and show the current network device download usage, so I can at least show how its doing?
10:46:39 * hackage snaplet-persistent 0.6.0 - persistent snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-persistent-0.6.0 (MichaelXavier)
10:47:48 <dminuoso> chorhizo: doesnt curl have that?
10:59:25 <NinjaTrappeur> chorhizo, rsync has this kind of informations. If you can't use it, you still can access to the total download count at /sys/class/net/$IF/statistics/rx_bytes
11:26:29 <ph88> Taneb, are you here ?
11:26:37 <Taneb> ph88: I am!
11:26:42 <ph88> cool
11:27:45 <ph88> Taneb, the technique you found doesn't work all the time  see here https://bpaste.net/show/f60d5e40ed1f
11:28:06 <ph88> Taneb, the function you advised me i put it on line 7
11:29:32 <ph88> the thing i'm searching for is :: T  .. if it's wrapped in some other data constructor such as   File (T ...)  (line 18, line 25) it works.  But on itself it doesn't work (line 15, line 28)
11:29:54 <ph88> i mean   File (Ter)    (Ter is data constructor of type T)
11:33:36 <Taneb> ph88: hmm, yeah
11:34:54 <Taneb> ph88: the issue is template doesn't look at the top-level
11:36:17 <ph88> is there another function that checks on the top-level too ?
11:36:52 <Taneb> There's "biplate" but it has a less general type
11:37:05 <Taneb> Oh no, it's just as general
11:37:21 <Taneb> > "hello" ^.. biplate :: [String]
11:37:23 <lambdabot>  ["hello"]
11:37:27 <Taneb> > "hello" ^.. template :: [String]
11:37:29 <lambdabot>  ["ello"]
11:37:46 <ph88> ok let me try biplate see what that does
11:38:28 <ph88> oh biplate works, great
11:38:39 <ph88> thanks Taneb
11:38:54 <Taneb> :)
12:19:17 <statusfailed> nshepperd_: nice, thanks! (for the scanl1Of tip!)
12:28:01 <ph88> hey guys, when i putStr this in ghci https://pastebin.com/P6uLsC2a i only see this https://pastebin.com/6KttN2q4 ... where is the rest ?
12:28:35 <ph88> maybe it's messed up because of some control characters in between ?
12:30:55 <kudomarkos> hello again
12:31:07 <kudomarkos> could someone tell me how can i do this SMALLER, please
12:31:07 <kudomarkos> https://paste.ofcode.org/LhDqLA39CxZre8bcUUiBhc
12:31:54 <glguy> kudomarkos: Name the repeated parts, and parameters for the parts that are not repeated
12:34:34 <jle`> kudomarkos: you can use pattern matching instead of fst/snd
12:34:45 <jle`> comestiblesTorre (x,y) tab = ...
12:35:25 <jle`> kudomarkos: you can also use concat instead of repeated ++'s
12:35:31 <jle`> > "hello" ++ "world" ++ "goodbye"
12:35:33 <lambdabot>  "helloworldgoodbye"
12:35:37 <jle`> > concat ["hello", "world", "goodbye"]
12:35:39 <lambdabot>  "helloworldgoodbye"
12:36:10 <ph88> disregard my previous question
12:40:58 <ph88> so about the previous question .. i narrowed it down that it has something to do with Text .. if i just show it in ghci as Text it looks good, but when i try to convert it to string and unpack it's missing a lot of stuff  https://bpaste.net/show/e92bc40bda6a
12:43:23 <cocreature> ph88: what happens without the putStr?
12:43:45 <cocreature> you’re probably overwriting things due to the \r
12:43:47 <ph88> looks the same as with Text
12:43:58 <ph88> what's so special about \r ?
12:44:03 <lemmih> ph88: \r resets the cursor to the start of the line.
12:44:04 <ph88> ah go to start of line
12:44:06 <ph88> ok
12:44:10 <ph88> :D
12:47:30 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
12:47:47 <geekosaur> in a quoted String or Char literal, backslash escapes do things
12:48:34 <iqubic> Does the emacs haskell-mode provide a quick way to get the type of a variable/function/name at the cursor's location?
12:49:04 <iqubic> That's really the main thing I'd need from an emacs haskell package.
12:49:55 <kudomarkos> jle thanks :D that is a good idea
12:54:55 <dmwit> reactormonk[m]: Yes, c_wraith nailed what I meant by "mistake". I suspect a boring old ADT for ingredients and boring old value-level computation of whether ingredients form a known recipe is going to be significantly simpler. I think your assumption that HLists are needed is symptomatic of this mistake -- not an argument against value-level computation but an expression that you haven't yet thoroughly demoted your thoughts from type- to
12:56:40 <dmwit> ...but you are closer to your problem domain than I am. So I'm not going to push my opinion super hard. If you're interested, I'd love to explore with you what a value-level version of this might look like sometime when we're both online. =)
12:57:40 <glguy> dmwit: Your client accidentally trunca
12:58:17 <dmwit> oh bother
12:58:50 <dmwit> ...haven't yet thoroughly demoted your thoughts from type- to value-level.
12:59:13 <eschnett> i'm looking for a type that is defined like "data Void a", i.e. without constructors, but with a type parameter. kind of a cross between Void and Proxy. is there a standard definition?
13:01:11 <dmwit> eschnett: Const Void, maybe
13:01:45 <eschnett> dmwit: thanks. i want to define instances for it, so i'd need a newtype then...
13:02:01 <Taneb> eschnett: I've looked in the past and couldn't find one
13:02:34 <dmwit> eschnett: If you want something that doesn't have any instances, you *have* to define a new type. At which point you might as well write the one line of code `data Thud a`...
13:02:58 <dmwit> Or maybe I'm confused about your objection.
13:03:02 <freeman42]NixOS> any suggestions for what JS library/framework to pick that works well with Haskell, maybe with GHCJS/PureScript (React, Vue, Angular, etc.)? I'm looking for something that could easily integrate with a JS charting library for example such as highcharts
13:03:33 <dmwit> Okay. I'm confused about your objection, so: Why can't you define instances for `Const Void`?
13:05:39 <geekosaur> they were thinking type synonym
13:05:50 <glguy> Or were hoping to avoid FlexibleInstances
13:06:14 <glguy> or perhaps in avoiding an IsVoid class, who knows :)
13:06:30 <dmwit> Or saw that Const already had some of the instances they wanted to override.
13:06:40 <dmwit> There's many answers. Hence "I'm confused about your objection.".
13:10:45 <ph88> Taneb, i have another strange situation .. i'm not sure if it's a problem with the function that use biplate or elsewhere in my code  .. could you have a look?  https://pastebin.com/fuseUZDS
13:53:53 <Squarism> if you have multi lib stack project (multiple .cabal/stack.yaml) is there some way of keeping every subproject on the same version? So that when you step version you dont have to change it manually in all .cabal files?
13:56:12 <jle`> Squarism: if they all depend on each other, this is automatic
13:56:17 <jle`> you just need to change the version on one of the files
13:57:01 <glguy> step which version?
13:57:19 <Squarism> jle`, I have 3 subproject. So i should  not have version specified in the 2/3 then?
13:57:47 <jle`> oh wait, are you talking about a version of a dependency
13:57:52 <jle`> or a version of the packages
13:58:46 <hexagoxel> find . -name "*.cabal" -exec sed "s/version: 0.1/version: 0.2/" -i {} \;
13:59:06 <hexagoxel> probably messed that up some way ..
13:59:35 <Squarism> i have this project where i have "myplatform", "myimplementation-of-platform", "executable-of-myimpl-of-platform". 3 subprojects which depend on each other in reverse order. When i want to step the version of it in my cabal files i do it in all 3.
14:00:12 <Squarism> hexagoxel, works i guess.
14:00:17 <jle`> oh step the version of your project?
14:00:23 <Squarism> yeah
14:01:13 <thblt> Am I right in assuming redaction of Stephen Diehl's *Write you a Haskell* is abandoned?
14:01:27 <fr33domlover> Squarism, it's not a big deal, 3 is not 100 :) also you likely want to update the Changelog with each release anyway
14:02:51 <Squarism> fr33domlover, true. Just that when working with java ive got used to do this in 10 subprojects using a utility command that is part of the build tool. So i thought id learn how to do it stack/haskell style.
14:04:27 <hexagoxel> Squarism: that's what matters, right? :) and i am just not aware of a neater answer.
14:05:06 <fr33domlover> Squarism, in Haskell it's part of the plain text input to the build tool, you can do what hexagoxel suggests though if you really want to automate it (but especially if you still need to manually update each subporject's changelog, little is gained by that)
14:06:03 <fr33domlover> Squarism, also check out PVP if you haven't
14:06:35 <fr33domlover> If you follow that, your subprojects are unlikely to be the same version over time
14:06:40 <Squarism> hexagoxel, thanks. Knowing what is possible is good enough.
14:07:47 <Squarism> fr33domlover, its not used by anyone else then me so i can skip changelogs until that changes. =D
14:19:53 <zincy> How do I consume a string using Parsec as opposed to a single char? I want to essentially do a negative look ahead
14:26:56 <lyxia> try (string blah)
14:31:40 * hackage cloud-seeder 0.2.0.0 - A tool for interacting with AWS CloudFormation  http://hackage.haskell.org/package/cloud-seeder-0.2.0.0 (marnold)
14:32:53 <Shmo> Hello!  Would anyone be interested in helping me with an annoying beginner problem?  I just started learning Haskell recently
14:33:16 <chorhizo_> Shmo, go for it, we don't bite
14:33:45 <jle`> Const Void, my favorite Applicative
14:33:52 <Shmo> :-)  Here's a simple code sample:  https://pastebin.com/tsPQujs3
14:33:56 <jle`> oh oops missed the scrollback
14:34:04 <Shmo> I just can't understand why it throws an error
14:34:21 <jle`> Shmo: well, what's the error?
14:35:05 <Shmo> Starts with "couldn't match type" and it says the probable cause is that map is applied to too few arguments, but I can't see that in the code I linked to at all
14:35:31 <jle`> remember that 'f g h x' is parsed as f applied to g, h, and x
14:35:50 <Shmo> When I go to ghci and map digitToInt "345" it works fine, and I figure I have something of exactly the same form
14:35:50 <jle`> like this:
14:35:52 <jle`> > logBase 10 3
14:35:54 <lambdabot>  0.47712125471966244
14:36:15 <jle`> you wrpte putStr map digitToInt (filter ...  contents)
14:36:20 <jle`> which is calling 'putStr' with three arguments
14:36:22 <jle`> 1. map
14:36:24 <jle`> 2. digitToInt
14:36:32 <Shmo> Oh!
14:36:43 <jle`> so you're giving putStr three different arguments
14:36:54 <jle`> you're giving it map, digitToInt, and that whole (filter .... contents) thing
14:37:02 <jle`> but putStr only takes a single argument, a string
14:37:21 <Shmo> Hmm, so I just put a pair of parentheses around everything after putStr
14:37:22 <jle`> by the way, you should probably use putStrLn instead of putStr
14:37:31 <jle`> yeah, that's the simplest way
14:38:29 <Shmo> It still doesn't like it.  But now I see why; because putStrLn expects [Char], not [Int]
14:39:34 <Shmo> Thank you so much, jle` , I get it now.  I guess I should probably try to use $ instead of parens, too
14:40:56 <jle`> no problem :)
14:41:04 <jle`> Shmo: you can use 'print', which is putStrLn + show
14:41:12 <zachk> Shmo: show
14:41:36 <light_rook> ` <interactive>: ^^ Could not load 'interactive_Ghci9_sp_closure', dependency unresolved. See top entry above.` is this meaningful to anyone?
14:41:38 <zachk> > concat . fmap show $ [1..10]
14:41:40 <lambdabot>  "12345678910"
14:41:46 <zachk> @type intercalate
14:41:47 <lambdabot> [a] -> [[a]] -> [a]
14:42:11 <zachk> > intercalate " " . fmap show $ [1..10]
14:42:12 <lambdabot>  "1 2 3 4 5 6 7 8 9 10"
14:43:20 <Shmo> Man, so much to learn, and it all looks so elegant
14:43:40 <zachk> do you know about . and $ ?
14:43:47 <zachk> . is function composition
14:43:55 <zachk> and $ is function application
14:44:18 <Shmo> I always thought about $ as being like putting parentheses around what follows
14:44:30 <zachk> you read that statement I input into lambdabot from right to left, just like function composition in math
14:44:38 <Shmo> Well, "always."  I've been at it for a couple of weeks
14:44:47 <zachk> :) keep at it
14:45:35 <Shmo> I don't really understand the difference between . and $ yet
14:46:03 <fishythefish> f . g gives you the function which first applies g, then applies f to the result
14:46:04 <jle`> seeing their definitions helps
14:46:06 <zachk> you can just use $'s all over the place
14:46:09 <fishythefish> f $ x is like f(x) in math
14:46:12 <jle`> (f . g) x = f (g x)
14:46:15 <jle`> f $ x = f x
14:46:32 <jle`> that's all there is too it ~
14:47:10 <Shmo> Is f $ g x the same as (f.g) x ?
14:47:16 <jle`> one way to find out
14:47:20 <jle`> expand the definitions :)
14:47:26 <jle`> f $ x = f x
14:47:30 <jle`> so f $ g x = f (g x)
14:47:38 <jle`> the second one:
14:47:43 <jle`> (f . g) x = f (g x)
14:47:50 <jle`> so yes they evaluate to the same thing
14:47:51 <Shmo> Oh, I see.  The second one follows directly from the definition
14:47:59 <jle`> mhm
14:47:59 <hexagoxel> precedences are important though, before you expand definitions
14:48:14 <jle`> the main thing about (.) is that it takes two functions and returns a new function
14:48:22 <Shmo> Right, hexagoxel , I definitely instantly started snagging on that
14:48:26 <jle`> and ($) takes a function and an argument value, and returns the functional applied to the value
14:48:32 <jle`> s/functional/function
14:48:42 <jle`> the "point" of (.) is to return a new function
14:48:52 <jle`> but the "point" of $ is to just to apply your function to your value to get a new value
14:49:16 <Shmo> That makes complete sense
14:52:47 <petrolifero[m]> But $ has low precedence so the effect is putting parênteses
14:52:54 <hexagoxel> at precedence 0, the only things with lower precedence are syntax stuff like function application, type annotations, type applications, record syntax
14:53:09 <hexagoxel> i probably forget something in that list.
14:54:08 <hexagoxel> also, in general parentheses need to be on left and right of ($)
14:54:31 <hexagoxel> a . b $ c + d  =  (a . b) (c + d)
14:54:58 <Shmo> Oh, yeah, that makes sense, to put the $ at lowest precedence
14:59:14 <quicksilver> hexagoxel: function application has the highest precedence not the lowest (compared to any operator)
15:00:25 <hexagoxel> good point, whoops.
15:02:49 <hexagoxel> so my examples were all wrong. the lower-precedence syntax stuff is if-then-else, case-of etc.
15:03:01 <hexagoxel> if you are willing to stretch the "precedence" term that far
15:03:06 <light_rook>  
15:03:48 <jle`> Shmo: in a sense, $ is just a cute hack
15:04:29 <sl2c> a$b=a b
15:04:54 <sl2c> i think this might actually be how it's "defined" in prelude except ghc does other magic with it and the type system
15:05:27 <petrolifero[m]> A adorable hack
15:07:01 <Shmo> i.e. syntactic sugar, jle` ?
15:07:06 <jle`> not syntactic sugar
15:07:12 <jle`> just a normal defined function
15:07:59 <Shmo> like an infix that takes all subsequent arguments and combines them into an argument and everything prior and combines it into a curried function?
15:13:42 <spaceloop> I have a cabal file with a test-suite, it seems like cabal ignores the extensions: CPP since I get a parse error on an ifdef
15:13:52 <spaceloop> the library component also contains extensions: CPP and builds fine
15:13:56 <spaceloop> is this a bug?
15:15:29 <quicksilver> sl2c: GHC only does a fairly modest piece of magic with $
15:15:38 <quicksilver> and $ was widely used before that magic existed
15:16:09 <sl2c> quicksilver: fair enough.  the big warning at the start of the prelude source (or maybe a different base page but still) is kinda scary though
15:18:10 <jle`> Shmo: yeah, it can do that not because of any magic, just because of how it's user-defined
15:18:18 <jle`> Shmo: also it doesn't quite combine it into a curried function
15:18:28 <jle`> not necessarily
15:18:51 <jle`> it doesn't "combine" it actually, it just tricks the parser/associator into treating it that way
15:19:23 <jle`> it's kind of like x * y * z + a * b * c, being interpreted as (x * y * z) + (a * b * c), since + associates lowest
15:19:42 <Shmo> jle`: If you have multiple $s in an expression, the leftmost one has the lowest precedence?
15:20:29 <jle`> $ is infixr, so f $ g $ h $ x is f (g (h x))
15:20:40 <jle`> multiple $'s on a line is kind of ugly though
15:20:51 <jle`> well, a lot of people consider even a single $ to be ugly
15:22:58 <Shmo> Oh, hmm.  I thought it was universally held preferable to lots of parens
15:23:31 <Shmo> I guess if you use parens in place of all the $s, Haskell starts to look a lot more like LISP
15:23:34 <quicksilver> not universally, certainly
15:23:41 <quicksilver> some people like the way lisp looks :)
15:24:20 <Shmo> :-)  I do love Scheme myself
15:24:55 <jle`> Shmo: yeah it's definitely not universally preferable
15:25:02 <jle`> most people sit somewhere in the middle
15:25:07 <lyxia> or rewrite your code so you need neither parentheses nor $
15:25:14 <jle`> nobody says 'always use $ instead of parentheses' or 'always use parentheses instead of $'
15:25:26 <jle`> most people are comfortable somewhere in the middle
15:25:41 <DigitalKiwi> death to parens!
15:25:41 <boj> readability above all
15:25:53 <jle`> and yeah, there's the 'rewrite your code to require neither parentheses nor $' camp, too
15:26:06 <sl2c> and then there's <$> and <*> and all that fun stuff
15:26:12 <Shmo> Ooh, that rewriting sounds tough
15:26:17 <jle`> we're all somwhere inn the middle of that triangle
15:26:24 <jle`> Shmo: nah it's really just about naming
15:26:33 <sl2c> Shmo: a lot of the rewriting is stuff like "pull out your subterms and give them names"
15:26:48 <jle`> instead of f . g . h $ x + y + z, you can say let myFunc = f . g . h; myNum = x + y + z in myFunc myNum
15:26:52 <jle`> names are good
15:27:00 <Shmo> Oh, that makes total sense!  Like boj said, readability above all
15:28:17 <Shmo> When I read a line of Haskell and see a $, right now, I think "Pause; the rest of the line is one thing"
15:30:43 <boj> Shmo: this helped me when i first started, said by someone here
15:30:52 <boj> "the $ wraps both sides in parens"
15:31:57 <hexagoxel> Shmo: that ability to "read/parse code without backtracking" you get is exactly why i even prefer a $ b $ c over a . b $ c
15:32:27 <Shmo> Yeah, boj , that's really helpful as long as there's just one $
15:32:57 <Shmo> hexagoxel: I think you nailed what I like about Haskell over LISP (and I love LISP); so much easier not to backtrack
15:33:37 <Shmo> It's probably too early to say, but I think I might become a heavy $ user
15:34:00 <hexagoxel> Shmo: still there is somewhat of a consensus in favour of a . b $ c
15:34:01 <Shmo> Or maybe I'll just get better at encompassing everything in its own function
15:34:12 <hexagoxel> but feel free to join me on the dark side of ()
15:34:15 <hexagoxel> of ($)
15:34:32 <Shmo> I haven't quite figured out how to use . without getting occasional errors thrown at me, but as I do, my tastes there are likely to change too
15:34:40 <DigitalKiwi> next thing you know you lose your job and you're homeless and your family hates you and you just can't get enough of your $ fix
15:34:44 <hpc> Shmo: it's a phase a lot of people go through, (.) and ($)
15:35:08 <hexagoxel> spend all your $ on your code, nothing left for your life
15:35:17 <hpc> you'll eventually find as you learn more, that you avoid situations where you need them more often
15:35:46 <Shmo> Hahaha
15:35:48 <hpc> (a similar sort of thing happens for do-notation, depending on the sort of programs you end up writing)
15:36:10 <hpc> but until then it's perfectly readable, and sometimes it's just the best way to express an idea
15:36:23 <Shmo> Oh, really, hpc?  Right now, I just recently learned do, and it's cleaned up my "make" functions significantly and made them more readable
15:36:47 <hpc> Shmo: have you seen Applicative?
15:37:40 <hpc> you may find yourself very happy with what it gives you
15:37:56 <Profpatsch> newtype ABehavior event a = ABehavior (forall b. event (a -> b) -> event b)
15:38:03 <Profpatsch> instance functorABehavior :: Functor event => Functor (ABehavior event) where
15:38:14 <Profpatsch> nvm
15:38:31 <Shmo> Profpatsch: is that an example of Applicative?
15:38:31 <hpc> heh
15:38:44 <hpc> i think that was a mis-paste
15:39:35 <hpc> > (,) <$> [1,2] <*> ["yes", "no"] -- this is the sort of thing you get with Applicative
15:39:37 <Profpatsch> Yeah, or rather I noticed my question is stupid.
15:39:37 <lambdabot>  [(1,"yes"),(1,"no"),(2,"yes"),(2,"no")]
15:39:56 <hpc> or with IO, (,) <$> getLine <*> getLine
15:40:04 <hpc> prompts for two lines of input, sticks both in a tuple
15:40:16 <fishythefish> hexagoxel: I didn't realize other people in this channel favor a $ b $ c too!
15:40:34 <chorhizo_> fishythefish, but it looks so ugly :(
15:40:39 <fishythefish> I write a . b $ c only when I consider (a . b) to be a single logical entity
15:40:44 <hpc> is the rank-2 hack with ($) still around?
15:40:50 <lyxia> yes
15:41:01 <hpc> i wonder if you could contrive an api where a $ b $ c is /required/
15:41:09 * hackage modular-arithmetic 1.2.1.3 - A type for integers modulo some constant.  http://hackage.haskell.org/package/modular-arithmetic-1.2.1.3 (TikhonJelvis)
15:41:16 <fishythefish> chorhizo_: compared to what? a . b $ c is the same number of operators, but now you have two different ones!
15:41:30 <Shmo> But isn't a . b $ c interpreted as (a b) c , while a $ b $ c is interpreted as a (b c) ?
15:41:38 <chorhizo_> yeah but in terms of aesthetic clutter
15:41:56 <fishythefish> no, a . b $ c = (a . b) c = a (b c)
15:41:58 <hpc> i write a $b $c
15:42:02 <hpc> just like perl :D
15:42:05 <chorhizo_> a . b $ c is the same as  (a ( b c))
15:42:21 <Shmo> Oh, fishythefish , I see
15:42:39 <fishythefish> chorhizo_: I don't know what "aesthetic clutter" means
15:42:56 <chorhizo_> fishythefish, neither do I, just my eyes hurt when I see so many $ signs
15:43:02 <hpc> fishythefish: it means "web design"
15:43:05 * hpc woop woop woop
15:43:12 <sl2c> the difference between a.b$c and a$b$c is that if there a or b are actually long expressions with other operators, the precedence will be different for those
15:43:31 <fishythefish> sl2c: explain?
15:43:41 <fishythefish> oh, I see what you mean
15:43:42 <hpc> fishythefish: (.) has a precedence of 5 or so
15:43:49 <sl2c> :info (.)
15:43:52 <hpc> so 6, 7, and 8 can interfere
15:43:57 <fishythefish> no, I understand
15:44:03 <hpc> heh
15:44:04 <sl2c> @info (.)
15:44:04 <lambdabot> (.)
15:44:12 <hpc> informative
15:44:20 <sl2c> i feel informed
15:44:33 <fishythefish> when I use a variable to represent an expression, I take that expression to be implicitly wrapped in parens
15:44:52 <sl2c> yeah, then you'll be fine
15:45:32 <fishythefish> chorhizo_: my eyes prefer $s; they're easier to pick out than .s
15:46:33 <chorhizo_> fishythefish, fair enough, I would probably use more $ for between something like a b c . d e f . g h
15:46:51 <chorhizo_> but for a . b . c or something like that I'd prefer .
15:46:55 <fishythefish> chorhizo_: where would you use $ there?
15:47:04 <fishythefish> a . b . c is not one of the options here
15:47:19 <chorhizo_> right, but you get what I mean
15:47:27 <chorhizo_> a . b . c $ d
15:48:04 <chorhizo_> for a b c . d e f . g h $ i j
15:48:12 <chorhizo_> maybe I'd use $ instead of . dunno
15:51:32 <Profpatsch> I tried to replace multiple $ $$$ by a . b . c $ d for a long time, but I eventually gave in.
15:51:49 <Profpatsch> It just doesn’t matter enough to be worth the hassel.
15:51:51 <Profpatsch> *le
15:51:58 <aarvar> or you can do (f . g . h) x
15:53:22 <cosinenan> hey I am having a problem. I am working on a locally installed package (as in https://stackoverflow.com/questions/32849269/how-to-install-use-a-local-version-of-package-using-stack).
15:54:11 <cosinenan> my issue is that when I create an error on purpose in the local library, intero doesn't catch it. But when I run 'stack build' in the top level directory it spits out the correct error message.
15:55:02 <cosinenan> I also believe (although I don't know how to verify) that I am using two versions of intero; one for my normal project and one for the included library.
15:57:25 <sm> hey all. Is there a version of <$> you can write on the right, corresponding to & for $ ?
15:57:48 <hexagoxel> sm: lens and some other packages have <&>
15:58:06 <hexagoxel> :t (<&>)
15:58:07 <lambdabot> Functor f => f a -> (a -> b) -> f b
15:58:15 <sm> nice, thanks
15:59:05 <hpc> :t (&)
15:59:06 <lambdabot> a -> (a -> b) -> b
15:59:11 <hpc> that's the corresponding one for ($)
15:59:17 <hpc> also i think in lens?
15:59:39 <lyxia> https://hackage.haskell.org/package/base-4.11.0.0/docs/Data-Functor.html#v:-60--38--62-
15:59:54 <lyxia> oh that's since 4.11
16:05:13 <cosinenan> so nobody knows what to do when 'stack build' reports an error but intero does not?
16:05:59 <cosinenan> sorry, I mean I am sure some people know. I am just frustrated with myself.
16:06:11 <lyxia> I have no idea sorry
16:07:15 <lyxia> ask on their bug tracker maybe?
16:08:05 <cosinenan> lyxia: I don't think it's a bug that warrants an issue... I am sure I am doing something simply stupid but I don't know what.
16:09:34 <hexagoxel> it is hard to google for the lack of an error message, eh
16:16:44 <danilo2> Hi guys! Are we able to somehow silent GHC warnings about missing top level signatures but only in TH generated code?
16:19:06 <lyxia> generate the code in its own module and disable warnings there?
16:25:29 <chorhizo_> is there a way to convert an Int to a Text? Like show but Int -> Text
16:26:07 <hpc> pack . show
16:26:29 <chorhizo_> hpc, ah. I was trying to avoid the string -> Text conversion
16:26:39 <chorhizo_> I guess if it's unavoidable I'll just unpack the Text
16:26:41 <sl2c> i think that conversion gets optimized out anyways
16:27:22 <sl2c> since there are a bunch of fancy stream fusion/list fusion steps
16:27:38 <chorhizo_> oh I see
16:27:39 <chorhizo_> cool
16:27:52 <hpc> yeah
16:28:31 <hpc> it's surprising how many fusion rules there are sometimes
16:28:55 <hpc> and even more things just get transposed from how they would appear to evaluate, because of laziness
16:28:57 <chorhizo_> I'll be honest, I have no idea what you mean by fusion rules
16:29:06 <chorhizo_> I would look it up but it sounds scary :^)
16:29:35 <hpc> chorhizo_: it turns things like map f . map g $ list, into map (f . g) $ list
16:29:52 <hpc> they're rewrite rules built around removing intermediate representations of things
16:30:04 <chorhizo_> oh, so it's literally fusion
16:30:09 <hpc> fusion HA!
16:30:26 <hpc> yep
16:30:50 <chorhizo_> I guess I've only really heard of it as optimisation
16:31:01 <hpc> it's a specific type of optimization
16:31:15 <hpc> like constant elimination, or inlining
16:31:17 <sl2c> i've tried to read the papers on the really fancy stream stuff but i don't remember it at all really
16:31:31 <Shmo> The optimization in Haskell just repeatedly blows my mind
16:31:53 <Shmo> Although the terrible code I write manages to stymie even that
16:32:02 <hpc> Shmo: most of it comes from language guarantees
16:32:26 <hpc> i remember there being some optimizations they wanted to add as list fusion rules, but they were unsound because of bottom
16:33:19 <hpc> Shmo: the best optimizations are higher-level stuff
16:33:41 <hpc> like you can always share (most) data between threads instead of copying, because it can't change anyway
16:34:42 <hpc> they even avoid recomputation with black-holes and grey-holes (depending on the rts you pick)
16:35:10 <hpc> so, an unevaluated value is a "thunk", which ghc implements as a pointer to a block of code that computes itself
16:35:30 <hpc> when you start evaluating a thunk, it's first rewritten to a black hole (which is code that exits with <<loop>>)
16:35:37 <Shmo> > sum [x | x <- [1..100]]
16:35:39 <lambdabot>  5050
16:35:40 <hpc> or a grey hole which blocks until the other thread is finished
16:35:50 <Shmo> Does that get turned into an explicit formula?
16:36:17 <hpc> it's effectively function pointers
16:36:39 <Shmo> The black and grey holes make some sense because I remember streams in LISP
16:36:42 <hpc> once something is evaluated, the last step is to rewrite the thunk to a block of code that doesn't compute it, but prints the already evaluated answer
16:37:14 <hpc> in the non-threaded runtime, you know nothing else is ever going to come along to say, kill your thread
16:37:26 <hpc> so once you loop in evaluation, you're done
16:37:40 <hpc> > fix id
16:37:43 <lambdabot>  *Exception: <<loop>>
16:38:00 <sl2c> > fix not
16:38:01 <hpc> which makes it look like sometimes haskell is able to detect infinite loops
16:38:03 <lambdabot>  *Exception: <<loop>>
16:38:19 <hpc> sl2c: that was surprising
16:39:07 <sl2c> > fix (+1)
16:39:09 <lambdabot>  *Exception: <<loop>>
16:39:19 <hpc> Shmo: the beauty of that implementation of thunks is that all of this functionality is just fancifications on "call a function that has a pointer to itself"
16:39:26 <sl2c> hpc: i mean, honestly it has the same data dependency as fix id
16:39:39 <chorhizo_> hpc, do you know how you'd get into some of the nitty gritty or doign more research stuff for haskell
16:39:48 <chorhizo_> I'd assume catagory theory would be useful
16:40:14 <hpc> it depends, but CT is usually helpful at least a little bit
16:40:20 <fishythefish> hpc: why is `fix not` surprising? `not` is strict
16:40:22 * Shmo has an astrophysics degree and is lost wrt "fix id"
16:40:30 <hpc> if you want to invent the next STM or something, more implementation-detail kind of stuff will be useful
16:40:45 <chorhizo_> isnt Fix f == f (Fix f)
16:40:47 <chorhizo_> :t Fix
16:40:48 <lambdabot> f (Fix f) -> Fix f
16:40:58 <fishythefish> chorhizo_: there's a difference between fix and Fix
16:41:02 <sl2c> chorhizo_: yeah that's Fix the type
16:41:02 <hpc> oh now that i think about it, it's not that surprising
16:41:11 <chorhizo_> wait a second
16:41:14 <hpc> i was still thinking of it as not (not (not ...
16:41:20 <hpc> rather than "evaluating x evaluates x"
16:41:24 <sl2c> :t fix
16:41:25 <chorhizo_> :t fix
16:41:26 <lambdabot> (a -> a) -> a
16:41:26 <lambdabot> (a -> a) -> a
16:41:30 <hpc> @src fix
16:41:30 <lambdabot> fix f = let x = f x in x
16:41:35 <sl2c> > fix (0:)
16:41:37 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
16:41:53 <hpc> > let fix f = f (fix f) in fix id -- this one doesn't loop, it's a new thunk every time
16:41:59 <lambdabot>  mueval-core: Time limit exceeded
16:42:10 <fishythefish> bottom is bottom :P
16:42:17 <Shmo> :t id
16:42:18 <lambdabot> a -> a
16:42:18 <hpc> that's tying the knot, which is a bit of a brain-strain to learn early on
16:42:20 <Shmo> err
16:42:24 <Shmo> > :t id
16:42:26 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
16:42:32 <chorhizo_> :t id
16:42:33 <lambdabot> a -> a
16:42:39 <chorhizo_> > id "hello"
16:42:41 <lambdabot>  "hello"
16:42:53 <sl2c> hpc: so it is.  that means it'd be represented as an actual circular data structure by the runtime, right?
16:43:00 <hpc> yeah
16:43:16 <hpc> knot-tying is really brittle
16:43:31 <hpc> for instance, your infinite list of zeroes is one cons cell pointing back to itself
16:43:38 <Shmo> > fix (2*)
16:43:41 <hpc> but if you map id (fix (0:)), that unties the knot
16:43:41 <lambdabot>  *Exception: <<loop>>
16:43:55 <sl2c> > fix (:8:[])
16:43:57 <lambdabot>  error:
16:43:57 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
16:43:57 <lambdabot>        Expected type: [a] -> [a]
16:43:58 <Cale> > fix error
16:44:00 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
16:44:00 <Shmo> I see.  Is that like taking an infinite power of 2?
16:44:20 <Cale> yes, it's like writing  let x = 2*x in x
16:44:23 <fishythefish> Shmo: it's like finding a solution to x = 2 * x
16:44:35 <hpc> automatic memoization is an application of memoization and fixed-point style of writing recursive functions
16:44:37 <Cale> The runtime detects the infinite loop in evaluation, and quits with an exception
16:44:52 <hpc> instead of fix, you use a more elaborate recursion scheme that avoids recomputation
16:45:00 <sl2c> > fix show
16:45:02 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:45:02 <Cale> (it tries to evaluate x, and during that evaluation, finds that it needs to evaluate x to proceed, so it can't make any progress)
16:45:34 <Shmo> > fix (4/)
16:45:37 <lambdabot>  *Exception: <<loop>>
16:45:41 <Shmo> Why isn't that 2 then?
16:45:50 <fishythefish> 2 is a solution but not the only solution
16:46:02 <hpc> Shmo: the abstract answer is it finds the least fixed point
16:46:06 <Cale> fix always finds the least-defined fixed point
16:46:10 <hpc> and bottom is a fixed point, because 4/bottom = bottom
16:46:17 <fishythefish> > 4 / undefined
16:46:19 <lambdabot>  *Exception: Prelude.undefined
16:46:25 <Shmo> Not -2?
16:46:37 <fishythefish> least defined doesn't mean least wrt < on the real numbers
16:46:39 <hpc> "least" in the sense of definedness
16:46:39 <Cale> If undefined -- or a nonterminating expression -- is a fixed point of the function, then that's the fixed point you'll get
16:46:59 <Shmo> Oh
16:47:05 <hpc> it's a totally different ordering of values
16:47:06 <Cale> (because that's the least defined value of all)
16:47:10 <sl2c> Cale: and undefined isn't a fixed point of (0:) because 0:undefined is different from undefined, yeah?
16:47:12 <hpc> Shmo: http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/ was really helpful when i was learning this
16:47:13 <Shmo> Hmm, so confused
16:47:20 <Cale> Yeah, in this ordering, all the numbers are incomparable
16:47:25 <Shmo> Thanks, hpc !
16:47:26 <Cale> sl2c: right
16:47:40 <fishythefish> Shmo: to save a bit of time, any function that is strict (i.e. evaluates its input) is gonna blow up when you try to `fix` it
16:47:56 <Cale> and you can view the result of fix as the limit of a sequence of values obtained by applying the function more and more times
16:48:15 <Shmo> I see
16:48:39 <Cale> _|_, f _|_, f (f _|_), ...
16:48:47 <Shmo> So fix cos would also throw a loop exception?
16:48:56 <Cale> where _|_ is the value representing nontermination
16:49:01 <Cale> yes
16:49:08 <Cale> > fix cos
16:49:10 <lambdabot>  *Exception: <<loop>>
16:49:24 <Shmo> Because it has to repeat it an infinite number of times to find the fixed point?
16:49:41 <hpc> because cos _|_ = _|_
16:49:43 <Cale> well, because it doesn't make any progress
16:49:45 <Shmo> Err, I guess *apply* it an infinite number of times
16:49:47 <hpc> so that's the least fixed point, it's found it
16:49:58 <sl2c> > let x = x in x
16:50:01 <lambdabot>  *Exception: <<loop>>
16:50:02 <Cale> If you define x = cos x
16:50:07 <Cale> and you try to evaluate x
16:50:16 <Cale> then you'll try to evaluate cos x
16:50:22 <hpc> Shmo: remember it always starts from the bottom, and the bottom is...... bottom
16:50:26 <sl2c> :t (:8:[])
16:50:28 <lambdabot> Num a => a -> [a]
16:50:28 <Cale> and cos is strict -- it pattern matches its argument
16:50:30 <Cale> which is x
16:50:38 <Cale> so x's evaluation will be triggered for a second time
16:50:43 <Shmo> I think I'm gradually getting it
16:50:48 <Cale> and that will result in the loop exception being thrown
16:51:33 <Cale> It would also be valid just to spin forever without throwing an exception, but the runtime does its best to catch the obvious cases.
16:51:56 <sl2c> :fix (((*2)<$>).(1:))
16:52:05 <Cale> You'll notice often that the threaded runtime will take a little longer to detect loops, or sometimes fail to detect them, but instead block forever, depending on what version of GHC you're using
16:52:16 <Shmo> For a second there, I got excited thinking it would just somehow find the fixed point
16:52:18 <Cale> That has to do with low level details
16:52:20 <hpc> sl2c: btw, you can pm lambdabot to get something working, then paste it here
16:52:26 <sl2c> hpc: right
16:52:37 <hpc> Shmo: just the least one ;)
16:52:38 <Cale> Shmo: well, it does find *a* fixed point, it's just a boring one in that case ;)
16:52:52 <Shmo> :-)
16:53:06 <sl2c> > let w xs = 1:map (2*) xs in fix w
16:53:08 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
16:53:09 * hackage sensu-run 0.5.0 - A tool to send command execution results to Sensu  http://hackage.haskell.org/package/sensu-run-0.5.0 (MitsutoshiAoe)
16:53:18 <hpc> Cale: the threaded runtime can <<loop>> now?
16:53:30 <hpc> i... have no idea how one would implement that
16:53:32 <Cale> I think so?
16:53:47 <hpc> but it sounds like the kind of impossible thing ghc would do
16:53:51 <Cale> haha
16:53:52 <sl2c> hpc: my guess would be something like "if all the threads are blocking on each other, you have a loop"
16:54:27 <sl2c> or, thread is blocking on something that just got gc'd
16:54:42 <hpc> sl2c: that latter scenario wouldn't ever happen, i think
16:56:40 <hpc> that reminds me, it's about time for my irregularly-scheduled read of seemingly impossible functional programs
16:57:10 <hpc> maybe i'll be able to run the code in my head this time
16:59:43 <johnw> For all those interested in recursion schemes out there: http://newartisans.com/2018/04/win-for-recursion-schemes/
17:04:17 <sl2c> johnw: neat!
17:22:53 <danilo2> lyxia: Im sorry I got disconnected and didnt notice it. Hmm, is there any way not to generate it in separate module ?
17:24:10 <danilo2> lyxia: basically this TH is used to cache some typelevel computations. It just creates a dummy untyped function. Then GHC types it. Then I run another TH that reifies the infered type and caches it as constant. (It allowed us to drop compilation times from minutes to seconds)
17:24:34 <danilo2> lyxia: so basically I cannot easily export these TH calls to separate modules
17:25:01 <danilo2> lyxia: whats funny, I cannot also type them in TH because I rely on the infered type
17:31:39 <lyxia> I don't think that's possible otherwise.
17:32:05 <lyxia> That seems very specific for a compiler feature
17:35:29 <danilo2> lyxia: Yep. I assumed the answer will be no, but I hoped im wrong :) Thanks for your help!
18:07:01 <Clint> anyone know anything about https://nyu.databrary.org/ ?
18:08:51 <EvanR> the video is freakin me out
18:09:09 * hackage open-union 0.4.0.0 - Extensible, type-safe unions.  http://hackage.haskell.org/package/open-union-0.4.0.0 (BenFoppa)
18:12:07 <acowley> johnw: That's pretty remarkable
18:26:40 <iqubic> What was the Braille thing we were experiementing with earlier?
18:26:57 <iqubic> Can someone type in those characters again?
18:32:21 <geekosaur> https://github.com/databrary/databrary/ ?
18:32:33 * geekosaur finds several mentions in logs...
18:34:05 <iqubic> No, it was like querying lambdabot with "> true false" but there was some braille character somewhere in there?
18:45:11 <MarcelineVQ> you asking about the composition operators people use sometimes?  .: .:: .:::
18:46:08 <iqubic> Yeah, I think that was it.
18:46:13 <iqubic> How does that work?
18:46:28 <iqubic> :t ((.) . (.))
18:46:29 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
18:46:38 <iqubic> How the heck does that work?
18:47:11 <Cale> iqubic: I find it helpful to figure this out first:
18:47:14 <Cale> :t fmap . fmap
18:47:16 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
18:47:32 <Cale> Does that type make intuitive sense?
18:47:34 <iqubic> I see what that does. I understand what that does.
18:47:59 <Cale> The only thing left then is to understand that there's an instance of Functor for (->) e in which fmap = (.)
18:48:21 <Cale> i.e. the functor f for which f t = e -> t
18:48:42 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)  in that case
18:48:49 <Cale> and that is exactly the type of function composition
18:48:51 <iqubic> I don't get how that translates to the given type signature of (.) composed with itself.
18:49:12 <iqubic> yes. I see how that is function composition.
18:49:25 <Cale> So, if we say f1 t = e1 -> t
18:49:30 <Cale> and f2 t = e2 -> t
18:49:44 <Cale> and substitute those into the type of  fmap . fmap  above
18:49:54 <iqubic> :t fmap . fmap
18:49:55 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
18:50:07 <iqubic> :t ((.) . (.))
18:50:08 <Cale> we get  (a -> b) -> (e1 -> e2 -> a) -> (e1 -> e2 -> b)
18:50:08 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
18:50:37 <iqubic> So what does that function even do?
18:50:51 <Cale> Well, it does the only thing it possibly could do, given its type
18:51:19 <iqubic> :t ((.) . (.) . (.))
18:51:20 <lambdabot> (b -> c) -> (a1 -> a2 -> a3 -> b) -> a1 -> a2 -> a3 -> c
18:51:35 <iqubic> What is the intial b -> c used for?
18:51:38 <Cale> It's  \f g e1 e2 -> f (g e1 e2)
18:51:58 <Cale> You get a function b -> c
18:52:07 <Cale> and you get a function a1 -> a2 -> a3 -> b
18:52:29 <Cale> and you get values of type a1, a2, and a3
18:52:34 <Cale> and you want to get a value of type c
18:52:38 <Cale> There's only one way to do it
18:53:00 <Cale> You apply your function a1 -> a2 -> a3 -> b to the appropriate values you have, in order to get a value of type b
18:53:05 <Cale> and then you apply your function b -> c
18:53:06 <iqubic> Wait, that's just function composition, but the second function takes a whole lot more than one argument.
18:53:10 <Cale> yes
18:53:34 <iqubic> :t (.)
18:53:35 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:54:31 <iqubic> Can we have something of "(c -> d -> e) -> (a -> b -> c) -> a -> b -> e?"
18:55:34 <lyxia> where do you get a d from
18:55:55 <Cale> exactly
18:56:05 <Cale> you're given:
18:56:12 <Cale> f :: c -> d -> e
18:56:15 <Cale> g :: a -> b -> c
18:56:18 <Cale> x :: a
18:56:20 <Cale> y :: b
18:56:39 <Cale> you can get g x y :: c
18:56:50 <Cale> and you can get f (g x y) :: d -> e
18:56:55 <Cale> but then you're stuck
18:59:09 * hackage taffybar 1.0.2 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-1.0.2 (eyevanmalicesun)
19:14:53 <orion> Could unsafeDupablePerformIO cause a segfault?
19:17:29 <lyxia> yes, like unsafePerformIO can
19:17:40 <suzu> i had a great time debugging segfaults today
19:17:44 <suzu> it sucked a lot
20:53:09 * hackage warp 3.2.19 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.2.19 (KazuYamamoto)
21:07:02 <mkoenig> I'm trying to make a Reflex (WebKitGTK) app with backend ready for shipping. I developed it on NixOS and I've successfully compiled it on Windows with "cabal new-build" but the executables give me segfaults (app) and strange errors (backend) when I try to run them. Any ideas how to proceed? https://pastebin.com/2F0mFkjx
21:29:27 <wagle> !hoogle [(a,b)] -> [(a,[b])]
21:30:32 <wagle> :t [(a,b)] -> [(a,[b])]
21:30:33 <lambdabot> error: parse error on input ‘->’
21:31:10 <wagle> rust
21:34:11 <EvanR> :k [(a,b)] -> [(a,[b])]
21:34:12 <lambdabot> error: Not in scope: type variable ‘a’
21:34:12 <lambdabot> error: Not in scope: type variable ‘b’
21:34:12 <lambdabot> error: Not in scope: type variable ‘a’
21:34:21 <EvanR> :k forall a b . [(a,b)] -> [(a,[b])]
21:34:22 <lambdabot> *
21:34:54 <wagle> looking for the name of a function
21:35:13 <EvanR> you want to group?
21:35:24 <EvanR> :t groupBy
21:35:26 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
21:35:39 <wagle> hmm
21:35:47 <EvanR> :t comparing
21:35:48 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
21:37:36 <wagle> [(1,2), (2,4), (1,3)]  to [(1,[2,3]),(2,[4])]
21:38:38 <geekosaur> :t groupOn fst
21:38:39 <lambdabot> error:
21:38:40 <lambdabot>     • Variable not in scope: groupOn :: ((a0, b0) -> a0) -> t
21:38:40 <lambdabot>     • Perhaps you meant one of these:
21:38:40 <wagle> maybe fold
21:38:42 <geekosaur> bag
21:38:44 <geekosaur> bah
21:39:02 <geekosaur> :t groupBy (comparing fst) . sort
21:39:04 <lambdabot> error:
21:39:04 <lambdabot>     • Couldn't match type ‘Ordering’ with ‘Bool’
21:39:04 <lambdabot>       Expected type: (a, b) -> (a, b) -> Bool
21:39:09 <nkaretnikov> geekosaur, ertes: remember my questions about primops, mvars, etc.? here's what i ended up writing: https://github.com/nkaretnikov/primitive-algorithms/blob/master/src/Data/Primitive/Algorithm/Insertion.hs whether it's useful or should be in the acme category is yet to be determined.
21:39:12 <geekosaur> I am too tired for this
21:39:33 <wagle> thanks for the ideas though!
21:41:28 <Cale> nkaretnikov: tbh, it's probably more useful without the list wrapping
21:42:19 <nkaretnikov> Cale: what do you mean by that? generalize [] to some sort of stream?
21:42:43 <Cale> I mean, just take a MutableByteArray and act on it
21:43:01 <nkaretnikov> Cale: ah, perhaps. i'll think about it.
21:44:06 <Cale> If you care about fine-tuning the performance of sorting your bytes that much, you probably already aren't using a list :)
21:45:20 <Cale> (especially given that insertion sort has poor asymptotic performance, so it only really gets used in cases where it wins due to constant factor concerns)
21:45:34 <Cale> Have you tested it alongside Data.List.sort?
21:47:17 <nkaretnikov> Cale: nah, i haven't tested against anything.
21:47:43 <nkaretnikov> Cale: it was a pain to code, and took a while to package. then i ran out of steam.
21:48:14 <nkaretnikov> Cale: i'm hoping to continue working on it, maybe even today. otherwise, it's kind of pointless.
21:48:42 <nkaretnikov> Cale: and  insertion sort was just randomly selected, so no real preference there
21:48:51 <nkaretnikov> Cale: but you're right about asymptotics
21:49:40 <nkaretnikov> Cale: like, i just don't want to measure time, but rather know what ghc/rts is doing. and that requires some thinking to setup
21:49:55 <nkaretnikov> Cale: maybe look at core/stg, too.
21:52:58 <nkaretnikov> (and i've added both of your suggestions to the todo list)
21:54:21 <ryantrinkle> is there anything like zeroth but up to date?
22:02:14 <nkaretnikov> Cale: also, as stated in the readme file, i'm not that interested in sorting, but rather would like to know whether imperative programming style can be easily translated to haskell, and whether it makes sense or not from the performance standpoint. you might think why? well, there's a lot of literature around, so it'd be good to tap into that rather than inventing stuff (like okasaki). also, a lot of programmers are
22:02:14 <nkaretnikov> taught how to program in an imperative fashion, so there's that, too. i'm not saying that's the way to go (think of how immutability parallelizes easily), just curious.
22:12:40 * hackage extensible-effects 2.6.0.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-2.6.0.0 (shergill)
22:16:39 * hackage beam-postgres 0.3.2.0 - Connection layer between beam and postgres  http://hackage.haskell.org/package/beam-postgres-0.3.2.0 (TravisAthougies)
22:37:09 * hackage extensible-effects 2.6.0.1 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-2.6.0.1 (shergill)
22:38:54 <dminuoso> Mmm. When exactly would you use CPS? I mean I frequently see it when dealing with things like connections, where you write code in terms of a continuation of some connection/handle.
22:40:59 <dminuoso> And by CPS I specifically mean Cont, not kleisli arrows.
22:51:23 <ertes> motivation: find a list (xs :: [Word8] such that (take 256 (scanl (+) 0 xs)) includes every Word8, which is quite easy:  xs = repeat 1
22:51:42 <ertes> now i need (xs :: [Word8]) such that (take 256 (scanl xor 0 xs)) includes every Word8
22:52:04 <ertes> i basically know how to do it using bit permutations, but is there a cheaper way to do it?
23:01:11 <Axman6> I feel like something like cryptol or Z3 could totally give you the answer... probably not quickly but it would be fun!
23:03:33 <fishythefish> > scanl xor 0 $ zipWith xor [0..254] [1..255] -- ertes
23:03:35 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
23:03:40 <Axman6> ha
23:04:05 <Axman6> > zipWith xor [0..254] [1..255] :: [Word8]
23:04:07 <lambdabot>  [1,3,1,7,1,3,1,15,1,3,1,7,1,3,1,31,1,3,1,7,1,3,1,15,1,3,1,7,1,3,1,63,1,3,1,7...
23:04:36 <Axman6> that's quite an interesting sequence
23:04:46 <ertes> > scanl xor 0 (zipWith xor [0..254] [1..255] :: [Word8])
23:04:46 <Axman6> @oesi 1,3,1,7,1,3,1,1
23:04:48 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
23:04:50 <lambdabot>  https://oeis.org/A111957 Triangle read by rows: T(n,k) = gcd(Fibonacci(n), L...
23:04:51 <lambdabot>  [1,1,1,1,1,2,1,3,1,1,1,1,1,1,1,1,1,4,1,1,2,1,1,1,1,1,1,1,1,3,1,7,1,3,1,1,1,1...
23:04:52 <fishythefish> note the analogy with repeat 1 = zipWith (-) [1..] [0..]
23:04:53 <dminuoso> fishythefish: How did you derive that?
23:05:05 <ertes> interesting, thanks, although i solved it differently now
23:05:13 <Axman6> @oeis 1,3,1,7,1,3,1,15,1,3,1,7,1,3,1,31
23:05:18 <lambdabot>  https://oeis.org/A038712 Let k be the exponent of highest power of 2 dividin...
23:05:18 <lambdabot>  [1,3,1,7,1,3,1,15,1,3,1,7,1,3,1,31,1,3,1,7,1,3,1,15,1,3,1,7,1,3,1,63,1,3,1,7...
23:06:25 <ertes> for_ (tail [0..255]) $ \dx' -> do let { dx = xor dx' (dx' - 1) }; for_ [0 .. Vum.length vec - 1] (Vum.unsafeModify vec (xor dx)); …
23:06:35 <ertes> this cycles 'vec' through all possible xors
23:06:42 <fishythefish> dminuoso: scanl (+) 0 and scanl xor 0 are both cumulative sums
23:06:48 <fishythefish> so the obvious thing to do is take first differences
23:07:02 <ertes> originally i had an undo step, which was rather stupid of me
23:07:36 <ertes> i think what i'm doing now is actually equivalent to that zipWith sequence
23:08:31 <ertes> yeah, it is:  zipWith xor [0..254] [1..255] = xor 0 1 : xor 1 2 : xor 2 3 : …
23:09:06 <fishythefish> if scanl (+) 0 xs = mySequence, then xs = zipWith (-) (tail mySequence) mySequence
23:09:19 <fishythefish> this generalizes to any addition, not just (+)
23:10:59 <fishythefish> (formally, I should specify that we're in a group or something)
23:14:39 * hackage iproute 1.7.4 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.7.4 (KazuYamamoto)
23:22:24 <ertes> just switching from unboxed to storable vectors just gave me a massive speedup with LLVM
23:25:21 <cocreature> ertes: interesting! is there also a speed improvement without the LLVM backend?
23:31:57 <ertes> cocreature: yeah, even with the native backend (-O -threaded)
23:32:30 <ertes> i can only assume that it's related to GC
23:32:48 <ertes> storable vectors come with the promise that they are never moved around in memory
23:33:02 <cocreature> not necessarily, it could also be cache effects. e.g. the Unbox instance for tuples will use two separate vectors
23:38:27 <ertes> i'm not using any tuples though
23:38:31 <ertes> it's all MVector Word8
23:38:57 <ertes> i'm heavily using MVector slicing and lots of reading and writing
23:39:14 <ertes> (i've basically written an abstraction for parsing directly from an MVector)
