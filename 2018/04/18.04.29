00:12:24 * hackage qnap-decrypt 0.3.1 - Decrypt files encrypted by QNAP's Hybrid Backup Sync  http://hackage.haskell.org/package/qnap-decrypt-0.3.1 (alexkazik)
00:35:24 <fr33domlover> How does GHC store Word8, Word16, Word32 etc. in memory?
00:35:34 <fr33domlover> Do they all have the same size at runtime?
00:35:48 <fr33domlover> Or is Word8 a single byte, Word16 two bytes etc.?
00:44:06 <fr33domlover> Hmm looks like all of them are machine word size
01:31:17 <Gigabitten> so I've encountered this very simple function and I'm confuzzled as to how this functions as it does
01:31:25 <Gigabitten> sum :: [Integer] -> Integer
01:31:34 <Gigabitten> sum xs = foldl (+) 0 xs
01:31:46 <Gigabitten> oh no I've put the wrong example in the chat
01:31:50 <Gigabitten> whoops
01:32:05 <Gigabitten> sum :: [Integer] -> Integer
01:32:12 <Gigabitten> sum = foldl (+) 0
01:32:16 <Gigabitten> there's the one
01:34:00 <Gigabitten> How can the compiler just know what you mean by that? and when on earth is this ever going to improve readability, or do anything other than cut down on keystrokes?
01:34:36 <ertes> Gigabitten: it doesn't
01:34:49 <JuanDaugherty> lol hs readability
01:34:53 <Gigabitten> I tested it in ghci, it definitely compiles
01:35:03 <Gigabitten> and behaves the same as the first one
01:35:16 <ertes> Gigabitten: yes, but the compiler doesn't "know" anything special here…  this is not a language/compiler feature
01:35:44 <ertes> Gigabitten: every function in haskell takes exactly one argument…  the way you implement multiple arguments is by currying
01:35:58 <JuanDaugherty> readability has a wholly different meaning in haskell, consistent with the intent of the concept
01:36:06 <capisce> Gigabitten: in ghci, try ":t foldl", then ":t foldl (+)", then ":t foldl (+) 0"
01:36:14 <Gigabitten> yeah I'm aware of this, but this doesn't even have a single argument, it's just a function name
01:36:15 <JuanDaugherty> but quite different from that the masses understand
01:36:25 <ertes> Gigabitten: that is:  the type notation (A -> B -> C) really means (A -> (B -> C)), i.e. a type of functions that take an A and return a *function* of type B -> C
01:36:37 <JuanDaugherty> s/understand/intend/
01:37:11 <ertes> Gigabitten: let (f :: A -> B -> C) and (x :: A)…  if you apply f to x, the result is (f x :: B -> C)
01:37:28 <ertes> Gigabitten: now let (y :: B), then ((f x) y :: C)
01:37:40 <ertes> Gigabitten: and we have a shorter notation for that:  f x y
01:38:03 <JuanDaugherty> the masses mean 'in a language everybody here can easily understand', hs means concision
01:38:14 <ertes> Gigabitten: so the notation (f x y), i.e. "apply f to the arguments x and y", is in reality a notation that applies f to x, and then applies the resulting function to y
01:38:55 <Gigabitten> ok, that all makes sense
01:39:03 <ertes> Gigabitten: that's why you can write (sum = foldl (+) 0), because (foldl (+) 0) *is* a function
01:39:18 <ertes> and you're defining 'sum' to be that function
01:40:13 <Gigabitten> ...but it's still got no argument in the equation. I still don't see how a function with no arguments can produce anything but one output. I got everything you just said except the last part.
01:40:15 <capisce> you could do sumStartingAt = foldl (+), and sum = sumStartingAt 0
01:40:18 <Gigabitten> maybe that means I didn't geet it?
01:40:29 <capisce> Gigabitten: it's a function that takes one argument
01:40:39 <ertes> Gigabitten:
01:40:42 <capisce> sum :: [Integer] -> Integer
01:40:54 <ertes> foldl :: (r -> a -> r) -> r -> [a] -> r
01:41:10 <ertes> foldl (+) :: (Num a) => a -> [a] -> a
01:41:11 <capisce> that argument is implicit in the definition of sum
01:41:15 <ertes> foldl (+) 0 :: (Num a) => [a] -> a
01:41:26 <ertes> Gigabitten: do you see that this is a function?
01:42:54 <Gigabitten> yeah, I see that foldl (+) 0 is a function which starts at 0 and sums the list up from the left.
01:43:20 <ertes> Gigabitten: then what stops you from giving that function a name?
01:43:27 <ertes> Gigabitten: sum = foldl (+) 0
01:43:52 <Gigabitten> christ ok
01:43:56 <Gigabitten> I get it now
01:43:58 <Gigabitten> Haskell is hard
01:44:12 * JuanDaugherty 2nd lol
01:44:18 <Gigabitten> I'm a math major. I thought that would protect me
01:44:29 <capisce> not so hard, this is just the first time you encounter this kind of syntax
01:44:29 <fishythefish> well, it's similar in math
01:44:38 <fishythefish> we routinely write h = g ∘ f rather than h(x) = g(f(x))
01:44:40 <ertes> Gigabitten: haskell is logical…  you just need to learn the basic rules, and those can be alien, if you're used to less logical languages =)
01:45:05 <ertes> Gigabitten: keep this in mind: *every* function in haskell takes *exactly* one argument, no exceptions
01:45:08 <Gigabitten> I'm used to that notation for function composition at least
01:45:13 <fishythefish> h is clearly a function despite the fact that we haven't explicit said what it does when applied to an argument
01:45:19 <fishythefish> explicitly*
01:45:46 <Gigabitten> you know
01:46:03 <Gigabitten> what's the name of that property that allows you to substitute wherever
01:46:14 <fishythefish> referential transparency?
01:46:15 <xacktm> referential transparency?
01:46:18 <capisce> Gigabitten: in Haskell that can be expressed as h = g . f, instead of having to write h x = g (f x)
01:46:21 <Gigabitten> yeah that.
01:46:31 <Gigabitten> I think referential transparency is going to be my best friend
01:46:37 <fishythefish> :)
01:46:46 <fishythefish> it is a very nice property
01:46:50 <ertes> Gigabitten: yes, it allows you to use equational reasoning
01:47:18 <Gigabitten> capisce: oh, is that so? that's a nice property.
01:47:28 <ertes> if (foldl (+) 0) is a function and you say (sum = foldl (+) 0), then clearly 'sum' is a function, too
01:47:41 <capisce> Gigabitten: (.) is the function composition operator in Haskell
01:47:44 <capisce> Gigabitten: (.) :: (b -> c) -> (a -> b) -> a -> c
01:48:09 <capisce> g . f is the infix way of using it
01:48:13 <ertes> Gigabitten: note that (.) is just a regular function defined in a library…  you could define it yourself
01:48:18 <capisce> (.) g f is the prefix way
01:48:30 <ertes> compose f g x = f (g x)
01:48:34 <fishythefish> @src (.)
01:48:34 <lambdabot> (f . g) x = f (g x)
01:48:44 <capisce> symbol-functions need to be enclosed in parentheses to be used in a prefix manner
01:48:49 <Gigabitten> ertes: it's ok, I've figured it out now. this is a really good IRC.
01:49:24 <ertes> Gigabitten: exercise: how many arguments does foldl take?
01:49:35 <Gigabitten> uh, one?
01:49:39 <ertes> Gigabitten: good =)
01:50:09 <Ariakenom> :t id
01:50:10 <lambdabot> a -> a
01:50:18 <Ariakenom> > id id id id id 1
01:50:20 <lambdabot>  1
01:50:24 <Gigabitten> what did you expecct
01:50:43 <fishythefish> it's demonstrating that id apparently takes 5 arguments :P
01:50:54 <capisce> Gigabitten: every function taking one argument is called "currying", defining sum without explicitly specifying the parameters is called "pointfree style"
01:50:57 <capisce> Gigabitten: https://wiki.haskell.org/Pointfree
01:51:03 <Gigabitten> man what an odd property. is decomposition of a multi-argument function just a property of lambda calculus?
01:51:27 <capisce> currying is named after Haskell Curry
01:51:30 <ertes> Gigabitten: lambda calculus shares that property, it too only has single-argument functions
01:51:49 <capisce> Gigabitten: https://wiki.haskell.org/Currying
01:51:51 <ertes> (although you could say that LC doesn't really have "functions")
01:51:55 <Gigabitten> although I'm sure in lambda calculus also it wouldn't be too hard to build a notation for multiple-argument functions for convenience
01:52:03 <Gigabitten> er, what does it have then?
01:52:32 <ertes> Gigabitten: in LC often the notation (λx y. _) is used as a shorthand for (λx. λy. _)
01:52:38 <ertes> haskell has that, too
01:52:59 <Gigabitten> yeah. I'm not surprised
01:53:11 <ertes> and whenever you write (f x y = _) it desugars to (f = \x y -> _) and then to (f = \x -> \y -> _)
01:53:36 <ertes> so "f x y = _" is really just a convenient syntax for named lambdas
01:53:54 <capisce> syntax sugar is convenience notation
01:54:13 <Gigabitten> yeah, I wouldn't want to write f = \x -> \y -> _ in a language that tries to cut down on excess typing
01:54:46 <Gigabitten> let's be honest, real programmers don't use Haskell, they just use Core
01:55:11 <capisce> how about complex programmers
01:55:14 <ertes> yeah, concise syntax is one of the most appealing things about haskell, but at the same time we maintain a very small core language that every haskell program "desugars" to, and that combination is really nice
01:55:35 <Gigabitten> capisce: real programmers no, complex programmers yes.
01:55:43 <ertes> > map (+ 3) [1..5]
01:55:44 <lambdabot>  [4,5,6,7,8]
01:55:51 <ertes> (+ 3) = \x -> x + 3
01:56:10 <Gigabitten> orthogonal programmers use Core, but they insist on calling it something else for clarity without realizing that by introducing another term they're only decreasing clarity.
01:56:33 <capisce> [4,5,6,7,8] is also syntactic sugar :)
01:56:49 <Gigabitten> actually what does a list desugar to
01:56:59 <Gigabitten> I never bothered to check
01:57:02 <ertes> Gigabitten: haskell uses cons lists
01:57:07 <Gigabitten> oh yeah forgot about that
01:57:16 <ertes> Gigabitten: every list is either of the form [] or of the form (x : xs), where xs is a list
01:57:16 <Gigabitten> is cons sugar?
01:57:26 <capisce> [1,2,3] is equivalent to 1 : (2 : (3 : []))
01:57:34 <capisce> or rather desugars to
01:57:45 <ertes> Gigabitten: here is a custom list type:  data List a = Nil | Cons a (List a)
01:58:04 <ertes> every (List a) is either Nil or (Cons x xs), where (x :: a), (xs :: List a)
01:58:36 <ertes> Gigabitten: [] (the type) is just a predefined version of this type
01:59:03 <ertes> data [a] = [] | a : [a]
02:00:04 <xacktm> :t (:)
02:00:05 <lambdabot> a -> [a] -> [a]
02:00:13 <Gigabitten> Haskell has such odd syntax, I end up having to look it up like four times before I memorize it lol
02:00:14 <xacktm> oh right
02:01:39 <Gigabitten> ertes: hey, how does that work? there's no pattern to match there after the guard. or maybe the syntax is just tripping me up there and a is the pattern?
02:01:50 <xacktm> odd is relative - for some people haskell is thier first language, so others are odd :P
02:02:02 <ertes> Gigabitten: there is no guard there…  that's how you define a type in haskell
02:02:10 <ertes> Gigabitten: data Bool = False | True
02:02:17 <Gigabitten> wait I forgot about that
02:02:21 <Gigabitten> darn
02:02:26 <ertes> Gigabitten: this declares that every Bool is either of the form False or of the form True
02:02:42 <Gigabitten> yeah yeah uh, I don't remember the name but it has a name
02:02:52 <Gigabitten> algebraic data type
02:03:09 <fishythefish> yes, in particular, a sum type
02:03:18 <Gigabitten> oh no there are kinds
02:03:43 <fishythefish> yes, but while you're starting out, you don't need to worry about kinds
02:03:52 <fishythefish> most things will have kind * for now
02:04:16 <Gigabitten> I'll take your word for it
02:04:54 <fishythefish> if you want, you can take ghci's word with the :k command
02:05:11 <fishythefish> :k Int
02:05:12 <lambdabot> *
02:05:31 <Gigabitten> what is :k
02:05:40 <JuanDaugherty> kind prolly
02:05:41 <fishythefish> shorthand for :kind, the same way you can use :t or :type
02:05:44 <Gigabitten> oh yeah that makes sense
02:05:58 <Gigabitten> the fact that "kind" is the actual word for it was dumb luck on my part
02:07:17 <fishythefish> oh, I see. "sum type" isn't a "kind" in the sense I was talking about
02:08:45 <Gigabitten> does universal currying slow down the compiler? I feel like it should but at the same time I could imagine how maybe it could speed it up too
02:09:05 <ertes> Gigabitten: we call types with multiple constructors "sum types"…  there is a deeper reason for why we use this particular wording, but don't concern yourself with that for now
02:09:10 <Gigabitten> maybe I don't want to know the answer because compilers are complicated and hard
02:09:39 <fishythefish> Gigabitten: GHC doesn't actually implement functions that way
02:09:47 <ertes> Gigabitten: the compiler either needs to be really clever, or it needs to use a non-traditional compilation scheme that is specifically made for lazy, curried languages
02:09:52 <ertes> Gigabitten: GHC does the latter
02:10:08 <ertes> so you don't need to worry about performance – most of the time =)
02:10:12 <fishythefish> a saturated function call (a function supplied with all of its arguments) generates different code than a partial application
02:11:29 <Gigabitten> yeah I can see that a curried function is certainly efficient. in fact, it seems like it would be pretty efficient to change functions which are passed constants and an argument to functions with only one argument in *any* language.
02:11:34 <fishythefish> note that the argument count here is based syntactically on what appears on the LHS
02:12:16 <Gigabitten> what's an LHS
02:12:20 <Gigabitten> how do I LHS
02:12:28 <ertes> Gigabitten: you might find this piece of information useful: GHC uses a kind of reduction algorithm to evaluate function applications instead of the more traditional function "calls"…  in fact there isn't even a "call stack"
02:12:44 <fishythefish> LHS = left-hand side
02:12:52 <Gigabitten> oh that's how I LH
02:12:54 <Gigabitten> *LHS
02:12:55 <Gigabitten> got it
02:15:11 * hackage util 0.1.6.0 - Utilities  http://hackage.haskell.org/package/util-0.1.6.0 (MatthewFarkasDyck)
02:18:16 <JuanDaugherty> i did a fresh install of ubuntu 17.10 yesterday and it seemed to install ghc. Is that possible?
02:19:30 <JuanDaugherty> (on a reformated partition, but it seems so odd that I'm thinking I musta somehow put it there)
02:20:48 <ertes> as for the reason i actually came here…
02:21:01 <fishythefish> JuanDaugherty: I don't see it on the manifest
02:21:02 <JuanDaugherty> (8.0.2 in /usr/bin)
02:21:11 <fishythefish> any chance you installed something that had it as a dependency?
02:21:17 <ertes> case (bs, x) of ("blah", A) -> _; ("blah", B) -> _
02:21:38 <ertes> where (bs :: ByteString), does this pattern-match compare bs to "blah" once or twice?
02:21:48 <JuanDaugherty> i think maybe it got dragged in somehow when I restored a user directory
02:23:34 <JuanDaugherty> and yeah a dependency is how i presume it actually happened
02:23:50 <Ariakenom> ertes: I haven't seen much about clever pattern compilations in GHC.
02:23:55 <Gigabitten> are there any particular cases where it's significantly better to not use pointfree? Now that I get it, this actually seems waay cleaner
02:24:05 <Ariakenom> Not sure if there are none or I haven't seen them though.
02:24:24 <ertes> Ariakenom: it does that in many cases, including view patterns
02:24:32 <ertes> it also has some limited CSE
02:25:07 <ertes> @pl \n = map (take n) . iterate (drop n)
02:25:07 <lambdabot> (line 1, column 4):
02:25:07 <lambdabot> unexpected "="
02:25:07 <lambdabot> expecting operator, pattern or "->"
02:25:10 <fishythefish> Gigabitten: yes, the main reason not to use pointfree is that it can be nigh impossible to decipher
02:25:11 <ertes> @pl \n -> map (take n) . iterate (drop n)
02:25:11 <lambdabot> ap ((.) . map . take) (iterate . drop)
02:25:13 <xacktm> I think a common point against it is sometimes pointfree obfuscates what the function is actually doing if you don't know how to read it
02:25:27 <ertes> Gigabitten: ^ here is a case you probably shouldn't write point-free
02:25:46 <ertes> :t liftA2 (+) (map . take) (iterate . drop)
02:25:47 <lambdabot> error:
02:25:47 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ [a]
02:25:47 <lambdabot>       Expected type: Int -> [[a]] -> [[a]]
02:25:48 <ertes> err
02:25:51 <ertes> :t liftA2 (.) (map . take) (iterate . drop)
02:25:52 <lambdabot> Int -> [a] -> [[a]]
02:25:59 <Gigabitten> ah, yeah, I figured that might happen every now and then
02:26:08 <ertes> this is kinda reasonable, but it's still harder to read than the pointful version
02:26:38 <Gigabitten> uh, is that the outfix (is outfix the word?) function composition operator?
02:27:00 <ertes> Gigabitten: hmm?  what's that?
02:27:04 <Gigabitten> the (.)
02:27:19 <ertes> Gigabitten: liftA2 comb f g x = comb (f x) (g x)
02:27:26 <ertes> Gigabitten: (.) is function composition
02:27:43 <Gigabitten> yeah my brain just ends up moving (.) to the right
02:28:07 <ertes> Gigabitten: liftA2 (.) f g x = f x . g x
02:28:18 <fishythefish> Gigabitten: "prefix", since it appears before its arguments
02:28:27 <Gigabitten> oh yeah that makes sense
02:28:53 <ertes> Gigabitten: liftA2 (.) (map . take) (iterate . drop) n = (map . take) n . (iterate . drop) n = map (take n) . iterate (drop n)
02:28:59 <Gigabitten> no pl
02:29:01 <Gigabitten> pls
02:29:14 <Gigabitten> what does that code do
02:29:35 <fishythefish> he's showing you what it does; that's not an implementation, just a translation
02:29:47 <ertes> Gigabitten: (liftA2 (.) (map . take) (iterate . drop)) is the point-free version of (\n -> map (take n) . iterate (drop n))
02:29:59 <Gigabitten> oh sorry I thought it was one thing
02:30:10 <ertes> Gigabitten: "=" doesn't always mean "definition", in general it just means "equals"
02:31:10 <Gigabitten> I'm glad I asked because there are clearly places where that notation is pointless
02:31:33 <Gigabitten> pun intended
02:32:49 * Ariakenom laughs politely
02:34:05 <ertes> @pl f x y = f y x
02:34:05 <lambdabot> f = fix flip
02:34:19 <ertes> @pl x y f = f y x
02:34:19 <lambdabot> x = fix (flip (flip . flip id))
02:39:46 <ertes> wow, i was so puzzled over why this one uses 'fix', but it was just a really stupid typo
02:39:52 <ertes> @pl \f x y -> f y x
02:39:52 <lambdabot> flip
02:39:55 <ertes> there we go
02:55:23 <Gigabitten> so there's this little exercise in Real World Haskell to make a version of the Data.List function tails that doesn't return the empty list at the end. my solution was myTails = init . tails
02:55:28 <Gigabitten> not sure if that's clever or cheap
02:58:21 <fishythefish> depends on what the exercise is designed to teach
02:59:36 <Gigabitten> oh yeah it was a complete circumvention of the lesson
03:00:05 <Gigabitten> I still found it amusing though
03:01:09 <fishythefish> well, combining existing functions to accomplish your goal is at the heart of functional programming
03:01:17 <fishythefish> but it doesn't give you much insight into the implementation
03:04:06 <Gigabitten> oh, well, later in the chapter it literally shows that you can do exactly what I did, so that's neat.
03:45:07 * hackage z3 4.3 - Bindings for the Z3 Theorem Prover  http://hackage.haskell.org/package/z3-4.3 (IagoAbal)
04:05:49 <hamastan> hSetEcho stdin False not working for me. i import System.IO and i made a function getCh that at first do this command (hSetEcho stdin False) and then it getChar into x, then it hSetEcho stdin True, and then return x. but even when i call getCh and type a Char in the terminal, i see the Char.
04:06:42 <hamastan> i want to not see the cahr
04:06:51 <hamastan> *char
04:07:58 <Gigabitten> hmm, why can't you pattern match on data types for cases when you've got a pretty generic function?
04:09:15 <hamastan> it is from graham hutton book. i copy his functions but in his result you see '-' instead of the chars you type. in my version somehow the first line is always seen. the game is hangman.
04:09:49 <fishythefish> Gigabitten: can you give an example? I don't quite understand your question
04:09:55 <hamastan> but it seems i do what ho is doing and i can't find the difference
04:10:14 <hamastan> i'll copy all the function of the game and paste it. please wait :-)
04:12:28 <Gigabitten> hmm, let me put together the smallest bit of code I can think of which shows my problem
04:13:20 <hamastan> fishythefish: the game is like this: you enter a word and then the second player need to guess it. so i need to enter a word but the second player should not see it and because of this i need to mask all the words (graham do it with '-').
04:13:21 <fishythefish> Gigabitten: do you mean that you have a polymorphic function (e.g. a -> Bool) and you'd like to inspect the actual type substituted for `a` in a given invocation?
04:13:37 <fishythefish> hamastan: okay?
04:13:52 <Gigabitten> uh, actually I think you may have hit the nail on the head
04:13:58 <hamastan> here is the game: http://lpaste.net/365371
04:14:48 <fishythefish> Gigabitten: this is essentially a design choice - Haskell has parametric polymorphism, which means your function must behave the same regardless of which type is substituted
04:15:26 <hamastan> you can ignore the strleng dunction :-)
04:15:40 <fishythefish> you can use typeclasses for some ad-hoc polymorphism, but in general you are more constrained than other languages in which you can do ad-hoc polymorphism e.g. by merely overloading
04:15:52 <fishythefish> on the other hand, parametric polymorphism is very nice for reasoning
04:18:23 <Gigabitten> okay, so the thing I'd like to be able to do is basically this: http://lpaste.net/365372 While I could just write two different functions, one for the String case and another for the Bool case, this is annoying.
04:18:47 <Gigabitten> uh, sorry, I made a typo
04:19:02 <Gigabitten> that should be getExample :: Example -> a
04:19:22 <Ariakenom> Gigabitten: that doesnt type check either
04:19:31 <fishythefish> line 4 is incorrect in any case, since Example is not a constructor
04:19:39 <Gigabitten> yeah I know
04:19:42 <Gigabitten> that's the point though
04:19:48 <fishythefish> you should have `getExample (Ex1 s) = ...` and `getExample (Ex2 b) = ...`
04:20:26 <Gigabitten> yeah but the behavior of getExample (Ex1 s) and getExample (Ex2 b) are exactly the same
04:20:42 <fishythefish> so write `getExample = id`?
04:21:19 <fishythefish> it's not clear to me what the intent of this function is, since the implementation disagrees with the signature
04:22:18 <Ariakenom> Gigabitten: write the type you would like for your function. The current one doesnt make sense
04:22:33 <Gigabitten> yeah sorry I wrote it up there
04:22:42 <Gigabitten> I recognized immediately that I made a mistake in the paste
04:22:51 <fishythefish> IMO the type is valid; the implementation is off
04:23:13 <Ariakenom> "Example -> a" would match "Example -> Int" or "Example -> IO ()"
04:23:14 <fishythefish> Gigabitten: Example -> a doesn't work; a could be *anything*
04:23:23 <Gigabitten> ...that's the point
04:23:56 <fishythefish> so what exactly is the issue? how are you trying to use this function such that Example -> a is what you need?
04:24:17 <Gigabitten> the intent is to take something of type Example (a string or a bool) and just return the value without the Example type attached to it
04:24:26 <fishythefish> that's not possible
04:24:39 <Gigabitten> oh.
04:24:52 <fishythefish> Haskell doesn't have untagged unions; there's no type which represents the union of String and Bool without a constructor
04:25:11 <fishythefish> your Example type is exactly what you'd use (apart from some renaming, perhaps)
04:25:28 <fishythefish> then when you actually need to dispatch on whether you have a String or Bool, you pattern match on the constructors
04:25:40 <Ariakenom> Well it doesn't make sense. You shouldn't type check both getExample ex + 1 and getExample ex ++ "world"
04:26:57 <statusfailed> Ariakenom: unless an Example can at all times be *both* a number and a string :D
04:27:45 <fishythefish> instance Num String would be orphaned though
04:32:19 <tomlambda> How would you use ReaderT here http://lpaste.net/365374  I'm not sure where to start.
05:07:58 <lyxia> tomlambda: looks like you have three parameters that never change
05:09:46 <lyxia> so every time you have  (f key aucTXID coinTXID)  you could replace that with  f  and change the type of f from   (f :: Key -> AucTXID -> CoinTXID -> x -> IO y)   to   (f :: x -> ReaderT Env IO y)   with   (type Env = (Key, AncTXID, CoinTXID))
05:19:21 <hamastan> > import System.IO
05:19:23 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
05:19:44 <tomlambda> lyxia - Thanks, what is x?
05:26:58 <lyxia> tomlambda: any extra argument f may have
05:27:36 <physicist__> so I install
05:28:18 <Ariakenom> Hm, this was convenient for early exit.
05:28:20 <Ariakenom> (?) = when; infixr 1 ?
05:41:52 <hamastan> how can i getChar but not to print what i enter to the screen?
05:44:47 <Franciman> Hi, does anybody use ghcid?
05:45:15 <Franciman> I have this issue: when I close it, the underlying ghc process doesn't stop
05:45:54 <Franciman> I have ghcid-0.7
05:50:55 * hackage influxdb 1.6.0.2 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-1.6.0.2 (MitsutoshiAoe)
05:55:13 <vaibhavsagar> Franciman: I don't think I have this issue. How are you exiting ghcid?
05:55:21 <Franciman> Ctrl-C
05:55:28 <Franciman> Ctrl-c *
05:55:32 <Franciman> how do you exit?
05:55:39 <vaibhavsagar> same
05:57:34 <Franciman> hmm strange
06:00:20 <vaibhavsagar> can you do a `killall ghci` and try again?
06:00:42 <vaibhavsagar> or a `killall ghc`?
06:01:51 <Quoo2yah> What problems would arise if we treated values as a 0-arg functions? Partial application would be broken, right? I.e. after partially applying all args we would get a thunk instead of the actual output, so we need a special "call" operator. Could this be useful in a strict language?
06:07:35 <MrLawrence> Hello, if I want to control some html tags like buttons and text boxes with Haskell, how can I do it? I want something very simple.
06:09:54 <vaibhavsagar> MrLawrence: how would you like this to work?
06:10:34 <vaibhavsagar> alternatively: how would you expect this to work in a language like Python or Java?
06:11:22 <vaibhavsagar> you write some (Haskell|Python), ???, and the DOM gets updated
06:11:29 <vaibhavsagar> what happens in ???
06:11:56 <MrLawrence> For example, the user clicks on a button and that calls a function in Haskell which extracts data from a text box, processes it in some manner, and then it gets updated in the document.
06:13:25 <vaibhavsagar> would you be willing to consider something like PureScript?
06:13:53 <vaibhavsagar> there are definitely ways to do what you want in Haskell but I don't think any of them are simpler than PureScript
06:14:50 <MrLawrence> Well, my constraint is time, I wouldn't want to use a technology that is hard to make work or hard to learn about, so long as that's not the case then sure.
06:15:46 <vaibhavsagar> okay, in that case I would recommend PureScript
06:16:01 <Tuplanolla> If you don't want to install or learn anything, what other choices do you have besides JavaScript, MrLawrence?
06:19:09 <MrLawrence> It's not that I don't want to learn or install, but that I don't want to learn how to setup or learn about something complicated (this is kind of subjective). In terms of web technologies I have only played with HTML, CSS and JS. I'm afraid not much else otherwise Tuplanolla .
06:25:22 <vaibhavsagar> MrLawrence: you might like Elm or PureScript
06:26:09 <vaibhavsagar> Haskell's a great language, but it wouldn't be my first choice for frontend web development
06:26:29 <vaibhavsagar> I think it would shine as a backend though
06:27:53 <MrLawrence> vaibhavsagar, How would you use it as a back-end? how would it communicate with the outside world?
06:27:55 * hackage cautious 0.3.0.0 - Keep track of warnings and errors during calculations.  http://hackage.haskell.org/package/cautious-0.3.0.0 (NickskeVdb)
06:28:12 <zezeri> https://pastebin.com/KRkfBUmC
06:28:14 <zezeri> why does this not work?
06:28:18 <zezeri> where is my error
06:28:24 <vaibhavsagar> MrLawrence: I'd use something like Servant or Scotty as an API server
06:28:26 <zezeri> its 2 lists with elements of integers
06:28:34 <zezeri> and i put parentheses for the negative numbers
06:28:47 <zezeri> then i used the cons operator to put one list in front of the other
06:28:49 <zezeri> that should work
06:28:59 <vaibhavsagar> zezeri: you cons an *element* onto a *list*
06:29:13 <zezeri> im so stupid.
06:29:15 <vaibhavsagar> you're trying to concatenate two lists together
06:29:22 <MrLawrence> use ++
06:29:22 <vaibhavsagar> no, you're not :)
06:29:24 <zezeri> thank you :D vaibhavsager
06:29:34 <vaibhavsagar> no worries
06:30:23 <vaibhavsagar> MrLawrence: AFAICT the current trend in web dev is to have a frontend and a backend that communicate in a RESTful manner
06:30:43 <vaibhavsagar> it's not necessary that they are both in the same language
06:31:16 <vaibhavsagar> so it's possible to pick technologies that are well-suited for each of the two
06:31:16 <zezeri> if i do have a list of lists
06:31:21 <zezeri> then i can use ":" to add another list
06:31:28 <zezeri> because then the "lists" are just "elements"
06:31:29 <zezeri> right?
06:31:30 <vaibhavsagar> zezeri: yes
06:31:32 <zezeri> wohoo :D
06:31:44 <zezeri> you guys are really helpful, appreciate it :)
06:32:42 <vaibhavsagar> you're welcome!
06:33:21 * hackage cautious-gen 0.0.0.0 -   http://hackage.haskell.org/package/cautious-gen-0.0.0.0 (NickskeVdb)
06:35:14 <MrLawrence> Is it possible to call Haskell from C and exchange data between the two?
06:38:23 <hc> MrLawrence: yes it is
06:51:59 <[exa]> MrLawrence: there's Foreign Function Interface demo on the wiki
06:58:02 <MrLawrence> Yeah, I tried that but it fails on the last step with "test.c:(.text+0x1a): undefined reference to `__stginit_hs'"
07:45:32 <dmwit> MrLawrence: Did you link with GHC's RTS?
07:47:54 <dmwit> I think something like `ghc -no-hs-main test.c` or something like that.
08:00:19 <MrLawrence> Yeah I did dmwit
08:01:03 <dysfun> is hackage having a bad day?
08:01:51 <dysfun> search isn't working so well here
08:02:46 <dysfun> it seems to eventually load, but really slowly
08:04:18 <dysfun> ooh i just got a 504
08:04:51 * hackage rio 0.1.2.0 - A standard library for Haskell  http://hackage.haskell.org/package/rio-0.1.2.0 (MichaelSnoyman)
08:19:25 <maerwald> odd library
08:43:20 <Quoo2yah> What problems would arise if we treated values as a 0-arg functions? Partial application would be broken, right? I.e. after partially applying all args we would get a thunk instead of the actual output, so we need a special "call" operator. Could this be useful in a strict language?
08:44:28 <[exa]> Quoo2yah: why would that break partial application?
08:44:31 <phadej> Quoo2yah: that's how it works in Haskell
08:45:09 <Quoo2yah> phadej: I believe you are wrong.
08:45:41 <[exa]> well, after applying all args you actually get a thunk
08:45:48 <Quoo2yah> [exa]: because, as I've said, partial application will always give you a new function, never the final value
08:45:51 <aarvar> and there's no partial application in haskell
08:45:58 <aarvar> just application
08:46:59 <Quoo2yah> [exa]: yeah, but here by "thunk" I mean specifically a function of 0-args, not a lazy thunk that runtime uses to perform computation. You see what I mean?
08:47:11 <phadej> Quoo2yah: what's the difference?
08:47:18 <[exa]> Quoo2yah: there are special cases in the code that are meant to pull out some information from the thunk, like pattern matching and some special constructions. These evaluate the thunks to WHNF
08:47:22 <Quoo2yah> phadej: types
08:47:49 <phadej> Quoo2yah: but why you would like to separate them (in Haskell)?
08:50:22 <Quoo2yah> [exa]: so... I don't quite see the connection with my question to be honest?
08:50:34 <hpc> if you ignore bottoms, there's nothing you can do with the type () -> a, that you can't do with the type a
08:51:08 <aarvar> () -> a is still a function of one argument
08:51:09 <[exa]> Quoo2yah: if you'd want to apply that to a strict language, some of them have stuff like futures
08:51:11 <Quoo2yah> hpc: it's still a 1-arg function though
08:51:12 <aarvar> as are all haskell functions
08:51:19 <hpc> which is the closest thing i can imagine to "0-arg functions", since in haskell all functions take exactly one argument
08:52:29 <Quoo2yah> hpc: the question is rather about why this was chosen to be so and what problem arise otherwise, not about how Haskell actually works
08:52:47 <aarvar> why what was chosen to be so?
08:53:00 <hpc> well, if as you say, a function of 0 arguments is a "thunk", then what you've described is already how haskell works
08:53:14 <[exa]> Quoo2yah: it's described here http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
08:53:23 <Quoo2yah> aarvar: why zero arg function are not a thing (contrary to popular belief)
08:53:39 <aarvar> Quoo2yah: I don't know what a "zero arg function" is
08:53:40 <hpc> 0-arg functions aren't functions
08:53:44 <aarvar> are you asking why there aren't explicit thunks?
08:53:54 <hpc> a function is a mapping from input to output, but without input it's just a value
08:53:59 <aarvar> i.e. why the language is lazy by default rather than strict by default with explicit laziness?
08:54:42 <hpc> if you look at 0-arg functions in other languages, those are not functions at all in haskell
08:54:45 <hpc> :t getLine
08:54:46 <lambdabot> IO String
08:55:14 <Quoo2yah> hpc: once again, Haskell uses thunks as an implementation detail if you will. I'm talking about representing, say, Int as a hypothetical ( -> Int) function (sic: there's nothing on the left side). So (succ 1) would give you not 2, but a function from nothing to 2, with (-> Int) type. Haskell doesn't work that way.
08:55:16 <hpc> in those languages, "function" actually means "procedure with maybe some parameters"
08:55:41 <aarvar> Quoo2yah: no reason to call it a function
08:55:49 <aarvar> you're asking for an explicit Thunk type are you not?
08:56:20 <Quoo2yah> [exa]: I'll need some time to check that out, I'll take a look at it later. If it's actually relevant, thanks a ton :)
08:57:09 <monochrom> I don't think thunks are meant. I'm pretty sure the question is a terminology question.
08:57:28 <[exa]> Quoo2yah: it contains all the main design decisions for designing the evaluation system as is. Btw (succ 1) actually gives you a thunk. Thunks can be rewritten on run-time to values (they are _not_ readonly, but that's hidden)
08:57:31 <hpc> or a misunderstanding of non-strict semantics
08:57:33 <pzp> Is there a standard name for the function of type [(a -> a)] -> a -> a that takes an initial value and pipes the output from each function in the list to the input of the next function in the list?
08:57:39 <monochrom> People need to accept that most of the time definitions are due to convenience not Platonic truth.
08:58:08 <phadej> :t ala foldMap Endo
08:58:10 <lambdabot> error:
08:58:10 <lambdabot>     • Couldn't match type ‘Unwrapped (t a -> m)’ with ‘t a -> m’
08:58:10 <lambdabot>       Expected type: (Unwrapped (t a -> m) -> t a -> m)
08:58:18 <monochrom> You go to a number theory class and "natural numbers" exclude 0 there.  You go to a combinatorics class and "natural numbers" include 0 there.
08:58:18 <phadej> :t ala Endo foldMap
08:58:19 <lambdabot> Foldable t => t (b -> b) -> b -> b
08:58:20 <Quoo2yah> aarvar: no reason not to :P Occam's razor and stuff, if we can make *everything* a function - why not to try and see what pros and cons are? I'm asking specifically about the cons.
08:58:22 <aarvar> or foldr (.) id
08:58:26 <[exa]> pzp: afaik it's something like foldr ($)
08:58:43 <zezeri> how can i make my code in haskell more readable ?
08:58:55 <aarvar> define readable
08:58:59 <monochrom> Is it wrong to go to a number theory class and modify their definition to include 0?  No, it is not wrong, it is just pretty inconvenient for number theory purposes.
08:59:10 <zezeri> function_2 listOfLists = [[element | element <- list, even element]| list <- listOfLists]
08:59:15 <zezeri> can i split this up somehow?
08:59:23 <aarvar> dont use list comprehensions :)
08:59:47 <zezeri> what should I use instead :D?
08:59:53 <pzp> [exa] and aarvar : yeah that works
08:59:57 <pzp> thanks
09:00:04 <[exa]> zezeri: sounds like map.filter even?
09:00:08 <MarcelineVQ> nothing wrong with list comprehensions, but that first part can be written as  filter even
09:00:09 <zezeri> oh
09:00:17 <zezeri> i guess i will come to that later
09:00:21 <zezeri> thank you exa
09:00:27 <monochrom> The Haskell community wants "function" to have a type of the form X->Y for one convenience, and this bans "0-arg function".  The formal logic community wants constants to be 0-arg functions for a different convenience.
09:00:28 <aarvar> zezeri: listOfLists >>= filterEven
09:00:35 <aarvar> I think?
09:00:44 <zezeri> alright, will look into it aarvar
09:00:44 <[exa]> zezeri: if you want to see more patterns, try redefining the basic list functions as list comprehensions
09:00:44 <aarvar> woops, I mean filter even
09:00:47 <hpc> map (filter even), i think
09:00:58 <aarvar> bind isn't it?
09:00:59 <zezeri> am at the beginning of learning the language still, so some of the stuff you are telling me i guess will make sense only later
09:01:08 <hpc> if you don't want to flatten it
09:01:32 <aarvar> oh, nvm, that's two nested comprehensions
09:01:34 <aarvar> didn't notice
09:01:51 <Quoo2yah> monochrom: no, I believe it's not a terminology question, it's about semantics. Btw, in tacit languages that's exactly how (I think) values are modelled: 5 is a fn that puts a Num on the stack (or whatever it is they use). I'm not sure if there's much info on typing this kind of langs tho
09:02:17 <hpc> zezeri: i think the most readable form of that function is function_2 list = map (filter even) list
09:02:26 <[exa]> hpc: oh yes I put . there instead of parens ( <- zezeri)
09:02:47 <zezeri> alright thanks to you aal aarvar, hpc, exa :)
09:02:55 <zezeri> *all
09:02:57 <hpc> zezeri: and thanks to built-in optimizations around the standard functions, it'll even be faster
09:03:58 <zezeri> sweet :)
09:04:09 <zezeri> learning haskell makes java and C seem so easy LOL
09:04:17 <aarvar> hpc: why not eta reduce?
09:04:26 <monochrom> And semantics is supposed to be some kind of Platonic truth rather than an artificial definition convenience-optimized for a particular purpose?
09:04:46 <duncan^> Why does it make Java and C look easy? All languages have quirks and ways to do things.
09:05:04 <zezeri> obviously because my experience is very limited :D
09:05:19 <monochrom> When I said that the logic community wants constants to be 0-arg functions, they want it at the semantic level, too.
09:05:32 <Quoo2yah> monochrom: semantics is supposed to be the typing rules + evaluation rules
09:05:34 <zezeri> From the limited experience I do have, C and java have been somehow much more intuitive
09:05:48 <hpc> aarvar: readability - if you're not thinking in terms of function pipelines, signalling that the thing is a function with the explicit parameter is more useful for readers
09:05:48 <zezeri> but slowly i am getting it (i think :) )
09:06:07 <aarvar> hpc: disagree
09:06:13 <aarvar> it's distracting noise
09:07:17 <Quoo2yah> aarvar: well, if you don't have the type written out, it makes the code more readable imo
09:07:51 <aarvar> Quoo2yah: maybe due to lack of familiarity with haskell
09:08:29 <aarvar> Quoo2yah: and why wouldnt you have the type?
09:08:37 <Quoo2yah> aarvar: if by "familiarity with Haskell" you mean memorising signatures of every function you are to ever use - then yes :)
09:08:39 <aarvar> the editor will insert it for you
09:08:44 <monochrom> At any rate 1-arg functions work better for currying, n-arg functions with n>=0 work better for uncurrying.
09:08:44 <aarvar> you should know map
09:09:07 <monochrom> And "work better" means "more convenient" just to be clear.
09:09:18 <Quoo2yah> aarvar: re typesig - not everyone does that. re map - we're not talking about map in specific, are we?
09:09:52 <aarvar> Quoo2yah: well if you don't then you probably should
09:10:01 <aarvar> Quoo2yah: the particular example is map
09:10:09 <aarvar> though I'd say the same thing for most functions
09:10:16 <aarvar> if it's a simple eta reduction
09:11:19 <Quoo2yah> aarvar: I never said I don't do that, lol. In this particular example the difference is negligible, imo, but in general I agree with hpc (if you don't have the type written out)
09:12:27 <hpc> yeah
09:12:38 <hpc> even if you don't technically need it, the parameter still tells you something as a reader
09:12:40 <dminuoso> aarvar: There is partial application in haskell.
09:13:02 <aarvar> dminuoso: in what sense?
09:13:16 <aarvar> I've never seen it
09:13:26 <hpc> it's sometimes useful in the same way a type signature is (though not quite to the same magnitude)
09:13:30 <aarvar> how do I partially apply a function of exactly one argument?
09:14:21 <monochrom> "map even foo" partially applies even.
09:15:21 <aarvar> monochrom: lol
09:15:32 <hpc> let's get even more esoteric with this
09:15:37 <aarvar> problem is it doesn't apply even at all
09:15:37 <hpc> id undefined partially applies id
09:15:39 <aarvar> but other than that
09:15:49 <monochrom> More seriously I'm afraid "partial application" is just some kind of intuition not a formal thing.
09:15:51 <dminuoso> aarvar: Oh just in the sense that we so have actual partial application. It can be observed with functions taking multiple arguments.
09:16:03 <aarvar> dminuoso: uh, what?
09:16:15 <aarvar> there's no such thing as haskell functions which take multiple arguments
09:16:21 <dminuoso> > let f = \(!a) -> \b -> a + b in (f undefined) `seq` 1
09:16:23 <lambdabot>  *Exception: Prelude.undefined
09:16:30 <dminuoso> > let f = \(!a) b -> a + b in (f undefined) `seq` 1
09:16:32 <lambdabot>  1
09:16:34 <dminuoso> aarvar: ^-
09:16:39 <aarvar> dminuoso: where is the partial application?
09:16:40 <aarvar> I dont see one
09:16:46 <dminuoso> aarvar: The second case has a partially applied f.
09:16:53 <aarvar> I see a function of exactly one argument, which returns another function of exactly onea rgument
09:17:03 <dminuoso> aarvar: Pattern matching makes the difference visible.
09:17:06 <aarvar> and then you apply the function of one argument to the one argument, to get back the function of one argument
09:17:13 <aarvar> dminuoso: that's syntactic sugar
09:17:22 <aarvar> \a b -> a + b means \a -> \b -> a + b
09:17:23 <dminuoso> aarvar: Pattern matching doesnt kick in until all arguments have been supplied
09:17:25 <dminuoso> No its not.
09:17:30 <aarvar> dminuoso: yes it is
09:17:32 <dminuoso> That is only true up to strictness.
09:17:37 <dminuoso> Just look at my example.
09:17:50 <dminuoso> > let f = \(!a) -> \b -> a + b in (f undefined) `seq` 1
09:17:52 <lambdabot>  *Exception: Prelude.undefined
09:17:52 <hpc> dminuoso: huh
09:17:52 <dminuoso> > let f = \(!a) b -> a + b in (f undefined) `seq` 1
09:17:54 <lambdabot>  1
09:18:10 <hpc> oh, i see what aarvar means
09:18:17 <aarvar> huh
09:18:18 <monochrom> That's interesting. Perhaps GHC is doing it wrong.
09:18:19 <fakenullie> does reflex has somehting like "time machine" to revert dom state to some previous moment
09:18:21 <hpc> the seq on a is before the \b in the first example
09:18:24 <hpc> and after \b in the second
09:18:45 <aarvar> lol
09:18:50 <aarvar> almost fooled me
09:18:58 <hpc> > let f = \a -> a `seq` \b -> a + b in (f undefined) `seq` 1
09:19:00 <lambdabot>  *Exception: Prelude.undefined
09:19:10 <hpc> > let f = \a -> \b -> a `seq` (a + b) in (f undefined) `seq` 1
09:19:12 <lambdabot>  1
09:19:35 <aarvar> dminuoso: do that without a bang pattern
09:19:40 <dminuoso> aarvar: Use pattern matching.
09:20:01 <dminuoso> > let f = \(Just a) b -> a + b in (f undefined) `seq` 1
09:20:03 <lambdabot>  1
09:20:04 <dminuoso> > let f = \(Just a) -> b -> a + b in (f undefined) `seq` 1
09:20:06 <lambdabot>  <hint>:1:24: error: parse error on input ‘->’
09:20:10 <dminuoso> > let f = \(Just a) -> \b -> a + b in (f undefined) `seq` 1
09:20:12 <lambdabot>  *Exception: Prelude.undefined
09:20:35 <dminuoso> I admit its a bit of an edge case, but to say that Haskell has no pattern matching is not really true.
09:20:39 <dminuoso> *no partial applicationb
09:21:18 <monochrom> Now I have to read the Haskell Report.
09:21:21 <aarvar> dminuoso: sure it is
09:21:23 <hpc> those pattern matches desugar to case-of, iirc
09:21:28 <aarvar> haskell has no partial application
09:22:14 <maerwald> sounds right
09:22:16 <hpc> > let f = \a -> case a of (Just a) -> \b -> a + b in (f undefined) `seq` 1
09:22:18 <lambdabot>  *Exception: Prelude.undefined
09:22:28 <hpc> > let f = \a -> \b -> case a of (Just a) -> a + b in (f undefined) `seq` 1
09:22:29 <lambdabot>  1
09:22:44 <maerwald> depends how strict you are about definitions
09:23:00 <MrLawrence> Hello, I am trying to compile a Haskell program with GTK library (ghc-gtk-devel from Fedora) and when doing `ghc test.hs` it tells me it cannot find "-lHSutf8-string" and "-lHSmtl", where can I get these or point these right?
09:23:28 <monochrom> Oh interesting "(\p1 ... pn -> e) = (\x1 ... xn -> case (x1, ..., xn) of (p1, ..., pn) -> e"
09:23:51 <monochrom> in which p's are patterns, x's are variables.
09:24:37 <nshepperd> ghc has lots of partial application though
09:24:42 <monochrom> So "(\x y -> e) = (\x -> \y -> e)" requires x, y to be variables.
09:27:22 <dminuoso> monochrom: In my point of view that can be seen as partial application. After all the semantics of the function (wrt to pattern matching) doesn't kick in until all arguments have been specified.
09:27:39 <dminuoso> (or rather until the function has been applied to all necessary arguments)
09:33:43 <monochrom> What is partial application?
09:35:10 <maerwald> wikipedia has a definition with lambda calculus
09:39:18 * hackage tersmu 0.2.2 - A semantic parser for lojban  http://hackage.haskell.org/package/tersmu-0.2.2 (mbays)
09:46:25 <tomlambda> In ReaderT how do I set the value of r when wrapping a function in my ReaderT -  ReaderT \r -> -- your value of (m a)
09:47:40 <capisce> tomlambda: set the value of r?
09:48:17 <fr33domlover> :t runReaderT
09:48:18 <lambdabot> forall k r (m :: k -> *) (a :: k). ReaderT r m a -> r -> m a
09:49:32 <fr33domlover> :t local
09:49:33 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
09:49:42 <mniip> fascinating, I've found StateT in C++
09:49:43 <tomlambda> So ReaderT wraps a function which returns another monad in newtype. Say I want to set an env key how would I use the ReaderT to set such a key in order to avoid passing it down through many functions?
09:49:44 <mniip> http://en.cppreference.com/w/cpp/locale/codecvt/out
09:49:46 <dmj`> tomlambda: that initial value is set when you call runReaderT, the ‘r’ in ReaderT $ \r -> is assuming that initial value
09:51:01 <tomlambda> dmj - but runReaderT takes a ReaderT and just unwraps that function?
09:51:13 <tomlambda> How would that set the value?
09:51:54 <capisce> tomlambda: runReaderT takes a ReaderT as well as the value
09:52:55 <tomlambda> runReaderT :: r -> m a	
09:53:24 <tomlambda> So r is the ReaderT?
09:53:25 <dmj`> tomlambda: runReaderT executes a ReaderT r a with an r, and returns the a in an m
09:53:38 <glguy> :t runReaderT
09:53:39 <lambdabot> forall k r (m :: k -> *) (a :: k). ReaderT r m a -> r -> m a
09:53:45 <capisce> tomlambda: r is the value
09:54:09 <fr33domlover> runReadetT   ::   ReaderT r m a   ->   r   ->   ma
09:54:38 <fr33domlover> it takes the action and executes with the given environment
09:54:39 <dmj`> :t flip runReader (3::Int)
09:54:40 <lambdabot> Reader Int c -> c
09:54:42 <tomlambda> Oh I was looking at the wrong type signature
09:55:24 <capisce> tomlambda: https://www.fpcomplete.com/blog/2017/06/readert-design-pattern
09:55:24 <dmj`> > runReader ((+1) <$> ask) 4
09:55:26 <lambdabot>  5
09:57:44 <dmj`> tomlambda: by env key, you mean environment variable key?
09:57:51 <tomlambda> Yeah
09:58:50 <dmj`> :t flip runReaderT “FOO" $ do { key <- ask; liftIO (setEnv “FOO” “”); }
09:58:51 <lambdabot> error: lexical error at character 'F'
09:59:29 <hpc> ... did you write that in word or something?
09:59:30 <jared-w> You're using fancy quotes, not normal quotes
09:59:32 <dmj`> :t \someKey -> flip runReaderT someKey $ do { key <- ask; liftIO (setEnv key mempty); }
09:59:33 <lambdabot> error:
09:59:33 <lambdabot>     Variable not in scope: setEnv :: t -> t0 -> IO a
09:59:39 <mdunn> I'm getting a Segmentation Fault: 11 when running a binary from the command line. How can I get the segfault dump?
09:59:52 <dmj`> tomlambda: import System.Environment
10:00:13 <dmj`> jared-w: yea this Nimbus IRC client appends fancy quotes.
10:00:47 <tomlambda> dmj - thanks was  mainly using env key as an example though
10:01:02 <jared-w> that's silly for an irc client lol
10:02:15 <tomlambda> So does ReaderT r m a wrap the entire function that needs access to the r?
10:02:37 <dmj`> jared-w: I agree
10:02:39 <glguy> ReaderT is just a newtype for functions, there's no magic
10:03:49 <dmj`> @unmtl ReaderT r m a
10:03:49 <lambdabot> r -> m a
10:06:07 <tomlambda> I guess its so general and simple I am not sure how to actually use it
10:06:09 <tomlambda> hehe
10:06:36 <tomlambda> I know it can emulate global state but I am not sure how to do that in practice
10:07:10 <Ariakenom> > id id
10:07:12 <lambdabot>  error:
10:07:12 <lambdabot>      • No instance for (Typeable a0)
10:07:12 <lambdabot>          arising from a use of ‘show_M87677870605128195523245’
10:07:38 <glguy> :t id id -- you generally can't print functions
10:07:38 <lambdabot> a -> a
10:10:53 <tomlambda> Ok so I guess a naive reader example for a key would be keyReader = ReaderT $ \f -> f "key1"
10:11:06 <tomlambda> How do I adjust this example if f is an IO action
10:12:59 * hackage cabal-debian 4.38 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.38 (DavidFox)
10:13:04 <dmj`> tomlambda: f there isn’t a function, but your reader state. You could make your reader state a function, but I’m not sure that’s what you’re trying to do
10:14:52 <tomlambda> I am trying to set f to be a function perhaps not a good idea. So f is determined by the second arg to runReaderT?
10:15:55 <glguy> Maybe you could explain to use what this code means:  newtype ReaderT r m a = ReaderT (r -> m a)
10:16:11 <capisce> tomlambda: the r can be a function type too yes
10:16:23 <dmj`> tomlambda: In that snippet you pasted, you’re saying that the function ReaderT wraps is a higher-order function. A function that takes a function, what capisce said.
10:16:25 <maerwald> hpc: I wonder if that should be documented in fbut: https://github.com/quchen/articles/blob/master/fbut.md
10:16:42 <maerwald> it's not there afais
10:17:12 <maerwald> arguably not that "frequent" though
10:18:05 <tomlambda> Perhaps its better for me to post a link to the problem I am actually trying to solve with ReaderT http://lpaste.net/365374
10:18:36 <tomlambda> So in that example I want to use ReaderT to avoid the explicit passing of function args that dont change
10:19:16 <EL_N3ciO> buenas
10:19:16 <capisce> tomlambda: that seems different from passing a function that returns an IO action
10:19:39 <capisce> tomlambda: for that you could use liftIO btw, as long as ReaderT is somewhere on top of IO in the monad transformer stack
10:19:56 <hpc> maerwald: maybe as part of the "f x is not f = \x" section?
10:19:57 <capisce> tomlambda: for this, maybe you want to make the r a record type containing several parameters
10:21:00 <dmj`> tomlambda: you might want to make a monad stack for this:
10:21:00 <dmj`> type Bidder = ExceptT PostTXError (ReaderT Config IO) PostTXResponse
10:22:01 <tomlambda> thanks
10:22:16 <dmj`> (exitCode, stdOut, stdErr) <- postTx =<< FakeBidTXin . uncurry3 <$> ask
10:22:22 <capisce> dmj`: I saw https://www.fpcomplete.com/blog/2017/06/readert-design-pattern recommends avoiding ExceptT, they have a chapter about it
10:23:06 <glguy> It's also often better to avoid ReaderT, too
10:23:17 <capisce> dmj`: although maybe that's for concurrent code
10:23:44 <jared-w> glguy: for what? Just using raw Reader?
10:23:53 <glguy> Using functions
10:24:18 <jared-w> er, I meant, if it's better to avoid ReaderT, what should you use instead
10:24:24 <jared-w> (unless that is what you meant)
10:24:25 <glguy> functions
10:24:37 <jared-w> gotcha :) less abstraction mo betta?
10:25:51 <maerwald> hpc: I'm opening an issue
10:25:52 <capisce> more functions more good
10:26:58 <capisce> in Haskell, saying "use functions" isn't really saying much
10:27:03 <dmj`> capisce: it’s true that ExceptT doesn’t do any kind of exception handling for you, and that can unintentionally mislead newcomers, but I’m not sure that means it should be avoided. It’s nice for returning your own custom errors after they have been caught. I’d also argue against throwing exceptions as control flow logic.
10:30:20 <tomlambda> If it isnt too much bother could someone explain this for me (exitCode, stdOut, stdErr) <- postTx =<< FakeBidTXin . uncurry3 <$> ask
10:30:35 <tomlambda> specifically uncurry3
10:30:54 <tomlambda> :t uncurry3
10:30:55 <lambdabot> error:
10:30:55 <lambdabot>     • Variable not in scope: uncurry3
10:30:55 <lambdabot>     • Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
10:31:09 <dmj`> tomlambda: uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
10:31:22 <tomlambda> thanks
10:31:46 <dmj`> uncurry3 f ~(a,b,c) = f a b c
10:32:33 <capisce> dmj`: ~?
10:32:40 <dmj`> tomlambda: it should probably be “uncurry3 FakeBidTXin <$> ask”, assuming your state is a tuple of 3 elements, in your case, (Key, Auc, Coin)
10:33:09 <dmj`> capisce: irrefutable pattern match
10:33:33 <dmj`> capisce: https://stackoverflow.com/a/6712023
10:34:00 <tomlambda> (exitCode, stdOut, stdErr) <- postTx  - how does this work?  I have only seen the bind arrow used like that in do blocks
10:34:57 <tomlambda> dmj - how would you set the (Key, Auc, Coin) state in the ReaderT?
10:35:35 <glguy> capisce: Yeah, it turns out that in a language like Haskell, hiding the function behind an abstraction ends up making more work and not paying off as often
10:35:45 <EvanR> tomlambda: that looks like it is indeed in a do
10:36:22 <EvanR> (exitCode, stdOut, stdErr) <- postTx by itself isnt valid
10:36:36 <glguy> the work "saved" from not applying functions is lost in uses of lifts and not having access to that function parameter when defining functions where it could have been available to guards and where clauses
10:36:52 <dmj`> tomlambda: when you call "flip runReaderT (key, auc, coin)”, that lets you access the tuple with "ask"
10:38:19 <maerwald> hpc: https://github.com/quchen/articles/issues/49
10:38:33 <hpc> nice
10:38:41 <capisce> glguy: I take it you're not a big Reader fan then
10:38:59 <EvanR> Reader by itself is rarely useful in my experience
10:39:11 <glguy> capisce: It's just not a way to structure a program, the type can be useful in isolated regions
10:39:18 <capisce> or ReaderT
10:40:04 <EvanR> ReaderT MyIOCrap IO might be useful as an implementation of your top level app monad
10:40:40 <glguy> If it's your top-level app monad it might  be useful as the implementation of an app-specific newtype
10:41:35 <EvanR> newtype App a = App { runApp :: ReaderT MyIOCrap IO a }
10:50:16 <DigitalKiwi> edwardk when is the live session for n00bs like me :|
11:00:29 <sm> DigitalKiwi: heh.. like he doesn't have enough windows to watch :)
11:00:58 <sm> you know there are some on youtube, right
11:01:11 <sm> (just not by edward)
11:01:17 <DigitalKiwi> I JUST WANT TO BE NOTICED
11:02:21 <DigitalKiwi> ImHTT asks if he's making an ios app...10 brownie points says that stands for I'm here to troll
11:08:19 <DigitalKiwi> I don't want to sign up just to ask what's haskell and what is it good for so someone else do it plz thnkx
11:10:24 <DigitalKiwi> edwardk spacemacs! <3
11:12:50 <EL_N3ciO> buenas
11:22:09 <Lepidora> I've got a function returning a [ ] of values, and I want to be able to call it recursively and in the end have it 'flatten out' all of the values to a single level array. I've got http://lpaste.net/5458439838741037056 so far, but I'm just creating arrays of arrays, which I don't want.
11:23:08 <Cale> Lepidora: concat
11:23:11 <Cale> :t concat
11:23:12 <lambdabot> Foldable t => t [a] -> [a]
11:23:23 <Cale> oh course, it gives you the fancy type signature :)
11:23:32 <Cale> :t concat :: [[a]] -> [a]
11:23:32 <lambdabot> [[a]] -> [a]
11:24:28 <Lepidora> Oh cool, let me look that up real quick
11:25:39 <jared-w> Dumb question, who wrote that really comprehensive fold tutorial article?  It specifically uses a lot of equational reasoning
11:30:08 <Lepidora> Cale: Will that work if I have mixed list and non list elements in my list?
11:31:37 <cocreature> Ariakenom: ertes wrote one iirc
11:31:43 <cocreature> eh ^ jared-w
11:31:59 <jared-w> yeeaaaaah that's the one, thanks
11:32:17 <Ariakenom> cocreature: eh?
11:32:21 <Cale> Lepidora: You by definition can't.
11:32:32 <Cale> Lepidora: Lists in Haskell are always lists of elements of the same type
11:32:39 <cocreature> Ariakenom: sry not sure how I managed to screw up nick completion this bad :)
11:33:22 <Lepidora> What about a definition like "data Sp = List [Sp] | Item Int"?
11:33:30 <Ariakenom> jar -> ar one delete
11:34:03 <Lepidora> Couldn't you have a list of Sp that holds both List [Sp] and Items?
11:35:50 <Cale> Yes, but that's a list of Sp then and not a list of lists :)
11:36:40 <Cale> (of course, some of the values of type Sp contain lists)
11:36:54 <Lepidora> Yeah, that's kinda what I meant
11:37:20 <Lepidora> I guess that makes sense
11:37:44 <Cale> But concat is going to want actual lists, and not Sp's, so you still have to do something recursive with Sp somewhere
11:38:01 <Cale> One thing you might consider is writing a function like:
11:38:13 <Lepidora> I came up with `run (List (x:xs)) = concat (run x:[(run (List xs))])`, and that seemed to work
11:38:56 <Cale> foldSp item list = f where f (Item n) = item n; f (List xs) = list (map f xs)
11:40:24 <dexterfoo> Cale: is that you talking about ApplicativeDo?
11:40:30 <Cale> yes :)
11:40:38 <dexterfoo> why is it bad?
11:40:58 <Cale> It's just very non-obvious how ApplicativeDo translates into operations
11:41:39 <Cale> Which is sort of okay a lot of the time, assuming you have legal instances, it will pick one of many possible desugarings all of which are equivalent
11:42:03 <Cale> But as soon as you care about performance, "one of these semantically equivalent programs" isn't really enough.
11:46:42 <dexterfoo> cool =]
12:00:19 <abhiroop> Can someone help me out with this? https://cs.stackexchange.com/questions/90511/can-we-define-the-functor-category-in-haskell-or-any-other-language-with-a-more
12:01:40 <cocreature> abhiroop: if you don’t care about it being Haskell, search for one of the category formalizations in Coq or agda
12:02:14 <Tuplanolla> I believe johnw has worked on those.
12:05:59 <endeavour_> What's the haskell equivalent of Seq.choose in F#? i.e. is there a function with the signature (a -> Maybe b) -> [a] -> [b]
12:08:14 <monochrom> I am not sure what Seq.choose does.  But perhaps it means catMaybes . map
12:08:16 <cocreature> :t mapMaybe -- endeavour_
12:08:17 <lambdabot> (a -> Maybe b) -> [a] -> [b]
12:10:19 <nshepperd1> @hoogle (a -> Maybe b) -> [a] -> [b]
12:10:19 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
12:10:19 <lambdabot> Distribution.Compat.Prelude.Internal mapMaybe :: () => (a -> Maybe b) -> [a] -> [b]
12:10:19 <lambdabot> CorePrelude mapMaybe :: (a -> Maybe b) -> [a] -> [b]
12:14:54 <endeavour_> ah, thanks :) mapMaybe seems to do the trick
12:17:16 <Cale> abhiroop: As for Haskell, have a look at Ed Kmett's "Hask"
12:19:24 <Cale> https://github.com/ekmett/hask -- there's a bunch of 80% baked stuff in here which redefines and generalises a lot of the category theoretical classes, and so you can define an instance of Category for natural transformations
12:21:17 <Cale> https://github.com/ekmett/hask/blob/master/src/Hask/Category.hs#L268
12:36:08 <abhiroop> Cale: at this part of the code I see he makes a natural transformation between categories itself an instance of a category. I was not aware of this
12:36:29 <abhiroop> But how do I make a Functor an instance of a Category
12:37:22 <abhiroop> *natural transformation between functors
12:44:51 <Cale> abhiroop: That is basically what he's doing, it's just that categories are being referred to by their arrows rather than their objects
12:45:11 <Cale> The category whose objects are functors has natural transformations for its arrows
12:47:20 <abhiroop> I see
12:47:48 <abhiroop> so Nat f . Nat g is the composition of the 2 functors f and g
12:51:22 <Cale> no, it's the composition of those natural transformations between functors
12:52:06 <Cale> The objects of the category (which occur at the type level as the 3rd and 4th arguments to Nat) are functors :)
12:53:27 <DigitalKiwi> edwardk NIX!
12:53:50 <maerwald> ?
12:54:04 <DigitalKiwi> puffnfresh you tell them
12:54:48 <DigitalKiwi> puffnfresh and send them to tonys 80 tweet twitter rant
12:56:19 <Cale> DigitalKiwi: it might be better to put stuff in twitch chat if you want Ed to see it?
12:57:13 <DigitalKiwi> mhr
12:57:32 <cocreature> or the gitter that he created specifically for this
12:57:49 <DigitalKiwi> I don't like twitch or gitter
12:58:03 <cocreature> gitter has an irc bridge iirc
12:58:19 <cocreature> eh it’s discord not gitter
12:58:31 <DigitalKiwi> IRC OR BUST
12:58:43 <cocreature> either way without context those messages don’t really fit here
12:59:02 * DigitalKiwi provides context
12:59:36 <DigitalKiwi> to new people that ask if they should use cabal or stack, cabal/cabal+nix, stack causes too many problems
12:59:52 <DigitalKiwi> write that down!
12:59:54 <hexagoxel> you can connect to twitch chat via irc directly
13:00:16 <DigitalKiwi> do I have to have a twitch account?
13:00:21 <hexagoxel> yes
13:00:31 <DigitalKiwi> then I don't like that
13:01:15 <cocreature> you don’t have to like it, just do it anyway :)
13:01:33 <infinisil> Hey, what's the double '' called?
13:01:38 <DigitalKiwi> see, that's where you're wrong, kid
13:01:43 <infinisil> E.g. `makeLenses ''Foo`
13:02:36 <glguy> infinisil: That's the syntax for resolving a type constructor name as a Template Haskell Name value
13:02:55 <glguy> DigitalKiwi: You can join twitch chat or not, but this isn't the place for twitch commentary in either case
13:03:03 <DigitalKiwi> w/e
13:03:07 <[exa]> infinisil: i'd go with 'quoted type'
13:03:18 <infinisil> Hmm alright thanks, template haskell stuff
13:03:35 <[exa]> if I got it correctly it's supposed to resemble the quote from scheme a bit
13:04:03 <glguy> The single ' version is for resolving value constructors to TH names:  'Just :: Name
13:04:07 <glguy> ''Maybe :: Name
13:04:53 <glguy> and then completely separately at the type level the DataKinds extension uses ' to promote a value constructor to a type constructor
13:05:20 <glguy> 'Just :: a -> Maybe a
13:55:44 <bodie_> why would I implement a compiler with haskell instead of ocaml?  I don't know that much about either
13:57:10 <duncan^> idk -you love haskell?
13:58:10 <hpc> because there exist better compilers in haskell than in ocaml to use as reference? :P
13:59:13 <Tuplanolla> Because then you don't have to name it after an animal, bodie_.
14:00:17 <[exa]> (...and choose a human instead! :D )
14:03:39 <DigitalKiwi> https://wiki.haskell.org/Applications_and_libraries/Compilers_and_interpreters for reference
14:07:32 <[exa]> bodie_: kindof suggest looking at CakeML (it's a very good compiler with a gazillion of layers and minilanguages) and thinking about whether it weren't simpler to write in haskell
14:12:04 <dmj`> What is the best pedagogical resource for learning about type-indexed monads
14:14:47 <dmj`> I’m writing a monadic DSL where value level terms construct a type level term. This type level term will then be reified into something interesting. The issue is that I need something like State s a where ’s’ is poly-kinded and can change on each invocation of bind.
14:15:04 <dmj`> I think type-indexed monads provide this.
14:16:50 <dmj`> I’d be interested in seeing a simple use of a type indexed state monad
14:17:40 <glguy> If you're planning on having a kind for the 's' other than * it won't be a state monad
14:19:05 <phadej> dmj`: https://hackage.haskell.org/package/indexed-extras-0.2/docs/Control-Monad-Indexed-State.html
14:21:11 <phadej> obviously you can have "phony" newtype IxPhony m i j a = IxPhony (m a) -- too
14:21:46 <dmj`> glguy: It’s ok if its not a state monad. Could be an identity monad that is parameterized by a singleton (poly-kinded phantom). I just need this phantom type to be able to be changed.
14:22:22 <phadej> dmj`: the two index approach is most sane
14:22:54 <phadej> either vai `m i j a`, or then Category `cat a i j`
14:23:05 <phadej> depends on what better suits your DSL
14:23:20 <phadej> either with*
14:26:14 <dmj`> phadej: nice, is there an indexed indentity perhaps ?
14:26:25 * hackage zeromq4-patterns 0.3.0.0 - Haskell implementation of several ZeroMQ patterns.  http://hackage.haskell.org/package/zeromq4-patterns-0.3.0.0 (hverr)
14:27:36 <phadej> dmj`: Those packages are underdeveloped
14:29:04 <dmj`> phadej: Ah, that’s ok, I care more about the concept, and how to write it myself.
14:29:23 * hackage om-elm 1.0.0.3 - Haskell utilities for building embedded Elm programs.  http://hackage.haskell.org/package/om-elm-1.0.0.3 (taphu)
14:31:13 <phadej> dmj`: I think the IxPhony is your `Indexed identity`
14:34:34 <piark_> bye
14:45:30 <dmj`> phadej: where do you see IxPhony
15:17:06 <ertes> @where foldrtut
15:17:07 <lambdabot> http://ertes.eu/tutorial/foldr.html
15:17:08 <ertes> jared-w: ^
15:17:41 <jared-w> ertes: thanks :) I already grabbed it. It's my favorite fold tutorial and I wanted to share it with some friends of mine who are in a FP class right now
15:19:37 <ertes> great =)
15:36:46 * hackage scotty-resource 0.2.0.2 - A Better way of modeling web resources.  http://hackage.haskell.org/package/scotty-resource-0.2.0.2 (taphu)
15:52:51 * hackage phoityne-vscode 0.0.23.0 - Haskell Debug Adapter for Visual Studio Code.  http://hackage.haskell.org/package/phoityne-vscode-0.0.23.0 (phoityne_hs)
16:00:13 * hackage haskell-dap 0.0.4.0 - haskell-dap is a GHCi having DAP interface.  http://hackage.haskell.org/package/haskell-dap-0.0.4.0 (phoityne_hs)
16:02:14 <d34df00d> Hey folks
16:02:29 <d34df00d> I'm trying to revive some old and failing package, and it has a nontrivial Setup.hs.
16:03:01 <d34df00d> So, where do I find componentsConfigs now?
16:07:30 <freeman42x]NixOS> silly question, google is failing me. how can I parse a list of int's? I tried: map (\n -> (read n) :: Int) words "1 9 3 4 -5" and other variants
16:08:05 <monochrom> I think this one just needs correct parenthesizing?
16:08:11 <hpc> > map read (words "1 2 3 4 -5") :: [Int]
16:08:13 <lambdabot>  [1,2,3,4,-5]
16:08:28 <hpc> you need parens around (words "the string")
16:09:09 <freeman42x]NixOS> ah, I forgot a $ sign map (\n -> (read n) :: Int) $ words "1 9 3 4 -5"
16:09:19 <freeman42x]NixOS> cheers
16:12:24 <d34df00d> > read <$> words "1 9 3 4 -5"
16:12:26 <lambdabot>  [*Exception: Prelude.read: no parse
16:12:31 <d34df00d> Ah, right.
16:12:34 <d34df00d> > read <$> words "1 9 3 4 -5" :: [Int]
16:12:36 <lambdabot>  [1,9,3,4,-5]
16:13:32 <edwardk>  digitalkiwi you can watch the stream after the fact on youtube but i have no chat options for you during that are 100% open
16:14:55 <DigitalKiwi> it's ok if I watch it again and want to talk I'll just make a throwaway account
16:15:09 <DigitalKiwi> I'm too stupid to understand much though so :(
16:15:20 <DigitalKiwi> I just like listening to you :|
16:15:29 <DigitalKiwi> TOTALLY NOT CREEPY
16:16:38 <edwardk> hah
16:28:45 <boxscape> is it, like, heavily frowned upon to use unticked promoted constructors or is it okay?
16:29:54 <exarkun> What's "unticked"?
16:30:20 <boxscape> :t undefined :: Proxy True
16:30:21 <lambdabot> Proxy 'True
16:30:22 <boxscape> this
16:30:39 <exarkun> ah, thanks
16:30:39 <boxscape> i.e. without the apostrophe
16:31:42 <lol-md5> https://repl.it/repls/SpiffyCyanMysql I'm trying to make Expr an instance of Functor, but I'm not sure what to do when the Expr is a Val, as on line 5.
16:31:50 <d34df00d> Right, I managed to fix Setup.hs of some package I'm trying to work with, and now it still fails to configure with a very helpful "setup: parsing output of pkg-config --modversion failed". How do I debug this?
16:32:26 <d34df00d> lol-md5: probably nothing.
16:32:41 <lol-md5> d34df00d just don't define it?
16:33:00 <d34df00d> By the looks of it, you only actually transform leaves constructed with the Var ctor.
16:33:05 <boxscape> what would you want to happen to the Int if the function is, say, Bool -> Bool?
16:33:14 <d34df00d> lol-md5: nope, you define it, but you write just fmap f (Val x) = Val x
16:33:38 <d34df00d> (Note that Val x on the left and on the right have different types)
16:33:51 <lol-md5> oh
16:34:05 <monochrom> This is analogous to "fmap f Nothing = Nothing" and "fmap f (Left e) = Left e".
16:34:15 <d34df00d> Yeah, that's a very good mental model.
16:34:23 <lol-md5> monochrom that helps, thanks
16:34:24 <monochrom> s/analogous/identical/
16:54:36 * hackage pier 0.1.0.0 - Yet another Haskell build system.  http://hackage.haskell.org/package/pier-0.1.0.0 (JudahJacobson)
17:10:07 <lol-md5> what's @free do?
17:10:14 <lol-md5> @free lol-md5
17:10:14 <lambdabot> Extra stuff at end of line
17:11:29 <hpc> @free map
17:11:30 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
17:11:36 <hpc> prints free theorems
17:11:49 <boxscape> @free traverse
17:11:49 <hpc> $map is... fmap iirc
17:11:50 <lambdabot> Extra stuff at end of line in retrieved type "(Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)"
17:11:59 <hpc> @free concat
17:12:00 <lambdabot> Extra stuff at end of line in retrieved type "Foldable t => t [a] -> [a]"
17:12:04 <hpc> hmm
17:12:09 <hpc> @free isJust
17:12:10 <lambdabot> isJust = isJust . $map_Maybe f
17:12:36 <hpc> :t fold
17:12:38 <lambdabot> (Monoid m, Foldable t) => t m -> m
17:12:38 <hpc> :t foldr
17:12:39 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
17:12:41 <hpc> darn
17:14:52 <hpc> anyhoo, theorems for free
17:14:57 <hpc> @where free
17:14:57 <lambdabot> http://andrew.bromage.org/darcs/freetheorems
17:15:16 <hpc> http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf
17:16:00 <hpc> they're theorems generated from nothing but parametricity and the type of the thing
17:17:46 <lol-md5> wow that's cool
17:18:12 <Axman6> there's also djinn:
17:18:34 <Axman6> @djinn (a -> b -> c) -> Maybe a -> Maybe b -> Maybe (a,b,c)
17:18:34 <lambdabot> f a b c =
17:18:34 <lambdabot>     case b of
17:18:34 <lambdabot>     Nothing -> Nothing
17:18:34 <lambdabot>     Just d -> case c of
17:18:34 <lambdabot>               Nothing -> Nothing
17:18:36 <lambdabot>               Just e -> Just (d, e, a d e)
17:19:39 <lol-md5> andrew.bromage.org/darcs/freetheorems times out for me, maybe it should be updated to reference https://github.com/lambdabot/lambdabot/blob/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Free.hs instead?
17:22:48 <d34df00d> Why can I write coerce :: DVS.Vector (v s') -> DVS.Vector (v s), but cannot write coerce :: v s' -> v s?
17:23:20 <Axman6> what is DVS.Vector?
17:23:29 <d34df00d> Axman6: Data.Vector.Storable.Vector
17:23:45 <Axman6> is that the class?
17:23:45 <d34df00d> Real code is at https://github.com/chetant/LibClang/blob/master/src/Clang/Internal/Monad.hs#L72 . I can replace the second unsafeCoerce with coerce, but not the first one.
17:23:46 <d34df00d> Why?
17:24:01 <Axman6> why? SoI can understand what you've actually written :\
17:24:21 <d34df00d> I mean, why I can replace the second unsafeCoerce in the linked code but not the first one :)
17:24:51 <d34df00d> Axman6: nope, that's the data type.
17:25:07 <Axman6> what is v s supposed to be in this case?
17:25:29 <d34df00d> Ah, that's the type class variable that's in Vector.
17:25:36 <d34df00d> (I guess I misread your question, sorry!)
17:26:02 <Axman6> just trying top figure out what the types of the values here are
17:26:41 <Axman6> I'm surprised you can use coerce without an Coercible instance
17:27:17 <d34df00d> Well, the compiler is supposed to derive those.
17:27:19 <MarcelineVQ> ghc generates those
17:27:32 <d34df00d> If it knows the role of the parameters does not affect the representation.
17:28:02 <Axman6> sure, but there's no mentnion that those instances exist in the constraint on the function
17:28:23 <Axman6> I would've thought you'd need a Coercible (v s) (v s') constraint or something
17:29:21 <d34df00d> If I replace DVS.Vector with [], I get a type error in the second case too.
17:29:22 <d34df00d> Wut.
17:29:54 <d34df00d> Couldn't match representation of type ‘v s'’ with that of ‘v s’ arising from a use of ‘coerce’ // NB: We cannot know what roles the parameters to ‘v’ have; we must assume that the role is nominal
17:30:15 <d34df00d> Totally reasonable. Why the typechecker accepts this code if it's DVS.Vector (v s) -> DVS.Vector (v s') instead of [v s] -> [v s']?
17:31:00 <crestfallen> hi in Data.List subsequences is defined ' subsequences = List.subsequencies ' .  Is that as far as I can read into the definition?
17:31:47 <Axman6> possibly because the instance for Vector is wonky - the instance that would be derived by GHC without any anotations would show that two Storable.Vectors are representationally the same. Just a guess though
17:31:59 <d34df00d> That actually makes sense.
17:32:15 <Axman6> crestfallen: is there an import at the top defining a module called List?
17:32:19 <d34df00d> Not sure how exactly ghc would come to that conclusion though.
17:32:24 <Axman6> like import qualified GHC.List as List?
17:32:57 <crestfallen> it says import qualified
17:33:18 <Axman6> crestfallen: ewhat does it say after that...
17:33:28 <crestfallen> sorry import qualified Data.List as List
17:33:31 <d34df00d> Is there a way to say that a role of a given type argument is phantom when defining a type class?
17:33:44 <crestfallen> but I don't know what that means
17:33:49 * hackage sensu-run 0.5.0.1 - A tool to send command execution results to Sensu  http://hackage.haskell.org/package/sensu-run-0.5.0.1 (MitsutoshiAoe)
17:34:14 <Axman6> that means it's importing the module GHC.List and calling it List, so anywhere you see List.foo, that's come from GHC.List
17:35:35 <crestfallen> ok, so > :info subsequences doesn't give a full def. I have a book example that returns the subsequences in a different order from the Data.List func. I wanted to see how its written
17:35:52 <d34df00d> > Roles other than ‘nominal’ for class parameters can lead to incoherence.
17:35:53 <d34df00d> Wut?
17:35:54 <lambdabot>  <hint>:1:18: error: lexical error at character 'n'
17:36:00 <crestfallen> pasting ...
17:36:37 <crestfallen> at the bottom of this paste is the books version : https://ptpb.pw/vXJy
17:36:44 <ania123> https://www.morganclaypool.com/doi/abs/10.2200/S00692ED1V01Y201601AIM032
17:36:51 <ania123> dies someone has a access to this paper?
17:39:29 <crestfallen> so when you load Data.List into ghci, :info doesn't show the full code. any way to see it from ghci ?
17:40:04 <Axman6> load GHC.List?
17:40:15 <Axman6> I never look at source code in GHCi
17:40:40 <MarcelineVQ> can that even be done?
17:41:22 <crestfallen> I'm here but cant read the source https://hackage.haskell.org/package/prelude-compat-0.0.0.1/docs/src/Data-List2010.html#subsequences
17:42:06 <crestfallen> sorry how to do this :
17:42:08 <MarcelineVQ> Axman6 said how to find more on List.subsequences a moment ago
17:42:39 <Axman6> that's definitely not the right package to be looking at
17:42:46 <crestfallen> I don't understand how to do it. missing fundamental
17:42:53 <Axman6> http://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.List.html
17:43:04 <ania123> does someone has a access to this paper?
17:43:04 <Axman6> I found that by searching in google for ghc.list
17:43:07 <ania123> https://www.morganclaypool.com/doi/abs/10.2200/S00692ED1V01Y201601AIM032
17:44:01 <Axman6> ania123: does this have anything to do with Haskell? and have you checked arXiv.org?
17:44:31 <Axman6> hmm, GHC.List doesn't seem to have permutations definied in it any more
17:45:21 <Axman6> crestfallen: try http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-List.html#v:permutations and click on the "Source" link at the right of the page
17:45:32 <crestfallen> will do thanks
17:46:25 <d34df00d> Axman6: interestingly, https://github.com/haskell/vector/issues/148 suggests the current behaviour with `a` being deduced as phantom for Data.Vector.Storable is wrong.
17:46:29 <d34df00d> So much for the safety.
17:47:19 <Axman6> yeah, as it is written it really is a phantom type
17:57:57 <crestfallen> Axman6, ok that func is pretty complicated:    [] : nonEmptySubsequences
17:58:55 <Axman6> IIRC the reason for it being to complicated is that it works on infinite lists with maximum laziness
17:59:15 <Axman6> > map (take 5) $ permutations [1..]
17:59:17 <lambdabot>  [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],[4,...
17:59:30 <crestfallen> I was hoping to compare that with https://ptpb.pw/vXJy  since the output is slightly different (the ordering)
17:59:40 <Axman6> > map (take 5 . drop 1000) $ permutations [1..]
17:59:42 <lambdabot>  [[1001,1002,1003,1004,1005],[1001,1002,1003,1004,1005],[1001,1002,1003,1004,...
17:59:52 <Axman6> > map (take 5) . drop 1000 $ permutations [1..]
17:59:54 <lambdabot>  [[3,5,2,4,7],[3,5,2,4,6],[7,3,5,4,2],[3,7,5,4,2],[3,5,7,4,2],[3,5,4,7,2],[3,...
18:00:37 <crestfallen> > subsequences [1,2,3]
18:00:39 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
18:01:40 <Axman6> ha, only just realised I kept talking about permutations when you wanted subsequences, my bad!
18:01:56 <crestfallen> Axman6, no worries yeah a bit confused
18:02:02 <crestfallen> I am
18:04:40 <crestfallen> can I enter in that entire subs func here ?
19:05:17 * hackage sbv 7.7 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-7.7 (LeventErkok)
19:16:00 <Illumine> why won't my client accept 4 'div' 2
19:16:15 <Illumine> Specifically, it wont accept 'div' being in between
19:16:29 <Illumine> but in haskell a function ith two arguments should be able to be activated in between
19:16:38 <Illumine>  why won't my client accept 4 'div' 2
19:16:38 <Illumine> Specifically, it wont accept 'div' being in between
19:18:40 <fishythefish> you need backticks, not single quotes
19:23:14 <johnw> Tuplanolla: on what?
20:34:22 * hackage brick 0.36.3 - A declarative terminal user interface library  http://hackage.haskell.org/package/brick-0.36.3 (JonathanDaugherty)
20:44:52 <ania123> does anyone has an access to this paper?
20:44:55 <ania123> https://www.morganclaypool.com/doi/abs/10.2200/S00692ED1V01Y201601AIM032
20:45:07 <Axman6> ania123: stop asking please
20:45:13 <ania123> ok
21:27:29 <dmj`> jle`: ping
21:39:36 <anhr> Hi
21:40:26 <anhr> Hi
21:40:54 <dmj`> anhr: Hi
21:53:04 <jle`> dmj`: pong
21:54:17 <jle`> edwardk: what's the etymology of 'auto' from ad?
21:54:32 <jle`> is it just a pun from 'automatic differentiation' ?
22:18:51 <gomii> hello hello
22:21:03 <gomii> Hi everyone
22:21:08 <spoonm> hello
22:21:50 <gomii> So why are there 1700+ people in here and no one is talking lul
22:24:08 <c_wraith> This is mostly a help channel (not entirely, but mostly).  No one needs help right now.
22:24:19 <jared-w> pretty usual. Most of us idle until someone starts talking about Zygohistomorphic prepromorphisms
22:24:51 <DigitalKiwi> I need more help than this channel can provide :(
22:24:59 <jared-w> We believe in you tho <3
22:25:58 <DigitalKiwi> thanks
22:26:58 <jared-w> You stuck on anything right now?
22:27:02 * jared-w is procrastinating on homework
22:27:14 * jared-w doesn't feel like writing MIPS assembly by hand
22:27:32 <jle`> gomii: most people usually just idle and read what happens
22:27:40 <spoonm> I have a question: how does one go from an IO action to an action in any other monad? basic haskell question I could look up, but hey, why not ask here?
22:27:53 <jle`> spoonm: it depends on the type you want to go to
22:28:07 <jle`> spoonm: consider a similar question "how would one go from a 'Maybe a' to a 'm a' of any other m?"
22:28:25 <spoonm> perhaps unwrap the a and wrap it again in m?
22:28:26 <jle`> it really doens't make sense to ask the question in general
22:28:35 <jle`> since every m is different
22:28:35 <pavonia> You usually can't go from IO to *any* other monad
22:28:38 <spoonm> I see
22:28:43 <jle`> "how would i go from Maybe a to [a]?"
22:28:51 <jle`> ^ that makes sense to ask
22:28:51 <jared-w> To rephrase the question a bit more...
22:29:05 <jle`> "how would I go from `Either e a` to `Maybe a`?"
22:29:08 <jle`> ^ that makes a lot of sense to ask
22:29:11 <jared-w> "How do you do a transformation a something to get a something else?"
22:29:20 <jle`> yes, that's a good rephrasing too :)
22:29:23 <spoonm> lol I got it, I got it ;-;
22:29:35 <jared-w> Doesn't make a lot of sense... Because, well, there's not a lot you can do with that little information :)
22:29:36 <jle`> so it's like asking, "how do i go from an Int to any other type?"
22:30:17 <jle`> i can answer "how can I go from an Int to a Double?"
22:30:38 <jared-w> That being said... If you're looking for a solution for a problem  you're running into, it sounds like you're probably looking at a monad stack and maybe a lifting function
22:31:01 <spoonm> then how can I go from a Maybe a to an IO a without just wrapping the whole thing in IO?
22:32:02 <DigitalKiwi> jared-w I have spent the last 2 days writing down lists of projects that I'll probably never be able to do any of and also been working on an old/new server. if you could make me smart that'd help otherwise I dunno :( literally over 25 project ideas...
22:32:07 * DigitalKiwi goes back to lurk
22:32:31 <jared-w> Can you tell us a bit more about what you're trying to do with that? I can tell you a few ways to do that but only one of those is going to make any sense for your particular problem :)
22:33:10 <jared-w> DigitalKiwi: project ideas are great though! Keep them in your brain and every time you look at a new piece of knowledge, stick it on a project mentally and soon you'll have tons of ideas of how to do them. Then it's just a matter of starting :)
22:33:52 <spoonm> jared-w: no problem at all :/
22:34:00 <jle`> spoonm: what does it mean to go from 'Maybe a' to 'IO a'
22:34:06 <spoonm> I'm curious, tho, what are some of your ways?
22:34:20 <jle`> what do you want to do if there is Nothing ?
22:34:23 <jared-w> oh, just curiosity? That's fine! I was worried you were trying to ask some question to solve a problem instead of just asking about the problem lol
22:34:28 <DigitalKiwi> my notebook is becoming a rdbms
22:34:35 <jle`> spoonm: a good way to start is wit pattern matching
22:34:40 <jle`> maybeToIO :: Maybe a -> IO a
22:34:43 <jle`> maybeToIO Nothing = ???
22:34:48 <jle`> maybeToIO (Just x) = ???
22:35:05 * DigitalKiwi adds to list "store notebook digitally"
22:35:25 <jared-w> Ever looked at org mode? ;)
22:35:46 <spoonm> ah, wasn't quite what I was asking, think of a f :: a -> Maybe a that could perform some IO
22:35:57 <DigitalKiwi> I've had the readme open for weeks in a tab for spacemacs docs...
22:36:12 <jle`> spoonm: haskell functions never perform IO
22:36:32 <jle`> the most they can do is describe IO
22:36:38 <jared-w> haha, nice. I'd just open up a org document and get started. Org mode is pretty terifying in its full complexity but just using it as a todo list is really easy
22:36:55 <spoonm> describe?
22:37:37 <jle`> spoonm: yes, as in, specify
22:37:41 <jle`> that's what the 'IO' type is
22:37:42 <jared-w> the IO a in a return type essentially means "this function is a recipe that, when executed, is going to do some IO and return an 'a' wrapped in that IO context"
22:37:43 <jle`> it describes IO actions
22:38:13 <jle`> 'putStrLn "hello"' is an IO action that describes the process of printing "hello" to stdout
22:40:19 <c_wraith> jared-w: I recommend being a bit more careful with terminology.  Within Haskell, it's important to not imply that IO actions are functions.
22:40:37 <spoonm> jared-w, jle`: I'm aware of lazy IO and all, but I do have some stuff I couldn't quite grasp
22:40:46 <c_wraith> jared-w: and it's handy to distinguish the IO action in the return value from the properties of being a function.
22:40:49 <jle`> spoonm: when did i mention lazy IO?
22:40:55 <jle`> i'm not talking about lazy IO at all actually
22:41:03 <jle`> lazy IO actually breaks this picture somewhat, in an annoying way, heh
22:41:06 <jared-w> right, thanks for that. Still a bit too sloppy with that, unfortunately
22:41:06 <jle`> we like to pretend it doesn't exist
22:42:10 <jle`> most discussions about IO actually usually pretend that lazy IO doesn't exist heh, since it's mostly an ugly hack
22:42:27 <spoonm> let's say I'm dealing with a do block in what's supposed to be an IO action. I've been told or read that there's no set order in that do block and that although every action in it will be executed, the order is only respected should a result of one action be necessary to another, and that in a way applies to any result of any function
22:42:58 <jle`> that sounds like the opposite of IO
22:43:14 <jle`> the point of IO is that >> enforces an order of IO action execution
22:43:29 <spoonm> then I need to go through the basics for maybe the 9th time
22:43:31 <jle`> (unless we talk about lazy IO, heh, which breaks a lot of expectations about IO in ugly ways)
22:43:41 <spoonm> yeah, how does that work?
22:43:56 <jle`> ugly compiler hack :)
22:44:08 <spoonm> I thought it was cute :(
22:44:16 <jared-w> The tl;dr of why it sucks is that lazy IO almost never happens when you want it to happen or how you think it'll happen
22:44:31 <spoonm> Isn't it on by default?
22:44:36 <jle`> it isn't
22:44:45 <jle`> it actually breaks pretty much every expectation haskell users have about IO
22:44:55 <jared-w> Aside from that cute two liner REPL implementation, there's basically zero useful cases of lazy IO
22:45:01 <jle`> spoonm: the only way to get lazy IO is to use 'unsafeInterleaveIO'
22:45:19 <spoonm> REPL?
22:45:44 <jle`> spoonm: the thing about IO is that order usually almost always matters
22:45:47 <jared-w> read-evaluate-print-load. GHCi is a repl, lisp is a repl, if you squint hard enough IRC behaves sort of like a REPL
22:45:53 <jle`> in practice
22:46:09 <c_wraith> jared-w: eh, more than that.  It's useful for things like "creating a stream of random values by reading from /dev/urandom", even in real programs. But you certainly have to be careful that the use case fits what it does.
22:46:29 <DigitalKiwi> s/load/loop/
22:46:37 <jared-w> whoops, thanks :)
22:46:54 <jared-w> Even for that case, don't most people whip out streaming libraries for that sort of thing, c_wraith?
22:47:04 <spoonm> I'm confused, I thought nearly all IO actions were lazy by default, like getLines and whatnot
22:47:26 <jle`> spoonm: what other IO actions can you think of? ;)
22:47:36 <spoonm> getChar?
22:47:44 <jle`> getChar is definitely not lazy
22:47:49 <c_wraith> getLine is not lazy, either
22:47:59 <jared-w> printLine better not be lazy either :)
22:48:03 <spoonm> iirc print is buffered
22:48:13 <c_wraith> spoonm: sure, that's true in every language.
22:48:16 <spoonm> or something I wanted to do was line buffered and all
22:48:29 <jared-w> That's just common sense for terminals though, not a thing that implies laziness
22:48:30 <spoonm> which is why I wasn't seeing everything I printed
22:48:43 <jle`> spoonm: yeah, that's not really a lazy io thing, that's the behavior of the terminal you are using
22:48:54 <jle`> so it's as related to haskell as the font you see in your terminal
22:49:19 <c_wraith> the lazy IO functions that typically get used are essentially getContents, hGetContents, readFile, and interact.  That's about it.
22:49:41 <spoonm> I see
22:50:03 <jle`> and they are all implemented using unsafeInterleaveIO
22:50:09 <c_wraith> Actually, interact isn't really lazy IO, either.  It blocks.
22:50:30 <c_wraith> It's just commonly used with a lazy non-IO function.
22:50:30 <jle`> lazy IO can be useful, but it does violate most expectations a haskeller has about how IO is supposed to work
22:50:35 <jle`> it's a sacrifice for convenience
22:50:46 <nshepperd> output buffering is a stdlib thing
22:51:17 <nshepperd> i start many of my programs with 'hSetBuffering stdout LineBuffering' so that I get immediate output when I'm teeing stdout into a file
22:51:38 <dminuoso> Speaking of lazy. Im looking at a protocol implementation that handles small UDP datagrams of around 200 bytes or so using lazy bytestrings (it's a simple request/respone scheme). Why would you pick lazy BS for this?
22:52:24 <nshepperd> otherwise it would default to buffering in big chunks when it detects its not outputting to a terminal
22:53:06 <c_wraith> dminuoso: I'd only use lazy BS if the result doesn't depend on your other code.
22:53:31 <dminuoso> c_wraith: What do you mean by "on your other code"
22:54:09 <jle`> morse code
22:54:29 <c_wraith> dminuoso: I really am objecting to something like a response value stream, where each chunk gets added to it as a result of some request your program makes earlier.
22:55:03 <c_wraith> dminuoso: I find that a terrifying use of lazy IO.  as jle` says, that one breaks all my expectations of how IO should work.
22:55:23 <dminuoso> c_wraith: Im talking about lazy ByteString, not lazy IO
22:55:38 <nshepperd> a lazy bytestring seems totally unnecessary for a 200 byte thing
22:56:01 <c_wraith> dminuoso: if you're not using lazy IO to produce the lazy bytestring, why are you using it at all?
22:56:10 <nshepperd> they might not have used it for a good reason at all
22:56:19 <dminuoso> c_wraith: Like I said, the protocol implementation Im looking at uses it for no documented reason.
22:57:32 <jared-w> Fork it and do it right™
22:57:43 <c_wraith> well, ok, there are certainly APIs that use lazy bytestrings for no externally-discernable reasons
22:58:08 <dminuoso> jared-w: Right now Im using Network.Socket, and doing recvFrom and sendAllTo with strict bytestrings in a forkIO'd thread already :)
22:58:21 <dminuoso> But I have these annoying fromStrict/toStrict wrappers around the library..
22:59:53 <c_wraith> I will say one thing for unsafeInterleaveIO - it doesn't break purity.  unsafeInterleaveST can, if used the wrong way!
23:00:36 * hackage halves 0.1.0.0 - Splitting/combining data structures to/from halves, quarters, eighths  http://hackage.haskell.org/package/halves-0.1.0.0 (puffnfresh)
23:01:12 <nshepperd> i suppose as an input to your function a lazy bytestring is somewhat better if the input _might_ be long, because fromStrict is always O(1) unlike toStrict
23:01:43 <nshepperd> i mean, lazy bytestring as input is the more 'permissive' interface
23:02:28 <nshepperd> but that's not really applicable if the input is required to be of limited length anyway
23:05:38 <dminuoso> nshepperd: How lazy is lazy BS? Is it lazy over the entirety, or is it lazy in chunks?
23:07:16 <jared-w> lazy BS is morally equivalent to [Strict Bytestring]
23:07:58 <nshepperd> yeah it's just a list of strict chunks
23:08:36 <nshepperd> so fromStrict is just a wrapping
23:09:04 <nshepperd> but toStrict might require concatenating chunks
23:20:04 <dpyro> how should i convert a Maybe to an Either?
23:21:14 <jared-w> The easy way is:  case foo of { Just a -> Right a; Nothing -> Left undefined; }  -- probably not the best solution, though
23:23:12 <jle`> dpyro: pattern matching is nice, you can use 'maybe' too as a hgiher order function
23:23:20 <jle`> :t maybe (Left "nothing") Right
23:23:21 <lambdabot> Maybe b -> Either [Char] b
23:23:39 <jle`> :t \default -> maybe (Left default) Right
23:23:40 <lambdabot> error: parse error on input ‘default’
23:23:57 <jle`> :t \d -> maybe (Left d) Right
23:23:58 <lambdabot> a -> Maybe b -> Either a b
23:25:47 * hackage superrecord 0.5.0.0 - Supercharged anonymous records  http://hackage.haskell.org/package/superrecord-0.5.0.0 (AlexanderThiemann)
23:27:04 <dpyro> i went with pattern matching, thanks jle`
23:27:15 <jle`> no problem!
23:51:02 <woodson> Hey guys, I am trying to build a project using nix and I keep getting this error
23:51:04 <woodson> /nix/store/rdh818ksl1337521b4xfyjlchy6y20n2-stdenv/setup: line 1202: 21233 Killed                  ghcjs $setupCompileFlags --make -o Setup -odir $TMPDIR -hidir $TMPDIR $i
23:51:50 <woodson> Anyone knows how I can fix this? it seems like the process keeps getting Killed...
23:53:58 <cocreature> woodson: are you running out of memory?
23:55:15 <woodson> cocreature: yes, I think thats what is happening...
23:55:33 <woodson> I just install ubuntu 16.04 on this temporary laptop
23:55:43 <cocreature> in that case, get more memory or use swap :)
23:55:45 <woodson> but I am not sure why I am running out of memory
23:56:02 <woodson> I made a swap file
23:56:17 <woodson> but I still get the same error
23:56:22 <cocreature> how much ram do you have?
23:57:00 <woodson> it got 3.6GB
23:57:54 <cocreature> not particularly surprised you’re running out of memory in that case tbh. GHC tends to use quite a lot of memory and ghcjs is only worse
23:58:19 <ayako> maybe needs -j1 somewhere?
23:58:53 <woodson> Damn, then I'm screwed?
23:59:41 <woodson> j1?
