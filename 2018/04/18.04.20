00:09:50 <ertes> https://gist.github.com/esoeylemez/bdff0bfe5139e4d1c7b5f1aadb20c3ca
00:09:58 <ertes> any ideas on how to make this more efficient?
00:18:40 <jchia> What a common thing that's Functor and Foldable but not Traversable?
00:19:43 <ertes> jchia: i don't think there is anything *common*
00:19:44 <jchia> I'm wondering whether to put '(Functor f, Foldable f)' or 'Traversable f' in the constraints for a function that I'm writing. The former is more accurate but the latter is shorter.
00:20:09 <ertes> jchia: i'd put the real constraint
00:21:10 <jchia> OK
00:26:32 <robstr> Hey I struggle with nix, maybe someone can help here https://gist.github.com/rsoeldner/f580d0207303b2b9ff6e2cdb2f451ebb - my `default.nix` depends on `testapp-dep` and since default.nix is a function, i would need to pass the `default.nix` file from testapp-dep too, but how should i do this ? It must be done here i think
00:26:34 <robstr> https://gist.github.com/rsoeldner/f580d0207303b2b9ff6e2cdb2f451ebb#file-app-config-nix-L6
00:26:51 <ertes> jchia: to answer your question, recently there was a discussion here about whether Functor+Foldable implies Traversable, and i think that it does *for algebraic types*
00:27:28 <ertes> jchia: so in standard haskell i'm pretty sure that it does, but the story could change with certain type system extensions
00:28:12 <ertes> robstr: wrong channel
00:29:15 <robstr> ertes: yea I was unsure if this is haskell related, I will try in the nixos channel :)
00:36:29 <w1n5t0n> Is it a good idea to use Haskell for some simple 2D and 3D mathematical animations, kinda like the 3blue1brown youtube channel?
00:39:47 <ertes> w1n5t0n: sure…  we have some low- to medium-level 3D graphics libraries and a bunch of low- to extremely-high-level 2D libraries
00:40:17 <ertes> w1n5t0n: start by looking at gloss to get a feeling for what extremely high-level 2D graphics in haskell look like
00:45:58 <dysfun> ertes: hrm i hadn't come across gloss before
00:46:17 <w1n5t0n> ertes: thanks, am looking into it!
00:46:19 <dysfun> looks cool
00:47:21 <dysfun> my favourite is the (defunct) one that was used in the hudak book
01:19:30 <ertes> i like all those surface aspects of haskell people won't shut up about: purity, type safety, etc…  but when it comes down to it, it's really stuff like this why i *love* haskell:  type Subparser m = StateT (MByteVector m) (MaybeT m);  data ParserF m x = ParserF { pfLookAhead :: Maybe Int, pfParser :: Subparser m x } deriving (Functor);  type Parser m = Free (ParserF m)
01:19:31 <ertes>     }
01:19:45 <ertes> i have no idea how to even approach this in other languages
01:25:13 <dysfun> i have no idea what's special about that that makes it so?
01:26:03 <Ferdirand> the fact that you get the functor and monad instances for free instead of having to write tons of obvious boilerplate ?
01:27:17 <dysfun> 'tons'
01:28:17 <Ferdirand> fair enough, relative tons
01:28:24 <ertes> no, the way it lets me solve this problem elegantly: you have a bytestring you need to parse, but it's transformed with unknown parameters…  bruteforcing the parameters for the whole bytestring is not possible, so you write a parser with "breakpoints"…  whenever you parse successfully up to a certain breakpoint, the search space collapses by a certain factor
01:28:29 <dminuoso> So.. when in "traditional" programming I would first build up some data structure from some input, then use that data structure to steer control flow to compute a single result - that's basically what hylomorphisms try to capture?
01:29:41 <dminuoso> If I look back, I find myself unfolding into a list with some temporary results, and then reducing that list into an answer kind of frequently in other languages
01:31:21 <ertes> now how would you solve this in C/C++?  you can't just use parser generators, and parser combinators are super-ugly, not to mention free monads
01:32:02 <dysfun> well i wouldn't try it in those languages, personally
01:32:29 <ertes> dysfun: can you name a language, where this would be reasonably easy to do?
01:32:44 <ertes> other than haskell's descendants (so no idris)
01:32:46 <dysfun> well i don't see the problem with parser combinators in a sane language
01:34:02 <ertes> i agree about that…  but i don't know any sane languages other than haskell =)
01:34:10 <dysfun> rust is semi-sane
01:35:00 <ertes> dysfun: this may be prejudice, but i'm sure this wouldn't be easy in rust
01:35:24 <dysfun> i think that's prejudice
01:36:31 <ertes> i couldn't find any information on free monads in rust, so i can't tell
01:37:33 <tdammers> I wrote a parser-combinator thing in C++ once
01:37:42 <tdammers> nowhere near as nice as in haskell, but doable
01:38:02 <ertes> i wrote parser combinators in C#…  same experience
01:38:08 <ertes> but keep in mind that this isn't about parser combinators
01:38:14 <ertes> this is about free monads over parser combinators
01:38:30 <ertes> in fact i'd go as far as to say that it's impossible in rust < 2
01:38:31 <tdammers> right, yes
01:38:54 <ertes> and i know that it's impossible in C# and F#
01:39:07 <ertes> it's possible in C++, but it's not going to be pretty
01:40:45 <tdammers> it's possible in C++, but of questionable usefulness
01:41:17 <merijn> C++ is the epitome of "everything is possible, but a lot of it takes uselessly much work"
01:41:39 <Boarders> C++, the dependently typed programming language
01:41:58 <tdammers> well, C++ does have type-level integers, kind of
01:42:09 <ertes> tdammers: i have no idea how else to do this kind of thing
01:42:13 <dysfun> during template expansion
01:42:42 <ertes> seriously i have no idea how this could/should be approached in other languages
01:42:47 <alp> well, boost.spirit is probably a good example of what it's like to write parser combinators in C++
01:43:09 <tdammers> ertes: probably by throwing purity out the window, and making it runtime-polymorphic
01:43:20 <ertes> i could sort of get this done in scheme, but it would be incredibly ugly and unsafe
01:43:34 <tdammers> I'm pretty sure massive amounts of "dependency injection" would also be involved
01:43:50 <tdammers> and needless to say, you'd be writing a metric fuckton of utterly trivial unit tests
01:43:54 <ertes> tdammers: well, this particular example uses a mutable array anyway
01:44:16 <ertes> it's not about avoiding mutable state, because this one *has* mutable state in its haskell variant
01:44:28 <tdammers> ofc, it's about abstracting out the algebra
01:44:32 <ertes> (originally i went with ByteString, but it turned out to be as horribly slow as i expected)
01:44:57 <tdammers> I guess in an OOP language, you would do that by baking the algebra into an abstract class or an interface, and then coding your parser against that, idk
01:45:16 <tdammers> it's still more limited in terms of what you can do with it though
01:46:03 <ertes> tdammers: and writing the controller in OO style is going to be an exercise in madness…  i wouldn't want to go down that particular rabbit hole
01:46:17 <merijn> Boarders: C++ is not dependently typed, though. As you can't depend on runtime values, only compile time values
01:46:18 <tdammers> ertes: me neither - but it's possible, and people do it without flinching
01:48:22 <Boarders> merijn: I am not at all knowledgeable on this but isn't the template system turing complete
01:48:40 <Boarders> so you could get arbitrary compile time compilations if you wanted?
01:49:20 <Boarders> compilations -> computations
01:49:35 <tdammers> Boarders: yes, but you can't close the circle - the template metalanguage and the C++-without-templates language aren't compatible, so you can't, for example, write C++ code that emits template metacode
01:49:37 <dminuoso> How do you emacs people deal with files on remote servers? Do you use tramp or similar things to access things remotely? Do you manually SSH into remote machines and use whatever editor (vim maybe if you're already an evil user) is available?
01:49:48 <[exa]> sshfs?
01:50:11 <tdammers> it's still a two-level hierarchy; there is no folding values, types, kinds, etc., into one self-referential level like Idris does
01:50:13 <dminuoso> Oh that's an interesting though, [exa]
01:50:15 <ertes> dminuoso: tramp
01:50:26 <Boarders> tdammers: ah fair enough, yeah even if you encode values as singletons I suppose you still have a fundamental distinction between type level and value level at any rate
01:50:27 <ertes> sshfs is too much maintenance
01:51:08 <ertes> dminuoso: you'll find that tramp supports everything you need, including dired and even magit
01:51:09 <tdammers> ertes: either vim over ssh, or rsync + local editing, or git + local editing
01:51:23 <tdammers> ertes: but I use vim anyway
01:51:36 <merijn> Boarders: For example, you can't do "int x = read(); foo<x>();" in C++
01:51:50 <Boarders> yeah
01:52:02 <ertes> dminuoso: in case that didn't quite get across: yes, you can use magit on remote repos…  i discovered that by accident recently =)
01:52:28 <merijn> I just use vim over ssh, but then I also use vim locally :p
01:53:01 <tdammers> merijn: same. The simplicity easily beats a lot of potential improvements in terms of overhead.
01:53:04 <ertes> dminuoso: and it's a lot faster than git on sshfs, too
01:53:28 <tdammers> git on sshfs feels dirty
01:53:56 <ertes> it is, and if you use it via tramp, magit just runs the git commands remotely, i.e. it does The Right Thing
01:54:12 <merijn> Man...I really need a function "a -> (a -> m b) -> m a" this is like the millionth time I need this...
01:54:40 <merijn> Well, the flip of that for better composition, I suppose
01:54:52 <merijn> \f v -> v <$ f v
01:54:58 <ertes> merijn: writing (x <$ f x) too expensive?
01:55:17 <ertes> i use that a lot, too, and in most instances with f = guard
01:55:20 <dminuoso> ertes: MM alright. Ill give tramp a try then :)
01:55:28 <merijn> ertes: That requires a lambda to capture 'x', which makes it really nasty to use it pointfree
01:55:51 <ertes> merijn: write the lambda inline, or use 'let'
01:56:00 <dminuoso> @pl \f v -> v <$ f v
01:56:01 <lambdabot> ap (<$)
01:56:58 <ertes> hmm, (ap (<$)) isn't even that bad
01:57:35 <merijn> ertes: Well, a more googleable name might make you hate yourself less in the future :p
02:01:00 <merijn> > ap (<$) return True
02:01:02 <lambdabot>  error:
02:01:02 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M785455713403...
02:01:02 <lambdabot>        prevents the constraint ‘(Show (f0 Bool))’ from being solved.
02:01:11 <merijn> > ap (<$) return True :: [Bool]
02:01:13 <lambdabot>  [True]
02:01:29 <merijn> Yeah, I don't see myself using that as is :p
02:01:41 <Boomerang> Is it possible to emit CPP from template-haskell? It's probably a bad idea, but it might be useful for something I'm working on.
02:01:58 <merijn> Boomerang: No, because CPP happens before GHC sees the code
02:02:10 <Boomerang> Right, that makes sense :) Thanks!
02:02:12 <ertes> merijn: classic case for a *.Utils module =)
02:02:27 <merijn> ertes: Yeah, I just need to come up with a name for it
02:03:01 <ertes> merijn: (<-<-)?
02:03:07 <ertes> merijn: (<$!)?
02:03:21 <ertes> merijn: schwarzbrot?
02:03:43 <merijn> ertes: I don't think an operator makes sense for how I'd use it, I was thinking like "constM" or whatever, but that's not quite it
02:04:44 <merijn> @hoogle Functor f => (a -> f b) -> a -> f a
02:04:45 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
02:04:45 <lambdabot> Prelude (<$>) :: Functor f => (a -> b) -> f a -> f b
02:04:45 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
02:04:54 <merijn> Nice try, Hoogle
02:05:04 <ertes> merijn: i can come up with tons of names that aren't quite it =)
02:05:05 <ertes> i think this is one of those cases where there simply is no good name
02:05:44 <merijn> "justDoIt" :p
02:05:58 <merijn> ertes: That's impossible to prove, though
02:06:24 <ertes> appliedToAndResultingIn =)
02:06:40 <ertes> hmm
02:06:41 <ertes> atari
02:07:07 <merijn> Hence the brainstorming here for names
02:07:24 <tht> .
02:07:25 <ertes> that was by accident, but it's searchable and just as meaningful as it needs to be =)
02:07:50 <ertes> @let atari = (<*>) (<$)
02:07:50 <lambdabot>  Defined.
02:07:59 <ertes> :t atari
02:08:00 <lambdabot> Functor f => (a -> f b) -> a -> f a
02:08:07 <merijn> Also, this is clearly Peak Haskell Problems: "this useful 30 characters operation isn't as elegant as I'd like it to be", meanwhile every other language is struggling to abstract basic shit
02:10:04 <merijn> :t let apFmapConst = ap (fmap . const) in apFmapConst -- clearly!
02:10:05 <lambdabot> Functor f => (b -> f a) -> b -> f b
02:10:37 <merijn> I suppose for absolute accuracy it should be apFmapDotConst
02:11:51 <[exa]> dminuoso: about sshfs, it requires some workarounds to work e.g. with git (you just mount with -oworkaround=rename) but otherwise I'm using it for almost everything without any serious problems
02:12:32 <kuribas> is there a library with newtype Option a = Option (a -> a)?
02:12:36 <[exa]> merijn: the Dot version starts to sound like java
02:12:55 <kuribas> And Option a <> Option b = Option (a . b)
02:13:14 <TMA> merijn: apDollarFmapDotConst
02:14:38 <merijn> kuribas: That's just Endo and it's in base
02:14:44 <merijn> :t Endo
02:14:45 <lambdabot> (a -> a) -> Endo a
02:14:52 <kuribas> merijn: Option is a nicer name :)
02:15:17 <kuribas> So I can use it to compose configuration options.
02:15:21 <merijn> kuribas: I don't think option is a very sensible name, though? Not that Endo is great, but at least it's theoretically sound and unambigous :)
02:15:37 <kuribas> it's also scary for library users
02:15:45 <merijn> kuribas: Yeah, but Endo is useful in many situations besides Option, though
02:15:57 <merijn> kuribas: So do "type Option = Endo", problem solved
02:16:03 <kuribas> hmm, right
02:16:07 <merijn> Or have more faith in your library users
02:16:24 <merijn> They're presumably writing haskell, so they'll get used to it :p
02:16:36 <tht> :t appEndo
02:16:38 <lambdabot> Endo a -> a -> a
02:19:41 <quicksilver> well exactly: the great thing about Endo is that you sound like harry potter when you unwrap it
02:23:46 <ertes> kuribas: i avoid libraries that microsoftise names…  i.e. "Endo is a scary name, so i'll rename it to Bewsheet"
02:24:30 <ertes> kuribas: background: microsoft thought that "monad" is a scary name, so they called their version "workflows" and later "computation expressions"
02:25:17 <ertes> the kind of bullshit names that appeal to java ServiceManagerFactory hipsters
02:26:00 <kuribas> quicksilver: haha, good point
02:26:08 <kuribas> ertes: isn't it flatmap?
02:26:20 <kuribas> I though mainstream languages use flatmap
02:26:31 <dminuoso> Not JavaScript.
02:26:34 <dminuoso> They will use smooshMap.
02:26:35 <ertes> they tried to find catchier names for "monad" itself
02:27:00 <dminuoso> kuribas: F# uses "Bind" for the name, but computational expressions is the word they use for monad itself.
02:27:30 <kuribas> which is rather unprecise
02:27:34 <ertes> kuribas: anyway, my point is: if it's a monoid, please say that it's a monoid…  don't make me read your source code to understand that your type is just an awkward variant of Endo
02:27:35 <maerwald> promises! :P
02:27:44 <kuribas> could be applicative as well
02:28:32 <dminuoso> kuribas: Avoiding the word "monad" at least lets you avoid the red herring about monad tutorials, category theory entrapments and other things too many Haskell beginners fall into.
02:28:45 <dminuoso> But anything more specific is too suggestive..
02:28:56 <dminuoso> Its a loss-loss :P
02:29:24 <maerwald> just don't try to teach haskell
02:29:24 <ertes> dminuoso: you think people haven't written terrible "computation expression tutorials", and that the computation expression tutorial fallacy doesn't apply? ;)
02:30:21 <fishythefish> hi, new here. i know this isn't the right language channel but someone told me computation expressions are like burritos. is this accurate?
02:30:27 <dysfun> i see this example derives Functor for an ADT with a constructor with multiple parameters. what does automated derive of functor do in such a circumstance?
02:30:38 <maerwald> fishythefish: which kind of burrito?!
02:30:46 <dminuoso> fishythefish: Kind of. Just imagine a burrito wrapped inside out stuffed inside a spacesuit floating on the ocean.
02:30:46 <ertes> except it's not as insidious as the monad tutorial fallacy, because F# doesn't really have monads anyway
02:31:09 <dminuoso> F# looks weird. :|
02:31:09 <maerwald> you can write monads in any language
02:31:25 <dysfun> ertes: i hear the pipe operator is better than monads
02:31:28 <maerwald> check out F* if you like haskell
02:31:31 <ertes> dysfun: it's always about the final type argument
02:31:31 <dminuoso> maerwald: Well in order to have the abstraction monad you need HKTs atleast.
02:31:34 <maerwald> it compiles to F#
02:31:34 <fishythefish> dminuoso: oh, write Gb instead
02:31:37 <fishythefish> they're enharmonic
02:31:45 <dminuoso> fishythefish: That depends on the instrument.
02:31:46 <dysfun> ertes: ah, thanks
02:31:54 <[exa]> .....Berechnungausdrücke sind Pfannkuchen!
02:32:04 <dminuoso> [exa]: +1 haha
02:32:05 <ertes> dysfun: i don't get that one…
02:32:16 <[exa]> couldn't resist.
02:32:26 <maerwald> [exa]: mit Pflaumenmus?
02:32:27 <dysfun> ertes: well half of the hype of f# seems to be "oh look, they have the (ocaml-style) |> operator
02:32:37 <maerwald> sorry, I meant Apfelmus!
02:32:40 <merijn> dysfun: The functor parameter is always the last type argument
02:32:48 <[exa]> maerwald: bitte schön.
02:32:56 <merijn> dysfun: "Functor :: (* -> *) -> Constraint"
02:32:56 <ertes> dysfun: oh, wow…  yeah, i totally get that hype
02:33:00 <maerwald> and then we have reactive bananas
02:33:06 <maerwald> *radioactive?
02:33:18 <dysfun> merijn: perfect, thanks
02:33:35 <dminuoso> dysfun: I think |> in general is highly problematic. It forces users to think about data shuffling, rather than function compositoin. :(
02:33:48 <fishythefish> time to put up an inert-banana library that ignores all temporal relationships
02:33:51 <maerwald> my next blog post: radioactive bananas wrapped in pancakes: the definite monad tutorial
02:33:53 <ertes> rückwirkende bananen?
02:34:14 <dysfun> dminuoso: having written a lot of elixir recently (which also has |>, but no static types), i'd have to agree
02:34:31 <maerwald> ertes: vibra...err, let's stop here
02:35:10 <fishythefish> dminuoso: on the other hand, Unix pipes may have already trained them to think that way, |> or no |> /shrug
02:35:16 <maerwald> dysfun: how does it feel? I once randomly applied for elixir jobs
02:35:35 <dysfun> maerwald: tbh, i quite enjoyed my elixir job while it lasted
02:35:42 <dminuoso> fishythefish: Well it's still better than C++ style wrapping inside () burritos or shuffling around variables.
02:35:49 <dminuoso> So it's not a complete disaster.
02:35:51 <dysfun> maerwald: it has this nice "everything where you can see it" property (until people start going mad with macros)
02:36:06 <dminuoso> I'd say |> allows for more concise imperative programming.
02:36:14 <dysfun> maerwald: i think about it in much the same way i think about baby haskell
02:36:44 <dminuoso> dysfun: macros (and lack of typing system) are what made me not pursue elixir.
02:36:59 <dysfun> well i program elixir because it's erlang, but with jobs
02:37:15 <dysfun> and macros are quite handy to have occasionally
02:37:38 <dminuoso> dysfun: Well the usage in ecto I found almost offensive.
02:37:40 <dysfun> and while i like a good type system, you'd be surprised how little i miss it most of the time
02:38:09 <dysfun> ecto goes quite overboard, i agree. but damn it's convenient
02:38:20 <maerwald> dysfun: I probably won't miss a good type system while writing code
02:38:24 <maerwald> but... while reading code.
02:38:39 <maerwald> because half of your thinking process is gone
02:38:43 <dminuoso> dysfun: I still prefer a typing system. I utterly dislike having to build and run code just to know whether things connect properly.
02:38:45 <dysfun> no, most of the problem i have reading elixir is parsing it
02:38:50 <dminuoso> Or whether I had a mental slip.
02:38:58 <dysfun> it makes some ....interesting... syntactical choices
02:39:25 <dysfun> yeah i know what you're saying, but i've also done a lot of dynamic language programming and if you're willing to go there, it's not really that bad
02:39:34 <dysfun> it's still immutable data
02:39:41 <Adluc> :pl fmap fmap fmap fmap fmap
02:39:42 <dysfun> it's all been really thought about
02:39:58 <maerwald> :t fmapN
02:39:59 <lambdabot> error:
02:39:59 <lambdabot>     • Variable not in scope: fmapN
02:39:59 <lambdabot>     • Perhaps you meant ‘fmap’ (imported from Control.Monad.Writer)
02:40:02 <dminuoso> dysfun: At this point I consider Crystal better than Ruby in every conceivable way.
02:40:07 <maerwald> write some TH code :P
02:40:09 <Adluc> @pl fmap fmap fmap fmap fmap
02:40:10 <lambdabot> fmap (fmap fmap) fmap
02:40:22 <dminuoso> dysfun: I mean if all you care about is the syntax, Crystal has it too but with guarantees. Type inference ensures you wont see types either, so you have the same flexibility.
02:40:28 <dysfun> dminuoso: i haven't bothered playing with crystal, but then i don't like ruby syntax and i was only writing elixir because it's a proxy for writing erlang
02:40:33 <dminuoso> To pick Ruby over Crystal is just intentional "shooting yourself in the foot"
02:40:53 <maerwald> dysfun: how is parsing haskell easier
02:40:57 <maerwald> compared to elixir
02:41:07 <dysfun> i didn't say it was :)
02:41:09 <maerwald> people may align their code in whatever shape
02:41:16 <dminuoso> dysfun: I wonder whether elixir would have any traction if it wasn't for OTP.
02:41:22 <dysfun> dminuoso: no.
02:41:23 <maerwald> there are not many languages that make parsing easy, python tried
02:41:37 <tdammers> actually, no
02:41:56 <tdammers> python explicitly sacrifices "easy to parse" for "easy for a certain class of humans to write"
02:41:59 <dysfun> human parsing text is terrible
02:42:01 <dminuoso> Is there any language that doesn't have a bison-style parser generator?
02:42:29 <dysfun> i'm actually quite look forward to proper visual programming, much as i'm currently wedded to emacs
02:42:56 <dminuoso> dysfun: I mean I know that dialyzr lets you annotate and type check elixir code.. but that requires everything to be annotated. And dialyzr diagnostics are.. well. It's like C++ template errors but worse.
02:42:57 <ertes> dminuoso: unlambda
02:43:11 <dminuoso> Heh. :)
02:43:12 <dysfun> dminuoso: no, dialyzer requires no type annotations at all
02:43:15 <maerwald> tdammers: are we talking compiler parsing or human parsing
02:43:42 <dminuoso> dysfun: Too many things default to any()
02:43:50 <maerwald> I find it rather easy to parse as a human
02:43:52 <tdammers> maerwald: compiler
02:43:54 <dysfun> dminuoso: agreed, but you can tighten those up if you like
02:44:13 <dminuoso> dysfun: Right. My argument about the quality of diagnostics being even below C++ template errors still holds though.
02:44:38 <dysfun> dminuoso: no. i know why you say that, they're not great, but i was doing some c++ TMP last year and it was hell
02:45:41 <dysfun> (in one case, i overfilled a boost compile-time vector and the output was just gibberish
02:45:56 <merijn> So, lens groupies: is there a better way for me to write this, or? http://lpaste.net/365034
02:46:02 <dminuoso> I never have any boost related TMP problems.
02:46:05 <dminuoso> But then again I dont use boost...
02:46:14 <dysfun> boost pushes compilers to their limits
02:46:23 <merijn> People who say Haskell docs are bad clearly have never tried using the boost docs :p
02:46:24 <dysfun> as with anything that does that, you can expect terrible diagnostics
02:46:49 <dminuoso> dysfun: I remember when some boost guy started implementing concepts.. using macros.. and macros.. and macros...
02:46:59 <dysfun> yes, don't do that :)
02:47:01 <maerwald> merijn: what haskell docs
02:47:05 <dysfun> it's a wonderful and clever hack, but don't use it
02:47:08 <maerwald> you mean type signatures?
02:47:44 <dminuoso> dysfun: It's a prime example of shoehorning features into a language that lacks the necessary machinery..
02:48:12 <merijn> johnw: You need to limit the horizontal space on your website, it becomes hard to read!
02:48:15 <dysfun> dminuoso: my main objection to c++ though is that members of the standardisation committee cannot agree on and remember what current behaviour is
02:48:16 <dminuoso> dysfun: I mean I've seen examples of people encoding numbers into church numerals to write algorithms with in R...
02:49:34 <dysfun> anyway, now i grudgingly write rust where i would otherwise have to use c++
02:49:43 <dysfun> and ideally i don't do systems programming at all
02:49:44 <maerwald> TH is the best example for a haskell project: no readme, no tutorial or examples, hundreds of types and functions with bad API docs
02:50:01 <merijn> maerwald: Still better than boost
02:50:05 <johnw> merijn: i just pushed a change to do that
02:50:05 <maerwald> heh
02:50:08 <johnw> or thought i did
02:50:09 * hackage hadolint 1.6.3 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.6.3 (lorenzo)
02:50:11 <maerwald> I'm exaggarating anyway
02:50:24 <johnw> uploading again now
02:50:26 <maerwald> although th is really pretty bad
02:50:36 <johnw> merijn: I set max-width: 80%; margin: auto
02:50:54 <merijn> johnw: Right, but max-width 80% is *way* to wide on wide screens :)
02:51:01 <johnw> hmm
02:51:12 * dysfun hears the sound of media queries
02:51:15 <johnw> 980px?
02:51:24 <dminuoso> dysfun: Yeah.. Ive come to the same conclusion that there's very little reason to pick C or C++ these days. Rust seems almost universally more attractive.
02:51:46 <dminuoso> Beyond arguments such as "availability of developers" maybe.
02:51:49 <dysfun> yeah, rust is way better than c++
02:52:16 <merijn> johnw: I dunno enough webdev to tell you the best way to do this, it's just that on my current screen the text column is about 40-45 cm wide, which isn't really comfortable for reading :) I worry whether a pixel max will play nicely with high DPI screens, though
02:52:35 <kennp> chiming in, I tried PyMonad, and it barely does the job.  When error happens, PyMonad very unhelpful compared to Haskell
02:52:58 <dysfun> kennp: all monad libraries in dynamic langs have awful debugging
02:53:15 <kennp> so I feel it is easier to start writing code that runs in PyMonad compared to in ghci, but it's a lot more difficult to write good code
02:53:18 <merijn> johnw: Ideally you'd specify a width in em, I suppose, which should scale to however big the text is on that specific screen. Although I'm not sure the theory holds up in practice
02:53:19 <tdammers> I would argue that monads are pretty useless in untyped languages, too
02:53:28 <dysfun> agreed
02:53:38 <dysfun> i have no idea why you'd want to use monads without the support of the type system
02:53:54 <kennp> er, becasue I am dealing with legacy python code? o.)
02:53:57 <kennp> o.O
02:54:00 <tdammers> I mean, after all they're all about enforcing a certain structure of the code through the type system, but when there's no type system, nothing is enforced and you're just left with more or less wordy boilerplate
02:54:01 <dminuoso> Ive been trying to author a complete FP library for Ruby. The main difficulty I have is that when things blow up, all I can talk about is some anonymous lambda..
02:54:41 <kennp> trying to think in Haskell while writing in python, a very dreamy experience.
02:54:46 <dminuoso> tdammers: It seems like something like Monad requires a full toolset of combinators to lift off.
02:54:58 <merijn> dminuoso: Well, yes
02:55:14 <tdammers> yes
02:55:38 <tdammers> you can of course do it the "pass dictionaries at runtime" way, but then you're not really gaining much, if anything
02:55:54 <tdammers> plus the code becomes utterly unreadable
02:57:04 <tdammers> Maybe.Monad.bind(function () { return just(3); }, function (n) { return just(n * 2); })()
02:57:07 <tdammers> ugh
02:57:27 <tdammers> (actually, Maybe.just(3) and Maybe.just(n * 2), really)
02:58:12 <dminuoso> tdammers: Is that last one valid Python?
02:59:42 <tdammers> dminuoso: I was going for JS
02:59:52 <tdammers> it would be even more terrible in Py
03:00:04 <tdammers> because useless lambda syntax and all that
03:00:23 <tdammers> (how does one even write a nullary lambda in Python?)
03:00:25 <dminuoso> Ruby has enough machinery to do this compactly.
03:00:35 <tdammers> lambda: expr?
03:00:56 <dminuoso> tdammers: pure(3) >-> n { pure(n * 2) }
03:01:06 <dminuoso> Is what my library allows
03:01:44 <johnw> merijn: any better now?
03:02:47 <tdammers> dminuoso: but still no type system, right
03:03:06 <dminuoso> tdammers: I've tried to shoehorn as much type checks in all the places, but it's ugly.
03:03:18 <tdammers> vOv
03:03:26 <tdammers> I guess if Ruby is a given, then this is as good as it gets
03:05:32 <dminuoso> tdammers: The main problem is polymorphic behavior, which I have. You just need to - at any point - introduce the type of monad to fixate it. So it's kind of like a not-really free monad.
03:07:51 <kennp> well, fans of Haskell.  how many of you will be able to live with ONLY Haskell, with at most one other language?
03:08:05 <kennp> and would you WANT to?
03:09:23 <lemmih> Haskell and English would be fine for me. :P
03:11:09 * hackage hw-hspec-hedgehog 0.1.0.4 - Interoperability between hspec and hedgehog  http://hackage.haskell.org/package/hw-hspec-hedgehog-0.1.0.4 (haskellworks)
03:11:28 <kennp> lemmih: great, write poetry in Haskell!
03:12:31 <dysfun> why would i want to only know 2 languages?
03:13:11 <kennp> dysfun: just probing whether Haskell is practical, after all in terms of number of coders writing code, Haskell is not a majority is it?
03:13:27 <dysfun> haskell is a practical language suitable for a wide range of problems
03:13:46 <kennp> dysfun: I agree, so I am curious why we are not getting more mindshare
03:13:49 <dysfun> that doesn't mean that i don't want to tackle problems that it's not good for
03:15:19 <kennp> one theory might be - it is so powerful and requires more learning that very casual coders never invested in the language
03:15:38 <dysfun> there is no doubt that the learning curve puts a lot of people off
03:16:04 <dysfun> but you get that more with people who're already good at imperative programming than people who've never programmed
03:16:14 <dysfun> people mostly just forget learning to program is hard, i think
03:16:59 <dysfun> but even still, many people will just do whatever they learning in university, which is probably java
03:17:15 <kennp> I am enjoying every difficult moment in Haskell (and there are many)
03:18:35 <kennp> Java is not very interesting....  I wish I was introduced to Haskell in university.  I got LISP.  That was 20 years ago, Haskell was not as mature as it is now.
03:19:36 <Taneb> 20 years ago... Haskell existed! And not much mroe than that
03:21:08 <kennp> Java found application on the internet and grew, but apart from certain security models, its theoretical foundation is nothing like Haskell.
03:21:53 <kennp> but I think learning Haskell has one fallback, all the nice tricks you learnt do not work very well no matter what language you switch to.
03:22:12 <dysfun> that's not true
03:22:19 <dysfun> learning haskell made me a better programmer in other languages
03:22:39 <kennp> yes, but like someone just said, they don't have compiler support for the Haskell type system
03:23:01 <dysfun> that doesn't mean it's not a useful grounding
03:23:10 <kennp> agree
03:28:20 <AWizzArd> In Hoogle I am searching for this:   a -> (a -> b) -> b         Why does this _not_ link me to (&)?    https://hackage.haskell.org/package/base-4.11.0.0/docs/Data-Function.html#v:-38-
03:29:07 <Taneb> AWizzArd: it can't scroll down far enough to get (&) to the top of the page
03:29:14 <Taneb> It is trying, at least for me
03:34:18 <kuribas> dysfun: yes, but then you have to work with the OO mess from your coworkers, and everything goes out of the drain.
03:34:33 <kuribas> dysfun: unless they are functional fans as well of course
03:34:42 <dysfun> "it depends"
03:34:55 <dysfun> i said earlier i was writing a lot of elixir recently. elixir is immutable data all the way through
03:35:14 <dysfun> it's a lot easier to just write functional code than e.g. java
03:35:20 <kuribas> or python
03:35:38 <dysfun> yeah people will look at you a bit funny if you map etc. everywhere in python
03:36:19 <kuribas> it's just much harder to make a mess in haskell than in python
03:36:42 <dysfun> not really. i've seen people who come from impertive backgrounds just put everything in IO before
03:37:31 <Taneb> AWizzArd: or do you mean, why is it not showing up in the search?
03:38:32 <kuribas> it's harder without the typechecker screaming at you :)
03:39:11 <kuribas> in haskell often the effect is hard to typecheck code, while in python it's hard to maintain code.
03:39:49 <Taneb> I've made plenty of messes in pure Haskell
03:43:18 <bjs> Taneb: it's easy to make messes in any suitably advanced language. The real skill is making usable messes ;)
03:43:51 <fishythefish> AWizzArd: it shows up in https://hoogle.haskell.org/?hoogle=a%20-%3E%20(a%20-%3E%20b)%20-%3E%20b for me, although I have to scroll down a bit
03:44:56 <tht>  /join #linux
03:54:23 <AWizzArd> Taneb and fishythefish: okay I am seeing it too, thx. Hoogle also looks new, there are those new filters, nice.
04:00:39 * hackage influxdb 1.6.0.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-1.6.0.1 (MitsutoshiAoe)
04:04:09 * hackage StateVar 1.1.1.0 - State variables  http://hackage.haskell.org/package/StateVar-1.1.1.0 (SvenPanne)
04:09:57 <merijn> johnw: Yeah, much more readable now
04:14:09 * hackage marihana 0.2.0.0 - Minimal tool to make your blog in Haskell  http://hackage.haskell.org/package/marihana-0.2.0.0 (suzukeno)
04:15:29 <Plato[m]> Is there anything more robust than "threadDelay" for timed wake ups?
04:16:18 <merijn> Plato[m]: What do you mean by robust?
04:16:46 <Plato[m]> Well, I suppose threadDelay isn't really exact. At least in other languages it isn't.
04:16:59 <merijn> What kinda exactness are you needing?
04:17:03 <Plato[m]> I don't want to be woken up early.
04:17:17 <hpc> threadDelay errs on the side of lateness
04:17:18 <merijn> threadDelay guarantees you don't wake up earlier
04:17:39 <merijn> hpc: Well, I suppose you could get async excepted
04:17:40 <[exa]> Plato[m]: why not wrap it a bit?
04:17:42 <Plato[m]> Oh! Hm, should've read the docs more carefully.
04:26:09 * hackage universum 1.1.1 - Custom prelude used in Serokell  http://hackage.haskell.org/package/universum-1.1.1 (shersh)
04:36:42 <robstr> Hey, I go crazy with haskell / nix - When building my application with stack i have no problems, with nix i receive only for the `o-clock` library: `Setup: o-clock.cabal: This package requires at least Cabal version 2.0` maybe someone know how to fix this ?
04:37:08 <merijn> robstr: Update to Cabal version 2.0 or later? :p
04:37:25 <merijn> It's a radical idea, I admit ;)
04:37:45 <robstr> merijn: :P This should be done by cabal2nix i think :D My system cabalversion is > 2.0
04:38:06 <merijn> I know jack all about Nix, tbh, so can't help you beyond that
04:39:03 <matsurago> is cabal 2.0 extremely new and untested? it's masked out on my system :(
04:39:16 <cocreature> matsurago: certainly not, the newest version is 2.2
04:39:17 <merijn> matsurago: Depends how you define extremely new and/or untested
04:39:48 <merijn> Then again, I've been running HEAD for weeks, so take my opinion with a grain of salt :p
04:39:59 <robstr> :P
04:40:23 <cocreature> robstr: which version of GHC are you using with nix?
04:40:37 <matsurago> it seems the last version marked as stable on my OS is 1.24
04:40:48 <robstr> cocreature: 802
04:40:54 <merijn> masaeedu[m]: That was the last version before 2.x
04:41:06 <merijn> s/masaeedu[m]/matsurago
04:42:31 <ph88> could someone help me figure out why line 31/52 doesn't output more ? https://ghostbin.com/paste/fcy3s
04:42:36 <maerwald> merijn: you probably mean the tip of the default branch, HEAD can point anywhere :P
04:42:51 <matsurago> merijn: oh it seems cabal was updated to 2.0 in 2017. It seems my OS haskell maintainers are really slow.
04:43:36 <cocreature> robstr: try using 8.2. iirc nix builds with whatever version of Cabal was shipped with the GHC release
04:43:40 <cocreature> not sure if you can override it
04:44:15 <robstr> cocreature: running it right now :) fingeres crossed
04:44:24 <lyxia> ph88: define "doesn't output more"
04:44:43 <cocreature> also what’s line 31/52 supposed to mean? 52 contains a comment
04:45:05 <ph88> lyxia, i get line 53 and expect the same as on line 62 to 82
04:45:37 <ph88> cocreature, line 49-53 is the output copied from ghci
04:45:49 <robstr> cocreature: you are right, now I use cabal > 2.0
04:46:02 <cocreature> robstr: probably = 2.0 rather than > 2.0 :)
04:46:31 <lemmih> ph88: Why do you expect the same output as in the comment on line 62?
04:47:19 <robstr> cocreature: maybe :P but the nightmare is not over, missing deps Glob >=0.9, doctest >=0.13, markdown-unlit ==0.5.*, tasty ==0.12.* :D
04:47:44 <ph88> lemmih, hold on i just want to check something first !
04:48:09 <cocreature> robstr: maybe you have the wrong versions?
04:50:16 <robstr> cocreature: in my stack file, i specified extra-deps: o-clock-0.1.1 - how can i check for the sha ?
04:50:32 <[exa]> is there a reasonable way to reconstruct typeclass instance member implementations from the output of GHC's compileToCoreSimplified?
04:51:10 <cocreature> robstr: I just put in the wrong one and wait for nix to tell me the correct one in the error :)
04:52:44 <ph88> lemmih, your question let me find the problem. I was doing debugAst on line 25 on a string (coming from line 23) instead of the ast structure
04:53:10 <lemmih> ph88: Glad to be of service.
04:53:15 <ph88> thx
04:53:47 <robstr> cocreature: https://hydra.nixos.org/build/67777556/nixlog/1
04:53:47 <ph88> is there any convenience library for printing colors to the terminal? or is it best to just put the raw escape codes in my source code ?
04:53:50 <robstr> cocreature: lol ...
04:55:05 <lemmih> [exa]: I don't think so. There are probably solutions outside of what I consider to be reasonable, though. :)
04:56:02 <lyxia> ph88: https://hackage.haskell.org/package/ansi-terminal ?
04:56:15 <cocreature> robstr: at least for tasty, the problem is most likely that the version you are trying to use is too new
04:56:29 <ph88> oh thanks
04:56:37 <[exa]> lemmih: kindof thinking about partially evaluating them out of tc dictionaries
04:59:02 <ph88> lyxia, seems that ansi-terminal wants to do IO actions .. it's not really convenient when i just build up a string .. but ok i'll something
04:59:29 <dminuoso> newtype Mu a = Mu (Mu a -> a)
04:59:30 <ph88> or maybe use setSGRCode
04:59:49 <dminuoso> How can I conceptualize this? Im trying to wrap my head around this.
05:00:49 <dminuoso> S
05:00:55 <dminuoso> @let newtype Mu a = Mu (Mu a -> a)
05:00:56 <lambdabot>  .L.hs:156:36: error:
05:00:56 <lambdabot>      Ambiguous occurrence ‘Mu’
05:00:56 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.Mu’,
05:01:30 <dminuoso> @let newtype MMu a = MMu (MMu a -> a)
05:01:31 <lambdabot>  Defined.
05:01:35 <merijn> dminuoso: That doesn't look like regular Mu
05:01:40 <dminuoso> @let y f = (\h -> h $ MMu h) (\x -> f . (\(MMu g) -> g) x $ x)
05:01:41 <lambdabot>  ghc: panic! (the 'impossible' happened)
05:01:41 <lambdabot>    (GHC version 8.2.2 for x86_64-unknown-linux):
05:01:41 <lambdabot>          Simplifier ticks exhausted
05:01:49 <lyxia> haha
05:02:17 <merijn> dminuoso: Normally Mu is type level fix
05:02:37 <lyxia> ph88: If you find a pure solution, I'm interested too.
05:02:48 <thblt> "the 'impossible' happened" is going in my error messages top ten right now.
05:02:50 <ph88> i thought maybe the setSGRCode
05:02:53 <ph88> i'll check it out
05:03:21 <cocreature> ph88: you could use one of the pretty printer libs that support colors
05:03:28 <Putonlalla> You can use `ansi-terminal` in a pure way, but that only works on some systems, ph88.
05:03:47 <cocreature> ph88: e.g. https://hackage.haskell.org/package/prettyprinter-ansi-terminal
05:04:33 <cocreature> you’ll have to work with Doc instead of String but ime once you want colors, some nice formatting is usually also required so you end up with a pretty printing lib at some point anyway
05:04:48 <cocreature> and if you don’t care about the pretty printing features it’s easy enough to ignore them
05:06:53 <ocramz> hullo all
05:07:32 <ocramz> is there a way in GHCi to query the intersection set of typeclass instances?
05:07:58 <ocramz> as in, if I say `:i MonadLog PrimMonad` I get the instances of both
05:08:17 <cocreature> ocramz: afaik there isn’t but it sounds like a nice feature
05:08:54 <ocramz> cocreature: I've been wanting this for ages
05:09:25 <cocreature> although it is probably more complex than it seems at first
05:10:17 <merijn> ocramz: Time to hack it in yourself ;)
05:10:30 <cocreature> to get anything useful you need to at least do unification of the instance heads rather than just checking if they’re identical
05:11:09 <ocramz> I wonder how hard it is
05:11:36 <merijn> ocramz: Only one way to find out!
05:34:37 <marmistrz> I have a data type whose one variant is a function
05:35:24 <marmistrz> data Foo = First Int | Second Int -> Int
05:36:01 <marmistrz> So that comparing two Second values will result in an error
05:40:03 <pavonia> Don't compare two Second values then :3
05:40:56 <pavonia> You can still check if two values have the same constructor using pattern matching, though
05:42:44 <marmistrz> pavonia, but in my real code I have something like 5 variants
05:43:12 <marmistrz> I'm only using the equality comparison in the tests
05:43:48 <marmistrz> So I really don't want to write it by hand
05:43:49 <pavonia> That won't work then, you can't compare if two functions are equal
05:43:58 <marmistrz> pavonia, I could return undefined then
05:44:22 <pavonia> Yes
05:44:48 <marmistrz> a partial function would be just fine in my case, but I'd like to automatically derive, not write it by hand
05:45:19 <Taneb> marmistrz: it is impossible to derive this
05:45:52 <pavonia> With Template Haskell it would be possible
05:45:56 <dminuoso> merijn: Ah well recursive types are just screwing too much with my head. :-)
05:46:48 <Taneb> pavonia: not in a way that's much easier than writing the instance by hand, unless there's some utility I don't know about
05:48:19 <pavonia> Yeah, for only 5 constrctors it's not worth the trouble
05:49:35 <ziman> can you write an (instance Eq (a -> b) where compare x y = error "boo") that would be there only for testing?
05:49:55 <lyxia> heh I like it
05:57:06 <[exa]> lemmih: btw afaik the information "loss" about instances happens exactly on desugaring?
05:58:41 <ph88> lyxia, this worked for me   (setSGRCode [SetColor Foreground Vivid Blue]) ++ myString ++ (setSGRCode [])
05:59:11 <Boarders> say you are in IO and have a way of printing errors of type String. What is the preferred way to do that?
05:59:42 <adjofun> Boarders: `putStrLn` =:)
06:00:09 <Boarders> I currently have a pattern like: parse :: FilePath -> IO Data
06:00:14 <cocreature> hPutStrLn stderr
06:01:42 <adjofun> cocreature: but stderr is just a stdout for wimps =:)
06:01:58 <Psybur> :t displayException
06:02:00 <lambdabot> Exception e => e -> String
06:02:11 <cocreature> adjofun: the important part is that it’s separate from stdout :)
06:03:44 <lyxia> ph88: <3
06:04:02 <ph88> :D
06:04:53 <Boarders> cocreature: if the return type is IO MyData which doesn't have a default value to return
06:05:05 <Boarders> then how would one use hPutStrLn
06:05:28 <cocreature> Boarders: so your question is not about printing errors but about handling failure cases in your program?
06:06:22 <Boarders> yeah I think so
06:08:04 <cocreature> there are various options: 1. change the return type to IO (Either Error MyData) (or Maybe, …) 2. throw an exception or if you’re writing an executable (rather than a library) and have a fatal error you can also use "exitFailure" but that’s something that should be used with caution
06:08:51 <adjofun> Boarders: then your type should encode the possibility of failure, like the above `:: FilePath -> IO (Either Error MyData)`
06:11:19 <Boarders> I had come across a blog post of Michael Snoyman where he was pretty critical of that sort of pattern
06:11:46 <adjofun> Boarders: link?
06:12:05 <jchia_1> When do people actually use Integer? GHC seems to default to Integer instead of Int, but for practical purposes, I almost never want to use Integer, and I think I'll use it only when I specifically need unbounded integers.
06:12:28 <Boarders> https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell
06:12:34 <cocreature> Boarders: he’s critisizing using ExceptT in the monad transformer stack of your whole application, not isolated uses of Either
06:12:43 <Boarders> ah fair enough
06:12:53 <merijn> jchia_1: You almost always need unbounded integers unless you are *very* sure you don't
06:13:02 <adjofun> jchia_1: for impractical purposes like fib(999999999) =:)
06:13:11 <Boarders> the difference being using Either allows for composable errors?
06:13:57 <cocreature> no the difference being one is an isolated use of some type whereas the other is a way to structure your whole application
06:14:54 <Boarders> ah ok
06:14:59 <Boarders> thanks, that makes sense
06:16:11 <cocreature> as a rule of thumb, returning Either is useful if in the majority of the cases the failure case can be handled reasonably whereas exceptions are useful if in the majority of cases, terminating your program is an appropriate response to a failure
06:17:15 <jchia_1> merijn: For many cases, the time I need Integer is probably the time I run out of memory.
06:17:28 <Psybur> % catch (listDirectory ".") (\e -> (putStrLn $ displayException  (e :: SomeException)) >> mempty)
06:17:28 <yahb> Psybur: ["15.txt","69.txt","43.txt","94.txt","22.txt","44.txt","58.txt","2.txt","54.txt","100.txt","95.txt","90.txt","4.txt","56.txt","42.txt","20.txt","39.txt","30.txt","74.txt","test.lua","76.txt","35.txt","25.txt","82.txt","14.txt","40.txt","19.txt","11.txt","81.txt","41.txt","96.txt","are you sure furq","68.txt","75.txt","62.txt","29.txt","46.txt","63.txt","66.txt","38.txt","91.txt","71.txt","83.txt",
06:17:58 <Psybur> That took so long for me to figure out what seems like something so basic xD
06:18:16 <Psybur> % catch (listDirectory "+_(_@)(*!@)(*$&") (\e -> (putStrLn $ displayException  (e :: SomeException)) >> mempty)
06:18:16 <yahb> Psybur: +_(_@)(*!@)(*$&: getDirectoryContents:openDirStream: does not exist (No such file or directory); []
06:19:13 <adjofun> Psybur: dude, it is too early for regexps, there are children in here!
06:19:29 <marmistrz> thanks
06:19:47 <ph88> why does a newline not pretty print?  https://ghostbin.com/paste/xbqrz
06:25:40 * hackage hw-ip 0.1.0.0 - Library for manipulating IP addresses and CIDR blocks  http://hackage.haskell.org/package/hw-ip-0.1.0.0 (haskellworks)
06:26:07 <adjofun> ph88: use http://hackage.haskell.org/package/prettyprinter plz, it is better.
06:26:36 <ph88> why is it better ?
06:27:35 <adjofun> ph88: it is all in the README
06:27:37 <ph88> oh it looks good be the description
06:28:48 <Putonlalla> Of course this particular package would have fancy box drawing diagrams in its documentation.
06:29:45 * hackage hasbolt-extras 0.0.0.6 - Extras for hasbolt library  http://hackage.haskell.org/package/hasbolt-extras-0.0.0.6 (ozzzzz)
06:30:50 <Psybur> Is there a cleaner way of doing this?
06:30:51 <Psybur> % System.Directory.getFileSize "bruh.txt" >>= (return . (/1000.0^2) . fromInteger)
06:30:51 <yahb> Psybur: 55.451648
06:31:18 <adjofun> ph88: also, at least for me, the whole point of usint pretty printers is to be able to compose text relative to other text without control symbols
06:31:24 <Psybur> @pl System.Directory.getFileSize "bruh.txt" >>= (return . (/1000.0^2) . fromInteger)
06:31:24 <lambdabot> ((/ 1000 . 0 ^ 2) . fromInteger) `fmap` System.Directory.getFileSize "bruh.txt"
06:31:27 <lyxia> Psybur: fmap (... . fromInteger)
06:33:01 <Psybur> :t (&)
06:33:02 <lambdabot> a -> (a -> b) -> b
06:33:36 <Psybur> % System.Directory.getFileSize "bruh.txt" & fmap ((/ 1000 . 0 ^ 2) . fromInteger)
06:33:36 <yahb> Psybur: ; <interactive>:15:1: error:; * Could not deduce (Num (b0 -> c)); (maybe you haven't applied a function to enough arguments?); from the context: (Fractional (a -> c), Num (b -> c), Num (a -> b)); bound by the inferred type for `it':; forall a c b. (Fractional (a -> c), Num (b -> c), Num (a -> b)) => IO (a -> c); at <interactive>:15:1-79; The type
06:33:41 <merijn> eh, why not just <$>?
06:34:11 <Psybur> % (return . (/1000.0^2) . fromInteger) <$> System.Directory.getFileSize "bruh.txt"
06:34:11 <yahb> Psybur: ; <interactive>:16:1: error:; * No instance for (Show (IO (m0 Double))) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
06:34:18 <merijn> Psybur: Lose the return
06:34:21 <Psybur> % ((/1000.0^2) . fromInteger) <$> System.Directory.getFileSize "bruh.txt"
06:34:21 <yahb> Psybur: 55.451648
06:34:28 <Psybur> Yeah copy paste gone wrong :D
06:34:50 <Psybur> :t fmap
06:34:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:34:52 <ph88> adjofun, i tested it with prettyprinter .. "\n" shows up .. now i need to change all my code ^^
06:35:11 <Psybur> @hoogle Functor f => f a -> (a -> b) -> f b
06:35:12 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
06:35:12 <lambdabot> Prelude (<$>) :: Functor f => (a -> b) -> f a -> f b
06:35:12 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
06:35:45 <Psybur> I wonder if theres a flipped fmap? I feel like its clearer to see that first Im getting a file size and then converting to megabytes
06:36:32 <merijn> Lens has <&>
06:36:37 <merijn> :t (<&>)
06:36:38 <lambdabot> Functor f => f a -> (a -> b) -> f b
06:36:56 <orion> At work I noticed a Haskell application segfaulting in production intermittently. I found a line of code in a logging module which used "unsafeDupablePerformIO". I removed it, and yet the application still segfaults.
06:37:08 <Psybur> % System.Directory.getFileSize "bruh.txt" <&> ((/1000.0^2) . fromInteger)
06:37:09 <yahb> Psybur: 55.451648
06:37:11 <Psybur> Nice
06:37:14 <orion> I grepped the entire code base for "unsafe", and didn't find any results.
06:37:34 <orion> So my question is: What do I do now?
06:37:36 <merijn> orion: Do you use the FFI?
06:37:42 <orion> merijn: No.
06:37:45 <adjofun> orion: grep Ptr =:)
06:37:55 <merijn> Load the core dump in gdb :p
06:38:27 <lyxia> <&> is in Data.Functor now!
06:38:50 <merijn> Nice
06:38:50 <Psybur> hell yeah!
06:42:38 <pavonia> :t (<&>)
06:42:39 <lambdabot> Functor f => f a -> (a -> b) -> f b
06:47:22 <Psybur> Strange. I installed base-4.11.0.0 but I still cant use <&>
06:47:48 <geekosaur> @index (<&>)
06:47:48 <lambdabot> bzzt
06:48:01 <merijn> Psybur: "I installed base" <- eh, what do you mean by that?
06:48:01 <Taneb> > (+1) <&> (*2) $ 3
06:48:04 <lambdabot>  8
06:48:16 <Psybur> stack install base-4.11.0.0
06:48:18 <Taneb> <&> is reverse function composition :)
06:48:20 <Psybur> For the global project
06:48:30 <merijn> Psybur: Yeah, that can't work
06:48:32 <geekosaur> you can;t do that, not usefully
06:48:35 <merijn> Psybur: base is a part of GHC
06:48:38 <geekosaur> base is wired into the compiler
06:48:52 <Psybur> Hmm, how do I upgrade the global project then? D:
06:49:08 <ziman> > 3 & (+1) <&> (*2)
06:49:09 <pavonia> Update GHC
06:49:11 <lambdabot>  error:
06:49:11 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M501942452292...
06:49:11 <lambdabot>        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
06:49:13 <geekosaur> upgrade ghc, which in this case means changing the resolver the global project is using to one that uses the ghc you want
06:49:33 <merijn> Psybur: base-4.11 is part of ghc-8.4, so you need to switch to ghc8.4
06:49:40 <Psybur> Yes, I upgraded the resolver in the global project.
06:49:46 <Psybur> But now what? heh
06:49:54 <adjofun> > 3 & (+1) <$> (*2)
06:49:57 <lambdabot>  7
06:50:00 <geekosaur> 8.4 may mean a nightly because stack was holding off on it due to bugs fixed in the just-released 8.4.2
06:50:15 <ziman> > 3 & ((+1) <&> (*2))
06:50:18 <lambdabot>  8
06:50:38 <lyxia> Psybur: are you running ghci with stack exec ghci
06:50:49 <cocreature> or "stack ghci"
06:50:56 <Psybur> Yes. I guess 11.5 isnt new enough
06:51:39 <geekosaur> as I just said
06:52:00 <geekosaur> 8.4.1 had some severe bugs so they didn't make an LTS release using it
06:52:05 <Psybur> Yep, that did the trick
06:53:09 * hackage hw-prim 0.4.0.7 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.4.0.7 (haskellworks)
06:53:17 <geekosaur> and 8.4.2 went GA literally yesterday, so it'll be a bit before it's been tested enough for there to be an LTS resolver for it
06:58:04 <Psybur> Man haskell is so much easier to read when you can follow it from left to right instead of right to left ;p
07:01:09 * hackage hw-prim 0.5.0.1 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.5.0.1 (haskellworks)
07:02:06 <adjofun> afaik there is an unspoken battle between mathematicians and computer scientists with denotation of function composition. Mathematicians use `(f . g)(x) = f(g(x))`, CS people use `(g;f)(x) = f(g(x))`
07:03:28 <Cale> adjofun: uh, everyone uses both of those some of the time.
07:03:42 <Cale> adjofun: but on both sides, the first notation is far more popular
07:03:45 <hc> the "mathematican's notation" looks much cleaner imho
07:03:48 <adjofun> Both sides argue that their notation is more cogent =)
07:04:35 <ystael> adjofun: and then there's the old school algebraists' convention (see I. Herstein, Topics in algebra), which would write what you gave as xgf
07:04:55 <Cale> Is that really "old-school"? :)
07:05:24 <adjofun> ystael: and then we throw in left-handed Polish notation =:)
07:05:33 <Eduard_Munteanu> There's also f . g . x
07:05:36 <Cale> I don't know that there's a time in history where that notation was ever more popular than the usual convention.
07:06:21 <ystael> I think it competed seriously for a while in the mid 20th century among algebraists specifically
07:06:33 <ystael> but it's been a long time, I may be misremembering
07:10:34 <ph88> does someone know a combinator that takes a parser to match ("AB") and a parser to stop ("XY")?   So "ABABXY" -> match "ABAB" leave "XY" not consumed
07:11:05 <adjofun> ystael: I can kinda see how that notation may represent a view of idea, but it seems to me it can backfire with `sin x / n = six` kind of situation
07:12:11 <Cale> ph88: manyTill?
07:12:24 <ph88> from which package ?
07:12:35 <Cale> parsec
07:12:42 <Cale> Most parser combinators?
07:12:50 <ph88> i use megaparsec
07:13:45 <Cale> http://hackage.haskell.org/package/megaparsec-6.5.0/docs/doc-index-M.html -- it's listed in the index, but unlinked, weirdly
07:14:16 <Cale> Ah, it's apparently reexported from http://hackage.haskell.org/package/parser-combinators-0.4.0/docs/Control-Monad-Combinators.html
07:15:36 <ph88> ah ok thanks !
07:16:01 <jchia_1> Is there a way to pattern match in a do block so that failure to match results in 'fail'? E.g. Matching (x:xs) in a Maybe [Int] do block, but if I try to do "(x:xs) <- blah" in the do block, I think I'll get an error about non-exhaustive patterns or something like that.
07:16:56 <Eduard_Munteanu> jchia_1, it does 'fail', but what fail does depends on the monad
07:17:12 <jophish> Grr, LANGUAGE CPP is breaking my haddocks!
07:17:17 <Cale> jchia: That's exactly why fail exists in the first place
07:17:36 <ph88> Cale, i think manyTill consumes "end"
07:18:11 <Eduard_Munteanu> Wrap it in a lookahead?
07:18:19 <ph88> ok let me try
07:18:22 <Cale> ph88: Oh, yeah, use lookAhead :)
07:20:26 <jchia_1> Eduard_Munteanu: Thanks. I was mistaken about non-exhaustive patterns in do blocks.
07:22:17 <jchia_1> I suppose the error about non-exhaustive patterns applies only to 'let', function definitons and case, not "<-".
07:25:16 <adjofun> jchia_1: but "x <- y" is sugar, which translates to " y >>= (\x -> ...)" iirc
07:28:46 <jchia_1> adjofun: Somehow pattern match failure for (<-) just results in 'fail', not an error about non-exhaustive patterns and I'm not sure exactly why. "main = print $ (\(x:xs) -> x) ([] :: [Int])" results in a run-time error "Non-exhaustive patterns in lambda"
07:31:46 <jchia_1> If the non-exhaustive lambda gets an error, I don't know why the non-exhaustive "(x:xs) <- blah" does not get an error but gets 'fail' instead.
07:31:51 <jophish> cpphs to the rescue!
07:32:44 <lyxia> jchia_1: fail can be overloaded, that's useful for [] and Maybe.
07:33:17 <pavonia> jchia_1: It's not just a simple lambda in desugaring, it's more like a case that uses fail in the "otherwise" branch
07:33:37 <lyxia> and also in any other monad that can handle the error.
07:36:17 <jchia_1> So the 'desugaring' of do blocks is not simply a rewriting of the code in terms of >>= and lambdas, and when the lambda doesn't match something special is done, correct?
07:37:03 <dysfun> the desugaring is literally just a rewriting of code in terms of >>= and lambdas
07:37:12 <lyxia> and >> and fail
07:37:14 <dysfun> yes
07:39:09 <jchia_1> OK
07:41:57 <jchia_1> In hindsight, I think this is the page I was looking for: https://wiki.haskell.org/MonadFail_Proposal
07:44:18 <HelpfulLittleGob> Hey guys, where can I read up on dependency graphs for CS?
07:44:24 <geekosaur> @undo do { (x:xs) <- blah; foo x }
07:44:24 <lambdabot> blah >>= \ a -> case a of { (x : xs) -> foo x; _ -> fail ""}
07:46:39 <pavonia> `fail ""' is just a simplification, no?
07:47:15 <geekosaur> yes, it's not doing the work to show the source location of the pattern match
07:47:47 <geekosaur> otherwise ti should be correct
07:49:58 <pavonia> @undo do { x:xs | odd x <- blah; foo x }
07:49:58 <lambdabot> <unknown>.hs:1:11:Parse error: |
07:50:52 <bender|> A few years ago I knew a guy named Kell. He was a pretty cool dude, but fella used to always get into trouble with the local gangs and stuff. Like, one fine day he started arguing with two local gang members because they were harassing an old man. Soon enough, trouble came to find him. He was walking back to his home when three gang members threatened him and said that they would kill him if he didn’t comply. He was then
07:50:52 <bender|> taken to some unknown location. Two days later the local police got on the case and finally discovered the gang members that had Kell. As soon as the police barged into the gang HQ, gunshots were fired. It was then, a police officer noticed a gang member taking Kell. He said on his microphone, “He haskell.”
07:52:02 <Psybur> bender| -> _|_
07:55:40 <adjofun> bender|: booooo, get off the stage
08:10:22 <HelpfulLittleGob> I am
08:10:23 <HelpfulLittleGob> the
08:10:25 <HelpfulLittleGob> most helpful
08:10:27 <HelpfulLittleGob> Gob
08:12:25 <HelpfulLittleGob> Gobbidy Gob
08:14:54 <typetetris> Nice, just noticed my keyboard layout has ⊥
08:16:43 * shapr hops quietly
08:18:33 <typetetris> HelpfulLittleGob: Do you already know about the helpful qualities of our lord and saviour functional programming?
08:29:53 <mpickering> Does cabal pipe stderr somewhere?
08:31:47 <mpickering> ah no
08:53:09 * hackage brick 0.36.1 - A declarative terminal user interface library  http://hackage.haskell.org/package/brick-0.36.1 (JonathanDaugherty)
08:53:11 * hackage vector-sized 1.0.1.0 - Size tagged vectors  http://hackage.haskell.org/package/vector-sized-1.0.1.0 (jophish)
08:57:39 * hackage servant-auth-token-acid 0.5.3.1 - Acid-state backend for servant-auth-token server  http://hackage.haskell.org/package/servant-auth-token-acid-0.5.3.1 (NCrashed)
08:58:31 <adjofun> aw man, I wish brick was buildable under windows =(
09:47:48 <cocreature> adjofun: the vty author was looking for someone to help with windows support so if you know anything about that … :)
09:53:49 <sm> yes please
10:04:31 <Psybur> In this definition for the applicative definition for a toy Parser, I dont understand the (f a) part.
10:04:36 <Psybur> (Parser cs1) <*> (Parser cs2) = Parser (\s -> [(f a, s2) | (f, s1) <- cs1 s, (a, s2) <- cs2 s1])
10:05:13 <Psybur> I suppose that only works if cs1 returns a function type?
10:06:11 <Psybur> What if your parser is something like String -> [((),String)]
10:06:23 <Psybur> f a wouldnt work there would it?
10:09:44 <byorgey> Psybur: yes, cs1 has to return a function type, which is guaranteed by the type of <*>
10:10:00 <byorgey> (<*>)Parser (a -> b) -> Parser a -> Parser b
10:10:01 <Psybur> Do Parsers generally parse into functions?
10:10:05 <byorgey> (<*>) :: Parser (a -> b) -> Parser a -> Parser b
10:10:16 <Psybur> Oh right
10:10:19 <Psybur> Dur
10:10:29 <Psybur> Ignore that :D
10:10:32 <byorgey> ok =)
10:10:37 <humanoyd> Is this approach (https://ocharles.org.uk/blog/posts/2014-12-10-nullary-type-classes.html) actually used or has it turned out to be a bad idea?
10:16:28 <lyxia> I haven't ever seen it used
10:18:38 <humanoyd> lyxia: thanks, I thought so
10:29:35 <sophiag> i realized a design problem i was stuck on could be modeled as a comonad, but since i've never writen a comonad instance before i'm a bit confused about the definitions. what's mainly tripping me up is the type and data constructors are a bit incongruous: i have Foo :: a -> Foo [a], but i'd like a composition of comonads to nest Foos rather than [a]s
10:29:55 <sophiag> here's the shortest example i could whip up: https://gist.github.com/Sophia-Gold/4489b21029b5cdd53e106dff50f3aa91
10:30:18 <lyxia> what makes you think it's a comonad then
10:30:25 <edwardk> sophiag: Foo isn't a comonad unless you have a guarantee the list is always nonempty
10:30:44 <edwardk> which is better provided by say, using NonEmpty in there ;)
10:31:02 <edwardk> then you have the problem that your duplicate is illegal and fails the laws
10:31:49 <sophiag> i figured it was something like that. my thinking is that the commented out definitions of extract and duplicate should yield the type signature i'd like for `bar`, but i'm clearly breaking one of the laws by using them
10:32:47 <edwardk> sophiag: you don't have a legal extract and you don't have a legal duplicate, so you are currently pretty far from a comonad.
10:33:31 <EvanR> the typeclass police will get you
10:33:47 <sophiag> yes, the ones that typecheck do not make sense to me
10:33:50 * edwardk dispatches the typeclass police to sophiag's location.
10:33:55 <sophiag> lol
10:35:11 <edwardk> there is a comonad for NonEmpty, but its a bit different than what you have. for non-empty lists the head is always defined, so you can extract that, duplicate then basically takes 'tails' and drops the empty list case.
10:35:36 <sophiag> that might actually be perfect
10:35:50 <edwardk> Data.List.NonEmpty should have that instance right out of the box
10:36:22 <edwardk> If you want a ton of similar constructs look at my 'streams' package
10:36:39 <edwardk> they cover a pretty wide cross-section of the valid comonads in this general area
10:36:41 <sophiag> i thought i'd largely use these instances for liftW2 when writing instances on Foo, but ended up just writing a function that only unwraps the head of the newtype and leaves the tail (with corresponding pattern synonyms) so i don't need any lifting on th rhs
10:38:03 <sophiag> but the case of empty lists makes the pattern synonyms really ugly and also requires i use the data constructor on the rhs
10:38:31 <edwardk> the problem is 'just extracting the head' when doing duplicate isn't going to fail a comonad law. Similarly just extracting the head in the ComonadApply case will fail the _symmetric_ strong lax semimonoidal comonad condition.
10:39:43 <sophiag> i meant i'm doing that in place of using liftW2. i'm just implenting something like a safe head and safe tail that return a tuple and defining unidirectional pattern synonyms on them
10:39:48 <edwardk> every comonad can be made semimonoidal using the kind of definition you put in there for <@>, so its not interesting
10:40:00 <edwardk> but symmetry is harder
10:40:38 <sophiag> right, that definition was just so i could use liftW2. it's essentially free and i assume could be derived somehow?
10:40:51 <edwardk> er s/isn't going to fail a comonad law/is going to fail a comonad law/
10:41:43 <edwardk> the problem is your ComonadApply fails the comonadapply laws, so leaning on liftW2 is cheating (and not helping because everything else is broken long before you get to that point)
10:43:40 <sophiag> well, now that i'm looking at NonEmpty it's essentially a correct version of what i was doing ad hoc instead of using that ComonadApply instance. the thing i'm still unsure about is getting the nesting behavior on the newtype rather than the list (it would probably make more sense once i can find the comonad instance for NonEmpty)
10:44:49 <sophiag> ah, ok so it seems like it *should* just work out of the box...
10:45:53 <sophiag> edwardk: thanks. i'll sub in NonEmpty and see if that just does it
10:48:05 <edwardk> np
10:50:33 <ph88> hey guys, i updated my code from lts 8.2 to 11.2 ... i had to make a few modifications to my code but it loaded in ghci. But with compiler optimization i go from 8 minutes to longer than an hour (i aborted it after an hour) .. how can i track down why compiling takes so much extra time ?
10:51:48 <pavonia> Is it slower in general or only for specific modules?
10:52:05 <ph88> only for the main module
10:52:16 <ph88> but i liked to have all my code in one file so that file is 5000 lines
10:52:36 <ph88> but 8 minutes compile time with a lot of optimizations turned on was very acceptable before
10:53:22 <ph88> for each AST node i have a parser, a prettyprinter and an arbitrary generator .. it's nice to keep them together. Makes maintaining the code easy
10:53:33 <shapr> edwardk: could a comonad checker be added to https://hackage.haskell.org/package/checkers ?
10:54:26 <ph88> so what could be some strategies to find out about slow compile times ?
10:54:35 <cocreature> binary search :)
10:54:56 <cocreature> i.e. remove half of your code, see if it’s still slow
10:55:31 <ph88> i was hoping for something more advanced than that :'(
10:55:34 <cocreature> but I’d probably check if you can reproduce it with 8.4.2 first. maybe it was a regression that has been fixed
10:56:41 <ph88> stackage nightly is on 8.4.1 is that ok too ?
10:57:22 <ph88> not even sure how to setup ghc without stack
10:57:25 <cocreature> at least worth a shot
10:57:27 <ph88> ok
10:57:31 <ph88> let me try thn
10:58:13 <ph88> stupid thing is that i'm already 4 commits ahead .. i didn't check for this compile time regression :(
11:16:10 * hackage haskell-gi 0.21.2 - Generate Haskell bindings for GObject Introspection capable libraries  http://hackage.haskell.org/package/haskell-gi-0.21.2 (inaki)
11:38:55 <monochrom> Heh, today's xkcd sounds like the memory profile of many programs too.  GC once in a while but memory footprint keeps growing.
11:43:47 <EvanR> about 12 years ago i developed a log scale to track how much crap i have
11:43:54 <EvanR> works well
11:44:22 <EvanR> theres something like a boltzman constant to put it in perspective
11:44:43 <bitemyapp> monochrom: that's basically how Golang's "real-time" GC works.
11:48:17 <EvanR> also i resemble that remark, prev xkcd
11:48:28 <EvanR> https://xkcd.com/1982/
11:50:47 <monochrom> heh
11:54:06 <rmeis> Hi, newb here. I am stuck with using sdl2 library. Anyone able to help?
11:55:41 <lemmih> rmeis: Start by asking your question.
11:59:30 <EvanR> may i ask lemmih to ask rmeis to ask a question
12:10:14 <rmeis> OK thanks, I need a the function 'pushEvent :: Event -> IO ()'. There is a low level version Raw.pushEvent available but I have no idea how to get from Event to Raw.Event. Hope that makes sense ...
12:11:18 <rmeis> The other way around there is convertRaw :: Raw.Event -> Event
12:14:34 <EvanR> are you sure you really want to push events
12:15:02 <EvanR> haskell has nice concurrency primitives to do your own stuff
12:15:16 <EvanR> sdl event queue by comparison is pretty clunky
12:17:07 <EvanR> there is no conversion from high level Event back to raw Event
12:17:23 <cocreature> it looks like the low level version expects a Ptr Event and Event has a storable instance
12:17:34 <EvanR> its like trying to turn a boiled egg back into a raw egg
12:17:42 <EvanR> you can of course make your own raw Events
12:18:02 <cocreature> so you could use alloca and poke
12:18:28 <lemmih> Or 'with', preferable.
12:18:40 <cocreature> ah yeah I knew that existed but couldn’t find it :)
12:19:39 <lemmih> rmeis: Foreign.with can turn an Event into a 'Ptr Event'.
12:20:37 <lemmih> rmeis: Oh wait, which Event are talking about here?
12:20:42 <EvanR> raw event
12:21:02 <cocreature> what is that? https://hackage.haskell.org/package/sdl2-2.4.0.1/docs/SDL-Raw-Event.html#v:pushEvent just takes a Ptr Event
12:22:33 <cocreature> ah https://hackage.haskell.org/package/sdl2-2.4.0.1/docs/SDL-Event.html#t:Event is the high level event type
12:22:49 <lemmih> rmeis: You're probably out of luck, then.
12:22:58 <ph88> cocreature, it's also very slow with ghc 8.4.1 .. (mind that lts upgraded also packages) .. so i guess binary search is my only option now ?
12:23:24 <EvanR> theres plenty of things rmeis could do
12:24:19 <sm> nothing wrong with binary search, it is a mighty hammer
12:24:23 <EvanR> exactly what you said to do, is among them. use with to get a Ptr to the raw event you made
12:24:35 <EvanR> and do the low level call
12:24:45 <cocreature> ph88: yeah, I suppose you could try compiling compiling with -v3 but it’s probably just going to tell you it’s stuck somewhere in the simplifier
12:30:49 <kettle> What's the best/most-idiomatic Haskell way of getting separate fields from the output of a function into different places in another function?
12:30:57 <kettle> E.g. I have a function `pointToSides :: Point -> Point -> (Side, Side, Point)`
12:31:27 <EvanR> use a lambda abstraction?
12:31:39 <kettle> that does some arithmetic to turn a `Point` (a tuple of (x,y)) into a pair of `Sides` (lengths) and an origin Point
12:32:05 <EvanR> \(a,b) (c,d) -> (_, _, _)
12:32:45 <rmeis> lemmih: To give a little background on what I am doing, I am recording "Events" and playing them back at a later point in time. So I am talking about any Event.
12:33:03 <kettle> EvanR: What would that do exactly? I'm not familiar with lambda calculus or abstractions in Haskell
12:33:17 <EvanR> maybe i misunderstood your question
12:33:30 <edwardk> data Sides = Sides { length1 :: Side, length2 :: Side, origin :: Point }
12:33:40 <edwardk> pointsToSides :: Point -> Point -> Sides -- =)
12:33:53 <johnw> kettle: when we say lambda abstraction, you may know it as "anonymous function" or "callable value" in other languages
12:34:02 <lemmih> rmeis: So you probably have a function that consumes Events. How about passing the events directly to that function?
12:34:08 <geekosaur> rmeis, one problem you're likely to run into is that not all high level Event-s map to Raw.Event-s
12:34:23 <kettle> johnw: ahh, that makes more sense. Sorry, I'm still rather haskell-illiterate :P
12:34:48 <johnw> kettle: no problem, we use some special language here, but it's motivated by wanting to maintain the connections to math and programming language theory
12:35:13 <johnw> C++ has lambda abstractions too, but since they don't call them that, it's easy not to recognize them as such
12:35:14 <kettle> edwardk: so using field labels? I tried that before and I got "Record syntax is illegal here"
12:35:56 <old1101> Hey, does anyone know the magic algorithm for this http://vpaste.net/6B3MV (did I explained it well enough?) ? I tried graphs, shortest path, reading by column, some hardcoded logic, but it doesnt solve all the cases
12:36:09 <edwardk> kettle: i think you had some sort of basic syntactic of logical error
12:36:15 <kettle> edwardk: I don't know if that was due to where I had used the field labels though (in the function type definition IIRC - I tried it a while ago for another function and haven't tried since)
12:36:19 <EvanR> rmeis: either youll need to record the low level events, or you need to rethink this and use your own notion of event and event queue
12:36:23 <rmeis> lemmih: no, not at the moment, thats why i wanted to use Raw.pushEvent
12:36:27 <edwardk> er syntactic or
12:36:34 <kettle> edwardk: yeah, probably. I'll have another go
12:36:44 <edwardk> you don't put labels in the type definition.
12:36:53 <edwardk> the data type 'Sides' has field accessors
12:36:58 <rmeis> geekosour: I am mostly interested in mouse and keyboard events. I guess i can find the mapping in Events.hs?
12:37:14 <camsbury> hey users of `streaming`, I've closed out a stream with `S.mapM_`, and used `runResourceT` immediately after. My logs show that the effects I expected are being run at the least... but I'm still getting a `hGetBufSome: illegal operation (handle is closed)`... any ideas? Streaming from a file handle.
12:37:15 <edwardk> the function type just returns a value of type 'Sides' which is basically the same as your tuple, just named with field accessors
12:37:55 <kettle> edwardk: ahh right, that makes more sense. Thanks
12:39:32 <edwardk> returning (x,y,z) or returning (Sides x y z) or Sides { label1 = x, label2 = y, origin = z } isn't appreciably different, but now users can take that result and access members of it. the mess is the names of the field accessors need to be unique or you have to move to tricks like classy lenses and the like.
12:40:17 <rmeis> EvanR: ok I will give this a try.
12:40:45 <rmeis> lemmih, EvanR, geekosaur thanks for the help
12:40:50 <edwardk> public non-binding poll: https://www.reddit.com/r/haskell/comments/8d5apd/ann_constraintsemerge_defer_instance_lookups/dxkqzt8/ <- suggestions for what to call that thing?
12:41:20 <zincy> If I have a function Maybe a -> Maybe (IO ())   how would I compose it with an a -> Bool ?
12:41:40 <edwardk> its basically the middle ground between Maybe and Either, where you can smuggle a message out but only as an error
12:42:34 <edwardk> zincy: yourfunction . fmap yourpredicate
12:43:03 <zincy> edwardk -- Ooh thanks
12:43:04 <jle`> zincy: what sort of composition?
12:43:10 <edwardk> zincy: what does your function do when the input is Nothing btw?
12:44:02 <edwardk> er nevermind
12:44:07 <edwardk> that thing i said makes no sense
12:44:12 <edwardk> a occurs in negative position in both
12:44:18 <edwardk> you can't compose those things
12:44:26 <zincy> edward k - returns Nothing
12:44:57 <edwardk> zincy: then shouldn't your first function be (a -> Maybe (IO ()) instead and then you can use things like the monad instance for Maybe to compose things?
12:45:02 <EvanR> Maybe a -> Maybe (IO ())  ???  a -> Bool  = (a,Maybe a) -> (Bool, Maybe (IO ())) :)
12:45:11 <edwardk> evanr: =)
12:45:29 <zincy> jle - not sure
12:45:31 <edwardk> but the two functions you have there don't compose as functions, both want to consume the 'a'
12:46:05 <Cale> zincy: What are the two functions computing? It strikes me that Maybe (IO ()) is a little uncommon, if occasionally quite useful.
12:46:07 <edwardk> unless you mean to make your function from a -> Bool act like a guard or something, e.g. only succeed if this precondition holds
12:46:47 <edwardk> and yeah, the types involved here "smell" pretty weird.
12:47:28 <jle`> zincy: why don't you show how you would implement it using pattern matching
12:47:33 <jle`> and we can see if there's a way to clean it up
12:47:38 <kudomarkos> Hello Everybody
12:47:39 <jle`> pattern matching on the Maybe, and using if/then or guards
12:48:11 <EvanR> accepting a Maybe a is a bit weird
12:48:12 <zincy> second function is actually  MVar b -> Maybe a -> Maybe (IO ())
12:48:13 <Cale> kudomarkos: hello
12:48:31 <edwardk> evanr: especially when it maps Nothing -> Nothing. its a sign monadic composition was missed
12:48:32 <EvanR> outside of the standard combinators
12:48:38 <EvanR> right
12:48:43 <shapr> salut kudomarkos
12:48:58 <zincy> http://lpaste.net/365059
12:49:01 <lyxia> edwardk: Result(Ok,Err) to confuse everyone coming from Rust.
12:49:04 <kudomarkos> I do really need help with an instance SHOW of a function, please
12:49:05 <kudomarkos> https://pastebin.com/fxcpKs62
12:49:31 <zincy> There is a link to the two functions I am trying to 'compose'
12:49:32 <kudomarkos> I am very new, and i don't understand how to do it
12:49:35 <edwardk> so you only want to broadcast valid auction actions?
12:50:51 <zincy> edwardk - Yes exactly
12:51:23 <edwardk> there is no need for broadcastAuctionAction as it is written to live in Maybe
12:51:30 <Cale> zincy: It might make more sense I think just for broadcastAuctionAction to produce a straightforward IO action, since it only ever produces Just of one.
12:52:17 <zincy> Just added another function for more context although unrelated to my initial question
12:53:13 <zincy> Isnt broadcastAuctionAction an IO action which may never be executed?
12:53:13 <EvanR> take AuctionAction (non-maybeified) and return an IO action. then elsewhere you can decide to not use it for some reason
12:53:26 <EvanR> it will be simpler
12:53:37 <kudomarkos> uh,
12:54:11 <edwardk> for zincy https://www.irccloud.com/pastebin/KzmLyhrE/Zincy.hs
12:54:35 <Cale> zincy: Oh, sorry, I missed the Nothing case, but yeah, what EvanR said :)
12:55:35 <kudomarkos> Ok, if you can't help me, could you show me an example. I can't find any in google
12:55:55 <edwardk> zincy: notice how broadcastAuctionAction is much simpler
12:55:57 <zincy> Thanks everyone you are  all incredibly helpful!
12:56:37 <EvanR> i found this exact technique works in other languages too
12:57:04 <EvanR> make functions responsible for less and at the use site put the extra bureaucracy
12:57:09 <edwardk> lyxia: =)
12:57:11 <zincy> edwardk - Yeah much better! What would you replace the traverse function with in my snippet?
12:57:46 <edwardk> traverse function? i guess you had an earlier snippet i didn't see?
12:57:59 <zincy> I updated it just after you looked
12:59:57 <edwardk> that is a very weird line of code. why are you traverse_'ing there?
13:00:55 <edwardk> https://www.irccloud.com/pastebin/bJmlH1ja/
13:01:10 <edwardk> no need to traverse_ or play any games
13:01:14 <EvanR> (serverState is unused)
13:01:18 <edwardk> or does parsedAuctionAction have the ability to fail?
13:01:23 <edwardk> ah, then
13:02:13 <zincy> The idea of traversing was to only execute the io action on the condition that the parsedAuctionAction succeeded - does it make sense in light of that?
13:02:17 <edwardk> https://www.irccloud.com/pastebin/DTViBL8Y/
13:02:45 <zincy> I guess returning a maybe IO is a bit pointless as it would be simpler as you did and just not execute the IO action on a condition
13:02:53 <edwardk> yeah
13:03:22 <zincy> correct parsedAuctionAction returns a Maybe AuctionAction
13:03:24 <EvanR> so is for_ a good way to combine Maybe or Either with IO in that way
13:03:44 <EvanR> i always wondered what the "standard" way is
13:03:50 <zincy> The when call is nice I havent seen that before is that specific to IO actions or any monad?
13:04:24 <EvanR> when is just a Monad library function
13:04:26 <EvanR> :t when
13:04:28 <lambdabot> Applicative f => Bool -> f () -> f ()
13:04:28 <edwardk> :t when
13:04:29 <lambdabot> Applicative f => Bool -> f () -> f ()
13:04:42 <EvanR> oops, now it works for any Applicative
13:04:51 <edwardk> it is in Control.Monad but works for any Applicative
13:05:08 <kudomarkos> can someone help me with an SHOW (/f -> a) example, please??? http://lpaste.net/365063
13:05:39 <zincy> cool
13:05:58 <zincy> Need to read up on how the for_ works
13:06:05 <EvanR> :t for_
13:06:06 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
13:06:19 <EvanR> its like a for loop, on acid
13:07:27 <zincy> Where is the 'collection' is that t a?
13:07:34 <EvanR> yes
13:07:35 <lyxia> kudomarkos: why are you trying to Show functions
13:08:37 <kudomarkos> Because an exercise.. :( but i don't see examples
13:09:11 <kudomarkos> lyxia do you know an example? google is not my friend today : (
13:09:45 <Lears> > (+1)
13:09:47 <lambdabot>  <Integer -> Integer>
13:09:51 <edwardk> zincy: "Maybe a" is a collection of 0 or 1 'a's
13:09:54 <Lears> Looks like lambdabot has one.
13:11:18 <lyxia> yeah but lambdabot has attenuating circumstances.
13:11:19 <zincy> edwardk - a so that is why in the case of  Nothing there are no elements to apply the function to
13:11:23 <edwardk> effectively, when limited to Maybe you get: for_ (Just a) f = () <$ f a;    for_ Nothing f = return ()
13:11:56 <edwardk> zincy: yeah. and if you upgrade parseAuctionAction to return a list it'll do the body for each one of them
13:12:17 <lyxia> kudomarkos: what should that code do
13:12:20 <edwardk> and it still works if you switch over to Either String a  -- in case you want error reporting
13:12:29 <lyxia> kudomarkos: What is (show (\_ -> Nothing))
13:12:39 * hackage coerce-util 0.1.0.0 - utils for Data.Coerce  http://hackage.haskell.org/package/coerce-util-0.1.0.0 (chessai)
13:13:15 <edwardk> kudomarkos: you can't show functions
13:13:31 <zincy> edwardk: What does the () <$ f a do
13:13:47 <edwardk> :t (<$)
13:13:48 <lambdabot> Functor f => a -> f b -> f a
13:13:49 <zincy> :t <$
13:13:50 <lambdabot> error: parse error on input ‘<$’
13:13:52 <cocreature> @src (<$)
13:13:53 <lambdabot> (<$) = (<$>) . const
13:14:04 <zincy> :t const
13:14:05 <lambdabot> a -> b -> a
13:14:08 <kudomarkos> edwardk: Yes I can... my teacher asked me for that exercise
13:14:16 <cocreature> x <$ y = fmap (const x) y
13:14:21 <EvanR> > for_ (Left "bad stuff") (x -> undefined) :: [Int]
13:14:23 <lambdabot>  error:
13:14:23 <lambdabot>      Pattern syntax in expression context: x -> undefined
13:14:29 <EvanR> > for_ (Left "bad stuff") (\x -> undefined) :: [Int]
13:14:31 <lambdabot>  error:
13:14:31 <lambdabot>      • Couldn't match type ‘()’ with ‘Int’
13:14:31 <lambdabot>        Expected type: [Int]
13:14:37 <edwardk> all its doing there is fmap (const ()) -- throwing away the result from the monadic action in case it had one to turn it into an IO () in your case if it was something else
13:14:44 <EvanR> > for_ (Left "bad stuff") (\x -> undefined) :: [()]
13:14:46 <lambdabot>  [()]
13:14:51 <kudomarkos> lyxia: _ -> Nothing        (This One I don't want to show it)
13:15:09 <edwardk> kudomarkos: then you clearly misunderstood your professor
13:15:24 <EvanR> you can't show an arbitrary function
13:16:08 <kudomarkos> can't I show The tuplas?
13:16:40 <EvanR> if you hold a function all you can do with it is apply it to arguments and observe the results
13:16:41 <chorhizo> kudomarkos, you don't need a show instance for that though
13:17:04 <edwardk> kudomarkos: what you are asking for isn't 'a little difficult' and its not like we misunderstood you, its fundamentally not in the realm of possibility. so if you want to "show" your "Tablero" type you need to figure out some way to encode it in an ADT that represents what those functions might be. this is really quite hard, so i suspect you misunderstood the problem somewhere.
13:17:42 <kudomarkos> example: (\pos -> if pos == (9,2) then Just Rey else if pos == (8,7) then Just Alfil else Nothing)
13:18:12 <edwardk> kudomarkos: if you're just using a Tablero as a Map, why isn't it a Map?
13:18:16 <kudomarkos> if i want to show that in that way: ((9,2,Just Rey), (8,7,Alfil)
13:18:36 <chorhizo> edwardk, I would guess that's some professor supplied code
13:18:40 <Cale> kudomarkos: What about all the infinitely many other cases?
13:19:13 <edwardk> kudomarkos: nothing prevents your function from doing arbitrarily complicated things
13:19:35 <kudomarkos> Cale... That is why i try to know! haha
13:19:37 <edwardk> chorhizo: sure. but the thing he's asking for he can't have, so its replace it with a Map or accept you can't show it
13:19:51 <EvanR> you can show it at selected arguments, like (9,2) and (8,7) and no others
13:19:55 <chorhizo> edwardk, right, I'm 99% sure he just midread the question...
13:20:06 <edwardk> yep
13:20:14 <Cale> kudomarkos: Functions are black boxes, there's no way for your show function to discriminate that the function produces Nothing for every value other than (9,2) and (8,7) -- it would just have to try many pairs (potentially forever) and see what it gets.
13:20:19 <chorhizo> or maybe it's just a red herring and his prof wants him to say it's not possible - unlikely lol
13:20:29 <kudomarkos> edwardk Tablero was created by my teacher, not me. I don't know how I would create it at first place since beggining
13:20:40 <edwardk> kudomarkos: "Tablero" cannot be shown
13:20:47 <EvanR> show _ = "<Tablero>"
13:20:51 <edwardk> =)
13:21:31 <edwardk> you can ask its values at various positions, but Posicion has infinitely many inhabitants, so you can literally never stop asking questions of the function to try to display it properly
13:21:54 <kudomarkos> no, they aren't infinitely
13:22:06 <edwardk> (Integer,Integer) -- how many pairs of integers are there out there?
13:22:16 <kudomarkos> the tuples (1,2) are the squares of a chess table
13:22:23 <kudomarkos> so they are only 32
13:22:25 <edwardk> ok, _now_ we're getting somewhere
13:22:28 <EvanR> 64?
13:22:31 <edwardk> 64 squares on a chess table are enumerable
13:22:58 <kudomarkos> well our table is smaller... and the rules of chess are different
13:23:04 <kudomarkos> but they aren't infinitely
13:23:18 <edwardk> but note that isn't an arbitrary function from (Integer,Integer) -> Maybe Pieza -- its a function from a limited domain
13:23:33 <chorhizo> kudomarkos, right, now we know it's a chess table, but (Integer,Integer) can contain an infinite amount of possibilities
13:23:38 <kudomarkos> (x,y) | x<-[1..4] y<-[1..8]
13:23:43 <edwardk> i'd say your professor doesn't know haskell very well if they are asking you to hang an instance off of a type synonym like that.
13:24:05 <edwardk> but you can successfully implement the specification as given now
13:24:51 <kudomarkos> chorhizo: that is
13:24:57 <edwardk> (in particular it needs TypeSynonymInstances, FlexibleInstances, has terrible type inference, interferes with other such functions, etc.)
13:25:26 <kudomarkos> I dont know TypeSyno,,, etc.... sorry
13:25:26 <edwardk> kudomarkos: did your professor state any preference as for _how_ you'd show the table?
13:25:41 <kudomarkos> edwardk no, she hasn't
13:28:55 <EvanR> > show (undefined :: Void)
13:28:57 <lambdabot>  "*Exception: Prelude.undefined
13:29:02 <zincy> Any recommendations for beginner tutorials on lenses? Trying to get started but not sure how :)
13:29:08 <EvanR> dangit they should have implemented it as ""
13:30:37 <lyxia> zincy: https://www.reddit.com/r/haskell/comments/88k18x/monthly_hask_anything_april_2018/dwlp3qk/
13:31:39 * hackage xmonad-extras 0.13.3 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.13.3 (psibi)
13:32:04 <zincy> lyxia - awesome
13:39:57 <cmotoche> Hello everyone. Does any one know how to do a `ORDERING ASC NULLS FIRST` with esqueleto or persistent? https://www.postgresql.org/docs/9.6/static/queries-order.html
13:40:21 <Gigabitten> so is there a real difference between type FooBar = (String, Integer) and data FooBar = FooBar (String, Integer) maybe I'm missing something obvious here
13:40:41 <geekosaur> the former is just an alias
13:40:56 <geekosaur> there is no difference whatsoever between a FooBar and a (String, Integer)
13:41:24 <geekosaur> "data" makes a new data type, which can have its own typeclass instances and has a constructor to distinguish it for pattern matching and such
13:41:33 <geekosaur> it also adds a chance for extra laziness
13:42:24 <Gigabitten> so why would you use type synonyms over data? are type synonyms more memory-efficient?
13:42:39 <mkoenig> You guys have any idea how to fix this? https://pastebin.com/tHmA4P08 It compiles successfully and I'm not using mtl, only monads-tf.
13:42:45 <EvanR> yes because they dont exist at runtime
13:43:31 <EvanR> type synonyms can make a large complex type easier to write in multiple places
13:44:08 <Gigabitten> kthx
13:44:17 <Gigabitten> that gives me a pretty good idea of when to use which
13:44:31 <EvanR> youre missing "newtype" though
13:44:41 <geekosaur> or just because a name makes more immediate sense, as with String vs. [Char]
13:44:49 <EvanR> which has the benefits of data without the runtime overhead
13:45:38 <EvanR> youll want to understand all 3
13:46:52 <zincy> Does the .both ship with the lens library? myTuple.both %= myUpdatingFunc
13:47:21 <trcc> Hi everyone, I am trying to make a get http request but getting an error related to types. Hpefully one of you can help. http://lpaste.net/365064
13:47:43 <EvanR> :t both
13:47:44 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
13:48:05 <EvanR> zincy: .both is really . both written in a misleading way :)
13:48:07 <trcc> This is the framework that I am using> https://haskell-lang.org/library/http-client
13:49:07 <chorhizo> Hey, I'm trying to use maybeRead, but do I seriously have to install cgi package and import Network.CGI.Protol? For such a useful function seems like it should be in base or something?
13:49:33 <zincy> :t both
13:49:34 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
13:49:44 <EvanR> chorhizo: readMaybe from Data.Text.Read ?
13:50:00 <chorhizo> EvanR, I thought it was called readmaybe... lol
13:50:00 <EvanR> er
13:50:11 <chorhizo> EvanR, I can't find it in hoogle
13:50:16 <chorhizo> https://www.haskell.org/hoogle/?hoogle=readMaybe
13:50:22 <EvanR> from Text.Read
13:50:45 <chorhizo> EvanR, right, but is text.read not in hoogle?
13:50:51 <geekosaur> not in that one
13:50:54 <EvanR> theres 2 hoogles
13:50:57 <EvanR> at least
13:51:04 <chorhizo> well shit, that makes sense, thanks
13:51:07 <geekosaur> hoogle's a bit messed up right now, that one has fuyll type search but an outdated database
13:51:21 <geekosaur> hoogle.haskell.org has a newer databse but type search doesnt work right
13:51:25 <chorhizo> man I love hoogle.. sad times I hope it gets fixed soon
13:51:30 <JuanDaugherty> Oh chorhizo you are my favorite sausage
13:51:35 <chorhizo> JuanDaugherty, thank you
13:51:42 <chorhizo> I am my favorite sausage too
13:51:51 <JuanDaugherty> :)
13:51:54 <sm> "right now" makes it sound.. temporary
13:52:11 <sm> rather than stuck this way for years :)
13:52:31 <EvanR> yes hoogle's breakage should be a Behavior not an Event
13:54:10 <kudomarkos> edwardk: for your information, i just GOT IT
13:54:11 <kudomarkos> :D
13:54:15 <kudomarkos> thanks anyway
13:54:43 <edwardk> like i said, once you collapse it down to an enumerable domain its possible.
13:54:54 <edwardk> but the problem is posed in a really crappy way
13:55:17 <edwardk> because no haskeller would actually write an instance like that hung off of a type synonym that was that loose
13:56:37 <kudomarkos> ahmm... i don't know how a haskeller thinks right now... maybe when i were in a future
13:57:10 <DigitalKiwi> edwardk now I'm going to do it just to prove you wrong
13:57:23 <Franciman> Hello
13:57:46 <edwardk> DigitalKiwi: that way lies excommunication ;)
13:57:59 <DigitalKiwi> what is this #scala
13:57:59 <Franciman> I'm writing a program where I'm asynchronously communicating with a server, is there any library to help making it easier?
13:58:04 <JuanDaugherty> mostly like princesses on high ivory tower above a microscopic but intolerable pea of any deviation from the pure mathesis
13:58:22 <EvanR> Franciman: async !
13:58:27 <JuanDaugherty> *a high
13:58:44 <Franciman> EvanR, doesn't it cover only stuff to start and stop async jobs?
13:59:20 <EvanR> ask your question again then
13:59:39 <Franciman> I was more focused on async communication stuff
13:59:43 <EvanR> because async is the answer to the original one. we can try again
13:59:47 <Franciman> for example do something on event received
13:59:49 <oo_miguel> Which is the most popular light haskell web frameowrk?
14:00:06 <Franciman> send a request and when a respose arrives run callback
14:00:13 <EvanR> use async
14:00:33 <Franciman> sure, thanks I will try
14:00:34 <EvanR> in haskell callbacks are really every IO action
14:00:52 <EvanR> (>>=) :: IO a -> (a -> IO b) -> IO b
14:00:54 <Franciman> probably my current idea isn't very functional... so I was hoping a framework would help me :P
14:01:16 <Franciman> I shall think about the design deeper. Thanks EvanR
14:01:35 <EvanR> so you want to make a request, then block waiting for the response (in a dedicated thread, probably aided with the async library), then continue normally
14:02:04 <EvanR> which flies in the face of javascript style which cant be allowed to block
14:02:34 <Franciman> so I'm encouraged to create many threads?
14:02:40 <EvanR> yes
14:02:45 <Franciman> cool
14:02:48 <Franciman> thanks
14:04:34 <mkoenig> Why am I getting ambiguous interface errors at runtime and how can I solve them? They are not coming from my package, probably from a dependency. https://pastebin.com/tHmA4P08
14:11:39 * hackage haskell-igraph 0.4.0 - Haskell interface of the igraph library.  http://hackage.haskell.org/package/haskell-igraph-0.4.0 (kaizhang)
14:13:10 <chorhizo> is there a reason i can't pattern match Left or Right as _
14:14:17 <lemmih> chorhizo: As in 'fn (_ x) = x' ?
14:15:03 <chorhizo> lemmih, as in, for a function  String -> Either (Maybe Int) (Maybe Int), I take the Either bla bla to case something of _ Nothing = bla, Left (Just x) = something else
14:15:25 <chorhizo> but _ Nothing = bla doesn't work, I get parse error in pattern
14:15:36 <lyxia> mkoenig: find which package depends on monad-tf and which one depends on mtl
14:15:56 <lemmih> chorhizo: Yeah, that's not allowed. You have to write out the cases.
14:16:12 <chorhizo> lemmih, I see. There must be a reason for it?
14:16:13 <lyxia> mkoenig: the second error looks very bad though...
14:17:21 <mkoenig> lyxia: indeed :/
14:17:22 <lemmih> chorhizo: What would the type of 'fn (_ x) = x' be?
14:17:44 <JuanDaugherty> *
14:17:57 <lemmih> chorhizo: 'Either a a -> a' ?, 'Maybe a -> a', something else?
14:18:18 <chorhizo> lemmih, sorry what do you mean?
14:18:31 <trcc> Hi. I am trying to execute a get request, but I get a type error that I cannot figure out. THe code is here: http://lpaste.net/4690850026698571776 and taken from: Basic Usage section on https://haskell-lang.org/library/http-client. Anyone up for looking at it?
14:19:00 <lemmih> chorhizo: Imagine you're the Haskell type-checker and you have to figure out the type of this piece of code: fn (_ x) = x
14:19:15 <lemmih> chorhizo: Can you tell me the type of that function?
14:19:36 <kettle> so I have a function that takes a list in the form "Type (_:_)" and I want to pass whatever the input list is to the body of the function (i.e. FunctionA([a,b,c,..]) = FuncB([a,b,c,...]) ) but somehow my tired brain and google-fu is failing me right now
14:19:39 <lemmih> chorhizo: (This is about why such functions are not allowed in Haskell)
14:19:40 <chorhizo> ah, that makes sense.
14:19:55 <chorhizo> I thought it would infer it from the case statements input
14:20:22 <chorhizo> because since the input is of Either (Maybe Int) (Maybe Int) I thought it would do some magic and _ would match left and right
14:20:29 <kettle> the "Type (_:_)" is because I am pattern matching a function to handle multiple data types, only one of which takes a list
14:21:21 <lemmih> chorhizo: Type signatures are (mostly) optional in Haskell.
14:21:40 <woodson> can anyone help, I cant seems to run any nix command anymore
14:21:55 <woodson> it was working fine earlier not sure what happened
14:21:57 <lyxia> mkoenig: wait isn't this a problem with dynamic linking? Can you try linking statically?
14:22:22 <mkoenig> lyxia: will try :)
14:25:22 <chorhizo> if anyone has any advice on my (admittedly eye shattering) haskell style, I'd highly appreciate it: https://github.com/PotterJam/HaskSCP/blob/master/app/Main.hs
14:25:37 <chorhizo> first thing I've actually tried to build and it's... messier than I'd hope.
14:25:54 <kettle> ok, never mind. I realised I could just write Foo (x:xs) = Bar (x:xs) which seems to work
14:28:16 <EvanR> fn (_ x) = x has type, exists a b . a -> b
14:28:42 <EvanR> so you cant ever use it in a verifiably valid way
14:29:58 <EvanR> that being said you can skip the type system whenever you want and -fdefer-type-errors to runtime :)
14:30:23 <EvanR> and youll be using a really crappy ruby
14:31:22 <EvanR> another options is to use generics to make a function that can unwrap any ADT like that
14:31:45 <EvanR> or make type classes
14:32:11 <EvanR> or do this!
14:32:18 <EvanR> @djinn Either a a -> a
14:32:18 <lambdabot> f a =
14:32:18 <lambdabot>     case a of
14:32:18 <lambdabot>     Left b -> b
14:32:18 <lambdabot>     Right c -> c
14:32:28 <chorhizo> EvanR, yeah I was going to use a type class
14:32:30 <chorhizo> wait what
14:32:30 <EvanR> (generate code from parametricity)
14:33:17 <lyxia> trcc: put the LANGUAGE pragma at the top, above the module line
14:33:24 <EvanR> though hopefully you see Maybe a -> a makes no sense
14:33:33 <trcc> Thank you lyxia
14:33:47 <lyxia> trcc: you're welcom
14:33:49 <chorhizo> EvanR, what do you mean?
14:34:15 <lyxia> chorhizo: why does parseSelection not return Maybe (Either Int Int)
14:34:33 <EvanR> about what
14:34:40 <mkoenig> lyxia: I've compiled it with *-static -optl-static* but the error persists. Do you know how can I check if it's compiled statically on windows? This is my cabal file https://pastebin.com/hi9EGgmC
14:34:54 <chorhizo> about seeing Maybe a -> a makes no sense
14:35:00 <chorhizo> is that in the context of djinn or?
14:35:46 <chorhizo> lyxia, I don't know actually, that would make more sense. I'll be honest I just wasn't sure how to move the maybe to the outside
14:36:15 <chorhizo> since I can't just readMaybe xs since there might be 'd' at the front
14:38:12 <EvanR> no, Maybe a -> a makes no sense in context of haskell
14:38:23 <lyxia> mkoenig: I'm not sure setting it from the cabal file works, try setting cabal flags on the command line
14:38:34 <EvanR> try to implement it yourself and see
14:39:11 <lyxia> chorhizo: Right <$> readMaybe xs
14:39:39 <chorhizo_> Evan can you just do stuff like Just x = x, Nothing = '' for Maybe String
14:40:00 <lyxia> chorhizo: concatenating paths with (++) is dangerous, (</>) should be prefered.
14:40:22 <EvanR> chorhizo: yes, but thats Maybe String -> String
14:40:28 <EvanR> not Maybe a -> a
14:40:38 <chorhizo_> lyxia: goddamn fmap how do I always forget the fundamentals
14:40:40 <EvanR> hence the jargon "parametricity"
14:40:48 <chorhizo_> Evan right yeah I see what you mean
14:41:04 <EvanR> @djinn Maybe a -> a
14:41:04 <lambdabot> -- f cannot be realized.
14:41:51 <chorhizo_> I guess the whole point of maybe is that you can't express any a in the same way
14:42:01 <EvanR> polymorphism has a way of heavily constraining what kind of stuff you can do
14:42:03 <EvanR> which is great
14:42:12 <chorhizo_> lyxia: oh I didn't know about that function, thanks
14:43:10 <EvanR> you can be told what you asked for makes no sense, or told that thing X is the only thing of the type you want that could possibly make sense
14:44:19 <chorhizo_> Yeah, and its good that it doesn't make sense
14:44:33 <EvanR> now you're singing my song!
14:44:36 <EvanR> hallelujah
14:44:44 <chorhizo_> Since like lyxia pointed out wrapping it in maybe makes way more sense
14:45:34 <EvanR> possibly missing results is a good use case for Maybe, yeah
14:46:00 <EvanR> but like we saw earlier its usually not good for "possibly missing arguments"
14:46:49 <EvanR> its also not good for "impossible to be missing results", as silly as that sounds
14:47:44 <EvanR> like, lookup from a chessboard implemented as an array, using keys known to be within bounds
14:47:51 <EvanR> shouldnt return Maybe
14:48:08 <EvanR> ... to indicate out of bounds
14:50:08 <chorhizo_> Right yeah
14:52:13 <EvanR> the relative absense of "maybe everywhere" really blew my mind coming from dynamic languages
14:53:37 <chorhizo_> By dynamic you mean dynamically typed I guess
14:53:47 <EvanR> ABSENCE
14:54:19 <EvanR> dynamically typed, dynamically runtiming, dynamically failing yeah
14:55:14 <chorhizo_> Dynamically failing sounds about right
14:55:33 <maerwald> so haskell is dynamic too
14:55:56 <EvanR> > toDyn 3
14:55:57 <lambdabot>  <<Integer>>
14:56:02 <EvanR> > toDyn 'c'
14:56:04 <lambdabot>  <<Char>>
14:56:05 <EvanR> cool
14:56:06 <DigitalKiwi> only if you use stack *hides*
14:58:26 <mkoenig> lyxia: *cabal new-build --ghc-options "-static -optl-static -optl-pthread"* recompiled everything but it still doesn't work
15:05:29 <lyxia> mkoenig: cabal new-build --disable-shared --disable-executable-dynamic   maybe cabal overrides those ghc-options
15:06:16 <lyxia> other than that, I'm not sure how to fix that issue
15:08:36 <danilo2> Hi guys! Is there any abstraction like lens plated, but which would execute a typeclass function on EACH field of a constructor, no matter what type this field is ?
15:10:36 <lyxia> danilo2: generics. one-liner and generics-sop have combinators for this.
15:11:53 <danilo2> lyxia: as far as I know generics work in runtime going over the fields. This is a parto f code where I need the highest performance. I understand that generics would not work as fast as jsut custom typeclass with TH over it right ?
15:12:35 <lyxia> Generics can be optimized to run as fast as handwritten code.
15:13:24 <danilo2> lyxia: Oh, didnt know about it. I was asking about it about a year ago here and what I remember is that a general assumption is that generics are always slower
15:13:41 <maerwald> lyxia: is there a good generics tutorial?
15:19:38 <danilo2> lyxia: It seems that what I need is the Generics.OneLiner.gtraverse. Thanks for mentioning these libraries! Btw, how can I know if such thing would be optimized or not? I really didnt hear before generics could be optimized away. Are there any sources about how to optimize generics ?
15:21:07 <lyxia> maerwald: I'm afraid not. The only links I have are a short introduction in the user manual https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generic-programming and this blogpost https://www.stackbuilders.com/tutorials/haskell/generics/ but neither goes in too much depth
15:21:18 * hexagoxel .oO a custom typeclass plus TH instance doesn't seem that easy because you need the dicts for each field type
15:22:08 <mkoenig> lyxia: Doesn't work either. I don't know if cabal overrides --disable-shared, but --ghc-options is passed to ghc: "C:\ProgramData\chocolatey\lib\ghc\tools\ghc-8.0.2\bin\ghc.exe" "--abi-hash" "-fbuilding-cabal-package" "-O" "-outputdir" "dist\build" "-odir" "dist\build" "-hidir" "dist\build" "-stubdir" "dist\build" "-i" "-idist\build" "-isrc" "-idis
15:22:08 <mkoenig> t\build\autogen" "-idist\build\global-autogen" "-Idist\build\autogen" "-Idist\build\global-autogen" "-Idist\build" "-IC:\msys32\mingw32\include" "-optP-include" "-optPdist\build\autogen\cabal_macros.h" "-this-unit-id" "base-orphans-0.7-c8ee1c934ce63f52420142938443b031630276a8" "-hide-all-packages" "-no-user-package-db" "-XHaskell2010" "Data.Orphans
15:22:09 <mkoenig> " "-Wall" "-hide-all-packages" "-j6" "-static"
15:22:11 <danilo2> hexagoxel: its eas, you just pass constraint in a forall bound type
15:22:19 <mkoenig> compiling haskell on windows is PITA
15:22:27 <lyxia> mkoenig: :/ sorry then
15:22:59 <maerwald> lyxia: ah, so it's as bad documented as TH
15:23:13 <mkoenig> lyxia: thanks anyway!
15:23:41 <hexagoxel> danilo2: you mean wrap every field in an existential?
15:25:01 <mkoenig> i have to figure out how to get it running on windows, maybe docker has graphical support now
15:25:02 <hexagoxel> i don't see how gtraverse helps, because all you get is the Data dict.
15:25:18 <danilo2> hexagoxel: no! I mean sometihng like this (writte now, not tested): class MapFields ctx f a where mapFields :: (forall t. ctx t => (t -> t)) -> a -> a
15:27:09 <lyxia> danilo2: The traditional way is to take a look at the simplified core (via -ddump-simpl). Now there is also https://hackage.haskell.org/package/inspection-testing to automate some of it.
15:27:09 <hexagoxel> danilo2: ah, i see. yeah that should work.
15:27:38 <danilo2> hexagoxel: yeah it works, jsut tested it
15:27:52 <danilo2> lyxia: thanks again for very useful links!
15:28:00 <hexagoxel> danilo2: have you also tested gtraverse?
15:28:23 <danilo2> hexagoxel: not yet, im playing with my dog while writing code now, so its a little slower :D
15:28:34 <danilo2> hexagoxel: but the dog is happy, so am I :D
15:28:47 <EvanR> keyboard dog?
15:29:04 <danilo2> no, real dog. A creature with 4 paws and tail :D
15:29:30 * geekosaur was thinking that was remarkably readable for dog on keyboard >.>
15:29:32 <EvanR> a tetrapod, fascinating
15:29:59 <danilo2> geekosaur: hah :D
15:30:13 <hexagoxel> danilo2: heh, alright. i am just curious about potential solutions now :)
15:30:44 <chorhizo> I saw that the haskell exchange is in london, it's pretty pricy.. I'd assume for someone fairly new to haskell it's a waste of time?
15:31:17 <danilo2> hexagoxel, lyxia  just found exaclty such library for TH: https://hackage.haskell.org/package/traverse-with-class  (just fyi)
15:32:22 <hexagoxel> danilo2 (, lyxia): thanks!
16:02:05 <sclv> chorhizo: it might be worth it
16:02:17 <sclv> Check out videos from past ones
16:02:28 <sclv> That’ll help you decide
16:02:55 <sclv> (note you have to register on the site to see them i think, but that’s free)
16:04:47 <chorhizo> sclv, oh I didn't know that, cool
16:16:09 * hackage tweet-hs 1.0.1.38 - Command-line tool for twitter  http://hackage.haskell.org/package/tweet-hs-1.0.1.38 (vmchale)
16:20:40 <DigitalKiwi> if they're on the site then why even go? :D
16:27:23 <EvanR> wait... how is Void an instance of Exception
16:28:17 <jle`> EvanR: toException = absurd
16:28:22 <jle`> EvanR: fromException _ = Nothing
16:28:41 <EvanR> o_O
16:28:47 <jle`> EvanR: conceptually if you think of Exception as an open sum of types, Void is like the identity of that sum
16:29:11 <EvanR> ah tricky tricky
16:29:26 <jle`> so Exception is like Either e (Either f (Either g (Either h ...)))
16:29:34 <jle`> so Void is just the branch that can never happen
16:29:46 <EvanR> 0 + DeadLock + FileNotFound + DivByZero + ...
16:29:50 <hpc> i hope it renders as "operation completed successfully"
16:30:20 <EvanR> no, it renders as this
16:30:27 <EvanR> > show (undefined :: Void)
16:30:29 <lambdabot>  "*Exception: Prelude.undefined
16:30:30 <EvanR> :(
16:30:38 <jle`> although i don't see a situation where you might need this
16:30:46 <jle`> EvanR: well, an exception for Void cannot be caught as Void
16:30:47 <EvanR> right thats what i dont get
16:31:05 <jle`> if you do catch (\(e :: Void) -> ...), it will re-raise all exceptions
16:31:08 <EvanR> what sanity is being served by this
16:31:11 <jle`> catching with Void is essentially a no-op
16:31:37 <jle`> is that catch or handle, i always mix up the order
16:32:10 <jle`> so yeah, try :: IO a -> IO (Either Void a) is essentially `fmap Right`
16:32:23 <jle`> and handle (\(e :: Void) -> ...) is essentially 'id'
16:33:11 <jle`> as far as i know it might just be a "the instance is possible so it's there" situation, but if there was an actual use that motivated it, it would probably have come from needing some no-op or identity
16:33:45 <EvanR> "because we can" lol
16:33:54 <EvanR> worst haskell reasoning ever
16:34:30 <jle`> i mean, for typeclass instances i think it makes sense to write all possible instances because someone somewhere might find a use for it and write an orphan instance
16:34:40 <jle`> and orphan instances are one of the worse sins in haskell
16:35:00 <jle`> but i see the drawback, in that typeclass instances are a part of the publically facing API, and it would normally not make sense to export a useless function as your API
16:35:07 <EvanR> i understand you that catching a Void with catch nothing, and basically not catch
16:35:15 <EvanR> now, how would anyone ever throw a Void ?
16:35:31 <EvanR> s/with/will/
16:35:59 <jle`> right, it's impossible to ever actually throw a Void
16:36:12 <davean> Thats kinda how the other side works
16:36:43 <EvanR> is there any situation where catching is polymorphic enough... uhg i dont know
16:36:50 <chorhizo> EvanR, loving that sed correction
16:37:03 <EvanR> i give up, i dont have to understand
16:37:53 <EvanR> Void is a valid exception type because you cant ever throw one anyway. is it also a valid Num type?
16:38:22 <dstolfa> EvanR: the void is nothing and everything at the same itme
16:38:27 <dstolfa> !!
16:38:50 <EvanR> > cast (undefined :: Void) :: Maybe Int
16:38:51 <dstolfa> you can't escape the void
16:38:52 <lambdabot>  Nothing
16:39:09 * hackage pipes-extras 1.0.14 - Extra utilities for pipes  http://hackage.haskell.org/package/pipes-extras-1.0.14 (GabrielGonzalez)
16:39:12 <geekosaur> someone did a Num instance for () the other day
16:39:30 <geekosaur> Void would be only slightly less useful
16:39:48 <EvanR> we should have an acme package for () and Void instances
16:40:01 <EvanR> acme-pointless-orphans
16:40:23 <dstolfa> EvanR: no, just for a thing that defines Everything as Void and then ReallyNothing as Void
16:40:29 <dstolfa> so you can do thing slike
16:40:36 <dstolfa> > cast (udnefined :: ReallyNothing) :: Maybe Int
16:40:38 <dstolfa> and get Nothing
16:40:39 <lambdabot>  error:
16:40:39 <lambdabot>      Not in scope: type constructor or class ‘ReallyNothing’
16:41:17 <EvanR> if you think about it, type level programming is really all management of nothing
16:41:23 * dstolfa packs his stuff and stops making stupid jokes
16:41:58 <EvanR> in the sense that it takes up zero bytes at runtime
16:42:06 <dstolfa> EvanR: but but, runtime types!
16:42:07 * dstolfa hides
16:42:09 <hpc> i like it
16:42:12 <jle`> EvanR: Void is not a valid Num instance
16:42:16 <EvanR> no?
16:42:20 <jle`> no
16:42:24 <jle`> you can't implement fromInteger
16:42:31 <hpc> i forget who it was, some mathematician once wrote "if i had the time, i would have sent a shorter letter"
16:42:50 <fishythefish> ben franklin i think
16:42:53 <dstolfa> hpc: a void letter?
16:43:03 <jle`> () is a valid Num instance though and I'm half sad it isn't one ;)
16:43:17 <fishythefish> but i've also heard it attributed to churchill and pascal now that i think about it
16:43:21 <EvanR> so that extended defaulting makes everything we do in here hilarious
16:43:27 <jle`> (context, i was the person who added the instance to lambdabot)
16:43:30 <EvanR> [1,2,3]
16:43:30 <hpc> fishythefish: my mind went to newton first, or maybe it was hilbert or something
16:43:32 <EvanR> [(),(),()]
16:43:35 <jle`> EvanR: oh yeah, that was the reason to not do it
16:43:39 <jle`> thanks for reminding me
16:43:48 <hpc> pascal sounds close
16:43:50 <jle`> @let instance Num () where fromInteger _ = ()
16:43:51 <lambdabot>  .L.hs:160:10: warning: [-Wmissing-methods]
16:43:51 <lambdabot>      • No explicit implementation for
16:43:51 <lambdabot>          ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
16:44:12 <jle`> @let instance Num () where _ + _ = (); _ * _ = (); abs = id; signum = id; negate = id; fromInteger _ = ()
16:44:13 <lambdabot>  Defined.
16:44:15 <jle`> > [1,2,3]
16:44:16 <EvanR> "franklin" or "tesla" should be what C was named
16:44:17 <lambdabot>  [(),(),()]
16:44:21 <dstolfa> jle`: you're evil
16:44:25 <jle`> yup that's a good reason for () not having a Num instance
16:44:35 <fishythefish> hpc: okay, looked it up - originally pascal, but paraphrased by a bunch of people after him
16:45:01 <dstolfa> this is almost as evil as a FFI for bash
16:45:24 <hpc> nice
16:46:48 <jle`> Num roughly approximates an algebraic ring, so Num () is essentially the Zero ring
16:46:50 <jle`> https://en.wikipedia.org/wiki/Zero_ring
16:47:05 <dstolfa> jle`: i mean, that's not that bad actually
16:47:12 <EvanR> in which case
16:47:12 <dstolfa> jle`: it just seems insane on the surface
16:47:30 <jle`> yeah the main issue is probably defaulting
16:47:40 <jle`> but the same arguments appply that i mentioned earlier, for not having it
16:47:53 <jle`> instances are a part of the public API and should help guide people on how to use a type
16:47:58 <EvanR> fromInteger i = 1 + 1 + 1 + ... (i times)
16:48:15 <EvanR> where 1 = ?
16:48:20 <jle`> EvanR: for Void you mean?
16:48:23 <EvanR> yeah
16:48:44 <EvanR> if we consider it a ring
16:49:13 <EvanR> but i guess you cant implement 1
16:49:28 <dstolfa> EvanR: yeah i'm not sure how you'd define 1 in the first place here
16:49:44 <EvanR> you thought 1 was the loneliest number
16:50:03 <EvanR> but obv its 0
16:50:39 <dstolfa> EvanR: if 0 is Void and Void is everything, are we nothing?
16:50:41 <dstolfa> okay, time to sleep
16:50:45 <dstolfa> enough of this
16:50:57 <jle`> EvanR: i don't think the empty set is a ring
16:51:17 <EvanR> why the hell not
16:51:22 <EvanR> we have empty category
16:51:31 <jle`> idk i googled empty ring and i didn't get any results
16:51:36 <EvanR> lol
16:51:38 <jle`> i even added quotes
16:51:51 <EvanR> it has to have a 0 and 1 element
16:52:44 <jle`> i guess it's because * has to be monoidal, and the empty set is not a monoid
16:52:53 <jle`> since there has to be 1
16:53:28 <jle`> category axioms only expect an 'id' for every object, so if there are no objects, there is no problem
16:56:03 <EvanR> Num could be split up right... the ring part and the subtraction part is an addon class
16:56:12 <EvanR> er no rings have subtraction
16:56:27 <aarvar> jle`: the categorical equivalent would be a category with a single object and no morphisms anyway, wouldn't it?
16:56:54 <EvanR> you have to have identity morphism
16:57:06 <EvanR> or its a Semigroupoid
16:57:17 <jle`> what did you just call me
17:03:39 * hackage mwc-probability-transition 0.1.0.0 - A Markov stochastic transition operator with logging  http://hackage.haskell.org/package/mwc-probability-transition-0.1.0.0 (ocramz)
17:03:43 <EvanR> haskeline is bugging me, i keep wanting to spell it haskellline
17:04:48 <jle`> yeah i never really liked those types of names, i always get tripped up on that ambiguity
17:05:19 <EvanR> 1 l is the last thing i would have expected
17:05:28 <EvanR> but all 3 choices look wrong
17:06:04 <jle`> i pronounce it in my head as 'haskline'
17:06:15 <jle`> kind of flows with readline better
17:06:25 <EvanR> good idea
17:07:23 <EvanR> does readline have all these nutty features like autocomplete?
17:16:03 <Shires> o/ who looks after lambdabot?
17:16:13 <lyxia> int-e ^
17:17:31 <Shires> ty lyxia
17:17:36 <davean> EvanR: how is autocompletion nutty?
17:17:44 <EvanR> good nutty
17:18:18 <davean> EvanR: But yes, thats kinda the point of readline, libedit, etc
17:18:45 <davean> its to bundle up line editing interfaces so they can be reused - autocompletion is a big part of that
17:19:06 <EvanR> cool
17:19:19 <jle`> editing is weird
17:19:37 <davean> If they didn't have those features you'd just use something like getline
17:20:19 <jle`> editing is weird because it's invisible and expected to the end user, and if you don't meet every single obscure expectation, the entire user experience is ruined
17:20:29 <davean> I will say, readline, libedit, etc all have fairly lacking docs and such, they definately come from the "read the code" generation
17:20:54 <davean> which in a way is nice
17:21:27 <EvanR> bad nutty: No instance for (MonadIO (InputT IO))
17:21:40 <EvanR> arising from a use of liftIO
17:22:03 <jle`> that's weird
17:22:07 <jle`> http://hackage.haskell.org/package/haskeline-0.7.4.2/docs/System-Console-Haskeline.html
17:22:21 <EvanR> yes
17:22:28 <davean> EvanR: actually, if anything, it looks like Haskeline might be feature deficient
17:22:36 <jle`> orphan instance somewhere maybe?
17:23:18 <EvanR> its deriving MonadIO
17:23:53 <EvanR> i imported Control.Monad.IO.Class to get the MonadIO instance of IO
17:23:55 <EvanR> didnt help
17:24:33 <jle`> that's weird, i see it in my ghci
17:24:42 <EvanR> so what
17:24:44 <EvanR> see what*
17:24:50 <jle`> the instance
17:24:54 <jle`> when i :i
17:25:26 <EvanR> ... i do not
17:25:40 <EvanR> after importing System.Console.Haskeline
17:25:52 <jle`> you probably have to import Control.Monad.IO.Class to see it in ghci
17:25:59 <jle`> since it only shows instances for classs in scope i think
17:26:54 <EvanR> did that no...
17:27:22 <EvanR> for InputT the MonadIO instance is not showing
17:27:39 <jle`> hm, what version of haskeline are you using
17:27:49 <EvanR> 0.7.4.2
17:28:12 <EvanR> ghc 7.10 ....
17:28:32 <jle`> hm
17:28:35 <jle`> can you show your output
17:28:36 <jle`> now i am puzzled
17:29:40 <EvanR> i exited ghci and reentered, the error is gone. types check, everything compiles
17:29:43 <EvanR> :S
17:29:45 <jle`> :S
17:31:30 <enterprisey> What term can I search for to understand expressions like `case c of (x -> Just y):xs -> (y, xs)`?
17:31:39 * hackage semirings 0.1.0 - two monoids as one, in holy haskimony  http://hackage.haskell.org/package/semirings-0.1.0 (chessai)
17:31:40 <EvanR> everything works now, it sucks!
17:32:04 <jle`> etrepum: ViewPatterns
17:32:11 <enterprisey> ok thanks
17:32:12 <jle`> etrepum: pattern matching/case statements
17:32:20 <jle`> i guess it depends on what you already know
17:32:23 <jle`> are you familiar with case statements?
17:32:26 <enterprisey> yes
17:32:27 <jle`> with Maybe/ADT's?
17:32:30 <enterprisey> yes
17:32:37 <enterprisey> yeah, ViewPatterns was what I was looking for
17:32:39 <jle`> how about with tuples?
17:32:42 <enterprisey> the top of that file is just extension soup
17:32:52 <jle`> (y, xs) is tuple construction
17:32:59 <geekosaur> view patterns haven't been an extension since haskell2010
17:33:08 <enterprisey> yes, I am familiar with everything else besides the ->
17:33:13 <jle`> ah okay
17:33:22 <jle`> geekosaur: i still always have to enable it for my files
17:33:34 <jle`> granted it's one of my more annoying pragmas to enable
17:33:46 <jle`> the most annoying for me is TupleSections for some reason
17:33:56 <jle`> and it's always like my twentieth pragma in a file
17:33:56 <geekosaur> oh dammit, I think I confused them. pattern guards are standard
17:34:03 <geekosaur> of course one is <- and the oter ->
17:34:06 <jle`> haha
17:34:24 <jle`> yeah that pattern guards are standard and view patterns aren't is a really weird situation
17:34:50 <jle`> hindsight is 20/20
17:41:09 * hackage semirings 0.1.1 - two monoids as one, in holy haskimony  http://hackage.haskell.org/package/semirings-0.1.1 (chessai)
17:55:00 <sophiag> has anyone here used Data.Functor.Nested?
17:57:05 <jle`> i feel like i just read about it recently
17:57:07 <jle`> i wonder where
17:57:24 <sophiag> i should give background why i'm asking
17:59:29 <sophiag> earlier i asked about writing a comonad instance for something like `newtype Foo a = Foo [a]` and obviously the answer is it doesn't make sense because a can be []. but having refactored the relevant code to use `newtype Foo a = NonEmpty a` (and then taken a nice friday nap) i'm realizing it's now uglier
18:01:32 <sophiag> the issue was mostly always how to unwrap and rewrap the newtype in instances, e.g. `(f:ft) + (g:gt) = f+g : ft + gt` where the two (+)s are different. i ended up just writing a helper function and pattern synonym to only unwrap the head so the best looking version so far doesn't require any lifting
18:02:24 <pfurla> erikd : btw, I hang around here too :)
18:03:52 <sophiag> what i was left with were just multidimensional functions that would generate types like Foo [[a]] when i'd prefer Foo (Foo (Foo a)). so while NonEmpty seemed obvious since i'm splitting off heads, at least where i'm putting it in the newtype is a change for the worse and really complicates the comonad instance to do complete what was lacking
18:04:19 <sophiag> hence why i'm wondering whether Data.Functor.Nested might just do the trick
18:05:17 <sophiag> that or possibly using NonEmpty Foo rather than Foo a = Foo (NonEmpty a)
18:06:36 <sophiag> jle`: does that make any sense? here was my original gist from this afternoon (although you should ignore the bad Comonad and ComonadApply instances): https://gist.github.com/Sophia-Gold/4489b21029b5cdd53e106dff50f3aa91
18:11:47 <jle`> hm, Nested doesn't seem like a good tool for one-off convenience functions, it looks like something for managing complicated stacks with many levels
18:11:54 <jle`> but i haven't used it before
18:12:23 <jle`> can you paste your current ugly code?
18:12:25 <jle`> with NonEmpty?
18:14:05 <sophiag> sure. i just haven't pushed it because chances are i'll revert
18:14:49 <erikd> pfurla: ?
18:15:14 <jle`> branches! :)
18:15:22 <pfurla> erikd : I am the posting on the language-javascript
18:15:33 <sophiag> yup, with foresight :p
18:15:39 <erikd> ah right. ok, hi!
18:15:44 <erikd> :)
18:15:47 <sophiag> errr, i'll just stash and use hindsight :)
18:15:54 <erikd> i mostly lurk here
18:16:44 <sophiag> oh and i realized another option would just be writing the instances i care about (Num and Fractional, not Comonad) on a type synonym for NonEmpty rather than this newtype. that would eliminate the unwrapping issue entirely and then i could use the standard Comonad instance (although it doesn't seem `extend` as defined for NonEmpty actually does what i want..)
18:23:40 <sophiag> jle`: pretty version with broken comonad stuff commented out https://github.com/Sophia-Gold/PowerSerious/blob/master/src/PowerSerious.hs and less pretty version using NonEmpty (still no comonad instance): https://github.com/Sophia-Gold/PowerSerious/blob/nested/src/PowerSerious.hs
18:24:33 <sophiag> oh, except i have that bizarre pattern synonym in the one on master
18:24:59 <sophiag> they look mostly the same is the thing. i'm just not addressing the issue of nesting constructors vs. lists
18:25:33 <sophiag> ah, which also explains why i have that crappy Show instance for [a]
18:27:09 * hackage miso 0.20.0.0 - A tasty Haskell front-end framework  http://hackage.haskell.org/package/miso-0.20.0.0 (DavidJohnson)
18:31:39 * hackage turtle 1.5.8 - Shell programming, Haskell-style  http://hackage.haskell.org/package/turtle-1.5.8 (GabrielGonzalez)
18:45:47 <EvanR> so haskeline gives you a good input line thing, what about color output?
18:47:48 <EvanR> which library does that
19:00:10 <sophiag> i realize i'm largely talking to myself now, but if i just want to nest constructors for multidimensional lists with this newtype behavior, i could obviously use pretty much the classic example of a type family. i would sort of prefer avoiding type-level shenanigans for this, but comonads may be the totally wrong way to go even though they seem to "describe" my problem well
19:00:51 <EvanR> multidimensional lists? are you doing something like linear algebra
19:01:32 <sophiag> no. power series and generating functions. the latter can fan out, e.g. pascal's triangle
19:01:39 * hackage marihana 0.2.1.0 - Minimal tool to make your blog in Haskell  http://hackage.haskell.org/package/marihana-0.2.1.0 (suzukeno)
19:02:38 <sophiag> actually there's a very particular combinatorial class that motivated me to refactor this at all. although i've only heard of them referred to as this in one book: "supernecklaces"
19:03:15 <EvanR> dang
19:03:23 <EvanR> supernecklaces
19:03:41 <sophiag> so necklaces are the number of cycles in ordered permutations of a set. you can take that up a level and count cycles of cycles
19:03:41 <shapr> sophiag: what book?
19:04:39 <sophiag> analytic combinatorics. modeling algorithmic complexity using combinatorial classes, generating functions, and complex asymptotics
19:04:51 <shapr> thanks
19:05:06 <EvanR> ordered permutation?
19:05:29 <sophiag> EvanR: subsequences vs. permutations in Data.List
19:05:35 <sophiag> minus the empty one
19:06:21 <sophiag> then just iterate on that (which is not entirely simple if you care about more than just counting) and you get these supernecklaces
19:07:33 <sophiag> i guess i just had this realization that comonads are very intuitive, if less useful, and that occurred while thinking about this. but it seems like they're wholly unnecessary and i should just use a type level Iterate on my newtype
19:07:43 <shapr> blog post?
19:07:55 <sophiag> hmm?
19:08:06 <shapr> sophiag: these musings sound worth of a blog post
19:08:08 <shapr> worthy*
19:08:53 <sophiag> shapr: eh, not really. i am supposed to be writing one on something wholly different though (supposed to per my own orders to myself)
19:09:01 <sophiag> figured i'd get to that today :/
19:10:14 <sophiag> oh, right...i didn't use type level Iterate because i can't just generate nestings :p
19:10:47 <sophiag> *that's* why i thought to use a comonad
19:13:39 * hackage type-unary 0.3.2 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.3.2 (ConalElliott)
19:39:06 <sophiag> ok, i do need to double check i'm obeying the comonad laws but think i'm making headway on this. not sure why more employers don't encourage mid-day naps + rubber ducking to no one on irc :p
19:42:27 <lyxia> note that you can quickcheck comonad laws
19:47:40 <sophiag> lyxia: woah, cool. i should be doing more of that with instances generally. you know there was once a time i actually thought the typechecker didn't allow malformed instances?
19:47:56 <sophiag> anyway, in this case i can already see i'm violating one of them :/
19:49:59 <Gigabitten> Am I right to figure that indentation works basically the same way in Haskell as curly braces work in a C-style language?
19:51:24 <sophiag> Gigabitten: to some extent. a do block can literally be written with curly braces and semicolons instead of line breaks
19:52:46 <Gigabitten> now that I think about it, everyone already indents according to the curly braces more or less, in C-style languages. what's even the point of the braces in those languages except that C did it
19:53:24 <Gigabitten> I mean sure you could do some janky stuff if you wanted but nobody ever does, for readability's sake
19:54:10 <sophiag> white space can be troublesome if you're not used to it. it looks good, but harder to say write a linter for
19:56:35 <lyxia> sophiag: also I'd love to read your blog if you have one (now or one day)
19:57:32 <blankhart> lyxia, your fibs from before were 2x faster than my fibs. you used a strictness annotation, and a function as carrier type in the f-algebra (instead of a tuple). can you explain what made it go, especially the carrier type? http://lpaste.net/4654102028815958016
20:00:05 <EvanR> Gigabitten: at some point there was concern about the ability to write performant parsers
20:00:13 <EvanR> or parsers at all
20:00:49 <EvanR> but also you still run into people who absolutely hate layout syntax
20:00:56 <sophiag> lyxia: i've only ever written one programming-related blog post in my life!
20:01:11 <Gigabitten> Wait, couldn't you just parse based on spaces after non-escaped newline characters?
20:01:35 <lyxia> blankhart: I would think about it in two steps. How do you write a function that's fast (fib_), and how do I turn it into a hylomorphism or whatever other recursion scheme.
20:01:43 <EvanR> yes, you "just" do that
20:02:39 <Gigabitten> hey I'm not claiming to have an intricate knowledge of parsers here. I guess there's just something I'm missing that makes the problem harder than it looks.
20:02:57 <EvanR> not that escaped newline would confuse it
20:03:08 <sophiag> Gigabitten: i haven't found much consensus style-wise on indentation in haskell. so like the emacs mode is less useful for that than languages with tons of delimiters
20:03:20 <lyxia> blankhart: the last thing fib_ does is call itself, so this can be compiled to a simple loop.
20:03:36 <EvanR> theres certainly haskell style guides and reformatters
20:03:50 <sophiag> Gigabitten: it's not a parsing issue. it's a "there are many equally valid choices" issue
20:04:12 <Gigabitten> well does that issue actually cause any issues
20:04:48 <lyxia> blankhart: and the strictness annotation prevents it from building a thunk
20:04:52 <sophiag> not for the language, but i do notice in emacs. that said, i never got into using intero due to nix issues
20:05:17 <blankhart> i see, lyxia, so the choice of carrier type is not intended to produce extra mileage in itself.  it is just a straight translation into the recursion scheme, and most of the oomph comes from avoiding the thunk.  is that right?
20:05:30 <blankhart> oh and tail recursion
20:06:12 <lyxia> blankhart: yeah that's how I see it, though I wish we could have an intuition that didn't require such low-level insight.
20:08:02 <sophiag> ugh, yeah there's a reason NonEmpty defines extend rather than duplicate and requires a recursive definition (talking to myself)
20:08:07 <blankhart> is this getting tail call optimizations into the recursion scheme?  that didn't seem possible where hylo recursion isn't in tail position.
20:09:24 <sophiag> blankhart: technically no tail calls (or *almost* none) in haskell are in tail position because they're wrapped in thunks
20:10:02 <sophiag> err, realized my wording there was bizarre
20:10:18 <EvanR> the recursive call to foldl here is in tail position
20:10:23 <EvanR> @src foldl
20:10:23 <lambdabot> foldl f z []     = z
20:10:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:11:09 <EvanR> where the effect is something you probably dont want, a bunch of thunks before you begin doing anything else
20:12:18 <sophiag> i'm saying technically it's at the end, but as far as "optimization" you can imagine it never really being in tail position once evaluation begins
20:12:35 <EvanR> thats why you have to distinguish tail calls from "TCO"
20:12:44 <sophiag> yes, good point
20:12:54 <sophiag> tco is a shitty term anyway
20:13:08 <sophiag> but that's a different issue
20:13:09 <lyxia> blankhart: yes, go is the continuation k in fib'.
20:13:58 <Cale> sophiag: It's more about the fact that there's no call stack, so "tail call optimisation" is weird.
20:14:07 <EvanR> since you dont have a call stack to optimize it doesnt er ^
20:14:35 <sophiag> i meant just the framing of referring to it as an optimization in any language rather than a necessity
20:14:52 <EvanR> that too
20:14:57 <sophiag> i had the good fortune of hearing guy steele tell an anecdote about him and bill joy trying to communicate this in java standards talks
20:15:01 <Cale> GHC does use a stack, but referring to it as a "call stack" would usually be confusing -- it mostly consists of pattern matches that are waiting to happen.
20:15:12 <blankhart> does the commentary about thunks/no TCO apply if you combine a tail call with a strictness annotation?
20:15:15 <sophiag> they were like "imagine if for loops blew the stack"
20:15:30 <Cale> When you evaluate everything outermost-first, you don't put something on the stack when you apply a function.
20:16:09 <Cale> (well, you might put the function on the stack in order to evaluate it into a lambda first)
20:17:01 <Cale> But when the function then does some pattern matching, you let the pattern match (and its continuation) wait on the stack while the scrutinee is evaluated.
20:17:02 <sophiag> Cale: i was actually wondering about that recently. i had to look at parts of GHC.Exts that manipulate the stack, but can't imagine you'd be able to use those to do much more than throw exceptions
20:18:33 <Cale> Sometimes I would really like GHC to be able to show us the *real* stack, with information about the locations where the pattern matches are occurring.
20:19:06 <EvanR> would be cool
20:20:39 <lyxia> blankhart: I'm also lost about the point they are making here.
20:21:30 <blankhart> is the point that tail recursion has no optimization benefits (even with a strictness annotation), or that it any benefit is more mysterious than in other languages?
20:22:44 <aarvar> Do you even need to think about tail recursion? Can't you just use the substitution model?
20:23:05 <EvanR> yes i haven't noticed tail recursion meaning much in haskell
20:24:32 <aarvar> The problem with languages without TCO is that they don't behave the same as the substitution model
20:24:54 <lyxia> Can it explain the perfomance difference between   fact 0 = 1 ; fact n = n * fact (n-1)    and   fact 0 acc = acc ; fact n acc = fact (n-1) $! (n * acc)
20:25:08 <aarvar> lyxia: yes
20:25:31 <lyxia> aren't the number of steps the same?
20:26:07 <aarvar> not sure, but the size of the expressions aren't
20:26:32 <blankhart> lyxia, fwiw, strictness rather than tail calls may account for much of the speedup in the fibs example.  the hylo with fib' performed roughly the same as fib_, but one was tail recursive and the other wasn't.
20:26:39 <aarvar> the first will build up the whole expression 5 * (4 * (3 * (2 * 1)))
20:26:52 <lyxia> that's only part of the bonus though
20:27:05 <aarvar> lyxia: size of the expression corresponds to memory usage
20:27:34 <lyxia> yes but that doesn't account for the fact that the latter version can hold everything in registers.
20:27:43 <lyxia> constant memory usage is a weaker guarantee
20:30:19 <aarvar> okay, sure, there are things it won't account for
20:30:53 <EvanR> is stuff like $! accounted by at all in substitution model
20:31:03 <EvanR> accounted for*
20:31:04 <aarvar> yes?
20:31:11 <aarvar> changes the order of evaluation
20:31:13 <EvanR> relly
20:31:34 <EvanR> ok thats what i was wondering, if you meant that
20:31:55 <EvanR> assuming seq stuff affects evaluation order
20:33:05 <aarvar> if you didn't want to assume seq you could imagine it to be seq n = case n of 0 -> 0; 1 -> 1; etc
20:33:12 <aarvar> er, sorry
20:33:16 <aarvar> ignore me
20:33:41 <lyxia> blankhart: I'm not sure what you mean here, both are tail recursive.
20:36:58 <blankhart> evaluating the f-algebra fib' requires an invocation of cata or hylo. i thought we said those weren't.
20:37:56 <lyxia> blankhart: go n  calls  alg = fib'  which calls  k = go (n-1)
20:40:24 <aarvar> blankhart: the compiler will presumably optimize cata away
20:40:35 <aarvar> but this is a good example of why not to think about tail recursion
20:43:41 <lyxia> blankhart: they both optimize to the same core, hence they perform the same http://lpaste.net/365069
20:44:42 <lyxia> blankhart: you can see it with "ghc -ddump-simpl -dsuppress-all -ddump-to-file -O"
20:45:29 <blankhart> that is pretty irrefutable but i am still limping along behind you.  go and k have different types; are we partially applying k when we say they are the same continuation?
20:46:49 <lyxia> go (n-1)  has the same type as  k
20:47:53 <blankhart> vice versa?  k is a -> a -> a and go is a -> b?
20:50:35 <lyxia> blankhart: this is confusing because these type variables are not in the same scopes. Monomorphisze a bit  fib' :: Algebra NatF (Integer -> Integer -> Integer),  hylo :: Algebra NatF (Integer -> Integer -> Integer) -> Coalgebra NatF Int -> Int -> Integer -> Integer -> Integer
20:50:45 <lyxia> go :: Int -> Integer -> Integer -> Integer
20:51:33 <blankhart> if i understand the point though it's that alg is in tail position within hylo and that's what matters, since alg makes a tail call to fib, and hylo always ends in the call to alg.
20:54:58 <blankhart> thanks, i understand the monomorphized types and agree.
20:55:04 <lyxia> it also matters that fib calls k, which is go.
20:55:55 <lyxia> which wasn't the case with the first algebra (Algebra NatF (Integer, Integer))
20:56:26 <blankhart> is this what they call "trampolining"? tail calls in different function definitions, but mutually recursive?
21:01:35 <lyxia> Trampolines might be one way to compile such functions but not the fastest here.
21:02:12 <sophiag> ugh, i think i need to just table this project. so many things i do in haskell end up being, "why can't i have coinductive divergent types," but it's not like there's a language *more* likely to provide such a perversity
21:02:52 <blankhart> okay, thanks.  this is subtler than i had appreciated. thank you, lyxia.  i have learned a lot and will study it further.
21:03:03 <EvanR> a divergent type doesnt sound nice
21:03:29 <geekosaur> @where stg
21:03:29 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
21:03:38 <eckyp> Hello #Haskell! I'm trying to setup a continuous delivery pipeline for a Haskell project. I want to make the build fail if the code coverage (using HPC) falls below certain threshold. Has anyone done this before?
21:04:21 <sophiag> well your first problem is probably caching...
21:04:40 <lyxia> blankhart: I think the distinction is whether you return a function, that will be called by the trampoline, or your call the last function yourself.
21:06:37 <blankhart> i see, and your point is that in hylo, although fmap go returns a function (wrapped in a functor) it also calls it itself by invoking alg?
21:07:39 <lyxia> yes and inlining makes the process very streamlined
21:08:23 <blankhart> excellent, i think that is the last bit i was missing.
21:23:04 <sophiag> lyxia: could i pick your brain about comonads? i'm thinking i don't need them hear and my excursion with NonEmpty was a bit bizarre, but before i rule it out i want to test my initial intuition: essentially just that i could use duplicate like a step through type-level iterate. i don't actually mean like `iterate . duplicate` as in the joke above, but essentially some strict version of that to produce a finite number of nested
21:23:05 <sophiag> types. does that make sense?
21:27:43 <matsurago> Hi, can anyone suggest a good editor or an IDE to edit Haskell files? I tried Atom and it fails miserably (incorrect identing on copy/paste, so I spend most of the time correcting ident).
21:27:53 <nisstyre> matsurago: I use gvim
21:28:16 <nisstyre> as long as you have syntax highlighting for Haskell it works great
21:29:12 <matsurago> nisstyre: Thanks, I'll try that one!
21:35:45 <DigitalKiwi> matsurago are you in the correct mode when you paste?
21:36:01 <sophiag> i'm getting some wonky behavior from the typchecker wrt Enum
21:36:55 <matsurago> DigitalKiwi: it's Haskell mode
21:36:56 <sophiag> it keeps inferring a constraint Enum [a], but obviously that throws an error in ghci if i add it explicitly
21:36:57 <DigitalKiwi> matsurago you might want :set paste and then to into insert mode
21:37:20 <DigitalKiwi> I totally read that wrong
21:37:29 <EvanR> sophiag: it must know something you dont...
21:37:33 <DigitalKiwi> nisstyre uses gvim you use atom >.>
21:37:48 <sophiag> EvanR: not ruling out that possibility
21:37:49 <matsurago> DigitalKiwi: right :) Installing gvim right now.
21:38:47 <sophiag> EvanR: i think there may be known inference issues with newtypes though. the [a] it's trying to put a constraint on is the a in [1..n]
21:38:49 <DigitalKiwi> anyway, if you encounter problems pasting in vim you probably need to :set paste before going into insert mode...this applies to anything not just haskell
21:38:55 * DigitalKiwi uses spacemacs it's nice
21:39:03 <sophiag> or enumFromTo 1
21:39:21 <EvanR> the a in [1..n] ?
21:39:45 <EvanR> absent referent
21:39:53 <sophiag> it's inferring the argument n is bound to as a list
21:40:14 <nisstyre> DigitalKiwi: why would you need to go into insert mode to paste?
21:40:30 <EvanR> there must be some reason for that lying around
21:40:34 <sophiag> e.g. foo n = [1..n]
21:40:40 <sophiag> foo :: [a] -> [a]
21:40:56 <EvanR> :t (\n -> [1..n])
21:40:57 <lambdabot> (Enum a, Num a) => a -> [a]
21:41:22 <sophiag> err rather (Enum [a], Num [a]) => [a] -> [a]
21:41:24 <nisstyre> if you're pasting from the clipboard you can do "+p in command mode
21:41:24 <EvanR> so [a] -> [a] must be impossible
21:41:27 <DigitalKiwi> nisstyre I just always do *shrug*
21:41:49 <nisstyre> DigitalKiwi: yeah I use "+p and "+yy/yw
21:41:53 <DigitalKiwi> I usually am using cmd+v
21:41:54 <nisstyre> works great
21:42:11 <DigitalKiwi> which is a different buffer than +p I think?
21:42:25 <sophiag> EvanrR: what do you mean? that it often infers nonsensical type sigs from types that are impossible to construct
21:42:31 <nisstyre> yes it is
21:42:38 <nisstyre> well " is the buffer
21:42:42 <EvanR> it infers the most general type... in this case
21:42:46 <nisstyre> er register I mean
21:42:46 <EvanR> :t (\n -> [1..n])
21:42:47 <lambdabot> (Enum a, Num a) => a -> [a]
21:42:56 <EvanR> theres no way to specialize that to get [a] -> [a]
21:43:01 <DigitalKiwi> and if I go into insert mode first then I know if I am also with paste
21:43:05 <EvanR> with more information
21:43:09 <sophiag> yes, obviously
21:43:14 <nisstyre> DigitalKiwi: fair enough
21:43:26 <EvanR> so i dont see even how the information you arent giving here is causing that type
21:43:44 <nisstyre> DigitalKiwi: if I do *+p and "+p it appears to paste the same thing
21:43:58 <sophiag> oh, you're just saying inference is failing so it goes as far down the lattice as you can and a <= [a] ?
21:44:26 <sophiag> oh ok, so you're as confused by that as i am?
21:44:31 <sophiag> that makes sense
21:44:38 <EvanR> i am saying that what youre saying makes no sense
21:45:04 <sophiag> i'm repeating a nonsensical thing the typechecker is telling me
21:45:06 <EvanR> you could give actual code and the actual error
21:45:17 <piyush-kurur> Does backpack has problems with types with kind signatures
21:45:18 <piyush-kurur> ?
21:46:17 <sophiag> EvanR: i'm not so concered with the error. more testing my intuition that inference was failing really badly. i don't think that constitutes a bug or anything, though
21:46:25 <EvanR> :|
21:46:45 <piyush-kurur> I have a signature file https://github.com/piyush-kurur/raaz/blob/backpackised/indef/Raaz/Primitive/Implementation/Stream.hsig. Please note the BufferAlignment element
21:46:50 <EvanR> failure to infer looks like "error" not a type that is totally wrong
21:46:58 <piyush-kurur> that per say is compiling
21:47:06 <EvanR> i think you have a bug in your intuition
21:47:33 <EvanR> i just showed how your code infers something else
21:47:38 <sophiag> there's that thing where code will compile, but throw a type error in interpreted mode
21:47:52 <piyush-kurur> But when I combine it with https://github.com/piyush-kurur/raaz/blob/backpackised/implementation/Raaz/Hash/Blake2b/CPortable.hs
21:48:04 <sophiag> let me exit ghci and see if it builds
21:48:11 <piyush-kurur> It is given me some errors
21:48:22 <piyush-kurur> saying the BufferALignment type is different in both cases
21:48:30 <EvanR> its not polite to criticize code while its not here
21:48:49 <DigitalKiwi> nisstyre also, if you do a cmd+v and it's a lot of text and you're doing it from INSERT (paste) it pastes a lot faster, and also sometimes if you don't do that it can cut off text iirc
21:50:12 <sophiag> EvanR: okay, so i even cleaned first and built again since i'm confused how that's possible, but it does build. yet the error in ghci is clearly at interpreted time? do we get stronger typechecking in ghci? as in it will compile with incorrect inference if you allow it?
21:50:15 <DigitalKiwi> I usually paste stuff from outside of vim and I don't know how to do it other than cmd+v :(
21:50:22 <nisstyre> DigitalKiwi: I didn't know that, maybe that's because it uses a different method of copying that's faster or more optimized for larger things
21:50:48 <nisstyre> DigitalKiwi: well now you do, "+p (on Linux) and *+p (on Windows)
21:51:00 <EvanR> doesnt sound right
21:51:11 <DigitalKiwi> I'm on macos
21:51:15 <EvanR> again i have nothing to go on, cant see your machine
21:51:18 <nisstyre> I think "+p works on MacOS
21:51:24 <sophiag> i guess first i should ask whether stack uses the same ghci version as the system ghc when i have it configured to use the latter?
21:51:25 <nisstyre> I've used it in the past
21:51:38 <EvanR> stack ghci ?
21:51:38 <sophiag> lol ok
21:51:45 <DigitalKiwi> it
21:51:58 <sophiag> yes, it's possible stack ghci is using a different version than i'm building with
21:52:04 <nisstyre> DigitalKiwi: the nice thing is that it's compatible with other vim commands too
21:52:11 <DigitalKiwi> that's just doing the vim buffer
21:52:15 <EvanR> why would you configure it like that
21:52:16 <nisstyre> e.g. 23"+p pastes it 23 times
21:52:18 <sophiag> i have stack configured to build with the system ghc i get from nix
21:52:33 <sophiag> for unpleasant reasons that's a bit older...
21:52:36 <EvanR> thats like... defeating the purpose of slack
21:52:41 <sophiag> like 8.02 vs. 8.2.x
21:52:52 <DigitalKiwi> cmd+v paste my macos clipboard, the one with p is doing something I did from vim
21:52:54 <sophiag> i'm on nixos...
21:53:13 <nisstyre> DigitalKiwi: yeah but " captures the system clipboard as I understand it
21:53:18 <sophiag> even people i know who do transpiling with nix use stack (or so they tell me)
21:53:21 <sophiag> Cale could answer that
21:53:36 <nisstyre> there might be some indirection there to copy it on demand
21:53:37 <sophiag> s/transpiling/cross-compiling
21:53:41 <nisstyre> and maybe that's why it's a bit slower
21:55:46 <sophiag> EvanR: since you were so persistent: https://gist.github.com/Sophia-Gold/4b2de1cb923fd6059fb54a8711296829
21:56:00 <sophiag> oh let me comment it
21:56:54 <sophiag> https://gist.github.com/Sophia-Gold/4b2de1cb923fd6059fb54a8711296829
21:57:07 <EvanR> yeah, now the inferred type isnt completely nonsense
21:57:11 <sophiag> i just posted the same link. i should go to sleep
21:57:29 <sophiag> the [a] is nonsense
21:57:39 <EvanR> all is well in my world
21:57:41 <sophiag> :t enumFromTo
21:57:42 <lambdabot> Enum a => a -> a -> [a]
21:57:55 <EvanR> you said it was [a] -> [a]
21:58:11 <sophiag> the [a] in that nonsense is the middle a in the type sig above
21:58:24 <EvanR> not [a] -> PowS (PowS a)
21:58:33 <sophiag> how does that make more sense?
21:58:39 <sophiag> it's the argument
21:58:43 <EvanR> n is a list
21:58:59 <sophiag> it cannot possibly be based on...
21:59:02 <EvanR> im not saying it makes more sense, im saying its not clearly nonsense
21:59:05 <sophiag> :t enumFromTo
21:59:06 <lambdabot> Enum a => a -> a -> [a]
21:59:24 <EvanR> you were trying to say doing [1..n] results in [a] -> [a]
21:59:31 <EvanR> which is impossible
21:59:39 <EvanR> it must at least be [a] -> [[a]]
21:59:50 <sophiag>  is that possible?
22:00:00 <EvanR> once we get past that, we can now begin to wonder why n is a list
22:00:34 <EvanR> :t subsequences
22:00:35 <lambdabot> [a] -> [[a]]
22:00:38 <sophiag> do you think that matters? i assume inference just fails sometimes
22:00:49 <EvanR> o_O
22:00:50 <aarvar> :t concat . tail
22:00:51 <lambdabot> [[a]] -> [a]
22:00:56 <sophiag> i think it's my newtype causing it
22:00:57 <aarvar> that's why
22:00:58 <EvanR> by "fail" you mean give wrong answers?
22:01:06 <sophiag> yes
22:01:08 <EvanR> no
22:01:09 <aarvar> and no, inference doesn't just randomly fail
22:01:19 <sophiag> okay
22:01:21 <aarvar> it always works for a certain subset of the language
22:01:26 <EvanR> yes thank goodness
22:01:42 <sophiag> well, i assumed there was something odd going on here
22:01:44 <EvanR> when it cant succeed, like RankNTypes, it doesnt give wrong answers either
22:01:46 <nshepperd> why is that concat in there
22:01:55 <nshepperd> why would you concatenate the subsequenecs
22:01:56 <aarvar> said subset has "principle types", i.e. every expression has a single most general type
22:02:37 <nshepperd> enumFromTo 1 n :: [Int]
22:02:47 <nshepperd> subsequences $ enumFromTo 1 n :: [[Int]]
22:03:04 <EvanR> if i take out the "concat ." i now get supernecklace :: (Enum a, Num a) => a -> PowS (PowS a)
22:03:06 <nshepperd> concat . tail $ subsequences $ enumFromTo 1 n :: [Int}???
22:03:22 <sophiag> nshepperd: actually i don't need the one at the bottom because i just moved the type constructor to the outside rather than fmapping over it. but otherwise i think i need concat because of the newtype
22:03:37 <nshepperd> by why would you concatenate subsequences
22:03:51 <nshepperd> forget about the types, doing that doesn't make sense
22:03:54 <sophiag> i think it's erroneous on the bottom, makes sense when fmapping
22:04:31 <nshepperd> > subsequences [1..3]
22:04:32 <aarvar> and you concatente subsequences twice...what
22:04:33 <lambdabot>  [[],[()]]
22:04:42 <nshepperd> O_O
22:04:50 <EvanR> rofl the () Num instance
22:04:57 <EvanR> jle`:
22:05:16 <nshepperd> >_<
22:05:22 <nshepperd> > subsequences [1..3::Int]
22:05:23 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
22:05:33 <nshepperd> > concat $ subsequences [1..3::Int] -- useless
22:05:35 <lambdabot>  [1,2,1,2,3,1,3,2,3,1,2,3]
22:06:27 <sophiag> so yes that wasn't "failure." the supremum can be the principle type. lambdabot is unityped i guess
22:06:43 <EvanR> what, so you had a bug in your code
22:06:43 <aarvar> sophiag: that was an instance of type defaulting
22:07:09 <sophiag> aarvar: fair. i just never thought of a <= [a]
22:07:27 <aarvar> <= ?
22:07:37 <EvanR> two different a's
22:07:40 <sophiag> i suppose < to be accurate?
22:07:45 <EvanR> a = [b] for some b
22:08:17 <EvanR> PowS (PowS b)
22:08:54 <EvanR> sometimes inference results will have all the vars renamed to start with a
22:09:12 <aarvar> sophiag: anyway, the repl will default to some monomorphic type so that it can print the thing
22:09:25 <aarvar> and it sadly defaulted to ()
22:09:45 <EvanR> that was a side show, somebody undefine it
22:09:54 <EvanR> @undefine
22:09:54 <lambdabot> Undefined.
22:09:59 <sophiag> yes i got that. i'm just saying in the other example a is more general than [b], yes?
22:10:14 <EvanR> list of some type was the most general possible type
22:10:16 <sophiag> hence why i was surprised to see [a] when it should have been a
22:10:27 <sophiag> EvanR: that still confuses me
22:10:28 <EvanR> it couldnt have been a... because you kept concatting
22:10:33 <nshepperd> "forall a. a" is more general than "forall b. [b]"
22:10:36 <aarvar> sophiag: because just a would be a type error with your code
22:10:42 <sophiag> that was the input.
22:10:47 <aarvar> you can't concat something of type a
22:11:07 <sophiag> it's an argument to enumFromTo
22:11:08 <EvanR> :t \x -> concat x
22:11:09 <lambdabot> Foldable t => t [a] -> [a]
22:11:13 <sophiag> :t enumFromTo
22:11:14 <lambdabot> Enum a => a -> a -> [a]
22:11:29 <EvanR> :t \x -> concat (enumFromTo 1 x)
22:11:30 <lambdabot> (Num [a], Enum [a]) => [a] -> [a]
22:11:31 <sophiag> 1 -> n -> list
22:11:42 <nshepperd> you would find your bug quicker if you give f a type sig
22:12:03 <aarvar> or just give n a type sig
22:12:08 <EvanR> dang i was wrong earlier
22:12:12 <nshepperd> or that
22:12:14 <sophiag> :t \x -> concat . tail $ subsequences $ enumFromTo 1 x
22:12:15 <lambdabot> (Num a, Enum a) => a -> [a]
22:12:27 <aarvar> sophiag: also, you can figure out where the mistake is by noticing the inferred Num [a]
22:12:35 <aarvar> that means you're treating a list as a number
22:12:42 <aarvar> i.e. in this case 1 is being inferred to be a list
22:13:02 <aarvar> so writing (1 :: Int) would quickly identify the problem
22:13:06 <sophiag> oy
22:13:10 <EvanR> write a silly program, get a silly type :)
22:13:15 <aarvar> ^
22:14:20 <sophiag> um, actually i just needed to annotate the Int literal this entire time
22:14:30 <EvanR> why not put a top level sig on supernecklace
22:14:36 <sophiag> i've had that function sitting there for 24 hrs confusinig the hell out of me
22:14:51 <EvanR> you dont even have to type it... just uncomment it
22:14:56 <sophiag> EvanR: it's the sig i thought it should be from the beginning!!
22:15:06 <sophiag> i just needed to annotate the literal
22:15:11 <sophiag> :p :p p
22:15:15 <EvanR> or uncomment this line
22:15:21 <EvanR> -- supernecklace :: Int -> PowS (PowS Int)
22:15:26 <aarvar> sophiag: but that's not the type of the thing you wrote. If you have the type signature it will tell you where the type error is
22:15:47 <aarvar> rather than inferring the type of your incorrect code
22:15:53 <sophiag> EvanR: that sig does not check without the literal annotated
22:16:02 <aarvar> it won't check either way
22:16:05 <EvanR> it doesnt check because the codes wrong
22:16:12 <sophiag> there was one erroneous function in the snippet
22:16:24 <nshepperd> both those concats are wrong
22:16:41 <aarvar> sophiag: also, you can write let f s = ... instead of let f = \s -> ...
22:16:44 <sophiag> nshepperd: no, the one on top is *correct*
22:16:47 <nshepperd> trust in the type checker and you will be brought into the light
22:16:52 <EvanR> it does check if you remove the second concat. but ymmv
22:18:04 <EvanR> it can still check and be wrong, like nshepperd is saying
22:18:08 <sophiag> what if i add back in spread? it's got to be something since this is essentially where i started...
22:18:19 <sophiag> no, i'm running it
22:18:27 <sophiag> just want to know where i wasted my time
22:19:06 <sophiag> spread operator works...
22:19:08 <sophiag> wtf
22:19:24 <aarvar> you wasted your time in second-guessing the type inferencer?
22:19:26 <sophiag> EvanR: it's my brain
22:19:42 <nshepperd> well, it does type check with one concat, yes, but it seems unlikely to be right since I still can't imagine what concating subsequences could possibly be good for
22:19:59 <sophiag> aarvar: no that was very recent and when i put it out there EvanR pressured me to share the code
22:20:27 <EvanR> because i felt i was wasting my time first guessing what you were looking at
22:21:04 <aarvar> you need a few more extensions if you want to make type inference produce nonsense :)
22:21:14 <sophiag> i still don't understand how [a] is more general than a
22:21:22 <aarvar> it's not. a is invalid
22:21:52 <EvanR> at least, in the original wrong code case
22:21:59 <aarvar> it infers the most general valid type
22:22:04 <sophiag> [a] can never be more general than a
22:22:12 <sophiag> they can be equal
22:22:20 <sophiag> [a] <= a
22:22:21 <EvanR> they cant be equal either
22:22:38 <fishythefish> [a] ~ a fails the occurs check, but if you want to use two different type variables, then sure
22:22:38 <aarvar> no one said it's more general. And that doesn't even make sense
22:22:40 <EvanR> that would make a = [[[[[[...
22:22:51 <nshepperd> concat :: _ -> a
22:22:54 <nshepperd> :t concat :: _ -> a
22:22:55 <lambdabot> error:
22:22:55 <lambdabot>     • Couldn't match type ‘a2’ with ‘[a]’
22:22:55 <lambdabot>       ‘a2’ is a rigid type variable bound by
22:23:06 <nshepperd> ^^ fails because concat has to produce a list
22:23:51 <nshepperd> :t concat :: _ -> [a]
22:23:53 <lambdabot> error:
22:23:53 <lambdabot>     • Found type wildcard ‘_’ standing for ‘t [a1]’
22:23:53 <lambdabot>       Where: ‘t’ is a rigid type variable bound by
22:24:19 <nshepperd> pff, chill out lambdabot, it's only a wildcard
22:25:29 <sophiag> the sentiment kept being "list of some type was the most general possible type," whereas clearly "some type" is more general. maybe i misinterpreted that line as saying a wasn't "possible?"
22:25:38 <sophiag> and now we're trying to back track to prove that?
22:25:52 <EvanR> are you trying to say type inference should always produce a
22:26:02 <aarvar> :t \xs -> xs ++ [1,2,3]
22:26:03 <lambdabot> Num a => [a] -> [a]
22:26:07 <aarvar> why didn't it just infer forall a. a??
22:26:09 <monochrom> "most general possible type" for what code?
22:26:11 <sophiag> i'm saying it should default to a vs. [a] if it's defaulting
22:26:20 <aarvar> sophiag: it's not defaulting
22:26:25 <aarvar> the repl was defaulting earlier
22:26:26 <monochrom> It's like saying "white is the best colour" without context.
22:26:31 <monochrom> and without purpose.
22:26:37 <sophiag> that quote is from EvanR who said it was defaulting
22:26:39 <aarvar> monochrom: https://gist.github.com/Sophia-Gold/4b2de1cb923fd6059fb54a8711296829
22:26:42 <sophiag> that's the context of this entire discussion
22:26:48 <EvanR> what no
22:27:58 * EvanR retracts sophiag statement for them
22:28:00 <monochrom> What's the type of subsequences?
22:28:04 <nshepperd> :t concat [4]
22:28:06 <lambdabot> Num [a] => [a]
22:28:11 <aarvar> :t subsequences
22:28:11 <lambdabot> [a] -> [[a]]
22:28:25 <monochrom> What's with all those $'s?
22:28:32 <sophiag> EvanR: i scrolled up to check. don't mean to be a jerk, but that's what i was responding to before. anyway glad we figured it out
22:28:48 <monochrom> @type \x -> concat . tail $ subsequences $ x
22:28:48 <EvanR> you were responding to phantom remarks? O_O
22:28:49 <lambdabot> [a] -> [a]
22:28:50 <fishythefish> can we get a quote?
22:28:56 <aarvar> defaulting doesn't cause incorrect types
22:29:02 <sophiag> EvanR: i just yanked that line
22:29:05 <aarvar> and it also produces a warning
22:29:09 <aarvar> and isn't happening here
22:29:09 <EvanR> no defaulting is happening
22:29:10 <sophiag> C-x-y
22:29:21 <sophiag> it's fine now
22:29:23 <sophiag> we're all fine
22:29:39 * hackage one-liner-instances 0.1.2.0 - Generics-based implementations for common typeclasses  http://hackage.haskell.org/package/one-liner-instances-0.1.2.0 (jle)
22:29:56 <fishythefish> from the logs, the only thing EvanR said about defaulting was "<EvanR> so that extended defaulting makes everything we do in here hilarious", and that's from before this discussion
22:30:26 <aarvar> I mentioned defaulting, not EvanR
22:30:42 <monochrom> OK I take it that "we're all fine now" means "I don't have evidence".
22:31:02 <fishythefish> aarvar, your comment was in reference to the Num () instance, though, right?
22:31:07 <aarvar> fishythefish: yes
22:31:59 <fishythefish> in any case, type defaulting is separate from the issue of a vs. [a] being the most general type
22:32:15 <aarvar> neither of those is even a type. We need to be clear about where the forall is
22:32:36 <EvanR> not too many places it could be...
22:32:42 <fishythefish> I assume forall a. a vs forall a. [a]
22:32:45 <fishythefish> following the normal conventions
22:32:58 <sophiag> monochrom: "we're all fine" means i try to value my time higher than fighting with strangers on the internet. if i can talk and learn things that's nice, though
22:33:25 <aarvar> so the people trying to help are wasting your time?
22:33:29 <nshepperd> i think sophiag was mixing up use of 'defaulting' as a technical term vs general usage
22:33:59 <nshepperd> anyway defaulting in the ghc sense isn't relevant here
22:34:04 <EvanR> agree no fighting
22:34:31 <nshepperd> sophiag: can you explain why concat [4] has inferred type 'Num [a] => [a]'?
22:34:37 <sophiag> aarvar: i'm saying i don't need to "present evidence" of things anyone said because i find that a childish ridiculous way to act somewhere like this
22:34:53 <sophiag> nshepperd: that's a good one
22:34:55 <nshepperd> sophiag: if you can understand that, you should be able to understand the original problem
22:35:01 <fishythefish> sophiag: except that you're falsely placing words in their mouths
22:35:39 <enterprisey> anyone have a link to a good paramorphism explanation
22:35:41 <sophiag> fishythefish: i just wrote one direct quote. maybe that was too far? i don't think so judging from him tho
22:36:02 <fishythefish> sophiag: what quote?
22:36:21 <fishythefish> enterprisey: https://stackoverflow.com/questions/13317242/what-are-paramorphisms
22:36:22 <EvanR> it was just adding confusion to a confusing situation
22:36:27 <sophiag> nshepperd: that example really helps
22:36:31 <enterprisey> fishythefish: I am bad thanks
22:36:38 <nshepperd> ah, "list of some type was the most general possible type" was the direct quote
22:37:15 <nshepperd> note it doesn't mention defaulting, which confirms my assumption that the term 'defaulting' was misunderstood or at least not realized that it is a term of art here
22:37:18 <fishythefish> oh, I was objecting to "that quote is from EvanR who said it was defaulting"
22:38:10 <EvanR> that quote is "from EvanR ... "
22:38:16 <EvanR> fixed ;)
22:38:17 <sophiag> what exactly does defaulting mean? i only assumed it meant inferring more general types, i.e. higher up in the lattic
22:38:31 <fishythefish> to be clear, defaulting was only mentioned because someone defined a Num () instance for lambdabot which caused e.g. [1..3] to evaluate as [(), (), ()]
22:38:33 <aarvar> let's just agree that this is all my fault for mentioning defaulting
22:38:56 <EvanR> its jle`'s fault for defining that instance (again!)
22:39:03 <DigitalKiwi> ya'll need to chill it's not like he slandered someone it was just a misunderstanding
22:39:30 <jle`> i feel like i made a big mistake
22:39:34 <fishythefish> sophiag: defaulting is when an ambiguous type is resolved by substituting a (prespecified) type for a type variable
22:40:23 <nshepperd> sophiag: 'ambiguous' meaning that the expression depends on a type variable that isn't part of its type signature
22:41:17 <aarvar> such as in `show 1`
22:41:21 <aarvar> :t 1
22:41:23 <lambdabot> Num p => p
22:41:24 <aarvar> :t show
22:41:25 <lambdabot> Show a => a -> String
22:42:03 <DigitalKiwi> here have fun https://xkcd.com/1942/
22:42:21 <EvanR> er, a and p are not in the type signature by virtue of 1 and show not having type sigs there?
22:42:36 <nshepperd> 'show 1' has type String
22:42:55 <nshepperd> but the string that you get depends on the type of the 1 there
22:45:32 <fishythefish> to demonstrate: in ghci, `show 1` should give you "1", but if you `default (Double)` first, then you'll get "1.0"
22:46:02 <fishythefish> in many cases, you don't notice the effect - in `show []`, which type was chosen for []?
22:46:28 <EvanR> depends on which extensions are on
22:47:53 <fishythefish> oh, and `default ()` will just cause those to type error (with a familiar looking message)
22:47:55 <aarvar> > ("hello" :: forall (x :: Void). String) ++ " world"
22:47:57 <lambdabot>  "hello world"
22:48:04 <aarvar> which value of type Void was chosen? :)
22:48:12 <aarvar> yay stuck type families!
22:48:15 <nshepperd> O_O
22:48:32 <EvanR> which type of kind Void lol
22:48:51 <aarvar> which type level value of type Void
22:49:15 <aarvar> Any of course
22:49:18 <fishythefish> which type level value of type level type Void* - but we normally just say "type" and "kind"
22:49:21 * EvanR waits for jle` to define one and mess you up
22:49:29 <nshepperd> now that's just madness
22:49:32 <aarvar> fishythefish: except now kinds are types
22:49:37 <aarvar> so just call it a type
22:50:03 <aarvar> nshepperd: it's too late
22:50:09 <aarvar> guess we need a new language
22:50:12 <EvanR> TypeInType is mad science
22:50:20 <aarvar> you don't need TypeInType for that, btw
22:50:25 <fishythefish> kinds are types only if you say they are
22:50:44 <EvanR> no, but you need it for elaborate confusing type level jargon, ironically
22:50:45 <monochrom> TypeInType still doesn't make x value.
22:50:49 <nshepperd> even if kinds are types, that doesn't stop me from calling them kinds
22:50:58 <aarvar> monochrom: what should I call it then?
22:51:06 <nshepperd> ceilings can be floors, but if it's above my head it's a ceiling
22:51:07 <aarvar> it's not a type, since it doesn't have type/kind *
22:51:07 <monochrom> x is still a type.
22:51:08 <fishythefish> a type variable
22:51:14 <aarvar> it's a type level thing
22:51:18 <aarvar> that doesn't make it a type
22:51:19 <fishythefish> a type doesn't have to have kind *
22:51:20 <aarvar> [] is not a type
22:51:22 <aarvar> yes it does
22:51:27 <fishythefish> no, it does not
22:51:27 <aarvar> that's like, the definition of a type
22:51:38 <aarvar> then why can't I write x :: []
22:51:38 <fishythefish> you might be thinking of inhabited types, and even then, theres #
22:51:47 <monochrom> "Which type of type Void is x?" is right if TypeInType.
22:51:49 <aarvar> fishythefish: oh, sorry, I meant TYPE rep for some rep
22:52:03 <aarvar> monochrom: no, x can't be a type
22:52:13 <aarvar> a type is something that can go on the right of a ::
22:52:22 <aarvar> that's why x :: t is pronounced "x has type t"
22:52:32 <EvanR> people regularly call Maybe :: * -> * a type
22:52:43 <aarvar> EvanR: and they shouldnt
22:52:46 <geekosaur> and they also call DataKinds promoted types types
22:52:48 <monochrom> A value cannot go right after "forall".
22:52:49 <aarvar> we dont have a good word for it though
22:52:51 <geekosaur> what would you call them
22:53:06 <aarvar> idk, type level values?
22:53:23 <aarvar> monochrom: and I didn't mean to say x is a value. It's a variable
22:53:26 <EvanR> -XValueInValue
22:53:26 <monochrom> And in fact actually a type can go right after "forall".  Therefore "forall x ..." makes x a type.
22:53:27 <geekosaur> you are inventing a different language than everyone else speaks...
22:53:46 <aarvar> geekosaur: I am?
22:53:51 * aarvar googles type theory
22:53:51 <fishythefish> geekosaur: to be fair, the ambiguity predates this conversation
22:54:02 <fishythefish> some people use "type" to refer to ordinary types, those with kind *
22:54:13 <fishythefish> others use "type" to mean anything at the type level
22:54:22 <aarvar> others use it for both :)
22:54:44 <fishythefish> the latter subsumes the former
22:54:50 <monochrom> Tonight must be postmodernism night.
22:54:55 <EvanR> and when values are used at the type level, ...
22:55:02 <aarvar> are "hello" and Int isomorphic types?
22:55:09 <fishythefish> no
22:55:14 <EvanR> like dependent types
22:55:25 <EvanR> were all screwed
22:55:27 <aarvar> EvanR: there is no type level with full dependent types
22:55:47 <monochrom> That is wrong.
22:55:56 <aarvar> How is that wrong?
22:55:59 <monochrom> However, it is true that there is no type level with Python and PHP.
22:56:00 <aarvar> What is "the type level"
22:56:20 <nshepperd> its the thing to the right of your ::
22:56:25 <aarvar> what does it mean for something to be "type level" in MLTT? If it appears in a term of type Type?
22:56:33 <fishythefish> http://adam.chlipala.net/cpdt/html/Universes.html
22:56:36 <EvanR> appears on the right of :
22:56:38 <jophish> In haddock, is there a way to link to a exported name with some custom text? something like [my text]('myExport')
22:56:44 <jle`> hey why isn't there a mapAccumL in Data.Foldable
22:56:48 <aarvar> foo : Int -> Type; foo n = Vect n String
22:56:51 <aarvar> is n type level?
22:57:06 <jle`> aarvar: what language is that?
22:57:08 <fishythefish> jle`: isn't it traversable?
22:57:13 <jle`> fishythefish: oh yeah good point
22:57:19 <aarvar> jle`: idk, idris?
22:57:24 <jle`> woo hoo found it :)
22:57:28 <aarvar> or some made up dependently typed language
22:57:30 <jle`> aarvar: oh sorry, i missed the context
22:57:40 <EvanR> in that case Vect is at the value level
22:57:51 <jle`> in languages like idris and other dependently typed languages, there is no distinctionb etween type level and term/value level
22:57:54 <jle`> they are the same thing
22:58:11 <aarvar> jle`: "that is wrong" - monochrom
22:58:18 <jle`> aw man
22:58:20 <aarvar> sorry, "That is wrong."
22:58:23 <aarvar> don't want to misquote
22:58:31 <EvanR> either way you cant take some value x and do ... : x
22:58:39 <jle`> am wrong
22:58:59 <fishythefish> jle`: er, what? coq has dependent types and has a type hierarchy
22:59:10 <jle`> yes, but that is like the distinction between Int's and Bool's in Haskell
22:59:19 <aarvar> ^
22:59:24 <jle`> they all exist at the same level of discourse and syntax
22:59:40 <fishythefish> oh, are we talking about syntactic separation?
22:59:46 <fishythefish> I thought we were talking semantics
22:59:51 <EvanR> you can use the term language to make types, at the type level
22:59:51 <nshepperd> anyway that's defaulting
22:59:59 <aarvar> we're talking about "type level" whatever that means
23:00:06 <nshepperd> when a term is ambiguous so the compiler takes up postmodernism
23:00:16 <aarvar> I claimed no such thing exists in a full dependently typed language, but "That is wrong."
23:00:26 <fishythefish> aarvar: to be fair, you introduced the terminology
23:00:28 <jle`> at the language level there is no distinction, even though things still have to typecheck
23:00:33 <aarvar> not "depends on the definition of this super vague thing", but "wrong"
23:00:45 <aarvar> fishythefish: in the context of haskell I did, because haskell does have this separation
23:00:56 <jle`> in haskell, types are not first-class values
23:00:57 <aarvar> and hence we need to distinguish between "term level value" and "type level value"
23:00:59 <EvanR> if there was no type level, we would really be screwed
23:01:06 <jle`> in idris, types are first-class values
23:01:23 <aarvar> EvanR: really?
23:01:29 <aarvar> what do you mean by type level then
23:01:51 <DigitalKiwi> https://typelevel.org/
23:01:52 <aarvar> Why can't we just have a single language for everything
23:01:52 <EvanR> nshepperd is right, its about taking place on the RHS of :
23:01:57 <aarvar> why cant types be terms like everything is
23:02:08 <jle`> the difference between "type level" and "term level" in idris is like the difference between "int level" and "bool level"
23:02:10 <aarvar> EvanR: what about foo as I defined above?
23:02:10 <jle`> in haskell
23:02:16 <aarvar> foo n = Vect n a
23:02:22 <aarvar> is n at the type level or the term level?
23:02:23 <EvanR> thats a function
23:02:28 <aarvar> answer: there's no distinction
23:02:30 <EvanR> i would call it value level
23:02:36 <aarvar> er, foo n = Vect n String
23:02:38 <EvanR> then you use it at type level elsewhere
23:02:42 <aarvar> it's a function from Nat -> Type
23:02:53 <EvanR> yeah, its type families done right
23:02:58 <aarvar> so anything that appears in an expression of type Type is "at the typelevel"
23:03:02 <aarvar> okay, strange definition
23:03:09 <aarvar> is True at the boolean level?
23:03:10 <EvanR> what... whatever
23:03:42 <EvanR> dependent types let you use value level machinery at the type level
23:03:49 <aarvar> foo maps a natural number level natural number to a type level type
23:03:56 <EvanR> saying "say goodbye to levels yall" isnt helpful
23:04:05 <aarvar> EvanR: no, they simply don't have a distinction between the two levels
23:04:18 <nshepperd> you're not even listening to EvanR, you're just being smug
23:04:26 <fishythefish> but again, no syntactic distinction, right?
23:04:44 <fishythefish> there's still a semantic distinction, which I think is what EvanR and I are more focused on
23:04:46 <EvanR> you still have to use a type here : _
23:04:56 <EvanR> no getting around it
23:05:02 <aarvar> and you have to use a boolean after (&&)
23:05:06 <EvanR> something i was confused about for a long time but there you have it
23:05:20 <EvanR> && and : are different species of thing
23:05:41 <EvanR> a function vs part of the notation of logic
23:05:47 <aarvar> what if you created a language without :
23:05:55 <aarvar> you can
23:06:01 <EvanR> sure
23:06:12 <aarvar> and it can still be dependently typed
23:06:16 <monochrom> The follow makes 0 a value: You cannot fill in the blank in "___ :: 0"
23:06:28 <aarvar> well, types are values
23:06:33 <EvanR> sure
23:06:49 <EvanR> not the other way around though
23:07:01 <aarvar> right
23:07:07 <EvanR> meaningful distinction to maintain
23:07:11 <aarvar> a type is a value of a universe type
23:07:21 <aarvar> no one is getting rid of this distinction
23:07:24 <crestfallen> hi when I run vars p1 p3
23:07:27 <crestfallen> oops
23:07:36 <aarvar> there's just no need for the term "type level" if it simply means "thing of a universe type"
23:07:59 <fishythefish> so you agree that the terminology is useful, you're just quibbling over choice of vocab?
23:08:01 <EvanR> i see a need still
23:08:13 <aarvar> I don't
23:08:24 <aarvar> fishythefish: no, I don't think "type level" is useful
23:08:47 <nshepperd> you just said the term "type" means "thing of a universe type"
23:08:48 <fishythefish> aarvar: evidently, you think "thing of a universe type" is useful
23:08:53 <EvanR> the stuff that you program that will run during type checking
23:09:00 <fishythefish> your only complaint seems to be that we spell it differently than you do
23:09:00 <aarvar> nshepperd: right, that's what a type is
23:09:03 <DigitalKiwi> nshepperd don't put words in his mouth!
23:09:08 <aarvar> something with a type T where T is a universe
23:09:13 <nshepperd> but there's no need for that term
23:09:16 <nshepperd> okay
23:10:11 <EvanR> another thing that happens at the type level, excuse the term, is instance selection
23:10:24 <aarvar> what does that mean
23:10:25 <EvanR> you cant do that at the value level
23:10:32 <EvanR> in haskell at least
23:10:35 <aarvar> I don't know what that means
23:11:04 <EvanR> you have libs in haskell that do lots of computation via the instance selection mechanism
23:11:09 <EvanR> which is a type level thing
23:11:24 <aarvar> if you mean that instances are resolved statically, obviously
23:11:46 <EvanR> i dont know, do they have to be
23:11:52 <aarvar> (not that every instance is completely known at compile time. They can depend on values that are only available at runtime)
23:12:13 <monochrom> Ah static vs dynamic also supports drawing a line between values and non-value types.
23:12:38 <monochrom> "Type level" exists because that's what "type erasure" erases.
23:12:40 <fishythefish> inb4 "there is no dynamic, there is only unityped!!!1!"
23:12:58 <EvanR> haha
23:13:07 <aarvar> monochrom: so anything that can be erased is "type level"?
23:13:17 <aarvar> what about the argument to a function of type () -> Int
23:13:22 <aarvar> in a total language
23:13:31 <nshepperd> a human is a featherless biped with broad nails
23:13:32 <aarvar> or Proxy# String -> Int
23:13:50 <EvanR> not everything that is erased is type level
23:14:00 <EvanR> just type erased stuff :)
23:14:08 <aarvar> and not everything "type level" need be erased
23:14:17 <aarvar> depending on what we mean by those terms
23:14:20 <EvanR> in dependent haskell, unfortunately...
23:14:28 <EvanR> no erasure for us
23:14:33 <aarvar> huh?
23:14:37 <aarvar> you mean no erasure of equalities?
23:15:21 <aarvar> also worth noting that erasability can't be determined without whole program analysis
23:15:25 <EvanR> there will be runtime running of proofs to make sure they dont bottom
23:15:28 <aarvar> foo x = x + 1
23:15:33 <aarvar> is foo typelevel?
23:15:35 <aarvar> maybe
23:15:43 <aarvar> you have to examine the whole program to see where it's used
23:15:46 <jle`> type erasure
23:15:58 <aarvar> EvanR: too bad that only works for inductive proofs
23:16:00 <EvanR> arguing from the perspective that if its not absolute its not a thing?
23:16:06 <aarvar> what happens if you want an infinite proof?
23:16:12 <aarvar> then you can't evaluate it
23:16:18 <EvanR> then it bottoms out
23:16:26 <aarvar> well, I guess you can actually, nvm
23:16:31 <monochrom> Oh and oh what fun there is the opposite side which does "proof erasure" instead.
23:16:34 <aarvar> since you don't need to eval all of it
23:16:36 <aarvar> I'm being dumb
23:16:36 <crestfallen> hi on this tautology checker  --  http://lpaste.net/365072  --  when I run ' > vars p1 p3 ' "AAABAB" is returned . this is of course before we use remove duplicates (rmdups). But I'm expecting this to return "AAAAB" , so something is amiss
23:17:05 <aarvar> EvanR: irrelevance is a nicer notion than erasure
23:17:22 <EvanR> not according to hott!
23:17:46 <fishythefish> crestfallen: lines 50 - 52 seem to be typo'd
23:17:46 <monochrom> Basically, following Curry-Howard, value = proof, type = proposition.  A mathematician would erase the value-proof and keep the type-proposition.  A computer would erase the type-proposition and keep the value-proof.
23:17:57 <fishythefish> you have vars q ++ vars q on each of those
23:18:08 <crestfallen> sorry rmdups is not included.  ok thanks checking that
23:18:11 <aarvar> monochrom: except not all types are propositions
23:18:11 <monochrom> You have to denounce Curry-Howard in order to erase the line.
23:18:24 <aarvar> depending on how we want to define proposition
23:18:41 <EvanR> why do we have to keep defining stuff
23:18:54 <aarvar> because you keep using words in weird ways
23:19:12 <EvanR> i'm trying to use them in normative ways
23:19:22 <EvanR> weird or not
23:19:32 <crestfallen> fishythefish, indeed, thanks. how did you see that so damned fast..
23:19:40 <monochrom> "I value my time higher than arguing who's the weird one"
23:19:46 * fishythefish wonders if we should instead start with HoTT and build up this conversation rigorously from there
23:20:08 <aarvar> EvanR: and javascript programmers refer to using the same language for the server and client as "isomorphism"
23:20:15 <fishythefish> crestfallen: it's not a big file, and it was fairly clear where to look based on what the issue was
23:20:18 <EvanR> yeah
23:20:25 <EvanR> i cant tell them theyre wrong
23:20:29 <aarvar> so your mathy use of isomorphism is nonnormative
23:20:37 <EvanR> what
23:21:14 <fishythefish> EvanR: if someone anywhere uses a word to mean something different than what you mean, your terminology is not normative, sorry
23:21:28 <aarvar> and in C procedures with side effects are called "functions"
23:21:30 <EvanR> is that true i dont know anymore
23:21:32 <crestfallen> fishythefish, thanks kindly, it may not be long but I'm slogging through this on a revisiting.
23:21:38 <monochrom> Well their json encoder-decoder is the identity function and clearly the identity function is an isomorphism. :)
23:21:59 <fishythefish> monochrom: more vexing to me is that their json encoder/decoder is the clone function
23:22:05 <aarvar> monochrom: lol, how is identity an isomorphism?
23:22:18 <aarvar> and there is no single identity function. It's a family of functions
23:22:22 * aarvar runs
23:22:32 <EvanR> > length [\x -> x]
23:22:34 <aarvar> unless you mean the function which takes a type and returns the identity function at that type
23:22:35 <lambdabot>  1
23:22:48 <fishythefish> aarvar: ah, no, I work in a unityped language, so there's only one identity function; your terminology is nonnormative
23:22:49 <aarvar> EvanR: cheating. It defaulted
23:22:58 <aarvar> fishythefish: that was parody
23:23:05 <fishythefish> aarvar: as was my statement
23:23:13 <aarvar> I noticed
23:23:50 <aarvar> apparently my definition of "type" is nonnormative because it's the mathy definition
23:23:54 <aarvar> but this is haskell, not math
23:25:39 <EvanR> type is not defined, it just appears in the rules of logic in various places. as a placeholder
23:26:23 <EvanR> if you try to define it a rabid weasel eats your face
23:26:35 <DigitalKiwi> fishythefish I'm just going to start using every word wrong to screw with EvanR
23:26:52 <fishythefish> DigitalKiwi: please don't, I'll be a casualty
23:27:04 <aarvar> kill two fish with one stone?
23:27:11 <fishythefish> +1
23:27:21 <DigitalKiwi> an apple a day keeps bill gates at bay
23:28:03 <aarvar> DigitalKiwi: why not linux
23:28:25 <crestfallen> also wondering fishythefish   I added rmdups here http://lpaste.net/365072    that is odd syntax, to have a cons directly in front of filter like that without use of parens...any comment? I mean it looks clean and all.
23:28:45 <monochrom> Gollum would love to kill two fish with one stone.
23:28:56 <fishythefish> crestfallen: it's the same as `x : (filter (/= x) (rmdups xs))`
23:29:09 <fishythefish> function application has higher precedence than (:)
23:29:49 <fishythefish> just like I can write 1 + 2 * 3 and you know it means 1 + (2 * 3)
23:30:12 <EvanR> > succ 1 ^ pred 4 -- and you know this (?)
23:30:15 <lambdabot>  8
23:30:34 <fishythefish> monochrom: I think he did that, actually :P
23:31:07 <crestfallen> yeah that is what I would have expected.  I mean, its wrong to say its the last thing on the 'stack' right?
23:31:25 <crestfallen> the cons* is the last thing
23:31:36 <EvanR> the : is the top thing in the expression tree
23:31:40 <EvanR> theres no stack
23:31:48 <fishythefish> I don't know what your operational model is, so I'm gonna dodge that question
23:32:06 <fishythefish> EvanR's suggestion is sensible - view it as an AST
23:32:10 <monochrom> Thank God the debate over what "stack" means was yesterday.
23:32:33 <EvanR> expressions form a tree, and precedence rules exist so you dont need countless parentheses
23:32:34 <fishythefish> I thought stack is that thing I'm supposed to stop using because cabal-install should be good enough for anyone
23:32:34 <crestfallen> queue
23:32:44 <aarvar> monochrom: "stack" is actually a well defined thing
23:32:46 <monochrom> But we can still debate over which direction to draw a tree --- which way is up...
23:33:00 <aarvar> stack as in the data structure, not the build tool
23:33:02 * aarvar runs
23:33:12 <crestfallen> well how should I think of it if its going to be a tree?
23:33:17 <EvanR> i have heard people refer to stacks when trying to understand expressions and i still dont get it
23:33:48 <fishythefish> aarvar: as long as we're quibbling, "stack" is an abstract data type, not a data structure
23:34:12 <aarvar> fishythefish: yes, my bad
23:34:19 <fishythefish> crestfallen: (:) is your root; its left child is x and its right child is the subtree representing `filter ...`
23:34:20 <EvanR> crestfallen: _ : _  is a tree with two children, two other expressions.  you can think of _ _ as a tree in the same way, but the node has no name or anything
23:34:28 <aarvar> depending on what's meant by "data structure"...
23:34:33 <aarvar> I apologize for using that term
23:34:35 <EvanR> _ _ is syntax for applying a function
23:34:39 <monochrom> Yeah you need to assume a lot.  Like, you have to assume eager evaluation, and then you have to assume you have already converted the expression to RPN.  Now you can use a stack to evaluate the RPN expression.
23:34:40 <EvanR> but its also an expression
23:35:25 <EvanR> monochrom: and then you hear "left to right" and "right to left" and i'm like... but a stack is vertical
23:35:30 <monochrom> which is an XYZ problem but I reckon that people love XYZ problems.
23:35:40 <aarvar> data Expr = Add Expr Expr | Mult Expr Expr | Zero | One | Var Int
23:35:43 <aarvar> omg it's a tree
23:36:00 <crestfallen> that's interesting .. in any case the cons is relegated to the end; after filter is done
23:36:08 <DigitalKiwi> looks more like a shrubbery
23:36:10 <fishythefish> drawing stacks horizontally is nice for analyzing executables
23:36:10 <aarvar> crestfallen: no
23:36:17 <aarvar> (:) is lazy
23:36:49 <fishythefish> > head (1 : undefined)
23:36:51 <lambdabot>  1
23:36:52 <monochrom> Naw.  Drawing stacks horizontally is nice iff your screen is wide rather than tall.  Same goes for drawing anything really.
23:36:54 <EvanR> crestfallen: filter may never happen, if you never look at the rhs of :
23:37:30 <fishythefish> drawing stacks horizontally is nice because then people stop arguing about where the "top" is and your buffer overflows look natural
23:37:41 <crestfallen> EvanR, sorry I don't follow that
23:37:48 <EvanR> the root being : helps me to understand it, because thats what you are starting with
23:37:56 <EvanR> you can look at the left child or right child
23:38:07 <monochrom> If you build a website for illustrating stacks...  You may like the desktop version to draw horizontally, the mobile phone version to draw vertically. :)
23:38:10 <EvanR> > head (1:undefined)
23:38:11 <aarvar> crestfallen: not everything in the tree necessarily gets evaluated
23:38:12 <lambdabot>  1
23:38:19 <EvanR> > tail (undefined:[1])
23:38:21 <lambdabot>  [1]
23:38:44 <EvanR> the other side may not even exist
23:39:13 <aarvar> or may be infinite
23:39:30 <fishythefish> @let myPred = not . myPred
23:39:31 <lambdabot>  Defined.
23:39:39 <fishythefish> > head (0 : filter myPred [1..])
23:39:41 <lambdabot>  0
23:39:48 <fishythefish> > filter myPred [1..]
23:39:56 <lambdabot>  mueval-core: Time limit exceeded
23:39:56 <lambdabot>  mueval: ExitFailure 1
23:39:57 <fishythefish> > myPred 1
23:40:04 <lambdabot>  mueval-core: Time limit exceeded
23:40:04 <lambdabot>  mueval: ExitFailure 1
23:40:43 <fishythefish> crestfallen: note that even though `filter myPred [1..]` doesn't terminate (and in fact, calling `myPred` on a single element also fails to terminate), the first expression was fine
23:41:03 <fishythefish> this is because (:) is lazy - `head` only cares about the thing on its left, so `filter myPred [1..]` was never evaluated
23:42:37 <crestfallen> ok that's interesting. so you won't get an non-exaustive error or what's the term..
23:43:08 <EvanR> a freeze up, in this case
23:43:20 <EvanR> you wont get a freeze up
23:43:48 <fishythefish> crestfallen: non-exhaustive patterns are a different issue
23:44:23 <crestfallen> thanks ALL,  x : filter (/= x) (rmdups xs) is a nice expression in any case.
23:44:24 <fishythefish> @let myFun True = 0
23:44:25 <lambdabot>  Defined.
23:44:27 <fishythefish> > myFun False
23:44:29 <lambdabot>  *Exception: /tmp/mueval4371-0.hs:159:1-14: Non-exhaustive patterns in functi...
23:45:04 <fishythefish> "Non-exhaustive patterns" is telling me that I didn't say what to do if the pattern matches `False`
23:45:18 <fishythefish> @let myHead (x : _) = x
23:45:19 <lambdabot>  Defined.
23:45:21 <fishythefish> > myHead []
23:45:23 <lambdabot>  *Exception: /tmp/mueval4400-0.hs:160:1-18: Non-exhaustive patterns in functi...
23:45:30 <fishythefish> Now it's telling me I didn't say what to do if I match an empty list
23:45:32 <EvanR> crestfallen: right... luckily that works and is readable, so you dont have to do ((x) : ((filter (/= x)) (rmdups x))) :)
23:45:37 <fishythefish> @undefine
23:45:37 <lambdabot> Undefined.
23:46:05 <EvanR> i cant even tell if thats well formed, and i just checked that it is
23:46:25 <EvanR> ignoring the smiley
23:46:38 <fishythefish> ((:) (x) ((filter) ((/=) (x)) ((rmdups) (x))))
23:47:52 <EvanR> (()()(()(()())(()())))
23:47:53 <crestfallen> well its very pretty without the scheme onion layers
23:49:11 <crestfallen> rmdups, there is something very counter-intuitive about that filter expression but its growing on me
23:49:27 <crestfallen> ignore rmdups
23:49:45 <EvanR> filter is counterintuitive
23:50:00 <EvanR> it fails to filter out stuff which matches the condition
23:50:32 <EvanR> it does the exact opposite
23:50:57 <c_wraith> filter is just ambiguous.  Sometimes a filter removes things you don't want, sometimes a filter captures the things you do want.  In Haskell, it's the latter.
23:51:03 <crestfallen> no capiche it works sort of like take doesn't it?
23:51:10 <EvanR> x : keep (/= x) nodups
23:51:30 <fishythefish> @let keep = filter
23:51:32 <lambdabot>  Defined.
23:51:38 <fishythefish> merry christmas
23:51:54 <crestfallen> oh yeah we talked about that months ago. fishythefish et al wanted to see that changed?
23:51:54 <EvanR> > keep (/= 5) [1,2,3,4,5,6,5,4,3,2,1]
23:51:56 <lambdabot>  [1,2,3,4,6,4,3,2,1]
23:52:07 <fishythefish> I what?
23:52:21 <EvanR> intuition validated
23:52:35 <crestfallen> someone suggested to change that to keep, sorry I guessed it might have been you
23:52:57 <fishythefish> nah, must have been someone else
23:53:57 <crestfallen> thanks the takeaway is the bit about the tree and the node. I need to think about that
23:54:52 <EvanR> an expression is either a leaf or an operator applied to one or more sub expressions
23:55:13 <fishythefish> and that operator might be function application
23:55:24 <EvanR> and fun application is invisible
23:55:34 <fishythefish> ($) to the rescue!
23:55:52 <EvanR> i saw it spelled @ in that book
23:56:09 <EvanR> implementation of functional programming languages
23:56:14 <fishythefish> I think ocaml uses @@
23:56:19 <crestfallen> trying to digest that... a leaf or an operator
23:57:32 <crestfallen> so you would always look at an operator such as (:) as a node ?
23:57:34 <EvanR> like... https://rnhmjoj.github.io/category-theory-for-programmers/src/part-3/chapter-6.html
23:57:39 <EvanR> first image
23:57:45 <fishythefish> crestfallen: not always
23:57:49 <fishythefish> it can be used as a (leaf) value
23:58:24 <fishythefish> e.g. in `foldr (:) [] xs`
23:59:07 <EvanR> ((foldr @@ (:)) @@ []) @@ xs -- making apps explicit
23:59:50 <crestfallen> EvanR, I actually found someone willing to teach me category theory from the math side; he doesn't know haskell
