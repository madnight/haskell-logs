00:01:18 <dminuoso> Mmm. Is there a combinator that let's me do `Exception e => e -> IO (Maybe a) -> IO a` ?
00:01:33 <dminuoso> I mean I can trivially write it myself, just wondering whether there's some other way
00:02:58 <EvanR> @pl (\e io -> fmap (maybe (throwIO e) id))
00:02:58 <lambdabot> const . fmap . flip maybe id . throwIO
00:03:17 <EvanR> had enough to drink to think thats not bad
00:03:30 <cocreature> :t \e a -> maybe (throwIO e) pure =<< a
00:03:31 <lambdabot> Exception e => e -> IO (Maybe b) -> IO b
00:04:07 <EvanR> dangit... unused arg
00:04:20 <dminuoso> cocreature: Ah, it didn't occur to me to use `maybe` - yeah that's what I was looking for.
00:04:22 <dminuoso> Thanks :)
00:04:35 <EvanR> @pl (\e io -> fmap (maybe (throwIO e) id) io) -- gonna look bad
00:04:35 <lambdabot> fmap . flip maybe id . throwIO
00:04:40 <jle`> :t maybe (throwIO e) pure
00:04:41 <lambdabot> error:
00:04:42 <lambdabot>     • No instance for (Exception Expr) arising from a use of ‘throwIO’
00:04:42 <lambdabot>     • In the first argument of ‘maybe’, namely ‘(throwIO e)’
00:04:48 <jle`> :t \e -> maybe (throwIO e) pure
00:04:49 <lambdabot> Exception e => e -> Maybe a -> IO a
00:05:05 <jle`> just pre-bind the result
00:05:39 <cocreature> and then you get what I wrote a few lines above :)
00:06:13 <jle`> this is also how i go from maybe to any Alternative :o
00:06:19 <jle`> :t maybe empty pure
00:06:20 <lambdabot> Alternative f => Maybe a -> f a
00:06:31 <jle`> my go-to Maybe a -> MaybeT m a
00:07:15 <vaibhavsagar> I discovered a cool implementation of map the other day: `map' = (runIdentity .) . traverse . (Identity .)`
00:07:38 <vaibhavsagar> swapping out Identity for Const is also interesting
00:07:48 <jle`> isn't that fmapDefault from Data.Traversable?
00:08:08 <vaibhavsagar> oh cool, I didn't know it was defined like that already
00:08:31 <jle`> http://hackage.haskell.org/package/base-4.11.0.0/docs/Data-Traversable.html#v:fmapDefault
00:08:40 <dminuoso> vaibhavsagar: That line of thought brings you to things like lenses by the way. :)
00:08:47 <jle`> a little more pointful in the docs
00:09:01 <vaibhavsagar> I know a little bit about lenses
00:09:10 <jle`> the actual impelemtnation is neat though
00:09:17 <jle`> fmapDefault = coerce traverse
00:09:23 <vaibhavsagar> mind = blown
00:09:29 <dminuoso> vaibhavsagar: One way to think of a lens, is as a Traversable that acts on just some part of your larger structure.
00:09:42 <dminuoso> vaibhavsagar: You then pick `Const` to "get something out", and `Identity` to "set something"
00:09:54 <vaibhavsagar> yes, I have heard this before
00:09:55 <jle`> vaibhavsagar: now try it with Proxy
00:10:05 <vaibhavsagar> wut
00:10:22 <jle`> traverse with Identity is fmap
00:10:27 <jle`> traverse with Const is fold
00:10:33 <jle`> traverse with Proxy is um
00:10:40 <vaibhavsagar> how do you `run` a Proxy?
00:10:41 <jle`> fun times
00:11:15 <jle`> oh sorry, yeah, i'm mixing things up
00:11:22 <jle`> the analogy isn't as fun as i was thinking
00:11:53 <vaibhavsagar> cool that `coerce traverse` is so useful though
00:12:09 <jle`> yeah it's pretty cute
00:12:27 <jle`> it's actually also the implementation for foldmapDefault
00:12:43 <jle`> foldMapDefault = coerce traverse
00:15:06 <vaibhavsagar> hmm, it doesn't seem to work the same in my GHCi
00:15:25 <jle`> oh yeah, you can't actually type it in directly unfortunately
00:15:49 <jle`> ghc needs a type annotation for traverse at least
00:15:56 <jle`> it can't infer what traverse you want to coerce from
00:16:40 <vaibhavsagar> :(
00:16:58 <vaibhavsagar> @let trav :: Traversable t => (a -> b) -> t a -> t b; trav = coerce (traverse :: Traversable t => (a -> Identity b) -> t a -> Identity (t b))
00:17:00 <lambdabot>  .L.hs:168:5: error:
00:17:00 <lambdabot>      • Variable not in scope:
00:17:00 <lambdabot>          coerce
00:17:08 <vaibhavsagar> @import Data.Coerce
00:17:08 <lambdabot> Unknown command, try @list
00:17:16 <cocreature> @let import Data.Coerce
00:17:17 <vaibhavsagar> @module Data.Coerce
00:17:18 <lambdabot>  .L.hs:80:1: error:
00:17:18 <lambdabot>      Data.Coerce: Can't be safely imported!
00:17:18 <lambdabot>      The module itself isn't safe.
00:17:18 <lambdabot> Unknown command, try @list
00:17:26 <vaibhavsagar> but it is safe
00:17:46 <vaibhavsagar> isn't the whole point of Data.Coerce safe coercion?
00:17:55 * vaibhavsagar shakes fist at lambdabot
00:18:08 <cocreature> % let trav :: Traversable t => (a -> b) -> t a -> t b; trav = coerce (traverse :: Traversable t => (a -> Identity b) -> t a -> Identity (t b))
00:18:08 <yahb> cocreature: ; <interactive>:120:61: error:; * Couldn't match representation of type `[b0]' with that of `t b' arising from a use of `coerce'; * In the expression: coerce (traverse :: Traversable t => (a -> Identity b) -> t a -> Identity (t b)); In an equation for `trav': trav = coerce (traverse :: Traversable t => (a -> Identity b) -> t a -> Identity (t b)); * Relevant bindings include trav :: (a
00:18:25 <vaibhavsagar> yes, this is the error I was getting as well
00:18:39 <jle`> % let fmd :: forall t a b. (a -> b) -> t a -> t b; fmd = coerce (traverse @t @Identity @a @b)
00:18:39 <yahb> jle`: ; <interactive>:121:64: error:; * No instance for (Traversable t) arising from a use of `traverse'; Possible fix:; add (Traversable t) to the context of; the type signature for:; fmd :: forall (t :: * -> *) a b. (a -> b) -> t a -> t b; * In the first argument of `coerce', namely `(traverse @t @Identity @a @b)'; In the expression: coerce (traverse @t @Ident
00:18:48 <jle`> % let fmd :: forall t a b. Traversable t => (a -> b) -> t a -> t b; fmd = coerce (traverse @t @Identity @a @b)
00:18:48 <yahb> jle`:
00:18:55 <jle`> % :t fmd
00:18:55 <yahb> jle`: Traversable t => (a -> b) -> t a -> t b
00:19:12 <jle`> you also have to specify which traversable you want to coerce from
00:19:17 <vaibhavsagar> does this require ScopedTypeVariables?
00:19:20 <jle`> since ghc can't infer with Traversable instance you are using 'traverse' for
00:19:33 <jle`> the way i wrote did, but it doesn't necessarily have to
00:20:02 <jle`> oh yeah the way cocreature wrote it would also require ScopedTypeVariables with the forall t a b. too
00:20:07 <frerich> Can anybody access http://hackage.haskell.org/package/containers/docs/Data-Tree.html ? I keep getting 'Error 503 Connection timed out' :-/
00:20:37 <vaibhavsagar> frerich: I'm getting the same thing
00:21:06 <jle`> because the type signature of fmapDefault only tells you the final coerce target, ghc doesn't know anything about the t/f/a/b of the traverse you are coercing
00:21:42 <jle`> %let foldmapd :: forall t a b. Traversable t => (a -> m) -> t a -> m; foldmapd = coerce (traverse @t @(Const m) @a @())
00:22:00 <jle`> % let foldmapd :: forall t a b. Traversable t => (a -> m) -> t a -> m; foldmapd = coerce (traverse @t @(Const m) @a @())
00:22:01 <yahb> jle`: ; <interactive>:124:54: error: Not in scope: type variable `m'; <interactive>:124:67: error: Not in scope: type variable `m'; <interactive>:124:109: error: Not in scope: type variable `m'
00:22:07 <vaibhavsagar> the `forall t a b.` is what I was missing
00:22:08 <jle`> % let foldmapd :: forall t a m. Traversable t => (a -> m) -> t a -> m; foldmapd = coerce (traverse @t @(Const m) @a @())
00:22:09 <yahb> jle`: ; <interactive>:125:89: error:; * Could not deduce (Monoid m) arising from a use of `traverse'; from the context: Traversable t; bound by the type signature for:; foldmapd :: forall (t :: * -> *) a m. Traversable t => (a -> m) -> t a -> m; at <interactive>:125:5-67; Possible fix:; add (Monoid m) to the context of; the type signature for:
00:22:13 <jle`> welp
00:22:22 <jle`> serves me right for not trying it out first
00:22:27 <vaibhavsagar> I think there needs to be a Monoid constraint on that?
00:22:47 <jle`> indeed, but my point has been sufficiently made i think so i won't spam anymore haha
00:22:54 <vaibhavsagar> fair enough
00:23:11 <vaibhavsagar> I also liked the symmetry of the pointfree definition
00:23:24 <jle`> yes, it was rather pretty
00:25:18 <jle`> Identity and Const are the only two interesting functors/applicative that VLH lenses use right?
00:25:23 <vaibhavsagar> funny things happen when you swap the wrapping and unwrapping
00:26:20 <vaibhavsagar> @let unmap = (Identity .) . traverse . (runIdentity .)
00:26:21 <lambdabot>  Defined.
00:26:24 <vaibhavsagar> :t unmap
00:26:26 <lambdabot> (Traversable t, Applicative f) => (a -> Identity (f b)) -> t a -> Identity (f (t b))
00:26:58 <vaibhavsagar> @let unfoldmap = (Const .) . traverse . (getConst .)
00:27:00 <lambdabot>  Defined.
00:27:03 <vaibhavsagar> :t unfoldmap
00:27:05 <lambdabot> forall k1 k2 (f :: * -> *) (t :: * -> *) a b1 (b2 :: k2) (b3 :: k1). (Traversable t, Applicative f) => (a -> Const (f b1) b2) -> t a -> Const (f (t b1)) b3
00:27:10 <vaibhavsagar> :D
00:28:32 <vaibhavsagar> I have no idea what any of this means, particularly unfoldmap
00:32:19 <dminuoso> Recently hackage has been having so much issues.. constantly getting 503. :(
00:32:54 <dminuoso> What other options do I have to view documentation?
00:33:05 <vaibhavsagar> dminuoso: stackage?
00:33:11 <vaibhavsagar> local haddocks
00:33:26 <dminuoso> Ah stackage works, thanks.
00:38:22 <statusbot> Status update: Expect some extended downtime for Hackage, due to administrative snafu. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5acf0988f84e8204e95a4c47
00:40:50 <jle`> thanks statusbot
00:51:37 <DigitalKiwi> probably because it's purple
00:52:38 <dminuoso> Never had problem with purple software before.
00:53:33 <chisui> Isn't onenote purple?
00:53:42 <DigitalKiwi> some people really got upset when it changed to purple
00:55:03 <dminuoso> According to color-blindness the color is called "Blue Diamond".
01:00:11 <DigitalKiwi> if you're color blind then how do you know if you haven't had problems with purple software D:
01:02:21 <frerich> DigitalKiwi: Err, as with anything - you know you haven't had problems since you haven't had problems? :-]
01:03:13 <DigitalKiwi> so a case of "never had problems with software" ?
01:03:17 <DigitalKiwi> well that's obviously a lie!
01:04:25 <frerich> As someone with a strong red weakness, I can tell that the main problem is when your wife tells you to go get the brown shoes and you open the warddrope and face ~20 shoes of equal color (since they are all red or brown or purple). :o)
01:04:32 <jchia> I have a big multi-dimensional array stored in a file. Getting the element at some coordinates involves calculating the file offset and reading the binary value. I can mmap the file and read it by reading the mmaped Ptr. I don't want to read the entire file into memory as its too large, but I want the convenience of doing random-access reads without explicit file IO (with Handle) and overhead of system calls. With the assumption that the file does not change,
01:06:16 <chisui> frerich: Yeah, we have three backpacks in different colors from green to olive to brown. They all look the same. My girlfriend refers to them by size now.
01:12:37 <DigitalKiwi> so christmas colors are just...everyday colors?
01:13:21 <pdxleif> ok who broke hackage?
01:13:28 <merijn> pdxleif: Ben :p
01:13:58 <merijn> pdxleif: There was an email on the -cafe and main mailing list he whoopsied the hackage machine
01:14:00 <DigitalKiwi> aka admin snafu
01:14:14 <DigitalKiwi> this is his new nickname
01:14:30 <merijn> oh, wait, wrong first name, now I'm glad I didn't write a full name :p
01:14:52 <merijn> Wrong brain autocomplete reading emails
01:15:09 <merijn> So this day is gonna start productive... :p
01:15:29 <DigitalKiwi> so who is the real person that is now known as admin snafu
01:16:53 <jle`> snafu is their name, admin is the title
01:18:03 <DigitalKiwi> snafu is their nickname not their real name that would be ridiculous to name your kid snafu
01:18:55 <jle`> i woudln't put it past a determined parent
01:20:33 <DigitalKiwi> hmm, I better never have kids...
01:20:57 <merijn> jle`: And that's why municipality officials can veto names that "would cause lasting harm to the child" here >.>
01:21:48 <DigitalKiwi> talua does the hula from hawaii
01:22:04 <romanix> Does any know what's happening with hackage? "Error 503 Connection refused"
01:22:19 <merijn> romanix: Admin fucked up :p
01:22:22 <DigitalKiwi> https://www.theguardian.com/lifeandstyle/2008/jul/24/familyandrelationships.newzealand
01:22:29 <DigitalKiwi> Admin Snafu
01:22:32 <merijn> romanix: https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
01:22:45 <cocreature> romanix: ffr https://status.haskell.org/
01:22:56 <merijn> Welp...looks like I better figure out how to point cabal-install at a different mirror
01:23:20 <merijn> "up to a day of disruption" <- something tells me someone deleted the wrong VM during the VM cleanup :p
01:23:27 <DigitalKiwi> it's 3 in the morning you can just wait until business hours when it's fixed
01:23:30 <cocreature> merijn: huh? I thought cabal should fall back to other mirrors by default these days
01:23:36 <merijn> cocreature: not sure
01:23:48 <cocreature> at least that’s what gershom claims in that reddit post
01:24:11 <merijn> DigitalKiwi: I'd say the majority here right now is from Europe and thus it *is* business hours
01:24:20 <dminuoso> Is it possible to assert that an instance exists in HSpec in a way to give a nice test failure, rather than failing to compile?
01:24:31 <dysfun> a good enough excuse to write not-haskell though, if anyone was looking for one
01:24:50 <DigitalKiwi> bah europeans can just take a day off
01:25:19 <dysfun> i don't tihnk i've ever had an employer that would give me the day off for a package repo being down
01:25:35 <cocreature> dminuoso: you can probably play some tricks ala https://github.com/CRogers/should-not-typecheck
01:26:08 <dminuoso> cocreature: Ah that looks about right! Thanks. :)
01:27:14 <cocreature> dminuoso: although tbh I wouldn’t bother. if you want to test that something doesn’t typecheck you don’t have the choice but just replacing a compile error by a test failure doesn’t seem to be worth the trouble
01:29:40 <reactormonk> I've got an newtype RIO = RIO (ReaderT a IO) - how would the MonadResource instance look like here?
01:31:46 <cocreature> reactormonk: I don’t think you can make a MonadResource instance for that since there’s also no instance for IO
01:31:59 <dminuoso> cocreature: So if you wanted to ensure that some generic implementation would typecheck, you'd just create some `data F = F ... deriving Generic; instance C F` and that's it?
01:32:08 <cocreature> yep
01:32:29 <cocreature> and probably also add a test that it actually behaves like you expect it to rather than just checking that it compiles
01:55:52 <romanix> Anyone familiar with Persistent/Esqueleto? I'm getting weird errors in 'stack ghci', while normal compilation works just fine: http://lpaste.net/364711
01:56:17 <superlinux> hello.
01:56:31 <romanix> Hi! :)
01:58:21 <superlinux> which serious program do you think someone should write  and this someone has just recently learnt haskell?
01:58:55 <quicksilver> they should some serious program which they genuinely want to be written, but which isn't beyond their abilities? :)
02:00:13 <merijn> superlinux: parsers and concurrent programs (webcomic scrapers, small servers, etc.) are always good I think
02:00:28 <superlinux> actually i am having the problem of the need to make a program. I can get whatever program I want without hassles
02:01:20 <superlinux> and I know in Haskell a small amount
02:01:44 <vaibhavsagar> superlinux: reimplement your favourite program
02:02:52 <merijn> cocreature: Clearly solving one new-build issue just reveals the next >.>
02:03:38 <superlinux> what I like is bizzar things.. something unusual
02:09:18 <frerich> superlinux: I find that anything which uses 'brick' for the UI is fun somehow :-)
02:20:00 <reactormonk> cocreature, would it be possible to put the ResourceT information into the ReaderT?
02:25:23 <merijn> Where did fpcomplete hide the docs of their hackage mirror?
02:26:02 <sophiag> merijn: what do you mean? stackage is up for me
02:26:29 <merijn> Except I'm not asking about stackage?
02:27:09 <merijn> ah, they don't mirror docs...bollocks
02:27:25 <sophiag> ok, sorry not sure what you're referring to
02:30:04 <sophiag> is there a way i can do something like `iterate subsequences` without explicit recursion?
02:31:01 <sophiag> simply iterate doesn't work since f(x) is of a different type than x
02:31:31 <chisui> sophiag: Do you mean something like fix?
02:31:37 <chisui> :t fix
02:31:39 <lambdabot> (a -> a) -> a
02:31:53 <sophiag> facepalm
02:32:41 <[exa]> nothing fixes like fix.
02:40:21 <sophiag> i didn't think i could use fix since the recursion is divergent
02:40:41 <merijn> > fix error
02:40:45 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
02:40:50 <sophiag> ha
02:41:17 <dminuoso> :t fix fix
02:41:18 <merijn> Someone buy me a new machine so rebuilding cabal-install doesn't take so long :(
02:41:19 <lambdabot> error:
02:41:19 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ a -> a
02:41:19 <lambdabot>       Expected type: a -> a
02:41:26 <dminuoso> So you cant fix a fix?
02:41:52 <sophiag> hmm
02:41:59 <sophiag> fix fix is a lot like iterate yeah?
02:42:05 <cocreature> reactormonk: if you’re willing to mess with internals, that should be possible given that ResourceT is basically just ReaderT (IORef ReleaseMap)
02:42:14 <cocreature> reactormonk: but then you’re just reimplementing ResourceT
02:42:16 <reactormonk> cocreature, yeah, currently doing that.
02:42:27 <merijn> reactormonk: Why, though?
02:42:31 <dminuoso> Ah no nevermind. It's clear why `fix fix` cant work :)
02:42:34 <cocreature> merijn: stackage does have docs for packages in stackage
02:42:46 <cocreature> e.g. https://www.stackage.org/package/resourcet
02:43:18 <reactormonk> merijn, Got a RIO stack, don't wanna add more
02:45:11 <chisui> sophiag: what exactly are you trying to do?
02:47:16 <sophiag> chisui: just generalizing counting subsequences of subsequences
02:48:24 <sophiag> fix stil gives me an infinite type for this...
02:49:15 <sophiag> e.g. length $ last $ take x $ iterate subsequences [1..y]
02:49:31 <dminuoso> sophiag: sequences of $ are an antipattern.
02:50:07 <Ariakenom> sequence ($)
02:50:08 <dminuoso> sophiag: length . last . take x . iterate subsequences $ [1..y]
02:50:21 <dminuoso> (Or with parens if you prefer)
02:50:52 <sophiag> dminuoso: so you find that more legible even tho it's semantically garbage?
02:50:54 <dminuoso> sophiag: then, `last . take x` is just (!! x)
02:50:55 <sophiag> lol
02:51:26 <sophiag> i could do `flip (!!) x` but still, non sequitor
02:51:45 <merijn> sophiag: . is superior to $ because with . it's always legal/typechecks when you lift out part of it into a separate binding. This is not true with $
02:51:59 <dminuoso> sophiag: No I mean (!!x) as a section.
02:52:19 <chisui> I don't understand what you are trying to do, doens't subsequences already contain all subsequences of subsequences?
02:52:22 <sophiag> um, composition and application are just different. the former doesn't make infinitely recursive types automagically typecheck...
02:52:33 <chisui> > subsequences [1,2,3]
02:52:35 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
02:52:40 <dminuoso> sophiag: No it was just about form.
02:53:13 <sophiag> dminuoso: that's why i mentioned several times it's besides the point
02:54:00 <trcc> Hi guys, question on mutability vs immutability. Say I have a list xs = [1,2,3,4,5,6], and I want to modify only one element, such that it becomes: [1,2,3,100,5,6]. Both the mutable version and the immutable version would have the same time to find the element, but the mutable version would be much faster to update the single element, whereas the immutable version would have to copy 1,2,3 and 5 and 7. Is this correct? Or is there some mag
02:54:00 <trcc> ic mechanism in the ghc engine?
02:54:35 <merijn> trcc: You only have to copy 1,2, and 3
02:54:46 <merijn> trcc: The [5,6] part of the list is immutable, so why bother copying?
02:55:03 <merijn> trcc: You can just reuse the tail without change
02:55:19 <trcc> ahh
02:55:48 <trcc> but chosing to modify value with 1000 in a list, would then result in copying 1 to 999, index 1 based
02:56:18 <merijn> trcc: yeah, but that's not a particularly common operation, though
02:56:52 <trcc> merijn: Just trying to increase my knowledge :)
02:56:55 <trcc> Thank you
02:57:26 <merijn> trcc: Also, note that you can have mutable datatypes in Haskell just fine if you need them, but then you can only use them from IO/ST/similar abstractions
02:57:50 <trcc> yes I have encountered that. Thanks though!
02:57:52 <Boomerang> If you use a linked list as a stack for example you never have that issue. If you do intend on changing values at random indices, then a linked list is probably not the right data structure :)
02:58:44 <trcc> Boomerang: I am not sure I understand your post
02:58:59 <trcc> what would you use instead
02:59:19 <quicksilver> and there are other data structurs which do better at sharing
02:59:27 <quicksilver> Data.Sequence for example
02:59:40 <Boomerang> Vector from the vector package is pretty good at random access
02:59:48 <trcc> okay thanks
02:59:50 <quicksilver> can change a value at a random index with good efficiency
02:59:55 <trcc> though I do not have a specific use case in mind
02:59:57 <quicksilver> well Vector is actually mutable though
03:00:05 <quicksilver> Sequence is just a smart immutable structure
03:00:31 <trcc> Thanks guys.
03:00:59 <dminuoso> sophiag: Mmm I wonder is it polymorphic recursion that you are looking for?
03:02:26 <sophiag> dminuoso: it's exactly what it looked like... [a] -> [[a]] -> [[[a]]] -> ...
03:02:52 <[exa]> sophiag: it separates 'data' from functions
03:03:03 <[exa]> sophiag: oh sorry my scrollback was like 1000 lines back
03:03:09 <sophiag> [exa]: now sure what "it" is
03:03:34 <sophiag> anyway, i gotta go to sleep
03:06:44 <chisui> sophiag: if you only care about the length of the sublists you could map all elements of the list to ()
03:07:02 <chisui> :t  iterate (map (const ()) . subsequences) . (map (const ()))
03:07:03 <lambdabot> [b] -> [[()]]
03:13:10 <romanix> Anyone familiar with Persistent/Esqueleto? I'm getting weird errors in 'stack ghci', while normal compilation works just fine: http://lpaste.net/364711 I think it's something to do with monomorphism as suggested by dminuoso but changing -XNoMonomorphismRestriction and -XMonomorphismRestriction doesn't help.
03:16:04 <dminuoso> @let data NList a = a :-: (NList [a]) | Nil
03:16:06 <lambdabot>  Defined.
03:16:10 <dminuoso> @let f :: NList a -> NList a; f (x :-: Nil) = x :-: (subsequences x :- Nil)
03:16:11 <lambdabot>  .L.hs:164:37: error:
03:16:12 <lambdabot>      • Couldn't match expected type ‘[a0]’ with actual type ‘a’
03:16:12 <lambdabot>        ‘a’ is a rigid type variable bound by
03:16:18 <dminuoso> Why does this not type check?
03:16:59 <dminuoso> Ohh.. `x` might not be a list..
03:21:49 <ara_> heya, anyone here got experience with SBV?
03:25:42 <dysfun> squirrel bite vulcanism?
03:26:10 <dysfun> selectively bungled voltage?
03:26:21 <ara_> smt-based verification https://www.stackage.org/haddock/lts-11.4/sbv-7.5
03:26:39 <dysfun> :)
03:26:41 <ara_> though both of those sound interesting :P
03:26:48 <dysfun> no idea if they exist :)
03:27:42 <cocreature> ara_: just ask your actual question instead :)
03:28:47 <ara_> In sbv is it possible to define a symbolic sort of symbolic values? Something along the lines of `Foo = Foo SInteger` and then `SFoo = SBV Foo`
03:29:25 <sophiag> so btw...this: supernecklace degree size = length . last . take 3 $ iterate (\s -> enumFromTo 1 . length . tail $ subsequences s) [1..4]
03:29:44 <sophiag> https://en.wikipedia.org/wiki/Necklace_(combinatorics)
03:30:01 <dminuoso> sophiag: https://gist.github.com/dminuoso/c4441626ceee2397f8f11e0829126a7b this works for me :P
03:30:26 <sophiag> ha
03:32:16 <sophiag> the fact that using application when you could use composition because that essentially guarantees correctness with less cognitive overhead is considered an "antipattern" whereas using a data constructor for a function like this is not really speaks to my feelings about the haskell community :p
03:32:43 <sophiag> i'm really not saying that from a trolly place or anything
03:32:43 <dminuoso> sophiag: This is not a data constructor.
03:32:48 <dminuoso> sophiag: This is a polymorphic data type.
03:33:01 <cocreature> ara_: that sounds weird, what would you use that for?
03:33:04 <dminuoso> Since base doesnt come with polymorphically nested lists out of the box..
03:33:13 <sophiag> oh by bad
03:33:17 <dminuoso> sophiag: Or rather its polymorphically recursive.
03:33:45 <dminuoso> sophiag: the fact you can do this at all I think is rather cool. :)
03:33:49 <sophiag> your use of type operators threw me off
03:34:24 <ara_> cocreature: I suspect I'm falling into the trap of 'describing what I think the solution is' rather than 'describing my problem'. Let me briefly try something, as I've had a thought, and then I will describe the _problem_.
03:34:38 <sophiag> dminuoso: i really like idris. idris does all that right. i also like haskell...a language somewhere inside haskell that's not feasible to break everyone's code to get to
03:38:09 <piyush-kurur> I have slowly been moving out of stack and intero's insistence of installing stack is a bit irritating. Do you have some recommendation. Bonus point if it can work with hsig files (backpack)
03:40:04 <cocreature> piyush-kurur: cabal?
03:40:16 <cocreature> or cabal-install if you want to be pedantic
03:41:12 <piyush-kurur> cocreature: yeah I moved to cabal (with new-builds) I would like a intero like interface with it
03:41:22 <cocreature> ah now I understood the question
03:41:26 <piyush-kurur> bascially type completion and all that (for emacs)
03:41:40 <cocreature> https://github.com/jyp/dante probably comes closest
03:41:53 <piyush-kurur> cocreature: thanks will have a look
03:42:37 <eelis_> how long do hackage outages usually last?
03:44:41 <Boomerang> eelis_ What do you need? Docs or source code? Which package? Maybe one of us has that cached somewhere else :)
03:44:57 <eelis_> readline package :)
03:45:23 <cocreature> eelis_: https://www.stackage.org/package/readline
03:46:13 <eelis_> thanks. does that also have the source code?
03:46:37 <cocreature> cabal and stack should both use mirrors afaik so you should be able to continue using these to get the source code
03:47:53 <eelis_> hm, "cabal update" gives me "cabal: Failed to download http://hackage.haskell.org/00-index.tar.gz : HTTP code 503", and http://auto-status.haskell.org/ says hackage is unavailable
03:49:41 <cocreature> are you on an older version of cabal?
03:50:01 <eelis_> 1.24.0.2
03:50:16 <cocreature> either way, you should be able to manually set the repository in ~/.cabal/config to one of the mirrors, e.g. http://hackage.fpcomplete.com
03:50:32 <eelis_> cool, i'll give that a try
03:50:38 <cocreature> I think the automatic mirroring is only included for cabal >= 2.0 but I’m not sure
03:51:47 <ara_> cicreature: Experimentation proved fruitless, so this is an explanation of what I'm trying to do and the result I want, without knowing if it's the right approach http://lpaste.net/9023312116609712128
03:52:25 <ara_> cocreature: Sorry, spelled your name incorrectly!
03:58:15 <cocreature> ara_: huh that code doesn’t even typecheck for me?
03:59:09 <ara_> cocreature: Oops I forgot about extensions in the package.yaml. Let me reduce it further to proper SSCE, sorry about that!
03:59:59 <reactormonk> Anyone happen to have a lifted version of `allocate` from resourcet around?
04:00:02 <cocreature> ara_: it’s not only extensions, there is a missing import and then there are also just type errors
04:00:19 <enoq> is Arrows and Kleisli Arrows the same thing?
04:00:29 <ara_> cocreature: Regardless, let me have a look!
04:03:05 <lyxia> enoq: Kleisli arrows are one kind of Arrows among many
04:07:40 <fendor> is hackage down?
04:07:59 <electrocat> fendor: yep
04:09:09 <electrocat> someone fucked up, you could use http://hackage.fpcomplete.com as mirror though
04:09:56 <enoq> lyxia: thanks
04:12:49 <ZeuPiark> hello
04:14:01 <cocreature> ara_: fwiw I suspect that part of the problem is that you derive instances using DeriveAnyClass. if you take a look at the source of SymWord (this really should be in the haddocks) https://www.stackage.org/haddock/lts-11.4/sbv-7.5/src/Data.SBV.Core.Data.html#SymWord they explicitely mention that you need to define literal, fromCW and mkSymWord if you are not using it as an uninterpreted sort (which seems to
04:14:03 <cocreature> apply in your example)
04:14:56 <ara_> cocreature: I did not catch that, thank you.
04:21:08 <dminuoso> lyxia: In what sense are Arrows more specialized than Profunctors?
04:21:22 <dminuoso> Is it compositionality?
04:22:33 <lyxia> every arrow is a profunctor
04:22:54 <Taneb> dminuoso: all arrows are profunctors but not all profunctors are arrows. Arrows are composable, you can lift functions into arrows directly (the "arr" function), they all have an identity, and there's the "first" and "(***)" functions
04:25:02 <Ferdirand> what's an example of profunctor that is not an arrow ?
04:25:42 <Taneb> Ferdirand: newtype Tagged a b = Tagged b
04:31:11 <Ferdirand> Taneb: okay, what's a non-degenerated example ?
04:37:09 <cocreature> ara_: maybe something like this is what you’re looking for? https://gist.github.com/cocreature/0ffb14153c29e0d169c71bda949b8506
04:39:49 <hc> Hi there, can anyone recommend a good haskell package that checks password strength?
04:40:10 <hc> preferably native haskell :)
04:40:16 <hc> i.e., no ffi
04:40:38 <dysfun> i can't imagine why you'd need ffi for that
04:40:48 <frerich> hc: I imagine such a function would basically use the 'all' function and a couple of custom predicates, like 'has digits' or 'has symbols'?
04:41:12 <hc> frerich: not really... I prefer "more subtle" checks tbh
04:41:27 <hc> such as (a) no palindromes, (b) no repetitions (c) no birthdates ...
04:41:54 <frerich> Ah, I see. And you could check dictionaries for commonly used words and such, yes.
04:42:00 <hc> jup
04:43:35 <frerich> hc: I'm not aware of anything ready-made, but this sounds like something which would be part of programming puzzles :-)
04:44:10 <hc> heh
04:45:10 <dysfun> well it sounds like you want custom checks, so you're not likely to find these in a library
04:45:18 <dysfun> so write your checks and run them all
04:47:37 <adjofun> hc: you basically need a function something like `strength :: Text -> Double`, which maps any string to a number between 0 and 1
04:47:44 <ara_> cocreature: I'm not sure if it is, but it's definitely something I can try and work off. Thank you so much!
04:47:48 <adjofun> also, this is a good idea for a library
04:47:49 <ara_> *work from
04:56:31 <quicksilver> although whatever you do won't be as good as https://github.com/dropbox/zxcvbn
04:56:42 <quicksilver> so I would say, only do this if you are doing it for the fun of the exercise.
04:57:55 <hc> adjofun: jup. maybe i'll write one if no good ones exist :)
05:00:03 <maerwald> quicksilver: why. That's primarily an algorithm afais, so he can implement it in haskell
05:01:04 <Kurvivor> hello! i am taking a beginner haskell course, got to recursive fucntions. I have run into an error i cannot quite understand, please help
05:01:15 <ara_> cocreature: Thank you for your help! Turns out this is very similar to my first attempt. This would work in a pinch, but in an ideal world it would be possible to have the model output a value for each `Foo` rather than each free variable in Foo.
05:01:25 <Kurvivor> i have defined function: mylen [] = 0 \n mylen (x : xs) = 1 + mylen xs]
05:01:59 <Kurvivor> when i run it with nonempty list, i get an error "non-exhaustive patterns in function mylen"
05:02:02 <Kurvivor> why?
05:02:11 <lemmih> > let mylen [] = 0; mylen (x : xs) = 1 + mylen xs in mylen [1,2,3]
05:02:14 <lambdabot>  3
05:02:25 <lemmih> Kurvivor: Did you define that function in GHCi?
05:02:45 <lemmih> Kurvivor: If so, use :{ and :} around multiline definitions.
05:02:52 <Kurvivor> lemmih: define as in? something like mylen :: [Int] -> Int?]
05:03:04 <lemmih> Kurvivor: Did you write the function in GHCi or in a text file?
05:03:09 <Kurvivor> lemmih: in GHCi
05:03:39 <lemmih> Kurvivor: Your second definition overwrite the first, then. I suggest using a text file and loading it in GHCi.
05:03:50 <lemmih> *overwrote
05:03:56 <Kurvivor> lemmih: thanks!
05:04:25 <Kurvivor> i thought that definitions are immutable, and was going to ask "how to get rid of old definitions" next
05:05:11 <quicksilver> technically they are immutable but you can shadow them.
05:05:25 <lemmih> Kurvivor: You're not actually mutating the definition, just shadowing it.
05:05:29 <quicksilver> this can be really confusing because you can have things which still refer to the shadowed one
05:05:38 <quicksilver> because they were compiled before it got shadowed.
05:06:04 <Kurvivor> so, if i bind to the same thing tbetween shadowing it with another definition, i will have a proper mess?..
05:06:06 <rotcev> Kurvivor: as was previously stated, you could also define it in ghci by doing something like :{\n myLen [] = 0\n myLen (x:xs) = 1 + myLen(xs) \n :}
05:06:23 <Maxdamantus> Note that shadowing only applies at a name level; things that refer to the previous variable will still refer to the previous variable. You've just created another variable with the same name.
05:07:21 <Maxdamantus> and you don't achieve anything that you can't achieve by just using different names for the different variables/definitions.
05:08:28 <maerwald> hackage down?
05:08:34 <merijn> maerwald: Yes
05:08:42 <maerwald> it says it's meditating
05:09:36 <zincy> How do I use the or function properly when trying to filter a Text value of a given set of chars, this isn't doing it - T.filter (\c -> (c /= '"' || c /= ' ')) txt
05:10:12 <merijn> zincy: That boolean condition is always true
05:10:27 <lemmih> zincy: You want && instead of
05:10:30 <lemmih> ||
05:10:48 <cocreature> you could use \c -> not (c `elem` ['"',' '])
05:11:04 <zincy> You guys are great thanks
05:11:13 <frerich> Or '`notElem` ['"', ' ']' :-)
05:11:22 <cocreature> I keep forgetting notElem is a thing
05:12:30 <maerwald> I feel like I want to try something else than solarized dark, it's just too little contrast. Anything people would recommend for haskell code?
05:14:26 <zincy> Is there a way to deconstruct the values inside record types on the fly without writing a getter function?
05:15:14 <Boomerang> maerwald: What text editor is this for? I quite like the vim-one vim/neovim plugin as a colour scheme :)
05:15:25 <frerich> zincy: You can write e.g. 'let (Person firstName lastName) = p in firstName'
05:15:39 <zincy> ooh thanks
05:15:53 <cocreature> if you have a record type, you already have getters that have the name of the fields
05:16:23 <zincy> The same would work for a tuple type right?
05:16:52 <maerwald> Boomerang: gvim
05:16:57 <zincy> say data Client = Client ([Char], Int)
05:17:12 <frerich> zincy: Yes (this is called 'pattern matching') but as cocreature mentions, it may well be that your friendly compiler already generated getters for you.
05:17:36 <frerich> zincy: ...if you define e.g. 'data Person = Person { firstName :: String }' you get a function 'firstName :: Person -> String' for free.
05:18:00 <Boomerang> That should probably work then :) It comes with 2 colour scheme, a light and a dark one. It's really easy to switch between the two even I rarely ever use the light one
05:18:02 <rotcev> zincy: this section of LYAH covers this topic: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax
05:18:46 <zincy> Thanks
05:19:43 <Boomerang> maerwald: I think the haskell-vim plugin will give you better than default syntax highlighting, it might be worth checking out as well!
05:20:30 <zincy> Next question, what is the need for types like MVar when writing servers? Am I right in saying this is to allow multithreaded processes to access the same memory locations safely?
05:20:48 <dminuoso> zincy: Right.
05:20:55 <merijn> zincy: Accessing the same memory is always safe because everything is immutable
05:21:07 <merijn> zincy: MVar is fo safely mutating memory in multithreaded processes
05:23:02 <maerwald> Boomerang: I just want a color scheme, not a plugin or syntax highlighting, I already have that
05:23:51 <Boomerang> Fair enough :)
05:24:13 <Sio> maerwald: I've found KDE's Breeze Dark syntax highlighting scheme to be quite nice.
05:25:41 <zincy> Why does the type signature for readMVar return an io action -   readMVar :: MVar a -> IO a
05:25:54 <zincy> Surely it should just return a
05:25:57 <merijn> zincy: Because it mutates things, thus causes side-effects
05:26:04 <cocreature> zincy: no it can’t, you can mutate the variable in an MVar
05:26:44 <zincy> Ok, I am confused about the need to represent side effects as IO actions
05:26:52 <cocreature> @where iotut
05:26:52 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
05:27:04 <zincy> Why cant you just do the side effect and pretend it doesn't exist
05:27:06 <cocreature> I recommend that tutorial as in introduction to IO in Haskell
05:27:21 <zincy> Thats probably a blasphemous question
05:27:28 <zincy> Ok thanks
05:28:00 <lemmih> zincy: Haskell is non-strict. You don't really know in which order your code will be executed.
05:28:03 <dminuoso> zincy: You can. But you dont get access to the kitchen knife until you can handle bread knives.
05:29:56 <zincy> Its interesting that in order to build a proper thing with haskell you need to cover a much broader conceptual territory than say js or python. I guess this is because the concepts build on each other.
05:30:39 <Boomerang> zincy: If you want to get an idea about the order your code gets executed in, sprinkle a few `traceShow` and see in which order they appear on stdout :)
05:30:46 <lemmih> zincy: With a math background, it can often feel the other way around.
05:31:05 <merijn> Even with a non-math background, tbh
05:31:24 <zincy> How can it feel the other way around?
05:32:34 <adjofun> zincy: stay tuned, and you will know =:)
05:32:52 <zincy> :)
05:32:54 <lemmih> zincy: In javascript, [] == 0 and 0 == "0" but [] /= "0". Haskell tends to borrow more traditional mathematical concepts.
05:33:40 <Boomerang> lemmih: I think that example is even more clear when you use "" instead of []
05:33:55 <quicksilver> > [] == ""
05:33:56 <cocreature> @pl v -> fmap (\b -> (f v, b)) (g v)
05:33:56 <lambdabot> (line 1, column 5):
05:33:56 <lambdabot> unexpected '>'
05:33:56 <lambdabot> expecting operator
05:33:57 <aarvar> zincy: you can't have side effects because haskell has no side effects :)
05:33:58 <lambdabot>  True
05:34:05 <cocreature> @pl \v -> fmap (\b -> (f v, b)) (g v)
05:34:05 <lambdabot> ap (fmap . (,) . f) g
05:34:15 <Boomerang> In javascript: "" == 0, 0 == "0", "" != "0"
05:34:23 <dminuoso> quicksilver: Haha. That was actually hilarious considering the context.
05:34:27 <cocreature> I should really know better by now than expect @pl to produce something useful
05:34:27 <zincy> I read many times that haskell does have side effects?
05:34:41 <aarvar> zincy: well it doesn't, unless you use unsafe functions
05:34:45 <dminuoso> zincy: Sure. We just keep side effects in IO.
05:34:46 <merijn> zincy: The reason why you want to limit side-effects to IO is that as a result whenever you have a function that does *not* involve IO you automatically know you don't have to think about global state as it can't be affected (changable) global state
05:34:49 <aarvar> IO is not side effects
05:34:52 <aarvar> dminuoso: nonsense
05:35:06 <cocreature> evaluation of Haskell code doesn’t have side effects, execution of IO actions does have side effects
05:35:10 <Sio> zincy: the point is that you tell the compiler what *does* have side effects, so it can make sure that all gets executed in the right order, then execute whatever else in the most efficient order it can imagine.
05:35:11 <merijn> zincy: Haskell does not have side-effects as the reason that they're side-effects is that they're not visible in the type
05:35:20 <merijn> zincy: In haskell they're just "effects"
05:35:25 <aarvar> um no, it doesn't have side effects because it's RT
05:35:30 <aarvar> referentially transparent
05:35:37 <dminuoso> That's just splitting hairs.
05:35:47 <aarvar> not really
05:36:23 <merijn> dminuoso: Pedantic precision is important to avoid unnecssary confusion
05:36:49 <merijn> Sloppy jargon is fine if you know how things fit together. It's just confusing when you don't yet see the big picture
05:36:51 <zincy> So if I print to the screen in haskell code the side effects occur at a lower level during the program's runtime?
05:36:58 <aarvar> zincy: but you can represent a "function with side effects" as a pure function which returns a value describing some side effects
05:37:16 <dminuoso> merijn: If youd ont yet see the big picture, then the subtle differences may just as easily be confusing.
05:37:27 <aarvar> zincy: so, a haskell program is entirely pure, and returns a value of type IO () (from main), which describes what the executable should do
05:37:27 <merijn> zincy: In Haskell we distinguish two separate things: evaluation (of expressions) which is pure and observable from other code
05:37:56 <merijn> zincy: The other side of things is: execution (of effects) which is performed by the runtime and *not* observable from within the pure language directly
05:38:01 <aarvar> zincy: it's not quite the same, but you can imagine a purely functional program which outputs instructions in assembly or some imperative language
05:38:44 <aarvar> you can build up the instructions without any side effects, yet the end result still describes a side effecting program
05:38:54 <zincy> Ok so the haskell program remains pure when we describe this other impure code as being an effect?
05:39:29 <zincy> So purity is being agnostic about the result of io actions?
05:39:47 <dminuoso> zincy: purity is about referential transparency.
05:39:49 <merijn> zincy: The code isn't impure, because the definition of "impure" is that it effects things in an observable way
05:40:11 <merijn> zincy: So effects which cannot be observed within the language don't affect purity
05:40:16 <Sio> We describe the effect we want inside the Haskell program, then hand that effect description to something that actually gets us that effect.
05:40:27 <merijn> zincy: The short summary of "pure function" is "always gives same result for same input"
05:40:35 <dminuoso> zincy: consider: `let !a = getLine in ...` - you effectively force _evaluation_ of `getLine` which just readily puts an `IO ()` object in there. But that doesn't cause for anything to happen.
05:40:45 <dminuoso> Sorry: *IO String
05:40:59 <Sio> Purity is just about the same function with the same inputs producing the same output. Which it wouldn't necessarily if it could read/write a global variable.
05:41:19 <zincy> Ok so impurity is essentiall outsourced by haskell and therefore the haskell code cannot observe any side effects
05:41:21 <maerwald> Sio: nah, only when we are thinking on evaluation level
05:41:28 <tdammers> you can also think in terms of values - any IO action is, as far as Haskell is concerned, really just another value, and you can apply all sorts of functions to it, but that doesn't change the value itself, nor does it have any side effects
05:41:33 <aarvar> zincy: "purity" means that you can replace any expression with the result of evaluating it without changing the semantics of the program
05:41:44 <tdammers> putStr is a function that takes a string and produces such a value
05:42:11 <tdammers> effects don't occur until the runtime picks up an IO value and executes it
05:42:13 <aarvar> e.g. 1 + 2 is pure (i.e. referentially transparent) because you can replace any instance of `1 + 2` with `3` and you still have the same program
05:42:18 <maerwald> people should really first talk about evaluation vs execution, WHNF and so on, before they pull the "purity" argument
05:42:30 <rotcev> i was once reading about pure functions quite a long time ago, and i liked the following statement, i found it slightly humourous: all _useful_ pure functions return something :-)
05:42:57 <zincy> Yeah the distinction between evaluation and execution is unfamiliar to me.
05:43:09 <zincy> When does evaluation happen?
05:43:09 <tdammers> rotcev: in Haskell, we use a definition for "function" by which all functions axiomatically have no side effects and return exactly one value
05:43:43 <merijn> alexbiehl: I'm starting to suspect the way to push Cabal patches forward is to just merge the PR and wait for someone to yell at you :p
05:43:58 <rotcev> tdammers: i know :), but it was quite funny when i read this a long time ago. i think the examples were given in javascript
05:44:28 <tdammers> rotcev: yes. IMO, the first thing you need to do when explaining Haskell functions to people coming from other languages is to disambiguate the term "function"
05:44:57 <maerwald> zincy: what kind of evaluation
05:45:03 <aarvar> just start with the substitution model
05:45:03 <Ariakenom> rotcev, I find throw useful :(
05:45:25 <zincy> The evaluation other people are talking about
05:46:04 <rotcev> tdammers: i think that is important too
05:46:14 <aarvar> zincy: (5 + 3) * (4 + 2) => 8 * (4 + 2) => 8 * 6 => 48
05:46:17 <rotcev> Ariakenom: hahaha
05:46:22 <aarvar> that's evaluation
05:46:29 <tdammers> zincy: generally, "evaluation" means "to determine the value of an expression", while "execution" means "perform the effects associated with a value"
05:46:39 <zincy> Ok thanks
05:46:47 <maerwald> there are different kinds of evaluation
05:47:10 <zincy> So when we are saying haskell is pure we are talking about the evaluation of the program?
05:47:38 * adjofun searches for acme-missiles as example
05:47:39 <zincy> Because effects are essentially given a type
05:47:51 <aarvar> zincy: what we're saying is that an expression has the same semantics as its evaluation
05:47:59 <aarvar> has nothing to do with types really
05:48:26 <zincy> Ok how does this relate to understanding purity
05:49:38 <maerwald> purity only exists on evaluation level, since evaluation doesn't randomly cause execution of code
05:49:41 <maerwald> it simply doesn't
05:49:52 <maerwald> which isn't true for all languages
05:50:04 <tdammers> Effects aren't necessarily given a type; it's rather such that Haskell-the-language only evaluates expressions, it doesn't execute - execution is the job of the runtime, and we trigger it by designating one of the expressions in our program as Main.main
05:50:24 <zincy> Ah gotcha thanks
05:50:26 <aarvar> zincy: 1 + 2 is pure because you can replace it with 3 without changing the meaning of your program. On the other hand, in a typical impure language, if you have var x = 0, the expression x++ is impure, because you can't replace it with its value, 0, without changing the meaning of the program
05:50:35 <tdammers> the runtime can only execute values that are IO actions, so on the Haskell side of things, we have a special type to capture this, called IO
05:51:00 <zincy> So what runs the runtime?
05:51:04 <tdammers> ?
05:51:05 <maerwald> haha
05:51:07 <Ariakenom> from a different angle. All effects in the pure language Haskell are those of the value called main. No functions used to compute that value have no side effects.
05:51:11 <maerwald> it's god!
05:51:19 <aarvar> Ariakenom: main has no side effects either
05:51:20 <tdammers> the runtime is essentially machine code that gets compiled into your binaries
05:51:37 <maerwald> tdammers: what runs your binaries :P
05:51:43 <zincy> haha
05:51:51 <Ariakenom> aarvar, the effects of running a Haskell program are those of the value main
05:52:13 <aarvar> they're the effects described by the returned IO value
05:52:20 <tdammers> maerwald: the OS loads them into RAM, and sets up CPU registers in such a way that the CPU will run it
05:52:32 <maerwald> tdammers: we can play this game for a long time, you know :P
05:52:36 <tdammers> maerwald: yes
05:53:25 <Ariakenom> aarvar, I dont even know how to parse that message
05:53:34 <tdammers> maerwald: my uncle was a software engineer for a German electronics company, he studied CS back when it was barely a discipline; part of his curriculum involved manually manufacturing ferrite-core memory arrays
05:53:41 <aarvar> Ariakenom: k
05:53:50 <tdammers> maerwald: I'm prepared to push at least that far
05:54:05 <aarvar> tdammers: are you saying it's a discipline now?
05:54:09 <rotcev> is it fair to say that the effect is the result of computing the IO function, but once you have that result, things become 'pure' again, for example when evaluating the 'effect'
05:54:11 <aarvar> doesn't seem like it to me
05:54:28 <maerwald> zincy: so... after you know what evaluation and execution is... what do you think the following function would do: doSomething :: IO a -> a
05:54:48 <aarvar> rotcev: I don't know what that means, but probably not :)
05:55:00 <mniip> tdammers, maerwald ooh ooh I know
05:55:07 <aarvar> maerwald: loop forever, obviously
05:55:10 <aarvar> only thing it can do
05:55:25 <tdammers> aarvar: no
05:55:32 <aarvar> tdammers: no what?
05:55:34 <mniip> the cpu boots and queries instructions from 0xFFFFFFF0, which are hardwired on the motherboard to the BIOS ROM chip
05:55:35 <maerwald> don't spoil!
05:55:42 * adjofun looks at accursedUnutterablePerformIO
05:55:43 <tdammers> aarvar: loop forever
05:55:43 <aarvar> maerwald: oops
05:55:49 <mniip> which sets the CPU into non-evict mode, since DDR controllers are not yet configures
05:55:50 <aarvar> tdammers: what else would it do?
05:55:53 <tdammers> aarvar: it can also bottom out immediately
05:55:55 <zincy> Look like identity that returns input
05:56:00 <aarvar> tdammers: right, with error. same thing
05:56:02 <zincy> My best guess
05:56:44 <tdammers> zincy: suppose I have a magical type Foo: data Foo a = ???
05:57:01 <tdammers> you don't know the ??? part, and you have no functions that operate on it
05:57:12 <tdammers> now you are tasked with writing a function :: Foo a -> a
05:57:30 <tdammers> but start simpler: write a function :: Foo Int -> Int
05:57:52 <tdammers> there are many ways to write it, but they all have one thing in common:
05:57:59 <tdammers> they cannot use the Foo Int value, at all
05:58:02 <zincy> They can only operate on ints?
05:58:04 <Sio> to get the resultant value of the IO effect, you have to execute it. Since doSomething doesn't return something wrapped in IO, it can't (legally) do that.
05:58:11 * aarvar suspects this isnt helping
05:58:12 <zincy> Really?
05:58:20 <tdammers> how would they use it?
05:58:39 <tdammers> you cannot deconstruct the Foo value, because you don't know its constructors, so you can't pattern-match on them
05:58:40 <zincy> Can add a constant to the first int arg
05:58:49 <tdammers> there is no first int arg
05:58:49 <maerwald> zincy: my point was more that if you want a reasonable function like 'doSomething :: IO a -> a' to exist you have to break the boundaries between evaluation and execution
05:58:52 <zincy> oh
05:58:52 <merijn> Anyway, I think there's like 8 concurrent explanations of various degrees of formality and correctness going..., I'd recommend grabbing an intro book
05:58:58 <tdammers> the first arg is a Foo Int, not an Int
05:58:59 <zincy> Thought you meant int -> int
05:59:05 <zincy> not Foo int -> int
05:59:09 <tdammers> Foo Int -> Int
05:59:13 * frerich wonders what question people are trying to answer here.
05:59:29 <zincy> Ah
05:59:45 <Psybur> @let data Foo f = F f
05:59:47 <aarvar> frerich: zincy wanted to know what purity is
05:59:47 <lambdabot>  Defined.
05:59:52 <adjofun> frerich: how to change radiowaves with bare hands =:)
05:59:53 <Sio> frerich: "what is purity?" and "what is IO?" at the same time.
05:59:55 <aarvar> and now we're off on some unrelated tangent
06:00:06 <tdammers> so you have a Foo Int value, but the only things you can possibly do with it ever is a) ignore it, b) pass it to something else, c) return it unchanged
06:00:11 <zincy> So without knowing the name of the constructor we cant lift operations on the Int
06:00:26 <tdammers> the definition of the constructor
06:00:38 <aarvar> plus you can't answer such a question without also having to try and correct other potentially misleading answers
06:00:44 <aarvar> so the whole thing is hopeless
06:01:01 <tdammers> if we had the definition of the constructor, *and* that constructor were such that pattern-matching could actually pull the Int out, then we could write that function
06:01:21 <aarvar> tdammers: and that's what purity is!
06:01:25 <aarvar> oh wait, no it isn't
06:01:27 <tdammers> aarvar: no.
06:01:30 <zincy> haha
06:01:41 <maerwald> tdammers: we could write a pattern synonym on IO that does unsafePerformIO xD
06:01:47 <tdammers> maerwald: shush
06:01:50 <maerwald> xD
06:01:52 <aarvar> zincy: have you ever heard of traverse? it's a really cool function
06:01:52 <dminuoso> mniip: what is non-evict mode?
06:01:56 <aarvar> :t traverse
06:01:57 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
06:01:59 <aarvar> this is totally on topic btw
06:02:13 <aarvar> oh also, check out lenses
06:02:27 <zincy> Does it literally let me traverse to the realm of purity?
06:02:35 <aarvar> once you understand lenses and traverse and parametricity, then someone might explain purity if you're lucky
06:02:43 <aarvar> but probably not
06:02:51 <zincy> Still also need to get to the bottom of the runtime rabbit hole
06:02:54 <rotaerk> isn't purity just a trait of functions, particularly that they don't do anything except evaluate to a value?
06:02:57 <zincy> quantum mechanics first
06:03:08 <mniip> dminuoso, well when the mobo has just booted, the DDR controllers aren't configured so you cannot access the on-board RAM
06:03:10 <tdammers> zincy: so anyway, we can't do c), because our return type isn't Foo Int, and we can't do b), because we have nothing available that takes a Foo Int
06:03:29 <tdammers> so all we can do is ignore the Foo Int value altogether and just return an Int we make up
06:03:32 <rotaerk> (and that value is always the same for a given input)
06:03:37 <mniip> non-evict is an undocumented mode in intel, which makes the CPU cache ignore evictions, and thus you are allowed to use the cache as if it were memory
06:03:44 <aarvar> rotaerk: purity = referential transparency, which is a property of expressions
06:03:53 <tdammers> so now consider Foo a -> a
06:04:09 <aarvar> tdammers: what is `a`?
06:04:13 <rotaerk> ah, so function purity is just a special case
06:04:18 <aarvar> you better explain universal quantification now
06:04:22 <tdammers> haha, yes
06:04:24 <tdammers> about to
06:04:28 <Psybur> :t let f (F x) = x in f (F 1)
06:04:29 <zincy> tdammers - what would an example of such a function be?
06:04:29 <lambdabot> Num f => f
06:04:33 <aarvar> tdammers: what if, we went back to the original question
06:04:40 <aarvar> no, that would be silly
06:04:44 <tdammers> aarvar: we might, but this is fun too
06:05:19 <rotaerk> https://wiki.haskell.org/Referential_transparency
06:05:24 <aarvar> tdammers: also, what if I unsafeCoerce the Foo, and it happens to work
06:05:30 <Psybur> How do I "unlet" on lambdabot? :D
06:05:44 <zincy> We can answer all the questions at once dont worry!
06:05:44 <aarvar> tdammers: also, the function could force the Foo with seq
06:05:53 <aarvar> better explain all that stuff too
06:06:12 <tdammers> aarvar: wanna take over?
06:06:17 <aarvar> tdammers: not really
06:06:29 <zincy> haha
06:06:37 <aarvar> you're having too much fun
06:06:42 <zincy> ok tdammers continue and then well go back to purity
06:06:46 <tdammers> right
06:07:10 <tdammers> so with Foo a -> a, you need to find an implementation that will work with *any* concrete type that the consumer picks for `a`
06:07:52 <zincy> ah right
06:08:08 <tdammers> the same implementation must work out for a ~ Int, a ~ String, a ~ (), a ~ Maybe (Either FileHandle (SuspensionBridge -> HashMap Text NetworkConnection)), etc.
06:08:43 <aarvar> zincy: so, once there was a man named John Reynolds...
06:08:57 <tdammers> so you only have one choice left: pick the only "value" that all types share
06:09:03 <zincy> So pattern matching by definition is matching patterns on the data constructor. Therefore without knowing the name of the data constructor there is no way to pattern match?
06:09:09 <tdammers> which happens to be "bottom", Haskell's way of copping out and failing to evaluate
06:09:14 <merijn> There's no way to get ghci to lazily load the files in a component you're loading, is there?
06:09:30 <tdammers> zincy: yes. Also, some types don't *have* constructors that you could pattern match on
06:09:33 <tdammers> e.g. functions
06:09:44 <tdammers> you can't pattern match on Int -> Int, for example
06:09:52 <tabaqui2> @quote
06:09:52 <lambdabot> Franciman says: a stessa cosa che dissero tutti del controesempio di weierstrass di cui leggevo stamattina
06:10:04 <aarvar> you can copattern match on it
06:10:14 <Psybur> > let f (a -> b) = b in f (2+3)
06:10:17 <lambdabot>  error:
06:10:17 <lambdabot>      • Couldn't match expected type ‘t1 -> t2’ with actual type ‘Expr’
06:10:17 <lambdabot>      • A view pattern expression expects one argument,
06:10:23 <Psybur> :D
06:10:38 <tdammers> so, back to IO a -> a
06:10:47 <lyxia> :t \a (a -> b) -> b
06:10:49 <lambdabot> (t1 -> t2) -> t1 -> t2
06:11:15 <dminuoso> mniip: Is that because it's evictions that cause write-backs?
06:11:36 <tdammers> this is exactly the same situation as Foo a -> a: we don't have the constructor, and all the functions that we can pass IO a into will return something that also involved IO
06:11:41 <rotaerk> :t (->)
06:11:42 <lambdabot> error: parse error on input ‘->’
06:11:43 <tdammers> (except for the notorious backdoors, that is)
06:12:08 <mniip> dminuoso, yeah
06:12:08 <maerwald> tdammers: or ignore the passed in IO a
06:12:17 <aarvar> was there a purpose in not using the identity function to explain parametricity?
06:13:18 <zincy> What is parametricity? The property of functions that don't change their behaviour when operating on different types?
06:13:35 <tdammers> maerwald: exactly, but again, unless we constrain a, we can't return from that
06:13:55 <tdammers> aarvar: wasn't trying to explain parametricity
06:13:58 * luk4 is away (Assente!)
06:14:08 <tdammers> so the essence is that IO a -> a would be "magic"
06:14:26 <aarvar> so, what if you just said that there is no function IO a -> a in the first place
06:14:46 <tdammers> aarvar: there is, and it's magic. the dark kind.
06:14:54 <aarvar> tdammers: no there isnt
06:14:56 <aarvar> it's not a function
06:15:02 <zincy> https://www.haskell.org/hoogle/?hoogle=IO+a+-%3E+a
06:15:07 <tdammers> aarvar: OK, there isn't, but you can write one
06:15:09 <tdammers> aarvar: here:
06:15:18 <aarvar> tdammers: there's no total function
06:15:21 <tdammers> > let foo :: IO a -> a = const undefined
06:15:23 <lambdabot>  <no location info>: error:
06:15:23 <lambdabot>      not an expression: ‘let foo :: IO a -> a = const undefined’
06:15:35 <aarvar> the point being, there's no function IO a -> a which will execute the IO action and return the result
06:15:44 <tdammers> aarvar: right, yes
06:15:45 <aarvar> since such a function would then have to have side effects, and haskell has no side effects
06:15:52 <aarvar> that takes like, 1 sentence to explain
06:15:52 <tdammers> yes
06:15:56 <aarvar> but good job
06:15:57 <tdammers> explain, yes
06:16:01 <tdammers> understand, no
06:16:11 <maerwald> I still think "purity" is a bit overrated. In the end, as a programmer, you don't just think about what happens at evaulation time, but also at execution of your functions. That means, even if a function is pure, there is no way to easily say how it behaves when it's executed. As such, never confuse "purity" with "it's easy to reason about".
06:16:13 <aarvar> yes, I'm sure your explanation was much easier to understand
06:16:16 <tdammers> also you didn't explain how the mechanics of the type system fit the semantics
06:16:42 <aarvar> maerwald: purity is necessary but not sufficient
06:16:44 <tdammers> maerwald: purity isn't enough, you also need totality
06:16:52 <maerwald> tdammers: not just that
06:17:01 <maerwald> a fine-grained effects system
06:17:11 <tdammers> not as far as evaluation is concerned
06:17:18 <maerwald> readFile :: String -> IO String -- ok, it just sent your file to facebook too!
06:17:24 <aarvar> I think maerwald's point is that if you use IO everywhere your program will still be difficult to reason about
06:17:29 <tdammers> well, yes
06:17:32 <maerwald> tdammers: well, I explicitly said evaluation and execution
06:17:37 <tdammers> purity helps with reasoning about the pure side of thing
06:17:40 <maerwald> you need both in order to reason about a program
06:17:43 <tdammers> yes
06:17:47 <aarvar> since an IO action could be pretty much anything, so the types aren't super helpful then
06:17:53 <maerwald> exactly
06:18:03 <aarvar> so, use more precise types
06:18:03 <tdammers> but the advantage haskell has over most other languages is that we can constrain and contain effects
06:18:11 <maerwald> with mtl?
06:18:13 <maerwald> ugh
06:18:26 <aarvar> mtl is fine
06:18:38 <tdammers> mtl, free monads, expressing pure things in ways that don't involve IO, etc.
06:18:46 <aarvar> could be improved by something like monad-layers though
06:18:58 <merijn> What's a good way to pass temp files to another process if I don't want said files lying around and cluttering the filesystem?
06:19:11 <tdammers> also typeclasses
06:19:31 <dminuoso> merijn: Mmm, shmem?
06:19:41 <maerwald> those things don't combine very well
06:19:51 <tdammers> foo :: OutputContext m => String -> m () -- there, now I can only send your file to facebook if your chosen implementation of OutputContext allows it
06:19:52 <aarvar> merijn: rm -rf / when you're done?
06:19:53 <merijn> dminuoso: No, I'm dealing with a program that takes a file as commandline argument
06:20:33 <aarvar> run the program in a virtual machine
06:20:44 <exarkun> merijn: What is the interface to the program?
06:20:44 <cocreature> merijn: one of the functions in the temporary package?
06:20:48 <hodapp> put it in /tmp and hope the user uses tmpfs?
06:20:49 <frerich> merijn: Does the called process exist longer or shorter than the calling program?
06:21:01 <merijn> frerich: shorter, but I need stdin, so I can't use that
06:21:41 <merijn> frerich: Normally I'd just pass in /dev/stdin as commandline argument, but I need stdin
06:21:59 <frerich> merijn: Are you working on both programs (i.e. could you change the called program) or does it need to be something addressable via the file system?
06:22:23 <aarvar> can you just write a file and then delete it when you're done?
06:23:04 <merijn> cocreature: That's just for making files, not ensuring they get cleaned up, but maybe I can get by with one of the withTemp versions
06:23:14 <frerich> merijn: A named pipe sounds like it might be viable?
06:23:52 <cocreature> merijn: right withSystemTempFile was what I had in mind which deletes the file after use
06:23:58 <merijn> frerich: But those stay around after both programs terminate, I think
06:24:19 <exarkun> You can unlink it as soon as the child process opens it
06:24:45 <exarkun> named pipes aren't exactly the same as files, eg you can't seek.  maybe that's okay in your case though.
06:25:04 <exarkun> you can unlink a _regular_ file after the child opens it too, though.
06:26:05 <merijn> I just wish IPC wasn't in such a ridiculous 70s state...
06:26:40 <frerich> Ah, interesting, on Unix, named pipes indeed can live longer than the process (on Windows, they get closed automatically).
06:27:10 <frerich> Named pipes are kind of my go-to solution for this kind of problem because you can 'stream' data very nicely.
06:27:24 <maerwald> tdammers: I was more thinking of a hierarchy of effects that is composable and e.g. classes of effects based on what kind of underlying syscalls there are
06:27:25 <exarkun> merijn: You didn't say what the interface to the program was.  Is it a filename in argv?
06:27:32 <merijn> exarkun: yeah
06:27:34 <maerwald> but those things would never nicely compose with the current type system
06:27:36 <exarkun> merijn: What OS do you want to support?
06:28:05 <exarkun> merijn: And what form do you have the data in in the parent process?
06:28:08 <merijn> exarkun: *nix is all I care about, windows would be a bonus, but not something I wanna put too much effort in
06:28:51 <maerwald> an effects tree!
06:29:13 <maerwald> and effect inference
06:29:49 <maerwald> specializing an effect without breaking the API
06:29:51 <exarkun> ByteString?  The name of another file?
06:30:45 <merijn> exarkun: text in whatever datatype I decided to eventually put it
06:30:55 <hodapp> well, 'mktemp' has been a thing for awhile
06:31:05 <hodapp> it would just have to be understood who is responsible for cleaning it up
06:31:07 <exarkun> On Linux and BSD (w/ procfs) you could open a pipe, pass the read end of the pipe to the child, pass /dev/fd/<n> as the filename, and write the data to the write end.
06:31:43 <exarkun> hodapp: mkstemp :)
06:32:56 <merijn> exarkun: How would you figure out which value n in that scenario?
06:35:03 <exarkun> merijn: you can set it from the parent
06:35:39 <exarkun> I haven't used these POSIX APIs from Haskell before
06:35:55 <exarkun> And hackage is still down
06:36:35 <merijn> exarkun: This morning the general opinion is that it could be a day before it's back up
06:37:12 <exarkun> The POSIX API is that you open the pipe, fork, (close any fds you do no want inherited), exec, and the child process has all of the same file descriptors available - so whatever the fd was in the parent, it is in the child.
06:38:23 <fr33domlover> Did something happen to Hackage?
06:39:18 <exarkun> https://mail.haskell.org/pipermail/haskell-cafe/2018-April/128913.html
06:40:09 <hc> Suppose I want to do a couple of checks. If all checks succeed I want to return Right (), else Left Text
06:40:30 <hc> Any suggestions? Are there standard libs/idioms to follow here?
06:40:39 <hc> (all checks are pure)
06:41:13 <frerich> hc: I'm taking a guess here - if your checks are all functions of type 'a -> Either Text ()' then you could use 'sequence'.
06:41:31 <frerich> hc: In case you want to have the error text of the first failing check.
06:41:51 <hc> great, thanks!
06:42:06 <merijn> mapM_
06:44:53 <robstr> Hey, is hackage down ? :-/
06:45:06 <phadej> yes
06:45:08 <exarkun> robstr: https://mail.haskell.org/pipermail/haskell-cafe/2018-April/128913.html
06:45:18 <phadej> https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
06:45:35 <robstr> ty, i need to check there first next time :)
06:45:53 <phadej> alsoÖÖ https://status.haskell.org/
06:46:04 <phadej> which is the "best source"
06:46:43 <robstr> whoo haskell community is good prepared :P
06:48:28 <robstr> I'm trying to parse a timestamp with aeson, which currently fails as UTCTime, `eitherDecode "2014-07-09T03:21:20.08" :: Either String UTCTime` is there a resource online right now checking allowed format ?
06:59:24 <Garmy> robstr: Maybe this? https://stackoverflow.com/a/19423857
07:01:47 <merijn> ugh, for extra fun times calling new-repl via createProcess magically has a different effect from running it directly in the shell....
07:04:24 <exarkun> merijn: probably because of presence or absence of a tty
07:04:30 <exarkun> I mean pty
07:06:05 <merijn> !!
07:06:10 <merijn> %(%&(&(*%&
07:06:59 <merijn> I have a suspicion
07:07:04 <merijn> And I'm going to stab someone
07:07:21 <exarkun> sounds like you might be a computer programmer.
07:07:47 <frerich> a computer programmer with a knife.
07:08:05 <exarkun> the 7th most dangerous kind!
07:08:07 <merijn> frerich: Not on me, but I'll go and find one...
07:08:24 <merijn> People should fucking stop using system to run programs
07:08:33 <exarkun> +1
07:08:37 <merijn> God fucking dammit
07:08:45 <robstr> Garmy: ty, i will check
07:08:56 <ongy> is system the one that forks to /bin/sh?
07:09:02 <exarkun> a programmer with system()!  the 6th most dangerous kind.
07:09:11 <merijn> ongy: Yes
07:09:17 <mniip> what's wrong with system?
07:09:24 <merijn> And thus fucks up entirely because it ends up running my aliases rather than actual programs
07:09:35 <mniip> ah, using a shell?
07:09:37 <merijn> mniip: Because I have "ghci" aliased to ghci + some arguments
07:09:52 <merijn> mniip: And running shit by passing a string through a shell triggers the aliases
07:09:57 <exarkun> ouch
07:10:00 <ongy> then your config is weird. shells should only parse them in interactive settings
07:10:15 <ongy> that's usually the very first line in .bash/zsh/whatever_rc
07:10:18 <exarkun> I agree with ongy but using system() is still awful.
07:10:21 <Ke> merijn: I alias to something else than the original command name, like qemu-con etc.
07:10:39 <exarkun> bad shell alias interaction is just 1% of the stuff that can go wrong
07:10:52 <merijn> ongy: THey're in my .bashrc is only for interactive shells
07:11:25 <exarkun> system() lets the child process inherit stdin/stdout/stderr
07:11:36 <exarkun> if stdin is a pty, hey, it's an interactive shell.
07:12:25 <jchia_1> Besides using CPP, is there a way to make code compatible with GHC 8.4 and pre-8.4 wrt the typeclass hierarchy related to Semigroup and Monoid?
07:12:26 <exarkun> (maybe)
07:13:20 <exarkun> merijn: but it's kind of surprising that /bin/sh reads your bashrc in any case
07:13:33 <merijn> exarkun: I'm not sure anymore what it does
07:13:40 <merijn> Maybe it's not the shell alias
07:13:51 <jchia_1> In GHC 8.4 the "class Monoid a ..." became "class Semigroup a => Monoid a ...".
07:14:05 <merijn> but for some reason "cabal new-repl" starts ghci with my .ghci loaded despite explicitly being told NOT to
07:14:07 <dminuoso> jchia_1: Just ensure you define a Semigroup instance everytime you define a Monoid instance.
07:14:30 <jchia_1> dminuoso: The problem is making the same code accepted under 8.4 and pre-8.4
07:14:43 <merijn> exarkun: Changing the alias isn't doing anything, so maybe it's something else
07:14:48 <dminuoso> jchia_1: What do you mean?
07:15:11 <ongy> jchia_1: pre 8.4 should still work with the Semigroup instance
07:15:15 <dminuoso> jchia_1: Just ensure you import Data.Semigroup, define the instance..
07:15:18 <ongy> you may need to import it
07:15:29 <dminuoso> jchia_1: The only "breaking" change is that 8.4 has placed Semigroup into Prelude
07:20:21 <tdammers> maerwald: indeed, we'd need some sort of extensible records system that doesn't suck
07:22:14 <jchia_1> dminuoso: OK, import Data.Semigroup and make a Semigroup instance for types that have a Monoid instance. I got this mixed up with another issue related to Text.PrettyPrint.HughesPJ.
07:23:26 <merijn> jchia_1: Which library are you using?
07:24:42 <jchia_1> merijn: I got the issue mixed up with the one here: https://github.com/skogsbaer/HTF/commit/9ecaf357ad4effae28121043579ab94876fed789
07:24:57 <jchia_1> I was going to try to fix the OneTuple package.
07:25:06 <jchia_1> But the maintainer is uncontactable. email bounced
07:25:20 <merijn> jchia_1: Which library is Text.PrettyPrint from?
07:26:46 <jchia_1> merijn: I believe it's 'pretty'.
07:27:01 <merijn> jchia_1: Where this is going is: You stop using it and replace it with prettyprinter by quchen
07:27:58 <jchia_1> merijn: Is it functionally the same? Maybe I'll make a github issue about migrating to prettyprinter.
07:28:32 <merijn> jchia_1: prettyprinter is designed to replace the 15 billion conflicting wl-prettyprint packages around
07:28:53 <merijn> Not sure how pretty fits into that picture, but it probably deserves to go too
07:35:56 <jchia_1> merijn: How do the wl-prettyprint packages conflict?
07:36:42 <merijn> jchia_1: there's wl-ansi-prettyprint wl-annotated-prettyprint, etc.
07:36:53 <merijn> jchia_1: But if you want annotation AND ansi colours you're basically boned
07:38:54 <yaxu> I'm getting a weird problem with Data.Semigroup.. I defined instances for compatibility with 8.4.1, then found people getting weird lockups with older ghc versions..
07:39:11 <dagano> how can i use cabal to search for a module by its path name, rather than its module name? ie i want 'Data.Vector.Unboxed.Bit' but using `cabal list bit' only shows the package name bit-vector (which is not the droid i'm looking for afaik)
07:39:45 <merijn> dagano: How did you find the module "Data.Vector.Unboxed.Bit"?
07:39:58 <dagano> google
07:40:05 <merijn> On which page...
07:41:05 <dagano> hackage .. which is down .. was hoping the mapping from Data.Vector.Unboxed.Bit -> (whatever the name is) would be available from cabal
07:41:30 <Ssavas> hi I need some help with Par monad here
07:42:00 <dogui> How do I tell Cabal to use a mirror?
07:42:02 <Ssavas> I am writing my own parallel map function with Par monad
07:42:16 <merijn> dogui: It should automatically switch to one of the mirrors if you have a recent cabal-install
07:42:42 <dogui> I don't : )
07:42:56 <Ssavas> The signature is pMapPM :: (NFData b) => (a -> b) -> [a] -> [b]
07:43:21 <Ssavas> I do not return an IVar, do i still need to use Par for my return list in the signature?
07:45:27 <dogui> merijn: I wrote in the .config, thanks
07:50:19 <sp__> I have a question: my program crashes with the following error "Prelude.read: no parse". And I have no idea which function could be causing this. Does anyone know of pottential suspects ?
07:50:39 <mniip> Prelude.reaed
07:51:09 <lyxia> Ssavas: you can have a signature like that without Par indeed.
07:51:19 <sp__> mniip: ok. thanks.
07:51:36 <Ssavas> lyxia, thanks
07:51:48 <ongy> sp__: you can grep your source for 'read', but a better way (imo) to et the information is to compile with profiling and rtsopts and call the application with +RTS -xc arguments, to get a stack on exceptions
07:52:52 <woodson> hey guys, I would like to know is ghcjs used more than purescript ? Or is purescript the best option to deal with javascript in haskell?
07:54:59 <sp__> ongy: Thanks for the advice. I did not know of this option.
07:55:01 <dysfun> purescript isn't haskell, to be clear
07:55:41 <dysfun> i personally think PS is the best option for frontend
07:55:41 <woodson> dysfun, i know
07:56:41 <woodson> I am just wondering if purescript is a better option than ghcjs if one wants to stay close to something similar to haskell
07:57:04 <dysfun> ghcjs will be amazing one day. i'm not convinced today is that day
07:57:52 <cocreature> the biggest advantage of ghcjs is that you can actually take your existing Haskell code and use it in your web app
07:57:59 <cocreature> but the tooling is somewhat rough
07:58:57 <woodson> Not only the web but to also interact with node library
07:59:18 <woodson> well js libraries i guess
08:00:04 <cocreature> yeah I guess so although I haven’t found any server-side js libs that I wanted to integrate with so far :)
08:00:22 <dysfun> if you're not actually using haskell on the backend, purescript is a no-brainer i think
08:00:30 <woodson> I have written a small tool in CLI tool in haskell but I would like to interact with a node lib
08:00:45 <woodson> and I am thinking that purescript might be a better option
08:01:00 <woodson> but I am looking at their command line parser lib
08:01:09 <woodson> and I am already missing optapplicative
08:02:36 <woodson> I just wish that there was something like as easy as bucklescript in haskell!
08:03:02 <cocreature> depending on the lib, it might also be a reasonable option to just launch a new process running node and communicate with that
08:04:19 <exarkun> How is bucklescript different from ghcjs?
08:06:01 <woodson> exarkun, i said easy to use
08:06:26 <woodson> just install ghcjs was a pain for me and the size of the file that it generates
08:06:31 <woodson> I am not saying its bad
08:06:52 <exarkun> I'm not saying it's good :)  Just asking for the comparison.
08:07:44 <woodson> Thats why I hate messaging sometimes.. misinterpreted
08:07:52 <woodson> at least we are on the same page now
08:07:54 <woodson> :)
08:08:03 <dysfun> all of these are reasons i went with purescript
08:08:43 <woodson> dysfun, you seem to have more knowledge in purescript
08:08:50 <dysfun> i've used it for a project
08:08:55 <woodson> have you ever tried to build a cli tool?
08:09:00 <dysfun> i wouldn't call myself an expert
08:09:11 <dysfun> not in ps, but it shouldn't be hard
08:09:21 <dysfun> well, apart from dealing with the nodejs apis
08:09:29 <dysfun> that's bound to be unreasonably painful in places
08:09:58 <dysfun> i'm using halogen, which i think is pretty good on the whole
08:10:03 <woodson> I need to convert yaml -> xml and xml -> yaml
08:10:14 <woodson> https://github.com/Thimoteus/purescript-optlicative
08:10:26 <dysfun> lol, nice name
08:10:35 <woodson> I was looking at this but I guess i am comparing it too much to
08:10:44 <woodson> haskell's optapplicative
08:10:57 <woodson> but quickly looking at it I just felt like meh..
08:11:04 <dysfun> *shrug* i always preferred cmdargs anyway
08:11:12 <woodson> haha
08:11:13 <woodson> lol
08:11:18 <woodson> either way
08:11:30 <woodson> the haskell libs just all seem better
08:11:37 <dysfun> ps is newer
08:11:42 <dysfun> that's got pros and cons
08:12:00 <dysfun> i think they've done a remarkable job in the time they've had tbh
08:12:39 <dysfun> there are areas where (dare i say it?) ps is better than haskell
08:12:48 <dysfun> unfortunately there are areas where the converse is true
08:13:18 <woodson> ok well I guess i just need advice from people more experienced
08:13:21 <woodson> if I may ask
08:13:34 <adjofun> dysfun: how dare you say such blasphemous words =:)
08:14:26 <woodson> my tool will just build a simple forlder project and retrieve some xml file from a nodejs library and convert it to yaml and it can also take the yaml file and convert it to xml and use the node lib to push to some server
08:14:47 <woodson> would you suggest using ps to communicate with node and do the parsing?
08:15:00 <woodson> or just use haskell and I guess call node using process?
08:15:04 <dysfun> it's not so much as communicate with node as call the node libs
08:15:12 <woodson> System.Process
08:15:31 <dysfun> it seems like you will need *some* javascript
08:16:07 <dysfun> that could be written in purescript, or it could be js with a haskell program bolted on the front or you could fight ghcjs
08:16:48 <woodson> it seems like I will have to deal alot with ffi in puresscript because
08:16:54 <woodson> I dont think that they have an xml lib
08:17:03 <woodson> so I would have to use a js lib?
08:17:37 <dysfun> maybe, i haven't looked
08:17:50 <dysfun> i've just built a web frontend in it
08:18:04 <woodson> ok, well is it a pain using the ffi?
08:18:17 <dysfun> way less than haskell imo
08:18:26 <dysfun> there's also purescript-ffi-utils which is quite handy
08:18:53 <bartavelle> anybody known how to display the Z3 source code from SBV ?
08:19:02 <bartavelle> s/known/knows/
08:19:11 <woodson> ok I guess that I would have to just git a try at their cli tools
08:19:29 <woodson> but the optapplicative that they have isnt completely done
08:19:41 <dysfun> submit a PR :)
08:19:47 <woodson> so I might have to use ffi and just use js Command  lib
08:20:18 <woodson> already planning on working on their pursuit repo to get my feet with
08:20:20 <woodson> wet**
08:20:24 <woodson> :)
08:20:50 <dysfun> i'd recommend fixing up a purescript lib over ffi personally
08:21:17 <dysfun> not that ffi is painful, but better to keep things in ps where it's easier to reason
08:22:36 <woodson> dysfun, alright thanks a lot
08:22:40 <woodson> really appreciate!
08:23:13 <woodson> I will start with a small cli sample to see how it goes
08:25:48 <dagano> currently learning about the state monad ... i want a set-like interface where all i care about is adding elements and testing for membership .. do these function signatures look right? set_add :: String -> S.State Table ()    and set_lookup :: S.State Table () -> String -> Bool ? for set_add i am not interested in returning a  value for calls .. is it correct to use () ?
08:26:52 <lyxia> setLookup :: String -> S.State Table Bool
08:28:40 <lyxia> Monadic functions generally look like   a -> ... -> m x   where m is your monad
08:29:11 <DwarfMaster> dagano: () is indeed the standard type to express an absence of interesting value
08:30:12 <dagano> lyxia: ah ok thanks .. i think escaping do notation would help me reason about the types/composition more clearly
08:33:32 <dagano> ok question about State.put  . if my state is some huge table, and i want to modify a small block of it .. is the state mutable in some sense? or is the state going to be copied entirely and then modified?
08:35:15 <lyxia> the state is not mutable but large chunks of it can get reused when you update it
08:35:37 <lyxia> it's the beauty of persistent data structures
08:37:35 <dagano> well i wonder why i'm using the state monad then. i could just have pure fuctions :: Table -> Item -> Table which would return a new table with item added
08:38:06 <DwarfMaster> It makes it possible to use the do notation
08:38:38 <DwarfMaster> And all the utilities that have been developped for monads
08:39:26 <DwarfMaster> But you are right in that State s a is equivalent to s -> (s,a)
08:39:54 <adjofun> :i State
08:39:55 <dagano> ah it helps to see it expressed that way
08:40:04 <lyxia> dagano: the state monad makes the state passing implicit
08:41:02 <adjofun> dagano: you are better off thinking that values with type `State s a` are state processors
08:52:59 <dysfun> woodson: welcome
09:01:00 <zincy> Im using Miso which is a front end framework. Websocket msgs come in through their api as a MisoString type. Now in order to decode such a msg using the aeson library I need a Bytestring not a MisoString. I could convert the MisoString into a Bytestring and then decode the JSON but this seems weird. Any ideas guys?
09:02:00 <lemmih> What is a MisoString?
09:02:15 <Akii> probably a type of noodle?
09:02:53 <zincy> A synonym for JSString
09:03:10 <zincy> https://haddocks.haskell-miso.org/src/Miso-String.html#MisoString
09:03:17 <lemmih> What is a JSString? :)
09:04:19 <adjofun> zincy: there is a fromMisoString :: MisoString -> str, where str is any string-like type, and ByteString is a string-like type
09:05:11 <zincy> GHCJS wrapper around a Javascript String
09:06:49 <zincy> adjofun - thanks Ill try that
09:08:17 <adjofun> zincy: also look at {-# LANGUAGE OverloadedStrings #-}, it seems relevant to your problem
09:11:04 <vlatkoB> Where is the HaXml issue tracker?
09:21:16 <jgt> Hello Haskellers
09:21:46 <jgt> when I start GHCi, it loads my project-specific .ghci before loading my global .ghci
09:21:58 <jgt> I think this behaviour is backwards
09:22:07 <jgt> can I change it somehow?
09:23:18 <zincy> What does "the type variable 'a0' is ambiguous" mean?
09:23:32 <alexteves_> http://hackage.haskell.org/ is down? I'm getting 'Error 503 Connection timed out'
09:23:57 <phadej> :t show . read "123"
09:23:59 <lambdabot> (Read (a2 -> a1), Show a1) => a2 -> String
09:24:07 <phadej> :t show . read $ "123"
09:24:08 <lambdabot> String
09:24:20 <alexteves_> defaulting is nasty
09:24:20 <phadej> kind of situation, here lambdabot defaults to ()
09:24:28 <phadej> show (read "123")
09:24:32 <phadej> > show (read "123")
09:24:35 <lambdabot>  "*Exception: Prelude.read: no parse
09:24:37 <phadej> > show (read "()")
09:24:40 <lambdabot>  "()"
09:24:57 <phadej> but not in GHCI, you'd need to somehow specify the type
09:24:58 <phadej> e.g.
09:25:02 <phadej> > show (read "123" :: Int)
09:25:05 <lambdabot>  "123"
09:25:32 <dsal> Does anyone have an example of a cabal dependency being conditional on GHC version?
09:26:47 <phadej> dsal: what you try to achieve_
09:26:48 <phadej> ?
09:27:29 <dsal> phadej: I did a pull request for checkers: https://github.com/conal/checkers/pull/21  -- it builds on old versions of ghc and I want to see if I can add a conditional dependency on semigroup that would make it work on all versions.
09:28:24 <jgt> Hackage is down. Stackage is not down. Let's have a flame war.
09:28:33 <phadej> if !impl(ghc >= 8.0)\n  build-depends: semigroups >= <pick suitable lower bound> && <0.19
09:28:49 <dsal> phadej: thanks.  Where does that go?
09:28:51 <phadej> jgt: Hackage mirrors work, I see no problem
09:29:13 <phadej> dsal: see e.g. https://github.com/haskell-compat/base-compat/blob/master/base-compat-batteries/base-compat-batteries.cabal for an example
09:29:20 <dsal> Awesome, thanks.
09:29:35 <jgt> phadej: comment was tongue-in-cheek, and I was replying to alexteves_
09:29:41 <jgt> :)
09:30:16 <phadej> I see, alexteves_ https://status.haskell.org/ is good site to check if something*.haskell.org doesn't work
09:31:13 <phadej> the topic is so full of links it won't make there I guess
09:31:29 <jgt> alexteves_: see https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
09:31:43 <enterprisey> we could shorten the topic a bit
09:31:44 <alexteves_> phadej jgt: ah thanks
09:31:49 <enterprisey> the logs could be linked to from the wiki page
09:39:53 <jking> Is the hackage outage being fixed?
09:40:01 <davean> Yes
09:40:18 <jking> Thanks - it breaks all the Apache Thrift builds when it is down :(
09:40:39 <davean> Ah :( Sorry, it'll be back probably around the end of the day
09:40:42 <davean> sorry
09:40:59 <jking> np, thanks
09:41:33 <cocreature> jking: recent versions of cabal (>= 2.0) will automatically fall back to mirrors so your builds shouldn’t break
09:46:55 <greentrophy[m]> Is it possible to parse a JSON object with arbitrary fields as an array using Aeson?
09:47:22 <greentrophy[m]> i.e. the fields aren't known ahead of time
09:47:40 <davean> greentrophy[m]: "as an array"?
09:47:45 <davean> what does that even mean?
09:48:04 <davean> It has fields, thats not array structured
09:48:13 <greentrophy[m]> so similarly to how you might parse a JSON array
09:48:44 <davean> But if its an array, it doesn't have fields
09:49:38 <infandum> Is there a list data type in haskell with O(1) length and O(1) mappend?
09:50:05 <davean> greentrophy[m]: it easy to get a mapping of field name to value with aeson
09:50:56 <greentrophy[m]> so something like this `{"adjhgadg":{"numbers":[1,2]},"aglkhdg":{"numbers":[6,3]},"galdghadg":{"numbers":[8,3]}}`
09:51:20 <greentrophy[m]> and you want [(String, [Int])]
09:51:29 <davean> That it just gives you
09:51:31 <davean> thats not an array
09:51:42 <jle`> infandum: maybe diff list type with tagged length
09:51:55 <davean> well, greentrophy[m], do you care about the ordering?
09:52:05 <davean> because JSON is order-invariant
09:52:14 <greentrophy[m]> no
09:52:17 <jle`> @let data DiffLen a = DL Int ([a] -> [a])
09:52:19 <lambdabot>  Defined.
09:52:20 <davean> Well then thats Object
09:52:28 <davean> which you'll see reflected in the JSON spec
09:53:26 <greentrophy[m]> `[{"name":"adjhgadg","numbers":[1,2]},{"name":"aglkhdg=","numbers":[6,3]},{"name":"galdghadg=","numbers":[8,3]}]` would be an example of something that I know how to parse that would end with the same result
09:54:06 <jle`> @let instance Semigroup (DL a) where DL n f <> DL m g = DL (n + m) (f . g)
09:54:08 <lambdabot>  .L.hs:165:10: error:
09:54:08 <lambdabot>      Not in scope: type constructor or class ‘Semigroup’
09:54:08 <lambdabot>      |
09:54:40 <jle`> @let instance Semigroup (DL a) where DL n f <> DL m g = DL (n + m) (f . g); instance Monoid (DL a) where mappend = (<>); mempty = DL 0 id
09:54:40 <lambdabot>  Parse failed: Parse error: instance
09:54:56 <jle`> @let instance Semigroup (DL a) where DL n f <> DL m g = DL (n + m) (f . g)
09:54:57 <lambdabot>  .L.hs:166:21: error:
09:54:57 <lambdabot>      • Expecting one more argument to ‘'DL a’
09:54:57 <lambdabot>        Expected a type, but
09:55:23 <jle`> @let instance Semigroup (DiffLen a) where DL n f <> DL m g = DL (n + m) (f . g)    -- last time :)
09:55:25 <lambdabot>  Defined.
09:55:38 <lemmih> Woo! Third time's the charm.
09:55:54 <jle`> @let instance Monoid (DiffLen a) where mappend = (<>); mempty = DL 0 id
09:55:55 <lambdabot>  .L.hs:170:19: error:
09:55:55 <lambdabot>      Ambiguous occurrence ‘<>’
09:55:55 <lambdabot>      It could refer to either ‘Data.Monoid.<>’,
09:56:04 <jle`> oh lambdabot is still on ghc 8.2 huh
09:57:32 <jle`> @let singletonDL :: a -> DiffLen a; singletonDL x = DL 1 (x:)
09:57:34 <lambdabot>  Defined.
09:57:44 <jle`> that type should have O(1) length and O(1) mappend
09:59:51 <doyougnu> hey all is the hackage website down? I keep getting 503 from it
09:59:57 <jle`> yes hackage is down
10:00:11 <jle`> https://status.haskell.org/
10:00:35 <EvanR> cue strongbad
10:08:07 <dmj`> doyougnu: there are mirrors
10:32:51 <curca> Why hackage is down?
10:33:09 <Taneb> curca: admin messed up somehow
10:33:31 <Taneb> See https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
10:35:16 <EvanR> "rapid unplanned disassembly"
10:36:34 <curca> Taneb: Thanks, bruh. I wanted to check wxwidgets docs in the morning and was surprised that the website is down for the whole day
10:37:13 <dumptruckman> Hey
10:37:27 <dumptruckman> Anyone have an examples of how to create an interactive console application?
10:37:56 <EvanR> theres this library brick
10:38:05 <EvanR> you could also try ncurses
10:38:30 <dumptruckman> What about just vanilla Haskell
10:38:41 <dumptruckman> I just don't even know how to approach this kind of problem
10:38:47 <EvanR> you need something to speak ancient console control runes
10:39:02 <davean> He doesn't necissarily mean semi-graphical
10:39:03 <curca> I don't think Haskell's standard lib contains something similar to ncurses
10:39:12 <waiting-for-dev> Hi there! Anyone out there that has been using selda package to deal with SQL?
10:39:39 <dumptruckman> Indeed, I do not mean semi-graphical... just something that would loop on use input and continue to ask questions or some such
10:39:43 <EvanR> ah
10:40:02 <EvanR> in Data.ByteString you have getLine to get a line of input
10:40:22 <EvanR> you could repeatedly do that, parse it and putStrLn the output
10:41:00 <Ariakenom> :t interact id
10:41:01 <lambdabot> IO ()
10:41:20 <EvanR> or getLine from the prelude
10:41:23 <EvanR> :t getLine
10:41:24 <lambdabot> IO String
10:41:28 <EvanR> :t interact
10:41:29 <lambdabot> (String -> String) -> IO ()
10:41:49 <dumptruckman> does anyone have an example of something like this?
10:42:18 <dumptruckman> I've used interact before for taking in a one off input but not for repeated inputs
10:42:31 <dyl> Hackage is in guru meditation.
10:42:42 <dyl> I guess it's about to emit the most gorgeous fold expression we've ever seen.
10:42:48 <EvanR> main = do{ putStrLn "type stuff."; interact (\stuff -> show (length stuff)) }
10:43:20 <EvanR> how does interact ever take only 1 ?
10:43:23 <Ariakenom> no
10:43:36 <Ariakenom> So you'd need to EOF it. Not great.
10:44:51 <Boomerang> main = interact (unlines . ("Hello" :) . fmap (show . (* 2) . read) . lines)
10:44:58 <Ariakenom> "interact id" is a program that echoes input
10:45:30 <dumptruckman> so wait.. interact continues to accept input?
10:45:44 <Boomerang> Yeah!
10:45:48 <Ariakenom> "interact (map toUpper)" is a program that uppercases the input
10:46:22 <Boomerang> I believe stdin and stdout are line buffered by default (at least with interact)
10:46:38 <dumptruckman> and it just termintes on EOF?
10:46:39 <EvanR> @src interact
10:46:39 <lambdabot> interact f = do s <- getContents; putStr (f s)
10:46:48 <EvanR> wut...
10:47:09 <Ariakenom> hehe, it's fun
10:47:13 <EvanR> so it doesnt work like `repl' from idris
10:47:23 <cocreature> do people use "interact" in real programs? it’s one of those functions that seem like they have just been added to "base" to make toy examples shorter while not being particularly useful in any kind of non-trivial program
10:47:31 <Ariakenom> You write a sufficently lazy (String->String)
10:47:47 <EvanR> yeah interact isnt great, repl is great
10:48:00 <Boomerang> I use interact for 99% of hackerrank problems :D
10:48:13 <byorgey> cocreature: I use interact all the time in one specific situation: when writing solutions to competitive programming problems
10:48:20 <Boomerang> But that's pretty much the only time I use it :p
10:48:26 <cocreature> ah interesting, thanks!
10:48:32 <cocreature> so it does have at least one use :)
10:49:18 <Ariakenom> main = interact main'. You've solved input output. I've found it handy.
10:49:19 <Boomerang> interact is the only IO you need for HackerRank problems, because they all have input on stdin and output on stdout with a pure solution
10:50:29 <dyl> I refuse to touch "hacker rank" because it brands itself as prep for "programming interviews".
10:50:33 <dyl> But, I would really like a nice problem set.
10:51:00 * dyl has a deep disdain a lot of industry practices surrounding interviews.
10:51:05 <NahNood1> What's the standard name (if any) for a function :: a -> (() -> a)?
10:51:19 <tabaqui2> NahNood1: const?
10:51:33 <dsal> :t const
10:51:35 <lambdabot> a -> b -> a
10:51:35 <dsal> Not specifically unit
10:51:38 <cocreature> NahNood1: that seems like a weird function "() -> a" is just "a"
10:51:46 <dyl> Still, generally that would be const.
10:51:52 <dyl> The only place that 'a' could come from is the input.
10:52:02 <EvanR> i once got a coin sorting problem
10:52:11 <dyl> ?free f :: a -> (() -> a)
10:52:11 <lambdabot> (.) g . f = f . g
10:52:16 <EvanR> i gave them a functional solution very simple, very quickly
10:52:19 <EvanR> they hated it
10:52:37 <EvanR> wasnt the solution they were expecting
10:52:57 <dyl> Interview problems only work if the interviewer can be a good judge. The reality is that hires are a human issue, and programmers aren't just warm bodies.
10:52:58 <cocreature> EvanR: it wasn’t composed of at least 10 java classes so obviously it was wrong
10:53:13 <NahNood1> tabaqui2, dsal: Hm, I guess 'const' is ok, even tho the intent is different. I mean it as a fn that takes a value and returns a thunk with that value (although in the context of Haskell it doesn't make much sense)
10:53:25 <EvanR> this was like, every programmer in the company in the interview too
10:53:28 <dyl> I've been hearing increasingly of trying to turn interviewing into a very mechanical scored process to the exclusion of important things like *actually interviewing someone*.
10:53:33 <dsal> NahNood1: How would you tell the difference?
10:53:41 <dyl> EvanR Sounds like a bad "culture fit".
10:53:42 <dyl> ;)
10:53:50 <EvanR> i was broke so
10:54:13 <NahNood1> dsal: between the b->a and ()->a version? Only by looking at the type. :)
10:54:49 <dyl> ?free f :: a -> (() -> a)
10:54:50 <lambdabot> (.) g . f = f . g
10:54:52 <dyl> ?free f :: a -> (b -> a)
10:54:53 <lambdabot> g . f x = f (g x) . h
10:55:11 <cajstyle> ?help
10:55:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:55:17 <cajstyle> ?list
10:55:17 <lambdabot> What module?  Try @listmodules for some ideas.
10:55:24 <cajstyle> @listmodules
10:55:24 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
10:55:24 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
10:55:25 <Ariakenom> dumptruckman, you mean like this? http://lpaste.net/364727
10:55:40 <dyl> ?unpl (.) g . f
10:55:40 <lambdabot> (\ x x0 -> g (f x x0))
10:55:41 <cajstyle> ?help op
10:55:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:01:52 <Ariakenom> unpl? You've been banned from #Haskell.
11:08:04 <dumptruckman> Ariakenom: uh yeah... is that idiomatic though?
11:08:42 <Ariakenom> dumptruckman, Sure. Anything in particular bothering you?
11:10:10 <dumptruckman> *shrug* I dunno, is it better than just using interact?
11:10:29 <dumptruckman> also I don't understand the implications of using monads so there's that too
11:10:41 <dumptruckman> just always unsure around monads
11:12:46 <Ariakenom> interact does get you around monads. But it's probably easier to get your command line thing going with "do" like the link.
11:13:28 <ski> s;monads;the I/O monad; ?
11:14:19 <rckd> hackage down?
11:14:23 <Ariakenom> ski how when what why?
11:14:30 <cocreature> rckd: https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
11:14:46 <rckd> oh lol thanks
11:15:00 <cocreature> rckd: ffr https://status.haskell.org/
11:15:48 <ski> `interact' returns an action in the I/O monad in particular
11:15:53 <rckd> whoops
11:17:01 <Ariakenom> and a monad in general
11:17:21 <rckd> reminds me on how i deleted a production database by accident. thank god i made a backup 5 minutes before that happend xD
11:18:33 <ski> dumptruckman seemed to be talking/thinking about monads in the general. i just wanted to point out that here we have `IO', which happens to be a monad, among other aspects of its interface
11:21:36 <Ariakenom> don't quite see why, but sure.
11:21:59 <Welkin> wtf is interact?
11:22:14 <statusfailed> :t interact
11:22:15 <lambdabot> (String -> String) -> IO ()
11:22:31 <Welkin> that is the type
11:22:33 <statusfailed> reads a string from stdin, passes to your function, writes the output of your function to stdout
11:22:36 <statusfailed> iirc
11:22:50 <Welkin> oh
11:22:55 <statusfailed> so "interact id" is echo
11:23:05 <Welkin> I vaguely recall that from some haskell tutorial I read many years ago
11:23:07 <Welkin> never touched it
11:23:33 <statusfailed> I think the type is a bit too simple to be useful in many applications
11:23:43 <statusfailed> I think there is also interactM maybe
11:23:45 <statusfailed> :t interactM
11:23:46 <Welkin> yeah, it looks useless
11:23:47 <lambdabot> error:
11:23:47 <lambdabot>     • Variable not in scope: interactM
11:23:47 <lambdabot>     • Perhaps you meant one of these:
11:24:17 <statusfailed> maybe it's not in prelude :-)
11:24:24 <ski>   interact f = putStr . f =<< getContents  -- iirc
11:24:42 <unknownln> `interact f = fmap f getContents >>= putStr`
11:24:43 <unknownln> basically
11:24:46 <statusfailed> ski: I think it reads line by line?
11:24:58 <Ariakenom> main = interact main' is nice if you just munch text. Like programming puzzles and similar.
11:25:00 <ski> statusfailed : depends on the buffering set
11:25:16 <ski> @src interact
11:25:16 <lambdabot> interact f = do s <- getContents; putStr (f s)
11:25:20 <statusfailed> ski: I thought getContents reads until EOF?
11:25:30 <ski> sure ?
11:25:31 <statusfailed> oh I misread your code :-)
11:25:48 <ski> it uses `unsafeInterleaveIO' ..
11:25:59 <Ariakenom> getContents does Lazy IO so returns right away.
11:26:18 <Ariakenom> I keep capitalising Lazy ...
11:26:26 <geekosaur> it's a convenience for quick and dirty scripting, basically
11:26:39 <infandum> jle`: Thanks, I'll look into it!
11:30:24 <Ariakenom> It makes for funny basic programming examples. Write a program that echoes input tends to take a few lines, ex 2 in python. In Haskell it's a 2 word expression :p
11:34:54 <dumptruckman> bah
11:35:15 <dumptruckman> with how infrequently I play with Haskell this Hackage downtime is really unlucky timing for me
11:39:18 <Welkin> as far as I know, hackage has never been down like this
11:40:13 <infandum> jle`: That looks pretty straightforward -- why isn't the default to use difference lists?
11:43:31 <[exa]> btw how complicated it is to mirror hackage on premises?
11:44:13 <[exa]> (or run a fork)
11:44:48 <azahi> after parsing json in data type "Values" I'm presented with something like that "Values {first = "first", second = "second" .. last = "last"}", how to get a specific value from it, for example, get "second" for printing?
11:45:02 <dumptruckman> Resorting to repl.it right now to play around cause i cannot install Haskell atm
11:45:09 <dumptruckman> what's this mean: 2018/04/12 18:43:59 error while decoding message:  invalid character 'H' looking for beginning of value
11:45:26 <dumptruckman> Just doing main = interact (map toUpper)
11:45:40 <dumptruckman> tried with input Hello
11:46:24 <jle`> infandum: they are really only optimized for mappends
11:46:48 <jle`> everything else they are pretty bad at
11:46:57 <jle`> O(n) head and tail, for instance :p
11:47:28 <Welkin> dumptruckman: why not?
11:47:35 <Welkin> dumptruckman: you certainly can install haskell
11:47:44 <Welkin> either using haskell platform, or from your distro's package manager
11:47:58 <Welkin> it takes a few seconds
11:48:17 <jle`> dumptruckman: hackage downtime isn't too bad because stackage has a nice mirror and cabal/stack already use mirrors
11:48:39 <dumptruckman> Well, actually trying to use Eta, which apparently needs to update before I can use it and it relies on Hackage
11:48:46 <jle`> *nice documentatino mirror
11:48:54 <pdxleif> The hackage website isn't working for me, but I can still cabal install stuff right now.
11:49:27 <Cale> infandum: btw, most of the time I wouldn't even bother with the DList type, unless I really needed the monoid instance -- for simple applications, it's usually tidy enough to just work with functions [a] -> [a] or whatever, and in place of each (++) use (.), in place of [x] use (x:) and in place of [] use id
11:49:33 <jle`> dumptruckman: what happens when you try to update it?
11:49:34 <Welkin> what is Eta? O.o
11:50:00 <dumptruckman> https://eta-lang.org/
11:50:31 <jle`> infandum: the original type you wanted could actually just be represented using (Sum Int, Endo [a])
11:50:57 <jle`> where singleton x = (Sum 1, Endo (x:))
11:51:13 <jle`> mappend/mempty/(<>) would work probably
11:52:24 <jle`> s/probably/properly
11:52:36 <dumptruckman> jle`: https://pastebin.com/4dapLuUx
11:52:41 <Cale> infandum: One of the first things I did way back when working on Bloodknight (an ARPG written in Haskell that never got released) was to improve the performance of our map editor's serialisation stuff. I noticed that it was cutting up a bunch of ByteStrings and concatenating them, and so before even bothering to understand why it was slow, I tried replacing ByteString with ByteString -> ByteString in a bunch of places
11:52:41 <Cale> and basically doing that trick, and all of a sudden, it went from taking several hundred MB of memory and half an hour to pack all the game data to taking a few megabytes and 30 seconds or so. :D
11:52:52 <jle`> huh that's unfortunate
11:53:44 <dumptruckman> I just started trying to use Eta a few days ago and it looks like there's now a new way to install it with gradle
11:53:51 <dumptruckman> maybe I should try to do that
11:53:57 <jle`> dumptruckman: does this help? https://github.com/typelead/eta/blob/master/docs/source/etlas-user-guide.rst#configuration-file
11:54:32 <Cale> (This was in a time before ByteString.Builder existed, which is roughly a fancier version of the same trick)
11:55:08 <Welkin> Cale: why isn't it open sourced?
11:55:19 <Welkin> if it is dead anyway
11:55:29 <Cale> Welkin: Because that would mean that we'd have to deal with supporting it
11:55:34 <Cale> for one
11:55:36 <Welkin> no you don't
11:55:47 <Welkin> just throw the code online and say "no warranty or support, have fun"
11:56:03 <Cale> Secondly, at this point, I doubt it would even build because of the way that GHC won't allow infix type variables.
11:56:36 <Cale> A large chunk of the code is our early arrowized FRP system, which if we were doing it all again today we'd just replace with Reflex.
11:57:00 <Cale> Maybe at some point Obsidian will have enough resources that we'll try and resuscitate it :D
11:57:01 <Welkin> it would be interesting to see the code
11:57:08 <Welkin> how you put it all together
11:57:20 <dumptruckman> jle`: it very well might. Thanks.
11:57:30 <jle`> best of luck :)
11:57:44 <Cale> Oh, and also, it included all the super-early cross compilation toolchain stuff
11:57:58 <Cale> which got upstreamed into GHC and probably replaced by now :)
11:58:12 <Cale> because the goal was to run this game on iPhones
12:03:12 <dysfun> what is the state of haskell for phones these days?
12:05:57 <eeyun[m]> does anyone have any suggestions on books to read or tutorials to go through for someone looking to get started in haskell?
12:06:33 <CahC5ooz> I have 2 questions about lambda lifting. 1) Given \x -> map (+ x) [...], is it correct that I can't lift the inner lambda if map is e.g. a (compiled) primitive? 2. Since every lambda term can be rewritten into SK-calculus, can I achieve the same effect as if I've lambda lifted the inner lambda by rewriting the whole function into a nameless combinator?
12:07:02 <EvanR> what inner lambda
12:07:24 <Welkin> (+ x) is \ a -> a + x
12:07:29 <Welkin> I think is what he means
12:07:31 <CahC5ooz> ^^^ this
12:07:42 <Welkin> but wtf is an "inner lambda"?
12:07:46 <Welkin> I don't understand your question
12:08:12 <dysfun> i think it's just meant "not the one starting \x at the top"
12:08:17 <Welkin> okay
12:08:21 <Welkin> but I have no idea what they are asking
12:08:22 <CahC5ooz> ^^^ this
12:08:25 <Welkin> the question doesnt make sense
12:08:45 <Welkin> what is lifting the inner lambda?
12:09:05 * EvanR tells Welkin to go read about lambda lifting
12:09:07 <davean> Welkin: well, taking that lambda and lifting it?
12:09:09 <Welkin> what is lambda lifting at all?
12:09:11 <Welkin> never heard of it
12:09:19 <EvanR> its a thing
12:09:29 <CahC5ooz> Welkin: https://wiki.haskell.org/Lambda_lifting
12:10:10 <CahC5ooz> eeyun[m]: http://haskellbook.com/ or http://learnyouahaskell.com/ (last one is free for online reading)
12:10:21 <EvanR> why do you think the inner (\a -> a + x) cant be lifted
12:10:25 <davean> CahC5ooz: well, for one map isn't a primative.
12:10:55 <davean> CahC5ooz: that seems to make your question pointless unless you're talking theoretically
12:11:07 <eeyun[m]> CahC5ooz: thank you!!
12:11:34 <CahC5ooz> davean: that's just an example. Suppose it's some fn from another module. The point is it's compiled and we can't rewrite its body. Regardless of that, the question is mostly theoretical (not really haskell-specific), yes.
12:12:04 <EvanR> you wouldnt be rewriting its body anyway
12:12:23 <CahC5ooz> How so?
12:12:30 <azahi> is hackage down?
12:12:41 <cocreature> azahi: https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
12:13:39 <CahC5ooz> azahi: also, http://isup.me/hackage.haskell.org/
12:13:50 <EvanR> \x -> map (\a -> a + x) [...]   ===>  \x -> map (f x) [...] where f x a = a + x
12:14:00 <EvanR> doesnt require a rewrite of map itself
12:14:37 <EvanR> that where is not haskell where, it stands for putting f at top level
12:15:21 <EvanR> hence you removed the nested lambda
12:15:47 <CahC5ooz> EvanR: but (f x) would itself return a closure then... how's that different from (+ x)?
12:16:11 <EvanR> a lambda is a syntactic construct, a closure is a runtime object
12:16:13 <Welkin> there are no closures
12:16:47 <CahC5ooz> Given f x a = a + x, (f x) returns \a -> a + x; that's a closure, no?
12:17:10 <jle`> by closure, do you mean function?
12:17:11 <Welkin> a closure maintains state
12:17:13 <Welkin> there is no state here
12:17:21 <EvanR> \a -> a + x, by itself is wrong
12:17:21 <crestfallen> https://ptpb.pw/VpJE hi the flipExpr function required that I add deriving Show to folde. why is that?
12:17:26 <EvanR> x not found
12:17:40 <EvanR> at runtime, none of these notations work
12:17:48 <jle`> crestfallen: it probably doesn't
12:18:03 <jle`> also you can't derive Show for folde, you can only derive Show for types
12:18:06 <CahC5ooz> jle`: by closure I mean fn + env; EvanR: x is a free variable, obviously - because of that it's a closure, that's my point.
12:18:13 <EvanR> its not a free variable at all
12:18:27 <EvanR> you passed x in as a concrete value
12:18:32 <crestfallen> jle`, sorry let me update that paste
12:18:47 <Welkin> substitute the values like an algebraic equation
12:18:52 <EvanR> the original question was why it cant be lifted, but there it is
12:19:06 <Welkin> there is no environment
12:19:10 <Welkin> it just substitutes
12:19:22 <jle`> crestfallen: are you sure the error isn't happening when you try to show an Expr?
12:20:19 <dumptruckman> is there a package out there for creating a sandboxed ghci instance?
12:20:36 <EvanR> it removes nested lambdas. you seem to be referring to different (vague) things all as function/lambda/closure
12:20:36 <crestfallen> yes this is what I needed to get it working https://ptpb.pw/WrIV  jle`
12:20:43 <Welkin> dumptruckman: what does that mean?
12:20:52 <davean> dumptruckman: "sandboxed"? dumptruckman does "new-repl" do basicly what you want?
12:20:53 <Welkin> when you start ghci, it is already a fresh instance of it
12:20:54 <CahC5ooz> EvanR: I'm sorry, but I don't think you understood the question. When you pass a "concrete value" to a curried function, it creates a closure. In any case, I'm not here for arguing, so I guess I'll just ask the question again later.
12:21:07 <Cale> dumptruckman: There are a whole bunch of ways to get that to happen depending on what you want :)
12:21:08 <jle`> crestfallen: flipExpr shouldn't require it
12:21:37 <jle`> crestfallen: it should be required if you want to Show an Expr
12:21:41 <crestfallen> all the functions worked except flipExpr
12:21:45 <dumptruckman> I want to make a discord bot that can do haskell eval but obviously don't want people to be able to access my file system
12:21:50 <dumptruckman> or do other nasty things
12:21:52 <jle`> crestfallen: does that file compile?
12:22:00 <EvanR> me neither, lambda lifting can be applied there
12:22:16 <Welkin> dumptruckman: just install lambdabot
12:22:19 <Welkin> it's already all set up
12:22:29 <dumptruckman> oh
12:22:29 <jle`> CahC5ooz: i think you might be confusing lambda calculus with implementations of functional programming
12:22:31 <Welkin> https://github.com/lambdabot/lambdabot
12:22:32 <Cale> Welkin: someone added discord support to lambdabot?
12:22:38 <crestfallen> jle`, yeah. since flipExpr is the only one returning an Expr jle`
12:22:39 <Welkin> Cale: no, but someone can
12:22:45 <Cale> Okay :)
12:22:51 <jle`> CahC5ooz: lambda lifting is an abstract mathematical concept
12:22:55 <Welkin> I meant the bot is already written
12:22:59 <Cale> right
12:22:59 <dumptruckman> Then just installing it won't work
12:23:08 <EvanR> see the two bullet points on the wikipedia for Lambda_Lifting, thats all i did
12:23:11 <jle`> CahC5ooz: closures are a technique some programming languages use to for implementation
12:23:14 <Welkin> all you need to do is add a discord interface
12:23:14 <Cale> dumptruckman: lambdabot runs Haskell via a thing called mueval, iirc.
12:23:29 <dumptruckman> alright
12:23:35 <Cale> (well, I recall correctly for some point in history, but lots of changes have been made since I last looked at lambdabot)
12:23:39 <jle`> CahC5ooz: another connection might be something like (5 + 6), and asking how to add 5 and 6 without doing any bit manipulations
12:23:44 <jle`> s/connection/parallel
12:24:02 <Cale> But yeah, maybe just hacking on lambdabot itself would be easier than starting from scratch... possibly.
12:24:16 <jle`> the addition of 5 and 6 is a mathematical idea, and we can talk about it without invoking operational aspects of how a computer might compute it
12:24:26 <jle`> crestfallen: yes
12:24:32 <Welkin> or try mueval
12:24:32 <jle`> crestfallen: so flipExpr doesn't require Show to work
12:24:38 <Welkin> I don't know how much work that will be to set up though
12:24:44 <CahC5ooz> jle`: lambda lifting is both a "mathematical" concept and an implementation technique; see http://wiki.c2.com/?LambdaLifting or e.g. the wikipedia article
12:24:49 <Welkin> https://github.com/gwern/mueval
12:25:10 <crestfallen> jle`, it does compile, so it makes sense to you that it requires that deriving Show then ?
12:25:21 <jle`> crestfallen: flipExpr doesn't require deriving Show
12:25:26 <Welkin> lol, c2.com
12:25:55 <Cale> CahC5ooz: The usual distinction I draw is that things stop being closures once you can no longer separate the code and environment part of the pair.
12:26:09 <Cale> and instead are something that you used a closure to implement
12:26:12 <Cale> (usually functions)
12:26:27 <jle`> crestfallen: it should compile without deriving Show
12:27:00 <Cale> Since there's no way to tear apart a function like (+) 5 and see the 5 on its own or substitute it for something else, that's not quite a closure any longer, even if the compiler chooses to implement it by one (it may not)
12:27:46 <jle`> crestfallen: what are you doing that causes you to see the error?
12:29:13 <Cale> CahC5ooz: Often people from lisp-ish backgrounds like to confuse the implementation detail with the feature that's been implemented though, so you will hear people throw around the word "closure" when they effectively mean "function" or "procedure"
12:29:20 <crestfallen> jle`, I'm using ...
12:30:06 <Cale> (or even specifically for "function which happened to capture the values of variables which were in local scope when it was defined")
12:30:38 <crestfallen> i.e. λ > flipExpr (Add (Add (Val 3) (Val 5)) (Val 33))
12:30:45 <crestfallen> jle`,
12:31:01 <jle`> crestfallen: that in and of itself should be ok
12:31:11 <jle`> for example, try doing something like `x = flipExor ....`
12:31:11 <EvanR> im not sure its right to say that a higher order function returns a lambda, which is a syntax
12:31:13 <jle`> and that should be fine
12:31:26 <jle`> crestfallen: the problem happens when you do (show x)
12:31:26 <Cale> Haskell has a bit more graph-rewriting culture behind it, and so it's a little more unusual to give functions of that sort a special distinction.
12:31:33 <jle`> crestfallen: or when you do show (Val 3), even
12:32:02 <jle`> crestfallen: flipExor is fine as it is.  it's just when you try to show the result that you get a problem
12:32:10 <jle`> crestfallen: but this doesn't have to do with flipExor
12:32:24 <jle`> crestfallen: the same thing happens if you ghci> Val 3
12:32:32 <jle`> or ghci> Add (Val 3) (Val 3)
12:32:44 <jle`> the issue isn't with flipExpr, but in the display of Expr's
12:32:51 <Cale> Oh did he forget to add the deriving Show?
12:33:10 <jle`> they were wondering why flipExpr wouldn't work without deriving Show
12:33:20 <Cale> oh
12:33:23 <crestfallen> deriving Show allows the flip func to print
12:33:35 <jle`> and i was triyng to say that flipExpr isn't the problem
12:33:37 <Cale> right, it allows you to print trees
12:33:39 <crestfallen> but yeah its on the data constructor line
12:33:48 <jle`> crestfallen: note that you don't print flipExpr
12:33:52 <jle`> crestfallen: you flip the Expr that it gives
12:34:03 <crestfallen> sorry?
12:34:04 <Cale> It's just if the interpreter ever needs to display an Expr for you, it will need an instance of Show to do that
12:34:07 <jle`> you can *use* flipExpr just fine
12:34:11 <CahC5ooz> Cale: I'm not sure what you're talking about. ((+) 5) is a closure (it has 5 in its env). (+) is not. You can lift the f = ((+) 5) by rewriting all its call sites from e.g. f x to f 5 x. Obviously, "+" and "5" were used purely as an example; my question is not specific to any of this. Can we please stop arguing about what "closure" and "lambda lifting" are? Anyone interested can read the definition on the wiki.
12:34:17 <jle`> crestfallen: you never print the actual function
12:34:24 <jle`> you only print (flipExpr (Val 3)) etc.
12:34:29 <jle`> you print the Expr that the function returns
12:34:30 <Cale> CahC5ooz: ((+) 5) might be implemented by a closure, but that's up to GHC to decide.
12:34:42 <Cale> CahC5ooz: It might also just be an expression graph
12:34:47 <Cale> (like any other expression)
12:34:51 <jle`> crestfallen: so, flipExpr will work fine with or without a Show instance
12:34:58 <jle`> crestfallen: for example, try:
12:35:05 <[exa]> CahC5ooz: (+) may be a closure with hidden type argument
12:35:13 <Cale> Indeed, that too
12:35:14 <jle`> ghci> size (flipExpr (add (Val 3) (Val 2))
12:35:23 <jle`> crestfallen: ^ that should run fine, and show you the result
12:35:35 <jle`> crestfallen: that will work even if you have no Show instance for Expr
12:35:45 <jle`> so flipExor isn't the thing that requires Show
12:35:48 <Cale> (or a type class instance argument)
12:36:10 <CahC5ooz> Cale: as I've pointed out previously, my question (actually, 2 of them) isn't specific to GHC and the details of how it's implemented - it's a theoretical one. Therefore, I'm sorry, but that's not helpful at all.
12:36:18 <CahC5ooz> [exa]: ok, good to know.
12:36:27 <Cale> CahC5ooz: The thing is, it's an implementation detail whether ((+) 5) is implemented by a pair of some code and an environment mapping free variables in that code to values.
12:36:28 <jle`> CahC5ooz: that's the point -- closure is implementation-specific, not theoretical
12:36:38 <Cale> It's not such a pair from the programmer's perspective.
12:36:49 <kripto> Hey, looking to exchange $ for a fairly easy and small program, please PM me.
12:37:04 <crestfallen> ok yeah without minor typo it works. Cale said trees need the Show so I guess that is a tree because expressions are nested
12:37:12 <jle`> CahC5ooz: talking about closures is the implementation-specific thing. if your question is completely theoretical, closures aren't a part of the picture
12:37:23 <Cale> From the programmer's perspective, once you apply (+) to 5, there's no way to separate those things again.
12:37:29 <davean> CahC5ooz: The thing is you're conflating how you tihnk it works with the spec, which is very open
12:37:57 <[exa]> CahC5ooz: regarding your questions, 1] has a problem of what is a "compiled primitive", by this you usually mean some highly fragile syntactic sugar; there's not much of that in Haskell and in other languages that can be solved by simply wrapping it in a nullary function
12:38:02 <jle`> crestfallen: you just need Show if you want to display the result; flipExpr never displays any results to String, so it doesn't work
12:38:06 <jle`> er, so it should work
12:38:11 <jle`> flipExpr shouldn't require Show
12:38:37 <chessandgo> is hackage down or something? I'm unable to update my cabal list due to "cabal: Failed to download http://hackage.haskell.org/00-index.tar.gz : HTTP
12:38:40 <chessandgo> code 503
12:38:42 <jle`> chessandgo: hackage is down
12:38:53 <CahC5ooz> Cale: I didn't say anything about separating (+) and 5 after applying one to another, so I'm not sure how it's related.
12:38:53 <jle`> https://status.haskell.org/
12:38:54 <Welkin> yeah, someone broke it
12:39:02 <chessandgo> rip ;(
12:39:10 <Welkin> which is embarassing
12:39:10 <davean> CahC5ooz: you clearly have an assumption about how Haskell works. People are telling you "Your assumption is wrong", but you're responding "That doesn't conform to my assumption so it isn't helpful"
12:39:19 <Welkin> we are better than the npm crowd
12:39:24 <Cale> CahC5ooz: I'm giving that as evidence that it is not a closure from the programmer's point of view.
12:39:29 <davean> CahC5ooz: Until you consider what people are saying a bit more, I don't think you'll get anywhere
12:39:36 <Cale> CahC5ooz: If you had access to the actual closure, you could take them apart again.
12:39:38 <Welkin> oh my god
12:39:44 <Welkin> you are still arguing over the semantics of closures?
12:39:45 <Welkin> what!
12:39:52 <EvanR> Welkin what is this, programming language racism
12:39:53 <chessandgo> leftpad ;)
12:39:58 <Welkin> Cale: you have better things to do with your time
12:39:59 <sclv> chessandgo: you can change your config to point to one of the mirrors as per http://mail.haskell.org/pipermail/haskell/2018-January/025325.html
12:40:03 <yaxu> any word on when hackage might be back? I have a friend trying to set up a workshop in Equador, and another preparing a music performance, both trying to install tidal..
12:40:05 <CahC5ooz> [exa]: "compiled primitive" is something the body of which we can't rewrite; I've cleared it up in a subsequent message.
12:40:05 <sclv> (newer cabals fall back automatically)
12:40:20 <jle`> yaxu: installs should still work fine
12:40:31 <CahC5ooz> davean: my question has nothing to do with how Haskell is implemented, as I've pointed previously a couple of times.
12:40:38 <sclv> for cabals that aren't sufficiently new they manually need to set the mirror however
12:40:42 <Cale> CahC5ooz: Also, the compiler is free to inline the 5 into the definition of (+) and compile specialised code for that function rather than a closure
12:40:47 <Cale> CahC5ooz: So there's no way of knowing
12:40:48 <davean> Cale: Yes, but you're just wrong
12:40:53 <davean> er, CahC5ooz you're jut wrong
12:40:57 <Cale> haha
12:41:04 <EvanR> on the internet
12:41:08 <CahC5ooz> davean: wrong about what?
12:41:08 <[exa]> CahC5ooz: 2] that would be basically equal to inlining, not lifting
12:41:20 <davean> CahC5ooz: That it doesn't have anything to do with how its implimented.
12:41:22 <Welkin> CahC5ooz: if your question is not about haskell, then why are you asking it in here?
12:41:24 <yaxu> it's already quite difficult to install haskell + libraries on 32 bit windows on a whole bunch of machines in a cybercafe in equador
12:41:37 <sclv> yaxu: i'm sorry :-/
12:41:40 <sclv> working on it
12:41:41 <Cale> CahC5ooz: I don't even know what your original question was, but if it included the word "closure" everyone's going to think you're talking about language implementation details.
12:41:47 <sclv> but there's definitely an additional step for now
12:41:50 <Welkin> yaxu: install haskell platform
12:41:51 <[exa]> CahC5ooz: unrewriteable things don't exist (except for scheme maybe)
12:42:02 <Cale> And given that you're talking about it in #haskell, people will probably assume you're talking about language implementation details in Haskell.
12:42:15 <sclv> i think if you direct them to use the latest cabal (2.2) (which isn't with the platform yet) then it actually will fetch the mirror automatically via dns magic
12:42:19 <CahC5ooz> Oh, lots of noise. Can you guys (except for [exa]) just stop replying to me? Honestly, this isn't helping anyone, and it's turned into pure shitposting tbh
12:42:19 <sclv> even with cabal down.
12:42:20 <yaxu> @sclv thanks, sorry to grump, I do appreciate everything haskell
12:42:20 <lambdabot> Unknown command, try @list
12:42:24 <sclv> or rather even with hackage down
12:42:30 <Cale> Closures have nothing to do with anything programmer facing really -- they're just an underlying implementation detail for a bunch of related features.
12:42:35 <sclv> in the meantime its just changing one line in ~/.cabal/config
12:42:45 <Welkin> yaxu: https://www.haskell.org/platform/#windows
12:42:46 * sclv goes back to hacking on the recovery
12:42:46 <Cale> (and in any given application of them, there are other approaches which might be taken in general)
12:42:50 <jle`> yaxu: the main thing affected is the online docs, but you can use stackage docs for now
12:42:59 <EvanR> the question is, "is the reason lambda lifting cant be done to \x -> map (+x) [...]  because map is a compiled primitive"
12:43:01 <jle`> yaxu: and for your original question, it will most likely be down for the rest of the day
12:43:08 <Welkin> once you install haskell platform. you can upgrade cabal (if you need to)
12:43:16 <gentauro> Is Haskell.org down? https://hackage.haskell.org/package/base/docs/Data-Ratio.html
12:43:22 <jle`> gentauro: no, just hackage
12:43:25 <Cale> gentauro: Hackage in particular is down
12:43:31 <jle`> can we update the /topic, maybe, heh
12:43:31 <Cale> It's really really annoying
12:43:31 <gentauro> OK
12:43:32 <crestfallen> Weird, I get the error without it. but thanks jle` Cale alot
12:43:37 <CahC5ooz> [exa]: yes, I believe it's much closer to inlining. So, my question was is this always possible (I guess yes, for the reasons stated in the first message) and why people don't seem to use it much?
12:43:41 <jle`> it's the second person to ask in the past minute
12:43:48 <jle`> crestfallen: the error isn't from flipExor
12:43:53 <gentauro> jle`: it has been down the hole day
12:43:54 <jle`> crestfallen: the error is from when you Show the answer
12:43:57 <gentauro> I thought i was my connection
12:43:57 <jle`> gentauro: yes
12:44:04 <jle`> it has been down for about 12 hours now
12:44:18 <jle`> current estimates say it will be down for the rest of the day
12:44:25 <gentauro> Roger that
12:44:28 <EvanR> luckily i purchased the hackage DVD and i am not affected
12:44:29 <crestfallen> jle`, is that because a tree structure requires that ?
12:44:32 <jle`> crestfallen: no
12:44:45 <jle`> crestfallen: it is because showing Expr requires it
12:44:47 <yaxu> @Welkin yes that needs 32 bit windows version which isn't there, tried with an old version but somehow couldn't get the c compiler to work - that step where you have to edit a difficult to locate file for an unclear reason wasn't working
12:44:47 <lambdabot> Unknown command, try @list
12:44:51 <jle`> that's how showing works in Haskell
12:44:56 <[exa]> CahC5ooz: inlining usually makes your code literally explode in size, which is not very popular if a] evaluating code takes run-time b] optimizing it back is NPC
12:45:03 <chessandgo> sclv: this link, http://mail.haskell.org/pipermail/haskell/2018-January/025325.html , seems to be talking about a different issue, and doesnt list mirrors. Unless im reading it wrong
12:45:05 <jle`> if you want to 'print out' or display a value, it needs to have a Show instance
12:45:06 <yaxu> anyway we'll get through it..
12:45:16 <Cale> CahC5ooz: It's usually weird to lambda lift out free-variables which are still in scope at the top level.
12:45:22 <Cale> CahC5ooz: You can certainly do it...
12:45:35 <sclv> oh whoops
12:45:52 <crestfallen> so the value returned is more complex than an Int, say, and ghc
12:45:57 <sclv> https://mail.haskell.org/pipermail/haskell-cafe/2018-April/128913.html
12:46:00 <crestfallen> requires it
12:46:01 <Cale> But there's not much advantage to turning that into  \map -> \(+) -> \x -> map (+x) [...]  or whatever
12:46:06 <jle`> crestfallen: complexity doesn't matter
12:46:11 <sclv> an admin should update the topic i guess
12:46:13 <jle`> crestfallen: even Int requires a Show instance to print :)
12:46:18 <Cale> when you're just going to immediately apply it again
12:46:26 <jle`> crestfallen: every value, no matte rhow simple, requires an instance of Show
12:46:28 <EvanR> so they were really asking about inlining...
12:46:30 <jle`> if you want to print it
12:46:50 <EvanR> explaining the relevant of map being primitive or not
12:46:56 <crestfallen> sorry, than why is it explicitly required in this case?
12:47:01 <crestfallen> then*
12:47:06 <jle`> crestfallen: it is not explicitly required in this case
12:47:11 <jle`> it is only required if you want to show the result
12:47:19 <Cale> CahC5ooz: When you want to lift something outward, you only care about parameterising over the things which will no longer be in scope.
12:47:23 <jle`> crestfallen: the file you have itself never shows the result
12:47:29 <Welkin> yaxu: https://www.haskell.org/platform/prior.html
12:47:31 <jle`> so the file and source code do not require deriving Show
12:47:32 <[exa]> CahC5ooz: btw there's a nice reading on inlining/dropping and related considerations/efficiency from O.Danvy (kindof outdated now, but still illustrative)
12:47:37 <Welkin> yaxu: 32-bit windows releases are all there :)
12:47:44 <jle`> crestfallen: however, if you want to show *any* Expr, then you need a Show instance
12:48:09 <jle`> crestfallen: so, nothing in the actual file you have requires Show
12:48:22 <jle`> crestfallen: however, if you load up ghci and want to print an Expr in your repl, it'll require Show
12:48:34 <jle`> whether or not the expr you made was defined using flipExpr
12:49:04 <jle`> for example, this causes the same error:
12:49:10 <jle`> ghci> Add (Val 3) (Val 5)
12:49:24 <jle`> if you just type in a value in ghci, it'll attempt to Show the result
12:49:25 <zdw> I'm having trouble getting to hackage.haskell.org - I get a 503 error.
12:49:30 <jle`> zdw: yes, hackage is down
12:50:02 <gentauro> jle`: they should probably change the topic of the channel ;)
12:50:04 <zdw> Ah, thanks, glad it's not only me.  Any reason why?
12:50:12 <gentauro> cos we all come and ask the same :)
12:50:14 <jle`> there was an incident
12:50:25 <crestfallen> ok I'll chew on that many thanks. also .. why did the book choose to name the function folde. does that recursion act as a fold?
12:50:37 <Cale> Effectively yeah.
12:50:38 <CahC5ooz> [exa]: yes, the explosion is a thing (iirc lambda to SK is quadratic in number of terms); on the other hand, I was thinking about compiling to a stack-based IR anyway, and I believe you can optimize away many of the overhead with pretty simple rules. So, other than that, do you think there are other (bad) things to be considered? Also, re Danvy - are you referring to "Defunctionalization at Work" or some other paper?
12:50:44 <Cale> I would have called it foldExpr
12:50:45 <jle`> crestfallen: probably because it's 'collapsing' the Expr down into a single value
12:51:00 <Cale> You can look at foldr as an instance of the same thing
12:51:24 <Cale> foldr cons nil replaces each (:) in the construction of a list with cons, and the [] at the end (if any) with nil
12:51:25 <crestfallen> got it thanks kindly jle` Cale
12:51:38 <jle`> no problem :)
12:51:49 <jle`> crestfallen: one thing you might consider is that there is no native reflection in haskell
12:51:59 <crestfallen> pardon?
12:52:00 <jle`> once things are compiled, there is no way to inspect the data type itself
12:52:08 <jle`> for things like the name of its constructors
12:52:11 <jle`> what its type is
12:52:13 <jle`> etc.
12:52:13 <dumptruckman> how exactly do i search for packages on hackage.fpcomplete.com?
12:52:23 <jle`> and for ghc, at runtime, it's just a blob of bytes
12:52:28 <Cale> (except for the at least two and perhaps more ways that people have cooked up and GHC has support for)
12:52:32 <Cale> lol
12:52:34 <chessandgo> sclv: that seemed to work, thanks!
12:52:54 <jle`> crestfallen: so if you just have a "Expr" value, it's just a blob of bytes...how would ghc know what to print out?
12:52:59 <jle`> that's what the Show typeclass is for
12:53:17 <jle`> it augments the type with 'showing' abilities
12:53:35 <EvanR> it might not even be a blog of bytes
12:53:36 <jle`> without this ability, the all you have is a blob of amorphous bytes
12:53:40 <EvanR> ()
12:53:42 <EvanR> Void
12:53:49 <jle`> indeed :)
12:53:57 <crestfallen> right, because Val is just verbage and not numeric or a string ?
12:53:57 <EvanR> RealWorld#
12:54:04 <jle`> crestfallen: even numeric and string
12:54:08 <jle`> need Show instances
12:54:20 <crestfallen> but they're built in right?
12:54:21 <[exa]> CahC5ooz: defunctionalization will be great for you if youre targeting stack; but there's also "lambda dropping" paper
12:54:29 <[exa]> hope that's from danvy
12:54:41 <jle`> crestfallen: their Show instances aren't necessarily built into the compiler, they're provided as a part of the base libraries
12:54:43 <dumptruckman> does someone know how to view hackage packages on a mirror?
12:54:45 <jle`> written within the language
12:54:53 <jle`> dumptruckman: you can use a hackage doc mirror like stackage
12:55:11 <crestfallen> got it. thanks kindly. I need to split . pax
12:55:20 <Cale> crestfallen: They're pretty close to built-in, though actually implemented in terms of some lower-level things available in GHC.
12:55:21 <jle`> crestfallen: so it's not quite "built in" to the language, it's just a normal library module that provides it
12:55:39 <EvanR> the Show class is assumed to exist in e.g. ghci
12:56:47 <c_wraith> sure, but ghci isn't part of the language spec.
12:56:55 <[exa]> CahC5ooz: danvy, schulz: lambda dropping: .... TCS, (2000)
12:57:05 <EvanR> the spec assumes it exists :)
12:57:21 <EvanR> i was ignoring the spec though
12:57:22 <jle`> Show and its instances might be magically built into the compiler, but that within the language, they are indistinguishable from normal user-defined typeclasses and instances
12:57:36 <crestfallen> thanks ALL. gotta go
12:57:41 <jle`> happy haskelling!
12:57:42 <jle`> aw
12:57:56 <EvanR> really... why do they need to be built in?
12:58:00 <c_wraith> yeah, the spec does require the existence of Show, Read, Ord, Eq, and a few others.
12:58:11 <jle`> by might i meant "might possibly"
12:58:47 <c_wraith> basically, anything the spec requires to be derivable must be built in some way or another.
12:59:14 <EvanR> i see the deriving must be built in as such
12:59:32 <EvanR> but not the definition of Show and standard instances
12:59:32 <CahC5ooz> [exa]: yep, yep, I've found it! Thanks a lot for the pointers, I'm reading it already. :) (btw, I've almost left the channel, frustrated, so that's a double thanks from me, haha)
12:59:34 <geekosaur> but in theory could be done by a preprocessor step
13:00:08 <EvanR> deriver must assume it exists though
13:00:54 <geekosaur> deriver can already explode in various situations, so being built in isn't a sinecure
13:02:05 <nshepperd1> ghci needs to know about Show
13:02:05 <[exa]> CahC5ooz: kindof hoping your source language is not haskell; trying to lower haskell by scheme-targeted tools is, say, brutal
13:02:27 <geekosaur> even ghci is overrideable
13:02:35 <[exa]> (which is what the people above have probably tried to say)
13:03:06 <geekosaur> but ghci's a convenience, not part of the language as such
13:05:08 <gentauro> how would you represent Church Numerals in binary? De Bruijn notation?
13:05:14 <EvanR> can ghci do color somehow yet
13:05:39 <Cale> gentauro: Well, can you imagine writing an algebraic data type for binary numbers?
13:05:52 <gentauro> EvanR: I like how the new stack has colors
13:06:01 <Cale> gentauro: Generally the Church encoding is just to take the constructors to be parameters of a lambda
13:06:15 <EvanR> gentauro: http://www.cse.unt.edu/~tarau/research/slides/slides_ictac14.pdf
13:06:23 <geekosaur> error messages have colors. it doesn't do syntax colors as you type
13:06:36 <Cale> gentauro: So if you had something like data Bin = Z | O Bin | I Bin
13:06:46 <geekosaur> someone would have to do a lot of work on haskeline for that
13:07:02 <EvanR> i just want colored output
13:07:23 <Cale> gentauro: then you could Church encode a term of that like  O (I (O (O (I Z)))) as (\z o i -> o (i (o (o (i z)))))
13:08:23 <gentauro> Cale, my approach is that I represent it as a string of only two operations
13:08:34 <EvanR> ah i thought "binary" meant, "on disk" or something
13:08:38 <CahC5ooz> [exa]: nah, source is my (purely imaginary at the moment) toy lang, which I use mostly as an excuse to explore stuff; I've clarified that the question wasn't about Haskell, but I guess that was too late, heh. Bad timing in general.
13:08:54 <[exa]> :D
13:08:59 <EvanR> the question was also not about lambda lifting
13:09:24 <Welkin> are we still on this?
13:09:30 <gentauro> 1 Cale 1 is for double the number and 0 is for succesor (both easy to implement with LC)
13:09:43 <Welkin> it has been over one hour
13:10:08 <Cale> gentauro: Well, you could use the same encoding I just gave and reinterpret the O and I constructors that way
13:10:56 <Cale> gentauro: You might prefer to make O and I be (\n -> 2*n) and (\n -> 2*n+1) though.
13:11:09 <Cale> (but of course it doesn't entirely matter)
13:11:56 <gentauro> Cale, I don't rely on operations, just pure LC ;)
13:12:28 <Cale> gentauro: Yeah, it only matters insofar as what you need to do to implement arithmetic
13:13:10 <EvanR> gentauro: that natural number structure i linked is really cool, comes with all the operations exception division, which isnt bad to write yourself
13:13:16 <Cale> gentauro: I would generally recommend writing things using algebraic datatypes first, and then figuring out how to translate to pure lambda calculus. It's easier to have that structure there to guide you into doing sensible things.
13:14:48 <Cale> gentauro: You can write something like
13:15:15 <Cale> foldBin z o i = f where f Z = z; f (O n) = o (f n); f (I n) = i (f n)
13:15:51 <Cale> and that is more or less a translation from the algebraic data type to the Church representation
13:16:11 <Cale> (though with the arguments swapped a little for that description)
13:16:11 <gentauro> yes
13:16:19 <gentauro> how do you represent that in Binary?
13:16:36 <jle`> Binary like, the library?
13:17:00 <gentauro> I mean, I represent 19 like this [False,True,True,True,False,True,False] (0111010)
13:17:08 <jle`> oh
13:17:15 <jle`> if you mean that kind of binary, then yes, it's already binary
13:17:45 <jle`> do you mean like a binary string?
13:17:53 <jle`> of 1's and 0's or True's and False's?
13:18:06 <gentauro> where, as mentioned before, 0 are "succ" and 1 are "double"
13:19:14 <gentauro> "double" -> mult (two      ) -> succ (succ zero) & mult = \m n f ->       m   (n f  )
13:19:51 <gentauro> I'm just looking into persiting LC to a string using (binary)
13:20:09 <Cale> Prelude> foldBin 0 succ (2*) (O (I (O (I (I (I (O Z)))))))
13:20:09 <Cale> 19
13:20:43 <Cale> So (\z o i -> o (i (o (i (i (i (o z)))))))
13:20:52 <Cale> would be the Church encoding
13:21:03 <Cale> > (\z o i -> o (i (o (i (i (i (o z))))))) 0 succ (2*)
13:21:06 <lambdabot>  19
13:21:23 <gentauro> Cale: Yes, how do you store that in "binary"? (only using 0 and ones?)
13:21:29 <gentauro> like the LC expression
13:21:32 <Cale> I'm not sure I understand
13:21:56 <gentauro> Yeah, I should probably just make a GIST
13:22:03 <Cale> You want a way to convert arbitrary lambda terms into binary?
13:22:21 <Cale> Or just the ones which are these encodings of binary numbers?
13:22:27 <gentauro> Cale: Not arbitrary, only Church Numerals
13:22:28 <Cale> We can produce the string just as easily...
13:22:50 <Cale> Well, except that 'succ' is a bit tricky, because we have to implement carries :)
13:23:12 <Cale> Oh, like traditional Church numerals?
13:23:21 <gentauro> My current approach is that all numbers can be made with "succ" and "double" (just "mult" and "two")
13:23:40 <gentauro> succ = \  n f -> \x ->   f (n f x)
13:23:48 <gentauro> mult = \m n f ->       m   (n f  )
13:23:50 <Cale> It's easier if you use 2n+1 and 2n
13:23:57 <gentauro> zero = \    f -> \x ->          x
13:24:04 <Cale> because those correspond directly to bits
13:24:11 <Psybur> head = succ . unzip
13:24:21 <gentauro> Cale: It sure is, but for that I'm not using "pure" LC
13:24:27 <Cale> hm?
13:24:36 <gentauro> operations and types imply CONS right?
13:24:44 <Cale> I just mean, if you interpret your pure lc stuff that way
13:25:17 <gentauro> I'm not doing anything that isn't been done before
13:25:57 <gentauro> I'm just trying to represent the "pure" LC in a binary string. Example 19 is "0111010" with my approach
13:26:28 <Cale> Sure, so I'll leave it to you to implement (however you want) binary successor with carry
13:26:59 <gentauro> so reading back the string would be: "zero", then "succ", then "double" and so on
13:27:21 <Cale> The key is, if you know how you want to implement Z, I and O, you just plug in whatever functions you like, and you get the result
13:27:42 <Cale> as arguments to the Church-encoded-binary-number
13:27:58 <Cale> So you can put in functions which manipulate strings of bits somehow
13:27:59 <gentauro> Cale: I will try to make a GIST and post it
13:28:34 <jle`> i love me a good G.I.S.T.
13:29:07 <Welkin> jle`: ghist or jist?
13:39:30 <tdammers> Welkin: same as "gif"
13:39:44 <Welkin> tdammers: so, hard g
13:39:55 <tdammers> Welkin: who knows
13:39:58 <MarcelineVQ> geef?
13:40:16 <Welkin> the g part is short for "graphics"
13:40:22 <Welkin> so of course it is a hard g
13:40:27 <tdammers> jraphics
13:40:30 <MarcelineVQ> jeef, jiff, nutella
13:40:30 <Welkin> the creator of the gif format is just a troll
13:40:52 <geekosaur> lotta guff over gs
13:41:07 <geekosaur> (geeze...)
13:41:13 <Welkin> lol
13:41:19 <Welkin> even wikipedia says it is a hard g!
13:41:19 <Welkin> https://en.wikipedia.org/wiki/GIF
13:41:54 <gentauro> Cale: https://gist.github.com/gentauro/dc461a9046bb512e845e5c847a6e090e
13:41:58 <le_frogballs> anyone know when hackage is gonna be back up?
13:42:05 <gentauro> Cale: I don't know if it gives any sense ...
13:42:06 <Welkin> LOL
13:42:08 <Welkin> "Steve Wilhite says that the intended pronunciation deliberately echoes the American peanut butter brand Jif, and CompuServe employees would often say "Choosy developers choose GIF", spoofing this brand's television commercials."
13:42:14 <Welkin> so they *are* trolls
13:42:58 <Welkin> le_frogballs: a day, a week, a year? who can say?
13:45:04 <Cale> gentauro: You want to implement that algorithm in pure LC?
13:45:22 <MarcelineVQ> What a useful response.    le_frogballs: if you don't find an answer here try asking in #hackage (I think)  in case someone there knows the story
13:46:41 <EvanR> still on a search for the one true pronunciation?
13:46:56 <Cale> le_frogballs: "Expect up to a day of disrupted service while we get things back in order. Really sorry about the inconvenience."
13:47:05 <Cale> https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
13:47:25 <EvanR> if a word when said results in a protracted pointless discussion tangent, it has failed its communication mission. and cant be fixed, it must be destroyed
13:47:57 <EvanR> use vs mention
13:48:31 <Welkin> EvanR: menschen?
13:48:45 <gentauro> Cale: Well I came up with that algo just for pure LC ;)
13:49:07 <gentauro> but I'm reading the slides you sent me atm
13:49:13 <gentauro> so I might change opinion
13:51:33 <EvanR> gentauro: you can enclosed that tree rep, which is balanced parens, with just 0 and 1. but its not obvious what the 0 and 1 represent
13:53:13 <EvanR> but the tree is pretty obvious, it basically allows your ops but with a shift of more than 1
13:53:18 <le_frogballs> Cale: preciate it
13:54:01 <EvanR> 10010001
13:54:24 <EvanR> 0 1 0 2 0
13:54:36 <EvanR> () 1 () 10 ()
13:54:36 <gentauro> EvanR: by using a number 2
13:54:50 <gentauro> you aren't limiting to binary (only 0 and 1)
13:54:51 <Welkin> who does number 2 work for!?
13:55:00 <EvanR> () (()) (0 0) ()
13:55:07 <EvanR> () (()) (() ()) ()
13:55:24 <gentauro> EvanR: are we now coding LIPS? :)
13:55:31 <gentauro> with all those parenthesis ;)
13:55:38 <EvanR> maybe you missed my slides link
13:56:26 <gentauro> EvanR: so it was you? I'm looking into them
13:57:22 <EvanR> it gives a 1 to 1 mapping between numbers and multiway trees
13:57:46 <EvanR> which hereditary in that children only consist of encodings of previous numbers
13:57:51 <EvanR> is hereditary*
13:58:01 <EvanR> also you can do arithmetic on it
13:59:07 <EvanR> the hereditary could be used in a DAG rep in memory
13:59:47 <EvanR> which only has 1 copy of any number
14:00:14 <EvanR> which consists of just the pointers to children
14:00:31 <EvanR> yeah sounds like peano... but its not
14:01:32 <dumptruckman> hmm.. if i have a cabal file for this project and no stack.yml, and a library says to cabal install it, but i don't have a cabal command on the path, what do i do?
14:01:35 <dumptruckman> I just have stack
14:02:14 <Welkin> dumptruckman: install cabal
14:02:17 <Welkin> cabal-install
14:02:22 <Welkin> seriously, drop stack
14:02:29 <Welkin> it's obsolete and only causes issues
14:02:32 <Welkin> it uses Cabal anyway
14:02:36 <Welkin> just use cabal directly
14:02:49 <dumptruckman> wat
14:02:55 <Welkin> also, use cabal new-*
14:02:57 <dumptruckman> I thought it was the other way around
14:02:58 <Welkin> for nix-style builds
14:02:59 <Welkin> no
14:03:15 <Welkin> https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
14:03:16 <dumptruckman> i'm on windows
14:03:31 <Welkin> if you installed haskell platform, you have cabal installed
14:03:45 <dumptruckman> i installed stack
14:03:50 <dumptruckman> i do not have cabal installed
14:03:53 <Welkin> https://www.haskell.org/platform/
14:03:57 <Welkin> install haskell platform
14:03:59 <gentauro> Welkin: I installed stack with curl and from that it just works ;)
14:04:26 <gentauro> I mean, it works all the times
14:04:49 <gentauro> which was not always the case with cabal (I hated the broken dependencies)
14:05:04 <Welkin> that doesnt exist any more
14:05:17 <Welkin> you could always solve that using sandoxes anyway, long before stack
14:05:24 <Welkin> now we have cabal new-*
14:05:32 <Welkin> sandboxes*
14:10:30 <dyl> Does new do anything sandbox related?
14:11:43 <Welkin> it creates nix-style builds
14:11:45 <Welkin> so yes
14:11:50 <Welkin> it is sandboxes, but better
14:18:47 <gentauro> EvanR: Wow, thx for the slides
14:18:52 <gentauro> much better approach !!!
14:29:19 <dyl> Excellent
14:29:38 <dyl> Welkin: before sandboxes I was (tongue in cheek) lobbying for a cabal nuke command
14:29:56 <dyl> It nukes your cabal haha.
14:30:43 * Clint squints.
14:36:02 <EvanR> gentauro: the paper is better, if you can find it
14:40:17 <gentauro> EvanR: -> http://www.cse.unt.edu/~tarau/research/2014/
14:42:04 <EvanR> the title of the paper is "the arithmetic of recursively run length encoded natural numbers"
14:42:15 <EvanR> i see you found some related work by the same dude
14:45:34 <gentauro> EvanR: The link was in the last page of the slides
14:45:53 <EvanR> yeah i think i found that
14:46:01 <EvanR> i also found the paper for free >:)
14:50:18 <chessandgo> what is "libHSth-abstraction", im getting an error related to it not existing while trying to build Aeson. I cleared out my packages in my .cabal folder to see if thatd help the mirror error
15:00:35 <geekosaur> that just breaks things, ~/.ghc is the one that matters
15:01:12 <Welkin> chessandgo: how are you building?
15:01:22 <Welkin> are you using `cabal build` or `cabal new-build`?
15:03:09 <gentauro> EvanR: "i also found the paper for free" where? I tried to google it and nothing :(
15:06:07 <chessandgo> Welkin: just using cabal install, although ive started installed the dependancies one by one and it seems to be progressing now
15:06:45 <Welkin> cheejust use cabal new-build
15:06:51 <Welkin> chessandgo: ^
15:07:27 <Welkin> did you `cabal configure` before building?
15:07:34 <Welkin> with cabal new-build I believe that is not necessary though
15:09:01 <chessandgo> havent done that, I think it just has to do with outdated depencances
15:09:07 <chessandgo> is there a command to rebuild everything?
15:12:38 <Welkin> chessandgo: yes, use cabal new-build
15:12:44 <Welkin> see if that works
15:20:36 <chessandgo> Welkin: Ive seem to have gotten It (not sure if it was fiddling with cabal or because I downloaded some depencies with my distros package manager
15:20:36 <suzu> how do i get GHC to choose the more specific of these two instances?
15:20:39 <chessandgo> gtg tho
15:20:48 <suzu> instance ToJSValue a => JsTypeable (IO a) where instance (ToJSValue a, ToJSValue b) => JsTypeable (IO (JsPromise a b)) where
15:21:05 <suzu> err, JsTypeable (IO a) vs JsTypeable (IO (JsPromise a b))
15:25:52 <jle`> "you can't"
15:26:22 <jle`> this is not something you should be relying on
15:26:46 <jle`> i'd consider it an abuse of typeclasses
15:27:13 <jle`> and a good sign that you might be approaching the problem from the wrong angle
15:27:35 <suzu> alright
15:27:55 <suzu> hmm\
15:28:12 <jle`> it might be possible to hack something together, but anything you do will probably cause more headaches down the line
15:28:53 <jle`> i speak from experience :)
15:28:53 <Welkin> typeclasses are evil
15:29:02 <suzu> i think i know how to solve this differently/better
15:29:31 <suzu> so i'll abandon this strategy lol
15:31:52 <jle`> an angel just got its wings
15:32:37 <suzu> can i differentiate the typeclass instance for `IO a` based on typeclass constraints on `a`?
15:32:55 <jle`> also a bad idea
15:32:57 <suzu> GHC picks an instance first, then resolves the constraints, doesn't it
15:33:05 <jle`> yes
15:33:05 <suzu> and will not backtrack
15:33:21 <jle`> there might be a way to hack this to work, but again, same problems and evil down the road :)
15:34:55 <suzu> is there a way i can define a new type that is a monad and works exactly like IO, but constraints the result type against a typeclass?
15:35:25 <suzu> and preferably doesn't require lifting IO actions into it all the time
15:35:42 <jle`> you can write a newtype wrapper around IO
15:36:03 <jle`> and it dpeends on what you mean by constrain the result type
15:36:23 <jle`> also it isn't possible to have a Monad over a limited subset of types in Haskell
15:36:28 <suzu> newtype MyNewIO = SomeClass a => MyNewIO { unNewIO :: IO a }
15:36:41 <jle`> yes but why do you want the constraint?
15:37:05 <jle`> it isn't possible to have a Functor over a limited subset of types in haskell, since fmap :: forall a b. (a -> b) -> X a -> X b
15:37:15 <suzu> ah i see
15:37:17 <jle`> so you should be able to fmap (const Y) over anything, where Y is a value of any type
15:37:19 <jle`> suzu: why not just:
15:37:26 <jle`> newtype MyNewIO = MyNewIO { unNewIO :: IO a }
15:37:44 <jle`> and just constrain the functions that use it
15:37:50 <jle`> kind of like how Data.Map works
15:37:50 <suzu> i could do that. but then you need to wrap regular IO actions up
15:37:58 <jle`> yes
15:38:01 <jle`> what is your actual problem?
15:38:28 <suzu> i am writing a library that will accept some user provided functions
15:39:19 <suzu> if they are of type a -> b -> c -> IO d, where 'd' has a from/tojson, then that will be accepted
15:39:59 <suzu> however, i want the user to be able to provide a function of a -> b -> c .. -> IO (Promise d), which will be evaluated differently to get the `d`
15:40:26 <jle`> why don't you just provide a different function for normal functions and promise'd functions
15:40:47 <jle`> takeNormalFunction :: FromJSON d => (a -> b -> c -> IO d) -> ...
15:40:59 <jle`> takePromiseFunction :: (a -> b -> c -> IO (Primise d)) -> ...
15:41:34 <suzu> yes, that could work
15:41:47 <suzu> i should also mention that it will take a function of any desired arity
15:42:00 <suzu> to do that i have some typeclass shenanigans
15:43:43 <suzu> i think i will take a look at splitting it into two functions though
15:43:45 <suzu> thanks
15:43:47 <suzu> !
15:43:50 <jle`> no problem :)
15:44:03 <jle`> splitting functions is probably also better for the user too
15:44:28 <jle`> if there was a ToJSON/FromJSON instance for Promise d, how would they specify what behavior they want?
15:45:15 <glguy> Anyone know why this typeintype using code doesn't check? https://gist.github.com/glguy/d4f50314cc1e86c34790c2a14b411f2f
15:49:25 <dexter1> is hackage down?
15:49:33 <Welkin> lol
15:54:22 <geekosaur> https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
16:11:59 <ttwoo2> How can I print strings to the console using GHCJS?
16:13:46 <jle`> putStrLn
16:17:21 <jle`> ttwoo2: all the stdout handles go to the console
16:17:29 <ttwoo2> Thanks
16:17:34 <jle`> and stderr too
16:17:48 <ttwoo2> How do I determine which module to import to use putStrLn from GHCJS?
16:17:56 <jle`> it should be available in Prelude
16:18:11 <jle`> import Prelude
16:18:38 <jle`> (this line shouldn't be necessary because Prelude is imported by default, unless you have -XNoImplicitPrelude enabled)
16:19:12 <jle`> putStrLn from Prelude prints to stdout, and stdout in ghcjs is the console
16:19:17 <jle`> *in the ghcjs runtime
16:20:11 <ttwoo2> It worked! Thanks so much!
16:20:15 <jle`> no problem :)
16:20:31 <ttwoo2> Is that using the FFI?
16:20:57 <jle`> putStrLn is the same putStrLn in normal ghc/haskell
16:21:13 <jle`> the difference is where the runtime points stdout/stderr to
16:21:18 <ttwoo2> Ah right, its only stdout and stderr that change
16:21:24 <ttwoo2> Gotcha
16:21:27 <jle`> to the haskell program it's all the same
16:21:37 <jle`> the runtime gets to pick where they go after it's done, yeah
16:33:52 <Xal> is hackage down right now?
16:33:59 <jle`> yes
16:34:02 <glguy> https://status.haskell.org/
16:34:05 <Welkin> lololol
16:34:49 <Xal> aaaaaaaaaaaaaaa I can't live without hackage
16:35:17 <jle`> installs should still work
16:35:29 <jle`> documentation for most packages are up at stackage :)
16:35:41 <Welkin> learn to build docs yourself
16:35:45 <Welkin> local docs > *
16:36:19 <jle`> LocalDocs > _ = True
16:36:40 <glguy> local docs > Type
16:36:43 <Welkin> it could be a css selector
16:44:47 <taktoa> what function should I use if I want to unsafely convert `IO a` to `forall s. ST s a`? just `unsafePerformIO`, or is there something else that is preferable?
16:45:12 <taktoa> er, `pure . unsafePerformIO`
16:45:22 <hpc> unsafeIOtoST or something like that
16:45:30 <taktoa> what module is that defined in?
16:45:35 <hpc> one of the ST modules
16:45:38 <taktoa> I've only seen `stToIO`
16:46:01 <hpc> ah right hackage is down
16:46:07 <hpc> @hoogle stToIO
16:46:07 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
16:46:07 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
16:46:07 <lambdabot> Control.Monad.ST.Lazy.Safe stToIO :: ST RealWorld a -> IO a
16:46:12 <hpc> @hoogle unsafeIOToST
16:46:13 <lambdabot> Control.Monad.ST.Lazy.Unsafe unsafeIOToST :: IO a -> ST s a
16:46:13 <lambdabot> Control.Monad.ST.Unsafe unsafeIOToST :: IO a -> ST s a
16:46:13 <lambdabot> Control.Monad.ST.Lazy.Unsafe.Compat unsafeIOToST :: IO a -> ST s a
16:46:16 <hpc> aha!
16:46:20 <taktoa> thanks!
16:48:03 <hpc> (standard disclaimer, this is exactly as unsafe as unsafePerformIO because each can be defined in terms of the other)
16:53:24 <Elorm[m]> Hi.
16:53:26 <Elorm[m]> Is Hackage down for anyone else ?
16:53:49 <Welkin> yes ye and yes
16:54:18 <Elorm[m]> Is this a planned downtime if I may ask or something happened
16:54:25 <glguy> You can look at the status page https://status.haskell.org/
16:54:39 <Elorm[m]> Also can I get a mirror or something ?
16:54:57 <Elorm[m]> Oh OK. Thanks
16:54:57 <davean> Elorm[m]: there are several mirrors - modern cabals will automaticly use them
16:55:27 <Elorm[m]> I'm a dinosaur :(
17:02:30 --- mode: ChanServ set +o glguy
17:02:30 --- mode: glguy set +b *!*@2a03:b0c0:1:d0:*
17:02:37 --- kick: H0YPWTTicho_ was kicked by glguy (spam)
17:03:20 --- kick: clampy was kicked by glguy (same network)
17:06:48 <ddellacosta> Elorm[m]: more here: https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
17:07:40 <fishythefish> maybe we should have a channel entry message
17:26:06 <Elorm[m]> > Elorm[m]: more here: https://www.reddit.com/r/haskell/comments/8bofby/unplanned_hackage_downtime/
17:26:07 <Elorm[m]> Thanks. Is reddit the go to place for Haskell  info now ? Just asking cause I don't use social media much
17:26:09 <lambdabot>  <hint>:1:98: error:
17:26:09 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
17:26:11 <statusbot> Status update: The hackage restore has been time-consuming but is going well. We anticipate hackage will be operational again within the day. Thank you for your patience. -- http://status.haskell.org/pages/incident/537c07b0cf1fad5830000093/5acf0988f84e8204e95a4c47
17:27:15 <Iceland_jack> Advertising the -XDerivingVia proposal https://github.com/ghc-proposals/ghc-proposals/pull/120
17:27:26 <Iceland_jack> Paper: https://www.kosmikus.org/DerivingVia/deriving-via-paper.pdf
17:29:46 <ddellacosta> Elorm[m]: I wouldn't say it's the only place, but it's _a_ place you can find a lot of community news and communication.
17:30:25 <ddellacosta> Elorm[m]: for example, Gershom also posted that notice to the mailing list: https://mail.haskell.org/pipermail/haskell/2018-April/025416.html
17:30:37 <ddellacosta> I just tend to spend more time on that subreddit, so...
17:34:28 <lyxia> https://haskell.org/news has a nice collection of sources
17:35:00 <ddellacosta> oh that's a great page lyxia, thanks for the link
17:35:03 <ddellacosta> didn't know about that
17:35:58 <lyxia> :)
18:14:35 <freeman42x]NixOS> anyone run into this haskell ide engine issue? https://github.com/haskell/haskell-ide-engine/issues/524
18:20:38 <blankhart> is hackage down or just me
18:22:05 <Xal> it's down
18:26:59 <geekosaur> being restored from backup
18:27:04 <geekosaur> "oops"
18:27:19 <davean> This is why we have backups
18:34:58 <jle`> Iceland_jack: super excited for it :)
18:35:10 <jle`> ever since i heard about it i've been starting to design my libraries around it
18:35:57 <jle`> can't wait for it to land and i can unleash it
19:01:35 <xplat> jle`: yeah it's nice.  that's how i felt about QuantifiedConstraints btw, except i kept trying to design things around it even before it was proposed orz
19:10:25 <Iceland_jack> jle`: Wow glad to hear
19:11:04 <crestfallen> hi what would be examples of input where we have  (==) _ _ as on lines 7, 12 ?   https://ptpb.pw/Xry2
19:11:19 <Iceland_jack> I think it will make a great combo with -XDependentHaskell which will make it easy to parameterize `deriving' with terms, but we can already model it somewhat effortlessly
19:11:49 <Iceland_jack> crestfallen: Just 1 == Nothing
19:11:59 <Iceland_jack> crestfallen: [1,2,3] == []
19:13:20 <crestfallen> Iceland_jack crucify_me here. sorry I keep changing my nick. thanks for previous/current help! so thats ....
19:13:37 <Iceland_jack> jle`: Serious question, should I add -XGeneralizedGeneralizedNewtypeDeriving to the proposal to mean the same
19:13:55 <crestfallen> so those inputs would match the wildcard cases
19:15:11 <Iceland_jack> Yes they cover different constructors, eg 'Just' on the left and 'Nothing' on the right
19:15:44 <Iceland_jack> They are a shorthand for
19:15:44 <Iceland_jack>     (==) Nothing  (Just _) = False
19:15:44 <Iceland_jack>     (==) (Just _) Nothing  = False
19:16:04 <crestfallen> ok so if there is a combinaiton of the previous two pattern matches in either instance declaration, that would return False and not an error
19:16:20 <lyxia> I'm looking forward to using DerivingVia to derive To/FromJSON with type-level options.
19:16:45 <Iceland_jack> lyxia: That's one exciting use is keeping different instances in sync wrt a particular configuration
19:22:08 <crestfallen> Iceland_jack, sorry, so (==) [2,3] [] would match the wildcard case, not the '(==) (x:xs) (y:ys)' right?
19:24:29 <ddellacosta> crestfallen: you can consider `(==) (x:xs) (y:ys)` as the general case vs. base case in the recursive function--if you hit the base case (`(==) [] []`) then you get equality--otherwise, you are either still recursing (`(==) (x:xs) (y:ys)`) or you've "fallen through to inequality" (`(==) _ _`)
19:25:33 <crestfallen> ddellacosta, excellent that is well said thanks
19:25:45 <ddellacosta> crestfallen: hope that helped!
19:26:22 <crestfallen> it DOES, some inputs return errors though and not False
19:26:39 <ddellacosta> oh, I may not have thought it through fully then.
19:28:52 <ddellacosta> crestfallen: can you give me an example of where it throughs an error?
19:28:59 <ddellacosta> *throw
19:33:04 <crestfallen> one sec I might be confused ddellacosta .. thanks hold on
19:33:15 <ddellacosta> crestfallen: sure thing
19:34:32 <crestfallen> eg (==) ["T"] [2] .. I thought the idea in the use of Maybe was to not throw errors
19:35:19 <ddellacosta> crestfallen: you aren't going to be able to compare those two, they are different types. And Maybe is different here--in the case you just showed me those are two lists
19:35:53 <crestfallen> yeah sorry its not the same instance declaration.
19:36:47 <ddellacosta> crestfallen: it seems like there's still something unclear to you--can you tell me more about what you're finding confusing? I bet I can shed some light on it, or help you work through it yourself
19:37:34 <crestfallen> very kind, one moment pls
19:38:18 <ddellacosta> take your time
19:39:21 <plugin> Could someone glance at this abridged type family / existential definition I have and tell me if the last signiture should typecheck?  I'm trying to untangle a type error and I believe it should but . . .
19:39:24 <plugin> https://gist.github.com/o1lo01ol1o/2f6695c0bc6e092d84293fc82094bd4f
19:43:11 <crestfallen> ddellacosta, so I guess its similar to using ' otherwise False'
19:43:58 <ddellacosta> crestfallen: yep, in the sense of "match any other case"
19:44:15 <lyxia> plugin: there's way too little context
19:44:41 <lyxia> plugin: what's T, what extensions do you have enabled, what is the error message
19:47:31 <plugin> lyxia:  The actual code is a bit more complicated but it boils down to needing to pack a [Nat] parameter and then be able to unpack it with enough information that the type family Combined can do its thing.  The error involves an ambiguous `Combined j0 k` popping up.
19:47:33 <crestfallen> ddellacosta, thanks kindly I'm satisfied. this is review but the wildcard will always perplex me
19:48:10 <ddellacosta> crestfallen: okay! Hope that helped. Feel free to ping me if I'm around and you have more questions
19:49:00 <plugin> lyxia:  added the extensions
19:49:05 <crestfallen> excellent thanks . I was on this channel as crucify_me for a while. Need to brush up..
20:56:04 <HaskellPro> hello
20:58:51 <lambdabot> Hello.
21:03:19 <Iceland_jack> hi HaskellPro
21:05:05 <jared-w> Iceland_jack: hey there :) how goes your `via` magic?
21:08:54 <tayo-tayo> Hello
21:10:24 <jared-w> hey
21:23:56 <Iceland_jack> jared-w: It goes well :) I'm a bit worn out by it, but we finally submitted the proposal and paper
21:25:05 <Iceland_jack> I'm so excited to see what people do with it, I've found so many unexpected uses
21:25:54 <jared-w> Nice! I saw the paper on the subreddit, ya dun good for being a normie :)
21:26:57 <jared-w> I think one use I'm going to be pretty interested in is using the `via` to make chains of coercions for different types basically for free (and simplify monad transformers, of course).
21:27:34 <Iceland_jack> Yes and it will also allow you to compose arbitrary isomorphisms
21:27:57 <Iceland_jack> You can even derive an associated type family via an isomorphism
21:28:15 <jared-w> Which I'm pretty excited about. I've always wanted a way to express more detailed isomorphisms. Oh shit, really? Wild stuff; didn't even realize it could do type family stuff :p
21:28:26 <Iceland_jack> The proposal is very simple but it packs a punch
21:29:22 <Iceland_jack> Yes you basically create a phantom `rep' parameter and write
21:29:22 <Iceland_jack>     type F (Via rep ..) = rep
21:29:53 <Iceland_jack> Then you constrain `rep' to be isomorphic to `F ..'
21:30:43 <Iceland_jack> A usecase for that is deriving Representable for (data Pair a = a :# a) via (Product Identity Identity)
21:31:42 <Iceland_jack> We normally inherit
21:31:42 <Iceland_jack>     type Rep (Product Identity Identity) = Either () ()
21:31:42 <Iceland_jack> but we want `Bool' (or `All', `Any' ..)
21:42:03 <jared-w> hah, nice; pretty simple but I definitely wouldn't have ever thought of that on my own lol
21:59:59 <dsal> I don't quite understand this boolean monad lambdabot offered me.   \x -> (a.b) x == x   is apparently the same as   (a.b)  >>= (==)
22:03:19 <geekosaur> it's just the function monad aka primitive/unwrapped Reader monad. function application is a monad
22:05:37 <jared-w> similar to how `fmap . fmap` is also `fmap fmap fmap`; things have slightly unintuitive instances every now and then :)
22:05:55 <dsal> It's exactly what I was looking for, but I don't quite understand it.  heh
22:08:04 <jared-w> dsal: do you know how "normal" monads work?
22:08:54 <dsal> Somewhat.  I haven't had to use too many monads.
22:10:41 <jared-w> So if you had a function and you wanted to apply an argument to it and then take the result of that and apply /that/ to a function... how would you do that? The "chain-y" thing?
22:11:27 <jle`> Iceland_jack: in what way is it a generalization of GND ?
22:12:36 <dsal> jared-w: What you're describing sounds a little like . to me.
22:12:45 <jared-w> it should :)
22:12:53 <jared-w> :t (.)
22:12:54 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:13:09 <jared-w> This only works for stuff that looks like this though; what if you have a slightly different shape but want to do the same thing?
22:13:21 <typedrat> what do you mean?
22:13:38 <jared-w> jle`: iirc it automates writing the typeclass instance by populating it with the necessary coerces so that rather than having a type need to be a newtype to use GND, you can do the same trick between any two types as long as they're representably equal and can be coerced into each other
22:20:31 <jared-w> typedrat: dsal: (>>=)  :: (r -> a) -> (a -> r -> b) -> r -> b  is the type of >>= specialized to functions. Then there's   pure :: a -> r -> a  (shamelessly stolen from stack overflow)
22:21:24 <jared-w> So with function composition you have a function (b->c) and one (a->b) and you can "thread" the a through two functions and turn it into a c
22:21:49 <robstr> morning, I'm trying to parse "2014-07-09T03:21:20.08" with aeson to a UTCTime, but there is a missing `Z` at the end, is there a way to ignore this ?
22:22:00 <jared-w> With the function instance for monads you have the general idea of some additional type r that's threaded through every computation as an additional argument
22:22:36 <jared-w> (the reader monad is the more commonly known application of this idea)
22:23:08 <dibblego> robstr: you could take this code, and make the (char 'Z' *>) expression into a function argument, and for your case, do nothing there: https://github.com/data61/xsd/blob/master/src/Text/XML/XSD/DateTime.hs
22:25:07 <robstr> dibblego: thank you
22:28:43 <dsal> jared-w: Thanks.  I'm going to go ahead and commit this and think it through later.  I can read it, just need to figure out why it works.  Is there a reference for it somewhere?
22:28:57 <dsal> My actual code is:
22:28:58 <dsal> prop_roundtrips :: (Show a, Read a, Eq a) => a -> Bool
22:28:58 <dsal> prop_roundtrips = read.show >>= (==)
22:29:07 <piyush-kurur> cocreature: finally moved to dante from intero (what a relief). However dante does not seem to support .hsig files or am I missing some configuration option
22:32:13 <dsal> Hmm...  So in my case, it's   (a -> a) -> (a -> a -> Bool) -> a -> Bool
22:39:00 <cocreature> piyush-kurur: I think it just supports what new-repl supports and I guess you can’t load .hsig files in that either
22:52:30 <cocreature> wow hackage is still down. I really don’t want to be a hackage admin right now
22:52:54 <dminuoso> Mmm. if Free gives me a free monad, does Day give me a free applicative?
22:54:04 <cocreature> dminuoso: https://www.stackage.org/haddock/lts-11.4/free-5.0.1/Control-Applicative-Free.html gives you a free applicative
22:54:08 <vilu> I have a cabal related question. I have a package with multiple executables and one test-suite. I want to test the code of the executables.
22:54:44 <vilu> When I add a test-suite section and run an empty test it works.
22:54:59 <vilu> Then I want to test a function in the source code of one of the executable.
22:55:01 <vaibhavsagar> vilu: I don't see how that's possible, when executables don't export functions other than main
22:55:26 <vaibhavsagar> actually, I don't think they export anything at all
22:55:36 <vaibhavsagar> executables are not librarie
22:55:38 <vilu> Ok
22:55:51 <vilu> To add to this, I'm new to haskell and it's build systems.
22:56:02 <vilu> I might want to do a library but I didn't understand that.
22:56:13 <vaibhavsagar> but if you turned the executable into a library and had a new executable that imported the library and called its `main`
22:56:15 <cocreature> you have two options 1. move the code that you want to test in a library or 2. add the files in the executable to hs-source-dirs in the test suite and include them diretcyl
22:56:20 <cocreature> I’d generally go for 1
22:56:30 <vilu> my problem is that I get Could not find module ‘Lib.X’
22:56:35 <dminuoso> cocreature: Mmm, it does look a specialized Day indeed. :o
22:56:51 <vilu> Then I went with cocreature 's option 2 which worked.
22:57:04 <vilu> But now I started having to add all the dependencies of the executable to the test section.
22:57:08 <vilu> which also felt wrong.
22:57:39 <vaibhavsagar> that's because you're essentially duplicating the executable for the test-suite
22:57:44 <cocreature> dminuoso: does it? I’m not sure how you specialize Day to get to that
22:57:54 <vilu> So a better way would be to have actual code in libraries but create small executable sections which basically only refer to the lib in their main method?
22:58:16 <vaibhavsagar> yes, that's what I would do
22:58:27 <vilu> Ok
22:58:29 <vilu> that makes sense.
22:58:32 <cocreature> dminuoso: I’d say, the monad analogue of Day is Compose not Free and I’m not sure you can call Free a specialized version of Compose
23:06:16 <dminuoso> cocreature: Mm. I missed a single `Ap` in that signature
23:06:19 <dminuoso> Im just comparing
23:06:24 <dminuoso> data Day f g a where (:<**>:) :: f x -> g (x -> a) -> Day  f g a
23:06:33 <dminuoso> With that. But I see what you mean.
23:09:02 <lts> let's say I have a type constructor BTree which has Leaf and Branch as its data constructors ; there is a function which accepts type BTree as an argument (afaiu we can pass Leaf or Branch as arguments to this function). Is it possible to figure out inside the function whether I'm dealing with a Leaf or with a Branch ? (i.e. to differentiate b/w the two data constructors?)
23:09:43 <cocreature> lts: pattern matching?
23:10:23 <lts> oh, can I pattern match on type constructors too ? wasn't aware of that
23:10:41 <dminuoso> lts: Leaf and Branch are data constructors.
23:11:05 <dminuoso> lts: If its a data constructor, you can pattern match on it (integer literals and array literals are data constructors too)
23:11:21 <dminuoso> f (Branch x y) = ...
23:11:24 <dminuoso> f (Leaf x) = ...
23:11:26 <lts> i see
23:11:31 <lts> right, makes sense
23:12:56 <vilu> I lost my connection. Thanks for the help related to the tests.
23:31:00 <lts> dminuoso: Just one more thing, my type constructor is defined like this (https://github.com/shivansh/goDB/blob/feat/types/src/Types.hs#L14) ; during pattern matching, how do I pass let's say the Leaf data constructor as an argument and also be able to have a usage like this (https://github.com/shivansh/goDB/blob/feat/types/src/BPlusTree.hs#L108), x is supposed to be the Leaf data constructor (earlier when I
23:31:01 <lts> had a single data constructor I simply used to pass x, but now it can be either a Leaf or a Node)
23:32:28 <dminuoso> lts: Your type signature is lying.
23:33:14 <cocreature> lts: you can do x@(Leaf {})
23:34:01 <cocreature> but I would probably use (Leaf keyCount degree keys child) instead and then use those variables instead of the record selectors
23:34:40 <lts> cocreature: is there a specific name of '@' operator in haskell, i was thinking of looking up some more details on it
23:34:48 <dminuoso> lts: as-patterns
23:35:04 <lts> cool, thanks
23:36:07 <cocreature> lts: note that using record selectors on sum types can easily lead to bugs, e.g., if you apply "next" to Nil or a Node, you’ll get a runtime error
23:39:07 <dminuoso> cocreature: Why can't the type system prevent that?
23:39:57 <cocreature> dminuoso: because Nil and Node are constructors of the same type
23:46:08 <dminuoso> @let data A = L { l :: Int } | R { r :: String } deriving Show
23:46:09 <lambdabot>  Defined.
23:46:13 <dminuoso> > r (L 2)
23:46:16 <lambdabot>  error:
23:46:16 <lambdabot>      Ambiguous occurrence ‘r’
23:46:16 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.r’,
23:46:33 <dminuoso> Ah well. Ill believe you
23:47:48 <cocreature> thanks :)
23:48:55 <jle`> dminuoso: r there is basically like head
23:49:08 <jle`> data List a = Nil | Cons { head :: a, tail :: List a }
23:49:44 <jle`> data Maybe a = Nothing | Just { fromJust :: a }
23:50:28 <cocreature> I wish there was a way to name fields but only allow their use when pattern matching and on constructors, so no record updates and record selectors
23:50:51 <jle`> oh yeah that'd be nice
23:50:58 <jle`> especially since a lot of people use field names as documentation
23:51:17 <cocreature> yeah
23:51:30 <jle`> if you have a sum type and each one has a bunch of fields, you can't name them to let people know what they mean
23:52:15 <cocreature> I’d say at least two thirds of my uses of record selectors are just to document things and I don’t care about getting record updates and record selectors
23:57:00 <pdxleif> RIP hackage 2001-2018 :'(
23:57:10 <jle`> from the ashes it will be reborn
23:57:21 <jle`> should be soon i hear :)
23:58:21 <frerich> cocreature: It was like that for me, too (using record selectors for documenting the type definition) but then I started using more warnings (and/or hlint) and it complained about shadowing names all the time because the record selectors were eating up names I wanted to use in function arguments. :-]
23:59:06 <frerich> cocreature: My new approach is to use `type` for everything such that instead of e.g. `data Person = Person { firstName :: String, lastName :: String }` I do `type FirstName = String; type lastName = String; data Person = Person FirstName LastName`. It's a little obnoxious with so many `type` definitions though...
23:59:22 <cocreature> I really dislike type synonyms
23:59:33 <frerich> I'm not really fond of them either. :-/
23:59:57 <cocreature> you force users to have to chase after the definition of the original type
