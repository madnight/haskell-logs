00:13:44 <dminuoso> :t fix
00:13:46 <lambdabot> (a -> a) -> a
00:13:46 <dminuoso> :t ($)
00:13:48 <lambdabot> (a -> b) -> a -> b
00:14:21 <liste> :t id
00:14:23 <lambdabot> a -> a
00:14:27 <liste> to make it complete :)
00:14:30 <dminuoso> :t fix id
00:14:32 <lambdabot> a
00:15:21 <liste> > fix id
00:15:25 <lambdabot>  *Exception: <<loop>>
00:25:48 <Ariakenom> is EvanR around to be bothered by arithmetic?
00:33:26 <dminuoso> liste: Interesting. GHC has a loop checker?
00:33:50 <dminuoso> Where does this happen? RTS? Compilation?
00:35:26 <liste> dminuoso: RTS, it's quite limited though
00:37:27 <liste> > foldr1 (+) [1..]
00:37:34 <lambdabot>  mueval-core: Time limit exceeded
00:37:34 <lambdabot>  mueval: ExitFailure 1
00:38:11 <liste> doesn't solve the halting progrem :)
00:38:43 * hackage resourcet 1.2.1 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.2.1 (MichaelSnoyman)
00:45:51 <dminuoso> Because of the impending heat death of the universe, any computation will eventually halt. Problem solved.
00:51:20 <Ferdirand> dminuoso: but.. but.. but...
00:55:55 <fgw> Isn't that the halting problem hehe
00:57:37 <merijn> Relatedly: I'm convinced the "next" Haskell will be total
01:00:57 <liste> merijn: Idris? ;)
01:01:34 <merijn> liste: Maybe
01:01:39 <merijn> liste: Not lazy, though :p
01:01:45 <merijn> Which is my main annoyance
01:02:26 <cocreature> idris is interesting in that totality is optional
01:02:26 <raichoo> merijn: yup
01:02:30 <merijn> The more I learn about programming language design and theory, the more I'm convinced Turing completeness is way overrated and undesirable
01:03:03 <dysfun> merijn: i'm not convinced that the next haskell will be lazy
01:03:08 <merijn> Of course, convincing the average programmer of that will be even more of a struggle than of the superiority of purity
01:03:11 <trcc> merijn: Could you expand at bit on that
01:03:21 <merijn> trcc: Which bit?
01:03:24 <trcc> regarding the turing completeness :)
01:03:29 <dysfun> also, turing completeness is very useful for building the abstractions that enable you to provide non-turing-complete interfaces
01:04:08 <merijn> trcc: Well, if I look at 95% of the code I've written in my life that's all been trivially terminating, so doesn't require Turing completeness
01:04:09 <MarcelineVQ> idris can be lazy, you just have to ask for it
01:04:28 <fgw> What kind of completeness does your code require, then?
01:04:30 <merijn> trcc: I used to think "well, still need Turing completeness for "infinite" loops like server request handlers"
01:04:31 <cocreature> merijn: yeah but if you enforce totality those 5% are going to be really painful
01:04:36 <merijn> cocreature: I'm not sure
01:04:37 <MarcelineVQ> By specifying things like Inf in your data or Lazy in your type
01:04:47 <merijn> cocreature: A large part of that 5% is just "while True:"
01:04:53 <trcc> ah ok
01:05:11 <merijn> trcc: And people have already come up with tricks for handling infinite loops in a terminating setting
01:05:49 <cocreature> merijn: I certainly want optional totality. I’m not convinced that enforcing is a) buys you anything useful and b) doesn’t cause a lot of pain for reasonable programs
01:06:12 <fgw> So this means that in the future everyone will program in html
01:06:25 <merijn> trcc: It's similar to the trick we use in Haskell to deal with purity. We relegate effects to the runtime. In a terminating setting you can recast an infinite "while True:" loop as a program that (in a provably finite number of steps) returns a continuation and then having the runtime call the continuation
01:06:52 <merijn> fgw: I'm saying Turing completeness is overrated. That does not mean that all non-Turing complete languages are equivalent
01:07:01 <trcc> Thank you for the explanation. A lot of interesting discussions in this channel
01:07:08 <merijn> fgw: The *real* question is "how expressive can we get before accidentally becoming Turing complete"
01:07:31 <merijn> cocreature: That just means we have more work to do on automating the boring stuff
01:07:34 <cocreature> turing completeness is overrated but avoiding it just for the sake of it is also silly
01:07:56 <dysfun> i think we've failed to establish that turing completeness *is* overrated
01:08:21 <raichoo> "However, the key message of this paper is that the status of general recursive
01:08:22 <raichoo> definitions is readily negotiable within a total framework."
01:08:28 <raichoo> https://pdfs.semanticscholar.org/e291/5b546b9039a8cf8f28e0b814f6502630239f.pdf
01:08:31 <merijn> dysfun: Well, why do you want Turing completeness?
01:08:45 <fgw> Isn't the computer itself in some sense turing complete
01:08:57 <fgw> (not saying they have to be, but)
01:09:04 <dysfun> merijn: to implement that 5% of stuff?
01:09:06 <raichoo> Turing completeness for Free, by Conor :)
01:09:16 <merijn> trcc: For example, the Halting problem is irrelevant in the Simply Typed Lambda Calculus, as it is strongly terminating.
01:09:23 <raichoo> Totally free, sorry ^^
01:09:36 <merijn> dysfun: I'm saying that we already have papers explaining on how to cover large swaths of the 5% in a total setting
01:09:40 <raichoo> Have to admit that I didn't fully read the paper yet.
01:09:54 <dysfun> merijn: ah, interesting. got links?
01:09:56 <merijn> dysfun: What we are currently lacking is the development on how to make all this ergonomic for "real" programmers
01:10:02 <fgw> What would throwing away TC give us?
01:10:06 <fgw> Would there be any benefit
01:10:07 <merijn> dysfun: I believe raichoo just linked the relevant one
01:10:25 <merijn> fgw: Total languages have no Halting problem
01:10:29 <dysfun> ta
01:10:37 <cocreature> merijn: yeah but how often do you care about the halting problem?
01:11:09 <merijn> cocreature: I'm not sure what you're arguing here?
01:11:19 <fgw> the halting problem isn't a ... problem
01:11:32 <fgw> It's not something you encounter every time you write a program, right
01:11:48 <dysfun> it certainly complicates a lot of things
01:11:53 <merijn> fgw: You never have problems with error/undefined/crashing in your haskell?
01:12:00 <cocreature> merijn: I’m arguing that while there are certainly nice theoretical properties arising from totality, I have yet to see practical benefits
01:12:08 <dysfun> or accidentally infinitely looping?
01:12:09 <merijn> fgw: Totality would mean being able to banish undefined/error
01:12:20 <trcc> merijn: why do you need turing completeness for an infinite loop? "I used to think "well, still need Turing completeness for "infinite" loops like server request handlers"". Doesn't it need a halt state?
01:12:24 <MarcelineVQ> at least partly relevant to the topic  https://www.researchgate.net/publication/2454160_The_Size-Change_Principle_for_Program_Termination
01:12:28 <fgw> merijn: I program in Java and C, hehe
01:12:49 <merijn> cocreature: Your main argument seems to be "Sometimes it's convenient to write non-total code", which is not really a counter-argument to my comment that "the next haskell will be total"
01:13:01 <merijn> cocreature: Seeing how haskell's purity has a shitton of escape hatches
01:13:26 <cocreature> merijn: fair enough, if you had said “the next haskell will be total with a lot of escape hatches” I’d probably agree :)
01:13:38 <merijn> cocreature: Any total language comparable to haskell's positioning as "pure" language could arguably have the same number of escape hatches
01:13:48 <fgw> Is JS React the next Haskell, maybe
01:14:09 <dysfun> fgw: if you're going to troll, can you at least do it well please?
01:14:13 <merijn> cocreature: I'm arguing that similar to Haskell being pure by default. The next Haskell will be total by default
01:14:16 * hackage yesod-auth 1.6.3, yesod-core 1.6.3 (MichaelSnoyman): https://qbin.io/bell-scan
01:14:26 <capisce> merijn: so not lazy?
01:14:39 <merijn> capisce: If it's up to me it will be :p
01:14:56 <merijn> But no one seems to want to pay me to develop programming languages :p
01:14:59 <fgw> What does it even mean to be the "next haskell"
01:15:10 <dysfun> incidentally, SPJ said in one of his talks "the next haskell will be strict"
01:15:34 <merijn> trcc: Well, yes, so there you have yet another point why non-totality is overrated :)
01:16:13 * hackage http-conduit 2.3.1 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.3.1 (MichaelSnoyman)
01:16:22 <merijn> trcc: Although that relies on input for shutdown, which is something external, so from a formal perspective would still look like (potential) infinite looping
01:16:30 <dminuoso> dysfun: At times I wish Haskell's lazyness was opt-in rather than opt-out.
01:16:32 <merijn> dysfun: I disagree with SPJ :)
01:16:45 <dysfun> dminuoso: yes, i'd prefer defaulting to strict too
01:16:48 <dysfun> merijn: :)
01:16:50 <merijn> dminuoso: And I will fight to the death to argue that lazy is the stricly superior default
01:16:59 <trcc> roger
01:17:26 <merijn> dminuoso: Problems caused by excessive laziness can always be solved by local strictness annotations. Problems caused by excessive strictness require non-local changes to your entire call-chain
01:17:33 <aarvar> making totality practical is probably just a matter of improving proof automation
01:17:51 <merijn> Unless you're advocating for a language that's strictness polymorphic, in which case, that'd be cool and you can pay me to work on my prototype again
01:18:15 <dminuoso> strictness polymorphism :o
01:18:51 <merijn> dminuoso: In fact, I've got lots of related cool ideas for pure exception handling you can fund me to work out too ;)
01:18:57 <aarvar> um, isn't haskell already "strictness polymorphic"
01:19:24 <merijn> aarvar: No, because a function is either strict or lazy. You cannot write a function whose laziness is decided at call-time
01:19:41 <aarvar> if you have a function which requires another function as an argument, you can pass it a lazy or a strict function as an argument
01:20:01 <merijn> A strictness polymorphic foldl could be used as either foldl (not sure why you'd want to) or foldl' without needing different code
01:20:16 <aarvar> you could already do that
01:20:18 <dysfun> yes, but how would you determine which to use?
01:20:26 <aarvar> foldl = polyfoldl id
01:20:31 <aarvar> foldl' = polyfoldl seq
01:20:36 <aarvar> er not id
01:20:40 <aarvar> const id
01:21:12 <aarvar> so now you just want to infer the argument I guess
01:21:15 <merijn> dysfun: Well, I've been playing with the notion of having multiple type systems in addition to the "functional" types before
01:21:57 <zipper> Say I want to read a file in hs safely I believe I have 2 options. 1. check that the file exists and can be read then read the file else `fail "message"` 2. try read the file and catch the exception
01:21:58 <merijn> dysfun: i.e. I have "(+) :: Int -> Int -> Int" which describes the "functional" behaviour of what it returns. You'd want orthogonal and inferrable types describing, e.g. strictness.
01:22:03 <zipper> which is preferred?
01:22:17 <merijn> zipper: 2, the first one suffers a race condition
01:22:19 <cocreature> zipper: the latter, the former has a race condition
01:22:23 <aarvar> describing strictness gets complicated though
01:22:27 <zipper> Ah!
01:22:34 <zipper> I hadn't factored that in
01:22:36 <merijn> zipper: Consider this: What if you check if the file exists and the file gets deleted before you read it, you're back to case 2
01:22:53 <aarvar> it could return a strict function for some arguments and not for others
01:22:55 <zipper> is there a better way to do this that I haven't thought up?
01:22:57 <dysfun> merijn: but is strictness strictly decidable without the user indicating it?
01:23:05 <merijn> zipper: Have a look at TOC-TOU races and filesystems
01:23:48 <merijn> dysfun: The entire point is that it isn't. You give users the tools to annotate these strictness typings where necessary
01:23:55 <zipper> merijn: this https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use ?
01:23:59 <merijn> zipper: yeah
01:24:00 <dysfun> merijn: right. that's what i'm asking, what is the mechanism for doing this?
01:24:02 <cocreature> zipper: just catching the exception is a pretty good way :)
01:24:15 <merijn> dysfun: I don't know yet, which is why this is a prototype I've been playing with :p
01:24:34 <merijn> dysfun: But since I don't get paid to do this shit and I have a life it's not going anywhere fast
01:25:07 <dysfun> just like my lang :)
01:25:35 <dysfun> incidentally, have you noticed zig, merijn ?
01:25:52 <abc234> sorry to butt in, but I got bored and googled Haskell and started learning about it half an hour ago
01:25:52 <merijn> I have no clue what zig refers to, so probably not :p
01:26:01 <fgw> abc234: welcome!
01:26:26 <abc234> even though I had Pascal, LISP among other things..... my head spinning very quickly reading Hitchhiker's Guide to Haskell
01:26:35 <dysfun> ah, well it's a safe language that interops with C very well but tries to be safe
01:26:50 <abc234> say, usually how long before one feels comfortable thinking in Haskell?
01:27:08 <dysfun> abc234: it depends how much time one invests in it, how much material one already knows etc., but it could be months to years
01:27:18 <merijn> abc234: Depends on the how many and what types of languages you already know, which books/materials you use, etc.
01:27:49 <abc234> well, I had C, C++, Java, LISP, Perl, Python, a bit of Erlang...
01:27:59 <abc234> but Haskell seems a total different animal
01:28:23 <dysfun> yes and no
01:28:32 <dysfun> for example, erlang is all about immutable data and functions
01:28:33 <fgw> It's great fun, if you're math inclined it's a real rush to do those programmer challenges in haskell
01:28:39 <abc234> I like the quicksort comparison between C and Haskell, brought a smile to my face
01:28:42 <merijn> abc234: ah, but if you already know erlang that will help considerably, because you'll already be familiar with pattern matching and a bit of recursion
01:28:48 <capisce> abc234: another mind-bender is Forth
01:28:50 <fgw> There are loads of very beautiful solutions you can come up with
01:28:55 <dminuoso> abc234: Keep in mind that the quicksort implementation you have seen is not completely honest though.
01:28:56 <capisce> and Prolog
01:29:08 <dminuoso> abc234: True quicksort operates in-place, the one you have likely seen does not.
01:29:12 <dysfun> capisce: i'm currently using a prolog book as a rolling mat
01:29:36 <TMA> bry tro
01:29:51 <TMA> sorry, wrong channel
01:30:18 <abc234> I get that maths part....  I get that.  It's like writing a math proof in Haskell, something like that
01:30:33 <dysfun> abc234: i think the primary thing that's going to be difficult to get over the hurdle of is learning to match types up, it's a different game from most type systems
01:30:35 <ongy> how would you even sort inplace with haskell lists? o.0
01:30:50 <merijn> ongy: Haskell lists are terri-bad for sorting anyway
01:30:51 <dysfun> ongy: you wouldn't, you'd have a mutable array
01:31:59 <abc234> anyone of you use Haskell as your primary go to programming language? i.e. use it even mathematically or programmatically trivial stuff?
01:32:03 <ongy> ok, that makes more sense^^
01:32:20 <merijn> abc234: I do, yes
01:32:21 <dminuoso> abc234: Im switching to Haskell for my primary go-to language.
01:32:21 <dysfun> haskell is a great language for doing general purpose stuff
01:32:26 <ongy> yea, when I have the choice it's my go to
01:32:27 <abc234> say, you want to spin up an address book database, nothing fancy, anyone of you would jump on to Haskell?
01:32:30 <abc234> oh really!
01:32:41 <dminuoso> abc234: Small utility "script/shell things", database interaction, API, stream processing, parsing..
01:32:46 <dminuoso> Haskell can do it all well =)
01:32:55 <abc234> thanks for the encouragement, I might take the dive.
01:33:07 <ongy> mind you, you are talking to the active part of #haskell, this probably isn't representative^^
01:33:10 <fgw> We'll always welcome another member to the cult
01:33:17 <fgw> sorry, programming language**
01:33:26 <abc234> at least it might stave off development of dementia in my case haha
01:33:43 <dysfun> abc234: even if you don't end up using it for general development, it's worth learning because it'll teach you to approach problems differently
01:34:16 <dysfun> i don't write haskell often these days, but even in other languages, i write better code for learning it
01:34:25 <abc234> i agree, but right now I feel a mix of pleasure and pain in my stomach....  sort of like, I feel good trying to lift 200 pounds mentally, u know?
01:34:27 <Darwin226> Any reason we don't have a ShowType :: k -> Symbol family?
01:34:39 <Darwin226> There's a similar things for custom type errors
01:34:46 <dysfun> i think the main thing is to accept that yes, it can be hard and to not give up
01:34:51 <dminuoso> Darwin226: You mean like Typeable?
01:34:55 <aarvar> Darwin226: probably exists in singletons?
01:34:59 <trcc> My challenge with Haskell is definitely understand all the terminology and math involved. Monoid, Semigroup, Functors, Applicative functors, monads etc. It is partly because I am really interested in understanding it, and not just using it. And a think that bugs me greatly is the ongoing debate on cabal, stack, nix. Very frustrating for a new user
01:35:23 <Darwin226> dminuoso: I thought typeable was for value level reflection
01:35:25 <dysfun> trcc: just ignore the turf wars and pick what works for you
01:35:30 <trcc> understanding* thing*
01:35:51 <Darwin226> aarvar: I don't see how it could be implemented without a ton of manual work
01:35:54 <dminuoso> Darwin226: Ahh.
01:36:00 <aarvar> Darwin226: wdym?
01:36:15 <Darwin226> You'd need to manually provide names for every primitive type
01:36:15 <abc234> I am going to get my irc client set up proper and register on freenode.  hope to be around more in the future.
01:36:16 <aarvar> singletons uses template haskell to promote value level stuff to the type level
01:36:26 <dysfun> trcc: as for the typeclasses, take them one by one and understand what the similarity is between several instances of the typeclass
01:36:29 <merijn> trcc: Well, this thread is rather interesting view on that: https://twitter.com/mattoflambda/status/982776992704512000
01:36:51 <trcc> dysfun: yes, currently I am going through the nicta course which uses Cabal afaik. Afterwards, once I come up with an idea, I will try nix and finish a simple project.. Think I have done enough reading for now
01:36:59 <Darwin226> aarvar: Oh, right, TH. This doesn't work in my case because I need it to work in a polymorphic context
01:37:01 <dminuoso> trcc: I think those names have the advantage of being sufficiently abstract to not give you the idea that "Functor" was about say "containers"
01:37:10 <merijn> trcc: The tricky part with all the Haskell typeclasses is not so much the name, but needing to first crystalise the concept said names point too
01:37:11 <aarvar> Darwin226: https://hackage.haskell.org/package/singletons-2.4.1/docs/Data-Promotion-Prelude.html#t:PShow
01:37:23 <dysfun> trcc: i'm in the stack camp fwiw, it's just so easy
01:37:26 <dminuoso> trcc: So by using an abstract name, they avoid giving you the wrong impression. :)
01:37:31 <fgw> trcc: the tweeter has probably encountered too much Hungarian Notation
01:38:03 <dysfun> fgw: notHungarian, you mean?
01:38:08 <merijn> trcc: And the advantage of the math-y names is they're fairly clearly delineate *just* that one concept. Unlike "containers" which points to many slightly different concepts in many people's brains
01:38:14 <trcc> merijn: hehe thanks for the link
01:38:20 <Darwin226> aarvar: No instance for Type
01:39:12 <merijn> trcc: If you like Nix you might want to use new-build when using cabal (assuming you have cabal-install 2.x)
01:39:25 <trcc> merijn: I am interested in learning math a long with haskell, so I like the math terms. I am just struggling :) Common stuff when learning a new thing, there is just a lot more of it when learning haskell as opposed to e.g. Scala
01:39:43 <trcc> thanks
01:39:45 <aarvar> trcc: does the nicta course not recommend nix?
01:40:08 <dysfun> trcc: i'm not sure i agree with that. scala's collections library has far more odd traits than haskell + common modules
01:40:14 <aarvar> huh,I guess it doesn't
01:40:28 <merijn> trcc: Basically, new-build takes a Nix-like "index packages with unique hash of transitive dependencies" approach so you never run into dependency conflicts between unrelated projects
01:40:28 <trcc> hehe aarvar looks like it is using nix, but I am only invoking cabal functions.\
01:41:09 <aarvar> scala is way more complicated than haskell
01:41:20 <merijn> trcc: The alternative view is "new-build is cabal sandboxes, except all the sandboxing happens automagically and you can actually share packages across project sandboxes"
01:41:33 <trcc> dysfun: I agree with you in that, but you do not encounter as many new terms, when you come from a C/C++ background. I am sure, that if you dive into Scala it is a different story
01:42:39 <dysfun> trcc: ah yes, on that note, a haskell functor is nothing like a c++ functor
01:43:25 <cocreature> is the dlist package still what people use? I already depend on lens and a million other things so I wonder if there isn’t a dlist implementation in one of those packages
01:43:35 <dminuoso> Just like "function" was abused to mean "routine", "functor" was abused to mean "first class function"
01:43:43 <trcc> It might be because I find the Scala tutorials more: "If you need to solve this problem, then do like this." Whereas in haskell it is: "If you need to solve this problem, then use typeclasses <followed by an introduction to typeclasses>
01:43:45 <aarvar> trcc: it's not like there aren't monoids and functors and stuff in scala too
01:44:08 <trcc> aarvar I am aware, you are just not subjected to them as early on as in haskell IMO
01:44:17 <aarvar> depends on what libraries you use
01:44:29 <trcc> probably. Just talking from my experience, which is limited >(
01:44:30 <trcc> :)
01:44:30 <aarvar> but yes,in scala early on you're subjected to lots of bullshit and confusion instead
01:44:47 <trcc> hehe I am not saying one is better than the other, just that they seem quite different
01:44:52 <aarvar> stuff about OO/FP hybrid blah blah blah
01:44:53 <dminuoso> This channel is a great place to hear criticism about "scala", "go" and "elm.
01:45:03 <dminuoso> Part of the daily routine.
01:45:08 <aarvar> trcc: btw, you might aslo try the #scalaz channel
01:46:16 <merijn> Also, you can't be subjected to monoids early enough. The longer I write Haskell, the more I'm amazed of how many of my problems become trivial with them
01:46:22 <merijn> @quote beaky monoids
01:46:22 <lambdabot> beaky says: i love monoids / they are so easy
01:46:25 <trcc> aarvar: Thanks, but plenty of stuff on my plate currently. Once I get comfortable enough to pick up Haskell for any random project, then I will expand. Currently my spare time goes with haskell
01:46:47 <aarvar> trcc: #scalaz has lots of haskellers
01:47:20 <trcc> I find plenty of brain-stretching comments in here. But i'll check it out :) Thanks
01:49:34 <trcc> But I finally understood the maybe monad properly yesterday just before falling asleep. And then I had a dream about fighting orcs all night. Maybe related? :)
01:50:10 <cocreature> trcc: just throw Nothing at the orcs
01:50:21 <aarvar> trcc: not that you're doing this, but be careful about confusing "the maybe monad" with "the maybe data type"
01:50:55 <dminuoso> cocreature: Is there an instance Exception (Maybe a)? :o
01:51:00 <aarvar> a common mistake is people using Maybe and thinking that means they're using monads
01:51:14 <aarvar> which is like saying if you use Strings then you're using monoids
01:52:03 <trcc> I was using it to convert list [maybe a] into maybe list a
01:52:15 <zipper> Is there no way to do string interpolation in hs? All I see is concatenation
01:52:17 <trcc> seems useful for this purpose
01:52:18 <jackcrfs> abc234 back; registered nickname jackcrfs, thanks for the warm welcome.
01:52:21 <aarvar> yes, that uses the Monad (actually the Applicative)
01:52:25 <aarvar> if you mean with sequence
01:52:28 <dminuoso> trcc: That's called `sequence/traverse`
01:52:32 <aarvar> :t sequenceA
01:52:33 <dminuoso> :t sequence
01:52:34 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
01:52:35 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
01:52:55 <trcc> yes, I found that, but did not understand how it operated in the beginning
01:54:43 <trcc> aarvar: ah shit, there are many monads? I just considered it as using the monad
01:55:03 <dminuoso> trcc: There are some.
01:55:11 <trcc> or, rewrite, I know there are many monads, but I did not consider maybe to have an applicate monad and other monads. Thought maybe just had one monad
01:55:29 <dminuoso> trcc: Check out which instances base comes with: https://hackage.haskell.org/package/base-4.11.0.0/docs/Control-Monad.html#t:Monad
01:55:31 <aarvar> trcc: Applicative is a superclass of Monad
01:55:40 <trcc> ah ok.
01:55:46 <trcc> Then it am still on track
01:56:10 <dminuoso> trcc: In the end `Monad` is not a thing that is "useful". It's just a very general pattern.
01:56:25 <aarvar> what
01:56:40 <trcc> dminuoso: I got that much. But can I, in this context then, avoid using Monad but just using Applicate?
01:56:43 <trcc> applicative*
01:56:48 <aarvar> "Monad" is very useful
01:56:57 <dminuoso> aarvar: Maybe that was phrased poorly.
01:57:01 <dminuoso> Monad doesn't have a purpose.
01:57:05 <jchia> I'm using inline-c package in my stack project. How can I configure the project to have extra linker command-line options? I want to link some external .so library.
01:57:08 <aarvar> what?
01:57:34 <aarvar> dminuoso: what does that mean
01:58:02 <aarvar> Monad is an abstraction. The purpose is to avoid code duplication
01:58:11 <aarvar> same as any other such abstraction
02:00:44 <Ariakenom> "The purpose is to avoid code duplication" <.<
02:01:04 <dminuoso> aarvar: Fine.
02:01:10 <jchia> I found out about the 'extra-libraries' section for the cabal file
02:01:26 <Ariakenom> I take issue with hat statement
02:01:37 <aarvar> Ariakenom: why
02:01:43 <dminuoso> aarvar: Reader monad?
02:01:53 <aarvar> dminuoso: um, what?
02:03:13 <Ariakenom> a common purpose of abstraction is to be more correct? Like using parametricity of a function
02:03:26 <Ariakenom> :t fmap
02:03:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:03:28 <aarvar> sure, abstraction has other benefits
02:03:49 <dminuoso> aarvar: I dont think it generally holds true that `Monad` avoids code duplication.
02:04:01 <aarvar> dminuoso: I have no idea what you mean
02:04:22 <aarvar> the point of having "Monad" is that I can write a single piece of code which works for all monads, rather than copy/pasting it for each one
02:04:34 <dminuoso> aarvar: What exact code duplication does IO avoid? In the current state it's simply an interface because the pattern models side effects rather well.
02:04:50 <aarvar> dminuoso: "IO" is not "Monad"
02:04:58 <aarvar> you're making the exact mistake I mentioned earlier
02:05:06 <dminuoso> aarvar: You are talking about ad-hoc polymorphism.
02:05:13 <aarvar> what?
02:05:21 <aarvar> no, I'm not
02:05:29 <aarvar> I'm talking about the purpose of abstractions
02:05:47 <aarvar> IO is just a data type like any other. It has nothing to do with monads
02:07:59 <aarvar> dminuoso: the avoided duplication is that of having to write sequence and other useful functions for each monad, rather than writing it once for all of them
02:08:17 <Taneb> :t replicateM
02:08:18 <lambdabot> Applicative m => Int -> m a -> m [a]
02:08:35 <dminuoso> aarvar: That's the advantage of _typeclasses_. Im talking about one in particular. As in if I ask you: "what exact problem does Monad solve"
02:08:46 <dminuoso> Then the answer would be "none in particular. it's just that some things are monadic"
02:08:56 <aarvar> dminuoso: has nothing to do with typeclasses
02:09:02 <aarvar> you could use explicit data types instead
02:09:33 <aarvar> the problem Monad solves is that it abstracts over a common pattern, allowing more code reuse etc
02:09:40 <aarvar> same as the use of Monoid, etc
02:10:04 <aarvar> Monad is particularly useful because it has both many instances and a lot of useful functions that can be derived
02:11:01 <dminuoso> aarvar: That's not a problem Monad solves.
02:11:09 <dminuoso> You can abstract over a common pattern without Monad just fine.
02:11:13 <Taneb> I think you two are talking at cross purposes
02:11:27 <ventonegro> Monads are just pipes *ducks*
02:11:50 <aarvar> dminuoso: Monad abstracts over a particular pattern
02:12:09 <aarvar> it gives you code reuse in the cases where you have that pattern
02:12:14 <aarvar> that's the purpose of Monad
02:12:14 <dminuoso> aarvar: Right. And that's exactly what I tried to convey. It doesn't solve any specific problem, but rather a pattern.
02:12:21 <merijn> Which GHC version added Coercible?
02:12:40 <aarvar> It solves the problem of "I have some triple (f, bind, unit) satisfying some laws, and would like to derive a lot of code for free, rather than writing it"
02:12:41 <dminuoso> aarvar: The code reuse doesn't come from the fact that it's a monad. It comes from the fact that you have a typeclass for it.
02:13:03 <Taneb> merijn: 7.8.1 I think
02:13:09 <dminuoso> :t fold
02:13:11 <lambdabot> (Monoid m, Foldable t) => t m -> m
02:13:17 <dminuoso> aarvar: ^- this does not use Monad.
02:13:21 <aarvar> no shit
02:13:39 <Taneb> merijn: (my source is base's changelog)
02:14:01 <aarvar> "Monad is an abstraction. The purpose is to avoid code duplication. same as any other such abstraction"
02:14:13 <dminuoso> aarvar: And how does that not hold true for any typeclass?
02:14:20 <aarvar> monad lets you avoid code duplication in the case of one particular pattern. Monoid in the case of another, etc
02:14:39 <aarvar> dminuoso: it does hold true for any good abstraction (once again, nothing to do with typeclasses)
02:14:42 <Ariakenom> ventonegro, Monads are just smart pipes. Where pipes are monoids and smart is on the category of endofunctors.
02:15:05 <aarvar> Ariakenom: no, they're a way of injecting external semantics into functions
02:15:11 <aarvar> or whatever he said
02:15:14 <fgw> I would say that a Monad is what it is defined as in haskell/GHC, very beneficial to look up and read through if you're unsure about Monads
02:15:32 <ventonegro> Ariakenom: :D
02:15:49 <aarvar> well, Monad as defined in the Prelude is less general than monads in category theory
02:16:04 <aarvar> so it depends on your definition
02:16:14 <Taneb> Ariakenom: monoids are just pipes on the category of sets
02:17:47 <dminuoso> aarvar: Foldable generalizes the notion of being able to deconstruct some structure into a new value. Semigroup generalizes the notion of (associatively) combining two things. Eq generalizes the notion of comparing two objects of identity. Read generalizes parsing from String into an object.
02:17:47 <aarvar> they're just pipes from an object to itself
02:18:17 <dminuoso> aarvar: If you continue that list, how would you describe Monad?
02:18:22 <aarvar> dminuoso: fold generalizes the notion of being able to convert to a free monoid, but close enough
02:18:31 <aarvar> or, of being a free monoid
02:19:01 <dminuoso> s/of identity/for equality/
02:19:33 <aarvar> dminuoso: Monad abstracts over the pattern of having some mapping f : * -> * such that one can compose functions of the form a -> f b
02:20:19 <fgw> That's what it's defined as, what are you disagreeing about? I don't get it
02:20:25 <merijn> You guys are going in circles and it makes for IMO extremely boring discussion
02:20:28 <aarvar> i.e. it's a function f such that Kleisli f forms a category
02:20:39 <aarvar> merijn: agree
02:22:45 <ventonegro> Monad is just a very useful pattern, that's clear. Maybe a better question is to ask why this pattern is so effective?
02:22:53 <merijn> I have a new belief: Monoids are like violence. If they're not solving your problem, you're not using enough of them
02:23:24 <dysfun> i thought that was supposed to be monads
02:23:50 <merijn> dysfun: No, more monads generally makes things less nice
02:23:51 <int-e> well, monads are useless
02:23:55 <int-e> :P
02:23:56 <merijn> More monoids are always better :)
02:24:12 <dysfun> heh
02:25:35 <cocreature> good thing monads are just monoids
02:25:37 <merijn> dysfun: Nesting monads generally makes things messier to deal with. Nesting monoids just makes things more monoidal :)
02:26:08 <merijn> And I love how mconcat can turn a list of 10 functions into one easily appliable function
02:26:26 <merijn> And then you're like "wait, I only want these functions enabled when conditions X holds"
02:27:07 <merijn> And then you realise you already wrote "Version -> [a] -> [a]" in your code and can just generalise that to "Monoid m => Version -> m -> m" and use that inside the list of functions to conditionally disable some
02:27:32 <dysfun> whoosh! what's a Version?
02:27:46 <merijn> dysfun: A version number for a program? :p
02:28:00 <dysfun> oh, i see, it's just your arbitrary data
02:28:48 <merijn> "instance Monoid m => Monoid (a -> m)" doesn't get the love it deserves
02:29:29 <dysfun> you should write an article extolling the virtues
02:37:47 <rckd> noob question: im trying to fetch some data from a website via Network.HTTP.Conduit but always getting HttpExceptionRequest
02:37:55 <rckd> how can i catch exceptions? :D
02:38:19 <merijn> rckd: Have a look at Control.Exception
02:40:03 <rckd> ok thanks
02:40:05 <rckd> ill try
02:40:06 <rckd> :-D
02:49:20 <rckd> merijn i ended up with this: http://lpaste.net/2913684351654821888
02:49:25 <rckd> any tipps / complains?
02:49:51 <merijn> looks sensible enough
02:50:35 <merijn> rckd: Although it currently does the equivalent of catching every exception
02:50:40 <trcc> what is your opinion on point free style? Sometimes I find it extremely abused and makes code unreadable. Any best practices?
02:51:03 <merijn> trcc: "Do whatever's readable"
02:51:13 <trcc> nice and simple
02:51:27 <merijn> rckd: So you probablly wanna do "Either HttpException ByteString" to only catch http errors
02:51:55 <rckd> oh ok i tried it with "HttpExceptionRequest" because it was part of the error message
02:52:08 <merijn> rckd: That's one of the constructors
02:52:08 <rckd> but that resulted in an error
02:52:13 <rckd> ok
02:52:18 <rckd> didnt looked into it now
02:52:25 <merijn> rckd: See the docs for simpleHttp "This function will throwIO an HttpException for any response with a non-2xx status code"
02:52:38 <merijn> Clicking on the HttpException type gives you the possible constructors it has
02:52:42 <aslkgadgl> Is it possible to Monad transform a ClientApp from the websockets package? An example of using the monad normally is here: https://github.com/jaspervdj/websockets/blob/master/example/client.hs and the type of ClientApp is (String -> IO a)
02:53:03 <rckd> ok thanks that works great
02:53:04 <aslkgadgl> I'm trying to use MaybeT with it, but I'm not sure how as there is an extra argument
02:54:49 <aslkgadgl> Woops I mean Connection not String
02:55:07 <merijn> rckd: A slightly nicer one would be: http://lpaste.net/2913684351654821888
02:55:25 <merijn> rckd: Note how inference on the use means the type annotation is no longer needed
02:56:12 <rckd> i tried with >>=: http://lpaste.net/7635168494585118720
02:59:36 <fourroot>  /join #lip
03:06:07 <ertes-w> ello
03:08:28 <ertes-w> aslkgadgl: Connection -> MaybeT IO a  -- like this?
03:08:30 <hooal> http://www.ner.indianrailways.gov.in//uploads/directcontent/1521325468456O-REDISTRIBUTION.pdf
03:10:59 <aslkgadgl> ertes-w: thanks, that worked!
03:15:42 <terrorjack> Hi folks, what does the "quotRemWord2#" primop do? Can't find even one line of comment anywhere
03:19:24 <ertes-w> terrorjack: just guessing here, but it's probably the primop for dual-word division instruction that some CPUs have
03:19:50 <dminuoso> terrorjack: Uh? https://github.com/ghc/ghc/blob/master/compiler/prelude/primops.txt.pp#L361-L362
03:20:07 <ertes-w> ah, i was right
03:20:36 <ertes-w> yeah, divide a 128-bit number by a 64-bit number (on 64-bit systems)…  on x86 that's a single instruction
03:21:33 <rckd> is there any built in function with  Either a b -> Maybe b  ?
03:22:29 <cocreature> rckd: the either package provides "rightToMaybe"
03:23:09 <dminuoso> rckd: Or you can just write this on the spot: f = either (const Nothing) Just
03:23:12 <rckd> hmm cant find it at hoogle
03:23:24 <cocreature> https://hoogle.haskell.org/?hoogle=rightToMaybe
03:23:52 <muesli4> Does it not work for `Left` values?
03:24:10 <rckd> oh lol: https://www.haskell.org/hoogle/?hoogle=rightToMaybe
03:24:11 <rckd> ??
03:24:11 <rckd> :P
03:24:27 <dminuoso> muesli4: Consider the isomorphic alternative: Either a b -> Either () b
03:24:37 <dminuoso> a -> () is quite forgetful!
03:24:52 <muesli4> dminuoso: Sure, but the name is kind of odd.
03:25:21 <cocreature> dunno seems pretty clear to me
03:25:27 <cocreature> especially given that there’s also a leftToMaybe
03:25:46 <dminuoso> cocreature: leftToJust/righToJust sounds a bit more sane
03:26:12 <cocreature> fair enough
03:27:18 <terrorjack> dminuoso: thanks!
03:27:23 <muesli4> Considering that there are two isomorphisms it makes sense.
03:27:45 <cocreature> except that neither of them is an isomorphism :)
03:28:24 <muesli4> cocreature: What would you call it?
03:28:33 <dminuoso> muesli4: I challenge you to write: Maybe b -> Either a b
03:28:36 <cocreature> muesli4: a function?
03:29:45 <dminuoso> muesli4: Is that function was an isomorphism, it needs to be invertible without loss of information.
03:30:44 <muesli4> I'm not saying the function is an isomorphism, just that given an isomorphism from a to a two such exists between `Maybe a` and `Either a ()` and `Maybe a` and `Either () a`. But yeah, technically not an ismorphism.
03:46:51 <ertes-w> just use the 'either' variant and avoid both the confusion and the extra package dependency =)
03:47:25 <cocreature> or the lens variant ;)
03:48:12 <ertes-w> :t preview traverse :: Either e a -> Maybe a
03:48:13 <lambdabot> Either e a -> Maybe a
03:48:27 <dminuoso> :t preview
03:48:28 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
03:48:34 * dminuoso smells lenses
03:48:54 <ertes-w> well, traversals =)
03:49:10 <ertes-w> or prisms, if you insist
03:49:17 <ertes-w> :t preview _Right
03:49:20 <lambdabot> MonadReader (Either c b) m => m (Maybe b)
03:49:22 <Taneb> :t (^? _Right)
03:49:23 <lambdabot> Either c b -> Maybe b
03:50:01 <dminuoso> ertes-w: I watched one of eds talks explaining: type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
03:50:21 <dminuoso> It was quite mindbaffling how your original task (V3 if you remember!) fits into this
03:50:47 <dminuoso> But I could barely understand 20% of it because he just rushed into strong profunctors and then things happened.
03:54:56 <merijn> I really need to find a better way to linewrap long (.) pipelines :\
03:56:27 <Ariakenom> merijn, ooh. tell me more tell me more
03:57:29 <rckd> is hlint the tool used for giving tipps @ lpaste?
03:57:31 <merijn> Ariakenom: hmm?
03:57:34 <merijn> rckd: Yes
03:57:51 <merijn> rckd: Note that not everyone agrees on how much you should believe hlint
03:58:14 <Ariakenom> merijn, what's wrong with indenting and starting with (.)?
03:59:27 <merijn> Ariakenom: Doesn't look very nice when you're already indented a few levels
04:00:30 <ertes-w> dminuoso: yeah, traversals are really just a generalisation of Traversable, and that just captures the idea of an effectful map
04:01:11 <ertes-w> dminuoso: and then if you replace the Applicative constraint by Functor, you can only handle a single value, which makes it a lens and supports deterministic 'view'
04:02:33 <Putonlalla> If you want to watch talks on lenses, I recommend starting with SPJ's second-hand account, dminuoso.
04:03:44 <ertes-w> merijn: this style has served me well for years: https://github.com/esoeylemez/rapid/blob/master/Rapid.hs#L151-L154
04:03:47 <Boomerang> Ariakenom: I indent and start with (.), but the trick is to move the `=` onto the next line as well so everything is only indended by say 2 spaces (or 4 if you prefer)
04:04:50 <Boomerang> (moving the `=` is mostly when doing pointfree stuff)
04:05:58 <Ariakenom> Boomerang, how do you mean?
04:07:43 <ertes-w> starting lines with punctuation is a typographical atrocity and a declaration of war against aesthetics
04:08:13 <Boomerang> Ariakenom: http://lpaste.net/364649
04:08:30 <merijn> ertes-w: Ending a line with an operator is an exercise in trying to maximally confuse the reader
04:09:21 <merijn> Boomerang: That doesn't work as nicely if myCoolFunction is indented a few times
04:09:29 <ertes-w> merijn: i disagree, and you're not going to convince me, so let's skip this particular topic =)
04:09:46 <merijn> I need to go badger Cabal contributors anyway :p
04:09:52 <Boomerang> merijn: In a where/let clause? It seems to work fine for me
04:09:55 <Ariakenom> Boomerang, ok I see. I just wasn't doing your understanding so I was confused. :)
04:10:07 <merijn> Boomerang: I'm not saying it doesn't work, I'm saying it looks bad
04:11:02 <Ariakenom> I did pretty much sugestion. Just left equality above and kept doSomething down
04:11:28 <Boomerang> Ariakenom: Sorry for the confusion. I often see this align with `=` style. Whenever you change the name of the function or add/remove arguments to it, you end up having to change the indentation. That's both a waste of time and leads to horrible git diffs :p
04:11:37 <ertes-w> if you start lines with punctuation you're not remotely in the position to talk about aesthetics…  the best you can achieve is "better than the worst" =P
04:12:59 <HoloIRCUser> Hi
04:13:22 <Ariakenom> Lets go further. Clearly punctuation should be placed at the start of sentence to indicate if a sentence got cut off.
04:13:26 <HoloIRCUser> Test
04:14:17 <Ariakenom> Boomerang, agreed.
04:18:54 <Unhammer> Is there a term for a number that you'd like to be as close to as possible but not above?
04:20:00 <merijn> Unhammer: "maximum"? :p
04:20:46 <merijn> Unhammer: What exactly would this be used for?
04:22:00 <Unhammer> well, if maximum == 1000 then 1 is typically fine …
04:22:34 <merijn> Unhammer: Is your goal "user specified data that can't exceed some magical boundary value"?
04:22:41 <Unhammer> I'm dropping dates from a list and keeping "maximum" spread between the remaining ones while having as much spread as possible
04:24:21 <Unhammer> e.g. if [1,6,8,12,14,20] are allowed dates, and 8 is the "maximum", one solution would be [1,8,14,20]
04:26:14 <lyxia> there's "greatest lower bound" but I'm not sure how that'd fit here
04:28:11 <adjofun> Unhammer: name it "sparsityThreshold" or even "varName", and call it a day =D
04:29:45 <Unhammer> x
04:30:06 <rckd> merijn any examples where hlint is bad? :D
04:31:34 <tdammers> rckd: it has some style preferences that aren't always appropriate, and that some people outright disagree with
04:31:58 <rckd> hm ok
04:32:49 <cocreature> technically some of its suggestions can also result in worse performance, e.g. eta reduction can prevent inlining
04:32:49 <Boomerang> tdammers: Can't you make your own rules/override the default ones?
04:33:33 <merijn> Boomerang: Sure, but that doesn't affect the suggestions on lpaste
04:34:01 <Boomerang> Oh right, of course. I forgot why we were talking about hlint ^^
04:34:45 <Boomerang> The only issue I have with hlin (not lpaste related), is how the `--refactor` sometimes works
04:36:15 <Boomerang> But maybe I should just be more careful with custom rules
04:41:06 <ertes-w> Unhammer: are you implementing some kind of rotation scheme?
04:41:27 <ertes-w> Unhammer: for expiring backups or something like that?
04:53:14 <Unhammer> ertes-w, no, this is for scheduling suggested order dates for recurring orders
04:53:34 <ertes-w> ah
04:54:46 <ertes-w> Unhammer: i have a library with operations like "skip to next monday" that you might find useful
04:55:03 <Unhammer> ooh, where?
04:55:07 <ertes-w> Unhammer: https://hackage.haskell.org/package/timelike
04:55:29 <ertes-w> Unhammer: it's currently undermaintained, because i'm not actively using it, so you might have to update the version bounds
04:56:08 <ertes-w> if you can wait, i'll make sure it builds this evening and release a version with updated bounds
04:57:50 <tabaqui2> https://hackage.haskell.org/package/tls
04:58:12 <tabaqui2> does anybody know how can I export session key from a context here?
04:58:54 <tabaqui2> I want to allow clients to debug session with wireshark
04:59:19 <Unhammer> well, we're on pretty old ghc's at work …
04:59:25 <Unhammer> so no rush for my sake heh
05:00:23 <ertes-w> Unhammer: alright…  still a bit of maintenance couldn't hurt =)
05:00:39 <ertes-w> Unhammer: oh and note that you need an extra library for the actual instances: timelike-time
05:03:13 * hackage ngx-export 1.4.0 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-1.4.0 (lyokha)
05:14:35 <Unhammer> ah, thanks
05:18:21 <jchia_1> Is there any package that lets me inspect C/C++ code and extract information like size of a type, offset of a struct member within a struct, etc? clang-pure is unmaintained.
05:20:14 <jchia_1> LibClang also seems unmaintained because it seems to be still using clang 3.8
05:21:13 * hackage wild-bind 0.1.2.0 - Dynamic key binding framework  https://hackage.haskell.org/package/wild-bind-0.1.2.0 (debugito)
05:21:47 <merijn> jchia_1: For what purpose?
05:22:17 <merijn> jchia_1: Also, such a package cannot exist as most of the things you mention aren't actually defined in the C standard and thus cannot be portably determined
05:22:29 <mnoonan> jchia_1: you generally can't
05:22:32 <jchia_1> There's some Haskell-C++ FFI that I'm trying to do to read C++ structs produced by C++ code.
05:22:46 <merijn> jchia_1: Yeah...you're screwed
05:23:01 <merijn> My advice: Give up now, down this road lies insanity
05:23:01 <jchia_1> merijn: In practice, I just care about clang/gcc's interpretation.
05:23:20 <merijn> jchia_1: C++ is *definitely* not portable between gcc and clang
05:23:43 * hackage wild-bind-x11 0.2.0.2 - X11-specific implementation for WildBind  https://hackage.haskell.org/package/wild-bind-x11-0.2.0.2 (debugito)
05:23:44 <mnoonan> If you're trying to FFI, maybe use inline-c++?
05:26:04 <jchia_1> mnoonan: Yeah, maybe I can use that to get the offset and size of struct members and use that for TH to generate Store instances.
05:26:59 <merijn> What C++ code are you interacting with?
05:27:56 <jchia_1> merijn: Some vendor API.
05:28:15 <merijn> jchia_1: Godspeed, you'll need it :)
05:29:05 <mnoonan> C++ APIs that aren't just header-wraps of C APIs should be illegal.
05:30:36 <jchia_1> mnoonan: I don't like the vendor API for other reasons, but these vendors are quite unprofessional. They don't even know to use namespaces.
05:31:30 <jchia_1> mnoonan: What happens when C++ APIs aren't like what you said?
05:31:39 <merijn> jchia_1: Sadness :)
05:32:35 <jchia_1> For example?
05:34:38 <merijn> jchia_1: The fact that there's no portable way to find out names, offsets, sizes, etc. turning your code into a spaghetti mess of compile time conditionals checking against various compiler and OS versions
05:36:01 <Taneb> It makes it very difficult (almost impossible) to use the API in not-C++
05:37:22 <jchia_1> OK, there's a portability problem when you want to use different OS or hardware. This can be a big problem for some people. Others just need one platform, e.g. Linux + Intel.
05:37:44 <merijn> jchia_1: No, it's not even portable on "linux + intel"
05:38:12 <merijn> jchia_1: Because ICC, g++, and clang++ can't safely operate C++ either
05:38:13 <jchia_1> OK, there were some ABI changes.
05:38:33 <merijn> jchia_1: In fact, I'm not even sure you can safely mix code from different versions of the same compiler
05:39:03 <merijn> I've had code fail because my BOOST install was compiled with one clang++ version different from my current clang++ version
05:39:06 <merijn> Fun times!
05:41:54 <oo_miguel> I am playing with pandoc and use "readMarkdown def{readerExtensions=pandocExtensions}" and then "writeHtml5String def doc". Everything works fine, beside I do not get lineNumbers in the resulting html for syntax highlighted code-blocks
05:42:17 <oo_miguel> any ideas/suggestions what I am missing?
05:58:51 <orion> I want to create an API which abstracts over Gmail and Outlook's REST APIs. In addition to a series of functions, I also want to define types that are associated with each mail provider. What design pattern is recommended for this?
05:59:13 <orion> I tried a record of functions but found it too limited, as I wanted to have associated types.
06:00:22 <orion> I am currently using a type family, but I am not sure that it's the best solution.
06:00:52 <orion> I can't use Backpack, because I need to be able to manipulate Gmail and Outlook simultaneously in the same executable.
06:00:54 <lemmih> I would go with a plain Haskell2010 solution but I'm boring like that.
06:02:14 <bwe> Hi, how can I let filter return only those tuples whose second inhabitant is invariant to Nothing? http://lpaste.net/1560209989111382016
06:03:37 <aasronStone> whenever we return something from inside of do it has type IO something how do i return just Something or maybe in another context like M something ??
06:03:40 <lemmih> bwe: You're using snd' which expects triples but the list has tuples.
06:04:15 <bwe> lemmih: True: http://lpaste.net/1560209989111382016
06:04:23 <lemmih> aasronStone: 'return' isn't specific to IO. You can do 'return () :: Maybe ()'
06:04:52 <bwe> > filter (snd . (/= Nothing)) [(5, Nothing), (6, Just 3.4)]
06:04:55 <lambdabot>  error:
06:04:55 <lambdabot>      • Couldn't match type ‘Bool’ with ‘(a0, Bool)’
06:04:55 <lambdabot>        Expected type: Maybe a -> (a0, Bool)
06:05:30 <lemmih> bwe: Other way around: (isJust . snd)
06:05:58 <bwe> lemmih: What's isJust?
06:06:08 <bwe> Variable not in scope: isJust :: Maybe a1 -> Bool
06:06:13 <lemmih> bwe: It's from Data.Maybe
06:06:30 <lemmih> > (isJust Nothing, isJust (Just ()))
06:06:33 <lambdabot>  (False,True)
06:07:05 <razzi> Hi! i would like to understand how the state monad transformers works
06:07:06 <bwe> Thanks to you advice, lemmih, I've got what I want.
06:08:26 <aasronStone> lemmih : i knew it's not specific to IO but didn't knew how to use otherwise by the way why it's IO by default ??
06:09:00 <lemmih> aasronStone: It's not tied to IO by default.
06:09:04 <lemmih> > return () :: Maybe ()
06:09:07 <lambdabot>  Just ()
06:09:11 <lemmih> > return () :: [()]
06:09:13 <lambdabot>  [()]
06:09:41 <lemmih> :t return
06:09:42 <ertes-w> razzi: hi, great!  so what's your current understanding?
06:09:43 <lambdabot> Monad m => a -> m a
06:10:05 <aasronStone> lemmih : oh nice
06:10:48 <aasronStone> lemmih : return itself is a function defined in monad typeclass ??
06:11:03 <lemmih> aasronStone: Yep.
06:12:21 <aasronStone> lemmih : hey what's the thumb rule to write instance of monad typeclass for a adt ? in other words when do you really wan't an adt to be monad ??
06:12:28 <Psybur> > pure () :: Maybe ()
06:12:31 <lambdabot>  Just ()
06:12:48 <Psybur> When would you ever use return over pure?
06:13:12 <lemmih> aasronStone: You have to follow the monad laws: https://wiki.haskell.org/Monad_laws
06:13:16 <razzi> ertes-w: pretty shallow, i've try few online examples and in the haskellbook, still stuck to understand how we can mix IO with State or Reader!
06:13:46 <ertes-w> razzi: do you understand basic state monads?
06:13:46 * hackage base-compat-batteries 0.10.1, base-compat 0.10.1 (ryanglscott): https://qbin.io/polls-quiz
06:13:47 <aasronStone> lemmih : but when do you want a type to be monad ??
06:15:03 <razzi> ertes-w: yes i do
06:15:08 <lemmih> aasronStone: There are a bunch of functions like 'mapM' that only work with monads. If you want to use those functions then your type constructor has to be a monad.
06:15:22 <merijn> aasronStone: Whenever it's sensibly possible
06:15:22 <ertes-w> razzi: a value of type (State s a) is a state transition function with an additional return value:  s -> (a, s)
06:15:46 <ertes-w> razzi: a value of type (StateT s m a) is a state transition function in the same way, except that it has access to m-effects:  s -> m (a, s)
06:15:52 <ertes-w> razzi: clear so far?
06:15:53 <merijn> aasronStone: If your type *can* be a monad, it means that all the 10s of thousands of lines of code that have been written for Monad automaticaly work for your new type
06:16:17 <merijn> aasronStone: So as a user of your library/type I get all this existing code for free
06:16:30 <razzi> ertes-w: yeah!
06:19:09 <ertes-w> razzi: now (>>=) is the composition function for such state transition functions
06:19:21 <ertes-w> razzi: i recommend that you implement it for yourself
06:19:46 <aasronStone> merijn : that's one obvious reason, but what else ??
06:19:54 <Psybur> Is there ever a case in the latest GHC when pure != return or pure is unavailable? Thats only a problem in legacy GHCs where monads werent necessarily applicatives?
06:20:04 <dminuoso> aasronStone: a `monad` is not a goal, it's rather an emergence.
06:20:15 <dminuoso> aasronStone: Some things are monadic, that is they fit that pattern desribed by
06:20:17 <dminuoso> :t pure
06:20:19 <lambdabot> Applicative f => a -> f a
06:20:20 <dminuoso> :t (>>=)
06:20:21 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:20:23 <dminuoso> + laws
06:20:36 <dminuoso> aasronStone: If it looks like that and follows the laws, you probably want it to be an instance Monad. =)
06:20:57 <Boarders> Psybur: if you have the writer monad but with a semigroup then you don't have pure/return but maybe you had something else in mind
06:21:35 <chisui> Are there any meetups or usergroups that deal with Haskell in northern germany?
06:21:47 <dminuoso> chisui: If you learn of any, let me know. :)
06:21:56 <merijn> Psybur: Well, that could be true even in modern GHC if the author is implementing unlawful instances
06:22:06 <merijn> Psybur: But the correct response to that is lynching the author :p
06:22:09 <dminuoso> ertes-w might know, even though he's from the southern parts.
06:22:28 <razzi> ertes-w: how?
06:22:36 <aasronStone> dminuoso : see like in case of functors we know we want to define a functor instance if the type we are defining can be mapped over , similar with applicative so is there a similar intutition for moand ??
06:22:38 <Boarders> it is weird that the concept of semigroup in the category of endofunctors does not seem to come up
06:22:44 <Boarders> does it go by a different name?
06:22:46 <dminuoso> aasronStone: No.
06:23:02 <dminuoso> aasronStone: Even with `Functor` it's not a good intuition.
06:23:07 <ertes-w> razzi: have you *defined* the basic state monads or just studied them?
06:23:30 <dminuoso> aasronStone: For example "mapping over a function" is a bit problematic, and yet there is an `instance Functor ((->) a)`
06:23:36 <dminuoso> aasronStone: Or the Const Functor.
06:24:27 <Profpatsch> Is a type application exactly the same as specifying a signature?
06:24:42 <Profpatsch> coerce @(Int -> Int) @(Int -> Age) toEnum
06:24:47 <aasronStone> dminuoso : yeah but it's generalized enough if you leave that one case and personally much more intutive
06:24:48 <razzi> ertes-w: no, I simply know how to use them
06:24:56 <Boarders> also why is Data.Set not a functor since I can "map over" it
06:25:03 <dminuoso> Profpatsch: Yeah.
06:25:10 <byorgey> Profpatsch: type application is more fine-grained, but basically yes
06:25:13 <Profpatsch> (coerce :: (Int -> Int) -> (Int -> Age)) toEnum
06:25:16 <dminuoso> Profpatsch: type applications is less cumbersome though because you dont have to specify *all*
06:25:33 <magicman> TIL: With enough LANGUAGE pragmas, you can make a typeclass an instance of a typeclass.
06:25:38 <Profpatsch> THose two are equal, rigth?
06:25:44 <ertes-w> razzi: ok, your first exercise is to implement them for yourself
06:25:47 <byorgey> Profpatsch: yes
06:26:04 <dminuoso> aasronStone: If you already have an `Applicative` you could think of `Monad` as an upgrade. If applicative can sequence two effects via (<*>), then Monad improves that by letting a function decide on the second effect based on the first result.
06:26:17 <ertes-w> razzi: define Functor, Applicative and Monad instances for this type:  newtype State s a = State { runState :: s -> (a, s) }
06:26:18 <Profpatsch> So the advantace of type application is that you can do them partially.
06:26:22 <Profpatsch> *ge
06:26:45 <dminuoso> aasronStone: So a `Monad` is a stronger (in the sense it can do more) version of an Applicative. that has that unique power to "pick an action based on the previous result"
06:27:10 <ertes-w> chisui, dminuoso: nope, sorry…  the only one i know is in munich…  i'm not even aware of any meetups in my area (ba-wü)
06:27:33 <byorgey> Profpatsch: yes, and also that you don't have to specify other stuff which is fixed.  e.g. consider   foo :: forall a.  [[Map Int a]] -> (a -> a -> Bool)
06:27:37 <Psybur> > pure 1 :: (Monad m) => WriterT (First Int) m Int
06:27:40 <lambdabot>  error:
06:27:41 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M441723520120...
06:27:41 <lambdabot>        prevents the constraint ‘(Data.Functor.Classes.Show1
06:27:42 <Boomerang> Profpatsch: not completely equal, you can leave some type "blank" without the need for PartialTypeSignatures. For example: `fromIntegral @_ @Int`
06:27:44 <Psybur> > return 1 :: (Monad m) => WriterT (First Int) m Int
06:27:45 <Profpatsch> It looks like we are going back to a language that resembles System-Fω more closely?
06:27:46 <lambdabot>  error:
06:27:46 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M135139411844...
06:27:46 <lambdabot>        prevents the constraint ‘(Data.Functor.Classes.Show1
06:27:51 <byorgey> to give a type signature you would have to write something like   foo :: [[Map Int Char]] -> (Char -> Char -> Bool)
06:27:56 <Psybur> So what I mean is like when would return work where pure wouldnt and its totally cool
06:27:59 <byorgey> but with type application you can just say  foo @Char
06:28:04 <Profpatsch> e.g. dhall has only explicit type sigs
06:28:11 <dminuoso> ertes-w: Ah the μHUG?
06:28:15 <Profpatsch> err, applications
06:28:27 <Profpatsch> To do polymorphism
06:28:48 <dminuoso> Profpatsch: Also note that if you've ever seen the "Proxy" pattern, that's basically type applications in absence of the extension TypeApplications.
06:29:10 <byorgey> Profpatsch: Uh, there's no way Haskell is "going back" to *requiring* explicit type application.
06:29:31 <byorgey> it's just that it can sometimes be a convenient option to do so explicitly
06:29:46 <razzi> ertes-w: Thus, I need to write the definition of fmap :: (a -> b) -> State s a -> State s b?
06:29:49 <Profpatsch> People seem to prefer it in recent blogposts/papers
06:30:06 <Profpatsch> But maybe that’s because it’s new and shiny. :)
06:30:08 <byorgey> Profpatsch: prefer it to what?
06:30:23 <Profpatsch> Explicit type signatures.
06:30:56 <Profpatsch> I should go and read up on how TypeApplications works then.
06:30:58 <byorgey> Profpatsch: well, sure, if you were just giving an explicit type signature specifically because you wanted to fix some type variable, then why not do it directly.
06:31:02 <dminuoso> Profpatsch: Would you want to write an explicit type signature for *every* let binding, where binding and monomorphization of a polymorphic function? You'd instantly increase the size of your code base by 2 with no benefits.
06:31:08 <Boarders> yeah but you can still have a polymorphic type signature and then use type applications at the call site to specailise
06:31:11 <Boarders> specialise*
06:31:45 <merijn> dminuoso: I already explicitly write a type signature for every let and where binding, tbh
06:32:13 <dminuoso> merijn: Oh interesting. Based on a lot of code Ive seen that's not very common, is it?
06:32:33 <merijn> dminuoso: I dunno, but it's easier to debug shit the more explicit signatures you have and easier to read too
06:33:24 <dminuoso> merijn: I guess that is true. Adding type signatures is a thing I do sometimes when GHC wont shut up. :|
06:33:25 <Profpatsch> Yeah, being explicit helps a lot, especially with stuff like recursion schemes.
06:33:49 <dminuoso> Profpatsch: Then type signatures are probably more readable.
06:34:06 <Profpatsch> always give your algebra :: (f a -> a) a type sig, or you’ll be going crazy. :)
06:34:10 <merijn> dminuoso: Makes pointfree easier to read too
06:34:14 <dminuoso> Profpatsch: The annoying bit about TypeApplications is that you have to be careful about the order of type variables (or use explicit forall)
06:34:33 <merijn> I think TypeApplications is rather obnoxious compared to signatures, yes
06:34:48 <merijn> Profpatsch: You know what I find helps with recursion schemes?
06:35:00 <dminuoso> Profpatsch: for example: `(F b, G a) => a -> b -> a` it's not instantly clear that `b` is the first type variable in this.
06:35:09 <merijn> Profpatsch: Not using them ;p
06:35:29 <Boarders> merijn: yeah I think some of the reputation of pointfree comes from the fact that you have to perform type inference yourself
06:35:43 <merijn> dminuoso: For example, see this code: https://github.com/merijn/cabal/blob/filter-flag-prototype/Cabal/Distribution/Simple/Program/GHC.hs#L51-L216
06:36:02 <merijn> dminuoso: I think the pointfree functions would be really hard to follow without types
06:36:06 <merijn> With the types it's pretty easy
06:36:34 <dminuoso> merijn: Well that's so large it might as well be a separate module, and then "top level bindings should have type signatures" triggers. :P
06:36:57 <merijn> dminuoso: I dislike stuffing things into the top-level when they're only ever used in one place
06:36:59 <Profpatsch> merijn: But they are just so coooooool. :)
06:37:17 <merijn> dminuoso: Also makes it hard to easily share variables
06:37:34 <dminuoso> merijn: Yeah that's fine. I mean in the end the more deeply nested where bindings dont all have type signatures, like this: https://github.com/merijn/cabal/blob/filter-flag-prototype/Cabal/Distribution/Simple/Program/GHC.hs#L119
06:37:44 <merijn> dminuoso: e.g. all the uses of "from" only work because it's in the where clause
06:38:02 <dminuoso> Heh. from :: Monoid m => [Int] -> m -> m
06:38:04 <merijn> dminuoso: That's more an oversight by me, though
06:38:08 <ertes-w> razzi: yeah
06:38:15 <dyl> I have a full prison style back tattoo of ~20 recursion schemes.
06:38:23 <dyl> It's decorated with ornamental bananas, lenses, and barbed wire.
06:38:28 <ertes-w> dminuoso: the one that advertises on haskell-cafe
06:38:42 <merijn> dminuoso: Well, initially I had "[Int] -> [String] -> [String]", but then I needed to enable some of the filter functions conditionally and realised "from" actually works for any monoid :p
06:38:51 <merijn> dminuoso: Since it's just "mempty" for older versions
06:39:07 <dminuoso> merijn: yeah. I was just smiling because you actually talked Monoid earlier.
06:39:28 <merijn> dminuoso: Well, the earlier remarks were triggered by the realisation I could generalise it :p
06:39:37 <merijn> dminuoso: Also, that code has like 6 different monoids going on :p
06:39:52 <merijn> dminuoso: Any, All, Endo, list, and function monoid :p
06:40:00 <merijn> oh, and First!
06:40:08 <dminuoso> Not sure what the function monoid would be useful for though.
06:40:22 <dyl> So, it just occurred to me, the reason we can define Functor in terms of fmap is (concisely) Yoneda, yes?
06:40:26 <merijn> dminuoso: line 75
06:40:27 <dyl> Is my intuition here correct?
06:40:28 <dminuoso> I mean it kind of does look like "Monoid distributes over (->)" in a weird way
06:41:31 <merijn> dminuoso: Function monoid is nice when gathering up results from several functions
06:41:44 <dminuoso> merijn: So I take it that CompilerFlavor is a Monoid too?
06:41:56 <merijn> dminuoso: No, the result monoid there is the list
06:42:14 <merijn> dminuoso: It's just applying each function on line 75 in a row, then concat'ing all the resulting lists
06:42:59 <merijn> dminuoso: Also, the function monoid applies recursively, so it can be used to mconcat functions of any number of arguments
06:44:38 <razzi> ertes-w: How do you think of, "instance Functor (State s) where fmap f (State fn) = State (\s -> (f (fst (fn s)), snd (fn s)))"
06:45:14 <dminuoso> merijn: Wait a second. `options :: BuildInfo -> [(CompilerFlavor, [String])]` right?
06:45:38 <merijn> dminuoso: Yes
06:45:42 * hackage catamorphism 0.6.1.1 - Exposes a Template Haskell function for generating catamorphisms.  https://hackage.haskell.org/package/catamorphism-0.6.1.1 (frerich)
06:45:58 <dminuoso> merijn: Ohh! I didn't spot the outer list! All good. :)
06:46:12 <dminuoso> Thought that was just `BuildInfo -> (CompilerFlavour, [String])`
06:46:28 <merijn> That'd only work if you had a CompilerFlavour monoid, yeah
06:46:28 <ertes-w> razzi: it's a start, but it can be improved a lot simply by using a let binding
06:46:36 <dyl> Question: what is worth checking out (for studying purposes, less than practicality) with respect to LR parsing in Hackage?
06:46:50 <merijn> dminuoso: But the alternative of applying all of those functions manually is really obnoxious to write out :)
06:46:51 <ertes-w> razzi: \s' -> let (x, s) = f s' in …
06:47:02 * dyl is trying to get a better feel for bottom up and chart parsers in Haskell in particular.
06:47:11 <merijn> dyl: As in parser generators? Or just as in parser writing
06:47:18 <dyl> As in parser writing.
06:47:21 <dminuoso> merijn: I think I should reserve a day of the week where I just browse through typeclass instances.
06:47:34 <dminuoso> Im sure there's plenty of hidden gems.
06:47:36 <dyl> Basically stuff that isn't the parsec family.
06:47:52 <merijn> dyl: trifecta
06:47:59 <merijn> dyl: Also the stuff UHC uses
06:48:08 <dyl> I would consider trifecta pretty similar to the parsec family, I guess?
06:48:11 <merijn> I forgot what they're called
06:48:15 <dyl> Maybe that speaks to my ignorance of the internals.
06:48:48 <razzi> ertes-w: Oh yeah! now Applicative
06:49:46 <dyl> Eh, I can also probably just translate my grammar and use megaparsec.
06:50:41 <byorgey> megaparsec is pretty nice.
06:50:56 <byorgey> trifecta looks really cool and powerful and I have no idea how to use it.
06:51:09 <ertes-w> byorgey: the same way you use any other parsing library
06:51:33 <byorgey> that's easy to say but the devil's in the details.
06:51:46 <merijn> byorgey: The trick is that you have to ignore everything in the trifecta package
06:51:51 <merijn> byorgey: The real code is in parsers
06:52:10 <dyl> "We factored the parsing out of the parsing library."
06:52:23 <byorgey> wow, that is a trick.
06:52:40 <merijn> byorgey: Also, my basic parser has functioned as a tutorial for trifecta for like 10 people already, apparently, so: https://github.com/merijn/lambda-except/blob/master/Lexer.hs https://github.com/merijn/lambda-except/blob/master/Parser.hs
06:52:53 <merijn> byorgey: Please ignore the fact that the typechecking and everything is utterly broken and buggy :p
06:52:56 <byorgey> merijn: cool, thanks
06:53:17 <byorgey> "Congratulations, Mario, you found the trifecta package! But the princess is in another castle"
06:53:23 <merijn> Actually, I think Lexer.hs is the only one you need
06:53:32 <merijn> Parser.hs is just boring parsec style parsers
06:54:22 <dyl> New library: parswreck – parses exclusively ambiguous grammars using an RNG to select productions
06:54:59 <dyl> "It works 100% of the time, 70% of the time."
06:56:56 <ertes-w> byorgey: either use one of the high-level interfaces in Text.Trifecta.Parser or use the incremental interface starting with 'stepParser'
06:57:02 <ertes-w> in the same module
06:57:40 <ertes-w> other than that you'll find pretty much the same combinators as in most other libraries, and it's a voluntary backtracking parser, so you'll have to use 'try'
07:01:12 <dyl> Megaparsec on Trifecta vs Megaparsec: "Complicated, doesn't have any tutorials available, and documentation doesn't help at all."
07:01:22 <dyl> Hah, don't they know that the documentation is all on IRC?
07:02:59 <merijn> dyl: They forgot to mention: "but has really pretty error messages"
07:04:34 <dyl> merijn and you get the special feature that when a user experiences a compiler error, edwardk appears in a puff of smoke behind them and gives them a primer on chart parsing.
07:04:42 <dyl> It's truly what sets it apart.
07:05:00 <merijn> dyl: No, he just gives you commit access to the repo and says "go ahead and fix it"
07:05:24 <dyl> "the repo" meaning whatever you implemented with trifecta, not just trifecta itself.
07:05:46 <dyl> Can anyone point me to a "why" on Proxy?
07:06:02 <dyl> Is it basically just to pass type parameters?
07:06:09 <dyl> So, just a type-witness?
07:08:39 <tdammers> pretty much, yes
07:09:24 <tdammers> typically, you'd use it to resolve instances when otherwise no reference to one of the typeclass arguments could be inferred
07:09:39 <dyl> Aahhhh I see.
07:10:24 <tdammers> e.g., say you have class Flub a b where { flubAppend :: a -> b -> a; flubEmpty :: b }
07:10:24 <dminuoso> dyl: Type applications without TypeApplications. :P
07:10:45 <tdammers> but that doesn't work, because you can't infer a from flubEmpty, so you can't tell which instance to use
07:10:59 <dyl> edwardk I saw your monoidal parsing talk btw, I wonder how that would play with something like APL where the rule of thumb is "the argument is the result of evaluating everything to the right"
07:11:13 <dyl> It seems like in theory you could make use of that property (with some ironing out of kinks in the language).
07:11:24 <tdammers> so: flubEmpty :: Proxy a -> b -- now you can tell which a to use
07:11:53 <dyl> How would one be able to use TypeApplications there? I don't see how it would immediately be possible.
07:12:12 <dyl> I'm not familiar with the syntax though.
07:12:13 <tabaqui2> how can I "Language.Haskell.TH.reify" some Type?
07:12:33 <dminuoso> dyl: instead of `f (Proxy :: T)` you just use `f @T` instead
07:12:37 <tabaqui2> I want all data constructors of the type, but reify works with Name
07:12:48 <tabaqui2> and I don't see Type -> Name function in the module
07:13:26 <dyl> I mean dminuoso, I don’t see how it would know what type parameter you’re applying when it’s part of a class.
07:13:43 <dyl> The a isn’t in the signature of flubEmpty explicitly to apply to.
07:13:54 <dminuoso> dyl: It is.
07:14:02 <dminuoso> dyl: `flubEmpty :: forall b. b`
07:14:10 <dminuoso> dyl: that takes one type parameter.
07:14:11 <dyl> But a?
07:14:29 <dminuoso> dyl: You pass them in order of appearance. Dont think you can do named type application.
07:14:36 <dyl> Right but here we were talking about providing the a parameter, not h.
07:14:37 <dyl> B*
07:14:40 <hanDerPeder> what's the tersest way to compose these functions? https://pastebin.com/HdYFVzKH
07:18:15 <tabaqui2> oh, nevermind :)
07:20:34 <dminuoso> dyl: Actually sorry that was wrong. flubEmpty :: forall a b. (Flub a b) => b
07:20:39 <dminuoso> dyl: so you have `a` and `b` in order
07:20:52 <dminuoso> so you could just do `flubEmpty @T`
07:20:53 <dyl> Ah okay, that's what I was wondering, if the Flub a b is implied.
07:21:05 <dyl> Roger roger.
07:21:11 <dminuoso> dyl: This requires AllowAmbiguousTypes to work at any rate.
07:21:44 <dyl> We need a linting plugin that analyzes your language pragmas and gives files a "black magic complexity".
07:21:54 <dyl> It goes from 0 to 10, and then Conal/EdK.
07:22:13 <dyl> {#- LANGUAGE ScrewItAllOfThem #-}
07:22:43 * hackage temporary 1.3 - Portable temporary file and directory support  https://hackage.haskell.org/package/temporary-1.3 (RomanCheplyaka)
07:24:28 <dyl> {#- LANGUAGE FullMetalFootGun #-}
07:24:36 <dyl> HigherKindedFootGun*
07:25:40 <Hafydd> AllowEldritchTypes
07:26:21 <lyxia> hanDerPeder: http://lpaste.net/364653
07:29:23 <hanDerPeder> lyxia: nice, thanks!
07:33:48 --- mode: ChanServ set +b topaz*!*@*
07:33:48 --- kick: Topazzz was kicked by ChanServ (Banned: zptao)
07:38:49 <dyl> "Success has come to our language."
07:38:50 <dyl> "You remember our venerable language, opulent and imperial, gazing proudly from its stoic perch above the ivory tower."
07:39:19 <dyl> "It is a festering abomination!"
07:40:01 <Cale> lol
07:44:31 <muuaka> http://www.seas.upenn.edu/~cis194/fall16/  is this not very short ? I Want to suggest a friend
07:46:11 <muuaka> is this inactive channel
07:46:44 <ski> it can be pretty active
07:46:48 <muuaka> !guide
07:46:57 <muuaka> !books
07:47:13 <Cale> I don't understand the question
07:47:21 <ski> i think usually people would suggest an earlier version of CIS194
07:47:26 <ski> @where CIS194
07:47:26 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
07:47:36 <ski> @where books
07:47:36 <lambdabot> See `LYAH',`RWH',`YAHT',`HR',`PIH',`wikibook',`PCPH',`HPFFP',`HTAC',`FoP',`PFAD',`non-haskell-books'
07:47:51 <ski> @where
07:47:51 <lambdabot>  @where <key>, return element associated with key
07:47:54 <Cale> Yeah, the Spring '13 one is the most popular
07:48:00 <ski> @where PIH
07:48:00 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
07:48:03 <muuaka> http://www.seas.upenn.edu/~cis194/fall16/   it is CIS 194 but its very short
07:48:06 <ski> @where HPFFP
07:48:06 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
07:48:23 <gchristensen> koala_man: I'm interested in extending shellcheck to, if PATH is set to an absolute value (ie: PATH=/foo/bin, not PATH=/foo/bin/:$PATH) to ensure every program called is in the declared path. does that seem possible?
07:50:35 <ertes-w> why do people prefer spring13 over the most recent one?
07:50:36 <ertes-w> (CIS 194)
07:51:41 <dminuoso> ski: So how does it feel to be turing complete by the way?
07:52:18 <Boarders> ertes-w: the most recent one looks like it makes heavy use of CodeWorld to do some graphics and things like that
07:52:25 <ski> hm, i don't know -- ask a Turing complete language for expressing computation ?
07:52:43 * hackage haskell-src-exts-sc 0.1.0.6 - Pretty print haskell code with comments  https://hackage.haskell.org/package/haskell-src-exts-sc-0.1.0.6 (achirkin)
07:52:44 <Boarders> the original 2013 is quite self-contained and has instructive exercises imo
07:52:54 <ertes-w> i see
07:53:06 * dminuoso does not think they got the joke
07:54:03 <monochrom> ski: I think dminuoso means that SKI is one of those Turing-complete languages :)
07:54:22 <dyl> Enterprise SKI.
07:54:35 <ski> oh .. untyped SKI, in that case
07:54:51 <nkaretnikov> is cpphs-1.20.8 broken on macos or something? i get a bunch of undefined symbol errors when trying to build it via stack
07:55:44 <ski> Cale : hm, i was wondering about the notion of "prime derivative" (or however it's called) you mentioned a while ago, whether it's defined for zero
07:57:07 <Cale> https://en.wikipedia.org/wiki/Arithmetic_derivative
07:57:17 <ski> ty
08:02:13 <ski> muuaka : how about a textbook (a couple suggested above), if you want something more extensive ?
08:03:48 <muuaka> ski none of them are free
08:04:08 <muuaka> I always suggest free ones
08:04:15 <muuaka> and completely against piracy
08:04:43 <T0PAZZZ> Hi
08:06:14 <ski> muuaka : maybe the wikibook ?
08:06:33 <ski> hello T0PAZZZ
08:06:40 <Boarders> muuaka: I liked http://legacydirs.umiacs.umd.edu/~hal/docs/daume02yaht.pdf
08:06:53 <ski> @where YAHT
08:06:54 <lambdabot> "Yet Another Haskell Tutorial", Hal Daume III,<http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>,<http://hal3.name/docs/daume02yaht.p(df|s)>,<http://darcs.haskell.org/
08:06:54 <lambdabot> yaht/yaht.p(df|s)>
08:07:04 <ski> @where wikibook
08:07:05 <lambdabot> http://en.wikibooks.org/wiki/Haskell
08:09:45 <muuaka> Boarders:  hal daume 3 seen him somewhere else Is he famous guy ?
08:10:54 <Boarders> I am not familiar with him, sorry
08:12:09 <Boarders> @where RWH
08:12:09 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:13:23 <muuaka> Boarders:  HE sounds awesome he is publishing form 2001
08:15:03 <freeman42x]NixOS> is Lamdu used for Haskell programming language? (I can't find that mentioned in any obvious place) https://github.com/lamdu/lamdu
08:15:16 <dminuoso> What is the relationship between Traversable and Foldable?
08:15:19 <dminuoso> :t traverse
08:15:21 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:15:22 <dminuoso> :t foldMap
08:15:25 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
08:15:34 <freeman42x]NixOS> at some point I thought that Lamdu was used on some derivative of Haskell, kinda like Purescript, but I am not so sure anymore
08:16:58 <ski> freeman42x]NixOS: you could try asking Peaker, if he was around atm ..
08:17:45 <Boarders> :t traverse_
08:17:46 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
08:18:05 <freeman42x]NixOS> ski, it is so important that it requires an issue on the repository and fix imo
08:19:58 <muuaka> I am generating too many bat files by writing files from my program in order to achieve certain task, is that a bad approach to generate so many bat files?
08:20:27 <ski> `Traversable' allows one to generate a new datastructure, having the same structure as the one which one was traversing over
08:20:28 <freeman42x]NixOS> you can imagine users being like: woah, Lamdu is so cool! but, ehm, what language is it useful for? looks like Haskell
08:20:28 <dminuoso> Boarders: traverse_ is not enough to describe Foldable though.
08:20:28 <dminuoso> And foldMap seems far more defining than foldr
08:20:37 <ski> `Foldable' is roughly `ToList'
08:21:17 <ski> (there was a blag somewhere explaining why the latter isn't quite true, but i can't seem to find it atm)
08:22:53 <ski> dminuoso : what if you use `traverse_ :: (Monoid m,Foldable t) => (a -> Writer m b) -> (t a -> Writer m ())' ?
08:22:53 <Boarders> if 'Foldable' is 'ToList' then Traversable is 'ToList' plus having a shape: t ()
08:23:44 <mnoonan> ski: maybe here: http://comonad.com/reader/2015/free-monoids-in-haskell/ where they use an infinite snoc list as something foldMap-able, but not really toList-able
08:24:42 <dminuoso> mnoonan: Ah that looks like it might give me my answers. Thanks.
08:24:47 <ski> @type (execWriter .) . traverse_ . (curry writer () .)
08:24:48 <lambdabot> (Monoid w, Foldable t) => (a -> w) -> t a -> w
08:24:52 <ski> @type foldMap
08:24:53 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
08:25:09 <dminuoso> ski: Okay I take that back. :o
08:25:34 <ski> mnoonan : hm, yes, that was the one i was thinking about. ty :)
08:26:16 <Boarders> what is a good example of something with a Foldable instance but not Traversable?
08:26:32 <applePrincess> Hello, can I create/define an 'unary' operator? I know it is just a function application with a one argument. And the point is not whether it is useful or not.
08:26:54 <ski> applePrincess : what is it supposed to do ?
08:27:13 * hackage ekg-statsd 0.2.3.0 - Push metrics to statsd  https://hackage.haskell.org/package/ekg-statsd-0.2.3.0 (MikhailGlushenkov)
08:27:28 <glguy> applePrincess: You can define postfix operators as seen here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=postfixoperators#extension-PostfixOperators
08:27:41 <applePrincess> ski : I do not care what it does, it can just be the 'id' function.
08:27:53 <dyl> Boarders: can you come up with something foldable that isn’t a functor?
08:28:07 <dyl> An unordered set might work, for example.
08:28:16 <glguy> > let (++) x = x+1 in (10++)
08:28:17 <Boarders> I guess set
08:28:18 <lambdabot>  11
08:28:18 <Boarders> yeah
08:28:22 <applePrincess> glyguy : thank you! I will have a look!
08:29:17 <ski> applePrincess : `unary :: (a -> b) -> a -> b; unary f x = f x' ?
08:29:33 <ski> applePrincess : this is called `($)', btw
08:29:34 <dyl> One example I found Boarders
08:29:36 <dyl> data Weird a = Weird a (a -> a)
08:29:48 <dyl> instance Foldable Weird where { foldMap f (Weird a b) = f $ b a }
08:30:29 <dyl> ?free foldMap :: Monoid m => (a -> m) -> t a -> m
08:30:29 <lambdabot> Extra stuff at end of line
08:30:35 <ski> not `.. = a <> f (b a)' ?
08:30:54 <dyl> ?free foldMap :: (a -> m) -> t a -> m
08:30:54 <lambdabot> Extra stuff at end of line
08:31:00 <dyl> Ah whoops
08:31:02 <applePrincess> ski: Hmmmm... yeah, but `($)' taks two arguments, doesn't it?
08:31:23 <ski> all functions take one argument, in Haskell
08:31:28 <ski> gotta leave ..
08:32:45 <ertes-w> applePrincess: for prefix unary operators you can just use the regular prefix syntax
08:32:58 <ertes-w> (!%&) x
08:33:13 <Boarders> dyl: this is nice because you can think of a way to convert Weird to a list
08:33:21 <ertes-w> unlike postfix operators you don't need an extension
08:33:45 <Boarders> but Weird () ~ () so you are not going to be able to re-construct it from a 'shape'
08:34:46 <ertes-w> Weird is really just an awkward stream type
08:35:06 <ertes-w> data NotSoWeird a = forall s. NotSoWeird s (s -> (a, s))
08:35:08 <applePrincess> ertes-w: seems like I can use prefix syntax and PostfixOperators as glguy mentioned.
08:35:15 <jackcrfs> stupid newbie question: "until (> 100) (*2) 1" works great, but suppose I want to print every intermediate value?
08:35:52 <applePrincess> Thank you, I will try!
08:35:53 <glguy> Then you wouldn't use (until), you'd use some other function
08:36:01 <ertes-w> jackcrfs: you can't use 'until' for that, but you can simply use 'iterate' and 'traverse_'
08:36:06 <Taneb> jackcrfs: you can use the iterate and takeWhile functions for this, for example
08:36:14 <jackcrfs> thanks! will try.
08:36:15 <ertes-w> jackcrfs: add 'takeWhile'
08:36:29 <jackcrfs> many thanks!
08:36:49 <Cale> > takeWhile (< 100) $ iterate (*2) 1
08:36:52 <lambdabot>  [1,2,4,8,16,32,64]
08:37:28 <dyl> Can anyone come up with something that is Foldable and Functor but not Traversable?
08:37:36 <dyl> Or is every Traversable both?
08:37:59 <jackcrfs> o.O wooooow! takeWhile is magical!
08:38:05 <dyl> Put another way, does Functor & Foldable ⇒ Traversable?
08:38:34 <ertes-w> jackcrfs: takeWhile isn't, but haskell is…  takeWhile is a straightforwardly defined list function, but thanks to laziness it just works
08:39:09 <dyl> Whatever happened with Cloud Haskell?
08:39:14 <ertes-w> dyl: for algebraic data types yes, but something like Set is not Traversable
08:39:19 <jackcrfs> magical, I started on Haskell today!  feels like a dream.
08:39:20 <dyl> (The Erlang-esque thing)
08:39:54 <Taneb> ertes-w: something like Set is not Functor, either
08:40:02 <ertes-w> true
08:40:26 <ertes-w> well, every Traversable is a Functor
08:40:36 <dyl> Also jackcrfs welcome to what is arguably the friendliest and most helpful channel on freenode.
08:41:07 <jackcrfs> agree it's VERY friendly and VERY helpful
08:41:13 * hackage generic-trie 0.3.1 - A map, where the keys may be complex structured data.  https://hackage.haskell.org/package/generic-trie-0.3.1 (EricMertens)
08:41:25 <ertes-w> :t Data.Traversable.fmapDefault
08:41:27 <lambdabot> Traversable t => (a -> b) -> t a -> t b
08:41:48 <dyl> Okay, so every Traversable is a Functor.
08:42:01 <dyl> Is every Foldable that is not Traversable not a Functor?
08:42:01 <ertes-w> dyl: that's the dual question though
08:42:20 <dyl> Er sorry
08:42:30 <ertes-w> as to whether Functor implies Traversable i'm inclined to say no, but i can't think of a simple example
08:42:42 <dyl> That’s what I mean
08:43:01 <ertes-w> the trouble is that you can't derive 'traverse' from 'fmap'
08:43:19 <dyl> So could there be a type that is Foldable and Functor but not Traversable?
08:43:19 <Boarders> what about just a representable functor: type Blah = (->) Int
08:43:22 <dyl> Hmm
08:43:33 <Boarders> I think that is a Functor and Foldable but not Traversable
08:43:37 <ertes-w> Boarders: that one is Traversable, if you newtype-wrap it
08:44:07 <ertes-w> (you would have to write the instance by hand though)
08:44:16 <Boarders> ah fair enough
08:44:23 <ertes-w> even if you replace Int by Integer it's still Traversable
08:44:51 <dyl> In any case the best example I can think of for Foldable but not Traversable is a collection without structure/ordering/etc to preserve (like Set).
08:45:27 <ertes-w> dyl: Set is not algebraic…  any example of that will be non-algebraic
08:45:30 <dyl> Something you can in theory “reduce” but not inspect the structure of.
08:45:43 <dyl> How do?
08:45:45 <dyl> So*?
08:45:49 <ertes-w> although i'm not entirely sure whether that's true if you enable some extensions
08:45:56 <Boarders> ertes-w: what about: type = (->) Tree Int
08:46:27 <dyl> Tree -> Int isn’t of the right kind though?
08:46:52 <Boarders> I meant type = (->_ (Tree Int)
08:46:54 <Boarders> ahh
08:47:02 <Boarders> ype = (->) (Tree Int)
08:47:09 <Boarders> ok can't type
08:47:14 <ertes-w> dyl: my reasoning is: DeriveTraversable derives a Traversable instance for every algebraic type that doesn't involve functions…  if a function with a countable domain is involved, it's still Traversable, and if it's not countable, then it's not Foldable (i think)
08:47:38 <ertes-w> newtype NonFoldable a = NonFoldable ((Integer -> Bool) -> a)
08:48:53 <tom> Does anyone use Nix to manage their dependencies for their repos?
08:48:58 <ertes-w> however, there isn't really a law that prevents NonFoldable from being Foldable =/
08:49:04 <ertes-w> Guest92011: i do
08:49:21 <Guest92011> How do you add a haskell package
08:49:27 <dyl> I’m thinking abstractly of say, real valued intervals. Though again not algebraic.
08:49:36 <Guest92011> and update all necessary config?
08:49:46 <dyl> You can’t really traverse a real valued interval meaningfully, but reduction (integration) makes sense.
08:49:52 <dyl> Not really the same thing though.
08:50:29 <ertes-w> Guest92011: for regular external dependencies you would just use your .cabal file, and cabal2nix will pick up on it
08:51:13 <ertes-w> Guest92011: for internal dependencies my approach is to extend the haskellPackages set via haskellPackageOverrides
08:51:14 <dyl> Does anyone think Haskell will ever have a major GHC competitor?
08:51:29 <lemmih> dyl: I kinda do.
08:51:37 <Guest92011> Thanks ertes-w
08:52:09 * dyl is trying to figure out how one could have eval in a compiled language nicely.
08:52:19 <dyl> Seems like you’d have to include a subset of the compiler in the runtime.
08:52:36 <dyl> It would blow up the binary size hugely.
08:52:59 <lemmih> dyl: GHCi is a Haskell program that includes eval.
08:53:11 <lemmih> Not sure how nice it is, though.
08:53:51 <dyl> One clever thing I saw: the Swift REPL is actually a thin wrapper around LLDB.
08:54:03 <dyl> It starts as an empty binary, and JIT/inserts each line
08:54:10 <dyl> Makes a lot of sense actually.
08:54:25 <dyl> (And debugging is easy because you’re already in the debugger.)
08:55:15 <dstolfa> dyl: lldb wrappers are quite nice. i wrote a thing that monitors execution of the fuzzee and builds a blame graph for functions out of it over different iterations in a couple of hundred lines of code
09:04:13 <rkennedy> Does anyone know why these types don't unify (or, I suspect they do, but I may be missing something): data A = A {unA :: Int} | A' {unA' :: [Int]}; deriveLensesFor [("unA","a"),
09:04:34 <rkennedy> ("unA'","a")]
09:05:14 <rkennedy> But there seems to be a clear traversal that isn't too bad to write. I have no problem writing that traversal by hand, just wondering if I'm missing anything insight
09:06:18 <ertes-w> rkennedy: you're talking about the (Traversal' A Int) that focusses on all Ints?
09:07:39 <rkennedy> Yeah exactly
09:08:01 <ertes-w> rkennedy: no, you're not missing anything, it's just that the lens library won't make* it for you
09:08:33 <ertes-w> rkennedy: however, if you generalise and derive the Traversable instance, then you get it for free
09:09:09 <ertes-w> @let data A a = A { unA :: a } | A' { unA' :: [a] } deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
09:09:12 <lambdabot>  Defined.
09:09:29 <ertes-w> > (traverse *~ 10) (A' [1,2,3])
09:09:33 <lambdabot>  A' {unA' = [10,20,30]}
09:10:29 <nkaretnikov> https://usercontent.irccloud-cdn.com/file/KGSEgBqm/image.png
09:10:40 <nkaretnikov> what's the rationale for placing bangs here?
09:11:00 <rkennedy> That is tight, appreciate the confirmation, though in this case it's just a particular and extremely monomorphic field. Thanks ertes-w!
09:11:08 <nkaretnikov> just do it for every type with a single constructor?
09:11:21 <ertes-w> nkaretnikov: it makes the fields strict, so as soon as you evaluate the root, you evaluate the whole data structure
09:12:24 <nkaretnikov> ertes-w: okay, got it. i somehow missed that bangs are used here consistently everywhere.
09:12:36 <ertes-w> nkaretnikov: no, there is no rule of thumb, it depends on how much strictness you want
09:13:04 <nkaretnikov> ertes-w: yeah, i get it. but here it just means i want this data structure to be strict, right? will it be evaluated to nf?
09:14:07 <ertes-w> nkaretnikov: it means you want it to be *unconditionally* strict…  if you leave out the bangs you would have to make sure your functions keep everything evaluated, but if your application requires that everything is in NF all the time anyway, might as well bang everything
09:15:07 <nkaretnikov> ertes-w: what about the "strict on the leaves" style? when is it beneficial as compared to not having strictness at all, or does it not make sense in any case since one you get to the leaves, you don't need thunks?
09:15:33 <nkaretnikov> once*
09:16:28 <nkaretnikov> i'm referring to this: https://johantibell.com/files/haskell-performance-patterns.html#(5)
09:17:09 <nkaretnikov> oh, no that's the strict spine, which is the opposite
09:17:11 <ertes-w> nkaretnikov: for most applications it's actually more reasonable to have a strict *spine* and non-strict leaves
09:17:54 <nkaretnikov> ertes-w: i think i've heard dons saying "strict on the leaves" on the haskell case, but i'm not motivated enough to re-listen just for that
09:18:29 <ertes-w> nkaretnikov: strict on the leaves can make sense, but it's more for very specific applications…  you'll know when you need it
09:19:19 <nkaretnikov> ertes-w: and what's the benefit of having a strict spine as compared to a full lazy data structure? like if you pattern match on a parent node, would you force its children anyway by doing some work?
09:19:30 <ertes-w> nkaretnikov: however, one important consideration is that strict fields of "small" types can be inlined in memory, so you save one pointer indirection
09:19:34 <nkaretnikov> wouldn't*
09:19:50 <ertes-w> nkaretnikov: this happens for enumeration types and all machine-sized standard types like Int
09:19:58 <nkaretnikov> ertes-w: unpacked, you mean?
09:20:04 <ertes-w> nkaretnikov: yeah
09:20:10 <nkaretnikov> ertes-w: yeah, i'm aware
09:20:34 <nkaretnikov> (please look at the question above regarding the strict spine)
09:20:55 <ertes-w> nkaretnikov: the advantage of the strict spine is mostly avoiding performance problems by forgetting to force properly
09:21:58 <ertes-w> i'm not 100% sure about this one, but it might also trigger GHC optimisations
09:22:00 <nkaretnikov> ertes-w: so, as i understand it, the performance problem may be caused by delaying evaluation to some unfortunate time, when it causes a spike, right?
09:22:20 <nkaretnikov> a spike in memory usage, i mean
09:22:39 <ertes-w> nkaretnikov: delays are a minor issue, but you might be building up unevaluated expressions and then discharge them all at once, which causes unnecessary allocations
09:22:46 <ertes-w> and allocations are performance killers
09:23:16 <nkaretnikov> ertes-w: just because you need to talk to the os to request memory?
09:23:43 * hackage filestore 0.6.3.2 - Interface for versioning file stores.  https://hackage.haskell.org/package/filestore-0.6.3.2 (JohnMacFarlane)
09:23:44 <ertes-w> GHC allocates from the OS in blocks and manages them on its own, but it's still work
09:23:46 <nkaretnikov> ertes-w: so is this the issue solved by arena-style allocators?
09:24:08 <ertes-w> i'm not familiar with that term
09:24:46 <nkaretnikov> you allocate a chunk of memory (more than you need) at the start of an application, then manage that pool youreself
09:25:17 <ertes-w> nkaretnikov: the thing is:  GHC handles short-lived memory objects super-efficiently…  anything that has a statically known lifetime is "short-lived" in that sense
09:25:34 <nkaretnikov> yeah, yeah, i know about that.
09:25:42 <nkaretnikov> okay, thanks for clearing some things up
09:25:48 <ertes-w> as soon as you build up expressions recursively that static knowledge is gone, and now you're putting weight on GC…  now memory management involves actual algorithms and allocation
09:26:25 <nkaretnikov> would be neat to benchmark this stuff. i wonder if there's a blogpost hiding somewhere that does this already (besides johan's/bos' slides)
09:27:08 <ertes-w> nkaretnikov: i'm not really sure what the rationale for that is, but i suppose OS allocation is slower, and with a custom allocator the compiler can use language-specific algorithms that the OS can't use
09:28:02 <nkaretnikov> yeah, by doing so you're basically claiming that you are going to build a better allocator yourself :)
09:28:09 <nkaretnikov> otherwise, it doesn't make sense
09:28:14 <ertes-w> for example GHC doesn't free individual objects, but all dead objects of a generation in a single GC run
09:28:33 <nkaretnikov> hence the "generational", yep yep
09:29:26 <ertes-w> and it actually doesn't really "free" them (freeing is not an explicit operation), but rather simply forgets about them
09:32:13 * hackage sparrow 0.0.1.3 - Unified streaming dependency management for web apps  https://hackage.haskell.org/package/sparrow-0.0.1.3 (athanclark)
09:36:45 <rotaerk> I see a call to ghc passing this argument: --ghc-option=-optl=-Wl,-rpath=somepath
09:37:16 <rotaerk> Where can I find documentation for the stuff after optl?
09:37:27 <cocreature> rotaerk: those flags are just passed on to the linker
09:37:36 <cocreature> so take a look at the gcc docs
09:37:50 <rotaerk> Oh so gcc is used to link? K
09:38:31 <cocreature> gcc will then call ld and pass the rpath option
09:39:14 <cocreature> so the gcc docs will tell you what -Wl does (pass the flag on to the underlying linker) and the ld docs will tell you what rpath does
09:39:30 <rotaerk> Ah, thanks
09:39:46 * hackage shake-ats 1.8.0.0, ats-pkg 2.10.0.0 (vmchale): https://qbin.io/saints-fleece
10:07:43 * hackage species 0.4.0.1 - Computational combinatorial species  https://hackage.haskell.org/package/species-0.4.0.1 (BrentYorgey)
10:23:43 * hackage massiv 0.1.5.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.1.5.0 (lehins)
10:25:04 <Ivan__1> dyl : 16:41 : it seems every t of kind * -> * is foldable, albeit with rather degenerate structure: foldMap _ _ = mempty
10:25:43 * hackage massiv-io 0.1.2.0 - Import/export of Image files into massiv Arrays  https://hackage.haskell.org/package/massiv-io-0.1.2.0 (lehins)
10:31:17 <lts> I'm currently implementing a B+ Tree in haskell, and have come across a problem. The leaves of the tree are linked with each other (a "next" entry in the data type) and form a linked list like structure. However, since these are not pointers, when one of the leaves is updated, what should be the correct way of propogating the changes to the previous leaf ? One approach which came to me was to maintain a
10:31:18 <lts> "prev" entry, although in that case the change will have to be propogated till the head of the linked list. This is how my data-type looks: https://github.com/shivansh/goDB/blob/master/src/BPlusTree.hs#L10
10:38:13 * hackage unliftio-pool 0.1.0.0 - Data.Pool generalized to MonadUnliftIO.  https://hackage.haskell.org/package/unliftio-pool-0.1.0.0 (BardurArantsson)
10:40:04 <Eduard_Munteanu> lts, it may be possible to tie the knot to maintain linked leaves, but ultimately it can't be done nicely and efficiently with an ADT. You kinda need explicit pointers.
10:40:13 * hackage clif 0.1.1.0 - A Clifford algebra number type for Haskell  https://hackage.haskell.org/package/clif-0.1.1.0 (maaleske)
10:44:43 <Eduard_Munteanu> This also makes the trees serializable, which you probably want because B+trees aren't all that useful in memory only.
10:48:07 <lts> Eduard_Munteanu: Thanks. by "explicit pointers" do you mean that there is some way to achieve those in haskell ? Or is it that I do need to explicitly propogate the changes all the way up to the head
10:49:09 <dyl> Are twisted functors or observable sharing relevant here?
10:49:09 <cocreature> lts: I don’t know enough about btrees to help you but it might be nice to look at an existing Haskell implementation, e.g., https://hackage.haskell.org/package/haskey-btree is a pretty recent implementation
10:49:45 <lts> cocreature: thanks for the link
10:49:45 <Eduard_Munteanu> lts, you can use pointers or some storage-specific offsets in Haskell. Or you can wrap a C implementation of B+trees.
10:49:50 <cocreature> lts: IORefs can replace some uses of pointers. or just store integer ids and have a separate map from those ids to the values stored at that link
10:50:01 <Unhammer> Propagating like that is what I did first time I ever tried making a (trie-like) data structure in haskell. Wasn't pretty, but maybe I just didn't know what I was doing.. This time I probably would have used runST
10:51:52 <Eduard_Munteanu> A map kinda defeats the purpose of direct pointer access.
10:52:37 <Unhammer> lts https://wiki.haskell.org/Monad/ST
10:53:56 <ertes-w> lts: if an ADT is a fixed point of a functor F, then you can use (Fix F) for the "pure" representation, but you can now use something like (F Key), where Key is a key into a Map-like data structure, to have explicit pointers, and you can:  tieKnot :: (Applicative f) => (Int -> f (F Key)) -> F Int -> f (Fix F)
10:54:22 <ertes-w> err
10:54:46 <ertes-w> tieKnot :: (Applicative f) => (Int -> f (F k)) -> F k -> f (Fix F)
10:55:32 <Eduard_Munteanu> Updates are gonna be messy, though.
10:56:32 <Eduard_Munteanu> Maybe not as messy as tied-knot doubly-linked lists, but still.
10:59:20 <lts> Thanks ; I'll study through all the approaches mentioned above
11:00:57 <ertes-w> Eduard_Munteanu: this is pretty generic…  you can use the type argument to refer to "previous" or "parent" nodes, if necessary
11:01:06 <ertes-w> it's just a nice way to get both at the same time
11:02:21 <ertes-w> (of course if you refer to parents *and* have an on-disk representation, then Fix F is not going to be very useful)
11:13:15 <theelous3_> is it reasonable to think of foldl as outside in, and foldr as inside out?
11:16:12 <MarcelineVQ> If accompanied by a picture describing what that means ehe
11:17:43 <MarcelineVQ> I've also seen it said as brackets stack up on the left or the right, but that's equally awful to someone just reading the words. Really the most reasonable explanation is the source for each function
11:20:13 <theelous3_> MarcelineVQ: http://s3.amazonaws.com/lyah/foldl.png
11:20:19 <theelous3_> because you asked for an image :P
11:20:25 <theelous3_> that being foldl
11:20:43 <theelous3_> starts on the "outside" most item
11:20:54 <theelous3_> accum + 3
11:21:06 <theelous3_> where as a foldr starts on the inside most, and would be accum + 1
11:21:07 <theelous3_> ?
11:21:39 <theelous3_> from lyah
11:22:02 <theelous3_> does a fine job of foldr, but its explanation of foldr is just "same but from the right" which doesn't help me
11:22:12 <theelous3_> fine job of foldl*
11:22:23 <EvanR> we were just last night talking about how almost everyones metaphor for foldr foldl and foldl' is wrong
11:22:29 <EvanR> for different reasons
11:22:29 <theelous3_> EvanR: yes :D
11:22:38 <theelous3_> that was from me asking about an impl of elem
11:22:56 <theelous3_> where the foldl version couldn't check an elem in an inf list
11:23:09 <EvanR> any analysis of a haskell data structure starts at the outside
11:23:28 <EvanR> but then foldl doesnt do anything else until it traverses to the end of the list
11:24:01 <theelous3_> where as foldr does?
11:24:48 <Athas> Has anyone else experienced many more 'solveWanteds: too many iterations' errors with GHC 8.4?
11:24:59 <EvanR> foldr applies your function to the first element of the list, and the result of foldring everything else. if your function is lazy, you can ignore the second part
11:26:06 <EvanR> foldr (\a b -> a) (error "this is never used here") [1..]
11:26:13 <EvanR> > foldr (\a b -> a) (error "this is never used here") [1..]
11:26:16 <lambdabot>  1
11:29:27 <Cale> Hey, if I'm using Template Haskell to generate a sequence of constraints, do I seriously just use the TupleT constructor and apply that to the constraints?
11:29:27 <maerwald> is there a deriable instance that is similar to Eq, but just compares constructors?
11:29:54 <Cale> (specifically, the TH is generating an associated type whose kind is Constraint)
11:30:08 <maerwald> basically, I would call the typeclass "Similar" :P
11:30:31 <EvanR> similar reminds me of geometry
11:30:32 <Cale> maerwald: I don't think there is, but usually if you want that, factoring your type differently might be a good idea
11:30:42 <maerwald> or "Like"
11:30:53 <Cale> (so that what you'd be comparing there becomes a specific field)
11:30:54 <EvanR> "KindaSortaLikeNotReally"
11:31:12 <chisui> maerwald: That would be pretty easy to do with Generic
11:31:13 * hackage ztail 1.2.0.2 - Multi-file, colored, filtered log tailer.  https://hackage.haskell.org/package/ztail-1.2.0.2 (DylanSimon)
11:31:16 <Cale> Not always possible of course
11:31:26 <Cale> Oh, yeah, you could use Data or Generic to do it
11:32:02 <Cale> :t toConstr
11:32:04 <lambdabot> Data a => a -> Constr
11:32:19 <Cale> :t (==) `on` toConstr
11:32:21 <lambdabot> Data a => a -> a -> Bool
11:33:49 <MarcelineVQ> maerwald: are you comparing shape or names?
11:33:53 <EvanR> theelous3_: the image of more like what foldl' does
11:34:00 <EvanR> the image seems*
11:34:07 <theelous3_> o?
11:34:22 <MarcelineVQ> cause GHC.Generics would let you compare shapes
11:34:38 <EvanR> yes thats totally not how foldl looks at all
11:34:45 <EvanR> despite the file name
11:34:49 <EvanR> LYAH strikes again
11:35:46 <MarcelineVQ> > foldl f [a,b,c]
11:35:49 <dyl> I wonder if you could derive the nonterminals for a grammar from Generic/Data of an ADT
11:35:49 <lambdabot>  error:
11:35:49 <lambdabot>      • Could not deduce (FromExpr [Expr]) arising from a use of ‘f’
11:35:49 <lambdabot>        from the context: (Show a, Foldable t)
11:35:54 <MarcelineVQ> hehe
11:35:54 <dyl> And then plug in the terminals.
11:35:58 <MarcelineVQ> > foldl f z [a,b,c]
11:36:00 <lambdabot>  f (f (f z a) b) c
11:36:01 <MarcelineVQ> > foldr f z [a,b,c]
11:36:05 <lambdabot>  f a (f b (f c z))
11:36:30 <EvanR> > foldl' f z [a,b,c]
11:36:33 <lambdabot>  f (f (f z a) b) c
11:36:37 <dyl> Or require terminals be expressible as literals or Enumerated.
11:36:42 <dyl> Enum* types
11:36:43 <EvanR> baw
11:37:01 <dyl> Baw gahd, EvanR, he has a family!
11:37:27 <maerwald> MarcelineVQ: what do you mean with shapes
11:37:34 <MarcelineVQ> that's the difference in how things are applied, for foldl/foldr, you can see there that f is given control right away in foldr, while foldl recurses right away instead. if f never uses it's second argument it's never computed, this is why foldr can 'stop early' or be used on infinite lists
11:38:23 <EvanR> according to the result alone, f is given control right away either way
11:38:36 <MarcelineVQ> maerwald: Well like you can see if two datatypes are isomorphic, if that's the sort of equality you're after
11:38:45 <EvanR> and to stop early you just need to be lazy in the right argument
11:38:53 <EvanR> which cant be right
11:38:55 <maerwald> MarcelineVQ: I'm comparing the same datatype
11:38:57 <MarcelineVQ> EvanR: shoot you're right, now I feel foolish for that example
11:39:28 <MarcelineVQ> foisted by my own petard "Really the most reasonable explanation is the source for each function"
11:39:34 <EvanR> even lambdabot is misleading us
11:40:20 <MarcelineVQ> @src foldr
11:40:20 <lambdabot> foldr f z []     = z
11:40:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:40:22 <MarcelineVQ> @src foldl
11:40:22 <lambdabot> foldl f z []     = z
11:40:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:40:46 <EvanR> yeah that makes to clear
11:40:50 <EvanR> make it clear :(
11:41:07 <MarcelineVQ> now, here you can see that in foldr  f  is given the chance to ignore it's second argument
11:41:09 <EvanR> cue the "@src is wrong"
11:41:44 <MarcelineVQ> whilist foldl calls foldl again immediately on the tail of the list
11:41:50 <MarcelineVQ> which won't stop until the list ends
11:42:44 <EvanR> foldl is funny because in an eager language, that is what youd want, since it reduces the args first
11:42:51 <EvanR> then does tail recursion
11:43:35 <MarcelineVQ> maerwald: sounds like Cale has your back then
11:44:49 <maerwald> I don't understand his proposal, it's too vague
11:46:01 <maerwald> or to put it differently: I'm not going to change the data type
11:46:13 <MarcelineVQ> his proposal is to derive Data and use  toConstr  to compare the Constructors of your type
11:46:38 <maerwald> oh, I missed that part
11:46:53 <ertes-w> @where foldrtut
11:46:54 <lambdabot> http://ertes.eu/tutorial/foldr.html
11:46:57 <ertes-w> theelous3_: ^ if you're interested here is an extensive tutorial on folds
11:47:06 <MarcelineVQ> Cale: from what I can tell yes, "Since the advent of ConstraintKinds, constraints are really just types. Equality constraints use the EqualityT constructor. Constraints may also be tuples of other constraints."
11:48:34 <theelous3_> ertes-w: ty!
11:49:49 <maerwald> oh, I don't like Data, I think I avoided it, because it allows to compare constructors of different types
11:50:02 <maerwald> I think I will just do my own type class
11:51:50 <maerwald> yes, in fact I used Data before and then removed it
11:52:35 <MarcelineVQ> depends what interface you're exposing to people I guess.  the example of   <Cale> :t (==) `on` toConstr    <lambdabot> Data a => a -> a -> Bool   only compare the same type
11:53:16 <maerwald> I'm exposing all of the type
11:53:49 <maerwald> and it's an exception type
11:53:59 <maerwald> I think I actually had a bug in my testing suite because of Data
11:55:22 <lyxia> Data is so bad, especially compared to Generics.
11:56:46 <MarcelineVQ> do you have many of these error types?
11:57:44 <MacSlow> Greetings everybody!
11:57:46 <ddellacosta> speaking of Generics, is there anything out there like a "cookbook" or set of examples of using Generics for various tasks? I've watched Andres Loh's presentation and I get Generics conceptually, but I have a hard time knowing where to start in terms of putting it to practical use.
12:00:22 <EvanR> theelous3_: i agree "outside inside" evokes more of the assymmetry in the two ways to fold, whereas left and right do not. I originally took left and right fold to be a no brainer, like if this was ruby, either reduce the array one way or the other
12:00:35 <EvanR> totally wrong
12:00:48 <EvanR> one direction or the other*
12:01:15 <theelous3_> yeah that's what had me confused initially
12:01:40 <EvanR> ertes-w: nice segway from calculus
12:02:05 <maerwald> the question is... if it makes sense to publish a package for just one f**king typeclass and then hope people adapt (they probably won't)
12:02:12 <ertes-w> =)
12:02:37 <EvanR> like calculus, folds were not invented but discovered, maybe explaining why many humans cant dig it
12:02:38 <maerwald> and it wouldn't be too well defined anyway
12:02:43 <MarcelineVQ> the question is, do you have many of these error types?
12:03:15 <ertes-w> indeed, and like calculus you can take them incredibly far
12:03:38 <ertes-w> calculus → topology, folds → initial algebras
12:03:59 <EvanR> "whats the point of foldl, its useless"  "ask God"
12:04:09 <ertes-w> and they both eventually end up at category theory =)
12:06:24 <EvanR> calculus -> differential geometry
12:07:18 <lyxia> ddellacosta: the generics-sop documentation links to a few examples
12:07:28 <ddellacosta> lyxia: thanks!
12:09:43 <lyxia> ddellacosta: generics-eot is another generics package that tries to be easy to understand, in a style closer to GHC.Generics than generics-sop is.
12:09:51 <ddellacosta> great, thanks for these
12:10:13 <jle`> ddellacosta: have you seen these? http://reasonablypolymorphic.com/blog/higher-kinded-data
12:10:16 <ddellacosta> I think the reality is that I just need to bang my head against it a bunch and eventually I'll build the intuition for when Generics are useful
12:10:22 <ddellacosta> jle`: no! thanks
12:11:12 <jle`> to me i see generics as a way to work with data types using generic combinators
12:11:20 <jle`> er, as if they were generic types, i mean
12:11:39 <jle`> so like, instead of 'Maybe a', i could just work with Either () a
12:11:54 <jle`> instead of data Person = P String Int Bool, i could just work with (String, Int, Bool)
12:12:02 <EvanR> if you have many ADTs and the things you do with them are are really the same, including what you do wth their constructor names, then you might be doing generics without Generics
12:12:27 <jle`> it's mostly used nowadays to automatically derive typeclass instances
12:12:39 <jle`> but there are a lot of other uses too, like the link i just posted
12:13:04 <ddellacosta> jle`, EvanR, interesting. I'm not ready to fully grok all of that but I'll file it away
12:14:13 <EvanR> you could also use it for webscale, where you accidentally ended up with 100 record types
12:14:28 <EvanR> and at some point you do some generic operaton with any of them
12:14:53 <dgpratt> I have an "imperative" algorithm for doing a topological sort and I was hoping to make a more "functional" version (neither in Haskell). I was wondering if there was a generic topological sort implementation in Haskell that I could use as a reference? I'm thinking the type of such a function might look like: Ord a => [a] -> (a -> [a]) -> [a]
12:16:04 <ddellacosta> EvanR: yeah that's actually a use-case I've heard about and I'm specifically interested in, any pointers to how to work with records in that way?
12:16:11 <EvanR> :t topSort
12:16:13 <lambdabot> Graph -> [Vertex]
12:16:17 <EvanR> heh
12:16:29 <ddellacosta> or links rather
12:16:32 <dgpratt> just make a graph first, easy peasy
12:17:20 <infandum> Is there a function that creates an "infinite" color palette like this R function: https://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/colorRamp.html
12:17:23 <sl2c> ?hoogle topSort
12:17:24 <lambdabot> Data.Graph topSort :: Graph -> [Vertex]
12:17:24 <lambdabot> Distribution.Compat.Graph topSort :: Graph a -> [a]
12:17:24 <lambdabot> Data.Graph.Inductive.Query.DFS topsort :: (Graph gr) => gr a b -> [Node]
12:17:57 <infandum> The arguments would be a list of colors, the output would be a function that takes an Int and spits out that many colors linearly interpolated from the input list of colors.
12:18:48 <infandum> It looks like Data.Colour can have a linear rgb space with blend, which is nice, but it only works with two colors.
12:19:13 <infandum> A list of colors may not be equally spaced apart though.
12:20:21 <ertes-w> infandum: if you use the 'colour' package, you can use any generic interpolation function
12:24:03 <EvanR> infandum: made me think of this technique: https://www.mathopenref.com/printdividesegment.html
12:25:28 <EvanR> that 2nd dimension is wicked
12:25:30 <infandum> ertes-w: How so?
12:31:31 <EvanR> when do we get computers based on geometry
12:32:44 * hackage error-context 0.2.0.0 - Provides API for enriching errors with contexts  https://hackage.haskell.org/package/error-context-0.2.0.0 (mtesseract)
12:34:24 <Psybur> Wonder how someone discovered that segment division thang
12:35:13 * hackage ekg-wai 0.1.0.3 - Remote monitoring of processes  https://hackage.haskell.org/package/ekg-wai-0.1.0.3 (TvH)
12:36:05 <ertes-w> @let band n xs0 = take n (go 0 xs0) where di = fromIntegral (length xs0 - 1) / fromIntegral (n - 1); go i xs'@(x1 : xs@(x2 : _)) | i > 1 = go (i - 1) xs | otherwise = (realToFrac (1 - i) * x1 + realToFrac i * x2) : go (i + di) xs'; go _ _ = []
12:36:08 <lambdabot>  Defined.
12:36:19 <ertes-w> > band 5 [0,10]
12:36:22 <lambdabot>  [0.0,2.5,5.0,7.5,10.0]
12:36:24 <ertes-w> > band 5 [0,10,100]
12:36:27 <lambdabot>  [0.0,5.0,10.0,55.0,100.0]
12:36:33 <ertes-w> infandum: ^ like this?
12:36:43 <ertes-w> (better use vectors than lists)
12:37:51 <ertes-w> you can easily replace (*) and (+) by the scalar multiplication and vector addition of a vector space
12:38:33 <infandum> Woah, that's exactly it
12:38:39 <infandum> I need to digest that function
12:40:20 <Ariakenom> hi
12:41:17 <dpyro> I've added a git commit to stack.yaml but I'm not even sure its being built 😰
12:41:29 <dpyro> what'
12:41:43 * hackage error-context 0.2.0.1 - Provides API for enriching errors with contexts  https://hackage.haskell.org/package/error-context-0.2.0.1 (mtesseract)
12:42:00 <dpyro> what's really frustrating is that i can import Network.Ethereum.Unit or Network.Ethereum.Web3.Eth but not Network.Ethereum.Web3
12:42:12 <dpyro> any hints of where to start with this?
12:42:45 <cocreature> dpyro: can you show us the full error and your stack.yaml?
12:43:36 <Adluc> Hello guys, can anyone who has account on haskell wiki https://wiki.haskell.org/IRC_channel add channel #haskell-embedded ?
12:44:44 <dpyro> here it is cocreature! https://pastebin.com/dGbF7xq8
12:45:33 <dpyro> for reference, this is the git commit it refers to: https://github.com/airalab/hs-web3/tree/dev/src/Network/Ethereum
12:45:50 <EvanR> Psybur: i see how you can argue that it works. if you imagine the line is already divided, and rotate two parallel lines away from the points, with those division lines extending, then you are free to equally expand or contract the anchors for the division lines
12:46:33 <cocreature> dpyro: that repository doesn’t seem to have an Address module
12:46:36 <EvanR> and the cut locatons remain the same. so "guessing" on the parallel lines and drawing a division ... "accesses the true original locations of the cuts"
12:46:45 <EvanR> because your guess doesnt matter
12:46:53 <dpyro> Address is a type, not a module
12:46:56 <ertes-w> infandum: read "di" as "delta-i", much like you read "dx" as "delta-x"
12:47:13 * hackage tidal 0.9.7 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.9.7 (AlexMcLean)
12:47:15 <cocreature> dpyro: according to the error message you are trying to use it as a module
12:47:44 <cocreature> dpyro: i.e. import Network.Ethereum.Web3.Address means “import the module with that name”
12:48:12 <dpyro> if i try `import Network.Ethereum.Web3 (Address)`, I get the error Could not find module ‘Network.Ethereum.Web3’
12:49:38 <dpyro> does `module Network.Ethereum.Web3 (..., Address, ...)` not make `import Network.Ethereum.Web3 (Address)` work or am I missing something?
12:49:39 <MarcelineVQ> the modules you're trying to import are from master, that's a dev branch commit
12:49:59 <cocreature> the Network.Ethereum.Web3 module also seems to exist in the dev branch
12:50:09 <dpyro> i'm also using a commit on the dev branch
12:50:14 <cocreature> ah it’s not exposed
12:50:23 <cocreature> https://github.com/airalab/hs-web3/blob/dev/web3.cabal#L35
12:50:27 <cocreature> take a look at the modules listed here
12:50:41 <EvanR> nevermind i'm wron
12:50:46 <cocreature> might just be an oversight
12:50:57 <dpyro> is it missing Network.Ethereum.Web3? 🤔
12:51:03 <cocreature> yes
12:51:46 <dpyro> let me try adding that in
12:53:16 <dpyro> hmm, well i think the Network.Ethereum.Web3 module now has build errors, but at least its a different error!
12:53:23 <dpyro> i'll see if i can use another commit or fork it
12:53:43 <dpyro> thanks for the help, i'm a noob at haskell and I would not have found that cabal issue for several more hours on my own
12:53:47 <cocreature> dpyro: do you have some specific reason why you can’t just use the latest release?
12:54:01 <dpyro> i'd have to switch lts i think
12:54:03 <dpyro> for stack
12:54:29 <cocreature> no, you can just add "web3-0.6.0.0" to the extra-deps section in your stack.yaml
12:55:52 <dpyro> that does not work, it complains that the other dependencies have too high a version
12:56:13 <cocreature> you’re going to have to show us the full error
12:57:17 <cocreature> or try using the master branch rather than the dev branch
12:57:25 <dpyro> https://pastebin.ca/4013256 is the error i got
12:57:27 <cocreature> at least the travis tests seem to pass for master while they fail for dev
12:58:15 <dpyro> i was here earlier for that version, and the course of action I had taken was to put allow-newer: true in stack.yaml
12:59:51 <dpyro> i also get that error if i change the resolver to lts-10.3
12:59:56 <cocreature> that won’t work because template-haskell is tied to the version of GHC
13:00:13 * hackage diagrams-core 1.4.1 - Core libraries for diagrams EDSL  https://hackage.haskell.org/package/diagrams-core-1.4.1 (BrentYorgey)
13:00:18 <dpyro> resolver: lts-10.3 or --resolver lts-10.3 gives me the same error
13:00:24 <cocreature> so you’ll have to pick a resolver that has a GHC version that ships with an older version of template-haskell
13:00:51 <cocreature> 9.21 should be the latest lts for GHC 8.0.2
13:00:54 <dpyro> that's fine, but I think my project has packages that are now pinned at too high a version
13:01:08 <cocreature> or try the master branch. that seems less broken than dev
13:01:28 <dpyro> i'm trying to use the hackage version with - web3-0.6.0.0
13:02:05 <dpyro> which uses resolver: lts-10.3 in its own stack.yaml
13:02:29 <cocreature> I just tried to tell you that you need to use lts-9.21 instead :)
13:04:26 <dpyro> ooh!
13:04:46 <dpyro> trying that now!
13:04:56 <cocreature> at least that’s what web3-0.6.0.0 requires, there might ofc be other packages that are not compatible with that
13:05:30 <dpyro> it has lts-10.3 in its stack.yaml but the dependencies won't resolve with it
13:05:35 <dpyro> i feel lied to 😠
13:06:25 <cocreature> well the master branch is probably compatible with lts-10.3
13:06:32 <cocreature> 0.6.0.0 is not
13:06:42 <cocreature> that’s why I said your other option is to try the master branch
13:09:28 <dpyro> oh i was confused, they all said 0.6.0.0 as the version and I did not realize the package and master branch differed
13:23:10 <ertes-w> infandum: https://gist.github.com/esoeylemez/f93bf2d19487a403cbbfc4eef70c5d3a
13:23:19 <ertes-w> this is much more efficient
13:23:49 <ertes-w> there is still room for optimisation, but i'll leave the rest to you =)
13:23:53 <dsal> ick.  I'm using tasty-golden to make a test for a csv processor thing I did.  My test is failing on Linux.  Stupid floating point
13:28:16 <dyl> My current work/personal split is animating the action of RNA polymerase by day, and playing with parsers by night
13:28:28 <dyl> An interesting observation is that these are actually rather similar.
13:28:37 <dyl> RNA Pol II is in a sense a compiler :p
13:30:56 <dyl> I wonder if one could make a toy language with structures that behave like proteins (active sites for example) and an “entropic runtime” consisting of specifying relative concentrations of each structure.
13:31:04 <dyl> And somehow have this do useful (but non deterministic) computation.
13:32:07 <dyl> You have some large set of agents in the system and they interact pseudorandomly with behavior depending on current interactions/bindings
13:41:04 <dpyro> i think that worked, thanks cocreature ☺️
13:41:22 <dpyro> only a simplified version, dyl
13:41:58 <dpyro> enzymes bump into everything while also being affected by everything
13:42:28 <dpyro> is there something like a fixed length ByteString?
13:44:24 <fresheye1> hey out there
13:44:33 <fresheye1> is there a Word8 version of isSpace for Data.Char?
13:52:13 * hackage qr-imager 2.0.0.0 - Library to generate images.  https://hackage.haskell.org/package/qr-imager-2.0.0.0 (vmchale)
13:56:13 * hackage constrictor 0.1.0.2 - strict versions of many things in base  https://hackage.haskell.org/package/constrictor-0.1.0.2 (chessai)
14:03:53 <EvanR> dyl: i tried to image a generalization of a parser... where you have the source material, and the action of a parser is to do a "subtraction" on to get something useful and the remainder, and repeat until nothing is left
14:04:26 <EvanR> im not sure if it works
14:05:38 <EvanR> perhaps needs to be recursive, you extracted something that needs to be parsed itself
14:06:20 <[exa]> that's specific for context-free parsers
14:07:20 <[exa]> just an idea: what about continuations (with slightly restricted type that forces them to ingest the string)?
14:08:50 <EvanR> i was trying to think of other kinds of source material than strings
14:10:04 <EvanR> for instance factorization is like, you have a number. you ask for a prime factor, you either get "parse error, 1" or you get a prime number and the quotient from dividing by it
14:10:32 <fishythe_> fresheye1: Data.Word8.isSpace?
14:10:54 <EvanR> i need to look up context free parsers
14:14:07 <epta> could anyone share a .gitlab-ci.yml to build haskell project using nix?
14:15:33 <c_wraith> EvanR, very very roughly, parser state is determined only by parents, not siblings.
14:15:38 <orbisvicis> is it possible to do parallel list comprehensions in the list monad ?
14:16:28 <c_wraith> EvanR, formally, you should define it in terms of languages and grammars, rather than parsers.. it's a bit more direct that way.
14:18:25 <c_wraith> orbisvicis, there's no special syntax for it outside of comprehensions. I'd probably just use zipWith
14:21:40 <orbisvicis> c_wraith: ah, thats definitely better than plain zip
14:25:23 <nkaretnikov> what companies are hiring remote at the moment besides well-typed, iokh, tweag, fpcomplete, and companies advertising on reddit/functionaljobs/haskellers?
14:34:45 <AndreasK> Why would using foldr over a strict IntMap lead to fewer allocations? Afaik IntMap is spine strict so it should be the same or better with foldl'?
14:43:43 * hackage ghc-core-smallstep 0.1.0.1 - A small-step semantics for Core  https://hackage.haskell.org/package/ghc-core-smallstep-0.1.0.1 (JoachimBreitner)
14:58:13 * hackage haskey 0.3.0.1 - A transactional, ACID compliant, embeddable key-value store.  https://hackage.haskell.org/package/haskey-0.3.0.1 (hverr)
15:05:22 <dsal> What's it called when you import stuff without qualifying either the package name or the things you want imported?
15:05:28 * dsal is writing a pull request to fix a library
15:05:46 <Tuplanolla> Unqualified imports, dsal?
15:06:12 <dsal> That's what I would think, but that sounded like something not using the 'qualified' keyword.  Good enough, though.
15:07:23 <dsal> There.  Now I've solved problems.  It's kind of gross, though.  I tried fixing the imports, but just drowned in new kinds of errors.
15:09:20 <dsal> I'm mildly curious what this conflicting (.) is, but I think I'd rather just not know right now.
15:11:02 <zachk> it might be from Control.Category
15:11:48 <dsal> Yeah, it is.
15:11:48 <dsal> Category cat => cat b c -> cat a b -> cat a c
15:11:50 <jle`> Control.Category exports its own (.), but it is a generalized version of Prelude's (.)
15:12:01 <jle`> so you can just import Prelude hiding ((.))
15:12:29 <dsal> Hmm...  Hiding looks better than what I did.
15:13:20 <jle`> just remember the double parentheses
15:14:51 <dsal> Had to hide the other one.  It imports Data.Function and Numeric.Units.Dimensional.Prelude and sometimes tries to move Prelude out of the way a bit in such a way that doesn't seem to work.
15:15:27 <dsal> Seems like bad practice for a library.  But hopefully it at least works again.
15:18:25 <zachk> you might want to hide id as well, I think Control.Category has it's own
15:20:22 <Tuplanolla> Names in `base` that accidentally clash are `+++`, `.`, `first`, `get`, `id`, `lift` and `second`.
15:22:53 <dsal> I just want the thing to build.  I think super broad imports like this are a bit fragile.
15:23:05 <dsal> I'm surprised the library still appears in LTS since you can't like, build it.
15:24:02 <dsal> oooh, it doesn't.  heh
15:57:12 * hackage plural 0.0.1 - Pluralize  https://hackage.haskell.org/package/plural-0.0.1 (fresheyeball)
16:14:36 <Haskell_Man> Hey I need some help with a Haskell code I'm writing
16:15:02 <Haskell_Man> Does anyone think they can help me
16:17:44 <petrolifero[m]> Show the code. Say what's the problem
16:18:53 <lyxia> he gone
16:19:19 <dsal> I don't think I can help him/her.
16:20:07 <sm> wait.. I'm getting an image.. square, like a.. computer screen
16:20:17 <setre> you think Haskell_Man might be female?
16:20:37 <dsal> I don't like to assume.
16:20:48 <zachk> be nice
16:20:52 <setre> joking
16:22:11 <zachk> Haskell_Man paste your code here http://lpaste.net/ and give back a link and we could look at it and help you
16:22:13 * hackage hpath 0.9.0 - Support for well-typed paths  https://hackage.haskell.org/package/hpath-0.9.0 (maerwald)
16:22:22 <setre> zachk: they left
16:22:46 <petrolifero[m]> The sex of Haskell_Man ( or Haskell_Man's sex, Sorry about my english) os irrelevant, right?
16:24:25 <zachk> oh
16:24:32 <aarvar> is there a way to hyperlink to a header in haddock?
16:27:07 <dsal> petrolifero[m]: It was a joke because there was an indicator directly in the username.   Similarly, if the person identified as Haskell_HighschoolKid, it'd be the user of undeterminable generation.
16:29:03 <jle`> Haskell_CollegeStudent: is this a homework question?
16:29:14 * geekosaur *eyeroll*
16:31:34 <petrolifero[m]> Ahhhh, Sorry. I look like a idiot. Kkkkk
16:35:12 <EvanR> if only they knew that haskell_man was actually an alien from the 99th century sent back to learn haskell, and this is the disguise
16:35:38 <Cale> Haskell_Man is just DeepMind's next project
16:39:05 <dpyro> building from source makes me cry 😭
16:40:51 <Cale> Building what in particular from source?
16:41:15 <dpyro> any project that isn't a Big Deal
16:41:37 <dpyro> not everyone sticks to using strict CI rules or stable master branch etc.
16:41:50 <dpyro> and not everyone has the same build environment
16:42:10 <dpyro> something will break given a large enough codebase
16:42:23 <dpyro> a learning experience if you're trying to hack on that project
16:42:37 <dpyro> frustrating if you have to do it for half a dozen packages you're consuming
16:43:16 <Cale> dpyro: More people should use the nix package manager
16:43:52 <Cale> I don't use NixOS, but I do use Nix quite a bit. It's nice for getting that kind of thing right.
16:44:52 <maerwald> what does that give me over cabal sandboxes, except a lot of complexity and breaking FHS
16:46:17 <Cale> It's like (new) cabal sandboxes, but for not only the Haskell dependencies
16:46:59 <maerwald> why would I need native dependencies in a sandbox
16:47:37 <dpyro> at this point i'm all for having containerized build environments
16:47:50 <maerwald> then use docker, nix is not a container technology
16:47:56 <dpyro> that would make building from source no longer feel like playing russian roulette
16:48:02 <Cale> It's especially really nice when you have a bunch of different people working on the project and want build reproducibility, so that if things are working or failing on one person's machine, they're doing the same stuff everywhere else too.
16:48:04 <maerwald> it's a huge symlink hack
16:48:16 <Cale> heh
16:48:43 <maerwald> docker is simpler for reproducibility
16:48:54 <Cale> Well, "simpler"
16:49:08 <maerwald> and cleaner, and distro-agnostic
16:49:15 <Cale> It sort of shoves all the mess of reproducibility into a box.
16:49:38 <maerwald> you mean a Dockerfile
16:50:07 <Cale> But it's still this imperative pile of state
16:50:24 <Cale> With nix, all your build outputs are immutable.
16:50:49 <maerwald> and configuration is a mess
16:50:56 <dmj`> maerwald: most Dockerfiles I see do `apt-get update && apt-get upgrade -y && apt-get clean`
16:51:31 <Cale> ^^ that would absolutely kill reproducibility pretty much
16:51:49 <Cale> It's nice to be able to take a project from a couple years ago, dust it off, and still be able to build it
16:52:02 <maerwald> you can, keep an image
16:52:21 <Cale> Keep an image forever that if you lose it, you can never get it back
16:52:33 <maerwald> same with everything else
16:53:00 <dmj`> With nixpkgs you’ll always have the hash at which you pinned.
16:53:02 <Cale> Well, with nix, if you lose your image, you can rebuild it from the pure specification, and it should produce the same result it always did
16:53:14 <maerwald> and if you lost that specification?
16:53:28 <Cale> Well, you don't want the specification to be "here's this disk image"
16:53:34 <dmj`> Someone would have to delete nixpkgs off of GitHub, doubt eelco wants to do that
16:53:49 <maerwald> it's just a non-argument
16:54:01 <Cale> There's a bunch of stuff I don't like about nix, but it's not this :)
16:54:09 <maerwald> in the day of storage everywhere, you say "you might lose your image"... err, right
16:54:11 <Cale> This is the one good idea in nix
16:54:24 <zfnmxt> I'm trying to get Hakyll to work, and I've made some changes to site.hs. When I run stack build, it re-installs pandoc, hakyll, etc every time and it takes forever. Is something wrong here? Shouldn't it just have to do that a single time?
16:54:29 <dmj`> maerwald: an image is one thing, but the third party deps. on the image are another.
16:54:31 <Cale> Well, you might lose the ability to change your image successfully
16:54:40 <maerwald> dmj`: what third party deps
16:54:43 <Cale> Because the way that it's specified is just a pile of bytes
16:55:13 <Cale> With something like nix, you can change one dependency at a time, and have a way forward and back.
16:55:23 <maerwald> Cale: same with nix, there is no guarantee you can build your spec with the nix package manager in 5 years time
16:55:31 <maerwald> and then you'll look for ways to bootstrap it maybe
16:55:39 <Cale> It's not like "oops, this is too old, I can't apt-get upgrade anymore"
16:56:01 <maerwald> it's the same problem everywhere, nix doesn't magically solve it, it just has some declarative config format and that's it, doh
16:56:48 <Cale> Well, a declarative configuration format and immutable store go a long way to making this problem factor into more manageable pieces
16:57:25 <maerwald> it's a nice toy, not really needed though
16:57:26 <Cale> The fact that the nix programming language itself is untyped sucks a whole lot (though that's something people are working on)
16:58:01 <Cale> But it is a pure functional programming language :)
16:58:33 <maerwald> not that amazing
16:58:43 <maerwald> I can have that with propellor too
16:59:06 <Cale> It doesn't have to be very amazing to be better than a bunch of scripts which shell out to apt a bunch :P
16:59:27 <maerwald> everything that avoids those symlink hacks is better
16:59:45 <Cale> What's so bad about the symlinks?
16:59:47 <maerwald> did they make steam work yet or are there still 300 semi-broken approaches to get it to work
16:59:52 <maerwald> symlinks are bad
17:00:10 <Cale> Steam works, but I don't give a shit about steam.
17:00:13 * hackage unagi-bloomfilter 0.1.1.1 - A fast, cache-efficient, concurrent bloom filter  https://hackage.haskell.org/package/unagi-bloomfilter-0.1.1.1 (BrandonSimmons)
17:00:15 <maerwald> also, nix is incompatible with some programs that hardcode certain paths and rely on FHS
17:00:17 <Cale> Steam is not a dependency of any of my projects.
17:00:33 <maerwald> even ghc was broken once
17:00:37 <Cale> I don't use nixos.
17:00:46 <Cale> Only the nix package manager itself.
17:00:50 <maerwald> Cale: you don't use any packages?
17:00:59 <Cale> I use nixpkgs
17:01:02 <dyl> It’d be amusing if nixos could somehow be shoehorned into a smalltalk image distribution
17:01:03 <maerwald> they are from nixos
17:01:11 <Cale> No, it's separate.
17:01:18 <maerwald> https://github.com/NixOS/nixpkgs
17:01:34 <maerwald> they are part of NixOS :)
17:01:41 <dyl> NixOS is built on Nix
17:01:44 <Cale> Well, NixOS is the distribution itself. I just run a much more ordinary Linux (Mint actually).
17:02:01 <maerwald> and NixOS provides all the packages
17:02:03 <maerwald> not Nix ;)
17:02:04 <dmj`> maerwald: having a binary cache is nice for haskell deps
17:02:14 <Cale> I use nixpkgs to obtain project dependencies, and don't care about anything which might be in there which is not needed to build my project.
17:02:44 <Cale> It's also really nice for deployment.
17:02:52 <Cale> For that we use NixOS
17:03:07 <Cale> (but just pretty cut down machine specifications)
17:03:09 <maerwald> I heard people in financial don't use it a lot
17:03:19 <maerwald> they just dockerize or something
17:03:40 <maerwald> and I've never seen it used for actual servers
17:04:02 <dmj`> maerwald: iohk.io uses nixos for their cloud services
17:04:28 <dmj`> maerwald: also, adoption != correct, plenty of people use javascript, adoption doesn’t make the technology better.
17:04:38 <maerwald> if I want a guarantee that something builds, I can just use stack. NixOS in fact also maps the stack versions
17:04:42 <Cale> We just have a script which produces a complete machine image, nix-copy-closure it over to an AWS instance or whatever, and then ssh's over and does a switch-to-configuration.
17:05:07 <maerwald> dmj`: exactly, many people use nix and recommend it to others... that doesn't make it correct ;)
17:06:07 <texasmynsted> is this a battle between Nix, Stack and Cabal?
17:06:25 <rotaerk> hmm, when I try to build this on nixos:  https://github.com/achirkin/vulkan/tree/f55335c4bf4bc32fc6abd8ac94a6bb8489366981
17:06:26 <maerwald> nah, it's just one of those "use my tool, because it's awesome" :P
17:06:48 <dmj`> maerwald: never said it did, but adopting nix doesn’t make it somehow “better”, same for Haskell
17:06:49 <rotaerk> I get this error:  https://github.com/achirkin/vulkan/issues/3#issuecomment-379970738
17:06:55 <Cale> texasmynsted: I don't really see it as a "battle"
17:06:55 <maerwald> I've never recommended the distro I use to anyone here, ever, or any other weird tool I use for myself
17:07:22 <rotaerk> however, if I edit the cabal file such that examples 05 and 06 are commented out, the build completes fine
17:07:26 <maerwald> I just question all that evangelism
17:07:37 <rotaerk> what I don't understand is why that error occurs at all.
17:07:50 <jackdk> now I want to hear what weird tools maerwald uses, because there's probably something cool in there that I'm not yet aware of
17:08:28 <rotaerk> basically, vkAcquireNextImage2KHR is a foreign import in vulkan-api, the library used by vulkan-examples, and it's a reference to a function in the vulkan-loader (a .so available elsewhere)
17:08:41 <rotaerk> however since my vulkan-loader is a version behind, that function doesn't exist in it
17:09:00 <rotaerk> but it's not being called at all by vulkan-examples, so why does it *care* that it can't resolve it?
17:09:14 <rotaerk> and why does it only care when building examples 05 and 06
17:09:55 <rotaerk> the maintainer is working around this by making some cabal flags that let you turn off the foreign imports, but it doesn't seem like that should be necessary ...
17:10:07 <Cale> rotaerk: Well, I don't think there's dead code elimination of foreign imports...
17:10:18 <Cale> I'm not sure about that though.
17:10:29 <rotaerk> well, I enabled dead code elimination when I compiled vulkan-api
17:10:46 <maerwald> jackdk: they are so cool that I don't want to share them...
17:11:06 <Cale> I'm not sure that would even matter though. I think if you foreign import something at all, it has to exist.
17:11:10 <maerwald> someone might actually try them out and then bother me with endless questions :P
17:11:13 <rotaerk> thing is, examples 01 through 04 all use vulkan-api; they justt use a different subset of it
17:11:21 <rotaerk> and they build fine
17:11:48 <Cale> I could be wrong about that I suppose
17:12:22 <Cale> You might want to have a look at the core for the thing which fails and just grep it for the import in question
17:12:55 <rotaerk> I even tried modifying example 01 to have all the same dependencies as 05 in the cabal file, all the same imports, and even put an call to one of the vulkan functions from the same module as vkAcquireNextImage2KHR, and it still built fine
17:13:00 <rotaerk> so not really sure what about 05 makes it fail
17:13:32 <rotaerk> Cale, the core?
17:13:40 <Cale> i.e. -ddump-simpl
17:13:53 <Cale> (and maybe -ddump-to-file)
17:14:21 <rotaerk> hmm will look those up
17:15:07 <Cale> if you supply those flags to GHC, it'll produce <modulename>.dump-simpl alongside the .o and .hi files
17:15:25 <rotaerk> hmm k
17:15:35 <Cale> if you don't -ddump-to-file, it'll just print it to stdout (or maybe stderr?) while building
17:16:07 <Cale> and that'll be the code after the simplifier has run (so the optimised intermediate language)
17:16:30 <Cale> you'll be able to see if there are any references left to the thing which is causing problems, and where they occur, hopefully
17:16:54 <rotaerk> k, thanks; will check that outt
17:34:31 <ddellacosta> can anyone tell me why I may prefer makeFields with prefixes in records vs. simply enabling DuplicateRecordFields and using makeFieldsNoPrefix? Assuming I have DuplicateRecordFields I'd naively assume that's always preferable, but I can imagine that there is more to it than that.
17:36:20 <geekosaur> backward compatibility?
17:36:45 <ddellacosta> geekosaur: yeah I guess that makes sense, was wondering if there was any other subtle gotchas too though
17:36:52 <ddellacosta> *were
17:37:19 <geekosaur> potentially more expensive since you're layering one typeclass atop another. likewise, conceivably type resolution issues
17:37:25 <geekosaur> iirc
17:37:39 <ddellacosta> geekosaur: gotcha, thanks
17:37:53 <geekosaur> once full OverloadedRecordFields is in, hopefully lens will integrate with it directly instead of providing its own when it's available
17:38:14 <ddellacosta> is that slated for 8.6?
17:38:27 <geekosaur> I don;t recall offhand
17:38:44 <ddellacosta> sorry, being lazy, I can look it up
17:39:21 <lyxia> ddellacosta: https://github.com/ghc-proposals/ghc-proposals/pull/6
17:39:56 <ddellacosta> lyxia: thanks, yeah that's what I was looking at just now, although it's not clear to me when that'll get released from that PR (yet)
17:40:10 <ddellacosta> maybe I'm not looking in the right place
17:43:40 <dysfigured> is making a web site with miso as a beginner going to kill me?
17:43:41 <ddellacosta> okay anyways enough with this digression...thanks for the lens help geekosaur!
17:44:24 <geekosaur> I poked around and didn't see it in the current roadmap; it got bumped out when the new release scheduling went into effect
17:44:36 <geekosaur> suspect it's now "whenever someone gets around to doing the work"
17:45:36 <ddellacosta> geekosaur: yeah, I ended up here https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.6.1 and poked around elsewhere and didn't see it
17:45:43 <ddellacosta> ah well
17:45:56 <ddellacosta> seems like enough work has been done on it that it will land sooner or later
17:46:56 <geekosaur> yeh, pretty sure they don't bother trying to predict now, it goes into the roadmap if they have commits for it
17:48:44 <rotaerk> Cale, thanks; that helped
17:49:03 <rotaerk> it's actually making a call to the vulkan library via template haskell at compile time
17:49:15 <rotaerk> (particularly, it's doing so to compile GLSL shader code)
17:49:45 <sm> dysfigured: it's got a quick start.. maybe not ?
17:50:20 <dmj`> dysfigured: it shouldn’t, but if it does, wouldn’t be a bad way to go
17:51:18 <dmj`> dysfigured: it’s really simple, you don’t have to even know that much haskell to use it, by design
17:52:10 <dmj`> dysfigured: if you understand functions and how to use the IO monad you should be good
17:52:15 <dmj`> dysfigured: what are you trying to build?
17:52:24 * dmj` thinks an O’Reilly book is in order
17:52:38 <dmj`> dysfigured: https://haskell-miso-slack.herokuapp.com/ join us
18:00:10 <sm> dmj`: cool demos!
18:02:04 <dmj`> sm: thanks :) can’t take all the credit though, Tobenna P. Igwe (ptigwe) made the 2048 clone, and its pretty slick. http://2048.haskell-miso.org/
18:04:05 * sm discovers this cool new "2048" game
18:17:51 <dysfigured> dmj`: i have a bit of experience with monads from js libs like sanctuary and fluture.. i'm looking at some of the miso examples, and can kinda understand it, i guess i'm just not comfy enough with haskell to know how to write that
18:20:47 * dysfigured hates slack, joins anyway
18:28:08 <EvanR> which slack
18:29:41 <leshow> reading this blog post, showing sequence :: t (f a) -> f (t a) and Int -> Maybe String being substituted in
18:29:59 <leshow> the result is [Int -> Maybe String] -> Int -> [Maybe String]
18:30:07 <leshow> but I don't understand the substitution
18:30:19 <leshow> can anyone enlighten?
18:30:38 <EvanR> looks like t must be Maybe, a must be String...
18:30:56 <leshow> t isn't []?
18:31:08 <EvanR> oh
18:31:10 * EvanR tries again
18:31:30 <leshow> it's the f a part I don't get, how do you substitute a -> b into f a
18:31:59 <EvanR> [ ], (A ->), and Maybe are all functors
18:32:08 <EvanR> so i wouldnt be surprised if theres more than one interpretation here
18:32:21 <thy0> thinking about using xmonad, how time consuming would it be to learn enough haskell to configure it properly?
18:32:23 <DwarfMaster> t is [], f is (Int ->) and a is (Maybe String) should work
18:32:35 <EvanR> so the Maybe is a red herring
18:32:45 <leshow> > :t (Int ->)
18:32:48 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
18:32:55 <EvanR> :k (Int ->)
18:32:57 <lambdabot> error: parse error on input ‘)’
18:33:01 <leshow> errr
18:33:03 <leshow> lol
18:33:06 <DwarfMaster> > :t ((->) Int)
18:33:07 <EvanR> (Int ->) isnt really syntax
18:33:09 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
18:33:22 <EvanR> :k ((->) Int)
18:33:24 <lambdabot> * -> *
18:33:44 <leshow> :t ((->) Int)
18:33:45 <lambdabot> error: parse error on input ‘->’
18:33:49 <leshow> bah
18:33:56 <EvanR>  :t only works on values
18:34:01 <leshow> oh okay
18:34:19 <leshow> :k (->)
18:34:21 <lambdabot> TYPE q -> TYPE r -> *
18:34:34 <leshow> right okay
18:35:45 <EvanR> -> is slightly magical
18:35:54 <arahael> buhman: 2
18:36:01 <EvanR> i mean... its appear in its own :k results
18:36:08 <EvanR> so take that with a grain of salt
18:36:14 <arahael> Appologies, buhman. (Bad typo, involving tab)
18:37:26 <DwarfMaster> It's not the same (->) in kinds though
18:37:41 <EvanR> the -> appearing in the kind of anything involving -> must be a different ->, with a higher kind. the sort of issue that would have lead to paradoxes was sorted (pun intended) out about 100 years ago
19:01:54 <dmj`> dysfigured: are you familiar with Elm at all?
19:02:20 <Welkin> dmj`: when will that finally die?
19:02:38 <Welkin> it's the long, slow death
19:02:59 <Welkin> it's Evan's fault though
19:03:31 <Welkin> I don't know anyone who actually uses it. Everyone tries it once and gets some ideas from it and takes them elsewhere
19:03:34 <dysfigured> dmj`: only in passing
19:03:55 <Welkin> the Elm architecture is a great idea. The Elm language is just bad
19:04:31 <Welkin> dmj`: you are pitching miso?
19:04:49 <Welkin> I still haven't used it yet, but I finally got it installed and set up (and working!)
19:04:58 <dysfigured> i'm just looking at alternatives to my current express+react setup
19:05:10 <Welkin> express is easily replaced with scotty
19:05:15 <Welkin> scotty is much better
19:05:27 <Welkin> react + redux is kind of like elm, but not really
19:05:47 <dysfigured> i'm not big on redux itself personally
19:06:03 <Welkin> redux is based on elm, but a lot more loose
19:06:48 <Welkin> it deviates from the elm architecture
19:07:05 <Welkin> I prefer the more standard elm architecture, which miso uses (mostly)
19:07:27 <Welkin> redux has quirks where it gets pretty messy with IO
19:07:36 <Welkin> it has no in-built mechanism to chain messages together
19:07:38 <Welkin> elm does
19:09:21 <leshow> purescript has some really interesting UI frameworks if you're into that
19:09:23 <Welkin> building javascript apps gets incredibly boring after you have done it many times
19:09:28 <leshow> halogen, for one, is pretty neat
19:09:34 <Welkin> I tried to get into purescript, but the ecosystem sucks
19:09:42 <Welkin> and the language is not ready for production use
19:09:44 <Welkin> too many issues
19:09:50 <leshow> its small, that's for sure
19:09:50 <jackcrfs> hi, newbie question: is there a built-in or recommended json library?
19:09:52 <Welkin> just stick with ghcjs
19:09:57 <Welkin> it's the future
19:10:05 <Welkin> jackcrfs: aseon
19:10:06 <leshow> afaik ghcjs community is even smaller
19:10:09 <Welkin> aeson*
19:10:20 <jackcrfs> noted aeson, thanks!
19:10:22 <Welkin> leshow: but we have the reflex-frp gang and miso
19:10:44 <Welkin> which are significantly better than anything offered by purescript in my opinion
19:10:52 <leshow> Welkin: I haven't tried any, although i did read some miso docs
19:11:27 <dysfigured> i've had fun with react, rxjs and ramda/sanctuary, which i think is about as functional as javascript gets..
19:11:48 <Welkin> dysfigured: I have hit a wall with javascript too after using react/redux and rxjs for a while
19:11:55 <Welkin> the only place to go from there is ghcjs
19:12:18 <Welkin> also, ramda sucks :(
19:12:43 <dysfigured> ramda is ok, i like sanctuary a lot
19:13:03 <Welkin> we are already compiling our javascript to javascript
19:13:07 <Welkin> why not compile a better language instead?
19:13:32 <leshow> how's the perf of ghcjs these days, last i heard it was a significant hit
19:13:54 <leshow> I mean, if you're making CRUD apps it hardly matters lol
19:13:57 <Welkin> leshow: no idea lately, but there are some year-old benchmarks that place it among the best
19:14:06 <Welkin> it is significantly better than anything in purescript
19:14:15 <Welkin> it is about as good as react
19:14:40 <Welkin> the performance is not a problem at all from what I have seen
19:14:55 <leshow> purs is about 3-4x slower than js for most stuff last time i looked. elm did a bit better but honestly every time i write elm i feel like banging my head against a wall
19:14:55 <Welkin> the file sizes are also equivalent to anything you would get from react and webpack
19:15:01 <leshow> it was great as a 'starter' fp lang
19:15:06 <Welkin> leshow: yes, elm sucks
19:15:54 <Welkin> the only language that will give you better performance and smaller files is ocaml->js
19:16:11 <Welkin> that is because of a lot of industry resources working on optimizing the compiler for that
19:16:23 <Welkin> a lot from facebook, since they use ocaml to write react
19:17:08 <Welkin> facebook doesn't even write their javascript in javascript any more
19:17:29 <leshow> bucklescript ?
19:17:30 <Welkin> the trend seems to be js going the way of assmebly
19:17:47 <Welkin> leshow: well, reasonml, which uses the bucklescript compiler
19:18:00 <leshow> I don't really feel like learning ocaml/reason honestly. there's only so much time in a day lol
19:18:09 <Welkin> there is no reason to
19:18:13 <Welkin> ghcjs is good enough
19:18:22 <Welkin> it's as good as any babel/webpack solution
19:18:44 <leshow> I'll keep that in mind next time around, which lib do you recommend? Miso?
19:18:53 <Welkin> I have not used any in production yet
19:19:06 <Welkin> but miso will be super easy to use if you know elm or have used react/redux
19:19:17 <Welkin> reflex is more advanced, but also more powerful it seems
19:19:25 <Welkin> I haven't tackled reflex yet
19:21:00 <Welkin> I recommend you try them both
19:21:05 <Welkin> they are different approaches
19:21:14 <leshow> Taking another peek at miso atm
19:21:51 <Welkin> leshow: dmj` is the author, and he hangs out in here
19:22:09 <leshow> Is there a nice(r) way to handle row types in Haskell yet
19:22:28 <Welkin> leshow: there are some libraries
19:22:39 <Welkin> I havent't found a need for it though
19:23:11 <leshow> That's one thing about purescript I quite liked, the polymorphic row types
19:23:23 <Welkin> they could be added as an extension
19:23:29 <Welkin> there are all kinds of proposals already
19:23:35 <Welkin> full dynamic types are coming
19:23:41 <Welkin> and there is a proposal for linear types as well
19:23:47 <leshow> dependent you mean
19:23:49 <Welkin> with a way to unify dynamic and linear types
19:23:51 <Welkin> yeah
19:23:53 <Welkin> dependent
19:24:02 <Welkin> sorry, just came from a python meetup
19:24:10 <leshow> Lol all good, I spent last week messing around with type families
19:25:01 <Welkin> I don't do any crazy type-level things though
19:25:05 <Welkin> I tend to keep it simple
19:25:21 <leshow> Practically I can't say I do either, it's just a curiousity
19:27:21 <EvanR> haskell has fully support for dynamics types
19:27:49 <EvanR> sum types, Typeable, and -fdefer-type-errors
19:28:01 <Welkin> ew, Typeable
19:28:04 <EvanR> lol
19:28:06 <arahael> Do we have any HTML or SVG renderers in pure haskell?
19:28:08 <Welkin> you are bringing back nightmares I had with yesod
19:28:19 <Welkin> arahael: renderer?
19:28:23 <Welkin> you mean like in a web browser?
19:28:30 <leshow> or do you mean like blaze-html
19:28:41 <arahael> Welkin: Ie, output to a surface of some sort.  Sure, like a browser, but no need for it to be interactive, just fast.
19:28:49 <Welkin> <3 blaze-html
19:28:57 <leshow> yeah, blaze is awesome
19:29:02 <arahael> I was looking at Lucid, it seems simpler, as a notation.
19:29:09 <Welkin> also, html generation using racket is awesome too!
19:29:19 <buhman> arahael: 3
19:29:24 <Welkin> it's just quasiquotes!
19:29:26 <arahael> Hypothetical use case of the tool: To spit out a PDF.
19:29:50 <Welkin> arahael: lucid proposes a more consistent naming scheme, but it is worse than blaze for 2 reasons
19:29:57 <arahael> Welkin: Yeah?
19:30:09 <Welkin> 1) it makes *all* of the names ugly and harder to type by adding a _ to the end of them
19:30:24 <Welkin> it also gives you impossible type errors because it is polymorphic up the whazoo
19:30:34 <Welkin> that was 2)
19:30:46 <Welkin> blaze just works and is easy to debug
19:30:54 <Welkin> I also very much prefer the attribute combinators
19:31:03 <arahael> Blegh.  1) is a minor annoyance, but 2) sounds quite a bit more significant.
19:31:18 <Welkin> a "Click me" ! href "#hi"
19:31:19 <Welkin> vs
19:31:38 <Welkin> a_ [href "#hi"] "Click me"
19:31:54 <Welkin> I could not even get it to work last time I tried lucid
19:32:03 <Welkin> the type errors were all "Ambiguous types"
19:32:07 <Welkin> ghc would just implode
19:32:11 <Welkin> no matter what I tried
19:32:11 <dsal> Argh.  I thought I had some kind of understanding of floating point, but I get different values for the same code on OS X vs. Linux.  Frustrating.
19:32:21 <arahael> Ok, I'm discouraged from Lucid now. :)  It's really importnat to have sensible error messages, imho.
19:32:29 <arahael> dsal: Why is that frustrating?
19:32:33 <EvanR> as a person who wrote several of these awful "basically html" DSLs, i very much appreciate consistency
19:32:55 <arahael> EvanR: Likewise.  But not at the expense of sensible errors.
19:32:57 <EvanR> so a_ [href "#hi"] "Click me" is looking good, other than the _
19:32:57 <leshow> blaze has been around a while longer, it's battle tested and fast. I don't know how it compares to lucid
19:32:58 <Welkin> EvanR: there are only two combinators in blaze with and underscore at the end: class_ and id_
19:33:07 <Welkin> big deal
19:33:10 <dyl> Welkin: unifying dynamic and linear types seems interesting.
19:33:21 <EvanR> lol
19:33:21 <dsal> arahael: Because it's showing up in my golden test.  I would hope the same code would give me the same answer.
19:33:24 <arahael> So, how do I get, say, an image out of blaze-html? :)
19:33:28 <Welkin> leshow: blaze has been around for 8 years in active development
19:33:47 <Welkin> arahael: you don't
19:33:51 <Welkin> blaze produces html
19:33:54 <arahael> dsal: Is it the exact same floating point types, and the exact same floating point mode?
19:33:57 <Welkin> your browser renders the html
19:34:13 * hackage prefix-expression 1.2.6 -   https://hackage.haskell.org/package/prefix-expression-1.2.6 (vonfry)
19:34:14 <arahael> Welkin: I'm aware, but I'm asking a question, "does this thing exist?"
19:34:15 <dsal> arahael: it's the same stack build.
19:34:18 <dyl> And then you take a screenshot, save as jpeg, and see it a few years later compressed to hell and back.
19:34:21 <Welkin> I don't know
19:34:23 <dsal> Me, IRL:  https://twitter.com/dlsspy/status/178043578457661440
19:34:30 <EvanR> dsal: tests and floatingpoint dont really mix
19:34:45 <EvanR> the truth is you get different answers on different systems
19:34:53 <dsal> Yeah.  I'll just chop off another digit... once and for all
19:34:54 <Welkin> dyl: axtually, 0.999999999... is exactly equal to 1
19:34:55 <Welkin> :P
19:34:58 <arahael> Welkin: Eg, librsvg exists for SVG, but that's not in Haskell. :)
19:35:14 <Welkin> arahael: I wouldn't expect a rendering engine to be written in haskell for html
19:35:19 <Welkin> those would probably be in C
19:35:38 <dsal> Welkin: I forgot what language I was suffering when I wrote that.
19:35:39 <dyl> dsal: for floats test within tolerances. Also check each platforms float.h and look at the constants.
19:35:42 <EvanR> whether something "needs" to be in C should be highly suspicious propositon
19:35:59 <arahael> Welkin: Why?
19:36:06 <Welkin> EvanR: it doesn't need to, but these low-level, performance sensitive programs are usually written in C or C++
19:36:16 <Welkin> just because that is what people choose to use
19:36:23 <dyl> This was actually the motivating problem for Rust as well.
19:36:30 <EvanR> dyl: dsal: test within tolerances, that you proved to be correct, rather than "meh seems big enough"
19:36:36 <EvanR> arent going to? ok
19:36:51 <dyl> That’s why I said look at the system headers.
19:37:00 <arahael> Welkin: I haven't tested it, but consider http://weasyprint.org/ <-- That's in *python*.
19:37:03 <Welkin> something cool about racket is that it uses exact numbers by default
19:37:08 <Welkin> I wish haskell did that too
19:37:13 <dyl> No you don’t haha.
19:37:14 <EvanR> dyl: which constants ?
19:37:22 <dyl> Representations for exact numbers often still suck.
19:37:27 <Welkin> 1/3 is 1/3, not 0.33333
19:37:28 <dyl> It’s an open research area.
19:37:34 <dsal> dyl, EvanR: sure.  margins are reasonably wide here.
19:37:52 <EvanR> Welkin: we just went down "why rationals suck" lane a few days ago in here
19:38:00 <Welkin> EvanR: how was it?
19:38:04 <Welkin> and why do they suck?
19:38:08 <monochrom> You could default to Rational.
19:38:08 <EvanR> confirmed, they suck
19:38:12 <dyl> They’re only countable.
19:38:21 <dyl> :p
19:38:33 <EvanR> at least, for the applications people are complaining floats about
19:38:35 <monochrom> Ah Double is also countable.
19:38:41 <dyl> Well yes.
19:38:44 <dyl> It was a joke :p
19:38:53 <monochrom> OK! Har har har!
19:39:06 * dyl slaps knees and guffaws
19:39:14 <dsal> I don't control the types in these calculations.  I'd think scientific would be good for geodetics.
19:39:14 <dyl> Floating points! Harrr!
19:39:30 <EvanR> numerics are no joke
19:39:47 <Welkin> dyl: you would have liked the presentation at the python meetup tonight
19:39:54 <Welkin> it was all about data science and data visualization
19:40:19 <EvanR> Welkin: which city is this
19:40:23 <EvanR> or country road
19:40:28 <Welkin> Indianapolis
19:40:35 <monochrom> Oh! Lately I used Scientific for marks because of its base-10 niceness.
19:40:42 <EvanR> is there any haskell there whatsosever?
19:40:46 <dyl> Yeah well my AyyPL has them all beat. I use clock emojis (🕑🕒🕓...) for my numerics!
19:40:50 <Welkin> also about geographic survey data from across the whole state
19:40:59 <Welkin> the entire state has been mapped with photography and lidar
19:40:59 <dyl> (Actually I don’t, numbers are one of the only things that aren’t emoji [but can be])
19:41:16 <Welkin> EvanR: a few people here and there.
19:41:24 <Welkin> python is huge here though
19:41:27 <EvanR> sounds like more than New Orleans
19:41:28 <Welkin> it has the largest and best meetup
19:41:32 <monochrom> I.e., to a large extend I want some comfort of mind when doing 0.1 + 0.3 + 0.1
19:41:35 <dyl> My pithy description of Python:
19:41:40 <Welkin> and javascript is huge too
19:41:41 <dyl> The second best language for almost anything.
19:41:45 <Welkin> lol
19:41:48 <Welkin> I don't like python
19:41:54 <Welkin> but it has some damn cool tools for data science
19:42:01 <dyl> I don’t like it conceptually but in practice it works well.
19:42:16 <dyl> I think that it’s found such adoption in the sciences ought to be studied more closely.
19:42:17 <arahael> Welkin: Julia seems to be good for data science, potentially.
19:42:27 <arahael> dyl: Indeed.
19:42:30 <EvanR> monochrom: and i assume it beats Fixed because you could snap and give someone a 0.1234123412347
19:42:35 <monochrom> Wait a second, Dennis Ritchie claimed that C was the 2nd best language for almost anything.
19:42:38 <EvanR> and it will work
19:42:39 <dyl> Namely why is Python so successful, but other languages (R, Julia...) tend to be constrained to data science and statistics?
19:42:51 <dyl> Julia’s dynamic specialization is neat though.
19:42:53 <Welkin> python and javascript are the top two languages right now
19:43:01 <Welkin> python mostly because of data science and deep learning
19:43:02 <dyl> Potentially has some bad memory footprint impact but still neat.
19:43:10 <dyl> Python was popular way before deep learning.
19:43:18 <Welkin> it was, but not at this level
19:43:21 <arahael> dyl: Well, Julia seems to focus on data science, but if you wanted to end up with an .exe that can show a GUI application... You're on your own.  That may have changed now, though.
19:43:22 <EvanR> julia is contributing to the idea that there is 1 true number type
19:43:24 <Welkin> not everyone wants to use it
19:43:24 <EvanR> and we know what it is
19:43:26 <Welkin> now*
19:43:30 <dyl> No, it was Welkin
19:43:39 <dyl> I’ve been doing python work in the life sciences for years.
19:43:46 <dyl> Nearly every single tool in biology (and not just bioinformatics) that is scriptable is Python scriptable.
19:43:51 <dyl> Many are written in Python and C.
19:43:58 <Welkin> I mean people who want to learn programming
19:44:04 <Welkin> like there are javascript/react bootcamps
19:44:06 <dyl> It’s the lingua franca for life sciences research code.
19:44:11 <EvanR> Welkin: thats a fad
19:44:11 <Welkin> there are now deep learning/data science bootcamps
19:44:22 <dyl> numpy and scipy are big parts of this.
19:44:30 <dyl> As is pandas, as it’s “most of R without R”
19:44:31 <EvanR> next week they will all be in VR bootcamp, until that gets old
19:44:39 <monochrom> Naw both Fixed and Scientific are fine for my purpose.  But Scientific has the added benefit of having instances in cassava.  I want to read these base-10 fractions from a CSV file.
19:44:43 * dyl is interested in research on language design in this space.
19:44:56 <dyl> (Meaning my own research.)
19:45:22 <Welkin> since I am bored out of my mind with javascript web apps, I thought I may as well try deep learning with python
19:45:23 <EvanR> interesting cassava doesnt have instances for Fixed but its in base and scientific is not
19:45:29 <dyl> Scientists hate onramping time.
19:45:34 <Welkin> it's something new and interesting
19:45:38 <dyl> And they hate _visible_ complexity.
19:45:47 <dyl> And they generally have an attitude of “if it works it’s good enough”.
19:45:56 <dyl> Look through python attached to published papers.
19:45:58 <dyl> It’s horrendous.
19:46:05 <dyl> Notebooks do NOT solve this problem.
19:46:06 <Welkin> is it all numpy/scipy?
19:46:14 <Welkin> because that is essentially matlab
19:46:19 <dyl> No it’s a lot of different libraries, and distributions.
19:46:22 <Welkin> which, yes, is terrible
19:46:23 <dyl> Such as sage, etc
19:46:31 <Welkin> because it is not written by software engineers
19:46:37 <EvanR> i really like matlab, but every engineer i mentioned it to hates it
19:46:49 <dyl> Right, one of the motivating statements of my current research direction is this:
19:47:05 <Welkin> it's funny that engineers generally dislike programming and they write horrible code
19:47:05 <arahael> dyl: Interestingly, my colleague who is mad keen on python, as a data scientist, recently wrote a python app for windows.  His conclusion: Python is not the best langauge for that.
19:47:09 <Welkin> unless they are software engineers
19:47:10 <dyl> Just as there are many more academic math users than mathematicians, there are many more academic programming users than programmers.
19:47:17 <dyl> I see this situation as a design failure.
19:47:22 <buhman> really?
19:47:25 <dyl> Scientists can’t be expected to be engineers.
19:47:37 <dyl> And expecting them to always have one or two students who can code competently is also unreasonable.
19:47:45 <arahael> Welkin: Depends on the specialisation.  Software engineers, on the other hand...
19:47:51 <dyl> Avoiding the use of programming tools in the life sciences is now practically impossible.
19:48:13 <buhman> dyl: not trying to contradict at all; but do you count people with job titles like "software engineer" in your count of "programmers"?
19:48:16 <dyl> If it’s not your analyses, it’s your experiments themselves, or a tool/package you use, or figure preparation...
19:48:20 <Welkin> dyl: but programming for those use cases is made as easy as importing a libraries and passing a bunch of data to one function
19:48:29 <dyl> But in practice it’s not just that.
19:48:30 <Welkin> it's not software engineering, more like scripting
19:48:40 <dyl> Right, it is closed to scripting.
19:48:51 <crestfallen> hi please teach me the intuition for writing folde here: the first pattern match I understand fine...  https://ptpb.pw/LB5y
19:48:56 <dyl> But reproducibility and determinism matter even more and aren’t enforced or even encouraged in any meaningful way.
19:49:13 <dyl> Code review for published academic code is nonexistent.
19:49:22 <crestfallen> its the second one that is tricky for me
19:49:27 <EvanR> i try to pretend that software engineering and scripting are different too
19:49:28 <dyl> Use of invariant analyses techniques or even numeric stability analyses is nonexistent.
19:49:43 <dyl> Software engineering is different than scripting in that the users are a team.
19:49:50 <dyl> Scripting to me is smaller scale.
19:49:54 <Cale> crestfallen: the idea is that we're taking replacements for each of the data constructors, and making those replacements throughout the structure
19:49:55 <arahael> And software engineering requires a whole project.
19:49:56 <dyl> And in practice in labs it’s 1-2 people.
19:50:00 <Cale> crestfallen: It might help to write it like...
19:50:05 <dyl> And maybe a few more that are just copy pasting and reusing bits.
19:50:06 <arahael> "scripting" is just a task, which may well be part of a project.
19:50:10 <dyl> ^
19:50:15 <dyl> More or less, yes.
19:50:15 <Cale> folde val add = f
19:50:17 <dyl> That’s my take.
19:50:23 <Cale>   where f (Val x) = val x
19:50:31 <EvanR> totally
19:50:38 <Cale>         f (Add x y) = add (f x) (f y)
19:50:40 <Welkin> a script is just thrown together, not designed in any meaningful way
19:50:49 <Welkin> and you certainly don't invent abstractions
19:50:56 <Welkin> just use library functions
19:50:57 <dyl> Correct.
19:51:00 <dyl> Not always.
19:51:03 <crestfallen> Cale why did you use add there?
19:51:03 <dyl> But usually yes.
19:51:10 <Cale> It's the replacement for Add
19:51:16 <dyl> But when those scripts are meaningful parts of your research and publishable
19:51:23 <Cale> The idea is to replace each Val with val and each Add with add
19:51:25 <dyl> “idk this script worked” ceases to be acceptable.
19:51:32 <Welkin> dyl: yeah, I can see the problem
19:51:32 <dyl> We can do better.
19:51:33 <Cale> throughout the entire structure
19:51:37 <EvanR> people just throw together, in no meaningful way, using library functions, whole huge projects all that time!
19:51:40 <dyl> Especially given the usage patterns you point out.
19:51:52 <dyl> This is a use case in which invariant analysis could work very well for example.
19:51:53 <Cale> So if you have something like Add (Val 5) (Add (Val 1) (Val 2))
19:51:55 <crestfallen> ok so that is the first line, what about the second Cale?
19:52:09 <Cale> the result we want is  add (val 5) (add (val 1) (val 2))
19:52:13 <Welkin> I have a friend who recently had to take over a disaster of a project that is a searchable database of grad student papers that was many thousands of lines of php
19:52:21 <Welkin> a huge mess written over many years
19:52:21 <Cale> where add and val are these functions which are supplied by the user
19:52:22 <dyl> The tooling also needs to be better. But the catch is that if it requires any onboarding time or introduces issues, it won’t be used.
19:52:32 <Cale> so we just recursively replace them throughout the structure
19:52:40 <EvanR> dyl: what are you talkng about again?
19:52:50 <Welkin> EvanR: programming tools for scientists
19:52:53 <Welkin> better tools*
19:52:56 <Cale> If the input is of the form  Val x  the result is  val x
19:52:56 <dyl> How bad the programming situation is in academia.
19:52:57 <EvanR> python?
19:53:00 <crestfallen> these functions being (+ 0) and (+) right Cale ?
19:53:07 <Cale> not necessarily
19:53:09 <Cale> they could be anything
19:53:13 <dyl> One sensible approach I see is in “interactive assistant” type tools, that do not impose constraints but guide towards better practices.
19:53:15 <Welkin> dyl: how do you thikn it can be improved?
19:53:21 <Welkin> the language, or the general tooling?
19:53:28 <dyl> A few ways but none that I can be sure of without user studies.
19:53:29 <dyl> So
19:53:31 <Welkin> haha
19:53:34 <Welkin> you mean like haskell?
19:53:37 <dyl> I would like to do things from the language.
19:53:37 <EvanR> improving the people
19:53:42 <Welkin> at least a type system
19:53:46 <dyl> But the reality is you won’t get people to switch.
19:53:47 <Welkin> have them use Coq! :D
19:53:51 <dyl> The risk is too high.
19:53:58 <crestfallen> ok thanks could you give an example of alternatives where we're not looking at the second two funcs size and eval ?
19:54:00 <dyl> You need to nudge people towards better practices incrementally.
19:54:01 <crestfallen> Cale
19:54:11 <arahael> I'd bet that most data scientists are still on python 2.7
19:54:12 <dyl> You need to give them something that helps them but doesn’t get in their way.
19:54:13 <crestfallen> for f and g
19:54:15 <Cale> Sure, perhaps we want to know the depth of the expression
19:54:17 <dyl> This is a design problem imo.
19:54:29 <dyl> arahael you mean 2.6 :p?
19:54:45 <dyl> And yes it is mostly 2.6/2.7. Though the situation with 3 is much better now.
19:54:57 <Welkin> python2 is deprecated
19:55:00 <Welkin> 3 is the standard now
19:55:04 <crestfallen> at attention...
19:55:06 <dyl> So are plenty of things frequently used.
19:55:07 <Cale> So  depth = folde (const 0) (\d1 d2 -> 1 + max d1 d2)
19:55:08 <Welkin> even numpy/scipy switched to 3
19:55:09 <arahael> dyl: Heh.  Indeed.  They only switch to python3 once it's literally a drop-in replacement, which depends on how the code was accidentally written.
19:55:09 <Welkin> I believe
19:55:12 <dyl> Academic programming tools and usage are the epitome of “the enemy of better is good enough”.
19:55:20 <EvanR> i am tired of talking about python
19:55:23 <dyl> Any successful tools in this space need minimal “activation energy”.
19:55:23 <Welkin> haha
19:55:38 <Cale> crestfallen: Or perhaps we'd just like to flip the entire expression over, reversing all the Adds
19:55:40 <dyl> They need to be catalysts, not new reactants.
19:55:45 * dyl falls into biospeak.
19:55:53 <Welkin> dyl: so what advantages do you think julia has?
19:55:54 <Cale> flipExpr = folde Val (flip Add)
19:56:03 <dyl> Julia is a neat language but I don’t see it replacing Python.
19:56:12 <Welkin> and then there is R, which looks technically better, but no idea how usable it is
19:56:16 <arahael> Julia does have a fantastic python binding, though.
19:56:20 <dyl> The main use case is heavily numeric computations where Python isn’t cutting it and it’s a young student.
19:56:29 <Cale> So that'll turn  Add (Val 1) (Add (Val 2) (Val 3)) into  Add (Add (Val 3) (Val 2)) (Val 1)
19:56:30 <dyl> The cost of hopping from Python to Julia is relatively low.
19:56:40 <EvanR> so haskell
19:56:45 <dyl> But the cost of using scipy/pandas is even less.
19:56:46 <EvanR> -offtopic
19:56:57 <Welkin> EvanR: it's happy hour
19:57:08 <crestfallen> Cale thanks ! I'm getting kicked out of cafe. thanks I will study that appreciate it !!
19:57:16 <arahael> Welkin: "happy hour" implies everybody is happy.k
19:57:16 <rotaerk> EvanR, go into #python and start talking about haskell
19:57:20 <rotaerk> bring the world into balance
19:57:33 <Cale> crestfallen: As your expressions get more complicated, there will be more interesting functions to write
19:57:38 <dyl> rotaerk: when this channel was all math for an hour I checked ##math and they were talking about programming.
19:57:43 <Welkin> rotaerk: his messages will soon be lost in a sea of "help me my program doesn't work!"
19:57:43 <rotaerk> heh
19:57:52 <Cale> crestfallen: for example, if there were lambdas, perhaps we could write something to collect up all the free variables
19:58:36 <arahael> Welkin: I'm curious.  Why wouldn't an html renderer be written in haskell?
19:58:43 <dyl> arahael: the key theme I want to emphasize is “oh, it’s nice, but good luck with adoption”.
19:58:45 <crestfallen> I see yes, really getting kicked out .. thanks Cale for your time and patience.
19:58:50 <rotaerk> haskell code can be hard to understand, but compared to other languages, it's not easy to *misunderstand* either
19:58:59 <dyl> And that’s why I don’t think new languages can help too much *alone*.
19:59:06 <Welkin> rotaerk: I disagree. It depends on who wrote the code
19:59:10 <dyl> The tooling needs to be more robust and designed for that class of users.
19:59:11 <Welkin> I have read some horrendous haskell
19:59:18 <arahael> rotaerk: Ironically, my data scientist colleague is a fan of haskell, too...  But he uses python instead.  Prefers python.
19:59:18 <Welkin> that made me want to gouge my eyes out with a spork
19:59:32 <arahael> rotaerk: Because python integrates into his tools much, much better. (Eg, Jupyter)
19:59:38 <dyl> Welkin: that’s what happens when you don’t meditate for two hours and then emit a single catamorphisn.
19:59:39 <rotaerk> Welkin, well yea, but did you misunderstand it, or just fail to understand it
19:59:39 <Welkin> mostly they abuse language features like typeclasses galore and use all the extensions they can think of
19:59:51 <Welkin> and, no parentheses
20:00:00 <Welkin> dolla dolla bills yall
20:00:06 <dyl> rotaerk: thats one great thing about the design space I’m interested in: it’s published so it doesn’t mater
20:00:13 <dyl> Incomprehensible = you failed
20:00:13 * hackage unagi-bloomfilter 0.1.1.2 - A fast, cache-efficient, concurrent bloom filter  https://hackage.haskell.org/package/unagi-bloomfilter-0.1.1.2 (BrandonSimmons)
20:00:33 <rotaerk> if you can't understand code, you won't do any damage to it, because you'll be paralyzed
20:00:43 <rotaerk> if you misunderstand code, you'll think you know what to do, and then make bugs
20:00:46 <Welkin> arahael: it's not that a render can't be written in haskell, it's just that I have not seen one yet
20:00:49 <dyl> It doesn’t matter if you have the best results ever if your figures and analysis are impossible to follow and your conclusions are stated ambiguously.
20:01:00 <dyl> Oh you haven’t met postdocs.
20:01:11 <dyl> “This code in this nature paper with 200 citations MUST BE GOOD!”
20:01:17 <dyl> “I’ll write everything just like this now.”
20:01:18 <rotaerk> code understandability is important, but I posit that misunderstandability is more of a concern
20:01:24 <dyl> [repeat over a dozen papers]
20:01:30 <dyl> It’s a snowball of bad.
20:01:39 <rotaerk> even more *
20:01:40 <arahael> Welkin: Fair enough.
20:01:44 <EvanR> dyl: you are hurting all the postdocs feelings in this channel
20:02:00 <dyl> Postdocs in biology/etc.
20:02:03 <dyl> It’s not their fault.
20:02:08 <dyl> They’re just trying to get good results.
20:02:12 <dyl> They’re not programmers.
20:02:13 <Welkin> I have heard of what a circus academia is from my phd friends
20:02:19 <dyl> The other point is that understandability doesn’t need to just be a facet of the language itself.
20:02:22 <dyl> Tooling can help here.
20:02:28 <Welkin> and how they had to make their papers *worse* to get them accepted by conferences
20:02:33 <dyl> Mining for invariants can help. QA approaches can help.
20:02:36 <Welkin> "Not enough math. Add mroe equations."
20:02:50 <EvanR> brainwashing troubled users can help
20:02:54 <EvanR> re-education
20:03:23 <dyl> I’m more interested in how tight feedback loops between user and tool can improve the user, ideally leading them to better tool choice and usage.
20:03:26 <EvanR> reconditioning for the god-given technologies
20:03:34 <dyl> You can’t make a good tool without considering the user.
20:04:11 <dyl> EvanR: I call it SCIPY-ULTR— wait never mind.
20:04:16 <jchia> question about serialization: When doing serialization, it's often for communication with non-Haskell systems. Packages like binary and store don't document their serialization format, at least as far as I can see from the haddock. What can I do do do serialization properly in such use cases? I've just been making assumptions about the format and manually testing for proper communication of the data with no assurance of what the format is.
20:04:34 <jchia> "What can I do to do serialization ..."
20:04:40 <EvanR> json
20:04:44 <arahael> jchia: I would've thought that having agreement as to the format is quite important.
20:04:48 <geekosaur> jchia, json and bson are most common for serialization between non-haskell apps
20:05:10 <jchia> EvanR: json is bad for various reasons. I think it doesn't do nan or inf properly, for one thing. for another, it's quite wasteful
20:05:14 <geekosaur> there's some protocol buffers implementations as well
20:05:29 <EvanR> who sends NaN or Inf...
20:05:30 <arahael> jchia: I've seen swagger.io being very common as a documentation format.  It doesn't seem that hard to parse their format representation either, and spit out code.
20:05:41 <arahael> jchia: (Their code generators suck)
20:05:50 <jchia> e.g. if i have a an array of doubles, json would be wasteful
20:06:04 <arahael> jchia: JSON doesn't have doubles, anyway.
20:06:18 <EvanR> on that note, what is a common, or even existing standard format that encodes doubles?
20:06:28 <jchia> EvanR: Not every numerical application just throws inf and nan away.
20:06:33 <arahael> google protocol buffers, I think.
20:06:34 <EvanR> actual doubles, not json styl
20:06:58 <EvanR> how do you do that, like, IEEE binary format?
20:07:06 <EvanR> big endian
20:07:13 <jchia> IEEE-754 is a most sane way to send doubles and floats
20:08:10 <EvanR> dunno why i havent seen that around, maybe because its iffy in C whether you can "just" load that data
20:08:13 <geekosaur> there's probably an asn.1 binding as well, but eurggggh
20:10:11 <arahael> EvanR: A bit of searching around seems to indicate that they use IEEE-754 in practice, but I don't see it specified in the documentation.
20:10:44 <EvanR> who
20:10:51 <arahael> EvanR: Google Protocol Buffers.
20:11:29 <jchia> I wonder why packages like binary and store don't document their serialization format.
20:11:44 <arahael> A fantastic question.
20:12:40 <geekosaur> so they can change it
20:12:43 <EvanR> ^
20:13:14 <EvanR> binary is not really for sending to foreign entities
20:13:22 <geekosaur> iirc binary does have some way to recognize and upgrade older versions, but it's not ... that
20:15:18 <EvanR> and with compact regions you can send "unserialized" data to the same haskell program somewhere, so i wonder what binary is for :)
20:15:36 <EvanR> dump and load unserialized heap images
20:21:48 <dyl> EvanR i use an array of entangled qubits on either end to pass data structures.
20:21:58 <dyl> It’s in the newest version of emacs.
20:22:14 <dyl> I think it’s under quantum-org-mode.
20:39:12 * hackage Octree 0.6.0.0 - Simple unbalanced Octree for storing data about 3D points  https://hackage.haskell.org/package/Octree-0.6.0.0 (MichalGajda)
20:42:43 * hackage bindings-GLFW 3.2.1.0 - Low-level bindings to GLFW OpenGL library  https://hackage.haskell.org/package/bindings-GLFW-3.2.1.0 (Mokosha)
20:44:13 * hackage GLFW-b 1.4.8.3 - Bindings to GLFW OpenGL library  https://hackage.haskell.org/package/GLFW-b-1.4.8.3 (Mokosha)
20:49:20 <jackcrfs> newbie question again: how to convert [Char] to Data.ByteString.Lazy.Internal.ByteString?  aeson.decode seems to want that
20:49:49 <EvanR> youd have to utf8 encode it
20:50:04 <jackcrfs> ah! i see, how?
20:50:22 <EvanR> encodeUtf8 :: Text -> ByteString
20:50:26 <jackcrfs> thanks!
20:51:50 <EvanR> in Data.Text.Lazy.Encoding
21:14:13 * hackage path-extra 0.1.1 - Some extensions to Chris Done's path library, for use with urlpath and attoparsec-uri.  https://hackage.haskell.org/package/path-extra-0.1.1 (athanclark)
21:43:13 * hackage urlpath 8.1.0 - Painfully simple URL deployment.  https://hackage.haskell.org/package/urlpath-8.1.0 (athanclark)
21:47:22 <EvanR> > wordSize
21:47:25 <lambdabot>  error: Variable not in scope: wordSize
21:48:31 <EvanR> do you need containers to use Data.Map couldn't sworn its always available (base) ?
21:48:43 <EvanR> could've
21:53:15 <nshepperd> it's in containers
21:53:54 <nshepperd> containers seems to be usually distributed with ghc though
21:54:29 <nshepperd> it's in my ghc-8.2.2 package for instance (on archlinux)
21:54:31 <EvanR> does that explain why ive never failed to import it
21:55:00 <nshepperd> probably
22:09:43 * hackage GLFW-b 1.4.8.4 - Bindings to GLFW OpenGL library  https://hackage.haskell.org/package/GLFW-b-1.4.8.4 (Mokosha)
22:22:17 <boj> anyone familiar with how haskell libraries in nixpkgs get bumped? are they just snapshots of hackage when a channel is made?
22:25:29 <cocreature> boj: iirc they’re based on stackage lts so if your package is in stackage, that version will be chosen. otherwise it’s the latest version by default. for some packages there are also multiple versions in nixpkgs
22:27:43 * hackage beam-postgres 0.3.1.0 - Connection layer between beam and postgres  https://hackage.haskell.org/package/beam-postgres-0.3.1.0 (TravisAthougies)
22:32:09 <boj> cocreature: blah, my network dropped. sorry
22:32:34 <cocreature> boj: you can see my answer in the logs if you missed it although given that you’re mentioning my name you probably haven’t :)
22:32:49 <boj> there's an email from 2016 on their mailing list about dropping support for tracking stackage lts releases
22:33:31 <boj> i'm pinned to 17.09, and have been curious why servant is stagnant at 0.11 instead of 0.13
22:33:45 <cocreature> I don’t think they follow lts too strictly but afaik it’s still the basis
22:36:46 <boj> i've been adding stuff i need by pinning them to hackage, but since we do clean room builds it results in full package recompiles for the snowflakes. was hoping i had just missed something
22:37:43 <cocreature> I think the way a lot of companies deal with this is by running their own nix caches
22:38:34 <boj> yeah, that makes sense
22:38:53 <dmj`> boj: if you open nix-repl and check out haskellPackages.serv… servant_0_13 should be in there
22:40:59 <dmj`> boj: actually, latest nixpkgs unstable has it
22:42:04 <boj> dmj`: thanks. i guess i'll have to patiently wait for it to fall into a stable channel
22:42:21 <boj> or look into forking our own, hmm
22:42:33 <dmj`> boj: nixpkgs-unstable is … stable enough :)
22:43:12 <boj> sadly it breaks a few things for us. someone accidently spun up an env on it and freaked out on me the other day :)
22:43:29 <dmj`> boj: ah, that’s no good. What was the error?
22:43:54 <boj> nix 2.0 becoming the new default doesn't play nice with a lot of our stuff atm
22:44:32 <dmj`> boj: ah, yea. Make sure the old nix is uninstalled ‘nix-env -e nix'
22:51:43 * hackage directory 1.3.2.2 - Platform-agnostic library for filesystem operations  https://hackage.haskell.org/package/directory-1.3.2.2 (Rufflewind)
23:04:41 <dminuoso> I have multiple threads that need to connect to an LDAP server with no transactional support. They basically modify/create/delete a single resource, and it cant work atomically. What Haskell idiomatic mechanisms do I have to synchronize the threads with mutual exclusion?
23:05:14 <dminuoso> (I dont actually have any threads yet, Im mapping out what I need for this)
23:06:13 <boj> hmm, so not stm. mvars?
23:07:59 <dminuoso> boj: Why wouldn't stm work? Basically when a user requests a change to `record1` it needs to be read and written back. Until that has happened the `record1` needs to be blocked.
23:08:23 <dminuoso> Would a tvar holding some list of records currently "held" work?
23:08:30 <boj> dminuoso: i am not sure really. you said it can't work atomically, which is kind of the point of stm i think
23:08:44 <geekosaur> I understodod that to mean that LDAP isn't atomic
23:08:57 <geekosaur> but that poses a different problem: what of other unrelated things trying to do updates?
23:09:05 <boj> ah, my poor reading skills
23:09:28 <dminuoso> geekosaur: By contract we have only a single server to interact with LDAP.
23:09:50 <dminuoso> So we can pretend there are no other unrelated things
23:12:24 <boj> dminuoso: if the LDAP connection is the resource, seems any of the standard haskell concurrency primitives would work fine. TVar, MVar
23:12:58 <EvanR> you need a MVar or TMVar holding the "token" necessary to access the LDAP service
23:13:28 <EvanR> one thread takes it, does stuff, and puts it back when done. or when it crashes, by virtue of you using a bracket (modifyMVar_)
23:13:58 <EvanR> you could put the connection itself in there, if it werent the tendency or stuff to disconnect randomly
23:14:59 <dminuoso> EvanR: Well it would be multiple tokens. Each instance of the resource would be blocked.
23:15:18 <EvanR> i dont get it
23:15:40 <dminuoso> EvanR: Say you have an ldap full of users. One thread can modify `user1` while another is modifying `user2`
23:15:49 <dminuoso> But you cant have two threads both modifying `user1`
23:15:56 <EvanR> you can do that?
23:16:09 <dminuoso> err. yes?
23:16:19 <EvanR> interesting
23:16:34 <boj> oh, so the users are the resources, not the ldap connection. and your app has some guarantee that all users it is tracking are unique?
23:16:38 <EvanR> that adds some complexity
23:17:01 <dminuoso> boj: Yes. Users are identified by distinguished names, which are guaranteed to be unique.
23:18:06 <EvanR> with a TVar (Set User), initially empty set, attempt to write your name to the set before continuing. if its already there, retry
23:18:37 <EvanR> if your action crashes, youll need to arrange before hand to erase that name
23:20:20 <EvanR> it will be like an infinite number of locks
23:21:17 <boj> dminuoso: i guess the idiomatic way would actually be stm then. i've done something like TVar (Map UserId (TVar UserData)) recently for a threaded network server
23:27:22 <xpika1> can a 3 element tuple be converted to a list using lens?
23:31:15 <jle`> > (1,2,3) ^.. each
23:31:18 <lambdabot>  [1,2,3]
23:31:27 <jle`> > toListOf each (1,2,3)
23:31:31 <lambdabot>  [1,2,3]
23:32:57 <dminuoso> boj: How would I ensure that some failure would not lead to some user being permanent locked?
23:35:13 <dminuoso> > (1, 'a') ^.. each
23:35:16 <lambdabot>  error:
23:35:16 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
23:35:16 <lambdabot>      • In the expression: 1
23:35:17 <dminuoso> > ('a', 1) ^.. each
23:35:20 <lambdabot>  error:
23:35:20 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
23:35:20 <lambdabot>      • In the expression: 1
23:35:31 <dminuoso> Interesting to get the same diagnostic.
23:36:33 <boj> dminuoso: hmm, yeah. you want to acquire a lock on a user, but then do some IO on it via LDAP, which can't happen in STM
23:36:37 <jle`> dminuoso: each has instances for (a,a,a)
23:36:57 <jle`> so it sees 'a' so it thinks you're doing (Char, Char)
23:38:24 <dminuoso> jle`: What causes `Char` to be picked? Is that because it's monomorphic? I just tried it with ('a', 1 :: Int) and (1 :: Int, 'a') which produces different diagnostics.
23:39:40 <boj> dminuoso: seems making the LDAP connection (or a token it needs to be used) as your lock resource is apt. then you can only ever manipulate one user at any given time
23:40:56 <dminuoso> boj: That defeats the purpose of having multiple threads though. ;)
23:41:21 <boj> dminuoso: do you need multiple threads?
23:41:46 <boj> like, you are manipulating a few million users constantly?
23:42:43 <boj> the one true source of info would be LDAP in your case, right? seems the restriction is control over access to it
23:47:13 <dminuoso> boj: In my case it's just latency Im concerned about, rather than throughput.
23:47:39 <EvanR> dminuoso: you can construct a bracket for the purpose of doing the task, then whether or not the task completes normally, does the unlocking. the unlocking "cant fail" unless the whole system is failing
23:47:51 <EvanR> using async, pretty easily
23:47:55 <dminuoso> boj: Because of some things an update might take some 100-200ms. There are awkward situations where there could be 3-4 simultaneous requests.
23:49:36 <boj> dminuoso: so the worry is a user might accidently be manipulated twice at the same time due to the latency?
23:49:39 <EvanR> you might also want to add a timeout, to account for when the task never ends for some reason
23:50:05 <dminuoso> boj: No just that you might have to wait up to a second before your request finishes. I like things fast. ;)
23:50:43 * hackage ats-pkg 2.10.0.2 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-2.10.0.2 (vmchale)
23:51:37 <dminuoso> EvanR: But not with stm right? It seems like IO with STM is a bad idea.
23:51:55 <EvanR> the STM isnt essential, no
23:52:25 <EvanR> but because its a TVar with a set in it, its easier for me to understand than an MVar with a set in it
23:52:33 <EvanR> theres always some set in the TVar, always valid
23:53:02 <EvanR> you can do the whole communication within atomically, no
23:53:05 <EvanR> cannot*
23:53:24 <boj> a single MVar lock variable in a user record could work. use bracket as EvanR suggests to unlock it on done/failure
23:53:55 <EvanR> a lock in a user record sounds fishy
23:54:14 <boj> yeah?
23:54:34 <EvanR> if you replicate the record... ok... its still the same lock... ok... ...
23:54:49 <EvanR> but where do you get these records?
23:55:19 <EvanR> a single central set of user ids who are locked seems simpler
23:55:36 <boj> ah, that makes more sense
23:55:42 <dminuoso> EvanR: wait a second. How would I use TVar without STM?
23:55:58 <EvanR> you would use atomically to do the locking and unlocking
23:56:27 <EvanR> two atomicallys (so no, the whole dance is not atomic at all)
23:56:36 <EvanR> which it cant be
23:57:11 <EvanR> or use two modifyMVar_s
23:57:27 <EvanR> actually no
23:57:48 <EvanR> STM greatly simplifies the case where you need to block until your name is off the list
23:58:09 <EvanR> i dont know how to do that without STM
23:58:50 <dminuoso> EvanR: oh it would be some `atomically (lock "EvanR"); update "EvanR"; atomically (release "EvanR")` ?
23:59:01 <boj> yeah
23:59:25 <dminuoso> No way it can be that simple.
23:59:41 <dminuoso> :o
23:59:46 <boj> :)
