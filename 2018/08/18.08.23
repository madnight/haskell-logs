00:02:44 --- mode: glguy set +v hal
00:02:55 <hal> and myrationalField is defined as myrationalField: 2 % 3
00:03:28 <dminuoso> hal: You'll have to repeat your first message, it did not get through.
00:04:33 <hal> dminuoso: sorry i did not get you what is `repeat your first message`
00:05:09 <cocreature> hal: the first message that we saw was “and myrationalField is defined as myrationalField: 2 % 3”. presumambly you send something before that which got blocked by antispam measures
00:06:09 <hal> how to read Data.Ratio.Rational type from yaml file, i was trying to read it , it throws an error `*** Exception: AesonException "Error in $myrationalField: expected Rational, encountered String"`
00:06:15 <hal> and myrationalField is defined as myrationalField: 2 % 3
00:12:17 <cocreature> hal: what are the contents of the relevant yaml field?
00:15:03 <cocreature> the yaml package uses the FromJSON instance to decode fields and for Rational it expects to see json like { "numerator": 2, "denominator": 3} (or rather the yaml translation of that)
00:15:26 <cocreature> if that’s not what you want, you need to change how things are decoded
00:15:43 <cocreature> e.g. by making a newtype for Rational that parses the string "2 % 3"
00:15:44 <hal> cocreature: basically want to store one ratio in yaml file and want to read it from haskell program 
00:17:00 <cocreature> hal: as long as you both read and store it from the Haskell program, things should work out fine. the problem here seems to be that you’ve written 2 % 3 into your yaml file by some other means which is a yaml string "2 % 3" and as I’ve explained above that’s not what the yaml package expects to see
00:18:19 <hal> cocreature: thanks { "numerator": 2, "denominator": 3} thing work, and I used 2 %3 beacuse it was woring ghci
00:21:00 <dminuoso> hal: FromJSON does not necessarily use Read.
00:21:08 <cocreature> it pretty much never uses Read :)
00:22:44 * dminuoso tries to resist the temptation to sprinkle his code with TH to remove boilerplate..
00:23:19 <cocreature> I’ll never understand the obsession with removing boilerplate that a lot of Haskellers seem to have :)
00:24:49 <dminuoso> cocreature: One part I quickly learned, is that _typing_ is not the bottleneck of programming, so being explicit/verbose is not really an important problem to address.
00:24:54 <Ariakenom> writing a name twice, or even once, is a terrible thing
00:25:05 <dminuoso> Most of my time is not spend actually _writing_ down code, so..
00:25:13 <dminuoso> Writing code is fast.
00:26:17 <cocreature> there are certainly bad types of boilerplate but a lot of boilerplate is also fairly simple code, that is hard to get wrong, easy to debug if it is wrong and not worth the effort to get rid of it
00:26:56 <dminuoso> Whereas the boilerplate removal techniques rely on fancy type hacking, template haskell, generic usage - suddenly your diagnostics turn to shit, debugging gets hard, understanding what code does is hard..
00:27:20 <cocreature> exactly
00:28:05 <cocreature> remove boilerplate if it becomes a problem, it’s not a goal in itself
00:28:34 <dminuoso> In my case I have 150 encoders and decoders that are _highly_ mechanical. Ideally I'd write them down as a specification and derive decoders/encoders automatically..
01:00:10 <dminuoso> Is there a way to have hlint pick up extensions enabled in my cabal file?
01:52:47 * hackage hw-ip 0.2.0.0 - Library for manipulating IP addresses and CIDR blocks  http://hackage.haskell.org/package/hw-ip-0.2.0.0 (haskellworks)
02:04:44 <dminuoso> johnw: Oh yes, `logging` looks like it could be what I need.. let me just wrap your library to enhance it with TID/PID :P
02:12:10 <merijn> Does anyone know how I can send posix signals to processes created with process? Apparently "terminateProcess" sends SIGTERM and some incompetent idiots are blocking that, so I'm not *actually* killing the process...
02:13:36 <merijn> Is there like a "terminateProcessWithExtremePrejudice"?
02:13:55 <[exa]> you can kill by process group
02:14:15 <[exa]> (man 3 killpg)
02:14:35 <merijn> [exa]: That seems...entirely unrelated to my entire question
02:16:17 <[exa]> well that's the common posix way to kill processes created by a process... :]
02:16:44 <dminuoso> merijn: You could try sending SIGBUG
02:16:50 <dminuoso> *SIGBUS
02:17:12 <merijn> dminuoso: Doubt it, they'd probably also ignore that if they're ignoring SIGTERM
02:17:19 <merijn> dminuoso: I just need to send SIGKILL
02:17:26 <merijn> dminuoso: But my question was: How
02:17:30 <cocreature> you probably need to use the unix package instead of process
02:17:36 <cocreature> i don’t think SIGKILL is a cross platform thing
02:17:40 <merijn> process has no support for for posix signals
02:17:43 <merijn> cocreature: I know
02:17:47 * hackage tax 0.2.0.0 - Types and combinators for taxes  http://hackage.haskell.org/package/tax-0.2.0.0 (frasertweedale)
02:17:49 <dminuoso> merijn: Ah
02:18:19 <merijn> Also, I already sent SIGBUG, since I think it's a misconfiguration/upstream bug, but I'm not in charge of that code
02:18:44 <dminuoso> Heh,.
02:19:08 <merijn> And I'd like to not repeat my problem of "whoops, I have 10k processes stuck in limbo on a shared head node" :)
02:19:45 <cocreature> merijn: the internals of process are exposed and let you get the CPid and then you can use signalProcess from unix
02:20:00 <merijn> cocreature: Yeah, I just found that
02:26:36 <dminuoso> merijn: Well if they ignore *all* signals you're shit out of luck as far as I know.
02:27:04 <dminuoso> The best thing you could do is kill its parent.
02:27:27 <dminuoso> It's unlikely they will catch sigSEGV/sigBUS though
02:27:35 <merijn> dminuoso: No
02:27:41 <merijn> dminuoso: Because you *can't* ignore SIGKILL
02:28:06 <merijn> You can't block, handle, or otherwise inhibit SIGKILL
02:28:30 <merijn> So there's no reason to do hacky things like sending SIGSEGV or SIGBUS when SIGKILL is just guaranteed to work
02:28:43 <dminuoso> merijn: Oh.. interesting. I did not know this.
02:28:50 <merijn> SIGTERM is the polite "will you please shutdown?" signal
02:29:06 <merijn> SIGKILL is the "kernel shoots process in the back of the head without asking" signal
02:29:19 <dminuoso> merijn: Well its not that extreme.
02:29:25 <dminuoso> Consider the inability to kill zombies.
02:29:31 <merijn> dminuoso: Zombies are already dead
02:29:34 <dminuoso> Heh
02:29:46 <Rembane> The Posix chainsaw signal?
02:29:48 <merijn> dminuoso: Zombie just means "dead process that parent hasn't yet waited on"
02:30:10 <merijn> dminuoso: To get rid of zombies you need to either make the parent wait on them OR kill the parent and let the grandparent deal with it
02:30:14 <dminuoso> merijn: There's no way to reap it from the process table however
02:30:20 <dminuoso> Fair enough
02:30:23 <merijn> dminuoso: Eventually you'll get to init which will auto-wait on all its children
02:32:12 <merijn> In fact, that's init's main purpose
02:34:17 * hackage hedis 0.10.4 - Client library for the Redis datastore: supports full command set,pipelining.  http://hackage.haskell.org/package/hedis-0.10.4 (k_bx)
02:41:08 <raduom> Hi everyone! I am using stack + hpack and i need to add a dependency to a package which is fetched in a submodule. How can I do that?
02:42:02 <dminuoso> raduom: What do you mean? Do you need to modify a dependency of your?
02:42:58 <raduom> I have a stack project A which depends on another stack project B. Project B is in directory submodule/B. How do I setup this dependency using hpack (package.yaml) and stack?
02:44:11 <merijn> hmm, interesting..
02:44:46 * hackage rhine 0.4.0.4 - Functional Reactive Programming with type-level clocks  http://hackage.haskell.org/package/rhine-0.4.0.4 (turion)
02:45:08 <merijn> cocreature: Turns out the entire reason I missed this issue is because my cleanup handler is just skipping over "waitForProcess". And wrapping it inside a "try" to see what happens with waitForProcess seems to do nothing...
02:45:11 <dminuoso> raduom: Is `B` in a submodule of `A`? 
02:45:21 <raduom> Yes.
02:45:42 <dminuoso> raduom: Im not sure whether this is a git-related question at all. From stacks perspective it's just a local directory
02:45:47 * hackage rhine-gloss 0.4.0.4 - Gloss backend for Rhine  http://hackage.haskell.org/package/rhine-gloss-0.4.0.4 (turion)
02:45:54 <dminuoso> raduom: So just add it to your `packages` in your package.yaml
02:46:01 <merijn> I'm a bit confused how I'd go about debugging this o.O
02:48:05 <merijn> How can IO actions be skipped without throwing an exception? o.O
02:48:36 <lavalike> continuations?
02:48:45 <merijn> no, this is just straight IO code
02:49:15 <dminuoso> merijn: unsafeInterleaveIO?
02:49:30 <merijn> dminuoso: Not in my code and also not in the the code used by process
02:49:42 <raduom> package.yaml: Ignoring unrecognized field $.packages
02:51:26 <merijn> This code: https://bpaste.net/show/17d3a3fdfe19
02:51:54 <merijn> "bar!" gets printed, but xyzzy never runs and neither do the case branches run
02:52:05 <merijn> It's as if it just stops right after printing "bar"
02:52:17 <merijn> Except other code in the shutdown keeps running afterwards, so that's not it
02:52:48 <dminuoso> merijn: What stdout buffering mode do you have?
02:52:58 <mniip> merijn, so what happens exactly?
02:53:06 <merijn> dminuoso: Good question!
02:53:19 <merijn> dminuoso: Should be line buffered, it's connected to terminal
02:53:51 <merijn> mniip: That function runs N times in sequence (once for every N processes) and all of them stop after the second putStrLn
02:54:42 <merijn> lemme set it to unbuffered
02:55:42 <dminuoso> merijn: This might be a silly question.. but waitForProcess does block and wait, doesn't it?
02:56:07 <merijn> yes
02:57:20 <dminuoso> merijn: why do you say it's *skipped* over?
02:57:32 <merijn> dminuoso: Because they're executing in a single thread
02:57:57 <merijn> dminuoso: And the rest continues to run
02:58:33 <dminuoso> merijn: Is this some weird deadlock because of your uninterruptibleMask perhaps?
02:58:42 <merijn> But it's not deadlocking
02:58:58 <merijn> The code just continues cleaning up and exits as-if the rest of the function isn't there
02:59:24 <mniip> merijn, doublecheck that you're running the right binary compiled from the right sources?
02:59:54 <mniip> merijn, wait, you have uninterruptibleMask
02:59:56 <merijn> mniip: My changes are happening in the logging show up fine
03:00:51 <merijn> mniip: Yes, so?
03:03:05 <mniip> if anything is thrown that will suppress the exception
03:03:09 <merijn> mniip: No
03:03:18 <merijn> uninterruptibleMask only suppress async exceptions
03:04:45 <dminuoso> merijn: How do you use destroyProcess?
03:05:06 <merijn> dminuoso: Cleanup function for resource-pool
03:05:28 <merijn> But I think I just realised a leak condition
03:05:35 <dminuoso> merijn: Then my question remains: How do you conclude that thing is being skipped over, as compared to being *stuck*
03:06:39 <merijn> dminuoso: destroyAllResources destroys them sequentially, but I just realised there's an edge condition where maybe one or two of them are not run as part of that
03:07:41 <maerwald> stack can't clone from local directories?
03:37:24 <madnight> maerwald: there's a solution that can clone from local directories, it's called nix
03:39:27 <mniip> wth
03:39:36 <maerwald> madnight: no.
03:39:54 <mniip> compiling ghc and getting random intermittent unknown identifiers here and there...
03:40:03 <maerwald> stack can, it was a different problem
03:40:05 <mniip> did I mess up hiface generation in the stage1
03:42:05 <madnight> maerwald: my sentence hasn't become invalid, even though stack can clone too
03:46:24 <madnight> i have another truthfully one: if you find yourself having many different problems with stack (in the past) try: nix
03:48:45 <mniip> I am subject to probably the worst combination of programmer practices
03:49:12 <mniip> I don't use hjkl in vi, I use the distribution-provided ghc, and distribution-provided cabal
03:49:19 <mniip> and I install packages into the global store
03:49:30 <mniip> oh and hard tabs
03:49:55 <marvin2> hard tabs in haskell source? no issues with that? 
03:50:12 <mniip> I just know to indent let-in properly, is all
03:50:42 <mniip> "in" needs to be more indented than the "let"
03:51:15 <mniip> and I never depend on a particular tab width
03:51:19 <maerwald> madnight: your sentence is not useful
03:51:42 <maerwald> I'm tired of people suggesting unrelated tools when someone asks for a specific problem for tool XY
03:52:40 <madnight> i agree, except that it is not unrelated in this case
03:54:05 <mniip> marvin2, here's an example of how I indent lets, guards, etc https://github.com/mniip/dequantify/blob/master/Main.hs#L155-L178
03:54:25 <mniip> when pushing something to hackage I would think twice but this is a private use experiment program
03:55:00 <Athas> vector-algorithms still has not been updated for GHC 8.6.  I sent the author a patch a month or so ago, but received no response.  It is a semi-important package, because criterion depends on it.  What is the proper procedure now?
03:55:27 <Athas> (The GHC 8.6 breakage is trivial to fix - vector-algorithms passes -Odph as a compiler flag, which has now been removed.)
03:56:36 <madnight> mniip: how about 80 columns max? hard to read you source for me on mobile devices
03:57:09 <mniip> s   h   r   u   g
03:57:15 <cocreature> Athas: the author is reasonably active on IRC so maybe try contacting them here. if all else fails there is https://wiki.haskell.org/Taking_over_a_package
03:57:23 <maerwald> madnight: yes, it is unrelated. I didn't ask for nix, I asked for stack.
03:58:01 <mniip> I have a 270-column screen and linewrap so me personally I'm not very concerned about it
03:58:40 <Athas> cocreature: is it dolio?  (Inferred by the ~dolio part of the broken homepage URL.)
03:58:49 <maerwald> please have fun introducing actual nix support to a 5 years old codebase just because you want stack to clone a local git repository, then fix CI, deployment, documentation.... seriously?
03:58:57 <cocreature> Athas: yep
03:59:01 <Athas> dolio: ping
04:00:00 <madnight> maerwald: if someone asks how to set a attribute in a deeply nested data structure in Haskell and someone mentions lens, is that unrelated for you?
04:00:03 <maerwald> don't advertise your personal tools, just because you like them
04:00:18 <maerwald> that's a contrived comparison
04:00:30 <maerwald> we are not talking about haskell libraries here
04:00:31 <madnight> it is a question
04:00:54 <maerwald> nix has nothing to do with haskell or stack. It's a package manager that requires a lot of work to support correctly 
04:01:08 <maerwald> don't confuse it with haskell libraries
04:01:08 <cocreature> madnight: that answers the actual question whereas responding to “how do I solve X using tool Y” by “use tool Z ≠ Y” is just annoying and clearly does not answer the question
04:01:31 <barrucadu> madnight: If someone asked for help with a specific lens library, and you recommended a different one, that would also be an unhelpful response
04:01:38 <maerwald> and even stacks nix integration is outright broken (unfortunately)
04:02:30 <madnight> lens is just a recommendation that could solve the problem, not the only solution
04:02:40 <cocreature> yes but it is a solution to the actual question
04:02:55 <cocreature> whereas “use nix” is not a solution to “how do I solve X with stack”
04:03:09 <madnight> so why should someone be allowed to suggest lens then (and lens suggest TH)
04:03:18 <madnight> and TH is more than Haskell
04:03:19 <cocreature> if someone ask “what should I use to manage Haskell deps” “nix” is a perfectly valid answer
04:04:42 <madnight> ok so i guess i get your point cocreature: saying "use lense" is insufficient, you should explain how it exactly solves the problem
04:04:52 <madnight> sind you introduced a new tool
04:04:59 <madnight> *since
04:05:36 <cocreature> I’m not arguing that “use lens” is a sufficient answer, I’m arguing that your answer does not answer the question that has been asked and this kind of behavior is really annoying so I urge you to try to reduce it
04:06:02 <maerwald> Well, his answer was wrong anyway.
04:06:19 <maerwald> If you use nix in a way that plain stack is broken (and cannot be used without nix anymore), you are clearly doing it wrong.
04:06:41 <cocreature> and I really don’t care whether you fancy nix, stack or cabal. if someone asks for help with one tool, either help them with that tool or let other people help
04:07:26 <madnight> maewald: usually you use either stack or nix, not both (at least that's what i do)
04:07:37 <maerwald> Well, that is wrong.
04:09:52 <madnight> okay I try to be more constructive with my nix recommendations then (even though if i know a nix solution to a specific problem)
04:10:47 <cocreature> thanks
04:10:49 <madnight> sorry maerwald, that i bothered you with nix
04:11:02 <maerwald> I already use it, but not to fix stack.
04:16:02 <Ariakenom> mniip: I just wanted to play around with indentation styles. What would you say about https://gist.github.com/Ariakenom/813c6962e438248d98e90b7afab0b9b2 ?
04:16:48 <mniip> I'm not a huge fan of stacked , or | (in datadecl) 
04:17:25 <Cale_> So I've spent the past couple days working on a data structure of kind (((* -> *) -> *) -> *) -> (* -> *) -> *
04:18:37 <phadej> data Foo t m 
04:19:01 <mniip> that's not a transformer-kinded t there
04:19:10 <phadej> ah true
04:19:23 <merijn> Ariakenom: Normally I line up the , and = from guards with the |
04:19:34 <Cale_> The structures we're working on for dynamic queries for data and responses to them between the frontend and backend of our applications are all things of kind (* -> *) -> *, which take a functor to be applied to the "leaves"
04:19:44 <phadej> Fix is (* -> *) -> *, so it's something taking Fix-like things
04:19:44 <mniip> data Foo t m = Foo (m (t Fix))
04:19:45 <phadej> hmm
04:19:52 <phadej> yeah
04:19:56 <mniip> not necessarily Fix, mind
04:20:02 <mniip> data F f = F (f Int)
04:20:09 <phadej> Fix-like-kinded :)
04:20:26 <Cale_> e.g. on the frontend when you're making queries, we use Const Integer pretty much (so we can efficiently increment and decrement it when different parts of the frontend become interested and are no longer)
04:21:43 <Ariakenom> merijn: yeah, just thought it looked a bit strange with | , = in a vertical line. I sort of liked indenting = at least
04:22:08 <merijn> Ariakenom: I find them even weirder not lined up, tbh
04:22:09 <Cale_> On the backend, this becomes Const (Map ConnectionId ()) to indicate which users are interested in each part, and then when we obtain the data, Map ConnectionId itself. Then when we send each user their data, Identity.
04:22:59 <Cale_> But we needed a type of Map-like datastructure for multiple queries of different types whose keys would tell us which type of functor-parametric container the values would be stored in
04:23:15 <Cale_> and which itself would be parameterised by a functor
04:23:34 <mniip> tangential question:
04:23:35 <Cale_> So the keys are indexed on a container type of kind (* -> *) -> *
04:23:45 <Cale_> and thus have kind ((* -> *) -> *) -> * themselves
04:24:29 <Cale_> and then the data type itself must be a functor-indexed container, hence (((* -> *) -> *) -> *) -> (* -> *) -> *
04:24:36 <mniip> SK combinator calculus is equivalent to lambda calculus and if S/K are given simple rank1 typing judgements then it's equivalent to simply typed lambda calculus
04:25:40 <mniip> is there a universal calculus with combinators whose types all shaped like '_ -> _ -> ... -> T' where T is a fixed type
04:26:29 <mniip> that probably didn't make a load of sense
04:27:55 <Cale_> Once you add a bunch of distinct types to the theory, they wouldn't be easily distinguished without adding some combinators for each new one you add...
04:28:01 <mniip> imagine an STLC where the only primitive type is T. I want a combinator calculus which can express any lambda but combinators' types can only be N-ary functions ending in T
04:29:04 <mniip> said types can be rank1 polymorphic of course
04:29:08 <Cale_> i.e. you just want to avoid ill-typed SK terms?
04:29:18 <Cale_> oh
04:29:18 <dstolfa> mniip: what is '_' here?
04:29:24 <Cale_> wait, that's different
04:29:29 <Cale_> I have no idea
04:29:40 <Cale_> oh, only rank 1 :)
04:29:46 <mniip> Cale_, K :: x -> y -> x
04:30:02 <mniip> if it is forced to be a function ending in T you get K :: T -> y -> T
04:30:17 <mniip> and then K K is ill-typed
04:30:32 <Cale_> Yeah, though presumably you want K to have its full polymorphism elsewhere
04:30:34 <mniip> of course, you could have  K' :: (T -> T -> T) -> y -> T -> T -> T
04:30:41 <mniip> with K' K
04:30:48 <mniip> but this requires an infinite family of K's and S's
04:30:53 <Cale_> yeah
04:30:56 <mniip> I was wondering if there's a finite solution
04:31:07 <Cale_> hmm
04:32:46 <Cale_> Well, any well-typed polymorphic SK term can always be applied at a type "ending in T".
04:33:00 <mniip> sure
04:34:21 <mniip> Cale_, that would give the constituent S's and K's different types though
04:34:29 <Cale_> Indeed
04:34:32 <mniip> different arities rather
04:34:36 <mniip> that's the problematic part
04:34:39 <merijn> hmm, what's the right place to report bugs in libraries like STM?
04:35:05 <Cale_> merijn: GHC's bug tracker?
04:37:01 <merijn> hmm, I guess this is more of a bounds issue
04:37:03 <mniip> Cale_, it's impossible isn't it
04:37:31 <mniip> STLC terms can have arbitrary arity (number of arrows until T)
04:37:37 <mniip> a combinator, even polymorphic, has a fixed arity
04:37:43 <mniip> application only decreases arity
04:38:57 <dstolfa> mniip: it does sound impossible to me, mainly because of the restriction that it has to end with T, unless you're willing to allow polymorphic combinators in a way that unless they are instantiated, they don't have to end in T
04:39:01 <dstolfa> but even then
04:39:03 <dstolfa> hmm
04:39:23 <dstolfa> i'm a little hesitant to say impossible here because i've not convinced myself that it is yet
04:39:35 <mniip> I just vaguely proved that up there yet
04:39:38 <mniip> s/yet//
04:40:20 <dstolfa> mniip: right, it has a fixed arity but if it's polymorphic in C : a -> b, b could be another arrow, c -> d and so on
04:40:24 <Cale_> mniip: Polymorphic combinators don't have fixed arity, if they are polymorphic in the type of their resultl
04:40:44 <dstolfa> Cale_: outta my head :-)
04:40:44 <mniip> the combinators have to end in T *accounting* for polymorphism
04:40:51 <dstolfa> mniip: right, then it's impossible
04:40:53 <dminuoso> merijn: Is your bug an STM bug?
04:41:18 <merijn> dminuoso: No, just a bug with GHC HEAD not exporting things that STM needs
04:41:32 <mniip> that's kinda sad
04:41:58 <merijn> mniip: Just something that's not been tested yet
04:42:46 <hpc> i guess technically now it's been tested
04:43:06 <mniip> I hope you can see where I was going with this combinator calculus
04:43:43 <mniip> on a second thought
04:44:13 <mniip> what if we concern ourselves with just the unary lambda functions but now (,) is a primitive type
04:44:56 <mniip> encoding x -> y -> z -> T  as (x, (y, (z, ()))) -> T
04:45:31 <mniip> is there a combinator calculus you could do on that?
04:45:55 <hpc> it would be awkward, you don't get partial application that way
04:47:19 <xsperry> hi
04:47:28 <xsperry> is this list comprehension syntax ghc extension?
04:47:51 <mniip> K :: (x -> T, (y, x)) -> T
04:48:14 <xsperry> >  [(x,y) | x <- [1,2,3] | y <- [4,5,6]]
04:48:16 <lambdabot>  [(1,4),(2,5),(3,6)]
04:48:38 <Maxdamantus> xsperry: no.
04:48:40 <mniip> S :: ((x, (y, z)) -> T, ((x, ()) -> y, (x, z)))) -> T
04:48:46 <merijn> Maxdamantus: I think it is
04:48:48 <Maxdamantus> oh, nvm
04:48:48 <mniip> man this is getting unqieldy
04:48:50 <mniip> unwieldy
04:48:52 <merijn> Parallel list comprehensions
04:48:54 <xsperry> Maxdamantus note that I used | instead of ,
04:48:56 <Maxdamantus> didn't notice the |
04:49:29 <merijn> xsperry: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#parallel-list-comprehensions
04:50:39 <mniip> hpc, hmm, true
04:53:40 <mniip> anyway
04:53:51 <Athas> Does anyone use Generalised List Comprehensions?
04:53:56 <mniip> the culprit here is substituting * or Constraint for T
04:54:03 <xsperry> merijn thanks
04:54:13 <mniip> you have data or class decls which can be polykinded but of fixed arity
04:54:40 <xsperry> list comprehensions were generalized in the beginning right? but then they changed it (unfortunately)
04:54:57 <merijn> xsperry: MonadComprehensions were in at some point, yes
04:55:06 <merijn> xsperry: Generalised list comprehensions looks...more general
04:55:40 <Athas> They are SQL-like.
04:55:54 <Athas> I'm not sure I've ever seen them in the wild.  They are my favourite example of thesis-ware in GHC.
04:56:11 <Athas> (In that I think they were implemented by one of Simon's students.)
04:56:47 <cocreature> Athas: you mean TransformListComp?
04:58:50 <Athas> cocreature: I don't remember what the extension flag is called, but their documented name is "Generalised (SQL-Like) List Comprehensions".
04:59:23 <merijn> Ok, there has to be some genius here that has a sensible suggestion on turning a sequence of float points into compact representation that lets me compare them without being too sensitive to floating point rounding noise
04:59:43 <cocreature> Athas: yeah that’s the one. there is a fairly recent GHC proposal to deprecate them
05:00:17 <mniip> merijn, er, what?
05:00:21 * ski . o O ( "MonadComprehensions madness" by monochrom in 2018-02-17 at <https://mail.haskell.org/pipermail/haskell-cafe/2018-February/128607.html> )
05:00:29 <mniip> do you want Ord on the compact representation?
05:00:31 <Athas> merijn: Set the last significant 4 bits of the base to 0.
05:00:52 <merijn> mniip: No, I just need a boolean "equal or not equal"
05:01:22 <Athas> Just cutting off the least significant bits won't protect you against underflow, unfortunately.
05:01:31 <mniip> ah you want something like 2.8 - 0.8 == 2.0
05:01:33 <merijn> Athas: Any more elaborate pointer on how to do that?
05:01:41 <merijn> mniip: No
05:02:30 <merijn> mniip: I have 2 sequences of floats I need to compare for "approximate" equality, without actually storing the entire sequence and doing a pointwise "seq1[i] - seq2[i] < some_epsilon"
05:02:50 <mniip> I don't understand this spec
05:03:30 <dmwit> merijn: gzip the sequence
05:03:57 <dmwit> Alternately: convert from a higher-precision floating point to a lower-precision one.
05:04:26 <merijn> dmwit: Right, but I'm trying to figure out a reasonable method of lowering the precision
05:04:35 <mniip> cut the mantissa
05:05:13 <dmwit> exactly
05:05:18 <Athas> I don't understand why taking the difference and comparing with an epsilon is not appropriate.
05:05:28 <Athas> (Except that it should be a relative epsilon.)
05:05:30 <merijn> Athas: It's appropriate, it's just not feasible
05:05:41 <merijn> Athas: Because storing the results isn't feasible
05:05:41 <Athas> Why is it not feasible?
05:05:49 <Athas> Why does this require storing them?
05:06:06 <merijn> Athas: Well, how can I compare results against past results without storing said past results?
05:06:20 <Athas> Presumably you can perform *some* operation on them, otherwise would you compare them in *any* way?
05:06:51 <merijn> Athas: Well, originally I was just storing hashes of the result, which works for deterministic integer results, but not for floating point results with noise
05:07:28 <mniip> ah so you want a lenient hash function on float sequences
05:07:29 <Athas> Sum the numbers and store that.
05:07:36 <mniip> should've said that
05:07:43 <merijn> mniip: Right
05:07:56 <merijn> Athas: That's likely to hit many false positives, though
05:08:02 <mniip> that's tricky
05:08:08 <lavalike> I wonder if mniip's idea of cutting the precision and computing the hash of that would do the trick
05:08:10 <merijn> Athas: As, ideally the numbers should always sum up to approximately 1
05:08:12 <Athas> Then also take the subtraction-fold and a few other things.
05:08:22 <mniip> hashing would require separating the floating point type into bins
05:08:26 <dmwit> lavalike: can't hash
05:08:32 <mniip> if the data is near the edge of a bin, the noise might move it into another bin
05:08:32 <Athas> Or multiply each number by its index in the sequence before adding them up.
05:08:41 <lavalike> mniip: indeed
05:08:56 <dmwit> lavalike: You can have two floats one ULP apart that fall into different bins after cutting the significant.
05:09:03 <dmwit> right
05:09:22 <lavalike> dmwit: what does ULP stand for?
05:09:36 <dmwit> I don't remember. It's what you get when you change the last bit of the significant.
05:09:45 <dmwit> unit of least precision, maybe?
05:09:54 <lavalike> reasonable
05:10:15 <dmwit> Yikes. s/significant/significand/ in both messages
05:10:16 <Ariakenom> last position
05:11:44 <dmwit> merijn: Of course, you can combine the two suggestions.
05:12:00 <dmwit> merijn: Reduce precision, then sum every three (say) to use a tenth the space.
05:12:16 <Ariakenom> If you can't cut the precision enough to ge tthem to be equal enough you need to define equal enough better
05:12:20 <dmwit> merijn: Which reduces the false positives a lot compared to summing them all.
05:12:51 <dmwit> merijn: Or sum every 100, or whatever.
05:13:22 <dmwit> merijn: And of course if you know something about the distribution of the floats you can probably do better still. Everything we've said so far is distribution-agnostic.
05:13:25 <merijn> Ariakenom: I only need 2 or 3 significant digits, tbh. But some of the values are small enough that even the 3 most significant digits are just floating point noise
05:13:46 <merijn> So I think I need to just zero out anything below a certain treshold
05:14:19 <mniip> a reinterpretation of dmwit's solution is:
05:14:21 <merijn> dmwit: I know nothing of the distribution, except that the total sum of the sequence is approximately 1.0
05:14:29 <mniip> a hash is a fixed size sample of the sequence
05:14:44 <mniip> two hashes compare as equal if all sampled points do wrt epsilon
05:14:55 <Ariakenom> merijn: maybe just rather than relative precision you want absolute precision?
05:17:01 <Ariakenom> So round to nearest integer (nearest integer divisible by k for less precision)
05:18:57 <dminuoso> Why would not specifying a module that transitively uses TH in exposed-modules/other-modules cause clang to produce linker errors..
05:19:08 <dminuoso> This is with cabal new-build
05:19:26 <dminuoso> https://gist.github.com/dminuoso/a213568ec246b5d61c2929de97c6befa
05:19:39 <dminuoso> Or maybe its not TH.. I have no idea what causes this.
05:19:45 <merijn> Ariakenom: The nearest integer is - for all of them
05:19:54 <merijn> s/-/0
05:20:33 <mniip> nearest integer divisible by 0.001 :P
05:20:43 <Ariakenom> mniip: yes
05:21:03 <Ariakenom> merijn: nearest number with some real k. forall i. i*k
05:21:40 <Ariakenom> integer i. math is not going well today
05:23:36 <Ariakenom> [..., -1, -0.5, 0, 0.5, 1, ...]
05:24:37 <mniip> Ariakenom, it's called "nearest multiple of k"
05:24:43 <mniip> which works out for non-integer k too
05:24:49 <Ariakenom> sounds smart
05:24:59 <mniip> so you don't have to say nonsensical things like "integer [...] 0.001"
05:46:11 <merijn> bleh...
05:46:21 <merijn> apparently waitForProcess can't be interrupted with timeout
05:52:12 <dminuoso> merijn: Thats interesting because it seems to run through allowInterrupt before ffing into wait()
05:52:39 <merijn> dminuoso: Yeah, but a timeout of 2 seconds is still going 20s later, so... >.>
05:54:55 <dminuoso> merijn: Mmm?
05:55:19 <xsperry> I am scraping code from some website, and to avoid initial delay of downloading entire page before I start getting results I just plugged in unsafePerformIO and it magically worked. not sure if I feel comfortable using that function though, and I am wondering what are the alternatives?
05:55:25 <dminuoso> merijn: Staring at this.. do you possibly have *2* places you are waiting for the same process in?
05:55:38 <xsperry> sorry, I meant unsafeInterleaveIO , not unsafePerformIO
05:55:39 <dminuoso> Or two threads.. 
05:56:07 <dminuoso> xsperry: conduit might be a better alternative
05:56:11 <xsperry> looking at http://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO-Unsafe.html unsafeInterlaveIO seems relatively safe, so maybe I should just continue using that?
05:56:23 <c_wraith> xsperry: you're getting pages where the total transfer time isn't dominated by the connection setup time?
05:56:32 <xsperry> in fact, I'm not sure why it even has unsafe prepended
05:56:46 <dminuoso> xsperry: Because it allows for IO actions to be reordered.
05:56:47 <c_wraith> it violates referential transparency
05:56:52 <dminuoso> xsperry: `a >> b` 
05:57:04 <c_wraith> dminuoso: it's way worse than that. :)
05:57:07 <Ariakenom> dminuoso: so does forkIO
05:57:13 <xsperry> c_wraith apparently yes, because I get first results almost immediately, vs waiting for a couple of seconds
05:57:16 <dminuoso> Ariakenom: no it does not.
05:57:38 <c_wraith> dminuoso: it lets you create "values" whose structure depends on order of evaluation.
05:57:48 <c_wraith> dminuoso: that's *way* worse than just reordering IO
05:58:11 <xsperry> what are practical implications? my code seems to just work fine after plugging it in. am I just getting lucky?
05:58:25 <mniip> unsafeInterleaveIO is a quick but ugly solution that introduces technical debt into your code
05:58:27 <dminuoso> xsperry: The problem is that it's hard to see how and when effects are happening.
05:58:29 <Ariakenom> interleave means they run sometime in the future or not. I dont think forkIO has stronger guarantees, technically. 
05:58:32 <dminuoso> xsperry: It may drag effects into pure code
05:58:33 <mniip> a "clean" solution is a proper lazy io library
05:58:49 <dminuoso> xsperry: unsafeInterleaveIO ties execution into evaluation
05:59:04 <mniip> starting using one, of course, requires an initial effort
05:59:30 <c_wraith> xsperry: the biggest potential problem in your use case is that execution might barge ahead and leave thousands of network connections open
05:59:34 <Ariakenom> xsperry: one issue is to make sure that you will close the file
05:59:41 <xsperry> dminuoso, I know, but why would I care about this? I don't have to think about this when writing non-IO code. and during execution of IO code, I just catch exceptions, as usual
06:00:01 <Ariakenom> connection in this case
06:00:11 <dminuoso> xsperry: Reasoning about lazyness is not easy. Reasoning about lazy IO is even less easy. Reasoning about when lazy IO handles get cleaned up is even more less easy.
06:00:42 <dminuoso> 14:57    c_wraith | dminuoso: it lets you create "values" whose structure depends on order of evaluation.
06:00:47 <dminuoso> Can you elaborate on what you mean by that?
06:01:13 <c_wraith> dminuoso: sure, one minute
06:01:59 <Ariakenom> it should be possible to run a thread that reads the file and a string value that blocks when it reaches wherever the thread is currently at
06:02:36 <Ariakenom> which should be a reasonable way to do things
06:05:17 * hackage pronounce 1.2.0.0 - A library for interfacing with the CMU Pronouncing Dictionary  http://hackage.haskell.org/package/pronounce-1.2.0.0 (NoahGoodman)
06:06:30 <c_wraith> dminuoso: https://lpaste.net/8872084801994096640
06:06:40 <dminuoso> c_wraith: Ah yeah.
06:06:51 <dminuoso> c_wraith: Had a feeling an IORef was coming :)
06:07:22 <c_wraith> dminuoso: it's even worse with unsafeInterleaveST, where you no longer even have a warning that something fishy might be happening from the type.
06:07:33 <merijn> Anyone know which exception SIGINT throws?
06:07:43 <dminuoso> c_wraith: That essentially is reordered IO so..
06:08:50 <dmwit> merijn: I don't, but I think you can install your own signal handler and then you don't have to know.
06:09:05 <cocreature> merijn: UserInterrupt iirc
06:09:19 <c_wraith> dminuoso: but in either case, you have the problem that eventually you have a value of type ([Integer], [Integer]) (darn it, I screwed that up in the paste, and new lpaste doesn't have edit) which evaluates to different things depending on the order of evaluation
06:10:35 <dminuoso> c_wraith: Im wondering whether our arguments are actually useless, since the reordering is partially what lazy I/O *wants* to do..
06:11:07 --- mode: glguy set +v unsymbol_
06:11:08 <dminuoso> c_wraith: Consider lazily reading a file, and just reading some chunks from the middle.
06:11:14 <unsymbol_> any ops around?
06:11:48 <dminuoso> unsymbol_: You can always reach admins in #haskell-ops
06:11:55 <unsymbol_> cheers!
06:11:56 <c_wraith> dminuoso: lazy IO should only be used for morally commutative effects.  Reading from a file is allowed to commute with other actions, so long as nothing changes the file.
06:12:14 <dminuoso> c_wraith: dmwit argues that it still doesn't compose nicely
06:12:26 <c_wraith> it still has issues, yeah.
06:12:40 <pikajude> hey so I can get my vim to store swap files in a directory in ~ sorted by the complete filename
06:12:55 <pikajude> is there a way to get cabal to put the dist directory in a directory like that
06:13:18 <c_wraith> and also, in the real world, "as long as nothing changes the file" is a disturbingly unlikely in the long term.
06:13:39 <xsperry> "<c_wraith> xsperry: the biggest potential problem in your use case is that execution might barge ahead and leave thousands of network connections open" <- how would I deal with this? I am kind of impressed that it all seemingly worked by just adding that single function call, and if this can be handled then I'll leave my code like this for now
06:13:41 <dminuoso> c_wraith: even in short term..
06:14:59 <fryguybob> I'm still distrubed by the general lack of transactional file systems...
06:15:05 --- mode: glguy set +v rihards
06:15:13 <dminuoso> xsperry: Depending on how you use it, it may be near impossible.
06:15:17 <c_wraith> xsperry: you have two options to deal with that.  One is to make sure the entire http return value has been processed before you start another page.  That can be fiddly, but you *can* make it work.
06:15:32 <dminuoso> xsperry: With lazy IO its the GC that essentially closes handles.
06:15:38 <c_wraith> xsperry: the other is to switch to a streaming IO library like conduit, pipes, streaming, etc
06:16:36 <rihards> anyone know of a recent writeup comparing pipes and conduit? everything i find is a few years old and it seems that both libraries have evolved quite a bit since then (and become more similar)
06:17:33 <c_wraith> rihards: last I heard, they are generally comparable in performance and utility. It mostly comes down to which design you prefer to use.
06:17:39 <dminuoso> fryguybob: well btrfs has snapshots so..
06:17:57 <dminuoso> fryguybob: atomic writable subvolumes.. it gets you half way there
06:19:32 <maerwald> rihards: I've heard a talk about streaming libs and the argument was both suck
06:20:00 <maerwald> maybe I can find the slides
06:20:28 <rihards> and another thing - is there something similar to Zip{Source,Conduit,Sink} in pipes? what i want to do is fork a source, do some processing on it in parallel, and then merge the results. so far i've found that conduit seems to support this but with pipes i would have to use pipes-concurency (i think)
06:21:04 <rihards> maerwald: thanks, that would be great
06:23:54 <cocreature> rihards: yeah afaik pipes-concurrency is the way to go here
06:24:12 <maerwald> the argument was for streamly or streaming, I currently don't remember which one
06:25:34 <dminuoso> fryguybob: or there is ZFS...
06:26:18 <maerwald> rihards: https://ivan-m.github.io/FPSyd-Streaming/#/
06:28:26 <mniip> the 's' hotkey in hackage is super neat
06:28:35 <rihards> maerwald: i've tried streaming. i ended up concluding that i can't express what i want in it. there seems to be no way of doing processing in parallel on the same *source* stream and then merging the results. same goes for streamly, afaik. but thanks for the link, i'm still very interested seeing what others have to say about these libraries
06:28:39 <mniip> but you know what would be insanely amazing? type lookup in *that*
06:28:45 <mniip> but I guess we can't have everything
06:30:05 <__monty__> rihards: Why does needing pipes-concurrency mean that pipes doesn't support it? I think it's just a different packaging approach, one is monolithic, the other is more write your own adventure.
06:30:37 <merijn> __monty__: It does something very different, tbh
06:31:06 <__monty__> mniip: Wow, thanks. Had no idea.
06:32:17 <exarkun> Is there a Maybe a -> Maybe b -> Maybe (a, b) in base somewhere?
06:32:28 <phadej> :t liftA2 (,)
06:32:29 <lambdabot> Applicative f => f a -> f b -> f (a, b)
06:32:30 <sshine> liftM2 (,)
06:32:38 <sshine> ok, liftA2.
06:33:15 <sshine> > (,) <$> Just 5 <*> Just 6
06:33:17 <lambdabot>  Just (5,6)
06:33:17 <rihards> what happens in streaming when i try to do something like `Monad m => Stream (Of a) m r -> Stream (Of (a,a)) m r :: zipSelf s = S.zipWith (,) s s` is that the resulting stream repeats the monadic action. i end up making two reads to a websocket where i wan only one, for example
06:33:37 <exarkun> sshine: thanks
06:33:49 <sshine> > liftA2 (,) (Just 5) (Just 6)
06:33:52 <lambdabot>  Just (5,6)
06:33:53 <maerwald> anyone knows why stack keeps wrongly complaining about a manually modified project .cabal file when you use hpack directly instead of the built-in crap?
06:33:58 <sshine> depending on the situation you might like either.
06:35:10 <exarkun> `(,) <$> Just 5 <*> Just 6` looks great because I lied in my question I really wanted Maybe (a + b).  So `(+) <$> ...` seem like the thing.
06:35:39 <xsperry> > liftA2 (+) (Just 5) (Just 6)
06:35:40 <lambdabot>  Just 11
06:36:59 <rihards> __monty__: yeah, it's not really a problem i guess. the main concern is just that the conduit aproach seems to be a bit more elegant, imho
06:38:04 <fryguybob> dminuoso: There are bits and pieces around, but as far as I know the NTFS version (TxF) is the most complete.  What I'm really complaining about is that this isn't the default, cross-platform, interface from programming langugaes broadly with the sort of thing we have now as an escape for possiblly more performance, but you are crazy to do it.
06:39:23 <rihards> __monthy__: not in regards to packaging, but in regards to having a ZipConduit (and the like) while in pipes-concurency you explicitly define communication channels that fork the source
06:40:40 <rihards> __monty__: oh, sorry, misspelled your name :)
06:49:31 <__monty__> I guess it depends on whether you like the kitchensink approach or not?
06:51:36 <ph88> can somebody review my PR and help with last bug ?  https://github.com/snoyberg/packdeps/pull/45 
07:01:25 <dminuoso> fryguybob: I think the people who truly enjoy transactional things are few in numbers sadly and know how to program are few. Quite a bunch of them are STM users, and there's not much of that.
07:01:57 <fryguybob> Well and all database people :D
07:02:18 <dminuoso> fryguybob: Like I said. "and know how to program"
07:02:19 <ab9rf> there aren't really that many Truly Serious database people
07:02:21 <fryguybob> Us TM people just took their good ideas.
07:02:43 <ab9rf> there's lots of people who (ab)use databases, but not nearly as many who actually understand them
07:03:01 <ab9rf> i've been a DBA since 1986 :)
07:03:17 <dmwit> Ah, so you're in the "abuse but don't understand" camp, then? ;-)
07:03:28 <ab9rf> dmwit: absolutely
07:03:44 <dmwit> FWIW I'm in the "in-memory is probably good enough for now" camp.
07:03:47 <ab9rf> dmwit: to be fair, i started to actually understand them about a decade ago
07:04:00 <ab9rf> dmwit: only took me twenty years or so
07:04:02 <dmwit> "what could possibly go wrong"
07:04:05 <fryguybob> dmwit: The non-volitale memory camp?
07:04:12 <dminuoso> dmwit: Absolutely. I hear EC2 can scale up to 4TiB of ram.
07:04:19 <fryguybob> *volatile
07:04:54 <dminuoso> Oh, apparently even more. 16TiB might be the current limit?
07:05:03 <cocreature> now ab9rf is in the “yells at young people to get off their lawn” camp :)
07:05:33 <ab9rf> hey
07:05:51 <dmwit> I wonder if any young person ever yelled at themselves to get off their lawn.
07:06:08 <ab9rf> probably, young people do all sorts of incomprehensible things
07:06:40 <dminuoso> MonadIncomprehensions
07:06:41 <cocreature> I prefer to yell at old people to get off my non-existent lawn
07:06:59 <ab9rf> i have yet to yell at anyone to get off my lawn
07:07:06 <ab9rf> although i have come close
07:07:07 <dminuoso> I prefer to put people under my lawn.
07:07:07 <dmwit> "get off my apartment's doormat"
07:07:13 <ab9rf> i do, however, have a lawn
07:07:17 <ab9rf> complete with TREES
07:07:22 <mniip> that grow?
07:07:26 <ab9rf> YES!
07:07:28 <ab9rf> it's AMAZING
07:07:28 <dolio> Athas: I actually handed off maintenance to someone else. But I'll check in with them about getting an 8.6 compatible release soon.
07:07:42 <dmwit> Can I outsource my yelling? If not, who would like to invest in a new service-economy startup?
07:08:00 <ab9rf> dmwit: well, you can always call the police
07:08:07 <ab9rf> they will sometimes yell at people for you
07:08:18 <mniip> ab9rf, double edged sword
07:08:20 <dmwit> (I'm going to need you to sign an NDA before I tell you my startup's idea, though.)
07:08:23 <ab9rf> but they might yell at you instead, so it's a bit of a crapshoot
07:08:41 <fryguybob> If I had transactional file systems people wouldn't be able to get on my lawn in the first place ;D
07:08:47 <ab9rf> haha
07:09:27 <dminuoso> fryguybob: because young folks are afraid of commitment?
07:09:34 <mniip> I used filesystems as a database at least once
07:11:08 <mnoonan> is there any editor support for automatically making corrections based on GHC's error messages?
07:11:41 <mnoonan> I'd guess >80% of the time I just want to apply the suggestion GHC gave me for language pragmas, import lists, whatever
07:12:10 <mniip> but if it tells you "enable TypeFamilies or GADTs" - which do you enable
07:12:30 <mnoonan> it doesn't have to work for everything!
07:13:18 <ab9rf> mniip: fork the universe, enable one in one fork, the other in the other, and wait to see if the states collapse?
07:14:00 <dmwit> mnoonan: No, but I do have editor macros for vim that insert language pragmas without changing your cursor location or last jump location.
07:14:24 <mnoonan> I worked for a while on a tool that used genetic algorithms to evolve C code. one of the best improvements we got was when we added "compilation fixers" that made specific edits based on the error messages coming back from the compiler.
07:14:45 <mniip> ab9rf, that requires equality on universes
07:14:51 <ab9rf> mniip: so?
07:15:43 <mniip> an equality on (wave)functions is impossible without breaking referential transparency (uncertainty principle)
07:16:07 <Taneb> Yes, that is the main issue with that suggestion
07:16:13 <ab9rf> hee
07:19:35 <Ariakenom> Just use instance Monad Uncertainty
07:24:10 --- mode: glguy set +v ghallak
07:25:21 <ghallak> Is it possible to generate haddock docs for a single module? this module is importing other modules, and I just want to see how the docs I wrote for a single module will look like, without generating docs for the other imported modules
07:31:12 <madnight> mniip: may i ask a physics question?
07:31:31 <mniip> ##physics would be better
07:31:36 <mniip> physics is just a hobby for me :P
07:32:24 <madnight> okay it's double hashtag? strange
07:32:49 <bash0r> Compared to the Haskell IRC the Scala IRC is pretty damn dead. :<
07:32:58 <bash0r> Does anybody know where the cool Scala kids meet?
07:33:58 <madnight> bash0r: https://www.scala-lang.org/community/ (they seem to be on gitter)
07:35:36 <Taneb> madnight: freenode uses double-hash for "unofficial" channels and single-hash for "official" channels, but the lines get pretty blurry
07:36:10 <madnight> Taneb: ah good to know, always wondered
07:37:40 <mniip> Taneb, there's a very strict line
07:38:58 <mniip> # is for on-topic (FOSS and/or other broadly licensed output) projects and/or groups with the said project actually controlling the channel
07:40:50 <mniip> #haskell is controlled by the haskell.org folk, but, e.g. ##C is not controlled by the ISO folk hence the discrepancy in the name
07:43:05 <hololeap> has anyone seen something like this function before, and can it be re-written in more general terms, or possibly using functions in Control.Monad.Free? http://dpaste.com/1J06N5V
07:44:18 <ab9rf> there are some exceptions: #dwarffortress, for example
07:44:28 <ab9rf> channel is not official and DF is closed-source :)
07:45:11 <mniip> not an exception rather deviation :)
07:45:24 <ab9rf> well, dwarf fortress fans are pretty deviant
07:46:24 <dstolfa> mniip: in my experience, the line isn't as strict as that. it's only strict if you get reported
07:46:32 <dstolfa> nobody does anything otherwise
07:46:51 <maerwald> why is stack so annoying
07:46:56 <dstolfa> but naming a channel #C will likely get you reported if you're not ISO
07:47:12 <ab9rf> sure, nails that nobody cares about never get nailed down
07:47:12 <mniip> sure
07:49:16 <NinjaTrappeur> Hey, I just stumbled a problem. Basically, I defined <$$> = fmap . fmap without the associated signature and GHC did not correctly infered the type. I quickly fixed the problem: I remembered somebody talking about that here last week. I know this problem has a name but can't remember it nor find this discussion in my irc logs... (I need the name to read the associated wiki page :D)
07:49:27 <ab9rf> i used to be a chanop for #wikipedia
07:49:35 <ab9rf> i've had my complete and total lifetime fill of IRC politics :)
07:50:27 <Ariakenom> NinjaTrappeur: monomorphizaiton?
07:51:07 <mniip> I used to operate a cryptocurrency channel
07:51:21 <merijn> mniip: Masochist
07:51:36 <ab9rf> mniip: ok, that beats #wikipedia, but only by a bit
07:51:58 <ab9rf> wikipedians are all insane, but most of them are not criminal
07:52:01 <ski> NinjaTrappeur : DMR, the Dreaded Monomorphism Restriction
07:52:17 <maerwald> mniip: not better than an OS channel
07:52:30 <ab9rf> i confess to spending time in ##windows 
07:52:37 <NinjaTrappeur> ski, yes, exactly! Thank you!
07:52:55 <ab9rf> i had to quit because the "experts" in ##windows tend to be utter morons
07:53:00 <ski> @where DMR
07:53:00 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
07:53:15 <ab9rf> at least in here, the people who claim to know what they're talking about generally actually do
07:54:53 <raduom> I have some pattern deifinitions that start with 'pattern ..'. what extension does that?
07:55:08 <merijn> raduom: PatternSynonyms
07:56:36 <raduom> thanks
07:58:58 <bash0r> madnight: THX
08:06:17 * hackage weeder 1.0.7 - Detect dead code  http://hackage.haskell.org/package/weeder-1.0.7 (NeilMitchell)
08:23:09 <rschmukler> Is there any way to introduce a type variable for the purpose of a superclass constraint that isn't used in the typeclass itself?
08:23:37 <glguy> Probably only with a functional dependency
08:23:37 <rschmukler> ie. `class (Monad m, Monoid (t m)) => MyTrans t where`
08:23:40 <mniip> rschmukler, in a universal way or in an existential way?
08:23:58 <mniip> Monoid?
08:24:12 <glguy> rschmukler: No, you'd need to know what m was to use the class. There's a proposal for "quantified constraints" you might search for, but it's not in GHC
08:24:23 <mniip> it is in GHC HEAD
08:24:34 <rschmukler> As I understood, quantified constraints was only on instance declarations not class definitions?
08:24:47 <rschmukler> (But my understanding is surface level, at best)
08:24:50 <mniip> they can be used everywhere a Constraint can be used
08:24:56 <rschmukler> That's fantastic
08:25:00 <mniip> superclass, context, instance
08:25:13 <mniip> even 'Dict' if you enable ImpredicativePolymorphism!
08:25:15 <ski> perhaps they really want `class (forall m. Monad m => Monoid (t m)) => MyTrans t where ...'
08:25:37 <mniip> ski, I thought so but I was confused about the Monoid
08:26:14 <ski> presumably `t :: (* -> *) -> *', so `MyTrans :: ((* -> *) -> *) -> Constraint'
08:26:18 <rschmukler> mniip: the class in the superclass constraint doesn't really matter, I was just demoing a higher-kinded constraitn
08:26:54 <rschmukler> (ie. I reached for Monoid for this example arbitrarily)
08:26:55 <mniip> that's an interesting "trans"
08:27:37 <rschmukler> mniip: Streamly (http://github.com/composewell/streamly) actually has a transformer that is that
08:27:49 <rschmukler> (allowing streams to be mappended)
08:28:15 <mniip> if you want 'class (exists a. C a b) => D b'  then use an MPTC/fundep or an assoc tyfam
08:28:28 <mniip> if you want 'clsas (forall a. C a b) => D b' that's quantified constraints
08:28:56 <hololeap> i've got an error complaining about a failed coverage condition, and i'm wondering if there's any way to write this instance for MonadFree or if it's just impossible: http://dpaste.com/3F6B0YM
08:28:58 <rschmukler> It's quantified constraints then, it seems
08:29:18 <zzz> beginner question: what's the reasoning behind (- 1) 2 returning an error?
08:29:43 <glguy> zzz: You're applying the negation of 1 as a function to 2
08:30:00 <glguy> (- 1) is another way of writing (negate 1)
08:30:13 <zzz> so it's a syntatic conflict?
08:30:23 <mniip> if you want (\x -> x - 1) then (subtract 1)
08:30:37 <dmwit> zzz: Yep.
08:30:58 <rschmukler> zzz: you can also do `((-) 1)) 2`
08:31:00 <zzz> ah ok. ((-) 1) 2 solves it
08:31:01 <eacameron> Is there a way to have :t show you kind signatures as well?
08:31:04 <zzz> right
08:31:14 <dmwit> rschmukler: But that's backwards...
08:31:21 <rschmukler> sorry
08:31:40 <dmwit> > ( ((-) 1) 2, (\x -> x-1) 2)
08:31:42 <lambdabot>  (-1,1)
08:31:48 <rschmukler> `((`-` 1) 2)`
08:31:57 <glittershark> > (- 1) 2
08:31:59 <lambdabot>  error:
08:31:59 <lambdabot>      • Could not deduce (Num t0)
08:31:59 <lambdabot>        from the context: (Num (t -> t1), Num t)
08:32:02 <dmwit> > (subtract 1) 2
08:32:04 <lambdabot>  1
08:32:16 <dmwit> ?src subtract
08:32:17 <lambdabot> subtract x y = y - x
08:32:24 * glittershark shakes fist at unary operators
08:32:32 <dmwit> It exists exactly because of this issue.
08:33:10 <cheater> hi
08:33:37 <glittershark> I'd like to do that too eacameron ... can't seem to figure out if it's doable
08:34:01 <cheater> i would like to quickly open a file and check what is at its 35th byte. then if that fits continue with 36, etc, until 48. I am on linux and would like to use some sort of efficient linux sys call for that. can someone suggest a technique for doing this?
08:34:11 <dminuoso> eacameron: well there is `:i`
08:34:21 <cheater> i'm fine with this being in IO
08:34:49 <hololeap> this is part of the error i'm getting, what does it mean? lhs type ‘FailTree’ does not determine rhs type ‘FailTreeF a’
08:34:50 <eacameron> dminuoso: That doesn't show me kinds either :/
08:35:03 <cheater> the file is at most 200 bytes.
08:35:12 <glittershark> eacameron: :set -fprint-explicit-kinds
08:35:13 <mniip> cheater, efficient linux sys call?
08:35:14 <cheater> but there are thousands of files to check.
08:35:20 <mniip> you need a seek, and a block read
08:35:30 <cheater> mniip: what's a block read?
08:35:39 <cheater> let me look it up
08:36:09 <mniip> % :t hGetBuf
08:36:09 <yahb> mniip: Handle -> Ptr a -> Int -> IO Int
08:36:15 <mniip> or perhaps more comfortably
08:36:19 <mniip> % :t BS.hGet
08:36:20 <yahb> mniip: Handle -> Int -> IO BS.ByteString
08:37:38 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
08:37:38 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
08:37:40 <cheater> what about doing fopen and then fseek?
08:37:45 <cheater> how would i call those from haskell?
08:38:33 <glittershark> % :t System.IO.hSeek
08:38:33 <yahb> glittershark: Handle -> SeekMode -> Integer -> IO ()
08:38:45 <cheater> hmm http://hackage.haskell.org/package/bindings-common-1.3.4/docs/Bindings-C-Stdio.html
08:38:54 <glittershark> cheater: http://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html
08:39:26 <eacameron> glittershark: Does that work? It doesn't seem to change anything for me
08:39:52 <glittershark> hmm
08:39:56 <glittershark> doesn't seem to for me either :P
08:40:00 <glittershark> well it's in ghci's docs
08:41:49 <hololeap> i feel like if i could impose the condition that (b ~ a) for `FailTreeF b a`, i could make it work, but i don't know how to do that
08:42:54 <hololeap> (my question got buried, so i'm going to re-paste my link: http://dpaste.com/3F6B0YM)
08:43:42 <cheater> thanks guys
08:44:14 <geekosaur> cheater, you don't want to use C stdio, it's not set up. you want to read the full range into a buffer and iterate over that
08:44:17 <cheater> mniip: i tried finding out what a "block read" is, but no luck. could you point me to a good resource?
08:44:28 <geekosaur> individual character reass are going to be expensive no matter what
08:44:30 <cheater> geekosaur: no, i don't. i want to read a single byte.
08:44:37 <geekosaur> it means you read a block at a time instead of a byte at a tiome
08:44:41 <cheater> right
08:44:44 <cheater> that's what i want
08:44:45 <geekosaur> then you cannot optimize at all
08:44:47 <cheater> how do i do this?
08:44:47 <mniip> cheater, are you familiar with how read(2)/write(2) work
08:44:54 <geekosaur> there is no "faster way"
08:44:56 <cheater> mniip: somewhat
08:45:03 <cheater> geekosaur: you're confusing me right now 
08:45:06 <mniip> they are block io interface
08:45:06 <cheater> :)
08:45:17 <geekosaur> yoiu ewant to simultaneously read exactly one byte at a time, and minimuze system call overhead
08:45:22 <geekosaur> read is a system call
08:45:38 <geekosaur> you can't optmize this except by reading the entire block
08:46:08 <mniip> reading 1 byte is going to be about exactly as fast as reading four thousand
08:46:09 <cheater> when you say block, do you mean block on the hard disk?
08:46:12 <geekosaur> I would like ot know why you think reading a byte at a time is somehow more correct
08:46:16 <mniip> no
08:46:23 <mniip> an arbitrarily sized buffer
08:46:25 <cheater> geekosaur: i don't think it is
08:46:42 <geekosaur> then why do you insist on it? [23 15:44:08] <cheater> geekosaur: no, i don't. i want to read a single byte.
08:46:45 <cheater> i just don't want to read bytes 0-34
08:46:55 <geekosaur> you will anyway, on sme level
08:47:09 <geekosaur> you can seek past them, but they're still being "read"
08:47:19 <geekosaur> disks are not byte addressible
08:47:23 <cheater> mniip: so what you mean is i should read in one buffer-worth of data at a time
08:47:28 <mniip> yes
08:47:30 <cheater> geekosaur: ok
08:47:52 <mniip> key word being "on some level"
08:47:58 <cheater> *shrug*
08:48:05 <cheater> no idea what that means :)
08:48:20 <geekosaur> and it's far faster to read the entire chunk and start at offset 35 than to do a seek syscall and then read
08:48:22 <mniip> the bytes won't read your program (the kernel abstracts the exactl block details from you) but that gives you a rough estimate on how long things take
08:48:23 <cheater> ok, so i guess i'll just read the whole file into memory
08:48:36 <geekosaur> becuase that's 1 syscall instead of 2
08:48:37 <cheater> makes sense
08:48:42 <mniip> geekosaur, I had not considered that but that's probably true
08:48:51 <cheater> yeah
08:48:54 <cheater> i'll do that
08:48:55 <mniip> cheater, first 48 bytes
08:48:56 <cheater> the files are small
08:49:00 <mniip> no need to read the whole
08:49:11 <cheater> the files are 200 bytes total
08:49:19 <mniip> you have to query the size then
08:49:25 <cheater> i know the size
08:49:29 <cheater> it's fixed for all of them
08:50:17 <geekosaur> (the kernel may actually read the whole file but that's not your problem. and it's usually got some reason to do so, including disk hardware for which that's actually faster than reading smaller regions, which is again for the kernel to know/care about, not you)
08:50:52 <cheater> mmm yeah
08:54:13 <hololeap> so, for the functional dependency, `(m :: * -> *) -> (f :: * -> *)`, and given that f is `SomeStruct b a` which has b applied, is there a way to tell the type-checker that (b ~ a) for the instance you are defining?
08:55:06 <cheater> that's some good ideas, thanks mniip and geekosaur 
08:55:30 <cheater> i wonder if ripgrep also uses fopen and does stuff the way you describe
08:55:33 <cheater> at least for small files
08:55:44 <exarkun> Anyone familiar with https://github.com/phadej/github and have any clue why its `createIssue` is failing with a 404 response?
08:55:57 <geekosaur> one other comment I'll add is that it's often not worth trying to micro-optimize reads like that because you can find yourself fighting not only the disk firmware but also the kernel trying to compensate for the disk firmware
08:56:10 <geekosaur> (many moder disks' firmware optimize for large databases, not small files)
08:56:35 <exarkun> Oh phadej is in this channel (hello).
08:58:52 <dminuoso> exarkun: Do the other endpoints work fine?
08:58:52 <cheater> geekosaur: ,makes sense
08:59:52 <dminuoso> cheater: I think ripgrep mmap's dfiles =)
09:00:17 --- mode: glguy set +v albeit
09:00:26 <albeit> Is there a lens way to do something like "Map.lookup key m >>= _fooMaybeA >>= _fooMaybeB" if lenses are derived for foo?
09:00:30 <exarkun> dminuoso: Reading an issue seems to work
09:01:42 <glguy> preview (ix key . fooMaybeA . folded . fooMaybeB . folded) m
09:02:05 <dminuoso> exarkun: Curious, are you sure the owner/repo is named correctly?
09:02:44 <albeit> glguy: Ah interesting, haven't seen folded, thanks!
09:03:27 <exarkun> dminuoso: as sure as I can be, I guess.  just tried copy/pasted them  from github webpage, same results.
09:03:41 <exarkun> Ah I have an idea.
09:04:01 <exarkun> Maybe the 404 means "some field of the issue you are trying to create is not known"
09:04:08 <exarkun> Like the milestone or something
09:05:07 <philippD> Is there a way to expand typealiases in ghci?
09:06:03 <dolio> philippD: :kind!
09:06:04 <philippD> :t show
09:06:05 <lambdabot> Show a => a -> String
09:06:13 <philippD> :kind! show
09:06:23 <dolio> This isn't ghci.
09:06:23 <philippD> % :kind! show
09:06:23 <yahb> philippD: ; <interactive>:1:1: error:; Not in scope: type variable `show'; Perhaps you meant type constructor or class `Show' (imported from Prelude)
09:06:50 <philippD> % :kind! String
09:06:50 <yahb> philippD: String :: *; = String
09:07:15 <philippD> I want something that exapnds String to [Char] for example
09:08:28 <dolio> That says it prints the normalized type, so aliases are considered normalized.
09:14:19 <philippD> Ok so there is :info that expands individual type aliases but it seems that you can't apply them there
09:15:59 <geekosaur> there's no way to fully expand them without switching on typechecker details, I think
09:16:40 <geekosaur> the typechecker guts try to preserve (not always successfully) what they're fed as input so the user doesn't get whacked with types they didn't explicitly specify unless it needs to show that detail for some reason
09:16:55 <geekosaur> so it would require hooking into the guts of the typechecker to change that
09:17:03 <cocreature> % :set -fprint-expanded-synonyms
09:17:04 <yahb> cocreature: 
09:17:06 <cocreature> :t show
09:17:08 <lambdabot> Show a => a -> String
09:17:18 <cocreature> huh
09:17:36 <philippD> you have to use %
09:17:47 <cocreature> % :t show
09:17:47 <yahb> cocreature: Show a => a -> String
09:17:53 <philippD> huh
09:18:04 <glguy> The expanded synonyms only show up in error messages iirc
09:18:10 <cocreature> ah I see
09:18:17 <glguy> % show :: ()
09:18:17 <yahb> glguy: ; <interactive>:122:1: error:; * Couldn't match expected type `()' with actual type `() -> String'; * Probable cause: `show' is applied to too few arguments; In the expression: show :: (); In an equation for `it': it = show :: ()
09:18:24 <glguy> or not :)
09:18:45 <glguy> I remember trying to figure out what that flag did at one point and it did have *some* effect!
09:18:51 <philippD> does yahb separate sessions?
09:19:02 <glguy> no
09:21:13 <glguy> https://gist.github.com/glguy/98f3bf0af8d9b51e996adbabc7cf9f36 it prints the expanded ones afterward
09:30:47 <zzz> guys i just found an acceptable solution the negation/subtraction syntax problem while avoiding `subtract`
09:31:31 <zzz> map (1+) [1,2,3] /// map (-1+) [1,2,3]
09:32:13 <zzz> thought i might share. as a begginer, this caveat in an otherwise almost perfect language was giving me a headache
09:34:32 <phadej> exarkun: only samples in https://github.com/phadej/github/blob/master/samples/github-samples.cabal are compiled during CI
09:34:58 <phadej> others are most likely outdated, iirc there was even an issue about that
09:35:14 <cocreature> zzz: tbh I find "map (\x -> x - 1) [1,2,3]" significantly more readable
09:36:02 <mniip> map (\x -> ...) ...  annoys the hell out of me
09:36:33 <cocreature> why?
09:37:09 <benzrf> zzz: lol
09:38:12 <ski>   /me . o O ( `(`map` [1,2,3]) $ \x -> ..x..' )
09:38:52 <philippD> pointfree or bust
09:39:19 <benzrf> i like forM
09:39:24 <benzrf> :t forM
09:39:25 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
09:39:36 <benzrf> it's just flip mapM :>
09:39:36 <ski> using `Identity', then ?
09:39:41 <mnoonan> not as sweet as `for`!
09:39:43 <mnoonan> :t for
09:39:44 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
09:39:47 <benzrf> oh i didnt mean for this purpose, just in general
09:39:53 <benzrf> mnoonan: ooh, i didnt realize that was defined
09:40:03 <mnoonan> iirc it is relatively newish
09:40:14 * cocreature makes grumpy comment about Haskellers focusing more on how to save a few characters than focusing on actually interesting problems
09:40:19 <benzrf> in Data.Traversable, i see
09:40:43 <mnoonan> cocreature: what, naming is one of the big 3 CS problems
09:40:54 <ski> making code aesthetically pleasing is more important than shaving off a few characters
09:42:17 * hackage composition-prelude 1.5.1.0 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.5.1.0 (vmchale)
09:42:37 <exarkun> phadej: is the milestone creation endpoint wrapped?  I don't see it in the API docs.
09:44:06 <mniip> cocreature, I guess, somehow, function composition is less mental work for me than adding a new identifier to local scope
09:44:20 <phadej> exarkun: https://github.com/commercialhaskell/stackage/blob/master/become-a-curator.md
09:45:14 <philippD> I'm trying to wrap my head around lens right now, but I can't figure out where the `Monoid (HList '[[Char]])` comes from. https://gist.github.com/chisui/43ea9826f5d5ee5bf07ae2bb3c310c1f
09:46:10 <cocreature> philippD: if you use "view" (or in your case the "use" variant of "view") for a Traversal instead of a Lens the elements are combined using the Monoid instance
09:46:17 <exarkun> phadej: "We are no longer accepting applications" :)  I see the note in the github api docs now about missing milestone endpoints.
09:53:12 <phadej> ah, soery wrong link
09:53:26 <phadej> http://hackage.haskell.org/package/github-0.19/docs/GitHub.html#g:16
09:54:19 <philippD> I actually fucked up in my example. How can I combine these two lenses together to use as an argument to (.=)? https://gist.github.com/chisui/43ea9826f5d5ee5bf07ae2bb3c310c1f
09:56:16 <cocreature> philippD: which (.=) are you referring to? presumably not the one from lens?
09:56:21 <cocreature> also what exactly do you mean by “combine”?
09:56:23 <philippD> yeah
09:57:40 <cocreature> “yeah” is not a useful answer to those questions :)
09:58:16 <philippD> I typed that when there was only one message from you. I'm currently typing my response to the second :p
09:58:39 <c_wraith> philippD, do they need to be used simultaneously? the point of the state operators in lens is to provide a clean method of applying multiple transforms sequentially.
09:58:57 <cocreature> the first message contained two questions :)
10:00:25 <philippD> so `sAt` looks into a heterogeneous map from the type of ref to `HList l` which is a heterogeneous list where the list of elements is derived from the type of ref. `hAt @t` is a lens into a single field HList. I now want to change a single entry in HList for a given ref
10:00:30 <cocreature> something like "sAt ref . _Just . hAt @String" should typecheck
10:00:45 <philippD> yes I am using lens
10:00:55 <philippD> _Just ok
10:01:37 <philippD> thanks cocreature, _Just did the trick
10:03:47 * hackage postgrest 0.5.0.0 - REST API for any Postgres database  http://hackage.haskell.org/package/postgrest-0.5.0.0 (steve_chavez)
10:05:29 <cocreature> philippD: not that this gives you a Traversal not a Lens, so if you try use it with "view"/"use"/… you’ll be back to needing a Monoid constraint
10:06:13 <glguy> That also doesn't update anything if there's no entry under "ref"
10:06:36 <philippD> glguy: that's ok
10:07:36 <zzz> can someone explain a newbie why -- foldl (-) 10 [1,2,3,4] == 12 
10:08:13 <glguy> > foldl (-) 10 [1..4] :: Expr
10:08:15 <lambdabot>  10 - 1 - 2 - 3 - 4
10:09:06 <glguy> > foldl (-) 10 [1..4]
10:09:09 <lambdabot>  0
10:09:31 <cocreature> that doesn’t look like 12 :)
10:09:41 <zzz> ah ok. right associative
10:09:48 <cocreature> no it’s left associative
10:09:58 <cocreature> (((10 - 1) - 2) - 3) - 4
10:11:05 <cocreature> but the associativity of (-) also doesn’t matter here. foldl will always apply the operator in this way even if it is declared as right associative
10:11:15 <cocreature> the associativity matters if you write 10 - 1 - 2 - 3 - 4 in your source file
10:11:30 <zzz> > 10 - 1 - 2 - 3 - 4
10:11:32 <lambdabot>  0
10:12:08 <zzz> why is ghci giving me 12?
10:12:39 <cocreature> have you declared (-) yourself?
10:13:38 <dmwit> % infixr 9 -
10:13:38 <yahb> dmwit: ; <interactive>:123:10: error:; The fixity signature for `-' lacks an accompanying binding; (The fixity signature must be given where `-' is declared)
10:13:39 <zzz> dammit. thanks cocreature
10:14:06 <zzz> i was messing with it a couple of hours ago and i forgot
10:18:34 <mniip> % :i -
10:18:34 <yahb> mniip: class Num a where; ...; (-) :: a -> a -> a; ...; -- Defined in `GHC.Num'; infixl 6 -
10:18:47 * hackage opentok 0.0.1 - An OpenTok SDK for Haskell  http://hackage.haskell.org/package/opentok-0.0.1 (adrice727)
10:18:47 <mniip> that's an l and it only goes to 6 dmwit
10:21:07 <droplet_> > foldr (+) 0 [1..4] :: Expr
10:21:09 <lambdabot>  1 + (2 + (3 + (4 + 0)))
10:21:18 <droplet_> where's the Expr type from?
10:21:34 <cocreature> droplet_: from the simple-reflect package
10:22:00 <droplet_> awesome thanks
10:27:04 <dmwit> mniip: This one goes all the way to 11.
10:27:35 <dmwit> I understand that you're pointing out that the standard make (-) infixl.
10:27:54 <dmwit> I wanted to see what would happen if I declared it to be infixr.
10:28:15 <dmwit> ...but not badly enough to try a second time with another name. =)
10:28:34 <dmwit> s/see what would happen/show what would happen/
10:29:17 --- mode: ChanServ set +o dmwit
10:34:54 <philippD> Is there a way to provide a default value to a Lens to a Maybe? Something like `Lens' a (Maybe b) -> b -> Lens' a b`? hoogle can't find anything like that.
10:35:52 <dmwit> :t non
10:35:53 <lambdabot> (Functor f, Profunctor p, Eq a) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
10:36:01 <dmwit> But beware that this is not law-abiding.
10:36:22 <dmwit> Usually it behaves the way you want anyway, but you should ask yourself afresh each time you use it.
10:36:59 <dmwit> (Namely, for `non x`, the value `Just x` roundtrips to `Nothing`, not `Just x`.)
10:37:08 <exarkun> took the milestone out, still get a 404 on issue create :(
10:48:06 <philippD> How long does it take to become productive with lens like that?
10:48:29 <philippD> (I know it's a subjective question I'm just very frustrated right now)
10:48:37 <dolio> 1 hour.
10:49:15 <exarkun> The 404 was caused by the token not having sufficient privileges. :(
10:49:42 <dolio> Shouldn't that be some other number?
10:49:45 <MarcelineVQ> philippD: a decent primer https://www.youtube.com/watch?v=QZy4Yml3LTY
10:50:07 <dminuoso> exarkun: wow for real?
10:50:10 <dolio> Like 403?
10:50:12 <dminuoso> exarkun: file a bug report in my opinion.
10:50:18 <exarkun> for real :(
10:50:34 <exarkun> dminuoso: github does not have a public bug tracker because github does not care about the opinion of the vast majority of its users
10:50:56 <exarkun> I have heard a rumor that there is a secret bug tracker that they invite their friends to but I dunno
10:51:14 <dminuoso> exarkun: You can send issues to support@github.com
10:51:51 <dminuoso> Oh wait.
10:51:53 <dminuoso> exarkun: https://developer.github.com/v3/troubleshooting/
10:51:56 <dminuoso> exarkun: Its documented.. heh
10:53:20 <dmwit> dolio: 403 would leak a bit about whether the repo exists, and you might argue that non-privileged users shouldn't always have access to that bit
10:53:23 <exarkun> It's kind of a valid point except I'm when the repository is public...
10:53:48 <dmwit> philippD: I liked artyom's "Lenses over Tea" series. Doesn't cover the enormity of the library, but does a great job of explaining the core ideas.
10:54:14 <dmwit> exarkun: Ah, yeah, in that case no bits leaked. =)
11:04:17 * hackage proto-lens-protoc 0.3.1.1 - Protocol buffer compiler for the proto-lens library.  http://hackage.haskell.org/package/proto-lens-protoc-0.3.1.1 (JudahJacobson)
11:05:17 * hackage proto-lens-arbitrary 0.1.2.2 - Arbitrary instances for proto-lens.  http://hackage.haskell.org/package/proto-lens-arbitrary-0.1.2.2 (JudahJacobson)
11:06:17 * hackage opentok 0.0.2 - An OpenTok SDK for Haskell  http://hackage.haskell.org/package/opentok-0.0.2 (adrice727)
11:08:17 * hackage proto-lens-combinators 0.1.0.11 - Utilities functions to proto-lens.  http://hackage.haskell.org/package/proto-lens-combinators-0.1.0.11 (JudahJacobson)
11:09:47 * hackage proto-lens-protobuf-types 0.3.0.2, proto-lens-optparse 0.1.1.2 (JudahJacobson): https://qbin.io/weapon-opens-79si
11:45:47 * hackage hadolint 1.11.2 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.11.2 (lorenzo)
12:06:55 <philippD> Is there a way to suppress hlint warnings on the next line?
12:08:40 <dmwit> https://github.com/ndmitchell/hlint#customizing-the-hints
12:14:38 <philippD> I used compare to define (==) to keep myself from repeating. Hlint doesn't like that so I added {-# ANN (==) "HLint: ignore Redundant compare" #-}. But That causes an error saying that == isn't in scope? What?
12:19:27 <philippD> And if I use a module annotation I get some strange ambiguous type errors for the string part of the annotation
12:20:20 <philippD> Duh, RTFM
12:21:16 <dminuoso> philippD: It's quite hilarious to use ANN pragma with OverloadedStrings, isnt it?
12:22:31 <zachk> whats ANN?
12:22:37 <mniip> -- @String this is a string comment
12:23:31 <mniip> zachk, an "annotation" pragma available to some static analysis tools such as hlint
12:24:19 <philippD> I didn't even know that they could even be something else then a String.
12:24:33 <dminuoso> philippD: If you read the GHC manual on the topic, it's quite enlightening.
12:24:41 <dminuoso> philippD: It's *so much more* than just about String. P)
12:24:43 <dminuoso> :)
12:25:55 <philippD> dminuoso: I'm currently reading it. But it's not intuitive at all.
12:27:18 <dminuoso> philippD: You can tag any type, binding or module with some expression (as long as that expression has a type with Data+Typeable instances)
12:27:59 <AWizzArd> Using TypeLits I wanted to reimplement the Nat type-level `+`: type family Plus (n :: Nat) (m :: Nat) :: Nat
12:28:13 <AWizzArd> type instance Plus 0 m = m    is well accepted
12:28:26 <AWizzArd> But GHC doesn’t like    type instance Plus (1+n) m = m
12:28:36 <philippD> dminuoso: That's actually pretty scary.
12:28:49 <AWizzArd> It’s nonsensical but it showcases how it doesn’t work.
12:29:17 <AWizzArd> Illegal type synonym family application in instance: 1 + n In the type instance declaration for `Plus'
12:29:47 <dminuoso> philippD: Perhaps it might be helpful to imagine hlint might accept annotatinos like: {-# ANN yourThing [Ignore ExtraParens, Error EtaReduce]] #-}
12:30:28 <the_2nd> I want to group a list of [a] to [[a]] where each sublist contains of elements which are considered equal by some function
12:30:37 <the_2nd> is there something already defined for that?
12:30:40 <dminuoso> philippD: where there exists some `data Action = Ignore Rule | Error Rule` and some `data Rule = ExtraParens | EtaReduce | ...`
12:30:53 <dminuoso> philippD: So suddenly hlint can go through bindings and inspect tags.
12:31:16 <dminuoso> or rather *inspect annotations
12:31:26 <philippD> dminuoso: I get that. But that would mean that I would have to depend on some HLint package to create these annotations
12:31:39 <mniip> wow!
12:31:48 <mniip> % :i id
12:31:48 <yahb> mniip: id :: a -> a -- Defined in `GHC.Base'
12:31:57 <mniip> take a closer look at that --
12:32:07 <mniip> % System.Process.readProcess "../usr/lib/ghc-8.6.0.20180620/bin/ghc" ["-B../usr/lib/ghc-8.6.0.20180620", "-e", ":i id"] ""
12:32:07 <yahb> mniip: "id :: a -> a \t-- Defined in `GHC.Base'\n"
12:32:13 <the_2nd> groupBy :)
12:32:22 <mniip> \t
12:32:38 <mniip> I knew I was in the right this whole time
12:32:48 <dminuoso> mniip: regarding what?
12:33:02 <mniip> using hard tabs
12:34:24 <cocreature> the_2nd: not quite, groupBy will only group successive elements. if you want all elements that are considered equal in a single sublist you have to use something else
12:35:04 <cocreature> for (==) you can just sort the list first
12:36:11 --- mode: glguy set +v dataN
12:36:39 --- mode: glguy set -v dataN
12:36:53 <philippD> AWizzArd: (+) from GHC.TypeLits is a type family. So you can't use that at that position afaik
12:37:08 <dataN> is this style discouraged, and if so, for what reason? https://gist.github.com/dataN-hs/be26ea252019495452bbbc0aa1bb2fee
12:37:20 <AWizzArd> Yes, the + itself already is a TF, true.
12:38:17 <AWizzArd> Just thought that it could be legal to do this.
12:38:32 <the_2nd> cocreature, thanks, would have missed that
12:38:44 <philippD> AWizzArd: You would have to match the constructor of Nat there but I can't find the actual definition. I suspect that it's internal to GHC itself. Maybe to increase performance
12:39:17 <dminuoso> mniip: Everyone knows tabs are better than spaces anyway.
12:39:32 <dminuoso> mniip: They lead to more efficient code.
12:39:33 <dmwit> the_2nd: If the elements are not consecutive, consider `M.fromListWith (++) [(convertToCanonicalForm v, [v]) | v <- vs]`.
12:39:57 <mniip> dminuoso, my whitespace character is longer than yours
12:40:36 <AWizzArd> philippD: in the end it’s okay because I just wanted to reinvent TypeLits’ (+).
12:40:53 <geekosaur> tab size wars?
12:41:07 <philippD> AWizzArd: you may have to reinvent Nat itself too.
12:41:13 <dminuoso> geekosaur: In my hands I hold the ultimate proof that settles the debate "tabs vs spaces" once and for all.
12:41:24 <AWizzArd> philippD: yes that would work.
12:41:24 <dminuoso> But such a weapon is dangerous to wield, so I will not use it.
12:41:40 <philippD> `data Nat = Plus a | Zero`
12:41:48 <dmwit> dataN: Yes, it is discouraged, because `instance Applicative f => Functor f` overlaps with all other possible instances, meaning you cannot make an instance of `Functor` for anything which is not also an `Applicative`.
12:41:55 <philippD> Then you don't need a Plus typefamily at all
12:41:56 <AWizzArd> philippD: when I have my own Nat then I can do    type instance Plus (S n) m = S (Plus n m)
12:42:08 <dminuoso> philippD: huh?
12:42:23 <dataN> dmwit: can this be fixed?
12:42:24 <dmwit> dataN: You may say: "But it doesn't overlap with things that aren't `Applicative`s, because then the `Applicative f` in the instance doesn't hold!". But instance selection doesn't work like that, sorry.
12:42:29 <philippD> ARGH, no you still have to define it
12:42:32 <AWizzArd> The idea was to have type-level addition.
12:42:39 <philippD> you're right AWizzArd
12:42:43 <dmwit> dataN: At a cost, yes. It is not a cost that GHC devs are likely to be interested in incurring any time in the near future.
12:42:51 <AWizzArd> Okay good, so no type families inside type families.
12:43:14 <dmwit> dataN: But this doesn't buy you anything anyway.
12:43:56 <glguy> DerivingVia is an upcoming solution to problems including having to mechanically specify defaults for instances like this in terms of other classes
12:44:21 <dmwit> dataN: The solution that should have been adopted was `class Applicative f where apply :: f (a -> b) -> f a -> f b; default apply :: Monad f => f (a -> b) -> f a -> f b; apply = ap` using the DefaultSignatures extension.
12:44:26 <dmwit> I honestly don't know why this was not done.
12:44:38 <dataN> dmwit: it can be used in trying to make a kind of function returning instances of "trivial" superclasses from "sufficient" superclasses
12:44:59 <dmwit> Yes, I understand the goal. DefaultSignatures is the existing solution to this goal. See above for an example of how that looks.
12:45:24 <philippD> AWizzArd: you can even call your type family (+) if you enable TypeOperators. You might also consider making the family closed
12:45:39 <dmwit> I didn't mean "it doesn't buy you anything" in an absolute sense, just "it doesn't buy you anything compared to DefaultSignatures". Apologies for not being clear about that.
12:47:17 * hackage opentok 0.0.3 - An OpenTok SDK for Haskell  http://hackage.haskell.org/package/opentok-0.0.3 (adrice727)
12:47:43 <AWizzArd> philippD: did this but first thought the use of an operator (:+) was my problem, so I tried naming the family `Plus`, which didn’t solve it.
12:48:01 <philippD> you can drop the :
12:48:02 <dataN> for instance, providing instances for 'class Get f where get :: f a -> (a,f a); class Set f where set :: (a,f a) -> f a' results in instances for Traversable and MonadPlus. 
12:48:24 <dmwit> (similarly for `default fmap :: Monad m => (a -> b) -> m a -> m b; fmap f x = x >>= return . f`)
12:48:34 <AWizzArd> philippD: I could if I hadn’t imported TypeLits.+
12:48:59 <philippD> ... which you can't use if you reinvent Nat :-P
12:49:48 <mniip> operators beginning with : are constructor names
12:50:00 <mniip> can only be used as type or data constructor names
12:50:20 <mniip> not functions, type families, or classes
12:50:50 <mniip> actually that one might be wrong
12:51:08 <dataN> oh, that needs also, class Empty f where empty :: f a... though something similar is possible without; it gives Traversable, Monad but there is no 'empty' for Alternative
12:51:09 <philippD> mniip: you can use them for type families and classes
12:51:13 <mniip> yup
12:51:25 <AWizzArd> philippD: yes. With my own Nat I was successful already. Then wanted to reimplement it in terms of the already existing functionality.
12:52:12 <dataN> but the Monad instance was via Foldable and (<|>) so actually, whats the name for Alternative without empty?
12:52:38 <mniip> yeah, I remember now, : acts like an uppercase punctuation
12:52:39 <dmwit> dataN: I'm sort of skeptical that Get/Set/Empty is enough. How do you know when to stop `get`ing?
12:53:09 <cocreature> dataN: https://hackage.haskell.org/package/semigroupoids-5.3.1/docs/Data-Functor-Alt.html#t:Alt
12:53:35 <philippD> Why is there no Alternative instance for Last?
12:54:47 <dataN> right, also there is need for Maybe in the Get/Set.... 'get :: f a -> (a,Maybe (f a))' and 'set :: (a,Maybe (f a)) -> f a'
12:55:22 <dataN> motivating class Create f where create :: a -> f a
12:56:37 <AWizzArd> In a 2010 papen SPJ talked about the idea of strongly typing   sprintf "Num: %d"  :: Int -> String   – how close are we to that? Can this only be done with a complete implementation of Dependend Types?
12:56:44 <dataN> cocreature: thanks. then Get + Set = Monad & Alt & Traversable, and Get + Set + Empty = MonadPlus & Traversable
12:57:52 <dataN> then synonyms can be introduced to name these, type Linear f = (Get f,Set f), Stack f = (Linear f,Empty f)
12:58:13 <mniip> AWizzArd, I think his interface was 'sprintf (text "Num: " <> int) :: Int -> String'
12:58:24 <mniip> that we can do at the moment
12:58:28 <dataN> and whats needed is the mechanism to then give the trivial superclasses
12:59:17 <mniip> I think I can even see a way to do it without type families
12:59:18 <philippD> AWizzArd: you could define the pattern through a quasiquoter
12:59:37 <AWizzArd> mniip: yes, he used such an interface, right. That works today.
13:00:35 <mniip> "%d" is quite different from  int mind
13:00:48 <fr33domlover> mniip, there's the package 'formatting' that works that way (it uses Text though, not String, iirc)
13:00:57 <mniip> the  text "Num :"  and  int  carry type information with it that [Char] does not
13:01:31 <dataN> note that for Stack, its more appropriate to use variants of get and set with respective types of; 'f a -> Maybe (a,f a)' and 'set :: Maybe (a,f a) -> f a'
13:03:28 <mniip> dataN, you realize that a free getset is a List or a NonEmpty depending on which definition you stick with?
13:03:49 <dataN> so, one option is to just put all the trivial superclasses alongside the defining superclasses in the type synonyms for Linear and Stack 
13:03:50 <mniip> % :t fromList
13:03:50 <yahb> mniip: IsList l => [Item l] -> l
13:03:54 <mniip> % :t toList
13:03:54 <yahb> mniip: ; <interactive>:1:1: error:; Ambiguous occurrence `toList'; It could refer to either `Data.Foldable.toList', imported from `Data.Foldable'; or `GHC.Exts.toList', imported from `GHC.Exts'
13:04:00 <mniip> % :t F.toList
13:04:00 <yahb> mniip: Foldable t => t a -> [a]
13:04:18 <mniip> well, maybe if IsList were (* -> *) -> Constraint
13:05:14 <AWizzArd> Here I see a type-safe printf in Idris. Fun.  https://www.youtube.com/watch?v=fVBck2Zngjo
13:05:51 <dolio> I don't see why printf is an important example.
13:06:16 <buhman> do `pure` and `return` do different things for monad instances?
13:07:05 <glguy> buhman: No, it's a law of the Monad class that they must be the same
13:08:07 <dataN> mniip: there is a default for Linear (which can be used always instead of Stack to get the desired superclasses, as Empty is not required for the Monad = Foldable + Alt.) from a class defined by a functions of types 'f a -> (a,i,Maybe (f a))' and 'i -> ((a,Maybe (f a)) -> f a)'. the situation you describe corresponds to i = ().
13:08:09 <c_wraith> dolio, it's more of a convenient example. "everyone" knows what it does already, and statically typing it seems to involve a pi type and type functions.
13:09:08 <dataN> and as such is a restricted case
13:09:43 <mniip> dataN, I don't quite see the difference between that and [(a, i)]
13:10:17 <dataN> sure, its equivalent using unfold via safe state. 
13:10:42 <mniip> so a class of functors isomorphic to Compose ((,) i) []
13:10:43 <dataN> thats what allows it to be used as the difference list portion of a zipper
13:11:00 <mniip> Compose [] ((,) i)
13:14:14 <dataN> though, generally, the type 'Applicative g => (a -> g b) -> f a -> (([g (Maybe (f b) -> f b)],Maybe (f a)) -> Maybe ([g (Maybe (f b) -> f b)],Maybe (f a)))' should be used with an input funtion 'pure :: a -> Identity a' to allow the zipper to be reversable and properly represent a supended traversal... otherwise its just a default for Traversable
13:18:17 <Boarders> if I have a test suite and want to pass a command line arg to only one part of it is that possible
13:18:19 <dataN> anyway, its simpler to consider, 'MonadPlus = (Monad + Alt) + Empty' as an example of the syntax being sought
13:18:58 <Boarders> in partiuclar I am trying to use tasty-golden and want to know how I ask it for new golden files to be generated (you are supposed to pass the command line arg --accept but that doesn't play well with the rest of the tests)
13:19:04 <dataN> well thats not the syntax! probably something more like the gist but with synonyms... https://gist.github.com/dataN-hs/be26ea252019495452bbbc0aa1bb2fee
13:21:42 <cocreature> Boarders: what do you mean by “doesn’t play well with the rest of the tests”?
13:22:15 <royal_screwup21> beginner question, but: what's the difference between sayMe :: (Integral a) => a -> String   vs  sayMe :: Integral  -> String
13:22:33 <Boarders> I mean if I do like "stack build --test --ta "--accept"" then the rest of the test suites say they do not recognise that as an arg
13:22:38 <Boarders> not sure if I am doing something stupid
13:22:50 <cocreature> Boarders: do you have multiple test suites?
13:22:54 <Boarders> yeah
13:23:12 <cocreature> ah so it’s the other test suites that are complaining, not a different part of the same test suite
13:23:24 <pavonia> royal_screwup21: Integral is not a type, so you can't use it where a type is required
13:25:07 <cocreature> Boarders: try passing the name of the test suite that you care about, then it should only run that and thereby also only apply the args to that
13:25:44 <Boarders> cocreature: thanks, though thinking about it that test suite will run non-golden tests so probably will complain
13:26:40 <cocreature> Boarders: I don’t think it will complain, as long as it’s a standard tasty test suite, it should be happy
13:26:52 <Boarders> ah ok, I'll give it a try. Thanks!
13:30:10 <dataN> mniip: no. if 'i' does not give rise to a set function then the list is order independant, if 'i' is "structure directing" i.e. for a given "shaped" container 'f' there exists 'i -> ((a,Maybe (f a))->f a)', then the order of the difference list you gave needs to be preserved or the shape is altered. 
13:31:10 <mniip> you said i -> ((a,Maybe (f a)) -> f a)
13:36:33 <Boarders> cocreature: do you know how you build a particular part of a project with stack?
13:37:38 <cocreature> Boarders: just passing the name should work?
13:38:02 <MarcelineVQ> Boarders: check the stack docs for target syntax
13:38:43 <cocreature> packagename:test:testsuitename should be the one that you need here
13:39:03 <dataN> mniip: right, but its not as simple as just giving every element some index like zip [1..]
13:40:03 <dataN> and they are Traversable Alt Monads, not just Functors.
13:40:25 <dataN> so how was defualt supposed to help?
13:40:45 <dataN> also, DerivingVia does not seem to help
13:43:00 <glguy> Doesn't help with what?
13:43:19 <dataN> it seems to be similar to https://ghc.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances and https://ghc.haskell.org/trac/ghc/wiki/IntrinsicSuperclasses
13:44:35 <dataN> glguy: the problem was that e.g. 'instance Applicative f => Functor f' prevented Functors that were not Applicative 
13:44:52 <glguy> Yeah, it helps so you can derive a Functor isntance from the Applicative one
13:46:24 <dataN> thats very similar to just writing the Functor instance using liftA
13:46:45 <glguy> except that it scales to multiple methods
13:47:09 <glguy> so you can use it to derive Functor and Applicative from your Monad instance
13:48:42 <dataN> the idea is to do with something like type Syn f = (Trivial f,Resulting f); type Trivial f = (A f,B f ... ), type Resulting = ( ... )
13:49:33 <dataN> for example Foldable + Alt = Monad
13:49:57 <glguy> yeah, you could build a newtype that did that to be used with DerivingVia
13:49:57 <Boarders> MarcelineVQ, cocreature: sorry for the stupidity but I really don't get how to use the target syntax
13:50:16 <glguy> you certainly wouldn't want the Foldable + Alt instance to be getting used without explicitly asking for it
13:50:44 <dukedave> Is there a name for this pattern: `newtype Foo a = Foo { getFoo :: t }` ?
13:50:48 <dataN> right, thats why the gist provided the option of overriding the defaults
13:51:22 <selfsymmetric-pa> dukedave: That is a newtype parameterized by a phantom type.
13:51:34 <cocreature> Boarders: you’ll have to be a bit more specific, which part do you not get? you just need to replace packagename and testsuitename with the name of your package and the name of your test suite
13:51:34 <selfsymmetric-pa> I don't know of a terser name for the pattern.
13:51:41 <glguy> dukedave: That looks like a mistake, where did 't' come from?
13:52:25 <selfsymmetric-pa> Oh right, whoops. >_<
13:52:27 <dataN> the overlapping instance still remains to then use those defaults to give the default implementations. 
13:52:51 <dataN> oh so maybe these can be replaced using default in the superclasses...
13:53:19 <Boarders> cocreature: in my cabal file the project is called blah say and I have Test-Suite integration-test
13:53:25 <dukedave> glguy: I was just making it up :)
13:53:37 <dukedave> It should have been `a`
13:53:46 <Boarders> if I do stack build blah:test:integration-test I get "Error parsing targets: Component CTest "integration-test" does not exist in package blah"
13:53:58 <cocreature> Boarders: try passing --test
13:54:08 <dukedave> I happened upon it here, although I've seen that pattern many times before: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors#contravariant-functors
13:54:11 <dataN> DeafultSignatures*
13:54:32 <Boarders> cocreature: same deal
13:54:59 <dukedave> selfsymmetric-pa: okay, thanks
13:55:10 <cocreature> Boarders: what happens if you try blah:integration-test?
13:55:29 <cocreature> Boarders: also can you show us the cabal file and the exact command you’re using? 
13:56:22 <Boarders> cocreature: the cabal file is here: https://github.com/amnh/PCG/blob/integration-tests/phylocomgraph.cabal
13:56:45 <Boarders> probably I am doing something incrediblty stupid
13:56:48 <Boarders> *
13:57:13 <cocreature> "stack ide targets" should list the targets
13:57:49 <Boarders> ahh I was not making it plural ahhh
13:57:51 <Boarders> fml
13:58:06 <Boarders> thanks for the indulgence cocreature, I appreciate it
13:58:11 <cocreature> np :)
14:00:19 --- mode: glguy set +v Ste1891
14:01:15 <Ste1891> Voice...?
14:01:26 <glguy> read your messages?
14:02:00 <Ste1891> OK, cheers.
14:02:19 <Ste1891> Hi there. I was rebuilding some libraries recently with cabal so I could then build my own application with GHC profiling enabled. On one build I noticed GHC was forking a process called "realgcc". I know what GCC is, but does anyone know what realgcc is and how it's more real?
14:04:27 <mniip> Ste1891, seems to be something reload to a ghc-specific mingw environment
14:05:13 <geekosaur> on windows, ghc has some shortcomings. the ghc install provides a full gcc so it can build C-related things including FFI stubs, but also ships a wrapper that compensates for e.g. argument length limits, which runs the real gcc which was renamed to that
14:05:15 <geekosaur> iirc
14:05:17 <mniip> ah yes, ghc on windows comes with a mingw-gcc compiler
14:05:35 <geekosaur> (I think it forces some things into a response file and alters the parameters so the response file is used)
14:07:32 <mniip> geekosaur, seems like the wrapper gcc.exe is mostly concerned about libdir, and is injecting -B arguments
14:08:04 <geekosaur> hm, possible. gcc can be relocated after a fashion, but a different way
14:08:13 <geekosaur> so maybe it's forcing ghc's relocation style on gcc
14:09:29 <mniip> man ghci.ico looks so 1995
14:10:09 <mniip> glad I don't use windows :P
14:11:25 <Ste1891> OK. I thought some one would know. Well, profiling did work after doing the ground work and it's pretty useful. I find it odd that only a small minority of the modules I import into my app needed rebuilding for this though. I would have thought it would be all or none.
14:12:47 * hackage http2-grpc-types 0.1.0.0 - Types for gRPC over HTTP2 common for client and servers.  http://hackage.haskell.org/package/http2-grpc-types-0.1.0.0 (LucasDiCioccio)
14:13:01 <mniip> Ste1891, if you're wondering, this is gcc.exe https://github.com/ghc/ghc/blob/master/driver/gcc/gcc.c
14:13:10 <mniip> and realgcc.exe is the /real/ one
14:13:50 <ab9rf> unrealgcc
14:14:43 <mniip> naturalgcc
14:15:25 <geekosaur> this makes me think the discussion I saw was about modifying an existing wrapper instead of creating a new one, as I'd though
14:15:43 <geekosaur> (vaguely recall it being gcc not handling too many linker arguments after it adds all its own)
14:16:06 <geekosaur> sometimes windows feels like you're spending mroe time working around it than developing...
14:16:23 <mniip> who'd need to specify more than 9 arguments to a program
14:16:44 <geekosaur> then again, I get the same impression from recent mac os
14:17:45 <ab9rf> geekosaur: it's really just that windows is based on VMS, not on UNIX
14:18:02 <geekosaur> this aspect is based on ms-dos
14:18:30 <geekosaur> and the vms thing is rather overblown, but seems thave become a meme again
14:18:32 <ab9rf> the idea of passing a gazillion arguments to the linker is absurd in either
14:18:54 <ab9rf> geekosaur: i've written system softare in VMS, there is more commonality than you might expect
14:19:16 <ab9rf> i have actually killed VMS machines by causing page faults while on the interrupt stack :)
14:20:28 <ab9rf> nothing quite like hearing the LA-120 Decwriter III that is serving as your system console rattlign off a core dump after you cause a machine check
14:21:11 <dataN> why does NoImplicitPrelude prevent defining ap using pure, complaining about there being no Reader Monad, and then why does it not allow defining pure = const when trying to define this instance?
14:21:35 <mniip> dataN, what's "const"
14:22:05 <dataN> const a _ = a
14:22:13 <mniip> that's in Prelude though
14:22:21 <dataN> just defined locally
14:22:31 <mniip> paste your code and error message
14:24:37 <mniip> ab9rf, you get cores at least. I didn't now what the shit was going on when my intel i7 was repeatedly MCE'ing
14:24:59 <dataN> oh, the Reader is used for liftA... https://lpaste.net/2673234893965623296
14:25:49 <Ste1891> Well, if you mean command line arguments the 9 limit is incorrect at least on Windows 10. My own app can receive 16.
14:26:14 <ab9rf> microsoft made the command bugger larger in a recent version
14:26:24 <ab9rf> not sure if it was w8, w10, or one of the w10 updates
14:26:44 <ab9rf> lots of peopel still using w7 though
14:26:48 <mniip> Ste1891, I came up with the number 9 randomly on the spot
14:26:50 <ab9rf> too many to not support
14:27:06 <mniip> being able to go %1 to %9 in a .bat file seemed like an appropriate place to put aa limit
14:27:07 <ab9rf> it's actually a byte or character (forget which) limit, not a count
14:27:16 <mniip> if you're doing msft thinking
14:27:23 <ab9rf> i think it used to be 1024, 
14:27:26 <dataN> sorry that was the wrong error... 
14:27:28 <ab9rf> but it's 4096 now i think
14:27:29 <dataN> mniip: https://lpaste.net/8218078273427472384
14:28:07 <mniip> dataN, pure :: f a ?
14:28:10 <geekosaur> it was never number if arguments. it's total length
14:28:19 <geekosaur> if you use a different api then it's larger but still limited
14:28:20 <dataN> !!!
14:28:48 <geekosaur> windows passes the whole thing as a single string, there is no "number of parameters"
14:29:09 <geekosaur> (and then the CRT splits it in the program)
14:29:12 <dataN> thanks
14:29:19 <dataN> dmwit: like this? https://lpaste.net/1058162989774929920
14:29:52 <hololeap> hi everyone. i asked about this a couple times earlier today and didn't get a response. i made a SO question about it, and i'm going to post it here in hopes someone can answer it, or at the very least help me refine my question: https://stackoverflow.com/q/51994396/983883
14:29:57 <ab9rf> it does not help that there are multiple APIs to launch processes, as well
14:30:04 <ab9rf> which have different limitations
14:31:58 <dataN> anyway, this is just no good at all. it should be done in the subclass, not the superclass. that was the whole point of making the example in the gist. otherwise there is no way to replace the type synonym with a "newclass" and do the defaults there. and the only other option is the overlapping instances which are not ok as discussed earlier. stuck at this point.
14:32:57 <mniip> hololeap, FailTree a k = Maybe (a, [k]), no?
14:34:15 <hololeap> well, Fix (FailTreeF a) ~ FailTree a
14:34:28 <mniip> yeah, that's not the case with yours
14:34:32 <ph88> can somebody review help with a small bug ?  https://github.com/snoyberg/packdeps/pull/45
14:36:05 <hololeap> if you look at the implementation of `wrap`, it's easy to see that it should work. i just can't figure out how to make the type-checker happy
14:39:55 <dataN> so currently, the only way to write e.g. Foldable + Alt = Monad + Alt is to rewrite the monad class!? this results in NoImplicitPrelude and huge classes full of all the various conceivable defaults, and is totally unmaintainable given that new defaults could arise. 
14:39:56 <mniip> hololeap, no?
14:40:24 <mniip> consider this
14:41:07 <mniip> @let data FailTree a = PassTree a [FailTree a] | FailTree
14:41:08 <lambdabot>  Defined.
14:41:27 <mniip> :t let pass (x, ts) = PassTree x ts in maybe FailTree pass
14:41:28 <lambdabot> Maybe (a, [FailTree a]) -> FailTree a
14:42:14 <mniip> ah I think I see where the problem is
14:42:32 <mniip> indeed this does not unify
14:42:37 <mniip> because your monad is not free
14:45:40 <hololeap> @let newtype FailTreeF b a = FailTreeF { getFailTreeF :: Maybe (b, [a]) } deriving (Functor)
14:45:41 <lambdabot>  Defined.
14:45:50 <dataN> hmm, maybe there is some way to use tags, they seemed to help safely use TypeApplications and AllowAmbigousTypes to allow OverlappingInstances to be used safely. any ideas how this might be done? the only example I have is; https://gist.github.com/dataN-hs/e0a154cd485d34d8a1c0c35dc49bebd2...
14:46:36 <hololeap> :t Fix (FailTreeF (Just (4, [Fix (FailTree Nothing)])))
14:46:37 <lambdabot> error:
14:46:37 <lambdabot>     • Data constructor not in scope: Fix :: FailTreeF Integer a0 -> t
14:46:37 <lambdabot>     • Perhaps you meant one of these:
14:47:00 <hololeap> oh... it's because i'm getting Fix and Free mixed up maybe
14:48:00 <hololeap> yeah, that was a derp on my part
14:48:46 <hololeap> i should be using recursion-schemes instead of free
14:50:20 <hololeap> mniip: when you said my monad isn't free, what exactly does that mean and how could you tell?
14:51:12 <mniip> hololeap, you can't write an instance
14:51:30 <mniip> how could you tell -> sudden realization of the big picture of the MonadFree class
14:51:59 <hololeap> hm, ok
14:52:58 <mniip> hololeap, a 'MonadFree f m' kind of requires M to have a _unary_ constructor  f (M a) -> M a
14:53:40 <hololeap> mniip: thanks, that is a helpful rule to remember until i can grok it
14:55:13 <mniip> well, need not necessarily be unary, but it cannot reference a
14:55:33 <mniip> 'Int -> F (M a) -> M a' is ok because you can tuck the Int into the F anyway
14:55:45 <mniip> 'M a -> F (M a) -> M a' likewise
14:55:51 <mniip> but not 'a -> F (M a) -> M a'
14:57:57 <hololeap> ok. i noticed that was the problem; that i needed to reference the `a` in `M a`, but i wasn't sure if that precluded me writing an instance
14:59:44 <hololeap> but, now that i think about it more, `Fix (FailTreeF a) ~ FailTree a`... i was confusing Fix and Free in my mind
15:03:17 * hackage opentok 0.0.4 - An OpenTok SDK for Haskell  http://hackage.haskell.org/package/opentok-0.0.4 (adrice727)
15:03:21 <lavalike> for a free monad, is there a way to not to have to type out all of the cases for a second interpreter, instead, just fall back to a first one in one declaration? (maybe this question is too general and fixing the types of the interpreters makes a difference)
15:04:44 <lyxia> interpreter2 = \x -> case x of Foo -> ... ; _ -> interpreter1 x      ?
15:05:47 <dmwit> dataN: Yes, like that, and notice that you don't need to write `fmap = (.)` and it will still work.
15:05:53 --- mode: dmwit set -o dmwit
15:06:02 <dataN> thanks
15:06:46 <dataN> still not sure how to use the Overlapping approach safely though 
15:07:44 <lavalike> lyxia: hmm
15:07:57 <dataN> that was; https://gist.github.com/dataN-hs/be26ea252019495452bbbc0aa1bb2fee
15:09:32 <lavalike> lyxia: runIO :: E a -> IO a; runL :: E a -> IO String are my types, so the second clause doesn't typecheck in the case
15:10:26 <dataN> how could TypeApplications avoid the fact that this enable superclasses that dont instantiate their subclasses to exist alongside a subclass that implements its superclass with an overlapping instance?
15:10:41 <dataN> ^ with the words in the right order
15:12:42 <lavalike> lyxia: I'm starting to think it's by fault for hiding that 'a' in the other interpreter
15:13:50 <mniip> dataN, how are typeapplications related to anything
15:15:19 <dataN_> where the fact is that such overlapping instances (of superclasses using thier subclasses) cannot exist alongside 'superclasses that dont instantiate their subclasses' 
15:17:56 <techieAgnostic> should i be using network.sockts or system.io for irc stuff?
15:17:58 <mniip> hololeap, aww, should've answered the question for that sweet internet karma
15:18:21 <mniip> techieAgnostic, anything with 8-bit clean passthrough to ByteString should work
15:19:00 <mniip> also I don't see any networking functions in System.IO
15:19:22 <techieAgnostic> im just reading through this
15:19:24 <techieAgnostic> https://wiki.haskell.org/Implement_a_chat_server
15:20:32 <mniip> ah
15:20:50 <mniip> that's referring to the fact that Network.Socket is using String for data which is stupid indeed
15:21:06 <techieAgnostic> oh right
15:21:14 <mniip> you'd still be using Network.Socket, but you'd be turning the network handles into Handles as in System.IO.Handle
15:21:34 <mniip> as the documentation currently states, there's Network.Socket.ByteString
15:21:42 <techieAgnostic> oh that makes sense
15:21:42 <mniip> with ByteString-typed functions
15:24:22 <glguy> techieAgnostic: If you keep working on IRC stuff some of us chat in #haskell-irc
15:25:30 <glguy> techieAgnostic: For connecting to IRC I use http://hackage.haskell.org/package/hookup-0.2.2/docs/Hookup.html , which abstracts away connecting to servers through SOCKS and TLS or not
15:26:16 <techieAgnostic> oh sweet
15:29:27 <mniip> last time I did an IRC client my connection type was more complicated and extensible
15:29:32 <mniip> and man that was in java
15:30:30 --- mode: glguy set +v Darwin226
15:30:31 <Darwin226> mapInsertOrDef a b c m = m & at a . non mempty . at b ?~ c
15:30:54 <Darwin226> it works, but it results in an unneeded Eq constraint on the inserted value
15:31:07 <glguy> Darwin226: use: non' _Empty
15:31:25 <glguy> or: anon Map.empty Map.null
15:33:54 <Darwin226> It works, but I don't get it
15:34:23 <glguy> Feel free to ask questions
15:34:46 <Darwin226> I'm processing :D
15:37:42 <Darwin226> Ok, so a "APrism' a ()" is effectively a nullary constructor/pattern
15:38:06 <glguy> yeah
15:38:11 <Darwin226> I can make it into an Iso by producing Nothing if the value is that nullary constructor, otherwise Just that value
15:38:44 <Darwin226> and the reason this approach doesn't need Eq is the same as the reason why (null []) doesn't need eq but ([] == []) does
15:40:28 <Darwin226> Yeah, I guess I understand. "non" is general and works for more than just patterns, but it requires Eq
15:41:55 <Darwin226> Thanks glguy 
15:42:33 <techieAgnostic> i'll ask at some point, im at work so i gotta find some free time
16:05:56 <dataN_> hmm, the "Exists" approach to writing classes does not seem to work without "impredictive polymorphism" https://lpaste.net/4594403241826975744
16:06:19 <dataN_> what up with that?
16:07:11 <dataN_> types cant use forall ?
16:09:33 <dataN_> otherwise the above would be a way to approach the Applicative Functor DerivingVia discussion... but Functor does not mention all of the parameters used in its defining function.
16:10:34 <zzz> is there any syntatic sugar for "if any one of the arguments is A" on function definitions?
16:10:35 <mniip> dataN_, you're asking to apply a constraint constructor (Tag) to a quantified type (forall a b. (a -> b) -> f a -> f b)
16:10:47 * hackage cabal-helper 0.8.1.1 - Simple interface to some of Cabal's configuration state, mainly used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.8.1.1 (DanielG)
16:10:55 <mniip> zzz, no, that'd have an odd typing rule
16:11:06 <mniip> consider perhaps
16:11:14 <mniip> f x y z w | A `elem` [x, y, z, w]
16:11:44 <zzz> mniip: that's acceptable. thanks
16:11:45 <dataN_> mniip: that I am
16:12:02 <mniip> dataN_, you realize the type theoretical issues with that
16:12:37 <dataN_> there are some?
16:13:03 <dataN_> GHC is unhappy about it, so I guess so
16:13:42 <arahael> Can I have alphabetic letters in infix operators? Say, :D+
16:14:00 <glguy> What happened when you tried?
16:14:49 <arahael> glguy: I get a parse error?
16:15:00 <glguy> Then you can't :)
16:15:05 <dataN_> in other settings there has been some way to work around the issue...
16:15:08 <arahael> glguy: So there are no extensions, either?
16:15:18 --- mode: glguy set +v smudge
16:15:36 <smudge> Hi everybody, I would like to create a GUI for a haskell program that will run on Windows. Does anybody have any reccomendations for which library I should use? Thanks.
16:16:13 <dataN_> mniip: what are they?
16:16:34 <zachk> have you looked at gtk or wx , smudge?
16:16:49 <arahael> smudge: If this was a language I had experience in, eg, Python, F#, C++, etcetera, then I'd recommend using WPF and C#, and call into your business layer.
16:17:07 * arahael doesn't yet consider himself experienced in Haskell.
16:17:59 <smudge> zachk: I haven't looked but I will do now that you've mentioned them :)
16:18:03 <arahael> glguy: How do people typically namespace their operators?
16:18:09 <zachk> :)
16:18:16 <dataN_> mniip: any link?
16:18:37 <glguy> arahael: They don't
16:19:04 <smudge> arahael: is this a windows library that I can interface with Haskell then?
16:19:05 <glguy> arahael: You can import them qualified:  import qualified M; example = 10 M.+!+ 20
16:19:25 <arahael> glguy: That would work!
16:19:39 <arahael> smudge: I typically embed into the GUI frontend.
16:20:08 <smudge> arahael: interesting, I'll check it out, thanks!
16:23:22 <arahael> smudge: An alternative would be to wrap the haskell as a web backend, I guess.
16:23:34 <dataN_> mniip: I can find: https://ghc.haskell.org/trac/ghc/ticket/14734, is that the same issue?
16:24:48 --- mode: glguy set +v tjyoco
16:25:40 <tjyoco> +v
16:26:12 <tjyoco> Hi, all.  I'm trying to get FFI to C# working.  I made a test library, but it wont compile. '$ ghc -O2 --make -no-hs-main -optl '-shared' -o Test.so Test.hs' gives the error 'undefined reference to main'.  ANy clue what this is about?  I have the no-hs-main flag there.
16:27:01 <smudge> arahael: yes I was looking into having haskell communicate with purescript and using purescript's react bindings to create a gui but that would require me to learn so many new technologies and I have limited time
16:27:33 <arahael> smudge: If you haven't done embedding before, then I'd probably avoid that, too.  Embedding has it's own quirks.
16:28:08 <smudge> arahael: yep will probably just look for something which does the job for now (as long as it works on windows)
16:28:37 <arahael> smudge: Generally I find http to be very easy to understand.  You could even use epheremal ports so that you don't actually clobber an existing port.
16:31:01 <smudge> arahael: interesting, I wouldn't even know where to start with it though, would you recommend using a tool like react??
16:31:29 <arahael> smudge: That's yet more to learn, though my colleagues are a massive fan of it.  Do you already know and understand HTML and javascript?
16:32:09 <arahael> smudge: If you're keen on a react-based system, but want to do Haskell, then perhaps #reflex-frp might be able to help? It's not react, though. ;) 
16:32:17 * arahael warns that he hasn't even *touched* reflex-frp.
16:32:18 <smudge> arahael: I have a vague grasp of HTML and how Javascript interacts with it using the DOM yes
16:33:39 <glguy> tjyoco: Do you have a "module" declaration at the top of your Test.hs file?
16:34:47 <smudge> arahael: haha I'm not necessarily keen on react, but I can see myself becoming productive with it fairly quickly since they have good guides and tutorials and the whole thing seems well designed 
16:35:37 <tolt> smudge: I've had success with the gi-* libraries. There are some examples too. http://hackage.haskell.org/package/gi-gtk
16:35:52 --- mode: glguy set +v caams
16:35:58 <tolt> And they have instructions for windows
16:36:24 <smudge> tolt: I'll have a look into them too then, thanks :)
16:39:07 <caams> hey I'm new to Haskell, I come from reading Learn you Haskell for great good, I wish to learn this language because school
16:39:25 <jle`> welcome caams :D
16:39:49 <caams> hey thanks :D
16:40:22 <hpc> caams: you picked a great language to be required to learn ;)
16:40:23 <mniip> "because school" ?
16:40:33 <mniip> ah so a requirement
16:40:36 <mniip> yeah great choice
16:40:52 <caams> Computer Science
16:41:05 <arahael> caams: I prefer "Real World Haskell", because that author actually knows English.
16:41:27 <tjyoco> glguy: yes my file is 'Test.hs' and at the top it says 'module Test where'
16:41:35 <hpc> cis194 is good too because it's from an actual course
16:41:40 <hpc> although i suppose you have that anyway
16:41:41 <madnight> welcome caams
16:41:46 <mniip> hey jle`,
16:41:52 <smudge> plus beetles are better than elephants
16:42:03 <mniip> do you know if there could be anything interesting to stream on twitch other than advent of code
16:42:03 <jle`> hi
16:42:04 <caams> arahael: then I should check the pdf
16:42:35 <hpc> mniip: write a <foo> with no libraries
16:42:40 <jle`> edwardk and puffnfresh have been having some pretty successful channel these days
16:42:50 <hpc> mniip: pick some sufficiently interesting foo, and write the abstractions you use too
16:42:53 <dmwit> mniip: No, I'm pretty sure Advent of Code is the only thing anybody streams on Twitch.
16:43:04 <mniip> project euler comes to mind but that's kind of in the same area
16:43:07 <jle`> edwardk does some low level stuff i think
16:43:17 <dmwit> Why not write an actually useful program?
16:43:21 <arahael> caams: Seriously, use whatever you can read and understand, for me, the dodgy grammar kept throwing me off, so I couldn't use "Learn you a Haskell".
16:43:32 <arahael> caams: But it's supposed to be very good.
16:43:36 <hpc> write a web server from scratch maybe
16:43:37 <jle`> there are some hot topics on the news that i think people might like to watch...i have been thinking of making a machine learning algorithms in haskell series
16:43:39 <madnight> Real World Haskell has very valuable user comments under each paragraph, i can recommend the online version of it
16:43:41 <jle`> i think the main key is to just be consistent
16:43:44 <mniip> web is ugh
16:43:48 <MarcelineVQ> mniip: write a browser game
16:43:55 <hpc> write a gopher daemon from scratch!
16:44:00 <mniip> something educative
16:44:13 <mniip> or rather, where one can demonstrate the cool stuffs
16:44:17 <dmwit> mniip: wanna help me develop a Dr. Mario AI? =)
16:44:27 <arahael> hpc: "Write a daemon gopher, after first writing the universe!"
16:44:30 <mniip> sorry what
16:44:33 <jle`> yeah i'm currently doing a type-safe tic tac toe w/ gui thing, just not sure what the real reach of that is though haha
16:44:36 <caams> arahael: I thought it was normal weird english for me XD
16:45:01 <hpc> mniip: write a database system from scratch?
16:45:11 <hpc> just the data structures you could do a hundred episodes on
16:45:17 <dmwit> Ooo, or how about a tiling window manager that actually understands compositing properly?
16:45:27 <mniip> catch: that requires knowing stuff about databases
16:45:28 <MarcelineVQ> dmwit: can reccomend a puyo puyo ai over a dr mario
16:45:28 <ricky_clarkson> and works with Java apps
16:45:30 <dmwit> So it can, like, duplicate windows, and do the fancy overview thing.
16:45:45 <mniip> dmwit, hmm, interesting
16:45:53 <jle`> mniip: i think puffnfresh does codewars some times
16:46:02 <hpc> mniip: part of it can be learning as you go
16:46:10 <mniip> recording that would be tricky what not with probably necessary X11 restarts
16:46:21 <mniip> qemu/vbox I guess
16:46:21 <jle`> VM?
16:46:23 <dmwit> mniip: Use Xpra or similar.
16:46:30 <hpc> ooh
16:46:34 <hpc> write a halvm operating system
16:46:42 <jle`> we should start a haskell streamers group or something to share tips
16:47:09 <caams> I would watch that
16:47:22 <mniip> dmwit, I remember there was a software that let me run an X server in an XWindow of another server, is this it?
16:47:25 <hpc> mniip: or think of something you've always wanted to publish, and stream that
16:47:32 <hpc> mniip: including the parts about getting all the packaging correct
16:47:32 <dmwit> mniip: Yes, I think so.
16:47:34 <mniip> jle`, haskell-streamers mailing list
16:47:42 <hpc> lots of programmers get packaging very wrong
16:48:03 <hpc> mniip: ooh, i tried using that recently
16:48:03 <jle`> we have a "community" functional programmers, https://www.twitch.tv/communities/functional
16:48:07 <hpc> xvfb or something like that
16:48:10 <jle`> mniip: oh nice :) where is it?
16:48:10 <mniip> hpc, cabal init, fill in the gaps, cabal sdist?
16:48:29 <hpc> yeah, xvfb and xpra
16:48:40 <mniip> jle`, haha I just made that up. It just rolls nicely off the tongue
16:48:55 <hpc> i was trying to fix the dpi settings for a game, it ended up having terrible latency though :/
16:49:00 <dmwit> mniip: Or turn your 6502 evaluator into a proper SNES emulator. ;-)
16:49:16 <mniip> haven't touched that in 40 years
16:49:17 <hpc> dmwit: that's a really good one
16:49:19 <jle`> edwardk 's discord is called "haskell-twitch"
16:49:22 <hpc> the snes is weirdly complicated
16:49:28 <hpc> but in some really interesting ways
16:49:31 <jle`> not sure if he would be okay with sharing it
16:49:36 <hpc> and you have a huge test suite right in front of you
16:49:45 <MarcelineVQ> it's not complicated it's just split apart, the hard stuff is that the extra chips are in the cart :<
16:50:50 <hpc> MarcelineVQ: well, perfect snes emulation is still an open problem iirc
16:51:01 <dmwit> mniip: (In short, do something that interests you. I don't really think AoC or PE will actually keep your attention for very long.)
16:51:23 <mniip> yeah but I can solve like 10 in a stream :P
16:51:33 <hpc> the closest one requires some absurd single-threaded performance level in order to work
16:51:35 <mniip> especially those in the first 2 hundred
16:52:39 <ab9rf> mniip: i used to use xnest for that, but i think xvfb is a more modern implmenetation :)
16:52:44 <mniip> dmwit, the sad reality is I don't have a large enough attention span to work on a project for several separate days
16:52:51 <smudge> arahael: so could I just have an empty html file with a javascript file attached to it that can talk to a haskell program and populate the DOM with stuff when necesary for the gui?
16:53:44 <arahael> smudge: You could.  Personally I prefer to lean on HTML rather than javascript, but either way, if you're doing HTML, some Javascript is needed.
16:55:18 <smudge> arahael: ok, and how would the javascript communicate with the haskell program?
16:56:25 <arahael> smudge: Usually using some form of xmlhttprequest, there aren't a lot of options. (Dont' be fooled by the name: It' snot neccessarily xml)
16:57:24 <arahael> smudge: The ultimate team here, is where you have one guy exclusively focusing on the web crap, and you can focus on the backend. :)
16:58:03 <MarcelineVQ> that poor guy
16:58:23 <arahael> MarcelineVQ: Ignorance is bliss.
16:58:34 <smudge> arahael: hahaha yeah, it's just me atm although if I do use html then I'll probs pay someone else to make it pretty with CSS :)
16:59:03 <arahael> MarcelineVQ: Seriously though, the tooling webapps now have is *awesome*. CSS and "developer tools" are amazing.
17:00:08 <arahael> smudge: I suggest you have a quick chat with those people about what sort of webapp they like doing CSS for.
17:01:17 * hackage vector-algorithms 0.7.0.2 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.7.0.2 (ErikDeCastroLopo)
17:01:28 <smudge> arahael: is CSS harder for different kinds of webapps?
17:02:42 <arahael> smudge: Imagine running your code through an obfuscator.
17:03:01 <arahael> smudge: And they will be used to certain types of jobs, as well.
17:03:24 <arahael> smudge: Many css gods aren't particularly good at code, imho.
17:03:32 <arahael> But *damn*, they're good at funking about with css.
17:05:34 <smudge> arahael: haha yeah it's more of the graphic design side of web dev
17:45:50 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
17:45:50 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
17:50:58 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
17:50:58 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
18:13:32 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
18:13:32 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
18:16:10 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
18:16:10 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
18:19:51 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
18:19:51 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
18:21:01 <fragamus> EUREKA!
18:21:06 <fragamus> take 12 $ foldl (flip (<*>)) [""] $ (fmap (:)) <$> (["0","1","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"]!!) <$> (\x->(read [x])::Int) <$> reverse "2863654"
18:21:16 <fragamus> er
18:21:20 <fragamus> > take 12 $ foldl (flip (<*>)) [""] $ (fmap (:)) <$> (["0","1","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"]!!) <$> (\x->(read [x])::Int) <$> reverse "2863654"
18:21:22 <lambdabot>  ["atmdmjg","atmdmjh","atmdmji","atmdmkg","atmdmkh","atmdmki","atmdmlg","atmd...
18:21:54 <MarcelineVQ> excellent, but be sure to have 4 lines of commentary right above it about what it does
18:22:09 <fragamus> QED!
18:22:23 <fragamus> It converts phone number into words
18:22:38 <ski> @type digitToInt
18:22:39 <lambdabot> Char -> Int
18:22:50 <fragamus> yeah I know
18:22:55 <MarcelineVQ> Yes I recall you mentioning the problem before, but the commentary isn't for me it's for you :>
18:23:28 <fragamus> it's for you : P
18:23:36 <glguy> fragamus: instead of foldl and reverse you should probably just be using foldr
18:23:51 <fragamus> that's interesting
18:23:58 <fragamus> lemme see....
18:24:17 * hackage hw-ip 0.2.0.1 - Library for manipulating IP addresses and CIDR blocks  http://hackage.haskell.org/package/hw-ip-0.2.0.1 (haskellworks)
18:37:39 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
18:37:39 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
18:37:45 <jle`> * traverse f xs, at the end
18:37:52 <fragamus> ah
18:38:02 <glguy> fragamus: If you just like seeing <*>, you can do this: https://gist.github.com/glguy/e03f804248ee16419af1c896c722a47f#gistcomment-2687637
18:38:14 <jle`> it's what you are doing when you write foldl flip (<*>) [""] $ fmap (:)
18:38:22 <jle`> you basically re-implemented traverse
18:38:31 <fragamus> because im so badass
18:38:43 <fragamus> : P
18:38:50 <jle`> note that instead of foldl (flip (<*>)), you can write foldr (<*>)
18:39:04 <jle`> and the link should be clearer kinda
18:39:26 <fragamus> I dont know why i did that
18:39:28 <glguy> (while at the same time dropping the reverse)
18:39:36 <fragamus> yeah
18:39:54 <fragamus> > take 12 $ foldr (<*>) [""] $ (fmap (:)) <$> (["0","1","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"]!!) <$> (\x->(read [x])::Int) <$> "2863654"
18:39:56 <lambdabot>  ["atmdmjg","atmdmjh","atmdmji","atmdmkg","atmdmkh","atmdmki","atmdmlg","atmd...
18:41:11 <fragamus> this is why I come in this chat... its always possible to make it crisper and shorter
18:41:53 <jle`> :t \f -> foldr (liftA2 (:) . f) (pure [])       -- traverse
18:41:54 <lambdabot> (Applicative f, Foldable t) => (a1 -> f a2) -> t a1 -> f [a2]
18:42:10 <jle`> :t [traverse, \f -> foldr (liftA2 (:) . f) (pure [])]
18:42:11 <lambdabot> Applicative f => [(a1 -> f a2) -> [a1] -> f [a2]]
18:42:19 <jle`> it still is a little different than what you wrote but you can start to see the link
18:42:23 <fragamus> :t liftA2
18:42:24 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:42:54 <jle`> it's one of the nicer ways to write sequence :: [m a] -> m [a]
18:42:54 <dataN> ok, so heres TypeApplications ImpredictiveTypes AllowAmbiguousTypes and UndecidableInstances giving default superclasses; https://lpaste.net/855601568907526144
18:43:02 <jle`> :t foldr (liftA2 (:)) (pure [])
18:43:03 <lambdabot> (Applicative f, Foldable t) => t (f a) -> f [a]
18:45:22 <c_wraith> dataN, I strongly recommend against doing anything that results in the compiler asking you to turn on ImpredicativeTypes. the extension is maybe 20% working at best, and breaks lots of other things.
18:46:37 <c_wraith> dataN, you can always do what that extension intends to do in a more verbose way with a wrapper data type that hides the polymorphism inside it.
18:46:52 <fragamus> @pl (\x->(read [x])::Int)
18:46:52 <lambdabot> (:: Int) . read . return
18:47:01 <c_wraith> hahaha.
18:47:10 <glguy> :t digitToInt
18:47:12 <lambdabot> Char -> Int
18:47:23 <dataN> c_wraith: yes, the code does not work. however, it compiles, and maybe the bug is from a reason other than that language extension, but the compiler cant help find the bug.
18:47:32 <c_wraith> apparently @pl thinks :: is an infix operator.
18:47:37 <fragamus> yes but it requires the import of Data.Char
18:47:48 <glguy> fragamus: That's fine
18:49:04 <dataN> oh, actually the extension can be commented out, so its definatly not from that! it uses a wrapper to hides the polymorphic type. 
18:49:11 <glguy> > (subtract 48 . ord) <$> "0123456789"
18:49:13 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
18:49:43 <dataN> any idea why it loops though? 
18:50:17 * hackage hw-ip 0.2.0.2 - Library for manipulating IP addresses and CIDR blocks  http://hackage.haskell.org/package/hw-ip-0.2.0.2 (haskellworks)
18:50:25 <glguy> > subtract 48 . fromEnum <$> "0123456789"
18:50:26 <fragamus> @pl (\i -> ["0","1","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"] !! digitToInt i)
18:50:26 <lambdabot> (["0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"] !!) . digitToInt
18:50:27 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
18:50:40 <dataN> possibly its something to do with the Eq instance and NoImplicitPrelude conflicting...
18:50:57 <glguy> fragamus: Making that point-free isn't an improvement (making things point-free generally isn't)
18:51:41 <fragamus> yeah in my concience I know that but sometimes I just have to
18:52:05 <jle`> you monster :o
18:53:10 <dataN> its difficult to see if the code is working because all the most simple examples rely on Prelude... maybe there is another way to test it...
18:55:14 <dataN> https://lpaste.net/855601568907526144
18:55:40 <fragamus> traverse ((["0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"] !!) . digitToInt) "2863654"
18:56:10 <fragamus> i need to study traverse
18:56:24 <fragamus> :t traverse
18:56:25 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
18:57:07 <fragamus> wierd
18:57:44 <dataN> :t \(x:xs) -> (fmap (:) (pure x),xs) 
18:57:45 <lambdabot> Applicative f => [a] -> (f ([a] -> [a]), [a])
18:59:17 <dataN> :t \(ys,(x:xs)) -> ((fmap (:) (pure x)):ys,xs)
18:59:19 <lambdabot> Applicative f => ([f ([a] -> [a])], [a]) -> ([f ([a] -> [a])], [a])
18:59:42 <subttle> Is liftN really a good way to think about traverse? For example right now I'm working on a RegExp type which has a Traverse instance but no Applicative instance (at least not an obvious one anyway), it has lift0 (pointed), lift1 (fmap), but I can't seem to come up with a solid lift2 for it
18:59:52 <subttle> maybe I'm just missing something :)
18:59:58 <dataN> :t foldr (<*>) (pure []) 
18:59:59 <lambdabot> (Applicative f, Foldable t) => t (f ([a] -> [a])) -> f [a]
19:00:10 <subttle> point*
19:01:04 <fragamus> I also have to say that this little one liner is a *great* way to get women to give their phone numbers
19:02:25 <fragamus> > traverse ((["0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"] !!) . digitToInt) "2863654"
19:02:27 <lambdabot>  ["atmdmjg","atmdmjh","atmdmji","atmdmkg","atmdmkh","atmdmki","atmdmlg","atmd...
19:02:31 <glguy> That's fine that your RegExp doesn't have an Applicative instance, traverse doesn't use the Applicative instance of the type being "traversed"
19:03:05 <NemesisD> why is  it that with ApplicativeDo enabled, foo = do; bar; baz is fine but foo arg = do; bar; baz seeks a Monad instance?
19:03:35 <subttle> glguy, that makes sense, thanks
19:04:18 <philippD> Does anyone have an idea why this fails? Is what I'm trying even possible? https://gist.github.com/chisui/0a7c95d9ce294d86b1259b1318b801cf
19:04:39 <glguy> NemesisD: You've probably hidden away too many details of the actual problem to help
19:10:45 <NemesisD> glguy: oh right, you have to bind your results even if you don't want to use them for ApplicativeDo, _ <- foo compiles, foo does not
19:11:49 <NemesisD> why is that?
19:13:17 <dataN> philippD: annotate 'f' ?
19:13:44 <philippD> dataN with what?
19:13:49 <philippD> @c?
19:14:19 <nshepperd> philippD: why doesn't l appear in the type of applyT
19:14:27 <dataN>  f :: forall (a :: a1). c a => f ()
19:14:34 <dataN> @a
19:14:34 <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask auto-reply auto-reply? v @ ? .
19:15:08 <philippD> dataN: the point is that `a` shouldn't be bound at that point
19:15:33 <philippD> nshepperd: because it's a parameter to the class
19:15:44 <dataN> @e ?
19:15:44 <lambdabot> Maybe you meant: easton echo elements elite eval v @ ? .
19:16:18 <philippD> I think I got it working by turning f into `(forall a. c a => proxy a -> f ())`
19:16:33 <philippD> But now I have Errors on the callsite I have to take care of
19:17:12 <nshepperd> this seems like it would be less confusing if you put proxies in the appropriate places instead of relying on TypeApplications
19:17:34 <nshepperd> applyT should have a proxy argument that specifies l as well
19:17:46 <dataN> how can you tell?
19:18:02 <dataN> when to use proxies, and when to use TypeApplications?
19:18:41 <philippD> nshepperd: It doesn't really change anything
19:19:11 <nshepperd> dataN: always use proxies, except when the correct way to use TypeApplications is so obvious that no-one could possibly get it wrong
19:19:15 <slack1256> Does anybody know the story why haskell didn't include row-polymorphism and polymorphic variants on the language definition?
19:20:01 <maerwald> I don't think that was a decision in terms of "must not include", but rather there was no reasoning to do so?
19:20:36 <dolio> Because it's not even clear what a good design for all that is?
19:21:18 <c_wraith> Those are things that could be easily added with a language extension, if everyone agreed the extension did it properly.
19:21:41 <c_wraith> The fact that they haven't been added should be taken as evidence that there's serious disagreement over how to do them.
19:22:25 <slack1256> That is a fair point.
19:23:34 <slack1256> But I was thinking "Are there downsides to a language with those extensions?", on the posts it always looks like a plus
19:24:42 <dolio> It's really easy to sketch something involving row types that looks cool, and really hard to come up with something that works well for it.
19:24:46 <dolio> In practice.
19:25:32 <slack1256> With that you mean, to come up with an implementation that is robust?
19:26:17 <dolio> Depending on what you want to do, it's easy to make your type checking intractable.
19:26:26 <nshepperd> that and it has to be compatible with all the other features haskell has
19:26:37 <dataN> ok, the error is not from conflicts with prelude; https://lpaste.net/6503176666259390464
19:27:17 <dolio> And there are research papers on tractable versions, but they're limited in certain ways.
19:27:35 <dataN> maybe the rule is when the forall is furthest in then the proxy is required...
19:27:37 <dolio> And you have to decide on various ways of dealing with duplicate tags and stuff.
19:30:26 --- mode: kornbluth.freenode.net set +v badzergling__
19:30:52 <dataN> its strange because normally the undecidable constraints results in a compile time error...
19:32:40 <dataN> like, even with all the language extensions, it hits a loop at compile time, so not only is the error itself difficult to find, its also difficult to see why it loops.
19:34:18 <dataN> why does this loop? https://lpaste.net/855601568907526144
20:23:17 * hackage cli-setup 0.2.0.5 - Helper setup scripts for packaging command-line tools.  http://hackage.haskell.org/package/cli-setup-0.2.0.5 (vmchale)
22:01:47 * hackage xmonad-spotify 0.1.0.0 - Bind media keys to work with Spotify  http://hackage.haskell.org/package/xmonad-spotify-0.1.0.0 (vmchale)
22:06:07 <dsal> What's   Applicative f => (a -> b -> f c) -> fa -> f b -> f c
22:06:12 <dsal> ?
22:12:50 <eiGHttt> :t liftA2
22:12:51 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
22:14:10 <dsal> Yeah, except it's "f c" and not just c
22:14:16 <dsal> It's a bind of some sort.
22:17:13 <cocreature> dsal: you need a Monad for this
22:17:25 <dsal> f is Maybe here
22:17:51 <cocreature> :t \f x y -> do x' <- x; y' <- y; f x' y'
22:17:52 <lambdabot> Monad m => (t1 -> t2 -> m b) -> m t1 -> m t2 -> m b
22:19:52 <eiGHttt> :t foldlM
22:19:53 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
22:21:17 * hackage vector-algorithms 0.7.0.3 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.7.0.3 (ErikDeCastroLopo)
22:22:27 <nshepperd> :t (fmap.fmap.fmap) join liftA2
22:22:28 <lambdabot> Monad m => (a1 -> b -> m a2) -> m a1 -> m b -> m a2
22:22:34 <dsal> cocreature: Thanks.  I recognized the need for a bind, but thought there was a magic that could do it all at once.
22:23:01 <rotaerk> much readable
22:23:09 <dsal> Heh, 'do' seems to be the most straightforward here.
22:23:26 * nshepperd doesn't condone actually using the triple-fmap operator
22:23:59 <cocreature> dsal: you could ofc define some "bind2" synonym for that but since that’s not particularly common I would stick to do notation for the sake of anyone reading your code base
22:24:26 <dsal> Yeah.  I'm going to be the only victim here.
22:25:27 <rotaerk> :t join liftM2
22:25:29 <lambdabot> ((a2 -> r) -> a2 -> r) -> ((a2 -> r) -> a2) -> (a2 -> r) -> r
22:25:29 <rotaerk> err
22:25:33 <nshepperd> :t \f a b -> join (liftA2 f a b) -- the sensible version of what i wrote
22:25:35 <lambdabot> Monad m => (a1 -> b -> m a2) -> m a1 -> m b -> m a2
22:25:42 <cocreature> dsal: that just means that the person reading your code is you in 4 months when you’ve forgotten about the name :)
22:26:22 <rotaerk> :t \f ma mb -> join (liftM2 f ma mb)
22:26:24 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
22:26:52 <rotaerk> oh, liftM2 is just a constrained liftA2...
22:27:28 <cocreature> rotaerk: yeah liftM2 is from the pre-amp days
22:27:36 <rotaerk> k
22:33:29 <dsal> cocreature: Yeah, that's what I mean.  Most of the haskell I write is basically notes to myself in the form of semi-useful programs.
22:33:54 <dsal> Often solving a simple problem and then continuing to work on it for a long time because I can't ever stop.
22:36:21 <subttle> damn, all the Applicative talk in the channel before inspired me to try to write that instance again and I think I have it this time woohooo... I haven't done the proofs yet but I ran a quick test for each law, so far so good
22:38:17 <subttle> I think the reason was mainly that I tried implementing liftA2 first (this was a while ago), and then when I went to revisit it I had a look at this page 
22:38:23 <subttle> https://dkalemis.wordpress.com/2014/03/22/trees-as-monads/
22:38:48 <subttle> and it said the type of structure I was using was bad for applicative
22:39:42 <subttle> anyway, point being is thank you channel for being awesome XD
22:40:32 <cocreature> subttle: if you post your code here, someone might be able to tell you if your Applicative instance is valid
22:40:57 <cocreature> although for the most part, just playing type tetris gets you to the right instance if you don’t produce an infinite loop
22:41:10 <subttle> okay I'll be embarassed when it isn't but sure
22:42:34 <cocreature> there is absolutely no need to be embarrassed! we all make mistakes :)
22:43:14 <subttle> https://gist.github.com/subttle/046975cd1c8a608e68b1795eeb019843
22:46:54 <cocreature> subttle: looks correct!
22:47:00 <subttle> I'm sure I could derive that Functor instance
22:47:04 <subttle> cocreature: woohoo!!
22:47:10 <subttle> haha thanks!
23:01:47 * hackage xmonad-volume 0.1.0.0 - XMonad volume controls  http://hackage.haskell.org/package/xmonad-volume-0.1.0.0 (vmchale)
23:05:12 <Ke> it's like they upload a package and the homepage is 404
23:18:19 <edwardk> jle`: i went with the generic name figuring we might get some more streamers to use it
23:31:02 <trcc> So in my FFI i am just using regular haskell types, i.e. Int and Double and not CDouble and CInt. So far no problems - what are the downsides of this?
23:38:44 <geekosaur> it might become stricter in the future and won't compile any more. also Int is a bit of a time bomb looking for a chance to go off, since CInt is always 32 bits but Int is 64 bits on 64-bit platforms.
23:39:37 <geekosaur> (and, if there at some point appear other Haskell implementations again, Int may not be either 32 or 64 bits; the standard allows some bit stealing for constructor tags. ghc doesn't do this but others might)
23:41:20 <trcc> geekosaur: ah okay. I'll switch to the FFI types then. Why is CInt always 32 bits?
23:41:58 <trcc> is an int in C "always" 32 bits?
23:42:09 <geekosaur> mostly to minimize portability issues between 32 and 64 but CPUs. pointers are still a problem but basic math isn't
23:42:22 <geekosaur> on Intel architecture, yes
23:42:44 <trcc> hmm
23:42:48 <geekosaur> it's not a hard requirement but a decision made by the implementors to aid in compatibility
23:42:49 <Ariakenom> trcc: No int's are a t least 16 bits. int should be named int16_fast
23:43:10 <Ariakenom> were fast indicates overflow is undefined. But it's always undefined so int16 is fine I guess
23:44:08 <trcc> that makes it really difficult to decide the FFI interface, when all the standard says is int
23:44:29 <Ariakenom> theoretically that is. practice is different. because C is <rant>
23:44:49 <geekosaur> ...that's a bit smartass, but the C standard indeed guarantees only minimum 16 bits, nothing else. the rest belongs to the platform ABI, and the assumption is that the Haskell FFI deals with that for you and gives you types CInt, CDouble, etc. that comply with the C ABI
23:45:01 <geekosaur> whereas Haskell types are not so guaranteed
23:45:34 <trcc> I'll go with CInt and see how it behaves
23:45:34 <Ariakenom> geekosaur: I mean I work in 16 bit ints. I'm not just trying to be annoying
