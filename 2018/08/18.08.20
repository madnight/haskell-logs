00:00:26 <dminuoso> pally: This `Sum` constructor is just an artifact of the fact that you can have only one instance per concrete type - and that you sometimes have multiple possible monoid instances.
00:00:49 <Flonk> Semigroup is in base now?
00:01:05 <cocreature> it’s been in base for some time
00:01:07 <dminuoso> pally: For example for `Int` you might have at least 2 candidates (addition and multiplication). So Haskell opted to create a newtype wrapper for each possible Monoid instance. :)
00:01:16 <cocreature> what’s relatively new is that Semigroup is a superclass of Monoid
00:01:35 <Flonk> ah
00:01:37 <thunderseethe> Is there a group typeclass in base?
00:01:53 <dminuoso> pally: Endo for example is the newtype wrapper endofunctions. (remember, an endofunction is just a function that has the same output type than input type)
00:02:19 <dminuoso> @let f' = Endo (+2) <> Endo (*3)
00:02:20 <lambdabot>  Defined.
00:03:03 <cocreature> thunderseethe: no
00:03:20 <dminuoso> thunderseethe: We have a pseudo-ring typeclass though, it's Num
00:03:33 <thunderseethe> I guess that wouldn't really give you a lot since we can't enforce group laws 
00:03:46 <dminuoso> thunderseethe: That's a nonsense argument, you cant enforce monoid laws either.
00:03:52 <dminuoso> Or functor laws. Or any laws really.
00:04:06 <Ariakenom> They're enforced socially
00:04:11 <Ariakenom> you will be mocked
00:04:49 <thunderseethe> Well yea but a group typeclass would be monoid plus some invisble extra rules
00:05:13 <thunderseethe> That could cause quite a bit of confusion for not a lot of advantage
00:05:15 <dminuoso> thunderseethe: monoid already has invisible extra rules. ;)
00:05:54 <dminuoso> thunderseethe: The trickery is especially funny for Monad. Try writing a lawful ListT monad transformer.
00:06:00 <cocreature> it’s not just monoid + some extra rules, it would also give you extra operations
00:06:24 <thunderseethe> cocreature does it give you extra operations?
00:06:35 <cocreature> thunderseethe: yes, an operation to get the inverse of a given element
00:06:55 <dminuoso> whereas inverse means: inverse x <> x = mempty
00:07:16 <thunderseethe> cocreature ah that's true I had not considered you would have an explicit function for that
00:07:39 <cocreature> Group just seems to be far less useful of an abstraction than Monoid when it comes to programming
00:07:53 <dminuoso> thunderseethe: for what its worth, Ive been pondering for a while now why exactly we have so many Monoid constraints
00:08:00 <dminuoso> when frequently an unital magma would suffice
00:08:56 <cocreature> you leak a lot of implementation details if you don’t require Associativity
00:10:03 <dminuoso> cocreature: Perhaps it's even more of a mathematical question - why associativity is so prevalent.
00:14:18 <dminuoso> Different topic: Are there languages like C but done right? Would that be rust? Are there more primitive alternatives with a strong focus on macro-assembler?
00:14:32 <cocreature> non-associative operations require way too much book-keeping for anyone to bother with them :)
00:16:12 <cocreature> rust is probably more C++ done right than C
00:17:25 <Ariakenom> everyone probably has a different idea of what the "right" parts of C are
00:19:42 <coldpresent> the devil is in the preprocessor :)
00:21:24 <cocreature> I write Haskell code using the C preprocessor!
00:21:48 <nshepperd> maybe haskell is C done right in that case
00:21:50 <dminuoso> Ariakenom: Something with an ML-kind of type system would be a great start.
00:22:14 <dminuoso> nshepperd: Well I want a non-GCed language, and it should really be lazy.
00:22:17 <dminuoso> *be strict!
00:23:40 <dminuoso> coldpresent: honestly the C preprocessor is the least problematic part.
00:38:25 <rish> Hey, I want to expose a Web API to interface with some ffi code, mainly Hunspell. To access Hunspell you create an instance of it and pass it to every function later on. Since the web server will have multiple request threads accessing a single hunspell instance I decided to use a MVar based locking to limit the access to a single thread at a time. However when I remove the lock and let everything access the
00:38:27 <rish> instance, it still works. Was my initial assumption wrong? If the ffi is marked as safe, did I actually need to do any locking?
00:41:55 <arahael> rish: I once made a garbage collected GC for a C-based project at uni.
00:42:19 <cocreature> rish: it depends on whether hunspell is thread safe
00:42:58 <arahael> rish: Spent 2 months on it, and then I found out two days before it was due that the locks never worked.  I've never made my own locks since, but the point is: It's quite possible for code to continue to work just fine without locks.
00:42:59 <cocreature> if it’s not thread safe then simple locking might also not be sufficient and you need to ensure that all calls are made from the same OS (not Haskell) thread
00:43:19 <arahael> rish: Until it doesn't work.  Therein lies the problem.
00:43:30 <rish> cocreature: looking at questions online and the code (although I am not too sure), it seems that hunspell is not threadsafe. So I am looking for ways to verify this too
00:44:22 <arahael> rish: You're using a "webserver" anyway, you might as well go full microservices, and just put Hunspell into it's own http server.
00:44:29 <dminuoso> rish: what is hunspell written in?
00:44:37 <cocreature> rish: fwiw there are Haskell bindings to hunspell on hackage that seem to take care of thread safety https://hackage.haskell.org/package/hunspell-hs
00:44:40 <dminuoso> rish: Oh its C++. You could helgrind it to get an idea.
00:44:41 <rish> arahael: how would I frontload 
00:45:12 <dminuoso> rish: a negative wont say much, but if it reports race conditions then that's really not good.
00:45:19 <cocreature> oh I guess those are your bindings probably :)
00:45:29 <rish> cocreature: that's my library, that's the library I am talking about. It's running fine in production with a webserver invoking it on every request
00:45:59 <arahael> rish: I'm not sure how you'd frontload, that'd be API specific, I'd expect?
00:46:07 <mniip> if a library says "not thread safe" and you run it in a multithreaded environment and it doesn't crash and you conclude that it's okay
00:46:14 <rish> cocreature: but I feel like I missing some insight on how it could be faster, or whether it was overkill to use MVar. I adapted it from a go library which did use Mutex
00:46:20 <dminuoso> cocreature: https://github.com/ashutoshrishi/hunspell-hs/blob/master/src/Language/Hunspell.hs#L137-L144
00:46:24 <mniip> you're on very thin ice and deserve to get shit when it does go bad
00:46:30 <dminuoso> cocreature: are you sure about that "take care of thread safety" part? :P
00:46:54 <dminuoso> I absolutely love code that says "atomically.." and you look at the code and see the synchronization primitives being commented out..
00:47:04 <cocreature> dminuoso: I only looked at the docs ;)
00:47:08 <dminuoso> Heh!
00:47:21 <rish> dminuoso: haha, that's not the released version. I am just trying something out right now
00:47:30 <rish> dminuoso: should have pushed a tag
00:48:40 <dminuoso> rish: Oh. Didn't realize that was you, should have git blamed it you are right.
00:49:05 <mniip> is there some kind of 'gshow' that works just like derived Show?
00:49:56 <mniip> powered by generics, obviously
00:49:59 <Ariakenom> dont know the ffi but why are you trying no locking and safe-call instead of locking and unsafe-call?
00:50:19 <cocreature> mniip: maybe try the one in generics-deriving? not sure how close it is to the derived version
00:50:25 <cocreature> *generic-deriving
00:50:27 <cocreature> https://hackage.haskell.org/package/generic-deriving-1.12.2/docs/Generics-Deriving-Show.html#v:gshow
00:50:42 <dminuoso> mniip: Thank you for helping me understand the innards of IO by the way. I think I even understand how unsafeDupableInterleaveIO works, it's quite interesting. :)
00:50:55 <mniip> really hoping to write something like
00:51:10 <mniip> instance Show T where show x | f x = g x | otherwise = gshow x
00:51:30 <mniip> (aint nobody got time for writing out show for dozens of constructors)
00:51:31 <rish> mniip: thanks, that's good information to know (I won't assume it works just because it runs fine for a while). Is there a good test I can try or should I try better to understand the operational semantics?
00:52:02 <mniip> valgrind has a race checker
00:52:04 <dminuoso> rish: You need formal methods to prove correctness.
00:52:19 <mniip> though the GHC rts might hinder valgrind's investigation
00:52:28 <Ariakenom> rish: dont know the ffi but why are you trying no locking and safe-call instead of locking and unsafe-call?
00:52:38 <mniip> I suggest you write a simple C wrapper around the library, run it in valgrind and pound it with requests
00:52:45 <dminuoso> Even if you use helgrind like I suggested, the absence of reports will not prove that it's free of race conditions.
00:52:55 <dminuoso> helgrind can only detect certain kinds of race conditions
00:53:11 <dminuoso> So it's a great tool to invalidate your assumptions, not so much to validate them.
00:53:15 <mniip> ah. I never used it. Assumed it was the magic solution :P
00:57:00 <rish> Ariakenom: I only just started reading more about the concurrency in ffi. Like you said, I realised that safe calls do some extra work to let a single os thread run the foreign call, so I am removing the locks and seeing if safe calls work 
00:58:53 <rish> dminuoso: I am interfacing the hunspell library with a servant + wai server. It receives requests for spellcheck on chunks of text, and it works with and without locks. but like you said, I should not conclude that it will continue working
00:59:54 <haasn> One of the known pitfalls when learning haskell is that haskell reuses a lot of terminology from other languages in different ways, examples I can think of being “class”, “method”, “return” or “constructor”. Are there any other examples I could add to this list?
01:00:14 <arahael> haasn: "function", and "variable".
01:00:22 <arahael> haasn: And "burritos".
01:00:32 <Ariakenom> haasn: s/reuses/uses/
01:00:38 <cocreature> rish: a safe FFI call won’t help you at all if the underlying C lib is not thread safe
01:00:45 <dminuoso> rish: Threading problems have a tendency to present themselves rarely. Sometimes the timing requires a nanosecond window of opportunity of two threads.
01:01:17 <Ariakenom> rish: yes. but did you consider if you can use unsafe-call ?
01:01:21 <dminuoso> rish: Which is why frequently multithreading problems dont appear until you have production software.
01:01:29 <dminuoso> It
01:02:14 <cocreature> safe FFI calls enable two things: first you can safely call back into the Haskell runtime from the FFI call and second they don’t block other Haskell threads
01:02:51 <cocreature> neither of those things will help you if your C library isn’t thread safe
01:03:28 <dminuoso> haasn: `functor` (C++ folks have a different meaning for this)
01:04:12 <mniip> I insist that C++ folks call it functional object
01:04:31 <haasn> Good additions, thanks
01:04:32 <arahael> mniip: Of course it's functional.
01:04:40 <mniip> but also we got the name earlier than the C++ folks
01:04:44 <arahael> mniip: Why would a C++ make a *non* functional object? ;)
01:05:03 <dminuoso> haasn: unrelated to haskell, it may also be confusing to find words being reused differently like container names
01:05:07 <dminuoso> haasn: vector, list, array..
01:05:22 <arahael> haasn: Gave me pause to see the "null" function.
01:05:23 <mniip> yeah, list is a very specific thing in haskell
01:05:39 <cocreature> hm, I’m curious, at which point did the oop people come up with the name “constructor”?
01:05:40 <arahael> Oh, "application" is different, too.
01:05:52 <mniip> cocreature, CONS?
01:06:04 <mniip> arahael, function application has always been called that
01:06:28 <cocreature> mniip: is that a language?
01:06:35 <mniip> no
01:06:41 <mniip> I mean CONS as it appeared in lisp
01:06:46 <rish> Ariakenom: I did try unsafe, and it works. Didn't try it in production. Currently I am using MVar and safe calls in production. it's slow but it works
01:06:49 <arahael> mniip: You mean, apply, or <$>?
01:07:06 <mniip> 'f x' is function application
01:07:13 <dminuoso> :t liftA2 (,)
01:07:14 <lambdabot> Applicative f => f a -> f b -> f (a, b)
01:07:18 <haasn> (so is `f <$> x`)
01:07:19 <cocreature> that doesn’t really answer my question then? lisp is not oop and CONS in lisp is different from constructors in oop
01:07:22 <mniip> I wouldn't call <$> or <*> application
01:07:28 <mniip> fmap, ap
01:07:45 <arahael> mniip: In other languages, it usually means to apply a set of arguments to a function.  I suppose in haskell, this might just be uncurry.
01:09:30 <mniip> you mean "partial application"
01:09:40 <mniip> emphasis on partial
01:10:42 * hackage typerep-map 0.3.0 - Efficient implementation of a dependent map with types as keys  http://hackage.haskell.org/package/typerep-map-0.3.0 (vrom911)
01:25:02 <Ariakenom> arahael: what did you mean with variable?
01:29:39 <Ariakenom> More names, Haskell's () is C's void. Haskell has Void too but it's different.
01:29:56 <Ariakenom> but also
01:29:57 <Ariakenom> :t void
01:29:58 <lambdabot> Functor f => f a -> f ()
01:49:47 <dminuoso> Ariakenom: Id argue that in some respect void is actually the same.
01:51:03 <dminuoso> Ariakenom: Such as: You can declare an object of type void but not define it.
01:52:47 <dminuoso> Ariakenom: That notion of "() is C's void" seems to come from trying to see functions in C the haskell/mathematical way.
01:54:22 <Ariakenom> dminuoso: It comes from them being placeholders. You can return void. You can't return Void (non-bottom)
01:54:35 <dminuoso> Ariakenom: what does it mean to "return void"
01:54:43 <dminuoso> Ariakenom: You dont return any value at all.
01:54:50 <Ariakenom> (IO Void) versus void f()
01:55:05 <dminuoso> Ariakenom: I'd argue they are exactly the same.
01:55:33 <dminuoso> Ariakenom: all you can do with `void f();` is sequence calls, but you can't draw a result from it into a variable.
01:55:43 <dminuoso> that is you can't do: void g = f();
01:56:09 <Ariakenom> that's just a strange quirk imo
01:56:24 <Ariakenom> void f() {return;}       f :: () -> Void; f () = ?
01:56:39 <dminuoso> Ariakenom: Like I said: That's trying to think of C the haskell/mathematical way.
01:57:06 <Ariakenom> dminuoso: you said that. you didnt argue for it
01:57:15 <Ariakenom> define that ? for me pls
01:57:26 <dminuoso> Ariakenom: Okay consider this. What is the difference between `IO Void` and `IO ()`?
01:57:56 <Taneb> IO Void can never stop
01:58:12 <Ariakenom> IO with impossible value, so loop or exception. IO with unimportant value.
01:58:13 <Taneb> Or rather, it can never allow you to continue the program beyond it
01:58:38 <Ariakenom> void f(); is a function with unimportant return. not "impossible"
01:58:45 <dminuoso> Taneb: Can't it? `do { _ <- impossibleAction; blablabla }`
01:59:01 <Taneb> dminuoso: you can write that but you can't write impossibleAction
02:00:09 <Taneb> Because if you could you could execute the value returned by "absurd :: Void -> IO ()"
02:01:36 <dminuoso> Ariakenom: What I consider far more unsettling, is that you can do something like `extern void foo` and then end up creating a `void *` pointer via &foo
02:02:07 <dminuoso> But fair enough, I guess you are right. It's a weird mixture between () and Void.
02:02:41 <cocreature> how is it a mixture and not exactly ()?
02:02:47 <xsperry> :i Void
02:02:51 <xsperry> :t Void
02:02:52 <lambdabot> error:
02:02:52 <lambdabot>     • Data constructor not in scope: Void
02:02:53 <lambdabot>     • Perhaps you meant one of these:
02:03:00 <Taneb> :k Void
02:03:01 <lambdabot> *
02:03:10 <xsperry> > Void
02:03:11 <lambdabot>  error:
02:03:11 <lambdabot>      • Data constructor not in scope: Void
02:03:11 <lambdabot>      • Perhaps you meant one of these:
02:03:18 <cocreature> % :i Void
02:03:18 <yahb> cocreature: data Void -- Defined in `Data.Void'; instance [safe] Eq Void -- Defined in `Data.Void'; instance [safe] Ord Void -- Defined in `Data.Void'; instance [safe] Semigroup Void -- Defined in `Data.Void'; instance [safe] Show Void -- Defined in `Data.Void'; instance [safe] Read Void -- Defined in `Data.Void'; instance [safe] Ix Void -- Defined in `Data.Void'; instance [safe] Data Void -- Defined in `Data.Void'
02:03:22 <dminuoso> cocreature: Because of the inability to create objects of type void.
02:03:32 <xsperry> it is a type with no constructors?
02:03:52 <dminuoso> xsperry: Correct.
02:03:53 <Taneb> dminuoso: it's a poorly named, second class ()
02:04:08 <xsperry> dminuoso and the point of that type is?
02:04:21 <phadej> note that if you about C as "pure" functions, they are a -> IO b
02:04:22 <xsperry> when would you use it over () 
02:04:37 <phadej> and () -> IO Void can be written (if IO weren't strict monad)
02:04:40 <cocreature> yeah, I’m happy calling it a second class citizen but I don’t think it has anything to do with Void
02:04:46 <dminuoso> xsperry: Contrary to what I said earlier, because I was thinking of a different direction, it's to encode the impossibility to have a value.
02:04:48 <phadej> can "be kind of written"
02:04:50 <dminuoso> Taneb: Fair enough.
02:04:52 <Taneb> xsperry: you can use it to express non-termination
02:05:21 <phadej> but it doesn't make sense to think about C that way
02:05:21 <dminuoso> xsperry: For example the ideal type of forever would be: Applicative f => f a -> f Void
02:05:33 <Taneb> And some other stuff, too, if I see a value of type [Void] I know it must be empty
02:05:35 <phadej> dminuoso: no, -> f b is way more useful
02:05:41 <xsperry> I'm not sure how that is better than Applicative f => f a -> f ()
02:05:50 <dminuoso> phadej: Oh yeah, I meant `ideal` in a noble kind of way :P
02:06:00 <phadej> :t forever
02:06:01 <lambdabot> Applicative f => f a -> f b
02:06:02 <Taneb> f () suggests you can do stuff after it
02:06:15 <cocreature> I don’t think Void is any more noble than a universally quantified b. they express exactly the same thing
02:06:44 <xsperry> if Void is meant to be used in this way it should have been given a more descriptive name
02:07:03 <[exa]> I heard someone calling it 'Voidever'
02:07:04 <dminuoso> xsperry: Void is called because it's the void type. It is devoid of any inhabitants.
02:07:13 <dminuoso> xsperry: (ignoring bottom)
02:07:30 <dminuoso> xsperry: from it functions like `absurd :: Void -> a` come
02:07:52 <madnight> :t absurd
02:07:53 <lambdabot> Void -> a
02:08:30 <dminuoso> I think some authors in set theory sometimes call the empty set void set.
02:10:08 <dminuoso> cocreature: If they expressed the same thing, shouldn't they be isomorphic?
02:10:11 <madnight> from bottom anything follows
02:10:45 <cocreature> dminuoso: they are, absurd gives you one direction and the other is just a specialized version of id
02:10:55 <dminuoso> :t id
02:10:56 <lambdabot> a -> a
02:11:05 <dminuoso> cocreature: How do you specialize that into `a -> Void`?
02:11:15 <cocreature> not id, sry but you just instantiate the type variable
02:11:24 <Ariakenom> :t id @Void
02:11:25 <lambdabot> error:
02:11:25 <lambdabot>     Pattern syntax in expression context: id@Void
02:11:25 <lambdabot>     Did you mean to enable TypeApplications?
02:11:32 <xsperry> dminuoso, would you be able to guess what Void is supposed to be used for, and how it is different than (), without checking the documentation? with a more descriptive name, you probably could
02:11:45 <Ariakenom> % :t id @ Void
02:11:46 <yahb> Ariakenom: Void -> Void
02:12:00 <dminuoso> xsperry: Void can also be used to track "impossible to have a value here" through a type system
02:12:12 <cocreature> % :t let f :: (forall a. a) -> Void; f x = x in f
02:12:13 <yahb> cocreature: (forall a. a) -> Void
02:12:17 <dminuoso> cocreature: Ah gotcha.
02:12:52 <cocreature> which does at least have the same implementation as id :)
02:15:13 <Ariakenom> xsperry: what's a " guess what Void is supposed to be used for, and how it is different than (), without checking the documentation?" name?
02:16:00 <xsperry> Ariakenom I don't know. but it aint Void
02:16:17 <cocreature> depends on how much type theory you’ve been exposed to before :)
02:17:34 <Taneb> cocreature: although "Initial" is better with too much theory, and significantly worse without
02:18:29 <cocreature> naming things is hard :)
02:18:33 <xsperry> cocreature did they get that from type theory, or C language? it seems like haskell designers like to confuse C programmers :P (for example 'return')
02:19:08 <Ariakenom> You want confusing? :p
02:19:10 <Ariakenom> :t void
02:19:12 <lambdabot> Functor f => f a -> f ()
02:19:19 <cocreature> I’m pretty sure using void for empty types/sets is older than the usage in C
02:20:27 <xsperry> that may be older than C, but haskell isn't
02:20:55 <cocreature> that’s not to say that there might not be a less confusing name but I honestly don’t know what it would be and I think there is also value in sticking to existing terms that are used at least in some contexts
02:20:59 <Ariakenom> return was designed to be familiar to C programmers I assume. you can blame the execution though
02:21:24 <Taneb> I think if Haskell had as a design goal "don't confuse C programmers", it would probably be a worse language, and almost certainly a worse Haskell
02:22:01 <Ariakenom> Ya, if we assume a C context Void is bad. But there are other contexts.
02:22:38 <Ariakenom> and C isn't a pinnacle of consistency and elegance to aspire to imo
02:26:00 <xsperry> it most certainly isn't. but when you take naming convention from C (and not just C), such as return, and make it look superficially similar in common use, while in reality, it is completely different, I'm  not sure how that is helpful to anyone
02:27:15 <ChaiTRex> Is there a way to convert a Constraint to a type level Bool based on whether the constraint is satisfied?
02:27:41 <cocreature> yeah return was definitely a mistake imho :)
02:27:49 <Ariakenom> yes, return being a bad name isn't controversial
02:28:03 <xsperry> and even if we forget C, Void isn't the best name. () has one value. Void has no value, meant to be used for non-termination. void is a function that takes f a and returns f () 
02:28:20 <cocreature> you still haven’t proposed a better name :)
02:28:29 <Ariakenom> xsperry: Void is a fine name. void is a bad name :p
02:29:45 <Ariakenom> the function void is clearly named after C's void. I learned about the function yesterday, my reaction was "wow, that's a bad name. TIL"
02:31:46 <veverak> interesting
02:32:00 <veverak> somehow I feel like this channels talks a lot about C...
02:33:02 <cocreature> secretly we’re all just writing C all day
02:33:53 <Ariakenom> indeed
02:37:31 <dmwit> ?tell fragamus Yes; you can see it here: https://lpaste.net/3837529025295679488
02:37:31 <lambdabot> Consider it noted.
02:37:59 <xsperry> Ariakenom I had same reaction after finding about Void (just now), while knowing about void before. void has the same use as (void) in C, shutting down compiler warning. I guess both names make sense, but to both in the same language, is a bit confusing :P
02:37:59 <hc> cocreature: =)
02:38:18 <hc> cocreature: I do write C every day, but I use a preprocessor to do it, called ghc
02:39:25 <Ariakenom> xsperry: I don't thing void makes sense as a name in hs at all
02:40:01 <Ariakenom> I was actually chocked at how bad and confusing it was :|
02:40:55 <xsperry> it made perfect sense to me (but I did not know about Void when discovering void)
02:41:06 <Ariakenom> makes sense
02:41:07 <liste> I think JavaScript has void too
02:41:21 <liste> which works like Haskell's void
02:41:29 <liste> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void
02:41:48 <dmwit> ?tell fragamus Some features of interest: \t<thing> to align nearby <thing>s (e.g. = signs, > for right arrows, < for left arrows, i for imports); \il to jump to the import list; \q on a line with `import Foo.Bar.Baz [(Type)]` to add a line `import qualified Foo.Bar.Baz as B`; \l<abbreviation> to add a language pragma, where the abbreviation is just the upper case letters of the pragma name if that's 
02:41:49 <lambdabot> Consider it noted.
02:41:54 <dmwit> unambiguous or upper-case letters + the first letter after the last upper-case one to disambiguate
02:42:11 <dmwit> ?tell fragamus unambiguous or upper-case letters + the first letter after the last upper-case one to disambiguate
02:42:11 <lambdabot> Consider it noted.
02:50:38 <dmwit> Hm. I think the one I have at work has a few more things, but I haven't synched my home and work computers in a while. Oh well.
02:52:41 <dmwit> ?tell fragamus Oops, this is an outdated version with a few infelicities. I'll try to remember to send along my latest version once I get to work.
02:52:41 <lambdabot> Consider it noted.
03:03:42 * hackage csg 0.1.0.5 - Analytical CSG (Constructive Solid Geometry) library  http://hackage.haskell.org/package/csg-0.1.0.5 (DmitryDzhus)
03:09:13 * hackage potoki-core 2.2.8 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.2.8 (NikitaVolkov)
03:10:13 * hackage potoki 2.0.6 - Simple streaming in IO  http://hackage.haskell.org/package/potoki-2.0.6 (NikitaVolkov)
03:20:41 <maerwald> when does stack regenerate .cabal file from package.yaml? It seems I have zero control over the process
03:22:02 <dminuoso> Who said that in traditional languages the callstack is usually a dozen stack frames? https://gist.github.com/dminuoso/7f6444b9b884f141aebd3402e1a0e6c7
03:24:44 <domenkozar> is it possible to do exsistential qualification for all sum types at once?
03:24:47 <domenkozar> data A = forall a. Show a => A a | B a | C a
03:25:01 <domenkozar> or do I have to do it per each constructor?
03:25:29 <sondr3> hello, I have a few quick questions about working with Haskell in Emacs if anyone here uses both
03:25:35 <dminuoso> sondr3: Just ask your question :)
03:25:51 <sondr3> cool
03:26:07 <sondr3> If you're using Intero, is there a need to also use interactive-haskell-mode at the same time?
03:26:24 <sondr3> I've been reading up on both but can't seem to figure out whether they supplement each other or override one another
03:29:02 <dmwit> domenkozar: once per constructor
03:29:29 <dmwit> domenkozar: But consider `data Tag = A | B | C; data A = forall a. Show a => MkA Tag a`
03:30:32 <domenkozar> oh neat :)
03:31:41 <domenkozar> dmwit: thanks
03:42:42 * hackage appendmap 0.1.1 - Map with a Semigroup and Monoid instances delegating to Semigroup of the elements  http://hackage.haskell.org/package/appendmap-0.1.1 (AlexeyKotlyarov)
03:51:22 <madnight> what works better for you, theory first then examples or examples first and then theory
03:52:43 <[exa]> depends
03:52:58 <[exa]> Identity is a nice example of too much stuff
03:54:19 <domenkozar> dmwit: went with GADTs
04:01:22 <madnight> can null in languages like java be considered as kind of bottom?
04:02:10 <Ariakenom_> if (x==NULL)
04:02:22 <Ariakenom_> > 1 == undefined
04:02:25 <lambdabot>  *Exception: Prelude.undefined
04:03:17 <quchen> No.
04:03:24 <dminuoso> madnight: not quite
04:03:28 <Flonk> null is more like ()
04:03:29 <quchen> Bottom in Java can be considered as kind of bottom.
04:03:29 <ggVGc> sweet old undefined
04:03:38 <dminuoso> madnight: One of the most important features of bottom is that you cant detect bottom.
04:03:48 <dminuoso> madnight: It's fundamentally not possible.
04:04:24 <dminuoso> madnight: Java is more like.. every type is wrapped in a Maybe, and it's up to you at every statement to scrutenize your value and test whether it's "Nothing" (that is Null)
04:04:39 <dminuoso> But without the type system or the implementation forcing/promoting this in any way.
04:04:52 <quchen> And then throw IO into the mix as well!
04:07:18 <Ariakenom_> % :t unsafePerformIO . try . evaluate
04:07:18 <yahb> Ariakenom_: Exception e => a -> Either e a
04:08:37 <cocreature> Ariakenom_: thou shalt not mention the existence of unsafePerformIO!
04:08:55 <madnight> the Nothing is null analogy doesn't seem correct to me, because one is a Functor (Maybe) and the other is a plain value. For me it's more like Java's Type system is "rigged" with null in the same way that Haskells is due to bottom
04:09:07 <dminuoso> madnight: bottom is fundamentally different.
04:09:27 <dminuoso> madnight: bottom represents a failure to compute a value, which might be due to non-termination for example.
04:09:34 <dminuoso> madnight: Null _is_ a computed value.
04:09:43 * hackage appendmap 0.1.2 - Map with a Semigroup and Monoid instances delegating to Semigroup of the elements  http://hackage.haskell.org/package/appendmap-0.1.2 (AlexeyKotlyarov)
04:09:53 <Ariakenom_> % :t try . evaluate -- cocreature is this enough?
04:09:54 <yahb> Ariakenom_: Exception e => a -> IO (Either e a)
04:10:01 <madnight> don't get me wrong i don't want to say that null is bottom in any way
04:10:33 <cocreature> Ariakenom_: I can accept that :)
04:11:00 <madnight> what i want to say is that bottom and null "destroys" (in math sense) the type system in the same way
04:11:10 <Ariakenom_> wrt dminuoso's "cant detect bottom"?
04:11:24 <madnight> by adding a "thing" that matches every type
04:11:31 <merijn> madnight: The thing is that bottoms are something that occurs way less frequently than null
04:11:49 <cocreature> Ariakenom_: well you can only detect a subset of bottom using that
04:11:50 <merijn> madnight: So while *in theory* they have the same breaking effect, *in practice* they don't
04:11:50 <phadej> madnight: null doesn't destroy anything. In Java everything is wrapped in MaybeT IO
04:11:55 <cocreature> you still won’t catch non-termination
04:11:58 <phadej> madnight: and that's implicit
04:13:01 <phadej> in OCaml everything is implicitly in IO, which is better, but not enough for purists :)
04:13:13 <cocreature> it only destroys the type system in a math sense if you pretend that it doesn’t exist in your math formulation. it’s perfectly possible to model null and bottom
04:13:35 <Ariakenom_> cocreature: True
04:13:46 <madnight> or i can put it in other word, in math we have well defined types / sets and then some java / haskell people come over and add "stuff" to that to make thinks work on a computer
04:14:02 <Ariakenom_> but I think I needed to show something not everything
04:14:46 <madnight> *words; *things;
04:18:51 <madnight> merijin: so the advantage of Haskell is that the type system is "less" broken than Javas, because bottom in Haskell does not occur as frequently as null in Java?
04:19:47 <Logio> madnight: you should note that java still has bottom as well
04:19:50 <dataN> managed to get a very general abstraction over zippers to compile; https://gist.github.com/dataN-hs/e0a154cd485d34d8a1c0c35dc49bebd2
04:19:53 <dminuoso> madnight: bottom and null are not quite related
04:20:14 <merijn> madnight: That, and purity, and ADTs being super convenient and powerful, immutability making reasoning much easier
04:20:47 <dminuoso> The interesting thing about Haskell is not IO, because that's the *default* of other languages. It's that you can do things _without_ IO in Haskell that is special.
04:21:22 <Axman6> void foo() { while (true); return;] Bottom in Java
04:21:24 <madnight> merjin: but i can always replace bottom in my equational reasonings right? : )
04:21:40 <dataN> the relevant type is on line 181. 
04:24:06 <dminuoso> madnight: what do you mean by replace?
04:24:16 <dataN> it basically says, if there exists a state function over a pairs first element, which returns values which can act on the second ellement, and visa versa, then the zipper can be navigated backwards and forwards as in a partially suspended traversal.
04:24:48 <madnight> i can formulate it even more general: there a "things" in Java and in Haskell that fundamental break the type system in a common mathematical sense, but Haskell breaks it safer
04:25:39 <dataN> the function 'forwards' on line 92 is also helpful to understand the approach. 
04:27:19 <dminuoso> madnight: what do you mean by "break the type system"
04:27:35 <phadej> it would be really bad if "type system is broken"
04:27:43 * hackage appendmap 0.1.3 - Map with a Semigroup and Monoid instances delegating to Semigroup of the elements  http://hackage.haskell.org/package/appendmap-0.1.3 (AlexeyKotlyarov)
04:29:00 <dminuoso> madnight: Type systems, at their core, are ways of proving the absence of certain behaviors.
04:29:06 <dminuoso> madnight: What behaviors they are completely depend on some things.
04:29:28 <dminuoso> madnight: Java's type system, amongst a few others, guarantees seg faults can't exist.
04:29:46 <dminuoso> From that perspective it's complete and unbreakable.
04:30:48 <dminuoso> madnight: It's really important to consider the model of your type system to know what the type system attempts to guarantee.
04:32:01 --- mode: glguy set +v Richard[m]
04:32:25 <madnight> dminuoso: but what kind of guarantees do i have, e.g. in view of unsafePerformIO
04:32:43 <dminuoso> madnight: unsafePerformIO is a primtive introduced by GHC. 
04:33:07 <dminuoso> It's not part of the language specification. If you use language extensions/compiler intrinsics all bets are off.
04:33:36 <Taneb> dminuoso: language extensions generally try to be consistent, and if they're not it's normally considered a bug
04:33:40 <dminuoso> madnight: plenty of extensions however are accompanied by rigorous proofs that they behave well wrt to the type system
04:34:04 <madnight> dminuoso: so Haskell2010 in itself is fine, but ghc implement is rigged?
04:34:18 <madnight> *implementation
04:34:35 <Ariakenom_> I've heard java has undefined behaviour in some corner? but im off topic
04:35:04 <dminuoso> madnight: Im not deeply familiar with the type system of Haskell, so I can't tell you much about it's model.
04:35:55 <phadej> Java has downcasts, i.e. unsafeCoerce
04:35:58 <phadej> i.e. you can break it too
04:36:13 <phadej> it's a pragmatic thing to have
04:36:17 <dminuoso> phadej: is that part of the language specification, or some oracle primitive?
04:37:11 <phadej> dminuoso: downcasts? I think it's in a spec, it's rarely needed, but when it is, it's essential
04:37:29 <dminuoso> Ah cool I was not aware of this :)
04:37:35 <hpc> it was needed very frequently pre-generics
04:37:43 <hpc> and iirc still kinda needed when you're using arrays?
04:37:43 <quchen> In practice, the main difference is that in Java you use unsafe things all the time everywhere, whereas in Haskell the handful of unsafe primitives are highly specialized, and rarely used.
04:38:13 <dminuoso> madnight: I think some of the things Haskells type system tries to guarantee is: type inference (outside of special situations like polymorphic recursion) and absense of segmentation faults
04:38:28 <dminuoso> madnight: and not just type inference, but HM-style type inference
04:38:33 <quchen> Using unsafeCoerce in Haskell outside of hacky exercises is *very* rare.
04:38:34 <Axman6> null is encouraged in every day Java, but bottom is strongly discouraged in Haskell
04:38:57 <madnight> so maybe what it comes down to is that Haskellers (due to their mindset) generally write safer code than other Programmers, but the the compiler (ghc) allows the same "convenience things" that other languages allow (sometimes with tricks)
04:39:19 <phadej> hmm, I used unsafeCoerce last week. I feel very bad about it.
04:39:42 <Axman6> was it in a way which would be guaranteed to be safe?
04:40:22 <quchen> madnight: It’s more like Haskell programs tend to break unpredictably when using unsafe functions light-heartedly. You absolutely cannot use unsafePerformIO in a safe way as a beginner. In Java, you can maneuver your way around null from day one.
04:40:24 <phadej> Axman6: "yes". I did what `reflection` does, but for my type-class
04:40:42 <phadej> so if GHC changes, I will notice :)
04:40:52 <Axman6> you hope
04:40:54 <Axman6> :)
04:41:26 <phadej> I do build acme-kmett with GHC-to-be-released periodically
04:41:29 <phadej> so does Ryan
04:41:47 <quchen> Hah what’s that – a package installing the kmettiverse?
04:41:51 <phadej> it's not automated and fool-proof proccess, but at least it's somewhat redundand
04:42:09 <madnight> quchen: that's true, but many beginners including me used to use the "head" function in one of their first excersises and it crashed
04:42:13 <phadej> quchen: https://github.com/phadej/acme-kmett
04:42:28 <madnight> quchen: without anything evil in mind
04:42:48 <phadej> madnight: so you can throw exception in Java. Not different
04:42:58 <phadej> and head is bad, I agree.
04:43:00 <Axman6> madnight: all good introductory exercises will tell you to use pattern matching when dealing with lists, very few will mention head or tail because they shouldn't be used
04:43:00 <quchen> The difference is that in Haskell it’s tricky to catch.
04:43:10 <madnight> for me that is indeed similar to crashes in java e.g. due to out of bounds
04:43:37 <Axman6> the inclusion of partial functions in the Prelude is pretty widely regarded as a mistake afaict
04:43:46 <quchen> Partial functions in Haskell (functions that crash on some inputs) are unfortunate, but here to stay for historical reasons. :-(
04:43:58 <Ariakenom_> Axman6: I'll keep my / tyvm :)
04:44:11 <quchen> madnight: The difference to Java is that there is a strictly better way of handling lists, namely pattern matching.
04:44:19 <Axman6> > 1/0 -- This isn't partial
04:44:21 <lambdabot>  Infinity
04:44:34 <madnight> Axman6: but that's the point, you can write safe Haskell, but you need to force yourself to do so, e.g. don't use head
04:44:36 <Axman6> > 0/0 -- Nor this
04:44:38 <lambdabot>  NaN
04:44:46 <Taneb> > 1`div`0 -- this is
04:44:48 <lambdabot>  *Exception: divide by zero
04:45:28 <Axman6> madnight: most commonly this is done by people using partial functions in the prelude though
04:45:37 <madnight> and i can also write safe code in other languages if i force myself to do so
04:45:41 <Ariakenom_> fine yes div. I'll just consider any Float an error out of spite
04:45:43 <Axman6> one day we might remove them, but who inows when it could happen
04:46:18 <Taneb> > 1 / 0 :: Rational -- I think this partial
04:46:19 <lambdabot>  *Exception: Ratio has zero denominator
04:46:30 <madnight> the difference is that Haskell requires less cognitive force to write safer code than other languages, but both allow you to write unsafe code
04:46:44 <Ariakenom_> > sum [0..] -- partial
04:46:50 <lambdabot>  mueval-core: Time limit exceeded
04:47:23 <badzergling_> @pl \f k (x, y) -> (x,) <$> f k y
04:47:23 <lambdabot> (line 1, column 18):
04:47:23 <lambdabot> unexpected ","
04:47:23 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
04:47:24 <quchen> madnight: I’d say the defaults are different. In Haskell, with some (but not much) experience, it’s the default to write safe code, and unsafe code is explicitly so. In Java, it’s just the other way round.
04:47:43 <badzergling_> @pl \f k (x, y) -> (\y' -> (x, y)) <$> f k y
04:47:44 <lambdabot> flip flip snd . (ap .) . flip flip fst . (((.) . flip (ap . (((<$>) . const) .) . (,))) .)
04:47:48 <Ariakenom_> it's the famous zergling
04:47:56 <Axman6> madnight: you might like to read http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.1337&rep=rep1&type=pdf
04:48:00 <quchen> Ariakenom_: Depends on the type of 0 – lazy nats would work here for example :-)
04:48:10 <badzergling_> im famous?
04:48:12 <Digit> heh, unintended nickping brought me back to chan to see this unsent line:  reminder to self, sort xmonad keybinds to escape window from tab in directions
04:48:44 <Ariakenom_> badzergling_: joke from yesterdays stream I think. I didn't quite catch it tbh, just joined
04:48:58 <dataN> line 198 says; going forwards - Get a value from a the snd list, partially apply cons to it, and cons it to the fst list, where 'a' and '[a]->[a]' are the intermediate types. going backwards - Get a value from the fst list, and apply it to the snd list, where '[a]->]a
04:49:22 <dataN> where '[a] -> [a]' is the intermediate type
04:49:25 <badzergling_> first time i actually managed to notice that it was sunday afternoon in time to actually catch a kmett stream
04:49:28 <Axman6> dataN: I don't understand what's going on, but it looks like it would make good blog post material :)
04:49:39 <dataN> thanks!
04:49:58 <Axman6> also I assume you've seen the Lens zipper stuff?
04:50:12 <dataN> which? 
04:50:28 <Taneb> http://hackage.haskell.org/package/zippers-0.2.5/docs/Control-Zipper.html I presume
04:50:37 <dataN> your looking at; https://gist.github.com/dataN-hs/e0a154cd485d34d8a1c0c35dc49bebd2 ?
04:50:38 <Axman6> yeah
04:50:46 <dataN> awesome 
04:51:04 <madnight> Axman6: i agree that fast and loose reasoning is morally correctly
04:51:23 <c_wraith> omg, I'm blind. I kept wonder how Data.Data managed all it's type introspection with the types it uses. I just finally noticed it's a subclass of Typeable. so blind...
04:51:37 <dataN> Taneb: that only looks 2d...
04:52:16 <srhb> Athas: Any plans to publish futhark on Hackage?
04:52:52 <madnight> maybe what i would like to have is an absolute saftey guarantee for parts of my programms, and that is what Haskell cannot offer since it (ghc) allows Shevinegans
04:53:41 <madnight> *shenanigans
04:54:08 <Axman6> maybe have a look at Idris
04:54:09 <hpc> madnight: take a look at the Safe language extension
04:54:15 <Axman6> also that
04:54:16 <Athas> srhb: maybe.  Would that be useful?
04:54:17 <hpc> or idris which adds dependent typing
04:54:24 <hpc> or something that isn't even turing-complete at all
04:54:33 <Athas> It's currently an end-user application, although maybe I can factor out a useful language-futhark package for writing tools.
04:54:42 <dataN> aka; let f = Zipper (Free (Zipper [])) in f a, as opposed to Zipper (Free f) a, or let g = Zipper (Free (Zipper g)) in g a
04:54:44 <srhb> Athas: I'm asking because infinisil just packaged it manually for nixpkgs, but if it were on Hackage it would just have appeared with no work needed (except for maybe a few fixups)
04:54:53 <srhb> Athas: I imagine the same goes for some other distribution systems :)
04:55:10 <dataN> one too many Zippers^ *
04:55:16 <madnight> is there a good interoop e.g. between Haskell and coq?
04:55:45 <Athas> srhb: does Cabal have a way of dealing with manpages nowadays?  Otherwise it will still require some manual(!) work.
04:55:53 <hpc> heh
04:55:57 <srhb> Athas: Good question, I actually don't know that. :)
04:56:00 <Athas> I once wrote a Cabal package that used a custom Setup.hs to compile and install manpages, but that was very gross.
04:56:25 <srhb> But we have a pretty good story for "fixing up" a haskell package that is mostly auto generated
04:56:47 <hpc> does haddock have a manpage formatter of some kind?
04:56:49 <hpc> or pandoc?
04:56:57 <srhb> Athas: I'll throw an issue at the tracker and you consider whether it's worth it. :)
04:57:07 <Athas> Yes, do that.  I'll probably take a swing at it.
04:57:28 <Athas> It's been many a year since I put something on Hackage, but I don't recall it being too onerous.
04:57:39 <srhb> Nah, it's pretty okay :)
04:58:11 <hpc> i only wish hackage knew more ways for a package to be bad
04:58:16 <hpc> (and cabal)
04:58:22 <hpc> they'll catch some mistakes, but not all
04:58:48 <Athas> Doesn't Hackage require PVP these days?
04:58:58 <dataN> Axman6: whats the advantage of using that over the far simpler; Applicative g => (a -> g b) -> (([g (Maybe (f a) -> f a)],Maybe (f a)) -> Maybe ([],))
04:58:59 <madnight> hpc: in Arch Linux (AUR) users can simply flag packages
04:59:11 <madnight> Athas: nope i use semver
04:59:19 <Athas> Good!
04:59:21 <dataN> Axman6: whats the advantage of using that over the far simpler; 
04:59:21 <dataN> Applicative g => (a -> g b) -> (([g (Maybe (f b) -> f b)],Maybe (f a)) -> Maybe (([g (Maybe (f b) -> f b)],Maybe (f a))
04:59:37 <Taneb> Athas: they recommend it but don't require it
04:59:41 <lavalike> that's what I call a simple type
05:00:07 <dataN> lavalike; compared to; http://hackage.haskell.org/package/zippers-0.2.5/docs/src/Control-Zipper-Internal.html#Zipper
05:00:48 <dataN> its totally self explanatory, and clearly resembles a suspended traversal, and is less than one line long.  
05:02:32 <hvr> Athas: well, you're expected too, unless you have technical reasons not to
05:03:18 <Athas> hvr: my program is not primarily a Haskell library, and its intended users are not necessarily Haskell programmers.  Probably they have never heard of PVP before.
05:03:28 <Athas> So I use SemVer, which is somewhat more common.
05:03:31 <infinisil> Athas: srhb: :D
05:03:36 <hvr> Athas: not on hackage
05:03:54 <Athas> No, but I can't really use a different versioning scheme on Hackage than I do everywhere else.
05:03:57 <hvr> Athas: see https://pvp.haskell.org/faq/
05:04:27 <jhrcek> When I paste a String with german umlauts into GHCI "ÄÜÖäüö" it prints "\196\220\214\228\252\246". What do these numbers mean? Are the chars encoded using some encoding or something?
05:06:04 <Maxdamantus> jhrcek: they're the decimal representations of the unicode code points.
05:06:48 <Maxdamantus> \196 = U+C4 = 'Ä'
05:08:30 <Maxdamantus> (in these cases, they also happen to be the corresponding codes in ISO/IEC 8859-1, but if your system is set up correctly the corres
05:08:41 <Maxdamantus> -pondences shouldn't stothere)
05:08:47 <Maxdamantus> stop there*
05:09:06 <jhrcek> Maxdamantus: so can I say that Haskell Strings use UTF-8 to represent unicode chars?
05:09:18 <Maxdamantus> jhrcek: no.
05:09:45 <hpc> that number isn't the representation of the char, it's its unicode codepoint
05:09:55 <Maxdamantus> jhrcek: Haskell Strings use numbers which normally correspond to unicode code points.
05:10:47 <Maxdamantus> jhrcek: if it used UTF-8, you would expect to see the 8-bit code units that make up a UTF-8 sequence somewhere.
05:11:51 <dmwit> ?tell fragamus https://gist.github.com/dmwit/88c2c9806191075b32b491864efaafc9 main differences: \db and \de to add/remove import Debug.Trace, and the view doesn't jump by 2-3 lines when doing \l<whatever>, \db, or \de like in the old version
05:11:51 <lambdabot> Consider it noted.
05:11:56 <Maxdamantus> > '∀'
05:11:58 <lambdabot>  '\8704'
05:12:15 <Maxdamantus> 8704 doesn't fit into an 8-bit code unit.
05:12:22 <phadej> so what
05:12:30 <phadej> Char is unicode codepoint
05:13:02 <Maxdamantus> It's a number that is normally used to represent a unicode code point.
05:13:03 <Axman6> Unicode is a complex beast. Unicode is not utf-8, it not utf-16, nor utf-32, the latter three are encodings of unicode, and all represent almost all of unicode (but have some quirks)
05:13:11 <dmwit> phadej: That's exactly the point Maxdamantus is trying to make. =)
05:13:16 <Maxdamantus> (it's also specifically bounded for that purpose)
05:13:39 <hpc> perhaps turn this around a bit, jhrcek: how would you tell what encoding of unicode a char is using?
05:13:56 <phadej> dmwit: ah, I lost context
05:14:34 <hpc> Axman6: almost all? now you have me curious
05:15:12 <phadej> so to say, String doesn't use any encoding - it doesn't have backing "bytestring/stream/array" 
05:15:23 <Maxdamantus> If the encodings are well-formed, they should be equivalent in representability.
05:15:27 <jhrcek> Unicode ~ assigns code points (like a number in sequence) to characters. Encoding: how the code points is represented by bits (8 bits in some encoding, 16 in others). What I don't get is the relationship between what I see printed out (show "some string umlauts") and encoding.
05:15:31 <dmwit> hpc: By poking in memory, I can see that GHC currently uses UTF-32. ;-)
05:15:39 <hpc> haha
05:15:59 <hpc> jhrcek: there is no relationship at all
05:16:06 <Axman6> I'm a bit rusty, but aren't some codepoints (specifically surrogates... are they codepoints? <- rustiness) not valid in utf-8
05:16:07 <hpc> jhrcek: you're seeing the codepoint
05:16:08 <Maxdamantus> since things like UTF-16 surrogates are not allowed to be represented as code points in UTF-8.
05:16:36 <hpc> Maxdamantus: surrogates aren't part of unicode though, are they?
05:16:46 <jhrcek> And what determined that some chars shown as 'a' and some as '\256'?
05:16:52 <dmwit> jhrcek: `show` takes a `String`, and produces a `String` that only has characters available in ASCII (!).
05:17:00 <Maxdamantus> They're still classed as code points, but they're "reserved" or something, and they can't be represented by well-formed UTF-8/UTF-32 strings.
05:17:03 <hpc> jhrcek: the Show instance for Char determines it
05:17:19 <hpc> jhrcek: printable ascii is printed as-is, all other codepoints are escaped iirc
05:17:26 <dmwit> jhrcek: Then, printing this String to screen uses whatever encoding is currently set by your locale, or can be overrided by special operations in `base` if you choose.
05:17:55 <Maxdamantus> So that means something like "\55296" is not a well-formed UTF-32 encoding.
05:17:56 <hpc> jhrcek: if you were to putStrLn it instead, it'd go through a bunch of encoding and file handle stuff
05:18:24 <hpc> jhrcek: and probably end up being actually outputted in whatever encoding stdout says it has
05:18:31 <Axman6> jhrcek: you'll see that if you use putStrLn on a string with non-ascii characters, like those you pasted, it gets printed, but printing using print will escape characters (I can't remember what determines if i character will be escaped)
05:18:35 <hpc> but that's a whole other operation
05:19:06 <Axman6> jhrcek: handling text properly is _hard_, and worth learning how to do properly
05:20:00 <jhrcek> hps, dmwit: thanks, I think I got it. Axman6 any resources you'd recommend?
05:20:00 <Axman6> From the wikipedia page, an example of how difficult these things can be: "For example, é can be represented in Unicode as U+0065 (LATIN SMALL LETTER E) followed by U+0301 (COMBINING ACUTE ACCENT), but it can also be represented as the precomposed character U+00E9 (LATIN SMALL LETTER E WITH ACUTE). Thus, in many cases, users have multiple ways of encoding the same character. "
05:20:56 <Axman6> http://www.unexpected-vortices.com/misc-notes/text-unicode/terminology.html is a useful place to start. IIRC the Data.Text haddocks have some useful info, and more can be found in other modules
05:22:51 * Axman6 was wrong about surrogates earlier
05:24:52 <Maxdamantus> That's one of the reasons I wouldn't described something like `Char` in Haskell as relating to UTF-32.
05:25:39 <Axman6> yeah it doesn't really, it represents a single code point (IIRC?)
05:25:47 <Maxdamantus> The relationship between `String` and UTF-32 is kind of like the relationship between `ByteString` and UTF-8.
05:26:00 <Axman6> which means you can stull have multiple Chars per grapheme
05:26:08 <Axman6> yeah
05:26:29 <Maxdamantus> You can use the former as a sequence of UTF-32 code units and the latter as a sequence of UTF-8 code units.
05:26:44 <Maxdamantus> but you need further constraints in either case to make sure the string is actually well-formed UTF-32/UTF-8.
05:26:57 <Axman6> Is there a library which handles String "correctly"? things like reversing the string paying attention to whether combining characters follow a character
05:27:03 <Axman6> handling case properly
05:27:15 <Axman6> (text-icu does a lot of this IIRC but not directly on String)
05:27:41 <Maxdamantus> Dunno. I've always seen those sorts of operations as inherently dodgy.
05:27:53 <Maxdamantus> Since they rely on conventions, or "locales" or something.
05:28:17 <Axman6> text is hard
05:30:39 <Maxdamantus> also, in the case of combining characters, that changes depending on the unicode standard.
05:31:23 <Maxdamantus> which is why HFS+'s filename normalisation specifically abides by Unicode 4 rules or something.
05:32:08 <Maxdamantus> because it would be even crazier to have the filesystem semantics change based on the version of Unicode used by the kernel or something.
05:32:21 <ab9rf> i got into a screeching argument with some app developer over whether file systems should be case-sensitive
05:32:36 <Maxdamantus> The answer is: yes, they should be.
05:32:44 <ab9rf> that was my position
05:33:12 <ab9rf> if that yields a less than desirable user experience, fix the interface between the file system and the user. don't break the file system.
05:33:14 <Maxdamantus> They should just work based on bytestring comparisons.
05:33:36 <ab9rf> yup. don't shove representational folding into the filesystem.
05:33:53 <Maxdamantus> It's slightly unfortunate that '\0', '/' and some cases of '.' are treated specially, but, meh, I can live with that.
05:34:16 <madnight> how many % of packages on hackage are fully Haskell2010 conform (would run without any ghc additions)? (best guess)
05:35:02 <ab9rf> max '.' isn't special
05:35:19 <Maxdamantus> ab9rf: Linux treats it as special, in some cases.
05:35:25 <ab9rf> Maxdamantus: when? 
05:35:43 <Maxdamantus> ab9rf: when the part between '/' delimiters is "." or ".."
05:35:48 <ab9rf> Maxdamantus: it shouldn't
05:35:58 <Maxdamantus> Right, but .. it does.
05:36:00 <ab9rf> Maxdamantus: those entries actually exist in each folder
05:36:15 <yushyin> madnight: even base uses ghc extensions and _most_ packages need base? So about 0-5% maybe :P
05:36:15 <ab9rf> it should just traverse through them
05:36:31 <Maxdamantus> .. can refer to a different filesystem.
05:37:11 <ab9rf> that's not treating . specially, it's treating the name ".." specially
05:37:16 <Maxdamantus> anyway, regardless of what level the specialisation happens at, they're special, since I can't make a file called "." or ".."
05:37:20 <Maxdamantus> or "\0foo"
05:37:32 <Maxdamantus> or "/foo/bar//baz"
05:37:53 <ab9rf> anyhoo
05:38:28 <Maxdamantus> I can make a file whose name is any sequence of bytes, as long as that sequence doesn't contain '/', '\0', or '.' under some circumstances
05:39:19 <madnight> yushyin: ok i'll wonder because sometimes people's argument is "let's don't do that ... otherwise ghc would be the de facto only compiler for Haskell", but it seems as though that this is already the case
05:43:48 <yushyin> madnight: of course other compilers could provide a base without the use of some extensions or just also implement some ^^
05:51:14 --- mode: glguy set +v cies
05:58:00 <quchen> As far as I know, only »/« and »\0« are forbidden in Unix filenames
05:58:38 --- mode: glguy set +v Fobbbbbb
05:58:41 <quchen> …reminds me of the interview question about how to delete a file called »-rf *«
05:58:45 <peutri> but it's always confusing whether those should be considered as characters, or bytes in the stream
05:59:11 <Maxdamantus> You also can't have a normal file called "." or "..", which is why '.' is semi-special.
05:59:33 <peutri> is it really? i thought you couldn't only because one already existed
05:59:53 <Maxdamantus> Well, you can't normally remove them.
06:00:12 <peutri> good point
06:00:21 <peutri> let me mess up my fs again exploring the limits of this
06:00:37 <Maxdamantus> Though you could then argue that the reason you can't remove them is simply because they're non-empty directories.
06:00:45 <peutri> or still active
06:00:53 <Maxdamantus> in any case, they're "special" in some way.
06:01:20 <Maxdamantus> because filesystems don't randomly create a file called "up" that links to itself, preventing you from using the name "up".
06:04:08 <cies> Question. Say I have a group of sum types with no constructors that take a value, like "data Bool = True | False" and "data T = A | B | C" and I want to get the constructors as a list (eg. [True, False] and  [A, B, C]) or a set or something because i want to check somewhere that all possiblities are covered. Is this possible? Or am I overlooking smth
06:04:58 <peutri> deriving Enum can get pretty close, no?
06:05:26 <liste> @let data T = A | B | C deriving (Enum, Bounded)
06:05:27 <lambdabot>  Defined.
06:05:36 <liste> > [minBound..maxBound]:: T
06:05:38 <lambdabot>  error:
06:05:38 <lambdabot>      • Couldn't match expected type ‘T’ with actual type ‘[a0]’
06:05:38 <lambdabot>      • In the expression: [minBound .. maxBound] :: T
06:05:46 <liste> > [minBound..maxBound]:: [T]
06:05:47 <lambdabot>  error:
06:05:47 <lambdabot>      • No instance for (Show T)
06:05:47 <lambdabot>          arising from a use of ‘show_M855145754237577132914166’
06:05:51 <cies> liste: thanks. did not consider that
06:05:56 <cies> will have a look
06:06:02 * liste always forgets Show :)
06:06:35 <liste> yw
06:07:09 <liste> > length [minBound :: T..]
06:07:12 <lambdabot>  error:
06:07:12 <lambdabot>      Not in scope: type constructor or class ‘T..’
06:07:12 <lambdabot>      No module named ‘T’ is imported.error:
06:07:16 <liste> > length [minBound :: T ..]
06:07:18 <lambdabot>  3
06:07:36 <liste> that should be enough ↑
06:09:00 <liste> hmm, why is there no [..x] or [..]
06:09:19 <liste> @let data NonBounded = P | Q deriving (Enum, Show)
06:09:20 <lambdabot>  Defined.
06:09:28 <liste> > [P..Q]
06:09:30 <lambdabot>  error:
06:09:30 <lambdabot>      Not in scope: ‘P..’
06:09:30 <lambdabot>      Perhaps you meant ‘C..’ (imported from Control.Category)
06:09:43 <liste> @undefine
06:09:43 <lambdabot> Undefined.
06:09:55 <liste> @let data NonBounded = NonA | NonB deriving (Enum, Show)
06:09:57 <lambdabot>  Defined.
06:10:04 <liste> > [NonA .. NonB]
06:10:06 <lambdabot>  [NonA,NonB]
06:10:12 <liste> > [NonA .. ]
06:10:14 <lambdabot>  [NonA,NonB]
06:10:31 <liste> you could also do that if you know the first element
06:10:48 <liste> but I guess minBound is more robust
06:11:07 <liste> @src Enum
06:11:07 <lambdabot> class Enum a where
06:11:07 <lambdabot>     succ, pred               :: a -> a
06:11:07 <lambdabot>     toEnum                   :: Int -> a
06:11:07 <lambdabot>     fromEnum                 :: a -> Int
06:11:07 <lambdabot>     enumFrom                 :: a -> [a]
06:11:09 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
06:11:11 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
06:11:43 <liste> > [toEnum 0 ..] :: [NonBounded]
06:11:45 <lambdabot>  [NonA,NonB]
06:11:56 <liste> that feels kinda icky though
06:12:22 <Taneb> Fails for, say, Int8
06:12:35 <liste> yeah
06:12:36 <Taneb> > maximum [toEnum 0 ..] :: Int8
06:12:38 <lambdabot>  127
06:14:12 <liste> > maxBound :: Int8
06:14:14 <lambdabot>  127
06:15:12 <Taneb> > minimum [toEnum 0 ..] :: Int8
06:15:14 <lambdabot>  0
06:15:20 <liste> I guess [x..maxBound] can be different from [x..] ? 
06:15:21 <Taneb> (I know what I'm doing, honest)
06:15:45 <Taneb> liste: not for a law-abiding Enum instance, I think, where the Bounded instance exists
06:16:16 <ab9rf> an Enum instance is not obliged to be a Bounded instance, though?
06:17:41 <Taneb> No
06:17:43 <peutri> I'd have guessed not, but that bijection to Int is a bad smell
06:18:39 <c_wraith> Hmm.  why do a bunch of links to Typeable in base's haddocks link to the wrong Typeable?
06:19:05 <ab9rf> ah. that's right. Bounded isn't required to be totally ordered
06:19:17 <Taneb> c_wraith: there's a wrong Typeable?
06:20:29 <ab9rf> and it's possible to have an unbounded Enum class
06:20:32 <ab9rf> at least in theory
06:20:35 <c_wraith> Ah, I see.  It's the same class, re-exported, but with an entirely different surrounding API
06:20:41 <c_wraith> :t toEnum
06:20:42 <lambdabot> Enum a => Int -> a
06:20:47 <c_wraith> Int is bounded
06:20:53 <ab9rf> yeah. that's a smell./
06:21:41 <ab9rf> it ought to be Integer, but ...
06:22:07 <ab9rf> "It is implementation-dependent what fromEnum returns when applied to a value that is too large to fit in an Int."
06:22:09 <cies>  liste: another question, I do not have the T type around. I specify that some functions param is an Enum and Bounded, but now I do not know exactly which type (e.g. T) is the Type I'm working with
06:22:59 <ab9rf> the HaskelL Report specifies that Float and Double are Enum instances
06:23:02 <Boarders> I wa reading something that said in hindley milner with let expressions you can form the term: let x = \y . y in x x and it will correctly infer a polymorphic type scheme for x and then specialise to the correct types in the expression
06:23:10 <Boarders> Is there a reason haskell does not do the same thing?
06:23:48 <Taneb> :t let x = \y -> y in x x
06:23:49 <lambdabot> p -> p
06:23:57 <c_wraith> cies: that helps.  it means you aren't stuck with worrying about what the type means.  you just get to work with "I can create a minimum and maximum element, and I can get successors and predecessors"
06:24:18 <ab9rf> c_wraith: toEnum is not guaranteed to be bijective
06:24:57 <dmwit> Boarders: ...but it does do the same thing.
06:25:01 <c_wraith> :t [minBound ..] -- cies: see how it doesn't matter what type you have?
06:25:02 <dmwit> > let x = \y -> y in x x
06:25:02 <lambdabot> (Enum a, Bounded a) => [a]
06:25:04 <lambdabot>  error:
06:25:04 <lambdabot>      • No instance for (Typeable p0)
06:25:04 <lambdabot>          arising from a use of ‘show_M618108043292984156714788’
06:25:10 <dmwit> :t let x = \y -> y in x x
06:25:12 <lambdabot> p -> p
06:25:13 <dminuoso> Oh this was beautiful. I just taught the basic of "how does Yoneda work" to a beginner. It was a real charm. :)
06:25:24 <dmwit> Boarders: See? Works fine.
06:25:34 <Boarders> dmwit: oh, huh
06:25:34 <ab9rf> yoneda always makes me think of star trek
06:25:42 <Taneb> Boarders: Haskell has the Monomorphism Restriction, for efficiency reasons, which prevents this, but GHC can disable it and disables it by default for GHCi
06:25:46 <Taneb> (and lambdabot)
06:25:56 <Boarders> I just had a situation in my code where I had to specify the same line of code twice for it to compile
06:26:01 <dmwit> Taneb: Doesn't prevent this, because there's no classes here.
06:26:03 <c_wraith> Taneb: I don't think that even applies.  There's no class present.
06:26:30 <Boarders> But maybe that was an issue with typeclasses
06:26:39 <dmwit> Boarders: Time to ask your real question, then, instead of this surrogate. =)
06:26:52 <ab9rf> gege
06:27:31 <Boarders> :)
06:31:32 <madnight> bartosz heavily teasers and postpones the introduction of the yonneda lemma, hope i will grok it when he finally gets to it (feels a bit like the late monad introduction in real world haskell)
06:37:44 <dminuoso> madnight: Yoneda is just a way of ensuring fusion on fmap.
06:38:01 <dmwit> cies: What is the type of the function you want to write?
06:38:22 <dmwit> /what should it do?
06:39:01 <dminuoso> Well on Coyoneda anyway. :)
06:39:30 <cies> dmwit: I want a fucntion that returns the [minBound..] for the type of the only argument I pass it
06:39:41 <cies> dmwit: is that understandible?
06:40:13 * hackage http-conduit-downloader 1.0.31 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.31 (VladimirShabanov)
06:40:32 <liste> cies: the ::T was only because I didn't have a type signature at all
06:40:44 <cies> dmwit: allCtors :: (Show a, Enum a, Bounded a) => a -> [a]
06:41:31 <liste> cies: if you have a type signature, [minBound..] should be enough
06:41:42 * hackage xmonad 0.14.1 - A tiling window manager  http://hackage.haskell.org/package/xmonad-0.14.1 (PeterSimons)
06:41:43 <cies> allCtors p = [minBound..] :: ``type of p``
06:41:52 <madnight> dminuoso: i try to follow Bartosz explain first and if i have some questions i'll come back to ask u : )
06:42:09 <dmwit> cies: Sure, `allCtors p = [minBound..]` already works just fine.
06:42:26 <dminuoso> madnight: The thing is, Bartosz explains the CT side of things.
06:42:34 <dmwit> cies: You do not need to (and can't, in standard Haskell2010) give an additional type signature inside the implementation.
06:42:35 <cies> sorry my lack
06:42:45 <cies> lemme try
06:42:47 <cies> thanks again
06:42:54 <dminuoso> madnight: Its not very helpful to learn the practical side of things. For a user Yoneda/Coyoneda give you guaranteed fusion of fmap for functors.
06:43:32 <dminuoso> or to rephrase: It's just Functor - but with a different (equivalent) representation that allows for fusion to happen.
06:43:34 <dmwit> cies: You can ```allCtors p = [minBound..] `asTypeOf` [p]``` if you want Haskell2010, or turn on ScopedTypeVariables and write `allCtors :: forall a. (Bounded a, Enum a) => a -> [a]; allCtors _ = [minBound..] :: a` if you're okay with extensions.
06:44:00 <dmwit> cies: If you go the latter route, I recommend not even taking `p` as an argument.
06:44:19 <dmwit> cies: You may also like the `universe` package, which gives enumerations of many non-`Enum` types.
06:44:22 <dmwit> ?hackage universe
06:44:22 <lambdabot> http://hackage.haskell.org/package/universe
06:46:14 <madnight> dminuoso: well but actually i'm more interested in the ct view point than it's application in hask, for me hask is only one small instance (and not my focus)
06:47:10 <dminuoso> madnight: By all means then.
07:10:35 <Ariakenom_> Hey. I'm looking into making a Haskell presentation to non-Haskellers. Do you have any approachable talks you like or things that could interest JS/Python/Java/C folk?
07:11:37 <phadej> hmm, SPJ asked thata on some mailing lisT (haskell-cafe?) not so long ago
07:12:08 <Ariakenom_> oh interesting
07:12:10 <phadej> Ariakenom_: https://mail.haskell.org/pipermail/haskell-cafe/2018-July/129443.html
07:12:43 <phadej> there're plenty of responses, you might find something there
07:12:52 <Ariakenom_> phadej: That seems great! thanks a lot
07:13:05 <phadej> cheers
07:13:13 <Boarders> ariakenom: not sure this is actionable exactly but I love this talk: https://www.youtube.com/watch?v=0oo8wIi2qBE
07:17:44 <Ariakenom_> "I would introduce type inference" so obvious in hindsight :p. those are the best ideas
07:18:10 <Ariakenom_> thanks Boarders I'll have a look later. typed holes were mentioned some here as well
07:27:39 <araadkins> I'm having an issue where each module in a stack package is annotated with either `{-# LANGUAGE Strict #
07:28:32 <araadkins> I'm having an issue where every module in a stack package is annotated with either `{-# LANGUAGE Strict #-}` or `{-# LANGUAGE NoStrict #-}` and then adding `Strict` to the list of `default-extensions` will suddenly stop things working.
07:28:42 <araadkins> Anybody seen something like that before?
07:29:00 <cocreature> araadkins: what do you mean by “will suddenly stop things working”? what exactly happens?
07:29:12 <araadkins> cocreature: A previously terminating computation hangs
07:29:30 <araadkins> cocreature: Surely if every file is annotated the addition to the default-extensions list is a no-op?
07:32:00 <cocreature> sounds like cli flags take precedence over LANGUAGE pragmas
07:32:13 <cocreature> not sure if that is expected, I never had a case where that would matter
07:33:18 <araadkins> cocreature: That doesn't appear to be the case elsewhere in the codebase however. Other packages are primarily strict with NoStrict annotations and that seems to work.
07:34:05 <cocreature> araadkins: are you sure that in those case it actually matters whether you compile with -XStrict or not?
07:34:40 <araadkins> cocreature: Positive. Enabling Strict for this one package causes the hang.
07:34:46 <cocreature> for -XSafe the user guide mentions explicitely that cli flags take precedence so I would expect that this applies everywhere https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe_haskell.html#safe-compilation
07:35:03 <cocreature> sure for this one package but you were talking about other packages that appear to work!
07:35:36 <araadkins> cocreature: Curious. Perhaps the parts of the codebase marked NoStrict are actually safe.
07:35:41 <araadkins> I need to investigate more.
07:43:33 <araadkins> cocreature: That was it. Thank you. Not sure why I assumed that LANGUAGE pragmas superseded command-line flags. 
07:45:15 <Franciman> Hi I'm using hsqml. I have this code: https://lpaste.net/5675125109237481472 and I get this error: https://lpaste.net/7495801787991982080
07:45:18 <Franciman> I don't understand why
07:45:34 <Franciman> in the examples I can return Text without any issue
07:45:41 <Franciman> why doesn't it work here?
07:46:42 <Franciman> <Franciman> in the examples I can return Text without any issue <- I mean in e.g. https://hackage.haskell.org/package/hsqml-demo-samples-0.3.4.0/src/src/Factorial1.hs here
07:46:56 <Franciman> this code returns Text values and it works
07:48:38 <cocreature> Franciman: what is the type of "category"?
07:48:46 <Franciman> Text
07:48:56 <Franciman> line 9
07:48:59 <cocreature> that doesn’t make sense, it needs to have some function type
07:49:04 <cocreature> ah I see
07:49:05 <Franciman> oh well
07:49:14 <Franciman> actually it's Article -> Text
07:49:15 <Franciman> sorry
07:50:00 <cocreature> it looks like defPropertyRO' expects that "tr" is an instance of Marshal but Text is not an instance of Marshal
07:50:27 <Franciman> but here: https://hackage.haskell.org/package/hsqml-demo-samples-0.3.4.0/src/src/Factorial1.hs
07:50:29 <Franciman> it works
07:50:30 <Franciman> damn
07:50:52 <cocreature> that doesn’t use defPropertyR0'
07:50:56 <Franciman> https://hackage.haskell.org/package/hsqml-demo-samples-0.3.4.0/src/src/Factorial2.hs
07:51:01 <Franciman> here it does
07:51:20 <Franciman> i creates an IORef Text
07:51:25 <Franciman> and then returns its content
07:53:11 <Franciman> there must be a difference, but I don't catch it
07:53:14 <cocreature> ah sry, it looks like it is an instance of Marshal. haddock was just stupid
07:55:13 <Franciman> ah maybe I don't import the instance?
07:55:35 <Franciman> that was it
07:55:36 <Franciman> damn!
07:55:39 <Franciman> thanks cocreature 
07:55:53 <cocreature> ah :)
07:55:58 <cocreature> orphan instances :(
07:56:34 <cocreature> it doesn’t even make sense to use an orphan instance for this
07:56:42 <cocreature> the typeclass is declared in the same package
07:57:20 <Franciman> indeed
07:58:22 <cocreature> might be worth opening an issue for
07:58:33 <cocreature> seems like it’s mostly just making life harder for users without any reason
08:00:19 --- mode: glguy set +v biglama
08:01:25 <Franciman> well, thanks again, cocreature 
08:02:00 <Franciman> I'm not sure I really know about how typeclass instance retrieving works
08:02:12 <Franciman> maybe I missed including the module containing the typeclass
08:02:39 <Franciman> did you see it's an orphan instance or was it a guess?
08:03:12 --- mode: glguy set -v biglama
08:03:24 <biglama> hi guys, I would like to generate PDF output from markdown using Hakyll. I thought of modifying a custom Writer with pandocCompiler but there is no option for pdf output (http://hackage.haskell.org/package/pandoc-2.2.3.2/docs/Text-Pandoc-Options.html)
08:03:34 <cocreature> Franciman: I checked: the typeclass is declared in Graphics.QML.Internal.Marshal and the instance is declared in Graphics.QML.Marshal
08:03:53 <cocreature> just declaring the instance also in the internal module should make it impossible to not import it
08:04:24 <ChaiTRex> Should typeclass functions be marked INLINE at the class definition or the instance definition?
08:05:06 <glguy> Instance
08:05:41 <ChaiTRex> glguy: Thanks.
08:05:54 <Franciman> I see
08:19:02 <hexagoxel> biglama: i think the pdf generation always happens via latex. and there is `writeLaTeX`
08:23:13 * hackage shellwords 0.1.2.1 - Parse strings into words, like a shell would  http://hackage.haskell.org/package/shellwords-0.1.2.1 (PatrickBrisbin)
08:24:19 <biglama> hexagoxel: I'm struggling to generate latex with writeLatex, though. With a very simple latex template, I have HTML output instead of latex :(
08:24:22 <biglama> https://gist.github.com/alexDarcy/2722c78661903c690f404494d7863c62
08:24:50 <biglama> hexagoxel: If you have any clue, I would be glad :)
08:29:06 <biglama> (I can't get writeLaTex to compile at the moment)
08:32:44 <ChaiTRex> Is there a general way to lower something from type level to value level?
08:33:00 <ChaiTRex> I'm assuming there's not because of type variables.
08:33:13 <phadej> ChaiTRex: singletons
08:33:26 <ChaiTRex> phadej: Thanks. I'll look those up.
08:33:59 <phadej> self-plug: http://hackage.haskell.org/package/singleton-bool but it's almost hte simplest example one can have
08:35:01 <cocreature> for lowering from type to value-level you can often also use typeclasses
08:35:14 <cocreature> the other way around is the one that is difficult :)
08:36:16 <Boarders> nonsense question: what do the people who write agda call themselves?
08:36:33 <ChaiTRex> phadej: Ahh, that's much easier to understand. Thanks.
08:36:58 <dmwit> Boarders: I don't know about other folks but I call myself dmwit.
08:37:03 <phadej> :D
08:37:18 <Boarders> :)
08:37:19 <glguy> There's a whole channel for #agda
08:37:38 <phadej> I'm quite sure there're someone who call themselves "proof engineers"
08:37:39 <Boarders> yeah, I just felt dumb joining it and going "are you called agdists?"
08:38:13 <Franciman> they like to be called godel
08:38:30 * dmwit . o O ( "But what is their name called?" )
08:39:10 <biglama> hexagoxel: https://github.com/jaspervdj/jaspervdj/blob/master/src/Main.hs here is a solution (search for "writeXeTex")
08:40:58 <dmwit> Boarders: https://www.poemhunter.com/poem/alice-and-the-white-knight/
08:40:58 <hexagoxel> biglama: if you follow the source of `pandocCompiler`, you can see that it ends up calling `writeHtml5String`
08:41:47 <hexagoxel> but it seems you figured it out, great
08:42:28 <ChaiTRex> cocreature: Thanks. I'll think about how to do that.
08:43:43 <phadej> fwiw, singletons-pattern are "use typeclasses"
08:44:14 <ChaiTRex> Oh, OK.
08:54:43 * hackage language-puppet 1.3.20.1 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-1.3.20.1 (SimonMarechal)
08:56:55 <dmj`_> jle`: ping
09:09:22 <max3> anyone have any experience with https://eta-lang.org/
09:11:36 <dmj`_> @pl \x y -> (:) <$> x <*> y
09:11:36 <lambdabot> (((:) <$>) .) . (<*>)
09:19:31 <glguy> liftA2 (:)
09:32:13 * hackage hriemann 0.3.2.1 - A Riemann Client for Haskell  http://hackage.haskell.org/package/hriemann-0.3.2.1 (shmish111)
09:42:19 <inkbottle> When you look at that: https://github.com/diagrams/SVGFonts#example; how do you know the minimal, say, "stack --package" to include? ("SVGFonts" is a start but not enough)
09:43:32 <cocreature> inkbottle: type the module name into hoogle/hayoo and you should find the packages that contain the imports
09:43:47 <inkbottle> cocreature: OK, I try that
09:47:31 <inkbottle> cocreature: The following does not produce obvious results: https://www.haskell.org/hoogle/?hoogle=Diagrams.Prelude (still in the learning curve)
09:47:59 <cocreature> inkbottle: use the new hoogle instead https://hoogle.haskell.org/?hoogle=Diagrams.Prelude
09:48:07 <cocreature> it still doesn’t index all of hackage but at least all of stackage
09:48:35 <inkbottle> cocreature: Nice, thanks
09:49:13 <cocreature> hayoo should index all of hackage iirc and if you only care about module name -> package it’s probably more than sufficient
09:52:39 <dmj`_> anyone know off hand which version of base started exporting Semigroup from Prelude?
09:53:16 <lavalike> Since: base-4.9.0.0
09:53:25 <lavalike> https://www.stackage.org/haddock/lts-12.7/base-4.11.1.0/Prelude.html#g:9
09:56:55 <cocreature> lavalike: the since annotation belongs to the definition, it doesn’t tell you when it was reexported (and iirc in this case the two don’t correlate
09:56:57 <cocreature> )
09:57:31 <lavalike> cocreature: what a let down
09:58:03 <lavalike> gotta do binary search then I guess
09:58:23 <dmj`_> thanks lavalike 
09:58:42 <lavalike> dmj`_: apparently it's not the correct answer, see cocreature's message :/
10:00:07 <dmj`_> Ah, cocreature strikes again 😃
10:00:28 <cocreature> looks like 4.11 added the reexport
10:02:37 <lavalike> but I don't see it in 4.10
10:02:45 <lavalike> oh, right
10:03:46 <lavalike> unfortunate there isn't a Since: for it exactly
10:25:43 * hackage eternity 0.1.3 - Native event-sourcing database  http://hackage.haskell.org/package/eternity-0.1.3 (vlastachu)
10:30:16 * hackage hriemann 0.3.2.2 - A Riemann Client for Haskell  http://hackage.haskell.org/package/hriemann-0.3.2.2 (shmish111)
10:30:29 <portnov> hi all.
10:31:59 <lavalike> howdy
10:32:58 <portnov> Q: is there any chance to write universal function typeRepToType :: Data.Typeable.TypeRep -> Language.Haskell.TH.Type ?
10:33:08 <portnov> @hoogle Data.Typeable.TypeRep -> Language.Haskell.TH.Type
10:33:08 <lambdabot> Data.Typeable rnfTypeRep :: TypeRep -> ()
10:33:08 <lambdabot> Data.Typeable typeRepArgs :: TypeRep -> [TypeRep]
10:33:08 <lambdabot> Data.Typeable mkFunTy :: TypeRep -> TypeRep -> TypeRep
10:38:05 <Gurkenglas> http://hackage.haskell.org/package/base-4.11.1.0/docs/src/Data.Typeable.Internal.html#TypeRep http://hackage.haskell.org/package/template-haskell-2.13.0.0/docs/Language-Haskell-TH.html#t:Type looks like
10:39:34 <portnov> yes, they are similar, but TypeRep does not expose it's internals :/
10:40:06 <portnov> (and separate question is - why they are not exactly the same type ?...)
10:40:53 <Gurkenglas> portnov, wait doesnt TypeRep include type constructors like Maybe while Type doesn't?
10:41:38 <Gurkenglas> Oh, I think I misread that GADT constructor line, scratch my last line
10:50:23 <dmrd> Hey folks,  quick one. I'm reformatting a function from using `let in` to using `where`. However, I'm stumbling upon the following issue: it seems that variables binded (is that the right term) in a `do` block are somehow not available later in a `where` block. Here's a small snippet of it: https://lpaste.net/1844374972558999552 . What causes this behavior? I figured these would be available anywhere later down the function
10:51:14 <glguy> the "where" is attached to the definition. Only function arguments are available in it
10:51:47 <glguy> if you want to define something *inside* the do-notation, use a let statement
10:52:07 <glguy> do fileAST <- parseFile filename; let message = "IN PROGRESS"; print message
10:52:45 <glguy> ; let importASTs = getImports fileAST; etc.
10:53:00 <dmrd> glguy: Oh, let statements don't always have to end in an `in` ? Interesting, although maybe its just syntactic sugar
10:53:18 <glguy> let expressions do
10:53:24 <glguy> but do-notation has a let statement
10:53:38 <c_wraith> let expressions always have an in.
10:53:57 <c_wraith> inside a do block, you can use let statements, though.
10:54:18 <c_wraith> they are sugar in the same way all statements in a do block are.
10:54:28 <c_wraith> but they're still convenient.
10:55:34 <dmrd> Oh wow, that's fantastic. Thanks y'all
10:58:32 <nan`> i understand what the kind of a monad transformer should be (* -> *) -> (* -> *) but what is up with the kind of ReaderT? I don't get it -- newtype ReaderT k r m a :: forall k. * -> (k -> *) -> k -> *
10:59:14 <glguy> nan`: Someone thought it would be a good idea to enable the PolyKinds extension in that module, so you're seeing the result
10:59:28 <nan`> glguy: hm. Ok.
10:59:35 <glguy> You should think of ReaderT :: * -> (* -> *) -> (* -> *)
11:01:12 <c_wraith> that seems like a particularly useless thing to make polykinded.
11:01:23 <phadej> :t ReaderT (\_ -> Proxy :: Proxy "foo")
11:01:24 <lambdabot> ReaderT r Proxy "foo"
11:01:39 <phadej> if you have some GADT with datakind...
11:01:43 <phadej> dunno
11:03:13 * hackage util-primitive 0.1.0.0 - Primitive memory-related utilities  http://hackage.haskell.org/package/util-primitive-0.1.0.0 (MatthewFarkasDyck)
11:03:34 <nan`> glguy: right, that helps actually i was thinking of ReaderT applied to something
11:03:48 <madnight> how can i use makeLenses'' for a data structure that is not underscore prefixed?
11:04:16 <the_2nd> Trying to stack build a LTS 12.7 (GHC 8.4.3) project on archlinux never seems to terminate and keeps freezing the UI
11:04:20 <the_2nd> any ideas?
11:04:34 <cocreature> madnight: makeLensesFor and makeLensesWith let you customize the naming scheme
11:04:37 <glguy> madnight: either specify a different naming rule or use makeLensesFor to specify the naming yourself.
11:04:45 <the_2nd> Happening during Configuring / Installing ghc
11:05:11 <the_2nd> already using the stack-static solution
11:05:28 <the_2nd> 11.22 with 8.2.2 works fine
11:07:01 <madnight> okay looks good, hmm and for any "cool" stuff you need TH right?
11:07:28 <glguy> Only if you define cool to mean TH
11:07:47 <the_2nd> nm, it just takes forever and keeps freezing my pc
11:07:53 <the_2nd> but finishes at some point
11:08:03 <geekosaur> sounds like you're hitting swap space limits to me
11:08:03 <madnight> glguy: i mean lenses auto generation is somewhat cool
11:09:46 <the_2nd> geekosaur, memory usage is actually rather low
11:10:17 <the_2nd> stack stuck at 0% usage and little memory
11:10:17 <the_2nd> just something seems to interfere with the OS/UI
11:10:29 <cocreature> madnight: there is also generic-lens which doesn’t require TH
11:14:47 <sebben> newbie question: is there a `pseq` equivalent that returns the a instead of the b? I.e. something like `fn :: a -> b -> a`. 
11:14:49 <madnight> cocreature: hmm looks good, how can i add deriving to an already existing imported ADT?
11:15:05 <sebben> What I am trying to achieve is to force evaluation of a function before subsequently doing some cleanup involving file IO
11:16:03 <glguy> Control.Exception.evaluate x >> cleanup >> return x
11:16:04 <cocreature> madnight: you can use standalone deriving but that implies an orphan instance and these tend to be somewhat problematic
11:16:35 <madnight> cocreature: but that is slightly cooler than TH right? :)
11:16:42 <glguy> sebben: But that you need to run some file cleanup *after* some evaluation indicates you're doing something wrong
11:17:26 <cocreature> madnight: I’m not sure “cool” is an objective metric so that’s somewhat hard to answer :). the TH solution does not suffer from the problems incurred by orphan instances. then again, an orphan instance for Generic is probably also not that bad
11:17:39 <cocreature> but I would first try to convince the author to add that to the package itself
11:17:44 --- mode: glguy set +v wdanilo
11:17:51 <wdanilo> Hi guys! I've got a question. Is it true that extensions in module header override the ones defined as default-extensions in cabal/stack file ?
11:18:08 <sebben> glguy: that might very well be true. I am writing a test for a parser I have written that should read content from a file. In my test setup I create the file on disk, do the processing on it that I want to test, and then delete the file in the cleanup phase. At the moment the file is deleted before the function test is ever run...
11:18:45 <cocreature> wdanilo: no, we actually had the same question earlier today: cli flags (and default-extensions is turned into a cli flag) take precedence
11:18:51 <glguy> sebben: Put the code on gist.github.com so we can see what's happening. Perhaps you're using lazy IO (readFile)?
11:18:57 <madnight> cocreature: so should every author in general do deriving Generic for their datatypes?
11:19:25 <cocreature> madnight: well it’s up to the author but I’d say Generic is probably worth deriving
11:19:28 <cocreature> (if you can)
11:19:37 <wdanilo> cocreature: I know oyu had this question - I'm working with ara on the same project but I just cannot believe it. I bet I was using it many times setting defualt extensions to something and overriding it in modules
11:19:38 <sebben> glguy: thanks! The code in question is this section here: https://github.com/sebastian/todos/blob/master/test/TodoSpec.hs#L58-L63
11:19:55 <the_2nd> how can I figure out if a path is a directory? e.g. paths returned by listDirectory
11:20:02 <wdanilo> cocreature: I just don't get it. I could swear I was always using it. Moreover its stupid, isnt it ?
11:20:04 <odanoburu> hello, I'm using the `xmlgen` library, but I can't seem to be able to print the generated XML using UTF-8 encoding. the `xrender` function outputs a bytestring, which I'm currently simply applying `putStr` on, as in the tutorial. to get correct utf-8 output, do I have to use the utf8-string library, or is there a better way? (maybe using text..?)
11:20:33 <selfsymmetric-pa> cocreature: Does deriving Generic by default have compilation speed implications? 
11:20:34 <glguy> sebben: https://gist.github.com/glguy/c326f1ddb310a0a923e8b3a0298c3edf
11:20:53 <cocreature> wdanilo: I don’t think it’s stupid, if you think of cli flags it makes sense that they take precedence imho. the slightly confusing thing here is that default-extensions is treated like any other cli flag
11:21:12 <sebben> glguy: oh man! thanks!
11:21:16 <cocreature> selfsymmetric-pa: sure, generating and compiling code is never free :)
11:21:44 <sebben> glguy: now that I see it, it obviously makes sense… 
11:21:45 <cocreature> but it’s usually not that bad
11:21:46 <wdanilo> cocreature: oh sure, cli flags should take precedence. But default-extensions is for what its called - defaults. So I can set something per project and don't put it everywhere unless I want to have fine grianed control
11:22:39 <cocreature> wdanilo: GHC doesn’t know anything about default-extensions. and the only option Cabal has to tell GHC about the extension is to pass it as a cli flag
11:23:40 <wdanilo> cocreature: I see the rationale behind it but its just very very bad. If I set default-extensions then I cannot disable it per-module, thats terryfying
11:24:05 <glguy> Yes, using default-extensions is a bad idea
11:24:12 <glguy> even without per-file overrides
11:24:54 <cocreature> wdanilo: I’m not saying the current behavior is great, I’m just explaining the rationale :)
11:25:19 <geekosaur> the_2nd, http://hackage.haskell.org/package/directory-1.3.3.1/docs/System-Directory.html#v:doesDirectoryExist
11:26:03 <cocreature> then again, I’d also argue that default-extensions + file-local overrides are pretty confusing and in that case you might just be better off not using default-extensions anyway (whether default-extensions should be avoided altogether is a separate matter)
11:26:16 <geekosaur> but (a) there's also tests using stat(), better if you're testing the same file/handle for multiple things (but which would force you into POSIX) (b) there can be security implication s here with respect to race conditions
11:27:02 <wdanilo> cocreature: yeah I know. I'm very thankful for the explanation. I just cannot believe I was living 10 years using Hs without knowing that 
11:27:17 <wdanilo> cocreature: thank you for helping me and Ara
11:28:32 <the_2nd> geekosaur, thanks
11:29:51 <inkbottle> This https://hackage.haskell.org/package/SVGFonts-1.7/docs/Graphics-SVGFonts.html#v:textSVG, yields "The function ‘stroke’ is applied to one argument, but its type ‘Render ()’ has none"; I can't find a more recent working example
11:31:32 <cocreature> inkbottle: what exactly do you mean by “this”? do you get this error when trying to compile the package, when trying to use it, …?
11:31:42 <cocreature> also please show us the full error message in some pastebin
11:31:50 <inkbottle> OK, I do that
11:35:25 --- mode: glguy set +v awjchen
11:35:34 <awjchen> In Mark Karpov's blog post (https://markkarpov.com/post/evolution-of-error-messages.html) and in the current megaparsec source, `mergeError` is a case expression `case errorPos e1 `compare` errorPos e2 of ...`, where `errorPos e1` and `errorPos e2` are stacks of source positions (:: NonEmpty SourcePos) that can be used to represent include files, and where the top of the stack corresponds to the front of the NonEmpty list.
11:35:45 <awjchen> My question is this: why should the stacks of source positions be compard using the default ordering for NonEmpty, in which the top element of the stack dominates the ordering, rather than the reverse ordering (`case (NE.reverse (errorPos e1)) `compare` (NE.reverse (errorPos e2)) of ...`), in which the bottom element dominates?
11:35:55 <awjchen> I ask because I am trying to solve an issue that seems to be resolved by modifying megaparsec to use the reverse ordering, but I really don't know anything about parsing or megaparsec, so I have no idea what other effects that might have.
11:36:52 <inkbottle> cocreature: error message is at the beginning, then the code: https://lpaste.net/4341657851115077632
11:37:11 <madnight> cocreature: are Profunctor Optics the new lenses?
11:38:09 <cocreature> inkbottle: as a first step, add some imports to fix the last 6 errors
11:38:37 <inkbottle> Yes, sure, try that
11:38:42 <cocreature> madnight: I’m not sure how to give a meaningful response to that. the lens lib that most people use doesn’t use profunctor optics for everything, so no?
11:41:00 <madnight> cocreature: sorry my wording is often quiet imprecise, mostly due to lack of the required knowledge in order to be more precise
11:41:20 <cocreature> is X the new Y? is just a bad question pretty much regardless of what X and Y are :)
11:43:17 <madnight> cocreature: sometimes older libs gets replaced by newer due to new insights, this does not render the old libs useless, but there will be a slow adoption towards that newer piece of technology
11:44:52 <awjchen> is there a more appropriate place to ask my question?  it's quite specific to megaparsec so I guess I could use the megaparsec issue tracker, but I thought i would first check here
11:45:07 <cocreature> madnight: profunctor optics seem to be slightly nicer on a theoretical level but I don’t see a lot of pratical benefits in switching to an all-profunctor based representation while there are significant downsides (you can’t declare lenses without depending on profunctor, you will probably break existing code, …)
11:45:13 <cocreature> so I don’t see a switch anytime soon
11:45:40 <cocreature> awjchen: I can’t comment on your specific question but afaik source stacks are already gone in master so it might not be a good idea to build a new project on top of them
11:48:12 <awjchen> cocreature: ah, that's good to know. thanks!
11:48:53 <inkbottle> cocreature: I'm back to the error produced by the original example from SVGFonts: https://lpaste.net/4089047996686139392
11:51:20 <inkbottle> I have little grasp on the error "Non type-variable argument in the constraint"
11:52:14 <philippD> > typeRep (Proxy :: Proxy (,))
11:52:16 <lambdabot>  ()
11:52:27 <inkbottle> However I just found that: https://groups.google.com/forum/#!msg/diagrams-discuss/LHRCGnmEtk0/s-5nKlnhDAAJ
11:52:28 <philippD> Shouldn't this output `(,)` ?
11:52:41 <inkbottle> which might be addressing the question
11:53:48 <inkbottle> cocreature: I've used the proposed solution, and it helps
11:54:31 <philippD> > typeRep (Proxy :: Proxy (,,,,,,))
11:54:33 <lambdabot>  ()
11:54:35 <inkbottle> I was reluctant first at using things I don't understand like {-# LANGUAGE FlexibleContexts #-} and {-# LANGUAGE TypeFamilies #-}
11:54:59 <suzu> are there known issues with using MVars in functions called by C?
11:55:02 <philippD> Why are all tuple types represented by `()`?
11:55:24 <glguy> suzu: you'll have to be more specific, certainly not in general
11:55:49 <suzu> i've got two calls to C running separately in asyncBounds
11:55:53 <suzu> they call out to some haskell functions
11:56:03 <suzu> i'm doing some concurrency between the two using MVars
11:56:11 <suzu> somehow i'm getting a deadlock occasionally
11:56:21 <mnoonan> philippD: that's just how they are pretty-printing, for some reason
11:56:35 <mnoonan> > typeRep (Proxy :: Proxy (,,))  == typeRep (Proxy :: Proxy (,,,))
11:56:37 <lambdabot>  False
11:56:58 <suzu> if i run this code in a loop, the first n-1 iterations deadlock and the nth works
11:57:11 <suzu> (i break the deadlock by placing a timeout on a takeMVar)
11:57:25 <philippD> mnoonan: yeah, I just checked them for equality. But printing still seems to be broken
11:58:22 <mniip> > splitTyConApp $ typeRep (Proxy :: Proxy (,,))
11:58:24 <lambdabot>  ((,,),[])
11:59:33 <ab9rf> too many commas
11:59:41 <mniip>   | isTupleTyCon tc =    showChar '(' . showArgs (showChar ',') tys . showChar ')'
11:59:47 <suzu> glguy: can you think of anything i might be doing wrong?
11:59:55 <mniip> that's the culprit, it doesn't check the arity of the tuple
11:59:57 <suzu> or perhaps some things i can do to make investigation easier?
12:02:37 <mniip> philippD, feel free to file a bug on the GHC trac
12:02:44 <mniip> libraries/base
12:02:49 <mnoonan> mniip: oof, yeah. it's even worse like this:
12:02:55 <mnoonan> > typeRep (Proxy :: Proxy ((,,,,) Int Bool))
12:02:57 <lambdabot>  (Int,Bool)
12:09:12 <philippD> I can't create a trac account. the registration page says that I failed to input a CAPTCHA but there is none
12:10:13 * hackage prim-instances 0.1.0.0 - prim typeclass instances  http://hackage.haskell.org/package/prim-instances-0.1.0.0 (chessai)
12:10:52 <suzu> im gonna just
12:10:55 <suzu> upgrade to 8.4.3
12:10:58 <suzu> just in case that's a thing
12:11:02 <suzu> that might matter here
12:11:05 <warbo> hello, I'm trying to improve the memory usage of a CLI program which transforms JSON data over stdio 
12:11:33 <warbo> I'm using aeson, and the top-level data is a JSON object, which I think is being kept around in memory
12:11:47 <ab9rf> a single JSON object?
12:11:52 <warbo> yes
12:12:00 <ab9rf> difficult to avoid that issue
12:12:15 <suzu> take a look at https://hackage.haskell.org/package/json-stream
12:12:30 <warbo> yeah, I had a read through
12:12:38 <ab9rf> you need something that can lazily deserialize json
12:13:17 <suzu> take a look at this too then
12:13:18 <suzu> https://www.reddit.com/r/haskell/comments/91yl95/the_problem_of_parsing_large_datasets_why/
12:13:46 <mnoonan> philippD: what do you think about adding it as a comment to this ticket? https://ghc.haskell.org/trac/ghc/ticket/14341
12:13:55 <mnoonan> (I can add if you need an account)
12:14:43 <ab9rf> is json-stream the analogue of SAX for JSON?
12:15:04 <philippD> mnoonan: yeah, seems to be the right ticket for that. I got the account. I was just to stupid to read.
12:15:19 <warbo> ab9rf: it seems to do parsing lazily, at the cost of losing things like up-front error checking
12:15:29 <ab9rf> part of the problem with JSON is that the semantics are such that you can't tell that you've got valid JSON until you get to the end of the document
12:15:41 <ab9rf> there's no semantically-valid way to lazily parse JSON
12:16:18 <warbo> we can still check for errors
12:16:30 <warbo> but only report on it once we reach the end of the document
12:16:58 <ab9rf> it's probably not a good idea to use JSON for "large documents"
12:17:25 <suzu> json is a bad serial protocol
12:17:34 <suzu> if that's something you can control, use something that isn't json
12:17:35 <warbo> still, the json-stream documentation mentions that it can take a bunch of dubious-sounding shortcuts too (e.g. skimming through whole sections of data to count open/close brackets, rather than doing "proper" parsing)
12:17:42 <ab9rf> at least with XML there is a widely-accepted paradigm for stream parsing (SAX)
12:17:52 <ab9rf> suzu: agreed
12:18:55 <warbo> ah, I see what you mean by SAX now
12:19:23 <warbo> I was thinking of its interface rather than its execution model
12:19:53 <ab9rf> SAX's limited interface is specifically designed to support a streaming execution model
12:19:57 <warbo> yeah
12:20:03 <ab9rf> you need something similar, exept for JSON
12:20:23 <warbo> only used inbriefly, many years ago, in PHP; so I've blocked out most of those memories
12:20:24 <warbo> :P
12:20:24 <ab9rf> should be possible, probably not the easiest thing to do though
12:20:42 * hackage setlocale 1.0.0.7 - Haskell bindings to setlocale  http://hackage.haskell.org/package/setlocale-1.0.0.7 (Kritzefitz)
12:20:52 <ab9rf> warbo: i learned how to use SAX a decade or so ago, used it two or three times, and then stopped carig
12:22:01 <warbo> I'm wondering if I can use json-stream's API, e.g. 'objectItems', to get a lazy list (or equivalent stream) of key/value pairs
12:22:57 <warbo> i.e. chop off the leading '{', treat the remainder like an array of pairs, and ignore the closing '}'
12:23:07 <ab9rf> maybe
12:23:34 <warbo> I know my data's well-formed, it's just hanging around too long in memory
12:24:02 <warbo> I've already sprinkled 'deepseq' and BangPatterns around
12:24:12 <suzu> can you fetch what you need out of it and then let it get garbage collected?
12:24:40 <warbo> I've tried doing that; not sure if I succeeded though
12:24:45 <ab9rf> it looks like json-stream is mainly intended to be used insituations where you have a large json structure, most of hwihc you are not interested in
12:25:12 <suzu> to let it be gc'ed, you need to forcefully eval the things you need from it and then let the entire object escape all scopes
12:25:24 <suzu> no thunks can be pointing at it anymore
12:25:28 <suzu> or hold any refs to it
12:25:54 <warbo> I need all of the data, but only need to process one key/value at a time
12:26:26 <suzu> then it won't be gc'ed
12:26:31 <ab9rf> "the many parser works by accumulating all matched values"
12:26:39 <warbo> so ideally I'd read the first key/value, process it (which may take a while), spit it out to stdout (the input/output JSON has the same structure) then move on to the next
12:27:27 <suzu> take the object, deepseq a list of that data and then don't hold refs to the original object
12:27:50 <warbo> oh, that would still stream?
12:27:51 <suzu> but this will hold an entire copy of the kvs in memory
12:27:56 <warbo> ah
12:27:58 <suzu> no, it will not stream
12:28:10 <suzu> if you want streaming then you need to keep thunks for fetching the rest, around in memory
12:28:17 <suzu> which means the entire object must persist for the entirety of your stream
12:28:19 <ab9rf> warbo: you might look at ndjson-conduit
12:28:32 <ab9rf> i have no idea if it will do what you want
12:28:39 <ab9rf> but it might give you ideas
12:28:58 <warbo> ooo, interesting
12:29:40 <suzu> the best advivce is don't use json
12:29:47 <warbo> heh
12:29:47 <suzu> what are you actually trying to do?
12:30:13 <warbo> processing data from an experiment
12:30:22 <ab9rf> if it's a big json array, you could just eat the leading separator, and then parse json objects one at a time off the input
12:30:24 <suzu> and it's in json?
12:30:29 <warbo> stored as a map of maps of things
12:30:31 <suzu> so your hands are tied?
12:30:32 <suzu> hm
12:30:43 <suzu> how about: open the json and reserialize it into something better
12:30:53 <suzu> and then do some happy streaming over that data
12:31:04 <warbo> ab9rf: that's what I meant by "chopping off the leading '{'"
12:31:22 <ab9rf> warbo: that is likely a strategy. i'd probably use conduits, but i like conduit
12:31:35 <suzu> streaming ftw
12:31:47 <suzu> https://hackage.haskell.org/package/streaming
12:34:47 <warbo> I've heard good things about streaming
12:35:41 <ab9rf> data structures with lead counts are MUCH better for storage than those that use terminators
12:36:04 <ab9rf> it's so much easier to "skip n bytes" than it is to "read until you get a X"
12:36:12 <warbo> ab9rf: yeah, I've heard good things about protobuf, capnproto, etc.
12:36:42 <ab9rf> such data formats are harder for humans to edit, but WHO THE FUCK CARES
12:37:09 <warbo> tangentially, do you know if there are jq-like tools for such formats?
12:37:26 <ab9rf> dunno
12:37:35 <ab9rf> JSON is this decade's XML
12:37:43 <warbo> one reason I'm constrained to use json is that I have to be compatible with a bunch of bash scripts using jq that I don't want to touch ;)
12:37:53 <ab9rf> it has all the disadvantages of XML and none of the advantages
12:38:02 <warbo> sexpressions ftw
12:38:07 <warbo> ;)
12:38:14 <warbo> (yes, I know, delimited)
12:38:17 <suzu> i think xml is worse than json
12:38:51 <ab9rf> suzu: depends on how you use it. if you actually define a schema and stick to it, xml is superior because it can be validated.
12:38:58 <ab9rf> json is just a box
12:39:06 <warbo> json doesn't have things like million laugh attacks, network requests during parsing, etc.
12:39:45 * hackage setlocale 1.0.0.8 - Haskell bindings to setlocale  http://hackage.haskell.org/package/setlocale-1.0.0.8 (Kritzefitz)
12:40:03 <ab9rf> the reason people use json is bceause it's trivial to parse in javascript, which is forcibly ubiquitious because of browsers
12:40:29 <ab9rf> if it weren't for that, nobody would ever use it
12:41:15 <warbo> it's also a lowest common denominator for storing data in most languages (arrays/lists, maps/dictionaries, null, bool, number and string)
12:41:29 <ab9rf> warbo: 
12:41:34 <ab9rf> warbo: "most" languages?
12:41:35 <ab9rf> really?
12:41:38 <ab9rf> :)
12:41:58 <exio4> it won by pragmatic de-factoness :P 
12:42:09 <mnoonan> the thing that infuriates me most about json is that *despite* the fact that its only real benefit is easy parsing from javascript... no comments.
12:42:17 <warbo> heh
12:42:25 <ab9rf> mnoonan: heh
12:42:37 <warbo> and the plethora of incompatible alternatives which add comments, but break compatibility with everything
12:42:38 <ab9rf> mnoonan: it's not intended to be read by hoomans, so why would you put comments in it
12:42:46 <warbo> (hence losing the point of using a standard format)
12:44:26 <liquid_pascal> warbo: what did you mean by delimited s-expressions?
12:45:14 <philippD> > typeRep (Proxy :: Proxy (Proxy 'True))
12:45:16 <lambdabot>  Proxy Bool 'True
12:45:32 <philippD> Why is the kind in such a strange position?
12:46:08 <warbo> liquid_pascal: s-expressions are delimited by '(' and ')', ab9rf prefers lead counts (e.g. "the next 100 bytes is a string")
12:47:59 <liquid_pascal> warbo: Is that supposed to be something different from a normal s-expression? Aren't they always surrounded by parens?
12:48:33 <ab9rf> warbo: i prefer delimeters in code and other things intended to be read and edited by humans
12:49:11 <ab9rf> warbo: for stuff being written out to be read back in by software, there is no point in having delimeters or terminators
12:50:03 <ab9rf> this is why json is crap
12:50:10 <ab9rf> it's not intended to be red by humans
12:50:49 <ab9rf> the data format used in minecraft anvil files would be a better choice
12:50:58 <warbo> I much prefer to read/write JSON manually than e.g. YAML though, which AFAIK was intended to be human readable/editable
12:51:19 <exio4> warbo: yaml is nicer to read but harder to write to me than json
12:51:23 <warbo> I always need to Google around for documentation when dealing with yaml
12:51:41 <warbo> so many ways to write a string!
12:51:46 <ab9rf> yaml is just xml with fewer angle brackets :)
12:51:59 <exio4> and not really 
12:52:13 <ab9rf> i know
12:52:30 <ab9rf> i used to know a guy at juniper who was a real yaml evangelist
12:56:17 <chessandgo> does anyone know if the mailbox is the only way to communicate with Processes on other nodes with cloud haskell
12:56:32 <warbo> liquid_pascal: I was just talking about normal s-expressions; i.e. given the choice between XML and JSON, I'd go for s-expressions ;)
12:56:44 <chessandgo> ReceivePort is unserializable so typed channels dont work internode
13:05:13 <zachk> chessandgo, mvars , and tvar and friends work for cloud haskell processes in the same process
13:05:27 <zachk> in the same OS process that is
13:07:31 <chessandgo> zachk: as do ReceivePort, im talking across nodes (different processes, maybe even different machines)
13:07:47 <chessandgo> the website is pretty lackluster
13:08:12 <zachk> never heard of ReceivePort, whats wrong with message passing with send? yea their documentation isn't complete
13:08:13 <chessandgo> mentioning typed channels, then mentioning that they cant be serialized, but not explicitly saying that you have to use the mailbox for internode communication
13:08:33 <chessandgo> zachk: send isnt typed
13:08:46 <chessandgo> its a bit annoying to get this nice typed primative, then have it useless across nodes
13:08:51 <zachk> cloud haskell uses the erlang style of concurrency, actors with message passing 
13:09:03 <zachk> the "receives" are typed though 
13:09:20 <liquid_pascal> warbo: ah sorry. So would I :D
13:09:41 <chessandgo> yeah, just a bit annoying
13:09:48 <chessandgo> RecievePort is from newChan
13:09:50 <chessandgo> CH.Process (CH.SendPort a, CH.ReceivePort a)
13:13:42 * hackage flick-duration 1.0.0 - work with durations of time using the Flick as the smallest unit  http://hackage.haskell.org/package/flick-duration-1.0.0 (clord)
13:19:21 <chessandgo> zachk: does erlang not have typed channels for internode communication?
13:20:02 <zachk> erlang has dynamic types, which are a pain to debug, and uses prolog-ish syntax 
13:21:27 <chessandgo> yeah, I noticed that much, which is why I kinda stayed away from using erlang
13:23:05 <zachk> I used elixir before, it was ok , but the dynamic types were a pain to debug, elixir is a different syntax over erlang, same language runtime underneath though
13:23:43 * hackage hapistrano 0.3.5.10 - A deployment library for Haskell applications  http://hackage.haskell.org/package/hapistrano-0.3.5.10 (juanpaucar)
13:24:17 <chessandgo> does elixir have monads?
13:24:22 <chessandgo> erlang has monads, but only as a library
13:24:26 <chessandgo> which is unfortunate
13:24:47 <zachk> chessandgo, iirc the mailboxes in cloud haskell will just queue up unread messages that dont match the type of a receive
13:25:05 <zachk> elixir has some sort of monad library never used it, and stopped using elixir a few years ago
13:25:14 <chessandgo> zachk: I suppose thats wat ill have to use
13:25:19 <chessandgo> I saw typed channels and go so happy
13:25:32 <chessandgo> but it seems that its just a tchan or something, doesnt work outside of local node
13:25:55 <zachk> :(
13:26:15 <zachk> you've seen the name processes and the monitors, chessandgo ?
13:26:50 <philippD> Does the usage of AllowAmbiguousTypes interfere with the `:t` in ghci or have I broken something?
13:27:22 <chessandgo> zachk: ive seen the monitors, but not the "name processes" yet
13:27:24 <chessandgo> what are those?
13:30:42 <zachk> I think thats one of the way of doing internode communication, you name and register the process on the node, and the other node communicates to another node using the a reference to the other node and name of the process you want to send to
13:39:21 <chessandgo> zachk: ah, isnt that like the DNS naming process for nodes
13:40:16 <zachk> chessandgo, I don't know that much about DNS, sorry 
13:40:49 <zachk> I generated BIND configuration files using a template and perl, but that was over a decade ago 
13:42:05 <sm> evening all
13:42:47 <sm> what's the right way to throw a final parse error in a megaparsec parser, preventing backtracking ?
13:43:09 <suzu> are there gotchas when using mvars with the ffi or something
13:45:50 --- mode: glguy set +v librerush
13:54:43 * hackage eternity-timestamped 0.4.1 - Automatic timestamping for Eternity  http://hackage.haskell.org/package/eternity-timestamped-0.4.1 (vlastachu)
13:55:38 <glittershark> is there something in the prelude that will give me `f 3 = f . f . f ; f 2 = f . f` etc?
13:55:43 <glittershark> or in Base
13:56:10 <glittershark> best I've got right now is stimes with Endo, but that doesn't feel good
13:57:42 <mnoonan> glittershark, why not? isn't that exactly what you're asking for?
13:57:56 <glittershark> newtypes just feel icky
13:58:50 <nshepperd1> iterate (f.) id !! n?
14:07:55 <sQVe> How can this be a problem? 'haskell-lsp-0.2.2.0 from stack configuration does not match >=0.5  (latest matching version is 0.7.0.0) needed since haskell-ide-engine is a build target.'
14:07:58 <jetpack_joe> does anyone have experience with private hackage servers? I am trying to bump a version of a library i uploaded, and am getting this error: https://pastebin.com/QGbr0CLK
14:10:14 <madnight> % import Control.Lens
14:10:14 <yahb> madnight: 
14:10:35 <madnight> % [[1,2,3], [1,2,3]] & ix 0 .~ [4]
14:10:37 <yahb> madnight: [[4],[1,2,3]]
14:11:14 <madnight> % [[1,2,3], [1,2,3]] & ix 0 & ix 0 .~ 4
14:11:15 <yahb> madnight: ; <interactive>:55:22: error:; * Couldn't match type `[[Integer]]' with `IxValue m -> f (IxValue m)'; Expected type: [[Integer]] -> m -> f m; Actual type: (IxValue m -> f (IxValue m)) -> m -> f m; * In the second argument of `(&)', namely `ix 0'; In the first argument of `(&)', namely `[[1, 2, 3], [1, 2, 3]] & ix 0'; In the expression: [[1, 2, 3], [1, 2, 3]] & ix 0 & ix 
14:11:19 <chessandgo> zachk: is there a more proper name, im having difficulty finding "named process"
14:11:19 <madnight> why?
14:12:02 <Gurkenglas> % [[1,2,3], [1,2,3]] & ix 0 . ix 0 .~ 4
14:12:02 <yahb> Gurkenglas: [[4,2,3],[1,2,3]]
14:12:18 <madnight> Gurkenglas: ah ok
14:12:50 <Gurkenglas> madnight, ix 0 turns a small action into a big action. you want to compose the thing that turns a medium action into a big action with the thing that turns a small action into a medium action
14:13:00 <zachk> yea chessandgo , I just looked it up in my code, it goes like this: register "demultiplex" demultiplexPid 
14:13:17 <Wizek> Is there any way to see what part of a Haskell app catches (and silently discards) UserInterrupt errors? 
14:13:52 <chessandgo> zachk: do you write cloud haskell then?
14:14:19 <Wizek> I've tried setting `installHandler sigINT (handler tid) Nothing`, and it seems to be silently overwritten as well
14:14:38 <zachk> chessandgo, I wrote a bit of it for my mud, but I don't have to work on my architecture much anymore, I just send small messages to actors in the mud now, and they handle it
14:15:09 <zachk> though I haven't been working on it much anymore, the cloud haskell can get kind of verbose and a bit spaghetti but it usually works fine without too many bugs
14:15:10 <chessandgo> zachk: very nice, you using mailboxes for everything then?
14:15:50 <zachk> no I use some tvar's for global state inside the mud core, which is seperate from the chat and networking frontend, so I can make sweeping changes without people losing connection
14:15:59 <zachk> I use lens too 
14:16:45 <zachk> map of maps of sum types is one of the main things of global state, and a mudId to processId map is the other. the maps being Data.Map
14:17:08 <chessandgo> are you all within the same node then? zachk 
14:17:16 <chessandgo> tvars dont work on different processes
14:17:22 <zachk> I have chat, private messaging , a who command , movement and looking ina  room for now
14:17:46 <zachk> yea i have two different processes to make up the mud, the core handles the stuff that is actually a mud and uses two tvars
14:18:11 <zachk> i also have a third process that doesnt use cloud haskell, but is a websocket and webserver frontend to the mud's networking frontend 
14:18:32 <zachk> whole thing is probably over a 1000 lines between three seperate programs
14:19:08 <zachk> I've been working on this current incarnation on and off for 2 or more years now iirc 
14:21:23 <zachk> sometimes I kind of wish I had OO and duck typing for handling the global state of the mud :-/ 
14:26:58 <dmj`_> zachk: typeclasses are kind of like duck typing with a seatbelt
14:29:17 <mnoonan> "if it `use`s like a duck, and it `assign`s like a duck..."
14:30:37 <chessandgo> isnt that what type level programming is for
14:30:58 <chessandgo> zachk: im breaking the lobby/connections into a seperate process from the engine itself
14:31:07 <chessandgo> so i can restart the engine without loosing client connections
14:31:11 <chessandgo> as most muds can do
14:31:41 <chessandgo> and its around 230 lines currently, I just need to figure out how to get the seperate node running, and get a parser and finite state machine for the login process up
14:32:42 * hackage sbp 2.4.0 - SwiftNav's SBP Library  http://hackage.haskell.org/package/sbp-2.4.0 (markfine)
14:33:05 <ChaiTRex> If I have an empty data declaration, do arguments of that type still actually take up space or are they treated as if you had a function of one less argument?
14:34:43 <suzu> if you have an empty data decl how can you ever make a value of that type?
14:35:04 <hpc> the only value is undefined
14:35:12 <ChaiTRex> I can't, but it might still use up space in the registers or whatever for a value of that type in case of undefined.
14:35:30 <ChaiTRex> If I don't evaluate the argument, will it be eliminated by GHC?
14:36:18 <glguy> ChaiTRex: Empty data types still have values
14:36:27 <glguy> error "my message here" :: Void
14:37:18 <Gurkenglas> mniip, http://hackage.haskell.org/package/yoctoparsec-0.1.0.0/docs/src/Control-Monad-Yoctoparsec.html <- token = wrap pure
14:37:26 <Gurkenglas> % :t wrap pure
14:37:26 <yahb> Gurkenglas: MonadFree ((->) a) m => m a
14:38:14 <ChaiTRex> Hmm, I'm wondering if it's zero-cost, though, if I don't evaluate the argument. That way, even if it has a value, it doesn't matter what the value is. I'm hoping GHC can eliminate the argument from the function it produces in the executable.
14:38:45 <glguy> It's not completely zero since the argument still needs to be passed
14:39:07 <glguy> In some cases with sufficient inlining the unused value might go away, but you shouldn't count on that
14:39:45 <glguy> You probably should just try not to have function arguments with empty data types, in any case. How are you running into this?
14:39:57 <ChaiTRex> Is there a way to have a type level Nat that has a zero-additional-cost way of using that to make a Word# -> Word# function?
14:40:09 <Gurkenglas> ...except wrap wants a monad instance. Why?
14:40:21 <ChaiTRex> Like, I have the number of bits something takes, and I want to mask the rest of the unused bits to clear them.
14:40:33 <ChaiTRex> The number of bits is in a type-level Nat.
14:40:54 <glguy> You can use a Proxy# or Tagged or TypeApplications
14:41:21 <ChaiTRex> I'm hoping to get functions like \ w# -> w#, \ w# -> and# w# ..., and \ w# -> narrow8Word# w#
14:42:10 <ChaiTRex> OK, thanks. I'll look into those.
14:43:11 <mniip> % :t wrap pure `asTypeOf` token
14:43:12 <yahb> mniip: Monad b => FreeT ((->) a) b a
14:43:14 <ChaiTRex> Proxy# looks excellent. Thanks again.
14:43:51 <mniip> neat
14:44:14 <mniip> Gurkenglas, wait, Monad b
14:44:40 <mniip> there's no need for wrap to have that constraint
14:44:56 <Gurkenglas> mniip, indeed
14:45:02 <Gurkenglas> PR to free time?
14:45:50 --- mode: glguy set +v Thedore_Rusevelt
14:46:14 <Thedore_Rusevelt> hi
14:46:56 <glguy> MonadFree has a Monad constraints presumably for the same reason MonadState does
14:47:20 <glguy> as a convenience given the way its typically used
14:47:33 <Gurkenglas> Because it's got Monad in the name, so you don't have to also say Monad in the constraint list?
14:47:41 <glguy> yeah
14:50:55 <mniip> hmm
14:50:55 <Gurkenglas> I feel like it formally deserves a PR anyway kinda https://github.com/ekmett/free/pull/178
14:51:58 <Gurkenglas> ...I'd presumably also have to remove the superclass from MonadFree
14:52:22 <Gurkenglas> gah, suddenly it doesn't feel like it deserves a PR :P
14:55:35 <mniip> if I have a type family with a branched axiom
14:56:17 <mniip> and I'm trying to write a singleton manipulator for said type family
14:56:39 <mniip> how do I evidence the incompatibility with one of the axiom branches
14:58:08 <mniip> consider e.g
14:59:04 <mniip> type family Eq (a :: Nat) (b :: Nat) :: Bool where Eq a a = True; Eq a b = True
14:59:19 <mniip> eq :: Proxy n -> Proxy m -> SBool (Eq n m)
15:00:35 <mniip> eq p q = case sameNat p q of Just Refl -> STrue
15:00:40 <mniip>   Nothing -> ???
15:06:28 <jle`> mniip: i don't think it's possible with GHC's api
15:06:38 <jle`> for Nat
15:06:50 <mniip> not sure it's possible for any non-algebraic kind
15:08:02 <jle`> unless the kind's abstract interface provides it
15:08:52 <jle`> but yeah type families with fallbacks based on nonlinear patterns always confuses me
15:09:01 <jle`> i don't know how things work until i try to compile heh
15:09:56 <mniip> jle`, I learned a thing about typefamilies recently
15:10:08 <mniip> closed type families don't make up one large branched axiom
15:10:26 <mniip> they're checked for pairwise confluence and are split into confluent groups that are in turn branched
15:12:14 <mniip> jle`, e.g this http://hackage.haskell.org/package/base-4.11.1.0/docs/src/Data.Type.Bool.html#%26%26
15:12:29 <mniip> all equations here are confluent so it's no different from an open family
15:12:31 <madnight> i finally managed to create a lens getter for my nested data structure, is there a idiomatic way to convert a getter into a setter?
15:13:52 <mniip> the a || a part especially
15:14:28 <mniip> jle`, I wonder if GHC can di any useful constraint solving on (a == b ~ False(
15:16:28 <mniip> doesn't seem like it
15:17:07 <jle`> madnight: do you mean like, manually re-writing the code?
15:17:32 <mniip> jle`, is there a library that can help or am I doomed to unsafeCoercing?
15:17:45 <madnight> jle`: b ^. fD ^?! _Hunks . ix 0 ^. hL . ix 0 . lC   thats my getter
15:17:47 <jle`> it's not possible in general, but if your getter is constructed using lenses then it should automatically be a setter if you keep it polymorphic
15:18:08 <jle`> madnight: what part is the getter?
15:18:09 <mniip> madnight, please do not paste perl here
15:18:21 <jle`> mniip: huh closed type families are weird
15:18:46 <madnight> mniip: perl?
15:19:35 <jle`> mniip: for your original type family, both branches were meant to return True right?
15:19:37 <glguy> madnight: If you're using more than one ^ function at a timer you're probably doing something wrong
15:19:54 <glguy> at a time*
15:19:55 <jle`> madnight: yeah, it's not clear what getter you are referring to
15:19:57 <mniip> jle`, er, False
15:20:44 <madnight> jle`: ah okay it also compiles if i replace the second ^. with .
15:20:54 <jle`> madnight: but, what is your getter?
15:20:59 <glguy> madnight: and then you can merge the ^. and ^?!
15:21:47 <jle`> mniip: one thing you can do is pull the trick that the singletons library works with
15:21:59 <madnight> glguy: yes sir, so now it's: b ^. fD . _Hunks . ix 0 . hL . ix 0 . lC
15:22:03 <jle`> is define Eq not using nonlinear patterns, but like Eq a b = If (a == b) True False
15:22:18 <jle`> madnight: ah so your getter is (fD . _Hunks . ix 0 . hL . ix 0 . lC)
15:22:26 <mniip> jle`, and then?
15:22:49 <mniip> does sIf effectively do LEM for me?
15:23:11 <jle`> madnight: if all of the pieces of your getter are also setters, then the final getter is also a setter
15:23:21 <jle`> mniip: ah wait, no, you're right, that mixes the two equalities
15:23:35 <jle`> i remember in a previous project this gave me a bunch of headaches
15:23:50 <madnight> jle`: is this the case right now for my getter?
15:23:53 <jle`> working at the type level with singletons is a weird juggling of prop vs dec equality
15:24:03 <jle`> madnight: impossible to know without knowing what fD, _Hunks, hL, lC are
15:24:54 <jle`> madnight: but you can use the handy table in the docs for http://hackage.haskell.org/package/lens
15:25:16 <jle`> when you compose optics with (.), they combine to their mutual child in the table
15:25:30 <jle`> so a lens and prism compose to turn into a traversal
15:26:22 <jle`> but also this is a bit weird because 'ix 0' is a traversal, so you shouldn't be able to use it as a getter with ^.   ...
15:27:04 <jle`> so (fD . _Hunks . ix 0 . hL . ix 0 . lC) can't be a getter; it's either a Traversal, Setter, or Fold
15:27:14 <jle`> if you're using ix from lens
15:27:46 <phadej> ^. makes lens into getter, traversal into fold
15:28:28 <phadej> > [Sum 1, Sum 2] ^. traverse
15:28:30 <jle`> oh huh that's neat
15:28:30 <lambdabot>  Sum {getSum = 3}
15:28:40 <phadej> well, it's a source of bugs too
15:28:59 <phadej> luckily, a lot of things you `view` aren't Monoids
15:29:07 <phadej> > ['a', 'b'] ^. traverse
15:29:09 <lambdabot>  error:
15:29:09 <lambdabot>      • No instance for (Monoid Char) arising from a use of ‘traverse’
15:29:09 <lambdabot>      • In the second argument of ‘(^.)’, namely ‘traverse’
15:30:04 <phadej> > [Sum 1, Sum 2] ^. traverse . to (\x -> [x])
15:30:06 <lambdabot>  [Sum {getSum = 1},Sum {getSum = 2}]
15:30:15 <phadej> > [Sum 1, Sum 2] ^.. traverse
15:30:17 <lambdabot>  [Sum {getSum = 1},Sum {getSum = 2}]
15:30:36 <glguy> ==>    ^.. folded     ==> toList
15:31:49 <phadej> one can argue that we'd need a `view` which uses a variant of `Const` which isn't Applicative
15:31:50 <glguy> I argued against view having the Monoid behavior and only using that behavior in foldOf to avoid these bugs and lost
15:31:56 <phadej> then you'll get better eror
15:32:04 <phadej> glguy: o/
15:32:05 <mniip> jle`, but
15:32:10 <mniip> there isn't an instance PEq Nat
15:32:13 <mniip> as far as I can see
15:32:21 <madnight> jle`: i don't know whether it's a getter or not, but it works, i get the nested object of interest
15:32:31 <jle`> mniip: yeah, my idea doesn't work
15:32:43 <jle`> madnight: yeah, just try using it as a setter
15:32:55 <jle`> it should be one, if fD, _Hunks, hL, and lC are usable as setters
15:33:04 <madnight> jle`: that also works :)
15:33:07 <jle`> nice :)
15:33:57 <mniip> hmm
15:34:01 <mniip> I can write     'Exactly i \/ 'Exactly j = If (i DTE.== j) ('Exactly i) 'Variable
15:34:09 <mniip> but that's not confluent with  a \/ a = a then :(
15:35:00 <mniip> a sad
15:37:34 <jle`> in my last project i spent a few days trying to make something like this work but i think in the end i gave up
15:37:47 <jle`> but if you find a solution i would be happy to hear :)
15:38:48 <jle`> i wonder how dependently typed languages deal with things like this
15:42:18 <jle`> presumably they might disallow nonlinear patterns
15:43:16 <cheater> hi
15:43:22 <cheater> are any maintainers of hedgehog around?
15:43:24 <mniip> jle`, does singletons have a typeclass T a where :: Sing a
15:43:38 <jle`> yeah, SingI
15:45:50 <mniip> hmm
15:45:51 <mniip> I wish
15:45:57 <mniip> I could specify two default decls
15:47:41 <phadej> write a lib for binary-encoded naturals
15:48:02 <phadej> computing with them isn't as slow as with peano numbers
15:48:14 <phadej> but then you can do ^^^ things
15:51:00 <phadej> data Bin = Bin0 | OneDouble Bin | TwoDouble Bin -- 0 | 2n+1 | 2n+2
15:51:55 <phadej> I'd be happy to get those into my `fin`
15:51:56 <fishythefish> why not 0 | 2n | 2n + 1?
15:52:17 <phadej> fishythefish: do you know the answer? :)
15:52:37 <phadej> (it is: zero is not unique)
15:53:01 <glguy> </spoilers>
15:53:06 <phadej> :/
15:53:10 <fishythefish> ah fair
15:53:26 <phadej> reading software foundations pays off.
15:54:22 <fishythefish> yeah i vaguely remember this from doing some of SF a while ago
15:55:11 <phadej> there's like two interesting problems, that one and palindrome
15:55:55 <phadej> not sure if they are both still in "logical foundations" part
15:59:12 <phadej> no wait, three
15:59:25 <phadej> classical logic axioms equivalence is nice puzzle to go through too
16:07:14 <chessandgo> can I get a link to "software foundations" and "logical foundations" they sound interesting phadej 
16:08:27 <epta> phadej: https://softwarefoundations.cis.upenn.edu/lf-current/index.html
16:08:28 <dmj`_> chessandgo: https://softwarefoundations.cis.upenn.edu/lf-current/toc.html
16:09:26 <epta> in travis.yml, what is the point of 'travis_wait 45 sleep 1800 &' like here https://github.com/bitemyapp/hedgehog-checkers/blob/master/.travis.yml#L15 ?
16:10:24 <chessandgo> dmj`_: thank you!
16:10:47 <dmj`_> chessandgo: of course
16:10:48 <chessandgo> hey, its on Coq
16:10:53 <chessandgo> I might already have this open in another tab
16:11:03 <chessandgo> good stuff, good stuff
16:11:16 <jle`> mniip: just wait til DerivingVia :)
16:13:08 --- mode: glguy set +v nineonine
16:13:10 <nineonine> is this
16:13:15 <nineonine> foo _ = ...
16:13:20 <nineonine> different from this
16:13:23 <dmj`_> jle`: how earth shattering will deriving via be
16:13:23 <nineonine> foo !_ = ...
16:13:34 <nineonine> in other words
16:13:56 <nineonine> does “!” have any effect on “_”
16:13:56 <nineonine> ?
16:14:09 <jle`> nineonine: it should be different i believe
16:14:15 <jle`> dmj`_: it will change everything
16:14:16 <hpc> nineonine: you can do that
16:14:21 <hpc> ghci -XBangPatterns
16:14:23 <glguy> nineonine: What happened when you tried?
16:14:24 <hpc> and then just define those
16:14:29 <hpc> it does what bang patterns do
16:14:32 <jle`> @let myfoo !_ = ()
16:14:34 <lambdabot>  Defined.
16:14:43 <jle`> > myfoo undefined
16:14:45 <lambdabot>  *Exception: Prelude.undefined
16:14:48 <jle`> sorry i was curious
16:14:54 <jle`> i didn't mean to squash nineonine's creative spark
16:14:58 <hpc> heh
16:15:21 <nineonine> ok so it forces the argument anyway
16:15:23 <hpc> having an idea like that and then discovering that it works or is already done, is reassuring in that you had a good idea to begin with
16:15:24 <nineonine> thanks
16:15:29 <hpc> (imo)
16:15:29 <jle`> nineonine: BangPatterns is sugar anyways
16:15:32 <jle`> i like to think of it as sugar
16:15:38 <jle`> thinking of it as sugar answers questions like this
16:15:46 <jle`> myfoo !x = () is sugar for myfoo = x `seq` ()
16:15:47 <nineonine> yes
16:16:04 <jle`> so it should still be x `seq` () even if you do not use the argument
16:16:29 <glguy> jle`: thinking of it as sugar adds this wrinkle:  f !_ = x becomes:   f _ = _ `seq` x
16:16:40 <glguy> \o/
16:16:46 <hpc> _ is sugar too
16:16:51 <jle`>  /o\
16:16:51 <hpc> for generating a symbol that's not being used :D
16:17:01 <hpc> it's sugar all the way down
16:17:05 <hpc> yum!
16:17:14 <dmj`_> jle`: really, what’s the killer feature
16:17:24 <glguy> hpc: so like:    f unused0 = unused1 `seq` x  ? ;-)
16:17:25 <jle`> i like to pretend that _ is an actual valid variable binding
16:17:36 <jle`> and _ is an actual valid variable name
16:17:57 <hpc> f _ _ = True -- test for equality
16:17:59 <jle`> dmj`_: basically multiple default instances
16:18:10 <jle`> hpc: but that's f = \_ -> \_ -> True
16:18:15 <jle`> checkmate underscoretheists
16:18:34 <jle`> dmj`_: so you can let users pick what default instance they want
16:18:38 <jle`> instead of enforcing just one
16:18:49 <phadej> let f x = _
16:18:50 <phadej> <interactive>:2:11: Pattern syntax in expression context: _
16:18:54 <phadej> in GHC-7.6
16:19:03 <jle`> it's also "modular" default instances too, so you can import and export them 
16:19:17 <phadej> (7.8 has holes already)
16:19:50 <jle`> maybe it's just that _ when used as a value is treated by ghc as a hole for ergonomic reasons ;_;
16:19:55 <jle`> ghc so helpful
16:20:14 <hpc> :t let f _ = _ in f
16:20:15 <lambdabot> error:
16:20:15 <lambdabot>     • Found hole: _ :: t1
16:20:16 <lambdabot>       Where: ‘t1’ is a rigid type variable bound by
16:20:35 <jle`> honestly i think one day we will see DefaultInstanceSigs as a mistake
16:20:42 <jle`> or a dead end path
16:20:59 <hpc> it's already a dead end, there's not much further to go from it
16:21:12 <hpc> the question is if it's a worthwhile end to begin with, which... not really imo either
16:21:31 <phadej> jle`: Haskell2010 says
16:21:32 <jle`> yeah, we might consider it a failed experiment
16:21:32 <phadej> Underscore, “_”, is treated as a lowercase letter, and can occur wherever a lowercase letter can. However, “_” all by itself is a reserved identifier, used as wild card in patterns
16:21:35 <hpc> i don't think features that only save typing are very useful
16:21:38 <dmj`_> jle`:  multiple default instances... so like using default in a class declaration but for different things
16:21:43 <hpc> the programmer can do that themselves by just writing functions
16:22:12 <jle`> dmj`_: as in, potential 'default' instances that have different behavior, that the user can pick from
16:22:42 <jle`> hpc: to an extent, saving typing can prevent accidental bugs
16:22:46 <dmj`_> jle`: so using type application you can choose which default instance you want ?
16:22:59 <hpc> a default instance signature says "this class doesn't just contain a common interface for things, it's also got a common implementation"
16:23:01 <jle`> not type applications, but DerivingVia syntax
16:23:04 <hpc> which... /is/ a function
16:23:29 <jle`> one common example is with ToJSON/FromJSON instances
16:23:52 <jle`> where there are many potential instances you miht want to be derived
16:23:55 <jle`> from your given data type
16:24:06 <jle`> maybe one where the identifiers are camel cased, or one where they are snake cased
16:24:08 <hpc> i think in that case it's beneficial to be explicit
16:24:13 <hpc> and write some printer combinators
16:24:20 <jle`> you can do deriving ToJSON via CamelCase, deriving ToJSON via SnakeCase
16:24:24 <hpc> or don't use a type class maybe
16:24:34 <jle`> yeah, ToJSON being a good or bad idea is another question, heh
16:25:19 <phadej> every line of explicit code can potentially introduce (consistency) bug
16:25:27 <hpc> in that case, the type class links the haskell-level expression of the information (as data)
16:25:36 <hpc> with the encoding (some json schema in particular)
16:25:36 <phadej> the more you can shovel into (more well tested) libraries out of the application code the better
16:25:47 <hpc> where that link isn't 1:1 in that way
16:26:09 <hpc> if you replace JSON with say, a table
16:26:11 <hpc> you have an ORM
16:26:19 <hpc> and ORMs are terrible, i have never seen a good one
16:26:23 <phadej> hpc: you don't need (and shouldn't) use same data for business domain and for "on-wire" format
16:26:35 <phadej> and that's exactly the problem with orm
16:26:46 <hpc> yeah
16:26:47 <phadej> if you used different types, the concerns won't be coupled
16:26:58 <hpc> you should treat it as an api boundary
16:27:04 <jle`> type classes are always a tradeoff
16:27:08 <hpc> because it is, and you actually gain a lot by thinking of it as one
16:27:19 <jle`> ToJSON/FromJSON definitely is on that boundary of a useful typeclass or not
16:27:21 <dyl> hpc SQLAlchemy is good, though not truly an ORM.
16:27:24 <hpc> your database can have multiple consumers
16:27:28 <dyl> It has one, but it's optional.
16:27:37 <hpc> your transfer format can be manipulated by other tools
16:27:50 <hpc> you can /change/ transfer formats independently of your data format
16:28:05 <jle`> my platonic ideal of a typeclass that justifies the concept for me is Ord
16:28:13 <jle`> when used with data types like Set and Map
16:28:45 <hpc> jle`: the trick there is, it doesn't matter what ordering you have when you're using a collection
16:28:47 <phadej> I pdon't see anything wrong with using type-classes for code synthesis
16:28:51 <phadej> it's *different* use
16:29:10 <jle`> hpc: yes, but the global consistency of Ord is important for the implementation of Map
16:29:31 <jle`> if the comparison function was passed as an argument, Map would be unusable
16:29:31 <hpc> phadej: the problem is type classes don't express common code, they express common interface
16:30:03 <hpc> jle`: ah that's a good point too
16:31:46 <jle`> but this is a distinct situation that most typeclasses don't fall under
16:32:10 <jle`> it's just one end on the extreme for me
16:32:16 <phadej> I see two sane solutions: either you use some "implicit" to generate encoder and decoder, and your implicit construction makes them compatible "by construction". /Or/ you have a way to write both at once
16:32:35 <phadej> In my experience, latter is way harder to engineer as a library, YMMV
16:32:39 <dyl> 'compatible'?
16:32:42 <hpc> the latter is the right way to go imo
16:32:43 <dyl> What if encode . decode != id?
16:33:09 <hpc> the idea of a unified parser/printer is a good one
16:33:34 <hpc> it expresses the right relationship without any extra unneeded constraints like uniqueness (which type classes kind of demand)
16:34:12 <jle`> using typeclasses for synthesis has its issues too
16:34:13 <phadej> dyl: I only need decode . encode = id; if wire format is not canonical, so what?
16:34:22 <jle`> as evidenced with the problems with quickcheck
16:34:24 <dyl> I don't really think decode . encode = id is actually a useful property, tbh.
16:34:26 <hpc> imagine like, a package of language lenses
16:34:40 <dyl> You want some sense of equivalence, but that 'law' isn't ever particularly helpful.
16:34:50 <hpc> you have some format spec, which gives you a unified encoder/decoder
16:34:51 <jle`> for example if i want to write data Foo = Foo Double Int, and wanted to generate test values with only doubles and ints within a given range
16:35:10 <hpc> and with that spec and some string, all you the programmer have to write is some data manipulation
16:35:12 <jle`> this can't be automaticlaly generated with typeclasses, *unless* you went in and newtype-wrapped the Double and Int fields
16:35:19 <hpc> and now you have source to source translation for free
16:35:29 <phadej> jle`: that argument is moot. You aren't testing *forall* then.
16:35:38 <dyl> hpc this sounds _very_ optimisitc.
16:35:54 <hpc> dyl: check out augeas sometime
16:35:55 <jle`> phadej: yeah, but what about situations where you aren't testing necessarily
16:36:07 <dyl> I would consider any decoder/encoder as you're describing to be pretty much trivial. 
16:36:15 <hpc> it's got some pretty major problems because of their choice of how to express recursion in the parser
16:36:20 <hpc> but it's legit
16:36:22 <dyl> You could just use GHC.Generics to achieve most of that.
16:36:32 <hpc> the unified parser/printer bit of it works perfectly
16:36:46 <dyl> ...for tree-like configuration files.
16:37:34 <hpc> sure
16:37:39 <phadej> jle`: "aren't testing"?
16:37:55 <hpc> i don't know that there's anything fundamental about the problem that makes augeas even close to the limit of what we can express though
16:37:57 <mniip> hi phadej
16:37:58 <phadej> QuickCheck is about testing, all other uses of Arbitrary are out of the domain
16:37:59 <dyl> And for any data structures which are DAG-like, you can use generics to achieve largely the same thing.
16:38:08 <phadej> i.e. *wrong*
16:38:16 <dyl> But as soon as you have references (and cycles namely), you're in bad shape.
16:38:21 <jle`> phadej: things like the Random or Variate typeclasses for System.Random or MWC.Random
16:38:45 <phadej> Random has an implicit law "generate uniform distribution"
16:38:46 <jle`> or just situations in general where you want to override the behavior of a given field
16:38:49 <dyl> I would consider any encoding/decoding problem where the data consists of topo-sortable (i.e. DAG-like) nodes with primitive leafs/values to be 'trivial'.
16:39:11 <phadej> at least i think about it that way
16:39:18 <dyl> You have key-based containers and indexed containers.
16:39:26 <dyl> You convert to that format independent of output style.
16:39:36 <dyl> output format* (e.g. JSON, XML, ...)
16:39:43 <jle`> hm, yeah, random might be a bad example too then in that case
16:39:48 <dyl> Except now you can't handle peculiarities in those formats when read in, so encode . decode = id is gone.
16:40:11 <dyl> And there's even more ambiguity when you chain encoding/decoding through different formats.
16:41:02 <phadej> but who cares about how JSON is formatted, if the document is equivalent?
16:41:05 <hpc> you'd have a hard time expressing that in any parser
16:41:12 <dyl> phadej format as in interchange formar.
16:41:17 <hpc> you'd parse the json or xml into some data structure, and then turn that into the graph
16:41:17 <dyl> Not as in indentation and spacing.
16:41:28 <dyl> JSON or XML don't natively express full graphs.
16:41:42 <dyl> Now you have to implement custom encoding/decoding, and you're no longer in trivial land.
16:41:50 <amf> does anyone have a link to writing/documentation about using EitherT (or something equivalent) to combat deeply nested if statements? I swear I've seen a number of writings, but my googling is failing
16:41:52 <dmwit> dyl: decode . encode = id is a great law. It means your encoding doesn't throw away any information.
16:42:06 <dyl> No, it doesn't.
16:42:12 <dmwit> Why not?
16:42:12 * hackage emd 0.1.4.0 - Empirical Mode Decomposition and Hilbert-Huang Transform  http://hackage.haskell.org/package/emd-0.1.4.0 (jle)
16:42:16 <dyl> It's sufficient, but not necessary.
16:42:23 <dyl> It's too strong of a condition. 
16:42:27 <hpc> but we're not talking about full graphs, or encoding for arbitrary data, only for arbitrary strings in some context-free grammar or whatever
16:42:36 <dyl> What you want is x ~ decode . encode $ x 
16:42:51 <dyl> decode . encode = id is too strong of a property.
16:42:59 <dyl> (for some equivalence ~)
16:43:00 <phadej> give an example
16:43:09 <phadej> concrete one
16:43:14 --- mode: glguy set +v DrOrange
16:43:18 <dmwit> dyl: I dunno. I frequently want = as my equivalence.
16:43:20 <hpc> one that say, parsec could handle half of
16:43:27 <dyl> dmwit then use = as your equivalence.
16:43:31 <glguy> DrOrange: Yes, beginners are welcome here.
16:44:00 <dmwit> dyl: ...Okay, I use = as my equivalence, I find this useful, and I conclude that decode . encode = id is a useful law.
16:44:17 <dyl> phadej consider an unlabeled graph (possibly with cycles), when you load it, you need some way to index/reference the nodes and edges. But depending on how it's serialized out, the ordering might be different, and you might end up with different ids.
16:44:27 <dyl> Here what I want is not "equality" but "the same shape".
16:45:11 <dyl> dmwit sure, but I don't think it's one worth baking into parsers/encoders as the default assumption.
16:45:21 <dyl> You can always strengthen if you want to.
16:45:40 <dyl> What I'm suggesting is just a weaker and, I think, more useful (w.r.t. real world usage) condition.
16:46:06 <nshepperd1> decode . encode ~ id
16:46:18 <dyl> No.
16:46:24 <dyl> x ~ (decode . encode) x
16:46:33 <dyl> The equivalence is on the values, not the functions.
16:46:39 <phadej> dyl: Nah, my data is lists of employees and what they did. Your concern is too theoretical to me.
16:46:43 <DrOrange> uUst dropping in here: How do you check for "same shape" between two graphs? And how is that different from equality?
16:46:55 <dyl> DrOrange: see graph isomorphism problem.
16:47:17 <dyl> I gave it as an example of where strong equality is 1) not very useful, 2) computationally expensive.
16:47:21 <hpc> what's stopping you from just writing your parser/printer so you get definitionally equal graphs from both ends?
16:47:28 <nshepperd1> decode . encode == id, with a suitable Eq definition on T -> T
16:47:30 <dyl> The real world.
16:47:40 <dyl> Because you're doing IO.
16:47:40 <phadej> and also (f x = x) = (f = id) fastly and losely thinking
16:47:59 <dyl> nshepperd1 Eq isn't for equivalence classes though.
16:48:02 <dyl> It's for equality.
16:48:07 <nshepperd1> Yes it is
16:48:10 <dyl> It'd be better to not overload Eq too much.
16:48:16 <nshepperd1> Look at Eq (Set a)
16:48:19 <dyl> Plus, you might be interested in different equivalence classes.
16:48:33 <phadej> then you use a newtype
16:48:45 <hpc> nshepperd1: equality isn't equality
16:48:50 <dmrd> c_wraith: Just wanted to let you know that I was finally able to get biplate (namely universeBi) working. Your example was very helpful. Thanks so much. For future reference, the core insight behind that helped me understand how to use it was realizing that I needed to provide an *explicit* type-annotation. I used to think that, if that were needed, I probably wasn't being explicit enough in my code somewhere else. Now I realize
16:48:50 <dmrd> that aint true
16:49:02 <dyl> hpc is Rudy confirmed
16:49:26 <nshepperd1> How can equality be real if our eyes aren't real
16:49:31 <dyl> Anyhow, my point is that I think `decode . encode == id` is a deceptively strong condition, and while it's one you might very well want, and should have when it's easy,
16:49:49 <dyl> it isn't essential to the parsing/encoding problem and shouldn't be such a dogmatized assumption about "good parsing and encoding".
16:51:48 <c_wraith> dmrd, ah, yes. that can happen when classes are involved. the types select behavior, so the type. needs to be specified *somewhere*
16:52:07 <DrOrange> How are guards different from simple if's? When should I use one or the other? To me it seems that a guard is just a shortcut for if, like the ternary conditional operator found in other languages
16:52:28 <dyl> If we were to let x be the wire format, and y be the abstract data structure... then let operation A be encode, operation B be decode, and let (. , .) denote equivalence under some class....
16:52:36 <c_wraith> DrOrange, well, they can fall through to a later pattern match.
16:52:38 <dyl> then we'd really want something like (Ax, y) == (x, By)
16:52:41 <dyl> ; - )
16:53:02 <c_wraith> DrOrange, which can be a lot more awkward to express in some cases.
16:53:28 <dyl> DrOrange guards are more declarative, whereas ifs are more procedural/control-flowy. 
16:54:00 <phadej> dyl: good point, as I think of it, I use `if` only in do-blocks
16:54:01 <dyl> guards look more like a piecewise function definition than a procedural thing.
16:54:08 <c_wraith> DrOrange, but in general.. I dunno. except in one-liners, I avoid if. it just feels awkward.
16:54:11 <dyl> if is flow-charty.
16:54:14 <dyl> guard is definition-y.
16:54:27 <dyl> (formal terms)
16:55:00 <phadej> multiway if is however quite declarative
16:55:13 <phadej> but it's guards!
16:55:29 <DrOrange> Coming from c++, I much prefer the if. I tried to do a factorial function with guards, and for the love of me, I couldn't make it. With ifs, it took me 30 seconds
16:56:04 <glguy> Coming from C++ you'll have a lot of things to relearn, thinking about if will just be a minor one
16:56:17 <c_wraith> the thing about if in Haskell is that it's totally redundant syntax for pattern matching. it's just awkward.
16:56:19 <phadej> let factorial n = product [1..n] ?
16:56:48 <DrOrange> phadej : I tried doing it recursively
16:57:20 <phadej> DrOrange: I'd say writing explicit recursion should be used with care
16:57:24 <nshepperd1> I consider Set.fromList . Set.toList = id to be true, given the appropriate (normal) denotation of Sets
16:58:23 <DrOrange> @glguy: Precisely why I started learning Haskell. I was told it would expand my mind about what it means to code
16:58:23 <lambdabot> Unknown command, try @list
16:58:34 <nshepperd1> It doesn't have the same operational properties as Prelude.id but so what
16:59:15 <DrOrange> phadej: why? Also how should I have written it implicitly?
16:59:58 <phadej> DrOrange: product [1..n] -- that has the recursion somewhere in it. But more importantly, it tells exactly what factorial is
17:00:14 <phadej> factorial of n is a product of 1 .. n numbers
17:00:45 <DrOrange> But it fails for n = 0. Also, that looked iterative to me
17:00:46 <phadej> Haskell is very good at making you build "vocabulary" to express solutions to your problems
17:01:28 <phadej> > product [1..0]
17:01:30 <lambdabot>  1
17:01:40 <phadej> > product []
17:01:42 <lambdabot>  1
17:02:08 <DrOrange> That's...unexpected. Sorry then, I seem to be wrong
17:02:23 <phadej> you have to try things :)
17:03:19 <DrOrange> God, it will take a while to free from those oop, declarative languages
17:03:40 <phadej> imperative*?
17:04:37 <DrOrange> I thought they are kind of synonims? Never quite understood what either meant for sure
17:04:47 <DrOrange> Always have to google them
17:05:09 <phadej> declarative is what Haskell is / tries to be
17:05:27 <phadej> wikipedia iirc explains those
17:06:44 <phadej> maybe too much information: but in haskell there is no "iteration", such things are expressed with recursion. But then recursion doesn't have limitations as it has in C++
17:07:14 <DrOrange> Ok, I already made a pretty poor impression here I guess. I've made a fool of myself
17:07:20 <phadej> no worries
17:07:33 <phadej> everyone have to start somewhere
17:07:41 <phadej> Haskell is *different*
17:07:46 <glguy> DrOrange: These are all fine questions for this channel, you're welcome back
17:08:38 <phadej> DrOrange: you can think of Haskell as the language which had Concepts 20 years ago ;)
17:08:55 <glguy> If you're going to be around a few more times it's worth registering with NickServ and you won't need to wait to be voiced to chat (we've been dealing with a wave of spam)
17:08:59 <mnoonan> for reference, "imperative" is the "do this, now do that, now do.." kind of programming. "declarative" is more like "this is the definition of X, this is the definition of Y"
17:09:22 <DrOrange> How is recursion limited in c++? I guess it's true, iteration is much more time efficient, especially for not inlined functions
17:09:47 <mnoonan> DrOrange: it's relatively easy to blow the stack using recursion in C
17:09:50 <mnoonan> (or C++)
17:10:25 <DrOrange> @glguy: I saw something about registering, but I am still very new to IRC stuff, so pretty confused here
17:10:25 <lambdabot> Unknown command, try @list
17:10:26 <mnoonan> e.g. I once wrote a recursive parser for a certain binary format (idapro). It had things like 0x00 means char, 0x01 means int, etc
17:10:39 <mnoonan> and, say, 0x02 _ means "a pointer to whatever _ decodes to"
17:10:48 <glguy> DrOrange: bookmark this for later: https://freenode.net/kb/answer/registration
17:10:51 <madnight> https://xkcd.com/1270/
17:11:07 <mnoonan> so pretty natural for recursion, right? just call your parser after the 0x02 tag, and make a pointer-to-whatever?
17:11:10 <chessandgo> is that a context free parser?
17:11:59 <phadej> as C++ was mentioned: have to mention this as well https://twitter.com/phadej/status/1031668595640680448
17:12:04 <mnoonan> but it turns out that when we ran in on emacs, we'd hit pointer types that were nested ~1000 deep, and each stack frame was a few Kb because the parsing procedure had a bunch of internal buffers and things
17:12:09 <phadej> I guess it old, but I only discovered that today
17:13:07 <mnoonan> so the recursive approach in C++, although much easier to write and reason about, didn't work at scale. I had to make and manage a heap-allocated stack to mimic the recursion.
17:13:36 <DrOrange> mnoonan: I've also blown my stack easily trying to delete recursively a linked list with 1000 elements
17:13:54 <mnoonan> DrOrange: yes, exactly!
17:14:27 <mnoonan> so I think if you do C++ (or C, or Python) long enough, you kind of get allergic to recursion. or at least suspicious of it.
17:14:27 <DrOrange> Well, why does recursion in Haskell does not have this problem? Surely, it must use a stack-like data structure, so what's the difference internally?
17:15:05 <DrOrange> I've learned to use it, but be cautious of it
17:16:09 <mnoonan> here's an explanation of why it isn't really an issue in Haskell: https://stackoverflow.com/a/43266615
17:19:01 <DrOrange> thanks, I will look over it now
17:19:04 <madnight> there is also https://stackoverflow.com/a/13052612
17:22:58 <Zipheir> DrOrange: See also tail recursion, although that's not a preferred Haskell term.
17:23:35 <dolio> If you think about it the right way, tail calls are why recursion is fine in Haskell, too.
17:23:45 <dolio> (Though, nothing to do with recursion.)
17:23:57 <ChaiTRex> Is there a way to get natVal to accept a Proxy# instead of a Proxy?
17:24:10 <mniip> jle`, hmm
17:24:11 <ChaiTRex> It complains about unlifted types.
17:24:13 <mniip> this is not enough
17:24:44 <mniip> (~) does not imply DTE.==
17:24:57 <mniip> but singletons' %== is fixated on that
17:25:11 <mniip> (albeit via PEq.==)
17:30:35 <jle`> yeah, it's really awkward
17:30:49 <mniip> I think I know a solution
17:31:58 <mniip> hmm
17:32:17 <mniip> GHC should get a flag to display coaxiom branch grouping
17:33:14 <phadej> ChaiTRex: natVal'
17:33:28 <phadej> takes Proxy#
17:33:32 <phadej> primed
17:34:54 <DrOrange> Brb
17:42:35 <DrOrange> I think I've registered alright
17:44:58 <mniip> so why are these two type family equations incompatible:
17:45:03 <mniip>   a \/ a = a    'Exactly i \/ 'Exactly j = If (EqNat i j) ('Exactly i) 'Variable
17:45:33 <mniip> where EqNat is a simplified version of equality on Nat
17:46:08 <mniip> clearly if (Exactly i) ~ (Exactly j) then i ~ j, then EqNat i j ~ True, then (If ... ~ Exactly i)
17:46:47 <DrOrange> Good night, haskell folks!
17:47:02 <DrOrange> At least here, it's night
17:50:58 <mniip> hmm
17:54:34 <mniip> example: https://lpaste.net/213220743717060608
17:54:50 <mniip> @letlpaste 213220743717060608
17:54:50 <lambdabot>  Parse failed: Parse error: <
17:55:03 <mniip> int-e, have you not yet figured out https?
17:57:58 <mniip> I think this is a GHC bug
18:00:38 <mniip> unify(<Just x, Just y>, <a, a>) = theta = [a -> Just x, y -> x]
18:01:19 <mniip> theta(If (Eql x y) (Just x) Nothing) = If (Eql x x) (Just x) Nothing = Just x = theta(a)
18:18:43 * hackage bins 0.1.0.0 - Aggregate continuous values into discrete bins  http://hackage.haskell.org/package/bins-0.1.0.0 (jle)
18:27:03 <coldpresent> why do anonymous io handlers throw type exceptions?
18:27:16 <coldpresent> getChar' =  getChar `catch` (\e -> return '\n')
18:27:38 <coldpresent> prevents the constraint ‘(Exception e0)’ from being solved
18:28:21 <coldpresent> shouldn't haskell autoinfer the correct type annotation?
18:28:29 <dolio> There's no default, probably.
18:28:38 <dolio> Do you have extended default rules turned on?
18:29:20 <jle`> coldpresent: what is the 'correct' type annotation?
18:29:22 <glguy> What's the "correct" type annotation you'd expect to be inferred?
18:29:33 <jle`> what clues do you have that would allow ghc to infer what type you want?
18:30:29 <dolio> Catch all exceptions, obviously. :)
18:30:42 <mniip> gotta catch them all
18:30:46 <dolio> Stack overflow. OOME. Whatever.
18:31:27 <glguy> Blocking"out of memory" is the economical alterative to buying more RAM
18:31:47 <coldpresent> jle`, glguy: i understand there are no clues for the compiler
18:31:53 <jle`> coldpresent: chances are if a human can't infer it, how could a compiler? :p
18:31:59 <jle`> so that's why haskell can't auto-infer it
18:32:13 <mniip> jle`, boy there are things no human can infer but ghc can :P
18:32:20 <jle`> i guess that was a bad example, heh
18:32:30 <coldpresent> right, but that code is in the official "gentle" haskell tutorial
18:32:46 <jle`> where is the official gentle haskell tutorial?
18:32:55 <dolio> The one from like 20 years ago?
18:33:06 <coldpresent> is there a way to type annotate anonymous functions?
18:33:07 <coldpresent> https://www.haskell.org/tutorial/io.html
18:33:15 <jle`> oh boy
18:33:28 <mniip> "catch                     :: IO a -> (IOError -> IO a) -> IO a"
18:33:31 <mniip> that line didn't age well
18:33:36 <jle`> yeah, that's haskell 98 apparently
18:33:46 <jle`> but yes ghc isn't 98-compatible anymore
18:33:52 <jle`> coldpresent: you're reading a tutorial for a different language, basically
18:33:56 <mniip> :t catch
18:33:57 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
18:34:06 <jle`> yeah, we should probably take down that tutorial
18:34:18 <jle`> or at least give it a much less privileged url
18:34:18 <mniip> coldpresent, with an extension you could say (\(e :: IOError) -> return '\n')
18:34:36 <mniip> without said extension, you could say (\e -> return '\n' `const` (e :: IOError))
18:34:53 <mniip> or
18:35:02 <mniip> (\e -> let _ = e :: IOError in return '\n')
18:35:10 <mniip> or actually
18:35:11 <mniip> ((
18:35:15 <mniip> ((\e -> return '\n
18:35:24 <mniip> ') :: IOError -> IO Char)
18:35:38 <mniip> sorry for the newline spam :p
18:35:40 <coldpresent> jle` oh shit
18:36:23 <jle`> dolio: hey it was last revised 18 years ago, at least ;)
18:36:37 <jle`> i guess this is what happens when a language is almost 30 years old
18:36:50 <jle`> it's hard to track down all the places to update things on the official site
18:37:41 <dolio> The gentle intro is a classic. You can't take it down. :)
18:38:10 <jle`> yeah, it should stay alive...but maybe in a less canonical url, heh
18:38:19 <jle`> Haskell is older than Java and Python combined*
18:38:45 <dolio> That doesn't seem right.
18:39:00 <jle`>     *defined using lattice join in the age pre-order
18:39:25 <dolio> Oh. So, max? :þ
18:39:30 <jle`> yup
18:39:59 <coldpresent> mniip: that last line is good
18:40:00 <coldpresent> thanks
18:40:06 <jle`> haskell is older than age of java /\ age of python
18:40:37 <coldpresent> not necessarily, haskell is younger than C
18:41:05 <mniip> so much for being the initial language in the category of languages
18:41:45 <jle`> haskell is about as old as ANSI C
18:42:46 <mniip> [...] Conditions (2) and (3) of Property 14 formalize the notion “make (B) firable again”.
18:42:52 <dolio> It's kind of depressing how old all these good langauges are.
18:43:15 <dolio> And some of them are just barely making an impact now.
18:45:28 <mniip> jle`, I found a hack that fixes this...
18:45:32 <mniip> but it introduces another issue
18:48:12 <mniip> oh
18:48:17 <mniip> and that fixes the issue
18:48:38 <mniip> https://lpaste.net/872363494823952384
18:51:10 <mniip> that breaks reduction on 'Test a Nothing' though
18:51:57 <mniip> unless!
18:53:13 <mniip> unless If gets a third equation
18:53:17 <mniip> If t a a = a
18:57:52 --- mode: glguy set +v joshuacottrell
18:58:16 <joshuacottrell> quit
18:59:34 <glguy> Anyone have a favorite library for spell-checking from Haskell I should check out?
19:05:24 <mniip> jle`, I am somewhat lost
19:07:39 <mniip> a-ha
19:07:48 <mniip> type x == y = x <= y && y <= x
19:07:52 <mniip> hahaha
19:08:59 <mniip> wait, that doesn't respect (~) does it
19:09:00 <mniip> dammit
19:11:44 <mniip> wait
19:11:53 <mniip> this was changed in singletons on just june 8th
19:13:17 <mniip> but it's not on hackage yet
19:53:32 --- mode: glguy set +v thunderseethe
19:53:55 <thunderseethe> Hello does anyone have experience with fixpoint types of multiple type variables?
19:54:24 <glguy> You're better off just asking your question. If someone can help, they will.
19:56:13 * hackage path-text-utf8 0.0.1.1 - Read and write UTF-8 text files  http://hackage.haskell.org/package/path-text-utf8-0.0.1.1 (chris_martin)
20:00:33 <thunderseethe> I'm running into an error message https://gist.github.com/thunderseethe/66ab6fa344b33098429c007c55c2ee95 where Expr thinks LValue has kind * -> * and I can't figure out why
20:05:57 <blankhart> the AssignmentExpr and LValueExpr data constructors use (LValue r) as a concrete type with kind *
20:06:38 <blankhart> oh nvm
20:07:54 <glguy> thunderseethe: I don't think the deriving logic for Functor or Generic1 is smart enough to deal with your use of Fix here
20:08:44 <glguy> It's not going to be able to guess how to derive functor for: AssignmentExpr (Fix (LValueF r)) r
20:08:52 <thunderseethe> glguy: That's very fair I would imagine the way I thread it through other fixpoints is convoluted. Should I bit the bullet and hand write functor and generic1?
20:09:16 <glguy> Hand-writing a Generic1 instance will be pretty involved
20:09:34 <thunderseethe> Yeah it did not look fun
20:09:52 <glguy> You could change the definition to this: AssignmentExpr (Compose Fix LValueF r) r
20:10:14 <thunderseethe> glguy: Okay, I'll give that a try 
20:10:58 <glguy> That helped with Generic1, but not Functor
20:11:28 <glguy> so you'd have to write Functor by hand, but that's the easier one
20:11:43 * hackage cmark-gfm 0.1.5 - Fast, accurate GitHub Flavored Markdown parser and renderer  http://hackage.haskell.org/package/cmark-gfm-0.1.5 (kivikakk)
20:12:16 * hackage spatial-math 0.5.0.1 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.5.0.1 (GregHorn)
20:19:28 <ChaiTRex> Can this be simplified? https://lpaste.net/136928037047369728
20:21:44 --- mode: glguy set +v MVQq
20:26:50 <glguy> ChaiTRex: You could probably eliminate that typeclass by implementing narrow in terms of KnownNat
20:30:02 <ChaiTRex> You mean with natVal?
20:43:47 <dmwit> :t bit
20:43:48 <lambdabot> Bits a => Int -> a
20:56:09 <glguy> ChaiTRex: I'd do something like this: https://gist.github.com/glguy/2734f88ec66b96fcd53d5a6c80ef7320
20:56:22 <glguy> That gets the same result for known natural numbers
20:57:01 <glguy> KnownNat/natVal doesn't inline well, for some reason, so this custom class ends up being needed
20:57:34 <glguy> this class would also have the advantage of allowing you to limit the instances to the range 0-63
20:59:49 <glguy> With the inlining you need for this all to make sense anyway, you might not even need to work with Word# directly
21:00:05 <c_wraith> it is certainly weird that natVal doesn't inline
21:01:25 <c_wraith> I can't see why it wouldn't inline just as well as any other class function when the type is known
21:01:49 <glguy> Well, one reason is that it's not like any other typeclass
21:02:02 <glguy> It's magical; instances are created on demand
21:02:09 <c_wraith> that's just like Coerce. :P
21:02:25 <glguy> Each one needs its own magic. Coerce doesn't actually allocate a value
21:02:33 <glguy> natVal allocates an Integer
21:02:36 <c_wraith> oh, that's true.  Coerce doesn't have evidence
21:03:09 <glguy> Magic classes like this and Typeable tend to try and reuse the magic value at least per module
21:03:25 <glguy> so maybe it doesn't account for cases where inlining the number would be more efficient
21:05:44 <glguy> Oh man, MarcelineVQ caved in and registered!
21:06:00 <ChaiTRex> glguy: Thanks1 Still looking it over.
21:08:02 <MarcelineVQ> glguy: I feel abused
21:09:23 <c_wraith> what hath spammers wrought?
21:40:43 * hackage softfloat-hs 0.1.0 - Haskell bindings for SoftFloat  http://hackage.haskell.org/package/softfloat-hs-0.1.0 (benselfridge)
22:00:29 <wchresta> Is there a way to document type level parameters with haddock? Something like forall n -- ^ doc
22:02:02 <monochrom> I think no. But people use suggestive names, e.g., in parser libraries they have "between :: Parser open -> Parser close -> Parser between -> Parser between"
22:02:38 <wchresta> Cool, thanks
22:15:09 --- mode: glguy set +v thunderseethe_
22:15:19 <thunderseethe_> Hello, I'm having an issue with the prettyprinter library https://gist.github.com/thunderseethe/15a42d501f1eaf7a53ca343124e27bf0 is there a way around this?
22:25:16 <jle`> thunderseethe_: no, that's the thing about the Pretty class
22:25:35 <jle`> it's probably an explicit design decision that is taken advantage of
22:26:34 <thunderseethe_> jle`: is there a way I can work around it? Perhaps define my data differently
22:26:51 <jle`> what do you want to do exactly?
22:27:49 <jle`> in the big picture?
22:28:51 <thunderseethe_> jle`: I have an ast with a big fix point type Expr ultimately I'd like a catamorphism that pretty prints my Expr and part of that is threading the Fix point type into the various sub types that contain it (unless there is a better way to do this)
22:30:04 <thunderseethe_> So I have a catamorphism Expr (Doc ann) -> Doc ann and then all my sub types (FieldCreate, LValue, Declaration, etc.) need pretty instances assuming that the expressions they contain have already been turned into (Doc ann) by the catamorphism
22:41:56 <glguy> thunderseethe_: write this function outside of an instance declaration and then use that function to implement the Pretty instance
22:43:21 <thunderseethe_> glguy: I attempted that, and I get the same error. I did it with a signature, should I forego the signature and let it be inferred?
22:43:56 <glguy> Then you might have have a different error to fix
22:44:25 <glguy> What's the version that doesn't use an instance?
22:46:38 <thunderseethe_> glguy: Actually I think I was misunderstanding you, you're saying just don't have a pretty instance for the auxiliar functions at all and instead use a helper function
22:46:52 <thunderseethe_> Auxiliary dataypes*
22:51:11 <mniip>   ooh
22:51:16 <mniip> :reload!  is nifty
22:57:39 <jle`> nice tip :)
23:00:24 <dminuoso> Is it sane to newtype wrap Text to trace things like "uid" through the application?
23:01:15 <dminuoso> I feel that just raw `Text` allows accidentally shoving in wrong values, and it requires haddock annotations left and right to know what `Text` means in some cases.
23:01:35 <arahael> As a novice haskeller, I've been trying to do that a lot.
23:01:56 <monochrom> Ah yes, I advocate that. But it can be inconvenient. You decide whether it's worth the effort.
23:02:01 <arahael> Mainly because it's so easy to do "Type Uid = Text" in Haskell.
23:02:25 <dminuoso> arahael: type aliases are not so useful
23:03:02 <monochrom> Aliasing is fake abstraction. :)
23:03:09 <cocreature> I newtype most uses of Text
23:03:33 <dminuoso> cocreature: Do you generally coerce or wrap/unwrap?
23:03:35 <arahael> Even "newtype Uid = Text" is much easier in Haskell.
23:03:58 <cocreature> dminuoso: wrap/unwrap (unless I actually have a list of things so coerce provides a benefit)
23:04:04 <dminuoso> arahael: Well it would be `newtype Uid = Uid Text` but yes :)
23:04:21 <monochrom> Oh hey, these days there is also the Backpack module system, which is like SML's, so you don't have to newtype-wrap, you gain the same safety and abstraction. :)
23:04:34 <arahael> dminuoso: :)
23:05:52 <monochrom> So, you write an "interface module" that only declares an undefined type UID (just declare this type name) and lists the type sigs of a bunch of UID operations.
23:06:24 <maerwald> tdammers: ping
23:06:47 <monochrom> Your UID-using module imports that interface module. So now it can't use the implementation detail of UID.
23:07:55 <monochrom> You have an "implementation module" that implements those operations and you can simply say "type UID = Text" and this type alias is actually safe and abstract because the UID-using module isn't even importing it.
23:08:37 <monochrom> And you set them up in a right kind of directory division, and then "cabal new-build" will figure it all out.
23:09:12 <monochrom> (Easier said than done but meh.  It's not too bad, I did this exercise once.)
23:10:52 <monochrom> OK actually there is one missing piece.  One of the *.cabal files need to say which module is the implementation module.  Because actually you can have multiple implementation modules lying around, and you have to say which one to go for somewhere.
23:14:11 <cocreature> monochrom: not sure backpack plays well with your “just use ghc directly instead of cabal-install/stack”-advice :)
23:14:39 <monochrom> Ah yes but that's conditional on "cabal is giving you a problem?".
23:14:51 <monochrom> Here, it's more like "cabal is giving you a solution!"
23:31:18 <coldpresent> what should I do when my constraint is ambiguous? for `readsTree` of https://www.haskell.org/tutorial/stdclasses.html
23:32:34 <coldpresent> i want the function to build all trees polymorphic type a, but haskell doesn't like that
23:34:53 <cocreature> coldpresent: can you show us the actual code that you have and the full error message?
23:37:17 <koz_> jle`: I thought you'd find this interesting/amusing: https://arxiv.org/abs/1808.05789
23:45:28 <coldpresent> cocreature: https://gist.github.com/zhengqunkoo/28fc267376e08d0acfa5ecd9f02b77d8
23:49:24 <liste> coldpresent: without a type annotation, ghc tries to monomorphize your functions
23:49:44 <liste> coldpresent: https://wiki.haskell.org/Monomorphism_restriction
23:51:50 <johnw> anyone know why servant might be ignoring an "Accept Foo" instance? It doesn't seem to ever be called
23:52:26 <cocreature> coldpresent: you need to add a type annotation to specify what type of trees you want to decode to, e.g., readsTree "<1|<2|3>>" :: [(Tree Int, String)]
23:52:39 <cocreature> ghci has the somewhat weird behavior of defaulting to [(Tree (), String)] in this case
23:52:45 <cocreature> which fails since the numbers don’t parse as ()
23:52:49 <cocreature> ghc just complains
23:53:39 <cocreature> it doesn’t really make sense to give rt1/rt2 a polymorphic type since you won’t be able to decode the numbers to some arbitrary type
23:53:55 <alp> johnw, you've got an accompanying MimeRender/MimeUnrender instance or more that could do the encoding/decoding part of content type handling?
23:54:07 <johnw> alp: hi!
23:54:15 <alp> hello :)
23:54:17 <johnw> alp: I have a MimeRender instance only
23:54:38 <alp> that's ok if you will only ever do e.g Get '[Foo] SomeType
23:54:45 <alp> and not ReqBody '[Foo] SomeType :> ...
23:54:46 <johnw> https://gist.github.com/44a523fb61e79b8cdd726311b3c1ef98
23:54:59 <johnw> I'm only using it with 'StreamGet NewlineFraming EventStream'
23:54:59 <alp> (on the server side. for clients it's the opposite)
23:55:06 <johnw> (server side)
23:55:18 <johnw> i'm adding tracing to servant-server now
23:55:23 <alp> oooh
23:55:27 <johnw> because I keep getting 406
23:55:55 <coldpresent> litse, cocreature: right, polymorphic in function definition, but monomorphic when i use the function. got it!
23:56:32 <coldpresent> s/litse/liste
23:58:18 <cocreature> coldpresent: in general, it also might make sense to have the result be polymorphic when you use a polymorphic function. it just happens that in this case, the argument you pass already restricts the type parameter (to things that have a Read instance that can parse integers) so making it polymorphic is misleading even if it typechecks
23:58:47 <alp> johnw, I don't see anything wrong in your paste. is the program closed source?
23:58:58 <johnw> for now, yes
23:59:30 <coldpresent> cocreature: and that typecasting to Int prevents it from autocasting to ()?
