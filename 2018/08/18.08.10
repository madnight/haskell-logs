00:01:43 <ab9rf> MarcelineVQ: i really hate watching videos but i'll consider it
00:02:13 <ab9rf> at the moment i'm trying to come up with a use case for Cons where s and t are not the same type
00:02:41 <cocreature> ab9rf: the slides work quite well on their own iirc
00:02:53 <[exa]> do the video tutorial authors consider that people with hearing/vision deficiencies can't access the information?
00:03:27 <ab9rf> [exa]: for me it's the fact that i have an auditory processing disorder
00:03:46 <ab9rf> attmepting to learn things from spoken word is nearly impossible
00:03:47 <MarcelineVQ> most vids are talks where the vid is an afterthought anyway, otherwise there'd be better audio
00:04:21 <ab9rf> it's all i can do just to process what is being said
00:04:43 <ab9rf> i'd rather simply have a transcript
00:05:01 <ArahaelPi> [exa]: They rarely do. :(
00:05:03 <ab9rf> if there are decent subtitles i can use that, but most of the time the subtitles are crap
00:05:13 <[exa]> also, I can't reasonably watch the 11minute video on 10minute subway ride
00:05:15 <[exa]> etc
00:06:08 <[exa]> ab9rf: a friend of mine was solving that just by mechanically writing what he hears down and then learning from that, which worked... in turn he produced probably the best lesson hand-outs we have here
00:06:24 <ArahaelPi> I'm deaf, incidentially, so that wouldn't work for me.
00:06:24 <ab9rf> [exa]: that's how i survived law school, basicall
00:06:45 <ab9rf> [exa]: although my notes were usually illegible
00:06:55 <[exa]> :]
00:07:08 <ArahaelPi> Which makes this current trend towards videos a bit frustrating, and also why I find myself moving away from the .NET community, as they seem to *love* videos.
00:07:15 <ab9rf> it was the proecss of writing them that was important; reading them later didn't matter
00:07:37 <ab9rf> ArahaelPi: its not just .NET, everyone s moving in that direction
00:07:51 <ArahaelPi> It's really frustrating.
00:07:54 <[exa]> ArahaelPi: luckily the trend to do videos kindof correlates with technologies that just suck (which .net does)
00:08:22 <ab9rf> there's subtle discriminatory processes involved there, too
00:08:28 <Ariakenom> where's my fire emoji when I need it
00:08:40 <ab9rf> you can tell that a person is female or a POC from a video
00:08:47 <ab9rf> that may not be as obvious from a written document
00:09:40 <liste> videos are so inefficient for learning
00:09:44 <[exa]> ......but perhaps the video authors can't write and we're discriminating them! :]
00:09:57 <ab9rf> it also reinforces stereotypes thar are already pretty strong in many tech communities
00:09:59 <liste> are people too lazy to read these days or something?
00:10:24 <ab9rf> liste: well, yes, but that's not new
00:10:33 <ab9rf> the majority of people have always been too lazy to read
00:10:37 <ArahaelPi> Indeed - yes, but apparently not new.
00:10:43 <ab9rf> the fact that you're on an IRC channel indicates that you're in the minority that isn't
00:10:52 <liste> but as a developer you kinda need to read. a lot
00:11:10 <ArahaelPi> liste: Depends.
00:11:24 <ab9rf> i know lots of developers who don't care to read
00:11:38 <ab9rf> i know one who was extremely good, but also violently dyslexic
00:11:40 <ab9rf> for him reading was painful
00:11:49 <ab9rf> i do not know how he managed to code, but he did
00:11:51 <ArahaelPi> liste: I know devs who don't read much, and apparently don't care to learn new things.
00:12:05 <[exa]> code's more picture-ish than textish (if it's not java)
00:12:21 <ab9rf> [exa]: he reported having a weird synethesia
00:12:43 <ab9rf> like for him varialbes were different colors on the screen
00:12:52 <ab9rf> even though he was using a monochrome monitor
00:13:04 * [exa] needs to afk, thanks very much for opinions though :]
00:13:06 <cocreature> there is nothing wrong with preferring videos as your learning material. not everyone has the same preference when it comes to learning new things
00:13:30 <ArahaelPi> Some devs I know read a *ton*, but they will also watch a good video if they come across one.
00:13:42 <ArahaelPi> And I can see that they "get" the concepts when expressed verbally, if reading hasn't worked.
00:14:07 <ab9rf> i've had times where a visual representation has assisted in understanding a thing
00:14:47 <ab9rf> but a slideshow is usuaully enough for that
00:15:10 <ab9rf> anyhoo
00:18:15 <dminuoso> Im currently trying out various things with my build setup, and it's so painfully slow when cabal new-build has to rebuild all dependencies.
00:18:23 <dminuoso> Is there a way to have new-build build dependencies with -O0?
00:21:11 <cocreature> dminuoso: I think if you put "package *\n  optimization: False" in your cabal.project file it tries to do that but packages that put -O2 in their ghc-options will still be built with -O2 iirc
00:24:13 * hackage hyraxAbif 0.2.3.9 - Modules for parsing, generating and manipulating AB1 files.  http://hackage.haskell.org/package/hyraxAbif-0.2.3.9 (andrevdm)
00:35:13 * hackage bhoogle 0.1.3.4 - Simple terminal GUI for local hoogle.  http://hackage.haskell.org/package/bhoogle-0.1.3.4 (andrevdm)
00:46:16 <Ariakenom> I think I found some of the cause for my missing graphics https://github.com/bos/criterion/issues/65 . It's floats :]
00:50:36 <taumuon> dibblego: I need a hint regarding implementing headOr with foldr
00:51:04 <dibblego> taumuon: the key is understanding what foldr actually does
00:52:00 <dibblego> taumuon: if you take a list, such as list = (a : b : c : d : []), then you (foldr f z list), the value returned is (a `f` (b `f (c `f (d `f` z))))
00:52:25 <dibblego> taumuon: specifically, foldr f z list, replaces in list, every occurrence of (:) with (f) and [] with (z)
00:52:39 <dminuoso> taumuon: https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
00:52:46 <dminuoso> Nicely visualizes this =)
00:52:56 <dminuoso> Do note though, that this only applies for list.
00:53:29 <dibblego> given this, what might you replace (:) and [] with in a list, for headOr
00:54:57 <taumuon> well the [] seems to wamt the fallback value
00:55:15 <dibblego> I agree :)
00:59:25 <taumuon> f... const? 
00:59:38 <taumuon> hmm
01:00:20 <dminuoso> taumuon: mind my asking, what is headOr supposed to do?
01:00:48 <dminuoso> `headOr :: a -> [a] -> a` ?
01:01:31 <taumuon> headOr :: a -> List a -> a
01:01:36 <trcc> https://github.com/data61/fp-course/search?q=headOr&unscoped_q=headOr dminuoso
01:01:37 <dminuoso> Close enough =)
01:02:16 <taumuon> OK I believe it is const, yay?
01:02:27 <dminuoso> taumuon: Test your beliefs!
01:02:35 <dminuoso> Turn religion into science.
01:02:53 <taumuon> there are no gods round these parts
01:04:21 <taumuon> >let headOr = foldr const
01:04:34 <taumuon> > let headOr = foldr const
01:04:37 <lambdabot>  <no location info>: error:
01:04:37 <lambdabot>      not an expression: ‘let headOr = foldr const’
01:04:47 <dminuoso> taumuon: use @
01:04:58 <dminuoso> @let headOr = foldr const
01:05:00 <lambdabot>  Defined.
01:05:08 <dminuoso> > is for evaluating an expression
01:05:10 <lambdabot>  error:
01:05:10 <lambdabot>      • Variable not in scope:
01:05:10 <lambdabot>          is :: ([a0] -> (a0 -> f0 b0) -> f0 [b0]) -> t0 -> t1 -> t2 -> t
01:05:14 <taumuon> thanks
01:05:16 * dminuoso spanks lambdabot
01:05:28 <taumuon> > headOr "a" []
01:05:31 <lambdabot>  "a"
01:05:36 <taumuon> > headOr "a" "b"
01:05:38 <lambdabot>  error:
01:05:38 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
01:05:38 <lambdabot>        Expected type: [[Char]]
01:05:46 <taumuon> > headOr 'a' "b"
01:05:48 <lambdabot>  'b'
01:06:01 <taumuon> > headOr 'a' ""
01:06:03 <lambdabot>  'a'
01:06:20 <taumuon> that's pretty neat
01:07:30 <trcc> headOr 'a' "bcd"
01:07:33 <trcc> > headOr 'a' "bcd"
01:07:36 <lambdabot>  'b'
01:07:42 <dminuoso> trcc: On that note, try reversing a list with folds!
01:07:49 <dminuoso> Err I meant taumuon of course.
01:07:51 <dminuoso> :)
01:09:15 <dminuoso> taumuon: It's possible with foldr and foldl, but it's probably easier with foldl. 
01:13:48 <taumuon> @let revv = foldl (flip (:)) []
01:13:49 <lambdabot>  Defined.
01:13:58 <taumuon> > revv "abcd"
01:14:00 <lambdabot>  "dcba"
01:14:29 <dminuoso> taumuon: if you are feeling extra brave, you can try it with foldr now (ideally without googling)
01:14:58 <taumuon> ok no googling.
01:15:05 <taumuon> this may take a while haha
01:15:17 <dminuoso> taumuon: If you cant solve it, write it down for later. It's a neat little excercise.
01:15:29 <taumuon> will do
01:17:58 <cocreature> or go all the way and implement foldl using foldr once and then you can stop worrying about how you express things using foldr if you have a solution using foldl :)
01:18:55 <liste> do others read foldr as "folder" ?
01:19:06 * dminuoso nods
01:19:32 <trcc> liste: not me. I read it as foldR
01:19:41 <dminuoso> trcc: What'
01:19:44 <dminuoso> trcc: What's the difference?
01:20:03 <lavalike> fold-yarr without y
01:20:09 <cocreature> lavalike++
01:20:20 <cocreature> fold it like a pirate
01:20:21 <trcc> dminuoso: fold and then pronounce the letter R
01:20:25 <trcc> hehe ye sort of
01:20:28 <dminuoso> trcc: Ah, I do something in between heh.
01:20:34 <liste> foldr.io, a hip new folding startup
01:20:36 <lavalike> @yarr
01:20:36 <lambdabot> Arrr!
01:20:40 <trcc> haha
01:20:47 <dminuoso> liste: does it have a blockchain?
01:21:02 <liste> dminuoso: they're doing ICO soon
01:21:09 <taumuon> reminds me of the startups that take out vowels for their brand names so they can use a pretty domain name.  foldr:  we fold your underwear better than you do
01:21:41 <taumuon> oh someone beat me to itt hehe
01:21:55 <taumuon> ^^;;
01:22:00 <dminuoso> Look at that. https://foldr.io/ is a thing and it has cloud!
01:22:09 <cocreature> but no blockchain
01:22:11 <cocreature> and no ai
01:22:18 <dminuoso> cocreature: you mean *deep neural networks
01:22:25 <dminuoso> ai is so 1990
01:22:56 <cocreature> I had the impression the term was growing in popularity recently again
01:23:13 <dminuoso>  https://spideroak.com/semaphor/
01:23:26 <dminuoso> By the way! Blockchain based messaging, will blow slack out of the sky.
01:23:43 <dminuoso> "blockchain encryption"
01:23:59 <merijn> You mean "Merkle lists"
01:24:14 <cocreature> I wonder what will happen to all those Haskell jobs if the blockchain hype dies
01:24:42 <merijn> cocreature: They'll go into Tesla, Facebook and banks :p
01:25:05 <dminuoso> So what other hip tech do I need to have and advertise to make a proper startup?
01:25:10 <cocreature> merijn: that would be the pleasant option. the sad option is that they go back to writing js
01:25:16 <dminuoso> Obviously it needs to be developed with "best practices"
01:25:37 <merijn> cocreature: There's slowly more and more banks adopting Haskell in their fintech/R&D departments
01:25:58 <cocreature> merijn: oh nice, I haven’t heard of a new one in quite some time
01:26:20 <merijn> cocreature: Barclays should be up and running now
01:26:23 <taumuon> where do you start with haskell when you're a huge company?
01:26:53 <merijn> cocreature: I don't see them mentioned often, but 1 or 2 years ago I got contacted by a recruiter for a Haskell team they were setting up
01:26:55 <dminuoso> taumuon: what do you mean with "where do you start"
01:26:59 <dminuoso> taumuon: You just start writing software.
01:27:00 <cocreature> merijn: I thought one of their Haskell teams already died off? I might be misremembering things
01:27:20 <dminuoso> taumuon: The advantage of being a big company, is that you can afford to train people in whatever tech you want.
01:27:43 <merijn> cocreature: I dunno?
01:27:43 <dminuoso> The main issue in Haskell is not getting it into existing infrastructure, it's finding people.
01:28:10 <dminuoso> Since there's very few haskell developers, the big companies can a) afford to hire the few available people, and b) afford to train new people
01:28:33 <cocreature> merijn: I vaguely recall talking to people about that at zurihac but I might be mixing things up :)
01:28:33 <merijn> The real trick is to just write a quick one of tool in Haskell and then only let them find out after they've been using it for a bit :p
01:28:46 <taumuon> haha yep
01:29:02 <dminuoso> merijn: You mean after they really like the stability and quality of the product?
01:29:13 <merijn> dminuoso: There's a lot more people *wanting* to program Haskell, than jobs though. And a lot of them are willing to take a paycut to write it over something else
01:29:27 * dminuoso nods
01:29:49 <taumuon> doen't haskell jobs pay more on average?
01:30:14 <dminuoso> taumuon: Im not sure whether that's actually a Haskell issue.
01:30:16 <taumuon> or are you talking about seniors taking the jr haskell jobs?
01:30:42 <dminuoso> taumuon: It may be related to the fact where Haskell may be used often, and that it's usually the more educated folks that end up with such jobs
01:31:18 <dminuoso> as opposed to say webdev that's infested with low quality software and low quality developers
01:31:23 <dminuoso> that brings low wages
01:31:41 <dminuoso> on average anyway
01:31:42 --- mode: glguy set +v ventonegro_
01:32:13 <taumuon> yep i have some experience with that.
01:33:27 --- mode: glguy set -v ventonegro
01:34:00 <ventonegro> testing, 1, 2, 3
01:36:13 * hackage edges 0.10 - Tools for efficient immutable graphs  http://hackage.haskell.org/package/edges-0.10 (NikitaVolkov)
01:37:13 * hackage liszt 0.1 - Append only key-list database  http://hackage.haskell.org/package/liszt-0.1 (FumiakiKinoshita)
01:41:57 --- mode: glguy set +v caht
01:42:06 <caht> +v
01:43:07 <caht> how to install intero using stack?
01:44:21 <caht> join #haskell
01:44:31 <dminuoso> caht: It should be installed automatically by emacs.
01:44:55 <dminuoso> caht: How did you install intero to emacs?
01:45:33 <caht> dminuoso : I am using VS Code, and while installing using stack it  throws error and stops
01:46:21 <dminuoso> caht: Not familiar with VS Code (that's Haskelly, isnt it?)
01:46:31 <dminuoso> caht: can you gist the error you are getting?
01:48:41 <caht> dminuoso : https://gist.github.com/maheshuligade/1d3f7c846cbdb7e49a18b97327964d91
01:49:33 <dminuoso> caht: Does your project have a custom `containers`?
01:49:41 <dminuoso> caht: https://github.com/commercialhaskell/intero/issues/565
01:50:31 <caht> dminuoso : am trying to install globally, and I don't know about the custom containers?
02:04:45 <koz_> This is a _little_ off-topic, but I figured someone here might know: in [some old language I dunno], quad -> 4, octa -> 8, ??? -> 16?
02:05:16 <koz_> Well, it's a prefix based on some old language I dunno, but still, what would ??? be?
02:05:19 <xacktm> hexa
02:05:21 <xacktm> ?
02:05:35 <jesyspa> Something like hexadec, I'd say.
02:05:54 <ab9rf> hexadeca
02:06:08 <koz_> OK, thanks.
02:06:13 * koz_ goes back to drawing board.
02:06:24 <ab9rf> that, or sede
02:07:02 <ab9rf> based on the fact tat the 16-dimensional algebra analogous to the 8-dimensional octonions are clled sedenions
02:07:13 <koz_> Hmmm, that works.
02:07:17 <ab9rf> sedeword
02:07:28 <koz_> That's what AVX operates on.
02:08:12 <ab9rf> i've never seen that used, but i've never seen anyone try to assign a name to a 256 bit integer
02:08:21 <koz_> Gotta be a first time for everything right?
02:08:25 <jesyspa> https://en.wikipedia.org/wiki/List_of_polygons#Systematic_polygon_names has some suggestions.
02:08:56 <koz_> hekkadeikaword. :P
02:09:03 <koz_> (almost looks Finnish)
02:10:03 <p0lyph3m> hex is greek , sede is latin , hexadecimal is mixed greeklatin :(
02:10:13 <ab9rf> a 128-bit integer has been called an octaword from time to time
02:10:30 <koz_> p0lyph3m: Yeah, I know about the mixed Greco-Latin of 'hexadecimal'.
02:10:51 <p0lyph3m> sedecimal 
02:10:53 <koz_> This actually led someone who loves ternary arithmetic to name the ternary equivalent 'heptavintimal'.
02:10:54 <Logio> Finnish doesn't bother with the silliness though, we just call n-gons n-kulmio's :P
02:11:14 <koz_> Logio: Finnish also doesn't loan from dead languages like it was going out of fashion. :P
02:11:51 <Logio> Exactly the silliness I'm referring to 
02:11:52 <ab9rf> english is constitutionally required to steal words from other languages
02:12:27 <koz_> ab9rf: Yeah, preferably across different time periods.
02:12:31 <koz_> Just to confuse people more.
02:12:38 <Logio> I wonder how much easier it must be to learn human anatomy in Finnish compared to the latin mess that doctors in anglo countries need to learn
02:12:52 <koz_> Logio: Know any Finnish doctors?
02:12:54 <ab9rf> koz_: and as inconsistently as possible
02:13:04 <koz_> ab9rf: Yup.
02:13:10 <Logio> koz_: none personally enough to ask 
02:13:18 <koz_> Logio: Oh well, maybe in the future.
02:13:45 <koz_> data SedeWord = SedeWord Word64 Word64 Word64 Word64.
02:13:49 <koz_> PRAY FOR ME.
02:13:54 <Logio> but most bones at least have perfectly reasonable names in Finnish, whereas in English you've invaded Gaul three times by the time you've finished learning them
02:14:12 <AWizzArd> I have  `class RMonad m where type RMonadCtxt m a :: Constraint  ...` and at the top of my file I put {-# LANGUAGE ConstraintKinds #-}. Yet „Constraint” is still underlined in Emacs and I get a „Not in scope: type constructor or class ‘Constraint’” error.
02:14:33 <ab9rf> AWizzArd: have you tried a goat?
02:14:45 <koz_> ab9rf: Is this a reference to something?
02:15:01 <Logio> koz_: what unholiness are you up to with those words of power? 
02:15:11 <ab9rf> often, solving programming issues is facilitated by the blood of a freshly slaughtered virgin goat
02:15:22 <koz_> Logio: The _short_ explanation is that I'm writing a dynamic SIMD assembler in Haskell.
02:15:32 <Logio> neat
02:15:42 <koz_> The slightly-longer explanation is that I'm showing how a certain problem can be accelerated into the next millenium by doing said thing.
02:15:58 * koz_ is working on a special topic paper for the IEEE Transactions on Evolutionary Computation.
02:16:29 <cocreature> koz_: oh that sounds very cool! is the idea to use that as some kind of jit compiler?
02:16:39 <koz_> cocreature: Not exactly. It's a bit more specific than that.
02:17:00 <koz_> Basically, my idea is to construct a special-purpose indexer in JITed SIMD assembly.
02:17:08 <koz_> And then use that to drive the core computation.
02:17:15 <koz_> It has to be done dynamically because the nature of the query changes.
02:17:39 <cocreature> interesting, let me know when you’ve written the paper :)
02:17:41 <koz_> I'll let you folks read the draft paper when I have something readable - deadline's November, so I've got time.
02:17:49 <Ariakenom> "Evolutionary Computation" "next millenium" So only 5 billion left?
02:17:55 <koz_> Ariakenom: Lol.
02:34:56 <pgiarrusso> AWizzArd: you also need an import for Constraint I think, it’s somewhere in base
02:36:38 <merijn> AWizzArd: You need to import Constraint for GHC.Exts
02:37:05 <pgiarrusso> merijn: thanks for filling in
02:39:51 <Profpatsch> From the GHC user manual:
02:39:54 <Profpatsch> Package version selection: When selecting a package, GHC will search for packages in all available databases. If multiple versions of the same package are available the latest non-broken version will be chosen.
02:39:56 <Profpatsch> Version conflict resolution: If multiple instances of a package version chosen by GHC are available then GHC will choose an unspecified instance.
02:40:14 <Profpatsch> What is a “package” in this context? I’m missing the definition.
02:40:25 <merijn> Profpatsch: A package as in those installed by Cabal
02:40:27 <Profpatsch> Is it the ID? The Name? 
02:40:45 <Profpatsch> merijn: No, we are on the GHC package level here.
02:41:00 <Profpatsch> Essentially the stuff that `ghc-pkg list` shows.
02:41:16 <merijn> Profpatsch: Yes, that's what Cabal manages
02:41:32 <Profpatsch> untrue, but not to digress;
02:41:55 <dminuoso> AWizzArd: You have to import Constraint from Data.Kind
02:42:08 <dminuoso> % import Data.Kind (Constraint)
02:42:09 <Profpatsch> well, “manages” is maybe right, but not defines and handles. 
02:42:09 <yahb> dminuoso: 
02:42:33 <Profpatsch> We have a client that has multiple (different) packages named “types” in his repo.
02:42:33 <dminuoso> % set -XTypeFamilies
02:42:33 <yahb> dminuoso: ; <interactive>:60:6: error: Data constructor not in scope: XTypeFamilies :: ASetter s t a b -> b -> s -> t
02:42:39 <Axman6> %:kind Show
02:42:51 <Profpatsch> And seems to have problems with that colliding by name.
02:42:55 * Axman6 doesn't know how yahb works
02:43:07 <dminuoso> % :set -XTypeFamilies
02:43:07 <yahb> dminuoso: 
02:43:13 <dminuoso> % class RMonad m where type RMonadCtxt m a :: Constraint
02:43:14 <yahb> dminuoso: 
02:43:30 <Profpatsch> But it’s not clear from the docs how GHC selects packages in that case. 
02:43:53 <dminuoso> Axman6: I think it needs a space after the %
02:43:56 <dminuoso> % :kind Show
02:43:56 <yahb> dminuoso: Show :: * -> Constraint
02:44:07 <Axman6> :thumbsup:
02:44:13 * hackage nqe 0.1.0.1 - Concurrency library in the style of Erlang/OTP  http://hackage.haskell.org/package/nqe-0.1.0.1 (xenog)
02:44:49 <dminuoso> merijn: By the way I finally did it - I kicked stack, and I even got rid of hpack'ing yaml files. Just bare cabal now. :)
02:50:43 * hackage dhall-to-cabal 1.3.0.1 - Compile Dhall expressions to Cabal files  http://hackage.haskell.org/package/dhall-to-cabal-1.3.0.1 (OliverCharles)
02:57:30 <madnight> dminuoso: without nix?
02:58:53 <dminuoso> madnight: Yeah. Nix is too steep and thick for me to worry at the moment.
02:59:17 <merijn> madnight: tbh, new-build is much easier than learning a whole new tool
02:59:23 <dminuoso> Ive spend an absurd amount of time learning new tech, so it's time to get productive. Ill probably revisit nix later. :)
02:59:30 <AWizzArd> dminuoso: okay one sec, will try that
02:59:42 <madnight> i mean getting rid of stack is a great relief for many haskell dev's, but you somehow need to handle the install of multiple ghc / lib versions
02:59:48 <dminuoso> merijn: Want to see something cool?
02:59:59 <AWizzArd> dminuoso: great, now it works.
03:00:02 <dminuoso> merijn: https://github.com/dminuoso/cabal-new-run-bug
03:00:12 <dminuoso> https://gist.github.com/dminuoso/ffadea142d47d8ffa6bf092aed4907cf
03:00:25 <merijn> madnight: new-build eliminates worrying about multiple lib versions
03:00:43 <madnight> merjin: link?
03:00:45 <dminuoso> Non-deterministic behavior of new-run =)
03:00:45 <merijn> madnight: So you only need to "handle" multiple GHCs, which I honestly just do via the age old "change my $PATH"
03:01:04 <merijn> madnight: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
03:01:25 <dminuoso> dmwit: ^- by the way. Not sure whether I can reduce it further.
03:01:55 <merijn> madnight: new-build is basically Nix inspired dependency management for packages, so like Nix it's as if every new-build project is automatically sandboxed, except you also get packages shared across sandboxes were possible
03:02:58 <AWizzArd> dminuoso: I am seeing this example, at the end of the page: https://kseo.github.io/posts/2017-01-13-constraint-kinds.html
03:03:17 <AWizzArd> Wouldn’t it be also okay to have    type RMonadCtxt m :: Constraint ?
03:03:30 <AWizzArd> And then   (>>=) :: (RMonadCtxt m, RMonadCtxt m) => m a -> (a -> m b) -> m b
03:03:32 <merijn> madnight: It's not entirely polished and done yet, but I've been using solely new-build for the past year or so, and it's pretty sweet
03:03:43 <AWizzArd> The one parameter could go away, no? Or is this semantically different?
03:03:58 <dminuoso> AWizzArd: think about what `m` is.
03:04:12 <dminuoso> AWizzArd: `m` is the type variable that gets substituted for the type you write instances for.
03:04:31 <madnight> i'm not so sure about that, "Nix-style" is not nix
03:04:58 <dminuoso> AWizzArd: so what would `type RMonadCtxt m :: Constraint` even mean?
03:05:01 <AWizzArd> dminuoso: the thing is: the variant where the family has only a single parameter compiles.
03:05:33 <merijn> madnight: It's not, but I can't be arsed learning a new tool with a ton of setup and hassle like Nix. Whereas new-build just solves the only real problems I had with cabal-install with like 20 lines of documentation
03:05:35 <AWizzArd> `m` is the monad for which I want to implement RMonad.
03:05:36 <dminuoso> % class Foo (m :: Constraint)
03:05:36 <yahb> dminuoso: 
03:05:43 <dminuoso> Oi. This works? :o
03:05:56 <madnight> merjin: nix is a general purpose "tool" that could solve packaging once and for all for all programming languages
03:06:00 <dminuoso> % instance Foo (Show Int)
03:06:00 <yahb> dminuoso: 
03:06:13 <dminuoso> This is.. kind of.. cool? 
03:06:23 <madnight> so you learn nix once and can use it for everything, cabal can only be used for haskell
03:06:26 <AWizzArd> dminuoso: I would expect the family to work.
03:07:03 <madnight> i tend to favour general solutions (or let's say higher abstractions) for one and the same problem
03:09:25 <dminuoso> AWizzArd: I think I misunderstood the whole thing completely.
03:10:17 <dminuoso> AWizzArd: The example illustrates the intent.
03:10:22 <AWizzArd> dminuoso: I was studying type families and then wanted to look into ContstraintKinds and now finally I can. And I then saw that RMonad example in that blog.
03:10:32 <dminuoso> AWizzArd: `instance RMonad S.Set where type RMonadCtxt S.Set a = Ord a`
03:11:21 <AWizzArd> Yes, here the parameter seems to really be needed.
03:11:46 <geekosaur> type level is not value level, you don't get eta reduction, the patameter has to be visible to be used
03:12:13 <geekosaur> (well, you get eta reduction but at the price that you could never talk about a which would make it difficult to actually use it)
03:12:55 <AWizzArd> dminuoso: I was contrasting it with https://stackoverflow.com/a/31328543
03:20:55 <AWizzArd> dminuoso: yeah, one can rewrite the RMonad example with a modified syntax. Instead of giving the second parameter a name we specify   type RMonadCtxt m :: * -> Constraint   – but then this example also needs to make use of the NoConstraint class that was shown on StackOverflow.
03:34:15 <dminuoso> AWizzArd: Thats pretty neat
03:34:44 <dminuoso> AWizzArd: Though Im not sure whether that's really useful
03:34:48 <AWizzArd> dminuoso: true
03:35:21 <madnight> in this diagram https://wiki.haskell.org/File:Typeclassopedia-diagram.png where would be the semiring?
03:35:25 <AWizzArd> dminuoso: anyway, I learned a few things. I see how I can use `()` as empty contraints with explicit parameters, and how I can work with an empty NoConstraint class with an anon param.
03:36:31 <dminuoso> madnight: It would be something between Num and Monoid maybe?
03:38:28 <dminuoso> madnight: Some people like to think of Num as Ring, although none of the laws are explicitly mentioned
03:40:17 <dminuoso> madnight: also consider that MonadPlus is a right seminearring, so you have some ring-like structures there too.
03:41:42 <madnight> but Num is only a instance of semiring
03:42:07 <dminuoso> madnight: No, Num is a typeclass.
03:42:23 <dminuoso> It can be thought of as a "subclass" of Semiring
03:42:31 <ZeuPiark> hello
03:43:09 <madnight> okay subclass then, but that doesn't fit into the diagram right
03:43:31 <madnight> i mean Num is to specific
03:56:19 <mschr> I have some "nested" data that I want to store in a Map k v
03:56:41 <mschr> Is there an advantage to "normalising" the data e.g. (Map (a, b, c) val) vs. (Map a (Map b (Map c val)))
03:56:58 <mschr> Or does it depend on the size of the data set?
03:58:00 <Taneb> mschr: they're subtly different
03:58:13 * hackage funflow 1.3.2 - Workflows with arrows  http://hackage.haskell.org/package/funflow-1.3.2 (nclarke)
03:58:17 <Taneb> eg. you can't translate M.singleton 'x' M.empty to the variety with tuple keys
03:59:13 * hackage text-builder 0.5.2 - An efficient strict text builder  http://hackage.haskell.org/package/text-builder-0.5.2 (NikitaVolkov)
04:00:43 <mschr> Taneb: having a "compound" key is easier to work with. Just wondering how much of a difference it makes or if there is a *right* way
04:01:37 <mschr> Would the compound key (unnormalized) use more memory or doesn't it matter since points to same memory location?
04:02:34 <Taneb> It would use slightly more memory
04:03:11 <Taneb> If you're often decomposing the structure and working on, say, a (b, c) map for each a, then you should definitely use the Map a (Map b (Map c val))) style
04:03:22 <Taneb> Otherwise I'd use the tuple style
04:03:43 * hackage text-builder 0.5.3 - An efficient strict text builder  http://hackage.haskell.org/package/text-builder-0.5.3 (NikitaVolkov)
04:03:45 <pie_> hm i didnt try to isolate it much but if you import a record qualified then you can try to use its accessors with a different typed record with an accessor of the same name and get a ghc assertion failure
04:04:15 <mschr> Taneb: cool, thanks!
04:04:21 <pie_> NamedFieldPuns may also be involved
04:04:31 <pie_> not sure
04:04:50 --- mode: glguy set +v bo
04:05:29 <bo> Guys, can you explain the logic of $ operator in some easy concepts? Why do i need to write and $ map (>5) [4,5,6] and not simply and map? When i write it with $ it should be equal to and (map (>5) [4,5,6]). It calculates map first and then 'and's over the result of map. What does this translate to without the dollar sign? Shouldn't it be the same thing?
04:07:03 --- mode: glguy set +v MarcelineVQ
04:07:04 <MarcelineVQ> and map (>5) [4,5,6]   is   (and map) (>5) [4,5,6]
04:07:29 <cocreature> or ((and map) (<5)) [4,5,6] if you want to make it entirely unambiguous
04:09:14 <bo> So in this case and partially applies to map runs it against (<5)? Excuse me, i have small brain explosion over here
04:10:13 <liste> (and map) (<5) doesn't type check
04:10:21 <liste> > (and map) (<5)
04:10:24 <lambdabot>  error:
04:10:24 <lambdabot>      • Couldn't match expected type ‘(Integer -> Bool) -> t’
04:10:24 <lambdabot>                    with actual type ‘Bool’
04:10:25 <MarcelineVQ> in this case  map  is the first argument for  and, which is a type error
04:10:51 <liste> and $ map (<5) OTOH does
04:10:57 <liste> > and $ map (<5)
04:10:59 <lambdabot>  error:
04:11:00 <lambdabot>      • Couldn't match type ‘[Bool]’ with ‘Bool’
04:11:00 <lambdabot>        Expected type: [Integer] -> Bool
04:11:08 <bo> Aha... So it receives a function instead of expected list?
04:11:10 <liste> > and $ map (<5) [4,5,6]
04:11:12 <lambdabot>  False
04:11:16 <merijn> bo: RIght
04:12:07 <hpc> bo: it serves a less immediately useful function as well, it turns function application into a function itself
04:12:36 <hpc> > ($) <$> [id, (* 2), (+ 100)] <*> [5, 10]
04:12:36 <simon> > map (\x -> x < 5) [4,5,6]
04:12:38 <lambdabot>  [5,10,10,20,105,110]
04:12:39 <lambdabot>  [True,False,False]
04:12:56 <simon> > map (\x -> (<) x 5) [4,5,6]
04:12:58 <lambdabot>  [True,False,False]
04:13:23 <hpc> bo: and you write operator sections with it
04:13:25 <simon> > map (\x -> flip (<) 5 x) [4,5,6]
04:13:26 <hpc> :t ($ False)
04:13:27 <lambdabot> (Bool -> b) -> b
04:13:28 <lambdabot>  [True,False,False]
04:13:28 <cocreature> hpc: sometimes I wonder if it wouldn’t be neat if "( )" would parse as function application. a few seconds later I hate myself :)
04:13:38 <hpc> hah
04:13:43 <bo> Alright, i see. It tells 'get me that function' instead of 'execute that function and give me what it returns'
04:13:47 <simon> > map (flip (<) 5) [4,5,6]
04:13:47 <Ariakenom> > and (map (<5) [4,5,6])
04:13:49 <lambdabot>  [True,False,False]
04:13:50 <lambdabot>  False
04:14:04 <hpc> cocreature: you know about the bracket syntax sugar for ($)?
04:14:12 <simon> > map (< 5) [4,5,6]
04:14:13 <phadej> cocreature: I like languages where () isn't overloaded at all, it's only a grouping operator
04:14:14 <lambdabot>  [True,False,False]
04:14:17 <hpc> cocreature: wrap your entire expression in parens, and then where you would use ($) instead use )(
04:14:20 <hpc> :D
04:15:13 <cocreature> hpc: sure I know about ($) but it would be kind of cute (and also really terrible) if you could turn “space” function application into a prefix operator by wrapping it in parentheses :)
04:15:26 --- mode: glguy set +v dataN
04:15:30 <hexagoxel> :t all
04:15:31 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
04:15:37 <dataN> if 's -> (a,s)' is State, what is '(a,s) -> s'?
04:16:01 <fvr> Reader?
04:16:05 <cocreature> phadej: I can definitely see the appeal in that. what would you use for unit?
04:16:06 <hpc> cocreature: and operator sections! imagine if ( 5) had a different type than (5)
04:16:14 <cocreature> hpc: lovely!
04:16:18 <simon> cocreature, &nbsp;!
04:16:35 <hpc> it would be great for me at least, i hate errant whitespace in code i have to maintain
04:17:14 <dataN> fvr: thats just 'r->a'
04:17:45 <phadej> cocreature: depends. Coq uses `tt` and I'm fine with that
04:18:01 <phadej> otoh, tt + ff could be bool constructors
04:18:09 <fvr> dataN: snd fits the type signature
04:18:17 <dminuoso> phadej: What languages are you referring to regarding ()?
04:18:42 <cocreature> phadej: hm yeah tt seems fine
04:18:50 <cocreature> dminuoso: well Haskell overloads () :)
04:19:03 <phadej> for a lot of things
04:19:07 <bo> One more thing: the '.' is very much like '$', but it creates new function that yet expects to be ran, correct? But in terms of chaining 'and $ map' are equivalent to 'and . map', 'map' will be executed first and result will be passed to 'and'
04:19:22 <phadej> unit, tuples, grouping, and for something else i forget for sure
04:19:24 <mschr> hpc: M-x global-whitespace-mode :-)
04:19:30 <liste> bo: you can't really "execute" functions, you can only apply them to arguments. "const 5 (foo 1 2 3)" applies the arguments 1 2 and 3 to foo, but it's not really ever executed
04:19:32 <dataN> fvr: what the name of the datatype ?? s a = ?? ((a,s)->s)
04:19:32 <dminuoso> No I mean, what language doesn't overload ()
04:19:57 <dminuoso> The vast majority of imperative languages overloads () to also mean function call
04:20:09 <liste> > const 5 (error "something horrid happened!")
04:20:11 <lambdabot>  5
04:20:14 <phadej> dminuoso: lisps, agda, lambda calculus
04:20:18 <dataN> snd is a value it could store
04:20:53 <phadej> dataN: (s, s -> a) is Store
04:21:00 <phadej> and that's the proper dual of State
04:21:14 <dataN> so?
04:21:59 <dataN> thats not; (a,s)->s
04:22:55 <dataN> oh, right, no, turning the arrow around is not taking the dual of state.
04:22:57 <cocreature> (a,s) -> s is isomorphic to a -> (s -> s) and at that point it’s something like Reader a (Endo s)
04:23:17 <cocreature> I don’t think it’s sufficiently common that anyone has given it a more succinct name
04:23:17 <dataN> yes
04:23:53 <Ariakenom> bo: well neither of those typecheck. I'm not sure about the details of your claim. Could you write a full expression?
04:24:25 <dminuoso> bo: (.) and ($) are different from one another. They are simply different functions!
04:24:28 <dminuoso> :t (.)
04:24:29 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:24:30 <dminuoso> :t ($)
04:24:32 <lambdabot> (a -> b) -> a -> b
04:24:39 <fvr> dataN: It is mentioned here https://hackage.haskell.org/package/category-extras-0.53.0/docs/Control-Comonad-Reader.html
04:24:57 <dataN> :t foldr
04:24:58 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
04:25:26 <dataN> (a->b->b) is a generalisation of Monoid append found in the type signature of foldr, its very common. 
04:25:32 <dminuoso> bo: Abstractly: (.) is a kind of `add` for functions, that is it combines two functions together in a meaningful way. ($) is function application.
04:26:49 <dataN> cocreature: probably the opposite of that is true
04:27:03 <dminuoso> bo: Also take note that the "order of execution" does not make much sense here because our evaluation model is very different.
04:27:19 <cocreature> dataN: fair enough, maybe you’re looking for https://hackage.haskell.org/package/reducers-3.12.3/docs/Data-Semigroup-Reducer.html?
04:28:20 <dataN> coreature: as in 'cons' ?
04:28:29 <merijn> Ah... <<loop>>, we meet again
04:29:07 <dminuoso> In Haskell programs loop when things go wrong. In Java programs crash when things go wrong.
04:29:33 <quchen> That statement is maybe a bit too general.
04:29:35 <cocreature> dminuoso: my Haskell programs usually segfault :P
04:29:43 <Ariakenom> dminuoso: well with <<loop>> the two are the same. yay
04:29:48 <dminuoso> Ariakenom: Heh.
04:29:57 <dminuoso> cocreature: Do you FFI a lot?
04:30:03 <cocreature> yep :)
04:30:15 <quchen> Loop is a brutal crash, much more brutal than say a null pointer exception.
04:30:27 <fvr> ap :: (Monad m) => m (Either e (a->b)) -> m (Either e a) -> m (Either e b) , can this function be written without a Monad m, maybe just an Applicative?
04:30:32 <dminuoso> quchen: Because it's an async exception?
04:30:43 <dminuoso> Or is it even?
04:30:52 <quchen> It’s GHC provably discovering an infinite loop. I don’t know what kind of error it is, but it’s not an exception.
04:30:59 <quchen> It’s the runtime barfing violently before crashing.
04:31:11 <Taneb> fvr: It's (<*>) for Compose m (Either e), I think
04:31:15 <quchen> Well, it’s not that bad, that would be a segfault. But loop is close ;-)
04:31:20 <dminuoso> Well to me the crash is a bonus, because you wouldn't want the program to just hang and consume CPU time
04:31:24 <Taneb> fvr: (so yes)
04:31:43 <quchen> dminuoso: Well, one could argue that non-master threads can meaningfully loop and that shouldn’t crash the program
04:31:51 <fvr> quchen: I brought it from ExceptT, the applicative definition there had a Monad m constraint
04:31:55 <dminuoso> quchen: fair enoguh
04:32:04 <Ariakenom> quchen: what? it isn't a normal exception?
04:32:14 <fvr> * Taneb: 
04:32:15 <quchen> dminuoso: For example, the Alternative »empty« for Concurrent is basically an efficient do-nothing loop
04:32:39 <quchen> (It’s infinitely repeated threadDelay)
04:32:59 <dataN> that is a subclass of Semigroup, so also has (m->m->m) which isnt neacary here, its just a way to use (m->m->m) + (c->m) to get (c -> m -> m)
04:33:45 <merijn> hmmm
04:34:06 <merijn> I'm trying to build a profiling version of my code and for some weird reason it's crashing on GHCi issues (?!?!)
04:34:25 <cocreature> dataN: what exactly are you looking for then? a function "a -> b -> b" without any additional constraints is too general to say anything useful about it
04:34:44 <cocreature> there are various abstractions for folds such as the foldl package if that’s what you’re looking for here
04:34:50 <quchen> Ariakenom: I don’t think it’s a normal exception, no
04:34:51 <dataN> perhaps a class providing (c->m->m) would then be a trivial superclass of Reducer
04:35:03 <dminuoso> > let a = b; b = a; in a
04:35:03 <quchen> Ariakenom: I don’t think it’s an exception at all
04:35:06 <lambdabot>  *Exception: <<loop>>
04:35:12 <quchen> > let a = a in a
04:35:13 <dminuoso> Why would GHCI not produce that exception for me?
04:35:15 <lambdabot>  *Exception: <<loop>>
04:35:25 <cocreature> % try (let a = a in a)
04:35:26 <yahb> cocreature: ; <interactive>:67:1: error:; * No instance for (Show (IO (Either e0 a0))) arising from a use of `print'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
04:35:28 <dataN> what would such a class be called?
04:35:29 <quchen> Maybe it’s Lambdabot who produces that »exception«
04:35:37 <merijn> dminuoso: Because ghci is interpreted and cannot detect all the loops GHC compiled code can
04:35:47 <quchen> dataN: »Left action on the semigroup« I think that’s called
04:35:56 <cocreature> % print =<< try (let a = a in a) :: IO (Either SomeException ())
04:35:56 <yahb> cocreature: ; <interactive>:68:1: error:; * Couldn't match type `()' with `Either SomeException ()'; Expected type: IO (Either SomeException ()); Actual type: IO (); * In the expression: print =<< try (let a = a in a) :: IO (Either SomeException ()); In an equation for `it': it = print =<< try (let a = a in a) :: IO (Either SomeException ())
04:36:17 <dminuoso> merijn: even when I compile it with GHC it doesn't produce an exception.
04:36:18 <cocreature> % print =<< try (pure (let a = a in a)) :: IO (Either SomeException ())
04:36:19 <yahb> cocreature: ; <interactive>:69:1: error:; * Couldn't match type `()' with `Either SomeException ()'; Expected type: IO (Either SomeException ()); Actual type: IO (); * In the expression: print =<< try (pure (let a = a in a)) :: IO (Either SomeException ()); In an equation for `it': it = print =<< try (pure (let a = a in a)) :: IO (Either SomeException ())
04:36:35 <merijn> dminuoso: <<loop>> is never guaranteed to be thrown
04:36:55 <dminuoso> merijn: Yeah but.. it used to throw this exception. It doesn't right now, I want it thrown so I can experiment somet hings.
04:37:02 <merijn> dminuoso: It's just sorta done opportunistically when detected, which might be affected by optimisations, etc.
04:37:07 <quchen> merijn: It isn’t? Not even when the code is clearly a self-evaluating thunk?
04:37:18 <dminuoso> evaluating a blackhole should always trigger this
04:37:29 <dataN> Let S be a semigroup. Then a (left) semigroup action (or act) of S is a set X together with an operation • : S × X → X 
04:37:34 <quchen> Ah, modulo code transformations and such. Alright.
04:37:38 <dminuoso> mmm
04:37:46 <dataN> from: https://en.wikipedia.org/wiki/Semigroup_action
04:37:47 <merijn> quchen: I mean "there is no Haskell source that is guaranteed to throw <<loop>>"
04:37:56 <dataN> the name "act" seems reasonable 
04:39:09 <merijn> heh
04:39:17 <dminuoso> merijn: Or maybe I misremember.. but Id really like to have <<loop>> exceptions in GHCi =(\
04:39:25 <dataN> the right semigroup action appears in foldl
04:39:28 <dataN> :t foldl
04:39:29 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
04:39:46 <merijn> I have code that compiles properly, but crashes GHC when compiling with --enable-profiling
04:39:52 <dataN> so maybe "actl" and "actr" ... 
04:40:12 <cocreature> merijn: any ffi in it or TH? I’ve had that happen in both cases
04:40:12 <merijn> Do TH and profiling somehow interfere with eachother?
04:40:22 <merijn> cocreature: Goddammit, don't say that >.<
04:40:27 <merijn> cocreature: Did you manage to fix it?
04:40:28 <dataN> thanks quchen
04:40:58 <cocreature> merijn: no, it was an upstream bug. iirc some things have been fixed in GHC but I’m not sure if all of them have been fixed and in which version
04:41:06 <merijn> I'm on 8.4.3
04:41:10 <NH> anyone know a good resource where i can learn the finer points of IO and running things concurrently/in threads
04:41:22 <merijn> Fuck...how am I supposed to debug <<loop>> without profiling? :(
04:41:54 <MarcelineVQ> tried ticky?
04:41:56 <cocreature> merijn: printf debugging is the best debugging
04:42:01 <MarcelineVQ> rather, can you try it
04:42:01 <NH> trying to create something akin to lambdabot I like the way it does it's thing in the background but you get a little prompt to give it commands
04:42:11 <cocreature> MarcelineVQ: I don’t think that gives you stack traces on exceptions does it?
04:42:38 <MarcelineVQ> dunno, it's just the first thing that popped into my head
04:43:08 <merijn> MarcelineVQ: What do you mean with "ticky"?
04:43:18 <cocreature> merijn: GHC has ticky ticky profiling
04:43:19 <MarcelineVQ> https://ghc.haskell.org/trac/ghc/wiki/Debugging/TickyTicky 
04:43:40 <merijn> NH: Do you have a clearer example of what confuses you?
04:43:45 <cocreature> which pretty much nobody seems to use for some reason but it’s there and last I checked it worked :)
04:43:59 <NH> merijn: more just not sure where to begin
04:44:28 <NH> i suppose i could go read lambdabot and work it out
04:44:44 <quchen> NH: An excellent source on anything parallel/concurrent is Simon Marlow’s book.
04:45:17 <cocreature> specifically the second part if you care about concurrency
04:45:39 <quchen> »Specifically the part about concurrency if you care about concurrency« ;-)
04:46:01 <MarcelineVQ> if you can find it :(   https://pdfs.semanticscholar.org/a87c/89e722e3636a632d41adbdec0e2f71586176.pdf
04:46:19 <MarcelineVQ> oreily decided you had to sign up to their trash service to read it as html
04:46:43 * hackage avro 0.3.4.2 - Avro serialization support for Haskell  http://hackage.haskell.org/package/avro-0.3.4.2 (alexeyraga)
04:47:41 <merijn> MarcelineVQ, cocreature: That helpfully output an infinite stack trace...
04:47:55 <cocreature> you can read it on archive https://web.archive.org/web/20180108044627/http://chimera.labs.oreilly.com:80/books/1230000000929/index.html
04:47:58 <merijn> Not sure infinity lines of "stg_gc_fun_info" is overly helpful...
04:48:14 <MarcelineVQ> that's slightly more information than <loop> at least
04:48:26 <merijn> Not really, because it's a RTS function
04:48:57 <MarcelineVQ> it's at least 3 more words in length than loop so you've gained total info
04:49:01 <cocreature> it’s more information just not more useful information :)
04:49:15 <merijn> It's data, not information >.>
04:49:37 <NH> MarcelineVQ: quchen: cocreature: ah brilliant cheers
04:49:49 <NH> turns out i do actually have it just never looked at it
04:50:22 <dminuoso> Id like a gitlab-ci friendly way of passing secrets of the following shape into a docker container: `data Env = Env { ldapPass :: String, ldapUser :: String, allowed :: [(String, String)] }`
04:50:47 <dminuoso> Ideally it goes through environment variables, but that [(String, String)] would be annoying to encode.
04:51:32 <dminuoso> Would something like ALLOWED="foo=bar, quux=baz" be sensible?
04:58:43 * hackage optima 0.1 - Simple command line interface arguments parser  http://hackage.haskell.org/package/optima-0.1 (NikitaVolkov)
05:06:42 --- mode: glguy set +v dataN
05:06:46 <dataN> reversing the arrow of ActR gives StateL;
05:06:52 <dataN> State s a = s -> (a,s) , StateL s a = s -> (s,a) 
05:06:53 <dataN> Act   s a = (a,s) -> s , ActR   s a = (s,a) -> s 
05:08:48 <dminuoso> Act looks supciously like Store..
05:08:54 --- mode: glguy set +v romanix
05:09:06 <romanix> can you guys suggest an efficient linear algebra library that supports sparse vectors/matrices? hmatrix has a GMatrix type but that's about it
05:12:07 <gentauro> will the following code run in parallel thx to Applicative? -> https://lpaste.net/4313492250156859392
05:12:15 <gentauro> or is there something I'm misunderstanding :)
05:14:21 --- mode: glguy set +v Matteo
05:15:18 <Matteo> what is the syntax for putting commenting titles in your haskell code ?
05:15:38 <Clint> what?
05:16:06 <MarcelineVQ> No.   getNumProcessors >>= setNumCapabilities  is the same as setting  -N  on the command line, it won't do anything by itself
05:17:05 <MarcelineVQ> https://web.archive.org/web/20180108044627/http://chimera.labs.oreilly.com:80/books/1230000000929/index.html is the place to go to learn about parallel and concurrency
05:18:34 <MarcelineVQ> https://hackage.haskell.org/package/monad-par  and  https://hackage.haskell.org/package/async  are the classic sources you'd be using for each, though there's newer things around for more specific uses
05:18:35 <gentauro> MarcelineVQ: with that line of code, I read from the system how many CPU/core there are, then I set them
05:19:28 <MarcelineVQ> sure but there's nothing automatically parallel about what you're doing with the list
05:20:03 <gentauro> I think I heard at a conference that <*> maps (in parallel) if it's specified
05:20:20 <gentauro> without having to do anything else. That's why I'm asking
05:21:00 <phadej> gentauro: no, that code is not parallel, rewatch the talk you listened at the conference
05:21:01 <MarcelineVQ> For [] it does not, another Applicative might
05:21:22 <gentauro> [] and list cos it's lazy-sequential?
05:22:08 <phadej> no
05:23:06 <phadej> you can map over [] in parallel, e.g. parMap in http://hackage.haskell.org/package/parallel-3.2.2.0/docs/Control-Parallel-Strategies.html
05:23:38 <phadej> but you cannot do that with <*>
05:24:17 <phadej> (alternatively, you could Concurrently `traverse` the [] with mapConcurrently from http://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html)
05:24:39 <phadej> which uses <*> of Concurrently, not [] itself
05:25:24 <gentauro> so there is nothing explicit with regard of paralelism and <*>?
05:25:44 <gentauro> so the sentence: "Monad is for series where Applicative is for parallel." is bull-crap?
05:26:45 <phadej> it's partially true. IO is Monad, and serial; Concurrently is only an Applicative; and "concurrent"
05:27:28 <opqdonut> monad is serial in the sense that you can make decisions based on previous outputs
05:27:37 <dminuoso> :t (>>=)
05:27:38 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:27:40 <dminuoso> :t (<*>)
05:27:42 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:27:58 <opqdonut> applicative is parallel in the sense that the shape of the computation is fixed, and thus "parallel" (if you look at the dataflow)
05:28:00 <dminuoso> gentauro: Consider that for (>>=) the second has a direct dependency on the first, that's directly tied into the type system
05:28:08 <phadej> gentauro: you have to distinguish when [] is used as a Monad, and when as Traversable
05:28:10 <dminuoso> but for (<*>) the two are indepdent
05:32:40 <gentauro> % [ (+1) ] <*> [ 0 .. 9 ]
05:32:40 <yahb> gentauro: [1,2,3,4,5,6,7,8,9,10]
05:32:48 <gentauro> no monadic code there right?
05:33:09 <phadej> gentauro: no, but you use [] as Applicative there
05:33:13 <gentauro> none of the values in the list depends on any other calculation (it's trully a map of f over xs)
05:33:19 <phadej> [ (+1), (+2) ] <*> [ 1..3]
05:33:21 <phadej> > [ (+1), (+2) ] <*> [ 1..3]
05:33:24 <lambdabot>  [2,3,4,3,4,5]
05:33:37 <phadej> that's "non-determinism", not "paralellism"
05:33:54 <phadej> :t parMap
05:33:55 <lambdabot> error:
05:33:55 <lambdabot>     • Variable not in scope: parMap
05:33:55 <lambdabot>     • Perhaps you meant ‘para’ (imported from Control.Lens)
05:33:56 <gentauro> phadej: yeah and (,) <$> [ 1, 2 ] <*> [ 2, 3 ] gives me the cartesian product ..
05:34:36 <gentauro> phadej: non-determinism?
05:34:38 <gentauro> what?
05:34:38 <phadej> gentauro: and even the results /could/ be computed in parallel, they aren't because it's far from obvious when it's so
05:34:48 --- mode: glguy set +v drets
05:34:56 <drets> I have a datatype declared in external package and it doesn't have Ord instance which I need. I created orphans instance in my file. How can I do it better?
05:35:03 <phadej> gentauro: you can wrap [] in `newtype ParList a = ParList [a]`, and define fmap = parMap
05:35:38 <phadej> and that will be about the same relation as between IO and Concurrently
05:36:07 <phadej> gentauro: I'd really recommend Marlow's book https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
05:36:54 <gentauro> phadej: yeah, I've been looking into his slides/talks on Haxl
05:38:13 <dminuoso> gentauro non-determinsm in the sense that a list can be thought of a "fuzzy" answer. Instead of "it's 5", a list encodes "maybe 4, 5 or 6". 
05:38:24 <phadej> Haxl is "Concurrently on steroids"
05:39:09 <phadej> Haxl's "magical" <*> makes things parallel, []'s <*> is not "parallel"
05:40:09 <merijn> drets: Better in what way? As in, no orphans?
05:40:29 <drets> Yep. Is there way to get rid of orphans at all?
05:40:37 <dminuoso> gentauro: So if you have `Either add one, or add 2` and apply that to `Either 1, 2 or 3` - then the answer, invariably, will have to be `Either 2, 3, 4, 3, 4 or 5`
05:40:43 <drets> I want to remove {-# OPTIONS_GHC -fno-warn-orphans  #-} from file :)
05:40:43 <gentauro> drets: there is a GHC flag ;)
05:40:47 <dminuoso> gentauro: So in that sense lists encode non-determinism
05:40:56 <merijn> drets: Not really, the only way to "get rid" of them is to define a newtype around the datatype and define Ord for that
05:41:12 <merijn> drets: That's the safest way, but not always applicable
05:41:36 <dminuoso> gentauro: It's actually rather ZipList that encodes the notion of "parallel" - but that is not to say that the implementation gives you actually concurrency
05:42:46 <Ariakenom> "actually parallelism"
05:43:51 <phadej> yeah, it's good to be pedantic about concurrency vs. parallelism :)
05:43:54 <gentauro> parallelism and concurrency are two different typics
05:43:54 <phadej> it's hard though
05:44:06 <phadej> (fwiw, haxl is concurrent)
05:44:06 <gentauro> OCaml has concurrency but doesn't have parallelism
05:44:46 <phadej> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/ch01.html#sec_terminology
05:45:51 <gentauro> phadej: reading this at the moment -> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/desugaring-haskell-haskell16.pdf
05:47:33 <Ariakenom> speaking of papers. have a list SPJ's https://www.microsoft.com/en-us/research/people/simonpj/#!publications
05:47:33 <MarcelineVQ> glguy: your "repeat your mssage" message is missing a space after the channel name
05:48:18 <drets> merijn, newtype works good to me. That first what I tried but it didn't work when I tried to derive Ord and Eq. Now I realized that I had to write instances for newtype manually. Thanks
05:48:19 <phadej> gentauro: note, that's ApplicativeDo has little benefit for []
05:48:41 <merijn> drets: Look up -XGeneralizedNewtypeDeriving in the GHC user guide :)
05:50:30 <drets> merijn, even with this extension enabled it asks for the ord of external datatype, so I leave the manual instances for now, but thanks :)
05:51:03 <merijn> drets: Yeah, the Ord instance you have to write manually (since it didn't exist, which is why you wanted the orphan, right?)
05:51:16 <merijn> drets: But GND at least means you don't have to reimplement Eq, Show, etc.
05:51:26 <drets> aaa :)
05:51:27 <phadej> gentauro: the Moore machine example has good sentence in it. > There even exists a Monad for this type, but it is grossly inefficient. (but that's not because of it being non-parallel, the <*> can be implemented more efficiently for it, than via >>=)
05:51:51 <merijn> drets: GND also lets you derive instances that normally can't be derived (like Monad, etc.)
05:54:08 <drets> merijn, good to know. Ok, I disabled extension, added to my datatype deriving Eq, Show and implemented only Ord and it still compiles :)
05:54:30 <merijn> drets: The Show will be slightly different, though
05:56:37 <phadej> just GND won't change how Eq/Ord/Show are derived
05:56:46 <gentauro> Ariakenom: I would expect to you provide a list of SPJ papers like this -> http://community.haskell.org/~ndm/darcs/tagsoup/tagsoup.htm
05:56:53 <gentauro> I mean, is this #haskell or what?
05:57:52 <merijn> phadej: Yeah, as I said that I remember DerivingVia, etc.
06:00:18 <Ariakenom> gentauro: Sorry to disappoint.
06:00:38 <phadej> one need to write `newtype Wrapper = Wrap { unwrap :: OtherType} deriving newtype (Show)` -- to make wrapper transparent in Show
06:03:06 --- mode: glguy set +v lortabac
06:04:40 --- mode: glguy set -v lortabac
06:06:17 <gentauro> (from slide 20) -> http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/31/slides/simon.pdf
06:06:20 <gentauro> they know
06:06:26 <gentauro> (my eyes are bleeding)
06:11:41 <lortabac> hello, is there a way to store an HList into a TVar? I couldn't find a way to do type-changing updates to a TVar
06:12:46 <mniip> no, mutable references have to be monomorphic
06:13:38 <lortabac> ok, I guess I need existentials to achieve the same goal
06:13:46 <mniip> you can use those yes
06:14:55 <lortabac> is this an intrinsic limitation of mutable references? I mean, could polymorphic references be implemented in theory?
06:15:09 <mniip> what would their interface look like
06:15:47 <mniip> are you thinking of something like   fmap :: (a -> b) -> Ref a -> Ref b  ?
06:15:54 <mniip> does that create a new Ref or reuse the old?
06:16:45 <lortabac> yes, I was thinking of something like fmap
06:16:53 <mniip> does that create a new Ref or reuse the old?
06:17:24 <lortabac> I don't mind if it creates a new Ref, as long as it stays in STM
06:17:36 <mniip> well duh, then,
06:17:53 <mniip> :t \f i -> readIORef i >>= newIORef . f
06:17:55 <lambdabot> error:
06:17:55 <lambdabot>     • Variable not in scope: readIORef :: t -> m a
06:17:55 <lambdabot>     • Perhaps you meant ‘readSTRef’ (imported from Data.STRef)
06:18:06 <mniip> :t \f i -> Data.IORef.readIORef i >>= Data.IORef.newIORef . f
06:18:07 <lambdabot> (a1 -> a2) -> GHC.IORef.IORef a1 -> IO (GHC.IORef.IORef a2)
06:18:26 <mniip> this isn't "polymorphic references"
06:18:36 <mniip> every reference is monomorphic in the end here
06:18:42 <lortabac> true
06:19:06 <lortabac> but in my case I only care about transactions
06:19:22 <mniip> but the two references are disjoint
06:19:23 <mniip> unrelated
06:20:13 <lortabac> ok, let's start from a different question then
06:20:34 <lortabac> what happens if I modify multiple TVar in a single STM transaction?
06:20:46 <lortabac> is it still atomic?
06:20:49 <mniip> yes
06:21:40 <lortabac> then I guess this trick should be safe
06:22:03 <merijn> lortabac: The point is that STM is atomic regardless of how many variables you access :)
06:22:04 <lortabac> but, as you say, each Ref is still monomorphic
06:37:22 <dyamon> Hi I was looking for a Haskell ctag-like generator for Vim (following the wiki page). I'd like to stick to the gentoo dev-haskell repo for pratical reasons. `fast-tags` is not in the repo, so that is out of the way. What would you suggest between `hasktags` and `hothasktags`?
06:37:23 <Ariakenom> decided
06:37:34 <Ariakenom> sry mismessage
06:38:03 <dminuoso> dyamon: hasktags
06:38:08 <dyamon> I'm not dealing with large project so I won't need particularly advanced features I guess
06:38:39 <dyamon> dminuoso: do you have a reason?
06:39:27 <dminuoso> dyamon: They are semi-official and maintained.
06:40:14 <dminuoso> dyamon: But really you should just try them out, hasktags has in its README a list of related works.
06:40:21 <dminuoso> And then decide for yourself which one works for you.
06:42:18 <dyamon> dminuoso: yeah I figured, I just wanted to know if there was some really good reason to choose one over the other (like "one is actually an enhancement of the other")
06:42:38 <dyamon> Ill start with hasktags! Thank you!
06:43:49 <dminuoso> When you emerge dev-lang/ghc, does it fully compile GHC?
06:44:09 <dminuoso> GHC has some murderous compile times..
06:45:13 * hackage nqe 0.2.0.0 - Concurrency library in the style of Erlang/OTP  http://hackage.haskell.org/package/nqe-0.2.0.0 (xenog)
06:45:51 <dyamon> dminuoso: I should look into the ebuild file but the general approach is to compile everything from source
06:46:23 <dminuoso> dyamon: how long did that take you?
06:49:04 <ab9rf> compiling ghc from source is a fairly involved process
06:50:19 <ab9rf> especially if you don't already have ghc
06:53:13 <dyamon> dminuoso: I don't remember, but looking at the ebuild file, it fishes for some architecture specific ghc binaries
06:55:27 <ab9rf> i'm not sure how far back you'd ahve to go in order to build ghc without access to a working ghc
06:56:43 <Ariakenom> A cold winter's day in 1992 ...
06:57:11 <POGtastic> hi guys, silly question here. say that I run ./foo 1 2 3. I use System.Environment.getArgs to start with ["1", "2", "3"]. I want to turn this into Just [1, 2, 3]. Alternatively, if I run ./foo 1 2 3 bar, I want it to return Nothing. I have a solution, but it's not very, um, Haskellish. any pointers in the right direction would be appreciated.
06:57:40 <dyamon> ok so it seems like the one in the official gentoo repo dev-lang/ghc downloads the ghc binaries and build ghc from source with them
06:57:59 <glguy> POGtastic: traverse readMaybe :: [String] -> Maybe [Int]
06:58:04 <dyamon> and if you use the `binary` flag you can skip the compilation and just keep the binaries
06:58:11 <POGtastic> :t traverse
06:58:13 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
06:58:16 <POGtastic> ooooo
06:58:21 <POGtastic> thanks
06:58:34 <POGtastic> haven't seen that function before.
06:58:59 <Ariakenom> POGtastic: you can use map instead. it doesnt use the right thing but you've probably used it
06:59:14 <Ariakenom> sry I meant "it doesnt do the same thing"
07:00:46 <dyamon> dminuoso: thanks again! bye
07:00:52 <POGtastic> Ariakenom: that would lead to a [Maybe Int] rather than Maybe [Int], right?
07:01:12 <Ariakenom> POGtastic: correct. so traverse does more of what you want
07:01:52 <mniip> traverse f = sequenceA . fmap f
07:06:25 <dminuoso> POGtastic: traverse is one of the most wonderful and powerful functions =)
07:06:56 <mniip> objection
07:08:44 <dminuoso> :t getDual . getConst . traverse (Const . Dual)
07:08:46 <lambdabot> (Monoid c, Traversable t) => t c -> c
07:09:00 <dminuoso> :t (execWriter .) . traverse_ . (curry writer () .)
07:09:01 <lambdabot> (Monoid w, Foldable t) => (a -> w) -> t a -> w
07:09:11 <dminuoso> mniip: Do you have something with more beauty than that?
07:10:09 <Taneb> :t foldMap
07:10:10 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
07:10:25 <dminuoso> Heh.
07:10:42 <Taneb> Or were you looking for examples of traverse?
07:10:44 <dminuoso> Taneb: My point was that traverse is powerful enough to recover foldMap from it :)
07:10:56 <mniip> that's not traverse though
07:10:58 <mniip> :t traverse_
07:11:00 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
07:11:13 <dminuoso> Fair enough
07:11:42 <mniip> @let puncture = (`runCont` \xs -> fmap (second ($ fmap fst xs)) xs) . traverse (\x -> callCC (\k -> pure (x, \xs y -> fmap fst $ (`runCont` id) $ k (y, \_ _ -> xs))))
07:11:44 <lambdabot>  Defined.
07:11:59 <dminuoso> :t puncture
07:12:01 <lambdabot> Traversable f => f b -> f (b, b -> f b)
07:12:56 <mniip> > map (($ 10) . snd) puncture [1,2,3]
07:12:58 <lambdabot>  error:
07:12:58 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
07:12:58 <lambdabot>                    with actual type ‘[b1]’
07:12:59 <mniip> > map (($ 10) . snd) $ puncture [1,2,3]
07:13:01 <lambdabot>  [[10,2,3],[1,10,3],[1,2,10]]
07:13:16 <dminuoso> mniip: Is this from lens?
07:13:19 <mniip> no
07:13:33 <mniip> it's something I came up with on my own
07:13:54 <mniip> thinking about it a bit more now,
07:14:06 <mniip> Traversable f => f a -> f (Store a (f a))
07:14:09 <POGtastic> so, I'm kind of lost with IO. say that I start with IO [String], which is System.Environment.getArgs. I want to convert IO [String] to, I think, IO (Maybe [Int]). as in, if all of the arguments are integers, I get a list of integers. I then perform a function of type [Int] -> [[Int]], and I want to print the results. the types are killing me, and I think it's because I don't understand exactly how IO works.
07:14:39 <dminuoso> POGtastic: Are you a bit comfortable with basic haskell?
07:14:57 <cocreature> POGtastic: do you know how to go from [String] to Maybe [Int]?
07:14:57 <POGtastic> dminuoso: i seem to do okay until it's time to actually print stuff to the screen.
07:15:12 <Taneb> > traverse (\x -> [x, x+1, x+2]) [1,2,3]
07:15:14 <lambdabot>  [[1,2,3],[1,2,4],[1,2,5],[1,3,3],[1,3,4],[1,3,5],[1,4,3],[1,4,4],[1,4,5],[2,...
07:15:22 <ab9rf> POGtastic: if you have a function that does [String] to Maybe [Int], all you hve to do is lift that into IO
07:15:34 <POGtastic> cocreature: from above, I have getIntegers = traverse readMaybe
07:15:42 <POGtastic> ok, I haven't seen "lifting" yet. lemme look that up.
07:15:52 <cocreature> :t fmap :: (a -> b) -> IO a -> IO b
07:15:54 <lambdabot> (a -> b) -> IO a -> IO b
07:16:02 <dminuoso> POGtastic: https://www.vex.net/~trebla/haskell/IO.xhtml
07:16:02 <marvin2> POGtastic do syntax migth be the easiest to grasp at first. do args <- getArgs {- args is of [String] type from now on -}
07:16:32 <ab9rf> yeah, do sugar is the usual easy way to do this
07:18:43 <nshepperd1> lortabac: type changing operations on mutable references are fundamentally problematic, in so far as accesses to the reference from different threads are unordered with respect to each other, so ghc would have no way to propagate the type information from one location to the other
07:19:39 <lortabac> nshepperd1: right, I hadn't thought about that
07:20:46 <nshepperd1> The only way around that i can see is to wrap the contents in an existential and do GADT pattern matching to reconstruct the type information at runtime
07:21:00 <mniip> Data.Dynamic also could help
07:25:24 <lortabac> I'm trying to implement an in-memory relational database. I need a map of tables, but each table has a different type
07:26:17 <lortabac> so one idea is to use a GADT, but maybe Data.Dynamic could be a simpler solution
07:38:14 --- mode: glguy set +v Contra
07:40:43 * hackage nqe 0.3.0.0 - Concurrency library in the style of Erlang/OTP  http://hackage.haskell.org/package/nqe-0.3.0.0 (xenog)
07:46:14 <POGtastic> yay it works. is this `main` block reasonable? https://pastebin.com/rJDZAz9k
07:47:09 <Ariakenom> POGtastic: "parsedArgs <- return $ getIntegers args" You can write let in do-notation "let parsedArgs = getIntegers args"
07:47:24 <Ariakenom> oh right you had some let there
07:48:17 <POGtastic> to be clear - are they equivalent?
07:48:21 <Ariakenom> yes
07:48:49 <Ariakenom> "x <- return y" -> "let x = y"; return means there
07:48:56 <POGtastic> gotcha. learning this has given me a weird mishmash of theory and "lol i don't care how this works, I just want it to work dammit"
07:49:06 <Ariakenom> there's no effect
07:50:47 <Ariakenom> POGtastic: haha. that's fine it'll become clear
07:52:22 <c_wraith> they're equivalent as long as the Monad instance selected for "return" obeys the Monad laws
07:52:54 <POGtastic> so, I think I "simplified" it to this: https://pastebin.com/2tkSNvgJ
07:53:22 <POGtastic> to be clear: <$> is mapping the function to the Maybe functor, right?
07:53:23 <Ariakenom> c_wraith: But what if he shadowed return = undefined!?
07:53:38 <Ariakenom> :t (<$>)
07:53:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:53:52 <Ariakenom> (<$>) = fmap
07:55:12 <Ariakenom> > unlines ["line1","line2"]
07:55:14 <lambdabot>  "line1\nline2\n"
07:55:27 <POGtastic> ooo
07:56:00 <Ariakenom> > (List.intercalate "\n") ["line1","line2"]
07:56:02 <lambdabot>  error:
07:56:02 <lambdabot>      Not in scope: ‘List.intercalate’
07:56:02 <lambdabot>      Perhaps you meant one of these:
07:56:11 <POGtastic> it's in Data.List
07:56:18 <Ariakenom> > (Data.List.intercalate "\n") ["line1","line2"]
07:56:21 <lambdabot>  "line1\nline2"
07:56:23 <c_wraith> POGtastic, are you interested in a sneaky implementation of rot1 that has better laziness properties?
07:56:32 <POGtastic> c_wraith: sure
07:57:30 <c_wraith> POGtastic, actually, nevermind. I was thinking of something really clever involving zipWith const, but you don't need that much cleverness.
07:57:59 <c_wraith> POGtastic, you can just get away with rot1 (x:xs) = xs ++ [x]
07:58:12 <POGtastic> Ariakenom: I'd just have to replace putStrLn with putStr, as unlines puts in that final '\n'
07:58:33 <Ariakenom> POGtastic: good catch
07:58:52 <c_wraith> POGtastic, which has the advantage of never needing the entire list in memory at once. your implementation does, just because of the use of length.
07:59:15 <POGtastic> that sounds a lot smarter c_wraith. i originally had a misconception on what ducci sequences were, so i had to rotate both ways and had a more complicated version of rot (which you probably saw from the stack overflow entry).
07:59:41 <c_wraith> POGtastic, yeah, the simple version falls down if you need more flexibility.
08:00:04 <Ariakenom> there's different [] behaviour though
08:00:22 <c_wraith> Ariakenom, only in terms of what exception you get.
08:00:29 <c_wraith> > cycle []
08:00:32 <lambdabot>  *Exception: Prelude.cycle: empty list
08:00:45 <Ariakenom> ah makes sense
08:01:30 <c_wraith> but yeah, you can also prevent that exception with a second equation if you want
08:01:59 <dminuoso> Wow. The kind of weird roads you can send the type checkers when you are using a type variable that you.. inadvertedly introduced into scope via ScopedTypeVariables 15 lines above without noticing..
08:02:13 <Ariakenom> lol
08:03:09 <POGtastic> quick question. when I do my_str <- getLine, what type is my_str? I know that getLine is IO String. is my_str just String?
08:03:18 <c_wraith> yep
08:04:23 <POGtastic> and going back to the description of "let x = return y" is usually equivalent to "x <- y", that's because the IO monad's `return` returns the contents, right?
08:04:38 <dminuoso> POGtastic: No.
08:04:41 <dminuoso> Or. Yes.
08:04:44 <Ariakenom> you misplaced the return
08:04:52 <POGtastic> oops
08:04:53 <dminuoso> POGtastic: well `return` doesnt do anything
08:05:05 <dminuoso> POGtastic: Its annoyingly named. Use `pure` instead, it's less confusing.
08:05:24 <dminuoso> POGtastic: `return` lets you place a value into your IO thing in a pure manner.
08:05:31 <dminuoso> so `return 5` gives you some `IO Int` for example
08:06:06 <dminuoso> (In truth it gives you something back that is more general, but we can ignore that for a moment)
08:06:18 <POGtastic> i know that `return` puts it inside a monad, and `pure` puts it inside an applicative
08:06:58 <POGtastic> :t (pure 5, return 5)
08:07:00 <lambdabot> (Applicative f, Num a2, Num a1, Monad m) => (f a1, m a2)
08:07:12 <dminuoso> POGtastic: do { x <- getLine; y <- getLine; return (x ++ y) }
08:07:31 <xsperry> > (pure 5, return 5) :: IO Int
08:07:33 <lambdabot>  error:
08:07:33 <lambdabot>      • Couldn't match expected type ‘IO Int’
08:07:34 <lambdabot>                    with actual type ‘(f0 Integer, m0 Integer)’
08:07:36 <xsperry> > (pure 5, return 5) :: (IO Int, IO Int)
08:07:38 <lambdabot>  (<IO Int>,<IO Int>)
08:07:46 <dminuoso> POGtastic: `let x = y` is equivalent to: `x <- pure y`
08:07:54 <POGtastic> aha
08:09:12 <Ariakenom> Every Monad's return will follow that law. Although technically that's not enforced by the compiler.
08:09:24 <dminuoso> POGtastic: `pure` not only puts it "inside a monad/applicative", but it does so effect-free. pure. flavorless.
08:10:00 <dminuoso> POGtastic: or rather: `pure 5` gives you something that has no effects loaded
08:10:22 <Ariakenom> > pure 5 :: Maybe Int
08:10:25 <lambdabot>  Just 5
08:10:43 <dminuoso> POGtastic: more interesting laws are: fmap f m = do { x <- m; return (f x) }
08:11:13 * hackage rv 0.0.0.0 - RISC-V  http://hackage.haskell.org/package/rv-0.0.0.0 (MatthewFarkasDyck)
08:11:38 <POGtastic> > fmap (+1) $ return 5
08:11:40 <lambdabot>  error:
08:11:40 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M171498511667...
08:11:40 <lambdabot>        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
08:11:47 <POGtastic> :O
08:12:03 <ab9rf> there were too many possible monads
08:12:13 * hackage risc-v 0.0.0.0 - RISC-V  http://hackage.haskell.org/package/risc-v-0.0.0.0 (MatthewFarkasDyck)
08:12:13 <ab9rf> > fmap (+1) $ return 5 :: [Int]
08:12:15 <lambdabot>  [6]
08:12:20 <POGtastic> oooo
08:12:21 <Ariakenom> :t fmap (+1) $ return 5
08:12:22 <lambdabot> (Monad f, Num b) => f b
08:12:50 <ab9rf> if you do that in ghci you'll get a page and a half of possible types
08:12:54 <POGtastic> > fmap (+1) $ return 5 :: Maybe Int
08:12:57 <lambdabot>  Just 6
08:13:53 <xsperry> > (+1) <$> return 5 :: Either String Int
08:13:56 <lambdabot>  Right 6
08:14:32 <dminuoso> POGtastic: So more interesting things are...
08:14:36 <dminuoso> parseThing <$> getLine
08:14:59 <dminuoso> Which allows you to run a pure function over the result of some IO a
08:15:35 <dminuoso> length <$> getLine :: IO Int
08:15:37 <dminuoso> For example :)
08:18:20 <POGtastic> ah, i figured it out. I was trying to do length <$> getLine and get just an Int, which you can't do.
08:18:34 <ab9rf> :t length <$> getLine
08:18:35 <lambdabot> IO Int
08:18:36 <POGtastic> at the very end of my chain, i need to do x <-
08:18:46 <POGtastic> to actually bind it to a variable
08:18:56 <POGtastic> so I can do x <- length <$> getLine to get x :: Int
08:19:03 <ab9rf> or use >>= to shove it into something else
08:19:22 <POGtastic> :t (>>=)
08:19:22 <ab9rf> which is technically the same thing, of course
08:19:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:19:31 <POGtastic> (just refreshing my memory on the type)
08:20:33 <ab9rf> :t (\x f -> do t <- x; f t)
08:20:35 <lambdabot> Monad m => m t -> (t -> m b) -> m b
08:20:54 <liste> @undo do { x <- length <$> getLine; pure x }
08:20:54 <lambdabot> length <$> getLine >>= \ x -> pure x
08:21:08 <dminuoso> Gah. 
08:21:11 <dminuoso> • Could not deduce (EnvRead (S1 ('MetaSel ('Just f) u s l) (Rec0 a) p)) arising from a use of ‘envRead’
08:21:34 <ab9rf> i am so craving a burrito now
08:26:47 <xsperry> why am I getting "Orphan instance" warning when defining a class instance for a type I did not create?
08:27:13 <mniip> xsperry, did you define the class in your module?
08:27:35 <xsperry> yes
08:38:46 <benzrf> :t evnRead
08:38:47 <lambdabot> error: Variable not in scope: evnRead
08:38:50 <benzrf> :t envRead
08:38:51 <lambdabot> error: Variable not in scope: envRead
08:38:54 <benzrf> o:
08:42:27 --- mode: glguy set +v MrSeeds
08:46:53 <dminuoso> Can someone explain to me why this fails to typecheck? https://gist.github.com/dminuoso/d3cc76135643085453e45203c9853d09
08:49:58 <dminuoso> Oh doh!
08:50:29 <dminuoso> forgot to K1 . M1 the result..
08:52:30 <gbd_628> Hey all---how do you make `Nat` from GHC.Types a member of the `Eq` typeclass?
08:53:51 <dminuoso> :k Eq
08:53:53 <lambdabot> * -> Constraint
08:53:58 <mnoonan> Isn't Nat a kind?
08:54:20 <dminuoso> Would TypeInType make this work?
08:54:40 <gbd_628> Oh, I'm using TypeInType.
08:56:08 <gbd_628> So yeah, I figured you'd be able to make it an `Eq`, since it's both a type and a kind or whatever. But I can't seem to find the successor constructor for GHC.Types.Nat
08:57:33 <gbd_628> I guess that's because it's primitive/magic/optimized/something. But none of `S`, `Succ`, `Suc`  work. Do I need to make my own, unoptimized `Nat` datatype instead of using the one from GHC.Types?
08:58:21 --- mode: glguy set +v k0d3fr34k[m]
08:58:21 <k0d3fr34k[m]> But, isn't it the other way round? Shouldn't foldr be unable to work on infinite lists?
08:58:23 <dstolfa> hmm, doesn't Haskell have something similar to Agda where you can provide a denotational definition of some type and tell the compiler to us ethe builtin
08:59:27 <k0d3fr34k[m]> Also, function application binds more tightly than '++', right?
08:59:30 <gbd_628> dstolfa: oh, I didn't even think of that. idk
08:59:50 <gbd_628> (BTW, don't know how relevant it is, but I'm using basically every pseudo-dependent-typing extension I could find.)
09:00:25 <dstolfa> gbd_628: http://hackage.haskell.org/package/data-type-0.1.0/docs/Data-Type-Nat.html
09:00:28 <dstolfa> seems like it's S
09:00:33 <dstolfa> S and Z that is
09:01:04 <gbd_628> weird, ghci's saying theres no such constructor in scope...
09:01:47 <nshepperd> instance Eq Nat where { _ == _ = False }
09:02:04 --- mode: glguy set +v adrice
09:02:27 <nshepperd> ghc Nats aren't peano numbers, they don't have any values or constructors
09:02:44 <dstolfa> gbd_628: oh this seems to be a package, oops
09:03:53 <gbd_628> dstolfa: oh yeah, you're right, that's from `data-type`. so it's not optimized, I take it?
09:04:31 <mniip> % :i GHC.TypeLits.Nat
09:04:31 <yahb> mniip: data GHC.Types.Nat -- Defined in `GHC.Types'
09:04:33 <gbd_628> nshepperd: Oh. I guess I kind of just assumed... So there's no builtin way to get Peano Naturals that aren't painfully slow?
09:04:35 <mniip> there's no constructors
09:04:39 <mniip> it's a primitive kind
09:05:22 <nshepperd> aren't peano naturals painfully slow by definition?
09:07:04 <gbd_628> nshepperd: i think Agda and/or Idris has this builtin way to have your cake and eat it too---you can use Zero and Succ in code, but internally they're magicked away to get an efficient representation.
09:07:15 <gbd_628> (that's my undertanding of how it works, anyway.)
09:08:19 <gbd_628> guess I assumed GHC.Types.Nat was something like that; I should have actually done my research
09:08:23 <nshepperd> well, I suppose you could use PatternSynonyms to define Zero and Succ patterns that make ordinary Ints look like peano numbers
09:09:17 <nshepperd> but in any case, Nat isn't inhabited by any values, only types, so == at the value level is useless anyway
09:09:20 <k0d3fr34k[m]> Also, function application binds more tightly than '++', right?
09:09:33 <k0d3fr34k[m]> Guys, I had read somewhere that "foldl cannot work on infinite lists as it has to reach the end of the list"
09:09:34 <k0d3fr34k[m]> But, isn't it the other way round? Shouldn't foldr be unable to work on infinite lists?
09:10:59 <gbd_628> nshepperd: okay, thanks. Would they work on the type/kind level then, too?
09:12:16 <glguy> k0d3fr34k[m]: No, both foldl and foldr process the list from the left to the right, but foldr is able to produce results before making it to the end
09:12:38 <glguy> foldr f z (x:xs) = f x (foldr f z xs)
09:12:38 <gbd_628> *oops. "at least", not "too"
09:12:43 <k0d3fr34k[m]> But foldr is right associative, right?
09:12:59 <nshepperd> gbd_628: I don't think PatternSynonyms are a thing at the type level
09:12:59 <k0d3fr34k[m]> Okay, so both of them read the input list from left -> right?
09:13:12 <glguy> k0d3fr34k[m]: If (f x (foldr f z xs)) can produce a result without using that last argument, then it can work on infinite lists
09:13:32 <glguy> k0d3fr34k[m]: but:    foldl f z (x:xs) = foldl f (f z x) xs
09:13:40 <monochrom> > foldr (&&) undefined (False : undefined)
09:13:43 <lambdabot>  False
09:13:43 <glguy> so there's no opportunity to produce some results along the way of processing the list
09:14:42 <k0d3fr34k[m]> glguy:  Oh, got it!! Thanks :) That representation made it clear
09:14:53 <k0d3fr34k[m]> Also, function application binds more tightly than '++', right?
09:14:54 <k0d3fr34k[m]> What about this?
09:15:59 <glguy> f x ++ g y -- is
09:15:59 <glguy> ((f x) ++ (g y))
09:15:59 <gbd_628> nshepperd: i think i may be have made an "XY problem" here, so here's what led me here:
09:18:08 <k0d3fr34k[m]> glguy: So yes, it does. Thanks 🙂
09:19:40 <nshepperd> k0d3fr34k[m]: function application has the highest precedence of anything you'll encounter apart from record syntax
09:23:17 <gbd_628> i'm trying to make verified typeclasses for algebraic structures, or at least, to better understand the limitations of the relevant Haskell extensions when I fail. Here's a pastebin of what I'm aiming for (doesn't compile): https://pastebin.com/myWzdV3t
09:24:13 <gbd_628> nshepperd: is what I'm trying to do even possible in principle with just TypeInType+ ? Or do I need to figure out what singletons are to get anywhere close?
09:24:49 <gbd_628> The pasted code fails to compile because it has no instance for `Nat` as an `Eq`, hence my original question.
09:28:31 <gbd_628> Also, I'm not really sure if the "type family" and "type instance" stuff is what I want; I basically just threw syntax extensions at it until it compiled.
09:32:57 <mnoonan> I don't know if you literally want Eq anyway, because what if you want to prove the laws in some case where you didn't have decidable equality?
09:34:58 <mnoonan> like, consider the monoid structure on `a -> a` for some infinite type `a`. You can't decide equality, but you can still prove (f . g) . h = f . (g . h) and f . id = id . f = f 
09:41:55 <gbd_628> mnoonan: True. Later, though, I was planning on making a field structure, and for that I need equality to test whether or not it's 0.
09:42:36 <gbd_628> Oh, and here's a gist, since that seems to be the standard instead of pastebin: https://gist.github.com/greatBigDot/32f6667060901bdc8b7d81a03bee5cea
09:45:25 <gbd_628> mnoonan: I hadn't really planned it all out, but I wanted to make things like the rational or the algebraic numbers into a field with typechecker-verified axioms. To do that, I'd need to lift those types into kinds, I think. Thus, I think I need to make them all inductive datatypes, and it would be nice if it weren't incredibly slow.
09:47:54 <gbd_628> at this point it looks like my best option is to just accept the slowdown. I don't see how else to get numbers and whatnot as types, which I need to make it verified. (Because TypeInType collapses the type/kind/sort/etc. hierarchy, but retains the separation between values and types, so you need to lift values to type to put them in type signatures, which is what I need for compiler-verification)
09:51:46 <gbd_628> Is there any kind of `natToInteger` function, by any chance? It seems like such a thing ought to exist.
09:53:13 <selfsymmetric-mu> Hello! What is the best way to parse a piece of JSON where one of the keys is dynamic. That is, I have an `IO Key` and a `DataType`, and I want to get `JSON -> Key -> IO DataType`. I figure you can't do this with `ToJSON` because the instance takes no parameters. How would you accomplish it in practice?
09:53:33 <geekosaur> gbd_628, had you tried fromIntegral?
09:54:01 <selfsymmetric-mu> For a contrived example, you need to be able to parse either `{"bar" :: "value"}` or `{"foo" :: "value"}` based on whether you get "bar" or "foo" at runtime.
09:54:16 <selfsymmetric-mu> Not a great situation to be in of course, and you'd like to avoid it, but it happens.
09:55:41 <gbd_628> geekosaur: Problem is, Nat isn't an Integral
09:55:56 <geekosaur> which Nat? the one I looked at is
09:56:18 <lavalike> selfsymmetric-mu: the second function doesn't need to be in IO, if you have some json representing an object, finding the value relative to one of its keys is a pure function in principle
09:56:37 <cocreature> selfsymmetric-mu: write a function of type Key -> Value -> Parser DataType and then use parseEither
09:57:09 <gbd_628> geekosaur: GHC.Types.Nat
09:58:13 <selfsymmetric-mu> lavalike: Right, that makes sense.
09:58:56 <selfsymmetric-mu> cocreature: Okay cool. So basically write a parameterized parser yourself. No way to pass it into generic JSON parsers, right?
09:59:00 <gbd_628> i thought it was the Peano numbers w/ an optimized internal representation, but nshepperd explained otherwise above
09:59:36 <cocreature> selfsymmetric-mu: what do you mean by “pass it into a generic JSON parser”?
10:00:22 <geekosaur> yeh, I think type level nats are just going to be slow there. it's trivial to write but not encouraged
10:00:24 <selfsymmetric-mu> cocreature: `genericParseJSON` from `Data.Aeson`.
10:00:33 <geekosaur> much like there's no way to speed up indexing a linked list
10:00:52 <selfsymmetric-mu> Makes sense. I mean it's not very generic anymore if you're working with dynamic keys.
10:01:01 <cocreature> selfsymmetric-mu: right but what do you want to pass into that? the generic implementation won’t know what it should do with the value you inject into it
10:01:11 <selfsymmetric-mu> cocreature: Yeah, that's fair. Thank you!
10:02:05 <cocreature> selfsymmetric-mu: if your question is if you could make this work with a FromJSON instance then the answer is yes using a newtype and the reflection package similar to http://newartisans.com/2017/02/a-case-of-reflection/. but that still won’t use the generic implementation
10:02:20 <selfsymmetric-mu> Cool, thank you!
10:05:06 <gbd_628> geekosaur: Got it. There's no magic way to bind an inductive definition of Nat to an efficient internal representation, the way you can in Idris---is that right?
10:06:04 <geekosaur> right. haskell's not that great at type level stuff as yet
10:06:11 <geekosaur> they're working on it
10:06:45 <geekosaur> I suspect it's unlikely that haskell will ever be idris, though
10:32:18 --- mode: glguy set +v zallarak
10:44:58 <hyperisco> geekosaur, the perspective of that statement is astounding
10:45:43 <geekosaur> re idris? I see haskell focusing on a different part of the design space
10:46:03 <geekosaur> and not much reason to clone another language, tbh
10:46:36 <hyperisco> that there is a place to stand where Haskell seems capable of so much, and another place where Haskell seems capable of so little
10:48:57 <MarcelineVQ> it's capable of too much, isn't that the issue, it's inconsistent as a logic?
10:49:53 <MarcelineVQ> that's not being addressed with the upcoming work, that I've seen, and isn't a priority which I'm guessing is what geekosaur means by focusing on a different space
10:50:45 <geekosaur> right. my impression is the whole thing is deliberately exploring different directions from idris, and in particular looking for ways to stay "haskelly"
10:51:51 <geekosaur> there's a ghc wiki page on the intent of "dependent haskell" development
10:52:26 <MarcelineVQ> still, I sure wish I could use haskell libs in idris
10:56:33 <MarcelineVQ> anyone use Streamly? it's pretty neat lookin
10:59:39 <chin-tastic> how neat? on a scale from meh to exStreamly
10:59:43 <chin-tastic> I'll see myself out
11:01:12 <jackhill> chin-tastic: nice one ☺
11:02:21 <MarcelineVQ> fairly :>
11:02:46 <MarcelineVQ> http://hackage.haskell.org/package/streamly-0.4.1
11:08:20 <pikajude> why does -Wsafe warn even if the file has been marked {-# LANGUAGE Safe #-}
11:08:22 <pikajude> that seems a bit weird
11:09:18 <MarcelineVQ> the way the docs reads it only warns if it's marked safe
11:09:33 <MarcelineVQ> "-Wsafe   warn if the module being compiled is regarded to be safe."
11:09:45 <pikajude> :thinking:
11:10:23 <nshepperd1> Warning! Safety ahead!
11:10:25 <MarcelineVQ> idk if 'if' should be 'whether' since I've never used it :X
11:10:58 <pikajude> right nshepperd1 
11:11:00 <pikajude> bit weird
11:11:04 <MarcelineVQ> sounds like you might want -Wunsafe
11:11:12 <MarcelineVQ> or even -Wtrustworthy-safe
11:30:12 <inkbottle> Is it possible to disable "completion" in intero? (for emacs)
11:47:13 * hackage hinfo 0.0.1.0 - Command Line App With Info on your Haskell App  http://hackage.haskell.org/package/hinfo-0.0.1.0 (ChristopherDavenport)
11:54:14 * hackage hinfo 0.0.2.0 - Command Line App With Info on your Haskell App  http://hackage.haskell.org/package/hinfo-0.0.2.0 (ChristopherDavenport)
12:11:52 --- mode: glguy set +v dataN
12:11:55 <dataN> how can constraints be promoted to Type level?
12:12:47 <dmj`> Does anyone know of a package that parses valid SQL to some IR *and* contains a SQL DSL for constructing this IR
12:14:19 <dmj`> I suppose if a parser exists you can always just add a QQ for it
12:14:28 <dataN> what do you mean by a SQL DSL?
12:15:07 <dmj`> dataN: Like a monad that will allow you to express selection, restriction, projection. I don’t want it specific to any database in particular, just true to many SQL specs
12:16:28 <dataN> so just a DSL?
12:17:01 <dmj`> dataN: right, for constructing some SQL AST that can generate valid SQL in a variety of specifications, 92, 2011, etc.
12:17:29 <dataN> so just SQL!?
12:18:25 <mniip> mnoonan, '
12:18:26 <mniip> reflectEq _ = unsafeCoerce (Refl :: a :~: a)' this is unideal...
12:18:29 <mniip> it should at least be stric
12:19:00 <mniip> context: http://hackage.haskell.org/package/gdp-0.0.0.2/docs/src/Theory.Equality.html#reflectEq
12:19:13 * hackage prometheus-client 1.0.0 - Haskell client library for http://prometheus.io.  http://hackage.haskell.org/package/prometheus-client-1.0.0 (OliverCharles)
12:19:28 <dmj`> dataN: parsers into this AST, DSL for constructing the AST, and codegen for various SQL dialects
12:20:43 <dataN> so just an IR!?!?
12:20:47 <madnight> there are quasiquote DSLs for at least SQLite, PostgreSQL and MySQL
12:20:57 <dmj`> dataN: I cam
12:21:07 <dmj`> dataN: I can’t tell if you’re being serious
12:21:33 <dmj`> madnight: I’d like a unified AST over the dialects (if possible), and pretty printers back into the dialects
12:22:15 <dataN> at least one of those terms is superfluous 
12:22:43 * hackage primitive-extras 0.6.5 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.6.5 (NikitaVolkov)
12:23:16 <mnoonan> mniip: how come?
12:23:43 * hackage prometheus-metrics-ghc 1.0.0 - Metrics exposing GHC runtime information for use with prometheus-client.  http://hackage.haskell.org/package/prometheus-metrics-ghc-1.0.0 (OliverCharles)
12:23:45 <mniip> mnoonan, case reflectEq undefined of Refl -> ...   recovers unsafeCoerce
12:24:28 <mnoonan> ah, I see.
12:25:22 <mnoonan> on the other hand, you'd be explicitly saying "reflect this equality proof: _|_", so maybe you deserve trouble? ;)
12:25:25 <madnight> not sure if something like that already exist, maybe you can take some existing libs and glue them together
12:26:05 <mniip> mnoonan, ehh
12:26:25 <mniip> reflect _|_ should be _|_
12:26:33 <mniip> also known as strictness :P
12:26:36 <pgiarrusso> mnoonan: what if you reflectEq on some recursive function
12:26:43 * hackage wai-middleware-prometheus 1.0.0 - WAI middlware for exposing http://prometheus.io metrics.  http://hackage.haskell.org/package/wai-middleware-prometheus-1.0.0 (OliverCharles)
12:27:01 <pgiarrusso> mniip++
12:27:04 <mniip> on the other hand
12:27:20 <mniip> I wonder if there's a way you can turn proofs with computational content into those without
12:27:24 <dmj`> dataN: haskelldb might be what I want
12:27:28 <dmj`> @package haskelldb
12:27:28 <lambdabot> http://hackage.haskell.org/package/haskelldb
12:27:29 <mnoonan> mniip: I'm tempted to just remove that function anyway. the proofs are really supposed to be irrelevant.
12:28:06 <madnight> http://hackage.haskell.org/package/queryparser "There is a single abstract syntax tree (AST) for representing queries of any dialect." might be useful
12:28:13 * hackage primitive-extras 0.6.6 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.6.6 (NikitaVolkov)
12:28:40 <mniip> consider how neat it would be to have "obviously correct" proofs of arithmetic axioms in terms of 'succ' that don't suffer from the performance issues of unary encoding
12:29:52 <hyperisco> mniip, I am considering it. Now what?
12:31:43 * hackage stm-hamt 1.1.1 - STM-specialised Hash Array Mapped Trie  http://hackage.haskell.org/package/stm-hamt-1.1.1 (NikitaVolkov)
12:32:20 <mniip> hyperisco, is that not enough for you?
12:34:02 <dataN> class Exists x where exists :: x; class A i x; class B x i; type C c i x = (Exists (i->x),c i x); type D c i x = (Exists (i->x),c x i). C can be used with A, and B with D. how can C and D be written as one constraint?
12:34:04 <hyperisco> mnoonan, that is your paper, yes?
12:34:12 * mnoonan nods
12:37:08 <hyperisco> mniip, A way to do that is to separate proof and program. Not a lot of interest in such things though, it seems.
12:37:40 <mnoonan> mniip: also, even if you forced the argument, you still have "myUnsafeCoerce = reflectEq sorry"
12:38:39 <mniip> true
12:39:10 <crestfallen> hi learning haskell, I need to think about performance for the first time : https://ptpb.pw/ZCZr   this program is hanging two 64-bit OS, a late debian linux and OSX. I was reading about mathematicians using haskell and how fast it is. how could this program cause hangs ? (from hutton textbook)    thanks
12:39:57 <MarcelineVQ> compile and run it. ghci is holding onto memory for some reason
12:40:31 <hyperisco> just taking a quick gander, it doesn't have anything to do with the 500 second wait does it?
12:40:32 <MarcelineVQ> if it's still eating up your ram when compiled then there's an issue
12:40:43 * hackage stm-hamt 1.1.2 - STM-specialised Hash Array Mapped Trie  http://hackage.haskell.org/package/stm-hamt-1.1.2 (NikitaVolkov)
12:40:49 <crestfallen> I did yesterday MarcelineVQ. that was a 32-bit debian machine though.
12:41:04 <hyperisco> oh, that's not a 500 second wait, that's a 500000 counter
12:41:21 <crestfallen> yeah nothing 500 seconds about it
12:41:28 <int-e> :t Control.Concurrent.threadDelay
12:41:29 <lambdabot> Int -> IO ()
12:41:44 <mniip> hyperisco, if we could prove that if T is a singleton and f :: T -> T is terminating then f x = x
12:41:45 <hyperisco> watch out when you upgrade your CPU else you won't be able to play your video game anymore
12:42:40 <dataN> use of elem looks slow
12:43:00 <crestfallen> not sure, the "glider" pattern does run for a few "generations"
12:43:11 <crestfallen> elem , hmm
12:43:13 * hackage stm-containers 1.0.1 - Containers for STM  http://hackage.haskell.org/package/stm-containers-1.0.1 (NikitaVolkov)
12:43:32 <MarcelineVQ> it's some ghci issue, the program doesn't, or didn't last time you asked, exhibit a problem when compiled
12:43:59 <crestfallen> I just used main = life glider
12:44:13 <Profpatsch> Is it lawful to instantiate Bifunctor for a type like  newtype MyError e a = MyError (ExceptT e IO a)?
12:44:31 <hyperisco> Profpatsch, yes
12:44:35 <Profpatsch> thanks!
12:44:41 <crestfallen> only that this was on two machines, where I had similar performance.
12:48:04 <hyperisco> mniip, I look at it this way. Haskell is nice because it infers types. If it didn't we'd all despise it, and why? Because it would obfuscate the work. Core is not that fun to decipher.
12:48:12 <dataN> yes, it checks the neighbours of every live grid element against every live element. 
12:48:54 <hyperisco> So on the same principle, why would I want to meddle with how I would otherwise plainly write a program? The analysis I gain is probably not worth it.
12:49:07 <int-e> crestfallen: so a) you should use Control.Concurrent.threadDelay for waiting. b) you should compile your code; it appears that in interpreted code, sequence_ [return () | _ <- [1..n]] accumulates memory on the heap (I didn't investigate why...)
12:50:05 <int-e> crestfallen: c) to make compiled code work, you need to flush stdio manually (or change it to something different from line buffering); you can use  System.IO.hFlush stdout  for that.
12:50:31 <crestfallen> int-e: sorry, you mean replace wait function somehow altogether ? I don't understand the rest of your advice, sorry
12:51:07 <int-e> crestfallen: yes, replace the wait function by threadDelay (which takes a number of microseconds to wait)
12:51:32 <crestfallen> int-e: kindly explain how to do that
12:51:55 <int-e> import Control.Concurrent; later: wait n = threadDelay n
12:52:34 <crestfallen> thanks. so is 500000 a reasonable input?
12:52:46 <int-e> it's half a second
12:52:50 <hyperisco> mniip, Would it be interesting if you could write untyped code and later prove its type in some type system of choice?
12:52:57 <int-e> I'd prefer it to go a bit faster
12:53:01 <int-e> ymmv
12:53:03 <dataN> hmm, it shouldnt crash though... 
12:53:18 <crestfallen> ok thanks trying that. I wonder why Hutton (author) would have this problematic func.
12:53:25 <MarcelineVQ> it doesn't, it eats up all the ram
12:53:37 <dataN> why?
12:53:48 <hyperisco> thread delays are in microseconds? lol
12:53:52 <MarcelineVQ> because of what int-e said a little bit ago
12:54:05 <dataN> stdio? 
12:54:33 <MarcelineVQ> I am MarcelineVQ's sardonic twist.
12:54:39 <int-e> dataN: I don't know why exactly, but the 'wait' does cause it to allocate gigabytes of memory very quickly if the code is interpreted.
12:54:43 <MarcelineVQ> " it appears that in interpreted code, sequence_ [return () | _ <- [1..n]] accumulates memory on the heap (I didn't investigate why...)"
12:55:22 <crestfallen> what about the Flush part, just import the package?
12:55:41 <int-e> import System.IO; put hFlush stdout  before the delay
12:56:44 <MarcelineVQ> int-e: fwiw the code refreshes fine in my terminal when compiled
12:56:55 <MarcelineVQ> or did, idk if ti's changes since I saw it last I gues hehe
12:57:11 <dataN> so each recursive call cant be garbage collected because of calls to the previous boards?
12:58:46 <dataN> does it not store the current board and discard the previous versions?
12:59:26 <int-e> dataN: the following line, sequence_ (replicate 100000000 (return ())), causes ghci to grow to 6GB on my computer.
12:59:47 <crestfallen> wow
13:01:23 <int-e> dataN: but this is specific to interpreted code; the same code, compiled, takes a while but does not grow above a couple of MB in memory usage.
13:01:29 <hyperisco> You'd almost think it was strict.
13:04:10 <hyperisco> At any rate, don't bother with hot waiting unless you're doing some higher accuracy timing. Be green, go to sleep. :)
13:05:50 <dataN> it would be faster if it used nested zippers...
13:06:13 * hackage indexation 0.4.2.1 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.4.2.1 (NikitaVolkov)
13:06:18 <hyperisco> Could be faster in a lot of ways. Probably lists is a poor choice.
13:06:45 <hyperisco> If you really wanted to scream, write it for the GPU.
13:06:55 <MarcelineVQ> it's an example out of the hutton book, not sure if all parts of it are though
13:07:04 <dataN> zippers are only possible with lists!
13:08:05 <MarcelineVQ> Since I've seen another one someone else wrote exactly the same it's either from hutton in its entirety, or not
13:08:08 <hyperisco> Could probably get 100k FPS or something :P
13:08:16 <MarcelineVQ> the wait is just weird tho
13:08:16 <mniip> hmm, that reminds me
13:08:32 <dataN> e.g. checking the adjacent elements of a very long list scales with the length of the list, wheras for Array it scales with the number of adjacents checked... 
13:08:40 <int-e> This was a regression from ghc-7.8 to ghc-8.0. (Meaning that "sequence_ (replicate 100000000 (return ()))" in ghc-7.8.4 does not allocate tons of memory.)
13:09:53 <dataN> int-e: whats the reasoning behind that?
13:10:06 <MarcelineVQ> int-e: even so it's a wait timer akin to old dos game draw-rates, sure their speed made sense on a x286, but slap that onto a pentium and it's all just blurs
13:10:53 <hyperisco> I remember buying such a video game back when. Amusing...
13:10:55 <MarcelineVQ> not that it's a blur, just a short-sighted example
13:11:03 <int-e> ghc-7.10.2 is fine too.
13:11:09 <int-e> dataN: reasoning?
13:11:15 <dataN> why did they do that?
13:11:32 <int-e> dataN: I doubt that it was intentional
13:12:01 <hyperisco> "regression" implies that.
13:12:14 <crestfallen> MarcelineVQ: still working. actually yeah it's verbatim from the hutton btw
13:12:29 <int-e> dataN: or perhaps it's the call stacks going wild
13:12:38 <MarcelineVQ> still working on what?
13:12:47 <dataN> so e.g. for an almost infinite list, checking n neighbours becomes prohibitive if using arrays for large (but no where near as long as the list) n , but is fine for list.
13:12:52 <int-e> (ghc-8 added "Support for lightweight callstacks and source locations")
13:13:01 <crestfallen> getting it to not crash
13:13:33 <hyperisco> dataN, what does "almost infinite" mean?
13:13:59 <crestfallen> I'm watching it "glide" at an oblique with zeros, right through my prelude loading output
13:14:16 <dataN> e.g. find the nth prime, finite for finite n
13:14:56 <c_wraith> oh, I was thinking of like a list of all 512 but numbers. finite, but you'll never iterate all the way through it.
13:15:02 <c_wraith> *bit
13:15:03 <hyperisco> The size of the game is what it is. Not sure what a list or array changes about that.
13:15:27 <MarcelineVQ> how are you running it?
13:17:47 <dataN> no, the list should be accessed at some position that can be reached, but enough so that its faster not to retraverse to this point even though the fast random access containers can be traversed faster.. that is unless they memoise the traversal in some magic way, but this cannot be determined without instruction.
13:18:37 <dataN> which can actually become important for very low length lists with wide stencil convolutions.
13:20:25 <crestfallen> int-e: hi again, where precisely do I put hFlush stdout   ? I have  ' wait :: Int -> IO () ; wait 300000 = threadDelay 300000 '    
13:20:39 <crestfallen> sorry not clear about this
13:20:46 <hyperisco> dataN, I actually have no idea what you are comparing. You are saying adjacencies are faster to find with a linked list rather than an array, yes? But I don't see how.
13:21:17 <int-e> crestfallen: I'd put it into the "life" function, between the calls to `showcells` and `wait`.
13:21:31 <int-e> (or perhaps at the end of `showcells`)
13:21:54 <crestfallen> thanks let's see int-e
13:22:36 <dataN> e.g. finding the largest two primes p,q where q = p+2, this would be done using an accumulating counter. even if large numbers can be generated quickly via multiplication, there is no need to do so unless they are discarded. 
13:23:41 <hyperisco> I am not sure that exact problem can actually be solved in the way you are suggesting.
13:24:21 <dataN> fluid dynamics simulations make use of reasonably wide stencils (e.g. 5*5*5) 
13:24:21 <mniip> hmm
13:24:34 <mniip> can (||) :: Bool -> Bool -> Bool  be an open type family
13:25:08 <mniip> do 'True || b = True' and 'a || True = True' count as conflicting equations
13:25:21 <hyperisco> Okay but we're just talking about how the data is laid out in memory. Linked lists have benefits for manipulating the list structure, but have no benefit for accessing elements in comparison to an array.
13:26:02 <dataN> why not?
13:27:41 <hyperisco> The nth element in the list requires n+1 memory loads, whereas the nth element in an array requires 1 memory load.
13:27:54 <dataN> what?
13:28:17 <hyperisco> Well if we don't agree there then I guess we're not talking about the same thing.
13:28:32 <dataN> !?
13:29:37 <dataN> you made a claim and justified it in an unclear way, you could clarify.
13:30:59 <dataN> arrays are slower than lists in the examples provided.
13:31:21 <hyperisco> Your examples seem to be based solely on accessing elements of the data structure.
13:31:39 <dataN> yes, thats when they perform better
13:32:07 <dataN> lists have faster directed access, as opposed to arrays which have faster random access.
13:32:21 <hyperisco> I have to be getting trolled right now.
13:32:30 <gentauro> ahhh
13:32:49 <gentauro> finally managed to implement SHA1 in a "safe" manner only depending on Prelude -> http://blog.stermon.com/articles/2018/08/10/haskell-safe-sha1-only-depending-on-prelude.html
13:33:03 <dataN> well if it gets you justify your claim...
13:33:12 <hyperisco> Oh, I get it, arrays are only good at xs[random()] :)
13:33:27 <gentauro> mem is OK and performance well ...
13:33:28 <gentauro> :D
13:33:43 <dataN> right! and doing that over and over for adjacent elements is wasteful 
13:34:03 <geekosaur> remember that list adjacency works only in one direction
13:34:12 <geekosaur> they're not doubly linked lists
13:34:19 <dataN> thats why Zippers are used
13:35:25 <dataN> the lookup table approach used in the game of life example is one attempt to avoid the prohibitive slowdown of representing a 2d grid using lists.
13:35:55 <dataN> but with zippers this could be a much larger table with many more live squares and perform better.
13:36:03 <mniip> there needs to be a -XKitchenSink extension...
13:36:08 <madnight> gentauro: funny though, damn small linux is big compared to alpine linux
13:36:33 <mniip> starting a new haskell file to experiment with something only to have to write the same 50 extension names again
13:36:34 <MarcelineVQ> mniip: if there was it'd still be missing the one you really wanted for any particular moment
13:36:54 <mniip> MarcelineVQ, if it's a really cryptic extension I could add it separately
13:37:20 <dataN> mniip: is that why there are more language extensions that libraries?
13:37:51 <MarcelineVQ> just need your big 3  -XMostlyHarmless -XTypeTrickery -XOriginalGlasgowExts
13:38:02 <dataN> mniip: what about type level constraints?
13:38:10 <mniip> RankNTypes, TypeFamilies, GADTs, TypeInType, ScopedTypeVariables, FlexibleContexts, FlexibleInstances, DataKinds, TypeApplications, MultiParamTypeClasses, FunctionalDependencies, PolyKinds, ConstraintKinds, KindSignatures, EmptyCase, ...
13:39:11 <dataN> using constraints instead of function arguments to eliminate the order they are provided could be very helpful at Type level.
13:39:32 <mniip> MarcelineVQ, -XRichTypes -XRichSyntax -XLowlevel
13:39:51 <madnight> mniip: we need a new Standard ... Haskell 2020
13:39:58 <mniip> Lowlevel being MagicHash, UnboxedTuples, UnboxedSums
13:40:56 <MarcelineVQ> -XThatThingNoOneKnowsHowToUseJustByLookingAtButEveryoneAcutallyNeedsToBeCool
13:41:19 <dataN> classes depending on the order of parameters are not a good default. 
13:41:38 <geekosaur> bring back -fglasgow-exts?
13:41:38 <MarcelineVQ> what do you mean by this dataN
13:42:01 <gentauro> now a days, people write more language pragmas than actually code :\
13:42:48 <mniip> oh I know
13:42:56 <ndmitchell> Why doesn't --depth=1 or --shallow-submodules work with GHC git? I'm spending much longer and wasting more bandwidth than I want
13:43:00 <mniip> {-# LANGUAGE CPP #-} {-# LANGUAGE
13:43:04 <madnight> i think we will get a bunch of new Extensions soon ... see how many new proposals are accepted https://github.com/ghc-proposals/ghc-proposals/pulls?utf8=%E2%9C%93&q=label%3AAccepted+ by the committee in the past few month
13:43:06 <mniip> #include "kitchensink"
13:43:07 <mniip> #-}
13:43:33 <dataN> MarcelineVQ: it is the names of the parameters that are referred to in the body of the class definition, they cant be reordered because there is no other way to distinguish them, which type level constraints would solve. 
13:45:12 <madnight> yay -XDerivingVia
13:45:20 <MarcelineVQ> What's the advantage of being orderless?
13:45:34 <crestfallen> int-e: MarcelineVQ   thanks! its working beautifully with hFlush stdout  after showcells b and wait set to 600000
13:46:15 <monochrom> It is not so much orderless than order-insensitive.
13:46:36 <dataN> then two identical classes which differ only by permutation of its parameters could be written as one declaration.
13:47:13 * hackage PyF 0.6.1.1 - Quasiquotations for a python like interpolated string formater  http://hackage.haskell.org/package/PyF-0.6.1.1 (guibou)
13:47:39 --- mode: glguy set +v TS17
13:47:58 <dataN> just as how my using e.g. a Monoid constraint instead of taking arguments of type 'a' and 'a->a->a' in a particular order.
13:48:11 <TS17> quick beginner question: I'm looking for a recursion scheme (something like iterate, fold, unfold etc) that lets me do the following: Imagine some recursive data structure like a tree. I want to go up the tree recursively until I find the first parent node with a particular property, then return that property
13:48:57 <dataN> large class hierarchies can provide many functions to the scope of a body of a function without demanding this many arguments, and all the possible permutations of these leading to a different function.
13:49:47 <crestfallen> so if I may ask, Hutton says this at the beginning of the exercise : " Despite its simplicity, the game of life is in fact computationally complete, in the sense that any computational process can be simulated within it by means of a suitable encoding. "  
13:50:04 <crestfallen> phew
13:50:13 <emmanuel_erc> TS17: You could use the First Monoid and the foldMap function?
13:50:48 <crestfallen> btw thanks for your help dataN
13:52:06 <crestfallen> ^ wondering about Hutton quote ^ if anyone can comment ?
13:52:18 <TS17> is there nothing simpler? I was thinking something along the lines of `a -> (a -> (Either a b)) -> b`
13:52:22 <monochrom> The sentence is correct.
13:52:40 <dataN> seems to be reasonable, some kind of processor built of gliders perhaps? 
13:53:05 <dataN> or maybe on an infinite grid, any program could be represented...
13:53:06 <TS17> I mean it would be trivial to implement myself, but I'm sure something like this must already exist
13:53:50 <emmanuel_erc> TS17: \f -> getFirst . foldMap (First . f)
13:54:01 <emmanuel_erc> I'm not sure if there is something I'm missing
13:54:18 <c_wraith> TS17, I don't think that can be total. 
13:54:37 <int-e> crestfallen: http://conwaylife.com/wiki/Turing_machine may be the most concrete answer
13:57:23 --- mode: glguy set +v albeit
13:58:21 <TS17> Of course it would be possible that there is no parent node that can ever supply a `b` but you could simply solve that problem by wrapping it in a `Maybe`. In fact I am currently using Kotlin where the type system is rather primitive so it doesn't matter anyway. I just came here because I thought there must be a special name for this kind of recurs
13:58:22 <TS17> ion scheme/already exist such a function and Haskell programmers are obviously much better at FP than Kotlin programmers
13:59:18 <albeit> I'm trying to deserialize an object :: Foo that is an instance of Serialize (from cereal) with a conduit like "sourceSocket sock .| conduitGet get .| Conduit.print" but it fails as it can't deduce "MonadState Foo Get". Any tips?
13:59:45 <crestfallen> dang it started hanging again after I left it going for 10 minutes by the way
14:00:35 <dataN> type families can be used to pattern match over type synonyms defining constraints, but using this to e.g. extend a constraint by an additional parameter results in multiple equivalent representations, without type level constraints (kind classes?) the choice of the position of this additional parameter is arbitrary. 
14:01:03 <c_wraith> TS17, nothing special. it's a special case of a graph search. (special in that it's linear, so BFS and DFS are the same)
14:01:51 <c_wraith> heh. special case of X, but no special *term* for it.
14:02:17 <TS17> damn, so I have to come up with a name myself
14:02:18 <cocreature> albeit: sounds like you might be using "get" from Control.Monad.State instead of the one from Data.Serialize
14:02:22 <emmanuel_erc> <ok, nvm, there is a part of the conversation that I missed>
14:04:20 <albeit> cocreature: Argh, that was it. Thanks. 
14:04:33 <mniip> I have to say, it's more wieldy than expected
14:04:47 <mniip> http://tcp.st/iaxp.h
14:05:03 <MarcelineVQ> such weilding
14:05:58 <wrengr> with lenses, is there a shorthand operator foo such that (x `foo` l & l1.~y1 & l2.~y2) == (x & l.l1.~y1 & l.l2.~y2) ?
14:06:35 <dataN> mniip: would that be possible? 
14:07:41 <mniip> dataN, would what be possible
14:07:44 <dataN> e.g. promoted Given 
14:08:39 <dataN> or, Exists, to avoid considering reflection
14:09:12 <dataN> class Exists x where exists :: x
14:11:39 <dataN> something like; (c :: ?x => x -> Constraint) 
14:13:02 <mniip> ok, here's some fixes: http://tcp.st/wo63.h
14:13:40 --- mode: glguy set +v grembly
14:13:54 <mniip> then your average kitchen sink is reduced to {-# LANGUAGE CPP #-} #include "KitchenSink.h" {-# LANGUAGE RichTypes,  UnsafeTypes, RichSyntax, LowLevel, Derive #-}
14:14:56 <TS17> I can't believe there is no name for this. It's not even limited to graphs. For example you could write something like `isEven num = foo num \x -> if x >= 2 then Left (x - 2) else Right (x == 0)` where `foo :: Int -> (Int -> Either Int Bool) -> Bool`    
14:15:00 <Gurkenglas> wrengr, the LHS of the == has l as a value and its RHS has l as a lens, is that intended?
14:16:10 <wrengr> Gurkenglas: the goal is just to avoid duplicating the lens whenever we follow it up with a bunch of lens updates to the same subcomponent of x
14:16:45 <ChaiTRex> Is there a way to see a program after Template Haskell has run on it (not just the spliced values, but the entire document afterwards)?
14:17:06 <wrengr> I mean, I can always play around with flip and the (>>=) for Reader, but it'd be nice if there were already a symbol for doing that
14:17:17 <mniip> TS17, \f -> until isLeft (>>= f)
14:17:17 <Gurkenglas> Oh, I misread the question then
14:17:48 <Gurkenglas> wrengr, x & l %~ (l1.~y1) . (l2.~y2)
14:17:49 <madnight> mniip: that's a good idea, but you can also define them in the cabal file right?
14:17:56 <c_wraith> wrengr, you can use (&~) and the stateful lens operations
14:18:13 <mniip> madnight, when I "experiment" with some stuff I often don't even have a folder
14:18:16 <mniip> let alone a cabal file
14:18:19 <wrengr> yeah, I know about (&~), but I've no need for it to be stateful per se
14:18:23 <crestfallen> https://ptpb.pw/3NRk  <   the game of life .. if not too stale by now, any critique appreciated 
14:18:52 <wrengr> Gurkenglas: thanks. I was just making my way around to guessing (%~) would work here
14:18:52 <Gurkenglas> crestfallen, concat (map f x) is concatMap f x
14:18:53 <c_wraith> wrengr, it's just a convenient way to maintain a focus on a subcomponent
14:18:53 <mniip> crestfallen, -1, not enough comonads
14:18:57 <mniip> :P
14:19:24 <madnight> mniip: so you suggest that header only for experiments
14:19:26 <dataN> newtype X (c :: ('Exists k1,'Exists k2) => Constraint) (x :: k1) (x :: k 2) = X ('using (k1,k2) c)
14:19:28 <Gurkenglas> crestfallen, concatMap is >>= for lists, so you can get rid of it with an additional <- line in that list comprehension
14:19:28 <crestfallen> don't know about those
14:19:59 <dataN> mniip: ^, couldnt avoid type level reflection :(
14:21:02 <mniip> madnight, I mean even if GHC were to officially support such a "synonym" it would only be available in a newer version
14:21:20 <Gurkenglas> Disregard that, getting the >>= out of "rmdups (b >>= neighbs)" would require something like that extension that lets you use sort on the whole list in an extra line
14:22:23 <madnight> mniip: i think it would be somewhat crazy to have an extension for extensions
14:22:27 <ChaiTRex> crestfallen: See http://www.drdobbs.com/jvm/an-algorithm-for-compressing-space-and-t/184406478
14:22:51 <mniip> madnight, crazy good?
14:23:12 <mniip> they should let TemplateHaskell emit LANGUAGE pragmas :P
14:23:23 <pie_> mnoonan, is this you? :D https://www.reddit.com/r/haskell/comments/8qn0wr/safe_api_design_with_ghosts_of_departed_proofs/ I know this is only a month old, but what's the status?
14:23:41 <dataN> maybe something like; data X c where X :: 'Exists k => (c :: 'Exists k => Constraint) -> X c
14:23:43 <Gurkenglas> crestfallen, you could still use that extension though if you find it pretty :P https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-TransformListComp
14:24:46 <Gurkenglas> Oh wait, requires forall a. [a] -> [a]? :S soz
14:24:54 <dataN> more generally; data X c where X :: p k => (c :: p k => Constraint) -> X c, where p is a kindclass!
14:24:55 <madnight> mniip, nope it feels like there is something wrong then, i mean where should that end? maye someone then say's hey i need another common mix of extension but with feature xy let's write an extension for that
14:25:23 <crestfallen> Gurkenglas: very sorry I don't follow. this is a book example that some members helped me improve significantly with ' hFlush stdout ' though after I left it running for 10 mins it crashed my system again. not sure about extensions, etc
14:26:07 <ChaiTRex> crestfallen: If you're on Windows, watch the resource usage in Task Manager. On something else, try `top`.
14:26:19 <ChaiTRex> crestfallen: See whether it starts using up too much memory or something.
14:26:27 <dataN> hmm thats too much like ':: p k =>' as in p being a typeclass...
14:26:42 <dataN> idk how it would work!
14:26:48 <madnight> mniip, extensions that are well accepted and battle proved should be integrated into the language
14:27:07 <crestfallen> ChaiTRex: thanks it was working great for < 10 mins
14:27:09 <Gurkenglas> (Though their example doesn't seem to be fully polymorphic, huh.) crestfallen, sorry for confusing, I don't think the extension helps :P
14:27:37 <ChaiTRex> crestfallen: The most common reason for a Haskell program to appear to hang a system is that it uses to much memory.
14:27:44 <mniip> madnight, problem is, haskell98 is fairly easy to implement (under a few thousand work hours)
14:27:56 <mniip> haskell with TypeFamilies? nearly impossible
14:28:06 <Gurkenglas> crestfallen, life has explicit avoidable monadic recursion, I try to avoid such
14:28:41 <Gurkenglas> :t iterate -- crestfallen, you could apply this to nextgen and glider to get an infinite history of boards
14:28:41 <mniip> there's extensions that we take for granted but whose implementation is so complicated that if it were to become part of haskell, that'd effectively make GHC the only compiler forever
14:28:42 <lambdabot> (a -> a) -> a -> [a]
14:29:00 <madnight> mniip, how about languages like Idris, Adga and Coq they also support them
14:29:07 <dataN> data p k => X (c :: p k => Constraint) where
14:30:01 <crestfallen> oy vay
14:30:23 <Gurkenglas> so "for_ (iterate nextgen glider) $ \b -> do cls; showCells b; hFlush stdout; wait 600000" would separate the IO from the looping
14:30:32 <mniip> dataN, I did think of a typeclass for RuntimeRep at one point
14:30:57 <grembly> is cloud haskell really just as good if not better than erlang/otp? is it ready for primetime?
14:31:02 <mniip> turns out that's extremely problematic to write as you can't do recursion on lists in UnboxedTupleRep
14:31:02 <dataN> whats that?
14:31:32 <mniip> well did you know that * = TYPE LiftedRep
14:31:40 <mniip> LiftedRep :: RuntimeRep
14:31:46 <Gurkenglas> :t nub -- crestfallen, rmdups has been done
14:31:47 <lambdabot> Eq a => [a] -> [a]
14:31:51 <madnight> mniip, haskell should be allowed to slowly evolve and don't end up in a extension hell of doom
14:31:51 <dataN> omg!
14:32:31 <mniip> madnight, imagine the specification hell that comes with RankNTypes
14:32:45 <mniip> the way it works is entirely dependent on GHC's typechecker
14:33:14 <madnight> mniip, lets start with the basics like overloaded strings
14:33:18 <dataN> so just parse the ghc source through some pretty-printer...
14:33:19 <crestfallen> Gurkenglas: kindly edit this paste.
14:33:21 <crestfallen> https://lpaste.net/3657999881949151232
14:33:35 <mniip> madnight, are you suggesting OverloadedStrings be enabled by default
14:33:47 <Gurkenglas> TS17, I'm not sure what you mean by "up the tree". Can you give a type signature for the function you want?
14:34:07 <madnight> mniip, yes with an option to disable it if needed
14:34:09 <MarcelineVQ> why are you asking people to critique something you copied out of a book :X
14:34:49 <TS17> something along the lines of  `a -> (a -> (Either a b)) -> b` (ignoring totality issues)
14:34:54 <dataN> is that something to do with kind classes?
14:35:11 <dataN> the RuntimeRep thing...
14:35:11 <mniip> dataN, kind-of
14:35:13 <mniip> :P
14:35:44 <mniip> dataN, what are you trying to do with kind classes anyway
14:35:57 <dataN> whats that about recursion on lists of UnboxedTupleRep?
14:36:01 <TS17> imagine you have some tree of widgets and you are given a child widget. Now you want to find the first parent widget that is a LinearLayout
14:36:02 <crestfallen> Idk one member's advice improved the performance. I'm just trying to see if it can work. I don't see why this would hang a machine when haskell is used for high math. sorry I just don't understand 
14:36:09 <mniip> with TypeInType I'm pretty sure you can already say 'forall k. Cls k => forall (a :: k). ...'
14:36:10 <madnight> mniip, next thing -XPackageImports, make them default
14:36:23 <MarcelineVQ> crestfallen: have you compiled it and ran that?
14:36:33 <dataN> mniip:the motivation is actually pretty sparse, just need Exists at type level.
14:37:33 <dataN> so that parameters can be provided without permutation equivalence; classes that are the same except with the parameters permuted.
14:37:42 <POGtastic> quick, really dumb question that I can't seem to find an answer for online. say that I've got a data type that has many, many alternatives (like a lexer with a whole bunch of tokens). Can I split this over multiple lines?
14:37:59 <crestfallen> MarcelineVQ shit *very sorry* I haven't tried stack yet. many thanks
14:38:01 <dataN> but probably there are other uses.
14:38:01 <madnight> mniip, next thing LambdaCase, very easy specification, make it default
14:38:11 <POGtastic> I want "data Token = foo | bar | baz | ....," but I don't want it to be an utterly massive line.
14:38:29 <crestfallen> it's been forever since I've used it
14:39:42 <infinisil> POGtastic: Um, just slap some newlines after foo, bar, baz?
14:39:58 <infinisil> usually the | is made to be directly under the =
14:40:06 <dataN> class hierarchies replace permutation equivalent function arguments, this would be good at type level. 
14:40:11 <MarcelineVQ> you don't need stack specifically if you have ghc on the command line    ghc myfile.hs   but if you use stack it should be as easy as  stack exec -- ghc myfile.hs
14:40:11 <mniip> dataN, so some kind of kind 'Ex' type with type families Exists :: p k -> Ex p, RunExists :: (forall k. p k -> r) -> Ex p -> r
14:40:19 <POGtastic> infinisil: ooo, looks like it works iff I have indentation with later statements.
14:40:26 <MarcelineVQ> stack ghc myfile.hs   might work, idk if that's for project's or not
14:40:29 <POGtastic> with the second line of the statement*
14:40:50 <POGtastic> thanks. googling this didn't say anything. i guess everyone thought it was obvious :/
14:40:58 <mniip> dataN, can't you lift a GADT to achieve this?
14:41:53 <dataN> it would make something like a lifted Dict possible 
14:42:07 <glguy> POGtastic: https://github.com/glguy/irc-core/blob/v2/lib/src/Irc/Message.hs#L71
14:42:20 <madnight> POGtatsic, https://en.m.wikibooks.org/wiki/Haskell/GADT#Summary
14:42:59 <POGtastic> correction, i'm just really bad at googling
14:43:00 <mniip> dataN, but you can just lift Dict
14:43:26 <mniip> ooh
14:43:27 <mniip> you cannot
14:43:28 <dataN> but whats that equivalent to? there is nowhere to put the => in the kinds...
14:43:53 <mniip> so we have kind equalities but no kind contexts?
14:43:55 <dataN> data p k => X (c :: p k => Constraint) where
14:47:36 <infinisil> dataN: Pretty sure that's just another type parameter
14:48:31 <dataN> no, p is a kindclass.
14:51:41 <dataN> e.g. kindclass P k1 k2 where i :: k1 -> k1 -> *; j :: k1 -> k2 -> k2 
14:52:31 <mniip> hmm
14:52:36 <mniip> I should push this on hackage
14:52:40 <mniip> maybe
14:53:31 <dataN> then can write; data P k1 k2 => X (c :: i -> j -> Constraint) where X :: c -> X c
14:54:06 <dataN> maybe k1 k2 are not in scope there, not sure, sorry. 
15:00:36 <Gurkenglas> crestfallen, https://gist.github.com/Gurkenglas/a35db3b5dc86812b8dbce85d84107c5f
15:02:09 <crestfallen> thanks kindly Gurkenglas looking at that. member made the point for two days that I hadn't compiled the program yet. flustered, but thanks again, working on it 
15:02:17 <grembly> is cloud haskell really just as good if not better than erlang/otp? is it ready for primetime?
15:05:56 <Gurkenglas> :t \f -> either id absurd . iterateM_ f -- TS17
15:05:58 <lambdabot> (a -> Either c a) -> a -> c
15:06:14 <Gurkenglas> iterateM_ from Control.Monad.Loops
15:07:42 <madnight> grembly: i can recommend: write a small non trivial programm with it and find out if it fits your needs
15:07:52 <Cale> grembly: Design-wise, I think it is. Has it been battle-tested at all? I have no idea.
15:07:58 <albeit> Does it seem reasonable to take ~5 microseconds to send ~200 bytes over a socket with sendAll?
15:08:51 <TS17> Gurkenglas no idea how that works. I am more interested in a name anyway. I was thinking it might be something like catamorphism, paramorphism...
15:09:03 <c_wraith> grembly, it is not just as good as OTP. it is good, and it's production quality in the core parts, but there are a lot of things in Zotp
15:09:07 <TS17> But it's probably just regular old recursion
15:09:25 <c_wraith> oops. a lot of things in OTP that aren't covered by cloud haskell.
15:09:30 <c_wraith> hit send too soon.
15:11:09 <Gurkenglas> :t let foo f = either id id . fmap (foo f) . f in foo -- TS17, written like this it's a hylomorphism
15:11:11 <lambdabot> (a -> Either c a) -> a -> c
15:11:11 <Cale> Oh, yeah, you should be aware of what it actually covers :)
15:11:39 <madnight> well the haskell community is bigger than the erlang community, so he gets better community support and more overall acceptance
15:14:40 <TS17> Gurkenglas thx I will look into it, but your use of `id` suggests that hylo is not the most fitting/general recursion scheme. I think it's just regular recursion without a special name
15:15:53 <grembly> madnight, Cale, c_wraith: thanks, guys. i'm definitely gonna give it a try. erlang/otp in haskell seems like it should be a distributed dream. is cloud haskell development/improvement still active though?
15:16:00 --- mode: glguy set +v AndiK
15:16:04 <AndiK> albeit: https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html
15:16:13 <AndiK> albeit: Sounds reasonable by these numbers
15:16:25 <Gurkenglas> TS17, most specific you mean
15:18:10 <mniip> hmm, are hackage candidates not built on the hackage matrix?
15:21:38 <madnight> grembly, https://github.com/haskell-distributed/distributed-process latest commit to master was 12 Jun so it would say yes
15:30:44 <Cale> Doesn't seem terribly active though, but that package itself shouldn't see too many changes
15:35:59 <ZeuPiark> bye
15:37:42 <`Guest00000> how to manage memory (allocate, deallocate) inside FFI'd libraries?
15:39:46 <`Guest00000> can i just call OS' memory management functions inside FFI'd functions, will it break anything in Haskell?
15:41:20 <ab9rf> `Guest00000: it might
15:41:36 <madnight> `Guest00000: https://wiki.haskell.org/Foreign_Function_Interface#Memory_allocation
15:42:08 <ab9rf> `Guest00000: also see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#memory-allocation
15:46:02 <ab9rf> `Guest00000: in general, if you use malloc/free in code called via FFI, nothing bad will happen, but you need to be aware of memory leak risks, and also be aware that FFI functions not marked as 'unsafe' may be running on more tjhan one thread concurrently
15:46:04 --- mode: glguy set +v thetallguy
15:48:55 <ab9rf> the RTS will not ensure that memory allocated by code called via FFI is ultimately released
15:50:02 <ChaiTRex> What is the best way using only primitive operations to get a pure ByteArray# with some constant contents?
15:51:37 <ab9rf> `Guest00000: obviously, if you call brk/sbrk from the FFI to reduce the working set, you'll probvably crash the RTS :)
15:53:16 <`Guest00000> probvably
15:53:41 <`Guest00000> thank you for info
16:09:06 <mniip> what -I path does GHC use by default with -XCPP?
16:12:43 <mniip> hmm
16:18:24 <mniip> can I place a file in a custom location with cabal?
16:20:55 --- mode: glguy set +v nineonine
16:20:59 <nineonine> question about concurrency
16:21:02 <nineonine> I have a function
16:21:12 <nineonine> receiveMessages :: ProgressReportMailBox -> Logger -> TVar ProgressReport -> IO ()
16:21:34 <nineonine> when I have it eta-reduced, it always deadlocks
16:21:35 <nineonine> receiveMessages = forever . messageCallback 
16:21:44 <nineonine> but when I pass all arguments explicitly it works ok
16:21:47 <nineonine> any idea?
16:22:18 <hpc> what's the definition, not eta-reduced?
16:22:23 <hpc> that you're trying?
16:22:33 <nineonine> receiveMessages progRepMbox logger progRepTVar = forever $ messageCallback progRepMbox logger progRepTVar
16:22:51 <nineonine> just reading from the TBQueue
16:23:08 <hpc> so, forever . messageCallback = \x -> forever (messageCallback x)
16:23:13 <hpc> eta-expanding /that/
16:23:38 <hpc> is \progRepMbox logger progRepTVar -> forever (messageCallback progRepMbox) logger progRepTVar
16:23:50 <hpc> i don't know how that typechecks, but i think that's your issue
16:24:10 <hpc> maybe some Monad ((->) e) stuff going on
16:24:17 <hpc> :t forever
16:24:18 <lambdabot> Applicative f => f a -> f b
16:24:21 <hpc> er, Applicative
16:24:35 <mniip> hmm
16:24:39 <mniip> I might need a custom Setup.hs
16:24:43 <mniip> never done this before...
16:26:14 <madnight> @pl receiveMessages progRepMbox logger progRepTVar = forever $ messageCallback progRepMbox logger progRepTVar
16:26:15 <lambdabot> receiveMessages = ((forever .) .) . messageCallback
16:26:45 <madnight> nineonine: your eta-reduction is wrong
16:27:03 <EvanR> surprised that it type checks
16:29:43 <nineonine> yeah, that suprrises me as well
16:29:54 <nineonine> trying ((forever .) .) . messageCallback 
16:29:59 <nineonine> give me vew minutes here
16:30:01 <nineonine> few*
16:30:09 <EvanR> that looks wacky
16:30:22 <nineonine> for sure, just to checking if it works
16:31:48 <nineonine> yes, it works
16:32:07 <EvanR> a "way" to do what youre trying to do is
16:32:15 <EvanR> forever .:: mycallbackthing
16:32:27 <EvanR> where .:: is (.) . (.) . (.) but its still wacky
16:32:49 <EvanR> one : / . (.) or each argument youre trying to delay
16:37:19 <mniip> I've never used .:: style things but if I had to I'd rather <$$$> = fmap . fmap . fmap
16:38:13 <hpc> :t (<$$>)
16:38:14 <lambdabot> error:
16:38:14 <lambdabot>     • Variable not in scope: <$$>
16:38:15 <lambdabot>     • Perhaps you meant one of these:
16:38:20 <hpc> oh cool, it's not taken
16:38:34 <hpc> :t (<**>) -- maybe this is what i was thinking of?
16:38:35 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
16:38:36 <mniip> well, <**> is kind of taken
16:39:39 <mniip> while thinking whether I should mention it's not "flip (<*>)" I came up with a neat way to phrase it
16:39:52 <mniip> liftA2 (flip id), versus  flip (liftA2 id)
16:54:25 <Gurkenglas> Is moving projects to other filepaths fine or should I repeat the build from the start?
17:02:22 <geekosaur> repeat the build, or edit the package registry and regenerate its index (ghc-pkg recache)
17:02:42 <geekosaur> which will need an option to point it to the right packagedb
17:06:43 * hackage hinfo 0.0.3.0 - Command Line App With Info on your Haskell App  http://hackage.haskell.org/package/hinfo-0.0.3.0 (ChristopherDavenport)
17:08:05 <mniip> hmm
17:08:28 <mniip> I can't seem to get build-type: Custom to work
17:10:01 <mniip> or rather, it seems that my postInst hook isn't called
17:11:47 <mniip> ah cool
17:11:52 <mniip> a cabal issue that's open since 2016
17:12:00 <ab9rf> weekend project!
17:12:07 * ab9rf runs
17:12:33 <mniip> ab9rf, distributing the fix on other systems isn't a weekend projects
17:12:51 <ab9rf> mniip: depends on how much charge your time expander has
17:33:36 <pie_> is a heavily callback based architexture bad for compiler optimizations?
17:33:49 <mniip> in an impure language - maybe
17:34:13 <pie_> I have a lot of stuff in IO :/
17:34:28 <pie_> and I think I also have a decent amount of IORefs
17:34:49 <pie_> thoug at this point im not sure what is and isnt considered impure anymore
17:41:52 <ab9rf> all my code is pure because i have a pure heart :)
17:43:13 * hackage project-m36 0.5 - Relational Algebra Engine  http://hackage.haskell.org/package/project-m36-0.5 (agentm)
17:43:29 <EvanR> a pure function is . . . ends up being "a function as in math", i.e. a function. making pure redundant
17:43:39 <EvanR> and then in haskell people call random other things pure
17:45:13 * hackage discord-haskell 0.5.0 - Discord bot library for Haskell  http://hackage.haskell.org/package/discord-haskell-0.5.0 (Aquarial)
17:45:31 <mniip> EvanR, let's just call them morphisms
17:45:38 <mniip> as they're not really functions
17:46:04 <mniip> (they're a particular kind of monotonic functions between domains)
17:46:06 <EvanR> why, because of undefined?
17:46:24 <mniip> but also they have a computational context
17:47:07 <EvanR> its funny the focus in haskell really shifts from functions to thunks
17:47:22 <mniip> yup
17:47:49 <mniip> well except for one case I discovered recently
17:48:28 <mniip> % whnf a = case seq a () of () -> void#
17:48:29 <yahb> mniip: 
17:48:35 <mniip> % let x = whnf undefined in ()
17:48:36 <yahb> mniip: ; <interactive>:77:14: error:; * Couldn't match type `Void' with `GHC.Stack.Types.CallStack'; arising from a functional dependency between:; constraint `?callStack::GHC.Stack.Types.CallStack' arising from a use of implicit parameter `?callStack'; instance `GHC.Classes.IP s Void' at <interactive>:1:10-30; * In the first argument of `whnf', namely `undefined'; In t
17:48:43 * hackage ats-pkg 3.2.1.8 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-3.2.1.8 (vmchale)
17:48:53 <mniip> oh huh did I not unbreak implicitparams
17:48:59 <mniip> % :q
17:48:59 <yahb> mniip: 
17:49:01 <mniip> % let x = whnf undefined in ()
17:49:02 <yahb> mniip: ; <interactive>:1:9: error: Variable not in scope: whnf :: t0 -> t
17:49:07 <mniip> % whnf a = case seq a () of () -> void#
17:49:08 <yahb> mniip: 
17:49:10 <mniip> % let x = whnf undefined in ()
17:49:10 <yahb> mniip: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:3:14 in interactive:Ghci5
17:49:31 <ab9rf> that is an obscure error
17:49:48 <ab9rf> obtuse rather
17:50:09 <mniip> nah, it's what I did was really discreet
17:50:25 <mniip> import GHC.Classes.IP; instance IP s Void
17:51:04 <mniip> causes every 'let ?id = ...' bind (and CallStack apparently) to run into a violated functional dependency issue
17:52:40 <mniip> neat, HasCallStack is just  ?callStack::CallStack
17:53:38 <mniip> neat, lambdabot crash
17:53:43 <mniip> > (?callStack) `seq` ()
17:53:45 <lambdabot>  mueval-core: internal error: PAP object entered!
17:53:45 <lambdabot>      (GHC version 8.2.2 for x86_64_unknown_linux)
17:53:45 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
17:54:37 <mniip> ah, it's not really related to callStack
17:54:40 <mniip> any IP will do
18:02:53 <ab9rf> heh
18:04:10 <mniip> I wonder why that happens
18:04:27 <mniip> is it entering the 'IP "callStack" a -> ()' elaborated function?
18:06:52 --- mode: glguy set +v zallarak
18:15:16 <mniip> I wonder if there's an unsafeCoerce hidden somewhere here
18:35:32 <Gurkenglas> "Progress 184/207: aeson-1.3.1.1, conduit-1.3.0.3, lens-4.16.1ghc-pkg.EXE: cannot find package conconduit-extra-1.3.0: using precompiled package" <- That looks like some output wasn't piped properly?
18:52:36 <crestfallen> hi while trying to build a stack project, I get the error: Missing dependency on a foreign library: * Missing C library: G  This problem can usaully be solved by installing the system package that provides this library (you may need the dev version).
18:52:58 <dmwit> mniip: I think it's not *just* ?callStack::CallStack.
18:53:12 <dmwit> mniip: Because I think the compiler magically makes a value for that IP.
18:53:26 <dmwit> (Also the docs say not to rely on the fact that it is implemented using IPs.)
18:53:47 <crestfallen> anyone know that package? I tried to install libudev-dev to no avail
18:53:58 <crestfallen> on a debian stretch machine
18:54:43 <dmwit> Oh man, I can never remember what mechanism cabal uses to detect C libraries.
18:54:46 <dmwit> Is it pkg-config?
18:55:04 <EvanR> "libg is a runtime library for g++."
18:56:11 <sclv> dmwit: it can use that
18:56:49 <sclv> https://cabal.readthedocs.io/en/latest/developing-packages.html?highlight=pkg-config#pkg-field-pkgconfig-depends
18:58:03 <crestfallen> the error is way longer, I thought that was the gist of it
18:58:38 <crestfallen> btw I upgraded stack
19:00:42 <crestfallen> anyone familiar with that error?
19:06:19 <dmwit> crestfallen: I think what sclv is telling you is that you haven't provided enough information yet.
19:06:33 <dmwit> e.g. perhaps sharing a cabal file would be in order at this point.
19:08:04 <crestfallen> one moment thanks dmwit 
19:09:37 <crestfallen> sclv dmwit this is the proj cabal file https://ptpb.pw/tszx
19:14:36 <monochrom> Yes please try to stick to "HasCallStack =>" and pretend you don't know the implementation detail. :)
19:15:01 <sclv> crestfallen: i don't see anything in that cabal file that seems to imply a dep on a C library?
19:17:47 <crestfallen> sclv, sorry clueless here. Just want to compile a textbook program
19:19:24 <monochrom> I don't recall any Hutton textbook example that needs a foreign library.
19:19:54 <monochrom> OTOH it certainly doesn't anticipate stack either.
19:20:18 <crestfallen> I'm in the directory, using stack build life-exe. is that wrong?
19:20:29 <sclv> crestfallen: can you paste the full error in a pastebin?
19:22:34 <crestfallen> sclv, thanks its a widow-maker https://ptpb.pw/W2Pt
19:24:10 <crestfallen> how would anyone understand stack
19:24:39 <ab9rf> osmosis
19:26:35 <Gurkenglas> crestfallen, I think "stack exec pacman -- --help" could get you somewhere
19:27:48 <sclv> crestfallen: ok so somehow this isn't building just that cabal file, but something that depends on the opengl package, and the missing library isn't "G" but "GL"
19:28:46 <sclv> the cabal file you pasted had no deps at all!
19:29:00 <Gurkenglas> (helped me install things iirc)
19:29:11 <sclv> so the first thing to figure out is why the heck you have OpenGLRaw in your deps at all
19:29:18 <crestfallen> sclv, sorry I need a total walkthrough if you have time
19:29:20 <sclv> and if you actually intend to or not
19:29:38 <sclv> ok -- so what files are in the directory? did you create them all or did you check them out from somewhere?
19:31:23 <Gurkenglas> On second thought, that four-letter guy sounds like he has more of an idea on this stuff ^^
19:31:38 <crestfallen> they were created: there's an app directory and an src with a module Lib in it
19:31:58 <sclv> crestfallen: figured it out!
19:32:04 <sclv> you called `stack build life` not `life-exe`
19:32:14 <crestfallen> tried it
19:32:17 <sclv> so stack is trying to build the `life` package from stackage!
19:32:18 <sclv> https://hackage.haskell.org/package/life
19:32:33 <sclv> or ackage
19:32:35 <sclv> hackage
19:32:50 <sclv> and that package, which is not yours, is what has the dependency on opengl
19:33:10 <Gurkenglas> You looked in the reverse dependencies of opengl? :D
19:33:12 <sclv> try just a raw `stack build` or just try `cbal build`
19:33:27 <sclv> Gurkenglas: no i looked at the error message and saw what the argument was :-)
19:34:56 <crestfallen> life-exe doesn't work
19:35:15 <crestfallen> what about that src directory should I delete that?
19:35:20 <sclv> no
19:36:05 <crestfallen> I tried running it from the parent directory, the project directory, and the app directory
19:36:07 <sclv> what about `stack build` with no arguments at all?
19:36:14 <sclv> you should run it from the directory containing the cabal file
19:36:33 <mniip> ugh
19:36:34 <mniip> anyone here ever write a Setup.hs file?
19:36:35 <crestfallen> "The specified targets matched no packages
19:36:37 <crestfallen> "
19:37:06 <sclv> ok.. ummm rename the package?
19:37:22 <sclv> sorry, i could pinpoint the error but i'm more of a cabal user
19:37:31 <sclv> not sure the exact target syntax of stack
19:37:58 <sclv> crestfallen: possibly you need a stack.yaml file to use it at all?
19:38:39 <crestfallen> I have package.yaml file
19:39:23 <sclv> you need a stack.yaml
19:39:32 <sclv> https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
19:40:00 <crestfallen> the yaml files says - executables: life-exe
19:40:16 <crestfallen> ok thanks I'll sleep on it sclv
19:40:28 <sclv> at least i could point to the error :-)
19:40:34 <crestfallen> how do I run it with cabal commands?
19:40:51 <sclv> just type "cabal build"
19:41:09 <sclv> you have no deps so no reason to do anything more complicated i'd otherwise recommend
19:41:25 <sclv> (assuming you have a ghc installed that cabal can find, and not just the one managed by stack)
19:42:19 <sclv> you should do so in the directory where the cabal file is, with the src/ subdirectory
19:43:30 <crestfallen> I think cabal compiled it fine. what's the cabal exec command?
19:43:59 <sclv> you just run the compiled binary directly
19:45:02 <sclv> it'll be somewhere in dist/build/
19:45:51 <crestfallen> getting warmer
19:47:40 <crestfallen> sclv, bingo!
19:48:02 <sclv> :-)
19:48:26 <crestfallen> running beautifully. hope Marceline*VQ smiles .. thanks sclv kindly 
19:48:38 <sclv> note that as you move to more complex projects with real deps you should learn to use "cabal new-build" (which is the new way) or sandboxing (which is slightly older but also works) to manage them more modularly
19:48:48 <sclv> but this was the fastest way to just get you up and running for simple low-dep stuff
19:49:23 <crestfallen> sclv, cool I need to take notes on all this !
20:02:17 <ab9rf> i do not miss cabal hell
20:11:21 <glguy> Me neither. I'm glad that's in the past
20:17:39 * dmj` mutters something about nix
20:20:44 <dmj`> anyone have a cool deriving via example
20:24:30 <Myrl-saki> What do you call it when you have a type in the definition of a typeclass?
20:24:58 <glguy> "associated type"
20:25:11 <Myrl-saki> Ah, same as Rust. :P
20:27:29 <ChaiTRex> Ahh, found it. runRW# lets you get a pure ByteArray#.
20:28:41 <centril> Myrl-saki: this particular naming came from Haskell ;)
20:29:05 <Myrl-saki> centril: It's just that I've been usin Rust recently. :P
20:29:06 <centril> (or possibly C++ if Haskell got it from there...)
20:29:29 <centril> Myrl-saki: yeah me too; I've been working on designing Rust as a language for some time now =)
20:31:38 <butterthebuddha> What are some actual use cases for ZipLists
20:32:03 <butterthebuddha> Actually, here's a more pointed question: why use a ZipList over a double linked list?
20:34:21 <c_wraith> what do those even have to do with each other?
20:34:25 <Myrl-saki> centril: Oh! :P I actually stumbled into an issue that you made (Box::leak) :P
20:34:42 <c_wraith> ZipList is just a wrapper around [] that provides a zipping Applicative instance and no Monad instance
20:35:01 <butterthebuddha> Well a ziplist allows you to walk backwards efficiently
20:35:05 <c_wraith> No it doesn't
20:35:13 <c_wraith> Or do you mean a list *zipper*?
20:35:14 <butterthebuddha> In certain cases
20:35:17 <centril> Myrl-saki: cool :P
20:35:19 <c_wraith> That's an entirely different thing
20:35:36 <centril> Myrl-saki: https://internals.rust-lang.org/t/welcome-mazdak-farrokhzad-centril-to-the-language-team/8174   :D
20:35:42 <butterthebuddha> I think I do mean ListZipper
20:36:00 <c_wraith> A list zipper is certainly far better than a doubly-linked list, because you can update the focused element in O(1) time
20:36:08 <c_wraith> Any update to a doubly-linked list is O(n) time
20:36:26 <butterthebuddha> Fair enough, I didn't think about that
20:36:52 <Myrl-saki> centril: Oh, it's today. :P
20:37:04 <centril> Myrl-saki: ^,-
20:37:11 <Myrl-saki> centril: rats!
20:37:13 <Myrl-saki> Grats!
20:37:15 <Myrl-saki> Whoops
20:37:19 <centril> Myrl-saki: thanks! <3
20:37:34 <centril> Whatever happened to idiom brackets... would be sweet to have them
20:37:44 <c_wraith> doubly-linked immutable lists are not a good data structure. :)
20:38:19 <centril> c_wraith: blasphemy :) what else would be use to teach CS beginners? :P
20:38:35 <centril> s/be/we
20:38:42 <c_wraith> No memory locality, no quick updates to anything.  You're better of using an immutable array
20:38:52 <c_wraith> at least then you get fast indexing
20:40:19 <Myrl-saki> c_wraith: Isn't it possible to make doubly-linked lists by adding stack operations to Okasaki's(?) queue?
20:41:00 <c_wraith> that gives you a double-ended queue, but the data structure is very much not a doubly-linked list.
20:41:10 <Myrl-saki> Oh, wait, I'm stupid.
20:41:13 <Myrl-saki> Yeah. :P
20:41:45 <Myrl-saki> Is there even any use-case for doubly-linked lists in FP land?
20:42:13 <c_wraith> There are uses when you're using mutable references for the links.  But not when they're immutable
20:48:14 --- mode: glguy set +v rien_
20:48:57 <rien_> The Reddit thread "How to Organize the Monad transformer stack" has a bit of code that counts 0, 1, 2 lifts, and I found that to be very illuminating. What is a good way to visualize these relationships between Haskell's syntax and the way monad transformers work?
20:53:11 <blankhart> first, picture a turducken
20:55:20 <rien_> blankhart: I had to look that up. Funny!
21:03:47 <rien_> It seems, according to most visual interpretations, that "lift" could be called "inside" as it operates one inner monad-transformer-stack-level over.
21:13:17 <Cale> rien_: I actually really dislike the use of the term "stack" when it comes to monad transformers, because any time that you have to think about a stack in that way, you're probably just using them wrong.
21:13:54 <Cale> also, we don't tend to describe f (g (h x)) as a "function stack"
21:15:09 <Cale> When you apply a bunch of monad transformers to some monad, there is, to be fair, a bunch of monads that you obtain along the way, and indeed, lift will take an action in one of them and produce an action in the next.
21:15:12 <rien_> Cale: What had you rather they be called, if not a stack, which at least from my research into its possible representations, is rarely imagined as a stack?
21:15:28 <Cale> I usually just think of the result as a monad.
21:15:44 <Cale> and don't think about all the stuff I got along the way
21:16:07 <Cale> If I have to do that for any more than a handful of lines while setting things up, I reconsider my life choices.
21:16:11 <rien_> Cale: I can follow you very well when you are describing "lift", I just wonder if there is a preferred or somewhat accurate visual representation of it.
21:16:32 <Cale> In particular, there should not be occurrences of lift strewn throughout a project
21:16:49 <rien_> Cale: I understand your point, though, that you're telling me how much cognitive load you allow these things to take from you while coding. I appreciate that.
21:17:07 <Cale> They should all come within a few lines of the definition of your monad, while you define basic operations that you're going to expose.
21:17:31 <rien_> Cale: well, perhaps I am following outdated tutorials, but I am still going through the ropes and I am not sure I can avoid code with lift on it, so I have to know it.
21:17:36 <Cale> Or in instances which define various operations
21:18:34 <Cale> Well, for example, when you apply StateT s to some monad to obtain another monad which additionally supports the state operations, get and put (and others)
21:18:37 <rien_> Cale: I see, in other words "lift" should only be used in problem-domain named functions.
21:18:58 <Cale> yeah
21:19:48 <Cale> You want to take all the operations on the underlying monad that you cared about, and make sure that they or something like them is available in the finished monad.
21:19:49 <rien_> As it is a low-level construct of sorts, in terms of monad transformers, the plumbing of which we do not want to be constantly talking about.
21:20:15 <rien_> Cale: That absolutely makes sense.
21:21:44 <rien_> Cale: I find that going over people on Reddit or StackOverflow explaining Haskell code line by line helps me catch a glimpse of how good Haskell programmers think through their code. I've found Kmett's coding videos good but a little over my league still.
21:22:48 <rien_> Although I can more or less follow his CEK machine video, I think compiler code is not representative of other programs I want to code with Haskell.
21:23:47 <rien_> As in, I find it easier to follow compiler code, like the Scheme in 48 hours tutorial, which really helped me understand so much of Haskell, since the topic of compilers is familiar and really always the same in most languages. (I come from lisp)
21:24:56 <rien_> What I am saying is that newbies like me find it very helpful to be able to inspect the thought process of good Haskell coders be they in live-coding video format or online discussion forums.
21:31:33 <Cale> rien_: One thing I like to point many beginners at is this talk by Simon Peyton Jones...
21:33:22 <Cale> hmm, google is failing me
21:34:10 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
21:34:13 <Cale> there we are :)
21:34:32 <Cale> rien_: ^^ :)
21:35:04 <blankhart> rien_ also have you looked into the use of mtl in http://jxv.io/blog/2018-02-28-A-Game-in-Haskell.html
21:35:52 <rien_> Cale: I have definitely never watched that one, as I don't have Flash. :P But I am downloading the .flv file now to play on my VLC. I take your recommendations with great heed so I appreciate that.
21:36:38 <rien_> blankhart: You know, I think I am just at the level where I am starting to understand things well enough that the answers to my googled questions now involve the mtl more and more, so I think it's time!
21:37:30 <rien_> blankhart: Thanks for that, I will read it as soon as possible. I can see it uses SDL with which I have been familiar for over a decade - and a familiar topic always helps.
21:38:13 <blankhart> if you scroll to the bottom of this page https://hackage.haskell.org/package/logging-effect-1.2.5/docs/Control-Monad-Log.html#tutorialMtl
21:39:10 <blankhart> there is as good a brief explanation as i have found of MTL.  it calls itself a refresher but also says it can be skipped by those already familiar, so i am not sure who it is for
21:40:54 <rien_> It is for me, or people who are familiar with simple state transformers like me. Very helpful, thanks for the pointer.
21:42:42 <rien_> Not to talk about "state", but with regards to monad transformers and the mtl, I found that this was a nice and easy introduction (think of "state" as the "familiar topic" here): Phil Freeman on Mutable State in Haskell (on youtube)
21:57:25 <rien_> Here is an example of a helpful glimpse to show what I mean: "we can use get from Control.Monad.Trans.State, but we also have to lift that into the ReaderT monad that is wrapping StateT"
21:58:30 <rien_> How the author says "lift ... into the ReaderT ... that is wrapping", this is invaluable for understanding in my opinion, and I wish there was a tutorial dedicated to how to talk and think about the code, but for now I am finding bits and pieces of it everywhere, so it's fine.
22:00:14 <rien_> I would have incorrectly characterized what he is doing as "lifting 'get' into the StateT monad" but I would be seemingly wrong.
22:00:16 <Cale> rien_: Ah, right, the get from that module doesn't involve a type class.
22:01:19 <Cale> The get from Control.Monad.State (which is part of the mtl package) is polymorphic, and you'll be able to use it in ReaderT r (StateT s m) because there's an instance of MonadState which applies lift for you in the case of ReaderT
22:02:15 <rien_> Ahhh... ok, that makes sense. It's about their commutability, right?
22:02:56 <Cale> It's just:
22:03:07 <Cale> instance MonadState m => MonadState (ReaderT r m) where
22:03:14 <Cale>   get = lift get
22:03:20 <Cale>   put s = lift (put s)
22:03:30 <Cale> oops
22:03:41 <Cale> I left out the s arguments on each MonadState there
22:03:49 <Cale> but you get the idea
22:03:58 <rien_> oh right, exactly what we were discussing, namely it is using "lift" in its newly established interface.
22:04:59 <rien_> Yes, that really helped a lot right now, you just untangled two things I thought were the same as I read these monad transformer examples.
22:07:00 <rien_> Oh, so it seems the mtl moves monad specification to the constraints.
22:07:12 <rien_> Rather, to the constraints level, I should say.
22:09:31 <Cale> Yeah, that's the idea. It turns out that its type classes are rarely the ones you really want to be using at the application level, but they're still handy when you're sticking some of these transformers together in cutting down the number of lifts required to do various bits of setup.
22:10:22 <Cale> (you probably want to define operations somewhat more specific than ask/get/put/etc.
22:10:23 <Cale> )
22:15:32 <maerwald> interesting how broken stacks nix integration is. Basically you have to disable it per-project, globally and pass --no-nix to every script so it doesn't try to randomly invoke a nix-shell inside an already existing nix-shell and then mess up
22:15:54 <maerwald> or download ghc and try to build it...
22:16:03 <rien_> Cale: Are you talking about another level of refinement above mtl? What would that be just for future reference? By the way, the article linked by blankhart above is excellent and right at my level now.
22:16:50 <rien_> Or perhaps you are simply talking about a larger interface than just ask/get/put etc
22:17:56 <maerwald> tools that try to understand their environment are the worst
22:19:08 --- mode: glguy set +v gentauro
22:19:11 <gentauro> :o
22:19:12 <gentauro> wow, this is actually pretty, pretty good !!! -> http://dev.stephendiehl.com/hask/
22:19:17 <gentauro> :o
22:19:40 --- mode: glguy set -v gentauro
22:20:03 <rien_> gentauro: I also found this good, but perhaps it is too basic for you: http://dev.stephendiehl.com/fun/001_basics.html
22:20:05 <Cale> rien_: Well, usually you're using ReaderT for some purpose. For example, maybe you're tired of carrying around a pool of connections to a database, and want to have access to it throughout the code which carries out some DB transaction.
22:21:00 <Cale> rien_: In that case, it might make more sense to define a type class which instead of having an operation that simply gets you a pool or connection, just carries out a query
22:21:11 --- mode: glguy set +v nineonine
22:21:13 <nineonine> myThreadId >>= killThread
22:21:37 <maerwald> gentauro: it's a nice overview but the sections about type families or other more sophisticated things are not very good imo
22:21:49 <maerwald> it's just an overview
22:22:55 <rien_> Cale: Absolutely. That makes sense.
22:23:56 <rien_> In other words, using monad transformers and the mtl as an approach to clean problem-domain interfaces instead of simply better plumbing.
22:24:29 <Cale> Yeah
22:25:35 <rien_> Cale: Those are great tips that are already sharpening the way I am reading examples. Much appreciated.
22:26:22 <gentauro> rien_: yeah, that would be to simple for me :)
22:26:32 <maerwald> monad transformers and clean problem-domain interfaces? what? :D
22:26:46 <rien_> gentauro: :)
22:26:51 <gentauro> rien_: but I like that he more or less put focus at the same parts (at least at the begining) as I did in my intro course ;)
22:27:07 <gentauro> https://gitlab.com/spisemisu/SpiseMisu.IntroCourseHaskell
22:27:07 <Cale> maerwald: The point is that they're like stepping stones to getting you there
22:27:40 <maerwald> transformers are just very clumsy, leaky, compose bad and are hard to reason about
22:27:44 <gentauro> I had 10 people who never wrote a line in a FP language
22:27:48 <gentauro> I got them all to write Haskell
22:27:49 <maerwald> not sure how you can build anything clean with them
22:27:51 <Cale> Eh, they're not *that* terrible
22:27:57 <gentauro> (we can only blame Stack for it)
22:28:21 <Cale> You just need to wrap up the resulting monad a bit, and define the interface you *actually* want to use, in terms of the one that you get from the transformers.
22:28:39 <gentauro> since we couldn't go through all training material. They were "eager" to have a 2 part :D
22:29:09 <rien_> gentauro: a battle-tested Haskell tutorial, that's nice! I will brush up with its help.
22:29:09 <gentauro> Haskell is becoming mainstream and that is pretty good (more people need to take the time to teach others ...)
22:29:45 <gentauro> rien_: my approach is that with 6-7 notions of Haskell they should be able to produce "decent" code
22:30:00 <gentauro> the mastering of a language, no matter which it is, takes years
22:30:27 <rien_> maerwald: I can clearly see the stepping stones that Cale mentioned with the help of monad transformers and then mtl; I can finally understand, or get a hold of, how to organize code in Haskell.
22:30:33 <rotaerk> what is a notion of haskell
22:30:33 <Cale> maerwald: Or you can go the other way, and use a free monad of some sort, and define all the operations you want up front. But then you still need to write an interpreter for those operations which interprets into some existing monad, at which point you might care to use a handful of transformers.
22:30:51 <rien_> gentauro: I am exactly betting on the same future. :)
22:31:54 <rien_> maerwald: I guess no matter how terrible they are, in order to read Haskell code, one needs to know about them; and framing it as a progression towards better code is helpful.
22:32:54 <maerwald> rien_: you can also frame it as an anti-pattern, depends on your taste ;P
22:33:07 <Cale> I actually went that way on a recent project for work -- we have this language for specifying underwriting rules for mortgages, and initially there's a free monad with a handful of basic operations, and then when we interpret, there's an EitherT and WriterT and a few other things
22:33:23 <maerwald> introducing non-declarative OOP style interfaces to haskell, that's basically what transformers are
22:33:24 <Cale> (and we run those monad transformers immediately, but they were still handy)
22:33:43 <rien_> maerwald: I am curious to hear from you what is your preferred way to solve the problems that monad transformers and the mtl propose to tackle. Is it the free monad approach as mentioned by Cale?
22:34:03 <Cale> Free monads don't solve the problem, they defer it :)
22:34:04 <maerwald> freer is nice, but no one uses it, so
22:34:27 <maerwald> most of the time you can just do without monad stacks, but then your code becomes... wait... more *functional* ;)
22:34:40 <Cale> Free monads are just a way to obtain a monad which has operations of specified types, but with unspecified implementations, and then you plug those implementations in later somehow.
22:35:16 <gentauro> Free monads are nice in the sence that you can use (>>=), (<*>) and (<$>) for free :)
22:35:21 <rien_> maerwald: isn't Freer an implementation of effects-and-handlers or am I mistaken?
22:35:44 <Cale> So often when you're defining how to run the actions in your free monad, you end up wanting to use monad transformers temporarily to get a monad in which it's easier to implement the operations
22:36:08 <rien_> Cale: I think I have seen code that way. At least it lets you "code with a pencil" or prototype something that type checks at first, and then "fill in the gory details" later, I suppose?
22:36:15 <Cale> and then if that's the only interpreter you write, the whole exercise was pointless
22:36:23 <gentauro> "Escaping Hell with Monads" -> https://philipnilsson.github.io/Badness10k/posts/2017-05-07-escaping-hell-with-monads.html
22:36:32 <gentauro> I <3 this blog post from Phillip Nilson
22:36:37 <Cale> (well, it might still have been fruitful in that at least you thought about the interface you wanted up front)
22:36:41 <maerwald> my point is rather that effects in haskell are just awkward and such, using APIs that heavily rely on effects expressivity is annoying
22:37:58 <rien_> Cale: Thank you, that whole description confirms what I knew about Free Monads. That is what I thought was their advantage, but I was not sure.
22:38:00 <gentauro> maerwald: and Monads help you make their usage "uniform"
22:38:20 <gentauro> you don't need to learn new stuff because you handling new effects
22:38:27 <gentauro> it's the same over and over again
22:38:57 <rien_> Perhaps the Free Monad approach is appealing to those who want to code type-first but still flesh out /some/ code.
22:39:06 <maerwald> I don't see how that's any better than having open effects with a strict checked exceptions system
22:39:12 <Cale> rien_: Yeah
22:39:20 <maerwald> the latter is actually much much easier to reason about
22:39:28 <Cale> rien_: But the real advantage is when you might want to interpret the operations of your monad in a few different ways
22:40:21 <rien_> "it's the same over and over again", exactly, and in that way I would object to comparing it to OOP, which in my experience has nothing to do with doing the same over and over again.
22:41:13 <maerwald> how does the monad instance help you when you cannot compose arbitrary instances
22:41:16 <rien_> Cale: As in, when I want to decouple the interpretation of my monad from its interface completely?
22:41:30 <rien_> So I can swap out interpreters?
22:41:31 <maerwald> it's not that much of an advantage, really
22:41:36 <Cale> rien_: yeah
22:41:51 <gentauro> we had a conversation when I gave the course on TDD/DDD. One of the participants claimed that he could achieve the same with polymorphism in OOPD
22:42:21 <Cale> rien_: You define a bunch of primitive operations, and then later get to plug in a real implementation for them in order to run the actions.
22:42:24 <gentauro> I said: "Yeah, what if you forget to declare your inherited classes, does the compiler tell you?"
22:42:34 <gentauro> and the conversation ended there ;)
22:42:49 <maerwald> I want a proper declarative effects system (possibly not part of the type system)
22:43:16 <gentauro> maerwald: like PureScript?
22:43:19 <rien_> gentauro: Hahah! So you know DDD in the context of functional programming? Anything you recommend I read in that regard?
22:43:34 <rien_> maerwald: Are you arguing that effect systems are simpler? Are they not also more recent and perhaps that is why they have not gained as much acceptance?
22:43:40 <gentauro> rien_: I tend to teach ADT with TDD/DDD
22:43:56 <Cale> maerwald: You want that right up until you use it, at which point you will be in here complaining about how much it sucks ;)
22:44:32 <rien_> gentauro: that is the extent of it? I understand that much and I think it is great that ADTs map to bounded contexts.
22:44:59 <gentauro> blog.stermon.com/assets/talks/2018-08-08_SpiseMisu.IntroCourseHaskell.pdf (starts at slide 26)
22:45:24 <gentauro> it's very basic stuff, but allow newcomers to "get the point" ;)
22:45:31 <rien_> maerwald: which language has that so far? multicore ocaml effects are still unchecked, is that all they're missing for you?
22:45:52 <rien_> gentauro: thank you!
22:46:38 <rien_> gentauro: oh, I'm so glad you meant Type-driven development by "TDD" instead of something else!
22:47:51 <maerwald> rien_: I don't know if any language has that yet
22:47:57 <maerwald> like, really in a usable way
22:48:10 <rien_> maerwald: That is what I mean by effect systems being too recent.
22:48:15 <maerwald> java with checked exceptions is actually pretty close and the type system is very well designed
22:48:18 <Cale> Have you tried Idris' effect system?
22:48:27 <maerwald> no
22:48:37 <gentauro> rien_: my "wet dream" is that some day, all business analyst will be writing "specs" in an ML-famliy langauge (preferable Haskell) ;)
22:48:40 <maerwald> isn't that type-level anyway?
22:48:56 <rien_> maerwald: "java with checked exceptions" and "very well designed" in the same sentence - not something you find every day :)
22:49:11 <maerwald> rien_: why not?
22:49:12 <Cale> Well, it uses the type system
22:49:26 <Cale> Idris is dependently typed, so you can do all sorts of fun things with the types
22:49:33 <gentauro> "java" and "very well" can't go in the same sentence
22:49:37 <gentauro> it's a fact
22:49:37 <rien_> maerwald: most everyone agrees it was a mistake to add checked exceptions to Java
22:49:50 <maerwald> huh?
22:50:01 <maerwald> gentauro: that's just arrogance or trolling ;)
22:50:15 <maerwald> the spec is very good, the type system is extremely extensible
22:50:16 <gentauro> I mean, I had to do my stuff with Java
22:50:30 <gentauro> and it's the worst language I ever had to deal with :(
22:50:31 <maerwald> just because the language sucks from a user perspective doens't mean it's not well designed
22:50:54 <rien_> maerwald: that is a strange statement
22:51:05 <rien_> isn't a language designed for its users?
22:51:17 <maerwald> errm
22:51:32 <gentauro> and I had to code +3 years profesionally in C++ :(
22:51:35 <maerwald> people like Scala and C++, yet those languages are anything, but not designed *at all*
22:51:45 <maerwald> Java on the other hand is very well designed
22:51:57 <maerwald> what you think of it as a programmer is a different set of arguments
22:52:04 <gentauro> Java is the absolute bottom, only surpased by "Java"Script (is it a norm that all bad languages have Java in their name?)
22:52:16 <maerwald> that sounds more emotional than anything else
22:52:52 <gentauro> C# > Java (any day)
22:53:12 <maerwald> e.g. security type systems... it wasn't surprising to me that the most easy and advanced implementation is a java one, not a haskell one
22:53:22 <gentauro> but last time I used Java was 1.4 / 1.5 (when generics just arrived)
22:54:04 <rien_> maerwald: read Ian Joyner's Objects Unencapsulated
22:54:35 <gentauro> I'm actually lying, I had to do a "bit" more recently -> https://svn.softwareborsen.dk/OIOIDWS/trunk/Examples/Digst.OioIdws.Java/
22:54:35 <rien_> maerwald: he will make you see the errors of Java. It could have learned from Eiffel, but it was not meant to be.
22:54:36 <maerwald> rien_: ?
22:54:42 <gentauro> (horrible horrible experience) :'(
22:54:49 <maerwald> I'm not sure what you are trying to convince me of
22:55:07 <rien_> maerwald: If you think Java is well designed, then you have not been exposed to well designed OOP languages.
22:55:27 <rien_> Or you have not been exposed to a good enough argument for why Java is poorly designed.
22:55:36 <maerwald> *sigh*
22:55:54 <maerwald> it does fine without a plethora of unspecced language extensions though :)
22:55:57 <rien_> Incidentally, C++ programmers suffer the most from this problem, and could also stand to gain from Ian Joyner's work, which is authoritative and cannot be refuted with a sigh.
22:56:09 <maerwald> so it's fairly consistent
22:56:18 <maerwald> and the type system is very very well designed and extensible
22:56:26 <maerwald> it's easy to write extensions
22:56:46 <rien_> By your logic, if Java is so good, then wait until you meet Eiffel, you will marry it.
22:57:12 <rien_> Anyways, I don't want to be off-topic. The recommendation stands, read Ian Joyner.
22:57:13 <maerwald> I guess the problem here is that you think I said "Java is a good language"
22:57:17 <gentauro> maerwald: the state the the type-system is very well designed. What happens if I forget to implement an inherited type. Will the solution compile?
22:57:23 <gentauro> will I be able to ship code?
22:57:30 <gentauro> will it blow at runtime?
22:57:39 <maerwald> a lot of things randomly blow up at runtime
22:58:10 <gentauro> but you claim that the type system is well design, I just counter-proof it by showing a valid example that it's not
22:58:10 <glguy> Java's type system is unsound, so it might blow up at runtime
22:58:16 <gentauro> all OO languages suffer from this
22:58:30 <glguy> Also this isn't a Java channel
22:58:38 <gentauro> glguy: roger :)
22:58:55 <gentauro> back to Haskell
22:59:00 <gentauro> so ...
22:59:06 <gentauro> % :t print
22:59:06 <yahb> gentauro: Show a => a -> IO ()
22:59:08 <rien_> gentauro: Ian Joyner published a 350 page book on how exactly do C++ and Java suck and how they chose consciously not to learn from Eiffel. Proud people design bad languages.
22:59:14 <gentauro> is it the same as
22:59:24 <gentauro> % :t (putStrLn . show)
22:59:24 <yahb> gentauro: Show a => a -> IO ()
22:59:26 <gentauro> ? :)
23:00:03 <gentauro> rien_: glguy has spoken, it's not a Java channel, so I'm not going into more *bait* ;)
23:00:43 <rien_> gentauro: thank you, I agree.
23:00:47 <gentauro> I tend to use putStrLn myself, but see a lot of people using print ...
23:00:47 <maerwald> it was ontopic as long as we talked about effects systems, but some people had to try hard to convince others that the language sucks, which wasn't even the point in the first place, *sigh*
23:01:12 <gentauro> why should I use one over the other and why do we have two things for the same? :D
23:02:02 <rien_> maerwald: what are the shortcomings of Freer in your view? And do you see Haskell getting an effects system that you are satisfied with? I fail to see why it cannot be a part of the type system.
23:02:57 <maerwald> it's less flexible then. I imagine something more declarative
23:03:03 <maerwald> which has another "effects checker"
23:03:13 <maerwald> compare with rusts borrow checker, which is not a type checker
23:03:46 <rien_> maerwald: but just so I understand, are you asking for a system that already has a paper describing it and just hasn't been implemented?
23:03:54 <maerwald> I have no idea
23:04:18 <maerwald> these are just random thoughts about what I feel like would make more sense. How to do it properly or at all is beyond me
23:04:40 <rien_> maerwald: How to do it properly is the interesting bit, though. ;)
23:05:04 <rien_> The papers on Effect Systems are outstanding, as in how could something so simple have eluded us for so long?
23:05:21 <rien_> It's just generalized exceptions after all.
23:11:35 <gentauro> rien_: have you seen TomASP.NET coeffects? -> http://tomasp.net/coeffects/
23:13:10 <rien_> gentauro: I have not, but it sounds like I something I want to read about! It's always good to know who your co-friends are. 
23:16:26 <gentauro> :)
23:21:36 <rien_> gentauro: I am eagerly following any developments on Effect Systems as it is such a simple idea, and as a schemer I am a lover of continuations, be they delimited or not
23:23:40 <tolt> So I'm working with a bit of a weird project. Has anyone made a network request to a specific network interface? Also over ipv6?
23:23:51 <tolt> with http-client or similar
23:26:41 <tolt> well, for ipv6 the ip needs to be in brackets
23:30:53 <cocreature> tolt: ipv6 should be relatively easy (although I don’t remember the specifics since I didn’t have to deal with this for some time)
23:31:25 <cocreature> tolt: connecting using a specific interface is probably going to be a bit tricky but it looks like you might be able to use the managerRawConnection field in ManagerSettings for that
23:31:43 <tolt> cocreature: yeah, probably going to try to make a library to handle this
23:31:57 <tolt> That was where I was at :/ kind of hoped someone had a nice and easy solution
23:42:18 <koz_> For a Storable instance, is there any reason why sizeOf == alignment wouldn't be true?
23:43:15 <cocreature> koz_: you might want to align to word boundaries, e.g., if you have a size of 7 byte you could align to 8 bytes
23:43:26 <koz_> cocreature: Ah, that makes sense. Thanks!
23:45:46 <Maxdamantus> I'm not very familiar with the FFI, but presumably also you could have something like a tuple of uniform types, which you would think could just use the alignment of the inner type, but the size would be some multiple of the inner type's size.
23:47:16 <cocreature> oh good point, yeah the alignment can also be smaller
23:47:29 <Maxdamantus> More practically, you have things like structs in C, which all have the same alignment requirements, but can obviously be of different size.
23:47:42 <Maxdamantus> (which would basically be a case of what cocreature said)
23:47:54 <koz_> Yeah, that makes sense. Thanks everyone!
23:47:58 <cocreature> e.g. Data.Ratio a has the alignment of "a" but twice the size
23:48:18 <koz_> cocreature: Yeah, because you can think of it as an array of exactly two a's.
23:48:26 <koz_> (a C array that is)
23:57:20 <koz_> Is there any system to how GHC picks the type variables it uses when it complains about missing signatures?
23:57:26 <koz_> Mine seems to use 'p' a lot.
23:58:26 <cocreature> I think it usually tries to use something similar to the ones used in explicit type signatures
23:58:49 <koz_> cocreature: Isn't it usually a,b,c, as well as f,t for typeclassy stuff?
23:58:57 <koz_> Well, and s t a b for lenses of course.
23:59:05 <koz_> Because Edward can't resist wordplay.
