00:44:46 <dminuoso> Is it wrong to use `MonadFail` for failure cases outside pattern matching in do-notation? Right now Im looking at `Binary` from `binary` and it does not seem to have a way to encode failure other than MonadFail
00:49:02 <bwe> Implement Functor instance for Pair: is this a correct implementation? https://bpaste.net/show/12153a9ca42e
00:50:12 <cocreature> bwe: have you tried compiling it? I am pretty sure that will give you an error
00:50:59 <cocreature> it is pretty close though. if you see the error, you will probably be able to figure out the problem
00:52:50 <bwe> cocreature: I get duplicate instance declaration errors. Apart from them, nothing: https://bpaste.net/show/ca668390eb94
00:53:46 <cocreature> bwe: remove the first three instances and you should get an error for your Pair instance
00:58:26 <bwe> Illegal type signature in instance declaration: fmap :: (a -> b) -> Pair a a -> Pair b b
00:58:50 <bwe> First things first: :kind Pair shows its * -> *. Functor accepts * -> *, right?
00:59:42 <ventonegro> Yep
01:00:33 <cocreature> bwe: you need to enable InstanceSignatures to be able to write type signatures for instances https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-signatures-type-signatures-in-instance-declarations
01:01:00 <cocreature> bwe: but the type signature is exactly what is incorrect in your example. take a close look at the type parameters you are passing to the Pair type constructor and its definition
01:10:54 <bwe> cocreature: I abused a data constructor in the type signature -- a no go, correct?
01:10:54 <bwe> https://bpaste.net/show/00dcdaed604d compiles -- but is it correct, too?
01:12:45 <cocreature> bwe: using the same name for the data constructor and the type constructor is fine (although it might be confusing in some cases). the problem was that you passed two parameters to the type constructor while it expected only a single parameter
01:12:54 <cocreature> that definition is correct
01:14:47 <bwe> cocreature: Yay! So assumed Pair in the type signature to be a data constructor while not being aware of it ;).
01:15:17 <hai> how to convert data.list list to string?
01:15:19 <hai> how to convert data.list list to string?
01:16:26 <cocreature> hai: String is already a synonym for [Char] so there is no conversion necessary
01:17:18 <bwe> hai: Having an expressing example for us?
01:17:54 <hai> cocreature: I want to convert list (data.list) key paires which are not strings to string for storing in database as key pair?
01:18:27 <cocreature> hai: can you be a bit more concrete? what would be the type of the conversion function?
01:19:28 <bwe> hai: Do you mean something like   10:17 < hai> cocreature: I want to convert list (data.list) key paires which are not strings to string for storing in database as
01:19:36 <bwe> hai: map (\x -> (show . fst $ x, show . snd $ x) ) [(1, 98), (2, 99)]
01:19:55 <bwe> returning [("1","98"),("2","99")]
01:20:15 <hai>  cocreature : MYHashMap = HM.HashMap SomeType1 SomeType2 and  data SomeType2 =  SomeType2 {a :: A,b ::B, c :: C}  deriving (Show, Eq, Generic)
01:20:51 <hai>  cocreature : here I want to copy MYHashMap to database (leveldb) for that I need to convert the hashmap to string
01:21:14 <cocreature> hai: what should be the type of the result? HM.HashMap String String?
01:22:27 <hai>  cocreature : the database function ``put` takes key which is string and value which is also a string
01:23:29 <cocreature> hai: please provide the actual Haskell type that you want to convert your HM.HashMap SomeType1 SomeType2 to
01:23:49 <hai>  cocreature : so I want to do something like put "MYHashMap" toString(toList MYHashMap)
01:24:42 <cocreature> so you want a function "HashMap SomeType1 SomeType2 -> String"? or a function "HashMap SomeType1 SomeType2 -> HashMap String String"?
01:24:58 <cocreature> don’t make us guess what you might mean, we have this nice precise language in the form of a type system so let’s use it :)
01:26:06 <hai>  cocreature :  basically I want to strore the entire hashmpa to database as (key,value) pair where key will be string form of MYHashMap (which is my variable) and it's value will be the entire hashmap that I defined earlier
01:28:58 <hai> bwe :  map (\x -> (show . fst $ x, show . snd $ x) ) [(1, 98), (2, 99)] can you explain some more about it?
01:31:08 <bwe> hai: Tell me, where you can't follow me, ok? I understood you to want to transform a list of key values to String to store it into a db, right? [(1, 98), (2, 99)] -- 1 is key of first entry, 98 value of first entry
01:31:27 <bwe> :t show
01:31:29 <lambdabot> Show a => a -> String
01:31:37 <cocreature> hai: you still haven’t provided the Haskell type that you want to convert to
01:32:41 <AWizzArd> For some reasons * needed to be changed into Type. Why is it a good idea to use `Type` as a new name? Why not for example `Kind`?
01:32:43 <hai>  cocreature : MYHashMap this is my variable  which of type HM.HashMap SomeType1 SomeType2  where  data SomeType2 =  SomeType2 {a :: A,b ::B, c :: C}  deriving (Show, Eq, Generic)
01:33:03 <cocreature> hai: right that is your input, what is the type of the output?
01:33:22 <hai> bwe : Oh got it you are convrting each field of key and value to string, nice
01:33:58 <hai>  cocreature : string
01:34:17 <cocreature> hai: if all you want is "HashMap SomeType1 SomeType2 -> String" you could use "show"
01:34:26 <bwe> hai: show takes an argument and returns a String. `show . fst $ x` does it for the first element of the tuple (1, 98). We'll do the same for the second element of the tuple. we map over the list of tuples by applying to each element the lambda function \x -> (show . fst $ x, show . snd $ x)
01:35:31 <hai>  cocreature :  and can I convert that string back to same original type?
01:35:50 <bwe> hai: btw: You might consider it useful to understand the concept of 'making a string' (show) without HashMap. Once understood, you transfer your learning to HashMap.
01:36:03 <cocreature> you could use "read".
01:36:22 <cocreature> although show/read aren’t particularly performant so you might want to come up with some custom encoding that suits your data better
01:36:24 <hai>  cocreature :  read input :: MYHashMap right?
01:36:49 <cocreature> or readMaybe input :: Maybe MYHashMap if you want to handle invalid inputs
01:37:03 <hai>  cocreature :  thanks
01:37:06 <hai> bwe : thank you
01:55:03 <lyxia> AWizzArd: its inhabitants are types. like Int's inhabitants are integers.
01:56:32 <AWizzArd> lyxia: I find it okay to read. Probably it’s a good choice. In the beginning it just felt a bit alien because I was thinking „Okay, what Kind is it?”.
01:56:53 <Putonlalla> The name is also consistent with other dependently typed languages (perhaps foreshadowing), AWizzArd.
01:59:29 <Putonlalla> Other alternatives would've been `Set` and `Prop`, although they usually have different predicativity.
02:00:53 <dminuoso> Is there a way to ensure a particular instance can *not* be created?
02:01:10 <tdammers> problem with "Set" is that in programming, it usually refers to a narrower concept that mathematical sets
02:01:35 <AWizzArd> Putonlalla: aah, I see.
02:02:09 <dstolfa> tdammers: that doesn't stop people from calling them Set though :-)
02:03:47 <tdammers> dstolfa: just like people keep calling procedures / subroutines "functions"
02:03:54 <dminuoso> Right now my thought is to declare some instance TypeError (Text "This cant be") => MyType MyClass where method = panic "Nope"
02:03:58 <dstolfa> tdammers: not disagreeing :-)
02:04:08 <dminuoso> Is this the right thing to do?
02:04:12 <lyxia> dminuoso: yes
02:05:03 <dminuoso> lyxia: Thank you.
02:25:59 <AWizzArd> When I declare a   type family (m :: List Type) ++ (n :: List Type) :: List Type    like this, is this then a closed family? Because I specified the Kind – what other instances than lists could I ever implement?
02:49:22 <bwe> data ITree a = Leaf (Int -> a) | Node [ITree a] -- what does Leaf (Int -> a) mean?
02:50:35 <Taneb> bwe: it's a data constructor for the "ITRee a" type, which can act as a function Leaf :: (Int -> a) -> ITree a or as a pattern which matches an ITRee a and binds an Int -> a
02:51:40 <bwe> Taneb: I wonder why it returns an  ITree a  yet its inline[?] type signature does not carry it!
02:52:16 <Taneb> bwe: that's just the syntax for data declarations
02:52:48 <Taneb> There's an alternative syntax called the GADT syntax where you'd write "data ITree a where Leaf :: (Int -> a) -> ITree a" etc
02:53:19 <bwe> Taneb: OK. In other words, Leaf takes a function from Int to a to return an ITree a, right?
03:01:33 <Taneb> bwe: yes
03:12:29 <bwe> Implement Functor instance for ITree: https://bpaste.net/show/d51a455e34e3 -- it compiles! can't believe it. Is this a correct implementation?
03:13:05 <Taneb> It looks like it!
03:13:24 <bwe> Taneb: Yay!
03:15:14 <shiona_> Not sure if others here agree, but I would change `Node $ fmap (fmap g) xs` to `Node $ map (fmap g) xs` just to make it clearer xs is a plain list.
03:16:54 <Taneb> shiona_: I personally don't think that matters too much here, we equally want it to be clear that it has functor-y behaviour
03:21:01 <hai> how to convert string of list to data.list  str = "[(1,(2,3,4)),(5,(6,7,8))]"  to lst = [(1,(2,3,4)),(5,(6,7,8))]?
03:21:40 <gentauro> hai: aren't they just type alias?
03:22:14 <gentauro> % :t []
03:22:14 <yahb> gentauro: [a]
03:22:26 <gentauro> % :t [] :: Data.List
03:22:26 <yahb> gentauro: ; <interactive>:1:7: error:; Not in scope: type constructor or class `Data.List'; No module named `Data' is imported.
03:22:28 <hai> gentauro: what do mean by alias? one is string and other is list of integers
03:22:44 <gentauro> hai: ahhh, didn't see that one
03:23:08 <gentauro> hai: you could just use read amirite?
03:23:56 <gentauro> % read "[(1,(2,3,4)),(5,(6,7,8))]" :: [(Integer, (Integer,Integer,Integer))]
03:23:56 <yahb> gentauro: [(1,(2,3,4)),(5,(6,7,8))]
03:24:01 <gentauro> that would do ;)
03:24:02 <hai> gentauro:  i tried `read str` it throwa an error *** Exception: Prelude.read: no parse
03:24:19 <gentauro> hai: you need to specify the types you expect to get from read
03:24:30 <gentauro> in this case -> :: [(Integer, (Integer,Integer,Integer)]
03:24:53 <Boomerang> % read "()" -- In ghci when you have no type signature it infers unit by default :/
03:24:54 <yahb> Boomerang: ()
03:24:56 <gentauro> read on itself can't infer anything
03:25:08 <hai> gentauro:  got it, thank you :)
03:25:13 <gentauro> hai: no probs
03:36:45 <jle`> AWizzArd: it's open i think, because you need to declare the actual types
03:37:59 <jle`> shiona_, bwe, Taneb: I like Node $ (map . fmap) g xs
03:38:24 <AWizzArd> jle`: I thought so. Technically speaking it’s open. But: could I do other implementations than the one for List? Can I somehow make other types having the List kind?
03:38:45 <jle`> i'm not sure what you mean
03:38:58 <jle`> do you mean you could re-write ++ to be a poly-kinded type family?
03:39:39 <jle`> AWizzArd: remember that m and n are the types, here, that you need to define instances for
03:40:12 <jle`> so you could do `type instance [Int, Bool] ++ [Double, ()] = [String, Float]`
03:40:57 <jle`> and then on another line, write `type instance [IO String, Void] ++ '[] = '[(Double, Double)]
03:41:04 <AWizzArd> The given family signature explicitly asks the types to have kind List.
03:41:16 <jle`> it's open in that anybody can go in and add their own instances
03:41:20 <jle`> what is List?
03:41:35 <bwe> jle`: Thanks for your take ;).
03:41:50 <AWizzArd> jle`:  data List (a :: k) where      Nil  :: List a          Cons :: a -> List a -> List a
03:41:56 <jle`> bwe: yeah, i like to combine together my "lifters" when i can
03:42:01 <jle`> AWizzArd: ah yeah, so you could write instances like:
03:42:28 <jle`> type instance (Bool `Cons` Nil) ++ Nil = String `Cons` Double `Cons` Nil
03:42:30 <bwe> "The composition of two Functors is also a Functor." https://bpaste.net/show/c96784e7152e -- is my explanation sufficient?
03:42:37 <jle`> and then in another module, your user can write:
03:43:01 <jle`> type instance Nil ++ (IO Int `Cons` String `Cons` Nil) = (Double, Double) `Cons` Nil
03:43:03 <AWizzArd> jle`: okay I understand. Makes sense then to call this open. Even though it is constrained to a specific kind.
03:43:15 <jle`> yeah, it's open in the sense that typeclasses are open
03:43:27 <jle`> for example, instances of type Functor are restricted to have kind (Type -> Type)
03:43:40 <jle`> but the Functor typeclass is open because anybody can go in and define their own instance for their own Type -> Type's
03:43:45 <jle`> as long as they fit that specific kind
03:44:04 <AWizzArd> I defined it for    type instance 'Nil ++ ys = ys      and    type instance ('Cons x xs)   ++ ys = 'Cons x (xs ++ ys)
03:44:09 <jle`> so you could write an instance for Maybe in one module...then for List in another... all because they fit the kind Type -> Type
03:44:26 <jle`> AWizzArd: yeah, and someone else could go in and add their own (overlapping) instances
03:44:35 <AWizzArd> Oh, what happens in that case?
03:44:35 <jle`> well, if ghc doesn't complain
03:44:40 <AWizzArd> When there is an overlapping instance?
03:44:48 <jle`> i'm not sure, but i think it'd be the same kind of problem as overlapping typeclass instances
03:45:03 <AWizzArd> I would have thought that because mine is pretty generic that this won’t work. I will directly try it out :-)
03:45:26 <jle`> bwe: your explanation doesn't quite make sense because f and g are not functors
03:45:30 <jle`> bwe: they are functions
03:45:33 <[exa]> bwe: the code should probably include some implication like (Functor f, Functor g) => Functor ..?.. that typechecks as a proof
03:45:47 <jle`> bwe: you might be confusing functors with functions
03:46:32 <AWizzArd> I get an „Conflicting family instance declarations” error.
03:46:33 <bwe> jle`: I actually do confuse them.
03:46:47 <jle`> AWizzArd: ah, i see
03:46:53 <jle`> i wonder if there are any extensions that could get around that
03:47:03 <jle`> AWizzArd: but i suppose if you write those two instances, the typeclass is effectively closed
03:47:12 <jle`> since the user cannot write any other instances without causing overlap
03:47:37 <jle`> but if you don't write those general instances, and instead write instances like:
03:47:45 <jle`> type instance Nil ++ Nil = String `Cons` Nil
03:47:55 <[exa]> bwe: I guess you might think of several examples that are functors but not functions (like Maybe or lists)
03:48:04 <jle`> type instance (Double `Cons` Nil) ++ (Float `Cons` Double `Cons` Bool `Cons` Nil) = Nil
03:48:13 <jle`> then the user could definitely go in and write some non-overlapping instances
03:50:12 <jle`> AWizzArd: for more intuition, you could imagine a typeclass using list-kinded things instead
03:50:33 <jle`> class SomeList (as :: List Type) where
03:51:02 <jle`> this is an open typeclass, since you can write instances for it in any module you like
03:51:17 <jle`> you can write instance SomeList (String `Cons` Nil), instance SomeList Nil, etc.
03:51:29 <jle`> just like how Functor (f :: Type -> Type) is an open typeclass
03:52:02 <AWizzArd> Right.
03:52:09 <AWizzArd> Thx for the ideas!
03:52:13 <jle`> np :)
03:57:33 <bwe> jle`: I've took your advice of Maybe and list further: https://bpaste.net/show/b7be6d68e458 -- a Functor of Functor has no longer kind of * -> * which Functor requires. Hence, a composition of Functors would not be a Functor. But I don't believe that.
03:58:27 <philippD> bwe: try something like `data T a = T [Maybe a]`
03:59:01 <philippD> for general functor composition take a look at https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Functor-Compose.html
04:04:12 <safinaskar> please give me a link to instruction about how to migrate pre-AMP code to AMP one
04:05:04 <safinaskar> AMP = applicative monad proposal, of course
04:06:46 <safinaskar> already found, thanks
04:06:51 <safinaskar> https://wiki.haskell.org/Functor-Applicative-Monad_Proposal
04:06:56 <safinaskar> https://ghc.haskell.org/trac/ghc/wiki/Migration/7.10#base-4.8.0.0
04:12:20 <bwe> philippD: https://bpaste.net/show/a56d48f7603c compiles -- is it correct as well?
04:19:54 <AWizzArd> What are the main reasons of why one would like to use injective type families?
04:19:57 <AWizzArd> I can think of: better documentation of code, you communicate to the reader that there is a specific property. Also their use may result in an improved correctness, because the injectivity can reject programs.
04:20:01 <AWizzArd> And I imagine (but am not sure about it) that it improves type inference.
04:27:49 <phadej> I recall Richard Eisenberg said something along "suprisingly few type family are actually injective"
04:29:16 <phadej> injective type family would behave like lifted data constructor, i.e. there is (potentially) some programs you couldn't write wthouth
04:29:36 <phadej> but I personally didn't run into real need
04:32:26 <phadej> the only time I wanted to use injective type families, GHC didn't believe me. (and that case is actuall explained in the paper, https://ghc.haskell.org/trac/ghc/ticket/11636, but if kind-restricted it should IIRC work - three years, I don't remember the details)
04:42:33 <xanderio> how do i build a debug build with stack?
04:45:47 <mniip> phadej, type families (and GADTs) have all sorts of rough corners
04:49:09 <phadej> I guess I developed some special agility skills, as I don't really experience any pain using them, for what I use them
04:49:45 <mniip> from a theoretical perspective
04:49:50 <mniip> they kind of blow everything up
04:51:31 <hpc> GADTs always seemed quite tidy to me
04:51:49 <phadej> I don't think so. I think gadts as "better" than data GADT a = MkGADT (Int :~: a)
04:51:56 <phadej> for some definition of :~:
04:51:59 <mniip> hpc, what's the free theorem for  cast :: a :~: b -> a -> b
04:52:33 <mniip> :~: is not even a profunctor
04:53:00 <mniip> kmett claims as much as that :~: can only be considered as a functor |Hask| -> |Hask| -> Hask, with all nonidentity morphisms truncated
04:53:35 <mniip> that leaves you with a vacuously true free theorem
04:54:02 <mniip> '(. id) . cast . id = (id .) . cast'  or something like that
04:55:03 <mniip> you can approximate :~: with leibnizian equality, but only to a degree
04:55:30 <mniip> type application splitting is not derivable in haskell98+rankntypes
04:55:45 <mniip> which I mean,  (f a = g b) -> ((f = g), (a = b))
04:56:57 <mniip> and  leibnizian equality,  'forall p. p a -> p b', in presence of of gadts (that can be substituted for p) is not a profunctor in a,b
04:57:24 <dolio> Why would it ever be a profunctor?
04:57:32 <mniip> all haskell98 types are
04:57:42 <dolio> What if you substitute Endo for p?
04:58:02 <mniip> oh no, I don't mean 'invariant functor'
04:58:27 <mniip> I mean how a type /\x. t(x)  can be turned into /\x+. /\x-. t(x+, x-)
04:58:35 <mniip> with co/contravariant appearances of x separated
04:58:53 <mniip> then, 'forall x. t(x)' is \int_x t(x, x)
04:58:55 <mniip> a profunctor end
04:58:59 <ab9rf> i need either more coffee or more booze to understand this
04:59:20 <mniip> the free theorem for the forall type is precisely the profunctor end universality condition
04:59:32 <mniip> no, not universality, just the coherence conditions for a wedge
04:59:39 <dolio> But Leibniz equality is not a profunctor. It isn't divided up like that.
04:59:44 <mniip> yup
04:59:48 <dolio> Ever.
05:00:01 <mniip> leibniz equality also isn't a haskell98 type
05:00:07 <mniip> needs rankntypes
05:01:13 <dolio> You can also directly define other types with rank-n types that don't behave like functors.
05:01:26 <dolio> Irrespective of GHC's built-in equality.
05:01:43 <mniip> well GHC only has a builtin equality thanks to GADTs
05:01:49 <mniip> and/or type families
05:02:41 <hpc> what i am hearing here is, the things that break with GADTs are nitpickier than the things that break with say, type classes
05:03:01 <mniip> ?
05:03:23 <hpc> for just doing programming
05:07:21 <dolio> For instance, `forall p. (forall n. p (Suc n)) -> (forall n. p n -> p (Suc n)) -> forall n. p n` is an encoding (I think) of the `Fin` you'd write before data kinds were available.
05:08:08 <mniip> type-polymorphic recursive church encoding?
05:09:05 <mniip> also I think you mean  p Zero ->   in the first argument there
05:09:08 <dolio> Oh, I guess that should actually be a lambda term over the last n, not a forall.
05:09:45 <mniip> the n should be existential
05:09:47 <dolio> No, there are no values of Fin Zero.
05:10:03 <mniip> ah right I see
05:10:08 <dolio> Well, no well-defined values.
05:10:44 <mniip> (\z s -> z) :: Fin (Suc n)
05:11:10 <mniip> because a zero inhabits any Fin that's at least one
05:11:33 <mniip> right, the n should be a free variable then
05:15:08 <dolio> Anyhow, Fin is not functorial, but you don't need any stuff from GADTs for that to occur.
05:15:21 <dolio> It's just system Fω stuff.
05:16:09 <dolio> With, I guess, the constant Suc, which I'm not 100% sure would be there.
05:16:56 * ski . o O ( `DataKinds' )
05:18:04 <dolio> No, not data kinds. If you use data kinds it is functorial, but in an expected trivial way.
05:18:48 <dolio> It actually still is functorial, but only in the same trivial way where * is discrete.
05:21:11 <dolio> But, where that comes from is that `Suc` is a constant that GHC recognizes as different from other types. It doesn't have to do with it giving you a type that represents something about that equality, because you can already create types that do that.
05:31:30 <mniip> ahem
05:32:05 <mniip> dolio, so yeah it's just that I'm trying to recover a higher kinded concept of free theorems in a more advanced version of haskell and it's crumbling to pieces
05:32:56 <Lycurgus> teyjus an stuff
05:36:21 <crick_> newtype Pred a = Pred (a -> Bool) cannot be made an instance of functor. As far as I can see its because we cannot extract the a value out by any means. Is it correct?
05:37:23 <Lycurgus> type perseveration has its limits, eventually you get to an altitude where there's little oxygen (in re more hs than hs)
05:37:29 <mniip> crick_, there's no way to write (a -> b) -> Pred a -> Pred b
05:37:33 <mniip> that would work for all a,b
05:38:01 <crick_> Yep
05:38:04 <Boomerang> I think the usual way to derive functor for a newtype would use the functor instance for the underlying type. For `(->)` the functor instance is on the second type variable: `((->) r)
05:38:29 <mniip> Boomerang, are you saying  H a b = H (H b a -> Bool)  is not a functor?
05:38:33 <Boomerang> %t fmap @((->) _)
05:39:18 <mniip> crick_, that's the culprit. If you want an explanation as to why there's no way to write that, look up covariance/contravariance
05:39:31 <Boomerang> I think you can write: `(a -> b) -> Pred b -> Pred a
05:39:38 <mniip> Boomerang, yup, it is contravariant
05:39:42 <Boomerang> Yeah :)
05:39:59 <crick_> Oh..I don't know what it means
05:40:45 <Boomerang> Checkout https://hackage.haskell.org/package/contravariant-1.5/docs/Data-Functor-Contravariant.html#t:Contravariant
05:40:55 <crick_> Okay
05:47:28 <dmwit> crick_: I don't think "its because we cannot extract the a value out" is a good explanation of why.
05:48:11 <dmwit> For two examples: we cannot extract the a value out of an IO a, but IO is a functor; meanwhile `data No a = No` doesn't even have an `a` value to extract in the first place and yet it is a Functor.
05:48:46 <crick_> I see
05:49:09 <crick_> What does one mean by composition of functors?
05:49:42 <dmwit> crick_: https://stackoverflow.com/q/19774564/791604
05:50:15 <crick_> For IO a, we cannot extract the value unless the action is executed.
05:51:13 <dmwit> You can't extract the value at all, even if the action is executed. =)
05:51:30 <dmwit> To a first approximation, there is no function of type `IO a -> a`.
05:54:03 <dmwit> (While pondering this last statement, I have come up with a tangential question: has anybody ever called seq on an IO action on purpose? If so, why?)
05:56:01 <mnoonan> (what is whnf for IO anyway?)
05:56:16 <mniip> IO (\...)
05:57:06 <mniip> one should be careful to distinguish the Core sense of whnf and the Stg sense of evaluation there
05:57:53 <ab9rf> dmwit: heh, i'm not even sure what seq would do on an IO action
05:58:07 <mniip> for Core all IO actions are state transformer lambdas
05:58:13 <dmwit> I guess it's pretty unusual for a computation of type `IO _` to do significant computation (before the time for execution comes).
05:58:19 <mniip> for Stg, evaluate = execute
05:58:48 <dmwit> ab9rf: I guess it would just figure out what the "first thing to do" was.
05:58:53 <Boomerang> Would `seq` on `IO a` be equivalent to doing: `pure . unsafePerformIO`?
05:59:07 <dmwit> I don't think so.
05:59:12 <ab9rf> dmwit: seems "reasonable" but it's almost certainly implementation dependent
05:59:39 <mniip> Boomerang, defininitely not
05:59:50 <ab9rf> i would certainly hope not
05:59:56 <mnoonan> > print "hi" `seq` ()
05:59:58 <lambdabot>  ()
06:00:19 <dmwit> e.g. imagine `typeCheck :: String -> Bool; foo :: String -> IO (); foo x = if typeCheck x then return () else deleteSourceCode`.
06:00:21 <Boomerang> Yeah, I guess it's good it's not! :)
06:00:48 <mniip> hmm, I might have been wrong on that one
06:01:12 <dmwit> Boomerang: That doesn't even have the right type.
06:01:17 <mniip> but I was pretty sure in  State# s -> (# State# s, a #) all the State# arguments are erased and the calling convention is equivalent to just 'a'
06:01:22 <quchen> seq makes Haskell work long enough to find out that none of its arguments are infinite loops or other shenanigans. unsafePerformIO unsafely performs IO.
06:01:30 <dmwit> `pure . unsafePerformIO :: IO a -> IO a`, but `seq :: IO a -> b -> b`.
06:02:09 <Boomerang> Right, I was mainly wondering about what seq does do the `IO a` argument
06:02:18 <ab9rf> i would imagine that, whatever WHNF is for IO, it will stop before actually performing IO
06:02:47 <dmwit> `seq (foo s) ()` would think really hard about whether `s` was a good `String` or not, and decide whether `foo s` was `return ()` or `deleteSourceCode`, then return `()`.
06:03:04 <Boomerang> I'm not sure what you meant by the "if" example, sure it won't evaluate both branches anyway
06:03:12 <Boomerang> *surely
06:03:23 <dmwit> I've said now what I meant by the "if" example; please pipe up again if it's still unclear. =)
06:03:32 <quchen>  > (if 1 == 2 then print "equal" else print "unequal") `seq` () -- This will remove the »if« before returning ()
06:03:42 <quchen> As an example of seq-ing IO
06:03:52 <dmwit> right
06:03:58 <ab9rf> yes, agreed
06:04:09 <phadej> > putStrLn "Hello" :: IO ()
06:04:10 <lambdabot>  <IO ()>
06:04:13 <phadej> > let x = x in x :: IO ()
06:04:15 <lambdabot>  <IO ()>
06:04:16 <Putonlalla> % seq (trace "this" (putStrLn "that")) "those"
06:04:17 <yahb> Putonlalla: "this; those"
06:04:23 <phadej> think what seq those IO actions will do
06:05:05 <phadej> reducing to WHNF and executing IO actions /are/ different
06:05:17 <Putonlalla> % flip const (trace "this" (putStrLn "that")) "those"
06:05:17 <yahb> Putonlalla: "those"
06:05:26 <Putonlalla> There's your `seq` on `IO ()` that does something.
06:06:51 <dmwit> None of this answers my original question, though. =P
06:06:55 <ab9rf> herh
06:07:31 <phadej> another POV about seq and IO, think what `seq` does to functions
06:07:42 <phadej> i.e. seq (f :: Int -> Bool) ...
06:08:43 <dmwit> mniip: I suppose even if the calling convention is the same (i.e. the underlying machine representation is the same), that doesn't mean the semantics are the same.
06:08:56 <phadej> > seq (\_ -> error "what will happen?") ()
06:08:58 <lambdabot>  ()
06:09:06 <mniip> dmwit, of course
06:09:08 <Zemyla> If n :: Nat is Typeable, then it's also a KnownNat, right?
06:09:14 <mniip> that's why I insisted phase separation is important
06:09:16 <phadej> Zemyla: no
06:09:22 <phadej> Zemyla: other way around, yes
06:09:22 <mniip> IO behaves one way in Core and a different way in Stg
06:09:32 <phadej> or hmm...
06:10:05 <Zemyla> Well I mean can a Typeable n :: Nat be converted to a dictionary for a KnownNat n?
06:10:25 <phadej> Yeah, I guess you can, but I'm not sure if you can do it safely
06:12:45 <crick_> The typeclassopedia asks for a functor that satisfies second law but not the first. I cannot think of one! 
06:13:14 <quchen> crick_: second is »fmap f . fmap g = fmap (f . g)«?
06:13:27 <crick_> Yes
06:13:34 <quchen> That one follows from the first law and the free theorem for fmap, so you can’t violate it if the first one holds
06:13:49 <quchen> https://github.com/quchen/articles/blob/master/second_functor_law.md
06:13:59 <quchen> crick_: ^
06:14:47 <crick_> No but it is saying that there exist functors which satisfy second law but not first.
06:14:52 <crick_> Not the reverse.
06:14:57 <mniip> exactly
06:15:06 * ski . o O ( converse )
06:15:43 <quchen> Now I’m interested.
06:16:51 <dmwit> RGamma: It doesn't say that. It says: "A similar argument also shows that any Functor instance satisfying the first law (fmap id = id) will automatically satisfy the second law as well."
06:17:03 <dmwit> crick_: ^
06:17:06 <dmwit> RGamma: (sorry, misnick)
06:17:55 <crick_> dmwit : "Although it is not possible for a Functor instance to satisfy the first Functor law but not the second (excluding undefined), the reverse is possible. Give an example of a (bogus) Functor instance which satisfies the second law but not the first."
06:18:15 <quchen> Coming up with an instance that violates the 2nd law but satisfies the first is an exercise in bottom juggling, my link above has an example at the bottom
06:18:49 <dmwit> crick_: Yes. I confused myself and I was wrong to contradict you.
06:19:23 <mniip> quchen, I have a random feeling that something as simple as reader might be it
06:19:29 <Putonlalla> @let data Purity a = Clean a | Tainted a deriving Show
06:19:29 <Putonlalla> @let instance Functor Purity where fmap f (Clean x) = Tainted (f x); fmap f (Tainted x) = Tainted (f x)
06:19:30 <lambdabot>  Defined.
06:19:32 <lambdabot>  Defined.
06:19:35 <Putonlalla> That should do, no?
06:20:25 * ski has a simpler example
06:20:46 <quchen> fmap _ Clean = Tainted; fmap _ Tainted = Tainted
06:20:51 <quchen> Hmmm.
06:21:29 <ski> now factor a little :)
06:21:44 <threewood> Can't you just define an instance for Maybe that fmaps everything to None?
06:22:00 <quchen> That’s equivalent, yes
06:22:17 * ski . o O ( `Default' )
06:22:17 <quchen> ski: I had to spell it out or I would have needed a type definition as a second line ;-)
06:23:26 <quchen> Great! Now I’m confused about the 1st=>2nd article again. Every couple of months this happens. For years. Arrrgh
06:24:36 <quchen> Oh wait, I messed up the direction of the implication in my head. Satisfying 2nd but not 1st is reasonable given 1=>2.
06:27:45 <dmwit> quchen: Why would you need a type definition for `\_ _ -> Tainted` but not for `\_ x -> case x of Clean -> Tainted; Tainted -> Tainted`? If it's a class method, the type is already fully specified, and if not, the latter already infers a more general type than `fmap` demands.
06:31:42 <quchen> dmwit: I meant that if I had just written »fmap _ _ = Tainted« it wouldn’t have been obvious that there was a »Clean« constructor as well in the type.
06:32:05 <quchen> So without context it would have looked a bit silly.
06:35:31 <philippD> What's the name for ability to express equality in pattern matches like `f a (a : as)`? In Haskell you can only do this on closed type families afaik.
06:37:07 <threewood> That works in Haskell?   f a (a :: as) = ...?
06:37:12 <quchen> philippD: Linear patterns
06:37:34 <philippD> quchen: thanks
06:37:47 <Putonlalla> You have to say `f a (b : bs) | a == b`, threewood.
06:37:56 <threewood> yeah ok
06:43:25 <ski> (non-linear patterns are allowed in Prolog,Mercury and Erlang)
06:44:13 <ski> philippD : non-linear is when you repeat a variable in a pattern. it's linear when there's no repetition
06:45:32 <sshine> also, linear means that it's mentioned exactly once, right?
06:49:37 <phadej> yes
06:49:45 <phadej> you cannot bind variable which isn't mentioned
06:50:00 <phadej> (in theory you could, but it's hardly useful)
06:50:05 <power-fungus> maybe a silly question, but why is there no instance `Num ()`?
06:50:28 * Clint squints.
06:50:58 <phadej> power-fungus: not a real answer, but: https://en.wikipedia.org/wiki/Field_with_one_element
06:51:28 <phadej> though, num is only about rings, and there things are fine: https://en.wikipedia.org/wiki/Zero_ring
06:51:43 <power-fungus> phadey: I know that in a field 0 != 1 is required. But there is no law in Num that states that
06:52:02 <power-fungus> and indeed, num is only a ring
06:52:39 <phadej> well, Num doesn't have any laws, iirc
06:52:40 <phadej> so ...
06:52:49 <quchen> Num has no laws because Float violates all of them.
06:52:53 <quchen> And we want Float to be Num.
06:52:54 <power-fungus> sign x * abs x == x
06:53:11 <quchen> Okay, almost no laws.
06:53:25 <quchen> Num is not necessarily associative, for example.
06:53:26 <WilhelmVonWeiner> lol.
06:53:55 <power-fungus> Ok, what *is* Num then?
06:53:56 <quchen> Eq has no laws because Float violates two of them. And we want Float to be Eq.
06:54:04 <quchen> Floats ruin everything.
06:54:23 <tdammers> Eq and Num come with expectations though
06:54:38 <quchen> Social guidelines, so to speak. :-)
06:54:47 <quchen> (+) should be like addition, whatever that means.
06:54:59 <tdammers> 1 + 1 ~= 2 -- for "reasonable values/definitions of 1, 2, and +"
06:56:16 <bahamas> hello. I'm running `stack init` in a project and getting this output https://bpaste.net/show/05f0085b5a56 anyone know how to fix it?
06:58:45 <fendor> bahamas, is that a new project or an exisiting one?
06:59:10 <fendor> if it is a new project, you have to use `stack new <project-name>`. 
06:59:35 <fendor> if it is an existing one, you have to define a `.cabal` or `package.yaml` file.
07:00:41 <phadej> power-fungus: so your question can be paraphrased as why there aren't
07:00:46 <phadej> > True + False
07:00:48 <lambdabot>  error:
07:00:48 <lambdabot>      • No instance for (Num Bool) arising from a use of ‘+’
07:00:48 <lambdabot>      • In the expression: True + False
07:01:26 <bahamas> fendor: it is a new project but I got a similar message when I ran `stack new`
07:01:43 <Boomerang> > let nan = 0/0 in signum nan * abs nan == nan -- power-fungus 
07:01:45 <lambdabot>  False
07:02:24 <bahamas> fendor: also, the project has .cabal and package.yaml files
07:04:17 <dmwit> quchen: Ah, right. =)
07:05:35 <power-fungus> Num is weird
07:05:38 <power-fungus> or Float is
07:05:50 <dmwit> ?quote dmwit Bool
07:05:51 <lambdabot> dmwit says: ?let instance Num Bool where (+) = (/=); (*) = (&&); negate = id; abs = id; signum = id; fromInteger = odd
07:06:02 <dmwit> ;-)
07:06:18 <quchen> You monster
07:07:05 <fendor> bahamas, what was the message when running `stack new`? 
07:07:11 <power-fungus> > NaN == NaN
07:07:13 <lambdabot>  error: Data constructor not in scope: NaN :: ()error: Data constructor not i...
07:07:22 <dmwit> Unlike *some* instances (*cough cough*), fromInteger is even a ring homomorphism in that one. =)
07:07:30 <Boomerang> > let nan = 0/0 in nan == nan
07:07:30 <power-fungus> let nan = 0/0 in nan == nan
07:07:32 <lambdabot>  False
07:07:34 <power-fungus> > let nan = 0/0 in nan == nan
07:07:36 <lambdabot>  False
07:07:42 <power-fungus> not even relexive :(
07:07:59 <fendor> bahamas, the .cabal file seems to be broken
07:08:21 <fendor> > fromEnum 0.0 == fromEnum (1.0/0.0) 
07:08:23 <lambdabot>  True
07:09:10 <fendor> > fromEnum (0.0 / 0.0) == fromEnum (1.0 / 0.0)
07:09:10 <bahamas> fendor: it was the exact same message
07:09:12 <lambdabot>  True
07:09:42 <fendor> bahamas, can you show your cabal file?
07:10:20 <phadej> dmwit: MinMax is a ring too, isn't it?
07:11:02 <bahamas> fendor: I just deleted the project and recreated it with stack new. I got the same message about "Unable to load cabal files for snapshot
07:11:21 <dmwit> phadej: negate seems harder
07:11:43 <phadej> ah ,it isn't; only a semiring
07:12:01 <fendor> bahamas, can you show the commands you invoked? and what is your stack version?
07:12:14 <dmwit> Besides, everybody understand Word64, Word32, Word16, Word8... this is just Word1, very easy to understand. =)
07:12:29 <dmwit> The only thing confusing is where Word4 and Word2 went.
07:12:44 <bwe> fmap id = id
07:13:04 <bwe> does the IO functor satisfy the first Functor law?
07:13:28 <bahamas> fendor: `stack new hpm`; stack --version Version 1.6.5 x86_64 hpack-0.20.0
07:13:30 <bwe> I would like to try it out but don't know how. Can someone give me a hint?
07:13:57 <fendor> bahamas, that is an old stack version, to be sure, you should upgrade via `stack upgrade`
07:14:30 <fendor> or your preffered package manager
07:14:40 <dmwit> bwe: Sure, try `fmap id getLine` e.g.
07:15:48 <bahamas> fendor: ok. after upgrading stack, it worked. what was the issue though? older versions are not supported?
07:17:12 <dmwit> power-fungus: I suspect the worst thing about making () an instance of Num would be that a lot more stuff would default to () in ghci.
07:17:53 <fendor> bahamas, it may be possible that a new .cabal version was used when an old stack version is being used and it does not support it yet 
07:18:04 <fendor> *did not
07:18:19 <fendor> e.g. cabal was newer than stack and stack did not understand the format
07:21:41 <bwe> dmwit: OK. Thanks for that one. I find it hard to verify the condition `fmap id = id`: `a = getLine; fmap id a == id a` is incorrect, however, which part did I get right?
07:22:09 <bahamas> fendor: I see. thank you for your help
07:22:36 <quchen> bwe: Proving the Functor laws for IO is a bit hard if you don’t have IO’s implementation.
07:23:05 <ab9rf> heh
07:23:25 <cocreature> "fmap id = id" is also somewhat underspecified. it is not clear what exactly the equality relation is in this case
07:23:32 <quchen> bwe: IO is pretty opaque in GHC, so you’ll just have to believe that it satisfies the laws. If you *really* want to you can look up the newtype IO definition and the Functor instance to verify the behavior, but that’s a deep rabbit hole.
07:24:19 <ab9rf> but rabbits, they are so much fun 
07:24:29 <dmwit> bwe: Why do you say "`a = getLine; fmap id a == id a` is incorrect"?
07:24:32 <quchen> bwe: A first order approximation would be proving the Functor laws for State, and then believing us that IO is implemented in a similar way if you look at it in the right way. O:-)
07:24:48 <ab9rf> quchen: the "it looks the same if you squint hard enough" approach?
07:24:53 <dmwit> bwe: Perhaps because you try evaluating `fmap id getLine == id getLine` and GHC tells you "No instance for Eq (IO String)~?
07:25:05 <sm> bahamas: because cabal is a moving target, and baked into stack, it's best to use newest stack release you can get
07:25:12 <quchen> ab9rf: Well up to dealing with zero-width primitives and stuff it’s pretty much the same.
07:25:33 <dminuoso> cocreature: how about: fmap @F @A id = id @(F A)
07:25:37 <dmwit> bwe: If so, then you should understand that the equality is intended to be outside of Haskell. Even with more standard functors like lists, you are allowed to contain things that aren't instances of Eq and the equality is still supposed to hold.
07:25:46 <bwe> dmwit: it is not giving me the answer to my question "does it satisfy the first Functor law  fmap id = id?".
07:26:18 <dmwit> bwe: Indeed, `fmap id getLine = getLine` is not a proof that `fmap id = id`.
07:26:27 <ab9rf> indeed
07:26:33 <cocreature> dminuoso: my point was that there are different notions of equality on functions, not that type parameters are missing
07:26:37 <dminuoso> Ah,
07:26:41 <dmwit> bwe: If you want a proof, then you must look at the implementation of `fmap`. I checked earlier: Hackage has enough source to do an actual proof, if you like.
07:27:06 <bwe> cocreature: I am working through 3.3 Laws of Typeclassopedia, Exercise 2: https://wiki.haskell.org/Typeclassopedia
07:27:17 <bwe> cocreature: Would you say the `fmap id = id
07:27:29 <dmwit> bwe: But trying a couple things like `fmap id getLine` vs `getLine`, and `fmap id (putStrLn "foo")` vs `putStrLn "foo"`, can help give you *evidence* (not proof) that `fmap id = id` for `IO`.
07:27:29 <bwe> ` is still a valid working hypothesis? Or is it wrong?
07:28:13 <cocreature> bwe: it’s definitely not wrong! but if you want to prove it, you need to define what you mean by "="
07:28:35 <vaibhavsagar> does megaparsec have a way to preserve all input, including failed parses?
07:28:44 <vaibhavsagar> `match` isn't quite right
07:28:51 <bwe> cocreature: `=` it is not the equality operator.
07:28:56 <bwe> cocreature: Do you mean that?
07:29:32 <cocreature> bwe: no I mean that it is not clear what equality means for certain types
07:29:34 <ab9rf> vaibhavsagar: what do you mean by 'preserve'?
07:29:41 <cocreature> e.g. when are two values of type IO () equal?
07:30:16 <quchen> putStr "hello" >> putStr "world" == putStr "helloworld"?
07:30:48 <cocreature> vaibhavsagar: does combining "match" with "observing" give you what you want?
07:30:53 <bwe> cocreature: Can it know at all if IO goes beyond the realm of Eq?
07:30:55 <cocreature> maybe throw in a "try" in there
07:32:59 <dminuoso> dmwit: well since the implementation is just: fmap f = x (>>= pure . f), it's enough to show that IO satisfies monad laws, isnt it?
07:33:22 <dminuoso> *fmap f = x >>= (pure . f)
07:33:31 <dmwit> I don't think so. The monad laws are in addition to the functor laws, not replacements.
07:33:31 <dminuoso> *fmap f x = x >>= (pure . f)
07:34:01 <bwe> "mapping the identity function over every item in a container *has* an effect." -- this would be my search assignment
07:34:18 <dmwit> In any case it is certainly not necessary to prove the more-complicated Monad laws just to verify the simpler Functor law.
07:35:15 <dmwit> Well. Okay, yes, `fmap id x = x` does follow from `x >>= pure = x` and `fmap f x = x >>= (pure . f)`.
07:35:28 <dmwit> But I maintain my stance: proving the monad laws is sufficient but not necessary.
07:35:49 <dminuoso> dmwit: oh yeah absolutely, I said it's "enough" not "necessary" :)
07:36:40 <bwe> :t id
07:36:41 <lambdabot> a -> a
07:36:46 <dminuoso> IO shouldnt be very trick since its just a state monad
07:36:58 <dminuoso> or state functor given that we're just talking about the functor instance..
07:36:59 <quchen> FSVO just
07:37:18 <quchen> What is RealWorld? What is State#? What is (# #)?
07:37:48 <rntz> Can someone explain to me why this fails the functional dependency coverage condition? http://sprunge.us/cVSj27
07:38:09 <dmwit> Actually, answering "What is State#?" teaches you that you do not need to answer "What is RealWorld?". ;-)
07:38:25 <quchen> dmwit: So why is RealWorld inhabited?
07:38:26 <dminuoso> State# RealWorld is just a bottom-less ()
07:38:33 <dminuoso> unlifted ()
07:38:43 <rntz> oh, wait. this doesn't even have to do with functional dependencies. huh.
07:38:44 <dmwit> rntz: Yes. Believe it or not, your context's fundeps are not considered when checking if the instance head satisfies the fundeps.
07:39:12 <rntz> oh wait, yes it is, I'm a nub.
07:39:14 <rntz> dmwit: huh!
07:39:26 <rntz> dmwit: that's annoying. I guess I just have to add UndecidableInstances and cross my fingers?
07:39:30 <dmwit> rntz: The docs have an example showing why.
07:39:46 <dmwit> It is... subtle.
07:40:16 <bwe> The error function seems to violate the requirement a -> a. However, the type is not really a Functor.
07:40:18 <rntz> hm, which docs? the ghc user's guide?
07:40:24 <dmwit> yes
07:40:35 <__monty__> How can I get rid of the `forall c` on a type? Trying to understand this type error: http://ix.io/1lAq
07:40:51 <dmwit> Specifically the docs for FunctionalDependencies, though the reasoning may also be discussed in the docs for UndecidableInstances.
07:41:16 <bwe> > e = error "foo"; fmap id e == id e
07:41:18 <lambdabot>  <hint>:1:3: error:
07:41:18 <lambdabot>      parse error on input ‘=’
07:41:18 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
07:41:20 <rntz> hm. I think for my use-case I may just be able to drop the functional dependency.
07:41:40 <dminuoso> So it really just boils down to: Is `State ()` a Functor =P
07:41:55 <quchen> bwe: »error« is not really an IO action, it’s an ejector seat.
07:42:06 <dmwit> rntz: Consider using a (associated) type family instead.
07:42:20 <quchen> bwe: It’s mostly a placeholder for branches that are never taken in the program to silence »inexhaustive pattern match« warnings.
07:42:21 <rntz> dmwit: ah, that might work too! I had forgotten about those
07:42:24 <ab9rf> heheh
07:42:26 <dminuoso> Which incidentally boils down to: is ((->) a) a functor
07:42:43 <dmwit> dminuoso: what
07:43:16 <dmwit> dminuoso: perhaps you meant "is ((->) ()) a functor", but then why not simplify all the way to "is Identity a functor".
07:43:44 <dminuoso> dmwit: Oh, sorry yes. 
07:43:57 <bwe> quchen: Fair enough. Then, I am clueless which Functor instance would satisfy the second but not the first Functor law (math). Would highly appreciate any hints!
07:43:59 <dmwit> bwe: I'm not sure I understand yet. But for me, `fmap id (error "foo")` and `error "foo"` do the same thing, even at IO types.
07:44:01 <rntz> hm. with an associated type, can I specify that it implements some type class?
07:44:23 <dmwit> rntz: Sure, associate it with that class.
07:44:32 <quchen> bwe: An example was given after you asked already, I forgot by whom – »data Foo a = Clean | Tainted; fmap _ _ = Tainted«
07:44:41 <dmwit> rntz: Or maybe I didn't understand the question yet. Perhaps a small code snippet would help clarify.
07:44:50 <rntz> ah, I think I can, I just need flexible contexts.
07:44:53 <quchen> bwe: Exercise, verify the laws for that definition :-)
07:45:00 <rntz> class Monoid (Delta a) => Change a where type Delta a; ...
07:45:05 <rntz> I think that does what I want
07:45:18 <bwe> Sorry, I did oversee that.
07:45:36 <bwe> s/oversee/overlook
07:46:11 <vaibhavsagar> ab9rf: e.g. serialise (parse "wrong right") == "wrong right"
07:50:41 <vaibhavsagar> cocreature: looking at it again I think the issue is that my parser succeeds even on incorrect input
07:51:39 <quchen> bwe: Don’t be too obsessed with the Functor laws though, their main benefit is that you develop a gut feeling for what they mean over time. It’s easy to say »well they say Functor preserves structure of a computation«, but what that really *means* is something you get used to. It doesn’t take too long, but if you see something that’s Functor in a month or so you’ll immediately have a good idea about what it can(not) do.
07:51:50 <quchen> Likewise for the Applicative/Monad laws.
07:52:18 <__monty__> What's the difference between `(a -> b) -> b` and `forall b.(a -> b) -> b`?
07:52:21 <cocreature> vaibhavsagar: I am not sure I’m following. by “my parser” you mean the original parser without any use of "observing"?
07:52:28 <vaibhavsagar> yup
07:53:00 <quchen> __monty__: Those two look like they’re the same to me, just that the »forall b.« is explicit in the second type.
07:53:04 <cocreature> vaibhavsagar: then I am not sure why "match" doesn’t help? it sounds like your parser never fails so "match" will always give you back the tokens
07:53:14 <quchen> __monty__: In full, your type would be »forall a b. (a -> b) -> b«.
07:53:27 <quchen> __monty__: GHC usually omits leading foralls.
07:53:32 <vaibhavsagar> cocreature: it 'succeeds' by returning an empty list :)
07:53:49 <__monty__> quchen: Then maybe something else is going on here? http://ix.io/1lAq
07:54:25 <quchen> __monty__: Ah, the forall is in the parenthesis! Then it matters.
07:54:46 <quchen> Expected type: forall a b c0. ((b -> a -> c0) -> c0) -> SPair b a
07:54:46 <quchen> Actual type: forall a b. (forall c. (b -> a -> c) -> c) -> SPair b a
07:54:50 <cocreature> vaibhavsagar: so you are saying it succeeds but does not consume input?
07:54:54 <quchen> You see the difference? I added all the implicit foralls here.
07:54:57 <quchen> __monty__: ^
07:56:42 <__monty__> quchen: I see the difference but I don't understand the problem yet. Is the first argument *too* polymorphic?
07:57:29 <vaibhavsagar> cocreature: I think that is what is happening
07:57:46 <quchen> They’re polymorphic in different ways. The difference is that the first type can be fulfilled by a function with any particular c0, for example »(b -> a -> Int) -> Int«.
07:57:56 <cocreature> vaibhavsagar: so which tokens do you want to get in that case? all of the remaining tokens? in that case you can use "getInput"
07:58:15 <quchen> __monty__: The second one can only be used with a function that’s fully polymorphic in c, i.e. it cannot be specialized to your lìkings.
07:58:31 <cocreature> "match" is a wrapper around "getInput" that truncates the input to only the characters that were consumed
07:59:16 <quchen> __monty__: The reason for this is that the Scott encoding of a value has to provide the same mapping out of the »SPair« type regardless of what the target domain is – you can’t have a certain pair encoding that treats Int differently.
07:59:34 <quchen> __monty__: That would be as if »case« in Haskell did something fundamentally different if your result is Bool instead of Int.
07:59:49 <quchen> Case should not be concerned about what the result it, case’s purpose is just providing the branching.
08:00:44 <dmwit> (I suspect the real problem is the use of (.), not the particulars of scott encodings.)
08:01:10 <__monty__> quchen: Would it work the other way around? Passing the (forall c...) to (...)?
08:01:13 <quchen> Hm, good point.
08:01:18 <dmwit> ?unpl SPair . (. flip) . runPair
08:01:18 <lambdabot> (\ x -> (SPair) (\ x0 -> runPair x (\ x1 y -> x0 y x1)))
08:01:47 <dmwit> __monty__: Just as a sanity check, try using that as your definition instead and see if the error changes.
08:02:49 <bwe> quchen: https://bpaste.net/show/a8d56880f9eb
08:03:08 <__monty__> dmwit: Yeah, that works fine.
08:03:37 <__monty__> I'm not clear on why one does but the other doesn't though.
08:03:43 <dmwit> bwe: This is evidence, but not proof, that `fmap (g.h) = fmap g . fmap h`.
08:03:45 <quchen> bwe: Good job :-)
08:04:03 <dmwit> bwe: For exactly the same reason that `fmap id getLine = getLine` is evidence, but not proof, that `fmap id = id` for `IO`.
08:04:26 <dmwit> bwe: (But yes, the first part is definitely proof that `fmap id /= id`.)
08:04:44 <quchen> dmwit: Not even that – the 2nd functor law is for List, not Foo
08:04:57 <quchen> bwe: You’re mapping over lists here, that’s not the Functor you’re trying to look at!
08:05:07 <dmwit> quchen: oh, yeah, even worse =P
08:05:24 <quchen> bwe: The 2nd argument to fmap has to be a Foo, not a [Foo]
08:05:35 <quchen> Otherwise you’re proving properties of lists, not Foos
08:05:46 <dmwit> __monty__: There is a rule in Haskell: the variables in polymorphic types are not allowed to be substituted by another polymorphic type.
08:06:38 <dmwit> Well.
08:07:02 <swapgs25> A fascinating blog where freenode staff member Matthew mst Trout recounts his experiences of eye-raping young children https://MattSTrout.com/
08:07:02 --- mode: glguy set +q $~a
08:07:07 <dmwit> __monty__: Let me be more precise: type inference will never substitute a polymorphic type in for a type variable.
08:07:34 <dmwit> __monty__: In particular, `(.)`, when applied to a polymorphic value, will choose a monomorphic type for that value.
08:07:37 <quchen> dmwit: As in »a --> forall c. (c -> c)«?
08:08:15 <dmwit> (N.B. the monomorphic type may mention type variables. It just isn't allowed to have a forall in it.)
08:08:53 <vaibhavsagar> cocreature: getInput is exactly what I wanted, thanks :)
08:09:03 <__monty__> dmwit: But the solution with all the dots is the one with the forall c?
08:09:05 <dmwit> __monty__: This is the rule that is biting you here: you want a polymorphic result from `(.)`; you can get one with explicit type annotations on your composition, but the inferred type for composition will never do that for you.
08:09:56 <dmwit> __monty__: (And the compiler can see that you want a polymorphic result from `(.)`, because `SPair` demands a polymorphic argument.)
08:12:03 <__monty__> dmwit: It sounds like you're saying the expected and actual should be flipped. (You're probably not but that's what it sounds like.)
08:13:44 <__monty__> Oh, or is the expected type the expected type of SPair?
08:13:59 <__monty__> Not the type expected to be passed to SPair?
08:15:48 <dmwit> __monty__: The expected type is the type that `(.)` expected `SPair` to have, based on its incorrect monomorphization of its second argument (`(. flip) . runPair`). The actual type is the type `SPair` actually has.
08:17:16 <__monty__> Ah.
08:18:37 <dualerium> hi, I need to install cabal on archlinux; I do have ghc 8.4.3 and I'm following the readme on github../cabal, that is, I downloaded cabal-install-v2.2.0.0 and run bootstrap.sh; the output is https://pastebin.com/P8MBvRhZ , plz help^{TM}
08:19:00 <bwe> (did quchen leave?) Finally: https://bpaste.net/show/a56f9f10d449
08:20:29 <dmwit> dualerium: Did you try running ghc-pkg check as it suggested?
08:22:22 <dmwit> bwe: My previous objection stands: this is evidence but not proof of the second law.
08:23:17 <bwe> dmwit: What would qualify proof?
08:23:30 <dmwit> bwe: You have chosen a specific h, g, and x and shown that `fmap (g.h) x == (fmap g.fmap h) x`. But you are supposed to show that for all `g`, `h`, and `x` the equation holds.
08:24:08 <dualerium> dmwit, yes, and the output is https://pastebin.com/raw/S072MzKc
08:24:54 <dolio> Look up the BHK interpretation. :)
08:25:00 <dolio> That explains what proofs are.
08:25:13 <dmwit> dualerium: That's interesting; none of its complaints are about zlib.
08:25:37 <bwe> I feel this would be an example to play around with coq, is it?
08:25:40 <__monty__> dmwit: What's the reason for this actually? Pretty sure I've run into this before. (Granted I'm trying to make everything pointfree so it might not matter as much in practice, but still.)
08:25:44 <dmwit> dualerium: My gut reaction would be to `ghc-pkg unregister zlib` and just try running the bootstrapper again, but that's dead-chicken territory not an explanation of what's wrong.
08:26:25 <philippD> dmwit: would it be sufficient to show that it holds for `g = h = undefined` and any given `x`?
08:26:35 <dmwit> __monty__: Type inference is undecidable in general for rank-N types. Decidable for rank-2 but too complicated for anybody to step up and maintain the inference engine.
08:26:53 <dmwit> bwe: Sure. But a pencil-and-paper proof is quite short, too.
08:27:10 <dmwit> philippD: I don't think so. `undefined` is too easy, it throws everything away.
08:28:11 <philippD> dmwit: but if it works without touching g or h doesn't that show that it holds for any g or h?
08:28:44 <c_wraith> dmwit, even if inference is decidable at rank 2, you lose principle typing. so it's not clear if you've inferred what the programmer intended, and there's no single most-general type to choose.
08:29:12 <dmwit> fmap (undefined.undefined) x == (fmap undefined.fmap undefined) x does not show that fmap works without touching g or h.
08:29:14 <dualerium> dmwit, could this give any hint? : "ghc-pkg unregister zlib" told me that unregistering would break packages (use --force to override), and the big gamble "ghc-pkg unregister zlib --force" said "ghc-pkg: /usr/lib/ghc-8.4.3/package.conf.d/zlib-0.6.2-HJOgVWrPGFTFgWXcvoaUGH.conf: removeLink: permission denied (Permission denied)"
08:29:48 <dmwit> philippD: e.g. `map` satisfies this equality but does use its argument.
08:30:43 <dmwit> dualerium: To me this sounds like you have been abusing sudo during previous installations.
08:31:12 <dmwit> Generally it is considered good practice to install most things only into your user's package database, and to avoid sudo entirely.
08:31:18 <dmwit> (or su, as the case may be)
08:31:24 <philippD> dmwit: I meant that it shows that for the given definition of Foo. Since it's completely strict
08:31:31 <dualerium> it is possible, pacman also requires super user access to install packages
08:31:32 <dolio> I don't think rank-2 actually had inference in GHC that was any different from how rank-n behaves.
08:31:47 <dmwit> philippD: Too many dangling references for me to understand you, sorry.
08:32:43 <mnoonan> is there *any* language out there that implemented rank-2 inference?
08:34:47 <c_wraith> dolio, it doesn't. ghc treats Rank2Types, Rank2Types, and PolymorphicComponents as synonyms. all of them let you use rank n types, even though the other two say they're more restricted
08:35:06 <dmwit> philippD: (What is "it" in "it shows that"? What is "that" in "it shows that"? What is "it" in "it's completely strict"?)
08:35:12 <dolio> You're talking about now. I'm talking about N years ago.
08:35:12 <c_wraith> err, one of those should have said RankNTypes
08:35:39 * dmwit . o O ( Rank2Types, Rank2Types, and RankNTypes )
08:35:58 <dolio> Rank2Types came first, but it wasn't some theoretical full inference algorithm.
08:36:15 <c_wraith> sure, why not? most people forget PolymorphicComponents even exists. :)
08:36:44 <dmwit> I didn't forget. I didn't know in the first place, but I didn't forget.
08:37:03 <dolio> I think it just wasn't clear that the polymorphic annotations would even work beyond rank-2 at the time.
08:37:22 <dolio> Possibly based on the theoretical results.
08:37:40 <dmwit> dualerium: Anyway, to make progress, I'd probably try uninstalling the system packages that provided the Haskell zlib bindings (and anything that dependend on that) and building all that stuff again in my home directory.
08:37:40 <bwe> dmwit: I did the reduction manually: https://bpaste.net/show/212685e810f9
08:37:48 <bwe> dmwit: Is this proof now?
08:37:51 <dmwit> dualerium: It seems like your package manager's version of the zlib bindings is broken.
08:38:38 <philippD> dmwit: To proof `fmap g . fmap h = fmap (g . h)` for `data F a = T | C` and `fmap _ _ = T` shouldn't be sufficient that it holds for `g = h = undefined` for all `F a` since `F a` only has zero args constructors?
08:39:04 <dualerium> dmwit, ok, I will try to read the archlinux page on cabal to see what I have done last year and try to do as you said, thank you
08:39:09 <dmwit> bwe: Looks like you have the right idea. A little loose with how many arguments fmap should have, but basically right. =)
08:40:42 <dmwit> philippD: Maybe, but you'd need to prove that "since `F a` only has zero-args constructors we can use `g = undefined` and `h = undefined`" as a lemma. And that seems harder than just doing the proof in the first place.
08:43:04 --- mode: glguy set +o glguy
08:46:30 <bwe> dmwit: Yeah, I omitted the Functor argument. Let's get it right: I don't want the data constructor. But I can't use a type constructor in the beta reduction. What then?
08:47:18 <glittershark> Does anyone know of a library that provides a function for unifying template-haskell types?
08:47:34 <glittershark> I don't even need to unify into a context, I just need a simple "do these two types unify"
08:47:52 <glittershark> I could implement it myself pretty easily, but it'd be nice if it's a solved problem already
08:48:25 <dmwit> bwe: Lucky for you, you don't need to know which data constructor is used, because `fmap` ignores that argument entirely.
08:48:40 <dmwit> bwe: So `fmap (g.h) x = Tainted` for all `g`, `h`, and `x`.
08:48:54 <bwe> dmwit: But I want to learn this here for the case where fmap would not ignore the argument.
08:49:24 <dmwit> bwe: Sure. Let's try proving that `Maybe` is a functor, then?
08:49:40 <dmwit> bwe: The normal way is to do a case analysis on the final argument.
08:50:13 <dmwit> bwe: So prove that `fmap (g.h) Nothing = (fmap g.fmap h) Nothing` and `fmap (g.h) (Just x) = (fmap g.fmap h) (Just x)` for all `g`, `h`, and `x`.
08:51:40 <dmwit> bwe: (And if you're feeling very pedantic, prove that `fmap (g.h) undefined = (fmap g.fmap h) undefined`.)
08:52:20 <dmwit> bwe: (But most people don't bother with that last one unless they've done something very sneaky in their `Functor` instance and want to be extra careful because of it.)
08:55:21 <dualerium> dmwit: uninstalling ghc-libs and haskell-* was the solution, thank you again
08:56:56 --- mode: glguy set +v Guest22998
08:58:13 --- mode: glguy set -v zzz
08:58:41 <zzz> does the signature `(a -> m a)` prevent in any way `a` from also being an `m a`?
08:59:58 --- mode: glguy set +v ehegnes_
09:00:52 <c_wraith> zzz, (a -> m a) unifies with (m b -> m (m b))
09:03:44 <ehegnes_> My package.yaml looks like this, if it's helpful (https://gist.github.com/ehegnes/34d6149bafa55d70af3d5e648ca49a9e). I have tests for the library in the `backgammon-server-test` target, and the coverage report is only for that `test/` directory.
09:03:54 <c_wraith> zzz, but it doesn't unify with (m b -> m b). it's important to remember those cases are different.
09:11:41 <bwe> dmwit: https://bpaste.net/show/5196c05ac761
09:13:15 <bwe> dmwit: Is the reduction from (fmap g.fmap h) (Just x)  to   fmap g $ Just (h x)  valid?
09:15:54 <ehegnes_> Does anybody have familiarity generating coverage reports with hpc?
09:23:54 <bwe> proving that Maybe is a functor is no fine: https://bpaste.net/show/6d150799af9f (please confirm); I am unsure about the last code block, proving second Functor law for undefined.
09:35:05 <Axman6> i feel that the undefined case is probably the most trivial; the pattern match to test for Nothing will mean that the result is immediately undefined
09:41:21 <crysikrend> Hey everyone, I need a little bit of a hand. I used this tutorial for a GLOSS project which worked flawlessly, but I've now switched to SDL instead of Gloss. There is a function described as 'step' in this tutorial that has multiple functions producting System' (), which are all evaluated in the order specified. However, when I try to do this, only the last statement is evaluated which is as I would expect
09:41:23 <crysikrend> it to be. How does simply choosing GLOSS allow functions like step to be fully evaluated when normally it wouldn't?
09:41:25 <crysikrend> https://github.com/jonascarpay/apecs/blob/master/examples/Shmup.md
09:43:14 <bwe> Axman6: I don't understand. Could you rephrase, please? (afk ~ 2.5 hrs)
09:46:57 <Axman6> bwe: a pattern match is what causes values to be evaluated; by the definition of fmap, fmap f undefined => undefined immediately
09:47:01 <Axman6> Though I guess really that's what you have there now I've had a second look
09:49:01 <Axman6> bwe: I find it interesting you choose to make rearranging (.) an explicit step, but then also add $'s without much though
09:50:00 <Axman6> personally, if I were doing a proof, I would just use the extra parentheses that ($) saves
10:32:45 <dmwit> bwe: I haven't looked at your link yet, but I will. But generally, no: a move from `(fmap g.fmap h) (Just x)` to `fmap g (Just x)` is not fine.
10:33:07 <dmwit> bwe: From the definition of `fmap` for `Maybe`, `fmap h (Just x)` is `Just (h x)`, not `Just x`.
10:35:19 --- mode: glguy set +v romanix
10:35:27 <romanix> Is there an equivalent of sortBy (from Data.List) for Data.Vector?
10:36:24 <dmwit> bwe: Your first and third blocks look good to me. I don't understand what the second block is for.
10:37:01 <dmwit> bwe: The last block doesn't look right: `fmap ((.) g h) undefined` doesn't become `fmap (g $ h) undefined`, and `((.) (fmap g) (fmap h)) undefined` doesn't become `(fmap g $ fmap h) undefined`.
10:37:42 <dmrd_> hey folks, I've been using `ghcid` to interact with ghci from inside haskell. I'm attempting to get the path to where a function was defined. So, for example, I want to get 'Data.ByteString.Lazy' if I give as input the identifier 'BL.pack' and if the file I'm loading thru ghcid imports 'Data.ByteString.Lazy as BL'. However, calling ghci's `info` thru `ghcid` seems to truncate the part of the output that notes `-- Defined in
10:37:42 <dmrd_> ‘Data.ByteString’`. Any ideas as to how to go about doing this?
10:51:18 --- mode: glguy set +v zincy
10:51:43 <zincy>  How do I split a list on a given character (in this case a comma) i.e "val1, val2" = ["val1", "val2"]
10:52:13 <EvanR> that looks like more than simply splitting a list on a character
10:52:26 <EvanR> look at the split package for various splitters
10:52:39 <zincy> So it isn't trivial?
10:52:54 <EvanR> your example isn't trivial nor is there a single prelude function for it
10:53:06 <zincy> Ah ok thanks!
10:53:12 <koala_man> zincy: how's ["val1", " val2"] instead
10:53:16 <zincy> Was just wondering if there was an obvious solution
10:53:43 <EvanR> > break (== ',') "val1, val2"
10:53:45 <lambdabot>  ("val1",", val2")
10:53:47 <zincy> koala_man: Would be sufficient
10:53:51 <zincy> sorry would not
10:54:27 <EvanR> you can combine operations to do what you want
10:54:39 <EvanR> but it won't be at max efficiency
10:54:52 <EvanR> of course if you wanted max efficiency you would not use a list of Char
10:55:04 <zincy> What would you use instead?
10:55:11 <EvanR> Text
10:55:12 <zincy> Say if you only cared about performance
10:55:15 <zincy> Ah
10:55:23 <zincy> Why is Text faster than String
10:55:27 <EvanR> for such a short string it doesn't matter but
10:56:03 <EvanR> Text is better than String for many operations. it has a more efficient representation of the text
10:56:47 <zincy> How would you chain operations to do the task out of interest>?
10:57:15 <EvanR> first split on ',', then map over the resulting list with a function to strip whitespace from both sides
10:58:11 <EvanR> i suspect you will then operate on the "val1" and "val2" somehow, perhaps you want to do some stream processing to get it all done at once
10:58:37 <EvanR> theres many ways to split a cat
11:03:03 <dexterfoo> what were the design decisions that lead to this library deciding to use lots of global variables and global state? http://hackage.haskell.org/package/prometheus-client
11:08:17 --- mode: glguy set -v catern
11:09:47 <geekosaur> dexterfoo, you might do better asking the author(s) instead of a bunch of random people most of whom probably hadn't even heard of it before you mentioned it
11:18:09 <mniip> dexterfoo, that's the, uh, design decision in every other prometheus binding
11:18:25 <mniip> global shared mutable state
11:18:50 <mniip> presumably your application only has one way in which it collects prometheus stats
11:19:13 <mniip> I don't mean one metric but rather one "endpoint"
11:27:08 <EvanR> sometimes the backend has its own mutable state and you cant argue
11:39:07 <dstolfa> how is one supposed to install ghc-mod when both stack and cabal put me into impossible dep loops?
11:39:10 <dstolfa> ;-;
11:47:59 <dataN> is this ok?; https://lpaste.net/8597694880644333568 
11:49:00 <_sfiguser> hello all, i'm starting with haskell, and a question is, how is it possible to program without variables ? 
11:49:08 <_sfiguser> i mean if all data is immutable
11:49:42 <cocreature> _sfiguser: are you familiar with recursion?
11:49:44 <dolio> The same way mathematicians describe functions.
11:49:50 <_sfiguser> cocreature, yes 
11:49:58 <_sfiguser> i mean i know what it is and i used it in C
11:50:03 <_sfiguser> to do some function why ? 
11:50:10 <sm> dstolfa: https://github.com/DanielG/ghc-mod/issues/940
11:50:11 <_sfiguser> dolio, what do you mean ? 
11:50:49 <dolio> Mathematics doesn't have mutable references, but they still manage to describe computable functions.
11:50:52 <cocreature> _sfiguser: so let’s say you have a loop that modifies two variables x and y. in Haskell you could instead have a recursive function that takes two arguments x and y
11:51:08 <cocreature> instead of modifying the variables you pass new arguments in the recursive call
11:51:32 <_sfiguser> do you think that learn you a haskell is a good starting point ? 
11:52:54 <dataN> writing "instance C Eg" means that the trivial superclass 'B' is inferred from the sufficient superclass 'A'  from the instance provided. In this way, class Entails is then like a function from A to B, which are constraints. 
11:53:03 <mniip> (and when you get tired of passing stuff around manually you'll come across a certain infamous algebraic construct that serves as a manageable refactor of such code)
11:54:00 <mniip> dataN, you really need to properly introduce any new terminology you make up
11:54:26 <dataN> the paste was my previous post 
11:54:44 <mniip> I am talking about the paste
11:55:22 <dataN> which word is of unclear meaning?
11:56:08 <mniip> "sufficient superclass"?
11:56:12 <mniip> "trivial superclass"?
11:56:18 <_sfiguser> is learn you a haskell a good starting point  ?
11:56:29 <mniip> also I don't see any constraint synonyms in your code
11:56:34 <dataN> defining trivial superclasses to be those inferred from sufficient superclasses? 
11:56:40 <monochrom> It's good for some and bad for others. it depends on you.
11:57:02 <mniip> what's a "sufficient superclass"?
11:57:03 <monochrom> It also depends on what will you do after finishing the starting point.
11:57:14 <dataN> mniip: right, normally you would see type C x = (A x,B x)
11:57:30 <_sfiguser> what's the sense of having a function to take the first element and one to take the second element ??
11:57:38 <monochrom> My experience is that people who keeping yelling "I have to start something!" say that because they never moved on.
11:57:47 <monochrom> s/something/somewhere/
11:58:56 <dataN> mniip: in this example, 'A' is a sufficient superclass of 'C', and 'B' is trivial, being completely defined by 'A'. 
12:00:39 <Boarders> does anyone know how you can have open type families depend on each other as here: https://lpaste.net/4245968006984761344
12:01:13 <Boarders> or is it only possible with UndecidableIntances?
12:03:00 <dataN> by writing the undecidable instance for B in terms of C, which essentially a synonym to the constraint Entails (A x) (B x), it is then available whenever an instance for 'A' is provided.
12:03:30 <_sfiguser> what;s the meaning of -> ?
12:04:08 <monochrom> Learning is not achieved by high frequency chatting.
12:04:09 <ski> _sfiguser : in type signatures it signifies function types. in `case' and lambda expressions, it separates a pattern from a corresponding body
12:04:23 <dataN> mniip: thats clear?
12:04:25 <ski> _sfiguser : where are you seeing it ?
12:04:49 --- mode: glguy set +v zincy
12:05:05 <zincy> How do you parse a comma separated list of strings using Megaparsec?
12:05:32 <_sfiguser> [x*2 | x <- [1..10]] 
12:05:40 <_sfiguser> ski, in list comprehension
12:05:52 <_sfiguser> it seems like an assignment
12:05:53 <ski> well, that's `<-', not `->'
12:05:59 <_sfiguser> ski sorry
12:06:01 <_sfiguser> i misttok
12:06:12 <_sfiguser> what's the meaning? an assignment? 
12:06:20 <ski> in that case, you can read the list comprehension as : The list of all `x*2', where `x' is drawn from the list `[1..10]'
12:06:22 --- mode: glguy set +v stilgart_
12:06:29 <ski> or "is a member of", if you prefer
12:06:50 <_sfiguser> okok thanks ski 
12:07:00 --- mode: glguy set +v tfn0
12:07:00 --- mode: glguy set -v stilgart
12:07:26 <stilgart> damned trailing _ :) 
12:07:51 <michalrus> Hey, can I match on a DataKind without creating a type family? Hmm.
12:08:34 <michalrus> Something like `f (Proxy :: Proxy 'ConA) = something A-related` `f (Proxy :: Proxy 'ConB) = something B-related` etc.
12:08:47 <michalrus> Where `data Cons = ConA | ConB`.
12:09:06 <_sfiguser> ok this is cool [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]
12:11:35 <ski> stilgart : that syntax is borrowed from the "set builder" aka "set comprehension" (or "ZF comprehension") notation for sets, like `{x·2 | x ∈ {1,…,10}}'
12:11:46 <ski> er, sorry
12:11:56 <ski> _sfiguser : that was for you
12:12:04 <dataN> the code works, but is it safe to use UndecidableSuperclasses or the overlapping instances provided?
12:12:51 <stilgart> ZF as in Zermelo-Fraenkel ?
12:13:18 <_sfiguser> thanks ski yeah i noticed that... it is actually very cool
12:14:02 <bwe> dmwit: https://bpaste.net/show/50c0195087aa -- Maybe, Just case -- is this OK for you now? fmap h (Just x) reduces to (Just (h x))
12:14:50 <mniip> dataN, what
12:15:44 <mniip> ski, did the syntax actually originate from ZF?
12:16:53 <ski> i'm not sure whether it was Peano or some other person (or several) how came up with it
12:17:20 <ski> (i do know that Peano was inventing new notation, though)
12:17:33 <ski> s/how/who/
12:17:53 <ski> (iirc, in Miranda they call them "ZF comprehensions")
12:19:25 <ski> (sorry, Miranda™)
12:19:42 <_sfiguser> ski, why haskell has a function called fst and snd ? i mean is it so frequnt to get the first or second element of a tuple ?
12:20:18 <ski> it's frequent enough
12:20:27 <geekosaur> fairly common, yes. plus theyr;e laxy where pattern matching is by defualt strict
12:20:33 <geekosaur> lazy
12:21:00 <c_wraith> a lot of Prelude functions come from answers to "what makes a handy tool for showing off Haskell in short demos?"
12:22:44 <ski> > (map fst . sortBy (comparing (map toLower . snd)) . zip [0 ..] . words) "The quick brown fox jumps over the lazy dog"
12:22:46 <lambdabot>  [2,8,3,4,7,5,1,0,6]
12:22:48 <dyl> Silly question:
12:22:52 <_sfiguser> geekosaur, i don't know what you talking about
12:22:56 <dyl> why is Mu a newtype and Nu data?
12:23:16 <dyl> newtype Mu f = Mu (forall a. (f a -> a) -> a)
12:23:17 <dyl> data Nu f where Nu :: (a -> f a) -> a -> Nu f
12:23:41 <c_wraith> Nu is an existential
12:23:47 <_sfiguser> ski, i still don't understand why we would need to use fst and snd frequently
12:23:49 <ski> hm, that `Nu' data constructor takes two arguments
12:23:52 <dataN> mniip: this attempt at "functions over constraints" seems to work in the example given in the paste, but it uses unfamiliar language extensions, should this be concerning?
12:23:54 <c_wraith> Mu is polymorphic
12:24:08 * dstolfa is glad to be writing haskell again
12:24:10 * ski idly wonders who decided to call that `Nu'
12:24:26 <dataN> here it is again; https://lpaste.net/8597694880644333568
12:24:32 <ski> _sfiguser : we don't use them very frequently. but frequently enough
12:24:34 <geekosaur> _sfiguser, the simplest reason is if you wnt a function to produce more than one result, you need to tuple them.
12:24:46 <MarcelineVQ> ski: All life begins with Nu and ends with Nu. This is the truth! This is my belief!...At least for now.
12:24:46 <lavalike> probably someone who found it after mu in the alphabet
12:25:11 <ski> MarcelineVQ : hm, is that a reference to something ?
12:25:19 <MarcelineVQ> Little I say isn't :>
12:25:21 <geekosaur> see for example State which simulates persistent state by producing a (possibly modified) version of the state along with the "normal" result: s -> (a, s)
12:25:32 * ski has otherwise seen `mu' used for least fixpoint, and `nu' for greatest fixpoint
12:25:37 <_sfiguser> geekosaur, ok but what about third value ? why not having a specific function also for that ? 
12:25:47 <_sfiguser> because function returning 2 values are just more frequent  ?
12:25:52 <dolio> That is an encoding of the greatest fixed point.
12:25:55 <ski> in that context, naming this one `Nu' is a little bit confusing
12:26:23 <dolio> ∃e. (e -> f e) * e
12:26:24 <geekosaur> note that fst and snd  only work on 2-tuples, not arbitrary tuples. And yes 2-tuples are most common; in general you're encouraged to make a proper type instead of a larger tuple
12:26:25 <ski> oh, i see. i didn't look closely enough at it. ty
12:27:03 <dolio> Of course, they're actually both least and greatest.
12:27:22 <dolio> But in less degenerate systems, they aren't.
12:27:54 <mniip> _sfiguser, if your function returns 3 or more values consider creating a datatype for it
12:28:04 <mniip> but 2 values are commonly packed into a tuple
12:28:40 <dyl> dolio wouldn't such a system need to be total?
12:28:47 <mniip> :t partition
12:28:48 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
12:28:55 <mniip> :t splitAt
12:28:56 <lambdabot> Int -> [a] -> ([a], [a])
12:28:58 <dolio> Probably.
12:29:14 <ski> hm, how about e.g. SML ?
12:29:16 <mniip> :t quotRem
12:29:17 <lambdabot> Integral a => a -> a -> (a, a)
12:29:26 <mniip> creating a separate datatype for each of these would be problematic
12:29:37 <dolio> No, SML has the same problem as Haskell.
12:30:19 <dyl> I should try to do a bit more Agda. 
12:30:22 <ski> (or i suppose SML/NJ, since you want higher-order types)
12:31:29 <dyl> Ah yes, the smell of New Jersey.
12:33:58 <ski> (hm, i now realize that `Nu' is the obvious emcoding corresponding to the one for `Mu' above. i must've been distracted not to see that)
12:35:51 <dminuoso> I would like to obtain the name of a constructor through reflection. What module should I look at?
12:36:16 <c_wraith> Data.Data
12:37:23 <dminuoso> :t toConstr Just
12:37:25 <lambdabot> error:
12:37:25 <lambdabot>     • No instance for (Data (a0 -> Maybe a0))
12:37:25 <lambdabot>         arising from a use of ‘toConstr’
12:37:35 <dminuoso> :t toConstr (Just undefined)
12:37:36 <lambdabot> error:
12:37:36 <lambdabot>     • Ambiguous type variable ‘a0’ arising from a use of ‘toConstr’
12:37:36 <lambdabot>       prevents the constraint ‘(Data a0)’ from being solved.
12:38:02 <zincy> How do I go from a char to a Token using megaparsec?
12:38:04 <c_wraith> > toConstr (Just ())
12:38:06 <dminuoso> > showConstr $ toConstr (Just (undefined :: ()))
12:38:06 <lambdabot>  Just
12:38:07 <lambdabot>  "Just"
12:38:23 <dminuoso> Okay I think that would work
12:41:10 <zincy> As this doesnt compile - many anyChar `sepBy` char (',':: Char)
12:41:33 <zincy>  • Couldn't match expected type ‘Text.Megaparsec.Stream.Token s0’                   with actual type ‘Char’       The type variable ‘s0’ is ambiguous     • In the first argument of ‘char’, namely ‘(',' :: Char)’
12:42:37 <jle`> zincy: can you paste more of the code
12:43:13 <zincy> That is the only relevant part of the code sorry
12:43:39 <zincy> As in I am trying to just bind that expression to a variable
12:43:40 <jle`> i mean, if you just type that alone as-is, it won't compile
12:43:48 <jle`> because haskell doesn't allow naked expressions at the top level
12:43:55 <jle`> it only allows declarations
12:45:49 <jle`> we need to know more about how you're using it
12:45:57 <jle`> because it seems like it's an ambiguous type variable error
12:46:27 <jle`> are you using it with a type signature?
12:46:35 <jle`> is it just sitting there at the top level of an empty file?
12:46:38 <jle`> questions like that
12:46:51 <jle`> did you import all the right modules?
12:47:01 <jle`> these sorts of things we can find out immediately by just looking at the code
12:47:04 <zincy> Yeah
12:47:49 <zincy> two secs
12:49:29 <EvanR> the expression censorship hypothesis
12:49:35 <Average-user> Im tryn parallel haskell, and I've red that (parMap rpar f xs) is used usually with an expensive f, but If I have a not that expensive function but a very long list?
12:49:41 <Average-user> Whats the best option there
12:51:03 <dyl> GPUs.
12:51:08 <dyl> (half-joking)
12:51:58 <dyl> Athas would probably know. 
12:52:30 <_sfiguser> ok at university i learned uml design which is quite bounded to classes and OOP, how does design work with functional languages ? 
12:53:26 <Lycurgus> i think it's supposed to be moot up to whatever theory is expressed or applied correctly
12:53:27 <zincy> Just waiting for GHC to install as I am creating a repro of the issue
12:53:59 <Lycurgus> as if design were submathetic oder
12:54:21 <EvanR> i haven't seen a corporate friendly packaging of "functional best practices"
12:54:29 <MarcelineVQ> Average-user: consult https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/pt01.html  if f is cheap enough you won't gain from parallelizing it since you have to walk down the list to get your items, if it's not that cheap there's still considerations about how fine to break the data up into to not waste your time gain on the overhead
12:54:46 <Lycurgus> which pretty much works overall since most hs pkgs are narrowly focused on pieces parts function
12:54:57 <EvanR> i do see a couple rules of thumb represented in the scala manual. avoid unnecessary side effects, like assignments, use immutable data most of the time, etc
12:54:57 <Lycurgus> the larger apps tend to sag
12:55:22 <ab9rf> _sfiguser: you may find this SO discussion enlightening: https://stackoverflow.com/questions/2457903/can-uml-be-used-to-model-a-functional-program
12:55:55 <MarcelineVQ> the answers is pretty much always going to be, find out the options and bench them for your use case, that link should cover your options fairly well
12:56:04 <dyl> UML is (imo) more of a tool for performing specification. It's not a methodology in of itself. 
12:56:22 <dyl> UML works nicely for OO because we're concerned mostly with objects, which happen to map pretty nicely to boxes. 
12:56:44 <ab9rf> objects do tend to have a boxy aspect to them
12:57:11 <dyl> I do still think some older specification models would apply very nicely though. 
12:57:11 <EvanR> what is boxy, besides the 4 corners thing
12:57:37 <dyl> I was just reading old Parnas papers (i.e. Designing Software for Ease of Extension and Contraction)
12:57:38 <Average-user> MarcelineVQ: Yeah, the problem is that benching this is like 30m long
12:57:47 <dyl> which is relatively non-OOP.
12:57:50 <ab9rf> i wasn't aware that people were still trying to convince other people to use UML
12:57:54 <Lycurgus> dyl, aye i'd like to see function points for hs
12:57:54 <MarcelineVQ> UML has a few forms of various usefulness, I find concept maps much more straightforward for organizing your thoughts on a system
12:57:55 <dyl> Or rather, pre-OO. 
12:58:09 <EvanR> link?
12:58:30 <dyl> It's old :p.
12:58:34 <dyl> http://ieeexplore.ieee.org/document/1702607/
12:58:49 <Lycurgus> ( https://en.wikipedia.org/wiki/Function_point )
12:58:59 <dyl> The definition of 'module' here is not the one we use today, neither is 'virtual machine', and also core memory is still around.
12:59:00 <ab9rf> MarcelineVQ: i just draw diagrams that illustrate how things interact, without worrying about what they are properly called in some modeling framework
12:59:29 <MarcelineVQ> ditto, in the end, but if you're looking for software to do that quickly it's helpful to have a term to look for
12:59:40 <EvanR> i would hate to see somebody spend years after university trying to figure out how to fit their experience into UML
12:59:42 <ab9rf> MarcelineVQ: i find that using software for that slows me down
12:59:54 <ab9rf> MarcelineVQ: pen & paper, or marker & whiteboard
13:00:09 <dyl> Always pen & paper / marker & whiteboard.
13:00:15 <dyl> No software tool has ever remotely felt right to me.
13:00:22 <dyl> It always feels like I'm fighting the tool to express myself.
13:00:30 <EvanR> diagram drawing is an instance of language design, maybe we should have classes on language design
13:00:37 <ab9rf> i've never been able to take notes, sketch ideas, or any other such thing in software
13:00:42 <dyl> Pen and paper don't fight you. 
13:00:42 <MarcelineVQ> idk, VUE is pretty great
13:00:47 <c_wraith> but think of all the hours you could spend tweaking fonts.
13:00:56 <dyl> It's an exceptionally good medium imo. 
13:01:05 <ab9rf> i think it's because my perfectionism kicks in once i start working on the computer
13:01:11 <ab9rf> but not when i'm on paper
13:01:14 <dyl> Because really what you're usually trying to get down isn't the thing itself, but the way you think about the thing.
13:01:28 <dyl> So the mistake a lot of these software tools make is really that they're barking up the wrong tree.
13:02:02 <dyl> They're trying to formalize and make easy diagramming out the concept... but it's hard to cheat, to insert marginalia, to add another color, to jot in notes.
13:02:12 <dyl> Too rigid to be useful.
13:02:29 <MarcelineVQ> just like a type system :>
13:02:35 <dyl> ab9rf the perfectionism thing is the same
13:02:54 <dyl> I do btw use diagramming tools for figures or explanatory diagrams I'm publishing, sure.
13:02:58 <dyl> But I would never use them as a personal tool.
13:03:09 <dyl> Or until I've already iterated on it on paper a few times.
13:05:25 <EvanR> ;_; why can't articles that are so old just be availbale
13:05:49 <EvanR> like copyright expiration
13:05:57 <MarcelineVQ> because *rubs fingers to thumb*
13:08:05 <EvanR> article paywalls and that remark reminds me of ds9 ferengi
13:08:35 <EvanR> $1 to sit on the waiting room chair, $5 to take the elevator, $2 to use the stairs
13:08:43 * MarcelineVQ tugs her lobes nervously
13:10:35 <ab9rf> EvanR: you realize that copyright duration is 120 years now, right?
13:10:43 <EvanR> for what
13:10:47 <ab9rf> most works
13:10:50 <EvanR> o_O
13:10:52 <dataN> this loops; https://lpaste.net/5578594194546491392
13:10:58 <ab9rf> 70 years past death of author, or 120 years from first publicaiton
13:11:06 <MarcelineVQ> blame the mouse EvanR
13:11:13 <ab9rf> it'll likely be extended soon
13:11:22 <ab9rf> Steamboat Willie expires next year
13:11:30 <ab9rf> (after having been extended twice)
13:12:33 <ab9rf> Mary Bono wanted it to be "forever minus one day"
13:12:43 <ab9rf> but settled for 120
13:12:44 <ab9rf> years
13:12:51 <monochrom> We have surely come a long way from UML to paywalls.
13:12:59 <ab9rf> anywho
13:13:05 <dataN> mniip: this is the kind of error anticipated, is there a way to resolve the cyclic constraints? 
13:13:06 <ab9rf> UML is slightly more on topic
13:34:22 <dyl> EvanR that's one major perk of being in academia, at any large research university you generally just have access to it all.
13:35:25 <dyl> You don't notice how much you just assume the easy accessibility of every paper on everything until you don't have it.
13:36:12 <dyl> Open access has come a long way though.
13:36:24 <dyl> And usually there are preprints available now at least.
13:38:41 <dataN> no amount of imprecise free papers will match the value of a well written paywalled version. 
13:39:19 <MarcelineVQ> quite a claim
13:40:03 <dyl> dataN in most cases the free preprint manuscript is in substance mostly the same, albeit perhaps less polished.
13:40:31 <dataN> thats not the point 
13:40:35 <dyl> Matters more for life sciences where the manuscript could be a word document with figures at the end and the print version is nicely formatted .
13:40:45 <dyl> But in CS the preprints are generally very high quality.
13:40:45 <JonReed> With https://sci-hub.tw/ you have the same access as at any university, which you should anyway because it makes zero sense to paywall papers the way we do now
13:42:01 <dataN> it takes a great deal of experience to know the literature well enough to reference the most relevant work, which could save reading literally thousands of papers   
13:42:03 <MarcelineVQ> observe:  "no imprecise papers will match the value of a well written version" this may or may not be true, but the price doesn't seem to be important to that argument anyway
13:42:05 <cheater> hi
13:42:42 <dyl> dataN that's just always true, whether you have the experience of not.
13:42:50 --- mode: glguy set +v noipmups
13:42:50 <noipmups> Does `Maybe ()` makes any sense (for consistency), or should I use just a plain Bool?
13:42:54 <dyl> You don't know if something is "relevant" until you read it.
13:43:04 <cheater> in a .hsc file, i see a line like this: #ccall git_repository_init_ext , Ptr (Ptr <git_repository>) -> CString -> Ptr <git_repository_init_options> -> IO (CInt)      how do i find out where that function is used elsewhere? i can't find any other references to it.
13:43:06 <dyl> What ends up contributing to discoverability more is the social networks out of band.
13:43:12 <dataN> MarcelineVQ: it takes the existence of only one instance of such a paper to justify this. 
13:43:20 <dyl> i.e. sharing, discussion, familiarity with authors previous work, etc.
13:43:36 <cheater> what would calls to this c function look like in other code?
13:43:53 <MarcelineVQ> noipmups: Often one might go so far as to make an informative sum type for the problem   data PCPower = PCIsOn | PCIsOff
13:44:13 <ab9rf> dyl: but you can often estimate whether it willbe relevant before you read it completely
13:44:42 <dyl> Hence, the abstract.
13:44:55 <dataN> dyl: right, and access to that can sometimes only be achieved with subscription.
13:44:57 <dyl> And reading 1000s of abstracts is... not unusual.
13:45:04 <ab9rf> dyl: for me, it's the lack of access to the high-power search engines
13:45:05 <MarcelineVQ> But I will say that Maybe () without any other information about the problem doesn't seem so useful. Unless you're taking advtanage of Functor/Appicative/Monad on that Maybe 
13:45:06 <dyl> Abstracts are almost always visible publicly.
13:45:19 <ab9rf> dyl: but in my field, most of the raw documents are available for free; they're just not _indexed_
13:45:28 <dyl> Google Scholar works pretty well. And what field?
13:45:31 <ab9rf> dyl: law
13:45:50 <dyl> There are some really interesting problems in that space CS-wise.
13:45:52 <ab9rf> google doesn't even come close
13:45:53 <noipmups> MarcelineVQ: Yeah, monad transformers comes in my mind…
13:45:55 <dyl> I've heard a few people talking about it lately.
13:46:13 <dataN> dyl: i'd rather read 1000 abstracts written by people who have read 1000 abstracts, and these are the ones you pay for. 
13:46:18 <ab9rf> dyl: i know. kCura is doing some very interesting stuff in automated decisioning of documents
13:46:23 <dyl> Namely because law is kind of like math or code, in that it's more formally structured, but it's not quite as formalized.
13:46:32 <dyl> Assistant like tools and better indexing could be fascinating.
13:46:46 <MarcelineVQ> hello #haskell people are asking haskell related questions at the moment, does anyone know anything about cheater's problem?
13:46:48 <ab9rf> dyl: oh, we're still pretty much nowhere on formalized legal reasoning
13:46:55 <dyl> dataN I don't really agree with this idea that you have to "pay to read the good abstracts".
13:46:57 <ab9rf> ooh, a problem
13:47:13 <dyl> There isn't this secret cabal of "the best researchers", a Wu Tang of Academia if you will.
13:47:31 <dataN> dyl: if its the difference between you, and someone else, having to read 1000 abstracts, that you, or their lifes work. 
13:47:39 <dataN> it can be yours or theirs
13:47:49 <dyl> I also don't really see reading 1000 abstracts as particularly bad.
13:48:02 <dataN> if the paper you *need* is available, then pay for it. otherwise it could be your lifes work writing it. 
13:48:07 <ab9rf> cheater: where did that .hsc file come from?
13:48:33 <cheater> ab9rf: gitlib's git repository
13:48:45 <sclv> I don’t read abstracts, or papers. Only bibliographies!
13:48:49 <dyl> dataN I'm not really sure I agree with you at all on this: "i'd rather read 1000 abstracts written by people who have read 1000 abstracts, and *these are the ones you pay for. *"
13:48:54 <cheater> it's in <gitlib repo root>/hlibgit2/Bindings/Libgit2/Repository.hsc
13:48:59 <dyl> why is it that the best abstracts are the ones you have to pay for :|?
13:49:44 <dyl> ab9rf I didn't mean so much formalized legal *reasoning*.
13:50:06 <dyl> I just meant that legal english is 'more structured' than plain english, so it could be interesting to work out ways to exploit that structure.
13:50:48 <ab9rf> dyl: not as much as you might think
13:50:57 <ab9rf> dyl: too much variation between "practitioners"
13:51:55 <ab9rf> cheater: you undertsand that .hsc files are input to hsc2hs, right?
13:52:14 <cheater> ab9rf: i know nothing about hsc files
13:52:24 <cheater> i know they're for the C ffi or something
13:52:30 <cheater> and connect haskell to c
13:52:33 --- mode: glguy set +v Darwin226
13:52:34 <cheater> that's all i know though
13:53:00 <Darwin226> Can someone tell me if the finalizer gets called when the ForeignPtr gets cleaned up, or if the inner Ptr value gets cleaned up?
13:53:01 <ab9rf> cheater: the .hsc you're looking at is usd to define a FFI interface to another library
13:53:18 <cheater> right
13:53:23 <ab9rf> .hsc files are (slightly) easier to write than writing them from scratch
13:53:36 <Darwin226> As in, can I make multiple ForeignPtr values from the same Ptr and expect them to invoke their finalizer at different times?
13:54:37 <cheater> ab9rf: ok, where does that put is?
13:54:38 <cheater> us
13:55:08 <Boarders> say I have two records and one has a subset of the records of the other, is there a zero cost way to coerce from one to the other (I hven't really used extensible records so maybe that is the answer)
13:55:27 <ab9rf> cheater: the devleopers didn't document the module that binding is in
13:56:27 <Boarders> that should be subset of the fields*
13:57:12 <Darwin226> Alternatively, I want to hook a haskell function to run when a haskell value gets finalized. I don't actually have any pointers to foreign objects
13:57:15 <Darwin226> how can I do that?
14:00:59 <ab9rf> cheater: there is one use in gitlib, at https://github.com/jwiegley/gitlib/blob/master/gitlib-libgit2/Git/Libgit2.hs#L1532
14:01:28 <johnw_> cheater: Hi, can I help?
14:02:35 <ab9rf> oh, hey, it's john
14:03:21 <johnw_> :)
14:03:57 <ab9rf> cheater: johnw is the person you should be asking about this :)
14:03:58 --- mode: glguy set +v michaelpj_
14:04:11 <michaelpj_> I have a mysterious compilation problem that is baffling me: https://ideone.com/dJPkqu
14:04:39 <mniip> michaelpj_, it's an ambiguous type
14:05:11 <mniip> whenever you use 'embed2' in some context, that context places expectations on what the types of 'a' and 'c' are
14:05:16 <mniip> but 'b' is left undetermined
14:06:15 <JonReed> Boarders: https://hackernoon.com/the-has-type-class-pattern-ca12adab70ae
14:06:32 <michaelpj_> I guess I would have expected to get that error at the use site then, maybe
14:06:41 <michaelpj_> I do see your point, though
14:06:56 <michaelpj_> I feel like I should be able to use it with TypeApplications
14:07:06 <michaelpj_> maybe that's what AllowAmbiguousTypes would do
14:07:24 <JonReed> Boarders: Not sure if it has absolutely zero cost coersion though (I imagine it should be able to optimize it?)
14:07:31 <mniip> michaelpj_, that's exactly what AllowAmbiguousTypes does
14:07:46 <michaelpj_> thanks, that makes sense
14:07:57 <mniip> the compiler is basically telling you that with AAT enabled you will always have to explicitly TypeApply a value for b
14:08:30 <subttle> does Iceland_Jack hang out in here, does anyone know?
14:08:38 <MarcelineVQ> sometimes
14:09:00 <subttle> okay cool :D
14:10:10 <subttle> I have an example for the question he tweeted, I just hate posting to twitter so I'd rather message him here but I didn't see them here which is why I was asking
14:10:23 <mniip> what's a twitter
14:10:48 <MarcelineVQ> he's not here as often as he has been in the past
14:10:56 <Boarders> you could try sending him a private message
14:13:36 <Boarders> JonReed: thanks, that is similar to what we have actually only using lenses
14:13:52 <realloc> hi, i'm trying to use conduit to process stdin (stdinC). It works, however, it wont capture data piped in on shell level ("myapp | cat somefile.txt"). Any ideas?
14:15:11 <typetetris> `myapp | cat somefile.txt` actually pipes the output of your app somewhere else, or did you mean "cat somefile.txt | myapp" ?
14:15:21 <mnrmnaugh> are you sure you dont mean ("cat somefile.txt | myapp")?
14:16:54 <mnrmnaugh> i mean, ive done things like that. foo|grep .|bar with gnu grep is pretty decent sponge as well
14:16:56 <realloc> mnrmnaugh: I'm an idiot. 
14:17:07 <realloc> I should go to bed
14:17:11 <mnrmnaugh> onoes!
14:17:20 <mnrmnaugh> coffee
14:17:43 <realloc> so it works perfectly well, I was just piping stuff the wrong way
14:18:05 <mnrmnaugh> niice
14:18:08 <realloc> thx
14:19:05 <mnrmnaugh> hmmm stdinC that sounds useful.. idek IO yet.. hasklol wouldve nice to fix silly mozlz4 things
14:26:50 <cheater> ab9rf: sorry, i've had someone at the door
14:27:01 <cheater> johnw: i'm having trouble using libgit with hlibgit2
14:27:17 <cheater> hey michaelpj_
14:27:21 <johnw> what sort of trouble?
14:29:14 <cheater> johnw: i'm trying to do stuff like: open a non-bare repository at a specific path, get the commit message in HEAD, fetch from a remote repo via ssh (or better yet some sort of socket within my haskell program), and merge with fast-forward (the other repo might have diverged, but it would only add files with names that are guaranteed to not collide with mine), also i would like to add and commit files
14:29:45 <cheater> i have been digging through gitlib, hlibgit2, libgit, and also pygit2 for several days now and i don't have a clue how to do this with gitlib
14:30:30 <johnw> the first part of what you described is easy with gitlib
14:30:36 <johnw> for an exmaple, see:
14:30:45 <cheater> i've seen something about a tree builder, but that's all
14:31:11 <cheater> i did something like: withRepository lgFactory "../test-repo/" $ do
14:31:18 <cheater> that seems to open the repo
14:31:27 <cheater> but on the next steps, i'm lost
14:31:39 <johnw> hmm.. seems that I deleted it
14:33:16 <johnw> here: https://github.com/jwiegley/gitlib/blob/c7cda41b478605de42747060e008b8b5bfd77f17/git-gpush/Main.hs#L108
14:33:21 <johnw> that's does exactly what you described
14:33:27 <johnw> it opens up the HEAD commit and looks at its commit message
14:33:43 <johnw> well, more or less
14:34:20 <johnw> doing a fast forward merge should be easy, but no such code exists yet
14:34:34 <johnw> in that case, you just confirm that one head is in the immediate history of the other, and then update the HEAD ref to point to it
14:34:48 <johnw> you'd copy from the remote repo into the local one
14:35:07 <johnw> as for only adding files guaranteed not to collide, I'm not clear on what you mean
14:35:15 <johnw> but I'm guessing that for that, you'd use the tree builder
14:35:58 <shanemikel> What's the trouble of instancing a typeclass for an unowned datatype?
14:36:08 <shanemikel> Is there a term for that?
14:36:10 <monochrom> What is unowned?
14:36:20 <shanemikel> defined in another module
14:37:03 <monochrom> The term is "orphaned" but this requires also that the class came from another module too.
14:37:07 <ab9rf> orphaned?
14:37:10 <shanemikel> orphaned
14:37:12 <shanemikel> right... 
14:37:31 --- mode: glguy set +v drp1338[m]
14:37:45 <ab9rf> you're not allowed to create an instance of a class for a type unless either the type or the class are defined in the immediate module
14:37:57 <ab9rf> instances are global
14:38:09 <ab9rf> so if two modules were to try to do this, they'd collide
14:38:34 <cheater> johnw: sorry, what do you mean about the tree builder?
14:38:37 <ab9rf> this rule reduces instance collisions by restricting where instances can be defined
14:39:35 <rzmt> How do i write bytestrings from Data.Csv into a file? This doesn't work https://paste.pound-python.org/show/EUv7rS947HQdXrBncjOJ/
14:39:49 <ab9rf> note that the utility of orphan instances is a matter of dispute, at least at times
14:40:16 <hpc> looking at it from the other direction, when you import something it's nice to know that it doesn't contain instances that will break your code
14:40:53 <ab9rf> the purpose of the rule is to avoid a limitation on the composability of libraries, by minimizing developer surprise
14:42:15 <ab9rf> if you need to define an instance for some type of a class you didn't define, you can always wrap that type in a newtype and make the newtype an instance. this is not an orphan instance because the newtype is defined in your module.
14:46:10 <shanemikel> ab9rf: yes I'm aware of the practice. thanks.  I'm actually quite familiar with GHC, but it's been a couple years.  I've been toying with rust and I'm having the same issue there, but they don't provide an escape hatch yet.  I was failing to remember the GHC terminology, which I figured would help explain my problem
14:46:46 <dmwit> bwe: yep
14:50:04 <ab9rf> shanemikel: ah. i haven't done anything with rust yet, so no comments
14:50:41 <cheater> johnw: how does one fetch with libgit?
14:51:34 <cheater> johnw: also, is it possible to fetch from a git repository on another computer, via a socket that my haskell program has opened, and that i have available in my program?
14:51:58 <cheater> i have my own transport running there, and whatever git would do, that would go on top of that i guess
14:58:43 <cheater> johnw: in that file, why do you do half of it with gitlib and half of it with the git binary?
15:11:11 <dyl> cheater I thought libgit wasn't concerned with network/fetching?
15:11:21 <dyl> Just the on-disk stuff.
15:11:33 <dyl> I'm probably mixing something up.
15:13:57 <cheater> libgit2 has the ability to use an ssh transport, which to me means it can fetch over the network.
15:15:02 <atchoum> hi
15:16:06 <atchoum> I just had the thought crossing my mind, that category theory was kind of a thing for powerful, courageous minds, with both the intuition and the powerful will to abstract the world in meaningful constructs.
15:17:40 <atchoum> while the meaningful side should be cast away for truly courageous minds.
15:18:09 <c_wraith> math cares little for courage.
15:18:42 <c_wraith> category theory is just a series of abstractions that refer to concrete things even less than most math
15:19:07 <atchoum> « math cares little for courage » nothing could be more wrong. 
15:19:32 <atchoum> At least I see courage in the will to go on this so called abstractions.
15:19:37 <dataN> https://lpaste.net/5336316283380039680
15:20:38 <atchoum> who is this Anonymous Coward anyway
15:20:58 <atchoum> sorry but you lost me. I got better things to do.
15:21:18 <johnw> cheater: you "fetch" by open two repository and copying commits from one to the other
15:21:27 <atchoum> but I truly think that it takes some courage to free  one's mind in doing maths.
15:21:58 <johnw> cheater: see Git.Commit.Push.copyRepository and pushCommit
15:22:30 <fishythefish> it takes courage to deal with the real world, math is an escape :P
15:22:34 <johnw> copyRepository works by creating a new bare repo, and then fetching all of the commits of another repository into it
15:22:50 <atchoum> fishythefish: I really think the opposite
15:23:03 <atchoum> but your pov is kind of truthful 
15:23:29 <dataN> would it be possible to tell how to fix that paste?
15:23:53 <atchoum> dataN: did you write it ?
15:25:17 <atchoum> dataN: « for some reason its throwing a compile error when 'Applicative f' is ommited, »
15:25:19 <mniip> no I'm pretty sure he has a misterious hat he keeps pulling these out of
15:25:48 <atchoum> dataN: not much of an answer but I think dissecting computers is always easier than dissecting nature
15:25:58 <dataN> atchoum: thats not the problem
15:26:39 * atchoum cannot even know what is the actual problem so he will be waiting until someone competent answer.
15:27:02 <MarcelineVQ> I'm guessing it's looping, based on the Interrupted at the bottom, but it's not very clear
15:27:32 <dataN> MarcelineVQ: yes, thats it
15:27:55 <dataN> thanks
15:27:55 <MarcelineVQ> you should make that clear next time because the problem did seem like you were asking about Applicative
15:28:11 <dataN> it should not loop
15:28:19 <cheater> johnw: let me look, 1 sec
15:29:04 <dyl> Can anyone elaborate on the use of Proxy vs injective type families?
15:29:16 <cheater> johnw: why is it called copyRepository? am i copying a whole repo?
15:29:23 <dyl> I see a lot of proxy usage, but it does appear the InjectiveTypeFamilies extension exists and works.
15:30:28 <atchoum> > ((<*>)(pure (+1)) (pure 1))
15:30:31 <lambdabot>  error:
15:30:31 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M851724830379...
15:30:31 <lambdabot>        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
15:30:38 <atchoum> :(
15:30:38 <dataN> maybe the Applicative error has something to do with it.
15:31:00 <atchoum> IDK but the result of go2 is 2 on my interpreter
15:31:11 <atchoum> though the expression is a little bit different
15:32:12 <dataN> oh, is the GHC version for UndecidableSuperclasses the issue?
15:32:14 <MarcelineVQ> dataN, your <*> for List uses ap, which uses defaultBind which uses asum  which uses <|> which uses liftA2 which uses <*>
15:32:37 <dataN> woot!
15:32:41 <dataN> thanks
15:33:39 <dataN> wait, how does <|> use liftA2?
15:34:00 <atchoum> does anybody already think of writing haskell without spaces ?
15:34:02 <cheater> johnw: how does one merge?
15:34:13 <atchoum> (would it be possible btw ?)
15:34:27 <dataN> no
15:34:31 <atchoum> :(
15:34:49 <atchoum> I mean without breaklines at least
15:34:53 <cheater> only villains do that
15:35:57 <atchoum> itsoundsverycool
15:36:01 <MarcelineVQ> dataN: sorry I was looking at 'some' accidently, still when you loop with <*> it's usually due to <*> calling itself in some fashion and I'm pretty suspicious of your Monad in terms of Applicative stuff
15:36:27 <dataN> but thats the whole point!
15:36:43 <greymalkin> I'm confused by the result of `[1] <|> [2]` being [1,2] -- that seems more Monoid than Alternative.
15:36:59 <greymalkin> What am I missing?
15:37:31 <dataN> 'Alternative f' is like 'forall a. Monoid f a'
15:37:43 <dataN> (f a) *
15:39:14 <greymalkin> I guess I was intuiting that it should result in `[1]` being that the `<|>` acts like an `orElse` for most Alternative Monads; I didn't expect the behaviour of mconcat.
15:39:27 <dataN> MarcelineVQ: it loops even if the definition of <*> is commented out
15:39:31 <atchoum> I have a real question though. I scored a very good grade in group theory, but it seems I cannot  get a good grasp of CT.
15:40:00 <atchoum> Well « a good grasp of CT » may very well be oxymorous / antinomic
15:41:12 <dataN> is there an easy way to upgrade GHC on windows? 
15:41:28 <dyl> atchoum it helps to see CT in some bigger context, with examples.
15:42:10 <atchoum> dyl: most examples come from what I'd call a good level of maths (ie you need to at least what domain/codomain mean for a function, you need to know what a set is, etc).
15:42:19 <dyl> I've been personally enjoying going through 'Algebra: Chapter 0', which covers a lot more than CT... but introduces CT early and weaves it throughout.
15:42:50 <atchoum> dyl: personally, group theory has been really interesting to me but CT doesn't stick
15:43:03 <dyl> (it starts from sets and categories, then works up through rings, groups, fields, vector fields, modules, the works)
15:43:06 <atchoum> but I am still looking for courses like CT for dummies etc.
15:43:25 <dyl> My point is that trying to "learn CT" as the end goal in my experience doesn't work.
15:43:46 <dyl> otoh, learning CT as you explore other parts of algebra and using it as a conceptual filing system/assembly language works very nicely.
15:43:46 <dataN> perhaps try a math irc?
15:43:50 <atchoum> dyl: yes, but this stuff is so basically abstract that examples doesn't really make sense
15:43:57 <dyl> That's my point exactly.
15:44:07 <dyl> It's so abstract and, really, simple, that it's hard to grok.
15:44:26 <dyl> But when you have a bunch of examples from throughout algebra, you can hang your coat on your intuition in those other areas.  
15:44:57 <dyl> The best way to develop intuition about a CT concept is to develop intuition about a lot of examples of that concept.
15:45:02 <atchoum> can you map categories on categories ?
15:45:03 <dyl> It might even be the only way.
15:45:09 <hpc> it's coats all the way down
15:45:31 <dyl> atchoum you might find Algebra Chapter 0 enlightening :). 
15:45:49 <dyl> It weaves CT in from the start while you build up intuition for algebraic objects.
15:45:56 <dyl> And will go further than your group theory course did.
15:46:05 <dataN> can anyone understand why this loops? https://lpaste.net/5336316283380039680
15:46:14 <dyl> (though the first several chapters are an alternate treatment of that)
15:46:21 <atchoum> you mean that ? https://bookstore.ams.org/gsm-104
15:46:38 <atchoum> to me maths are always understandable through exercises
15:46:42 <dyl> Yes. 
15:46:54 <atchoum> I mean you get the hang of some demonstration and then you get the idea and then you are good to go
15:46:55 <dyl> You're probably familiar with a lot of the material up through Chapter IV.
15:46:59 <dyl> Though this may be a much deeper dive :).
15:47:34 <atchoum> yes relearning the basics ç
15:47:54 <cheater> johnw: also, is stuff in gitlib/README.md accurate, or is this woefully outdated?
15:47:56 <atchoum> is always a good thing
15:48:08 <dyl> It's also just a deeper treatment than the usual college/university/... group theory course.
15:48:14 <dyl> Note that group theory and field theory are split up into two parts.
15:48:21 <hpc> dataN: i bet the problem is (<*>) = ap
15:48:29 <dyl> er, groups and linear algebra
15:48:50 <hpc> ap is defined in terms of (>>=), (>>=) is defined in terms of FoldableMonad, and maybe FoldableMonad's defined in terms of (<*>)?
15:49:09 <dataN> hpc: it can not be, as it still loops if that line is commented out!
15:50:02 <atchoum> mmh ship to this adress : rue de Panama Paris :D
15:50:08 <dyl> A good essay and a good interview, each about learning math:
15:50:10 <dyl> https://terrytao.wordpress.com/career-advice/theres-more-to-mathematics-than-rigour-and-proofs/
15:50:11 <atchoum> expensive good
15:50:12 <dataN> asum does not use <*>
15:50:14 <dyl> https://plus.maths.org/content/andrew-wiles-what-does-if-feel-do-maths
15:51:11 <hpc> oh huh, asum is defined in terms of (<|>)
15:51:15 <dyl> Wiles comments on 'getting stuck' ring really true to me.
15:51:42 <dyl> "The process of research mathematics seems to me [to be] that you absorb everything about the problem, you think about it a great deal... [and] you get stuck. Then you have to stop, let your mind relax a bit and then come back to it. Somehow your subconscious is making connections and you start again, maybe the next afternoon, the next day, the next week even and sometimes it just comes back. Sometimes I put something down for a few months, I come back and
15:51:42 <dyl>  it's obvious. I can't explain why. But you have to have the faith that that will come back."
15:51:47 <dyl> ^ very important for anyone learning maths I think.
15:51:52 <dataN> hpc: right, via explicit recursion, it should not enter a constraint loop
15:51:57 <hpc> dataN: (<|>) (Cons x xs) ys = x `Cons` xs <|> ys
15:51:58 <dyl> or Haskell for that matter :)
15:52:01 <hpc> dataN: add parens here
15:52:13 <hpc> see if it still loops then
15:52:16 <atchoum> dyl: working is just like that
15:52:22 <dyl> A lot of things are.
15:52:33 <atchoum> still this wiles seems impressive
15:52:36 <dyl> I have found a couple well-placed 15 minute walks during the work day can *really* help productivity.
15:52:52 <hpc> ^
15:52:52 <MarcelineVQ> hpc: good catch :O
15:53:06 <MarcelineVQ> that's entirely the issue
15:53:14 <dyl> I have a lovely eucalyptus grove near my desk now. 
15:53:21 <dyl> Perfect for a good walk.
15:53:30 <dataN> it does
15:53:34 <dataN> loop that is
15:53:36 <mniip> dyl, that explains a good deal of things
15:53:50 <dyl> It's like you're cooking, you add ingredients to the pot, but you also have to sometimes cover, reduce heat, and just let it simmer.
15:54:00 <dyl> Sometimes you just need to let it be for a bit.
15:54:24 <dyl> The most effective way to think through a problem is often to judiciously and deliberately set aside time to *not* think about it! 
15:54:29 <dataN> dyl: can you stfu please
15:54:36 <dyl> Sorry, ⇒ -offtopic.
15:55:34 <MarcelineVQ> Even if it is that's not a useful response. If you don't want to hear something don't listen to it dataN, or even better one can suggest something that is useful to talk about
15:55:51 <hpc> dataN: works for me when i test it with parens there
15:55:52 <dyl> I was rambling a bit off topic, I'm in the wrong here. No worries.
15:55:58 <hpc> how did you parenthesize it?
15:56:27 <MarcelineVQ> dataN: It also worked for me when properly parens'd
15:56:35 <hpc> you need to make sure you're actually deconstructing the first parameter
15:56:51 <hpc> and not reassembling it again when you do the next (<|>)
15:57:19 <dataN>  (<|>) (Cons x xs) ys = Cons x (xs <|> ys)
15:57:36 <dyl> Inline function applications bind more strongly than operators. 
15:58:02 <dataN> the fixity was not the problem 
15:58:30 <dyl> No, the problem is that you're just constructing exactly what you just destructured. 
15:58:51 <dataN> its not though
15:58:54 <dyl> You have (Cons x xs) <|> ys ⇒ (Cons x xs) <|> ys 
15:59:10 <dmwit> dataN: Let's stay civil.
15:59:34 <MarcelineVQ> It was the issue though, perhaps you forgot to save or reload the source file entirely?
15:59:42 <chessandgo> can you have a data type the uses its own constructures later, I'm trying to create a finite state machine for logging
15:59:45 <chessandgo> data LoginState' = NoCredentials | Username T.Text | UsernameAndPassword (Username T.Text)
15:59:51 <MarcelineVQ> Or you've tried other thins and yours has deviated from the paste in other ways?
15:59:52 <chessandgo> something like this, but valid
16:00:11 <dyl> chessandgo constructors themselves are not types.
16:00:22 <dyl> But you might be able to use a phantom type and GADTs to constraint a bit more.
16:00:39 <dyl> Or, maybe separate our Username as its own type.
16:00:42 <hpc> i would just make Username and Password types
16:00:43 <hpc> yeah
16:00:52 <chessandgo> I was thinking GADTs might be it, i'll have to learn them
16:01:03 <hpc> GADTs are overkill here
16:01:05 <dyl> GADTs are probably going to turn into a snakepit. 
16:01:44 <dyl> If you *really* want to constrain to certain constructors, you can use them to do that (think of something like Expr a being specialized to Expr Int).
16:01:50 <atchoum> snakepit :D
16:01:54 <dyl> But, in practice you probably just want to refactor your types.
16:02:08 <hpc> dataN: i copied https://lpaste.net/5336316283380039680 into test.hs, changed line 88 to " (<|>) (Cons x xs) ys = x `Cons` (xs <|> ys)", loaded it into ghci, and ran go2
16:02:10 <dataN> even with this line is commented out, it still loops!
16:02:11 <hpc> and got a result
16:02:28 <chessandgo> essentially, I have a product type that im trying to convert to sum
16:02:40 <chessandgo> I have this
16:02:41 <chessandgo> data LoginState = LoginState (Maybe T.Text) (Maybe T.Text) deriving (Show)
16:03:03 <dataN> im on 8.4.3
16:03:07 <chessandgo> but it'd make sense that you couldn't have typed your password before your username, so I'm trying to contrain it
16:04:26 <MarcelineVQ> dataN: So am I and get the Cons 2 Empty result with the change hpc suggests
16:04:39 <dyl> chessandgo well, one thing is, is it actually useful to have the Username constructor part there at all?
16:04:40 <hpc> data LoginState = LoginState (Maybe (T.Text, Maybe T.Text)) deriving (Show)
16:05:03 <dyl> as an example of what I mean, UsernameAndPassword (T.Text) would be just fine too, provided you know that's the username.
16:05:30 <dyl> hpc this is a state, it doesn't actually contain the password I think.
16:05:30 <hpc> dataN: a tip when you try a bunch of stuff and nothing seems to make the result change in any way whatsoever:
16:05:39 <hpc> dataN: just put lkajshdlkajshdlkjahsdglkjhaslkgjhalksjdghlkasdjhglkkashdglkjh at the end of the file, and retest
16:05:48 <chessandgo> it was planning for it to be UsernameAndPassword (Username T.Text) T.Text, its just it was already invalid
16:05:58 <dataN> yeah its compiling correctly
16:06:00 <hpc> dataN: no error, and now you know you're not loading new code at all
16:06:07 <chessandgo> just trying to make it impossible to create a UsernameAndPassword without already having a Username
16:07:10 <dyl> chessandgo one moment...
16:07:25 <chessandgo> hpc: that'd work, it was just hoping for multiple type constructures for pattern matching for state transitioning
16:08:14 <hpc> chessandgo: just use deeper patterns
16:08:26 <dyl> I can show you the sledgehammer approach also :p
16:08:55 <chessandgo> im pretty sure the sledgehammer approach is data LoginState = LoginState (Maybe T.Text) (Maybe T.Text) deriving (Show)
16:09:14 <chessandgo> and pattern mathcing on that and just having a case to catch the invalid situation :P
16:09:46 <chessandgo> hpc: I think you've got the answer, ill tryout your solution
16:10:04 <atchoum> what do you think of that: http://www.stephendiehl.com/posts/production.html ?
16:10:39 <atchoum> It seems an honest review of what can be done with Haskell on large corporate projects.
16:11:53 <atchoum> can you do with haskell the same kind of transitive imports that you can do in Python ?
16:11:56 <dataN> MarcelineVQ: maybe not. this certainly does not change anything
16:12:22 <MarcelineVQ> dataN: are you copying from the paste like we are?
16:12:58 <dataN> oh, can you load it into lambdabot?
16:13:38 <MarcelineVQ> You probably could but what I​ mean is we're using the same thing and chagning the same thing, are you also copying and changing that thing? it's easy for forget if you've made other changes
16:14:26 <dataN> if thats the case maybe lambdabot would remove such possibility 
16:15:06 <dataN> there is a command to import from lpaste? 
16:15:57 <MarcelineVQ> I'm not sure it works with the current lpaste
16:16:16 <MarcelineVQ> but if it did it would be @letpaste thepastenumber
16:16:31 <dataN> @letlpaste 5336316283380039680
16:16:31 <lambdabot>  Parse failed: Parse error: <
16:16:45 <MarcelineVQ> I use a wrapper script to load pastes into a ghci session typically, though I didn't in this case
16:17:13 <hpc> in vim, :%s/\d\+\n^I//gc gets rid of the line numbers
16:17:36 <MarcelineVQ> hmm? it should be loading from raw
16:17:39 <dataN> whats the other compiler running on this irc?
16:17:53 <hpc> MarcelineVQ: new lpaste doesn't seem to have a raw output
16:17:58 <MarcelineVQ> sure it does
16:18:01 <hpc> or maybe it exists but not in the ui?
16:18:08 <MarcelineVQ> dataN have you tried to copy and edit https://lpaste.net/raw/3037433925799510016 ?
16:18:26 <hpc> oh, it's /raw/id, not /id/raw
16:18:32 <MarcelineVQ> oops wrong paste link hehe, that's my edited one already
16:18:59 <MarcelineVQ> https://lpaste.net/raw/5336316283380039680 is yours
16:22:10 <MarcelineVQ> re the previous subject, I'm just an old fashioned sort of idiot but if your datatype contains only Maybe you maybe have an extraneous type
16:22:36 <MarcelineVQ> *extraneous datatype
16:22:39 <dyl> chessandgo: to give you the broad picture of one approach, you can define a data type such as data Cred = None | User | UserPass but use data kinds to promote it. So UserPass is a type of kind Cred. Then you have data AuthState (a :: Cred) where ...
16:22:40 <dyl> With constructors like 
16:23:02 <dyl> PasswordProvided :: AuthState User -> T.Text -> AuthState UserPass
16:23:04 <dataN> ah, my local version had (<*>) commented out which caused the loop. thanls
16:23:18 <dyl> So basically you have a closed type family of tags which you use to “classify” AuthStates. 
16:23:28 <dyl> And then you can encode relationships between these in constructors.
16:23:29 <chessandgo> do you think getting into type level programming is really worth it tho?
16:23:32 <dyl> No.
16:23:36 <MarcelineVQ> This is why I was trying to impress on you that it's best to work from the same slate as others because a person forgets their edits
16:23:38 <chessandgo> me too, at least for this
16:23:39 <dyl> Not at all really. 
16:23:44 <dyl> But it’s fun :p
16:23:53 <chessandgo> maybe I will
16:24:08 <MarcelineVQ> You've now lost 30 minutes of your life to a solved problem :>
16:24:19 <chessandgo> i'd like to make use of some crazy features in my program :P
16:24:26 <hpc> chessandgo: it's worth it, but don't try and make the compiler do value-level things
16:24:27 <dyl> And I’m sitting in a PL area in a CS department so I’m obligated to suggest overwrought and overcomplicated but intellectually interest approaches. 
16:24:33 <dyl> ^ 
16:24:40 <dataN> hpc, MarcelineVQ: while your here and the code now working and understood, is there any chance to ask about this approach to writing default instances using UndercidableSuperclasses used in these examples?
16:24:43 <hpc> chessandgo: good type-level programming is in service of the values in those types
16:24:46 <dyl> That’s a very good way to phrase it. 
16:24:54 <chessandgo> we're also using haskell
16:24:57 <MarcelineVQ> I've no experience with UndercidableSuperclasses at all
16:25:02 <chessandgo> we have to over complicate things
16:25:17 <dataN> but thats how this code manages to do what it does
16:25:25 <dyl> One nice thing about the HKT approach here though is that you can define functions individually for cases. 
16:25:45 <dyl> For example AuthState None clearly doesn’t have a username projection. 
16:25:46 <dataN> doh, it does not
16:26:19 <dataN> must have been a previous version which did, sry. ok but the question remains about the approach
16:26:31 <dataN> the class Entails it introduces 
16:26:35 <chessandgo> on a side note, i've been looking into kinds in haskell, and I can only really find # and * (ignoring higher ranked kinds)
16:26:42 <chessandgo> is there some other ones
16:27:02 <dyl> chessandgo look at the ConstraintKinds and DataKinds extensions 
16:27:45 <dyl> With the latter, data Nat = Z | S (Nat) actually also defines a kind Nat inhabited by the types Z and S.
16:27:47 <MarcelineVQ> dataN: I don't know much about that stuff sorry, certainly not enough to say whether an approach is more valid than another
16:27:56 <chessandgo> i meant more like built in kinds, so I can more easily wrap my head around it
16:28:09 <chessandgo> given # and * very concrete examples
16:28:13 <chessandgo> with regards to the bottom value
16:28:20 <hpc> chessandgo: Constraint is the kind of things that go to the left of (=>)
16:28:28 <dyl> Typeclasses (as constraints) can also act as kinds. 
16:28:51 <hpc> :k (Functor [])
16:28:52 <lambdabot> Constraint
16:29:00 <hpc> :k Category
16:29:01 <lambdabot> (k -> k -> *) -> Constraint
16:29:09 <dyl> :k Functor 
16:29:10 <lambdabot> (* -> *) -> Constraint
16:29:12 <chessandgo> is the Constraint Kind just called Constraint?
16:29:16 <hpc> yep
16:29:17 <dyl> Yeah. 
16:29:24 <chessandgo> no single ascii symbol
16:29:36 <geekosaur> the ASCII symbols are going away, actually
16:29:42 <geekosaur> as of 8.6, * is called Type
16:29:45 <hpc> :k (->)
16:29:46 <lambdabot> TYPE q -> TYPE r -> *
16:29:47 <chessandgo> yeah, but id atleast like them to match
16:29:53 <dyl> Really? 
16:29:54 <chessandgo> is # getting renamed too?
16:30:05 <hpc> # is already renamed, iirc
16:30:11 <chessandgo> whats it called?
16:30:22 <dyl> AccursedUnutterableSort
16:30:35 <geekosaur> # was replaced by Levity, which was in turn modified by RuntimeRep
16:30:36 <chessandgo> Octothorp Kind
16:30:45 <dyl> ...Levity?
16:30:55 <dyl> What’s the etymology? 
16:31:00 <dyl> Something to do with hoisting? 
16:31:02 <chessandgo> I know of Levity polymorphism but I didnt know thats what # was called now
16:31:09 <MarcelineVQ> Loftity sounded dumb
16:31:12 <geekosaur> basically, instead of a specific kind, it refers to lifted vs. unlifted types
16:31:19 <geekosaur> and is a constructor instead of a simple kind
16:31:44 <geekosaur> # only really worked when it was guaranteed that every unlifted type could be represented as a machine word
16:31:48 <dyl> It occurs to me that edwardk doesn’t have anything named after him. I suggest the hierarchy: Value, Type, Kind, Sort, Kmett. 
16:31:57 <chessandgo> isnt there a super kind called ? that * and # are part of, or was than an extentsion 
16:32:05 <geekosaur> that was a hack for older ghc
16:32:22 <hpc> Lens k m e t
16:32:26 <geekosaur> which no longer exists, the newer representation allows levity polymorphism so the ? and ?? hacks aren't needed any more
16:32:26 <dyl> Soon we’ll all be doing sort-level programming with constraint kmetts.
16:32:53 <chessandgo> so Levity Type and Constraint are the only built in kinds we currently have
16:33:52 <dyl> What is Levity polymorphism? 
16:34:11 <phadej> Unlifted/lifted
16:34:12 <chessandgo> polymorphism over lifted and unlifted 
16:34:20 <geekosaur> being able to work on both unlifted and lifted kinds
16:34:28 <chessandgo> so id can work on kinds of * and #
16:34:40 <hpc> it lets you write stuff like this:
16:34:40 <hpc> example :: Int# -> Int# 
16:34:41 <hpc> example = id
16:34:57 <dyl> :t ($)
16:34:59 <lambdabot> (a -> b) -> a -> b
16:35:05 <dyl> Oh, it doesn’t show the “new version”. 
16:35:06 <hpc> % :t ($)
16:35:07 <yahb> hpc: (a -> b) -> a -> b
16:35:10 <jollygood2> hi
16:35:12 <hpc> :
16:35:13 <jollygood2> I am struggling to express something in haskell that is very easy and natural to express in OOP language. in OOP language I would have a library with a base class, which defines some common methods, and several methods that are supposed to be overloaded by the user of the library. this allows user of the library to extend the class (while taking advantage of methods defined by the library). it also allows library code to work o
16:35:14 <hpc> :/
16:35:28 <chessandgo> typeclasses?
16:35:47 <hpc> jollygood2: if the base class is an interface, that sounds like haskell's type classes
16:35:50 <jollygood2> chessandgo, I tried that, but then got a link saying it was considered antipattern to use typeclasses like this
16:36:17 <hpc> it's an antipattern to use them with an existential to try and get inheritance
16:36:20 <dyl> As existentials you mean?
16:36:30 <hpc> you don't really have inheritance here though, just a common interface
16:36:47 <jollygood2> don't I need existential to do this? " it also allows library code to work on a list of base classes, which may also contain objects of inheritted, user-defined classes, and it can operate on them in a generic manner"
16:37:22 <jollygood2> and yes, with typeclasses user of the library can't take advantage of the methods that library defined for the base class
16:37:36 <ricky_clarkson> jollygood2: Oddly enough, it's kind of out of fashion in OOP languages anyway.
16:37:37 <dataN> ok, here is the final version; https://lpaste.net/1091699344257581056
16:37:49 <dataN> it *does* use UndecidableSuperclasses...
16:38:24 <dyl> jollygood2 it’s better to think in terms of interfaces/protocols/etc than inheritance. 
16:38:46 <dyl> While some things are taxonomizable, in most cases you don’t have a hierarchy so much as a set of protocols.
16:38:50 <dataN> the class "Entails" can be used to return "trivial" from "sufficient" superclasses. 
16:39:23 <ski> jollygood2 : cut off near "... it also allows library code to work o"
16:39:31 <jollygood2> oh?
16:39:47 <jollygood2> it also allows library code to work on a list of base classes, which may also contain objects of inheritted, user-defined classes, and it can operate on them in a generic manner
16:40:02 * ski idly wonders whether jollygood2 just wants higher-order functions
16:40:33 <dolio> Probably.
16:40:53 <dataN> any comments?
16:40:53 <ski> hm, or maybe record-of-functions ?
16:40:57 <jollygood2> this is where existentials come in, I need them to have a list of typeclasses, or something close to it. and that is apparently considered an antipattern in haskell. so what is the idiomatic way of expressing this in haskell?
16:41:02 <dolio> Probably that, too.
16:42:11 <dyl> jollygood2: are you trying to have a heterogenous list? 
16:43:09 <dyl> jollygood2: you should peruse the Typeclasses a la Carte paper perhaps 
16:43:22 <ski> jollygood2 : have you tried using HOFs or records of functions ?
16:43:23 <dyl> Look up the expression problem also.
16:43:23 <dolio> The reason it's an "antipattern" is that it's basically a complicated way to have the record-of-functions thing that ski mentioned.
16:43:26 <dataN> jollygood2: its not usual to put constraints in a list, why not use a tuple?
16:43:45 <jollygood2> dyl, I don't know if I'd call it a heterogenous list, in OOP language it would be a list of object of base class type. if you are hinting at algebraic data type, that won't work, because I want to give user of the library the ability to create additional types
16:43:51 <dyl> Sorry, data types a la carte. 
16:43:53 <dyl> http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf
16:44:26 <hpc> jollygood2: you want records of functions
16:44:38 <dyl> ^ 
16:44:41 <ski> jollygood2 : HOFs would allow the user of the library to pass in functionality (behaviour) for the library to use, instead of the user subclassing the base class / implementing the interface
16:44:43 <dyl> Right so in Haskell if you have a class Widget, a homogenous list is forall a. Widget a => [Widget] 
16:44:51 <dyl> [a]*
16:44:53 <hpc> jollygood2: so, in C++ the way class methods work is you have a virtual function table at the start of the struct
16:45:04 <ski> jollygood2: if you want heterogenous collection, then try record-of-functions
16:45:05 <dyl> But a heterogenous list has to be of existentials, which gets hairy. 
16:45:08 <hpc> jollygood2: which is just another struct with function pointers in it
16:45:24 <hpc> right in the value, basically encoding what type it has at runtime
16:45:33 <dyl> record of functions is a much easier approach, and indeed is often what you have to do to make type erasure work nicely in other languages.
16:45:37 <hpc> you would do the same with a haskell record, just putting functions in it as fields
16:45:56 <hpc> data Object = Object {method :: Something}
16:46:04 <jollygood2> so record of functions, where functions would be similar to methods I'd have in a base class?
16:46:04 <hpc> in that example, method :: Object -> Something
16:46:06 <dyl> I.e. you have some typeclass Widget,  
16:46:23 <dyl> you make an erased box WidgetBox which is a record of functions (methods of Widget) 
16:46:34 <hpc> you can make it a function to add more parameters, or make Something a more suitable "action" kind of type like IO ()
16:46:40 <dyl> And then you can conform/instantiate Widget for WidgetBox also.
16:46:52 <ski> (dyl : rather it's a list of type `[a]' for some type `a' where `Widget a'. the `forall a.' bit there would mean something else, and the `Widget a =>' is also inaccurate)
16:46:58 <jollygood2> would you completely replace objects with records of functions, or have actual objects with normal fields, then convert them to records of functions?
16:47:10 <dataN> is what is being described a dependant type, where the records can be added at runtime, or a kind of extensible record datatype what the compiler should handle somehow?
16:47:14 <hpc> data PrinterBase = Base {print :: String -> IO ()}
16:47:31 <hpc> ^ can construct a printer object for stdout, stderr, a network handle, or one that doesn't print at all
16:47:33 <dyl> ski my bad 
16:47:36 <hpc> just by changing what you put in that field
16:48:06 <dyl> We should write a tongue in cheek ebook called “Value Level Programming in Haskell”.
16:48:19 <hpc> dyl: that sounds like a legit idea
16:48:31 <ski> dyl : i'm only mentioning this because it seems to be a common misconception (or perhaps common incorrect formalization of a more correct vague intuition of what's going on)
16:48:33 <ricky_clarkson> hpc: Does the virtual function table get repeated in every struct/class, or does it get stored centrally so that each struct/class only needs one pointer to it?
16:48:34 <dolio> jollygood2: I would guess most seasoned Haskell folk wouldn't be thinking about objects in the first place.
16:48:50 <dyl> ski I was roughly sketching on my one.
16:48:52 <hpc> ricky_clarkson: in C++ it's probably a pointer
16:48:55 <dyl> phone*
16:48:59 <hpc> to reduce memory and keep it a constant size in the struct
16:49:49 <ricky_clarkson> phew, mental model intact. Thanks.
16:49:59 <ski> jollygood2 : what would "actual objects with normal fields" be, in your case ?
16:50:31 <dyl> jollygood2 let me provide you an example
16:50:52 <dataN> so its a type level list of types and a list of values of a sum type over them, and named lenses to each index of this list?
16:50:55 <ski> dataN : neither, i think, if you're commenting on the discussion originating from jollygood2
16:51:08 <dataN> yes that
16:51:19 <ski> (or were you talking about your earlier paste ?)
16:51:44 <dataN> its not that?
16:53:08 <ski> jollygood2 : record-of-functions is like having objects without classes, and without implementation inheritance. but with interfaces (abstract base classes if you will)
16:53:09 <jollygood2> ski, I am trying to writing a web scraper that works on different web pages, and scras different thing,s, and I am trying to have as much common, generic code as possible. so actual "objects" would be, for example, data ComputerAd { cpu :: String, memory :: Integer }. and then a record of fucnctions would, I guess, be something like this GenericAd { getPrice() .. addToTable :: IO () } 
16:53:18 <jollygood2> I am not even sure if that is making sense
16:53:47 <jollygood2> one issue compared to OOP approach, is that I can't have common fields and methods. like, for example, price, description, etc, something that all ads have
16:54:06 <ski> (well, in this situation, to a first approximation, a class is just a function (a value, a run-time entity) that computes an object)
16:54:14 <jollygood2> and if I have both concrete types, like ComputerAd, and generic ype that is record of functions, won't that involve a lot of boilerplate?
16:54:30 <ski> (if you want open recursion, then you need something more involved)
16:56:13 <ski> dataN : i was answering your earlier question, fwiw
16:57:26 <ski> jollygood2 : one record could reference another record
16:57:42 <dyl> record-of-functions is pretty much just *manually passing around vtables*.
16:57:53 <ski> (or one could copy over fields)
16:58:16 <hpc> oh yeah
16:58:28 <dataN> i dont know how to add records to a datatype anywhere except at the data deceleration, and i dont know if using lenses and type lists to emulate this is whats required
16:58:34 <hpc> jollygood2: so looking at yet another language, javascript and quite a few other languages do what's called prototype OO
16:58:39 <ski> jollygood2 : do you need to be able to access `cpu' and `memory' from outside the object itself ?
16:58:59 <hpc> jollygood2: part of it is that for inheritance, there's just always a field that's the same for every type, containing the parent object
16:59:19 <hpc> jollygood2: so if you have class B extends A, and make a B object
16:59:33 <hpc> jollygood2: you're also making an A object, and making b_object.parent = a_object
16:59:33 <ski> jollygood2 : iow, do you actually need your "concrete types" ?
17:00:30 <dataN> hpc: "extends" as in a subclass with an additional abstract function? 
17:00:56 <ski> dataN : i suspect you're thinking of something more complicated that might not be necessary in jollygood2's case
17:01:26 <hpc> as in B is a subclass of A
17:01:40 <hpc> neither one necessarily needs to have abstract methods (not functions)
17:02:12 <dataN> ski: its not about if classes can emulate extensible records? 
17:02:53 <dataN> "abstract" meaning the function definition is not provided in the class definition 
17:03:36 <hpc> jollygood2: if i was writing your thing myself, i would have a parser :: Text -> ParsedAd
17:03:43 <ski> dataN : jollygood2 started wondering if type classes could get them were they wanted, but we're thinking that they may be overkill / inappropriate for their usecase
17:03:57 <dataN> sorry, oop isnt familiar terminology 
17:04:08 <hpc> jollygood2: and then some functions that extract the info you want from those
17:04:24 <hpc> and then maybe you'd have a list of one type of ad, a list of another type, etc
17:04:30 <ski> (i haven't seen an indication of extensible records being needed, yet)
17:04:43 <hpc> or maybe you'd put them all together, and have extractInfo :: ParsedAd -> SomeAd
17:04:58 <hpc> data SomeAd = AdTypeOne ... | AdTypeTwo ... | ...
17:05:19 <hpc> depending on if i need to treat them heterogenously after i have done the initial parsing
17:05:27 <dataN> wasnt there talk of web page formats yet to be encountered needing to be incorperated into a datatype?
17:05:28 <ski> they seemed to want to be able to add new kinds of ad, without having to change the basic ad type
17:05:49 <ski> which suggest a record of methods may be appropriate, to me
17:05:53 <dyl> ^
17:06:11 <hpc> ah right
17:06:14 <hpc> forgot that part
17:07:09 * ski awaits some feedback from jollygood2
17:07:14 <dataN> maybe an open type family?
17:07:28 <dyl> dataN I think you're perusing a wonderful collection of sledgehammers...
17:07:36 <dyl> but in the end the shed just needs to be nailed together.
17:07:37 * ski smiles
17:07:52 <hpc> dyl: what i am hearing here is...
17:07:56 <hpc> impredicative types :D
17:07:56 <jollygood2> in a dynamically typed OOP language I could have, for example, BaseAd, RealEstateAd, which extends Base ad, and ads things common to different kinds of real estates. then I'd have specific real estate ads, ApartmentAd, HouseAd, which extend RealEstateAd. the point of having concrete types is to be able to fetch all the different fields in the ads i am fetching, and then display them in a table, that dynamically generates column
17:08:04 <dataN> AdTypeN is not the worry?
17:08:29 <hpc> in a dynamically typed language you don't really have any of those types at all :P
17:08:40 <dyl> well, you do, just at runtime.
17:09:02 <ski> well, you do, just in your head
17:09:56 <jollygood2> that dynamically generates columns based on the available fields of the found ads
17:09:58 <dyl> Picture yourself in a boat on a river, with tangerine types and marmalade kinds. 
17:10:03 <jollygood2> the only way I can think of getting the same type of flexiblity in haskell, is to have something like this data FieldValue = String String| Double Double | Int Int. and then  data Ad { fieldName :: String, fieldValue :: FieldValue }.. but that is kind of horrible
17:10:06 <dataN> jollygood2: your describing a class hierarchy? 
17:10:09 * ski . o O ( <https://www.youtube.com/watch?v=6Ejga4kJUts> )
17:10:10 <dyl> Somebody calls you, you return quite slowly. A call-site with kaleidoscope eyes.
17:10:39 <hpc> jollygood2: so you have some operation with the type, Ad -> Row
17:10:46 <jollygood2> dataN yes
17:11:04 <hpc> jollygood2: instead, make that row a field in the Ad record
17:11:15 <hpc> and write a row type that's maybe just Map String String
17:11:21 <hpc> name of column mapping to value in cell
17:11:31 <hpc> then write showTable :: [Row] -> Text
17:11:45 * hpc is mixing String and Text, it's late :P
17:11:58 <ski> jollygood2 : perhaps you could include a method in `BaseAd' which already generates the table .. hmm
17:12:16 <dyl> tbh I'd probably just add vinyl to my requirements and get on with it
17:13:19 <dyl> (another sledgehammer :p)
17:14:09 <jollygood2> hpc hmm interesting. What would Ad be, a record of functions? And I'd convert each concrete ad type to Ad?
17:14:17 <jollygood2> dyl vinyl?
17:14:19 <dyl> http://hackage.haskell.org/package/vinyl-0.10.0/docs/Data-Vinyl-Tutorial-Overview.html
17:14:30 <dyl> A way to do records.
17:14:42 <dyl> Only requires about a dozen extensions to be enabled!
17:14:55 <jollygood2> or is Ad the type I defined above
17:14:55 <dataN> dyl: can that work with yahb?
17:15:09 <dyl> ¯\_(ツ)_/¯ 
17:15:14 <dyl> I don't know much about yahb.
17:16:13 <dataN> % :m Data.Vinyl 
17:16:13 <yahb> dataN: ; <no location info>: error:; Could not find module `Data.Vinyl'; Perhaps you meant Data.Kind (from base-4.12.0.0)
17:16:28 <dataN> >:|
17:16:40 <dyl> it looks like this would be a decent fit jollygood2 
17:17:05 <dyl> It seems to me that the actual class hierarchy of Ads isn't actually too important in of itself. 
17:17:21 <dyl> For example, you might actually only care about whether an ad contains a field "IsRent" and "RentAmount". 
17:18:50 <dyl> data AdFields = Name | Address | Unit | PropertyManager | Brokerage ...; type ApartmentAd =  [Name, Address, Unit, PropertyManager]; type HouseAd = [Name, Address, Brokerage]
17:18:51 <ski> jollygood2 : `BaseAd'/`Ad' would be the record of methods
17:19:55 * ski thinks jollygood2 should probably play around with ordinary records before trying to tackle vinyl
17:20:06 <dyl> ski yeaaaaaah
17:20:32 <dyl> vinyl is most certainly among the sledgiest of hammers. 
17:21:04 <dyl> Four year first-string varsity sledge on the hammer team, if you will.
17:25:07 <sleepster> is there a recommended dev environment for beginners? Should I just use vi/emacs + stack?
17:33:44 <mud> sleepster: I quite like whatever random editor and slack, sure. You can get quite far that way.
17:33:57 <mud> There's fancier setups, but they tend to be annoying to keep maintained.
17:34:35 <MarcelineVQ> any old editor with haskell language highlighting and ghci/ghcid will get you far
17:37:04 <sleepster> :) thanks
17:38:57 * ski used Notepad and WinHugs at home
17:54:54 <Average-user> I implemented some parallel functions in my program, and indeed the performance changed, but negatively. But whats weird is that when doing profiling the log says that only one processor
17:55:09 <Average-user> was used
18:01:10 <suzu> you compiling with -threaded?
18:02:28 <c_wraith> did you generate way too many sparks, such that the overhead of coordinating them exceeded any parallel speedup?
18:04:14 <Average-user> I compiled with -threaded
18:04:23 <Average-user> and yeah probably I did
18:04:55 <Average-user> but thats not the point, I know it can be hard to find where to parallelize, but what I found weird is that profiling tells me that I onle used 1 processor
18:06:46 <c_wraith> it's possible that things went the other direction, and you had a data dependency between each calculation, so no sparks ever managed to start
18:06:58 <Average-user> mhh
18:07:00 <c_wraith> that can happen with laziness
18:08:20 <Average-user> I think I'll try something simple and see if profiling works
18:09:32 <dataN> did you use real processors?
18:10:16 <Average-user> I'm not sure
18:10:39 <Average-user> Intel(R) Core(TM) i5-4300U CPU @ 1.90GHz
18:11:10 <Average-user> not sure what all this information means: CPU(s):              4
18:11:10 <Average-user> On-line CPU(s) list: 0-3
18:11:10 <Average-user> Thread(s) per core:  2
18:11:10 <Average-user> Core(s) per socket:  2
18:11:13 <Average-user>  
18:11:47 <dataN> maybe there is some way to use haskell with hardware abstraction?
18:12:33 <dataN> for benchmarking multi-core programs on one cpu like you describe  
18:13:56 <dataN> Average-user: hmm, thats fine.
18:16:06 <dataN> to examine the delay of the latency of communicating between processes
18:16:17 <dataN> processors* 
18:17:44 <MarcelineVQ> Average-user: did you read that book I linked you on the subject?
18:18:58 <dataN> maybe by using the llvm instead of compiling to C? or maybe even a simple user defined bytecode/assembly 
18:19:15 <MarcelineVQ> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/pt01.html as a reminder
18:23:20 <dataN> maybe the parallelisation itself would not depend on the intermediate language used... 
18:24:33 <djtyml> hi all. I was tyring acid-state example and got error. No instance for (Control.Monad.Reader.Class.MonadReader FailureDb (Query FailureDb))    https://gist.github.com/f451f7687a738a141de5d0008f1b9035
18:25:02 <dataN> but what kind of instruction set should be made available? 
18:25:40 <dataN> (for benchmarking) 
18:26:07 <dataN> is there a system f compiler that could be used for this?
18:26:23 --- mode: glguy set +v djtyml
18:26:35 <glguy> Hi djtyml try again now
18:26:38 <djtyml> hi all. I was tyring acid-state example and got error. No instance for (Control.Monad.Reader.Class.MonadReader FailureDb (Query FailureDb))    https://gist.github.com/f451f7687a738a141de5d0008f1b9035
18:28:54 --- mode: glguy set +vv djtyml_ djtyml__
18:29:19 <greymalkin> djtyml: Is there a line number for that?
18:30:04 <djtyml__> 29 and 32
18:30:18 <greymalkin> Ah.. sorry, I didn't see the error below.
18:30:23 <dataN> djtyml: why expect those instances to work, there is no implementation of them
18:31:27 <Average-user> MarcelineVQ: I've not. But right now I'm trying to figure out why is profiling showing that just one processor is used
18:31:52 --- mode: glguy set +v djtyml
18:35:28 <rotaerk> I read that as "one professor"
18:35:32 <rotaerk> had a double-take
18:38:17 * ski . o O ( multi-core professors )
18:54:26 <greymalkin> Average-user: Have you added +RTS -N2 to the arguments?
18:55:08 <greymalkin> If I recall, just compiling with -threaded doesn't determine how many cores to use.
18:58:41 <Average-user> greymalkin: thats what I'm looking now
19:00:03 <Average-user> That was it
19:00:10 <Average-user> Thanks
19:00:54 <Average-user> I read that -NX wasn't exactly the amount of processors I have
19:01:09 <Average-user> How can I know whats the maximum X in my computer?
19:14:11 <geekosaur> -N without a number "should" figure that out
19:14:59 <geekosaur> the real answer is rather more complicated, in particular because some workloads get worse if you spread them over too many processors (this is not a flaw in the runtime, it's that this is quite a complex subject that doesn't lend itself to simpleminded answers)
19:21:44 <Average-user> geekosaur: When I leave it with -N, onle uses 1 processor
19:21:49 <Average-user> don't know hy
19:21:50 <Average-user> why*
19:22:35 <geekosaur> having trouble imagining that you're running a ghc old enough to have that behavior. what kind of system are you on and how did you install ghc?
19:23:29 <ktonga> is there a recommended set of flags and options to set for libs, exes and tests?
19:24:26 <monochrom> I don't even believe that this can be diagnosed without seeing a single line of actual code.
19:24:44 <ktonga> im looking at ghc options docs and it's kinda infinite :P
19:24:56 <geekosaur> hm, that too, if you're doing the wrong thing then it will look like there's only one processor in use
19:25:00 <glguy> ktonga: You don't need to specify any options
19:25:09 <ktonga> so -Wall is pretty obvious 
19:25:44 <geekosaur> ktonga, if there were a recommended set then it'd be packaged. like, say, -O which means a bunch of different options. and the optimizations it doesn't include are situational, so would not be "recommended set"
19:25:45 <ktonga> that's why i asked for a recommended set :)
19:25:55 <ktonga> ok
19:26:06 <glguy> flags are for overriding the recommended defaults
19:26:06 <monochrom> Yeah there is none. I even recommend against -Wall.
19:26:43 <ktonga> but if i dont add -threaded i get a node.js app?
19:27:06 <monochrom> Clearly, there is no way you can write in Haskell and get a node.js app.
19:27:29 <MarcelineVQ> though you do get some interesting things out of ghcjs
19:27:58 <geekosaur> -threaded picks a runtime, there are often reasons for this that can't be packaged. (for example, no X11 GUI does threading well, so not using -threaded is generally a good idea for such)
19:28:18 <ktonga> ok so w/o -threaded i've still got concurrency but not reall parallelism?
19:28:43 <ktonga> real*
19:29:09 <monochrom> I'm going to be blunt and say I doubt your program needs real parallelism.
19:29:30 <geekosaur> there's only one "Haskell thread" (the runtime uses additional threads for various things). which can be necessary if you are using some C APIs, or things like X11 which are inherently single-threaded (unless you make each thread an independent X11 connection, but that compliates interoperability between them)
19:29:34 <monochrom> Probability that a randomly chosen stranger programmer can actually write such a program is like 0.001%.
19:29:38 <ktonga> any web app can benefit from parallelism
19:30:20 <monochrom> No, you are confusing problems with attempted solutions.
19:30:25 <ktonga> oh that's for OS level thread
19:30:33 <ktonga> no haskell green threads 
19:30:34 <MarcelineVQ> Average-user: I'm of the radical opinion that knowing what's going on is more useful than diagnosing what's going on, and still recommend reading the parallel half of that book which takes you through why things behave how they do and what makes up the machinery you're trying to use
19:30:38 <geekosaur> but you may be asking what I suspect is Average-user's question, after a fashion. (a) parallelism is not a magic way to speed up every possible application (b) and if you don't do it right, in a lazy language you may spawn a bunch of threads that pass thunks back that all get forced by the main thread, net gain 0
19:30:56 <monochrom> Many problems can benefit from parallelism. Many attempted solutions fail to.
19:31:23 <geekosaur> but there's lots of people who are convinced that you can parallelize 2+2 effectively. and at least as much poor attempts to parallelize things that can
19:31:39 <geekosaur> be
19:33:08 <monochrom> In the particular case of web apps, 99.99% of programmers write their web apps that use mutable global states. Therefore their web apps actually become flawed under parallelism. Or concurrency. Or any hot word of the day.
19:33:47 <ktonga> i dont have any, yet
19:33:52 <monochrom> But I had matrix multiplication and the like in my mind a few minutes ago.
19:34:08 <ktonga> i just do some kafka and postgres stuff per each request 
19:34:34 <ktonga> so i guess they can easily run in different cpus at the same time
19:34:48 <monochrom> The problem of matrix multiplication is really nice to be solved by parallel algorithms. Now ask actual programmers to code up actual algorithms. Most of them are unparallizable.
19:35:04 <monochrom> So this is what I mean by confusing problems with attempted solutions.
19:35:51 <geekosaur> postgres stuff may well be run by a separate process. regardless of what you do, since you're sending things to a database engine that is running in one or more separate processes from yours
19:36:54 <monochrom> The bottleneck is postgres. It doesn't matter that you have 1000000 Haskell threads.
19:37:22 <ktonga> sure
19:37:52 <ktonga> if io is not blocking like in jdbc :) i'm ok
19:38:05 <monochrom> This is best understood by considering how McDonald's offers mobile online ordering so 50 customers can place orders in parallel, and yet the kitchen only has two frying devices.
19:39:45 <ktonga> i understand concurrency vs parallelism, what im not familiar with is how things work in haskell regarding that
19:40:09 <monochrom> My friend puts it very pinpointingly. "You're just moving the queue around."
19:40:22 <MarcelineVQ> in addition to 2 friers they also have a seperate pay and pickup window, another useful lesson being that building up serivces of multiple smaller concurrency's can have a good overall improvement
19:40:31 <dmj`> ktonga: what you want is an embedded db that uses mmap’d files that has non-blocking reads. Postgresql might cache some things for you, but it isn’t embedded and needs intelligent indexing
19:41:09 <geekosaur> @where parconc
19:41:10 <lambdabot> https://web.archive.org/web/20180117182938/http://chimera.labs.oreilly.com/books/1230000000929/index.html
19:41:33 <monochrom> Yeah for a fundamentally sequential process, your best strategy is pipelining.
19:41:44 <MarcelineVQ> geekosaur: if it matters the modern link is https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
19:42:05 <geekosaur> @where+ parconc https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
19:42:05 <lambdabot> Good to know.
19:42:33 <geekosaur> anyway that's (supposed to be) a freely available ebook about parallelism and concurrency in haskell
19:42:50 <ktonga> yeah has been in my to-read list since forever, i guess it's time
19:43:25 <monochrom> Why aren't you concurrentizing your to-read list already?!
19:43:27 <MarcelineVQ> usefully even if one has 0 interest in ever doing parallel or concurrent things, the book is worth reading
19:43:56 <ktonga> i wasn't compiled with -threaded (?)
19:43:58 <MarcelineVQ> due to the term explanations, learning mechanics of things, and program examples
19:44:51 <ktonga> i'll read it right away
19:46:36 <ktonga> i even made my company buy a copy a few weeks ago
20:11:52 <Average-user> MarcelineVQ: I also have that opinion, I just wanted to make sure that my environment is working as it shoulf before start trying the book examples. Don't think thats a crazy idea, don't know about you
20:12:22 <MarcelineVQ> I think all you guys are crazy crazy crazy all the time :>
20:12:49 <Average-user> Thats proabably true
20:24:26 <maerwald> is there documentation about how to add a builtin rule in shake?
20:56:59 <arahael> I want to eventually write some tests where I want to demonstrate that randomAst -> Print -> Parse == original randomAst.  What do I read to find out how to do this? I assume that quickcheck is the tool for this?
20:58:12 <arahael> I don't use the IO monad at all for this.
20:59:25 <c_wraith> quickcheck definitely works for that.
20:59:34 * arahael reads wiki.haskell.org/Introduction_to_QuickCheck1 - it does indeed look like what I need.
20:59:38 <c_wraith> You tell it how to build a random AST
20:59:43 <arahael> c_wraith: Awesome, thanks for the confirmation.
20:59:46 <c_wraith> then you give a function AST -> Bool
20:59:59 <c_wraith> And it generates a bunch of ASTs to see if the property holds for all of them
21:00:02 <arahael> c_wraith: Is it possible for it to generate the random AST for me? Given their types?
21:00:43 <c_wraith> Well, you have to give it a description of how to randomize the type.  But then it takes care of creating all the instances that it tests with
21:01:14 <arahael> It's a fairly large AST, it would be amazing if it could be done magically.
21:01:19 <c_wraith> You would do that by making an Arbitrary instance for your type
21:01:48 <arahael> The AST is about a hundred lines or so of type declarations.
21:02:02 <c_wraith> Eh, you probably want to have some manual control, or else it will create trees that are so deep that the tests take forever to run
21:02:26 <arahael> Hmm, good poit.
21:02:50 <c_wraith> But if you want to see what you can do automatically, there are libraries like https://hackage.haskell.org/package/generic-arbitrary
21:03:04 <arahael> I suppose I shouldn't complain, it's already vastly more concise than I would have achieved in any other language.
21:03:11 * arahael checks out generic-arbitrary.
21:04:06 <arahael> That looks ideal.
21:04:24 <c_wraith> hopefully it even creates things of reasonable sizes. :)
21:04:41 <arahael> Heh, I guess I'll find out, once I get to it. :)
21:07:57 <arahael> SEriously impressed at how nice it is to develop in Haskell.
21:11:49 <blankhart> using the streaming library, once i have a "Stream (Stream (Of a) m) m r" how do i turn that into a "Stream (Of [a]) m r"
21:20:57 <blankhart> withdrawn, figured it out
21:24:25 <arahael> what was it?
21:36:50 <blankhart> the answer to my question?  Streaming.mapped Streaming.Prelude.toList
21:37:48 <blankhart> the documentation oscillates between qualified and unqualified imported functions and i got confused
21:57:19 <arahael> Feels like there is a more generic answer to that.
23:06:59 <dminuoso> Is there an extension that would enable me writing this? https://gist.github.com/dminuoso/e456b7d68709b98d78008ff84e1a04ad
23:08:22 <dminuoso> I have a sum type of about 100 constructors (with an additoinal 150 to come), and it's starting to get a bit weird.
23:08:43 <glguy> Template Haskell, GHC.Generics
23:10:05 <dminuoso> glguy: Ive been avoiding TH to keep the code accessible and readable mmm.
23:10:38 <dminuoso> glguy: My point is not as much the repeating theme, in my code there's some difference depending on the constructor - I just want to interleave serialize/deserialize like that
23:11:09 <glguy> Ok you can use TH for that too
23:13:01 <cocreature> dminuoso: if you don’t like TH, use generics?
23:13:55 <dminuoso> cocreature: How exactly do I use generics to achieve this?
23:14:35 <cocreature> GHC.Generics might make it a bit painful but it should be fairly straightforward using generics-sop
23:15:05 <MarcelineVQ> 250 constructors sounds like a lot for generics, dunnno the current state of it tho
23:15:10 <glguy> https://gist.github.com/dminuoso/e456b7d68709b98d78008ff84e1a04ad#gistcomment-2693954
23:15:53 <dminuoso> glguy: Ohh cool, that explains it - I was not aware you could quote an entire instance declaration!
23:15:58 <dminuoso> Yes that will be the way. :)
23:16:01 <glguy> Oh, actually TH might validate that and reject it too early...
23:16:12 <dminuoso> :(
23:17:55 <glguy> This one would be more doable https://gist.github.com/dminuoso/e456b7d68709b98d78008ff84e1a04ad#gistcomment-2693955
23:18:12 <glguy> You'd need a separate declaration quote per constructor
23:47:59 <Axman6> dminuoso: doesn't the derived Enum instance give you thi already?
23:48:42 <dminuoso> Axman6: The example might be too simplistic. My goal is just to interleave two function/method declarations.
23:49:04 <Axman6> right
23:53:28 <kosmikus> dminuoso: if the goal is just the interleaving, then why not define one method for each constructor that does both, of type (a -> Int, Int -> a), and have serialize and deserialize just select the right component?
23:54:39 <dminuoso> kosmikus: Because one does not simply walk into Emacs and come up with the simple solution!
