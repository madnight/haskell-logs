00:00:33 <maerwald> depends on the program
00:01:59 <maerwald> mostly nothing is easy in haskell, especially writing large programs or trying to use unmaintained bindings to things that work better in other languages
00:02:09 <maerwald> only thing that is quite easy in haskell is refactoring
00:04:51 <maerwald> if you are lucky that what you are trying to do has proper ecosystem support in haskell and your project is probably long-maintenantance, then sure
00:08:18 <maerwald> most people have little awareness of the link between language and language ecosystem and that they effect each other in real-world :o until they actually try to write large programs :)
00:08:52 <TommyC> <unpopular opinion>everyone should learn & use asm (even if just a little) at least once</unpopular opinion>
00:09:09 <kuribas> TommyC: not unpopular AFAIK?
00:09:14 <maerwald> would you do your VR stuff in haskell? or even something simpler like useful image processing?
00:09:27 <maerwald> probably not, C++ libraries are better
00:09:29 <TommyC> kuribas: I get a lot of shit for that in other places...like workplaces.
00:09:45 <kuribas> maerwald: http://hackage.haskell.org/package/hip
00:09:59 <maerwald> kuribas: have you actually used it?
00:10:14 <kuribas> TommyC: because you break their idea that they can do anything in javascript?  :-P
00:10:17 <kuribas> maerwald: no
00:10:20 <maerwald> ...
00:11:15 <kuribas> TommyC: same about algorithmic complexity I guess.
00:11:51 <kuribas> TommyC: a lot of people think it's not necessary, because you use libraries.  Then they loop over a linked list by index :-)
00:12:19 <TommyC> kuribas: Don't even get me started on that
00:12:31 <TommyC> Java has a [] operator for linked lists and so many people I knew used that.
00:12:56 <TommyC> I'm glad enterprises will probably move away from Java starting in January.
00:13:24 <cocreature> I highly doubt that :)
00:13:47 <TommyC> well the new license is very deterring
00:14:02 <kuribas> towards what?
00:14:12 <TommyC> kuribas: Who knows...hopefully haskell. :3
00:14:36 <maerwald> lol
00:14:41 <TommyC> But dat new January 2019 license doe
00:15:00 <maerwald> haskell has only "industry" support for backend and some web stuff
00:15:11 <kuribas> really unlikely
00:15:42 <TommyC> kuribas: As long as they move away from Java because that license makes them pay $$ just to use it in the enterprise, I'm ok with it.
00:15:56 <kuribas> asking a mainstream programmer to use emacs is already to much.
00:16:05 <maerwald> why would you?
00:16:07 <TommyC> kuribas: Only if you don't let them use evil mode.
00:16:08 <maerwald> except for trolling
00:16:32 <kuribas> java has some nice tooling that haskell lacks
00:16:47 <TommyC> maerwald: vim struggles with large files (try opening a file larger than the amount of RAM you have available)
00:16:56 <maerwald> TommyC: what?
00:16:57 <TommyC> emacs doesn't open the entire file into memory iirc
00:17:05 <kuribas> TommyC: do you have +8GB files?
00:17:30 <TommyC> kuribas: yeah but they're binaries
00:17:34 <maerwald> well, editor trolling incoming
00:17:40 <TommyC> hex editing is a *****
00:18:00 <TommyC> but my point about the large files (and large projects too if you try to open multiple files) still stands
00:18:16 <maerwald> yes, only emacs works correctly...
00:18:26 <maerwald> no other editor does, everyone should use emacs
00:18:34 <TommyC> no, but it can handle large files better than vim can
00:18:38 <kuribas> well, mainstream people expect something like intellij
00:18:38 <maerwald> people who don't know emacs are not smart enough
00:18:46 <maerwald> so mainstraim people!
00:18:56 <TommyC> kuribas: vim has autocomplete plugins and emacs does too
00:18:58 <maerwald> you're just being elitist :P
00:19:06 <TommyC> maerwald: How so? I use vim 99% of the time.
00:19:13 <kuribas> maerwald: I mean people who only want to do the job, not learn more about it.
00:19:32 <kuribas> not have some pride in it.
00:19:40 <TommyC> maerwald: and idk what you mean by "know emacs". If you mean keybindings, I don't know the default emacs keybindings either. I use evil mode if I'm using emacs.
00:19:47 <maerwald> pride is the worst at workplace
00:20:48 <kuribas> maerwald: if it is misplaced yes
00:21:33 <maerwald> it starts with feeling superior
00:21:56 <kuribas> maerwald: sure
00:22:22 <TommyC> You can have pride in a project you and your team finished.
00:22:29 <TommyC> Nothing wrong with that imo.
00:22:29 <kuribas> but having some pride or satisfaction that you did a good job, write nice code is good.
00:22:51 <maerwald> And people experience that with any language.
00:22:53 <maerwald> Including java
00:23:08 <glguy> This conversation is off the rails, right?
00:23:13 <kuribas> yes
00:23:15 <TommyC> yep
00:23:31 <glguy> Ok, just making sure we all agreed
00:23:54 <kuribas> My point is that for haskell to become interesting for the mainstream, it has to have better tooling.
00:24:07 <maerwald> That too
00:24:13 <maerwald> but that's just a tiny part of the problem
00:24:22 <maerwald> it's more ecosystem in general
00:24:41 <maerwald> game developers won't switch to a nice language if they have to use half-assed bindings and lack tons of support, libraries and whatnot
00:25:08 <maerwald> it's just too risky and not worth
00:26:57 <Ke> everyone here writes their own editors using the wonderful yi editor library
00:27:12 <Ke> that has asymptotically superior performance in editing
00:32:16 <kuribas> Ke: anyone uses yi?
00:32:40 <Ke> it is at least being developed
00:33:12 <Ke> I maintain a yi config, but not the default editor now
00:33:23 <maerwald> leksah used to have a yi flag, but last time I tried it didn't compile
00:46:32 <haasn> sigh, why does the tuple in `Wire` have to be the wrong way around from `modifyMVar` :(
00:46:46 * hackage proto-lens-protoc 0.3.1.2 - Protocol buffer compiler for the proto-lens library.  http://hackage.haskell.org/package/proto-lens-protoc-0.3.1.2 (JudahJacobson)
01:03:17 * hackage debian-build 0.10.1.2 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.10.1.2 (KeiHibino)
01:14:53 <ZeuPiark> hello
01:36:52 <safinaskar> is this possible to "run" entities of kind "Constraint" in ghci, such as "Num Int"?
01:36:55 <safinaskar> :k Num Int
01:36:56 <lambdabot> Constraint
01:37:19 <safinaskar> when I type ":k Num Int" in ghci, ghci just says that "Num Int" is Constraint
01:37:26 <olligobber> I believe Constraints don't exist at runtime
01:37:36 <safinaskar> but how to see, is it true Constraint or false?
01:37:45 <olligobber> :k Num String
01:37:46 <lambdabot> Constraint
01:37:47 * hackage text-ldap 0.1.1.13 - Parser and Printer for LDAP text data stream  http://hackage.haskell.org/package/text-ldap-0.1.1.13 (KeiHibino)
01:37:53 <safinaskar> i. e. I want ghci to output to me "true" or "false"
01:38:02 <safinaskar> olligobber: i agree
01:38:26 <safinaskar> olligobber: but types and kinds don't exists in runtime, too. yet ghci is able to print them
01:38:51 <olligobber> safinaskar, you can use :info to see information about a type
01:38:54 <lavalike> what makes this work? first:   type AppMonad m = (MonadIO m, MonadState GameInfo m)   then:   action :: AppMonad m => m ()
01:39:21 <olligobber> that includes which typeclasses it is in, so you could check if Num is in the list
01:42:04 <safinaskar> :info Num Int
01:42:20 <haasn> > () :: Num String => ()
01:42:22 <lambdabot>  error:
01:42:23 <lambdabot>      No instance for (Num String)
01:42:23 <lambdabot>        arising from an expression type signature
01:42:47 * hackage nirum 0.4.0 - IDL compiler and RPC/distributed object framework for microservices  http://hackage.haskell.org/package/nirum-0.4.0 (hongminhee)
01:43:06 <safinaskar> olligobber: thanks
01:43:17 * hackage json-rpc-generic 0.2.1.5 - Generic encoder and decode for JSON-RPC  http://hackage.haskell.org/package/json-rpc-generic-0.2.1.5 (KeiHibino)
01:43:23 <safinaskar> olligobber: it works
01:43:45 <olligobber> haasn, smart
01:44:47 * hackage nirum 0.5.0, nirum 0.4.2, nirum 0.4.1 (hongminhee): https://qbin.io/looked-garmin-nhsa
01:46:40 <safinaskar> haasn: thanks, it works, too
01:48:25 <lavalike> is it an extensions that lets one use they 'type' keyword that way?
01:50:57 <cocreature> lavalike: yeah you need ConstraintKinds for this to work
01:52:01 <lavalike> «Allow types of kind Constraint to be used in contexts.»
01:52:55 <lavalike> I didn't know about the kind "Constraint"
01:54:15 <lavalike> interesting, is Constraint used elsewhere or is it just for this?
01:55:19 <ski> it can be used to define data types (or classes) taking constraints or classes as arguments
01:57:32 <ski> like `data Constr c = c => MkConstr' where a value of type `Constr (Eq a)' (e.g.) contains a constraint `Eq a'. that way you can return constraints from functions
01:59:25 <kuribas> :t fail
01:59:27 <lambdabot> Monad m => String -> m a
01:59:48 <kuribas> hmm, I thought it was a separate class...
02:19:20 <maerwald> how do you set AR when configuring the ghc bindist?
02:28:16 <lavalike> ski: fun!
02:58:50 --- mode: glguy set +v Andras
03:00:46 <Andras> I pretty new to haskell, I have been writing some haskell code, but cannot set up HUnit (Installed it with cabal). I wrote some tests but cannot run them. Does someone has a good link?
03:04:35 <pavonia> Andras: Probably best to prepare a paste with some sample code and the error you run into
03:07:12 <Andras> I have this in a file named gol.test.hs
03:07:14 <Andras> import Test.HUnit  test1 = TestCase (assertEqual "for (foo 3)," (1,2) (foo 3)) test2 = TestCase (do (x,y) <- partA 3                      assertEqual "for the first result of partA," 5 x                      b <- partB y                        tests = TestList [TestLabel "test1" test1, TestLabel "test2" test2]
03:07:18 <Andras> wooo
03:07:25 <Andras> anyway, legit looking test
03:07:30 <dminuoso> Andras: You might want to use gist or some paste service instead :)
03:07:39 <Andras> ghc gol.test.hs
03:07:42 <Andras> yep
03:07:44 <Andras> 1 sec
03:10:26 <Andras> https://pastebin.com/qc2duMMc
03:10:35 <Andras> I have described everything here
03:10:49 <Andras> Ive read like 15 google results
03:13:26 <safinaskar> i think haskell has huge design bug. consider this:
03:13:26 <safinaskar> type SS = ExceptT String (ExceptT String Identity) -- compiles
03:13:26 <safinaskar> test6 :: SS ()
03:13:26 <safinaskar> test6 = throwError "string" -- compiles (why?!)
03:13:28 <safinaskar> This is impossible to tell what means "throwError" here. Whether it correspond to first ExceptT or to second one. So, the compiler simply seem to decide that it refers to first one without any reason.
03:13:32 <safinaskar> So, am I alone who thinks this is a bug? Are there some blog posts etc about this? Maybe some proposals etc?
03:14:56 <Andras> hmm let me try this
03:15:05 <dminuoso> safinaskar: So take a deep breath before you barge in and consider some issue a haskell design error.
03:15:18 <dminuoso> safinaskar: Consider for a second how throwError *works*
03:15:21 <dminuoso> :t throwError
03:15:22 <lambdabot> MonadError e m => e -> m a
03:16:48 <dminuoso> safinaskar: Simply by type unification it determines that `e ~ String` and `m a ~ ExceptT String (ExceptT String Identity)`
03:17:12 <dminuoso> Heck not even type unification, this is just [App]
03:17:25 <rzmt> I'm trying to run multiple conduit streams in parallel. How would i add concurrency here so that i have multiple fetchConduits consuming values from the stream at the same time? https://paste.pound-python.org/show/cDnRPpXcMqW6LyhY2e6D/
03:18:15 <dminuoso> safinaskar: So now GHC has an obligation to prove `MonadError String (ExceptT String (ExceptT String Identity))`
03:19:06 <dminuoso> safinaskar: It will then look around and see that `mtl` has some instance: Monad m => MonadError e (ExceptT e m)
03:19:13 <dminuoso> and it will use that instance.
03:19:48 <dminuoso> Which it does after proving that `Monad (ExceptT String Identity)` is satisfies
03:21:16 <int-e> "and it will use that instance" -- it also checks that this the only matching instance.
03:21:45 <pavonia> Andras: You never close the opening parenthesis of line 11
03:22:51 <pavonia> Andras: Also consider using "TestCase $ ..." instead of "TestCase ( ... )"
03:23:23 <int-e> safinaskar: the point is that there is no MonadError e m => MonadError e (ExceptT e m)  instance. Most of the other mtl classes are lifted that way, for example, there is an instance MonadIO m => MonadIO (ExceptT e m).
03:24:28 <Andras> hmm
03:24:32 <Andras> I got another error
03:24:38 <int-e> safinaskar: So you might get the impression that all operations are lifted from the inner monad, but that's really not the case. It's also worth noting that you can access the inner throwError using 'lift (throwError e)'.
03:26:08 <Andras> https://pastebin.com/48MWC2QH
03:26:22 <dminuoso> • Could not deduce (Monoid (NonEmpty Schema.InputObjectFieldDefinition)) arising from a use of ‘<>’
03:26:25 <dminuoso> What the heck is going on there?
03:26:37 <dminuoso> :t (<>)
03:26:39 <lambdabot> Monoid m => m -> m -> m
03:26:44 * dminuoso scratches his head
03:26:51 <dminuoso> Shouldn't that be a Semigroup constraint?
03:27:17 <Andras> I might just go and learn clojure
03:27:26 <pavonia> Andras: What's unclear about the error message?
03:27:29 <Andras> this language has such a bad ecosystem errors
03:27:39 <Andras> its horros compared to mainstream stuff
03:27:45 <Andras> horror*
03:28:23 <Andras> removed the tests
03:28:29 <Andras> I have a simple assertion
03:28:30 <Andras>  The IO action ‘main’ is not defined in module ‘Main’
03:28:33 <Andras> I get this
03:28:35 <Andras> WTF
03:28:46 <ski> getting errors while coding is normal. it's not uncommon, at least for some stuff, for the code to just work, once the type-checker is satisfied
03:29:00 <Andras> I tought scala build tool is bad
03:29:24 <dminuoso> Andras: The quality of diagnostics is usually very good, it just takes more practice to read and understand because of some factors.
03:29:48 <Andras> Is there someway that I can start doing some TDD with haskell
03:30:04 <dminuoso> Andras: You should probably get a good grip on the haskell basics first.
03:30:10 <Andras> I have spent like 3 hours trying to set up a unit testing environment
03:30:21 <dminuoso> Andras: Test frameworks make heavy use of certain idioms you should be familiar with first.
03:30:28 <Andras> I usually write siple stuff with tests to learn a new language
03:30:38 <Andras> simple*
03:31:10 <__monty__> I agree, TDD is very different in Haskell. Most of the things you'd write simple tests for in other languages are caught by the type system or can't happen because of purity.
03:31:31 <Andras> I mean I just want some assertions for my expressions
03:31:45 <Andras> BUt probably I can write something for that
03:31:51 <ski> perhaps you'd be interested in learning QuickCheck
03:32:10 <int-e> "type driven development" seems more appropriate in Haskell :)
03:32:48 <Andras> hahha
03:32:48 <__monty__> I'd suggest doctest but I'm not sure how easy it is to use: http://hackage.haskell.org/package/doctest
03:33:11 <ski> you write general properties, like e.g. `reverse (reverse xs) == xs' (reversing a list twice gives back the original list), and it randomly generates lists to put in `xs', and checks that you get `True' for your property for each generated value of `xs'
03:34:00 <__monty__> While I agree QuickCheck is a really good tool for TDD in Haskell I'm not sure it's any easier than HUnit. So I don't see it helping.
03:34:44 <Andras> Thanks guys! Ill write a tuple list with a (function to test,output) put them in a list and and go through it
03:35:02 <Andras> I think its a decent solution
03:37:25 <dminuoso> :i (<>)
03:37:34 <dminuoso> % :i (<>)
03:37:34 <yahb> dminuoso: class Semigroup a where; (<>) :: a -> a -> a; ...; -- Defined in `GHC.Base'; infixr 6 <>
03:38:04 <dminuoso> :t (<>)
03:38:06 <lambdabot> Monoid m => m -> m -> m
03:38:06 <dataN> does DefaultSignatures give rise to the concept of classes that cant both be instantiated?
03:38:14 <ski> @index (<>)
03:38:14 <lambdabot> Data.Monoid, Text.PrettyPrint.HughesPJ, Text.PrettyPrint.HughesPJClass, Text.PrettyPrint, Language.Haskell.TH.PprLib
03:38:15 <__monty__> Andras: Yes, I think most people just write and run stuff in ghci while learning, so that's definitely not worse. You can get into the various testing frameworks once you feel somewhat comfortable with the language.
03:39:30 <Andras> tbh my idea is just to do some prectise and learn the language to get better at programming in general
03:40:24 <Andras> I think haskell can give you a pretty good FP mindset
03:40:34 <ski> using the interactor isn't bad for (emphemeral) tests
03:40:43 <__monty__> Part of that can be learning about quickcheck though : )
03:41:00 <dataN> i.e. those that are neither Undecidable or Overlapping, but which through presence in a class as defaults would throw an error if both instantiated, or would that throw an error when trying to define the defaults?
03:41:07 <dminuoso> ski: Oh it seems that base had a different signature for this in base 4.10
03:41:13 <ski> for (more or less) repeatble ones, you want some testing framework like unit tests or QuickCheck
03:41:17 <dminuoso> https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Monoid.html#v:-60--62- 
03:41:21 <dminuoso> This is annoying. :(
03:41:22 <ski> dminuoso : *nod*
03:41:51 <Andras> Ive seen quick check in real life haskell
03:42:01 <Andras> ill check it out
03:42:14 <ski> Andras : it can sometimes be mindbending, even frustrating, but, imho, the reward is great
03:42:38 <dminuoso> ski: The reward is greatest when you (successfully) employ the Feynman algorithm.
03:42:41 <Andras> Zea thas why im kinda doing it
03:42:49 <Andras> y*
03:43:13 <ski> keep in mind that learning a different programming paradigm is a bit like learning to program from scratch all over again
03:43:45 <dminuoso> ski: I still smile thinking back when you had me figure out a type safe Y combinator.
03:43:50 <dminuoso> About 4 weeks into the language.
03:44:00 <dminuoso> Recursive types completely twisted my mind.
03:44:44 <ski> dminuoso : you hadn't used them in C or whatever, before ?
03:45:13 <ski> oh, the `Santa' type
03:45:15 <Andras> ski: Yea, I kinda know it :)  Altough Im pretty familiar with currying, ref transparency, immutability
03:45:20 <dminuoso> ski: Yes. ;)
03:45:32 <dminuoso> ski: And no, I never encountered it before.
03:45:33 <Andras> ski: I just wanna see what a purely functional language is like
03:45:38 <ski> Andras : they you have a good start :)
03:45:46 <ski> s/they/then/
03:46:06 <dminuoso> Andras: What makes Haskell special, is that it's also *lazy*
03:46:21 <ski> stricly speaking, non-strict
03:46:35 <lavalike> ha
03:46:39 <ski> most implementations implement non-strictness by laziness
03:46:40 <Andras> Im smelling some inside jokes hahahaa
03:46:58 <liste> ski: what other implementations are there?
03:46:59 <dminuoso> ski: I was trying to be not so strict.
03:47:18 <ski> liste : Hugs was popular when i started learning Haskell
03:47:30 <liste> ski: I mean for non-strictness
03:47:48 <ski> there are a couple of others, like UHC, LHC, JHC
03:48:31 <ski> liste : well there is (was ?) some experimental implemental with implicit paralellism, speculative evaluation. that's definitely distinct from plain laziness
03:48:41 <Andras> btw guys do you use FP at your dayjob? or do you just hack java/c#/javascript aswell?
03:48:42 <ski> s/tal/tion/
03:49:05 <dminuoso> Andras: Ive started to push Haskell into our company.
03:49:14 <dminuoso> Successfully. :)
03:49:55 <Andras> niice, for some backend algorithms?
03:49:56 <dataN> getting the error "Duplicate default type signatures"
03:50:11 <ski> liste : where you can speculatively evaluate some subcomputations, on available cores, that you think might be needed soon, taking care not to let exceptions percolate and abort the computation
03:50:26 <dminuoso> Andras: For some REST APIs, household scripting jobs, data processing.
03:50:35 <dminuoso> Network services
03:51:05 <osa1> if I duplicate a Handle with hDuplicate and then hSeek on one of the Handles does the index in the other Handle also change?
03:51:17 <dminuoso> dataN: Can you gist your code together with the error?
03:51:46 <dataN> sure
03:51:49 <rzmt> dminuoso: neat, care to share what frameworks have you been using for rest APIs?
03:51:51 <Andras> dminuso: I can see its nice for data processing but the other stuff can be done easily with any other tool, also it kinda makes your code untouchable for the uninitiated
03:52:04 <Andras> tools*
03:52:10 <maerwald> are there pre-packaged cabal-install binaries for different GHCs?
03:52:18 <dminuoso> rzmt: servant
03:52:39 <dataN> dminuoso: https://lpaste.net/5959691392954400768
03:53:17 <int-e> osa1: I think yes, according to the documentation: http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-IO-Handle.html#v:hDuplicate
03:53:37 <dminuoso> Andras: That holds true for programming in general.
03:54:28 <Andras> Well I think most OOP languages are pretty simial
03:54:33 <Andras> similar*
03:54:40 <dminuoso> Andras: I agree, most of them are close copies of another.
03:54:47 <dminuoso> With just some subtle changes in semantics.
03:56:12 <dminuoso> Andras: To me I value the high quality ecosystem of haskells packages. They are usually well written and very well documented. Then we find that Haskell is much faster to write correct code in. It's easier to reason about code.
03:56:53 <Andras> dminuso: Hmm I never heard haskell has a high quality ecosystem
03:57:19 <Andras> dminuso: also the documentation seems pretty poor compared to js/java/c#
03:57:27 <liste> ski: sounds really interesting, I wonder if those ideas will be integrated to mainstream later
03:57:53 <dminuoso> Andras: We have a unified place called hackage in which all repositories together with their haddock documentation is listed.
03:58:14 <dminuoso> Andras: All public API is, at least, documented by means of its type which generally can tell you a lot.
03:58:30 <dataN> this also does not work: https://lpaste.net/5644304277892497408
03:58:47 <mniip> dataN, not supposed to
03:59:42 <cocreature> you can’t have more than one default signature
03:59:44 <dminuoso> dataN: You should really not use OverlappingInstances as a module pragma by the way.
03:59:57 <dminuoso> dataN: It's a great way to get incoherent programs.
04:00:18 <dataN> was just following this; https://stackoverflow.com/questions/10015009/fun-with-types-resolving-multiple-instance-declarations
04:00:41 <dataN> but it does not extend to DefaultSignatures 
04:01:28 <dataN> the application is; instance (Exists i,Exists (i -> x)) => Exists x
04:02:29 <dataN> the idea is that if more than one trivial superclass exists, then it can be written using that
04:03:45 <dataN> and then there should be some way of choosing which to use
04:04:08 <cocreature> DerivingVia helps somewhat for the case where you want to have multiple default signatures
04:04:53 <dataN> is there an example of that which compiles?
04:05:26 <cocreature> DerivingVia will only be in GHC 8.6 which isn’t released yet
04:05:43 <cocreature> if you grab the rc you should be able to compile the examples from the proposal
04:12:33 <dataN> what if it was; forall (a::k) (i::k->*) (x::k->*). (Exists (i a),Exists (i -> x)) => Exists (x a)
04:12:44 <dataN> that wouldnt work with DerivingVia?
04:13:17 <dataN> (class Exists x where exists :: x) 
04:13:54 <dataN> oops, that is missing 'instance' ... 
04:14:04 <dataN> before the forall
04:14:28 <dataN> if thats even possible, anyway, the forall is not required
04:15:38 <dataN> and possibly it needs; forall a. Exists (i a -> x a)
04:17:17 * ski . o O ( s/Exists/Inhabited/ ? )
04:20:31 <dataN> here, like this; https://lpaste.net/3912101520253911040
04:22:03 <dataN> cocreature: would that work with DerivingVia?
04:22:46 * ski idly wonders what the point of this is
04:23:57 <cocreature> dataN: I have no idea what you are trying to do. there are no default signatures in that snippet
04:24:54 <ski> @type let foo :: forall a. f a -> (forall b. f b -> g b) -> g a; foo fa fg = fg fa in foo
04:24:55 <lambdabot> error: Not in scope: type variable ‘f’
04:24:56 <lambdabot> error: Not in scope: type variable ‘f’
04:24:56 <lambdabot> error: Not in scope: type variable ‘g’
04:25:11 <ski> @type let foo :: forall f g a. f a -> (forall b. f b -> g b) -> g a; foo fa fg = fg fa in foo
04:25:12 <lambdabot> forall k (f :: k -> *) (a :: k) (g :: k -> *). f a -> (forall (b :: k). f b -> g b) -> g a
04:41:35 <Andras> :t replicate
04:41:36 <lambdabot> Int -> a -> [a]
04:49:20 <liste> :t genericReplicate
04:49:21 <lambdabot> Integral i => i -> a -> [a]
04:53:22 --- mode: glguy set +v Andras_
04:53:22 <Andras_> https://pastebin.com/QGvvLn7N
04:53:33 <Andras_> success with my miniframework
04:53:55 <Andras_> ski, dminuso
04:54:03 <Andras_> what do you guys think?
04:55:30 <ski> Andras_ : if you use `all' instead of `map', then you get a single `Bool', rather than a list of them
04:55:45 <ski> otoh, then if one test fails, you don't see which of them it was
04:56:35 <Andras_> ski: I see it as it gives back a bool list
04:56:42 <ski> instead of `\(o,r) -> o == r', one could say `uncurry (==)'. up to you which you consider more readable
04:57:43 <Andras_> hmm I have to google uncurry
04:57:58 <ski> in `shapeArea' and `getDescendingColumns', you could use pattern-matching rather than `if'-`then'-`else'
04:58:21 <ski> @type uncurry
04:58:22 <lambdabot> (a -> b -> c) -> (a, b) -> c
04:58:53 <ski> `uncurry' converts a function taking two arguments, curriedly, into one taking them in a pair instead
05:00:02 <ski>   shapeArea 1 = 1
05:00:03 <ski>   shapeArea n = getDescendingColumns (n*2 - 1) + getDescendingColumns ((n - 1)*2 - 1)
05:00:06 <ski> like that
05:00:16 <ski> one case for `1', one case for anything else
05:01:20 <ski> oh, also
05:01:42 <ski>   runTests ors = map (\(o,r) -> o == r) ors
05:01:49 <ski> can be "abreviated" as
05:01:55 <ski>   runTests = map (\(o,r) -> o == r)
05:02:22 <Andras_> but how does it know that im waiting for a param<?
05:02:29 <ski> because after giving `map' a function on elements, it returns back a function (on lists), which you can directly name `runTests'
05:02:47 <Andras_> Ill look into these stuff and upload an updated version in the evening
05:02:57 <Andras_> Are you guys usually here>
05:03:19 <ski> defining `foo x = (...) x', where `...' is an expression that returns a function (and doesn't depend on `x' is the same as defining `foo = ...'
05:04:30 <ski> this is called function extensionality : a function is determined (only) by what outputs it gives for each possible input. so the two definitions of `foo' (or `runTests') define equal functions, functions that behave the same when called with an argument, which is all that matters for "identity of functions"
05:04:51 <ski> Andras_ : i'll probably be here in the evening, i suppose
05:04:58 <Andras_> runTests'' = map (\(o,r) -> o == r)
05:05:02 <Andras_> this doesnt work tho
05:05:19 <Andras_> Ambiguous type variable ‘a0’ arising from a use of ‘==’
05:05:19 <Andras_>       prevents the constraint ‘(Eq a0)’ from being solved.
05:05:31 <ski> did you supply a type signature ?
05:05:43 <Andras_> nope
05:06:10 <Andras_> okey
05:06:13 <Andras_> works now :D
05:06:16 <Andras_> thanks!
05:06:30 <ski> you're running into an annoying "feature" often known as DMR, the Dreaded Monomorphism Restriction. it can be turned off if you put at the top of your source file :
05:06:32 <Andras_> Ill look into pattern matching later on, only used it in sacal yet
05:06:45 <ski>   {-# LANGUAGE NoMonomorphismRestriction #-}
05:07:03 <ski> or, if you supply a type signature, it won't trigger either
05:07:38 <Andras_> thank you ^^
05:08:01 <Andras_> be back in the evening guys
05:08:46 <ski> briefly speaking, when using type class overloading, a definition can't use sharing of results, and the designers of Haskell thought that this might be confusing to newbies, therefore the language refuses to overload a definition without function parameters (functions won't be shared anyways), unless you specify a type signature (thus knowingly getting no sharing)'
05:09:09 <ski> arguably, the DMR, intended to reduce confusion for newbies, is confusing in itself
05:09:51 <ski> @where DMR
05:09:52 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
05:09:58 <ski> has some more info
05:10:07 <ski> Andras_ : have fun
05:22:01 <a_nick> Hey so can I chain data types together? I'm a total noob, working with something like this https://codeshare.io/5D7Ejk , but I get the error that it can't match the expected type Size/Color with actual type Char. I can see how that's happening, but I don't know how to convert from char into Size/Color, or if this is the totally wrong road to be on
05:25:39 <liste> a_nick: make functions to convert from char to Size/Color
05:25:55 <liste> (at this point, it's both safer and more educational than using "read")
05:26:11 <a_nick> yeah I'd run across Read but just ended up more confused
05:26:25 <liste> parseSize :: Char -> Size
05:26:35 <liste> parseColor :: Char -> Color
05:26:45 <a_nick> right
05:26:46 * hackage potoki-core 2.2.8.2 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.2.8.2 (NikitaVolkov)
05:27:43 <liste> a_nick: you *could* also do "parseSize :: Char -> Maybe Size"
05:27:57 <ski> or maybe `parseSize :: Char -> Maybe Size', for then you need to handle errors when calling it
05:28:32 <a_nick> great minds think alike eh
05:28:59 <liste> a_nick: but at that point you need to either unwrap the "Maybe"s and build a 'pyramid' of error checking, or learn how >>= for Maybes work (it's probably too advanced at this point)
05:30:02 <ski> learning `case' could be useful
05:30:05 <liste> by an error checking pyramid I mean "case parseSize c1 of (Just size) -> case parseColor c2 of (Just color) -> ...; _ -> Nothing; _ -> Nothing
05:30:21 <liste> for 2 values it's OK though
05:30:34 * ski . o O ( s/(Just size)/Just size/ )
05:30:39 <liste> yeah
05:30:59 <ski> sorry, it's one of my pet peeves :)
05:45:20 <a_nick> ok I thought I could be cheeky and just have parseSize x = x, but clearly that isn't working
05:45:28 <a_nick> >.<
05:46:01 <a_nick> really don't want to be that guy who asks about every single little thing, but here I am!
05:51:57 <liste> a_nick: you need to implement each case separaterly
05:52:10 <liste> a_nick: note that 'L' ≠ L
05:52:20 <liste> two very different things
05:52:55 <a_nick> ah ok, so guards for each one?
05:53:15 <liste> a pattern for each noe
05:53:21 <liste> one*
05:53:24 <liste> no guards required
05:53:47 <a_nick> oh!
06:06:09 <Gurkenglas> % 2 + _ -- mniip, is this a bug?
06:06:13 <yahb> Gurkenglas: ; <interactive>:1:1: error:; GHC internal error: `Ghci1.it' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []
06:24:17 * hackage publicsuffix 0.20180825 - The publicsuffix list exposed as proper Haskell types  http://hackage.haskell.org/package/publicsuffix-0.20180825 (wereHamster)
07:08:22 <dataN> cocreature: the problem is when two classes have the same trivial superclass. 
07:11:20 <dataN> is that when to use DerivingVia? 
07:16:16 <dataN> otherwise, it seems to make sense to make a class containing a function from the class defining functions of the class to those of its trivial superclass. Then, this can be instantiated for both target classes alongside the trivial superclass
07:18:17 * hackage protocol-radius 0.0.1.1 - parser and printer for radius protocol packet  http://hackage.haskell.org/package/protocol-radius-0.0.1.1 (KeiHibino)
07:28:17 * hackage termonad 0.2.1.0 - Terminal emulator configurable in Haskell  http://hackage.haskell.org/package/termonad-0.2.1.0 (cdepillabout)
08:59:51 <texasmynsted> anybody use emacs and have a nice whitespace mode setup for haskell?
09:37:21 <dminuoso> :k TypeError
09:37:22 <lambdabot> *
09:37:30 <dminuoso> % :i TypeError
09:37:30 <yahb> dminuoso: newtype TypeError = TypeError String -- Defined in `Control.Exception.Base'; instance Show TypeError -- Defined in `Control.Exception.Base'; instance Exception TypeError -- Defined in `Control.Exception.Base'; instance AsTypeError TypeError -- Defined in `Control.Exception.Lens'; instance (t ~ TypeError) => Rewrapped TypeError t -- Defined in `Control.Lens.Wrapped'; instance Wrapped TypeError -- Defin
09:37:37 <dminuoso> % import GHC.TypeLits
09:37:38 <yahb> dminuoso: 
09:37:39 <dminuoso> % :i TypeError
09:37:40 <yahb> dminuoso: type family GHC.TypeLits.TypeError (a :: ErrorMessage) :: b -- Defined in `GHC.TypeLits'; newtype Control.Exception.TypeError = TypeError String -- Defined in `Control.Exception.Base'; instance Show Control.Exception.TypeError -- Defined in `Control.Exception.Base'; instance Exception Control.Exception.TypeError -- Defined in `Control.Exception.Base'; instance AsTypeError Control.Exception.TypeErro
09:41:05 <[exa]> guys guys
09:41:47 <[exa]> is there some haskell alternative to ImGui here https://github.com/ocornut/imgui ?
09:42:34 <[exa]> (esp. regarding the "immediate mode" style of UI design)
09:56:06 <cocreature> [exa]: afaik there isn’t
09:57:39 <cocreature> I thought about writing bindings at some point
09:58:44 <dminuoso> for imgui?
09:59:01 <cocreature> yes
10:04:39 <hpc> that would be nice
10:17:27 <[exa]> cocreature: there are internally pointers to data, everything would need to be a MVar or something. 
10:33:54 <cocreature> [exa]: in the low-level bindings you just use Ptr and then you try to come up with some nice Haskell API on top of that
10:40:31 * [exa] thinking about ways of squashing the imgui stuff to monads
10:41:51 <[exa]> state+lens would be nice if someone rewrote the whole imgui to haskell
10:44:01 <maerwald> everything has to be a monad these days
10:49:49 <maerwald> monadTransformerFactory
10:50:03 <maerwald> industrialMonadFramework
10:50:15 <[exa]> IMonad
10:51:01 <maerwald> maybe we are where Java is with design patterns
10:51:48 <maerwald> except our misdesigns are intellectually more complex, so they give an illusion of superiority?
10:53:36 <[exa]> well yeah, but try looking at the C++ code from imgui without imagining a DSL for it
10:54:05 <hpc> just use templates
10:54:13 <hpc> that's never caused problems before
10:57:54 <royal_screwup21> trying to find all strings of a certain length like so: https://thepasteb.in/p/Rghn14G9rJ0Tz I'm getting a not in scope error  - how do I fix this? :)
10:58:31 <hpc> @hoogle String -> Int
10:58:32 <lambdabot> System.Console.ANSI cursorUpCode :: Int -> String
10:58:32 <lambdabot> System.Console.ANSI cursorDownCode :: Int -> String
10:58:32 <lambdabot> System.Console.ANSI cursorForwardCode :: Int -> String
10:58:39 <hpc> that's completely backwards!
10:58:42 <hpc> royal_screwup21: you want length
10:58:59 <c_wraith> that's...  a really poor result from hoogle
10:58:59 <Pepe_> Anybody ever tried to install matterhorn (https://github.com/matterhorn-chat/matterhorn/) ? I get different levels of failure when I try to compile it myself (./install.sh) with ghc 8.4.3-1 on Arch. Anybody has experience building it?
10:59:21 <c_wraith> Pepe_: ....  are you using arch's ghc install?
10:59:50 <Pepe_> c_wraith, yes. Also tried ghc-static fwiw, I also get errors, different ones
10:59:59 <c_wraith> arch breaks ghc badly.
11:01:25 <hpc> at the risk of being the "just use stack" guy, this does seem like something it would solve rather cleanly
11:01:27 <c_wraith> Hmm.  a former coworker of mine is one of the main contributors to that
11:01:46 <Pepe_> c_wraith, any idea how to build all that? apparently Arch packages use runhaskell with a Setup.lhs that imports Distribution.Simple
11:03:00 <maerwald> c_wraith: just a reflection of arch packaging in general
11:03:09 <maerwald> although I haven't looked how exactly they break ghc
11:06:43 <Pepe_> Any idea what I can use then to build that thing
11:08:36 <royal_screwup21> Couldn't match expected type ‘[String] -> Int’
11:08:36 <royal_screwup21>                 with actual type ‘Int’ -- what does this mean? :)
11:09:19 <royal_screwup21> I'm writing a function that takes in a list of strings and returns an int https://thepasteb.in/p/NxhV8kVVLOmuN
11:09:48 <c_wraith> royal_screwup21: in all likelihood, the next line of the error message says something about not providing enough arguments to a function
11:10:20 <c_wraith> Oh.  that's actually too many arguments
11:10:28 <royal_screwup21> ah here's the full traceback: https://thepasteb.in/p/Y6hkqVk6BNrt7
11:10:44 <c_wraith> you're providing 3 arguments to max
11:11:06 <royal_screwup21> ah
11:11:24 <royal_screwup21> need to put the brackets, got it
11:11:24 <c_wraith> fwiw, I'd change your base case to [] instead, too
11:11:40 <royal_screwup21> yup makes sense
11:13:55 <ab9rf> it's probably reasponable to make your base case 0 on the empty list
11:14:43 <c_wraith> yeah, given that the inputs to max will always be non-negative, 0 is an identity
11:15:08 <royal_screwup21> what would you guys say is the best way to learn haskell? I'm just trying out various kinds of exercises right now
11:15:21 <ab9rf> royal_screwup21: the only way to learn a programming language is to program in it
11:15:30 <maerwald> @cis194
11:15:30 <lambdabot> Unknown command, try @list
11:15:35 <maerwald> @where cis194
11:15:35 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
11:15:41 <maerwald> royal_screwup21: ^
11:15:48 <ab9rf> i hear those are good exercises
11:16:42 <ab9rf> i remember writing a mastermind game in prolog about 30 years ago
11:16:46 * hackage validity-bytestring 0.4.0.0 - Validity instances for bytestring  http://hackage.haskell.org/package/validity-bytestring-0.4.0.0 (Norfair)
11:16:58 <dyl> I need to learn me some Prolog properly,
11:17:02 <dyl> hm.
11:17:13 <ab9rf> i'm certain that i never learned prolog properly
11:17:21 <ab9rf> i totally suck at prolog
11:17:33 <dyl> I’d like to propose an extension to Greenspun’s Tenth Law.
11:17:49 <dyl> That any sufficiently complex compiler contains a bug ridden and incomplete implementation of Prolog.
11:17:54 <ab9rf> hehe
11:18:17 * hackage genvalidity-hspec-optics 0.1.0.0, genvalidity-bytestring 0.3.0.0, validity-vector 0.2.0.2, validity-uuid 0.1.0.2, validity-unordered-containers 0.2.0.2, validity-time 0.2.0.2, validity-text 0.3.1.0, validity-scientific 0.2.0.2, validity-primitive 0.0.0.0, validity-path 0.3.0.2 (Norfair)
11:18:46 * hackage genvalidity-text 0.5.1.0 - GenValidity support for Text  http://hackage.haskell.org/package/genvalidity-text-0.5.1.0 (Norfair)
11:20:08 <dmiles> dyl: see decription @ https://github.com/TeamSPoon/wam_common_lisp 
11:27:47 * hackage Prelude 0.1.0.0 - A Prelude module replacement  http://hackage.haskell.org/package/Prelude-0.1.0.0 (HerbertValerioRiedel)
11:39:12 <rzmt> i copy pasted the example here but the lines do not get printed atomically, am i missing something? http://hackage.haskell.org/package/pipes-concurrency-2.0.11/docs/Pipes-Concurrent-Tutorial.html#g:2
11:40:27 <glguy> rzmt: Hard to say; put the code you pasted together on gist.github.com so we can see what you did?
11:42:32 <rzmt> glguy: i hope this works https://paste.pound-python.org/show/vMzb3OBYq0HrUn2q3dM3/
11:43:04 <rzmt> Running main prints unreadable lines, unlike in the example
11:43:41 <dyl> dmiles: 👍
11:45:05 <glguy> rzmt: works for me
11:45:12 <glguy> so something's going on in your local environment
11:45:33 <glguy> maybe paste the actual output you're getting so someone can help. I'm on my way out the door
11:47:18 <rzmt> Thanks anyway glguy. I get this output in ghci https://paste.pound-python.org/show/LhJlhqmRHo63SL0Q43hb/
11:52:02 <glguy> rzmt: that's just interleaving the outputs
11:52:17 <glguy> Maybe you ran it with the threaded runtime
11:52:39 <glguy> Or from ghci where output isn't buffered
11:54:40 <rzmt> Ok, i'll see if i find something
12:14:02 --- mode: glguy set +v romanix
12:14:12 <romanix> Is there a way to catch multiple exception types in Haskell? I would like to catch my custom exception but also have a separate handler for any other exception (SomeException presumably).
12:14:42 <dmwit> rzmt: If you don't like the output being interleaved, you can have a single thread be in charge of printing stuff and have other threads send it messages to print via a Chan or similar.
12:14:52 <dmwit> romanix: Sure, call `catch` twice.
12:15:05 <dmwit> catch (catch act handler1) handler2
12:17:54 <romanix> Of course! Thanks dmwit.
12:21:28 <Pepe_> c_wraith, I'm curious to hear what's broken on Arch btw, wrt. the ghc package. I just had a look and there's nothing fancy it. Sources come from downloads.haskell.org, configures and builds, no patches
12:23:16 * hackage stitch 0.6.0.0 - lightweight CSS DSL  http://hackage.haskell.org/package/stitch-0.6.0.0 (Intolerable)
12:31:52 <glguy> Pepe_: it doesn't install the static libraries, but static linking is the standard way to compile Haskell
12:33:19 <Pepe_> https://git.archlinux.org/svntogit/community.git/tree/trunk/PKGBUILD?h=packages/ghc so I just have to install ghc-static as well?
12:34:51 <rzmt> dmwit: that's a good tip. I'm trying to handle big csv in streaming fashion while doing the processing with concurrency. I'm a bit unsure if pipes-concurrency is best tool for this.
12:40:35 <dmwit> I can never remember the default fixity. Would be nice if ghci would print it every time as a reminder.
12:41:40 <dmwit> romanix: Anyway it occurs to me that since the default fixity is left-associative, you could also write ```act `catch` handler1 `catch` handler2``` which you might find more aesthetically pleasing in some cases.
12:42:23 <romanix> dmwit, That's exactly what I did. Cheers. :)
13:09:16 * hackage purescript-iso 0.0.1.2 - Isomorphic trivial data type definitions over JSON  http://hackage.haskell.org/package/purescript-iso-0.0.1.2 (athanclark)
13:21:23 --- mode: glguy set +v guessWho
13:24:47 <MarcelineVQ> you guys are great
14:14:50 <pikajude> are cabal new-build and Setup.hs mutually exclusive?
14:15:39 <sclv> No
14:15:48 <sclv> New-build works with custom setupsn
14:29:23 <ChaiTRex> Why do types like Int define their own versions of typeclass functions? For example, both minInt and minBound are defined.
14:31:34 <dolio> Are there rewrite rules involving minInt?
14:32:53 <nitrix> I have never heard of minInt.
14:33:05 <nitrix> Which package is that?
14:34:09 <pikajude> oh
14:34:12 <pikajude> i see
14:34:35 <nitrix> I just checked and Data.Int provides the Int type as well as a Bounded Int instance but nothing else.
14:34:37 <dolio> Apparently it's defined in GHC.Base, which is prior to Enum existing.
14:34:52 <dolio> In the graph of modules.
14:35:05 <dolio> So presumably that's the reason.
14:36:52 <ChaiTRex> Oh, OK.
14:37:06 <ChaiTRex> Thanks.
14:37:17 <dmwit> ChaiTRex: Independently of the module ordering, it is frequently handy to have more-monomorphic versions.
14:37:33 <dmwit> e.g. using `map` or `(.)` instead of `fmap` tells the reader some intent.
14:38:13 <dmwit> And can guide type inference in certain cases, so e.g. `[minBound ..]` on its own is probably an ambiguous type error but but `[minInt ..]` wouldn't be.
14:38:55 <nitrix> :t [minBound..]
14:38:56 <lambdabot> (Enum a, Bounded a) => [a]
14:39:30 <nitrix> > [minBound..]
14:39:33 <lambdabot>  [()]
14:39:39 <dmwit> nitrix: Try compiling `main = print [minBound..]`.
14:39:42 <nitrix> Default rules?
14:39:49 <dmwit> ExtendedDefaultRules
14:39:52 <ChaiTRex> dmwit: Ahh, that makes sense. Thanks.
14:39:52 <geekosaur> remember lambdabot and ghci both have Extended... that
14:40:23 <dolio> You might especially want to be monomorphic way in the guts of GHC, which is where minInt is.
14:40:42 <dolio> And not worry about whether minBound is doing what you want.
14:41:24 <ChaiTRex> It looks like Word8 defines its Ord operators as named functions it defines in Data.Word, which are INLINE[1]
14:46:17 * hackage mixpanel-client 0.1.0.0 - Mixpanel client  http://hackage.haskell.org/package/mixpanel-client-0.1.0.0 (domenkozar)
14:56:47 * hackage tidal 0.9.10 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.9.10 (AlexMcLean)
15:00:44 <hpc> oh! that's the dj thing someone mentioned a week ago
15:12:45 <Boarders> does anyone know the newtype that makes: type Blah a b = f a -> g b, a profunctor where f and g are functors
15:13:24 <phz_> I knew that :D
15:13:29 <phz_> but I can’t recall, sorry :(
15:17:33 <mnoonan> Boarders: looks like.. Biff? what the hell kind of name?!
15:17:35 <mnoonan> http://hackage.haskell.org/package/bifunctors-5.5.2/docs/Data-Bifunctor-Biff.html#t:Biff
15:17:50 <mnoonan> Biff (->), that is
15:18:08 <Boarders> lmao
15:19:01 <c_wraith> mnoonan: it's a joke based on Back to the Future
15:19:55 <dolio> No, "Biff" has something to do with 'bifunctor'.
15:20:10 <ab9rf> biff is a perfecly reasonable name
15:20:11 <dolio> Then it has an adjoint that they called "Tannen" as the joke.
15:20:26 <mnoonan> oh my
15:20:33 <nitrix> Biff inside, Tannen outside :p
15:20:34 <ab9rf> it's no worse than the Clown and Joker types
15:20:58 <nitrix> Clown left, Joker right :P
15:21:05 <ab9rf> stuck in the middle with you
15:21:19 <nitrix> I think they're great. Memorable :P
15:21:26 * mnoonan . o O (business, party, mullet)
15:23:09 <rfold> Is it possible to import a module for which I have only a .o file and a .hi file? I tried -i, but with -v it shows that GHC is only looking for .hs and .lhs files.
15:23:15 <ab9rf> haskell's got nothing on geneticists
15:24:01 <ab9rf> who have managed to name a gene that causes crippling deformities in children the "sonic hedgehog" gene. "I'm sorry, but your child has a defect in his sonic hedgehog gene, and that's why he can't sit up or eat on his own."
15:24:27 <mnoonan> they truly have mastered the art.
15:25:43 <MarcelineVQ> you could say the child is 'too slow' and that he should 'step it up'
15:28:08 <geekosaur> and they're still trying to figure out how to get out of their mess
15:28:22 <geekosaur> some own it, some try to hide it ("Shh"), etc.
15:28:33 <geekosaur> this is what happens when you decide to name something by asking your kids ;p
15:28:38 <rfold> Reading the separate compilation docs and observing the -v output, it seems as if --make is implied, but I'm not passing this option.
15:28:55 <geekosaur> --make has been defualt for years unless -c is specified
15:29:28 <rfold> Thanks, passing -c fixes it :D
15:29:55 <ab9rf> geekosaur: i heard about all this from a friend of mine who was a med student while my son was getting surgery to remove a cancer that ultimately traces to his own genetic abnormality
15:30:17 <ab9rf> geekosaur: at least my son's gene has a boring name (it starts wth R, ends with X, and has a bunch of digits in the middle)
15:30:36 <geekosaur> I heard about it when they first published. ("that'll end well...")
15:34:45 <dsal> Is there a way in general to indicate a test is slow and maybe shouldn't run every time?
15:35:07 <dsal> Using tasty with an hunit thing.
15:48:14 <dmwit> dsal: I solved this in pulp by making the slow-running test fire up some Bach fugues in your browser for you. =P
15:48:29 <dsal> ha
15:48:33 <dmwit> Unfortunately that code never hit github because I figured out how to make the test run faster instead.
15:49:16 <dsal> This particular test is "solves a particular hard problem and gets known answer X"  I'm trying to see if I can find something better on the left side of that.
15:50:09 <dsal> I may have instead found a bug.
15:50:24 <dmwit> So, less snarky: cabal does support having more than one test suite.
15:50:36 <dmwit> So you could have an "every time" suite and an "infrequent" suite.
15:51:09 <dmwit> And I don't know about tasty specifically but I suspect there is probably a way to select particular tests via command-line arguments.
15:51:23 <dmwit> (like, even if you put them in the same suite)
15:52:12 <dsal> Oh, an additional test makes a lot of sense.
15:52:26 <dsal> I clearly need to drink more liquid or something.  Brain not working well. heh
16:00:04 <wroathe> I'm working through Programming in Haskell, and question 3.5 asks "Why is it not feasible in general for function types to be part of the Eq class?" I'm sure there are many facets to this answer by I'm struggling to come up with a concrete argument for making functions part of Eq...
16:00:26 <dolio> For or against?
16:00:39 <wroathe> against, sorry
16:00:50 <wroathe> argument against making functions part of Eq*
16:01:09 <dolio> What would be your strategy for deciding equality of functions?
16:01:19 <wroathe> For pure functions, wouldn't it be possibly to prove that two functions are equivalent at compile time?
16:01:19 <jle`> wroathe: what would you define the behavior to be?
16:01:29 <jle`> wroathe: what do you mean by 'equivalent'?
16:01:31 <jle`> that's what we're asking
16:02:22 <jle`> also, what about functions that are not known at compiletime?
16:02:25 <dolio> Eq isn't about you proving things, either. It's about writing a function where you give it two things and it figures out if they're equal.
16:02:27 <wroathe> Well, in this case that for every possible input the outputs of both functions match
16:03:05 <jle`> wroathe: so you want ((+1) . (+2)) == (+3) to be true?
16:03:26 <wroathe> jle`: Yeah, I think that's what they're after
16:03:39 <jle`> how could you possibly implement that?
16:04:16 * hackage capnp 0.1.0.0 - Cap'n Proto for Haskell  http://hackage.haskell.org/package/capnp-0.1.0.0 (isd)
16:04:36 <wroathe> The runtime implementation for proving equality would never exit in that case, right?
16:04:47 <jle`> so you want x == y = (infinite loop) ?
16:04:59 <jle`> _ == _ = infinite loop
16:05:01 <wroathe> But at compile time you'd be able to determine that they're equivalent,r ight?
16:05:09 <jle`> how would you do that?
16:05:36 <zachk> wroathe, its a hard problem to decide function equivalence and its not generally decidable
16:05:40 <wroathe> Well, the root operation is (+) and (+) must equal (+), right?
16:05:40 * ski . o O ( Ever heard of the halting problem ? )
16:05:50 <MarcelineVQ> generally is the operative word involved here
16:06:05 <jle`> wroathe: sure, but what about things like ((+1) . (+2)) = (+3) ?
16:06:06 <hpc> fleeting thought: it would be nice if hackage had reverse dep search built in
16:06:26 <MarcelineVQ> hpc: yus
16:06:30 <dolio> Merge sort is equal to radix sort right?
16:06:52 <ski> @where revdeps
16:06:52 <lambdabot> <http://packdeps.haskellers.com/reverse>,<http://packdeps.haskellers.com/>,<http://www.yesodweb.com/blog/2011/02/reverse-packdeps>
16:11:41 <wroathe> jle`: Ah, just found this: https://en.wikipedia.org/wiki/Rice%27s_theorem
16:12:00 <wroathe> from this answer: https://stackoverflow.com/questions/1132051/is-finding-the-equivalence-of-two-functions-undecidable
16:13:29 <jle`> nice :)
16:14:41 <dolio> (==) isn't even given as much of a chance as you get in Rice's theorem, though.
16:14:42 <jle`> note that for enumeratable domains it's possible to define this sort of equality, given that the functions are total
16:14:50 <dolio> It just gets two functions that it can call.
16:15:03 <jle`> you can compare (Int -> Bool)'s by enumerating over all Int's
16:15:16 <jle`> for total functions, at least
16:15:26 <rotaerk> hmm I need to write a function with a signature like Eq a => [a] -> ([a],[Int]), where the resulting [a] is all the distinct values from the input list, and where the resulting [Int] is indices of every element in the input list, within the distinct list
16:15:45 <rotaerk> is there a good way to do this *without* resorting to mutable collections
16:15:45 <dolio> Semi-deciding is fair, I think. Pretty much nothing else is working for partial values.
16:15:57 <jle`> yeah, it's the same for [a]'s instance
16:16:27 <jle`> rotaerk: i'd probably make it [(a,Int)] instead
16:16:34 <jle`> oh wait
16:16:41 <jle`> i see
16:16:48 <jle`> yeah, it's kind of 'trivial' with Data.Set
16:17:29 <dolio> Is there a good mutable way with just the Eq constraint?
16:17:50 <jle`> @let distIx xs = let s = S.fromList xs in (S.toList s, map (`lookupIndex` s) xs)
16:17:52 <lambdabot>  .L.hs:180:48: error:
16:17:52 <lambdabot>      • Variable not in scope: lookupIndex :: t -> S.Set t -> b
16:17:52 <lambdabot>      • Perhaps you meant one of these:
16:18:05 <jle`> @let distIx xs = let s = S.fromList xs in (S.toList s, map (fromJust . (`S.lookupIndex` s)) xs)
16:18:06 <lambdabot>  Defined.
16:18:12 <jle`> > distIx "hello world"
16:18:14 <lambdabot>  (" dehlorw",[3,2,4,4,5,0,7,5,6,4,1])
16:18:36 * ski . o O ( "Rice's theorem for the Martin-Löf universe" by Martín Hötzel Escardó in 2012-02,2012-14-16,2014-08-21 at <https://www.cs.bham.ac.uk/~mhe/agda-new/RicesTheoremForTheUniverse.html> )
16:18:48 <rotaerk> this needs to be fast, because it'll be dealing with a list containing like... a million elements or something
16:19:00 <rotaerk> which is why I'm considering mutable collections
16:19:03 <jle`> are you saying that Set isn't fast enough to handle a list with a million elements?
16:19:20 <rotaerk> not exactly
16:20:06 <jle`> > S.length $ S.fromList [1..1000000]
16:20:08 <lambdabot>  error:
16:20:08 <lambdabot>      Not in scope: ‘S.length’
16:20:08 <lambdabot>      Perhaps you meant one of these:
16:20:12 <jle`> > S.size $ S.fromList [1..1000000]
16:20:15 <lambdabot>  1000000
16:22:56 <rotaerk> I didn't know about lookupIndex, though
16:24:06 <rotaerk> k, thanks; I'll try it this way and see if it's fast enough
16:26:15 <jle`> also if your items are finite itmight be better to just have a dense representation
16:27:18 <jle`> but yea lookupIndex is pretty fast in sets
16:28:14 <dmwit> (Even if `Set` didn't have that operation, you can use `traverse` and `State` to turn a `Map a ()` into a `Map a Int`.)
16:29:08 <ArahaelPi> Does Haskell have an operator that typically means "cast or convert"?
16:29:16 <dmwit> :t coerce
16:29:17 <lambdabot> error:
16:29:17 <lambdabot>     • Variable not in scope: coerce
16:29:17 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
16:29:24 <ArahaelPi> dmwit: As an operator.
16:29:24 <dmwit> :t Data.Coerce.coerce
16:29:24 <jle`> all operators are user-defined, fwiw
16:29:25 <lambdabot> Coercible a b => a -> b
16:29:36 <jle`> ArahaelPi: what do you mean by operator?
16:29:38 <dmwit> ArahaelPi: Well, then, `coerce`. ;-)
16:29:52 <ArahaelPi> jle`: Infix symbol, dmwit just as good as answered me. :)
16:30:09 <jle`> i wonder how that would be used, hm
16:30:10 <dmwit> I don't know what two arguments you're going to give it, tohugh.
16:30:12 <ArahaelPi> dmwit: Thanks. :)
16:30:21 <ski> coercing to a function type ?
16:30:26 <dmwit> I guess.
16:30:26 <jle`> ah yeah
16:30:33 <jle`> it'd be like a fancy ($)
16:30:38 <ArahaelPi> dmwit: Well, I'm making an AST, right now I call it `As`, but I wanted more inspiration as to operator symbols for it.
16:30:46 <dmwit> ::
16:31:03 <jle`> @let newtype Reader' r a = Reader' (r -> a)
16:31:04 <lambdabot>  Defined.
16:31:13 <jle`> @let ask' = Reader'
16:31:15 <lambdabot>  Defined.
16:31:29 <ArahaelPi> dmwit: You're suggesting :: for it? Intriguing.
16:31:34 <jle`> > ask' succ `coerce` (5 :: Int)
16:31:36 <lambdabot>  error:
16:31:36 <lambdabot>      • Variable not in scope: coerce :: Reader' a0 a0 -> Int -> t
16:31:36 <lambdabot>      • Perhaps you meant ‘coerced’ (imported from Control.Lens)
16:31:41 <jle`> @let import Data.Coerce
16:31:42 <lambdabot>  .L.hs:81:1: error:
16:31:42 <lambdabot>      Data.Coerce: Can't be safely imported!
16:31:42 <lambdabot>      The module itself isn't safe.
16:31:45 <jle`> :(
16:31:47 <ski> ArahaelPi : what should the two operands be ?
16:31:56 <dmwit> jle`: yahb is more permissive...
16:32:24 <ski> ArahaelPi : i think the `::' suggestion is under the assumption that the right operand is the type to coerce to
16:32:25 <ArahaelPi> ski: A value, and... It's type, which is why dmwit's suggestion is surprisingly good there, didn't think of using :: itself. (Does haskell even allow it?)
16:32:41 <jle`> note that :: in Haskell doesn't coerce anything
16:32:47 <jle`> so i don't think it would be a good analogy
16:32:47 <ski> > ((3 :: Int) :: Int) :: Int
16:32:48 <dmwit> Not coercion. Specialization only.
16:32:49 <lambdabot>  3
16:32:56 <ski> that's type ascription in Haskell
16:32:58 <dmwit> > (3 :: Int) :: Word8 -- not okay
16:33:00 <ArahaelPi> ski: Doesn't work in haskell though.
16:33:00 <lambdabot>  error:
16:33:00 <lambdabot>      • Couldn't match expected type ‘Word8’ with actual type ‘Int’
16:33:00 <lambdabot>      • In the expression: (3 :: Int) :: Word8
16:33:05 <jle`> yeah, :: doesn't do any coercion, so if you're using it for coersion, that'd be very confusing
16:33:09 <dmwit> > (3 :: Num a => a) :: Int -- yes okay
16:33:11 <lambdabot>  3
16:33:20 <ski> ArahaelPi : works, but does something different from coercion
16:33:27 <ArahaelPi> <interactive>:1:19: error: parse error on input ‘::’
16:33:32 <jle`> you can use :::
16:33:34 <rotaerk> jle`, what do you mean by dense representation here?
16:33:59 <jle`> rotaerk: sorry, i thought about it and i'm not sure anymore :)
16:34:03 <rotaerk> k
16:34:25 <jle`> but yeah, :: in Haskell doesn't coerce anything
16:34:27 <ArahaelPi> jle`: ::: works, thanks. :)
16:34:39 <jle`> do you really want specialization?
16:34:41 * ski would argue that there's an implicit specialization inbetween the two ascriptions in dmwit's last example
16:34:43 <dmwit> And cons in your AST should obviously be ::::
16:34:43 <ArahaelPi> jle`: And it's nicely distinct from ::, as well.
16:34:48 <rotaerk> the use-case of this is, given vertices, produce a list of vertices to add to the vertex buffer, and a list of vertex indices to add to the index buffer
16:35:04 <rotaerk> the bigass list of vertices is coming from a model file
16:35:11 <ArahaelPi> dmwit: The AST I have doesn't have cons, so that simplifies that bit. :)
16:35:39 * ski idly wonders what kind of language ArahaelPi is representing
16:36:12 <ArahaelPi> ski: Delphi.
16:36:30 <ski> as in the Pascal derivative ?
16:36:33 <ArahaelPi> Yep.
16:36:57 <ski> mhm, ic
16:37:14 <ArahaelPi> I couldn't find a haskell parser for it, so figured: Here's an opportunity!  Plus, I actually wanted it for work, so double win.
16:37:49 <ski> what's the concrete syntax in Delphi, then ?
16:38:03 <ArahaelPi> ski: "as".
16:38:29 * ski would probably go with `As', in that case, possibly used infix
16:38:56 <ArahaelPi> ski: Yeah, that's what I"ve done for now, and I'll probably stick with it.
16:39:17 <ArahaelPi> ski: Interestingly, I can represent the assignment *exactly*, as := :)
16:39:26 <ski> more obvious to later readers what's going on
16:39:52 <ski> unless you document clearly that it corresponds to `as'
16:40:01 <dmwit> Yes, I agree with ski.
16:40:16 <ArahaelPi> Yeah, I have started commenting my AST types for that reason.  You've convinced me to keep it as `As`
16:40:16 <dmwit> Clever is fun briefly. Unsurprising is usable forever.
16:40:24 <ArahaelPi> dmwit: Point!
16:40:48 <ArahaelPi> Gotta go, thanks for the discussion!
16:40:52 <ski> np
16:41:11 <nsnc> 6e736e63
16:41:35 <ski> hello, nsnc's cat
16:41:46 <nsnc> Oops
16:41:57 <MarcelineVQ> it's okay it shows up as ******** for other people
16:42:00 <nsnc> wrong channel. /shrug
16:42:47 <nsnc> 1 (853) 058-659
16:42:50 <dmwit> There's a channel where that was an intelligible, useful message?
16:43:11 <nsnc> Isn't that what off topic channels are for? 
16:43:36 * ski was also thinking it might be a hexadecimal address or datum
16:43:40 <MarcelineVQ> dmwit: nsnc is part of a botnet that became self-aware, the numerics are the language of that particular net
16:44:03 <nsnc> WHY DOES LITERALLY EVERYONE ACCUSE ME OF BEING A BOT?
16:44:13 <ski> we're all bots in here
16:44:17 <MarcelineVQ> embrace your lore
16:44:19 <nsnc> it is actually meaningful...
16:44:28 <nsncfriend> I'm a bot.
16:44:34 <ski> no shame in admitting it to yourself
16:44:43 <nsnc> This is the bot around here.
16:45:19 <nsncfriend> yup! nsnc isn't a bot.
16:45:25 <MarcelineVQ> @botsnack
16:45:25 <lambdabot> :)
16:45:55 <dmwit> http://www.smbc-comics.com/comic/captcha
16:46:17 * hackage util 0.1.11.0 - Utilities  http://hackage.haskell.org/package/util-0.1.11.0 (MatthewFarkasDyck)
16:46:29 <nsnc> Hmm
16:47:18 <nsnc> Anyway, I don't have anything on topic to say, so... Bye!
16:47:57 <MarcelineVQ> If you develop and interest in the haskell programming language be sure to drop back in, people are happy to help
16:48:20 <dmwit> > "\x6e\x73\x6e\x63"
16:48:22 <lambdabot>  "nsnc"
16:48:28 <dmwit> yessss
16:48:33 <dmwit> what do I win
16:48:51 <MarcelineVQ> home-made red sauce
16:49:46 * Clint squints.
16:50:17 <nsnc> dmwit: no... Wrong channel, remember?
16:50:27 <nsnc> Also, there's the phone number... /Shrug
16:50:36 <dmwit> Yeah, I haven't got the phone number part yet.
16:51:19 <dmwit> Closest I've gotten is an envoy of DC 15s.
16:51:37 <nsnc> MarcelineVQ: I use Haskell every once in a while. Mind you, I'm no Haskell master. However, if somebody would port pwntools to Haskell, I would use Haskell much more... :P
16:53:12 <nsnc> dmwit: if you really want some puzzles to work on, check out my puzzle website, not my wrong channel postings... :P
16:53:35 <dmwit> Nah. I've got plenty of fun programming puzzles that will actually get me something I want at the end. =)
16:53:42 <nsnc> Good.
16:53:52 <rotaerk> I like how the pwntools site calls it a "CTF framework" but doesn't say what a CTF framework is
16:54:26 <dmwit> CTF is a kind of puzzle/contest. Typically somebody exposes a computer with some kind of weird security vulnerability for you to find.
16:54:34 <rotaerk> k
16:54:41 <dmwit> If you find it, you can exfiltrate some data that lets you prove you found the vulnerability.
16:55:14 <nsnc> pwntools is the best framework out there for writing exploits for CTF chals.
16:55:15 <dmwit> This is a 0th approximation of the truth from somebody who's never participated in one, so remember your salt.
16:59:56 <hpc> i just got a simple synthesizer-alsa program sort-of-working on my laptop :D
17:00:08 <hpc> it behaves very poorly in ghci, but i think i will spend some time tomorrow refining it
17:03:38 <dmwit> hpc++
17:04:47 <hpc> with this, i have briefly touched on everything a pc game is supposed to be able to do, at some point or another
17:05:05 <hpc> open a window, draw a thing, take input from multiple sources, networking, and now sound
17:05:20 <MarcelineVQ> Have you failed to deliver on a basic promise?
17:05:30 <hpc> haha
17:05:44 <ab9rf> hpc: don't forget in-game purchases
17:06:06 <hpc> hpc-game will be DRM-free! https://en.wikipedia.org/wiki/Direct_Rendering_Manager
17:06:57 <hpc> ab9rf: incidentally i have done paypal integration before too
17:08:14 <dmwit> I don't see "ship a last-minute hack that everybody agrees is awful but does its job" in your list.
17:08:28 <dmwit> (You know about how the trains worked in Fallout 4...?)
17:08:38 <hpc> it's a tiny dude with a train-shaped hat
17:08:41 <hpc> running really fast
17:08:47 <hpc> bethesda code is the best
17:08:55 <dmwit> Agreed.
17:09:52 <hpc> my theory is a designer wanted a moving train, and the programmers said do it yourself we're busy screwing up shadow projection
17:10:25 <dmwit> We don't have any way to move props. But we do have this NPC scripting tool...
17:13:35 <ab9rf> i've never played fallout 4, but i have played skyrim, which is the same engine
17:13:38 <ab9rf> i can only imagine
17:14:54 <dmwit> Skyrim speedruns are hilarious. 90% staring at a wall, 9% flying through space at lightspeed, 1% punching dragons.
17:15:17 <MarcelineVQ> there's a 40% reloading saves in there
17:15:26 <dmwit> Oh yeah, I forgot that part!
17:15:39 <MarcelineVQ> it's the prereq for flying
17:44:09 <dsal> If I've got a simple stack project, I get test/Spec.hs and basic config there.  Doing the obvious thing to break that into two separate test runs doesn't work.  Suddenly complains the module name is incorrect.
17:44:51 <dsal> i.e., saw Main, wanted Spec.  Is there some kind of coupling between directories and modules?
17:46:05 <dsal> Hmm...  Yeah, even having the file there with no package.yaml changes causes compilation failure.  I guess I see what it's doing.
17:49:59 <droplet> I'm playing with type families and :kind! in ghci, is there some way I can see the 'evaluation steps' taken?
17:57:20 <dmwit> dsal: Yes, there is a coupling between filenames and module names.
17:57:35 <dmwit> dsal: You can decouple this a little bit with main-is: in the appropriate stanza of your cabal file.
17:57:35 <dsal> Is "just make a new directory" the best way to do this?
17:57:54 <dmwit> You can keep them in the same directory if you use main-is and neither needs to import the other.
17:58:05 <dmwit> droplet: I believe currently no.
17:58:37 <dsal> OK.  I'm going to try to figure out what this is in package.yaml
17:58:56 <droplet> dmwit: okay thanks
17:59:25 <dsal> package.yaml has a "main" thing, but that doesn't seem to do it.
18:00:05 <dmwit> droplet: :i on a type family name will show you what clauses there are, but you have to manually find the one that applies.
18:03:48 <MarcelineVQ> main-is  for testing is  Spec.hs  in a default stack project already. what is 'the obvious thing' you did? what did you type on cli to get your error? if you could you share your project structure in a git or something it may be more diagnosable
18:04:31 <dmwit> MarcelineVQ: He wants to have two test suites, one with main-is: Spec.hs and one with main-is: SomethingElse.hs.
18:06:43 <MarcelineVQ> isee
18:07:15 <MarcelineVQ> based on quick testing problem seems to be that package.yaml is adding Spec to the other-modules sections
18:07:40 <MarcelineVQ> remove the occurences of your respective main's name from other-modules in your cabal file
18:08:46 <MarcelineVQ> that is to say, for each test stanza you have make sure there isn't an erroneous addition to the other-modules section
18:12:20 <MarcelineVQ> I can only see this as an hpack bug or oversight in how it's including module names, the module listed in package.yaml's  'main:' has no business being added to the cabal stanza's "other-modules:" list
18:13:50 <dsal> MarcelineVQ: I did this, but initially without a new directory: https://github.com/dustin/numberpuzzle/commit/2bdbc99beac1e2a3aea46a2bf553dea370b9f233
18:14:19 <dsal> If Spec.hs and Slow.hs are in the same directory, I get the module errors.
18:16:10 <MarcelineVQ> further testing shows that I'm an idiot, it's being added correctly in a fashion. other-modules is automatically including whatever's in the test dir
18:17:03 <MarcelineVQ> this just happens to be wrong when the name doesn't match the module contents, I wonder if there's hpack syntax for exluding modules
18:17:58 <dataN> cocreature: https://lpaste.net/1296674897522589696
18:20:15 <MarcelineVQ> dsal: the issue that is happening is that the two tests are including everything in their source dir in other-modules,  https://github.com/sol/hpack#test-fields  
18:21:20 <MarcelineVQ> They excluse their "main:" but include everything else in that dir, this is a problem because they're each including a file in their other-modules who's name doesn't match its module Foo where
18:22:23 <dsal> I swear this used to work.  But I also come in and out of haskell too infrequently to retain state.
18:22:32 <MarcelineVQ> one easy fix is to use different dir/subdirs, another each fix is to use the cabal file directly so you get to decide what goes in the test stanzas other-modules sections, according to this doc another option is to use 'when' but idk how atm
18:23:04 <dsal> Oh, that's probably how I did it.  Most of my older projects didn't use package.yaml
18:23:32 --- mode: glguy set +v Guest76363
18:25:37 <MarcelineVQ> dsal: it's a little weird but just include  other-modules: ""  in your package.yaml's test sections for now
18:26:10 <MarcelineVQ> Of course if you add other modules this will need to be updated, but the automatic other-modules  adding is being too greedy
18:27:11 <dsal> Yeah, that seems to work.
18:27:19 <dsal> Thanks.
18:30:31 <MarcelineVQ> In a slightly smarter world hpack might examine all the main-is and exclude all of them from any other-modules section. Though I'm sure there's hidden issues there too
19:01:16 * hackage hoppy-runtime 0.5.1 - C++ FFI generator - Runtime support  http://hackage.haskell.org/package/hoppy-runtime-0.5.1 (khumba)
19:07:38 <dmrd_> is it possible to call GHCi from inside haskell? Trying to capture the output of its `:type` command
19:08:04 <dmrd_> note that I've already reviewed the GHC-as-a-library tutorial. That won't do. I need to call GHCi because I want to identify polymorphic expressions
19:11:36 <dmj`> dmrd_: I’d check out the code of ghcid 
19:12:53 <dmrd_> dmj`: anywhere in particular? or just to look for it
19:19:35 <dmj`> dmrd_: https://github.com/ndmitchell/ghcid/blob/master/src/Language/Haskell/Ghcid.hs#L63
19:20:20 <dmrd_> Thanks dmj` I'll review this
19:20:42 <dmj`> dmrd_: np
20:45:50 <glguy> dmrd_: It's very unlikely that you can't get what you're asking for out of ghc-as-a-library
20:47:21 <dmrd_> glguy: yup! That's what I meant to say with my message above. It looks like 'ghcid' does a pretty good job at illustrating how to capture stdout output from ghci. dmj` : I tried it out and it seems to work :) 
20:47:40 <glguy> You shouldn't need to involve ghci
20:47:41 <dmrd_> oh wait, I think I misread your message glguy 
20:48:09 <dmrd_> yeah. Hmm. I remember reading that polymorphic expressions would be a problem
20:50:16 <glguy> ghc as a library is just ghc
20:51:16 <glguy> hint is an easier to use layer on top of ghc, this might help: http://hackage.haskell.org/package/hint-0.8.0/docs/Language-Haskell-Interpreter.html#v:typeOf
20:52:29 <glguy> Prelude Language.Haskell.Interpreter> runInterpreter (typeOf "\\x -> x")
20:52:29 <glguy> Right "p -> p"
20:52:43 <dmrd_> glguy: Thanks :) . I'll try it all and see if hint or ghc-as-library do the trick. If so, I'll stick with that since it seems cleaner. Will report back on progress!
20:53:22 <dmrd_> but I'll report back tomorrow. Taking a break from coding for today haha
20:54:43 <siraben> :t (***)
20:54:44 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
20:54:59 <siraben> Is there a paper I can read on the uses of (***) ?
20:55:35 <glguy> You can search for papers on "Arrows", but they're more or less out of fashion
20:56:31 <maerwald> always follow the latest fashion hypes :P
20:56:39 <ensYde> what would be the purpose of them
20:56:56 <dmrd_> Also, is it me or all most (if not all) SYB tutorials just research papers?
20:57:09 <siraben> maerwald: And what would be an example of the current fashion hype? 
20:57:44 <maerwald> type-level programming?
20:57:51 <maerwald> seems everyone needs it now
20:58:05 <maerwald> because there is no way you can solve it with ordinary haskell :>
20:58:15 <glguy> There's: https://www.haskell.org/arrows/ if you want to read about it. It turned out not to be a terribly useful abstraction
20:58:53 <geekosaur> at least, in that form. but it led to three more useful ones: Applicative, Profunctor, and Category
21:02:55 <siraben> So I've just read Wadler's paper on monads and Hutton's on monadic parsing, found them to be amazing.  Any recommendations for other mind-blowing topics to read about?
21:03:17 <glguy> siraben: How about https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
21:04:23 <blankhart> or http://haskell.cs.yale.edu/wp-content/uploads/2011/02/POPL96-Modular-interpreters.pdf
21:05:04 <siraben> glguy: blankhart: Thanks, I'll read them.
21:05:29 <siraben> Wadler mentioned the continuation monad briefly, but didn't elaborate, any papers on that?
21:07:17 <maerwald> not that mind blowing but nice https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf
21:11:04 <blankhart> siraben: continuation monad http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
21:18:03 --- mode: glguy set +v mot
21:19:47 <ArahaelPi> glguy: iteration, a mind blowing topic? That I have to check out. :)
21:22:10 <ArahaelPi> Hmm, 25 pages, on *iterators*.  Will have to give that a read later.
21:23:07 <centril> siraben: I find this mindblowingly useful: https://www.microsoft.com/en-us/research/wp-content/uploads/2003/01/hmap.pdf
21:23:31 <centril> or a more modern implementation: https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Plated.html
21:35:06 <siraben> Thanks for all the papers, I'll be looking forward to reading them!
21:35:47 <blankhart> as a guide to further topics and contextualizing existing ones i highly recommend http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf 
21:41:52 <MarcelineVQ> the rabbit hole is bottomless, they keep breeding
21:44:49 --- mode: glguy set +v blinkhard
22:19:18 <keep_learning> Hi Everyone, I have installed Haskell mode and M-x interactive-haskell-mode starts the interactive mode, but when I am pressing C-c C-l, I am getting Haskell process command errored with: (error "Unexpected response from haskell process.")
22:20:10 <keep_learning> I remember in the past I used to do M-x (some inferior mode ), but I can't remember it. Could some one please tell me how to run it interactively 
23:00:16 <ZeuPiark> hello
23:00:16 * hackage preludeplus 0.1.0.4 - Generalizes List functions and replaces partials with NonEmpty equivalents.  http://hackage.haskell.org/package/preludeplus-0.1.0.4 (jnbooth)
23:01:29 <slack1256> hello
23:19:16 * hackage preludeplus 0.1.0.5 - Generalizes List functions and replaces partials with NonEmpty equivalents.  http://hackage.haskell.org/package/preludeplus-0.1.0.5 (jnbooth)
