00:00:30 <dminuoso> cocreature: I think the most appropriate flagname would be "warn-incomplete-statement-patterns"
00:00:46 <gregberns> cocreature:  heres with -v3 https://gist.github.com/gregberns/e485406541c1c6ea15935fc6c407a958#file-gistfile2-txt
00:01:10 --- mode: glguy set +v _sras_
00:01:21 <dminuoso> It doesnt fit right for pattern guards but oh well.
00:01:24 <gregberns> I uninstalled stack and all of haskell cause it was all taking up a ton of space, and wanted to start fresh
00:01:51 --- mode: glguy set -v _sras_
00:02:01 <_sras_> Can't constructors in data instances for a data family be promoted to type level?
00:03:03 <cocreature> dminuoso: I’m still not sure I get the motivation for pattern guards. isn’t being partial and falling through to the next case kind of the point of pattern guards?
00:03:11 <_sras_> Can't constructors in data instances for a data family be promoted to type level?
00:04:04 <dminuoso> cocreature: I'
00:06:24 <_sras_> Can't constructors in data instances for a data family be promoted to type level? (Is anyone seeing this message?)
00:06:33 <glguy> We see it
00:07:30 <glguy> I'd suggest trying it on either the latest release or 8.6 beta. I wouldn't expect it to work myself
00:07:46 * hackage th-lift 0.7.11 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.7.11 (MathieuBoespflug)
00:08:57 <_sras_> glguy, Thanks. I asked because the message is showing up as a bit grayed in my chat client.
00:09:40 <_sras_> glguy, your message about 8.6 beta. Was that for me?
00:10:27 <glguy> Yeah, I'm saying if it works it will be a very recent feature so try 8.4.3 first and then 8.6
00:10:35 <dminuoso> cocreature: Mmm yeah I should probably not do the naive thing. 
00:11:20 <cocreature> _sras_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overview explicitely states that data families are not promoted
00:14:01 <_sras_> cocreature, Yes. it does. Thankyou.
00:22:53 <lamdev> hello is there a populated channel for beginners at the whole irc gig? installed irssi several hours ago, and couldn't manage to find a way to connect to chat.freenode.net... (i'm connecting via webchat here). btw sorry for the off-topicness
00:23:30 <lamdev> or mind you if you have the url of some tutorial that actually works...
00:23:41 <lavalike> the irssi page does have a tutorial
00:23:55 <lavalike> https://irssi.org/documentation/startup/
00:24:38 <lamdev> but for non-beginners to irc, right? at least that's what i read the other day...
00:27:49 <lavalike> lamdev: check out the private messages tab with my name 
00:30:33 <lamdev> sorry lavalike i seem to have encountered technical problems here too, took me a while to realize my message stopped getting through
00:30:48 <lamdev> how did you open the private message window?
00:30:55 <lavalike> with /query lamdev 
00:45:04 --- mode: glguy set +v dickbarends
01:10:34 <ilyaigpetrov> Hi. I want to handle corner cases when `read()` in my code fails. I think it may be done with `readMaybe`, but I don't get how to approach it in a simple way: https://gist.github.com/ilyaigpetrov/bdab174e02972f5e61c6b9d944af2034 -- Could you prompt me, please?
01:12:11 <ilyaigpetrov> Actually I have written code that uses readMaybe, but it's so horrible that I don't dare to use it or to share it.
01:14:54 <dfordivam> ilyaigpetrov: so if read fails it goes to Unknown.. right?
01:15:24 <ilyaigpetrov> dfordivam: no, if `read` fails I get: LogMessage Info *** Exception: Prelude.read: no parse
01:15:50 <ilyaigpetrov> But yes, I want to get Unknown in case read fails.
01:16:01 <dfordivam> yeah thats what I meant
01:16:40 <dfordivam> so for simplicity you can write nested case statements
01:18:36 <cocreature> pattern guards will work nicely here
01:18:54 <cocreature> in combination with readMaybe
01:20:29 <liste> dfordivam: make a helper function "MessageType -> Maybe TimeStamp -> String -> Maybe LogMessage"
01:27:32 <kuribas> I am allowed to give a short presentation of haskell at my workplace.  What would be a good topic?
01:28:13 <ilyaigpetrov> dfordivam: thanks for the code, not very DRY but indeed better than my horrible solution
01:28:36 <cocreature> kuribas: what’s the audience?
01:28:45 <Ariakenom> kuribas: I'm currently looking into a haskell presentation as well 
01:28:52 <kuribas> cocreature: my coworkers
01:29:09 <kuribas> cocreature: mostly Java developers, but they are open minded
01:29:17 <Ariakenom> I'm currently into "why should I even care about Haskell?" and found this https://mail.haskell.org/pipermail/haskell-cafe/2018-July/129443.html
01:31:30 <cocreature> kuribas: I would stick to “simple” Haskell (~ haskell 2010) in that case and demonstrate the concurrency features
01:31:43 <cocreature> green threading, stm, …
01:32:26 <Ariakenom> type inference is an interesting topic as well
01:32:27 <cocreature> concurrency being difficult is probably something that your coworkers can relate to and it’s nice in that it shows that Haskell is not just useful for solving mathematical puzzlesin ghci
01:32:37 <kuribas> perhaps the hxt for xml processing?
01:33:08 <cocreature> not really a fan of hxt personally
01:33:08 <kuribas> cocreature: I'd like to show some concrete problem.
01:33:28 <cocreature> sure you embed that into some concrete problem like building a small tcp server or whatever
01:33:28 <kuribas> if I show concurrency, I'd need to have a problem to show it on.
01:34:17 <kuribas> tcp would be nice :-)  Unfortunately I don't have much time before the presentation (it's next friday)
01:34:59 <cocreature> that’s 4 days, should be enough to whip up a quick server :)
01:35:35 <Ariakenom> keeping state in STM and just mutating without thought :p
01:35:41 <kryft> kuribas: What's their background? For instance, if they're mostly working with javascript, maybe just showing how you can model some problem with types and what kind of practical help you get from the compiler could be interesting
01:36:15 <Ariakenom> kryft: "mostly Java developers, but they are open minded"
01:36:25 <kuribas> kryft: java mostly, parsing files and the web frontend of our app.
01:36:26 <kryft> kuribas: Like to me being able to tell whether a function has side effects or not just by looking at the type is a pretty cool feature with practical value
01:37:06 <kryft> Ariakenom: Oh, duh, my backlog reading skills could use some polishing :)
01:37:25 <kuribas> or maybe json parsing?
01:37:37 <kuribas> it's relevant...
01:37:49 <kuribas> we have xml as well
01:38:14 <cocreature> json parsing is nice but it also kind of fits into the “you can only use Haskell for pure data transformations”-believe that a lot of people have about Haskell
01:38:27 <cocreature> I think it’s more interesting to show something that falls out of that category
01:38:28 <AWizzArd> When I use an HList then it’s totally working for lists that are fully known at compile time. But is it also perfectly type-safe and fully functioning if I use it at runtime only?
01:38:39 <kuribas> cocreature: yeah, good point
01:38:52 <AWizzArd> I.e. I let the user decide what to put in there, and which n-th element he wants to take out of the list.
01:39:19 <kuribas> AWizzArd: you want existential quantification then.
01:39:44 <dminuoso> cocreature: I wish people would think of haskell rather as "You can *also* use Haskell for pure data transformations with type-driven guarantees of purity"
01:39:44 <AWizzArd> kuribas: so HLists are only for lists that are completly known at compile-time?
01:39:54 <kuribas> AWizzArd: pretty much, yes
01:40:22 <cocreature> dminuoso: agreed :)
01:40:42 <AWizzArd> kuribas: and is it the same with length-indexed Vectors too?
01:41:26 <cocreature> it depends on what exactly you want to do 
01:42:06 <cocreature> it is perfectly possible to read dynamic input as a length-indexed vector but then the code that consumes it has to handle an arbitrary length
01:42:16 <cocreature> i.e. it must be polymorphic in the length parameter
01:42:30 <cocreature> but you’ll still get guarantees like map preserves the length
01:42:35 <cocreature> so it’s not useless
01:42:56 <cocreature> alternatively you can read your input as a Maybe (Vector 3 Int) and fail if it has the wrong length
01:43:15 <AWizzArd> Okay I see.
01:44:39 <cocreature> hlists don’t tend to be particularly useful if you need to be polymorphic in the types contained in that list so for most uses you want the types to be fixed statically
01:45:25 <cocreature> for vectors being able to handle vectors of arbitrary length is a lot more reasonable since that is also what you get if you don’t use length-indexed vectors
01:56:01 <kuribas> cocreature: another idea would be to make a combinator based query language for our data engine.
01:56:03 <AWizzArd> cocreature: well yes, hlists are in some sense always statically limited in programs that can’t crash and handle all cases.
01:57:09 <cocreature> AWizzArd: not necessarily, e.g., I can safely take the length of an hlist even if I don’t know anything about the type parameters
01:57:35 <kuribas> cocreature: showing how to make typesafe structural queries.
01:58:50 <cocreature> kuribas: a) that probably still fits in the “pure data transformations” category, that I would try to avoid and b) depending on how you set that up it requires a fair amount of type-system hackery which can be overwhelming to people that have never seen Haskell before
01:59:53 <kuribas> cocreature: yeah, I am using type-applications to find the attributes by string (since they are strings the lisp code).
02:00:06 <kuribas> cocreature: that may be much for someone without haskell experience.
02:17:17 <kuribas> cocreature: what kind of TCP server?  A chess server?
02:18:14 <maerwald> why is hpack integrated in stack?
02:18:49 <cocreature> dunno, I’m not going to write all of your talk for you :)
02:19:26 <hvr> maerwald: you mean, why it's linked into stack? or are you asking why stack is pushing to replace .cabal with .yaml ?
02:20:00 <maerwald> stack generates .cabal from package.yaml
02:20:07 <maerwald> it does so with an internal version of hpack
02:20:19 <maerwald> but... it doesn't allow you to control how hpack is run, which is stupid
02:20:26 <hvr> :-)
02:20:46 <maerwald> so when you run hpack manually, stack complains that something is wrong
02:20:54 <maerwald> which is nonsense
02:21:52 <hvr> well, you're probably a corner case which they didn't take into account :-)
02:22:01 <infinisil> kuribas: how about a simple chat server
02:22:28 <maerwald> hvr: well, that's what happens when you break unix philosophy
02:22:39 <maerwald> assuming use cases
02:22:58 <maerwald> and everything outside of your assumptions then is broken...
02:23:10 <maerwald> welcome to stack
02:23:39 <maerwald> should be integrated in systemd
02:27:03 <hvr> be careful... they might go for it ;-)
02:27:51 --- mode: glguy set +v shiona_
02:28:19 <shiona_> A quick slightly off-topic question: I came across a computer science question in which a set is used in place where a type is supposed to be. Is this set a type? Is type a set? Are they similar enough that they can be used interchangeably or has the author just made a mistake?
02:30:05 <ventonegro> shiona_: The keyword for "type" in the PL Agda is Set :)
02:30:07 <jose_zap> If I understand you question correctly, that sort of thing is possible. You can use values as types, with the DataKinds extension
02:30:24 <ventonegro> shiona_: Types are basically sets of values
02:32:37 <Athas> maerwald: in the Unix philosophy, hpack should not take options!
02:34:16 * hackage text-builder 0.5.4.2 - An efficient strict text builder  http://hackage.haskell.org/package/text-builder-0.5.4.2 (NikitaVolkov)
02:35:25 <maerwald> Athas: the only "option" I use it print to stdout (which it should do by default anyway if it was true unix)
02:36:23 <maerwald> that enables me in my docker build chain to generate the .cabal on the host while still only ever mounting the project folder read-only into docker containers
02:41:17 * hackage pomaps 0.0.2.0 - Maps and sets of partial orders  http://hackage.haskell.org/package/pomaps-0.0.2.0 (sgraf812)
02:44:14 <Athas> maerwald: IIRC, stack will use an existing .cabal file, if one exist, rather than running hpack.  Was that broken?
02:44:33 <Athas> As a workaround, maybe just delete the package.yaml on the host after generating the .cabal file.
02:48:09 <maerwald> Athas: it complains that the existing .cabal file was modified manually, which is wrong
02:48:32 <maerwald> and no, deleting project files temporarily is not a solution
02:54:03 <Athas> maerwald: does stack then refuse to build?
02:54:21 <maerwald> no
02:54:46 <maerwald> but it won't regenerate the .cabal file anymore if you now build on the host
03:03:17 * hackage uuid 1.2.14.1 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.14.1 (HerbertValerioRiedel)
03:07:16 * hackage tar-conduit 0.2.4 - Extract and create tar files using conduit for streaming  http://hackage.haskell.org/package/tar-conduit-0.2.4 (lehins)
03:21:21 <dminuoso> GHC bugs aside, are there ways a timeout would be unable to interrupt a thread?
03:21:28 <dminuoso> Permamently that is
03:21:59 <WilhelmVonWeiner> Does anyone have any good resources to understanding the funamental logic and mathematics behind FP concepts?
03:22:17 <dstolfa> dminuoso: stuck in the kernel with interrupts off... :-)
03:22:31 <dstolfa> dminuoso: in other words: kernel bugs
03:22:36 <WilhelmVonWeiner> Like books/papers/webzones on lambda calculus, function and monoids and monads, etc
03:23:01 <cocreature> dminuoso: non-interruptible foreign calls
03:23:27 <dstolfa> cocreature: why would that make it permanently uninterruptable
03:23:31 <dstolfa> it sounds like a bug to me
03:24:38 <dminuoso> Mmm, I suppose there's also incorrect usage of uninterruptibleMask
03:25:07 <dstolfa> dminuoso: that's only the case if timeout is not a NMI here though, is it?
03:25:54 <dminuoso> dstolfa: does the RTS have the concept of NMIs?
03:26:09 <dstolfa> dminuoso: no idea, sorry :-(
03:26:13 <dstolfa> dminuoso: if it does, it's worth looking into that
03:28:15 <dminuoso> cocreature: Mmm isnt every FFI call uninterruptable unless explicitly tagged interruptible?
03:28:41 <dminuoso> This is starting to get less funny than I anticipated..
03:41:53 <cocreature> dminuoso: right
03:42:17 <cocreature> dstolfa: well depends on the ffi call, if it eventually returns then it will ofc not be uninterruptible forever
03:49:22 <Ariakenom> dminuoso: There's -fno-omit-yields https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#ghc-flag--fomit-yields
03:51:49 <Ariakenom> This seems a nice description https://ghc.readthedocs.io/en/latest/bugs.html#known-bugs-or-infelicities
04:15:10 <dminuoso> Ariakenom: Ah I see, that makes sense
04:29:16 <limenius> Hello guys. Usually when I'm trying to understand something in imperative language, I just place some debug output or fire up gdb and step through the code. What do you do in haskell, when you have problem  to understand some function? currectly I'm having problem to understand/visualize "direct self-reference".
04:30:05 <hpc> like a self-referential data structure?
04:30:21 <tdammers> limenius: in imperative code, you reason in terms of "what happens next"; in functional code, you reason in terms of equivalencies - "what can I substitute here", or "what's the value of this expression"
04:33:28 <dminuoso> limenius: Make sure that you keep repeating that haskell does not have call-by-value semantics. GHC uses call-by-name - this is a key to understanding some of the principles like how `cycle` works
04:33:34 <limenius> Well for example I'm currently reading haskell wiki concerning primes number generation and I spent quite a trying to visualize how will be the code executed... Or what values will be supplied, I do understand mechanism... But I wouldn't came up with it...
04:33:37 <dminuoso> *call-by-need even!
04:33:57 <limenius> primesTo m = ps
04:33:59 <limenius>   where ps = map head $ takeWhile (not.null) $ scanl (\\) [2..m] [[p, p+p..m] | p <- ps]y
04:34:23 * dstolfa waits for someone to bring up strictness analysis and follow up with some category theory
04:35:39 <limenius> \w tdammers Thanks for your point of view. I'll try to use that
04:36:21 <Ariakenom> dstolfa: I'll just dive into IO = ST RealWorld. That should clear things up
04:37:47 <dminuoso> Ariakenom: You mean `State# RealWorld`
04:37:52 <dminuoso> Oh wait./
04:37:57 <dminuoso> :k ST
04:37:58 <lambdabot> * -> * -> *
04:38:01 <dminuoso> What is this
04:40:12 <[exa]> ST needs 2 type params?
04:40:32 <Ariakenom> phantom region
04:42:05 <dminuoso> Ariakenom: It looks inapplicable to RealWorld
04:42:12 <dminuoso> :k RealWorld
04:42:13 <lambdabot> *
04:42:15 <dminuoso>  Huh
04:42:25 <dminuoso> :k State# RealWorld
04:42:26 <lambdabot> error:
04:42:26 <lambdabot>     Not in scope: type constructor or class ‘State#’
04:42:26 <lambdabot>     Perhaps you meant one of these:
04:42:39 <dminuoso> > import GHC.Exts
04:42:41 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
04:42:46 <dminuoso> @let import GHC.Exts
04:42:47 <lambdabot>  .L.hs:134:1: error:
04:42:47 <lambdabot>      GHC.Exts: Can't be safely imported! The module itself isn't safe.
04:42:47 <lambdabot>      |
04:44:13 <dminuoso> % import GHC.IO
04:44:13 <yahb> dminuoso: 
04:44:15 <dminuoso> % import GHC.Exts
04:44:16 <yahb> dminuoso: 
04:44:23 <dminuoso> % :k State# RealWorld
04:44:24 <yahb> dminuoso: State# RealWorld :: TYPE ('TupleRep '[])
04:44:34 <dminuoso> Ariakenom: ^- so I dont think that would kindcheck.
04:44:46 <Ariakenom> dminuoso: I'm just going of what I remembered from Imperative Functional Programming. Which is probably outdated and misremembered.
04:44:48 <dminuoso> Unless ST has some hidden levity in there
04:45:14 <Ariakenom> % :k State#
04:45:14 <yahb> Ariakenom: State# :: * -> TYPE ('TupleRep '[])
04:45:45 <ChaiTRex> % :t runRW#
04:45:45 <yahb> ChaiTRex: (State# RealWorld -> o) -> o
04:45:46 * hackage indexation 0.4.3 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.4.3 (OShev)
04:46:41 <dminuoso> Ariakenom: Although I guess `ST RealWorld` is isomorphic to IO` at least
04:46:47 <dminuoso> :t stToIO
04:46:48 <lambdabot> ST RealWorld a -> IO a
04:46:50 <dminuoso> :t ioToST
04:46:52 <lambdabot> error: Variable not in scope: ioToST
04:47:07 <dminuoso> % :t ioToST
04:47:07 <yahb> dminuoso: IO a -> ST RealWorld a
04:47:16 <dminuoso> Ariakenom: So that makes my point mood and I take everything back.
04:48:02 <Ariakenom> I never doubted the validity of my statement!
04:48:47 <dstolfa> Ariakenom: you know, i went away for 10 minutes and come back to see you delivering on your promise to delve into it
04:49:13 <hpc> dstolfa: nobody ever lies on irc :D
04:49:24 <dminuoso> Maybe Im missing something. Can someone give me an example of an arrow command using a pattern?
04:49:36 <Ariakenom> dstolfa: I'd like to correct your "delve" into "dragged". Otherwise yes :p
04:49:43 <dminuoso> I tried this: idA = proc (a, 1) -> arr (id :: String -> String) -< (a : "bar")
04:49:58 <dminuoso> Either there's a bug in GHC somewhere, or there's another way to have a pattern in an arrow command
04:54:17 <hpc> dminuoso: that looks right to me, except that it's not id
04:54:43 <hpc> > idA ('s', 1)
04:54:43 <hpc> "sbar"
04:54:45 <lambdabot>  error:
04:54:45 <lambdabot>      • Variable not in scope: idA :: (Char, Integer) -> t
04:54:45 <lambdabot>      • Perhaps you meant one of these:
04:54:46 <hpc> oops
04:55:17 <dminuoso> hpc: oh yeah the name is just a relict from something old 
04:55:56 <hpc> if you're actually in the do block and not at the proc part, use "<-" like with regular do-notation
04:58:15 <hpc> hmm, i think?
04:58:25 * hpc is very bad at arrow notation due to never needing to use it
05:02:26 <dminuoso> hpc: Ahh that's it yes thanks.
05:03:04 <dminuoso> hpc: You can have a pattern like: proc a -> do { (1,2) <- someArrow -< a; ... }
05:03:11 <dminuoso> And thats apparently the pattern I was looking for :)
05:06:46 * hackage non-empty-containers 0.1.2.0 -   http://hackage.haskell.org/package/non-empty-containers-0.1.2.0 (andrewthad)
05:10:01 <dmwit> Hm. Perhaps we will shortly need an "empty-containers" package to go with that.
05:11:25 <dmwit> I guess it wouldn't be totally stupid. Proxy and Const are useful despite being very empty-container-like.
05:11:53 <hpc> hah
05:12:32 <Ariakenom> container ! key = error "Well, what did you expect?"
05:16:41 <Putonlalla> > negation "You can do anything!"
05:16:43 <lambdabot>  "You can't do anything!"
05:17:12 <olligobber> > negation "You can not do anything!"
05:17:14 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
05:18:50 <liste> > negation "Can you do anything"
05:18:52 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
05:20:50 --- mode: glguy set +v gentauro
05:20:56 <gentauro> how would you write code for arbitrarily read/writes with Network.Socket (http://hackage.haskell.org/package/network-2.7.0.2/docs/Network-Socket.html)?
05:21:07 --- mode: glguy set -v gentauro
05:21:51 <dmwit> What does "arbitrary" mean?
05:22:05 --- mode: glguy set +v aleator
05:22:06 <gentauro> server can write something at any given point and so can the client
05:22:24 <aleator> Good polytyped grief. For pedagogical purposes I'd need a non-polymorphic function of atleast two arguments, that isn't defined as an operator and does not take overloaded literals as input. I can't find any!
05:22:26 <gentauro> (a bit like a p2p chat with no central server)
05:23:19 <dmwit> I think that's pretty much the default.
05:24:07 <gentauro> dmwit: default?
05:24:47 * hackage ngram 0.1.0.0 - Ngram models for compressing and classifying text.  http://hackage.haskell.org/package/ngram-0.1.0.0 (TomLippincott)
05:25:19 <dmwit> gentauro: You don't have to do anything special. Sockets are already full duplex.
05:26:11 <gentauro> dmwit: I know that from experience, but how do you actually write the code?
05:27:24 <gentauro> example: foo = do ping <- recv socket42; send <- send socket42 "pong"
05:27:42 <gentauro> here pong will only be send if `ping` is recieved
05:28:02 <dmwit> aleator: How about `lex`?
05:28:23 <dmwit> gentauro: Fork a writer thread and a reader thread.
05:28:28 <gentauro> I'm looking for something like: "If I don't recieve a ping, well then I will send one and I will wait for a `pong`. Otherwise
05:28:51 <Putonlalla> :t showParen -- aleator
05:28:52 <lambdabot> Bool -> ShowS -> ShowS
05:28:53 <gentauro> dmwit: got it (just what I was thinking about)
05:28:56 <pong> hi
05:29:34 <aleator> dmwit: Good catch. It is under a type alias, but I'd guess that would do. Same for showParen.
05:29:36 <dmwit> Oh, lex takes only one argument. Whoops. =P
05:29:38 <gentauro> dmwit: then use `Control.Concurrent.MVar` right?
05:29:49 <gentauro> to handle state
05:29:58 <dmwit> gentauro: Sure, or Chan, or TVar, or TMVar, or, or, or...
05:30:11 <Putonlalla> :t numberToRangedRational -- aleator
05:30:13 <lambdabot> error:
05:30:13 <lambdabot>     Variable not in scope: numberToRangedRational
05:30:28 <Putonlalla> :t numberToRangedRational
05:30:29 <lambdabot> (Int, Int) -> Number -> Maybe Rational
05:30:40 <dmwit> aleator: Here's a better one:
05:30:42 <dmwit> :t openFile
05:30:43 <lambdabot> error: Variable not in scope: openFile
05:30:49 <dmwit> % :t openFile
05:30:49 <yahb> dmwit: FilePath -> IOMode -> IO Handle
05:31:11 <dmwit> aleator: monomorphic, prefix-by-default, takes two arguments... and is even something you might want to use in real code. =)
05:31:22 <Putonlalla> % :t setEnv
05:31:22 <yahb> Putonlalla: ; <interactive>:1:1: error: Variable not in scope: setEnv
05:32:07 <aleator> dmwit: Yeah... Thats nice. I've even used that. Having IO in it is not as nice, but I guess it would still be ok.
05:32:07 <Putonlalla> There are many such functions related to `IO`, but with the downside of `IO`.
05:32:19 <dmwit> Yep.
05:32:55 <aleator> But yeah, when you start hunting these it becomes fast apparent that polymorphism gets used a lot
05:33:08 <gentauro> dmwit: would it be possible to make code to read/write from socket with <*> or <|>?
05:34:10 <dmwit> aleator: Ooo, GHC.Char has eqChar and neChar
05:34:55 <aleator> Wait. What or why are those?
05:35:05 <olligobber> > negate "Yesn't"
05:35:07 <lambdabot>  error:
05:35:08 <lambdabot>      • No instance for (Num [Char]) arising from a use of ‘negate’
05:35:08 <lambdabot>      • In the expression: negate "Yesn't"
05:35:21 <dmwit> They are monomorphic versions of (==) or (/=), which could exist for a variety of reasons.
05:35:47 <Putonlalla> Actually, `System.IO.Error` has many good options.
05:35:54 <aleator> Yeah.. Well, makes me want to grep out hackage to see if they have ever been used. :)
05:35:58 <dmwit> The most likely is that Char is baked into the compiler, these are bindings to primops or something, and this module is imported by the module that defines Eq and the Eq Char instance.
05:36:12 <aleator> dmwit: That'd be my guess as well.
05:36:27 <dmwit> Putonlalla: Nice!
05:36:48 <aleator> Surprisingly, Data.Data has plenty of these as well, but they make for really lousy examples.
05:46:02 <Putonlalla> Well, I nominate `mkIOError`.
05:47:49 <maerwald> oh boy, Servant errors are really bad
05:48:30 <dminuoso> maerwald: They are manageable if you keep the types small.
05:49:22 <dminuoso> Most combinators distribute over (:<|>) so as long as you have small handlers and small API endpoint sets its not so bad.
05:49:31 <dstolfa> i think the biggest typing error i got was 2k lines of code with it telling me that there's a wellsortedness error regarding equality in Isabelle
05:49:38 <dstolfa> luckily, that was quickly debugged
05:49:40 <maerwald> to me this is all over-engineered and unpleasant for some contrived advantage
05:50:18 <dminuoso> maerwald: Is it that much better than QuasiQuoted routes? At least you can trivially tap into those types and use them for things like documentation generation
05:50:27 <dminuoso> Or automated prometheus metric generation
05:50:35 <maerwald> Scotty and Snap are fine
05:51:02 <maerwald> huge complexity for small use case
05:54:08 <alp> I suppose you've read the blog post about why it's designed the way it is?
05:55:06 <dminuoso> alp: I really love the ability to have a type-driven connection between my client and the server - albeit that's something you can also solve with QQ.
05:55:29 <maerwald> alp: sure, I couldn't find a good argument
05:56:33 <alp> ok, fair enough
05:57:02 <dminuoso> alp: The main reason the author didnt use TH was that its untyped - I wonder whether things have changed since typed TH
05:57:16 <alp> (I'm the author of the post)
05:57:21 <dminuoso> Oh interesting!
05:57:29 <dminuoso> alp: You are to blame for servant? :)
05:57:43 <alp> one of the 3 persons to blame, yes
05:57:58 <maerwald> so, what is the advantage?
05:57:58 <dminuoso> Well thank you for it. It's a lovely set of libraries.
05:58:17 <alp> maerwald, over what?
05:58:38 <dminuoso> alp: Would you consider QQ or typed TH nowadays as an alternative way to generate API types?
05:58:41 <maerwald> over Scotty
05:59:23 <maerwald> I only see "let's be more abstract" or "let's be more elegant" or "let's have less code", but I don't see *simplicity* anywhere or that an unsolved problem has been solved
06:02:47 <tdammers> IMO scotty lacks an important abstraction step
06:03:30 <tdammers> there is no concept of a "resource" in scotty; "/foo/bar/23" and "/foo/bar" are just two arbitrary strings to scotty's router, the connection between them isn't captured anywhere
06:03:58 <alp> dminuoso, I don't think so, not as the main vehicle anyways. in the early days, we had a QQ to specify API types, but the author decided to drop that after a few versions. I am usually not fond of involving TH when I can do without while keeping my sanity. TH and QQs are nice tools, but I would not want to design a DSL around them. they introduce some complexity, they often increase compile times because of how TH is executed, but they of 
06:03:58 <alp> course let me do anything I want. so at this point, you face different trade offs and usually pick the one you're most comfortable with
06:04:35 <maerwald> tdammers: which is useful for?
06:05:09 <tdammers> maerwald: well, I just like useful truths about the problem domain to be embedded in the code itself, for a dozen or so reasons
06:05:12 <alp> maerwald, well, you're just talking about servant-server then? because the whole point of those API types is that you can use them "from the other side" of HTTP too, among other things
06:05:31 <maerwald> tdammers: that's a bit vague
06:05:38 <tdammers> maerwald: yes, I know, but that's as good as it gets
06:06:01 <tdammers> maerwald: if you prefer, you can call it the principle of the single source of truth
06:06:04 <maerwald> ok, then I would argue it doesn't justify the complexity
06:06:11 <tdammers> it depends
06:06:29 <tdammers> I want to have the semantic structure of the API reflected in the code somehow
06:07:13 <alp> if you only look at the """web framework""" aspect of servant, sure, there's nothing revolutionary and even some annoyances, like specifying things in types, terrible errors, etc. and a few small advantages, like handlers with types that reflect what the handler takes in and responds with and a way to map this to the different parts of the request from which they come. things like this, but nothing wow-worthy really
06:07:38 <tdammers> you can do it at the type level or at the value level; if you do it at the value level, you can change the API structure without recompiling, which is nice (and often even a requirement); if you do it at the type level, then you get compile-time checks of your API structure
06:08:16 <maerwald> tdammers: that sounds all very theoretical and abstract. Again... even if there is an actual real-world use case, probably no one ever encountered it. So the expressivity (and the complexity that it intorudces) could have been avoided.
06:08:30 <tdammers> OK, concrete real world use case then
06:08:38 <tdammers> you have a todo list
06:09:47 <tdammers> GET /todo/items lists todo items, GET /todo/items/{id} gets a single item, POST /todo/items/{id} updates, etc
06:10:12 <tdammers> with scotty, these are 3 completely independent handlers
06:10:30 <tdammers> so if you change the name of the table that holds todo items, you have to change it in 3 places
06:11:08 <alp> maerwald, I have a real world use case described towards the beginning of the post. I had to write web apps and make them talk to some others, so I needed server & client functions, which led me to investigate how I could go about being able to just reuse the server's definition or something like that to generate the client functions
06:11:14 <maerwald> tdammers: huh?
06:11:26 <alp> the sheer number of endpoints made me look for an automated approach
06:11:55 <tdammers> likewise, if you decide that you want to have todo items served as /todo/entries, not /todo/items, you have to change 3 routes, independently
06:12:02 <tdammers> so that's kind of bad
06:12:21 <maerwald> that's all very contrived yeah
06:12:22 <tdammers> especially since if you forget one of them, nothing will warn you until you try to run things
06:12:41 <tdammers> contrived? it's like the canonical thing you do with an API
06:12:48 <maerwald> complex solution for not a really big problem
06:13:03 <tdammers> well, it's not a big problem if those 3 routes are all your API has
06:13:17 <alp> also, you're completely ignoring the non-server aspect
06:13:22 <alp> if all you're writing is a server
06:13:32 <alp> that's not where servant edge is
06:13:36 <alp> servant's*
06:13:58 <tdammers> but anyway, I want some sort of entity in my code - a type, a data structure, something like that - that describes the "TODO items" resource
06:14:12 <alp> it works well, so do quite a few other libraries, different design choices etc.
06:14:18 <enick_693> for example I use servant-swagger
06:14:19 <enick_693> changing a single route, will change the server and the swagger for me
06:14:24 <maerwald> tdammers: I want changes to be simple. Every time I touch servant code I spend 10x the time compared to scotty code.
06:14:39 <alp> well, nobody's saying servant's the best thing ever
06:14:45 <alp> me included
06:14:52 <tdammers> indeed; I'm not saying servant is the perfect solution
06:14:53 <maerwald> how much stuff is encoded on type level is really not very interesting to me
06:15:02 <alp> maerwald, and that's fine
06:15:06 <alp> but it's not over-engineered
06:15:12 <tdammers> in fact, it probably isn't, which is why I usually build custom abstractions tailored to the project myself
06:15:19 <alp> I started out with the simplest solution
06:15:35 <alp> and with my requirements, and the help of my 2 colleagues, ended up with the current approach
06:16:05 <alp> in fact I was rather inexperienced with type-level stuffs back then, but that's where my requirements led me
06:16:33 <tdammers> one important thing that you can't easily do without consolidating multiple related routes into some sort of abstraction is generating clients
06:16:39 <tdammers> which is what alp hinted at
06:18:51 <tdammers> declaratively describe the API structure; then based on that, fire up a live API, generate client code, check consistency, etc.
06:18:52 <enick_693> client, mock-server (great to work on the frontend while the backend is not yet finished), mock-client,
06:19:00 <alp> so tl;dr: servant does things like this for real reasons, and this all got written in a company, no academics were involved, etc. now if for your use cases, servant gives almost no benefit, that's ok. I know there's quite some hype around it these days, it has good and bad sides (more contributors, talked about a lot - inaccurately sometimes - etc). but people should feel free to look at servant and see what's particular about it, learn a 
06:19:01 <alp> bit about the ideas behind it, but move on to using another lib.
06:19:12 <tdammers> you can't do that when your data model is "Route -> IO Response"
06:19:58 <tdammers> alp: yeah, unfortunately with the recent type-level hype, people sometimes get a bit over-enthusiastic and start doing things at the type level just because they can
06:20:08 <tdammers> but that doesn't mean it has no merits at all
06:20:33 <alp> yeah, or conversely some people just won't use any library that mentions "type level"
06:20:35 <maerwald> I value clear control flow over DSLs. A bit of repition is fine.
06:21:20 <tdammers> the problem with this particular kind of repetition is that is scales at least linearly with project size
06:21:31 <maerwald> works fine here
06:21:32 <threewood> Good that we finally have template metaprogramming in Haskell
06:21:52 <maerwald> you can use multiple files, structure your project properly
06:22:02 <maerwald> least amount of code is rarely the best idea, ime
06:22:17 <tdammers> it's not about amount of code at all
06:22:33 <alp> it's about the functionality that you have to write vs what's taken care of for you
06:22:43 <tdammers> it's about keeping the number of code changes required for a semantic change as close to 1 as possible
06:23:10 <maerwald> yeah, but it's not really a problem, more an elegance thing
06:23:13 <alp> no no
06:23:18 <tdammers> and about reducing the number of things you can accidentally get wrong when making a change
06:23:21 <alp> for me back then it was about spending 2 months on something
06:23:40 <alp> vs 2 or 3 weeks tops, once servant was there
06:23:40 <maerwald> alp: I can't see that from the blog post, seriously
06:23:57 <alp> maerwald, again, you're completely ignoring the client side
06:24:14 <alp> I had to write many web apps, with dozens of endpoints, etc, and then talk to them from other programs
06:25:14 <alp> servant allowed me not to write the ("client-side") request making logic for any one of my endpoints
06:25:25 <alp> that's the whole point of those descriptions, and the motivation for them
06:25:30 <alp> it's all at the beginning of the post
06:26:20 <alp> doing something manually that you can avoid, because the server already has, hidden in it, the structure of the API, with everything a client needs to know to hit any particular endpoint VS spending your time on what's really important
06:26:33 <tdammers> that's the single source of truth, again
06:27:08 <tdammers> you have a fact already embedded in the system (the API backend definition), and now you need a client that matches this fact
06:27:24 <alp> at least that's what it was about for me, that's why this central description that you can reuse for all sorts of tasks became very, very important. the amount of time I've saved with servant-client is just enormous.
06:27:47 <tdammers> you can manually write the client, but then you express the same truth in two disjoint places, and that means they can go out of sync, that keeping them synchronized is a manual effort
06:28:24 <tdammers> and what's worse, you're also duplicating the facts that say how connecting to an endpoint works on the client side, for every endpoint
06:28:45 <tdammers> and when the way such a connection is supposed to work changes, you have to manually change all your client side connectors
06:29:14 <maerwald> tests catch that very well
06:29:14 <tdammers> but if you automatically derive them from the structure that's already there, then you only have to change one thing, and then generate them again
06:29:31 <tdammers> tests? but how do you test that kind of thing?
06:29:52 <tdammers> those changes aren't guaranteed to break anything in any obvious way
06:30:26 <maerwald> why would that not be testable if you write your client and tests it?
06:30:28 <tdammers> also, if you change the way connecting to an endpoint works, and you have proper tests in case, you will need one test for each endpoint
06:30:52 <tdammers> so now what, you update all your tests, one by one? isn't that even worse?
06:30:53 <maerwald> and if you are using a non-haskell language for connecting to your endpoints, you have to do that anyway
06:31:27 <tdammers> actually, even in an untyped language, you can still benefit from that abstraction
06:31:52 <alp> no, there are servant libs for generating client code in some other languages, as well as a swagger spec which lets us generate client code in even more languages
06:31:53 <maerwald> how? It knows nothing about the haskell code
06:31:58 <alp> all from the API description
06:32:30 <tdammers> one benefit is that you can test the general mechanism instead of testing all your endpoints individually
06:32:32 <alp> well it knows the server will expect some header, a request body in JSON or HTML or whatever, and will respond with no content and a 204 status code if everything goes well, etc
06:32:57 <alp> maerwald, also, it's about writing tests vs guaranteeing things are correct by construction (or type-checking, here, I suppose)
06:33:09 <maerwald> so what languages does it support
06:34:04 <tdammers> alp: I would argue that even if you write tests, it's still a million times better to only have to test the individual parts in a generalized fashion once, than to duplicate the same test code over and over and over
06:34:10 <alp> https://packdeps.haskellers.com/reverse/servant-foreign + all the ones we can reach by producing a swagger spec automatically and generating code from there
06:34:25 <alp> (using swagger tools)
06:34:50 <maerwald> no clojurescript
06:35:05 <maerwald> out of luck
06:35:40 <alp> https://github.com/swagger-api/swagger-codegen#overview <- languages supported by swagger
06:36:13 <maerwald> I don't see clojurescript there either
06:36:29 <alp> one could easily write a servant-clojurescript lib
06:36:33 <maerwald> haha
06:36:34 <maerwald> sure
06:37:06 <alp> :)
06:37:33 <maerwald> well, that use case is compelling... because breaking API between clojurescript and backend happened
06:37:53 <maerwald> but then it's still code generation
06:38:03 <alp> well there's no other way, with clojurescript
06:38:13 <alp> with Haskell we found a way, but not for foreign languages
06:38:25 <maerwald> so servant + reflex would be a good combination?
06:38:48 <alp> so we've got this servant-foreign package, which collects all the information one needs to generate code in a foreign language, with functions to query every single endpoint
06:39:07 <alp> then all the packages you've seen above take this and spit out strings with the said code
06:39:23 <alp> sometimes directly as strings, sometimes using proper ASTs and a pretty printer
06:39:54 <alp> maerwald, I haven't used reflex myself, but I've certainly heard or read about many people using this combination. or servant+miso.
06:40:48 <maerwald> interesting
06:41:03 <maerwald> but then again, when you have already access to backend types
06:41:09 <maerwald> not sure servant is that compelling anymore
06:41:18 <alp> anyway, gotta run now, hopefully some of this was helpful, see you around
06:41:23 <maerwald> cya
06:45:47 * hackage ntype 0.1.0.0 - N-ary sum/product types  http://hackage.haskell.org/package/ntype-0.1.0.0 (int_index)
06:48:17 * hackage apecs 0.5.0.0 - Fast ECS framework for game programming  http://hackage.haskell.org/package/apecs-0.5.0.0 (jonascarpay)
07:26:22 <asheshambasta> Anyone aware why base-noprelude is so old on Stackage? https://www.stackage.org/package/base-noprelude
07:33:25 <asheshambasta> For some reason, the NoImplicitPrelude langauge extension in my test file gets ignored and I see the error commented in the Gist: https://gist.github.com/asheshambasta/5632b3b24cef9c98d6c3615536e8c3d5
07:34:33 <asheshambasta> anyone ignore me, I'm being stupid. 
07:36:36 <asheshambasta> actually, no, something funny is going on; I've added the NoImplicitPrelude extension in my Main.hs file; (even though its default-extensions in package.yaml) and yet I'm seeing errors
07:39:38 <c_wraith> asheshambasta: are you still getting the error from the gist?  Because that error suggests NoImplicitPrelude is working right.
07:39:53 <asheshambasta> yes; but only when doing `stack test`
07:40:42 <asheshambasta> c_wraith: `stack ghci` seems to work correctly. Basically I have a module named Prelude in the src/ and I have the `NoImplicitPrelude` extension enabled in my package.yaml. 
07:41:52 <c_wraith> Honestly, I'd just rename your module to something else.  Seems easier than debugging the difference between normal and test compilation environments
07:41:59 <mbwgh> How embarrassing! There are tutorials about this online, but I still got the feeling I better ask at least once about this, in order to avoid a snafu: Can somebody give me the run-down of what is necessary to do a pull request?
07:42:38 <asheshambasta> c_wraith: okay, but this is strange and I'm not sure why this happens only with Stack test 
07:42:54 <lyxia> mbwgh: a github account
07:43:00 <mbwgh> check
07:43:05 <tdammers> mbwgh: depends on the project. typically, the procedure is fork, commit to fork, tell upstream
07:43:24 <tdammers> mbwgh: many projects these days use github to handle the forking and the telling upstream
07:47:43 <mbwgh> So, I fork the project on github, clone the fork, hack away, and then what. Is remote/upstream the same? Should I introduce a feature branch or commit to `develop`? And in the end, I push into my forked repo and use github again to do the pull request?
07:48:56 <tdammers> forking on github makes a copy of the project in your github account
07:49:19 <tdammers> then you clone that copy to your workstation, make changes, commit them, and push them to your fork
07:49:41 <tdammers> and then, in github, you can create a pull request based on your fork
07:49:51 <tdammers> "remote" and "upstream" are not the same
07:50:22 <tdammers> "remote" is a git term, referring to a repository elsewhere (outside the current clone), that you can interact with through pushing and / or fetching
07:51:00 <tdammers> "upstream" is more of a social thing; it means "the version of this project from which I originally forked, and / or against which I should issue pull requests"
07:51:39 <maerwald> it's the hut where the true master lives
07:51:45 <tdammers> many projects have a de-facto authoritative ("official") repository, so if that's the case, then that's going to be your upstream
07:51:51 <hexagoxel> ("upstream" is also a git term that associates a specific remote branch to a local branch)
07:52:15 <tdammers> hexagoxel: oh right...
07:53:33 <mbwgh> So, I want to add a small function to unliftio. It has two branches: master and runOnce. Is runOnce also a conventional name? Should I commit to master or runOnce?
07:56:06 <lyxia> use master
07:56:13 <lyxia> runOnce is probably some irrelevant branch
07:56:59 <mbwgh> And what about testing? If a project has travis/appveyor set up, do I have to do something?
07:57:23 <lyxia> nope
07:57:28 <mbwgh> And what is that dumb thing everybody does wrong the first time?
07:57:39 <lyxia> the tests will run when you make your PR
07:59:19 <lyxia> I can't think of a way you can get it wrong but maybe I lack imagination.
07:59:52 <mbwgh> For instance, should I bump the minor version, edit the Changelog, or is that something the maintainer does? Things like that maybe.
08:00:07 <maerwald> tdammers: do you guys give trainings?
08:00:18 <tdammers> maerwald: "you guys" being Well-Typed?
08:00:24 <maerwald> yeah
08:00:30 <tdammers> matter of fact we do
08:00:48 --- mode: glguy set +v Noob
08:02:55 <maerwald> who do I talk to? :o
08:03:11 <tdammers> well-typed.com ;)
08:03:36 <lyxia> mbwgh: you probably don't need to do anything like that. Some repos have a CONTRIBUTING file or a section in the README, and otherwise you can look at previous PRs to get an idea of what they should look like.
08:03:59 <Psybur> Iirc theres a way to define repeated stateful computations using 'fix'. That ringing a bell for anyone?
08:04:17 <c_wraith> fix is just an abstraction of recursion
08:04:22 <Psybur> (a, s) -> ((a,s) -> ...
08:04:29 <c_wraith> If you can write it with recursion, you can write it with fix
08:04:33 <lyxia> mbwgh: most of the time you just add your changes to the master branch and let the maintainer take care of the rest.
08:04:35 <Noob> Anyone can help?
08:05:18 <dmwit> Psybur: What is a "repeated stateful computation".
08:06:04 <Psybur> dmwit, taking the state from one evaluation and sticking it back into the function and repeating
08:06:54 <Psybur> s -> (a,( s -> (a, s -> ...
08:07:04 <mbwgh> Psybur: Everytime you write something like fun = go where go = ... if ok then pure 42 else go, you can write myfun = fix $ \go -> ... if ... instead. Since the type of fix is (a -> a) -> a, this works with monadic functions, where a ~ (m b), as well.
08:07:10 <dmwit> Psybur: https://hackage.haskell.org/package/List-0.6.2/docs/Control-Monad-ListT-Funcs.html#v:iterateM
08:08:16 <Psybur> No way to define this kind of computation at the type level? Or is that an infinite type error
08:08:34 <mbwgh> Psybur: So in a way, fix allows you to "capture the current continuation" and jump back to it if necessary. Meaning you can define any primitive recursive function as an anonymous closure in terms of fix.
08:08:46 <dmwit> Psybur: ListT (State s) a *is* that type.
08:09:39 <dmwit> Up to some niggles about newtype isomorphism and ListT having Nil, too. You can make a StreamT if you really want it that removes the Nil niggle.
08:10:03 <mbwgh> This might actually be an xy problem kind of thing. What do you want to do?
08:10:55 <dminuoso> Psybur: Think of `fix` as taking a function like a kind of string and tying a knot into both ends :P
08:11:02 <dminuoso> as in tying them together.
08:11:03 <dmwit> Psybur: (There's also mfix, but it definitely has a different type *and* behavior than I'm understand you to ask about.)
08:11:36 --- mode: dmwit set -o dmwit
08:11:40 <dyl> > fix error 
08:11:42 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
08:11:42 <dyl> For example
08:11:57 <ski> Psybur : do you want to feedback the output state as input state of the same call ?
08:12:10 <Psybur> ski, yes
08:12:14 <dminuoso> :t (fix error)
08:12:15 <lambdabot> [Char]
08:12:20 <dmwit> Psybur: Well... then mfix is for you.
08:12:26 <dmwit> Make sure you use the lazy State.
08:12:36 <ski> Psybur : or do you want to produce a new computation that given a new input state produces a new result, and a new computation that ... ?
08:12:42 <dminuoso> mmm mfix is just a kleisli fix isnt it?
08:12:56 <dmwit> ...and a lazy underlying monad, too.
08:13:03 <ski> Psybur : so basically `let (a,s) = f s in a' ?
08:13:04 <Psybur> And I dont necessarily want to use a monad. Can I just use it on a function s -> (a,s)
08:13:26 <dmwit> dminuoso: What does "just" mean there? Are you asking if `mfix = coerce fix`? I believe the answer to that is no.
08:13:36 <dminuoso> dmwit: huh no.
08:13:41 <dminuoso> :t fix
08:13:42 <lambdabot> (a -> a) -> a
08:13:50 <dmwit> Right, the types don't match.
08:14:20 <dmwit> Psybur: Sure, `runState . mfix . state`. ;-)
08:14:33 <dmwit> Psybur: Or ski's short snippet which doesn't use any libraries is quite clean as well.
08:14:38 <ski> @type fst . fix . (. snd)
08:14:39 <lambdabot> (b -> (c, b)) -> c
08:16:11 --- mode: glguy set +v N0oo0B
08:16:18 <ski> @type runState . mfix . (state . )
08:16:19 <lambdabot> (a -> s -> (a, s)) -> s -> (a, s)
08:17:27 <Psybur> @let r f = let (a,s) = f s in a
08:17:29 <lambdabot>  Defined.
08:17:35 <Psybur> :t r (+1)
08:17:37 <lambdabot> error:
08:17:37 <lambdabot>     Ambiguous occurrence ‘r’
08:17:37 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.r’,
08:17:47 <dmwit> (+1) doesn't return a tuple.
08:17:54 <Psybur> Oh right
08:19:27 <Psybur> @undef
08:19:27 <lambdabot> Undefined.
08:19:39 <dmwit> ski: The extra `s` argument in the `State`-based one is interesting. I suppose if `undefined` won't do as an argument for that, nothing will.
08:20:22 <dmwit> :t flip evalState undefined . mfix . (state .)
08:20:24 <lambdabot> (c -> s -> (c, s)) -> c
08:20:56 <Psybur> :t let (a,s) = (a+1,a+1) in s
08:20:57 <lambdabot> Num b => b
08:21:25 <dmwit> > let (a,s) = (0:a, 0:a) in s
08:21:27 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
08:21:46 <dmwit> > let (a,s) = (a+1, a+1) in s :: Expr
08:21:53 <lambdabot>  mueval: ExitFailure 1
08:21:59 <dmwit> mhm =)
08:22:37 <dmwit> > let (a,s) = (1+a, 1+a) in s :: Expr
08:22:39 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
08:24:39 <ski> @type L.r (+1)
08:24:40 <lambdabot> error:
08:24:40 <lambdabot>     Not in scope: ‘L.r’
08:24:40 <lambdabot>     No module named ‘L’ is imported.
08:24:57 <ski> (hm, it got renamed ?)
08:25:39 <dolio> The 'extra s' is mfix taking a stateful fixed point, not taking a fixed point of states.
08:26:05 <dolio> So if you feed it `undefined`, you're saying that the input state is undefined. So it's probably the least likely thing to work.
08:26:35 <dolio> Unless your stateful function doesn't really care about the state.
08:31:19 <dolio> I.E. mfix is `\s -> let (a, s') = f a s in (a, s')`
08:32:32 <dolio> The value is recursive, not the computation.
08:38:19 <dmwit> dolio: Ah, thank you.
08:39:21 <dmwit> In which case mfix is a bad suggestion to make in the first place.
08:39:43 <dolio> If you want the state to be self-referential, yeah.
09:10:45 <danza> anybody would give me some hints about how to approach an infinite loop at runtime? stack profiling seems to be targeted at test suites. is it a good approach to try to debug the executable?
09:11:32 <danza> i already checked the warnings with `-Wall`, i don't think i can get more from static analysis
09:14:40 <jose_zap> how do you know it is an infinite loop?
09:15:47 --- mode: glguy set +v wroathe
09:16:18 <danza> i assume it is, by the way it gets all the CPU without taking memory, taking excessive time to terminate
09:17:56 <glguy> wroathe: read your messages
09:18:23 <wroathe> glguy: send one more time, sorry
09:18:30 <wroathe> accidentally closed the window
09:19:10 --- mode: glguy set -v wroathe
09:22:17 <jose_zap> danza then I would definitely enable stack profiling
09:22:52 <danza> so does that work by adding a wrapper to the executable, which parses the `+RST -p` options?
09:23:53 <jose_zap> danza there is no wrapper, the profiling flag will make the compiler change it's output so it generates stats
09:24:02 <jose_zap> by passing the flag you activate the stats gathering
09:25:06 <danza> when i tried ` stack exec -- my-exe +RTS -p` with my executable i just got an option parsing error by my exe ... maybe this works only for test suites?
09:25:17 <danza> https://docs.haskellstack.org/en/stable/GUIDE/#debugging
09:26:46 <danza> my battery is almost over but danza-cloud will stick around, i will read from it later
09:44:49 <wroathe> .
09:52:55 --- mode: glguy set +v tin__
09:53:38 <glguy> tin__: check your messages
09:55:21 <dmwit> danza-cloud: Compile with `-rtsopts`. It may also be the case that stack itself soaks up your RTS options (I don't know) in which case you might try `stack --RTS exec -- my-exe +RTS -p` might help with that.
09:55:40 <dmwit> Nailing it on the grammar there.
09:56:04 <danza-cloud> thanks dmwit 
09:57:04 <tin__> hi, I have a weird installation problem.. I had installed haskell-platform in an ubuntu machine without any problems, but now I realised that hp2ps is missing
09:57:11 <dstolfa> dmwit: grammar is hard
10:02:04 --- mode: glguy set +v EdwardIII
10:03:03 <EdwardIII> hey, the mac download page (https://www.haskell.org/platform/mac.html) says "If you would rather install with MacPorts or Homebrew then select the appropriate option to the right." but there is no right? i see 2 packages when i do brew search: haskell-stack and haskell-for-mac
10:04:03 <glguy> EdwardIII: https://github.com/Homebrew/homebrew-cask/pull/47908
10:04:22 <glguy> "This seems to be equivalent to brew install ghc cabal-install stack"
10:05:16 <EdwardIII> glguy: cool, thanks!
10:06:54 <cocreature> tin__: by “missing” you mean it’s not in your PATH or it’s nowhere on your disk?
10:10:23 <tin__> I guess is nowhere, at least is not at /usr/bin
10:13:08 <cocreature> tin__: where does "which ghc" point to?
10:17:22 <tin__> ghc is in /usr/bin
10:17:44 <tin__> other ghc related tools are also there, for example hpc
10:18:09 <cocreature> tin__: is that a symlink or maybe some bash script that calls the actual binary?
10:21:51 <cocreature> tin__: e.g. for me the binary is in lib/ghc-8.4.3/bin/hp2ps which on your system is probably either /usr/lib/… or /usr/local/lib/…
10:37:21 <jose_zap> danza-cloud did you compile with --profile?
10:40:54 <tin__> thanks cocreature
10:56:45 <danza-cloud> jose_zap yes, i didn't pass `--rtsopts` like dmwit suggested though ... i'll give it another try
11:06:49 <danza-cloud> so, `--profile` doesn't seem to add `+RST` parsing to my command, while `--rtsopts` is not a valid stack option. i would like to investigate better how to enable profiling in the future. anyway, removing most warnings also removed the loop i had, so now i have no need to debug the runtime
11:07:13 <glguy> You mean +RTS ?
11:08:00 <danza-cloud> yep ... does it get added to all executables, or just to test suites? i don't seem to get it in my executable when building with `stack build --profile`
11:08:17 <danza-cloud> referring to https://docs.haskellstack.org/en/stable/GUIDE/#debugging
11:28:39 <dmwit> danza-cloud: The flag is `-rtsopts` (one `-`), and it's a GHC option. Dunno how to ask stack to use specific GHC options. With cabal you add something like `ghc-options: -rtsopts` to the appropriate place in your cabal file. Although I admit I would have expected a profiling build to turn this on already.
11:36:27 <hololeap> numeric-prelude depends on HTam, which apparently doesn't exist: http://hackage.haskell.org/package/numeric-prelude ... is it possible it got deleted?
11:41:53 <dminuoso> hololeap: It used to exist once from what I can gather with archive.org https://web.archive.org/web/20160826102651/http://code.haskell.org/~thielema/htam/
11:43:03 <glguy> hololeap: It's unlikely that it was deleted from Hackage. It's more likely that it was never uploaded. It's only needed to build the examples
11:48:15 <hololeap> thanks
11:49:01 <infandum> Does parMap make duplicates of data?
11:49:37 <danza-cloud> dmwit: exactly, with stack one could use `-ghcoptions=-rtsopts` but i assume that's already passed by `--profile`. anyway i'm not going to try further at this point, thanks for the ideas +1
11:49:39 <infandum> Like, if I do parMap (f y) xs, is y duplicated for each element in xs?
11:52:47 <dminuoso> parMap :: Strategy b -> (a -> b) -> [a] -> [b]
11:53:49 <monochrom> No. But read the core code to be sure.
11:54:54 <infandum> oh sorry, it would be parMap rdeepseq
12:10:58 <dolio> monochrom: Was that a punishment for not understanding the semantics of Haskell? :P
12:12:11 <monochrom> Ah. Sometimes learning and punishment are difficult to distinguish. :)
12:12:46 <geekosaur> "not another goddamn learning experience"
12:40:06 <droplet> Is one of mtl or transformers currently preferred over the other in general?
12:42:14 <monochrom> They are both preferred :)
12:43:08 <monochrom> It is better to study your specific purpose and seek to suit it.
12:44:38 <johnw> I'd say: Write using mtl as much as you can, IF it will ever be used in multiple contexts. Transformers will be used to provide the context (by calling runReaderT, for example, or in the definition of your application's various concrete transformers)
12:46:07 <monochrom> mtl is one layer on top of transformers. You can't lose if you get both.
12:46:44 <monochrom> They are now accomplices not rivals.
12:47:58 <zzz> ?src maxBound
12:47:58 <lambdabot> Source not found. Where did you learn to type?
12:48:31 <suzu> lol ^
12:48:35 <monochrom> maxBound is a method of Bounded.
12:49:08 <monochrom> I learned to type on a typewriter.
12:49:21 <monochrom> Mechanical, not electronic, too.
12:50:38 <zzz> where can I get the definition of functions? I'm new to Haskell :p
12:51:00 <ddellacosta> zzz: you mean the docs, or the actual code?
12:51:46 <ddellacosta> zzz: one good place to start is hoogle: https://www.haskell.org/hoogle/
12:51:57 <ddellacosta> assuming I understand what you're looking for
12:52:10 <monochrom> lambdabot knows some function definitions, but maxBound is not one of them.
12:52:24 <ab9rf> hm, i probably really learned to type on a computer
12:52:40 <ab9rf> i used a typewriter first, but i was never very good at it
12:53:05 <ab9rf> i do remember typing my eighth grade term paper using an IBM Selectric and a fuckton of correcto tape
12:53:16 <zzz> the actual code would be nice
12:53:17 <AL-YISVN> if you want to see the actual code you can find it on the hackage page for the module
12:54:09 <AL-YISVN> specifically there's a link labeled 'source' in the top right corner
12:55:34 <zzz> thanks!
13:00:15 <dmwit> For maxBound specifically, the value it evaluates to is almost certainly also its definition.
13:01:55 <dolio> Ah, well, for e.g. Int, the definition is much less clear than that. :)
13:03:48 <dmwit> Yes, I just went to the documentation for base and checked out a few. I was surprised at how often the definition is not syntactically equal to the value it evaluates to.
13:05:15 <dmwit> Many instances are derived. For the number types, the instances are allergic to fromInteger, and often include some CPP.
13:05:48 <dmwit> I feel as though I have learned something, although I'm not certain it was useful to learn it.
13:06:56 <dmwit> I also learned that the haddocks' source link is very wrong in a lot of cases.
13:07:07 <dolio> Well, you can't really do Int by writing down a number.
13:07:13 <dolio> Or Word.
13:07:31 <dolio> The specific sized versions you could.
13:08:23 <dmwit> Yes, Int and Word use CPP. But inside the CPP they write down a (unboxed) number.
13:08:48 <dolio> Oh, really? Someone was just talking about how there's `maxInt` somewhere, or something.
13:09:13 <dolio> Is that not used in maxBound?
13:09:32 <dmwit> Oh, well, yes, there's one layer of indirection. maxBound = maxInt, then maxInt = #if 32-bit bignumber# #else biggernumber# #endif
13:09:40 <dolio> Oh, okay.
13:25:33 <pmade> I have a package that contains a library and an executable.  When trying to build a static binary on Linux (NixOS) GHC complains that it can't find the .so for the library when compiling Main.hs.  Of course, there's no .so, just a .a.  Is there an executable-specific flag that I'm missing that GHC needs?
13:26:45 <jeltsch> cocreature: I have trouble building llvm-hs. I’ve installed the binary distribution of LLVM 6.0.1 from the LLVM website. Building llvm-hs fails with the error message “llvm-config: error: libLLVM-6.0.so is missing.” Well, there is no such file in the LLVM distribution. Any ideas?
13:27:08 <zzz> "I feel as though I have learned something, although I'm not certain it was useful to learn it." - a Haskell programmer
13:27:32 <zzz> am I doing this right?
13:29:12 <chreekat> pmade: how are you compiling the executable?
13:29:50 <lkurusa> zzz: it's always useful to learn
13:30:54 <pmade> chreekat: nix-build, which is using Setup.hs I believe.
13:31:37 <zzz> lkurusa: no doubt about that
13:32:02 <monochrom> No, I am so glad I still haven't learned PHP. :)
13:32:43 <lkurusa> monochrom: i stand corrected :)
13:32:57 <lkurusa> although, it might be useful to learn, so that you now how not to do a couple things :)
13:33:07 <lkurusa> know*
13:34:18 <chreekat> pmade: I use disableShared for that and don't have to add any ghc flags by hand
13:35:18 <pmade> chreekat: Is that the same as `enableSharedLibraries = false;`?
13:35:19 <chreekat> * disableSharedExecutables
13:35:28 <chreekat> sorry, bbl
14:00:49 <dmwit> zzz: You twisted my words most expertly, sir. =)
14:01:43 --- mode: glguy set +v Darwin226
14:01:54 <Darwin226> Anyone here familiar with gloss?
14:06:10 <dmwit> ?where justask
14:06:10 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
14:06:25 <Darwin226> fair enough
14:06:33 <Darwin226> Anyways, in the play/simulate modes
14:06:50 <Darwin226> the update function gets a float parameter that's supposed to be the delta time for the current frame
14:07:20 <Darwin226> this is where you usually get how long the previous frame lasted
14:07:27 <Darwin226> however
14:07:50 <Darwin226> it seems that in gloss I just get a constant 1 / whatever I specified as the desired framerate
14:08:11 <Darwin226> which is useless since I'm the one specifying it, might as well calculate that constant myself
14:08:37 <Darwin226> I found the relevant code and git blame tells me it hasn't been touched in 2 years so it's not like this got broken recenly
14:09:16 <Darwin226> Other than that my program seems to be exibiting the "spiral of death" if the update + draw take more than the allocated time
14:09:41 <Darwin226> instead of just dropping the framerate, each frame freezes for a bit longer than the last one
14:10:09 <Darwin226> this is what usually happens with badly implemented game loops but it's kind of weird to happening here since the loop is handled by glut
14:10:28 <Darwin226> If anyone has any thought, I love to hear them
14:10:53 <dmwit> I guess I'm not too surprised that a library that was designed to be a good pedagogical tool turned out not to be great for a serious application, though I am sorry that it sounds like you've invested a pretty serious chunk of time into it before discovering its limitations.
14:11:30 <Darwin226> I don't think it's that simple. This seems much more like a bug than a limitation
14:12:20 <Darwin226> I've played around with gloss before and it actually performs better than I expected
14:13:18 <Darwin226> and it's not that much time. After all, one of the main points of gloss is that you can get up an running very fast
14:13:56 <dmwit> Out of curiosity, are you using the threaded runtime?
14:14:45 <Darwin226> I'm actually running it through ghci
14:15:17 <Darwin226> it, of course, performs much better when compiled, but the only consequence should be a lower framerate
14:15:29 <dmwit> Do you see the same behavior when compiling with -O2 -threaded?
14:15:46 <dmwit> Well, -threaded can make a big difference even if the framerate stays the same.
14:15:47 <Darwin226> No because my frames take less than 16ms to update
14:16:03 <Darwin226> but I'm guessing I would, I'll try to stress test it
14:16:05 <dmwit> Especially with FFI-heavy code like I assume this is.
14:16:06 <Darwin226> stand by
14:18:03 <fresheyeball> hey out there
14:18:13 <fresheyeball> is there any harm to unused dependencies in a cabal file?
14:18:27 <fresheyeball> is there a reason not to make all exe's have the same long dependency list?
14:18:33 <dmwit> Longer compilation times, and maybe the dependency solver has a harder time finding a solution.
14:18:51 <dmwit> Probably with static linking it will make your executable bigger, too.
14:19:21 <Darwin226> Yeah, same thing happens with the compiled version. Each frame takes longer than the last
14:19:28 <dmwit> drat
14:20:07 <Darwin226> do you know the flags I need to get a printout of runtime statistics after a program runs?
14:20:36 <fresheyeball> dmwit: how about runtime? any impact?
14:20:45 <dmwit> Probably not.
14:20:46 <fresheyeball> larger binaries?
14:20:51 <dmwit> Probably yes.
14:21:39 <dyl> Anyone have any recommendations for vim+haskell?
14:21:55 <dyl> I'm, as usual, lost in the myriad options, all with slightly different support for slightly different scenarios :/.
14:22:07 <mrArkwright> Hi everyone. I can't seem so get a do block inside a let binding inside another do block to work. I'm getting a parser error and can't figure out why. Is there any reason why this cant's work in principle? https://lpaste.net/2713359028200669184
14:22:07 <dmwit> Roll your own. ;-)
14:22:20 <mrArkwright> replacing the do block with an equivalent function seems to work
14:22:29 <dyl> Learning vimscript properly is still a bit down my todo list :p.
14:22:31 <dmwit> Darwin226: Not offhand, but the GHC manual has detailed information on profiling.
14:22:56 <dyl> I'd just like something that works with cabal new-* nicely and to have completions.
14:23:04 <Darwin226> mrArkwright: Yeah, it needs to be indented past the 'let' keyword
14:23:06 <dmwit> mrArkwright: The contents of the inner `do` must be indented further than the `f` of `foo`.
14:23:09 <dyl> Is neco-ghc still maintained?
14:23:20 <dyl> ...is ghc-mod even still used?
14:23:43 <mrArkwright> ah. great. thanks a lot (:
14:24:29 <Lycurgus> dyl, not with current ghc apparently
14:24:43 <dyl> \o/
14:25:38 <dmwit> dyl: ctrl-n works well enough for me without any plugins.
14:27:39 <dmwit> What do you want vim to do to "work with cabal new-*", out of curiosity?
14:27:42 <dyl> My demands are modest: 1) basic refactoring, 2) completions (ideally type-aware), 3) show type/repl, 4) 10% of the gross domestic product of Sweden.
14:28:03 <dyl> Meaning I'd like it to be aware that it is in a cabal project and of what modules are available.
14:28:07 <dyl> I do not use stack.
14:28:38 <ab9rf> dyl: can i interest you in a lightly-used late model helicopter?
14:29:18 <dyl> ab9rf depends... is yaw insured as well as pitch and roll?
14:29:31 <dyl> I'm not getting into one of these "oh, we only insured two axes of rotation" scams again.
14:29:41 <dmwit> dyl: I use kien/CtrlP for jumping between modules, plus sometimes vim-yard for when finding the appropriate root directory for CtrlP to play in is especially difficult.
14:30:39 <dyl> inline documentation, or at least good 'jump-to-definition' is also important.
14:32:57 <dmwit> hasktags is good for jump-to-definition. In complicated cases, I use cabtags.
14:33:27 <dmwit> https://github.com/dmwit/cabtags
14:34:11 <dyl> "cabtags is a terrible hack for parsing cabal project files and cabal package files in shell and using the information in them to build this explicit list of subdirectories to pass to hasktags."
14:34:16 <dyl> \o/
14:35:12 <dyl> I finally got my vim/tmux integration set up nicely though.
14:35:29 <dmwit> Good news: I just learned in #hackage of a new cabal feature that will upgrade this from "terrible hack" to "officially supported". But you've gotta wait for a cabal release + something that makes cabtags break so hard I'm willing to put in the time to make it work right. =P
14:35:34 <dyl> I kind of like having ctrl-<h,j,k,l> just spawn new tmux/vim splits when you hit edges.
14:40:24 <dyl> \o/ 
14:40:34 <dyl> backspace in tmux no longer works <3.
14:41:38 <dmwit> I can't tell whether you use \o/ as a positive or negative emoji.
14:41:46 <dyl> dmwit yes
14:41:59 <dyl> It's simply 'throwing hands up'
14:43:21 <dmwit> That sounds painful, and also how did those hands get in your stomach in the first place?
14:44:17 <dyl> My stomach was making the rumblies...
14:44:21 <dyl> that only hands would satisfy!
14:48:11 <ab9rf> dyl: CARL!
14:52:56 <fresheyeball> is there a callHpack2nix in the works?
14:56:56 <MarcelineVQ> what would be the main advantage?
14:57:27 <fresheyeball> I could use hpack without commiting the .cabal result
14:57:34 <fresheyeball> right now I use hpack and callCabal2nix
14:57:42 <fresheyeball> which means its on my to keep the files in sync
14:59:44 <dyl> So, I’m a bit confused. 
14:59:59 <dyl> HIE appears to have support for newer GHC... but ghc-mod doesn’t.
14:59:59 <glguy> Maybe put your hands over your head?
15:00:03 <dyl> Are they out of sync now?
15:00:26 <monochrom> What is HIE?
15:00:31 <fresheyeball> haskell ide engine
15:00:35 <monochrom> Ah.
15:00:37 <dyl> It would be quite nice to be able to read the local cabal new-* setup, 
15:00:37 <MarcelineVQ> haskell ide engine, which I think has a faq about that, or ghc-mod does
15:00:42 <dyl> and then type search locally.
15:00:50 <dyl> :/
15:01:45 <dyl> Also not sure of a good REPL option, though I’m fine with just using tmux.
15:02:37 <dyl> Haskell IDE is a lot like Linux on the Desktop. 
15:03:18 <dyl> It resembles the eschatology of some doomsday cult.
15:03:22 <dyl> “Soon!” 
15:04:28 <MarcelineVQ> have you tried it recently?
15:04:41 <dyl> No, I mean the concept of a haskell IDE.
15:05:04 <dyl> I can never quite figure out a decent setup that doesn't involve emacs.
15:05:19 <MarcelineVQ> It has a guide on its main page for installing for various editors
15:05:35 <dyl> I just want decent IDE features in my vim.
15:05:59 <dyl> Or at least a stable, functional, basis on which to build my own.
15:06:13 <MarcelineVQ> seen https://github.com/haskell/haskell-ide-engine#using-hie-with-vim-or-neovim ?
15:06:30 <dyl> That's what I'm looking at currentl.
15:07:33 <ChaiTRex> How can I do debug prints within an attoparsec Parser?
15:09:08 <mbwgh> Is a SIGINT handler for an interactive command line application in the style of `ctrlC Interrupt = handle ctrlC $ do {- ask for confirmation -}`, i.e. one that *really* would like you to confirm that you want to quit, in bad taste?
15:09:33 <ChaiTRex> mbwgh: Not if pressing Ctrl+C a second time kills it.
15:09:43 <ChaiTRex> mbwgh: And if quitting accidentally is costly.
15:10:18 <ChaiTRex> mbwgh: If it's not costly to accidentally quit, it should just quit.
15:10:31 <dyl> Bah, stack.
15:10:42 * dyl curmudgeons.
15:11:05 <monochrom> ChaiTRex: There are some tools in Data.Debug that suit this.
15:11:11 <monochrom> Err, Debug.Trace
15:11:41 <mbwgh> ChaiTRex: I use Ctrl-C to return from sub-menus to previous menus, but that might mean making Ctrl-C a force of habit. So the top-most ctrl-C handler asks for confirmation, and is explicitly not killed by pressing Ctrl-C a second time, since the handler is its own handler...
15:11:50 <dyl> haskell-ide-engine doesn't even have any instructions for not using stack ://.
15:12:01 <dyl> Nor any indication of what it installs, or where :\.
15:12:45 <glguy> dyl: Wouldn't anything it installs be described in its .cabal file anyway?
15:12:55 <dmwit> mbwgh: Just to talk about bikeshed colors: ESC is a more common keybinding for "go up one level of menu", I think.
15:12:55 <glguy> or does it do something particularly creative?
15:12:56 <zzz> where can i elucidate myself on the syntax: data Type a => Class a = !a :+ !a ?
15:12:57 <ab9rf> i would think it would have to be
15:13:12 <ChaiTRex> mbwgh: Consider Esc instead.
15:13:14 <glguy> zzz: You'd want to go back in time for that
15:13:15 <mbwgh> ChaiTRex: This is of course not ideal, but with haskeline you only have the choice of either getting one char, or a string, the latter of which requires to press enter.
15:13:20 <ChaiTRex> monochrom: Thanks, I'll check it out.
15:13:24 <dyl> glguy I'm just lost in the new tooling.
15:13:57 <zzz> glguy: deprecated?
15:13:59 <glguy> zzz: Actually, can you be more specific about which part of that syntax you don't understand?
15:14:04 <dmwit> zzz: I think you may have misdiagnosed something, assuming you intended `Type` to be the name of a type and `Class` to be the name of a class.
15:14:06 <mbwgh> dmit, ChaiTRex: Is that possible with haskeline?
15:14:07 <glguy> one part was deprecated but there's a lot more there
15:14:13 <ab9rf> zzz: do you have a more concrete example that you wish to inquire about?
15:14:43 <monochrom> Yeah please don't generalize your question.
15:14:48 <subttle> Hi, pardon me, I have a question regarding ends/coends and I don't have a PhD :P 
15:14:51 <subttle> The situation is that I have a data type for an epsilon-NFA (`data EFA q s = ...`) and then another data type which wraps that and makes `q` (the type parameter for the set of states, Q) into an existential.
15:14:53 <ChaiTRex> mbwgh: Sorry, I'm not sure about Haskeline.
15:14:57 <subttle>  It looks like `data SomeEFA s = forall q . (Finite q) => SomeEFA (EFA q s)` and I'm trying to figure out a way to operate "inside" the `SomeEFA` constructor, I'm pretty sure I want ends/coends but I don't have a PhD and I don't have two weeks to learn all the stuff (I probably will anyway :P) just to find out it's not actually what I need. 
15:15:04 <subttle>  Would anyone mind just telling me if that is actually what I want? I will be extremely grateful :) Thank you
15:16:04 <monochrom> WTH is EFA?
15:16:09 <jle`> what is an end/coend in this context?
15:16:16 <subttle> EFA = epsilon NFA
15:16:28 <monochrom> Sure. Actual code?
15:16:29 <subttle> I'm looking to do something like this..
15:16:33 <ab9rf> zzz: the reason i ask is because !a :+ !a is the constructor for the Complex type from Data.Complex in base
15:16:37 <jle`> what do you mean by 'operate inside'?  what sort of things did you want to do specifically?
15:16:55 <monochrom> Yeah please don't ask highly generalized abstractified questions.
15:16:56 <subttle> fromList  w = foldl1 (\(SomeEFA acc) (SomeEFA b) → SomeEFA (concatenate acc b)) (fmap (SomeEFA . literal) w)
15:17:02 <dmwit> subttle: It sure doesn't seem like ends/coends should be necessary. Anyway I've written a bunch of code that deals with existentials, and I don't know what ends/coends are either.
15:17:24 <jle`> subttle: why doesn't that work?
15:17:35 <subttle> but I don't want to have to deconstruct and then rewrap every time
15:17:42 <subttle> that does work, jle` 
15:17:55 <subttle> dmwit: Okay, that is good to know :D
15:18:06 <jle`> subttle: i suppose you can write a higher-order function to abstract over unwrapping and rewrapping?
15:18:26 <jle`> combineSomeEFA f (SomeEFA x) (SomeEFA y) = SomeEFA (f x y)
15:18:40 <jle`> then you can do foldl1 (combineSomeEFA concatenate)
15:18:55 <dmwit> I don't think you're going to be able to avoid unwrapping and wrapping. The type of your EFA is changing there, presumably.
15:19:00 <subttle> jle`: exactly, I thought that's where the coend would come in, I just wanted to know if that was the abstraction for dealing with that :)
15:19:06 <jle`> what is a co-end?
15:19:11 <jle`> coend?
15:19:12 <mbwgh> dmit, ChaiTRex: In any case, if I wanted to over-engineer, I would've added the brick dependency. I guess I might consider tracking the time since the last ctrl-C and quit if it is pressed twice quickly.
15:19:13 <dyl> Like an end but the other way.
15:19:18 <jle`> ooh yeah
15:19:36 <jle`> subttle: it sounds like this would be a pretty simple solution?
15:19:43 <jle`> are you perhaps looking for something more complicated, that you can show off? :)
15:19:44 <dyl> Am I just biased against stack because I'm not used to it?
15:19:55 <dyl> 🤔
15:20:00 <jle`> there are many potential reasons dyl 
15:20:16 <subttle> jle`: I'll give that a whirl first and see :)
15:20:16 <jle`> human bias is a complicated subject
15:20:21 <dyl> I haven't been able to figure out what it is that it does concisely.
15:20:26 <dyl> It seems to do many things.
15:20:45 <jle`> subttle: no problem :) yeah, it does sound like you're trying to over-complicate things by a lot heh
15:20:56 <jle`> this "higher order function" pattern is a very common design pattern in haskell
15:21:07 <jle`> we have things like map f (x:xs) = f x : map f xs
15:21:08 <dyl> I just want to install HIE, and it's building ghc again.
15:21:14 <jle`> fmap f (Just y) = Just (f y), etc.
15:21:22 <jle`> those exist to "avoid unwrapping and wrapping"
15:21:28 <dyl> Oh.
15:21:33 <jle`> and it's somethign most haskellers learn pretty early, no PhD required :)
15:21:34 <dyl> Now it's installing another version of GHC.
15:21:35 <dyl> Why.
15:21:42 <dyl> Why do I need 8.4.3 and 8.2.1 for this.
15:22:02 <MarcelineVQ> because you didn't specify the 8.2.1 resolver?
15:22:06 <subttle> jle`: exactly, I'm used to that so when I keep unwrapping, manually applying functions, and then rewrapping it just feels like I'm missing something lol
15:22:14 <dyl> It started installing 8.2.1 for happy, it appears.
15:22:16 <mbwgh> dyl: Because the library uses a specific "resolver", which ties it to a specific stackage snapshot, i.e. a curated set of library versions, and a ghc version.
15:22:31 <dyl> Well, the library uses 8.4.3. But it looks like happy doesnt.
15:22:32 <monochrom> Actually the 8.2.1 part is odd because it's superceded by 8.2.2
15:22:42 <dyl> This makefile has "stack --stack-yaml=stack-8.2.1.yaml install happy" :/.
15:22:44 <dyl> Who knows why.
15:22:52 <subttle> well, I think I have the guidance I need for now, thank you very much channel!!
15:23:22 <jle`> subttle: no problem :)  just a note, combineSomeEFA as I wrote it won't work without a RankN type signature
15:23:30 <mbwgh> dyl: Since happy is a binary, at the time the bootstrap script was written it didn't built with 8.4.3 yet?
15:23:50 <mbwgh> or makefile in this case
15:23:56 <subttle> jle`: okay cool, thanks mate!
15:24:56 <jle`> the type should be something like combineSomeEFA :: Finite q' => (forall q r. (Finite q, Finite r) => EFA q s -> EFA r t -> EFA q' s') -> SomeEFA s -> SomeEFA t -> SomeEFA s'
15:25:35 <MarcelineVQ> using the make file? the make file builds all versions of hie, so yes it'll want more than one ghc
15:25:37 <mbwgh> dyl: In any case, downloading and installing ghc is something that stack does and ghc does not. Also when stack came out, telling newcomers to just "cabal build && cabal install" was a given and people would get frustrated when it fucked their shit up
15:25:57 <zzz> sorry nevermind. i was indeed very confused
15:26:16 <mbwgh> dyl: s/ghc/cabal
15:26:28 <mbwgh> argh
15:26:36 <dyl> I just want cabal build/install to work though.
15:26:39 <dyl> And now they don't :)
15:26:45 <dyl> (in this particular project haha.)
15:26:56 <dyl> But yeah, I'm aware how obnoxious cabal hell was...
15:27:12 <dyl> Still, now there's this big opaque blob of tooling I don't understand that promises to fix it and confuses me :(.
15:28:54 <monochrom> What you install via stack, you can only access via stack commands again.  At least for most stack configs.
15:29:02 <mbwgh> dyl: It's really just either cabal (new-build) or stack. Both work fine. Ups & downs exist, like stack being able to pull ghc, or cabal being compatible with backpack. If you're fine with cabal, you don't need stack. If somebody wants to build a cabal project with stack, they `stack init` and move one. We can all co-exist :)
15:29:02 <dyl> stack kind of feels like it wants to be a unikernel type deal. 
15:29:04 <dyl> but it's not.
15:29:31 <dyl> mbwgh yeah, seems like it's just this project that isn't working for me with plain cabal.
15:29:35 <monochrom> As usual, every issue associated with open world is solved by switching to walled garden.
15:30:32 <Lycurgus> thus spake monochrom 
15:30:56 <Lycurgus> grace hopper's best: easier to ask forgiveness
15:31:02 <mbwgh> monochrom: I am not sure about libs, but for binaries, stack install just builds and copies to ~/.local/bin .
15:31:15 <dyl> Appears to be the case.
15:31:23 <dyl> Though I'd hope it caches these dependencies.
15:31:28 <dyl> (and ghc installations...)
15:31:36 <monochrom> Imagine in a cellphone channel, people exchange notes about "Android app market hell", and their blanket solution is "buy an iPhone instead".
15:31:46 <mbwgh> dyl: It does, on a per-resolver basis.
15:31:55 <MarcelineVQ> That is not occuring here.
15:31:55 <glguy> monochrom: is that not what happens?
15:31:58 <dyl> monochrom that is my blanket solution though ;p
15:32:20 <monochrom> mbwgh, but libs are the most important aspect for #haskell participants.  This is not #xmonad (where people just need exes).
15:32:45 <dyl> stack feels like it was made for people who are haskell ecosystem consumers. 
15:32:50 <dyl> i.e. writing end-user applications and services.
15:33:11 <Lycurgus> the analogy is somewhat strained, apple's closed market actually works, delivers the desired end thing, fungible apps, in toto
15:33:29 <jle`> dyl: yeah, stack has a good user experience for that i think, esp with stack scripts
15:33:43 <jle`> but i also like how stack integrates well with stackage
15:33:52 <jle`> fits like a glove
15:34:16 <jle`> but how valuable that is to you depends on how valuable you find stackage
15:34:17 <dyl> I'm going to make a new toolchain that requires wheel and trashes your system directory.
15:34:19 <dyl> I call it frack.
15:34:20 <monochrom> jle`, I respect you a lot, but that sounds like "iOS integrates well with iTunes"...
15:34:23 <dyl> It integrates with frackage.
15:34:35 <dyl> Nothing integrates well with iTunes.
15:34:38 <dyl> Least of all iOS devices.
15:34:43 <monochrom> Heh OK!
15:34:52 <jle`> monochrom: heh, it was meant to sound that way ;)
15:34:58 <monochrom> Haha
15:35:00 <dyl> I say this as someone who's pretty squarely inside the Apple garden.
15:35:01 <mbwgh> monochrom: Like I said, I don't really know in what aspect stack is considered to be flawed regarding packages. Likewise, I can't follow the walled garden analogy - after all, using dependencies from outside stackage, be it hackage or github, isn't hard.
15:35:07 <jle`> there was an implication of "...compared to cabal"
15:35:14 <jle`> *cabal-install
15:35:35 <jle`> i think it's possible to separate the benefits of stack at large from the benefits of stackage
15:35:39 <dyl> What stack seems to do that is valuable is lock down a common denominator (LTS/resolver).
15:35:44 <monochrom> mbwgh, I am stating that stack is a control freak. This is or is not a flaw depending on you.
15:35:49 <jle`> that difference i think is approximately what cabal-install is, give or take
15:36:01 <hexagoxel> dyl: did you try new-building hie, even though the readme admittedly does not mention it?
15:36:06 <dyl> It doesn't work :(
15:36:19 <dyl> Also some submodule issues that stack apparently handles that cabal doesn't.
15:36:44 <hexagoxel> i just confirmed that it finds an install-plan, at least
15:36:47 <dyl> Let's see.... trying to stack init first.
15:37:03 <dyl> "Warning: Installed version of cabal-install (2.2.0.0) is newer than stack has been tested with.  If you run into difficulties, consider downgrading."
15:37:06 <dyl> ...no
15:37:06 <mbwgh> monochrom: Could you please elaborate? I haven't seriously used cabal except that one time when I wrote hello-world...
15:37:24 <MarcelineVQ> stack init is for generating a stack.yaml from a cabal file, this repo has a stack.yaml
15:37:30 <dyl> hexagoxel 
15:37:34 <dyl> After searching the rest of the dependency tree exhaustively, these were the goals I've had most trouble fulfilling: haskell-ide-engine (2), ghc-mod-core.
15:37:35 <dyl> :/.
15:37:48 <dyl> I can't even get a build plan.
15:37:52 <jle`> mbwgh: walled-garden in the sense that all of haskell is meant to be interfaced with through a stack wrapper
15:37:57 <dyl> Sorry, that's from stack resolver.
15:38:00 <dyl> solver*
15:38:01 <jle`> mbwgh: for example, you can't use the system ghc/ghci
15:38:20 <jle`> you have to use the one that stack abstracts an interface over
15:38:25 <MarcelineVQ> there's no reason to be running a solver, the repo is already set up for stack
15:38:29 <hexagoxel> dyl: and you did init&update the git submodules?
15:38:51 <mbwgh> jle`: There is a system-ghc: field (commented out) in the stack.yaml that comes with the default template though...
15:39:05 <dyl> stack init won't go.
15:39:06 <jle`> mbwgh: yes, that lets you use system ghc through stack
15:39:07 <dyl> submodules are good.
15:39:15 <jle`> mbwgh: but that's the opposite direction i'm talking about, sorry
15:39:25 <jle`> i'm saying that you can't use the system ghc *without* stack
15:39:26 <dyl> Oh hey, cabal new-build is rolling now.
15:39:41 <jle`> you always have to go through stack
15:39:45 <MarcelineVQ> stack init is not an appropriate command, it shouldn't even try to run because a stack.yaml exists already...
15:40:11 <dyl> My bad, mixed them up.
15:40:29 <dmwit> jle`: To be fair, cabal is moving that direction, too, I think. Depending on exactly what you mean by that.
15:40:29 <dyl> I love how every third line is "ignoring (possibly broken) abi-depends field for packages", this fills me with confidence.
15:40:40 <monochrom> Does HIE really require stack? Or is it just providing stack-related config files so you can choose to go through stack but you don't have to?
15:40:41 <jle`> dmwit: i don't disagree, yeah
15:40:47 <glguy> dyl: That's a ghc glitch
15:40:47 <MarcelineVQ> dyl: cabal-install says that for me too
15:40:48 <dyl> monochrom it's not clear.
15:41:08 <MarcelineVQ> monochrom: no, it just helps align the tooling versions correctly
15:41:12 <hexagoxel> dyl: now we know which ghc version you use :D
15:41:13 <mbwgh> jle` Ok I get what you mean. You can of course add it to your $PATH manually, but at this point you start arguing about taste. I had a system ghc from my distro's repository for a while and ran into trouble at some point. So personally I appreciate the abstraction layer.
15:41:17 <dyl> It only really specifies installation instructions for stack, Nix and ArchLinux (aka the hypechain)
15:41:42 <MarcelineVQ> because the version of the tools matter in this sort of ide thing, ghc most importantly, but others as well
15:41:59 <dyl> It's a bit frustrating that the *minimal* installation instructions are not presented first.
15:42:15 <dyl> And by minimal I don't mean 'easiest modulo these big tooling assumptions'
15:42:35 <dmwit> Minimal installation instructions, step 1: locate a very fine magnet.
15:42:50 <dyl> step 2: tell the fine magnet how attracted you are to it
15:43:29 <MarcelineVQ> is minimal allowed to assume you know what versions of tools go together and that you can use cabal on a git repo you download yourself? because those can be pretty minimal instructions, but no less frustrating if you get it wrong
15:43:44 <dyl> minimal for me IS using cabal on a git repo.
15:43:46 <MarcelineVQ> put cabal-install on your path    https://github.com/haskell/haskell-ide-engine.git && cd haskell-ide-engine && stack install   is pretty darn minimal, even if it takes awhile
15:43:55 <dyl> i.e. using the minimal set of tools to do the job with the least baked in assumptions.
15:44:11 <dyl> The problem is that 'stack install' hides a LOT.
15:44:41 <dyl> It's a "rest of the f'n owl" trope.
15:45:13 <dyl> https://i.kym-cdn.com/photos/images/newsfeed/000/572/078/d6d.jpg
15:45:18 <MarcelineVQ> do you have hie installed via cabal yet?   I'd be testing along with you but cabal-install doesn't actually work properly on my system :(
15:45:27 <MarcelineVQ> with nix or not
15:45:32 <hexagoxel> new-builds also hides .. well more than cabal build did. but for a multiple-package project, the old-build instructions would not look "minimal" either
15:45:34 <dyl> Well, it's configuring and building, so that's a start.
15:46:03 <dyl> I think the install is about halfway through the kmettiverse.
15:46:07 <dyl> So we're making progress.
15:46:24 <glguy> git clone, submodule update, and cabal new-build have been working fine for me so far on h-i-e without any fuss so far, I'm up to hlint, brittany, and cabal-plan so far
15:47:33 <monochrom> dyl: Hey that's more succint than "1. Read the problem.  2. Think very hard.  3. Write the down solution."!
15:47:59 <dyl> "1. Read the problem. 2. Meditate under waterfall until enlightenment. 3. Emit a single fold expression."
15:48:10 <dmwit> dyl: My point, in case it was too subtle, is that "using the minimal set of tools" is incredibly vague. Maybe cabal is minimal to you; but to monochrom, GHC is more minimal. And the logical conclusion is to go, "well, maybe compiling by hand is more minimal still, and then you know you could actually touch the bits on the hard drive yourself instead of using device drivers, and...".
15:48:20 <dyl> Yeah, that's true.
15:48:27 <dyl> I guess ghc-pkg directly is too low, but stack is too high.
15:49:01 <monochrom> dmwit: Yeah, I was thinking of continuing your magnetic approach with "now hover your magnet over your hard disk to write the desired bits"
15:49:25 <dmwit> monochrom: I'm glad you got it, anyway. =)
15:50:04 <glguy> How long ago was it that a patient human could encode data by hand on a magnetic storage device?
15:50:24 <dyl> Depends on how much data you want to encode.
15:50:35 <glguy> I mean on the common devices of the day
15:50:47 <jle`> i mean i'm sure there are hobbyists these days that do so on their toy machines
15:50:55 <c_wraith> I don't think it was really possible in the 80s
15:51:07 <dmwit> glguy: I think one of our coworkers had a hand-built memory that he read and wrote bits on by hand. =)
15:51:11 <dyl> > when 'hacking' literally meant taking a fire axe to a recalcitrant steel panel to get at core memory with a rare earth magnet
15:51:13 <lambdabot>  error:
15:51:14 <lambdabot>      • Syntax error on 'hacking'
15:51:14 <lambdabot>        Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
15:51:31 <dmwit> Might not have been magnetic memory, though.
15:52:02 <dyl> True, these days you might pry up some digital floorboard and discover you've been using a VMM implemented with Mechanical Turk.
15:52:50 <mbwgh> hacking, TemplateHaskell. Heh
15:52:59 <dyl> I wonder how difficult it would be to write a filesystem that runs on mturk.
15:53:08 <dmwit> I remember as a kid my Dad screwed up our computer's BIOS once and had to toggle in a new one bit-by-bit on the motherboard itself. He wasn't controlling the magnet, though.
15:53:09 <monochrom> glguy: If you can relax from "data" to "metadata", it's fairly recent.  For example, suppose you said something bad and someone recorded it on tape and blackmail you.  After you have paid up, they will tear out the tape by hand to encode the 1-bit metadata "I now honour my side of the deal". >:)
15:53:16 <dyl> "When I copy this file, fifty cents is spent on making actual human beings edit inode records."
15:53:31 <dyl> That's... kind of dark.
15:54:00 <geekosaur> you start t understand AWS, etc.
15:54:45 <dyl> Or: TCP/Postmate.
15:55:35 <monochrom> dmwit: How many bits were there in that BIOS?
15:56:54 <dmwit> Not many. And there was some pre-BIOS or something that could display in hex what you had entered so far, so at least you could see if you made an error.
15:57:01 <dmwit> I don't remember the details; I was quite young.
15:57:22 <dmwit> It was a few screenfuls of hex digits, I think.
15:57:56 <dyl> Looks like it built ok!
15:58:05 <monochrom> Is HIE basically just a couple of exes? So that "stack install" is actually the simple right thing to do and you just need the exes it leaves in ~/.local/bin and that's it, no one cares if you lose stack's stuff afterwards?
15:58:17 * geekosaur is having flashbacks to the C1P's ROM monitor
15:58:20 <dyl> What's a reasonable default for --symlink-bindir?
15:58:38 <dyl> ~/.cabal/bin?
15:58:40 <geekosaur> whatever private bin directory you have in $PATH?
15:58:43 <geekosaur> or that
15:58:55 <hpc> obviously /sbin
15:58:56 <dyl> Or .local/bin, yeah.
15:58:59 <hpc> live on the edge!
15:59:04 <dyl> I've somehow managed to mostly avoid $PATHgore.
15:59:20 <monochrom> I am very skeptical that stack honours ~/.cabal/whatever at all. >:)
15:59:35 <dyl> monochrom ~/.cabal/bin didn't even exist :p.
16:00:45 <mbwgh> When it comes to stack, I get the impression some people take its existance personal
16:01:03 <dyl> I don't take it personally.
16:01:15 <monochrom> Sure. Like Katniss in Hunger Games says, "it's always personal".
16:01:17 <dyl> Cool. I have hie but not the hie-wrapper.
16:01:51 <jle`> ∃ p. takes stack personally(p)
16:02:18 <dyl> This is a good example of why stack *usage* bothers me: 
16:02:24 <monochrom> Hmm, maybe you won't need hie-wrapper.
16:02:28 <hpc> i can only hope to write a program so simultaneously useful and controvertial someday
16:02:29 <dyl> 1) The 'lowest common denominator' path of using cabal is undocumented.
16:02:45 <dyl> 2) Failing to use the high level blessed path leaves you with questions ("where is this wrapper coming from?")
16:02:50 <mbwgh> Like a great philosopher once said: That's just like, your opinion man
16:03:00 <dyl> That it is dude, that it is.
16:04:04 <dyl> monochrom probably not, so long as I stick to the known ok version of GHC.
16:04:11 <dyl> But, it's a bit odd, as hie-wrapper is specified in the .cabal.
16:04:30 <glguy> dyl: new-build builds the hie-wrapper, I got one
16:04:36 <dyl> odd.
16:04:47 <hpc> dyl: i think speaking a bit more generally, a lot of programmers just kind of shut down the programming part of their brain once they get to packaging
16:04:48 <mbwgh> Didn't you say you invoked the makefile?
16:04:56 <hpc> they forget that how you package something is still part of the api
16:05:07 <dyl> I don't appear to have gotten a hie-wrapper :|
16:05:08 <dyl> Odd.
16:05:22 <hpc> and "it installs" is not the minimum bar for functional packaging
16:05:24 <dyl> Then again I don't even know where artifacts are going haha.
16:05:50 <dyl> But, no hie-wrapper according to mdfind.
16:05:59 <glguy> You're definitely make things harder for yourself by going against all the documentation and scripting that they've built up around stack
16:06:25 <glguy> You don't get points for doing it on principle
16:06:29 <dyl> Well, yes.
16:06:46 <dyl> I just want to figure out how to do this manually so I understand what they're actually using stack for here.
16:07:15 <mbwgh> is mdfind a macOS only thing? Haven't heard of it before
16:07:21 <glguy> Running new-build or stack build either way isn't any more or less manual
16:07:24 <dyl> Yes, more or less like locate.
16:07:33 <hpc> i would be more curious what they are doing in the code that somehow makes it incompatible with plain cabal
16:07:39 <dyl> ^
16:07:42 <dyl> it doesn't appear to be much.
16:07:45 <dyl> If anything.
16:07:45 <hpc> why do they need all the extra crap
16:08:08 <hpc> in my experience, there's no reason for packaging to ever be bypassed like this
16:08:27 <hpc> whatever it is, make it happen at runtime or in a config file
16:08:56 <dyl> Found hie-wrapper, though it's not installing alongside hie with new-install.
16:09:15 <dyl> ...or actually that hie was just leftover and this isn't installing anything :p.
16:09:44 <hpc> i don't see hie on hackage either
16:10:06 <dyl> It's not on hackage.
16:10:11 <dyl> It has to be built from source.
16:10:28 <hpc> that... is what hackage is for
16:10:32 <hpc> lol
16:10:49 <dyl> Well, hie builds with cabal just fine.
16:11:05 <dyl> I'm probably not understanding how new-install handles binaries somehow.
16:11:29 <glguy> as far as I knew new-install wasn't working for anything other than installing executables directly from Hackage if that
16:11:39 <dyl> Ahhh, okay good to know.
16:11:58 <dyl> Well, I'll have to just manually drop the executables in for now.
16:12:02 <dyl> That's a little :..
16:12:05 <dyl> little sad.*
16:12:18 <monochrom> cabal new-build is going to put the exes at a really obscure place, right?
16:12:35 <hexagoxel> (good old `find dist-newstyle -name "$1" -type f | xargs -rx ls -t | head -n1` .. )
16:12:38 <dyl> As someone who's used to xcode derived data folders... ;p
16:12:41 <dyl> not that bad... 
16:12:57 <dyl> Something like: newstyle⁩ ▸ ⁨build⁩ ▸ ⁨x86_64-osx⁩ ▸ ⁨ghc-8.4.3⁩ ▸ ⁨haskell-ide-engine-0.2.2.0⁩ ▸ ⁨x⁩ ▸ ⁨hie⁩ ▸ ⁨build⁩ ▸ ⁨hie⁩
16:13:06 <dyl> Not sure where 'x' comes from.
16:13:14 <monochrom> Does "cabal new-install" exist? Does it do what I think?
16:13:30 <dyl> It exists, but it didn't do what I thought it would do.
16:13:36 <dyl> Namely it didn't install anything, it just said it was up to date.
16:13:42 <jle`> you need co-cabal co-install
16:13:52 <jle`> cocabal coinstall?
16:13:57 <sclv> it works in HEAD
16:14:12 <hpc> cabal gnu-build
16:14:13 <sclv> It copies exes
16:14:25 <mbwgh> should've stuck with autotools
16:14:26 <monochrom> Ah good to hear.
16:14:30 <monochrom> Haha
16:14:56 <hpc> this is why i only install things with curl | sh
16:15:08 <jle`> yeah, hm, i wonder what i would do if i wanted to write something that would be installable in 5 years
16:15:38 <MarcelineVQ> compile it to BASIC
16:15:53 <hexagoxel> no, stay with haskell. use a shake script.
16:16:08 <hpc> jle`: you would write some code, write the dependencies correctly in a cabal file, and do literally nothing else
16:16:18 <mbwgh> no docker?
16:16:32 <hpc> nah, a vagrantfile
16:16:40 <monochrom> At the end of those 5 years, you will actually want to insist on stack, because that's how you can in your config file instruct stack to download a 5yo GHC for your 5yo code.
16:17:25 <MarcelineVQ> for what it's worth the only consistent haskell dev tool I've used so far is ghcid
16:17:26 <hexagoxel> include the source for your build-tool along with the package source, to make sure
16:17:51 <mbwgh> You mean that old hunk of junk that doesn't come with co-linear co-dependent co-types?
16:18:20 <MarcelineVQ> everything else has failed in some new and baffling way at some point of use
16:18:22 <monochrom> I like ghcid a lot, too.
16:19:24 <monochrom> mbwgh: Yeah!
16:19:31 <hexagoxel> MarcelineVQ: you mean you never encountered the thing where ghcid does say "everything is fine" when internally ghci panicked? :)
16:19:48 <hpc> ooh, i love it when programs do that
16:19:56 <hpc> nothing like a good lie to help you debug things
16:20:08 <monochrom> Wait, that happens?!
16:20:31 <MarcelineVQ> not ghci, but ghc yes, I had TypeApplications on in my .ghci and ghcid used that I think and didn't inform me that my module did't actually have that turned on
16:20:34 <monochrom> I guess my code is not crazy enough to panic GHC.
16:20:40 <MarcelineVQ> Still, most consistent by far
16:20:51 <begriffs> Are hdevtools in a good state lately?
16:21:05 <mbwgh> Nothing beats deleting source files tho
16:23:24 <sdegutis> "Hello there."
16:23:27 <mbwgh> Isn't hdevtools the thing that leaves these socket files lying around everywhere?
16:23:28 <sdegutis> I mean hi.
16:25:51 <begriffs> Assuming ghc-mod is still in shambles too?
16:26:31 <dyl> Well, HIE seems to be... integrated ish, except for a bunch of LSP errors.
16:26:37 <dyl> Which I can't really get to in any meaningful log.
16:27:05 <mbwgh> sdegutis: Was there a question you would like to ask?
16:27:15 <sdegutis> I'm trying to see if I recognize any nicks.
16:27:28 <dyl> I'm seeing fixme's show... so it's doing something.
16:27:28 <sdegutis> I used to frequent this channel years ago.
16:27:39 <MarcelineVQ> you know me, we went to finishing school together
16:27:39 <dyl> er, hints.
16:29:36 <hpc> putStrLn "Hello (forall s. s)!" :: ST s ()
16:29:48 <mbwgh> But maybe to pick up on the earlier discussion. If we were speaking not of some Haskell package, but an application, what would your preferred way of distribution/installation be?
16:30:30 <dyl> Even weirder:
16:30:46 <dyl> HIE expects cabal-install to be available... but doesn't appear to look for it.
16:30:59 <dyl> Symlinking it into .local/bin seems okay though :|.
16:31:19 <monochrom> Is your cabal exe on your PATH?
16:31:27 <dyl> It is, but it's system-level.
16:31:27 <monochrom> Or rather, Was
16:31:33 <monochrom> Hrm.
16:31:36 <dyl> It's in usr/local/bin.
16:31:37 <mbwgh> They state stack install cabal-install in the Readme
16:31:42 <dyl> Yup.
16:32:56 <MarcelineVQ> mbwgh: prebuilt standalone bins
16:33:07 <MarcelineVQ> iow no install, just go
16:33:07 <dyl> [Error] Got error while processing diagnostics: readCreateProcess: cabal "configure" "--with-ghc=ghc" "--flags" "" (exit 1): failed
16:33:17 <dyl> So, looks like it's not finding cabal.
16:33:23 <dyl> (this is from LSP-client in vim)
16:33:38 <monochrom> Or maybe it can't find GHC.
16:33:46 <dyl> Well, I'm getting GHC hints.
16:33:50 <dyl> So, it seems like it can find that.
16:34:02 <mbwgh> MarcelineVQ: And how would you distribute it?
16:34:10 <monochrom> This is why I hate leaky abstractions.
16:34:52 <dyl> It could also be because it's trying to use cabal configure.
16:35:08 <dyl> And this project is new-configured.
16:35:16 <monochrom> Ah
16:35:21 <dyl> So it's going to find missing dependencies.
16:35:38 <MarcelineVQ> mbwgh: depends entirely on who I'm distribtuing to, but in general these days probably off github
16:35:52 <MarcelineVQ> as a topical example,  https://github.com/commercialhaskell/stack/releases
16:40:20 <mbwgh> MarcelineVQ: While this is on-github, would prefer off-github because of he who should not be named, or some other reason? In any case, what would be the alternative?
16:42:19 <dmwit> I think "off github" meant "I would let people download my release off of github", not "I would keep my binary off of github".
16:42:28 <mbwgh> aah
16:43:05 --- mode: glguy set +v verement
16:43:24 <verement> FWIW, GitLab is quite nice
16:44:17 <mbwgh> Can you host binary blobs without some sort of pro account?
16:44:24 <hpc> yes
16:44:27 <hpc> just push them to your repo
16:44:37 <mbwgh> And it's not against ToS?
16:44:42 <hpc> it's a git repo :P
16:45:12 <hpc> you might run afoul of size limits maybe?
16:45:32 <MarcelineVQ> oh uhm
16:45:43 <mbwgh> Now that I think about it, any potential for abuse should be accounted for via the size limit, yes
16:45:51 <MarcelineVQ> no, by "off github" I meant "to get from github"
16:46:10 <mbwgh> Funny how off and on can mean the same thing
16:46:37 <mbwgh> but me no engrish
16:46:56 <dmwit> Is there a multi-argument case, like functions use but without defining a function and calling it?
16:46:59 <MarcelineVQ> Well it wasn't that clear in hindsight
16:47:12 <hpc> it was off-clear
16:47:18 <dmwit> I use `case (foo, bar) of ...` but sometimes feel a bit funny about the possibility of an extra allocation/destructuring/deallocation that implies.
16:47:18 <MarcelineVQ> At the time it perfectly matched what I was thinking though
16:47:28 <dyl> Hrm well 
16:47:35 <hpc> dmwit: just add ~
16:47:37 <MarcelineVQ> ~
16:47:38 <dyl> LSP/HIE is flaking for unknown reasons. 
16:47:48 <dmwit> hpc: doesn't eliminate the allocation, though...?
16:47:58 <dyl> It’s *connected* it just doesn’t do anything except show GHC hints.
16:47:59 <geekosaur> hm. some ways I'd expect it to force the extra allocation
16:48:12 <hpc> oh right, it's case
16:48:13 <geekosaur> whereas the strict one invites it to be more clever about the immediate deconstruction
16:48:16 <mbwgh> Maybe a strict pattern matching pair?
16:48:29 <hpc> just trust ghc to take care of it for you?
16:48:49 <dmwit> hpc: Yeah, maybe. =)
16:48:51 <hpc> i doubt anything like that is going to be your primary performance loss
16:49:22 <hpc> short-lived allocations are a pointer increment anyway
16:50:11 <mbwgh> If that was a concern, you would like to reduce branching anyway. If that's not possible, and indeed the allocations were a factor, maybe a good old if-then-else is in order?
16:50:20 <dyl> In theory I should be able to install GHC, install a LSP server for Haskell, and then have stuff more or less just work modulo cabal new-*. 
16:50:35 <dyl> In practice, I can use stack and atom, or struggle through undocumented paths.
16:51:05 <MarcelineVQ> I've had mixed results on atom's end with hie, I blame atom for this mostly
16:51:10 <dyl> Maybe that’s why stack annoys me: it seems to cultivate lack of concern for anything that isn’t stack. 
16:51:22 <MarcelineVQ> opften atom works just well enough to let you know it's not working
16:51:24 <dyl> It’s feels like a subecosystem.
16:51:37 <hpc> dyl: that's a good way of putting it
16:51:45 <hpc> stack should be a user tool, not a packager's tool
16:52:04 <mbwgh> Atom OOM'ed for me when I tried it
16:52:39 <dyl> As an example: the situation in python just works, regardless of whether I’m using pyenv, virtualenvwrapper, etc 
16:52:51 <dyl> I install an interpreter, install the language server, and away I go with completions and such 
16:53:49 <mbwgh> I don't think that is true for the editor integration story. Sure, setting up an interpreter is easy, but you have that now with GHCi as well
16:54:03 <dyl> Not what I mean, really. 
16:54:24 <dyl> The editor integration isn’t even documented for the “standard” path. 
16:55:17 <dyl> I don’t know why I can’t just cabal install this globally and be done with it.
16:56:39 <mbwgh> dyl: Then what did you mean?
16:56:46 <geekosaur> it works with pythoin because in all cases it's the python executable doing it underneath, so as long as the correct python is found it will work
16:57:00 <dyl> I mean that the entire story here feels flaky. 
16:57:10 <dyl> And Haskell’s ecosystem is mature enough that it shouldn’t be this flaky.
16:57:39 <dyl> I shouldnt have to manually clone a repository and use the maintainers’ package system of choice just to _get the package_.
16:57:46 <dmwit> dyl: https://www.vex.net/~trebla/humour/tautologies.html #2, I think
16:57:53 <jle`> yeah, hm, i wonder what i would do if i wanted to write something that would be installable in 5 years
16:58:02 <geekosaur> editor integration for haskell means either building in a copy of the compiler (ghc-api), which often means a separate editor helper for every project, or doing the same with some backend which ends up having the same problem
16:58:09 <mbwgh> I don't know. Python does have mature whole-package solutions like editors, but when I tried to set up vi and emacs, I did not have a good time
16:58:29 <jle`> oh sorry, acidentally re-sent a message
16:58:42 <geekosaur> there is ongoing work on having ghcid be that backend, which will help.
17:00:15 <MarcelineVQ> dante uses ghci for a backend, I think, dunno if there's a vim dante, there's a vim intero
17:00:44 <dyl> I think it’s relevant to consider the idea of the compiler as a functional database. 
17:01:03 <dyl> It seems like these days editor integration makes the most sense in the compiler itself :/.  
17:01:10 <dyl> From where I stand anyways.
17:01:19 <MarcelineVQ> well ghci does have an api for edtior's to access, it's just a matter of people writing the editor plugins
17:01:37 <geekosaur> this is why ghcid, which is still evolving along with tools that seek to use it like hie
17:01:39 <hpc> dyl: what other tool would have such a precise understanding of what a compiled program will be?
17:01:51 <dyl> My point exactly. 
17:01:53 <geekosaur> but neither one's quite there yet, so to be usable now hie has to do other things
17:02:16 <mbwgh> Didn't whole-meal solutions like leksah and haskell-for-mac exist?
17:02:49 <dyl> I don’t think I’ve ever gotten leksah to work. 
17:02:56 <hpc> mbwgh: they cut the api boundary closer to the compiler
17:03:00 <dyl> And Haskell-for-Mac is a solution to a different problem. 
17:03:00 <geekosaur> they were packages of piecemeal solutions, and would break if you changed things beyond what they expected
17:03:08 <hpc> so the ide integration piece had a lot of custom weird stuff that wouldn't always work
17:03:14 <geekosaur> like, installing something they expected to have complete control over
17:03:30 <hpc> language servers theoretically cut closer to the editor, but more often than not they still leave that bad cut near the compiler
17:03:39 <MarcelineVQ> e.g. of ghci's editor features https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:complete
17:04:18 <geekosaur> well. the idea behind language seevers is to adapt compiler-based backends to editor-based frontends. which requires both to be there. ghcid isn't quite there yet
17:04:41 <dyl> Yeah, looks like the Haskell LSP server implementation farms a lot out to existing commands. 
17:05:02 <dyl> Or rather, HIE does. 
17:05:24 <geekosaur> the intent is to use ghcid, and to help it get to where it needs to be. but they also want to be usable now, so they need to use things other than ghcid
17:05:54 <dyl> The thing is, new users are like water, they’ll take the path of least resistance. 
17:06:06 <dyl> So I expect a lot of stack/atom focus. 
17:06:26 <dyl> The presence of a good enough solution for most people delays the better solution. 
17:06:29 <mbwgh> dyl: You make that sound like a flaw in character.
17:06:35 <dyl> No, not at all.
17:07:03 <dyl> If I was trying to Get Things Done properly I would do the same. 
17:07:17 <monochrom> I am the one who makes every human condition sounds like a flaw. :)
17:07:38 <dyl> monochrom is one being and not several. I’ve seen many human beings and monochrom is one of them.
17:07:53 <dyl> He has many personality traits, as people do.
17:08:58 <arahael> With megaparsec, is it possible to "fork" the input stream so that I can represent multiple possible parses?
17:09:04 <MarcelineVQ> That sounds like something monochrom-pretending-not-to-be-monochrom would say..
17:10:00 <arahael> I'm trying to determine how to parse a preprocessor directive, to the effect of: a := {$ifdef alpha}"ALPHA"{$endif} {$ifdef beta}"BETA"{$endif}
17:10:31 <monochrom> Are you really forking? Or do you just need a little backtracking but at the end the answer is still unique?
17:10:32 * arahael supposes he should just evaluate it, and represent them in the AST already.
17:11:19 <arahael> monochrom: I kind of answered myself.  I should evalate it eg, as a PreProcessorExpression [ParseOptions]
17:11:29 <mbwgh> i.e. try (this <|> that <|> choice manyothers)
17:11:48 <arahael> mbwgh: Trouble is, that's an either choice.  I want to represent *both*.
17:12:19 <arahael> mbwgh: And unforutnately, the way my parser works is that the expression has to "make sense", so I can't really parse the half an expression that is ifdef'ed out.
17:14:28 <mbwgh> If you need several possible parses, you still need to backtrack. But I am not sure if try will still work for this, it could be that you need to manipulate megaparse's state.
17:15:07 <mbwgh> On the other hand, there may be an interesting combinator I don't know about yet
17:16:03 <arahael> I don't think try will work.  In the above contrived example, I want to have *both* the alpha, *and* the beta options.  Ie: T "a" := PP [("alpha", "ALPHA"), ("beta "BETA")]
17:23:30 <nash50> hello, is it possible to parse a reference to a type without getting "ambiguous type" error? This is a minimal example of a problem I'm stuck at: https://repl.it/@naushadh/AfraidSociableSysadmin
17:23:56 <mbwgh> arahael: Could you maybe make it work with lookAhead and try? You need try to backtrack upon failure, but in the success case, lookAhead does not consume input. My first thought would be to use parsers that return something like a Maybe, and use withRecovery to return Nothing (there is surely a simpler approach). But then each parser will return something, and you can use catMaybes for all of these results.
17:24:44 <arahael> mbwgh: The trouble is that still only returns one possible parse.
17:25:08 <dolio> arahael: You should completely do the preprocessing before doing the parsing.
17:25:25 <dmwit> nash50: What type are you expecting `helloMeta` to be called at? Perhaps the `a` in the type of `routeToHello`?
17:25:45 <dolio> Hence, "preprocessing." :)
17:26:22 <mbwgh> arahael: For example if you had two parsers, you would use both of these parsers on the same input state. If both succeed (by returning `Just yourtype`), catMaybes would return [yourtype, yourothertyype], assuming a suitable sum-type.
17:26:27 <geekosaur> nash50, one thing that occurs to me right off is you're missing the Metadata a constraint on routeToHello
17:26:44 <geekosaur> although I would have expected a different error for that tbh
17:27:01 <mbwgh> arahael: But yes, if the problem can be simplified by what dolio said, I'd say go for it
17:27:25 <geekosaur> also, you're not using f currently. Possibly if you were, it would be able to use that usage to determine a
17:27:36 <geekosaur> right now, it has no way to connect them, which is what that error is telling you
17:27:37 <arahael> dolio: That would mean that I would have to determine all the possible options for preprocessing, generate all the possible outcomes, then parse all the possible post-processed results.
17:27:39 <dolio> It is hard won wisdom from doing things wrong many times. :)
17:28:01 <dmwit> nash50: Anyway, you probably just want to write `go (Just a) = f a` instead of `helloMeta a`.
17:28:06 <mbwgh> That is why we try to avoid cpp
17:28:13 <arahael> mbwgh: Agreed.  It stinks.
17:28:16 <dyl> When in doubt:
17:28:19 <dyl> > fix error
17:28:21 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
17:28:23 <arahael> Anyway, thanks for the discussion - I'll keep thinking about it.
17:28:39 <dmwit> nash50: (...and add `Metadata a` to your context for `routeToHello`.)
17:29:11 <dolio> I guess I don't understand. Why don't you have the options available when you're preprocessing?
17:30:07 <nash50> dmwit geekosaur: good catch! I fixed the two issues. I still get similar error 
17:30:15 <arahael> dolio: I want to allow the AST to be used as a code generator / style guide enforcer.
17:31:15 <mbwgh> arahael: Btw, in the approach I tried to describe, you would need to keep track of what each successful parse *would* consume, take the "maximum" of that and fast-forward accordingly, making this very imperative.
17:31:47 <arahael> mbwgh: That's actually a very reasonable approach.
17:32:06 <mbwgh> arahael: Yes, but something you would hope was already implemented somewhere :)
17:32:35 <arahael> mbwgh: This mess could be constrained in the parsing of the specific PPC tokens that require it.
17:33:30 <dmwit> nash50: We can't see your screen.
17:34:01 <nash50> dmwit: apologies, here's the link: https://repl.it/@naushadh/AfraidSociableSysadmin
17:34:26 <dolio> arahael: Does that mean that every possible parse has to generate an AST that passes the style guide?
17:34:51 <arahael> dolio: Ideally, yes.
17:35:05 <dmwit> nash50: And the error?
17:35:19 <dmwit> nash50: (When I hit "run" on that page, it says something I don't understand.)
17:35:35 <nash50> {-  main.hs:42:3: error:    • Ambiguous type variable ‘a0’ arising from a use of ‘routeToHello’      prevents the constraint ‘(Metadata a0)’ from being solved.      Probable fix: use a type annotation to specify what ‘a0’ should be.      These potential instances exist:        instance Metadata A -- Defined at main.hs:11:10        instance Metadata
17:35:35 <nash50>  B -- Defined at main.hs:18:10        instance Metadata C -- Defined at main.hs:25:10    • In a stmt of a 'do' block: routeToHello uri helloMeta      In the expression:        do { uri <- getLine;             routeToHello uri helloMeta }      In an equation for ‘main’:          main            = do { uri <- getLine;                   routeToHello u
17:35:36 <nash50> ri helloMeta }  -}
17:36:02 <nash50> I've updated the snippet at the url with the error blob. https://repl.it/@naushadh/AfraidSociableSysadmin
17:36:50 <dmwit> nash50: You still need to tell it what type you want to call `helloMeta` at.
17:37:35 <geekosaur> that error's just telling you the truth: there is no way for it to guess which instance you want. I tknows it needs one, but has no idea which
17:37:46 <dmwit> nash50: e.g. try `routeToHello uri (helloMeta :: Proxy A -> IO ())`
17:37:56 <geekosaur> I suspect that commented out portion would tell it enough to infer it
17:38:06 <geekosaur> in its absence, what dmwit just said
17:38:24 <geekosaur> actually, no, that wouldn't work as is, bit it shows what you need
17:39:21 <dmwit> Is the "that" that wouldn't work my snippet? If so, what problem do you predict?
17:41:19 <geekosaur> no, I men the comment at the very bottom of the paste, which I initially misread as usimg the result instead of mocking it
17:43:44 <dmwit> got it
17:45:01 <nash50> dmwit: that's what I figured too. I was just wondering if there was some type level means to automatically dispatch the right type/proxy based on a parser. I'm trying to get away from having an exhaustive case statement that `routeToHello` should have to explicitly match URI to a specific instance of `Metadata`.
17:45:42 <geekosaur> type level is compile time, it's not going to be able to make decisions based on runtime
17:46:55 <geekosaur> and in all cases, a function produces a fixed type determined by its caller. that result might be a sum type that allows selection of possible types/values, but all of them have to be known and handled by the caller in advance
17:47:43 <geekosaur> so no, f / helloMeta can't choose an "a" at runtime
17:48:52 <nash50> geekosaur: ah! I see. I suppose if I really had to go down the "automatic" path, template haskell is the only way.
17:49:36 <nash50> actually nvm, even TH will require declaring a set of "routes" to generate code for.
17:50:26 <nash50> dmwit geekosaur: thank you
17:51:18 <ktonga> since I started using nix with haskell i have a doubt. I understand how it works in conjunction with `cabal build`, but what will happen when `cabal new-build` become the default behavior?
17:51:40 <ktonga> as i understand cabal will be trying to do the same as nix does
17:52:25 <dmwit> You might ask again on #hackage, where cabal devs hang out and talk about cabal. I know there's some folks hard at work to make sure nix and new-* work well together, but I don't know the details of their plans.
17:53:12 <ktonga> oh sure, thank you dmwit
17:55:04 <koz_> What's the bot command I can use to check which module something is in?
17:55:10 <MarcelineVQ> index
17:55:51 <koz_> MarcelineVQ: Mind showing me?
17:56:12 <MarcelineVQ> :B
17:56:22 <MarcelineVQ> @index fromList
17:56:22 <lambdabot> GHC.Exts, Distribution.Simple.PackageIndex, Data.IntMap.Strict, Data.IntMap.Lazy, Data.IntMap, Data.IntSet, Data.Map.Strict, Data.Map.Lazy, Data.Map, Data.Set, Data.Sequence
17:56:30 <koz_> @index (>=>)
17:56:30 <lambdabot> Control.Monad
17:56:33 <koz_> Thanks!
17:58:07 <dmwit> ?hoogle (>=>)
17:58:07 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
17:58:07 <lambdabot> Text.XML.Cursor (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
17:58:07 <lambdabot> Text.XML.Cursor.Generic (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:48:52 <dmwit> :t length
18:48:53 <lambdabot> Foldable t => t a -> Int
18:48:55 <dmwit> :t genericLength
18:48:56 <lambdabot> Num i => [a] -> i
18:49:01 <dmwit> =(
18:50:02 <glguy> There aren't many good uses of genericLength
18:50:21 <dmwit> It isn't generic enough!
18:50:58 <dmwit> (...for what I currently want, which is `Maybe a -> Word32`.)
18:52:32 <glguy> It's almost always better to use fromIntegral than to add up the list length at the alternate type
18:53:45 <shachaf> The only good use of genericLength is to compute a lazy natural number.
18:54:02 <shachaf> And even that use probably isn't great.
18:54:32 <shachaf> I sort of wish fromIntegral . length had a name.
18:54:42 <dmwit> That is also my current wish.
18:57:10 <zzz> is there a prefix equivalent of <*> ?
18:57:34 <dmwit> :t ap
18:57:35 <shachaf> There's ap, but it's not as good because it's defined in terms of Monad.
18:57:35 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:57:46 <dolio> (<*>)
18:58:06 <zzz> so nothing for Applicative
18:58:21 <dmwit> Not if you dislike dolio's answer.
18:58:24 <zzz> ok thanks
18:58:36 <dolio> > (<*>) [(+1),(+2)] [1,2]
18:58:38 <lambdabot>  [2,3,3,4]
18:58:42 <zzz> not that I dislike. was just curious
19:00:36 <zzz> how do you pronounce it in conversation?
19:01:40 <monochrom> makeGenericLengthGreatAgain = foldl' (\z _ -> z+1) 0
19:01:58 <monochrom> You can say "ap".
19:02:08 <glguy> Still not great unless you as Inline or specializations
19:02:25 <monochrom> Because it's a generalization of function application's "application".
19:07:12 <dmwit> makeGenericLengthGreatAgain = fromIntegral . length
19:07:20 <dmwit> worstOfBothWorlds = genericLength . toList
19:07:36 <dolio> What if you have more than 2^63 elements in your list?
19:07:52 <dmwit> dolio: It's worse than that. I'm converting to Word32.
19:08:14 <dolio> Oh no.
19:08:24 <dmwit> dolio: Don't worry, though, my list is a Maybe.
19:08:28 <monochrom> At least it is not Int32 hehe
19:09:28 <dmwit> My length will fit in a Word1. =)
19:33:25 <monochrom> Eh? GHC comes with parsec now?
19:38:46 <geekosaur> iirc the cabal/package.conf file parser was reimplemented in parsec
19:39:08 <geekosaur> but it's a non-exposed component, so a separate install won't conflict with it
19:39:14 --- mode: glguy set +v mothatt
19:39:39 --- mode: glguy set -v mothatt
19:40:08 <mothatt> Hi everyone, I feel like an idiot but I can't figure out how to parse a 3 character string into a custom data type
19:40:59 <ab9rf> mothatt: you may need to be a bit more specific in your problem statement
19:41:16 <mothatt> I'm trying to parse a string describing a persons characteristics (first letter height, second letter hair colour, third letter sex)
19:41:26 <mothatt> so SBM would be a short blonde male
19:42:00 <dmwit> Do you have parsers that take a single character and do something sensible for each of those three components?
19:42:24 <mothatt> i was trying that dmwit 
19:42:39 <ab9rf> your first step should be to parse the first character
19:42:40 <dmwit> Cool, where did you get stuck?
19:42:41 <mothatt> but then im not sure how to construct the final Person data type from that
19:42:44 <ab9rf> ah
19:43:03 <ab9rf> welcome to <$> and <*>
19:43:11 <mothatt> i had something like Person p = Person (parseHeight (p!!0)...)
19:43:19 <dmwit> mothatt: What are the types of your single-character parsers?
19:43:26 <dmwit> ab9rf: ...maybe
19:43:32 <dmwit> ab9rf: Depends how basic we're going here. =)
19:43:50 <mothatt> parseHeight h :: Char -> Height
19:43:53 <ab9rf> dmwit: yeah, it may be better pedagologically to explain the "long way" before teaching the shortcut
19:44:09 <mothatt> oh boy, time to get my learning hat on
19:44:12 <dmwit> mothatt: Interesting! What happens if you see an unknown Char?
19:44:29 <mothatt> mm, thats the other problem
19:44:43 <dmwit> mothatt: I recommend `parseHeight :: Char -> Maybe Height` instead.
19:44:46 <ab9rf> you may want to consider using Maybe
19:44:49 <mothatt> im also struggling to wrap my head around maybe
19:46:06 <mothatt> if i'm returning maybe something, does the type have to be defined as Nothing | Just thing
19:46:27 <ab9rf> no, Maybe provides the definitions of Nothing and Just
19:46:31 <dmwit> Well, that is the definition of `Maybe`.
19:46:33 <dmwit> ?src Maybe
19:46:33 <lambdabot> data Maybe a = Nothing | Just a
19:47:00 <dmwit> So e.g. you could write `parseHeight :: Char -> Height; parseHeight 'S' = Just Short; parseHeight 'T' = Just Tall; parseHeight _ = Nothing`.
19:47:03 <mothatt> ahh, that makes more sense
19:47:06 <ab9rf> if you have a type Height, you can construct the type Maybe Height by writing "Maybe Height"
19:47:14 <dmwit> err...
19:47:23 <dmwit> `parseHeight :: Char -> Maybe Height; ...`, of course. =P
19:47:29 <ab9rf> heh
19:47:40 <ab9rf> dmwit: we are careening toward <$>
19:47:48 <dmwit> ab9rf: Yep... or liftA3.
19:48:26 <dmwit> mothatt: Once you have the three parsers together, you can use simple pattern-matching for your top-level guy.
19:48:27 <ab9rf> dmwit: it was quite the glorious moment when i understood how that worked
19:48:59 <ab9rf> sooo much more succint than having to explicitly go "if ... if ... if ..."
19:49:26 <dmwit> mothatt: e.g. something like this: `parsePerson :: String -> Maybe Person; parsePerson [height, color, sex] = case (parseHeight height, parseColor color, parseSex sex) of { (Just h, Just c, Just s) -> Just (Person h c s); _ -> Nothing }; parsePerson _ = Nothing`.
19:50:19 <mothatt> i see, theres the ticket
19:50:20 <mothatt> case
19:50:43 <dmwit> There's two pattern-matches of interest there.
19:50:49 <ab9rf> that works, yes
19:50:51 <dmwit> One is the match to make sure the string is of length 3.
19:50:58 <dmwit> The other is to make sure the sub-parsers all succeed.
19:51:23 <dmwit> (The second one would idiomatically be written in a different way, but it's maybe a bit much for beginners.)
19:52:08 <ab9rf> heh
19:55:29 <mothatt> ah, so thats how you access individual chars in a string
19:55:39 <mothatt> parsePerson [a, b, c]
19:57:58 <dmwit> That's one way, yes.
19:59:00 <dmwit> (And next you will go, "ah yes, but I want to be able to handle the situation where I have a Person and another thing in the same string, and pull them both out". And then things will get one more layer of complicated. =)
19:59:45 <mothatt> luckily, i don't need to do that afaik
20:00:33 <ab9rf> that approach is relying on the fact tht a string is a list of characters
20:00:43 <ab9rf> so you're matching on a list with three elements
20:02:16 <MarcelineVQ> @unmtl MonadState ServerState m => SerialT m () -- ;_;
20:02:16 <lambdabot> Plugin `unmtl' failed with: MultiParamTypeClasses language extension is not enabled. Please add {-# LANGUAGE MultiParamTypeClasses #-} pragma at the top of your module.
20:02:52 <dmwit> ?unmtl SerialT (StateT ServerState m) ()
20:02:52 <lambdabot> SerialT (StateT ServerState m) ()
20:02:59 <dmwit> hm =)
20:03:31 <dmwit> Ah, yes, I guess that's about as much as it can possibly hope to do without knowing what SerialT is.
20:04:14 <MarcelineVQ> Nothing much more than that, I was just wondering what MonadState really looked like
20:04:15 <dmwit> You might wish it would like, put a type-level lambda in there or something. But that would just get your hopes up that GHC had grown a new language extension. =P
20:04:24 <dmwit> ?unmtl StateT ServerState m ()
20:04:24 <lambdabot> ServerState -> m ((), ServerState)
20:04:29 <dmwit> MarcelineVQ: mu
20:04:42 <dmwit> MarcelineVQ: MonadState is a class. You can only ask what specific instances really look like.
20:05:08 <MarcelineVQ> confusing stuff, it's called unmtl but these are transformer things yeah?
20:05:45 <geekosaur> it desugars mtl types into the underlying representation. it doesn't do typeclasses as such
20:05:47 <nitrix> transformers and mtl have a close relationship.
20:06:00 <glguy> MarcelineVQ: I believe that the ?unmtl command predates the split of mtl in to transformers and mtl
20:06:13 <monochrom> The name "unmtl" was before the peace treaty between mtl and transformers. Back then mtl contained code that today is in transformers.
20:06:17 <geekosaur> and it assumes any type it doesn't know about is "primitive" like Int
20:06:36 <MarcelineVQ> thanks team
20:07:11 * lambdabot does a lap giving high-fives
20:07:43 <nitrix> o/
20:08:25 <mothatt> thanks for the help guys
20:09:19 <MarcelineVQ> Trying to decide what the acceptable level of transformer pollution is for me in an application that does real work. I'm suspecting it's "exactly enough to do the job" for better or worse
20:09:49 <dmwit> typeclass-ify all the things!
20:10:02 <nitrix> MarcelineVQ: Wrapped with newtypes, it becomes very manageable.
20:10:27 <MarcelineVQ> If you wrap all your constrains into one with a constraintkind it's like there's nothing sneaky going on at all
20:11:00 <MarcelineVQ> app :: AllTheThings m => m ()
20:11:17 <nitrix> :>
20:11:27 <monochrom> A realistic application is rarely exactly MonadState and MonadReader and MonadParser.
20:11:30 <glguy> app :: AllTheThings ()
20:12:09 <monochrom> More often, you have some data invariants to preserve, so actually exposing arbitrary "put" and "get" is harmful.
20:12:18 <chessandgo> whats the recommended way to do timeouts without async exceptions
20:12:33 <chessandgo> the library i'm using dosnt work well with them
20:13:00 <dmwit> Is `timeout` no good?
20:13:06 <monochrom> So "AllTheThings m => ..." is actually right. But you carefully design the methods of AllTheThings to be the exact non-leaky abstraction you need.
20:13:07 <glguy> chessandgo: I like registerDelay from STM
20:13:14 <chessandgo> timeout sends an async exception
20:13:29 <dmwit> Oh, wow. I need to go to bed.
20:13:34 <dmwit> I read "without" as "with". =P
20:13:57 <monochrom> No. You need a drink. >:)
20:14:02 <MarcelineVQ> ^
20:14:19 <chessandgo> hows that work? glguy 
20:14:23 <glguy> No no no, tomorrow's a work day. We need him firing on all cylinders
20:14:46 <MarcelineVQ> on a tuesday?
20:14:51 <dmwit> no firing, i like working here =(
20:15:02 <glguy> http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Conc-IO.html#v:registerDelay
20:15:17 <glguy> Sure, we need him employing all cylinders
20:15:38 <dmwit> yesss
20:15:44 <dmwit> STM is way too cool.
20:16:39 <monochrom> registerDelay eh? This is crazy!
20:17:04 <chessandgo> STM's the next on my list
20:17:14 <ktonga> can i fork an IO that was lifted into a MonadIO? or i have to make it concrete to IO instead of using mtl constraint?
20:17:16 <dmwit> monochrom: Hiya, Maybe!
20:17:23 <chessandgo> load the whole MUD world from database into one giant STM thing (comonad?)
20:17:28 <dmwit> ktonga: gotta concrete it
20:17:50 <ktonga> sure. cheers.
20:18:07 <dmwit> ktonga: related: https://stackoverflow.com/q/9243215/791604
20:18:45 <ktonga> reading... Thanks! :)
20:19:28 <chessandgo> glguy: looks very useful, although I dont think ill be able to use it in this case, as I'd have to poll the tvar
20:19:28 <monochrom> Haha "registerDelay requires -threaded"
20:20:06 <dmwit> chessandgo: Uh? `atomically` and `retry` work together in the right way already.
20:21:08 <dmwit> Hm, maybe I misunderstood.
20:21:21 <chessandgo> dmwit: the thing im trying to interupt/cancle is a currently looping function thats reading from a websocket
20:22:00 <chessandgo> (unless theres a way I can just make a thread stop existing without cancling it)
20:23:27 <monochrom> I just use cancel or killThread, depending on whether I'm using async or forkIO.
20:23:31 <dmwit> Maybe it's okay if it keeps reading, but you get a result that says it's still going and hasn't worked yet...?
20:23:58 <monochrom> And who issues my cancel and killThread? Another thread that threadDelays and issues it.
20:24:12 <chessandgo> monochrom: don't both of those use async exceptions
20:24:23 <monochrom> Yes.
20:24:26 <glguy> chessandgo: If the websocket API doesn't offer a way to timeout then the only way to timeout is going to be an async exception. What are you trying to work around by avoiding them?
20:24:54 <chessandgo> glguy: the websocket library closes the websocket once it gets an async exception
20:25:18 <glguy> chessandgo: Can you have a single thread responsible for reading all the websocket messages and putting them onto a TQueue?
20:25:38 <glguy> and then you can use STM to try to read either from the TQueue or the timeout TVar?
20:26:02 <chessandgo> well currently theres a thread for each websocket, where they'd all just write to a tchan
20:26:27 <chessandgo> I want to do some stuff with the websocket after the timeouts reached, but by then the library has closed the websocket
20:34:35 <rotaerk> :t \f -> fix $ \r a -> a : r (f a)
20:34:36 <lambdabot> (t -> t) -> t -> [t]
20:35:11 <rotaerk> :t iterate
20:35:12 <lambdabot> (a -> a) -> a -> [a]
20:38:57 <chessandgo> I dont need to `cancel` a thread thats already completed right? that wont lead to a space leak for forgetting that
20:39:26 <glguy> Right, you just want to let go of the ThreadId
20:45:18 <sdegutis> It's been said that Haskell is only useful as a DSL for writing DSLs, does that sound right?
20:46:16 <glguy> It does sound like something that has been said, it's not right.
20:46:51 <glguy> You've been using it for a couple of years now so you've probably got a bit of a sense of what you can do with it
20:46:57 <dyl> sdegutis: Wat out west, there was this language that I wanna tell ya about. A language by the name of Haskell. At least that was the handle his lovin' maintainers gave him, but he never had much use for it himself. This Haskell, he called himself 'The Lang.' Now, 'Lang' - that's a name no one would self-apply where I come from. 
20:47:39 <dyl> But then there was a lot about the 'Lang' that didn't make a whole lot of sense to me. And a lot about where he compiled, likewise. But then again, maybe that's why I found the place so darned interestin'. They call Los Angeles the 'City Of Angels.' I didn't find it to be that, exactly. But I'll allow there are some nice folks there. 'Course I can't say I've seen London, and I've never been to Fra
20:47:39 <dyl> nce. And I ain't never seen no queen in her damned undies, as the fella says. But I'll tell ya what - after seeing Los Angeles, and this a-here story I'm about to unfold, well, I guess I seen somethin' every bit as stupefyin' as you'd see in any of those other places.
20:47:52 <sdegutis> is this a copypasta
20:48:35 <dyl> And even if he's a lazy language - and the 'Lang' was most certainly that, quite possibly the laziest in Los Angeles County, which would place it high in the runnin' for laziest worldwide. But sometimes there's a language, sometimes, there's a language. Wow, I lost my train of thought here. But, aw, hell. I've done introduced it enough.
20:49:16 <ab9rf> well
20:49:24 <ab9rf> anyway
20:49:26 <dyl> That’s just like, your evaluation, man.
20:49:48 <chessandgo> does code inside a handle know that an exception has been raised?
20:50:02 <MarcelineVQ> dyl: I take comfort in that.
20:50:15 <chessandgo> or is it that im not catching a specific exception thats getting into the function body
20:51:12 <dyl> MarcelineVQ: I sure hope you make the finale.
20:51:15 <dyl> finals*
20:56:22 <Zipheir`> dyl: You're irreplaceable.
20:58:25 <dsal> How can I have packages available from the global stack project?  I tried adding them in packages:, but is there a way to fetch dependencies?
20:59:26 <MarcelineVQ> local packages?
21:00:12 <MarcelineVQ> are you wanting to add local packages?
21:00:24 <MarcelineVQ> or ones from hackage or git?
21:00:56 <dsal> From hackage.  I'm kind of confused as to the state of this.
21:01:05 <MarcelineVQ> Then you add them to extra-deps not packages
21:01:14 <dsal> I had added QuickCheck a while back.  I just tried adding checkers and it doesn't seem to work.
21:01:23 <dsal> It doesn't tell me it's *not* working, but the package isn't available.
21:01:29 <arahael> With megaparsec, how do I match for the BOM? I tried _ <- symbol "\xFEFF", but it didn't seem to do the trick.
21:02:26 <MarcelineVQ> both of those are in major resolvers so you shouldn't add them to any particular section
21:02:28 --- mode: glguy set -q $~a
21:03:06 <MarcelineVQ> instead invoke a stack command with them to add them to your cache.  stack ghci --package checkers QuickCheck
21:03:45 <MarcelineVQ> if you invoke that outside of any project it should now be availabel any time you run stack ghci, until you delete your cache or change the global resolver
21:04:10 <dyl> arahael: possibly dumb but did you check input encoding and whether detecting it as two units helps? 
21:04:40 <dsal> MarcelineVQ: That worked.  I don't quite know what it did, though.
21:04:55 <arahael> dyl: Two units?
21:05:02 <dsal> Oh, I see.
21:05:08 <arahael> dyl: I used Data.Text's readFile.
21:05:09 <MarcelineVQ> It built and added them to the cache for the resolver specified in ~/.stack/global-project/stack.yaml
21:05:21 <dsal> Yeah, I see now.
21:05:23 <MarcelineVQ> So anytime you use that resolver these are already available
21:05:24 <dsal> Thanks.
21:05:32 <dyl> I mean that symbol may be looking for a single extended grapheme cluster. 
21:05:42 <dyl> Which the BOM is technically not. 
21:05:54 <arahael> dyl: The BOM is a unicode character, though.
21:06:01 <dyl> I don’t know how the internals of MegaParsec work either. 
21:06:03 <dsal> Oh, so it may have worked if I used a resolver that had already loaded the packages?  That explains why QuickCheck worked, but checkers didn't.
21:06:09 <dyl> “Character” is not so easily defined.
21:06:18 <dyl> But still, it should parse as one unit.
21:06:26 <dyl> (Even if it’s not...)
21:06:59 <arahael> dyl: I could manually check the text prior to parsing it. It's a single character.  Also, it's specified on www.unicode.org/faq/utf_bom.html#BOM that it's a unicode code.
21:07:23 <arahael> SPecifically, it's "the character code U+FEFF".
21:07:41 <dyl> Have you tried writing a minimal test case? 
21:07:47 <arahael> dyl: Yes.
21:07:55 <MarcelineVQ> dsal: yes, mind that this doesn't make them available to a specific project, you specify the packages you want in your cabal file for that. this just prebuilds them and happens to make them available to things like ghci
21:07:58 <dyl> That’s really odd if so.
21:08:17 <dyl> Have you tried printing the escaped input going into megaparsec.
21:08:27 <dyl> It sounds like there might be some other layer at play here.
21:10:19 <arahael> dyl: I have a test case that uses an input string that begins with \xFEFF, and it fails, part of the error is (fromList [Tokens ('\65279' :| "")])
21:11:07 <dsal> MarcelineVQ: Yeah, I'm just doing some out-of-project stuff.  Thanks for the pointers.
21:13:07 <dyl> It sounds like it’s interpreting it in a higher big Unicode encoding that you’re using.
21:13:13 <dyl> bit*
21:13:27 <arahael> dyl: Hmm.
21:13:45 <dyl> Try matching with exactly the sequence in the error.
21:14:16 <arahael> I misinterpreted my unit tests. :(
21:14:23 <dyl> 65279 is 0xFEFF
21:14:43 <arahael> Seems it's failing when I *don't* have the BOM. That's a... Very different problem.
21:15:19 <koz_> If I want extensible records, what's the go-to library for this nowadays?
21:15:44 <suzu> maybe vinyl?
21:16:30 <arahael> dyl: Beautiful, as usual, I was wrong, and everything else was right. :)  Thanks for your help.
21:16:57 <arahael> I was using _ <- try $ char '\xFEFF' to try and discard the symbol.
21:17:29 <arahael> Somehow, using _<- optional $ char '\xFEFF' was the correct solution, so try must not have restored the state properly.
21:17:49 <glguy> it wouldn't do anything to put a try on that
21:18:03 <arahael> glguy: Could you enlighten me as to why?
21:18:28 <glguy> try means "if this fails to parse and consumes input, pretend like it failed to parse but never consumed input"
21:18:43 <arahael> Ah, means to *pretend* it failed, I see.
21:18:48 <glguy> failure is preserved
21:19:01 <glguy> try won't do anything for a parser that only ever consumes 1 character
21:19:07 <arahael> So, it's like, "try parsing with this...  And if it fails, continue from THAT point on."
21:19:15 <glguy> no, it's not "continue"
21:19:18 <glguy> it's still "fail"
21:19:45 <glguy> the difference is in if it should appear like some input was successfully consumed before failing or not
21:20:02 <glguy> this is important because given:   a <|> b,    if a fails but consumes input then b is not used
21:20:09 <glguy> b is only used if a fails and consumes no input
21:21:04 * koz_ looks at Vinyl, and understands precisely none of it.
21:21:06 <arahael> So, in the context of (char '\xFEFF') <|> b ?
21:21:34 <glguy> The parser (char x)  only ever fails consuming no input, or succeeds consuming one character
21:21:40 <glguy> so try can't have an effect
21:21:50 <monochrom> "try" is opt-in backtracking. Normally <|> does what glguy says because it saves the cost of backtracking by disabling backtracking.
21:21:53 <arahael> So what does 'x' do, then?
21:22:09 <glguy> x is a character, it doesn't do anything
21:22:26 <arahael> I mean, why bother parsing \xFEFF to it, if it always succeeds?
21:22:48 <glguy> It doesn't always succeed
21:22:58 <glguy> it only succeeds if the next character was \xFEFF
21:23:08 <glguy> in the case of char '\xFEFF'
21:23:11 <arahael> And if the character was *not* \xFEFF?
21:23:14 <monochrom> \xFEFF is character literal syntax for codepoint FEFF (hexadecimal)
21:23:15 <glguy> then it fails
21:23:27 <monochrom> I say this because you asked what is 'x'.
21:24:07 <arahael> glguy: I'm trying to reconcile the fact that 1) char failed, and 2) It consumed input, and 3) try does NOT restore the state properly?
21:24:27 <monochrom> But it does not consume input if it fails.
21:24:31 <glguy> try restored the state properly
21:24:41 <glguy> no input was consumed and try ensured that no input was consumed (trivially)
21:24:47 <glguy> and the parse still failed as expected
21:24:52 <arahael> Ah, I see!
21:25:11 <monochrom> (char 'a' >> char 'b'), given input string "ac", will fail and consume input (the "a" part)
21:25:19 <arahael> And as a result, the parse ultimately failed entirely, because it wasn't optional and I didn't provide it any other options!
21:27:51 <arahael> Thanks for that, glguy!  I shouldn't have been that slow!
21:37:08 <ktonga> when working with MonadError is there a way to map the error type?
21:39:27 <monochrom> What does the doc say?
21:40:26 <jle`> ktonga: do you mean when working polymorphically over all MonadError instances?
21:40:49 <jle`> or do you mean working with a specific MonadError instance?
21:41:14 <glguy> (same answer)
21:41:18 <ktonga> is hoogled for something like this without any luck `(MonadError a m, MonadError b n) => (a -> b) -> m c -> n c`
21:41:47 <jle`> ktonga: ah so you want a way that works polymorphically between any two MonadError instances?
21:42:04 <jle`> yeah, there isn't
21:42:09 <jle`> note that MonadError only has two methods
21:42:28 <ktonga> im within a function that works polymorphically but i have to go concrete to IO to fork 
21:42:29 <jle`> so if the only thing you know about a type that it is a MonadError instance, all you know is throwError and catchError
21:43:01 <jle`> check out the typeclass -- http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Error-Class.html
21:43:02 <ktonga> then i cannot turn IOException into the other error (which is Text :) )
21:43:17 <jle`> there are only two methods in the typeclass
21:43:29 <jle`> however, if you have a specific instance in mind, we can probably do something
21:43:50 <ktonga> yeah i was hoping IO to be Bifunctor for IOException
21:43:55 <ktonga> but seems it's not
21:43:56 <jle`> but if you want to be polymorphic over all MonadError instances, you only have two methods
21:44:20 <glguy> You can make a new error type: data KtongaError = IOExceptionError IOException | TextError Text
21:44:20 <ktonga> i can add an extra constraint if needed 
21:44:34 <jle`> ktonga: you can turn an `IO a` into a `IO (EIther Text a)`, if you want
21:44:45 <jle`> where the second is a Left if the original throws an IO exception
21:45:12 <ktonga> tried that too but can't make the types align with all the errors and the lifts :D
21:45:17 <ktonga> ill keep trying 
21:45:26 <jle`> if you have some code, we can look at it to try to help
21:45:46 <jle`> alternatively yeah you can make a data type like what glguy gave, and you can "intercept" all IOExceptions and re-throw them as KtongaErrors
21:46:07 <glguy> Ideally all of the lifts are isolated to the problem-domain specific combinators
21:46:20 <ktonga> yeah i thought of that too, catch IOExc and map them to Text 
21:46:32 <glguy> and catching IO errors and then moving those into a wrapper exception transformer is bad practice
21:46:49 <jle`> you can't re-throw as Text, since Text is not an instance of Exception
21:46:50 <ktonga> yeah i think my main problems is im not structuring it well
21:47:19 <ktonga> can i paste a few lines snippet?
21:47:25 <glguy> gist.github.com
21:47:37 <jle`> does lpaste not work anymore? :'(
21:47:51 <glguy> No, it's crap now
21:47:59 <glguy> or down, depends on the time
21:48:05 <jle`> :(
21:48:25 <zalila> :-/
21:49:01 <ktonga> ok gimme a sec, it's just a first try to make it work then i'll beautify it
21:53:13 <ktonga> https://gist.github.com/ktonga/a16851d1a44407ff9979605921543baa
21:54:05 <ktonga> i know the problem is `pollForever` returning `IO ()`
21:55:07 <ktonga> also i dont like how all my functions are in IO :) i'm starting exploring ES + CQRS so I have to flush the design a lot 
21:55:18 <jle`> what is print' ?
21:55:31 <glguy> If you just stick to a simple type you won't have to jump through these hoops
21:55:41 <glguy> rather than trying to write things in terms of constraints
21:55:47 <ktonga> just for quick debug
21:55:50 <ktonga> print' :: (Show a, MonadIO m) => Text -> a -> m ()
21:55:50 <ktonga> print' txt = liftIO . print . (txt <>) . show
21:56:35 <jle`> yeah, this isn't really how MonadError is meant to be used
21:56:50 <ktonga> i imagined that
21:56:56 <jle`> how would you use the MonadError constraint, anyway?
21:56:59 <jle`> in updateProjection?
21:57:43 <jle`> what are you expecting to gain from writing it for all MoandError, and not just making it SignupEvent' -> IO () ?
21:57:48 <ktonga> i throw a few errors in certain cases so yeah instead of using ExcepT directly i do it with trowError form MonadError
21:58:15 <glguy> If you're already using IO, you should use IO's exception mechanism rather than trying to add ExceptT on IO
21:58:17 <ktonga> be cool? :P
21:58:36 <jle`> MonadError is supposed to be a separate sort of world from IO exceptions
21:59:20 <ktonga> yeah im having troubles coz most of my functions are in IO so im liftIO'ing all over the place too
21:59:21 <jle`> MonadError is more about threading of short-circuiting pure values, like Either
21:59:35 <glguy> You won't need to liftIO any more once you're just using IO
21:59:41 <jle`> ktonga: why would you need to use liftIO
21:59:43 <jle`> if everything is IO?
22:00:03 <zalila> bad one?
22:00:21 <jle`> what value does MonadIO give you here? :)
22:00:21 <ktonga> i'm also using libs like the kafka client that have such constraints
22:00:34 <ktonga> so i just propagated them, maybe that was the error
22:00:42 <jle`> that's great, since IO is an instance of MonadIO
22:00:48 <jle`> so any MonadIO constraint can be fulfilled by IO :)
22:00:52 <jle`> so you are free to use IO
22:01:04 <ktonga> yeah in a previous version i use IO instead 
22:01:14 <ktonga> this was an experiment, a failed one it seems :)
22:01:52 <ktonga> and i dont see myself using other type than IO anywhere, so...
22:02:06 <jle`> yeah, premature abstraction is definitely a cause of lots of headaches
22:02:20 <jle`> but yeah, when you do refactorings like this, it's a good idea first to ask why
22:02:26 <jle`> try to imagine what benefits it would bring
22:02:36 <jle`> and if it's worth the effort
22:02:50 <jle`> unuless it's just for fun i suppose :)
22:03:43 <ktonga> i guess it's also coming from Scala where tagless final is the latest fashion :)
22:04:23 <jle`> in this case you have inadvertently stumbled into one of the weirder parts of Haskell: "errors vs exceptions"
22:05:00 <jle`> the two live in different worlds and it takes some finesse to get used to when one world is appropriate over the other
22:05:21 <jle`> i think in other languages this line is convoluted more than it is in haskell
22:06:11 <glguy> "tagless final" is interesting, but if you're going to use it you're better off designing your own class that has the operations you wanted. It's uncommon for the ones in mtl to  be the right ones to use
22:06:16 <ktonga> yeah i thought i knew some haskell, but starting a real app (as in at my job) is a wall of frustration :) i ain't know shit
22:06:38 <jle`> ktonga: really i think what happened here is that you did know haskell
22:06:56 <jle`> but things fell apart when you tried adding fancy abstractions :)
22:07:01 <jle`> haskell isn't about the fancy abstractions
22:07:07 <jle`> even though that's what hits hackernews
22:07:11 <ktonga> my idea was using using record of functions for the algebras
22:07:19 <ktonga> i dont really like using TCs for that
22:07:39 <jle`> fwiw the analogy of MonadError for runtime exceptions is MonadThrow
22:07:50 <jle`> rough analogy, MonadError generalizes Either, MonadThrow generalizes IO
22:08:06 <ktonga> my idea of moving to haskell finally at work was to simplify my life which involves a lot of scala at the moment 
22:08:20 <ktonga> but things dont map 1:1
22:08:36 <jle`> heh, at least it's not boring :)
22:08:55 <ktonga> not at all! im having tons of fun
22:09:59 <jle`> ExceptT, Either, MonadError, etc., are all about threading 'error' semantics through 'pure' values
22:10:19 <jle`> IO, MonadThrow deal with GHC's great runtime exception mechanism
22:11:02 <jle`> mixing them is always kind of awkward
22:11:03 <ktonga> and i dont really know why i've thrown CQRS in the mix too
22:11:17 <ktonga> maybe i'm better off with a simpler arch
22:12:30 <ktonga> if i can separate my pure stuff from the IO one i guess it will become more clear, error handling im mean
22:14:17 <jle`> sometimes though IO is the best way to think about something
22:14:51 <ktonga> MonadIO is better for libs than for app code?
22:15:44 <glguy> It's better when the library exposes IO rather than MonadIO, which can add a performance penalty (in particular when you just wanted IO)
22:19:40 <ktonga> so what is the advice? work in IO Either a b with a transformer instead?
22:20:26 <ktonga> im using throwError ATM to shortcircuit
22:20:44 <glguy> a transformer for what?
22:20:56 <ktonga> to flatten IO and Either
22:21:12 <ktonga> like ExceptT
22:21:16 <glguy> You can just use IO exceptions for that, make your error an instance of Exception
22:21:16 <jle`> ktonga: the advice is that your code was already perfectly fine with IO :)
22:21:35 <glguy> It doesn't generally pay off to expose transformers
22:22:00 <glguy> If you're going to use them it's better to use them to implement a newtype an to write all the operations you need to work with that newtype
22:22:00 <ktonga> the code with IO was simpler with only an echo example in kafka 
22:22:19 <ktonga> no im trying to implement something a bit more complicated reusing that
22:22:23 <glguy> If you can get away with just IO and no transformers you'll be doing pretty well
22:24:25 <jle`> yeah, transformers don't really add any general benefit
22:24:30 <jle`> they don't make all code better
22:24:41 <jle`> they only have very specific specialized use cases where they can help 
22:24:51 <jle`> they aren't a general tool for making code better, they are a precision tool only useful for specific situations
22:25:01 <jle`> and in every other situation they make things much worse
22:25:31 <ktonga> OK, i will try. I thought that exceptions were to be avoided in Haskell, i think it was a misconception 
22:25:45 <jle`> partial functions should be avoided
22:25:54 <jle`> runtime exceptions in IO are completely different, heh
22:26:06 <jle`> it's one of the most powerful tools we have
22:26:22 <ktonga> but if i work in IO i have to produce the excepetion, haven't i?
22:26:33 <jle`> what do you mean?
22:26:40 <jle`> you don't have to produce exceptions
22:26:43 <jle`> if you don't want to
22:27:00 <ktonga> where i would use a Left blah i have to make the IO fail instead
22:27:25 <jle`> one thing you can do is just use normal pattern matching
22:27:33 <jle`> case myEither of Left x -> throwIO ....; Right x -> ...
22:28:16 <ktonga> like a liftEither
22:28:17 <jle`> pattern matching is one of the best things about haskell :)
22:28:33 <jle`> kinda, but there's no need to overcomplicate something as simple as pattern matching
22:29:06 <jle`> pattern matching is one of the language features that haskellers use the most
22:29:29 <ktonga> yeah in scala is heavily used too 
22:29:53 <ktonga> but for things like either and maybe i would prefer a folding-like function instead 
22:29:58 <jle`> how come?
22:30:32 <ktonga> use either and maybe :) so you have it in one line 
22:30:43 <jle`> why is one line a benit?
22:30:48 <jle`> *benefit
22:31:05 <ktonga> pattern matching makes you kinda abouse of where so it looks nice within a do
22:31:29 <jle`> hm, not sure what you mean
22:31:39 <jle`> i don't think having code on one line is every a benefit in and of itself
22:31:43 <jle`> *is ever a benefit
22:31:58 <ktonga> nvm, i think this is just a matter of personla taste 
22:32:13 <jle`> using either and maybe causes a lot of problems over using pattern matching
22:32:23 <jle`> for one, pattern matching lets you take advantage of layouting
22:32:38 <ktonga> the idea is always to work withe the either and produce the IOs for both branches instead of using a transformer then?
22:32:42 <jle`> so it's much easier to write multi-line things, because you can take advantage of indenting
22:32:56 <glguy> I find functions like 'maybe' are most suited for partial application and use with higher-order functions as long as the arguments are simple, so something like: map (maybe z f)
22:32:57 <jle`> and blocking
22:33:17 <jle`> yeah, the only time i ever use maybe or either is in partially applied form, meant to be passed to higher-order functions
22:33:24 <jle`> in any other situation the code is usually much less readable
22:33:29 <jle`> like, by a large factor
22:34:12 <jle`> pattern matching giving layouting is also a large contributor to this, since if your case bodies are long, you can provide an argument over multiple lines
22:34:18 <jle`> with either/maybe, you have to use parentheses in a very awkward way
22:34:28 <ktonga> yeah i understand that, i use it to do pointfree
22:34:47 <jle`> pointfree is also something that usually makes code less readable
22:34:54 <jle`> in most situations
22:35:07 <ktonga> i know :( not for me tho
22:35:19 <jle`> for you, it usually makes code more readable?
22:35:46 <ktonga> if it is not crazy long like 5 fns composed 
22:35:54 <arahael> I've begun to prefer *trivial* pointfree expressions.
22:36:05 <jle`> ktonga: so, it only makes trivial functions more readable? ;)
22:36:11 <ktonga> just for two or three i think is nice
22:36:54 <ktonga> but the alternative is a like with lots of $$$$$$ and ()()()()()()\
22:37:05 <ktonga> s/like/line
22:37:07 <jle`> ktonga: but yeah, to answer your original question, there is no reason to use transformers unless you are taking advantage of a very specific and narrow use case they provide 
22:37:18 <glguy> ktonga: Or even better naming subexpressions
22:37:19 <jle`> you should never add monad transformrs just because
22:37:47 <jle`> you should only use monad transformers if you are in a specific situation where you can take advantage of the very specific and specialized benefit they provide
22:37:51 <jle`> they are not useful in general
22:38:01 <ktonga> cool! so transformer only to flatten the monads for a do is an antipattern
22:38:30 <jle`> hm, what do you mean by 'flatten the monads for a do' ?
22:39:01 <ktonga> use IO a and IO Maybe a in the same do
22:39:17 <jle`> what i meant really was that using transformer for no reason is an antipattern
22:39:23 <jle`> but using transformers for a reason is a good idea normally
22:39:29 <ktonga> ok :D
22:39:35 <jle`> if your transformers provide a benefit, it might make sense to use them
22:39:40 <jle`> i was talking about using transformers for no reason
22:40:31 <ktonga> i thought its one and only benefit was to add the effect of one monad to another 
22:40:44 <ktonga> like add error handling to any monad with ExceptT
22:41:46 <jle`> a monad transformer takes a monad and returns a new monad instance. if you take advantage of that new monad instance (that new definition of (>>=), (>>)) then it can be useful
22:42:58 <jle`> but you pay a price in some line noise
22:42:59 <boj> i find ReaderT over IO particularly useful. coupled with a MonadDb constraint, i can limit which functions can access a database connection pool that gets passed around
22:44:40 <jle`> ktonga: but yeah, my original advice was given because you would be surprised how many people just wrap their code in monad transformers for no reason, not taking advantage of any of their benefits, just because they think it's the thing to do
22:44:43 <glguy> You can limit which functions get the database handle by not passing the handle those functions
22:45:11 <boj> glguy: agreed, but that gets complicated in a huge code base
22:45:23 <ktonga> ok it will feel like my java days but i'll give it a try to throwIO
22:45:43 <glguy> In a huge code base you typically don't have a single resource to be controlled
22:46:11 <glguy> (that is you have multiple)
22:46:12 <boj> yeah, i was oversimplifying my example
22:47:36 <jle`> ktonga: fwiw i do use many monad transformers fairly often, but i understand that there's always a cost and i try to be aware of the benefits and see if they outweigh the cost first.  but i know that being able to judge this is a sense that takes some practice
22:48:04 <jle`> so maybe it wouldn't be too bad after all to try it out for small benefits :)
22:48:15 <jle`> just so you can know where that threshold is for you
22:48:23 <boj> conversations like these always make me curious if i've gone in the wrong direction. "you don't need a transformer stack" - yes, you can definitely write a lot of code without them and explicitly pass stuff around, but it seems like they make scaling code easier as your code base grows
22:54:08 * boj kills the channel
22:54:23 <glguy> I find that it's better to make a newtype for the application if you intend for it to scale up than to plan to layer on raw transformers
22:54:32 <glguy> If the transformers happen to be the implementation of the newtype that's just fine
22:55:04 <glguy> This way that complexity can be isolated to the implementation of this common type and adding new functionality or operations doesn't need to then be propagated through the app
22:55:20 <dminuoso> What is the reason GHC frequently declares instances like this: `instance Monad (IOEnv m) where (>>=) = thenM` and then providing a top level binding for thenM?
22:55:22 <boj> that makes sense, and is what i do (servant heavy API stuff).
22:55:37 <MarcelineVQ> where does one learn about these ideas for app design?
22:57:30 <glguy> Primarily from designing apps, secondarily from discussions with other Haskell programmers
22:57:31 <boj> nothing concrete that i am aware of
22:57:42 <glguy> There might be a good written reference but I'm not aware of it
22:57:49 <MarcelineVQ> shucks.
22:57:55 <ktonga> so you newtype your monad stack and then define instances for it?
22:58:47 <glguy> You typically don't need any classes or instances unless there's a family of types that need to share some operations
22:59:15 * dminuoso .oO( a Monad instance would be nice for a monad tranformer stack )
22:59:19 <boj> ktonga: usually just the newtype and a run function which handles the entry point to your app and all the run* methods to call
22:59:34 <boj> functions*
22:59:36 <glguy> Sure, your basics like Functor, Applicative, Monad are good to have
22:59:42 <ktonga> but you need them to leverage all the abstract functionality from libs and base
22:59:55 <dminuoso> ktonga: If you need an instance then sure provide it.
23:01:24 <ktonga> ha! that quick correction :) <3 at least you didn't write procedures :P
23:01:59 <boj> i'm not even sure why i said that word :p
23:02:12 <ktonga> the oop dev in you
23:02:28 <ktonga> the M word
23:02:30 <glguy> Haskell classes have methods, too. (it's not only an OOP word)
23:02:56 <ktonga> why are they not functions?
23:03:06 <boj> because they dispatch based on the instance?
23:03:07 <dminuoso> ktonga: A function has a precise mathematical meaning.
23:03:07 <ab9rf> because they might not be
23:03:20 <ab9rf> a method can have any type signature
23:03:34 <ktonga> i understand by method some internal state requiered otherwise it's just a -> b 
23:03:37 <dminuoso> % class Sizable a where sizeOf :: Int
23:03:37 <yahb> dminuoso: ; <interactive>:32:23: error:; * Could not deduce (Sizable a0); from the context: Sizable a; bound by the type signature for:; sizeOf :: forall k (a :: k). Sizable a => Int; at <interactive>:32:23-35; The type variable `a0' is ambiguous; * In the ambiguity check for `sizeOf'; To defer the ambiguity check to use sites, enable AllowAmbiguousTypes; 
23:03:45 <dminuoso> % :set -XAllowAmbiguousTypes
23:03:45 <yahb> dminuoso: 
23:03:49 <dminuoso> % class Sizable a where sizeOf :: Int
23:03:49 <yahb> dminuoso: 
23:03:52 <ab9rf> ktonga: sorry, that's an OO definition of method
23:03:58 <dminuoso> % instance Sizable Int32 where sizeOf = 32
23:03:58 <yahb> dminuoso: 
23:04:07 <dminuoso> Voila! Method without a function!
23:04:25 <cocreature> dminuoso: it’s a function that accepts a type argument! ;)
23:04:29 <ski> (you can have immutable OO)
23:04:35 <ktonga> func type -> int
23:04:42 <MarcelineVQ> dminuoso: I may have gone with mempty
23:04:52 <ktonga> or default
23:05:11 <ktonga> but the TC mechanism is resolving the input for the function 
23:05:18 <ab9rf> TC?
23:05:24 <ktonga> typeclass sorry
23:05:31 <ab9rf> mmm
23:05:39 <ktonga> kinda :)
23:05:42 <dminuoso> ktonga: If you want to be really pedantic then cocreature is right. the actual type of sizeOf is: sizeOf :: forall a. Int
23:05:56 <ab9rf> it's still not a function though
23:06:29 <dminuoso> ab9rf: It's a function from kind * to Int.. kind of..
23:06:40 <dminuoso> I can even apply it with TypeApplications.
23:06:49 <dminuoso> sizeOf @Int = 32
23:06:50 <ab9rf> dminuoso: well, arguably, yes
23:07:04 * ski . o O ( `sizeOf :: forall a. Sizable a => Int')
23:07:17 <dminuoso> ski: Which corner should I take?
23:07:23 <ab9rf> hehe i was wondering if someone would point that out
23:07:24 <dminuoso> I shall stand there for the rest of the day in shame.
23:07:25 <ktonga> in the docs typeclasses operations are listed under `Methods` section :(
23:07:29 <ski> corner ?
23:07:49 * ski ponders eating a corner of a cake
23:07:53 <glguy> class Fun where fun :: Int; instance Fun where fun = 42
23:07:54 <ab9rf> ski: where naughty people are made to sit
23:07:58 <dminuoso> You have cake? Im jealous.
23:08:02 <glguy> There we go, no more trying to sneak functions back into the picture
23:08:04 <ab9rf> i want cake!
23:08:12 <ab9rf> cake function
23:08:14 * ski made squash cake .. too bad it is round, doesn't have corners
23:08:27 <ab9rf> ski: i have a knife, i can make anything have corners
23:08:28 <dminuoso> ski: It's probably not an ideal circle.
23:08:32 <glguy> {-# Language MultiParamTypeClasses #-} allows for zero-parameter classes
23:08:35 <dminuoso> ski: So it has microcorners.
23:08:52 <ski> well, then i could only micronibble it
23:08:54 <dminuoso> % :set -XMultiParamTypeClasses
23:08:54 <yahb> dminuoso: 
23:09:09 <dminuoso> % class Nope where how :: Int
23:09:09 <yahb> dminuoso: 
23:09:13 <dminuoso> % :t how
23:09:13 <yahb> dminuoso: ; <interactive>:1:1: error: No instance for Nope arising from a use of `how'
23:09:18 <dminuoso> :(
23:09:20 <ktonga> that's because typeclasses are like OOP interfaces :P (dont ban me please)
23:09:32 <dminuoso> glguy: Curious, how does one use this?
23:09:43 <ab9rf> ktonga: purge thatthought, it will only lead you into trouble
23:09:52 <dminuoso> ktonga: typeclasses were invented specifically for overloading.
23:09:53 <glguy> dminuoso: You could use it to disassociate the declaration from its implementation across modules
23:10:17 <ab9rf> ktonga: it's not entirely wrong, but it's wrong enough that it will hurt you more than it will help you
23:10:31 <ktonga> it was a "joke" i dont really believe that :O
23:10:54 <dminuoso> glguy: Do you have a slightly more concrete example? I dont quite follow.
23:12:07 <glguy> I've never actually used it for anything. I don't know of anything that's ever used it.
23:12:23 <glguy> I have a vague memory that this was shachaf's fault that it works
23:12:35 <dminuoso> % :k Nope
23:12:35 <yahb> dminuoso: Nope :: Constraint
23:12:48 <dminuoso> Is this like the unit constraint?
23:13:04 <dminuoso> % f :: Nope => Int; f = 10
23:13:05 <yahb> dminuoso: 
23:13:05 <glguy> No, because it's not necessarily satisfied until you write an instance
23:13:10 <ski> @let class Holds ct where {dict :: Dict ct}; instance ct => Holds ct where {dict = Dict}
23:13:11 <lambdabot>  Defined.
23:13:38 <glguy> % f
23:13:38 <yahb> glguy: ; <interactive>:41:1: error:; * No instance for Nope arising from a use of `f'; * In the expression: f; In an equation for `it': it = f
23:13:55 <dminuoso> glguy: Oh.. so it's closer to Void then?
23:14:02 <dminuoso> I mean it seems unsatisfiable
23:14:03 <glguy> No, because you can write an instance
23:14:06 <dminuoso> How?
23:14:12 <glguy> try
23:14:20 <dminuoso> % instance Nope Int
23:14:20 <yahb> dminuoso: ; <interactive>:42:10: error:; * Expected kind `* -> Constraint', but `Nope' has kind `Constraint'; * In the instance declaration for `Nope Int'
23:14:30 <dminuoso> % instance Nope Maybe
23:14:30 <yahb> dminuoso: ; <interactive>:43:10: error:; * Expected kind `(* -> *) -> Constraint', but `Nope' has kind `Constraint'; * In the instance declaration for `Nope Maybe'
23:14:36 <glguy> kind error
23:14:55 <dminuoso> Oh.
23:14:58 <dminuoso> % instance Nope
23:14:58 <yahb> dminuoso: ; <interactive>:44:10: warning: [-Wmissing-methods]; * No explicit implementation for; `how'; * In the instance declaration for `Nope'
23:14:59 <shachaf> glguy: Oh, man, why did I even do that?
23:15:01 <dminuoso> Wow. What is this.
23:15:10 <glguy> shachaf: Was it yuou?
23:15:20 <shachaf> Yes.
23:15:30 <glguy> 1 point for that neuron
23:15:46 <dminuoso> Interesting so..
23:15:53 <dminuoso> % instance Nope where how = 10
23:15:53 <yahb> dminuoso: 
23:16:00 <dminuoso> % :t how
23:16:00 <yahb> dminuoso: Int
23:16:08 <shachaf> The trouble is that the instance has to be either orphan or declared together with the class.
23:16:29 <glguy> % how
23:16:29 <yahb> glguy: 10
23:16:37 <dminuoso> Shouldn't that strictly be `how :: Nope => Int`
23:16:54 <glguy> No, because the Nope constraint can be solved
23:16:59 <glguy> There's an instance right there
23:17:23 <glguy> Just like we wouldn't expect: fmap :: Functor [] => (a -> b) -> [a] -> [b]    
23:17:34 <glguy> the Functor [] gets solved
23:17:45 <glguy> an instance is found, we don't keep the constraint around
23:18:07 <glguy> % class Nope1 where how1 :: Int
23:18:07 <yahb> glguy: 
23:18:11 <glguy> % :t how1
23:18:11 <yahb> glguy: ; <interactive>:1:1: error: No instance for Nope1 arising from a use of `how1'
23:18:28 <dminuoso> glguy: ^- thats what confuses me.
23:18:37 <dminuoso> glguy: I would have, at the minimum, expected this to work.
23:18:38 <nshepperd1> The instance could be generated magically / incoherently, like HasCallStack is
23:19:09 <nshepperd1> So maybe it has some obscure uses with ghc type checker plugins
23:19:30 <nshepperd1> For generating some sort of debugging info
23:20:31 <cocreature> % class Foobar where
23:20:31 <yahb> cocreature: 
23:21:10 <cocreature> % instance TypeError (Text "foobar") => Foobar
23:21:10 <yahb> cocreature: ; <interactive>:55:10: error:; Ambiguous occurrence `TypeError'; It could refer to either `GHC.TypeLits.TypeError', imported from `GHC.TypeLits'; or `Control.Exception.TypeError', imported from `Control.Exception' (and originally defined in `Control.Exception.Base')
23:21:18 <cocreature> % instance GHC.TypeLits.TypeError (Text "foobar") => Foobar
23:21:18 <yahb> cocreature: ; <interactive>:56:10: error:; * Illegal nested constraint `(TypeError ...)' (Use UndecidableInstances to permit this); * In the instance declaration for `Foobar'
23:21:27 <cocreature> % :set -XUndecidableInstances
23:21:27 <yahb> cocreature: 
23:21:29 <cocreature> % instance GHC.TypeLits.TypeError (Text "foobar") => Foobar
23:21:29 <yahb> cocreature: 
23:21:34 <glguy> % let x :: Nope1 => Int; x = how1 in ()
23:21:35 <yahb> glguy: ()
23:21:42 <cocreature> % foo :: Foobar => Int; foo = 1
23:21:42 <yahb> cocreature: 
23:21:46 <cocreature> % foo
23:21:46 <yahb> cocreature: ; <interactive>:62:1: error:; * foobar; * In the expression: foo; In an equation for `it': it = foo
23:21:47 <glguy> dminuoso: You have to let GHC know that even though there are no variables in the constraint that it's OK to defer it
23:22:06 <cocreature> maybe useful for providing custom errors if you remove a definition?
23:23:34 <glguy> Like many things I think it exists because it should for consistency, not because it was known to be useful
23:23:34 <cocreature> hm no you could just add the TypeError constraint directly on foo
23:30:06 <nshepperd1> You could use it to give () :: Constraint a haskell definition instead of it built in (actually i assume this would also need a syntax extension to make "class () where " legal)
23:37:18 <dminuoso> glguy: Ohh I see. It would be equivalent to asking this:
23:37:24 <dminuoso> % :t fmap @Void
23:37:24 <yahb> dminuoso: ; <interactive>:1:7: error:; * Expected kind `* -> *', but `Void' has kind `*'; * In the type `Void'; In the expression: fmap @Void
23:37:27 <dminuoso> Uhh
23:37:38 <dminuoso> data Magic a = Magic a
23:37:39 <dminuoso> % data Magic a = Magic a
23:37:39 <yahb> dminuoso: 
23:37:42 <dminuoso> % :t fmap @Magic
23:37:43 <yahb> dminuoso: ; <interactive>:1:1: error: No instance for (Functor Magic) arising from a use of `fmap'
23:37:59 <dminuoso> Okay I think Im beginning to understand what I dont understand.
