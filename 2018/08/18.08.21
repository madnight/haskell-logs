00:00:09 <cocreature> coldpresent: there is no casting going on, you are specializing the type variable a to be Int. nothing is being converted or cast
00:00:51 <cocreature> but yeah if you specialize it yourself, then ghci won’t attempt to do specialization for you. after all there is no variable left to specialize, Int is just a concrete type
00:03:47 <coldpresent> thanks for the clarification
00:08:45 <johnw> alp: so, it's never seeing my instance
00:09:08 <johnw> alp: the cmediatype proxy ends up as application/octet-stream
00:12:22 <gonz_> Does anyone have a solid nix setup for using ghc-mod?
00:12:57 <gonz_> I really miss my old emacs setup where I could use all the nice stuff like insert type, case splits, etc.
00:13:38 <gonz_> Or does `haskell-ide-engine` offer this as well and I just haven't realized?
00:14:08 <johnw> alp: a bit more context: https://gist.github.com/5a314b8389b617bb24542fe26086c368
00:14:20 <johnw> I would think the instances get used at 'serve', no?
00:15:12 <johnw> omg, grrr
00:15:24 <johnw> StreamGet's content-type doesn't match, but it's not a type error
00:15:30 <johnw> i've not been changing it in both places all the time
00:16:34 <johnw> ok, now it works
00:18:34 <jle`> koz_: nice :)
00:30:09 <koz_> jle`: I thought so too.
01:21:43 * hackage xmonad 0.14.2 - A tiling window manager  http://hackage.haskell.org/package/xmonad-0.14.2 (PeterSimons)
01:23:01 <ArahaelPi> Is xmonad 100% haskell, or?
01:23:26 <bshelden> Up until you hit the X bindings, anyway
01:23:52 <ArahaelPi> Interesting - cool. :)
01:32:12 <Ariakenom> There's waymonad https://github.com/waymonad/waymonad
01:32:16 <Ariakenom> related
01:32:44 <ArahaelPi> Very nice. ;)
01:33:20 * ArahaelPi really needs to get himself a nice Linux desktop system.
01:34:27 <ArahaelPi> When I get one (next year), I hope to give NixOS a go.
01:34:39 <ArahaelPi> (nixOS would be too painful on a Raspberry PI)
01:37:13 <Ariakenom> ArahaelPi: I've considered nix on RPi. Is it terrible?
01:37:48 <olligobber> Is there a nice way to apply (a -> IO b) to a function (a -> b) -> IO c ?
01:37:48 <ArahaelPi> Ariakenom: I have the most powerful RPi, and it wasn't easy to get haskell stack on it even with the default raspbian already setup.
01:38:17 <Taneb> ArahaelPi: back in 2013 I didn't have much trouble getting GHC+cabal-install on one
01:38:32 <ArahaelPi> Ariakenom: It crashed twice, and I now know that was because it was swapping -> super-massive slowdown -> high heat -> throttling...
01:38:36 <Taneb> Although I can't remember what I did, and things may have changed
01:39:22 <ArahaelPi> Taneb: I think it was much easier to get GHC and cabal itself on, I suspect.  But stack has a bit of overhead.
01:39:39 <ph88> how can i run this code?  https://github.com/snoyberg/packdeps/tree/web/packdeps-yesod 
01:39:44 <ArahaelPi> olligobber: Isn't that just bind?
01:40:04 <ArahaelPi> olligobber: Though, you still need an (a->c) or something there.
01:41:24 <olligobber> One solution was to turn the a -> IO b into IO (a -> b) and then use bind
01:41:30 <olligobber> I was just wondering if there was a nicer one
01:42:15 <ArahaelPi> olligobber: Try it and then see what hlint says?
01:46:51 <ph88> anyone experience with yesod ?
01:51:42 <pavonia> ph88: Better to just ask your question
01:53:07 --- mode: glguy set +v ilbelkyr6
01:53:08 <ilbelkyr6> |              / ('  /      (o)   |
01:53:11 <ilbelkyr6> |             /   '"'           .-\_
01:53:49 <xacktm> glguy: btw new spam getting past your filters ^
01:54:43 * hackage quickcheck-state-machine 0.4.0 - Test monadic programs using state machine based models  http://hackage.haskell.org/package/quickcheck-state-machine-0.4.0 (stevana)
01:56:41 <ph88> pavonia, i asked my question :/  -- how can i run this code?  https://github.com/snoyberg/packdeps/tree/web/packdeps-yesod
01:57:03 <hololeap> olligobber: how did you turn `a -> IO b` into `IO (a -> b)` ?
01:57:11 <pavonia> ph88: Oh sorry, didn't see that
01:57:49 <ph88> it's a simple question, it's just that i've never done it before
01:58:31 <hololeap> ph88: have you tried on #yesod ?
01:59:17 <ph88> didn't know that channel exist
01:59:43 * hackage nakadi-client 0.6.0.0 - Client library for the Nakadi Event Broker  http://hackage.haskell.org/package/nakadi-client-0.6.0.0 (mtesseract)
01:59:44 <pavonia> ph88: Looks like a normal cabal package. So put the code into a folder, run `cabal install packdeps-yesod`, then the library and binary should be installed
01:59:55 <ph88> i use stack
02:00:03 <olligobber> hololeap, I adjusted the function that was returning a thing of type a -> IO b to instead return a lambda inside IO
02:00:22 <ph88> i already did   stack build
02:01:13 <ph88> pavonia, you gave me an idea i think i got it now thanks
02:01:53 <olligobber> I can't actually think of a general function (a -> IO b) -> IO (a -> b)
02:01:57 <ph88> stack exec -- packdeps-server Development
02:02:15 <dminuoso> olligobber: Because they are different things?
02:02:50 <olligobber> dminuoso, a and IO a are different things, but you can convert between them
02:02:56 <dminuoso> olligobber: One is simply an IO action that, as a result, produces a function. The other is a function that, as a result, produces an IO action.
02:02:58 <hololeap> olligobber: i think it would require a traversable instance for either (a ->) or IO, which presumably isn't possible 
02:03:03 --- mode: glguy set +v CristvoGomesFerr
02:03:19 <olligobber> well, one way atleast
02:03:51 <dminuoso> olligobber: Consider this example:
02:03:55 <cocreature> olligobber: for IO (a -> b) you can do some IO but eventually you need to produce a function a -> b, so you can’t use any information from "a" to perform IO computations
02:04:02 <cocreature> for a -> IO b you most certainly can use that information
02:04:09 <dminuoso> olligobber: (\s -> if s then launchMissiles else signTreaty)
02:04:29 <dminuoso> olligobber: How could you *possibly* turn it into.. well the other thing
02:04:32 <cocreature> why are computer scientists so keen to launch missiles?
02:04:36 <olligobber> cocreature, good explanation
02:04:58 <dminuoso> olligobber: because launching missiles is a good example of rather drastic effects...
02:05:16 <dminuoso> also because we like SPJ papers.
02:05:23 <quchen> cocreature: Quite the contrary! We use launching missiles as an example of things not to do. It’s like suicide in philosophy, it’s the thing we have to be able to talk about in order to not have it.
02:05:50 <quchen> cocreature: Imagine we had »release the puppies«, everyone would unsafePerformIO that like mad!
02:05:54 <olligobber> now back to my original question, is there a way to do (a -> IO b) -> ((a -> b) -> IO c) -> IO c ?
02:06:05 <cocreature> quchen: ah makes sense! :D
02:06:14 <dstolfa> or... "pet kittens"
02:06:19 <dminuoso> olligobber: Too much XY for my taste. What exactly are you trying to do?
02:06:51 <dminuoso> olligobber: The fact that you want this feels like you have some fault in your logic going on.
02:07:09 <dstolfa> i'm confused as well
02:07:15 <dstolfa> why (a -> IO b)?
02:07:22 <dstolfa> if you already have (a -> b) -> IO c?
02:07:30 <dstolfa> i don't understand why you need the first thing
02:07:31 <olligobber> dminuoso, I have a thing that takes a filename and a thing that it's looking for in a file, and returns whether it found the thing in the file
02:07:50 <olligobber> so it has type String -> a -> IO b
02:08:19 <dminuoso> olligobber: Can we, for argument sake, use some upper case type names here?
02:08:33 <dminuoso> so say `String -> Stuff -> IO Bool` right?
02:08:38 <olligobber> sure
02:09:04 <olligobber> and I have another thing that takes a stuff verifier and launches a nice interface, it has type (Stuff -> Bool) -> IO ()
02:09:31 <olligobber> I want to use the stuff verifier (after I give it the filename) in the interface
02:10:26 <dminuoso> "launches a nice interface"
02:10:28 <cocreature> read the file first and then you can write Stuff -> Bool
02:11:18 <hololeap> olligobber: i think the confusion here is you have an implicit `a` hanging around, which you didn
02:11:23 <olligobber> dminuoso, yeah, it prompts for user input and flashes big warnings on some input
02:11:36 <hololeap> 't mention, so the signature would be more like `(a -> IO b) -> ((a -> b) -> IO c) -> a -> IO c`
02:11:45 <dminuoso> olligobber: Oh okay. Interface is a bit confusing, becuase in programming lingo that has a very distinct meaning.. :P
02:12:06 <olligobber> hololeap, nope, no implicit a, that is collected from user input
02:12:10 <cocreature> user interface isn’t exactly an unknown term in programming lingo :)
02:12:29 <olligobber> yeah, I should have specified user interface
02:12:44 <olligobber> anyway, I think the best solution is to change the types of my things
02:12:45 <dminuoso> cocreature: Curiously I didn't even make the conneciton, I tried really hard to understand what it meant to no avail :P
02:13:08 <ph88> is that normal when there is an error in the hamlet file that it the compiler message don't point to this error ?
02:13:09 <cocreature> olligobber: have you considered the solution I proposed? that shouldn’t require any changes
02:13:53 <Ariakenom> dminuoso: Too much Java#? It has no distinct meaning in Haskell, right?
02:14:32 <dstolfa> Java has weird naming
02:14:46 * dstolfa would never expect objects to be terms of some type
02:14:51 * dstolfa would instead expect objects to be types
02:15:09 <olligobber> cocreature, your solution requires changes
02:15:14 <olligobber> anyway, it isn't that important
02:15:27 <olligobber> I was just curious if such a function existed, cos for a moment it felt like it could
02:16:13 <cocreature> olligobber: it requires changing the a -> IO b but not the (a -> b) -> IO c
02:16:58 <olligobber> cocreature, my other solution also requires changing the a -> IO b but not the (a -> b) -> IO c, and to an even lesser extent
02:17:10 <cocreature> fair enough :)
02:18:21 <hololeap> :t \f g a -> f a >>= flip g a
02:18:22 <lambdabot> Monad m => (b1 -> m a) -> (a -> b1 -> m b2) -> b1 -> m b2
02:18:43 <CristvoGomesFerr> m (a -&gt; b) -&gt; a -&gt; m b: It feels like it could exist, but it doesn't, it has already happened to me a lot. I always have to prove it to myself using m = Maybe and I am never convinced...
02:19:17 <CristvoGomesFerr> Or the other way around, I don't remember
02:19:52 <cocreature> please don’t start using html escapes in irc :(
02:19:53 <olligobber> CristvoGomesFerr, the other way around, the one you said is \f x -> ($ x) <$> f
02:20:00 <olligobber> ^ agreed
02:20:41 <hololeap> :t (\f g a -> f a >>= g a) :: Monad m => (a -> m b) -> (a -> b -> m c) -> a -> m c
02:20:42 <lambdabot> Monad m => (a -> m b) -> (a -> b -> m c) -> a -> m c
02:20:53 <hololeap> it just needs that `a` available to make it work
02:21:04 <cocreature> hololeap: that’s still not it, you have a -> b -> m c instead of (a -> b) -> m c
02:21:16 <hololeap> oh, oops
02:21:21 <olligobber> yeah
02:23:27 <olligobber> ah, if we agree that (a -> IO b) -> IO (a -> b) cannot exist, that implies the non-existance of (a -> IO b) -> ((a -> b) -> IO c) -> IO c
02:23:52 <olligobber> for the case where c = a -> b and the second argument is return
02:24:13 <hololeap> :t dimap :: ((a -> b) -> a) -> (IO b -> IO c) -> (a -> IO b) -> ((a -> b) -> IO c)
02:24:14 <lambdabot> ((a -> b) -> a) -> (IO b -> IO c) -> (a -> IO b) -> (a -> b) -> IO c
02:24:32 <hololeap> that's all i've got
02:24:34 <olligobber> so yeah, it doesn't exist, unsolvable, thanks for your help everyone
02:27:34 <hololeap> is `((a -> b) -> a)` even possible in haskell?
02:28:07 <hololeap> besides when a ~ ()
02:28:17 <Taneb> hololeap: whenever a is inhabited
02:28:35 <Taneb> :t const mempty :: Monoid a => (a -> b) -> a
02:28:36 <lambdabot> Monoid a => (a -> b) -> a
02:28:43 <cocreature> are you talking about "forall a b. ((a -> b) -> a)" or some fixed choice of a and b?
02:29:02 <Taneb> hololeap: but in general, no, consider the type Void (data Void;)
02:29:26 <Taneb> There's the function absurd :: Void -> a
02:29:50 <Taneb> If we had the general case of your suggestion, we'd have (Void -> a) -> Void, which we could pass absurd and get a Void out
02:29:56 <Taneb> And Void is uninhabited
02:30:39 <Taneb> So, you know, bad stuff
02:31:17 <olligobber> :t const undefined :: (a -> b) -> a
02:31:18 <lambdabot> (a -> b) -> a
02:31:39 <olligobber> if a has no constructors, such a function could not exist
02:31:48 <hololeap> i was just thinking that the ((a -> b) -> a) seems to be the tricky part in that dimap, and maybe why that function is impossible 
02:32:16 <Taneb> hololeap: there are definitely functions of type "((a-> b) -> a)" for *specific* a and b
02:32:29 <Taneb> As I said, they exist whenever a is inhabited
02:32:36 <Taneb> So that's not a problem
02:34:02 <madnight> isn't there for every Functor a Functor from the Codomain, in Haskell Contravariant?
02:35:42 <madnight> % import Data.Functor.Contravariant
02:35:43 <yahb> madnight: 
02:36:10 <madnight> % :t contramap
02:36:11 <yahb> madnight: Contravariant f => (a -> b) -> f b -> f a
02:36:31 <hololeap> Taneb: the only other way i can see it working is if `a` is inhabited with something akin to (a, b -> a)
02:36:32 <lavalike> how does THAT work
02:36:53 <cocreature> madnight: what exactly do you mean by “a functor from the codomain”?
02:37:19 <cocreature> lavalike: newtype Pred a = Pred (a -> Bool) and f = Pred
02:37:43 <Taneb> hololeap: if you have an "a" you can use const to get a "b -> a" for free
02:38:03 <cocreature> or if you want a boring example "newtype Const a b = Const a"
02:39:04 <hololeap> Taneb: i meant the only way without ignoring the first argument (the `a -> b` argument)
02:39:42 <hololeap> but yeah, that is the way to get it for free
02:41:02 <hololeap> it just makes narrowing it down to `(a -> b) -> a` instead of `b -> a` pointless
02:43:31 <hololeap> :i Op
02:43:39 <hololeap> % :i Op
02:43:40 <yahb> hololeap: newtype Op a b = Op {getOp :: b -> a} -- Defined in `Data.Functor.Contravariant'; instance Monoid a => Monoid (Op a b) -- Defined in `Data.Functor.Contravariant'; instance Semigroup a => Semigroup (Op a b) -- Defined in `Data.Functor.Contravariant'; instance Floating a => Floating (Op a b) -- Defined in `Data.Functor.Contravariant'; instance Fractional a => Fractional (Op a b) -- Defined in `Data.Fun
02:43:49 <madnight> cocreatue: i mean from the opposing category C^op
02:44:46 <dminuoso> madnight: That's also Functor.
02:44:54 <dminuoso> madnight: The categorical dual of a Functor is Functor.
02:46:16 <madnight> okay and it's not contravariant?
02:52:01 <dstolfa> madnight: it is, if you have a covariant functor F : C -> D, then G : Cop -> D is contravariant
02:52:34 <phadej> but if you E = Cop, it's again covariant!
02:52:39 <phadej> so it depends!
02:52:42 <dstolfa> in fact, contravariant functors are sometimes defined as covariant functors on the opposite category
02:52:50 <madnight> okay so i think Haskell could auto derive Contravariant just like it can auto derive Functors right?
02:52:58 <phadej> madnight: yes and no
02:53:04 <olligobber> wait, contravariance? isn't that related to subtyping?
02:53:14 <dstolfa> phadej: it's covariant w.r.t. Cop, but contravariant w.r.t. C
02:53:18 <dstolfa> phadej: hence my definition above :-)
02:53:34 <dstolfa> phadej: it really depends on what people prefer
02:53:42 <phadej> madnight: Compose f g = Compose (f (g a)) derivng Contravariant -- what to do?
02:53:47 <dstolfa> phadej: some people prefer to just work with covariant functors and define the functor w.r.t. Cop
02:53:57 <dstolfa> others prefer to work with contravariant functors, but they're all just functors
02:54:25 <phadej> madnight: Functor is "easy", if you pretend there aren't Contravariant
02:54:48 <phadej> in fact, contravariant package has Compose with (Contravariant f,  Contravariant g) => Functor (Compose f g) instance
02:54:50 <dstolfa> and even if there are, it's trivial to go back and forth
02:55:01 <phadej> http://hackage.haskell.org/package/contravariant-1.5/docs/Data-Functor-Contravariant-Compose.html
02:55:45 <phadej> _maybe_ standalone deriving would be able to do that, as it doesn't have to come up with correct context - you as programmer provide it
02:55:47 <madnight> other question, isn't there a Covariant for every Functor ... free theorems and so?
02:57:31 <phadej> Covariant? Haskell's Functor is covariant, both covariant and contravariant have co-, that's confusing indeed
02:57:31 <Taneb> madnight: there is a functor C^op -> C^op for every functor C -> C, but a contravariant functor is C^op -> C
02:58:05 <dstolfa> Taneb: or in general, the image would be some other category, D
02:58:22 <phadej> madnight: I'd suggest to use capitalised Functor to refer only to Haskell's type-class, and functor to categorial definition
02:58:36 <Taneb> dstolfa: yes but I didn't want to think about how things would flip around ;)
02:58:37 <phadej> some people do use that convention, which is subtle, but helps to disambiguate
02:58:49 <lavalike> cocreature: thanks!
02:58:51 <dstolfa> Taneb: fair enough, what you said isn't wrong ;)
02:59:10 <madnight> alright sorry, so is there a contravariant functor C^op -> C for every covariant Functor (map) in Haskell?
02:59:18 <Taneb> madnight: no
02:59:26 <dstolfa> okay i think we need to pause for a second
02:59:35 <dstolfa> madnight: are you talking about category theory or haskell here
02:59:44 <dstolfa> because that'd clear up some of the confusion
03:00:13 <dstolfa> in category theory, we can define a contravariant functor of a covariant functor F : C -> D by saying it's the covariant functor on the opposite category: G : C^op -> D
03:00:22 <dstolfa> such that g o f = G(f) o G(g)
03:01:11 <madnight> and in Haskell we cannot
03:01:37 <dstolfa> i'm not going to claim that
03:01:46 <dstolfa> we may be able to, i just haven't done enough thinking about it to tell you how
03:02:12 * hackage SDL-gfx 0.6.2.0 - Binding to libSDL_gfx  http://hackage.haskell.org/package/SDL-gfx-0.6.2.0 (fffaaa)
03:03:13 * hackage tomland 0.4.0 - Bidirectional TOML parser  http://hackage.haskell.org/package/tomland-0.4.0 (shersh)
03:04:08 <madnight> basically give me a map and i construct (naturally) a contramap function, that's what i want : )
03:04:37 <madnight> for any fmap function in Haskell
03:04:46 <Taneb> madnight: what type should it have?
03:05:03 <Taneb> ((a -> b) -> [a] -> [b]) -> (b -> a) -> [a] -> [b]?
03:05:18 <dstolfa> :t fmap
03:05:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:05:43 <madnight> % :t contramap
03:05:44 <yahb> madnight: Contravariant f => (a -> b) -> f b -> f a
03:07:27 <dstolfa> madnight: and what is the proposed type?
03:08:23 <madnight> type is Contravariant
03:08:37 <dstolfa> no, i mean, what is the proposed type signature for the function that would map fmap to contramap
03:08:47 <dstolfa> are you imagining what Taneb suggested?
03:09:46 <madnight> no
03:09:55 <dstolfa> then what would it be
03:10:43 <madnight> natural transformation from Functor to Contravariant?
03:12:12 <Taneb> madnight: what do you think this should look like in Haskell's type notation
03:13:00 <Taneb> Everything I can think of that you could mean, doesn't exist
03:13:19 <madnight> (a -> b) -> f b -> f a
03:13:20 <dstolfa> madnight: right, so you'd have eta1 : F -> G and eta2 : G -> F such that F(x) >----> G(x), F(x) >----> F(y), G(y) >----> G(x) and F(y) >----> G(y) commute?
03:13:40 <dstolfa> madnight: that's not a natural transformation, that's a contramap
03:14:05 <dstolfa> i suppose you could specify one if we could specify a dinnatural transformation?
03:14:09 <dstolfa> dinatural*
03:14:48 <madnight> i mean in Haskell we get fmap for free
03:15:01 <madnight> i want contramap for free : )
03:15:52 <hololeap> you might be interested in Profunctors which are Bifunctors which are contravariant in the first argument and covariant in the second one
03:16:02 <dstolfa> right, to get contramap for "free", the only way i can imagine it working is if we had a dinatural transformation between them
03:16:15 <dstolfa> i don't think we have that atm
03:16:18 <dstolfa> in haskell, that is
03:16:33 <Taneb> We don't even really get fmap for free, most of the time
03:16:40 <dstolfa> Taneb: yeah, hence the "free" here
03:17:17 <madnight> Taneb: okay, "free" then
03:17:40 <Taneb> So, you want to be able to say "deriving Contravariant"
03:17:51 <madnight> yup
03:18:15 * dstolfa thinks this would be quite easy with dependent types
03:18:16 <mniip> 1534846462 [13:14:22] <madnight> i mean in Haskell we get fmap for free
03:18:18 <mniip> we do?
03:18:23 <mniip> ah, as in deriving Functor
03:18:31 <madnight> mniip: "free"
03:18:37 <mniip> you can probably achieve it with Generic
03:18:41 <mniip> Generic1?
03:18:58 <mniip> ah, Generic cannot do exponentials
03:19:11 <mniip> template haskell only then I'm afraid
03:19:22 <Taneb> Functor's relatively easy to derive, as we can just keep the parity
03:19:36 <Taneb> Polarity?
03:19:40 <mniip> variance
03:19:44 <Taneb> That one
03:19:54 <Taneb> Contravariant we need to swap the variance an odd number of times
03:20:09 <Taneb> (an even number of times and we get Functor, I don't know if GHC can do this, though?)
03:20:50 <dminuoso> olligobber: Type theory copied the terms from category. You can think of (->) as a bifunctor that is covariant in one argument and contravariant in another argument. In CT this corresponds to the hom functor.
03:21:10 <Taneb> derivng Functor is pretty stupid
03:21:12 <dminuoso> olligobber: Equivalently you could think of a category where you have the subtyping relationship as morphisms between types 
03:21:39 <dminuoso> olligobber: and then have a similar bifunctor (->) that is.. still.. covariant in one argument and contravariant in the other argument
03:22:41 <mniip> dminuoso, a C^op x C -> D functor is colloquially referred to as a profunctor from C to D
03:22:57 <mniip> but sure, it's the same thing as "bifunctor from C^op and C to D"
03:23:03 <mniip> or "functor from C^op x C to D"
03:23:16 <dstolfa> naming is hard okay
03:24:41 <madnight> so (my wish) "deriving Contravariant" would require TH but should be possible?
03:26:58 <dminuoso> mniip: Weirdly I rarely read "the hom profunctor" though.
03:39:12 * hackage versioning 0.3.0.0 - Type-safe data versioning.  http://hackage.haskell.org/package/versioning-0.3.0.0 (lortabac)
03:40:12 * hackage versioning-servant 0.1.0.0 - Servant combinators for the versioning library.  http://hackage.haskell.org/package/versioning-servant-0.1.0.0 (lortabac)
03:59:36 <Ariakenom> What's peoples definition (in a weak sense, common usage counts as well) of "side-effect" around here?
04:00:05 <quchen> Ariakenom: Things where it makes a difference how many times you do them
04:00:13 <quchen> …and in what order
04:00:32 <trcc> Ariakenom: Usually it is when things change that are not obvious. When obvious things changes it does not seem worth discussing it
04:00:46 <trcc> taking the approach of common usage here :) 
04:01:35 <Ariakenom> Ok. How do you use "side effect" wrt IO a?
04:03:19 <Ariakenom> In particular would you (or others in common usage) say "print" has no side effect while "trace" does?
04:09:05 <pavonia> Ariakenom: I'd say both have side effects. Note that trace is actually not a pure function, it's more tricking the compiler into thinking it is
04:10:31 <hpc> i would say print is a pure function (it does IO but has IO in the type)
04:10:34 <hpc> and trace is impure
04:11:04 <sshine> monads have effects, and the IO monad has side effects?
04:11:07 <hpc> and what keeps it from being unsafe is that it hardly does anything at all
04:11:37 <hpc> the IO type expresses actions that can be executed
04:11:46 <hpc> (execution is a totally different operation than evaluation)
04:11:51 <Ariakenom> indeed
04:11:55 <dstolfa> monads just happen to model side-effects nicely
04:11:57 <dstolfa> but a list is a monad too
04:12:14 <Ariakenom> hpc: but you would use side effects for execution
04:12:18 <dstolfa> side-effects are those statements that cause the runtime to act with the environment
04:12:25 <sshine> sorry, let me rephrase (getting terminology straight): a monadic action has effects, and the IO monad's actions have side effects?
04:12:30 <dstolfa> they just happen to wrap into monads nicely
04:12:51 <Ariakenom> pavonia: Allright. In my usage print has effects and trace has side effects. But I'm probably mostly inserting meaning myself
04:12:52 <sshine> when would you call the effect of a monadic action a side effect?
04:13:09 <sshine> or rather, the effect of *executing* a monadic action...
04:13:10 <hpc> Ariakenom: i think "side effects" isn't precisely defined enough to say for sure what it is and isn't used for
04:13:27 <Ariakenom> hpc: Yup. thatsmy reason for asking around :)
04:13:43 <Ariakenom> I'm looking for some Haskell "false friends" 
04:13:49 <dstolfa> hpc: to me, it means that the program will have an effect on its environment
04:13:52 <Ariakenom> But side effect doesnt seem to be one
04:13:54 <dstolfa> it's not just a monad, many things are monads
04:13:59 <hpc> print's behavior is entirely captured by its type
04:14:02 <dstolfa> consider list with flatten and singleton
04:14:02 <hpc> trace's behavior is not
04:14:21 <Ariakenom> and effect isn't used in that sense outside afaik
04:14:29 <hpc> to some extent, a side effect is anything the program does that you aren't thinking of at this very moment
04:15:15 <dstolfa> you could think of effects as transitions in a LTS
04:15:18 <dstolfa> if you really wanted to
04:15:22 <cocreature> one way to reconcile things is to separate evaluation from execution. evaluating `print "Hello World"` doesn’t have any side effects while evaluating `trace "Hello World" ()" does
04:15:55 <hpc> or like
04:16:05 <cocreature> the execution of print "Hello World" definitely does have side effects but that’s a separate concept
04:16:29 <hpc> your entire program starting from main is some kind of directed graph
04:16:48 <hpc> something else entirely outside your program traverses this graph to execute your program
04:17:16 <hpc> at some points, execution requires something to be evaluated first, to produce a value of type IO whatever
04:17:29 <Ariakenom> cocreature: alternatively the execution has effects which are in no way side :)
04:17:40 <hpc> if that evaluation performs IO actions on its own, that's unsafe behavior
04:17:54 <cocreature> sure at that point you are arguing about badly defined terms :)
04:18:19 <cocreature> but that doesn’t really refute my point that print and trace are fundamentally different because only one has effects during evaluation
04:18:20 <Ariakenom> yes
04:18:30 <hpc> thinking of it this way also helps you realize that evaluation never happens on its own either, something outside the expression has to be looking at it in some way
04:18:53 <Ariakenom> cocreature: I was wondering about common usage of the terms
04:21:15 <cocreature> I’d argue that effect and side effect are used in too many contexts and with slightly different meanings that insisting on some specific meaning is not really useful. if it matters, make it clear what you mean by the term instead of arguing about the one true meaning
04:21:45 <hpc> ^
04:22:00 <dstolfa> cocreature: i tend to agree :-)
04:22:41 <dminuoso> cocreature: The really interesting part, is that when you look beneath the seams - then effects *are* tied into evaluation.
04:22:54 <hpc> in ghc at least
04:22:57 <dminuoso> Yeah.
04:23:15 <Ariakenom> yes arguing because you have different definitions is pointless
04:23:16 <cocreature> that’s interesting from an implementation perspective but I don’t think it’s particularly useful as a Haskell programmer
04:23:27 * dstolfa tends to use the word "effects" to talk about transition labels on transitions in a LTS
04:24:18 <Ariakenom> I'm not arguing for a true meaning. I asked because I was wondering if side-effects was a "false friend". A term that seemed similar but was used differently. I think I can conclude no. It's vague and about the same in general computing and #haskell
04:24:22 <dminuoso> cocreature: Well the presence of lazy IO and the availability of primitives like unsafePerformIO/unsafeInterleaveIO does not hide it completely.
04:25:52 <dminuoso> Ariakenom: At any rate: My personal view is that what the innards of the IO type suggests: An effect is just a change of the real world.
04:26:11 <Ariakenom> I myself dropped the side part because I compared it to the medical term, where side indicates not intended.
04:26:20 <dminuoso> In some interesting ways it suggest that every function has effects when applied and evaluated simply for consuming CPU time
04:26:22 <cocreature> fair enough although I’d argue that at least as a beginner ignoring the existence of those things is very benefitial so the evaluation/execution separation is at least very useful for teaching
04:26:35 <dminuoso> cocreature: Oh yeah I agree.
04:27:24 <cocreature> dminuoso: that reminds me, do you have some good resource on the innards of IO? I should brush up my knowledge, it’s been a while since I’ve looked this stuff
04:27:39 <dminuoso> cocreature: Staring at accursedUnutterablePerformIO revealed everything to me. :)
04:27:55 <dminuoso> That and some useful points from mniip.
04:28:35 <cocreature> dminuoso: alright thanks! I’ll see if staring at that helps :)
04:28:40 <Ariakenom> dminuoso: you asked for material on innards of IO yesterday?
04:28:44 <mniip> my explanation was completely point-less
04:28:46 <Ariakenom> r do I misremember
04:29:23 <cocreature> mniip: pointless or pointfree? :)
04:29:57 <Taneb> I should probably look into GHC's guts a bit more than I have
04:29:58 <mniip> pointforgetful
04:30:24 <dminuoso> That sounds like a useful typeclass: class Pointforgetful (f :: * -> *)
04:30:35 <dminuoso> I wonder what its method(s) would be.
04:30:54 <Ariakenom> what about the term "type safe". "type theory" or "memory safety". show of hands pelase
04:32:57 <cocreature> I’m happy with a progress + preservation definition for type safety
04:33:01 <Ariakenom> type safety has roots in both type theory and closely linked to memory safety. Which would you assume it was about? Or would it depend on context/ask.
04:33:16 <dminuoso> cocreature: I see what you did there.
04:33:30 <cocreature> dminuoso: hm?
04:33:33 <dminuoso> Ariakenom: the memory safety is about a specific model a type system is tied to.
04:33:37 <dminuoso> cocreature: You quoting TaPL there. ;)
04:33:55 <cocreature> dminuoso: I don’t think tapl came up with that
04:34:21 <dminuoso> Oh fair enough then
04:34:54 <cocreature> wikipedia claims it’s from a paper by wright and felleisen
04:35:07 <cocreature> but I would expect that the ideas were probably around before that
04:35:15 <dminuoso> cocreature: Ah yes TaPL also names that reference
04:35:35 <dminuoso> The slogan “safety is progress plus preservation” (using a canonical forms lemma) was articulated by Harper; a variant was proposed by Wright and Felleisen (1994).
04:35:45 <dminuoso> So it would be Harper likely
04:35:52 <cocreature> ah nice, didn’t know that
04:41:06 <Ariakenom> So the type theory assumption is different from most programmers would assume afaik. Wiki agrees I think. I actually got confused with a colleague over this one, still don't know what the non-theory version really means.
04:41:36 <dstolfa> Ariakenom: "non-theory"
04:41:45 <dstolfa> Ariakenom: what do you mean by that
04:42:12 <cocreature> a definition where nobody knows what it really means is probably not a definition worth using :)
04:42:43 <antranigv> hey all. anyone can recommend a good book on Functional Programming? ideally with Erlang or Haskell. :)
04:44:17 <cocreature> antranigv: the two Haskell books that I’ve seen recommended the most these days are “Programming in Haskell” by Hutton and “Haskell Programming from First Principles” by Moronuki and Allen
04:44:27 <Ariakenom> dstolfa: not sure. might be wrong. 
04:44:35 <cocreature> I haven’t read either of them personally, so I can’t give a good recommendation as to which one is preferable
04:45:11 <cocreature> the latter seems to start from the very basics of programming which I could imagine gets a bit tedious if you already know some other language
04:45:40 <madnight> antranigv: or for starters http://learnyouahaskell.com (very easily explained)
04:46:40 <madnight> cocreature: what's with Real World Haskell?
04:47:25 <oak> http://haskellbook.com/
04:47:42 <mniip> I wish hpffp was more free
04:48:32 <dstolfa> mniip++
04:48:40 <cocreature> madnight: it’s more of a cookbook on how to solve specific problems and use specific libraries and those books sadly tend to suffer from being outdated
04:49:01 <dstolfa> back when i read WYAH, it was quite good too
04:49:05 <dstolfa> not sure if it was updated since
04:49:16 <cocreature> wyah?
04:49:22 <dstolfa> cocreature: write you a haskell
04:49:37 <mniip> not because I'm a cheapskate, but because it's awkward to recommend it to people only to have them pirate the pdf while I sit in the same channel as the copyright holder
04:49:41 <dstolfa> it's a book that guides you to building a functional programming language in haskell
04:49:43 <cocreature> that project sadly died off before it got to the interesting parts (for me)
04:49:53 <sm> @quote FAQ books
04:49:53 <lambdabot> FAQ says: What are some good books for learning haskell ? Haskell Tutorial And Cookbook (HTAC), Programming In Haskell (PIH), Haskell Programming From First Principles (HPFFP)
04:49:57 <merijn> cocreature: tbh, contrary to popular opinion I *don't* think HPFFP is suited for non-programmers, I think it's better for existing programmers, tbh
04:50:15 <cocreature> merijn: ah interesting, I’ll keep that in mind when it comes to recommendations
04:50:17 <madnight> cocreature: hmm that's the book i used to learn Haskell, the user comments on each paragraph are very valuable
04:50:38 <merijn> cocreature: Yes, it starts slow, but you have to anyway to deprogram existing intuitions but a lot of the first chapters focus on things that are only "obviously useful" to existing programmers, not lay-people
04:50:49 <merijn> cocreature: i.e. lots of finnicking with lists, for example
04:51:10 <merijn> cocreature: Which just kinda has non-programmers go "but why am I doing this?"
04:51:33 <merijn> (mind you, that is sample size 1) :p
05:00:32 <madnight> is Hask a cartesian closed category?
05:00:46 --- mode: glguy set +v gentauro
05:00:50 <gentauro> is there a compiler flag for GHC so instead of creating a binary, it just outputs code as System F (GHC intermediate language?) -> https://youtu.be/lC5UWG5N8oY?t=698
05:01:18 <cocreature> gentauro: -ddump-simpl or -ddump-prep
05:01:40 <cocreature> well it will also create the code in that case but you’ll get the Core as well
05:01:51 <cocreature> not sure if you can stop after the simplifier, -fno-code stops even before that afaik
05:03:10 <gentauro> cocreature: thx. I will give it a try :)
05:04:48 <dmwit> madnight: Is Hask a category?
05:07:03 <madnight> dmwit: you refer to bottom?
05:08:32 <gentauro> cocreature: I thought I would get a nice AST :)
05:08:46 <dmwit> I don't remember the specific objections, but googling gave me http://math.andrej.com/2016/08/06/hask-is-not-a-category/
05:08:55 <dmwit> Which is probably what I was thinking of.
05:09:12 <cocreature> gentauro: even better, you get some nice human readable syntax! (for some definition of human readable)
05:09:27 <dmwit> But the non-snarky point I'm trying to make is: until you carefully define Hask, it probably doesn't make much sense to ask about its properties.
05:09:39 <dstolfa> dmwit: hask is technically not a category, but people handwave when they say Hask
05:10:00 <gentauro> cocreature: meh -> Result size of CorePrep = {terms: 23, types: 11, coercions: 0, joins: 0/0}
05:10:12 <cocreature> gentauro: so?
05:10:20 <cocreature> not sure what you are trying to tell me with this
05:10:31 <gentauro> cocreature: I would rather have a huge Tree with the extended lamda calc as described in the video :)
05:10:39 <cocreature> there are various -dsuppress-* options to hide things you don’t care about
05:10:44 <cocreature> you get the source as well
05:11:12 <madnight> i often read something like: Hask is the category of Haskell types and functions (except for ... bottom .. and the like)
05:11:16 <cocreature> I doubt you really want to see the AST, that would be completely unreadable for any nontrivial program
05:11:32 <madnight> maybe we can refer to it as "Hask"
05:11:38 <dmwit> madnight: I also comment here on a potential resolution, but, like many other armchair CTers, I have not done the work needed to carefully verify that this makes Hask a category: https://stackoverflow.com/q/51331179/791604
05:11:40 <cocreature> you can probably write a core plugin and dump it or see if there is some existing plugin if you really want it
05:12:00 <gentauro> cocreature: I was expecting a bit like "Lambda Calculus" translated to "SKI Combinators" ;)
05:12:39 <dstolfa> dmwit: the only way to prove it is to formally define all the semantics of haskell and prove that it constructs a category :-)
05:12:54 <dstolfa> (well, the only pragmatic way, i think anyway)
05:13:23 <cocreature> gentauro: the AST shown in those slides is literally copied from the GHC source afaict, there is no representation in terms of ski combinators
05:14:09 <madnight> dstolfa: the intuition would be enough for me
05:14:13 <dmwit> dstolfa: That would certainly be one way. And I have not done that work, nor has anybody else, as far as I know.
05:14:15 <merijn> dstolfa: Well, that's easy, we just have to ignore the existence of IO! :)
05:15:32 <dmwit> madnight: Sure; as an intuition, we certainly have conversions between `(x,y) -> z` and `x -> (y -> z)`, namely, `curry` and `uncurry`.
05:16:38 <madnight> well what we can do is to simply define Hask', that is Hask without any elements which wouldn't make it a category : )
05:16:50 <dmwit> But you may already notice an oddity: we have sneakily used the same arrow twice in `x -> (y -> z)`, whereas CT is more careful to distinguish between two different kinds of arrows there.
05:16:58 <madnight> is Hask' cartesian closed?
05:17:01 <dmwit> So being careful really requires quite a bit more work.
05:17:32 <dmwit> madnight: That question is truly unanswerable. Who knows what Hask' is? It might even be a discrete category for all we know.
05:17:48 <dmwit> Sorry. Not unanswerable. But not easier to answer than your first one.
05:18:19 <gentauro> cocreature: but I guess there are in terms of extenden Lambda Calculus right?
05:18:36 <dmwit> (At least for me the obvious way to answer it requires all the same work and then some extra work, too.)
05:19:42 <madnight> hmm
05:20:00 <cocreature> gentauro: I’m not sure what you mean by that. as I already said that representation is literally the one used by GHC. after that it goes to STG which is mostly a canonicalized form of Core without types and then C-- which definitely isn’t any kind of lambda calculus anymore
05:22:24 <dmwit> gentauro: You... should be getting significantly more output than just "Result size of CorePrep = ...". You are, right?
05:22:37 <dmwit> gentauro: The rest of that is your "extended lambda calculus" (where did you get this term?).
05:25:45 <gentauro> dmwit: ofc I'm -> https://lpaste.net/576580642020524032
05:27:03 <gentauro> there is a lot of stuff that doesn't really give sense (expression wise) ..
05:27:18 <dmwit> False. There is a lot of stuff in a language you don't know yet.
05:27:31 <gentauro> dmwit: True that
05:27:52 <gentauro> but that doesn't make my statements less valid
05:28:35 <dmwit> Okay. It may not make sense to you, but there are definitely people to whom it makes sense.
05:28:48 <dmwit> And it can make sense to you, too, in the future, if you're interested.
05:29:21 <cocreature> I’m still not sure what you are hoping to get, do you just want a way to suppress everything except for lines 51,52,55,56?
05:30:13 <cocreature> https://github.com/yav/dump-core will give you slightly prettier output
05:30:35 <dmwit> You need 59,60 too. It's just not obvious because of -dsuppress-uniques.
05:30:56 <cocreature> ah right, didn’t look too closely
05:31:31 <dmwit> I suspect the real problem here is the program being compiled was too simple, so the compiled version is too simple to "look like" lambda calculus.
05:31:40 <dmwit> But I don't really know.
05:32:38 <gentauro> yeah, It might have been me that expected something else.
05:32:53 <gentauro> cocreature: that dump-core is more of what I was looking for :) (thx again)
05:32:59 <gentauro> http://yav.github.io/dump-core/example-output/Galua.OpcodeInterpreter.html
05:33:00 <gentauro> :)
05:33:29 <gentauro> but still no expression tree ..
05:33:48 <dmwit> What are you on about with this "no expression tree" business?
05:33:50 <gentauro> dmwit: the reason I was asking is because I have played around with John Tromps Binary Lambda Calculus
05:34:10 <dmwit> What is an expression tree, and what part of e.g. `(63) $wsetStackSize = ...` from your link doesn't qualify?
05:34:42 <gentauro> dmwit: data Expr = Var ...
05:34:47 <gentauro> you know the usual suspect?
05:34:56 <pgiarrusso> gentauro: what you see *is* an AST (if you’re looking for that), just pretty-printed back into text form
05:34:58 <dmwit> This is a pretty-printed version of that data structure.
05:35:29 <gentauro> oh, my bad
05:35:41 <dmwit> (For that matter, `Lambda (App (Lambda (Var 1)) (Var 0))` would be, too.)
05:36:07 <pgiarrusso> sure, just even less readable :-)
05:36:27 <gentauro> pgiarrusso: but easier "parseable"
05:36:28 <gentauro> ;)
05:36:30 <dmwit> Just trying to figure out what gentauro's actual objection is, and making some guesses about what it might be.
05:36:59 <gentauro> dmwit: Haskell code => System F => Lambda Calc => SKI
05:37:14 <dmwit> No, that is not the trajectory that GHC takes.
05:37:36 <gentauro> dmwit: I know, but that is what I thought I could get ;)
05:37:43 <pgiarrusso> gentauro: do you want a human or a tool to parse it?
05:38:17 <dmwit> Haskell code => System Fco => Cmm => machine code or Haskell code => System Fco => LLVM => machine code are the two possible trajectories AFAIK.
05:38:25 <dmwit> What you are seeing here are System Fco terms.
05:38:42 <merijn> dmwit: You forgot STG in there
05:38:46 <dmwit> Okay.
05:38:56 <pgiarrusso> gentauro: if you’re trying to do X through Y, it helps to say what X is, so people can give appropriate suggestions
05:39:09 <merijn> I think it's Haskell -> Core -> STG -> Cmm and then either machine code or LLVM followed by machine code
05:39:33 <pgiarrusso> where Core = System Fcc, IIUC?
05:39:33 <dmwit> Anyway, there's never any bare lambda calculus nor SKI.
05:40:41 <pgiarrusso> “lambda calculus” is so generic... system fcc *is* an extended lambda calculus, tho it has *lots* of extensions
05:41:20 <pgiarrusso> (I’m also happy to argue it’s not a lambda calculus ;-) )
05:41:48 <Ariakenom> Can ghc still do Cmm->C->machine as a third last step?
05:42:03 <merijn> Ariakenom: Not by default
05:42:23 <merijn> The unregisterised C backend still exists, but is not in release builds. It's only used for bootstrapping GHC on new platforms
05:42:48 <merijn> Ariakenom: Certainly not in a usable state for "real" work
05:44:37 <gentauro> pgiarrusso: I though I did?
05:45:00 <gentauro> I just misunderstood what System F was (based on the slide on the video)
05:45:03 <gentauro> that's all
05:46:35 <gentauro> pgiarrusso: and lambda calculus is no way generic. I'ts only: data Expr = Var String | Lam String Expr | App Expr Expr
05:46:38 <gentauro> that's it
05:47:11 <gentauro> ofc you can extend "pure LC" with types and so, but then it's no longer "pure LC" but "impure LC"
05:48:30 <Ariakenom> merijn: cool thanks
05:49:23 <dminuoso> What documentation would I have to read if I wanted to provide my own IO primitives?
05:50:08 <merijn> dminuoso: Define "primitive"?
05:50:14 <merijn> What sorta things are you thinking off?
05:50:40 <MarcelineVQ> dminuoso: https://ghc.haskell.org/trac/ghc/wiki/Commentary/PrimOps
05:51:00 <MarcelineVQ> Even if you did't mean at that level it's probably a useful read
05:51:16 <merijn> At a higher level you can do most stuff in libraries, tbh
05:51:29 <dminuoso> merijn: You mean by ffi'ing?
05:51:47 <merijn> dminuoso: Maybe, I'm not sure what you mean by "IO primitive" so can't say
05:51:50 <dminuoso> MarcelineVQ: Thanks I think that might be spot on.
05:55:26 <pgiarrusso> gentauro: that’s not the full story, System F is also clearly a lambda calculus. Viceversa, GHC’s internal language doesn’t have lambda expressions as syntax, functions are all lifted to the top-level
05:55:56 <MarcelineVQ> which internal lang?
05:56:38 <quchen> I thought lambda lifting was explicitly left out of STG.
05:57:17 <pgiarrusso> MarcelineVQ: I meant core
05:57:48 <pgiarrusso> quchen: hm I might be mixing up details, you’re right the GHC story is more complicated
05:58:42 <quchen> pgiarrusso: And Core has lambdas.
05:58:48 <quchen> https://github.com/ghc/ghc/blob/master/compiler/coreSyn/CoreSyn.hs#L274
06:01:00 <quchen> (And so does STG, which is pretty much Core.)
06:04:28 <quchen> With whom did I recently talk about tricky Haskell questions that teach you something? I just remembered one looking at the Core type, »Why do we have let when we already have lambdas – what’s the difference between ›(\x -> expr) y‹ and ›let x = y in expr‹?«
06:05:39 <MarcelineVQ> isn't the import part of let actually letrec?
06:06:45 <MarcelineVQ> idk, might be a silly question, never actuall sat down and done my core study
06:07:35 --- mode: glguy set +v librerush
06:12:35 <quchen> MarcelineVQ: Well then on the other hand, why have lambdas when we already have letrec? :-þ
06:13:12 <dmwit> Why have let? Its type is more exciting. Why have lambda? For when we don't know y yet.
06:13:26 <MarcelineVQ> pshh easy, because functional programming is about lambdas, you gotta have 'em :>
06:13:35 <merijn> quchen: Why have recursive bindings when you've got fix?
06:14:05 --- mode: glguy set +v gentauro
06:14:10 <gentauro> % :t fix
06:14:10 <yahb> gentauro: (a -> a) -> a
06:14:47 <dminuoso> :t fmap fix pure
06:14:48 <lambdabot> b -> b
06:15:01 <quchen> > let x = undefined in x x
06:15:03 <lambdabot>  *Exception: Prelude.undefined
06:15:13 <quchen> > (\x -> x x) undefined
06:15:15 <lambdabot>  error:
06:15:15 <lambdabot>      • Occurs check: cannot construct the infinite type: t0 ~ t0 -> t
06:15:15 <lambdabot>      • In the first argument of ‘x’, namely ‘x’
06:15:58 <dmwit> Ooo, ooo, I want to make my answers more parallel.
06:16:13 <dmwit> Why have let? For when we don't know its type yet. Why have lambda? For when we don't know its argument yet.
06:16:54 <Hjulle> What is the scope used in the view function for top level view patterns? I'm trying to modify the functions generated by servant-client, but ghc complains that the view functions I am using are not in scope. :S
06:17:27 <MarcelineVQ> hjozwiak: best to include your code in a paste with questions about your code :D  error too
06:17:56 <Hjulle> > f = (+1); (f -> x) = 1 -- Error: variable 'f' not in scope
06:17:58 <lambdabot>  <hint>:1:3: error:
06:17:58 <lambdabot>      parse error on input ‘=’
06:17:58 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
06:18:54 <Hjulle> > let f = (+1); (f -> x) = 1
06:18:56 <lambdabot>  <no location info>: error:
06:18:56 <lambdabot>      not an expression: ‘let f = (+1); (f -> x) = 1’
06:19:06 * quchen just opened the locally stored logs only to see ertes-w talk to me. Way to ruin my day.
06:19:12 <Hjulle> > let f = (+1); (f -> x) = 1 in x
06:19:14 <lambdabot>  error:
06:19:14 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M616845839118...
06:19:14 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:19:34 <dmwit> > let f = const (); (f -> x) = () in x
06:19:37 <lambdabot>  error:
06:19:37 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M589478827649...
06:19:37 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:20:09 <Hjulle> > let f = (+1) :: Int -> Int; (f -> x) = 1 in x
06:20:11 <lambdabot>  error:
06:20:11 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M557916888118...
06:20:11 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
06:20:16 <dmwit> Oh, lol.
06:20:18 <dmwit> It's because:
06:20:19 <dmwit> :t f
06:20:20 <lambdabot> FromExpr a => a
06:20:34 <dmwit> > let blargle = const (); (blargle -> x) = () in x
06:20:36 <lambdabot>  error:
06:20:36 <lambdabot>      Variable not in scope: blargle :: () -> t1
06:21:02 <Hjulle> There we go. That's the error I wanted.
06:21:47 <dmwit> That is kind of annoying. Can be worked around, though.
06:21:53 <MarcelineVQ> if you define them seperately it works, not sure why
06:22:17 <MarcelineVQ> I'm looking at the scoping rules atm,  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#view-patterns  if anyone else wants to
06:22:24 <dmwit> > let f = const () in let (f -> x) = () in x
06:22:26 <lambdabot>  ()
06:22:29 <dmwit> Hjulle: ^
06:22:46 <Hjulle> I want to define them top level. I guess I could use a separate module, but that is annoying
06:22:52 <dmwit> MarcelineVQ: It doesn't say, I think. I looked while Hjulle was perfecting his lambdabot query. =P
06:23:08 <MarcelineVQ> there's hints
06:23:50 <dmwit> Hjulle: You want a hack?
06:24:04 <dmwit> Hjulle: Use TemplateHaskell and insert a `return []` line between the definition of `f` and `x`.
06:24:22 <dmwit> Hjulle: https://lpaste.net/8225654196305657856
06:24:33 <pgiarrusso> quchen: sorry you're right, I got confused with *more typical FP compilers* which do lambda-lifting
06:27:57 <dmwit> Hjulle: I can't remember the term for it, but GHC does some chunking of definitions into mutually recursive but independent chunks. I suspect that the way it does this for view patterns is not quite right. TemplateHaskell lets you manipulate how the chunks are computed a bit, and in particular definitions before and after a TH splice never get put in the same chunk.
06:28:31 <dmwit> Hjulle: It's probably worth reporting as a bug -- even if it's behaving as intended, the docs could use some updating to say what's intended.
06:29:07 <Hjulle> dmwit: Ok, thanks
06:30:05 <dmwit> Hjulle: When you report the bug, send me a link. =)
06:51:12 * hackage gll 0.4.0.11 - GLL parser with simple combinator interface  http://hackage.haskell.org/package/gll-0.4.0.11 (ltvanbinsbergen)
06:57:09 <madnight> how can i save notes/quotes in lambdabot?
06:57:43 <MarcelineVQ> ​@remember
06:58:15 <madnight> @remember test
06:58:15 <lambdabot> Incorrect arguments to quote
06:58:37 <madnight> @remember test test
06:58:37 <lambdabot> I will never forget.
06:58:47 <Ariakenom> @quote test
06:58:47 <lambdabot> test says: test
06:58:59 <dminuoso> What is the module name to refer to an identifier that is shadowed by other things like simple-reflect?
06:59:05 <dminuoso> @let f = 1
06:59:06 <lambdabot>  Defined.
06:59:10 <dminuoso> How would I refer to that `f` now?
06:59:17 <cocreature> :t L.f
06:59:18 <lambdabot> Num p => p
06:59:24 <dminuoso> cocreature: Ah thanks!
06:59:45 <madnight> @remember composition "Here's a categorical rule of thumb: everytime you have composition, you should look for a category."
06:59:45 <lambdabot> Good to know.
07:01:07 <philippD> Does anyone know how to turn a function of the form `c a => a -> Process ()` into a Closure from distributed-process?
07:02:39 <Ariakenom> @quote
07:02:39 <lambdabot> BrianWKernighan says: /* lasciate ogne speranza, voi ch'intrate. */
07:03:01 <Ariakenom> clearly
07:04:30 <Taneb> "Abandon all hope, ye who enter here", I think
07:06:10 <Ariakenom> makes sense
07:06:25 <Ariakenom> @quote BrianWKernighan
07:06:25 <lambdabot> BrianWKernighan says: /* lasciate ogne speranza, voi ch'intrate. */
07:08:30 <ab9rf> Taneb: that fits with the words i do recognize ('speranza' and "intrate')
07:08:56 <Taneb> ab9rf: lasciate is you leave, I think the imperative plural is the same?
07:09:05 <Taneb> And voi is just plural you
07:09:22 <Taneb> But the language we should be talking about here is Haskell, not Italian
07:09:29 <ab9rf> hehe
07:09:47 <Taneb> (I think ogne is like "each")
07:10:11 <Ariakenom> @quote
07:10:11 <lambdabot> PhilipGreenspun says: Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.
07:13:30 <madnight> is this considered to be idiomatic Haske
07:13:41 <madnight> ll: http://hackage.haskell.org/package/tuple-0.3.0.2/docs/src/Data-Tuple-Select.html#Sel1
07:14:32 <ab9rf> heee
07:14:40 <ab9rf> how else would you implement that?
07:14:44 <cocreature> madnight: no but it’s still kinda useful and a lot of people use it in the lens variation
07:15:42 <ab9rf> the only thing you could do to make it "prettier" is explicitly use template haskell :)
07:16:11 <ab9rf> tuples are a bit of a fart
07:18:21 <madnight> hmm generally if i see something like this (regardless of the language) the first thing that comes to my mind is that it feels wrong / there is a missing abstraction
07:19:45 <dmwit> you might like hlist or generics
07:19:59 <ab9rf> madnight: you'd be right
07:20:06 <ab9rf> madnight: tuples are not generalized
07:22:18 <madnight> dmwit: why did the author of tuple didn't use hlist or generics, what's the drawback
07:23:36 <dolio> Why did the author do it at all?
07:31:20 <madnight> dolio: maybe we will never know
07:31:37 <madnight> although we could ask him
07:32:44 <dolio> He is a bit of a madman.
07:33:48 <madnight> at least he looks so https://github.com/augustss
07:33:50 <dolio> Embedded BASIC DSLs and whatnot.
07:34:24 <phadej> tuple-0.1.0.0 is uploaded on 2009
07:34:29 <phadej> there was no Generics back then
07:35:01 <phadej> ghc-7.2 is from 2011 which was first release with generics
07:35:37 <phadej> and for the record, Lennart wrote the first haskell compiler :)
07:35:48 <madnight> phadej: and TH?
07:36:04 <dolio> TH existed, I think. But it was certainly less used.
07:36:07 <phadej> https://en.wikipedia.org/wiki/Lennart_Augustsson
07:36:15 <jr_dev> anyone know if there's a meaningful difference between `elem' a (x:xs) = a == x || elem' a xs` and `elem' a (x:xs) |
07:36:38 <jr_dev> and `elem' a (x:xs) | a == x = True | otherwise = elem' a xs`
07:37:02 <jr_dev> does || (logical or) execute the righthand statement if the lefthand is True?
07:37:11 <cocreature> no
07:37:29 <jr_dev> so there's no difference in O(n) between those statements then?
07:37:39 <Taneb> They should be exactly the same
07:37:50 <jr_dev> thanks
07:37:53 <madnight> "Augustsson has written three winning entries in the International Obfuscated C Code Contest" well that answers my questions altogether : )
07:37:53 <phadej> template haskell is maintanment burden, writing explicit code stands out for 10 years
07:38:12 <cocreature> jr_dev: fwiw, O(n) is not the right metric to use here since it will be O(n) even if || did execute the righthand statement in each case
07:39:48 <madnight> phadej: he used a mixed approach is code is auto-generated but pre-compile time (copy and paste)
07:40:03 <madnight> *his
07:40:15 <jr_dev> cocreature: distinction appreciated :)
07:41:03 <phadej> madnight: sometimes that make sense, in fact, I auto-generated tuple instances in aeson e.g.
07:41:04 <jr_dev> cocreature: what's the metric i'm looking for to describe the advantage here?
07:41:36 <phadej> so aeson can be TH-free, and we are sure the code is good (as Generics for big things might not optimise)
07:43:04 <madnight> so let's write Haskell programms, that generate Haskell programms in order to avoid TH?
07:43:55 <phadej> madnight: there's a difference between writing "core libs" and "apps"
07:44:10 <cocreature> jr_dev: you could limit the inputs to lists where the first element is the one you are looking for, then you can apply big-o notation since the worst case will be O(1) for 1 case and O(n) for the other
07:44:11 <phadej> I hope that we won't need to touch aeson instances in a very long time
07:44:48 <phadej> for example, so the trouble of generating them once, probably saved the compilation time all aeson users would spent executing TH
07:45:42 <phadej> i.e. core libs aren't the best source of "idomatic haskell"
07:45:52 <phadej> thy are source of "core lib idiomatic haskell", which is different
07:45:59 <phadej> very different constraints
07:47:32 <phadej> and I personally avoid TH, because it's always an issue when new GHC is released
07:47:52 <madnight> well "apps" simply use TH and "core libs" use some sort of pre-compiler static code generation, i would then argue both variants are not very idiomatic
07:47:58 <jr_dev> cocreature: :+1:
07:49:08 <phadej> madnight: TH for boilerplate generation is IMHO idiomatic. YOu just cannot afford that in all environments
07:49:53 <Welkin> phadej: I agree, but many people think less keyboard strokes = efficiency
07:50:11 <madnight> then one might ask, why is boilerplate necessary in the first place?
07:50:27 <Welkin> because the code needs to come from somewhere
07:50:41 <Welkin> you write it, or the compiler does
07:50:54 <kryft> phadej: What exactly is the issue with TH when a new GHC is released?
07:51:43 <dolio> I don't think the 'tuple' package is necessary.
07:52:19 <madnight> Welkin: no that's not correct, with a correct abstraction i can avoid thousands of lines of boilerplate code
07:52:44 <dolio> Except for quick one-off stuff, people generally don't use big tuples for anything significant where you'd need APIs like that for them.
07:52:47 <madnight> and TH is not really an abstract, it's a boilerplate generator ...
07:52:58 <madnight> *ion
07:53:03 <dolio> Becuase they're better off as a more well defined structure in that case.
07:53:28 <dolio> Certainly not 32-tuples.
07:53:28 <phadej> kryft: from a library writer POV (who writes TH generators), the TH definitions change. see e.g. http://hdiff.luite.com/cgit/template-haskell/diff?id=2.12.0.0&id2=2.11.1.0
07:54:29 <glguy> Dealing with these changes is why you end up depending on something like http://hackage.haskell.org/package/th-abstraction
07:54:45 <phadej> glguy: yeah, that lib is a savior
07:54:48 <madnight> dolio: so we don't need TH because that's only for rare use cases like tuple 32?
07:54:50 <phadej> when it's enough for you
07:54:55 <glguy> as the template-haskell package makes little effort to cross version compat
07:55:08 <glguy> phadej: We can always add more to it :)
07:56:15 <phadej> glguy: true.
07:56:26 <phadej> and surprisingly it didn't needed changes for GHC-8.6
07:57:06 <dolio> No, TH is useful for a lot of stuff. But generating instances for tuples up to size 32 is not a good example.
07:57:40 <dolio> Because it is an example of doing something that isn't very useful with it.
07:59:33 <madnight> dolio: well for me the "issue" is not limited to tuple32 but to, why do we need boilerplate in the first place, why not introduction a correct abstraction?
07:59:44 <dolio> What boilerplate?
08:00:32 <madnight> dolio: eg. lens auto-generation is done with TH
08:00:33 <Welkin> I am thinking the same question dolio
08:00:46 <Welkin> you can write your own lenses by hand
08:00:50 <Welkin> you never *need* TH
08:01:49 <madnight> sure but now i have a very big data structure and i want a simple abstraction that automatically adds me lenses
08:01:50 <Welkin> lenses are one attempt to fix records in Haskell (which are broken in several ways)
08:02:44 <Ariakenom> lenses do do more than records
08:03:07 <Welkin> madnight: the only answer is TH
08:03:11 <dolio> The only solution that comes to mind is the compiler generating lenses for fields instead of the functions it generates now.
08:03:24 <ab9rf> yes, but then you'd be writing code in a language that is not Haskell :)
08:03:26 <Welkin> TH is the only way to do metaprogramming
08:03:36 <dolio> But that is essentially no differen than just writing TH to do it and not building it into the compiler.
08:04:15 <madnight> well how can i tell the compiler that he can automatically derive Functor?
08:04:20 <dolio> There are two or so other ways to get the compiler to generate lenses, too, probably.
08:04:31 <dolio> GHC already can derive Functor.
08:04:45 <madnight> dolio: couldn't i use the same approach for lenses?
08:05:10 <dolio> The approach of modifying GHC to have a feature that generates lenses?
08:05:14 <madnight> derive Lens
08:06:10 <madnight> dolio: no not modifying GHC, but making it possible to write code that do so, without the need for changing GHC source
08:07:09 <Welkin> the code has to come from somewhere: either you write it, or you run TH that someone else wrote, or someone adds that code to the compiler
08:07:53 <madnight> Welkin: yes but where do i write the code is an important factor
08:07:56 <dolio> There are GHC plugins, too.
08:08:24 <dolio> But I don't see why those are significantly better than template Haskell or something similar for this.
08:08:33 <Welkin> I don't see the problem with adding a single line to have TH geenrate lens code for you
08:08:38 <Welkin> or even writing it by hand
08:09:17 <madnight> Welkin: e.g. what if we would "lift" the code for derive Functor that is now hard wired into ghc to the core lib level?
08:09:59 <madnight> thus it would be possible to write other core libs that do similar things, without changing the compiler
08:11:00 <Welkin> adding random things to the compiler is how you end up with c++
08:11:25 <madnight> Welking: i talk about removing things from the compiler
08:11:37 <mnoonan> this isn't even the same kind of "deriving". Lens isn't a typeclass.
08:16:53 <madnight> to me TH is just a boiler plate code generator required because of missing abstractions, okay except for DSL's like SQL and the like
08:17:18 <dolio> What missing abstractions?
08:17:50 <dolio> TH is like a macro language. That arguably is a very powerful language feature for solving exactly this sort of stuff.
08:18:49 <madnight> dolio: i could use Python to generate Haskell code
08:19:05 <Welkin> madnight: you can generate python code with haskell using strings too
08:19:17 <Welkin> that is not really metaprogramming
08:19:48 <Welkin> TH is not required, and it is not a boilerplate generator
08:19:59 <Welkin> TH is mostly used for creating DSLs
08:20:09 <dolio> It's not the greatest macro language, but comparing it to generating code with a python script is pretty ridiculous.
08:20:14 <mnoonan> TH isn't like C macros, it's more like Lisp macros or Python's ast module.
08:20:30 <dolio> Unelss you're going to do extensive work on your python system for generating Haskell.
08:20:48 <madnight> for DSLs i see the point
08:20:57 <Welkin> if you don;t like TH, then don't use it
08:21:11 <Welkin> write your code out explictly
08:21:34 <Welkin> using TH for boilerplate is overkill in my opinion
08:22:09 <madnight> but for boiler plate generation i would like to have a more powerful native abstraction instead
08:24:02 <Welkin> why do you have "boilerplate" in the first place?
08:24:08 <Welkin> typeclass instances?
08:24:27 <madnight> yup
08:24:41 <glittershark> What are people here doing to mitigate GHC compilation time on large projects
08:24:45 <glittershark> is there anything, really?
08:25:09 <glittershark> I have a 30kloc (not that large!) haskell project and it takes like... 15 minutes to compile
08:25:53 <madnight> https://rybczak.net/2016/03/26/how-to-reduce-compilation-times-of-haskell-projects/
08:26:53 <madnight> and try the Gold Linker, i use it and it's linking super fast : )
08:26:55 <fsestini> what’s the standard way for libraries to expose functions operating on monads that can throw different types of errors, and that avoids excessive lifting in client code?
08:27:09 <fsestini> i see from hackage that ether is deprecated
08:27:21 <glittershark> fsestini: MonadError is the replacement for MonadExcept
08:28:04 <fsestini> glittershark: yep. but you cannot have multiple instances of MonadError
08:28:24 <glittershark> yes, that would be... difficult
08:31:09 <fsestini> i think it can be done in principle, with some type annotations. it’s just that MonadError has a fundep to improve inference
08:57:42 <dminuoso>     ‘fromAttr’ is not a (visible) method of class ‘FromLdapAttr’
08:57:52 <dminuoso> Is GHC being unsure whether it's just not visible or not existent?
09:01:26 <geekosaur> it only knows names that you imported; it's possible that you incompletely imported, or the defining module incompletely exported, it
09:01:37 <geekosaur> so it cites both possibilities
09:02:11 <geekosaur> if it came from a pre-compiled package, it can't go looking for the package source to see if it is in fact defined somewhere but not exported
09:02:54 <dminuoso> geekosaur: Was wondering whether maybe the interface files had information about the class.
09:03:09 <geekosaur> not if it wasn't exported and wasn't inlinable
09:23:13 * hackage bulletproofs 0.2.0 -   http://hackage.haskell.org/package/bulletproofs-0.2.0 (sdiehl)
09:39:43 * hackage shake-elm 0.2.0.0 - Elm builds in shake  http://hackage.haskell.org/package/shake-elm-0.2.0.0 (vmchale)
09:48:50 <AWizzArd> For a `data Vector a (n :: Nat) where … Nil  :: Vector a 0 … (:-) :: a -> Vector a n -> Vector a (n+1)` I would like to write an Eq instance. Easy for the cases that involve Nil.
09:48:55 <AWizzArd> But my case `x :- xs == y :- ys = (x == y) && (xs == ys)` doesn’t work. I want to know how (i.e. what is the syntax here?) I can add the constraint that the length of both vectors is the same? That is:  (n1 ~ n2) => …
09:49:30 <cocreature> :t (==)
09:49:31 <lambdabot> Eq a => a -> a -> Bool
09:49:49 <cocreature> AWizzArd: in your case a = Vector a n and that’s the same for both arguments
09:49:59 <cocreature> so they already have to have the same length
09:50:32 <philippD> Is there a way to get the following code to work without adding `AllImplement Show (T a)` or `Show b` constraint explicitly to `f` in the class declaration? https://gist.github.com/chisui/f4862c9e2c2722656a043a0235c68985
09:50:43 <AWizzArd> Yet GHC complains: Could not deduce: n2 ~ n1
09:50:53 <cocreature> AWizzArd: show us the code and the full error
09:50:55 <philippD> am I even using Constraintkinds and Typelists correctly?
09:51:42 <AWizzArd> cocreature: I basically gave the full code. Above is the data declaration, using TypeLits.  And for Eq I also pasted the code. But I can paste it somewhere, one sec.
09:52:16 <cocreature> you probably need to write two separate Eq instances, one for "Eq (Vector a 0)" and one for "Vector a n => Eq (Vector a (1 + n))"
09:52:32 <AWizzArd> Oh okay, I will try that.
09:56:28 <cocreature> AWizzArd: ah actually this is just a case of GHC being kind of dumb. if you use ghc-typelits-natnormalise things work properly for your instance
09:56:47 <AWizzArd> Okay, will try that quickly.
09:57:13 * hackage shake-elm 0.2.0.1 - Elm builds in shake  http://hackage.haskell.org/package/shake-elm-0.2.0.1 (vmchale)
10:00:29 --- mode: glguy set +v freemywenis
10:00:46 <freemywenis> is there a format that is to haskell what json -> javascript, edn -> clojure, etc., or are homoiconic format relations like those only possible in dynalangs?
10:02:52 <geekosaur> not standardized as such, but people often use the Show and Read clsses that way. (but they're not really designed for it; for example, no attempt to deal with cyclic structures0
10:04:56 <ggVGc> haha, I use Show and Read for quick and dirty serialization more than I'd like to admit
10:05:08 <ggVGc> I've even used it for configuration...
10:05:09 <ggVGc> :(
10:05:31 <geekosaur> could be worse. xmobar's config *simulates* doing so ... poorly
10:06:11 <geekosaur> leading to joys like incomprehensible 'syntax errors' if you reference a plugin that isn't present in your xmobar
10:21:33 <nshepperd> philippD: your problem is that even though f has the Find b (T a) constraint, which says that b is one of [Int, String], it doesn't say *which*
10:22:34 <nshepperd> philippD: so even though ghc has Show Int and Show String at this point, it doesn't have a way to choose the right instance
10:27:31 <nshepperd> constraint solving is a kind of constructive logic, it needs a procedure to find the instance
10:32:39 <philippD> nshepperd: I thought I can use `AllImplement Show (T ())` to ensure that I can get access to the Show instance I need
10:35:27 <nshepperd> the only thing that does is provide instances (Show Int, Show String) in the context
10:35:47 <nshepperd> (which are already there anyways since those instances are global)
10:37:35 <nshepperd> you can also think about this operationally. at runtime, Find b (T a) compiles away to nothing. it's just a constraint which is either satisfied or fails, which is checked at the call site
10:38:13 <nshepperd> so f is being passed a value of b, which is either String or Int, and expected to be able to print it, not knowing which it is
10:42:05 <nshepperd> this suggests one way to fix it. instead of a type family, you could make 'Find a xs' an actual typeclass, which provides a value of a GADT
10:43:18 <nshepperd> the GADT would say not only that b is in the list (T a), but also would say which element it is, when pattern matched
10:45:56 <nshepperd> data ListElement (a :: *) (xs :: [*]) where { IsFirstElement :: ListElement a (a:xs); IsLaterElement :: ListElement a xs -> ListElement a (b:xs) }
10:47:13 <nshepperd> pattern matching that would be a bit of an annoyance though
10:51:23 <Ariakenom> Is there no Read a => String -> Maybe a?
10:52:14 <laudecay> Ariakenom: look up parsers in haskell :3
10:52:30 <Ariakenom> no
10:52:44 <Ariakenom> thank you
10:52:53 --- mode: glguy set +v nbloomf
10:53:08 <MarcelineVQ> there's various readMay's around
10:53:13 <nbloomf> there is readMaybe in http://hackage.haskell.org/package/base-4.11.1.0/docs/Text-Read.html
10:55:18 <philippD> nshepperd: I think I will have to rethink my architecture. There are other problems with the actual code too.
10:55:32 <philippD> Thank you for shedding some light on the Constraint stuff
11:03:26 <nbloomf> also Ariakenom you can search hackage by signature with Hayoo, e.g. https://hayoo.fh-wedel.de/?query=%28Read+a%29+%3D%3E+String+-%3E+Maybe+a
11:12:11 <suzu> ggVGc you have a great nick
11:16:17 <warbo> managed to get my JSON parsing program to run in constant space :)
11:16:36 <suzu> nice. how?
11:16:45 <warbo> although it does its own parsing, and uses the type 'IO ()' all over the place :P
11:17:36 <warbo> I made a simple function that uses 'getChar' and a stack to accumulate a bytestring from stdin
11:17:47 <warbo> counting brackets to figure out when to stop
11:18:09 <ab9rf> heh
11:18:29 <warbo> then passes that chunk of bytestring to aeson to decode, followed by my processing, which writes its results straight to stdout before starting the loop again
11:18:33 <warbo> it's horrible :P
11:24:39 <dminuoso> geekosaur: Mmm, well in this case it's in the same package. 
11:25:15 <dminuoso> Im feeling it might be an improved diagnostic *if* GHC had some knowledge about the class, so that it could tell for sure that the method was simply not visible, or whether it just doesn't exist.
11:25:30 <dminuoso> But then again folks like merijn would jump at the chance and tell me "Go write it" :P
11:37:52 <geekosaur> dminuoso, it's still using the .hi file. people already complain about compile times; stuffing the whole thing in the .hi file is no better than just switching to whole-program compilation, which would make it even slower
11:38:45 <geekosaur> or for that matter reading / re-parsing / re-typechecking the file it has available, when it's in the same package
11:38:52 <geekosaur> you at some point have ot choose which you care more about
11:39:15 <geekosaur> you can get really great diagnostics by things that slow compilation down by 15-30x
11:39:59 <geekosaur> or by holding everything it's ever seen in memory, thus making ti take that much more space instead of more time
11:40:38 <ggVGc> suzu: haha, thanks
11:48:23 <dminuoso> geekosaur: Fair enough
11:58:30 <dsal> I'm  having a moment of dumb.  How can I make a cartesian product of n copies of permutations of l efficiently?
11:59:43 <dsal> I did something like      (Set.toList . Set.fromList) . map (take n) . permutations . (concat . replicate n)
12:02:43 <zachk> dsal, that doesn't look totally correct, and I don't think it computes a cartesian product at all
12:03:02 <dsal> Yeah, I did a bit of an XY there.
12:03:27 <zachk> > (,) <$> [1,2,3] <*> ['a','b','c'] -- dsal , that is what I use for cartesian product these days 
12:03:29 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
12:03:44 <dsal> I have a list l, and I want all combinations of k elements from it.  Then I want k copies of that.
12:04:07 <dsal> The thing that makes this slightly tricky is that I don't know how many copies I want ahead of time.
12:04:24 <zachk> :t subsets
12:04:25 <lambdabot> error:
12:04:25 <lambdabot>     • Variable not in scope: subsets
12:04:26 <lambdabot>     • Perhaps you meant ‘subst’ (imported from Data.Number.Symbolic)
12:04:31 <zachk> :t subset
12:04:33 <lambdabot> error:
12:04:33 <lambdabot>     • Variable not in scope: subset
12:04:33 <lambdabot>     • Perhaps you meant ‘subst’ (imported from Data.Number.Symbolic)
12:05:04 <zachk> > filterM [True,False] [1,2,3] 
12:05:06 <lambdabot>  error:
12:05:06 <lambdabot>      • Couldn't match expected type ‘a -> m Bool’
12:05:06 <lambdabot>                    with actual type ‘[Bool]’
12:05:15 <zachk> > filterM (const [True,False]) [1,2,3] 
12:05:17 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:05:32 <zachk> there is a builtin to do that now, but I forgot what it was 
12:05:43 <philippD> I am a little confused by the constraints package. Suppose I have some `class A (m :: * -> * -> *)` how can I use `Forall` to essentially say `class (forall a. Monad (m a)) => A m`?
12:06:00 <bbaren> :t subsequences
12:06:01 <lambdabot> [a] -> [[a]]
12:06:04 <bbaren> zachk: ^
12:06:07 <dsal> I remember that...
12:06:32 <zachk> > filter (\list->length list == 2) . subsequences $ [1,2,3,4,5] 
12:06:34 <lambdabot>  [[1,2],[1,3],[2,3],[1,4],[2,4],[3,4],[1,5],[2,5],[3,5],[4,5]]
12:08:13 <dsal> > concatMap permutations . filter (\list->length list == 2) . subsequences $ [1,2,3,4,5] 
12:08:15 <lambdabot>  [[1,2],[2,1],[1,3],[3,1],[2,3],[3,2],[1,4],[4,1],[2,4],[4,2],[3,4],[4,3],[1,...
12:08:19 <zachk> dsal, I would code the choose K of N as a recursive function that uses the list monad, perhaps, 
12:08:27 <zachk> that is not giving you all the choices though
12:08:46 <zachk> filter out the element from the list after your choose it and recurse again and accumulate the answer
12:09:21 <dmwit> > replicateM 2 "abc" -- dsal ?
12:09:23 <lambdabot>  ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
12:09:31 <dmwit> I'm not sure I understand what you're after yet, though.
12:09:46 <dsal> Hmm...  I wonder if I tried that.
12:13:39 <dmwit> > let choose_ k n ~(x:xs) | k == 0 = [[]] | k > n = [] | otherwise = ((x:) <$> choose_ (k-1) (n-1) xs) <|> choose_ k (n-1) xs; choose k xs = choose_ k (length xs) xs in choose 2 "abc" -- also a possibility
12:13:41 <lambdabot>  ["ab","ac","bc"]
12:16:14 <dsal> I have a list of things and I want all combinations of those things taken k at a time.  I want to take that and have a list of k lists of those (which I'll then flatten)  e.g., "abcd" -> ["aaa", "aab", ...]
12:16:53 <dmwit> uh
12:16:54 <lthms> looks like someone you would want to do with the list monad?
12:17:00 <dmwit> You're going to have to fill out that ...
12:17:12 <dmwit> There's lots of inequal continuations that seem sensible to me.
12:17:28 <dmwit> > replicateM 3 "abcd" -- is the simplest, for sure.
12:17:30 <lambdabot>  ["aaa","aab","aac","aad","aba","abb","abc","abd","aca","acb","acc","acd","ad...
12:17:37 <dmwit> But there are many others.
12:19:08 <dsal> Actually, I think replicateM might actually be doing what I want.  I think I overthought that.
12:23:42 <int-e> > let cr 0 _ = [[]]; cr n xs = do {xs@(x:_) <- tails xs; (x:) <$> cr (n-1) xs} in cr 3 "abc"
12:23:48 <lambdabot>  ["aaa","aab","aac","abb","abc","acc","bbb","bbc","bcc","ccc"]
12:24:39 <dminuoso> Assume I have some `data Acc = Acc { restriction :: Restriction, ... }` that is loaded straight off a directory service. I have the need to issue a `Replace` operation on the restriction. 
12:25:05 <dminuoso> My issue is, I dont know how to design this the right way, so that the code building the "replace" operation does not need to have the directory services field name wired in.
12:26:38 <dmwit> Do you also hold this concern about the parser, that it should not need to know what field name to look under in the directory service? Presumably you can solve the problem in essentially the same way you did for that...
12:27:11 <dmwit> Beyond that, I suspect the question is as yet too vague to answer meaningfully.
12:28:25 <dminuoso> dmwit: Well that parser might as well use the same source of truth - but beyond TH I dont know how to do this in a type safe way: https://gist.github.com/dminuoso/77e56a02fc02417c2481d036f0b781d1
12:30:45 <dmwit> That code looks super great to me.
12:31:24 <dmwit> I get that you're sad that you can't tie the two "uid"s together. That is a shame for sure, but probably not worth the effort anyway.
12:31:27 <philippD> Why doesn't this work, but when I delete the second occurrence of `f ()` it works https://gist.github.com/chisui/ae1c20e7219356919fd7072293b451ee
12:31:54 <dmwit> If you're really into it, you might take a look at the paper "Invertible Syntax" or something like that and see if you can steal ideas from it.
12:32:18 <dmwit> (There's a package on Hackage for it, but it probably won't be directly usable for your `FromLdap`/`ToLdap` classes.)
12:33:24 <dmwit> philippD: Presumably you would need to unwrap the `Forall (Monad1 m)` constraint somehow to make it available to call `(>>)`.
12:34:01 <dmwit> philippD: When you delete the second `f ()` it works because the desugaring of `do { f () }` is `f ()`, which doesn't mention any `Monad` operations at all, only `f` which is available from the `A` constraint.
12:34:56 <dminuoso> dmwit: Reload my gist, the `Actions.hs` is my headache.
12:35:18 <geekosaur> remmeber tyhat "do" does not by itself induce any Monad constraints, it only enables syntax. the second `f ()` induces the Monad constraint by desugaring to a use of (>>)
12:36:24 <philippD> dmwit: interesting, You don't have to have a Monad instance if you have only one expression in a do block.
12:36:42 <geekosaur> that's what I just said
12:36:44 <dmwit> philippD: Correct.
12:36:50 <geekosaur> "do" does nothing except enable syntax
12:37:01 <dmwit> dminuoso: I have a cunning plan.
12:37:03 <geekosaur> it adds no constraints, it does not change types
12:37:03 <geekosaur> > do 1
12:37:05 <lambdabot>  1
12:37:36 <philippD> geekosaur: sorry me feed was obscured by all the people quiting
12:37:46 <dmwit> dminuoso: data Account f = Accunt { accountName :: f AccountName, firstName :: f String, lastName :: f String, realm :: f Realm }
12:38:04 <geekosaur> the second f () activates the new syntax introduced by do, and thereby pulls in (>>)
12:38:07 <dmwit> dminuoso: fieldNames :: Account (Const String)
12:39:03 <philippD> So this means I can't use the Forall in this case to get a Monad instance?
12:39:24 <dmwit> I expect you can, but will need to explicitly unpack it at the appropriate types.
12:39:34 <dmwit> But I haven't played with Forall much, so I don't know exactly how that would look.
12:40:13 <dmwit> I suppose you'd use `inst :: Forall p :- p a`.
12:40:46 <dmwit> And `(\\) :: a => (b => r) -> (a :- b) -> r`.
12:41:45 <dmwit> % :set -XConstsraintKinds -XPolyKinds
12:41:45 <yahb> dmwit: Some flags have not been recognized: -XConstsraintKinds
12:41:51 <dmwit> % :set -XConstraintKinds -XPolyKinds
12:41:51 <yahb> dmwit: 
12:42:09 <EvanR> whoa
12:42:21 <dmwit> % f :: Proxy ((a,b) :: Constraint) -> Proxy a; f Proxy = Proxy
12:42:22 <yahb> dmwit: 
12:42:56 <dmwit> % :t f (Proxy :: Proxy (Ord a, Bounded a, Enum a))
12:42:56 <yahb> dmwit: ; <interactive>:1:4: error:; * Couldn't match type `(Ord a0, Bounded a0, Enum a0)' with `(a, b0)'; Expected type: Proxy (a, b0); Actual type: Proxy (Ord a0, Bounded a0, Enum a0); * In the first argument of `f', namely `(Proxy :: Proxy (Ord a, Bounded a, Enum a))'; In the expression: f (Proxy :: Proxy (Ord a, Bounded a, Enum a))
12:43:06 <dmwit> oh?
12:43:14 <dmwit> % :t f (Proxy :: Proxy (Ord a, (Bounded a, Enum a)))
12:43:14 <yahb> dmwit: Proxy (Ord a)
12:43:18 <dmwit> fascinating
12:43:30 <dmwit> % :t f (Proxy :: Proxy (Eq a, Ord a))
12:43:31 <yahb> dmwit: Proxy (Eq a)
12:43:47 <dmwit> % :t Proxy :: Proxy (Eq a, Ord a)
12:43:47 <yahb> dmwit: Proxy (Eq a, Ord a)
12:45:01 <dmwit> Wild. I never new that we could nest constraint lists like that, or that subsumed constraints could be retained in some situations.
12:45:10 <philippD> where does the `a` come from?
12:45:11 <dmwit> s/new/knew/
12:45:23 <dmwit> From a sneakily implicitly inserted forall.
12:45:39 <dmwit> % :t Proxy :: forall a. Proxy (Eq a, Ord a) -- like this
12:45:39 <yahb> dmwit: Proxy (Eq a, Ord a)
12:46:09 <philippD> wow
12:46:59 <shapr> what was that?
12:47:30 <dmwit> bird? plane? lambda-man?
12:48:33 <shapr> dmwit: it's too far beyond my understand
12:49:53 <philippD> I still don't get how to unpack Forall though
12:50:02 --- mode: glguy set +v dminuoso
12:50:05 <dminuoso> dmwit: I really love that idea, I mean it presents some interesting challenges because now Ill have `Identity` all around
12:50:30 <merijn> dminuoso: Wrapping fields in a record?
12:50:56 <merijn> dminuoso: You can fix that with TypeFamilies and Generic abuse
12:51:45 <dminuoso> merijn: Mmm?
12:51:50 <merijn> dminuoso: http://reasonablypolymorphic.com/blog/higher-kinded-data/
12:52:23 --- mode: glguy set +v gentauro
12:52:33 <gentauro> I'm glad I begin to understand how Hakyll works. Elms is becoming less and less atractive to code in :( -> https://github.com/elm/compiler/blob/master/upgrade-docs/0.19.md#removed-user-defined-operators
12:53:05 --- mode: glguy set -v gentauro
12:53:11 <dminuoso> merijn: Oh that looks quite simple to address. 
12:53:13 <dminuoso> Neat :)
12:53:51 <EvanR> user defined operators, horrible, terrible
12:54:35 <EvanR> elm should do another update, function names must all be in standard english, and refer to something that makes sense
12:54:41 --- mode: glguy set +v sent1nel_
12:54:47 <EvanR> arglebargle for example should be syntactically disallowed
12:55:35 <dminuoso> EvanR: And it should do stemming and require lexemes to exist in say thesaurus.
12:55:41 <dminuoso> For good measure you know.
12:56:25 <sent1nel_> elm vs purescript; general thoughts? is one clearly more haskell-like than the other?
12:56:42 <sent1nel_> i've only just begun to learn haskell. i don't yet have front-end preferences.
12:56:59 <EvanR> the rationale document linked on that page is patently wrong
12:57:01 <EvanR> :(
12:57:12 <philippD> EvanR: wouldn't that only cause java enterprise style names?
12:57:15 <gentauro> sent1nel_: there is none :(
12:57:21 <EvanR> "i have never seen # % @ or $ used to make a good operator"
12:57:41 <philippD> :t (<$>)
12:57:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:57:43 <gentauro> % for modulus?
12:57:55 <gentauro> :t $
12:57:56 <lambdabot> error:
12:57:56 <lambdabot>     parse error on input ‘$’
12:57:56 <lambdabot>     Perhaps you intended to use TemplateHaskell
12:57:59 <EvanR> # is used to indicate apartness for instance
12:58:05 <gentauro> :t ($)
12:58:07 <lambdabot> (a -> b) -> a -> b
12:59:07 <gentauro> this is how you end writting code when you can't define bitwise operators -> https://lpaste.net/8564193293921943552
12:59:10 <gentauro> I mean ...
12:59:23 <gentauro> how tf is that understandable?
13:00:20 <gentauro> not lets see the same logic implemented in Haskell -> https://lpaste.net/5161621477912477696
13:00:23 <gentauro> :|
13:00:26 <EvanR> on the other hand, if no one published anything until they were 100% sure of stuff, we may still be living in caves
13:00:39 <EvanR> publish or perish
13:01:25 <gentauro> I had implemented the elm-sha
13:01:58 <gentauro> but I just got tired of having to re-write it cos he keeps making changes (to please JavaScript people? The can all go ...)
13:02:15 <gentauro> so I told him to delete all my stuff, I can't be botherede anymore
13:03:29 <EvanR> obviously the real answer to programming language design disagreements is to go off and make your own which fixes everything
13:04:15 <EvanR> the only words you can use in my language are from the 1000 essential english list
13:04:31 <veverak> EvanR: https://xkcd.com/927/
13:05:15 <gentauro> when I studied comp.sci, one of my felow students he was really into programming languages.
13:05:29 <dmwit> philippD: `g :: forall m a. A m => m a (); g = (\\) @_ @(Monad1 m a) (f () >> f ()) inst`
13:05:33 <gentauro> I think he is one of the people I know who can tell you the good thing about a language and 5 minutes after destroy it
13:05:36 <dmwit> philippD: Needs ScopedTypeVariables and TypeApplications
13:05:59 <gentauro> he has made a few attemps on making programming languages and always keeps putting it to the grave
13:06:14 <EvanR> haskell makes it so easy why not
13:06:17 <gentauro> I mean, I'm more of an algo guy, I just want something I can't state "stuff" in a clear and concise manner
13:06:34 <gentauro> I can't = I can
13:06:58 <jr_dev> just starting my haskell journey. wondering about style for newlines
13:07:20 <EvanR> thats the rub, different stuff has adifferent clear and concise language for it
13:07:34 <EvanR> hence the move toward giving the programmer more ability to make new languages
13:07:39 <EvanR> not less
13:07:42 <gentauro> jr_dev: stylish-haskell is your bestest friend EVER !!!
13:07:53 <jr_dev> `nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+b))`
13:07:59 <jr_dev> Wondering where most people would linebreak on that line
13:08:12 <jr_dev> gentauro: oh nice, i'll look into it
13:08:13 <gentauro> https://github.com/jaspervdj/stylish-haskell
13:08:14 <EvanR> that is 1 line
13:08:16 <dmwit> jr_dev: No break.
13:08:32 <gentauro> btw, this jaspervdj he makes some cool stuff :D
13:08:37 <jr_dev> isn't it over 80 chars?
13:08:42 <dmwit> jr_dev: But I'd also define `translate :: Vector -> Point -> Point` and then write `nudge (Rectangle p1 p2) v = Rectangle (translate v p1) (translate v p2)`.
13:08:43 <gentauro> (hakyll, stylish and websockets)
13:08:49 <EvanR> > length "nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+b))"
13:08:50 <philippD> dimwit: Thanks, I was missing the TypeApplications
13:08:51 <MarcelineVQ> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md is pretty reasonable style guide
13:08:52 <lambdabot>  105
13:09:04 <jr_dev> gentauro: thanks for the recc!
13:09:19 <dmwit> > length "nudge (Rectangle p1 p2) v = Rectangle (translate v p1) (translate v p2)"
13:09:22 <lambdabot>  71
13:09:25 <dmwit> excellent
13:09:40 <gentauro> Tabs are illegal. -> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md#indentation
13:09:43 <gentauro> I agree
13:09:58 <dmwit> Tabs are great. Mix them with spaces. -> http://dmwit.com/tabs
13:10:00 <gentauro> I saw a few days ago a funny tweet were somebody was using fibonacci for indentation
13:10:12 <gentauro> that was pretty clever to avoid "long scopes"
13:10:37 <gentauro> I mean, it starts a joke, but many people (my self included) are begining to think that's the way to do it !!!
13:11:08 <EvanR> usually i use 1 tab, to tab over the one big where clause. by tabs i mean spaces
13:11:13 <jr_dev> if you for some reason had to write that line as is, would you newline at the open "("?
13:11:21 <gentauro> https://i.imgur.com/KhfJjVj.jpg
13:11:27 <dmwit> jr_dev: Probably before the `=`.
13:11:45 <jr_dev> dmwit: thanks
13:11:54 <dmwit> jr_dev: Then, if necessary, each argument to `Rectangle` could go on its own (indented) line.
13:13:10 <gentauro> jr_dev: I sometimes tend to "waste" to much time placing stuff just above each other -> https://gitlab.com/spisemisu/SpiseMisu.IntroCourseHaskell/blob/master/SpiseMisu.IntroCourseHaskell.hs
13:13:26 <gentauro> I even do the list "thingby" 
13:13:43 <gentauro> % foo [    ] = 0
13:13:57 <gentauro> % foo (x:xs) = 1 + foo xs
13:14:04 <EvanR> o_O
13:14:12 <gentauro> so the brackets and parenthesis match on the next lines
13:14:19 <gentauro> and I do the same with "wildcards"
13:14:20 <EvanR> what is this, abstract art
13:14:24 <int-e> gentauro: eww
13:14:33 <gentauro> I just like to code to be readable and "easy to the eye"
13:14:39 <EvanR> your empty list looks like a blank to fill out
13:14:51 <gentauro> I mean, when I don't see code like that I tend to throw up a bit in my mouse :'( 
13:14:56 <int-e> (I mentally treat [] as a single token, the spaces hurt.)
13:15:09 <jr_dev> gentauro: the examples here are great
13:15:21 <gentauro> jr_dev: I did a intro course
13:15:27 <dmwit> int-e: Today I wrote `foo :: (      ) => a -> b`. Where is your god now?
13:15:29 <gentauro> you can see the material on that link
13:15:41 <jr_dev> gentauro: working my way thru learnyouahaskell rn
13:15:46 <gentauro> dmwit: learning from the best
13:15:57 <int-e> dmwit: well you're certainly reinforcing my atheist beliefs :P
13:15:58 <gentauro> jr_dev: that's a really good source to beginners
13:16:14 <gentauro> let's see if I can find some more strange stuff :0
13:16:17 * hackage Fin 0.2.4.0 - Finite totally-ordered sets  http://hackage.haskell.org/package/Fin-0.2.4.0 (MatthewFarkasDyck)
13:16:23 <jr_dev> gentauro: it's been pretty good so far
13:16:39 <jr_dev> making a big career transition and have some downtime for the next month, so haskell is the current project
13:16:56 <gentauro> search for "000000000000000001" -> http://blog.stermon.com/articles/2018/08/10/haskell-safe-sha1-only-depending-on-prelude.html
13:17:04 <gentauro> I mean, it just have to give sense when I re-read it
13:17:06 <jr_dev> simultaneous project is coding on a netbook w/out a gui, so i'm all console rn
13:17:06 <gentauro> :S
13:17:07 <EvanR> instead of writing [] as [   ] to get things to line up, you should ammend haskell to allow = to be written   -    -
13:17:59 <gentauro> | 80 > t    = ... and | otherwise = acc I tend to do this instead | 80  >  t  =
13:18:10 <gentauro> so the equal signs are just above each other ...
13:18:30 <EvanR> also what if there are 4 cases, one with two [], two with one [], and one with none. how do you expand stuff
13:18:34 <gentauro> if you look at my chunksOf of
13:18:46 <gentauro> I use [] cos in the next line I use "bs"
13:19:07 <emilypi> sup 
13:19:13 <selfsymmetric-pa> https://github.com/lspitzner/brittany
13:19:59 <gentauro> EvanR: foo [   ] = ...; foo [ x ]; foo [h:t] = ... (you mean like this?)
13:20:06 <EvanR> no
13:21:22 <EvanR> nevermind dont answer
13:23:37 <gentauro> EvanR: what?
13:24:06 <EvanR> another dollar wasted on concrete syntax concerns
13:25:29 <gentauro> EvanR: that's why I like elm-formatter cos it really doesn't care of what you like
13:25:42 <gentauro> it just "enforces" the communities best practices
13:26:19 <gentauro> sometimes it looks horrible, buy hey, it's how they decided elm code should look like and I can live with that
13:26:19 <EvanR> "best practice"
13:26:19 <gentauro> but if they leave it up to me, it will for the most differ from others
13:26:38 <gentauro> EvanR: in other words what Evan wants :)
13:26:38 <EvanR> that attitude is a paradox
13:26:56 <gentauro> or the guy who wrote the elm-formatter tool
13:27:42 <gentauro> since I'm implementing safe array only depending on Prelude (and no nasty pointer stuff)
13:28:03 <gentauro> to make them somehow "fast" I need to be able to get an element based on an index
13:28:11 <gentauro> and furthermore update that element.
13:28:30 <gentauro> My question is (I'm implementing Inmutable Vectors Log32)
13:28:54 <gentauro> if I ask for the 33 element for a FixedVector32
13:29:14 <gentauro> it should a) Give Nothing (wrapping result in Maybe) or thrown an error
13:29:27 <gentauro> b) throw an error
13:29:34 <gentauro> I don't seem to like none of these
13:29:39 <EvanR> or c) be ill-typed
13:30:09 <gentauro> and I have come up with a c) ensure that index is .&. 31 (idx `mod` 32)
13:30:22 <EvanR> o_O
13:30:33 <gentauro> that way I know for sure that it will always retrieve a valid element (it will have to specified in the docs ofc)
13:30:45 <glittershark> are there any utilities out there for running type-checking or type-inference code on Template Haskell?
13:30:46 <EvanR> in an erroneous situation you ignore it and give whats almost a random answer
13:30:55 <EvanR> even PHP is not that bad
13:31:15 <glittershark> I'd specifically like to take a set of GADTs and enumerate the set of sets of constructors of those GADTs which are possible (eg, will typecheck)
13:31:15 <EvanR> (you don't get random answers)
13:31:38 <glittershark> so like, applying the type variables and solving equality constraints
13:32:54 <glittershark> essentially I'm reaching for GHC's exhaustiveness checker
13:33:49 <gentauro> EvanR: well it's not random, it's deterministic
13:33:50 <EvanR> gentauro: compare and contrast the decision to replace division by zero error with a non-error 0 answer (or 7, or whatever number)
13:34:40 <gentauro> it's a bit like saying 48 hours from now
13:34:52 <EvanR> call your dev team and tell them that division by zero no longer crashes. they respond by saying dang.. better not accidentally lead to div by zero, or we wil probably never know in production
13:34:55 <gentauro> and you will have to look into your watch to figure out when that happens
13:35:49 <EvanR> until some end user is smart enough to tell that somethings wrong
13:36:06 <gentauro> "give me the 57 element of a FixedVector32"
13:36:22 <gentauro> 25 it is
13:36:25 <gentauro> I can't see that's bad
13:36:56 <EvanR> in your case, always modulating will impose a performance penalty when the user never indexes out of that zone. and if they wanted to modulate, they could just do it themselves
13:37:12 <EvanR> baking in the modulo is doing too much to me
13:37:28 <gentauro> 57 .&. 31 should be pretty fast in any language
13:38:08 <EvanR> "people won't notice bugs in their code" is still a valid concern
13:38:43 <EvanR> the more things that don't crash, the harder it is to avoid bugs that pass the type checker
13:40:38 <gentauro> at the moment I moved the FixedVector32 from it's own module (Internal.hs) to ArrayLog32 (bottom as a Helper stuff) cos I don't want to expose IDX cos of the error thing
13:41:13 <gentauro> when I call it, I let math handle that stuff but if you imported the internal lib, you would explode ...
13:41:55 <EvanR> submitted for your approval, if the type system could check that your index is in bounds, then the implementation could implement your array without bounds checks
13:41:57 <gentauro> I really dislike the thing that Internal.hs modules hierarchy doesn't limit exposure
13:42:07 <EvanR> then you get safety and speed
13:42:43 <gentauro> EvanR: yes, that's the b) throw an error (index out of bounds)
13:42:57 <EvanR> ... no
13:43:08 <EvanR> b would be impossible
13:43:30 <EvanR> Nothing and throwing would be impossible and so unnecessary in the API
13:43:51 <EvanR> also segfaulting would be impossible
13:43:56 <gentauro> eh, idx > 32 -> throw error, pretty possible (that's how most Arrays are implemented)
13:44:14 <EvanR> idx > 32 would be impossible
13:44:22 <EvanR> also > 31
13:44:36 <gentauro> yeah
13:44:40 <gentauro> size > 32
13:44:41 <EvanR> it would be a type error
13:44:44 <gentauro> idx > 31
13:44:54 <EvanR> idx > size-1 would be impossible
13:45:30 <EvanR> check out the Vect type in dependent types
13:46:15 <abueide> is there a way to execute a binary file from haskell on android/desktop
13:47:00 <EvanR> gentauro: example, this is the index operation in idris
13:47:14 <EvanR> index : Fin len -> Vect len elem -> elem
13:47:25 <EvanR> no Maybe and it won't crash
13:48:25 <gentauro> % newtype I00 a = I00 a
13:48:35 <gentauro> % newtype I01 a = I01 a
13:48:45 <gentauro> % data FixedVector2 a = FV (I00 a) (I01 a)
13:49:15 <gentauro> I guess this achieves it without the extra performance overhead (newtypes get erased compile time right?)
13:49:45 <gentauro> and it's pretty typesafe
13:49:53 <EvanR> depending on how data gets compiled, yeah
13:50:31 <EvanR> but like i was saying in principle you dont need performance overhead forthe type safe length indexed array
13:50:42 <EvanR> and its more flexible than FixedN
13:51:23 <gentauro> EvanR: but you need dependent types
14:03:43 <ggVGc> don't we all
14:03:48 * ggVGc depends on types
14:04:08 <ggVGc> does this make me a dependent type?
14:04:54 <ggVGc> does GHC treat data declarations with only one constructor as newtype?
14:05:13 <MarcelineVQ> no
14:05:19 <ggVGc> I kind of wonder why we even need the newtype keyword when data with one constructor is semantically the same
14:05:25 <ggVGc> maybe I'm wrong
14:05:25 <MarcelineVQ> they're not
14:05:32 <ggVGc> I feel they should be
14:05:36 <ggVGc> why not?
14:08:03 <MarcelineVQ> newtype once erased is exactly the thing it holds, data has an extra constructor layer. a data of a bottom value won't crash the program until you scrutinize what the constructor holds, newtype will crash right away when examined
14:08:47 <MarcelineVQ> You should google it though because I'm probably way off, the difference is the behavior when considering bottoms though
14:09:14 <ggVGc> I know there's a difference. I guess what I'm questioning is if we need this difference
14:09:18 <ggVGc> is it useful to us
14:14:48 * hackage leancheck 0.7.2 - Enumerative property-based testing  http://hackage.haskell.org/package/leancheck-0.7.2 (rudymatela)
14:16:34 <geekosaur> it is, becuase it lets you tell the typechecker to treat it differently than it otherwise would
14:17:07 <geekosaur> think of it as a highly constrained, safer unsafeCoerce, usable to hide or alter typeclass relationships
14:17:23 <geekosaur> (and safer yet with role support)
14:18:48 <MarcelineVQ> I don't think what I said makes any sense
14:19:45 <c_wraith> ggVGc, it's definitely necessary to have both behaviors. newtype is an optimization for when that's the behavior you want. you could emulate its behavior with data, but then you'd have the performance cost of the wrappers.
14:21:54 <c_wraith> also, you'd have the cognitive cost of making sure you get ~ annotations on every pattern match.
14:28:54 <dminuoso> @let newtype N1 = N1 Int
14:28:55 <lambdabot>  Defined.
14:28:59 <dminuoso> @undef
14:28:59 <lambdabot> Undefined.
14:29:02 <dminuoso> @let newtype N1 = N1 !Int
14:29:03 <lambdabot>  .L.hs:158:14: error:
14:29:03 <lambdabot>      • A newtype constructor cannot have a strictness annotation,
14:29:03 <lambdabot>          but ‘N1’ does
14:29:10 <dminuoso> @let newtype N1 = N1 Int
14:29:11 <lambdabot>  Defined.
14:29:15 <dminuoso> @let data D1 = D1 Int
14:29:16 <lambdabot>  Defined.
14:29:27 <dminuoso> > case undefined of (N _) -> ()
14:29:28 <lambdabot>  error: Not in scope: data constructor ‘N’
14:29:35 <dminuoso> > case undefined of (N1 _) -> ()
14:29:36 <lambdabot>  ()
14:29:38 <dminuoso> > case undefined of (D1 _) -> ()
14:29:39 <lambdabot>  *Exception: Prelude.undefined
14:29:52 <madnight> > import Prelude
14:29:54 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
14:29:59 * ski . o O ( redundant brackets detected )
14:30:14 <dminuoso> Oh hey ski :)
14:30:19 <ski> madnight : already imported in lambdabot
14:30:27 <ski> hello dminuoso
14:30:55 <dminuoso> MarcelineVQ: ^- this in a nutshell is the difference. if apat is irrefutable, then `N1 apat` is irrefutable as well.
14:31:46 <MarcelineVQ> :o
14:34:05 <c_wraith> as far as I can tell, you can emulate newtype N = N (type) with data D = D !(type) and a ~ on every match against D.
14:34:38 <c_wraith> awkward to get right, and also the performance overhead..
14:35:11 <dminuoso> c_wraith: well you dont need it on _every_ match, just the ones where the inner pattern is irrefutable
14:35:44 <dminuoso> e.g. for `D1 "foo"` it would be incorrect to turn it into ~(D1 "foo")
14:36:07 <c_wraith> that only makes it more complicated to get right.
14:37:49 <c_wraith> I definitely recommend the version that makes it automatic. :)
14:37:57 <dminuoso> c_wraith: Yeah. I think it boils down to just "newtype" gets erased at compile time, data does not. The difference in behavior wrt to pattern matching is just logical conclusion.
14:38:21 <dminuoso> That is, if you think about what `newtype` does, then it should make sense that `N1 _` be irrefutable.
14:38:41 <c_wraith> lots of people only see half of it, though.
14:39:24 <hexagoxel> c_wraith: no, it is not about the lazy match being sometimes not necessary, it is actively wrong, as demonstrated.
14:39:37 <madnight> can i use newtype like type somehow?
14:40:19 <c_wraith> hexagoxel, I'm not arguing with that. I agreed. it's even harder to get right than just "do this everywhere"
14:40:55 <c_wraith> hexagoxel, lots of people seem to think data with one strict field is the same as newtype, and miss the rest. that's my point.
14:40:57 <dminuoso> madnight: You can put `type` aside most of the time, its not a particularly useful tool in many scenarios.
14:42:25 <madnight> dminuoso: lets say i import a type from a lib, can i newtype it, add derivings and use it with the imported lib functions?
14:42:38 <dminuoso> madnight: Absolutely yes.
14:43:13 <dminuoso> madnight: newtype does require you to unwrap/wrap or use coerce, but you get used to both.
14:43:52 <hexagoxel> c_wraith: ah, i see. sorry :)
14:44:02 <madnight> dminuoso: example (blog post) somewhere?
14:44:24 <dminuoso> madnight: I personally recommend just *trying* it
14:45:32 <madnight> dminuoso: error: Qualified name in binding position
14:47:05 <geekosaur> you're going to have to show what you tried, but that sounds like you got something rather wrong
14:47:21 <geekosaur> (that said, occasionally it's just botched indentation)
14:48:08 <c_wraith> hexagoxel, no worries! :)
14:48:26 <madnight> geekosaur: newtype FileDelta a = T.FileDelta a
14:49:01 <dminuoso> madnight: The error message is quite clear..
14:49:10 <dminuoso> madnight: At any rate, drop the "T." bit
14:49:29 <madnight> dminuoso: but why?
14:49:37 <dminuoso> madnight: what do you expect it to do?
14:49:39 <geekosaur> remember that that name is not the thing you are wrapping, it is the constructor that is wrapping the real value
14:49:43 <geekosaur> as such it is never qualified
14:49:51 <geekosaur> because you are *defining* it there
14:50:04 <dminuoso> madnight: newtype is somewhat different in how you use it.
14:50:09 <geekosaur> and don;t forget the difference between type and data constructors
14:50:20 <dminuoso> madnight: newtype creates a *data* constructor, and you tell it what it wraps.
14:50:27 <dminuoso> newtype Token = Token Text
14:50:52 <dminuoso> Creates a: a type constructor called "Token" and b: a data constructor called "Token" that has the type Text -> Token
14:51:33 <dminuoso> Perhaps less confusing for beginners you might think of it as: newtype Token = MkToken Text
14:52:02 <dminuoso> This "wraps" the Text type.
14:53:09 <dminuoso> So if you wanted to wrap some `T.FileDelta` you'd have to do: newtype MyDelta a = MyDelta T.FileDelta a
14:54:38 <madnight> dminuoso: The constructor of a newtype must have exactly one field but ‘MyDelta’ has two
14:54:51 <geekosaur> missed parens
14:54:57 <dminuoso> Oops forgot some parens there, should be: newtype MyDelta a = MyDelta (T.FileDelta a)
14:55:16 <geekosaur> if what you were trying to do was get something that didn;t need a wrapper, you can't.
14:55:19 <madnight> dminuoso: Expected kind ‘k0 -> *’, but ‘FileDelta’ has kind ‘*’
14:55:31 <geekosaur> a type symonym can. but there's no difference between that and an unqualified import there
14:55:58 <dminuoso> madnight: I just assumed that T.FileDelta was a type constructor based on your earlier attempt.
14:56:03 <geekosaur> and you can't do different things with the type. haskell uses the constructor to determine types, you can't have it infer which one to use that way
14:56:26 <dminuoso> madnight: So if a nullary type constructor then it would be just: newtype MyDelta = MyDelta T.FileDelta
14:56:30 <geekosaur> and you are going to have to show more detauil as to what you are trying to accomplish; this is looking like random thrashing around to little point
14:56:56 <madnight> dminuoso: compiles.
14:57:43 <madnight> dminuoso: still i don't know what todo with MyDelta now
14:58:20 <dminuoso> madnight: whatever you want. MyDelta is a brand new type.
14:58:30 <madnight> dminuoso: Couldn't match type ‘FileDelta’ with ‘MyDelta’
14:58:42 <dminuoso> madnight: That's the point of newtype and why it's frequently a better choice than type. :)
14:58:57 <dminuoso> madnight: It's an entirely new type.
14:59:35 <madnight> dminuoso: so i can't use it with existing functions from the imported lib that expect FileDelta?
15:00:29 <dminuoso> madnight: You can a) use pattern matching to recover the inner value with the original type, you can b) use coerce to make it "just fit" or c) write a simple unwrap function.
15:02:43 <madnight> dminuoso: guess i take convert (MyDelta a) = a then
15:05:08 <dminuoso> madnight: A common idiom is to write the newtype as: newtype MyDelta = MyDelta { reDelta :: T.FileDelta }  -- that way you get the "unwrap" function for free.
15:10:30 <madnight> dminuoso: hmm my lenses do not work for the newtype thing
15:13:39 <madnight> dminuoso: guess i need something like this Control.Lens.Wrapped now?
15:15:44 <madnight> by the way what do #haskell think about Anonymous Records? https://www.athiemann.net/2017/07/02/superrecord.html
15:22:10 <koz_> If anyone here uses (Neo)vim to write Haskell - I wanna set up hindent as an external formatter in a project-local .nvimrc, but I dunno how to do that, since hindent is build locally and has to be run via 'stack exec'. Could someone help me understand what I need to put in my .nvimrc to make this work?
15:31:43 <madnight> koz_: https://github.com/alx741/vim-hindent
15:31:52 <madnight> koz_: g:hindent_command = "stack exec -- hindent"
15:33:01 <koz_> madnight: Oh, nice! That makes it much easier, thank you.
15:37:31 <dminuoso> % :set -XDataKinds
15:37:32 <yahb> dminuoso: 
15:38:02 <dminuoso> % :set -XTypeApplications
15:38:02 <yahb> dminuoso: 
15:38:07 <koz_> madnight: Any chance you know how to work Neomake as well? I'm having a bit of trouble adding more warnings to hdevtools executed by it.
15:38:15 <dminuoso> % Proxy @('[Int])
15:38:15 <yahb> dminuoso: Proxy
15:38:18 <dminuoso> Huh.
15:39:58 <dminuoso> Ah. I was missing polykinds nevermind. :)
15:39:59 <madnight> koz_: no sorry i use ale instead of neomake for linting
15:40:17 <koz_> madnight: That's fine.
15:40:36 <koz_> I'm just a bit confused how the hell I can modify it, because of its weird stack shim.
15:41:59 <koz_> (I can link you its default config file if that'll help, because I'm lost af right now)
15:43:00 <madnight> koz_: i switched entirely from stack to nix, because of the many problems i have had with stack in various scenarios
15:43:21 <koz_> madnight: Fair enough.
15:58:47 * hackage configuration-tools 0.4.0 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.4.0 (larsk)
16:05:14 <dminuoso> foldMap Alt
16:05:21 <dminuoso> Things are starting to get neat!
16:07:21 <madnight> dminuoso: you talk to yourself?
16:07:22 <DrOrange> What's foldMap?
16:08:15 <dminuoso> DrOrange: You might consider foldMap the true nature of Foldable
16:08:25 <Zemyla> Oh, I figured out a way to turn a Set into a Monad that's different from "just wrap it in Codensity".
16:09:46 <Zemyla> First, I start with the Coyoneda transform of Set.
16:09:48 <DrOrange> dminuoso: I am a beginner, so I have no idea what those are. I only know a handful of functions. Sorry :(
16:10:21 <dminuoso> DrOrange: Do you know what Monoid is?
16:10:26 <madnight> % :info foldMap
16:10:26 <yahb> madnight: class Foldable (t :: * -> *) where; ...; foldMap :: Monoid m => (a -> m) -> t a -> m; ...; -- Defined in `Data.Foldable'
16:11:12 <Zemyla> This lets me make it a Functor and a Foldable.
16:11:26 <Zemyla> For Applicative and Alternative, I use these two functions:
16:11:54 <Zemyla> :t S.cartesianProduct
16:11:55 <lambdabot> error:
16:11:55 <lambdabot>     Not in scope: ‘S.cartesianProduct’
16:11:55 <lambdabot>     No module named ‘S’ is imported.
16:11:56 <DrOrange> dminuoso: I think I've read about it, but no, I don't remeber what it is
16:12:09 <Zemyla> :t Data.Set.cartesianProduct
16:12:10 <lambdabot> error:
16:12:10 <lambdabot>     Not in scope: ‘Data.Set.cartesianProduct’
16:12:10 <lambdabot>     No module named ‘Data.Set’ is imported.
16:12:15 <dminuoso> DrOrange: Monoid captures the general notion of being able to smash two things together in a meaningful way.
16:12:30 <Zemyla> @let import qualified Data.Set
16:12:31 <lambdabot>  Defined.
16:12:34 <Zemyla> :t Data.Set.cartesianProduct
16:12:35 <lambdabot> error:
16:12:35 <lambdabot>     Not in scope: ‘Data.Set.cartesianProduct’
16:12:35 <lambdabot>     No module named ‘Data.Set’ is imported.
16:12:54 <hpc> wait what
16:13:03 <Zemyla> Ugh. But anyways, the type of cartesianProduct is Set a -> Set b -> Set (a, b), and the type of disjointUnion is Set a -> Set b -> Set (Either a b).
16:13:33 <Zemyla> These maintain the invariant that the resulting Sets are sorted if the incoming Sets are, even without an Ord dictionary.
16:13:42 <dminuoso> DrOrange: say adding two numbers, multiplying two numbers, concatenating lists, taking the smaller of two numbers
16:14:19 <dminuoso> DrOrange: And Foldable is about the same thing really, except not just two elements - but you do it along some structure.
16:17:16 <DrOrange> So, adding two variables/literals together would be considered a monoid?
16:17:34 <dminuoso> DrOrange: Not quite! A Monoid has 2 extra requirements.
16:18:19 <dminuoso> DrOrange: It requires that the operation has some "null" element. Like "adding 0". "Multiplying by 1". "concatenating with an empty list". "taking the the lesser number with one fixed to infinity"
16:18:50 <dminuoso> And the operation must be associative, which is just to say: (a <> (b <> c)) = ((a <> b) <> c)
16:18:53 <dminuoso> And that's it.
16:19:49 <DrOrange> dminuoso: Those are the exact laws you have to prove to ensure that a structure is a monoid, like say, the group of all natural numbers and the additive operation
16:19:59 <dminuoso> DrOrange: =)
16:20:32 <DrOrange> It always amazes me how close Haskell gets to real math, and how disconnected the other languages are
16:21:05 <hpc> give it like, 5 years
16:21:16 <hpc> and you'll be amazed at how far haskell is from the math behind it :P
16:22:01 <hpc> but yeah, Monoid is one of those really important type classes to know
16:22:01 <DrOrange> Is there any other language like Haskell out there? I know it isn't the only functional one, but what about other declarative languages? I know I could easily google this, but I love how people here explain stuff :)
16:22:05 <hpc> you'll see it everywhere
16:22:07 <hpc> in every language
16:22:46 <DrOrange> I didn't see it in C++ nor in Python, so I don't know what to tell you
16:22:59 <hpc> my experience with rust has been qualitatively similar
16:23:31 <DrOrange> Never took up Rust, I have too many languages to learn right now
16:23:32 <dminuoso> DrOrange: For "similar" you have OCaml, maybe Idris in a way
16:23:34 <hpc> i haven't gotten deep in the community but they definitely try hard to keep it good
16:23:38 <DrOrange> But it looks terribly tempting
16:23:52 <koz_> :t flip
16:23:52 <dminuoso> DrOrange: Also consider Prolog, it may be refreshing
16:23:53 <lambdabot> (a -> b -> c) -> b -> a -> c
16:24:08 <koz_> :t swap
16:24:09 <lambdabot> (a, b) -> (b, a)
16:24:26 <hpc> idris is an experience worth trying, even if you never write a program more than 20 lines long
16:24:45 <DrOrange> hpc: This is what I've been told about Haskell
16:24:53 <DrOrange> So here I am
16:25:03 <hpc> dependent types feel like the next 20 years of new programming language features
16:25:13 <hpc> (truly new ones, not like java getting lambdas)
16:25:32 <hpc> haskell feels like the good timeline in star trek
16:25:36 <dminuoso> DrOrange: Haskell has such a rich type system and lawful interfaces, its quite enjoable.
16:25:40 <hpc> with clean-shaven spock
16:26:03 <DrOrange> hpc: =))) Brilliant description
16:26:32 <dminuoso> DrOrange: How well are you versed in math?
16:26:56 <DrOrange> dminuoso: So far I have found it less than enjoyable, but I like the ideas behind it
16:27:04 <hpc> DrOrange: i know it's on the backburner for you, but definitely don't let rust drop off it
16:27:08 <dminuoso> DrOrange: What dont you like about it?
16:27:31 <hpc> i think it'll be the future language that C/C++ programs get written in
16:27:38 <hpc> like, the next postfix or the next grep will be written in it
16:28:04 <dminuoso> 01:24              hpc | dependent types feel like the next 20 years of new programming language features
16:28:15 <DrOrange> dminuoso: I consider myself a slightly above mediocre student. I am studying engineering, so I don't know what to say more than that
16:28:16 <dminuoso> Good. We need new research so that golang can actively ignore that advancements happen fruther.
16:28:28 <hpc> harsh
16:28:31 <hpc> but fair
16:29:07 <hpc> DrOrange: i kind of agree, it's really hard for me to think "mathematically"
16:30:09 <dminuoso> DrOrange: Well you still get to enjoy some of the basic properties. Monoid/Category laws are very prevalent in a lot of places which makes reasoning about program transformations really easy.
16:30:17 <hpc> i can understand it all eventually, but it has to be anchored in things like computation, or a type system
16:30:23 <dminuoso> The past 2 hours Ive been doing nothing but pleasing the type system losing kind of track what exactly Im doing.
16:30:39 <dminuoso> It's like Im playing a game with the type checker. If it type checks I win and I get a functioning program for free.
16:31:01 <DrOrange> dminuoso: Definitely I don't like how I have to think of different ways to solve problems that would otherwise take me 20 seconds in c++. It seems like my mind is not built for this language in a way, and it is really frustrating
16:31:33 <dminuoso> DrOrange: That's very common - it's related to the fact that Haskell takes a very different direction - so it takes a lot of unlearning and getting used to.
16:31:36 <hpc> DrOrange: in a way it's not
16:31:46 <hpc> DrOrange: you have to kind of break out of your old way of thinking
16:32:02 <dminuoso> DrOrange: For me I can solve problems much much faster in Haskell nowadays. But it took me a few months of learning and practice. :)
16:32:14 <hpc> it's like learning programming from scratch all over again
16:32:27 <dminuoso> Yup. And then its not surprising that you may not be very productive in 2 months.
16:32:28 <DrOrange> Also, the compiler is very strict, and that adds to the frustration. I always like to think that I am battling it in order to make my code better, but still, unnerving
16:32:40 <dminuoso> Especially if you then compare your programming speed with a language you are well versed in
16:33:13 <DrOrange> hpc: I feel like the learning curve in Haskell, whether you programmed before or not, is much stepper than any other language I've tried
16:33:19 <dminuoso> DrOrange: Its definitely not.
16:33:33 <hpc> eventually you'll reach a point where you can learn just as quickly in both ways of thinking
16:33:33 <dminuoso> DrOrange: we regularly get people who learn Haskell as their first language with such ease..
16:33:46 <hpc> and eventually you'll then notice they aren't really that different in the first place
16:34:08 <DrOrange> dminuoso: How I envy them
16:34:12 <hpc> when people say haskell makes you better at any other programming language, this is what they mean
16:34:25 <dminuoso> DrOrange: Me too. I had to spend the better part of a year to get a grip on the language.
16:34:55 <DrOrange> Also, I find myself little time to practice Haskell, between work and school
16:34:58 <dminuoso> Originally I thought "IO" was special in Haskell. It wasnt until a few weeks ago that I finally realized that IO is not a special thing in Haskell.
16:35:05 <dminuoso> It's rather that the *lack* of IO that is special. :)
16:35:10 <hpc> i initally learned haskell between semesters
16:35:28 <hpc> and started with a month of like, 14-hour haskell learning days
16:35:38 <DrOrange> hpc: Did you need it for school?
16:35:45 <hpc> nope
16:35:56 <hpc> it seemed like fun :D
16:36:22 <hpc> that was... almost 10 years ago now, jeez time flies
16:36:32 <DrOrange> Reminds me of the good old days when I discovered C++ and Processing
16:36:41 <DrOrange> I wish I had spent more time on them then
16:36:44 <dminuoso> DrOrange: Nowadays I wish I never spend years on C++
16:36:47 * hackage hw-prim 0.6.2.13 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.13 (haskellworks)
16:36:47 <dminuoso> It feels like such a waste.
16:36:58 <madnight> dminuoso: well IO is special in that it is hard wired into the compiler and you cant write it yourself like other monads
16:37:19 <hpc> i learned enough c++ to make changes to a hl2 mod that could compile but not run
16:37:45 <hpc> there was nothing about it to make me feel like it was worth the effort learning
16:37:50 <DrOrange> I just love every part of it: feels sometimes that the compiler was made especially for me. Something I don't think I will ever feel with another language
16:37:56 <dminuoso> madnight: No my point is: Using IO is as simple as writing programs in any imperative language.
16:38:03 <hpc> it was all just "oh you can't use new here because dunno lol"
16:38:42 <DrOrange> hpc: And now you know how Haskell feels for me
16:38:42 <hpc> rust is great though, whenever i make a borrow checker mistake i never feel like it's something i should have been able to do
16:38:46 <hpc> it's always been my mistake
16:39:44 <madnight> dminuoso: i know what you want to say and i tend to agree, but with a few exceptions
16:39:47 * hackage Fin 0.2.5.0 - Finite totally-ordered sets  http://hackage.haskell.org/package/Fin-0.2.5.0 (MatthewFarkasDyck)
16:41:49 <hpc> the part that won IO over for me was realizing that IO actions are just values
16:41:58 <hpc> and as values, you can do whatever you damn well please with them
16:42:02 <hpc> :t forkIO
16:42:03 <lambdabot> error: Variable not in scope: forkIO
16:42:06 <hpc> blegh
16:42:31 <hpc> there are very few languages where creating a new thread is as clean as forkIO
16:42:43 <dminuoso> hpc: It's interesting, Im beginning to realize one of the primary strengths of functional programming is that when you implement some feature/behavior/sematic of another language - you hvae to do it with functions
16:43:00 <dminuoso> And because you use a function, it means you have just captured that feature/behavior/semantic as a first-class citizen.
16:43:06 <hpc> yeah
16:43:22 <hpc> i had a similar aha moment like that about ($) and function application
16:43:24 <hpc> wrt Cont
16:43:51 <hpc> and then another one with fix, which i still need to sort of make the last logical step on
16:43:58 <DrOrange> hpc: Fucking POSIX threads in c++, they emptied me inside. So hard to use and make them function, not worth the effort
16:44:22 <dminuoso> DrOrange: You should try Haskell with STM!
16:44:32 <DrOrange> STM?
16:45:16 <dminuoso> hpc: What moment did you have with fix?
16:45:29 <dminuoso> hpc: The idea that recursion itself can be captured as a first-class object?
16:46:18 <dminuoso> I mean lisp is the king of "being able to capture things as first class citizens" because its homoiconic.
16:46:42 <dminuoso> But its unwieldly to use from what I can tell
16:47:18 <hpc> DrOrange: https://gist.github.com/headprogrammingczar/4574ce6eea6d3a4ae57c442eca724a15 - thread pool in 10 lines
16:47:46 <hpc> DrOrange: it creates a queue for actions to run in the pool, and a bunch of threads running loops
16:47:54 <hpc> which consume actions from the queue and run them
16:48:15 <dminuoso> DrOrange: STM is software transactional memory. It's a clean and simple way to gain *safe* concurrency.
16:48:28 <hpc> to run an action on the pool, writeChan c $ do {the thing you want it to do}
16:49:08 <hpc> dminuoso: lisp is very bad at it, actually
16:49:45 <hpc> dminuoso: references to functions, references to values, and references to macros, and quotes of expressions
16:49:49 <hpc> are all totally different things
16:49:53 <dminuoso> Mmmm.
16:49:57 <DrOrange> What's "$"?
16:50:02 <hpc> :t ($)
16:50:03 <lambdabot> (a -> b) -> a -> b
16:50:06 <hpc> f $ x = f x
16:50:11 <hpc> it's function application as a function
16:50:20 <stilgart> f $ g x = f (g x)
16:50:43 <DrOrange> Woooooooooooow
16:50:56 <DrOrange> That's really really nice
16:51:07 <dminuoso> hpc: Mmm fair enough.
16:51:17 <hpc> DrOrange: it's great combined with (.)
16:51:26 <hpc> f . g . h $ x = f (g (h x))
16:51:34 <marvin3> > map ($10) [(+2),(*2),(^2)]
16:51:35 <stilgart> > map ($ 3) [ (1+), (2*), (4-) ]
16:51:35 <dminuoso> hpc: Maybe the raw LC approach is the real king. I mean by turing-completeness it's guaranteed we can capture everything in a lambda..
16:51:36 <lambdabot>  [12,20,100]
16:51:37 <lambdabot>  [4,6,1]
16:51:42 <stilgart> marvin3: :)
16:51:47 <marvin3> first =)
16:51:50 <stilgart> indeed
16:51:58 <hpc> DrOrange: f $ g $ h $ x technically works too, but
16:52:10 <hpc> (f . g . h) is a thing all on its own
16:52:23 <hpc> and is a function that takes x, and does the whole pipeline of functions on it
16:52:33 <rotaerk> I don't really see any reason to use . instead of $ when it's immediately applied
16:52:58 <dminuoso> rotaerk: (.) denotes a kind of processing pipeline
16:53:00 <DrOrange>  So "." is just pipelining?
16:53:10 <DrOrange> Ok
16:53:11 <hpc> :t (.)
16:53:12 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:53:13 <dminuoso> DrOrange: we call it function composition
16:53:23 <hpc> (f . g) x = f (g x)
16:53:25 <rotaerk> right but f . g . h $ x  is the same as f $ g $ h $x
16:53:41 <dminuoso> DrOrange: The reason why it's really advantageous to think of it as composition, is because semantically it creates a new function
16:53:45 <dminuoso> one that is the composition of the input
16:53:53 <hpc> rotaerk: it's a matter of what you're expressing, at a higher level than what the code does
16:53:57 <dminuoso> DrOrange: we can use this (.) as a higher order function
16:53:58 <dminuoso> for example
16:54:06 <rotaerk> k
16:54:14 <hpc> rotaerk: are you saying "do a bunch of function applications" or "the composition of these functions, applied to x"?
16:54:22 <dminuoso> @let compute = foldr (.) id [(+10), (*20), (sub 50), (*2)]
16:54:23 <hpc> usually it's the latter
16:54:24 <lambdabot>  .L.hs:161:42: error:
16:54:24 <lambdabot>      • Variable not in scope: sub :: Integer -> b -> b
16:54:24 <lambdabot>      • Perhaps you meant one of these:
16:54:29 <dminuoso> @let compute = foldr (.) id [(+10), (*20), (*2)]
16:54:30 <lambdabot>  Defined.
16:54:34 <dminuoso> > compute 100
16:54:36 <lambdabot>  4010
16:54:42 <hpc> although i am guilty of lots of ($) on one line myself in code i wrote while learning haskell
16:55:13 <rotaerk> I do the "a bunch of function applications" rather than "composition of these functions, applied to x" usually
16:55:25 <dminuoso> rotaerk: ($) has a stronger focus on "data shuffling" and it makes it harder to see the structure of the program :)
16:56:01 <dminuoso> rotaerk: also another good reason is that (.) makes for simpler refactoring.
16:56:24 <dminuoso> rotaerk: You can simply extract the pipeline out into a separate binding with no extra work. You cant do that with ($)
16:56:31 <hpc> or part of the pipeline
16:56:40 <hpc> (.) is associative
16:56:53 <elpfen> What's that function that coalesces all maybes or eithers? I think it's a monad transformer. Hard to hoogle, sorry
16:56:54 <hpc> if you have f . g . h . j . k
16:57:00 <dminuoso> (.) also has an identity
16:57:02 * glguy tries to remember a time when using . over $ saved a noticable amount of timer in a future refactoring
16:57:05 <hpc> one day you decide f . g and h . j . k are sensible factorings
16:57:21 <hpc> the next day you discover some neat property and now f, g . h, and j . k
16:57:25 <hpc> are the better factoring
16:57:31 <dminuoso> elpfen: catMaybes or asum?
16:57:52 <rotaerk> here's some of my recent code https://github.com/Rotaerk/vulkanTest/blob/master/main/src/Main.hs#L345-L367
16:58:03 <hpc> glguy: changing the way you thought probably did more than the punctuation itself
16:58:04 <elpfen> I don't think it was a traversable op, I'm pretty sure it was a monad transformer
16:58:12 <hpc> and that's hard to measure
16:58:23 <glguy> guard $ not . null $ surfaceFormats   is not bettr than   guard (not . null) surfaceFormats
16:58:26 <DrOrange> So foldr goes from right to left and applies (.), which just computes 100*2*20+10?
16:58:43 <rotaerk> yeah, I could change that
16:58:45 <glguy> err, what's even going on there
16:59:06 <glguy> guard (not (null surfaceFormats))
16:59:29 <rotaerk> guard (not . null $ surfaceFormats)
16:59:30 <rotaerk> or something
16:59:51 <rotaerk> it's guaranteeing that there exist surface formats and present modes
17:00:06 <glguy> There's no merit badge for using 1,000 operators
17:00:13 <rotaerk> lol
17:00:24 <hpc> don't tell edwardk
17:00:46 <dminuoso> glguy: What a brilliant idea. Github should have badges.
17:01:01 <dminuoso> "Unique operators used"
17:01:36 <hpc> it can be like stack overflow
17:01:40 <dminuoso> DrOrange: foldr just constructs a new function that is: (+10) . (*20) . (*2)
17:01:42 <hpc> you must have this many points to merge request
17:01:48 <hpc> er, pull request
17:02:02 <buhman> should integrate with CI, so you automatically get rewarded with flashier badges as your code "improves"
17:02:04 <glguy> As long as you have to spend those points to clutter code with $ and .
17:02:25 <hpc> glguy: nah, one point per line of code
17:02:29 <hpc> simple and fair :D
17:02:31 <dmwit> I have types PrinterWarning and ParserWarning defined in the same module that both want to steal XPositionOverflowed data constructor name. wat do
17:02:47 <dminuoso> buhman: CI should cost points. Real code warriors dont test their code, they simply don't write bad code.
17:02:55 <marvin3> DrOrange, foldr composed those functions into a new function, which was named compute. a simpler example of using (.):
17:02:58 <marvin3> > let f = sum . concat in f [[1,2,3],[4,5,6]]
17:03:00 <lambdabot>  21
17:03:05 <hpc> dmwit: make them the same type
17:03:10 <DrOrange> dminuoso: Shouldn't it be the other way around? 100 . (*2) . (*20) . (+10)?
17:03:22 <dmwit> dminuoso: Occasionally I think, "this code is too simple to have bugs", and then am humbled.
17:03:25 <dminuoso> DrOrange: The point was really just to show that (.) was not an intrinsic but just a function that has some inputs and an output :)
17:03:34 <glguy> dmwit: change one constructor's name or put them in different modules?
17:03:40 <dminuoso> DrOrange: Nope, foldr works the other direction :)
17:03:43 <dminuoso> DrOrange: strictly speaking its:
17:03:46 <dmwit> hpc: That's a possibility I hadn't considered.
17:03:54 <dminuoso> compute = (+10) . (*20) . (*2) . id
17:04:05 <dminuoso> but `a . id = a` so ...
17:04:13 <DrOrange> dminuoso: Oh, I get what you mean now. Everything is a function :))
17:04:16 <hpc> dmwit: they're both a type of error, a description, and a location
17:04:17 <hpc> dmwit: :D
17:04:20 <dminuoso> DrOrange: Yes! :)
17:04:30 <dminuoso> DrOrange: well not everything, but plenty of things
17:04:33 <marvin3> except things that aren't :)
17:05:02 <ab9rf> every function is a function
17:05:20 <DrOrange> Except for monads... those are something else
17:05:26 <jle`> why is lyah on hacker news lol
17:05:41 <buhman> we could build a whole service around this; it could serve up starbursts like https://codecov.io/gh/ptpb/pb so that you know where you need to add more operators
17:05:44 <marvin3> but yes, a lot of things that appear like built-in syntax in haskell are just functions
17:05:52 <rotaerk> jle`, maybe it's the hip new thing again
17:06:01 <dmwit> glguy: Yeah, I should know enough to know those are basically the choices.
17:06:19 <dmwit> I guess in retrospect I just wanted to whine. =P
17:06:20 <glguy> DrOrange: Most things aren't functions: Ints, Bools, lists, Strings, everything that doesn't have type (a -> b)
17:06:30 <ab9rf> jle`: slow news day
17:06:57 <glguy> dmwit: fine by me 
17:07:09 <hpc> glguy: a list could be lots of functions :P
17:07:27 <hpc> so could a string!
17:07:30 <hpc> > "function"
17:07:31 <lambdabot>  "function"
17:07:35 * hpc runs away
17:07:41 * glguy closes the door behind hpc
17:09:13 <ab9rf> glguy: it does occur to me that "essentially all" of the values in Hask are functions
17:09:34 <dmwit> jle`: It's funny. If you go by comment text, reposts are among the least popular, but if you go by votes, reposts are among the most popular.
17:09:53 <ab9rf> dmwit: votes are cheap
17:10:13 <ChaiTRex> The complaints about reposts are all reposts.
17:12:16 <dmwit> I am cheap. Therefore I are votes.
17:17:10 <jle`> 'everything is a function' is definitely a prevailing fallacy in haskell
17:17:17 <jle`> s/prevailing/persistent
17:17:36 <jle`> it's an objectively wrong sentiment that refuses to go away :'(
17:17:50 <dmwit> Everything is a function, and every function is memoized.
17:21:01 <rotaerk> but in Java, an OOP language, it is *known* that everything is an object
17:21:08 <rotaerk> therefore in a FP language, everything must be a function
17:23:03 <jle`> this is one of conal's theories in http://conal.net/blog/posts/everything-is-a-function-in-haskell
17:23:49 <koz_> rotaerk: In Java, that statement is patently false.
17:23:56 <koz_> Unless you're gonna argue that 'int' is an object.
17:24:03 <koz_> Which is true neither conceptually nor implementationally.
17:24:29 * dmwit has just witnessed the birth of a new word
17:24:39 <buhman> I too also stared at this
17:24:44 <rotaerk> yeah I know
17:25:42 <jle`> in java i'd say that it is true with caveats
17:26:02 <rotaerk> classes aren't objects !
17:26:34 <rotaerk> though in haskell some types are functions
17:26:56 <hpc> koz_: it's true enough in java because everyone uses Integer and automatic unboxing
17:27:08 <jle`> some types are "type functions"
17:27:20 <jle`> but the report doesn't call those functions
17:28:31 <rotaerk> yeah, I wasn't referring to "functions as defined by the report"
17:58:05 <monochrom> All of you are right. A lot of Java people just pretend that everything is an object.
17:58:59 <monochrom> If you bring up int values, they'll just dismiss you as a pedant.
17:59:03 <pie_> hey guys, i have a list of sets, some of the sets are subsets of the other sets, is there an easy way to remove the redundant results?
18:01:19 <monochrom> Define "redundant". And define how to decide which ones to remove.
18:02:53 <jle`> give a sample input and output :)
18:06:11 <dmwit> pie_: Perhaps `unions :: Ord a => [Set a] -> Set a` is good enough for you.
18:06:41 <pie_> dmwit, its not because some of the results are "bad" and i havent decided which ones are yet
18:07:01 <pie_> i was thinking that wouldnt work but now that you mention it, it otherwise probably would
18:07:02 <pie_> hm
18:07:56 <pie_> so my type is [Set (String,String)], it's a list of sets of mappings
18:08:57 <pie_> and so if i have something like [{("a","b"), ("b","c")}, {("b","c")}, {("f","h")}]
18:09:06 <pie_> the second result should be removed because its a subset of the first one
18:09:37 <dmwit> :t sortOn
18:09:38 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
18:10:48 <pie_> isnt that just for ordering?
18:11:36 <dmwit> :t map head . filter (\xs -> case xs of [] -> False; x:rest -> all (not . (x `S.isSubsetOf`)) rest) . tails . sortOn S.size
18:11:37 <lambdabot> Ord a => [S.Set a] -> [S.Set a]
18:12:17 <pie_> woah
18:12:18 <jle`> so you want to remove sets in a list that are complete subsets of another?
18:12:23 <pie_> jle`, yes
18:12:23 <dmwit> O(n^2). It is probably possible to do better.
18:12:26 <koz_> OK, this is doing my head in. I have a type Column a, which stores values of a based on a certain set of constraints, defined by another type Signature a. I wanna be able to store a collection (list, vector, w/e) of Column a where any given 'a' could be different (so for example, a Column Float, a Column Text and a Column Int), with the associated Signatures. However, I can't think of how I can do this
18:12:29 <koz_> without destroying information about 'a' and also not having a special-purpose container for each possible combination of types I would need.
18:12:31 <koz_> How would I go about doing this?
18:12:39 <pie_> dmwit, thats what i figured, not sure about doing better (easily)
18:13:46 <dmwit> koz_: data WithSig = forall a. WithSig (Column a) (Signature a)
18:14:08 <dmwit> koz_: But you'll want `Signature` to be a GADT that lets you recover `a`, or else include some typeclass constraints on `a` in that existential box.
18:14:08 <koz_> dmwit: But doesn't this mean that (say) [WithSig] destroys all information about each given a?
18:14:17 <dmwit> koz_: Yes, see my second message. =)
18:14:21 <koz_> How would I make a GADT that lets you recover this info?
18:14:56 <pie_> dmwit, whats that function it takes as an arg?
18:15:00 <dmwit> data Signature a where ArrowSig :: Whatever -> Signature a -> Signature b -> Signature (a -> b); IntSig :: WhateverForInts -> Signature Int; FloatSig :: WhateverForFloats -> Signature Float -- etc.
18:15:15 <koz_> dmwit: Ah, OK.
18:15:18 <dmwit> pie_: "it" = "filter"?
18:15:40 <pie_> dmwit, facepalm, i was reading the wrong signature from the bot
18:17:11 <dmwit> pie_: Might have to be `sortOn (negate . S.size)`, I can never remember which way `sort` sorts things.
18:17:23 <dmwit> You want the small sets early in the list after sorting.
18:17:36 <pie_> sorton sorts smallest first
18:17:57 <pie_> hmm yeah i need to find a better approach for this, this n^2 is going to be REALLY slow
18:18:06 <pie_> i have like 30000 elements
18:18:32 <pie_> its speeding up but still gonna take a while
18:18:35 <dmwit> I have a cunning plan.
18:18:38 <pie_> oh hey it finished
18:18:48 <dmwit> Convert your [Set a] to a Trie a.
18:18:54 <MarcelineVQ> dmwit: is it to use Down?
18:18:55 <pie_> dmwit, i might be able to do some filtering earlier in my pipeline, things are a bit of a mess right now
18:19:19 <pie_> dmwit, what actually happens if that i have an AST, and im ...lets just say sampling some subtrees from it
18:19:21 <dmwit> Then just ignore internal nodes in the Trie and you're done.
18:20:11 <pie_> so if i could kill the redundancy at the subtree extraction stage it might be better...
18:20:13 * pie_ ponders
18:20:25 <dmwit> (Oh, neat! This means you don't have to store the usual `Bool` telling whether the current internal node is "final" or not.)
18:20:31 <pie_> hm, i dont know much about tries
18:21:06 <pie_> oh boy.
18:21:31 <dmwit> For your purposes, roughly, `Trie a ~ Map a (Trie a)`, plus the invariant that the key in each map is smaller than any value stored in the value tries.
18:22:26 <pie_> ok, i need to think about things and probably do some refactoring, then get back to this *thumbs up*
18:22:32 <dmwit> (Industrial strength tries also do "path compression", in which consecutive singleton maps are stored all at once, so roughly `Trie a ~ Map [a] (Trie a)` with some extra invariants.)
18:22:46 <pie_> fancy
18:22:59 <pie_> your routing seems to have crushed my 30000 nodes to 7000
18:23:02 <dmwit> There are trie packages on Hackage, though, so you can probably reuse one of them and save some effort there at minimal performance cost.
18:23:11 <pie_> *routine
18:28:54 <pie_> random question, can I have GHC parallelize (pure) library functions im some automatic way?
18:29:26 <koz_> pie_: Depends what you mean by 'automatic'.
18:29:38 <pie_> magicUseMoreCPUsFunction doThing
18:29:51 <dmwit> No. But see `par` and `pseq`.
18:29:56 <pie_> ah ok, oh well
18:30:00 <dmwit> It's not automatic, but it is quite lightweight.
18:30:05 <pie_> i am vaguely familiar with thos
18:30:11 <dmwit> And there are libraries for parallelizing data structures.
18:30:22 <koz_> Some have that built-in (for example, massiv).
18:30:24 <pie_> ok ill look into it
18:30:33 <dmwit> Though list manipulations... are usually hard to parallelize.
18:30:55 <pie_> it was more of a general question
18:31:21 <pie_> i should memoize this stuff to a file
18:32:29 <pie_> also wow im very inefficient, using lots of ram
18:50:48 <techieAgnostic> On hackage what are the yellow vs purple version numbers?
18:52:17 * hackage bins 0.1.1.0 - Aggregate continuous values into discrete bins  http://hackage.haskell.org/package/bins-0.1.1.0 (jle)
19:02:26 <glguy> techieAgnostic: Which package?
19:02:55 <techieAgnostic> hspec
19:03:08 * geekosaur can never remember what the colors mean, but purple is normal versions
19:03:17 <geekosaur> and they make it annoyingly difficult to find the legend
19:03:30 <techieAgnostic> im wondering cos i can cabal2nix cabal://hspec-2.0.0, but not for 1.9.5
19:03:41 <glguy> Purple are "preferred versions"
19:03:48 <glguy> hspec specifies that >= 2.0 is preferred
19:04:12 <glguy> http://hackage.haskell.org/packages/preferred
19:04:28 <pie_> dmwit, i have an idea
19:04:38 <glguy> Preferred and deprecated versions can be used to influence Cabal's decisions about which versions of hspec to install. If a range of versions is preferred, it means that the installer won't install a non-preferred package version unless it is explicitly specified or if it's the only choice the installer has. Deprecating a version adds a range which excludes just that version. All of this information is collected in the preferred-versions file that's 
19:04:38 <glguy> included in the index tarball.
19:04:58 <pie_> so what im actually doing is i have two trees for which im trying to find identical substructures (basically i erase variable names)
19:05:37 <pie_> *they are ASTs and I find identical substructures by erasing variable names, hashing the nodes (so...turning it into a merkle tree?) and then taking the intersection of the node hashes
19:06:07 <pie_> so if you have say a top level match, then you will get matches all the way down, which is what will result in redundant results
19:07:00 <pie_> so im thinking, if i take all the hashes of say tree A, and i take the hashed of tree B _in top-down level order_
19:07:05 <pie_> *hashes of tree B
19:07:42 <pie_> then what I can do is if I find a match, I can to a traversal of that node and remove all its children from the union?
19:08:16 <techieAgnostic> glguy: Ahh ok, thank you
20:03:02 <ChaiTRex> Does -fno-spec-constr-count set the count to zero or infinity?
20:07:18 <fragamus> hi I need help with pedagogy: https://gist.github.com/fragamus/0739f346cb80f04af381e86a5e39a768
20:10:30 <MarcelineVQ> try writing this using multiple separate map's under a let and see if you find it more readable
20:11:30 <glguy> fragamus: Stick with map and (.) instead of <$> when you can to make it easier to understand what's happening. Put type signatures on top-level definitions to give the reader a hint about what they're looking at
20:11:54 <fragamus> yeah
20:12:14 <glguy> Avoid mixing composition and operators slices
20:12:16 <fragamus> can you tell what it is intended to do
20:12:25 <glguy> No, not at a glance
20:12:43 <ChaiTRex> The type of the first one is apparently [[String -> String]]
20:12:48 <fragamus> it sucks up a phone number and spits out letters 
20:13:01 <ChaiTRex> Oh.
20:13:20 <fragamus> for remembering phone numbers
20:14:45 <glguy> So this? letters i = ["0","1","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"] !! i
20:14:45 <glguy> example = traverse (letters . digitToInt) "4742836"
20:16:40 <fragamus> oh nice
20:17:09 <fragamus> i shall make an adjustment and adopt that
20:35:35 <blankhart> say i want an algorithm to score (for example) how close xooxxoox is to xoooxoxx. it's closer than oooooooo, but not as close as an exact match. i have a number of problems that are variations on this theme involving things more complicated than x and o. what should i read about?
20:35:57 <suzu> levenshtein edit distance
20:36:13 <suzu> https://en.wikipedia.org/wiki/Edit_distance
20:36:15 <ChaiTRex> You could convert them to bits, use xor and popCount.
20:36:45 <suzu> his question was about literature
20:36:53 <suzu> you can start with that wikipedia link
20:36:54 <ChaiTRex> Oh.
20:37:11 <blankhart> thank you that looks just right suzu
20:37:41 <suzu> what are you working on?
20:37:51 <suzu> or rather, what are you actually trying to do?
20:39:57 <blankhart> match lines of poetry against an expected scansion, match phonemes against rhyming patterns, match words against correct spellings, etc.
20:40:27 <suzu> ok
20:42:08 --- mode: glguy set +v williamyaoh
20:43:03 <williamyaoh> hey all, I have a question about stm
20:43:26 <williamyaoh> I have a minimal example here: https://lpaste.net/1055575125950201856
20:43:44 <williamyaoh> and I'm wondering why I'm not getting 0 for a result
20:44:36 <giovanifss> I also asked on #ghc, but do you know how hard it's to create ghc bindists? The support for openbsd is kind of lacking, so I was wondering if it would be something I could do
20:47:05 <maerwald> it's sufficiently documented
21:00:05 <koz_> dmwit: I tried your suggestion, but I'm getting these errors: https://lpaste.net/2097558471409926144
21:00:34 <koz_> (in this case, AttributeOf is the GADT that's meant to make the type hidden by Column's existential recoverable)
21:01:06 <dminuoso> jle`: That "Reasons vs rationalizations" part put the nail into the coffin for me.
21:02:03 <dminuoso> That is there is nothing wrong with claiming "every value can be thought of as a function" - this is somewhat equivalent to calling () the terminal object in Hask.
21:05:59 <dminuoso> Err. Terminal object of course. Heh it's a bad idea to talk category theory 10 minutes after waking up.
21:08:10 <pie_> is there a simple way to parallelize this?
21:08:11 <pie_> let [baked, compiled] = fmap Parser.readJs [b,c]
21:08:23 <pie_> my pokings at seq seem to be unsuccessful so far
21:08:34 <pie_> i compiled with -threaded and tried this:
21:08:34 <pie_> hb <- hashAST (compiled `par` baked)
21:08:34 <pie_>     hc <- hashAST compiled
21:09:01 <koz_> pie_: http://hackage.haskell.org/package/parallel-3.2.2.0/docs/Control-Parallel-Strategies.html#v:parMap <-- this maybe?
21:13:43 <dsal> Is there a convenient      Applicative f => (a -> a -> a) -> a -> a -> f a
21:13:51 <koz_> :t liftA2
21:13:53 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
21:13:56 <dsal> @hoogle Applicative f => (a -> a -> a) -> a -> a -> f a
21:13:56 <koz_> Wait no.
21:13:57 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
21:13:57 <lambdabot> Diagrams.Prelude liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
21:13:57 <lambdabot> Streaming liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
21:14:04 <dsal> Yeah, that's what hoogle keeps telling me, but it's not what I want.
21:14:31 <dsal> I basically want to make (+) into  Int -> Int -> Maybe Int
21:14:33 <koz_> :t (+) <$> 2 <*> 2
21:14:34 <lambdabot> (Num (f b), Num b, Applicative f) => f b
21:14:42 <koz_> dsal ^
21:15:17 <dsal> @pl \a b -> (+) <$> a <*> b
21:15:17 <lambdabot> (((+) <$>) .) . (<*>)
21:15:19 <dsal> heh
21:15:32 <koz_> Yeah... I wouldn't write it pointfree.
21:15:42 <pie_> maybe i want rdeepseq or something because none of this stuff seems to do it
21:15:45 <dsal> I'll just make a convenience function.  This is just for repling anyway.
21:15:51 <dsal> Thanks, though.
21:15:52 <koz_> :t f <$> x <*> y
21:15:54 <lambdabot> error:
21:15:54 <lambdabot>     • Couldn't match expected type ‘f ()’ with actual type ‘Expr’
21:15:54 <lambdabot>     • In the second argument of ‘(<$>)’, namely ‘x’
21:16:01 <pie_> so i guess i need to make an nfdata instance or something
21:16:02 <koz_> Damn, it won't show that. :(
21:16:10 <dsal> Yeah, that's fine.  I'll just do that in the repl.  Thanks!
21:16:10 <glguy> koz_: What you're writing isn't what dsal asked about
21:16:29 <glguy> :t \f x y -> pure (f x y)
21:16:30 <lambdabot> Applicative f => (t1 -> t2 -> a) -> t1 -> t2 -> f a
21:16:34 <dsal> > (+) <$> 2 <*> 2   :: Maybe Int
21:16:36 <lambdabot>  error:
21:16:36 <lambdabot>      • No instance for (Num (Maybe Int)) arising from the literal ‘2’
21:16:36 <lambdabot>      • In the second argument of ‘(<$>)’, namely ‘2’
21:16:49 <koz_> glguy: Yeah, sorry about that.
21:16:55 <koz_> Guess I'm just clueless today.
21:17:57 <dsal> pure (f x y) is what I did.  I just thought that might have a name, though it's a little weird.
21:20:23 <glguy> :t ((pure.).)
21:20:24 <lambdabot> Applicative f => (a1 -> a2 -> a3) -> a1 -> a2 -> f a3
21:20:27 <glguy> the savings!
21:20:33 <koz_> glguy: Lol.
21:20:52 <koz_> :t (((pure .) .) .)
21:20:53 <lambdabot> Applicative f => (a1 -> a2 -> a3 -> a4) -> a1 -> a2 -> a3 -> f a4
21:21:23 <glguy> koz_: Don't spend all your savings on the extra spaces :)
21:23:30 <c_wraith> edwardk's lens examples always make me feel weird for continuing to put spaces around . like I do every binary operator..
21:23:44 <koz_> c_wraith: I do it as well. Old habits die hard.
21:24:15 <c_wraith> I'm sticking with it.  I'm just going to scratch my head and wonder "is that normal?" frequently. :)
21:28:01 <sssilver> hi all... in my game I have an FOV (frame of view) and Exposure. Both are floats. Should they be defined as unique types?
21:28:12 <dsal> Ah, the extra parens would've done it.
21:28:17 <sssilver> intuition says yes because I don't wanna pass an FOV to something that expects an Exposure
21:28:27 <sssilver> where can I read more about this?
21:30:19 <suzu> it is called 'newtype wrapping' sssilver 
21:31:07 <suzu> https://wiki.haskell.org/Smart_constructors
21:40:03 <sssilver> suzu: is there more generic material about this that recommends general approaches?
21:42:16 <subttle> Hi, I have a question potentially regarding something like a quotient type. The bigger picture is that I have a function which minimizes my automaton type `minimize :: DFA q s -> DFA (Set (Set q)) s` which works fine, and while the state space blows up, the amount of "useful" states (states which are reachable from q₀ and can reach some state in F) either stays the same (automaton was already 
21:42:22 <subttle> minimized) or decreases.
21:42:26 <cocreature> sssilver: there’s really not that much to it, it’s basically “wrapt the existing type in a newtype and if you want to perform validation use a smart constructor”
21:42:42 <subttle> I was hoping to write a new version of `minimize` by making the new state space something like `minimize :: DFA q s -> DFA (EquivalenceClasses q) s` where the equivalence classes are determined by the equivalence relation formed by evaluating if two states are `indistinguishable` where `indistinguishable :: DFA q s -> q -> q -> 𝔹`.
21:43:04 <subttle> So far it looks like I'm either to use the `equivalence` or `setoid` packages, but I'm rather inexperienced with monad transformers, and not entirely sure I can do this without dependent types, so I'm asking if anyone could nudge me in the right direction here, thanks!
21:43:04 <sssilver> cocreature: I'm more interesting in the theory behind it. How do you gauge between "every single thing is a unique type" and "everything is Any"
21:43:31 <sssilver> afterall the word "type" itself implies generality
21:43:43 <cocreature> I don’t think there is a lot of theory behind it, it’s a tradeoff made on a case-by-case basis
21:44:32 <sssilver> cocreature: doesn't type theory have a say in this?
21:45:06 <dsal> I've got a list monad that has a     a <- stuff     and      b <- otherstuff     then I'm trying to do      c <- permutations (a <> b)     I get a lot of duplicates, so I tried    c <- (Set.toList . Set.fromList . permutations) (a <> b)
21:45:11 <cocreature> I don’t think type theory helps you make the design tradeoffs here
21:45:18 <dsal> Doesn't seem to be any difference.   Is there a way to do this?
21:45:44 <dsal> Actually, it does deduplicate partially.
21:47:54 <cocreature> dsal: if your Ord/Eq instances are correct, that should work. are you sure you are actually seeing duplicates?
21:48:26 <dsal> Yeah, because if I run the results through the Set.fromList, it deduplicates the result.
21:48:55 <cocreature> so it does make a difference after all?
21:49:20 <suzu> is the intersection of a and b the empty set?
21:49:51 <suzu> and: are a and b made of unique elements?
21:50:21 <cocreature> depending on what exactly you want you could unique a <> b instead of the permutations
21:50:23 <suzu> if not.. then yeah this will give you duplicates
21:50:47 <dsal> So, it makes a difference, but it doesn't remove all duplicates.  Doing it to the result of the list monad removes all duplicates.
21:50:52 <dsal> a and b are definitely distinct.
21:51:42 <suzu> intersection?
21:52:23 <cocreature> dsal: can you show us the full do block? are you returning c directly or maybe postprocessing c, e.g., something like return (fst c)
21:52:38 <suzu> what is the type of a and b?
21:52:48 <suzu> what's their semigroup instance do?
21:54:38 <dsal> I'm doing one of those "solve for X with a bunch of numbers and operators" problems.  "a" in this case is a bag of digits and "b" is a bag of operations.  I shake them all up and see what wins. https://www.irccloud.com/pastebin/wzYx5a2m/thing.hs
21:55:32 <glguy> dsal: Is the original problem description online somewhere?
21:56:59 <dsal> Not really.  It was on a whiteboard at work written in perl6 with some eval and stuff.   Given a set of numbers, find a way to come up with a specific value using some common operators.  In this case, I'm trying  to get [5, 5, 5, 1] to == 24
21:57:20 <suzu> sounds like dynamic programming
21:57:23 <dsal> My thing evaluates in RPN.
21:57:59 <suzu> to solve (make 24 with [5,5,5,1]) you can solve (make 29 with [5,5,1]) and add + 5 to the end of it
21:58:08 <suzu> err make 19* not 29
21:58:55 <suzu> if that fails then you can try (24/5) with [5,5,1] and multiply the result by 5
21:58:59 <suzu> if that fails you can .. etc
22:00:50 <dsal> It solves the problem, but it spits out a bunch of   [5,5,*,1,5,^,-],[5,5,*,1,5,^,-]
22:02:47 * hackage antiope-athena 6.0.1 -   http://hackage.haskell.org/package/antiope-athena-6.0.1 (newhoggy)
22:03:47 * hackage antiope-sqs 6.0.1, antiope-sns 6.0.1, antiope-s3 6.0.1, antiope-messages 6.0.1, antiope-dynamodb 6.0.1, antiope-core 6.0.1 (newhoggy)
22:05:22 <cocreature> dsal: you are deduplicating separately for each choice of "digs" and "ops". if the results for different choices of "digs" and "ops" overlap, you’ll get duplicates
22:07:27 <dsal> That sort of makes sense, but I don't understand how.  My goal was to smash them together, permute, and remove common permutations.  This is primarily a problem with this particular input because there are a lot of 5s.
22:08:50 <cocreature> dsal: do you not understand why things overlap or why the list monad behaves this way?
22:09:08 <dsal> Heh, possibly both?
22:10:19 <dsal>  Oh.  Actually, I think I do get it.
22:10:44 <cocreature> each line in the do block runs once for each combination of choices made before it
22:11:09 <cocreature> > [[1,2,3],[1,2,3]] >>= Set.toList . Set.fromList
22:11:10 <lambdabot>  error:
22:11:11 <lambdabot>      Not in scope: ‘Set.toList’
22:11:11 <lambdabot>      Perhaps you meant one of these:
22:11:16 <cocreature> > [[1,2,3],[1,2,3]] >>= Data.Set.toList . Set.fromList
22:11:18 <lambdabot>  error:
22:11:18 <lambdabot>      Not in scope: ‘Set.fromList’
22:11:18 <lambdabot>      Perhaps you meant one of these:
22:11:19 <cocreature> > [[1,2,3],[1,2,3]] >>= Data.Set.toList . Data.Set.fromList
22:11:21 <lambdabot>  [1,2,3,1,2,3]
22:12:07 <dsal> Yeah, that makes sense.  I don't haskell enough to really internalize things.
22:14:50 <cocreature> dsal: as to why things overlap, let’s say digits = [1,5,5] then you’ll get the permutations [1,5,5] and [5,1,5] (among others). the inputs produced for those two choices of digs will be the same
22:15:10 <dsal> Yeah, that's why the whole thing works in the first place.
22:15:35 <cocreature> that’s also why you get duplicates :)
22:16:48 <mnrmnaugh> ooo thats cool
22:17:03 <dsal> Kind of annoying that  -> set ->  waits for all inputs before providing any outputs.
22:17:37 <dminuoso> Is there a better way to indent NonEmpty than this? https://gist.github.com/dminuoso/d3f21c67cc0aed40d861c5efc29cb898
22:17:41 <dsal> This is a case where nub is better.
22:18:41 <dminuoso> I mean aside from using OverloadedLists and NonEmpty (which I refuse to use because I dont want a sword labelled "bottom" hanging over my head)
22:19:58 <mnrmnaugh> yeek. id align fist char of column myself, but, thats not to bad, oh like this? maybe https://ptpb.pw/zJnI
22:20:12 <mnrmnaugh> oh, and comma at end, not start
22:20:33 <koz_> Could someone help me figure out how to use Type.Reflection? It's a bit larger, so I've zipped a stack project here: https://transfer.sh/ygOWK/reflection-confusion.zip
22:20:43 <dminuoso> mnrmnaugh: actually I might prefer that as is
22:20:54 <koz_> Just unzip it, cd in, stack setup, stack build.
22:21:04 <koz_> The error message totally confounds me.
22:21:10 <mnrmnaugh> ye, doesnt look to bad as is
22:21:12 <dsal> Is there something like nub with better complexity that can stream results?  It seems like it'd be easy enough to write.
22:21:25 <koz_> dsal: Depending on the constraints, you can do better.
22:21:28 <dminuoso> I quite like commas at the beginning, makes things line up quite nicely
22:21:35 <koz_> If you have an Ord constraint, you can 'filter' it through a Set.
22:21:54 <koz_> If you have Hashable and don't care about the final ordering, you can do the same through a HashSet.
22:21:59 <dsal> I'm using (Set.toList . Set.fromList) -- that doesn't produce any values until it's complete.
22:22:11 <buhman> I'm having trouble understanding applicative; what does "function in a context" conceptually mean (aside from the type)?
22:22:20 <koz_> dsal: You can use the Set in a State monad.
22:22:22 <koz_> (a lazy one)
22:22:24 <dminuoso> buhman: It doesn't mean something specific really ;)
22:22:27 <mnrmnaugh> oh the, one i changed. im so used to comma at end, is all
22:22:30 <koz_> That will produce values on-demand.
22:22:34 <dsal> I need to learn how to do that.  heh
22:22:42 <koz_> dsal: One sec.
22:22:49 <dsal> Because that sounds ideal.  I want state in this list monad.
22:23:08 <dsal> Another guard that ensures I've not seen this input.
22:23:13 <dminuoso> buhman: Applicative is best described by this though
22:23:17 <dminuoso> :t liftA2 (,)
22:23:18 <lambdabot> Applicative f => f a -> f b -> f (a, b)
22:23:39 <cocreature> go seen [] = []; go seen (x : xs) | x `member` seen = x : go (Set.insert x seen) xs; otherwise = go xs
22:23:40 <dsal> Ideally I could canonicalize this input and filter out equivalent expressions.
22:23:57 <koz_> cocreature's definition is basically the idea.
22:24:15 <cocreature> I don’t think a State monad really helps here
22:24:28 <dminuoso> :t uncurry $ liftA2 (,)
22:24:29 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
22:25:06 <dminuoso> buhman: But really I recommend not worrying about applicative. Just focus on how you can use specific instances, you will naturally develop an intuition over time. :)
22:25:16 <dminuoso> Same holds true for Monad.
22:25:35 <buhman> oh welp, I was just about to start reading about that in earnest :)
22:26:01 <cocreature> the primary reason for the somewhat confusing type of <*> is that it plays really well with currying
22:26:12 <koz_> :t (<*>)
22:26:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:26:15 <cocreature> e.g. liftA2 f x y = f <$> x <*> y
22:27:06 <nshepperd> @let ordNub xs = foldr (\a k ss -> if S.member a ss then k ss else a : k (S.insert a ss)) (const []) xs S.empty
22:27:07 <lambdabot>  Defined.
22:27:21 <nshepperd> > ordNub [1..]
22:27:23 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:29:48 <dsal> This seen filter still seems to not be emitting values lazily.
22:30:04 <dsal> I probably got it wrong.
22:30:15 <nshepperd> it seems like adding ordNub to containers has been discussed on the libraries list occasionally, but hasn't happened yet
22:30:24 <buhman> also "g <$> f a" giving "h x = f (g(a, x))" seems magical
22:32:29 <buhman> though I suppose the left part of that isn't even correct
22:32:44 <cocreature> buhman: it’s also not true :) it should be g <$> f a = \x -> g (f a x)
22:32:49 <buhman> yeah
22:32:54 <cocreature> and even that is only true for one particular choice of Functor
22:32:56 <dsal> Nevermind, the test was backwards.
22:40:34 <koz_> Would someone be able to explain this to me? https://lpaste.net/5855438273094090752
22:41:43 <koz_> Relevant other file: https://lpaste.net/6400546485691219968
22:46:47 * hackage language-ats 1.7.0.3 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.7.0.3 (vmchale)
22:51:24 <pavonia> koz_: Not entirely sure, but I think the `a` of Column applies to any type whereas the `a` from exfiltrate is given by the caller
22:55:39 <cocreature> koz_: your type signature lets the _caller_ choose "a"
22:55:54 <cocreature> koz_: so for an arbitrary choice of "a" made by the caller, you need to be able to return "m a"
22:56:14 <cocreature> but your function returns a Text regardless of what choice I make for "a"
22:59:31 <cocreature> koz_: either make an ADT that can store Text and Double and return that or use a GADT + an existential similar to AttributeOf and Column
23:01:57 <koz_> cocreature: My goal here is to have the ability to create collections of Columns without having to have a new type for every combination of possible AttributeOfs inside said columns.
23:02:17 <koz_> dmwit suggested an approach like this, but I guess I misunderstood.
23:03:09 <mnrmnaugh> i got a question, i know its sugar, but if i can `[1..]`, why cant i `[..(-1)]` predictable means predictable, does it not?
23:04:02 <cocreature> mnrmnaugh: what would [..(-1)] :: Integer be?
23:04:43 <glguy> A type error, lists aren't integers!
23:04:45 <mnrmnaugh> i would think just the the same?
23:05:04 <glguy> mnrmnaugh: We don't know what you think that syntax means. What does it mean to you?
23:05:09 <mnrmnaugh> im still getting the hang of the type stuff
23:05:14 <mnrmnaugh> oh ok
23:05:34 <opqdonut> well [..x] could be [minBound..x]
23:05:39 <mnrmnaugh> predictable list, counting down, from -1 to ..
23:05:40 <opqdonut> just like [..] is [minBound..maxBound]
23:05:56 <cocreature> eh I meant [Integer] :)
23:06:00 <opqdonut> oh, that's called [-1,0,..]
23:06:00 <glguy> [..] isn't [minBound..maxBound]
23:06:14 <opqdonut> > [-1,0..]
23:06:16 <lambdabot>  [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
23:06:31 <mnrmnaugh> like, number line, 1 to inf, same with respect to -1 to -inf
23:06:38 <opqdonut> glguy: you're right... I misremembered
23:06:52 <opqdonut> gah
23:06:54 <opqdonut> > [-1,-2..]
23:06:56 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
23:06:57 <opqdonut> that's what I meant
23:07:16 <mnrmnaugh> ye that just goes up, i did think of that, and im glad it works
23:07:20 <opqdonut> mnrmnaugh: to be consistent, [..-1] should be a list _ending_ with -1
23:07:28 <koz_> cocreature: I guess I'll wait for dmwit to reappear and hopefully get an answer or some suggestions. Thanks for your help though.
23:07:34 <mnrmnaugh> mmmm, perhaps
23:11:06 <mnrmnaugh> but thats not consistent to me, for one, also this wonderful (yknow, its really nice to have decent compiler) complains for two
23:12:14 <trcc> Hi guys. I am creating, or attempting to, a haskell library. I come from a background of imperative programming, so I am trying to figure out how to do this stuff in a functional way and best practices. The library is for implementing simulation units (SUs) adhering to the Functional Mock-Up interface. Here, the SU is the slave, and a function called doStep will be invoked in an iterative fashion, from a third-party master. This function 
23:12:14 <trcc> is the heart of my question. If this was an imperative program, then I would offer an interface, that the developer of the SU would implement, and register in the framework. Then I could invoke his implementation. How is this performed in Haskell? I am thinking of stating that the developer must implement af function A with a given name and signature, which must call a given framework function FA and pass a function B, which FA invokes.
23:12:16 <mnrmnaugh> and why does lambdabot not get angry at lack of () around -x, i just noticed :O
23:13:01 <glguy> Why would you have expected it to?
23:13:38 <Athas> trcc: this can be done via type classes.  However, it might be simpler to just require the SU developer to make their work available as a record of functions.
23:14:17 <trcc> Athas: how can I do something similar to registering?
23:14:39 <trcc> I understand that type classes are somewhat similar to interfaces, but I am missing the registering part 
23:14:57 <mnrmnaugh> well apperently not at all... i was told to always use () around negative integers... but it seems not to be that case. ok then
23:15:07 <trcc> record of functions, did not think about that
23:15:22 <Athas> trcc: well, that is a stateful operation, so you need some coordination mechanism.
23:15:30 <cocreature> trcc: depends on what exactly registering is about to do. it might be as simple as adding it to a list
23:15:35 <cocreature> it = the record
23:15:47 <glguy> You need () around a negated function argument
23:15:56 <glguy> f (-1)
23:16:05 <cocreature> instead of having a stateful registering interface, you could also consider having the user pass in the list
23:16:47 <mnrmnaugh> ye, i geddit now. that makes sense. i thought it was a bit odd anyway
23:16:53 <trcc> athas cocreature: then the user-defined function must be invoked every time, and the user-defined function must call my framework, on every invocation of doStep right?
23:17:05 <trcc> It is because I feel it is leaving a lot up to the user, that I would like the framework to handle
23:17:50 <glguy> Otherwise it's subtraction: f-1
23:17:59 <mnrmnaugh> as a newbie coming from an imperative background, iterate is not the idea/term you want
23:18:16 <cocreature> trcc: I think I might be missing context here but I was thinking of passing the records to your framework and then the framework calls the functions in those records
23:18:47 <mnrmnaugh> ye, thats what i was, like.. "if its not going to try to eval as (-), why do i .. ok watever then"
23:18:57 <trcc> cocreature: the challenge is, that the framework is not in control. It executes a function, and then a third-party application is in control.
23:19:07 <mnrmnaugh> excuse me, apply, not eval
23:19:35 <mnrmnaugh> tho i guess in that case im ok calling them the same
23:20:21 <cocreature> trcc: a relatively simple solution would be to have the framework store some state in an IORef or something like that across invocations
23:20:35 <trcc> cocreature: can it also store records of functions?
23:20:39 <cocreature> suure
23:20:41 <cocreature> *sure
23:20:45 <mnrmnaugh> idk if this helps at all trcc , but ive been doing a mantra, "say what things are, not what they do"
23:21:04 <trcc> mnrmnaugh: I do not know if it helps either :)
23:21:14 <nshepperd> you need () around a negated value with an operator to the left of it, also
23:21:19 <cocreature> there might be a more functional solution but that depends a lot on the details of your application
23:21:22 <nshepperd> > 6 * (-7)
23:21:24 <lambdabot>  -42
23:21:26 <mnrmnaugh> logical
23:21:29 <nshepperd> I think those are the only two cases
23:21:48 <mnrmnaugh> my freind yelled at me for calling them operators :D
23:22:54 <trcc> cocreature: I already have some state stored in a stablePtr, that is passed to my library from the third-party application on every invocation. I guess, that I could just store the record of functions there as well.
23:23:16 <cocreature> right, that should work
23:23:28 <trcc> thanks
23:24:42 <cocreature> mnrmnaugh: that seems somewhat silly given that the Haskell 2010 standard also speeks of operators
23:24:50 <cocreature> *speaks
23:25:27 <mnrmnaugh> lolol, and even the fact that they are classicaly refered to as such. it is a good notion tho. everything is function
23:26:27 <glguy> No, not everything is a function
23:26:29 <mnrmnaugh> hes a bit daft. good guy. just, haskell was his first programming language, i think thats a large infulence
23:26:54 <glguy> There are integers, strings, tuples, and lots more
23:27:37 <mnrmnaugh> well ofc things like ( and ) and [ ] arent, but thinking of the 4 base operations as functions, made some things click
23:27:47 <mnrmnaugh> ye and those
23:29:07 <mnrmnaugh> this tuple stuff is wierd man... i was readin Data.Matrix the other day.. im so lost... why ( 0 0 0 0 ) aside from the fact that it looks nicer
23:29:39 <mnrmnaugh> im ok with n-pls, and lists. but smths fuckyyyy
23:29:50 <Athas> glguy: well, what is a string but a function from integers to characters?
23:30:56 <mnrmnaugh> well you wouldnt use a string to apply a functor. but ye. fair enough
23:31:21 <mnrmnaugh> names of functions are strings :p
23:31:30 <dminuoso> Athas: Haskell has a type system that gives a very clean and concise way of telling what a function is.
23:31:31 <nshepperd1> A function from integers to characters would represent an infinitely long string
23:31:40 <nshepperd1> In both directions
23:31:54 <dminuoso> Lists are not as much functions from integers to characters, since that gives you a partial function giving you a total mess.
23:32:03 <nshepperd1> Besides, being equivalent to a function is different from being a function
23:32:05 <dminuoso> Ornamented peano numbers is a cleaner way of calling them
23:32:53 <dminuoso> data List a = Cons a (List a) | Nil
23:32:55 <dminuoso> data Nat    = Succ   (Nat   ) | Zero 
23:33:06 <mnrmnaugh> partial eval got me good the other day.. i forget what i was doin tho
23:37:25 <mnrmnaugh> ive been doing foo :: Int -> Int -> Int; foo a = a   and similiar a bunch in ghci lately, tryna get a hang for the typesystem. i cant help but feel im doing it wrong...
23:37:59 <mnrmnaugh> or, thats not even the right... ye. i gotta get the hang here..
23:38:02 <dminuoso> nshepperd1: I really like how Conal put it with: I dont hear people say 'everything is a list' where 3 is really [3]` or `everything is a pair where 7 is really (7, _|_)`
23:38:52 <mnrmnaugh> :set +t is very nice, btw
23:39:28 <mnrmnaugh> yehp. ofc its foo :: p -> p
23:40:17 <Athas> dminuoso: yeah, I was mostly trolling, but I don't think that a functional representation would necessarily imply an infinite list.  Haskell is not a total language, and any function may be partial.
23:40:29 <Athas> Hell, Haskell does not even have parametricity in certain exotic cases.
23:40:55 <mnrmnaugh> i quite like the list stuff, and the list comprehension. which i finally have a hang of. idk why i couldnt rember the bloody syntax. its quite simple, like, predicate, is not a hard word
23:44:09 <nshepperd> Athas: a function Integer -> a implies an infinite list of 'a's, where some of the entries might be _|_
23:44:24 <nshepperd> the difference is a finite list tells you how long it is
23:44:36 <Athas> nshepperd: does Data.Array.(!) do that as well?
23:44:58 <Athas> :t (!!)
23:45:00 <lambdabot> [a] -> Int -> a
23:45:01 <Athas> Or that one.
23:45:48 <Athas> I suppose that denotationally, they might as well.  I can't offhand see why it would make any difference.
23:48:09 <gentauro> Athas: since you worked on an array language
23:49:31 <gentauro> would the following design (for index in order to avoid extra overhead of Maybe or throwing error out of bounds) be a valid design choice: Do a `case i .&. 31 of`?
23:49:34 <dminuoso> Athas: Let's enjoy that thought for a second if you dont mind.
23:49:47 <gentauro> that way I ensure that they will never call outside my FixedVector32
23:50:20 <cocreature> turning invalid inputs automatically into valid inputs is a terrible idea
23:50:39 <gentauro> cocreature: not if you write it down in the `docs`
23:50:43 <Athas> gentauro: so you turn every vector into an infinite repeating vector?
23:50:48 <dminuoso> Athas: Conal suggests that at the core "trying to think of it as a function is more about holding onto a belief in the face of evidence to the contrary than a means of *arriving* at a belief"
23:50:50 <gentauro> Athas: yes
23:50:53 <gentauro> just like a watch
23:50:53 <Athas> This is a very error-prone design.
23:51:02 <dminuoso> Athas: I think using bottom as an excute to make a point is the same thing really
23:51:10 <cocreature> gentauro: it’s still a terrible idea. what if I made a mistake? I want the API to tell me about it and not silently attempt to correct my mistake
23:51:11 <dminuoso> I like pretending that functions cant be partial.
23:51:31 <cocreature> e.g. if I have an off-by-one error and run off the end of the array it doesn’t make any sense to jump back to the first element in general
23:51:52 <gentauro> cocreature: that's a valid point
23:52:00 <Athas> dminuoso: me too!  "Morally correct" reasoning and all that.
23:52:14 <cocreature> I’ll take a crash over an incorrect result and a hard to find bug anyday
23:52:18 <Athas> gentauro: you really think the overhead of the bounds check will be significant?
23:52:26 <gentauro> cocreature: so I just throw the "out of bounds error" and let the world burn?
23:52:32 <cocreature> yes
23:52:39 <Athas> If you are writing this in Haskell, I guarantee you that something else will be the bottleneck before that bounds check.
23:52:55 <cocreature> I mean if you want to be fancy use some type system stuff and/or liquid haskell to prove that your indices are valid
23:53:04 <dminuoso> I also guarantee that most people suck at predicting where a bottleneck might be.
23:53:09 <gentauro> Athas: well n .&. 31 shouldn't be expensive in any (decent) language
23:53:11 <cocreature> but converting invalid indices into some arbitrary index in range is just not a good idea
23:53:29 <Athas> gentauro: no, but neither is (if n < k then error "no" else ...).
23:53:32 <nshepperd> anyway, I think it's a bad habit not just in programming but in thinking in general to go around saying "X is just Y" or "everything is Y" any time X and Y have some similarity or equivalence
23:54:17 <nshepperd> if you have different mental buckets for things that are different but have some equivalence, you can observe this equivalence and be better off for it
23:54:32 <dminuoso> nshepperd: There may be various reasons for this. Trying to change the topic, trying to imprint your belief how the world _really_ works onto someone else.
23:54:42 <dminuoso> Or maybe you are trying to argue for something, so you assume a different model.
23:54:45 <gentauro> it looks like glguy should help the people from hakyll out on their channel
23:54:57 <gentauro> I asked a question and somebody is posting a "penis bird"
23:54:58 <gentauro> :|
23:55:02 <Athas> nshepperd: yes, I agree.  I was originally provoked because Haskell itself documents Data.Array as "which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers", which I always found pretty amusing.
23:55:03 <nshepperd> if you try to put things that are actually different in the same mental bucket, you just end up confusing yourself
23:55:14 <gentauro> (or is just the level of #hakyll?)
23:56:00 <dminuoso> "Look, the category of Vect_k is just Set.. so let's stop calling it vector spaces over K and call it category of sets"
23:56:11 <Athas> gentauro: I use Hakyll for my website, and I don't think I ever had to involve birds or my penis.  (It's probably just the spambots.)
23:56:29 <gentauro> Athas: :(
23:57:09 <glguy> Unfortunately (?) my power is limited
23:57:11 <gentauro> Athas: don't you find it annoying that Hakyll requires all your web content to be placed in the root folder mixed with all the Haskell stuff?
23:57:29 <Athas> gentauro: does it?  You can put things in subfolders.
23:57:33 <gentauro> (that's actually my question in haskyll)
23:57:49 <gentauro> Athas: yeah, but then you output is : /sub_folder/index
23:57:54 <gentauro> Athas: yeah, but then you output is : /sub_folder/index.html
23:57:58 <Athas> gentauro: not if you add a custom route.
23:58:01 <gentauro> which I find quite annoying
23:58:45 <Athas> When you call 'route' you can just pass whatever.
23:58:48 <gentauro> Athas: right now I'm just using `route idRoute`
23:58:56 <Athas> Yeah.  Don't do that, then.
23:59:39 <Athas> I think a gsubRoute may be the easiest way to strip a leading directory.
23:59:55 <gentauro> Athas: so I should just call it with a static value like: `route "index.html"`
