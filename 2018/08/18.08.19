00:00:12 <maerwald> Gtk is not a framework
00:02:13 <mniip> 'toolkit' is close enough to a framework
00:02:20 <maerwald> nah
00:02:49 <maerwald> if you've used Gtk, you would never compare it to a framework. It's way too raw for that.
00:03:26 <chessandgo> its not raw unless your on the framebuffer
00:05:22 <mniip> maerwald, it's frameworky enough for my taste
00:05:54 <chessandgo> if youre not using a unikernel, its too much framework for m taste
00:06:54 <maerwald> whatever, to answer your question: I would look for libraries that solve the problems, not a single framework that solves all of them at once and 1000 others things I don't care about
00:07:21 <maerwald> writing libraries is something people have forgotten, while being obsessed with frameworks
00:08:03 <maerwald> so I can't answer your question, because I don't approach my problems that way
00:09:00 <Ke> maerwald: tbh haskell people seem to be the among the worst container zombies
00:09:26 <maerwald> yeah, sometimes
00:10:30 <chessandgo> "container zombies">
00:10:31 <chessandgo> ?
00:10:31 <maerwald> IMO, haskell is very well suited for writing idiomatic small libraries
00:11:03 <maerwald> the only problem is that the ecosystem doesn't really settle for one way of expressing effects, so libraries may or may not be well composable
00:11:39 <maerwald> which is why I'm still thinking an effects system outside of the type system would make sense, because then the burden of effects being composable is not on the types anymore
00:12:16 <maerwald> and there is also only one way of expressing effects
00:12:17 <maerwald> simple
00:12:27 <Ke> some people claim that too small libraries are the problem, as you may not rely on them being worth packaging or maintaining
00:13:27 <ArahaelPi> Ke: So we won't see the likes of LeftPad in haskell? :)
00:13:30 <Ke> chessandgo: it's a vague term in scale from program to app
00:14:21 <chessandgo> ah
00:14:42 <chessandgo> LeftPad as an anonmouse service/function
00:14:45 <mniip> one of the few strong sides of haskell package management is that nearly anyone can publish a library
00:14:48 <Ke> chessandgo: there is a definitely a cultural swith with things like containers and microservices, community package managers and distro packaging like nix
00:14:50 <mniip> even if it's just 1.5 functions
00:15:25 <mniip> *and* at the same time a lot of must-have libraries aren't installed by default
00:15:25 <Ke> ArahaelPi: I think we do have libs like that laready
00:15:32 <mniip> so people are introduced to package management anyway
00:15:55 <mniip> so when you publish your library you know you are on a sort of level playing field with things like mtl
00:16:25 <mniip> hmm, maybe not mtl, is it a boot package?
00:16:44 <mniip> lens is a better example then
00:16:53 <Ke> mniip: in pov of traditional distro you are not, since the person using your lib has to embed for distribution
00:17:21 <chessandgo> nixOS does look like a great distro
00:17:25 <Ke> mniip: I guess you know, what chromium repo looks like with all its submodules
00:17:28 <chessandgo> however Gentoo currently has my heart
00:17:48 <maerwald> chessandgo: lol
00:18:01 <Ke> chessandgo: Gentoo and Nixos are absolute on the opposite sides of this debate
00:18:27 <MarcelineVQ> why have the debate
00:18:50 <Ke> well they might not care, but they are subscribing to a philosophy
00:19:10 <Ke> obviously not everyone can have their way everywhere
00:19:22 <chessandgo> I like my compiling and useflags
00:19:33 <chessandgo> and would hate to have to set up my custom initramfs again
00:22:04 <Ke> it's one of those set up once run everywhere
00:23:40 <Ke> new philosophy is the thing that denies me cool things like brow.sh and riotweb without setting up additional software sources
00:23:51 <chessandgo> how is brow.sh
00:23:55 <chessandgo> I like my w3m
00:23:58 <chessandgo> its a good browser
00:24:29 <Ke> w3m can't do google play music
00:25:07 <chessandgo> i just play music with cmus locally, or mpv with youtube-dl, but to each their own
00:28:56 <taumuon> is nixOS like a linux built on a package manager like npm or stack?  You can put together a whole system with a config file?
00:29:42 <chessandgo> *most* linux distros are built on a package manager
00:29:55 <MarcelineVQ> sounds like a reasonable description, the guys over at #nixos could explain it best
00:29:57 <chessandgo> its the specific declarative nature of their package manager that makes it differenet
00:31:12 <taumuon> i see
00:31:56 <chessandgo> most package managers are like procedural programming, they just mutate the state of your distro
00:32:34 <maerwald> NixOS and gentoo are OT
00:32:37 <chessandgo> nixOS is declaring what packages are installed, and can have multiple  versions installed side by side based on content (intead of upgrading in place)
00:33:25 <chessandgo> the NixOS team is pretty good
00:33:35 <maerwald> this channel is about haskell
01:04:52 --- mode: glguy set +v emacstheviking
01:07:25 <emacstheviking> Having an issue with point free style! I am getting to grips with System.Random (writing a simple game with SDL2) and I came up with this,   rndNum range = getStdRandom (randomR range)    but when I tried to convert it to point free I hit an error as no type information is available, I am calling it like this    rndNum (0::CInt, 800)
01:14:02 --- mode: glguy set +v emacstheviking_
01:14:16 <lyxia> give rndNum a signature
01:14:25 <emacstheviking_> rndNum range = getStdRandom (randomR range)
01:14:33 <emacstheviking_> but it won't know the type in the range and complains!
01:14:58 <emacstheviking_> DOH! Too early on a Sunday ...thanks!
01:15:45 <emacstheviking_> How will that make it work thought...I wanted to pass a rang ein like this (1, 10::Int) or (0, 799::CInt) ...
01:15:56 <emacstheviking_> ir not fixed in the signature
01:15:56 <lyxia> if you write it  rndNum = getStdRandom . randomR you hit the monomorphism restriction
01:16:16 <emacstheviking_> lyxia: heard of that, don't fully grok
01:17:02 <emacstheviking_> Reading the page on the haskell wiki about it.
01:17:13 <lyxia> what that means is that if there are no arguments, rndNum will not be inferred to be polymorphic
01:17:36 <lyxia> and so using it both at type Int and CInt will be an error
01:18:00 <emacstheviking_> Makes sense given Haskells nature!
01:18:15 <emacstheviking_> I know there is a LANGUAGE setting to disable it but is that *wise* ???
01:18:22 <lyxia> no it's not
01:18:26 <emacstheviking_> I already have the OverloadedStrings one for working with SDL
01:18:48 <emacstheviking_> I didn't think so. Can yo apply it to just one function in a separate file then make it a module??
01:19:38 <lyxia> add a signature, or add at least one explicit argument, if you want a polymorphic definition
01:20:26 <lyxia> you can diaable it with NoMonomorphismRestriction if you really want
01:20:59 <emacstheviking_> If I put my function in a module all on its own with NoMono...Res.... then only that function is affected?
01:21:06 <lyxia> yes
01:21:35 <emacstheviking_> Great. OK, thanks....off to read up everything on MonoRes and get on with it
01:21:40 <emacstheviking_> thanks again list!! :) 
01:21:49 <lyxia> it's really a local extension, it doesn't affect users of that function in any way
01:37:42 * hackage fromhtml 1.0.1 - Simple adapter for transformation of HTML to other formats  http://hackage.haskell.org/package/fromhtml-1.0.1 (MarekSuchanek)
02:24:40 <dataN> not sure why this wont resolve the tag; https://lpaste.net/7716845488221192192
02:40:43 * hackage hw-simd 0.1.1.1 - SIMD library  http://hackage.haskell.org/package/hw-simd-0.1.1.1 (haskellworks)
02:56:39 <dataN> even this fails to compile; https://lpaste.net/8077722264067375104
02:56:56 <dataN> despite the instance appearing to be available...
02:57:59 <dataN> ok, sorry that last paste was wrong, nvm
03:02:32 <dataN> so this is the most simple form of the error; https://lpaste.net/1533313310470963200
03:07:32 <fweht> i just try to read 'Notions of computation and monads', can someone tell me what a continuation is?  i tried to understand the wikipedia definition but couldnt match it up with the context: https://i.imgur.com/ZuMWlVv.png
03:08:48 --- mode: glguy set +v noob
03:09:29 <noob> What's the best way to get the haskell-ide-engine working on Antergos/Arch?
03:10:02 <cocreature> fweht: R^(R^A) is a different notation for (A -> R) -> R which should look familiar if you know about continuations
03:10:25 <lavalike> fweht: A^B is like B -> A, so R^(R^A) is (A->R)->R
03:15:01 <lavalike> :t curry
03:15:02 <lambdabot> ((a, b) -> c) -> a -> b -> c
03:15:13 <lavalike> C^(A*B) = (C^B)^A
03:19:43 * hackage http2-client 0.8.0.1 - A native HTTP2 client library.  http://hackage.haskell.org/package/http2-client-0.8.0.1 (LucasDiCioccio)
03:30:40 --- mode: glguy set +v khilan
03:30:57 <khilan> Hello! Can someone plz help me with the type error in <https://gist.github.com/khilanravani/1287d3b08bbdb1bc37e8034581b45158> ?
03:33:42 <maerwald> forall arr e cs . ( MArray arr Y Double, IP.Array arr Y Double, IP.Array arr Y Word16, MArray arr Y Word16, Array arr X Double, Array arr RGB Double, Array arr X Bit, Array arr X Word16)
03:33:45 <maerwald> errr, what
03:36:14 <khilan> maerwald: sorry, I didn't quite understand. Is it not the correct way?
03:36:54 <cocreature> khilan: what makes you think that toVector gives you back "Manifest arr"?
03:37:59 <khilan> cocreature: No, I know it doesn't. I'm sorry I just wanted to show that I'm trying to get something like that.
03:38:32 <cocreature> if you know that it doesnâ€™t give you back a Manifest then you already seem to have figured out why you are getting the error?
03:39:13 * hackage http2-client-exe 0.1.0.0 - A command-line http2 client.  http://hackage.haskell.org/package/http2-client-exe-0.1.0.0 (LucasDiCioccio)
03:39:21 <khilan> cocreature: yes actually, I'm looking for a type that I can use to convert to manifest.
03:42:35 <cocreature> sounds like you might be looking for toManifest
03:44:29 <khilan> cocreature: yes but I couldn't find that
03:45:13 <khilan> cocreature: Oh sorry wait
03:45:45 <cocreature> itâ€™s directly above toVector https://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image-Interface.html#v:toManifest
03:45:57 <dataN> ok, got tag working, but there something like a bug; https://lpaste.net/8956485139903283200
03:46:10 <dataN> there is a description of it in the paste
03:47:16 <khilan> cocreature: yes, I'm sorry I don't know why I was looking for that in Hoogle! Although, I'm getting the same kind of error message
03:48:29 <cocreature> khilan: take a look at the types, toManifest doesnâ€™t give you back a "Manifest arr", it gives you back an "Image (Manifest arr) cs e
03:48:32 <cocreature> "
03:48:56 <cocreature> Iâ€™ve never used hip so Iâ€™m not sure if "Image arr cs e -> Manifest arr" even makes sense
03:49:25 <cocreature> and from your paste itâ€™s impossible to see why you think you need these since sobelX/sobelY are unused
03:50:18 <khilan> cocreature: yes, I noticed that after you pointed it out. No, this is the first part of the code. There is a lot more computation after that :-)
03:51:09 <dataN> has it set up some way to navigate the constraint inference which breaks in unexpected ways without reasonable error messages!?
03:52:55 <dataN> there was even a runtime error! :o
03:55:19 <sm> morning all. I have Transaction and Posting types, each referencing values of the other. I'd like to use the default Show instances for both, except modified to not recurse forever. And it's a bit hard to define custom show functions down here in Types.hs. Any suggestions ?
04:00:12 <dataN> might mean that there is something is wrong somewhere, and its stopping some generalisations so it would be good to understand and fix
04:00:43 <cocreature> sm: I would probably just -ddump-deriv the default implementation, copy & paste it into the source file and modify it as desired
04:03:27 <sm> cocreature: good idea, thanks
04:05:19 <sm> wow, interesting 
04:15:13 <aranea-> Hi there! Quick question: I'm writing an attoparsec parser. How can I apply one of the predefined parsers (hexadecimal in this case) to just the next two bytes of input?
04:16:01 <aranea-> I haven't used Haskell for a couple years, and I've forgotten awfully much about it.
04:16:52 <dataN> aranea-: do you mean something like (x1:x2:xs) ?
04:18:14 <dataN> :t take
04:18:15 <lambdabot> Int -> [a] -> [a]
04:19:14 <dataN> as fmap would require all the element change type together 
04:19:19 <aranea-> No, I'm writing an attoparsec parser in a long "do" block. I could do "value <- hexadecimal", but that'd consume more input than I want.
04:19:56 <aranea-> I'm wondering if there's some parser combinator that'll restrict hexadecimal to consume at most two bytes.
04:19:58 <dataN> x <- y >>= ... ?
04:20:08 <dataN> oh right... nvm
04:21:26 <liste> aranea-: fmap/lift "hexadecimal" over a parser that consumes 2 bytes
04:21:46 <liste> though not sure if it type checks as is
04:22:09 <aranea-> I could write my own hex parser that consumes two bytes at a time and then run it repeatedly with count, of course.
04:23:20 <aranea-> Can't fmap it.
04:23:25 <aranea-> :t hexadecimal
04:23:26 <lambdabot> error: Variable not in scope: hexadecimal
04:23:47 <aranea-> Well, anyway, it's "Integral a => Parser a".
04:24:17 <aranea-> So, not a pure function, but a monadic "value".
04:29:43 * hackage cabal2nix 2.11 - Convert Cabal files into Nix build instructions.  http://hackage.haskell.org/package/cabal2nix-2.11 (PeterSimons)
04:31:13 * hackage wai-extra 3.0.24.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.24.2 (MichaelSnoyman)
04:33:27 <dataN_> aranea: can you use advance? 
04:33:28 <dataN_> there is http://hackage.haskell.org/package/attoparsec-0.13.2.2/docs/src/Data.Attoparsec.ByteString.Internal.html#advance
04:34:26 <maerwald> tdammers is hard to catch these days
04:34:42 <maerwald> maybe it's the timezone
04:35:00 <dataN_> any help with this? https://lpaste.net/8956485139903283200
04:36:48 <aranea-> dataN_: I think advance just consumes the input and discards it? Anyway, thanks for your help, I'll just write my own hex parser.
04:44:42 * hackage mackerel-client 0.2.0 - An API client library for Mackerel  http://hackage.haskell.org/package/mackerel-client-0.2.0 (itchyny)
04:50:38 <dataN_> hmm Next_Tag seems to be fixing 'p' in a way that; 'instance Tag (p :: k) a => Exists a where 10  is = tag @p' could not.
04:51:05 <dataN_> oh, that "10" is a line number from the paste.
04:51:20 <dataN_> ok, convinced its working as expected now.
04:56:06 <coldpresent> why does `f m x = case Map.lookup x m of { Nothing -> Map.insert x 1 m; Just k -> Map.adjust (+1) k m }
04:56:25 <coldpresent> have type `f :: (Ord a, Num a) => Map.Map a a -> a -> Map.Map a a`?
04:56:46 <coldpresent> i would expect the type to have `Map.Map a Int` instead, since the value is always an integer
04:57:19 <liste> :t 1 -- coldpresent 
04:57:20 <lambdabot> Num p => p
04:57:44 <liste> that's not an integer
04:57:50 <liste> > 1 :: Double
04:57:52 <lambdabot>  1.0
04:58:00 <dataN_> here is a working example; https://lpaste.net/2194657275266727936
05:03:17 <dataN_> the style is to define classes as synonyms of Exists, and to use tag to distinguish between various classes defined by functions of the same type. 
05:03:30 <dataN_> Tag*
05:05:11 <dataN_> which is just the addition of a phantom parameter which can be passed the "newclass" version of the constraint synonym 
05:06:03 <coldpresent> ah, there was a bigger issue with the logic in my function
05:07:10 <coldpresent> replace with `Map.adjust (+1) x m`, then the types make sense
05:07:12 <coldpresent> thanks guys
05:16:31 <ancarda> Is there a Haskell package that is similar to Go's `context` package?
05:24:44 <dataN_> ancarda: is that similar to Debug.Trace? 
05:24:50 <c_wraith> ancarda: the async package does a lot of that.
05:25:29 <c_wraith> ancarda: but nothing ties all of those things together
05:25:59 <ancarda> dataN_: No, `context` is likely a lot closer to c_wraith's `async` package; it's for sending signals around your program. It's quite useful for graceful shutdowns and request timeouts
05:26:08 <ancarda> I use it a lot in Go, and I'm really missing it in Haskell :(
05:27:34 <dataN_> whats the similarity between logging and concurrency? 
05:28:06 <dataN_> or is that not the desired use case?
05:28:58 <c_wraith> why do you think context has anything to do with logging?
05:29:25 <dataN_> apparently it has nothing to do with logging! my mistake
05:29:59 <ancarda> dataN_: It's not for logging. Example usecase might be: I have a TCP server running and I want to gracefully shutdown. The server can `select` over `<-ctx.Done` and some channel receiving TCP connections. When I end the context from another thread, it'll cause `Done` to immediately return, and I can stop listening
05:30:22 <ancarda> There could be something similar for any open connections, they could also check `ctx.Done` when is appropriate, and then cleanup and return
05:30:49 <c_wraith> ultimately, async solves all the same problems.  but how you use it is very different
05:32:03 <ancarda> Do you know if it also solves the issue that `Network.Simple.TCP`'s `serve` function seems to catch POSIX signals? I can't seem to catch SIGTERM and do a graceful shutdown even if I wanted to :/
05:32:43 <ancarda> Although, that may be my fault for doing something wrong
05:36:02 <ancarda> c_wraith: By the way, I'm not really using `forkIO` much -- the TCP server runs on the main thread. It's just from the SIGTERM handler, I don't know of a way to get it to stop running `serve`
05:36:31 <c_wraith> doesn't look like that library interacts with signals at all
05:36:45 <c_wraith> so you're getting the default signal handler, which is "raise an exception in the main thread"
05:38:14 <ancarda> Yeah, that makes some sense. I setup my own on main: `_ <- installHandler keyboardSignal (Catch $ killApplication ctx) Nothing` which then causes `Network.Simple.TCP.serve: Synchronous exception accepting connection: ExitSuccess` to appear on the terminal
05:38:18 <c_wraith> if you want your own handler, you need to use System.Posix.Signals from the unix package to add it
05:40:22 <ancarda> c_wraith: From `killApplication`, I call `throwTo mainThreadId ExitSuccess` to end -- is that correct?
05:40:55 <ancarda> I suspect it's my own fault I'm catching `ExitSuccess` and it can't exit
05:51:25 <glguy> ancarda: if your goal is to wait on multiple channels, STM is great
05:52:42 <ancarda> glguy: With `TChan`? I havenâ€™t looked into STM yet, though I am going to soon
06:00:45 --- mode: glguy set +v val_
06:01:49 <val_> i have a datatype {Ok :: String, Default}
06:02:10 <val_> and i need to make optparse-applicative for the type
06:02:52 <val_> if it's ok i should return fmap Ok $ strOption (...)
06:02:58 <val_> otherwise Defaul value
06:03:10 <val_> is anyone here?
06:03:51 <mniip> I don't understand that syntax
06:03:55 <val_> hi!
06:03:59 <val_> So
06:04:00 <mniip> data D = Ok String | Default ?
06:04:08 <val_> yes
06:04:13 <mniip> that's not how you write it
06:04:34 <mniip> you're looking for
06:04:41 <mniip> (Ok <$> ...) <|> pure Default
06:05:01 <val_> oh, that pure thing should help
06:05:10 <val_> thx!
06:05:13 <mniip> :t pure
06:05:13 <Clint> or use Maybe String instead
06:05:14 <lambdabot> Applicative f => a -> f a
06:05:37 <mniip> yeah, if you have Maybe String there's a prepackaged function in .Applicative
06:05:39 <mniip> :t optional
06:05:40 <lambdabot> Alternative f => f a -> f (Maybe a)
06:05:58 <mniip> (optional ...) is literally what you're looking for
06:12:05 <ChaiTRex> How do I import this package: https://hackage.haskell.org/package/ghc-8.4.3/docs/Platform.html ?
06:12:32 <ChaiTRex> Sorry, module
06:14:08 <ChaiTRex> I get 'It is not a module in the current program, or in any known package.'
06:15:07 <hpc> you're on that version of ghc?
06:15:43 <hpc> you should get something like It is a member of the hidden package â€˜ghc-8.0.2â€™.
06:15:57 <ChaiTRex> 8.4.3
06:16:05 <hpc> hmm, odd
06:16:59 <hpc> can you run ghc-pkg dump | grep 'name: ghc' -A30
06:17:53 <hpc> er
06:17:55 <hpc> can you run ghc-pkg dump | grep 'name: ghc$' -A30
06:18:26 <hpc> on my machine it finds the package and in the middle it says 'exposed: False'
06:19:13 <ChaiTRex> It's there. I think I found the answer. I need -package ghc
06:19:16 <mniip> so the question from #haskell-beginners has left me thinking
06:19:24 <mniip> here's somewhat of a challenge
06:19:28 <mniip> :t gfoldl
06:19:29 <lambdabot> Data a => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
06:19:32 <mniip> :t gunfold
06:19:33 <lambdabot> Data a => (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
06:19:55 <mniip> write out a deeply recursive gcast :: (Data a, Data b) => a -> b
06:20:42 <ChaiTRex> Is it possible to have -package ghc in OPTIONS_GHC? I get unknown flag in  {-# OPTIONS_GHC #-} pragma: ghc
06:21:02 <mniip> you'd want to collect the subparts into a heterogeneous list using gfoldl, and then turn the list into the new object using gunfold, while recursively gcasting each component
06:21:23 <mniip> but both gfoldl and gunfold are left-associative so the list has to be reversed in the middle, which I hate
06:22:02 <mniip> wondering if there's a single datatype that I could use in place of 'c' in both of those functions to go directly  a -> b
06:22:41 <mniip> at first I thought I could construct a consumer with gunfold first and then pass it to gfoldl to fill in the blanks but that approach turned out to be flawed as gfoldl returns 'c a' not 'c b'
06:23:04 <mniip> so one definitely needs to gfoldl first
06:23:49 <mniip> does church encoding allow easy snocing?
06:24:10 <mniip> :t \x xs -> \z c -> xs (c x z) c
06:24:11 <lambdabot> t1 -> (t2 -> (t1 -> t3 -> t2) -> t4) -> t3 -> (t1 -> t3 -> t2) -> t4
06:24:24 <mniip> seems like it
06:24:51 <mniip> oh actually that's probably ideal
06:29:09 <mniip> oh
06:29:17 <mniip> might not be possible in terms of the same type
06:30:18 <dataN> polytag! https://lpaste.net/2557562589936615424
06:30:24 <ChaiTRex> join #haskell-beginners
06:30:32 <ChaiTRex> Sorry
06:31:48 <mniip> unless
06:32:57 <mniip> yeah right, gfoldl and gunfold just want different types of things to be the parameter
06:34:21 <mniip> gfoldl wants to end with what we're consuming (c a), gunfold wants to start with the constructor type
06:34:32 <mniip> (c (A -> B -> ... T))
06:49:09 <mniip> how do I uncons a church-encoded list?
06:51:44 <mniip> :t \xs -> xs Nothing (\x r -> Just (x, maybe [] (uncurry (:)) r))
06:51:45 <lambdabot> (Maybe a1 -> (a2 -> Maybe (a3, [a3]) -> Maybe (a2, [a3])) -> t) -> t
06:51:47 <mniip> messy
06:52:44 <mniip> but scott encoding doesn't snoc so easily
06:54:12 <dataN> yeah snoc lists! 
06:55:14 <mniip> dataN, I need snoc and uncons
06:55:17 <mniip> or cons and unsnoc
06:56:56 <dataN> :: f a -> Maybe (Maybe (f a) -> f a,Maybe (f a)) ?
06:58:43 * hackage corecursive-main 0.1.0.0 - Write your main like it can call itself back.  http://hackage.haskell.org/package/corecursive-main-0.1.0.0 (LucasDiCioccio)
06:58:56 <dataN> proablably not...
06:59:49 <dataN> what about; 'f a -> (Maybe (f a) -> f a,Maybe (f a))' giving Next_T ([Maybe (f a) -> f a],Maybe (f a)) via StateS?
07:00:10 <dataN> rrg
07:01:08 <dataN> mniip: what have you got so far?
07:01:50 <mniip> an ugly hack that folds over Const (HeterogeneousListWithDataConstraints), and unfolds over State (HeterogeneousList...)
07:02:08 <mniip> data GList = GNil | forall d. Data d => GCons d GList
07:02:09 <mniip> dcast :: (Data a, Data b) => a -> b; dcast x = evalState (gunfold unfolduncons pure (toConstr x)) $ getConst $ gfoldl (\(Const h) x -> Const (GCons x h)) (\_ -> Const GNil) x where unfolduncons m = get >>= \case GNil -> error "Not enough fields"; GCons x xs -> do put xs; ($ dcast x) <$> m
07:04:47 <dataN> so whats the problem? the fact your difference list is backwards?
07:11:33 <mniip> int-e, 1534687842 [17:10:42] <lambdabot>  Parse failed: DefaultSignatures language extension is not enabled. Please ad...
07:11:38 <mniip> int-e: please ad
07:11:55 <dataN> what about a verticle Zipper over a partition tree, that would help speed up the reverse
07:12:22 <mniip> dataN, this isn't a question of choice of an efficient data structure
07:12:32 <mniip> rather just something elegant in the types sense
07:12:45 <dataN> assuming the middle was accessed less frequently than the alternating calls to head and last
07:13:31 <dataN> (having to resize or remove the internal segments)
07:14:30 <dataN> :t reverse
07:14:32 <lambdabot> [a] -> [a]
07:15:18 <dataN> the constraint on that should be Traversable?
07:16:58 <dataN> whats up with the types?
07:17:16 <dataN> Data?
07:18:55 <dataN> Generics!?
07:19:03 <dataN> oh no
07:19:43 <dataN> is there motivation for this? 
07:20:37 <dataN> biplate travesals?
07:21:23 <dataN> scrap your zippers?
07:23:55 <dataN> isnt the point that by indicating the shape of the structure as is required by Traversable, that optimisations from structured access become available?
07:25:48 <dataN> doesnt "higher dimensional trees algebraicly" show there are more than 2 orthogonal zipper directions (infinitly many).
07:27:20 <ChaiTRex> Is there a way to convert a type-level Nat to a type-level Int?
07:28:02 <mniip> :t GHC.TypeLits.natVal -- ChaiTRex
07:28:03 <lambdabot> GHC.TypeNats.KnownNat n => proxy n -> Integer
07:29:44 <ChaiTRex> Thanks.
07:30:22 <dataN> oh, you want to zip over monad transformer stacks or something but without having to store a type level list of types?
07:30:54 <dataN> kind of like a multi-typed version of Free?
07:31:31 <dataN> and to be able to commute the levels where lawful...
07:31:50 <dataN> no, cant help you there
07:43:52 <ocramz> hullo!
07:45:36 <ocramz> I have a bit of TH that populates a typeclass instance, is there a way to have `derive` use it?
07:47:52 <ocramz> I mean, the "deriving" clause
07:51:41 <MarcelineVQ> deriving for a newtype?
07:53:05 <ocramz> yes, deriving for either a newtype or data
07:54:01 <MarcelineVQ> asking because there's GeneralizedNewTypeDeriving   but for data I'm not sure I follow, if the TH populates the instance why do you need to derive it
07:54:54 <ocramz> just a matter of ergonomics
07:55:29 <ocramz> I'd like the package all the user needs into a single deriving clause
08:05:12 * hackage mvc 1.1.7 - Model-view-controller  http://hackage.haskell.org/package/mvc-1.1.7 (GabrielGonzalez)
08:06:13 * hackage cmark-sections 0.3.0.1 - Represent cmark-parsed Markdown as a tree of sections  http://hackage.haskell.org/package/cmark-sections-0.3.0.1 (Artyom)
08:06:25 <mniip> ocramz, I think if your splice returns Q [Decl], you can splice inside a 'where' clause of an instance
08:06:35 <mniip> or! you could make your splice outright output an instance
08:06:48 <mniip> $(deriveClass 'Type)
08:07:23 <mniip> otherwise no, you can't have "deriving" make use of that
08:07:56 <mniip> ocramz, does your TH do anything that Generic can't?
08:08:36 <mniip> functions, rankNtypes, gadts, looking up a name or other templating?
08:08:42 <ocramz> mniip my TH splice reifies the type and counts the number of constructors
08:08:54 <mniip> is that all it does?
08:08:58 <ocramz> so in my current understanding you can't do this with Generic
08:09:08 <mniip> you can count the number of constructors
08:09:31 <mniip> % :kind! Rep (Maybe Int)
08:09:32 <yahb> mniip: ; <interactive>:1:1: error: Not in scope: type constructor or class `Rep'
08:09:38 <mniip> % :kind! GHC.Generics.Rep (Maybe Int)
08:09:39 <yahb> mniip: GHC.Generics.Rep (Maybe Int) :: * -> *; = GHC.Generics.D1 ('GHC.Generics.MetaData "Maybe" "GHC.Maybe" "base" 'False) (GHC.Generics.C1 ('GHC.Generics.MetaCons "Nothing" 'GHC.Generics.PrefixI 'False) GHC.Generics.U1 GHC.Generics.:+: GHC.Generics.C1 ('GHC.Generics.MetaCons "Just" 'GHC.Generics.PrefixI 'False) (GHC.Generics.S1 ('GHC.Generics.MetaSel 'Nothing 'GHC.Generics.NoSourceUnpackedness 'GHC.Gene
08:09:48 <mniip> %% :kind! GHC.Generics.Rep (Maybe Int)
08:09:48 <yahb> mniip: http://qp.mniip.com/y/92
08:10:21 <mniip> you can count the number of :+:s and V1s that appear inside a D1 but outside of a C1
08:10:42 * hackage microlens-th 0.4.2.2 - Automatic generation of record lenses for microlens  http://hackage.haskell.org/package/microlens-th-0.4.2.2 (Artyom)
08:11:13 <mniip> perhaps, C1 should return 1, V1 should return 0, :+: should add, D1 should return the inner value untouched
08:11:18 <mniip> and that's about all instances you should have
08:11:43 * hackage microlens-ghc 0.4.9.1 - microlens + array, bytestring, containers, transformers  http://hackage.haskell.org/package/microlens-ghc-0.4.9.1 (Artyom)
08:13:02 <mniip> on the upper side, you can probably have functions in your type
08:14:31 <mniip> it will just be an argument to Rec0
08:14:35 <mniip> (K1 R)
08:15:17 <ocramz> mniip thanks but I'm not sure I follow completely
08:15:36 <ocramz> doesn't the Rep representation encode a specific value?
08:15:52 <mniip> Rep is a type
08:15:59 <mniip> a type family
08:16:06 <mniip> you don't need to use the from/to, just the type family
08:16:30 <ocramz> so I should provide (:+:), V1 etc instances for Rep?
08:16:34 <ocramz> Rep of my type
08:16:36 <mniip> no
08:17:22 <ocramz> sorry, mixed up. Let me rephrase
08:19:04 <ocramz> for each type a that has a Generic instance, there is a generic encoding Rep a
08:19:20 <ocramz> but I don't understand how to tear this representation apart
08:19:24 <ocramz> without using TH
08:21:18 <mniip> @let class Variants f where { variants :: proxy f -> Int }; instance Variants (M1 C m f) where { variants _ = 1 }; instance Variants V1 where { variants _ = 0 }; instance Variants f => Variants (M1 D m f) where { variants _ = variants (Proxy :: Proxy f) }; instance (Variants f, Variants g) => Variants (f :+: g) where { variants _ = variants (Proxy :: Proxy f) + variants (Proxy :: Proxy g) }
08:21:19 <lambdabot>  .L.hs:161:20: error:
08:21:19 <lambdabot>      Not in scope: type constructor or class â€˜M1â€™
08:21:19 <lambdabot>      Perhaps you meant one of these:
08:21:26 <mniip> @let import GHC.Generics
08:21:27 <lambdabot>  Defined.
08:21:28 <mniip> @let class Variants f where { variants :: proxy f -> Int }; instance Variants (M1 C m f) where { variants _ = 1 }; instance Variants V1 where { variants _ = 0 }; instance Variants f => Variants (M1 D m f) where { variants _ = variants (Proxy :: Proxy f) }; instance (Variants f, Variants g) => Variants (f :+: g) where { variants _ = variants (Proxy :: Proxy f) + variants (Proxy :: Proxy g) }
08:21:29 <lambdabot>  Defined.
08:22:04 <mniip> @let variants' :: forall a. (Generic a, Variants (Rep a)) => Proxy a -> Int; variants' _ = variants (Proxy :: Proxy (Rep a))
08:22:06 <lambdabot>  Defined.
08:22:18 <mniip> > variants' (Proxy :: Proxy Bool)
08:22:20 <lambdabot>  2
08:22:36 <mniip> > variants' (Proxy :: Proxy (Maybe (Either Bool Bool)))
08:22:38 <lambdabot>  2
08:22:46 <mniip> as you can see this only focuses on the outer type constructor
08:23:07 <mniip> > variants (Proxy :: Proxy Proxy)
08:23:09 <lambdabot>  error:
08:23:09 <lambdabot>      â€¢ No instance for (Variants Proxy) arising from a use of â€˜variantsâ€™
08:23:09 <lambdabot>      â€¢ In the expression: variants (Proxy :: Proxy Proxy)
08:23:13 <mniip> > variants' (Proxy :: Proxy Proxy)
08:23:15 <lambdabot>  error:
08:23:15 <lambdabot>      â€¢ Couldn't match type â€˜k0 -> *â€™ with â€˜*â€™
08:23:15 <lambdabot>        Expected type: Proxy Proxy
08:23:21 <mniip> ah right
08:23:27 <mniip> > variants' (Proxy :: Proxy (Proxy Proxy))
08:23:29 <lambdabot>  1
08:25:03 <ocramz> ah, I see now. Thanks mniip :)
08:26:04 <mniip> trying to find a more interesting example
08:28:02 <mniip> > variants' (Proxy :: Proxy GeneralCategory)
08:28:05 <lambdabot>  error:
08:28:05 <lambdabot>      â€¢ No instance for (Generic GeneralCategory)
08:28:05 <lambdabot>          arising from a use of â€˜variants'â€™
08:28:16 <mniip> @let deriving instance Generic GeneralCategory
08:28:18 <lambdabot>  Defined.
08:28:20 <mniip> > variants' (Proxy :: Proxy GeneralCategory)
08:28:22 <lambdabot>  30
08:28:35 <mniip> (Data.Char.GeneralCategory)
08:40:49 <ocramz> mniip does lambdabot start with a bunch of default extensions like KindSignatures, FlexibleInstances etc.?
08:41:02 <ocramz> the code you pasted above doesn't work without
08:42:48 <geekosaur> @where L.hs
08:42:48 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
08:42:59 <geekosaur> tl;dr: yes
08:43:23 <geekosaur> not sure about those specific ones but a lot of stuff is turned on by default
08:43:27 <mniip> ocramz, yes sure
08:43:35 <geekosaur> plus there's something of a common set people who do type hackery turn on by default
08:43:55 <ocramz> thanks geekosaur ^^
08:44:05 <mniip> DeriveGeneric, FlexibleInstances, FlexibleContexts, ScopedTypeVariables
08:44:27 <mniip> not that many really
08:56:12 <Ariakenom> default ((),Integer,Double) interesting
08:57:06 <Ariakenom> What's () for?
08:59:12 * hackage strelka 2.0.2.2 - A simple, flexible and composable web-router  http://hackage.haskell.org/package/strelka-2.0.2.2 (NikitaVolkov)
09:01:53 <geekosaur> mostly so you don't have to add type annotations when doing things with empty lists
09:02:02 <geekosaur> or e.g. Nothing
09:02:08 <geekosaur> (when you're not using the Just)
09:02:31 <geekosaur> so it quietly infers () instead of whining that you didn['t say what kind of empty value you wanted
09:03:27 <EvanR> > show ([] :: [Void])
09:03:30 <lambdabot>  "[]"
09:06:49 <ocramz> I've only begun to explore generic programming and it's super interesting what you can do with it
09:09:46 <Ariakenom> thanks geekosaur 
09:14:53 --- mode: glguy set +v gentauro
09:14:56 <gentauro> > length $ ([ undefined ] :: [ Void ])
09:14:59 <lambdabot>  1
09:15:03 <gentauro> ?
09:16:11 <gentauro> > voids = undefined : voids :: [ Void ]
09:16:13 <lambdabot>  <hint>:1:7: error:
09:16:13 <lambdabot>      parse error on input â€˜=â€™
09:16:13 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
09:16:23 <gentauro> % voids = undefined : voids :: [ Void ]
09:16:24 <yahb> gentauro: 
09:16:38 <gentauro> % length $ take 25 voids
09:16:39 <yahb> gentauro: 25
09:16:42 <gentauro> :|
09:16:56 <gentauro> I has a list of voids ...
09:17:01 <EvanR> undefined :: Void totally misses the point!
09:19:45 <gentauro> which is? 
09:20:04 <merijn> gentauro: That you cannot have non-bottom values of type Void
10:15:25 <davos> 7 ^ 80
10:17:41 <MarcelineVQ> well sure we have 7's, but do we have enough
10:18:43 <cocreature> 7^79 7s is quite a lot
10:27:46 <Ariakenom> > 7 ^ 80
10:27:49 <lambdabot>  40536215597144386832065866109016673800875222251012083746192454448001
10:32:07 <michalrus> Hmmmmmmm, I have a problem with DuplicateRecordFields and TypeFamilies. :o https://gist.github.com/michalrus/67fbf9be1a187677e1d6ffa5a7a7a09f
10:34:42 <mbwgh> In `data MyData = MyData { values :: ![Int]; count :: !Int }`, does the bang pattern for `values` amount to anything _more_ than just "doesn't throw on `null`, pattern match etc."? Would a bang for a lazy structure be in bad taste?
10:37:12 <geekosaur> it can count for things that improve space usage, although here I think that doesn't quite work (the list can't be unboxed into a MyData value because it has multiple constructors_
10:48:15 <mbwgh> geekosaur: Yeah I tried to give an example where one part would be clear (count, or any other "running total", accumulator etc.) and the other not as much. People seem to recommend "bang everything" in records, unless you have a reason not to. What are the "reasons not to"? Cyclic data structures? Anything with more than one constructor?
10:49:05 <geekosaur> the main reason to do it is to help produce better code when you know things are always defined and used strictly.
10:49:06 <nshepperd> I wouldn't bother marking a list field as strict 
10:49:41 <geekosaur> a reason not to do it is if you are using ti recursively, because excessive strictness could cause infinite loops / bottoms.
10:49:43 * hackage record-encode 0.1.0.0 - Generic encoding of records  http://hackage.haskell.org/package/record-encode-0.1.0.0 (ocramz)
10:50:11 <mbwgh> Ah, something like an AST type
10:50:13 <nshepperd> but i also don't really believe in strict'ing every field in a record
10:50:17 <geekosaur> in general, as nshepperd says, it's not very useful to make a list strict; you usually gain nothing from having just the first constructor be strict / "known"
10:51:15 <mbwgh> So, by not believing in this kind of rule of thumb, you mean don't bang types like Int either?
10:51:24 <geekosaur> occasionally strictness is useful when working with FFI stuff, since you have more control over when things get forced (otherwise there'll be a certain tendency for the FFI glue to do it, so it can ass definite things to C), but that's a bit of a reach
10:51:50 <geekosaur> Int is often worth inlining, but this is something of a "premature optimization" thing
10:52:25 <geekosaur> (marking it strict won't do so directly, but -funbox-strict-fields is iirc a default optimization)
10:52:42 <nshepperd> I add strictness for fields when I think it'll help
10:52:46 <mbwgh> But where is the harm? If you want to use the Int in any kind of situation, it has to be normalized
10:53:01 <mbwgh> Use = do more than pass around
10:53:31 <nshepperd> so if your Int is always used by anything that consumes the record, then it's a good idea
10:53:50 <geekosaur> ^
10:54:21 <geekosaur> with fields liek that, the question becomes "are you perhaps unnecessarily forcing a slow calculation that often isn't used?"
10:54:31 <geekosaur> which is one of the places where default-lazy is a win
10:55:11 <mbwgh> Could you clarify that? Doesn't every record become consumed in some way or the other? (I'm most likely missing something here...)
10:55:35 <mbwgh> Or are you referring to branching?
10:55:43 <geekosaur> the record as such may, but you may never do anything specific with a particular field in it
10:55:57 <geekosaur> in which case there is no reason for it to actually get calculated
10:56:57 <mbwgh> Ah ok. The record might be something I have no control over, like from a third-party package, yes
10:57:23 --- mode: glguy set +v joshsh
10:57:25 <nshepperd> something that eats a record doesn't necessarily look at every field
10:57:27 <joshsh> how can I realize this function:
10:57:30 <geekosaur> or you have control over it but it's collecting related data, not all of which is used for every use case
10:57:45 <joshsh> ioMaybe :: Maybe a -> (a -> IO b) -> IO (Maybe b)
10:58:43 * hackage record-encode 0.1.0.1 - Generic encoding of records  http://hackage.haskell.org/package/record-encode-0.1.0.1 (ocramz)
10:59:17 <mbwgh> So then the revised rule of thumb would become: "Bang fields which can only be pattern matched against by reducing to NF, and which are needed in each branch of execution"?
10:59:20 <MarcelineVQ> :t mapM
10:59:22 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
11:00:22 <mbwgh> Does that make sense?
11:00:24 <geekosaur> something like that. but, as I said, might still be "premature optimization". you miht well not see much difference in actual use cases unless pumping MB or GB of data through it
11:00:59 <dmrd> hey all, I'm using a type from a 3rd party library that implements `toList` (from Foldable). However, when I try to call `toList` on that type, I get a 'toList' not in scope. Anyone know what causes this? Also, happy Sunday :) 
11:01:13 <mbwgh> Does "premature optimization" actually apply when it's only one character in one place?
11:01:14 <merijn> dmrd: toList is not in the Prelude
11:01:31 <merijn> dmrd: You have to import it from Data.Foldable, I'm pretty sure
11:01:32 <joshsh> lambdabot, yes that is a more generic signature for my function. How can I materialize it?
11:01:55 <dmrd> merijn, oh silly me. I'll try that out :) Thanks in advance
11:02:03 <MarcelineVQ> joshsh: ah you want to write ioMaybe from scratch?
11:02:11 <mbwgh> If you're lazy, toList = foldr (:) []
11:02:59 <dmrd> merijn: it worked. Thanks <3 
11:03:13 <joshsh> I would prefer a built-in function, but I suspect there is a simple solution using monadic syntax
11:03:46 <MarcelineVQ> if you want a function aailable in prelude you may use mapM
11:03:58 <joshsh> looking harder at mapM, thanks
11:05:10 <joshsh> yes, that looks perfect. Thank you
11:06:06 <philippD> Can someone explain why the `(A a)` coudln't be deduced here? https://lpaste.net/6471646327791943680
11:06:29 <mbwgh> joshsh: If you are going to `flip` it, you may want Data.Traversable.for.
11:07:47 <joshsh> mbwgh, nice. Adding both of these to my toolbox
11:08:13 <mbwgh> philippD: Your instance says: "Given that a is an A, (B a) is also an A". So you are missing the "Given that a is an A" part in your function signature.
11:09:01 <mbwgh> philippD: No sorry. I meant "a is also a B".
11:09:28 <mbwgh> philippD: I think I didn't look at it hard enough
11:09:54 <philippD> mbwgh: Argh, you're right. Although the actual fix would be add the `(A a)` constraint to `B` class declaration
11:10:14 <philippD> +the
11:10:37 <mbwgh> philippD: Yes, I was totally gonna say that.
11:11:16 <mbwgh> joshsh: hlint does suggestions regarding already existing library functions
11:11:25 <joshsh> MarcelineVQ: works like a charm. Haskell, and #haskell, are awesome
11:12:01 <joshsh> mbwgh: oh cool
11:21:44 <mbwgh> I just noticed that lpaste was replaced by gist.github in /topic. Is there a major reason?
11:26:29 <cocreature> mbwgh: yes, the new lpaste is annoying :)
11:27:07 <nshepperd> i think people didn't like that lpaste doesn't have much features any more
11:27:52 <cocreature> itâ€™s not even about any fancy features, just copying the source of a paste is already really annoying in the new version
11:28:08 <cocreature> just copying copies too much and there is no link to the raw version
11:28:36 <cocreature> and github gists have a lot of useful features like multifile pastes, comments, â€¦
11:28:56 <mbwgh> Wasn't there something like hpaste as well?
11:30:13 <mbwgh> Maybe that is a question for when the github = microsoft apocalypse happens
11:31:10 <nshepperd> copying from lpaste seems to work now
11:31:56 <geekosaur> hpaste becmae lpaste but that was just a name change. a couple years later the then lpaste was replaced with the current annoying one
11:32:41 <cocreature> nshepperd: still seems to copy the line numbers as well
11:33:10 <nshepperd> it does? huh, it works fine in chrome
11:33:27 <nshepperd> the line numbers have user-select: none;
11:33:55 <cocreature> doesnâ€™t seem to work in firefox
11:34:04 <nshepperd> sad
11:37:19 <madnight> https://www.reddit.com/r/haskell/comments/862k28/looking_for_new_maintainer_of_lpastenet/
11:40:22 <mbwgh> Man, this page sucks now. Since it's just a table, it should be easy to whip something up with scalpel so in theory you can still use it. Or a one-liner in the console, but I can't javascript
11:40:58 <nshepperd> what the heck, it works with -moz-user-select, but not user-select
11:41:16 <dmrd> Hey folks, sorry to interrupt but I've been looking at type-signatures for a couple days trying to figure this one out. Simply put, I have a recursive data type with multiple constructors and want to traverse down its components as I construct a list of all its sub-components that match a specific constructor. How would you do this? This data type has an instance of Foldable, Functor and Traversal and I feel like these should
11:41:16 <dmrd> enable me to complete this task. Any hints? Hope the explanation made sense :p 
11:41:31 <nshepperd> but the compatibility table claims user-select is supported since 2013
11:42:58 <c_wraith> dmrd: you can certainly do that with Foldable
11:43:48 <c_wraith> dmrd: foldMap matchingFunction where matchingFunction returns [Foo] on the correct constructor and [] otherwise
11:45:13 <dmrd> c_wraith: I have had intuition, but looking at the type-signatures in foldable, they always seem to throw away the computational context (maybe I'm using the wrong vocab here), which I figure prevents me from checking against their type constructor? I'm gonna give your suggestion some thought for a little while. Thank you
11:45:41 <c_wraith> > foldMap f [Right 10, Left 83, Right 22, Left 1] where f (Left _) = [] ; f x@(Right _) = [x]
11:45:44 <lambdabot>  <hint>:1:49: error: parse error on input â€˜whereâ€™
11:45:44 <mbwgh> nshepperd: Where does -moz-user-select show up for you?
11:46:03 <c_wraith> > let f (Left _) = [] ; f x@(Right _) = [x] in foldMap f [Right 10, Left 83, Right 22, Left 1] 
11:46:06 <lambdabot>  [Right 10,Right 22]
11:46:10 <ChaiTRex> c_wraith: Does that work recursively?
11:46:20 <nshepperd> mbwgh: i manually added it to the css with developer tools to see if it works
11:46:32 <c_wraith> ChaiTRex: it looks at everything the Foldable instance targets
11:46:38 <ChaiTRex> Ahh, cool.
11:46:51 <ChaiTRex> Haven't really used Foldable yet.
11:47:13 <nshepperd> mbwgh: I'm gonna send a pull request on github to add it
11:48:35 <dmwit> c_wraith: I think maybe he's looking to discriminate between constructors of the container type, not constructors of the contained type.
11:48:44 <dmwit> Which Foldable will not let you do.
11:48:52 <c_wraith> dmwit: ah, I see.  Did miss that.
11:49:02 <c_wraith> None of those classes help with that, then.
11:49:04 <mbwgh> nshepperd: Is that -moz-user-select: all or text or ..?
11:49:34 <nshepperd> mbwgh: -moz-user-select: none; prevents selecting the line numbers on firefox
11:49:37 <dmwit> dmrd: It might be worth looking into Scrap Your Boilerplate or uniplate or biplate or Generics or one of these generic programming tools.
11:50:02 <mbwgh> aaah
11:50:09 <dmrd> c_wraith: 
11:50:13 <c_wraith> dmrd: yeah, what I did will miss.  Those classes don't help.
11:50:37 <c_wraith> dmrd: I'd go to lens's Plated class, but that's essentially the same thing dmwit is talking about.
11:50:40 <dmrd> c_wraith: yeah I think I didn't express myself correctly the first tyme around. dmwit got it right
11:50:57 <mbwgh> I forgot how accessors work :(
11:51:13 <mbwgh> But I get the idea
11:51:13 <dmrd> oh boy, venturing into lens for the first time. Will check those out. Thanks y'all 
11:51:33 <mbwgh> *selectors
11:51:41 <mbwgh> I'll show myself out
11:54:51 <nshepperd> I don't have much of a clue about accessors either, i just added it alongside the existing user-select property
11:56:07 <mbwgh> nshepperd: I didn't see such a property, which is why I asked
11:58:05 <nshepperd> oh
12:03:22 <ChaiTRex> Is there some way of testing in the type level whether a Nat would overflow an Int?
12:04:13 <ChaiTRex> Preferably without using CPP.
12:04:27 <glguy> http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-TypeNats.html#t:-60--61--63-
12:04:39 <glguy> And hard coding in the bound of Int
12:04:47 <ChaiTRex> Ahh, darn.
12:04:55 <ChaiTRex> I was hoping not to have to hard-code it.
12:05:24 <mbwgh> nshepperd: Maybe this is me being too stupid to use firefox, but shouldn't this rule show up in some <a href='#lineN'> element?
12:05:28 <ChaiTRex> I'll probably do that in the end, though.
12:05:41 <ChaiTRex> Thanks.
12:06:59 <mbwgh> nshepperd: Ah, it shows up in the style-editor, but not the inspector
12:07:44 <nshepperd> mbwgh: weird, it shows up in the inspector for me. i just right clicked on one of the line number links and selected 'inspect element'
12:09:12 * hackage safe-money 0.7 - Type-safe and lossless encoding and manipulation of money, fiatcurrencies, crypto currencies and precious metals.  http://hackage.haskell.org/package/safe-money-0.7 (RenzoCarbonara)
12:09:39 <mbwgh> nshepperd: Nope. But then I guess the fact that I actually use palemoon might become relevant at some point :)
12:10:13 * hackage safe-money-aeson 0.1 - Instances from the aeson library for the safe-money library.  http://hackage.haskell.org/package/safe-money-aeson-0.1 (RenzoCarbonara)
12:10:30 <mbwgh> That, or it's related to some addon.
12:10:53 <nshepperd> https://github.com/lpaste/lambda-paste/pull/3
12:11:00 <droplet> Can anyone direct me to where the Fractional instance for Double is defined?
12:11:13 * hackage safe-money-xmlbf 0.1, safe-money-serialise 0.1, safe-money-cereal 0.1 (RenzoCarbonara): https://qbin.io/talks-thongs-qu8s
12:12:12 * hackage safe-money-store 0.1 - Instances from the store library for the safe-money library.  http://hackage.haskell.org/package/safe-money-store-0.1 (RenzoCarbonara)
12:12:51 <cocreature> droplet: https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Float.hs#L500
12:13:16 <droplet> cocreature: thanks!
12:20:12 <c_wraith> dmrd: by the way, if lens is daunting (which is fair, it's *huge*), you might find it easier to just go with a single-purpose library like uniplate
12:21:40 <dmrd> c_wraith: thanks for the suggestion. I'll review them both and see what works best for my use case. I suspect uniplate might be enough
12:22:25 <c_wraith> dmrd: for what it's worth, I'm comfortable with lens and know the Plated class is what would make this work, I still had to spend 15 minutes going through the docs to find the correct combinator to use it the way you described. :)  (It's Control.Lens.Plated.cosmos)
12:24:12 <dmrd> c_wraith: haha I see. Noted! That'll be a time-saver
12:42:09 <kuribas> it's easier to start with microlens instead of lens.
12:42:18 <kuribas> it's compatible anyway, and has better docs
12:47:33 <pie__> erikd, hey, I just want to say thanks for working on/writing language-javascript!
12:54:43 <tomboy64> hmm. skylighting-core is masked, which in turn blocks pandoc and rstudio
12:54:50 <tomboy64> unfortunate this :D
12:55:33 <c_wraith> hmm.  Is there a way to get ghci to list what modules are imported if you've set the prompt to something else?
12:57:04 <cocreature> c_wraith: :show imports
12:57:16 <c_wraith> thanks
12:57:27 <cocreature> or :show modules depending on what exactly you want
12:57:47 <c_wraith> the latter isn't giving me any output.  don't know what that's about
12:58:14 <c_wraith> oh, I see.  It's for things loaded from source
12:58:27 <c_wraith> Yeah, I wanted imports.  Things loaded from packages.
12:59:47 <cocreature> iirc :show imports is a superset of :show modules
13:00:16 <c_wraith> If I remember how the ghc api works correctly, it doesn't *have* to be, but it's sort of useless to load a module and not import it.
13:00:29 <c_wraith> and I don't think ghci lets you do it, for that matter
13:01:04 <cocreature> hm, what happens if you do :add?
13:01:15 <c_wraith> never tried that.  Never knew it existed. :)
13:01:22 <dmrd> hey folks, one cannot force record syntax on types defined by a third party, or can you? I just find myself making lots of functions to get specific components of a container and it seems hacky
13:01:38 <c_wraith> correct, you cannot
13:01:48 <dmrd> sad
13:01:57 <cocreature> you can however yell at the maintainer to change things into a record ;)
13:03:06 <dmrd> haha, it seems to me that there should be a way to augment the definition of an imported data type. Maybe thru some more advanced tricks. But yeah, I won't worry about it for now
13:03:41 <c_wraith> I mean, just creating named accessors is roughly equivalent unless you want to use them to update too
13:20:46 <endojelly> Any good library to implement a CLI? I know I could just use the readline interface
13:20:52 <endojelly> but maybe there's something that does a bit more?
13:22:41 <lavalike> endojelly: CLI is a thing, readline (or haskeline) is another, hmm
13:23:05 <endojelly> lavalike, oh, it's actually called "CLI"? heh
13:23:23 <endojelly> and haskeline, is that a readline implementation in haskell? let me have a look.
13:23:43 <endojelly> haskeline looks good instead of readline already.
13:23:59 <lavalike> endojelly: many CLI tools don't have interpreters inside
13:24:34 <endojelly> lavalike, it looks like CLI in combination with haskeline could be good
13:24:38 <endojelly> on a very first look
13:25:09 <lavalike> people rave about optparse-applicative to do cli option parsing
13:30:43 * hackage ip 1.4.1 - Library for IP and MAC addresses  http://hackage.haskell.org/package/ip-1.4.1 (andrewthad)
13:38:03 <erisco> -
13:38:24 <erisco> +
13:38:34 <c_wraith> dmrd: https://lpaste.net/3043832387688464384  I threw together an example of using lens to do some constructor-dependent traversal of a json value.  This might convince you to use uniplate instead. :)
13:55:52 <dmrd> c_wraith: Checking it out right now!
14:01:21 <dmrd> c_wraith: oh wow, this is complicated yet very succinct.  Thank you for putting this together btw. I'm still looking into the semantics of lens and syb so I have yet to put it all together
14:01:39 <c_wraith> dmrd: that's a good description of any non-trivial use of lens. :)
14:02:21 <c_wraith> It's got a lot of concepts, but they're mostly orthogonal and compose together nicely.  So you have a lot of pieces to learn, but each one opens up a ton of additional things you can do.
14:05:21 <dmrd> c_wraith: yeah that's the feeling I get now that I'm diving "deep" into Haskell. It's funny though because my workflow will usually start with the question "huh, I wonder how to do X, let's google it!" and 15 minutes later I'm watching a YouTube video on category theory trying to wrap my head around some semantics. I know that may not be the case here, but I can definitely feel that it is a bit of a paradigm shift. Weird, feel
14:05:21 <dmrd> like I'm learning to code for the first time
14:07:38 <c_wraith> That's how I felt when learning Haskell.  2-3 months of "I thought I knew how to program", followed by about 6 months of "ok, so all those things I knew still apply, but I have to look at them from a different perspective", then finally "Ok, I have learned so much - and there's still so much more".  Been in that last phase for... uh...  10 years. :)
14:07:40 <dmj`> jb55: ping
14:10:32 <dolio> c_wraith: It doesn't get any better. :)
14:11:00 <c_wraith> dolio: what do you mean?  "There's still so much more to learn" is the ideal state. :)
14:12:33 <dolio> That's true.
14:12:45 <dolio> Maybe I meant, "It doesn't _get_ any better!"
14:12:59 <c_wraith> ah-ha!  that makes sense
14:26:08 <Ariakenom> dmrd: "I know that may not be the case here" I saw a blog post a few days ago tracing lens history to GÃ¶del :)
14:26:56 <dmrd> Ariakenom: oh really? I'd love to check that out actually. Still remember the rough title?
14:27:22 <c_wraith> https://julesh.com/2018/08/16/lenses-for-philosophers/
14:27:30 <c_wraith> That's the one
14:27:48 <dmrd> also c_wraith : yeah uniplate seems like the right tool for the job here. I read the example provided in the haskell wiki and it looks exactly like what I want. I'm still working thru some pesky errors but I feel I'm close
14:27:55 <dmrd> bookmarked
14:35:34 <erikd> pie__: i didn't write language-javascript, but i did take over maintanership when the original author becamse too busy and then made some improvements
14:36:01 <jb55> dmj`: sup?
14:36:57 <pie__> erikd, ah, well thanks anyway ;P
14:37:17 <erikd> no promblem :)
14:37:18 <pie__> erikd, is there an easy way to thank the oriinal author?
14:37:23 <pie__> (as well)
14:37:46 <erikd> alanz: ^^^
14:53:03 <dmrd> Continuing on the discussion on `uniplate`, it seems that its 'universe' function only flattens a structure to the extent of including all sub-sequences of constructors belonging to the data-type of the root, correct? I was hoping it would also flatten constructors not-belonging to that data type, if that makes sense
14:54:47 <pavonia> dmrd: What would be the return type in that case?
14:57:03 <endojelly> huh, was it not called liftIO?
14:57:42 <c_wraith> @index liftIO
14:57:42 <lambdabot> Control.Monad.IO.Class
14:58:48 <endojelly> c_wraith, ah, thanks
14:59:50 <dmrd> pavonia: you caught me there. Let me think about that. However, while I do that, I may help to be precise about what I'm trying to use. I'm using haskell-src-exts to parse haskell ASTs and I'm trying to "filter" out of them all instances of an identifier. So currently I'm working with a 'Decl' (declaration) data type and trying to recurse down until I find an instance of the Ident (identifier) constructor. However, the
14:59:50 <dmrd> Identifier constructor belongs to the name data type, not the Decl data type. If it helps, this is the definitions of Decl() <https://hackage.haskell.org/package/haskell-src-exts-1.20.2/docs/Language-Haskell-Exts-Syntax.html#t:Decl> and this is the definition of Name <https://hackage.haskell.org/package/haskell-src-exts-1.20.2/docs/Language-Haskell-Exts-Syntax.html#t:Name> . Universe gets me a little closer to that goal of
14:59:50 <dmrd> ending up with a list of only `Idents` but it's not quite there yet. Still investigating
15:04:25 <c_wraith> dmrd: I think you can do that with a series of mutually recursive functions, one for each constructor of Decl that can contain a Name.  Whenever they contain a Decl, they call the top function again.
15:04:27 <chessandgo> did stackage go down or something, im unable to create a new project
15:04:50 <chessandgo> "Unable to load cabal files for snapshot"
15:07:10 <dmrd> c_wraith: yeah that sounds right. Is there a shortcut on the docs that give a way of returning all constructors that can contain a Name? Else, I'll do the manual work, which is fine. Just checking if there's a clever way
15:07:28 <dmrd> asking since there may be multiple levels of nesting
15:08:39 <c_wraith> dmrd: You *might* be able to do something with Data.Data for that.  It has type-driven traversals.  I've never learned how to use them, though, and I'm not sure they actually would work here.
15:09:01 <dmrd> gotcha, will investigation. Thank so much
15:09:05 <dmrd> *investigate
15:13:43 * hackage record-encode 0.2 - Generic encoding of records  http://hackage.haskell.org/package/record-encode-0.2 (ocramz)
15:17:42 * hackage record-encode 0.2.1 - Generic encoding of records  http://hackage.haskell.org/package/record-encode-0.2.1 (ocramz)
15:46:28 <Squarism> anyone got a creative idea on how i could partly mock IO? With some detail https://lpaste.net/2294393420971507712 . How can I make "FixtureLogStateT String Int m" do real IO also?
15:46:43 * hackage xmobar 0.28 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.28 (JoseAntonioOrtegaRuiz)
15:48:42 * hackage safecopy-migrate 0.2.0 - Making SafeCopy migrations easier  http://hackage.haskell.org/package/safecopy-migrate-0.2.0 (Artyom)
15:54:22 <madnight> % :set -XNoMonoPatBinds
15:54:23 <yahb> madnight: 
16:02:14 <c_wraith> dmrd: https://lpaste.net/9166776784643948544  using the uniplate library
16:04:20 <Squarism> or.. lets say I have some ReaderT X with 6 or so type class instances, How can I remove a few? 
16:04:41 <Squarism> .../override a few. Skipping the idea of mocking completely
16:05:24 <geekosaur> newtype wrapper, deriving through the ones you want, then declare your own instances for the others
16:08:06 <Squarism> geekosaur, Using that approach, can reuse ones "already defined"? Like say the MonadDB typeclass has 30 methods. Can I just make the newtype use the one already defined for wrapped value?
16:08:19 <Squarism> can I reuse the ones..
16:08:35 <geekosaur> that's what you get when you derive through with GeneralizedNewtypeDeriving
16:09:36 <geekosaur> (except for the predefined derivable classes: Read, Show, Enum, Bounded, Eq, Ord)
16:11:12 <c_wraith> iirc, ghc recently added an option to tell it how to derive a class when there are multiple options
16:12:58 <c_wraith> yeah, https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/DerivingStrategies
16:14:04 <geekosaur> I'm not sure what the actual question here is, to be honest
16:14:14 <geekosaur> what did you believe deriving did with newtypes?
16:14:48 <geekosaur> or did you believe that all instances were automagically derived through for you? and if so, what did you believe people specifying deriving clauses were doing?
16:17:52 <stevenxl> Hi everyone. I have the following type signature: getAuthId :: (MonadHandler m, HandlerSite m ~ master) => Creds master -> m (Maybe (AuthId master))
16:18:03 <stevenxl> I was wondering, how do I read HandlerSite m ~ master
16:18:26 <c_wraith> stevenxl: ~ is type equality
16:18:47 <stevenxl> c_wraith: So does that mean that HandlerSite m is an "alias" in some sense to master?
16:18:58 <hpc> > () :: (Int ~ String) => ()
16:19:00 <lambdabot>  error:
16:19:00 <lambdabot>      Couldn't match type â€˜Intâ€™ with â€˜[Char]â€™
16:19:00 <lambdabot>        arising from an expression type signature
16:19:05 <hpc> > () :: (Int ~ Int) => ()
16:19:07 <lambdabot>  ()
16:19:09 <hpc> :t (~)
16:19:11 <lambdabot> error: parse error on input â€˜)â€™
16:19:12 <c_wraith> stevenxl: sort of.  it's most practical to think of it at "the compiler must be able to prove they're the same type to use this"
16:19:12 <hpc> :k (~)
16:19:14 <lambdabot> k -> k -> Constraint
16:19:21 <c_wraith> *as
16:20:40 <stevenxl> Hm... So given that, would I be able to say that Creds master is, to a first approximation the same as Creds (HandlerSite m)?
16:20:53 <hpc> it doesn't come up very often, usually if you have some (a ~ b) => f a, you can write (f b) instead
16:20:57 <c_wraith> It means exactly that
16:21:20 <hpc> there's probably something about HandlerSite, or how getAuthId is used, which requires it
16:21:39 <c_wraith> And yeah, usually it comes up when there's some advanced type feature involved..  I'm guessing HandlerSite is a type family in this case.
16:21:45 <c_wraith> (It also comes up with GADTs)
16:21:47 <mniip> I don't see anything preventing tidying up this equality constraint here
16:22:04 <mniip> ah, if HandlerSite is a tyfamp
16:22:07 <mniip> tyfam*
16:22:42 <Squarism> geekosaur, I believed newtype just cleaned all instances from the type. Didnt know it was simple to plug some of them back in 
16:23:02 <geekosaur> thats the point of GeneralizedNewtypeDeriving
16:23:12 <geekosaur> you say which ones to copy through, then you can do whatever with the rest
16:23:15 <hpc> Squarism: a newtype is a new type, after all ;)
16:23:44 <Squarism> great. Ill try that
16:26:13 <stevenxl> c_wraith, hpc thank you both. I think this is a bit out of my depth right now. However, the originally reason I asked is because I'm getting a type error, and I might be focusing on the wrong part of the error. Expected type: m (Maybe (AuthId master)) and Actual type: HandlerFor site0 (Maybe (Key User)) is something I can try and punch my way out of.
16:27:18 <c_wraith> stevenxl: I'd focus on the innermost part:  AuthId master vs Key User.  Are those the same?  (I really don't know, if type families are involved)
16:27:19 <hpc> stevenxl: now that you know what to mentally substitute where, yeah you can track down the actual mismatch
16:29:19 <stevenxl> c_wraith: I think I say where you are coming from. If m ~ HandlerFor site0, then that error is equivalent to expected m (Maybe (AuthId master)), actual is m (Maybe (Key User))
16:29:25 <stevenxl> I see*
16:29:29 <c_wraith> yep
16:30:05 <stevenxl> Nice. OK going to continue down this path.
16:40:01 <stevenxl> If I want to find the type of a value, I can use a type whole such as x :: _ or I can assert a wrong type and let GHC tell me I'm wrong, such as x :: (). 
16:40:26 <stevenxl> Should I be using one over the other in certain situations? Or is one always preferred?
16:40:30 <c_wraith> yes, both of those work.  Though, typo warning:  It's a type "hole" :)
16:41:04 <MarcelineVQ> typed hole in fact :D
16:41:06 <c_wraith> It's slightly more of a supported feature to use _
16:41:08 <hpc> holes are preferred
16:41:55 <hpc> you can also use holes wherever an expression would go, to get the type of what value should go there
16:42:20 <c_wraith> right.  value holes, as it were.
16:42:47 <stevenxl> Ha - thank you. Brain lapse - I knew it was hole not whole.
16:42:49 <hpc> everything's a value, on some level
16:42:50 <hpc> :D
16:43:01 <c_wraith> on the type level, types are values!
16:43:37 <stevenxl> yea the feedback from GHC was must better with the typed hole versus asserting the wrong type. 
16:45:22 <hpc> i haven't tried, but i think holes also work better with IDEs
16:45:41 <hpc> like your IDE can ask its language server to do something sensible with the hole like automatically fill it with a value
16:45:57 <hpc> that's how it worked in agda though
16:46:16 <hpc> i would be surprised if that's not a thing though
16:46:20 <MarcelineVQ> idk if we have an ide expression search atm
16:46:24 <MarcelineVQ> *with expression
16:47:15 <hpc> it'd be the language server in any event
16:57:44 <techieAgnostic> so cabal list tells me i have base 4.9 installed, and the default avaliable version is 4.10, but cabal install base-4.10.0.0 fails saying could not resolve dependencies, and that only already installed instances of base can be used
16:57:51 <techieAgnostic> how do I go about fixing this?
16:58:16 <stevenxl> OK. So I'm making some progress. The type error says that the expected type is m (Maybe (AuthId master)), but the actual type is m (Maybe (Key User)). But if I look at the declaration for AuthId, I see:     type AuthId App = UserId. Unfortunately, UserId is auto-generated by template haskell, but in the example in these docs (https://www.yesodweb.com/book/persistent) type PersonId = Key Person, and so I imagine that we have
16:58:16 <stevenxl> a type User = Key User. So m (Maybe (AuthId master)), when master is initialized to App, should be equivalent to m (Maybe (Key User)).
16:58:40 <stevenxl> err, type UserId = Key User
16:59:50 <stevenxl> Not sure why the compiler and I are coming to different conclusions (obviously compiler is right but I don't know how to fix). 
17:00:14 <stevenxl> https://www.irccloud.com/pastebin/Xqm2TTFS/getAuthId
17:03:27 <stevenxl> Hm.. maybe I can specialize x to be Either (Entity (AuthId App) (AuthId App) instead of Either (Entity User) (Key User).
17:10:35 <stevenxl> hm.. something is not vibing; gonna take a break and hit this up later.
17:17:45 <madnight> https://lpaste.net/4903329076808253440 whats my problem?
17:19:12 <dolio> techieAgnostic: base comes with GHC, and only that version can be used with that version of GHC.
17:19:13 * hackage typesafe-precure 0.7.0.1 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  http://hackage.haskell.org/package/typesafe-precure-0.7.0.1 (igrep)
17:21:54 --- mode: glguy set +v wazdee
17:22:59 <wazdee> It seems to be an open issue on github https://github.com/brendanhay/amazonka/issues/466
17:23:28 <wazdee> however I tried pinning my stack.yaml to a newer commit like people said and its still not working
17:41:33 --- mode: glguy set +v wazdee_
17:42:04 <wazdee> Does anyone have experience reading files from S3 in haskell? I'm trying to use amazonka-s3 and I am able to write, list buckets, etc. But when I try to read the body of a getObject response I get an HttpExceptionRequest   
18:02:51 <glguy> techieAgnostic: base comes with GHC. If you want a different base, use a different GHC
18:30:13 * hackage jps 0.1.0.0 - Jump point search for Haskell  http://hackage.haskell.org/package/jps-0.1.0.0 (isovector)
18:31:09 <dmrd> anyone here experienced with biplate? Was speaking with some folks earlier today about it but I suppose they may be offline now. Curious as to how to specify the 'goal' / 'to' type
18:31:22 <c_wraith> dmrd: did you see my paste up there?
18:31:32 <c_wraith> dmrd: https://lpaste.net/9166776784643948544  (just in case)
18:31:57 <c_wraith> dmrd: the goal type is specified by the type of the function passed to descendBiM (in this case)
18:33:13 * hackage recursion 1.2.0.0 - A recursion schemes library for GHC.  http://hackage.haskell.org/package/recursion-1.2.0.0 (vmchale)
18:33:35 <dmrd> c_wraith: yeah I have it open right here. It just mixed in a couple iffy concepts in my head (such as template haskell ) and so I'm having trouble reading it. what exactly is 'f' doing there? I see its somehow using the writer monad but I can't quite decipher it 
18:34:41 <c_wraith> dmrd: well, the trick in doing this with any generic traversal is to get the result back out, when you want a different type than the type of the structure you are traversing
18:35:46 <c_wraith> dmrd: Fortunately, there's a variant that allows you to use any monadic context you'd like.  (Honestly, it probably should be Applicative, but the library is old, and predates Applicative being made a superclass of Monad)
18:36:35 <c_wraith> So f has two purposes.  One is relatively simple - it has to type check in a way that allows descendBiM to know what type it's looking for.
18:37:03 <c_wraith> The other is that it has to pack up the results that it found into the context so they can be extracted at the end of the traversal.
18:37:52 <c_wraith> I'm using Writer to pack up a list of Name values that it finds, so that m ~ Writer [Name]
18:38:55 <c_wraith> the contents of f are pretty boring.  It writes the found name into the list (paying attention to the type of tell) and then returns the value it found.
18:39:02 <c_wraith> :t (<$)
18:39:03 <lambdabot> Functor f => a -> f b -> f a
18:39:13 * hackage recursion 1.2.0.1 - A recursion schemes library for GHC.  http://hackage.haskell.org/package/recursion-1.2.0.1 (vmchale)
18:39:39 <c_wraith> that operator just means "perform the action on the right, but substitute in the value on the left in place of the result"
18:40:57 <badzergling_> I wouldn't even say that it means "perform" in any sense, it's "replace all the `b`'s in this  `f` with this particular `a`
18:40:59 <dmrd> c_wraith: Ok, I'll take all of that into account and look at it for a little longer / try to run it myself. Import template haskell is giving me some issues but I think that playing with it should be illustrative. I'll return to working on it for a little. Thanks so much, as always
18:41:14 <c_wraith> dmrd: oh, right.  I started ghci with -XTemplateHaskell
18:41:34 <c_wraith> dmrd: you can also use this at the prompt  :set -XTemplateHaskell 
18:49:32 <dmead> Hi guys
18:49:37 <dmead> does anyone have a parser for cobol?
18:50:04 <dmead> also, unrelated. i'm rusty with haskell...  what guide should i follow for bootstrapping a new project
18:50:46 <monochrom> The Gentle Introduction.
18:51:06 <dmrd> dmead: maybe this? https://gist.github.com/mikehaertl/3258427
18:51:18 <dmead> The gentle introduction didn't cover cabal and stack when i read it in 2005
18:51:35 <monochrom> Sure. You didn't say you need that.
18:51:51 <dmead> Sorry i should have specified.. I mean the haskell platform/toolchain.
18:52:04 <dmead> i've known haskell for a long time. I used to have some projects on the wiki way back.
18:52:07 <dmrd> dmead: I love this guide http://seanhess.github.io/2015/08/04/practical-haskell-getting-started.html
18:52:24 <dmrd> dmead: It's multi-part so read all 4 parts
18:53:03 <monochrom> I would read the cabal user's guide and the stack user's guide.
18:53:45 <sclv> i just start with "cabal init" and it gets me up with the basics
18:54:02 <monochrom> I also think that cabal is simpler so start with cabal if you don't already have a decision.
18:54:03 <sclv> when i need to build out test-suites etc then i go to docs
18:54:32 <sclv> (the main difference with cabal from the past is instead of build you call `new-build` to get the modern package management experience)
18:57:01 <monochrom> Yeah, new-build and new-* have a lot of overlap with how stack does things.
19:02:09 <dmead> @monochrom should you tldr the difference between stack and cabal for me?
19:02:09 <lambdabot> Unknown command, try @list
19:02:15 <dmead> monochrom, 
19:02:18 <dmead> etc
19:02:50 <dmead> sclv, ot
19:03:05 <dmead> sclv, its all the same to me. I stopped haskell right about when cabal came out
19:03:23 <dmead> like 2010-2011 maybe
19:03:52 <c_wraith> cabal was out when I started using Haskell in 2008 - so... longer than that.
19:03:57 --- mode: glguy set +v zipp
19:04:27 <dmead> ah
19:04:33 <dmead> well, either way. it's been a while
19:04:43 <dmead> and i didn't really use cabal back then anyway
19:04:59 <monochrom> tldr? You'd better not regret asking me for a tldr. stack is a control freak. That's the difference.
19:05:13 <glguy> Stack solves dependency resolution being hard by making you manually specify the build plan.
19:07:11 <glguy> Fortunately that's not really necessary in most cases
19:07:52 <monochrom> I suddenly realize that I have no idea what a "build plan" is.
19:08:44 <monochrom> Because I thought it were as simple as "versions of dependencies" but clearly people wouldn't say "build plan" for just that.
19:10:52 <glguy> I mean, build plan is shorter. Versions of dependencies and tools and package flags etc
19:14:43 * hackage stratosphere 0.25.0 - EDSL for AWS CloudFormation  http://hackage.haskell.org/package/stratosphere-0.25.0 (jdreaver)
19:23:41 <chessandgo> when you lift something, youre putting it the context of the monad below, and then rewrapping it, right?
19:24:43 <c_wraith> Eh.  You're doing whatever is necessary to make the types match.  I don't think it's worth assigning more meaning to it than that, because it can be wildly different for different types.
19:26:18 <chessandgo> ive been getting into Cloud haskell
19:26:41 <Squarism> anyone able to shine some light on  my noob problem https://lpaste.net/1036737472404389888 ?
19:26:42 <chessandgo> and suddenly they throw the wrench of "and you can do any IO within the Process monad by using liftIO"
19:27:03 <chessandgo> and it through me for a loop because I didnt realize their types where hiding that they where ontop of the IO monad the whole time
19:27:39 <Squarism> I want to make a modified context using newtype for the ReaderT im using in my production code for a test
19:32:20 <dmrd> c_wraith: I think I figured out why I don't understand your snippet. I clearly don't understand how to tell behaves outside its usual `do` block (paired up with a return as the last statement). Can we talk about that for a little?  I think I'm really close to cracking this one out
19:32:50 <c_wraith> dmrd: what I wrote is the equivalent of f x = do { tell [x] ; return x }
19:33:36 <c_wraith> dmrd: I just used (<$) because it's shorter.  There's nothing special about do notation after all - it just maps to functions that you can call without it.
19:36:42 <Squarism> nvm
19:37:33 <ddellacosta> so if fmap over Identity is (roughly) function application, then what is fmap over Const actually doing? I'm having a hard time understanding what it "means" if that makes sense
19:37:51 <c_wraith> ddellacosta: it changes the type, but does nothing else
19:38:21 <glguy> fmap _ (Const x) = Const x
19:39:54 <ddellacosta> c_wraith: it changes the type in what sense? Like, I can see that the type variable I have for b in Const a b is resolved into a specific type after I call fmap. So we can say that b is "realized" somehow? 
19:40:20 <ddellacosta> or am I barking up the wrong tree by thinking too hard about this?
19:40:50 <glguy> fmap f :: Const e a -> Const e b
19:41:17 <glguy> The type "changed" where you had an a in there and now you have a b
19:42:19 <c_wraith> :t fmap show (Const 0)
19:42:20 <lambdabot> Num a => Const a String
19:43:35 <ddellacosta> glguy: okay, I guess I was misunderstanding how the types change
19:43:50 <ddellacosta> still, I feel like I'm missing some deeper connection here.
19:44:25 <c_wraith> Why do you think you're missing something?
19:46:06 <ddellacosta> c_wraith: maybe because I've been trying to understand these in the context of lens, and it seems like Identity and Const are doing something "interesting" in that context, and I'm trying to understand what that is and failing to get it. Via https://hackage.haskell.org/package/lens-tutorial-1.0.3/docs/Control-Lens-Tutorial.html, about a quarter of the way down
19:46:50 <c_wraith> The interesting thing Const does is at the type level.
19:47:30 <c_wraith> You've got a function with a type something like (a -> f b) -> s -> f t
19:47:58 <c_wraith> How do you smuggle an `a' value out in the type `f t'?
19:48:23 <c_wraith> The simplest answer is to set f ~ Const a
19:48:25 <glguy> Const and Identity are extremely simple. The insight that you can generalize over both of them at the same time is the interesting thing
19:48:40 <c_wraith> So then you have (a -> Const a b) -> a -> Const a t
19:48:46 <ddellacosta> c_wraith: I would assume to subsume it as part of t somehow
19:48:47 <ddellacosta> ah
19:48:55 <ddellacosta> glguy: yeah, that part is maybe what I'm having trouble with
19:48:58 <ddellacosta> the latter
19:49:58 <ddellacosta> c_wraith: that is interesting and helpful, thanks. I'm not sure yet how to connect that to the lens stuff I'm reading but it has increased my grasp of Const, at least
19:50:10 <ddellacosta> improved I should say
19:52:27 <c_wraith> Well, fortunately there are some lenses about
19:53:14 <c_wraith> :t (\f -> getConst . f Const)
19:53:16 <lambdabot> forall k1 k2 a1 (b1 :: k2) a2 c (b2 :: k1). ((a1 -> Const a1 b1) -> a2 -> Const c b2) -> a2 -> c
19:53:31 <c_wraith> > (\f -> getConst . f Const) _1 ("hello world!", ())
19:53:33 <lambdabot>  "hello world!"
19:53:40 <koz_> c_wraith: Dat type though.
19:53:47 <c_wraith> blame polykinds
19:55:12 <MarcelineVQ> :t _1
19:55:14 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
19:55:14 <ddellacosta> oh ha that is view isn't it
19:55:18 <c_wraith> yes, it is
19:55:27 <c_wraith> well, a slightly less polymorphic version of it
19:56:03 <ddellacosta> okay yeah that type is hard but I can kinda see it, where the lens is the first arg
19:56:04 <c_wraith> since view's type involves MonadReader
19:57:05 <koz_> Does anyone know if/when hdevtools will be added to the LTS-12 series of Stackage releases?
19:57:33 <ddellacosta> okay I think I'm going to have to think about this for a bit. c_wraith and glguy thanks for your help, especially that last example c_wraith
20:00:25 <glguy> koz_: if something isn't in lts-12 already it's not going to be. You can see what packages might be in lts-13 by looking at nightly
20:00:43 * hackage gloss-rendering 1.13.0.1 - Gloss picture data types and rendering functions.  http://hackage.haskell.org/package/gloss-rendering-1.13.0.1 (BenLippmeier)
20:01:42 * hackage gloss-algorithms 1.13.0.1 - Data structures and algorithms for working with 2D graphics.  http://hackage.haskell.org/package/gloss-algorithms-1.13.0.1 (BenLippmeier)
20:02:29 <koz_> glguy: Oh, so basically, if something doesn't go in at the _beginning_ of an LTS, it won't go in until the next LTS?
20:02:43 * hackage gloss 1.13.0.1, gloss-raster 1.13.0.1 (BenLippmeier): https://qbin.io/fucked-forbes-t3ke
20:03:16 <c_wraith> Once a stackage release is tagged, it never changes.
20:03:43 * hackage gloss-examples 1.13.0.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.13.0.1 (BenLippmeier)
20:12:40 <YellowOnion> is there a way to wildcard import all infix operators?
20:14:17 <glguy> No
20:14:39 <glguy> (which is why lens provides http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Operators.html )
20:15:28 <YellowOnion> glguy, ahh thanks.
20:16:13 * hackage gloss-rendering 1.13.0.2 - Gloss picture data types and rendering functions.  http://hackage.haskell.org/package/gloss-rendering-1.13.0.2 (BenLippmeier)
20:18:23 <fragamus> dmwit: did you say you have a 308 line haskell.vim
20:20:08 <glguy> I didn't see dmwit's messages, but my version fixed for Haskell 2010 and some other extensions in GHC is here https://glguy.net/haskell.vim
21:15:10 --- mode: glguy set -v MarcelineVQ
21:22:34 <koz_> What's the typeclass that provides division again?
21:24:01 <stevenxl> RealFrac
21:24:30 <stevenxl> sorry
21:24:33 <stevenxl> Integral
21:24:34 <stevenxl> :t div
21:24:36 <lambdabot> Integral a => a -> a -> a
21:24:49 <stevenxl> :i Integral
21:25:02 <koz_> stevenxl: Thanks.
22:07:10 <jle`> :t (/)
22:07:12 <lambdabot> Fractional a => a -> a -> a
22:07:19 <jle`> ^ koz_ 
22:07:56 <koz_> jle`: Thanks!
22:20:01 --- mode: glguy set +v thunderseethe
22:20:19 <thunderseethe> Hello, I'm having an issue with prettyprint Doc annotations type variables not coercing to the same type. It's saying expected type: Doc ann1, actual type: Doc ann and cannot reconcile that they should be equivalent. Is there a way I can force them to be equivalent and has someone else run into this before?
22:20:41 <koz_> thunderseethe: Would you mind pasting what you're trying to do on lpaste? That's a bit vague.
22:21:53 <thunderseethe> koz_: totally, just a second
22:24:03 <thunderseethe> https://lpaste.net/6446685030134579200
22:24:43 <thunderseethe> I tried to reduce it down to the crux of the issue, let me know if there's any context missing or something I'm doing isn't reasonable/idiomatic
22:25:50 <jle`> hi all, just letting anyone who is interested know that i'll be streaming implementing a dependent type-safe tic tac toe with miso gui in a few minutes :) https://www.twitch.tv/justin_l
22:29:18 <koz_> thunderseethe: Are you trying to use recursion schemes or something?
22:30:10 <thunderseethe> koz_: yes, I pretty print Expr as a catamorphism.
22:33:12 * hackage record-encode 0.2.2 - Generic encoding of records  http://hackage.haskell.org/package/record-encode-0.2.2 (ocramz)
22:46:44 <maerwald> stack re-copies all binaries on "build", even if they have not been rebuilt?
22:50:50 <maerwald> https://github.com/commercialhaskell/stack/issues/3486 great
22:51:04 <dminuoso> Garh. Want levity polymorphism for ($) :(
22:55:03 <dminuoso> Mmm. Can instance Monad IO be defined in Haskell at all? Im having difficulties debugging my attempts because unboxed tuples make it hard to debug this in GHCi.
22:55:29 --- mode: glguy set +v pally
22:55:51 <pally> https://stackoverflow.com/questions/3136338/uses-for-haskell-id-function
22:56:15 <pally> foldr (.) id [(+2), (*7)] -- building up a function via a fold
22:56:45 <pally> @let f = foldr (.) id [(+2), (*7)]
22:56:46 <lambdabot>  Defined.
22:56:50 <pally> f 7
22:56:56 <pally> > f 7
22:56:58 <lambdabot>  error:
22:56:58 <lambdabot>      Ambiguous occurrence â€˜fâ€™
22:56:58 <lambdabot>      It could refer to either â€˜Debug.SimpleReflect.fâ€™,
22:57:29 <pally> that's not really nice.
22:57:34 <thunderseethe> that is unfortunate
22:57:43 <dminuoso> @let pf = foldr (.) id [(+2), (*7)]
22:57:43 * hackage yaml 0.10.0 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.10.0 (MichaelSnoyman)
22:57:44 <lambdabot>  Defined.
22:57:46 <dminuoso> > pf 7
22:57:49 <lambdabot>  51
22:58:05 <dminuoso> pally: https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
22:58:29 <dminuoso> pally: In your specific case replace numbers with *functions* like (+2) and (*7)
22:59:53 <nshepperd> dminuoso: instance Monad IO is indeed defined in base, in terms of the underlying unboxed tuples / State# s stuff
23:00:00 <dminuoso> nshepperd: whereabouts?
23:00:07 <nshepperd> https://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.Base.html#returnIO
23:00:19 <dminuoso> nshepperd: Okay im really confused now. :-)
23:00:20 <dminuoso> OH!
23:00:23 <dminuoso> Haha.
23:00:38 <dminuoso> nshepperd: All good. Thats what I had, just understood my.. well. Mistake.
23:01:06 <dminuoso> My program seemed to have been stuck. I didn't think too much of that "getLine' :: MyIO String" that was waiting for stdin...
23:02:04 <nshepperd> :>
23:02:12 <MarcelineVQ> :>
23:02:43 * hackage tax 0.1.0.0 - Types and combinators for taxes  http://hackage.haskell.org/package/tax-0.1.0.0 (frasertweedale)
23:07:24 <pally> I understand foldr its simple usage, but not when there's function composition and `id` thrown in the mix
23:07:52 <pally> I came across that StackOverFlow page to learn what `id` does.
23:08:11 <thunderseethe> are you familiar with function composition?
23:09:30 <pally> kinda.  Lemme explain what I mean by "simple" (basic usage).
23:11:49 <laudecay> im actively suicidal recommend me a haskell project that'll make it better
23:11:49 <pally> @let myFoldr f accum [] = accum; myFoldr f accum (x:xs) = f x (myFoldr f accum xs)
23:11:50 <lambdabot>  Defined.
23:12:10 <laudecay> d i s t r a c t i o n  t i m e
23:12:43 <MarcelineVQ> Can't be that active
23:12:53 <dminuoso> pally: Check out the picture I linked to you.
23:13:15 <dminuoso> pally: Stop thinking in terms of "accumulation", think of foldr as a kind of structural transformation. 
23:13:36 <cocreature> pally: thatâ€™s the implementation of foldr not a simple usage of it
23:14:16 <pally> cocreature, yes, and that's to demonstrate my understanding of foldr.  dminuoso just brought out a good point
23:14:16 <isTofu> Holy shit
23:14:27 <isTofu> there's a channel for haskell with people..
23:14:54 <pally> and maybe my problem is that I was introduced to foldr in a way that I think in terms of "accumulation"
23:14:59 <laudecay> what should i write yall
23:15:03 <thunderseethe> @let pfp = myFoldr (.) id [(+2), (*7)]
23:15:05 <lambdabot>  Defined.
23:15:10 <thunderseethe> pfp 7
23:15:21 <thunderseethe> > pfpf 7
23:15:24 <lambdabot>  error:
23:15:24 <lambdabot>      â€¢ Variable not in scope: pfpf :: Integer -> t
23:15:24 <lambdabot>      â€¢ Perhaps you meant â€˜pfpâ€™ (line 181)
23:15:39 <thunderseethe> yikes, that's embarassing
23:15:42 <cocreature> what foldr does it, it replaces each occurence of (:) with your reducer and [] with the initial value
23:15:43 <thunderseethe> > pfp 7
23:15:45 <lambdabot>  51
23:16:11 <cocreature> eh the grammar in that sentence is completely broken but hopefully it still gets the point across :)
23:16:26 <cocreature> > foldr f i (1 : 2 : 3 : [])
23:16:27 <MarcelineVQ> laudecay: write a snes emulator
23:16:28 <lambdabot>  error:
23:16:28 <lambdabot>      Ambiguous occurrence â€˜fâ€™
23:16:28 <lambdabot>      It could refer to either â€˜Debug.SimpleReflect.fâ€™,
23:16:30 <laudecay> what snes
23:16:33 <cocreature> @undefine
23:16:33 <lambdabot> Undefined.
23:16:34 <laudecay> what is
23:16:35 <cocreature> > foldr f i (1 : 2 : 3 : [])
23:16:37 <lambdabot>  f 1 (f 2 (f 3 i))
23:16:47 <dminuoso> pally: An alternative thought that, possibly, may provide a lot of intuition is the equivalent:
23:16:56 <MarcelineVQ> woah hey now, I'm not gonna do all the work for you
23:17:01 <cocreature> if you write that in infix form you get "1 `f` (2 `f` (3 `f` i)))"
23:17:06 <dminuoso> @let fe = foldMap Endo [(+2), (*8)]
23:17:07 <lambdabot>  Defined.
23:17:09 <dminuoso> > fe 8
23:17:11 <lambdabot>  error:
23:17:11 <lambdabot>      â€¢ Couldn't match expected type â€˜Integer -> tâ€™
23:17:11 <lambdabot>                    with actual type â€˜Endo Integerâ€™
23:17:18 <cocreature> which is exactly 1 : 2 : 3 : [] with (:) replaced by f and [] replaced by i
23:17:33 <dminuoso> @let fe = appEndo . foldMap Endo [(+2), (*8)]
23:17:34 <lambdabot>  .L.hs:158:1: error:
23:17:34 <lambdabot>      Multiple declarations of â€˜feâ€™
23:17:35 <lambdabot>      Declared at: .L.hs:157:1
23:17:40 <dminuoso> Gah well that.
23:17:49 <laudecay> isnt that gonna be like really hard
23:18:04 <laudecay> im looking for quick satisfaction
23:18:19 <dminuoso> laudecay: You can get a lot of quick satisfaction even writing a snes emulator.
23:18:26 <laudecay> not hating myself more because i fail at a hobby project like i fail at everything else in my worthless life
23:18:30 <dminuoso> laudecay: Each function you write can provide for lots of satisfaction.
23:18:37 <thunderseethe> laudecay: write a chip8 emulator
23:18:39 <laudecay> i dont even know where to start
23:18:46 <laudecay> whats chip8
23:18:59 <thunderseethe> tiny and friendly
23:19:02 <laudecay> huh 35 opcodes
23:19:05 <laudecay> seems friendly
23:19:10 <laudecay> probably not friendly in haskell
23:19:18 <thunderseethe> http://www.multigesture.net/articles/how-to-write-an-emulator-chip-8-interpreter/
23:19:47 <thunderseethe> your opcodes map almost directly onto a Sum type with a little bit fiddling decoding isn't awful either
23:20:28 <laudecay> yeah i think i wrote most of some ast shit with sum types in my intro haskell class forever ago
23:21:13 <cocreature> if youâ€™re not into low-level stuff, a scheme interpreter might also be nice
23:21:19 <laudecay> how do i represent the memory, state monad? or
23:21:22 <ChaiTRex> Is this supposed to happen? Could not deduce (KnownNat ((2 ^ n) - 1)) ... from the context: KnownNat n
23:21:33 <laudecay> i used unfoldr for simulation a while back which was slow but worked
23:21:35 <cocreature> and there is a nice tutorial https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
23:21:42 <dminuoso> Okay! So unsafeDupableInterleaveIO time. My understanding is as follows: All it does is ensure that given `a >> b`, then b will not depend on a. Is my understanding right here?
23:21:47 <laudecay> oh i might go for scheme then
23:21:53 <cocreature> ChaiTRex: try using the ghc-typelits-knownnat plugin
23:22:03 <ChaiTRex> cocreature: OK. Thanks.
23:22:15 <laudecay> im going to want to die more if i take on something easy and just completely fail
23:22:40 <laudecay> tbh if i just like.... drink until i cant walk.... i cant kill myself either
23:23:38 <cocreature> youâ€™d be surprised by how many people here will probably be able to tell you stories about how they failed to learn Haskell on their first attempt (myself included) :)
23:23:40 <dminuoso> The way I read the implementation it seems to just ensure that an `IO` action will no longer do the regular `State# RealWorld` fiddling, so that there is no direct `State# RealWorld` reaching from the next action back to this one
23:23:48 <laudecay> this isnt my first attempt
23:24:07 <laudecay> ive been doing this for 2 years
23:24:10 <dminuoso> It's quite surprisingly how simple IO is..
23:24:15 * dminuoso loves Haskell
23:24:16 <thunderseethe> I still haven't learned haskell and I've made countless attempts
23:24:19 <laudecay> but i was prolly dropped as a child so
23:24:22 <laudecay> whatever
23:24:27 <cocreature> I think it clicked for me on like my third attempt or so
23:24:32 <cocreature> and I took long breaks in between
23:24:48 <thunderseethe> I think it also goes pretty incrementally
23:24:49 <laudecay> i can get the computer to run the haskell
23:24:54 <laudecay> it just looks like imperative code
23:24:59 <laudecay> and its revoltingly ugly 
23:25:01 <laudecay> and its slow as fuck
23:25:26 <laudecay> i implemented a simulation of a bunch of computers doing paxos in haskell about 3 months ago, i was in this channel pestering everyone
23:26:00 <pally> > id [(+2), (*7)]
23:26:02 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>]
23:26:08 <laudecay> "hey why doesnt x work" "why dont you just do this in python if youre going to write imperative code anyway"
23:26:25 <dminuoso> pally: Are you roughly familiar with the concept of monoids?
23:26:27 <laudecay> "why arent you listening" hey sorry im fucking stupid
23:26:37 <cocreature> you complain about not being able to solve simple problems but you are able to implement paxos? seems like you might just need to adjust your notion of what counts as simple :)
23:26:49 <pally> dminuoso, nope.  never been introduced..
23:27:04 <laudecay> paxos isnt hard when youre handheld through it lol
23:27:20 <cocreature> paxos is certainly doable but itâ€™s also far from trivial
23:27:27 <laudecay> i suck
23:27:37 <dminuoso> pally: Feel free to add it to your short term list of things to absorb, it's a really useful, simple and cool abstraction 
23:27:54 <laudecay> i want to stop being awake
23:27:55 <laudecay> fuck
23:28:08 <DoomGuyFieri> Does anyone here use Sabayon Linux?
23:28:28 <laudecay> DoomGuyFieri: i had to fight with the devs once to get shit taken down off their pastebin site
23:28:40 <laudecay> but no, does sabayan actually have users lol
23:28:48 <thunderseethe> pally: also consider it's not id [(+2), (*7)] rather it's (+2) . (*7) . id
23:30:00 <pally> thunderseethe, what you just said I believe will open things up for me.
23:30:23 <dminuoso> pally: When you grasp monoids, this foldr trick will feel so natural.. =P
23:30:55 <pally> dminuoso, this notation, (or trick you call) is causing me a lot of pain.
23:31:01 <pally> :S
23:31:09 <thunderseethe> pally: When I'm struggling to grok what's going it's helpful to expand out the function invocations so I can see what's happening start with foldr (.) id [(+2), (*7)] => foldr (.) ((*7) . id) [(+2)] and continue onwards
23:31:15 <dminuoso> > foldMap Product [1,2,3,4,5]
23:31:17 <lambdabot>  Product {getProduct = 120}
23:31:19 <dminuoso> > foldMap Sum [1,2,3,4,5]
23:31:22 <lambdabot>  Sum {getSum = 15}
23:31:51 <thunderseethe> pally: if monoids are overwhelming don't worry about them too much right now. They provide the math behind folds but aren't necessary while your still grokking id
23:32:02 <thunderseethe> you're*
23:32:21 <dminuoso> pally: Essentially a Monoid has this concept of: given some type `m` we have a "combine together function" that goes `m -> m -> m`
23:32:30 <pally> thunderseethe, you understand the baby steps I need at this point.  Thanks.
23:32:39 <dminuoso> pally: And we have some special element that acts as a kind of "0", so we can "add" it with no effect.
23:32:50 <thunderseethe> pally: No worries, everyone starts where you are :)
23:32:56 <dminuoso> pally: Like 0 for integer addition, 1 for integer multiplication or the empty list for list concatenation
23:34:03 <pally> thunderseethe, dminuoso is trying to dump the math on me... but I feel like if I am going to learn monoid, it takes more than just an intuition.  Maybe I am wrong.
23:34:22 <dminuoso> pally: Not really math, it's no more than Im saying. Monoid just captures the idea of "combining" things in a useful way.
23:34:25 <MarcelineVQ> oh he's done, that's all there is to the concept
23:35:29 <cocreature> I propose that we rename Monoid to Smashable
23:35:29 <coldpresent> i still dont get monoids, but i hope i will someday
23:35:40 <thunderseethe> They have a scary name (much like their cousin monad) but they're simple one you get used to higher order functions. They provide a way to abstract over "combining things" which is very nifty but again not necessary until you've worked with it enough to start to see the pattern yourself and question if it generalizes
23:37:28 <pally> thunderseethe, I am just starting to get more comfortable with monad.  Whether it has a scary name or not, there are a number of pieces at play in order to understand a program that uses >>= (e.g. how the bind operator is defined, how it is used)
23:39:06 <thunderseethe> Yeah one of the unfortunate bits of haskell is you have to dive into the deep end and use monads right away
23:39:14 <dminuoso> pally: Monoid is no different really. There you have this ominous <> operator that just "smashes" two elements together. How does it do so? Well every type can implement it differently. :)
23:39:28 <thunderseethe> Good ole monadic IO 
23:39:49 <Flonk> The `min` function takes two numbers and spits out a number, the smaller of the two. If you `min` anything with Infinity you get back what you put it. So min forms a monoid, infinity being the "identity element"
23:40:12 <Flonk> Similarly, `+` turns two numbers into one, 0 being the neutral element that doesn't do anything
23:40:34 <Flonk> Pretty much everything forms a monoid in some way
23:40:48 <dminuoso> (++) takes two lists and spits out a single list. If you (++) some list `a` with the empty list you get `a` back.
23:41:18 <thunderseethe> Do endofunctors form a monoid?
23:41:20 <dminuoso> (.) takes two endofunctions (functions with same input and output types) and spits out a single function. if you (.) some function `f` with the `id` function, you get `f` back
23:41:22 <dminuoso> thunderseethe: Yes!
23:41:24 <Flonk> thunderseethe, well played
23:41:32 <dminuoso> thunderseethe: endofunctors with composition and id form a monoid :)
23:41:41 <dminuoso> *endofunctions at least
23:41:46 <dminuoso> endofunctors too.
23:42:05 <thunderseethe> dminuoso: yes, I was being a bit tongue n cheek :)
23:42:10 <dminuoso> Ohh! Hah.
23:56:47 <pally> dminuoso, is Maybe smashable ?
23:57:10 <pally> > (Just 2) + (Just 3)
23:57:12 <lambdabot>  error:
23:57:12 <lambdabot>      â€¢ No instance for (Num (Maybe Integer))
23:57:13 <lambdabot>          arising from a use of â€˜e_123â€™
23:57:32 <Ariakenom> > Just "a" <> Just "b"
23:57:34 <lambdabot>  Just "ab"
23:57:42 <lavalike> pally: if its contents are Smashable
23:58:14 <pavonia> > Just (Sum 2) <> Just (Sum 3)
23:58:15 <lavalike> > Nothing <> Just (Sum 2) <> Nothing <> Just (Sum 3)
23:58:17 <lambdabot>  Just (Sum {getSum = 5})
23:58:18 <lambdabot>  Just (Sum {getSum = 5})
23:58:23 <lavalike> haha
23:59:24 <dminuoso> Which means there exists an instance Semigroup a => Monoid (Maybe a)
23:59:33 <pally> > getSum Sum 2
23:59:35 <lambdabot>  error:
23:59:36 <lambdabot>      â€¢ Couldn't match expected type â€˜Sum (Integer -> t)â€™
23:59:36 <lambdabot>                    with actual type â€˜a0 -> Sum a0â€™
23:59:36 <dminuoso> The reason it doesn't say `Monoid` there is a bit more subtle and something you can ignore for now. :)
23:59:43 <pally> > getSum (Sum 2)
23:59:45 <lambdabot>  2
