00:23:07 <zenspider> hrm. anyone awake? #haskell-beginners has been dead all day
00:23:38 * Ariakenom yawns
00:23:54 <Ariakenom> mornin
00:24:04 <zenspider> 'morn
00:24:19 <zenspider> soo... I'm trying to move from globally installed ghc + cabal + pkgs to stack ... and I guess I'm not getting something. I've removed the old global ghc + cabal and I've done stack setup and re-installed a number of packages local to that ghc... but some of the old packages aren't installing via `stack install` (which I understood used cabal under the covers)
00:24:26 <zenspider> 1) Some of the dependencies aren't resolving correctly, so I have to add them to the global stack.yaml in the extra-deps. That seems really odd, and/or broken?
00:24:29 <zenspider> 2) some of the packages didn't actually build. structured-haskell-mode for example now fails out near the very end of the build because `descriptive` fails.
00:24:56 <zenspider> I'm guessing I just don't get something yet as I'm very new to stack (and still pretty new to haskell outside of a textbook)
00:25:12 <cocreature> zenspider: are you trying to install Haskell executables, install Haskell libraries globally or install the dependencies of a Haskell project?
00:25:49 <zenspider> I think the answer is haskell executables ... to help with my dev environment (emacs tooling) and such
00:26:17 <zenspider> I dunno if I bumped up into a version of haskell that is just broken for some of these libraries? or... what.
00:26:22 <zenspider> (and I don't know HOW to tell)
00:26:32 <cocreature> okay, in that case "stack install" is at least the right command to use (it is not the right command for installing libraries)
00:26:41 <cocreature> can you show us the specific errors you are seeing?
00:27:09 <zenspider> well, with regard to 1:
00:27:17 <zenspider> In the dependencies for structured-haskell-mode-1.1.0: descriptive must match >=0.7 && <0.10, but the stack configuration has no specified version  (latest matching version is 0.9.4) 
00:27:29 <zenspider> says to run stack solver (which just sits there... for a REALLY long time?)
00:27:42 <zenspider> or to manually list the dependency in global stack.yaml
00:27:50 <cocreature> right, I would go for the latter
00:28:01 <cocreature> although structured-haskell-mode isn’t really actively maintained anymore afaik
00:28:06 <zenspider> but... cabal installed it fine? what am I not getting?
00:28:09 <cocreature> so it might make sense to just avoid it all together
00:28:22 <zenspider> oh poo. that's too bad. I would have loved to have paredit like stuff in haskell-mode
00:28:37 <cocreature> by default stack takes packages from "stackage", a snapshot of a subset of packages on hackage locked to specific versions that are known to work together
00:28:53 <cocreature> if a package is not in stackage, you have to add it to extra-deps
00:29:10 <zenspider> where cabal... what? resolves the dependency tree itself?
00:29:41 <cocreature> right, cabal looks at all packages on hackage and their version constraints and tries to come up with a set of versions that are compatible with the constraints
00:29:46 <zenspider> based on something I read, the first thing I installed via `stack install` was cabal :P
00:30:21 <zenspider> ok. so... locking I then wind up with... ew. something not pastable. sec.
00:31:37 <zenspider> damnit. yagist.el won't post utf8?? ugh
00:32:02 <zenspider> https://gist.github.com/zenspider/d28b49ed9a6451fd9afbff0b27ba3c1d
00:33:46 <cocreature> looks like descriptive is not compatible with GHC 8.4. it’s fixed in master https://github.com/chrisdone/descriptive/commit/1d826c267d808ebfd9db86463f30f74cdd508850 but there hasn’t been a new release since
00:34:27 <cocreature> you could install from master but personally I would avoid relying on editor tooling that isn’t maintained particularly actively
00:34:48 <zenspider> ok. so it was rolling to too new of a haskell version. it didn't seem like much of a hop, but I'm new to this game
00:34:56 <zenspider> yeah. that seems wise
00:35:06 <zenspider> I could add an issue to ask for a release I suppose
00:35:37 <zenspider> unless they turn off issues. :(
00:36:57 <zenspider> is chrisdone (fpco) ever in here?
00:38:18 <zenspider> would it make sense to bump back to a previous ghc version? I'm not married to any of this stuff
00:39:28 <cocreature> you could do that but as I said, I would just avoid tooling that causes problems instead of jumping through hoops trying to get it to work.
00:39:58 <cocreature> Haskell tooling sadly tends to be a bit fragile and it is very easy to put way more time into setting it up than it actually saves you
00:41:54 <zenspider> fair
00:42:15 <bwe> dmwit: proof of `fmap (g.h) undefined = (fmap g.fmap h) undefined` https://bpaste.net/show/69a806c70376 -- is the proof valid?
00:45:14 <johnw> g . h is not the same as g $ h
00:46:06 <johnw> in f . g $ h you can replace it with f $ g $ h, but you can't freely exchange . and $ in all places
00:47:27 <quchen> bwe: ^
00:49:11 <cobax> so this is the state of the art in terms of reproducibility - nix generating a docker image atop alpine? https://cs-syd.eu/posts/2018-07-14-nix-docker-haskell
00:53:10 <MarcelineVQ> "So you spend a few minutes looking into Nix documentation and decide that maybe this whole digital computers thing is maybe not your thing after all." haha :>
00:56:51 <fendor> well, i get the pain
00:59:37 <ski> bwe : `h undefined' need not be equal to `undefined'. how did you remove the `fmap' in front of `h' ? how did you go from `fmap (...) undefined' to `undefined' ?
00:59:43 <zenspider> I couldn't even get nix to bootstrap... and the IRC channel was less than helpful... I gave up
01:01:11 <ski> bwe : imho, it might be easier to follow the proof as a chain of equalities, rather than as a sequence of separate equations
01:02:23 <ski> (unless you in some specific part of the proof actually need to operate on a whole equation. in which case it would, imho, be good to highlight that fact by 
01:02:40 <ski> *not* doing that in places where you don't need to)
01:03:06 <zenspider> hrm... how do I match the lts version to the ghc version? A fresh install of an older ghc version sets up stack.yaml to use 12.9. Any subsequent stack install starts to install the latest ghc.
01:03:50 <zenspider> oh... do I specify compiler to override that?
01:04:11 <MarcelineVQ> no you specify the resolver, check the list here https://www.stackage.org/
01:05:50 <zenspider> ah! thank you. that is working.
01:12:15 <bwe> ski: if h is not defined yet, how can I reason about `h undefined`?
01:16:36 <dstolfa> using stack, i have a bunch of modules in src/ which are not imported in the main executable. what i'd like to do is unit test a couple of them with hspec -- but when i kick off `stack test` it can't seem to find my modules. i've never used stack before for my own project and am trying it out for the first time to see if it'd be a good match for a relatively large autogenerated project with a couple of 
01:16:42 <dstolfa> files that are plugged into it. what am i doing wrong here?
01:18:39 <MarcelineVQ> stack test runs the test-suit sections in your cabal file  where does your cabal  (or package.yaml if you use it) file say it's looking for test modules?
01:19:12 <cocreature> dstolfa: a common setup is that you have a library that defines most of your code and then the executable and the test suite depend on that library to import modules from that library
01:22:50 <dstolfa> cocreature: right, i have that. do i need to import all of my modules into the library?
01:23:12 <dstolfa> by library i mean Lib.hs
01:23:21 <dstolfa> because in the cabal file, all of my modules are already under library:
01:23:34 <cocreature> dstolfa: no
01:23:45 <cocreature> can you show us the cabal file and the error? that might simplify things
01:23:48 <dstolfa> sure
01:23:49 <dstolfa> sec
01:26:07 <dstolfa> cocreature: https://pastebin.com/GceDbAt8 so the context is, there are many errors, but they all look like this, i.e. not being able to find things from these modules
01:27:06 <cocreature> dstolfa: have you imported the corresponding module in your test suite? if you have, can you show us the module header of that module?
01:27:14 <dstolfa> cocreature: i have, sec
01:27:28 <dstolfa> cocreature: import Test.Hspec
01:27:28 <dstolfa> import Tinyd
01:27:28 <dstolfa> import PrettyPrint
01:27:28 <cocreature> sidenote: a formal model of dtrace sounds pretty cool :)
01:27:52 <cocreature> dstolfa: I am interested in the header of the module that defines nat_of_integer, not the import list
01:27:53 <dstolfa> cocreature: yeah, though dealing with Isabelle generated code can be painful at times :-)
01:27:56 <dstolfa> ah
01:28:28 <dstolfa> cocreature: https://pastebin.com/AUWxbWRf
01:29:27 <cocreature> dstolfa: looks like the module is called Arith but you are not importing Arith
01:30:40 <dstolfa> oh poop, i forgot haskell requires all imports and doesn't automatically pick them up
01:30:53 <dstolfa> cocreature: that'll do it, thanks
01:48:39 <fendor> does someone have modern resource on how to test a servant rest api ?
01:51:41 <jkarni> fendor: you can often use servant-client in the tests
01:52:57 <jkarni> fendor: though it kind of depends on what it is you want to test
01:53:59 <fendor> jkarni, integration tests would be nice
01:54:47 <jkarni> fendor: worth mentioning re: testing servant in general are some packages that handle specific tests quite cleanly
01:54:51 <jkarni> fendor: like https://hackage.haskell.org/package/servant-aeson-specs
01:54:59 <jkarni> fendor: or https://hackage.haskell.org/package/servant-quickcheck
01:57:12 <fendor> jkarni, servant-client would be sensible to use for reproducible integration tests?
01:58:24 <jkarni> fendor: well, reproducibility depends a lot more on your setup than on servant-client
01:58:29 <alp> fendor, if you want to test the logic of your handlers, use servant-client, because it'll produce well-formed requests.
01:58:48 <jkarni> alp: hi Alp :)
01:59:04 <alp> if you want to test the overall behaviour of the web app with respect to good practices and what not, servant-quickcheck and hspec-wai are good helpers
01:59:16 <alp> the former will hit all your endpoints and verify that they meet some user specified properties
01:59:53 <alp> the latter will just let you build and send raw http requests, so you can e.g test the reaction of the service to invalid requests
01:59:56 <alp> jkarni, hello :)
02:00:09 <fendor> jkarni, naturally, thank you!
02:00:13 <fendor> alp, thanks, will do!
02:08:22 --- mode: ChanServ set +o Sigyn
02:31:56 <fendor> when using swagger-ui for servant, how to I have to define the `ToSchema` instance so that nested objects are flattened in the Json representation?
02:32:29 <alp> phadej, ^^^
02:33:36 <veverak> swagger is for haskell? \o/
02:57:44 <rkrishnan> I have a project where I have module specific Error types defined and the functions return an Either value. 
02:57:48 <rkrishnan> However, there are some functions that use these modules that can return one of these error types. How do we deal with such situations?
02:58:09 <rkrishnan> Is it a better idea to define all the errors for a library in one error type?
03:03:08 <fendor> what is the preffered way of application logging in servant?
03:03:54 <alp> use any of the wai logging middlewares
03:04:17 <fendor> alp, isnt that only for requests? 
03:04:22 <alp> https://hackage.haskell.org/package/wai-extra-3.0.22.1/docs/Network-Wai-Middleware-RequestLogger.html or https://hackage.haskell.org/package/wai-logger or anything else you'll find
03:04:35 <alp> no, middlewares can see the request come in and the response go out
03:04:46 <alp> and they can tweak the request on its way to the app or the response on its way to the client
03:05:16 <fendor> alp, and if i want to log service level stuff? 
03:05:49 <fendor> or should i also do that via wai-loggers?
03:06:33 <dmwit> bwe: As far as I can tell, this is exactly the same proof as last time, so my complaint from last time is exactly the same. (And the other folks responding to you more promptly said the same thing.)
03:08:04 <dmwit> rkrishnan: Why is it a problem that a function that uses those modules can return one of those error types?
03:08:22 <alp> so e.g you can write a middleware that turns <some request body> into { error: <the request body> } and adds the appropriate json content type header, whenever it sees a response being returned with status code 4xx
03:08:33 <cocreature> rkrishnan: make a sumtype that encompasses the errors that can be returned?
03:09:20 <alp> fendor, whatever is more appropriate. I don't really know what you mean by "service level", but if you mean things like "registered a new user with email foo@bar.com", then... well, it depends on what you want to do with those logs
03:10:32 <alp> it might be nice to put them somewhere separate, or maybe you really just want to see those things in your log files but they don't matter all that much
03:11:29 <alp> nothing prevents you from having a middleware that logs HTTP-level stuffs and another logging mechanism, sending the logs somewhere else, that lets you record all the things the handlers are doing
03:11:46 <alp> it all depends on what you want/need
03:11:47 <fendor> ok, i see, thank you!
03:12:02 <fendor> well, for now i just need debugging level logging
03:15:29 <rkrishnan> dmwit: an example is that one of the module is returning a cryptography specific error, another module is returning some other network error. I like the function to have some sort of an Either return value.
03:16:52 <dmwit> Sure. `Either` is sort of `Either`. Or you can make a custom combiner as suggested by cocreature.
03:16:54 <rkrishnan> cocreature: like an library wide error sum type? That is what I have now. I was wondering is that is a good approach or if it is a better approach to have a module specific error sum type because then the error type resides in the module than in another place.
03:17:22 <rkrishnan> dmwit: okay, sounds good. Thanks.
03:18:14 <dmwit> rkrishnan: I think this is the kind of thing cocreature was suggesting. PrintWarning and ParseWarning are module-specific errors, Diagnostic is a combined thing. https://github.com/dmwit/maryodel/blob/master/haskell/Dr/Mario/Protocol/Client.hs#L24-L70
03:18:35 <dmwit> (From some code I've been hacking on very recently, so it's fresh on my mind and easy to think of off-the-cuff. =)
03:20:16 <rkrishnan> dmwit: thanks a lot.
03:37:06 <ArahaelPi> It's incredible, how so many of the warnings shown by -Wall, indicate *real logic bugs*.
03:37:39 <maerwald> mostly just incomplete pattern matching ime
03:38:04 <ArahaelPi> That's what I'm experiencing, too - also unused variables.  Most of which turn out to be significant.
03:38:22 <ArahaelPi> Always hated that warning in other languages. In haskell, unused variables turn out to be surprisingly signfiicant.
03:44:37 <ArahaelPi> How do I cross compile this haskell app to windows, as a single exe?
03:45:05 <ArahaelPi> (Is it Easy, like Go, or Hard, like C++?)
03:45:16 <ArahaelPi> If it's hard, I probably won't bother. :(
03:49:50 <[exa]> crosscompiling C++ is hard?
03:50:18 <ArahaelPi> [exa]: Every tried it?
03:51:50 <[exa]> ArahaelPi: yeah, with mingw it boils down to something like ./configure TARGET=mingw32
03:52:03 --- mode: glguy set +v Viwor
03:52:38 <[exa]> given ofcourse your build system and toolchain is sane
03:53:07 <ArahaelPi> Right.  With Go, any Go compiler can crosscompile.
03:53:08 --- mode: glguy set +v zincy
03:53:36 <ArahaelPi> I can sit on macos, install Go, caring only that it's the latest version (because why the heck not), and do: 'GOOS=linux' go build, and it spits out a linux binary.
03:53:41 <ArahaelPi> Ditto for windows.
03:53:58 --- mode: glguy set -v Viwor
03:53:58 --- mode: glguy set -v Viwor
03:54:10 <ArahaelPi> With C++, I consider it hard, because you have to go around and find and configure the environment, and get things setup just right.
03:54:10 <Viwor> someone can help me with this error: https://gist.github.com/yohad/1e21b0811a5417329cd6a96f134e6f86 ?
03:54:28 <ArahaelPi> Was hoping Haskell isn't the same - ie, that Stack can take care of it for me.
03:55:54 <zincy> I have a minimal reproduction of the problem I am trying to solve here. Can't get it to compile. I am trying to Megaparsec to parse a comma separated list of values. https://pastebin.com/AjdXRdQ2
03:56:27 <byorgey> Viwor: looks like hsdev specifies unsatisfiable dependencies
03:56:48 <byorgey> Viwor: in particular it requires GHC 8.4, but also requires ghc-syb-utils, which requires GHC < 8.4
03:56:53 <[exa]> ArahaelPi: anyway I'm not sure what support for crosscompilation GHC has
03:57:10 <ArahaelPi> [exa]: No worries. I'll assume it's "hard".
03:57:14 <[exa]> ArahaelPi: but there's a 'safe bet': install GHC in wine and use it to produce windows executables
03:57:26 <byorgey> Viwor: if I were you I would ask the maintainer of hsdev about it
03:57:31 <[exa]> ArahaelPi: afaik it won't be even complicated,  you just do 'wine cabal build'
03:57:42 <Ariakenom> I know there has been recent work on cross compilation. But I don't know more.
03:57:42 <ArahaelPi> zincy: megaparsec, I think, will evaluate "many anychar" first, until it can't parse any more, and check for a 'char ,'
03:57:50 <ArahaelPi> [exa]: Nice.
03:58:11 <ArahaelPi> [exa]: Not sure what wine is like on macos, but that would be cool.
03:58:54 <Viwor> byorgey: is there a way for me to just get a binary?
03:59:20 <[exa]> ArahaelPi: it just works, see here: https://wiki.winehq.org/MacOS
03:59:25 <Ariakenom> zincy: your type annotation has "e0" and "s". That doesn't look right
03:59:42 <ArahaelPi> [exa]: Very nice. 
04:00:34 <cocreature> rkrishnan: yeah dmwit’s example is exactly what I was suggesting. use specific error types where there is only a specific error and then combine them in sumtypes if multiple errors can occur
04:03:27 <phadej> fendor: easiest way is to avoid manual ToJSON instance: therr more direct teanslation, the easier it is (can ise generics). otherwise, if ToJSON is manual, so ToSchema needs to be. I'm afraid that best way to see how to write them is to look how instances for basic types sre sefined in the lib.
04:08:07 <Ariakenom> "ghci is often used during development." How correct is this statement?
04:08:56 <hpc> just about universally correct
04:09:46 <hpc> stock vim + ghci is as good as an IDE
04:09:56 * ArahaelPi can't believe he just wrote a delphi parser, in his spare time, using delphi, in spare time over 2.5 weeks.
04:09:59 <Ariakenom> great thanks, just felt like making sure
04:10:06 <ArahaelPi> * With some bugs, obviously.
04:10:33 <hpc> isn't delphi like visual basic for even boringer people?
04:10:36 <cocreature> ArahaelPi: next step: write a Haskell to delphi compiler so you do not have to write delphi
04:10:39 <hpc> :P
04:11:06 <ArahaelPi> cocreature: The thought occurred to me. :)
04:11:39 <[exa]> hpc: visual pascal, yes
04:11:41 <cocreature> ArahaelPi: I’m sorry to inform you that you have been infected with the Haskell virus
04:12:06 <ArahaelPi> cocreature: Damn dibblego and his lets-lens.
04:12:12 <ArahaelPi> :)
04:12:30 <ArahaelPi> That's what really got me into Haskell.
04:12:40 <cocreature> lets-lens?
04:13:10 <ArahaelPi> Yeah, he has a bunch of excercises that steps you through to implementing the various lens.
04:13:50 <ArahaelPi> Honestly I'd been on-and-off learning haskell for a while, but lets-lens and this parser activity really got me set to using haskell.
04:14:10 <ArahaelPi> Incidentially, do people seriously use haskell to target other langauges?
04:14:33 <cocreature> oh I totally misread the name. I somehow thought this was about lenses for let-expressions and I have no what that should be :)
04:14:46 <ArahaelPi> Ah, no worries :)
04:15:01 <fendor> phadej, ok, so, the smartest way might be to define a dto type and a model object for my different purposes, right?
04:15:10 --- mode: glguy set +v Entroacceptor
04:15:20 <Entroacceptor> well, there's some serious Haskell to Javascript stuff
04:15:47 <ArahaelPi> But actualy, my next step is to fix all these warnings, and write quickchecks to try and demonstrate that my parser and AST are good.  There's bound to be a few issues.
04:16:06 <ArahaelPi> And there's still a few things I don't parse in Delphi.
04:16:44 <ArahaelPi> Entroacceptor: ghcjs, I know.
04:16:57 <ArahaelPi> Trouble is, I'm the only haskell dev on this team. The rest are all Delphi devs.
04:17:17 <cocreature> I guess eta probably counts for Haskell → Java
04:17:36 <ArahaelPi> Yes, but they don't produce idiomatic java (or javascript, as the case may be)
04:17:52 --- mode: glguy set +v noipmups
04:17:57 <noipmups> How to compose `f1 :: Foo -> IO a -> IO a` with `f2 :: Foo -> IO a` to get `f3 :: Foo -> IO a`?
04:18:23 <ArahaelPi> noipmups: Isn't that applicative?
04:19:17 <noipmups> ArahaelPi: It is. Thank you.
04:20:41 <Taneb> ArahaelPi: we compile Haskell to VHDL quite a lot here
04:20:59 <ArahaelPi> Taneb: Is that VHDL intended for people to edit though?
04:21:09 <ArahaelPi> Taneb: Or is VHDL merely the compiler output?
04:21:12 <Taneb> The latter
04:21:19 <ArahaelPi> Yeah, that makes sense.
04:21:20 <Taneb> I don't think anyone really wants to edit VHDL
04:21:39 <Ariakenom> True
04:21:47 <ArahaelPi> Taneb: "wants to" isn't neccessarily the issue at hand.
04:22:38 <Taneb> Fair
04:22:40 <noipmups> ArahaelPi: Can't wrap my head around this. Given type `(<*>) :: f (a -> b) -> f a -> f b`, what's `f` in this case?
04:23:07 <ArahaelPi> noipmups: That's not the complete type.
04:23:33 <phadej> fendor: I won't argue about smartness, but indeed it will separate concerns
04:23:55 <noipmups> ArahaelPi: What do you mean by "complete type"?
04:24:30 <ArahaelPi> noipmups: Eg, `Functor f =>` <-- That would be *part* of the type specification there.
04:26:24 <noipmups> ArahaelPi: Oh, I know. I omit the typeclass because I though it's well know in this case.
04:26:38 <ArahaelPi> noipmups: The point is that's what tells you what f is!!
04:27:50 <Ariakenom> noipmups: Are you looking to solve your problem at all or in some fancy way?
04:28:25 <Ariakenom> Otherwise declare a function and use do notation and I think you will get it.
04:29:34 <ArahaelPi> Ariakenom: I actually found that do notation impeded my haskell learning to start with.
04:31:42 <noipmups> Ariakenom: I already solved it. I'm just trying to understand the magic behind.
04:32:15 <fendor> phadej, ok, thanks!
04:33:19 <Ariakenom> noipmups: what do you have?
04:35:20 <noipmups> Ariakenom: Why (f1 :: Foo -> IO a -> IO a) <*> (f2 :: Foo -> IO a) = (f3 :: Foo -> IO a).
04:35:55 <noipmups> Ariakenom: Sorry for the syntax. I hope it's clear.
04:36:18 <dstolfa> did Megaparsec rename Parser to Parsec?
04:36:50 <olligobber> noipmups, looks like it's using the applicative instance for (->) Foo
04:37:31 <olligobber> noipmups, so it's applying the (IO a -> IO a) contained in f1 to the IO a contained in f2 to yield and IO a contained in f3
04:37:39 <quchen> (f <*> g) x = f x (g x)
04:37:52 <cocreature> dstolfa: no, Parser in "parsec" is just a type synonym for a specific form of Parsec. megaparsec just dropped that synonym
04:38:14 <dstolfa> cocreature: ah. that kinda broke my existing code
04:38:30 * dstolfa looks at Megaparsec and how to implement the type synonym
04:38:47 <Ariakenom> noipmups: But using <*> there seem like a bad idea imo
04:39:06 <dstolfa> ah, simple enough
04:39:22 <fendor> phadej, but doesnt this approach has a lot of code duplication if entities would share fields?
04:39:49 <cocreature> dstolfa: megaparsec doesn’t attempt to be API-compatible to parsec
04:39:54 <cocreature> there are quite a few differences
04:40:22 <ArahaelPi> Megaparsec 7 seems to have more differences, again.
04:40:49 <dstolfa> cocreature: yep -- but that's fine. i just defined type Parser myself
04:40:53 <dstolfa> it's quite simple to do so, so i don't mind
04:41:03 <olligobber> noipmups, `f3 = \x -> f1 x (f2 x)`
04:41:10 <noipmups> Ariakenom: What should be a good idea in this case?
04:42:12 <noipmups> olligobber: Thank you, I think I understand.
04:49:59 <dmwit> noipmups: That's a pretty obtuse use of (<*>). But it works because `(Foo ->)` is Applicative.
04:50:35 <dmwit> noipmups: And in the `(Foo ->)` instance for `Applicative`, the definition is `f <*> g = \foo -> f foo (g foo)`.
04:52:08 <dmwit> noipmups: Some other comments: there are many other type-correct ways to create `f3` that behave differently. For example, `f3 = f2`, or `f3 foo = f1 foo (f2 foo >> f2 foo)`.
04:52:53 <dmwit> ...or `f3 foo = f2 foo >> f2 foo`, or, or, or...
04:55:43 --- mode: glguy set +v c50a3262
04:55:55 <c50a3262> hey I'm just playing with Snap/Heist, just wondering if there's a nice way of doing something with CSS that plays well with these packages?
04:57:36 <c50a3262> looks like Clay is the most well known thing
05:20:00 --- mode: glguy set +v icedelta
05:50:30 <ventonegro> Neo rebooted the Matrix
06:05:46 <rkrishnan> cocreature: thanks.
06:26:05 <Zemyla> The continuation monad supports goto. Does the ntinuation comonad support comefrom?
06:26:25 <c_wraith> boo
06:27:11 <Zemyla> More seriously, is there a way to support comefrom?
06:28:49 <c_wraith> you could do it in a delimited fashion, the same way continuations provided delimited goto
06:29:14 <c_wraith> but it has the complication that it also adds nondeterminism
06:29:31 <c_wraith> and so you first need to actually define its semantics
06:30:25 <c_wraith> is it like a notification system, where reaching a label sends out a global notification and all listeners for that label then proceed?
06:30:44 <c_wraith> that would push you towards an actor model
06:31:06 <c_wraith> which is cool, but it's a lot less funny than calling it "comefrom"
06:31:57 <c_wraith> is this what an attempted spam attack looks like?
06:32:21 <ski> bwe : "if h is not defined yet, how can I reason about `h undefined`?" -- you should make sure your reasoning makes sense, regardless of how `h' could be defined. iow you should reason, for all possible `h'
06:33:12 <ski> bwe : if e.g. we have the definition `h _ = False', then `h undefined = undefined' does *not* hold. therefore, when reasoning about every `h', you can *not' assume that `h undefined' is equal to `undefined'
06:34:59 <dmwit> ski: You are missing some shared context.
06:35:10 <dmwit> ski: He is specifically proving something about fmap for  Maybe, not for arbitrary fmap.
06:35:39 <dmwit> bwe: (I think you should mostly ignore ski's objections for now because he did not know about this shared context.)
06:36:36 <dmwit> (For Maybe, it is correct that `fmap h undefined = undefined`, even without knowing what `h` is, because `fmap`'s implementation pattern matches on its second argument.)
06:37:18 <ski> ok, bwe didn't mention that five and a half hour ago
06:37:37 <dmwit> I know.
06:37:57 <dmwit> I don't fault you. This has been a days-long conversation, it's easy to miss out on parts of it.
06:38:24 <ski> still, they need to make an argument for that (as i suggested)
06:38:35 * ski nods
06:43:41 <quchen> A days long question about fmap for Maybe?
06:45:12 <Taneb> quchen: some people are thorough and/or distracted
06:46:44 --- mode: glguy set +v zincy
06:47:58 <zincy> Which combinator should I use from MegaParsec to take only 8 characters 
06:49:59 <quchen> replicateM 8 anyChar
06:50:19 <quchen> (A combinator is a lambda term with no free variables, you probably meant »function«)
06:51:08 <zincy> Whats a free variable?
06:51:17 <zincy> Thanks
06:51:25 <zincy> :t replicateM
06:51:26 <lambdabot> Applicative m => Int -> m a -> m [a]
06:52:11 <dmwit> zincy: First we define bound variables.
06:52:39 <dmwit> zincy: Bound variables are variables which are created by an enclosing `let` or lambda, or by a following `where`.
06:52:52 <dmwit> zincy: Free variables are variables which aren't bound.
06:52:59 <zincy> So a bound variable is a named variable?
06:53:11 <dmwit> zincy: For example, in `\x -> x + 3`, (+) is free.
06:53:57 <dmwit> zincy: Similarly, in `\n act -> sequence (replicate n act)` (the definition of `replicateM`), `n` and `act` are bound but `sequence` and `replicate` are free.
06:55:39 <zincy> So what about `\a -> \b -> a` .   b and a are both bound?
06:56:01 <dmwit> right
06:56:37 <dmwit> And in `\a -> b (\b -> b)`, one occurrence of `b` is bound and the other is free.
06:57:32 <Taneb> > map (\map -> map + map) [1,2,3]
06:57:34 <lambdabot>  [2,4,6]
06:58:08 <zincy> thanks dmwit! :)
06:58:18 <dmwit> > fmap fmap fmap (\fmap -> fmap) ["fnord", "fnord", "fnord"]
06:58:20 <lambdabot>  ["fnord","fnord","fnord"]
06:59:17 <zincy> So a free variable comes from outside the scope of the function it was defined it in if such a variable is not defined in the current scope
07:00:58 <ski> comes from outside the expression under consideration
07:01:49 <dmwit> zincy: That's the basic idea, yup!
07:01:49 <ski> bound variables can be renamed at will (if done consistently)
07:02:01 <zincy> :)
07:02:44 <ski> free variables can only be renamed if onealso renames them in the context surrounding the expression
07:04:09 <ski> `\x -> x^2 - 1' is (/ evaluates to) the same (function) value as `\t -> t^2  - 1'
07:04:32 <ski> `x^2 - 1' is not the same as `t^2 - 1'
07:05:42 <ski> lambdas, `where', `let', `case', defining equations (with formal parameter pattern) bind variables
07:06:06 <ski> zincy : makes sense ?
07:08:43 <ski> in math, bound variables occur e.g. in "big sigma" summation notation (and the corresponding "big pi" product notation), (both definite and indefinite) integral notation, Leibniz derivative notation (`d f(x) / d x'). bound variables are sometimes called "dummy" variables in math
07:10:13 <ski> (obviously also in definitions of functions like `f(x) = x^2 - 1' (which implicitly is to hold for all `x'. it's this implicit `forall x.' quantifier which really binds the variable here) .. hm, also `x' is bound in `{x : |R | 2 < x < 3}'
07:20:09 <glittershark> Does Template Haskell do associated type family instances as TySynD or TySynInstD?
07:22:33 <glittershark> I'm reading from https://ghc.haskell.org/trac/ghc/ticket/10891 that it's the latter, can someone confirm?
07:26:37 <lyxia> there's no way it could be TySynD since it only represents RHS of the form (MyTyFam var1 .. varn) as opposed to (MyTyFam (MyTyCon1 ...) ... (MyTyConn ...))
07:26:39 <mniip> % Language.Haskell.TH.runQ [d| instance Generic a where type Rep a x = a |]
07:26:39 <yahb> mniip: [InstanceD Nothing [] (AppT (ConT GHC.Generics.Generic) (VarT a_2)) [TySynInstD GHC.Generics.Rep (TySynEqn [VarT a_2,VarT x_3] (VarT a_2))]]
07:26:44 <mniip> glittershark, hope this answers your question
07:28:44 <glittershark> mniip: it does, thanks! always forget about runQ
07:33:15 <mniip> well
07:33:31 <mniip> % $(LitE $ StringL $ show $ [d| instance Generic a where type Rep a x = a |])
07:33:31 <yahb> mniip: ; <interactive>:22:3: error: Data constructor not in scope: LitE :: t0 -> Language.Haskell.TH.Lib.Internal.ExpQ; <interactive>:22:10: error: Data constructor not in scope: StringL :: String -> t0
07:33:56 <mniip> % $(Language.Haskell.TH.Syntax.LitE $ Language.Haskell.TH.Syntax.StringL $ show $ [d| instance Generic a where type Rep a x = a |])
07:33:56 <yahb> mniip: ; <interactive>:23:3: error:; * Couldn't match type `Language.Haskell.TH.Syntax.Exp' with `Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp'; Expected type: Language.Haskell.TH.Lib.Internal.ExpQ; Actual type: Language.Haskell.TH.Syntax.Exp; * In the expression:; Language.Haskell.TH.Syntax.LitE; $ Language.Haskell.TH.Syntax.StringL; $ show; 
07:36:57 <mniip> % $(Language.Haskell.TH.Syntax.LitE . Language.Haskell.TH.Syntax.StringL . show <$> [d| instance Generic a where type Rep a x = a |])
07:36:57 <yahb> mniip: "[InstanceD Nothing [] (AppT (ConT GHC.Generics.Generic) (VarT a_6989586621679106371)) [TySynInstD GHC.Generics.Rep (TySynEqn [VarT a_6989586621679106371,VarT x_6989586621679106372] (VarT a_6989586621679106371))]]"
07:46:16 <dmwit> ski: How could you forget foralls and existses?
07:49:57 <bwe> ski: I agree, I should have made it clear that g and h are undefined. Sorry for missing that point.
08:01:32 <laurus> Hello! I installed Hakyll via the Debian package system (libghc-hakyll-dev), so how do I do the "init" and "build" commands (when I type "stack" nothing is found).
08:04:41 <lyxia> laurus: is there a hakyll-init in your path? (I see hakyll has an executable with that name)
08:04:53 <laurus> lyxia: Yes, I was able to do that step :)
08:05:10 <laurus> But then when I cd to the "my-site" directory that it created, I don't know what to do.
08:05:19 <lyxia> ah
08:05:23 <lyxia> cabal build
08:05:35 <laurus> Oh, cool, that's working.
08:05:57 <lyxia> cabal exec my-site -- build
08:06:10 <laurus> lyxia: Thank you. So should I have used stack instead?
08:06:59 <lyxia> I don't think so.
08:07:03 <laurus> OK :)
08:08:12 <laurus> By the way, when I enter "cabal exec my-site -- build", I get "cabal: The program 'my-site' is required but it could not be found."
08:08:27 <laurus> There is a file called "site.hs" here
08:08:46 <lyxia> (You can use stack, but that will not use packages installed via your distro's package manager.)
08:08:59 <laurus> (Okay, I think I will stick with Cabal then. Thanks for that explanation.)
08:09:31 <lyxia> laurus: uh, there's a *.cabal file, and it should have a line    Executable something
08:09:38 <lyxia> what is "something"
08:10:04 <laurus> Yes, it says "executable site"
08:10:16 <lyxia> ah, try "cabal exec site -- build"
08:10:29 <laurus> "cabal: The program 'site' is required but it could not be found."
08:10:56 <lyxia> what about "cabal exec -- site build"
08:11:03 <lyxia> (I don't use cabal so I'm guessing)
08:11:12 <laurus> Same thing.
08:11:23 <laurus> Maybe I'll just uninstall everything and start using Stack so that the tutorial works :-/
08:12:30 <lyxia> ah it's "cabal run" instead of "cabal exec"
08:12:37 <laurus> lyxia: Oh :) Okay.
08:13:58 <laurus> lyxia: It worked :) Thank you so much.
08:14:14 <lyxia> The explanation of all this is that a hakyll site is an executable, here its name is "site". "cabal build" builds that executable, and "cabal run site", well, runs that executable.
08:14:28 <laurus> I see.
08:14:30 <lyxia> running that executable generates your static site.
08:14:48 <laurus> Okay.
08:23:30 <droplet> Must I be in the project directory to run stack test, or is there some way of telling stack which directory I want it to run in?
08:26:21 <tdammers> current directory, or any of its subdirectories that isn't a stack project itself
08:26:27 <tdammers> just like with git and similar tools
08:26:52 <tdammers> although you can use stack outside of stack projects, at least some of its commands
08:27:45 <droplet> But there's no way of telling stack I want it to run as if its in a given directory?
08:44:58 <Athas> GHC 8.6 is coming out Real Soon Now, right?
08:49:25 <Boarders> does anyone know if it is possible to have a constraint of the form: instance (c ~ A a b c, C1 a, C2 b, C3 c) => Class c
08:49:37 <Boarders> or do I need to have UndecidableInstances for this?
08:50:00 <Boarders> sorry that should be d ~ A a b c, {...} => Class d
09:04:44 <lyxia> yes you need the extension if d is a variable
09:06:04 <Boarders> does anyone know if there is any movement on this: https://ghc.haskell.org/trac/ghc/ticket/9269
09:09:45 <dexterfoo> Boarders: try asking in #ghc
09:12:23 <_sfiguser> ok by definition a Closure is a function that remembers the environment at which it was created. so since in FP each function should return always the same result with the same parameters, a closure ins't broking this principle ? 
09:14:13 <rotaerk> _sfiguser, how would a closure return a different result in different calls with the same parameters?
09:14:17 <dexterfoo> _sfiguser: no. because haskell has no "variables", the environment can never change after the function was created. this is at least one way of looking at it
09:17:27 <cocreature> closures become really boring from a users perspective in a language where all values are immutable
09:58:08 <maerwald> who cares about immutability!
10:02:52 <tdammers> _sfiguser: the crucial thing to understand is how evaluation and execution are completely separate concerns in Haskell - the language itself only covers evaluation, execution happens in the runtime
10:03:24 <maerwald> tdammers: and it's not very well defined, is it?
10:03:59 <tdammers> _sfiguser: but Haskell closures happen in the realm of the language, not the runtime - so when you close over a variable, the closure inherits the variable's value, but that has no influence on the execution side of things
10:04:03 <maerwald> so what you gain in terms of reasoning because of "purity" you lose because you have no idea what the runtime does
10:04:55 <tdammers> maerwald: what you gain is that you can reason (almost) equationally about one fairly well-guarded side of things, as opposed to most other languages, where the two concerns are completely intertwined
10:05:41 <maerwald> that doesn't mean that the product is less well defined
10:05:49 <maerwald> and the product is what you care about as a programmer
10:05:49 <tdammers> maerwald: you still can't reason very well about the execution part; but fortunately, a lot can be done purely in the evaluation part, and that part is pure (ignoring bottoms and unsafePerformWhatevers)
10:06:04 <tdammers> it's still a win
10:06:11 <maerwald> I'm not too sure about that
10:06:42 <tdammers> worst case you end up writing imperative code
10:06:53 <tdammers> imperative haskell is still more or less on par with other imperative languages
10:07:00 <dstolfa> tdammers: BRRRRRRRRRR no imperative code here!
10:07:10 <tdammers> dstolfa: I said "worst case", didn't iI
10:07:43 <tdammers> and by "writing imperative code", what I obviously meant is "writing pure code in an EDSL that models the semantics of imperative code"
10:09:11 <dstolfa> tdammers: i am happy now
10:09:26 <tdammers> phew.
10:12:17 --- mode: glguy set +v crick_
10:13:46 <EvanR> was about to say
10:15:40 <maerwald> tdammers: imperative haskell is not on par with other imperative languages
10:15:51 <dolio> tdammers: You really need to explain what the difference between "evaluation" and "execution" is if you're going to say things like that.
10:15:52 <maerwald> it's much more easy to reason about what I get in rust, Go or even C
10:16:17 <dolio> Saying they're different things is kind of jargon specific to this irc channel.
10:16:18 <maerwald> you have laziness, lazy bytestring, must use seq and deepseq to not screw up pointers and GHC functions, ...
10:16:26 <EvanR> cutesy syntax to deal with exceptions would be nice
10:16:45 <EvanR> terrible for loops are a bit stilted in haskell
10:17:07 <EvanR> when you are updating variables or objects
10:17:40 <dstolfa> i choose to ignore undefined and seq
10:18:17 <tdammers> dolio: fair point
10:18:18 <cocreature> dstolfa: ignore as in “refuse to use” or ignore as in “I reason loosely about my code as if they do not exist”
10:18:48 <maerwald> what most people don't get is... abstraction doesn't just improve reasoning, it also complicates it in some ways
10:18:52 <EvanR> i reason precisely about code as if they dont exist :)
10:18:53 <dstolfa> cocreature: probably both
10:19:18 <maerwald> so a lot of abstraction is the worst you can get if you want to reason on low-level
10:19:47 <EvanR> maerwald: a good abstraction will compartmentalize the reasoning into a nice part and the remainder, the gotchas or assumptions
10:19:51 <maerwald> haskell would be a 100% no-go in automotive industry for example. Impossibly to verify the compiler or any other tool
10:20:16 <cocreature> dstolfa: refusing to use "seq" is pretty bad imho :)
10:20:24 <EvanR> C compilers are verified?
10:20:29 <EvanR> in practice?
10:20:32 <maerwald> EvanR: yes.
10:20:38 <EvanR> o_O
10:20:41 <ChaiTRex> seq is great for the top-level strict bindings that GHC hates.
10:20:49 <dstolfa> cocreature: SHH!
10:20:52 <cocreature> there are verified C compilers, not all C compilers are verified
10:21:03 <dstolfa> EvanR: veircomp
10:21:05 <dstolfa> vericomp*
10:21:31 <dstolfa> no
10:21:32 <EvanR> i need to learn these things
10:21:34 <dstolfa> compcert
10:21:34 <dstolfa> wtf
10:21:37 <dstolfa> my brain is not working
10:21:44 <dstolfa> i replaced verilog compiler with compcert
10:21:48 * dstolfa stops talking
10:21:59 <EvanR> i knew that existed but not if its in real world use
10:22:01 <ricky_clarkson> maerwald: How does that work for self-driving cars? afaik they use machine learning, which sounds hard to formally verify.
10:22:11 <dstolfa> ricky_clarkson: they don't
10:22:20 <dstolfa> there's very little formal verification in practice
10:22:44 <dstolfa> there's compcert which tries to prove that all transformations it does are valid, but that depends on a formal model of the underlying architecture -- which we've been shown is wrong recently with meltdown and spectre
10:22:46 <glguy> Eaton talked about how they use Haskell to program their garbage trucks
10:24:12 <maerwald> I wouldn't touch haskell for anything that has non-functional requirement of high reliability or runtime correctness
10:24:28 <maerwald> especially because of laziness and its side-effects
10:24:37 <EvanR> non functional...
10:24:38 <maerwald> and the GC, anyway
10:24:44 <EvanR> i like that one
10:24:58 <maerwald> EvanR: yes, you know what non-functional software requirements are right? :)
10:24:59 <ChaiTRex> But garbage trucks need GC.
10:25:09 <maerwald> lol
10:25:11 <EvanR> can you clarify
10:25:12 <glittershark> lel
10:25:16 <maerwald> EvanR: no.
10:25:20 <EvanR> gret
10:25:30 <maerwald> that's so basic you can probably google it
10:26:01 <dstolfa> i'm gonna go ahead and say that i'm not a parctical person at all. i find haskell *practical*
10:27:00 <metalrain> haskell is somewhere in spectrum of practical
10:27:13 <maerwald> we still haven't explored enough about haskell
10:27:37 <maerwald> it's too early to make statements imo
10:28:12 <EvanR> @faq is haskell practical
10:28:12 <lambdabot> https://wiki.haskell.org/FAQ
10:29:34 <dstolfa> maerwald: well, it's practical to me in the sense that it's the target language for my executable, formal & symbolic specification
10:30:50 <shapr> maerwald: be nice!
10:31:12 <maerwald> shapr: ?
10:32:22 <shapr> ricky_clarkson: oh hey! I haven't seen you around in YEARS! when did you get back?
10:34:41 <ricky_clarkson> shapr: Hi. I kind of dropped off IRC as I was using internal stuff I couldn't really ask/answer questions about in public.
10:35:54 <shapr> oh exciting
10:36:01 <shapr> ricky_clarkson: so you back from outer space now?
10:38:48 <ricky_clarkson> shapr: Just hanging around here in hopes of getting inspired to learn something (free monads, monad transformers) or refresh some stuff I learned and forgot (lenses, those funky inverted iterators whose name I forget, other stuff).
10:43:38 <shapr> ricky_clarkson: got any cool projects you're working on?
10:43:41 <shapr> coming to ICFP perhaps?
10:49:06 <ricky_clarkson> Sadly not.
10:49:45 <shapr> neither?!
10:49:52 * shapr hugs ricky_clarkson 
10:50:08 --- mode: glguy set +v olakunle
10:50:59 <glguy> olakunle: check your messages
10:51:00 <byorgey> shapr: are YOU coming to ICFP?
10:51:12 <shapr> byorgey: yes!
10:51:15 <shapr> first time in 12 years!
10:51:18 <byorgey> shapr: yay!
10:52:05 <dstolfa> wait
10:52:06 <dstolfa> when is ICFP
10:52:09 * dstolfa had a knee surgery
10:52:14 * dstolfa hopes to MAAAYBE make it
10:52:37 <byorgey> dstolfa: September 23-29
10:52:41 <dstolfa> booger
10:52:41 <dstolfa> can't
10:52:45 <byorgey> =(
10:52:47 <shapr> anyone else going to ICFP?
10:52:50 * dstolfa sobs
10:52:52 * mnoonan <-
10:53:09 <shapr> mnoonan: w00! bringing a banjo?
10:53:10 <mnoonan> (well, the Haskell Symposium bit anyway)
10:53:17 <shapr> I can bring a unicycle again this time.
10:53:18 * glguy is heading down this year. Haven't been since '08
10:53:25 <shapr> glguy: awesome!
10:53:41 <mnoonan> shapr: given all of the horror stories I've seen about flying with instruments, I think that's a "no"
10:53:49 <shapr> aw, too bad
10:54:03 <byorgey> yeah, turns out instruments aren't very good for flying
10:54:05 <shapr> My unicycle did get damaged flying out of London airport
10:54:06 <byorgey> planes work better
10:54:16 <shapr> byorgey: ba-dum TISH
10:54:22 <mnoonan> most recent was a guitar that was skewered by a forklift, airline offered to pay back the cost of the case.
10:54:32 <shapr> :-(
10:54:38 <mnoonan> (not mine)
10:55:38 <shapr> any cool after hours gatherings planned? should we have a #haskell gathering?
10:56:54 <fenedor> what would be a good use case of event sourcing? It looks like it is great, if you require an audit trail, since the audit trail is inherently created and can be used to query the state of a software at any given time.
10:57:10 --- mode: glguy set +v sent1nel_
10:57:17 <maerwald> fenedor: financial industry
10:57:18 --- mode: glguy set -v sent1nel_
10:57:20 <shapr> I know there's CUFP, but I kinda wish for a media steering group for Haskell as wel
10:57:24 --- mode: glguy set +v sent1nel_
10:57:25 <sent1nel_> less great use case for event sourcing: edits to a word document
10:57:45 <sent1nel_> (i've seen it used that way; no bueno)
10:58:20 <fenedor> sent1nel_, why is that not a good idea? for example, what if you need to know about any change in the correct order?
10:58:25 <maerwald> fenedor: check https://tech-blog.capital-match.com/posts/3-anatomy-of-haskell-web-app.html but it's not too much about the business use case of the decision
10:58:27 <fenedor> maerwald, may I ask why?
10:58:48 <maerwald> well, if someone sues you, you gotta be prepared no?
10:59:11 <maerwald> and it may actually boil down to your proving that there has been no error in your system
10:59:18 <shapr> wat?
10:59:37 <sent1nel_> fenedor: imagine a document with hundreds of thousands of changes. essentially you are maintaining a perfect record of hundreds of thousands of events, probably with snapshots. usually, you don't need that record; nobody ctrl+zs back to the first character of document, typically, from a publishable state.
10:59:44 <maerwald> because you are not saving state
11:00:25 <maerwald> event sourcing is horribly slow for startup though, unless you have a snapshotting system, which an be quite tricky
11:00:36 <fenedor> maerwald, you mean, if I have to prove for example that a user read a file at a specific time, event sourcing might make sense? Is event sourcing fitted for audit trails, or should that be handled by something else?
11:01:00 <fenedor> maerwald, i think, `eventful` or something like that has a snapshotting feature already
11:01:06 <maerwald> well, that... and that your core business logic can be totally pure!
11:01:12 <sent1nel_> snapshotting isn't that tricky, but it can be. another problem: without snapshots or a search index, good luck looking up an aggregate by any field by anything other than id, such as an e-mail address for user aggregates
11:02:10 <fenedor> sent1nel_, i get that but if you have to maintain for legal reasons, it might be a sensible implementation, right?
11:02:19 <maerwald> another thing that is quite annoying is migrating your model...
11:02:47 <sent1nel_> you'd have to have a bulletproof use case for me to recommend using event sourcing in that context
11:02:59 <fenedor> sent1nel_, yeah, it does not matter if it is slow, because most interaction should be with the most recent version
11:03:14 <maerwald> I cannot say for sure, but wrt financial business logic, event sourcing may also be the natural choice, as in: it's actually easier compared to just storing state
11:03:42 <fenedor> sent1nel_, in pharma industries, changes made to a data file have be versioned and saved, you have to prove with which version of a file the results have been obtained with. 
11:05:13 <maerwald> but model migration is really complicated, unless you choose to create snapshots after every change and remove all migration code afterwards :o
11:05:29 <fenedor> maerwald, what is model migration?
11:05:43 <maerwald> you might have to read the blog post I linked
11:05:58 <maerwald> model... as in, what data/events exist and are serialized
11:05:59 <dmj`> TIL ghci has a :complete command 
11:06:05 <dmj`> mind blizown 
11:06:13 <maerwald> if you change any of that data, what happens with the serialization of old events?
11:06:59 <olakunle> Hello every one
11:07:05 <maerwald> your old events now have different data than your current codebase, but still need to be loaded to construct the final state
11:07:25 <maerwald> so that's a lot of migration for every single thing
11:07:46 <maerwald> although some things don't need migration (e.g. just adding a constructor)
11:09:26 * lambdabot waves to olakunle
11:09:52 <fenedor> maerwald, ill read the blog first, thanks for the resource! 
11:10:21 <maerwald> fendor: here is a sophisticated approach to defining migrations https://tech-blog.capital-match.com/posts/4-json-migration.html
11:10:47 <maerwald> but you really buy into a set of problems too... however, you gain some nice things
11:12:09 <maerwald> https://www.youtube.com/watch?v=lKIPlARq1z8
11:12:18 <fenedor> i think so, too. The main disadvantage is model migration?
11:12:37 <maerwald> I wouldn't say that
11:12:44 <maerwald> it's just an annoyance
11:14:13 <fenedor> what would you say are disadvantages, except if it is just not the use case
11:14:20 <maerwald> basically you are maintaining a large set of pure event/command/model code, which... in the end really does almost nothing, in terms of actual business logic implementation. Then you create services (see the blog post) which is the only part where you can do something useful
11:14:42 <maerwald> and now the actual problem is: you have an architecture, but you have no architecture. Because you stuff almost everything useful into the service layer... ugh
11:16:51 <maerwald> so it's a bit of a fake architecture in my opinion and hides the real problem
11:17:08 <maerwald> or maybe someone else has figured out how to do it better, no idea :P
11:23:34 <fenedor> but what is the problem to solve? for example, I want to implement a versioned filesystem that is accessed over a Servant API. Currently, the versioning is done by git and abusing `git notes` (dont judge me, I did not choose). Although i have to eventually mutate a real filesystem, saving the history in a pure manner sounds like a nice architecture to me.
11:24:07 <maerwald> that sounds like an interesting use case
11:24:22 <maerwald> and is probably less complicated in terms of logical layers
11:24:45 <maerwald> my point is... if you have a lot of different *models* things become hairy
11:25:03 <maerwald> because only the services can communicate between models
11:25:14 <maerwald> but services are what you want to avoid!
11:26:30 <fenedor> i think i see what you mean, but in this case it would be a single model, the state of the filesystem
11:26:44 <maerwald> that's pretty straight forward I guess
11:27:11 <maerwald> also, the domain is well defined, so you would probably not mess a lot with the model data structures
11:28:59 <fenedor> mhm, i think i might write a small proof of concept. Thanks for the blog posts and yt vid, ill go through them first!
11:29:29 <olakunle> So I have this problem with haskell-src-exts.....it's preventing my haddock build
11:29:47 <olakunle> Any way I can ask haddock to skip it
11:29:53 <maerwald> also, one nice advantage of event sourcing is the single source of truth concept... you can have multiple independent "views" on your data, just by having other "clients" read the events, transform and present them however they want (and possibly cache the state and do a pub-sub thing)
11:30:24 <maerwald> but there is no doubt that the source of absolute truth is always your event store
11:31:43 <fenedor> yeah, that is actually an requirement as well!
11:32:19 <maerwald> it's not the most performant thing though... even when you use snapshotting
11:33:36 <fenedor> i think that is fine, one can build other indexing tools and also since normally only the most recent state is required, it does not matter if rarely used features are slow
11:34:27 <maerwald> yes, but loading your filesystem will take a long time
11:36:14 <glguy> olakunle: You'll have to give people a lot more information than that about what you're doing and what's going wrong. gist.github.com is good for sharing commands you tried and the resulting output
11:36:28 <maerwald> could be useful to have a user specify the max history entries or something so that you have a snapshot that is constantly moving forward
11:36:32 <maerwald> like your bash history
11:36:50 --- mode: glguy set +v crick_
11:38:42 <maerwald> fenedor: if your implementation is interesting, I might write a GTK filemanager for it :P
11:39:37 <maerwald> mind you, no asynchonicity!
11:41:04 <fenedor> maerwald, hehe, we'll see, so far it is just an idea.
11:41:29 <maerwald> well, you can't really have stuff writing asynchronous to the event store
11:41:33 <maerwald> that would blow everything up
11:41:44 <maerwald> and the main problem of filesystem is that they allow exactly that
11:43:45 <glguy> crick_: Read your messages
11:43:47 <fenedor> yeah, thats true. events must be reduced sequentially. 
11:44:06 <maerwald> or you write a dependency based filesystem where asynchronous writes are allowed as far as files are *logically* independent... now you use shake to define those dependencies and set deadlocks, lol!
11:44:33 <maerwald> (this was a joke)
11:45:41 <crick_> glguy: I don't get you
11:46:11 <glguy> crick_: There's a tab near the top of your web browser with my name on it
11:46:27 <crick_> Yep
11:46:30 <glguy> click it
11:46:36 <crick_> I read
11:47:01 <crick_> I will be voiced meaning?
11:47:19 <fenedor> maerwald, deadlocks would probably be bad :D 
11:47:57 <glguy> crick_: meaning you can talk now that you were marked +v 10 minutes ago, but your first message was lost
11:48:03 <maerwald> you can call them semaphores, same thing
11:52:42 <olakunle> glguy: sorry about that. check out better explanation here https://gist.github.com/noxecane/7b940c18585247572e3a5a40569c72ef
11:55:53 <olakunle>  /msg NickServ VERIFY REGISTER olakunle thuwkghwmwtj
11:57:15 <dataN> if 'Monoid i' gives 'maybe mempty (mappend a) b :: Monoid i => i -> Maybe i -> i', whats a function of type 'w -> Maybe x -> x'? 
11:59:19 <dataN> Monoid implements it, as does (Exists x,Exists (w->x->x))
12:00:00 --- mode: glguy set -v crick_
12:00:29 --- mode: glguy set -v olakunle
12:01:32 <geekosaur> er? aren't the only implementations of that type along the lines of foo _ (Just x) = x; foo _ _ = undefined ? you can't do anything with the w, because you know literally nothing about it
12:02:49 <dataN> the constraint gives access to; exists :: w -> x -> x
12:04:14 <dataN> which along with 'exists :: x' gives a function of type 'w -> Maybe x -> x'
12:04:59 <crick_> Can someone please have a look at this code: https://lpaste.net/6835155905705672704
12:05:20 <crick_> I am trying to implement the function 'flatten'
12:05:31 <byorgey> dataN: what constraint?  You asked 'what's a function of type w -> Maybe x -> x'
12:05:36 <byorgey> I don't see any constraints.
12:05:45 <crick_> Which does the job of indenting expressions correctly
12:06:01 <crick_> I am not able to get it right
12:06:58 <dataN> byorgey; (Exists x,Exists (w->x->x)) is a constraint, where; 'class Exists x where exists :: x'
12:07:17 <dataN> its like using ImplicitParams
12:07:44 <dataN> Monoid would also be a constraint 
12:07:50 <byorgey> dataN: I understand that.  But I don't understand your question.
12:07:52 <geekosaur> why do I always have the feeling that dataN is wrking in a type system that is self-consistent but has little if anything to do with Haskell's?
12:08:55 <byorgey> dataN: are you asking something like "given   _ => w -> Maybe x -> x, what constraints can be filled in for _ to make it inhabited"?
12:09:05 <dataN> geekosaur: its just sugar for writing classes as tuples. 
12:10:54 <dataN> byorgey: 'given' is used specifically in the context of Reflection, so Exists is preferable. its also the basecase of a recursion over Empty :: (f :: k -> *)
12:13:09 <dataN> type Monoid x = (Exists x,Exists (x->x->x)); type ?1 x w (Exists x,Exists (w->x->x)); type ?2 w x = w -> Maybe x -> x
12:13:34 <crick_> \QUIT
12:13:45 <dataN> both Monoid and ?1 can be used to provide default implementations for ?2
12:14:39 <dataN> type Act w x = Exists (w->x->x) is a reasonable name as it represents the left group action
12:15:09 <dataN> ?1 then seems to be something like a left Semigroup? 
12:15:09 <lambdabot> tH3n SeEMz t0 bE zOm3thing 1Ik3 a lEph+ 53/\/\i9r0up?
12:15:17 <dataN> !!
12:15:46 <dataN>  and the question is "whats ?2" 
12:15:47 <dataN> ?
12:17:54 <dataN> class Act w x where act :: w -> x -> x 
12:18:39 <dataN> oops, there was an Exists missing from ?2 above...
12:18:54 <dataN> class ?2 w x where ??? :: w -> Maybe x -> x
12:19:47 <dataN> is this the type of something encountered somewhere where it is given a name?
12:21:33 <dataN> perhaps as '(w,Maybe x) -> x' is contrarywise of 'x->(w,Maybe x)' which is some kind of safe version of State, this is some Safe version of Act?
12:23:54 <dataN> but there are many examples for such safe versions (e.g. for the more familiar example of State);
12:23:54 <dataN>  s -> (a,s) | s -> (Maybe a,s) | s -> (a,Maybe s) | s -> Maybe (a,s)
12:25:23 <dataN> maybe there is some convention to be aware of for naming the ways of distributing kind (* -> *) type over a pair? 
12:25:51 <dataN> any ideas ?
12:26:17 <dataN> possibly the lens folks have such conventions? 
12:30:36 <dataN> not sure if also considering e.g. 'Maybe s -> (a,s)' would confuse it more... but its kind of not really a pair :-/
12:31:18 <dataN> and distributing things over arrows seems even worse! especially as half of it is curried 
12:31:58 <dataN> sure lens should have this kind of stuff down 
12:32:46 <dataN> recall something about permuting tuples and multivariate functions...
12:39:56 <dataN> damn, its that fmap over the nth parameter stuff again. except now half the parameters are separated by arrows and half are in a tuple. 
12:40:07 <dataN> helpf
12:44:19 <dataN> hmm, maybe its kind of like a nested thing, where the first distribution over the outer layer which is the arrow (Maybe s -> (a,s) | s -> Maybe (s,a)) and then there is also the option of descending into the second argument, as it is also a kind of product type (s -> (Maybe a,s) | s -> (a, Maybe s))
12:46:36 <dataN> ok, sure, thats the way, so, how is that done? are these Traversals? can they be generated into a list and then retrieved using (!!)? 
12:47:56 <dataN> (at type level obviously)  
12:51:35 <dataN> is it normal to encounter type level traversals?
12:52:01 <dataN> is there any documented examples anywhere?
12:52:37 <dataN> still not sure how to do it, probably has something to do with type families or something... 
12:53:58 <dataN> is there a way to write these types at value level and then promote them?
12:59:00 <the_2nd> can I somehow use http://hackage.haskell.org/package/optparse-applicative to parse a list?
12:59:18 <the_2nd> e.g. --items=a,b,c
12:59:31 <lyxia> sure
13:00:18 <the_2nd> how so?
13:00:45 <lyxia> the_2nd: http://hackage.haskell.org/package/optparse-applicative-0.14.2.0/docs/Options-Applicative-Builder.html#v:option the first argument is an arbitrary parser
13:02:32 <the_2nd> so right now I'm using strOption to parse a single string
13:02:58 <the_2nd> and would like to parse [String]
13:03:12 <the_2nd> is the syntax via the comma then just as I wrote?
13:04:45 <the_2nd> just using option doesn't seem to work
13:06:22 <the_2nd> lyxia, https://stackoverflow.com/questions/34889516/optparse-applicative-option-with-multiple-values/34894035#34894035 looks good
13:10:22 <crick_> I am trying to follow the book: "Implementing functional languages" by Peyton Jones. I am stuck at the pprinter section. Can someone help me out?
13:15:10 <[exa]> crick_: well, you need to state what is the exact thing you're stuck at
13:18:06 <the_2nd> lyxia, seems like multiple dirs with spaces will be tricky, hm
13:18:26 <the_2nd> I think I'll need some unquoting logic afterwards
13:24:57 <crick_> exa: I am trying to write a pretty printer. Have a look at this code: https://lpaste.net/6835155905705672704.
13:26:23 <crick_> I am stuck at the definition of flatten function
13:28:04 <crick_> [exa]: The book: https://www.cse.iitb.ac.in/~as/fpcourse/PJ_DL_book.pdf
13:34:52 <AndreasK> Any suggestions for a map where elements have multiple keys? Thinking of having a map from the keys to a unique key, and then using Data.Map from there.
13:36:37 <davean> AndreasK: BiMap
13:36:48 <davean> Depending on what yo uwant
13:37:31 <AndreasK> davean: I need only a one direction map, but have multiple keys per element
13:38:32 <AndreasK> So eg keys 1 and 2 refer to the same element: lookup 1 = x, lookup 2 = x, lookup 3 = y, ...
13:50:51 <monochrom> The standard Data.Map supports non-injectiveness. fromList [(1,x), (2,x), (3,x), (4,y), (5,y)]
13:53:00 <davean> And you get inherant sharing due to laziness, etc. But that doesn't give you a "delete x" operation or the like
13:53:03 <davean> hence asking what he wanted
13:55:36 <monochrom> Did he say he was looking for "delete x"?
13:56:32 <geekosaur> sounds to me like a 2-level map
13:57:06 <monochrom> No, it sounds to me when he described a 2-level map it was an XY problem.
13:57:49 <davean> No, thats why I said I had no idea what he needed
13:57:53 <davean> he hasn't said much at all :/
14:09:42 <infinisil> What's you people's favorite way to handle exceptions/errors in haskell?
14:10:02 <monochrom> Depends on particulars.
14:10:06 <infinisil> My mind tells me that I want to have a guarantee that the program doesn't crash, and that everything should be well typed
14:10:28 <infinisil> So these IO exceptions don't sound very nice, and neither does MonadFail 
14:10:34 <monochrom> So how about this. My favourite way is to actually study the actual problem and make a wise choice.
14:11:33 <infinisil> Hmm.. Well let's assume it's a complicated application with multiple layers that each can throw errors, you write all the code yourself, no external code used, so you get to choose the error mechanism of every part
14:11:36 <fresheyeball> hey out there
14:11:46 <fresheyeball> I am taking in stdin as a conduit
14:11:51 <[exa]> cross_: sorry, I was afk
14:12:01 <fresheyeball> and its going to be accepting a comma seperated list as stdin
14:12:12 <geekosaur> except you don't, because the standard library does stupid things like exposingh synchronous file-open errors as async exceptions
14:12:15 <[exa]> (oh, wrong highlight)
14:12:36 <infinisil> geekosaur: Heh right, okay let's say you can wrap everything in your favorite way to handle errors
14:13:00 <fresheyeball> any recommendation on how to split by `Producer IO ByteString` on ',' such that the new conduit has one per item?
14:13:10 <fresheyeball> "foo,bar" -> ["foo","bar"]
14:13:13 <fresheyeball> but with conduits
14:13:47 <infinisil> That makes me think.. Isn't there some way to make libraries output the "most general error type", such that it can be converted to anything the user desires? Via some typeclass of course
14:13:59 <monochrom> I stick to the standard IOExceptions for IO things. For non-IO things, they already use Maybe or Either already.
14:14:41 <fresheyeball> Also sourceHandle stdin :: Producer IO ByteString confuses me
14:14:49 <fresheyeball> because ByteString is already a stream
14:15:12 <fresheyeball> so it this? what the equlivlant of [ByteString] or ByteString?
14:15:39 <threewood> infinisil:  Some errors are different than others.  File not found and Out of Memory are quite different
14:16:13 <monochrom> Yeah why are you afraid of "it depends"?
14:19:09 <threewood> And different still are assertion failures where we know something went wrong, but often not exactly what went wrong
14:20:00 <threewood> I think the best answer to this last state is compartmentalized failure
14:20:14 <threewood> Kill everything in a certain sandbox and start over
14:21:02 <threewood> But you might want to do something more sophisticated like look through a log of actions...
14:21:12 <threewood> In summary: see monochrom's answer
14:21:25 <AndreasK> davean: Deleting is sadly required
14:31:47 <AndreasK> monochrom: I didn't think of using Map that way but your right. I will just go with that and add the list of keys (shared) to the value. That way it's straightforward how to delete all references as well
14:32:04 <AndreasK> So "Map Key (Keys,Value)"
14:32:59 <dmwit> (Map k v, Map v (Set k))
14:34:21 <infinisil> threewood: monochrom: Yeah probably, thanks, I'll just see what goes when I code bigger stuff :)
14:34:29 <dmwit> Map k (Set k, v), like you propose, doesn't offer as efficient a way to find a starter key for a given value that you want to delete.
14:35:17 <dmwit> It also makes key deletion less efficient, because you must update all sibling keys, whereas with mine you need only update the key itself and the set in the other map.
14:37:04 <dmwit> There is the relation package for (Map k (Set v), Map v (Set k)), which make be close enough for your needs.
15:29:46 <AndreasK> dmwit: Deletion is an all or nothing thing (so if I delete I always delete all keys) and there is always a starter key available in my use case. I see how your approach is better in the general case, but it doesn't offer an advantage in this particular case.
15:32:30 <AndreasK> I use it to look up items by (unique) properties. So I always have the key. If I modify the item the properties aren't valid anymore so I have to delete all old entries and insert the entries for the modified item.
16:24:45 --- mode: glguy set +v ellis_phee
16:24:47 <ellis_phee> any1 know a good channel to talk about Lean
16:27:26 <greymalkin> Is there a canonical version of Data.Function.& that can nest ($) ?
16:27:59 <c_wraith> like, has a precedence of (-1)?
16:28:02 <greymalkin> If not, what would be the best way to do `X (operator) unless $ test)`
16:28:09 <ChaiTRex> ellis_phee: Maybe #leanprover
16:28:15 <c_wraith> because no. 0 is the lowest precedence
16:28:16 <ChaiTRex> ellis_phee: Not really sure, though.
16:28:38 <greymalkin> c_wraith: If it had the same precedence, wouldn't it be read right-to-left?
16:28:46 <greymalkin> er... left-to-right?
16:29:33 <ChaiTRex> ellis_phee: Here's a conversation that ends with someone creating that channel: https://groups.google.com/forum/#!topic/lean-user/xpgrgXqKgpU
16:34:50 <hpc> greymalkin: sometimes, you just gotta use parens
16:36:34 <greymalkin> hpc: Yeah, I have some rather long predicates though; I was hoping to be able to cleanly deliniate them :(
16:37:03 <philippD> greymalkin: move them into a let or where clause
16:37:51 <Mitsos101> is this program's behavior well-defined? https://lpaste.net/7086486443995955200
16:42:50 --- mode: glguy set +v bgavran
16:49:17 <bgavran> Hi all!
16:49:33 <bgavran> Does this work? I'm still trying to figure out spacemacs and irc 
16:49:54 <benzrf> hi bgavran
16:50:53 --- mode: glguy set +v bgavran
16:51:01 <glguy> Yeah it's working
16:51:03 <bgavran> hi! So it works
16:54:05 <bgavran> It's my first time on #haskell. I've been playing with haskell since about one year ago and I can't really see myself going back :) Glad to be here!
16:54:11 <bgavran> not sure about the rules and stuff
16:56:22 <hpc> bgavran: everything's made up and the points don't matter
16:56:29 <hpc> if you ever acquire points, use @pl to remove them :D
16:58:02 <bgavran> @pl
16:58:02 <lambdabot> (line 1, column 1):
16:58:02 <lambdabot> unexpected end of input
16:58:02 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
16:58:26 <hpc> @pl \x -> f x
16:58:27 <lambdabot> f
17:00:53 <Mitsos101> however
17:00:58 <Mitsos101> @pl \x y -> [x, y]
17:00:58 <lambdabot> (. return) . (:)
17:01:10 <Mitsos101> on (++) pure is shorter
17:01:17 <benzrf> yikes
17:02:01 <bgavran> @pl \a b -> a + b
17:02:01 <lambdabot> (+)
17:02:05 <bgavran> oh this really works haha
17:02:47 <philippD> @pl let a = a in a
17:02:47 <lambdabot> fix id
17:02:50 <philippD> wow
17:03:02 <c_wraith> huh. that one is cute.
17:03:15 <c_wraith> it is certainly equivalent!
17:03:35 <philippD> it is but I didn't think it was smart enough for that
17:03:56 <c_wraith> it uses fix for recursion all the time.
17:05:17 <c_wraith> @pl fac n = if n == 0 then 1 else n * fac (n - 1)
17:05:18 <lambdabot> fac = fix (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1))
17:06:02 <kranius> how does that command even work ?
17:06:38 <hpc> oh yeah, it gets pretty stupid if you have type errors too
17:06:40 <benzrf> structural recursion on terms, i'd imagine
17:06:50 <c_wraith> iiuc, it basically rewrites lambdas to somethingkke ski combinators
17:06:52 <hpc> @pl \f a b -> [f a, f a b]
17:06:52 <lambdabot> liftM2 ap (((.) . (:)) .) (flip flip [] . ((flip . ((:) .)) .))
17:07:04 <philippD> https://github.com/bmillwood/pointfree
17:07:05 <c_wraith> err, something like
17:09:07 <Maxdamantus> @pl let a = a in let b = b in a b
17:09:07 <lambdabot> fix id (fix id)
17:09:23 <benzrf> @pf test
17:09:23 <lambdabot> Maybe you meant: pl bf
17:09:43 <benzrf> @bf ++,
17:09:43 <lambdabot>  Done.
17:09:50 <benzrf> oh, it's not brainfuck?
17:09:59 <Mitsos101> @help bf
17:09:59 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
17:10:04 <kranius> @unpl fix id
17:10:04 <Mitsos101> hmm
17:10:04 <lambdabot> fix (\ x -> x)
17:10:21 <Mitsos101> @unpl on (++) pure
17:10:21 <lambdabot> on (++) pure
17:10:23 <philippD> @unpl fix
17:10:23 <lambdabot> fix
17:10:29 <benzrf> @bf ++.
17:10:29 <lambdabot>  Done.
17:10:33 <benzrf> hrm
17:10:43 * benzrf double checks which command is which
17:11:01 <benzrf> @bf +++++++++++++++++++++.
17:11:01 <lambdabot>  Done.
17:11:05 <benzrf> smh
17:11:30 <kranius> @pl \(a,b) -> (b,a)
17:11:31 <lambdabot> uncurry (flip (,))
17:11:31 <benzrf> bbl
17:11:36 <benzrf> :t swap
17:11:37 <lambdabot> (a, b) -> (b, a)
17:11:41 <benzrf> ftfy
17:12:19 <philippD> @pl \(a,b,c) - > (c,b,a)
17:12:19 <lambdabot> (line 1, column 7):
17:12:19 <lambdabot> unexpected "c"
17:12:19 <lambdabot> ambiguous use of a non associative operator
17:12:35 <philippD> @pl \(a,b,c) -> (c,b,a)
17:12:35 <lambdabot> (line 1, column 7):
17:12:35 <lambdabot> unexpected "c"
17:12:35 <lambdabot> ambiguous use of a non associative operator
17:13:31 <c_wraith> it seems to only know pairs, not arbitrary tuples
17:13:53 <kranius> unfortunate
17:13:55 <philippD> @pl \(a,(b,c)) -> ((c,b),a)
17:13:55 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip (flip . ((,) .) . flip (,)))
17:14:29 <philippD> :t (`ap` snd)
17:14:30 <lambdabot> ((a1, a2) -> a2 -> b) -> (a1, a2) -> b
17:16:02 <ricky_clarkson> @pl \a : b : c : Nil -> [c,b,a]
17:16:02 <lambdabot> ap ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . (((.) . (const .) . flip (:)) .) . flip (:) . return . head) tail
17:16:33 <Mitsos101> @pl \[a,b,c,d,e,f,g] -> [g,f,e,d,c,b,a]
17:16:33 <lambdabot> (line 1, column 2):
17:16:33 <lambdabot> unexpected "["
17:16:33 <lambdabot> expecting pattern
17:16:45 <Mitsos101> @pl u [a,b,c,d,e,f,g] = [g,f,e,d,c,b,a]
17:16:45 <lambdabot> (line 1, column 20):
17:16:45 <lambdabot> unexpected " "
17:16:45 <lambdabot> expecting operator
17:17:20 <ChaiTRex> @pl \(a:b:c:d:e:f:g:[]) -> [g,f,e,d,c,b,a]
17:17:20 <lambdabot> (line 1, column 17):
17:17:20 <lambdabot> unexpected "["
17:17:20 <lambdabot> expecting "()", natural, identifier, "_" or "("
17:17:38 <ChaiTRex> @pl \(a:b:c:d:e:f:g:[]) -> g:f:e:d:c:b:a:[]
17:17:38 <lambdabot> (line 1, column 17):
17:17:38 <lambdabot> unexpected "["
17:17:38 <lambdabot> expecting "()", natural, identifier, "_" or "("
17:17:50 <philippD> @pl \a:b:c:d:e:f:g:Nil -> [g,f,e,d,c,b,a]
17:17:50 <ChaiTRex> @pl \(a:b:c:d:e:f:g:xs) -> g:f:e:d:c:b:a:xs
17:17:53 <lambdabot> ap (flip ap tail . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . (flip .) . ((ap .) .) . flip flip head . (flip .) . (((.) .) .) . flip flip tail . (flip .) . ((
17:17:53 <lambdabot> flip .) .) . (((ap .) .) .) . flip flip head . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip (flip . (flip .) . ((
17:17:53 <lambdabot> flip .) .) . (((flip .) .) .) . (((((.) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) .
17:17:53 <lambdabot> (((flip .) .) .) . ((((flip .) .) .) .) . ((((((.) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . (((((flip (:) .) .) .) .) .) . ((((flip (:) .) .) .) .) . (((flip (:) .) .) .) . ((flip (:) .) .) .
17:17:53 <lambdabot>  (flip (:) .) . flip (:) . (: [])) head) tail) head) tail . head) tail
17:17:55 <lambdabot> optimization suspended, use @pl-resume to continue.
17:17:58 <lambdabot> ap (flip ap tail . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . (flip .) . ((ap .) .) . flip flip head . (flip .) . (((.) .) .) . flip flip tail . (flip .) . ((
17:17:59 <lambdabot> flip .) .) . (((ap .) .) .) . flip (flip . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip (flip . (flip .) . ((flip .)
17:18:00 <ricky_clarkson> flipping heck
17:18:01 <lambdabot>  .) . (((flip .) .) .) . (((((.) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((
17:18:03 <lambdabot> flip .) .) .) . ((((flip .) .) .) .) . ((((((.) .) .) .) .) .) . (((((flip ((.) . (:)) .) .) .) .) .) . ((((flip ((.) . (:)) .) .) .) .) . (((flip ((.) . (:)) .) .) .) . ((flip ((.) . (:)) .) .) . (
17:18:05 <hpc> stahp
17:18:05 <lambdabot> flip ((.) . (:)) .) . flip ((.) . (:)) . (:)) head) tail) head) tail) head . head) tail
17:18:23 <kranius> scary
17:18:47 <benzrf> lol
17:19:07 <c_wraith> just think of it as abstract ascii art
17:19:11 <ricky_clarkson> lambdabot: obfuscated haskell generator
17:19:31 <Mitsos101> i think there's an unnecessary flip around there
17:19:50 <philippD> Mitsos101: which one? :D
17:20:30 <geekosaur> lambdabot's just being unnecessarily flip
17:22:03 <ab9rf> wow
17:22:06 <philippD> @pl let f = \l -> case l of { [] -> []; (a:as) -> f as ++ [a] }
17:22:06 <lambdabot> (line 1, column 25):
17:22:06 <lambdabot> unexpected "{"
17:22:06 <lambdabot> expecting variable, "(", operator, ";" or "in"
17:22:15 <ab9rf> impressive
17:22:43 <philippD> @pl \a -> let f = \l -> case l of { [] -> []; (a:as) -> f as ++ [a] } in f a
17:22:43 <lambdabot> (line 1, column 31):
17:22:43 <lambdabot> unexpected "{"
17:22:43 <lambdabot> expecting variable, "(", operator, ";" or "in"
17:22:55 <cobax> so this is the state of the art in terms of reproducibility - nix generating a docker image atop alpine? https://cs-syd.eu/posts/2018-07-14-nix-docker-haskell
17:23:31 <ab9rf> i've got "figure out how to use docker with stack" on my to-do list
17:23:35 <Mitsos101> @pl f xs = if empty xs then [] else (f (tail xs) ++ (pure (head xs)))
17:23:35 <lambdabot> f = fix (ap (flip if' [] . empty) . (`ap` (pure . head)) . ((++) .) . (. tail))
17:24:06 <cobax> ab9rf: also there is a stack2nix thing but I never ended up using it
17:24:32 <ab9rf> cobax: i'm still learning how to use docker in general, so using it with stack is "advanced" for me
17:24:40 <philippD> cobax ab9rf: use nix and cabal, no need for stack anymore
17:24:58 <cobax> philippD: is that the latest? if so, I need to catch up badly.
17:25:00 <philippD> ab9rf: and with nix you kind of don't need docker
17:25:18 <philippD> cobax: it works for me like a charm
17:25:20 <ab9rf> philippD: i'm windows-based
17:25:34 <ab9rf> philippD: at least much of the time
17:25:56 <philippD> ab9rf: THEN YOU ARE LOST!!
17:26:29 <cobax> philippD: do you have an example codebase? the return to cabal seems weird to me, what is the lts tied to, or how do you resolve package conflicts?
17:26:46 * ab9rf puts philippD on the "people who will evangelize instead of help" list
17:27:57 <philippD> cobax: like with stack nix provides you with a set of package versions but it's easier to customize that set of packages
17:29:08 <philippD> cobax: and you can just switch the GHC version like that. I use it here https://github.com/chisui/dakka
17:29:43 <philippD> too bad clever isn't here right now
17:30:41 <cobax> I'm looking at it now... I see dakka.nix, line 7, packages without versions specified
17:31:25 <cobax> because it's pegged on default.nix line 3 I guess.
17:31:36 <cobax> interesting, thanks for the link!
17:33:22 <glguy> cobax: the dependency solver is quite good, and you can fix a particular set of dependencies with a freeze file. there are fewer conflicts like you used to get with the old cabal-build because new-build can handle more than one copy of the same version of a package with difference dependencies, and those are all able to be cached across multiple build directories to save rebuild time like you used to get with separate sandboxes
17:34:12 <philippD> glguy: I don't use new-build, just nix+cabal
17:35:07 <cobax> glguy: seems like you're doing yet a variant on what philippD is doing? interesting
17:38:08 <glguy> cobax: I just didn't read far enough back to see all of what has been discussed perhaps. I just thought the topic was about build options
17:40:23 <philippD> To be honest I didn't bother reading up on new-build since I use nix and it works and I use it for everything now, even non Haskell stuff. Is new-build useful for me?
17:40:34 --- mode: glguy set +v mac10688
17:41:03 <mac10688> I'm doing an exercise and I need to create a function frequency :: Int -> [Text] -> Map Char Int to run in parallel. What haskell function will let me dictate the number of workers without changing the signature?
17:43:36 <glguy> philippD: someone else will have to compare them; I haven't used nix. new-build supports backpack, which I've been looking at recently. I don't know if you get that with nix or not
17:44:14 <philippD> glguy: yeah, backpack doesn't work with that out of the box
17:44:30 <philippD> but I haven't looked at packpack much as well so ...
18:10:53 <mac10688> Does anyone know if this problem is possible to solve in haskell?
18:10:54 <mac10688> Your code should contain a frequency :: Int -> [Text] -> Map Char Int function which accepts a number of workers to use in parallel and a list of texts and returns the total frequency of each letter in the text.
18:11:40 <mac10688> I haven't seen a function to let me determine the number of workers to use in parallel. I've seen that that's set at compile time
18:12:05 <philippD> there is always unsafePerformIO.
18:12:45 <mac10688> lol that doesn't sound good
18:12:49 <mac10688> but I'll check into it
18:13:04 <MarcelineVQ> How are you getting the parallelism?
18:13:06 <glguy> http://hackage.haskell.org/package/parallel-3.2.2.0/docs/Control-Parallel-Strategies.html#g:7
18:13:24 <glguy> unsafeInterleaveIO isn't applicable
18:14:20 <glguy> Or you can use forkIO to split up the job and then accumulate the results with a Chan
18:17:16 <mac10688> the strategies will return an Eval Monadic type. Is it possible for me to use a monad inside a function defined as frequency :: Int -> [Text] -> Map Char Int
18:17:18 <mac10688> ?
18:20:09 <mac10688> hmm maybe runEval. I will check this out
18:40:28 <rotaerk> https://hackage.haskell.org/package/constraints-0.10.1/docs/Data-Constraint.html
18:40:52 <rotaerk> it says "Pattern matching on the Dict constructor will bring this instance into scope."  
18:41:00 <rotaerk> what does it mean to bring an instance into scope?
18:41:44 <lyxia> it means that it can be used in instance resolution
18:42:17 <lyxia> if you have a Dict (Show a) and you try to show a, you will get an error if you didn't pattern match on the Dict.
18:43:39 <rotaerk> hmm, are you saying that instead of:  myShow :: Show a => a -> String; myShow a = show a
18:43:58 <rotaerk> I can instead do:  myShow :: Dict (Show a) -> a -> String; myShow Dict a = show a
18:44:25 <lyxia> yes
18:44:42 <rotaerk> interesting
18:51:05 --- mode: glguy set +v PrimeNate32
18:51:59 <PrimeNate32> Hi.
18:53:18 <OmegaDoug> Hi. I'm trying to write a semigroup instance for a custom datatype but can't seem to pass a variable from the stimes function to the handler function. I can't figure out the error.
18:53:47 <OmegaDoug> Any help would be appreciated: https://gist.github.com/DouglasBrunner/5d4518590bde3e445aaa0efae7a790db 
18:56:54 <lyxia> OmegaDoug: replicate (fromIntegral x) ...
18:57:41 <OmegaDoug> lyxia: thanks. I was so close. Just noticed that replicate doesn't take an Int
18:57:42 <OmegaDoug> Thanks
18:57:47 <lyxia> the numeric classes are quite a confusing mess
18:58:44 <OmegaDoug> Yeah, 
18:58:46 <OmegaDoug> that they are
19:29:31 <ArahaelPi> *sigh*, bug in hindent. :(
19:30:04 <ArahaelPi> I defined a data type: Foo `As` Bar; and it strips the `'s.
19:30:51 <glguy> Like you had: x :: Int `Either` Bool   with the TypeOperators extension?
19:31:35 <ArahaelPi> glguy: I'm not using that extension, but yes, I guess.  I had data Foo = Foo `As` Foo
19:31:43 <ArahaelPi> (Amongst a whole bunch of other constructors)
19:31:54 <glguy> You can't use it without that extension...
19:32:03 <ArahaelPi> Seems to be working fine?
19:32:13 <glguy> Maybe you enabled it in your .cabal file
19:32:46 <ArahaelPi> Not as a ghc option ,no.
19:32:51 <MarcelineVQ> It's not a type operator it's a data constructor
19:33:23 <MarcelineVQ> which are valid to infix with ` `  if you don't want something like  :>
19:34:17 <glguy> Right, you don't need the extension at the value level. I was focused on having defined a data type
19:37:20 <MarcelineVQ> even then though it's fine it seems.    data a `Ger` b = Gor a b   is valid   data a :++ b = Bor a b   needs the extension  
19:38:00 <MarcelineVQ> > Left 3 :: Int `Either` Bool
19:38:02 <lambdabot>  Left 3
19:38:33 <MarcelineVQ> lambdabot must have it enabled, since I didn't actually expect that to work though
19:38:46 <MarcelineVQ> since it seems declarations and useage are different
19:39:02 <glguy> For maximum consistency you appear to be able to define a data type with `` syntax but not use that type without the extension
19:39:11 <MarcelineVQ> This seems to be the case
20:07:03 <rotaerk> hmm why is it that with `Dict :: a => Dict a` serves as evidence of `a`, but `Sub :: (a => Dict b) -> a :- b` doesn't serve as evidence of `a`, and instead *requires* `a`
20:09:47 <rotaerk> -with
20:16:05 <rotaerk> f :: Dict (Show a) -> a -> String; f Dict = show  -- valid
20:16:26 <rotaerk> f :: Show a :- Show a -> a -> String; f (Sub Dict) = show  -- invalid
20:16:50 <rotaerk> I'm just unclear why one proves the constraint and the other requires it
20:18:18 <rotaerk> f :: x => x :- Show a -> a -> String; f (Sub Dict) = show  -- valid, but I don't think it can be used
20:18:28 <glguy> rotaerk: Show a :- Show a    means, if you can provide an instance of Show a, then you get an instance of Show a
20:18:45 <rotaerk> yeah, I understand the semantics of it, I just don't understand why it behaves that way
20:18:56 <jle`> rotaerk: are you asking about why in terms of the implementation?
20:18:57 <glguy> The field has type: (a => Dict b)
20:19:11 <glguy> rotaerk: So when you match on that you get the b constraint, but you have to provide the a one
20:19:16 <jle`> or why in terms of why it's useful
20:19:53 <rotaerk> I'm asking why in the case of Dict, the constraint in its type is *provided* (i.e. the Dict serves as evidence that the constraint is met)
20:20:03 <rotaerk> but the constraint in the type of the (a => Dict b) is *required*
20:20:11 <rotaerk> what's the key difference there
20:20:15 <jle`> you're asking about why as in why Dict was chosen to do that, or why as in how it is implemented?
20:20:29 <jle`> i guess i'm asking if you're asking about the design decisions, or about the implementation
20:20:30 <rotaerk> the latter I guess
20:20:38 <glguy> rotaerk: is confused about how ExistentialQuantification works
20:21:00 <glguy> rotaerk: In the case of Dict the constraint is outside the data constructor
20:21:08 <jle`> okay, so you understand *why* edwardk wanted Dict and Sub, but you don't understand *how* he implemented them to fulfill his vision
20:21:12 <glguy> in the case of (:-) the constraint is inside the data constructor
20:21:44 <glguy> data Dict a = a => Dict
20:21:56 <glguy> data a :- b = Sub (a => Dict b)
20:22:08 <rotaerk> ah, hmm
20:25:32 <rotaerk> glguy, what does ExistentialQuantification have to do with constraints?
20:26:14 <rotaerk> all I know about that is that you can use forall on a type variable to control its scope and thus force a parameter to remain generic
20:26:18 <rotaerk> polymorphic *
20:26:25 <glguy> That's the extension that allows you to do put constraints on the outside of the data constructor like that
20:27:06 <rotaerk> oh.
20:27:14 <rotaerk> didn't realize it did more than forall
20:27:31 * rotaerk reads up on the extension.
20:27:48 <glguy> Or you can do with with GADT syntax: data Dict :: Constraint -> Type where Dict :: a => Dict a
20:28:30 <glguy> While sub needs RankNTypes
20:28:30 <glguy> data (:-) :: Constraint -> Constraint -> Type where Sub :: (a => Dict b) -> a :- b
20:29:05 <rotaerk> oh... I was confusing RankNTypes and ExistentialQuantification
20:30:55 <glguy> Have you heard about types in positive and negative positions before?
20:30:59 <ArahaelPi> glguy: So...  It's a bug in hindent? :)
20:31:04 <rotaerk> nope
20:31:10 <glguy> ArahaelPi: sounds like it
20:31:10 <rotaerk> no idea what that means
20:31:21 <ArahaelPi> Cool. :)
20:32:15 <glguy> rotaerk: In a type like:   Int -> Bool     Bool is in a positive position and Int is in a negative one. Every time you go to the left of an -> arrow  the polarity switches positive to negative
20:32:33 <glguy> positive positions are the types of values you get, negative ones are the ones you have to give
20:32:45 <glguy> so in the case of this function  we have to provide the Int to use this function
20:32:53 <glguy> we get back a Bool
20:33:02 <rotaerk> right
20:33:24 <glguy> (Int -> Bool) -> Char
20:33:35 <jle`> rotaerk: if you recognize that Dict lets us essentially talk about `foo :: c => b` as `foo :: Dict c -> b`
20:33:54 <jle`> then Sub (a => Dict b) is basically Sub (Dict a -> Dict b)
20:33:56 <glguy> To use this we're going to get Char and Int. We'll have to provide Bool. let's try and make such a thing
20:34:36 <glguy> > let example p = [x | x <- ['a' .. 'z'], p (fromEnum x) ]
20:34:38 <lambdabot>  <no location info>: error:
20:34:38 <lambdabot>      not an expression: ‘let example p = [x | x <- ['a' .. 'z'], p (fromEnum ...
20:34:44 <glguy> ?let example p = [x | x <- ['a' .. 'z'], p (fromEnum x) ]
20:34:46 <lambdabot>  Defined.
20:34:48 <glguy> :t example
20:34:49 <lambdabot> (Int -> Bool) -> [Char]
20:34:57 <glguy> well, [Char] instead of Char, whatever :)
20:35:00 <rotaerk> close enough
20:35:00 <rotaerk> hehe
20:35:23 <glguy> You can see that that implementation is providing the Ints via fromEnum. I'm on the hook to provide Bools back in
20:35:37 <glguy> Int and [Char] are in positive positions, Bool is in negative one
20:35:41 <glguy> > example even
20:35:43 <lambdabot>  "bdfhjlnprtvxz"
20:36:05 <glguy> The same pattern happens with => arrows, too
20:36:12 <rotaerk> jle`, those look like the same thing to me, since Sub is basically ignorable, it's `Dict c -> b` vs `Dict a -> Dict b`.  Except the former somehow proves c while the latter requires a
20:36:17 <glguy> in negative positions are the constraints you have to provide
20:36:25 <glguy> in positive positions are the ones you get
20:37:09 <jle`> rotaerk: yes, they are really the same, entail :: a => Dict b, is the same thing as entail :: Dict a -> Dict b
20:37:26 <rotaerk> glguy, I see...
20:37:33 <jle`> so Sub could really be written as newtype a :- b = Sub (Dict a -> Dict b)
20:38:09 <jle`> which makes the Category instance a lot more clear
20:38:29 <jle`> instance Category (:-) where id = Sub id; Sub f . Sub g = Sub (f . g)
20:38:37 <jle`> huh that's cuter than i thought it would be
20:39:09 <rotaerk> - -> +   and   -(- -> +) -> +  :.  (+ -> -) -> +
20:40:43 <rotaerk> - => +   and  -(- => +) -> +  :.  (+ => -) -> +
20:41:14 <ab9rf> that is starting to look disturbingly like an esolang
20:41:24 --- mode: glguy set +v mac10688
20:41:25 <rotaerk> it's certainly pseudolang
20:41:43 <ab9rf> "Design a programming language using ONLY punctuation."
20:41:50 <rotaerk> that explanation helped though, thanks
20:41:51 <glguy> mac10688: https://freenode.net/kb/answer/registration
20:45:33 <rotaerk> hmm, with ->, a positive position is obtained from the function, and a negative position is provided to the function by the caller of it.  Having trouble with the analogy for =>
20:46:04 <mac10688> thanks glguy, I'll look into that
20:46:57 <rotaerk> with a constraint in a negative position, it means ... the expression is requiring the caller to resolve the constraint by choosing a compatible type
20:47:15 <rotaerk> and if it's in a positive position, it means ... the expression serves as evidence of the constraint?
20:48:56 <rotaerk> hmm that seems roughly accurate, thinking through the examples
20:53:34 <mac10688> I am now identified I believe
20:53:48 <mac10688> I am a bone fide user
20:54:03 <glguy> You did it!
21:00:01 <rotaerk> hmm reading the user guide on ExistentialQuantification; never actually done that before.  I think my understanding of forall came from some stupid source, and it didn't distinguish RankNTypes and EQ
21:27:02 <jle`> congrats mac10688 :)
21:27:08 <jle`> you will always remember this day
21:27:15 <mac10688> :D <3
21:27:22 <jle`> i still remember the first time i got authenticated/identified on irc
21:27:30 <jle`> i divide my life into pre-auth and post-auth
21:27:52 <MarcelineVQ> This entire situation is sickening.
21:28:08 <mac10688> And you've always asked yourself, does the IRC server hash passwords?
21:29:13 <jle`> probably not
21:29:25 <jle`> IRC is also a plaintext protocol
21:29:38 <jle`> so if you use a sensitive password then an MTM already has it, im sorry
21:29:55 <glguy> You don't have to use a password, you can use an asymmetric key pair
21:30:05 <centril> can we make this any shorter?
21:30:07 <centril> msort = let merge = \case ([], xs) -> xs; (xs, []) -> xs; (x:xs, y:ys) -> if (x < y) then x:merge (xs, y:ys) else y:merge (x:xs, ys) in \case [] -> []; [x] -> [x]; xs -> merge $ msort *** msort $ splitAt (length xs `div` 2) xs
21:30:10 <mac10688> yeah 8 years ago someone in the computer lab told me all passwords were stored in plain text. That's why I wasn't so eager to register lol
21:30:44 <glguy> Other options: https://github.com/glguy/irc-core/wiki/Automatically-authenticating-to-NickServ#sasl-username-and-ecdsa-key
21:31:31 <jle`> glguy: oh hey, thanks for the tip :)
21:31:58 <jle`> centril: that's already way too short to be readable lol
21:32:05 <jle`> well, it's pushing the limit
21:32:13 <centril> jle`: hihi
21:32:23 <centril> jle`: I'm disappointed I have to  msort *** msort
21:32:26 <jle`> if we're golfing, then you can get rid of a lot of those spaces
21:32:29 <centril> feels like base should have a function for that
21:32:37 <jle`> i think msort=let merge=\case ... should be legal syntax
21:32:49 <centril> jle`: probably is; but spaces stay in ^.^
21:32:59 <jle`> oh, so what is the objective here?
21:33:05 <jle`> is it code golf, or...
21:33:52 <jle`> i guess it could be just for fun :)
21:34:09 <jle`> centril: usually i use bimap msort msort
21:34:17 <jle`> or `join bimap msort` sometimes
21:34:27 <jle`> i consider (***) to be deprecated in favor of bimap these days if you're using tuples
21:34:35 <centril> jle`: well... this started out as showing the expressiveness of Haskell... you can do a oneline quicksort, so I wanted to see how short one can make a mergesort
21:34:59 <jle`> personally if i saw this i would runs far away as possible from this language ;_
21:35:01 <jle`> ;)
21:35:12 <jle`> but everyone is different
21:35:13 <centril> jle`: fair =P
21:35:23 <centril> jle`: I hate points; I want to be free of them
21:35:45 <centril> but I guess it's pretty pointless
21:36:24 <jle`> i hate points.  they're course and rough and irritating and they get everywhere
21:36:56 <MarcelineVQ> From my point of view the pointless is evil
21:37:08 <MarcelineVQ> The nicest example of mergeSort is the one in base  http://hackage.haskell.org/package/base-4.11.1.0/docs/src/Data.OldList.html#sort
21:38:06 <jle`> centril: btw if you want cuteness points, this recursive helper function pattern can be encapsulated in Data.Function.fix
21:38:19 <centril> MarcelineVQ: what is this... No LambdaCase! :P
21:39:37 <centril> jle`: I actually tried that but it didn't go so well
21:39:48 <centril> (didn't give it a lot of effort...)
22:37:10 <ArahaelPi> I'm still writing my Delphi Parser. (The last 10% takes forever to do...), however, it strikes me that once I have this, figuring out how to compile it should be relatively easy?
22:39:09 <jle`> famous last words
22:44:29 <johnw> does "scanl mappend mempty" have a name/idiom associated with it?
22:47:21 <ChaiTRex> Is there any way to write a rewrite rule guaranteed to fire before those included with GHC and its bundled libraries?
22:51:22 <MarcelineVQ> johnw: that's fun looking, what are you using it for?
22:52:04 <johnw> MarcelineVQ: too late at night for that discussion. :) It turns up in a couple of places if you google, but I just wondered if anyone recognized it.
23:22:21 <cocreature> ChaiTRex: I don’t think so. you could try a high phase number and increase -fsimplifier-phases but I doubt all rules in GHC have phase annotations that only trigger in phase <= 2
23:22:39 <cocreature> ChaiTRex: it also sounds like an xy problem, what are you actually trying to achieve here?
23:49:23 <veverak> hi folks
23:49:35 <veverak> with Optional.Applicative - how to approach something like 'rest of the line' ?
23:49:55 <veverak> I've haskell script that read some data and runs binaries over files it founds
23:50:38 <veverak> and I would like to pass a argument options to those binaries..., so I need to collect those options with parser
23:51:29 <veverak> commands CMD [-s|--select ARG] [-d|--debug] [-b|--binary ARG]     <- this is what I have now, soemthing like commands CMD [-s|--select ARG] [-d|--debug] [-b|--binary ARG] [...args for binary...] would be nice 
