00:00:00 <lambdabot>  5
00:00:05 <MarcelineVQ> > succ 2
00:00:07 <lambdabot>  3
00:00:12 <MarcelineVQ> > pred 2
00:00:14 <lambdabot>  1
00:00:19 <mnrmnaugh> best one i think i got was inc a b = [(-a)..(b-1)]; add a b = length (inc a b) -- but using '-' is cheating, since its... negate something, i forget
00:00:35 <gabeugca2> take 5 [1,1.5..]
00:01:03 <gabeugca2> > take 5 [1,1.5..]
00:01:05 <lambdabot>  [1.0,1.5,2.0,2.5,3.0]
00:01:22 <mnrmnaugh> ya, i just found succ/pred, seems decent, but then i noticed that succ is enumFrom . + enumTo -- that is not it, but, ye
00:01:27 <mauke> > let add a b = length (replicate a () ++ replicate b ()) in add 2 3
00:01:29 <lambdabot>  5
00:02:11 <mnrmnaugh> well it all started when i noticed there was a subtract and div, but no add or multiply. i guess sum almost counts, but not really
00:02:24 <mnrmnaugh> prefix notation ftw \o/
00:02:52 <mnrmnaugh> oooo replicate
00:02:52 <mauke> subtract only exists because unary - is in the language
00:03:01 <mauke> it's a hack
00:03:11 <mauke> div is integer division, as opposed to /
00:03:15 <mauke> > 2 / 3
00:03:17 <lambdabot>  0.6666666666666666
00:03:19 <mauke> > 2 `div` 3
00:03:21 <lambdabot>  0
00:03:23 <mnrmnaugh> it looked a bit eugh, tbh
00:03:42 <koz_> Wow, I actually have a legit use case for a contravariant functor.
00:03:43 * hackage fastparser 0.3.1.1 - A fast, but bare bones, bytestring parser combinators library.  http://hackage.haskell.org/package/fastparser-0.3.1.1 (SimonMarechal)
00:03:43 <mnrmnaugh> ya i know div is for non floats, thanks tho
00:03:46 <mauke> and we have ^, ^^, ** for exponents
00:04:27 <mnrmnaugh> orly, ** too. im more a fan of ^ and ^^ myself. every time... python whyyyyy
00:05:08 <mauke> > let add a b | a .&. b == 0 = a .|. b | otherwise = add (a `xor` b) ((a .&. b) `shiftL` 1) in add 2 3
00:05:10 <lambdabot>  5
00:05:23 <mnrmnaugh> i got the hang of the, eh, style of recursion today. not bad for a week
00:05:28 <mnrmnaugh> owo
00:05:57 <mauke> .oO( notices your .|. )
00:06:06 <mnrmnaugh> i do not know . and i tried gaurds like twice. ill stick to if and case for now
00:06:10 <koz_> mauke: That's Haskellese for 'bitwise or'.
00:06:35 <mauke> mnrmnaugh: .&. is bitwise and, .|. is bitwise or
00:06:45 <mnrmnaugh> ahhhhh ok. hmmm
00:08:20 <mnrmnaugh> im so bad at bitwise stuff, even in c :D shifts i get, can never remember how to xor tho
00:08:31 <mauke> there are only 4 cases
00:08:38 <koz_> mnrmnaugh: Xor is 1 if they're different, and 0 otherwise.
00:08:44 <mauke> > [xor 0 0, xor 0 1, xor 1 0, xor 1 1]
00:08:46 <lambdabot>  [0,1,1,0]
00:08:59 <koz_> It's short for eXclusive OR.
00:09:08 <mnrmnaugh> ya, but applied over a list, i knew how to do that once...
00:09:20 <mauke> ... list?
00:09:25 <Axman6> foldr xor?
00:09:36 <koz_> > [ x `xor` y | x <- [0,1], y <- [0,1]]
00:09:37 <lambdabot>  [0,1,1,0]
00:09:55 <koz_> Or even
00:09:58 <mnrmnaugh> like eh, i do not know the eqivelent.. i meant with pen and paper :p
00:10:12 <koz_> > [ (x, y, x `xor` y) | x <- [0, 1], y <- [0, 1]]
00:10:14 <lambdabot>  [(0,0,0),(0,1,1),(1,0,1),(1,1,0)]
00:10:36 <mnrmnaugh> i absolutly love the list comprehnsion, just by the way. sets are so nice
00:11:29 <mnrmnaugh> mmmm
00:11:42 <koz_> mnrmnaugh: Yeah, it's pretty useful. Funnily enough, I usually forget they exist.
00:11:47 <koz_> (even in cases where they'd be very useful)
00:11:52 <mnrmnaugh> :o
00:12:04 <Axman6> many cases are easier to express using applicative
00:12:20 <Axman6> > xor <$> [0,1] <*> [0,1]
00:12:22 <lambdabot>  [0,1,1,0]
00:12:27 <mauke> > do x <- [0, 1]; y <- [0, 1]; return (x, y, x `xor` y)
00:12:28 <koz_> Axman6: Yeah, in this case, definitely.
00:12:29 <lambdabot>  [(0,0,0),(0,1,1),(1,0,1),(1,1,0)]
00:12:46 <mnrmnaugh> lol mauke niice
02:25:43 * hackage potoki-core 2.2.5.1 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.2.5.1 (NikitaVolkov)
02:32:35 <epta> is there something like @hackage retry but without (MonadIO m) constraint on the monad?
02:32:45 <epta> @hackage retry
02:32:45 <lambdabot> http://hackage.haskell.org/package/retry
02:33:26 <epta> (MonadThrow m) would be just great
02:39:08 <epta> well, probably not, since `threadDelay` is bounded to IO ()
02:39:13 * hackage githud 2.1.0 - More efficient replacement to the great git-radar  http://hackage.haskell.org/package/githud-2.1.0 (gbataille)
02:48:58 <madnight> maybe some of you noticed that hackage has a new design since quite a while, do you know if there are any plans to update the haddock design any time soon, to match the haddock design?
03:00:56 <gentauro> will the elements of my FixedArray be sparsed in mem or will they be putted side-by-side? -> https://lpaste.net/8254319452284256256
03:02:29 <gentauro> FixedArray is defined as a product type:
03:03:00 <gentauro> % data FixedArray a = A Integer a a a a
03:03:01 <yahb> gentauro: 
03:03:08 <gentauro> > data FixedArray a = A Integer a a a a
03:03:09 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
03:03:30 <gentauro> % A 0 undefined undefined undefined undefined
03:03:30 <yahb> gentauro: ; <interactive>:16:1: error:; * No instance for (Show (FixedArray a0)) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
03:09:39 --- mode: glguy set +v Guest50632
03:09:51 --- mode: glguy set -v stilgart
03:11:13 * hackage potoki-core 2.2.5.2 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.2.5.2 (NikitaVolkov)
03:17:28 <nklap> hey
03:20:31 <Rembane> Morning
03:24:35 --- mode: glguy set +v yannherklotz
03:30:28 <yannz`> exit
03:30:53 <Mitsos101> Hello everyone! I'm using foldTree to find the set of vertices in a tree satisfying a particular condition. The problem is that the signature of my function is Vertex -> [[Vertex]] -> [Vertex], and there is obviously no way to concatenate the answers for every vertex in less than O(nlogn) amortized time. Is there an O(n) solution?
03:37:29 <madnight> what's the purpose of irrefutable patterns?
03:42:06 --- mode: glguy set +v dataN
03:42:07 <dataN> what is (<|>) called? 
03:43:55 <ArahaelPi> dataN: https://www.haskell.org/hoogle/?hoogle=%3C%7C%3E
03:44:06 <madnight> dataN: wedge-shaped Imperial Star Destroyer ^^
03:44:21 * ArahaelPi likes that definition.
03:45:56 <Rembane> I usually call it "Or" 
03:46:09 <Rembane> Applicative or is a better name though.
03:46:50 <ArahaelPi> Rembane: I prefer madnight's definition.
03:47:23 <Maxdamantus> Shouldn't it relate to Alternative, not Applicative?
03:47:39 <Rembane> ArahaelPi: Me too
03:47:52 <Rembane> ArahaelPi: It's a bit verbose in informal speech though.
03:50:46 <ArahaelPi> Rembane: Which is why most people use the <|> form. ;)
03:50:49 <Rembane> Maxdamantus: Yes, but I see it like this: Applicative And <*>, Applicative Or <|> 
03:51:04 <Rembane> ArahaelPi: Which is also a mouthful to say when spoken. :)
03:51:38 <dataN> ArahaelPi: that just gives its type
03:51:39 <ArahaelPi> Heh, ok. :)
03:51:44 <ArahaelPi> dataN: And it's name!
03:51:53 <Ariakenom> madnight: Don't know too many uses. I've seen it in some STM where the purpose was to move spent time to outside the transaction
03:52:07 <Ariakenom> for irrefutable patterns
03:52:53 <dataN> infix symbolic functions cant have letters as prefixes or suffixes...
03:53:52 --- mode: glguy set +v _sras_
03:54:19 <ArahaelPi> dataN: I misinterpreted, the definition Hoogle gave me was: (<|>) :: Alternative f => f a -> f a -> f a
03:54:26 <dataN> Rembane: thats incorrect. whats Applicative Or!?
03:54:37 <dataN> :t (<|>)
03:54:38 <lambdabot> Alternative f => f a -> f a -> f a
03:54:49 <ArahaelPi> dataN: And that lives in Control.Applicative.
03:54:57 <ArahaelPi> dataN: So I'd say it's Applicative Or.
03:55:02 <dataN> > "hello " <|> "Alternative"
03:55:04 <lambdabot>  "hello Alternative"
03:55:31 <dataN> @where (<|>)
03:55:31 <lambdabot> I know nothing about (<|>).
03:55:51 <Rembane> > "hello" <*> "Alternative"
03:55:53 <lambdabot>  error:
03:55:53 <lambdabot>      • Couldn't match type ‘Char’ with ‘Char -> b’
03:55:53 <lambdabot>        Expected type: [Char -> b]
03:55:56 <Rembane> :(
03:56:04 <dataN> hmm, well its from Control.Alternative 
03:56:10 <[exa]> SQL people would say it's COALESCE
03:56:20 * [exa] punishes self
03:57:22 <[exa]> anyway I usually read <*> as "app" and <|> as "alt"
03:57:43 * hackage potoki-core 2.2.5.3 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.2.5.3 (NikitaVolkov)
03:58:00 --- mode: glguy set +v dataN_
03:58:02 <dataN_> sorry, its in Control.Applicative, http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:-60--124--62-
03:58:38 <ArahaelPi> 20:54       ArahaelPi | dataN: And that lives in Control.Applicative.
03:59:23 <_sras_> Can someone please review my, possibly stupid, infra for dealing with money values with currencies and exchange rates, as required by a typical web application? Here https://bitbucket.org/sras/scratch/src/haskell-money-existential/src/Money.hs?fileviewer=file-view-default
04:00:43 <dataN_> Or would seem to have something to do with sum types as opposed to product types 
04:01:13 <dataN_> :t mappend
04:01:14 <lambdabot> Monoid a => a -> a -> a
04:01:24 <dataN_> :t (++)
04:01:25 <lambdabot> [a] -> [a] -> [a]
04:01:33 <dataN_> :t (<|>)
04:01:34 <lambdabot> Alternative f => f a -> f a -> f a
04:02:17 <kuribas> is it possible to create a lifted operator?  One that can only be used as a type?
04:02:38 <[exa]> kuribas: lifted to what?
04:02:44 <kuribas> [exa]: type level
04:02:58 <[exa]> like, say, : ?
04:03:04 <kuribas> well I have ::: 
04:03:14 <[exa]> oh noes sorry that's data constructor
04:03:21 <kuribas> which I want to use like a tuple
04:03:32 <kuribas> (lifted tuple)
04:03:50 <[exa]> but it should be generally possible, you could probably look up how the ~ for coercions is implemented
04:04:47 <kuribas> or do all type operators need to be ticked?
04:05:35 <dataN_> :t mplus
04:05:36 <lambdabot> MonadPlus m => m a -> m a -> m a
04:05:48 <dataN_> :t asum
04:05:49 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
04:05:52 <[exa]> kuribas: btw you might like this:  https://hackage.haskell.org/package/type-operators
04:06:29 <dataN_> calling it mplus is only wrong if its not Foldable...
04:19:44 <kuribas> [exa]: I solved it using: "type (:::) (s :: Symbol) (a :: *) = '(s, a)"
04:20:30 <kuribas> [exa]: so my type level lookup table becomes '[ "field1" ::: Int, "field2" ::: String ], etc...
04:20:34 <kuribas> which is quite nice :)
04:22:57 --- mode: glguy set +v yannz
04:23:29 <yannz> :t (<>)
04:23:30 <lambdabot> Monoid m => m -> m -> m
04:25:50 --- mode: glguy set -v yannz
04:31:36 <Maxdamantus> 22:50:27 < Rembane> Maxdamantus: Yes, but I see it like this: Applicative And <*>, Applicative Or <|> 
04:31:51 <Maxdamantus> Rembane: but .. (<*>) exists for all applicatives .. (<|>) does not.
04:32:12 <Maxdamantus> (<*>) is pretty much the essence of what applicative is.
04:32:22 <Maxdamantus> (compared to Functor)
04:33:23 <Maxdamantus> and likewise,  (<|>)  is pretty much the essence of what Alternative is.
04:33:31 <Rembane> Maxdamantus: That's true, my mental model leaks.
05:01:35 <pie__> cocreature, thanks
05:48:22 <Gurkenglas> Requesting review https://gist.github.com/Gurkenglas/5c64a909f202c8f073ae5bdbc5d1dd8e
05:55:28 <Wizek> Any ideas if/how this could be made to work? https://gist.github.com/Wizek/76126e426881cac1224201e1e43027eb
05:57:48 <Gurkenglas> Wizek, you want it to infer that "getIO :: Int -> _" has _ = IO Int, "getIO :: IO Int -> _" has _ = IO Int, and "getIO :: a -> _" has _ not yet determined?
05:58:58 <Wizek> Gurkenglas: That sounds about right
05:59:19 <Wizek> ooor
05:59:23 <Gurkenglas> Wizek, https://gist.github.com/Lysxia/70bfeb67071fdd23f5d68eef7d3664f8#file-hkd-hs-L25 sounds like it displays the language feature that might do it
06:00:09 <Gurkenglas> type family ToIO a where ToIO (IO a) = IO a; ToIO a = IO a
06:01:29 <Gurkenglas> Wizek, keep going on that ooor :D
06:01:42 <Wizek> Gurkenglas: Btw, even in your previous last example I think/hope it could be inferred that "getIO :: a -> _" has _ = IO a.
06:01:54 <Wizek> I just did :)
06:02:20 <Gurkenglas> Wizek, but what if a is IO Int?
06:02:32 <Wizek> although that does run the risk of what if a --- precisely.
06:02:57 <Gurkenglas> So we can't tell until we've reduced a to weak head normal form
06:03:29 <Wizek> isn't it even earlier than that, in typechecking/inference phase of the build when this decision is made?
06:04:06 <Gurkenglas> Right, in the inference phase where it computes what type exactly a is
06:05:17 <Gurkenglas> That's what I mean by that line ^^
06:05:45 <Wizek> alright, I'm thinking about this a bit more and giving the type family approach a try, thanks !
06:06:12 <Gurkenglas> Now someone shorten my mess https://gist.github.com/Gurkenglas/5c64a909f202c8f073ae5bdbc5d1dd8e
06:07:03 <Wizek> Gurkenglas: is it only shortening that you are looking for?
06:08:01 <MarcelineVQ> like runExceptT m >>= either (lift . f) (FreeT . pure) ?
06:08:32 <Wizek> https://www.irccloud.com/pastebin/LpAC5Nyz/
06:08:48 <MarcelineVQ> where's that m coming from btw
06:09:16 <Wizek> MarcelineVQ: maybe scoped?
06:09:18 <Gurkenglas> MarcelineVQ, well yes but that's not good enough :P
06:10:52 <Gurkenglas> MarcelineVQ, trying to make https://github.com/Gurkenglas/haskell-ide-engine/blob/IDErring-FreeT/src/Haskell/Ide/Engine/Dispatcher.hs#L89 sane
06:11:29 <Gurkenglas> 89 to 93 ought to be one line, and I oughtn't be talking about Pure
06:14:51 --- mode: glguy set +v dataN
06:15:03 <dataN> if a class function is defined with defaults using various different constraints, which of these are used if more than one of the constraints are satisfied?
06:17:15 --- mode: glguy set +v BKD
06:18:58 <BKD> how do iCOMPLETELY uninstall the Mac Haskell complete package? I think I corrupted something.
06:21:03 <Wizek> Gurkenglas: Second iteration, now with ToIO. Not sure how to get past these type errors, and perhaps this wasn't quite what you had in mind either. https://gist.github.com/Wizek/76126e426881cac1224201e1e43027eb/2a8c3ed406c31a0bf965bde448b8405df83c0896
06:22:07 --- mode: glguy set +v zincy
06:26:11 <dataN> e.g. how to work around this error; https://lpaste.net/7793557851850407936
06:27:27 <lavalike> BKD: /Library/Haskell/bin/uninstall-hs
06:30:06 <zincy> dataN: You have two type sigs for the same function
06:33:20 <Gurkenglas> Wizek, if this works I'd hope there'd be no IOLike class involved
06:33:41 <Gurkenglas> Just "getIO :: a -> ToIO a"
06:33:54 <Gurkenglas> But I don't know how to define non-polymorphic functions.
06:34:13 * hackage dates 0.2.2.2 - Small library for parsing different dates formats.  http://hackage.haskell.org/package/dates-0.2.2.2 (IlyaPortnov)
06:34:36 <Wizek> Gurkenglas: that's all and well on the type level, but I am confused how that could work on the term level. 
06:35:35 <Wizek> Gurkenglas: e.g. somehow I need to tell ghc somewhere that it needs to choose between either `id` or `pure`, don't I?
06:44:13 * hackage text-builder 0.5.3.1 - An efficient strict text builder  http://hackage.haskell.org/package/text-builder-0.5.3.1 (NikitaVolkov)
06:47:35 <dataN> zincy: is there a way to do it using a Language extension? 
06:48:04 <dataN> local instances work but they introduce a continuation...
06:56:14 <shafox> I am getting error • Couldn't match expected type ‘FileContent’
06:56:14 <shafox>               with actual type ‘IO FileContent’ • In a stmt of a 'do' block: content <- LBS.readFile fileName here in this code block https://lpaste.net/2004101305898893312
06:57:04 <MarcelineVQ> did you mean   processFile :: FilePath -> IO FileContent
06:58:35 <shafox> I want FileContent so that I can use that somewhere else without IO. 
06:59:32 <MarcelineVQ> That's not really an option by itself  http://www.vex.net/~trebla/haskell/IO.xhtml
07:00:07 <Gurkenglas> http://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#v:uninterruptibleCancel what does "not interruptible" mean here? dat doc
07:00:28 <lavalike> Gurkenglas: it has to do with exceptions
07:02:18 <MarcelineVQ> A typical route is to open the file in  main  and then work on it with your non-IO functions.  sort of like you've already done here with processFile, you're opening the file then handing it off to the non-IO processFileContent to work with
07:02:23 <lavalike> Gurkenglas: http://simonmar.github.io/posts/2017-01-24-asynchronous-exceptions.html
07:03:00 <MarcelineVQ> s/opening/reading
07:03:23 <Gurkenglas> Backpedaling: How do I run an IO action until the exact moment another thread pushes a particular button?
07:03:42 <Gurkenglas> (Because throwing exceptions to solve that sounds like an antipattern)
07:07:13 <glguy> Exceptions
07:08:12 <shafox> MarcelineVQ: yes, so move it to main ?
07:08:25 <dataN> how was this error supposed to be solved again? https://gist.github.com/dataN-hs/acf5a207415443fb339833dcd6c3d47f
07:09:04 <MarcelineVQ> yep that'll get you started, be sure to read that link
07:10:02 <dataN> e.g. Could not deduce (A a0) from the context: A a
07:12:38 <dataN> oh right, the forall. thing... the gist is updated, it shows multiple defaults with reified constraints. 
07:13:20 <dataN> (require explicit forall. and type annotated values when using ScopedTypeVariables) 
07:13:43 --- mode: glguy set +v zincy
07:13:48 <zincy> What does that error mean?
07:15:23 <dataN> that the typechecker needs direction to resolve the type a bound at the functions type. 
07:15:33 <dataN> type 'a' *
07:17:50 <dataN> adding 'forall a b.' and annotating the type of the the default definition.
07:17:52 <glguy> zincy: Once you identify with NickServ you won't have to keep repeating your first messages.
07:18:31 <dataN> it was complaining that; Could not deduce (C a)  from the context: A a  bound by the type signature for: default_C_B_ :: forall a b. A a => (C a => b) -> b or from: C a0
07:18:56 <zincy> dataN: you are referring to this right:
07:18:57 <zincy>  https://lpaste.net/4476062865458987008
07:19:00 <dataN> where it could see there was the instance 'C a0' but couldnt resolve 'a ~ a0'
07:19:15 <lavalike> Gurkenglas: I guess the simplest way is `async` and later, upon receiving the signal, `cancel`
07:19:19 <dataN> certainly not! 
07:19:23 <dataN> my appologies 
07:19:32 <dataN> apologies* 
07:20:53 <glguy> zincy: Your first message with that URL was blocked because you aren't identified
07:21:33 <zincy> thakns
07:21:48 <zincy> how do I identify
07:22:16 <glguy> Try: /msg nickserv help register
07:33:15 <Myrl-saki> How do you guys comment your code?
07:33:52 <hpc> // increment i
07:34:01 <Clint> -- FIXME
07:35:29 <savask> Does anyone here have experience with haskell's Z3 package?
07:36:15 <savask> I can run my code using Z3 in the interpreter, but can't compile it (linking fails)
07:36:15 <hpc> Myrl-saki: serious answer, i comment my code when i can't possibly make it look like what it does
07:36:25 <hpc> or if there's information outside the code that is necessary to understand what the code is
07:55:32 <rotaerk> hmm is there any function that would take "abc" and return ["aaa", "aab", "aac", "aba", "abb", "abc", ...]
07:55:43 * hackage potoki-core 2.2.5.4 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.2.5.4 (NikitaVolkov)
07:55:57 <rotaerk> basically I want permutations but where elements can repeat
07:56:06 <jgt> in Persistent/Esqueleto, is it possible to get a `expr (Value Bool)` from some raw SQL? I want to do `WHERE earth_box(ll_to_earth(lat, lon), 1000) @> ll_to_earth(things.lat, things.lon)`, but I don't want to have to ditch Persistent/Esqueleto entirely because those two extensions aren't (as far as I know) supported
07:59:07 <hpc> > sequence "abc"
07:59:09 <lambdabot>  error:
07:59:09 <lambdabot>      • Couldn't match type ‘Char’ with ‘m a’
07:59:09 <lambdabot>        Expected type: [m a]
07:59:14 <hpc> hmm
07:59:35 <hpc> > sequence (repeat (length "abc") "abc")
07:59:37 <lambdabot>  error:
07:59:37 <lambdabot>      • Couldn't match expected type ‘[Char] -> t (m a)’
07:59:37 <lambdabot>                    with actual type ‘[Int]’
08:00:01 <hpc> > sequence (replicate (length "abc") "abc")
08:00:03 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
08:00:15 <hpc> it's even in your order! :D
08:00:17 <rotaerk> hmmm
08:00:20 <rotaerk> nice ! :D
08:00:28 <int-e> :t replicateM
08:00:29 <lambdabot> Applicative m => Int -> m a -> m [a]
08:01:31 <rotaerk> > replicateM (length "abc") "abc"
08:01:33 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
08:02:01 <hpc> that extra length call is a bit awkward, don't think you can do anything about that though
08:02:15 <hpc> fundamentally you need to know how long the input string is just so you can generate the right amount of 'a' at the start
08:03:30 <rotaerk> I'm gonna use this to figure out the appropriate sequence of elemental rotations matches this implementation of rotateEuler
08:03:46 <rotaerk> err s/the appropriate/which/
08:06:09 <POGtastic> hi guys. I wrote a lexer/parser for arithmetic expressions. I currently have ways of throwing exceptions when the parser fails, and I'd like to instead return a Maybe type (with "Nothing" to denote failure). is there a non-cumbersome way of doing this? code is here: https://gist.github.com/mbottini/db13ee252ba2605bf9dd9a825b87f4b9
08:08:34 <POGtastic> the one thing that I can think of is to enclose *every* Expr type inside Maybe.
08:10:13 * hackage json-rpc 0.8.0.0 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.8.0.0 (xenog)
08:10:38 <jgt> asked a different way, how do I use a function like earth_box() in Persistent/Esqueleto?
08:19:53 <glguy> Myrl-saki: ideally you want to explain the purpose of the module and each definition. Document the arguments when they are confusing, provide examples
08:20:03 <glguy> https://github.com/glguy/advent2017/blob/master/execs/Day07.hs simple example
08:20:51 <MarcelineVQ> No :: without --     :>
08:21:09 <Myrl-saki> glguy: Thanks!
08:21:18 <Myrl-saki> MarcelineVQ: Well crap. :(
08:22:53 <hpc> that's quite a rule
08:23:02 <MarcelineVQ> I'm forgetful.
08:23:35 <MarcelineVQ> Comments are really for you, other people have to look hard anyway, you'll forget to look hard
08:24:00 <POGtastic> nm, i figured it out. I like the pattern of foo :: a -> a -> b being applied to Maybe types with foo <$> t1 <*> t2 :: Maybe b
08:39:22 <ab9rf> comments are best used to confuse those who look at the code later
08:42:58 <Gurkenglas> How do I make my thread wait until any thread says that the ressource I was waiting for is now ready for everyone's processing?
08:45:46 <MarcelineVQ> use an MVar that stores a value saying whether it's ready possibly
08:47:21 <MarcelineVQ> so your main might readMVar to wait, and one of the threads would putMVar when the resource is ready
08:50:44 <MarcelineVQ> there's more robust options, Chan, TChan, QSem possibly, not sure the best way to apply those to this problem
08:53:28 <pie__> MarcelineVQ, well I was screwing around with something like this, which i think is pretty verbose https://bpaste.net/show/3c8bb14bafec and also the pure True / pure False stuff is screwy
08:53:29 <MarcelineVQ> the main issue with the MVar is multiple threads can block putting into the same MVar I guess
08:53:34 <EvanR> use a TVar with a Bool. the waiter can do a retry loop until its True. other threads can write True to it without worrying about blocking
08:53:53 <EvanR> this whole dance is only guaranteed to work once
08:54:02 <pie__> its also annoying if i want to do IO depending on the condition but then have it in scope independent of the condition (i.e. after the if). i havent been able to think of a nice way to do that
08:55:23 <pie__> i think mvar has nonblocking functions that give a maybe value?
08:56:29 <pie__> i ended up doing someting similar by someone else's suggestion (i.e. using a flag object), but I have an event system provided by the library im using (Qt), so I just set callbacks on when the flag is changed
08:56:31 <MarcelineVQ> yeah I guess they do, Bool    tryPutMVar
08:56:40 <EvanR> no reason to use MVar here...
09:00:01 <Zemyla> Huzzah, it works! https://lpaste.net/1669566328983257088
09:07:47 <Gurkenglas> EvanR, mvar sounds more fitting, actually - it can be empty until the ressource is ready, then contain the ressource once it exists
09:07:58 <Gurkenglas> Or why would you prefer a TVar (Maybe a) to an MVar a?
09:08:11 <EvanR> thats not the same question
09:08:13 <MarcelineVQ> I wouldn't be put the resource itself in there if multiple threads are gonna want it
09:08:43 <EvanR> some resource is now ready vs some resource is now stored in an mvar
09:09:00 <Gurkenglas> What's the difference?
09:09:37 <EvanR> the second version basically is its own solution
09:10:13 <EvanR> i'm still wondering how this dance works after the initial readiness
09:10:25 <EvanR> how does it become unready
09:10:30 <EvanR> or is it a one shot
09:10:37 <Gurkenglas> I'm thinking I'll do Map k (MVar a), but then I would have to fiddle with creating it as it's needed. Is there a way to have a container with all the MVar's implicitly created empty immediately?
09:10:57 <Gurkenglas> Once it's ready that's permanent
09:11:34 <Gurkenglas> It's like a lazy memoizer map, except you're not allowed to evaluate the thunks, that's someone elses job, you wait until he's done it
09:14:17 <dmwit> You might be able to make a TMap k (IO (MVar a)) or something.
09:14:33 <dmwit> But I don't think that will be better than just writing a function that does the fiddling.
09:15:47 <dmwit> You might also like IVar.
09:16:22 --- mode: glguy set +v boxscape
09:16:49 <boxscape> @pl \res -> next & (traverse.results %~ (res :))
09:16:49 <lambdabot> (line 1, column 36):
09:16:49 <lambdabot> unexpected '~'
09:16:49 <lambdabot> expecting simple term
09:16:57 <boxscape> hm...
09:17:09 <boxscape> @pl \res -> next & (traverse.results +++ (res :))
09:17:09 <lambdabot> (next &) . (traverse . results +++) . (:)
09:17:18 <boxscape> pointfree was complaining that I need template haskell with this for some reason
09:17:47 <dmwit> At a guess: you actually used ($ next), and typo'd it as $( next).
09:18:19 <boxscape> no, I copy-pasted
09:18:25 <dmwit> Wait. *pointfree* was complaining?
09:18:37 <boxscape> yes, the program "pointfree" from hackage
09:19:20 <dmwit> I didn't know pointfree knew anything about TH at all.
09:19:31 <int-e> dmwit: it uses haskell-src-exts though
09:28:20 <boxscape> @pl \res -> (traverse.results +++ (res :)) next
09:28:20 <lambdabot> flip (traverse . results +++) next . (:)
09:28:27 <boxscape> it complains about that too, FWIW
09:32:40 <Gurkenglas> dmwit, TMap's deprecated in favor of tbox which doesn't look that fitting
09:34:08 <int-e> boxscape: not sure how it arrives at that error message... but the problem is that it doesn't know the fixity of %~... so (traverse . results %~ (res :)) is ambiguous.
09:49:42 <int-e> boxscape: ah. `pointfree` first parses it as an expression, which fails (because of the fixity error); then it parses it as a declaration. But it looks like an expression so the only way this is a declaration is to treat it as a top-level TH splice, where the $() may be omitted. That succeeds (fixities would be resolved later), but TH is not enabled... and you get that awful error.
09:51:25 <int-e> dmwit: that was a pretty good guess, all things considered.
09:52:20 <int-e> dmwit: your crystal ball just failed to clue you on the fact that the $( ) were invisible :)
09:55:53 <dmwit> Gurkenglas: No, from the total-map package.
09:56:07 <dmwit> int-e: Nice, I bet that was tricky to figure out.
09:56:36 <int-e> dmwit: Not very, but I did resort to using Debug.Trace.
09:59:03 <int-e> Now I'm just wondering what should be done about it... I guess `pointfree` shouldn't discard the error it got from parsing the input as an expression.
10:02:08 <EvanR> getting spam from Eduard_Munteanu2 :(
10:04:58 <boxscape> int-e ah, I see. thanks
10:06:18 <boxscape> how come lambdabot doesn't have a problem with the lack of a fixity declaration?
10:06:42 <boxscape> I guess it just assumes a default fixity?
10:12:17 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820004.4.2 default fixity is infixl 9
10:15:42 <int-e> boxscape: https://github.com/bmillwood/pointfree/issues/28
10:16:09 <int-e> @pl a . b ? c
10:16:09 <lambdabot> (line 1, column 9):
10:16:10 <lambdabot> unexpected "c"
10:16:10 <lambdabot> expecting space
10:16:10 <lambdabot> ambiguous use of a left associative operator
10:16:20 <boxscape> int-e: nice
10:16:50 <boxscape> given the default fixity of infixl9, is the fixity error due to mixing infixl 9 and infixr 9?
10:17:20 <dmwit> EvanR: Try /mode EvanR +R to only receive messages from registered nicks.
10:17:28 --- mode: glguy set +v tmarsh
10:17:31 <dmwit> ...maybe /mode +R EvanR, I can't remember.
10:17:36 <int-e> boxscape: lambdabot's @pl has its own ad-hoc parser.
10:17:44 <boxscape> ok
10:18:22 <int-e> and it doesn't look like it knows about fixities at all
10:18:27 <tmarsh> I want to avoid writing my own Bits instance if possible, but I can't find anything like what I need out there.. (In C++ it would be std::bitset<size_t>.)
10:18:34 <int-e> -- TODO, use Language.Haskell
10:19:02 <boxscape> huh, I see
10:19:39 <int-e> it should probably try to use pointfree as a library.
10:20:19 <dmwit> tmarsh: UArray Bool is bit-packed.
10:20:34 <dmwit> UArray ix Bool, I mean.
10:22:29 <tmarsh> dmwit: Oh, nice. I hadn't even considered UArray Bool. I guess the downside would be that I would still have to write my own `Bits` instance.
10:22:32 <dmwit> tmarsh: or... well, I guess it depends on what <size_t> means (I'm no C++ expert).
10:22:44 <dmwit> If you just want an Int's worth of bits, Int is already a Bits instance.
10:22:54 <tmarsh> It's just a template parameter specifing the number of bits in the bitset.
10:22:55 <dmwit> Word{8,16,32,64}, too
10:23:16 <tmarsh> So, if I want exactly 9 bits, for example, with correct overflow behavior
10:23:27 <dmwit> If you use UArray ix Bool, I wouldn't bother writing a Bits instance. Just use array indexing instead.
10:23:45 <dmwit> What is "overflow" in regards to a bitset?
10:24:51 <tmarsh> If I have a binary representation of 11011 and precision 5, for example, then 11011 `shift` 1 = 10110.
10:26:30 <dmwit> Okay. I don't know of a good existing library for strange bit lengths like that. At work we use a newtype, parameterized by a type-level Nat, over Integer.
10:28:07 <tmarsh> Yeah, that's the approach I was heading towards, but was hoping someone had tread that path already. For context, I'm using this for bitboards (like used for chess where Word64 represents all the positions on the board), which is just a type of broadword programming.
10:29:19 <tmarsh> Thanks for the suggestions!
11:09:43 * hackage engine-io 1.2.21 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.21 (OliverCharles)
11:28:13 * hackage engine-io-snap 1.0.7 -   http://hackage.haskell.org/package/engine-io-snap-1.0.7 (OliverCharles)
11:35:43 * hackage socket-io 1.3.10 -   http://hackage.haskell.org/package/socket-io-1.3.10 (OliverCharles)
11:46:25 <xsperry> can anyone upload anything to hackage, with no pre or post upload selection?
11:53:13 * hackage json-rpc 1.0.0 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-1.0.0 (xenog)
12:03:57 --- mode: glguy set +v Arthur
12:04:37 <Arthur> this is my first time on the chat, and I come in peace to ask a n00b question (I'm sure this is fairly common, lol)
12:05:20 <c_wraith> very common.  Ask when ready! :)
12:05:38 <c_wraith> (someone will probably answer.  There are a lot of people here that help)
12:05:51 <Arthur> thank you so much :), it's a fairly basic issue, I hope you can help me understand what this error means.
12:06:32 <Arthur> I have done some research but I think it will be better to understand the issue coming from people already used to code in haskell, and the question is
12:07:26 <Arthur> I'm defining a "snoc" list and one of its functions returns its tail. The Snoc list is defined like this:
12:07:46 <c_wraith> oh, this isn't a great place for code more than a line long
12:07:51 <Arthur> data ListS a = NilS | Snoc (ListS a) a deriving Show
12:08:00 <c_wraith> Use a pastebin to keep everything together
12:08:26 <Arthur> (thanks for the tip)
12:08:27 <hpc> the topic has a paste site
12:12:44 <Arthur> thank you for the tip, I created a pastebin :) 
12:12:47 <Arthur> So, this is my code:
12:12:48 <Arthur> https://pastebin.com/ZLUaChq5
12:13:02 <Arthur> The problem I have is with the tailS function. 
12:13:29 <Arthur> I wonder why is it that I can't return a NilS since it's definied as part of the data type
12:14:52 <Arthur> I get the following error: Couldn't match expected type 'a' with actual type 'ListS a0' , 'a' is a rigid type variable bound by the type signature for: tailS :: forall a. ListS a -> a
12:16:16 --- mode: glguy set +v tmarsh
12:17:00 <c_wraith> so, line 11 is the issue
12:17:49 <Arthur> yes, inded. 
12:17:58 <c_wraith> if you turn on -Wall to get more warnings, that might help you out.  There should be a warning as well as the error from that line if you do
12:18:39 <Arthur> oh wow I didn't know about that, thank you, I'll do that right away, lemme see...
12:19:22 <tmarsh> You should check your return type of tailS. NilS must be a (TailS a).
12:19:57 <ph88> how do you guys deal with left recursion in megaparsec ?
12:20:01 <pie__> how can I do this nicely?: https://bpaste.net/show/20e115082609 (and make it work at all, note the scoping issue on handled')
12:20:18 <c_wraith> ph88: use chainl.  If that doesn't work, use a different library
12:20:36 <Arthur> thank you very much guys!
12:20:44 <c_wraith> Arthur: figure out what was going on?
12:21:09 <ph88> pie__, maybe use $ instead of ( )
12:21:11 <c_wraith> ph88: oh wow.  Megaparsec doesn't even have chainL
12:21:38 <c_wraith> ph88: in that case, work really hard to refactor the grammar.
12:22:17 <lyxia> pie__: use ExceptT to throw an exception when things are NOT handled?
12:22:24 <pikajude> is it possible to get GHC to warn for missing export lists only in modules that are exposed-modules?
12:23:26 <c_wraith> pikajude: I don't think so.  GHC doesn't know about exposed-modules, so it's something cabal would need to do, and I don't think it has hooks for that.
12:23:38 <pavonia> pie__: Define handled' outside of the first when
12:23:40 <Arthur> I had no idea you could personalize the warnings in Haskell, this is amazing
12:23:55 <Arthur> you guys just opened up my eyes
12:24:27 <pie__> pavonia, well, that depends on btn <- QMouseEvent.button ev, which I didnt want to run unless the first check succeeds, but i guess i could do that
12:24:57 <pie__> Arthur, there's also -Wno-error=... to ignore specific ones (google for docs)
12:25:13 <pie__> ^ it was relatively recently added too \o/
12:25:33 <pie__> so you can set -Wall but ignore specific classes of warnings if you want
12:25:34 <pavonia> Ah, so you have to use if/then/else instead of `when` to return the value
12:26:14 <pie__> Arthur, i use -Wall with -Werror and exclude specific classes with no-error, when I want to make sure I start cleaning stuff up
12:26:51 <Arthur> that's really useful omg
12:26:51 <pie__> pavonia, thats also pretty ugly, but i guess
12:27:04 <Arthur> it's much better to trace and debug that way
12:27:12 <Arthur> so it's been added fairly recently?
12:27:24 <pie__> Arthur, i think it originates with LLVM, but im not sure. im kind of surprised it took this long...
12:27:45 <pie__> Arthur, well IIRC from what i saw in the docs no-error was added in 8.2.2, idk about the rest
12:27:47 <Arthur> I know... hopefully this will bring more people to Haskell. Debugging was hellish
12:27:51 <pikajude> ok, thanks c_wraith 
12:28:38 <pie__> pavonia, ah wait yeah i definitely need the first check to succeed first otherwise the second will segfault (external lib)
12:28:45 <pie__> so if else it is i guess...
12:28:46 <pie__> meh
12:28:53 <pie__> that looks horrible :p
12:29:29 <c_wraith> Arthur: so, the error message you were getting was talking about a "rigid type variable". That means a type variable that comes from a type signature and is therefore forced to be polymorphic.  You were providing a value with a partially known type (NilS :: ListS a, for any type `a') when it expected a value of the type `a' that comes from the type signature.
12:29:38 <pavonia> pie__: I usually use a case in such situations
12:29:53 <pie__> pavonia, i keep forgetting i can do that
12:30:14 <pie__> that might be a little nicer
12:30:35 <pie__> i could probably try exceptT as well but i havent ever tried exceptions yet and i dont feel comfortable starting now
12:31:16 <c_wraith> ExceptT is notably *not* GHC's exception system.  It's just a library around returning error values.
12:33:00 <c_wraith> Arthur: Also, the type `a' in (NilS :: ListS a) is not the same type `a' as from the type signature.  That can be a confusing point.  Type variables with the same name only mean the same type if they are both defined in the same scope (usually a single type signature)
12:33:07 <pie__> c_wraith, hm
12:33:24 <pie__> maybe it should have been called something else? :P
12:34:06 <c_wraith> Well, it's still used for exception handling.  It just is a library-based approach instead of GHC's system.  The advantage is that you can recover from one outside of IO.
12:34:44 <typetetris> Is there something like MinGHC for ghc 8.4.3 ?
12:35:00 <typetetris> Or some other installer for Windows? 
12:35:10 <glguy> Haley
12:35:37 <glguy> Haskell platform, the core installer is the minimal one
12:36:04 <ph88> typetetris, you can use stack for windows
12:36:21 <mbwgh> Is it bad to replace functions like `myFun args = ... $ go; where go = ...` with `myFun args = ... . fix $ \go -> ...` to safe on identation? :/
12:37:24 <glguy> Haskell platform comes with stack, too, so you'll have that if you need it later
12:37:51 <c_wraith> mbwgh: it can be mildly harder to read, but I'll do similar things in a do block when I need to close over bindings from earlier in the block.
12:38:33 <typetetris> Thanks
12:38:35 <c_wraith> mbwgh: it seems a little less useful in that case, because my standard is half-indentation for a where, so that the bindings in it are only one indentation step in from the parent
12:38:37 <mbwgh> c_wraith: Yeah I had this kind of situation exactly. Imperative haskeline spaghetti code that needs to jump back and retry etc.
12:39:44 <xsperry> isn't one of the features of stack to allow it maintain your (multiple) ghc installations? so getting stack with haskell platform seems a bit backward
12:41:03 <mbwgh> I figured if would rather use fix to introduce a poor man's goto label than introduce a lot of small functions, which would cause me to jump around when reading the code. But using fix quickly becomes a habit, I noticed
12:41:20 <lavalike> you just need that quick fix
12:43:39 <hpc> mbwgh: it's like
12:44:00 <c_wraith> mbwgh: I try to resist the urge, much like I try to resist using the Functor/Applicative/Monad instances for ((->) r).   Most of the time it interferes with reading code for people who aren't well-versed in it 
12:44:00 <hpc> mbwgh: you make a habit out of using lambdas in a lot of places you don't need a full-blown name for a function
12:44:09 <hpc> mbwgh: and then one of those small anonymous functions happens to be recursive
12:44:29 <hpc> and once you have the tool of fix, that scenario pops out to you constantly :D
12:44:42 <dyamon> Hi guys, I have a problem with Parsec that is driving me crazy! I have a file with one word per line (with possible trailing spaces). Why is this oneliner not working? '((many1 alphaNum) <* (many space)) `sepEndBy` newline <* eof'?
12:44:43 <ph88> c_wraith, instead of chainl megaparsec offers https://hackage.haskell.org/package/megaparsec-6.5.0/docs/Text-Megaparsec-Expr.html have you seen it ?
12:44:53 <c_wraith> ph88: I have not
12:45:04 <mauke> dyamon: does space match '\n'?
12:45:31 <dyamon> I assumed it does not
12:45:40 <hpc> mbwgh: i agree with c_wraith though, often just giving something a name outweighs the terseness
12:45:54 <lavalike> mauke: it does
12:46:00 <mauke> that's a questionable assumption
12:46:08 <mbwgh> dyamon: You can test these things with the predicates from Data.Char. If there is overlap between your left and right parsers, you are going to have a bad time.
12:46:36 <lavalike> dyamon: I got bitten by the same problem a little while ago, mauke spotted it quite fast!
12:47:09 <mauke> if there's a named combinator, I assume it matches all whitespace characters because if you only want ' ', you can just say char ' '
12:47:09 <dyamon> oh ok... I feel dumb now, sorry!
12:47:16 <lavalike> if you don't need to divide the lines  many1 alphaNum `sepEndBy1` space  will do it
12:47:34 <mbwgh> hpc: Well, you do give it a name in `fix \namedLambda -> ...`, but I guess I was right in my suspicion that things become very non-idiomatic quickly.
12:48:14 <dyamon> lavalike: my actual file is a bit more complex, but I tried to find the minimal example giving the error
12:48:27 <hpc> here's maybe a better use for fix, though still very rare:
12:48:37 <hpc> fix is a function, that expresses the idea of recursion
12:48:39 <dyamon> well thanks for now! 
12:48:48 <hpc> specifically, recursion by calling the same function again
12:49:04 <hpc> but because it's itself a function, you can now replace fix with other ideas of recursion
12:49:15 <hpc> like maybe by alternating between two functions
12:49:30 <dstolfa> in short: because we live in the world of continuous functions, we can find a fixpoint of these functions and off we go recursing! :-)
12:49:33 <hpc> and you can pass fix as a parameter, to functions that are generic on what recursion scheme they use to do their work
12:49:50 <mauke> m e m o i z a t i o n
12:49:55 <hpc> ^
12:50:26 <hpc> automatic memoization works by putting "save this result for later" in the middle of a recursive call
12:50:42 <hpc> so you'd write something that's generic over recursion schemes
12:50:48 <hpc> the unmemoized thing would be (foo fix)
12:50:54 <hpc> and the memoized thing would be (foo memoFix)
12:51:58 <mauke> I use fix as unconst
12:52:02 <mauke> > fix (const 42)
12:52:04 <lambdabot>  42
12:52:06 <monochrom> haha
12:52:15 * lavalike slaps head
12:52:26 <hpc> @let break = const
12:52:27 <lambdabot>  Defined.
12:52:31 <hpc> > fix (break 42)
12:52:33 <lambdabot>  error:
12:52:34 <lambdabot>      Ambiguous occurrence ‘break’
12:52:34 <lambdabot>      It could refer to either ‘Data.List.break’,
12:52:34 <mauke> bad move
12:52:45 <EvanR> you broke break
12:52:48 <hpc> wait, i got this
12:52:49 <hpc> > fix error
12:52:51 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
12:52:57 <EvanR> if it's not break don't fix it
12:53:05 <mbwgh> ha
12:53:07 <lavalike> but he did
12:53:21 <monochrom> No no no. If it's not const don't fix it.
12:53:26 <EvanR> an exception to every exception
12:53:51 <mbwgh> I feel a paradox incoming
12:54:15 <monochrom> All paradoxes are resolved by non-termination.
12:54:59 <hpc> non-termination is the computer closing its eyes and hoping the problem goes away
12:55:46 <mauke> > fix show
12:55:48 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
12:56:15 <lavalike> > fix . fix . fix . fix . fix . fix . const . const . const . const . const . const $ ()
12:56:17 <lambdabot>  ()
12:56:21 <EvanR> > text (fix show)
12:56:26 <ph88> can someone help me with this linker error ?  https://bpaste.net/show/d911af36a0dc
12:56:29 <lambdabot>  mueval-core: Time limit exceeded
12:56:35 <ph88> i already tried to do stack clean and remove .stack-work folder
12:56:49 <hpc> fix show is the proof of the theorem "quoting regular expressions is hard sometimes" :D
12:57:24 <EvanR> > show fix
12:57:26 <lambdabot>  error:
12:57:26 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘show’
12:57:26 <lambdabot>      • In the expression: show fix
12:57:30 <monochrom> Generally all quoting and escaping mechanisms get out of hand.
12:58:03 <mauke> should've used here-documents
12:58:17 <lavalike> take 2: Generally all quoting mechanisms escape handling.
12:58:35 <monochrom> haha
13:03:10 <ph88> ah i think i found the problem .. the notorious "can not do profile build first"
13:13:21 <ph88> so i first build project normally now ... now with profiling i get these linker errors i've never seen before https://bpaste.net/show/febf25c669cc 
13:23:09 <ph88> what does it mean if i execute my program and it just prints   <<loop>>   ?
13:23:34 <c_wraith> that means it would have gone into an infinite loop, but ghc decided it's more useful to tell you so and crash.
13:23:58 <c_wraith> It's specifically an infinite loop where evaluating a value depends on the result of evaluating that value
13:24:12 <c_wraith> Look for accidental name re-use in a let, or the like
13:25:03 <c_wraith> Or an intentionally recursive value that can't evaluate productively due to a laziness error, or something
13:27:43 * hackage potoki 2.0.4 - Simple streaming in IO  http://hackage.haskell.org/package/potoki-2.0.4 (NikitaVolkov)
13:28:53 <ph88> c_wraith, is there another way to find the loop than just look at the code ?
13:29:24 --- mode: glguy set +v ccrpto
13:29:42 <c_wraith> maybe.  I've never looked.
13:29:43 * hackage potoki-core 2.2.6 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.2.6 (NikitaVolkov)
13:29:56 <ccrpto> do I really need to manually compile with :r and load function everytime i change something in my file?
13:31:06 <ccrpto> any fancy packages out there that automatically compile or like a devserver or quokka?
13:31:08 <glguy> No, you can run ghcid
13:32:47 <ccrpto> ok, gonna try
13:33:35 <glguy> ?hackage ghcid
13:33:36 <lambdabot> http://hackage.haskell.org/package/ghcid
13:40:25 <ccrpto> so this is like a linter right? 
13:40:58 <monochrom> No. This is unlike anything else you knew. Just read its introduction carefuly.
13:44:07 <hpc> ccrpto: a language server is a process that an IDE talks to
13:44:28 <hpc> when you right-click an identifier, the IDE goes "hey language server, anything interesting about this word?"
13:44:39 <hpc> language server goes "you can jump to the definition, it's on line 12345"
13:44:44 <hpc> and IDE displays that button
13:45:10 <lavalike> these programs are so articulate hpc 
13:45:11 <hpc> any IDE that supports the language server model will have identical features when talking to ghcid
13:45:13 * hackage cache 0.1.1.1 - An in-memory key/value store with expiration support  http://hackage.haskell.org/package/cache-0.1.1.1 (hverr)
13:45:40 <hpc> and adding new IDE features is in the control of the language server maintainer, instead of each IDE's team individually
13:46:08 <hpc> IDEs don't need to actually understand every language on their own, and someone who is intimately familiar with haskell can write good IDE features that work everywhere
13:46:11 <hpc> win-win
13:46:21 <hpc> but it's something that's only really become big in the last year or two
13:48:10 <ab9rf> the idea, i suppose, to do something about the plethora of language-specific IDEs
13:48:42 <hpc> yeah
13:49:01 <hpc> plus changing /who/ is doing the language-specificness
13:49:04 <hpc> from many groups, to one
13:49:38 <ab9rf> but, of course, https://xkcd.com/927/
13:49:46 <pie__> can i make a data constructor accept an argument of any type (well, i mean until its specialized), without having to propagate a type parameter EVERYWHERE
13:49:57 <ab9rf> pie__: no
13:50:02 <pie__> ugh...
13:50:14 <ab9rf> pie__: you can't have hidden types
13:50:17 <mauke> yes
13:50:25 <pie__> everything ends up with a bunch of arguments everywhere and its horrible
13:50:25 <hpc> ab9rf: the trick is making that 15th standard so damn good that it becomes the majority
13:50:31 <mauke> you can totally have hidden types
13:50:36 <mauke> it's called existential types
13:50:42 <hpc> in this case though, it's more like going from 0 standards to 1 standard
13:50:43 <ab9rf> hpc: or at least good enough and have a gorilla behind it.
13:50:54 <hpc> it's a lot easier to get buy-ion
13:50:55 <hpc> in
13:51:08 <ab9rf> hpc: yeah, the first player to enter the field has a huge advantage
13:51:17 <pie__> mauke, hm ill look into that. is this something im likely to shoot myself in the foot with?
13:51:30 <mauke> yes
13:51:41 <ab9rf> hpc: we've seen this happen, with both TCP/IP and Ethernet
13:52:05 <ab9rf> hpc: and, at least for a long time, Intel
13:52:12 <ab9rf> although ARM is starting to displace it
13:52:45 <hpc> incidentally, TCP/IP wasn't first
13:52:50 <ab9rf> hpc: no, it wasn't
13:52:55 <ab9rf> hpc: not even close
13:53:10 <ab9rf> but it had the backing of a gorilla
13:53:34 <hpc> yeah that's true
13:54:38 <ab9rf> today there isn't really a gorilla anymore
13:55:08 <ccrpto> @hpc i'm running haskell on visual studio code, how do you console.log( ) output of functions though?
13:55:08 <lambdabot> Maybe you meant: src rc pl ghc
13:55:13 <ab9rf> too often the apparent gorillas end up being a herd of ferrets in a gorilla costume
13:55:24 <pie__> mauke, what i actually want to do is i have a metadata field in a record and id like to pass generic used data in it
13:55:36 <monochrom> ccrpto: Consider the library module Debug.Trace
13:56:02 <hpc> ccrpto: that's not an IDE-specific question
13:56:15 <hpc> Debug.Trace is the way to go, since you can insert it anywhere
13:56:21 <monochrom> Well even a real Gorilla is a herd of cells. :)
13:56:34 <hpc> (trace a b) means, if b is evaluated, then a is printed to stdout
13:56:38 * monochrom shows his ugly reductionist tail :)
13:56:52 <hpc> in IO, putStrLn works just fine as well
13:57:22 <monochrom> Oh wait, ccrpto is religiously insisting on IDEs?
13:57:29 <hpc> monochrom: even a cell is a bunch of other organisms that happened to come together a gazillion years ago
13:57:32 <hpc> like mitochondria
13:57:55 <monochrom> I heard that we got that from a virus infection but it was so great.
13:58:02 <ab9rf> pie__: there's a clever way to do that, but i can't remember what it is right now
13:58:15 <pie__> :c
13:58:20 <pie__> thanks anyway
13:58:23 <ab9rf> pie__: i saw an example of doing something like that about five years ago, and i can't remember where or what it was called
13:58:23 --- mode: glguy set +v mijothy
13:58:24 <hpc> ccrpto: anecdote on IDEs - i have VSC installed on the machine i am typing this on, right now
13:58:33 <hpc> ccrpto: and i have never used or wanted to use it for haskell
13:58:44 <hpc> ccrpto: i open a terminal, split it vertically, one side is vim the other side is ghci
13:58:53 <hpc> type type type, :w, tab over, :r
13:59:51 <monochrom> My students have been using Visual Studio Code for Haskell with great success.  (And minimal setup work, I presume, since they just need it for half of a course.)
13:59:52 <Gurkenglas> When a would be in scope in a type signature but isn't in a type application, am I doing something wrong?
13:59:57 <ab9rf> pie__: "represent your datatype as the fixpoint of a functor, and compose the annotation in at each layer using a functor product"
14:00:07 <monochrom> (Or rather, since my students tend to be lazy in all things.)
14:00:31 <pie__> ab9rf, sadly i cant understand that
14:00:33 <Gurkenglas> I've been using VS Code with haskell-ide-engine for the last few weeks
14:00:35 <lavalike> teaching haskell sounds like a nice job
14:00:38 <ab9rf> pie__: or use a Cofree monad
14:00:55 <hpc> lavalike: you have to balance that against the fact that your job is being a teacher ;)
14:00:58 <ab9rf> pie__: use the google machine
14:01:01 <monochrom> I think "generic data" is informationlessly vague.
14:01:04 <mijothy> any chance of a little help with a beginner question? I'm getting the error at the bottom of this gist (relevant code included) https://gist.github.com/MIJOTHY/667454e350853dc1c6ce86092d9b52f4
14:01:11 <ab9rf> maybe you'll find an example that will inspire you
14:01:15 <pie__> ab9rf, yeah im looking up the cofree
14:01:26 <monochrom> You may as well ask "how do I write a great data definition".
14:02:08 <Gurkenglas> There's been problems with Windows, but useful things include menus that find me all usages of a term in a project, context menu options via which I can compare the line I rightclicked on with git-past versions of itself, etc
14:02:08 <ab9rf> monochrom: people who are used to using bagtyped languages constantly want to be able to have an "arbitrary data type" in haskell 
14:02:10 <hpc> how do i write a great data definition? :P
14:03:05 <monochrom> Or maybe that's an effect not a cause. People who think sloppily to begin with prefer to use fast-and-loose languages of course.
14:03:15 <Gurkenglas> And when the fast recompilation works, I see new compile errors/typed hole fills after 1-3 seconds
14:03:21 <pie__> I want an "arbitrary" datatype because the implementation doesnt depend on the specifics of the datatype...
14:03:28 <monochrom> My personal opinion is that if you can't write down concrete examples of use cases you're vague.
14:03:38 <hpc> pie__: can i interest you in type variables?
14:03:43 <ab9rf> pie__: that's what type variables are for
14:03:48 <hpc> have as many as you like
14:03:52 <pie__> yeah i have type variables
14:03:53 <hpc> a, b, c, abc
14:03:56 <ab9rf> hpc: the request was to do it _without_ a type variable :)
14:03:58 <pie__> i have no problem with type variables :P
14:04:26 <ab9rf> type variables have a tendency to proliferate in haskell code :)
14:04:30 <ab9rf> s t a b
14:04:30 <pie__> what i dont like is that if i add a type variable to this type, suddenly i have to propagate a type variable to a bunch of stuff and its verbose :(
14:04:37 <monochrom> And "it can be anything!" is also vague because the issue has never been whether it's "any". The issue is whether the producer chooses or the consumer chooses.
14:04:58 <ab9rf> the hting is, it can be "anything" but it needs to be the _same_ anything
14:05:01 <Gurkenglas> pie__, if you show us the code you have I could see if I can find a solution
14:05:03 <hpc> pie__: well, you have to know it's the same
14:05:05 <monochrom> i.e., "exists" vs "forall".
14:05:35 <hpc> suppose you wrote a "generic" id function
14:05:47 <hpc> and did (id (5 :: Int)) :: String
14:05:49 <ab9rf> try to write a -> b
14:06:13 <hpc> id :: Whatever -> Whatever, for some concrete type that's somehow totally polymorphic
14:06:36 <monochrom> Well that's "public Object id(Object)" in Java.
14:07:01 <pie__> line 41 forces udata to be propagated up everywhere else https://bpaste.net/show/1e4f1418dac6 
14:07:04 <Rembane> I will do anything for love, but I won't do that.
14:07:14 <monochrom> Been there done that saw its fall to disgrace
14:09:52 <monochrom> pie__, you can't eliminate this "verbosity" [sic], you can only choose where to put it.
14:10:08 <monochrom> Option A: have "State udata" in the type sig.
14:11:00 <monochrom> Option B: have "State Object" in the type sig, but then inside the function body you have to downcast it back to udata.  Such as in 20th-century Java.
14:11:18 <pie__> (its not that I dont see (on a beginners level) why its necessary, or that it doesnt work, its just makes my code feel messy)
14:11:41 <monochrom> Actually there is Option C too.
14:11:53 <monochrom> Option C: Don't use Haskell. Go back to Python.
14:12:21 <hpc> option D: don't have a type signature, let inference do it
14:12:30 <monochrom> OK that's a joke. Of course if you do that, it's s/Python/Scheme/
14:12:32 <pie__> meh if i was using python id probably have had an aneurism a fifth of a way through this refactor 
14:12:52 <hpc> obligatory "which python?"
14:13:06 <monochrom> Python 3.141592653...
14:13:13 <pie__> you could say the same about ghc versions :p
14:13:36 <hpc> pithon
14:13:43 <pie__> :D
14:14:05 <hpc> pie__: well, "which haskell" is something you don't even have to stick to within the same project
14:14:08 <hpc> which ghc, yes
14:14:13 <hpc> but language extensions... extend the language
14:14:36 <pie__> something about breakage because of changes to base
14:14:37 <hpc> python and Python are the same thing because there's only one real implementation
14:14:54 <monochrom> OK now we just need someone to come up with Tauthon...
14:15:06 <pie__> oh god the trolling potential
14:16:12 <pie__> option E: use explicit forall? (dont really know what that actually results in though..)
14:16:30 <pie__> well looks like i'll jut bee keeping the type variables
14:16:34 <monochrom> That's longer, not shorter.
14:17:12 <monochrom> I.e., it improves "foo :: State udata -> Meh" to "foo :: forall udata . State udate -> Meh"
14:18:04 <pie__> ok then im probably mixing it up with rankntypes
14:18:21 <monochrom> Oh rank-n types have even more foralls.
14:18:42 <pie__> :D
14:19:01 <pie__> why even write programs. foralls4lyfe
14:19:18 * pie__ tries to remember where he was in his code
14:19:26 <monochrom> I do recommend "just erase the whole project" sometimes.
14:19:38 <dstolfa> monochrom: sometimes?
14:19:40 <dstolfa> i recommend that all the time
14:20:06 <monochrom> Yes, but I try to be nice.
14:20:13 * hackage indexation 0.4.2.2 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.4.2.2 (NikitaVolkov)
14:20:38 <pie__> well that would also be my default answer but id prefer not to
14:20:40 <pie__> ;~;
14:20:40 <dstolfa> monochrom: ti-hi
14:22:00 <pie__> to quote from someone's github page "I like Haskell and snow, they distract me from the living hell that is technology."
14:28:44 --- mode: glguy set +v ezyang__
14:29:01 <ezyang__> Given a TH AST (e.g., from a [| |] quote), is it possible to pretty-print it back into a Haskell source program 
14:29:28 <ph88> omg :/ i made the silliest mistake ever
14:29:31 <ph88> main = main
14:29:53 <hpc> main = putStrLn "<<loop>>"
14:30:10 <dstolfa> main = let main = main in main?
14:30:48 <monochrom> ezyang__: There is some command-line option to dump a splice.  Maybe that helps.  But it's probably also on stderr.
14:31:11 <ezyang__> So... I don't actually want to splice it :) 
14:31:36 <ezyang__> I was hoping TH would give me a poor man's Haskell parser/pretty-printer 
14:31:53 <dstolfa> how do i lambdabot again
14:31:58 <dstolfa> :f = let f = f in f
14:31:59 <hpc> > "like this"
14:32:01 <lambdabot>  "like this"
14:32:05 <dstolfa> ah
14:32:09 <dstolfa> > f = let f = f in f
14:32:10 <lambdabot>  <hint>:1:3: error:
14:32:10 <lambdabot>      parse error on input ‘=’
14:32:10 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
14:32:18 <hpc> it has to be an expression
14:32:21 <dstolfa> damn
14:32:30 <monochrom> Just add one more level of let-in
14:32:35 <hpc> > let f = let f = f in f in f
14:32:38 <lambdabot>  *Exception: <<loop>>
14:32:40 <monochrom> Yeah :)
14:32:42 <dstolfa> har har har
14:32:59 <dstolfa> does lambdabot do some totality checking or something
14:33:08 <dstolfa> or well, termination checking in this case
14:33:12 <hpc> what you're looking at is blackholing of thunks
14:33:25 * dstolfa chuckles
14:33:26 <hpc> in the single-threaded runtime, there's only one thread at a time
14:33:36 <hpc> so
14:33:46 <monochrom> This is of the kind of infinite loop that can be easily caught in the process of lazy evaluation.
14:34:12 <hpc> on an actual machine, a thunk is something like a pointer to a block of code
14:34:21 <dstolfa> monochrom: yeah but surely someone can construct one that can't and requires a bit more work -- but what hpc described should catch it regardless
14:34:30 <hpc> this is the "box", and that code computes the unboxed value
14:34:39 <hpc> (someone else can correct me if i am wrong about boxing here)
14:34:53 <hpc> dstolfa: so, the first time you evaluate a thunk, execution enters the thunk
14:35:02 <hpc> dstolfa: first the thunk pointer is rewritten to a black hole
14:35:06 <hpc> dstolfa: then the code is run
14:35:18 <hpc> dstolfa: then the code block is rewritten to "just return the computed value"
14:35:18 <dstolfa> hpc: i know, i've been unfortunate enough to deal with codegen in llvm and linkers :'(
14:35:28 <hpc> dstolfa: then the pointer is moved back to the modified box
14:35:32 * dstolfa wants to forget all about this
14:35:40 <hpc> so, if a thunk's evaluation depends on itself
14:35:51 <hpc> it reenters the thunk while it's been mutated to the black hole routine
14:36:09 <hpc> the black hole routine is very roughly, error "<<loop>>"
14:36:21 <pie__> fancy
14:36:25 <hpc> in the threaded runtime, this is a greyhole instead
14:36:33 <dstolfa> the real question is
14:36:40 <dstolfa> what does yahb do
14:36:41 <hpc> when control enters a greyhole, the thread blocks until some other thread does whatever it is threads do
14:36:45 <dstolfa> how do i interact with yahb again
14:36:52 <dstolfa> yajaru[m]: help
14:36:53 <dstolfa> oops
14:36:55 <dstolfa> yahb: help
14:36:55 <hpc> maybe it's a true infinite loop, and it waits for an async exception
14:36:58 <monochrom> I think something about % ?
14:37:01 <hpc> or maybe two threads are computing the same value
14:37:05 <dstolfa> % let f = let f in f in f
14:37:06 <yahb> dstolfa: ; <interactive>:17:15: error: parse error on input `in'
14:37:16 <hpc> in this case, the greyhole resolves itself when the first thread to start the computation finishes
14:37:25 <dstolfa> % let f = let f = f in f in f
14:37:31 * dstolfa can't type
14:37:31 <yahb> dstolfa: [Timed out]
14:37:40 <dstolfa> ah, yahb does it the easy way
14:38:25 * dstolfa wonders if he can override yahb's watchdog by overriding the getCurrentTime
14:38:39 <dstolfa> % let getCurrentTime = 3
14:38:41 <yahb> dstolfa: 
14:38:48 <dstolfa> % let f = let f = f in f in f
14:38:54 <yahb> dstolfa: [Timed out]
14:38:59 * dstolfa grumbles
14:39:07 <lavalike> is 3 enough time
14:39:12 <lavalike> oh nevermind
15:00:29 <davean> kloeri
15:01:42 <EvanR> funny once but
15:16:50 <EvanR> interesting, abusing Array functions in ruby as poor man's Maybe (Maybe is a list which is either empty or has 1 element)
15:17:20 <EvanR> you can map, do case analysis etc without defining a custom Maybe class
15:36:53 <crestfallen> hi I went through an exercise online where a non-recursive lambda exp (for factorial) is passed to fixx which I believe is an approximation of the y-combinator :     fixx :: (t -> t) -> t ; fixx f = f (fixx f). I'm trying to discern between that and something that I'm reading about F-albebras. newtype Fix f = Fx (f (Fix f))
15:38:18 <crestfallen> I guess this produces trees where you don't need recursion within the type 
15:39:34 <crestfallen> the article says this : In Haskell, we can express the fix point of a type constructor f as a type: newtype Fix f = Fx (f (Fix f))
15:40:06 <benzrf> crestfallen: yep
15:40:24 <crestfallen> is this used often?
15:40:26 <hpc> crestfallen: mentally erase data constructors and they're identical modulo capitalization
15:40:29 <benzrf> this is basically a fixed point operator on type functions
15:40:35 <hpc> that Fix type in particular isn't used terribly often
15:40:40 <hpc> but variations like Free are
15:40:53 <crestfallen> what exactly is fixed point
15:40:55 <hpc> and the concept of making a data type matching some desired recursion scheme is very common
15:41:23 <benzrf> crestfallen: for a function f, a fixed point of f is a value x such that f x = x
15:42:00 <crestfallen> If I may paste something (again) ...
15:42:16 <benzrf> we don't have equality of types here, but we do have something like a natural isomorphism f (Fix f) ~ Fix f
15:42:27 <hpc> that's actual equality there btw, it doesn't mean f = id :D
15:42:56 <hpc> (if you've gotten in the habit of reading equations typed on a keyboard as haskell)
15:44:10 <hpc> the newtype breaks that type-level equality in practice, but it also stops the compiler from trying to compute the type forever
15:45:07 <crestfallen> right x is the lambda in this case and not identity but one moment please
15:45:28 <crestfallen> https://ptpb.pw/ZbZD
15:45:42 <crestfallen> this I can pretty much follow ^
15:46:13 <crestfallen> somewhere it said that this is as close to the y-combinator that haskell approaches or somesuch
15:46:53 <crestfallen> so I can't really follow all of what you guys were saying
15:46:56 <crestfallen> however
15:47:03 <hpc> fix and the y combinator compute the same thing
15:47:13 <hpc> however the y combinator's definition relies on being in an untyped environment
15:47:32 <crestfallen> interesting cool
15:47:36 <hpc> we care about equational reasoning anyway so yeah, it's literally as close as you can get
15:47:43 <hpc> they're extensionally equal :D
15:47:50 <crestfallen> so this (bartosz) article is saying...
15:48:40 <crestfallen> something about fractally recursive structures.... ?
15:49:24 <crestfallen> " After infinitely many iterations we should get to a fix point where further iterations make no difference. "
15:50:53 <crestfallen> hpc could you go into equational reasoning a bit?
15:51:03 <hpc> crestfallen: for that, generally in math, mentally replace "infinitely many" or "infinitely close" or "at infinity" with their equivalent description in terms of limits
15:51:03 <crestfallen> by example
15:51:26 <hpc> i think in that article he was speaking more casually to get the idea across to programmers, instead of being mathematically precise
15:51:53 <hpc> so equational reasoning, roughly speaking
15:52:01 <crestfallen> ok thanks, but the concept is not much different from what I pasted using the factorial lambda
15:52:06 <hpc> means that the equals sign in haskell definitions is an actual equals sign in your brain
15:52:13 * hackage free-algebras 0.0.4.0 - Free algebras in Haskell.  http://hackage.haskell.org/package/free-algebras-0.0.4.0 (coot)
15:52:20 <hpc> (not to the compiler because it still has to know what's being defined, just in your head)
15:52:28 <hpc> so if you see a definition f x = y
15:52:37 <hpc> mathematically that's f(x) = y
15:53:14 <hpc> and then elsewhere you see g(z) = f(z)
15:53:19 <hpc> you can follow the equality
15:53:24 <hpc> g(z) = f(z) = y
15:53:26 <hpc> g(z) = y
15:53:37 <hpc> and then anywhere you see g(z), etc etc
15:53:57 <hpc> in programming, what that looks like is
15:54:07 <hpc> anywhere you see an expression, you can give it a name and refer to that name
15:54:22 <hpc> and the reverse, anywhere you see the name of something you can mentally replace it with its definition
15:54:36 <hpc> f = \x y -> complicated expression
15:54:36 <crestfallen> just like "body" in my example
15:54:46 <hpc> somethingElse = f tomato tomahtoe
15:55:16 <hpc> is with equational reasoning, the same as somethingElse = (\x y -> complicated expression) tomato tomahtoe
15:55:49 <hpc> you can apply that equational reasoning to fix even, and that's how you know that fix f = f (f (f (f (...
15:55:55 <hpc> just expanding it step by step
15:56:07 <hpc> substitute fix in fix's body, with its definition
15:56:25 <crestfallen> so its a kind of pattern matching
15:56:54 <crestfallen> ?
15:57:11 <crestfallen> the author says something else interesting...
15:57:49 <hpc> i wouldn't call it pattern matching
15:58:14 <hpc> i would probably call it algebra of some kind, if pressed for a word?
15:58:39 <hpc> maybe there's "pattern matching" in there, the same way in high school algebra you would look for certain patterns of formulas to apply which equational rules to, to make it easier to solve
15:58:58 <crestfallen> so technically a fixed point is not recursive though it looks something like it
15:58:59 <hpc> but that's unrelated to the math itself, it's just optimizing your brain for school problems ;)
15:59:32 <crestfallen> is my comment correct? ^
15:59:51 <hpc> (actually algebra's still not quite the right word)
16:00:05 <crestfallen> f-algebra?
16:00:37 <crestfallen> but what is "finding" the fixpoint ? : But recursion can be abstracted away to uncover the real primitives behind expressions. The trick is to define a non-recursive function and then find its fixed point.
16:00:58 <hpc> so this is getting close to the part of math where i personally don't care (the technically-not-recursive bit)
16:01:07 <hpc> iirc that's right and fix is... inductive?
16:01:38 <hpc> in my mind they're sort of traversing the same self-referential kind of structure in different logical directions
16:01:59 <crestfallen> hmm, yeah that's what I was sensing
16:02:30 <hpc> crestfallen: when you ask about finding the fixed point, do you mean in general math or how haskell computation resolves what some (fix f) is?
16:03:43 <hpc> actually i guess at this point we should start talking correctly about how many fixed points there are to a function
16:03:53 <crestfallen> but if it has a purpose where you couldn't use a recursive tree structure then I should probably understand the distinction.   well hpc is the fix point other than the value being resolved?
16:03:55 <hpc> because one can have one or many
16:04:02 <hpc> (or maybe none)
16:04:09 <crestfallen> ok please if you have time
16:04:29 <hpc> i'll talk about how (fix f) is computed in haskell
16:04:35 <crestfallen> please do discuss that
16:04:39 <hpc> because we're in #haskell, and also because that's what i know best
16:04:53 <hpc> so, fixed points are /any/ x such that x = f x
16:04:55 <crestfallen> yeah in the context of haskell
16:05:33 <hpc> and additionally, as an importantly related tangent, values have a notion of "definedness"
16:05:40 <hpc> which forms a partial ordering
16:06:04 <hpc> bottom is the least-defined
16:06:25 <hpc> and then things get more-defined from there based on how far into the value bottom is being pushed
16:06:34 <hpc> but it's a partial order, things can be incomparable
16:06:44 <hpc> True and False are incomparable, but both more defined than bottom
16:07:05 <hpc> (bottom : bottom : bottom) is more defined than (bottom : bottom) is more defined than bottom
16:07:12 <hpc> so, all this in mind
16:07:22 <hpc> what fix computes is just the least fixed point
16:07:31 <hpc> if the least fixed point is bottom, bottom is what you get
16:07:39 <hpc> even if 1 or 2 or "banana" are also valid
16:07:59 <hpc> so let's take a simple example, f = (1:)
16:08:02 <hpc> > fix (1:)
16:08:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
16:09:05 <hpc> first we evaluate (fix (1:)) to whnf - weak head normal form - we evaluate to the "root" of the value's "tree", which is the first data constructor
16:09:18 <hpc> fix (1:) = (1:) (fix (1:))
16:09:27 <hpc> = 1 : (fix (1:))
16:09:37 <hpc> and we have our root constructor, (:)
16:09:44 <hpc> and happen to have also gotten the first element, 1
16:10:06 <hpc> and now we're done, that's actually it
16:10:47 <crestfallen> so I've been trying to handwrite evaluation order lately and ...
16:10:52 <hpc> if the thing /consuming/ (fix (1:)) decides to drill deeper into that value, then we go deeper
16:11:15 <crestfallen> it really looks quite similar to hand-writing a recursive functions step by step output
16:11:59 <crestfallen> if I am correct
16:12:24 <hpc> they're both the same thing, if i understand you right
16:12:34 <hpc> in both cases, you're just tracing haskell evaluation
16:12:36 <hpc> full stop
16:12:49 <crestfallen> ok thanks, that's why I was looking for a distinction to sink my teeth into..
16:14:08 <crestfallen> really appreciate it hpc .. the language is what sometimes throws me off, but I see a structure going through its paces and I pretty much can see what is happening
16:14:35 <hpc> reading my scrollback, i left that explanation of least fixed points kind of half-baked - read http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/
16:15:18 <crestfallen> well you said that about True/False being ...
16:15:33 <crestfallen> incomparable
16:15:46 <hpc> yeah
16:16:38 <crestfallen> youre saying incomparable things cannot be put in order.
16:16:48 <hpc> oh yeah, so let's take an example where the least fixed point is actually bottom
16:16:54 <hpc> and that uses that incomparability
16:17:06 <hpc> f = not
16:17:10 <hpc> what is fix not?
16:17:32 <crestfallen> True == not not
16:17:49 <crestfallen> False == not not not
16:18:16 <hpc> it never converges
16:19:04 <crestfallen> so its not a logical value in that context
16:19:07 <hpc> or you can consider, if between iterations you're stepping from one value to an incomparable one, it's invalid and you can just stop there (i think)
16:19:31 <hpc> so let's follow it the way ezyang's blog posts want us to
16:19:55 <hpc> you start with bottom
16:20:07 <hpc> then apply not to it, and see where you move to in the partial ordering of definedness
16:20:11 <hpc> you stay at bottom
16:20:13 <hpc> boom, there's your fixed point
16:20:29 <hpc> if you do the same with fix (1:), it goes
16:20:36 <hpc> bottom -> 1 : bottom -> 1 : 1 : bottom -> ...
16:20:47 <hpc> up and up the (:) side of the partial ordering
16:20:57 <hpc> and not criss-crossinng to the [] side
16:21:31 <hpc> many many many different ways to reason about fix
16:22:42 <crestfallen> hpc I'm a bit foggy but thanks kindly hpc I'll read the blog
16:23:01 <hpc> yeah
16:23:29 <crestfallen> its like you can't add 1 to infinity
16:23:33 <hpc> that series of posts is how fixed points finally came together as a cohesive thing in my mind
16:24:41 <crestfallen> ok but in a lambda expression passed to fixx , termination is built into the lambda so its a base case just like in recursion hpc
16:24:43 <nshepperd1> I think it's a theorem that if you start from bottom you never move from a value to a different incomparable one
16:25:07 <nshepperd1> The new value is always more defined or equal
16:25:26 <hpc> ah
16:25:48 <nshepperd1> And the limit of this sequence of increasingly defined things is your fixed point
16:27:09 <crestfallen> youre saying 1: bottom is more defined ?
16:27:16 <crestfallen> than bottom?
16:27:25 <hpc> correct
16:27:40 <hpc> later there's a drawing for the [a] type in that blog post
16:27:54 <hpc> bottom : bottom is just up the (:) side of the tree from bottom
16:28:10 <hpc> and then 1 : bottom would be up the 1 side from that
16:28:19 <hpc> if you mentally overlayed the other picture for Int
16:29:00 <crestfallen> so there is a limit as in calculus where you call it fixpoint and call that a solution
16:31:16 <ChaiTRex> Do Int# literals get truncated to 32 bits when using Int64#s on a 32-bit machine?
16:31:51 <ChaiTRex> *when using them as
16:33:29 <monochrom> That is a very mixed-up question. Do you want to talk about Int# or do you want to talk about Int64#?
16:34:03 <ChaiTRex> I want to have literals that don't truncate to use as Int64#s.
16:34:14 <ChaiTRex> I don't have a 32-bit machine, so I can't test how they work.
16:34:38 <monochrom> Then stick to Int64#.
16:34:53 <monochrom> Int# size follows GHC bit-size.
16:34:54 <ChaiTRex> How do I write an Int64# literal?
16:35:17 <monochrom> I forgot. But I would read the GHC user's guide carefully again.
16:35:40 <ChaiTRex> OK. I'll take a look. Thanks for the pointer.
16:36:08 <monochrom> And if that turns out to be futile, I would read base source code where Int64# is declared, there may be incidental examples there.
16:37:16 <hpc> if you can find it, i was just having trouble with both hoogle and hayoo
16:37:38 <monochrom> Hrm Int# is long int?!
16:38:07 <ChaiTRex> Int# is whatever the machine word size is.
16:40:02 <nshepperd> case 17 of I64# n -> n
16:40:05 * nshepperd cheats
16:40:17 <hpc> what if i run haskell in the cloud? then there's no computer!
16:40:42 <ChaiTRex> nshepperd: Hmm, that may be the only way.
16:41:29 <ChaiTRex> The GHC user's guide only mentions literal Char#, Addr# (for strings), Int#, Word#, Float#, and Double#.
16:41:49 <monochrom> Hrm Yeah
16:42:31 <ChaiTRex> I'll try doing a 32-bit virtual machine or something.
16:43:36 <nshepperd> if only fromInteger had PolyKinds
16:49:05 <c_wraith> could Num be rewritten using levity polymorphism?
16:51:04 <monochrom> Err maybe source code of ghc-prim too.
16:54:14 <monochrom> What's unsettling to me is "data Int64 = I64# Int#"
16:54:53 <hpc> does that have a bunch of CPP already evaluated or something?
16:55:48 <monochrom> Oh, right, there is also "#if WORD_SIZE_IN_BITS < 64" "data {-# CTYPE "HsInt64" #-} Int64 = I64# Int64#"
16:56:13 <Axman6> yeah I was about to say it'll be mased on MachDeps.h or something
16:58:52 <nshepperd> hey, it works
16:58:54 <nshepperd> class Num2 (a :: TYPE r) where fromInteger :: Integer -> a
16:59:07 <nshepperd> throw some RebindableSyntax and away you go
16:59:47 <c_wraith> so..  worth proposing to libraries@ ?
17:01:26 <hpc> i wonder what it compiles down to in the unboxed case
17:03:13 <hpc> nshepperd: try it for 0.5 as well
17:03:46 <hpc> it'll probably work too, but might as well make it a complete proposal?
17:03:49 <nshepperd> you mean for Fractional?
17:04:00 <hpc> yeah, and Float# / Double#
17:06:32 <nshepperd> seems to work
17:06:34 <nshepperd> λ> D# (0.5 :: Double#)                                                           
17:06:36 <nshepperd> 0.5
17:08:47 <nshepperd> is it ok for base libraries to use levity polymorphism then?
17:08:57 <c_wraith> they already do
17:09:02 <c_wraith> look at the type of ($)
17:09:12 <c_wraith> (when you have levity polymorphism enabled)
17:27:17 --- mode: glguy set +v N3RGY
17:27:47 <nshepperd> hm, this is weird though, i can't see where the operations for Int64# are exported
17:28:03 <nshepperd> because of that CPP, everything's in terms of Int#
17:28:43 <N3RGY> If I want to make a typeclass F (n :: Nat) (m :: Nat) with three instances, F 0 0, F 0 M, and F N M, how do I do this without requiring IncoherentInstances?  (Sorry if that's a double post, it looks like I was -v'd when I joined)
17:28:45 --- mode: glguy set -v N3RGY
17:30:19 <ChaiTRex> nshepperd: Are you referring to IntWord64.hs?
17:31:00 <nshepperd> well, I was looking for how to implement fromInteger :: Integer -> Int#
17:31:19 <nshepperd> GHC.IntWord64 is empty according to ghci
17:31:37 <nshepperd> i mean fromInteger :: Integer -> Int64#
18:06:36 <rien_> Besides Yann Esposito's Category Theory Presentation, what other Haskell tutorials spend time showing both code and CT graphics like Esposito's tutorial?
18:07:53 <dmj`> @google monads made difficult
18:07:55 <lambdabot> http://www.stephendiehl.com/posts/monads.html
18:07:55 <lambdabot> Title: Monads Made Difficult
18:08:00 <dmj`> rien_: ^
18:11:08 <rien_> dmj`: You have granted my wish. I will go over it and learn it, and if I have further questions I'll come back. Thank you!
18:11:29 <dmj`> rien_: cheers
18:23:52 <rien_> dmj`: Hmm Ok, what I am looking for is what that tutorial does in the end by using the word "would".
18:24:37 <rien_> dmj`: In other words, Yann Esposito's presentation showed me how the same thing (say, Strings) can be represented at several levels of CT. Then Diehl's tutorial showed me how to represent CT in Haskell.
18:24:53 <rien_> What I am looking for is the graphics for what CT Haskell is *actually* doing, not what it could do.
18:25:22 <rien_> In other words, I'm looking for graphics for the last bit of Diehl's tutorial where he starts to say "in Haskell, this CT concept *would* be this..."
18:28:38 <blankhart> bartosz milewski has a haskell/CT series with a lot of illustrations of piglets and firecrackers
18:35:31 <blankhart> there is a book and a youtube series, and every july 4 in nebraska there is a modern dance festival where they act out the diagrams
18:40:21 <zearen> nixos + haskell + zlib = @_@
18:41:08 <zearen> I really should add stack support to this library while I'm polishing it up.
18:45:13 <rien_> blankhart: Yes, I guess Milewski will be my best bet. Thanks!
18:46:57 <selfsymmetric-mu> blankhart: Nebraska...I don't know whether or not to believe you. XD
18:53:56 <arahael> selfsymmetric-mu: The Maybe monad is probably appropriate here, then.
19:13:47 <selfsymmetric-mu> arahael: Hullo?
19:14:59 <arahael> selfsymmetric-mu: Was a bad joke. :)  Wrap the claim in a Maybe, and continue processing it assuming that the claim is true. ;)  Means you don't need to believe it.
19:15:26 <selfsymmetric-mu> XD
19:54:16 <rotaerk> these pixels are so juicy
19:54:43 <rotaerk> (trying out JuicyPixels)
20:44:53 <dukedave> I just needed to share: I was just thinking about how FRP felt like a good fit for a project I'm working on (despite not really 'getting it').  I hit a point where I thought, "yes but srsly where does state go?", so I just Googled that question and by some miracle ended up on this Quora and now suddenly FRP seems so obviously a better way to think about state XD
20:44:53 <dukedave> https://www.quora.com/How-is-state-represented-in-FRP-Can-you-have-something-like-the-state-monad-in-FP
20:49:03 --- mode: glguy set +v Arthur
20:50:00 <rien_> I found this, which I would humbly describe as "Haskell in CT": https://en.m.wikibooks.org/wiki/Haskell/Category_theory
20:50:30 <Arthur> I was wondering if you could  help me come up with a solution to the following problem... I have been struggling for half an hour
20:50:45 <Arthur> maybe just an idea for me to come up with the right solution
20:50:50 <rien_> Yann Esposito's CT Presentation has both "Haskell in CT" and "CT in graphics" and I am looking for more of "Haskell in CT" like the Wikibooks link above, but with more graphics.
20:50:59 <Arthur> I have to define a successor function for the following type
20:51:06 <Arthur> https://pastebin.com/cEv3Hcjk
20:51:39 <Arthur> I wrote some ideas, I see the pattern but in the end, it's not working as it's suppossed to.
20:51:47 <Arthur> Any help would be appreciated, thank you in advance :)
21:15:13 * hackage fast-arithmetic 0.6.0.9 - Fast functions on integers.  http://hackage.haskell.org/package/fast-arithmetic-0.6.0.9 (vmchale)
21:24:43 <rien_> Yann Esposito says "The same object can be seen in many different way as a category. You can choose what are object, morphisms and composition." besides Milewski, is there someone drawing the CT diagrams specifically for the objects and morphisms that Haskell chooses?
21:31:09 <c_wraith> rien_: https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
22:38:34 <ZeuPiark> hello
22:46:10 <ChaiTRex> Hello.
22:46:45 <mauke> hi
22:56:31 <rien_> c_wraith: Thank you, I think that is what I am looking for. For instance, in the Functors chapter, he does mention that fmap does the "morphism-sending" part of Functors, while the constructor does the "object-sending" part.
22:56:50 <rien_> c_wraith: As for that, discussions such as these have helped me understand the terms better: https://www.reddit.com/r/haskell/comments/516htg/learning_haskell_as_a_category_theorist/
22:57:34 <rien_> Which incidentally, has someone clarifying to the OP this same feature, as a matter of example.
23:05:04 <nshepperd> i've been lazily working on a blog post figuring out the technically correct category theory things in haskell
23:06:20 <nshepperd> for instance morphism composition is f . g = f `seq` g `seq` (\x -> f (g x))
23:08:11 <dminuoso> nshepperd: What is technically category theory for haskell?
23:08:12 <nshepperd> which is basically the same as the . in prelude but makes some uninteresting breaking of the associativity law go away when f or g is undefined
23:09:18 <nshepperd> similarly, Hask is a monoidal category when the tensor is data Pair a b = Pair !a !b, which is different from the usual lazy (a,b) everyone's used to
23:16:03 <nshepperd> dminuoso: idk, i'm just interested in whether you can use denotational semantics to put all the category theory stuff we talk about on a more solid footing
23:20:40 <nshepperd> it's also an excuse for me to learn some category theory since i don't actually know what a cartesian closed category is
23:20:42 <nshepperd> yet
23:32:32 <dminuoso> nshepperd: Isn't CT in the presence of bottom _really_ lackluster?
23:32:47 --- mode: glguy set +v jui
23:34:25 <dminuoso> nshepperd: I mean you dont get terminal objects, initial objects, product or coproduct types..
23:35:26 <nshepperd> i dunno
23:35:37 <nshepperd> i haven't read anyone else discussing it
23:41:48 <nshepperd> i suppose that about terminal objects makes sense, since you always get the two morphisms undefined and const undefined
23:43:17 <dminuoso> nshepperd: You have that annoyance with every construction that relies on "unique morphism ..."
23:43:50 <marxS> is there a resource to view the implementations of haskell packages? for example, I'm trying to see whether monoid is addition or multiplication in http://hackage.haskell.org/package/matrix-0.3.6.1/docs/Data-Matrix.html
23:43:53 <marxS> but cant find it
23:44:20 <marxS> semigroup
23:44:21 <marxS> *
23:44:26 <dminuoso> marxS: At the top you have a link named `source`
23:44:42 <dminuoso> marxS: You can also find a similarly named link on each identifier in the haddock file
23:44:47 <marxS> ah ok, didnt see that thanks
23:45:11 <dminuoso> marxS: http://hackage.haskell.org/package/matrix-0.3.6.1/docs/src/Data-Matrix.html#line-175
23:45:11 <dminuoso> marxS: So that way you can directly jump to the definition of some identifier :)
23:54:22 <ChaiTRex> Is there some way to get a precompiled ByteArray or something like it to hold a lot of data or is the only way to get a bunch of data to generate it at runtime?
23:55:01 <Ariakenom> ChaiTRex: C FFI is a way
23:55:35 <ChaiTRex> Is there a way just using Haskell (and GHC's extensions to Haskell)?
23:59:09 <Ariakenom> ChaiTRex: There may be, I don't know. There's also saving it to a file, makes sense if it's a lot of data.
23:59:31 <ChaiTRex> Oh, no. I'd like it baked in to the executable, so to speak.
