01:27:22 <_sras_> Is there a standard class for things that can be encoded/decoded to bytestring ? Can this package, http://hackage.haskell.org/package/readable, be used for this purpose?
01:28:46 <lyxia> cereal and binary
01:29:43 <liste> @hackage binary
01:29:44 <lambdabot> http://hackage.haskell.org/package/binary
01:29:50 <cocreature> Readable looks more like a replacement of Read for efficiency purposes
01:37:40 <gentauro> I seem to have issues with my peer function (creating a p2p app that at the begining should just send every 5 seconds the size of it's events to another peer) -> https://lpaste.net/5769648908401639424
01:38:27 <cocreature> gentauro: you’ll have to be more precise than “I seem to have issues”
01:38:33 <gentauro> I don't really seem to be able to use forkIO (forkFinally) in order to create an "incomming/outgoing" streams
01:38:36 <_sras_> lyxia, liste Thanks
01:38:57 <gentauro> in a recurring function, in this case `peer`
01:40:02 <cocreature> gentauro: that’s still not a description of the actual problem. what happens if you use it? do you get a compile-time error, a runtime error, no error but behavior different from what you expect, …?
01:40:48 <gentauro> cocreature: I'm looking for "a simple" example on how to do in/out communication with Network.Sockets
01:41:08 <gentauro> what I'm getting right is just "crap"
01:42:14 <cocreature> *shrug* if “crap” is the best description of your problem that you can give then I’m sorry but I’m not going to spend my time guessing what might actually happening
01:42:28 <gentauro> what I'm aiming for is: "start main socket that will listen to incoming connections. Once I recieve a peer connection, ensure that you read / write in an arbitrary order (just like a chat)"
01:43:19 <gentauro> cocreature: cool, no probs
01:44:23 <boj> gentauro: i'm not sure how useful this is as it's a tad more complicated, but an example of a network server i am slowly hacking on https://github.com/uncannyworks/armoredbits/tree/master/src/ArmoredBits/Network
01:46:59 <gentauro> boj: yeah it's a bit more complex but I think it's just the example I need in order to create my minimalistic p2p app :) (thx)
01:47:21 <boj> gentauro: cool, glad it may serve as an example
01:53:30 <Athas> Allow me to once again praise ghcid.
01:53:31 <Athas> It is good.
01:53:34 <Athas> That was it.
01:54:47 <gentauro> Athas: say what?
01:56:16 <gentauro> https://github.com/ndmitchell/ghcid
01:56:17 <gentauro> :o
01:56:21 <gentauro> didn't know that existed
01:57:25 <Athas> It is the only remotely IDE-like Haskell development tool that Just Works and does not have nasty error cases.
01:59:09 <gentauro> Athas: I currently have a multi-package setup with stack. Intero just quits and throws the towel ...
01:59:27 <gentauro> (I get error that System.IO can't be loaded ... then you know it's f**d)
01:59:42 <Athas> I've had Intero work OK, but it was pretty slow and fragile.
02:00:01 <Athas> And I found it too complex to debug wtf was going on.  In contrast, ghcid doesn't do much at all, but it never fails.
02:00:40 <gentauro> Athas: Intero doesn't like the following setup -> https://lpaste.net/1891608613403754496
02:06:18 <maerwald> intero just blows up my memory
02:06:36 <Athas> Yes, that too.  Although ghci itself does the same for me.
02:06:50 <maerwald> stack exec ghci not that much
02:06:52 <Athas> ghcid passes -fno-code by default, which makes the pain go away.
02:06:55 <maerwald> and then load only what you need
02:06:59 <maerwald> ghcid is just broken haha :D
02:08:39 <maerwald> the only thing that work in haskell is hasktags/codex
02:09:03 <maerwald> I stopped bothering with any kind of auto-completion or in-editor type info
02:09:11 <Athas> Yes, me too.
02:09:16 <maerwald> when jumping to a function takes 0.01s due to ctags support, you don't care anyway
02:09:19 <Athas> I use ghcid to tell me whether my code compiles, and that's it.
02:10:22 <maerwald> well, ghcid has a broken config file parser
02:10:32 <maerwald> so depending on your needs, you just cannot set it up lol
02:13:48 <Boomerang> The only issue I have with ghcid is if you make a type in a plugin: {-# GHC_OPTIONS -fplugin ... #-} then suddenly everything is "All good" and no error is shown :/
02:13:53 <Boomerang> *typo
02:14:09 <Taneb> Does anyone know a tool for checking whether a cabal file mentions dependencies that aren't used?
02:15:36 <cocreature> Taneb: https://hackage.haskell.org/package/packunused
02:16:20 <croben> don't ask why, but i'm trying to define an instance Num String
02:16:28 <croben> but it won't compile
02:16:31 <croben> https://lpaste.net/2668520772221272064
02:16:37 <croben> what have i done wrong?
02:17:10 <cocreature> croben: neg is called negate and fromIntegral is called fromInteger
02:17:17 <Athas> :info fromIntegral
02:17:21 <croben> lol
02:17:24 <croben> thanks
02:17:30 <cocreature> croben: if you take a look at the docs you’ll see the functions in the typeclass https://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#t:Num
02:17:39 <maerwald> if you remove ~/.stack, is it safe to keep your projects .stack-work or will it be broken?
02:18:01 <Athas> maerwald: has always worked for me.
02:18:09 <maerwald> good
02:18:24 <maerwald> stack has terrible issues with shadowed dependencies
02:18:27 <Athas> I sometimes clean out ~/.stack to remove snapshots I don't use anymore, and it has never caused me trouble.
02:23:37 <gentauro> Athas: do you bind you projects to a specific GHC or LTS?
02:23:52 <croben> cocreature: i know, i was just lazy and thought i remembered them
02:23:57 <gentauro> I've been using LTS all the time and never had an issue with dependencies
02:24:01 <croben> works now :)
02:49:51 <bahamas> hello. I'm setting up haskell language server on vs code. I ran `make build-all` and the README tells me to set "languageServerHaskell.useHieWrapper" to true. the setting doesn't exist though. anyone know what I should do?
03:12:41 <maerwald> install the plugin
03:16:39 <bahamas> maerwald: I have Haskell Language Server installed
03:24:30 <maerwald> how do you set ghc-options in cabal.config?
03:30:10 <Taneb> cocreature: thanks, that's exactly the sort of thing I was looking for
03:47:14 <gentauro> boj: this is how my basic communication looks like for my p2p app (not done yet, but at least I can listen and write arbitrarely) -> https://lpaste.net/5197597957934809088
03:47:56 <gentauro> I added a `keepalive` state
03:48:30 <gentauro> which I reset if I receive the appropiate message
03:48:32 <gentauro> :)
04:01:58 <Taneb> Hmm, Storable and Unboxed Vectors don't have Foldable instances even though I think they could
04:03:14 <lyxia> yes they could
04:03:48 <cocreature> really? toList for a storable vector has type "Storable a => Vector a -> [a]" not "Vector a -> [a]" as required by Foldable
04:04:11 <lyxia> ah... nvm
04:04:58 <cocreature> and unboxed vectors aren’t really any different here
04:05:08 <lyxia> I thought it would be like Set...
04:05:13 <cocreature> except that you have an Unbox a constraint instead of a Storable a constraint
04:05:39 <cocreature> the difference is that for vectors you actually need the instance to read data not only for modifications
04:05:46 <bahamas> I get this error in VS Code. anyone know what it's about? "Got error while processing diagnostics: <command line>: cannot satisfy -package-id base-4.10.1.0 (use -v for more information)"
04:06:20 <cocreature> bahamas: do you only get that in vscode or also when you try to build in a terminal?
04:07:33 <bahamas> cocreature: only in VS Code
04:08:23 <cocreature> not sure then, sry
04:12:05 <jose_zap> bahamas is that with the haskell-language-server plugin?
04:13:53 <cocreature> it sounds like your editor integration might be built for one version of ghc but you’re trying to use it with a different version
04:14:09 <jose_zap> right
04:14:53 <bahamas> jose_zap: yes. well I ran make build-all which should install support for all versions of ghc. at least that's what the README says
04:15:18 <bahamas> but yeah, I also got the error that there's a mismatch between the HIE version and my project's version. I don't know how to fix that
04:15:24 <jose_zap> bahamas I think you need to configure the vscode plugin to use the hie-wrapper  executable
04:15:49 <jose_zap> bahamas https://github.com/alanz/vscode-hie-server#hie-wrapper
04:16:20 <bahamas> jose_zap: it says that, but the extension doesn't have that configuration setting any more
04:16:46 <dfordivam> cocreature: hi
04:16:54 <jose_zap> then try setting the executable path to the hie-wrapper binary
04:17:03 <cocreature> dfordivam: hi?
04:17:24 <dfordivam> cocreature: I think you have a good understanding of llvm so had some questions..
04:17:33 <bahamas> jose_zap: do you know where I can find that binary?
04:18:17 <jose_zap> bahamas check the output of the make-all command, it should say where it copied the binaries
04:18:21 <jose_zap> usually in ~/.local/bin
04:18:50 <cocreature> dfordivam: sure although if they’re not Haskell related #haskell-offtopic might be a better place
04:19:52 <dfordivam> cocreature: so I am exploring the possibility of implementing ghccc in wasm architecture.. and since there are no tail-calls, it has to be done via trampoline..
04:20:23 <dfordivam> are you on #ghc.. I generally discuss this stuff there
04:40:53 <tabaqui> How can I write type signature that looks like "foo :: forall a. Monoid (m a) => m MyType -> ...
04:41:22 <tabaqui> Here I want to say, that (m a) is a Monoid for any "a" and next "m MyType"
04:42:22 <cocreature> tabaqui: wait until GHC 8.6 and QuantifiedConstraints :)
04:42:37 <cocreature> tabaqui: although for this specific case, you might be able to get by with an Alternative m constraint
04:44:06 <maerwald> in a cabal-sandbox I cannot build containers-0.5.11.0 with Cabal-2.0.1.1, why?
04:44:25 <tabaqui> well, Alternative doesn't imply Monoid, but here I mean List or Seq
04:44:29 <tabaqui> cocreature: thanks
04:45:52 <cocreature> tabaqui: Alternative does not imply Monoid but if you have a type where you can make a forall a. Monoid (m a) instance, you can often also provide an Alternative instance for that type
04:47:00 <tabaqui> indeed :)
04:47:36 * ski . o O ( `foo :: (forall a. Monoid (m a)) => m MyType -> ..m..' )
04:49:11 <dibblego> maerwald: use cabal new-*
04:50:38 <maerwald> no
04:50:46 <maerwald> I don't want shadow dependencies and all that crap
04:51:04 <maerwald> then I can just use stack
04:51:57 <cocreature> shadowed dependencies are a GHC bug, not a cabal or stack bug
04:52:06 <cocreature> there is a workaround in 8.4 and a proper fix in 8.6
04:52:13 <maerwald> I can't use either of those
04:52:20 <maerwald> so I want a cabal sandbox to minimize this
04:52:40 <maerwald> but cabal-sandbox doesn't let me install the required container version
04:52:48 <maerwald> can I tell it to ignore dependency checking?
04:55:28 <cocreature> there is --allow-newer and --allow-older. if you tell us what is actually going wrong, someone might be able to help more
04:56:16 <maerwald> rejecting: containers-0.5.11.0 (conflict: Glob => containers==0.5.10.2/installed-0.5...)
04:58:44 <jose_zap> maerwald have you tried already installing it with stack? Unsure if this will help you, but maybe worth a try
04:58:48 <philippD> could this issue be due to the fact that containers versions are bound to the ghc version?
04:58:48 <philippD> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
04:59:08 <maerwald> jose_zap: I said I'm in a cabal sandbox, that's not related to stack
04:59:23 <cocreature> containers is bundled with ghc but as long as you don’t depend on the ghc library, that shouldn’t cause problems
04:59:50 <cocreature> note that things like doctest do depend on the ghc lib so you might end up depending on it without you realizing it
05:01:03 <jose_zap> ah ok, don't mind me then
05:01:33 <philippD> cocreature: does this also hold for `base` and `ghc-prim` or are those hardwired?
05:02:25 <cocreature> those are hardwired
05:04:35 <maerwald> cocreature: it seems it was "binary installed" in cabal.config...and the already installed binary was built against old containers
05:04:49 <maerwald> quite tricky
05:05:10 <cocreature> huh? you don’t install things in cabal.config
05:05:38 <maerwald> constraints
05:05:47 <cocreature> ah I see
05:05:55 <maerwald> I'm using lts-11.13 cabal.config
05:06:22 <maerwald> and a custom ixset-typed, which needs a newer containers
05:06:29 <maerwald> so that causes all these problems
05:07:25 <dataN> this crashes for some reason; https://lpaste.net/7190622676321304576
05:10:12 <jose_zap> dataN because of the error in line 16?
05:10:34 <hpc> dataN: examine what (backwards . forwards) eg is
05:10:39 <hpc> dataN: and then forwards eg
05:11:13 <hpc> dataN: somewhere in there, you're evaluating state []
05:11:21 <dataN> right, but it shouldnt
05:11:39 <hpc> does trumps shouldn't ;)
05:11:43 <dataN> it must be getting the constraints wrong somehow
05:12:12 <dataN> maybe the reason it loops is the same reason it hits that error...
05:12:51 <hpc> your State and Act classes have only one instance
05:13:01 <hpc> so they could just as easily be reasoned about as ordinary functions here
05:13:12 <hpc> oh nvm, you have another State instance
05:13:29 <hpc> and another Act instance
05:13:33 * hpc dies of embarassment
05:13:52 <jose_zap> maybe you can ask the compiler to reason with you by using NonEmpty instead of List for the state?
05:14:07 <jose_zap> that would lead the the place you are passing an empty list
05:14:24 <hpc> ah that's a good idea
05:14:36 <hpc> if it can't happen anyway, don't let it exist in the type system either
05:15:18 <dataN> right, or it could handle the list using maybe, but then it would just return Nothing
05:15:50 <dataN> the only empty list it could encounter is that supplied as the initial value for the tail of the zipper
05:16:54 <hpc> for the first test, with just forwards
05:16:59 <hpc> what is that expression's type?
05:17:20 <hpc> it looks like it's [[Int] -> [Int]] to me
05:17:56 <hpc> and if it's trying to show it and looping there somehow maybe?
05:18:11 <hpc> try (ztail $ forwards eg) `seq` ()?
05:18:16 <dataN> note that the its Zipper b a, not Zipper a b, where 'a' is the "tail"
05:18:17 <hpc> and see if that loops?
05:18:39 <dataN> (when pattern matching on zipper, not when using it as a type...)
05:19:01 <dataN> hpc: yes, that loops
05:19:43 <dataN> 'forwards eg' has the same type as 'eg'
05:19:55 <hpc> oh, i missed that bit in the data definition
05:20:11 <dataN> Zipper :: (Lens (a->a) b,State a (a->a)) => b -> a -> Zipper a b
05:21:23 <hpc> i think i would have to rewrite this so it's a -> b -> Zipper a b, just so it doesn't keep tricking my eyes
05:22:18 <dataN> i.e. [a] can return [a]->[a] by first using the 'State [a] a' instance, and then partially applying (curry act :: Act a [a] => a -> [a] -> [a])
05:23:18 <dataN> this happens on line 20
05:24:39 <dataN> hpc: its an artefact of using ([f a->f a],f a) as the Zipper type with the existance of functions of type (f a -> (a,f a)) and ((a,f a)->f a)
05:25:17 <dataN> this is an attempt to generalise those types
05:26:13 <dataN> maybe there is a way to annotate the undecidable instance, how could it be going wrong though?
05:28:22 <hexagoxel> dataN: why not manually inline `act@(b->b) @b` ?
05:28:57 <dataN> where?
05:29:04 <hexagoxel> line 20
05:29:22 <hexagoxel> state xs = let (f,xs) = state xs in (curry (uncurry id) f,xs)
05:29:53 <hexagoxel> state xs = let (f,xs) = state xs in (f,xs)
05:31:14 <dataN> thought it might be better to tell it which instance to use
05:31:35 <dataN> but that version is ok, and leads to the same error
05:31:48 <hexagoxel> if you know the instance, you can inline its impl
05:33:30 <dataN> oh, well that looks wrong... its supposed to be partially applying something, not collapsing away like that
05:33:48 <dataN> right?
05:38:46 <dataN> without that it throws; No instance for (State [Int] ([Int] -> [Int]))
05:42:02 <hexagoxel> .oO Act is "Pushable", State is "Poppable", Lens is "StackLike"
05:42:19 <dataN> well it lacks empty, but nearly 
05:42:32 <dataN> (Stack would have empty)
05:42:56 <hexagoxel> dataN: there are not even laws, so talking about "supposed" is hard
05:44:30 <dataN> yeah, there are several different options; (f a->f a,f a) and (Maybe (f a) ->f a,Maybe (f a)).
06:04:46 <dataN> this version makes sure the correct version of act is used, which is cons, not id; https://lpaste.net/4649842941676748800
06:05:01 <dataN> but it has the same error...
06:11:40 <ilyaigpetrov> I have executed 'stack install hlint' and it has overloaded my PC for more than an hour already. Why does it take so long?
06:13:01 <dataN> ok, there was a typo; this version at least does not complain about empty lists, however, it still loops! and with the instance now being decidable, it really does not seem as thought it should... https://lpaste.net/6576375914144202752
06:20:29 <ab9rf> ilyaigpetrov: how slow is your internet connection?
06:20:33 <dmwit> Decidable/undecidable instances is about whether the compiler loops; it is completely independent of whether the program produced by the compiler loops.
06:21:12 <ab9rf> enabling undecidable instances will not make your program more likely to loop; what it may do, however, is make the compiler fail to complete
06:21:52 <ilyaigpetrov> ab9rf: it's quiet fast optic fiber
06:21:54 <ab9rf> enabling them relaxes constraints in the type system, allowing type specifications that may be undecidable in the solver
06:22:20 <ab9rf> and Church-Turing says that the solver cannot 100% detect all such cases
06:22:30 <ab9rf> and so it may, in some circumstances, loop
06:22:38 <dmwit> dataN: Line 20 is your loop.
06:22:56 <dmwit> dataN: You say, roughly, in part: let `xs` be the tail of `xs`.
06:23:02 <ab9rf> heh
06:23:12 <ab9rf> it's turtles all the way down!
06:23:48 <ab9rf> ilyaigpetrov: without more information, it's not possible to offer much advice
06:23:57 <dmwit> (Once you've taken the tail infinitely many times, then `f` is the head of what's left.)
06:24:13 <dataN> 'state @[Int] @Int [1,2,3]' works, but 'state @[Int] @([Int]->[Int]) [1,2,3]' loops
06:24:31 <ab9rf> i'm not surprised
06:24:41 <dmwit> dataN: Yes, that is consistent with my explanation of what's wrong.
06:25:02 <dataN> right
06:25:15 <dataN> so why does it use this instance repeatedly?
06:25:25 <dmwit> mu
06:25:33 <dataN> the type annotations tell it to take the head and then partially apply cons to it
06:26:08 <dmwit> Incorrect.
06:26:13 <ilyaigpetrov> ab9rf: the last log message says: attoparsec build, haskell-src-exts
06:26:20 <dataN> i.e. state @[a] @a is called, not state @[a] @([a]->[a])
06:26:25 <dmwit> Correct.
06:26:39 <dmwit> Ah, I think I see your confusion.
06:26:58 <dataN> where is the recursive call?
06:27:06 <dmwit> dataN: `let` is a recursive let. The `xs` inside the body of your function is completely unrelated to the `xs` you take as an argument to `state`.
06:27:29 <dataN> argh!!!
06:27:31 <dmwit> dataN: You could write `state _ = {- same as before -}` and it would behave exactly the same.
06:27:45 <dmwit> dataN: Perhaps you want `let (f, xs') = ... in (..., xs')`.
06:27:47 <ClaudiusMaximus> -Wname-shadowing
06:27:53 <dataN> certainly
06:28:01 <dataN> thanks
06:28:46 <ClaudiusMaximus> -Wunused-matches complains too
06:29:42 <ab9rf> ilyaigpetrov: it should not take that long to build attoparsec
06:40:09 <infandum> I have a program that can analyze many things in parallel and mconcat the results to spit out. It seems to perform well with memory. However, when trying to add a feature that uses the length of the results, sorts the results, and provides an additional element attached to each result, the memory usage exploded. I assume it's because the results could be streamed before but now they cannot. Is there a way around this?
06:40:41 <infandum> To calculate each result there is an extreme amount of computation, but the result is just like three numbers and some text.
06:40:51 <opqdonut> hmm
06:40:57 <opqdonut> you can sort incrementally
06:41:05 <infandum> Those results are what's used for the additional column of information (i.e. p-values to get FDRs).
06:41:07 <dataN> hmm, now how to use the type 'p' now appearing as a proxy tag to Zipper, that is type 'a' of 'Lens a b => State b (b->b)' https://lpaste.net/2098777675186307072
06:41:19 <opqdonut> I mean do a merge-sort instead of mconcat
06:41:25 <opqdonut> but that might not help
06:42:15 <infandum> opqdonut: Is there maybe a way to tell the garbage collector to delete everything that made the result at a certain point?
06:42:21 <infandum> Or is it already doing it?
06:43:04 <dataN> just by strictly storing the intermediate values before acting on them should work
06:44:30 <dataN> e.g. if reading in many files, and taking the length of each and then sorting by length, writing the files lengths to disk, and reading them back in again would work, so then should strict evaluation. is that what you mean?
06:45:18 <infandum> dataN: something like that, yeah
06:45:50 <infandum> I don't even need to read them back in again, the sorting by length then writing the lengths to the disk would be similar
06:46:22 <dataN> that would cause the garbage collector to delete all the contents it read in from the files to determine the length.
06:46:26 <infandum> Would that use up a ton more memory than without sorting by length?
06:47:03 <dataN> infandum: no, you need to write the lengths as the arrive, as in appendFile
06:47:13 <dmwit> infandum: Sorted lists that know their length are monoidal.
06:48:11 <dmwit> newtype SortedList a = SortedList [a]; mempty = []; mappend xs ys = Data.List.Ordered.union
06:48:12 <infandum> No, I mean if no strictness was used
06:48:15 <twynkle> Any opinions about persistent and esqueleto?
06:48:32 <dmwit> newtype SortedListWithLength a = SortedListWithLength (SortedList a, Sum Int) deriving Monoid
06:49:03 <infandum> Like a difflist
06:49:05 <dataN> dmwit: the problem is about trying to store the result of taking 'length' without storing the list supplied
06:49:08 <dmwit> No difflist here.
06:49:30 <dmwit> dataN: What? But that's even easier. Are you sure that's the problem?
06:49:34 <dataN> yes
06:49:52 <dataN> its a common problem
06:49:52 <dmwit> I don't believe you.
06:50:08 <dataN> infandum: is that what you mean?
06:50:12 <infandum> So just use like a bang pattern then?
06:50:19 <dataN> it would seem so
06:50:25 <infandum> I can try
06:50:37 <infandum> It just seemed to explosive in memory
06:51:15 <dataN> well if you take a small metric of a large data and expect it to delete the old data and it does not, then it will consume more memory than expected 
06:53:34 <dataN> dmwit: any idea about the proxy type that cant be supplied to the class instance in the above paste?
06:53:48 <dmwit> I'm having trouble reconciling "I want to add a feature that sorts the results" with "I want to throw away the results".
06:54:52 <dataN> no, the "results" here, were described as "just like three numbers and some text"
06:55:51 <dataN> "To calculate each result there is an extreme amount of computation" seems to mean the same thing as taking a lot of memory
06:56:21 <dataN> "tell the garbage collector to delete everything that made the result" indicates the input should be discarded, and the result retained 
06:58:38 <dataN> instance Lens a b => State b (b->b) where
06:58:51 <dataN> how to annotate state to indicate the type 'a' ?
06:59:03 <dmwit> infandum: It is tough to say what's gone wrong without any code to look at. A minimal reproducing example would be welcome, as always -- and constructing it may just show you what went wrong anyway without our help.
07:00:24 <dmwit> dataN: I suspect you can't, without adding a parameter to `state` (or `State`).
07:00:34 <dataN> thats not an option...
07:01:14 <dataN> seems like a newtype is needed as usual 
07:01:39 <dmwit> instance Lens a b => State (Tagged a b) (b -> b) -- ?
07:02:05 <dataN> right
07:02:14 <dataN> thanks
07:02:16 <dmwit> Or tag the other thing. Or add a type family that chooses `a` given `b`.
07:02:24 <dataN> huh?
07:03:04 <dmwit> Can you turn "huh?" into a complete question, please?
07:03:43 <dataN> the other thing being (b -> b) ? and, can this type family be provided as a constraint? otherwise how else can the instance be resolved?
07:04:16 <dmwit> Yes, "the other thing" is `b -> b`, so `instance Lens a b => State b (Tagged a (b -> b))` also seems like an option.
07:04:47 <dmwit> The type family way would look like `type family Container b; instance Lens (Container b) b => State b (b -> b)`.
07:05:04 <dataN> ok. so, the idea of using 'b' to determine 'a' seems ok, as in this particular use 'b = [a]' 
07:05:42 <dataN> hmm ok, that works 
07:05:49 <dataN> thanks again
07:07:04 <dataN> normally associated types are not as good as explicit parameters though... is there something like 'instance Lens (b `Determines` a) b => State b (b -> b)'
07:08:16 <dataN> the 'a' would be in scope to be used by the definition of 'state'
07:09:26 <dataN> or would it be something like 'instance (Lens a b,Determines b a)'
07:09:55 <dataN> that wouldnt work?
07:09:59 <infandum> Okay, it looks like bang patterns are helping, not sure yet. Of course it's when I decide that "I use bang patterns on tuples too much, let's only use them for accumulating variables". I should just give it up and always use them for tuples.
07:11:16 <dataN> is it that type families like this are kind of ensuring that only one instance exists?
07:12:51 <dataN> in which case, it would be good to be able to indicate somehow, which of two existing Determines instances to use, by supplying an annotation. 
07:13:51 <dataN> is that what Tagged is for?
07:16:38 <dmwit> You can add a fundep to Lens (by turning it into a proper class), but that may be too restrictive on your instances, dunno.
07:16:53 <dmwit> Tagged is just a way to carry an extra type parameter around.
07:17:23 <dataN> what about the 'Determines a b' type family as an alternative to Tagged?
07:17:45 <dmwit> What kind are you hoping to give to `Determines a b`?
07:18:06 <dmwit> Never mind, it doesn't matter.
07:18:09 <dataN> so that some flag can be used to indicate which instance to use
07:18:30 <dmwit> It doesn't help, for the exact same reason you're in this pickle to begin with: that still leaves it to the compiler to choose `a`, and it has no guidance on how to do so.
07:18:51 <dmwit> Changing name from `Lens` to `Determines` doesn't help at all.
07:18:52 <dataN> ah
07:19:54 <dataN> well it would be like; Lens (flag `Determines` a) b => State (Tagged flag b) (b -> b)
07:20:27 <dmwit> Sure, that could work. But then why not just `Lens a b => State (Tagged a b) (b -> b)`? What does the explicit extra `flag` buy you?
07:20:59 <dminuoso> Did warn-incomplete-uni-patterns ever change in behavior?
07:21:24 <dataN> the ability to use a Bool to choose between two available instances?
07:21:29 <dataN> for example...
07:21:33 <dmwit> You can already do that.
07:21:56 <dmwit> Whatever `Determines` was going to compute, you can still compute that and stuff it in the tag.
07:23:31 <dataN> no, the 'a' appearing in your version needed to be the type used by Lens, wheras this would give some way to name the different instances, rather than using the type, which could be ambiguous , e.g. if storing a list of 'Either a a', the type 'a' wouldnt help
07:24:30 <dataN> this doesnt have a "Continer a" instance, but it could have 'Determines Bool a' 
07:25:09 <dataN> anyway, thanks 
07:27:20 <dmwit> But your `Lens (Determines flag a) b` has the exact same problem...
07:27:38 <dataN> probably it needs the extra parameter of the thing its determining it from...
07:27:47 <dmwit> You would have to restructure your `Lens` class completely to deal with it, to make your lenses chosen not just by the types of the source and target.
07:28:10 <dataN> Lens (Determines flag b a) b => State (Tagged flag b) (b -> b)
07:28:53 <dataN> argh, no! that but without 'a' supplied to Determines 
07:29:03 <dmwit> e.g. `class Lens flag where type Source flag; type Target flag; lens :: (Source flag -> Target flag, Target flag -> Source flag -> Source flag)` or whatever. And then somebody would say, "okay, but then if you have to name the `flag` every time you use `lens`, why is this a typeclass at all?" and you would have no answer.
07:29:40 <dmwit> Might as well just name the lens instead of naming the type-level flag that chooses a lens.
07:29:50 <dataN> right, and thats as bad as having to give State an extra flag
07:30:43 <dataN> the flag was to determine 'a' from 'b' given several options that could be unumerated and mapped to the flag type
07:31:11 <nshepperd1> infandum: you're making a left fold where the accumulator is a tuple? Yeah, you want to use bang patterns there to make sure the elements of the tuple are evaluated, not just the tuple constructor
07:31:59 <nshepperd1> OR, use your own accumulator type with strictness annotations instead of a regular tuple
07:35:39 <infandum> nshepperd1: No, it had no accumulator here
07:35:42 <infandum> no folding
08:16:48 <meat_wiggler> foo
08:18:00 <meat_wiggler> so, when people say "Haskell has too much cruft", are they referring to the language spec itself or to GHC specifically?
08:18:35 <dolio> What people?
08:18:42 <dolio> Shouldn't you be asking them?
08:24:39 <meat_wiggler> i've seen the sentiment many times on r/haskell and hackernews, figured it'd be easier to ask here
08:25:15 <lkurusa> hackernews, lol
08:25:18 <Putonlalla> The language with all its extensions has grown quite large, meat_wiggler.
08:25:31 <Putonlalla> The compiler has naturally followed suit.
08:28:37 <nshepperd1> Haskell is the least crufty language I've ever used
08:29:32 <hc> lua is very un-crufty, but can't really compare it to haskell :-)
08:29:58 <lkurusa> i feel like haskell can either very crufty or not, depending on the programmer's choice
08:30:45 <nshepperd1> Hacker News readers might consider having any polymorphism at all to be cruft
08:32:13 <mniip> hc, lua is uncrufty in a different aspect
08:32:31 <mniip> having a lightweight and portable RTS with no extras
08:33:43 <mizunno> Hi, can someone explain me what does the extension FlexibleInstances mean?
08:34:23 <lyxia> mizunno: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleInstances
08:38:51 <mizunno> I see, thanks lyxia :)
08:44:45 <lyxia> yw
08:50:34 <infandum> meat_wiggler: Whenever I see people comment about cruft, it's usually about how String is [Char], unsafe functions like head in base, etc.
08:51:04 <infandum> fmap should be named map
08:51:07 <infandum> stuff like that
08:52:43 <bahamas> hello. does haskell has something like Cargo's add command? that adds a package (crate) to dependencies. also, something equivalent to cargo.lock?
08:52:44 <mniip> infandum, should 'first' be  'p a b -> p (c, a) (c, b)' or '(a -> b) -> f c a -> f c b'
08:53:15 <Ariakenom> bahamas: Are you currently using Cabal or Stack?
08:54:07 <dmwit> mniip: definitely not
08:54:14 <Ariakenom> I don't actually know the answer for either (or Nix). Just seemed like the question to ask :p
08:55:08 <dmwit> mniip: that would be very confusing
08:55:17 <mniip> dmwit, eh?
08:55:28 <mniip> :t Control.Category.first
08:55:29 <lambdabot> error:
08:55:29 <lambdabot>     Not in scope: ‘Control.Category.first’
08:55:29 <lambdabot>     Perhaps you meant ‘Control.Category.id’ (imported from Control.Category)
08:55:37 <mniip> :t Control.Arrow.first
08:55:38 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
08:55:39 <mniip> :t Data.Bifunctor.first
08:55:40 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
08:55:42 <dmwit> mniip: Eh, a dumb joke. You gave the type for the two variants of `second`.
08:55:49 <mniip> oh shi
08:56:08 <mniip> can't count to two eh
08:56:12 <dmwit> =D
08:57:09 <bahamas> Ariakenom: kind of using Stack. I'm going through the Haskell Programming book, which uses stack
08:57:35 <dataN> pairs? 
08:58:06 <dataN> have this; https://lpaste.net/1814211679232196608
08:58:08 <Taneb> mniip: what about r a b -> t (p a c) (p b c) ;) http://hackage.haskell.org/package/categories-1.0.7/docs/Control-Categorical-Bifunctor.html#v:first
08:58:41 <mniip> neat
08:58:53 <mniip> that would be just 'fmap' though
08:59:08 <mniip> in a sufficiently augmented Functor class
09:00:46 <dataN> the problem is when combining these
09:01:05 <Ariakenom> bahamas: You'd probably wanna glance through https://docs.haskellstack.org/ then. I'd guess stack install and stack.yaml are the things you want but I don't know Stack or Cargo :p
09:01:08 <dataN> such as state over a pair, where state itself is a restriction over the possible functions over pair
09:01:37 <mniip> Taneb, why does that package use the name Dual when the widespread name is Op?
09:02:13 <dataN> (a,b) -> (c,(a',b')) has very many ways of being constructed, e.g. using b' to determine a' and a' to and b to determine c. it becomes difficult to count these
09:03:40 <Taneb> mniip: beats me, it was written over 10 years ago by somebody who isn't me
09:04:14 <dataN> the rule would be that no intermediate type should be created. 
09:04:37 <dataN> i.e. a + b = p , p+ a' = c.
09:05:04 <Taneb> mniip: I don't think "Dual" is a bad name, either
09:06:05 <mniip> it's not "bad"
09:06:47 <dataN> Taneb: dual is for categories right? how does that restrict to Cartesian products?
09:08:02 <dataN> it would be good to have rules to handle there combinatorics... 
09:08:40 <dataN> mniip: do any of the types in that paste not appear commonly?
09:09:00 <Taneb> dataN: I'm not sure I understand your question
09:10:20 <dataN> e.g. (a->a') -> (a'->b->b') -> (a,b) -> (a',b')
09:11:20 <dataN> there are very many such combinations for pairs of pairs e.t.c. 
09:12:16 <dataN> seems like something with exhaustivness checking might help generate them...
09:14:54 <dataN> and then how to unfold using them, as in via; state2 :: (s -> Maybe a) -> (a -> Maybe s) -> (s -> Maybe (a,Maybe s)) state2 f g s = fmap (\a -> (a,g a)) (f s) 
09:17:17 <dataN> wait maybe this needs better foundations. sorry
09:17:25 <dataN> another time
09:19:42 <dataN> unfold2 :: (s -> Maybe (a,Maybe s)) -> s -> ([a],Maybe s)
09:20:52 <dataN> https://lpaste.net/347676722142904320
09:21:53 <dataN> mniip: about how to handle the combinatorics 
09:22:32 <dataN> when composing.. e.g. state and pair?
09:26:28 <dataN> like this; https://lpaste.net/7413103541327233024
09:27:42 <dataN> maybe there is some library for this?
09:28:55 <AWizzArd> On https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell I see the following type signature: forall (k :: *) (a :: k). Proxy a -> Proxy a  – is this replacing the existant Proxy which has just one single type argument (a phantom type) with a new Proxy which additionally takes a type of something that is inhabited?
09:29:03 <ChaiTRex> Anyone know the ETA for 8.6.1?
09:30:20 <dataN> it just means the parameter supplied to proxy can have arbitrary kind 
09:30:43 <bahamas> Ariakenom: stack install installs binaries, so it's not the same as npm package install. it's an unfortunate confusion
09:30:48 <dataN> data Proxy (a::k) = Proxy
09:30:57 <dataN> using PolyKinds
09:30:58 <AWizzArd> Exactly, this would make sense. But why mention *?
09:31:16 <ChaiTRex> Is there a way to see the deriving-ed implementations generated on compilation?
09:31:18 <AWizzArd> data Proxy (a :: k) = Proxy   explains it I thought.
09:31:25 <bahamas> as far as I have looked, there's nothing in the Haskell ecosystem to match the features in Cargo that I mentioned. I asked here to make sure I didn't miss anything
09:31:32 <ChaiTRex> AWizzArd: So that the kind doesn't have arrows.
09:31:35 <dataN> otherwise k would not be in scope 
09:32:07 <bahamas> the whole haskell tools experience is pretty frustrating. I tried to setup haskell-ide-engine with both vs code and atom and I got errors both times
09:33:22 <ChaiTRex> Ahh, found -ddump-deriv
09:33:34 <dataN> if you paste the errors perhaps there is an obvious solution otherwise whats the question?
09:33:36 <AWizzArd> dataN: But this funny syntax will only be required without PolyKinds yes?
09:34:42 <dataN> there are a number of reasons the explicit forall may be required, and one of those is to remind the user to enable PolyKinds! 
09:35:45 <lyxia> AWizzArd: It's PolyKinds that allows it in the first place
09:36:37 <dataN> for instance; data Proxy a = Proxy would be ok with PolyKinds enabled (equivalent to the definition above) but would also compile without it, and not work as expected later
10:06:45 <elpfen> Just realized the Haskell logo is not just a lambda, but a bind operator too 
10:07:02 <elpfen> Newt
10:07:16 <elpfen> s/w/a/
10:15:43 <Guest78737> elpfen: that's a checkpoint I proudly achieved recently too. today I got familiarized with the idiomatic representation of bottom in ASCI, the excellent character sequence "_|_"
10:24:49 <Ariakenom> elpfen: I like how your correction is longer than the original message :)
10:25:02 <mbwgh> It just came to me that my code could be greatly simplified by unsafeCoerce. What I am wrangling with is haskeline's InputT, for which I had to write some unsatisfying workarounds because the Internals are not exposed. Question: Can some of the "generic programming classes" like Data, Typeable, Generic, still be derived for these kind of opaque types?
10:25:07 <monochrom> ASCII is so yesteryear. Have a little ⊥.
10:26:07 <monochrom> Your type may actually be eligible for the Coerce class, which is a compiler-checked coerce.
10:26:07 <mbwgh> I just need to be able to use the fact that it is a newtyped ReaderT
10:26:24 <glguy> One you've got a Generic or Data instance, the type can't be considered opaque
10:26:31 <mbwgh> monochrom: For the corresponding Coercible instance to exist, the type constructor needs to be in scope I believe
10:27:07 <mbwgh> @glguy: That's the point. I want to "unopaque" haskeline's InputT.
10:27:07 <lambdabot> Unknown command, try @list
10:28:05 <mbwgh> I believe it can be done with TemplateHaskell, but then this wouldn't simplify my code really. It does work already after all
10:28:12 <glguy> The "safest" way to misuse the library is via Template Haskell
10:28:33 <mbwgh> hmm
10:28:47 <glguy> The best is to add upstream functionality
10:29:31 <mbwgh> I don't think adding an .Internal module is going to happen. The maintainer seems to go out of their way to protect me from myself.
10:29:54 <mbwgh> Besides, ghc depends on the package
10:30:46 <monochrom> Hrm. Which type is it?
10:30:49 <glguy> It'll certainly save time upstreaming improvements to assume they wouldn't be accepted
10:30:58 <monochrom> Oh Haskeline's InputT.
10:31:02 <mbwgh> Yes.
10:31:41 <glguy> What functionality are you needing that isn't exposed?
10:32:09 <mbwgh> I can of course open an issue. And I might have issued a pull request as well, but I looked into the open issues and a lot of them are not answered by the maintainer.
10:34:26 <mbwgh> glguy I just wanted to added a MonadUnliftIO instance, delegating to the instance for ReaderT, around which InputT is a wrapper. Haskeline comes with their own MonadException, which I do not want to show up like (MonadUnliftIO m, MonadException m). Also it provides a typeclass instance for ErrorT and not ExceptT, things like that. This is all not terrible, but they're paper cuts
10:36:02 <mbwgh> Regarding unliftio, I actually do make use of catch/handle. Now with two versions of these functions, one for MonadUnliftIO, and MonadException, things become a little tricky in places
10:49:14 <glguy> mbwgh: I think you're better off forking this package and making it work like you want. MonadException shows up in many on the operations the package exposes. Just getting the newtype opened isn't enough
10:49:50 <glguy> I don't think depending on unliftio is in the future for that package
10:50:31 <glguy> Then you could pull MonadException out altogether
10:51:12 <mbwgh> glguy: You can make use of the fact that IO is an MonadException instance and liftIO that again, which is what I did everywhere. Together with "running" and rewrapping the transformer
10:52:12 <mbwgh> I think the action to take it this point may be to open an issue
10:52:16 <mbwgh> *at
10:53:02 <mbwgh> To add an .Internal module that is, or ask if such a PR would be welcome
11:09:16 <wpcarro> I deleted a directory under my `~/.stack/programs/x86_64-osx/ghc-8.4.3/lib/ghc-8.4.3/path` and now I'm running into `dyld: Library not loaded: ...` problems. Does any know of a fix for this? 
11:09:34 <wpcarro> could it be as simple as a `stack install ...`?
11:11:04 <sm> wpcarro: easy to check
11:11:37 <nitrix> If you delete that whole folder for that version of GHC, I believe stack would re-download it all?
11:11:42 <wpcarro> sm: I'd like to know more about what went wrong also... 
11:12:31 <wpcarro> nitrix: that's the part I'm trying to understand. I'm not too familiar with how Stack installs and resolves packages. I feel like I have packages scattered all throughout my FS
11:12:41 <wpcarro> Will be switching to Nix soon enough, but in the meantime...
11:13:07 <sm> it installs things under ~/.stack and under ./.stack-work
11:13:08 <wpcarro> Also need to know how to call `stack install` to target a ghc version - in this case: 8.4.3
11:13:23 <sm> and in ~/.local/bin
11:13:51 <nitrix> I think normally the stack.yaml is the one that pins the GHC version via one of the lts release.
11:14:23 <wpcarro> nitrix: definitely. In this case, however, since it's in my `~/.stack` folder, it feels global and not project specific
11:14:35 <monochrom> Yeah wouldn't it be nice if file systems had version control so you could just roll back.
11:14:40 <sm> you can use ~/.stack/global-project/stack.yaml then
11:14:41 <dmrd_> hey folks, this may be tricky. I'm trying to create a function-less argument which, everytime it's called, returns a value in a sequence. So the first time its called, it returns 0. The second time, it returns 1 and so on. How would you go about doing this in Haskell?
11:14:42 <wpcarro> sm: thanks for sharing. I guess I need to learn more about when it choose between the three destinations
11:14:54 <wpcarro> monochrom: totally...
11:15:28 <wpcarro> sm: hmm didn't know about `global-project`...
11:15:34 <sm> wpcarro: you don't choose between these, stack puts different things in each (shared tools & libs, project-specific libs, and binaries respectively)
11:15:59 <wpcarro> sm: my resolver in that `stack.yaml` says 8.4.2. Is there a good way to switch this temporarily?
11:16:11 <monochrom> stack uses ~/.stack to store various GHC versions and the packages you indirectly brought in, so that they can be shared by your various projects (whatever is sharable)
11:16:12 <wpcarro> should I just edit the file, or is there a top-level command that is preferred
11:16:13 <sm> wpcarro: sure, you can use --resolver on command line
11:16:39 <wpcarro> sm: giving it a try now. Thanks so much for the information. Very helpful
11:16:56 <monochrom> If you delete some files there. then you need to find out how much more to delete to trigger a proper reinstall.
11:17:17 <monochrom> Unfortunately I don't think there is a direct re-install command.
11:17:28 <monochrom> The problem with leaky abstractions.
11:18:41 <monochrom> I mean, even Steam has "verify installation" (and it actually checks thoroughly and redownloads).
11:19:12 <nitrix> I wonder if you could stack exec ghc-pkg unregister the offending package and install it again.
11:19:56 <sm> nitrix: IIRC that leaves cached files which can still cause trouble, I've had to remove those manually
11:20:05 <sm> but definitely worth a try
11:20:33 <nitrix> That was my experience too. I honestly normally just delete .stack-work when things go sour. ~/.stack I'm not too sure what can be safely removed.
11:20:37 <wpcarro> so when I run `stack install --resolver 8.4.3 integer-gmp`, I get a `Yaml file not found: ` exception... I feel like I'm missing something here
11:21:00 <monochrom> If you don't mind inefficiency and redundancy, you can delete all of ~/.stack and start over. (Unless/Except for some config files you want preserved.)
11:21:18 <sm> agreed, but it's such a lot of rebuilding...
11:21:25 <mbwgh> dmrd_: What do you mean by "function-less argument" ? Have you tried using either an IORef, or a State [Int], things like that?
11:21:42 <mbwgh> Or just State Int
11:21:52 <sm> wpcarro: I think you're not specifying the resolver right ? --resolver lts-12.7 maybe
11:21:58 <monochrom> Or is it argument-less function?
11:22:10 <wpcarro> sm: interesting... I'll try that
11:22:18 <sm> --dry-run is also handy
11:22:30 <monochrom> Like, () is a function-less argument because no one wants to be a function that takes () as argument :)
11:22:41 <dmrd_> mbwgh: thanks for responding :) . I meant a function that does not take an input. Otherwise, it'd be easy to just feed in a number 'arg' and return 'arg +1'. I have not looked into IORef or State[Int] but State[Int] seems like the right way to go, right? Not super comfortable with reasoning about monads...but the "State monad" did come to mind as the way to go
11:22:50 <dmrd_> oh yeah i meant argument-less function haha
11:23:18 <sm> we'll give you plenty of functionless argument if you want :)
11:23:24 <monochrom> Yeah try State.
11:23:54 <wpcarro> sm: so the lts-12.7 worked... problem now is that I'm getting the same dyld error I got before
11:24:13 <sm> wpcarro: what usually works for me is google the error message
11:24:40 <sm> or, feel free to pastebin the output
11:24:41 <wpcarro> sm: ok I'll do some more digging
11:25:13 <wpcarro> sm: https://pastebin.com/LMZA1GJe
11:25:21 <mbwgh> dmrd_ You would need a function `next :: State Int Int` and use `get` and `put` to get the current state (the Int), update the state, and `return` the current state
11:25:34 <wpcarro> the problem is that the missing library is the one that I'm trying to install
11:25:53 <mbwgh> dmdr_: Or similar, there is lots of ways to go about it
11:26:27 <sm> wpcarro: I think probably just deleting that entire /Users/wpcarro/.stack/programs/x86_64-osx/ghc-8.4.3/ is quickest
11:26:31 <dmrd_> mbwgh: Trying to write it right now. Thanks for the function signature
11:26:32 <mbwgh> It is quite likely that you don't need state at all, but could `map` or `foldr` over [1..] instead
11:26:45 <wpcarro> sm: ok I'm open to that... thanks
11:26:57 <sm> it'll reinstall quickly
11:27:35 <wpcarro> awesome. Very helpful information, so thanks for time + patience
11:33:18 <infandum> dataN: Just as an FYI: the bang pattern did work and now the program has sane memory again. Interesting how that worked out -- just finding the length and sorting was enough to shoot it sky high without the bang pattern.
11:33:45 --- mode: ChanServ set +o glguy
11:53:09 <dmrd_> mbwgh: the function you suggested, `next`, would that not take a state monad as an input?
11:58:27 <monochrom> No, it's like "next :: State Int ()", "next = do { n <- get; put (n+1) }"
11:58:27 <monochrom> err, maybe this instead: next :: State Int Int; next = do { n <- get; put (n+1); return (n+1) }
11:59:10 <monochrom> This is pre-increment, like C's ++n.  If you want post-increment like n++, exercise for the reader.
12:02:36 <mbwgh> Exactly. It would however indeed be part of a larger `State Int` computation. Once you have written this `State Int YourFinalResult`, inside which you use `next` via something like `do { ...; n <- next; ... }`, you use for instance `runState` to get a non-monadic function out of it, which you can call as usual.
12:07:34 <dmrd_> Ok so I realize these are pretty silly questions, I've just shy'ed away from Monads for a little while. Thanks y'all for your patience in advance.
12:07:34 <dmrd_> So I realize that calling `runState next 0` would return 1,1). I expect that's not a surprise to anyone. Similarly,`runState next 1` would return 2,2. Can I somehow wrap this in some way such that I can simply call something like 'foo next` and just get the sequence 1, then 2, then 3, etc?
12:09:05 <dmrd_> otherwise, I fail to see the benefit from simply writing a function `add1 x` which takes in a number `x` and returns `x+1`. The issue here being, that I was hoping not to need a constant reference to `x` given some constraints I'm working with :p
12:09:25 <geekosaur> evalState or execState, but generally you combine them into larger State computations
12:09:33 <geekosaur> otherwise, as you say, there's little point to it
12:10:31 <geekosaur> runState (next >> somethingThatUsesTheState >> next >> somethingElse) 0
12:10:48 <dmrd_> I see. hmm
12:10:56 <geekosaur> which again might be evalState or execState if you only care about the result or the final state, respectively
12:11:04 <dmrd_> geekosaur: are you familiar with `biplate` ?
12:11:16 <geekosaur> not very, no
12:14:02 <mbwgh> dmrd_: Most of the times, a transformer comes with a 'run' function which returns a way to "initialize" it and returns everything that was used internally. Then there's the exec* and eval* functions. The exec returns just the state, while eval returns just the result. This doesn't always make sense, like for Reader for example, but is a common pattern
12:14:02 <mbwgh> dmdr_: And just for the record, these are not silly questions. We've all been there, and had to get our hands dirty with these concepts for the first time. It isn't easy for anybody in the beginning really, that's perfectly normal.
12:14:02 <monochrom> dmrd_: Consider this.  myprog = do { i <- next; j <- next; return [i, j] }.  What will runState myprog 7 give you?
12:14:14 <monochrom> Do not think in terms of "foo next". Think in terms of next >>= \x -> ... or do-notation.
12:14:19 <dmrd_> mbwgh: haha yeah I know. I'm just acknowledging that there's clearly something about the paradigm here that I'm missing 
12:14:38 <edmundnoble> StateT does very, very little
12:15:01 <edmundnoble> That makes it very predictable and easy to understand, comparatively
12:15:01 <geekosaur> my very first use of State actually did it the way you've been thinking of, just so I could get used to how State worked. My next iteration rewrote to use it properly
12:15:33 <dmrd_> monochrom: would it return a state monad of state 9 and evaluating 8?
12:15:53 <dmrd_> well actually, I'm not sure about that monochrom. I need to think it thru / run it thru ghci
12:16:28 <monochrom> No.  Let empirical observation refute your mental model.
12:17:07 <dmwit> dmrd_: I think "think it thru" and "run it thru ghci" are both excellent ideas, and you should pursue both.
12:17:07 <dmrd_> ah. `([8,9],9)` . And yeah haha dmwit I'm on it
12:17:21 <monochrom> Oh, my "no" was no to "return a state monad of state 9 ..."
12:18:35 <monochrom> You should always use your mental model to make a prediction. Then use empirical observation to contradict your prediction and eliminate your mental model.
12:18:59 <monochrom> All correct models are built in the ash of destroyed wrong models.
12:19:04 <monochrom> s/ in / on /
12:20:49 <mbwgh> dmrd_: Just some terminology. In `State s a`, `State :: Type -> Type -> Type` is the vanilla type constructor (a function on types), `State s :: Type -> Type` is the monad, and `State s a :: Type` is the monadic action or computation, i.e. really just a  value like any other you can pass around.
12:20:56 <monochrom> In the case of State, it is also possible to mechanically expand the definition of >>= for State and mechanically trace through evaluation of runState myprog 7.  I had a student who was performing poorly but after he did that he grokked it.
12:23:08 <monochrom> It's a bit of a sledgehammer because it's like "my 19th-century model of electron orbitals in an atom is deviating from reality, ah but recently I learned Schrödinger's equation so let me just re-calculate everything from that".
12:24:12 <monochrom> It's tedious but it can work, especially if you trust the formalism and distrust your intuition.
12:24:15 <geekosaur> you're doing pretty good if you can pull that one off for anything beyond hydrogen
12:25:48 <monochrom> Yeah I think they did only hydrogen ever. Still, very representative of what can happen. Like, the p orbitals look totally out of whack, but actually fits known chemistry much better.
12:48:01 <EdwardIII> if i want to draw something out to the console, like a Snake clone, is UI.NCurses my best bet?
12:48:58 <epta> @hackage brick
12:48:59 <lambdabot> http://hackage.haskell.org/package/brick
12:49:11 <epta> EdwardIII: take a look at this
12:49:22 <EdwardIII> cool, thanks epta 
12:49:47 <EdwardIII> i've been trying to understand algebraic types in JS and it isn't really clicking so i thought i'd go to haskell and try and figure it out there instead
12:49:57 <EdwardIII> thought i might make a little snake clone as a learning experience
12:53:31 <dmwit> Haskell has a much cleaner syntax for creating and using algebraic types, so I'm hopeful for you.
12:55:56 <EdwardIII> i've read quite a lot but i want to see how it works in something real world
12:56:04 <kuribas> @pl \x -> (Just (+1) >>= ($ x)
12:56:04 <lambdabot> (line 1, column 27):
12:56:04 <lambdabot> unexpected end of input
12:56:04 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or ")"
12:56:04 <EdwardIII> as i think that will help it click
12:56:19 <kuribas> @pl \x -> Just (+1) >>= ($ x)
12:56:19 <lambdabot> (Just (1 +) >>=) . flip id
13:20:45 <kuribas> how do you make a list of datatypes, to access the typeclasses?
13:21:17 <kuribas> data Types = forall a. Types (Proxy a) ?
13:23:10 <glguy> kuribas: I don't understand the question, but I don't think this is the answer
13:23:57 <kuribas> glguy: I want to serialise dynamically to a database.  However for deserialisation I need to know which types I can deseralise to.
13:24:25 <kuribas> glguy: like Dyanmic, but also being able to store it to the database.
13:25:43 <kuribas> like heterogenous database storage.
13:28:45 <monoidal> Dynamic is TypeRep a -> a -> Dynamic. You can create a similar existential datatype with an extra constraint, like Serializable a => TypeRep a -> a -> MyDynamic
13:29:10 <monoidal> However, this is unlikely what you need - I would be considering creating a variant type that contains all types that the database can store.
13:31:49 <kuribas> That'd be a lot of boilerplate
13:34:07 <kuribas> monoidal: your suggestion would only work for serialising, not for deserialising
13:35:08 <mbwgh> monochrom: Orbitals didn't actually exist before quantum mechanics. Atomic orbital is literally defined as "one-electron wave function", stemming from the analytical solution to the hydrogen wavefunction, a product of functions describing the "radial part" and the "spatial part", the latter of which is also called spherical harmonic. And as you rightfully noted, solutions for He and upwards do not exist, 
13:35:14 <mbwgh> because of the electron-electron repulsion terms, which don't exist for H. You *can* however approximate such a multi-electron wave-function by linear combination of an (unfortunately finite) basis of one-electron wave functions and being really clever about it - however that is really only the beginning. In any case, the chemist's picture comes in large part from this picture, using a minimal basis.
13:39:12 <monoidal> kuribas: I don't understand your problem completely
13:39:44 <monoidal> remember that at runtime types are erased, and classes don't really exist (except in the form of passed dictionaries)
13:40:26 <kuribas> monoidal: we have a large lisp data engine, and I am trying to model it in haskell.
13:41:53 <kuribas> monoidal: we have a large amount of different types.  Encoding them as one sumtype would be possible, but cumbersome.
13:45:56 <geekosaur> you do realize that a function cannot specify its result type, it must accept the one its caller asks for?
13:46:21 <geekosaur> even something like Dynamic (or your own version) only goes so far
13:46:45 <kuribas> geekosaur: yeah, that's why I need a map from typerep to a deserialise function.
13:47:00 <geekosaur> an existential that includes proof that it contains something (de)serializeable is possible. TypeRep might not be the way to go here, though
13:47:00 <kuribas> and I need to know the types in advance.
13:47:56 <geekosaur> possibly you want an existential with some kind of Serializable typeclass constraint, which typeclass would give you serialize and deserialize methods?
13:48:09 <kuribas> Serialise
13:48:35 <kuribas> Maybe it's easier to define a big database schema using Persistent or so :)
13:48:48 <kuribas> But I wanted to see if I can do it generically, like the lisp does.
13:48:50 <geekosaur> still asking for trouble in the future though. I see why you want TypeRep but I suspect one oriented toward the datbaase is better than one based on Haskell types
13:49:19 <geekosaur> possibly involving a type family which indexes on your database type rep
13:53:04 <kuribas> geekosaur: how?
13:53:34 <kuribas> Doesn't cloud haskell use typerep as well for typed channels?
13:54:22 <geekosaur> cloud haskell passes haskell types between haskell programs. databases are not typically haskell programs.
13:55:18 <geekosaur> and usually place their own constraints on what can be stored. (do remember that haskell types include things like function types. cloud haskell handles those specially; databases wouldn't be able to do that quite as readily)
13:55:20 <mbwgh> I think cloud haskell makes use of the fact that you have multiple instances of the same executable, and uses -XStaticPointers which were developed for this purpose.
13:55:26 <geekosaur> yes
13:58:14 <kuribas> the basic idea is to have mutable data for objects that can change state often.
13:58:36 <kuribas> These are stored in a heterogenous map that is indexed by ID.
13:59:37 <kuribas> They are also stored in the database in case the program goes down.
14:00:34 <kuribas> immutable would work as well with lenses, but I am not sure that's efficient for handling gigabytes of data.
14:01:46 <mbwgh> If it's gigabytes, you may need concurrent access anyway. But what exactly prevents you from using a sum-type? You probably answered it before, but I can't see it
14:02:15 <kuribas> mbwgh: it's mostly an hierarchy of product types.
14:02:46 <kuribas> which is quite deep
14:04:08 <mbwgh> That isn't quite a no-go for simple sums of products yet. 
14:04:59 <kuribas> mbwgh: for the database?
14:05:56 <mbwgh> Ah, you mean that it is difficult to synchronize representations?
14:06:44 <kuribas> mbwgh: writing to the database would involve wrapping and unwrapping the sum type.
14:07:44 <mbwgh> So the top-most type isn't some kind of container, but just one huge value of this sop-type?
14:08:16 <mbwgh> or adt
14:08:44 <geekosaur> suddenly i'm wondering if this shouldn't just be JSON or etc.
14:08:48 <kuribas> mbwgh: think of the topmost type as a collection of facturies, the bottom-most individual devices who's metrics we collect.
14:08:52 <geekosaur> cbor, protocol buffers, whatever
14:09:03 <kuribas> geekosaur: serialise is cbor
14:09:29 <kuribas> geekosaur: json is possible, but I thought serialise would be faster
14:09:50 <kuribas> mbwgh: and then do analysis on every level.
14:10:18 <kuribas> mbwgh: which is mostly realtime, though not very fine granularity (about 15 minutes).
14:11:32 <kuribas> mbwgh: the bottom-most types change the most often, that's why I thought having the whole datatype immutable would be inefficient.
14:14:07 <kuribas> mbwgh: refering to devices by ID also makes sense, as they are largely independent from their parents (the factories)
14:15:25 <kuribas> I may even use MVars if a hashmap is to slow.
14:18:03 <kuribas> mbwgh: I am counting more than 80 different types.
14:18:28 <mbwgh> kuribas: Have you actually tried a hashmap yet? With the strict variant you have to do more work up-front, but if most of the work happens in the leaves as you said, there could be considerable sharing. I am *not* sure if gc quirks with large data-sets might become relevant.
14:19:53 <kuribas> mbwgh: the benchmarks I read suggest that reads are much faster than writes, which is pretty good.  Concurrent reads are also great with immutability. 
14:21:34 <mbwgh> Is the work parallelizable, or do values depend on each other?
14:22:17 <kuribas> a lot of it can be done in parallel.
14:23:20 <kuribas> a lot of the attributes are being calculated from other attributes
14:23:23 <mbwgh> Maybe you can afford to make a working-copy of the leaf values into a mutable array of strict k,v pairs, work on these values while allowing the rest of the map to be collected, and when you're done remanifest it and insert
14:24:13 <mbwgh> If it's on a per-level basis as you said, this could be a parallel fold, maybe a scan which is still somewhat parallel
14:24:24 <mbwgh> They scans are tricky :)
14:24:31 <mbwgh> *Thogh
14:24:59 <kuribas> the granularity shouldn't be to small though
14:25:56 <mbwgh> That would only apply for the deepest layers, which I assume are the largest. And this is probably all premature optimization until you have benchmarked anyway :P
14:28:27 <mbwgh> In any case, going fancy-typed will probably bite you in the ass in unexpected ways, same with mutability if you are not sure you need it etc.
14:29:25 <tfn0> hi
14:29:54 <hexagoxel> hi
14:29:57 <tfn0> I'm confused how the following works
14:30:01 <tfn0> lift . get
14:30:08 <tfn0> when it concerns a transformer stack
14:30:22 <glittershark> :type lift . get
14:30:26 <glittershark> @type lift . get
14:30:27 <lambdabot> (MonadState (m a1) ((->) a2), Monad m, MonadTrans t) => a2 -> t m a1
14:30:45 <tfn0> in RWH ch19 it says this will apply get on the surrounding monad
14:30:47 <glittershark> `instance MonadReader ((->) a)` strikes again!
14:30:56 <mbwgh> Did you mean lift . put? Or lift get?
14:30:56 <glittershark> you probably are looking for `lift get`
14:30:56 <tfn0> ch18
14:30:58 <glittershark> @type lift get
14:31:00 <lambdabot> (MonadState a m, MonadTrans t) => t m a
14:31:27 <glittershark> er, `instance Monad ((->) a)`
14:31:37 <tfn0> first of all, I was confused why monad transformers are not discussed in various, including current, books, so I checked RWH ch18
14:32:22 <mbwgh> tfn0: Monad transformers are discussed, including in Learning Haskell from first Principles. It's just mtl that people like to treat superficially
14:32:24 <tfn0> it's on page 437
14:32:57 <tfn0> in http://book.realworldhaskell.org/read/monad-transformers.html
14:33:07 <tfn0> I'm confused by implicitGet and explicitGet
14:33:13 <kuribas> mbwgh: I have described the attributes using type-level strings :-)  It's as fancy typed as you can go.  
14:33:19 <tfn0> 1) I don't understand what's implicit or how implicitGet works
14:33:31 <mbwgh> tfn0: In any case, can you come up with a concrete example for a monad transformer stack where you would need `lift get`? And one where only `get` would be enough?
14:33:32 <kuribas> mbwgh: But this way I can have attributes which are calculated from other attributes.
14:33:43 <kuribas> mbwgh: the way it is in lisp right now
14:34:04 <kuribas> mbwgh: and present it to the outside world as well
14:34:35 <tfn0> mbwgh: how does raising from one level to the one above work? is it RTS magic or pure library I can follow?
14:35:03 <kuribas> tfn0: type class resoluation
14:35:27 <mbwgh> kuribas: If it works, huzzah. I usually try to stick with adts, until I have a reason to use phantom types. I avoid upgrading to GADTs until I have a reason to restrict pattern matches. A reason for everything. Haskell isn't Lisp unfortunately
14:36:06 <tfn0> kuribas: based on return type, the right get is called? even if so, where does the unwrapping happen? sorry about the noob questions
14:36:38 <kuribas> tfn0: yeah, for each layer the right function is looked up (by the typeclasses).
14:36:49 <tfn0> kuribas: I suppose code is generated to runXXX and then apply get, correct?
14:37:28 <tfn0> kuribas: one ore more runXXX, where XXX is that level's monad's type
14:37:39 <mbwgh> tfn0: lift itself is a typeclass method of monadtrans. Each transformer implements this class, otherwise it wouldn't be a transformer. The necessary concrete lift implementation is looked up when the compiler learns the type of the given expression where lift is involved. Like when you use (+) :: Num a => a -> a -> a. It really isn't anything more special than that.
14:37:41 <kuribas> tfn0: for example get will get the state if it's the State Monad, otherwise it will pass it one layer.
14:38:35 <kuribas> tfn0: it works a bit like virtual functions in C++.
14:38:42 <kuribas> methods
14:38:57 <mbwgh> member functions
14:39:05 <kuribas> yeah
14:39:27 <tfn0> kuribas: each one has a distinct lift. ok. still not seeing what part detects how many layers to peel off (with what runXXX)
14:39:59 <kuribas> tfn0: runXXX has nothing to do with it.
14:40:37 <geekosaur> each one peels off one layer. there are predefined instances for all the standard transformers, that amount to "relaying" it down to an instance that does something other than unwrapping
14:41:28 <tfn0> geekosaur: but it cannot have one for each variant, considering I can stack freely
14:41:31 <geekosaur> to take a simpler example, MonadIO: there is one instance that "does something": instance MonadIO IO where liftIO = id -- which just runs the action
14:41:36 <mbwgh> tfn0: Suppose you have two transformer stacks. `type Stack1 a = ReaderT Bool (State Int) a; type Stack2 = StateT Int (Reader Bool) a`. In one of these, you get `get` an Int, in the other you need `lift get`. Why?
14:41:37 <geekosaur> All the others peel off a layer and pass it dowmn
14:42:23 <kuribas> tfn0: it's similar to finding an element in a list.
14:42:34 <kuribas> tfn0: you don't need to know how deep it is in the list.
14:44:44 <mbwgh> It's just the Chain of Responsibility pattern(tm)
14:45:22 <tfn0> if I have type Stack3 a = ReaderT Bool (WriterT Int (Reader Int)) a
14:45:32 <tfn0> which is probably invalid syntax
14:45:51 <mbwgh> seems good
14:45:54 <tfn0> btw, my GHCi wasn't able to typecheck/resolve ':t lift get'
14:45:58 <mbwgh> can't `get` tho
14:46:18 <kuribas> tfn0: there has to be a State monad in it for get
14:46:49 <tfn0> kuribas: whats't the read equivalent in a R/O Reader monad?
14:47:00 <kuribas> ask?
14:47:04 <kuribas> :t ask
14:47:06 <lambdabot> MonadReader r m => m r
14:47:07 <tfn0> right
14:47:26 <mbwgh> tfn0: Are Control.Monad.Trans and Control.Monad.Trans.State in scope?
14:47:28 <kuribas> tfn0: not that you cannot get to the inner Reader with ask
14:47:35 <tfn0> not .State
14:47:59 <mbwgh> Then `get` isn't in scope.
14:48:12 <mbwgh> Or you import Control.Monad.State, which is `mtl`, not the `transformers` package
14:48:39 <tfn0> :m +Control.Monad.Trans.State fixed it, thanks
14:48:41 <mbwgh> `mtl` allows you to infer the necessary amount of "lifting", again via typeclass resolution
14:48:42 <tfn0> anyway, so
14:49:12 <tfn0> type Stack4 a = ReaderT Bool (ReaderT Int (ReaderT Int)) a
14:49:19 <tfn0> is invalid I think
14:49:56 <tfn0> mbwgh: the inferred lifting is what I'm after to understand, the mechanics of it
14:49:56 <mbwgh> the inner needs to be either ReaderT Int m, or Reader Int, which is just ReaderT Int Identity
14:50:24 <tfn0> type Stack5 a = ReaderT Bool (ReaderT Int (ReaderT Int (Reader Int))) a
14:50:53 <tfn0> is Stack5 still working or would I have to be explicit about lifting?
14:51:19 <mbwgh> You always need to be explicit with lifting if you don't use `mtl`, but `transformers`.
14:51:40 <mbwgh> And `mtl` can't handle this kind of stuff, you would need to explicitly lift there as well
14:51:44 <tfn0> my guess about the mechanics is that the type I'm asking for plus the context I'm in are used to deduce how many 'lift' calls are required for the monadic function to do its work
14:51:45 <hexagoxel> mtl ask won't work with multiple Reader(T)s due to the functional dependency
14:53:42 <mbwgh> tfn0: If you call `ask`, you have to be in some `ReaderT r m a`. If you call `lift ask`, the underlying `m` now needs to be a `ReaderT as well`, so `ReaderT r (ReaderT r2 m) a`. Thus with (lift . lift $ ask) you have `ReaderT r (ReaderT r2 (ReaderT r3 m)) a` and so on
14:54:22 <mbwgh> Technically, with (lift . lift $ ask) the outer two don't need to be readers anymore :)
14:54:32 <tfn0> mbwgh: and for contrived examples as given above the automatic lift deducer fails, correct?
14:55:08 <mbwgh> You mean omitting lift by using mtl?
14:55:11 <tfn0> mbwgh: since it's ambiguous because of the same thing wrapped in the same thing ...
14:55:22 <tfn0> mbwgh: I don't know about mtl vs transformers, sorry
14:57:10 <mbwgh> Ok. With transformers, you allways to call `lift` yourself. `mtl` generalizes the concrete transformers, like `ReaderT`, to typeclasses. Thus `ask :: ReaderT r m r` becomes `ask :: MonadReader r m => m r`. And every transformer stack that has a `ReaderT` *somewhere* in it, is an instance of `MonadReader`, thus you shouldn't need to `lift` anymore.
14:57:34 <mbwgh> But that only works if there is only *one* `ReaderT` layer in the stack.
14:57:46 <mbwgh> If not, you need to `lift` again.
14:58:10 <mbwgh> In practice, you shouldn't have to layer readers upon readers - to stick with this example.
14:58:14 <tfn0> mbwgh: because it cannot decide/select for me since there's no unique choice
14:58:35 <tfn0> mbwgh: I did that to understand why I wouldn't need lift with mtl
14:58:41 <mbwgh> You can flatten a `ReaderT r1 (ReaderT r2 m) a` into `ReaderT (r1, r2) m a` for example.
14:58:48 <tfn0> mbwgh: trying to come up with a case that breaks the mechanics
14:59:11 <mbwgh> If I may give you some advice: Stay with `transformers` for as long as you can manage.
14:59:31 <tfn0> mbwgh: I have no idea about mtl vs transformers, just learning Haskell
14:59:36 <mbwgh> If you aren't experienced with them, the type errors you get with `mtl` when you do something wrong will be *very* hard to grok.
14:59:52 <tfn0> mbwgh: monad transformes came up in code I was using, and I had to understand the conventions
15:00:03 <tfn0> mbwgh: thanks for the advice
15:00:24 <tfn0> mbwgh: another issue is that the library I was using also makes use of advanced type level extensions
15:00:37 <hexagoxel> and the errors that you get with more powerful "lift deducers" are even worse :p
15:00:45 <tfn0> mbwgh: and then I scratch my head why I cannot call the library function from inside my regular foo ... -> IO () function
15:01:17 <tfn0> mbwgh: then I realize I have to make my call site's surrounding function be in the same monad stack
15:02:09 <tfn0> mbwgh: which works, until I try to call that wrapper function from another module and I get: No instance for (that-monad-transformer-stack)
15:02:18 <mbwgh> The trick with mtl are three aspects. One: the operations are generalized to type-classes. Two: Each concrete transformer is an instance of this type class, i.e. they provide a concrete implementation. Three: Even when a transformer does not correspond to a type-class, it is *still* an instance, provided that it is wrapped around something (that is wrapped around something (that is...)) that *is* an 
15:02:24 <mbwgh> instance: `MonadReader r m => MonadReader r (StateT s m)` for example
15:04:19 <tfn0> isn't MonadReader r m => MonadReader r (StateT s m) incomplete?
15:04:25 <tfn0> missing the innermost layer?
15:04:31 <tfn0> sorry
15:04:42 <tfn0> that's a type spec not a transformer stack
15:04:46 <tfn0> my bad, reading wrong
15:06:01 <mbwgh> It's an instance declaration. Any StateT s m implements MonadReader, but *only* if there is some underlying monad that implements MonadReader ...
15:06:33 <tfn0> let's say I have this: doFoo :: (MonadFoo FooBar m, MonadBaz m) => FilePath -> m [String]
15:06:37 <mbwgh> I.e. it keeps delegating until a `ReaderT` is actually encountered.
15:06:44 <tfn0> which needs flexible instanced and type families
15:07:02 <mbwgh> you don't need type families, that is something different
15:07:03 <tfn0> the 'm' is unique, correct, and just reused?
15:07:17 <tfn0> mbwgh: trying to reverse engineer a library function I'm using
15:07:23 <mbwgh> ok
15:07:52 <tfn0> mbwgh: and what I'm doing wrong when trying to use it and then export that function as a utility function which is supposed to be called from a aregular foo.... -> IO () function
15:07:56 <mbwgh> The `m` can be anything with kind * -> *, that happens to implement both (MonadFoo FooBar) and MonadBaz.
15:08:20 <tfn0> mbwgh: but the m in that functions' signature is uniqye and isn't different between the two monads, right?
15:08:50 <mbwgh> er, could you elaborate what you mean with unique?
15:09:16 <tfn0> mbwgh: there's one 'm' instantiation and it's the same m in all positions
15:09:21 <tfn0> mbwgh: make more sense?
15:10:03 <mbwgh> Unless you have both `instance MonadFoo f IO` and `instance MonadBaz IO`, you need to "unwrap" it at the call site, usually with some run* function that should come with the concrete transformer.
15:10:43 <tfn0> mbwgh: or a withFoo function?
15:10:49 <kuribas> glguy, monoidal, mbwgh, geekosaur: I managed to do what I wanted, wehter it's a good idea or not :)
15:11:07 <mbwgh> It doesn't *have* to be unique, it depends on how it is used. There are as many possibilities as there are instances of these classes.
15:12:10 <tfn0> mbwgh: but the return type -> m [String]. is the m in there independent of the two m's in the multi constraint definition?
15:12:44 <mbwgh> tfn0: If it is called with* in the code you are using, sure. But usually with* is something of type (a -> m b) -> m b, for instance a partial application of the `bracket` function. It's an idiom people use for resource cleanup / exception safety
15:14:03 <mbwgh> tfn0: No. Both these constraints refer to this `m` specifically. It couldn't be `(MonadFoo k, MonadBar l) => a -> m c, since there would be no way of telling what `k` and `l` should be when called. 
15:14:46 <tfn0> mbwgh: so, it's 'unique', then?
15:14:56 <mbwgh> tfn0: This is very similar to (+) :: Num a => a -> a -> a. It can be Int -> Int -> Int, or Double -> Double -> Double, but not `Bool -> Bool -> Bool`, since `Bool` is not an instance of `Num`.
15:15:19 <tfn0> mbwgh: of course, and that makes sense
15:15:59 <mbwgh> tfn0: It *has* to be uniquely determined when you use it, either inferrable or via a type annotation. Otherwise, you would have an ambiguous type error
15:16:31 <tfn0> mbwgh: I'm using John Wiegley's gitlib, and there I "wrap" the library functions inside a withRepository
15:17:02 <tfn0> mbwgh: which meant that any helper function I wrote to be used in that do block had to have the same signature:
15:17:55 <tfn0> foo :: (MonadGit LgRepo m, MonadLg m) => SomeArg1 -> m [ReturnType]
15:18:49 <mbwgh> tfn0: This is the reason we do all this newtype stuff, actually. There is a `Monad` instance for `(->) r`, i.e. any function `a -> r` is a monad. A reader monad specifically. Now if we were to define a monad instance for `s -> (a, s)`, which one should the compiler choose? This one, or the reader monad again, where `r -> a` ~ `s -> (b, s)` for `r ~ s` and `a ~ (b, s)`? There is one type-class instance per 
15:18:55 <mbwgh> type. Always.
15:19:11 <mbwgh> `r -> a`, not `a -> r`
15:19:57 <tfn0> mbwgh: https://github.com/jwiegley/gitlib/blob/0463bcedf3ef37d0b/gitlib/Git/Repository.hs#L47
15:20:30 <tfn0> mbwgh: sorry, I meant line 10: https://github.com/jwiegley/gitlib/blob/0463bced/gitlib/Git/Repository.hs#L10
15:21:03 <tfn0> mbwgh: ah, sorry again, sloppy at midnight
15:21:19 <tfn0> mbwgh: it's line 53, the last function in the module
15:21:43 <mbwgh> btw, unliftio comes with a directory module
15:21:48 <mbwgh> ok
15:22:06 <tfn0> mbwgh: you take an existing git repo, and then run gitlib's functions wrapped in that "runner?"
15:23:26 <tfn0> mbwgh: I wrote a helper method, extracting out helper code for mapM, and I had to make it: helper :: (MonadGit LgRepo m, MonadLg m) -> SomeArg -> m [SomeResult]
15:23:29 <mbwgh> tfn0: Just to be clear, is this something that doesn't currently typecheck? Or does something wrong? What is the problem exactly?
15:24:17 <tfn0> this works, after making sure any functions I call withing the withRepository have the same (MonadGit LgRepo m, MonadLg m) constraint that defines the -> m [MyResultType]
15:24:48 <tfn0> but when I call the function that runs withRepository from another module, in a regular -> IO () function, I get "no instance ..."
15:25:28 <tfn0> mbwgh: I wasn't sure what kind of monad type signature that is, so I read up on transformers, etc in RWH
15:25:42 <mbwgh> Generally, I would start out with a concrete type signature, i.e. the simplest concrete transformer stack that allows me to do what I want to do. Only when I have that, I would delete the type signature and look at the inferred type. And only if that doesn't cut it in terms of generality, I would look for ways on how to generalize it further.
15:25:56 <mbwgh> It depends on whether you are writing library or application code anyway
15:26:26 <tfn0> mbwgh: application code, using gitlib
15:26:40 <mbwgh> If you have a `MonadFoo` class, you usually also a `FooT` that implements it. This is called mtl-style
15:27:35 <mbwgh> Sometimes you don't need any additional state but only constrain usage of `IO` functions. Which is `MonadUnliftIO` does, hence it comes with an `instance MonadUnliftIO IO`
15:28:49 <tfn0> mbwgh: I only dug in because it didn't type check for me, so I added that "complicated" signature to my helper function which I ran inside the withRepository block
15:29:16 <tfn0> but I'm confused because the example app here https://github.com/jwiegley/gitlib/blob/master/git-monitor/Main.hs#L75 ist just a regular -> IO () function
15:30:45 <tfn0> and I thought I could write withRepository .... in my application code
15:31:27 <tfn0> which gives me: No instance for (Git.Libgit2.HasLgRepo IO)
15:32:40 <tfn0> mbwgh: if I remove all the complicated signature, it all compiles
15:33:49 <tfn0> mbwgh: oh shit, I just fixed it
15:33:51 <mbwgh> tfn0: The first thing you should do when working with unknown types is look at the haddocks and see what instances they implement. If I check the signature of `withRepository`, I see a `MonadUnliftIO m` constraint. I know that one! It's basically either `IO`, `IdentityT IO` (booring..) or `ReaderT r IO`. Or some newtype wrapper around that. That has to apply to `MonadGit` too. Let's check.
15:34:06 <tfn0> and a regular, old foo :: ArgType -> IO [ResType] works
15:34:12 <mbwgh> As you can see if you look at the instance list on hackage, you can see no instance list
15:35:04 <mbwgh> Instances must be defined somewhere else. You should be able to load main in ghci and type `:info MonadGit` and see all available instances
15:36:39 <tfn0> mbwgh: thanks, good idea
15:37:27 <tfn0> tfn0: that libary has several types left as "anything": https://github.com/jwiegley/gitlib/blob/master/gitlib/Git/Types.hs#L44-L46
15:37:43 <tfn0> mbwgh: that libary has several types left as "anything": https://github.com/jwiegley/gitlib/blob/master/gitlib/Git/Types.hs#L44-L46
15:38:08 <tfn0> mbwgh: which looks like the most basic kind, meaning it can be any value
15:39:16 <tfn0> mbwgh: it was confusing to understand where in the libraries stuff gets concrete and how. it was also confusing how the interface and the types/functions within don't match 1:1 what is exposed from the backends (using git exectuable, Hit libary or hlibgit2 libgit2 wrapper lib)
15:39:35 <mbwgh> tfn0: Those are associated types
15:39:43 <mbwgh> Which indeed require type families.
15:41:01 <mbwgh> That means that for instance `Old` is a type function. You can think of it as `Old :: MonadGit r m => r -> Type`. That is, `Old x` will yield some other type.
15:41:23 <tfn0> mbwgh: I kinda suspected that I got myself a very "advanced" lib as the first library to consume as a Haskell beginner
15:41:32 <mbwgh> Yes you did
15:41:45 <mbwgh> it's not easy to navigate either I think
15:41:52 <tfn0> mbwgh: it's a weird lib
15:42:09 <tfn0> the split between interface and backend and how you hook in a backend is confusing, too
15:42:23 <tfn0> especially to a beginner
15:43:03 <tfn0> so, type Oid r :: *, is like "here's a type Oid with a single type param, and it's totally-abstract for now"
15:43:06 <tfn0> correct?
15:43:54 <tfn0> somehow, somewhere, by selecting the backend as part of the withRepository call, the concrete types are chose due to functions selected, I guess
15:44:24 <tfn0> and I, additionally, got confused that I could (or not) run backend-specific functions
15:45:42 <mbwgh> tfn0: When you implement an instance of the MonadGit class, not only do you have to implement the value-level functions like usual, but you have to implement the type-level functions too. That is, you have `instance MonadGit Foo Bar where type (Old Foo) = Int` or something
15:46:19 <tfn0> mbwgh: makes sense
15:46:36 <mbwgh> tfn0: Found it http://hackage.haskell.org/package/gitlib-libgit2-3.1.2/docs/Git-Libgit2.html
15:47:13 <mbwgh> it's in gitlib-libgit2 of course, not gitlib or hgitlib2. How obvious
15:47:24 <tfn0> mbwgh: so any function I want to run from withing the withRepository block
15:47:34 <tfn0> mbwgh: it's a very confusing strucute, agreed
15:47:38 <tfn0> *structure
15:48:31 <mbwgh> It's the `(Applicative m, MonadExcept m, MonadUnliftIO m, HasLgRepo m) => MonadGit LgRepo m` part.
15:48:48 <tfn0> yep
15:49:25 <tfn0> mbwgh: say I write a function doFoo
15:49:48 <tfn0> mbwgh: it has to end with: -> Control.Monad.Trans.Reader.ReaderT LgRepo IO My_Result_Type
15:50:10 <tfn0> at least that's what GHC tell me if I use "_" as signature
15:53:11 <mbwgh> so what is the problem now? How to implement it?
15:54:05 <mbwgh> If you already work with typed holes, you can start with `myhelper x y z = ReaderT $ \r -> do _` and take things from there
15:54:11 <tfn0> mbwgh: just wonderding if I have to write doFoo :: Int -> Control.Monad.Trans.Reader.ReaderT LgRepo IO My_Result_Type
15:54:17 <subttle> Hi, I have what I think is a quick question. I have a data type with two type variables `data GFA q s = GFA { delta ∷ (Either Init q, Either Final q) → RE.RegExp s }` If I keep the type vars in the order `q s` I can define Pointed, Functor, Applicative, Profunctor, etc. I think I want them in this order. However, if I put them in the other order I can define a cool Divisible functor instance... What 
15:54:23 <subttle> is the best thing to do in this scenario? Newtype it with the type variables flipped? Or just define the Divisible instance with a type level Flip constructor? Or is there another class for Profunctors were the contravariant arg is also Divisible?
15:54:24 <tfn0> mbwgh: for each helper function I write that's called in the context of withRepository
15:55:18 <tfn0> mbwgh: what I learned tonight: if you get stuck with a musterious type checker error, then try omitting signatures, it might just compile as expected :)
15:55:23 <mbwgh> It would make sense to do it that way. Since ReaderT over IO seems to be the only instance of MonadGit anyway
15:56:31 <mbwgh> You can of course generalize that to `MonadReader whatever`, but it might not be worth it and will definitely make type errors harder to understand
15:57:08 <mbwgh> And for lifting IO action you only need liftIO. Works regardless of how many levels deep the IO part is in the stack
16:00:07 <tfn0> mbwgh: thanks a lot
16:01:02 <tfn0> mbwgh: I wasted, well, learned about transformers, while scratching my head about the type checker error, which ended up as a mistaken signature
16:02:29 <tfn0> *wasted a day
16:03:52 <mbwgh> Happens. There was a time where I had to learn the hard way that [[]] and [] can make a major difference
16:04:30 <mbwgh> It's usually better if it's a type error
16:05:48 <tfn0> mbwgh: my understanding of how the lifting with transformers works is still foggy, but oh well
16:08:46 <mbwgh> It helps to create some contrived transformer stacks and try to lift over them, run them, newtype them and re-implement instances etc. Learning by doing
16:09:02 <mbwgh> Don't read all the tutorials
16:10:47 <mbwgh> And most importantly, not every problem warrents a transformer stack. If you're forced to be in IO and need some mutable state, well guess what, you don't need StateT over IO. You can use IORefs already
16:12:08 <mbwgh> For what it's worth, I believe this gitlib stuff is a little over-engineered, and is not what every haskell library should look like
16:13:03 <mbwgh> Given what the author had to work with, the underlying c-library, this may have been unavoidable though
16:19:37 <dmwit> subttle: Sure, make a newtype that's an instance of Divisible. But keep in mind that you can also just define some functions that do the same thing and aren't part of the class.
16:19:53 <dmwit> If it's a useful operation, it's still a useful operation even though it's not technically an instance.
16:20:35 <mbwgh> What's the point of Pointed?
16:20:37 <subttle> dmwit: great, I'll try that now, thanks!!!
16:20:57 <hpc> mbwgh: historically, it factored out part of Applicative
16:21:12 <hpc> then it was discovered that its only law was a free theorem
16:21:31 <mbwgh> So it's Applicative sans ap?
16:21:36 <hpc> so, it has no point
16:21:38 <hpc> hehe
16:22:01 <dmwit> mbwgh: yep
16:22:12 <subttle> a lot of people voted against it during AMP but I still like using it :D
16:22:13 <dmwit> "licative"
16:23:32 <subttle> dmwit:  I see what you did there haha
16:24:54 <hpc> going back 10 minutes, even if you find you do want to use a transformer stack
16:24:57 <hpc> put it in a newtype
16:25:06 <hpc> so you can change it later
16:25:32 <hpc> transformer stacks rarely stay the same for very long, in my experience
16:25:58 <hpc> and eventually once you understand your problem well enough, you'll want to just write the perfect data type and be done with it
16:38:31 <koz_> I'm trying sqlite-simple from a REPL. I did the following, and got the error message you see there: https://lpaste.net/4117269986269986816
16:38:36 <koz_> Why is this happening?
16:39:32 <hpc> use Only Double
16:39:37 <hpc> see the instance list on http://hackage.haskell.org/package/sqlite-simple-0.4.16.0/docs/Database-SQLite-Simple.html#t:FromRow
16:39:38 <koz_> hpc: Thanks - _just_ figured.
16:39:48 <hpc> heh
16:54:26 <jkachmar> Hey folks, quick question w.r.t. `ExceptT e IO` versus `IO` exceptions. I'm running some benchmarks and getting results that are counter to my assumptions about the performance tradeoff between the two error handling schemes.
16:54:58 <jkachmar> https://github.com/fosskers/scalaz-and-cats/blob/master/haskell/src/Haskell.hs#L87-L93
16:54:59 <jkachmar> https://github.com/fosskers/scalaz-and-cats/blob/master/haskell/bench/Bench.hs#L55-L65
16:55:03 <jkachmar> https://gist.github.com/jkachmar/201647e6055f129bc188b9a56324dd67
16:55:14 <jkachmar> first two are the benchmarks in question, the gist is the result of having run them
16:56:10 <jkachmar> Is there something obvious I'm missing here? I had thought that `>>=` for `ExceptT` had a performance penalty associated with case analysis of the `Either` 
16:57:26 <hpc> jkachmar: look at what it compiles down to and maybe there aren't even any branches there at all?
16:58:26 <hpc> this is something you'll find in say, gcc as well
16:58:55 <hpc> but haskell is better suited to having a larger proportion of seemingly branchy code go away
17:05:43 <dolio> I thought CPUs are good at predicting branches.
17:06:34 <jkachmar> Updated the gist w/ core dumps
17:06:58 <dolio> The bigger the number in the benchmark, the more times 'same branch as last time' is the correct guess. :)
17:11:03 <jkachmar> I was under the impression that `ExceptT` introduced machinery that GHC couldn't just optimize away though
17:11:35 <jkachmar> And that `IO` (or `ST`) would necessarily be faster because of the optimizations involved with those types
17:12:28 <jkachmar> e.g. https://hackage.haskell.org/package/monad-ste was put together under the assumption that `ExceptT e m` is slower than something w/ an `IO` or `ST` construction
17:13:07 <dolio> Does your benchmark show that ExceptT isn't slower?
17:13:28 <dolio> In realistic code.
17:14:01 <dolio> (It's also possible that STE is unnecessary.)
17:14:45 <jkachmar> I searched around for benchmarks of "realistic code" and didn't find much, hence me going to fosskers' benchmarks repo which just recursively calls the same function binding in either of `ExceptT String IO Int` or `IO Int`
17:15:14 <jkachmar> `ExceptT` seems to be equal or slightly faster for both fail slow (i.e. throw at the end of a benchmark) and fail fast (i.e. throw at the beginning)
17:16:17 <jkachmar> My immediate thought is that the benchmark is flawed (sorry fosskers), and I was hoping that someone might be able to point me to a more realistic benchmark or real-world performance analysis
17:16:57 <dmwit> Is there an unboxed mutable vector suitable for use in STM?
17:21:11 <dolio> dmwit: Not that I know of. I'm not sure if STM has the machinery for that under the hood.
17:21:43 <centril> Is there anyone here who is fluent in a language which is not English?
17:22:03 <centril> (natural language)
17:22:12 <ktonga> o/ Spanish
17:22:54 <centril> ktonga: cool; would you be more likely to say "Is your car red, white, or blue?" or "Is your car red, your car white, or your car blue?"
17:23:05 <dolio> jkachmar: I don't know of anything substantive. But unfortunately I don't think I would trust that that benchmark shows anything. It could only show something if the ExceptT part were actually slower in the benchmark.
17:23:19 <MarcelineVQ> either it fine but the first is better
17:23:23 <ktonga> first option
17:23:27 <centril> ktonga: thanks
17:23:44 <ktonga> did I pass? :P
17:23:50 <hpc> i am very curious now how that relates to programming
17:23:52 <dmwit> dolio: I was afraid of that.
17:23:54 <dmwit> Ah well.
17:23:58 <centril> hpc: my question?
17:24:03 <hpc> yeah
17:24:08 <centril> ktonga: hehe yeah ;)
17:24:22 <dolio> jkachmar: I.E. if it's bad in an extremely simple example, I'd trust it to be bad in a realistic one. But if it's good in an extremely simple example, I don't trust it to be good in a realistic one.
17:24:26 <hpc> some kind of NLP, or are you designing a grammar?
17:24:44 <centril> hpc: I'm trying to see if my conjecture that the mental model for pattern matching is more likely to be in CNF or DNF
17:24:44 <hpc> also i would say the first one, but i am solely english-speaking
17:25:21 <jkachmar> dolio: Yeah, that makes sense to me. At this point I'm just curious what a good example benchmark would be since there's substantial folklore in the community around `ExceptT` representing a significant enough slowdown over `IO`
17:25:23 <hpc> centril: approach it more from parsing, i think
17:25:30 <centril> hpc: i.e. case EXPR of Car(Red | White | Blue) -> EXPR  or  case EXPR of Car(Red) | Car(White) | Car(Blue) -> EXPR
17:25:34 <hpc> is (noun) (choices)
17:25:46 <MarcelineVQ> car is red, white, blue
17:26:27 <centril> hpc: (there's a GHC proposal about this; I'm writing up the Rust equivalent)
17:26:48 <centril> MarcelineVQ: do you speak any non-English language perhaps? :)
17:26:54 <hpc> ah interesting
17:27:01 <chessandgo> does the mzero value of the IO monad have a name?
17:27:20 <hpc> centril: i think either could work, the syntax for patterns is recursive
17:27:24 <MarcelineVQ> None I want to share ehe
17:27:40 <hpc> you just need a suitable distributive law for it
17:27:54 <centril> hpc: it's technically trivial; I'm trying to show that it is desirable
17:29:11 <jkachmar> chessandgo Is it not just `failIO`?
17:29:30 <dolio> jkachmar: Actually, I looked at the core you pasted.
17:29:31 <MarcelineVQ> but I does occur to me that in many non-english languages "your car" might instead be   car [there]  or  car [here]  without mention of ownership, and "is" might be entirely implied by the sentence being a question and thus redundant
17:29:34 <dolio> It's not doing any branching.
17:30:05 <dolio> It completely optimized it down to a loop that just counts down and returns a constant Left value at the end.
17:30:09 <chessandgo> jkachmar: I wouldn't know, I just had assumed that return () would be the empty of IO, but apparently its not
17:30:19 <jkachmar> dolio: yeh, man maybe GHC is good at this optimization thing
17:31:04 <hpc> chessandgo: look at the laws, and try to see what satisfies them
17:31:04 <centril> MarcelineVQ: my question is not about that; but rather whether you'd say  A(B | C | D) or A(B) | A(C) | A(D) in your language
17:31:06 <dolio> I would not expect it to optimize out that amount of branching in general, though.
17:31:15 <hpc> chessandgo: it's a good mental exercise
17:32:07 <marvin2> chessandgo it can't be IO (), types don't match.
17:32:07 <dmwit> chessandgo: What was your assumption about what <|> does?
17:32:07 <chessandgo> hadn't thought of that
17:32:21 <dolio> jkachmar: If you think about it, your code does `pure n >>= selfCall`, and it's going to do enough inlining to know that that's just `selfCall n`.
17:32:49 <chessandgo> just was writing a case statement and wanted a branch that did nothing so I tried empty instead of return () (as it was using a print fucntion)
17:33:07 <jkachmar> chessandgo: if you look up `MonadPlus`, you can see the instance definition and see where `mzero` comes from
17:33:14 <dolio> So at the very least you need to do something where it can't tell whether or not it's going to throw an exception.
17:33:48 <jkachmar> dolio: yeah, maybe a random number generator that triggers a thrown exception or something
17:33:50 <jkachmar> thanks!
17:33:58 <chessandgo> on a similar note, do you import the monoid package and use <> instead of ++
17:34:19 <chessandgo> I noticed the purescript website's hello world example used the mappend for strings 
17:34:25 <dolio> jkachmar: You could probably just error if n%100000 == 0 or something.
17:34:35 <chessandgo> which is quite nice
17:34:45 <dolio> Even though that's always false, it probably won't figure that out.
17:34:57 <jkachmar> hmmmm, I'll give it a shot, tyvm
17:39:51 <chessandgo> after reading about Monoid vs MonadPlus, its becoming clearing now to me
17:42:04 <chessandgo> looking at :info []
17:42:06 <chessandgo> it has
17:42:33 <chessandgo> instance Monoid [a] and instance MonadPlus []
17:43:27 <chessandgo> does the first mean that lists are monoids under the same type, and the second is a monoid under any type?
17:46:47 <ski> centril : "there's a GHC proposal about this; I'm writing up the Rust equivalent" -- proposal about what ? 
17:46:52 <dmwit> chessandgo: Yes.
17:47:03 <dmwit> chessandgo: They mean essentially the same thing.
17:47:07 <dmwit> (In this case.)
17:48:00 <ski> centril : also, how about "Do you want coffee or tea ?" vs. "Do you want coffee or do you want tea ?" ? how does that fit with CNF vs. DNF ?
17:48:46 <chessandgo> dmwit: why is one [] and the other [a] , is there any signficiance to the a type variable
17:50:15 <dmwit> Of course there is significance.
17:50:33 <dmwit> The two type classes classify over different kinds.
17:50:49 <dmwit> MonadPlus is a property of parameterized types only.
17:51:16 <dmwit> Monoid can (must) apply to types which take no parameters.
17:51:29 <dmwit> e.g. Text and ByteString are Monoids (with essentially the same behavior as [a]'s instance), but can't be MonadPlus because they're not parameterized types.
17:52:47 <chessandgo> hm, but String, for example, is an instance of a MonadPlus because its a case of the paragertized []
17:53:52 <dmwit> No, String is not an instance of MonadPlus.
17:54:00 <dmwit> Only []. Not [Char].
17:54:20 <chessandgo> ah
18:13:08 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
18:13:08 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
18:47:52 <rotaerk> hmm using reflection to solve the configuration problem... I wonder if a good application of this would be, for instance, reifying a Vulkan device/instance, since most Vulkan functions need one of these
18:52:05 <centril> ski: the first seems to me CNF and the second DNF; I'd always say the first myself
18:52:05 <centril> ski: https://github.com/ghc-proposals/ghc-proposals/pull/43
18:56:33 <ski> centril : hm, realized i rather wanted an example like "I ordered eggs and bacon." vs. "I ordered eggs and I ordered bacon.#
18:56:33 <centril> ski: that's more like  Ordered [Eggs, Bacon] -> EXPR
18:56:33 * ski . o O ( <https://en.wikipedia.org/wiki/Coordination_(linguistics)> )
18:56:33 <centril> vs. [Ordered Eggs, Ordered Bacon]
18:56:44 <ski> well, probably both can't type-check at the same time
18:57:08 <centril> ski: fine... Ordered <$> [Eggs, Bacon]  :P
19:01:41 <dolio> "Do you want coffee or tea" isn't necessarily the same as "do you want coffee or do you want tea" though.
19:04:08 <centril> dolio: no?
19:04:08 <dolio> The latter kind of suggests that you must choose either coffee or tea, while the former leaves an option to deny either.
19:04:08 <centril> dolio: perhaps via tone; but the former does not necessarily entail compulsion
19:04:30 <centril> at least not to me
19:04:40 <centril> and I'm not sure it is even suggested; I think it is understood that you can say "neither"
19:05:23 <geekosaur> yes, it will depend on tone, context, etc.
19:05:23 <dolio> Right, but not in the second.
19:05:23 <geekosaur> trying to analyze natural language with formal logics doesnt work very well
19:05:23 <centril> geekosaur: for sure
19:05:32 <centril> but I think natural languages can inform language design wrt. mental models
19:06:06 <dolio> Anyhow, if `p | q` is a pattern, I don't see why you wouldn't allow `C(p | q)` as an option, even though `C(p) | C(q)` is the same way of using a more general case for the same thing.
19:06:26 <centril> dolio: that's the case I'm trying to make :)
19:06:49 <dolio> I have some redundant words in there, I think.
19:09:18 <dolio> Well, I can think of reasons, I guess.
19:09:55 <dolio> But it's probably possible to allow it given some restrictions.
19:11:08 <centril> dolio: I mean, you can just desugar a language with C(p | q) into one with C(p) | C(q)
19:11:37 <dolio> It depends a lot on how you're handling things.
19:11:42 <centril> dolio: such as?
19:13:27 <dolio> Well, if each disjoined pattern can bind different things at different types, then you need (in general) disjunctions of terms on the right. And then if you nest disjunction patterns, it can become unclear which things correspond to which, I think.
19:14:27 <centril> dolio: but each disjoined pattern needs to introduce the same exact bindings at the exact same type or you'll have a type error
19:14:37 <dolio> If you get rid of some parts of that, it's probably easier, though.
19:15:43 <dolio> Okay, well, that's definitely restrictive enough.
19:15:43 <dolio> You don't _have_ to do that, though.
19:15:43 <dolio> Like, ski doesn't want to do that. :)
19:15:47 <dolio> Although I think you probably should.
19:15:47 <centril> dolio: wrt. performance I think going  C(p) | C(q) => C(p | q)  might be more performant
19:16:07 <centril> dolio: hmm well; I think you'll have soundness problems if you don't :)
19:16:31 <centril> or very funny semantics alternatively
19:18:13 <centril> like an exception if one alternative in the pattern didn't introduce the binding and it was matched
19:18:13 <dolio> I think if you gain performance by doing that rewrite on your code, the compiler isn't very good.
19:18:13 <centril> yuck :P
19:18:13 <centril> dolio: elaborate?
19:18:19 <dolio> Well, GHC compiles all patterns to one-step case analysis.
19:20:11 <dolio> Because that's all that exists at the low level representation.
19:20:11 <dolio> So those would both compile to something that matches on C first, and then proceeds to match on p vs. q.
19:20:11 <centril> dolio: so it does what I said?
19:20:11 <centril> I didn't mean that the user should do the transformation
19:20:11 <centril> that would be ridiculous
19:20:12 <dolio> | wouldn't even exist at that low level.
19:20:25 <dolio> Most likely.
19:21:16 <centril> dolio: yes well; the effect of one-step case analysis can be thought of as doing C(p) | C(q) => C(p | q) in the surface syntax
20:30:46 <tnks> I don't remember this dot-file showing up in my projects before.  Is this a normal artifact of cabal new=build now?  Or something else?  .ghc.environment.x86_64-linux-8.2.2
20:31:30 <tnks> I asked too soon:  https://github.com/haskell/cabal/issues/4542
20:31:36 <boj> tnks: it's new as of 2.2
20:31:54 <boj> and is a hot topic as well - kind of breaks CIs and stuff
20:39:32 <tnks> boj: yeah, I'm seeing this now.  I still don't know what's in it exactly, or why it's breaking things.
20:40:12 <glguy> It's so when you run ghci, for example, your new-build installed packages will be available
20:40:27 <glguy> It makes things like doctest work on their own
20:41:19 <whatsupboy> Hey guys I see https://www.haskell.org/documentation  its improved a lot
20:41:44 <whatsupboy> http://haskell.cs.yale.edu/wp-content/uploads/2015/03/HSoM.pdf   new books title and contents very intresting
20:42:15 <tnks> glguy: didn't that already work with `cabal new-ghci`?  Or is this something that ghci picks up independently of Cabal?
20:42:34 <glguy> ghci picks it up on its own
20:42:45 <glguy> and other tools too, like the doctest executable
20:49:11 <tnks> glguy: I think I'm figuring some of this out now.  I'm actually looking at the file more now.  I see a helpful comment at the top I missed.
20:49:30 <tnks> Why are some packages suffixed with a hash, but others not?
20:49:51 <tnks> I guess if they are pure-haskell?
20:49:53 <glguy> The ones that come with GHC aren't
20:50:29 <tnks> I'm using Nix... so all are provided as a ghcWithPackages.
20:50:34 <tnks> a little confused then.
20:51:18 <glguy> I don't know, I haven't had to use Nix. For me the ones that come with GHC have no hash and the ones that new-build built do
20:52:23 <tnks> glguy: okay, kind of curious then.
21:12:54 <tnks> glguy: okay, so all the package ids are from the Nix-generated stuff... not sure why some have hashes and other's don't.  But it's all global.
21:13:23 <tnks> but I think I'm in the camp that this file is not useful as a default.
21:13:31 <tnks> people should opt-in, not opt-out.
22:22:56 <boj> MarcelineVQ: you asked how people figure out how to structure haskell apps yesterday (which is crazy to me, i feel like you've been around the block more times than myself) - here's a semi out of date IOHK document which points out some experiments they have done https://github.com/input-output-hk/cardano-sl/blob/1d79a801936edeb4bde7f41187924bc59c7b9b20/docs/cardano-monads.rst
22:24:01 <boj> i get the impression that there are just way too many ways for us to shoot ourselves in the foot and it'll take another decade to settle on something common :)
22:24:15 <MarcelineVQ> I'm into all of the things but write very little
22:24:24 <boj> ah, gotcha
22:24:36 <MarcelineVQ> atm I'm reviewing the parallel and conccurent programming book because it has some good examples
22:24:45 <boj> fantastic book
22:24:56 <MarcelineVQ> especially since I'm wanting to make a server
22:25:15 <MarcelineVQ> well, part of it is that anyway, it's relevant in any case
22:25:30 <MarcelineVQ> thanks for the link I'll peruse
22:25:54 <boj> not sure how genuinely useful it is, but they talk about a lot of things i am still trying to discover with my team
22:26:54 <MarcelineVQ> Actually the thing I'm working on is reminiscent of your previous endeavour, though the clients aren't human
22:27:25 <MarcelineVQ> Or rather that role is redundant :>
22:27:30 <boj> in that case, very similar then :)
22:27:56 <boj> i scrapped my original project. it was quite literally what got me into haskell
22:28:09 <boj> hacking on a public version now, albeit slowly
22:28:43 <boj> look forward to seeing what you build! (if you make it public)
22:29:32 <MarcelineVQ> I'm sure parts will be, at least enough for people to tell me how wrong I'm doing it
22:29:55 <boj> if you find the "right" way clue me in
22:30:33 <MarcelineVQ> The right way is to make someone else do it but that's not the option most people have access to
22:30:40 <boj> hah
23:30:47 <boj> "In Haskell 2010 Language Definition, Num is not listed as a derivable class. But with GeneralizedNewtypeDeriving language extension of GHC, we can lift the instance definition of Num Word up to Num Id" -- lifting terminology is still slightly confusing to me. what does it mean to "lift X up to Y" here?
23:32:11 <cocreature> boj: in this case “lift” just refers to translating the instance of Word to the instance of Id by adding a bit of newtype wrapping/unwrapping/coerce
23:32:21 <opqdonut> lifting typically means converting an operation "f : A -> B" to an operation "f : A' -> B'" where A' contains or subsumes A
23:32:29 <opqdonut> and B' does the same for B
23:32:52 <boj> ok, i think i get it. thanks
23:32:55 <opqdonut> in this case it means getting a "(+) :: Id -> Id -> Id" from "(+) :: Word -> Word -> Word"
23:33:12 <opqdonut> the canonical example of lifting is fmap, I guess
23:33:25 <boj> basically, you can treat Id as if it were a Word?
23:33:40 <opqdonut> well you still can't do id+word
23:33:49 <boj> right
23:34:53 <boj> does that apply in all cases where we use the word "lift" in haskell?
23:35:47 <boj> like, when we talk about the function lift in a monad transformer stack, we're actually saying we want to translate from monad M to monad N?
23:37:18 <MarcelineVQ> no, just that we want to talk about our value at the same level we're talking about our stack. when there's layers of abstractions lifting is to take something up an abstraction layer
23:37:36 <boj> hmm, ok. so different meaning in that context
23:37:41 <MarcelineVQ> Same meaning :>
23:38:36 <boj> interesting. i mean, conceptually lift . lift . lift makes sense, i want to lift my function to the 3rd layer of the stack
23:41:14 <boj> ok, i get what you mean now. "lifting up the abstraction layer" are the key words
23:41:35 <boj> whether it be a stack, or a type instance
23:45:04 <MarcelineVQ> This is my understanding at this time. It'd be a good idea to ask again when more people are around for more answers.
23:46:12 <boj> yes, because the next question is, "where did hoist come from, and how is it different from lift?" :)
23:47:05 <cocreature> I wouldn’t try to interpret too much meaning into “lift” and “hoist”. most people use those terms fairly loosely
23:47:39 <boj> ok, so there's not actually a mathematical relationship with those words then
23:49:25 <cocreature> there is a mathematical relationship for certain uses of “lift”, e.g. fmap, liftA2, … but as demonstrated by your previous quote people definitely use lift in concepts where it doesn’t refer to some functorial lifting
23:55:55 <madnight> is there a map function that applies fmap as many times as required to fmap over the deepliest nested structure, similar to deep flattening
23:56:41 <liste> madnight: what would its type be?
23:58:59 <madnight> hmm what's the type sig of deep flatten?
