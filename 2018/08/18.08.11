00:00:09 <cocreature> koz_: right but afaik ghc uses those because people use them in type signatures not because ghc has some builtin nrule that it should use f for typeclasses. but I’m mostly just guessing here so I might be wrong :)
00:00:33 <koz_> cocreature: OK, thanks. I've noticed it changing sometimes through various GHC versions I've been using.
00:00:44 <koz_> Hence my surprise at 'p'.
00:11:33 <kuribas> is it possible to have a type level mapping from symbol to value?
00:11:42 <kuribas> (symbol being type level string)
00:12:06 <kuribas> so I could associate a number of "properties" with a datatype, some of which may be dynamically calculated.
00:13:33 <kuribas> maybe a heterogenous list?
00:26:53 <mniip> 1533970618 [09:56:58] <koz_> Is there any system to how GHC picks the type variables it uses when it complains about missing signatures?
00:27:16 <mniip> the typechecker makes up a name based on what kind of process led to the creation of the type variable,
00:27:34 <mniip> plus if this variable is ever unified with a user-provided type variable, the user-provided name takes precedence
00:30:49 <koz_> mniip: OK, thanks.
00:30:52 <mniip> @let foo :: forall (i :: * -> * -> *) love pizza. i love pizza; foo = undefined
00:30:54 <lambdabot>  Defined.
00:30:55 <mniip> :t foo
00:30:56 <lambdabot> i love pizza
00:31:03 <mniip> :t (\x -> x) foo
00:31:04 <lambdabot> i love pizza
00:31:25 <koz_> That's... kinda hilarious and awesome.
00:31:41 <koz_> (is that an identity pizza you've got there?)
00:31:52 <mniip> :t fmap id foo
00:31:53 <lambdabot> Functor (i love) => i love b
00:32:06 <koz_> :t (\x -> 2) foo
00:32:07 <lambdabot> Num p => p
00:32:19 <koz_> Awwwwwwwww, I wanted a const pizza.
00:33:44 <kuribas> HList looks interesting, is there a tutorial for it?
00:35:01 <koz_> kuribas: Not that I know of - I came across it recently for similar reasons to your own.
00:38:27 <kuribas> there's also hvect
00:58:34 <lavalike> > let xs = [1,3,5,8]; do { x <- xs; let ys = xs \\ [x]; y <- ys; return [[x],[x,y]]; }
00:58:36 <lambdabot>  <hint>:1:57: error:
00:58:36 <lambdabot>      parse error on input ‘<-’
00:58:36 <lambdabot>      Perhaps this statement should be within a 'do' block?
00:58:40 <lavalike> what am I missing
01:01:04 <lavalike> (oops, the first ; is meant to be an "in" but that is not the problem.) 
01:04:19 <kuribas> > let xs = [1,3,5,8] in do { x <- xs; let ys = xs \\ [x]; y <- ys; return [[x],[x,y]]; }
01:04:22 <lambdabot>  <hint>:1:59: error:
01:04:22 <lambdabot>      parse error on input ‘<-’
01:04:22 <lambdabot>      Perhaps this statement should be within a 'do' block?
01:07:07 <kuribas> > let xs = [1,3,5,8] in do {x <- xs; let {ys = xs \\ [x]}; y <- ys; return [[x],[x,y]]; }
01:07:09 <lambdabot>  [[[1],[1,3]],[[1],[1,5]],[[1],[1,8]],[[3],[3,1]],[[3],[3,5]],[[3],[3,8]],[[5...
01:07:14 <lavalike> YAY
01:07:45 <kuribas> lavalike: it assumed the semicolon after let was all part of let.
01:26:06 --- mode: glguy set +v romanix
01:26:08 <romanix> Do you see any compilation speed differences between GHC 8.0.x and 8.2.x? I'm doing some ad-hoc benchmarking now and it looks like I'm getting about 15%-20% speed improvement on 8.2.
01:26:42 <merijn> romanix: I saw some emails about improved build times in 8.2
01:30:58 <romanix> I wish there was a bit more consideration for speed among GHC developers :/
01:31:23 <romanix> Waiting for compilation kills my productivity atm
01:31:35 <Athas> Unfortunately, that's hard to writer papers about, and I think most GHC developers are still researchers.
01:31:40 <merijn> romanix: There's only like a handful of them and most of them are doing this only as a small part of their main job
01:32:03 <merijn> romanix: The best way to improve X in GHC is "start working on X or pay someone to do so"
01:32:34 <romanix> I understand the reasons for this situation.
01:33:16 <cocreature> well the fact that 8.2 improved things shows that GHC devs _do_ care about compilation speed
01:33:30 <romanix> It's free software after all and everyone has their own goals
01:33:39 <cocreature> in terms of practical ways to make your life easier, ghci helps a lot
01:33:41 <merijn> hmm, I don't suppose persistent has a LIKE operator/filter?
01:33:45 <Athas> Was that "consolidation release"?  I remember there was a release cycle where the focus was on stability and speed rather than more features.
01:33:49 <cocreature> especially in combination with something like ghcid
01:33:56 <cocreature> Athas: yeah
01:34:09 <merijn> Also, splitting TH and code with huge records into separate modules that don't change much will help
01:34:29 <merijn> romanix: Also, is this because you want to get type errors/warnings for your code ASAP?
01:34:33 <romanix> cocreature, yeah. I use ghci, intero, avoid TH and use -O0 :)
01:34:42 <merijn> romanix: Because if yes, try using "-O0 -fno-code"
01:34:54 <merijn> romanix: You're not using -fno-code yet ;)
01:35:13 <merijn> romanix: That skips code generation and only does type-checking
01:36:27 <romanix> merijn, i think intero does -fno-code by itself
01:56:45 <madnight> romanix, so you type :r how slow is it? (in seconds)
02:03:04 <romanix> madnight, i don't recall ghci numbers but full ghc recompilation takes 30-45 seconds depending on flags
02:03:33 <fnurglewitz> romanix: really? it takes more to compile vim on my i7 
02:04:11 <romanix> fnurglewitz, I mean full recompilation of my silly app using ghc :)
02:04:20 <fnurglewitz> oh ok :D
02:04:34 <fnurglewitz> I was thinking my i7 was a bit slow :P
02:04:38 <madnight> well that doesn't sound to bad for full compilation
02:05:23 <madnight> e.g. compiling firefox from scratch takes up to 4 hours build time : )
02:06:16 <romanix> madnight, well I've been following Jonathan Blow's jai language and Haskell build times annoy me now :)
02:06:24 <epta> in hspec, is there a way to mix 'beforeAll' and 'before', so that the latter uses the result of the computation of former? 
02:07:59 <madnight> romamix, you should go all out for ghci during development, and basically only compile if you want to run all tests and ship
02:10:16 <romanix> madnight, ghci does help but for performance optimisation I need the full thing with -O1
02:11:06 <romanix> anyway, it's just complaining :)
02:11:31 <madnight> romanix, and you even need these performance optimizations while developing?
02:12:46 <madnight> romamix, usually devs are okay with the fact that the debug build is much slower compared to the production build
02:12:57 <romanix> madnight, by "performance optimisation" I mean me changing my code so that it performs better, not GHC optimising things for me
02:14:12 <madnight> romanix, because you mentioned -O1, thats
02:14:24 <madnight> compiler optimization
02:15:50 <romanix> madnight, yes, I need -O1 so that I know how GHC behaves when I optimise my code by hand
02:16:21 <romanix> to know whether my changes are effective
02:17:31 <madnight> romanix, well if you have such deeply critical code (performance-wise) you could consider to write that portion in C and add it via FFI
02:18:30 <madnight> C is not only faster in execution, it also compiles extremely fast
02:20:26 <romanix> madnight, yes. It's an option I'm considering
02:30:42 <kuribas> anyone used generic-lens instead of normal lens?
02:32:40 <kuribas> how well does it work?
02:32:58 <kuribas> doesn't it generate hard to read error messages?
02:39:51 <Ariakenom> madnight: "[C] also compiles extremely fast" could you tell that to my work codebase?
02:40:23 <kuribas> Ariakenom: C or C++?
02:40:37 <Ariakenom> C
02:41:02 <kuribas> ghc also does a lot of stuff that C doesn't
02:41:16 <kuribas> like type level computations, removing abstractions
02:41:28 <madnight> Ariakenomen: in absolute terms it's possible to write a C program that coi
02:42:24 <madnight> compiles 1 year, but in relative terms it's one of the fastest compilers out there
02:55:48 <veverak> P.S: and for large codebase, the build system can be the "slow part", got nice personal experience with make vs ninja (ninja won)
02:57:33 <Ariakenom> Ya the codebase I'm talking about does have other reasons for being slow too, I'm sure.
03:19:32 --- mode: glguy set +v reygoch
03:19:55 <reygoch> something like this example in javascript: https://github.com/marioizquierdo/jquery.serializeJSON
03:20:23 <reygoch> does anyone know if there is a parser for form url encoded data which functions like the one in the php. Meaning that it can parse structured data rather than just a flat key value map.
03:30:28 <madnight> i don't know much about php, could you provide a link to the php function?
03:30:34 --- mode: glguy set -v reygoch
03:31:12 <ZeuPiark> hello
03:31:39 <reygoch> madnight: It's a lot of C mumbo jumbo. This JS lib (which tries to do the same on the frontend) is much more readable https://github.com/marioizquierdo/jquery.serializeJSON
03:32:53 <reygoch> madnight: I was thinking of translating that code to Haskell but I don't really want to repeat the effort if there is already such library.
03:33:19 <madnight> reygoch, what this function does is "Serialize an HTML Form to a JavaScript Object"
03:33:59 <madnight> reygoch, so you want: Serialize an HTML Form to a Haskell Object?
03:34:09 <reygoch> madnight: To Aeson object
03:34:48 <reygoch> madnight: That seems like the most reasonable choice, and than I can just try to parse Aeson into an actual haskell data structure.
03:35:52 <madnight> reygoch, yes it many cases this can be done automatically without writing an actual parsing routine
03:36:12 <lavalike> I would think it would be the case that whatever framework you're using to handle http will provide something to work with form-encoded data
03:38:07 <madnight> lavalike, execpt for elm, elm doesn't support typeclasses so parsing JSON is "hard"
03:39:03 <lavalike> madnight: I'm specifically thinking of Haskell here, isn't elm a transpiled-to-js client-side sort of deal?
03:39:11 <reygoch> lavalike: there are such utilities, but they don't really parse structured data
03:39:21 <lavalike> reygoch: what are you using?
03:39:39 <reygoch> lavalike: servant and http-types package if I'm correct
03:40:32 <reygoch> lavalike: here is my ticket in http-types https://github.com/aristidb/http-types/issues/89
03:40:46 <reygoch> lavalike: just so that you get a better idea of what I'm looking for
03:43:20 <lavalike> reygoch: in this example an endpoint /login is set up to read the form-encoded data from the request (and respond with json but that's not important) https://github.com/haskell-servant/servant/issues/236#issuecomment-142882108
03:44:28 <reygoch> lavalike: I think we have a misunderstanding. It is not a problem to parse form data, it is a problem to parse nested form data.
03:45:25 <reygoch> lavalike: That is currently not supported by default so I'm hoping to find some library which solved that problem but so far nothing.
03:46:55 <madnight> reygoch: here is an example where i parse nested json data https://github.com/madnight/grendel/blob/master/src/Data/Grendy/GraphQL.hs#L34
03:47:17 <madnight> regoch: that's quite straightforward
03:47:36 <reygoch> madnight: not really the problem I'm trying to solve.
03:47:43 <lavalike> reygoch: aren't you free to write your `fromFormUrlEncoded` method any way you like? In the example they take 2 fields and turn the into a `User email pwd` but nothing stops one from doing more work I'd say
03:47:56 <lavalike> *turn them into
03:48:18 <reygoch> madnight: I am, but this is a generic case and I don't want to write the whole parser if someone else potentially have done that already.
03:48:33 <madnight> reygoch: hmm okay then i don't understand your problem, maybe lavalike does
03:49:02 <lavalike> reygoch: that's fair, there may be other packages that already provide you a form-url-encoded parser
03:49:30 <reygoch> madnight: well, I guess I'll have to write the whole thing my self since I haven't found anything that can parse structured data from form-url-encoded.
03:50:10 <lavalike> @package http-api-data
03:50:10 <lambdabot> http://hackage.haskell.org/package/http-api-data
03:50:45 <lavalike> @package urlencoded
03:50:45 <lambdabot> http://hackage.haskell.org/package/urlencoded
03:51:51 <lavalike> reygoch: I found those two for starters
03:52:17 <reygoch> lavalike: yes, that is again just a flat key value pair structure. It's not nested and that is the whole problem. I get key value pair like this : ("user[username]", "MyUsername")
03:52:37 <madnight> reygoch: i think you should break your problem down
03:52:51 <reygoch> madnight: I'm going to do that now :D
03:53:02 <reygoch> madnight: bye
03:53:07 <madnight> reygoch: i still don't know if your problem is from, urlencoded, nested or something else
03:53:15 <madnight> that are different problems
03:53:32 <reygoch> My problem is parsing urlencoded data into a nested structure.
03:54:11 <lavalike> reygoch: I am not sure that the first package for example can't handle a custom type that contains a list, say, I would hope it does!
03:54:24 <reygoch> take a look at this, here I clearly describe the problem https://github.com/aristidb/http-types/issues/89
03:54:52 <madnight> there are many tutorials for parsing nested json to haskell, why don't they work for your case?
03:55:06 <lavalike> madnight: because he's not parsing json
03:55:13 <reygoch> XD
03:55:17 <madnight> then problem is, i also don't understand that issue ^^
03:55:24 <reygoch> dude here : https://github.com/aristidb/http-types/issues/89
03:56:37 <lavalike> madnight: when you create a simple form in html, <form action="/doit" method="POST"><input name="foo"></input></form> and let the browser do its default action with it, you get a special encoding of the form's values called form-url-encoded
03:56:41 --- mode: glguy set +v yeffrey
03:57:33 <yeffrey> I'm learning (trying) haskell and I'd like to do it via TDD but I didn't find lot a deep example of hspec
03:57:42 * hackage ho-rewriting 0.2.1, syntactic 3.7.1 (EmilAxelsson): https://qbin.io/hate-wider-r6dl
03:57:52 <madnight> i would convert that thing to json which is obviously possible
03:58:01 <madnight> and then parse it with aeson
03:58:07 <madnight> problem solved?
03:58:36 <lavalike> that might also be a solution, would need to search for code that turns form-encoded values into json
03:59:00 <madnight> he already posted such a function
03:59:21 <lavalike> another solution is disabling the browser's default behavior with javascript and use .. yeah, something like that .. on the client side, but one might not want to do that for some reason
03:59:48 <madnight> [12:31] (reygoch) madnight: This JS lib (which tries to do the same on the frontend) is much more readable https://github.com/marioizquierdo/jquery.serializeJSON
04:00:28 <lavalike> madnight: I'm just saying one might have reasons to not want / be able to change the client
04:01:14 <yeffrey> hello, I would like to know if anybody knows a nice github repo about a small rest api with a small domain model with hspec tests ?
04:01:26 <reygoch> Yes, I actually have a requirement for my app to be JSless, otherwise I'd be sending JSON to the server instead.
04:01:40 <lavalike> reygoch: how complicated is the "nested data"?
04:01:44 <madnight> lavalike, one could even use ghcjs or setup an aws lambda function for that
04:01:55 <lavalike> madnight: eeek.
04:02:25 <reygoch> madnight: are you a mad knight or a mad night, don't even mention ghcjs to me :D
04:02:31 <reactormonk> My favourite - thread blocked indefinitely in an STM transaction - any standard way to debug that?
04:02:39 <madnight> lavalike, i mean JSON is the standard for passing data around APIs right?
04:02:57 <lavalike> madnight: as we discovered, the browser thinks otherwise in this particular instance :)
04:02:59 <reygoch> yeffrey: have you tried this https://hspec.github.io/ there are a good examples there, and a tutorial
04:04:46 <yeffrey> reygoch: yep, is it an haskell practice to have like "1-liner" test ?
04:05:15 <madnight> i don't know my first instinct tells me: format xy |> json |> aeson is easier than format xy |> custom haskell parser
04:06:29 <reygoch> madnight: to do format xs |> json you have to be able to parse xs into json, no?
04:07:02 <madnight> reygoch, yes there are many ways todo so
04:07:07 <reygoch> madnight: my first instinct was "did someone already do this for me so I don't have to" :D
04:07:19 <lavalike> reygoch: how complicated is the "nested" data?
04:07:46 <reygoch> lavalike: idk, about a days work
04:08:23 <madnight> reygoch, then add "google" to the front of my chains
04:08:54 <lavalike> reygoch: I mean are there 100 layers or 2
04:09:07 <reygoch> lavalike: indefinite
04:09:17 <lavalike> now I'm scared
04:09:57 <reygoch> lavalike: we are writing Haskell here, we do not write just a 1 - 2 depth case, we generalize ;D
04:10:54 <madnight> lavalike: he will end up writing a quiet complex parser if he is about to avoid json/aeson
04:10:54 <lavalike> reygoch: I'm not sure if http-api-data I linked above supports instance ToForm Foo with something like data Foo = Foo { x :: String, moreFoos :: [Foo] } but if it does you're golden
04:11:28 <lavalike> might warrant experimentation
04:11:43 <reygoch> lavalike: I've checked that already, and it doesn't. :(
04:11:54 <lavalike> reygoch: how did you figure that? I can't from just the documentation
04:12:02 <reygoch> lavalike: Foo has to be a plain value type
04:12:58 <lavalike> reygoch: my question still stands
04:14:14 <madnight> he already passed the first part of the chains, namely "google", now he has to decide, json or custom parser : )
04:14:52 <reygoch> lavalike: newtype Form { unForm :: HashMap Text [Text] }
04:15:02 <lavalike> reygoch: in the generics part of the documentation it does show an example with a record containing a list, and mentions [a], I am slightly hopeful it'll recurse down such 'a's that have FromPost a
04:17:21 <reygoch> The way it stores the data simply doesn't allow for such Generic parsing.
04:17:24 <madnight> wasn't reygochs issue on GitHub already answered by the project owner? who knows the project better than him?
04:18:14 <lavalike> reygoch: why not, the keys' Text could keep its shape and still refer to the nested objects
04:19:00 <lavalike> (which I'm guessing it does to be able to decode lists)
04:19:45 <lavalike> (well that's too wild of a guess, another would be the value type of the hashmap is how lists are supported :/)
04:20:01 <reygoch> lavalike: it can only decode something like "field=value1&field=value2" into field = [value1, value2]
04:20:27 <lavalike> that's a definite possibility
04:21:07 <lavalike> how are you even constructing deeply nested stuff in a static html form
04:31:40 <ab9rf> html supports arbitrary nesting
04:49:12 * hackage ghc-exactprint 0.5.7.1 - ExactPrint for GHC  http://hackage.haskell.org/package/ghc-exactprint-0.5.7.1 (AlanZimmerman)
05:31:12 * hackage deferred-folds 0.6.12 - Abstractions over deferred folds  http://hackage.haskell.org/package/deferred-folds-0.6.12 (NikitaVolkov)
06:04:53 <kuribas> do type families follow pattern matching rules?
06:05:15 <kuribas> like, when the first rule matches, it doesn't continue?
06:12:25 <hpc> the type family itself is more like the type-level version of a class method
06:12:43 <hpc> picking which type family to use resovles the same way picking a definition of fmap would, by the instance it resolves to
06:12:50 <hpc> and instance resolution isn't changed by turning on type families
06:13:10 <hpc> maybe that helps? not sure what you mean by pattern matching rules
06:13:57 <kuribas> well, I mean that type family definitions can overlap
06:14:06 <kuribas> while instances shouldn't.
06:14:28 <hpc> correct
06:14:32 <ab9rf> https://typesandkinds.wordpress.com/2012/12/22/ordered-overlapping-type-family-instances/
06:14:33 <kuribas> I am trying to do a type level Symbol lookup
06:14:39 <hpc> instance Foo A where type F A = Int
06:14:45 <hpc> instance Foo B where type F B = Int
06:15:19 <hpc> oooooh
06:15:25 <hpc> this is about type families defined outside a type class
06:15:27 <hpc> ?
06:15:45 <kuribas> yeah
06:16:19 <hpc> that i am less familiar with, can't help you there :/
06:16:34 <kuribas> basically I want to test if s in ((s :: Symbol, b) ': ts) matches a specific Symbol.
06:16:42 <kuribas> that's a type level list.
06:23:07 <Profpatsch> Remind me: was there a System.Process module that’s not as brain-damaged as the one in process? 
06:23:23 <Profpatsch> - Text instead of String
06:23:42 <Profpatsch> - No implicit de/encoding of Handles
06:25:37 <hpc> there might be a ByteString version of it, that would handle the second issue?
06:26:36 <Profpatsch> There’s one that jumps through the usual hoops of trying to be as “general” as possible by defining a type class 
06:26:38 <Profpatsch> https://hackage.haskell.org/package/process-extras-0.7.4/docs/System-Process-Common.html
06:28:07 <Profpatsch> LOL, Snoyman seems to be the maintainer of process, and he added an advertising clause for his type-process library.
06:28:16 <Profpatsch> m(
06:29:10 <Profpatsch> narcissism is a hard fate
06:58:41 <madnight> https://lpaste.net/4817227970504556544 : )
07:01:14 <p0lyph3m> fast forward to 2017 , hehehe
07:13:54 <the_2nd> I have a [(a, [b])] list with duplicate 'a's and would like to merge the 'b's of duplicate 'a's. I looked at Map, but there seems no proper function to collect these in one go? Update etc. require the key to be present already, which seems weird
07:14:11 <dmwit> M.fromListWith (++)
07:14:50 <the_2nd> awesome :D
07:16:57 <dmwit> the_2nd: Also see alter, which is like update but doesn't require the key to exist.
07:17:13 <dmwit> (But you probably wanted insertWith anyway.)
07:22:02 <the_2nd> yep, thanks
07:25:36 <ab9rf> meow?
07:25:43 --- mode: glguy set +v vaibhavsagar
07:25:44 <ab9rf> eugh
07:26:28 <vaibhavsagar> is there somewhere I can view the haddocks for GHC 8.6.1?
07:26:52 <Axman6> the_2nd: did you get an answer to your question? I disconnected - the answer is insertWith (++)
07:26:52 <vaibhavsagar> http://hackage.haskell.org/package/ghc only has 8.4.3
07:27:02 <Axman6> o/ vaibhavsagar
07:27:08 <vaibhavsagar> hi Axman6!
07:27:26 <the_2nd> Axman6, yep, all is fine. Thank you, too
07:27:40 <Axman6> excellent
07:27:49 <Franciman> Hi
07:27:55 <Franciman> Why does ghc keep using libtinfo5?
07:28:29 <Franciman> also I'm installing cabal, I get the following error: https://lpaste.net/199260291823828992
07:28:34 <Franciman> what's happening?
07:28:41 <Franciman> I am running ./bootstrap.sh
07:38:36 <kuribas> UndecidableInstances is safe right?
07:38:47 <kuribas> and OverlappingInstances is unsafe?
07:39:25 <ab9rf> safe, safe, what is safe?
07:40:00 <kuribas> benign?
07:40:07 <kuribas> can't do much harm?
07:40:59 <Axman6> @where wiwik
07:41:00 <lambdabot> I know nothing about wiwik.
07:41:28 <Axman6> @where wiwikwlh
07:41:28 <lambdabot> I know nothing about wiwikwlh.
07:42:01 <Axman6> kuribas: http://dev.stephendiehl.com/hask/#language-extensions might be useful
07:42:11 <Axman6> @where+ wiwik http://dev.stephendiehl.com/hask/#language-extensions
07:42:11 <lambdabot> Done.
07:42:23 <Axman6> @where+ wiwikwlh http://dev.stephendiehl.com/hask/#language-extensions
07:42:23 <lambdabot> It is forever etched in my memory.
07:42:40 <Axman6> dmanit, didn't mean to keep the anchor >_<
07:42:46 <dmwit> ?tell Franciman I believe GHC uses libtinfo to get pretty coloring in its error messages. As for the cabal thing... well, have you tried running ghc-pkg check as suggested in the error?
07:42:46 <lambdabot> Consider it noted.
07:42:51 <vaibhavsagar> :(
07:43:08 --- mode: glguy set +v kritzefitz
07:43:18 <dmwit> vaibhavsagar: If your previous message explains why you are frowning, you'll have to repeat it.
07:43:53 <Axman6> think it was a sympathy frown for my stupidity :)
07:43:55 <vaibhavsagar> just frowning at the anchor that Axman6 inadvertently stored for eternity
07:43:56 <dmwit> vaibhavsagar: As a spam counter, non-registered nicks' first messages are hidden and checked against a blacklist of known spam messages.
07:44:08 <dmwit> oh
07:44:10 <vaibhavsagar> yep, I got the automated message from glguy, thank you :)
07:44:12 <kritzefitz> kuribas: Apparently both UndecidableInstances and OverlappingInstances can be used when -XSafe is in effect.
07:44:27 <vaibhavsagar> also I am registered IIRC
07:44:50 <vaibhavsagar> apparently I have a voice now, although I did not before
07:44:55 <Axman6> kritzefitz: not sure the definitions of safe for XSafe and "safe to use" are completely aligned
07:45:24 <dmwit> vaibhavsagar: Perhaps you have not correctly identified to nickserv? You aren't currently logged in.
07:45:37 <vaibhavsagar> hmm, strange
07:45:57 <kritzefitz> Axman6: It was the closest thing I could quickly measure, but you're probably right.
07:46:01 <Franciman> dmwit, ah thank you
07:46:21 <Franciman> I didn't try ghc-pkg check
07:46:55 <dmwit> Axman6: (You can just ?where+ again to fix it...)
07:47:11 <glguy> vaibhavsagar: You're not identified to NickServ currently
07:47:27 <Axman6> @where+ wiwik http://dev.stephendiehl.com/hask/
07:47:28 <lambdabot> It is stored.
07:47:29 <vaibhavsagar> I see, just looking up how to do that now
07:47:35 <Axman6> @where+ wiwikwlh http://dev.stephendiehl.com/hask/
07:47:35 <lambdabot> It is stored.
07:47:36 <glguy> vaibhavsagar: You can configure your client to automatically identify on connect
07:47:46 <vaibhavsagar> I thought I had :)
07:47:55 <Axman6> irc is hard
07:48:28 <vaibhavsagar> Axman6: this also explains why you haven't seen my response to your PM
07:49:35 <Axman6> yes!
07:50:29 <Axman6> Feel free to repeat yourself once you're identified :)
07:51:28 <bwe> I have the type    Handler (Maybe [PastStop])    I want   [PastStop]
07:51:47 --- mode: glguy set -v vaibhavsagar
07:51:59 <vaibhavsagar> all good now?
07:52:25 <Axman6> bwe: I assume you have something with type Handler (Maybe [PastStop])? and Handler comes from Servant?
07:52:28 <glguy> yup
07:55:32 <bwe> Axman6: https://bpaste.net/show/d15db86730ea
07:56:08 <bwe> Axman6: getTrainDelay works fine as a function of which server is composed from.
07:56:56 <bwe> Axman6: Now, suppose the user provides an additional QueryParam of stationId, it should subselect the delay information of that station only (that is of PastStop type).
07:57:12 <Axman6> if (isNothing foo) is a big codesmell to me, just as an aside
07:57:41 <bwe> Axman6: I agree. I just dumped my sandbox into the pastebin to ease our communications flow, okay?
07:58:17 <Axman6> yep
07:59:02 <bwe> stationId PastStop == qStationId should be the filter condition.
07:59:53 <Axman6> do you mean the ...fmap (stationId $ pastStation) x == qStationId] filter condition?
08:00:45 <bwe> yes.
08:02:20 <bwe> trainDelay is wrapped in a Maybe, that in turn is wrapped in a Handler
08:02:23 <Axman6> hmm, this code doesn't type check at the moment - I have a feeling you want to change let trainDelay = getTrainDelay trainDelays trainName into trainDelay <- getTrainDelay trainDelays trainName
08:02:42 <Axman6> right, yes that is what you want
08:03:21 <Axman6> just to be clear, the line  `let trainDelay = getTrainDelay trainDelays trainName` becomes `trainDelay <- getTrainDelay trainDelays trainName`
08:03:40 <bwe> How is that assignment called, btw?
08:03:42 <Axman6> then trainDelay will have type Maybe TrainDelay
08:03:54 <Axman6> that's just monadic bind
08:04:12 <Axman6> it's syntax sugar for getTrainDelay trainDelays trainName >>= \trainDelay -> ...
08:12:37 <bwe> Axman6: this typechecks now: https://bpaste.net/show/2de6acfce4ce
08:12:50 <bwe> Axman6: what can I do about the codesmell?
08:13:43 <int-e> :t listToMaybe
08:13:44 <lambdabot> [a] -> Maybe a
08:13:54 <Axman6> > listToMaybe []
08:13:56 <lambdabot>  Nothing
08:13:56 <Axman6> > listToMaybe [1]
08:13:58 <lambdabot>  Just 1
08:14:03 <Axman6> > listToMaybe [1,2]
08:14:05 <lambdabot>  Just 1
08:15:03 <bwe> Handy ;).
08:15:36 <Axman6> and I would at least use a pattern match on trainDelay, that completely avoids the need for fromJust which isn't total
08:15:37 <fsestini> bwe: I would also pattern match on trainDelay
08:15:41 <fsestini> ^
08:16:10 <Axman6> case trainDelay of Nothing -> return Nothing; Just delay -> matching = [x | x <- pastStops delay ...
08:16:14 <int-e> bwe: Why is the trainName argument a Maybe? Is it useful to pass Nothing into that function?
08:16:49 <Axman6> (there's a let missing there too)
08:17:48 <Axman6> in fact, you can end up with: ... Just delay -> return $ listToMaybe [x | x <- pastStops delay, stationId (pastStation x) == qStationId]
08:17:54 <bwe> int-e: It is not useful to pass nothing. However, I vaguely remember the servant tutorial said something about wrapping a query param into a Maybe.
08:18:22 <Axman6> a recent version of Servant allows you specify that a query param is required in its type, which is pretty awesome
08:19:07 <Axman6> but before that QueryParam "foo" Thing always required Maybe Thing in the handler
08:20:20 <vaibhavsagar> is there a paper on the Hugs bytecode interpreter?
08:23:28 <bwe> Axman6: https://bpaste.net/show/47362d2d6873 doesn't typecheck
08:25:16 <bwe> Axman6: Gotcha, missed a $ after the return
08:25:27 <bwe> Axman6: So, I do not need to handle the Nothing case?
08:26:12 * hackage attoparsec-uri 0.0.5 - URI parser / printer using attoparsec  http://hackage.haskell.org/package/attoparsec-uri-0.0.5 (athanclark)
08:30:31 <bwe> Axman6: Thanks for your assistance.
08:30:53 --- mode: glguy set +v chris___
08:31:16 <Axman6> bwe: no you definitely need to handle the Nothing case too
08:32:48 --- mode: glguy set +v lsund
08:33:48 <spoonm> the poor skills and bad code aside, is there any reason for this to be segfaulting? http://ix.io/1jTR
08:33:58 <Axman6> glguy: still getting much spam? 
08:35:09 <Axman6> spoonm: ... no... but please don't make SQL queries by concatenating strings :(
08:35:16 <spoonm> I know it's bad lol
08:35:27 <Gurkenglas> I'm on Windows. haskell-ide-engine's ghc is running for a long time. I can see the ghc in my Task Manager. Can I find out how far along the compilation has come?
08:35:35 <spoonm> but it's just for my own use, managing collections on a kobo ereader without something like calibre
08:35:38 <Gurkenglas> Perhaps with Cheat Engine or something, but how?
08:35:43 <spoonm> I don't get why this is giving me a segfault, though
08:37:19 <Axman6> spoonm: have you tried removing things replacing them until it works? my first though would be to replace the getContents call to just a list of the lines you're expecting to get from stdin
08:37:48 <spoonm> Axman6: I have not, I'll try a few things, thanks
08:38:09 <Axman6> next I would replace getArgs too
08:39:07 <spoonm> I just did both
08:39:08 <Axman6> spoonm: you might also want to have a look at Text.Printf, gives you a printf style interface for string formatting
08:39:13 <spoonm> still segfaulting :/
08:39:38 <Axman6> how are you running it?
08:39:43 <spoonm> Axman6: I was going to, but couldn't remember what module it was, so I just went with this for a first hacked together solution
08:40:30 <spoonm> Axman6: I'm on arch, so it's compiled with ghc -dynamic -shared file.hs, then piping a find call to `./bin "colName"'
08:40:59 <Axman6> are you sure it's called bin?
08:41:17 <spoonm> those were just examples, the true name is a little convoluted
08:41:19 <Axman6> you should delete that file and make sure that's actually the output of compiling
08:41:23 <spoonm> I did
08:41:42 * hackage temporary-resourcet 0.1.0.1 - Portable temporary files and directories with automatic deletion  http://hackage.haskell.org/package/temporary-resourcet-0.1.0.1 (ThomasTuegel)
08:41:56 <Axman6> ok, well just to humour me, make sure that you are actually compiling your changed code, and that that is the code which you are running
08:42:03 <spoonm> lol I am
08:43:02 <Axman6> what happens if you make main just print "Hello, world!"
08:44:12 <spoonm> let's see
08:44:41 <spoonm> segfault, so yeah, guess it wasn't the code
08:44:48 <Axman6> why're you using -dynamic and -shared anyway?
08:44:48 <petercommand> Is unifying terms and types a part of dependent Haskell? I'd like to know whether or not type families will be replaced by normal functions
08:45:03 <spoonm> Axman6: arch did away with the static libraries to make the ghc package smaller
08:45:15 <spoonm> the static libraries are now in a package called ghc-static, afaik
08:45:33 <spoonm> even installing it gave me trouble compiling things, however, with ghc accusing the modules to be missing
08:45:44 <Axman6> from memory the arch guys managed to completely break anything to do with haskell for quite a while, so who knows what's wrong
08:45:53 <spoonm> yep, that's what they did
08:46:56 <spoonm> I'll install ghc-static again and try compiling without any special flags
08:47:10 <spoonm> works fine
08:47:30 <cocreature> ime the simplest solution on arch is to remove everything except for ghc and ghc-static and then just compile without any special flags
08:48:14 <spoonm> cocreature: sad part of that is I have things like xmonad installed through the package manager, not cabal :(
08:48:34 <spoonm> I guess I'll use cabal for it from now on
08:49:27 <cocreature> for something like xmonad it’s not that big of a deal. it’s more annoying for things like pandoc that now pull in all of ghc even for people that have no intention of writing a single line of Haskell code
08:50:02 <spoonm> pandoc and ffmpeg are very good at installing packages no one will ever need
08:52:50 <petercommand> I'd like type families to be replaced by normal functions
08:53:08 <petercommand> so it becomes easier to do type level programming in Haskell
08:53:17 <cocreature> petercommand: the best way to look this up is probably richard’s thesis
08:53:58 <petercommand> https://github.com/goldfirere/thesis this one?
08:54:25 <petercommand> cocreature: thanks
08:54:38 <cocreature> yep
08:56:20 <bwe> I learned from this channel that `fromJust` is a sign that I am doing it wrong. What's the right approach to avoid using fromJust?
08:56:29 <c_wraith> bwe: pattern match
08:56:51 <c_wraith> bwe: then you have entirely different branches for the value being present or absent
08:57:07 <c_wraith> bwe: and in the branch where the value is present, it's already in scope without calling anything
08:58:26 <madnight> bwe: or use http://zvon.org/other/haskell/Outputmaybe/fromMaybe_f.html
08:59:05 <madnight> bwe: so you have to provide a default value in case of Nothing
09:04:28 <bwe> c_wraith, madnight: thanks, I need to focus more on pattern matching.
09:10:01 <blankhart> you may also want to read more about "total" versus "partial" functions, bwe
09:22:53 <kuribas> type level computing is really complicated...
09:24:13 <Axman6> a lot of type level programming is surprisingly simple, it's very similar in many cases to the first functions you learnt when learning haskell
09:24:31 <lsund> exit
09:25:11 <kuribas> mixing type-level with value level computation is difficult.
09:25:21 <kuribas> type level computation in itself isnt...
09:27:53 <romanix> Anyone noticed ResourceCleanupExceptions popping up in their web apps? I've upgraded to stack lts-11.20 and it started happening. Apparently it's something to do with resourcet.
09:29:23 <cocreature> romanix: looks like that is new in resourcet 1.2 and it happens if your cleanup function throws an exception
09:32:42 <romanix> cocreature, that's right. It looks like the exception is thrown in one of the libraries (wai?) rather than my code. Does this look familiar? https://lpaste.net/3356681095474053120
09:50:12 <mozzarella> what's the best programming language?
09:51:28 <cocreature> romanix: haven’t seen it personally (but I’ve also not done a whole lot of wai stuff recently). it looks like it might be coming from https://hackage.haskell.org/package/wai-extra-3.0.24.0/docs/Network-Wai-Parse.html#v:tempFileBackEnd so maybe take a closer look at that and look through the issue trackers/open a new issue
09:52:44 <romanix> Thanks cocreature. I'm looking into this now.
09:53:31 <c_wraith> mozzarella: whichever one best suits all of your needs.
09:55:00 <teto> could anyone share a shell.nix using developPackage that actually overrides one haskell derivation ? I can't make it work :\
09:56:25 <ab9rf> mozzarella: DWIM is the best programming language. unfortunately, developing in it requires a precognition system.
09:56:25 <cocreature> teto: can you show us what you tried?
10:00:39 <mozzarella> haskell has always seemed alien to me
10:01:42 <ab9rf> mozzarella: how so?
10:01:46 <cocreature> mozzarella: have you ever tried learning Haskell? most things that are unfamiliar seem alien
10:02:26 <c_wraith> mozzarella: haskell is absolutely different.  But that's not a bad thing.  Learning more things is fun.
10:04:38 <Gurkenglas> Anyone got a lint for doing "at x . non' _Empty %= (y:)" in exactly one place and "at x . non' _Empty <<.= []" in exactly another?
10:06:32 <ab9rf> Gurkenglas: should call it the hobgoblin checker
10:08:12 <Gurkenglas> ab9rf, ???
10:08:23 <Gurkenglas> explain your joke :D
10:08:29 <merijn> Any persistent experts? Any hints on how I could do a SQL style "LIKE" query?
10:11:13 <ab9rf> Gurkenglas: emerson
10:12:12 <Gurkenglas> ab9rf, I don't follow.
10:12:13 <teto> cocreature: my source-overrides in https://github.com/NixOS/nixpkgs/issues/44718#issuecomment-412286957 are ignored (using nixos-unstable)
10:12:35 <ab9rf> Gurkenglas: "A foolish consistency is the hobgoblin of little minds"
10:13:04 <ab9rf> Gurkenglas: there is therefore, at least in those of us who were forced to read Emerson in high school, an association between seeking consistency and hobgoblins
10:13:13 <dmj`> merijn: there might be a way to define your own Filter and use a “BackendSpecificFilter"
10:13:22 <ab9rf> Gurkenglas: Emerson wasn't an engineer :)
10:13:25 <dmj`> merijn: http://hackage.haskell.org/package/persistent-2.8.2/docs/src/Database.Persist.Types.Base.html#PersistFilter
10:13:26 <Gurkenglas> (For the record, "at x <>= y" happens to work in this case)
10:13:56 <cocreature> teto: try applying the overrides to haskellPackages and then call developPackage on the modified haskellPackages
10:14:12 <Gurkenglas> (oh wait "at x <>= Just y" I think - dangit dev environment leaves me hanging again)
10:14:27 <merijn> dmj`: Cheers, I'll have a look
10:14:45 <teto> cocreature: overriding cabal-helper in an overlay works
10:15:02 <cocreature> teto: something like https://github.com/cocreature/nix-miso-template/blob/master/server-only/default.nix#L17
10:16:21 <c_wraith> Gurkenglas: "consistency is the hobgoblin of small minds"
10:16:36 <ab9rf> c_wraith: not the exact quote
10:17:25 <Gurkenglas> ab9rf, what are you calling the hobgoblin checker there? What seeks consistency?
10:17:55 <ab9rf> Gurkenglas: it's simply a fairly silly literary reference. no moral judgment is implied or intended.
10:18:57 <Gurkenglas> Did I sound offended to you? I'm still sounding offended, aren't I. Ignore that, then :P I still don't know how you were actually targeting that reference
10:19:23 <JuanDaugherty> it's a very famous quote due to j.s. mill i think but there's a missing word
10:19:27 <JuanDaugherty> petty
10:19:49 <JuanDaugherty> "petty consistency is the hobgoblin of small minds"
10:20:19 <Gurkenglas> It was immediately obvious that "hobgoblin" is a reference to something, what I'm missing is how it applies here
10:20:29 <MarcelineVQ> idk I'm pretty sure it's "marshmallow consistency is the hobgoblin of small minds"
10:20:35 <JuanDaugherty> ah just remembered, it's foolish not petty
10:21:20 <JuanDaugherty> nope was Emerson
10:21:28 <ab9rf> MarcelineVQ: now i want a brand of marshmallows called "Hobgoblins"
10:21:49 <JuanDaugherty> ttps://www.goodreads.com/quotes/353571-a-foolish-consistency-is-the-hobgoblin-of-little-minds-adored
10:21:55 <MarcelineVQ> yeah here it is  "marshmallow consistency is the hobgoblin of small minds"  -ralph waldo picklechips
10:21:58 <ab9rf> i quoted it above, about 40 lines ago
10:22:12 <Gurkenglas> ab9rf, I seek your association between seeking consistency and my original question
10:22:45 <ab9rf> Gurkenglas: as previously stated, the association is due to ralph waldo emerson, as explained above.
10:23:07 <Gurkenglas> ab9rf, no that's the association is between seeking consistency and hobgoblins
10:23:26 <ab9rf> Gurkenglas: you asked for a lint checker for whether a construct was being used consistently
10:23:37 <JuanDaugherty> ab9rf, acknowledged, had to scroll back to see it
10:24:01 <Gurkenglas> ab9rf, I asked for a lint for a pair of lines of code
10:24:28 <JuanDaugherty> there's another I think by Keynes about changing your mind when the facts change
10:24:35 <Gurkenglas> Ah, I thought a lint is what a linter produces.
10:24:40 <ab9rf> emerson was a pretentious twit.
10:24:41 * hackage strelka-core 0.3.0.1 - Core components of "strelka"  http://hackage.haskell.org/package/strelka-core-0.3.0.1 (NikitaVolkov)
10:25:01 <Gurkenglas> And my question never said anything about consistency :D
10:25:21 <ab9rf> Gurkenglas: ah, i misunderstood your request/inquiry, then
10:25:23 <Gurkenglas> So, to rephrase my original question:
10:26:04 <Gurkenglas> I do "at x . non' _Empty %= (y:)" in exactly one place and "at x . non' _Empty <<.= []" in exactly another. Is there a better way, perhaps one that lets me put "$ y" somewhere?
10:26:20 --- mode: glguy set +v tomsen
10:26:28 --- mode: glguy set +v bas_
10:26:39 <dmwit> Oh, heck.
10:26:42 <dmwit> :t (<<.=)
10:26:43 <lambdabot> MonadState s m => LensLike ((,) a) s s a b -> b -> m a
10:27:07 <ab9rf> what does that do?
10:27:25 <bas_> is there a reason why one can't seem to make a Data MyType = Something | SomeOtherThing | True 
10:27:37 <bas_> referencing the True from preludes Bool
10:27:42 <Gurkenglas> The first prepends y to what's waiting for x, the second empties and gets the list of what's waiting for x.
10:27:46 <ab9rf> bas_: True is already defined
10:28:31 <dmwit> bas_: It's just a rule. Different types must have different constructors. You can import the Prelude qualified to create a new constructor with the same name, but you can't have a single constructor be part of two different types.
10:28:42 <MarcelineVQ> data should be small as well
10:28:42 <bas_> ab9rf I get that, I sort of wanted it as an alias, or am I thinking too much in terms of subtyping
10:28:47 <ab9rf> bas_: value constructors cannot be shared between types (usually)
10:29:13 <dmwit> Yes, you are thinking too much in terms of subtyping.
10:29:26 <dmwit> Anyway this wouldn't be subtyping, since you didn't include False.
10:29:47 <dmwit> (alternately: this wouldn't be subtyping, since Bool didn't include Something or SomeOtherThing).
10:29:58 <petercommand> :t non'
10:29:59 <lambdabot> (Functor f, Profunctor p) => APrism' a () -> p a (f a) -> p (Maybe a) (f (Maybe a))
10:30:34 <bas_> ah, yes, but I excluded that rather more for brevity than anything else
10:30:58 <ab9rf> bas_: it wouldn't have been legal if you had included | False
10:31:08 <ab9rf> bas_: but it would have at least been a proper sub/supertype
10:31:52 <JuanDaugherty> the full emerson quote, I wouldn't call that being a pretentious twat, but I would call it a grevious error (the part about great men misunderstood because they can contradict themselves at will)
10:32:45 <Gurkenglas> the emerson conversation should never have happened :x
10:33:02 <JuanDaugherty> is regular current lambdabot what is fielding type requests (:t) here?
10:33:06 <MarcelineVQ> "the emerson converstion was a mistake" -mark twain
10:37:21 <ab9rf> now i'm faced with trying to understand why emerson is associated in my mind with penguins
10:37:39 <maerwald> because you are a true surrealist, just embrace it
10:38:49 <geekosaur> bas_, Haskell is designed around construtors being type markers, in particular pattern matching relies on this. Let's say you  do that and thne pattern match against True in a function binding. Which type is it supposed to use, if you don't specify?
10:39:43 <geekosaur> also, every so often type-directed name resolution comes up (usually with respect to records). It turns out to be a trainwreck, at least if you expect type inference to work.
10:41:36 <Gurkenglas> I have "foo f (FreeT m) = do val <- m; case val of Pure x -> return x; Free y -> f (foo f) y". iterT is (equivalent to) "iterT f (FreeT m) = do val <- m; case val of Pure x -> return x; Free y -> f $ fmap (iterT f) y". Can I express the first in terms of the second?
10:44:27 <Gurkenglas> (Thought I would switch the FreeT and ExceptT layers of https://github.com/haskell/haskell-ide-engine/blob/509c97156ced3bda214cf0c4b80bfb4aca51aaf4/src/Haskell/Ide/Engine/Dispatcher.hs#L90 so I can use iterT)
10:45:06 <dmwit> JuanDaugherty: What is "regular current lambdabot"?
10:45:56 <MarcelineVQ> as in not yahb or other
10:46:29 <int-e> @version
10:46:29 <lambdabot> lambdabot 5.1.0.1
10:46:29 <lambdabot> git clone https://github.com/lambdabot/lambdabot
10:46:32 <int-e> :t 123
10:46:34 <lambdabot> Num p => p
10:47:09 <int-e> still ghc-8.2.2 though.
10:47:22 <Gurkenglas> Oh wow, my custom functor's fmap happens to already swallow the composition I was despairing about. I must be a genius.
10:47:52 <JuanDaugherty> dmwit, the one I'm building now
10:48:11 <JuanDaugherty> (via stack install lambdabot)
10:49:29 <JuanDaugherty> (in ghc-8.4.3)
10:53:04 --- mode: glguy set +v nineonine
10:53:10 <nineonine> i have a question about exceptions
10:53:28 <nineonine> i spawn a worker thread to read from TBQueue
10:53:40 <nineonine> one of the messages kills this thread
10:53:59 <nineonine> however i also try to catch exceptions on that thread
10:54:17 <nineonine> can I somehow handle only ThreadKilled exception in that handler ?
10:54:50 <nineonine> actually think i want to ignore ThreadKilled and report other exceptions
10:56:25 <teto> cocreature: thanks for the example. I might fall back on stack as almost my attempts at installing haskell programs via nix failed (because of dependencies/compilation errors :/ )
10:57:12 <rotaerk> resolving dependencies is the whole point of nix
10:57:39 <MarcelineVQ> teto: seen this? https://github.com/Gabriel439/haskell-nix
10:57:39 <EvanR> ignoring ThreadKilled sounds hazardous
10:57:40 <JuanDaugherty> (which is 5.1.0.1)
10:58:06 <teto> MarcelineVQ: yes thanks
10:58:47 <nineonine> well, not ignoring
10:58:54 <nineonine> but lets say i want to do something else with it
10:59:04 <nineonine> like have a different log message
10:59:21 <nineonine> or just gracefully handle it in some way
10:59:38 <teto> rotaerk: nixpkgs has only a snapshot with the latest versions and because of the "top" constraints, it creates many incompatitibilities with dependencies if I understand correclty.
11:00:21 <nineonine> i tried catchJust 
11:00:47 <rotaerk> yeah, I guess you often can't use haskell packages in nixpkgs right out of the box
11:00:52 <nineonine> and for its first argunemt i something like this
11:01:23 <cocreature> you don’t even need catchJust, ThreadKilled is a separate type so you can catch only that
11:02:14 <madnight> teto: nix also has snapshots of older versions of hackage packages
11:02:16 <nineonine> ok so how do I do that ?
11:02:33 <nineonine> I can just use ‘catch’ and have a different handling case for ThreadKilled ?
11:02:39 <cocreature> :t catch
11:02:40 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
11:02:42 * hackage stratosphere 0.24.4 - EDSL for AWS CloudFormation  http://hackage.haskell.org/package/stratosphere-0.24.4 (jdreaver)
11:02:52 <cocreature> if you force "e" to be ThreadKilled you will only catch ThreadKilled
11:03:08 <nineonine> ok got it
11:03:26 <cocreature> you can do so by adding a type annotation somewhere, e.g. catch x (\(e :: ThreadKilled) -> …) using ScopedTypeVariables
11:03:59 <nineonine> how can I extend this handler to also accept other Exceptions ?
11:04:01 <nineonine> is it possible ?
11:04:16 <nineonine> like a base case for all other exceptions
11:04:37 <cocreature> just use "catch" twice
11:04:40 <cocreature> or use "catches"
11:04:49 <EvanR> catches makes more sense
11:05:11 <nineonine> yes! i think this is what i need!
11:05:13 <EvanR> but when catching all exceptions, i tend to think something like async makes more sense
11:05:14 <nineonine> awesome
11:05:41 <EvanR> the thread dies, but the monitor thread deals with it
11:05:55 <EvanR> so as not to complicate the worker thread
11:06:25 <nineonine> ok, will gitve it a try now. thanks everyone!
11:08:58 <teto> madnight: in older commits ? or several at the same time ?
11:09:59 <madnight> teto: snapshots of compatible sets
11:11:31 <madnight> teto: https://nixos.org/channels/ you can add them to your $HOME/.nix-channels if you like
11:12:25 <nineonine> ok so THreadKilled is actually a data contructor from AsyncException type
11:13:33 <EvanR> so youll have to catch AsyncExceptions and do case analysis
11:14:01 <nineonine> yep, trying that right now
11:14:15 <EvanR> if this is really what you want to do, i would extract the whole thing into a combinator
11:14:31 <EvanR> whatever action you pass gets wrapped in a catch
11:14:48 <nineonine> can you please describe it a bit more ?
11:14:53 <EvanR> (you still have the possibility of getting killed before that catch runs
11:15:06 <nineonine> oh that is exactly what i want
11:15:34 <madnight> EvanR: -XOrPatterns might also be useful for this use \case in the future
11:15:36 <EvanR> async on the other hand is solid, the monitor thread will definitely be informed of child thread getting killed regarless
11:15:52 <EvanR> regardless
11:16:00 <EvanR> OrPatters ...
11:16:08 <EvanR> never heard of it
11:16:33 <madnight> EvanR: allows something like f (C1 x | C2 x) = show x
11:16:37 <EvanR> o_O
11:16:40 <EvanR> cool
11:17:30 <MarcelineVQ> EvanR: in the future was more operative
11:18:01 <EvanR> oh so this isn't currently existing technology
11:18:31 <MarcelineVQ> it's currently discussed technology 
11:18:48 <madnight> EvanR: nope unfortunately not yet https://github.com/ghc-proposals/ghc-proposals/pull/43
11:18:50 <MarcelineVQ> As in actively
11:20:02 <madnight> EvanR: but community support for this one is big, it seems more likely than not that this one will make it (if you ask me)
11:20:02 <JuanDaugherty> (*5.1.0.2)
11:20:28 <EvanR> cool
11:28:40 <Zemyla> Okay, can someone explain this error? https://lpaste.net/2803601354856071168
11:30:40 --- mode: glguy set +v sander
11:32:29 <Zemyla> Should I just turn on AllowAmbiguousTypes?
11:35:19 <mniip> Zemyla, unlikely
11:36:54 <mniip> Zemyla, when you invoke your function with a particular 'S s a' argment
11:37:06 <mniip> due to STupleRep being a type function, there's no way to know what 'a' is
11:37:23 <mniip> this is the error you would get if you enabled AAT
11:37:33 <mniip> without AAT the compiler is warning you at the definition site
11:37:50 <Zemyla> mniip: But STupleRep is injective.
11:38:12 <mniip> hm
11:38:22 <Zemyla>  That's the point of making it injective.
11:43:29 <mniip> Zemyla, I think it might be related to (a :: TYPE r)
11:43:50 <mniip> Zemyla, have you tried not passing r as an explicit param?
11:44:10 <mniip> you can match on it still with:  STupleRep s (a :: TYPE LiftedRep) = ...
11:44:23 <Zemyla> What do you mean?
11:47:40 <Zemyla> mniip: I have to have r as an explicit parameter because the result is a value of TYPE ('TupleRep (KTupleRep r)).
11:48:12 <mniip> type family STupleRep s (a :: TYPE r) = (sa :: TYPE ('TupleRep (KTupleRep r))) | sa -> a s where
11:48:16 <mniip> does that not work?
11:51:15 <Zemyla> Expected kind 'TYPE r', but (a :: TYPE 'LiftedRep) has kind '*'
11:51:50 <mniip> hmm
11:52:25 <merijn> hmm, Haskeline's completion setup doesn't really have a way to update it over time, does it?
11:53:36 <mniip> Zemyla, I don't get any error with the following simple test
11:53:51 <mniip> % type family F (a :: TYPE r) = (fa :: TYPE (TupleRep '[r]))
11:53:51 <yahb> mniip: 
11:53:53 <mniip> % type instance F (a :: TYPE LiftedRep) = (# a #)
11:53:54 <yahb> mniip: 
11:54:11 <nan`> what does it mean to construct the fixed point of a unary type constructor? I know what a fixed point is in math but how is this a fixed point "data Mu f = In (f (Mu f))"
11:54:13 <Zemyla> It's not simply TYPE (TupleRep '[r]).
11:54:19 <mniip> right
11:55:21 <nan`> i'm reading a paper https://web.cecs.pdx.edu/~mpj/pubs/springschool95.pdf and i want to understand what he is saying, i just don't get how it isa fixed point.
11:56:02 <mniip> nan`, in a lazy functional language,  'f (f (f (f ...)))' is a fixed point of 'f'
11:56:42 <mniip> especially so if you consider your types as domains, i.e including nontermination
11:57:15 <mniip> 'f (f (f (f ...)))' can be written as 'fix f' where 'fix f = f (fix f)'
11:57:32 <mniip> (that's not the exact definition)
11:57:43 <mniip> translating this all into type level, you have 'data Fix f = Fix (f (Fix f))'
11:58:09 <Gurkenglas> uh oh two different failures on two attempts at stack upgrade --git https://gist.github.com/Gurkenglas/d48ab4bd35fbbc31bb4d20eaa5af1599
11:58:40 <nan`> mniip: hm i will think about it thank you
11:58:50 <Gurkenglas> (oh I think just the output format is different, not the error)
12:00:24 <mniip> nan`, mind, in my notation I used Fix to mean both the data and the type constructor
12:00:48 <Gurkenglas> Could it be caused by being run from inside a stack project?
12:00:49 <mniip> in yours 'Mu' is the type constructor (type function), and 'In' is a data constructor
12:18:06 <lf94> https://www.haskell.org/arrows/syntax.html is this composition on steroids?
12:22:53 <typetetris> Where can I learn, for which ghc versions I need to import `Data.Semigroup` and for which not ?
12:23:35 <madnight> typetetris: http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Semigroup.html Since: base-4.9.0.0
12:24:22 <madnight> typetetris: https://wiki.haskell.org/Base_package ghc 8.0.1 (May 2016) base 4.9.0.0
12:25:45 <typetetris> Okay thank. Is there some tutorial or package I can peak on, how to make a package with monoid instances compatible with all major ghc versions
12:25:46 <typetetris> ?
12:27:44 <madnight> typetetris: not sure if there is a tutorial but you can use CPP and a pragma like this https://github.com/madnight/asciichart/blob/master/src/Data/Text/Chart.hs#L28 to make your code compatible
12:28:17 <typetetris> I found https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid#Writingcompatiblecode that seems to be, what I want.
12:28:53 <madnight> typetetris: yup looks good
12:36:05 <EvanR> officially spoiled now writing down a set of "mutually recursive" equations which has no actual recursion, and not having to worry about ordering
12:36:26 <EvanR> in eager land, you have to put them in the right order or else
12:36:36 <EvanR> and the order may not make as much sense
12:37:16 <EvanR> otoh accidental recursion goes unnoticed until too late(tm0
12:37:59 <Gurkenglas> Nope, it still happens outside a stack project folder https://gist.github.com/Gurkenglas/f0674b97142bdb912e9682dc6800cef5
12:38:46 <Gurkenglas> Should I post this as a stack issue?
12:46:35 <Ariakenom> does anyone rely on the Enum fractional instance?
12:47:21 <Ariakenom> > [1.0,3 .. 4]
12:47:23 <lambdabot>  [1.0,3.0,5.0]
12:48:57 <EvanR> > [1,3..4]
12:48:59 <lambdabot>  [1,3]
12:49:03 <EvanR> o_O O_o
12:50:19 <nshepperd> the enum instance for floats is weird and broken
12:52:06 <hpc> s/the enum instance for// ;)
12:53:11 <hpc> i don't think i have ever used the Enum instance for floats, except to demonstrate how odd it is
12:53:44 <nshepperd> > [0.0, 0.1 .. 1.0]
12:53:46 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.600...
12:57:47 <nshepperd> > [1.0,3 .. 3.9]
12:57:49 <lambdabot>  [1.0,3.0]
12:58:11 <lavalike> > enumFromThenTo 1 3 4 -- EvanR 
12:58:12 <lambdabot>  [1,3]
12:58:41 <EvanR> i have used the enum instance for floats when screwing around in ghci
12:58:51 <EvanR> luckily never ran into any of these edge cases
13:05:22 --- mode: glguy set +v lippirk
13:05:36 <Ariakenom> just wondering how much breakage changing it would cause
13:06:23 <lippirk> does anybody know how to escape a # in a hamlet file?
13:07:42 * hackage edges 0.11 - Tools for efficient immutable graphs  http://hackage.haskell.org/package/edges-0.11 (NikitaVolkov)
13:08:14 <marvin2> > [0.5..1.0]
13:08:16 <lambdabot>  [0.5,1.5]
13:08:20 <marvin2> > [0.5,0.6..1.0]
13:08:22 <lambdabot>  [0.5,0.6,0.7,0.7999999999999999,0.8999999999999999,0.9999999999999999]
13:09:52 <nshepperd> @check (\start end steps -> (end > start && steps >= 1) ==> let s = (end - start) / fromIntegral steps in length [start, start +
13:09:52 <lambdabot>  <unknown>.hs:1:122:Parse error: EOF
13:09:56 <nshepperd> blast
13:10:14 <nshepperd> @check (\start end steps -> (end > start && steps >= 1) ==> let s = (end - start) / fromIntegral steps in length [start, start + s .. end :: Double] === (steps+1))
13:10:16 <lambdabot>  +++ OK, passed 100 tests.
13:10:54 <EvanR> good, it works
13:10:59 <EvanR> ship it
13:11:32 <nshepperd> seems like it does what you expect, at least, when the step size divides the interval evenly
13:12:00 <nshepperd> which is probably the normal case
13:12:12 <EvanR> > [2.0, 2.1 .. 4]
13:12:14 <lambdabot>  [2.0,2.1,2.2,2.3000000000000003,2.4000000000000004,2.5000000000000004,2.6000...
13:12:19 <EvanR> > last [2.0, 2.1 .. 4]
13:12:21 <lambdabot>  4.000000000000002
13:12:33 <EvanR> i'm not sure what i expect...
13:13:01 <Ariakenom> EvanR: 5? :p
13:13:12 <EvanR> lights
13:13:44 <Myrl-saki> Aaaaa, weird types.
13:13:48 <Myrl-saki>   withSession $ mainWidgetWithHead (headWidget bulma pacifico fa) . loginPage
13:13:50 <marvin2> float enum adds half a step to end value, which is 0.05 in this case
13:14:00 <Myrl-saki>   withSession $ \sess -> mainWidgetWithHead (headWidget bulma pacifico fa) $ loginPage sess
13:14:05 <Myrl-saki> Second one type-checks, first one doesn't.
13:14:15 <EvanR> interesting
13:14:37 <cocreature> sounds like there is a RankNType involved
13:15:14 <Myrl-saki> cocreature: Oh, thanks. :P
13:15:31 <Myrl-saki> cocreature: I'm guessing it's hidden within the constraint?
13:15:32 <nshepperd> usually i use [start + fromIntegral i * (start - end) / fromIntegral steps | i <- [0..steps]]
13:15:34 <alexteves> yeah I had something similar happen yesterday (also with reflex-dom) stuff
13:15:42 <nshepperd> when i want to sample things over an interval
13:15:46 <alexteves> should go away if you add signatures
13:15:46 <cocreature> Myrl-saki: I don’t know, I don’t know where that function is coming from
13:15:50 <nshepperd> or numerically integrate or something
13:16:15 <Myrl-saki> cocreature: It's with reflex-dom. I meant to say "can it be hidden within the constraint?"
13:17:07 <Gurkenglas> How do I write https://gist.github.com/Gurkenglas/0685fd44c92705515a00731349a18643 correctly?
13:17:13 <cocreature> mainWidgetWithHead doesn’t seem to have a constraint in its type signature
13:17:35 <Myrl-saki> cocreature: Everything else does. `headWidget :: MonadWidget t m => Text -> Text ->  Text ->  m ()`
13:18:37 <Myrl-saki> cocreature: I guess it's too deep within the code to find, since MonadWidget is also just a type synonym(constraint synonym?)
13:18:49 <cocreature> my guess would be that loginPage has some RankNType thingy in its return type
13:19:10 <Myrl-saki> LoginPage is defined as
13:19:12 <Myrl-saki> loginPage :: MonadWidget t m => Session -> m ()
13:19:37 <Ariakenom> > maxBound :: Float
13:19:39 <lambdabot>  error:
13:19:39 <lambdabot>      • No instance for (Bounded Float) arising from a use of ‘maxBound’
13:19:39 <lambdabot>      • In the expression: maxBound :: Float
13:19:41 <cocreature> that MonadWidget typeclass looks terrible :)
13:19:43 <Ariakenom> hm why not?
13:20:06 <EvanR> lol
13:20:49 <cocreature> Myrl-saki: doesn’t seem to be a type synonym. what exactly is the error that you get for the first version?
13:21:00 <Gurkenglas> Ah there we go, "(Monad n, MonadTrans t, m ~ t n)"
13:21:06 <Gurkenglas> (First time I needed ~!)
13:21:15 --- mode: glguy set +v dataN
13:21:22 <dataN> why are DefaultSignatures provided to the superclass and not the subclass?
13:21:40 <Myrl-saki>     • Couldn't match type ‘m0 ()’ with ‘forall x. Widget x ()’
13:21:41 <Myrl-saki>       Expected type: m0 () -> IO ()
13:21:43 <Myrl-saki>         Actual type: (forall x. Widget x ()) -> IO ()
13:21:45 <Myrl-saki> cocreature: 
13:22:06 <lf94> Myrl-saki, yo :)
13:22:06 <dataN> subclass modules cant be imported by the module defining the superclass. 
13:22:09 <Myrl-saki> lf94: OMG
13:22:15 <Myrl-saki> lf94: PM
13:23:13 <cocreature> Myrl-saki: yeah that definitely looks like an error caused by RankNTypes somewhere but I definitely can’t be bothered to look through that horrible typeclass to figure out where exactly it’s coming from :)
13:23:41 * hackage cereal-data-dword 0.1.1 - Integration of "cereal" and "data-dword"  http://hackage.haskell.org/package/cereal-data-dword-0.1.1 (NikitaVolkov)
13:24:06 <cocreature> Myrl-saki: oh it’s easy, it’s directly in the type https://github.com/reflex-frp/reflex-dom/blob/develop/reflex-dom/src/Reflex/Dom/Internal.hs#L66
13:24:21 <cocreature> I was looking at the version of hackage but as usual reflex authors can’t be bothered to make releases :/
13:24:39 <cocreature> even though reflex platform presumambly uses this version which is why you are seeing this error
13:25:32 <Myrl-saki> cocreature: Oh thanks!
13:25:41 * hackage edges 0.11.0.1 - Tools for efficient immutable graphs  http://hackage.haskell.org/package/edges-0.11.0.1 (NikitaVolkov)
13:30:47 <ZeuPiark> bye
13:31:43 --- mode: glguy set +v dataN
13:31:45 <dataN> :t sequence 
13:31:46 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:31:51 <dataN> :t sequence (\(x:xs)->(x,Just xs))
13:31:52 <lambdabot> (Monoid a, Traversable ((->) [a])) => (a, [a] -> Maybe [a])
13:31:57 <dataN> why is there a Monoid constraint?
13:34:20 <hpc> :t \(x:xs)->(x,Just xs)
13:34:21 <lambdabot> [a] -> (a, Maybe [a])
13:34:25 <hpc> :t sequence
13:34:26 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:34:37 <dataN> :t sequence . (\(x:xs)->(x,Just xs))
13:34:38 <lambdabot> [a] -> Maybe (a, [a])
13:34:41 <dataN> oops...
13:34:47 --- mode: glguy set +v kritzefitz_
13:34:50 <kritzefitz_> dataN: Because (,) a is only a Monad with (Monoid a)
13:35:06 <dataN> oh, whys that?
13:35:31 <hpc> :t return -- dataN: implement that for ((,) a)
13:35:32 <lambdabot> Monad m => a -> m a
13:35:57 <hpc> what's the left element of the resulting tuple?
13:36:00 <dataN> :t \a-> (a,a)
13:36:01 <lambdabot> b -> (b, b)
13:36:26 <hpc> not quite
13:36:49 <dmj`> does B.useAsCString mempty give NULL
13:36:52 <hpc> if you treat (,) like that, keeping both elements the same
13:37:04 <hpc> then if you do something like fmap on it
13:37:10 <hpc> then in the type (a, b), both a and b change
13:37:28 <hpc> meaning when you go back to thinking generically, m doesn't stay the same
13:37:39 <hpc> in one moment m = ((,) a), in another m = ((,) b)
13:38:09 <Gurkenglas> Can I warn when people instantiate my variant of liftIO at id?
13:38:16 <hpc> dataN: consider m = ((,) SomeVerySpecificType)
13:38:25 <hpc> dataN: you should be able to write return such that you can do both
13:38:36 <hpc> return "some string" :: (SomeVerySpecificType, String)
13:38:41 <dataN> :t \a->(1::Int,a)
13:38:42 <lambdabot> b -> (Int, b)
13:38:44 <hpc> and return 5 :: (SomeVerySpecificType, Int)
13:40:09 <hpc> dataN: what if m = ((,) String) now?
13:40:33 <dataN> \((a,b),(c,d)) -> (a `mappend` c, b `mappend` d) ?
13:40:39 <dataN> for join...
13:41:18 <dataN> :t \a->(mempty,a)
13:41:20 <lambdabot> Monoid a => b -> (a, b)
13:41:21 <hpc> you're still thinking that the 'a' type variable applies on both sides of the tuple
13:41:25 <hpc> there you go
13:42:10 <hpc> dataN: so yeah, that's the correct definition of return
13:42:21 <dataN> :t \(m1,(m2,a)) -> (m1 `mappend` m2,a) 
13:42:23 <lambdabot> Monoid a => (a, (a, b)) -> (a, b)
13:42:31 <hpc> for Monoid a => Monad ((,) a)
13:42:45 <hpc> then m = ((,) a)
13:42:52 <hpc> return :: b -> m b
13:43:06 <dataN> awesome!
13:43:22 <hpc> substituting in m and the additional constraint, return :: Monoid a => b -> (a, b)
13:43:30 <hpc> dataN: now write fmap, it should be pretty easy
13:43:47 <hpc> :t fmap
13:43:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:43:57 <dataN> :t \f (a,b) -> (a,f b)
13:43:58 <lambdabot> (t -> b) -> (a, t) -> (a, b)
13:44:08 <hpc> yep
13:44:13 <hpc> left stays the same, right changes
13:44:19 <hpc> because of the positioning of the type variables
13:44:44 <hpc> dataN: the same happens for Either, but it doesn't need any extra constraints because return doesn't need to make a value of the left type
13:45:02 <dataN> :t \(a,f) (b,x) -> (a`mappend`b,f x)
13:45:03 <lambdabot> Monoid a => (a, t -> b) -> (a, t) -> (a, b)
13:45:31 <hpc> > join ("string 1", ("string 2", 5))
13:45:33 <lambdabot>  ("string 1string 2",5)
13:46:40 <dataN> ok.
13:47:34 <dataN> so why do DefaultSignatures appear in the superclass rather than the subclass definition despite this meaning they cant be used for subclasses in different modules to the superclass? 
13:51:24 <kuribas> why does ghc complain about the type variable of Proxy being not of kind (*) (but Bool), while it works inside a type class?
13:51:53 <kuribas> If I write attr = lookupAttrSymbol (Proxy :: Proxy found) (attributes :: AttrMap a ts) as an instance, it works fine, if I write it as a function, ghc complains.
13:52:21 <dataN> what is; the "required" context of  the signature for pattern synonym?
13:52:25 <kuribas> :t Proxy
13:52:27 <lambdabot> forall k (t :: k). Proxy t
13:53:49 <dataN> kuribas: whats the error?
13:54:29 <kuribas> dataN: • Couldn't match type ‘*’ with ‘Bool’ Expected type: Proxy found0 Actual type: Proxy found0
13:54:45 <kuribas> compiler bug?
13:54:48 <dataN> yep
13:55:00 <dataN> call it an unhelpful error.
13:55:08 <hpc> what is the kind of found?
13:55:12 * hackage attoparsec-ip 0.0.2 - Parse IP data types with attoparsec  http://hackage.haskell.org/package/attoparsec-ip-0.0.2 (athanclark)
13:55:16 <kuribas> hpc: Bool
13:55:22 <dataN> the error is elsewhere in the code and it throws that kind of message for some reason
13:55:40 <hpc> hmm
13:55:48 <dataN> a paste would be helpful
13:58:03 <kuribas> dataN: https://gist.github.com/kuribas/36a2e0538421498c4f8c91b1ef06a8ab
13:58:41 * hackage attoparsec-ip 0.0.3 - Parse IP data types with attoparsec  http://hackage.haskell.org/package/attoparsec-ip-0.0.3 (athanclark)
13:58:46 <dataN> with the error as a comment?
14:01:07 <kuribas> dataN: I pasted the error
14:01:18 <hpc> i can reproduce it
14:01:45 <kuribas> the GetAttr class seems rather unneccessary, and I want to get rid of it.
14:02:19 <hpc>       Expected type: Proxy Bool found0
14:02:19 <hpc>         Actual type: Proxy * found0
14:02:36 <hpc> oh, i can give Proxy a kind signature maybe
14:04:27 --- mode: glguy set -v kritzefitz
14:04:28 <hpc> what's the language extension for @ as a symbol for passing arguments the next level up?
14:04:48 <kuribas> hpc: TypeApplications
14:04:52 <kuribas> for some reason putting a forall on the function solved the problem...
14:04:57 <kuribas> weird...
14:04:57 <hpc> that's already on
14:05:11 <hpc> weird
14:05:24 <kuribas> maybe because of the scopedvariables?
14:05:28 <hpc> i was trying stuff like :: Proxy @Bool found, and getting nowhere
14:05:34 <kuribas> ScopedTypeVariables
14:05:50 <kuribas> ah, they likely didn't kick in...
14:05:58 <hpc> hmm
14:06:05 <hpc> if i take out ScopedTypeVariables, the error is the same
14:06:13 <kuribas> so found referred to a fresh found.
14:06:40 <dataN> kuribas: this works; https://lpaste.net/649859965275602944
14:07:38 <kuribas> dataN: yeah, because now the variables unify.
14:08:10 <dataN> oh so how is that forall not implicit?
14:08:25 <hpc> it is
14:08:35 <hpc> but turning on the behavior of ScopedTypeVariables probably requires you to write it
14:08:41 <kuribas> dataN: because scopedtypevariables don't work on implicit foralls
14:08:47 <hpc> otherwise the regular behavior applies
14:09:45 <dataN> so this is the better way; https://lpaste.net/8881731912721235968
14:10:43 <hpc> maybe (found :: Bool) in that forall for future-you's sanity as well?
14:11:46 <dataN> so using ScopedTypeVariables is giving this error; Expected type: p a Actual type: p a, which seems to indicate that a forall should be made explicit.
14:11:56 <kuribas> hpc: I think I lost it already ... but yeah :)
14:12:24 <hpc> oh, i know exactly why now
14:12:36 <hpc> so, if you pass the parameter to ghci that it tells you to
14:12:40 <hpc> the error includes the kinds
14:12:48 <hpc> one of the "found"s is :: Bool
14:12:50 <hpc> the other is :: *
14:12:54 <kuribas> yeah exactly
14:12:56 <hpc> so they're the same name, but different types
14:13:13 <hpc> because without ScopedTypeVariables, you can't refer to the type variable in the signature, in the body
14:13:30 <HunterJozwiak> Hmm. I am writing a dictionary for the screenreader to better represent Haskell symbols. What would be good for ->, or is there an index with arrows and their correct translations?
14:13:49 <hpc> this class of errors should maybe detect when the signature in the body is shadowing the definition's signature, and print a hint
14:14:01 <geekosaur> and the extension requires you to use explicit forall because the Haskell spec says they;re independent and existing code may depend on it, so you must be explicit about what bindings' scopes you're extending
14:15:29 <pavonia> HunterJozwiak: http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unicode-syntax has the symbols GHC uses
14:15:40 <hpc> something like "type variable `found` in the body of `foo` shadows the type signature. Perhaps you mean `forall {type variables in scope}. existing signature`"
14:15:54 <dataN> so the unhelpful error is when the kinds match but the symbols cant be?
14:17:03 <hpc> yeah
14:17:09 <hpc> whoops scrolled up
14:17:12 <hpc> but also yeah
14:17:35 <HunterJozwiak> pavonia: thanks much.
14:17:46 <dataN> it could suggest to make explicit forall
14:17:57 <kuribas> hpc: I was confused because both were found0, so I thought they were the same type variable.
14:18:40 <dataN> thats not the error the paste gave
14:19:04 <dataN> can it be reproduced?
14:19:16 <kuribas> did emacs mess it up?
14:19:24 <hpc> maybe?
14:19:29 <hpc> or your version of ghc
14:19:33 <kuribas> Expected type: Proxy found0 Actual type: Proxy found0
14:19:57 <dataN> 8.4.3 didnt give that error.
14:20:21 <kuribas> 8.2.2 I think
14:20:52 <hpc> 8.0.2 here, it just said "found"
14:21:15 <hpc> don't feel like downloading a bunch of LTSs to compare :P
14:21:54 <kuribas> it isn't that important...
14:22:27 <dataN> so the more recent error is helpfull enough, forcing the kinds to match using the explicit forall.
14:24:29 <dataN> oh, but only if the kinds dont match... then some indication for the ScopedTypeVariables convention of requiring explicit forall would still be helpful. 
14:25:03 <dataN> why does it do that anyway?
14:26:10 <int-e> dataN: you mean why does it require the forall?
14:26:41 * hackage madlang 4.0.2.9 - Randomized templating language DSL  http://hackage.haskell.org/package/madlang-4.0.2.9 (vmchale)
14:27:11 <dataN> why doesnt ScopedTypeVariables work with implicit forall?
14:27:48 <kuribas> I think to be not invasive
14:27:57 <Cale> dataN: Because that would cause lots of existing code to break if you turned on the extension.
14:28:14 <dataN> oh, because it conflicts with type annotations. 
14:29:51 <hpc> i would be curious to see how much code it breaks in practice
14:30:17 <Cale> I actually wish that TypeApplications worked the same way
14:30:27 <hpc> but i guess part of the loose "contract" of language extensions is that they never break vanilla haskell just by adding them?
14:30:39 <Cale> It should be impossible to use a TypeApplication with anything that wasn't defined with an explicit forall
14:31:23 <Cale> because now library authors who don't even use TypeApplications but perhaps want to use ScopedTypeVariables have to worry about what happens when they add an explicit forall with multiple type variables
14:31:25 <geekosaur> [11 21:13:40] <geekosaur> and the extension requires you to use explicit forall because the Haskell spec says they;re independent and existing code may depend on it, so you must be explicit about what bindings' scopes you're extending
14:45:33 --- mode: glguy set +v dataN
14:45:49 <dataN> here is the error "the required context of the signature for pattern synonym"; https://lpaste.net/8378680445088301056
14:46:18 <dataN> how can constraints be added to patterns?
14:52:33 <dataN> cant find anything online...
15:00:50 <rotaerk> hmm I'm using the "clock" library to get the time, and it returns # nanoseconds as an Integer ... I need a float representing the number of seconds
15:00:52 <dataN> adding annotations to the type of the function being matched over seems to work, but this is not whats meant in the error? https://lpaste.net/1830942213232656384
15:00:54 <rotaerk> any idea how to convert?
15:01:07 <rotaerk> (well, double actually)
15:01:12 * hackage libnix 0.2.0.0 - Bindings to the nix package manager  http://hackage.haskell.org/package/libnix-0.2.0.0 (Profpatsch)
15:02:12 <dataN> :t fromInteger 
15:02:13 <lambdabot> Num a => Integer -> a
15:02:34 <rotaerk> oh.. lol
15:04:02 <dataN> also, those kind of infix pattern synonyms seem difficult to import...
15:06:15 <dataN> i.e. there seems to be no way to do so while specifying exported functions using parenthesis after the module deceleration or imported functions using parenthesis at the import call...
15:06:32 <dataN> only works if the whole module is imported 
15:13:42 * hackage libnix 0.2.0.1 - Bindings to the nix package manager  http://hackage.haskell.org/package/libnix-0.2.0.1 (Profpatsch)
16:23:41 * hackage indexation 0.5 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.5 (NikitaVolkov)
16:32:12 * hackage attoparsec-uri 0.0.5.1 - URI parser / printer using attoparsec  http://hackage.haskell.org/package/attoparsec-uri-0.0.5.1 (athanclark)
16:36:41 * hackage attoparsec-uri 0.0.6 - URI parser / printer using attoparsec  http://hackage.haskell.org/package/attoparsec-uri-0.0.6 (athanclark)
17:00:42 * hackage wiring 0.5.1 - Wiring, promotion and demotion of types.  http://hackage.haskell.org/package/wiring-0.5.1 (seanparsons)
17:26:26 --- mode: glguy set +v jackoe
17:26:30 <jackoe> lquit
17:43:21 <Gurkenglas> No (e -> m a) -> ExceptT e m a -> m a? :(
17:46:43 <fsestini> Gurkenglas: \f m -> runExceptT m >>= either f pure ?
17:53:44 <blankhart> is there a typeclass expressing the notion of a linear container that can be traversed in order, where the order is meaningful rather than an implementation detail (as for a List, Seq, ...)?
17:54:46 <EvanR> what does linear container mean... why doesn't Map count, or does it
17:55:20 <shachaf> What's the distinction between a meaningful order and an implementation detail?
17:57:38 <blankhart> by linear i just mean that there is a unique ordering that is exposed rather than hidden
17:57:59 <Axman6> can you give an example?
17:58:03 <blankhart> List
17:58:03 <shachaf> Traversable/Foldable always exposes an order.
17:58:24 <blankhart> maybe that is the answer
17:58:39 <blankhart> i will think harder
18:00:12 * hackage indexation 0.5.0.1 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.5.0.1 (NikitaVolkov)
18:00:36 <Gurkenglas> fsestini, yes but that's verbose for that
18:13:01 <nshepperd> what would be interesting would be a typeclass for containers where the order is *not* meaningful or defined: foldMapUnordered :: (CommutativeMonoid m) => (a -> m) -> f a -> m
18:14:09 <nshepperd> but i'm not sure what it would actually be good for in practice
18:14:32 <c_wraith> CommutativeMonoid is a troublesome class, too
18:15:07 <c_wraith> It would have the exact same functionality as Monoid.  So it's either a subclass with no methods (makes inference awful) or it's mostly-redundant.
18:15:09 <nshepperd> it's just monoid, but with an extra law!
18:15:35 <EvanR> it would be great for... combining sorted sets then sorting them!
18:15:46 <EvanR> order doesnt matter!
18:16:08 <nshepperd> it would be good for containers that do reduction in parallel across multiple threads or clusters
18:16:23 <c_wraith> associativity is enough for parallel reduction
18:16:30 <nshepperd> where the order of operations might change depending on what data is in whose cache
18:18:52 <nshepperd> c_wraith: if you get to choose how to split up the data
18:19:53 <nshepperd> ofc  this is silly because if you're doing stuff across clusters there's network traffic so maybe the whole thing should be in IO
18:46:09 <Gurkenglas> https://github.com/haskell/haskell-ide-engine/blob/84d60f4af62fe58402a569d5992e2790ef4e6cbe/src/Haskell/Ide/Engine/Dispatcher.hs#L89 <- If I can't give hoistFreeT a fully polymorphic argument that's an antipattern, right? How would I correctly dismantle the FreeT and ExceptT layers here?
18:46:57 <Gurkenglas> (hoistFreeT = hoistFreeT')
18:47:39 <Gurkenglas> (all but the type signature, that is)
18:51:39 <Gurkenglas> There are prisms for Free, why not FreeT?
19:14:45 <dibblego> what would it look like exactly?
19:57:34 <pie__> is there any way to ensure that a large object doesnt get copied?
19:58:24 <benzrf> pie__: in what context?
20:00:43 * hackage fast-arithmetic 0.6.0.8 - Fast functions on integers.  http://hackage.haskell.org/package/fast-arithmetic-0.6.0.8 (vmchale)
20:04:10 <pie__> benzrf, well im downloading stuff and displaying it and some of these objects could presumably be pretty large, so if i accidentally say did a copy when going from the downloaded object to the displayed object id waste a lot of ram (or just not fit)
20:04:38 <pie__> err, well in actuality it wouldnt not fit but it would still be awkward to effectively double the ram usage
20:05:32 <benzrf> i think that's almost entirely an issue of the specifics of the libraries you're using
20:06:14 <benzrf> but i think (?) you shouldnt have to expect ghc to do any copying that wouldnt be directly caused by how the libraries work
20:08:04 <pie__> yeah i figured
20:08:20 <pie__> there isnt some type magic i can do? :p (well, why would there be i guess)
20:16:30 <Axman6> why would things be copied? Haskell data structures are extremely good and sharing data because of immutability
20:18:19 <Axman6> s/and/at
20:30:13 * hackage hw-prim 0.6.2.4 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.4 (haskellworks)
20:49:21 <pie__> Axman6, fair enough
20:49:40 <Axman6> pie__: do you have a particular example you're worried about?
20:50:43 * hackage discord-haskell 0.5.1 - Write bots for Discord in Haskell  http://hackage.haskell.org/package/discord-haskell-0.5.1 (Aquarial)
20:51:17 <pie__> not really, but at one point i pass data to an external lib so ill probably want to use some kind of Ptr
20:51:49 <pie__> Axman6, ^
21:11:43 * hackage jord 0.3.0.0 - Geographical Position Calculations  http://hackage.haskell.org/package/jord-0.3.0.0 (CedricLiegeois)
21:20:40 <cocreature> pie__: you can use a StablePtr if you want to treat it as an opaque pointer from the C side
21:21:32 <pie__> cocreature, cool thanks, that will probably be helpful
21:23:18 <cocreature> pie__: if you want to pass some blob of bytes that will actually be inspected from the C side then the two main options are binned ByteArray# and Storable vectors
21:23:25 <cocreature> s/binned/pinned/
21:23:36 <cocreature> ByteString uses pinned byte arrays under the hood
21:23:50 <pie__> oh thats what opaque meant
21:25:05 <pie__> cocreature, is there a comparison of the two somewhere?
21:25:43 * hackage jord 0.3.1.0 - Geographical Position Calculations  http://hackage.haskell.org/package/jord-0.3.1.0 (CedricLiegeois)
21:26:28 <cocreature> pie__: I don’t know of any comparison
21:26:39 <cocreature> Storable is probably easier
21:27:06 <cocreature> you also don’t need a Storable vector, you can pass anything with a Storable instance to C
21:30:34 <cocreature> thinking about it pinned ByteArray# is really the wrong thing to use here. it guarantees that it isn’t moved but it isn’t really meant for being passed to C
22:07:43 * hackage haskell-gi 0.21.4 - Generate Haskell bindings for GObject Introspection capable libraries  http://hackage.haskell.org/package/haskell-gi-0.21.4 (inaki)
22:13:06 --- mode: glguy set +v aravindh
22:17:29 <aravindh>  Can someone tell me how to write a function that accepts more than one type that adheres to a typeclass? For example, if I have a type class Svg, and data Circle, data Square conform to SVG, then I want to write a function that takes a list of SVG which contains both square and circle at the same time
22:18:53 <dmj`> could do this with existential quantification
22:18:56 <dmj`> data SomeList = forall s . SVG s => SomeList [s]
22:19:30 <dmj`> But could also just make your type more verbose and avoid classes, data SVG = SVGCircle Circle | SVGSquare Square, and write functions on SVG
22:20:26 <dmj`> or doThing :: SVG a => [a] -> [a]
22:21:02 <cocreature> that’s not a list of things that are an instance of SVG, it’s a list of a single type "a" that has to be an instance of SVG
22:21:11 <dmj`> right, I was getting to that
22:21:25 <dmj`> the problem with [a] is that all the a’s have to be the same
22:22:31 <cocreature> generally, I would try to avoid existentials in most cases. e.g. here rather than accepting a heterogenous list of things that you can convert to svg, why not just accept a list of svg elements?
22:23:02 <cocreature> i.e. perform the conversion when you put elements in the list
22:57:58 <Myrl-saki> https://gist.github.com/adrianparvino/68865ffc3a016f191e20e38ac23542fc
22:58:01 <Myrl-saki> Any comment on this Lens?
22:58:10 <Myrl-saki> s/Lens/Lens usage/
22:58:57 <koz_> Is there something in the Haskell ecosystem similar to vector, but for higher-dimensional arrays?
23:00:02 <cocreature> koz_: massiv is probably worth a look for that
23:00:59 <koz_> cocreature: How similar is it to the way vector does things?
23:01:43 <cocreature> not sure what exactly you mean by that. things are necessarily going to be a bit different if you’re working with multi-dimensional arrays
23:01:50 <cocreature> and massiv also takes parallelism into account
23:01:52 <cocreature> just look at the api
23:02:02 <koz_> cocreature: Alrighty, I shall. Thanks for the suggestion!
23:02:46 <koz_> I guess I meant more like 'does it have a similar set of structures to vector, for example, a Storable one, an unboxed one, etc'.
23:02:54 <koz_> It appears that the answer is 'yes, with single-letter names for everything'.
23:03:19 <cocreature> it even has a few more :)
23:03:24 <koz_> Yeah, I saw that.
23:03:33 <koz_> That's good - I should be able to work with that.
23:07:20 <cocreature> Myrl-saki: tbh I wouldn’t use lens for anything here apart from (loginPage ^. responseBody). if you chain "to" you might as well just apply regular functions and you can replace the mapped part by fmap
23:08:03 <cocreature> so something like fromAttrib "…" <$> find (…) (parseTags (loginPage ^. responseBody))
23:08:39 <cocreature> it’s not any longer, it’s easier to read even if you do know lens, it requires less knowledge of lens, …
23:13:17 <Myrl-saki> cocreature: Thanks.
23:13:56 <Myrl-saki> Oh, TIL, & and >>> has the same fixity.
23:14:09 <Myrl-saki> So you can't `a & f >>> g`
23:14:11 <Myrl-saki> :(
23:16:46 <MarcelineVQ> you could but one is infixl and one is infixr at the same precedence which is the real issue
23:18:18 <Myrl-saki> Ohhh
23:19:13 * hackage amazonka-iam-policy 0.0.2 - Amazon IAM Policy Document DSL and Combinators.  http://hackage.haskell.org/package/amazonka-iam-policy-0.0.2 (BrendanHay)
23:26:15 <maybefbi> I am using types generated by json-autotype. It is full of (:|:) type constructors as defined here: http://hackage.haskell.org/package/json-autotype-2.0.0/docs/Data-Aeson-AutoType-Alternative.html I want to be able to go inside like so ((a :|: b) :|: c) -> a without having into invent a new function each time for each type of lookup
23:26:51 <maybefbi> how do i do this?
23:27:05 <maybefbi> do i need something like Fix or Cofree for arbitrary depth?
23:28:21 --- mode: glguy set +v aravindh
23:28:42 <aravindh> Can someone tell me how to pass multiple types conforming to a typeclass as params to a function. I have a typeclass SVG and data Circle & Square confirming to SVG. I want to define a function that accepts multiple instances of SVG at the same time. How do I define such a function signature
23:29:19 <aravindh> I basically want to pass a list containing both Circle and Square at the same time
23:29:25 <koz_> aravindh: Are you after something like 'foo :: (SVG a, SVG b) => a -> b -> Bool' or something?
23:29:27 <maybefbi> how do i generalize ((a :|: b) :|: c) -> a and ((a :|: b) :|: c) :|: d) -> a into one function?
23:29:27 <MarcelineVQ> did you happen to catch the responses you got to that question earlier?
23:29:32 <dmj`> maybefbi: This is why I don’t use json-autotype :) it’s almost better to use it just for type generation, then manually edit it by hand afterwards.
23:29:43 <maybefbi> ok
23:29:51 <aravindh> @Koz: Yes but it is a list. So I do not know how many values I would be passing
23:29:51 <lambdabot> Unknown command, try @list
23:29:53 <MarcelineVQ> asking just in case you missed them, not asking in a mean way
23:29:54 <dmj`> maybefbi: what json api are you modelling?
23:29:59 <maybefbi> reddit
23:30:06 <maybefbi> reddit listing
23:30:08 * dmj` reads reddit api docs
23:30:14 <koz_> aravindh: Then 'bar :: (SVG a) => [a] -> Int' perhaps?
23:30:21 <maybefbi> wait let me lpaste it for you
23:30:38 <koz_> Or do you want to have multiple _different types_ which are all instances of SVG and somehow packed into a list?
23:30:46 <aravindh> No. This would fix `a` to a single type. But i want it to accept both circle & square at the same time
23:30:53 <aravindh> Yes correct
23:31:13 <dmj`> @package reddit
23:31:13 <lambdabot> http://hackage.haskell.org/package/reddit
23:31:17 <dmj`> maybefbi: does this not suffice?
23:31:29 <dmj`> maybefbi: sure
23:31:59 <koz_> aravindh: You have to use something called an existential type. https://wiki.haskell.org/Existential_type might be of some help.
23:32:28 <koz_> Alternatively, instead of using a typeclass, you could make a sum type like this:
23:33:00 <aravindh> I tried. But i am still getting error. I will create a gist. Please give me a min.
23:33:02 <koz_> data SVG = Circle Float Float | Square Float | Rhomboid Float Float etc.
23:33:12 <koz_> Because using existentials for something like this seems excessive.
23:34:20 <aravindh> https://gist.github.com/hardvain/d6b40b63cb3da343d76fe49f1bd2b182
23:34:55 <aravindh> I do not want to make a sum type because then it would not be useable by those using the library. 
23:35:08 <koz_> That ... doesn't make sense. Why would it be the case?
23:35:32 <koz_> Also, could you please output the error you get from GHC?
23:36:14 <aravindh> Updated the error message in the gist
23:36:45 <aravindh> If I make a sum type, how can comeone add more variants to SVG type?
23:36:59 <koz_> aravindh: Ah, I see. You're concerned with extensibility.
23:37:07 <koz_> Your original statement wasn't clear on that point.
23:37:14 <koz_> What's 'Node' in this context?
23:37:22 <aravindh> Sorry for not being clear
23:37:28 <aravindh> Node is a data constructor of Tree
23:37:58 <aravindh> Updated the gist with tree 
23:38:21 <koz_> Yeah, the issue is that your Tree is fixed to a specific a.
23:38:27 <koz_> The problem's not with your function.
23:38:37 <koz_> Since what you want is a _Tree_ that stores an existential.
23:39:00 <koz_> Whereas currently, Tree a is fixed to some specific a.
23:39:10 <aravindh> I have added forall a for sampleTree. Doesnt that make it an existential?
23:39:26 <koz_> aravindh: No. That forall doesn't actually do anything.
23:39:54 <koz_> Read this: https://wiki.haskell.org/Existential_type#Basics
23:40:03 <koz_> It gives an example of what you're trying to do.
23:40:19 <aravindh> Ok @Koz. Thanks a lot. I will read this
23:41:07 <koz_> No worries!
23:41:15 --- mode: glguy set +v maybefbi
23:41:31 <maybefbi> tips
23:41:50 <lavalike> and tricks
23:43:00 <mnrmnaugh> ok, i have a rather inept question. so eh, Prelude not found is pretty bad, isnt it... how come ghci can find it then? and also if i try and module Prelude, it still craps out, apologies for the screenshot, i figure its easier to just show the whole thing https://ptpb.pw/bnJP.png, and yes it tried both -v and ghc-pkg check
23:43:02 --- mode: glguy set +v gabeugcar
23:43:45 <MarcelineVQ> how was ghc installed
23:43:53 <mnrmnaugh> with pacman
23:44:08 <MarcelineVQ> that's pretty weird then, even for arch
23:44:22 <c_wraith> well, yes and no
23:44:24 <mnrmnaugh> and i do remeber hearing something about it being broken on arch, but, the fact that ghci works...
23:44:28 <c_wraith> arch has been shipping a broken ghc for a while
23:44:29 <koz_> The general Arch advice (spoken as someone who used Arch for a while) is 'use Stack and save yourself the hell'.
23:44:49 <c_wraith> that is certainly a weird way to be broken, though
23:45:13 <mnrmnaugh> hmmm, what is Stack?
23:45:26 <MarcelineVQ> https://wiki.archlinux.org/index.php/haskell  is the defacto first stop, but not finding Prelude is quite off. do you have ghc-static?
23:45:55 <mnrmnaugh> ohhh nope, not static
23:46:34 <mnrmnaugh> lets try that, thank you
23:46:48 <MarcelineVQ> give it a shot, at worst you're in the same spot
23:47:07 <mnrmnaugh> heh, yehp
23:47:11 <MarcelineVQ> stack is a pretty good option for arch currently, I have to use it myself lamentably
23:47:31 <MarcelineVQ> er, not to lament srack, just the state of haskell on the distro
23:47:49 <koz_> MarcelineVQ: I hear ya.
23:48:01 <koz_> (even though I Gentoo now)
23:48:05 <koz_> (still using Stack :P)
23:48:07 <mnrmnaugh> ive been havin enough fun with ghci, but im wondering why this inc func doesnt need the second arg, inc a b = [a..] !! b. how does it know where to stop o.o
23:48:30 <mnrmnaugh> so i figure tryna dump stg is prolly a good route
23:49:19 <mnrmnaugh> lol silly deps. -static relies on the eh, normal ghc package? ok...
23:49:41 <MarcelineVQ> [a..] ?  it doesn't stop, it's just that you're only requesting as many items as needed to get to the index b specifies. haskell is lazy so it won't evaluate things unless they're needed
23:49:47 <mnrmnaugh> oh hey, it found it, noiche, my hero
23:50:14 --- mode: glguy set +v gabeugca1
23:50:19 <mnrmnaugh> im calling it without the b, tho. and it does stop :S
23:51:00 <mnrmnaugh> inc i o = [i..] !! o ; domap a b = if a!!0 == b then a else domap (fmap (inc b) a) b 
23:51:39 <Digit> hi, newbie question: i have "fmap (/ 2) [1..9]", but what does it the other way, so the 1..9 are divided by the 2?
23:52:19 <koz_> > fmap (/ 2) [1..9]
23:52:21 <lambdabot>  [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5]
23:52:32 <koz_> You mean the 2 is divided by each of those, right?
23:52:42 <koz_> Since what you're requesting is what it already does.
23:52:50 <Digit> oh brain fog.  yes.  XD   sorry, edit fail.
23:52:57 <koz_> > fmap (2 /) [1..9]
23:52:59 <lambdabot>  [2.0,1.0,0.6666666666666666,0.5,0.4,0.3333333333333333,0.2857142857142857,0....
23:53:11 <koz_> Haskell, much like friendship, is magic.
23:53:13 <Digit> oh, simples.  that helps me understand fmap much better.
23:53:29 <gabeugcar> > fmap (2 /) [1..9]
23:53:31 <lambdabot>  [2.0,1.0,0.6666666666666666,0.5,0.4,0.3333333333333333,0.2857142857142857,0....
23:53:53 <mnrmnaugh> ye, im still kinda lost on map and fmap. pretty nice so far tho
23:54:10 --- mode: glguy set +v gabeugca2
23:54:18 <koz_> :t contramap
23:54:19 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
23:54:32 <gabeugca2> :t Map
23:54:33 <lambdabot> error:
23:54:33 <lambdabot>     • Data constructor not in scope: Map
23:54:33 <lambdabot>     • Perhaps you meant one of these:
23:54:40 <mauke> map f [x1, x2, x3, ...] == [ f x1, f x2, f x3, ... ]
23:54:45 <gabeugca2> :t Data.Map
23:54:47 <lambdabot> error:
23:54:47 <lambdabot>     Not in scope: data constructor ‘Data.Map’
23:54:47 <lambdabot>     No module named ‘Data’ is imported.
23:55:04 <gabeugca2> take 5 [1..]
23:55:05 <mauke> given a list of arguments, map f returns a list of results (of applying f to each argument in turn)
23:55:30 <gabeugca2> @take 5 [1..]
23:55:30 <lambdabot> Maybe you meant: type time
23:55:35 <MarcelineVQ> mnrmnaugh:  inc is being applied to two arguments there  fmap (inc b) a   is saying apply inc to b, then use that resulting function on the contents of a
23:55:36 <mnrmnaugh> ye but its very picky about functions that take arguments
23:55:59 <mnrmnaugh> ohhhhhhhhhhhhhhhhhhhh ok
23:56:09 <MarcelineVQ> @let inc i o = [i..] !! o
23:56:10 <lambdabot>  Defined.
23:56:14 <koz_> Also, where's contramap from?
23:56:15 <MarcelineVQ> :t inc -- this is a function
23:56:16 <lambdabot> Enum a => a -> Int -> a
23:56:25 <MarcelineVQ> :t inc 12 -- but so is this
23:56:26 <lambdabot> (Num a, Enum a) => Int -> a
23:56:42 <geekosaur> @hoogle contramap
23:56:42 <lambdabot> Control.Lens.Getter contramap :: Contravariant f => (a -> b) -> f b -> f a
23:56:42 <lambdabot> Data.Functor.Contravariant contramap :: Contravariant f => (a -> b) -> f b -> f a
23:56:42 <lambdabot> System.IO.Streams.Combinators contramap :: (a -> b) -> OutputStream b -> IO (OutputStream a)
23:56:57 <mauke> > (+ 3) 2
23:56:59 <mnrmnaugh> the type stuff is definatly screwing with me still
23:56:59 <lambdabot>  5
23:57:01 <koz_> I wanted the Contravariant one, thanks!
23:57:08 <gabeugca2> @type Data.Map
23:57:09 <lambdabot> error:
23:57:09 <lambdabot>     Not in scope: data constructor ‘Data.Map’
23:57:09 <lambdabot>     No module named ‘Data’ is imported.
23:57:19 <gabeugca2> @type Maybe
23:57:21 <lambdabot> error:
23:57:21 <lambdabot>     • Data constructor not in scope: Maybe
23:57:21 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
23:57:26 <mauke> gabeugca2: what are you doing?
23:57:32 <mnrmnaugh> looks so easy, but i die every time :D
23:57:36 <MarcelineVQ>  @type is for expressions
23:57:44 <gabeugca2> @:t maybe
23:57:45 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
23:57:48 <MarcelineVQ> @type  Just 12
23:57:49 <lambdabot> Num a => Maybe a
23:58:05 <gabeugca2> @type Just 10
23:58:06 <lambdabot> Num a => Maybe a
23:58:07 <geekosaur> and Data.Map is a module, not a type. and Maybe is a type constructor, not an expression
23:58:17 <geekosaur> Maybe kas a kind instead of a type
23:58:20 <geekosaur> :k Maybe
23:58:21 <lambdabot> * -> *
23:58:25 <mnrmnaugh> ive been trying to impl add without using + for like, a few days now. its eh. been interesting
23:58:38 <gabeugca2> @:k Maybe
23:58:38 <lambdabot> Maybe you meant: wn v rc pl id do bf ask @ ? .
23:59:03 <gabeugca2> :k Maybe
23:59:04 <lambdabot> * -> *
23:59:13 <gabeugca2> :t fmap
23:59:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:59:58 <MarcelineVQ> mnrmnaugh: you might like succ/pred   if I'm understanding your work here it's relevant. I kind of like + myself though
23:59:58 <mauke> > let add a b = a - negate b in add 2 3
