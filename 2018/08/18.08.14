00:00:12 <superlinux> dminuoso, I was only asking whether the stream operator exists in haskell. haskell is my 1st FP language. now I am also reading about elixir
00:00:29 <dminuoso> superlinux: its not really a "stream operator"
00:00:34 <dminuoso> superlinux: it's semantically similar to ($)
00:00:41 <dminuoso> except the direction is reversed
00:00:47 <superlinux> I know what is composition in haskell
00:01:05 <int-e> dminuoso: The way to hell is paved with overlapping instances. (Oh did I write "hell"? I meant "incoherent instances".)
00:01:19 <superlinux> ah right! yes! the dollar sign in reverse. hehe
00:01:30 <dminuoso> superlinux: I think function composition is more fitting though.
00:01:36 <dminuoso> It's also equivalent in a way
00:02:19 <superlinux> yes equivalent
00:02:56 <dminuoso> superlinux: so maybe (>>>) is a good analogy?
00:21:13 * hackage haskell-lsp-types 0.7.0.0 - Haskell library for the Microsoft Language Server Protocol, data types  http://hackage.haskell.org/package/haskell-lsp-types-0.7.0.0 (AlanZimmerman)
00:51:24 <arahael> Is parsec still the goto tool for writing a parser? 
00:51:34 <arahael> (Note: I'm pretty naive when it comes to this)
00:52:13 * hackage haskell-lsp 0.7.0.0 - Haskell library for the Microsoft Language Server Protocol  http://hackage.haskell.org/package/haskell-lsp-0.7.0.0 (AlanZimmerman)
00:52:21 <cocreature> arahael: I would recommend megaparsec over parsec
00:52:27 <cocreature> take a look at the readme for a comparison
00:56:00 <arahael> cocreature: Nice.  I notice that it suggests Attoparsec for cases where I want to process "large" amounts of data, and Megaparsec where I'd prefer better error messages.  That is, unless the input size is 'huge', go with megaparsec.
00:56:05 <arahael> How big are we talking about with "huge"?
00:56:53 <cocreature> as a rule of thumb, avoid attoparsec for any input generated by humans. the error messages tend to be bad and humans donâ€™t produce that much input
00:57:11 <arahael> Awesome, thanks for that.
00:57:37 <cocreature> if you are parsing some kind of protocol then attoparsec can make sense but megaparsec comes pretty close in terms of performance so unless you have some specific reason to care a lot about performance I would always default to megaparsec
00:58:27 <arahael> Yeah, I want to parse a programming language, so it sounds pretty obvious that I should pick megaparsec.
00:58:36 <cocreature> yeah definitely
00:59:09 <cocreature> arahael: you might want to take a look at https://markkarpov.com/megaparsec/parsing-simple-imperative-language.html for this
01:00:09 <arahael> I'll definitely be looking through the tutorials.
01:00:27 <Ariakenom> What about some overengineered "attoparse <|> megaparse" for fast successes and good errors
01:01:05 <cocreature> Ariakenom: Iâ€™d say the more likely outcome of that is something with bad errors and bad performance :)
01:01:42 <cocreature> as I said the performance difference is already fairly small and iirc Iâ€™ve even seen megaparsec beat attoparsec in some benchmarks
01:07:42 <dyamon> hi, can you give me some directions to approach error handling when dealing with multiple libraries (and hence different error handling techniques)?
01:11:09 <arahael> cocreature: It strikes me that writing smaller parsers that parse just a single line of the code is a good starting point, and further, that I could quasi-quote this, and put it directly into my tests.  Any good tutorials on that?
01:11:36 <cocreature> arahael: Iâ€™m not sure what you hope to gain from quasi quoters here
01:12:15 <asheshambasta> Has anyone else found themselves in the situation of converting a Crypto.PubKey.RSA.Types.PrivateKey to a PEM format? 
01:12:35 <arahael> cocreature: What's this called? [fooLang| var z = a + b; ]
01:16:49 <arahael> cocreature: It seems like an elegant way to insert code to be parsed?
01:17:05 <arahael> (I ask what it's called, because I'm not sure of my terminology)
01:20:25 <arahael> What I'd want to do, is test that it indeed results in the AST I expect.
01:30:09 <lortabac> hello, is there a way to check if a constraint is satisfied in GHCI?
01:31:13 * hackage haskell-postal 0.2.1.0 - Haskell binding for the libpostal library  http://hackage.haskell.org/package/haskell-postal-0.2.1.0 (netom)
01:33:22 <lortabac> oh nevermind, I just have to add the constraint to a dummy function
01:33:33 <asheshambasta> https://github.com/haskell-crypto/cryptonite/issues/69, this is going to be a PITA I suppose
01:34:26 <merijn> asheshambasta: Anything involving x.509 involves lot of sadness and drinking, yes
01:35:32 <asheshambasta> merijn: I guess so, yes. Although this just seems like some plumbing I need to do: writing an RSA PrivateKey from cryptonite to a PEM string
01:36:01 <asheshambasta> merijn: my knowledge about crypto is limited, but this is a rather simplistic use case, I'm assuming. 
01:39:21 <cocreature> arahael: I donâ€™t understand why you need a quasi quoter for that. if you are just trying to insert code to be parsed in a test, why not use a simple string literal instead, e.g., "var z = a + b;"
01:40:12 <Clint> asheshambasta: probably a good thing to add to x509-store
01:41:06 <asheshambasta> Clint: agreed 
01:41:09 <mpickering> How can I globally stop .ghc.environment files being generated?
01:41:18 <asheshambasta> Clint: I'll see if I can figure something out 
01:41:30 <cocreature> mpickering: you canâ€™t sadly
01:41:41 <cocreature> mpickering: see https://github.com/haskell/cabal/issues/4542
01:47:48 <mpickering> seriously they have just annoyed me
01:48:04 <Gurkenglas> Does typeRep have an inverse?
01:48:11 <cocreature> mpickering: same here but Iâ€™m too tired to continue the discussion in that issue
01:48:18 <mpickering> I don't see what the problem with explicitly entering an environment like python or nix-shell is
01:50:29 * dminuoso is tempted to provide a quasiquoter for iproute so that I can have compile time safe literals without the need for validated-literals
01:51:58 <Gurkenglas> How do I read a String to the type provided by an argument TypeRep?
01:54:08 <geekosaur> pretty sure you don't unless you use ghc-api to make types --- which wouldn't necessarily match with the compiled program
01:54:50 <mpickering> cocreature: https://github.com/haskell/cabal/issues/4542#issuecomment-412802391
01:55:53 <cocreature> mpickering: thanks although I feel like the comments in this issue just repeat the same arguments over and over without making any progress :/
01:56:05 <mpickering> It feels like everyone is being held hostage to one user's workflow...
01:56:51 <mpickering> An uncharitable reading is that (1) User's report problems (2) Maintainer closes as wontfix 
01:57:47 <sclv> Thereâ€™s literally agreement to add a flag to control this
01:58:13 <sclv> The only disagreement is the default value of the flag
01:58:30 <sclv> Which is absolutely a matter of taste
01:59:07 <mpickering> So has this flag been implemented?
01:59:22 <cocreature> there was agreement that there should be a flag before this feature was in a released version of cabal, yet we got a release that forced this behavior on everyone and didnâ€™t add a flag
01:59:22 <sclv> No. But someone should!
02:00:35 <Gurkenglas> geekosaur, how about TypeRep -> String -> Dynamic?
02:01:23 <geekosaur> you need the full compiler and rfull compile time information to do what you want
02:01:28 <sclv> Until the release people didnâ€™t realise how _much_ the lack of a flag would bother people tbh
02:01:29 <Gurkenglas> Should they then unrelease that release until they've added the flag or removed the feature?
02:01:51 <sclv> Hence why it only kicked off in earnest on that ticket 3mo ago
02:07:21 <Gurkenglas> There's a function "foo :: C b => A -> b". This record has an A and there's a "Map TypeRep Dynamic" in a record to memoize all the foo results on that A, which is monadically cached the first time someone tries to access it. I want to move that memoizing behavior to the data, by making that field "Map TypeRep (IO Dynamic)" or "TypeRep -> IO Dynamic" or something. I already have a function that'll memoize the "TypeRep -> IO Dynamic" once I 
02:07:21 <Gurkenglas> have it. How can this be approached?
02:07:57 <Gurkenglas> (*"in the record". There's only one record.)
02:08:34 <dminuoso> Gurkenglas: Im curious if you dont mind, what does "monadically cached" mean?
02:09:02 <dminuoso> It's completely unrelated by the way. :)
02:09:31 <Gurkenglas> dminuoso, actually foo's type is "C b => A -> IO b". Does that answer your question? :P
02:09:53 <Gurkenglas> (C has Typeable as a superclass.)
02:10:13 * hackage futures 0.1 - Simple and fast implementation of Future  http://hackage.haskell.org/package/futures-0.1 (NikitaVolkov)
02:13:44 <dminuoso> Gurkenglas: I think so yeah.
02:14:22 --- mode: glguy set +v rihards
02:14:45 <rihards> because then i get errors like "Couldn't match type â€˜mâ€™ with â€˜m1â€™"
02:15:01 <dminuoso> rihards: You seem to have missed the first part of your message.
02:15:11 <Gurkenglas> dminuoso, it's IRC's fault
02:15:27 <rihards> huh? it wasn't sent?
02:15:45 <Gurkenglas> rihards, yea, it's less painful if you don't dwell on it :D
02:15:46 <geekosaur> it was sent privately because you have to be voiced first, because freenode's getting spammed to hell and back
02:15:54 <dminuoso> rihards: we currently have some mechanism in place to fight the current spam situation
02:15:59 <geekosaur> you should have gotten a rivate message telling you this, but some clients won't show it to you dirctly
02:16:35 <rihards> ok :D here it is then:
02:16:51 * dminuoso has a response prepared
02:16:55 <rihards> hey, is there any way to reference the parent function's type signature's type variables in a sub-functions type signature? i'm trying to debug a compiler error by setting type signatures for my sub-functions but this doesn't work so well when the functions have type constraints because then i get errors like "Couldn't match type â€˜mâ€™ with â€˜m1â€™"
02:16:59 <dminuoso> rihards: Use ScopedTypeVariables.
02:17:11 <dminuoso> Neat! It was correct after all, based on just that fragment.
02:17:31 <Gurkenglas> For extra balls, put the "Neat" line in with the previous one.
02:17:32 <dminuoso> rihards: Note you also have to explicitly introduce `m` with forall
02:17:34 <geekosaur> note that you also need to explicitly "forall* the type variables that are to be exposed
02:17:52 <geekosaur> because you could change the meaning of existing code that doesn't expect the type variables to be related
02:20:03 <Gurkenglas> hexagoxel, given a String, how do I memoize "Read a => Proxy a -> IO Dynamic" across all a?
02:23:43 * hackage jukebox 0.4 - A first-order reasoning toolbox  http://hackage.haskell.org/package/jukebox-0.4 (NickSmallbone)
02:26:01 <rihards> oh, sweet, ScopedTypeVariables is just what i'm looking for. thanks
02:26:26 <rihards> and nice catch there, dminuoso :D
02:30:10 <dminuoso> ScopedTypeVariables should be part of the language.
02:31:41 <rihards> it seems so. it's been a thing i've been meaning to use since i started with haskell
02:34:12 <rihards> btw, are there any plans to consolidate some of the ghc extensions and make haskell2020 or something?
02:35:04 <dminuoso> rihards: https://github.com/haskell/rfcs/projects/1
02:35:15 <rihards> oh, right, wikipedia says exactly that
02:37:34 <rydgel> what is the best websockets client library?
02:38:30 <rydgel> with ssl support
02:38:43 * hackage typed-process 0.2.3.0 - Run external processes, with strong typing of streams  http://hackage.haskell.org/package/typed-process-0.2.3.0 (MichaelSnoyman)
02:41:59 <rihards> rydgel: i've been using the websockets library and wuss for ssl
02:43:58 <rydgel> ok thanks, doesn't seem to have any others
02:46:14 <rihards> when i was searching around that's what i concluded as well. but websockets is really sufficient and nice to work with
02:46:54 --- mode: glguy set +v BKD
02:47:07 <BKD> I've tried home-brew AND from source and I CAN NOT get wxHaskell installed on my High Sierra based Mac! The "from source" comes closest but make dies with "<some-file>.o must specify at least one -dep-suffix". Which file is named depends on which target I specify for make. Additionally, I have tried with 8.4.3 (error + deprecation warnings galore) AND 7.10.3 (just the error message)
02:52:36 <BKD> I installed WxWidgets 3.1.1 from source into "/usr/local/wxWidgets" and put the "bin" subdirectories on my $PATH as well as setting WXWIN to the base dir without /bin. Anybody willing to walk me through getting wxHaskell to work step-by-step? If not, I'll have to find another language and I STRONGLY prefer functional programming
02:56:51 <lavalike> BKD: by the way, this picture is not great https://matrix.hackage.haskell.org/package/wx
03:00:02 <BKD> lavalike: Are there any alternatives to wxHaskell then?
03:01:37 <lavalike> BKD: not to use wx widgets, but I have seen other toolkits/bindings being suggested lately, in particular:
03:01:40 <lavalike> @package gi-gtk
03:01:40 <lambdabot> http://hackage.haskell.org/package/gi-gtk
03:05:19 <BKD> does that have native appearance on Windows and Mac? "Foreign-looking" apps don't sell well on the App Store.
03:06:10 <hjt> i asked a question on stackexchange and accepted the answer, but now i sort of want to know more...
03:06:12 <hjt> https://stackoverflow.com/questions/51012153/how-to-think-about-the-lack-of-laws
03:06:43 <lavalike> BKD: I believe they don't, at least on mac
03:08:18 <BKD> ok, thanks. what is the name of the base library, GTK? I'll do a quick "google" and check
03:11:08 <lavalike> BKD: yes
03:21:55 <ZeuPiark> hello
03:25:44 <BKD> lavalike: it says GTK+ 3 supports native Mac appearance, but doesn't say either way about gtk+ 2
03:30:21 <dminuoso>     â€¢ No instance for (Servant.Prometheus.HasEndpoints MandyAPI)
03:30:33 <dminuoso> Is there generally a way to debug why it couldn't find an instance, or do I really have to do this by hand?
03:30:47 <dminuoso> I mean servant has some rather big types..
03:34:32 <davean> It can't find it because it doesn't exist in the scope. Its either not defined, or nothing imports the definition anywhere in your import transative closure.
03:34:39 <davean> Maybe you mean why does it want that instance?
03:36:17 <dminuoso> davean: Well I have instances, but they dont seem to match so..
03:36:42 <dminuoso> davean: It's essentially an instance for a huge servant type
03:36:47 <dminuoso> Or rather a series of instances
03:37:07 <davean> I mean they're not that instance then? Or you don't import it
03:41:43 * hackage jukebox 0.4.1 - A first-order reasoning toolbox  http://hackage.haskell.org/package/jukebox-0.4.1 (NickSmallbone)
03:42:27 <dminuoso> davean: Ah I get it. It appears there was no instance for BasicAuth which was my outermost type constructor. :)
03:42:31 <dminuoso> Thank you.
03:42:43 * hackage amazonka-iam-policy 0.0.4 - Amazon IAM Policy Document DSL and Combinators.  http://hackage.haskell.org/package/amazonka-iam-policy-0.0.4 (BrendanHay)
03:43:48 <maerwald> is there a way to list all rules in shake?
03:49:42 <ph88> is this a memory leak ?  https://imgur.com/a/UEf6L0l 
03:50:18 <merijn> ph88: Maybe? Depends on what you're doing...
03:50:53 <ph88> run quickcheck test
03:51:26 <ph88> i generator random AST, then pretty print it and then parse it back into AST .. which must be equal .. this is the property that i'm testing
03:52:13 * hackage Frames-beam 0.1.0.1 - A library for accessing Postgres tables as in-memory data structures.  http://hackage.haskell.org/package/Frames-beam-0.1.0.1 (GagandeepBhatia)
03:53:12 <ph88> by the way .. why i only see 120 seconds of data in my heap profiling chart when my program ran half an hour ?
03:53:20 <merijn> That should probably be constant, unless you're generating huge ASTs by accident...
03:55:30 <ph88> i think the AST's are actually the dark part in the bottom of the graph
03:55:42 <ph88> where each triangle is a completed iteration of quickcheck
03:56:17 <merijn> I can't read what the yellow part is in that image, tbh
03:57:04 <ph88> you mean the textual description ?
03:57:19 <ph88> it's the biggest part of the graph .. the area under the top line
03:57:30 <ph88> (17398)putLine/counterexampl...	2584392   i see in my .hp file
04:00:04 <ph88> i will run the profiling again with longer cost-centre stack name to get some more info ..
04:02:59 <ph88>   /usr/bin/time stack exec vfix -- +RTS -h -L 99999 -sstderr      vfix: bad RTS option: -L       aaahhmmm .. manual says this -L options is available  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#rts-options-for-heap-profiling   i also use ghc 8.4.3 with lts-12.6  o_O
04:04:22 <ph88> ah i shouldn't put space between -L and number
04:10:19 * Gurkenglas "has $ _Just . _Right" ðŸ‘Œ
04:15:43 * hackage JuicyPixels 3.3.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.3.1 (VincentBerthoux)
04:38:33 <ZeuPiark> bye
04:48:06 <Gurkenglas> modifyMVar_ says it's not atomic. That means it's not safe for two threads to mutate different entries of an MVar (Map k a), right?
04:49:43 <opqdonut> Gurkenglas: read the docs
04:49:46 <opqdonut> > In particular, the "bigger" functions in this module (swapMVar, withMVar, modifyMVar_ and modifyMVar) are simply the composition of a takeMVar followed by a putMVar with exception safety. These only have atomicity guarantees if all other threads perform a takeMVar before a putMVar as well; otherwise, they may block.
04:49:48 <lambdabot>  <hint>:1:14: error: parse error on input â€˜,â€™
04:49:57 <opqdonut> oops right yeah don't use > for quotes here
04:53:43 <Gurkenglas> Ah, I was used to all relevant documentation being at the function x)
05:07:49 <ij> Is there some package that parses and works with diffs(diff output)?
05:10:44 --- mode: glguy set +v ashesham`
05:12:09 <asheshambasta> ij: http://hackage.haskell.org/package/Diff-0.3.4/docs/Data-Algorithm-Diff.html
05:19:14 <dmwit> I don't think that has anything for parsing diff output.
05:20:06 <lavalike> @package diff-parse
05:20:06 <lambdabot> http://hackage.haskell.org/package/diff-parse
05:22:07 <asheshambasta> dmwit: ah true, thanks
05:22:43 * hackage Rasterific 0.7.4 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.7.4 (VincentBerthoux)
05:22:56 <ph88> this message about pkg-config https://bpaste.net/show/5025b2567771 is it about some haskell dependencies or libraries on my system ?
05:23:41 <cocreature> ph88: itâ€™s about the libglade C library which is apparently required by the glade Haskell library
05:24:05 <dmwit> ph88: Check in your system's package manager for something named e.g. libglade-dev or similar.
05:34:32 --- mode: glguy set +v gentauro
05:34:35 <gentauro> is Haskell `undefined` everybodies elses `null`?
05:34:45 <gentauro> % :t undefined
05:34:46 <yahb> gentauro: a
05:34:53 <gentauro> jep, pretty much :P
05:35:40 <Ariakenom> > undefined == 3
05:35:41 <[exa]> gentauro: nein!
05:35:42 <lambdabot>  *Exception: Prelude.undefined
05:36:09 <gentauro> is there a way (LANGUAGE pragma) to turn this "off" for good?
05:36:10 <Saulzar> Not exactly, for example you can't easily check for undefined
05:36:30 <dminuoso> gentauro: what is that undefined you speak about?
05:36:39 <merijn> gentauro: Undefined specifically might be possible, but for bottom in general, no
05:36:47 <gentauro> % [ 1,2,undefined, 3]
05:36:48 <yahb> gentauro: [1,2,*** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:11:7 in interactive:Ghci8
05:36:59 <gentauro> dminuoso: see example above?
05:37:01 <Ariakenom> :t let undef = undef in undef -- halting problem solving pragma
05:37:03 <lambdabot> t
05:37:13 <gentauro> it like the god damn `null` pointer from all other languages :(
05:37:16 <Saulzar> Undefined is usually used for incomplete code - it's more like exception or error
05:37:30 <[exa]> gentauro: it is not, you can't recover from undefined
05:37:31 <dminuoso> gentauro: Nope. Not seeing it. :o)
05:37:54 <merijn> Saulzar: You shouldn't use undefined for incomplete code, that's what typed holes are for
05:37:55 <gentauro> [exa]: so program "explodes"?
05:37:57 <gentauro> good !!!
05:38:12 <dminuoso> [exa]: But you can..
05:38:19 <dminuoso> Not that you should but...
05:38:29 <merijn> dminuoso: Not easily
05:38:30 <gentauro> dminuoso: try (...)
05:38:33 <gentauro> ?
05:38:36 <[exa]> gentauro: if you want nullability, use Maybe. undefined is a `reasonable name' for bottom values, which are meant to stand for computations that don't terminate
05:38:55 <gentauro> [exa]: I don't want nullability, I want to remove `undefined` from the lanuage :D
05:38:59 <Ariakenom> forkIO . pure $ undefined == 3
05:39:02 <Saulzar> merijn, Really, often I would use both   (undefined :: _)  :P
05:39:10 <gentauro> wtheck is that crap doing there in the first place D:
05:39:22 <merijn> Saulzar: That's a PartialTypeSignature, not typed hole
05:39:27 <cocreature> gentauro: that still leaves you with "undefined' = let x = x in x" which isnâ€™t that different in practise
05:39:48 <Ariakenom> undefined is not too different from error
05:39:50 <Ariakenom> :t error
05:39:51 <lambdabot> [Char] -> a
05:40:01 <dminuoso> gentauro: Just encode possible failure with Maybe. It's the clean way and after doing it for a bit you might feel enlightenment coming your way.
05:40:02 <merijn> Saulzar: (someone decided to go for maximum confusion and refer to partial type signatures as "type holes" (note the lack of *d*)
05:40:05 <[exa]> gentauro: that's the point of undefined, you can define it whenever you have recursion or cycles available. So haskell people defined a `pretty nice' undefined that at least throws an exception
05:40:09 <Ariakenom> _ / 0 = error "division by zero"; _ / 0 = undefined
05:40:27 <gentauro> dminuoso: I know how to handle errors
05:40:32 <merijn> gentauro: Undefined is an example of non-termination, i.e. it's part of Turing completeness
05:40:37 <gentauro> I just don't know how to handle other pelples `undefined`
05:40:43 <dminuoso> gentauro: Pull reque4sts.
05:40:53 <merijn> gentauro: You cannot eliminate non-termination in a Turing-complete language
05:40:57 <Saulzar> merijn, It seems quite a related concept
05:41:01 <[exa]> gentauro: you don't, they simply didn't finish their programs (or wrote type magics)
05:41:07 <merijn> gentauro: You handle other peoples undefineds by yelling at them to fix their shit
05:41:17 <gentauro> merijn: :D
05:41:19 <quchen> Ariakenom: undefined is literally Â»error "Prelude.undefined"Â«, so yes :-)
05:41:36 <gentauro> % :t Prelude.undefined
05:41:37 <yahb> gentauro: a
05:41:40 <gentauro> :(
05:41:56 <dminuoso> gentauro: Usually good libraries dont give you partial functions.. so..
05:41:57 <cocreature> :t let x = x in x
05:41:58 <lambdabot> t
05:42:06 <[exa]> so what if I
05:42:25 <[exa]> % let undefined' = error undefined' in undefined'
05:42:31 <yahb> [exa]: "*** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Exception: *** Excep
05:42:34 <gentauro> :o
05:42:40 <Ariakenom> gentauro: How would you like to define division without error?
05:42:43 <[exa]> good!
05:42:57 <dminuoso> Obligatory...
05:42:59 <dminuoso> > fix error
05:43:01 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
05:43:25 <quchen> > fmap fix return "Whatâ€™s going on here"
05:43:27 <lambdabot>  "What\8217s going on here"
05:43:32 <gentauro> % div' n d = if 0 == d then Nothing else Just n `div` d
05:43:34 <yahb> gentauro: 
05:43:43 <gentauro> Ariakenom: like that
05:44:01 <dminuoso> quchen: okay what the :o
05:44:30 <Ariakenom> pure as const :)
05:44:56 <quchen> dminuoso: Itâ€™s an interesting exercise to figure out what Â»fmap fix returnÂ« does.
05:45:10 <gentauro> % foo = fmap fix pure
05:45:11 <yahb> gentauro: 
05:45:18 <quchen> Looking at the type, there are only two implementations that typecheck.
05:45:25 <gentauro> % :t foo
05:45:26 <yahb> gentauro: b -> b
05:46:20 <gentauro> from now on, I'm going to leave `undefined` easter-eggs around my code :)
05:46:32 <gentauro> (and w8 eating pop-corn for the world to burn)
05:46:41 <dminuoso> quchen: oh thats pretty cool :)
05:46:41 <quchen> fmap fix return is not undefined. There are much more interesting undefineds.
05:47:09 <dminuoso> quchen: That's just simple type unification.. :)
05:47:32 <quchen> Yes! Itâ€™s an excellent interview question if your goal is not hiring new candidates too!
05:47:34 <[exa]> gentauro: oh that's too easy. Use any of the infinite number of undecidable ways to define undefined!
05:47:41 <quchen> Just like Â»Implement foldl' using foldrÂ« ;-)
05:47:47 <dminuoso> quchen: I could do it!
05:48:14 <quchen> I can do a lot of things but would absolutely fail them in an interview
05:48:17 <dminuoso> Heh :P
05:48:47 <dminuoso> quchen: I think the `fmap fix pure` is not so bad actually for an interview question. A competent haskeller should be able to figure it out in very little time.
05:49:07 <quchen> Whatâ€™s the difference between Â»data D a = D !aÂ« and Â»newtype N a = N aÂ«?
05:49:10 <gentauro> % :t fix
05:49:11 <yahb> gentauro: (a -> a) -> a
05:49:38 <quchen> dminuoso: It took me way too long the first time I tried figuring it out. I donâ€™t think itâ€™s a very easy question. Maybe if itâ€™s a socratic interview, but even then.
05:49:53 <gentauro> quchen: D is strict? and N is a single-case union type?
05:50:14 <gentauro> D gives mem overhead, while N is removed at compiler time?
05:50:36 <quchen> Thereâ€™s a denotational difference between the two
05:50:45 <quchen> You can write a program to distinguish them
05:51:13 <quchen> Itâ€™s very subtle and you probably have to read the Report carefully to find the solution
05:51:24 <gentauro> quchen: ein?
05:51:37 <dminuoso> quchen: I take it you go beyond reflection or coerce?
05:51:56 <quchen> Standard Haskell 2010
05:52:08 <quchen> (Or 98, doesnâ€™t matter)
05:52:17 <dminuoso> Okay Ill take the challenge =)
05:52:19 * dminuoso brb
05:52:59 <dminuoso> quchen: Cool, I would not have guessed this. :)
05:53:14 <hexagoxel> @tell Gurkenglas "Read a => Proxy a" ~ "Dict Read", right? and there is Ord (Dict a), so the previous solution applies.
05:53:14 <lambdabot> Consider it noted.
05:54:46 <Gurkenglas> hexagoxel, "Dict (Read a)", yes? I want an entry for every value of a
05:56:40 <Geekingfrog> Is there a lens to go from a Maybe [a] to [a] where Nothing -> [] and Just (xs) -> xs ?
05:56:47 <quchen> ?let data D a = D !a
05:56:48 <lambdabot>  Defined.
05:56:51 <quchen> ?let data N a = N a
05:56:52 <lambdabot>  .L.hs:168:1: error:
05:56:52 <lambdabot>      Multiple declarations of â€˜Nâ€™
05:56:53 <lambdabot>      Declared at: .L.hs:162:1
05:57:02 <quchen> ?undefine
05:57:02 <lambdabot> Undefined.
05:57:06 <quchen> ?let data D a = D !a
05:57:07 <lambdabot>  Defined.
05:57:11 <quchen> ?let newtype N a = N a
05:57:13 <lambdabot>  Defined.
05:57:18 <quchen> Playgroundâ€™s open!
05:57:35 <dmwit> Geekingfrog: non []
05:57:52 <dminuoso> quchen: Am I free to play too knowing the answer? :P
05:58:15 <dmwit> Geekingfrog: But beware that it doesn't roundtrip quite right: You will get Just [] -> [] -> Nothing instead of Just [] -> [] -> Just []
05:58:42 <Geekingfrog> It's for a quick and dirty script, and there will be no roundtrip, let me try that
05:59:18 <quchen> Actually, I might have been wrong in that Â»we can write a program to distinguish D and NÂ«, since the solution is âŠ¥ in one case, and we canâ€™t check for that
05:59:48 <quchen> But I guess if we allow a real program with IO and catching undefined then weâ€™re OK
05:59:53 <Vides> Hi there
05:59:59 <dminuoso> > (\(D a -> ()) undefined
06:00:01 <lambdabot>  <hint>:1:24: error:
06:00:02 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:00:08 <dminuoso> > (\ (D a) -> ()) undefined
06:00:10 <lambdabot>  *Exception: Prelude.undefined
06:00:10 <Vides> I have a question, maybe someone here can help me easily
06:00:11 <dminuoso> > (\ (N a) -> ()) undefined
06:00:13 <lambdabot>  ()
06:00:41 <Vides> if I try to define a dot product using only elementary functions, what is wrong with dotP = (foldl (+) 0) . (map (\(x,y) -> x * y)) . zip ?
06:00:46 <quchen> dminuoso: Thatâ€™s GHCâ€™s interpretation, now prove itâ€™s correct from the Report :-D
06:00:56 <dminuoso> quchen: It says so according to 3.17.2
06:01:18 <dminuoso> quchen: `N apat` is an irrefutable pattern is `apax` is irrefutable if `N` is a constructor defined by newtype
06:01:29 <quchen> Ah, that section actually mentions it explicitly! I havenâ€™t read that part
06:01:33 <dminuoso> `N apat` is an irrefutable pattern if `apat` is irrefutable and if `N` is a constructor defined by newtype
06:01:42 <quchen> The next chapter (formal semantics) is where I usually had to dig
06:01:53 <quchen> Reading the informal part could have saved me quite a bit of time it seems
06:01:57 <dminuoso> Read smart nod hard! :P
06:02:00 <dminuoso> *not even.
06:02:11 <dminuoso> quchen: Where exactly where you looking?
06:02:16 <quchen> FWIW itâ€™s rule (l), which basically says Â»newtypes can be erased when pattern matchingÂ«, which you cannot do with data types
06:02:37 <quchen> > case D undefined of D _ -> ()
06:02:39 <lambdabot>  *Exception: Prelude.undefined
06:02:44 <quchen> > case N undefined of N _ -> ()
06:02:46 <lambdabot>  ()
06:03:07 <quchen> Eh, (k)
06:03:38 <dminuoso> quchen: where in the report is that?
06:03:56 <quchen> dminuoso: Next chapter, Â»formal semantics of pattern matchingÂ«
06:04:28 <quchen> The heart and soul of the Report! :-D
06:04:29 <hexagoxel> Gurkenglas: ah, right. `forall a . Dict (Read a) -> IO Dynamic`
06:06:20 <dminuoso> > case undefined of (N _) -> ()
06:06:23 <lambdabot>  ()
06:06:27 <dminuoso> > case undefined of (D _) -> ()
06:06:29 <lambdabot>  *Exception: Prelude.undefined
06:06:34 <quchen> Ha, even easier.
06:06:40 <quchen> Simpler, rather.
06:08:11 <dminuoso> quchen: The real way to conduct a haskell interview is to ask them about Conduche functors and 2-functors to Prof though.
06:08:34 <Vides> in dotP = (foldl (+) 0) . (map (\(x,y) -> x * y)) . zip, GHCi says that left of zip we were expecting a type [a] - > [(c,c)], which is true, but instead it received the full type of zip, [a] - > [b] - [(a,b)]
06:08:41 <dminuoso> Make sure they really grasp Grothendieck fibrations.
06:09:01 <quchen> dminuoso: Thatâ€™s too obvious. The question must be deceptively simple with an insightful gotcha.
06:09:13 * hackage hmatrix-sundials 0.19.1.0 - hmatrix interface to sundials  http://hackage.haskell.org/package/hmatrix-sundials-0.19.1.0 (DominicSteinitz)
06:09:31 <Vides> my whole function is actually taking two lists, so that would actually be true... so I'm lost here :(
06:09:59 <quchen> Or outright misleading! Â»In what way does the strict identity function differ from the non-strict one â€“ f x = x vs f !x = x?Â«
06:11:03 <mauke> Vides: the last . isn't right
06:11:12 <dminuoso> Vides: First, you can use zipWith
06:11:21 <dminuoso> :t zipWith (*)
06:11:23 <lambdabot> Num c => [c] -> [c] -> [c]
06:11:27 <mauke> . is defined as (.) f g = \x -> f (g x)
06:11:32 <dminuoso> > zipWith [1,2,3] [10,20,30]
06:11:34 <lambdabot>  error:
06:11:34 <lambdabot>      â€¢ Couldn't match expected type â€˜Integer -> b -> câ€™
06:11:34 <lambdabot>                    with actual type â€˜[Integer]â€™
06:11:36 <quchen> Â»foldl' (+) (0 :: Int) [1..100000] â€“ in what way can a sufficiently stupid compiler overflow here?Â«
06:11:37 <dminuoso> > zipWith (*) [1,2,3] [10,20,30]
06:11:39 <lambdabot>  [10,40,90]
06:12:04 <dminuoso> Vides: and then `sum = foldl (+) 0`
06:12:12 <quchen> Â»Does foldr (+) overflow the heap or the stack? What about foldl (+)?Â«
06:12:17 <Vides> I know of zipWith, but I was wondering if there's any way to do it with only map, fold, and zip
06:12:29 <dminuoso> Vides: So you get a much shorter, more expressive, easier-to-see-mistakes version: dot = sum . zipWith (*)
06:12:34 <quchen> zipWith f = map (uncurry f) . zip
06:12:47 <dminuoso> Or.. dot = sum .: zipWith (*)
06:12:55 <mauke> :t sum . zipWith (*)
06:12:57 <lambdabot> (Num [c], Num c, Foldable ((->) [c])) => [c] -> [c]
06:13:09 <dminuoso> :t sum .: zipWith (*)
06:13:10 <lambdabot> error:
06:13:10 <lambdabot>     â€¢ Variable not in scope:
06:13:10 <lambdabot>         (.:)
06:13:18 <dminuoso> @let (.:) = (.) . (.)
06:13:19 <lambdabot>  Defined.
06:13:20 <dminuoso> :t sum .: zipWith (*)
06:13:21 <lambdabot> Num c => [c] -> [c] -> c
06:13:38 <Vides> quchen ah, uncurry...
06:14:23 <dminuoso> quchen: so the foldl' question, that would be if (+) was not strict right?
06:14:40 <quchen> (+) is strict on Int
06:15:18 <quchen> It doesnâ€™t really matter though, the sufficiently stupid compiler could overflow in either case
06:16:08 <quchen> All of my interview questions teach a valuable lesson in some way, theyâ€™re just very much unsuitable for interviews ;-)
06:16:27 <quchen> Maybe I should call them Â»questionsÂ« instead so it doesnâ€™t sound like Iâ€™m a madman
06:17:35 <quchen> dminuoso: The crux for foldl' is that Â»seqÂ« does not imply an evaluation order, and if the compiler is lazy the wrong way it gets to do a lot of extra heap work
06:17:37 <dminuoso> Well okay let me address the foldl variant, that would overflow the stack at least.
06:17:56 <dminuoso> quchen: Mmm yeah. I was aware about the seq part, but didnt connect it to this question mm.
06:18:04 <quchen> ?src foldl'
06:18:04 <lambdabot> foldl' f a []     = a
06:18:04 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:18:07 <dminuoso> No wait!
06:18:17 <dminuoso> the foldl variant will overflow the heap
06:18:21 <quchen> You can just keep expanding the foldl' and youâ€™ll get a huge cascade of let 
06:18:47 <dminuoso> Whereas careless usage of foldr will overflow the stack
06:19:22 <quchen> Now the question is â€“ which one is better?
06:19:33 <quchen> That is, less bad? :-D
06:19:37 <dminuoso> quchen: between which? foldl and foldr?
06:19:39 <quchen> Yup
06:19:42 <marvin2> dminuoso what is the differeince in haskell? I thought stack is not limited and can use all the available memory
06:20:02 <dvaergiller> quchen: depends which way you need to fold ;)
06:20:05 <Taneb> marvin2: generally it's bad if you use all the available memory, even if you can
06:20:07 <marvin2> so there's no actually a stack, in the conventional sense
06:20:11 <marvin2> no actual*
06:20:39 <quchen> Thereâ€™s no function call stack in GHC, no.
06:20:48 <quchen> The stack stores pattern matches, mostly.
06:21:10 <quchen> It grows when you use Â»caseÂ« and not when you evaluate function calls.
06:21:16 <dminuoso> quchen: My intuition says that foldl might be more painful because I suspect a thunk might require much more space than just the argument on the tack
06:21:23 <dminuoso> But that's just a guess
06:21:58 <quchen> dminuoso: Suppose you use foldl, get your heap to almost overflow (itâ€™s huuuuge enough letâ€™s say). What then?
06:22:04 <marvin2> quchen, so if we are in a recursive function with pattern matching, stacking would continue to grow (and potentially overflow)?
06:22:09 <quchen> foldl terminates. What now?
06:22:22 <quchen> marvin2: Yes
06:22:24 <dminuoso> quchen: the space is still in usage until GC hits, and then my program will stall quite a bit while GC works?
06:22:37 <dminuoso> Again, just a guess.
06:22:38 <marvin2> quchen how big is the stack?
06:22:44 <quchen> dminuoso: What happens to the giant thunk once you evaluate it?
06:23:08 <dminuoso> quchen: Dont thunks stick around until reclaimed?
06:23:46 <quchen> dminuoso: The thing is, once foldl terminates, you get a thunk thatâ€™s evaluated in a similar way than the foldr result
06:23:54 <quchen> So you get a stack overflow after your heap overflow
06:23:57 <dminuoso> quchen: Oh..
06:24:00 <quchen> foldr only has the stack overflow
06:24:04 <dminuoso> Right that makes perfect sense.
06:24:06 <quchen> Less overflow! Much better! ;-)
06:24:18 <dminuoso> So foldl is double treachery memory wise.
06:24:39 <dminuoso> quchen: what about my GC thoughts though?
06:24:53 <quchen> marvin2: I donâ€™t know. Fairly large, but in typical programs it doesnâ€™t grow a lot. Dozens of frames I would say.
06:25:36 <dminuoso> in typical programs stack frames can be somewhat sizable thought depending on how much you store in local variables that the compiler couldn't put into immediates or static storage
06:25:47 <quchen> dminuoso: There are multiple ways thunks can disappear, GC is one of them. Blackholes are another.
06:26:34 <quchen> https://github.com/quchen/stgi/#black-holes
06:26:46 <dminuoso> quchen: regarding foldl' though.. doesnt that mean a proper implementation would use pseq rather than seq?
06:26:58 <quchen> Well, black holes aid GC, so I guess itâ€™s GC too.
06:27:19 <quchen> dminuoso: No, a proper implementation would use seq and leave the compiler the liberty to do the right thing.
06:27:22 <dminuoso> quchen: so that's another reason to avoid fold. you get high heap usage, high stack usage and the thunks will increase GC pressure.
06:27:30 <dminuoso> foldl I mean
06:27:47 <dminuoso> What _is_ foldl good for? :P
06:27:56 <quchen> pseq says Â»Iâ€™m smarter than the compilerÂ«, which is very rarely the case.
06:28:12 <quchen> I have never used foldl in a productive way.
06:28:15 <xsperry> why do both foldl and foldl' even exist? why didn't they just implement foldl as foldl'?
06:28:22 <quchen> Some people have. Anyone who has remembers it specifically.
06:28:44 <xsperry> and why do functions like sum use foldl
06:28:55 <dminuoso> @src sum
06:28:55 <lambdabot> sum = foldl (+) 0
06:29:19 <dminuoso> xsperry: the base implementation is: getSum #. foldMap Sum
06:30:06 <quchen> xsperry: sum [1..] > 1 â€“ this works for the usually silly Â»sum = foldr (+) 0Â« and lazy integers
06:30:28 <mnoonan> quchen: is that a codata joke?
06:30:39 <quchen> Not a joke, just a corner case
06:30:40 <xsperry> so it breaks something you'd use in practice, for the sake of imagionary silly concept like lazy integers
06:30:42 <madnight> @src (->)
06:30:43 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
06:30:57 <quchen> xsperry: Pretty much.
06:31:03 <xsperry> awesome
06:31:04 <Taneb> xsperry: back in the 90's when they were defining the Haskell language standard they were willing to accept "functional programming is just slow", rather than figuring out a better way
06:31:14 <mnoonan> quchen: no, i mean "I have never used foldl in a productive way" :)
06:31:14 <Taneb> foldl (+) 0 is a fairly obvious way to write sum
06:31:37 <madnight> > let a <- b = flip (->)
06:31:39 <merijn> Taneb: You'd want foldl'
06:31:39 <lambdabot>  <hint>:1:7: error:
06:31:39 <lambdabot>      parse error on input â€˜<-â€™
06:31:39 <lambdabot>      Perhaps this statement should be within a 'do' block?
06:31:49 <quchen> mnoonan: That wasnâ€™t a joke either :-Ã¾
06:31:51 <Taneb> merijn: I'm trying to justify why the report uses "foldl"
06:32:05 <quchen> mnoonan: But youâ€™re right, it could have been.
06:32:09 <xsperry> Taneb so what has stopped them from rewriting sum to us foldl in the past 20 years?
06:32:19 <merijn> Taneb: The point is that I (nor anyone else) has never encountered a case where foldl is better than foldl'
06:32:22 <quchen> mnoonan: Â»Iâ€™ve never used foldl destructively eitherÂ«
06:32:23 <Taneb> xsperry: language standards are slow
06:32:32 <merijn> Taneb: So foldl should've beend efined as "foldl'"
06:33:05 <xsperry> Taneb, what about ghc writers doing it on their own? I doubt anyone would complain that they aren't following standard in this case
06:33:08 <Taneb> merijn: foldl' isn't in the Haskell2010 standard
06:33:15 <merijn> Taneb: So?
06:33:18 <quchen> Oo
06:33:19 <quchen> Itâ€™s not?
06:33:43 <Taneb> merijn: I'm talking specifically about the Haskell2010 standard and why it's written that way
06:33:49 <Taneb> Not what's a good idea in GHC Haskell
06:33:51 <quchen> It is!
06:33:59 <quchen> Section 20.3
06:34:09 <merijn> Taneb: Unless you can give a compelling reason why foldl' *isn't* in Haskell2010, that's still a bug in the report
06:34:11 <Taneb> quchen: oh, it's in Data.List?
06:34:18 <quchen> Yup
06:34:19 <Taneb> I missed that! Whoops
06:34:20 <quchen> Not in Prelude
06:34:26 <quchen> â€¦it seems
06:34:59 <xsperry> if foldl' already isn't in report there's no reason to introduce it. better to turn foldl into fold', and ghc could do foldl' = foldl for backward compatibility sake
06:35:18 <Taneb> merijn: I don't see why it would be a bug in the report, it's not an incorrect definition per se, just one with major issues in GHC (and possibly not other implementations of Haskell)
06:35:35 <dminuoso> xsperry: turning foldl into foldl' would have some nasty consequences.
06:35:39 <dmwit> Oh my goodness, no. We should not switch foldl and foldl' in a GHC release.
06:35:53 <xsperry> dminuoso name one
06:36:44 <dminuoso> xsperry: let's say for the sake of argument someone defined: last = foldl const
06:36:45 <quchen> The burden of proof is on the person making the change, not the other way round
06:36:46 <xsperry> dmwit not switch them, but turn foldl into foldl', and leave foldl' as is (and perhaps deprecate it)
06:36:49 <Taneb> xsperry: existing code that uses either foldl or foldl' would change behaviour in a potentially surprising and non-obvious way
06:36:53 <xsperry> dmwit not switch them, but turn foldl into foldl', and leave foldl' as is (and perhaps deprecate it)
06:37:03 <dminuoso> xsperry: By switching them out you know crash any software that, transitively, uses that function on a list containing bottom.
06:37:47 <xsperry> dminuoso I'm not really following what you're saying. is that just another theoretical BS concept like previously mentioned lazy integers, that nobody would actually use in practice?
06:38:12 <dmwit> For what it's worth: I have seen foldl used in practice.
06:38:12 <int-e> xsperry: Can you prove that this doesn't break any code (or introduce bad performance in code that is performing well today)?
06:38:31 <int-e> People do all sorts of stuff, in practice.
06:38:54 <Ariakenom> xsperry: I've used lazy integers as part of memoization strategy
06:39:16 <xsperry> int-e, can you prove that it does? because if you can't, then I'd take "maybe breaks some code" over "would certainly break some code" 
06:39:20 <dminuoso> xsperry: I can find foldl used _all_ over the place of GHC.
06:39:25 <int-e> xsperry: You can educate people to use foldl' by default; changing foldl to be strict is not worth the inevitable pain.
06:39:32 <dminuoso> xsperry: And tons of other packages I have on my harddrive.
06:40:12 <dminuoso> xsperry: But GHC would be an interesting pick. Flip foldl like you suggested and see if it passes performance tests..
06:40:13 <int-e> xsperry: No, I think the burden of proof is on you, since you're proposing to change the status quo.
06:40:16 <xsperry> dminuoso yes it is used all over the place in GHC.. which is why functions like sum can throw exception in certain cases
06:41:05 <xsperry> int-e, if you can't provide a single example where foldl' would be worse than foldl, and I can provide examples where the opposite is true, then you have no case to keep foldl as is
06:41:41 <dminuoso> xsperry: foldl' would be worse on an infinite list... so there's that.
06:41:54 <xsperry> dminuoso how so?
06:42:00 <dmwit> Would it? Surely both diverge on an infinite list.
06:42:07 <dvaergiller> xsperry: if in 99.9% of cases it caused an improvement and in 0.1% of cases causes a problem, then it's a problem
06:42:10 <ph88> how can i find out how i can reduce memory usage of the yellow area in my heap profile graph ?  https://imgur.com/a/UEf6L0l
06:45:19 --- mode: glguy set +v aeline
06:47:30 <int-e> > foldl (flip (&&)) True [expensive calculation, easy computation that is usually False] -- still artificial, but this is the kind of stuff I'd be wary about... folding over a short list where the relevant answer can be computed without forcing the intermediate results.
06:47:32 <lambdabot>  error:
06:47:33 <lambdabot>      Variable not in scope: expensive :: t0 -> Boolerror: Variable not in sco...
06:47:33 <lambdabot>      Variable not in scope: easy :: t1 -> t2 -> t3 -> t4 -> Bool -> Boolerror...
06:47:39 <int-e> ah
06:47:44 <int-e> > foldl (flip (&&)) True [undefined, False]
06:47:46 <lambdabot>  False
06:47:50 <int-e> > foldl' (flip (&&)) True [undefined, False]
06:47:51 <lambdabot>  *Exception: Prelude.undefined
06:49:14 <aeline> Hey, new to learning Haskell, quick question: I've a bunch of
06:49:14 <aeline> 	 functions of type (N -> N -> N), and I'd like a function that maps
06:49:14 <aeline> 	 them to type (N -> N -> Maybe N). I've got it working now, but it
06:49:14 <aeline> 	 feels inelegant: justWrapper f = \a b -> Just $ f a b. Is there a
06:49:17 <aeline> 	 nicer way to do this? Feels like there should be.
06:49:20 <aeline>  
06:49:23 <int-e> This will be rare, but it will result in the worst kind of regression to track down: code that just gets inexplicably slower or more memory hungry.
06:49:35 <dmwit> aeline: I like your proposed solution.
06:49:46 <dmwit> aeline: You could also write `justWrapper f a b = Just $ f a b`.
06:50:17 <aeline> Ok, I was trying to do something like Just . f but couldn't get it to work out.
06:50:23 <dmwit> aeline: There are many other ways, but this one is simple and instantly readable. Very nice work!
06:51:08 <dmwit> aeline: You can always ask ?pl to work it out for you automatically. When you do, you will see why I highlighted "instantly readable" as a nice feature of your code. =)
06:51:13 <dmwit> ?pl \a b -> Just $ f a b
06:51:14 <lambdabot> (Just .) . f
06:51:19 <dmwit> ?pl \f a b -> Just $ f a b
06:51:20 <lambdabot> ((Just .) .)
06:51:23 <dmwit> yuck
06:51:28 <int-e> fmap . return *runs and hides*
06:51:37 <int-e> (I messed that up even)
06:51:49 <asheshambasta> I seem to have run into a problem: I have a do block in which I write a file at line N; then I have another line N+M where I want to read from this file (or I set off a process that needs to read from this file); what seems to be occuring is that the file is not written at N when its required at N + M 
06:51:50 <xsperry> int-e that is and isn't it?
06:51:59 <dmwit> :t fmap fmap fmap return
06:52:00 <lambdabot> (Functor f2, Functor f1, Monad m) => f1 (f2 a) -> f1 (f2 (m a))
06:52:02 <xsperry> @src and
06:52:02 <lambdabot> and = foldr (&&) True
06:52:06 <xsperry> no it isn't
06:52:08 <int-e> dmwit: right
06:52:25 <xsperry> it uses foldr, not foldl or foldl'
06:52:45 <asheshambasta> what's the best way to "force" evaluation in a do block? 
06:52:59 <dmwit> asheshambasta: How are you writing the file?
06:52:59 <xsperry> int-e, so is your only example actually an example where you'd not use foldl at all, but foldr?
06:53:19 <dmwit> asheshambasta: And what evidence do you have for "the file is not written at N"?
06:54:13 <asheshambasta> xsperry: the file is privisioned at a webroot of my nginx server; and requests to that file with the correct filename are failing. 
06:54:26 <asheshambasta> I'm writing the file using Text.IO's writeFile
06:54:26 <dmwit> asheshambasta: (At a guess: you are using `readFile`, and your evidence is actually showing that "the file is not *closed* at N".)
06:54:32 <xsperry> ???
06:54:32 <dmwit> Sorry, `writeFile`.
06:55:11 <asheshambasta> dmwit: the file is supposed to be read by nginx itself
06:55:21 <asheshambasta> xsperry: hold on, I'll try to explain
06:55:38 <xsperry> asheshambasta are you sure you are directing your messages to me?
06:55:59 <asheshambasta> xsperry: ah sorry, my bad.
06:56:17 <Fobbbb> Hi. I am trying to map a list of [[Maybe CellValue]] ->  [[String]]. I am using list comprehension, but I am getting a type error.
06:56:24 <dmwit> Hm, actually, `writeFile` should close its handle appropriately, only `readFile` does the semi-closed thing.
06:56:32 <dmwit> Okay, I want to see an MVCE.
06:56:35 <Fobbbb> unwrap [a] = [y | y <- [x | x <- map (\v -> fromCellValue $ fromJust v) a]]
06:57:40 <dmwit> Some comments: `[y | y <- e]` is exactly the same as `e`.
06:57:53 <dmwit> You don't need to write brackets around an argument just because its type is a list.
06:58:10 <dmwit> `unwrap [a] = ...` is specifically a pattern match that matches a list with exactly one element.
06:58:26 <dmwit> `unwrap a = ...` is a pattern match that matches any list.
06:58:45 <Fobbbb> OK, so how do I specify that I am working with the inner list
06:59:11 <dmwit> It's unusual to use `map` in a list comprehension. Instead of `[x | x <- map f xs]`, consider `[f x | x <- xs]`.
06:59:17 <asheshambasta> dmwit: here's a simple example of what I'm trying to achieve here https://gist.github.com/asheshambasta/2a07359773fc44f4a557a375c8405a03
06:59:43 <dmwit> (Or just `map f xs`, as in the previous rule that said `[y | y <- e]` is the same as `e`.)
07:00:09 <Fobbbb> so I am working with a list of a list, how do I explicitly say I am working with a inner list
07:00:15 <dmwit> Fobbbb: "The inner list" is a thinko. There are an unknown number of inner lists.
07:00:58 <dmwit> asheshambasta: That is, indeed, minimal; but not complete or verifiable.
07:02:00 <dmwit> Fobbbb: One way to lift a function that operates on list elements to a function that operates on lists is `map`, which I think you already know about.
07:02:04 <dmwit> :t map
07:02:06 <lambdabot> (a -> b) -> [a] -> [b]
07:02:27 <dmwit> Use it twice to operate on doubly-nested lists.
07:02:30 <dmwit> :t \f -> map (map f)
07:02:31 <lambdabot> (a -> b) -> [[a]] -> [[b]]
07:02:55 <asheshambasta> dmwit: here's the full: https://gist.github.com/asheshambasta/f9dad40bbb89000bf4aab3b44dfe967a#file-flow-hs-L169
07:03:10 <xsperry> instead of trying to do this all in a single line, why not write a function that operates on the inner list, and then map that function to the nested list
07:03:10 <hexagoxel> asheshambasta: and the nginx logs say what?
07:03:14 <dmwit> asheshambasta: Now it is likely complete and verifiable, but not minimal.
07:03:53 <asheshambasta> hexagoxel: https://gist.github.com/asheshambasta/f9dad40bbb89000bf4aab3b44dfe967a#gistcomment-2678737
07:05:13 <asheshambasta> something strange is going on here :-( )
07:08:18 <xsperry> int-e do you agree that neither foldl nor foldl' are the right choice there? so while you did find an example where foldl does better than foldl', it isn't an argument against turning foldl into foldl', as we'd not use any variant of foldl there
07:08:46 <int-e> xsperry: I did write that it was an artificial example
07:08:58 <xsperry> sorry, I missed it
07:10:14 <hexagoxel> asheshambasta: there are a ton of potential failure points around your diagnosis so far: you could be writing the wrong file path, have the wrong nginx conf, forgot to catch some exception, ..
07:10:43 <asheshambasta> hexagoxel: yeah
07:11:00 <int-e> xsperry: The point was that this is close enough to natural code to be impossible to grep for, and I believe that using foldl over lists that are known to be short is not uncommon. The other point is that switching the evluation order can have profound impacts on performance.
07:11:08 <asheshambasta> what I also don't understand is the default choice made by the Wreq package to throw errors on statuses >= 400 
07:11:25 <asheshambasta> s/errors/exceptions 
07:12:42 <int-e> xsperry: I'm not inclined to go looking for a real world example, because I do agree that such examples will be rare.
07:12:59 <dvaergiller> asheshambasta: I'd also like an explanation for that. It can be quite annoying when writing tests for example
07:13:56 <asheshambasta> dvaergiller: yeah; and at times when you explicitly forget to specify your options and it'll blow up in your face. It should've been tolerant/safe by default
07:14:58 <asheshambasta> dvaergiller: even the `asJSON :: FromJSON a -> Response ByteString -> Response a` (or similar) throws exceptions.
07:15:25 <xsperry> int-e, I think it is a lot less worse that the code that uses foldl, when it should really be using foldr, breaks, or is slower, than what we have now. (proper uses of left fold being slower, and/or breaking, because ghc is blindly following the standard). having both foldl and foldl' also makes the language appear sloppy to newcomers who are told to always use foldl'
07:16:27 <ph88> i have a question about type system .. can anyone take a look how i can solve these constraints?  https://bpaste.net/show/b63a50853ead  
07:16:34 <dvaergiller> asheshambasta: there isn't really anything that says a 404 should be unexpected or an error scenario anyway. you might want to check for the existence of some entity and then 404 might be a perfectly normal everyday outcome
07:18:09 <asheshambasta> dvaergiller: exactly, most API's I know of use response codes to signal failures that should be handled, going to exception route for Wreq seemed surprising to me
07:18:52 <dmwit> xsperry: I don't really think GHC should be in the business of breaking code just because the GHC authors don't like the style that code was written in.
07:19:08 * dvaergiller made a new friend today
07:19:39 <asheshambasta> dvaergiller: +1
07:20:22 <xsperry> dmwit, at the very least, they should implement functions like sum to work properly always, not only when compiled with certain optimization flags
07:20:53 <Ariakenom> Joined together by their shared hatred
07:21:57 <dmwit> ph88: can't; instead write a `getDefault :: Rule f Prefix => ...` and `instance Rule Gen SelectedName where get = getDefault; instance Rule Prefix SelectedName where get = getDefault`.
07:23:14 <ph88> dmwit, i don't want the implementation from both of these instance to be the same .. i think this will happen if i refer them both to the same function getDefault
07:24:28 <ph88> i want to say    instance Rule f SelectedName where    not for every possible f in the universe but only f is Gen or Parser which is used in my program
07:24:57 <dmwit> Oops, I typo'd. I meant `instance Rule Parser SelectedName`, not `instance Rule Prefix SelectedName`.
07:25:13 <dmwit> ph88: I am confused. I interpreted your paste as "here's the code I want to write but can't". Is that not how it was intended?
07:26:16 <dmwit> In your paste, you gave a single instance for `f/SelectedName` which would be used for both the `Gen/SelectedName` and `Parser/SelectedName` use cases, so I described how to do that without hitting the type error you posted.
07:28:20 <ph88> dmwit, the first 5 lines of the paste is part of the current code   i have also code for line 17 and 19 in my paste
07:28:59 <dmwit> Do you dislike the current code for more reasons than just "it doesn't compile"?
07:29:57 <ph88> dmwit, it's about line 8 the use of the n93 function which needs a   Rule f Prefix ..  but i don't have Rule f Prefix anymore (this was the old situation)  now i want to separate implementation one for   Rule Gen Prefix and one for Rule Parser Prefix
07:30:41 <ph88> dmwit, the old code had a problem with infinitive loop because of left recursion grammer, i had to rewrite this part but i want the generator to stay the way it is
07:31:46 <dmwit> I am thoroughly lost. These two sentences appear contradictory to me: "i have also code for line 17 and 19 in my paste [instances for Rule Gen Prefix and Rule Parser Prefix]" and "i want to separate implementation one for Rule Gen Prefix and one for Rule Parser Prefix [implying you cannot for some reason]".
07:33:07 <ph88> dmwit, the implementation for  Rule Gen Prefix  and   Rule Parser Prefix   is ready (and working) i just didn't put them in the paste
07:33:39 <dmwit> So I repeat my question: do you dislke the code you pasted for more reasons than just "it doesn't compile"?
07:34:20 <ph88> no
07:34:26 <dmwit> Okay. Here's how you fix it:
07:34:56 <dmwit> Define `getDefault :: Rule f Prefix => {- whatever the type of get is -}; getDefault = {- the definition you gave for get in your paste -}`.
07:35:23 <dmwit> Then instead of `instance Rule f SelectedName where ...`, write `instance Rule Gen SelectedName where get = getDefault; instance Rule Parser SelectedName where get = getDefault`.
07:36:00 <ph88> dmwit, i don't want the implementation from both of these instance to be the same .. i think this will happen if i refer them both to the same function getDefault
07:36:43 <dmwit> These two sentences appear contradictory to me: "no [meaning I like the current code, which uses the same implementation for both instances]" and "i don't want the implementation from both of these instances to be the same".
07:36:51 <ph88> ah i see
07:37:44 <ph88> is it not possible to put some kind of constraint instead in pseudo code:    instance (f = gen OR f = Parser) => Rule f SelectedName where    ?
07:37:51 <dmwit> Correct, it is not possible.
07:38:11 <ph88> ok i believe you, i'm curious why it's not possible
07:38:45 <mnoonan> constraint solving doesn't do any backtracking, for one thing
07:39:02 <dmwit> To avoid difficult-to-debug compile-time performance, the instance resolution mechanism was made incredibly simple. The guiding principle is: compiler must never have to choose between two possibilities.
07:39:44 <dmwit> There is no theoretical reason for this, only the practical one I described.
07:40:14 <ph88> ok
07:41:12 <dmwit> The specific one you describe could probably be shoehorned in without breaking this principle.
07:41:15 <dmwit> But it wasn't.
07:42:09 <dmwit> ph88: But I'm being silly.
07:42:13 <dmwit> ph88: The solution is even simpler.
07:42:22 <ph88> i had a feeling about this :p
07:42:33 <dmwit> ph88: Keep everything the same and write `instance Rule f Prefix => Rule f SelectedName where ...`.
07:42:55 <asheshambasta> Anyone else using the Fira Code font for Haskell? 
07:43:37 <ph88> dmwit, instance Rule f Prefix   does not exist in my code
07:43:47 <dmwit> ph88: (I was blinded by the request for `f = Gen or f = Parser`, because this doesn't say that. Anybody could come along later and add another `instance Rule Blah Prefix` later. But you probably don't actually care if that happens.)
07:43:49 <ph88> i think this was already inferred that i need this
07:43:50 <mnoonan> asheshambasta: the only reasonable choice, imo :)
07:44:00 <dmwit> ph88: Try it. =)
07:44:31 <asheshambasta> Yeah its quite a nice font 
07:45:01 <dmwit> ph88: (I know that `Rule f Prefix` does not exist in your code. It isn't required to for this to work.)
07:45:12 <ph88> why is it not required ? i'm puzzled
07:45:23 <ph88> i thought that was the point of these constraints 
07:46:33 * Ariakenom goes into editor settings
07:46:47 <Ariakenom> Oh yeah Fira Code indeed
07:47:49 <dmwit> ph88: If you try to use an instance for, say, `Rule Blah SelectedName`, here is what will happen: 1. GHC will pick the `Rule f SelectedName` instance. 2. GHC will discover that it therefore needs a `Rule Blah Prefix` instance. 3. GHC will discover that it does not know of any `Rule Blah Prefix` instance. 4. Type error.
07:48:39 <dmwit> ph88: On the other hand, if you try to use an instance for `Rule Gen SelectedName`, the process will go 1. GHC will pick the `Rule f SelectedName` instance. 2. GHC will discover that it therefore needs a `Rule Gen Prefix` instance. 3. GHC will notice that you have written a `Rule Gen Prefix` instance and succeed.
07:50:35 <dmwit> ph88: The difference is about when instance resolution for `Rule f Prefix` happens. With `instance Rule f SN`, it happens when typechecking the implementation of `get` and without knowing any details about `f`; with `instance Rule f Prefix => Rule f SN` it happens when trying to find an instance of `Rule f SN` instead and likely already knowing exactly what `f` is.
07:50:42 <mbwgh> Is it possible to compile haddocks in such a way that the "Instances" are not unfolded (that is, they should [+] not [-]) ?
07:52:09 <asheshambasta> speaking of fonts; https://www.slant.co/topics/5611/viewpoints/3/~monospace-programming-fonts-with-ligatures~pragmatapro (yowza, the price)
07:53:30 <mniip> who needs ligatures...
07:55:05 <ph88> thanks for explanation dmwit     I had to put   Rule f Prefix =>    on all my functions in that file because they are circular, but it type checks now !
07:55:21 <mbwgh> If fmap were <et>, I would keep looking for </et> though
07:55:35 * asheshambasta Likes ligatures
07:55:37 <mbwgh> *flip fmap
07:56:14 <monochrom> >>= could use a ligature :)
07:57:01 <asheshambasta> monochrom: https://www.dropbox.com/s/qf8ta3i91xu1mw6/Screenshot%202018-08-14%2016.56.24.png?dl=0
07:57:30 <mbwgh> Just call it flatmap, it's so intuitive
07:57:35 <mniip> monochrom, how do you write >>= on paper
07:57:44 <ph88> with a pencil
07:57:51 <dmwit> You write >>= on paper?
07:58:10 <mbwgh> Pencils are for chumps without confidence
07:58:24 <dmwit> Ok, ok, how do you write >>= on a whiteboard?
07:59:10 <asheshambasta> thats a fair point, actually, whenever I post my code as a gist or something, it looks pretty different 
07:59:23 <asheshambasta> however, when editing code, they're eye-candy
08:00:12 <dmwit> ph88: You know what the shameful part is? I even know what the rest of the error says.
08:00:28 <dmwit> ph88: And the rest of the error says, "write `instance Rule f Prefix => Rule f SelectedName` instead".
08:01:03 <dmwit> ph88: Well. But in that fancy GHC language. Something like "Probably fix: add Rule f Prefix to the instance context".
08:01:13 <dmwit> s/Probably/Probable/
08:01:40 <dmwit> Partfully shame on me, but partfully shame on you for excerpting the error. ;-)
08:01:42 <mniip> dmwit, I write >>= literally as 3 symbols
08:01:49 <monochrom> asheshambasta: Neato!
08:01:57 <mniip> with little to no effort to nest the >> and connect the > with =
08:02:02 <dmwit> mniip: If you can get past all my snarking, so do I.
08:02:08 <mniip> and I totally do not make a gap in the last >
08:02:52 <ph88> dmwit, this was the full original error https://bpaste.net/show/3b1205555a41
08:03:03 <mniip> I can see where you're going >= <= =/ but I'm kinda used to them already
08:03:05 <mbwgh> Does anybody know how to close all the "Instances" tabs in haddocks?
08:03:22 <dmwit> ph88: Huh!
08:03:35 <dmwit> ph88: I could swear I've seen language like what I described above in error messages before.
08:03:40 <dmwit> I wonder why it wasn't triggered here.
08:03:43 <ph88> i've seen it before too
08:03:51 <ph88> when i see this advice i follow it
08:03:54 <mniip> oops I mean /=
08:04:06 <dmwit> ph88: Well, I feel a little less ashamed now, anyway. =)
08:04:33 <dmwit> At least the advice wasn't so easy to come up with that we'd already written the program that could generate it. =D
08:04:48 <ph88> ye
08:10:59 <ph88> anyone know some packages that help with space leak ?
08:12:13 * hackage retry 0.7.6.3 - Retry combinators for monadic actions that may fail  http://hackage.haskell.org/package/retry-0.7.6.3 (MichaelXavier)
08:15:32 <ClaudiusMaximus> anyone want to help me improve the cpu utilisation of my concurrent program?  this is the threadscope view https://mathr.co.uk/tmp/et-cli.png  +RTS -N with 16 cores, using replicateConcurrently_ from async to spawn 16 worker threads that do FFI-based work
08:16:19 <ph88> how do i actually know if i have a space leak or it's valid that the program use much memory ?
08:16:57 <ph88> ClaudiusMaximus, what are your workers waiting for ?
08:17:00 <[exa]> ClaudiusMaximus: well that looks almost singlethreaded to me
08:17:43 <mbwgh> ph88: Have you done a heap-profile and all that jazz?
08:18:01 <ClaudiusMaximus> [exa]: yes.  but the task is embarrassingly parallel (fractal rendering) so something is going wrong.  +RTS -s reports around 300% cpu usage, going from Total   time   45.526s  ( 15.083s elapsed)
08:18:10 <[exa]> ClaudiusMaximus: compile flags?
08:18:14 <ph88> mbwgh, i made this https://imgur.com/a/UEf6L0l
08:20:13 <[exa]> ClaudiusMaximus: also afaik marking the FFIs as interruptible may help with weird schedulers
08:20:30 <ClaudiusMaximus> [exa]: ghc-options: -Wall -threaded -eventlog -rtsopts -with-rtsopts=-N
08:20:30 <[exa]> ClaudiusMaximus: (and regarding the compile flags, doublecheck for -threaded)
08:20:39 <[exa]> hm ok it's there. :D
08:21:05 <[exa]> what is the scheduler that you're using btw?
08:21:52 <mbwgh> ph88: I am pretty sure that you can configure either hp2ps or the ghc runtime to not cut off the names. Both `weigh` and `criterion` can measure allocations too, if are willing to go down the bench route. There's also some package I forgot the name of, that allows creating flamegraphs from profile data.
08:23:09 <ph88> mbwgh, yes i already configured with longer names .. the one that uses so much memory is  https://bpaste.net/show/07acfc094d47
08:23:17 <ClaudiusMaximus> [exa]: scheduler? ghc-8.4.3 with replicateConcurrently_ from async
08:23:23 <mbwgh> ph88: Since this appears to be a long-running program, you may be interested in the ekg package as well. I haven't used it myself, but who knows
08:23:27 <roidusilence> so I'm trying to generate a function for a large sum datatype and thus there would be multiple clauses in my FunD
08:23:39 <roidusilence> can I use the qq syntax to write clauses ?
08:23:42 <roidusilence> if so how ?
08:23:46 <mbwgh> Well, not "long"-running, but you know what I mean
08:24:08 <[exa]> ClaudiusMaximus: afaik that should just work... /me out of ideas, sorry
08:25:20 --- mode: glguy set +v adrice727_
08:25:34 <adrice727_> If anyone is familiar with generating JWTs with jose, I'm running into a malformed token issue and I'm not sure why.  https://gist.github.com/adrice727/db4774aea0fe3711a99a7cd03dc8b2fb.   I'm wondering if it has something to do with this line `( "X-SOME-AUTH", C8.concat $ fmap convertString $ toCompact signedJWT)`
08:26:47 <mbwgh> ph88: I can't tell much from that, but my first intuition would be that there is some dictionary passing going on you may want to avoid. Has ghc given you warnings about missed specializations? Or can you locate the particular code in question in core?
08:26:56 <roidusilence>  etc }
08:27:00 <roidusilence> I was hoping to do : genfuncs name = do { TyConI (DataD _ _ _ _ constructors _) <- reify name; clauses <- forM_ constructors $ mkClause';
08:27:52 <roidusilence> but Im not sure its such a great idea as Im not sure you can quasiquote a clause
08:28:10 <ph88> mbwgh, there were some missing specializations in not-related parts. I haven't looked at Core yet ..    But i think the long line in my paste is the callstack .. where test0 is directly called by main
08:33:45 <roidusilence> nvm
08:38:12 <mbwgh> ph88: When it comes to space leaks, it's best to be familiar with everything https://github.com/ndmitchell/spaceleak and dons have ever written. You may want to throw around explicit scc annotations instead of auto-prof as well, but of course, if test0 = main ...
08:39:19 <Gurkenglas> What should I do if my argument for non has a monadic side effect?
08:41:08 <mbwgh> ph88: Seems nice too http://blog.ezyang.com/2011/06/pinpointing-space-leaks-in-big-programs/
08:43:59 <mbwgh> Gurkenglas: Wouldn't fromMaybe and a named continuation be clearer in that case?
08:50:18 <Gurkenglas> mbwgh, could you expand on that?
08:53:56 <mbwgh> Gurkenglas: I was under the assumption that you were using lens combinator non to return some default element. But of course you may still be able to use non by floating out the monadic action and relying on laziness
08:55:52 <mbwgh> But now that I think of it, that won't work, because of sequencing :/
08:56:10 <Gurkenglas> mbwgh, I am. sequencing should happen to be no problem here
08:57:14 <Gurkenglas> The problem with floating out is that non is applied at every value of a map, and depends on the key
08:57:48 <mbwgh> Ah, ok I think I get it
09:00:02 <mbwgh> My intuition: Not a use-case for non, then, since you would likely break the Iso laws anyway
09:00:23 <dminuoso> When I have a local package under foo/ and I modify it, should new-build pick this up and rebuild/relink?
09:05:04 * dminuoso is confused - now it works..
09:05:45 <hexagoxel> dminuoso: i assume it is listed in your cabal.project? then it should
09:06:11 <dminuoso> hexagoxel: It did once I made an additional modification..
09:06:25 * dminuoso shrugs
09:06:49 <cocreature> dminuoso: have you properly specified all modules? e.g. if you have a module thatâ€™s neither in exposed-modules nor in other-modules cabal wonâ€™t rebuild properly
09:08:33 <dminuoso> cocreature: Ill check again. The only special thing was that the first modification was strictly speaking in dead-code.
09:08:43 <dminuoso> Unless of course new-build is smart enough to figure this out.
09:08:55 <cocreature> depends on what exactly you mean by dead code
09:09:09 <dminuoso> cocreature: It was in a binding my application does not use (not even transitively\)
09:10:18 <cocreature> dminuoso: if itâ€™s in some lib that you donâ€™t use and you build your application (rather than cabal new-build all) then cabal wonâ€™t build it
09:11:18 <cocreature> that also holds if they are in the same package, e.g., you have an executable and a library and you build the executable which does not depend on the lib
09:15:11 <dminuoso> cocreature: fair enough, no idea what happened there. maybe I didnt save my buffer correctly
09:16:58 <hololeap> i'm starting out learning FRP for use in some projects. i'm not sure whether to use reactive-banana or reflex. does anyone have any input on this?
09:26:25 <dminuoso> @tell Axman6 Out of curiosity.. did you ever run your servant-prometheus with an actual prometheus setup?
09:26:25 <lambdabot> Consider it noted.
09:28:34 <kritzefitz> I just saw a thread on Haskell-Cafe asking about a strict version of sum. Isn't sum already strict?
09:29:09 <cocreature> kritzefitz: sum for lists is implemented as a foldl not a foldl'
09:29:22 <cocreature> however, GHC will often optimize it to something equivalent to a foldl'
09:29:32 <dminuoso> kritzefitz: According to the report they are not.
09:29:38 <kritzefitz> I see
09:29:58 <cocreature> but really itâ€™s just silly and should be changed but Iâ€™m not willing to participate in the bikeshedding that would result from trying to do this
09:30:26 <kritzefitz> Are there cases where it makes a semantic difference?
09:30:54 <cocreature> depends on what you mean by â€œsemantic differenceâ€ I suppose :)
09:31:42 <cocreature> in terms of operational semantics, foldl will result in linear memory usage if GHC does not manage to optimize things while foldl' will have constant memory usage (assuming we are summing Int)
09:32:40 <savask> Hello. In my program I use bindings to some external library, and while I have no trouble running the prog with runhaskell, I can't compile it, since the linking step fails with "undefined reference" errors
09:32:41 <kritzefitz> By â€œsemantic differenceâ€œ I meant if sum using foldl' will ever produce a different result from sum with foldl
09:32:52 <savask> Could someone please shed some light on that problem?
09:34:08 <Ariakenom> kritzefitz: if (+) just gives the first number and you have [1,undefined]
09:34:53 <kritzefitz> Ah, yes. I forgot that (+) is overloadable. Silly me.
09:34:57 <cocreature> if you have some weird instance of Num where that is the case, then you probably want a foldr instead of a foldl so I donâ€™t really accept that as an argument for why we should keep sum as foldl
09:35:10 <ClaudiusMaximus> [exa]: found part of the slowdown: replacing a heavily-contended IORef Int with Data.Atomics.Counter gave me a boost from 12.7s elapsed to 1.23s elapsed
09:50:51 <ChaiTRex> Is there some way to use all modules that are installed that start with 'AAA.' (e.g., AAA.Plugin1, AAA.Plugin2, etc.) as GHC plugins?
09:52:02 --- mode: glguy set +v deepfire
09:53:16 <ClaudiusMaximus> [exa]: and the rest of the "low cpu utilisation" seems to have been down to simply "not enough work to do", bumping the image size by 10x10x and it's at 1600% with -N16 on my 16 thread cpu
09:54:08 <bonz060> Hig guys; I'm going through Haskell from first principles. What's the difference between `mod` and `rem`?
09:55:24 <ChaiTRex> bonz060: How it handles negative numbers.
09:55:46 <lavalike> > (7 `mod` (-5), 7 `rem` (-5))
09:55:48 <lambdabot>  (-3,2)
09:56:02 <ChaiTRex> bonz060: div and quot are similarly different.
09:56:19 <lavalike> > (7 `div` (-5), 7 `quot` (-5))
09:56:21 <lambdabot>  (-2,-1)
09:56:46 <ChaiTRex> bonz060: Also, just as an aside, quot and rem are faster if you don't need the specific way div and mod handle negative numbers.
09:57:04 <EvanR> are they? why
09:57:27 <ChaiTRex> They're CPU instructions. div and mod are calculated from quot and rem.
09:57:41 <ChaiTRex> quot and rem are like / and % in C.
09:58:07 <EvanR> and % is ruby seems to act like div and mod
09:58:13 <EvanR> \say / and %
09:58:22 <EvanR> :X
09:58:55 <EvanR> is there some kind of conspiracy to change the way / and % works
10:00:49 <mauke> EvanR: / / and %
10:01:57 <Ariakenom> ChaiTRex: bonz060: Also, just as an aside, div and mod are better if you don't need the speed of quot and rem.
10:02:18 <ChaiTRex> Haha
10:02:45 <bonz060> lavalike: ChaiTRex Thanks a bunch.
10:03:04 <ChaiTRex> bonz060: You're welcome.
10:03:34 --- mode: glguy set -v deepfire
10:04:14 * hackage chronos 1.0.4 - A performant time library  http://hackage.haskell.org/package/chronos-1.0.4 (andrewthad)
10:05:05 <bonz060> ChaiTRex: I've started getting into Haskell. I'm currently reading learnYouAHaskell and Haskell from first principles; in addition to doing challenges on Project Euler/ codewars. Is that a good strategy for levelling up in terms of Haskell skills. I'd like to work in the functional space eventually.
10:07:40 <ChaiTRex> bonz060: I think they're a good start.
10:08:10 <dminuoso> bonz060: You will learn more working on projects than by project euler/codewars.
10:11:18 <c_wraith> also, getting very far in project euler comes from math knowledge, not programming skill.
10:12:18 <dminuoso> and codewars is really hard when you're not already good at the language..
10:12:48 --- mode: glguy set +v blair__
10:12:50 <blair__> https://gist.github.com/blairdrummond/a5f95bd67b9fb44ec507301fe3db76d5
10:12:56 <blair__> https://imgur.com/a/XYBF7Jx
10:13:08 <dminuoso> bonz060: If you want to work in the "functional space eventually", the best you can do is "just start working in it"
10:14:53 <blair__> Sorry, most of the program isn't important. What's important is that I'm reading a 4k file of text and it seems like it's using a disproportionate amount of memory to read that.
10:15:59 <maerwald> using codex/hasktags when I jump to symbols outside of my project I get an error file ~/.stack/indices/.../SomeFile.hs does not exist. How do I generate those?
10:16:09 <blair__> I tried using Data.Text instead of Strings when reading the lines of the file, but as you can see from the images that didn't seem to help. I'm trying to figure out where my getGenomes code and fromText code is getting slowed down
10:16:10 <dminuoso> blair__: I think you might have better luck if you use a bytestring and then translate that into a vector
10:17:15 <blair__> When you say Vector? Is there a Data.Vector or something?
10:17:20 <dminuoso> blair__: Yes. 
10:18:56 <dminuoso> blair__: Also you are naughty for those overlapping Show/Read instances.
10:19:13 <blair__> Haha, yeah, ok, fair enough
10:19:24 <dminuoso> blair__: The existing instances should be good enough. Show/Read are not meant for serializing/deserializing.
10:19:40 <dminuoso> Or rather not the way you mean it to.
10:20:10 <blair__> Yeah, fair enough. I don't have much experience with Haskell, so "when all you have is a hammer"
10:20:42 <blair__> Is that where parsec comes in? (I've heard of it I think)
10:21:13 <dminuoso> blair__: `show` is for producing a valid haskell expression that, when used, produces the same value as you stuff in.
10:21:51 <blair__> Oh ok, fair enough. That's not what I'm doing there at all
10:23:25 <ChaiTRex> You can make show work more like you want by making it output something like "map fromChar \"ATCGTCGGCTG\"". That way it'll be a valid Haskell expression.
10:23:43 <dminuoso> blair__: It's kind of orthogonal to your problem though.
10:24:15 <blair__> Sure, but style pointers are still important. I missed the memo on that - but that's good to know
10:27:43 <blair__> But yeah, any intuition as to how fromText is using up so much memory here? The input file here is 4k
10:28:25 <blair__> It seems weird that handling the text is using *so much* more than that
10:28:41 <noidedsuper> What are you `fromText`ing it to? (Sorry, just came in)
10:28:50 <dminuoso> blair__: Because lists are super inefficient.
10:29:09 <dminuoso> blair__: To see why, imagine list was defined as follows:
10:29:23 <dminuoso> data [] a = Cons a [a] | Nil a
10:29:23 <blair__> A list [Nucleobase] where Nucleobase = A | C | G | T
10:29:52 <EvanR> list is inefficient if used as a data structure, having it materialized in memory
10:30:21 <blair__> Wow eh, is the memory overhead really that bad?
10:30:27 <EvanR> yeah
10:30:27 <dminuoso> blair__: So every single base would be wrapped inside a `Cons` constructor, with a pointer to the rest. A linked list with each element wrapped inside its own box.. =)
10:30:46 <dminuoso> blair__: And lists are defined *exactly* like that. : is just infix Cons, and Nil is just []
10:32:00 <EvanR> but if you are producing and consuming list elements lazily, you have a shot at using way less memory
10:32:05 <blair__> Yeah, I guess that's true eh. It didn't occur to me that the structure itself would occupy so much space though. And it seems weird that that appears in fromText and not factors (which creates a *lot* of lists)
10:32:41 <EvanR> creating is fast, forgetting is fast, but if cons cells start to accumulate in memory, things slow down
10:33:19 <dminuoso> Also lists have double indirection, so it kills cache prefetch
10:33:31 <dminuoso> And it has no locality of reference
10:33:45 <dminuoso> Which means working on them sequentially is not fun.
10:33:51 <blair__> Yeah, and I think I'm handling *most* of the lists lazily. The only ones I want to keep a hold of are the ones off the disk (I might have to change that if I'm reading in large DNA sequences, but for these toy examples they're a few kilobytes at the max)
10:34:14 <EvanR> represent the data from the disk in a ByteString
10:34:23 <EvanR> then always work with that as a source
10:34:36 <blair__> dminuoso: Can you rewind those last three comments? I'm not familar with those ideas
10:34:43 * hackage wai-extra 3.0.24.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.24.1 (MichaelSnoyman)
10:35:33 <dminuoso> blair__: When you access some memory address, its very likely you will request a nearby address.
10:35:37 <noidedsuper> If you're doing DNA data you can theoretically pack each letter into just two bits, giving you a mega-compact representation. Not sure how you'd do that in Haskell and that would probably murder performance if you're inspecting individual letters a lot, but it'll use very little memory
10:35:43 <blair__> EvanR: Hmm. Ok, fair enough, I'll try that. 
10:36:08 <EvanR> you can view a ByteString as a sequence of 2-bit words
10:36:40 <dminuoso> blair__: Usually it is *highly* beneficial to keep data you iterate over together in memory.
10:36:42 <EvanR> or packed sequence of Nucleobase
10:37:07 <dminuoso> blair__: This will keep page and cache misses low, and improve cache prefetching (which is various subsystems trying to predict access patterns and preload data into fetch you are likely to use)
10:37:18 <blair__> noidedsuper: Yeah I was thinking about that. I might try to figure out how to serialize the data to binary later when I start thinking about messing around with bigger datasets
10:37:21 <dminuoso> blair__: lists have their elements spread out in memory, making it rather expensive.
10:38:00 <Eduard_Munteanu> 2 bits can be packed neatly in a byte, i.e. 4 bases per byte.
10:38:34 <dminuoso> A cache line on modern processors is 64 bytes. So if you have a *packed* representation, then you can 256 bases in a L1 cache line with one access.
10:38:38 <dminuoso> L1 cache is incredibly fast.
10:39:17 <noidedsuper> L1 cache on Ryzen is 32 kb and it's the same on Haswell 
10:39:26 <noidedsuper> That's a hell of a lot of DNA base pairs 
10:39:41 <blair__> dminuoso: Ah, ok. Some of that old data-bases stuff is coming back to me. I should probably read up on how that's all implemented. Are there heuristics as to when you allocate consecutive blocks of memory versus distributed? For example, if I wanted to load a gigabyte of text I imagine that loading that as a single range would be hard
10:39:58 <dminuoso> blair__: Not really =)
10:40:07 <noidedsuper> A gigabyte allocation is pretty easy on modern processors. It won't all be in one OS page but you can get contiguous addresses.
10:40:13 <dminuoso> blair__: We have a virtual memory space that is.. well big enough.
10:40:57 <dminuoso> blair__: When you get into high amounts of sequential work being done, you should start with packed representations to leverage cache/page mechanics.
10:41:03 <EvanR>  i think you're skipping ahead right now, first look at Data.ByteString I/O operations instead of standard String ones
10:41:22 <EvanR> it gives you packed bytes back instead of a list of Char
10:41:56 * Eduard_Munteanu thinks it would be nice to have a generic packed string representation
10:42:13 <dminuoso> Eduard_Munteanu: uh.. text? :P
10:42:16 <EvanR> generic?
10:42:18 <noidedsuper> Being able to abstract over the representation would also be really nice
10:42:36 <blair__> Anyone have any reading recommendations on this stuff? I took a few CS classes before switching to a math program (master's student atm). I'm ok with data-strcutures, but I think I don't know much about how things work closer to the metal
10:42:36 <Eduard_Munteanu> Yeah, so you could just use any Storable as a character.
10:43:14 <EvanR> would really help here since you want sub-byte characters
10:43:18 <EvanR> wouldnt
10:43:45 <Eduard_Munteanu> Hm, I guess Storable wouldn't be enough for sub-byte addressing.
10:43:58 <dminuoso> blair__: My personal recommendation is, write a kernel at some point in the future.
10:44:05 <EvanR> haha
10:44:20 <noidedsuper> blair__: Typically, the big things to keep in mind are that memory is really slow unless it's close together, branches are free as long as you can predict them, and you should *always* profile before you start optimizing because what you think is slow is probably gonna be wrong 
10:44:25 <dminuoso> I mean some toy kernel.
10:44:25 <blair__> Hahaha
10:44:26 <maerwald> dminuoso: maybe one that doesn't freeze your system during swapping
10:44:28 <noidedsuper> If you keep that in mind you can get really far 
10:44:39 <maerwald> not sure how linux managed to be the worst kernel wrt swapping
10:44:49 <dminuoso> blair__: Im being serious. It's what I did, and it really helped me to understand _so many things_
10:45:06 <EvanR> solution, never enable swap
10:45:12 <noidedsuper> Getting the dinosaur book and browsing through it is also a decent idea 
10:45:19 <maerwald> EvanR: you buy the ram, yay
10:45:21 <maerwald> thanks
10:45:32 <EvanR> i select which program to OOM kill
10:45:42 <maerwald> it just doesn't happen
10:45:44 <blair__> dminuoso: Haha, fair enough. Maybe I'll give that a try
10:46:09 <blair__> The dinosaur book?
10:46:13 * hackage modern-uri 0.2.2.0 - Modern library for working with URIs  http://hackage.haskell.org/package/modern-uri-0.2.2.0 (mrkkrp)
10:46:21 <dminuoso> blair__: If you should do so, check out #osdev here on freenode. It's a great community, they have good resources. Just be prepared for one might undertaking and reading.. reading.. reading manuals. :o)
10:47:14 <blair__> Haha, that's fine. I'm about the man-page life (or even the "just read the source code life")
10:47:19 <noidedsuper> blair__, https://www.amazon.com/Operating-System-Concepts-Binder-Version/dp/1118129385
10:48:27 <blair__> Solid, thanks
10:49:25 --- mode: glguy set +v emeraldemon
10:49:27 <blair__> Any comments with respect to versions of this book? The 2008 is probably fine eh?
10:49:36 <emeraldemon> Hi
10:49:59 <Eduard_Munteanu> Hi, emeraldemon 
10:50:04 <noidedsuper> 2008 is probably fine, yeah. I have the most recent version because I needed it for class two years ago, but a lot of the fundamentals haven't changed at all
10:50:05 <dminuoso> blair__: Things haven't changed much in the past few years.
10:50:14 <blair__> Cool beans
10:59:11 <blair__> Cool, well thanks for the help folks! I'll give those edits a shot
11:01:55 <deepfire> Is there some reference material on what GHC (8.4 era) flags to enable to improve DWARF/GDB backtraces?
11:07:48 <Gurkenglas> Is there some way to get IO (a -> MVar b) in time smaller than |a|?
11:13:23 <ChaiTRex> blair__: You can speed things up a bit by storing the Nucleobase as a Char internally: https://lpaste.net/5054403722516365312
11:14:43 <dmwit> Gurkenglas: Probably, with some suitable typeclass constraint on `a`.
11:15:15 <ChaiTRex> blair__: Sorry, that got truncated. Here it is: https://lpaste.net/3475061711390638080
11:15:40 <dmwit> Gurkenglas: e.g. for Int you could imagine `unsafeInterleaveIO`ing just two computations, one for those with the top bit set and one for those with the top bit unset, which themselves interleave two computations one each for the possible second bit values, and so on.
11:16:55 <dmwit> I find it odd that you're willing to spend three days on this, though. You could have the ugly and quick thing done in 15 minutes and move on with your life.
11:27:01 --- mode: glguy set +v Boarders
11:27:08 <Boarders> does stack have a command to open localhost when you run stack hoogle --server?
11:27:10 <ph88> which info should i send along for ghc bugreport ?  this info is a bit minimal  https://bpaste.net/show/65c1a44832ed
11:27:44 <dmwit> ph88: As short a program as you can which also prints this error.
11:27:57 <ph88> my program is huge :'(
11:28:31 <blair__> ChaiTRex: Oh, it hadn't occurred to me that it might be faster to just not convert the underlying data-type, but I guess that makes sense
11:30:16 <sm> evening all
11:31:24 <sm> would anyone know a way to get HUnit to output the test labels without erasing each line ? Or do I need to switch to tasty for that ?
11:34:23 <ph88> Boarders, maybe make an alias in your shell
11:52:27 --- mode: glguy set +v MarcelineVQ
11:52:29 <MarcelineVQ> "<hololeap> i'm starting out learning FRP for use in some projects. i'm not sure whether to use reactive-banana or reflex. does anyone have any input on this?" no one with an opinion? what do you think conal_, which of these do frp better/truer?
11:52:56 * Clint squints.
11:59:43 * hackage gas 0.0.0.1 - Limit how many steps a program may take.  http://hackage.haskell.org/package/gas-0.0.0.1 (rightfold)
12:03:14 <johnw> MarcelineVQ: what's your goal? commercial success? just getting it going? mastering the semantics?
12:04:06 <hololeap> bonz060: i found these challenges helpful to learn haskell, but like others said, i would pair them with your own personal projects: https://www.hackerrank.com/domains/fp
12:04:53 <MarcelineVQ> Currently I'm just bringing attention to hololeap's question, but I do have an interest in using frp to develop applications for automated trading
12:05:41 <johnw> I know that reflex is being used successfully at Obsidian Systems
12:05:53 <johnw> I know less about how others are using reactive-banana
12:06:02 <deepfire> Is GHC's eventlog useful/can be made useful in case of crashes?
12:06:18 <MarcelineVQ> I hope it is, they make reflex hehe :>
12:07:09 <deepfire> I want to try to use eventlog to trace allocation/use/release of foreign objects, to debug segfaults.
12:07:31 --- mode: glguy set +v zincy
12:07:39 <deepfire> But I'm not sure how synchronous it is..
12:07:39 <zincy> How do I apply the first and second elements of a tuple to an argument to a binary function? I have a list of tuples.
12:07:46 <ChaiTRex> MarcelineVQ: I recently heard of https://hackage.haskell.org/package/streamly, which claims to allow FRP.
12:07:59 <MarcelineVQ> did you hear about it from me?
12:08:10 <ChaiTRex> MarcelineVQ: I don't know. It was on the Haskell reddit.
12:08:14 <MarcelineVQ> oh no then
12:08:26 <MarcelineVQ> I had mentioned it in here recntly, and have been playing with its tutorial
12:08:33 <ChaiTRex> Ahh, OK.
12:08:35 <dmj`> ChaiTRex: streamly copies vectorâ€™s internal type for streaming
12:08:48 <ChaiTRex> Ahh, that's probably a good thing.
12:08:54 <dmj`> and appends to it a data type that holds a lot of concurrency primitives (IORef, etc.)
12:09:06 <dmj`> ChaiTRex: yea, thatâ€™s why itâ€™s destroying the other streaming libraries
12:09:41 <zincy> so [(50,"bob")] -> Person   where Person is a record of { age :: Int, name:: String }
12:10:01 <dmj`> ChaiTRex: data Stream m a = forall s. Stream (s -> m (Step s a)) s is from vector
12:10:38 <dmwit> zincy: uncurry
12:10:38 <ChaiTRex> Ahh, OK.
12:10:44 <ChaiTRex> zincy: uncurry Person (50, "bob")
12:11:03 <dmj`> ChaiTRex: and this is streamly data Stream m a = forall s. Stream (State K.Stream m a -> s -> m (Step s a)) s
12:11:38 <dmj`> low-hanging fruit
12:11:48 <dmj`> ChaiTRex: Iâ€™d watch out for async exceptions though, with streamly that is
12:12:33 <ChaiTRex> OK, I'll be careful of that.
12:13:08 <MarcelineVQ> There's little issues still like exception propogation not quite working, specifically if you use fail to stop a program and expect all your streams to quit. This is a tutorial example so it's a little odd to be at issue
12:13:37 <MarcelineVQ> rather  examples/AcidRain.hs
12:14:01 <zincy> :t uncurry
12:14:02 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:14:04 <zincy> Thanks!
12:16:11 <MarcelineVQ> zincy: more basically there's pattern matching    \(x,y) -> Person x y      uncurry packages this up by letting you supply any function instead of specifically Person
12:17:15 <zincy> Thanks
12:17:17 <zincy> :)
12:20:02 <zincy> How do you match on nested records such as Person {.., Cat {..} } 
12:20:02 <dmj`> ChaiTRex: I just donâ€™t know why it doesnâ€™t use async
12:20:34 <ChaiTRex> zincy: \(Person a b (Cat c d)) ->
12:23:35 <zincy> ah yes need the cat =  in there
12:23:45 <dmj`> let Person { cat = Cat {..}, .. } = person
12:24:18 <dmj`> let Cat {..} = person ^. cat 
12:24:53 <nitrix> Hi guys, I was wondering yesterday, why does Haskell needs a garbage collector? It seems to me like it'd be the perfect language to do copy-on-write, not share or mutate memory, no pointers, none of that.
12:25:21 <nitrix> The excuse that comes up often is closures, but I don't think that's true.
12:26:18 <nitrix> What's wrong a closure that copies the variables in scope from the environment into its own scope. Everyone owns their own memory, it just gets freed normally, no GC.
12:26:30 <ChaiTRex> nitrix: Here's a Stack Overflow thing on it: https://stackoverflow.com/a/9953741/7208029
12:26:42 <dmj`> nitrix: you might get better answers in #ghc
12:28:10 <chessandgo> although im not very knowledgeable about it
12:28:20 <chessandgo> nitrix: linear types can get around needing a GC for somethings
12:28:33 <chessandgo> although theyre not in haskell and are very much "cutting edge"
12:31:45 <dmwit> nitrix: ...that's not copy-on-write, it's copy-on-closure-creation.
12:32:09 <nitrix> dmwit: My thoughts are a bit all over the place, but yes, that's just one more example.
12:32:11 <dmwit> Adding a copy to every closure creation seems like it would get pretty memory-intensive (and slow) pretty easily.
12:32:30 <dmwit> Basically every function call would potentially have to create a completely fresh copy of all its arguments. Ouch.
12:33:37 <nitrix> On write.
12:34:21 <dmwit> No, because you need to know when to free, and your proposed mechanism for that was "everybody is responsible for their own memory and frees it normally, no GC".
12:34:41 <dmwit> My function can't free its arguments normally unless it's copied them (or otherwise knows that its caller doesn't use those arguments again).
12:35:53 <nitrix> Your function does not free its arguments unless it made of copy, in which case, it's escape analysis.
12:35:58 <nitrix> *a
12:37:20 <nitrix> That's fine, that's the caller's role to determine this. The caller knows it passed the information to your function and can't free it until the function returns, at which points it knows the function is done using said data, or can assume it made a copy of it if it wants to modify it or persist.
12:37:42 <merijn> nitrix: What if I store a partially applied function in a data structure?
12:38:23 <nitrix> merijn: So, you have a partially applied function. I don't see the issue. When the data structure goes away, so does the partial function.
12:38:26 <ab9rf> merijn: how dare you do that
12:38:39 <zachk> nitrix, how would you know when to free something shared between threads like an MVar?
12:38:50 <merijn> nitrix: Yeah, but you said you weren't gonna store the data in the close (i.e. partially applied function)
12:39:08 <merijn> nitrix: So where are you gonna leave it then? Can't leave it with the caller, because there is no caller yet/anymore
12:39:12 <nitrix> merijn: I see.
12:39:27 <merijn> nitrix: Can't store it in the close, because you just said we weren't going to, to avoid massive copying slowdown
12:39:41 <merijn> s/close/closure
12:40:03 <nitrix> merijn: Yeah, but in this case, the compiler has all the information about which arguments were provided and what should and shouldn't be deallocated :/
12:40:18 <merijn> Does it?
12:40:29 <ab9rf> this vaguely reminds me of all the c++ progarmmers who tell me that "you wouldn't need garbage collection if you just had smart pointers like c++"
12:40:51 <merijn> ab9rf: You can get quite far with C++ smart pointers, tbh
12:41:39 <ab9rf> merijn: sure but you can't get *everywhere*, and a lot of environments that use a GC also use something like C++ smart pointers, precisely to reduce GC load
12:42:08 <merijn> ab9rf: When all you've got is a hammer...
12:42:29 <ab9rf> merijn: and you've never seen anything that wasn't a nail
12:42:46 <emeraldemon> nitrix: Seems like the only reasonable solution is to write your own haskell compiler
12:43:26 <ab9rf> you could probably build a haskell implementation that did a lot less GC, and maybe even one that didn't need to do GC at all, but you'd be making tradeoffs to do so
12:43:50 <nitrix> emeraldemon: I've been thinking about it for months now.
12:44:00 <nitrix> emeraldemon: Because I can't verbalise my idea.
12:44:01 <emeraldemon> Go for it!
12:44:14 <ab9rf> really, give it a try
12:44:21 <ab9rf> the worst that can happen is that you fail
12:44:25 <ab9rf> :)
12:44:31 <mnoonan> you don't even need to do a big chunk of the work, "just" core -> executable
12:45:09 <nitrix> I think in my mental model, the closure would know which arguments are boxed and unboxed, you discard both similarly, except the boxed ones are potentially used elsewhere so to avoid sharing nightmares that leads to GCs, you have copy-on-write.
12:45:23 <emeraldemon> You could either write a mini-compiler from scratch, or fork ghc and mess with it
12:45:47 <dolio> What is writing?
12:46:04 <dmwit> I don't even think you'd have to do a Haskell.
12:46:24 <dmwit> You could easily start with an untyped lambda calculus + lazy let or something to make it a smaller project.
12:46:28 <nitrix> dolio: Actually, it'd be writing, or, escapes the lifetime of that function.
12:46:36 <dmwit> ...or a fully-typed one, if you thought that would make it easier.
12:46:47 <dolio> What does writing mean?
12:46:52 <nitrix> dolio: Mutating.
12:47:24 <nitrix> Which Haskell doesn't really do, idiomatically, so it shouldn't be a big deal :/
12:47:58 <dolio> Well, good implementations do write over stuff.
12:48:12 <dolio> You overwrite suspended computations with their value.
12:48:19 <dolio> To avoid re-doing work.
12:48:39 <merijn> hmmm, slightly annoying that xml-conduit doesn't have a nice way of collecting up multiple values/axis in one traversal...
12:48:43 * hackage haskell-postal 0.2.1.1 - Haskell binding for the libpostal library  http://hackage.haskell.org/package/haskell-postal-0.2.1.1 (netom)
12:48:48 <dmwit> Oh, good point. This is a tricky part of the "just copy everything everywhere" thing, too.
12:48:52 <nitrix> I'd probably make a couple language changes too. Possibly no ability to tie a knot, or may even get rid of the lazy evaluation/memoization because that's also sharing.
12:49:07 <dmwit> If you copy before a thunk is forced, you may have forced yourself to redo that work.
12:49:22 <dolio> Okay, so now you're really slow. :)
12:49:51 <nitrix> I know what both of you are thinking, but is it really?
12:50:01 <emeraldemon> Hmm, is there a standard benchmark for garbage collectors?
12:50:57 <emeraldemon> For small or fast-ish programs no GC might well be optimal
12:51:22 <nitrix> Other eager languages have been working this way for many years. I find it easier to reason about. Get a result from a function call, store the result in a variable, like monomorphic restriction does, except not how GHC messes up the type signature.
12:52:12 <nitrix> I don't know, I aware I'm just rambling and I sound like an old man, so yeah. The answer as expected is to implement it to know.
12:52:28 <ab9rf> there's no question that haskell's lazy evaluation makes reasoning about performance or memory usage harder
12:52:28 <abueide> how do i map read to [["1", "2", "3"], ["3", "2", "1"]]
12:52:36 <nitrix> I'm almost sure the road will lead to linear types.
12:52:45 <abueide> would it be map . map read
12:52:52 <ab9rf> :t map . map read
12:52:54 <lambdabot> error:
12:52:54 <lambdabot>     â€¢ Couldn't match type â€˜[b0]â€™ with â€˜a -> bâ€™
12:52:54 <lambdabot>       Expected type: [String] -> a -> b
12:52:54 <glguy> No, map (map read)
12:53:10 <glittershark> :t (map . map) read
12:53:11 <lambdabot> Read b => [[String]] -> [[b]]
12:53:14 <dolio> I mean, certainly there's a reason why no one uses call-by-name for real languages.
12:53:20 <abueide> or map read . map $ someString :: [[char]]
12:53:39 <danso> what do you mean that question? map . read 
12:53:52 <danso> are you trying to map to the outer list or the inner? 
12:54:00 <abueide> i want to map read to the inner list
12:54:12 <danso> those are already strings
12:54:16 <glguy> > fmap fmap fmap read [["1", "2", "3"], ["3", "2", "1"]] :: [[Int]]
12:54:19 <lambdabot>  [[1,2,3],[3,2,1]]
12:54:19 <abueide> i want the streangs to be numbers
12:54:26 <Ariakenom> start from inside and work out 
12:54:27 <abueide> i want [[char]] -> [[Int]]
12:54:29 <dolio> Pretty much every call-by-value language has GC, too, though.
12:55:17 <dolio> Also, JHC tried to do without GC, but it didn't actually work.
12:55:19 <ab9rf> i've written haskell programs that use amazingly small amounts of memory
12:55:22 <danso> (map . map) read $  [["1", "2", "3"], ["3", "2", "1"]] :: [[Int]] 
12:56:35 <dolio> And if you're going to start talking about linear types and whatnot, then it seems like the answer is that, no, Haskell isn't the ideal language for this, because you have to add stuff to it to make things actually feasible.
12:56:52 <danso> on the subject of performance, is there a reason why GHC implements typeclasses by passing dictionaries at runtime? 
12:57:03 <glittershark> it doesn't always danso 
12:57:12 <danso> i don't know much about type inference, but it seems like that should be resolvable at compile time
12:57:19 <glittershark> there's an optimization pass called "specialization" that will make them resolve at compile time
12:57:28 <glittershark> it's a tradeoff between binary program size / compilation time and performance
12:57:28 <geekosaur> because typeclasses can lead to polymorphic recursion, which can only be resolved by runtime information
12:57:34 <glittershark> also that
12:57:47 <geekosaur> consider a Show instance that works by deferring to the Show instance for a contained tyoe
12:57:50 <nitrix> geekosaur: Example on top of your head?
12:58:03 <nitrix> Gotcha
12:58:19 <danso> ah, so it isn't decideable 
12:58:27 <danso> i was wondering whether that was the case
12:58:45 <geekosaur> if it is possible to resolve them at compile time, ghc will do so, but it's not always possible and then you need to fall back to dictionary passing
12:59:13 * hackage self-extract 0.3.4 - A Haskell library to make self-extracting executables  http://hackage.haskell.org/package/self-extract-0.3.4 (brandonchinn178)
12:59:13 <dolio> Well, it might not figure them out, even if it's possible.
12:59:29 <dolio> Depending on how hard you make it.
13:00:17 <danso> actually, i don't fully understand why that scenario shouldn't be resolvable at compile-time, geekosaur 
13:00:24 <geekosaur> or whether doing so could cause other problems (recursion in general is difficult)
13:00:42 <geekosaur> because it's hard to tell when to stop unrolling
13:01:18 <dolio> Resolving them at compile time is in opposition to separate compilation.
13:01:57 <dolio> (In general.)
13:03:14 <Cale> TODO: Write a program which uses instance specialisation or lack thereof to solve Sudoku puzzles, making any changes to GHC required in the process.
13:03:29 <danso> the problem is that the type might be infinitely recursive? 
13:04:55 <lavalike> would that leverage the equivalent of C++'s SFINAE
13:05:43 * hackage foldable1 0.1.0.0 - Foldable types with at least 1 element  http://hackage.haskell.org/package/foldable1-0.1.0.0 (MatthewFarkasDyck)
13:05:46 <danso> or is the problem with instances like either
13:05:50 <danso> instance (Show a, Show b) => Show (Either a b) where 
13:05:54 <dolio> danso: foo :: Show a => Int -> a -> String ; foo 0 x = show x ; foo n x = foo (n-1) (x,x)
13:08:25 <Cale> danso: Yeah, the problem is that as soon as you have a polymorphic instance like that, you effectively have infinitely many potential instances, and then polymorphic recursion can actually make use of an infinite number of them.
13:08:47 <Cale> (as dolio's example shows)
13:09:27 <abueide> k i cant get it to work. if I need a function that is ([Char], [Char]) -> ([Int], [Int]) it would be (map . map) read correct?
13:09:51 <glguy> No, map is for lists, not for tuples
13:09:52 <Cale> abueide: (\(x,y) -> (read x, read y)) ?
13:10:13 <abueide> (fmap . map) read ?
13:10:15 <Cale> Or, well, did you want to turn single Char values into Ints?
13:10:26 <dminuoso> abueide: You shouldn't want to use read.
13:10:27 <Cale> fmap only affects the second element of a pair
13:10:33 <dmwit> Ariakenom: Okay, I have to ask my question about bringing type variables into scope for @ again, because now the trick you taught me with _ doesn't do what I want.
13:10:44 <Cale> :t fmap
13:10:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:10:54 <Cale> Imagine plugging in f = (,) t
13:11:06 <Cale> you get (a -> b) -> (,) t a -> (,) t b
13:11:13 <Cale> i.e. (a -> b) -> (t, a) -> (t, b)
13:11:32 <abueide> I just want to turn the stdin "3 2 1\n1 2 3" into ([3, 2, 1], [1, 2, 3])
13:11:36 <abueide> i can't get it to work
13:12:07 <dmwit> % :t coerce @(Compose _ _ _ -> Compose _ _ _ {- I want a here -}) @([[String]] -> [[_ {- I want a here -}]]) (fmap read)
13:12:08 <yahb> dmwit: forall k (w1 :: k -> *) (w2 :: * -> k) w3 w4. (Coercible (w1 (w2 w3)) [[w4]], Coercible (w1 (w2 String)) [[String]], Functor (Compose w1 w2), Read w3) => [[String]] -> [[w4]]
13:12:16 <dminuoso> >> (traverse . traverse) readMaybe [["1", "2", "3"], ["3", "2", "1"]] :: Maybe [[Int]]
13:12:21 <Cale> > map (map read . words) . lines $ "3 2 1\n1 2 3"
13:12:23 <lambdabot>  [[*Exception: Prelude.read: no parse
13:12:23 <dminuoso> > (traverse . traverse) readMaybe [["1", "2", "3"], ["3", "2", "1"]] :: Maybe [[Int]]
13:12:26 <lambdabot>  error:
13:12:26 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe Int
13:12:31 <dmwit> Ariakenom: Don't suppose you have a fancy trick for connecting two _'s like that...?
13:12:33 <Cale> > map (map read . words) . lines $ "3 2 1\n1 2 3" :: [[Int]]
13:12:35 <lambdabot>  [[3,2,1],[1,2,3]]
13:12:40 <dminuoso> @let import Text.Read
13:12:42 <lambdabot>  Defined.
13:12:48 <dminuoso> > (traverse . traverse) readMaybe [["1", "2", "3"], ["3", "2", "1"]] :: Maybe [[Int]]
13:12:50 <lambdabot>  Just [[1,2,3],[3,2,1]]
13:12:54 <Cale> (of course, you probably do want to use something like readMaybe)
13:13:05 <dminuoso> In which case it would be traverse rather than map.
13:13:10 <Cale> I don't like using traverse for that though, just use mapM :P
13:13:27 <lavalike> :t traverse
13:13:28 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:13:31 <abueide> thank you cale
13:14:00 <Gurkenglas> Should there be a view pattern ALens such that "ALens l = a" => "l = cloneLens a"?
13:14:13 <dminuoso> > let r = (traverse . traverse) readMaybe in (r . words . lines) "3 2 1\n1 2 3"
13:14:15 <lambdabot>  error:
13:14:15 <lambdabot>      â€¢ Couldn't match type â€˜Charâ€™ with â€˜[Char]â€™
13:14:15 <lambdabot>        Expected type: String -> [[String]]
13:14:30 <fragamus> So Const is both a Functor and a Contravariant and so when all the laws are applied both fmap and contramap canâ€™t use their argument   Right?
13:14:37 <Cale> Lately I've been finding people using a lot of code which is general to the point that it's annoying to read -- whenever I see traverse, I imagine that for some reason we actually care about the Applicative generality.
13:14:43 <Gurkenglas> (is view pattern the right word?)
13:14:48 <dminuoso> fragamus: That's parametricity.
13:14:49 <Cale> (same goes for 'pure' which actually annoys me even more)
13:14:51 <dminuoso> fragamus: because:
13:14:53 <dminuoso> :t fmap
13:14:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:15:06 <dminuoso> fragamus: The implementation has to be ready to work for *all* possible choices of `a` and `b`
13:15:44 <Gurkenglas> ...looking for something that lets me turn the ALens into a Lens at the creation site
13:16:26 <fragamus> So contramap f someConst === phantom
13:17:34 <glittershark> Gurkenglas: pattern synonym maybe?
13:17:40 <dminuoso> fragamus: Not quite phantom.. `contramap _ (Const a) = Const a
13:18:00 <glittershark> well `contramap = const coerce`
13:18:19 <dminuoso> glittershark: You dont need that really.
13:18:28 <dminuoso> :t coerce
13:18:29 <lambdabot> error:
13:18:29 <lambdabot>     â€¢ Variable not in scope: coerce
13:18:29 <lambdabot>     â€¢ Perhaps you meant â€˜coercedâ€™ (imported from Control.Lens)
13:18:31 <glittershark> my point is that it's got a phantom type role
13:18:40 <glittershark> :t Data.Coerce.coerce
13:18:41 <lambdabot> Coercible a b => a -> b
13:19:06 --- mode: glguy set +v bas_
13:19:19 <bas_> This is probably a bit of a beginner question but if I want the fmap definition of Maybe
13:19:39 <dminuoso> bas_: lookup `Maybe` in hoogle
13:19:43 <bas_> yes
13:19:48 <bas_> that is the type signature
13:19:50 <bas_> but https://github.com/ghc/ghc/blob/master/libraries/base/Data/Maybe.hs
13:19:56 <glittershark> there's a `source` link usually
13:19:58 <glittershark> at the right
13:19:59 <bas_> how would I find the actual implementaion 
13:20:00 <dminuoso> bas_: go to the defining module in base, go to instances, there under "Functor Maybe" there is a link on the right named Source
13:20:16 <dminuoso> bas_: That's the usual pattern. :)
13:23:03 <bas_> ah that is cool dminuoso 
13:25:27 <bas_> is there a way to do something like say a data D a = X a | Y x | Z a 
13:25:53 <bas_> and then to have a function that takes a D a and have only one implementation to get to the a?
13:25:58 <ab9rf> bas_: what is 'x'?
13:26:01 <bas_> instead of having to match X Y en Z
13:26:24 <bas_> X Y and Z are contexts for a
13:26:35 <ab9rf> bas_: you said "Y x", did you mean "Y a"?
13:27:07 <bas_> pardon me, yes!
13:27:24 <abueide> can some one give me some advice on how to improve my code (make it more readable, better approach etc)
13:27:26 <abueide> https://pastebin.com/YMK0rQ8r
13:27:35 <abueide> https://hackerrank-challenge-pdfs.s3.amazonaws.com/21400-compare-the-triplets-English?AWSAccessKeyId=AKIAJ4WZFDFQTZRGO3QA&Expires=1534281906&Signature=1B9SDMkIvOb9T0SXgRnJFPMEAbg%3D&response-content-disposition=inline%3B%20filename%3Dcompare-the-triplets-English.pdf&response-content-type=application%2Fpdf
13:27:41 <abueide> ^^ that was the problem i was solving
13:28:17 <bas_> I understand I can just destructure all the D's in my example, but if you have more than three that get's annoying pretty fast
13:29:18 <ab9rf> bas_: i have a sense that you might be able to do that with something out of lens, but i won't swear to it. i don't understand lens that well.
13:30:01 <bas_> aha
13:30:29 <dmwit> bas_: `data D a = X { getA :: a } | Y { getA :: a } | Z { getA :: a }`
13:30:58 <mnoonan> it feels so wrong :|
13:31:08 <dmwit> bas_: Or `data Tag = X | Y | Z; data D a = D { tag :: Tag, val :: a }`
13:31:24 <dmwit> bas_: Or keep your declaration and write `getA (X a) = a; getA (Y a) = a; getA (Z a) = a`.
13:31:50 <bas_> dmwit of all those I feel the third is the closest
13:31:59 <mnoonan> bas_: you might be fine with just deriving Foldable / Traversable / Functor for whatever you want to do
13:32:00 <ab9rf> you could probably use template haskell to "accelerate" writing lots of getA cases
13:32:13 <bas_> hahaha
13:32:25 <mnoonan> @let D a = X a | Y a | Z a deriving (Functor, Foldable, Traversable)
13:32:25 <lambdabot>  Parse failed: Parse error: |
13:32:37 <mnoonan> @let data D a = X a | Y a | Z a deriving (Functor, Foldable, Traversable)
13:32:38 <lambdabot>  .L.hs:165:1: error:
13:32:38 <lambdabot>      Multiple declarations of â€˜Dâ€™
13:32:38 <lambdabot>      Declared at: .L.hs:160:1
13:32:41 <bas_> ab9rf, that is a rather heavy weapon for the use case
13:32:56 <ab9rf> bas_: i enjoy killing flies with sledgehammers
13:32:57 <mnoonan> @let data Bas a = X a | Y a | Z a deriving (Functor, Foldable, Traversable)
13:32:59 <lambdabot>  Defined.
13:33:10 <zachk> bas_, maybe you just want something that reads as this type (Tag,a) ? 
13:33:48 <ab9rf> if 'a' is some sor tof auxiliary data, i'd be really tempted to use the tagged tuple approach
13:34:19 <bas_> ab9rf, hahaha I started haskell 2 months ago and I am writing a Chess AI so that in and of itself is a challenge, templatehaskell might be a bit too much for now
13:35:24 <zachk> bas_ have you seen I believe it is barbossa? its a haskell chess engine
13:35:39 <ab9rf> bas_: fair enough. i've been programming in haskell for about six years now and template haskell still scares me
13:35:47 <dmwit> abueide: `check = filter (\(l, r) -> l > r)`, or `check = filter (uncurry (>))`
13:36:08 <bas_> Ah nice zachk However, I do not want to look at it right now
13:36:30 <bas_> I enjoy the "coming up with original ideas" at this phase
13:36:44 <bas_> ab9rf, hehe exactly
13:36:52 <mnoonan> > map (foldr1 const) [X 1, Y 2, Z 3]
13:36:54 <lambdabot>  [1,2,3]
13:37:41 <ab9rf> bas_: there's not necessarily a Right Way to do what you're asking about; trying different ones and see which works best for you may be informative to your learning process :)
13:37:42 <dmwit> mnoonan: And you have the audacity to tell me my record solution feels wrong??
13:37:59 <mnoonan> :)
13:38:14 <mnoonan> the den of sin up in here
13:38:42 <zachk> mnoonan, how does that even work? 
13:39:02 <ab9rf> zachk: he defined D to have a Foldable instance
13:39:02 <abueide> dmwit, i don't quite get what uncurry does from google
13:39:18 <ab9rf> :t foldr1 const
13:39:19 <dmwit> abueide: I'd probably also write something like `score [alice, bob] = [length . check $ zip alice bob, length . check $ zip bob alice]`.
13:39:19 <abueide> maybe i should learn what currying is
13:39:19 <lambdabot> Foldable t => t b -> b
13:39:36 <dmwit> abueide: It's just a shorthand for transforming `f` to `\(a,b) -> f a b`.
13:39:39 <dmwit> ?src uncurry
13:39:40 <lambdabot> uncurry f p = f (fst p) (snd p)
13:40:08 <dmwit> Okay, the Haskell Report writers were more careful than me. It's even better than turning `f` to `\(a,b) -> f a b`.
13:43:05 <dmwit> abueide: I understand that this is just a quick-and-dirty piece of code, so this is probably not a consideration.
13:43:17 <dmwit> abueide: But the existing code uses partial functions a lot.
13:43:41 <dmwit> abueide: If I were doing it, and it weren't intended to be thrown away within an hour of completing it, I'd want to be more careful about error handling.
13:44:05 <dmwit> abueide: Other than these things I think your basic approach and style are both fine.
13:44:25 <abueide> thanks I appreciate the advice
13:45:02 <abueide> uncurry is cool
13:46:07 <bas_> mnoonan, what? I love how this language makes me feel like a wizard
13:48:44 * zachk puts on his wizard robe and hat 
13:49:08 <EvanR> but ... where are my beams
13:49:20 <mnoonan> come to think of it, the const is a red-herring here..
13:49:33 <mnoonan> > map (foldr1 (error "haha")) [X 1, Y 2, Z 3]
13:49:40 <lambdabot>  [1,2,3]
13:49:56 <ab9rf> oi.
13:50:23 <dmwit> > map (foldr1 (+)) [X 1, Y 2, Z 3] -- the "I hate my coworkers" version
13:50:27 <lambdabot>  [1,2,3]
13:50:36 <dmwit> :t sum
13:50:37 <lambdabot> (Num a, Foldable t) => t a -> a
13:50:43 <dmwit> Oh, it's already suitably polymorphic.
13:50:48 <dmwit> :t head -- ?
13:50:49 <lambdabot> [a] -> a
13:51:05 <ab9rf> oh, duh
13:51:17 <dmwit> too bad
13:51:26 <ab9rf> it's because the second argument to foldr1 is never used
13:51:49 <dmwit> No, the first argument is never used. For *this* Foldable, anyway.
13:51:57 <ab9rf> sorry, yes, first
13:52:08 <zachk> :t foldr1
13:52:10 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
13:52:21 <ab9rf> all that matters is that it typechecks
13:52:23 <dmwit> > [X 1, Y 2, Z 3] >>= toList
13:52:26 <lambdabot>  error:
13:52:26 <lambdabot>      Ambiguous occurrence â€˜toListâ€™
13:52:26 <lambdabot>      It could refer to either â€˜F.toListâ€™,
13:52:31 <dmwit> > [X 1, Y 2, Z 3] >>= F.toList
13:52:33 <lambdabot>  [1,2,3]
13:52:50 <ab9rf> > map (folder1 negate) [X 1, Y 3, Z 2]
13:52:52 <lambdabot>  error:
13:52:52 <lambdabot>      â€¢ Variable not in scope:
13:52:53 <lambdabot>          folder1 :: (Integer -> Integer) -> Bas Integer -> b
13:52:58 <ab9rf> bah
13:53:02 <ab9rf> autcorrectfingers
13:53:08 <ab9rf> > map (foldr1 negate) [X 1, Y 3, Z 2]
13:53:10 <lambdabot>  error:
13:53:11 <lambdabot>      â€¢ Occurs check: cannot construct the infinite type: b ~ b -> b
13:53:11 <lambdabot>        Expected type: b -> b -> b
13:53:18 <ab9rf> ooh, wasn't expecting an occurs check
13:53:25 <dmwit> > map maximum [X 1, Y 2, Z 3]
13:53:27 <lambdabot>  [1,2,3]
13:53:34 <dmwit> ab9rf: The argument isn't used, but it still has to have the right type.
13:53:40 <dmwit> :t foldr1
13:53:41 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
13:53:42 <ab9rf> dmwit: yes, that was what i was trying to demonstrate
13:54:00 <ab9rf> i was expecting a type mismatch, but not an occurs check
13:54:53 --- mode: glguy set +v alproxy
13:55:36 <alproxy> It seems interesting and I can't find it via a google search
13:55:46 <ab9rf> alproxy: what does?
13:55:51 <dmwit> alproxy: You'll have to repeat the  first message you tried to send to the channel.
13:56:02 <alproxy> Ohh..
13:56:03 <alproxy> Hi, can anyone point me to a link to the GSoC work by Andrew Knapp on 'Parallel Automatic Differentiation'(https://summerofcode.withgoogle.com/projects/#6711125681373184)
14:05:02 <shapr> alproxy: it's not easy to find
14:06:04 <alproxy> Yes, I can't find anything related to that
14:06:33 <shapr> alproxy: I was hoping to  find a blog link on https://summer.haskell.org/news/2018-04-23-accepted-projects.html
14:06:35 <shapr> but no
14:06:59 <alproxy> Maybe I should tag the mentors here
14:07:02 <alproxy> @edwardk @aloiscochard[m]
14:07:02 <lambdabot> Unknown command, try @list
14:07:11 <alproxy> edwardk aloiscochard[m]
14:37:18 <monochrom> That was quite a thread in haskell-cafe on "why oh why Prelude doesn't have strict sum".  Anyone want to start a sequel thread on "why on why Prelude doesn't have Text" too? >:)
14:42:54 <hpc> why oh why Prelude doesn't have JuicyPixel
14:43:43 * hackage lsp-test 0.2.1.0 - Functional test framework for LSP servers.  http://hackage.haskell.org/package/lsp-test-0.2.1.0 (luke_)
14:44:56 <Cale> Has anyone actually had that be the performance problem with a real non-contrived program?
14:45:28 <monochrom> Haha hpc
14:47:42 <Cale> Text vs. String is very often a real issue, but Either having lazy fields?
14:47:48 <monochrom> OK actually I wasn't being fair.  The original question did not insist on Prelude; it asked where on hackage you find import strict sum, in hope of not reinventing the wheel.
14:48:24 <monochrom> But inevitably it always drifts off to attacking Prelude.
14:48:30 <chessandgo> isnt JuicyPixel a graphics library
14:48:38 <Cale> yes
14:48:40 <chessandgo> I heard Rasterific was native haskell
14:48:45 <chessandgo> although maybe im mixing those us
14:49:07 <chessandgo> I try not using bindings when I can use a more comfortable native interface
14:54:57 <nan`> i'm trying to understand this paper, they have a language of types and i am trying to understand the unification algorithm. The terms are defined like this:
14:54:57 <nan`> > data Type v = TVar v                 -- Type variable
14:54:57 <nan`> >             | TInt                   -- Integer type
14:54:57 <nan`> >             | Fun (Type v) (Type v)  -- Function type
14:55:00 <lambdabot>  <hint>:1:1: error: parse error on input â€˜dataâ€™
14:55:00 <lambdabot>  <hint>:1:1: error: parse error on input â€˜|â€™
14:55:00 <lambdabot>  <hint>:1:1: error: parse error on input â€˜|â€™
14:55:16 <ab9rf> please don't paste code :)
14:55:26 <nan`> Ok sorry. My question is: what is any example of a function can i construct?
14:56:53 <nan`> basically they are showing how monads can be used for substitution in this type language, and unify for functions unifies the left hand sides, then unifies with resulting subst on right hand sides, then returns composition of both substs. But i just don't get the language.
14:57:47 --- mode: glguy set +v adad
14:58:17 <adad> If I have (a -> Either [err] val) and [a], can I use traverse to collect/mappend the [err] to return Either [err] [val]?
15:13:11 <chessandgo> is there a way to use a normal Maybe function within a MaybeT transformer stack
15:13:47 <chessandgo> ive got a pure function that returns a Maybe ByteString, and id like it to be flattened 
15:14:00 <chessandgo> otherwise I have to asum a Maybe Maybe ByteString
15:14:54 <Cale> Apply the MaybeT constructor?
15:16:03 <chessandgo> ill look into that
15:20:26 <Cale> chessandgo: You might also use something like  maybe mzero return
15:20:33 <Cale> :t maybe mzero return
15:20:34 <lambdabot> MonadPlus m => Maybe a -> m a
15:21:45 <hvr> :t maybe empty pure
15:21:46 <lambdabot> Alternative f => Maybe a -> f a
15:22:25 <Cale> I'm pretty sure that the Alternative and MonadPlus instances are the same for MaybeT
15:22:41 <Cale> But yeah, you can also do that :)
15:22:56 * hvr thought we were code-gulfing and I was able to safe 2 characters
15:23:02 <chessandgo> havent used a MonadPlus before, ill have to look into it
15:23:33 <Cale> :t MaybeT
15:23:34 <lambdabot> error:
15:23:34 <lambdabot>     â€¢ Data constructor not in scope: MaybeT
15:23:35 <lambdabot>     â€¢ Perhaps you meant variable â€˜maybeâ€™ (imported from Data.Maybe)
15:24:12 <Cale> Applying the MaybeT data constructor will be the most concise thing to do if you have, say, an IO (Maybe a) and you want a MaybeT IO a
15:24:47 <Cale> However, it doesn't generalise to other choices of monad -- your monad has to be exactly MaybeT applied to something in order for that to work.
15:25:43 <Cale> mzero and empty are generalisations of MaybeT (return Nothing)
15:26:01 <olle_> hello and good evening. does haskell have reflection? e.g. looking up a function from a string?
15:26:42 <chessandgo> let me just post the function im trying to fix
15:27:53 <Cale> olle_: No
15:28:44 <olle_> Cale: ok
15:28:49 <Cale> olle_: However, you can of course construct a Map String (Foo -> Bar)
15:29:01 <olle_> right
15:29:08 <olle_> Cale: can you do the same with modules?
15:30:08 <Cale> What would the type of the operation you want be?
15:30:25 <olle_> Cale: put in a string, get a module as return value.
15:30:32 <Cale> Modules aren't values
15:30:38 <olle_> ok
15:30:38 <fsestini> olle_: modules arenâ€™t first-class
15:30:44 <olle_> got it
15:30:59 <Cale> You can use ghc as a library
15:31:23 <Cale> For a handy frontend to that, you might want to try something like the 'hint' library
15:31:38 <Cale> http://hackage.haskell.org/package/hint-0.8.0/docs/Language-Haskell-Interpreter.html
15:32:04 <Cale> That'll let you load code at runtime and extract arbitrary things from it
15:32:17 <olle_> Cale: ok!
15:32:41 <Cale> Note also that if compiled .o/.hi files exist, it can load those instead of interpreting
15:32:41 <olle_> Cale: is that possible with compiled, too?
15:32:46 <olle_> ah
15:32:53 <olle_> thank you!
15:33:44 <hpc> the .o file is the compiled output
15:33:50 <olle_> yes
15:33:52 <hpc> the .hi file is information that lets you know the names and types of things
15:33:59 <hpc> so... yes
15:34:09 <olle_> ok
15:37:56 <madnight> pandocs syntax highlighting does not support elm, thus if you write a blog that renders md -> html with pandoc (like hakyll) you get no highlighting, suggestions?
15:40:57 <barrucadu> madnight: I didn't particularly like pandoc's highlighting, and have my blog shell out to pygments.  I don't know if that does elm, though
15:41:40 <barrucadu> But if you do want to call another highlighter, here's how I did it: https://github.com/barrucadu/memo.barrucadu.co.uk/blob/master/hakyll.hs#L122
15:44:30 <madnight> barrucadu: alright i'll check that out then
15:47:51 --- mode: glguy set +v Guest65966
15:49:47 <Guest65966> let's say you need a massive piece of functionality, like parts of a game engine
15:50:00 <Guest65966> you can create classes for it
15:50:15 <Guest65966> and make these classes talk to each other
15:50:29 <Guest65966> is functional programming just a massive list of functions?
15:50:43 * hackage alg 0.2.6.0 - Algebraic structures  http://hackage.haskell.org/package/alg-0.2.6.0 (MatthewFarkasDyck)
15:52:52 <Cale> Guest65966: I don't understand. No?
15:53:43 <Guest65966> what i understand of FP is it looks like this:
15:53:59 <Guest65966> pure functions, no side effects, avoid shared state
15:55:15 <Guest65966> so x -> x-> x-> x-> x-> x-> x , you take argument, transform it and pass to next function which changes the argument and pass to next function
15:55:30 <Guest65966> or you compose a bunch of functions 
15:55:50 <Guest65966> but still, the result of that calculation you pass on to another function
15:55:56 <Cale> Sure, a lot of functional programming involves writing and composing together functions
15:55:57 <davean> Oh, but at the trivialized level thats also what assembly does
15:56:03 <Cale> which manipulate all sorts of data
15:56:14 <chessandgo> sorry, back, something needed my immediate attention
15:56:18 <davean> every assembly instruction can be considered a function call - so I don't see that as a very interesting view
15:56:41 <Guest65966> im a bit new to programming, in a dillema
15:56:50 <chessandgo> assembly can mutate global state
15:56:56 <Guest65966> starting to belive OOP might be wiser for me
15:56:56 <chessandgo> so theyre not quite that pure
15:58:44 <chessandgo> Cale: this is the function im trying to fix https://pastebin.com/CSND5bws
16:02:42 <pie_> i was told something like i can put a data declaration in a typeclass, but im not sure what was actually meant by this
16:03:11 <hpc> probably data families
16:03:35 <pie_> ok thanks ill take a look
16:11:03 <zachk> > join (Just (Just 5)) -- chessandgo ! 
16:11:05 <lambdabot>  Just 5
16:41:23 <libscott> if i want to make alot of types for strings of different lengths (Str1, Str2, Str3 etc), is there any type level trick that can make this easier?
16:42:03 <dolio> Index by a natural number?
16:43:01 <hpc> ^
16:43:15 <hpc> you'd make basically a sized list type, and then put Chars in it
16:43:43 <hpc> foo :: SizedList 3 Char; foo = "foo"
16:44:03 <hpc> (++) :: SizedList n a -> SizedList m a -> SizedList (n + m) a; (++) = you get the point :D
16:44:22 <hpc> some IsString in there for the literals too
16:45:12 <libscott> but i can't indicate the size in a type signature using that
16:45:21 <Squarism> Maybe im too green to see the way around it, but I really miss mocking from from Java. Sure i can make my IO fkns return typeclass constrained monadic values. But what about all other values you toss around. Say I have Big datastructures with strict fields, theres no other way than hammering 20 fields of "undefined" to construct them. A simple test that could be small becomes huge because of all setup.
16:45:33 <libscott> ie parseThing :: SizedList 3 -- no
16:46:21 <hpc> libscott: the size is the number in the type
16:46:27 <hpc> you can use a type variable too
16:46:48 <hpc> that's how (++) would be able to not care how long your lists are
16:47:07 <libscott> ðŸ¤”, type variable
16:47:46 <libscott> Right but i can't specify a SizedList 3 in a type signature that way
16:48:11 <hpc> i mean, if you know parseThing produces a 3-sized list you could
16:48:17 <libscott> Maybe I can do a trick where I have `type SizedList 3 = SizedList (SizedList (SizedLeaf))`
16:48:17 <abueide> has anyone had experience with building android apps? should I just end up using kotlin while using the style i've learned from haskell
16:51:27 <Cale> abueide: We build android apps at Obsidian
16:52:03 <Cale> abueide: You might want to try reflex-platform and/or obelisk, which contain our recipes for android support
16:52:06 <Cale> (and iOS)
16:52:25 <abueide> oh your from obsidian
16:52:30 <abueide> cool
16:57:30 <abueide> are there any substantial apps that are open source built with reflex-platform so I can learn how to design a good frontend Cale 
17:12:59 <dmwit> libscott: Why can't you specify a SizedList 3 in a type signature?
17:17:09 <dmwit> chessandgo: You might like `canlogin <- runMaybeT $ do { ...; guard (rehash == hash); return uuid }; return canlogin`. And then you can apply the Monad law `do { canlogin <- act; return canlogin } = do { act }` to simplify even further.
17:18:05 <Axman6> dminuoso: I can't actually remember, one of our teams is using it in one of their apps but I don't remember if they ever got prometheus running
17:19:48 <chessandgo> dmwit: does that remove the extra maybe?
17:20:22 <dmwit> yep
17:21:03 <chessandgo> monadic laws can combine a Maybe with a MaybeT?
17:21:27 <dmwit> Nope. I did that before applying the monad law.
17:21:52 <dmwit> Specifically: you had `return Nothing` and `return (Just uuid)`. I have `return uuid`.
17:22:17 <chessandgo> ah, I think im starting to get it now
17:22:25 <chessandgo> so I remove the if and use guard?
17:22:35 <dmwit> You can do it with an `if` if you prefer that.
17:22:46 <dmwit> `if rehash == hash then return uuid else empty`
17:23:18 <c_wraith> that's making my skin crawl without context - I really hope hash isn't user input.
17:23:20 <chessandgo> what import empty? monadPlus? 
17:23:31 <dmwit> ?index empty
17:23:31 <lambdabot> Control.Applicative, Data.Binary.Builder, Data.ByteString.Lazy, Data.ByteString.Lazy.Char8, Data.ByteString, Data.ByteString.Char8, Data.ByteString.Short, Data.IntMap.Strict, Data.IntMap.Lazy, Data.
17:23:32 <lambdabot> IntMap, Data.IntSet, Data.Map.Lazy, Data.Map.Strict, Data.Map, Data.Set, Data.Sequence, Text.PrettyPrint.HughesPJ, Text.PrettyPrint.HughesPJClass, Text.PrettyPrint, Language.Haskell.TH.PprLib
17:23:37 <chessandgo> nice
17:23:40 <dmwit> ...the first one
17:24:38 <chessandgo> should that be else return empty
17:24:41 <chessandgo> or just else empty
17:25:28 <dmwit> I wrote what I meant.
17:25:56 <chessandgo> ive gotten the code working now, but now i have some questions
17:26:10 <dmwit> (I admit that it's not always so. But it was this time.)
17:26:27 <chessandgo> I thought every statement of an if had to use a return (if you where using it in that way), so that the types all match
17:26:37 <chessandgo> and if return is thought of being putting soemthing back into a context
17:26:42 <chessandgo> is empty already in that context?
17:26:50 <dmwit> It is true that the types of the branches of an if must match.
17:26:56 <c_wraith> chessandgo, please reassure me that `hash' is not user input.
17:27:00 <dmwit> It is not true that every branch of an if must use a return.
17:27:16 <dmwit> return is just one of many possible monadic actions.
17:27:25 <chessandgo> c_wraith: its a salted hash of a password pulled from a database
17:27:52 <chessandgo> yeah, but if you use return in one branch of an if, dont you need it in both, otherwise the types wont match
17:28:02 <dmwit> > if True then return 4 else [72]
17:28:04 <lambdabot>  [4]
17:28:09 <dmwit> > if False then return 4 else [72]
17:28:10 <lambdabot>  [72]
17:28:23 <dmwit> See? No `return` in the other branch. Just an expression of the right type.
17:28:37 <chessandgo> I seem to have misunderstood how if works
17:28:46 <geekosaur> return is not control flow
17:28:59 <chessandgo> I know, but its putting something back into a monadic context
17:29:04 <geekosaur> in this case, it sees [a] as the type, so the monad is []
17:29:13 <geekosaur> % :t return @[]
17:29:14 <yahb> geekosaur: a -> [a]
17:29:36 <dmwit> chessandgo: What is the "it" in "its [sic] putting something back into a monadic context"?
17:29:42 <c_wraith> chessandgo, ah, should be fine then. (APIs that use MACs to authenticate access often allow timing attacks in the comparison of the calculated and passed MAC values)
17:30:32 <chessandgo> c_wraith: at one point it was user input as someone registered an account, but it was hashed with the argon2 libarary, which I hope protects against timing attacks
17:30:34 <dmwit> chessandgo: `if` is completely Monad-agnostic. There is no language interaction between `if` and `Monad` (except perhaps for a funny interaction between `if` and the layout rules which apply to `do` blocks).
17:31:13 <gobby> Hey guys I can't get the websockets library to work for me. I can get the websocket to work on websocket.org/echo but it gives me an error when I try it via the websockets library
17:31:17 <chessandgo> return doesnt change the type of an ifs branch?
17:31:19 <gobby> This is my code: https://pastebin.com/EGJn6vka
17:31:28 <dmwit> chessandgo: Sure it does. Why do you believe it doesn't?
17:31:38 <geekosaur> it did, it changed a type a to a type [], because the context said it was using a list
17:32:17 <chessandgo> ive just been thinking with the rule: "if one uses return, the other needs to use return, since a context is a type, and one branch without the context wouldnt be the same type"
17:32:21 <MarcelineVQ> examine the parts of dmwit's example closesly, use ghci to help you if you can
17:32:23 <geekosaur> nope
17:32:26 <c_wraith> chessandgo, the vulnerable portion is (==), but only when one of the inputs is under attacker control. you've described salted hashes such that the user can't predict what will be passed as either argument
17:32:27 <dmwit> > [return 4, [72, 73]]
17:32:28 <geekosaur> it doesn;t care how you got a list
17:32:29 <lambdabot>  [[4],[72,73]]
17:32:30 <geekosaur> it's a list
17:32:41 <dmwit> chessandgo: But the other branch *does* have a monadic type. It just doesn't use `return`.
17:32:45 <geekosaur> return here produces a list, because that's the type needed and lists have a Monad instance
17:33:04 <dmwit> chessandgo: You seem to be stuck on thinking that `return` is the only way to get a monadic type. But it ain't.
17:33:04 <geekosaur> it cares not how it got there, just that the types match at the end
17:34:05 <dmwit> chessandgo: It's like saying "if one branch of the `if` uses `(&&)`, then the other branch must also use `(&&)`, because they both have to return a `Bool`".
17:34:32 <dmwit> chessandgo: Although it's true that if one branch returns a `Bool`, the other must also, it simply isn't true that `(&&)` is the only way to make a `Bool`.
17:34:47 <chessandgo> so in the case of:
17:34:49 <chessandgo> if True then return 4 else [72]
17:35:00 <chessandgo> return puts the 4 in the context of the [] monad
17:35:08 <chessandgo> while else [72] just gives the whole context
17:35:20 <dmwit> Okay, sure.
17:35:26 <geekosaur> right. and the only point it cares about that context is deciding what variant of return to use
17:35:37 <geekosaur> which it gets from seeing the other "leg" produces a list
17:35:59 <geekosaur> which fixes the Monad context for return as [], whih has such an instance, so it's happy
17:36:27 <dmwit> (In the `[72]` case it chooses which variant of return to use by looking at the other leg. In the case chessandgo is actually using, it's more complicated.)
17:36:37 <geekosaur> another way people get this wrong is
17:36:39 <geekosaur> > do 4
17:36:41 <chessandgo> I think im getting it now, this should be pretty obvious based on how return and functions work, but ive never actually had to do soemthing like this
17:36:41 <lambdabot>  4
17:37:16 <geekosaur> "do" doesn't require a Monad right off, either, it just translates some things to operators that want a Monad context. but if you don;t use those things, it doesn't care
17:37:29 <chessandgo> isnt do just all syntax sugar anyways
17:37:35 <geekosaur> yes
17:37:44 <dmwit> > do { let { x = 5 }; x }
17:37:46 <lambdabot>  5
17:37:51 <gobby> anybody familiar with websockets in haskell?
17:38:12 <chessandgo> not amazingly so, but im using them
17:38:13 <c_wraith> > do ()
17:38:15 <lambdabot>  ()
17:38:31 <gobby> chessandgo: I think my problem is simple
17:38:34 <chessandgo> gobby: I have import Network.WebSockets as WS
17:38:46 <libscott> dmwit: Expected a type, but â€˜3â€™ has kind
17:38:55 <gobby> I can get the websocket to work on websocket.org/echo but it gives me an error when I try it via the websockets library
17:38:55 <chessandgo> but the library doesnt work with async exceptions, as i found otu myself a while ago
17:38:56 <gobby> This is my code: https://pastebin.com/EGJn6vka
17:39:01 <gobby> oh
17:39:08 <gobby> hmm
17:39:24 <dmwit> libscott: Either turn on PolyKinds, or turn on KindSignatures and tell it your argument is a Nat and not a *.
17:39:41 <chessandgo> dmwit: back to my actual code, if hash == rehash then return uuid else empty
17:39:53 <chessandgo> is empty the "nothing" of the MaybeT transformer?
17:39:55 <dmwit> libscott: `data FancyList (a :: Nat)` with `KindSignatures`, e.g.
17:40:01 <chessandgo> because if I replace empty with Nothing it doesnt compile
17:40:13 <marvin2> :t do { let { x = 5 }; x }
17:40:14 <lambdabot> Num p => p
17:40:19 <dmwit> chessandgo: Yes, it is the "nothing" of the MaybeT transformer. You can replace it with `MaybeT Nothing`.
17:40:40 <dmwit> chessandgo: Oops, `MaybeT (return Nothing)`.
17:40:44 <dmwit> chessandgo: https://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control.Monad.Trans.Maybe.html#line-146
17:40:53 <chessandgo> what do you recommend. I could do that and have one less import, but, 
17:41:17 <dmwit> chessandgo: I recommend `guard` as in my first reply.
17:41:48 <dmwit> chessandgo: And pressing the button you have configured in your editor to put `import Control.Applicative` at the top of your file.
17:41:58 <dmwit> chessandgo: Because that goes in *every* file. =)
17:42:15 <chessandgo> im using neovim ;)
17:43:13 * hackage hw-prim 0.6.2.6 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.6 (haskellworks)
17:44:14 <dmwit> chessandgo: Here, have some bits of my .vim/ftplugin/haskell.vim: https://lpaste.net/5193608796605251584
17:44:32 <dmwit> "il" = "import list"
17:44:45 <libscott> dmwit: thx 
17:45:06 <chessandgo> ha, im suprised you actually have all that for your vim
17:45:17 <chessandgo> I only really have a command to compile a document when writing latex
17:45:24 <dmwit> chessandgo: Oops, I forgot to include my iabbrev HI import =)
17:45:58 <dmwit> If you call those few lines "all that", I'm going to blow your mind: my haskell.vim is 308 lines long.
17:46:19 <suzu> so i've got this strange issue and i'm looking for advice on how to debug it
17:46:29 <fragamus> > fmap show negate 3
17:46:31 <lambdabot>  "-3"
17:46:46 <suzu> if have an operation that looks like this: { x <- async ...; b <- async ...; waitBoth a b; do more stuff }
17:47:03 <suzu> this works just the way i'd expect. runs two things in parallel and waits for the results
17:47:11 <dmwit> (Well, okay, most of that is autogenerated from GHC output... but about 100 lines of it are hand-written. =)
17:47:15 <suzu> when i run it a _second_ time though, one of those actions doesn't start
17:49:22 <suzu> how do i find out wtf is going on
17:49:44 <chessandgo> are you running the ghci
17:49:55 <chessandgo> because ^c ing ghci wont kill other threads
17:49:59 <chessandgo> theyll still be running
17:50:19 <chessandgo> and if your threads are using locks or waiting on some resource
17:50:23 <suzu> no, this is a compiled executible
17:50:28 <suzu> yes, i am using locks and waiting on resources
17:50:42 <chessandgo> are you killing the threads and thus the lock never releasing
17:50:50 <suzu> but those are recreated within each operation and don't exist between runs of this operation
17:51:06 <chessandgo> hm
17:51:15 <dmwit> chessandgo: I suppose he's probably using the async package, which is pretty careful about doing exceptions right.
17:51:21 <suzu> i am using async, yes
17:51:57 <dmwit> Although your guess does sound like a good one, even in the context of async.
17:52:35 <dmwit> suzu: I hate to sound like a broken record, because I feel like I give this advice a lot, but... time to produce an MCVE.
17:52:43 <suzu> what is an MCVE?
17:52:49 <chessandgo> dmwit: another stupid question, but is there something like a monad but with out mzero, like just from semigroup instead a monoid
17:52:50 <dmwit> Minimal, complete, verifiable example.
17:53:10 <aarvar> chessandgo: Bind?
17:53:11 <suzu> that will be very difficult for me to extract
17:53:23 <dmwit> Yes, debugging is indeed very difficult.
17:53:27 <suzu> hehe
17:53:41 <suzu> so i am going to whittle away at my application code until i can find the problem
17:53:45 <dmwit> chessandgo: Monad doesn't have mzero.
17:53:55 <suzu> and i am asking what kinds of things should be on my mind as i'm trying to debug this
17:54:08 <suzu> and perhaps if there are any tools or compiler flags that'll let me remove some nondeterminism
17:54:10 <aarvar> chessandgo: if you mean without pure/return, there's http://hackage.haskell.org/package/semigroupoids-5.3.1/docs/Data-Functor-Bind.html#t:Bind
17:54:39 <chessandgo> yeah, isnt pure/return the mzero concept from monoids
17:55:04 <aarvar> it's the unit, yes
17:55:28 * dmwit squints
17:55:59 <dmwit> Okay, yes, pretty much.
17:56:03 <dmwit> But you mean mempty, not mzero. =P
17:56:19 <chessandgo> hmm, thats interesting
17:56:58 <chessandgo> I was thinking it might have to do with comonads because from what Ive read is that theres no way to get a value "into" one, and lacking a mempty, which means lacking a pure/return...
18:03:13 * hackage axel 0.0.1 - The Axel programming language.  http://hackage.haskell.org/package/axel-0.0.1 (jgrosso256)
18:12:38 <doomrobo> I'm getting a super weird build error on the network package on my MBP. It happens for 2.6.3.6-2.7.0.0.2. I download a fresh copy from Github, switch the resolver to lts-12.5, and then do a stack build. The error I get is that network.buildinfo had an unexpected character (0x1e record separator). Anyone have any ideas?
18:25:29 <glguy> doomrobo: haven't you looked inside that file to see what's going on? Can you reproduce it without stack?
18:26:33 <glguy> Have you*
18:30:00 <tmarsh> I'm back again.. I was working on a Bits instance with a configurable precision (a la C++'s std::bitset<n>), but hit a snag...
18:30:32 <tmarsh> The Bits class has a function `bit :: Int -> a`, but my values can't be created with just an Int, they need some more information.
18:31:18 <Cale> What more information?
18:32:16 <tmarsh> The additional information is the precision.
18:32:31 <acowley> It should be in the type
18:33:01 <tmarsh> I'm a bit new at this, trying to figure out how I can provide a constant at the type level.
18:33:24 <acowley> instance KnownNat n => Bits (BitSet n) where ...
18:34:00 <tmarsh> Oh, that's really interesting. Thanks for the lead!
18:34:53 <ChaiTRex> How do you extract the type literal to a value literal at runtime?
18:35:05 <ChaiTRex> Or a value
18:35:06 <acowley> natVal or natVal'
18:35:13 <ChaiTRex> Ahh, thanks.
18:35:43 * hackage hw-prim 0.6.2.7 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.7 (haskellworks)
18:36:11 <acowley> A bit sad that there isn't a natVal variation that expects the use of TypeApplications as that's how you'd write it today.
18:38:15 <tmarsh> Is it not bad form to rely on GHC internal modules? The description on hackage says "The programmer interface for working with type-level naturals should be defined in a separate library."
18:40:10 <doomrobo> glguy, this is the file. It does indeed have an 0x1e at the specified location
18:40:11 <doomrobo> https://bpaste.net/show/831fd5cba5c8
18:41:41 <acowley> tmarsh: It's not ideal, but it's the current state of play. Sometimes GHC moves things around, but basic KnownNat usage like this has been pretty stable.
18:52:58 <doomrobo> If I have a typeclass method that's generic over 'a' and I want to reference 'a' (say, for casting) in an instance of the class in another module, how do I do that?
18:53:22 <doomrobo> currently, I'm just copying the methods type signature in the class instance and it works, but it's kinda clunky
18:54:01 <tmarsh> acowley: is there a good example of the KnownNat usage? I added the context to my instance, but the usage of natVal is a bit of a mystery. Some out of context usage I saw uses natVal (Proxy @ n), which doesn't pass the parser.
18:54:52 <acowley> That's TypeApplications, I'd write this the old-fashioned way and say (Proxy::Proxy n).
18:55:56 <acowley> Or you can accept more GHC internals and use `(proxy# :: Proxy# n)` for possibly slightly better performance.
18:56:43 <acowley> tmarsh: If your code is up somewhere, I'm happy to phrase it using the right names for your situation.
18:57:22 <glguy> To avoid the potential function overhead without GHC internals, just use Data.Tagged.Tagged
18:57:25 <acowley> doomrobo: What's the type of the method?
18:58:09 <acowley> glguy: with natVal?
18:58:20 <tmarsh> That's quite generous. My code is here: https://github.com/thomasmarsh/renju/blob/master/src/BitBoard.hs#L66-L68
18:58:58 <glguy> acowley: No, not for natVal. I didn't read far enough back
18:58:59 <doomrobo> acowley, here's the code. https://bpaste.net/show/64ea8c0844eb
18:59:10 <doomrobo> the casting is done on the first line of the let
18:59:26 <acowley> tmarsh: You have too many unknown types in the context
18:59:35 <tmarsh> That's WIP code based on your feedback, not compiling. It's actually 2 dimensions, a width and a height, which affect the precision. So, instance (KnownNat h, KnownNat w, ...) => Bits (BitBoard a) where .. 
19:00:26 <acowley> doomrobo: I think you're doing it exactly right
19:01:06 <doomrobo> acowley, hmm alrighty. thanks!
19:01:12 <acowley> tmarsh: You really need the dimensions to appear in BitBoard's type
19:01:53 <tmarsh> acowley: I just hit my wall of understanding. What do you mean by too many unknown types. So, it should be something like Bitboard h w a instead of what I have?
19:02:05 <acowley> tmarsh: exactly!
19:02:23 <tmarsh> Okay, I'll give that a shot!
19:02:24 <acowley> tmarsh: And you can then drop the `Size` part of the newtype, I think
19:02:44 <acowley> tmarsh: If these are statically known quantities, then you want them as part of the type rather than values of that type.
19:02:46 <tmarsh> Oh, but then I can't have a context on a newtype, right?
19:02:53 <acowley> tmarsh: Just like a template argument in C++
19:03:21 <acowley> tmarsh: Where do you want to put a context?
19:04:53 <tmarsh> acowley: newtype BitBoard h w a = (KnownNat h, KnownNat w) => BitBoard a
19:05:13 * hackage axel 0.0.2 - The Axel programming language.  http://hackage.haskell.org/package/axel-0.0.2 (jgrosso256)
19:05:18 <acowley> tmarsh: you don't need to put them there, just leave them on the instance as you've written it
19:05:19 <ab9rf> axel F?
19:05:41 <acowley> tmarsh: Then, callers will write, Bits (BitBoard a) => BitBoard a -> ...
19:06:06 <acowley> tmarsh: Satisfying that Bits (BitBoard a) constraint will demand the KnownNat constraints on your Bits instance
19:08:21 <acowley> ab9rf: All outputs are piped into an axel-f.mid file
19:10:15 <acowley> tmarsh: Something I'd also think about is if a particular a is big enough for the w and h you have. This is a bit more involved, as you want to say something like (w*h <= BitSize a) for some type function BitSize, or you want to automatically select an 'a' given a w and an h.
19:10:28 <tmarsh> acowley: I expected 'BitBoard a' to have kind * -> * -> * for the three parameters (h, w, and a)
19:10:45 <tmarsh> acowley: the compiler doesn't like instance (KnownNat h, KnownNat w, Bits a, Num a) => Bits (BitBoard a)
19:11:27 <acowley> tmarsh: newtype BitBoard h w a = BitBoard a; instance (KnownNat h, KnownNat w, Bits a, Num a) => Bits (BitBoard h w a) where ...
19:12:29 <tmarsh> acowley: okay that matches my understanding better. I'm getting another error with that usage, but I'm going to try and figure it out on my own. :)
19:18:13 * hackage axel 0.0.3 - The Axel programming language.  http://hackage.haskell.org/package/axel-0.0.3 (jgrosso256)
19:28:20 <tmarsh> acowley: this is an exciting refactor for me. It's taking a while, so I'll go ahead and profusely thank you now.
19:29:09 <acowley> tmarsh: I'm really glad I was able to help!
19:55:11 <tmarsh> acowley: if you're still there, I'm having a problem with ambiguous type variables: https://pastebin.com/pd1Ebx55
19:55:58 <tmarsh> I'm trying to follow some example code fairly closely and came up with that minimal example.
20:01:12 <tmarsh> This is a more minimal implementation, along with error message: https://gist.github.com/thomasmarsh/0fdbf3a045e516a5143249aef64b4f5c
20:28:15 <tmarsh> Okay, I think I fixed my example. I needed {-# LANGUAGE ScopedTypeVariables, PolyKinds, DataKinds, RankNTypes, MagicHash #-}
20:41:56 <buhman> I end up writing code like: "q a b = f (g a) (g b)". It seems like pointfree should also be possible, but I'm not sure how.
20:42:37 <tmarsh> Not very readable, though, unless you like "q = (. g) . f . g"
20:43:14 * hackage hw-simd 0.1.0.3 - SIMD library  http://hackage.haskell.org/package/hw-simd-0.1.0.3 (haskellworks)
20:46:06 <buhman> tmarsh: hmm yeah, I think my objective is more to only write "g" once
20:55:39 <dmwit> buhman: f `on` g
20:56:22 <dmwit> > on f g 3 4
20:56:24 <lambdabot>  error:
20:56:24 <lambdabot>      â€¢ Could not deduce (Show b0) arising from a use of â€˜fâ€™
20:56:24 <lambdabot>        from the context: FromExpr c
20:57:05 <buhman> > on (<>) show 3 4
20:57:07 <lambdabot>  "34"
20:57:09 <buhman> nice
21:06:32 <suzu> :t on
21:06:33 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:07:32 <buhman> I ended up implementing "Ord b => (a -> b) -> a -> a -> Ordering" with that, which of course already exists
21:07:44 <buhman> https://www.haskell.org/hoogle/?hoogle=Ord+b+%3D%3E+%28a+-%3E+b%29+-%3E+a+-%3E+a+-%3E+Ordering interestingly `on` is in the same search result
21:29:24 <dmwit> Yes. I am sad that there is no `equating`.
21:37:51 <mniip> hmm, if I have a natural isomorphism between Hom(X, -) and Hom(Y, -)
21:38:03 <mniip> does that mean the exists a natural isomorphism between X and Y
21:38:42 <mniip> evidenced by the images of id_X and id_Y
21:40:32 <mniip> I guess that needs a stronger condition
21:40:45 <mniip> namely also an iso between Hom(-, X) and Hom(-, Y)
21:41:16 <mniip> seems vaguely related to the yoneda lemma
21:41:35 <mniip> if two objects have the same pattern of arrows around them then are they really different
21:41:55 <mniip> oh er, "does that mean the exists a natural isomorphism between X and Y" <- that should be "unique" not "natural"
22:15:46 <dmwit> mniip: It's been a while, and I haven't carefully expanded definitions, so take this with a heap of salt.
22:16:08 <dmwit> mniip: But intuitively it seems like one should always have a natural isomorphism between Hom(X, -) and Hom(X, -).
22:16:22 <dmwit> mniip: But it's certainly not always the case that there's a unique isomorphism between X and X.
22:23:09 <chessandgo> does anyone know about the quality of the openAL library http://hackage.haskell.org/package/OpenAL
22:35:28 <mniip> dmwit, oh
22:36:16 <mniip> there's as many isomorphisms between X and Y as there are natural isomorphisms between (Hom(X, -), Hom(-, X) and (Hom(Y, -), Hom(-, Y))
22:36:40 <mniip> hmm no
22:37:00 <mniip> well no that sounds likely
22:59:03 <syniseth> I'm learning Haskell from "Learn You a Haskell For Great Good" and noticed that prepending to a list is faster than appending to a list. This seems counter-intuitive. Woudldn't it be slower since you have to readjust every index for prepending in contrast to appending, or is this due to a unique way the language was designed?
22:59:54 <mauke> lists don't have indices
22:59:58 <mauke> they're not arrays
23:00:12 <syniseth> How are they stored in memory then?
23:00:18 <mauke> a linked list
23:00:27 <syniseth> OH
23:00:29 <syniseth> Thank you
23:00:44 <syniseth> So for all linked list that rule applys?
23:00:57 <syniseth> applies*
23:01:05 <mauke> depends
23:01:36 <mauke> doubly-linked lists aren't really useful in Haskell; I think adding any elements requires reconstructing the whole list
23:02:09 <mauke> you could also have a "reversed" linked list where the last element is stored first, which would make appending efficient
23:03:14 <syniseth> Ah I see, so appending is slower because it has to traverse the first list, since it is only linked in one direction.
23:03:31 <syniseth> Ty
23:03:33 <mauke> that, and it has to copy every node
23:04:04 <mauke> haskell is all about immutability, so any "change" really means constructing a new value
23:04:29 <mauke> prepending an element doesn't have to do that because it can just reuse the existing list as the tail of the new list
23:05:05 <mauke> > 1 : (2 : (3 : []))
23:05:07 <lambdabot>  [1,2,3]
23:05:25 <mauke> the [1,2,3] is just pretty-printing. the representation with : is what lists actually look like in memory
23:06:16 <syniseth> That is different than most languages right?
23:06:37 <syniseth> Like Python
23:06:42 <syniseth> where they're mutable
23:07:19 <syniseth> so 1:2:3 ++ [5] makes a brand new list
23:07:38 <mauke> that's a type error, actually :-)
23:07:50 <mauke> I don't think python's lists are linked list, though
23:07:55 <mauke> *linked lists
23:07:57 <opqdonut> > (1:2:3:[])++[5]
23:07:59 <lambdabot>  [1,2,3,5]
23:08:03 <opqdonut> (fixed the type error)
23:08:10 <mauke> @src (++)
23:08:10 <lambdabot> []     ++ ys = ys
23:08:11 <syniseth> oh thank you
23:08:11 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
23:08:11 <lambdabot> -- OR
23:08:11 <lambdabot> xs ++ ys = foldr (:) ys xs
23:09:31 <mauke> @src []
23:09:31 <lambdabot> data [] a = [] | a : [a]
23:10:05 <mauke> that's pseudocode (not actually valid syntax), but that's how lists would be defined
23:10:25 <mauke> in valid syntax: data List a = Nil | Cons a (List a)
23:10:40 <yushyin> https://github.com/python/cpython/blob/master/Include/listobject.h#L23 vector of pointers
23:11:47 <mauke> in python you could probably say something like: a linked list is either empty (represented by None) or an element and another list (represented by a tuple (x, rest) where x is the element and rest is another list)
23:12:29 <mauke> (1, (2, (3, None))), etc
23:13:23 <mniip> mauke, I think it did become valid syntax in a recent version
23:14:34 <syniseth> with ghci I did :!irssi -c freenode to get here, is there a related command to switch back to ghci without exiting irssi?
23:15:06 <mauke> o_O
23:15:14 <syniseth> A bit off-topic
23:15:21 <mniip> no I don't think so no
23:15:33 <mniip> you'd have to detach the irssi from the tty
23:15:41 <mniip> which ghci would have to have control over
23:15:48 <mauke> wouldn't you then have ghci and irssi running in the same terminal?
23:16:04 <syniseth> Has anyone here used Yesod?
23:16:13 <syniseth> yea it is
23:16:26 <syniseth> if I did /exit it would take me back to ghci
23:16:45 <mauke> I did some experiments and ctrl-z pauses all of it, including ghci :-)
23:17:27 <buhman> I hope nobody decided to implement job control in ghci
23:17:38 <mniip> sounds like a fun project
23:18:45 <syniseth> Anyone here dabbled with a Haskell web framework before?
23:19:11 <mniip> I have a program that outputs a helloworld in html if that counts :P
23:19:35 <syniseth> Lol
23:20:17 <syniseth> Thanks for help guys I'll be back later :D gotta focus on this book!
23:54:55 <dminuoso> mauke: Strictly speaking its not pseudocode but _actual_ code. But it's from GHC so..
23:57:54 <maerwald> is -fllvm slower in terms of compile speed?
