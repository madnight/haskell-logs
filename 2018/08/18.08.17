00:48:31 <Lears> So I've written up a relatively simple (40 line core source module, 40 line example usage) implementation of a Linear Order data-type (something I've been wanting for a while): https://gist.github.com/LSLeary/a0e1d73775e0d0f3908648c5fdbfc15d
00:48:59 <Lears> But I'm not experienced in haskell type-fu; it would be good to know if there are any clear ways to improve this.
00:50:12 * hackage preludeplus 0.1.0.0 - Generalizes List functions to MonadPlus etc. and replaces partials and group(By) with NonEmpty equivalents.  http://hackage.haskell.org/package/preludeplus-0.1.0.0 (jnbooth)
00:51:13 * hackage potoki-core 2.2.6.1 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.2.6.1 (NikitaVolkov)
00:52:12 * hackage preludeplus 0.1.0.1 - Generalizes List functions and replaces partials with NonEmpty equivalents.  http://hackage.haskell.org/package/preludeplus-0.1.0.1 (jnbooth)
01:15:29 --- mode: glguy set +v __idiot__
01:19:21 --- mode: glguy set +v TBloemink28
01:19:24 --- mode: glguy set +v beaky10
01:20:47 --- mode: glguy set +v haha
01:25:16 --- mode: glguy set +v Raziel5
01:29:14 <lortabac> hello, is there an easy solution to the "cannot satisfy -package-id... is unusable due to shadowed dependencies" Cabal error?
01:31:27 <merijn> lortabac: Are you using "cabal build"?
01:32:19 <dminuoso> Im unsure how to even formulate this.. but what does this code mean? https://gist.github.com/dminuoso/34e1af2bbc3e0e2f704ba58f43791b22
01:32:27 <dminuoso> What deep black magic way of creating bindings is this?
01:33:01 <merijn> dminuoso: You can perform arbitrary pattern matches in bindings at the top level just like everywhere else
01:33:10 <lortabac> merijn: cabal new-build
01:33:17 <dminuoso> merijn: yeah but.. wait. what?
01:33:23 <merijn> dminuoso: Try "x, y, z :: Int; [x,y,z] = [1,2,3]" on the top level
01:33:37 <merijn> dminuoso: That "Just Works (TM)"
01:33:48 <dminuoso> o_o
01:34:05 <merijn> dminuoso: Well, if you can create a binding like that in let/where, why wouldn't you be able to at the top level?
01:34:47 <merijn> lortabac: huh...that was going to be my suggested workaround. Try asking in #hackage? hvr seems to be around
01:34:52 <dminuoso> merijn: Ohh, so :<|> is a data constructor
01:35:01 <lortabac> merijn: thanks
01:35:04 <dminuoso> I mean it has to be
01:35:14 <merijn> dminuoso: Starts with a :, so yes :)
01:35:18 <dminuoso> merijn: Gotcha =)
01:38:01 <cocreature> lortabac: 8.4.3 has a workaround, for older versions nuking things in ~/.cabal/store is the only option afiak
01:38:20 <cocreature> 8.6 should fix it properly
01:39:31 <lortabac> cocreature: I removed .cabal/store/ghc-8.2.1 and tried again
01:41:59 --- mode: glguy set +v zeroed1
01:45:23 --- mode: glguy set +v macker24
01:56:53 --- mode: glguy set +v anataex
02:13:43 * hackage potoki-core 2.2.7 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.2.7 (NikitaVolkov)
02:14:43 * hackage potoki 2.0.5 - Simple streaming in IO  http://hackage.haskell.org/package/potoki-2.0.5 (NikitaVolkov)
02:17:30 <dminuoso> merijn: What do you mean with "starts with a `:`" though
02:17:54 <dminuoso> Is there a rule that states a data constructor must start with either a capital letter or a colon?
02:18:03 <merijn> dminuoso: : is the "capital letter operator"
02:18:23 <merijn> So, yes, all operator constructors must start with : and all things starting with : are constructors
02:18:32 <merijn> Same way constructors always start with a capital letter
02:18:45 <dminuoso> merijn: is that an extension or from the report?
02:18:54 --- mode: glguy set +v rihards
02:19:03 <merijn> dminuoso: That's specified by the report
02:19:57 <rihards> hey, is there some magical "middle-layer" that i could stick in front of a `Stream (Of a) m r` from the Streaming library so that the resulting stream wouldn't repeat the monadic action if, e.g., i zipped it with itself?
02:28:37 <rihards> i have defined a few stream processing functions that do some transformations on the original stream that is fetched from a websocket (via S.repeatM $ do ... <get a message from websocket>). afterwards i zip the resulting streams together an print them. the problem is that each of the derived streams competes for messages from the websocket fetching them by itself
02:29:48 <dminuoso> merijn: where?
02:30:26 <merijn> dminuoso: In the grammar
02:34:15 <dminuoso> merijn: Ah I think I found it. consym  -> (:{symbol})<reservedop>
02:35:20 <dminuoso> conop -> consym | `conid`; constr -> ... | (btype | ! atype) conop (btype | ! atype)
02:35:29 <dminuoso> Cool really missed that bit, thanks merijn. :)
02:37:47 <mniip> !
02:37:53 <rihards> so as i see it - either there is a *magical* mid-layer that would make sure that the websocket is called exactly once for each of the original stream's elements; or i have to rewrite this stuff to create ... i dunno ... some composable state monad compuations (one for each of the derived streams) that would go over the original stream and spew out what i want ... or something. does the second option seem something familiar to any of you?
02:37:58 <mniip> I found a way to encode :~: using RankNTypes
02:38:46 <mniip> @let data a :=: b = R (forall p. p a -> p b)
02:38:48 <lambdabot>  Defined.
02:38:57 <mniip> :t (\
02:38:58 <lambdabot> error:
02:38:58 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
02:38:59 <mniip> er
02:39:08 <mniip> :t \(R f) -> f Refl
02:39:09 <lambdabot> forall k (a :: k) (b :: k). (a :=: b) -> a :~: b
02:39:27 <mniip> :t (\Refl -> R id) :: a :~: b -> (a :=: b)
02:39:28 <lambdabot> forall k (a :: k) (b :: k). (a :~: b) -> a :=: b
02:42:45 <mniip> @let data Sym p b a = Sym { runSym :: p a -> p b }
02:42:46 <lambdabot>  Defined.
02:43:15 <mniip> :t \(R f) -> R (runSym (f $ Sym id))
02:43:17 <lambdabot> forall k (b :: k) (a :: k). (b :=: a) -> a :=: b
02:45:08 <mniip> you can probably do all of coercion algebra on this
02:45:19 <mniip> nominal equality only, ofc
03:07:32 <madnight> is a markov chain a category? http://setosa.io/ev/markov-chains/
03:08:22 <madnight> i see objects, arrows, identity, morphisms
03:08:50 <madnight> the first example seems to be isomorphic
03:09:51 <mniip> madnight, what would composition be
03:10:57 <madnight> in the first example: f . g = id
03:15:28 <fishythefish> I think you're observing that a (finite?) Markov chain can be represented as a digraph and you can generate the free category on a digraph
03:17:20 <mniip> looks more like a matrix to me
03:18:19 <fishythefish> based on that link, I'm assuming madnight is referring to the finite state machines rather than the transition matrices
03:18:55 <mniip> I mean, in essence, a markov chain associates a probability to each transition
03:19:26 <mniip> so individual transitions cannot be morphisms
03:19:55 <fishythefish> I mean, I agree that a Markov chain is not a category (at least in a way that is obvious to me)
03:20:03 <mniip> sure, you can generate a free category on top of that
03:20:10 <fishythefish> I think the premise of the question was that the FSMs on that page look vaguely like categories
03:20:18 <mniip> using the multipcation monoid for the probability
03:20:25 <mniip> multiplication*
03:21:04 <mniip> this would be more appropriately called a category of paths though
03:21:52 <mniip> which can be rigorously extended to a free category on a weighted digraph with a monoid on the weight
03:22:11 <xsperry> xs = 0 : xs <- how much memory will xs occupy? and will memory usage grow as we keep evaluating xs, or will it be constant (just 0 and a pointer back to itself, plus additional memory used by any list)
03:22:42 <mniip> xsperry, the way you wrote it, it'll occupy constant space
03:22:47 <mniip> just a reference loop
03:23:08 <madnight> could there be any usefulness to approach Markov Chains from a categorial view point?
03:25:06 <mniip> I don't think so
03:25:41 <mniip> being a free category (any composition of generator morphisms is uniquely represented) it's not very interesting
03:30:10 <mniip> interesting
03:30:20 <mniip> so RankNTypes is as strong as GADTs then
03:30:36 <mniip> (why did we get GADTs in Core then)
03:49:19 <Unhammer> What would you use to ensure only one instance of a program running on Windows? I see people claim `notepad > lockfile` ( https://superuser.com/a/649819/36198 ) will cause that file to be write-locked, but I seem to be able to open the same file for writing concurrently on Windows (and Linux), ie. http://termbin.com/zbej does not cause an Exception, writes just fine in both cases
03:51:00 <Rembane> Unhammer: What about checking if a file exists? Will that solve your problem? 
03:58:39 <Unhammer> Rembane,  no, because the file might exist because of a previous run
03:59:16 <Unhammer> I'd prefer not to have to trust that cleanup-code will always have run
03:59:23 <Rembane> Unhammer: If it does exist because of a previous run, doesn't that mean that something went wrong?
04:00:29 <Unhammer> Yes. Lots of things could go wrong. I still want the program to re-run if the previous run went wrong. I just don't want the program to start if it's already running.
04:01:38 <Rembane> Okay. Can you setup a socket on localhost on a port, and if you can connect to that port you don't run?
04:04:06 <AWizzArd> Did Data.Map’s `lookup` function in the past return its result into any monad? Over 10 years ago?
04:05:52 <Taneb> AWizzArd: as Maybe?
04:06:19 <Taneb> AWizzArd: I've just looked at really old haddocks and yeah
04:06:42 <Taneb> http://hackage.haskell.org/package/containers-0.1.0.0/docs/Data-Map.html#v:lookup
04:06:52 <Taneb> lookup :: (Monad m, Ord k) => k -> Map k a -> m a
04:07:02 <Taneb> "The function will return the result in the monad or fail in it the key isn't in the map."
04:07:07 <AWizzArd> Taneb: okay great thx. That explains it.
04:07:07 <Taneb> Wow, that's ugly
04:07:25 <dstolfa> Taneb: that is indeed ugly
04:07:37 <AWizzArd> Taneb: I was reading a paper which presented code that looked like a bad type error. And it would be one nowadays.
04:07:37 --- mode: glguy set +v greeneyedfriend[
04:07:48 <AWizzArd> It would have worked if lookup had returned an `m a`.
04:08:27 <Taneb> AWizzArd: it has that type signature in versions 0.1.0.0 and 0.1.0.1
04:08:47 <Taneb> 0.2.0.0 has lookup :: (Ord k) => k -> Map k a -> Maybe a
04:08:57 <Taneb> And was uploaded November 2008
04:09:17 <Taneb> From the changelog: "Various result type now use Maybe rather than allowing any Monad."
04:09:18 <dstolfa> Taneb: what was the motivation for returning m a initially?
04:09:28 <dstolfa> because it seems kind of senseless to return any monad
04:09:51 <Taneb> dstolfa: it was 2007 and people were still exploring the design space
04:10:01 <dstolfa> Taneb: yeah, i understand that, but what was the motivation?
04:10:03 <AWizzArd> Sounds plausible.
04:10:12 <dstolfa> i'm not bashing people here, just curious what the motivation was
04:10:12 <int-e> dstolfa: It would work for Maybe and [] -- I guess these are the two useful ones.
04:10:12 <AWizzArd> Maybe they wanted more generic code.
04:10:19 <dolio> AWizzArd: Yes, it used to work that way.
04:10:21 <AWizzArd> For Either also.
04:10:23 <int-e> (Either as well, at the tiem)
04:10:23 <Taneb> If you used Either or IO you got an error message
04:10:26 <int-e> *time
04:10:35 <dstolfa> int-e: ah, i suppose that makes sense
04:10:42 <Taneb> "Data.Map.lookup: key not found"
04:10:46 <int-e> > fail "abc" :: Either () () -- not anymore
04:10:48 <lambdabot>  *Exception: abc
04:10:55 <ChaiTRex> If I have a function, f x = if aConstant = 5 then g x else h x, will the GHC RTS automatically shorten it to f x = h x or f x = g x depending on the value of aConstant?
04:11:18 <ChaiTRex> The constant is a runtime constant.
04:11:19 <AWizzArd> It allowed to just write:     M.lookup n env     instead of   maybe (fail ("undefined variable: " ++ n)) return $ Map.lookup n env
04:11:23 <int-e> Taneb: Either used to implement 'fail' as 'Left' (modulo the 'Error' class)
04:11:30 <dolio> A better specification would be that it only works in monads equipped with a properly defined notion of failure.
04:11:31 <Taneb> int-e: yes, I know
04:11:38 <dolio> But that didn't exist at the time.
04:11:56 <Taneb> int-e: I meant, if you use Either, you got access to an error message that you can do something with
04:12:18 <dstolfa> i can see Either making sense here as well
04:12:24 <dolio> Only the improper one existed. :)
04:12:43 <Taneb> But we've come along way since 2008
04:12:50 <dstolfa> okay, it's been a while since i wrote serious haskell
04:12:53 <dstolfa> do we have an Error monad
04:12:58 <dstolfa> which is isomorphic to Either
04:13:01 <dstolfa> i.e. it's a coproduct
04:13:07 <dstolfa> but just names things like Some and Err
04:13:31 <dolio> There's ExceptT Id, I think.
04:13:55 <maerwald> tdammers: do you guys provide lens courses? 
04:15:02 <lavalike> why does Either not fail with Left anymore?
04:16:14 <mniip> lavalike, (fail "foo" :: Either Int Int) = Left ?
04:17:55 <ChaiTRex> Left 5, obviously.
04:18:15 <mniip> that sounds very parametric
04:18:32 <mniip> @free fail :: String -> Either a b
04:18:33 <lambdabot> $map_Either f g . fail = fail
04:19:54 <Taneb> @free notFail :: String -> Either String b
04:19:54 <lambdabot> $map_Either ($map_String f) . notFail = notFail
04:19:57 <Unhammer> Rembane, huh, that sounds like it should work … I remember having some trouble with ports not being "let go" when I was using Python, but I'll just have to try it and see
04:20:09 <int-e> hrm, why is ErrorT deprecated in favor of ExceptT when the latter maps 'fail' to 'error'?
04:21:39 <Rembane> Unhammer: Good luck! Have you looked into the bracket-pattern btw?
04:22:11 <merijn> int-e: ErrorT was deprecated because it restricted the Left type to error instances and gave the misleading impression it would only work for errors
04:22:26 <merijn> int-e: As for the fail implementation: How else would it implement fail?
04:22:26 <int-e> merijn: That was the whole point of ErrorT
04:22:51 <merijn> int-e: No, because not all left-biased Left cases are errors, they are just "exceptional", hence ExceptT
04:24:15 <int-e> merijn: I thought the point was to get the old Either behavior back. The Error class is in there to make "fail" work, same as originally for Either.
04:25:13 <merijn> int-e: In a few releases with proper MonadFail this is solved anyway
04:25:26 <int-e> I have no real stake in this (I don't think I'm using ErrorT anywhere), but I'm irritated in deprecating something in favor something else that doesn't cover all its use cases.
04:25:32 <merijn> int-e: Because then fail will only work for ExceptT is the base Monad is MonadFail
04:25:40 <int-e> s/ in/ at/
04:25:52 <merijn> int-e: What can you do with ErrorT that ExceptT can't?
04:26:15 <int-e> merijn: mapping "fail" to the exceptional case of the monad transformer.
04:26:41 <merijn> That's honestly more a bug than a feature anyway
04:27:07 <int-e> Well to my mind that was *the* main feature of ErrorT.
04:27:11 <merijn> int-e: And you can cover that case by using MonadFail
04:27:33 <cheater> int-e: what does that mean? mapping fail to the exceptional case of the monad transformer
04:27:39 <int-e> no, not really, because as you said, MonadFail will propagate the error to the base monad.
04:28:21 <dminuoso> Why is ExceptT not called EitherT?
04:28:24 <int-e> cheater: we have  fail "abc" :: ErrorT String Identity ()  ==  ErrorT (Identity (Left "abc"))
04:28:31 <dminuoso> I find it properly confusing.
04:28:37 <merijn> dminuoso: Because it's a left-biased version of Either
04:28:53 <merijn> dminuoso: There was lots of bikeshedding
04:28:54 <dminuoso> merijn: what do you mean by left bias?
04:29:11 <cheater> int-e: where does the Either come from?
04:29:14 <Unhammer> Rembane, I have, but I don't trust it to dtrt Always (kill9, plugpulling etc)
04:29:27 <int-e> cheater: from the definition of ErrorT
04:29:42 <cheater> and that is not possible in ExceptT?
04:29:45 <merijn> dminuoso: Both in the definition of >> going left hand first and the monad short-circuiting Left results
04:30:11 <int-e> newtype ErrorT e m a  = ErrorT (m (Either e a))
04:30:32 <mniip> hmm
04:30:36 <int-e> cheater: no, because this is different from calling "fail" in the base monad.
04:30:52 <int-e> (which in the case of Identity is just "error")
04:31:03 <cheater> so what happens when you do fail "abc" in the ExceptT version?
04:31:08 <ChaiTRex> Are if statements thunks that can be replaced with a branch of the if statement if the condition is a runtime constant?
04:31:14 <cheater> ah
04:31:22 <dminuoso> merijn: But isn't that what the Either monad does too?
04:31:37 <merijn> dminuoso: There was *A LOT* of bikeshedding
04:31:48 <int-e> > fail "abc" :: ExceptT String Identity ()
04:31:50 <lambdabot>  ExceptT (Identity *Exception: abc
04:31:55 <mniip> if I have  'forall p. p (f a) -> p (g b)', how do I recover 'forall p. p a -> p b'
04:31:58 <dminuoso> cheater: if are just case f of True -> ...; False -> ...; expressions
04:32:14 <cheater> int-e: so then rather than use the Either monad, you have to try and catch?
04:32:43 <int-e> cheater: I cannot use "fail".
04:32:56 <ChaiTRex> dminuoso: Can case statements be permanently replaced by one of their branches if the decision statement is a runtime constant?
04:32:57 <cheater> mniip: use the identity functor and then unpack.
04:33:10 <mniip> cheater, hmm?
04:33:12 <cheater> although
04:33:13 <mniip> f,g,a,b are rigid
04:33:37 <cheater> yeah, just pack your a in an f, and then take it out of the g
04:33:42 <cheater> and that's your new function
04:33:52 <mniip> eh?
04:34:30 <int-e> cheater: note that I'm not even claiming that ErrorT is particularly useful. I'm merely objecting to the way it's being deprecated: " Module ‘Control.Monad.Error’ is deprecated: Use "Control.Monad.Except" instead" because the latter is not an adequate replacement for the former.
04:34:38 <dminuoso> ChaiTRex: what do you mean?
04:34:56 <mniip> cheater, you're making a lot of assumptions on f,g,a,b,p here
04:35:05 <mniip> once again, they're rigid and unconstrained
04:35:06 <dminuoso> ChaiTRex: if you have something like: b = case f of True -> ifTrue; False -> ifFalse; 
04:35:25 <ChaiTRex> dminuoso: Let's say I have `case runtimeConstant of theCorrectValue -> a; ...`, does the entire case statement get replaced by a?
04:35:26 <dminuoso> ChaiTRex: then the way GHC implements evaluation, b will be memoized.
04:36:13 <dminuoso> ChaiTRex: First during simplifier passes there's a lot of transformations happening, so what you see has a low chance of looking like it after compilation has happened.
04:36:31 <ChaiTRex> dminuoso: Ahh, OK. Does that include when the case branch isn't constant?
04:37:35 <cheater> mniip: let's say you have foo :: forall p. p (Either a) -> p (Maybe b). Then just.foo.Either will have the type you want
04:37:40 <cheater> er
04:37:44 <cheater> just.foo.Left
04:37:50 <dminuoso> ChaiTRex: GHC has no JIT compilation that can, with runtime knowledge, constant fold code if thats what you mean.
04:38:19 <mniip> cheater, you're making little sense right now
04:38:20 <dminuoso> ChaiTRex: Do you have a full code example?
04:39:00 <cheater> mniip: lol, w/e
04:39:22 <mniip> cheater, 'foo . Left' would be a kind error
04:39:57 <cheater> i'm sure you can figure it out
04:40:00 <mniip> Left returns 'Either x y', where 'Either x' has kind '* -> *' whereas in 'p (Either a)', the p has kind '(* -> *) -> *'
04:40:07 <ChaiTRex> dminuoso: No, I'm planning on how to handle endianness, which will eventually be a runtime constant.
04:40:24 <mniip> cheater, at this point I want you to elaborate just so that I can point out your mistake
04:40:43 <ChaiTRex> dminuoso: I was hoping case statements were thunks that were evaluated until they hit an unbound variable or something.
04:40:46 <cheater> so make it p (Either x a), and stop being annoying about it
04:40:48 <mniip> cheater, there is no 'a -> f a' or 'f a -> a' for generic f or g
04:40:55 <mniip> 'p' is not necessarily a functor
04:40:57 <cheater> so f = Either x
04:40:59 <mniip> a,b are not necessarily kind *
04:41:16 <dstolfa> mniip: lots of cheating going on here huh
04:41:20 <ChaiTRex> dminuoso: And then the evaluation was still completed to that point on future calls to the function.
04:41:22 * dstolfa is not following, just saw mniip say cheater twice
04:41:22 <cheater> i am not necessarily going to continue this ordeal
04:41:25 <dminuoso> ChaiTRex: Let's consider this example: f = case ... of True -> ifTrue; False -> ifFalse
04:41:56 <mniip> dstolfa, check your ignore lists I guess?
04:42:02 <dminuoso> ChaiTRex: `f` is now represented as a thunk. If you force it, it will discriminate on its argument, find the answer and then update the thunk to directly return `ifTrue` or `ifFalse` respectively
04:42:17 <dminuoso> ChaiTRex: Named expressions memoize.
04:42:22 <ChaiTRex> dminuoso: Oh, OK. That's good :)
04:42:24 <dstolfa> mniip: i'm just blind as a bat, i just realised that there's someone named cheater 
04:42:28 <ChaiTRex> dminuoso: That makes my job much easier.
04:43:01 <ChaiTRex> I can just put an if with the two endiannesses at the beginning.
04:43:16 <mniip> anyway
04:43:16 <cheater> dstolfa: hi! i do exist
04:43:23 <dminuoso> ChaiTRex: Just keep in mind that it wont work with functions
04:43:29 <mniip> I fear splitting a type application might not be possible with ADTs or RankNTypes
04:43:55 <ChaiTRex> dminuoso: Ahh, just named nonfunction values?
04:44:10 <dminuoso> ChaiTRex: Think about it for a second. f x = x + 1
04:44:13 <ChaiTRex> I could probably put two lambdas on the if branches.
04:44:27 <mniip> there's no GADT-free p you can plug into 'p (f a) -> p (g b)' to derive a function 'forall q. q a -> q b'
04:44:33 <dminuoso> ChaiTRex: I apply `f` to 5 somewhere in the code. Would it be valid to replace the definition of `f` with something like `f = const 6`?
04:44:39 <mniip> at least that's my current conjecture
04:45:04 <ChaiTRex> dminuoso: No, that would have to stop because of an unbound variable.
04:45:18 <ChaiTRex> At least unbound on the right.
04:45:37 <ChaiTRex> That might not be the right term.
04:46:25 <dminuoso> ChaiTRex: It might be easiest to experiment a bit with some naive/badly written `fac` function, say: fac n = if n == 0 then 1 else n * fac (n-1)
04:46:56 <dminuoso> ChaiTRex: When you apply that to 20000 it will take a few seconds to compute.
04:47:27 <dminuoso> something like `let n = fac 20000 in (n, n)` will behave differently from (fac 20000, fac 20000)
04:48:04 <ChaiTRex> dminuoso: Right, that makes sense.
04:49:21 <ChaiTRex> What about f = case endianness of Big -> \x y -> ...; Little -> \x y -> ...? Does it simplify the thunk to only one of the lambdas?
04:49:32 <ChaiTRex> Where endianness is a runtime constant.
04:49:37 <dminuoso> ChaiTRex: Yes.
04:49:46 <ChaiTRex> Ahh, OK. Thanks. That makes more sense now.
04:50:26 <dminuoso> ChaiTRex: The first time you force it, it will discriminate on `endianness` and update the thunk of `f` to directly produce the appropriate lambda. That has nothing to do with `case` though.
04:50:37 <dminuoso> ChaiTRex: whatever the expression returns is essentially memoized. :)
04:51:55 <ChaiTRex> Ahh, I see.
04:52:32 <dminuoso> ChaiTRex: We can safely do this because functions/core is assumed to be pure. So it's morally correct.
04:52:42 <dminuoso> *functions/code
04:53:38 <dminuoso> Its also why things like unsafePerformIO tend to be problematic because it ties effects into evaluation. Evaluation might never happen, or in case of sharing might surprisingly happen only once despite you using `f` in 3 places..
04:58:09 <ChaiTRex> Yeah, I try not to use unsafePerformIO unless it's referentially transparent for that run of the program.
04:58:32 <ChaiTRex> And if it's just reading rather than writing something.
04:58:45 <ChaiTRex> That way it doesn't matter so much.
05:00:06 <xsperry> is it normal that I can't C-c out of length [1..] ?
05:00:11 <xsperry> > length [1..]
05:00:17 <lambdabot>  mueval-core: Time limit exceeded
05:00:19 <mniip> oh
05:00:20 <mniip> maybe I can
05:00:38 <ChaiTRex> xsperry: Sometimes you have to press it twice in a row.
05:00:59 <xsperry> I pressed it 10 times in a row
05:01:02 <xsperry> maybe it is emacs, not ghci
05:01:23 <ChaiTRex> xsperry: Yeah, something might be capturing your Ctrl+Cs.
05:01:26 <xsperry> yes.. in ghci C-c breaks fine
05:01:38 <xsperry> but not if I run ghci in emacs
05:01:50 <ChaiTRex> xsperry: emacs likes the Ctrl combinations.
05:02:14 <maerwald> lol
05:02:21 <ChaiTRex> xsperry: There's probably some alternative.
05:02:23 <xsperry> I think it is my fault, actually :P
05:03:49 <xsperry> no, it isn't. I thought I disabled C-c in emacs to train myself to not use it, but I only disabled M-x. so it seems emacs is intercepting C-c, yeah
05:04:21 <xsperry> C-g does not work either. or C-break
05:05:11 <maerwald> get an editor that works
05:05:14 <ChaiTRex> There's probably some alternative key combo or something that emacs veterans would know.
05:07:09 <ArahaelPi> C-c C-c might work
05:09:12 * hackage rpmbuild-order 0.2 - Order RPM packages by dependencies  http://hackage.haskell.org/package/rpmbuild-order-0.2 (JensPetersen)
05:15:23 <Ariakenom> Related good to know. You might not be able to interrupt a haskell program not compiled with -fno-omit-yields
05:16:35 <maerwald> so the more keys you hit the higher the chances of it working in emacs? 
05:18:12 <c_wraith> maerwald: up to 15 or so.  Beyond that you're just asking it to get snarky
05:18:18 <mniip> Ariakenom, behold, C-\
05:18:51 <maerwald> good that I'm using an editor where the only thing that is broken are plugins
05:19:13 <mniip> maerwald, questionable
05:23:42 * hackage indexation 0.4.2.3 - Tools for entity indexation  http://hackage.haskell.org/package/indexation-0.4.2.3 (NikitaVolkov)
05:46:38 <mniip> hm
05:46:53 <mniip> interesting drawback of holes
05:48:13 * hackage cl3 1.0.0.3 - Clifford Algebra of three dimensional space.  http://hackage.haskell.org/package/cl3-1.0.0.3 (nwaivio)
05:48:55 <mniip> % :t \(f :: forall r. (forall a. a -> r) -> r) -> _ f
05:48:56 <yahb> mniip: ghc: panic! (the 'impossible' happened); (GHC version 8.6.0.20180620 for x86_64-unknown-linux):; tcTyVarDetails; co_aEQJ :: TYPE t_aEQO[tau:1] ~# TYPE t_aEQQ[tau:1]; Call stack:; CallStack (from HasCallStack):; callStackDoc, called at compiler/utils/Outputable.hs:1164:37 in ghc:Outputable; pprPanic, called at compiler/basicTypes/Var.hs:497:22 in ghc:Var; Please report this as
05:49:24 <mniip> not quite what I expected
05:49:54 <mniip> anyway, the issue is:     • Found hole: _ :: t0 -> t       • Cannot instantiate unification variable ‘t0’
05:51:43 * hackage hw-prim 0.6.2.9 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.9 (haskellworks)
05:52:25 <dmwit> mniip: Is this a "we need a real exists keyword" kind of drawback?
05:52:34 <dmwit> I admit I'm not clear on exactly what GHC is complaining about there.
05:52:34 <mniip> not really no
05:52:49 <mniip> it's just the way holes are implemented
05:53:12 <mniip> let '_ :: forall k (a :: k). a', then run the inference mechanism
05:53:40 <mniip> the inference mechanism wouldn't apply a 'forall a. a'-typed value to a polymorphic function
05:53:54 <mniip> because that, as stated, requires unifying a tyvar with a quantified type
05:54:15 <dmwit> Right, I see. A smaller example with the same problem is just `\(f :: forall r. r) -> _ f`
05:55:12 <dmwit> And you want it to say "found a hole of type `(forall a. a) -> b`" but it won't do that.
05:55:31 <mniip> yup
05:56:12 * hackage rpmbuild-order 0.2.1 - Order RPM packages by dependencies  http://hackage.haskell.org/package/rpmbuild-order-0.2.1 (JensPetersen)
06:01:21 <mniip> data Arg p x y = Arg { runArg :: forall r. (forall f g a b. (forall q. q x -> q (f a)) -> (forall q. q y -> q (g b)) -> (p a -> p b) -> r) -> r }
06:01:23 <mniip> what a type
06:01:47 <glguy> greeneyedfriend[: Read your direct messages; no one saw your question earlier
06:03:18 <dminuoso> ChaiTRex: Just by the way, `endianness` is necessarily constant. ;)
06:05:56 <pie_> is there any library for large file backed data structures?
06:08:44 <cocreature> pie_: what data structure are you looking for?
06:09:15 <pie_> probably some kind of graph
06:09:50 <pie_> not 100% sure yet, just trying to survey the landscape
06:10:15 <cocreature> I’ve seen disk-based b-trees on hackage
06:10:24 <dminuoso> Though it is an interesting question. Does GHC offer me some ways to have a named expression produce different results say for (n, n)
06:10:41 <cocreature> not sure if there is something for general graphs, you could also consider using a graph db in that case
06:10:57 <pie_> cocreature, i might want to do something where i apply transformations to a file and want to be able to access any node
06:11:15 <dminuoso> Relatedly, can a computed thunk be "undone" by the GC?
06:11:27 <mniip> dminuoso, contexts?
06:12:00 <mniip> @let apair = let n = 0 in (n, n)
06:12:02 <lambdabot>  Defined.
06:12:08 <mniip> er
06:12:08 <cocreature> pie_: that still sounds very vague, I would recommend that you first figure out what exactly you need and then search for things
06:12:17 <mniip> @let apair = let n = 123456 in (n, n)
06:12:18 <pie_> cocreature, arrows would be functions and nodes would be the states after the transformation is applied
06:12:19 <lambdabot>  Defined.
06:12:24 <mniip> > apair :: (Word8, Integer)
06:12:26 <lambdabot>  (64,123456)
06:12:28 <pie_> cocreature, fair enough
06:12:36 <dminuoso> mniip: Assume them to be the same type.
06:12:46 <dminuoso> mniip: Specifically Im wondering about ways to break referential transparency
06:12:49 <mniip> then no
06:12:56 <mniip> I was about to mention referential transparency
06:13:01 <dminuoso> :)
06:13:13 * hackage toxcore 0.2.0 - Haskell bindings to the C reference implementation of Tox  http://hackage.haskell.org/package/toxcore-0.2.0 (iphydf)
06:13:17 <mniip> just turn them into applications
06:13:34 <mniip> % let x _ = trace "foo" () in (x void#, x void#)
06:13:34 <yahb> mniip: ; <interactive>:2:32: error:; * Couldn't match a lifted type with an unlifted type; When matching types; p0 :: *; Void# :: TYPE ('TupleRep '[]); * In the first argument of `x', namely `void#'; In the expression: x void#; In the expression: (x void#, x void#); <interactive>:2:41: error:; * Couldn't match a lifted type with an unlifted type; When matching ty
06:13:39 <lortabac> hello, it seems that the (==) type family does not work correctly on GHC 8.2, has anyone heard of this issue?
06:13:44 <mniip> % let x :: Void# -> (); x _ = trace "foo" () in (x void#, x void#)
06:13:45 <yahb> mniip: (foo; (),foo; ())
06:14:22 <mniip> (Void# -> a) has the same calling convention as 'a'
06:15:17 <mniip> lortabac, are you saying that because it can't reduce 'a == a' for a rigid but unknown a?
06:16:33 <dminuoso> mniip: Im trying to find a way whether you can break referential transparency on a memoized expression.
06:16:50 <mniip> dminuoso, you can't
06:17:17 <lortabac> mniip: I have a data type data V = VZero | VSucc V, if I run :kind! VZero == VZero in GHCI it does not reduce
06:17:45 <dminuoso> mniip: Can I inhibit the STG closure memoizing the result value through a pragma?
06:17:50 <lortabac> mniip: whereas in GHC 8.4 it works as expected
06:18:03 <int-e> dminuoso: the worst case is that a thunk gets evaluated more than once... that can lose sharing and if the thunk violates referential transparancy, that may propagate outside.
06:18:43 <dminuoso> int-e: in what scenario would the thunk be evaluated more than once?
06:19:15 <int-e> dminuoso: two threads entering it at the same time
06:20:01 <int-e> dminuoso: there's no locking at that point unless you ask for it with noDuplicate#
06:20:47 <int-e> (which unsafePerformIO uses; that's the difference to unsafeDupablePerformIO)
06:22:17 <dminuoso> int-e: Ah, I take it the fact no lock is used is because the lock contention might be more expensive than waiting for the other thread to produce the result?
06:22:51 <vaibhavsagar> silly lens-aeson question: how do I replace a Value with another Value?
06:23:41 <int-e> dminuoso: a lock would be too expensive (actual contention is rare)
06:26:43 * hackage greskell 0.2.1.0 - Haskell binding for Gremlin graph query language  http://hackage.haskell.org/package/greskell-0.2.1.0 (debugito)
06:27:42 * hackage greskell-websocket 0.1.1.0 - Haskell client for Gremlin Server using WebSocket serializer  http://hackage.haskell.org/package/greskell-websocket-0.1.1.0 (debugito)
06:28:38 <int-e> dminuoso: I suspect the real cost is having to acquire a cache line exclusively at a particular point in time (instead what happens is that the code will replace the thunk by a black hole with an ordinary write which the processor can write out later)
06:30:08 <dminuoso> int-e: "acquire a cache line"?
06:30:31 <dminuoso> int-e: do you mean acquire/release semantics?
06:30:59 <dminuoso> Interesting, wasn't aware that this was cache-line grained.
06:31:09 <dminuoso> I suppose it makes sense.
06:31:09 <int-e> dminuoso: I have something like compare_and_swap in mind.
06:32:29 <dminuoso> int-e: And then there might be the problem of the actual lock mechanism. A spinlock would be expensive if the computation takes long, a mutex would be expensive if the computation is small..
06:32:55 <dminuoso> And then possibly dead lock scenarios with mutual recursion..
06:37:34 <mniip> lortabac, interesting
06:38:35 <mniip> lortabac, it seems that (==) was different in 8.2
06:38:59 <mniip> lortabac, see http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Type-Equality.html#t:-61--61-
06:39:35 <lortabac> mniip: oh, it's clearly written in the documentation
06:39:41 <mniip> it was this way until http://hackage.haskell.org/package/base-4.11.0.0/docs/Data-Type-Equality.html#t:-61--61-
06:39:50 <mniip> which I suspect corresponds to 8.4
06:41:11 <lortabac> mniip: I think I will have to define my own (==) to be compatible with 8.2
06:52:39 <mniip> of all things
06:52:53 <mniip> I didn't expect Left and Right (coercion, not either) to be a problem
06:54:42 <mniip> it doesn't seem like RankNTypes and ADTs can split a type application
06:58:06 <dminuoso> Internally, how does IO actually work? Is there some good resources that explain this?
06:58:15 <maerwald> GHC code
06:58:57 <merijn> dminuoso: You can read the Lazy Function State Threads paper
06:59:41 <dminuoso> merijn: Ah I remember this. Guess its time to give it a read now :)
07:37:18 <coldpresent> dminuoso https://wiki.haskell.org/IO_inside
07:43:01 <mniip> dminuoso, long story short,
07:43:04 <mniip> % :i IO
07:43:05 <yahb> mniip: newtype IO a = GHC.Types.IO (State# RealWorld -> (# State# RealWorld, a #)) -- Defined in `GHC.Types'; instance Alternative IO -- Defined in `GHC.Base'; instance Applicative IO -- Defined in `GHC.Base'; instance Functor IO -- Defined in `GHC.Base'; instance Monad IO -- Defined in `GHC.Base'; instance MonadPlus IO -- Defined in `GHC.Base'; instance Monoid a => Monoid (IO a) -- Defined in `GHC.Base'; inst
07:43:11 <mniip> % :kind! State#
07:43:11 <yahb> mniip: State# :: * -> TYPE ('TupleRep '[]); = State#
07:43:17 <mniip> emphasis on TupleRep []
07:44:36 <mniip> so, in Core, an IO is exactly like a state transformer on this weird State# RealWorld thing
07:44:47 <mniip> and in Stg/Cmm it gets erased and IO a is exactly like 'a'
07:46:24 <benzrf> scary
07:46:40 <benzrf> % :i  State
07:46:40 <yahb> benzrf: type State s = StateT s Identity :: * -> * -- Defined in `Control.Monad.Trans.State.Lazy'
07:46:45 <benzrf> oh hell yeah
07:46:50 <benzrf> ive always wanted an :i feature on lambdabot
07:46:52 <mniip> State# not State
07:46:58 <benzrf> i know, i was just seeing if :i worked
07:47:08 <mniip> yahb not lambdabot :P
07:48:05 <glittershark> what is yahb?
07:48:09 <glittershark> is it open source somewhere?
07:48:43 <mniip> partly
07:48:51 <ChaiTRex> dminuoso: You can see some State# RealWorld stuff in GHC.Exts, which also includes the realWorld# function that gives a starting state and the runRW# function that unsafePerformIO and so on use to break out of State# RealWorld.
07:49:22 <mniip> ChaiTRex, dminuoso, mind, 'State# RealWorld' isn't really a "state"
07:49:31 <ChaiTRex> Yeah, it's a fake value.
07:49:42 <mniip> it's a value that is phantom, as it gets eventually erased. it's only used to enforce order of evaluation during core passes
07:49:54 <glittershark> % System.Directory.removeDirectoryRecursive "/"
07:49:54 <yahb> glittershark: *** Exception: /: removeDirectoryRecursive:getSymbolicLinkStatus: does not exist (No such file or directory)
07:50:01 <glittershark> heh
07:51:21 <dmwit> That's pretty wild. How does anything work if / doesn't exist?
07:51:30 <dmwit> Well, anything that touches the filesystem, anyway.
07:51:41 <mniip> glittershark, yahb is 5% IRC frontend (closed), 5% sandboxing (open), 90% a deployed ghc/ghci/cabal environment (how do I open source that)
07:52:02 <mniip> %! stat /
07:52:03 <yahb> mniip: stat: cannot stat '/': No such file or directory
07:52:04 <mniip> %! stat .
07:52:05 <yahb> mniip:  File: '.'; Size: 313344 Blocks: 618 IO Block: 1024 directory; Device: 701h/1793d Inode: 2 Links: 3; Access: (0755/drwxr-xr-x) Uid: ( 996/ UNKNOWN) Gid: ( 996/ UNKNOWN); Access: 2018-08-15 11:34:16.000000000 +0000; Modify: 2018-08-15 11:33:56.000000000 +0000; Change: 2018-08-15 11:33:56.000000000 +0000; Birth: -
07:52:05 <maerwald> never use the directory package
07:52:06 <maerwald> never
07:52:09 <mniip> mystery
07:52:13 <glittershark> wow
07:52:16 <glittershark> nice sandboxing
07:52:32 <glittershark> do you have a link to that?
07:52:46 <glittershark> I'd like to hack something like this into my company's chatbot
07:53:00 <glittershark> recently did something similar with lambdabot where I just run it as a subprocess and interact with stdin/stdout
07:53:22 <mniip> glittershark, https://github.com/mniip/sandbox/tree/master
07:53:36 <glittershark> sweet! thanks mniip 
07:53:38 <dmwit> %! stat ..
07:53:39 <yahb> dmwit:  File: '..'; Size: 4096 Blocks: 8 IO Block: 4096 directory; Device: 801h/2049d Inode: 8782680 Links: 7; Access: (2755/drwxr-sr-x) Uid: ( 0/ UNKNOWN) Gid: ( 0/ UNKNOWN); Access: 2018-08-15 11:40:11.853893568 +0000; Modify: 2017-07-23 22:36:02.754541261 +0000; Change: 2017-07-23 22:36:02.754541261 +0000; Birth: -
07:53:50 <mniip> glittershark, mind it's rather obtuse
07:54:10 <mniip> main.cpp is more of a C++ script than a workable UI/API
07:54:25 <glittershark> heh
07:54:48 <dmwit> %! echo $PATH
07:54:48 <yahb> dmwit: /var/lib/xsbot/sandbox/root/bin
07:55:06 <dmwit> ...but / doesn't exist. Ok.
07:55:14 <glittershark> %! reboot
07:55:14 <yahb> glittershark: bash: line 1: reboot: command not found
07:55:32 <MarcelineVQ> you're assuming this bot has some pretty good permissions
07:55:58 <dminuoso> mniip: Oh wow. Okay everything instantly clicked.
07:56:02 <mniip> MarcelineVQ, I'm assuming it has yes
07:56:22 <mniip> unless you mean it differentiates people on IRC in any way - then no
07:56:34 <dminuoso> mniip: accursedUnutterablePerformIO seems to be the most naive demonstration..
07:57:10 <mniip> yup
07:57:16 <mniip> of it's inlined everything goes haywire
07:57:36 <dminuoso> mniip: Yeah it started with an article describing _why_ things go haywire, which is fairly interesting.
07:57:39 <mniip> because core-to-core passes think it's perfectly fine to reorder evaluation
07:58:03 <dminuoso> mniip: Or even worse, do things like common subexpression elimination.
07:58:11 <dminuoso> Which, if it happens on a malloc would be *terrible*
07:58:15 <mniip> right
07:58:25 <ChaiTRex> runRW# is pretty nice. It's essentially NOINLINE until it's safe to INLINE.
07:59:01 <ChaiTRex> Though it might duplicate work. I think it's more like unsafePerformDupableIO
07:59:17 <mniip> dminuoso, that obviously can't happen in 'x >> x' because that's  \s -> case x s of (s', _) -> x s'
07:59:49 <dminuoso> ChaiTRex: unsafeDupablePerformIO _is_ just runRW#
07:59:58 <ChaiTRex> dminuoso: Ahh, OK.
08:00:15 <Boarders> if I have some function like f :: a1 -> a2 -> A and a function c :: A -> B then I can do (fmap . fmap) c $ f to get something of type a1 -> a2 -> B
08:00:29 <Boarders> is there something similar you can do for arguments in contravariant position?
08:00:49 <dolio> (.)
08:01:03 <ChaiTRex> Boarders: Use pointfree.io website. Put in a lambda that does what you want.
08:01:19 <mniip> pointfree isn't always the readable one
08:01:22 <dminuoso> Boarders: contramap with Op?
08:01:31 <mniip> (fmap . fmap) c $ f  is unreadable imo
08:01:45 <Boarders> yeah, I would not use it in actual code
08:01:47 <Boarders> I was just curious
08:01:49 <mniip> fmap c . f   and (c .) . f  are a bit more readable
08:02:00 <dmwit> :t flip (.) -- Boarders
08:02:02 <lambdabot> (a -> b) -> (b -> c) -> a -> c
08:02:08 <mniip> (>>>) = flip (.)
08:02:10 <dmwit> (or flip fmap if you prefer that spelling of (.))
08:02:54 <mniip> @pl \x y -> f (g x) y
08:02:54 <lambdabot> f . g
08:03:01 <mniip> @pl \x y -> f x (g y)
08:03:01 <lambdabot> (. g) . f
08:03:07 <dmwit> :t contramap
08:03:09 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
08:03:35 <dmwit> And of course
08:03:36 <dmwit> :t rmap
08:03:37 <lambdabot> Profunctor p => (b -> c) -> p a b -> p a c
08:03:47 <dmwit> :t lmap
08:03:48 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
08:03:56 <dmwit> whatevs, who can remember which is which
08:04:07 <mniip> l is for left and r is for right?
08:04:26 <dmwit> Next you're going to tell me you can remember which side is left and which is right.
08:04:28 <mniip> and an arrow goes uhh, left to right
08:04:37 <mniip> you got me there
08:05:40 <mniip> could be more RTL-aware with imap and tmap for initial and terminal :P
08:05:43 <Boarders> there is a debate on the nlab page about whether the op occurs on the left or right
08:05:47 <Boarders> so you are in good company
08:06:06 <dolio> There is?
08:06:13 <dminuoso> Bike shedding mode activated.
08:06:17 <mniip> Boarders, you mean C^op x C -> D  vs C x C^op -> D ?
08:06:28 <Boarders> yeah
08:06:32 <Boarders> here: https://ncatlab.org/nlab/show/profunctor#discussion
08:06:37 <mniip> weird
08:06:39 * dmwit . o O ( Therefore, fmap changes the functor and leaves the functor's argument unchanged. )
08:06:46 <mniip> Hom is obviously C^op x C -> Set
08:06:53 <mniip> would you not want Hom to be a profunctor?
08:06:55 <maerwald> are those emacs key bindings?
08:07:03 <mniip> would you want Hom to be a profunctor on C^op rather
08:07:08 <dminuoso> % :i State#
08:07:08 <yahb> dminuoso: type role State# nominal; data State# a :: TYPE ('TupleRep '[]); -- Defined in `GHC.Prim'
08:07:29 <kryft> I read "would you want to be a profunctor"
08:07:32 <kryft> Career goals
08:07:40 <ChaiTRex> Is there a convention for naming things when you have a constant number that's both a value (Integer) and type (n :: Nat)? Like name and nameType or something?
08:07:45 <dmwit> Look at kryft over here. Amateur functor hour.
08:07:55 <kryft> :)
08:08:34 <mniip> dmwit, yeah they're probably not even bi
08:08:38 <dmwit> ChaiTRex: Surely it would be `name` and `Name`, no?
08:09:16 <dolio> Putting the op on the left is obvious due to the hom set.
08:09:22 <ChaiTRex> dmwit: Hmm, good point. I was doing undefined :: 1234
08:09:44 <dolio> The real question is whether you should consider the op the source or the destination of the profunctor.
08:09:52 <mniip> ChaiTRex, I use the same name
08:09:57 <dminuoso> % let return' x = \s -> (# s, x #) :: IO a
08:09:58 <yahb> dminuoso: ; <interactive>:12:23: error:; * Couldn't match expected type `IO a1' with actual type `(# p1, p #)'; * In the expression: (# s, x #) :: IO a; In the expression: \ s -> (# s, x #) :: IO a; In an equation for return': return' x = \ s -> (# s, x #) :: IO a; * Relevant bindings include; s :: p1 (bound at <interactive>:12:18); x :: p (bound at <interactive>:12:13); 
08:10:04 <mniip> case natVal :: p x of x -> ...
08:10:07 <dminuoso> % let return' x = \s -> (# s, x #) :: a -> IO a
08:10:08 <yahb> dminuoso: ; <interactive>:13:23: error:; * Couldn't match expected type `a1 -> IO a1' with actual type `(# p1, p #)'; * In the expression: (# s, x #) :: a -> IO a; In the expression: \ s -> (# s, x #) :: a -> IO a; In an equation for return': return' x = \ s -> (# s, x #) :: a -> IO a; * Relevant bindings include; s :: p1 (bound at <interactive>:13:18); x :: p (bound at <inte
08:10:11 <ChaiTRex> mniip: Is there a way to assign a type based on a runtime if?
08:10:13 <dminuoso> Oh!
08:10:14 <mniip> x the tyvar vs x the identifier
08:10:17 <mniip> can never clash
08:10:25 <dminuoso> % let return' x = IO (\s -> (# s, x #)) :: a -> IO a
08:10:26 <yahb> dminuoso: ; <interactive>:14:17: error:; * Data constructor not in scope: IO :: (a0 -> (# a0, p #)) -> a1 -> IO a1; * Perhaps you meant `I#' (imported from GHC.Exts)
08:10:36 <mniip> % import GHC.IO
08:10:36 <yahb> mniip: 
08:10:44 <dminuoso> % let return' x = IO (\s -> (# s, x #)) :: a -> IO a
08:10:44 <yahb> dminuoso: ; <interactive>:16:17: error:; * Couldn't match expected type `a1 -> IO a1' with actual type `IO p'; * Possible cause: `IO' is applied to too many arguments; In the expression: IO (\ s -> (# s, x #)) :: a -> IO a; In an equation for return': return' x = IO (\ s -> (# s, x #)) :: a -> IO a; * Relevant bindings include; x :: p (bound at <interactive>:16:13); return' :
08:10:47 <ChaiTRex> mniip: I need to have the type vary based on the number of bits in an Int.
08:10:49 <mniip> ChaiTRex, with existentials yes
08:10:49 <Boarders> just a sanity check, but this works the way I expect right? https://lpaste.net/5962572405476950016
08:10:49 <dminuoso> Mmm
08:11:02 <ChaiTRex> mniip: OK, I'll look into that. Thanks.
08:11:04 <mniip> you're better of with CPP and an ifdef
08:11:14 <mniip> in that specific case
08:11:30 <Boarders> (and more generally if I have a record with a bunch of fields with the same types then unsafeCoerce will go between them)
08:11:40 <ChaiTRex> mniip: I want to make sure the code will still work if GHC becomes a decent cross-compiler (unless there's a way to get that info about the target at compile-time).
08:11:58 <dolio> Boarders: Do you expect absolutely no guarantee that it works? :)
08:12:08 <dolio> Because that's true. :)
08:12:16 <mniip> Boarders, yes, if in the same order, none unpacked, with the same bangs and the same StrictData extension status
08:13:05 <mniip> Boarders, mind there was a nasty bug in older ghci related to this
08:13:18 <mniip> I remember because I fixed it!
08:15:01 <Boarders> dolio: :)
08:15:10 <Boarders> mniip: thanks!
08:16:41 <dminuoso> mniip: Okay thanks this is pretty cool :)
08:22:21 <dmwit> ChaiTRex: Have you considered using Int32 or Int64 instead?
08:22:44 <dmwit> These are Int-alikes with target-independent sizes.
08:23:29 <ChaiTRex> dmwit: It's for ByteArray# addressing, which uses Ints. I want to support as little or as many indexes as it allows.
08:24:03 * dmwit nods agreeably
08:26:46 <dminuoso> % newtype MyIO a = MyIO (State# RealWorld -> (State# RealWorld, a))
08:26:47 <yahb> dminuoso: ; <interactive>:17:45: error:; * Expecting a lifted type, but `State# RealWorld' is unlifted; * In the type `(State# RealWorld -> (State# RealWorld, a))'; In the definition of data constructor `MyIO'; In the newtype declaration for `MyIO'
08:27:12 <dminuoso> Why does newtype expect a lifted type?
08:27:13 * hackage hora 2.2.0 - date time  http://hackage.haskell.org/package/hora-2.2.0 (procione)
08:27:25 <dminuoso> That feels a bit arbitrary considering that newtype is erased
08:28:23 <mniip> dminuoso, (,) expects a lifted type
08:28:28 <AWizzArd> HLists, implemented by using all the powerful extensions that GHC offers (for example DataKinds) – this creates absolutely typesafe heterogeneous lists yes? I can’t ever read an element out of it without knowing exactly what I have? True?
08:28:52 <mniip> GHC.IO.IO uses (#,#)
08:29:11 <dminuoso> mniip: Oh heh yeah I see it now. I then ended up trying `newtype T = T Int#` which failed too
08:29:19 <dminuoso> % newtype T = T Int#
08:29:19 <yahb> dminuoso: ; <interactive>:18:13: error:; * A newtype cannot have an unlifted argument type; * In the definition of data constructor `T'; In the newtype declaration for `T'
08:29:35 <dmj`> What is the simplest way to make a binary instance for a GADT
08:29:51 <mniip> dminuoso, that restriction is probably historical and can be lifted these days
08:33:21 <dminuoso> mniip: From the bits I can gather it seems an artifact from `newtype` producing a type of kind * - there's a proposal to lift this indeed.
08:34:13 <lortabac> dmj`: maybe this can help https://www.well-typed.com/blog/2017/06/rtti/
08:34:38 <ChaiTRex> How do I assign a type at runtime. The two I want to choose are known at compile-time, but not which one will be chosen. How do I do something like `type (B :: Nat) = if b >= 10 then 123 else 456)`? It should end up with B being 123 or 456.
08:37:53 <dminuoso> ChaiTRex: What does "assign a type at runtime" even mean?
08:38:07 <Cale> ChaiTRex: That doesn't even make sense.
08:38:40 <dmwit> ChaiTRex: TH or CPP, perhaps
08:38:47 <ChaiTRex> Hmm...
08:38:49 <Cale> Those wouldn't be runtime though
08:39:00 <dmwit> Oh, true. For runtime, existentials.
08:39:23 <Cale> Yeah, I suppose "choosing a type at runtime" can be done with GADTs and existentials.
08:39:25 <lortabac> ChaiTRex: I think you are talking about dependent types
08:39:39 <Cale> Depending on what you really mean by that.
08:39:40 <ChaiTRex> lortabac: Yeah, I think so.
08:39:47 <dstolfa> what do you mean by dependent types
08:39:56 <ChaiTRex> Hold on. I'll go back to my actual problem. Maybe there's some other way.
08:39:59 <dstolfa> do you mean a calculus of constructions-like type theory that allows types to depend on terms
08:40:04 <dstolfa> or are you just talking about types depending on other types
08:40:08 <dstolfa> because the latter is what lists are as well
08:40:21 <dstolfa> i.e. a list of integers, a list of characters, ...
08:40:23 <pie_> would it be possible to generate a parser from a nested record?
08:40:42 <Cale> dstolfa: Types which depend on terms to be sure, because that's a way of interpreting "assign a type at runtime"
08:40:53 <lortabac> dstolfa: the former (types that depends on terms)
08:41:03 <ChaiTRex> I have this https://lpaste.net/4373222609450434560, where maxBitsProxy should be a Nat type that varies based on the machine word size.
08:41:21 <dstolfa> Cale: lortabac thanks. i usually ask that question when people say dependent types because it's not always clear what they mean :-)
08:41:35 <ChaiTRex> Is there an alternative way to accomplish that?
08:42:12 <ChaiTRex> Sorry, MAX_BITS_TYP should be maxBitsProxy as well.
08:42:26 <Cale> dstolfa: In here, I would expect it to usually mean types depending on terms. Types that depend on other types don't usually get a special word from Haskell programmers, they're too ordinary ;)
08:43:14 <dstolfa> Cale: better to clearly define it before a disagreement arises and suddenly we all figure out that we were talking about different things
08:48:09 <dmwit> I think "dependent types" has a pretty firm convention, at least in this community and the PL research community.
08:49:12 <dmwit> If you want types that depend on types, the convention there is "parameterized types".
09:09:45 <lalbornoz> anyone in here use haskero & visual studio code
09:36:07 <dminuoso> mniip: The IO type aside, because I think it actually was not what I wanted to know - but it's interesting to understand the IO type itself now.
09:36:48 <dminuoso> I suppose it's rather interesting what causes the side effects? Is that magic that happens inside the entry code of a thunk?
09:45:02 <mniip> dminuoso, the thunk has the type 'State# RealWorld -> (# State# RealWorld, a #)'
09:45:09 <`Guest00000> when i use my own main() in C instead of main in Haskell, is it absolutely safe to pass something other than (&argc, &argv) to hs_init()?
09:45:22 <mniip> so its "entry code" is really its application code
09:49:05 <koala_man> `Guest00000: yes
09:51:03 <koala_man> `Guest00000: the docs even have an example of this: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#making-a-haskell-library-that-can-be-called-from-foreign-code
09:51:09 <mniip> how confusing
09:51:30 <mniip> writeBinIface takes 'way' from dflags' "buildTag", not "ways"
09:51:51 <dminuoso> mniip: So it's that application code that, for example, might do some `read` on the disk to produce that `a`?
09:52:19 <mniip> I guess DynFlags has some invariants on those two fields.. considering updateWays
09:52:30 <mniip> dminuoso, yes
09:53:04 <khilan> Hello! I'm a bit stuck on a type error (its silly though). Code <https://gist.github.com/khilanravani/9e6c4c415a69ddd4bd32dd9a40ddabe3> Error message from line 81. Can someone plz help me figure out the type binding? Thanks in advance!
09:53:58 <Jacoby6000_> :q
10:02:08 <khilan> Can someone plz help me out with the above error msg?
10:03:54 <mniip> this has got to be some next level haskell hacking...
10:04:17 <mniip>  > :t undefined :: Maybe (UnsafeCoerceType (->))
10:04:17 <mniip>  Maybe (->)
10:05:00 <mniip> I had to modify a module's interface files!
10:08:31 <dmwit> khilan: I dunno, I haven't looked carefully, but it looks to me like you've mixed up an unboxed vector and a boxed vector?
10:25:51 <khilan> dmwit: yes, I think so too but didn't exactly understand what type binding to use...
10:29:40 <khilan> dmwit: The problem is mostly with hBins but I'm unable to figure out, how to correct it
10:32:28 <mniip> interesting
10:32:40 <mniip> so coercing between (a => b) and (a -> b) doesn't quite work as expected
10:36:28 <wraithm> Is there a library out there for deriving functions (not type class methods) for newtypes? Say I had: newtype MyIntMap a = MyIntMap (Map Int a), could I write a simple “derivingFunction MyIntMap Data.Map.lookup” that would specialize and do the newtype wrapping/unwrapping for lookup? Resulting in lookup :: Int -> MyIntMap a -> Maybe a. I don’t care if it’s implemented with template haskell, generics, or some other method. It’s kind of
10:36:28 <wraithm>  similar to generalized newtype deriving, only for functions, not typeclass methods.
10:36:28 <wraithm>  similar to generalized newtype deriving, only for functions, not typeclass methods.
10:41:28 <mniip> wraithm, how about 'lookup = coerce Data.Map.lookup'
10:41:32 <glguy> wraithm: Data.Coerce will help, you might have to add type signatures though, it's not automatic.
10:43:20 <wraithm> Oh neat! I did not know that worked for newtypes.
10:43:49 <mniip> that's about the only thing it works for
10:44:06 <mniip> newtypes and newtype accessories (roles)
10:44:11 <khilan> glguy: Can u plz help me out with <https://gist.github.com/khilanravani/9e6c4c415a69ddd4bd32dd9a40ddabe3> Error message from line 81. 
10:44:15 <wraithm> Yeah, makes sense... I don't know what I thought it was for, lol.
10:44:58 <eacameron> Anyone know why there's no instance of Foldable for Alt?
10:45:08 <mniip> khilan, as the error message says, you have two different types named Vector
10:45:21 <eacameron> Data.Monoid.Alt that is
10:45:37 <eacameron> Oh...nevermind. Because I'm not using 8.2
10:45:45 <khilan> mniip: yes, I did get that but couldn't figure out which type binding to use.
10:45:48 <eacameron> Or wherever that landed
10:46:17 <mniip> khilan, see what 'hBins' returns
10:47:41 <khilan> mniip: hBins is a Vector Int only <http://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image-IO-Histogram.html#t:Histogram>
10:54:03 <khilan> mniip: Also, can u plz suggest a way to get ride of the partial functions head, tail ?
10:54:43 <mniip> the tail is safe because scanl alawys returns a nonempty list
10:55:11 <khilan> Oh yes, okay.
10:55:15 <mniip> as for the head, there's no way to get rid of it because what if dropWhile returns an empty lisy
10:55:17 <mniip> list
10:56:00 <mniip> there's uh
10:56:02 <mniip> :t find
10:56:03 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
10:56:06 <mniip> you might be interested in
10:56:26 <khilan> Okay, I see. And for `!` ?
10:56:33 <khilan> mniip: Okay, I'll look it up
10:57:02 <mniip> no idea about that one
10:57:26 <mniip> 1534528037 [20:47:17] <+khilan> mniip: hBins is a Vector Int only <http://hackage.haskell.org/package/hip-1.5.3.0/docs/Graphics-Image-IO-Histogram.html#t:Histogram>
10:57:38 <mniip> Data.Vector.Unboxed.Vector
10:59:44 <khilan> mniip: oh right, I need to redefine the imports
10:59:47 <khilan> Thank u!
11:30:20 <fresheyeball> anyone know how the num instance for DiffTime works?
11:30:28 <fresheyeball> 1 = how much time?
11:32:46 <c_wraith> a second, I believe
11:33:27 <fishythefish> thought it was picoseconds
11:37:43 * hackage network-bitcoin 1.8.3 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.8.3 (wraithm)
11:42:45 <dmj`> I just want a nice template haskell thing to derive a binary instance for a GADT, is that so much to ask?
11:43:23 <madnight> if a package on hackage has outdated dependencies (e.g. last release 4 years ago) and the maintainer does not react to Issues, what is your recommend way to proceed? Fork the package, upgrade, re-release to hackage with other name and credits to origin?
11:43:28 <mniip> dmj`, what kind of GADT
11:43:49 <mniip> madnight, what's the package
11:43:59 <madnight> mniip: http://hackage.haskell.org/package/hpygments
11:44:01 <mniip> sounds like hackage trustees job
11:44:36 <mniip> you could ask to adopt the package if you're willing to maintain it
11:45:51 <madnight> mniip: okay i guess i wait a bit before i do that, maybe the maintainer responds now to the second upgrade request https://github.com/davidlazar/hpygments/issues/3
11:51:57 <monochrom> DiffTime is in seconds.
11:52:28 <monochrom> It does have fractional parts though.
11:55:57 <Boarders> is there any way to have types fully reduced in ghc type errors (when using type families)?
12:08:43 * hackage vault-trans 0.1.0 - A monad transformer for vault-tool  http://hackage.haskell.org/package/vault-trans-0.1.0 (mdunn)
12:12:01 <dmwit> fishythefish: 1 is a second, to picosecond precision.
12:13:03 <dmwit> Boarders: I don't think you can get them to be printed that way in errors, but you can ask ghci to reduce a particular type with `:kind!`.
12:13:16 <dmwit> % :kind! String
12:13:16 <yahb> dmwit: String :: *; = String
12:13:30 <lavalike> what's the exclamation point for?
12:13:38 <dmwit> uh
12:14:02 <dmwit> Actually I guess :kind! only reduces type families, not type synonyms, which I guess could be good or bad depending on your goals.
12:14:26 <dmwit> lavalike: The ! requests reduction; without it you get just the kind and not the reduced type.
12:14:39 <lavalike> fun
12:14:42 <dmwit> % :kind! 3+4
12:14:43 <yahb> dmwit: ; <interactive>:1:2: error: Not in scope: type constructor or class `+'
12:14:48 <dmwit> too bad
12:15:04 <Boarders> dmwit: thanks, unfortunately ghci is borked on this project
12:15:24 <dmwit> Boarders: If it is "borked" only because of type errors, consider -fdefer-type-errors.
12:15:31 <Boarders> no it is some ffi thing
12:15:42 <Boarders> which is thoroughly above my paygrade
12:15:47 <dmwit> In that case, -fobject-code may help.
12:26:42 * hackage hadolint 1.11.1 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.11.1 (lorenzo)
12:27:19 <isd> Hey all. I'm puzzling over an issue re: resource cleanup.  I have a bit of code that needs to (1) create a temporary file (currently using openTempFile), (2) do stuff with the handle (3) close the handle (4) do more stuff (5) delete the file. I'm not sure how to set up exception handlers so that this is async-exception safe. It doesn't seem like I can use bracket, since openTempFile creates two resources that need to be cleaned up at di
12:27:19 <isd> fferent times, and resourcet has the same problem. Is there a standard way to do this?
12:30:25 <isd> (I could write something low level with mask, but if there's a high-level way to do it that would be better).
12:30:42 <lavalike> isd: I know of this one post about this topic http://www.well-typed.com/blog/97/
12:32:21 <cocreature> isd: so your issue is that you want to close the handle before deleting the file?
12:33:57 <isd> cocreature: correct.
12:34:43 * hackage haskoin-bitcoind 0.3.0 - An adapter for haskoin to network-bitcoin  http://hackage.haskell.org/package/haskoin-bitcoind-0.3.0 (wraithm)
12:36:41 <cocreature> isd: I would probably just immediately close the handle (i.e. during resource aquisition) that you get from openTempFile in that case and then open a new one. that way you have two calls two bracket and your lifetimes are not tied together
12:37:43 <isd> cocreature: good thought; that's at least an improvement over the solutions I'd come up with (which all involved using mask and friends directly)
12:38:55 <cocreature> you should be able to completely avoid messing around with mask directly for my solution since exceptions are already masked during resource aquisition 
12:39:30 <cocreature> that said, I don’t think using mask is something that should be avoided at all costs. if you have a simpler solution using mask, then that might be perfectly fine
12:41:40 <isd> My ideas using mask are definitely not simpler. 
12:45:12 <Boarders> does anyone know if there are any papers that compare the relative "strengths" of what can be expressed by GADTs vs closed type families?
12:47:13 * hackage namespace 0.1.4.0 - A Generic Haskell library for managing namespaces  http://hackage.haskell.org/package/namespace-0.1.4.0 (xuhao)
12:50:25 <Wizek> I suspect MVar's aren't exactly created for fulfilling this purpose, but is it per chance possible to subscribe to them somehow? E.g. to get notified on all changes
12:51:40 <cocreature> Wizek: no
12:52:15 <cocreature> one alternative would be some kind of chan and dupChan
12:52:17 <lavalike> "there must be a better way!"
12:52:45 <lavalike> isn't there a one-capital-letter-Var that lets multiple threads be notified
12:56:26 <ChaiTRex> lavalike: This? https://hackage.haskell.org/package/stm-2.4.5.0/docs/Control-Concurrent-STM-TChan.html
12:56:31 <Wizek> cocreature: will that give me similar locking sematics as MVars with the added extra option for subscriptions?
12:56:33 <merijn> Chan's and dupChan, what was the question?
12:56:45 <merijn> Because I might have the exact right thing :p
12:57:01 <Wizek> merijn: this was: " I suspect MVar's aren't exactly created for fulfilling this purpose, but is it per chance possible to subscribe to them somehow? E.g. to get notified on all changes"
12:57:32 <merijn> Right, something like Chan would work, but Chan has a problem with 0 subscribers reading
12:57:44 <Wizek> merijn: how so?
12:58:03 <cocreature> Wizek: depends on how exactly you do this. you could proxy all operations through one thread that actually still uses an MVar but also writes all changes to a Chan
12:58:07 <merijn> Wizek: If no one ever reads a Chan everything you write in it is kept forever
12:58:20 <lavalike> ChaiTRex: I think that looks like what he might want!
12:59:02 <cocreature> lavalike: huh? that’s the Chan solution I described
12:59:09 <merijn> Wizek: I actually wrote a package to solve that issue https://hackage.haskell.org/package/broadcast-chan
12:59:32 <ChaiTRex> lavalike: There's also this if you're OK installing packages: https://hackage.haskell.org/package/broadcast-chan-0.1.1
12:59:50 <merijn> Which works even with 0 subscribers, the HEAD version actually has a bunch of other stuff, but I keep not getting around to finishing it for release :)
13:00:13 <lavalike> cocreature: you definitely did, I am not intimately familiar with the primitives so I don't know about M- T- Q- things, this one is TChan in particular, so I'm learning
13:00:31 <merijn> ChaiTRex: To be fair, it purposefully has like 0 dependencies beyond base :p
13:00:51 <merijn> ChaiTRex: Although the next version will probably depend on unliftio-core + transformers
13:00:55 <cocreature> merijn: how did you manage to upload docs for 0.1.1 but have hackage still not show the docs? ;)
13:01:13 <merijn> cocreature: oh...interesting...
13:01:23 <ChaiTRex> merijn: Oh, that's cool.
13:01:32 <merijn> cocreature: Good question, I uploaded a revision at some point
13:02:00 <merijn> ChaiTRex: I have some stuff for running a conduit in parallel too, but I keep getting distracted from finishing it up :p
13:02:01 <lavalike> so the idea is that broadcast-chan doesn't need you to use STM?
13:02:11 <lavalike> *require of you
13:02:27 <merijn> lavalike: The idea is "implement something that STM already has, but in a library, because people didn't want me adding it to base"
13:02:43 * hackage vault-trans 0.1.0.1 - A monad transformer for vault-tool  http://hackage.haskell.org/package/vault-trans-0.1.0.1 (mdunn)
13:02:51 <Wizek> looking into these, thanks for the tips
13:02:51 <merijn> lavalike: The next version I'm working on has a bunch more "batteries included stuff", but I haven't sorted out the API yet
13:03:17 <lavalike> merijn: what are the tradeoffs?
13:03:30 <merijn> lavalike: See the main page docs ;)
13:03:42 <lavalike> space leaks!
13:03:43 * hackage css-syntax 0.0.8 - This package implments a parser for the CSS syntax  http://hackage.haskell.org/package/css-syntax-0.0.8 (wereHamster)
13:03:45 <merijn> oh, wait, those aren't updated
13:04:16 <merijn> lavalike: the README has a list of trade-offs: https://github.com/merijn/broadcast-chan
13:04:39 <merijn> lavalike: Actually benchmarking it, STM is actuallly faster in a lot of situations
13:06:03 <lavalike> merijn: that was very clear, appreciate it
13:11:40 <cocreature> merijn: doesn’t TChan also suffer from the 0-reader problem?
13:29:40 <merijn> cocreature: TChan has a working broadcast/dupChan function in base already
13:30:02 <merijn> cocreature: https://hackage.haskell.org/package/stm-2.4.5.0/docs/Control-Concurrent-STM-TChan.html#v:newBroadcastTChan
13:30:14 <merijn> cocreature: Which is what got me to ask for adding it for Chan in base
13:30:52 <merijn> cocreature: Then people told me "first show people want it by making a library!", so that's what I did :p
13:31:21 <cocreature> merijn: ah nice, somehow I always missed newBroadcastTChan
13:34:32 <merijn> Honestly, the far more useful part is the conduit wrapper I have that runs a "a -> IO b" function N times in parallel 
13:38:42 <lavalike> cocreature: that's the one ChaiTRex posted!
13:47:27 <cocreature> lavalike: they linked to all of TChan which I did know about, I just didn’t know about newBroadcastTChan :)
13:52:27 <lavalike> haskell's full of wonders
13:52:50 <mbwgh> Does resourcet a way to prevent leaking handles from a MonadResource block?
13:52:55 <mbwgh> *provide a way
13:54:30 <MarcelineVQ> gotta say tho, merijn's makes it a lot clearer on what/how it's used
13:54:41 <MarcelineVQ> s/what/why
13:58:47 <T0pH4t> Hello all, quick question if I have a type class Foo and I have instances A and B. If I have a data type bar defined as "data Bar = Foo x => Bar x" Is it possible to declare an equal instance that only checks for equality when types are equal? Right now it just fails to compile because of type ambiguity which is understandable. 
13:59:54 <T0pH4t> basically can i declare explicit (==) instances for both A and B?
14:00:01 <T0pH4t> or some other trick i guess.
14:02:40 <Cale> T0pH4t: What does this have to do with equality?
14:03:17 <Cale> You want an instance of Eq for Bar? That's not going to be doable.
14:03:23 <T0pH4t> @Cale nvm I can explicity comare constructors
14:03:24 <lambdabot> Unknown command, try @list
14:03:53 <T0pH4t> you can just check for the permutations
14:21:07 <dmwit> T0pH4t: Sure, `data Bar = forall x. Foo x => NotEqual x | forall x. (Foo x, Eq x, Typeable x) => MaybeEqual x`
14:22:17 <dmwit> T0pH4t: `instance Eq Bar where MaybeEqual x == MaybeEqual y = case testEquality (typeOf x) (typeOf y) of { Just Refl -> x == y; Nothing -> False }; _ -> False`
14:22:40 <dmwit> oops
14:22:50 <dmwit> That last `_ -> False` should be `_ == _ = False`.
14:22:52 <T0pH4t> ahh ok
14:23:00 <T0pH4t> interesting way of doing it
14:23:36 <dmwit> Of course this violates reflexivity.
14:23:45 <dmwit> So I would recommend avoiding this.
14:24:09 <madnight> does nlab has no mobile friendly view :/?
14:24:44 <T0pH4t> I ended up with just doing case x of Bar A(..) -> case y of Bar A(..) -> True ->; _ -> False; Bar B(..) -> case y of Bar B(..) -> True; _ -> False
14:24:55 <T0pH4t> which i think is a better approach
14:24:55 <dmwit> Of course without your requirement that sometimes `Eq` isn't supported, you can do `data Bar = forall x. (Foo x, Eq x, Typeable x) => Bar x` and then there's no problem with reflexivity.
14:25:39 <dmwit> T0pH4t: Interesting. How did you do that? You shouldn't be able to match on `A`/`B` given only that `Foo x` holds.
14:26:03 <T0pH4t> All instance of Foo are known to the compiler
14:26:08 <dmwit> Incorrect.
14:26:20 <dmwit> The open world assumption is baked deep into Haskell.
14:27:09 <T0pH4t> Well it compiles, so it must. But my actual declaration is a GADT
14:28:13 <T0pH4t> so i have something like "data Animal a =>  Bear :: Foo a => a -> G Bear 
14:28:27 <T0pH4t> woops G= Animal
14:28:38 <T0pH4t> sry doing types on fly lol
14:30:04 * dmwit squints
14:30:08 <T0pH4t> so as long as a has an instance of Foo, I can just enumerate wha t I know and "_" what I don't. and it accepts that
14:30:41 <T0pH4t> i might be missing a piece. I have greatly simplified my real code
14:30:42 * Ariakenom laughs at "dmwit squints"
14:33:10 <T0pH4t> Woops I guess that was supposed to be "data Animal a where Bear :: Foo a => a -> Animal Bear" etc.
14:35:02 <T0pH4t> well even that was bad since Bear isn't a defined type when i use "Animal Bear" as type of Bear, but w/e. I hope I got my point across lol.
14:38:26 <dmwit> No, you didn't. I still have no idea what you've actually done, because what you've described so far doesn't sound like a thing that the Haskell I know is okay with.
14:38:45 <dmwit> If you've got something that's working for you, I guess it doesn't really matter. But I'm pretty confused about what you want and what you've got.
14:39:18 <T0pH4t> lol i figured
14:39:36 <T0pH4t> if i get time i might just put together a min example
14:51:21 <Zipheir> where Bear?
14:51:45 <ab9rf> werebear?
14:53:19 <lavalike> To become is to understand.
14:53:35 <emeraldemon> So if I'm using stack, should I move to the next stack lts every time it changes?
14:53:45 <emeraldemon> like 12.4 -> 12.5 -> 12.6
14:58:24 <philippD> I read somewhere that forall was comming to Constraints. To do stuff like `(forall a . c a b) => b`. Does anyone know the state of that or a good searchterm to find info with?
15:00:00 <pavonia> What are the semantics of that?
15:00:28 <dyl> That looks like it should be (conceptually): forall a. s.t. exists c a b ⇒ b?
15:00:42 <dyl> I'm not sure what that's supposed to mena.
15:02:17 <mnoonan> philippD: https://ghc.haskell.org/trac/ghc/wiki/QuantifiedConstraints
15:02:58 <philippD> Yeah, that's what I was looking for
15:03:20 <koz_> ab9rf: Werebear?
15:05:14 <dmwit> koz_: WEREBEAR?
15:05:29 <koz_> dmwit: WerEbEAr?
15:06:40 <dmwit> I you were to be especially attentive to the monster a second time, you would rebeware the werebear.
15:06:58 <koz_> dmwit: Not cobeware?
15:07:18 <dmwit> I don't think so, unless you're talking about a wecobear.
15:07:36 <koz_> What is a cobear even?
15:07:52 <dmwit> It's like, one unit of corn, right?
15:08:04 <koz_> Why corn and not honey?
15:08:12 <dmwit> Who ever heard of a cob of honey?
15:08:22 <koz_> Ah, cob-ear.
15:08:26 <koz_> I meant 'co-bear'.
15:08:27 <Cale> philippD: In the meantime, there's some stuff in Data.Constraint.Forall you can use
15:08:42 <Cale> http://hackage.haskell.org/package/constraints-0.10.1/docs/Data-Constraint-Forall.html
15:09:02 <philippD> Cale: yeah I'm looking at the source of that. Fucking wild
15:09:46 <mnoonan> you know, "sometimes you eat the bear, and sometimes the bear eats you". In the first clause, you're a cobear.
15:10:04 <Cale> I've been using ForallF a good bit lately... as well as some other gadgets...
15:10:08 <koz_> mnoonan: So does this mean all non-Soviet bears are in fact, cobears?
15:10:08 <Cale> class ArgDict f where
15:10:09 <Cale>   type ConstraintsFor (c :: k -> Constraint) f :: Constraint
15:10:09 <Cale>   argDict :: ConstraintsFor c f => f a -> Dict (c a)
15:10:25 <Cale> We have some TH which generates instances of this class.
15:13:12 <Cale> (The assumption is that f is a GADT, and this gives you a way to express that you can obtain instances of c for the argument to the GADT's type for any given value of it)
15:14:09 <dmwit> Looks handy.
15:14:14 <Cale> type Has c f = (ArgDict f, ConstraintsFor c f)
15:14:19 <Cale> has :: forall c f a r. (Has c f) => f a -> (c a => r) -> r
15:14:19 <Cale> has k r | (Dict :: Dict (c a)) <- argDict k = r
15:15:55 <Cale> So if you have some x :: f a, you can write  has @Monoid x (... stuff that uses an instance Monoid a ...)
15:44:43 * hackage preludeplus 0.1.0.2 - Generalizes List functions and replaces partials with NonEmpty equivalents.  http://hackage.haskell.org/package/preludeplus-0.1.0.2 (jnbooth)
15:55:33 <koz_> For Massiv, why are P and U distinct representation types?
16:01:43 * hackage throttled 1.1.0 - Concurrent processing of a Foldable, throttled by CPU count.  http://hackage.haskell.org/package/throttled-1.1.0 (fosskers)
16:06:44 <koz_> When I write module exports, how do I export a type but _not_ its constructors?
16:07:32 <glguy> module M (Type)
16:08:06 <koz_> glguy: Thanks!
16:20:22 <Squarism> There is no way of getting the name you set with labelThread in GHC.Conc?
16:23:30 <hpc> doesn't look like it, it's just for debuggers
16:23:55 <Squarism> hpc, thanks
16:24:03 <geekosaur> yes. note how it says it does nothing with a non-debugging runtime
16:24:17 <hpc> yeah i was about to say if i had to guess, it's not always present
16:24:56 <hpc> i was just reading something about how windows didn't get labeled threads until a few weeks ago
16:25:17 <hpc> or something like it, i wasn't reading too closely
16:25:28 <Squarism> geekosaur, i had a hard time accepting it. =D
16:38:24 <koz_> Am I allowed to write a signature of the form (:>) :: Foo -> Bar -> Baz? I'm getting a parse error.
16:38:38 <dolio> :> is a constructor name.
16:38:56 <koz_> My goal is to write an infix function.
16:38:58 <johnw> does anyone know how, using servant-streaming, to set the response headers?
16:39:24 <hpc> koz_: so you know how variables are lower-case and constructors are upper-case?
16:39:32 <hpc> koz_: ':' is the "upper-case" symbol
16:40:05 <koz_> hpc: OK, so no colon use?
16:40:11 <hpc> it just can't start with it
16:40:15 <koz_> Ah.
16:54:10 <johnw> or maybe more directly asked: is there any way to manipulate the response headers outside of using the api type?
16:57:38 <Squarism> Anyone know if theres some type of config file mechanism available through a library to configure hslogger ?
16:58:18 <Squarism> some quick way of setting priority per log-name that is
16:59:38 <hpc> that sounds like it would belong better as a section of your program's single config file
16:59:42 <hpc> instead of being broken out like that
17:02:02 <Squarism> hpc, true. Just used to log4j 
17:02:21 <geekosaur> how did I know that was coming
17:23:13 * hackage hw-prim 0.6.2.10 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.10 (haskellworks)
17:59:35 <d34df00d> Hi!
18:00:41 <d34df00d> How shall I list my C++ bits of code in a cabal file? I cannot use c-sources can I?
18:01:11 <d34df00d> I tried cxx-sources and it seems to work, but cabal complains saying this field is unknown.
18:02:02 <philippD> cabal only supports C afaik.
18:03:05 <dmwit> You can use extra-source-files to have the files included in the sdist tarball.
18:03:07 <philippD> You could try compiling as a dynamic library and link against it. At least that's what I tend to do
18:03:28 <dmwit> But it won't do anything about building/linking those files, as philippD says.
18:03:40 <d34df00d> Haha, interesting that cxx-sources and cxx-options work then! What's more interesting, having cxx-options in my .cabal with cabal-version of 2.0 makes cabal say that cxx-options are supported starting with version 2.1, but when I switch to 2.1, the warning goes away, but they're still considered as unsupported.
18:04:15 <d34df00d> dmwit: uh, that's a pity. I don't need them in sdist, I just have some extern "C"-d code interfacing with some C++ library that's I'm later using via c2hs.
18:04:31 <d34df00d> (I could have used inline-c-cpp as well, but it doesn't play nicely with stack ghci)
18:06:33 <mniip> you can hope that it might work if your cc is smart enough to call cc1plus instead of cc1 for .cpp files
18:08:00 <d34df00d> mniip: my next question would then be how to pass additional options to the c++ compiler as the library is C++11-only, and sticking -std=c++11 to cc-options looks like a bad idea.
18:08:44 <mniip> looks like it's a super new version only thing
18:08:59 <d34df00d> You mean cabal version?
18:10:19 <mniip> cabal 2.2
18:10:49 <d34df00d> I'm totally cool with supporting just that.
18:11:05 <d34df00d> Though I wan't able to find the docs on it, google shows up 2.0 :(
18:11:13 * hackage preludeplus 0.1.0.3 - Generalizes List functions and replaces partials with NonEmpty equivalents.  http://hackage.haskell.org/package/preludeplus-0.1.0.3 (jnbooth)
18:12:35 <mniip> the docs clearly mention "Since:	Cabal 2.2"
18:13:14 <d34df00d> Ah, https://www.haskell.org/cabal/users-guide/ is older, it seems.
18:14:22 <elpfen> is it an antipattern to define something like this: data Foo = Bar | Baz; toStr Bar = "BarStr"; toStr Baz = "BazStr" ?
18:16:09 <elpfen> It's sort of like static consts, and that seems wrong. I have another function that I want to constrain to a set of strings, so it takes in a Foo
18:20:04 <d34df00d> What's the right syntax to have a type associated with a type class of a kind other than *?
18:20:43 <d34df00d> class C (k :: Foo) where
18:20:43 <d34df00d>     type CType k :: Bool
18:20:46 <d34df00d> Or smth like that.
18:24:54 <d34df00d> Scratch that, I could just use a type family directly.
18:25:07 <d34df00d> type family (k :: CursorKind) :: Bool where -- neat
18:26:41 <elpfen> Answered my own question, mostly. I'm looking for show and read...
18:29:05 <elpfen> Corollary, is there a way to implement a type class while still using the typeclass function? Ex: show = toLower . show
18:29:27 <d34df00d> With a newtype, kinda what you want.
18:33:47 <MarcelineVQ> make your own function for that, don't be mean to show :>  data Foo = Bar | Baz deriving Show     showMyFoo :: Foo -> String; showMyFoo = toLower . show
18:34:40 <elpfen> Ah that sounds good
18:35:46 <MarcelineVQ> Show/Read are intended to create and read strings that are actual haskell code one could just as easily type into ghci and have work as is.
18:36:13 * hackage recursion 1.0.0.0 - A recursion schemes library for GHC.  http://hackage.haskell.org/package/recursion-1.0.0.0 (vmchale)
18:36:33 <MarcelineVQ> https://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#t:Show for more info
18:44:11 <pikajude> Is there a way for me to disable -Werror for a specific file?
18:49:19 <nisstyre> pikajude: {-# OPTIONS_GHC -Wwarn #-} maybe?
18:52:29 <pikajude> oh, that's right
18:52:35 <pikajude> i found it in the documentation right after i asked this question
18:52:37 <pikajude> bad habit of mine
18:52:39 <pikajude> thanks nisstyre 
18:52:44 <nisstyre> no problem I didn't know about it either
18:54:13 * hackage hw-prim 0.6.2.11 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.11 (haskellworks)
21:06:14 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
21:06:14 --- topic: set by glguy!~glguy@haskell/developer/glguy on [Thu Aug 02 09:06:51 2018]
21:06:14 --- names: list (clog revolving_ pacak tomsen Arcaelyx djbeau3 MoarSpaceFi Saulzar fujiy jedws oisdk khilan amiri danso XorSwap maddybutt ninedotnine floryst hamishmack blinkhard andyhoang theDon emilypi lagothri1 acarrico banc jle` PatrickRobotham ChaiTRex hucksy DTZUZO drbean djanatyn YongJoon Tops2 iross survove lassulus eschnett prakashdanish functionaldong d34df00d amirpro hololeap fakenerd klntsky coldpresent rprije jluttine lambda-11235 jb55 gentauro tombusby sbdchd)
21:06:14 --- names: list (cynapse graphene gienah Richard[m] dty flebron Destol urodna Blkt codesoup barrucadu joshsh mnoonan elfets lamba galingale nocm dvgroc[m] OnkelTem raingloom xinus_ T0pH4t tnks pavonia pfurla toovs kerrhau lawlesseel gabe4k Zipheir hph^ nurupo _bo carlomazzaferro zincy dpyro dan_f aarvar jdt dedgrant twandy zero_byte wildlander dstolfa jeeeunevans__ `Guest00000 mitchellsalad__ ptek juri_ kefin texasmynsted_ twk- colmeka[m] wonko77 xplat gyia piyush-kurur jkup)
21:06:14 --- names: list (Freechicks tristanp ekleog ft oldandwise Digit bjobjo tabaqui poljar1 sdothum Lears glguy dddddd ma27 bt ralu ericsagnes huytd valentinbuza bluepixel noam unlink2 dmiles catsup ashirase alex`` Christophe[m]1 verement kuttifunk Neo-- erikd cyphase nesakysiu hvr esp32_prog koz_ Moyst joof Maxdamantus jchia nyberg Foritus markus1199 justanotheruser tapeinos wollw yrid phreedom boj Axman6 RGamma _dga theorb Cale fionnan gabiruh madnight Tesseraction keegans_)
21:06:14 --- names: list (cheater lachenmayer nklap Fairy nckx themsay[m] ctag_ alx741 jjpk niklasl thaumavorio Kipras_ pie_ SCHAPiE raoulb Thra11 tomboy64 telser pikhq byorgey toure|gone Solarion beeman amuck ddellacosta pikajude renzhi ph88 duairc @Sigyn Cathy fryguybob henriksod shutdown_-h_now niko random_tester[m] ocharles[m] kedah[m] petrolifero[m] etarnvik[m] acomar[m] lurpam[m] kbobyrev[m] yhylord[m] dnk8n[m] wst[m] knoppaz[m] trigalero[m] squallcx[m] gregoiregeis[m] dotty[m])
21:06:14 --- names: list (frump[m] aquarial[m]1 traxticlet[m] dotglitch[m] +greeneyedfriend[ dial[m] Robert[m]1 arielze[m] lixl03[m] danielr[m]1 loco_joe[m] kxra[m] silasnordgren[m] qffr[m] ddavidd[m] ktaylora[m] lainon[m] vizowl[m] cbg[m] pikachoum[m] Ekho[m] rinor[m] trixon[m] mimi55555[m] revskill[m] guest3321[m] jbweston[m] feuerligin[m] chaseroycroft[m] effjay[m] slugwurths-reven dlilja[m] rhc[m] apigeon[m] M2mol[m] cryptomann[m] yajaru[m] vars[m] sevensidedmarble hylophile[m])
21:06:14 --- names: list (fre[m] psiska[m] smaller_infinity thisiswhereitype andresbach[m] aquarial[m] etcinit[m] tchernobog[m] seeh[m] srid[m] hsw[m] travankor[m] willyh[m] Movablyqueryingl kalhuzcxv[m] silvio[m] pagoda_5bIvanoPa Grgoire[m] killjoyy[m] XiaopongTran[m] tuxitagnu[m] arthurxavierx[m] intergalacticgot ddowl[m] simonmic[m] jeroenbulters[m] qwqdw[m] zoltanzuberi[m] acertain Fede[m] schum ambler[m] IAM[m] alexshpilkin[m] Noughtmare[m] michbad[m] k0d3fr34k[m] dubaduba[m])
21:06:14 --- names: list (applecluster[m] mtncoder[m] tet[m] Makinit[m] George[m] tmallard[m] asm[m]1 javjarfer[m] rihardsk[m] mith[m] BL[m] Hanma[m] exarkun sudoreboot02[m] freusque[m] braunseb[m] morgib[m] whoops[m] thekyriarchy[m] chreekat[m] coscomo[m] noteventime xobroll[m] thejonny[m] flyingclam[m] sudoreboot[m] lycium[m] roninkaizen[m] mujx[m] wuffie[m] TuXic[m] M0x8badf00d[m] Barnabas[m] jansc[m] masaeedu[m] aloiscochard[m] bmjh[m] lightandlight[m] KevinMGranger[m] fgaz)
21:06:14 --- names: list (abhir00p[m] johnnyv[m] MatrixTravelerbo HDurer[m] tfc[m] ahri[m] jibby[m] elijordan grumble nitaigao ByronJohnson piluex[m] sevanspowell[m] Squarism forell sellout- moei sqrt2 Eduard_Munteanu YellowOnion cbarrett revprez_1nz DTZUZU monochrom Khisanth tinwood urdh shrifbot pwestling jzl NinjaTrappeur Durbley yaroot_ kmill platz ixian8 Ckat lalbornoz cpape meck obfusk nnplv milli DwarfMaster xpoqp SquidDev etrepum mazzafish jix +kryft nopf m4lvin jml duncan^)
21:06:14 --- names: list (Lord_of_Life hc Dabo elpfen alanz abbe metalrain nyaray_ pasukon bradparker pgiarrusso ranberry_ bcoppens bas080 Unhammer lag keep_learning +aleator joncfoo dave_uy armyriad sdx23 nyaomi orekix revprez gspia loli Vq dolio ion kav maerwald jimki keri opqdonut quaestor fugyk revprez_stg megaTherion jzono1 albel727 cic jp leah2 caa51h hjozwiak perrier-jouet Tehnix violeta electrocat toppler cn28h pranz hodapp tv wonko7 earthy nshepperd verlet64 mingc howdoi rofl__)
21:06:14 --- names: list (LastTalon +MarcelineVQ Sgeo jkarni cloudhead kwantam Hijiri jorj polman vaibhavsagar c_wraith bornjre lavalike HallaSurvivor SolarAquarion jw358 pierrot aminb buhman dilettante wrengr_away rafadc fluxit tylerjl kiprasz HalfEatenPie ynyounuo rodgzilla hackage jophish ArahaelPi bydo Taneb spoke_ PyroLagus sis7 catern shiona__ FransWillem ljhms Cerise Cthalupa Zialus themagician _flow_ kqr Xal acro cocreature solarus carc aijony typedrat_ fairfiel- dredozub-)
21:06:14 --- names: list (subleq_ bertschneider_ tjbp_ terrorjack hydraz ryzokuken hsribei angerman georgew elvishjerricco arkeet` badzergling_ benl23_ gothos_ UnlawfulMonad tsahyt insanitea trebuh dyl iryp lugh runeks jakehehrlich benzrf +stemarsh mrd ekrion UpsideDownRide_ yarnspinner Kneiva sdrodge araujo Guest50042 sujeet jmnk R0b0t1_ bdw atk betawaffle Salek xaimus bbaren markmarkmark Wamanuz2 lnostdal cods Arider mahalex Guest14872 cjwelborn mauke UserOO7 Ramanga Jackneilll sudden)
21:06:14 --- names: list (mattp__ peutri omilu pepijndevos bodie_ Ewout AndreasK akshayn Enigmagic korans soncodi Adeon m0rphism1 jstolarek loc yahb redfish64 so mceier veverak jdnavarro ahihi aldum marble_visions milesrout swalladge burp nullifidian Philonous aurieeeh petercommand rawles runde implementation Tspoon_ cgfbee dilinger revprez_atlanta Orbstheorem karahobny guibou pta2002 amx glowpelt eldritch anderson ego jackieh_ mrm NH dgpratt zaquest n3parikh RahulS _Sp4rrowh4wk_)
21:06:14 --- names: list (yushyin noctux acowley haroldwu thebnq vimto dfordivam ephemera_ tomku|two dukedave eacameron worch treehaqr bind Konehaltia tdammers __name__ ongy greymalkin Thalheim absence lantti [df] ycheng spopo dan64- drdo ventonegro mutantmell haircode_ aweinstock Clint ggVGc jfredett_ haveo_ jit10 lc_ sm sariyar a3f edwardk infty sw4n makergrl wagle chin-tastic hugo teto jchia_1 lukelau michalrus magicman mimi_vx mountaingoat sms DexterLB Ranhir lispy lambdabot)
21:06:14 --- names: list (MindlessDrone ruffy_ capisce Natch pmade mnrmnaugh arw ClaudiusMaximus irclogger_com Amadiro CindyLinz spacebug pakettiale stvc2 shachaf kaol hpc c-rog_ kipd wtw vin-ivar meinside xacktm Klumben mikeplus64 SegFaultAX Entroacceptor iphy Jonno_FTW unsymbol jrib spoonm nshepperd1 phz^evoke pong esph malthe hive-mind asjo TimWolla cross stefan-__ Niamkik noexcept_ Adluc dh cyberlard iron_houzi Majiir ambrosia tazjin Guest46810 scinawa azahi gnusosa Profpatsch)
21:06:14 --- names: list (habbah_ isacl_ jonrh jinblack sclv scav fnurglewitz PLPD-Bot yumh pita paraseba geronimogarcia bonz060 isenmann machinedgod Madars ab9rf Patternmaster Meanirelli reda dqd bengt_ Velpoman lyxia ds- Tritlo int-e cjay- MTwister troydm mupf canta robertm1 Ivan__1 ryantm dibblego v0d1ch rom1504 jackhill aRkadeFR m1dnight_ Ekho zymurgy Putonlalla scroll uptime stilgart sheyll thallada rootnode_ gluegadget infinity0_ obiwahn Wizek averell cgoldammer valdyn)
21:06:14 --- names: list (reverse_1ight tessier nicoulaj divVerent stux|RC bigs aib tlevine wayne @ChanServ zzz rkrishnan AWizzArd beerdrop underikar jeeger hiredman trosa dminuoso incomprehensibly peschkaj systemfault paf31 natim87 fingerzam Charn rzmt Unode gsingh93 rntz seliopou mou nille lpsmith d6e_ debugloop bwe Nik05 EricZou pulec lieven bs efskap APic nemesit|znc mpickering Zemyla clever arahael reptar_ hiptobecubic dpower asm89 +Logio geal adamCS carbolymer jonge Ke Drezil_)
21:06:14 --- names: list (lstdgtfp mgaare_ endojelly tkr karlguy CrazedProgrammer Paks bshelden mxf_ l\i\a hashworks aramiscd tripty jesyspa jvanbure bod_ nwf otulp ^|{`-}_{ Guest3833 wamaral eyenx oberstein d3lxa drewbarbs alexknvl hongminhee m0ar chindy infinisil thoradam statusfailed byte512_ Jello_Raptor wraithm nimbleark kriztw ironChicken raatiniemi sigmundv_ beka Flonk rookie101 eagleflo MasseR wildsebastian heyj Jaxan dustinm coeus aksz mcspud swhalen lowryder wz1000 Myrl-saki)
21:06:14 --- names: list (duoi t36s jrslepak jetpack_joe alp monad_cat dmwit iskm feepo_ kaychaks christianpoveda Zoddo Tuplanolla Randy nullie liff cesardv qzo zerokarmaleft trobotham bgamari typetetris ocharles hsiktas chelfi mstruebing jzelinskie johs ajmcmiddlin Kamuela sppky plaeremans Deadhand M2tias GreenSand ancarda Akii datajerk rotty srk mjrosenb runit orzo beaky bspar idupree ectos Annihitek xnyhps coot statusbot Folkol miklcct tolt ncl28 uwap rotaerk c50a326 philosau1 ecx)
21:06:14 --- names: list (mniip liste pdxleif nuxdie_ stiell qdickon nek0 epta bjs Forkk Geekingfrog lukeshu tismith adamse chriswk newhoggy agrif tureba cow-orker geekosaur zaiste llwu h30 ibttis bollu alek1 srhb Deewiant ackthet jtrate Intensity joel135 hoke_t joeyh DDR PoliticsII ziman totallymoony +croben_ dsal nsnc davl +oak apoc Xandaros dschoepe_ echoreply6 awx_ phadej dysfigured kubrat yazmir8azyr brisbin rizary Neo erg jtcs klugez integral qz pyrtsa carter flux [exa] Argorok_)
21:06:14 --- names: list (rann cheshircat Liskni_si Ferdirand comboy gargawel micro +greeny__ pharaun nisstyre Sceinox kosmikus kadoban oldnborg sshine luigy mgttlinger Fylwind- umpc blackdog linduxed EvanR ring0` Hafydd dexterfoo bartavelle TommyC cynick adarshaj int0x27h hexagoxel scav__ kloeri davean srid bitemyapp bafain shapr deu milessabin defanor Saizan quicksilver zipper Rembane ij noplamodo Jon Athas rootmos_ centril ammar2 gonz_ SlashLife PHO__ exio4 koala_man exferenceBot)
21:06:14 --- names: list (mankyKitty mmaruseacph2 baweaver nitrix joeytwiddle suzu CrunchyChewie diginet mitch_ abra0 runawayfive nilOps)
21:31:40 <libertyprime> is haskell the one true programming language?
21:33:08 <infinisil> libertyprime: Nope, Jot is the only one true programming language
21:35:51 <infinisil> http://www.nyu.edu/projects/barker/Iota/
21:42:50 <Cale> libertyprime: Haskell certainly isn't perfect, but it's better at most things than anything else which is practical for real world use right now.
21:47:00 <jle`> libertyprime: depends on what you mean by "true"
21:57:46 <suzu> haskell's got it's problems
21:58:02 <suzu> it is pretty damn good though, i would be so upset to go back to say, python
21:58:10 <suzu> tbh i might even quit, idk
21:58:25 <Cale> Yeah, the thing is, it's hard to complain when everything else is just so unbelievably poor
21:58:54 <suzu> i've yet to play with rust. i heard it's setting the bar in it's own way too
22:10:20 <mniip> is there any way I can split a type application without GADTs?
22:10:36 <mniip> or TypeFamilies, or anything else involving coercion axioms
22:12:56 <mniip> a different formulation of the same question would be, can RankNTypes alone be used to prove generativity of type applications
22:30:25 <arahael> Cale: Kotlin, F#, and Swift seem to be gaining ground, at least.
22:31:49 <arahael> Which, hopefully, brings things up from "unbelievably poor", to "poor"> :)
22:45:02 <dataN_> undecidable cyclic instances; cant decide to add a list modifying function to a list or use it to modify the list, can a type annotation help? https://lpaste.net/7609130925368016896
23:08:19 <dataN_> is there a way to use synonyms to direct the path along which constraints are resolved, or are two synonyms of the same type always exactly equivalent?
23:10:56 <dmwit> Think of type synonyms as a macro system.
23:11:08 <dmwit> The macros are completely expanded before they even make it into the compiler.
23:11:50 <dmwit> Everywhere you write String, the compiler just sees [Char].
23:13:58 <mniip> that's only true to some degree :P
23:16:21 <dataN_> but in this example there is no additional information to direct the compiler
23:16:56 <mniip> but in general yes, type synonyms don't affect any decision made in the typechecker
23:17:17 <mniip> other than cosmetic decisions such as when displaying a type for the user in an error or GHCi command
23:17:50 <dataN_> and there is no way to use classes which are equivalent to give these names also? 
23:18:01 <mniip> clauses?
23:19:56 <dmwit> I don't understand the question. What are "these" in "to give these names also"?
23:20:17 <dataN_> e.g. class StateS s a = Exists (StateS_T s a); class Get f a = Exists (State_T (f a) a) === StateS (f a) a
23:21:41 <dataN_> so that then instances of StateS could be used by directing the compiler using the name "Get"
23:23:31 <dataN_> actually in the example it should be Set, which can be distinguished between either Act ([a] -> [a]) as in function application or as in cons.
23:25:51 <mniip> what
23:25:53 <dmwit> same
23:26:06 <mniip> none of this even remotely makes any sense
23:26:16 <mniip> if you introduce new syntax please explain what it means
23:27:09 <dataN_> the problem is that the functions are defined in terms of the most general class and that making equivalent classes with different names to help the compiler means these functions cant be used.
23:27:41 <dataN_> oh sorry, that is a typo.
23:28:36 <dataN_> class should be type... also, class Exists x where exists :: x
23:29:31 <dataN_> oh right and then they are just undecidable type synonyms, thats why classes were used, sorry it should be;
23:30:12 <cocreature> to make this very clear: no you can’t use type synonyms to change which instance is selected
23:30:21 <dataN_> class StateS s a = where stateS :: StateS_T s a; class Get f a where get :: (State_T (f a) a)
23:33:55 <dataN_> the problem is how to direct which instance to use when the types are identical so that TypeApplications cant help. 
23:33:56 <mniip> dataN_, and your question is?
23:34:10 <mniip> "when types are identical"?
23:34:15 <cocreature> use a newtype so the types aren’t identical
23:34:21 <dataN_> https://lpaste.net/7609130925368016896
23:34:30 <mniip> do you have a simplified example
23:35:22 <geekosaur> or add a phantom type to it so you can use e.g. a proxy to select an instance by that type. but if the types are identical, that's all the typechecker knows so it *can't* choose one over the other
23:35:27 <libertyprime> ainfinisil: jot and iota; intriguing
23:36:41 <mniip> dataN_, so you're asking that 'next @(s, x)' does one thing while 'next @(x, s)' does another?
23:36:47 <dataN_> geekosaur: not sure if proxy types add more than TypeApplications...
23:37:03 <dataN_> mniip, no
23:37:14 <geekosaur> they give you hooks for TypeApplications to use
23:37:21 <mniip> you have two Next instances here
23:37:26 <mniip> they're in obvious conflict
23:37:27 <geekosaur> TypeApplications can't add things that aren't already there
23:39:34 <dataN_> mniip: thats false. 
23:40:29 <mniip> no, it's true
23:40:43 <dataN_> there is only one Next instance!
23:40:47 <dataN_> the problem is;         instance forall a. Act a [a]         instance forall x. Act (x -> x) x
23:40:50 <mniip> you have a commented out one
23:40:55 <dataN_> !!!
23:41:13 <mniip> you didn't provide any Act instances in your pastd
23:41:19 <mniip> ah sorry you did
23:41:34 <mniip> right
23:43:29 <mniip> dataN_, consider type family F where F = [F -> F]
23:43:39 <mniip> what would   Act (F -> F) F  be?
23:43:53 <dmwit> (No type families needed. What would `act (id, [])` be?)
23:44:12 <dataN_> either [id] or []
23:45:40 <mniip> dmwit, so, id ;: F -> F, [] :: [F -> F]   :P
23:45:41 <dmwit> (But rereading the text above, I suspect they already know that this is a problem.)
23:45:52 <dataN_> true
23:46:44 <dmwit> You could add a phantom parameter.
23:46:58 <dataN_> thats the f1 and f2 both appearing as  @([a]->[a])
23:47:02 <dmwit> `class Act p f x where act :: (f, x) -> x`
23:47:24 <dataN_> it wouldnt have more information than the type?
23:47:47 <mniip> dmwit, AllowAmbiguousTypes?
23:47:48 <dmwit> data ConsOrApp = Cons | App; instance Act Cons x [x] where ...; instance Act App (x -> x) x where ...
23:48:14 <dmwit> `act @Cons` will pick one instance, `act @App` the other.
23:48:22 <dataN_> hmm
23:49:52 <dataN_> seems like a reasonable replacement for function names or class or type synonyms or newtypes in this setting. could be the best available option.
23:50:21 <dmwit> I don't really see what this Act class is buying you, to be honest.
23:51:10 <mniip> yeah, feels a lot like
23:51:33 <mniip> class Apply a b c | a b -> c where apply :: a -> b -> c
23:51:50 <mniip> instance Apply (x -> y) x y
23:52:09 <mniip> iow, not really generalizing anything
23:52:29 <dataN_> right, that was the point about the proxy not helping
23:52:41 <dataN_> it has to be strictly more informative than the type.
23:54:42 <dataN_> does the idea using pattern matching on classes work? seems like they would then be equivalent as type synonyms, and a similar additional name parameter flag would be required...
23:57:36 <dmwit> You have a bad habit of using dangling references. It makes you very difficult to understand.
23:58:06 <dataN_> is there something like newtypes for classes? 
23:58:26 <dmwit> class Old a => New a; instance Old a => New a -- sort of
23:59:08 <dataN_> not sure that would help here...
23:59:42 <dmwit> I honestly have no idea where here is, or why we need help at that location.
