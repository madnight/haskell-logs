00:00:44 <Axman6> generally yes
00:06:59 --- mode: glguy set +v aleator
00:07:18 <aleator> Hello! Is there any pre-cooked solution for making aeson instances for Generic f => (Fix f)?
00:10:40 <dminuoso> Axman6: I find that surprising because it produces completely invalid prometheus metrics..
00:36:33 --- mode: glguy set +v robstrrr
00:36:56 <robstrrr> Recently I run into a strange problem, when running `cabal configure` I receive `Not in scope: type constructor or class `ProgramSearchPath` while running `cabal new-configure` works.  What happens here ?
00:39:21 <cocreature> robstrrr: does "cabal new-build" work as well? I’m not sure if new-configure does everything configure does
00:40:18 <robstrrr> cocreature: yes, still works
00:41:01 <cocreature> robstrrr: hm weird, maybe it’s picking a different version of Cabal? can you show us the full error message
00:44:00 <robstrrr> cocreature: https://gist.github.com/rsoeldner/1597b67ddd2fd68f225bccd32cebe5f4 with ghc 7.0.4 (by accident) but strange outcome ...
00:44:40 <cocreature> robstrrr: ghc 7.0.4 probably also comes with an ancient version of Cabal which is just too old for this project
00:48:24 <sm> is there an easy way to programmatically redirect one handle to another ? I'd like to make hunit's stderr output appear on stdout
00:48:57 <sm> perhaps it's as easy as let stderr = stdout in ... ?
00:49:07 <liste> sm: can you do it outside the program?
00:49:55 <sm> not really.. in the same program I'm printing easytest output which is on stdout, I'd like both outputs on the same handle
00:50:07 <mniip> dup2?
00:51:03 <sm> aha, I'll try that. Thanks!
00:51:21 <cocreature> https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-IO.html#v:dupTo is the binding to dup2
00:52:20 <sm> better, thank you
00:52:42 <mniip> !
00:52:52 <mniip> I've never considered that '2' stands for "to"
00:52:58 <mniip> in this particular case at least
00:53:27 <sm> seems unix specific though
00:53:31 <mniip> next you're going to tell me 'wait4' is "wait for" :P
00:53:33 <sm> not available in unix-compat
00:53:40 <sm> so that's out for me
00:55:56 <asheshambasta> anyone here using Beam for databases? 
00:56:17 <asheshambasta> (https://github.com/tathougies/beam)
00:56:30 <sm> I guess I'll modify the hunit code
00:57:43 * hackage say 0.1.0.1 - Send textual messages to a Handle in a thread-friendly way  http://hackage.haskell.org/package/say-0.1.0.1 (MichaelSnoyman)
00:58:11 <mauke> sm: http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-IO-Handle.html#v:hDuplicateTo
00:59:03 <sm> there it is! knew it. Thanks
01:01:39 <sm> mauke: would you think that's thread safe ? 
01:01:58 <sm> eg if I redirected stderr in one thread and not another
01:14:09 <mniip> sm, stderr is process-global
01:28:09 <sm> I modified runTestTT, it was only a line
01:29:21 <sm> any other easytest users here ? have you found weaknesses ?
01:44:04 --- mode: glguy set +v emacstheviking
01:48:25 <lag> Good morning
01:48:55 <lag> Does anyone know why Haskell (GHC) isn't being built for aarch64 anymore?
01:50:58 <cocreature> lag: my guess would be that there is just not that much demand for it. for most aarch64 systems you probably want to cross-compile instead of compiling on the system itself
01:51:32 <lag> cocreature: What makes you say that?
01:52:19 <cocreature> as a rough rule of thumb, most aarch64 systems are probably less powerful than your desktop or laptop
01:53:40 <lag> cocreature: I can provide you with 100 examples to the contrary :)
01:54:08 <cocreature> sure, I never said that this is true in all cases
01:54:18 <lag> cocreature: Not least the 64core 256GB RAM beastie sat behind me :)
01:55:07 <gentauro> lag: can I please haz?
01:55:32 <lag> gentauro: ?
01:55:34 <lag> gentauro: Have?
01:55:40 <lag> gentauro: No :)
01:55:43 <yushyin> now if performance would really just add up with numbers of cores! :D
01:55:45 <gentauro> lag: do you even internet? :|
01:56:05 <lag> gentauro: I have completed the internet - twice
01:56:49 <gentauro> it's the right thing to do -> https://www.youtube.com/watch?v=iDbyYGrswtg
01:57:26 <mniip> lag, on hard mode?
01:57:32 <gentauro> lag: but does your desktop really have 64-cores? Le why?
01:57:46 <gentauro> I mean, to CS and/or Minecraft ...
01:57:56 <mniip> probably not a desktop
01:58:05 <mniip> can hardly imagine a non-x86 desktop
01:58:27 <ArahaelPi> mniip: I'm using a non-x86 desktop. :)
01:58:53 <ArahaelPi> But I'm probably just being very odd here.
01:59:57 <gentauro> ArahaelPi: raspberry pi? (guessing from your name)
02:00:16 <ArahaelPi> gentauro: Indeed.
02:00:25 <ArahaelPi> It's an Arm7 with 1GB RAM.
02:01:05 <gentauro> ArahaelPi: you aren't doing Haskell dev on it right?
02:01:44 <ArahaelPi> gentauro: No, though I did install haskell stack on it.  Crashed and burned twice, but it got in.
02:02:43 <ArahaelPi> Stack ghci comes up decently fast.
02:03:04 <ArahaelPi> (In roughly 2.6 seconds)
02:03:17 <Ke> lag: Talos2?
02:03:31 * lag feels like he's back at school!
02:03:45 <lag> Anyway ... back to my original request
02:04:15 <Ke> mniip: right now there are loads of choices for non-x86 desktops
02:04:21 <lag> So silicon vendors are brining out a great many Aarch64 based platforms
02:04:29 <lag> bringing*
02:04:38 <Ke> mniip: besides SBCs there is Talos2 and some ARM servers
02:04:49 <lag> Lots of small platforms i.e. Phones/Tablets, but also lots of servers
02:04:58 <ArahaelPi> Trouble are all the variations.
02:04:58 * asheshambasta likes Selda (https://selda.link/tutorial/ch1-example-explained/) a lot
02:05:18 <ArahaelPi> The RPi has a custom build of debian, even though debian already supports ARM.
02:05:42 <lag> I'm working ong enabling lots of different projects for ARM64 -- most already support them, but there are a few that are trying to catch up
02:05:59 <lag> Not many *stop* supporting Aarch64 after initially supporting it 
02:06:06 <lag> I was wondering what happened to Haskell 
02:06:16 <lag> I can see support in earlier versions 
02:06:38 <lag> http://downloads.haskell.org/~ghc/latest/
02:06:55 <lag> Anyone I can speak to that has any knowledge of the pre-builts?
02:07:05 <ArahaelPi> loc: I think the #reflex-frp cater to apple's particular variant of ARM64.
02:07:13 <cocreature> there is a limited amount of manpower, I’m pretty sure that if someone steps up to help out with aarch64 builds we should be able to get them back
02:08:15 <lag> cocreature: Aren't your builds automated?
02:08:37 <cocreature> afaik they aren’t fully automated but I’m not a ghc maintainer
02:24:33 <pgiarrusso> lag: I haven’t rechecked recently, but GHC’s build system hasn’t been state of the art for a while
02:25:08 <lag> pgiarrusso: That is not a good advert for Haskell :'D
02:25:15 <tazjin> there was (I swear!) a function in one of the basic servant libraries that generated a textual sitemap from an API description, but I can't seem to find it again
02:25:20 <tazjin> does someone where this function is and what it's called? 
02:27:35 <pgiarrusso> lag: maintainers are volunteers, and they perceive the cost of building GHC as lower than messing with build scripts in bash. The real downside is when building patch releases or supporting less common platforms.
02:28:06 <dminuoso> tazjin: https://haskell-servant.readthedocs.io/en/stable/tutorial/Docs.html
02:28:13 <lag> pgiarrusso: Bash? *mind blown*
02:28:22 <lag> pgiarrusso: Don't you guys use CI?
02:28:30 <dminuoso> tazjin: You could also do it yourself. I recently figured out that it's really easy to consume servant types :)
02:28:40 <dminuoso> It looks far scarier than it really is
02:29:00 <pgiarrusso> lag: uh? Even with CI, how do you write your build scripts? Surely not all in Haskell
02:29:17 <tazjin> dminuoso: yeah, I'm comfortable with them but I thought the function existed somewhere :) needed it to demonstrate something. Thanks! 
02:29:18 <dminuoso> pgiarrusso: make can get you quite far if you have special needs.
02:29:42 <lag> pgiarrusso: ASM
02:29:44 <lavalike> tazjin: I can only find the reverse, maybe you're remembering this? https://hackage.haskell.org/package/servant-0.2.2/docs/Servant-QQ.html
02:29:45 <Taneb> Didn't GHC change its build system to something to do with Hadrian recently?
02:30:04 <pgiarrusso> dminuoso: sure, most of it uses make, I used “bash
02:30:09 <pgiarrusso> very loosely
02:30:27 <cocreature> Taneb: currently hadrian and the make-based build system are maintained in parallel with the default still being the make-based build
02:30:32 <dminuoso> lavalike: Oh neat I thought that was still in discussion.
02:30:35 <Taneb> cocreature: ah, I see
02:30:52 <dminuoso> lavalike: I prefer types still simply because combinators.. :P
02:30:56 <lavalike> tazjin: oh maybe it's this: https://haskell-servant.readthedocs.io/en/stable/tutorial/Docs.html in particular markdown :: API -> String
02:31:50 <lavalike> dminuoso: I'm liking what I'm finding too!
02:32:37 <dminuoso> lavalike: QQ seemed to weird when I got into Haskell, but now Im starting to really like it. :)
02:32:45 <dminuoso> It beats shoehorning a DSL into a language
02:33:03 <lavalike> sometimes it can be a wonderful tool
02:33:24 <dminuoso> lavalike: Have you seen regex-heavy?
02:33:34 <lavalike> not yet but I'm gonna now!
02:33:39 <dminuoso> err *pcre-heavy
02:33:42 <dminuoso> https://hackage.haskell.org/package/pcre-heavy
02:33:54 <cocreature> lavalike: fwiw that link to the servant docs links to an ancient version. that module doesn’t seem to exist anymore
02:34:04 <lavalike> cocreature: aww ):
02:34:08 <dminuoso> It's the first regex library I found that feels *just right* and as easy to use as regex in say perl or ruby :)
02:34:11 <lavalike> I found it through the home page
02:34:53 <lavalike> dminuoso: nice find, will have to keep it in mind
02:35:12 <dminuoso> lavalike: and it works with Text/ByteString.
02:35:25 <dminuoso> That's just the icing. :)
02:36:23 <lag> Where is the code for GHC?
02:36:25 <lavalike> cocreature: servant-docs on hackage (latest version) does seem to provide markdown :: API -> String amongst other things
02:36:37 <lavalike> lag: http://github.com/ghc/ghc is a place
02:36:38 <lag> I found Cabal on GitHub
02:36:51 <lag> lavalike: It's not under Haskell?
02:36:55 <lavalike> apparently!
02:37:05 <cocreature> lavalike: I was referring to the quasi quoter you linked, not the markdown thingy
02:37:10 <lavalike> oooh
02:37:20 <merijn> GHC github is a mirror
02:37:28 <merijn> Actual development of GHC is not on github
02:37:35 <merijn> unlike the things under the haskell organisation
02:37:41 <lag> Looks like it uses Travis - CI, no?
02:37:44 <merijn> No
02:37:54 <merijn> GHC uses Phabricator and a self-hosted git repo
02:37:59 <lavalike> cocreature: man you're right, it's soooo old
02:38:35 * lag Googles Phabricator?
02:38:54 <lavalike> the github mirror is easier to access (:
02:39:56 <dminuoso> lag: It's the facebook stack.
02:40:06 <lag> lavalike: merijn: cocreature: Any idea who did build Aarch64?
02:40:12 <lag> dminuoso: Thanks
02:40:18 <vaibhavsagar> does anyone know how the GHC API changed between 8.4 and 8.6?
02:40:33 <dminuoso> lag: Did you check https://ghc.haskell.org/trac/ghc/wiki/Arm64
02:40:40 <lavalike> dminuoso: is that true? It looked to me when I delved in a bit that it was some random company making it
02:40:42 <vaibhavsagar> I'm having this weird issue where my code typechecks but the tests seem to spin forever
02:40:57 <vaibhavsagar> i.e. the types, they do nothing!
02:40:58 <lag> dminuoso: I cannot check what I did not know existed -- thanks for the link that's helpful :)
02:41:24 <dminuoso> lag: It came out of facebook yes, it was moved into a dedicated company later
02:42:00 <lavalike> I was writing a client for it and it was a headache, the documentation wasn't in sync with what was actually happening on the endpoints
02:42:10 <lag> dminuoso: That's oooooold
02:42:54 <dminuoso> I absolutely *love* the advertisement notes about phabricator
02:42:55 <dminuoso> "Written in PHP so literally anyone can contribute, even if they have no idea how to program."
02:43:02 <lavalike> hehe
02:43:50 <lag> dminuoso: That article is 3 years old -- Aarch64 was included as part of a recent release: http://downloads.haskell.org/~ghc/8.4.2/
02:44:46 <cocreature> lag: if you want some more details, write an email to ghc-devs
02:44:49 <hjt> dminuoso: that sentence is pure gold
02:45:32 <lag> cocreature: I just pinged on #ghc
02:45:43 <lag> cocreature: If I don't get a response, I'll join the MLs
02:46:10 <dminuoso> lag: #ghc is very active :)
02:47:21 <lag> dminuoso: cocreature: Okay, found someone - hopefully they respond when they come back online
02:47:44 <lag> cocreature: I do have the same question regarding Cabal 
02:47:50 <lag> cocreature: Same people?
02:48:17 <maerwald> it seems piping in shake cmd is broken
02:48:18 <dminuoso> lag: regarding using cabal?
02:48:29 <lag> dminuoso: Regarding Aarch64 support
02:48:36 <dminuoso> lag: #hackage probably
02:49:02 <lavalike> what does Aarch mean
02:49:07 <cocreature> does cabal even do binary releases? once you have GHC working you can just build cabal
02:49:20 <merijn> cocreature: Yes, as of a shortwhile ago
02:49:24 <lag> lavalike: "ARM architecture" 
02:49:26 <merijn> cocreature: Although I just bootstrap from source
02:49:43 <dminuoso> lag: AArch32 and AArch64 are two execution modes of ARM
02:49:47 <lag> cocreature: I don't want to build anything -- I wish to consume pre-builts
02:49:53 <merijn> lag: The cabal repo has a bootstrap.sh which will bootstrap Cabal from source as long as you have a working GHC
02:49:58 <dminuoso> lag: Sometimes people use them synonymously with ARM ;)
02:50:07 <dminuoso> Or sorry both were meant for lavalike 
02:50:12 <cocreature> lag: why does it matter if you have to build cabal or not, if you have to build 100 other Haskell libraries that your project depends on?
02:50:25 <lavalike> gotcha
02:50:30 <cocreature> I get the motivation for ghc since it’s somewhat complicated to build but for cabal?
02:50:40 <cocreature> *complicated and slow
02:50:49 <lag> cocreature: Do you know what 'Docker Hub' is?
02:50:56 <cocreature> yes
02:51:16 <lag> cocreature: I'm working on a project for ARM to enable some key projects for Aarch64
02:51:35 <lag> cocreature: Almost all of the Docker Hub projects consume official pre-builts 
02:51:43 <lag> cocreature: .. including Haskell's 
02:52:07 <merijn> lag: Cabal/cabal-install only very recently started having prebuilts, and I'm not sure they have a very official status
02:52:30 <cocreature> fair enough, although I still don’t see a whole lot of benefit in doing that over running the bootstrap script at the beginning of your dockerfile
02:53:21 <lag> cocreature: Very very very few projects pull any source at all
02:53:53 <lag> cocreature: *deb packages are preferred 
02:53:55 <dminuoso> lag: Personally Im not sure why that is the case. I mean for verification purposes you need to validate a prebuilt binary just as much as validating the source.
02:54:18 <lag> dminuoso: Not my design :)
02:54:23 <dminuoso> lag: Fair enough. 
02:54:27 <lag> dminuoso: I think it's a time thing
02:54:46 <dminuoso> lag: Oh yeah, I mean I make fun of gentoo folks all the time dont get me wrong..
02:54:48 <lag> dminuoso: Almost none of them do any building at all
02:55:37 <dminuoso> But ever since I started to develop in Haskell, I kind of remember those old times when you had to compile xorg a week long on some old AMD K6-II...
02:56:20 <cocreature> it just feels weird to insist on having everything prebuilt for a development environment that people are going to use to compile tons of other stuff
02:59:07 <dminuoso> cocreature: Some people have this bizarre fear of software being "less robust" when you compile it from hand.
02:59:24 <dminuoso> As if compilers are brittle and need to be used by professionals and experts.
02:59:24 <maerwald> I always use my feet to compile
03:00:21 <dminuoso> Though there is some point to preferring official builds, since they have a higher chance of being configured right.
03:01:12 <cocreature> sure for GHC I definitely get the desire, cabal just feels pretty close to building any other Haskell package which you won’t be able to avoid anyway if you want to do Haskell development
03:03:19 <lag> cocreature: That makes no sense at all :)
03:03:23 <Gurkenglas> If threads share a mutating "Maybe (Either a b)", can I make one thread wait for it to become just, and another wait for it to become just right?
03:03:36 <lag> cocreature: "Why install a distro if you're going to write code?"
03:03:50 <lag> cocreature: "Why not just build everything"
03:04:04 <lag> cocreature: You're beginning to sound like a Gentoer :D
03:04:38 <lavalike> I didn't read cocreature's comments that way, he's saying cabal is not as big as ghc, but as big as most other packages you'd normally compile
03:04:47 <cocreature> you missed the part where I said cabal is similar to any other Haskell package. I don’t want to spend time trying to figure out how to compile some fortran library as a Haskell developer or some Haskell project with a weird build system like GHC
03:05:09 <cocreature> but adding one package that is quite similar to the ones that I’m familiar with doesn’t seem like a big deal
03:05:42 <lag> cocreature: The idea of Docker Hub is to install everything you need with a single command `docker pull <thing>`
03:06:03 <lag> cocreature: I don't actually know what `cabal` is, but the Haskell Dockerfile installs it
03:06:18 <cocreature> lag: but it’s not going to contain my Haskell deps anyway so I still have to build those
03:06:25 <lag> cocreature: The Dockerfile was written by people who know Haskell better than I -- at least I hope so
03:06:28 <cocreature> or you need a separate docker image for any Haskell project
03:07:16 <cocreature> anyway, I’m not saying there is no value in having binary builds of cabal, I just don’t think it’s that big of a problem in practise
03:07:21 <lag> cocreature: Actually the packages is called `cabal-install` - does that make this better?
03:07:38 <lag> package*
03:07:48 <cocreature> the package is called cabal-install, the executable is called cabal
03:07:59 <lag> cocreature: https://github.com/freebroccolo/docker-haskell/blob/master/8.4/Dockerfile
03:08:09 <lag> cocreature: You will have to take it up with this project
03:08:26 <lag> cocreature: All I know is, I need it in order to build this project for Aarch64
03:08:45 <Mitsos101> I am using an online platform to compile Haskell programs, but Data.Vector isn't installed. Is it somehow possible to copy Data.Vector's source code, paste it in my file, and use it from there? I was thinking of prefixing every function in Data.Vector with a single 'v' and copy-pasting the source.
03:13:38 <ZeuPiark> hello
03:18:00 <madnight> is Haskell expressive enough to define a multifunctor (generalized functor with n variables)?
03:18:54 <lavalike> :t bimap
03:18:56 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
03:19:04 <opqdonut> madnight: you can define one for each concrete n
03:19:33 <opqdonut> and you can probably use some type-level-list hackery to define one for arbitrary n
03:20:53 <madnight> opqdonut: sure but then Haskell limits my expressiveness if i have to write them all out, trifunctor, quadfunctor, ...
03:21:12 <lavalike> works well enough for tuples
03:21:58 <madnight> i always wondered why their are such things as liftA5 or so, it strikes me as Haskell is missing a syntactic feature
03:22:34 <madnight> obviously in math you can easily write a liftN or multifunctor down in a single definition
03:22:47 <dminuoso> madnight: Template Haskell can fill that gap
03:22:58 <cocreature> you can get most of these to work in today’s Haskell even without TH. the problem is that type inference is often horrible
03:23:22 <dminuoso> Heh, even impredicative types seems to be completely unproblematic when you have no type inference.
03:23:56 <dminuoso> *impredicative polymorphism I mean
03:25:04 <madnight> can someone provide an example Haskell function, that takes for example an arbitrary amount of functions (a -> b) as input?
03:25:31 <dminuoso> % class Lift a f b | a b -> f where lift' :: f a -> b
03:25:31 <yahb> dminuoso: 
03:25:50 <dminuoso> % instance (a ~ a', f' ~ f, Lift as f rs, Applicative f) => Lift (a -> as) f (f' a' -> rs) where lift' f a = lift' $ f <*> a
03:25:50 <cocreature> madnight: maybe take a look at things like printf. it’s not quite that but the same idea
03:25:51 <yahb> dminuoso: ; <interactive>:22:10: error:; * Illegal instance declaration for `Lift (a -> as) f (f' a' -> rs)'; The coverage condition fails in class `Lift' for functional dependency: `a b -> f'; Reason: lhs types `a -> as', `f' a' -> rs' do not jointly determine rhs type `f'; Un-determined variable: f; Using UndecidableInstances might help; * In the instance declaration for `
03:25:56 <opqdonut> madnight: well just pass in [a->b]?
03:26:01 <dminuoso> % :set -XUndecidableInstances
03:26:01 <yahb> dminuoso: 
03:26:03 <dminuoso> % instance (a ~ a', f' ~ f, Lift as f rs, Applicative f) => Lift (a -> as) f (f' a' -> rs) where lift' f a = lift' $ f <*> a
03:26:04 <yahb> dminuoso: 
03:26:07 <opqdonut> madnight: currying makes variadic functions difficult
03:26:17 <dminuoso> % instance (f a ~ b) => Lift a f b where lift' = id
03:26:17 <yahb> dminuoso: 
03:26:37 <opqdonut> madnight: in C/Java you know when you've gotten all of the arguments, but in haskell you can't really, since (f x y z) is ((f x y) z)
03:26:40 <dminuoso> % lift :: (Lift a f b, Applicative f) => a -> b lift x = lift' (pure x)
03:26:40 <yahb> dminuoso: ; <interactive>:26:1: error:; * You cannot bind scoped type variables `a', `f', `b', `lift', `x' in a pattern binding signature; * In the pattern: lift :: (Lift a f b, Applicative f) => a -> b lift x; In a pattern binding: lift :: (Lift a f b, Applicative f) => a -> b lift x = lift' (pure x); <interactive>:26:45: error:; * Expected kind `k0 -> k1 -> *', but `b' has kind `*'; * In t
03:26:46 <lavalike> this comes to mind: http://okmij.org/ftp/Haskell/polyvariadic.html
03:27:08 <opqdonut> madnight: but if you want to see some practical variadic code, consider looking at Text.Printf
03:27:11 <dminuoso> % huh uhh
03:27:11 <yahb> dminuoso: ; <interactive>:27:1: error: Variable not in scope: huh :: t0 -> t; <interactive>:27:5: error: Variable not in scope: uhh
03:27:51 <opqdonut> yeah lavalike's link explains the Tet.Printf method
03:30:59 <madnight> okay thanks, i'll have a look at the Text.Prinf source / polyvariadic functions
03:35:01 <merijn> Text.Printf is kinda awful/typeclass abuse, though
03:42:36 <dminuoso> % lift :: (Lift a f b, Applicative f) => a -> b; lift x = lift' (pure x)
03:42:36 <yahb> dminuoso: 
03:42:44 <dminuoso> This took me far too long to spot heh.
03:43:21 <dminuoso> % lift (+) (Just 3) (Just 2)
03:43:21 <yahb> dminuoso: ; <interactive>:29:16: error:; Not in scope: `fromInteger'; Perhaps you meant `formatInteger' (imported from Text.Printf); <interactive>:29:25: error:; Not in scope: `fromInteger'; Perhaps you meant `formatInteger' (imported from Text.Printf)
03:43:23 <merijn> That looks like a different Lift class than I'm used to...
03:43:35 <dminuoso> % lift (<>) (Just "a") (Just "b")
03:43:36 <yahb> dminuoso: ; <interactive>:30:1: error:; * Overlapping instances for Lift (a0 -> a0 -> a0) f0 (Maybe [Char] -> Maybe [Char] -> t); Matching givens (or their superclasses):; Lift (a -> a -> a) f (Maybe [Char] -> Maybe [Char] -> t); bound by the inferred type for `it':; forall a (f :: * -> *) t. (Lift (a -> a -> a) f (Maybe [Char] -> Maybe [Char] -> t), Applicative f,
03:43:50 <dminuoso> % :set -XOverlappingInstances -- Let'
03:43:51 <yahb> dminuoso: ; <no location info>: warning: -XOverlappingInstances is deprecated: instead use per-instance pragmas OVERLAPPING/OVERLAPPABLE/OVERLAPS; Some flags have not been recognized: --, Let'
03:43:59 <dminuoso> Oh well.
03:44:52 <dminuoso> How does one undef with yahb?
03:46:32 <dminuoso> % lift (<>) (Just "f") (Just "b")
03:46:33 <yahb> dminuoso: Just "fb"
03:46:36 <dminuoso> % lift (<>) (Just "f") (Just "b") (Just "c")
03:46:36 <yahb> dminuoso: ; <interactive>:39:1: error:; * Couldn't match type `Maybe [Char]' with `Maybe [Char] -> t' arising from a use of `lift'; * In the expression: lift (<>) (Just "f") (Just "b") (Just "c"); In an equation for `it': it = lift (<>) (Just "f") (Just "b") (Just "c"); * Relevant bindings include it :: t (bound at <interactive>:39:1)
03:46:47 <dminuoso> Oh 
03:55:17 <hexagoxel> (does "% :r" work?)
03:56:30 <madnight> % :r
03:56:31 <yahb> madnight: Ok, no modules loaded.
03:56:35 <liste> yahb is a full featured ghci
03:57:18 <liste> % :?
03:57:18 <yahb> liste:  Commands available from the prompt:; <statement> evaluate/run <statement>; : repeat last command; :{\n ..lines.. \n:}\n multiline command; :add [*]<module> ... add module(s) to the current target set; :browse[!] [[*]<mod>] display the names defined by module <mod>; (!: more details; *: all top-le
03:57:43 <madnight> % [1..]
03:57:43 <yahb> madnight: ; <interactive>:42:2: error:; Not in scope: `fromInteger'; Perhaps you meant `formatInteger' (imported from Text.Printf)
03:57:47 <hexagoxel> well, there is our "undef" equivalent
03:59:24 <madnight> % import Prelude
03:59:25 <yahb> madnight: 
03:59:39 --- mode: glguy set +v Guest45278
03:59:42 <madnight> % [1..]
03:59:48 <yahb> madnight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127
04:01:43 <madnight> % sum [1..]
04:01:46 <yahb> madnight: *** Exception: heap overflow
04:04:59 <rswarbrick> Hi all! I'm a newish haskeller and have just run into my first space leak problem (boo!). I can see a profile using "+RTS -p -h" and it has the classic "big triangle" shape. I presume this means I'm accumulating a load of thunks without evaluating them, but my first (haphazard) attempts at adding calls to seq don't seem to be making any difference. Can anyone suggest a good reference for how to figure out what's goi
04:04:59 <rswarbrick> ng on?
04:05:55 <merijn> rswarbrick: The GHC user guide on profiling is pretty good. Personally I also like the -sstderr output to get a rough idea of which functions/cost centers are allocating a lot
04:06:08 <rswarbrick> In case it's relevant, the code is reading multiple text files (using parsec) and accumulating the values it sees into some sort of set. (It's a tool for measuring some sort of program coverage). I can trigger the leak by reading 100 copies of the same file, which you'd expect to have constant memory usage.
04:06:24 <merijn> rswarbrick: Are you reading these files as String?
04:06:33 <glguy> Guest45278: read your direct messages
04:07:29 <rswarbrick> merijn: Thanks. Yes, I'm reading them as Strings, but the files are each pretty small (14Kb) and I'm parsing most of the strings to integers before accumulating them.
04:07:39 <merijn> rswarbrick: Yeah, don't do that :)
04:07:51 <merijn> rswarbrick: Switch to Text and I can already guarantee massive space savings :)
04:08:00 <phadej> well, it's still won't help the leak
04:08:10 <rswarbrick> merijn: Ok, I understand that this might save a constant factor, but I don't think it will help the fact that I'm leaking stuff
04:08:11 <merijn> phadej: Sure, but he should start with that anyway :)
04:08:20 <merijn> rswarbrick: It will save MUCH more than a constant factor
04:08:20 <phadej> if the problem is because the contents are retained for too long
04:08:26 <phadej> (and then `seq` won't really help)
04:08:36 <merijn> rswarbrick: String consumes about 24 bytes per character on 64bit architecture
04:08:47 <merijn> rswarbrick: vs 1-2 bytes for western text when using Text
04:09:03 <phadej> 2 bytes-4bytes, text is utf16
04:09:09 <merijn> phadej: oh, right
04:09:10 <Ariakenom> (that does sound like a constant factor)
04:09:12 <madnight> % import System.Process
04:09:13 <yahb> madnight: *** Exception: heap overflow
04:09:23 <rswarbrick> merijn: So the constant factor as 12 to 24. I'm concerned with the fact that a situation that should have constant memory has an increasing memory usage.
04:09:36 <merijn> rswarbrick: Can you put the code somewhere visible? Preferably somewhat minimised :)
04:09:46 <madnight> i destroyed yahb ^^
04:09:51 <rswarbrick> merijn: The code is at https://github.com/ArgonDesign/acov
04:10:07 <rswarbrick> The bit that's interesting is in src/acov-report/Raw.hs
04:10:30 <glguy> % ()
04:10:31 <yahb> glguy: ()
04:10:32 <phadej> rswarbrick: if you'll use _strict_ Text, than you'd avoid lazy-IO, which a) might make issue go away by itself, b) heap profile might look more useful
04:10:49 <madnight> % ()
04:10:50 <yahb> madnight: ()
04:11:14 <phadej> rswarbrick: and parsec can be run on (strict) Text too, so you should try that - only small changes wil be required
04:11:34 <madnight> % import System.Process
04:11:35 <yahb> madnight: 
04:12:19 <merijn> rswarbrick: I suspect (like phadej) that something lazy is keeping your entire input alive, somehow. But I don't easily spot the parser entry point
04:12:40 <madnight> % readProcessWithExitCode "seq" ["1", "10"] ""
04:12:41 <yahb> madnight: (ExitSuccess,"1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n","")
04:13:29 <glguy> madnight: you can play with the bot in direct message
04:13:52 <madnight> ok : )
04:13:53 <rswarbrick> merijn: The call stack looks something like updateCoverage calls takeContents calls parseScript which parses a single file into an AST. The resulting AST gets passed to takeScript (which I would have hoped would not leave any stray dependencies lying around).
04:14:00 <Ariakenom> Can see if it's about lazy IO by just reading the entire file right away isntead of lazily
04:14:00 <Guest45278> don't know if this is too off-topic but: if one wants to represent the `Bool Monoid` with the `AND operator` as a category, would the objects in it be `True` and `False` or just the type `Bool`?
04:14:37 <Cale> rswarbrick: What type of data is reported for the triangle by -hy ?
04:15:10 <rswarbrick> Cale: Good question. Give me a sec to find out.
04:15:45 <rswarbrick> Cale: Almost all of it is reported as "[]" (which I guess is a list?)
04:15:49 <merijn> rswarbrick: An easy test (not a sensible fix!) for if it's lazy leaking is to just deepseq the result on line 165
04:15:52 <Cale> Makes sense
04:15:57 <Cale> That's String probably
04:16:17 <rswarbrick> Cale: I do see "String" reported separately as a tiny amount at the bottom.
04:16:24 <Cale> ah, interesting
04:16:37 <merijn> rswarbrick: If it's (unnecessarily) keeping onto the input the deepseq should squeeze that out
04:16:40 <maerwald> shake: plan construction failed
04:16:46 <maerwald> such useful message
04:17:26 <Cale> rswarbrick: About how much memory is spent on lists?
04:18:12 <rswarbrick> Cale: I'll try a bigger example (which takes 20s instead of 1s) to distinguish between the leak and stuff I might expect. One sec.
04:18:29 <rswarbrick> merijn: I'm just looking up deepseq now to work out how to do that. I'll let you know when I have a result!
04:20:01 <rswarbrick> Cale: I see about 60% spent on lists, about 30% on Integers (probably these are also leaking) and everything else is teensy.
04:22:17 <merijn> rswarbrick: You want force from Control.DeepSeq in the deepseq package
04:22:38 <rswarbrick> merijn: Hmm. My AST types don't have NFData instances so deepseq isn't completely trivial to add. I was just trying "Right res -> deepseq res $ Right res"
04:22:39 <Cale> rswarbrick: but how many bytes is that?
04:22:58 <Cale> rswarbrick: (so we can get an idea of how long the lists are)
04:22:59 <rswarbrick> Cale: The total reported is ~8M but this scales linearly in the input size
04:23:20 <rswarbrick> Oh, that makes sense. This is with 200 14Kb input files.
04:23:24 <merijn> rswarbrick: Then change line 158 to "case force (parse script name contents) of"
04:23:45 --- mode: glguy set +v emacstheviking
04:23:56 <Cale> So that's on the order of hundreds of thousands of list elements
04:24:01 <merijn> Oh, right, I keep forgetting force/deepseq requires NFData instances
04:24:14 <Cale> Does that make any kind of sense in the context of what the program is doing?
04:24:32 <Cale> (if it's not lists of characters...)
04:24:43 <glguy> Nfdata instances can be generated with generics, so they aren't hard to get
04:24:44 <rswarbrick> merijn: Is there a "deriving NFData"-style thing I can use?
04:24:54 <merijn> rswarbrick: See glguy's remark :)
04:24:56 <Cale> I'm somewhat surprised that String would show up as its own type there to be honest...
04:25:45 <Ariakenom> is there a non lazy IO readFile
04:25:58 <hpc> Ariakenom: openFile and read the lines
04:25:58 <Cale> Ariakenom: Use the one from (strict) Text or ByteString
04:26:01 <hpc> or that
04:26:02 <merijn> rswarbrick: So "deriving (Generic)" on each datatype and "instance NFData MyType" (empty instance definition) for each type should do it
04:26:13 * hackage hriemann 0.3.2.0 - A Riemann Client for Haskell  http://hackage.haskell.org/package/hriemann-0.3.2.0 (shmish111)
04:26:26 <rswarbrick> merijn: Yep, thanks. I'll have that done in a sec.
04:26:31 <merijn> You should be using Text/ByteString for reading files anyway, so that should be a trivial change :)
04:26:46 <Cale> While it might be interesting to see how deepseq affects things, it's sort of... not the right way to solve issues of this sort :)
04:27:14 <merijn> Cale: Hence why I said it's a helpful diagnostics tool here, but not a solution
04:27:16 <rswarbrick> Cale: I think merijn was doing this to make sure we've identified what's leaking.
04:27:20 <Cale> right
04:27:29 <merijn> Cale: I just forgot the hassle of adding NFData instances
04:27:30 <Cale> Have we tried switching to Data.Text?
04:27:46 <Cale> I think we should do that first and see if we still get megabytes of list cells
04:27:47 <merijn> Because else just "force $ parse" would've been a super quick test :)
04:28:04 <merijn> Cale: Well, that's what I recommended first :)
04:29:18 <rswarbrick> merijn: "force parse" doesn't quite work because I'd need an NFData instance for ParseError, but I wrapped the last line as Right res -> force (Right res). The result is basically the same data usage, but now everything is type Set instead of type []. I guess this means that I'm using a lazy set that needs a seq, but the deepseq has chivvied evaluation along that far?
04:29:29 <rswarbrick> *data usage should have been "memory usage"
04:30:23 <merijn> hmm, I'd have to see the profiling output/data usage plot
04:30:42 <rswarbrick> merijn: Do you have a favoured imgur-like site?
04:31:13 <merijn> Not really
04:33:16 <rswarbrick> I've uploaded it here: https://imgur.com/eqP8TrF. Unfortunately, imgur shows it with a black background which isn't massively helpful. Right click and view image to see it properly.
04:34:50 --- mode: glguy set +v emacstheviking
04:36:09 <emacstheviking> I just dont "get" fmap at all despite having used it!! I feel penny dorpping not too far away but still mentally confused about what fmap does for me that I can't do with pattern matching on a set of constructors for my type?
04:37:02 <glguy> emacstheviking: it allows you to write things that work across multiple types
04:37:24 <emacstheviking> by writing an implementation of "Functor a"
04:37:38 <emacstheviking> for my new type. I still get that too but when is it useful?
04:37:45 <Cale> emacstheviking: Well, it's common to want to apply a function to all the elements of a container
04:38:00 <Cale> emacstheviking: fmap is the way to do that for many differeny types of container
04:38:04 <Cale> different*
04:38:10 <Ariakenom> emacstheviking: Others can see that all you do is fmap. And no other transformation
04:38:20 <dminuoso> emacstheviking: Functor has no intrinsic use case.
04:38:22 <Ariakenom> pattern matching and reconstructing could do more
04:38:23 <emacstheviking> ok, so lists have to be homogenous but a list of types could be wildy differenty data isntances?
04:38:26 <dminuoso> emacstheviking: Functor captures an abstract pattern.
04:38:47 <dminuoso> emacstheviking: Do you understand Monoid?
04:39:03 <merijn> rswarbrick: You're still using Set/Map storing String?
04:39:23 <rswarbrick> merijn: Where do you mean?
04:39:44 <emacstheviking> I understand the concept of functors, monoids and monads but *using* them is proving to be tricky...maybe I have yet to meet a genuine use case for myself to make it relevant?
04:39:48 <Cale> emacstheviking: All there is to it is that there are lots of types which support an operation of this shape
04:39:59 <dminuoso> emacstheviking: Do you understand the abstract concept of a monoid?
04:40:07 <Cale> emacstheviking: and so it's handy to have a common interface to them
04:40:08 <merijn> rswarbrick: oh, it's just ModData that uses String keys
04:40:17 <Cale> dminuoso: why would that be relevant?
04:40:43 <merijn> rswarbrick: 35MB doesn't seem that much, though? Are you sure that's not actually what's require for you data? How many integers are you storing in sets?
04:40:47 <Cale> Monoid and Functor don't have much in common apart from both being typeclasses
04:40:55 <barrucadu> emacstheviking: You might be overthinking it.  Functor doesn't give you any additional power over pattern matching (well, except for types which don't expose their constructors - but they could all define their own specialised fmap function).  It's just a name for a common pattern.
04:40:56 <dminuoso> Cale: They are both abstract typeclasses.
04:41:06 <dminuoso> Cale: Both capture a very abstract pattern.
04:41:08 <Cale> sure, but we could also ask if they know about Num
04:41:20 <merijn> hmmm, time to figure out why my query suddenly returns 0 results after changing the schema...
04:41:20 <emacstheviking> I am currently working with SDL... lets assume I create a scene graph (un progress)... and I wanted to implment a "scale" operation, could I then use "fmap" over my scene graph and then presumably code an implementation for every different type of scene graph type instance so do the right thing?
04:41:37 <Cale> emacstheviking: Is your scene graph type parameteric?
04:41:39 <rswarbrick> merijn: This test is running over 200 identical files. I'd expect an allocation of some memory at the start, then constant memory usage for a while as we read the other 199 copies of the same thing.
04:41:41 <Cale> parametric*
04:42:11 <merijn> rswarbrick: Why would you expect constant memory usages? Are you merging the results of each file?
04:42:12 <Cale> emacstheviking: If so, then probably
04:42:23 <emacstheviking> barrucadu you might be right, I often oberthink things! Haskell makes the C++ shotgun for your feet pale by comparison :)
04:42:37 <merijn> rswarbrick: if so, which part of the code does the merge?
04:42:38 <Cale> emacstheviking: If you have something like SceneGraph a where a is the type of things being stored in the SceneGraph, and you want to apply a function to all of them
04:42:46 <dminuoso> emacstheviking: The common pattern is very simple: For some thing `F` if you can turn `a -> b` into `F a -> F b` in a sensible manner, then we call `F` a functor.
04:42:54 <Ariakenom> Cale: Num is very different. Functor and Monoid are defined with and used with their laws. Num is more a vague idea of a number
04:43:13 <rswarbrick> merijn: Well, the merge for a given record is the union of sets in updGrp. The high-level control calls updateCoverage for each input file as a sort of fold.
04:43:24 <Cale> Ariakenom: I don't see them as all that different.
04:43:31 <emacstheviking> Cale my type is basically evolving but very simple "data GfxObject = GfxText | GfxImage | GfxCursor deriving Show" for rendering TTF text, a loaded image or a flashing blob!
04:43:47 <merijn> rswarbrick: Highly suspicious mappend there!
04:43:59 <dminuoso> emacstheviking: A curious version of this is, given `f :: String -> Char` we can turn `Int -> String` into `Int -> Char`
04:44:09 <dminuoso> emacstheviking: Which suggests that (Int -> ...) is a Functor, which it is. :-)
04:44:11 <merijn> rswarbrick: What happens if you add a BangPattern on "vals" on line 220/221?
04:44:23 <Cale> emacstheviking: Well, that one won't be a functor, because it doesn't have a type parameter
04:44:44 <emacstheviking> Ha! That's where I was going with my madness! It has to be parameterised with a type
04:44:55 <merijn> rswarbrick: Also, if Int is big enough for you, there's a dedicated IntSet in containers, instead of "Set Integer"
04:45:03 <emacstheviking> because fmap "unpacks" from a context which my data types don't have!??!?!
04:45:25 <Cale> emacstheviking: fmap :: Functor f => (a -> b) -> f a -> f b
04:45:32 <Cale> So if we have some container type f
04:45:43 <Cale> some function (a -> b)
04:45:51 <Cale> and we have a container of values of type a
04:46:02 <Cale> then we can apply the function to all of them and obtain a container of values of type b
04:46:20 <emacstheviking> where a and b *could* be the same type
04:46:20 <Cale> The type parameter is necessary in order to explain how things are going to change when we apply the function
04:46:26 <Cale> yes, they could
04:46:52 <dminuoso> emacstheviking: but they could also be different, and you dont know anything about them
04:46:56 <emacstheviking> great. and the type parameter essentially i how to pattern match/deconstruct the source value and then rewrap it in the correct outgoing context
04:47:17 <dminuoso> emacstheviking: not necessary pattern match, but use.
04:47:31 <emacstheviking> dminuosu yes I think I am beginning to see now that it is a generalisation...I mean, that's what LYAH and my well thumbed RWH tell me but sometimes I wonder how dumb I really am!!!
04:47:45 <rswarbrick> merijn: Not a big change. I see the memory usage for the Set instances tail off very slightly just after the peak. Hmm. I'm going to go get some lunch now. Thank you very much for the help - at least I now have a toolbox of things like "force" to figure out what's going on. I'll ping back if and when I figure out what the problem was.
04:47:52 <dminuoso> emacstheviking: Would you be willing to recognize ((->) Int) as a sort of type constructor?
04:47:56 <Cale> emacstheviking: Well, the implementation of fmap for any given choice of f will probably pattern match and recurse through whatever structure is appropriate
04:47:58 <emacstheviking> yes, pattern match was a bad thing to cite there. Use is better.
04:48:04 <rswarbrick> Cale: Thanks for your help. I'll get back (after lunch) when I've figured out what I got wrong!
04:48:10 <emacstheviking> Yes, LYH goes into that I think.
04:48:44 <emacstheviking> But that's part of my confusion about types and containers: *everything* is just functions at the end of the day so how do you know something is a type and not just a plain old function?
04:48:50 <merijn> rswarbrick: I mean, if you're repeatedly parsing the same set and merging them *and* seeing a constantly growing Set usage, my first suspicion is: the merge isn't being forced
04:48:58 <merijn> emacstheviking: Everything isn't functions
04:49:01 <dminuoso> emacstheviking: Types and values live in different namespaces.
04:49:12 <merijn> emacstheviking: http://conal.net/blog/posts/everything-is-a-function-in-haskell
04:49:17 <dminuoso> emacstheviking: `Int + Float` won
04:49:19 <emacstheviking> But I thought a partially applied Type constructor was still just a function?? Maybe that's my issue!
04:49:26 <dminuoso> emacstheviking: `Int + Float` won't compute, unless you happen to have a data constructor named Int and Float.
04:49:38 <dminuoso> emacstheviking: a "type level function" perhaps.
04:49:46 <Cale> rswarbrick: No problem. In any case, it looks like you've discovered that you're accumulating output (ScopeData?) so maybe the problem isn't actually in this file
04:49:59 <emacstheviking> Ha. I smell "kinds" stuff from LYAH here as well... I need to go read that article first, thanks so far!
04:49:59 <dminuoso> `Maybe :: * -> *` so it's a type function that takes a type and gives a type back
04:50:20 <dminuoso> `((->) Int) :: * -> *` is also a type function that takes a type and gives a type back
04:50:55 <emacstheviking> As fed up as I am, I am kind of excited cos the Eureka moment is going to be massive!
04:51:22 <Cale> emacstheviking: Only values of type A -> B for some types A and B are called functions
04:51:42 <Cale> (otherwise the word "function" and "value" would be synonymous, which isn't very useful)
04:52:36 <ArahaelPi> With megaParsec, how do I do a 'sepBy1 p semicolon' until it has a line that p can't parse?
04:52:36 <emacstheviking> so A -> B are the RHS isntances of a "data" declaration
04:52:47 <emacstheviking> so A -> B are the RHS isntances of a "data" declaration as opposed to the LHS, the actual type constructor specification
04:52:52 <Cale> what
04:53:03 <dminuoso> emacstheviking: (->) is a special infix type constructor.
04:53:03 <Cale> no, A -> B is the type of the thing we're calling a function
04:53:09 <Cale> where A and B are some other types
04:53:12 <dminuoso> emacstheviking: (->) :: * -> * -> *
04:53:19 <emacstheviking> ok, that was a tangent moment....please go on! :)
04:53:34 <dminuoso> emacstheviking: So `(->) Int Float` is the type of all functions from Int to Float
04:53:49 <dminuoso> emacstheviking: Conceptually (->) is not too different from say Maybe
04:53:56 <dminuoso> Or Either
04:53:57 <Cale> For example...
04:53:59 <Cale> :t ord
04:54:01 <lambdabot> Char -> Int
04:54:07 <Cale> ord is a function since it has type Char -> Int
04:54:15 <Cale> :t getLine
04:54:16 <lambdabot> IO String
04:54:24 <Cale> getLine is not a function, since it has type IO String
04:54:31 <Cale> which isn't of the form A -> B
04:54:47 <Cale> the Integer value 5 is similarly not a function
04:55:45 <emacstheviking> (reading Conal Elliot page...)
04:57:15 <dminuoso> emacstheviking: If you ever get confused about what is a data and what a type constructor, you might find GADTSyntax to be a useful tool.
04:57:46 <ArahaelPi> I think what I want is probably takeWhile1P.
04:57:56 <emacstheviking> dminuoso: GADTSyntax is where the RHS doesn't have to always use the type parameters from the LHS yes?
04:58:38 <dminuoso> ArahaelPi: `many p` ?
05:01:21 <ArahaelPi> dminuoso: I can't figure out how that works.  I notice the types are identical to 'some p'.
05:02:04 <ArahaelPi> dminuoso: Does it do as many p as it can until it fails, and then rewrinds the parser to that end of the last successful try, and return the parse results that succeed?
05:02:22 <dminuoso> ArahaelPi: Yes.
05:02:39 <ArahaelPi> dminuoso: Awesome. :)  How does 'some' work, by contrast?
05:02:46 <dminuoso> ArahaelPi: The same way.
05:03:01 <dminuoso> ArahaelPi: The difference between some and many is that many is `zero or more` and some is `one or more`
05:03:19 <dminuoso> ArahaelPi: they are very simple combinators from Alternative.
05:03:20 <ArahaelPi> dminuoso: So 'some' is "parse, then many"?
05:03:43 <dminuoso> ArahaelPi: some v = (:) <$> v <*> many v; many v = some v <|> pure []
05:03:54 <dminuoso> ArahaelPi: the modern defintions are slightly different, but these are easier to read I think
05:04:09 <ArahaelPi> dminuoso: Ah, that makes sense, then.
05:07:04 <Ariakenom> :t many getLine
05:07:06 <lambdabot> IO [String]
05:08:04 <c_wraith> That doesn't make much sense.  I blame Alternative's too-permissive spec
05:08:07 <ArahaelPi> dminuoso: It nearly works, but have an issue with the semicolon at the end.
05:08:19 <Cale> emacstheviking: That's what GADTs are generally, but GADTSyntax just adds support for the syntax of GADTs without the actual generalisation
05:08:23 <ArahaelPi> I basically need a 'many' version of sepBy1.
05:08:24 <Ariakenom> c_wraith: Why not?
05:08:55 <opqdonut> ArahaelPi: isn't that called just sepBy?
05:08:57 <c_wraith> Ariakenom: it will never stop recursing because getLine never fails
05:09:24 <Ariakenom> c_wraith: Not true. It will stop on end of file
05:09:39 <ArahaelPi> opqdonut: Doesn't seem to be, because sepBy1 falls apart when it's parsers don't parse.
05:09:46 <ArahaelPi> opqdonut: I want it to parse until it no-longer can.
05:09:50 <c_wraith> Hmm.  I guess that may not be true.  getLine may fail if stdin has reached EOF.  I never consider the fact that stdin can be finite
05:10:11 <merijn> c_wraith: Wut
05:10:19 <ab9rf> c_wraith: most of the files on my computer are, in fact, of finite length
05:10:20 <merijn> When would stdin ever be non-finite?
05:10:25 <ab9rf> merijn: yes
05:10:27 <mnoonan> c_wraith has a lot of programs still running in the background, I guess
05:10:38 <merijn> ab9rf: Not only that, but most input pipes are connected to processes with finite lifetimes!
05:11:04 <ab9rf> merijn: sure, if for no other reason than that ComEd sucks
05:11:07 <c_wraith> merijn: most programs I use interactively terminate before stdin closes
05:11:23 <merijn> c_wraith: You never pipe/redirect ? :p
05:11:28 <c_wraith> not really
05:12:03 <ArahaelPi> opqdonut: I want to parse: public one; two; three; private one; two; three;
05:12:41 <ArahaelPi> opqdonut: So I have: sepBy1 accessibilityAndFields semi; and accessibilityAndFields in turn does the sepBy1 for the identifiers one, two, and three.
05:14:29 <opqdonut> ArahaelPi: hmm, I wonder if sepBy1 (try identifier) semi works
05:14:55 <opqdonut> but anyway, I'd start by writing out with manual recursion + try, and then try to squint and see if it fits some combinator
05:14:58 <ArahaelPi> opqdonut: I already do lexeme . try there.
05:15:39 <ArahaelPi> opqdonut: The problem is I don't know how to say: "Go this far, and then return what we've built so far and go back to the previous try".
05:16:06 <ArahaelPi> opqdonut: So I basically can't igure out how to successfully get past that 'private' word there.
05:16:41 <dminuoso> stdin is finite by law of thermodynamics.
05:16:50 <opqdonut> ah right your inner sepBy1 gobbles up the ; that the outer one should get
05:16:58 <opqdonut> (try semi)
05:17:01 <c_wraith> doesn't matter if it's finite if it outlives the process reading it
05:17:03 <opqdonut> did you try that?
05:17:20 <opqdonut> I can't be bothered to write the parser myself right now, sorry
05:17:51 <ArahaelPi> opqdonut: Hmm...
05:18:15 <ab9rf> it sounds like you're running into parsec's gobble-on-fail semantics
05:18:27 <ArahaelPi> opqdonut: No, it fails because it says "private cannot be an identifier", because it's obstinately trying to continue on.
05:18:36 <ArahaelPi> ab9rf: That sounds promising!
05:19:02 <ArahaelPi> ab9rf: How do I learn about that?
05:19:06 <opqdonut> ArahaelPi: and it's trying to continue because it gobbled up the ";"
05:19:20 <ab9rf> parsec does not return consumed tokens to the input after a failure
05:19:31 <opqdonut> http://hackage.haskell.org/package/parsec-3.1.13.0/docs/src/Text.Parsec.Combinator.html#sepBy1
05:19:33 <ab9rf> if you want it to backtrack, you must explicitly request backtracking with `try`
05:19:39 <opqdonut> note the "sep >> p"
05:19:43 <ArahaelPi> opqdonut: Not exactly, it's still insisting on looking for 'four;', and failing to step back and think maybe, it has another 'private ...' instead.
05:19:48 <opqdonut> so if it manages to parse a separator, it will want a p
05:19:52 <ArahaelPi> ab9rf: I've been putting 'try' *everywhere*.
05:20:24 <ArahaelPi> opqdonut: Hmm...
05:20:42 <ab9rf> what's the grammar?
05:20:48 <opqdonut> you could consider using sepEndBy1 on the inner level, and no sep anything on the outer level
05:20:59 <opqdonut> or, as I said, manual recursion
05:21:08 <ab9rf> trying to nest sepBys is difficult
05:21:37 <ArahaelPi> ab9rf: The grammar is Delphi, I'm trying to parse the fields in a record.
05:21:38 <dminuoso> ArahaelPi: ((:) <$> f) <*> (many (semicolon *> p))
05:21:44 <dminuoso> Or something along those lines? 
05:22:28 <ArahaelPi> dminuoso: That's a bit too abstract for me - I don't know what 'f' and 'p' are.
05:22:36 <dminuoso> ArahaelPi: sorry `f = p`
05:22:47 <dminuoso> ArahaelPi: thats your item parser 
05:23:27 <dminuoso> ArahaelPi: And *> is just >> but I prefer using the Applicative version
05:23:41 <ArahaelPi> dminuoso: ((:) <$> p) <*> (many (semicolon *> p)), then, where p is the item parser?
05:24:57 <ArahaelPi> dminuoso: That makes sense, actually, I'll give that a go tomorrow.  Essentially, you're saying: "Parse an item, then parse many (semi + item)'s".
05:25:05 <dminuoso> ArahaelPi: yup
05:25:13 <ArahaelPi> dminuoso: Awesome - thanks!
05:25:26 <dminuoso> though.. isnt that sepBy?
05:25:35 * dminuoso is confused
05:26:02 <ArahaelPi> dminuoso: I'm confused, too. :)  This is my first attempt, really, of megaparsec using https://markkarpov.com/megaparsec/parsing-simple-imperative-language.html#the-language
05:26:21 <dminuoso> sepBy1 actually heh
05:26:23 <dminuoso> sepBy1 p sep = (:) <$> p <*> many (sep *> p)
05:26:39 <ArahaelPi> Then that doesn't help, as I already seem to be doing that.
05:26:58 <ab9rf> i don't remember delphi grammar well enough
05:27:06 <ab9rf> it has been almost two decades since i last used it
05:27:40 <ArahaelPi> ab9rf: I'm not sure if it's really relevant, at this point.  I should get to bed soon, though.
05:27:51 <ArahaelPi> Perhaps I should have another dig at this tomorrow.
05:28:00 <ab9rf> dig dog dug
05:29:35 <dminuoso> ArahaelPi: what exactly is wrong with sepBy/sepBy1?
05:30:46 <ArahaelPi> dminuoso: For "public one; private two;", it successfully gets the first one done.  But then at private, it's another identifier, but I've told it that "public" and 'private' are reserved words.
05:31:06 <ArahaelPi> dminuoso: And so it fails.  I expect it to return a list of identfiers [one], in this case, and then try again from the start.
05:31:24 <ArahaelPi> So I basically want to get Public ["one"], and then Private ["two"]
05:32:00 <ArahaelPi> Alternatively, if this was "public one; two; private three; four;", I'd want Public ["one", "two"], Private ["three", "four"]
05:32:17 <dminuoso> ArahaelPi: Why not have some `data Var = Public String | Private String` and then produce some [Var]`
05:33:03 <ArahaelPi> dminuoso: I do do that, actually.
05:33:54 <ArahaelPi> dminuoso: Though, it's `data Var = Public [String] | Private [String]`
05:35:06 <ArahaelPi> I think I should look at this tomorrow, and if I'm still stuck, try and come up with a smaller sample and show that code.
05:37:45 <ArahaelPi> G'night!
05:38:48 <Ariakenom> good day. sleep well
05:48:02 <toppler> I completely missed a subtle bug using (>>) (would have had it with (*>)), where the lhs was m (m a) and the rhs was m a, and I had missed out a join. Is there an argument to say that these functions that implicitly void out their functor should be replaced by ones that take f () rather than f a?
05:48:30 <c_wraith> I don't think that would help
05:48:47 <toppler> Changing it made the bug a type error.
05:48:51 <c_wraith> you'd just be stuck using void when you know there's a result you want to throw away
05:49:10 <c_wraith> and that's awfully common
05:49:29 <Ariakenom_> toppler: C void or Haskell Void?
05:49:36 <toppler> @type void
05:49:37 <lambdabot> Functor f => f a -> f ()
05:49:53 <Ariakenom_> wow, that's a terrible name
05:49:57 <c_wraith> fwiw, though, -Wall includes a warning for do notation that doesn't bind results of types other than ()
05:49:59 <Ariakenom_> TIL
05:50:22 <toppler> c_wraith: I know. But I'm not using do notation here.
05:50:35 <c_wraith> if you're worried about that bug, you should
05:51:00 <toppler> In this case, I've hidden the prelude implementation and written a stricter one.
05:51:10 <c_wraith> I don't think that will help in the long run
05:51:12 <toppler> I'd rather void explicitly.
05:51:23 <c_wraith> because you'll just get in a pattern of using void everywhere
05:51:32 <c_wraith> because it's the only sane thing to do
05:51:44 <toppler> I think if I'm voiding everywhere, that might be a bad smell anyway.
05:51:55 <dminuoso> toppler: what does "void out their functor" mean?
05:51:58 <c_wraith> I think all benefit you're actually getting is from heightened awareness of the problem
05:52:09 <toppler> dminuoso: Calling "void". I was being a little poetic there.
05:52:37 <dmwit> c_wraith++
05:52:53 <dmwit> Once `void foo >> bar` is built into your fingers it will instantly stop being helpful.
05:52:58 <toppler> c_wraith: I write a lot in applicative style, and I don't *think* I would void that much in my code. Would have to actually do an empirical test.
05:53:03 <dmwit> And you will write this bug again.
05:53:40 <dmwit> I think it's more interesting to address how you arrived at a situation where you had an `m (m a)` in the first place.
05:54:03 <hexagoxel> if your left side is actually m (), you don't have to call `void`. separating that case by forcing the use of `void` seems useful.
05:54:24 <dminuoso> Hah. Whenever I see some `m (m a)` in a place where some `m a` should have been, Ill just replace a random <$> with (=<<), kickback as the program type checks and magically does the right thing - leaving me to wonder *but why...*
05:54:26 <toppler> dmwit: You think they're uncommon?
05:54:48 <toppler> dminuoso: I didn't realise it was m (m a). Hence the bug.
05:54:51 <toppler> I thought it was m a.
05:55:07 <Cale> toppler: Consider writing less Applicative style.
05:55:19 <c_wraith> toppler: this sounds like the result of writing too much in Applicative... darn it
05:55:37 <hexagoxel> void should be :: forall a f . Functor f => f a -> f ()
05:55:48 <hexagoxel> then you could "void @Int"
05:55:51 <int-e> I miss the stereo quote
05:56:00 <hexagoxel> which will complain about m (m Int)
05:56:04 <Cale> If it's hard to keep track of the types to the point that it wouldn't be obvious that something has type m (m a), then the code is probably harder to read than it should be
05:56:09 <dminuoso> hexagoxel: Well you can still do it.. `void @_ @Int`
05:56:17 <c_wraith> int-e: did you lose it in a migration somewhere?
05:56:18 <dminuoso> Not that either is pretty.. 
05:56:27 <int-e> @quote fugue
05:56:27 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
05:56:38 <int-e> c_wraith: no it was deliberately forgotten
05:56:41 <c_wraith> ah
05:59:13 <toppler> Cale et al: I'll bear that in mind. Though looking at this line, it's just liftA2. It needed a join afterwards which I hadn't noticed.
06:00:40 <Ariakenom_> liftA2 (const id)
06:00:53 <dmwit> toppler: Yes, I think they're uncommon.
06:00:55 <dminuoso> > liftA2 (<>) (pure "a") (pure "b")
06:00:58 <lambdabot>  error:
06:00:58 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M384938327906...
06:00:58 <lambdabot>        prevents the constraint ‘(Show (f0 [Char]))’ from being solved.
06:01:29 <dminuoso> Is there a way to have GHC know it doesn't need to know the type here?
06:01:45 <merijn> dminuoso: It does, though?
06:01:50 <dmwit> toppler: I can think of exactly four places where I've actually wanted a nested monadic action. Two of them have to do with IO, and one of them is lists.
06:01:51 <Cale> toppler: Yeah, maybe just don't use liftA2 :)
06:01:53 <dminuoso> merijn: does it?
06:02:04 <dminuoso> merijn: oh well it does heh.
06:02:13 <merijn> dminuoso: Well, how else to print some random ass Applicative?
06:02:24 <dmwit> toppler: ...and the last one is once when I was trying to be too clever with liftA2... =P
06:02:34 <toppler> Cale: Hmm...I'm thinking there might be some controversy over that style advice :)
06:02:38 <dminuoso> merijn: Yeah it just hit me once I hit enter after "does it?"
06:02:49 <Cale> toppler: Well, if you want to use Applicative, you can still do that
06:03:12 <Cale> ... possibly
06:03:41 <Cale> But liftA2 isn't the thing you wanted
06:03:48 <dminuoso> merijn: curious about earlier, what kind of Lift class do you know about?
06:04:06 <dminuoso> > lift (<>) (Just "a") (Just "b")
06:04:08 <lambdabot>  error:
06:04:08 <lambdabot>      Ambiguous occurrence ‘lift’
06:04:08 <lambdabot>      It could refer to either ‘Control.Monad.Writer.lift’,
06:04:15 <toppler> Cale and dminuoso: All my cases of join here involve applying a function of the form a -> b -> ... -> m z
06:04:22 <dminuoso> % lift (<>) (Just "a") (Just "b")
06:04:23 <yahb> dminuoso: Just "ab"
06:04:29 <toppler> To arguments m a, m b, ...
06:04:33 <dmwit> I don't think there's a handy collection of combinators that are like liftA* with a join, but it would be nice to have them.
06:04:36 <Cale> oh, actually, probably not
06:04:40 <dminuoso> % lift (\x y z -> x <> y <> z) (Just "a") (Just "b")
06:04:40 <yahb> dminuoso: ; <interactive>:16:1: error:; * Couldn't match type `Maybe ([Char] -> [Char])' with `()' arising from a use of `it'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
06:04:50 <Cale> since you want to actually decide what to do next based on the results of the actions
06:05:02 <dminuoso> % lift (\x y z -> x <> y <> z) (Just "a") (Just "b") (Just "c")
06:05:02 <yahb> dminuoso: Just "abc"
06:05:21 <Cale> you really just want to bind a bit
06:05:46 <dmwit> dminuoso: ?src lift
06:06:17 <dminuoso> dmwit: mm?
06:06:42 <dmwit> dminuoso: Where is that lift defined?
06:07:12 <toppler> Cale: So what's your recommendation for this case?
06:07:17 <dminuoso> dmwit: https://gist.github.com/dminuoso/b95dc9f443c4496bead9f9a689c0c81a
06:07:55 <Cale> do u <- x; v <- y; f u v
06:08:16 <Cale> Just write the obvious bloody code.
06:08:37 <dmwit> dminuoso: Can the fundep be `b -> f` instead?
06:08:49 <toppler> I actually find the applicative case easier to read.
06:09:29 <dmwit> toppler: My recommendation is a bit different from Cale's. I recommend writing a handful of combinators with names similar to liftA2, liftA3, etc. but with the right type.
06:09:40 <Cale> Well, a natural name for this would be ap2
06:09:46 <dmwit> :t ap
06:09:48 <lambdabot> Monad m => m (a -> b) -> m a -> m b
06:09:52 <dmwit> Would it?
06:10:01 <Cale> oh, right, that still does the return
06:10:24 <dmwit> You can't name this after anything Applicative can do, because Applicative can't do it.
06:10:33 <Cale> yeah
06:11:14 <dmwit> The natural name is (=<<2) ;-)
06:11:46 <dmwit> :t (=<<)
06:11:48 <lambdabot> Monad m => (a -> m b) -> m a -> m b
06:12:18 <dminuoso> dmwit: Mmm I think so yeah
06:12:21 <dmwit> dminuoso++ for a neat class
06:12:21 <byorgey> (=<<..) perhaps
06:12:42 <dmwit> Probably giving it an infix name isn't so great in the end.
06:12:50 <dmwit> Think about how it will be used and try to imagine yourself enjoying that.
06:13:38 <byorgey> hmmmm nope
06:13:50 <Cale> liftM2M, lol
06:13:53 <Spaceman77> I've heard that LISP will free your mind.
06:13:58 <Spaceman77> WHat will Haskell do to my mind?
06:14:03 <dmwit> Cale: I like it. =)
06:14:05 <dminuoso> Spaceman77: Fix it.
06:14:24 <Spaceman77> dminuoso: Curious answer. Why?
06:14:31 <dminuoso> Spaceman77: But honestly, it's not what Haskell will do to your mind, its what you do to your mind.
06:14:49 <dminuoso> Spaceman77: Haskell might fundamentally change the way you approach programming or problem solving.
06:14:56 <Cale> Spaceman77: That's sort of an odd question. I doubt the answer is really useful.
06:14:58 <dmwit> > fix mind
06:15:00 <lambdabot>  "I can't let you do that, Dave."
06:15:07 <dminuoso> :t mind
06:15:09 <lambdabot> p -> [Char]
06:15:14 <dminuoso> Hah.
06:15:18 <dmwit> ?free p -> String
06:15:19 <lambdabot> Extra stuff at end of line
06:15:24 <dmwit> ?free mind :: p -> String
06:15:24 <lambdabot> mind = mind . f
06:15:38 <Spaceman77> Jesus, i understood precisely 0% of the syntax
06:15:48 <Spaceman77> only the types rinf bells
06:15:57 <Cale> Spaceman77: The syntax isn't the hard part ;)
06:15:59 <dminuoso> Spaceman77: Think about how wildly different prolog looks.
06:16:07 <toppler> Should also suggest that, while Applicative can't do this, some Monads implement their Applicative interface more efficiently than the derived liftM*, and I can think of use cases where I want the arguments to be evaluated "in parallel", and the result only joined at the end.
06:17:24 <Cale> toppler: Which monads?
06:17:49 <toppler> Cale: An Async one?
06:17:53 <Cale> Anything where f <*> x is semantically different from ap f x should be considered a bug, imo.
06:18:35 <dmwit> f <*> x is allowed to be operationally different from ap f x.
06:19:20 <dminuoso> Spaceman77: You get used to the syntax. :)
06:19:23 <Cale> It's technically allowed to be, but I think it's a bad idea.
06:19:35 <dminuoso> Spaceman77: Just approach it with an open mind.
06:19:44 <Cale> (just as we can write instances of Monad which don't satisfy the Monad laws...)
06:20:35 <toppler> How far can we take that? Associative operations often have different performance as you apply associative laws.
06:23:33 <Spaceman77> FP has changed my approach with concepts such as map, reduce, first class functions and closures.
06:23:51 <veverak> first class functions <3
06:23:52 <toppler> Might as well use Java then :)
06:24:06 <Spaceman77> I can say that i have only "dabbled a bit" with one FP language
06:24:20 <toppler> Though Guy Steele claimed Java is halfway between C++ and Lisp anyhow.
06:24:25 <dminuoso> Spaceman77: LISP is not properly functional because it has too many escape hatches.
06:25:02 <dminuoso> Spaceman77: With imperative and mutable data you get too many backdoors - that prevents you from being forced to solve things with functional solutions.
06:25:06 <Taneb> It's easier to learn to ride a bike when you're using a bike compared to when you're using a magical car that can transform into a plane that happens to have pedals
06:25:07 <merijn> dminuoso: Unlike Haskell which only has about 50
06:25:24 <dminuoso> Heh
06:26:07 <dminuoso> merijn: Haskell doesn't promote using these hatches as much though, and we have enough combinators to avoid escape hatches.
06:26:26 <Spaceman77> I wanted to ask what else is there in FP? What are monads?
06:26:34 <dminuoso> Spaceman77: it's just a programming pattern.
06:26:51 <Spaceman77> dminuoso: and sort of a meme
06:27:02 <Spaceman77> dminuoso: not in a sense that it is useless
06:27:03 <toppler> To give Lisp its credit, it proved itself as both a systems language down to the metal and a high level language. And maybe my imagination is lacking, but Lisp for things like editor scripting (Emacs) is a pretty nice fit.
06:27:43 <Spaceman77> dminuoso: but in the sense that its definition provides no clarity on what it is :D
06:27:56 <toppler> Spaceman77: A lot of what's being called "functional" these days is specifically about *typed* functional languages and, even then, it's about Haskell style type systems. So not Lisp.
06:28:07 <dminuoso> Spaceman77: It's a relatively abstract pattern that is best understood by slowly practicing the various concrete instances.
06:28:16 <dminuoso> Spaceman77: Then slowly a pattern will emerge on its own. :)
06:28:38 <Spaceman77> Can you explein a primarily OOP programmer what a monad is?
06:28:51 <Spaceman77> what does this pattern provide?
06:28:54 <Spaceman77> what does it solve?
06:29:01 <dminuoso> Spaceman77: It doesnt solve something in particular.
06:29:13 <Spaceman77> but it does solve metasomething
06:29:15 <dminuoso> Spaceman77: It's just when you write code, you sometimes repeat yourself.
06:29:32 <dminuoso> And Monad captures a particular repeating theme.
06:29:46 <Cale> Spaceman77: There are many libraries which define some type of computations, parameterised on their type of result
06:30:05 <megaTherion> dminuoso: wouldnt that be called a continuation?
06:30:14 <Cale> Spaceman77: For example, a library for parsing might define (for any type t), a type  Parser t
06:30:32 <Spaceman77> ALright
06:30:38 <Spaceman77> thank you for your answers :)
06:30:46 <dminuoso> Spaceman77: Its like when you write some code. And you write something very similar in another place.
06:30:50 <dminuoso> ANd then something very similar in yet another place.
06:31:03 <dminuoso> You may say to yourself "why not write a common function that does this general thing"
06:31:14 <Cale> where a value of type Parser t is something which knows how to consume the beginning of a string and produce some depleted string and result of type t (perhaps more than one, if it's a parser with backtracking)
06:31:24 <megaTherion> Spaceman77: http://learnyouahaskell.com/chapters is quite a nice book (I think)
06:31:40 <dminuoso> Spaceman77: My best advice is: Do not worry about Monad. Its not helpful to focus on it, and you dont need to understand it to dive into Haskell.
06:31:53 <Cale> Spaceman77: A natural thing you might want to do is to take some parser to run on the initial portion of the input, and use its result to determine the parser to run next.
06:31:53 <dminuoso> You will learn and absorb it automatically through reptition and pattern recognition with your eyes.
06:32:18 <Cale> Spaceman77: i.e. this is an operation of type  Parser a -> (a -> Parser b) -> Parser b
06:32:33 <Cale> It takes some initial parser, and a function which given the result of that parser, produces another
06:32:54 <Cale> and glues them together into a parser which runs both and produces the result of the second parser
06:33:00 <Cale> Make sense?
06:33:08 <dminuoso> Spaceman77: One close analogy is: What does multiplication of numbers, addition of numbers and list concatenation all have in common?
06:33:22 <dminuoso> Spaceman77: There's a common theme to these three things.
06:33:37 <Cale> Also, for any value, we can make a parser which consumes none of the input (but does so successfully), and simply returns the given value
06:33:45 <Cale> i.e. a -> Parser a
06:34:04 <Spaceman77> dminuoso: operators and operands?
06:34:07 <Cale> A monad is a type M for which there are operations
06:34:09 <Cale> a -> M a
06:34:15 <Cale> M a -> (a -> M b) -> M b
06:34:16 <Cale> like this
06:34:21 <dminuoso> Spaceman77: A bit more. number division does not fit into that list.
06:34:46 <dminuoso> Spaceman77: a) they all have a special element that acts as a kind of "zero" element. multiplication by 1. addition by 0. concatenate an empty list
06:34:52 <dminuoso> Spaceman77: and all operations are assocaitive.
06:34:57 <Cale> Spaceman77: and it just turns out that many libraries have operations of those shapes
06:35:15 <Cale> So by abstracting over a choice of one, we can write many useful things that apply generally to all of them
06:35:19 <dminuoso> Spaceman77: So this "shape/pattern/theme" occurs really often. That pattern/theme is called "Monoid"
06:36:32 <Cale> Spaceman77: did you follow what I've said so far?
06:36:57 <Spaceman77> Yes and no :) both of yout and dminuoso's replies have left me overwhelmed
06:37:11 <ab9rf> processing timeout!
06:37:20 <Cale> Okay, let's just look at this more carefully. I think the best way to understand is by way of examples.
06:37:29 <Spaceman77> No need, Cale
06:37:29 <Ariakenom_> parallel monad tutorial > 1 monad tutorial. It's obvious
06:37:30 <Spaceman77> thank you
06:37:52 <Spaceman77> Thing is, before summer i was busy doing my BSc paper and project
06:37:57 <Cale> https://wiki.haskell.org/Monads_as_computation -- you might like this description
06:38:23 <Spaceman77> during that time i came across some blogposts promoting LISP as something that, when understood, helps you become better
06:38:33 <dminuoso> Spaceman77: Like I said, dont focus on it really - you will absorb it on your own. :)
06:38:37 <centril> Spaceman77: http://www.cse.chalmers.se/edu/course/TDA342_Advanced_Functional_Programming/lecture3.html
06:38:53 <Spaceman77> also around that time i installed XMonad on my pc and became intrigued with Haskell
06:39:11 <Spaceman77> So all summer, instead of learning one or the other, i've been unproductively deciding all this time
06:39:15 <ab9rf> Spaceman77: it's a general truism that learning any new way to express programming algorithms will make you better at programming
06:39:35 <centril> Spaceman77: I find it useful to think of a monad in terms of an operation   join :: M (M a) -> M a   as well as   pure :: a -> M a
06:39:37 <megaTherion> also some math foundation can help greatly
06:39:55 <dminuoso> Prolog is also great to pick up :)
06:40:01 <centril> Spaceman77: for example, think of lists, you have  [[a]] -> [a]
06:40:16 <centril> what this operation does is to flatten the list
06:40:48 <ab9rf> prolog is sadly neglected as a programming language
06:40:52 <centril> I also find it useful to think of monads as composition with context
06:40:53 <Cale> Spaceman77: anyway, the whole point, I should mention, is that there are lots of operations which we can write that work with an arbitrary monad -- most of which have a sort of "control structure" feel to them -- and which we can then obtain for free once we implement these couple of basic operations
06:41:04 <rswarbrick> Hi again all! I've got a bit further investigating my space leak (thanks, Cale and merijn), but have a followup question. I've managed to get constant space usage with judicious use of force (from deepseq), but can't work out how to do it with just "seq". Specifically, I have some code like this: "let map' = f cov in force (cov { covMap = map' })". The "force" call ensures that the old value of cov (and its associat
06:41:04 <rswarbrick> ed map) get discarded. This code doesn't have the same effect: "let map' = f cov in seq map' $ cov { covMap = map' }". I think I can see why, but how should I be getting the same effect?
06:41:34 <centril> Ordinary composition is:  (.) :: (b -> c) -> (a -> b) -> (a -> c)
06:41:50 <rswarbrick> (the codebase is at https://github.com/ArgonDesign/acov, file src/acov-report/Raw.hs, this is function "updCoverage")
06:42:08 * dminuoso likes to think of a monad as an endofunctor f for which the set of all (a -> f b) forms a category
06:42:08 <centril> Monadic composition is:  (<=<) :: (b -> M c) -> (a -> M b) -> (a -> M c)
06:42:57 <Spaceman77> centril: i appreciate your effor, but i'm afraid that this is something i need to absorb myself, eventually, to understand it
06:43:00 <Spaceman77> centril: thank you :)
06:43:30 * dminuoso thinks about https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
06:43:51 <Cale> Spaceman77: Yeah, the best thing to do is just learn to use a lot of libraries which happen to define monads
06:44:12 <centril> Spaceman77: I would just try a bunch of examples, particularly involving [a], Maybe, State, Writer, IO, and it will hopefully stick :)
06:44:17 <Cale> Spaceman77: and then you'll have a pretty clear idea of what they all have in common
06:44:32 <c_wraith> I think I "got" monads when I was learning parsec and suddenly just went "oh, it just means this works how I expect it to"
06:44:47 <dminuoso> Spaceman77: My recommendation remains: If you see the word `Monad` just imagine that it's just a programming pattern you dont need to understand. Chances are you have been using it already, but you dont need to know what the pattern is.
06:44:55 <centril> Spaceman77: I find this short post pretty good, https://philipnilsson.github.io/Badness10k/escaping-hell-with-monads/
06:45:11 <dminuoso> c_wraith: same here, monadic parser combinators put the nail into the coffin
06:45:22 <Ariakenom_> dminuoso: I'm pretty sure the key to monads is quantity of tutorials. At once. On IRC.
06:45:31 <dminuoso> c_wraith: Though then I reapproached it from CT and got some pretty cool enlightenment
06:45:44 <centril> the continuation monad still freaks me out sometimes
06:45:46 <c_wraith> The important part is that I'd already built up the expectation from working with lots of other code.  It was just the realization that I already knew it.
06:46:07 <dminuoso> The one thing I still dont have a firm grasp on is applicative functors.
06:46:20 <centril> Is it just me who thinks ContT is weird / don't want to think about?
06:46:24 <dminuoso> I understand them on a law level, but I there's no fundamental intuition..
06:46:31 <rswarbrick> Following up on the question above, this code also doesn't get constant space usage: "let map' = force (f cov) in seq map' $ cov { covMap = map' }" (so the problem isn't that I haven't fully evaluated "f cov"; it's that (I think) the old value of cov is left lying around).
06:46:40 <dminuoso> centril: Have you written ContT yourself?
06:46:53 <Taneb> centril: I'm with you
06:46:54 <Spaceman77> A final question. One that most likely doesn't matter or doesn't make any sense, but i ask it out of curiosity. Would you learn LISP or Haskell first?
06:46:59 <c_wraith> dminuoso: have you seen edwardk talk about Day convolutions and how Applicative is just a special case of them?
06:47:00 <dminuoso> Spaceman77: haskell first.
06:47:05 <centril> dminuoso: it's the continuation transformer monad, pretty sure it is in MTL/transformers
06:47:08 <dminuoso> c_wraith: No but I know that approach too.
06:47:13 <JuanDaugherty> lisp first definitely
06:47:16 <Taneb> centril: I can implement it (by following the types) but I've never been in a place where I wanted to use it or known how to
06:47:19 <dminuoso> centril: No I know, my point was: have you tried implementing it yourself?
06:47:28 <centril> dminuoso: sure
06:47:28 <dminuoso> centril: Its a bit mind bendling if a beginner, but its pretty cool. :)
06:47:31 <megaTherion> why would anybody want to learn LISP? :O
06:47:31 <JuanDaugherty> (if the choice is that or hs)
06:47:37 <toppler> centril: I've only used it once, I think, possibly stupidly. I wanted a nicer syntax for working with alloca for FFI stuff, which all have a continuation type.
06:47:37 <dminuoso> megaTherion: to hack emacs?
06:47:39 <centril> dminuoso: I'm absolutely not a beginner Haskeller ;)
06:47:42 <megaTherion> stuff emacs :p
06:47:47 <Spaceman77> Now this is interesting
06:47:54 <Spaceman77> One said Lisp, one said Haskell
06:47:54 <dminuoso> centril: Fair enough, cant remember everyone in this channel - far too many people :)
06:47:56 <Spaceman77> why?
06:48:05 <ab9rf> i taught myself lisp in 1985... not a lot of haskell around then
06:48:09 <centril> dminuoso: I mostly hang in #rust ^,-
06:48:11 <ab9rf> no, wait, 1982
06:48:18 <dminuoso> Spaceman77: If you know Haskell and if you know an imperative language you have then gotten lisp for free.
06:48:30 <dminuoso> Spaceman77: But if you learn lisp first, you still have to take the hard road and learn haskell
06:48:35 <Cale> dminuoso: That's not really true...
06:48:42 <megaTherion> Spaceman77: you are a Java guy?
06:48:43 <Ke> I don't know lisp
06:48:48 <Cale> There's a lot of weird things about programming in lisp.
06:48:49 <c_wraith> centril: continuations are very roundabout.  I most pretend they don't exist except as a theoretical concept.  The approach has served me well.
06:48:50 <centril> I find LISP has really unfortunate concrete syntax
06:48:54 <ab9rf> Ke: that can be corrected
06:48:58 <Ke> no way
06:49:02 <ab9rf> Ke: it's not hard
06:49:19 <Ke> it has dangerous ideas about types
06:49:28 <centril> c_wraith: ++ Might as well use some imperative language if you're gonna dabble with early returns and stuff
06:49:33 <Spaceman77> megaTherion: I've been mostly doing OOP in C#, so yes
06:49:35 <dminuoso> centril: ah cool - yeah rust is on my TODO list in life: "Forget all about C++ and learn Rust"
06:49:41 <megaTherion> Spaceman77: maybe Closure is for you then ^^
06:49:42 <dminuoso> Its written right onto the wall in my office. With a magic marker.
06:49:45 <megaTherion> err Clojure 
06:49:52 <ab9rf> heh
06:49:56 <centril> dminuoso: You should totally learn it :) Rust + Haskell are a great combo
06:50:10 <Spaceman77> Interesting that you mention rust
06:50:11 <dminuoso> centril: I find langauges without ADTs a real pain to work in nowadays.
06:50:21 <dminuoso> Its beyond me how one can have a language _without_ them
06:50:24 <centril> Speaking of Rust... we should totally reimplement the RTS in Rust
06:50:33 <centril> dminuoso: and pattern matching
06:50:35 * kuribas codes lisp for his job :)
06:50:42 <Spaceman77> I am a roboticist, so when doing robots it's mostly in C or C++
06:50:53 <kuribas> common lisp, not clojure
06:50:57 <ab9rf> Spaceman77: is that for a good reason, or Just Because?
06:51:01 <dminuoso> centril: Also Rust seems to have a fine type system.
06:51:11 <ab9rf> i don't see how C++ is really beneficial for robotics
06:51:14 <dminuoso> centril: C++ feels offensive and.. well. VERBOSE.
06:51:17 <Spaceman77> ab9rf: what exactly?
06:51:36 <veverak> ab9rf: why it should not be? :)
06:51:38 <centril> dminuoso: region typing + parametric polymorphism + type classes, basically
06:51:46 <dminuoso> centril: what is region typing?
06:51:52 <Spaceman77> ab9rf: performance and memory management
06:51:59 <Spaceman77> ab9rf: thats the benefit
06:52:18 <veverak> also much better type system than C ;)
06:52:22 <ab9rf> Spaceman77: so, the usual "just because" reasons
06:52:28 <megaTherion> modern C++ is great... just the syntax is annoying
06:52:31 <dminuoso> veverak: Everything is better than C.
06:52:48 <veverak> megaTherion: true to that
06:52:49 * megaTherion still didnt decide if he should try Rust ....
06:52:54 <dstolfa> dminuoso: except maybe COBOL
06:52:55 <ab9rf> i looked at rust
06:52:56 <dminuoso> veverak: To me the only reason to use C is because you're forced to because your embedded hardware only comes with exotic weirdly written C compilers.
06:53:00 <veverak> dminuoso: but not everything has same performance
06:53:03 <veverak> :)
06:53:05 <nshepperd1> An applicative functor is just a monoid in the monoidal category of  endofunctors, where the tensor is day convolution
06:53:07 <Spaceman77> ab9rf:  why do you think c++ isn't beneficial to robotics?
06:53:08 <ab9rf> but haven't used rust because i haven't had a project for which rust was a good fit
06:53:08 <centril> dminuoso: http://pauillac.inria.fr/~fpottier/slides/fpottier-2007-05-linear-bestiary.pdf
06:53:09 <dstolfa> veverak: C is very shit at performance btw
06:53:09 <dminuoso> veverak: But even then I'd opt for a XYZ -> C compiler :P
06:53:19 <ab9rf> Spaceman77: i don't think C++ is beneficial to pretty much anything
06:53:24 <dstolfa> veverak: the only reason it "performs well" is because a lot of smart people have spent decades making it fast due to legacy code
06:53:27 <dstolfa> that's it.
06:53:29 <ab9rf> it's a grotty garbage-can language
06:53:35 <veverak> dstolfa: ah, I see
06:53:41 <ab9rf> people use it because people have always used it
06:53:45 <veverak> ab9rf: let's just agree to disagree
06:53:50 <Spaceman77> ab9rf: now those are some strong words
06:53:50 <dminuoso> I mean when the choice is "C or C++" then Ill pick C++ but only because C is even worse.
06:53:51 <ab9rf> not because it's particularly good for anything
06:54:18 <dstolfa> if we didn't have CPU vendors spend billions into implementing register renaming, topsorts, branch prediction and speculative execution (look where that got us ;)), C would perform god awful
06:54:36 <centril> As a Rust language designer I know that Rust is less expressive than Haskell; but if you have limited resources (latency, perf, memory allocation) then Rust is a good idea
06:54:36 <ab9rf> dminuoso: i admit that i'll use C++ simply because i can be lazy and use STL classes to save coding time
06:54:52 <dstolfa> note that ISAs are designed around C, so if you ever have trouble understanding cache coherence and why it's so tricky to deal with, or why things like spectre exist, you can blame C
06:54:56 <centril> But I'm working overtime on making Rust as expressive as it can be ^,-
06:54:57 <dminuoso> ab9rf: And C++ has lambdas. You have templates which are better than nothing really.
06:55:14 <dminuoso> ab9rf: Phantom types are also a possibility.. C++ is not bad, it just has a very frustrating UX.
06:55:16 <Spaceman77> I am also considering diving deep into C++, but this Rust language sounds interesting
06:55:31 <dstolfa> Spaceman77: if you know what separation logic is, Rust is just a language that implements it in its type system
06:55:39 <Spaceman77> Languages, languages, languages.....
06:55:44 <dstolfa> well, the ownership part of it anyway
06:55:47 <centril> and if you don't know what separation logic is, you'll be fine as well
06:55:48 <dminuoso> Spaceman77: You can never know enough. ;)
06:56:00 <dminuoso> A programmer who refuses to learn more languages is a programmer not worth hiring. :P
06:56:07 <ab9rf> dminuoso: over time, pretty much everything you might want to have has been smooshed into C++ in some way or another, but it's been done haphazardly, resulting in an ugly, confusing synta
06:56:17 <Cale> If I was choosing to *write* C or C++ by hand and had the freedom to choose only between those two, then I'd pick C++. However, that's a highly unlikely situation. The only situation where I can imagine using either language is where C is perhaps the target language of a compiler I'm writing -- but it's not even particularly good at that anymore, since LLVM exists.
06:56:19 <dminuoso> ab9rf: I fully agree.
06:56:22 <centril> dminuoso: hmm well; I would probably refuse to learn Go :)
06:56:32 <Spaceman77> i am doing a project in Go atm
06:56:35 <Spaceman77> in my job :(
06:56:35 <veverak> dminuoso: that should not be followed blindly
06:56:38 * dstolfa writes C most of the time because he does OS development
06:56:40 * dstolfa hates C
06:56:40 <dminuoso> centril: I should learn Go just to be able to say why its so bad.
06:56:40 <Spaceman77> i dont like it
06:56:40 --- mode: glguy set +v kryft
06:56:42 <ab9rf> dminuoso: and there's a lot of baggage of stuff that C++ allows you to do, but which you should probably not do
06:56:43 <kryft> ab9rf: (or wouldn't be)
06:57:00 <centril> dminuoso: I know *enough* about it to talk about it with some degree of authority
06:57:03 <veverak> dminuoso: day has only 24 hours and you simply do not have enough time to master every lanaguage
06:57:05 <dminuoso> dstolfa: I wish C would die for OS development :(
06:57:10 <veverak> dminuoso: (give nother interesting stuff to learn)
06:57:11 <kryft> ab9rf: Just out of curiosity, where do you think rust would be a good fit?
06:57:11 <dstolfa> dminuoso: i wholeheartedly agree
06:57:14 <dstolfa> dminuoso: it's utter crap
06:57:16 <Spaceman77> Go is bad because all these "good practices" that have been accumulated over the years cannot be applied to Go
06:57:17 <centril> e.g. about its type system, etc.
06:57:19 <Ariakenom_> dstolfa: Done any MISRA?
06:57:32 <centril> Spaceman77: why "good practices" in quotes?
06:57:33 <kryft> ab9rf: (That was my first message before I got voiced)
06:57:43 <dminuoso> veverak: No you dont have to learn every language, but if you are not open to the idea to expand your mind...
06:57:52 <dstolfa> Ariakenom_: of course not, not a single linux/FreeBSD/OpenBSD/NetBSD/illumos dev i know uses it. it's just "i like this more than this other thing"
06:58:01 <Spaceman77> centril: good is a strong word, the truth is somewhere in the middle ;)
06:58:02 <ab9rf> kryft: rust looks to me like a good fit for OS components, and for applications which have a large need to interact with The Real World
06:58:20 <centril> Spaceman77: Personally I feel Go is a regression
06:58:30 <Spaceman77> centril: I agree
06:58:31 <veverak> dminuoso: "open to the idea" and "programmer who refuses to learn more languages" can be considered same and also can be considered as two different statements :)
06:58:32 <centril> At least it is the diametrical opposite of Haskell
06:58:39 <dminuoso> centril: Dunno, compared to C its an upgrade.
06:58:45 <dstolfa> dminuoso: i would really like to see more operating systems in OCaml with functorial dependencies of components, so that operating systems can run in many environments without changing the code and bothering to port the main part of an OS
06:58:48 <ab9rf> centril: i've yet to understand what the benefit of Go is
06:58:48 <Cale> Spaceman77: The first thing I did when I considered picking up Go was to try to implement a polymorphic 'map' function in it, as I usually do when learning a new language and trying to decide if it's going to waste my time or not
06:58:49 <dstolfa> dminuoso: have you seen MirageOS?
06:58:50 <veverak> dminuoso: I refuse new languages withou hesitation, it's not that I am not open to the idea, it's just that I am selective about what to learn
06:58:52 <dminuoso> centril: But in the grand scheme of things it's amazing how Go manages to ignore 30 years of langauge development.
06:58:56 <Ariakenom_> dstolfa: I find it's great for hating C more. You get a warning and you go "Hm, why's that.". And when you look it up you go "OH, who would define a language like this!?"
06:58:57 <Cale> Spaceman77: This proved to be impossible, so I dropped it.
06:59:08 <centril> dminuoso: uh well; C is setting a pretty low bar
06:59:10 <dstolfa> Ariakenom_: oh i know the C spec by heart
06:59:12 <dminuoso> centril: ;)
06:59:20 <dstolfa> Ariakenom_: i am already in the phase of why someone would do that
06:59:22 <ab9rf> dstolfa: i used to, but then they changed it
06:59:37 <dstolfa> ab9rf: the only sane part of it is the C11 concurrency model tbh
06:59:42 <dstolfa> and that's because it was developed semantics first
06:59:56 <ab9rf> dstolfa: i had K&R down pretty much pat, but there are some things changed in the post-K&R specifications that i haven't internalized
06:59:56 <Cale> "Apply an arbitrary function to a list (or array or whatever) of values, obtaining another list (or array, etc.)" is really not too much to ask
06:59:57 <centril> dminuoso: besides, you should justify having a GC with more in terms of correctness than what Go offers imo
06:59:59 <Spaceman77> Another pointless question. SHould i learn Rust first (i am doing masters in robotics, so i need some low level language), or Haskell :)?
07:00:08 <centril> Spaceman77: learn both :)
07:00:10 <ab9rf> Spaceman77: yes
07:00:16 <maerwald> Cale: if you expect haskell everywhere you go, you will always be disappointe
07:00:24 <Cale> maerwald: That's not even Haskell.
07:00:33 <maerwald> you approached the language wrong
07:00:34 <Spaceman77> great answers :D
07:00:41 <centril> Spaceman77: if you are doing robotics, learn Rust first; it will make learning Haskell easier
07:00:46 <maerwald> Go is not about elegance
07:00:49 <maerwald> or abstraction
07:01:06 <dstolfa> Spaceman77: to most people that use programming language, they're tools that help them write faster, cleaner, more bug-free code
07:01:10 <Ariakenom_> dstolfa: You don't happen to have any sinister integer promotion examples?
07:01:12 <Cale> maerwald: If a language can't express enough polymorphism to handle 'map' it's guaranteed to waste too much of my time for me to have any interest writing code in it.
07:01:23 <ab9rf> as far as i can tell, Go is about putting shackles on Google's vast hordes of programming talent that are better on paper than they are in reality
07:01:25 <maerwald> you could have known before that
07:01:43 <centril> maerwald: Go is about making real things at scale? ^,-
07:01:47 <Cale> It's a good initial test for whether I should be interested in a language or not.
07:01:49 <dstolfa> Ariakenom_: most of the examples i usually give have to do with ptr-integer-ptr casts where even on flat memory architectures things get funky across llvm and gcc
07:01:57 <maerwald> sounds rather narrow to me
07:01:59 <Cale> Of course, there are other things I'd like to have as well.
07:02:03 <Spaceman77> As i said i am doing a project in Go. You don't program in go, you painfully grind through the problem with it
07:02:04 <Cale> It's not all that narrow :P
07:02:27 <maerwald> well, it made you no explore the motivation and strengths of the language (there are not many, but...)
07:02:28 <centril> Anyways... Let's not spend more time thinking about Go :P
07:02:31 <Cale> Most good programming languages, and many bad ones, can do this.
07:02:32 <Spaceman77> goroutines and channels look nice first, but then again they are similar to GOTO's (where is my data going from here?)
07:02:39 <kuribas> I know a company that uses go and haskell, "because you cannot do everything in haskell".
07:02:48 <ab9rf> kuribas: that's funny
07:03:08 <kuribas> they only use haskell for transformations.
07:03:09 <Cale> Actually, I should say, every good programming language can express map :P
07:03:18 <Taneb> ...anything I'd want to do in Go I'd much rather do in Haskell
07:03:39 <ab9rf> Cale: and to think of all the FORTRAN i wrote back in the 80s.
07:03:42 <dstolfa> Go is a sorry excuse of Rob Pike to justify his opinions about programming
07:03:47 <maerwald> Cale: why? that sounds pretty arbitrary
07:03:48 <centril> Spaceman77: One thing that I will say is that Rust's community is very friendly and will help you a lot if you need it
07:03:59 <Spaceman77> centril: Thank you :)
07:04:01 <dstolfa> i tend to agree with centril, Rust does have a nice community
07:04:02 <Cale> It doesn't require much.
07:04:17 <centril> Spaceman77: :)
07:04:18 <Cale> and the stuff that it requires I consider basic things
07:04:26 <maerwald> if all you care about is polymorphism, pick language that focus on polymorphism, *shrug*
07:04:40 <Cale> Functions, a tiny amount of polymorphism
07:04:45 <maerwald> don't pick go if you want polymorphism
07:04:45 <glguy> I hate being in a language's irc changed and having them bashing on other languages. Let's leave Go alone
07:04:55 <glguy> Changed-> channel
07:04:58 <ab9rf> dstolfa: i've gotten that impression too. but then again, that is likely by contrast with Go's community, which is obnoxious and irritating. since rust and go are viewed as competitors, rust seems downright friendly by comparison.
07:05:25 <ab9rf> we could pick on BASIC instead :)
07:05:30 <maerwald> ab9rf: rusts compiler is also magnitudes more complicated
07:05:32 <Taneb> I should get back into messing around with Rust... I did a fair bit a couple of summers ago and barely any since
07:05:44 <ab9rf> maerwald: that's not surprising. 
07:06:00 <dstolfa> Cale: does that mean that a language that supports HoTT and is able to polymorphically instantiate functions written for one type to another, seemingly completely different one if there is an isomorphism between them would be the best you can think of today? :>
07:06:27 <Spaceman77> centril: any good books on Rust?
07:06:35 <maerwald> ab9rf: at least Go has a spec, rust doesn't :/
07:06:38 <centril> Yeah, more talk about Haskell, less about other stuff (except for Rust)
07:07:02 <glguy> There's a great channel for talking about rust if you're interested in that
07:07:11 <maerwald> yeah, not on freenode though
07:07:18 <centril> Spaceman77: https://doc.rust-lang.org/book/2018-edition/index.html
07:09:35 <centril> glguy: I would personally love more collaboration between the Haskell and Rust communities =)
07:10:33 <Cale> dstolfa: I would love a practical language based on HoTT.
07:10:46 <centril> Cale: yes please :)
07:10:56 --- mode: glguy set +v isovector
07:10:57 <Cale> dstolfa: However, computing with univalence is pretty hard
07:11:04 <dstolfa> Cale: first we need a syntax for it, but there are bits and bobs you can take in a pragmatic way
07:11:09 <isovector> what is the meaning of roles for typeclasses? 
07:11:20 <centril> Cale: how amenable is HoTT to laziness?
07:11:25 <isovector> coercion of dicts?
07:13:58 <glguy> isovector: I haven't seen that one yet; where'd you encounter it?
07:14:40 <dminuoso> dstolfa: Did you know that you can have objects of type void?
07:14:54 <Cale> centril: That's another open question
07:15:15 <Cale> centril: It shouldn't be impossible, but there haven't been many attempts at lazy dependently typed languages
07:15:18 <isovector> glguy: i'm just playing around with role annotations and noticed that :info will give annotations for classes
07:15:20 --- mode: glguy set +v wpcarro
07:15:26 <Taneb> ...I should also get back into HoTT (I've got the book on my desk)
07:15:34 <centril> Cale: mmh, Dependent Haskell is pretty much the only one?
07:15:37 <isovector> but trying to set one gives this: "• Roles other than ‘nominal’ for class parameters can lead to incoherence."
07:15:40 <wpcarro> I'm having trouble fetching a dependency from GitHub. Right now the process feels opaque to me. Can anyone give me some helpful debugging techniques for deps using Stack?
07:15:44 <Cale> centril: Yeah, and that doesn't even exist yet
07:15:55 <centril> Cale: yeah; vaporware <3 :P
07:15:56 <glguy> wpcarro: Best technique is to share the error you're getting when you don't understand it
07:16:17 <wpcarro> glguy: I'm getting an error that the module I'm trying to import could not be found
07:16:35 <maerwald> dependent haskell, ugh
07:16:41 <glguy> wpcarro: also don't paraphrase error messages when sharing them
07:16:58 <centril> maerwald: it's a great thing.
07:17:04 <maerwald> it's terrible
07:17:05 <centril> can't happen soon enough
07:17:27 <wpcarro> glguy: should I share by pasting plaintext? Or do some IRC clients support markdown?
07:17:30 <maerwald> let's crank up expressiveness, until no one knows anymore what a line of code does. Language design? We don't need it!
07:17:44 <maerwald> just add features like we are doing another C++ :o
07:17:46 <glguy> wpcarro: You should use a paste bin service like gist.github.com
07:17:55 <wpcarro> glguy: great thank you
07:17:58 <madnight> https://beuke.org/haskell-pronounceable-names/
07:18:13 * hackage hora 2.1.0 - date time  http://hackage.haskell.org/package/hora-2.1.0 (procione)
07:18:41 <centril> Cale: I've been thinking about totality and Rust, but there's a niggle wrt. preventing panics... stack overflows... do you know how Agda / Idris avoid that problem?
07:18:47 <maerwald> the subset of problems where you really want dependent types is not as big as you think. If you introduce that expressiveness unconditionally into the language, you are damagint it
07:19:20 <centril> maerwald: I want that choice for myself thank you.
07:19:27 <maerwald> lol
07:19:40 <maerwald> that's... not... how you design a language :D
07:19:44 <wpcarro> glguy: updated. https://gist.github.com/wpcarro/fe5e9eb3c6c3cb2aa34238fe6f5f8a6a
07:20:04 <Taneb> centril: I don't think Agda does anything much to prevent stack overflows and similar
07:20:06 <maerwald> please think of the ecosystem and the impact
07:20:43 <centril> maerwald: It's not like everyone will be using DT instantly everywhere
07:20:45 <dminuoso> Also interestingly C has the actual void type.
07:20:48 <centril> use it where it is needed
07:20:56 <dminuoso> `int f(void f)` is a thing.
07:21:05 <maerwald> centril: well, haskellers like to overuse expressivity, so I'm pretty sure it'll happen
07:21:29 <centril> maerwald: overuse is in the eye of the beholder
07:21:32 <dminuoso> centril: Who needs DTs when you can just toss enough singletons at it?
07:21:38 <dminuoso> *DT
07:21:40 <maerwald> centril: like most things 
07:22:35 <centril> dminuoso: hah; I'm with Eisenberg on this one, singletons are monstrosities ^,-
07:22:58 <ab9rf> singletons are, in my experience, a code smell
07:23:51 <megaTherion> dminuoso: I dont think void f can be a thing
07:24:04 <dminuoso> megaTherion: It absolutely can.
07:24:09 <centril> Taneb: so it's enough to write  'fn main() { let x = [42u8; 1024 * 1024 * 10]; }'  in Rust to blow the stack; and this uses no recursion
07:24:23 <centril> which makes preventing panics difficult I think
07:24:27 <dminuoso> megaTherion: You cant possibly call that function, but hey you cant apply `f :: Void -> Int` either, but it's a valid function.
07:24:35 <dminuoso> Bottom aside of course.
07:24:42 <maerwald> centril: afair, even edward wasn't too keen about dependent types in haskell, because for the subset of problems where you need it you can just pick another language. 
07:24:52 <dminuoso> maerwald: As for void objects, you can declare `extern void f`
07:24:53 <megaTherion> dminuoso: not in C ;)
07:24:54 <toppler> dminuoso: If f is the constant function, I can.
07:24:55 <dminuoso> Err megaTherion ^-
07:25:03 <dminuoso> megaTherion: Yes in C.
07:25:15 <maerwald> centril: mind you, you are introducing a whole new layer of "reasoning" into the language.
07:25:16 <Taneb> centril: ouch
07:25:27 <dminuoso> toppler: Id like you to think very carefully about this again.
07:25:30 <megaTherion> dminuoso: "parameter ('f') has incomplete type
07:25:30 <maerwald> it's nice to know what to expect and what you have to reason about
07:25:38 <centril> maerwald: Staying in one language is a pretty big win; and it's a great way to teach dependent types because Haskell is the gateway to Agda/Idris/Coq I find
07:25:54 <maerwald> if you want to use dependent types, why not use one of those
07:25:56 <dminuoso> @ let f :: Void -> Int; f _ = 1
07:25:58 <glguy> wpcarro: I don't use stack, but now you might have enough information that someone who does could help
07:25:59 <maerwald> it's better that way
07:26:02 <ab9rf> i have enough trouble reasoning about types without throwing dependent types into the mix
07:26:02 <dminuoso> % let f :: Void -> Int; f _ = 1
07:26:03 <yahb> dminuoso: 
07:26:08 <toppler> > f (error "boo!")
07:26:09 <dminuoso> toppler: ^- I challenge you to use yahb to call this function.
07:26:10 <maerwald> keeping everything in one language just leeds to C++ and Scala. both are terrible
07:26:10 <lambdabot>  error:
07:26:10 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M773285115089...
07:26:11 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
07:26:16 <dminuoso> toppler: like I said: bottom side.
07:26:21 <wpcarro> glguy: thanks
07:26:26 <centril> maerwald: because I want laziness and GHCs ridiculous number of optimizations
07:26:53 <toppler> dminuoso: How about an unsafePerformIO?
07:26:56 <centril> and also Haskell is a pretty fine looking language wrt. surface syntax
07:27:39 <maerwald> centril: you already have both
07:27:50 <dminuoso> megaTherion: Oh wait, for a function you may not name it.
07:27:52 <centril> maerwald: huh?
07:28:05 <maerwald> "because I want laziness and GHCs ridiculous number of optimizations"
07:28:10 <dminuoso> megaTherion: no wait, this is weird
07:28:13 <centril> maerwald: *and* dependent types
07:28:32 <maerwald> and that's where you left "language design" and went to "feature request"
07:28:54 <maerwald> welcome to C++
07:28:55 <megaTherion> dminuoso: maybe you meant void* but thats a different type in C.
07:29:11 <dminuoso> megaTherion: Im confused right now. Let me get back to you on that one.
07:29:18 <dminuoso> megaTherion: What you can do for sure is `extern void f;`
07:29:18 <centril> maerwald: I'm opting out of this discussion; I do language design for Rust all the time and don't need to be lectured on what language design is or isn't
07:29:29 <maerwald> rust doesn't have language design :P
07:29:42 <dminuoso> megaTherion: and then use a linker script to do whatever. Then `f` is a proper object of type void. you can even take its address and then obtain a (void *) from it
07:29:45 <maerwald> the RFC workflow is not that bad, but...
07:30:06 <maerwald> no one really looks at the bigger picture and what the newly introduced complexity gives
07:30:09 <centril> maerwald: I don't think you understand how Rust is designed
07:30:24 <ab9rf> could you two find somewhere else to argue this?
07:30:25 <maerwald> my point is, it isn't, it doesn't even have a spec
07:30:49 <centril> ab9rf: I'm done with this anyways
07:31:18 <dminuoso> centril: Are you a rust contributor?
07:31:50 <dminuoso> Oh, a language team member even :)
07:31:57 <centril> dminuoso: yes :)
07:32:08 <centril> to both things
07:32:32 <dminuoso> centril: your name looks suspiciously persian.
07:32:42 <centril> dminuoso: guilty :)
07:33:00 <dminuoso> You should try my Zereshk Polo
07:33:05 * Clint perks up.
07:33:21 <centril> dminuoso: you're Iranian or just a fan?
07:33:24 <dminuoso> Just a fan heh
07:33:32 <centril> dminuoso: :)
07:33:41 <Taneb> Ran into a Haskell library on Hackage today that fails due to AMP :(
07:34:01 <Clint> Taneb: last updated in 2004?
07:34:13 <Taneb> Clint: 2014, actually, not quite so bad as that
07:34:30 <Taneb> "The library requires at least GHC 6.8.1"
07:34:52 <Taneb> http://hackage.haskell.org/package/chp-2.2.0.1
07:36:59 <Taneb> (the infelicity is in an unexported module, Control.Concurrent.CHP.Poison)
07:37:03 <Taneb> http://hackage.haskell.org/package/chp-2.2.0.1/docs/src/Control-Concurrent-CHP-Poison.html
07:37:43 <dminuoso> centril: I also have a farsi colleague, so I have some access to good ingredients and recipes. :)
07:37:56 <Taneb> As far as I can tell it's just Maybe with a different name, too :(
07:38:03 <centril> dminuoso: I should try your Zereshk Polo :)
07:38:04 <dminuoso> or *persian rather I guess
07:38:24 <dminuoso> centril: If you're in northern Germany let me know ;)
07:38:50 <centril> dminuoso: Aight; and if you are ever in Göteborg, Sweden let me know :)
07:49:11 <ph88^> i want to report a ghc bug but i dont want to upload my whole project to the interwebz .. i cant really minimize the code either .. any other alternative ?
07:49:44 <dminuoso> ph88^: why cant you make a testcase?
07:54:37 <glguy> ph88^: If you can't pin down the issue and can't isolate it and can't share the code then you're out of luck unless you want to hire someone to do that work for you
07:55:02 <c50a326> let a = bind lower \inp -> upper inp  -- why am I getting parse error on input '\' here?
07:56:12 <toppler> c50a326: Try let a = bind lower $ \inp -> ...
07:56:42 <ab9rf> or putting the lambda in parentheses
08:02:58 --- mode: glguy set +v dataN
08:03:08 <dataN> this complies with AllowAmbiguousTypes, but this sometimes casuses errors so is rarely used, and so viable uses of this Language extension are not well understood. what could be anticipated use in this example? https://lpaste.net/4815913847950934016
08:08:18 <dataN> what *problems* could be anticipated *from its* use...
08:10:06 <Ariakenom> heartburn, nausea 
08:11:02 <ab9rf> permanent soul corruption
08:12:22 <glguy> The excess of typeclasses and associated types would drive me away from that module before the ambiguous types would
08:13:05 <nitrix> In general monads dont compose, at least not in the traditional sense because of the signature of kleisli arrows, but monad transformers allows for chaining/stacking monads in a way that's /effectively/ what people intend to do when they mean composing functionalities. Thus, my question is: Is it entirely true that monads don't compose? Also, attempts on my own to figure this out lead me to `swap :: (Monad
08:13:07 <nitrix> m, Monad n) => (m (n a)) -> (n (m a))`, to be able to convert `n (m (n (m a)))` into `n (n (m (m a)))` and then use `join` to get `(n (m a))`, but it's very painful to do such composition.
08:13:36 <nitrix> Further digging basically rediscovering a concept akind to comonad.
08:13:48 <nitrix> Someone cares redrawing the bigger picture for me?
08:13:55 <glguy> nitrix: Here's a proof that they don't compose in general https://glguy.net/composing-monads/Help.html
08:14:47 <dminuoso> nitrix: did you watch edwards talk on monad transformer lenses?
08:15:01 <glguy> Of course for those monads that commute you can compose them like you're discovered
08:15:02 <nitrix> dminuoso: Link?
08:15:07 <dminuoso> nitrix: https://www.youtube.com/watch?v=Bxcz23GOJqc
08:15:22 <dminuoso> nitrix: Its a really good talk, but it's lightning fast.
08:15:55 <nitrix> glguy: So there are exception? Are monads that commute pretty much the only way known so far?
08:16:03 <nitrix> glguy: I guess it would if you have a proof :P
08:16:09 <nitrix> Checking
08:17:36 <glguy> nitrix: see the referenced paper for more information you're likely to be interested in
08:18:40 <nitrix> Hahaha. Oh my. It's spot on :)
08:19:10 <dataN> so, how could the code be written so that ambiguous types do not occur?
08:19:10 <dminuoso> nitrix: oh wait a moment, I think I may be confusing this talk with another...
08:19:35 <nitrix> So I discovered their swap, prod and dorp constructions. Very curious to read the whole thing :P
08:19:46 <glguy> dataN: add a proxy parameter or use Data.Tagged
08:20:43 <nitrix> glguy: What are the implications, curiously? Since monads are so imbiquitious for the Haskell eco-system, does that bring a negative tradeoff?
08:21:29 <dminuoso> nitrix: It just means you can't assume (M1 :.: M2) to be a monad.
08:21:44 <dminuoso> If its one, then that's great.
08:21:56 <nitrix> I do remember complicated monad transformer stacks for my little game, to the point where I was using MonadState and such, so that it'd wrap/unwrap the transformer stack at the right level magically for me.
08:29:04 <dataN> glguy: but its an associated type in a class.. there is no place to put a forall... why cant it see the parameter the class is defined over?
08:29:40 <dminuoso> nitrix: Applicatives compose though, so you can write an instance (Applicative f, Applicative g) => Applicative (f :.: g)
08:31:17 <dolio> But do they compose in a way that makes the language do what you want?
08:31:26 <dmwit> dataN: Because the type of `advance` doesn't determine the type the class is defined over.
08:31:40 <glguy> nitrix: monad transformers are best used hidden behind newtypes. You only see the uses of lift in the implementation of problem domain combinators
08:32:18 <nitrix> Makes sense.
08:32:28 <dmwit> dataN: e.g. if one defines `Zipper [] a = (); Adv [] = ()`, then the type of `advance` is `ActS () ()`, which does not mention `[]`.
08:32:46 <dminuoso> dolio: what do you mean?
08:33:16 <dmwit> dataN: Or, to put an even finer point on it, one could make those two definitions and also `Zipper Maybe a = (); Adv Maybe = ()`, and then `ActS () ()` has both type `ActS (Adv Maybe) (Zipper Maybe ())` and type `ActS (Adv []) (Zipper [] ())`.
08:33:34 <dmwit> dataN: This is pretty much the raison detre for AllowAmbiguousTypes+TypeApplications.
08:33:55 <dataN> hmm
08:34:12 <dmwit> (Sorry, "`ActS () ()` *is* both type ...", not "`ActS () ()` has both type ...".)
08:34:27 <dmwit> ?quote dmwit famil
08:34:27 <lambdabot> dmwit says: Type families are not injective. Your first three inscrutable error messages with type families in them will be because you don't understand this rule.
08:34:51 <dolio> I mean that most use of monads and the like in Haskell are to define the algebra of embedded languages. So, is the composition of two applicatives actually the algebra people want when they ask about 'composing monads'?
08:37:16 <dminuoso> dolio: interesting question, I suppose there may be multiple applicative instances for a given (Applicative f, Applicative g) => f :.: g
08:38:10 <dataN> dmwit: the type of Zipper is not abstract, it is defined in the class
08:38:42 <dmwit> dataN: I don't believe anything I said is predicated on Zipper being abstract or Zipper being defined outside the class.
08:38:43 <rswarbrick> Hi all! Just a quick ping for Cale and merijn: Thanks for the help. I eventually fixed the leak with commits 7b8f6a9 and ec11309 at https://github.com/ArgonDesign/acov. Phew!
08:39:08 <dataN> dmwit: defining it as () is not possible
08:39:12 <dmwit> Cale++ merijn++
08:39:17 <dmwit> dataN: What stops me?
08:39:34 <dataN> type Zipper f a = ([Diff f],f a)
08:40:01 <dmwit> dataN: That is just a default implementation. Each instance can do its own thing.
08:40:15 <dmwit> If you want it to be the once-and-for-all definition of Zipper, lift it out of the class.
08:40:58 <dmwit> (And then it won't be a type family any more, just a type synonym.)
08:41:16 <fsestini> is this the indended behaviour for pattern synonyms? https://lpaste.net/1258088941400096768
08:41:45 <fsestini> I would expect ghc to recognize that (B n) is exhaustive (just like (A n))
08:41:47 <dataN> thats confusing, the Constraint on f is then implicit. 
08:42:08 <dataN> but ok.
08:42:29 <dmwit> fsestini: https://ghc.haskell.org/trac/ghc/ticket/8779
08:43:46 <dmwit> fsestini: Oh, ignore that. I thought the issue was still open, but it seems to have been finished. Let me find the right spot in the user manual instead.
08:44:07 <dmwit> fsestini: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#complete-pragmas
08:44:20 --- mode: glguy set +v smudge
08:44:35 <smudge> Hey guys I'm trying to use generics to get a Binary instance for my custom datatype but it's not working. I think it might be to do with how my stack project is set up but I'm not certain. Could someone help me out? Thanks.
08:45:02 <fsestini> dmwit: thanks!
08:45:27 <dmwit> smudge: You should make a code sample that is as small as possible while still showing the problem, and include either the error you get or information about the behavior you see vs. the behavior you want.
08:45:47 --- mode: glguy set +v robotbuddy
08:45:49 <fsestini> is there a quick explanation for why the checker is so naive right now?
08:45:55 <dmwit> smudge: Use a pastebin (don't paste directly into the channel).
08:45:59 <fsestini> and/or if there are plans to improve on it?
08:46:08 <smudge> :dmwit ok thanks, will do
08:46:45 <robotbuddy> what? voiced?
08:46:45 <dmwit> fsestini: Pattern synonyms can include essentially arbitrary code. That doesn't mean nothing can be done, but it does mean not everything can be done.
08:47:17 <dmwit> fsestini: So I suspect the implementers just punted on that until it became clear that it was a significant need.
08:47:38 <dmwit> fsestini: If it is for you, well... GHC is FLOSS. ;-)
08:47:57 <fsestini> fair enough :D
08:48:00 <dmwit> robotbuddy: You should have an explanation in your PMs.
08:48:43 * hackage hzenity 0.2.1 - Haskell interface to Zenity dialogs  http://hackage.haskell.org/package/hzenity-0.2.1 (EmilAxelsson)
08:51:43 <dataN> dmwit: not it gives this error, which is similar; https://lpaste.net/7940878627422339072
08:52:54 <dmwit> dataN: I agree it is similar. Can you reread my previous explanation and make your own attempt at adapting it to this new situation? The explanation is essentially the same; just with some names and maybe some kinds switched.
08:53:27 <dataN> its because it does not mention x.
08:53:34 <dataN> (same with backwards)
08:54:10 <dmwit> Right.
08:54:27 <dataN> but that was the whole point of the class. and, as can be seen in the type of backwards, x *is* mentioned, and could be expected to define 'F x' and 'S x'
08:55:26 <dmwit> x is only guaranteed to be mentioned in the constraint.
08:55:31 <dmwit> That's not enough to avoid being ambiguous.
08:55:58 <dmwit> (Because the compiler is obligated to choose a way of satisfying that constraint, and has no way for you to guide it in that endeavor.)
08:56:08 <dataN> isnt 'Exists (x -> (S x)' and the associated type 'S x' something like a fundep saying it can be determined?
08:56:10 <dmwit> ...*unless* you turn on TypeApplications, of course.
08:56:37 <dmwit> Again: `Exists (x -> S x)` is only in a constraint.
08:57:01 <dmwit> The constrained type must determine all the types used in the constraint, and it doesn't.
08:57:30 <dataN> TypeApplications seems not to do anything.
08:57:43 * hackage hzenity 0.3 - Haskell interface to Zenity dialogs  http://hackage.haskell.org/package/hzenity-0.3 (EmilAxelsson)
08:57:55 <dmwit> AllowAmbiguousTypes lets you write down ambiguous types. TypeApplications gives you a way to use terms whose type is ambiguous.
08:58:01 <dmwit> Two great tastes that taste great together.
08:58:34 <dataN> so where does the @ go?
08:58:38 <dmwit> But yes, it is true: enabling TypeApplications does not allow you to write down ambiguous types or write down terms whose type is ambiguous.
08:59:07 <dmwit> Users of `Forwards` will write `forwards @({- ... -})` or `backwards @({- ... -})`
08:59:25 <dataN> what would go in those braces?
08:59:38 <dmwit> A type which is an instance of `Forwards`.
09:00:07 <dataN> ok, trying that now, thanks.
09:00:38 <dataN> its good that there is a way to use AllowAmbiguousTypes constructivly.
09:09:46 <dataN> how can an associated type of a class defined over a parameter f :: (* -> *) be given, as using forall a. f a in the types definition throws; "Illegal polymorphic type: forall a. ...  In the type instance declaration"
09:10:34 <smudge> Hey guys I can't seem to get generics working in my project, here is a basic example using the binary package : https://pastebin.com/kCuFvGL4. Are there any obvious ways my project could be set up incorrectly to prevent generics working?
09:10:51 <maerwald> I don't really get the point of shake. I've seen it used for docker image building but the cases where the dynamic dependencies actually kick in seem to rare, that it's so much work for almost no gain
09:13:23 <glguy> smudge: you need an instance of Binary for your type
09:13:44 <glguy> Also please avoid pastebin.com
09:14:06 <dataN> oh right, the associated type should also have (* -> *) and mention 'a' explicitly as an extra parameter on the LHS
09:14:40 <geekosaur> smudge, just having a Generic instance is not enough, it won't use that unless you make an empty Binary instance as well. the point of generics here is to use the default, generics-based, instance definition --- which means you say the instance exists but with no implementation, not that it just magics up an instance out of thin air.
09:15:16 <glguy> http://hackage.haskell.org/package/binary-0.8.6.0/docs/Data-Binary.html#g:3
09:15:28 <glguy> smudge: read that section
09:15:35 <dminuoso> smudge: What `generic` does, is give you access to the "structure" of some data type in a generic representation.
09:16:10 <smudge> ah ok, thanks for the explanation
09:18:51 <smudge> if I need to create a binary instance, then what does using generics save me from having to do? 
09:20:00 <glguy> smudge: did you read that section?
09:20:45 <glguy> Read the section above it to see what happens when you don't use generics
09:21:22 <dminuoso> smudge: the class Binary has a default implementation which is: put = gput . from; get = to `fmap` gget
09:21:30 <dminuoso> % :t to
09:21:31 <yahb> dminuoso: (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
09:21:34 <dminuoso> Uh.
09:21:41 <dminuoso> % :t GHC.Generic.to
09:21:42 <yahb> dminuoso: ; <interactive>:1:1: error:; Not in scope: `GHC.Generic.to'; No module named `GHC.Generic' is imported.
09:21:49 <dminuoso> % :t GHC.Generics.to
09:21:49 <yahb> dminuoso: GHC.Generics.Generic a => GHC.Generics.Rep a x -> a
09:22:03 <dminuoso> smudge: In order for that implementation to work the type has to have an instance Generic.
09:22:24 <smudge> oh my bad I just added "instance Foo" and it compiles now
09:22:44 <smudge> "instance Binary Foo" i means
09:23:06 <dminuoso> smudge: So at minimum you need to write `instance Binary Foo` - but if you want to not write your own put/get you can use the default implementation. That default implementation requires your type to have a Generic instamce.
09:23:16 <dminuoso> It will use that Generic instance to do its thing.
09:24:04 <smudge> I see
09:25:20 <smudge> thanks for the help guys, woulda probably been banging my head off the wall for several more hours
09:26:00 <robotbuddy> can a lowly shell scripter learn haskell from scratch at home?
09:26:06 <robotbuddy> asking for a friend
09:26:22 <MarcelineVQ> yep
09:26:27 <nitrix> When did Haskell add do-notation and how much did it affect the readability/usability of programs?
09:26:32 <Clint> learn you a haskell from great scratch
09:27:22 <nitrix> I'm so familiar with `do` that I can hardly immagine what the language might have been in those years.
09:28:12 <glguy> Early [Response] -> [Request] I/O was a mess
09:28:18 <nitrix> The Request/Response system that monads improved upon isn't that uncommon for frameworks in other languages.
09:28:41 <nitrix> glguy: Right. I'm more curious about the impact of the do-notation in itself.
09:28:45 <nitrix> glguy: Or did both happen simultanously?
09:29:46 <glguy> That's before my time, I'm not sure. I've only read code using the old system
09:30:18 <glguy> Just using >>= isn't terrible, though
09:30:53 <nitrix> You lose let-expressions, if I'm correct?
09:31:09 <dminuoso> nitrix: no?
09:31:13 <glguy> Nope, you just use the normal let-in expressions
09:31:22 <nitrix> Ah I see.
09:31:37 <dminuoso> f >>= \x -> let g = f x in ...
09:32:27 <dminuoso> nitrix: you can write with >>= and hanging lambdas, it kind of looks like do-notation even :)
09:34:05 <nitrix> dminuoso: Not too different than lisp :P
09:34:13 <smudge> (>>=) :: m a -> (a -> m b) -> m b, seems to suggest that you can chain monads with bind in two seperate ways, either inside the (a -> m b) where the a stays in scope or in the resultant m b where a has fallen out of scope, is this correct?
09:34:49 <dminuoso> smudge: Nope
09:35:13 <glguy> smudge: Yes, you can write:  (m >>= \x -> n) >>= z     --or--   m >>= \x -> n >>= z
09:35:48 <dminuoso> oh?
09:36:48 <glguy> smudge: and one of the monad laws says: m >>= (\x -> k x >>= h)  =  (m >>= k) >>= h
09:36:56 <dminuoso> glguy: Are you sure you didn't misread that?
09:37:52 <glguy> dminuoso: Yeah, I think the point is that 'x' is/isn't in scope to be used in the use of 'z'
09:37:57 <nitrix> glguy: So, if I continue my thought experiment of listing things that are fundamental for the language, one could get rid of the do notation, even go as far as the IO system and monads, which are very significant cornerstones of the language, yet, removing something as simple as let-expression is braking important semantics.
09:38:13 <ab9rf> do notation is entirely dispensable
09:38:30 <smudge> let expressions aren't necessary surely?
09:38:34 <dminuoso> do-notation has built-in fail though..
09:38:45 <dminuoso> smudge: Can you elaborate what you mean by your question?
09:38:52 <nitrix> I like that word. Would looking at Core be a good starting point for finding out what's dispensable and what isn't?
09:38:56 <ab9rf> i think let expressions can probably also be done away with, but doing so is much harder
09:39:01 <nitrix> (System F maybe)
09:39:29 <smudge> dminuoso: the one about monads?
09:39:33 <dminuoso> smudge: yeah
09:39:42 <nitrix> ab9rf: Possibly with many small helper functions having `where` clauses?
09:40:00 <dminuoso> smudge: I read your question rather differently from how glguy read it, so Im curious what you meant.
09:40:00 <monochrom> You can't get rid of let because it's letrec.
09:40:16 <ab9rf> monochrom: you ca, butr you have to do ugly things with fix
09:40:36 <monochrom> And fix is taken for granted?
09:40:40 <nitrix> I'd rather not go down the fix route :X
09:41:15 <ab9rf> monochrom: well, if you don't have a y combinator, anonymous recursions are a bit tricky :)
09:41:19 <nitrix> I like that you followed my train of thought though :)
09:41:29 <smudge> dminuoso: ok so there are two (m b)'s in the type of bind which indicates that at either of those places you could bind another (b -> m c) function thereby chaining monads
09:41:41 <nitrix> Are you both suggesting that ultimately, it boils down to SKI combinators?
09:41:46 <dminuoso> smudge: Nope! The second (m b) is the return type!
09:41:47 <ab9rf> nitrix: doesn't it always?
09:42:14 <smudge> dminuoso: yes but there is nothing preventing you from chaining from that point if you wanted to
09:42:16 <nitrix> What is Haskell based on? BCKW?
09:42:22 <glguy> dminuoso: Maybe just explain your interpretation because while I wouldn't use the same words, smudge's understanding makes sense
09:42:29 <ab9rf> nitrix: if your language is based on the lambda calculus, you're going to get down to SKI conmbinators, or to something isomorphic to them
09:42:40 <dminuoso> glguy: To me it sounded like mass confusion about haskell types.
09:43:18 <nitrix> ab9rf: thank you for reminding me <3
09:44:01 <nitrix> And off I go designing λ-calculus systems :P
09:44:03 <ab9rf> nitrix: at some level, let is just sugar for binding something to something else, which you can do with a lambda application
09:44:31 <nitrix> Alpha conversion?
09:44:56 <dminuoso> smudge: the `m c` what you *get* from that second function
09:44:58 <nitrix> Oh you said applying, so b-reduction.
09:44:59 <ab9rf> nitrix: i don't remember the specifics at this point, i don't use that stuff enough to remember it
09:45:10 <dminuoso> smudge: `m a -> (a -> m b) -> m b` there is not two `m b` floating around. There's exactly one.
09:45:14 <ab9rf> nitrix: and it has been decades
09:45:16 <glguy> dminuoso: Yes, and you can use that result as the argument to another >>=
09:45:22 <monochrom> "there are two (m b)'s" is a very poor reason.  But it is the second m b that's chainable.
09:45:31 <glguy> dminuoso: Or you can use >>= inside the 2nd argument of >>=
09:45:32 <nitrix> ab9rf: Still, you headed me in the right direction. Now I have a formal system to build upon.
09:45:47 <dminuoso> glguy: and that's different how?
09:45:48 <nitrix> Thank you :_)
09:45:55 <ab9rf> nitrix: i try to remember enough of it to be able topoint myself (or someone else) in the right direction
09:46:00 <dminuoso> glguy: Isn't the (m b) from the 2nd argument *precisely* that?
09:46:11 <glguy> dminuoso: because in one case the argument to the second function is available
09:46:15 <glguy> and in the other it is not
09:46:24 <smudge> dminuoso: it would be the difference between (m >>= (\x -> n)) >>= f and (m >>= (\x -> n >>= f))
09:46:26 <ab9rf> nitrix: one of the side effects of having studied law. there's no way youc an remember all of the law, so the goal is to remember enough of it to be able to narrow further research :)
09:46:27 <glguy> which is the difference that smudge called out originally
09:46:28 <MarcelineVQ> nitrix: if you want system names then ghc is system fc
09:46:34 <monochrom> You can't just look at "Int -> Int" and say "there are 2 Int's".  They play opposite roles.
09:46:43 <ab9rf> there are four lights
09:47:00 <dminuoso> smudge: so your question is about associativity? ;)
09:47:01 <MarcelineVQ> previously system fw, and it's probably past fc by now as well I would guess
09:47:11 <dminuoso> glguy: fair enough, maybe Im just too confused to understand this.
09:47:17 <ab9rf> is this whole argument about the associativity of bind?
09:47:33 <glguy> dminuoso:  It's about associativity if you reframe the laws in terms of Kleisli composition
09:47:46 <monochrom> glguy: The difference is that smudge claims that the first m b is also chainable.
09:48:06 <nitrix> MarcelineVQ: Is my understanding that System FC is System F + ADT, which in turn System F is lambda calculus with the concept of types and polymorphism?
09:48:06 <dataN> dmwit, glguy: here is the example working https://lpaste.net/7086381423455633408
09:48:17 <glguy> "chainable" isn't a technical term. I'm interpretting it as meaning "I can use >>= here"
09:48:17 <nitrix> MarcelineVQ: correct*
09:48:40 <smudge> but we do chain off the first (m b) that's how we keep all the relevent values in scope right?
09:48:58 <dataN> turned out not to need TypeApplications...
09:48:58 <smudge> yeah my bad for the bad terminology
09:48:59 <monochrom> That's my abbreviation.  The whole thing is "chainable to b -> m c" very specifically.
09:49:12 <dminuoso> smudge: its not a scope question.
09:49:22 <ab9rf> i have no idea what "chainable" means in this conversation
09:50:16 <dminuoso> smudge: The last example made your question clear, it's still beyond me how glguy understood you - my hat off to him :)
09:50:16 <dminuoso> smudge: Monad laws *require* both to be the same thing.
09:50:17 <MarcelineVQ> fairly, fc is what allows gadt  https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/FC
09:52:19 <nitrix> MarcelineVQ: I guess my last question is, is that a modification or an addition to typed lamda calculus? As in, which one is more general or powerful?
09:52:56 <nitrix> MarcelineVQ: Normally, more general is more powerful, but here you seem to loose generality to provide new capabilities to the language.
09:53:02 <smudge> dminuoso: I'm still not sure how scope is not relevant here :/
09:54:03 <nitrix> MarcelineVQ: If it's not clear, it's fine. I have to read about all this anyway, so I'll soon find out.
09:54:15 <MarcelineVQ> I'm actually not sure how to use the word general. as I would probaly say untyped lambda calc is way more general, but way less useful
09:55:28 <monochrom> "power" is also ambivalent.
09:55:30 <MarcelineVQ> My point there being that I'm not sure if more general means more powerful since the word is a little mysterious to me
09:55:35 * dstolfa refrains from using the word "untyped" because it becomes impossible to explain that all programs are fundamentally typed right after. he instead prefers unityped lambda calculus
09:56:23 <ab9rf> dstolfa: i've always wondered just what the untyped lambda calculus actually does
09:56:34 <MarcelineVQ> it reduces when possible :>
09:56:46 <dmwit> smudge: A possible interpretation of your question: suppose you had `act1 >>= (\a -> act2 >>= \b -> act3 a b)`. Here `act3 a b` appears to need both `a` and `b` to be in scope. If I wanted to rewrite it as `act1 >>= (\a -> {- something mentioning act2 -}) >>= \b -> {- something mentioning act3 -}`, then `a` appears not to be in scope in the `something mentioning act3`.
09:56:50 <dstolfa> ab9rf: it's lambda calculus with non-normalising beta reduction
09:56:55 <dstolfa> STLC makes it strongly normalising
09:57:06 <ab9rf> dstolfa: yes, but that doesn't tell me what it's useful for :)
09:57:08 <nshepperd> stringly typed lambda calculus
09:57:08 <dmwit> smudge: So then your question is: can we rewrite into that form? And the answer is, perhaps surprisingly, yes.
09:57:26 <monochrom> Typed lambda calculus is "more" "powerful" because it affords free theorems.  Untyped lambda calculus is "more" "powerful" because it admits more recursions.  Note that these are two opposing powers.
09:57:55 <dmwit> smudge: By writing `(act1 >>= (\a -> fmap ((,) a) (act2 a)) >>= \(a, b) -> act3 a b`.
09:58:01 <ab9rf> monochrom: now that was a useful statement
09:58:04 <dmwit> smudge: See the trick? We can run `act2` but remember `a` at the same time.
09:58:08 <dstolfa> monochrom: outta my head
09:58:14 * dstolfa shoos monochrom 
09:58:50 <smudge> dmwit: wow ok
09:59:00 <monochrom> "power" is always ambivalent.  The question is never whether there is power.  The question is always whose power.  #dialecticclassstruggle
09:59:12 <MarcelineVQ> nownow
09:59:17 <ab9rf> monochrom: marx on lambda calculus
09:59:42 <dstolfa> ab9rf: as for recursion itself, the fixpoint combinator should make it a little more clear as to what's happening
09:59:51 <monochrom> Same thing with forall vs exists. :)
09:59:52 <smudge> dmwit: oh it's like Writer
10:00:06 <dmwit> a bit like =)
10:00:12 <dstolfa> as the name suggests, these functions live in the world where they are continuous and hence we can literally find a fix point of such functions
10:00:15 <dstolfa> hence the name "fixpoint combinator"
10:00:23 <nitrix> monochrom: MarcelineVQ ab9rf Lovely, I'm truely enjoying this :)
10:00:55 <ab9rf> while i enjoy these conversations, i'm not sure that they actually expand my knowledge
10:01:09 <smudge> dmwit: should I just start learning category theory if I want to understand this stuff better? I thought I understood monads pretty well up until now
10:01:11 <ab9rf> then again, i'll be 50 soon, and thus no longer required to expand my knowledge :)
10:01:40 <nitrix> It's a great refresher for me before I begin working on my little idea related to this :]
10:01:49 <ab9rf> i have subordinate units to do that for me now
10:02:02 <monochrom> Oh, I was just framing what you already knew in a new perspective.
10:02:21 <dmwit> smudge: That seems like a possible route. I also really liked sigfpe's article for the intuition + All About Monads for the practice seeing lots of examples of monads.
10:02:27 <nitrix> ab9rf: Is that how it works!? 25 more years of pain ahead of me, haha.
10:02:29 <dstolfa> ab9rf: i'm sorry i'm not a bit more practical. i don't usually think in haskell terms but as abstractly as possible. i couldn't tell you off the top of my head what real world usecases there are currently, i'd have to work it out from the theory and looking at problems
10:02:32 <monochrom> I always like to make fun when programmers speak of "power" and "any".
10:02:33 <dmwit> ?where ychimamyah
10:02:34 <lambdabot> I know nothing about ychimamyah.
10:02:45 <dmwit> ?google you could have invented monads and maybe you already have
10:02:46 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
10:02:46 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
10:03:07 <ab9rf> dstolfa: for all i know you are. i'm old and tired and in pain most of the time, it's really hard for me to learn new things
10:03:08 <nitrix> monochrom: Granted I knew what kind of answer I'd get, having confirmation really helps.
10:03:45 <nshepperd> programming is a constant struggle between I, the writing programmer, and I, the reading programmer
10:03:48 <dstolfa> ab9rf: well, you're not the only one who tells me that i'm spewing abstract nonsense, all my coworkers to but they tolerate it because when we're dealing with actual problems some good comes out of it :-)
10:03:58 <dstolfa> s/to/do/
10:04:08 <dminuoso> Is there some implied law that for (>>=) the result must be exactly the result from applying the second argument to the "result" of the first?
10:04:15 <dminuoso> Actually.. strike that!
10:04:15 <ab9rf> dstolfa: i've been around long enough to realize that abstract nonsense sometimes helps in understanding concrete issues
10:04:25 <dminuoso> I should know better to ask that. Counter-example []
10:04:51 <dstolfa> dminuoso: i love how sometimes questions like that pop up and the moment you type it you realise that it should be obvious :-)
10:04:56 <ab9rf> heh
10:05:03 * dstolfa has that all the time
10:05:15 <dminuoso> dstolfa: In fact it's wrong to think that thought on so many levels.. :)
10:05:17 <ab9rf> the act of stating the question elicits the answer
10:05:31 <nitrix> dminuoso: The type system ensures the type stays the same with those type variables, and we, additionally, have laws for the Monad type class, correct. Left/right identity and associaitivity.
10:05:53 <nitrix> dminuoso: Plus, the implications of the constraints on Applicative and Functor, with their own laws.
10:05:58 <dminuoso> nitrix: the type staying the same is far different from value staying the same, and I should really know that it cant stay the same..
10:06:11 <nitrix> dminuoso: The second part addresses this.
10:06:26 <nshepperd> i think the polymorphism of >>= and the laws involving 'return' ensure that if the input has a "result" the function must be applied to it
10:06:43 <dstolfa> nshepperd: i'm not sure how?
10:06:49 <dstolfa> nshepperd: i can give you an input and use some global constant instead
10:07:04 <dminuoso> nitrix: getLine >>= const (putStrLn "hello world")
10:07:10 <dstolfa> ^
10:07:15 <nshepperd> dstolfa: that would violate m >>= return = m
10:07:18 <dminuoso> nitrix: If what I said was true, then that would be the same as putStrLn "hello world"
10:07:19 <nitrix> dminuoso: `return a >>= f = f a`. You cannot arbitrarily decide that your implementation for >>= just discards the value and cooks up a new one.
10:07:20 <dminuoso> which it clearly is not
10:07:30 <monochrom> Intuitively speaking, polymorphism ensures that >>= cannot conjure its own "a" values.
10:07:37 <ab9rf> nitrix: why not?
10:07:55 <dminuoso> nitrix: not discard, but it may not be able to do it yet.
10:08:06 <dminuoso> nitrix: in case of IO or Async you simply do not *have* the input ready yet
10:08:18 <dminuoso> so you have to conjour something out of thin air
10:08:19 <nitrix> Yeah you can be lazy about it but you cant discard it afaik.
10:08:32 <nitrix> Because you ultimately have a functor.
10:08:41 <nitrix> Something must be there:/
10:08:49 <dstolfa> nono, you can't discard it
10:08:50 <monochrom> OTOH, >>= does not even need to call the 2nd function.
10:08:53 <dstolfa> but it doesn't stop you from writing it
10:08:54 <ChaiTRex> What package is the IO constructor in?
10:09:02 <ab9rf> ChaiTRex: what IO constructor?
10:09:15 <ChaiTRex> abra0: The one that wraps RealWorld function.
10:09:33 <MarcelineVQ> It's not in a package, it's int he ghc source tree
10:09:42 <ab9rf> ChaiTRex: aha
10:09:45 <dminuoso> dstolfa: why cant you discard it?
10:09:52 <monochrom> GHC.IO? GHC.Prime? GHC.Types?
10:09:54 <dstolfa> dminuoso: well, try your example in ghci
10:09:54 <nitrix> dminuoso: Notice how >>= in your example still has to pass the value foward to the lambda, even if you proceed to get rid of it later on with `const`, which btw is the same as >>
10:10:07 <dminuoso> dstolfa: let me ponder on it a real long while
10:10:16 <ChaiTRex> monochrom: Thanks. GHC.Types works.
10:10:17 <dminuoso> Lets try the Feynman algorithm
10:10:32 <dstolfa> dminuoso: what you can do, as nitrix said is getLine >> putStrLn ("hello")
10:10:48 <dstolfa> but that won't give the same result as your example
10:11:15 <MarcelineVQ> oh is it in prim? neat
10:12:02 <monochrom> Haha fun typo. GHC.Prime is like Amazon Prime. :)
10:12:32 <nshepperd> in 'fmap f (ma :: m a) :: m b' f is free to ignore the 'a' that it gets, but it has to be passed some 'a', eventually. unless 'ma' doesn't have any 'a's in the first place
10:12:53 <monochrom> "GHC Prime subscribers get new GHC versions 3 days before the general public release!"
10:13:05 <ab9rf> hehe
10:13:15 <nshepperd> because applying f is the only way for fmap to get a 'b'
10:14:06 <monochrom> No no, you need to weaken that a bit.  Const doesn't even use f.  And Maybe uses f sometimes but not always.
10:14:22 <ab9rf> something feels wrong to me in that
10:14:31 <dataN> ok, here is an example where TypeApplications might help, how would that work? https://lpaste.net/2242397473144307712
10:14:33 <monochrom> So you have to weaken it to "if fmap uses f, it has to rely on ma for the 'a' value"
10:15:26 <nitrix> dminuoso: Given the law `return a >>= f = f a`, you can see how the value cannot be tempered with. e.g. `return 42 >>= (+1) = (+1) 42`. If >>= did anything else, you'd violate the law and brake our equational reasoning.
10:15:29 <monochrom> Similarly, in m >>= k, you have to add the precondition "if >>= decides to use k".
10:15:35 <nshepperd> What does "ma has an 'a'" mean? something like "the type variable 'a' is not phantom in the constructor of ma"
10:15:56 <nshepperd> monochrom: but the point is >>= can't just *decide* not to use k
10:16:32 <monochrom> []'s and Maybe's and Either's >>= make that decision during runtime all the time.
10:16:32 <glguy> instance Monad Proxy where
10:16:33 <glguy>     _ >>= _ = Proxy
10:16:42 <nshepperd> the only time it can not use k, is with types like Const and Maybe when there's no 'a' value to rely on
10:16:43 <monochrom> Const's >>= make that decision statically.
10:17:01 <monochrom> OK we violently agree.
10:17:32 <glguy> Const doesn't have a Monad instance
10:17:40 <monochrom> Yikes
10:18:12 <nitrix> It'd be disaster, it'd violate the law I just mentioned :P
10:18:15 <nshepperd> fine, types like Proxy and Maybe and [] and Either :)
10:18:16 <nitrix> Left identity :P
10:18:59 <monochrom> S -> [(S, a)]
10:19:38 <monochrom> Also IO. Exceptions happen.
10:20:27 <monochrom> "evaluate (div 1 0) >>= \x -> print x" is not going to let that printing happen.
10:22:05 <nitrix> Could GHC verify laws?
10:22:06 <ab9rf> someone needs to make IO break less
10:22:14 <ab9rf> exceptions are a pain
10:22:42 <monochrom> http://www.vex.net/~trebla/haskell/exception.xhtml
10:23:55 <dataN> is it possible to make Ambiguous Types work in this example by using TypeApplications? https://lpaste.net/2242397473144307712
10:25:42 <nshepperd> you can't write a Monad instance for a type m where 1. a is not phantom in m a and 2. ma >>= k never applies k
10:25:54 <glguy> dataN: Yes you can
10:26:04 <nshepperd> i'm not sure of the correct phrasing of #1, but it's something like that
10:26:43 <nshepperd> *you can't write a lawful instance
10:27:20 <nshepperd> the haskell police won't arrest you for writing an unlawful instance.
10:27:33 <ab9rf> not yet, at least
10:28:23 <dataN> glguy: how?
10:28:40 <glguy> dataN: what part are you stuck on?
10:28:48 <dataN> where does the @ go?
10:29:34 <glguy> after the variable for which you want to specify the type application
10:31:12 <dataN> eg = (forwards ([],[1,2,3])) @ Maybe (Zipper [] Int) ?
10:32:06 <dataN> because that throws; Cannot apply expression of type `Maybe (Zipper f0 a0)' to a visible type argument `Maybe'
10:32:29 <vaibhavsagar> is there a fix for the lack of MonadFail instances for polyparse?
10:32:56 <nshepperd1> It has to go after the variable. Which means for a function before the arguments
10:33:56 <nshepperd1> dataN: forwards @Maybe ...
10:34:07 <glguy> nshepperd1: right place wrong type
10:34:17 <nshepperd1> Err
10:34:29 <nshepperd1> Also put the type in parens
10:34:52 <nshepperd1> forwards @(Maybe (Zipper [] Int))
10:35:14 <dataN> forwards @ (Next (Zipper [] Int)) ?
10:35:21 <glguy> None of those
10:35:46 <glguy> dataN: Have you read through this? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=typeapplications#extension-TypeApplications
10:36:10 <dataN> which throws; Expected kind `* -> *', but `Next (Zipper [] Int)' has kind `*' In the type `(Next (Zipper [] Int))'
10:38:52 <dmrd> Hey all, quick one: given a string representing an import statement in a file, is there a way to directly map it to what package that import statement is referring to? So, for example, if I do 'Data.ByteString.Short',  I'm looking for a service that tells me that this refers to the ByteString hackage.
10:39:16 <glguy> dmrd: there's ghc-pkg find-module
10:40:52 <glguy> (for when you already have the module installed)
10:41:44 <dataN> :set -XTypeApplications -fprint-explicit-foralls
10:41:56 <dataN> :t +v forwards @ [] @ Int forwards @ [] @ Int   :: Forwards [Int] => Next ([[Int] -> [Int]], [Int])
10:41:57 <lambdabot> error: parse error on input ‘@’
10:42:48 <glguy> dataN: drop the space after the @
10:42:51 <dmrd> glguy, thanks for always responding so promptly. Ideally, I'd like to circumvent the process of installing modules. i'm just interested in finding the name of the module so I can do some processing on its documentation: namely finding the type signatures of its API. Maybe that isn't possible, although I suppose I could always try to do some trial and error by searching for the import among all dependencies listed in the
10:42:51 <dmrd> stack.yaml or .cabal file
10:43:13 <dataN> :t +v forwards forwards :: forall (f :: * -> *) a. Forwards (f a) => Next ([F (f a)], S (f a))
10:43:15 <lambdabot> error:
10:43:15 <lambdabot>     Not in scope: type constructor or class ‘Forwards’
10:43:15 <lambdabot> error:
10:43:19 <dataN> oops sorry
10:43:24 <glguy> dmrd: There's no definitive answer. I think you'll need to use Google or hoogle or similar otherwise
10:43:42 <dmrd> glguy: thanks. I'll do some digging
10:43:50 <dataN> glguy: ok this will make an example possible, Thanks
10:48:46 --- mode: glguy set +v dataN_
10:48:50 <dataN_> here is the code working; https://lpaste.net/2462252115972587520
10:49:13 <glguy> yay, you figured it out :)
11:21:44 <Gurkenglas> Is there an IO (FilePath -> FilePath) version of http://hackage.haskell.org/package/directory-1.3.3.1/docs/System-Directory.html#v:canonicalizePath ?
11:26:02 <MarcelineVQ> what does the one you're imagining do?
11:26:32 <MarcelineVQ> as in, how is it asking for its argument
11:32:24 <Profpatsch> What’s the nicest way of traversing over a Map k v  with a function (v -> Either e a) and collecting the errors into  Validation (Map k e) (Map k a)?
11:33:09 <Profpatsch> Pretty nonstandard now that I think about it and using the fact that Map is a Semigroup.
11:35:58 <ab9rf> Profpatsch: you're looking for a genrealization of partitionEithers
11:36:20 <ab9rf> i don't know if anyone has actually done that
11:38:06 <ChaiTRex> Is there anything other than NOINLINE that needs to be done to make it so that a top-level Int (dontRecalculateMe :: Int) value is only calculated once?
11:38:49 <Profpatsch> ab9rf: lol, you are right.
11:40:47 <ab9rf> Profpatsch: i don't see why you couldn't implement Traversable t => t (Either a b) -> (t a, t b) 
11:41:32 <Profpatsch> ab9rf: No, it’s not (,), but Either in the reslut.
11:41:34 <Profpatsch> *result
11:41:46 <Profpatsch> So not really a generalization of partitionEither
11:42:25 <ab9rf> Profpatsch: you used a data constructor instead of a tuple, but that's a simple translation
11:42:51 <Profpatsch> Validation is Either
11:42:57 <Profpatsch> With collection semantics
11:43:00 <ab9rf> ah, i'm not familiar with Validation
11:43:14 <Profpatsch> I don’t think there’s a generalization really.
11:43:18 <ab9rf> probably not
11:44:12 <ab9rf> actually,Validation is a Foldable
11:44:27 <ab9rf> oh, wait no, misread the doc
11:44:36 <Profpatsch> Well, you could say  Semigroup s => (a -> Either e b) -> s a -> Validation (s e) (s b)
11:45:45 <Profpatsch> Which doesn’t make sense, because s must be kind *
11:46:20 <ab9rf> map (Either a b -> Validation a b) over the Map, then fold
11:47:33 <dolio> traverseWithKey?
11:47:55 * hackage OpenGLRaw 3.3.1.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-3.3.1.0 (SvenPanne)
11:48:10 <Profpatsch> Yeah, I have traverseWithKey, but it feels overly verbose.
11:48:37 <MarcelineVQ> :( take #ghc off no-pleb mode
11:49:39 <philippD> Profpatsch: what about Alternative instead of Semigroup?
11:50:39 <dfeuer> carter: please have a look at https://github.com/haskell/primitive/pull/194 soon. There's plenty of time before we need to merge it, but I bet you will have gripes about my names, and I will not be surprised if my type families spin you into a tizzy. Let's get this hashed out before 8.8 gets too close.
11:50:39 <MarcelineVQ> AndreasK: re your foldl question from the other day https://ghc.haskell.org/trac/ghc/ticket/7994
11:51:10 <carter> dfeuer: :) will do
11:51:25 <dolio> I don't see how it could be much less verbose than traverseWithKey unless someone used it to write the exact function you want already, which probably isn't the case.
11:51:35 <carter> dfeuer: I’ve been a tad slow all summer but starting to catsup on my backlog. 
11:51:40 <dfeuer> Thanks.
11:52:03 <carter> dolio: we should catsup if you have time for helping maintainafai. :)
11:52:22 <Profpatsch> catsoup?
11:52:24 <dolio> I don't, really.
11:52:32 <dolio> Getting out of the maintenance game.
11:52:54 <carter> Smart
11:53:25 <AndreasK> MarcelineVQ: Thanks for the link!
12:01:23 <carter> Profpatsch: catch up.  But like ketchup is keysup
12:01:33 <carter> Katsup
12:01:38 <carter> Ketsup?
12:01:52 <Profpatsch> carter: There’s a pretty disturbing animation of that name: https://en.wikipedia.org/wiki/Cat_Soup
12:02:17 <carter> Why would I click on that link?
12:02:40 <MarcelineVQ> Not to be confused with a film featuring very animated people, duck soup
12:03:08 <Profpatsch> lol
12:03:43 * hackage multipart 0.1.3 - HTTP multipart split out of the cgi package  http://hackage.haskell.org/package/multipart-0.1.3 (ErikHesselink)
12:28:33 <nitrix> When the domain of discourse for universal quantification is a type variable with a type class constraint, does this count as a witness?
12:29:13 <nitrix> Hopefully I asked that correctly.
12:29:45 <dolio> I'm not sure you did. :)
12:30:03 <nitrix> Let me guess, witnesses are only for existentials?
12:30:13 <dolio> I just don't know what you're asking.
12:34:41 <nitrix> Does having a type class constraint in a type signature with universal quantification be sufficient to prove that there's a type (witness) t --- meh, I already know this is wrong just by typing it. I'm describing existentials -.-
12:35:07 <nitrix> Time to backtrack. How the heck does Haskell represents existentials with only universal quantification?
12:35:58 <nitrix> data T = forall a. C a
12:36:10 <nitrix> Syntaxically it's simple, but formally, how does that looks like?
12:38:58 <[exa]> there's the paper about Fc system
12:39:06 <dolio> The point of that is that it makes sense for that to be a `forall` because of where it appears.
12:39:21 <dolio> That is `data T = C (exists a. a)`
12:39:48 <nitrix> dolio: So the forall is essentially exists because it's so far to the right in the type declaration?
12:40:11 <dolio> But when you move the a past the constructor, it's saying that for all a, C is a constructor of T with field type a.
12:40:22 <nitrix> What if T wasn't parametrized, like.... data forall a. T = C a ?
12:40:44 <dolio> No, it's forall because it's outside the constructor rather than inside.
12:40:59 <nitrix> Oh sorry I misread.
12:41:01 <dolio> Also, the type of the constructor is given as: C :: forall a. a -> T
12:41:18 <dolio> Because `forall a. a -> T` ~= `(exists a. a) -> T`.
12:41:47 <Mitsos101> How can I do something like this with a Set? f p x s = when p (S.insert x) s
12:42:14 <dmwit> Mitsos101: if p then S.insert x s else s
12:42:19 <Mitsos101> I've thought of f p x s = if p then (S.insert x s) else s but I have to type `s` twice and it doesn't really seem optimal
12:42:32 <dmwit> (if p then S.insert x else id) s
12:42:46 <Mitsos101> looks great, thanks
12:43:00 <dmwit> S.fromList [x | p] <> s -- ;-)
12:43:05 <Mitsos101> On a side note: Why isn't Set Applicative?
12:43:08 <dolio> Or you could imagine the syntax is saying, "forall a. (C :: a -> T)"
12:44:01 <nitrix> I see.
12:44:12 <dmwit> Mitsos101: There's a couple problems. But let's start with the easiest one to see: `(<*>) :: Set (a -> b) -> ...` is hard because then you need to be able to compare functions for equality (and ordering).
12:44:15 <nitrix> dolio: Could I write data forall a. T = C a ?
12:44:25 <nitrix> dmwit: Or is that semantically different?
12:44:48 <nitrix> dmwit: wrong highlight
12:45:22 <nitrix> @let data forall a. MyT = MyC a
12:45:22 <lambdabot>  Parse failed: Illegal data/newtype declaration
12:45:32 <nitrix> Well that answers it.
12:50:53 <wahed> I am trying to reimplement sequence for Maybe with a right fold. I can't figure out why the fold doesn't stop when it encounters a Nothing.
12:51:01 <Mitsos101> dmwit: Hmm, yes, you're right
12:51:06 <wahed> foldr fn Nothing
12:51:06 <wahed>   where
12:51:06 <wahed>     fn Nothing _ = Nothing
12:51:06 <wahed>     fn (Just x) Nothing = Just [x]
12:51:09 <wahed>     fn (Just x) (Just acc) = Just (x : acc)
12:51:54 <dolio> nitrix: I mean, you can't write it because it's not defined to be correct syntax. But it kind of makes sense.
12:52:28 <fishythefish> wahed: because if you encounter a Nothing, the accumulator is updated to Nothing per the first clause of fn, but then if you encounter Just x, the second clause makes it Just [x]
12:52:52 <fishythefish> so you'll end up with all the values encountered after the last Nothing
12:53:13 <nitrix> dolio: I see. So the case is that, within the constructor, it's `exists`, outside of it, it may be `forall`, but they are essentially equivalent since the only thing affected is that constructor.
12:53:40 <dolio> Yeah. And GHC didn't have to add a new keyword this way.
12:53:40 <nitrix> @let data Testing = forall a. Foo a | Bar a
12:53:41 <lambdabot>  .L.hs:179:20: error: Not in scope: type variable ‘a’
12:53:41 <lambdabot>      |
12:53:41 <lambdabot>  179 |              | Bar a
12:53:50 <nitrix> @let data Testing = forall a. (Foo a | Bar a)
12:53:50 <lambdabot>  Parse failed: Parse error: |
12:53:54 <nitrix> Clever :)
12:54:04 <dolio> Also, exists is actually kind of a bad choice.
12:54:34 <dolio> Because constructors can have multiple fields, but there's no place to put the exists where it'd make sense to scope over all of them.
12:54:41 <dmwit> :t foldr
12:54:42 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:55:02 <dolio> That is, it's a bad choice if you're going to be attaching existential quantification to constructors.
12:55:19 <nitrix> Gotcha.
12:55:36 <nitrix> Now I really wonder how C++'s templates approach the issue.
12:55:39 <dolio> Which is itself kind of a good choice, because it's easy to handle.
12:55:57 <dmwit> > sequence [] :: Maybe [Int] -- here's a hint, wahed
12:55:59 <lambdabot>  Just []
12:57:01 <dmwit> > let fn = {- doesn't matter, it's never called -} undefined in foldr fn Nothing [] :: Maybe [Int]
12:57:03 <lambdabot>  Nothing
12:58:10 <MarcelineVQ> @let data Testing where Foo :: a -> Testing; Bar :: a -> Testing -- we don't need no stinkin' foralls
12:58:11 <lambdabot>  Defined.
12:58:26 <nitrix> GADTs :3
12:58:32 --- mode: glguy set +v dawg
12:59:43 <dawg> hi there :)
13:00:45 <wahed> fishythefish: I don't use the accumulator when I encounter a Nothing. Shouldn't the fold stop?
13:01:10 <fishythefish> wahed: no, the result of fn is just the accumulator value for the next "step"
13:01:20 <fishythefish> whether you've used the existing value is irrelevant
13:01:45 <dawg> greetings, shouldn't Applicative have liftA2 under it's methods? http://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#t:Applicative
13:02:08 <fishythefish> it does?
13:02:25 <fishythefish> http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Applicative.html#v:liftA2
13:03:25 <dawg> fishythefish is there a reason that liftA2 isn't there on the link I sent (prelude)
13:03:49 <ab9rf> dawg: it is?
13:03:54 <dawg> is it because it's not imported by default?
13:04:10 <geekosaur> Prelude doesn't export everything, yes.
13:04:10 <ChaiTRex> dawg: Yes. The Prelude is what's there by default.
13:04:40 <dawg> ok thanks a lot and sorry for the dumb question :)
13:04:49 <fishythefish> wahed: depending on how you look at it, foldr never stops early - the closest thing to stopping early is ignoring all the values from the foldable after a certain point
13:09:02 <wahed> fishythefish: From the "Haskell Book - Christopher Allen": "With foldr, the rest of our fold is an argument to the function we're folding with. ... If f (folding function) doesn't evaulate its second argument (rest of the fold), no more of the spine will be evaluated. ... foldr can avoid evaluating not just some or all of the values in the list, but in the spine as well"
13:09:38 <wahed> Seems like I have misinterpreted that
13:10:31 <ab9rf> fishythefish: foldr doesn't stop?
13:10:34 <ab9rf> > foldr mplus Nothing (Just 1:(repeat Nothing)) 
13:10:36 <lambdabot>  Just 1
13:10:51 <ab9rf> if it "didn't stop", that wouldn't terminate
13:10:53 <fishythefish> ab9rf: yeah, that's why i hedged with "depending on how you look at it"
13:11:27 <ab9rf> > foldr (*) 0 [1,0..]
13:11:35 <lambdabot>  mueval-core: Time limit exceeded
13:11:35 <lambdabot>  mueval: ExitFailure 1
13:11:44 <ab9rf> now figure out why :)
13:12:02 <nitrix> The latter is an infinite list.
13:12:17 <ab9rf> so is the former
13:12:20 <fishythefish> so is `repeat Nothing`, the key is that (*) is strict in both arguments
13:12:24 <ab9rf> that's why
13:12:35 <ab9rf> mplus for Maybe a is not
13:12:38 <nitrix> The former is a list whose tail is a thunk that wont be evaluated?
13:12:45 <nitrix> So you wont get the repeated list?
13:13:32 <fishythefish> and why won't it be evaluated?
13:14:31 <monochrom> > foldr mplus undefined (Just 1 : undefined)
13:14:33 <lambdabot>  Just 1
13:14:56 <monochrom> Maybe's mplus is conditionally lazy on its 2nd operand.
13:15:01 <fishythefish> right
13:15:06 <nitrix> ;o
13:15:18 <monochrom> mplus (Just x) foo = w00t I've got the Just I need, who cares about foo now
13:15:25 <fishythefish> in contrast to (*), which is what ab9rf was demonstrating
13:16:00 <monochrom> You can, in fact, design your own type and your own Num instance such that * has some laziness, too.
13:16:25 <wahed> fishythefish: Then why didn't my function 'stop' the fold?
13:16:47 <monochrom> It's just that the standard number types choose to have eager * + etc because that maps better to hardware or people's anticipation. or just second-guessing people's anticipation.
13:16:48 <fishythefish> wahed: your function always evaluates the next element of the foldable
13:17:06 <ab9rf> > foldr mplus (Just 1) (repeat Nothing) --even more fn
13:17:13 <lambdabot>  mueval-core: Time limit exceeded
13:18:12 <ab9rf> even though you can reason that this should be Just 1, it's bottom
13:18:31 <fishythefish> then you're using flawed reasoning :P
13:19:38 <ab9rf> well, yeah
13:19:46 <wahed> it bottoms out because the zero value along with the last value in the list is passed to mplus in the innermost expression?
13:20:01 <wahed> and here we have no last value
13:20:16 <ab9rf> it's a right fold
13:20:29 <ab9rf> it never gets to the base case
13:20:51 <wahed> yes. that's what I tried to write.
13:21:19 <ab9rf> > foldl mplus (Just 1) (repeat Nothing) 
13:21:27 <lambdabot>  mueval: ExitFailure 1
13:21:34 <sedeki> monad question: the sequential nature of monadic operations follow from what monad law?
13:22:10 <wahed> ab9rf: Bottoms out because foldl doesn't let the folding function choose if the rest of the fold is evaluated?
13:22:25 <monochrom> No, it follows from the type "m a -> (a -> m b) -> m b" which implies some kind of data dependency.
13:22:45 <ab9rf> wahed: foldl always diverges on infinite lists
13:22:58 <monochrom> In fact, even that data dependency is pretty weak in sequentializing.  Consider the Tardis monad.
13:23:19 <sedeki> monochrom let me see...
13:23:59 <ab9rf> i was thinking it was the other way around: the monad laws were chosen because they are implied by the fact that some monads act to sequence operations
13:24:11 <sedeki> monochrom well... type of _what_? isn't that one of the monad laws?
13:24:23 <monochrom> Type of >>=
13:24:29 <sedeki> bind
13:24:41 <sedeki> never mind
13:24:44 <monochrom> And consider Control.Monad.State.Lazy, e.g., https://lpaste.net/41790
13:25:34 <dolio> Monads don't actually sequence anything.
13:25:43 <ab9rf> dolio: some do, some don't
13:25:53 <monochrom> That's what dolio means.
13:26:07 <dolio> Well, that's true. In general they don't, and it's not clear what that would even mean, really.
13:26:35 <monochrom> English lacks a short way to say "not forall" i.e. "exists not".
13:27:05 <dolio> Like, the operation of completing a metric space is a monad.
13:28:20 <monochrom> OMG it's true!
13:28:25 <sedeki> dolio just to clarify, what do you mean by completing a metric space? i have studied some math to understand the terms in play, but haven't thought about the "operation"
13:29:13 <ph88^> what's the goto sqlite driver for haskell ?
13:30:26 <dolio> Well, my math in the area is pretty weak. But there are things called 'complete metric spaces' and not all metric spaces are complete. And there is an operation that takes a metric space to the 'smallest' (probably, in some sense) extension of it that is complete.
13:30:31 <dolio> And that is a monad.
13:30:43 <dolio> The concrete example is that the completion of the rationals is the reals.
13:30:57 <ab9rf> i love that Tardis monad
13:31:16 <sedeki> yes ok, so the operation that injects Cauchy sequences into that space
13:31:36 <sedeki> is that what you mean?
13:31:57 <monochrom> Define the functor that maps a metric space to its completion. This functor is a monadic functor.
13:32:18 <ab9rf> that seems to make sense to me
13:32:38 <dolio> I think the operation is idempotent, too, so doing it to an already complete space does nothing, effectively.
13:32:39 <chessandgo> are case patterns the actual pattern of the data, or as long as they evaluate as equal
13:32:44 <monochrom> This one you're better off thinking of fmap, pure, join.  Don't worry about >>= first.
13:32:47 <dolio> You get something equivalent to the original space.
13:32:54 <chessandgo> im pattering matching on a list, and i'd like to replace [] with empty, but its a compile error
13:32:57 <chessandgo> even tho
13:33:02 <chessandgo> > [] == empty
13:33:04 <lambdabot>  True
13:33:35 <ab9rf> chessandgo: you can't pattern  match on empty
13:33:41 <monochrom> Yeah completing an already complete space gives you the same or an isomorphic thing. (Depending on how you set up the details.)
13:34:09 <monochrom> Anyway that gets you an easy answer for what join :: C (C s) -> C s does.
13:34:11 <chessandgo> ah, that makes sense
13:34:18 <sedeki> monochrom so the functor you mention takes a point in Q and does what?
13:34:23 <ab9rf> you can only match on constructors
13:34:29 <monochrom> No. Takes a whole space.
13:34:36 <monochrom> It's a functor.
13:34:42 <sedeki> ah ok
13:34:43 <chessandgo> could I use view patterns if I wanted this functionality
13:34:45 <dolio> Also this is the case where mathematicians can use this to characterise the complete spaces. Complete metric spaces are the 'algebras' of the completion monad.
13:34:54 <sedeki> monochrom yeah it must be the whole space
13:35:06 <chessandgo> its not that important, ive just been cleaning up my code from using return Nothing to empty
13:35:09 <sedeki> monochrom then what? sorry, i'm just trying to follow this example
13:35:45 <ph88^> how can a package get removed from hackage and stackage ?
13:35:48 <dolio> Well, the functor mapping would be like `(Q -> Q) -> R -> R`, so it takes maps on Q to maps on R.
13:35:55 <wahed> ab9rf: Feel stupid for not getting this, but could you explain how my folding function is NOT lazy on the second arguments if it encounteres a Nothing value?
13:36:14 <dolio> The unit of the monad `Q -> R` shows how to include the rationals in the reals.
13:36:35 <fishythefish> wahed: it is, but you need it to be lazy in the first argument
13:36:35 <wahed> flipMaybe = foldr fn Nothing
13:36:35 <wahed>   where
13:36:36 <wahed>     fn Nothing _ = Nothing
13:36:36 <wahed>     fn (Just x) Nothing = Just [x]
13:36:36 <wahed>     fn (Just x) (Just acc) = Just (x : acc)
13:36:55 <dolio> And a special case of bind is `R -> (Q -> R) -> R`.
13:37:10 <dolio> Which, maybe you can make some sense of that. :)
13:37:41 <sedeki> how can you take the whole reals as an argument to a function which returns the reals?
13:37:44 <dolio> It's doing something to define a new real with a continuous mapping and a sequence from some real, probably.
13:38:17 <ab9rf> sedeki: this is category theory, not programming :)
13:38:23 <fishythefish> f x = x -- how can you take x to be an argument to a function which returns x?
13:38:29 <monochrom> Oh God this is Real Analysis Done Right.
13:39:08 <dolio> Oh, rocconnor did a paper on this, if I recall correctly...
13:39:10 <ab9rf> wahed: your function is insufficiently lazy in its first argument
13:39:17 <monochrom> Yeah, you agree that a functor maps objects to objects, morphisms to morphisms?
13:39:37 <sedeki> monochrom yes, one for one
13:39:52 <fishythefish> not necessarily one to one
13:40:03 <ab9rf> for a foldr to terminate on an infinite list, the folded function has to be lazier in its left argument than it is in its right.
13:40:07 <dolio> https://arxiv.org/ftp/cs/papers/0605/0605058.pdf
13:40:27 <monochrom> ab9rf: Wait, left? right?
13:40:56 <monochrom> Great, I'll put in on my exam >:)
13:41:33 <ab9rf> i may be on crack at the moment
13:42:01 <ab9rf> it's hot, i haven't slept well in three days, and i'm in pain
13:42:01 <dolio> sedeki: I'm not sure if this was clear, but the category is one where the objects are metric spaces.
13:42:07 <chessandgo> is there a simple way to use holes without using cases of functions, so that I could do something like
13:42:10 <chessandgo>  (Just 1) == (Just _)
13:42:44 <dolio> So, then, <> : MSpace -> MSpace is the monad, and R = <>Q.
13:42:48 <chessandgo> I have a two cases case statement that id like to turn into a guard and I cant figure out how to do it cleanly
13:42:52 <dolio> Is a particular example.
13:43:28 <ph88^> how can i search all the package that depend on a package ?
13:43:45 <ph88^> reverse dependencies
13:44:48 <wahed> > foldr const 0 [1,2,3,5, undefined]
13:44:50 <lambdabot>  1
13:45:13 <ab9rf> > foldr const undefined [1,2,3,4, undefined]
13:45:15 <lambdabot>  1
13:46:36 <ab9rf> i need a nap
13:46:39 <ab9rf> or a drink
13:47:15 <wahed> ab9rf: thanks for your help. I'll trouble you another day if my brain remains stupid.
13:47:28 <ab9rf> wahed: just keep in mind that i'm often wrong :)
13:48:44 <dolio> sedeki: Another way of ordering the particular bind is: `(Q -> R) -> (R -> R)`. So if you have a continuous map from Q to R, the monad says that it can be extended to a continuous map from R to R somehow.
13:48:53 <philippD> What's the easiest way of defining a `MonadState a MyMonad` instance for `newtype MyMonad x = MyMonad (State (a,String) x)` ?
13:49:23 <sedeki> dolio what property of the completion process do you rely on to call it monadic?
13:49:39 <ab9rf> sedeki: the fact that it complies with the monad laws?
13:49:43 <philippD> The MonadState instance is only exposing a part of the actual state
13:49:59 <Eduard_Munteanu> ph88^, see https://packdeps.haskellers.com/reverse
13:50:02 <dolio> eta : A -> <>A and mu : <><>A -> <>A which are associative and unital in the right way.
13:50:02 <sedeki> ah i see
13:50:37 <dolio> So, like, extending eta : Q -> R is the identity on R.
13:51:07 <Eduard_Munteanu> philippD, just use a deriving clause
13:52:09 <sedeki> dolio in general, are "operations" monads, or is it the types?
13:52:11 <Eduard_Munteanu> philippD, wait, do you want just that 'a', not the entire state?
13:52:17 <ab9rf> sedeki: both
13:52:39 <philippD> Eduard_Munteanu: Yeah that's the whole point of the newtype
13:52:56 <ab9rf> sedeki: there are two different monads over integers, for example
13:53:06 <dolio> Monad, not monoid.
13:53:29 <philippD> Eduard_Munteanu: I know how to write the correct `state` definition but I was thinking that it there might be an easier way. lens maybe?
13:53:33 <Eduard_Munteanu> philippD, you'll have to write your own instance then. Or you can split the state.
13:53:38 <sedeki> dolio yes monad?
13:53:49 <dolio> The mapping of types, or between categories is the monad.
13:53:51 <Eduard_Munteanu> Hm.
13:53:53 <dolio> So <> is the monad in this case.
13:54:03 <dolio> Or, (<>, eta, mu).
13:54:10 <dolio> The whole structure.
13:54:11 <sedeki> i see
13:54:31 <Eduard_Munteanu> philippD, I guess you could hide / not export the lens for the private parts.
13:55:46 * dstolfa is confused with dolio's wording on "mapping between categories is a monad" and he knows category theory
13:55:48 <dolio> Anyhow, the reason that a bunch of monads in Haskell "sequence" things is that they are defining embedded languages of sequential operations.
13:55:51 <philippD> Eduard_Munteanu: `StateT a (State String)` would work but I would like to keep the Transformerchain as short as possible. How would you implement it using lenses?
13:56:26 <dstolfa> dolio: i think you want to say that a monad, which is an endofunctor, i.e. goes from C to itself (perhaps in this case the category of Hask to itself), but arises out of an adjunction that adequately models some effects
13:56:43 <dstolfa> the reason we use a monad is because we can talk about that adjunction without ever mentioning the other category
13:56:46 <dolio> dstolfa: Well, I mean, I think it's pretty common to say things like "the powerset monad."
13:56:47 <monochrom> A monad is a functor. So whenever you see "the foo monad" it does you a lot of good to first think "what is the foo functor?" and usually your lightbulb goes on just like that.
13:57:08 <dstolfa> dolio: yeah but it's not common to say it's a map
13:57:13 <dstolfa> at least i've never heard that
13:57:14 <Eduard_Munteanu> philippD, State Foo a, and export only some lenses for Foo without its constructor.
13:57:29 <tswett> Hey everyone.
13:57:30 <monochrom> And clearly a foo functor is a mapping from a category to a category such that etc etc.
13:57:30 <dstolfa> it's technically not wrong since it's an endofunctor, but it's a bit confusing nonetheless
13:57:35 <Eduard_Munteanu> tswett, hey
13:57:35 <dolio> Oh, yeah, my bad.
13:57:55 <dolio> It's a mapping from a category to itself.
13:57:56 <tswett> I made this lpaste post way back. It looks like I accidentally overwrote it with something else at some point. https://lpaste.net/349696
13:58:03 <tswett> There isn't a way to recover what I had there before, is there?
13:58:13 <ab9rf> this is starting to make sense
13:58:16 <dolio> Unless you do the weird 'non-endofunctor' version someone came up with.
13:58:35 <dstolfa> dolio: i mean, if you're to call it a monad, it has to be isomorphic to the endofunctor definition
13:58:48 <ab9rf> i don't see how you can have a monad that is not an endofuctor
13:58:52 <ab9rf> endofunctor
13:59:39 <dolio> It's a generalization of monads, technically, although all the examples I've seen could probably just be monads, if I recall.
14:00:17 <dstolfa> dolio: a generalisation of monads would probably have something to do with a cateogory of endofunctors that have more objects?
14:00:22 <dstolfa> category*
14:00:42 <monochrom> Given enough coffee or research grant, there is always someone who can concort a crazy generalization. :)
14:00:44 --- mode: glguy set +v Boarders
14:00:56 <Boarders>  I have a type class that defines some getter :: Getter s a
14:01:07 <monochrom> at which point, clearly math is invented not discovered. >:)
14:01:17 <dolio> No, the idea is that you have a monad 'relative' to another functor F : C -> D. And then eta : F A -> T A and extend : (F A -> T B) -> (T A -> T B).
14:01:18 <Cale> dolio: What generalisation are we talking about?
14:01:26 <Boarders> when I try to write an instance with: getter = to undefined
14:01:30 <ab9rf> i'm not seeing the generalization
14:01:38 <Boarders> I still get a tye error, what is going on with that?
14:01:53 <monochrom> Oh that actually looks neat, not contorted.
14:01:56 <Cale> ah, like that
14:02:04 <ab9rf> oh, wait, i see maybe 
14:02:06 <dolio> If F is the identity then T is the normal definition of a monad.
14:02:11 <monochrom> hehe
14:02:32 <dolio> You can have 'relative' adjunctions, too.
14:02:33 <Eduard_Munteanu> I wonder if that means anything in terms of adjunctions.
14:02:38 <ab9rf> huh
14:02:38 <monochrom> OK this one is discovered not invented. >:)
14:02:38 <Eduard_Munteanu> Oh.
14:02:41 <dstolfa> http://www.cs.nott.ac.uk/~psztxa/publ/Relative_Monads.pdf
14:02:44 <dstolfa> this is what you want ^
14:02:57 <ab9rf> ok, that's not completely insane but i don't see how it's useful, either
14:03:12 <dolio> The examples presented tend to be kind of contrived.
14:03:33 <dstolfa> ab9rf: think of a monad arising on some type rather than any type
14:03:47 <monochrom> That paper may contain a good use case.
14:04:27 <monochrom> But I'm also OK with "but just one use case is not enough".
14:04:39 <dstolfa> monochrom: when has any mathematician cared about use-cases?
14:04:41 <monochrom> But at least it is not entirely crazy.
14:04:48 <ab9rf> dstolfa: haha
14:04:49 <dstolfa> it's mostly like: this is cool
14:04:57 <dstolfa> and then 30 years later people use it for something
14:04:58 <dolio> Like, you have C = Nat, and F = Fin. But an actual mathematician would just talk about finite sets and it wouldn't be necessary.
14:04:59 <ab9rf> someone will find a use case eventually
14:05:22 <monochrom> Actually they have to. You heard of that joke about a PhD thesis on a vacuous thing?
14:05:28 <ab9rf> but yeah, it makese as much sense to me as monads do
14:05:35 <ab9rf> which is not very much, but i'm exceedingly stupid
14:05:53 <dstolfa> monochrom: they "have" to. the reality is that they solve something and then come up with weird use-cases where it "could" help without actually thinking about it too much
14:07:13 <Boarders> why does the type Rep come up when I try to write a Getter?
14:09:29 <ab9rf> ok, i'm going to forget that i read that paper. nothing in it seemed insane, but i don't think it will ever help me do anything :)
14:09:43 <Eduard_Munteanu> Boarders, an instance of what?
14:10:07 <Boarders> I have some class which defines a Getter s a
14:10:24 <Boarders> and when I try to write an instance using the lens function to I just get gibberish type error
14:10:28 <Boarders> it is driving me insnae
14:10:30 <Boarders> insane*
14:10:36 <Eduard_Munteanu> Boarders, what is the type error?
14:10:38 <ab9rf> although i now want to know more about left Kan extensions
14:11:18 <ab9rf> i need to get a good monograph on category theory and try to actually learn something about it in some sort of systematic way sometime when i've had more than four hours of sleep
14:12:02 <philippD> Is there an elegant implementation of a homogenous map? I mean a Map where the keys are parametrized by a type so you can store values of any type inside that map. A lookup would look something like `lookup :: Key a -> HMap -> Maybe a` and the only way of obtaining a key would be by inserting a value.
14:12:15 <Boarders> Eduard_Munteanu: https://lpaste.net/6770343603668516864
14:12:23 <ab9rf> today was the first day of school. for the first time in several months i got more than three or four hours of peace and quiet
14:12:45 <dstolfa> ab9rf: a good way to learn any maths is to do it
14:12:51 <dstolfa> maths is not a spectator's sport :)
14:13:11 <johnw> Is there any way in a servant handler to access the current request?
14:13:11 <ab9rf> dstolfa: i'm quite aware of that
14:13:36 <Cale> philippD: Look up dependent-map... one sec, I'll get you a link
14:13:54 <Cale> https://hackage.haskell.org/package/dependent-map-0.2.4.0/docs/Data-Dependent-Map.html
14:14:25 <Cale> philippD: This one has parameters explaining what the connection between the key and value types are though... there's also Vault which may be more what you're looking for
14:14:36 <Cale> https://hackage.haskell.org/package/vault-0.3.1.2/docs/Data-Vault-Lazy.html
14:14:50 <Cale> Vault needs you to create keys in IO though
14:15:13 <Cale> while DMap is keyed usually by some GADT
14:15:45 <Cale> and the type parameter of the GADT is given to another type function (perhaps Identity) to get the type of the values in the map
14:15:55 <Boarders> Eduard_Munteanu: any ideas?
14:16:25 <Cale> (also you mean heterogeneous I think)
14:16:33 <Eduard_Munteanu> Boarders, your type annotation might be wrong, does it work with a simple undefined without one?
14:17:10 <philippD> Cale: Yeah I meant heterogeneous. DMap looks promissing. Thanks
14:17:29 <Boarders> Eduard_Munteanu: no
14:17:54 <Eduard_Munteanu> Boarders, do you get a different error?
14:18:27 <Boarders> I get: https://lpaste.net/8126218861520355328
14:18:51 <Eduard_Munteanu> johnw, do you need some particular information from the request?
14:19:09 <dmj`> johnw: no there isn’t, but I believe you can write a custom combinator to do exactly that
14:19:12 <ab9rf> johnw: you can get various bits out of the request using various combinators
14:19:24 <ab9rf> or write your own combinator if you need something not provided by default, i suppose
14:19:31 <johnw> Eduard_Munteanu: just want to log it to the debug output
14:19:40 <dmj`> johnw: the machinery around custom combinators has become very opaque and is not documented anywhere
14:20:00 <johnw> any examples?
14:20:25 <Eduard_Munteanu> johnw, if you need to log every request, you can write a WAI middleware
14:22:23 <dmj`> johnw: let me try to write something small
14:22:54 <dmj`> johnw: it would come down to making your own instance HasServer api => HasServer (Debug :> api) instance
14:23:21 <dmj`> tpye ServerT (Debug :> api) m = Debug -> ServerT api m
14:24:11 <dmj`> then access withRequest inside the body of route Proxy context subserver =
14:24:16 <dmj`> johnw: let me try to demo in a nix-shell
14:24:17 <Eduard_Munteanu> Boarders, are you using ScopedTypeVariables correctly?
14:24:51 <Eduard_Munteanu> Those type variables might not match.
14:30:06 <ramzzi> hello
14:31:20 <madnight> the source code of this module looks a bit confusing for me http://hackage.haskell.org/package/anonymous-sums-0.6.0.0/docs/Sums.html could someone elaborate
14:32:18 <c_wraith> it's using template haskell to generate a bunch of boilerplate definitions
14:32:55 <ab9rf> hehe
14:33:36 <madnight> ah okay thought TH is always like [| stuff |]
14:33:51 <c_wraith> that's for generating TH values.
14:34:03 <c_wraith> $() is for splicing TH expressions into source
14:34:42 <ph88^> does anyone know how groundhog, opaleye, selda and beam compare?
14:34:59 <ab9rf> ph88^: depends on your comparison function
14:35:23 <ph88^> just the features that they have
14:35:24 <madnight> ah now it makes sense to me okay, guess i'll have a look at the internal module source then
14:35:26 <c_wraith> madnight: in some sense, they're inverses.  $([| foo |])  is the same as as just writing `foo' in code.
14:40:21 <Gurkenglas> <MarcelineVQ> what does the one you're imagining do? <- I'm not sure what sorts of IO canonicalizePath must do. What I'm hoping is that it can be done before knowing the argument
14:40:32 <Gurkenglas> What is it doing?
14:41:05 <c_wraith> following symlinks is a common thing
14:43:10 <ZeuPiark> bye
14:43:31 <ab9rf> how can you canonicalize something without knowing what it is?
14:44:07 <suzu> what is the advantage of using Debug.trace vs putStrLn wolf-fence printing
14:44:18 <suzu> trace also lets me know when things are being evaliuated?
14:44:19 <monochrom> canonicalizePath f = do { putStrLn "please just tell me the answer:"; getLine }
14:44:22 <suzu> evaluated *
14:44:25 <c_wraith> suzu: trace doesn't require IO
14:44:33 <suzu> i am in an environment where i have IO
14:44:44 <c_wraith> then you don't need trace.
14:44:46 <suzu> i am trying to track down a concurrency bug and all i can find so far is "this should be impossible"
14:44:50 <suzu> lol, ok
14:44:57 <c_wraith> It's specifically for when you aren't in IO
14:45:18 <suzu> i am in IO but i am wondering if laziness is some kind of culprit here
14:45:29 <suzu> and maybe trace can illuminate such a thing for me?
14:45:30 <marvin2> canonicalizePath transforms relative paths to full paths
14:46:01 <marvin2> among several other things, but that is one thing it does that needs IO
14:46:10 <c_wraith> suzu: well, yes.  It can reveal evaluation order/time when used with the non-IO parts.
14:47:00 <c_wraith> suzu: note that non-IO code can't cause a concurrency bug - but it can reveal it.
14:47:15 <suzu> this is mostly all IO code
14:47:20 <suzu> though i am doing some C-ffi things in here
14:47:28 <suzu> and am using the async library
14:47:37 <suzu> i have an action that, when done exactly once, works perfectly fine
14:47:46 <suzu> when done twice or more, it will hang
14:47:46 <c_wraith> ok, dumb question - are you sure that the C library is thread-safe?
14:47:49 <c_wraith> most of them aren't
14:48:06 <suzu> it is not. it must have all of it's calls constrained to a specific OS thread
14:48:17 <suzu> so i am using asyncBound
14:48:39 <c_wraith> that's a good start, but you also need to worry about re-entrancy
14:48:45 <suzu> uh oh shit
14:48:55 <suzu> what does that mean?
14:49:53 <suzu> to clarify a bit more, the structure of my code is something like { a <- async (some c shit); b <- (async some c shit); (waitBoth a b `catch` \e -> ...) }
14:50:01 <c_wraith> almost exactly what it sounds like.  Do critical sections ever get entered twice at once?  That can happen even with a single thread when you get recursion or callbacks involved
14:50:35 <suzu> a and b call c functions that can call out to haskell and they will manipulate MVars to keep some things between a and b in sync
14:50:58 <suzu> this works for exactly one iteration. on the second iteration, a won't happen and b will hang there forever waiting for it
14:52:01 <c_wraith> I think it's a high probability that the ffi code is going wrong in there one way or another.  Especially when callbacks are involved.
14:52:30 <suzu> sad
14:52:36 <suzu> what are some ways i can investigate this further?
14:52:43 <dmj`> johnw: https://gist.github.com/f97afee6b40130f7e84502bbe8311804
14:52:57 <suzu> the ghci debugger seems to just shit itself when i try to ctrl-c during that hang to see what the app is doing
14:53:07 <suzu> quits with a "too many hs_exit()s" error
14:53:11 <monochrom> Is it actually safe to run a and b concurrently? Especially the c shit in them.
14:53:23 <suzu> yes. if they are on different OS threads
14:53:29 <gobby> Trying to connect to a websockt (wss) and I keep on getting the following error: `*** Exception: HandshakeFailed (Error_Packet_Parsing "Failed reading: invalid header type: 72\nFrom:\theader\n\n")`
15:00:51 <suzu> c_wraith: ping
15:05:23 <ab9rf> i hate dealing with non-reentrant code
15:07:42 <suzu> i'm not understanding what reentrancy means here
15:07:49 <suzu> what would be an example?
15:17:08 <`Guest00000> is there a library for: serializing data structures into binary, but also propagating changes in the data structure to changes in the binary such that binary changes are minimal, for managing serializations stored in files or other storage (i imagine an implementation of this to be like: huge binary sections aren't just moved around, deletion of data structure nodes causes creating holes in the 
15:17:14 <`Guest00000> binary, changes in field cause tiny in-place binary changes, just linking to an already existing structure node causes just writing one pointer, and so on)
15:18:47 <lavalike> peculiar ask
15:19:43 <`Guest00000> well, it's a simple idea: to have data structures that you can change, which are linked to their serializations in files transparently
15:19:58 <`Guest00000> so that writes pushed to files are also minimal
15:20:43 <`Guest00000> given that there are a lot of brilliant haskell libs already, this one could also exist...
15:21:41 <`Guest00000> effectively, such a file must mirror data structure's representation in memory...
15:24:02 <`Guest00000> given that a Haskell implementation can already do this for memory, we could have an interface to allow this thing for any storage
15:24:28 <`Guest00000> tell me again that we should absolutely deny Haskell programs access to low-level representation of things
15:26:21 <nitrix> I think if your library had some form of effectful lenses, you could narrow down what part of your structure changed and given a quite sophisticated encoder, calculate the exact offsets of what needs to be change on disk.
15:26:50 <nitrix> Would definitely require a lot of effort, but it'd be cool :)
15:29:24 <MarcelineVQ> ph88: https://hackage.haskell.org/package/sqlite-simple
15:29:44 <rien_> `Guest00000: would that not result almost in giving Haskell "image-like" abilities as in "Lisp Image"-like? That would be cool indeed.
15:30:48 <`Guest00000> right
15:30:54 <`Guest00000> only for data
15:35:36 <droplet> How can I get stack ghci to use a project-specific ghci conf?
15:36:19 <droplet> putting it in ./.ghci doesn't seem to work, it just gets totally ignored
15:36:45 <lavalike> not sure there is any other way than explicitly passing it as an option
15:37:25 <droplet> Ah crap my apologies I'd named it wrong :(
15:38:52 <lavalike> ah so if  you have it in the current directory it reads it first?
15:39:36 <suzu> ok so i solved the problem but i have no fucking clue how
15:40:45 <suzu> ok yes i do! it appears i had one `asyncBound` lacking
15:40:56 <suzu> or i did that and forgot to build
15:40:58 <suzu> and didn
15:41:04 <suzu> n't* notice that it corrected the issue
15:44:04 <droplet> lavalike: yup, exactly
15:45:25 <lavalike> droplet: neat! cool to know
16:00:24 <Gurkenglas> Keep bumping my head against there being no <%%= :x
16:00:44 <Gurkenglas> Can we have a library that procedurally generates _all_ potential lens operators?
16:06:42 <hpc> like some kind of template
16:06:44 <hpc> for haskell
16:07:02 <hpc> nah, that would never work
16:10:39 <Gurkenglas> https://lpaste.net/3539345234234179584 can this be made to refer only once to slot?
16:11:23 <Gurkenglas> (...zoom, I suppose. Is there a painless way to get zoom instances for a lot of newtype wrappers?
16:12:02 <Gurkenglas> One of which include StateT so can't just use coerce :P
16:12:25 <Gurkenglas> *includes
16:12:25 <Gurkenglas> Hmm maybe monad-control helps
16:15:34 <Gurkenglas> (the last line from the paste turned out not to work if anyone's scratching their heads)
16:20:24 <Gurkenglas> The first works, the second doesn't. Why? https://lpaste.net/2667489726667161600
16:29:01 <pavonia> Gurkenglas: Do you have ScopedTypeVariables enabled?
16:30:08 <pavonia> otherwise the `a` from `Proxy :: Proxy a`is a different one than in the type signature
16:30:13 * hackage emd 0.1.3.0 - Empirical Mode Decomposition and Hilbert-Huang Transform  http://hackage.haskell.org/package/emd-0.1.3.0 (jle)
16:36:27 <dmwit> Even with ScopedTypeVariables on the `a`s are different, because there's no `forall`.
16:37:47 <dmwit> So... turn on ScopedTypeVariables and add `forall m a.` to the front of your `findData` signature and you'll be good to go probably. =)
16:38:10 <Gurkenglas> Ah, thanks.
16:38:22 <Gurkenglas> No need for m, even
16:38:32 <Gurkenglas> nevermind, need.
16:38:37 <dmwit> =)
16:38:53 <Gurkenglas> (The lack of compile errors displayed by the IDE was the IDE's fault)
16:39:31 <dmwit> Actually I find it mildly annoying that STV is all-or-nothing. It's never actually gotten in my way, but I feel like if you're going to add `forall` as a requirement, you may as well allow some variables to be bound and some not.
16:40:09 <geekosaur> it is? that was the point of the forall
16:40:19 <geekosaur> but people are lazy and forall all of them
16:56:10 <dmwit> geekosaur: No, if you leave some variables out of your forall, GHC gives you an error.
16:56:54 <dmwit> % :set -XScopedTypeVariables
16:56:55 <yahb> dmwit: 
16:57:05 <dmwit> % let x :: forall a. a -> b; x = undefined
16:57:05 <yahb> dmwit: ; <interactive>:25:25: error: Not in scope: type variable `b'
16:57:42 <dmwit> can't go halfsies
16:59:07 <dmwit> Maybe you thought I meant "allow variables in some signatures to be bound and variables in other signatures not to be bound". But what I actually meant was "allow some variables to be bound and others not to be bound *within a single signature*".
16:59:22 <dmwit> I admit I was not very clear about that.
17:04:12 <geekosaur> I revcall that working at one point, maybe some other extension required it to be tightened up. I would have expected unspecified ones to be caught by the default forall, but I could see that interfering with other extensions
17:04:33 <geekosaur> and in some sense technically wrong, I suppose, but older ghc wasn't always in the technically right department
17:14:22 <geekosaur> And I'm pretty sure the other behavior was intentional, to make it easier to deal with older code that might expect Report behavior for other type variables
17:40:05 <arahael> As promised last night, I took another go at my parsing problem with megaparsec, and couldn't figure it out.  I have made another smaller attempt, would appreciate any help!
17:40:11 <arahael> https://gist.github.com/arafangion/46e7236c8ec6d40e8fbdee9385f4b584
17:42:25 * arahael adds a few missing bits - imports, etc.
17:47:16 <arahael> And the obvious: putting the 'try' into it so that the relevant line becomes "fields <- sepBy1 (try identifier) semi", doesn't change anything.
17:55:22 <arahael> I'm sure it's something very simple...
18:00:05 <MarcelineVQ> what version of megaparsec do you have and what is the definition of Parser
18:01:37 <arahael> MarcelineVQ: What's the quickeset way to find out, using stack?  As for Parser, it's just 'type Parser = Parsec Void String'
18:01:47 <MarcelineVQ> if it's a project  stack list-dependencies
18:02:06 <arahael> Using megaparsec 6.5.0 then. :)
18:05:15 <MarcelineVQ> hmm odd, me too, can't get your code to typecheck as-is. is this all you have in your file?
18:05:59 <arahael> Hmm, let me ensure it compiles, then - it must be missing something.
18:06:05 <arahael> (I have other things in the file, let me remove those)
18:06:11 <MarcelineVQ> Well, I know it's not, but are you missing more than just   type Parser = Parsec Void String
18:09:42 <arahael> Try that latest version, I was indeed missing a few functions.
18:10:05 <MarcelineVQ> yeah I think you were missing your own symbol and lexeme definitions you've crafted from Text.Megaparsec.Char.Lexer's
18:12:51 <arahael> For what it's worth, I can trivially parse "public one; two: private one; two", with a slightly modified testP (one that sepBy's using ':'), but not "public one; two; private one; two;"
18:14:11 <arahael> Which I'm sure is a hint, but I can't figure that out.  It's as if sepBy *insists* on matching the parser if it sees the separator.
18:20:45 --- mode: glguy set +v himekami
18:21:14 <arahael> Hmm, I think I've found the answer:
18:21:17 <himekami> +v glguy
18:21:40 <arahael> https://stackoverflow.com/a/41835837  Coincidentially, it looks identical to what I was told last night.
18:23:43 <MarcelineVQ> is that the issue? hmm, my route was to change the approach and have a parser for reserved words.
18:24:11 <MarcelineVQ> https://lpaste.net/2900396010603806720
18:26:39 <arahael> Hmm, no, it didn't fix it. (That is, the SO link didn't fix it)
18:27:18 <arahael> Why do you need a parser for reserved words?
18:28:20 <MarcelineVQ> Dunno, I ​make a parser for anything I care about.
18:28:39 <MarcelineVQ> beats using fail
18:29:58 <MarcelineVQ> Not that there's something wrong with fail, I probably shouldn't have said that.
18:30:20 <arahael> Well, I have two questions, then - why does that work, and why is this a particular problem with nested sepBy1's?
18:34:02 <arahael> Also, it should probably be testP that has the sepEndBy1, and not the testVisibilityP?
18:35:19 <MarcelineVQ> Up to you just depends which level you want to care about trailing ;  at. I'm actually not entirely sure about the issue with the original so still looking at it
18:35:21 <slack1256> What is the closest I can get to row-types in haskell?
18:35:55 <dmj`> slack1256: probably vinyl
18:36:05 <dmj`> @package vinyl
18:36:06 <lambdabot> http://hackage.haskell.org/package/vinyl
18:37:55 <arahael> MarcelineVQ: Hmm, have I explained it well enough, though - you're just not sure about why megaparsec is struggling with it, as I am?
18:38:46 <MarcelineVQ> You have I'm just dumb, I could  see one way to solve the one part getting stuck but I'm not sure what is actually causing the problem overall
18:40:56 --- mode: glguy set +v dataN
18:40:58 <dataN> https://lpaste.net/3028193213467852800
18:41:00 <MarcelineVQ> the overall being why it's okay with the first public and not the next private, which doesn't seem to be related to nested sepBy1
18:41:20 <MarcelineVQ> since you can try testVisibilityP directly with the same issue
18:43:50 <arahael> MarcelineVQ: Yeah, I'm confused about it.
18:44:06 <dataN> the problem with associated types is that they cant be expressed using type synonyms
18:46:49 <MarcelineVQ> oh, of course hehe, it works because public is being parsed by anyIdentifier not identifier
18:47:05 <MarcelineVQ> so there's never a chance to fail on public
18:48:04 <arahael> MarcelineVQ: But the first word of "public one; two;" and "private one; two;" should never fail.
18:48:15 <MarcelineVQ> so is your goal    [Visibility "public" ["one","two"],  Visibility "private" ["one","two"]] ?
18:48:22 <arahael> Yes, that's my goal.
18:48:28 <MarcelineVQ> alrighty, let's see
18:50:59 <dataN> a constraint synonym cant be defined using the associated types of a class...
18:52:55 <dataN> e.g. compare the above paste to this; https://lpaste.net/8619814872751800320
18:52:58 <arahael> MarcelineVQ: Note, the real language is much more complex, this is just the most simplified subset of the problem I could come up with.
18:54:49 <dataN> by mentioning the associated types instead as parameters, type synonyms can then be given for the various different Zippers. 
19:03:56 <MarcelineVQ> arahael: I'm fairly baffled
19:03:58 <arahael> MarcelineVQ: I found a seriously simple solution.
19:04:30 <arahael> I don't understnad it, though.  "fields <- many identifier".
19:05:28 <MarcelineVQ> that's going to stop at the first ; isn't it?
19:09:16 <arahael> Hmm, yeah it doesn'tw ork.
19:11:42 <MarcelineVQ> got a weird solution
19:11:58 <arahael> Hmm?
19:12:06 <MarcelineVQ> https://lpaste.net/8811996783593914368
19:12:50 <arahael> How does that work?
19:15:21 <MarcelineVQ> I'm, not wholly sure
19:17:43 <arahael> It seems to discard the private.
19:18:01 <arahael> Oh, forgot your change to testP as well.
19:18:29 <MarcelineVQ> Perhaps, and then backtracks because of try in identifier, and now the next testVisibilityP is free to use anyIdentifier on the private
19:19:34 <MarcelineVQ> Still not sure why the many is neccesary for that to happen though
19:19:53 <arahael> Nor why it swallows the trailing semicolon.
19:40:34 <arahael> How do we get more help on this, seeing as we both seem to be somewhat stumped?
20:00:13 * hackage serverless-haskell 0.6.7 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.6.7 (AlexeyKotlyarov)
20:04:14 <MarcelineVQ> sebBy might just be the wrong idea to be using.
20:06:23 <MarcelineVQ> we don't really have a bunch of items seperated by ;   rather the goal is that there's two items here that must start with a visibility and are followed by at least one thing that ends with ;
20:07:07 <arahael> I think you may be right there.
20:08:07 <MarcelineVQ> to that end https://lpaste.net/3164875724414779392 may convery the meaning better
20:08:45 <arahael> Yeah, I just made a similar change.  It's simpler, and clearer.\
20:09:23 <arahael> MarcelineVQ: Thanks for your time on this!
20:09:35 <MarcelineVQ> np, I was making dinner for some of it :>
20:10:24 <arahael> Enjoy!
20:36:43 <glguy> Is there anything clever to do for assigning unique IDs that can be allocated and released out of order without just allocating increasing IDs assuming that 64-bits is enough?
20:37:45 <glguy> obvious solutions include keeping around a list of freed identifiers and then reallocating from that, always searching from 0 looking for unallocated ids
20:38:02 <glguy> I'm just trying to think through alternatives
20:43:34 <arahael> glguy: If you can expand that to 128 bits, you could use GUIDs.
20:43:46 <arahael> glguy: Which are mathematically constructed to be statistically unique.
20:44:04 <glguy> Oh yeah, just generate a number and check if it's already used, if so try again
20:44:33 <glguy> as long as I don't have more than half out I shouldn't have to retry that many times :)
20:45:25 <arahael> glguy: Well, make the first few bits depend on something like a thread identifier the next few to be the nanosecond, next few to be sequential enumeration, and hte last few to be fully random?
20:51:34 --- mode: glguy set +v mac10688
20:51:40 <mac10688> :t (&&&)
20:51:42 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
20:51:54 <mac10688> :t length &&& head
20:51:55 <lambdabot> [a] -> (Int, a)
20:52:29 <mac10688> :t length
20:52:31 <lambdabot> Foldable t => t a -> Int
20:52:32 <mac10688> :t head
20:52:34 <lambdabot> [a] -> a
20:53:07 <mac10688> [a] == t a?
20:53:26 <mac10688> I see
20:53:40 <mac10688> crisis averted. the world makes sense again
20:57:02 * arahael hands mac10688 a realWorld#
20:58:13 * hackage serverless-haskell 0.7.5 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.7.5 (AlexeyKotlyarov)
21:21:07 <MarcelineVQ> glguy: is the use for the numbers describable? what are the chances it's a fun and interesting application where you don't need to check if the number you generated is in use and defer that check until you need to care who you're talking about, lazy identifcation :O
21:22:09 <glguy> No the real application isn't fun. I just want to assign unique identifiers to active timers so that the timers can be cancelled
21:22:38 <glguy> Can't rely on laziness because I will give the IDs to the C world
21:23:03 <MarcelineVQ> those pencil pushers
21:25:29 <Eduard_Munteanu> glguy, monotonic timestamps might do
21:26:00 --- mode: glguy set +v leungbk
21:27:00 <Eduard_Munteanu> Although getting suitable timestamps is kinda expensive.
21:32:41 <glguy> leungbk: read your private messages
21:35:12 <leungbk> would anyone mind helping me troubleshoot haskell-ide-engine? it was working fine for me until i tried to set up a hoogle db this afternoon.
21:36:57 * glguy reads about how kernel process IDs are allocated
21:39:13 <ClaudiusMaximus> glguy: you could perhaps use malloc and free to (de)allocate IDs?
21:44:40 <ClaudiusMaximus> rough guess, 64bit should be good for 12 years assuming i allocate one every clock cycle on every core...
22:25:59 <cbarrett> greetings, it's quite late here
22:26:15 <cbarrett> sure has been a lot of spam on here lately...
22:28:35 <dminuoso> dstolfa: Okay so I tried to apply the Feynman algorithm to find something similar to `instance Monad (Const ...)`
22:29:13 <dminuoso> dstolfa: But I think Im willing to accept that (>>=) can't disregard what the kleisli arrow returns.
22:32:29 <renzhi> what's the difference between "fmap show Just 3" and "show `fmap` Just 3"? I thought the difference is just infix or not, but obviously, quite different.
22:32:55 <YellowOnion> anyone know how to get doctest compiling on nix and ghcjs?
22:33:25 <dminuoso> :t fmap
22:33:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:33:31 <YellowOnion> doctest seems to be a depedancy of a package I'm using, I don't need it myself.
22:33:51 <dminuoso> renzhi: It's associativity and precedence rules.
22:34:32 <dminuoso> renzhi: So the trick here, is that `Just` is a function.
22:34:40 <dminuoso> renzhi: And there exists an `instance Functor ((->) a)`
22:34:53 <dminuoso> Let me rewrite for clarity:
22:35:01 <dminuoso> (show <$> Just) 3
22:35:07 <dminuoso> This is the same as `fmap show Just 3`
22:35:46 <renzhi> I see, I see. Just got the precedence wrong :)
22:36:52 <cocreature> YellowOnion: I’m not sure you can get it to compile using ghcjs but what you can do is disable the test suite of the package that uses it
22:36:58 <dminuoso> renzhi: And in case you are not familiar with that, that particular instance is just `fmap = (.)` so the first one is equivalent to: (show . Just) 3
22:37:33 <renzhi> dminuoso: I know that one, thanks
22:37:37 <YellowOnion> cocreature, yeah I was thinking that, but I have no clue what package is pulling it in.
22:37:47 <YellowOnion> or how to disable it.
22:38:08 <cocreature> YellowOnion: you can use haskell.lib.dontCheck to disable it and you can use nix to show you the dependency graph
22:38:53 <YellowOnion> cocreature, I'm new to nix, so I'm not sure where to put that.
22:39:51 <cocreature> YellowOnion: https://github.com/Gabriel439/haskell-nix has some examples (it uses a slightly different approach but both should work)
22:41:15 <renzhi> dminuoso: what really got me is the "Just is a function" part
22:42:32 <YellowOnion> cocreature, thanks.
22:43:14 <dminuoso> renzhi: It may be really helpful to burn that into your mind. Such tricks are sometimes used in short patterns..
22:43:39 <dminuoso> > foldMap Product [1,2,3]
22:43:41 <lambdabot>  Product {getProduct = 6}
22:43:43 <dminuoso> :t foldMap
22:43:45 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
22:44:07 <dminuoso> So here pass `Product` as a function. :)
22:45:01 <dminuoso> renzhi: Also burn into your mind that `f a b c` always means (((f a) b) c)
22:45:22 <dminuoso> You might not want to use fire.
22:45:36 <cocreature> and burn in your mind that calculating the product using foldMap is a bad idea for t = [] :)
22:45:39 <ab9rf> a soldering iron should be sufficient
22:46:23 <renzhi> dminuoso: :D
22:47:02 <YellowOnion> cocreature, sometimes I wish nix's Syntax was less flexible, as a noob I'm finding it hard to infer how to apply it to my package configuration.
22:47:49 <cocreature> YellowOnion: yeah the learning curve for nix is quite harsh
22:48:07 <dminuoso> > getDual . foldMap (Dual . (-)) [1,2,3]
22:48:09 <lambdabot>  error:
22:48:10 <lambdabot>      • Couldn't match expected type ‘a -> Dual c’
22:48:10 <lambdabot>                    with actual type ‘Dual (a0 -> a0)’
22:48:40 <YellowOnion> cocreature, doesn't help when Gabs tutorial breaks the example I pull from miso setup guide lol
22:48:53 <cocreature> YellowOnion: how does it break?
22:49:18 <cocreature> YellowOnion: if you want to use miso, I have some example configs that I used for a workshop at https://github.com/cocreature/nix-miso-template
22:50:37 <YellowOnion> cocreature, on project0, Gab's one says to cabal2nix . > default.nix, but I get an error: cannot auto-call a function that has an argument without a default value ('mkDerivation')
22:50:52 <YellowOnion> when calling nix-build
22:51:40 <YellowOnion> on miso they use `cabal2nix . > app.nix`
22:52:43 <cocreature> YellowOnion: Gabriel also says that you should be using "nix-build release${n}.nix" instead of just "nix-build" (which will default to building default.nix)
22:53:01 <cocreature> either way you probably want "cabal2nix --compiler ghcjs . > …"
22:55:13 * hackage bhoogle 0.1.3.5 - Simple terminal GUI for local hoogle.  http://hackage.haskell.org/package/bhoogle-0.1.3.5 (andrevdm)
22:57:31 <YellowOnion> cocreature, that's just an example of the flexibilty, when you just switch the role of default.nix and app.nix
22:57:36 <ZeuPiark> hello
22:58:41 <maerwald> isn't there a nix channel?
23:00:03 <YellowOnion> maerwald, no one replied there when I asked for help, channel is pretty dead.
23:00:25 --- mode: glguy set +v doc_
23:03:48 <doc_> how to make custom data types as hashmap key i tried it thows error as `Can't make a derived instance of ‘Hashable `?
23:04:41 <dminuoso> doc_: You have to provide an instance Hashable for your key.
23:05:50 <doc_> dminuoso: how to do that?
23:06:54 <dminuoso> doc_: You can use the default generic implementation.
23:07:21 <dminuoso> doc_: Have your key type derive Generic (you'll need to enable DeriveGeneric and import GHC.Generics (Generic)), and then write `instance Hashable YourType`
23:07:35 <dminuoso> doc_: It's pretty much documented https://hackage.haskell.org/package/hashable-1.2.7.0/docs/Data-Hashable.html#g:4
23:08:37 <doc_> dminuoso: thanks for your help :)
23:28:43 * hackage sendgrid-v3 0.1.1.0 - Sendgrid v3 API library  http://hackage.haskell.org/package/sendgrid-v3-0.1.1.0 (marcelbuesing)
23:29:59 <doc_> even though I have defined instance of fromJSON for myDataType still it throws error No instance for (aeson-1.2.4.0:Data.Aeson.Types.FromJSON.FromJSONKey   myDataType )?
23:30:57 <cocreature> doc_: sounds like you might have written myDataType instead of MyDataType?
23:31:08 <cocreature> lower case type names are type variables
23:32:02 <geekosaur> that, fully qualified, can also mean you're using it compiled against one version of aeson but linked with something that was compiled with a different version
23:33:40 <doc_> cocreature: it is capital only like MyDataType 
23:34:13 <cocreature> doc_: even in the error message? it looks like you have just copied that so I would be surprised by a typo in there
23:35:20 <doc_> cocreature: yes I just replaced the data type name while copying  
23:37:49 <cocreature> doc_: then you’ll have to provide a bit more information, e.g., some code snippet, the full error message, …
23:38:03 <cocreature> and make sure you aren’t mixing up different versions of aeson as geekosaur suggested
23:38:50 <doc_> cocreature: • No instance for (aeson-1.2.4.0:Data.Aeson.Types.FromJSON.FromJSONKey                          MyDataType)         arising from a use of ‘decodeFileEither’     • In a stmt of a 'do' block:         mConfig <- decodeFileEither filePath ::                      IO (Either ParseException Config)       In the expression:         do mConfig <- decodeFileEither filePath ::                         IO (Either ParseException
23:39:47 <cocreature> please use some pastebin site for multiline error messages and code snippets
23:40:56 <doc_> cocreature: https://pastebin.com/NwqmBnN8  here the full error message  is
23:41:59 <mauke> amendment: some pastebin site that is not pastebin.com
23:42:20 <cocreature> doc_: how are you compiling your project?
23:42:33 <doc_> cocreature: stack build
23:43:11 <cocreature> doc_: is Config a type synonym for something involving MyDataType? otherwise this error message doesn’t make much sense since you need a FromJSON instance for Config and not MyDataType
23:45:07 <doc_> cocreature:  config is type synonom for something like type Config = HM.HashMap MDT1  (HM.HashMap MyDataType MDT3)
23:45:42 <doc_> cocreature:  MDT1 and MDT3 are my different data types
23:47:00 <cocreature> doc_: can you show us the FromJSONKey instance for MyDataType?
23:47:24 <doc_> cocreature:  instance FromJSON MyDataType
23:47:47 <cocreature> doc_: that’s the instance for FromJSON, the error message is asking for an instance for FromJSONKey
23:48:21 <doc_> cocreature: ok then how to write for FromJSONKey?
23:49:25 <cocreature> depends on how MyDataType is defined. if it is just a newtype wrapper for Text, then you can use GND to derive it
23:50:13 <doc_> cocreature: data MyDataType = a | b |  c | d deriving (Show, Eq, Generic)  instance Hashable MyDataType
23:51:50 <cocreature> doc_: take a look at the existing instances to see some examples, e.g., here’s the one for Bool https://hackage.haskell.org/package/aeson-1.4.0.0/docs/src/Data.Aeson.Types.FromJSON.html#line-1207
23:56:25 --- mode: glguy set +v dataN
23:56:28 <dataN> most Zippers are covered by either Stack or Linear; https://lpaste.net/235345159640842240
