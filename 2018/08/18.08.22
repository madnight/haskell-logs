00:00:10 <Athas> I don't think that will be type-correct.
00:00:35 <cocreature> customRoute allows you to produce an arbitrary route based on the input filepath
00:00:40 <cocreature> so you can strip some folder
00:00:54 <Athas> customRoute $ joinPath . drop 1 . splitPath . toFilePath
00:00:57 <Athas> That should do it.
00:01:16 <gentauro> Athas: https://jaspervdj.be/hakyll/reference/Hakyll-Core-Routes.html#v:gsubRoute
00:01:20 <Athas> You'll need to combine it with other routes if you want to convert Markdown to HTML and such.
00:01:22 <gentauro> that looks like just what I need
00:01:30 <cocreature> there is also gsubRoute
00:02:04 <gentauro> cocreature: Athas already mentioned it and I think that's will solve the problem :)
00:02:23 <Athas> If you want more Hakyll tricks, the generator for my own website is written in Literate Haskell: http://sigkill.dk/programs/sigkill.html
00:02:25 <cocreature> oh right, missed that
00:02:29 <Athas> It does a few things that are not straightforward.
00:03:38 <nshepperd> Athas: i think the proper isomorphism with Array would be something like 'data ArrayF a = forall b e. (KnownNat b, KnownNat e) => ArrayF (BoundedInteger b e -> a)' with -XGADTs
00:04:09 <nshepperd> where BoundedInteger is probably some newtype wrapping of Integer that represents a bounded range of numbers
00:04:26 <gentauro> Athas: roger that
00:04:42 <gentauro> btw do you have any javascript? I'm aiming to remove all traces of it
00:04:52 <Athas> gentauro: no, none.  Why would I?
00:05:05 <gentauro> nice
00:05:20 <Athas> nshepperd: the next challenge is adding concatenation while preserving O(1) indexing in the resulting array!
00:05:24 <gentauro> Athas: so the hover menu thing is just CSS right?
00:05:33 <Athas> But this is probably not possible with a functional representation.
00:05:37 <Athas> gentauro: yes.
00:05:50 <Athas> I am terrible at CSS and HTML, so I guarantee that all the tricks are simple.
00:06:11 <gentauro> Athas: I have O(1) ish inserts while O(log_32 n) lookups :)
00:06:27 <gentauro> in my Haskell array ;)
00:06:32 <Athas> gentauro: I'm betting your representation is not a function.
00:06:47 <gentauro> Athas: that's just what I'm looking for
00:06:55 <gentauro> (easy CSS / HTML)
00:07:14 <Athas> By the way, you might want to read this paper on parallel functional arrays: https://www.cs.cmu.edu/~rwh/papers/farray/popl17.pdf
00:07:31 <Athas> But I'm not sure it's a good fit for you, since it uses effects internally while presenting a functional interface.
00:07:31 <nshepperd> Athas: no problem: the new function is \i -> if i < length array1 then array1 i else array2 (i - length array1)
00:07:58 <Athas> nshepperd: if you concatenate 'n' arrays, then indexing into the resulting array is then O(n).
00:08:57 <nshepperd> eh, i suppose so
00:09:11 <nshepperd> but it's O(1) if you concatenate two arrays :p
00:09:13 <gentauro> Athas: unless you use RRB-trees
00:09:19 <gentauro> https://infoscience.epfl.ch/record/169879/files/RMTrees.pdf
00:09:32 <Athas> gentauro: sure, but this discussion is about the drawbacks of a functional representation.
00:10:02 <gentauro> yeah, I couldn't get myself to do append/concatenation as it sparses the indexes
00:10:19 <gentauro> and my FixedVector32 wouldn't be all filed before using a new
00:10:28 <gentauro> that was something I couldn't comprosmise on
00:10:56 <gentauro> but I would love to hear other ways to achieve append/concatenation in a decent time complexity without "breaking" the design of my array
00:11:09 <Athas> Use a tree, not an array.
00:11:49 <gentauro> Athas: my FixedVector are represented as: data FixedVector2 a = FV2 a a
00:11:58 <gentauro> (it's a product type)
00:12:04 <gentauro> but with 32 elements
00:12:25 <nshepperd> maybe the actual answer is to secretly use an actual array internally, and copy everything whenever you append, just like normal arrays do
00:12:44 <Athas> Yes, that is likely ideal.
00:13:14 <Athas> You can have a small work-queue for the case where several concatenations occur after each other, and manifest them all at once when the first non-concat operation occurs.
00:16:29 --- mode: glguy set +v old_spice
00:16:39 <old_spice> I try some [1,2]
00:16:45 <old_spice> some (Just 1)
00:16:53 <old_spice> some [Just 1, Nothing]
00:17:09 <old_spice> all of them hang up and need to be interripted
00:17:15 <old_spice> interrupted
00:17:38 <old_spice> ghc 8.4.2
00:18:43 <gentauro> Athas: `foo = gsubRoute "web/" (const "") `composeRoutes` idRoute` works like a charm. Thx !!!
00:18:58 <Ariakenom> old_spice: It should. Here are definitions https://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Applicative.html#t:Alternative
00:19:02 <Athas> This is now the #hakyll refugee channel.
00:19:46 <old_spice> Ariakenom: it should hang?
00:20:41 <cocreature> old_spice: what do you expect it to do instead?
00:20:42 <Ariakenom> old_spice: some and many really only make sense when the action "v" can give different results when run twice
00:20:44 <old_spice> what are examples of proper usage?
00:21:10 <cocreature> parsers are a common example where "some" and "many" make sense
00:21:11 <Ariakenom> old_spice: like a takeChar in a parser, or getLine in IO
00:21:28 <Ariakenom> > some Nothing
00:21:30 <lambdabot>  Nothing
00:21:33 <old_spice> so IO stuff?
00:21:39 <gentauro> Athas: Yeah, no more "penis birds" for me :'(
00:21:41 <Ariakenom> > many Nothing
00:21:43 <lambdabot>  Just []
00:21:45 <cocreature> parsers aren’t IO stuff :)
00:22:21 <Ariakenom> Needs statey stuff though I think
00:22:38 <old_spice> some Nothing > Nothing
00:22:46 <old_spice> some (Just 1) > hangs
00:23:16 <cocreature> some (Just 1) = liftA2 (:) (Just 1) (many (some (Just 1))
00:23:25 <Ariakenom> old_spice: some and Nothing runs until the action fails, is "empty". Just 1 will never fail
00:23:27 <cocreature> to evaluate the liftA2 you have to inspect both arguments
00:23:36 <cocreature> eh that should be "many (Just 1)"
00:23:41 <Ariakenom> sorry correction. "some and many runs ..."
00:24:06 <cocreature> but if you try to evaluate "many (Just 1)" you end up with (some (Just 1) <|> pure [])
00:24:10 <cocreature> and at that point things recurse
00:24:18 <cocreature> so it never terminates
00:24:38 <jle`> old_spice: some only works with "stateful" actions really
00:24:48 <jle`> where sequencing the same action twice might produce different effects
00:25:02 <Ariakenom> > (empty :: Maybe (), empty :: [()])
00:25:05 <lambdabot>  (Nothing,[])
00:25:11 <jle`> so Alternatives like, IO, State, Parser
00:25:16 <old_spice> ok, got it. So can not be used as a pure fn?
00:25:27 <jle`> it's a pure function
00:25:36 <jle`> but the Alternative instance has to have a "stateful" sort of (>>)
00:25:52 <jle`> it depends on (*>) for the type
00:26:02 <jle`> basically if x *> x = x, then some/many don't really work
00:26:32 <dminuoso> Given `data User { name :: Text, age :: Int }` is there a way to write the following: `f User{..} = [f name ~= name]` such that the first `name` is `name :: User -> Text` and the second is `name :: Text` from RecordWildCards?
00:27:01 <dminuoso> Or do I have to do the long route and name the fields like `f User{user=userV} = [f name ~= nameV]`
00:27:17 <jle`> yeah RecordWildCards is kinda inflexible
00:27:23 <jle`> it's basically just literal sugar
00:27:27 <dminuoso> mmm
00:27:28 <old_spice> jle`: ta. I will experiment with a working example
00:27:33 <jle`> User{..} is sugar for User{name=name, age=age}
00:27:38 <lavalike> cocreature: what are some/many for?
00:27:59 <cocreature> dminuoso: how about "f u = [f (name u) ~= name]"?
00:28:06 <cocreature> althought that probably shouldn’t be "f" both times
00:28:25 <jle`> lavalike: some/many are very useful for 'stateful' Applicative instances like IO, State, Parser
00:28:27 <cocreature> lavalike: I already gave the example of parsers and jle` and Ariakenom gave some more details, so I’m not sure what you’re asking?
00:28:38 <jle`> i use it a lot with MaybeT
00:28:48 <dminuoso> cocreature: Oh yeah. That actually might be better than writing out User{user=userV, age=ageV, ..}
00:28:48 <Ariakenom> lavalike: many (getChar ' ') will read spaces until fail. assuming a getChar function
00:28:52 <dminuoso> I like it =)
00:29:02 * dminuoso has an opportunity to make his source file 20 lines shorter
00:29:06 <lavalike> cocreature: sorry I missed it, I went experimenting and I couldn't figure out how to get someting useful out of them
00:29:19 <Ariakenom> many getLine will read lines from stdin until exception, eg end of file exception
00:30:03 <lavalike> oh it's the same many as in Parsec
00:30:11 <jle`> the only time they work is if 'repeating' an action twice could potentially produce different effects
00:31:24 <lavalike> now I see, appreciate it
00:37:59 <Ariakenom> many (getTChan tchan) will read all the values currently in a channel I presume
00:39:28 <Ariakenom> and, probably more useful, some (getTChan tchan) will fail if there isn't at least one item in the channel
00:43:23 <old_spice> this is easier to understand:
00:43:28 <old_spice> foldr (<|>) Nothing [Nothing, Just 1]
00:44:09 <old_spice> it is probably for a different purpose
00:44:20 <Ariakenom> old_spice: very different
00:44:24 <Ariakenom> :t msum
00:44:25 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
00:44:25 <old_spice> :)
00:44:33 <Ariakenom> :t asum
00:44:34 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
00:44:42 <old_spice> ah yes: forgot about msum
00:44:46 <Ariakenom> > asum [Nothing, Just 1]
00:44:48 <lambdabot>  Just 1
00:44:54 <Ariakenom> :)
00:44:58 <old_spice> ta
00:56:22 <dminuoso> :t sequence
00:56:23 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
00:56:40 <dminuoso> :t foldMap
00:56:42 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
00:56:45 <dminuoso> :t asum
00:56:46 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
00:57:20 <dminuoso> :t uncurry $ liftA2 (,)
00:57:21 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
00:57:28 <dminuoso> This kind of looks like sequence
00:58:20 <cocreature> :t bisequence :: Applicative f => (f a, f b) -> f (a, b)
00:58:22 <lambdabot> error:
00:58:22 <lambdabot>     • Variable not in scope:
00:58:22 <lambdabot>         bisequence :: (f1 a1, f1 b1) -> f1 (a1, b1)
00:58:28 <cocreature> @let import Data.Bitraversable
00:58:29 <lambdabot>  Defined.
00:58:30 <cocreature> :t bisequence :: Applicative f => (f a, f b) -> f (a, b)
00:58:32 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
00:59:39 <lavalike> :t bisequence
00:59:40 <lambdabot> (Applicative f, Bitraversable t) => t (f a) (f b) -> f (t a b)
01:25:47 * hackage postgresql-query 3.5.0 - Sql interpolating quasiquote plus some kind of primitive ORMusing it  http://hackage.haskell.org/package/postgresql-query-3.5.0 (AlekseyUymanov)
01:30:37 <trcc> cocreature: does this seem like the right way for storing the function? (As we discussed earlier)
01:30:39 <trcc> https://gist.github.com/CThuleHansen/5d87de9b06721b2d7e2f5f5e887fed0e
01:32:25 <cocreature> trcc: looks reasonable, if you now want to handle multiple instances replace Maybe by []
01:32:30 <cocreature> I also wouldn’t use a type synonym here
01:32:59 <cocreature> especially not for StepSize but also not for DoStepFunction
01:35:22 <dminuoso> cocreature: Okay I give up once again. Not quite sure how I can crack this hard nut "Applicative" - maybe I need to take the Day approach to figure it out.
01:35:39 <dminuoso> Monad is *easy* compared to this.
01:35:50 <dminuoso> And yet it's the one that gets all the bad reputation. :(
01:36:07 <trcc> cocreature: I am aiming for one instance for version 1 :) Why not type synonym? Just best practices?
01:36:17 <Ariakenom> That's just because they haven't heard of Applicative yet. Mwuahaha
01:36:32 <trcc> and thanks
01:36:48 <dminuoso> trcc: type synonyms lull you into a sense of false security. They offer none of the benefits of the type system, and just increase confusion.
01:37:00 <cocreature> trcc: use newtypes or just use the actual types
01:37:14 <Taneb> dminuoso: Applicatives are just things you can do "liftA(n)" for any natural n, so functions like liftA3 :: (a -> b -> c) -> f a -> f b -> f c
01:37:32 <Ariakenom> dminuoso: Do you want exampleson uses of Applicative? optparse-applicative on hackage
01:37:34 <Taneb> (or even liftA0 :: c -> f c, this is generally called "pure")
01:37:45 <dminuoso> Taneb: That's a circular definition though, isn't it?
01:37:51 <Taneb> Is it?
01:38:03 <cocreature> trcc: type synonyms introduce the mental overhead of forcing you to look up the definition if you want to use it while not actually preventing you from using an API incorrectly
01:38:05 <Taneb> If you can write those functions, you can write an Applicative instance
01:38:13 <dminuoso> Taneb: Well Monad is an endofunctor f for which arrows of the shape `a -> f b` compose nicely.
01:38:26 <dminuoso> So Im hoping for something fundamental like this
01:38:37 <trcc> cocreature: what do you mean not actually prevent you from using the API incorrectly? I guess it still checks, that StepSize corresponds to a Double
01:38:49 <cocreature> dunno, “Functor extended to an arbitrary number of arguments” seems sufficiently fundamental to me
01:39:01 <trcc> dminuoso: they offer the same benefits of the type system as the regular type does right?
01:39:07 <cocreature> trcc: e.g. you can still mix up different Doubles and pass a Double that was intended for something else
01:39:15 <trcc> ah yes
01:39:22 <trcc> Makes sense. Thank you.
01:39:27 <dminuoso> trcc: Haskells type system will prevent you from stuffing a `Bool` into a place that says `Int`
01:39:39 <trcc> ye
01:39:49 <dminuoso> trcc: But Haskell cant prevent you from stuffing a `Text` into a `Token` when you have `type Token = Text`
01:40:07 <trcc> ah yes
01:40:08 <trcc> thanks
01:40:18 <dminuoso> Or a `Token` into a place that reads `Text`
01:40:25 <trcc> replacing with newtype
01:41:17 <cocreature> in this case I would probably use a newtype for StepSize and just remove the type synonym for DoStepFunction
01:41:31 <trcc> hehe just what I did :D
01:41:38 <trcc> I created a newtype for DoStepFunction and decided to remove it again
01:41:44 <dminuoso> cocreature: I suppose my issue with that definition is that I dont clearly understand what a "function with multiple argument" really fundamentally means
01:41:51 <dminuoso> I mean I have no intuition for it.
01:42:08 <trcc> dminuoso: brought up in functional programming?
01:43:25 <lortabac> dminuoso: maybe this alternate definition of Applicative is easier to reason about: http://blog.ezyang.com/2012/08/applicative-functors/
01:48:53 <dminuoso> lortabac: Mmm that looks interesting, that could be the definition Im looking for. Reading the original paper from McBride and Paterson now :)
01:50:13 <dminuoso> It feels just right.
01:51:05 <lortabac> dminuoso: look at the comment by Derek Elkins, he explains why Applicatives are lax monoidal functors
01:51:35 <dminuoso> lortabac: It's almost self explanatory :)
01:51:42 <lortabac> :)
01:53:35 <dminuoso> lortabac: I mean in my head I can cite that Applicative are strong lax monoidal functors, but until now it just hadn't clicked for.. dunno reasons.
01:55:45 <lortabac> dminuoso: it's a bit like join vs. >>= for monads, sometimes join is easier to reason about
01:56:08 <dminuoso> lortabac: I personally prefer to think in terms of (>=>) and (return)
01:56:21 <dminuoso> Suddenly the laws look clean
01:56:54 <Taneb> (I just noticed I called liftA2 "liftA3" earlier, my bad)
01:58:19 <dminuoso> Taneb: I like the thought of calling `pure` liftA0 though.
01:58:39 <dminuoso> :t pure
01:58:41 <lambdabot> Applicative f => a -> f a
01:58:42 <dminuoso> :t liftA2
01:58:43 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
01:58:46 <Taneb> :t liftA
01:58:47 <lambdabot> Applicative f => (a -> b) -> f a -> f b
01:59:46 <dminuoso> Taneb: Law-wise the Monoidal route seems to be *much* simpler though :P
02:00:10 <dminuoso> although.. perhaps I should rephrase the laws in terms of liftA*
02:00:22 <Taneb> It might be a fun and useful exercise!
02:03:33 <dminuoso> :t pure (.) <*> u <*> v <*>
02:03:35 <lambdabot> error:
02:03:35 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
02:03:59 --- mode: weber.freenode.net set +v dminuoso
02:03:59 --- mode: glguy set -v dminuoso
02:31:30 <trcc> I guess that a function that potentially can do anything must have a returntype of IO (something?) 
02:31:55 <merijn> trcc: Define "potentially can do anything"?
02:32:05 <liste> trcc: if you want to do IO actions, you need IO in the tye
02:32:07 <trcc> web requests, file operations, whatever
02:32:07 <liste> type*
02:32:12 <liste> yes
02:32:18 <liste> those are IO actions
02:32:38 <trcc> ok great
02:32:51 <Ariakenom> trcc: just fyi the word "function" has different meanings and in Haskell context "IO a" isn't a function
02:33:05 <trcc> Ariakenom: hehe ye, good point
02:33:12 <trcc> operation then? :)
02:33:25 <merijn> Also depending on what you're doing that doesn't mean you have to require IO
02:33:38 <Ariakenom> yes, action is common
02:34:02 <trcc> merijn: ye. I am aware. I'll upload my code on github sometime and ask for improvement suggestions. Hopefully someone will give me some ideas 
02:34:04 <trcc> :)
02:37:57 <kuribas> trcc: that's not right, there are values that can potentially do things IO cannot.
02:37:59 <dminuoso> merijn: Any interesting functors I could use with HKD by the way?
02:38:05 <kuribas> trcc: for example nondeterministic computation.
02:38:05 <dminuoso> I mean so far Identity and Const are what Im using
02:38:12 <merijn> dminuoso: eh...Maybe?
02:38:20 <merijn> dminuoso: "Either MyValidationError"?
02:38:27 <trcc> kuribas: I'll treat that if I ever encounter it. But thanks!
02:38:54 <dminuoso> merijn: mmm
02:38:57 <kuribas> trcc: it may be a monad that has IO in it though ...
02:39:13 <Ariakenom> trcc: You can't stick a "print" into an STM transaction for example
02:42:39 <cocreature> dminuoso: []/Vector can also be interesting to get a struct of arrays representation vs array of structs
02:44:01 <dminuoso> Mmm perhaps Im actually looking for Writer
02:46:29 <mniip> 1534930659 [12:37:39] <kuribas> trcc: for example nondeterministic computation.
02:46:35 <mniip> setjmp?
02:46:43 <mniip> heh
02:46:56 <Ariakenom> ffi setjmp will surely work perfectly
02:47:30 <kuribas> mniip: but "IO a" will return a single a
02:51:02 <mniip> you could have collect :: IO a -> IO a
02:51:15 <mpickering> Why is this implementation of the fib function which uses a vector for constant indexing so slow?  https://www.irccloud.com/pastebin/PCPHjsyT/
02:51:26 <mpickering> The version using a list is many times faster
02:52:37 <Ariakenom> mpickering: paste the version using a list?
02:53:35 <mpickering> https://www.irccloud.com/pastebin/C80pspNk/
02:53:37 <merijn> mpickering: The list can be GCed as it goes and might fuse away entirely
02:53:57 <merijn> mpickering: Whereas the Vector has to be generated in memory entirely
02:54:16 <cocreature> is GHC really smart enough to fuse away a list if you use !!?
02:54:21 <cocreature> I would be surprised by that
02:54:22 <merijn> oh, wait, no that list implementation is stupid >.>
02:54:24 <Ariakenom> mpickering: also benchmark code. I g2g though
02:54:24 <mpickering> I don't think so
02:54:32 <merijn> cocreature: I was assuming a saner list based fib :)
02:54:38 <Taneb> mpickering: how are you measuring the time?
02:55:17 <cocreature> the list version memoizes across executions while the vector version does not
02:55:28 <cocreature> so if you benchmark repeated calls, the list version will win
02:55:35 <Ariakenom> indeed
02:55:45 <cocreature> (which e.g. criterion will do)
02:55:55 <mpickering> ah hmm
02:56:09 <mpickering> Can I stop criterion doing that?
02:56:17 * hackage hriemann 0.3.3.0 - A Riemann Client for Haskell  http://hackage.haskell.org/package/hriemann-0.3.3.0 (shmish111)
02:56:33 <mpickering> https://github.com/mpickering/probable-tribble/blob/master/Bench.hs
02:56:45 <Ariakenom> fib k = fibtable !! k where {fibtable = ...} mpickering 
02:56:56 <Ariakenom> eh maybe, igonre me
02:58:54 <Taneb> You could make the list code a closer equivalent of the vector code by passing in k as a parameter and only computing up to theere
02:59:16 <mpickering> yes good idea
03:02:57 <trcc> How does one do composition within the monad? I have f :: a -> IO b and g :: b -> IO c. I am currently doing: f x >>= g. If it was not IO, then I would do (f . g) x. 
03:03:14 <mpickering> There is the >=> operator
03:03:15 <merijn> :t (>=>)
03:03:16 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:03:21 <merijn> trcc: Fish operator! :)
03:03:28 <trcc> ahh yes, the fish one! Thanks :D
03:03:35 <trcc> I could have use hoogle for that!
03:03:41 <trcc> gotta make that a habbit
03:05:54 <mniip> kuribas, figured out a way to make it work
03:05:57 <mniip> just you wait :P
03:06:13 <trcc> hmm I get variable not in scope >=>
03:06:24 <mniip> % :i (>=>)
03:06:24 <yahb> mniip: (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c -- Defined in `Control.Monad'; infixr 1 >=>
03:06:30 <trcc> ah
03:06:48 <kuribas> kleisli arrow
03:07:48 <mpickering> Taneb: You're right that changing that makes the list version take a very long time
03:08:47 <mpickering> https://www.irccloud.com/pastebin/KqMq0THm/
03:17:24 <madnight> trcc: it's the right fish https://beuke.org/haskell-pronounceable-names/
03:18:05 <madnight> trcc: <=< is the left fish
03:18:24 <madnight> that's basically the same fish but turned around
03:28:26 <trcc> % :i modifyIORef'
03:28:26 <yahb> trcc: modifyIORef' :: IORef a -> (a -> a) -> IO () -- Defined in `Data.IORef'
03:28:42 <trcc> % :i deRefStablePtr
03:28:42 <yahb> trcc: ; <interactive>:1:1: error: Not in scope: `deRefStablePtr'
03:33:19 <trcc> % :i writeIORef'
03:33:19 <yahb> trcc: ; <interactive>:1:1: error: Not in scope: writeIORef'
03:33:21 <trcc> % :i writeIORef
03:33:21 <yahb> trcc: writeIORef :: IORef a -> a -> IO () -- Defined in `GHC.IORef'
03:35:11 <mniip> if I throw SomeException AnException  and catch AnException?
03:35:24 <mniip> sounds like Typeable magic should be able to guarantee that
03:35:31 <mniip> s/if/can/
03:41:23 <mniip> does GHC have a more fork(3) like function with e.g  IO a -> IO (Maybe ThreadId)
03:41:55 <mniip> or perhaps, fork :: IO a -> IO a -> IO a
03:41:57 <mniip> er
03:42:04 <mniip> or perhaps, fork :: (ThreadId -> IO a) -> IO a -> IO a
03:42:33 <liste> :t forkOS
03:42:34 <lambdabot> error:
03:42:34 <lambdabot>     • Variable not in scope: forkOS
03:42:34 <lambdabot>     • Perhaps you meant one of these:
03:42:39 <mniip> no
03:42:42 <mniip> I'm looking for
03:43:01 <mniip> fork k m <* x  =  fork ((<* x) . k) (m <* x)
03:43:26 <mniip> if(fork()) { /*parent*/ } else { /*child*/ } /*both*/
03:44:14 <mniip> NB: the child doesn't terminate when it runs out of else{}
03:45:54 <mniip> I understand this is easily handled by ContT IO but
03:46:25 <trcc> I am trying to combine deRefStablePtr with writeIORef: f x y = (deRefStablePtr x) >>= (\z -> writeIORef z y ) . So far, I got to: Monad m => (a -> m b) -> (b -> c -> m ()) -> (a -> c -> m ()). However, this does not exist. Am I doing something wrong in terms of hoogle, or does something like that just not exist?
03:47:23 <mniip> that doesn't look like a function worth having
03:49:24 <trcc> hehe
03:49:43 <trcc> It is basically composing a function with 1 argument with a function of 2 arguments
03:49:45 <fommil> I've built my own cabal-install, and deleted the OS (ArchLinux) version because I've lost faith in their packaging. But when I run it I get "/usr/bin/cabal: No such file or directory" ... is cabal hardcoding to /usr somewhere?
03:50:04 <mniip> fommil, 'hash cabal'
03:50:29 <fommil> mniip: thanks! I thought I'd done that already
03:50:43 <fommil> I've rebooted so many times today I've forgotten what I've done
03:52:06 <mniip> % :t System.Posix.Process.forkProcess
03:52:06 <yahb> mniip: IO () -> IO System.Posix.Types.ProcessID
03:52:20 <mniip> but its docs don't give a good vibe
03:52:34 <mniip> ah, that still doesn't do what I need
04:07:02 <fommil> does anybody have a cabal file for xmonad, this is how I have been compiling with the system cabal: ghc --make xmonad.hs -i -ilib -fforce-recomp -main-is main -v0 -o $1
04:07:25 <fommil> now I have a cabal sandbox in my ~/.xmonad and I'm trying to work out what goes into the .xmonad/build
04:22:56 <mpickering> Using a cabal sandbox sounds like you're doing something quite old school
04:24:35 <Athas> Which non-prerelease alternatives to sandboxes exist?
04:30:46 <hc> stack
04:30:59 <merijn> Athas: new-build is in a released version of cabal-install
04:31:06 <mpickering> Using nix or new-build
04:33:53 <Athas> merijn: but don't they still call it incomplete?
04:34:21 <merijn> Athas: Complete enough for most usecases
04:34:24 <Athas> "Some features described in this manual are not implemented. If you need them, please give us a shout and we’ll prioritize accordingly."
04:34:40 <merijn> Athas: I think the plan is that new-build will be switched in one of the next 2 releases
04:34:42 <Athas> This does not sound like a full replacement for sandboxes yet, although it worked fine for the few things I've tried with them.
04:34:57 <Athas> Good!  I hope they will stop with the awkward "Nix-style local build" terminology, though.
04:35:49 <Athas> I even used 'cabal new-haddock' at one point where 'stack haddock' would segfault on language-c-quote.
04:53:29 <dmwit> koz_: ping
04:55:03 <dmwit> koz_: I have the same answer as cocreature, for what it's worth.
04:55:14 <dmwit> koz_: Existentials are a bit like IO: once you go into one, you can never come back out.
04:56:05 <dmwit> koz_: So you'll need `exfiltrate` to again return an existential box like `data ColumnVal = forall a. ColumnVal (AttributeOf a) a`.
04:57:40 <dmwit> koz_: The only way out of an existential is to have something that can return the same type, no matter what type was existentially wrapped, as in `unwrap :: (forall a. AttributeOf a -> a -> b) -> ColumnVal -> b`.
04:58:23 <merijn> They're worse
04:58:50 <merijn> Because existentials warp everything around them into ugly Rank2 CPS code to be useful and you end up writing more boilerplate than just doing the simple thing
05:00:15 <dmwit> Athas: The new hotness to replace sandboxes is GHC environments.
05:00:28 <merijn> dmwit: Not really, they hardly ever work
05:00:48 <dmwit> err... are "environments" the right word? I'm not talking about .ghc.environment files here.
05:01:16 <mpickering> The whole ghc environments mess could have been avoided if they worked like every other tool - you enter one by an explicit command 
05:02:01 <dmwit> Oh, I guess this is probably still what Athas would consider prerelease, though. https://github.com/hvr/cabal-env
05:13:18 --- mode: glguy set +v rockstarr
05:13:36 --- mode: glguy set +v shak
05:13:59 <shak> but i cannot figure how to execute ops in main since it is of type IO ()
05:14:33 <merijn> shak: See the message you got
05:17:56 <shak> If i write  main = putStrLn $ runStateT ops [], I get 
05:18:06 <shak>     • Couldn't match type ‘Data.Functor.Identity.Identity’ with ‘[]’       Expected type: String         Actual type: Data.Functor.Identity.Identity ([Int], [Int])
05:21:20 <merijn> shak: putStrLn wants a String, not "([Int], [Int])" which is what runStateT returns
05:22:23 <Ariakenom> :t runStateT -- also Identity
05:22:25 <lambdabot> StateT s m a -> s -> m (a, s)
05:22:35 <Ariakenom> wait no nevermind
05:22:49 <pavonia> :t runState
05:22:50 <lambdabot> State s a -> s -> (a, s)
05:25:01 <shak> wonderful this works main = let (x:xs, x2:xs2) = runState ops [] in   putStrLn $ show x2
05:26:15 <shak> what are the tuples returned in the runState? Are they initial and final state ?
05:26:21 <pavonia> Note that this will crash if one of the lists is empty
05:26:48 <Ariakenom> shak: result of last state action and last stat I'd guess
05:27:47 <shak> Ah okay.. got it. 
05:30:34 <cocreature> t runState
05:30:38 <cocreature> :t runState
05:30:39 <lambdabot> State s a -> s -> (a, s)
05:30:54 <cocreature> shak: the type of that should already tell you that it can’t be initial and final state
05:35:34 <shak> true, should have noticed that
05:36:19 <dmwit> shak: FWIW, I'd want to write `case runState ops [] of (x:xs, x2:xs2) -> putStrLn $ show x2` if only so I would have the easy opportunity later to handle empty return lists. Also, since you're ignoring the output value, you might like `execState`.
05:36:23 <dmwit> :t execState
05:36:24 <lambdabot> State s a -> s -> s
05:38:47 * hackage jord 0.4.0.0 - Geographical Position Calculations  http://hackage.haskell.org/package/jord-0.4.0.0 (CedricLiegeois)
05:40:06 <merijn> I'd use "print" instead of "putStrLn . show" :p
05:41:08 <shak> cool makes sense 
05:44:12 <shak> If I am modelling a multi player game and want to receive the player's commands as channel.. Does it make sense to use channels in the record type of the players?
05:44:36 <shak> sth like: ` data Player = Player {name :: String                      ,score :: Int                      ,hand :: Deck                      ,pChan :: TChan PlayerMessage                      ,dChan :: TChan DealerMessage}`
05:46:22 <merijn> Yes, no, maybe :p
05:46:34 <pie_> erikd, i have a big 5mb javascript file, you think theres anyway to parallelize or speed up readJS or something?
05:48:34 <ChaiTRex> shak: You'll know better than me which to choose in the end, but also consider a regular old list if you don't need multiple consumers. You get all the listy things for free with a list.
05:51:04 <ChaiTRex> pie_: There's probably no easy way to parallelize parsing, but you can make sure you use something like Text to get faster access to the source code and fusion optimizations.
05:51:53 <pie_> ChaiTRex, yeah i didnt think it likely
05:52:05 <dstolfa> pie_: you could imagine parsing each function block in parallel
05:52:13 <dstolfa> and then unifying the things that pop out if needed...?
05:52:23 <pie_> dstolfa, wouldnt you need to already have parsed to know where they are?
05:52:24 <pgiarrusso> pie_: if you want to parallelize parsing, something else must be wrong
05:52:41 <dstolfa> pie_: not if you do a binary search for them
05:52:59 <pie_> pgiarrusso, well its not the slowest thing, its tolerable, ill time it, but it probably takes like 30 seconds
05:53:12 <pie_> hm then again i didnt test how fast that is compiled
05:53:43 <dstolfa> pie_: start at the half of the file, then half on each side of that and so on until you reach a small enough gap between the halves and start doing it linearly at that point. it's dirty and awful but it's a way to do it
05:53:47 <pgiarrusso> If parsing’s the bottleneck, change parser I guess?
05:53:56 <dstolfa> but i tend to agree with pgiarrusso here
05:54:10 <pie_> this is the nly parser i found that works well, oh well, ill focus on other time issues then
05:54:19 <pie_> pgiarrusso, i made the homogeneous tree i was talking about with mietek but it seems to slow stuff down a lot
05:54:31 <dstolfa> pie_: are you trying to JIT btw?
05:54:40 <dstolfa> pie_: if so, usually you don't parse everything
05:54:52 <dstolfa> you parse, you guessed it, the things you need to parse to JIT
05:54:57 <dstolfa> otherwise you take the slow path and interpret it
05:55:19 <pie_> dstolfa, nah im not, just AST manipulations
05:55:31 <pgiarrusso> dstolfa: isn’t that “you don’t compile everything”?
05:55:43 <pie_> well ok bottom line is i need to work at it some more and maybe something will crystallize
05:56:09 <pgiarrusso> I’d check how long do other parsers take (dunno, in browsers)
05:56:13 <pgiarrusso> Or node.js
05:56:13 <dstolfa> pgiarrusso: yes, but my point is that he doesn't need to parse the whole file, he just needs to parse the part where he JITs it, the rest is interpreted (and you could argue parsed, but not before it gets executed)
05:56:18 <ChaiTRex> pie_: The big speedups are usually better data structures for the task and better algorithms for the task.
05:56:29 <pie_> ChaiTRex, right
05:56:41 <dstolfa> pie_: but regardless, is time that big of a deal if all you do is AOT manipulation of the AST?
05:57:06 <pgiarrusso> pie_: my gut feeling is that those parsers must be much faster
05:57:06 <pie_> well my stuff currently takes 130 seconds to run on one core (and iirc i didnt implement a lot of things yet)
05:57:17 <merijn> parsing is hard to parallelise
05:57:26 <merijn> Unless you can split into independent modules/chunks
05:57:32 <ChaiTRex> pie_: You could probably parallelize other things. Like what else are you doing besides parsing?
05:57:48 <pie_> you guys are probably all right, one sec, im timing parsing
05:58:16 <pavonia> dstolfa: How do you defer parsing parts of the code? Don't you need to parse the whole thing to know where the parts "not to parse" start and end?
05:58:58 <pgiarrusso> I guess you could split code in blocks by lexing and counting parentheses
05:59:02 <dstolfa> pavonia: you just populate the data structure as things get executed while you interpret them and profile things. you then use some heuristics, i.e. most commonly called hot path and JIT that CFG
05:59:02 <merijn> pie_: I missed the start of the conversation, but someone mentioned Text. Is the current one using String?
05:59:17 <pie_> its whatever language-javascript uses
05:59:29 <dstolfa> pavonia: that's roughly the approach people have to initial JIT compilers without spending too much time on optimising the parsing itself
05:59:30 <pie_> ok you guys are right parsing only seems to take like 20 seconds
05:59:41 <pgiarrusso> still looks like a lot
05:59:43 <pie_> thats like...15% of the run time
05:59:46 <pie_> pgiarrusso, its a big file
05:59:50 <pie_> two big files
06:00:03 <pgiarrusso> Scala parsers parse millions of lines per second
06:00:11 <pgiarrusso> Lines, not bytes
06:00:14 <pgiarrusso> (Iirc)
06:00:15 <pie_> iunno then
06:00:20 <dstolfa> parsing 5MB files sounds like it shouldn't take 20 seconds
06:00:43 <pie_> well that also involved putStrLn to /dev/null because i couldnt get it to actually execute the thunk otherwise
06:01:00 <pie_> (naive timing with time in bash)
06:01:02 <dstolfa> putStrLn will slow things down, even if to /dev/null
06:01:07 <pie_> sure
06:01:10 <pgiarrusso> Anyway, maybe it’s an inefficient parser, but if it’s not your bottleneck, you should look at other things
06:01:18 <pie_> pgiarrusso, yeah thats what im saying now
06:01:24 <pie_> sidenote, is there an easy way to parallelize this?: let [baked, compiled] = fmap Parser.readJs [b,c]
06:01:30 <ChaiTRex> pie_: Use deepseq for forcing evaluation.
06:01:36 <pie_> i was bumbling around with rpar a bit yesterday but couldnt get it to work
06:01:44 <pie_> ChaiTRex, oh that would make sense...
06:01:59 <pie_> guess i gotta implement NFData for that then 
06:04:51 <pie_> No instance for (NFData JSAST) arising from a use of ‘rdeepseq’
06:04:57 <pie_> let _ = parMap rdeepseq id [baked, compiled]
06:05:03 <pie_> yup, oh boy lol this might get tedious
06:05:25 <pie_> this is what that looks like http://hackage.haskell.org/package/language-javascript-0.6.0.11/docs/Language-JavaScript-Parser-AST.html
06:06:21 <merijn> pie_: You can do "deriving (Generic)" on your datatypes, then use the default instance for NFData
06:06:36 <pie_> merijn, hm. maybe i can use standalonederiving
06:06:40 <pavonia> dstolfa: Do you have a term to google or link to some example of that? I really don't understand how this is supposed to work in languages like JS. In Haskell you could probably skip parts based on indentation, but in JS I can only think of the brace counting mentioned earlier
06:07:37 <pie_> merijn, i still have to do it on 20 different types though but its still better than writing it by hand
06:08:30 <pie_> ChaiTRex, I use these to turn the AST (made of compositions of like 20 types) into something i can traverse: https://bpaste.net/show/5728d8a08f85 https://bpaste.net/show/a3635ad88a87
06:09:54 <dstolfa> pavonia: unfortunately i don't :(. there are many ways to do it, brace counting is one. another one to consider are all statements that have something to do with branches, so you compute the CFG as you interpret it and see how often you hit each branch (kind of like branch predictors work). you can then JIT that hotpath
06:10:08 <dstolfa> pavonia: i'm sure there are some papers/books covering it, i just don't know any
06:11:10 <pavonia> Okay
06:11:54 <pie_> merijn, well it compiled \o/ but it still only used one core..
06:12:03 * pie_ checks he compiled with -threaded
06:12:15 <pie_> yup ghc -O3 -threaded
06:13:00 <cocreature> pie_: how are you running your program?
06:13:08 <pie_> sidenote, oh theres only -O2
06:13:20 <pie_> pushd ..; ./build.sh; popd; time ../_build/bin/SC >/dev/null
06:13:21 <merijn> pie_: Did you actually parallelise anything?
06:13:47 <pie_> oh im dumb i left it commented out....
06:13:48 <madnight> is there a common idiom for lets say (fmap . fmap . fmap)? so repeating functions N times?
06:14:13 <cocreature> pie_: you need to run with something like "+RTS -N" if you actually want multiple cores
06:14:19 <pie_> cocreature, ah.
06:15:04 <pie_> merijn, so I did 'deriving instance Generic JSAST' but I still get 'No instance for (NFData JSAST) arising from a use of ‘rdeepseq’'
06:15:21 <Clint> madnight: some people use .: iirc
06:17:05 <madnight> % :t (.:)
06:17:05 <yahb> madnight: ; <interactive>:1:1: error:; * Variable not in scope: .:; * Perhaps you meant one of these: `C..' (imported from Control.Category), `.' (imported from Prelude), `.~' (imported from Control.Lens)
06:17:42 <pie_> merijn, ah i got it. i needed deriveanyclass and derive nfdata as well
06:17:47 <pie_> merijn, thanks for the pointer
06:18:50 <Clint> madnight: no, i'm wrong, that was for fmap.fmap
06:26:52 <trcc> @pl deRefStablePtr ptr >>= \ioref -> writeIORef ioref state
06:26:52 <lambdabot> flip writeIORef state =<< deRefStablePtr ptr
06:27:28 <trcc> @pl writeState ptr state = deRefStablePtr ptr >>= \ioref -> writeIORef ioref state 
06:27:28 <lambdabot> writeState = (. flip writeIORef) . (>>=) . deRefStablePtr
06:28:07 <pie_> oh boy more stange things, this is right here: http://hackage.haskell.org/package/language-javascript-0.6.0.11/docs/Language-JavaScript-Parser.html#t:CommentAnnotation
06:28:31 <pie_> but when i try 'deriving instance Generic CommentAnnotation' i get ' Not in scope: type constructor or class ‘CommentAnnotation’'
06:30:08 <pie_> I got all the other ones to work https://bpaste.net/show/bea00a92b2ea
06:31:04 <pie_> oh looks like it might not be exported...
06:32:30 <ChaiTRex> pie_: No, it's exported from that module (https://hackage.haskell.org/package/language-javascript-0.6.0.11/docs/src/Language-JavaScript-Parser-Token.html)
06:32:54 <pie_> hm but i think that might be private?
06:34:43 <ChaiTRex> pie_: The module is exposed: https://github.com/erikd/language-javascript/blob/new-ast/language-javascript.cabal#L60
06:34:57 <pie_> all righty then (im waiting for nix to build)
06:36:12 <pie_>     Could not find module ‘Language.JavaScript.Parser.Token’
06:36:13 <pie_>     it is a hidden module in the package ‘language-javascript-0.6.0.11’
06:36:14 <pie_> :I
06:36:28 <ChaiTRex> Hmm...
06:36:44 <pie_> weird
06:36:46 <cocreature> it’s not exposed, the link ChaiTRex posted shows that it’s in other-modules not in exposed-modules
06:36:59 <ChaiTRex> Oh, I misread. Sorry.
06:37:09 <trcc> stDoStepFunction = unsafePerformIO $ newIORef Nothing  won't this create a new IORef every time it is invoked?
06:37:32 <pie_> well...i guess i could expose it?
06:37:34 <ChaiTRex> LexerUtils, ParseError, ParserMonad, and Token are all hidden.
06:37:45 <pie_> or reexport CommentAnnotations in the .AST
06:38:00 <cocreature> trcc: you need a NOINLINE pragma on this kind of definition to prevent that from happening
06:38:10 <cocreature> trcc: but really you should just avoid using code like this in the first place :)
06:38:33 <trcc> What does the NOINLINE pragma do?
06:38:57 <cocreature> pretty much what the name suggests, it prevents GHC from inlining the definition
06:39:49 <trcc> I am not really sure what that means. I need it to create the ioref once, and then I read/write it later on, without recreating it
06:39:55 <ski> trcc : if you follow cocreature's suggestion, then `stDoStepFunction' will be bound to a single reference cell. otherwise, perhaps you'll get multiple ones, or perhaps not
06:39:58 <ChaiTRex> trcc: I use it when I have a value that I don't want to recalculate so much.
06:40:01 <trcc> ah ok
06:40:18 <trcc> so I should add {-# NOINLINE stDoStepFunction #-}
06:40:25 <ChaiTRex> trcc: If it gets inlined, the definition gets repeated all over the place and it gets recalculated at those places.
06:40:56 <trcc> ahh that is what it means
06:41:07 <ski> trcc : usually it's better to create it normally, and then either pass it in as an argument (perhaps hidden), or use it in place (e.g. in an action that you return and later invoke)
06:41:26 <pie_> ChaiTRex, ok w00t that worked
06:41:46 <ski> (perhaps hidden in a monad or idiom (aka applicative functor), i.e.)
06:41:47 <pie_> saved a grand total of 1 second on exec time wtf xD
06:42:15 <pie_> how do i test the speed of this thing without printing it
06:42:23 <pie_> i guess i need to force evaluation somehow
06:42:54 <ClaudiusMaximus> _ <- evaluate (deepseq thing thing) -- something like this
06:43:10 <trcc> How is it performed within GHC? The first time the function is invoked it creates a reference cell, the following times the function is invoked it returns a reference to it?
06:44:30 <ChaiTRex> pie_: Just do print (deepseq theThing ())
06:44:46 <ChaiTRex> pie_: You'll see "()" printed after it's all evaluated.
06:44:47 <ski> trcc : in your case, `stDoStepFunction' is *not* a function (it *is* the reference cell)
06:44:51 <pie_> ChaiTRex, ahh
06:44:58 <trcc> ahh ok
06:45:08 <pie_> if i wanted to do it fully cleanly i would use evaluate as mentione dby claudius?
06:45:09 <trcc> Thank you
06:45:36 <ChaiTRex> pie_: I'm not sure what that is, so maybe :)
06:45:58 <ski> trcc : but, yes. probably something like that, unless some fancy optimization/improvement reorganizes things. and `NOINLINE' is meant to avoid such problems here
06:46:28 <ChaiTRex> pie_: Oh, something for after the parsing is fast: https://hackage.haskell.org/package/streamly
06:46:34 <ski> trcc : still, i think it's usually better to avoid using `unsafePerformIO', even in this specific stylized use-case
06:46:41 <ChaiTRex> pie_: It can help you to parallelize the parsing with other phases.
06:46:48 <pie_> hm
06:46:56 <merijn> hmmm
06:47:20 <pie_> to be fair this is mostly an exercise at this point since 90% of the time seems to be elsewhere
06:47:27 <trcc> ski: I will submit my full program later on (First one in Haskell, and not so big) and then hopefully someone will give me feedback. There are reasons for me doing it this way
06:48:16 <pie_> ok here's the parse timing 
06:48:16 <pie_> 9.06user 2.72system 0:07.56elapsed 155%CPU (0avgtext+0avgdata 999048maxresident)k
06:48:16 <pie_> 0inputs+0outputs (0major+248775minor)pagefaults 0swaps
06:48:21 <ski> @wiki Global variables
06:48:21 <lambdabot> https://wiki.haskell.org/Global_variables
06:48:31 <ski> @wiki Top level mutable state
06:48:31 <lambdabot> https://wiki.haskell.org/Top_level_mutable_state
06:48:45 <ski> trcc : see those ^ wiki pages for some more info
06:48:47 <merijn> Dammit, I really need to some up with a better way to verify my algorithm results >.> Anyway know of a sensible way of checking whether two large sequence of floating points are "close enough" without storing the entire sequence >.<
06:49:03 <trcc> ah ye, thanks
06:49:17 <pie_> without parallelism it takes:
06:49:18 <pie_> 9.90user 2.98system 0:08.17elapsed 157%CPU (0avgtext+0avgdata 980576maxresident)k
06:49:18 <pie_> 0inputs+0outputs (0major+244174minor)pagefaults 0swaps
06:49:22 <pie_> thats kind of weird
06:49:58 <pie_> i guess most of the performance was lost on printing? and then something that cant really get sped up here
06:50:03 <merijn> pie_: How are you doing the parallelism?
06:50:12 <pie_>     --print $ deepseq (parMap rdeepseq id [baked, compiled]) ()
06:50:12 <pie_>     print $ deepseq [baked,compiled] ()
06:50:20 <pie_> the top is the first timing paste
06:50:22 <merijn> pie_: Also, use "time -p" this is rather unreadable :)
06:50:48 <pie_> merijn, oh thats much better thanks
06:51:10 <pie_> also which one of these is the actual elapsed itme lol
06:51:17 <merijn> pie_: You're deepseq twice in the first, which means you traverse everything twice...
06:51:26 <merijn> pie_: You want "real" which is wallclock time
06:51:39 <pie_> merijn, ah ok
06:51:51 <dataN> merijn: wouldnt there be a problem if the subset was biased? i.e. only a random choice over the zipped lists would be safe, and so requiring a complete traversal... 
06:52:17 <pie_> so how do i avoid the second deepseq
06:52:37 <pie_> just seq?
06:52:40 <merijn> dataN: hmm?
06:52:50 <pie_> nah that didnt force eval..
06:53:31 <ChaiTRex> pie_: Is baked what compiled uses for input?
06:53:42 <pie_> ChaiTRex, no these are two independent input
06:53:45 <pie_> s
06:53:48 <ChaiTRex> Oh, OK
06:54:02 <ChaiTRex> pie_: They use the same inputs?
06:54:14 <merijn> dataN: I have a setup where I basically store the hash of my algorithm output for the algorithm to check whether results match. Unfortunately I now added pagerank which has floating point output so isn't entirely stable. I figured I'd just round to 2 or so significant digits. Unfortunately apparently that still has some noise and 1 significant digit seems...excessively imprecise
06:54:56 <pie_> ChaiTRex, nope: b <- readFile bakedPath' ; c <- readFile compiledPath'
06:55:03 <pie_> let [baked, compiled] = fmap Parser.readJs [b,c]
06:55:07 <ChaiTRex> pie_: Oh, I see.
06:55:36 <pie_> ChaiTRex, here's a paste, sorry its so messy https://bpaste.net/show/0126b82c0b08
06:56:24 <Ariakenom> merijn: throw away "unnecessary" precision
06:56:50 <merijn> Ariakenom: Right, but the point is that I'm already down to two significant digits and still getting too much noise :)
06:57:01 <Ariakenom> merijn: I see ...
06:57:50 <dataN> so, reading about completeness (contextual and functional) for polymorphic lambda calculi following the work of Lambek, how are such properties relevant to haskell programs? is a subset of haskell (such as omitting some of the more flexible language extensions) "complete"?
06:57:53 <ChaiTRex> pie_: What happens if you do print $ (parMap rdeepseq id [Parser.readJs b, Parser.readJs c]) ()?
06:59:26 <dataN> merijn: why? is that less expensive than direct equality? 
06:59:29 <pie_> ChaiTRex, does that even make sense?
06:59:43 <pie_> oh
06:59:51 <pie_> one sec
07:00:13 <pie_> ChaiTRex, yeah parmap doesnt take that many arguments?
07:00:53 <ChaiTRex> It shoulud be just three arguments.
07:01:16 <pie_> print $ parMap rdeepseq id [baked, compiled]
07:01:23 <pie_> works but it prints all the results which we want to avoid
07:01:42 <pie_> actually
07:02:40 <pie_> i guess i should do let [baked, compiled] = parMap rdeepseq id (fmap Parser.readJs [b,c])
07:02:51 <dataN> and if so, which language extensions should be avoided to guarantee such properties? which properties can be expected to hold over these language subsets, and what additional properties can be attained by further restriction to languages that can be compiled to haskell? what examples of this exist? 
07:02:56 <pie_> but then i now need to force baked and compiled somehow
07:03:06 <ChaiTRex> pie_: I'd eliminate the fmap just in case GHC is messing with the parallelization.
07:03:30 <pie_> ok
07:03:54 <ChaiTRex> pie_: parMap rdeepseq id ([Parser.readJs b, Parser.readJs c])
07:03:58 <pie_> yeah
07:04:31 <ChaiTRex> pie_: If that gives the same results timewise, you can switch back.
07:04:42 <ChaiTRex> pie_: Also, maybe (const ()) instead of id
07:04:43 <pie_> ugh this is annoying, i wouldnt care if it was lazy when using it but i need to force it to eval to benchmark
07:05:23 <pie_> ChaiTRex, well either i print it and get bad timing info or i dont and it doesnt get evaled
07:05:31 <dataN> suppose some code can be written in a very simple way, can a very restricted language guarantee some very strong properties hold? what can be the benefit of ensuring properties such as functional or contextual completeness hold for some program?
07:05:46 <ChaiTRex> pie_: Let me check something.
07:05:59 <pie_> ChaiTRex, maybe the rdeepseq should be switched out for something else and rdeepsec moved outside?
07:06:22 <dminuoso> Is there some hacky way to do IO in STM in such a way, that the IO is only done when a transaction is committed?
07:06:26 <pie_> meh but [baked,compiled] itself is still lazy
07:06:31 <dstolfa> dataN: see seL4, they did that with a very small subset of C and haskell
07:06:52 <ChaiTRex> pie_: The rdeepseq should take care of the full evaluation and the (const ()) should give you ()s after that.
07:07:16 <ChaiTRex> pie_: You'll be able to tell by if the time goes to near zero or not.
07:07:20 <pie_> ChaiTRex, but if i use const () i wont get my results? ok well if i split it back into what it originally was i guess i can do that
07:07:46 <ChaiTRex> pie_: It should still evaluate the results fully and then give you ()s.
07:08:06 <ChaiTRex> pie_: So, timing will be good to go and you won't get a bunch of output on the terminal.
07:08:11 <pie_> i supose
07:08:18 <dminuoso> Although.. I think Im looking at this problem wrong.
07:08:19 <pie_> trying this:
07:08:19 <pie_>     let st@[baked, compiled] = [Parser.readJs b, Parser.readJs c]
07:08:19 <pie_>     print $ parMap rdeepseq (const ()) st
07:08:23 <ChaiTRex> pie_: Though if the time goes to near zero, I'm wrong.
07:08:43 <dataN> merijn: maybe a order preserving transformation would be better than a hash for that, as then a difference could be taken, and then the question is about choosing an order preserving compression. 
07:08:51 <pie_> ChaiTRex, time is zero...
07:09:17 <dataN> dstolfa: did what?
07:09:42 <dstolfa> dataN: restricted themselves to a subset of the language, proved a bunch of things about it and then proved that it refines their specification
07:09:55 <ChaiTRex> pie_: Ahh, OK.
07:10:00 <ChaiTRex> pie_: Scratch that plan then.
07:10:17 <merijn> dataN: That doesn't work, because that'd mean I have to store all the data, which is too much
07:10:28 <dataN> the question is about if language extensions should be avoided to ensure completeness 
07:10:36 <dstolfa> dataN: ah.
07:10:45 <pie_> ChaiTRex, i find it a bit funny how people that actually have a clue have trouble with this :D
07:10:51 <pie_> haskell pls
07:11:19 <dataN> so, probably, is haskell98 complete in any sense?
07:11:20 <ChaiTRex> pie_: Does print $ parMap rdeepseq id st halve the time or give the same?
07:11:23 <pie_> i tried: print $ (parMap rdeepseq id st) `seq` () 
07:11:25 <pie_> thats also zero
07:11:54 <merijn> dataN: I think what I really want is "the N significant before the Mth decimal place", but I don't think there's an easy way to compute that
07:12:15 <pie_> ChaiTRex, it has time but it might just be a lot of printing, idk if parsing would take zero time :p
07:12:25 <fryguybob> dminuoso: The usual way to do that is to return an IO action.  You can then make your own atomically that would run that action on commit.
07:12:28 <pie_> real 17.88 user 22.6 sys 6.15
07:14:05 <fryguybob> dminuoso: If you require those IO actions to be serialized, you can take a TVar acting like a lock in your transaction, return the IO action, execute the action, then atomically release the TVar.
07:14:06 <MarcelineVQ> merijn: dunno if this makes sense but what about treating the produced data source as a stream with two consumers that start at the same place, one consumes to compare in a low-memory fashion, the other is just waiting (saving the spot so to speak) until you want to take the data in full
07:14:14 <ChaiTRex> pie_: How long does parsing each alone take?
07:14:40 <merijn> MarcelineVQ: I never want the data in full, tbh
07:15:08 <pie_> ChaiTRex, how do i find out without printing it? :O
07:15:09 <pie_> * :I
07:15:09 <merijn> MarcelineVQ: I'm just sanity checking that my different implementations actually get the same results (and are thus, in fact, different implementations of the same thing, rather than buggy nonsense)
07:15:15 <fryguybob> dminuoso: You can wrap this up in an API that should be able to hide enough to prevent it from going wrong, but the run time will not prevent you from getting it wrong (like doing something in you IO action that runs another transaction with your IO).
07:15:34 <Ariakenom> :t join . Control.Concurrent.STM.atomically -- I do hate these overly hierarchical name spaces
07:15:36 <lambdabot> GHC.Conc.Sync.STM (IO a) -> IO a
07:15:49 <MarcelineVQ> oh okay, so you're having trouble making a streaming comparison?
07:16:05 <ChaiTRex> Just use [baked] or [compiled] in place of st.
07:16:47 <dataN> basically, this is motivated by the extension of completeness from simply typed to polymorphic lambda calculus, which seems to be what RankNTypes is about?
07:17:52 <merijn> MarcelineVQ: The problem is that the "golden" correct input I'm comparing against is computed ahead of time and I have 250 results for 15 implementations, with a lot of results measuring into the multiple gigabytes. So there's no real simple way to compare them in a streaming fashion
07:18:54 <MarcelineVQ> are singular results many gigabytes or are the sequences to be compared totalling many gigabytes?
07:18:55 <pie_> ChaiTRex, ah what the hell, i just timed the whole program run and the runs are  103 seconds and 99 seconds so i dunno
07:19:07 <pie_> ChaiTRex, i guess parsing is fast enough
07:19:11 <merijn> MarcelineVQ: Single results can easily be several GB
07:19:13 <MarcelineVQ> I see hmm
07:19:31 <MarcelineVQ> what is a result?
07:19:31 <pie_> ChaiTRex, or i just did other stuff that compromised the test ;p
07:20:02 <merijn> MarcelineVQ: Correct label for each vertex in a graph
07:20:08 <pie_> but why is printing so slow XD
07:20:15 <ChaiTRex> pie_: One other possibility is that the OS cached the files you're reading from in RAM.
07:20:30 <ChaiTRex> pie_: Unless you were getting the original results repeatedly.
07:20:50 <pie_> ChaiTRex, i was
07:20:57 <ChaiTRex> pie_: Ahh, OK.
07:21:02 <pie_> and it did 103 again
07:21:03 <pie_> so idk
07:21:29 <dataN> dstolfa: does this mean that the question should also consider what is required by some specification, so that as well as considering "sufficient subsets of a language" it is also necessary to consider if some subset of propositions are required?
07:22:30 <pie_> ChaiTRex, ok im going to try evaluate
07:22:38 <pie_> aaaand that also seems to take zero time
07:22:44 <pie_> ClaudiusMaximus, halp? ::p
07:22:44 <ChaiTRex> pie_: If you're going to use parMap still, use Parser.readJs instead of id to nicen things a little.
07:23:05 <pie_> ChaiTRex, good point
07:23:17 <dstolfa> dataN: well that depends. you could consider a subset of the language that you can prove is complete, you could take a subset that is relatively complete and be careful and you could take one that is not even relatively complete (and at that point, i would be careful about using that language at all) and be even more careful :-)
07:23:31 <pie_> im guessing evaluate didnt do anything either because im still not using the result
07:23:32 <dataN> as in; "my code can be written using a very simple subset of haskell, does this mean it has a better chance of capturing its completeness"?  
07:23:44 <coldpresent> why does vim give such bad indentation support for haskell?
07:24:06 <pie_> i cant believe parsing would be that fast >_>
07:24:10 <coldpresent> i'm using vim-polyglot plugin, is that the cause of my indentation problems?
07:24:12 <ChaiTRex> pie_: Even when you do putStrLn (deepseq results "Evaluated.")?
07:24:12 <dstolfa> dataN: what completeness do you mean here?
07:24:37 <dataN> take functional completeness as its seems sufficient 
07:25:07 <ChaiTRex> pie_: Like, do the parMap, then do deepseq on parMap's results.
07:25:13 <pie_> one sec
07:25:25 <dstolfa> dataN: in that case, you can prove functional completeness if you can prove that you can construct all propositional functions
07:25:34 <dstolfa> so, take a subset of haskell and have at it in something like agda :)
07:26:10 <pie_> ChaiTRex, oh right, yeah doing that takes 8 seconds
07:27:03 <ChaiTRex> pie_: Try with [baked] or [compiled] in place of st. See what the parallelization speedup is.
07:28:02 <pie_> ChaiTRex, that takes about 4 seconds
07:28:23 <pie_> so if deepseq is really going through it twice, i suppose it would hypothetically halve the time
07:28:24 <dataN> is the idea that by using some language extension that 'completeness proofs formulated over e.g. polymorphic lambda calculus' could be made to *not* hold? 
07:28:30 <pie_> of course id only be saving 4 seconds lol
07:29:21 <ChaiTRex> pie_: Yeah, I think the zeroing before was because you used seq instead of deepseq.
07:29:23 <dstolfa> dataN: for semantic, strong and refutational completeness, sure
07:29:42 <ChaiTRex> pie_: That only gets the (:) constructor of the list. deepseq gets both elements after parMap runs.
07:29:53 <pie_> ChaiTRex, meh, i need to read the parallel programming in haskell book.
07:29:56 <pie_> ChaiTRex, sure.
07:31:09 <pie_> ChaiTRex, ok but the question still stands how to get it to eval in parallel, strictly
07:31:20 <pie_> i want it evaled *now* instead of when its called :/
07:31:28 <pie_> then again
07:32:14 <pie_> ok i need to go get breakfast x) thanks for your time!
07:32:44 <dataN> essentially, the effort seems to be toward formulating the fewest axioms to give completeness, c.f. S,K combinators. so then what happens when the language is extended?
07:32:54 <Athas> dmwit: yes!  I am a grumpy man about releases.
07:33:13 <ChaiTRex> pie_: You're welcome. One thing to check when you come back is to compare the time that parMap and evalMap take.
07:33:49 <ChaiTRex> pie_: Sorry, evalList ... . map parsefunction
07:35:58 <ChaiTRex> pie_: See what the time difference between sequential and parallel evaluation is.
07:36:08 <ChaiTRex> pie_: Hopefully it about halves it.
07:38:37 <dataN> dstolfa: what would be the use of agda?
07:39:06 <dstolfa> dataN: mechanising your proof. if you can prove things without a proof assistant and not miss any cases, you are a better person than me :-)
07:39:19 <dstolfa> by "things" i mean sufficiently complex things, not textbook theorems
07:39:20 <dataN> things?
07:39:51 <dstolfa> dataN: prove that the subset of the language you're considering is functionally complete, for example
07:40:52 <dataN> how, by bombarding it with sufficiently many test cases? or by implementing some known complete set of combinators?
07:41:03 <dataN> (if thats the right way to say it)
07:41:52 <MarcelineVQ> total is the usual buzzword there
07:42:07 <dstolfa> dataN: it's up to you how you formulate the problem tbh, whatever is easiest
07:42:31 <shapr> totally
07:42:31 <dataN> no, how does agda do it?
07:42:49 <dstolfa> dataN: agda doesn't do it, you have to do it and i just used agda as a recommendation for a proof assistant that can help you do it :-)
07:43:21 <dstolfa> agda is based on intuitionistic type theory with stratified universes (not cumulative) and checks for totality of everything you write
07:43:36 <dstolfa> coq is similar, but has cumulative universes and tactics
07:43:50 <dstolfa> the other choice you have are HOL-based proof assistants like HOL light, isabelle, ...
07:44:40 <dataN> "checks for totality"? 
07:45:13 <dstolfa> dataN: terminates or produces a finite number of outputs
07:45:46 <dataN> why would you want to prove that!?
07:46:23 <dstolfa> dataN: to avoid constructing a terminal object that can be used to prove anything else
07:46:39 <dataN> for most calculations to arbitrary precision would be impossible to prove that
07:46:50 <merijn> dataN: Because then all the things that say "can't prove because halting problem" become provable
07:47:04 <dmwit> dataN: Goedel taught us that Turing completeness and soundness as a logic are mutually exclusive. Haskell chooses Turing completeness. Agda chooses logical soundness.
07:48:13 <dataN> right, well the question was about sufficient subsets of turing completeness, so how is the suggestion to use "logical soundness" to reason about this?
07:48:40 <merijn> sufficient subset of what?
07:48:44 <dstolfa> dataN: because if you want to prove something, you have to do it in a sound logic. you want to prove that your subset of the language is functionally complete
07:48:47 <dstolfa> you can do it by hand too
07:48:48 <dstolfa> but good luck with that
07:49:00 <dstolfa> (you still need to do it in a sound logic, even by hand btw)
07:49:11 <dataN> well sure, just implement SK combinators or a turing machine...
07:49:50 <dataN> i.e. implement a known complete language 
07:49:57 <dataN> or is that wrong?
07:50:01 <dstolfa> dataN: you mean functionally complete
07:50:18 <dataN> is that too restrictive?
07:50:23 <dstolfa> semantic completeness is a different thing (which is what we often mean when we say complete)
07:50:27 <dstolfa> it's a different notion entirely
07:50:44 <dstolfa> all functional completeness tells you is that you can express all propositional functions
07:50:49 <dmwit> dataN: Completeness and soundness are different. Agda is not complete.
07:51:27 <dstolfa> semantic completeness (which is often just called completeness) states that all tautologies are theorems. not even FOL is semantically complete, but it is relatively complete, i.e. things can be reduced down to arithmetic
07:51:32 <dstolfa> (same thing holds for hoare logic, btw)
07:52:45 <dataN> wait, why is that important?
07:52:54 <dmwit> dataN: Or another way to say that: you cannot implement SK or a Turing machine in Agda.
07:53:02 <dstolfa> dataN: because you may not be able to prove something in your proof system that's true if it's not complete
07:53:11 <dstolfa> i.e. a statement could be true, but you could never prove it
07:53:18 <dstolfa> that's what we mean by completeness
07:53:26 <dstolfa> or, semantic completeness if you will :-)
07:53:36 <asheshambasta> I'm considering writing an image on-the-fly optimisation/resizing HTTP service in Haskell using Servant. Something that accepts an image filename and format as query params and outputs the image in that format. Is Servant a good choice for something like that? 
07:53:49 <dataN> then why consider writing a proof system instead of a program!?
07:53:57 <dstolfa> dataN: ??
07:54:24 <asheshambasta> This service will need to be reasonably performant, but the benchmarks that I'm seeing online (namely techempower) paint a pretty bleak picture.
07:56:03 <dataN> why consider semantic rather than function completeness to answer the initial question about what subsets of haskell are complte?  
07:56:46 <dstolfa> dataN: because the ability to express all propositional functions doesn't change if you just add more things onto it and don't alter the semantics of the thing that was used for your proof
07:56:58 <dstolfa> that's why i asked what completeness you want to reason with
07:57:00 <dstolfa> and you said functional
07:57:31 <dstolfa> for that, it's sufficient to find A subset of haskell that can express all propositional functions
07:57:53 <dataN> to clarify, it is the completness of a language written in haskell that is in question 
07:58:30 <dataN> i.e. given a set of functions, can a turing machine be constructed 
07:58:31 <dstolfa> dataN: implement one that's known to be functionally complete
07:59:10 <dataN> right so how was agda supposed to help?
07:59:47 * hackage gi-vte 2.91.19 - Vte bindings  http://hackage.haskell.org/package/gi-vte-2.91.19 (inaki)
08:00:12 <dstolfa> dataN: well, you take the implementation out of the equation and you prove that the grammar + semantics of your language and prove functional completeness
08:00:29 <dstolfa> otherwise, it's not really a proof, it's more like a handwavy argument
08:00:35 <dstolfa> at least IMO :-)
08:00:37 <dstolfa> YMMV
08:01:23 <dataN> what?
08:01:30 <dstolfa> my first sentence was constructed like i'm an idiot. "... and you prove that the grammar + semantics of your language are functionally complete"
08:01:43 <dataN> how, using agda?
08:01:49 <dstolfa> dataN: any proof assistant
08:02:12 <dstolfa> whatever you like most
08:02:12 <dstolfa> :-)
08:02:37 <dataN> and thats the same as constructing a turing machine? 
08:03:00 <dmwit> No. It is an alternative way to prove equivalence to Turing machines.
08:03:18 <dataN> how does it do that?
08:03:43 <dmwit> blood, sweat, and tears
08:04:12 <dmwit> Less snarky answer: "it" doesn't. *you* do.
08:04:23 <dataN> how does it help?
08:04:26 <dmwit> *it* just checks that you didn't make a mistake in your work.
08:04:41 <dataN> how?
08:05:14 <dmwit> I can link you to some details on the algorithm...?
08:05:38 <dataN> what does it do!?
08:05:51 <dmwit> It checks proofs.
08:06:30 <dataN> why is that nesacary when writing a turing machine IS a sufficient proof so says everyone
08:06:51 <dmwit> It is not necessary, and also nobody claimed it was necessary.
08:06:56 <dataN> it has unit tests for a turing machine? 
08:07:18 <dataN> its sufficient though...
08:07:46 <dmwit> Correct, proving your sublanguage functionally complete in Agda would be sufficient.
08:08:08 <dmwit> I don't understand the question, "it has unit tests for a turing machine?". I don't know what "it" is. But every sensible substitution for "it" I can think of has the answer "no".
08:08:35 <dstolfa> if you want to *prove* functional completeness, you can't do it through something that goes through a compiler and executes, as you can't consider all possible inputs, and you can't guarantee that the imagined semantics of your programming language match the assembly that the compiler produced and the microinstructions that the uarch executes
08:08:48 <dstolfa> hence i don't consider anything that happens during runtime a proof of anything, just a happy coincidence
08:09:09 <cocreature> at least for an unbounded set of inputs :)
08:09:16 <dataN> so it neither constructs a turing machine, nor any other turing equivalent language and it somehow proves turing completeness? is that correct?
08:11:11 <dmwit> I don't think "you do not construct a Turing machine anywhere in the proof" is guaranteed to be correct. Nothing stops you from doing that, though it again doesn't seem to me like an obviously necessary step, either.
08:12:23 <dmwit> I don't think "you do not model any Turing-equivalent language anywhere in the proof" is likely to be correct. But you won't be able to embed that language in Agda, that is, write an evaluator that does potentially unbounded amount of computation.
08:12:43 <dataN> ok
08:12:44 <dmwit> I do think it should be possible to write down a theorem and a proof of "language X is Turing complete" in Agda.
08:13:34 <dolio> You can write an evaluator for it, even. You just won't be able to make it be evaluated as part of Agda's normal reduction.
08:13:57 <cocreature> you can’t write a function that given a turing machine and an input state will run it until it halts or loops forever in agda. you can certainly write a function that runs a turing machine for n steps, so in particular you can write the transition function
08:16:10 <dataN> can the proof assistant also help to show semantic completeness of the language? or is the question, what proofs can be used?
08:17:57 <dataN> and why write the proof (e.g. implement SK combinators) using agda anyway!? 
08:18:03 <dmwit> The proof assistant can help you convince yourself (and others) that when you showed semantic completeness of the language, you did not make any mistakes, forget any cases, mix up your quantification, do your induction incorrectly, etc.
08:19:02 <dmwit> And if you think that sounds like a trivial benefit, I think that you have not been horrified by trying to convert hand-written proofs into Agda and discovering how many places they were wrong. =P
08:19:06 <geekosaur> assuming it's not buggy, of course :)
08:19:15 <dmwit> Assuming Agda is not buggy, yes. =)
08:19:24 <geekosaur> (reflections on trusting trust has ramifications beyond security)
08:19:31 <dstolfa> i'd like to augment that
08:19:57 <dstolfa> assuming that agda is not buggy and assuming that anywhere else in the stack (including the CPU) there is no bug in the implementation
08:20:11 <dstolfa> i would consider agda to be the grammar + semantics. the implementation of agda is a lot more
08:20:25 <dstolfa> the former can be hand-checked in its core inference rules
08:20:29 <dstolfa> the latter... not quite :-)
08:20:37 <cocreature> rowhammer your way to proving false :)
08:20:47 <dstolfa> cocreature: lmao
08:21:12 <dataN> so it does not show the turning machine written in the language is actually a turing machine?
08:21:23 <dmwit> An Agda proof which exploited rowhammer to prove false would be an incredible technical achievement!
08:21:28 <cocreature> dstolfa: now I want to see someone actually pull that off :)
08:21:46 <dstolfa> cocreature: you know, it would make a fun workshop paper
08:21:56 * dstolfa might do that at some point
08:22:03 <cocreature> dstolfa: looking forward to reading your paper :D
08:23:26 <dmwit> dataN: I feel like you are still missing the point here.
08:23:37 <dataN> go on
08:23:37 <dmwit> dataN: It's on *you* to come up with a theorem and a proof.
08:23:47 <dataN> not turing?
08:24:05 <dmwit> dataN: I expect that, no matter what theorem you're (you specifically. I rule out cocreature) interested in stating, you can state it in Agda.
08:24:43 <cocreature> dmwit: rude!
08:24:46 <dmwit> dataN: If you want to prove that you wrote a Turing machine in some language, I thoroughly believe it is possible to state that theorem in Agda.
08:25:12 <dataN> how?
08:25:50 <dataN> earlier unit tests were ruled out
08:25:54 <dataN> earlier,
08:25:55 <dmwit> Step 1 is to define, in type theory, what a Turing machine is. Then you define what your language is. Then you define what it means to have a Turing machine in your language.
08:26:25 <dmwit> Step the last is to state that the term you wrote down in your language meets the definition you made for "what it means to have a Turing machine in your language".
08:27:04 <dmwit> It works the same way mathematicians do: first define your way up from very basic concepts to complex ones. Then state your theorem in terms of your defined things. Then make a proof.
08:28:49 <dataN> for what?
08:28:58 <dmwit> Agda's role is to verify that your definitions and proofs follow the rules of good mathematics, not to proscribe what mathematics are interesting to you.
08:29:39 <dmwit> cocreature: I think it is the opposite of rude. I'm saying I think you are skilled enough to come up with a theorem that couldn't be stated in Agda. =)
08:30:56 <dataN> so the way is to write a unit test, and that unit test is the construction of a turing machine in a turing complete language? oh no, that wouldnt work; then it could just output a string... hmm
08:30:58 <dmwit> s/proscribe/prescribe/ I guess
08:31:16 <dolio> What do unit tests have to do with anything?
08:31:50 <dataN> apparently agda is going to help prove a language turing complete.
08:31:59 <dolio> What do unit tests have to do with proofs?
08:32:09 <dolio> Mathematicians don't do unit tests.
08:32:27 <cocreature> agda is primarily going to help you and others that your proof is correct, it is not going to write the proof for you
08:32:35 <cocreature> dmwit: heh, in that case I take it back :)
08:32:43 <dataN> the proof involves constructing a turing machine, and further, proving that this turing machine works.
08:32:57 <dataN> that looks like a unit test
08:33:09 <dstolfa> dataN: i don't think you'll be able to construct such a proof, because what do you mean by: "this turing machine works"
08:33:10 <Logio> test != proof
08:33:13 <kuribas> dolio: they do for the collatz conjecture :)
08:33:17 <dstolfa> i think you first have to define the notion of a turing machine and prove that you can construct it
08:33:26 <dstolfa> and also what Logio said
08:33:28 <dolio> kuribas: Oh, that's true.
08:33:30 <geekosaur> that sounds like testing vs. proving. proving is not about testing, proving is about logically demonstrating that illegal states can't exist, not testing that they can't
08:33:32 <dstolfa> unit tests can't prove anything other than presence of bugs
08:33:42 <dstolfa> and they can't even prove that actually
08:33:46 <dataN> Logio: the proof is in creating this machine
08:33:46 <dstolfa> because happy coincidence during runtime
08:33:48 <dstolfa> versus sematnics
08:33:51 <glguy> How does this tie back into Haskell?
08:33:55 <geekosaur> if a system is constructed such that it cannot have an illegal state, and you can show that it is so constructed, you have proven it
08:34:02 <dstolfa> glguy: his language is implemented in haskell
08:34:11 <Logio> dataN: how do you demonstrate that you created it correctly?
08:34:17 <geekosaur> (but contemplate a certain quote attributed to Knuth)
08:35:13 <dataN> Logio: unit tests?
08:35:23 <Logio> as I said, those are not proofs
08:35:30 <MarcelineVQ> geekosaur: "That which should be destroyed by proofs should be" ?
08:35:32 <ChaiTRex> What's a good way to allow people to write functions as if they're dealing with a list of `Word`s (hopefully with list fusion active) when they're really dealing with a `ByteArray#` of `Word#`s and translate that with Template Haskell to code that corresponds directly (I don't want wrapper types and so on like with the primitive library)?
08:35:46 <geekosaur> MarcelineVQ, "beware, I have only proven this program correct, not tested it"
08:35:46 <dataN> well the only proof is constructing a turing machine, so it seems recursive
08:35:47 <MarcelineVQ> could be, oh well, it wasn't that good a line
08:36:00 <geekosaur> proofs and tests address different things
08:36:01 <Logio> dataN: have you done any mathematical proofs?
08:36:18 <geekosaur> neither is sufficient unto itself, notwithstanding people who apparently think unit tests are the be-all and end-all
08:36:21 <dataN> geekosaur: its a system of interacting point particles 
08:37:01 <dmwit> ChaiTRex: Can't. Lists can do lots of things that ByteArray#'s can't.
08:37:05 <dmwit> e.g. point to themselves.
08:37:22 <dataN> > True == True 
08:37:24 <lambdabot>  True
08:38:12 <ChaiTRex> dmwit: I'm willing to restrict it to [Word] -> a, unless that doesn't help.
08:38:31 <ChaiTRex> dmwit: So that they have to deal with a flat list.
08:39:18 <cocreature> dataN: if you’re interested in theorem provers like agda and coq, I recommend that you take a look at the book “software foundations” (which is freely available online). seeing a few examples will probably be a lot more enlightening than trying to understand this otherwise
08:40:34 <dataN> because without them people who cant read my language wont be able to see if the SK combinators are implemented correctly?
08:41:46 <dstolfa> dataN: no, because without a proof, nobody with any rigour will believe you that it's the language semantics that are turing-complete, just that the implementation happens to produce executable code that just happens to work somewhat like a turing machine, but can't really tell because you can't examine it for all possible inputs
08:42:19 <dataN> what proof!?
08:42:29 <ChaiTRex> dataN: Proofs show all possible inputs work properly. Unit tests show that some inputs work properly.
08:42:37 <dataN> apparently its a unit test
08:42:38 <dstolfa> dataN: a proof of the ability to construct a turing machine in your programming language
08:42:42 <dstolfa> dataN: it's not a unit test.
08:42:52 <ChaiTRex> dataN: Some inputs /= all possible inputs.
08:43:00 <mnoonan> ==== <- the rails                   this conversation -> ... 
08:43:13 <cocreature> ChaiTRex: doesn’t something like vector already come pretty close to your goal? you have an API that is fairly similar to lists, you have fusion and for unboxed vectors you have a very thin wrapper around ByteArray#
08:44:28 <glguy> This conversation isn't about Haskell any more. If people want to continue it they could jump in #haskell-in-depth or another channel deemed suitable or /msg
08:44:29 <ChaiTRex> cocreature: I may end up using Vector. I'm trying to have a no-thickness interface with ByteArray#, though.
08:45:06 <ChaiTRex> cocreature: I'll take more of a look at it.
08:46:22 <cocreature> ChaiTRex: I’d first try some benchmarks to see if you actually come up with something faster than vector. if the overhead of Haskell over lets say C is acceptable I would be surprised if the overhead of vector matters
08:46:38 <cocreature> ChaiTRex: and GHC should be able to unbox things so it will actually pass around a ByteArray# in between
08:46:59 <ChaiTRex> cocreature: Ahh, benchmarking is a good plan.
08:47:36 * geekosaur 's brain is being broken by "unit tests are the only conceivable truth" / "if it demonstrates correctness then it must be some kind of unit test"
08:47:43 <madnight> glguy is a pattern guard
08:47:54 <dataN> glguy: I'm reading "Fibrations with Indeterminates: Contextual and Functional Completeness for Polymorphic Lambda Calculi" and have been told that using a proof assistant is required to show that this is relevant to a dsl written in haskell which attempts to preserve the properties of that paper, specifically, which language extensions, if any, should be avoided to best guarantee the language produced is complete.
08:48:44 <dmwit> No, you have not been told that a proof assistant is required.
08:49:16 <eacameron> Does filterSource force the input path to be copied to the store?
08:49:16 <glguy> dataN: OK, hopefully you got what you needed from the conversation.
08:49:22 <dataN> right, i shouldnt have asked why it was suggested at all
08:49:29 <dmwit> Ugh, I'm sorry. I will abide by the recommendation to continue this conversation elsewhere, if at all.
08:49:51 <madnight> https://www.reddit.com/r/haskell/comments/679jd3/purity_of_runst_is_finally_proven/
08:50:33 <dataN> dmwit: its ok, your contributions are appreciated 
08:51:36 <maerwald> madnight: file not found
08:52:31 <ChaiTRex> maerwald: Might be a proxy blocking Reddit or something.
08:53:10 <madnight> damnit, but it exists somewhere .. for mathematician it's enough to know a solution exists
08:53:49 <hyperisco> unless you're constructivist
08:53:59 <glguy> https://iris-project.org/pdfs/2018-popl-runST-final.pdf
08:54:15 <madnight> that's it ty glguy
08:54:44 <dataN> glguy: actually that question is still open
08:57:15 <ChaiTRex> Is there a short name for a function that traverses a [a] applies an a -> Maybe b function and stops traversing and returns the b if it's a Just?
08:57:23 <maerwald> ChaiTRex: no, I mean the link to the paper
08:57:31 <maerwald> glguy: thanks
08:57:33 <ChaiTRex> maerwald: Oh! Sorry.
08:57:55 <byorgey> ChaiTRex: so something like   [a] -> (a -> Maybe b) -> Maybe b ?
08:58:07 <glguy> asum + fmap
08:58:12 <ChaiTRex> byorgey: Yeah, with an extra b for a default return value.
08:58:33 <byorgey> in that case  fromMaybe + asum + fmap
08:58:55 <madnight> % :info fromMaybe
08:58:55 <yahb> madnight: fromMaybe :: a -> Maybe a -> a -- Defined in `Data.Maybe'
08:58:57 <byorgey> no standard function exists that does all that but you can put it together easily out of those pieces
08:59:10 <ChaiTRex> OK, thanks.
08:59:15 <madnight> % :t asum
08:59:15 <yahb> madnight: (Foldable t, Alternative f) => t (f a) -> f a
08:59:18 <glguy> (\f xs -> asum (fmap f xs)) :: (a -> Maybe b) -> [a] -> Maybe b
08:59:20 <ChaiTRex> Oh, I'm just trying to think up a name for a function that does all that.
08:59:29 <ChaiTRex> So, I'll use those to come up with one.
08:59:31 <byorgey> @type \b f -> fromMaybe b . asum . fmap f
08:59:32 <lambdabot> (Functor t, Foldable t) => c -> (a -> Maybe c) -> t a -> c
09:00:03 <kuribas> :t listToMaybe
09:00:04 <lambdabot> [a] -> Maybe a
09:00:12 <glguy> :t alaf First foldMap
09:00:13 <lambdabot> Foldable t => (a -> Maybe b) -> t a -> Maybe b
09:00:19 <ChaiTRex> :t head . mapMaybe
09:00:19 <kuribas> :t \f -> listToMaybe . traverse f
09:00:20 <byorgey> ooh, fancy
09:00:20 <lambdabot> error:
09:00:20 <lambdabot>     • Couldn't match type ‘[a] -> [b]’ with ‘[c]’
09:00:20 <lambdabot>       Expected type: (a -> Maybe b) -> [c]
09:00:20 <lambdabot> Traversable t => (a -> [b]) -> t a -> Maybe (t b)
09:00:27 <byorgey> ChaiTRex: why does it need a name?
09:00:57 <ChaiTRex> byorgey: It'll be a function for, say, comparing two ByteArray#s lexicographically.
09:01:05 <madnight> i like the yahb bot better, since it doesn't require special \bot syntax
09:01:11 <kuribas> :t \f -> listToMaybe . map f
09:01:12 <lambdabot> (a1 -> a2) -> [a1] -> Maybe a2
09:01:38 <byorgey> ChaiTRex: I don't think I understand, how would it help you lexicographically compare two ByteArray#s ?
09:02:00 <kuribas> :t \f -> listToMaybe . mapMaybe f
09:02:01 <lambdabot> (a1 -> Maybe a2) -> [a1] -> Maybe a2
09:02:06 <ChaiTRex> byorgey: It would let me return Just LT or Just GT or Nothing (to recurse).
09:02:20 <ChaiTRex> byorgey: Then the default value would be EQ
09:06:18 <ChaiTRex> byorgey: So, whatever (\ a b -> case ltWord# a b of { 0# -> case gtWord# a b of { 0# -> Nothing; _ -> GT }; _ -> LT }) or the alternative with Word instead of Word#.
09:07:00 <ChaiTRex> Oh, and an EQ for the second argument to whatever.
09:07:25 <ChaiTRex> Sorry, and Justs.
09:08:25 <dataN> :t let loop f b (x:xs) = maybe b (flip (loop f) xs) (f x) in loop
09:08:26 <lambdabot> (t -> Maybe a) -> a -> [t] -> a
09:10:49 <pmade> Does TemplateHaskell interfere with building static binaries in any way?
09:11:01 <dataN> :t let loop f b ys = case ys of [] -> Nothing; (x:xs) -> maybe (Just b) (flip (loop f) xs) (f x) in loop
09:11:03 <lambdabot> (t -> Maybe a) -> a -> [t] -> Maybe a
09:16:16 <eacameron> Anyone know of any good libraries for humanizing units (like bytes -> MB) based on the values.
09:28:50 <danr> eacameron: maybe one of these https://hackage.haskell.org/package/prefix-units https://hackage.haskell.org/package/byteunits
09:30:54 <eacameron> danr: Aha that's exactly what I need thanks! I recalled seeing byteunits but couldn't remember the name
09:31:07 <danr> yw :)
09:32:04 <madnight> pmade: no
09:33:10 <philippD> I'm trying to use more lens stuff. Are there any elegant ways to apply lenses to the state in MonadState or StateT?
09:34:24 <eacameron> philippD: https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Operators.html#v:-37--61-
09:35:15 <philippD> eacameron: Ah, pretty cool
09:35:16 <glguy> philippD: See the stateful column: https://github.com/ekmett/lens/wiki/Operators
09:35:36 <danr> philippD: what eacameron linked to, and zoom is a nice combinator for state: https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Zoom.html#v:zoom
09:35:36 <fsestini> philippD: and if you are on microlens, there’s an entire module for that kinda stuff http://hackage.haskell.org/package/microlens-mtl-0.1.11.1/docs/Lens-Micro-Mtl.html
09:36:03 <fsestini> s/module/package
09:38:50 <pmade> madnight: Thanks.
09:53:36 --- mode: glguy set +v ronin
10:02:43 <philippD> I'm sorry if these questions are basic or are answered somewhere else comprehensively (I couldn't find a resource) but: How do I use a lens with `Maybe` something like `A (Maybe B)` if I have lenses for `A` and `B`.
10:03:29 <glguy> You can't use a lens exactly since there might not be a B there
10:03:38 <glguy> But there's other stuff you can do. What are you trying to do?
10:05:20 <philippD> I have a newtype around a Map and I want to get into the value of that map
10:05:32 <philippD> s/the value/a value/
10:06:26 <philippD> s/newtype/datatype that has lenses created with makeLenses/
10:06:38 <glguy> OK, then you can do:   preview (ix mapKey . bLens)
10:07:12 <glguy> e.g. preview (ix myKey . _2) :: Map Key (Int, Char) -> Maybe Char
10:08:05 <philippD> OK, now another wrinkle: that is actually the state of a `StateT`
10:08:26 <glguy> Then you can use: preuse
10:08:56 <philippD> Damn, that library has everything
10:09:00 <glguy> preuse = use . pre
10:10:02 <madnight> philippD: yup lens lib comes with "Batteries Included" according to edward
10:10:49 <dmwit> philippD: If there is a default value that you want to imagine non-existing keys have, you can look at `non` as well.
10:10:57 <philippD> madnight: looks more like an atomic reactor to me
10:12:23 * ronin
10:12:30 <madnight> philippD: except that atomic reactors are unsafe
10:13:42 <dmwit> e.g. `M.fromList [('a', 7)] ^. at 'a' . non 0` is 7 and `M.fromList [('a', 7)] ^. at 'b' . non 0` is 0.
10:13:50 <philippD> madnight: https://github.com/ekmett/lens/search?l=Haskell&q=unsafe
10:14:37 <philippD> dmwit: that looks like what I want
10:15:31 <madnight> philippD: ok convinced
10:21:31 <ChaiTRex> Is there some easy way to map all subexpressions in a Template Haskell Exp of type Exp to another Exp?
10:22:28 <ChaiTRex> Including if they're in other data types, like Body or something, that are branches off of the starting Exp.
10:23:41 <c_wraith> ChaiTRex, lots of tools for that. stuff like syb(Data.Data) or GHC.Generics
10:24:01 <ChaiTRex> OK, I'll look into both. Thanks.
10:24:58 <c_wraith> they're powerful, but they're not immediately obvious how to use. lots of crazy types.
10:25:51 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
10:25:51 --- topic: set by glguy!~glguy@haskell/developer/glguy on [Thu Aug 02 09:06:51 2018]
10:25:51 --- names: list (clog_ pyrtsa_ hiredman_ monochrom esp32_prog xplat iAmerikan wpcarro gienah_ simony toovs sent1nel_ rschmukler lumm yunhao94 gxt Ariakenom ronin conal nowhere_man tzemanovic tsaka__ perspectival Denommus replay lastmanstanding connrs fragamus sdothum kritzefitz amirpro vikaton Natch Arcaelyx Destol pab daishi nbloomf Jacoby6000_ kefin keepLearning512 khilan chreekat nyberg danso dbmikus__ Jesin oisdk Psybur jao canaria milanj SpinTensor Gurkenglas zfnmxt)
10:25:51 --- names: list (Guest38637 lambda-11235 pio_ Khisanth ByronJohnson valentinbuza al-damiri Digit logzet davr0s rblaze asheshambasta michaelsdunn1 sevensor qxjit[m] hyperisco thunderrd mnoonan mekeor Freechicks telser[m] HarveyPwca jkup emilypi tristanp nocm ddellacosta sykloid tomboy64 alexteves son0p elfets PLPD-Bot escapist carlomagno DasBrain polman jeltsch bo liquid_pascal nuncanada mikulak mizu_no_oto yyy gabiruh eschnett Boarders bbrodriguez humanoyd thy0 Wuzzy anoe)
10:25:51 --- names: list (SenasOzys forgottenone nek0 hydraz fgaz hc odanoburu dddddd philippD juhp jonathanj_ ericsagnes revtintin __monty__ dqd simukis cpape suppi kuribas catsup alex`` buhman ashirase NinjaTrappeur HallaSurvivor zero_byte ersran9 thc202 takuan wonko77 +shak oo_miguel JSharp acidjnk danvet sektor glowpelt armyriad mounty vlatkoB beka gentauro mutantmell Velpoman aijony boj jeeger sssilver bellis__ versatile juri_ ecx R0b0t1 theDon erikd lagothrix banc nckx)
10:25:51 --- names: list (Durbley jokester markus1189 alx741 joof djbeau ArahaelPi swalladge subttle zaiste lucas8 telser cyphase uglyfigurine baweaver jchia wollw moei nurupo ironChicken nitaigao pikhq TommyC mniip yahb lavalike poljar c_wraith Klumben Arguggi rodgzilla sis7 jangsentry10032[ andjjj23 koz_ alanz jw358_ ynyounuo- vaibhavsagar_ bornjre_ asjo` maddybutt wrengr_away ClaudiusMaximus ixian8 Taneb cbarrett Blkt_ fluxi- theorbtwo debugloop dmrd_ shutdown_-h_now Kipras_)
10:25:51 --- names: list (nisstyre cn28h yushyin xacktm deu Zemyla catern PyroLagus joncfoo orekix Novitsh Forkk SolarAquarion jophish verlet64 metalrain mitchellsalad__ m4lvin obfusk hackage TimWolla wagle cheshircat nwf dminuoso machinedgod joeyh M0x8badf00d[m] hiptobecubic liff stiell markmarkmark linduxed zymurgy cic asm89 efskap geal plaeremans gluegadget mattp__ tkr kriztw Profpatsch gre petercommand qzo Clint dysfigured klugez_ Guest36643 haveo noexcept Tspoon__ habbah)
10:25:51 --- names: list (alanz[m] lightandlight[m] CrazedProgrammer thisiswhereitype cdo256[m] milli mtncoder[m] zoltanzuberi[m] chelfi dvgroc[m] sudoreboot[m] Makinit[m] michbad[m] BL[m] noteventime Hanma[m] dubaduba[m] ring0` hsiktas karlguy dnk8n[m] qwqdw[m] loco_joe[m] Hafydd johs yhylord[m] smaller_infinity dotty[m] peschkaj erg typetetris scav_ rootnode SlashLife shiona_ integral lambdabot NB0X-Matt-CA niklasl duncan^ Randy umpc Flonk marble_visions rotaerk MatrixTravelerbo)
10:25:51 --- names: list (nilOps abra0 diginet suzu joeytwiddle nitrix mankyKitty exferenceBot koala_man PHO__ gonz_ ammar2 centril Jon noplamodo quicksilver Saizan milessabin bitemyapp srid davean hexagoxel adarshaj bartavelle dexterfoo blackdog Fylwind- mgttlinger luigy sshine kadoban Sceinox pharaun +greeny__ comboy Liskni_si Argorok_ [exa] carter jtcs brisbin yazmir8azyr dschoepe_ Xandaros apoc +oak dsal moony ziman PoliticsII DDR hoke_t joel135 jtrate ackthet Deewiant srhb)
10:25:51 --- names: list (alek1 bollu ibttis h30 geekosaur cow-orker tureba newhoggy chriswk adamse lukeshu Geekingfrog bjs epta qdickon nuxdie_ pdxleif liste philosau1 uwap ncl28 miklcct Folkol statusbot coot xnyhps ectos beaky orzo runit srk rotty Akii ancarda M2tias sppky Kamuela ajmcmiddlin jzelinskie mstruebing ocharles bgamari trobotham cesardv nullie Zoddo christianpoveda kaychaks feepo_ iskm dmwit monad_cat alp jetpack_joe jrslepak duoi wz1000 lowryder mcspud aksz coeus)
10:25:51 --- names: list (heyj wildsebastian MasseR eagleflo rookie101 raatiniemi nimbleark Jello_Raptor byte512_ statusfailed alexknvl d3lxa oberstein eyenx wamaral otulp jvanbure tripty l\i\a mxf_ bshelden endochelly mgaare_ lstdgtfp Drezil_ Ke adamCS +Logio dpower reptar_ arahael clever mpickering nemesit|znc APic pulec EricZou Nik05 bwe lpsmith mou rntz gsingh93 Unode rzmt fingerzam natim87 paf31 systemfault incomprehensibly trosa AWizzArd rkrishnan @ChanServ wayne tlevine bigs)
10:25:51 --- names: list (stux|RC divVerent nicoulaj tessier valdyn cgoldammer averell Wizek obiwahn infinity0_ thallada sheyll stilgart uptime scroll Ekho m1dnight_ aRkadeFR jackhill rom1504 v0d1ch Ivan__1 canta mupf MTwister int-e Tritlo ds- lyxia bengt_ reda Patternmaster ab9rf Madars isenmann bonz060 geronimogarcia paraseba yumh fnurglewitz sclv jonrh isacl_ azahi scinawa Guest46810 tazjin ambrosia Majiir cyberlard Adluc Niamkik cross hive-mind esph pong phz_ spoonm jrib)
10:25:51 --- names: list (unsymbol Jonno_FTW iphy Entroacceptor mikeplus64 meinside vin-ivar kipd c-rog_ hpc kaol shachaf stvc2 spacebug CindyLinz Amadiro arw mnrmnaugh capisce lispy Ranhir DexterLB mimi_vx lukelau teto hugo makergrl sw4n infty edwardk a3f sariyar sm lc_ jfredett_ haircode_ drdo dan64- spopo ycheng [df] lantti absence greymalkin __name__ tdammers Konehaltia bind treehaqr worch eacameron dukedave tomku|two ephemera_ dfordivam vimto thebnq haroldwu noctux dgpratt NH)
10:25:51 --- names: list (mrm jackieh_ anderson eldritch pta2002 karahobny revprez_atlanta dilinger cgfbee runde rawles aurieeeh nullifidian burp aldum ahihi mceier so redfish64 loc jstolarek Adeon soncodi korans Enigmagic AndreasK Ewout bodie_ pepijndevos omilu peutri UserOO7 mauke mahalex cods Wamanuz2 bdw sujeet nonzen Kneiva mrd benzrf jakehehrlich runeks dyl tsahyt benl23_ +badzergling_ arkeet` elvishjerricco georgew angerman hsribei ryzokuken terrorjack tjbp_ bertschneider_)
10:25:51 --- names: list (typedrat_ carc solarus cocreature acro Xal kqr _flow_ themagician Cerise FransWillem Hijiri howdoi mingc earthy tv hodapp toppler electrocat violeta Tehnix hjozwiak jzono1 fugyk quaestor opqdonut keri jimki Vq revprez sdx23 dave_uy +aleator lag Unhammer bas080 ranberry_ pgiarrusso bradparker pasukon nyaray_ elpfen Dabo Lord_of_Life nopf +kryft SquidDev xpoqp lalbornoz Ckat kmill jzl pwestling shrifbot tinwood revprez_1nz sellout- forell sevanspowell[m])
10:25:51 --- names: list (piluex[m] jibby[m] ahri[m] tfc[m] HDurer[m] johnnyv[m] abhir00p[m] KevinMGranger[m] bmjh[m] aloiscochard[m] jansc[m] Barnabas[m] wuffie[m] mujx[m] roninkaizen[m] lycium[m] flyingclam[m] thejonny[m] xobroll[m] coscomo[m] chreekat[m] whoops[m] morgib[m] braunseb[m] freusque[m] sudoreboot02[m] exarkun rihardsk[m] javjarfer[m] asm[m]1 tmallard[m] George[m] tet[m] k0d3fr34k[m] Noughtmare[m] alexshpilkin[m] IAM[m] ambler[m] Fede[m] acertain jeroenbulters[m])
10:25:51 --- names: list (simonmic[m] intergalacticgot tuxitagnu[m] XiaopongTran[m] killjoyy[m] Grgoire[m] pagoda_5bIvanoPa silvio[m] kalhuzcxv[m] Movablyqueryingl willyh[m] hsw[m] srid[m] seeh[m] etcinit[m] aquarial[m] andresbach[m] psiska[m] fre[m] hylophile[m] sevensidedmarble cryptomann[m] M2mol[m] dlilja[m] chaseroycroft[m] feuerligin[m] jbweston[m] guest3321[m] revskill[m] mimi55555[m] trixon[m] pikachoum[m] cbg[m] vizowl[m] lainon[m] ktaylora[m] ddavidd[m] qffr[m])
10:25:51 --- names: list (silasnordgren[m] danielr[m]1 lixl03[m] Robert[m]1 dial[m] dotglitch[m] traxticlet[m] aquarial[m]1 frump[m] gregoiregeis[m] squallcx[m] trigalero[m] wst[m] kbobyrev[m] lurpam[m] acomar[m] etarnvik[m] petrolifero[m] kedah[m] ocharles[m] niko fryguybob @Sigyn duairc byorgey thaumavorio ctag_ themsay[m] Fairy nklap lachenmayer Tesseraction madnight fionnan Cale RGamma Axman6 Moyst hvr verement huytd bt ma27 @glguy bjobjo ft ekleog colmeka[m] jeeeunevans__ jdt)
10:25:51 --- names: list (barrucadu flebron +Richard[m] survove amiri Saulzar SegFaultAX Partmedia d6e_ nyaomi l8star ljhms leah2 jb55 mantovani tabaqui subleq aminb Squarism cjwelborn maerwald Zialus Solarion nsnc ricky_clarkson atomi mmaruseacph2 Deadhand texasmynsted nnplv bcmiller yarnspinner hongminhee perrier-jouet phadej Athas micro gargawel EvanR Rembane oldnborg qz datajerk awx_ tismith c50a326 dpanth3r swhalen ventonegro Cathy cloudhead Nikotiini DekuNut zaquest m0rphism)
10:25:51 --- names: list (SCHAPiE Cthalupa djanatyn Guest32564 rootmos UnlawfulMonad t36s ruffy_ yrid iron_houzi ptek gothos pacak techieAgnostic atk bydo malthe davl sudden dustinm Zowlyfon xaimus pbodev1 isTofu Tuplanolla atle mathu Jinxit haasn dcoutts chindy troydm domenkozar Charn abbe jchia_1 YellowOnion_ jdnavarro pakettiale jmnk machined1od drewr ashwinik Meanirelli noam insanitea pita saml Jackneill akshayn trebuh dedgrant rafadc_ jix_ kav_ kipras`away amuck ralu_ jkarni)
10:25:51 --- names: list (leothrix toure urdh HalfEatenPie carbolymer etrepum grumble infinisil Zipheir CurryWurst dmiles kwantam ScriptRunner _dga Foritus amf jluttine acowley acarrico justanotheruser drbean klntsky gehmehgeh hntd dibblego kuttifunk gspia jaziz bs bitonic NightA zipp tromp chin-tastic mazzafish ChaiTRex lnostdal veverak ggVGc tombusby wonko7 marvin3 antranigv cjay- DTZUZO bbear cjh` kloeri Hjulle inkbottle [Leary] MindlessDrone MarcelineVQ spoke renzhi_ albel727_)
10:25:51 --- names: list (Guest76759 jonge sqrt2 phreedom dolio drewbarbs_ jml johnw Soft nfd9001 zerokarmaleft raoulb loli pikajude bspar Ferdirand idupree2 seliopou_ stefan-__ implementation jinblack lieven greeneyedfriend[ slugwurths-reven random_tester[m] yajaru[m] vars[m] nille effjay[m] thoradam scav kxra[m] underikar exio4 bbaren Bigcheese_ tolt elijordan ego sigmundv mith[m] schum TuXic[m] thekyriarchy[m] Guest20622 flux kosmikus riatre M[m]28 applecluster[m] Philonous)
10:25:51 --- names: list (shapr apigeon[m] rinor[m] ddowl[m] Ekho[m] rhc[m] arielze[m] knoppaz[m] wtw rann megaTherion rizary GreenSand Jaxan arthurxavierx[m] defanor masaeedu[m] Christophe[m]1)
10:26:53 <ChaiTRex> c_wraith: Does SYB work without Data instances (I think Exp doesn't have one)?
10:27:05 <glguy> No, SYB uses Data instances
10:27:19 <c_wraith> ChaiTRex, Exp definitely has them. I used them over the weekend.
10:27:32 <ChaiTRex> Oh, OK. GHCi is lying to me!
10:27:51 <c_wraith> import Data.Data and then ask it again
10:28:04 <ChaiTRex> Oh, OK.
10:28:37 <ChaiTRex> Ahh, there it is. Thanks.
10:29:01 <MarcelineVQ> the source for th has DeriveDataTypeable  at the top which is a good hint about whether Data is invovled
10:29:13 <MarcelineVQ> though not the most obvious thing to search for
10:29:34 <MarcelineVQ> more simply it's in the instance list in docs  https://hackage.haskell.org/package/template-haskell-2.13.0.0/docs/Language-Haskell-TH-Syntax.html#t:Exp
10:33:32 <ChaiTRex> MarcelineVQ: Ahh, thanks.
10:43:47 <madnight> domenkozar: hey cachix is down, i want to compile my nix package :)
10:51:24 <philippD> OK, I may have chosen a pretty bad place to start to include lens in my code but how would you use lens to access a heterogeneous map? my Map implementation is pretty naive (https://gist.github.com/chisui/480982044578e99811d76bc5f76c56d3). My `sAt` lens doesn't seem to work with preview etc.
10:52:44 <glguy> You mean hAt?
10:53:00 <philippD> yeah
10:53:25 <philippD> I changed the prefix from s to h
10:53:33 <glguy> you need to used 'folded' after hAt to get the ix behavior
10:54:11 <glguy> Well, folded for preview to work, traverse in general
10:54:12 <glguy> http://hackage.haskell.org/package/lens-4.17/docs/src/Control.Lens.At.html#ixAt
10:55:18 <glguy> at is the lens for locations that might or not not be set in a map, ix is the Traversal for locations that are set in a map
10:56:10 --- mode: glguy set +v stondo
10:56:22 --- mode: glguy set -v stondo
10:56:33 <dmwit> That's a pretty subtle distinction.
10:56:35 <stondo> hi all
10:56:53 <dmwit> Does this mean that ix could potentially have multiple results for some key?
10:57:02 <stondo> I'm having some troubles with import System.Random in a stack project
10:58:01 <dmwit> stondo: Maybe send us a link to a pastebin with some error text?
10:58:02 <glguy> dmwit: based on its type, yes. There was some discussion on an issue ticket if it was OK for an instance of Ixed to have the multiple value behavior or not
10:58:05 <stondo> I succefully installed random with stack install random and if I execute stack ghci I can import System.Random
10:58:36 <stondo> the problem arise when I run stack build
10:58:38 <MarcelineVQ> stondo: add random to your dependencies in your *.cabal file
10:58:46 <philippD> so I should create something like `xsHAt k = hAt k . traverse`?
10:58:49 * shapr adds a random dependency
10:58:57 <glguy> philippD: Yeah
10:58:59 <MarcelineVQ> stack is about building projects so you need to specfify the things you need in your project
10:59:38 <philippD> URGH, that type is ugly af
10:59:51 <stondo> MarcelineVQ: it's already there
11:00:12 <MarcelineVQ> alrighty, what's the error then?
11:00:14 <stondo> MarcelineVQ: - random under  build-depends in executable
11:00:41 <glguy> philippD: The type will be: hIx :: HMapConstraints k v => k v -> Traversal' (HMap k) v
11:01:00 <stondo> https://pastebin.com/pvGVuSSL
11:02:27 <stondo> and that is the relevant part of my .cabal: https://pastebin.com/N3t1Zkgg
11:02:54 <dmwit> stondo: Since your library is what imports System.Random, it is what needs to depend on the random package.
11:02:54 <MarcelineVQ> aha, well Ch11 is part of your library not your executable, so random is a library build dependency
11:04:20 <dmwit> (If your executable also imports System.Random, then both must depend on random.)
11:04:35 <stondo> stack complains if I manually modify .cabal file
11:04:42 <monochrom> stondo: IIRC from other people's Q&A, "stack install random" does nothing like what you think.
11:04:47 <glguy> stondo: You have to delete the package.yaml after the cabal file is generated
11:05:21 <glguy> The default template gives you a package.yaml, but it's better to stick with the .cabal file once its generated
11:05:34 <monochrom> Instead, you write in your *.cabal or *.yaml or whatever config file to say you need random, then let stack read it and do it.
11:05:36 <stondo> should I just add random under library -> build-deps ?
11:05:42 <dmwit> Wow, package.yaml can't even capture this? This is a super-common need.
11:05:43 <dmwit> stondo: yep
11:05:57 <monochrom> stack works in mysterious ways.
11:06:23 <MarcelineVQ> dmwit: Yep it can
11:06:32 <dmwit> Good.
11:06:35 <MarcelineVQ> It's just an extra layer of what to someone starting out
11:06:36 <monochrom> Also do not draw analogies between stack and cabal, or cabal and apt-get, or stack and apt-get.
11:06:43 <stondo> I should probably add something to my stack.yaml
11:06:51 <monochrom> They actually have incompatible, rivaling philosophies.
11:07:03 <stondo> and it would work. But what is the correct segment to uncomment?
11:07:07 <MarcelineVQ> there's nothing you need to add to your stack.yaml to import random
11:07:21 <monochrom> Everything you know about one of them, toss it out of the window when you use the other.
11:07:50 <dmwit> But quickly climb out the window and grab it back once it's time to switch again.
11:07:56 <monochrom> heh
11:08:11 <stondo> can someone please give me a short list of what to do to add random as a dependency to my project/module?
11:08:16 <shapr> I like stack for some things, cabal for most other things.
11:08:18 <stondo> I'm confused now :)
11:08:18 * shapr shrugs
11:08:31 <shapr> stondo: do you have a build-depends: line in your cabal file?
11:08:31 <glguy> stondo: Add it to the build-depends section of your *library*
11:08:33 <monochrom> I would think the stack quickstart guide and user guide have this?
11:08:36 <MarcelineVQ> add it under your librariy build-deps like dmwit suggested, if you use it in your exectuable add it there too
11:08:40 <shapr> oh
11:09:03 <stondo> I already did that, but then stack complains
11:09:20 <dmwit> stondo: short list: 1. delete package.yaml 2. modify *.cabal
11:09:21 <glguy> stondo: you have to delete the package.yaml file so it stops overwriting your cabal file
11:09:25 <stondo> someone suggested to delete package.yaml
11:09:49 <stondo> just wanted to make sure there is no other way to solve this
11:09:54 <stondo> thanks everyone
11:10:07 <dmwit> Why do you want to be sure of that?
11:10:21 <dmwit> There are certainly other ways to solve this. Some are very, very difficult.
11:10:21 <monochrom> Because internet strangers are not to be trusted.
11:10:26 <MarcelineVQ> Well the other way to solve it is to add the dependency to your package.yaml instead, but now you'll have to learn about package.yaml files on top of what you're doing
11:10:34 <dmwit> You could write your own compiler and build system, e.g.
11:10:44 <glguy> You could write your own makefile
11:10:59 <stondo> first thing I did was adding random to package.yaml
11:11:02 <monochrom> You could use cabal.
11:11:15 <stondo> seemed quite easy (just added - random) but had no effect
11:11:17 <glguy> monochrom: Don't get your good ideas mixed in with our bad ones
11:12:00 <stondo> deleted package.yaml and modified .cabal file and stack still complains :(
11:12:04 <monochrom> Mixed in, eh? That's exactly what you need cabal new-build for. Backpack mixins. :)
11:12:09 <glguy> stondo: You know we can't see your screen, right?
11:12:37 <stondo> it was a typo, sorry everyone
11:13:17 <stondo> now I have to solve some import problem due to clashing function names, but I think I can handle that
11:13:25 <MarcelineVQ> awesome, gl
11:13:28 <stondo> thanks again everyone for the help
11:15:31 <monochrom> Next April 1st, a generalization of mixin will be implemented in cabal new-build.  Toxin.  >:)
11:15:56 --- mode: glguy set +v koserge
11:16:27 <stondo> I don-t want to annoy you guys, but since I'm kinda new to Haskell and its ecosystem, I'm wondering if it's really not possible to add random dependency by just using package.yaml and stack.yaml
11:17:08 <stondo> just knowing if it's possible, would be nice
11:17:13 <glguy> stondo: MarcelineVQ said it was 6 minutes ago.
11:17:17 <zachk> doesn't stack still require a cabal file? correct me if i'm wrong 
11:17:19 <monochrom> What do the stack guides and docs say?
11:17:37 <MarcelineVQ> it's completely possible
11:17:37 <glguy> zachk: some stack templates use a package.yaml to generate the cabal file
11:17:46 <zachk> ahh didn't know that 
11:18:03 <glguy> zachk: which leads to people accidentally using it
11:18:35 <stondo> do you expert guys prefer to use Cabal only instead of stack?
11:18:56 <monochrom> I am not an expert. Therefore I stick to cabal, even ghc directly.
11:18:59 <stondo> I'm just starting, so it would be nice to know what to learn and what to avoid learning
11:19:03 <nshepperd> I use cabal *and* write my own makefile
11:19:07 <nshepperd> i'm a monster
11:19:09 <shapr> I like cabal new-build, but stack has the advantage that it'll download GHC for you
11:19:25 <shapr> so, depends on whether I'm teaching those new to Haskell
11:19:30 <monochrom> I think of that as a disadvantage.
11:19:35 <monochrom> Even betrayal.
11:19:36 <clever> i use cabal files with nix, and nix will download ghc and build it for you
11:19:52 <clever> nix allows better control over which ghc it downloads, and ensuring its the same one
11:21:06 <monochrom> Then again when I'm teaching students, the first order of business is to do exercises that just require Prelude, not a hundred 3rd-party webapp libraries.
11:21:08 <philippD> nix is also great if you have non haskell dependencies
11:21:21 <MarcelineVQ> nix is amazing if you already know the nix language
11:21:37 <philippD> it's also the most portable buildsystem I have ever seen
11:21:46 <glguy> _deepfire: read your messages
11:21:51 <clever> philippD: yeah, stack and cabal are both unable to manage non-haskell deps
11:22:25 --- mode: sinisalo.freenode.net set +o ChanServ
11:22:30 <shapr> stondo: cabal new-build can use all eight cores on my laptop for building, iirc stack can only build one package on each core
11:22:37 <shapr> but that's not a huge difference
11:22:44 --- mode: glguy set +v nbloomf
11:22:44 <shapr> well, sometimes
11:22:53 <philippD> I run two very differently set up machines and I can just run `nix-build` on any of them and if it works on one it works on the other. CI as well
11:22:54 <nbloomf> I use stack + make
11:23:06 <MarcelineVQ> shapr: afaik there's no intrinsic difference there, it's just a matter of what flags are set up
11:23:16 <clever> philippD: and if you pin the nixpkgs and run hydra, you can even have the builds cached
11:25:02 --- mode: glguy set -v _deepfire
11:25:03 <philippD> clever: I use travis so you don't get caching (which causes builds to take foreeeever)
11:25:04 <MarcelineVQ> stondo: so as you might notice there's not a particular one right way, people are using a variety of tools with different needs and uses, if you have something that works for you it's best to just use it because writing code is more useful/fun than banging tools together
11:25:37 <philippD> clever: are there free hydra services?
11:25:53 <_deepfire> are Typeable instances incurring some unexpected/hidden runtime costs?
11:25:55 <MarcelineVQ> Also afaik the book you're using has a particular way to do things in it so it's probably easiest to follow that
11:26:01 <clever> philippD: none that i know of, but there is cachix, which is a middle-ground
11:26:14 <shapr> stondo: yeah, I suggest you try the options, see what works for you
11:26:15 <clever> philippD: i believe cachix lets travis just push to a binary cache, and then use it later
11:26:41 <monochrom> Typeable instances incur runtime costs, but I wouldn't call them hidden or unexpected. I clearly know and expect them.
11:27:33 <monochrom> But then again someone who doesn't understand computing would think that the halting problem is unsolvable because it incurs hidden and unexpected surprises.
11:27:47 <glguy> _deepfire: Maybe you could be more specific about what cost you're concerned about.
11:28:50 <_deepfire> glguy: I regret asking the question : -)
11:29:12 <philippD> clever: It doesn't look good for a caching service if your website has a cloudflare timeout.
11:29:14 <_deepfire> it was more of an exploratory one, I didn't have anything specific in mind
11:29:36 <clever> philippD: oh, and it happens to be offline right now
11:29:51 <clever> philippD: if you have AWS, nix can also copy things to an S3 bucket
11:29:57 <glguy> _deepfire: OK, it's hard to know what costs you consider unexpected. Using typeable involves a runtime check.
11:30:04 <monochrom> A philosophy channel would be a better place to discuss "hidden". A psychology channel would be a better place to discuss "unexpected".
11:30:12 <philippD> clever: Am poor student :(
11:30:36 <clever> philippD: you can also just run it on your own hardware, got a spare laptop or desktop you can leave on 24/7?
11:31:00 <_deepfire> glguy, only when we consider the type's representation -- by simply consulting the dictionary that is tagging along?
11:31:19 <_deepfire> (that's something I would call expected)
11:32:39 <glguy> typeable doesn't tell us about a type's representation, it is specifically a unique identifier associated with a type that should only match for two types when those two types are the same
11:33:21 <glguy> when two of these identifiers match we assume that means its OK to assume they have the same representation and coerce from one type to the other
11:37:58 <_deepfire> glguy: you mean in the sense that TypeRep only gives you the type's "formula", but not the structure of its values?
11:38:30 <_deepfire> a structured name of the type
11:38:39 <glguy> yeah
11:39:32 <philippD> _deepfire: TypeRep only gives you the information you get using :t in ghci (which is actually powered by Typeable internally as I learned a few days ago)
11:39:55 <_deepfire> cool, thank you!
11:41:15 <philippD> % :set -XAllowAmbiguousTypes
11:41:16 <yahb> philippD: 
11:46:45 <dmwit> philippD: uh?
11:47:01 <dmwit> I don't think :t can be powered by Typeable. Typeable can't do polymorphism, and :t can.
11:48:20 <geekosaur> recent Typeable can
11:48:40 <geekosaur> (new API for that)
11:48:42 <monochrom> _deepfire: Data is the class for value structure
11:49:00 <glguy> geekosaur: Where can I read about that?
11:49:55 <philippD> dmwit: I had a strange case when using AllowAmbiguousTypes where I got an error whith :t that read that there was no `Typeable` instance for the function I was looking at. The ghc codebase is pretty vast so I didn't actually check that it uses Typeable but the internal error message looked like it does.
11:49:58 <geekosaur> hm, looks like it's still incomplete but partially impleented
11:50:53 <monochrom> You can also relax what philippD said and say the spirit is that Typeable's information is similar to :t's
11:50:57 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Typeable is the root page for discussion; see also https://github.com/ghc-proposals/ghc-proposals/pull/16/files/5fe08be0acb77c7a5d21a0ee2160256f41b5b494
11:51:06 <geekosaur> which last shows as closed, so maybe it's in now
11:51:34 <glguy> geekosaur: This stuff is about Typeable working for types of all kinds
11:51:39 <geekosaur> mm, that's just part of it, actually
11:51:41 <glguy> not about working on quantified types
11:52:23 <geekosaur> my understanding is that poilymorphism is intended as a use of that, and is at least partly implemented now
11:52:30 <geekosaur> but may not handle some things yet
11:52:58 <glguy> polymorphism wouldn't work well with the current design that has TypeRep indexed by the type its the rep for
11:52:59 <geekosaur> that is, polymorphism-supporting Typeable is unsafe without this
11:53:32 <monochrom> The future is always brighter.
11:53:47 <mniip> geekosaur, I'm not sure that allows Typeable over quantified types
11:54:36 <machined1od> Hi all. Is it OK to ask question about Stack here?
11:54:50 <monochrom> Yes.
11:55:37 <machined1od> Okay, great. So, I'm wondering if there's a way to set build options for dependencies (and transitive dependencies), and if yes - how? Either the explanation, or the link to the explanation works.
11:56:18 <dsal> I had some list monad confusion last night.  Today I was writing out the same code on a whiteboard and it was really obvious how it worked.  I think the do syntax made it a little confusing
11:56:26 <machined1od> Also - how to set these for the packages manually entered in the 'extra-deps' section in stack.yaml
11:57:41 <monochrom> dsal: You may like the MonadComprehension extension so you can write like [ foo | x <- bar, ... ] for all monads!
11:58:22 <monochrom> In fact have fun with my https://mail.haskell.org/pipermail/haskell-cafe/2018-February/128607.html
11:58:39 <dsal> I do just enough haskell to lose my orientation every time I have something new to write.
11:59:28 <monochrom> OTOH it is actually valuable to grok the do-notation view of [].
12:00:00 <monochrom> My http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.hs may help with that.
12:00:41 <dsal> I get too lost in the "this basically does a thing I want" without thinking about how or why.
12:00:59 <dsal> It feels like magic, but when I actually think about it, it's even easier than magic.  The magic feeling is kind of nice, though.
12:01:14 <exarkun> When I try to use `issue` from the github package (example here - https://github.com/phadej/github/blob/master/samples/Issues/ShowIssue.hs ) passing Text as the first two arguments, I get a type error: Couldn't match expected type ‘GitHub.Data.Name.Name GitHub.Data.Definitions.Owner’ with actual type ‘Text’
12:01:29 <MarcelineVQ> machined1od: last I looked into it no, if they come from a resolver you don't get to choose their options, if you have them as local deps you can do what you like
12:01:40 <exarkun> How does the example get away with passing a literal string (I guess it has something to do with what kind of string it is) and how do I fix this for my Text variables?
12:01:56 <exarkun> How do I make a `GitHub.Data.Name.Name GitHub.Data.Definitions.Owner`?  How do I read the API docs to answer this question for myself?
12:02:07 <monochrom> I'm a scientist. So I think in terms of "someone else sees to the details for me" instead of magic.  And yes, slavery is easier than magic!
12:02:29 <geekosaur> exarkun, OverloadedStrings
12:02:35 <geekosaur> which applies only to string literals
12:03:28 <geekosaur> and its fromString won't help unless you unpack the Text to String. suggest you want an api that creates the type it wants
12:04:10 <exarkun> mkName on http://hackage.haskell.org/package/github-0.19/docs/GitHub-Data-Name.html is the only API I have found so far for making Names and I don't understand it.  `proxy entity`?
12:04:50 <geekosaur> some value that is used only to carry the type
12:05:02 <geekosaur> `Proxy Owner` might work
12:05:10 <MarcelineVQ> machined1od: you can set flags like so https://docs.haskellstack.org/en/stable/yaml_configuration/#flags and apparantly that works for snapshot deps too, which is neat, other things can be set using their own sections  https://docs.haskellstack.org/en/stable/yaml_configuration/#ghc-options
12:06:01 <exarkun> What is `Proxy`?
12:06:34 <MarcelineVQ> The docs read like these settings all apply to snapshot packages now too which is neat but not something I've tried recently
12:06:58 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.11.1.0/Data-Proxy.html
12:07:07 <geekosaur> as I said, it's something that can carry a type with it
12:07:35 <geekosaur> it's using lowercase in the signature because there are other ways to carry it that are sometimes more convenient, but in general you use a Proxy
12:07:56 <philippD> :t typeRep
12:07:57 <lambdabot> forall k (a :: k) (proxy :: k -> *). Typeable a => proxy a -> TypeRep
12:08:05 <selfsymmetric-pa> exarkun: Are you familiar with phantom types? You can't construct them but you can use them to label your datatypes. Proxy carries phantom type information, but it's so general that it can even carry phantoms of multiple kinds. 
12:08:15 <philippD> > typeRep (Proxy :: Proxy Int)
12:08:17 <lambdabot>  Int
12:08:18 <exarkun> I suppose I mostly meant "Where is Proxy?"
12:08:31 <geekosaur> which I answered by pointing you at the haddock for it
12:08:33 <exarkun> I'll look at Data.Proxy, thanks.
12:08:34 <geekosaur> Data.Prox
12:08:35 <geekosaur> er
12:08:36 <ski> @index Proxy
12:08:36 <lambdabot> Data.Proxy, Data.Typeable.Internal, Data.Typeable, Data.Dynamic, Data.Data
12:08:39 <philippD> > typeRep ([] :: [Int])
12:08:41 <lambdabot>  Int
12:08:59 <philippD> > typeRep (Just (1:: Int))
12:09:01 <lambdabot>  Int
12:09:31 <geekosaur> the idea here is to get type safety by having a Name carry information about what kind of Name it is, so you can't use it in the wrong place, without having to duplicate the Name machinery for every possible variety of Name
12:10:27 <philippD> % typeRep (Proxy @Int)
12:10:27 <yahb> philippD: Int
12:16:25 <exarkun> geekosaur: Yes, I saw the doc link, thank you.  I was just trying to clarify my question.
12:19:38 <Athas> Stackage is still just a subset of Hackage, right?  I remember there was debate about whether to allow non-Hackage packages (what a mouthful), but not the conclusion.
12:45:05 <madnight> is there a ghcjs of eval to eval Haskell at runtime?
12:48:08 <dminuoso> madnight: What problem are you trying to solve?
12:49:08 <madnight> dminuoso: i would like to create a simple haskell repl in browser (clientside) without any need for a severside
12:49:34 <madnight> dminuoso: i think this just be doable with ghcjs
12:50:25 <madnight> s/just/should/gI
13:01:19 <madnight> dminuoso: tell me your thoughts
13:18:53 <stondo> some hours ago I asked how to import System.Random in a stack project and someone suggested to delete package.yaml and use .cabal only. I just got it working using package.yaml. It was quite simple. I just added: - random to dependencies in package.yaml under - base >= 4.7 && < 5. Just in case anyone cares or is interested
13:24:36 <aurieeeh> Greetings! I don't quite frequent this channel so I don't know if my question belongs here, but is there a SQL mapping library that doesn't use TemplateHaskell? I know it seems like a weird request, but I'm working on an educational project that's more meant for beginners and Persist is a language on its own lol
13:25:05 <dmj`> madnight: just compile ghc with ghcjs, simple ;) 
13:25:29 <dmj`> aurieeeh: when you say SQL mapping, what do you mean, like SQL code gen?
13:25:48 <madnight> dmj`: "just" is that even possible currently?
13:27:09 <aurieeeh> Kind of like an ORM in object-oriented langs
13:27:36 <aurieeeh> if that's possible w/o TH, thats a given
13:27:50 <dmj`> madnight: ghcjs itself has a library where you can do eval like things. You need to find the haddocks for ghcjs itself
13:28:01 <aurieeeh> if not, guess I'll just include persist
13:28:18 <dmj`> aurieeeh: there's an embedded DSL in haskell that can describe SQL statements in a monadic expression and then you can gen SQL from it
13:28:22 <glguy> stondo: We know that it's possible, it's just better not to have to
13:28:28 <dmj`> @package haskelldb 
13:28:28 <lambdabot> http://hackage.haskell.org/package/haskelldb
13:28:32 <dmj`> aurieeeh: ^
13:28:57 <dmj`> aurieeeh: it will do codegen, but not parsing of SQL itself, for that you'd need a different package 
13:29:11 <aurieeeh> oh wow, thats perfect, thanks
13:30:37 <stondo> glguy: I knew, you know, but I didn't and just thought, perhaps, someone else could be interested. It would be interesting to understand why it's necessary though
13:30:58 <glguy> stondo: And at the time multiple people said it was possible
13:32:07 <stondo> glguy: I'm not arguing against that, but since no one told me how to, I wrote it here. It doesn't seem a problem to me.
13:32:19 <glguy> stondo: No, someone did
13:32:36 <stondo> if someone did, I totally missed it
13:35:00 <stondo> glguy,: just for the sake of precision I scrolled up and read again our previous chat about the topic and still can't see any line mentioning to add - random to dependencies of package.yaml
13:35:12 <madnight> dmj`: link or it didn't happen
13:35:34 <stondo> (which is different from dependecies under executable section)
13:35:37 <glguy> stondo: OK, MarcelineVQ had said it. But I'll grant that there were a lot of messages so you might have missed some
13:37:00 <stondo> anyway, I really didn't want to be polemical. I'm just trying to learn
13:43:14 <dmj`> madnight: I'd ask in #ghcjs
13:47:52 <madnight> dmj`: i dont think it is possible 
13:48:13 <dmj`> madnight: I think it is
13:49:18 <madnight> dmj`: but that doesn't mean anything unless you can provide an example or link :)
13:52:40 <dmj`> madnight: https://github.com/ghcjs/ghcjs/blob/master/ghcjs.cabal#L116
13:55:16 * hackage speculate 0.3.4 - discovery of properties about Haskell functions  http://hackage.haskell.org/package/speculate-0.3.4 (rudymatela)
13:58:51 <madnight> dmj`: that would require to compile ghcjs with ghcjs
14:01:17 * hackage fitspec 0.4.6 - refining property sets for testing Haskell programs  http://hackage.haskell.org/package/fitspec-0.4.6 (rudymatela)
14:09:17 * hackage extrapolate 0.3.2 - generalize counter-examples of test properties  http://hackage.haskell.org/package/extrapolate-0.3.2 (rudymatela)
14:28:04 <monochrom> stondo, glguy: Aw, please don't get into a quarrel. But it's better to maximize your use of *.cabal because it maximizes compatibility with other people because think of those of us who don't use stack.
14:33:38 <MarcelineVQ> a cabal file still materializes :>
14:42:51 <dmj`> is there a lens to view the popCount of a Bool
14:43:03 <dmj`> > True ^. to popCount 
14:43:05 <lambdabot>  1
14:43:11 <dmj`> > True ^. to (popCount  . not)
14:43:13 <lambdabot>  0
14:44:01 <dmj`> It would be really nice if lambdabot let us grep stuff in packages
14:45:40 <__monty__> MarcelineVQ: But you'd have to commit it and deal with possible merge conflicts for it to be of use to non stack users.
14:48:55 <monochrom> MarcelineVQ: Oops, I keep forgetting that.
15:09:07 <Average-user> This (https://logic.pdmi.ras.ru/~smal/files/smal_jass08_slides.pdf) presentation shows an O(n^2) algorithm to detect if two rooted trees are isomorphic, which I have implemented (https://lpaste.net/5481732395575017472). But it also shows an improvement to make it O(n), but I'm struggling to implement this one. Any suggestions? 
15:14:18 <lavalike> try... again?
15:19:36 <domenkozar> madnight: resolved :)
15:20:06 <madnight> domenkozar: domenkozars thought process finally terminated.
15:20:19 <madnight> domenkozar: result?
15:20:42 <domenkozar> will investigate :)
15:22:16 <MarcelineVQ> monochrom: to be fair there's still a point to be made about people that are helping needing to know about both things, especially if the question is vague
15:27:46 * hackage reactive-banana-automation 0.5.1 - home (etc) automation using reactive-banana  http://hackage.haskell.org/package/reactive-banana-automation-0.5.1 (JoeyHess)
15:36:19 <realfascism> uh
15:36:26 <realfascism> anyone here using happstack?
15:36:30 <realfascism> seems pretty nice
15:51:31 <madnight> realfascism: this name includes stack, happnix sounds better to me
15:55:10 <droplet> I've just had the compile error 'stimes' is not a (visible) method of class 'Semigroup' in ghc 8.4.3 and 8.6.1 on travis ci, but not with 8.0.2 or 8.2.2 and I'm very confused since it certainly looks like a visible member of the class to me...
15:56:25 <droplet> Even more confusingly, it seems to work fine for me on 8.4.3
15:58:30 <droplet> Any help/suggestions?
15:58:47 <c_wraith> droplet, one idea..  how are you importing it?
16:00:53 <droplet> c_wraith, #if __GLASGOW_HASKELL__ < 803; import Data.Semigroup; #endif
16:01:47 <c_wraith> that... looks a lot like you aren't importing the module at all in ghc 8.4+
16:02:30 <c_wraith> does Prelude re-export it in 8.4?
16:02:51 <glguy> Probably not stimes
16:03:09 <c_wraith> yeah, that's my guess.
16:03:20 <droplet> Ah yup that's it
16:03:51 <c_wraith> when the error message says (visible), I expect the problem to be imports.
16:04:00 --- mode: sinisalo.freenode.net set +o ChanServ
16:04:15 <droplet> Doesn't it always say visible if you define a method not in the class?
16:04:39 <c_wraith> I might always expect it to be an import problem, whether it is or not. :)
16:04:44 <droplet> But yeah that was it, prelude exports Semigroup but not stimes, thanks!
16:04:56 <droplet> lol fair enough
16:09:40 <xacktm> what library do people use for haskell IRC bots?  
16:09:51 <xacktm> or do you "Roll your own"?
16:10:19 <hpc> usually it's a roll your own thing, as a learning exercise
16:10:52 <xacktm> aye
16:12:33 <ab9rf> writing an IRC client is a good exercise
16:12:35 <ab9rf> you should try it
16:14:03 <xacktm> yeah there's fun in refactoring too
16:17:34 <dmwit> xacktm: There's a pretty featureful IRC client called glirc written in Haskell (by glguy here on #haskell). You could look at its dependencies to get some ideas.
16:17:43 <dmwit> The main one that looks relevant is this one:
16:17:46 <dmwit> ?hackage irc-core
16:17:46 <lambdabot> http://hackage.haskell.org/package/irc-core
16:18:11 <xacktm> oh yeah good point
16:25:24 <madnight> would also be nice if hackage could summarize which extensions are used
16:29:53 <matzy_> i've been programming around 4 years now and I've learned C, obj-c, and web scripting languages like js and php, but I'm really missing a "swiss army knife" language and also want to learn FP, so i'm deciding between haskell and common lisp. I've already done my homework, a ton of reading on both, just seeing if anyone had a personal opinion they'd share that might help me decide?
16:30:13 <johnw> since you asked in #haskell, choose haskell
16:30:37 <dmwit> madnight: There's a spot for it in cabal files, but many packages don't set it.
16:31:00 <dmwit> I don't know off the top of my head of a package that does set that; if somebody else does, it might be interesting to see whether Hackage actually shows that information somewhere easy to spot.
16:31:26 <dmwit> matzy_: I also think you should choose Haskell, but not because you're in #haskell.
16:31:37 <dmwit> However, I suspect my opinion is strongly correlated with the fact that *I* am in #haskell.
16:31:48 <madnight> matzy_: i think you should try both, at least some simple examples if you are unsure
16:31:53 <dmwit> Which one causes the other is a question for the philosophers.
16:32:12 <matzy_> My specific needs (and why I think both haskell and cl are good) are: 1. general scripting 2. able to write a REST api with mature libraries (or stdlibs) 3. C FFI 4. Ability to write a simple native GUI program if ever needed
16:32:22 <madnight> matzy_: my problem is (and will probably always be) the many parenthesis of lisp
16:33:01 <matzy_> madnight: I actually have already!  Both were much harder to get going in than scheme, and haskell was the harder of the two :)
16:34:45 <madnight> matzy_: do you have any things that you like in particular in languages that you already know?
16:34:56 <matzy_> Lisp's syntax makes sense to me. It's very simple and the parens disappeared for me pretty quick after learning some racket (scheme) and writing my emacs config. But CL is harder than scheme and I wasn't able to just start coding like I could in racket. Haskell I can barely do anything, I clearly will need to spend a lot of time reading and learning before writing even a small script
16:36:45 <matzy_> I'm drawn to CL bc I love emacs and I hear rave reviews about slime and the dev environment, but then again, I'm thinking to myself, "If I choose haskell the environment won't matter as much because I won't have massive bugs to try and hunt down"
16:36:52 <shapr> matzy_: you have a great and thrilling journey ahead of you!
16:36:53 <madnight> matzy_: hmm emacs and lisp have some kind of symbiosis, people who like emacs better than vim tend to like lisp better
16:37:19 <shapr> matzy_: my CL friend only uses emacs because of slime
16:37:23 <shapr> I just like emacs
16:37:23 <madnight> matzy_: just my personal opinion, i cannot proof that by any means
16:37:29 <matzy_> dmwit: what specifically do you like better? or you think makes it better to learn?
16:37:31 <johnw> does anyone know if cabal2nix can support backpack?
16:38:13 <matzy_> shapr: so you use emacs for haskell?  how is the dev environment?  that i haven't read much about honestly
16:38:18 <shapr> matzy_: are you in Atlanta? if yes, come to my weekly meetups!
16:38:28 <shapr> matzy_: I think it's great, and getting better
16:38:44 <shapr> Heard of language server protocol?
16:38:45 <matzy_> shapr: sadly no, just moved from miami to chicago (freezing my ass off now!)
16:38:54 <matzy_> yes it's incredible
16:39:11 <shapr> alanz is doing awesome stuff with haskell+lsp in emacs
16:39:17 <matzy_> i have the best C IDE i've ever had in my life, right inside emacs right now
16:39:29 <shapr> the base haskell mode is nice, has good support for repl in another buffer, and there's a nice cabal mode
16:39:37 <shapr> you using cquery?
16:39:45 <matzy_> the cmake people did an amazing job.  is the haskell lsp good?
16:39:56 <shapr> I couldn't figure out how to get cquery to run on a VM and talk to my emacs on the host
16:40:09 <matzy_> sorry cquery
16:40:29 <shapr> I've not done much C dev in the past coupla decades
16:40:34 <matzy_> yes i am.  it's absolutely incredible.  i'm still shocked at how good it is.  it's the best language server implementation thus far
16:40:54 <shapr> too bad all of my C dev happens inside VM or docker container where everything is hard to reach
16:41:35 <matzy_> all you have to do is pass the dirs to clang, and you can do that in your init.el file through (clang-additional-arguments) function (or something like that)
16:41:45 <matzy_> for the cquery-lsp
16:42:07 <matzy_> you can tell it additional compiler flags to pass.  that might help your directory problem.  anyway, back to my question
16:42:15 <shapr> the haskell-lsp mode is not done, but it has a bunch of cool features
16:42:29 <shapr> I've used it to show off the Haskell Refactoring browser for lightning talks
16:42:56 <matzy_> is it usable? do you use it for your coding or do you switch on and off still?
16:42:57 <shapr> but then I go back to mostly stock haskell-mode
16:43:11 <shapr> it's usable, but very much in flux
16:43:23 <matzy_> ah ok. awesome, thanks
16:43:25 <shapr> and my day job is Go / Python / C++ / C
16:43:37 <shapr> with small bits of C#
16:43:50 * ski . o O ( Liskov Substitution Principle )
16:44:01 <shapr> heh, sure :-)
16:44:11 <matzy_> i'd really check out cquery, the lsp mode is amazing. well worth the setup time, i assure you
16:44:16 <shapr> ski: https://en.wikipedia.org/wiki/Language_Server_Protocol
16:44:35 <shapr> matzy_: I can only build my C source on a VM, but emacs runs on the host, is that supported?
16:44:47 <ski> shapr : yah, just random reinterpretation :)
16:44:49 <ab9rf> hrm, stack is being mean to me
16:45:04 <madnight> my way: Java -> C++/inline asm -> JavaScript / CoffeeScript / Python -> Haskell
16:45:32 <matzy_> shapr: hmm that is a little weird, i'm guessing it's compiling inside the vm....i'd have to think
16:45:49 <ab9rf> your way to what?
16:45:51 <shapr> I spent a few hours on that a month or two ago, and gave up
16:46:11 <ab9rf> now all i can think of is "Das Weg zum Lesen!"
16:46:27 <matzy_> deutsch?
16:46:28 <ab9rf> or whatever the hell that stupid textbook was called
16:46:39 <shapr> matzy_: talar du svensk? :-P
16:46:53 <ab9rf> i can't remember if that was high school or college
16:47:03 <ab9rf> or even if i'm remembering it correctly
16:47:06 <matzy_> nej :)
16:47:07 <ab9rf> high school was 30 years ago
16:47:12 <shapr> tyvärr
16:47:41 <matzy_> nur deutsch
16:48:06 <shapr> matzy_: anyway, if you have issues with haskell-mode, I can help some, and there's also #haskell-emacs
16:48:08 <ab9rf> ick
16:48:30 <matzy_> so is the haskell repl good? is it used like with lisps? or is this more like C, write code, compile, read compiler errors, fix, rinse and repeat
16:48:36 <ab9rf> madnight: so, what is this "way" you're talking about?
16:48:44 <ab9rf> matzy_: ghci has its purposes.
16:49:06 <matzy_> i guess i'm trying to get a picture of what the dev workflow is like
16:49:08 <shapr> > map (+) [1..9]
16:49:10 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
16:49:31 <hpc> because haskell is static-typed, ghci gets a lot of use as a combination typechecker / debugger
16:49:31 <ab9rf> lambdabot has some curious Show instnaces
16:49:35 <madnight> matzy_: ghci is good, i use it always for :r devel
16:49:36 <shapr> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 15  fibs
16:49:38 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610]
16:49:41 <hpc> make some edits, reload the file
16:49:55 <hpc> see if it typechecks, see if some functions have the expected results for some inputs
16:49:56 <shapr> nowadays you can make new datatypes and that kind of thing in ghci
16:49:58 <hpc> and repeat
16:49:59 <ab9rf> i've done what hpc talks about quite a lot too, especially when i'm trying to figure out types
16:50:12 <shapr> ab9rf: do you use type holes?
16:50:17 <ab9rf> shapr: occasionally
16:50:42 <madnight> ab9rf: you can see the function signature, that's enough documentation isn't it?
16:50:45 <matzy_> would you feel comfortable writing a REST API in haskell?  are the routing libraries and stuff mature enough?
16:51:07 <shapr> :t let fibs = 1 : 1 : zipWith (+) fibs _ in take 15 fibs
16:51:07 <lambdabot> error:
16:51:08 <lambdabot>     • Found hole: _ :: [a1]
16:51:08 <lambdabot>       Where: ‘a1’ is a rigid type variable bound by
16:51:11 <ab9rf> once i have the "basic shape" of the code down enough to start writing unit tests, the process tends to change to a more "traditional" code/compile/fix
16:51:17 <hpc> matzy_: definitely
16:51:23 <matzy_> i'm guessing that might be a dumb question, but just checking cause that's one big thing i will need. i'm sick of php
16:51:24 <shapr> matzy_: yeah, I've built moderate sized websites in Haskell, with twitter bootstrap and all that
16:51:33 <matzy_> and node is bullshit
16:51:34 <hpc> matzy_: any minor weaknesses it has over other languages it would have in the rest libraries
16:51:37 <ab9rf> matzy_: writing RESTful apis in haskell is almost sleep-inducingly easy
16:51:51 <shapr> matzy_: here's a small simple website: https://github.com/shapr/sporkle/blob/master/app/Main.hs
16:51:54 <hpc> matzy_: are made up and then some by its ability to do the stuff you tell it to
16:52:27 <ab9rf> i used to have a modest sized website built with haskell, but i misplaced its hard drive
16:52:30 <shapr> that includes writing and reading the datatypes to/from sqlite
16:52:56 <madnight> matzy_: php is the second worst language, just behind go ^^
16:53:16 <MarcelineVQ> worst isn't a particularly descriptive word
16:53:19 <matzy_> shapr: thanks for the example. man, it's like, so simple to read, yet so hard to understand
16:53:31 <shapr> yeah, I'd say go and php have their good points, but they are often used outside of those good points
16:53:48 <gentauro> > 7. -1-Array Indexing
16:53:50 <lambdabot>  error:
16:53:50 <lambdabot>      Precedence parsing error
16:53:50 <lambdabot>          cannot mix ‘.’ [infixr 9] and prefix `-' [infixl 6] in the same infi...
16:53:50 <gentauro> In Julia programming, the first element of an array is denoted by [1] instead of [0]. This form of indexing is quite simple to handle especially when dealing with large data projects.
16:54:05 <hpc> if php was used /exclusively/ for templating, maybe it would be a decent DSL
16:54:14 <gentauro> "7. -1-Array IndexingIn Julia programming, the first element of an array is denoted by [1] instead of [0]. This form of indexing is quite simple to handle especially when dealing with large data projects."
16:54:18 <gentauro> ein?
16:54:21 <matzy_> where does this do the routing?
16:54:34 <gentauro> that's the worst excuse ever to state an 1-index array :S
16:54:36 <matzy_> nvm nvm
16:54:37 <shapr> matzy_: https://github.com/shapr/sporkle/blob/master/app/Main.hs#L68
16:54:38 <gentauro> (julia article)
16:54:51 <shapr> matzy_: it's http method then url
16:55:16 * ski . o O ( "PHP: a fractal of bad design" <https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/> )
16:55:39 <shapr> matzy_: there are heavier frameworks that do more checking, but scotty/spock are much simpler frameworks.
16:56:07 <matzy_> yeah i see the get and posts now. it's weird, i've never seen a language that doesn't visually scope the code
16:56:07 <shapr> matzy_: for extra entertainment, that file includes the typesafe HTML for the website :-P
16:56:42 <matzy_> what is "typesafe" HTML?
16:57:00 <shapr> means your HTML *will* be correct, or the compiler will stop you.
16:57:11 <matzy_> oh wow, that's cool!
16:57:21 <matzy_> does it use the w3c validator?
16:57:37 <hpc> with types!
16:57:38 <shapr> no, the legal combinations are expressed in the type system
16:57:48 * hackage sv-core 0.2.2 - Encode and decode separated values (CSV, PSV, ...)  http://hackage.haskell.org/package/sv-core-0.2.2 (qfpl)
16:58:32 <shapr> that is, the library author encoded what was legal in the library, and the compiler will reject combinations that do not match what was encoded.
16:58:36 <matzy_> wow so it parses and then validates the html itself??
16:58:46 <matzy_> that's crazy
16:59:10 <shapr> it generates the html
16:59:26 <shapr> matzy_: here's my form: https://github.com/shapr/sporkle/blob/master/app/Main.hs#L79
16:59:43 <madnight> matzy_: jup you can write typesafe html and also typesafe css
16:59:52 <hpc> matzy_: the library is /only/ capable of generating valid html, is how it works
17:00:00 <hpc> no validation, it's correct by construction :D
17:00:22 <matzy_> wow that post is ridiculously easy to read!
17:00:41 <matzy_> first time i've understood multiple lines of haskell before
17:01:15 <madnight> matzy_: http://fvisser.nl/clay/
17:04:16 <matzy_> madnight: wow that is really nice. simple and readable too
17:04:43 <matzy_> so is haskell more popular than CL? will haskell have better/more popular/mature libraries for stuff like this than CL?
17:05:03 <madnight> matzy_: yes
17:05:25 <shapr> matzy_: I also think Common Lisp is worth learning, I suggest you spend a few hours with both Haskell and Common Lisp and see which one fits your brain best.
17:05:35 <shapr> matzy_: I think CL has fewer paying jobs, I'm not sure about the libraries.
17:05:41 <shapr> Last I heard, ITA Software was the only big Common Lisp employer, not sure if that's still true after Google bought them
17:06:04 <shapr> matzy_: I bet you'll get a higher quality answer about CL from a CL group :-)
17:06:18 <matzy_> very true, i appreciate your input though!
17:06:27 <madnight> matzy_: and haskell has a very good community support e.g. this is one of the largest channels on freenode
17:06:45 <shapr> matzy_: if you decide to do CL for the next five or six years, remember to come back and learn Haskell too!
17:07:16 <shapr> I'm learning verilog myself ... soon I'll be using http://www.clash-lang.org/
17:07:17 <matzy_> the libraries thing will be a big deal to me. after learning a lot of languages, i need something that fills that void between C and the web scripting languages, but isn't too niche to not do stuff when i need to get things done
17:07:47 <matzy_> racket is still a little too new i feel, i wouldn't write an API in it yet
17:08:00 <shapr> I've always thought of racket as a language building language.
17:08:25 <matzy_> that's mostly what it's used for. which sucks, cause it's the easiest lisp to pick up
17:08:27 <matzy_> IMO
17:09:31 <shapr> matzy_: https://github.com/lexi-lambda/hackett ?
17:10:35 <matzy_> people never cease to amaze me 
17:10:41 <shapr> matzy_: I'd suggest starting with http://www.cis.upenn.edu/~cis194/spring13/lectures.html if you want to learn Haskell
17:11:09 <shapr> if you like it, there are books you may want to purchase, or you can just hang out here and ask lots of questions
17:11:55 <matzy_> is it fun to write in? one thing i did find about racket is that it was really fun to write in, although kind of a mindfuck at times
17:12:05 <matzy_> i imagine haskell will be a mindfuck * 1000
17:12:07 <shapr> Haskell is SUPER fun
17:12:16 <madnight> or the dreaded beginner guide http://learnyouahaskell.com/
17:12:19 <shapr> and yeah, you gotta rewire your brain to write decent code
17:12:35 <matzy_> that's what i'm worried about tbh
17:12:49 <matzy_> i had enough time wrapping my head around enough functional concepts to use racket
17:12:57 <matzy_> *i had a hard enough time
17:13:43 <shapr> matzy_: it's worth it
17:13:57 <matzy_> shapr: i was just about to ask if it was worth it hahah
17:14:10 <shapr> TOTALLY worth it
17:14:20 <matzy_> why is that?
17:14:37 <matzy_> personal opinions fine, i'm curious to hear
17:14:38 <shapr> you get better at all your other programming languages!
17:14:44 <shapr> because equational reasoning is easier
17:14:44 <madnight> matzy_: maybe the next time you learn fp concepts stay connected to this channel and shapr will answer all your questions
17:14:54 <shapr> could happen!
17:14:57 <matzy_> lol
17:17:57 <matzy_> i'm trying to write a script that will roll through all the .h files in a given directory and scan each line of the file, inserting a specific header before it if it is a definition for a matching function, a list of which are provided in an input file. i couldn't figure it out in CL and am currently hacking away in racket.  Is that something you could do with haskell, or is stuff like that really hard?
17:18:49 <matzy_> so you provide the script 1. the dir to search and 2. a file with a list of functions and it searches all the .h files for that function defintion and inserts some text before it if it finds it
17:18:50 <madnight> matzy_: that's simple stuff
17:19:22 <matzy_> so simple i could figure it out? ;-p
17:19:28 <matzy_> cause i haven't yet in racket lol
17:19:42 <matzy_> i dread setting up a whole js env just to write es6 code 
17:20:01 <matzy_> C sucks for strings. see where i'm at?
17:21:58 <matzy_> i want to write less far less php than i currently have to (and who does filesystem scripting in php anyways), solving this in c++ would be like cutting your grass with napalm, and...well that's about it for languages I know
17:24:56 <madnight> matzy_: and you have to know what a monad and "such things" exactly are, you can use it without that knowledge
17:24:56 <MarcelineVQ> don't have to?
17:24:57 <madnight> MarcelineVQ: yup
17:24:57 <madnight> sorry its a bit late here
17:27:26 <MarcelineVQ> no time like the present to find out
17:27:56 <matzy_> i've played around in both, but to actually get stuff done i need to commit to really diving into one i feel
17:28:16 <matzy_> madnight: gotcha.  i knew it wasn't going to be that easy lol
17:31:51 <matzy_> i didnt realize haskell was much more popular than CL and had better libraries. that's a huge deal
17:32:34 <madnight> % import System.Directory
17:32:34 <yahb> madnight: 
17:32:45 <madnight> % getCurrentDirectory
17:32:46 <yahb> madnight: "/var/lib/xsbot/sandbox/root/data"
17:34:56 <matzy_> does haskell have a C FFI?
17:35:03 <shapr> yup
17:35:08 <madnight> matzy_: yes, sir
17:35:33 <MarcelineVQ> % writeFile "merrrrrrj.txt" "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
17:35:33 <yahb> MarcelineVQ: *** Exception: merrrrrrj.txt: hClose: resource exhausted (No space left on device)
17:35:35 <matzy_> beautiful
17:35:38 <MarcelineVQ> aww :>
17:35:51 <madnight> % getDirectoryContents "/var/lib/xsbot/sandbox/root/data"
17:35:51 <yahb> madnight: [".","..","foo2","ghci","merrrrrrj.txt","newfile","foo"]
17:36:20 <madnight> % getCurrentDirectory >>= getDirectoryContents
17:36:20 <yahb> madnight: [".","..","foo2","ghci","merrrrrrj.txt","newfile","foo"]
17:36:41 <matzy_> does it have arrays and objects? or does it have lists? 
17:37:26 <shapr> @where cis194
17:37:27 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
17:37:37 <shapr> @where lyah
17:37:37 <lambdabot> http://www.learnyouahaskell.com/
17:37:53 <madnight> matzy_: both
17:37:56 <shapr> matzy_: read things, try things, ask questions!
17:38:11 <madnight> matzy_: lists and arrays
17:38:26 <ski> matzy_ : by "objects" you mean ?
17:38:39 <matzy_> ok awesome, i was curious
17:38:44 <MarcelineVQ> https://en.wikibooks.org/wiki/Haskell/FFI
17:38:59 <matzy_> i guess i'll do the cis 194 class then
17:39:19 <ski> > listArray (0,9) [n^2 | n <- [0 .. 9]]
17:39:21 <lambdabot>  array (0,9) [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81)]
17:39:31 <MarcelineVQ> There's an error in week 2 or 3 or so that'll probably stop you, be sure to check back in here when it does
17:39:32 <ski> that's an (immutable) array
17:39:40 <matzy_> i'll miss out on slime, but maybe i won't have many bugs to catch :)
17:39:59 <matzy_> ski: ohhh ok
17:40:05 <matzy_> an array of lists?
17:40:11 * ski has heard good things about SLIME
17:40:18 <ski> nah, an array of integers
17:40:30 <matzy_> (0,0) is an int?
17:40:36 <matzy_> oh, that's the index
17:40:38 <matzy_> nvm
17:40:57 <ski> `listArray' takes a list to initialize the array. the list here acts like an initializer loop in an imperative language would
17:40:58 <matzy_> still thinking in lisp
17:41:17 <MarcelineVQ> oh week 7 appearantly
17:42:16 <ski> there is no special syntax for arrays, however there is special implementation support (to typically get adjacent elements, O(1) (modulo caches, &c.) element access)
17:42:45 <ski> so, if you show the value of a(n immutable) array, it
17:42:51 <madnight> matzy_: https://lpaste.net/1935622549194932224 https://lpaste.net/4125355000211701760
17:43:04 <madnight> matzy_: direct comparison
17:43:21 <ski> 'll not divulge implementation details, but rather show a call to the library function `array' which would compute to an equal array
17:44:02 <matzy_> ah ok
17:44:15 <matzy_> makes sense!
17:44:27 <ski> (and it so happens that the function `array' takes an association list of index-element pairs/associations. `listArray' is a wrapper around this that expects a list of elements only, given in ascending index order)
17:45:23 <ski> .. and array indices doesn't have to be natural numbers (iow non-negative integers), or even integers
17:46:09 <matzy_> ah, that's kinda remniscient of lua's tables
17:46:30 <ski> first, you can use tuples as indices, for multi-dimensional arrays. but you can also declare you own types (when appropriate) as instances of the `Ix' class, which enables use of values of that type as array indices
17:46:57 <matzy_> wow
17:47:07 <ski> (`Ix' basically tells how to map the values of the type, plus array bounds, to a contiguous sequence of integers)
17:47:16 * hackage unix-compat 0.5.1 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.5.1 (JacobStanley)
17:47:24 <matzy_> i could definitely see where that is useful to be honest
17:48:09 <matzy_> kind of esoteric, but really powerful
17:48:20 <ski> it's not incredibly fancy. just pointing out that you don't have to encode you indices yourself as integers
17:48:54 <matzy_> ski: oh so is that the best way to imitate a javascript object then?
17:49:13 <matzy_> like if you were working with json?
17:50:00 <ski> (e.g. i don't recall whether you can use (immutable) array values themselves as array indices. i suspect not, out-of-the-box (you could probably make an `Ix' instance, i suspect, though). that would qualify as a bit more fancy, imho)
17:50:53 <ski> matzy_ : hm, i suspect that most often you'd like to use records (which are thin syntactic sugar over plain algebraic data types), for that
17:51:55 <ski> record (as well as tuples) have a definite number of fields (components), which can have different types
17:52:30 <ski> lists, and arrays, and finite-maps, hashmaps, and similar, are homogenous, all elements must have the same type
17:52:31 <matzy_> ah right, you probably can't have just a generic object
17:52:41 <ski> well, it depends
17:53:12 <ski> sometimes the record-of-methods idea of an object is useful in Haskell as well
17:53:18 <matzy_> in general i mean. in JS you can kind of build your objects as you go along, in haskell you'll need to visualize that data up front i'm assuming
17:53:33 <matzy_> or is that an incorrect assumption?
17:53:57 <ab9rf> you nmormally figure out what your data is
17:53:59 <ab9rf> first
17:55:00 <ski> if you change your data type definition, the compiler will usually yell at the places you need to adapt in order to work with the new version of the type
17:55:27 <ski> so it's not so bad to change one's basic types dozens of times
17:55:33 <matzy_> so i'd better get pretty used to dealing with types then, right?
17:55:50 <ski> yea :)
17:55:50 <ab9rf> and a lot of the time your functions were sufficiently polymorphic that nothing (much) changes
17:56:08 <matzy_> is that really what cuts down on all the bugs? just super strict typing?
17:56:13 <ab9rf> yes
17:56:17 <matzy_> and a PITA compiler?
17:56:32 <matzy_> wow that's crazy
17:56:36 <ab9rf> and the fact that the type system allows for a whole hell of a lot more code reuse
17:56:37 <ski> well, there's something called typeful programming, where one actively tries to use strict typing to one's advantage
17:56:38 <MarcelineVQ> Not all the bugs but way more than a person expects
17:57:03 <ski> in order to try to minimize situations where errors would not manifest as type errors
17:58:01 <matzy_> got it. you guys are great, thanks so much for all the help
17:58:03 <MarcelineVQ> once up and running the first barrier a person runs into is reading the painfully precise error messages :>
17:58:12 <matzy_> lol
17:58:21 <ab9rf> heh
17:58:27 <ab9rf> "What the hell is an occurs check anyway?"
17:58:28 <matzy_> i read somewhere you shouldn't install it through the website. is that true>
17:58:31 <matzy_> *?
17:58:40 <ski> the simplest example of that is like, instead of using a `String' (or whatever), you make a new data type which is only a wrapper around a single `String'
17:58:40 <ab9rf> install what?
17:58:52 <ab9rf> i usually assign a newtype for anything that is going to move around as data, and if i need to change the implementation i just change it at that point, and only the code that has to peer through that newtype is affected
17:59:11 <matzy_> the language itself
17:59:11 <matzy_>  
17:59:28 <ab9rf> there's probably no harm in having the platform installed
17:59:58 <matzy_> like you should use system packages instead, but i wonder if that's more of a linux thing. i just broke my linux laptop and am stuck on a '14 mbp now :(
17:59:59 <ski> say you call this new type `Identifier' (if this is supposed to represent an identifier in a language implementation, e.g.), then now you can't accidentally pass a `String' where an `Identifier' is expected, or vice versa
18:00:13 <ab9rf> i actually don't have the platform installed on my laptop, and do everything through stack, but that's mostly because i got tired of different versions of mingw arguing with one another
18:00:26 <matzy_> why different versions?
18:00:30 <ab9rf> it's probably much less of a problem on linux
18:00:42 <matzy_> i was on linux....now mac 
18:00:57 <ab9rf> matzy_: becaues i'm on windows and the platform uses one version of mingw, but i have other stuff installed that uses other versions of mingw, and they fight with one another sometimes
18:01:17 <ab9rf> mingw is a POSIX emulation environment for windows
18:01:23 <matzy_> ohhh mingw version clashes, i thought you meant haskell version clashes
18:01:46 <matzy_> i was wondering why you had multiple versions running. if there was like a python 2/3 in the haskell land
18:01:55 <ab9rf> so i ended up uninstalling the platform and doing everythig through stack, which uses prepackaged compilers installed in an undisclosed location
18:02:10 <ab9rf> and which do not fight with anything else on the system
18:02:37 <ab9rf> you probably do want to avoid installing packages from hackage/stackage globally
18:02:59 <matzy_> is that just user submitted repos?
18:03:20 <ab9rf> it's fairly common for people to have multiple haskell compilers installed (or at least present) on the same machine
18:03:49 <matzy_> ah so there is some versioning issues then?  package compatibility across versions?  or breaking api changes?
18:03:53 <ab9rf> i have one project around her that is locked to GHC 7.4 for some reason, so if i work on that project it uses a GHC 7.4 toolset off of stack
18:04:08 <ab9rf> but that runs in its own sandbox and doesn't mess with any other sandbox
18:04:43 <ab9rf> matzy_: there is a thing called "cabal hell"
18:05:17 <ab9rf> which you avoid by never installing anything gobally, but instead using separate sandboxes for each project
18:05:24 <matzy_> is cabal the package manager?
18:06:25 <ab9rf> cabal is a packager, but it can also be used to install built packages
18:07:41 <ab9rf> i just created a new project on my computer a bit ago
18:07:54 <sclv> the mingw version installed with the platform shouldn't impact anything else on the system
18:07:57 <sclv> it doesn't need to be in the path
18:08:13 <ab9rf> after creating the folders, i did "stack setup" which proceeded to obtain a current compiler image from stack and "install" it in a directory in my user folders
18:10:22 <ab9rf> sclv: i used to have issues with it on windows. i haven't actually had platform installed for some time though, i just use stack to invoke the compiler and it uses sandboxed compilers
18:10:33 <sclv> right
18:10:51 <ab9rf> sclv: this also facilitates situations where i need a sandboxed compilr with some weird configuration for some reason
18:10:52 <sclv> i'm just noting that in general mingw shouldn't have those issues
18:11:02 <ab9rf> sclv: "shouldn't" :)
18:11:13 <sclv> well i haven't seen any reports of those issues documented in like 2 years at least
18:11:17 * hackage persistent-mysql-haskell 0.4.2 - A pure haskell backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-haskell-0.4.2 (naushadh)
18:11:28 <sclv> it doesn't put anything in the path
18:11:30 <ab9rf> sclv: that's about when i switched to using stack
18:11:34 <sclv> fair 'nuff
18:11:36 <ab9rf> sclv: and, also, got a new computer
18:11:38 <sclv> :-)
18:12:00 <ab9rf> sclv: i'm farily certian that i actually had mingw installed on the system (for some other reason) and it was on the path
18:12:16 <sclv> right -- the actually installed one would be on the path
18:12:26 <ab9rf> and there were conflicts
18:12:27 <sclv> but if everything works right, the two should exist side by side
18:12:42 <ab9rf> sclv: it's also possible that i broke it somehow
18:12:52 <sclv> but again, that's due to fixes that were put in place about 2-3 years ago :-)
18:12:59 <ab9rf> sclv: the stack approach has been perfectly adequate for me
18:13:19 <sclv> before then it was quite a mess -- myself i wanted cygwin and ghc to coexist and that was a mess too
18:13:21 <sclv> now it all works
18:13:41 <ab9rf> sclv: yeah, that's when i had those experienced
18:13:52 <ab9rf> i'd say it was 2014-2015 when i was dealing with that stuff
18:14:00 <sclv> i'm not trying to argue with your choices or anything -- just want to be clear on the current state of things, since not everyone knows about how it works now :-)
18:14:29 <sclv> (what happened was ghc expected some stuff in your path before, and now there's config files around that let it find it without it needing to be in the path)
18:14:58 <ab9rf> sclv: that fits with my experience. glad that got fixed, it was seriously irritating for me.
18:47:17 * hackage ival 0.1.0.0 - Intervals  http://hackage.haskell.org/package/ival-0.1.0.0 (MatthewFarkasDyck)
20:30:17 * hackage persistent-sqlite 2.8.2 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.8.2 (MichaelSnoyman)
20:48:16 --- mode: glguy set +v badzergling__
20:48:32 <badzergling__> is there a way to make quickcheck quieter and only show failing tests?
21:00:42 <jle`> badzergling__: how are you running your tests?
21:01:11 <badzergling__> in ghcid via `$quickCheckAll`
21:32:16 <gregberns> I've just started really getting comfortable in Haskell and cleaned up my system and got onto 8.4.3 then got the "OS X: clang: warning" error. https://ghc.haskell.org/trac/ghc/ticket/15112
21:32:16 <gregberns> Whats the best path forward? Any thoughts?
21:32:48 <gregberns> I cant even `cabal install` anything
21:33:47 <MarcelineVQ> comment 7?
21:35:13 <MarcelineVQ> less cryptically: did you try the suggestion from comment 7?
21:35:16 <gregberns> I dont see anything like that in that locaation
21:35:18 <sclv> gregberns: indeed, changing the settings file as per https://ghc.haskell.org/trac/ghc/ticket/15112#comment:7 is a good solution
21:35:59 <sclv> gregberns: it might be somewhere like /Library/Frameworks/GHC.framework/Versions/8.4.2-x86_64/usr/lib/ghc-8.4.2/settings
21:36:01 <MarcelineVQ> could be different depending on how you've installed I suppose, but it'll be somewhere
21:36:21 <sclv> also, note that this error goes away if you update to the latest apple devtools
21:36:42 <gregberns> sclv: ah I'll try that
21:37:08 <gregberns> and I'll take a look to see if I can find that file
21:46:48 * hackage loc 0.1.3.3 - Types representing line and column positions and ranges in text files.  http://hackage.haskell.org/package/loc-0.1.3.3 (chris_martin)
21:49:16 <hololeap> has anyone seen something like this function before, and can it be re-written in more general terms, or possibly using functions in Control.Monad.Free? http://dpaste.com/1J06N5V
21:54:17 * hackage loc-test 0.1.3.3 - Test-related utilities related to the /loc/ package.  http://hackage.haskell.org/package/loc-test-0.1.3.3 (chris_martin)
21:56:39 <dminuoso> How do people know what logging framework to pick.. Between monad-logger, log-warper, hslogger, fast-logger, wai-logger, katip, log-base (+backends), logging-effect I have a really hard time deciding what is suitable..
22:20:09 <ab9rf> use all of them in parallel
22:43:23 <chessandgo> once I do stack build   where is the binary put?
22:54:54 <wchresta> Can I use a function f :: forall n a. (KnownNat n, 5 <= n) => Proxy n -> Vec n a from a function that builds n using someNatVal? I know how to get KnownNat n via someNatVal but I'm not sure I'll be able to satisfy 5 <= n from a runtime number, ever.
22:57:27 <mniip> wchresta, yup, I don't think you can
22:58:50 <dminuoso> ab9rf: What a brilliant idea! Logging is good. Logging much is better. Logging much with many frameworks must be best. :-)
22:59:02 <dminuoso> Diversify!
23:00:19 <cocreature> chessandgo: somewhere in .stack-work
23:01:59 <dminuoso> chessandgo: stack exec -- which your-program-exe
23:02:32 <chessandgo> ah, thank you, I wasnt looking for hidden folders
23:02:56 <dminuoso> chessandgo: This trick also works for cabal new-build/new-exec by the way =)
23:03:28 <wchresta> mniip: Thanks. Seems I need to wait for proper dependent types :)
23:04:02 <chessandgo> bit odd it takes -exe to the progarm name even when not on windows
23:04:04 <chessandgo> thank you
23:05:23 <johnw> dminuoso: you missed just 'logging' ;)
23:06:57 <chessandgo> someone should make a framework called "Lumberjack"
23:07:01 <chessandgo> that only does logging
23:07:17 <dminuoso> johnw: I take it you are John Wiegley? =)
23:07:57 <johnw> nope, never of heard of him, who is that, total coincidence ;)
23:12:05 <dminuoso> johnw: Why did you write your framework? Why didn't the existing solutions fit your bill?
23:12:22 <johnw> 'logging' is just a wrapper around fast-logger
23:12:27 <johnw> it makes logging from IO as simple as possible
23:12:38 <johnw> no transformer, just IORef-based
23:13:12 <johnw> because sometimes, you just want to log, and being typeful about the logging effect doesn't matter enough
23:46:04 <nshepperd> eh, you can totally get proof of 5 <= (n :: Nat) at runtime
23:47:20 <nshepperd> just do a runtime check with KnownNat then unsafeCoerce some proof that (5 <=? n) ~ True
23:49:38 <nshepperd> there just isn't a function in GHC.TypeNats to do this conveniently yet
23:58:23 <dminuoso> johnw: Ill give `logging` a try then. :)
