00:01:45 <kuribas> proxy is a bit ugly, because it has no runtime meaning
00:02:03 <dmwit> No problem, use Proxy#. ;-)
00:02:10 <kuribas> what's that?
00:02:11 <dmwit> (But yes, I too prefer TypeApplications to Proxy.)
00:02:28 <dmwit> It's like Proxy, except in addition to having no runtime meaning, it also has no runtime representation.
00:02:37 <kuribas> ah, cool :)
00:02:54 <dataN_> dmwit: the problem is that forwards is defined using very general classes, and the rest of the code uses this generality. 
00:02:59 <kuribas> so doesn't Proxy gets compiled away?
00:03:16 <kuribas> or does it need to check for bottom?
00:04:08 <dmwit> I think Proxy gets shared aggressively but generally not compiled away. But I'm not 100% on that; GHC has surprised me before with the things it's capable of.
00:04:41 <kuribas> where's the documentation for Proxy# ?
00:04:41 <dmwit> dataN_: That doesn't sound like a problem to me. It just sounds like a description of your code.
00:05:00 <dmwit> https://hackage.haskell.org/package/ghc-prim-0.5.2.0/docs/GHC-Prim.html#t:Proxy-35-
00:05:03 <dataN_> it uses a TypeApplication to distinguish between various instances for various types 'f'.
00:05:28 <kuribas> dmwit: thanks
00:06:07 <dataN_> and the problem is that two valid instances exist for one 'f', so that this type is insufficient to direct the compiler.
00:06:56 <dmwit> Didn't we do this one already?
00:08:04 <dataN_> newtypes and the empty subclass / newclass break the code defined over "forwards" (basically the whole example).
00:09:44 <dataN_> it was apparently necessary to clarify that
00:11:53 <dataN_> it would be good to see the 3 approaches to compare them. (newtypes, newclasses, flags). it is an interesting example, thanks for the help
00:47:18 <kuribas> Typeapplications are pretty usefull.  I am using them now to do a (type level) symbol lookup in a typeclass.
00:53:36 <kuribas> Is there a way to solve the "No Semigroup instance" problem without cpp?
00:57:25 <kuribas> like loading a compat module?
01:00:12 <cocreature> kuribas: https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid#Writingcompatiblecode
01:01:57 <kuribas> cocreature: thanks!$
01:02:23 <kuribas> (dollar is typo)
01:02:41 <kuribas> looks like a curse now ...
01:06:52 <kuribas> This keyboard sucks...
01:21:42 * hackage df1 0.2 - Type, render and parse the df1 hierarchical structured log format  http://hackage.haskell.org/package/df1-0.2 (RenzoCarbonara)
01:26:25 <kuribas> How do you unset a binding in ghci?
01:26:27 <dataN_> why isnt mempty treated the same as mappend in that proposal? does that mean its a convention to give empty synonyms directly in classes? why is mappend not part of the class? is there a reason this synonym is not given the same treatment as e.g. pure/return?
01:26:55 <dataN_> (empty as in mempty*)
01:27:19 <kuribas> dataN_: which mempty synonym?
01:27:53 <dataN_> class Empty a where empty :: a
01:28:06 <dataN_> (a :: k)
01:28:26 <dataN_> oh, a :: *
01:28:46 <cocreature> where is "class Empty" coming from? that class does not exist in the proposal
01:29:09 <cocreature> and "mappend" is part of the Monoid class so I’m not sure what you’re getting at
01:29:27 <dataN_> its motivation is similar to Semigroup 
01:29:54 <dataN_> -- GHC Extension: Legacy alias not needed for Haskell Report
01:31:41 <dataN_> mappend :: Semigroup a => a -> a -> a; mappend = (<>)
01:33:22 <dataN_> cocreature: if it were kept as part of Monoid that would be the same as the Monad Applicative proposal, the question is why this proposal does not use that convention
01:34:38 <dataN_> kuribas: any class that also had a function of the same type as mempty
01:34:51 <cocreature> dataN_: have you actually looked at the proposal? deprecating manual definitions of mappend and eventually moving mappend out of Monoid is part of the proposal
01:35:32 <dataN_> then the question is why this was not done for return of Monad?
01:35:55 <cocreature> that’s also planned for Monad
01:36:17 <dataN_> ah, at least the reasoning behind these choices is consistent 
01:36:17 <cocreature> cf the monad of no return proposal
01:36:50 <dataN_> is there a similar proposal for mempty?
01:37:33 <cocreature> that doesn’t make any sense. Monoid doesn’t have a superclass that defines mempty
01:37:42 <cocreature> just like Monad doesn’t have a superclass that defines >>=
01:37:52 <dataN_> whats the superclass containing return?
01:38:12 <dataN_> oh, its not Applicative no pure...
01:38:16 <dataN_> hmm
01:39:17 <sternmull> I run hoogle 5.0.17.3 with "hoogle server --host=127.0.0.1 --local" and it still links to external urls... how do i get offline documentation? Is version 5 still unfinished and i should use hoogle 4?
01:39:51 <dataN_> so, class Empty a where empty :: a; class Pure (f :: k -> *) where pure :: forall (a :: k). f a
01:41:09 <dataN_> does that work? not sure how to restrict the kind 'k' to * for use with Applicative/Monad though....
01:44:01 <dataN_> it would seem that the lack of existance of these classes seems to mean there is a convention to define synonyms of their defining functions within the classes they appear in rather than being their subclasses...
01:45:24 <cocreature> that empty typeclass is pretty useless, a typeclass that just gives you some fixed value of a type doesn’t let you write a lot of useful code in terms of it. and if you really just want some fixed value, just accept it as an argument. enforcing that the value is inferrable from the type just makes things harder in that case
01:45:29 <dataN_> probably because of confusion surrounding the fact that any function is essentially a synonym of empty...
01:46:39 <dataN_> but this does not extend to pure :: * -> * or pure :: k -> *
01:47:21 <cocreature> I’m not sure what "pure :: * -> *" is supposed to mean. are you suggesting that there is a type called pure that has kind * -> *?
01:47:38 <dataN_> :k pure
01:47:40 <lambdabot> error: Not in scope: type variable ‘pure’
01:47:45 <dataN_> :k return
01:47:46 <lambdabot> error: Not in scope: type variable ‘return’
01:47:49 <dataN_> !?
01:47:54 <cocreature> you can’t take the kind of a value
01:48:44 <cocreature> pure has type a -> f a and the kind of that type is *
01:48:50 <dataN_> cocreature: its useful to define Empty as then writing classes as synonyms of it applied to various types allows them to be pattern matched over using type families.
01:49:52 <dataN_> class pure (f :: * -> *) ... ; class pure (f :: k -> *) ... 
01:50:04 <dataN_> sorry...
01:50:41 <dataN_> was thinking of mzero!
01:51:46 <dataN_> so then there would be a similar proposal to remove mplus from MonadPlus?
01:52:05 <dataN_> and a similar question about why not then do the same with mzero...
01:53:51 <cocreature> arguably MonadPlus should just be removed completely since it provides exactly the same operations as Alternative (although it does have an additional law)
01:54:50 <dataN_> is that because of some idea that constraint synonyms are not viable prelude classes?
01:55:46 <dataN_> wait, whats; class Semigroup (a :: k)
01:59:11 <dataN_> hmm, not that does not work, has to be MonadPlus...
02:00:25 <dataN_> class Alternative (f :: k -> *) where (<|>) :: forall (a :: k). f a -> f a -> f a
02:02:29 <dataN_> (without the Alternative superclass)
02:02:40 <dataN_> Applicative*
02:03:15 <dataN_> trying to get a higher kinded monoid...
02:03:31 <dataN_> for use with the higer kinded pure above
02:05:00 <dataN_> just because these are easy to consider, compared to the the more recent representation of Functor / Category, which have similarly flexible Arity. 
02:16:55 <ZeuPiark> hello
02:29:17 <mniip> is there an 'evaluate' for ST?
03:01:39 <ArahaelPi> Can I apply hlint's output automatically?
03:01:46 <ArahaelPi> I mean, I agree with all 26 suggestions.
03:05:09 <mniip> "Most importantly,
03:05:10 <mniip> a cyclical structure cannot be stored in a compact region."
03:05:11 <mniip> what
03:05:28 <lingeeal> Hi, I have tried to: stack build a yesod template and cannot see any dist/bin folder with the executable being produced as stated in the docs. Why?
03:16:42 <dataN> any way this can work as a way to resolve conflicting instances? https://lpaste.net/5124181144186650624
03:26:03 <dataN> is there a way to match type families using a wildcard or most polymorphic type without making a conflicting instance declaration? 
03:27:31 <merijn> dataN: What are you trying to do?
03:27:48 <merijn> Actually, why is Choice a class at all?
03:27:58 <merijn> Why not just have a Choose type family
03:30:03 <dataN> that would still be conflicting though right?
03:30:21 <merijn> dataN: Then you might be able to reformulate it as a closed type family
03:30:32 <merijn> Which, may or may not (no clue) help
03:31:04 <merijn> dataN: You can abuse overlap with closed type families: https://gist.github.com/merijn/6130082
03:31:47 <dataN> the idea would be to be able to match like 'otherwise' so a pattern match would be chosen over a failure to match so it wouldnt complain about a lack of match as in; Couldn't match type `Choose ((x -> x) -> x -> x)' with `True'
03:33:23 <dataN> (with that instance commented out)
03:36:51 <jle`> mniip: unsafeIOtoST . evaluate? ;_
03:36:55 <jle`> * ;)
03:36:59 <jle`> although i'm not sure if that works
03:37:52 <dataN> merijn: not sure how to use that approach 
03:39:43 <dataN> recall something about not equals not being a constraint...
03:40:11 <mniip> that's true
03:40:27 <merijn> dataN: That's what the "foo" ~ "bar" constraint does
03:40:35 <merijn> dataN: Basically a failing constraint :p
03:40:57 <mniip> the closest thing you have is (a == b ~ False)
03:41:06 <mniip> but that doesn't have any nice axioms to it
03:42:09 <dataN> the idea is that unless specified it should catch all other instances. 
03:42:49 <dataN> as in; instance Choice a where  type Choose a = ()
03:43:33 <dataN> but that if otherwise specified, it would use that instance instead, e.g Choose (Act_T a [a]) = True
03:43:52 <mniip> merijn, I wonder whether it's public knowledge that closed type families don't actually get matched in order...
03:44:04 <mniip> not always in the exact order you write them
03:44:21 <merijn> mniip: Eh...they should be, that's the entire point of them
03:44:49 <dataN> well that would seem to mean pattern matching such as is used over function arguments is not possible...
03:45:21 <merijn> mniip: What makes you say they aren't?
03:45:40 <asheshambasta> I've been trying to wrap my head around why this happens: https://gist.github.com/asheshambasta/8c56b1a61f7f5d98b5d575b7db1635c2
03:46:02 <dataN> oh so the problem is that with closed type families, all the Choose instances would have to be written in one place?
03:47:45 <cocreature> asheshambasta: I think GND might not be able to deal with existentials in general even if they don’t cause problems. that said, I would also argue that this existential is a bad idea anyway :)
03:48:49 <cocreature> asheshambasta: actually does it even work if you remove the deriving clauses? I thought you couldn’t use existential typeclass dicts in newtypes
03:49:10 <cocreature> since the dict needs to be represented at runtime it can’t have the same runtime representation
03:49:54 <asheshambasta> cocreature: the module compiles fine without the deriving clauses
03:50:26 <asheshambasta> and what I'm trying to achieve here is ensure that the error type is an instance of `IsPgErr`
03:50:28 <cocreature> “You can’t use existential quantification for newtype declarations.” is what the GHC userguide says
03:50:46 <cocreature> asheshambasta: add constraints on your use sites not in the type definition
03:51:20 <asheshambasta> ah yes
03:51:25 <cocreature> oh I think I misread things, this is a RankNType not an existential
03:51:35 <cocreature> which makes the "e" type parameter entirely useless
03:51:52 <dataN> possibly its trying to use something like "is implemented" as a value rather than having it throw a compile time error. 
03:52:18 <asheshambasta> cocreature: I must admit this was a case of copy-paste from https://stackoverflow.com/questions/43444170/can-a-typeclass-constraint-be-used-in-a-newtype-definition/43444407 
03:52:48 <cocreature> asheshambasta: that answer also states “this isn’t very usable” :)
03:53:35 <asheshambasta> yeah but I was experimenting to see what worked -- but what you said about use-sites makes much more sense 
03:56:17 <dataN> that way the error for thrown for more than one instance would be helpful, while avoiding the less than one instance defined error, matching one or fewer instances then allowing the Choice class to work as desired. 
03:57:28 <dataN> but this requires exactly two classes, where one matches every other case than the other. 
03:59:27 <dataN> it might help to see how type families could be used as was suggested above. I cant see how the other way would work though 
04:02:35 <dataN> essentially, any way to get this to work (other than flags) https://lpaste.net/5124181144186650624
04:03:00 <xsperry> hello
04:03:20 <xsperry> can someone why am I getting constant memory usage in first case, but not the second? https://lpaste.net/4295043454360092672
04:03:43 <xsperry> +explain
04:09:22 <cocreature> xsperry: can you reproduce this outside of ghci? ghci tends to be a bit weird sometimes
04:11:20 <JuanDaugherty> my guess would be only the second actually executes to get the value, the first just analyzes to get the implicit length
04:13:13 <dataN> merijn: would you be able to explain how to use a closed type family to solve this example? 
04:37:59 <dataN> where the catch all instance described would be setting 'Choice (Act_T (x -> x) x)' to 'Choice a'
04:40:53 <xsperry> cocreature, if I compile both work fine. does haskell guarantee constant space in both cases, in the first case, but not the case, or in neither case?
04:42:56 <cocreature> xsperry: it somewhat depends on the rest of your program. if you use tens1/tens2 somewhere else, then neither version will be constant space since the GC can’t collect the list. if you don’t use it somewhere else then both versions should be constant space
04:44:31 <xsperry> hmm, I thought we always get constant space when we tie the knot, ie let xs = x : xs in xs
04:46:13 * hackage plan-applicative 2.0.1.0 - Applicative/Arrow for resource estimation and progress tracking.  http://hackage.haskell.org/package/plan-applicative-2.0.1.0 (DanielDiazCarrete)
04:46:34 <hpc> xsperry: you can cut that knot pretty easily with something like map id
04:47:46 <cocreature> if you do something like "print (length (take 1000000 tens1)) *> print (head tens1)" the GC cannot collect tens1 while it is calculating the length since there is still a reference to it
04:50:49 <hpc> perhaps a better way of phrasing "constant space" for lists is "each element takes the same amount of memory to evaluate to whnf (or normal form?)"
04:52:19 <hpc> i guess even that has a lot of nuance to it, like say an infinite list of fibs
04:52:49 <hpc> if you traverse it from the head of the list and rnf each element, you have to keep the previous few elements in memory
04:53:43 <cocreature> I usually think of “constant space” in the context of lists as meaning that the list can be collected while it is being consumed
04:53:53 <cocreature> so you never have to materialize the full list
04:54:21 <hpc> yeah
04:54:56 <hpc> maybe reasoning about memory use has to be like strictness or evaluation order
04:55:10 <xsperry> let me rephrase my question, is it a bug of ghci that I am getting constant space in one case, but not the other? or does haskell standard not require constant space in either case
04:55:11 <hpc> "if the expression is traversed in this way, it has that memory characteristic"
04:55:42 <hpc> xsperry: the haskell standard says nothing about memory, period
04:56:03 <cocreature> I’m actually somewhat surprised that the first version has constant memory usage since you can still reference tens1
04:56:07 <hpc> it only says what the value should be at the end of the computation
04:58:14 <hpc> i finally scrolled back up to read the paste, it makes perfect sense to me
04:58:31 <hpc> myrepeat1 is knot-tied
04:58:40 <hpc> tens1 and tens2 are top-level definitions so they never get GC'd
04:58:41 <hpc> so!
04:58:58 <hpc> testing the length of tens1 keeps one cons cell in memory at a time because that's all there is
04:59:16 <hpc> 10 : <points back to itself>
04:59:26 <cocreature> ah right
04:59:31 <hpc> tens2, when evaluated, is going to keep a ton of unique cons cells in memory
04:59:38 <hpc> and actually keep them there because it's top-level
04:59:41 <cocreature> sry, yeah I screwed up here :)
04:59:57 <hpc> xsperry: yeah you were right about a page ago when you mentioned knot tying
05:00:24 <hpc> xsperry: try writing tens3 = map id tens1, btw
05:00:28 <hpc> xsperry: and watch it OOM again
05:16:43 * hackage bencoding 0.4.4.0 - A library for encoding and decoding of BEncode data.  http://hackage.haskell.org/package/bencoding-0.4.4.0 (SergeyVinokurov)
05:17:09 <mniip> who's ben
05:17:46 <nshepperd> Ben Coding
05:21:32 <nshepperd> also, if you write 'tens4 :: Num a => [a]; tens4 = myrepeat2 10' it'll be constant space as well
05:23:13 <nshepperd> because tens4 is actually secretly a function that builds the list at a certain type, so the function would be reused/shared but the list would be temporary
05:57:21 --- mode: ChanServ set +o glguy
06:32:41 <d34df00d> What are the restrictions of makeLenses? It seems to not generate a lens for my field of a singletons-generated type.
06:33:41 <d34df00d> Ah, nope, that's a wrong question.
06:34:01 <d34df00d> It's not generating lenses for existentially quantified types in a GADT.
06:34:27 <d34df00d> Which kinda makes sense if the type variable is mentioned several times in different fields — how can you update just one of them?
06:35:15 <d34df00d> In this case, what's my best option to have a lenses for a type like Cursor :: { _cursorKind :: SCursorKind k, _value :: Value k } -> Cursor?
06:36:57 --- mode: glguy set +v acoret_laptop
06:37:00 <glguy> That doesn't look like a good candidate for having a lens
06:37:28 <d34df00d> I'd probably be fine with just a getter too.
06:38:00 <glguy> It's not a good candidate for a Getter either
06:38:13 <d34df00d> Hmm, why? Especially the kind part?
06:38:29 <glguy> The existentially quantified type
06:38:50 <glguy> Same reason you can't have a normal field accessor function
06:39:13 <glguy> acoret_laptop: read your messages
06:39:43 <acoret_laptop> OK,i may login and then i can speak,is that right?
06:39:51 <d34df00d> glguy: is there any reasonable way to rewrite this into something that'd allow a getter at least for a cursor kind?
06:40:12 <glguy> No, the message says you can speak with voice set and that you'll be voiced
06:40:12 <d34df00d> glguy: originally I had Cursor :: { _cursorKind :: CursorKind }, and I want to add a _value that depends on the kind.
06:44:37 --- mode: glguy set -v acoret_laptop
06:44:56 <acoret_laptop> ok,am i in?
06:45:13 <ab9rf> no
06:46:08 <acoret_laptop> really?
06:47:35 <glguy> acoret_laptop: you could talk once you were voiced earlier and still now that you're identified
06:48:26 <acoret_laptop> oh!i forget to identify
06:59:39 <glguy> d34df00d: it's just going to be unpleasant to use that. That's one of the costs of complicating things with singletons
07:01:01 <d34df00d> glguy: that's a pity. I'd probably wait then till ghc gets full dependent types and continue with not-so-typesafe interface right now.
07:01:32 <d34df00d> This cursor thing represents a node in the C++ AST, and half of its contents depend on the kind. I don't want to uglify everything with singletons here :(
07:05:01 <glguy> d34df00d: This is more of a peek at the pain of dependent types than a speedbump
07:05:55 <d34df00d> Dunno, I played a bit with those in Idris, and things like this would be quite neatly expressible (though there are no lenses there, of course).
07:10:01 <dmwit> You can `data Exists f = forall a. Exists (f a)` and have a getter of type `Cursor -> Exists SCursorKind`.
07:31:25 <Wizek> Is it possible to have 2 reader contexts in a mtl stack? I've tried like this: https://gist.github.com/c8954f62ed6351221144b281721211da
07:32:41 <Wizek> and I get a type error like this: https://gist.github.com/Wizek/c8954f62ed6351221144b281721211da/e22fc4cf2cc6463981615b983b74d356cc333dc7#file-reader-hs-L37
07:33:18 <glguy> No, you'll need to merge them
07:33:23 <Wizek> I would have thought that explicit type signatures via typeapplications are enough to disambiguate between them
07:33:36 <Wizek> glguy: hmm, strange an unfortunate
07:33:40 <Wizek> and*
07:34:01 <glguy> Mtl classes are rarely the right abstraction to expose
07:34:24 <Wizek> glguy: as opposed to?
07:34:42 <ChaiTRex> With Haddock markup, how do I have a link to the identifier `blah32` in the current module, but have the text of the link saying `blah$n`?
07:35:53 <glguy> Wizek: making classes specific to the problem you're solving, or not using classes
07:36:11 <glguy> MonadProblemSpecificChar m
07:36:59 <hpc> ChaiTRex: https://haskell-haddock.readthedocs.io/en/latest/markup.html#links
07:37:10 <Wizek> glguy: if my memory serves me right, you are more of a fan of extensible effects approaches rather than mtl; or am I confusing you with someone else?
07:37:16 <hpc> oh, an identifier
07:37:23 <__monty__> ChaiTRex: Maybe Anchors?
07:37:25 <glguy> MonadReader is like using a single global variable defined in someone else's package
07:37:58 <glguy> Wizek: no, I'm a fan of simple solution, I don't care for extensible effects
07:38:13 <hpc> ChaiTRex: does a mix of syntax like [blah$n]'blah32' work?
07:38:31 <ChaiTRex> __monty__, hpc: Thanks, I'll try both.
07:38:54 <d34df00d> dmwit: what I decided to do is to lift the kind to Cursor (so it's now Cursor (k :: CursorKind)) and just wrap that in SomeCursor :: SCursorKind k -> Cursor k -> SomeCursor
07:39:00 <d34df00d> Looks reasonably well.
07:39:03 <d34df00d> IMO, at least.
07:39:13 <hpc> ChaiTRex: or say something like blah$n (ie 'blah32')
07:39:47 <ChaiTRex> hpc: Ahh, OK. I'll add that to the list of things to try :)
07:39:49 <d34df00d> I'm certainly happy I didn't try to approach dependently typed programming from Haskell.
07:39:58 <hpc> i think i like the parenthetical best, since you can say (ie 'blah32' or 'blah64') later
07:45:42 * hackage hw-prim 0.6.2.12 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.12 (haskellworks)
07:49:14 <dmwit> ChaiTRex: Perhaps [blah64](#v:blah32).
07:51:03 <dmwit> (#t instead of #v for type-level identifiers)
08:02:39 <ChaiTRex> dmwit: Ahh, thanks. I'll try that too.
08:07:55 --- mode: glguy set +v ashesham`
08:08:24 <ashesham`> I _somewhat_ understand why there cannot be a MonadMask instance
08:08:24 <ashesham`>             for ExceptT; but whats the alternative to ExceptT in that case/
08:09:28 <asheshambasta> I _somewhat_ understand why there cannot be a MonadMask instance
08:09:28 <asheshambasta>             for ExceptT; but whats the alternative to ExceptT in that case? 
08:09:51 <merijn> asheshambasta: Eh, there is a MonadMask for ExceptT? :)
08:10:03 <merijn> asheshambasta: But only as of exceptions-0.9
08:12:09 <asheshambasta> merijn: ah, for some reason I thought there wasn't
08:12:13 <asheshambasta> eg.: https://www.fpcomplete.com/blog/2017/02/monadmask-vs-monadbracket
08:14:08 <merijn> 0.9 which added it was in February 2018, so that was right back then
08:15:37 <bendo> hi there
08:15:49 <bendo> can I convert Integer to POSIXTime?
08:15:58 <asheshambasta> merijn: I see
08:16:09 <asheshambasta> I'm probably being stupid :) 
08:17:05 <Habib> @hoogle Integer -> POSIXTime
08:17:05 <lambdabot> Data.Time.Clock.POSIX posixSecondsToUTCTime :: POSIXTime -> UTCTime
08:17:05 <lambdabot> Data.Thyme.Time.Core posixSecondsToUTCTime :: POSIXTime -> UTCTime
08:17:05 <lambdabot> Data.Time.Clock.POSIX utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
08:17:16 <merijn> Well, what does the Integer represent?
08:17:24 <geekosaur> there's a note in exceptions-0.9 about it
08:17:40 <geekosaur> short version is, finally used to use mask but doesn't as of 0.9
08:18:00 <geekosaur> specifically so they could implement it in a way compatible with EitherT and friends
08:19:24 <geekosaur> bendo: "To convert from a CTime or EpochTime, use realToFrac."
08:19:41 <geekosaur> Integer also has a Real instance, so that should also work
08:20:15 <bendo> merijn: https://lpaste.net/5922272018668978176
08:20:59 <merijn> geekosaur: That depends what the integer represents...
08:21:25 <merijn> That approach works if you implicitly assume the Integer is "seconds since Epoch", but is it?
08:21:39 <bendo> yes
08:21:43 <geekosaur> true, but most of the time they're using epoch time just because that's the most common place you get it (something storing an epoch time, which is common on unix)
08:22:01 <bendo> ist unix time
08:23:18 <bendo> the thing is that I taking time from response as an Integer
08:23:37 <geekosaur> there are some potential gotchas but again, if you got it from a unix-epoch time, it'll already be correct (or on the OS vendor, or possibly whoever provided the time if they didn't think things through properly, but you'd probbly need to analyze source cod of whatever produced it in that case)
08:23:45 <bendo> then I have function getTime and getTime' which expect POSIXTime
08:24:24 <geekosaur> and you'd have the same quibbles in C
08:57:02 <Profpatsch> Uh, is there a semigroup like Either, but with the instance Semigroup a => Semigroup T e a
08:57:24 <Profpatsch>   (R a) <> (R a') = a <> a'
08:57:26 <Profpatsch> ?
08:58:20 <Profpatsch> An inverted Validation or something. :)
08:58:42 <merijn> Profpatsch: You can trivially define a newtype for that, but I don't think it exists already
09:00:51 <Profpatsch> mapReduce with short-circuiting behaviour and collection of results.
09:03:06 <dmwit> Profpatsch: Data.Semigroup.Apply.App (Either e) a
09:03:13 <dmwit> ?hackage reducers
09:03:13 <lambdabot> http://hackage.haskell.org/package/reducers
09:04:05 <Profpatsch> Kmett did it first™
09:04:22 <dmwit> Yeah. And more generally, to boot. =)
09:05:34 <Profpatsch> How is having to provide an Apply instance more general? 
09:06:20 <dmwit> You got it backwards. Getting to use any `f` with an `Apply` instance (rather than being specific to `Either e`) is more general.
09:07:01 <Profpatsch> right.
09:07:03 <Profpatsch> Awesome!
09:07:13 <dmwit> (`Either e` already has an `Apply` instance.)
09:10:06 <Profpatsch> Though why name it App and not something like Collect?
09:10:24 <dmwit> There are only three hard problems in computer science...
09:11:26 <Profpatsch> Ah, lol, the Applicative instance is named Ap
09:11:39 <Profpatsch> It doesn’t matter, really.
09:12:22 <Profpatsch> It’s all about expectation and acclimatization. :)
09:16:40 <ab9rf> dmwit: those being?
09:16:48 <dmwit> Naming things and off-by-one errors. ;-)
09:16:53 <ab9rf> dmwit: heh
09:17:15 <ab9rf> dmwit: so the field hasn't changed since i was a student in the 80s :)
09:18:20 <byorgey> I think the original form is "there are only 2 hard problems in CS: cache invalidation and naming things".
09:19:01 <dmwit> Hm, that's not what's in my cache.
09:19:11 <byorgey> hehe
09:19:23 * byorgey sets dmwit's dirty bit
09:19:41 <dmwit> =D
09:19:56 <byorgey> I think "dealing with human measurement of time" should be added to that list as wel
09:20:26 <dmwit> Time, text, and names. The "yikes" list.
09:20:31 <monochrom> Hey people do you have problems with cabal or stack?
09:20:33 <byorgey> and maybe also "dealing with human perception of color"; and then of course the natural generalization, "dealing with humans"
09:20:54 <merijn> monochrom: If you're bored enough to go on with your suggestions I've got some useful work you could be doing :p
09:20:55 <monochrom> Because I have an advice: All your problems will go away if you use GHC directly. :)
09:21:44 <dmwit> I have to repeat a lot of commands every time I change a file. Maybe I'll make a Makefile to automate that.
09:23:51 <monochrom> byorgey: http://www.vex.net/~trebla/humour/tautologies.html #1 :)
09:25:05 <monochrom> dmwit: You started with "there are only three hard problems", then listed naming things and ... oh wait, off-by-one, eh!
09:25:06 <ab9rf> monochrom: a tool that never causes any problems is likely not worth using
09:25:28 <dmwit> monochrom: is good joke, yah?
09:25:42 <__monty__> Are we intentionally misquoting? Only 2 hard problems: names, caches and off-by-one errors.
09:26:04 <monochrom> No, he's intentionally committing an off-by-one error.
09:26:04 <hpc> #4 is still my favorite tautology
09:26:59 <merijn> monochrom: WHy is 7 limited to finite numbers?
09:27:11 <monochrom> Yeah you have a very depressing realization of #4 after lurking in #haskell for a year or something.
09:27:48 <merijn> monochrom: pffft, naah
09:27:51 <dmwit> ab9rf: makes me think of http://www.team.net/mjb/hawg.html
09:28:13 <merijn> monochrom: #4 is far more of an accurate description of every time I have to deal with C/C++
09:28:36 <dmwit> monochrom: #4 has actually changed the way I ask questions because it is so good.
09:28:37 <merijn> monochrom: Like, my commandline parser which has worked flawlessly for the past year magically breaking for no discernible reason >.>
09:28:46 <monochrom> Because people keep doing "hey I've got this error message 'type X does not match type Y' (oh the error message also says 'line 10' but I'll conceal that from you), what gives? Let me show you only lines 45-50 for good meaasure"
09:29:07 <dmwit> merijn: The best part is after you find the problem, the experience of having to ask yourself, "How did this *ever* work right?".
09:32:59 <hpc> dmwit: it's times like that i think technology is like wile e coyote building a bridge
09:33:14 <ab9rf> hpc: nah, wile is much better at building bridges than most technologists
09:33:15 <hpc> dmwit: the end attached to the ground breaks, but if you just keep building the bridge fast enough you won't fall down too
09:33:32 <hpc> meanwhile none of it is actually attached to anything
09:35:54 <dmwit> hpc: Ever watched a slomo video of a slinky being dropped?
09:36:39 <hpc> yes
09:36:47 <hpc> it's a lot like what i described :D
09:36:52 <dmwit> yeah =)
09:40:14 <monochrom> Haha neato
10:05:42 <Guest92638> Hi, I am learning about lens package. Reading https://artyom.me/lens-over-tea-1 and stuck at the step writing `choosing :: Lens s1 t1 a b -> Lens s2 t2 a b -> Lens (s1, s2) (t1, t2) a b`
10:06:17 <maerwald> tdammers: sup
10:06:18 <Guest92638> I am stuck around this point `choosing l1 l2 afb es1s2 = _ $ bimap (l1 afb) (l2 afb) es1s2`
10:06:57 <cocreature> you probably want bitraverse instead of bimap
10:08:46 <Guest92638> bitraverse require applicative, but lens defined with only functor
10:12:50 <cocreature> Guest92638: I just looked at the post and it uses Either instead of (,)
10:13:14 <cocreature> I don’t think you can get by with only Functor for your version of choosing
10:13:41 <Guest92638> ah yes, i modify it to (,) to see if i can find any idea but still stuck
10:14:44 <Guest92638> probably unwrap the either with pattern matching is doable, but i follow the advice in the blog to use bimap
10:15:32 <cocreature> Guest92638: well the blogpost also says that bimap doesn’t work :)
10:16:15 <Guest92638> :rage: oh i miss read it
10:16:26 <Guest92638> :( got it, thank you very much
10:17:55 <kuribas> is there a proapplicative and promonad, like profunctor?
10:18:51 <cocreature> kuribas: which operations would you expect to see in those typeclasses?
10:19:20 <kuribas> like "probind :: f a -> (b -> f a) -> f b"
10:19:32 <phadej> kuribas: http://hackage.haskell.org/package/profunctors-5.3/docs/Data-Profunctor-Monad.html
10:20:22 <kuribas> right :-)
10:22:36 <Guest92638> actually, because of it only have Functor, I am not sure how to write that function
10:24:08 <cocreature> Guest92638: for Either that should be sufficient. can you show us the code you have atm?
10:26:38 <Guest92638> I pattern matching on es1s2 above but not sure what to do next
10:27:27 <ddellacosta> is it correct to say that fmap in the Identity Functor is simply function application?
10:27:45 <cocreature> Guest92638: okay, so you have two cases to consider: in the first you are given a "Left s1". do you have an idea what you could apply to "s1" in this case?
10:28:14 <cocreature> ddellacosta: yep (+ some wrapping/unwrapping of the Identity newtype)
10:28:19 <ddellacosta> cocreature: thanks
10:28:54 <Guest92638> I can apply `l1 afb` on that
10:29:27 <Guest92638> ah, then i can apply fmap Left on that whole thing
10:29:32 <cocreature> exactly!
10:29:39 <cocreature> figuring out the case for Right should be easy now :)
10:29:56 <phadej> "choosinG" for pairs is "alongside", and it *is* a puzzle to write :)
10:30:20 <Guest92638> I got it now, thank you very much @cocreature
10:32:49 <cocreature> Guest92638: fwiw in addition to the version phadej mentioned just now you can also write choosing :: Lens s1 t1 a b -> Lens s2 t2 a b -> Traversal (s1, s2) (t1, t2) a b
10:34:43 * hackage th-printf 0.6.0 - Quasiquoters for printf  http://hackage.haskell.org/package/th-printf-0.6.0 (JudeTaylor)
10:36:12 <Guest92638> @cocreature I will do it a bit later, not going to Traversal yet. But i don't really get what phadej really mean there
10:36:12 <lambdabot> Unknown command, try @list
10:36:52 <cocreature> Guest92638: alongside :: Lens s1 t1 a1 b1 -> Lens s2 t2 a2 b2 -> Lens (s1, s2) (t1, t2) (a1, a2) (b1, b2)
10:37:28 <cocreature> but that’s definitely not easy to write and I forgot the details myself :)
10:37:43 --- mode: glguy set +v khilan
10:37:52 <khilan> Hello! I'm trying to resize a list `samples` to size of say (m x n) in <https://gist.github.com/khilanravani/1287d3b08bbdb1bc37e8034581b45158>  I tried something using `Data.Set` but am still unable to understand how to do it. Can someone plz suggest a way to do this?
10:38:22 <Guest92638> cocreature: got it, thanks for helping me
10:39:53 <cocreature> khilan: what is the type of samples?
10:40:03 <cocreature> and what type should the resized version have?
10:41:20 <khilan> cocreature: The resized version may be a list or an array, I just want to access the values as in line 20
10:41:42 <khilan> cocreature: http://hackage.haskell.org/package/normaldistribution-1.1.0.3/docs/Data-Random-Normal.html
10:44:58 <cocreature> one option would be to use "listArray" to convert the list to an array
10:46:43 <khilan> cocreature: ok, so it would be something like `new = listArray (m, n) samples` , right
10:51:22 <khilan> cocreature: Ok, I think it worked :-). 
11:00:27 <khilan> cocreature: Can u also plz help me with the error msgs in <https://gist.github.com/khilanravani/1287d3b08bbdb1bc37e8034581b45158>
11:00:42 <khilan> From line 39
11:01:47 <khilan> sorry 27
11:02:54 <glguy> khilan: what part of the error do you need help with?
11:04:59 <khilan> glguy: `new ! (x, y)` should return the value and PixelY fromIntegral should convert it into pixel, right? 
11:05:54 <glguy> No, I mean what part of the error message
11:06:31 <khilan> 1st part form line 27
11:06:59 <rotaerk> khilan, you've provided a value of type [(Int, Int)] where it's expecting a value of type Array (Int, Int) Integer
11:07:06 <rotaerk> that's what 28-30 mean
11:07:25 <rotaerk> and it proceeds to tell you specifically where that is... in the first argument of !
11:07:47 <glguy> Line 27 is the filename with the problem and line and column information
11:10:48 <khilan> rotaerk: Oh, very sorry. Mixed up the input params in '!' . Thanks!
11:11:15 <rotaerk> yep, just pay close attention to what the error message is telling you
11:11:21 <rotaerk> I didn't actually tell you anything :P
11:11:28 <rotaerk> I just paraphrased what the error said
11:17:27 <cocreature> and even when you can’t make sense of the actual error message, taking a minute to stare at the location mentioned in the error can often be quite helpful
11:21:33 <khilan> cocreature: yes, I'll keep that in mind. Thank u!
11:22:04 <khilan> Still facing some msgs, trying to make sense of them :-)
11:49:49 <merijn> Rats...comparing whether my algorithm is right by verifying outputs are identical is probably not going to work out for approximate algorithms... >.>
11:51:44 <merijn> Shit...I was just storing the hash of output files to verify my results, but my new code has approximate floating point values as results, so that's not gonna work...anyone got a brilliant idea that doesn't involve storing all full outputs?
11:53:26 <hpc> is there a convenient error function you could write instead?
11:53:50 <merijn> hpc: I'm thinking my best bet might be rounding my output
11:54:47 <hpc> ooh, maybe
11:55:10 <hpc> round both outputs consistently to some precision and hash that?
11:55:55 <merijn> hpc: Basically, it's N rounds of pagerank over a bunch of different implementations and the order of operations (and thus FP results) aren't consistent across implementations, but if I can figure out a reasonable rounding it should work out, I suppose
11:55:57 <hpc> you have to round a little more aggressively than your target accuracy or allow it to report false errors, so it's not quite perfect
11:55:58 <Ke> sum up the results with different sequences of multipliers
11:56:05 <merijn> Since they're supposed to converge on the same results
11:56:20 <uglyfigurine> has anyone tried using https://copr.fedorainfracloud.org/coprs/petersen/ghc-8.6.1/ ??
11:56:53 <merijn> Ke: How...does that help?
11:58:17 <Ke> you can do linear transform from n values to m values with appropriate matrix then compare the m values with some threshold
11:58:58 <merijn> Given the sizes of n I don't think that's going to end up very reasonable
11:59:16 <Ke> m can be moderately small
11:59:39 <Ke> you can always have small enough m
12:00:13 * hackage fitspec 0.4.5 - refining property sets for testing Haskell programs  http://hackage.haskell.org/package/fitspec-0.4.5 (rudymatela)
12:01:47 <Ke> or you mean the accumulated rounding error is too big
12:02:29 <Ke> ?
12:03:09 <rotaerk> hmm, given a Ptr Void and a Vector Word8, how would I copy the contents of the vector into memory at the pointer
12:03:55 <rotaerk> when I was copying some x that was Storable, I just needed to do:  poke (castPtr ptr) theStorable
12:04:04 <merijn> Ke: I mean that I'm entirely sure what you're suggesting in the first place, but it sounds like quite a bunch of computation given that N varies across the different results I have
12:04:07 <rotaerk> but Vector Word8 doesn't seem to be Storable
12:04:19 <nshepperd> if you're rounding, you'll need to set the rounding level so that p = 2 * n * expected_error / rounding_level is small, i think
12:04:24 <merijn> rotaerk: Convert to a Storable vector and just grab it directly?
12:04:47 <rotaerk> this is a Data.Vector.Storable.Vector, which isn't storable
12:04:57 <merijn> rotaerk: No, but you can just extract a Ptr from it
12:04:57 <Ke> merijn: sure, if it varies by a factor of more than epsilon unpredictably, it would not work
12:05:02 <Ariakenom> nshepperd: s/expected_error/worst_case_error/    technically?
12:05:05 <nshepperd> p gives the approximate probability that one element of your n-dimension output will be 'too close' to the boundary between rounding up and rounding down
12:05:09 <merijn> rotaerk: I ever have some example code on ripping out the guts of Storable Vector
12:05:13 <merijn> rotaerk: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Utils.hs
12:05:33 <Ariakenom> nshepperd: no sorry misunderstood
12:05:42 <merijn> rotaerk: That's converting a Storable Vector to ByteString, but you can just skip that step and grab the ForeignPtr directly
12:06:17 <merijn> rotaerk: Obviously all this is *super* safe :p
12:06:59 <rotaerk> ah thanks; though now the question is ... how to copy N elements from one ptr to the other
12:07:02 <Ke> merijn: your results are a vector x, multiply by matrix A  so that || A x_1 - A x_2 || is your error
12:07:21 <rotaerk> and yeah, far from safe :P
12:07:23 <merijn> rotaerk: Although, actually this is overkill
12:07:38 <merijn> rotaerk: If you just wanna copy the vector
12:07:58 <rotaerk> what I'm doing is taking a vector of image data and copying it into a memory mapped GPU buffer
12:08:14 <Ke> merijn: if A is of easy form you never have to store neither A  nor x
12:08:32 <rotaerk> Ptr Void is the buffer's pointer, and the Vector Word8 is the image datta
12:08:53 <Ariakenom> merijn: Is non floats an option?
12:08:55 <merijn> rotaerk: You can zip the Word8 with indices and then just "mapM_ zippedVector $ \(i, val) -> poke (ptr + i) val" (modulo type errors
12:09:07 <merijn> Ariakenom: Eh, well, no, since PageRank is always floats :p
12:09:35 <merijn> Ke: But then I'd have to compute a different matrix for each input
12:09:44 <rotaerk> ah hmm... happen to know if there is a more optimal way to do it?  I can imagine it might be faster to copy in larger chunks at a time
12:09:45 <merijn> Ke: Since I have like >250 different vector sizes
12:09:56 <rotaerk> though I don't really know how, say, C's memcpy works under the hood
12:10:09 <rotaerk> if it's just iterating over the bytes or doing something more clever
12:10:09 <Ke> merijn: right, then it's a no-go
12:11:05 <Ke> but how would floating point errors even be the biggest problem then
12:11:11 <rotaerk> oh I see
12:11:14 <rotaerk> :t copyBytes
12:11:15 <lambdabot> error: Variable not in scope: copyBytes
12:11:26 <Ariakenom> merijn: What do you mean?
12:11:27 <rotaerk> :t Foreign.Marshal.Utils.copyBytes
12:11:28 <lambdabot> GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> Int -> IO ()
12:12:10 <merijn> Ke: I 15 different results for 250 different inputs (which produce 250 unique outputs) and I wanna verify that, for each of those 250 inputs the 15 different versions are identical (approximately)
12:17:30 <Ariakenom> No more deterministic software floats on hackage afaict
12:17:37 <nshepperd> output_summaries = [[sum (zipWith (*) o (randoms seed)) | seed <- [1..m]] | o <- output]
12:17:55 <nshepperd> compare output_summaries across your 15 versions
12:19:03 <Ke> merijn: if your matrix rows are just generated sequences, like (-1)^n, you can just cut off at proper len
12:19:34 <nshepperd> computing randoms may be some computation, but surely less than pagerank in the first place
12:22:17 <Ke> 1^n and (-1)^n are actually pretty reasonable examples
12:25:31 <Ke> I guess the system works if epsilon*(x_max/x_min)*n_values << 1 or something
12:27:53 <Ke> where 1 is the acceptable relative error, I guess
12:50:13 * hackage logict-state 0.1.0.5 - Library for logic programming based on haskell package logict  http://hackage.haskell.org/package/logict-state-0.1.0.5 (AtzeDijkstra)
12:50:43 * hackage chr-data 0.1.0.1 - Datatypes required for chr library  http://hackage.haskell.org/package/chr-data-0.1.0.1 (AtzeDijkstra)
12:51:43 * hackage speculate 0.3.3 - discovery of properties about Haskell functions  http://hackage.haskell.org/package/speculate-0.3.3 (rudymatela)
12:51:45 * hackage chr-core 0.1.0.4 - Constraint Handling Rules  http://hackage.haskell.org/package/chr-core-0.1.0.4 (AtzeDijkstra)
12:54:01 <zachk> > 2+2 -- seeing if lambdabot is alive in here at least....unresponsive elsewhere
12:54:03 <lambdabot>  4
12:57:59 <MarcelineVQ> @botsnack
12:57:59 <lambdabot> :)
12:58:04 <hololeap> is it possible to make synonyms for constraints? something like: type AsyncWriter m = MonadWriter [SomeAsync] m
12:58:37 <cocreature> hololeap: yes if you enable ConstraintKinds
13:00:49 <hololeap> cocreature: legit. that's just what i wanted. thanks
13:05:26 <elpfen> What's a good way to represent an infinite stream? I have a socket response that I want to represent in a more general way.
13:05:42 <elpfen> I'm thinking of something like an Rx observable.
13:05:54 <merijn> elpfen: Depends how you wanna process it
13:06:03 <merijn> elpfen: You could simply use a conduit or similar
13:07:18 --- mode: glguy set +v gentauro
13:07:22 <gentauro> % :t scan
13:07:22 <yahb> gentauro: ; <interactive>:1:1: error:; * Variable not in scope: scan; * Perhaps you meant one of these: `Seq.scanl' (imported from Data.Sequence), `BSL.scanl' (imported from Data.ByteString.Lazy), `BS.scanl' (imported from Data.ByteString)
13:17:16 * hackage bench 1.0.12 - Command-line benchmark tool  http://hackage.haskell.org/package/bench-1.0.12 (GabrielGonzalez)
13:24:27 * hackage bv-sized 0.5.0 - a BitVector datatype that is parameterized by the vector width  http://hackage.haskell.org/package/bv-sized-0.5.0 (benselfridge)
13:54:36 <crestfallen> hi if we say a predicate representation of prime numbers, is that use of the word representation the same as in representation theory? i.e. does the predicate create a finite set of primes that can be expressed in matrix form ? just wondering after reading up of representation theory...
13:55:23 <crestfallen> or is representation used more generally / literally
13:56:38 <crestfallen> in other words do you think of all results of a function that checks for primality as a set ?
13:57:14 <glguy> That looks like it's a better question for ##math than #haskell
13:57:15 <crestfallen> when the results are True
13:57:56 <crestfallen> I asked it there thanks. I was just wondering since I first heard "predicate representation" here.
14:08:17 <dmwit> I've got a pretty simple byte-oriented protocol. I'm looking at binary and attoparsec, which both seem more than capable enough; are there others I should be considering? Any tips on how to choose?
14:08:50 <ab9rf> i'd use binary if you can in preference to attoparsec
14:09:05 <ab9rf> binary isn't nearly as flexible, though
14:11:54 <ab9rf> i vaguely recall running into another library for that sort of thing once, but i don't remember it having any advantage over eithr binary or atto
14:12:04 <ab9rf> nor do i remember what it was called
14:12:13 <dmwit> You'd prefer binary for speed or for some other reason?
14:13:03 <MarcelineVQ> ab9rf: cbor?
14:13:29 <dmwit> cbor looks great, but doesn't really help if the protocol is already specified and isn't cbor.
14:15:05 <MarcelineVQ> Just wondering if that's what he was thinking of
14:15:23 <dmwit> attoparsec looks like it has a bunch more "library" built up around it. Like... takeWhile exists, e.g.
14:18:08 <ab9rf> MarcelineVQ: don't think so
14:18:12 <ab9rf> MarcelineVQ: and i'm not a he :)
14:18:41 <ab9rf> i don't recall running into cbor
14:24:26 <fresheyeball> derive generic on a large enum is killing ghc
14:24:41 <fresheyeball> is it possible to have an NFData instance that does not require Generic?
14:24:44 <MarcelineVQ> aww still? it's been an issue for awhile iirc
14:25:34 <MarcelineVQ> Actually I might be thinking of the large records issue
14:55:22 --- mode: glguy set +v pamu
14:56:21 <d34df00d> Isn't the NF for a enum type the same as WHNF?
14:56:33 <pamu>  How can I get started with Nix haskell project? Any beginner friendly tutorials available on internet?
14:56:36 <d34df00d> (assuming the enum type is a type whose all constructors dont' have subfields)
14:57:32 <MarcelineVQ> pamu: https://github.com/Gabriel439/haskell-nix is popular, I haven't finished it myself
14:58:13 <Gurkenglas> Clicking "#fork" on https://downloads.haskell.org/~ghc/8.4.2/docs/html/libraries/base-4.11.1.0/src/GHC.Conc.Sync.html#forkIO gives me 400
14:58:20 --- mode: glguy set +v gre
14:58:43 * hackage openexr-write 0.1.0.2 - Library for writing images in OpenEXR HDR file format.  http://hackage.haskell.org/package/openexr-write-0.1.0.2 (pavolzetor)
15:04:08 <gre> hello
15:04:49 * gre is looking for a functionnal language to make some scripts/GUI on windows
15:05:06 <gre> is Haskell can help me for that or do you have any other suggestion pls? ty
15:05:32 <systemfault> gre: You might find me totally crazy... but I'd consider using PureScript with Electron.
15:06:58 <pamu> Has anyone used miso ( https://github.com/dmjio/miso ) ? What is your experience with it? What does it serve all the basic features required for Single page frontend app development?
15:07:16 <gre> hi, ofc im not find you totally crazy, i didn't know purescript actually, im reading about
15:07:16 <pamu> *How is your experience with it?
15:25:22 --- mode: glguy set -v gre
15:34:58 <c50a326> https://ptpb.pw/VwA9/hs what's wrong with the opening ( on line 15? :S
15:35:31 <lavalike> c50a326: " and ( must be on the same column
15:35:47 <c50a326> bloody emacs! ty
15:36:04 <lavalike> np
15:41:12 * hackage control 0.1.0.0 - Class of monad transformers which control operations can be lifted thru  http://hackage.haskell.org/package/control-0.1.0.0 (MatthewFarkasDyck)
16:10:19 <madnight> pamu, i used miso and pux (Purescript)
16:10:29 <c50a326> what do haskellers think about erlang?
16:12:00 <madnight> pamu, from my personal experience i like miso better, that's not due to the framework (both frameworks are good for my purpose), but rather due to the language
16:12:57 <hpc> c50a326: it's on my "learn it eventually if it's not too far out of my way" list
16:13:30 <hpc> i like the idea of it, concurrency is an important thing to be able to do well
16:20:59 <Rembane> c50a326: Erlang is a small, and beautiful language with very interesting primitives and rock-solid concurrency. The lack of a powerful type system and static type checking bites me all the time though. I find it very frustrating to work with.
16:22:04 <Wizek> glguy: Apparently this is possible after all! https://gist.github.com/Wizek/ad643609535033321fcc8489f933d4f4
16:24:01 <suzu> erlang has no static typing
16:24:03 <suzu> dealbreaker
16:24:08 <suzu> i can never og back
16:25:17 <slack1256> Has gi-gtk effectively won as the de-facto native UI library for haskell?
16:37:55 <glguy> Wizek: using undecidable instance to break functional dependencies is a bad plan
16:38:09 <glguy> Relying on overlapping instances is too
16:38:18 <glguy> You're worse off now than you were before
16:38:42 <Wizek> glguy: How so? Can this go bad in some way?
16:40:18 <glguy> And on to of that you're still using MonadReader
16:42:59 * Wizek glguy: I am indeed. But if the limitation is gone it's not as bad a choice as before, or is it? Also, could you share an example with me with which this can go wrong? Either at compile time or runtime?
16:43:18 <Gurkenglas> What do you use instead of MonadReader?
16:43:48 <glguy> I don't know what all the consequences are of violating the functional dependency. I didn't really know it would let you. I expect that to create inference issues. 
16:44:38 <glguy> Gurkenglas: either no class or a class specific to the problem you're solving. Exposing and relying on mtl classes is an antipattern
16:45:06 <glguy> Similar issues to using global variables defined in someone else's package
16:46:18 <Wizek> glguy: look here, it works quite well and quite flexibly too! I don't expect inference to work without the type appications, to me that's a very understandable tradeoff. https://gist.github.com/Wizek/6efcef92a961009dad355e2793da21cd#file-reader2-hs-L23-L29
16:48:54 <Wizek> glguy: I also don't quite agree that this is akin to using global variables for two reasons: 1) it's only available to functions whose types explicitly state they can have access. 2) we can have safe IORefs and MVars in reader contexts without having to reach for unsafePerformIO globally. 3) running multiple such functions still won't mess up each other's state as they are separate, so not really global
16:49:31 <Wizek> but maybe I am missing something with how you mean global variables, or how this can be an issue.
16:49:34 <hololeap> i'm having a hard time understanding the use of OverloadedLabels in haskell-gi. all i know about labels is that they are basically type-level strings. what i don't understand is what their use is in this code, for instance #add and #showAll : https://github.com/haskell-gi/haskell-gi#using-the-generated-bindings
16:49:43 <hpc> Wizek: it's more of a packaging-level issue
16:50:01 <Eduard_Munteanu> What's that @Bool syntax?
16:50:08 <hpc> your package's api directly includes parts of another package's api
16:50:55 <Wizek> hpc: Do you mean that in the context if one is writing and publishing a library?
16:51:27 <geekosaur> Eduard_Munteanu, TypeApplications
16:51:47 <hpc> yeah, or not even publishing but just using it
16:52:19 <hpc> it's less effective as an abstraction because it leaks stuff below it
16:52:24 <hololeap> honestly, i don't understand the motivation for Symbols or OverloadedLabels
16:52:46 <Wizek> hpc: how so? Is that because this way I am exposing some mtl specific stuff?
16:52:52 <hpc> or actually, here's a better way to put it
16:53:02 <hpc> your package's api now includes its dependencies
16:53:25 <hpc> where before the dependencies were implementation details, now users of your package care about what it's using too
16:53:35 <hpc> so you can't go changing that dependency later, or it's also an api change
16:53:54 <Wizek> hpc: surely that's just an abstraction detail
16:54:27 <Wizek> e.g. I could say I only export `askInt = ask @Int` and `askBar = ask @Bool`
16:54:34 <Wizek> and later on I can refactor
16:54:39 <hpc> :t ask
16:54:41 <lambdabot> MonadReader r m => m r
16:54:48 <hpc> :t ask @Int
16:54:49 <lambdabot> error:
16:54:49 <lambdabot>     Pattern syntax in expression context: ask@Int
16:54:49 <lambdabot>     Did you mean to enable TypeApplications?
16:54:53 <hpc> blargh
16:55:04 <MarcelineVQ> % :t ask @Int
16:55:04 <yahb> MarcelineVQ: MonadReader Int m => m Int
16:55:18 <Eduard_Munteanu> Thanks, looks like a cool extension which I missed.
16:55:38 <hpc> Wizek: MonadReader is still exposed
16:56:57 <Wizek> hpc: that's true. But maybe I can continue to abstract. E.g. I could say `type CanAskBar m = MonadReader Bool m`
16:57:13 <Wizek> And that way no one has to rely on MonadReader specifically
17:00:03 <Wizek> hpc: what do you think?
17:01:39 <hpc> type aliases don't really do anything
17:01:50 <hpc> you're no longer typing MonadReader but it's still the same type
17:07:04 <glguy> Wizek: it's just poor design, but if it works well enough for you then that's ok
17:07:51 <glguy> And it's like a going variable in how it relies on a unique shared class you don't control
17:08:00 <glguy> Not because of mutable state
17:08:08 <glguy> Like a global*
17:09:00 <glguy> Type synonyms aren't abstraction, so that doesn't help
17:09:37 <glguy> And breaking the functional dependencies makes brittle code that will break when GHC gets smarter and rejects your code
17:11:11 --- mode: glguy set +v badzergling_
17:11:51 <badzergling_> is there a version of `Data.Constraint.Lifting` where the constraints on `a` and `f a` can be different?  
17:12:50 <badzergling_> I suppose I'm looking `QuantifiedConstraints` but as type class. 
17:56:41 <hololeap> what is this syntax? `#add` and `#showAll`: https://github.com/haskell-gi/haskell-gi#using-the-generated-bindings
17:57:41 <c_wraith> hololeap: it's part of the OverloadedLabels extension
17:59:49 <hololeap> c_wraith: so that has something to do with a type level String, right? what exactly are these? they seem to be functions from the way they are used
18:04:49 <phadej> hololeap: http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Records.html
18:05:49 <phadej> hmm
18:05:50 <phadej> A label #foo has type IsLabel "foo" t => t
18:06:17 <phadej> http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-OverloadedLabels.html
18:07:37 <phadej> i.e. it can be abused for a lot of things.
18:07:45 <phadej> (ab)used
18:09:49 <hololeap> phadej: i just really don't get it. a Symbol is like a type-level string, right? what uses would this have and why are they using `#add` instead of just having a function called `add`?
18:10:58 <geekosaur> because a function can't be shared betyween different records
18:11:32 <geekosaur> that's how normal haskell records work, data Foo = Foo {bar :: SomeType } gives yoiu a fucntion bar :: Foo -> SomeType
18:11:34 <glguy> They do it because multiple types have methods of the same name, and gi-gtk works to emulate the original gtk api
18:11:57 <geekosaur> but you can't reuse that name in a different record because it would define bar :: SomeOtherRecord -> SomeType which would conflict
18:11:59 <glguy> Assuming you were looking at gi-gtk
18:12:20 <geekosaur> and that, yes. C allows such reuse so gi-gtk uses those names for compatibility
18:12:45 <geekosaur> by making it a typeclass function parameterized by a type level string, you can use typeclasses to resolve which record is intended
18:13:30 <hololeap> what is a record in this context?
18:13:57 <geekosaur> data Foo = Foo {bar :: SomeType }
18:14:12 <geekosaur> except that they are actually defining records representing a bunch of gtk C structs
18:14:21 <geekosaur> where C allows names to be reused between different structs
18:15:06 <hololeap> ok... i think i'm starting to get it, but where would i see the documentation for `#add` or `#showAll`? would i have to look at the C docs?
18:20:00 <glguy> Yeah, you'd look at the standard gtk documentation
18:28:35 <hololeap> alright, i think i understand it well enough for now
18:48:08 <slack1256> Is there any easy way (via cabal/stack) to access the local documentation of an installed package?
18:48:37 <slack1256> I usually search my file-system for the corresponding index-file
18:51:13 * hackage axel 0.0.4 - The Axel programming language.  http://hackage.haskell.org/package/axel-0.0.4 (jgrosso256)
18:52:03 <chessandgo> im getting a -Wunused-matches false posative, is this significant
18:52:14 <chessandgo> it seems to not detect im using a var latter
18:54:16 <acoret_laptop> slack1256: use cabal haddock? i dont use cabal in fact...just see it in cabal help
18:55:56 <slack1256> acoret_laptop: that option seems to be for generating haddock documetation of a program. I want to access the currently indexed docs
18:58:51 <oldandwise> why is `f = ((-)3)` why can't i reverse the substraction in the same way is division?
18:59:36 <oldandwise> for example, `f = (2/)` and `f = (/2)` but i cannot the same for substraction 
18:59:44 <mniip> oldandwise, because (-3) is a negative 3 integer literal
18:59:45 <acoret_laptop> slack1256: combining find with cabal copy maybe help
18:59:50 <mniip> use (substract 3)
18:59:55 <mniip> er
18:59:58 <mniip> subtract
19:00:09 <oldandwise> ouch... 
19:01:09 <oldandwise> what to import?
19:01:51 <acoret_laptop> oldandwise: prelude?
19:02:30 <oldandwise> mniip: are you using dvorak?
19:03:27 <mniip> no
19:04:03 <mniip> % :i subtract
19:04:04 <yahb> mniip: subtract :: Num a => a -> a -> a -- Defined in `GHC.Num'
19:04:06 <mniip> it's in Prelude
19:04:27 <oldandwise> `f = (3 subtract)` 
19:04:35 <mniip> no
19:04:37 <glguy> -3 is negate applied to the 3 integer literal without the extension enabled
19:04:39 <mniip> f = (subtract 3)
19:05:02 <oldandwise> yes, but how can i have the other way around ?
19:05:17 <mniip> it is already the other way around
19:05:29 <mniip> > let f = subtract 3 in f 10
19:05:31 <lambdabot>  7
19:05:43 <mniip> subtract = flip (-)
19:05:45 <mniip> not (-)
19:07:56 <oldandwise> ok..got it now: `f = (subtract 3)` and `f = (3-)` are what i was aiming for
19:08:30 <mniip> yup
19:25:35 <oldandwise> what u think of the FP in javascript? is it viable?
19:26:41 <shachaf> Sounds like a question for ##javascript
19:30:09 <oldandwise> how do i do this: `f = (subtract 2) . (*)`  so that `f 3 4` is 10
19:30:26 <oldandwise> ie, i chain the functions
19:30:50 <ChaiTRex> @pl \a b -> a * b - 2
19:30:50 <lambdabot> flip flip 2 . ((-) .) . (*)
19:30:55 <ChaiTRex> @pl \a b -> b * a - 2
19:30:55 <lambdabot> flip flip 2 . ((-) .) . (*)
19:31:04 <ChaiTRex> Well, that's a bust.
19:31:30 <ChaiTRex> let f = (subtract 2 .) . (*) in f 3 4
19:31:32 <ChaiTRex> > let f = (subtract 2 .) . (*) in f 3 4
19:31:34 <lambdabot>  10
19:32:13 <oldandwise> wow..thanks
19:32:20 <mniip> protip: don't do that
19:32:28 <mniip> \a b -> a * b - 2
19:32:31 <ChaiTRex> Yeah, best to write it as a lambda
19:32:31 <mniip> is the way to write it
19:32:39 <mniip> if you want to be able to read it 15 minutes later
19:32:39 <ChaiTRex> Much more readable that way.
19:33:08 <dolio> > (curry $ subtract 2 . uncurry (*)) 3 4
19:33:10 <lambdabot>  10
19:33:32 <ChaiTRex> :t subtract 2 =<< (*)
19:33:33 <lambdabot> (Num (b -> b), Num b) => b -> b
19:33:45 <ChaiTRex> :t subtract 2 >>= (*)
19:33:46 <lambdabot> Num b => b -> b
19:33:56 <ChaiTRex> > (subtract 2 >>= (*)) 3 4
19:33:58 <lambdabot>  error:
19:33:59 <lambdabot>      • Could not deduce (Num t0)
19:33:59 <lambdabot>        from the context: (Num (t -> t1), Num t)
19:34:13 <ChaiTRex> Hmm, never mind on that.
19:52:14 --- mode: glguy set +v yajw
19:52:36 <yajw> I am a haskell beginner.
19:53:14 <acoret_laptop> yajw: welcome!
19:53:23 <yajw> haha, thank you !
19:57:40 <oldandwise> given, the amount of overhead thinking when declaring/defining a function. What are some Haskell bugs that would creep in, in a haskell-based code?
19:58:09 <maerwald> oldandwise: can you be more specific?
19:58:23 <mniip> none! haskell is always bug-free! yes!
19:58:30 <acoret_laptop> lol!
19:59:11 <maerwald> strong type systems (contrary to popular belief) has almost no connection to the amount of bugs in a code base. The main thing it makes easier is refactoring and up-front design. That's all
19:59:17 <maerwald> don't fall for that fallacy
20:07:10 <oldandwise> maerwald: is IDE intellisense included here?
20:09:33 <maerwald> editor/IDE support in general is very bad
20:09:45 <maerwald> the reason refactoring is nice is because of the compiler, not other tools
20:10:42 <Squarism> agree, (also coming from intellij). You loose some, gain some. =D
22:22:13 * hackage hw-simd 0.1.1.0 - SIMD library  http://hackage.haskell.org/package/hw-simd-0.1.1.0 (haskellworks)
23:16:12 * hackage XML 0.0.1.0 - Extensible Markup Language  http://hackage.haskell.org/package/XML-0.0.1.0 (MatthewFarkasDyck)
23:17:12 * hackage hs-functors 0.1.3.0 - Functors from products of Haskell and its dual to Haskell  http://hackage.haskell.org/package/hs-functors-0.1.3.0 (MatthewFarkasDyck)
23:19:13 * hackage control 0.1.1.0 - Class of monad transformers which control operations can be lifted thru  http://hackage.haskell.org/package/control-0.1.1.0 (MatthewFarkasDyck)
23:24:43 * hackage lifted-base-tf 0.1.0.0 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-tf-0.1.0.0 (MatthewFarkasDyck)
23:26:13 * hackage relude 0.2.0 - Custom prelude from Kowainik  http://hackage.haskell.org/package/relude-0.2.0 (shersh)
23:26:20 <vaibhavsagar> does stack have an equivalent of --enable-executable-dynamic
23:28:43 * hackage util-exception 0.2.0.0 - Exceptional utilities  http://hackage.haskell.org/package/util-exception-0.2.0.0 (MatthewFarkasDyck)
23:29:03 <chessandgo> if I want to create a single page web app of medium complexity (read and write from a websocket) should I use purescript or GHCJS?
23:29:12 <chessandgo> the backend is running haskell, if that matters
23:30:26 <vaibhavsagar> chessandgo: I would recommend purescript because I think it is easier to set up and deploy
23:31:12 <chessandgo> thanks, do you have any recommended GUI library? I looked at the choice of bindings and didn't know what to choose
23:31:35 <chessandgo> I hear react and Angular as the current javascript hottness, but theres many bindings for both
23:35:17 <maerwald> pick clojurescript
23:35:28 <maerwald> better support, but then you have little type system
23:36:11 <maerwald> or just plain js. I wouldn't bother with either ghcjs nor purescript
23:38:55 <chessandgo> but then you have to use procedural programming *and* javascript!
23:38:59 <chessandgo> the worst of all worlds!
23:39:05 <maerwald> huh?
23:39:10 <chessandgo> Javascript
23:39:24 <MarcelineVQ> single page app of medium complexity sounds like a good test-case for miso   https://github.com/dmjio/miso#examples
23:39:25 <maerwald> don't be obsessed, look at the options honestly
23:41:44 <chessandgo> Meanirelli: GHCJS then? thats client side?
23:44:01 <maerwald> yet another leaky abstraction? ;P
23:44:19 <ArahaelPi> If you only need a little bit of scripting, javascript's hard to beat..
23:44:31 <ArahaelPi> If you need a bit more, then perhaps typescript.
23:44:42 <ArahaelPi> More still? Maybe purescript or perhaps ghcjs.
23:44:53 <maerwald> yes and if you do it right, you really only do little bit of scripting. Nothing beats static websites. JS is the reason the web is vulnerable.
23:45:17 <maerwald> don't use js for fun, use it because you cannot do something without it
23:49:56 <chessandgo> It would be nice not to need it
23:50:43 <chessandgo> but creaing a cross plateform standalone program that handled what would come downt to disabling pictures and formatting text dynamically would be more work than just doing something with the web
23:50:50 <chessandgo> displaying*
23:51:19 <maerwald> well, people think they need all those features, but they really don't
23:51:25 <maerwald> it's just that they *want* them
23:51:41 <ArahaelPi> I see businesses managing just fine using an NCURSES based application.
23:52:37 <maerwald> user interface doesn't become better with buttons dynamically appearing and disappearing. In fact, it's the other way around
23:52:51 <chessandgo> well I dont really *need* my personal project, I could just stop developing it, too
23:53:00 <maerwald> you introduce a whole new set of user errors just because of that "dynamic" obsession
23:53:33 <maerwald> and then the website loads and rearranges in weird ways, so your next click accidentially hits "delete" 
23:54:53 <maerwald> but hey, many cross platform
23:55:38 <maerwald> and better support for vulnerabilities
23:55:46 <maerwald> and ads
23:56:35 <chessandgo> then what is your recommended crossplatform framework that allows me to easily read from websockets and format text and images
23:59:05 --- mode: glguy set +v taumuon
23:59:30 <maerwald> I don't use frameworks
23:59:58 <chessandgo> you code your GUIs from scratch?
