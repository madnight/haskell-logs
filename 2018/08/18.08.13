00:05:06 <dminuoso> tdammers: Hey regarding casing, is there a reason there's no `fromScreaming` in your library?
00:05:40 <dminuoso> Oh haha. I guess Im supposed to use fromSnake =)
00:15:13 * hackage natural 0.3.0.2 - Natural number  http://hackage.haskell.org/package/natural-0.3.0.2 (qfpl)
00:18:44 <lyxia> ChaiTRex: I once heard that (byte)string literals get compiled that way.
01:17:08 <arahael> Are there any resources for true Literate programming in Haskell?
01:17:19 <arahael> (Ie, as Knuth invented it - not the current .lhs thing)
01:19:51 <arahael> Alternatively, any resources that explain how .lhs works, demonstrating that .lhs code can be ordered to suit human logic, rather than the compiler?
01:21:12 <pie__> i think haskell can be reordered arbitrarily for top level things
01:21:24 <pie__> (well you need to have imports at the top))
01:21:33 <lyxia> yeah that's already true of .hs
01:21:44 <arahael> So .lhs is "good enough", I guess, though that's still more of a per-file thing.
01:21:49 <arahael> (And not program wide)
01:21:54 <lyxia> right
01:22:13 <arahael> I guess that's still "good enough" for most people.
01:24:11 <pie__> actually i think you can reorder more or less any blocklike thing? (idk the propery syntactic name)
01:24:19 <pie__> (i mean not within a block)
01:27:54 <pie__> unrelated, what should I use for a FIFO?
01:28:39 <pavonia> The way WEB is able to move source code around in the documentation isn't mostly necessary anymore today because modern programming languages usually have a sophisticated module handling system
01:28:53 <lyxia> pie__: sequences from containers
01:29:04 <pie__> lyxia, ah ok
01:29:26 <lyxia> pie__: there's also one with two lists that's quite easy to roll your own
01:29:45 <pie__> yeah im not big on algorithms at the moment p
01:29:46 <pie__> * :p
01:29:50 <merijn> Also depends what you're using said FIFO for :p
01:30:46 <pie__> uh...."as a fifo"? xD
01:31:09 <pie__> queueing (man that is a messed up word) up user data for viewing in another UI element
01:31:35 <merijn> pie__: Yeah, but you could want FIFO's accessed from multiple concurrent threads, or just a queue :)
01:31:48 <pie__> ah
01:31:50 <dminuoso> pie__: Let's separate the reordering. When you are say in a do-block, you can reorder things if your monad is commutative. I mean it basically boils down to whether `a >> b` is the same as `b >> a`
01:32:18 <pie__> dminuoso, sure i guess
01:32:22 <dminuoso> pie__: So reordering inside *code* is possible if the operator you are reordering around is commutative.
01:32:32 <pie__> sure, but usually it isnt?
01:32:35 <dminuoso> Right.
01:32:48 <pie__> well i mean i dont disagree at all, i just want thinking so nuancedly
01:32:57 <dminuoso> Bindings, such as top level bindings, bindings introduced by where or by let however have no directions.
01:33:43 <pie__> alternative reading, >> is usually precisely what imposes ordering, so if you dont have >>, or >> is commutative, youre fined (?)
01:33:49 <pie__> *you're fine
01:35:22 <merijn> pie__: I think it's generally clearer to talk about >>= when we think about ordering, because the type of >>= makes it clearer why
01:35:45 <merijn> pie__: Additionally, "a >> b" is simply defined as "a >>= \_ -> b"
01:35:51 <pie__> ah, ok
01:36:00 <merijn> :t (>>=)
01:36:02 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:36:03 <pie__> i only have a practical notion for this stuff as of yet
01:36:32 <merijn> pie__: It's clear from the second argument being "a -> b" that you *somehow* first need to get the 'a' from 'm a' to be able to continue
01:36:37 <dminuoso> In that case, a commutative monad would be one where: `a >>= f >>= g` is the same as `a >>= g >>= f`
01:36:42 <pie__> merijn, yeah
01:36:46 <merijn> eh, second argument being "a -> m b"
01:38:49 <dminuoso> pie__: But you dont even have to think as far as monads to talk about non-commutative operators.
01:39:11 <merijn> Division and subtraction are obvious examples
01:39:18 <pie__> well within a ?statement/expression? is also a problem sure 
01:39:23 <merijn> > 10 - 5 == 5 - 10
01:39:26 <lambdabot>  False
01:39:35 <pie__> but i suppose that was also implicit
01:39:37 <pie__> :p
01:40:47 <merijn> pie__: Haskell doesn't have statements, just expressions (and expressions that look vaguely like statements due to liberal application of syntactic sugar)
01:41:05 <pie__> merijn, ah ok
01:41:29 <merijn> pie__: Do notation is just syntactic sugar for uses of let-in, >>= and >> which are just expressions
01:41:46 <merijn> pie__: See https://en.wikibooks.org/wiki/Haskell/do_notation
01:41:48 <pie__> yeah im familiar with that, i just didnt know what things are called
01:45:05 <dminuoso> pie__: If you mimic Python code for example, every expression would be of type `IO Dynamic`. In order to sequence two "statements", you would use >> and >>=.
01:45:43 <dminuoso> So in a curious way the instance IO Monad implements sequencing actions, which python might call statements.
01:45:51 <dminuoso> *instance Monad IO
01:45:53 <dminuoso> Heh
01:49:47 <merijn> Anyone bored and need some suggestion of usefull Haskell to write? :p
01:49:58 <Clint> ha
01:50:09 <ArahaelPi> pavonia: Well, yes, but how would you say, define a data structure in one module, and refer to it in another?
01:50:17 <ArahaelPi> pavonia: My understanding is that WEB would let you do this.
01:50:28 <merijn> I'll guarantee people will love you for it! (At least I will, but I'm sure I'm not alone!)
01:51:40 <hjt> merijn: well at the very least i'm intrigued
01:52:06 <merijn> hjt: Someone should go and implement an "ADOPT" pragma to silence individual orphan instance warnings :)
01:52:47 <hjt> that is weirdly adorable as a concept
01:53:01 <merijn> I've had this idea for awhile, but too busy with work to implement it. But I think it shouldn't be *too* hard for someone willing to dive into the GHC code for a eek or two
01:53:15 <merijn> hjt: I'm very proud of coming up with that pragma name, yes
01:53:49 <pavonia> ArahaelPi: Can you even have different files with WEB?
01:54:36 <ArahaelPi> pavonia: Why would WEB be single-file? (Remember, it was originally for Pascal, if I'm not mistaken - and then modified for C)
01:55:41 <dminuoso> For a web application running a prometheus client, would it make any sense at all to try and run the prometheus on my applications web server?
01:55:59 <merijn> Unrelatedly: We really should have a "flip runReaderT" in transformers so that composing things isn't so awkward all the time...
01:56:02 <dminuoso> My feeling says: unconditionally no, because I dont even want to think about controlling access to different endpoints
01:56:13 <pavonia> ArahaelPi: I'm just not sure how well the compiler can cope with several files
01:56:21 <dminuoso> So Id rather have my web application export prometheus metrics on port XYZ, while running the web servier on port ABC
01:58:45 <ArahaelPi> pavonia: Most pascal and most C programs are processed over multiple files, and LaTeX also very easily supports multiple files as well. (I guess I just answered my question - use LaTeX)
01:59:54 <dminuoso> pavonia: Do you know why the linker is called the linker?
02:00:17 <dminuoso> It links together object files to form a program. We have been linking programs from fragments together for many decades.
02:00:23 <dminuoso> It's not hard.
02:00:44 <Ariakenom> except when it is
02:00:56 <pavonia> dminuoso: This was about the WEB documentaion system, no linking involved here
02:01:27 <dminuoso> pavonia: Oh wait a moment. What is WEB?
02:02:02 <pavonia> The literate programming language Knuth developped
02:02:05 <merijn> dminuoso: Knuth's literate programming tool
02:02:06 <pie__> presumably off topic but since people here presumably like progressing towards reliale systems, probably useful thread https://twitter.com/www_ora_tion_ca/status/1027668858109407232
02:02:40 <merijn> Pfft, I only write the most unreliable of systems!
02:03:20 <dminuoso> pavonia: Ohh sorry. I thought you meant.. nevermind!
02:04:33 <pavonia> No worries, that was a bit offtopic here anyway
02:08:57 <rien_> speaking of off-topic, is there a #haskell-category-theory ?
02:09:15 <dminuoso> rien_: #haskell serves that purpose mostly. Though most CT freaks also hang around in #math
02:09:38 <rien_> dminuoso: Thank you.
02:10:07 <ChaiTRex> How do I make a Haskell program go idle permanently without quitting and without some kind of busy loop (it should use zero CPU time from then on)?
02:10:23 <dminuoso> ChaiTRex: Can you elaborate what you are trying to do?
02:10:24 <merijn> ChaiTRex: "forever $ threadDelay maxBound"
02:11:58 <rien_> Terminology-wise, if Maybe Int is a "functor of Int" because I can send Int's objects and morphisms to Maybe Int, then what is "Int" called in relation to "Maybe Int" given that I cannot send Maybe Int objects and morphisms to Int? Or does it not have a name?
02:12:15 <ChaiTRex> I'm just thinking of what to do if I'm, for example, writing some rewrite rules that can figure out that some pure function will never return with a particular input and replace that call with something that doesn't waste CPU while preserving the behavior.
02:12:45 <ChaiTRex> merijn: Thanks
02:13:21 <mauke> ah, optimized bottom :-)
02:13:30 <merijn> ChaiTRex: That's...an awful use of my suggestion
02:13:39 <ChaiTRex> Haha, OK :)
02:13:39 <Ariakenom> ChaiTRex: Actually I will question that goal. Do you know of exception <<loop>> ?
02:13:50 <mauke> you could also just error "<<loop>>"
02:14:09 <ChaiTRex> If that's considered equivalent, OK. I'll do that.
02:14:15 <ChaiTRex> Thanks.
02:14:31 <mauke> not quite equivalent, but more useful in practice
02:14:47 <mauke> I once wrote an interpreter whose only error "message" was to go into an infinite loop
02:14:51 <Ariakenom> > let x = x in x
02:14:53 <lambdabot>  *Exception: <<loop>>
02:15:00 <mauke> makes debugging your code rather interesting
02:15:05 <dminuoso> rien_: Maybe itself is the functor.
02:15:11 <ArahaelPi> ChaiTRex: If it's a pure function, as you say, then why is it using CPU if it's not required/evaluated?
02:15:18 <dminuoso> rien_: Maybe sends `Int` to `Maybe Int`, `Double` to `Maybe Double`, etc.
02:15:26 <ArahaelPi> ChaiTRex: *something* must be causing it to evaluate.
02:15:29 <dminuoso> rien_: And it sends (+1) to an approriate morphism, etc
02:15:31 <ChaiTRex> ArahaelPi: It's given a value that will lead to an infinite loop or something.
02:15:41 <Ariakenom> "bottoms" tend to be considered the same. exceptions and inf-loops aka non-termination
02:15:45 <ChaiTRex> ArahaelPi: Which will waste CPU time if we can determine at compile time that that will happen.
02:15:50 <ArahaelPi> ChaiTRex: Well, make it more lazy, then?
02:16:00 <ChaiTRex> Ariakenom: Ahh, OK.
02:16:30 <ChaiTRex> ArahaelPi: I mean things like numeric computations where the inputs are essentially strict once they start being processed.
02:16:59 <rien_> dminuoso: I stand corrected - you are right, Maybe is the Functor. Is there a name for the subject type that a Functor is taking to some other type?
02:17:23 <Ariakenom> compile error would be the preferable choice to replace it with though
02:17:54 <ChaiTRex> ArahaelPi: But even things like length . cycle (without an empty list) can qualify.
02:18:09 <Ariakenom> can you rewrite rule to error?
02:18:29 <Ariakenom> can you rewrite rule to compile error?
02:18:30 <ChaiTRex> ArahaelPi: I think so, as long as it typechecks, which error does.
02:18:41 <ChaiTRex> ArahaelPi: I'll check.
02:19:04 <dminuoso> rien_: Category.
02:19:17 <dminuoso> rien_: A functor maps entire categories.
02:19:48 <dminuoso> rien_: In haskell a functor maps Hask to Hask (which is why it's more accurately called endofunctor)
02:21:15 <dminuoso> rien_: The point is, the Functor does not transport any particular type. It maps the entire _category_. Every object (in Hask these are the types), and every morphism (in Hask these are functions)
02:21:32 <rien_> dminuoso: Ah, ok. In other words, whenever I have Functor of X (like Maybe x or [x]) then that necessarily means that viewing X as a Category is a valid interpretation? Why is Hask the Category here and not Int, in Maybe Int?
02:21:58 <dminuoso> rien_: Again, it's not `Maybe x` that is the functor, it's just `Maybe`
02:22:23 <dminuoso> rien_: Well if you can find a category where what you are saying makes sense, then it's also a functor in there.
02:22:24 <rien_> dminuoso: I keep writing it incorrectly even though I have understood that point.
02:23:06 <dminuoso> rien_: What would the category `Int` look like?
02:23:11 <dminuoso> What are its objects? What are its morphisms?
02:23:15 <rien_> dminuoso: Let me rephrase. You say in Haskell a functor maps Hask to Hask. But I don't write Maybe Hask, I write Maybe Int. I'm having trouble differentiating CT things from Haskell things.
02:23:31 <rien_> dminuoso: Like Yann Esposito's graphi representations
02:23:35 <dminuoso> rien_: Hask is a bit fuzzy and exists only in our imagination (and some CT inclined heavy libraries)
02:24:05 <dminuoso> rien_: `Maybe Int` can be thought of taking the functor `Maybe` and applying it to an object `Int`
02:24:22 <rien_> dminuoso: Here is where I saw graphic representations of the Categories Int and String, for example: http://yannesposito.com/Scratch/en/blog/Category-Theory-Presentation/
02:24:37 <ArahaelPi> I've just tried to do a 'stack init', and got: Unable to parse cabal file for bhoogle-0.1.3.4@sha256:7c54134733cded07e263fced4dc08141f9bc20292d676d218323704b0264aae0,1806: NoParse "license" 7
02:25:15 <dminuoso> rien_: where at?
02:25:15 <AWizzArd> When I have a Data.Map I can use fmap to compute a new Map where the keys stay the same but where I possibly have new values for the Map-values. If I want to do this with the keys and not the values of the Map I would have to use mapKeys for example.
02:25:15 <ArahaelPi> How do I fix that?
02:25:33 <AWizzArd> Is there a Bifunctor implementation which could also map over the keys?
02:26:06 <rien_> dminuoso: Degenerated Categories
02:26:40 <dminuoso> rien_: Not sure what I should look out for
02:27:02 <rien_> dminuoso: Degenerated Categories: Monoids
02:27:13 <rien_> dminuoso: on that slide there's a graphic of Int and String as a category
02:27:42 <dminuoso> rien_: Id say ignore that for now.
02:27:44 <Ariakenom> AWizzArd: They keys' constraint, Ord?,pose an issue, don't they?
02:27:54 <rien_> dminuoso: Well, that is what I am trying to understand now.
02:28:04 <dminuoso> rien_: When we say `Maybe` is a functor, we really mean that it maps Hask (the category where objects are types, and morphisms are functions) back to Hask
02:28:06 <dminuoso> In such a way that:
02:28:16 * ArahaelPi deletes the project entirely, and repeats "stack new foo"
02:28:18 <dminuoso> fmap id = id; fmap f . fmap g = fmap (f . g)
02:28:24 <rien_> dminuoso: it seems there are parallel interpretations of which things are being considered Categories and morphisms and objects at any given time
02:28:41 <dminuoso> rien_: Also note that a free theorem states that you can recover one from the other in Haskell - so in practicality its enough to state: fmap id = id
02:29:03 <dminuoso> rien_: absolutely yes.
02:29:41 <dminuoso> rien_: if you can find a set of objects and draw arrows such that, every object has an id arrow, and arrows associatively compose into new arrows - then you have a category
02:29:48 <dminuoso> the popular ones we usually name
02:29:51 * ArahaelPi tries stack upgrade, on a whim.
02:29:52 <dminuoso> Hask is one such category
02:30:24 <dminuoso> rien_: Functor usually even maps from one category to another!
02:30:24 <AWizzArd> Ariakenom: I see, yes, thx.
02:30:34 <dminuoso> rien_: It's just that in Hask you usually only have boring endofunctors.
02:30:35 <rien_> dminuoso: I'm processing what you're saying, I appreciate the help... let me think a bit :)
02:31:17 <dminuoso> rien_: One cool Functor for example is the hom functor, that lets you map *any* category into Set.
02:31:53 <rien_> dminuoso: Well, let me start from something more familiar. I'm glad you used the word recover there, allow me to use it more generally. Can I recover Int from Maybe Int? (I expect the answer to be no)
02:32:00 <ChaiTRex> Ariakenom: error works: https://ideone.com/7AkZZ6
02:32:17 <dminuoso> rien_: No you cannot!
02:32:18 <rien_> And the reason being that Nothing in Maybe Int would not map to anything in Int.
02:32:26 <dminuoso> rien_: Exactly. :)
02:32:28 <ArahaelPi> Well, stack upgrade fixed it. :)
02:32:39 * ArahaelPi appologises for the noise.
02:32:45 <rien_> dminuoso: Really? Is the reason correct as well?
02:34:09 <Ariakenom> ChaiTRex: Yes. I meant can you make it a compile error?
02:34:18 <ChaiTRex> Ariakenom: Ahh.
02:35:13 <dminuoso> rien_: Strictly speaking you can if you admit bottom - but when we talk CT we have to really pretend there is bottom.
02:35:22 <dminuoso> *there is no bottom
02:36:27 <rien_> dminuoso: Ok, then allow me to ask this question which is what I am trying to figure out... please bear with me :)
02:36:37 <dminuoso> rien_: Though let me rephrase: it depends what you want really
02:36:44 <dminuoso> f :: Maybe Int -> Int; f = 1
02:36:45 <rien_> dminuoso: go on
02:36:49 <dminuoso> *f _ = 1
02:37:01 <dminuoso> rien_: So just making an Int out of Maybe Int is no problem.
02:37:16 <rien_> dminuoso: but categorically I cannot "get" Int from any (or for all) Maybe Int, right?
02:37:33 <dminuoso> rien_: The core essence of a functor is not just the fact that it maps types, but that it also maps functions in a composition-preserving manner
02:38:00 <dminuoso> rien_: I just showed you that there is a morphism `Maybe Int -> Int`
02:38:19 <rien_> dminuoso: I get that part, that it also maps morphisms preserving the structure, namely the composition.
02:38:55 <dminuoso> rien_: A functor is a morphism in Cat, the category of categories!
02:39:07 <dminuoso> rien_: From that point we can talk about mono- and epimorphisms.
02:39:11 <rien_> dminuoso: That means little, no? There is a morphism for any A -> B by ignoring A and giving some predefined B.
02:39:43 <dminuoso> rien_: You asked for a morphism `Maybe Int -> Int`, I gave you one. Not sure what you are looking for.
02:40:16 <dminuoso> rien_: If you want some general `Unmaybe` then no, such a functor does not exist I think.
02:40:43 <dminuoso> rien_: Part of the problem is surjectivity.
02:41:16 <rien_> dminuoso: No, allow me to rephrase. I asked if I can "always" go from Maybe Int to Int. Because I see Maybe Int as "Int + a token" so it seems you can always go from a set of n things to a set of n+1 things by just leaving the "token" thing without an arrow pointing to it. Does that make sense?
02:41:31 <rien_> dminuoso: Yes I believe that is what I am getting at.
02:41:42 <dminuoso> rien_: what would Unmaybe do to `Int`
02:41:47 <dminuoso> What would it map `Int` to?
02:42:38 <rien_> dminuoso: Int -> Maybe Int is injective-only
02:42:42 <dminuoso> rien_: You're too focused on `Maybe Int` and its internals really.
02:43:21 <rien_> dminuoso: Unmaybe cannot be written, or not without making choices, no?
02:43:36 <dminuoso> rien_: The problem begins with: What about Int? What about ()
02:43:46 <dminuoso> rien_: If you want to write a functor Unmaybe, you have to map these too.
02:44:46 <dminuoso> rien_: since you cant know which type you get, you cant even handle the Nothing case to begin with.
02:45:06 <rien_> dminuoso: yes! I agree. We are totally on the same page here.
02:45:08 <rien_> Therefore...
02:45:16 <dminuoso> The whole thought.. uh.
02:45:57 <rien_> dminuoso: (I'm typing a question that I was leading to)
02:46:40 <rien_> It is only with this precise "categorical frame-level", namely that of considering Maybe as a Functor for anything, instead of an endofunctor of Hask, that we can say that we cannot reverse it (that we cannot write an Unmaybe) - yes?
02:47:25 <rien_> if we were talking at the level of endofunctors of Hask then one could reasonably expect Unmaybes to be perfectly sane
02:47:56 <dminuoso> rien_: in the category of functors morphisms are called natural transformations.
02:48:17 <dminuoso> rien_: one nice example is listToMaybe
02:48:49 <dminuoso> rien_: these require naturality though..
02:49:34 <dminuoso> rien_: so what you would need is a natural transformation `Maybe -> Identity`, which you cant write satisfying naturality laws
02:50:32 <ArahaelPi> How do I express a context-dependant AST in Haskell?
02:50:38 <dminuoso> rien_: Just consider the trivial example of: `Maybe Void -> Identity Void`, good luck writing that.
02:50:51 <ArahaelPi> (Eg, C code, with preprocessor stuff)
02:50:57 <Axman6> ArahaelPi: what do you mean?
02:51:42 <rien_> dminuoso: Ok, I appreciate your help. :) I don't think I am at the level where I can phrase my question yet. Your corner cases are unconvincing to me because I am talking only about the levels that we can choose to name things categories...
02:51:55 <ArahaelPi> Axman6: Well, suppose I want to define a notion that a C file consists of a list of function declarations and function implementations, but allow for a preprocessor line to redefine keywords from that point down, and still have it represented as a single grammar.
02:52:07 <dminuoso> rien_: Do you know the type Void?
02:52:21 <rien_> dminuoso: the category with no objects ?
02:52:33 <dminuoso> rien_: the *type* with no objects (again pretending bottom does not exist)
02:52:38 <dminuoso> It's devoid of any objects.
02:52:49 <ArahaelPi> Axman6: I'm finding that I can express the AST, except that allowing a preprocessor mark to be put in *anywhere* makes it really hard to define the concrete grammar.
02:52:51 <rien_> dminuoso: why is it wrong the way I said it?
02:53:18 <dminuoso> rien_: well I suppose its also some category, but thats really irrelevant
02:53:39 <dminuoso> rien_: my point is: Void has 0 inhabitants. Identity Void has 0 inhabitants. Maybe Void has 1 inhabitant.
02:54:33 <ArahaelPi> Axman6: I think I'm forced to consider it as a two-pass syntax - first parse: Figure out the preprocessor and handle that - second pass, the real language.
02:54:40 <rien_> dminuoso: Ok, so I understand what you're saying. You're just trying to keep me at this categorical-level of seeing things, with Hask and so forth, and away from categorical-level explorations as that of Esposito's, right?
02:54:55 <rien_> dminuoso: I agree with all those statements.
02:55:30 <rien_> dminuoso: That is why I said Maybe is a functor that adds one token, or one object, to a category.
02:55:52 <dminuoso> rien_: A type theory way of looking at Maybe is +1
02:55:56 <rien_> dminuoso: And that is why I use it in my examples, as it is of a small structure and easy to understand why I cannot go back to Int from Maybe Int
02:55:59 <dminuoso> rien_: It adds one to an arbitrary type =)
02:56:08 <dminuoso> Or `+()` if you want
02:56:23 <dminuoso> rien_: Again. You can go back to Int from Maybe Int.
02:56:33 <rien_> dminuoso: I totally agree, indeed that is how I see it, see above my idea of seeing it as "adding a(n opaque) token to a type (or an object to a category)"
02:56:39 <rien_> dminuoso: No, please.
02:56:46 <rien_> dminuoso: we're talking in different levels.
02:56:52 <rien_> dminuoso: at the function level yes you can
02:56:52 <dminuoso> rien_: My point is: chose your words carefully.
02:56:59 <rien_> dminuoso: at the categorical level you cannot
02:57:06 <rien_> I'm asking precisely which words should I use
02:57:17 <rien_> dminuoso: how do you call this categorical level shifting?
02:57:28 <dminuoso> rien_: When you say "I cannot go back to Int from Maybe Int", the only way that sentence makes sense to me is "there is no morphism from Maybe Int to Int in Hask"
02:57:44 <dminuoso> In the category of Hask where types are objects and functions are morphisms, there exists a morphism going from Maybe Int to Int.
02:57:52 <dminuoso> f :: Maybe Int -> Int; f _ = 1
02:57:54 <rien_> dminuoso: I mean it as "there is no Functor from Maybe Int to Int generally" -> thank you for telling me how you read it!
02:58:02 <dminuoso> rien_: Again. Functors act on categories.
02:58:41 <dminuoso> rien_: what you seem to be asking for is a natural transformation: η_x : Maybe x -> Int x
02:58:45 <dminuoso> rien_: what you seem to be asking for is a natural transformation: η_x : Maybe x -> Identity x
02:58:53 <rien_> dminuoso: again, I think we are talking about different categorical-levels... I'm not talking about any space where "Hask" exists... I am talking purely in terms of commutativity, in other words, it's not because some functor F takes me from A to B, that I can go from B to A, right?
02:59:13 <dminuoso> rien_: the functor takes you from Hask to Hask.
02:59:18 <dminuoso> Not from Int to Maybe Int.
02:59:21 <dminuoso> Hask to Hask.
02:59:24 <rien_> a functor guarantees only one direction, right?
02:59:36 <jit10> haskell functors are endofunctors :)
02:59:55 <dminuoso> rien_: an endofunctor has no direction.
02:59:58 <rien_> jit10: only if you choose that categorical level way of looking at it
03:00:29 <rien_> jit10: for instance, Yann Esposito consistently choose other categorical levels, as in, he represents an Int and a String as a category... so it depends on your chosen perspective, right?
03:00:39 <dminuoso> Maybe : Hask -> Hask
03:00:57 <dminuoso> Since it takes you from Hask to Hask, you can easily go back to Hask from Hask.
03:01:11 <dminuoso> Any endofunctor will do.
03:01:47 <dminuoso> rien_: Then define your category, and formulate your question within that category.
03:02:30 <dminuoso> rien_: When we talk CT in Haskell we usually only talk about Hask, Set and some other categories
03:02:39 <rien_> dminuoso: I totally agree again, and I understand those statements you made.
03:03:07 <rien_> dminuoso: Ah, ok. So Yann Esposito is an exception in that he ... what? changes his categorical perspective?
03:03:26 <dminuoso> rien_: He's trying to talk about monoid categories.
03:03:41 <dminuoso> rien_: It may be useful to think of a category as a generalization of a monoid.
03:03:45 <rien_> dminuoso: Also in tutorials like this, isn't the author playing with, or changing this "categorical perspective" that I'm trying to express? http://www.stephendiehl.com/posts/monads.html
03:04:20 <dminuoso> rien_: Yes.
03:04:20 <rien_> dminuoso: Ok I'll bite :) how is a category a generalized monoid?
03:04:36 <dminuoso> rien_: a monoid is a single-object category. a category is a multi-object monoid.
03:05:23 <rien_> dminuoso: ah ok, that makes sense and I can see that. That is quite interesting :)) but I can see it, wow.
03:05:39 <rien_> it's a very creative way of seeing it, I hadn't come across that description before
03:06:30 <dminuoso> rien_: Basically what happens, is that you can have the category of categories, where objects are categories and morphisms are functors.
03:06:44 <dminuoso> rien_: you can also have a category of functors, where objects are functors are morphisms are natural transformations
03:06:49 <dminuoso> and you can have a category of endofunctors... etc..
03:06:59 <rien_> dminuoso: Ok so here is the thing, I want to draw (for my own learning purposes) these CT graphs of some of my Haskell code. But I cannot trust myself that I will not switch categorical levels halway through and confuse myself. How do I stay on one path?
03:07:08 <dminuoso> rien_: monads can be described by looking at a particular monoidal category of endofunctors.
03:07:26 <dminuoso> where that monoidal category of endofunctors is equipped with a particular tensor of functor composition
03:07:27 <rien_> dminuoso: It doesn't seem useful to consider Hask -> Hask as I draw those graphs so I am talking about living in Yann Esposito's perspective
03:08:48 <dminuoso> rien_: Functors are very basic, so..
03:09:34 <dminuoso> rien_: The best you can do is draw diagrams. Name your objects and morphisms. Maybe give them concrete names if that helps.
03:11:08 <rien_> dminuoso: If you look at Esposito's slide *above* doing ctrl+f for "Haskell Kinds", that graph on that slide entitled Hask... I'd be drawing at that level, and Hask would never be mentioned, right? 
03:12:23 <dminuoso> rien_: You can give the box a title "Hask" if you want.
03:12:44 <dminuoso> rien_: when you work with multiple categories and functors between them you really want to name them. ;)
03:13:31 <dminuoso> rien_: http://ncatlab.org/nlab/files/functor.jpg
03:13:40 <dminuoso> rien_: here you can see a functor F : C -> D
03:14:11 <rien_> dminuoso: Absolutely! I agree. And if I were to "enter" the categorical-level of the Int on that graph, then I would be at the categorical level of that other graph you saw where Int was illustrated as a monoidal category, right? I'm just asking about moving categorical frames
03:14:24 <rien_> Am I stepping them correctly when I say that?
03:14:57 <dminuoso> rien_: Well `Int` has no intrinsic category level. It's rather that you look at some category (Int, +, 0)
03:14:57 <rien_> dminuoso: and at that other graph we could draw a box around it and name it Int
03:15:20 <rien_> dminuoso: there are "intrinsic category levels" ? Or do you mean intrinsic to Haskell?
03:15:29 <dminuoso> rien_: well you keep saying "categorical level.."
03:15:29 <rien_> as in, the one Haskell chose
03:15:35 <dminuoso> Not sure what thats supposed to mean =)
03:15:41 <rien_> dminuoso: what!?
03:16:10 <rien_> dminuoso: remember you told me to ignore the "level" where we can see that Int is a monoidal category, when I showed you that Yann Esposito slide?
03:16:30 <dminuoso> rien_: Call it (Int, +, 0)
03:16:51 <dminuoso> It's a monoid, and all monoids trivially form a category.
03:17:27 <rien_> dminuoso: I don't want to make you repeat yourself. I understand that.
03:17:38 <rien_> dminuoso: What I am getting at is what I meant when I said this: "it seems there are parallel interpretations of which things are being considered Categories and morphisms and objects at any given time"
03:17:50 <rien_> and you said "aboslutely yes" and went on to describe how and I get it.
03:18:08 <Taneb> (I wonder if there's a case for adding newtype MonoidCategory m a b = MonoidCategory m; instance Monoid m => MonoidCategory m to base)
03:18:16 <dminuoso> rien_: Right! There are many many categories.
03:18:27 <dminuoso> rien_: And you can have multiple monoids with Int by the way. :)
03:18:31 <rien_> dminuoso: But we can't mix how we view them
03:18:37 <dminuoso> rien_: Well you can..
03:18:39 <rien_> or can we?
03:18:47 <dminuoso> rien_: functor is the principle mechanism.
03:18:57 <dminuoso> rien_: a functor goes from some category A to another category B
03:19:07 <dminuoso> rien_: the hom-functor takes an *arbitrary* category and maps it to Set.
03:19:21 <dminuoso> Set is the name of a particularly popular category where objects are sets and morphisms are functions
03:19:23 <rien_> if we can mix how we view them, then why did you tell me not to pay too close attention to Yann Esposito's representation of Int and String as  category?
03:19:28 <rien_> *as a category*
03:19:35 <dminuoso> rien_: for now =)
03:20:04 <rien_> dminuoso: until I learn what? I don't know what I'm missing, given I understood everything you said.
03:20:33 <dminuoso> Nevermind me then :)
03:21:26 <rien_> dminuoso: No problem, that is why I was asking about this "level", because I thought you were saying the reason to ignore it was because Haskell did not *choose* to see Int as a category
03:21:28 <rien_> even though we can
03:21:41 <rien_> hence why I talked about what level did Haskell choose
03:21:56 <rien_> dminuoso: and its need to keep at that level
03:22:25 <rien_> Haskell never "slips" and accidentally sees Int and String as categories, therefore something is "keeping it at that level"
03:22:47 <rien_> but no one talks about this and the tutorials mix the levels... 
03:23:00 <dminuoso> rien_: There's not really "levels"
03:23:10 <dminuoso> rien_: Think of a category as a big bag. You can have multiple bags on your desk cant you?
03:23:36 <rien_> dminuoso: but do you understand what I'm saying? How can I have confidence that when I look at a graph, it's showing me the way Haskell sees things, versus some arbitrary way we could choose that also conforms to category laws?
03:23:43 * hackage scanner 0.3 - Fast non-backtracking incremental combinator parsing for bytestrings  http://hackage.haskell.org/package/scanner-0.3 (YurasShumovich)
03:23:43 <dminuoso> rien_: There is some hierarchy of categories, but that's rather when you consider the category of categories, or category of functors.
03:24:39 <rien_> dminuoso: I don't know, can I? Can Haskell see Int and String as categories the way Yann Esposito sees it? Isn't the answer to that something like Stephen Diehl's Monads Made Difficult? that is what I'm trying to undeerstand
03:25:40 <dminuoso> rien_: Haskell has no perspective
03:26:52 <rien_> dminuoso: It seems Haskell clearly chose some things to be functions, others to be Functors, and others to be NTs
03:27:12 <rien_> as if it chose to remain at a certain level
03:27:20 <dminuoso> rien_: Haskell has types and functions. The category notion is just us developers. :)
03:27:34 <dminuoso> rien_: If we squint a bit we can make out some categories.
03:27:37 <rien_> dminuoso: Hmm...
03:28:05 <dminuoso> rien_: The closest relationship to category theory is just burrowing some names like Functor
03:28:57 <rien_> dminuoso: I see what you mean... in that case, do you happen to know, in Type Theory alone (without CT), what is a Functor?
03:29:12 <rien_> That is what I need to read next!
03:29:36 <dminuoso> rien_: higher kinded types?
03:29:57 <dminuoso> % :k Maybe
03:29:58 <yahb> dminuoso: Maybe :: * -> *
03:30:05 <rien_> dminuoso: Oh...
03:30:21 <rien_> dminuoso: So a language without HKT cannot have functors? Elm can't have them, then?
03:30:23 <dminuoso> % :k Functor
03:30:23 <yahb> dminuoso: Functor :: (* -> *) -> Constraint
03:30:28 <dminuoso> rien_: Correct.
03:30:44 <rien_> % :k Monad
03:30:44 <yahb> rien_: Monad :: (* -> *) -> Constraint
03:31:09 <rien_> so for Type Theory, both Functors and Monads are the same thing?
03:39:13 * hackage socket 0.8.1.0 - An extensible socket library.  http://hackage.haskell.org/package/socket-0.8.1.0 (LarsPetersen)
03:40:03 <pie__> if i want to push/pop on a mutable fifo, do i just stick it in an ioref and write a lpush and a rpop (or whatever) with atomicModifyIORef'?
03:45:32 <madnight> pie: why not State Monad?
03:47:18 <pie__> madnight, idk how to use it
03:47:29 <pie__> can I pass that around like a reference?
03:47:37 <pie__> ive kind of been using ioref like a pointer
03:48:04 <ArahaelPi> Can I "automatically" derive instances for my data types? (I'm tired of typing "deriving (Show)" all the time)
03:48:05 <rien_> pie__: This really helped me understand when to use which kind of mutation: https://www.youtube.com/watch?v=thyO6p2bMAc
03:48:13 * hackage universum 1.3.0 - Custom prelude used in Serokell  http://hackage.haskell.org/package/universum-1.3.0 (gromak)
03:48:20 <quicksilver> as a general learning tip if you're asking questions about mutable data and you haven't learn how to use the state monad yet, you're doing it backwards
03:48:26 <pie__> rien_, thanks
03:48:27 <quicksilver> learn the idiomatic way first
03:48:42 <quicksilver> and then learn the (really very limited) circumstances under which you actually want mutation
03:49:01 <pie__> quicksilver, eh, youre not wrong.
03:49:04 <rien_> pie__: in the first few minutes he gives a brief overview of when to use which
03:49:20 <pie__> (also, bbiab need to eat lunch so i can function)
03:49:26 <ventonegro> "You can write FORTRAN in any language"
03:49:58 <ArahaelPi> ventonegro: But can you write Haskell in FORTRAN?
03:50:08 <madnight> pie, my experience with state monads is that you can programm with them in am imperative programming style with for loops and so
03:50:13 <pie__> ;D
03:50:33 <ventonegro> ArahaelPi: Sure, write an interpreter in FORTRAN first :)
03:50:42 <ArahaelPi> ventonegro: Bah!
03:50:55 <ArahaelPi> ventonegro: Could write Fortran in Haskell, *without* writing the compiler!
03:52:28 * ArahaelPi cut&pastes yet another "deriving (Show)"
03:53:16 <madnight> http://www.cis.upenn.edu/~cis552/current/lectures/soln/STMonad.html
03:55:39 <merijn> Writing C in Haskell is downright easy, just put IO and Ptr everywhere and make sure to use lots of MagicHash :p
03:56:49 <carlosdagos> @merijn hahaha
03:56:50 <lambdabot> Unknown command, try @list
03:56:51 <merijn> quicksilver: tbh, I'm using more and more mutation over time, then again, I'm pretty sure I've mastered the "no mutation" part by now :p
03:57:16 <madnight> or state monad and for, while and the like are just functions and pointer is STref
03:57:34 <merijn> carlosdagos: The best part, it's 100% true. Writing C in Haskell is really easy and fairly nice (compared to writing actual C)
03:58:03 <Ariakenom> merijn: How will I get all my implicit conversions though? (1::Word8)+1 doesn't involve Int at all!
03:58:18 <carlosdagos> @merijn I know, for example: http://hackage.haskell.org/package/inline-c
03:58:19 <lambdabot> Unknown command, try @list
04:00:00 <madnight> Ariakenom: implicit conversion is possible with template haskell
04:00:43 * hackage haskell-postal 0.1.0.0 - Haskell binding for the libpostal library  http://hackage.haskell.org/package/haskell-postal-0.1.0.0 (netom)
04:00:56 <quchen> Ariakenom: Haskell doesn’t do any implicit conversions.
04:01:40 <madnight> quchen: *in Haskell 2010
04:02:00 <merijn> It never does implicit conversions in any extensions in GHC either
04:02:49 <Ariakenom> Eh. Yes, that's what I was trying to say. I would like my 8 bit char operations to involve 64 bit ints pls
04:02:57 <madnight> merjin: how come that you can write inline c with template haskell?
04:03:22 <merijn> madnight: That uses Template Haskell to generate and compile C at compile time
04:03:23 <madnight> merjin: C has implicit conversion as far as i know
04:03:40 <merijn> madnight: That's like saying haskell has implicit conversions because I can call C via the FFI
04:03:46 <quchen> Java has objects and you can write a Java compiler in Haskell, that doesn’t make Haskell OOP either
04:04:02 <madnight> merijn: template haskell == haskell extension
04:04:17 <merijn> madnight: inline-c still doesn't do implicit conversion
04:04:22 <merijn> madnight: It just calls C code via the FFI
04:04:47 <ChaiTRex> Does pinning an array affect garbage collection other than not moving things around (for example, will it lead to less frequent garbage collection or freeing of that object when it's no longer in use?)?
04:04:50 <merijn> So Template Haskell doesn't add implicit conversions to Haskell in any shape or form
04:05:14 <merijn> ChaiTRex: Well, not moving it around makes GC faster
04:05:31 <merijn> ChaiTRex: Since GHC uses a copying GC, reducing the amount it has to copy reduces the time it takes to perform GC
04:05:48 <madnight> merijn: that's like saying unsafePerfomIO is pure, because Haskell is a pure Language
04:05:51 <ChaiTRex> merijn: Is the pinned area outside of being garbage collected at all?
04:05:52 <merijn> ChaiTRex: A pinned array just has to have the pointer copied, rather than the entire array + contents
04:06:00 <madnight> merijn: that does not make sense
04:06:23 <Ariakenom> merijn: But freeing it costs instead
04:06:30 <merijn> ChaiTRex: That...is a good question? Can you store boxed values in those arrays?
04:06:33 <merijn> Ariakenom: Not a lot, tbh
04:06:59 <ArahaelPi> Ariakenom: In most GC's, free'ing something is free.
04:07:24 <merijn> ArahaelPi: Well, it has to maintain a pointer of all pinned arrays to remember where they are (and remember to free them)
04:07:30 <Taneb> Do the extensions that GHCi enable apply to files loaded with :l
04:07:31 <Taneb> ?
04:07:37 <merijn> ArahaelPi: But overall it's pretty cheap
04:07:39 <Ariakenom> The usual freeing is to not copy. Which is quite cheap
04:07:53 <ArahaelPi> merijn: Yes, but you can just like, set it to nil, and let the GC figure out what memory is still being used, completely ignoring the garbage.
04:07:54 <merijn> Taneb: ghci has a separate flag for extensions active in the REPL and those active in the loaded files
04:08:03 <merijn> Taneb: Consult GHC user's guide for details, etc. :)
04:08:13 <quchen> Taneb: No, each file is loaded with its own set of extensions. Just imagine the havoc enabling bang patterns on files written with (!) infix operators might cause
04:08:33 <ChaiTRex> merijn: It looks like only ByteArray#s (and mutable ones) can be pinned, at least in GHC.Exts.
04:08:41 <quchen> f ! x = x -- id or (flip const)?
04:09:13 <Ariakenom> :t const id
04:09:14 <lambdabot> b -> a -> a
04:10:37 <hexagoxel> ChaiTRex: iirc pinned objects live in a separate heap
04:11:14 <ChaiTRex> hexagoxel: Does the RTS garbage collect or free things there automatically?
04:11:23 <Taneb> merijn: quchen: thanks
04:11:31 <merijn> ugh...sometimes I miss mutable global state >.>
04:12:47 <marvin2> merijn top-level IORef + unsafePerformIO to initialize it?
04:13:02 <merijn> marvin2: Yeah, but that doesn't quite work out here either :)
04:13:14 <hpc> if the IORef is polymorphic you get unsafeCoerce out of that
04:14:22 <ChaiTRex> Ahh, it looks like it is garbage-collectable (https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC/Pinned)
04:14:40 <merijn> hpc: Basically, I want to use haskeline's completion, but I need to get completion from an externals process which is a little slow, so I wanna asynchronously run them in the background, but that means I need to somehow lift the completion request to the start of the program from their current location
04:15:06 <hpc> ah
04:15:27 <hpc> and that would mean threading a whole bunch of state from main to this deep haskeline call
04:16:03 <merijn> From main to the deep call is easy, but not all of them I can know in advance, so I also need to be able to register new ones as I go :\
04:16:17 <merijn> hpc: So it's just really a nasty hassle
04:18:45 <ArahaelPi> ChaiTRex: Imagine that you have memory - four locations.  You've used 3 of them, say, the memory now looks like "xx.x".  You decide to free the item at memory location 3.  A GC will report "You have used memory locations "xx..", and you infer that the '  **' items are free.
04:19:43 <ArahaelPi> ChaiTRex: Like dumping things on your table,  you check for locations where you *don't* want to dump things on, eg, your keyboard.  And you pick one of the remaining spaces available.
04:22:22 <olligobber> I installed ghc on arch, but I think I did something wrong: https://gist.github.com/olligobber/b28ae05b10cbf11934028269dd7e7345
04:23:03 <hpc> olligobber: if you installed it with pacman, arch's packaging of ghc has some major fundamental issues
04:23:14 <hpc> olligobber: check the arch wiki for how to work around it
04:24:14 <MarcelineVQ> "Could not find module ‘Prelude’" often means you're building statically and should install the  ghc-static  package
04:24:21 <olligobber> or I can use `-dynamic` when compiling
04:24:38 <olligobber> MarcelineVQ, thanks!
04:25:18 <MarcelineVQ> It's cabal-install that dies on me on arch these days, that's a dumptruck load of notfun
04:31:03 <merijn> Or just install GHC via bindist ;)
04:32:19 <hpc> or do everything in a stack project
04:32:31 <MarcelineVQ> there's something insidous that's wrong, stack installed caba-install, manually installed, pacman installed, and even nix installed all over different (2.0+) versions all die on me hehe
04:32:50 <MarcelineVQ> on different things, constrained solving or building, it's so weird
04:32:58 <merijn> hpc: Then I have to learn and deal with stack, though
04:33:32 <hpc> it's not that hard
04:34:07 <yushyin> Well, stack also had some problems some time ago with installing the correct ghc ... Something something about pic 
04:34:18 <merijn> hpc: Learning not, no. Dealing with is, I don't like stack's workflow
04:34:28 <madnight> better skip stack and fast forward to 2018: cabal2nix
04:35:11 <MarcelineVQ> speaking of which, what's the workflow for nix + newbuild?
04:35:57 <MarcelineVQ> I mean, you don't use newbuild with nix afaik, but eventually newbuild will be build, so that's why I ask
04:36:14 <merijn> madnight: Try asking in #hackage?
04:36:21 <merijn> s/madnight/MarcelineVQ
04:36:53 <MarcelineVQ> It's not on my radar just now just curious since there's more nix people every day
04:37:03 <hexagoxel> building stack itself is fun, too. you just need the right combination of versions, see https://matrix.hackage.haskell.org/package/stack
04:37:15 <hexagoxel> that one green field :D
04:37:17 <madnight> newbuild is the wrong answer to an already existing solution, namley nix
04:37:54 <MarcelineVQ> you can get a bin to get stack going, better than what their sh script does that's for sure
04:39:53 <merijn> hexagoxel: Are you really surprised stack only really builds well on stack?
04:42:34 <madnight> it's like ghcjs that only really builds well with nix
04:42:59 <hpc> huh
04:43:21 <hpc> it'd be neat to have hackage matrix available as something you could install on your workstation
04:43:36 <merijn> hpc: Ask hvr? :)
04:43:45 <hpc> hvr: ask
04:43:50 <hpc> :)
04:44:08 <hexagoxel> nah, i am just confused why they don't publish their boot-strapping scripts
04:44:34 <hexagoxel> that they say "fuck cabal" all while complaining about people saying "fuck stack" is given
04:44:38 <hpc> imagine being able to check that table before doing a release of your code :D
04:45:10 <merijn> hpc: Travis CI integration ;)
04:45:11 <MarcelineVQ> where are all these people that says these things I keep hearing about
04:45:17 <hexagoxel> (this is such a lovely topic :D)
04:46:10 <hpc> merijn: put each row of that matrix on hackage itself
04:57:53 --- mode: glguy set +v dataN
04:57:55 <dataN> is there a way to use the MINIMAL pragma to distinguish trivial and sufficient superclasses in type synonyms?
05:07:26 <dataN> hmmm, maybe as constraints are order independent constraint synonyms could just be separated into two sets of parenthesis, though thats not a language feature to make it a documented convention..
05:17:22 <osa1> anyone know if `stack build --fast` builds deps in fast mode too?
05:19:13 * hackage hw-bits 0.7.0.3 - Bit manipulation  http://hackage.haskell.org/package/hw-bits-0.7.0.3 (haskellworks)
05:20:13 * hackage hw-prim 0.6.2.5 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.5 (haskellworks)
05:23:18 <dminuoso> Is there a way to hook into all requests with servant?
05:23:27 <dminuoso> Need to insert some instrumentation.. =)
05:29:54 <quchen> dminuoso: Hook into? Servant gives you an Application, and you could wrap that using Middleware = Application -> Application
05:34:22 <c50a326> hey, any recommendations for very gentle/basic introductory stuff on "parsers"? I've tried reading a bunch of stuff and I just don't understand any of it... :(
05:35:20 <Ariakenom> > lines "abc\ndef\n" -- done
05:35:22 <lambdabot>  ["abc","def"]
05:36:18 <c50a326> well I'd like to understand the monadic parsing in haskell paper
05:36:32 <lavalike> c50a326: this is an evergreen https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf
05:40:18 --- mode: glguy set +v Fobbb
05:40:43 * hackage irc-core 2.5.0 - IRC core library for glirc  http://hackage.haskell.org/package/irc-core-2.5.0 (EricMertens)
05:42:19 --- mode: glguy set +v Fobbbb
05:42:23 <Fobbbb> Hi. Anyone used xlsx package before? How do I get a String or ByteString from a CellValue type?
05:45:28 <dyamon> hi all! It's the first time I'm dealing with a somewhat bigger project and I have some doubts on the folder structure. Let's say I have src/Foo/Types.hs and src/Bar/Types.hs and a fist level src/Types.hs that imports the previous files and re-exports them. I'd like for files in src/Foo or src/Bar to import only "their" Types.hs and not depend in any way on the others (or on the src/Types.hs). Is this the 
05:45:34 <dyamon> common way of doing thing? Or I'm just making things more complex?
05:45:38 <glguy> Fobbbb: A CellValue can be a Text which you can then unpack to a String
05:45:59 --- mode: glguy set +v _sras_
05:46:06 <_sras_> Can someone please review some Haskell code that I wrote to work with money values in a typical web app. The code uses some extensions such as GADTs, ExistentialQuantifications, DataKinds, and I want to know if there is something wrong/stupid in how I use this, and if the same can be achieved in a simpler manner.Here is the link, https://bitbucket.org/sras/scratch/src/6b4731caddca8c2adb1c09306187ed9427286f81/src/Money.hs?at=haskell-money-existential&fileview
05:46:06 <_sras_> er=file-view-default
05:46:35 <[exa]> _sras_: what do you expect from the reviewer btw?
05:48:13 * hackage glirc 2.28 - Console IRC client  http://hackage.haskell.org/package/glirc-2.28 (EricMertens)
05:48:20 <[exa]> _sras_: I'd avoid getting the exchange rate at the exact conversion moment btw, esp. if people will be allowed to trigger exchange by clicking. Also you don't seem to deal with rounding anywhere, which is very expectable with money
05:49:08 <_sras_> [exa], I would like them to look at how I am using the extensions and if I am over engineering things. Also I would like to know if this achieves additional type safety by using these extensions.
05:49:48 <[exa]> _sras_: safety against what?
05:51:44 <[exa]> _sras_: but yes otherwise it looks good, at least at the first look.
05:51:47 <_sras_> [exa], Regarding rounding issues, I think I have let the option to select the underlying data type for the money values to the user. 
05:52:27 <c50a326> oh wow this paper answered my problems concisely in just a few paragraphs in 2.1 http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf
05:53:24 <[exa]> _sras_: rounding is a complex issue, eg. most accounting systems require that you round differently in different stages of computation and you'll certainly want to choose appropriate rounding method for calculating exchange rates etc... but well, your code is probably ready for most of that
05:55:05 <Fobbbb> Still getting "Couldn't match expected type ByteString with the actual type CellValue"
05:56:05 <_sras_> [exa], Safety against things like accidentally adding money values of different currencies or being able to use a money value separately from its associated currency...
05:57:00 <glguy> Fobbbb: Then you haven't pattern matched on the CellText constructor
05:57:07 <[exa]> _sras_: well that should work, yes :]
05:57:22 <glguy> Fobbbb: CellValue doesn't contain any ByteString, it only contains Text
05:59:35 <_sras_> [exa], Here, https://bitbucket.org/sras/scratch/src/6b4731caddca8c2adb1c09306187ed9427286f81/src/Money.hs?at=haskell-money-existential&fileviewer=file-view-default#Money.hs-62 I am doing some conversion from type level Currency to a Currency value. Can it be done simpler?
06:02:58 <Fobbbb> OK, thanks. Should the Xlsx package provide the function that get what I want or I am going to have to write one
06:11:06 * ab9rf thinks that hardcoding currency names into one's code is not best practice
06:11:29 <ab9rf> after all, currencies are occasionally created or destroyed
06:12:05 <lavalike> executables too
06:14:11 * [exa] thinks the same about money but hey, we're programming :D
06:15:16 <ab9rf> if i add 50 euros to 70 dollars, what i have is "50 euros and 70 dollars"
06:15:30 <ab9rf> it's not an error
06:16:13 * hackage ersatz 0.4.4 - A monad for expressing SAT or QSAT problems using observable sharing.  http://hackage.haskell.org/package/ersatz-0.4.4 (ryanglscott)
06:17:44 <ab9rf> there's also the issue that currency exchange is, in reality, a lossy process
06:17:53 <ab9rf> the buy is always less than the sell
06:18:31 <ab9rf> and there may be exchange fees, which may be either proportional or fixed
06:20:16 <mniip> ab9rf, yeah and buy/sell isn't a fixed coefficient when large sums are involved
06:20:45 <ab9rf> mniip: yeah, buy or sell enough and you'll drop below the top of the book
06:21:03 <mniip> the whole book?
06:21:05 <_sras_> ab9rf, I did not understand this. "that hardcoding currency names into one's code is not best practice". By this do you mean it is not good to define currency names in a library?
06:21:22 <ab9rf> mniip: if you're dealing with an uncommonly traded currency, there might not even be a book
06:21:31 <ab9rf> _sras_: i would not do so
06:22:26 <mniip> I've seen cryptos whose books are under a few thousand dollars, but that's not something one would want to trade huh
06:22:49 <ab9rf> _sras_: the most recent new currency, other than cryptos (which get created all the time) was in 2012
06:23:11 <ab9rf> didn't someone fairly large rebase theirs recently?
06:24:14 * hackage hw-simd 0.1.0.2 - SIMD library  http://hackage.haskell.org/package/hw-simd-0.1.0.2 (haskellworks)
06:24:39 <ab9rf> _sras_: when a sovereign currency is revalued, ISO issues it a new currency code. a sovereign currency issuers can revalue its currency at any time.
06:25:02 <Taneb> There's a currency scheduled to be released like next week
06:25:24 <ab9rf> _sras_: hardcoding currencies into your code forces you to patch and recompile any time any of the 170-odd currency-issuing sovereigns revalues its currency 
06:25:38 <Taneb> (Venezuala is changing their currency due to rampant inflation)
06:25:49 <mniip> Taneb, to runescape gold?
06:25:53 <ab9rf> hehe
06:26:02 <Taneb> :P
06:26:24 <ab9rf> mniip: likely more stable than the bolivar
06:27:00 <Taneb> By "like next week" I mean, literally in seven days
06:27:15 <Taneb> So yeah, currencies change more often than you think
06:27:28 <ab9rf> yup, goes from VEF to VES
06:27:36 <ab9rf> with a fixed ratio of 1:10000
06:27:49 <ab9rf> sorry, 1:100000
06:28:21 <mniip> is that by how much they hyperinflated over the last years? or does that cover something else
06:28:23 <ab9rf> and VEF was created in 2008, replacing VEB at a fixed ratio of 1:1000
06:29:42 <Boomerang> Is that following the "VE[A-Z]" pattern and we've only been told about a few versions of the currency? ^^
06:29:59 --- mode: glguy set +v BKD
06:30:12 <BKD> Where is the best place to ask for help if I can't get wxHaskell to install?
06:30:19 <madnight> https://stackoverflow.com/a/43243323/6593641
06:30:20 <ab9rf> Boomerang: VEB was the original bolívar. VEF was the bolívar fuerte. VES is the new bolívar soberano.
06:30:36 <ab9rf> Boomerang: so far, they've only done three since ISO 4217
06:31:01 <Boomerang> So S isn't "superfuerte"? :)
06:31:04 <ab9rf> VES goes live 20 August 2018, unless delayed again
06:31:15 <ab9rf> Boomerang: heh
06:31:46 --- mode: glguy set +v taumuon
06:32:08 <ab9rf> _sras_: currency exchange is a complicated, nontrivial matter
06:32:46 <taumuon> anyone know if it's possible to optimise the sum of squares?  
06:32:50 <taumuon> sumOfSquares n = sum $ map (^ 2) [1..n]
06:33:06 <ab9rf> taumuon: like, find a recurrence for it?
06:33:15 <glguy> BKD: you can ask here. Put all the information you can on a paste bin
06:33:41 <Taneb> taumuon: that's going to be about as fast as you can go if you want to do it that way, but there is a better way to do it
06:33:48 <Taneb> Which for large n is going to be an awful lot quicker
06:34:30 <ab9rf> taumuon: the recurrence for sum-of-squares is well-known; deriving it is a college algebra problem
06:34:43 <glguy> taumuon: there are closed form solutions , just Google a bit
06:35:01 <ab9rf> http://faculty.cs.niu.edu/~freedman/340/340notes/340recurrence.htm
06:35:13 <taumuon> thanks guys
06:35:44 <BKD> what's a "paste bin"?
06:36:09 <Boomerang> https://pastebin.com/
06:36:25 <glguy> BKD: a website that hosts pastes . Avoid pastebin.com though
06:36:33 <Boomerang> Or https://lpaste.net/
06:36:39 <ab9rf> who are we recommending these days?
06:36:43 <glguy> Gist.gitgub.com is good
06:36:45 <ab9rf> gist?
06:36:46 <taumuon> what's wroing with lpaste?
06:36:57 <taumuon> wrong*
06:37:00 <Boomerang> lpaste changed quite a bit
06:37:14 <ab9rf> lpaste isn't nearly as nice as it used to be
06:37:14 <glguy> Lpaste is on life support, lacking in important features, unreliable
06:37:18 <Boomerang> Not necessarily wrong though
06:37:28 <runeks> Is there a convenient way to express a large number -- e.g. 1000 -- as a type-level natural number in Haskell?
06:37:50 <ab9rf> runeks: define "convenient"
06:38:11 <runeks> ab9rf: Writing `'1000` is convenient
06:38:38 <Boomerang> You should be able to use `1000` literaly
06:39:18 <pong> > 1000 :: Word8
06:39:20 <lambdabot>  232
06:39:30 <runeks> Boomerang: Ah, cool! It works
06:39:41 <runeks> :k 1000
06:39:42 <lambdabot> GHC.Types.Nat
06:39:46 <pong> > 1000 :: Word
06:39:48 <lambdabot>  1000
06:39:54 <_sras_> ab9rf, Can you suggest any Haskell libraries for dealing with this problem, even to a limited extent?
06:40:02 <runeks> Didn't think it was *that* convenient
06:40:15 <ab9rf> _sras_: i don't know what problem you're trying to deal with
06:40:32 <Boomerang> runeks: :D
06:40:49 <ab9rf> _sras_: it's just a specific case of using dimensioned numbers
06:42:17 <ab9rf> the idea of tagging currency values with a denomination is sound
06:42:57 <ab9rf> but i point out that adding disparate currencie values is not an error
06:43:07 <ab9rf> it just requires that you carry the sum as a composite value
06:43:31 <Boomerang> % natVal' (proxy# :: Proxy# 1000)
06:43:31 <yahb> Boomerang: ; <interactive>:4:1: error: Variable not in scope: natVal' :: Proxy# 1000 -> t
06:44:37 <Boomerang> % natVal (Proxy :: Proxy 1000)
06:44:37 <yahb> Boomerang: ; <interactive>:5:1: error: Variable not in scope: natVal :: Proxy 1000 -> t
06:44:42 <ab9rf> the economics of currency exchange are complicated, and the rules that apply will depend on whether it's a realized or unrealized exchange 
06:44:43 <Boomerang> Oh well... :/
06:45:39 <ab9rf> i used to work with a company that did significant transactions in both dollars and yen
06:45:53 <ab9rf> they used a parallel-ledger approach for most purposes
06:46:30 <dminuoso> quchen: Oh do you mean a wai middleware?
06:46:37 <quchen> Yup
06:47:18 <ab9rf> _sras_: the accounting principles that apply also vary somewhat by country
06:47:38 <ab9rf> _sras_: it's probably best not to hard-code FASB 52 into a library that might be used outside of the US
06:50:00 --- mode: glguy set +v araadkins
06:50:33 <mniip> ab9rf, "realized"?
06:50:44 <araadkins> The `package.yaml` doesn't specify `OverloadedStrings`, but Intero is giving me errors as if it is enabled
06:51:57 <dminuoso> araadkins: Did you save your buffers?
06:52:04 <araadkins> I did indeed.
06:52:31 <dminuoso> araadkins: `M-x intero-restart` for good measure :P
06:52:44 <araadkins> Doesn't make a difference.
06:52:54 <_sras_> ab9rf, But if you are putting currency names in type level, is there any way around having to recompile the whole app when you have to add a new currency?
06:52:58 <dminuoso> araadkins: can you gist the code and the error message?
06:53:14 <ab9rf> mniip: some accounting systems i've seen handle foreign currencies by converting them for periodic closing reports to the "main" currency by posting unrealzied conversion entries to the GL, then posting a transaction that reverses those conversions. those are unrealized conversions.
06:53:14 <dminuoso> araadkins: also, do you get the same error message if you build with cabal/stack outside?
06:53:30 <ab9rf> mniip: the sole purpose is to have the entire ledger stated in a single currency
06:53:49 <araadkins> dminuoso: Unfortunately it's not exactly standalone. I can gist the error message though if that would help. And no, the error only occurs inside Intero. If I put `{-# NoOverloadedStrings #-}` at the top of the problem file it will load in Intero.
06:53:59 <ab9rf> mniip: since the currency is never actually exchanged, it's an "unrealized conversion"
06:54:00 <[exa]> guys let's invent a functional way to get rid of muneh
06:54:12 <ab9rf> _sras_: no
06:54:21 <ab9rf> _sras_: youcan't change the definition of a type at runtime
06:54:27 <dminuoso> araadkins: did you by any chance enable OverloadedStrings in one of your buffers? 
06:54:28 <ab9rf> _sras_: or create new ones
06:54:39 <dminuoso> araadkins: at some point I mean.
06:54:40 <mniip> ab9rf, not sure I follow but ok
06:54:50 <ab9rf> mniip: it's accounting ledgerdemain
06:54:53 <mniip> 1534168435 [16:53:55] <ab9rf> _sras_: youcan't change the definition of a type at runtime
06:54:56 <mniip> well actually
06:55:03 <araadkins> dminuoso: Not as far as I am aware, and fully restarting Intero with only this one buffer open still has the issue. 
06:55:12 <mniip> you can pass type level tags in instance dictionaries
06:55:18 <mniip> e.g GHC.TypeLits.Symbol
06:55:31 <ab9rf> mniip: yeah, ok, there are some crazy ghc typefu things like that
06:55:52 <mniip> you can essentially make up new types with existentials and
06:55:55 <mniip> :t GHC.TypeLits.someSymbolVal
06:55:56 <lambdabot> String -> GHC.TypeLits.SomeSymbol
06:56:01 <araadkins> dminuoso: It also appears to have done it with PolyKinds, which is all the more concerning.
06:56:23 <dminuoso> araadkins: Have you tried restarting emacs altogether? Also Im starting to be interested in your intero configuration
06:56:50 <araadkins> dminuoso: I'm actually using Intero within Neovim, but yes I have restarted nvim.
06:57:29 <mniip> ab9rf, well, you can use non-ghc typefu
06:57:40 <ab9rf> _sras_: if you were running an inventory system, would you want a different type for each stock item?
06:57:53 <mniip> data N = Z | S N; class KnownN (n :: N)
06:58:13 <mniip> data SomeN where SomeN :: KnownN n => Proxy n -> SomeN
06:58:16 <ab9rf> _sras_: or would you just use a type that represented inventory as "6 widgets", "3 stembolts", etc?
06:58:22 <mniip> someNVal :: Natural -> SomeN
06:58:28 <ab9rf> _sras_: currency is _no different_
06:58:29 <mniip> all perfectly writeable without unsafeCoerce
06:58:53 --- mode: glguy set +v stemarsh_
06:58:56 <araadkins> dminuoso: There's no additional configuration I am aware of. I've only rebound some keys and told intero not to start immediately
07:02:48 <_sras_> ab9rf, so basically you are saying it is not worth? About your example with stock items, are those really comparable? I mean, money and stock items? Because money values can appear at a lot of places, and a we often don't have to display "6 widgets" in temrs of "3 stembolts".
07:05:22 <dminuoso> araadkins: what backend are you using? intero? ghci? cabal repl?
07:05:45 <dminuoso> araadkins: Are you perhaps in a different stack target?
07:05:52 <araadkins> dminuoso: Backend is intero itself, though you gave me pause and the issue occurs also with `stack ghci`
07:05:58 <araadkins> So now I'm even _more_ confused
07:06:29 <dminuoso> araadkins: Do you perhaps have some special settings in your ~/.ghci ?
07:07:22 <ab9rf> _sras_: you can't convert currencies any more than you can convert widgets to stembolts.
07:07:35 <dminuoso> araadkins: I think it's easier to debug then, because it's no longer a neovim/intero issue - just a stack issue.
07:08:16 <ab9rf> _sras_: your problem is that you want to treat currencies as projections of some abstract money concept, as if they're simply different units of the same "money" value.
07:08:22 <ab9rf> _sras_: that's not how money works.
07:08:44 <ab9rf> it's not like converting feet to meters
07:09:53 <araadkins> dminuoso: I don't actually appear to have a ~/.ghci, and the only file under ~/.ghc is ghci_history.
07:10:07 <ab9rf> i remember once getting a check denominated in canadian dollars. my bank inadvertantly cashed it as if it were denominated in US dollars.
07:11:07 <ab9rf> it took six months to unscrew that mess
07:22:43 * hackage Frames-beam 0.1.0.0 - A library for accessing Postgres tables as in-memory data structures.  http://hackage.haskell.org/package/Frames-beam-0.1.0.0 (GagandeepBhatia)
07:23:28 <ph88> i get linking errors when i pass "debug" flag to ghc .. should i report it as bug ?
07:24:59 <MarcelineVQ> instinctively I would ask if you have profiling libraries available to link, you'll want to check that first which will depend on your build system
07:25:35 <ph88> i use stack for building
07:26:36 <ph88> i don't know about profiling libraries being available .. i let stack do building for me all the time
07:27:12 --- mode: glguy set -v araadkins
07:27:22 <MarcelineVQ> I'm not sure if it's even neccesary for debug, but it's what came to mind for linker errors so you'll want to check that
07:29:20 <MarcelineVQ> by check I mean the docs to make sure your steps are right, https://docs.haskellstack.org/en/stable/GUIDE/#debugging
07:29:51 <ph88> i don't know how to check that. By the way i suspect it's an issue with mixing profiling code with debug symbols https://bpaste.net/show/2f53a85f68e0 
07:29:55 <MarcelineVQ> though these aren't especially comprehensive :X
07:40:31 <MarcelineVQ> idk if --no-strip would matter, dunno a what stage in compiling that stripping happens
07:43:12 <ph88> i think by default there is no strip of symbols
07:43:24 <ph88> but usually stripping is the very last stage i think
07:44:53 <nitrix> Depends on your field of work.
07:44:57 * nitrix chuckles.
07:46:23 <ph88> lol
07:46:30 <nitrix> Hi ph88 o/
07:46:34 <ph88> hi
07:51:54 <nitrix> Makes sense. Different executables might require different symbols from a library so you wouldn't know until you're done linking.
07:55:33 --- mode: glguy set +v BKD
07:56:39 <BKD> okay, I put of a gist of the error I get from cabal while trying to install wxHaskell at https://gist.github.com/Bryan-Dunphy/cdd1995d752f1431b45b2e3f25f195fc
08:02:18 <ph88> i made this heap profile but i don't understand which functions in my code are causing the memory usage .. especially the yellow area  https://imgur.com/a/xjkamrV
08:07:10 <acowley> Is there a way to have the built-in record update syntax not impact a phantom type argument of a record?
08:07:22 <AWizzArd> I understand that argument that an Ord constraint on a Set helps to make it efficient. But couldn’t one use a hashmap under the hood for fast lookups and go without the Ord?
08:07:51 <merijn> AWizzArd: Well, then you'd need a "Hashable" constraint, wouldn't you?
08:08:01 <acowley> By "not impact", I mean preserve
08:08:06 <AWizzArd> merijn: true, okay.
08:08:12 <merijn> AWizzArd: And that's in fact what unordered-containers does
08:08:26 <merijn> @hackage unordered-containers
08:08:27 <lambdabot> http://hackage.haskell.org/package/unordered-containers
08:08:42 <AWizzArd> (the bot should output an httpS link)
08:09:29 <AndreasK> lambdabot is on github you can probably raise an issue about https there
08:09:45 <mniip> considering haskell's closest encounter with HTTPS is libcurl... not sure about that
08:10:13 --- mode: glguy set +v dataN
08:10:17 <dataN> error; https://gist.github.com/dataN-hs/08421f415fb90caed763e39072106f25
08:11:14 <AndreasK> ph88: Did you look at a regular profile run? That might also be helpful as it shows allocations by function.
08:11:26 <mniip> dataN, that type is indeed ambiguous
08:12:11 <dataN> not sure it can be annotated though because 'g' is not visible 
08:12:32 <AndreasK> ph88: There are also some options for heap profiles, show constructor name, retainer and some others iirc, worth looking at too
08:12:44 <mniip> dataN, either use some proxy arguments, or settle with AllowAmbiguousTypes and TypeApplications
08:12:59 <acowley> I guess I'll have to include a Proxy field in the record
08:13:01 <mniip> or well, refactor the type in some other way to mention f and g
08:14:45 <dataN> couldnt get proxy types to work.. whats that about TypeApplications?
08:16:26 <mniip> dataN, well consider this
08:16:30 <mniip> % ty :: forall a. Typeable a => String; ty = show $ typeRep (Proxy :: Proxy a)
08:16:32 <yahb> mniip: ; <interactive>:1:7: error:; * Could not deduce (Typeable a0); from the context: Typeable a; bound by the type signature for:; ty :: forall k (a :: k). Typeable a => String; at <interactive>:1:7-36; The type variable `a0' is ambiguous; * In the ambiguity check for `ty'; To defer the ambiguity check to use sites, enable AllowAmbiguousTypes; I
08:16:43 <mniip> if we do force it with ambiguous types:
08:16:49 <mniip> % set -XAllowAmbiguousTypes
08:16:50 <yahb> mniip: ; <interactive>:2:6: error: Data constructor not in scope: XAllowAmbiguousTypes :: ASetter s t a b -> b -> s -> t
08:16:55 <mniip> % :set -XAllowAmbiguousTypes
08:16:56 <yahb> mniip: 
08:17:04 <mniip> % ty :: forall a. Typeable a => String; ty = show $ typeRep (Proxy :: Proxy a)
08:17:04 <yahb> mniip: 
08:17:11 <mniip> then we are left with the following issue:
08:17:12 <mniip> % ty
08:17:13 <yahb> mniip: ; <interactive>:5:1: error:; * No instance for (Typeable a0) arising from a use of `ty'; * In the expression: ty; In an equation for `it': it = ty
08:17:26 <mniip> we don't know what type to substitute for 'a' at a use site
08:17:26 <ph88> AndreasK, ah yes good idea ill have a look
08:17:32 <mniip> we can solve this with type applications:
08:17:35 <mniip> % ty @Int
08:17:36 <yahb> mniip: "Int"
08:17:49 <mniip> or we could model our function differently to avoid the ambiguous types at all
08:18:11 <mniip> % ty' :: forall a. Typeable a => Proxy a -> String; ty' _ = show $ typeRep (Proxy :: Proxy a)
08:18:12 <yahb> mniip: 
08:18:19 <mniip> % ty' (Proxy :: Proxy Int)
08:18:20 <yahb> mniip: "Int"
08:19:23 <dataN> so in this example, where would the type of the Applicative be specified? 
08:20:16 <mniip> traverse_DifferenceS_ :: forall f x g .( DifferenceS f,Applicative g) => Proxy f -> Proxy g -> ((Applicative g,Traversable f) => x) -> x
08:21:05 <dataN> g :: (*->*)
08:21:33 <dataN> traverse_DifferenceS_ :: forall f x g p1 p2 .( DifferenceS f,Applicative g) => (p1 f,p2 g) -> ((Applicative g,Traversable f) => x) -> x
08:21:46 <acowley> It seems unnecessary that record update syntax would generalize a type, but I guess it's not a common problem.
08:21:56 <mniip> dataN, Proxy is polykinded
08:21:59 <mniip> :k Proxy
08:22:00 <lambdabot> k -> *
08:22:15 <dataN> oh
08:22:22 <mniip> also I'd really rather not tuple them up like htat
08:22:26 <dataN> must have defined it wrong somewhere! 
08:22:29 <dataN> doh!
08:22:56 <dataN> yes the polykinded version is better
08:22:58 <dataN> thanks
08:29:12 <madnight> can i run multiple commands at once in ghci? something like: :r;:t abc;main?
08:29:56 <dataN> now it gives this error;https://lpaste.net/8074219928690884608
08:31:11 <mniip> madnight, no, but you can load a multiline chunk of code at once with :{ and :}
08:35:54 <hexagoxel> madnight: you can put ":def combine \x -> return $ map (\c -> if c == ';' then '\n' else c) x" into your .ghci
08:36:13 <hexagoxel> then ":combine :r;:r" will reload twice etc.
08:36:43 <hexagoxel> combine is a stupid name, now that i think of it
08:37:40 <hexagoxel> of course that breaks any other input involving ";"
08:37:59 <madnight> hexagoxel: nice "hack", thx
08:39:07 <ph88> when i do   stack install   for the global project which optimizations are applied ?
08:39:53 <hexagoxel> does something like "contcurrent = ContT $ \c -> void $ forkIO (c ())" exist in some lib?
08:41:04 <magicman> Data.Set.valid x == False. Oops, I broke something somewhere.
08:41:29 <hexagoxel> you can do some strange stuff with ContT, e.g. express a "takeMVar" that forks itself before blocking..
08:42:13 * hackage haskell-postal 0.2.0.0 - Haskell binding for the libpostal library  http://hackage.haskell.org/package/haskell-postal-0.2.0.0 (netom)
08:43:15 <dataN> AllowAmbiguousTypes does not seems to help either...
08:46:43 * hackage optima 0.1.1 - Simple command line interface arguments parser  http://hackage.haskell.org/package/optima-0.1.1 (NikitaVolkov)
08:47:02 <dataN> it says; forall a b (g1 :: * -> *). (a -> g1 b) -> f a -> g1 (f b), even when 'traverse_DifferenceS :: forall a b. (a -> g b) -> f a -> g (f b)' is written
08:47:16 <dataN> why does ghc change the forall like that?
08:47:22 <acowley> Does anyone have a good technique for having travis-ci builds depend on unreleased versions of dependencies?
08:47:53 <pie__> merijn, cant quite remember who i was talking to exactly about a queue in an ioref, but originally this is what made me lean towards using iorefs in the rest of my program https://stackoverflow.com/questions/1931875/when-is-it-ok-to-use-an-ioref
08:48:06 <pie__> i will try writing it with stref i a bit if i can get around to it
08:48:20 <glguy> acowley: Add the dependencies as submodules; have the travis script pull them down?
08:48:50 <acowley> glguy: Thanks
08:49:07 <glguy> acowley: Are you building with new-build?
08:50:01 <acowley> glguy: Whatever the multi-travis-ghc tool uses
08:50:11 <acowley> glguySo, yes
08:50:42 <glguy> OK, do you know about optional-packages: in cabal.project?
08:51:14 <acowley> glguy: I do not. My cursory look into these things suggested that git dependency references are an upcoming feature
08:51:52 <acowley> But I guess I'll need a file system reference for the submodule
08:51:54 <acowley> so I should read
08:52:00 <pie__> alternatively, if I'm stuck in IO anyway, is there any reason to use ST?
08:52:11 <glguy> The way to go is to track the commit of the unreleased package you require in your git submodules. You can add the submodule directory to your packages: or optional-packages depending on what makes sense for your case
08:52:39 <dataN> even passing the Proxy to the function being called does not help; https://lpaste.net/4658691970170880000
08:52:58 <Ariakenom> pie__: You do get a static boundary for the state. For the benefit of the reador or something
08:53:11 <ph88> i'm doing 10 quickcheck iterations with code compiled with -O2  still my program takes about 14 to 60 seconds to run ... i noticed that about 70% of the time is spend in quickcheck part. I generate random AST then pretty print it and then parse it to check if i get back the same AST. Anyone a clue why the code is so slow?  https://bpaste.net/show/5677dddf18ba 
08:54:13 <acowley> glguy: Thanks again. So optional-packages would make sense if I don't want to have the submodule on a dev machine, say?
08:54:37 <JuanDaugherty> why should quickcheck be fast? because 'quick' trumps what it's doing?
08:54:39 <glguy> optional-packages is for when the hackage version works, but in some cases you want to use a local version instead
08:54:56 <glguy> so if the directory is not found then it will use hackage instead of complaining that it can't find it
08:55:27 <dataN> (with this as the original incase its not visible in the scroll up; https://gist.github.com/dataN-hs/08421f415fb90caed763e39072106f25)
08:56:11 <ph88> JuanDaugherty, i don't know why it would be fast, but it should be fast because i want to do more iterations :P
08:56:25 <JuanDaugherty> :)
08:57:41 <JuanDaugherty> i think of it as just the essential element for the proof style of hs programming, not something that ever is in final code and so just
08:57:59 <JuanDaugherty> needs to return in reasonable time, not hang
08:58:48 <JuanDaugherty> a minute or so no biggy
09:04:04 --- mode: glguy set +v dataN_
09:04:23 <glguy> dataN: Once you identify with nickserv your messages will stop getting blocked
09:04:46 <dataN_> why does even explicitly fixing the type of the function with a Proxy not work?
09:05:02 <ddellacosta> emacs with dante/haskell-interactive-mode is constantly freezing and it's driving me NUTS. It's happening whenever I open a bracket/paren or when auto-complete kicks in, and seems to be worse whenever Template Haskell is involved, although I'm not sure that's the only identifying trait to this issue. Has anyone experienced something similar, and how did you go about debugging it? Apologies if this would be better in a
09:05:02 <ddellacosta> n emacs-related channel vs. here
09:10:24 --- mode: glguy set +v brunooo
09:17:58 <Fobbbb> I am trying to sort a nested list by the first element value of the inner list. However I cannot get the compare function correctly.
09:18:26 <Fobbbb> order :: (Ord a, Eq a) => [[a]] -> [[a]] --- order l = sortBy (\(x:y:xs) -> (compare (x!!0) (y!!0))) l
09:18:58 <acowley> glguy: I think my travis build is running now, but I had to edit the generated .travis.yml a bit to stop it from clobbering the cabal.project file. Is that typical?
09:19:36 <glguy> acowley: It's typical once you're using a more interesting cabal.project
09:19:52 <glguy> brunooo: check your private messages
09:19:55 <dminuoso> Fobbbb: sortBy (\x -> ...)
09:20:00 <dminuoso> Fobbbb: x is the inner list.
09:20:18 <dminuoso> Fobbbb: sortBy (\x y -> ...)
09:20:23 <dminuoso> x and y are the inner lists! :P
09:21:12 <dminuoso> :t sortBy (\(x:_) (y:_) -> compare x y)
09:21:13 <lambdabot> Ord a => [[a]] -> [[a]]
09:21:23 <Fobbbb> huh now I don't understand the code anymore.
09:21:44 <dminuoso> Fobbbb: ignore for a moment that this is a nested list
09:22:03 <dminuoso> :t sortBy
09:22:04 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
09:23:00 <dminuoso> let a ~ [Int] for the same of discussion
09:23:18 <dminuoso> So then sortBy :: ([Int] -> [Int] -> Ordering) -> [[Int]] -> [[Int]]
09:23:20 <dataN_> hmm, seems like it could possibly have something to do with the forall in the definition of traverse_, maybe its complaining about the extra Applicative constraint in there? https://lpaste.net/5448406494489870336
09:24:20 <Fobbbb> I'll need time to digest this. Thanks.
09:25:00 <dminuoso> Fobbbb: Perhaps its easier to read this as: sortBy (\x y -> compare (head x) (head y))
09:25:17 <dminuoso> Or maybe `sortBye (\x y -> compare (x !! 0) (y !! 0))`
09:25:38 <Fobbbb> The second version is what I have at right now
09:25:42 <dminuoso> Fobbbb: I should mention at this point that this is unsafe because a list can be empty, so this could crash.
09:25:47 <dataN_> it seems to be concluding 'Traversable g => x' somehow even though 'Traversable f => x' is written...
09:26:05 <dminuoso> Fobbbb: It would be safer to use NonEmpty rather than list. :)
09:28:38 <Fobbbb> huh OK, I think I get it. I think.
09:29:03 <dataN_> oh, the arguments were flipped, here is the correct error;
09:29:04 <dataN_> https://lpaste.net/6306652165523898368
09:31:32 <dataN_> so defiantly the forall of traverse_ is demanding g is ambiguous...  
09:32:58 <dataN_> maybe it can be fixed with a proxy argument to traverse_ but this does not seem correct, as the type should be fixed by the Applicative returning function not at the definition of traverse...
09:33:43 * hackage hadolint 1.11.0 - Dockerfile Linter JavaScript API  http://hackage.haskell.org/package/hadolint-1.11.0 (lorenzo)
09:45:18 <nshepperd> dataN_: it looks like you're trying to put a monomorphic thing (with particular types f and g) into a polymorphic box
09:45:37 <nshepperd> Traversable_ requires an argument that works for *all* f,g
09:46:36 <dataN_> meaning the proxies should be dropped? 
09:48:35 <nshepperd> sorry, the Traversable_ requires an argument that works for all g
09:48:39 <nshepperd> f is fine
09:48:44 <ddellacosta> is there a type of lens that will let me filter values, for example if I'm digging deep into a tree-structured complex record value and I want to collect all of a set of leaves with a specific string value?
09:49:02 <nshepperd> I can't really tell you what you should do since i'm not sure what you're trying to do
09:49:27 <nshepperd> but dropping the Proxy g might get you somewhere useful
09:49:28 <glguy> ddellacosta: there's a Fold for that: filtered
09:49:40 <nshepperd> and dropping the Applicative g constraint
09:49:45 <dataN_> yes that works!
09:50:09 <ddellacosta> glguy: https://hackage.haskell.org/package/lens-4.15.3/docs/Control-Lens-Fold.html#v:filtered ?
09:50:13 <ddellacosta> glguy: thank you, I'll check it out!
09:54:13 * hackage RFC1751 1.0.0 - RFC-1751 library for Haskell  http://hackage.haskell.org/package/RFC1751-1.0.0 (xenog)
09:57:59 <bollu> Did a lot of accounts on freenode get hacked or something?
09:58:03 <bollu> I got spammed like, 10 times
09:59:07 <dataN_> nshepperd: thanks. heres an example of it working; https://gist.github.com/dataN-hs/08421f415fb90caed763e39072106f25
09:59:14 * hackage optima 0.1.2 - Simple command line interface arguments parser  http://hackage.haskell.org/package/optima-0.1.2 (NikitaVolkov)
10:01:33 <dataN_> anything implementing 'differenceS :: Applicative g => (a -> g b) -> f a -> (g (Maybe (f b) -> f b),Maybe (f a))' is Traversable. this is just one example of many possible defaults e.g. by providing a similar function of the same type without the Maybes... 
10:02:49 <dataN_> its a good example of when to use local instances, since Traversable is from Prelude and cannot be modified to include default clauses. 
10:04:12 <glguy> Bollu: freenode is getting massively spammed this month. Set yourself +R
10:04:25 <bollu> glguy I see, thanks
10:04:42 <dataN_> also allowing for multiple defaults to be defined...
10:10:32 <pie__> ok so i can see how STRefs allow you to use mutable state locally, but i pass stuff around all over the place so im not sure it would help me a lot...
10:19:36 --- mode: glguy set -v ezyang__
10:32:56 <madnight> pie: then you have the wrong abstraction, most of your functions should be pure and a small portion of code should then compose those functions and do effects
10:33:07 <madnight> not the other way around
10:38:56 <ab9rf> yups
10:39:38 <Flonk> any cat theory buffs online?
10:39:46 <ab9rf> meow
10:39:55 <Flonk> ab9rf, I'll take it :D
10:40:05 <ab9rf> i know nothing about category theory though
10:40:27 <Flonk> oh, shame
10:40:56 <dstolfa> Flonk: just ask your question
10:43:23 <Flonk> Working through Bartosz' intro to cat theory and in the chapter representable functors he defines `data Pair a = Pair a a` and challenges us to implement his Representable typeclass
10:43:59 <Flonk> In other words I need to find the right type `a` such that I can find an invertible natural transformation :: Hask(a, -) -> Pair
10:45:20 <Flonk> I can pick a = () with the transformations alpha fn = Pair (fn ()) (fn ()) and beta (Pair x x) = \_ -> () I think.
10:45:58 <Flonk> I think I can also pick a = Bool with alpha fn = Pair (fn True) (fn False) and beta (Pair t f) = \b -> if b then t else f.
10:47:21 <Flonk> This looks to me like we shold be able to somehow construct a "best" representation (in this case bool) using some sort of universal construction. Bartosz has shown me a hundred by this point but I still can't set any up myself. How would I go about doing it?
10:48:56 <Fobbbb> I have a non-exhaustive pattern for a constructor pattern matching error. Do I have to create all of the functions despite I am only interested in one type of value
10:49:21 --- mode: glguy set +v badzergling
10:49:47 <madnight> Flonk: i'm currently in the Profunctor chapter ^^
10:50:22 <badzergling> Fobbb: what will happen when you apply your function to a value with a differenc constructor?
10:50:30 <Flonk> madnight, not too far off :P
10:50:58 <Fobbbb> I dunno. Undesired behavior I suppose
10:51:55 <badzergling> Fobbbb: you're still basically on the hook for defining that undesired behavior...
10:52:28 <Fobbbb> I am not sure what I can write that will cover all other bases.
10:53:01 <ab9rf> Fobbbb: so why is this function being defined over such a broad domain?
10:53:24 <Fobbbb> Oh I am just trying to retrieve data from CellValue type, from Codec.Xlsx packagfe
10:53:48 <badzergling> well, you could "fail",  instead of `MyFoo -> YourBar`, you can change the type of your function to `MyFoo -> Maybe YourBar`, and return a `Just` only when the caller uses the correct constructor of `MyFoo`
10:53:55 --- mode: glguy set +v Boarders
10:54:08 <Boarders> Flonk: if a functor is representable in the sense that you have Pair a ~ T -> a for some T
10:54:14 <Boarders> then T will be unique
10:54:24 <Boarders> if you take T = Bool then like you say this works
10:54:44 <Boarders> if you take T = () then this does not work as Pair a is not isomorphic to () -> a
10:56:07 <badzergling> Boarders: `T` is only unique up to isomorphism.  we could have chosen `Maybe ()` or `Either () ()` as `T`, which still satisfies the correct universal property.  Both of those are, of course, isomorphic to `Bool`
10:56:10 <madnight> but i think he have to show that his projection is better than any other projection (and unique up to isomorphism)
10:56:32 <Boarders> yes, sorry I meant to say unique (up to unique isomorphism)
10:56:49 <Flonk> Boarders, ah. That means I picked faulty natural transformations for T = () and came to wrong conclusions :D Thanks!
11:01:05 <Flonk> Yeah I see it now. My beta is obviously silly
11:10:15 <Fobbbb> I still haven't figured it out. So what is the proper way of dealing with a constructor of multiple types. Creating a function for each?
11:10:25 <madnight> Flonk: i better continue reading : )
11:15:43 --- mode: glguy set +v Flonk_2
11:27:43 * hackage haskell-postal 0.2.0.1 - Haskell binding for the libpostal library  http://hackage.haskell.org/package/haskell-postal-0.2.0.1 (netom)
11:37:11 --- mode: glguy set +v if`m
11:37:54 <christianpoveda> Hey hi! I have an small question about Kinds. 
11:39:23 <christianpoveda> Why does this needs kind polymorphism? What role is playing {k] here? https://www.irccloud.com/pastebin/mkipVuqa/
11:42:03 <kritzefitz> Is it possible with TH to write a declaration quotation like [d| $foo bar = baz |] where the name of the function is a splice?
11:42:13 <kritzefitz> I always get a syntax error when I try to do that.
11:57:29 <ChaiTRex> kritzefitz: Does foo produce a Pat?
11:57:47 <kritzefitz> ChaiTRex: foo :: Name
11:58:00 <kritzefitz> I'ts supposed to be the name of the function I'm trying to declare.
11:59:05 <ChaiTRex> kritzefitz: Wrap it with VarP.
11:59:26 <ChaiTRex> Maybe $( fmap VarP foo ) or something.
11:59:39 <kritzefitz> That doesn't help.
12:00:39 <ChaiTRex> What's the exact type of foo?
12:00:43 * hackage language-ats 1.7.0.0 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.7.0.0 (vmchale)
12:00:45 <kritzefitz> Name
12:00:46 <acowley> Does anyone have a .travis.yml that uses a cabal.project file to build with a git submodule for an unreleased dependency?
12:01:09 <ChaiTRex> kritzefitz: Try foo' = returnQ (VarP foo)
12:01:17 <ChaiTRex> kritzefitz: Then use $foo'
12:01:44 <ChaiTRex> kritzefitz: Or change foo to do that wrapping.
12:02:08 <ChaiTRex> kritzefitz: Let me double-check something.
12:02:11 <kritzefitz> Where does returnQ come from? Do you mean just return?
12:02:30 <ChaiTRex> kritzefitz: Splices have to be of type Q whatever. returnQ puts the Q in front of the type.
12:02:32 <kritzefitz> BTW, I get a parse error, so I doubt the type of the expression changes anything.
12:02:55 <ChaiTRex> kritzefitz: Let me check what a one argument pattern looks like. BRB.
12:03:32 <kritzefitz> A one argument pattern works like you suggested, but then it's a ValD, but I want a FunD.
12:08:43 <Boarders> christianpoveda : it works fine if you do: type family Length (list :: [*]) :: Nat where ...
12:09:15 <Boarders> The k just makes it kind polymorphic in the type level list you accept as an arg
12:09:28 <Boarders> (but maybe I am missing the point of your question)
12:12:26 <ChaiTRex> kritzefitz: Sorry, still working on it.
12:12:38 <kritzefitz> ChaiTRex: Thank you for doing so.
12:13:29 <christianpoveda> Boarders: but for example Maybe is a unary type constructor. Nevertheless I'm unable to have a list of Maybe, what's the point of allowing kind polymorphism in that example? 
12:14:13 * hackage language-ats 1.7.0.1 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.7.0.1 (vmchale)
12:16:34 <christianpoveda> I mean, my question is how can I have a term with a type of kind * - > *? 
12:16:36 <Boarders> christianpoveda: you can get the length of both [Int, Char, String] and ['Zero, 'Succ 'Zero] etc.
12:17:06 <Boarders> not sure if that is useful to you or not
12:17:35 <christianpoveda> But succ zero shouldnt have kind *? 
12:17:45 <Boarders> no it has kind Nat
12:18:26 <christianpoveda> Ohhhh 
12:18:34 <christianpoveda> That's dark magic
12:18:48 <christianpoveda> So Nat is a kind also
12:18:53 <christianpoveda> Wow
12:20:49 <ddellacosta> is there a more idiomatic way to reduce a list to unique values than (what I'm doing now) Data.Set.fromList ?
12:21:37 <fsestini> christianpoveda: Nat is a kind when you enable -XDataKinds
12:21:55 <Boarders> ddellacosta: not sure about more idiomatic but you can use the function nub from Data.List
12:22:26 <ddellacosta> Boarders: thanks, I figured there was something in `Data.List` that I was missing
12:22:27 <ChaiTRex> kritzefitz: Looks like it can't be done: https://stackoverflow.com/questions/16332124/template-haskell-names-of-declarations-as-strings
12:22:29 <ab9rf> ddellacosta: other than using nub?
12:22:29 <christianpoveda> fsestini: is this true for all datatype? 
12:22:43 <ddellacosta> ab9rf: yep, that's why I was asking, I wasn't aware of nub
12:22:45 <ab9rf> ddellacosta: sorry, i'm slow today
12:22:49 <christianpoveda> Datatypes*
12:22:50 <ddellacosta> np!
12:22:58 <ab9rf> ddellacosta: the name is not obvious :)
12:23:15 <ddellacosta> yeah, haha. I was looking for like, "distinct" or "unique" or something
12:23:22 <ab9rf> ddellacosta: there's also nubBy, which uses a comparator function
12:23:22 <kritzefitz> ChaiTRex: That's unfortunate. Thank you, for your help!
12:23:33 <ddellacosta> ab9rf: oh that sounds handy
12:23:39 <ddellacosta> thanks! This is all good to oknow
12:23:43 <ddellacosta> *know
12:24:18 <ddellacosta> I wonder what the etymology of "nub" is
12:24:28 <christianpoveda> I mean with that extension all datatypes are promoted to kinds? 
12:24:38 <fsestini> christianpoveda: not all datatypes get promoted
12:24:56 <fsestini> see https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/promotion.html for the exact description of what are promoted and what not
12:24:59 <ab9rf> ddellacosta: see the docs for Data.List :)
12:25:10 <christianpoveda> Thank you! 
12:25:21 <ddellacosta> ab9rf: that'd be too easy :-p
12:25:25 <ddellacosta> ab9rf: cool, thanks
12:27:26 <Boarders> christianpoveda: you can make the kinds more explicit with something like:
12:27:33 <Boarders> type family (+) (a :: Nat) (b :: Nat) where
12:27:39 <Boarders> 'Zero + b = b 
12:27:40 <sjakobi> How do I make cabal new-haddock include regular (non-hyperlinked) sources in the docs?
12:27:42 <Boarders>   'Succ a + b = 'Succ (a + b)
12:28:01 <Boarders> that way you can't do something unintended like:
12:28:08 <Boarders> 'Zero + Int
12:28:23 <christianpoveda> Boarders Ohhh, ok. That should help! Ty! 
12:28:42 <MarcelineVQ> you can splice patterns now, but it doesn't look like you can splice the dec name
12:29:18 <ChaiTRex> kritzefitz: You're welcome.
12:43:08 <hexagoxel> "setup: Most RTS options are disabled. Link with -rtsopts to enable them."
12:43:11 <Gurkenglas> I think I already asked something like this once, but I don't know how to search the logs. How do I memoize a function of type a -> IO b?
12:43:46 <hexagoxel> - i can't be the first to try to global export "GHCRTS=-M1G" and see everything break
12:44:15 --- mode: glguy set +v oisdk
12:44:20 <dminuoso> Is it bad practice to configure applications by passing environment variables into a docker container?
12:44:30 <dminuoso> I've come to the point where this would fit really nicely with gitlab-ci and variables.
12:44:38 <dminuoso> And everything else is a kind of pita with docker.
12:44:48 <oisdk> ddellacosta bear in mind that nub is O(n^2), where as Set.fromList is O(n log n)v
12:45:28 <ddellacosta> oisdk: oh, that is good to know, I had assumed they were both the same complexity (probably because I didn't bother looking at the docs, d'oh)
12:45:31 <ddellacosta> thanks
12:45:43 <ddellacosta> not that I'm working with a ton of values but still like knowing
12:46:09 <dmwit> Gurkenglas: Why is this hard? e.g. what's wrong with using an `IORef (Map a b)` internally to implement the signature `Ord a => (a -> IO b) -> IO (a -> IO b)`?
12:46:30 <oisdk> There's also nubOrd in containers, which is probably your best bet http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Containers-ListUtils.html#v:nubOrdv
12:46:41 <oisdk> dunno if it's in base yet though.
12:46:53 <ddellacosta> oh cool, something else I didn't know about
12:46:58 <ddellacosta> thanks oisdk
12:47:18 <Gurkenglas> dmwit, I suppose, but I hoped I can combine this safely from existing stuff
12:47:19 <ddellacosta> I see the author went all-in on the word "nub"
12:48:00 <dmwit> Gurkenglas: IORef and Map do not qualify as "existing stuff"?
12:48:10 <Gurkenglas> dmwit, once and memoize qualify :P
12:48:59 <Gurkenglas> once :: IO a -> IO (IO a), memoize :: (<pretty much> Ord) a => (a -> v) -> a -> v
12:50:12 <dmwit> I don't think that actually answered the question of whether IORef and Map qualify. =)
12:51:27 <Gurkenglas> "Quite right. Interesting. That was quicker than the others."
12:53:02 <Gurkenglas> I suppose I might as well use unsafeInterleaveIO here, right? Would it do anything else?
12:56:29 <ab9rf> ridiculouslyUnsafePerformIONowAlreadyDammit
12:59:10 <hexagoxel> Gurkenglas: have you considered the monad-memo package?
12:59:31 <dmwit> Gurkenglas: Why would you use unsafeInterleaveIO?
12:59:50 <dmwit> You could use that if you wanted to reuse once and memoize. But I think there's no reason to try that, myself.
13:00:12 <dmwit> Unless `a` is a truly small type. In which case see `universe`, which offers a `Traversable` instance for `(->)` that will interest you.
13:01:30 <dmwit> :t let once :: IO a -> IO (IO a); once = undefined in traverse once
13:01:32 <acowley> How can I generate a promoted list in TH that prints using list syntax rather than ':?
13:01:32 <lambdabot> Traversable t => t (IO a) -> IO (t (IO a))
13:02:39 <dmwit> (But you would probably want `traverse (unsafeInterleaveIO . once)`.)
13:06:22 <hexagoxel> Gurkenglas: "memoIO f = Memo.startEvalMemoT @IO . Memo.memo (liftIO . f)"
13:07:20 <acowley> Oh, it seems I wrote code to do what I wanted some time ago
13:11:39 <ab9rf> i'd kill for code that did things i wanted some time ago
13:11:56 <ab9rf> especially if you could control how far into the past it does them
13:13:19 <Gurkenglas> hexagoxel, nice that looks like it fits
13:13:20 <Gurkenglas> thanks
13:17:00 <typetetris> What is the point of this ghc-* packages on hackage describing parts of ghc I presume? If I understand correctly they ship with ghc and never need to be downloaded from hackage?
13:17:39 <monochrom> Perhaps just for doc links.
13:17:57 <monochrom> You could ask of base too, you know.
13:18:37 <dminuoso> typetetris: Do you have an example package?
13:18:42 <typetetris> ghc-compact
13:18:58 <fragamus> Are Function parameters resolved left associative or right
13:19:12 <Gurkenglas> hexagoxel, "memoM f = Memo.startEvalMemoT . Memo.memo (lift . f)" rather, right?
13:19:14 <monochrom> Yeah, why is even base on hackage? Misleading some beginners into thinking that they could just go "cabal install base-5.0.0.0"
13:19:23 <ab9rf> fragamus: functional application binds left
13:19:25 --- mode: glguy set +v ccrypto
13:19:34 <fragamus> Ty
13:19:34 <ab9rf> fragamus: f a b is (f a) b
13:19:47 <dminuoso> fragamus: also function application has the highest precedence in haskell
13:20:13 <ccrypto> I mean OCaml*
13:20:16 <hexagoxel> Gurkenglas: i vaguely remember you asking for the most specific implementation matching the query :p
13:20:27 <ccrypto> or ReasonML, well itssame i guess lol
13:20:30 <hexagoxel> but sure :)
13:21:43 <ccrypto> learning haskell now, i love languages that forces you to use paradigms
13:21:52 <sclv> monochrom: makes docs available
13:21:56 <ab9rf> ccrypto: all languages force you to use paradigms
13:22:38 <ccrypto> yes, but you can write years javascript and still write messy code
13:22:42 <dminuoso> ccrypto: I'd argue that Haskell forces you _less_ to use a certain paradigm. If you want strictness, you can have it. If you want lazyness, you can have it. If you want imperative code, you can have it.
13:22:46 <dminuoso> If you want functional code, you can have it.
13:22:47 <ab9rf> you can write messy haskell too
13:23:41 <zachk> if you want object oriented?
13:23:52 <monochrom> sclv: That's what I said.
13:23:54 <ab9rf> you can write object-oriented code in haskell too. 
13:24:02 <Ariakenom> then you google object oriented haskell
13:24:15 <ccrypto> someone told me i should learn haskell because the knowledge you gain can easily be translated into other languages
13:24:17 <ab9rf> i've written object oriented code in C, BASIC, and assembly
13:24:34 <ab9rf> ccrypto: that's true of every language you learn
13:24:35 <dminuoso> ccrypto: Some will, some wont. For me it radically changed how I approach problems and write code in general.
13:24:41 <monochrom> WTF is "paradigm" anyway?
13:24:50 <MarcelineVQ> para dig 'em
13:24:52 <ab9rf> monochrom: it's what happens when two digms get together
13:24:59 <dminuoso> ccrypto: Haskell idioms rarely translate directly sadly - mostly because languages like basic things - you know a non-shitty type system and ADTs..
13:25:06 <dminuoso> *lack basic things
13:25:10 <hexagoxel> as long it is a reason to love haskell, i would not complain
13:25:38 <monochrom> I prefer how John Backus use the word "style" instead.
13:25:56 <olle> Can a function have "Show"?
13:25:57 <ab9rf> haskell tends to encourage you to look at problems from a different persepctive than the usual "do this than do that" approach that dominates many other forms of programming
13:26:14 <hexagoxel> "but people must not love haskell for the wrong reasons" :D
13:26:20 <ab9rf> getting used to analyzing problems in a different way is beneficial to your general skill as a programmer
13:26:27 <dminuoso> olle: No
13:27:09 <ab9rf> olle: there are both practical and theoretical reasons why you can't have Show instances for functions.
13:27:13 <dminuoso> olle: I mean if your function has a finite domain that you can enumerate, and a showable domain/codomain you could show them.
13:27:13 <olle> dminuoso: ok
13:27:19 <dminuoso> olle: that would be the closest thing you could make work
13:27:40 <ab9rf> but it is possible to have Show instances for _some_ function types
13:27:41 <dminuoso> olle: Also note that `Show` is strictly for producing valid code that you could copy+paste into GHCi..
13:27:41 <olle> dminuoso: but you can write ":t myfun" - couldn't "Show" return the same string?
13:27:54 <typetetris> Not really useful: `instance Show (a -> b) where show _ = "Mow!"`.
13:28:00 <dminuoso> olle: Take note of my last comment
13:28:07 <olle> ok
13:28:31 <typetetris> Didn't now `Show` was meant to produce c&pable code.
13:28:34 <typetetris> Nice to know.
13:28:39 <ab9rf> olle: the idea is that Show is supposed to create text that, when "read" reproduces the original value
13:28:50 <olle> ab9rf: ok
13:28:55 <ccrypto> I love the haskell community, you guys seem to love programming more than javascript people
13:29:05 <olle> ab9rf: so not equal to "toString()", then? :)
13:29:24 <dminuoso> olle: Correct.
13:29:26 <ab9rf> olle: well, there are a lot of Show instanecs that do not comply with that rule :)
13:29:32 <olle> got it
13:29:49 <dminuoso> olle: Think of `Read` as something GHCi could use to turn a literal input into a value, whereas `Show` would be the opposite direction.
13:29:51 <ab9rf> olle: but yes, the expectation for a Show instance is much stricter than the toString methods of languages like java or python
13:29:59 <dminuoso> olle: Such that: `read . show = id` if it were 
13:30:08 <ab9rf> read . show = id
13:30:14 <ab9rf> for any type that has a show instance
13:30:26 <olle> ok, great!
13:30:33 <dmwit> olle: universe offers a Show instance for functions with finite domain.
13:30:34 <dminuoso> olle: Also note that you cant really rely on it, many packages break that rule.
13:30:38 <ab9rf> (and a read instance)
13:30:47 <dminuoso> (sadly)
13:30:51 <dmwit> olle: There are also packages that offer a Show instance which shows the type, or shows a constant string.
13:30:52 <olle> yeah, I would assume.
13:30:52 <hexagoxel> and unfortunately there is no commonly accepted equivalent type class for "toString" functionality
13:31:12 <ab9rf> PrintableRepresentation? :)
13:31:15 <dminuoso> dmwit: These packages should be abolished, their authors hung up and whipped.
13:31:16 <olle> hehe
13:31:29 <ab9rf> dminuoso: we could fundraise that way
13:31:41 <ab9rf> dminuoso: sell the video rights to the WWE
13:31:43 <dmwit> dminuoso: Well, the latter two, obviously. But universe is a righteous force for good.
13:31:47 <dmwit> Also obviously.
13:31:52 <hexagoxel> including a type signature would be valid haskell code, so what's the problem :S
13:32:00 <dmwit> No conflict of interests here, you can take my word as objective fact.
13:32:15 <monochrom> "printable" doesn't cut it. There is a difference between "print for programmer" and "print for end user".
13:32:24 <ab9rf> monochrom: end users suck
13:32:46 <monochrom> Yes.
13:32:47 <dminuoso> hexagoxel: The result of show is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared
13:32:48 <dmwit> monochrom: and "print for send to network", and a dozen other "for"s
13:32:53 <dminuoso> hexagoxel: A type signature is not an expression.
13:33:16 <olle> dmwit: that's serialize, no?
13:33:37 <dmwit> Sure, I can think of other synonyms, too!
13:33:41 <hexagoxel> printing functions appropriately for end users sounds like a fun task
13:33:43 <olle> ;)
13:34:10 <monochrom> It would be great if end users didn't exist. Because then programmers would have no point to exist either. Then all problems caused by programmers (e.g., bugs, poor docs) would not happen in the first place.
13:34:13 <dminuoso> hexagoxel: GHC could dump some stg representation into it, and provide some machinery to demarshal it.
13:34:42 <hexagoxel> you have clever end-users
13:35:13 * hackage parameterized-utils 1.0.1 - Classes and data structures for working with data-kind indexed types  http://hackage.haskell.org/package/parameterized-utils-1.0.1 (RobertDockins)
13:35:34 <mniip> 1534192426 [23:33:46] <dminuoso> hexagoxel: GHC could dump some stg representation into it, and provide some machinery to demarshal it.
13:35:38 <mniip> referential transparency
13:35:43 <ddellacosta> I feel like there is a simpler/more concise way to do this:
13:35:46 <ddellacosta> > foldMap (maybe [] pure) [Just 1, Nothing, Just 2]
13:35:48 <lambdabot>  [1,2]
13:36:09 <dmwit> > catMaybes [Just 1, Nothing, Just 2]
13:36:11 <lambdabot>  [1,2]
13:36:20 <mniip> ddellacosta, print (funrep f)  might depend on how 'f' was reduced exactly
13:36:23 <ddellacosta> dmwit: hahaha, there it is, thanks
13:36:37 <ddellacosta> mniip: sorry, I'm not sure I follow
13:36:59 <dmwit> ddellacosta: it was a misnick
13:37:03 <mniip> oops, that was for dminuoso
13:37:07 <ddellacosta> oh okay, np
13:37:23 <dmwit> ddellacosta: You might like to read the implementation of catMaybes, too: catMaybes xs = [x | Just x <- xs]
13:37:31 <lavalike> @src catMaybes
13:37:31 <lambdabot> catMaybes ls = [x | Just x <- ls]
13:37:50 <ddellacosta> dmwit: yes! That's actually more what I was feeling like I was missing
13:37:52 <ddellacosta> thanks
13:38:43 <dmwit> > foldMap toList [Just 1, Nothing, Just 2]
13:38:45 <lambdabot>  error:
13:38:45 <lambdabot>      Ambiguous occurrence ‘toList’
13:38:45 <lambdabot>      It could refer to either ‘F.toList’,
13:38:47 <dminuoso> mniip: How could reduction affect this?
13:38:50 --- mode: glguy set +v haitlah`
13:39:23 <dmwit> > foldMap F.toList [Just 1, Nothing, Just 2]
13:39:26 <lambdabot>  [1,2]
13:39:27 <dminuoso> mniip: I mean my point is, if you have some `foobar a b = a ++ b` then you could have `show foobar` produce: Stg "[LclId] = [] \u [] let { sat_s1s3 [Occ=Once] :: [GHC.Types.Char] [LclId] = [] \u [] GHC.CString.unpackCString# "bar"#; } in let { sat_s1s2 [Occ=Once] :: [GHC.Types.Char] [LclId] = [] \u [] GHC.CString.unpackCString# "foo"#; } in GHC.Base.++ sat_s1s2 sat_s1s3;"
13:39:38 <dminuoso> Plus quotes fixed
13:39:41 <dminuoso> Or something similar.
13:39:57 <dminuoso> Oh well ghc did some things there. But you get the idea.
13:39:58 <haitlah`> So
13:40:01 <ab9rf> hehe
13:40:07 <haitlah`> dmwit: list comprehension just ignore stuff that you don't match ?
13:40:14 <ab9rf> that's quite the mess of pottage
13:40:35 <ab9rf> i mean, obviously that horrendous mess is obviouslt the same as \a b -> a ++ b
13:40:42 <mniip> dminuoso, that violates referential transparency
13:40:57 <mniip> "show foobar" and "show (id foobar)" should produce the same thing but it would not
13:40:57 <dmwit> haitlah`: More or less, yes.
13:41:06 <dminuoso> mniip: Why should it produce the same thing?
13:41:13 <dminuoso> or well.
13:41:15 <dminuoso> It should yes.
13:41:17 <mniip> because 'id foobar = foobar'
13:41:18 * dminuoso mumbles
13:41:20 <dminuoso> Yeah
13:41:51 <mniip> functions, in presence of general recursion, have no normal form so such a show is impossible
13:42:00 <dminuoso> ab9rf: Beauty really doesnt matter. Show is not meant to be human readable or look nice.
13:42:03 <mniip> se picking between two evils here really
13:42:11 <fragamus> I’m going through typeclassopedia and I have reached ((->) e) which is described as a functor. I want to see an example of fmap applied to this functor
13:42:22 <dminuoso> fragamus: Write the instance yourself.
13:42:29 <dminuoso> fragamus: If it type checks its valid, as long as you dont use bottom.
13:42:52 <dmwit> haitlah`: The exact rule is `[e | p <- l, Q] = let ok p = [e | Q]; ok _ = [] in concatMap ok l`, where here `e`, `p`, `l`, and `Q` are all metavariables.
13:42:52 <mniip> fragamus, 'fmap show negate'
13:42:58 <dmwit> haitlah`: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
13:43:18 <dmwit> > fmap show negate 3
13:43:20 <lambdabot>  "-3"
13:43:38 <haitlah`> dmwit: so cool, thanks :)
13:43:55 <dminuoso> mniip: I'd say it's an acceptable risk. If you do the `read . show` transformation you get two things that are extensionally equivalent.
13:44:17 <dmwit> Are they extensionally equivalent if show lets you observe the difference?
13:44:21 <dmwit> I say no.
13:44:40 <dmwit> Well. Maybe extensionally equivalent, but not contextually equivalent.
13:44:48 <dminuoso> dmwit: But by that logic, couldnt you break referential transparency with TH and half of reflection magic?
13:45:18 <dmwit> Yes, TH breaks referential transparency.
13:45:59 <dmwit> Hell, TH breaks alpha equivalence.
13:46:05 <dminuoso> Otoh.. I really really wouldn't want a mechanism that let's me `read` text into code..
13:46:08 <dminuoso> Especially not at runtime..
13:46:34 <olle> (what's TH...?)
13:46:38 <dminuoso> olle: Template Haskell
13:46:42 <olle> thanks
13:47:39 <dminuoso> dmwit: By the way my test case regarding new-exec is isolated.
13:47:41 <dminuoso> It's quite scary.
13:47:44 <madnight> dmwit: is there any property of haskell that is not violated by TH?
13:48:01 <dminuoso> Or wait, it was new-run =)
13:48:17 <dminuoso> dmwit: https://github.com/dminuoso/cabal-new-run-bug - does anything look out of the ordinary here?
13:48:42 <tombusby> hey, does anyone know where the best places to look for remote functional programming jobs are
13:49:01 <zachk> stackoverflow?
13:49:11 <dmwit> dminuoso: Uh, well, /app is a scary directory to have in your Dockerfile.
13:49:18 <dmwit> I certainly don't have one of those.
13:49:28 <tombusby> zachk: not a lot of haskell jobs there really
13:49:41 <tombusby> I got an ad on reddit the other day for a functional job remote work lsiting site
13:49:44 <dminuoso> dmwit: Uh I take it you are not comfortable with Dockerfile? Or was that a poorly executed joke?
13:49:45 <tombusby> wonderingif any of you know it
13:49:49 <zachk> you said functional, not just haskell :9 
13:50:09 <dminuoso> Asking because I cant tell :o)
13:50:11 <dmwit> dminuoso: Ah, I got the arguments to ADD backwards, didn't I?
13:50:14 <tombusby> zachk: true but there's not a huge amount of functional either, except scala which I doin't really know
13:50:48 <dminuoso> dmwit: It seems so. It copies the contents of the project over into the container, into a dir named /app
13:50:55 <dmwit> dminuoso: Looks pretty plain. I didn't know the "+exe" syntax for constraints but it looks plausible anyway.
13:51:00 <zachk> scala isnt too bad if you know haskell and some oo already 
13:51:15 <tombusby> zachk: I know JAva but I'm rusty. Maybe I'll learn scala
13:51:16 <dminuoso> dmwit: Yeah its not documented anywhere.
13:51:30 <dminuoso> But as with plenty cabal/new-* things you have to discover things in issues!
13:52:20 <mniip> 1534193133 [23:45:33] <dmwit> Hell, TH breaks alpha equivalence.
13:52:21 <mniip> er?
13:52:36 <mniip> I assume you mean code parsed by a quasiquoter - sure
13:53:45 <madnight> https://stackoverflow.com/a/10857227/6593641
13:54:49 <dmwit> mniip: I was thinking of reify, which has the right type to take a name and return its definition; but according to the wiki I'm wrong and reify will never do this.
13:56:48 <mniip> well anything that happens before splicing is just ast processing
13:56:57 <mniip> no wonder it's no preserving invariants you're used to
13:58:15 <monochrom> I can't get my head straight on which direction is reify and which is reflect.
14:01:09 <dmwit> I do not understand dismissing TH as "just AST processing".
14:01:23 <ab9rf> any time i encounter code that uses something called "reify" i usually end up not understanding what the code is doing
14:01:37 <monochrom> The way I understand is that people first decide which direction is best called "reflect", then the other direction is automatically "reify".
14:02:03 <dmwit> It is a process which does not preserve the invariants I am used to; why is it important what algorithm is used to violate the invariants I expected?
14:02:17 <monochrom> And usually "reflect" is the direction that a program asks "what does my own code look like?"
14:02:49 <ZeuPiark> re
14:02:52 <weeirc8089> ohh monochrom I remember u from may year ago u're still here heh
14:03:12 <weeirc8089> many years
14:03:15 <monochrom> I could say the same of shapr, you know.
14:03:40 <dmwit> I could say the same of weeirc8089, except for the part about where I remember them.
14:05:39 <dmwit> In retrospect, that came out a bit meaner than intended.
14:07:23 <EvanR> how does that explain why reflection package is called reflection
14:08:07 <monochrom> It doesn't. Should it?
14:08:31 <lavalike> reflection is the f, reify is the f^-1
14:08:58 <dmwit> I conclude that monochrom is not good at explaining human behavior. I have a feeling he may choose to agree with me.
14:10:10 <monochrom> Yeah, but I'm getting better.
14:11:35 <dmwit> I think you're right. =)
14:11:38 <monochrom> So far the simple model of "your brain knows the right thing to do, and then puts it through a not-gate" works more than 70% of the time.
14:12:18 <dminuoso> When you run a thread that exports instrumentation metrics, would you use async to have the application fail if the instrumentation thread fails?
14:12:30 <dminuoso> Just a naive forkIO feels wrong
14:12:44 <fragamus> :t fmap show negate
14:12:45 <lambdabot> (Num a, Show a) => a -> String
14:13:04 <fragamus> So arrow is a functor
14:13:12 <monochrom> Yes. show . negate
14:14:02 <dminuoso> fragamus: what do you mean by `arrow`
14:14:08 <fragamus> And so functor is not a “box” as described in LYAH
14:14:26 <dmwit> With a bit of work, I think I can convince you that a function is a box.
14:14:43 <dminuoso> That doesn't make the box analogy any more useful though.
14:14:55 <fragamus> Dimwit please proceed
14:14:58 <monochrom> You can view it as a box or container.  "Integer -> Foo" is a huge array of Foo's, indexed by Integer.
14:15:23 <dmwit> fragamus: I have a box with a bunch of `String`s in it.
14:15:23 * dminuoso then challenges dmwit to apply the box analogy to Const.
14:15:31 <dmwit> fragamus: Each `String` is labeled.
14:15:35 <monochrom> But eventually you need to think outside the box.
14:15:46 <dmwit> fragamus: Let's say, for simplicity, that I have 256 `String`s, and I've labeled them in sequence from 0 to 255.
14:16:06 <dmwit> dminuoso: It is a box that doesn't actually contain any values, what's so hard about that?
14:16:25 <monochrom> Fun fact: All theorem provers model arrays as functions.
14:16:26 <dmwit> fragamus: Does that sound box-like to you?
14:16:37 <fragamus> Yes
14:16:47 <dmwit> fragamus: Okay. Now I tell you the type I have given to my box: `Word8 -> String`.
14:17:10 <dmwit> fragamus: That is, if you tell me the label you care about, I'll tell you what `String` I have at that label.
14:17:24 <fragamus> Yeah ok
14:17:32 <dmwit> fragamus: And `fmap` says, if you give me a way to transform a value I have in my box, I'll transform all the values I have in my box.
14:17:38 <fragamus> That is a freaky way to think dude
14:17:40 <dmwit> % :t fmap @((->) _)
14:17:41 <yahb> dmwit: (a -> b) -> (w -> a) -> w -> b
14:17:42 <lavalike> lol
14:17:56 <dminuoso> dmwit: It doesnt feel very useful.
14:18:13 <dmwit> Give me a transformation `a -> b`, and a box with `w` labels containing `a`s, and I'll transform all the `a`s to give you back a box (still with `w` labels) containing `b`s.
14:18:30 <lavalike> dminuoso: operating on all information at once does seem useful
14:18:54 <dmwit> dminuoso: I'm afraid I can't be held responsible for your feelings. =P
14:19:24 <lavalike> dmwit is only responsible for telling you what Strings he has at the labels you ask for
14:19:29 <dminuoso> dmwit: Heh fair enough. I once supported the box model, but I've stepped away from it because it distracts from what Functor is about really.
14:19:39 <monochrom> The container analogy breaks easily.
14:19:52 <dmwit> I agree. But flawed analogies turn out to be pretty good teaching tools sometimes.
14:20:27 <dmwit> By now we know that electrons don't orbit atoms in circles. But it's a pretty good starter model, and I would hesitate to try to teach full quantum electrodynamics to high schoolers.
14:20:30 <monochrom> Oh, it doesn't break always. It's OK for Maybe, Vector, and functions.
14:20:55 <dminuoso> monochrom: Heck it's even okay for things like Promise or IO
14:21:04 <dminuoso> If you run your imagination a bit.
14:21:12 <monochrom> And actually it is refreshing to know of the function<->generalized array equivalence.
14:21:17 <fragamus> Well I am reading typeclassopedia for the purpose of coming to a better understanding so flawed analogies may be a problem
14:21:47 <dminuoso> Promise is like a box with a value that is in - Star Trek Technobabble inbound - a state of temporaly flux.
14:22:14 <dminuoso> fragamus: Functor is fully described by its interface and its laws. :)
14:22:44 <dmwit> fragamus: I think learning many examples of Functors is a very good way to go.
14:23:00 <dmwit> Specific -> general is a time-tested learning technique.
14:24:25 <monochrom> The "container" perspective fails because it is more specialized than Functor.
14:24:52 <monochrom> Most people's idea of "container" includes the tools from Foldable and even Traversable too.  Clearly Functor doesn't have them.
14:24:59 <dminuoso> The main thing `container` breaks with is IO really.
14:25:43 * hackage wl-pprint-console 0.1.0.2 - Wadler/Leijen pretty printer supporting colorful console output.  http://hackage.haskell.org/package/wl-pprint-console-0.1.0.2 (minad)
14:25:55 <monochrom> So a lot of basic examples of Functor feel like "containers" because they are [], Maybe, Vector, which also happen to be Foldable and Traversable.  But you need to expect that it doesn't scale.
14:26:15 <ab9rf> ding
14:26:43 * hackage intro 0.3.2.0 - "Fixed Prelude" - Mostly total and safe, provides Text and Monad transformers  http://hackage.haskell.org/package/intro-0.3.2.0 (minad)
14:27:01 <monochrom> You need to see that "obviously" just having fmap and its pretty lax laws is pretty weak actually. There are a lot of things you can't do.
14:27:59 <dmwit> Yes. It is pretty rare to see Functor in a type signature.
14:28:07 --- mode: glguy set +v SirKasimir
14:28:43 * hackage writer-cps-transformers 0.1.1.4 - WriteT and RWST monad transformers  http://hackage.haskell.org/package/writer-cps-transformers-0.1.1.4 (minad)
14:29:13 * hackage colorful-monoids 0.2.1.2 - Styled console text output using ANSI escape sequences.  http://hackage.haskell.org/package/colorful-monoids-0.2.1.2 (minad)
14:29:19 --- mode: glguy set +v humanoyd
14:29:45 <humanoyd> What is the easiest way to get the reduced row echelon form of an hmatrix-matrix?
14:30:17 <fragamus> Ok so fmap show negate   sucks up negate and returns   show .  negate
14:30:45 <Gurkenglas> <hexagoxel> Gurkenglas: i vaguely remember you asking for the most specific implementation matching the query :p <- it doesn't count as most specific if you're specializing it explicitly
14:31:10 --- mode: glguy set +v Guest13090
14:31:43 * hackage optima 0.2 - Simple command line interface arguments parser  http://hackage.haskell.org/package/optima-0.2 (NikitaVolkov)
14:31:48 <monochrom> humanoyd: Perhaps luPacked?
14:32:05 <fragamus> :t putStrLn
14:32:06 <lambdabot> String -> IO ()
14:33:00 <orion> Is there a lens combinator which takes in a (Maybe a) and, if Just, set the value, if Nothing, leave the value unchanged?
14:34:07 <fragamus> :t getString
14:34:09 <lambdabot> error:
14:34:09 <lambdabot>     • Variable not in scope: getString
14:34:09 <lambdabot>     • Perhaps you meant ‘getting’ (imported from Control.Lens)
14:34:25 <monochrom> getLine?
14:34:31 <fragamus> :t getLine
14:34:32 <lambdabot> IO String
14:35:03 <humanoyd> monochrom: doesn't seem to work :/
14:35:04 <zachk> orion: try something like (Just 5) & _Just %~ (+5) 
14:35:07 --- mode: glguy set +v albeit
14:35:15 <albeit> Is it possible to write an Aeson FromJSON instance for something like "Int -> Foo"? If so, how do I encode the Int value passed in from outside the parser?
14:35:16 <monochrom> You read the doc of luPack?
14:35:18 <fragamus> fmap reverse getLine
14:35:27 <zachk> > (Just 5) & _Just %~ (+5) 
14:35:29 <lambdabot>  Just 10
14:35:40 <zachk> > Nothing & _Just %~ (+5) 
14:35:42 <lambdabot>  Nothing
14:35:51 <orion> That's not quite what I want.
14:35:55 <zachk> or just fmap
14:36:04 <zachk> > fmap (+5) (Just 5) 
14:36:05 <dmwit> albeit: Possible? Probably. But I suspect you are making a mistake somewhere if you want that.
14:36:07 <lambdabot>  Just 10
14:36:12 <zachk> > fmap (+5) Nothing
14:36:13 * hackage writer-cps-mtl 0.1.1.5 - MonadWriter orphan instances for writer-cps-transformers  http://hackage.haskell.org/package/writer-cps-mtl-0.1.1.5 (minad)
14:36:15 <lambdabot>  Nothing
14:36:18 <humanoyd> monochrom: yes
14:36:35 <orion> zachk: I want a function (Lens s t a b -> Lens s t a (Maybe b))
14:36:44 <fragamus> :t fmap (read::String->Int) getLine
14:36:45 <lambdabot> IO Int
14:36:48 <dmwit> > 3 & id %~ maybe id const (Just (+5))
14:36:50 <orion> I think I can write one myself, but if one already exists I should use that.
14:36:50 <lambdabot>  error:
14:36:51 <lambdabot>      • No instance for (Num (Integer -> Integer))
14:36:51 <lambdabot>          arising from a use of ‘e_135’
14:36:57 <zachk> :t _Just 
14:36:58 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
14:37:09 <albeit> dmwit: Could be. I have a datatype that has three fields, two of which are read from the parsed data and one is known prior. How would the FromJSON instance when the field known prior isnt part of the json data?
14:37:13 <fragamus> Ok where’s the box in that
14:37:30 <fragamus> 1
14:37:34 <monochrom> The box of IO >:)
14:37:49 * hackage wl-pprint-annotated 0.1.0.1 - Pretty printer with annotation support  http://hackage.haskell.org/package/wl-pprint-annotated-0.1.0.1 (minad)
14:37:54 <fragamus> The box that contains the universe
14:38:30 <monochrom> getLine is a box that contains a string that I will input tomorrow, and right now I don't even know what I want to input tomorrow, but the box already knows!
14:39:07 <monochrom> #determinism #Leibniz #preordained #freewill
14:39:34 <fragamus> Ok I don’t smoke funny cigarettes
14:39:45 <dmwit> albeit: parseJSON v = liftA2 (MyConstructor knownFirstField) (parseJSON v) (parseJSON v) -- ?
14:39:59 <monochrom> Anyway if you read the serious sentences we wrote earlier, we already said that the box story doesn't go far.
14:40:01 <shapr> monochrom: yay! you still remember me!
14:40:23 <monochrom> Think outside the box.
14:40:27 <fragamus> Ok
14:40:36 * dmj` wishes haskell-mode had better integration with ghcid 
14:41:09 <albeit> dmwit: Okay, that's what I'm doing now, guess I'll stick with that.
14:41:48 <dmwit> albeit: You can also just write whatever function you want. It doesn't have to be named parseJSON and be a part of a FromJSON instance.
14:42:29 <dmwit> fragamus: I have a Rube-Goldberg device box. Opening the box involves a bunch of shenanigans that do strange things to the world. But once it's open, I have a plain value inside.
14:42:51 <dmwit> fragamus: getLine is the Rube-Goldberg device which interacts with the user for a little while before opening its box.
14:43:01 <dyamon> Hi! I have different error types in my project (ParseError from a parser module, IOError reading a file, ...), and I'd like to build a common Error to be able to deal with any of them in the main computation. Definining a union of these is an option, but can I achieve the same with type classes?
14:43:16 <fragamus> Dimwit that helps
14:43:30 <dmwit> fragamus: fmap read getLine makes a new Rube-Goldberg device which is just like the old one, except it does even more stuff before the box is open. Specifically: it interacts with the user a bit, and then does some parsing, and *then* the box is open.
14:43:35 <orion> zachk: This does what I want in the specific case, but not the general case: foo l = lens _bar (\s b -> s { _bar = fromMaybe (_bar s) b })
14:44:13 <fragamus> Ok nice
14:44:41 <monochrom> This is a Pandora's box.
14:45:18 <fragamus> No it easy now
14:45:30 <dmwit> > 3 & id %~ maybe id id (Just (+5)) -- orion
14:45:32 <lambdabot>  8
14:45:33 <fragamus> Functor is a box
14:45:42 <dmwit> > 3 & id %~ maybe id id Nothing
14:45:44 <lambdabot>  3
14:46:04 <dmwit> The first `id` is a lens. The second two `id`s are part of my implementation of your combinator.
14:46:21 <dmwit> :t \l mf -> l %~ maybe id id mf
14:46:22 <lambdabot> ASetter s t b b -> Maybe (b -> b) -> s -> t
14:46:57 <dmwit> Oh, wait, you want to set it to the constant contained in the Maybe?
14:47:10 <dmwit> :t \l mf -> l %~ maybe id const mf
14:47:12 <lambdabot> ASetter s t b b -> Maybe b -> s -> t
14:49:36 <hvr> monochrom: yes, current main reason for 'base' being on hackage is its haddocks
14:49:45 <monochrom> So here is another problem with the box story.  Later you will be able to tell box stories of Applicative and Monad too.  So why do you have 3 classes if they're all "box"es?  At least two of them cannot be "box"es.  So what went wrong?
14:50:33 <monochrom> Not to mention Foldable and Traversable.
14:51:03 <dmwit> I object to "at least two of them cannot be 'box'es".
14:51:07 <dmwit> Convince me.
14:51:47 <monochrom> Do you now start imagining "besides boxes, there are also envelopes, plastic bags, paper wraps, and environmentally friendly shopping bags"?
14:52:25 <Gurkenglas> :t let foo :: Lens a a a (Maybe a); foo f a = fromMaybe a <$> f a in foo -- zachk, this?
14:52:27 <lambdabot> Functor f => (a -> f (Maybe a)) -> a -> f a
14:52:32 <dmwit> No. But I do start imagining, "There is encryption, and homomorphic encryption, and secret-sharing encryption. At least two of these three cannot be encryption.".
14:52:47 <monochrom> There are 3 classes, with differing methods aka capabilities. If one of them corresponds to "box", the other two cannot.
14:52:57 <Gurkenglas> Wait, wrong guy. orion, what I wrote?
14:53:22 <orion> dmwit: That did the trick, thanks. :)
14:53:28 <fragamus> Functor is a box what is fucked up
14:54:46 <Gurkenglas> @let foo f a = fromMaybe a <$> f a; bar :: Lens s t a a -> Lens s t a (Maybe a); bar = (. foo)
14:54:48 <lambdabot>  Defined.
14:55:25 <Gurkenglas> Note that this isn't type-compatible with the lens laws
14:55:49 <monochrom> You have inclusion in mind. I have exact equivalence in mind.
14:57:57 <fragamus> The Rube Goldberg box is an awesome analogy
14:58:50 <fragamus> My fmap read getLine  just adds a little more mechanism to the box
15:02:15 <dmwit> (An aside, completely unrelated to learning Functor, Applicative, or Monad: use readLn, not fmap read getLine.
15:02:18 <dmwit> )
15:02:53 <glguy> It's not just shorter; fmap read hides failed parses
15:10:39 <ChaiTRex> Does anyone know a feed URL for the entirety of Hackage usable with Zeal/Dash?
15:11:26 <monochrom> fmap readMaybe getLine may be better.
15:11:42 <monochrom> (Yes today I am full of puns on box and maybe.)
15:12:14 <monochrom> (At least I haven't brought up Schrödinger's box)
15:18:47 --- mode: glguy set +v smudge
15:19:49 <smudge> Hello, I have a question. Why does the Foldable class consider foldMap or foldr to be more fundamental than toList?
15:20:55 <hpc> :t toList
15:20:56 <lambdabot> error:
15:20:56 <lambdabot>     Ambiguous occurrence ‘toList’
15:20:56 <lambdabot>     It could refer to either ‘F.toList’,
15:20:56 <glguy> Because the other operations can be more efficiently implemented in terms of foldMap or foldr than toList
15:21:19 <hpc> because they might traverse it differently than a regular list fold
15:21:26 <hpc> :t foldMap
15:21:27 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
15:21:41 <hpc> it uses mappend, which can associate either way
15:21:49 <glguy> toList introduces an intermediate list into the mix that typically isn't needed
15:22:13 <glguy> Implementing foldr or toList each offer the same associativity issues
15:22:32 <glguy> (potential issues)
15:22:55 <hpc> a sort of fuzzier reason, but Foldable abstracts over catamorphisms and not things that are shaped like lists
15:23:01 <hpc> so it's closer to the concept the code is trying to express
15:23:16 <smudge> ok interesting
15:23:24 <smudge> I should probably learn more about catamorphisms
15:24:27 <hpc> a catamorphism is basically just a thing that collapses a collection into a single thing
15:25:47 <dmwit> Can you collapse a box?
15:25:58 <madnight> hpc: e.g. foldr
15:27:47 <dstolfa> hpc: so, the opposite of what catmorphism is. you know, when cats push glass off the table and break it into a billion pieces
15:28:30 <smudge> hahaha, what is the opposite called?
15:28:37 <hpc> a catastrophe
15:28:42 <dstolfa> :))))))
15:29:57 <madnight> https://i.pinimg.com/564x/ac/5e/ab/ac5eaba1fd8a73b0378b3e1fca723699--cat-humor.jpg
15:30:46 <smudge> how is it possible to implement foldr in terms of foldMap when foldr doesn't require Monoid class constraint?
15:31:11 <madnight> foldr requires Foldable
15:31:49 <hpc> foldr f z t = appEndo (foldMap (Endo #. f) t) z
15:33:05 <hpc> (#.) is a weird type trick
15:33:33 <smudge> so it's a hack?
15:33:59 <hpc> http://hackage.haskell.org/package/base-4.11.1.0/docs/src/Data.Functor.Utils.html#%23. - see the comment at the bottom here, it's an optimization
15:33:59 <dmwit> Hack? No. Endo is an important Monoid.
15:38:08 --- mode: glguy set +v drmr
15:38:59 <Tuplanolla> The coercion is the hack there, dmwit.
15:39:33 --- mode: glguy set +v nicekor
15:39:44 <nicekor> hi
15:40:02 <humanoyd> monochrom: just to clarify, did you find a way to get the reduced row echelon form with luPacked?
15:43:26 <glguy> drmr: gotta read your direct messages
15:43:49 <drmr> oh thanks !
15:43:55 <drmr> ok I will register
15:44:13 * hackage optima 0.3 - Simple command line interface arguments parser  http://hackage.haskell.org/package/optima-0.3 (NikitaVolkov)
15:46:37 --- mode: glguy set +v BKD
15:46:52 <BKD> ok, after all my problems I went back to a pre-Haskell backup. I have everything downloaded but only Xcode, Visual Studio Code and Haskero are installed. Would somebody please walk me through getting wxHaskell set up correctly?
15:47:35 --- mode: glguy set -v roidusilence
15:48:38 <roidusilence> say I have this type : data A = X Foo | B Bar Foo |  C Qux Bar Foo can I use template haskell to generate a function that will always return the "last" element of the datatype no matter the data constructor, the one with type Foo ?
15:51:14 <Tuplanolla> Considering how prisms are generated, the answer is yes, roidusilence.
15:51:49 <glguy> It'd be even shorter using syb
15:52:06 <lavalike> BKD: is it more complicated than installing wx from homebrew and the relevant haskell packages with cabal?
15:52:52 <roidusilence> thats great
15:53:19 <glguy> Template Haskell can generate arbitrary expressions and definitions. It's a very manual process of just generating the Haskell syntax you want
15:54:34 <BKD> Every time I try it that way, I get errors from "cabal install wx". Is there another option?
15:55:19 <lavalike> BKD: brew puts the libraries in peculiar places, often it tells you what linker options to pass to compilers to find the libraries
15:56:25 <BKD> I'd rather avoid home-brew/etc as I don't need it for anything else?
15:56:54 <lavalike> BKD: how are you getting wxWidgets installed instead?
16:00:06 <BKD> download and follow their Mac install directions. All of their included samples and demos build and run correctly. I installed it to "/usr/local/wxWidgets" and set WXWIN to "/usr/local/wxWidgets" in my .bash_profile
16:02:01 <lavalike> BKD: have you come across this? https://wiki.haskell.org/WxHaskell/Mac
16:02:53 <lavalike> I wonder why it says "cabal install wx cabal-macosx"
16:03:13 <lavalike> (step 3 seems important too)
16:04:24 <madnight> https://www.corajr.com/posts/2014/12/22/nix-osx-haskell/
16:06:29 <BKD> yes, following those directions is where I get the "cabal install" error
16:07:41 <lavalike> what errors do you get?
16:09:30 <madnight> BKD with nix you don't need brew
16:10:32 <BKD> lavalike: the error gist is at https://gist.github.com/Bryan-Dunphy/cdd1995d752f1431b45b2e3f25f195fc
16:11:08 <lavalike> BKD: looks like it can't find wx-config, does "which wx-config" work for you?
16:11:48 <BKD> midnight: I tried Nix, it was more confusing than homebrew and has no uninstall as well
16:12:05 <suzu> HIE vs intero
16:12:19 <suzu> what do
16:12:36 <BKD> lavalike: it returns "/usr/local/bin/wx-config"
16:12:50 <lavalike> BKD: interesting
16:13:38 <lavalike> BKD: I can't reproduce this on my system, cabal install wx fails with dependency resolution problems :(
16:14:43 * hackage brick-skylighting 0.3 - Show syntax-highlighted text in your Brick UI  http://hackage.haskell.org/package/brick-skylighting-0.3 (JonathanDaugherty)
16:15:13 * hackage optima 0.3.0.1 - Simple command line interface arguments parser  http://hackage.haskell.org/package/optima-0.3.0.1 (NikitaVolkov)
16:18:58 <mniip> hmm
16:19:35 <mniip> is there any reason the GHC solver can solve KnownNat 2, 2 + 2 ~ 4, but not  KnownNat n => KnownNat (n + 1)
16:20:39 <mniip> I wonder if it'd be feasible to have a typeclass with  proxy (n :: Nat) -> Maybe Natural
16:20:55 <mniip> with the intention that an irreducible (invalid) type family application like (2 - 5) turns into Nothing
16:21:53 <mniip> then you could have (MaybeKnownNat n, MaybeKnownNat k) => Maybe (n :~: k)
16:22:00 <mniip> and then you could express the fact that  n - n always reduces to 0
16:22:15 <mniip> (cause currently you need KnownNat (n - n))
16:24:58 <mniip> I hate how everything typelits is kind of jammed in with plugins
16:26:37 <dmwit> ...I was going to say I think there's a plugin for the Presburger algorithm, then I saw your last line. =P
16:29:20 <mniip> dmwit, not really concerned about Nat equality there
16:29:37 <mniip> I can just assert that whenever I want with sameNat
16:29:45 <mniip> *provided* I know both are KnownNats
16:31:35 <madnight> I recently stumbled upon this https://github.com/ocharles/hlint-source-plugin and now I wonder how hard it is to import http://hackage.haskell.org/package/haskell-src-exts-1.20.2/docs/Language-Haskell-Exts.html and write a GHC extension?
16:37:24 <pavonia> madnight: How are GHC extensions and haskell-srcs-exts related?
16:39:02 <madnight> madnight: im not sure, but haskell-src-ext provides a way to intercept the ghc compilation process and doing some stuff (linting)
16:39:41 <madnight> s/madnight://g
16:40:38 <pavonia> I don't think it does that
16:42:51 <madnight> pavonia: then how does the hlint-source-plugin work?
16:43:39 <pavonia> It seems to use a plugin interface provides by GHC
16:43:51 <geekosaur> HSE is a standalone parser, hence easier to work with than GHC's. it is independent of GHC's, though
16:44:05 <geekosaur> which is why the not eunder future work saying that it has to re-parse the source again
16:44:21 <geekosaur> as a ghc plugin, all it's doing is arranging to run hlint during compilation
16:44:27 <geekosaur> it's not *using* ghc
16:45:35 <madnight> hmm okay, but if i would like to prepocess the haskell source, e.g. do some rep
16:45:49 <geekosaur> this is the wrong way to do it
16:46:05 <madnight> lacements, then I could write a ghc plugin?
16:46:07 <geekosaur> preprocessing would be done with a source plugin, which is new in ghc 8.6 iirc
16:46:20 <geekosaur> and is possibly still easier to do with -pgmF
16:48:31 <madnight> basically I would like to experiment with a few languages feature that i could some easily write as loadble plugin (just for me, no proposal or something)
16:52:04 <madnight> e.g. in js such extensions are scriptable with babel
16:58:50 <erikd> I've got a vector of `Data.Vector.Storable a` from which I can get the ForeignPtr and a length. is there a way to write from that `ForeignPtr` to disk and similarly read from disk directly into a `ForeignPtr`?
17:04:08 <dmwit> erikd: You can probably write a tiny FFI call to `write`, that would likely be the lowest-overhead way to do it.
17:04:34 <dmwit> The cheapest in programmer time (esp. debugging time) is probably to make an intermediary ByteString.
17:05:36 <erikd> thanks dmwit i'll see how i go with the FFI call :)
17:05:38 <ClaudiusMaximus> :t hPutBuf
17:05:39 <lambdabot> error: Variable not in scope: hPutBuf
17:06:05 <dmwit> erikd: http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#g:24
17:06:26 <dmwit> erikd: write is going to be fun because you get to handle all the stuff the IO manager usually does for you manually instead.
17:07:10 <dmwit> e.g. dealing with EAGAIN or smaller return values than the count you passed or whatever.
17:07:37 <BKD> lavalike: new problem wxhaskell's configure works but "make" returns "You must specify at least one -dep-suffix make: *** [dist/wxdirect/MultiSet.o] Error 1" Ideas?
17:07:40 <erikd> ah yes, maybe fwrite/fread makes more sense
17:07:52 <ClaudiusMaximus> https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html#v:hPutBuf https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html#v:hGetBuf https://hackage.haskell.org/package/base-4.11.1.0/docs/Foreign-ForeignPtr.html#v:withForeignPtr erikd i would use these
17:07:59 <ab9rf> it's so much fun to work directly with syscalls
17:08:07 <dmwit> erikd: I really think it would be best to start with a mediating ByteString.
17:08:15 <erikd> ClaudiusMaximus: i think you may be correct. thanks!
17:08:16 <dmwit> Optimize later when you know that's the bottleneck.
17:08:44 <dmwit> ClaudiusMaximus++
17:09:20 <erikd> dmwit: i am aleady at the otimize stage, but you are right i should stick with optimize and then got to extreme optimize :)
17:39:24 <erikd> dmwit, ClaudiusMaximus : so easy :) https://gist.github.com/erikd/fd4f528b49cc83bbba9a125590ea72dd
18:02:16 --- mode: glguy set +v mac10688_
18:02:29 <mac10688_> does anyone know if that's supposed to be a regular Stack type in haskell
18:02:58 <mac10688_> I'm looking for a reusable Stack data type in haskell. I'm surprised there isn't just a Stack module or something out there
18:03:07 <Cale> Usually I'd just use a list
18:03:17 <Cale> Lists have exactly the properties you'd want from a stack
18:03:51 <mac10688_> ok let me see how that will fit
18:06:39 <mac10688_> ok thank you I will see how that can fit
18:06:51 <mac10688_> for some reason i'm mac10688_. I'm gonna resign in
18:08:25 --- mode: glguy set +v mac10688
18:08:38 <mac10688> hmm my client is opening the all servers twice. oh well. Thanks for the help. I see how list will work
18:08:58 <mac10688> i was thinking about using it earlier but I got so caught up in demanding a Stack data structure
18:10:39 <elpfen> QQ any opinions on rest client packages?
18:25:26 --- mode: glguy set +v brunoooo
18:26:11 <brunoooo> I just want to remove it to install a previous version :(
18:35:12 <mac10688> :t (!?)
18:35:13 <lambdabot> error:
18:35:13 <lambdabot>     • Variable not in scope: !?
18:35:13 <lambdabot>     • Perhaps you meant one of these:
18:35:34 <dmwit> brunoooo: Remove what?
18:35:59 <dmwit> brunoooo: (In case you wrote a previous message that answers that question, you'll have to repeat it. See your privmsgs for details.)
18:36:25 <brunoooo> Hi, how to downgrade a package using stack? Using cabal 2.2.0.0 broke stack and I can't remove it
18:38:01 <dmwit> It's not super clear to me how installing a different cabal executable could break stack. But under normal circumstances, installing a different version of cabal can be done with e.g. `cabal install cabal-install --constraint "cabal-install<=2.1"` or whatever constraint you want.
18:38:18 <dmwit> If you have a specific version in mind you can use "cabal-install==X.Y.Z".
18:38:44 <dmwit> If you share some more details on the error, we may be able to help you with the error directly instead of helping you with your guess at what the solution is.
18:39:18 <dmwit> (Which may be right! I'm not claiming you're wrong. But usually it's best to give details on the root problem.)
18:39:35 <mac10688> how do I import (!?) specifically from Data.Map.Lazy? I have "import qualified Data.Map.Lazy as Map (fromList, (!?))"
18:39:37 <brunoooo> okay so I'm trying to do stack solver, I get "Installed version of cabal-install (2.2.0.0) is newer than stack has been tested with.  If you run into difficulties, consider downgrading."
18:39:40 <brunoooo> then a crash
18:39:40 <mac10688> oh wait nvm
18:39:48 <brunoooo>  error, called at src/Stack/Solver.hs:173:16 in stack-1.7.1-JqFYW3fz7If7um4NzPRwPj:Stack.Solver
18:40:00 <dmwit> mac10688: You can `import Data.Map.Lazy (fromList, (!?)); import qualified Data.Map.Lazy as Map`
18:40:31 <mac10688> dmwit, yeah... as soon as i paste it I think of that. I was looking at it for like 6 minutes. Never fails
18:40:38 <acowley> Is there a nice point free way to write (d -> e) -> (a -> b -> c -> d) -> a -> b -> c -> e ?
18:40:39 <mac10688> thanks
18:40:47 <acowley> It's eluding me
18:40:47 <stevejb> greetings, what is a good way to read a Text and attempt to convert to Double only if all characters are numeric
18:41:01 <stevejb> E.g. f "47" = Just 47.0
18:41:04 <brunoooo> if I do "stack install cabal-install-1.24.0.2", I get Cabal-2.2.0.1 from stack configuration does not match >=1.24.2 && <1.25  (latest matching version is 1.24.2.0)
18:41:09 <stevejb> f "47.0" = Just 47.0
18:41:14 <stevejb> f "47a" = Nothing
18:41:19 <dmwit> acowley: (.) . (.) . (.)
18:41:27 <dmwit> acowley: one `(.)` per argument you want to drop under
18:41:35 <mac10688> stevejb, I think there is a isDigit from Data.Char
18:41:48 <mac10688> stevejb, I think you can use the all function to test it first
18:42:11 <mac10688> all isDigit "2342"
18:42:27 <dmwit> stevejb: There is `readMaybe`, though that will also give you `Just` for things like `1.3` and `-3.4e5`.
18:42:48 <stevejb> dmwit: that seems okay
18:42:55 <dmwit> I figured it would be. =)
18:43:00 <stevejb> mac10688: thank you as well
18:43:12 <sclv> brunoooo: getting Cabal higher doesn't mean cabal-install higher
18:43:26 <sclv> older versions of the cabal-install executable can still build with the latest Cabal library
18:43:31 <sclv> and its fine
18:44:12 <ClaudiusMaximus> > case reads "123cabbage" of [(n, rest@"")] -> Just n ; _ -> Nothing
18:44:14 <lambdabot>  Nothing
18:44:23 <brunoooo> I just want to tell stack to use a version that doesn't make stack crash, I don't know what to do for that :/
18:44:40 <dmwit> ClaudiusMaximus: That is essentially what readMaybe does, except that it checks whether `all isSpace rest` instead of `null rest`.
18:45:31 <sclv> brunoooo: using a newer Cabal lib should give a cabal binary that stack is still compat with
18:45:40 <sclv> oh i see
18:45:55 <sclv> you can't install cabal-install because stack is pinned to a newer dep
18:45:59 <dmwit> ClaudiusMaximus: Also, why the as-pattern? =)
18:46:35 <sclv> brunoooo: you can just download the binary of older releases for common platforms: https://www.haskell.org/cabal/download.html
18:47:26 <ClaudiusMaximus> dmwit: documentation!
18:47:30 <sclv> brunoooo: actually the right link for that is https://www.haskell.org/cabal/release/
18:48:14 <sclv> which takes you to https://www.haskell.org/cabal/release/cabal-install-1.24.0.2/
18:48:24 <brunoooo> where do I put it?
18:48:36 <sclv> brunoooo: what OS are you on?
18:48:44 <brunoooo> linux
18:49:10 <sclv> ok so you can type "which cabal" to see where your current binary is
18:49:26 <sclv> since the current is newer you prob don't want to delete it, but you could move it to like "cabal2" or something for now
18:49:36 <sclv> and just put the new one in the same spot
18:49:45 <sclv> or you can put it anywhere else it'll have precedence in your path
18:49:55 <sclv> i think stack just uses whatever cabal-install binary it finds lying around
18:53:10 <brunoooo> it's a binary and I got the source code, so I have to build it?
18:59:05 --- mode: glguy set +v adrice727
18:59:57 <adrice727> I'm guessing it has something to do with this line `( "X-SOME-AUTH", C8.concat $ fmap convertString $ toCompact signedJWT)`
19:01:06 <acowley> dmwit: Yeah, I prefer fmap fmap fmap for no good reason, but I was wondering if there was a set of definitions along the lines of liftA3 already in base
19:03:56 <glguy> adrice727: gotta read your messages
19:06:21 <brunoooo> alright I'm going to bed thanks for the help I will build cabal tomorrow!
19:07:32 <sclv> sigh
19:08:04 <sclv> the idea that you can just install an executable without building it is weird to people
19:08:47 <glguy> Where would you put the optimization flags if you downloaded a executable?
19:15:24 <dmwit> acowley: I don't think so. This is plain fmap at an appropriate Compose type, but writing the type signature needed to use `coerce fmap` is going to be more painful than just writing `fmap . fmap . fmap` in the first place.
19:16:51 <mniip> hmm, I don't think I can make instances on type family applications can I
19:17:13 <mniip> even if there's no coaxioms for those particular type family applications
19:20:37 <droplet> I'm struggling to get stack to be happy with two executables, the generated .cabal file includes the source of both executables in the other-modules field of both executables
19:21:05 <mniip> guess not
19:21:47 <mniip> definitely doable in Core for Nat however, and doesn't violate coherence
19:22:52 <glguy> droplet: you can delete the package.yaml and fix the cabal file
19:23:44 <droplet> glguy: Is this just something package.yaml files can't handle then?
19:24:28 <glguy> There's probably a way to handle it there but it's a good idea to stick with normal cabal files anyway
19:24:53 <droplet> Oh, I thought package.yaml files were preferred to dealing with .cabal files
19:25:11 <glguy> Nope, just happen to be the default in a stack template
19:25:59 <droplet> Hm okay thanks
19:31:59 <adrice727> If anyone is familiar with generating JWTs with jose, I'm running into a malformed token issue and I'm not sure why.  https://gist.github.com/adrice727/db4774aea0fe3711a99a7cd03dc8b2fb
19:32:02 <adrice727> I'm guessing it has something to do with this line `( "X-SOME-AUTH", C8.concat $ fmap convertString $ toCompact signedJWT)`
19:37:34 <droplet> @glguy Using lowercase names for the exec sources fixed it
19:37:35 <lambdabot> Unknown command, try @list
19:37:56 <droplet> glguy: Why are cabal files better?
19:38:28 <sclv> they give you the full syntax
19:38:35 <sclv> package.yaml files just desugar to them
19:38:44 <glguy> They're compatible across more tools, don't use yaml, direct access to cabal functionality
19:38:45 <sclv> but sometimes the desugaring can be confusing or not give what you want
19:38:50 <glguy> more people use them so its easier to get help
19:39:59 <droplet> that makes sense, but I find it weird theyre in the stack default template in that case
19:40:08 <glguy> I agree
19:40:16 <dmwit> A meta-comment: the cabal file format is a little bit complicated. I can see why somebody would want a simpler format. But it turns out that almost every complication that's in there is in there because it helped somebody solve a build problem.
19:40:41 <dmwit> Simpler is a noble goal, but build systems are not simple.
19:41:48 <DoomGuyFieri> Hi everyone. I've heard good things about this channel and have been wanting to learn a functional language, so I'm excited to be here.
19:43:05 * dmwit waves
19:43:26 <Cale> Hi DoomGuyFieri -- feel free to ask any questions you might have about Haskell
19:44:11 <mniip> dmwit, I wish it were just all makefiles down the road
19:44:37 <DoomGuyFieri> I guess my first question is about dev environments. I usually use Jetbrains products. Do those have good support for Haskell or should I look elsewhere?
19:45:16 <mniip> DoomGuyFieri, when developing in a functional language due to high level of composition involved you don't usually make a lot of use of "classical" IDE integration features
19:45:39 <mniip> so "just a text editor" wouldn't impair your experience much
19:46:27 <mniip> I mean, anything works
19:47:21 <dmwit> mniip: Can't tell if sarcastic. I do not miss Makefile debugging at all; I do not miss manual dependency-chasing for Makefiles at all; I do not miss the awful make language when creating a new Makefile at all.
19:47:50 <DoomGuyFieri> mniip, alright cool. Thanks a lot!
19:51:48 <Cale> One thing I generally recommend is keeping open at least two windows: one for whatever text editor you like, and one for ghci. You can load the code you're working on in ghci and whenever you edit it, use :r to reload. You might also like "ghcid" for a tool that watches your project whenever a file changes and reports any errors/warnings.
19:52:22 <MarcelineVQ> ghcid is the only completely consistent too I've tried so far
19:52:28 <MarcelineVQ> *tool
19:52:34 <Cale> Personally, I also like using hasktags along with my editor's tags support to jump-to-definition
19:54:29 <dmj`> MarcelineVQ: do you use it with haskell-mode emacs?
19:55:03 <dmj`> MarcelineVQ: if so, how? Inside of an eshell?
19:55:14 <MarcelineVQ> I use it in it's own terminal on my other screen
19:58:08 <dmj`> MarcelineVQ: I open an eshell, then a nix-shell inside of it, then cabal configure, then finally start ghcid, and sometimes I have to restart and do the whole thing over again
19:59:10 <DoomGuyFieri> Alright. I use VS Code for my JS development, so I can probably just install some Haskell extensions and be up and running in no time.
20:00:13 <mac10688> weird that there isn't a maybeHead function in prelude
20:00:31 <glguy> Data.Maybe.listToMaybe is in base, at least
20:00:43 <glguy> but case expressions are usually good enough
20:01:50 <mac10688> oh i didn't consider doing case on list
20:01:55 <mac10688> yeah i'll do that
20:02:01 <mac10688> keep it simple
20:03:28 <MarcelineVQ> there's too much bloat in base for convenience anyway :>
20:03:50 <MarcelineVQ> :t fmap fst . uncons
20:03:51 <lambdabot> [b] -> Maybe b
20:08:02 <chessandgo> is Crypto.Random the recommended module for cryptographically secure numbers?
20:09:14 <dmj`> @package entropy
20:09:14 <lambdabot> http://hackage.haskell.org/package/entropy
20:09:28 <dmj`> @package DRBG
20:09:28 <lambdabot> http://hackage.haskell.org/package/DRBG
20:09:54 <chessandgo> isnt that for using the underlying OS's entropy manually?
20:10:10 <sclv> droplet: btw if your executables are all sharing a code directory, that might be the reason?
20:25:59 <tcsiwula> Does anyone know how I can use the curl command to query a Network.HTTP.Client server that is running?
20:28:25 <suzu> Network.HTTP.Client doesn't serve webpages
20:29:06 <tcsiwula> Sorry I meant Network.HTTP.Server. Not for a webpage but for an executable on a remote sever
20:30:57 <mac10688> I saw someone using a tool the other day in a medium article for haskell and I was wondering if Linux had a similar tool. https://medium.com/urbint-engineering/haskell-lens-operator-onboarding-a235481e8fac. This guy uses a tool called dash and he can search for haskell documentation without going to a webpage
20:35:16 <chessandgo> mac10688: zeal?
20:35:25 <chessandgo> zeal has haskell documentation
20:37:43 * hackage hpack 0.29.7 - A modern format for Haskell packages  http://hackage.haskell.org/package/hpack-0.29.7 (SimonHengel)
20:38:18 <droplet> sclv: this was the case but i expected that to work fine
20:38:54 <mac10688> oh let me check that chessandgo 
20:39:08 <mac10688> and let me know if you want to play a chess game
20:39:49 <mac10688> wow this zeal thing is looking like just what I wanted
20:40:45 <chessandgo> ha! id be quit rusty at chess
20:42:33 <pavonia> tcsiwula: Why would a request from curl be different for a Haskell server than for any other one?
20:43:23 <chessandgo> it reads the curl's default user agent and tells you to stop using C
20:47:37 <ab9rf> chessandgo: a server that refuses to serve requests for certain user agents?
20:48:54 <chessandgo> its possible but i was joking
20:49:05 <fragamus> :t fmap negate negate
20:49:06 <lambdabot> Num b => b -> b
20:49:24 <fragamus> fmap negate negate 3
20:49:48 <fragamus> :t contramap negate negate
20:49:50 <lambdabot> (Num b, Contravariant ((->) b)) => b -> b
20:49:59 <chessandgo> > fmap id id 1
20:50:01 <lambdabot>  1
20:50:27 <fragamus> contramap negate negate 3
20:51:01 <fragamus> > contramap negate negate 3
20:51:03 <lambdabot>  error:
20:51:03 <lambdabot>      • No instance for (Contravariant ((->) Integer))
20:51:03 <lambdabot>          arising from a use of ‘e_13’
20:51:10 <c_wraith> functions can't be an instance of Contravariant
20:51:48 <fragamus> Ok so I need a contravariant
20:53:31 <c_wraith> > getPredicate . contramap negate (Predicate (<3)) $ 4
20:53:33 <lambdabot>  error:
20:53:33 <lambdabot>      Variable not in scope: getPredicate :: Integer -> cerror:
20:53:33 <lambdabot>      Data constructor not in scope:
20:55:08 <c_wraith> > getPredicate (contramap negate (Predicate (<3))) 4
20:55:10 <lambdabot>  True
20:58:28 <tcsiwula> pavonia: good question =) shows my lack of curl exposure
22:33:11 <dminuoso> c_wraith: At times I really wish one could write `instance Contravariant (a -> _) where ...`
23:20:26 <dibblego> this has consequences; I don't think you really want that
23:21:23 <dminuoso> dibblego: SPJ could conjure a paper with black magic on it giving us type inference back.
23:21:49 <dibblego> it would need to be a different type constructor
23:30:37 --- mode: glguy set +v dfi
23:30:51 <dfi> in each case?
23:36:35 <dminuoso> dibblego: why would it?
23:39:09 <dibblego> since otherwise it is ambiguous and can only be disambiguated, unless you want type ascription
23:39:22 <dibblego> s/only be/not
23:39:36 <dminuoso> dibblego: Im trying to honestly understand what the issue is. Can you name a trivial ambiguous scenario?
23:40:37 <dibblego> `instance Functor (\x -> Either x a)`  `instance Functor (\x -> Either a x)`
23:42:43 * hackage StateVar 1.1.1.1 - State variables  http://hackage.haskell.org/package/StateVar-1.1.1.1 (SvenPanne)
23:46:13 * hackage amazonka-iam-policy 0.0.3 - Amazon IAM Policy Document DSL and Combinators.  http://hackage.haskell.org/package/amazonka-iam-policy-0.0.3 (BrendanHay)
23:47:34 <lyxia> could one not imagine some mechanism to allow either instance and have the compiler check that only one is used?
23:48:58 <osa1> when using cabal-new build can I specify where to copy the final executables? the default path is crazy
23:49:28 <lyxia> noone is going to write Contravariant ((->) a) so we might as well allow Contravariant (\x -> (x -> a)), is that what you meant dminuoso?
23:50:13 * hackage amazonka-iam-policy 0.0.3.1 - Amazon IAM Policy Document DSL and Combinators.  http://hackage.haskell.org/package/amazonka-iam-policy-0.0.3.1 (BrendanHay)
23:51:13 <carlosdagos> @osa1, there's a flag `--libexecdir=DIR` which could be useful for what you want 
23:51:13 <lambdabot> Unknown command, try @list
23:52:23 <superlinux> my question is not about Elixir. but asking whether Haskell has the same operator (|>) for stream processing as Elixir?
23:54:18 <osa1> carlosdagos: I don't think that does what I want
23:54:29 <osa1> in fact I don't think it does anything. I don't see any new files in DIR
23:55:33 --- mode: glguy set +v SamyIsMyHero
23:55:38 <SamyIsMyHero> im new
23:56:46 <dminuoso> lyxia: Or perhaps outright disallow such.. how would I call it.. overlapping instances? =)
23:57:38 <dminuoso> superlinux: We like to think in terms of function composition which is roughly equivalent but more expressive.
23:58:22 <SamyIsMyHero> is anybody here a pentester or has been
23:58:30 <dminuoso> superlinux: |> is basically about shuffling data from one function into the next. function composition lets us create that pipeline but without having to feed data into it.
23:59:03 <dminuoso> superlinux: for example: countWords = (length . words) creates such a processing pipeline.
23:59:46 <SamyIsMyHero> ezit
