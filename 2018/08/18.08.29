00:01:34 <liste> madnight: which deep flatten?
00:01:46 <liste> or rather, what deep flatten
00:02:23 <madnight> e.g. deep flatteing for abritarly deep lists
00:02:38 <liste> there is no such thing
00:03:04 <madnight> in JavaScript there is
00:03:12 <liste> madnight: but this is #haskell
00:03:42 <madnight> liste: MultiParamTypeClasses
00:04:41 <boj> madnight: do you mean any kind of structure, or just nested lists?
00:05:12 <madnight> let's stick with list
00:05:15 <ZeuPiark> hello
00:05:45 <boj> madnight: arbitrarily nested lists?
00:05:52 <madnight> yes
00:05:59 <cocreature> madnight: what do MultiParamTypeClasses have to do with this?
00:06:02 <boj> i am not sure that is possible
00:06:33 <madnight> hmm what do you think about https://stackoverflow.com/a/5994717/6593641
00:06:33 <cocreature> let’s say you have [[a]] how do you know how many levels you want to flatten it? you might say 1 but what if I instantiate a with [Int]
00:07:45 <boj> madnight: the answer with concat still states that you have to call concat again, which means you need to know the depth ahead of time
00:07:48 <cocreature> you can usually get these things to work in some way but type inference is horrible and they’re really not as useful as it might seem at first
00:10:11 <madnight> cocreature: hmm i would rather provide a explicit type sig than repetitive saying concat, but maybe that's just me
00:10:13 <cocreature> and as demonstrated by the example in that post, it doesn’t work particularly well with polymorphism
00:11:14 <cocreature> madnight: I mean if you start wanting to flattening more than 3 levels, I could see a point in trying to avoid concat but at that point I would also strongly suggest that you reconsider what you are doing and try to find a better solution :)
00:13:11 <madnight> cocreature: so deep flattening is unnecessary by nature?
00:13:33 <boj> madnight: what is your actual goal? maybe that is a better line of reasoning
00:13:51 <cocreature> I’m not saying it is unnecessary in all cases but if you find yourself flattening 10 levels, I would at least question if there isn’t a better solution
00:15:17 <cocreature> like how did you end up with 10 levels of data that you don’t care about (because you want to flatten them) in the first place, do you really want to use the same data structure for all levels, could you use the Monad instance of list, …?
00:15:31 <madnight> the existence of useful cases is enough motivation for me (and yes 10 is extreme indeed)
00:16:06 <boj> having a hard time picturing a useful case of arbitrarily nested lists
00:16:17 <cocreature> if the usecases are sufficiently rare, I’ll take concat . concat . concat over forcing some bad abstraction on top of whoever reads the code
00:16:40 <madnight> parsing JSON for example can often result in deeply nested data structures
00:16:59 <boj> usually known ahead of time though, right?
00:18:03 <madnight> boj: does printf know its args ahead of time?
00:18:36 <boj> are you working with unknown json data?
00:19:44 <madnight> only unknown nested level
00:20:24 <lavalike> cocreature: your reasoning brought this Oleg piece back to mind http://okmij.org/ftp/Haskell/deep-monadic-join.hs
00:20:35 <boj> madnight: you could probably work with the lens library to examine the state of the structure at runtime, but note that you can also fail at runtime since you aren't constraining the structure to compile time types
00:21:19 <cocreature> madnight: alright, if the nesting level is unknown, then you won’t be able to extract a nested list in Haskell anyway, since you can’t give that function the right type
00:21:31 <cocreature> so what you do instead is recurse on the Object and concat the lists at each step
00:22:12 <madnight> i guess it's impossible to give such compiler guarantees for flexible datastruces
00:23:00 <cocreature> what guarantees do you want to give?
00:23:12 <madnight> lavalike: very interesting
00:23:41 <lavalike> could be given a more modern Haskell spin
00:24:31 <liste> madnight: a list with arbitrary, possibly mixed, levels of nesting is really a tree
00:24:39 <liste> @src Tree
00:24:39 <lambdabot> Source not found.
00:25:00 <madnight> i guess i could use the same approach for a abritarly deeply nested fmap
00:25:19 <boj> @src Data.Tree.Tree
00:25:19 <lambdabot> Source not found. You untyped fool!
00:25:25 <boj> ah well
00:25:33 <cocreature> or you could just use a newtype that has the Functor instance you want :)
00:25:35 <liste> > Node "a" [Node "b" [], Node "c" [Node "d" [], Node "e" []]]
00:25:38 <lambdabot>  Node {rootLabel = "a", subForest = [Node {rootLabel = "b", subForest = []},N...
00:28:18 <madnight> cocreature: yes instance DeepFunctor that is
00:28:36 <madnight> implementing deepfmap
00:30:26 <cocreature> I still think you are solving a problem that doesn’t exist. e.g. let’s say you have a nested layer of functors e.g. IO (Maybe a). ofc you could now go ahead and try to get DeepFunctor to work but you could also just use MaybeT IO a or Compose IO Maybe a instead and you’ll get the right functor instance
00:32:04 <madnight> "I'm not saying it is unnecessary in all cases"
00:33:01 <cocreature> that was mostly a statement to avoid someone being really pedantic and coming up with some contrived usecase :)
00:33:03 <madnight> again I'm not trying to say that i cannot solve my exact problem in a better different way
00:34:11 <olligobber> madnight, Data.Fix
00:37:58 <cocreature> madnight: if you have some concrete problem where you think a deep fmap or a deep concat might be the best option, I’d be interested to take a look and see if it cannot be solved better in another way :)
00:38:25 <madnight> hmm arbitrary deep flattening in py or js is very useful and part of many libs, guess in Haskell it is not so popular since it is not as safe as ahead of time stuff
00:39:15 <cocreature> madnight: do you have a concrete example where you would use it in py or js?
00:40:06 <liste> madnight: Haskell folks tend to use well defined records and ADTs instead of nested lists or maps
00:40:25 <cocreature> I would expect that in pretty much all of those situations you wouldn’t end up with a nested list in Haskell in the first place
00:40:46 <cocreature> e.g. let us consider json, in js that might just be a nested list so you might want to deep flatten it
00:40:47 <bahamas> hello. how should I read type variables with a number after them? for example
00:40:49 <madnight> cocreature: you can find many thousand examples via GitHub advance search
00:40:54 <cocreature> in Haskell you’ll get an aeson object instead
00:40:55 <bahamas> :t (sequence. ) . fmap
00:40:56 <lambdabot> (Monad m, Traversable t) => (a1 -> m a2) -> t a1 -> m (t a2)
00:40:57 <cocreature> not a nested list
00:41:12 <cocreature> so your task is “how do I deep flatten an aeson object” not “how do I flatten nested lists”
00:41:31 <cocreature> madnight: sure but I am interested in what specifically you have in mind so we have something concrete to work with
00:41:38 <madnight> cocreature: well they could do it all wrong, if that is what you are trying to say
00:42:06 <cocreature> madnight: no I am not, I am saying that the cases where you apply deep flatten in js are not cases where you would end up with nested lists in Haskell
00:42:16 <cocreature> as I just tried to explain with the json object
00:42:31 <liste> bahamas: they're just arbitrary names, GHC probably has some "smart" algorithm where it constructs the type variable names based on the names in the original definitions and renames them to avoid conflict
00:42:33 <MarcelineVQ> bahamas: there's nothing special about them, a1 and a2 refer to different types  in the same way that b and c would
00:43:29 <madnight> cocreature: I'm more in for a general discussion about the usefulness of deep flatten, I'm very sure you can find other ways for specific examples, no doubt
00:44:00 <liste> Python and JS solve problems differently, so they have more use for deep flatten
00:44:05 <bahamas> liste: MarcelineVQ I see. thanks
00:44:08 <liste> in Haskell it's just a curiosity
00:44:11 <cocreature> well my point stands “deep flatten on nested lists is not a useful operation Haskell”
00:44:24 <cocreature> deep flatten of an aeson Object on the other hand can very well be a useful operation
00:44:34 <cocreature> and would correspond to deep flatten on nested lists in py or js
00:47:20 <madnight> cocreature: perfect that was the clear and simple answer i was looking for, either useful or not, now i will throw that idea over board and try to think of a more Haskell like approach (by the way I'm coming from the js/py world)
00:51:31 <cocreature> madnight: sorry if I made this more complicated than necessary by trying to avoid absolutes. my offer still stands, if you have some concrete problem where you find yourself wanting a deep flatten in py/js, I’m happy to take a look at it and try to suggest how I would approach this in Haskell :)
01:00:17 <madnight> i think our mismatch was, that i tend to ask question like: is some concept xy useful in general or not    and your approach is more based on: i can show you examples where it is not. But to provide an example for one case where it is e.g. not useful does not automatically render the whole concept unuseful in general (which was my question)
01:09:10 <cocreature> I’m somewhat wary of claiming that “xy is _never_ useful” since then someone pedantic comes along with some contrived example so I instead go for “most of the time xy is not useful” :)
01:10:27 <madnight> maybe you could say then: i can't think of any good example where it might be useful
01:20:34 <bahamas> in this code: (*3) <$> (+2) 4. is (+2) first applied to 4 and then (*3) applied to the result?
01:21:26 <cocreature> bahamas: do you mean ((*3) <$> (+2)) 4?
01:22:22 <bahamas> cocreature: here's the actual example that made me wonder: `traverse f (Right y) = Right <$> f y`
01:22:45 <cocreature> bahamas: that parses as Right <$> (f y)
01:22:46 <bahamas> so f is first applied to y and then Right is applied to the result?
01:22:50 <bahamas> aha
01:23:06 <cocreature> function application alwyas takes precedence
01:23:47 <bahamas> unless the precedence is lower, right? I mean <$> is also a function
01:25:17 <cocreature> let me rephrase that: prefix function application always takes precedence over infix operators
01:25:53 <bahamas> ok
01:51:32 <madnight> is it possible to redefine precedence of imported operators?
01:52:42 <[exa]> I guess you should be able to e.g. import them qualified and redefine them completely
01:55:17 <sshine> [exa], can't you just apply new fixity declarations? https://www.haskell.org/tutorial/functions.html#sect3.2.2
01:55:29 <sshine> whoops, I meant madnight. :)
01:56:04 <[exa]> well that would be great but I somehow doubted it would work
01:57:05 <madnight> is a qualified operator like M.<$> ?
01:57:53 <pavonia> Yes
01:58:16 <madnight> funny looks weird
01:58:59 <sshine>     The fixity signature for ‘&&&’ lacks an accompanying binding
01:59:00 <sshine>       (The fixity signature must be given where ‘&&&’ is declared)
01:59:07 <pavonia> > succ Prelude.. pred $ 0
01:59:10 <lambdabot>  0
01:59:10 <sshine> [exa], yeah, so apparently you can't change the fixity for an imported operator.
01:59:47 <sshine> in Standard ML that's the only way to make an imported operator infix. >_<
02:03:07 <[exa]> pavonia: wtf is Prelude.. ?
02:03:29 <[exa]> oh lord I see it now :D
02:03:31 <[exa]> ok
02:05:10 <mniip> sshine, you could do
02:05:22 <mniip> import Prelude hiding ((.)); import qualified Prelude;
02:05:31 <mniip> (.) = (Prelude..); infix whatever .
02:08:41 <Putonlalla> > (.Prelude Prelude..(Prelude..))(const"Prelude")(.)
02:08:43 <lambdabot>  "Prelude"
02:31:01 <sshine> mniip, right. I think that's what [exa] suggested.
02:31:09 <sshine> madnight, ^
02:31:17 <madnight> > "Prelude"
02:31:19 <lambdabot>  "Prelude"
02:31:33 <madnight> that's shortest
02:35:10 <mniip> > tyConModule $ typeRepTyCon $ typeOf otherwise
02:35:12 <lambdabot>  "GHC.Types"
02:35:15 <mniip> damn
02:36:05 <sshine> > uncurry (:) $ ((!! 1) &&& drop 4) $ reverse "Prelude"
02:36:07 <lambdabot>  "derP"
02:36:57 <liste> :t typeOF
02:36:58 <lambdabot> error:
02:36:58 <liste> :t typeOf
02:36:58 <lambdabot>     • Variable not in scope: typeOF
02:36:58 <lambdabot>     • Perhaps you meant one of these:
02:36:59 <lambdabot> Typeable a => a -> TypeRep
02:54:04 <randomName> how do i call makeMock https://lexi-lambda.github.io/blog/2017/06/29/unit-testing-effectful-haskell-with-monad-mock/
02:54:14 <randomName> i get Variable not in scope:      makeMock         :: [Char]           -> [Language.Haskell.TH.Syntax.Type]            -> Language.Haskell.TH.Lib.DecsQ    | 31 | makeMock "FileSystemAction" [ts| MonadFileSystem |]
02:54:59 <thorsten`> Hi, I have a pipe to a process and want to read its stdout and stderr in a non-blocking way until the process finishes. how do I do this?
02:55:22 <ggVGc> thorsten`: just read from stdin?
02:55:38 <lyxia> randomName: it seems to no longer exist in the current version of monad-mock
02:56:18 <ggVGc> thorsten`: if you want to read from stdin async, you'll have to spawn a separete thread and communicate with it through for example an MVar
02:56:31 <randomName> lyxia : ohkay so manually writing the GADTs and instances is the only way now ?? 
02:56:35 <thorsten`> to clarify: I've already done createProcess and reading only stdout or only stderr is fine
02:56:53 <lyxia> randomName: it seems to have never existed actually
02:56:54 <thorsten`> and I'm not talking about stdin at all ;)
02:57:02 <ggVGc> thorsten`: I think it's better if you combine the streams when you pipe
02:57:03 <lyxia> randomName: https://hackage.haskell.org/package/monad-mock-0.2.0.0/docs/Control-Monad-Mock-TH.html has a makeAction, maybe that's a typo?
02:57:11 <ggVGc> and just read stdin from your haskell program
02:57:55 <ggVGc> thorsten`: https://stackoverflow.com/a/637834
02:58:02 <lyxia> randomName: maybe makeMock was a typo and she meant makeAction
02:58:03 <thorsten`> how can I combine stderr and stdout when using createProcess?
02:59:28 <thorsten`> ggVGc: my haskell program creates the process when the user presses a key. as mentioned earlier: I'm not talking about stdin at all ;)
02:59:38 <randomName> lyxia : it was a typo but even after correcting it, it cannot generate gadts for some reason 
03:00:03 <lyxia> randomName: how do you know it cannot generate gadts
03:01:21 <randomName> lyxia : coz i'm getting error saying constructors not found, constructors which makeAction is supposed to generate 
03:01:36 <lyxia> thorsten`: everything ggVGc said makes sense if you substitute stdin with stdout
03:01:42 <randomName> lyxia : also where should i place makeAction, i know nothing about template haskell 
03:02:17 <lyxia> randomName: the same place where you put makeMock, just after the imports
03:02:35 <lyxia> randomName: do you have a minimal example to share
03:03:52 <lyxia> randomName: you can look at the code the TH script generates by passing -ddump-splices to the compiler
03:05:32 <thorsten`> lyxia: no, it does not make sense. to clarify: my haskell programm calls createProcess and I want to reat that process's stdout and stderr. so https://stackoverflow.com/a/637834 does not help
03:07:09 <randomName> lyxia : how can i use lyxia with stack runHaskell ??
03:08:52 <lyxia> randomName: stack build --ghc-options="-ddump-splices"   then find a file .stack-work/.../NameOfMyHaskellProgram.dump-splices
03:10:18 <lyxia> thorsten`: create process returns values of type Handle, and there are functions in System.IO to work with Handle. In particular this allows you to check whether there is input available in a nonblocking way: https://hackage.haskell.org/package/base-4.11.1.0/docs/System-IO.html#v:hWaitForInput
03:11:58 <thorsten`> lyxia: yes, but if I have a handle for the process's stdout and process's stderr, how can I wait for at least one of them becoming ready? do I have to do this in separate threads (via forkIO)?
03:16:07 <lyxia> hmm forking two threads that listen to each Handle is the easiest solution I can think of.
03:17:41 <thorsten`> and then I use an MVar for each in order to wait for both threads to finish before waiting the process to finish an receiving its exit code?
03:20:26 <lyxia> thorsten`: that sounds about right. But if you don't read the handles and just wait for the process to exit, does it block waiting for its output to be consumed?
03:21:47 <lyxia> or do you want to do stuff while the process is running as well?
03:21:48 <thorsten`> lyxia: it might: if the process creates more output than the pipe can buffer then the writes within the process block
03:22:25 <thorsten`> but anyway, yes: I want to show the processes output and errors in an interactive application
03:23:11 <lyxia> I see, thanks.
03:24:56 <thorsten`> thank you! :)
03:43:34 <thorsten`> by the way, this is the end result: https://github.com/t-wissmann/caligraph/blob/master/Caligraph/Cli/Main.hs#L212-L219
03:47:29 <maerwald> anyone has ever encountered cases where STM.TQueue swallows/loses items?
03:52:39 <lyxia> thorsten`: looks good
04:10:40 <marvin2> what tutorial is recommended these days for beginners over LYAH?
04:10:49 <hpc> @where cis194
04:10:49 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
04:11:05 <liste> http://haskellbook.com/ is also popular
04:11:27 <typetetris> marvin: Beginner as in "didn't program before" or beginner as in "doesn't know haskell"?
04:17:31 <AWizzArd> When using the DataKinds extension: is the singlequote ' operator immediately available?
04:17:53 <EdwardIII> i've been reading LYAH... is it fairly OK to continue?
04:18:00 <EdwardIII> i must admit i'm finding it quite challenging though
04:18:26 <hpc> yeah that's fine
04:18:55 <hpc> LYAH isn't necessarily wrong, there's just better presentations / orderings of the same information
04:18:59 <marvin2> typedrat, beginner to haskell and functional programming in general, but with experience in mainstream imperative/OOP languages
04:19:29 <guessWho> what is this keyword (:->) ??
04:19:57 <cocreature> guessWho: it is not a keyword, it’s defined in some library that you are using
04:20:01 <hpc> guessWho: it's a user-defined operator, like (/) or (++)
04:20:20 <cocreature> if you give us some context, it might be possible to point you to its definition
04:20:46 <guessWho> what does it mean in this lib i couldn't figure out 
04:20:46 <guessWho> https://hackage.haskell.org/package/monad-mock-0.2.0.0/docs/Control-Monad-Mock.html
04:21:43 <hpc> it's the constructor for WithResult - https://hackage.haskell.org/package/monad-mock-0.2.0.0/docs/src/Control-Monad-Mock.html#WithResult
04:22:54 <EdwardIII> hpc: cool, thanks
04:22:57 <AWizzArd> In ghci I am trying   :k 'Foo   but get the error message „Data constructor 'Foo' cannot be used here (Perhaps you intended to use DataKinds).   Yes, I intended to use DataKinds. I have it as a pragma at the top of my file.
04:23:13 <cocreature> AWizzArd: you need to enable it in ghci
04:23:16 <cocreature> :set -XDataKinds
04:23:22 <AWizzArd> Okay, will try.
04:23:24 <EdwardIII> i can do a bit of map, a bit of currying and a bit of function composition but i'm mainly interested in how this fits together in the real world - e.g. how do i pull a twitter feed and squirt it out on screen, that sort of thing
04:23:42 <AWizzArd> cocreature: thx, that worked.
04:24:05 <hpc> EdwardIII: how much have you done with the IO type?
04:24:10 <hpc> that's where all of that stuff would live
04:24:23 <cocreature> EdwardIII: I think that is one of the main criticisms of lyah, it never gets to the point where it teaches you to actually write useful Haskell code
04:27:13 <EdwardIII> hpc: nothing yet, i'm just playing around with ghci & following LYAH
04:27:31 <EdwardIII> i pulled brick and starting playing around a little bit kind of struggled to get anywhere
04:39:12 <ArahaelPi> I want a -> [a], what should I use? (Eg, 2 should become [2])
04:40:47 <asheshambasta> Anything to watch out for when using Stack on Arch? 
04:41:29 <ChaiTRex> ArahaelPi: If you want f a = [a], that's (:[])
04:41:47 <ArahaelPi> ChaiTRex: That works, awesome.
04:41:48 <thorsten`> asheshambasta: yes, let stack download the appropriate ghc to your home and don't use --system-ghc
04:42:10 <asheshambasta> okay, thanks thorsten` 
04:42:22 <cocreature> ArahaelPi: you could also use pure/return although :[] is probably clearer
04:42:43 <ArahaelPi> cocreature: Yeah, I think I prefer :[]
04:42:48 <ChaiTRex> Are constant non-top-level lists memoized even between calls to the function they're defined in?
04:43:04 <ArahaelPi> cocreature: Good reminder, though - I forgot lists were monads.
04:43:11 <ChaiTRex> (with NOINLINE)
04:43:56 <cocreature> ChaiTRex: if you compile with -ffull-laziness which is part of -O or at least -O2 (not entirely sure it’s part of -O) they should be
04:44:08 <ChaiTRex> cocreature: OK, thanks.
04:44:14 <cocreature> if you compile with -fno-full-laziness then they shouldn’t be memoized
04:44:31 <cocreature> the fact that it’s annoyingly hard to prevent GHC from sharing things is one of my biggest annoyances in Haskell
05:29:53 <philippD> I'm looking at the definition of dependent types https://en.wikipedia.org/wiki/Dependent_type#%7F'%22%60UNIQ--postMath-00000001-QINU%60%22'%7F_type and according to that is `Just` a dependent function where it's pi-type is $\Pi_(a:*)Maybe(a)$?
05:30:41 <philippD> Or are generics something different here?
05:32:51 <cocreature> philippD: the return type of Just depends on the input _type_ not the input value
05:33:27 <cocreature> what dependent types allow you is to have something like replicate : a(n : Int) -> Vector n 
05:33:43 <cocreature> what dependent types allow you is to have something like replicate : (n : Int) -> a -> Vector n a
05:33:50 <cocreature> (sry pressed return accidentally)
05:34:00 <cocreature> so here the return type Vector n a depends on "n" not on Int
05:35:39 <Maxdamantus> I'd say the answer to his question is: it can be.
05:36:04 <Maxdamantus> Well, it's not quite what was written.
05:36:38 <philippD> cocreature: So a dependent type always "lifts" a value to a type?
05:36:50 <Maxdamantus> but more like: $\Pi_(a:*). \Pi_(x:a). Maybe(a)$
05:37:25 <Maxdamantus> or in Idris notation: (a: Type) -> (x: a) -> Maybe a
05:39:04 <cocreature> right that’s one way to view it
05:39:14 <cocreature> if you see types as first class entities
05:39:15 <Maxdamantus> but it's not a notable use of dependent types, since the types are only depending on types (`a: Type` says that `a` is a type, so the type expression on the right (`(x: a) -> Maybe a`) is only depending on a type)
05:42:10 <ventonegro> philippD: In dependently-typed languages, types are values, so there is no lifting
05:42:21 <Maxdamantus> You can think of regular forall types that you reason about with -XRankNPolymorphism or whatever as special cases of that.
05:42:37 <ventonegro> In Idris, Type is the type of all values which are themselves types
05:42:54 <philippD> ventonegro: I'm trying to learn dependent types through the Haskell lense
05:43:03 <Maxdamantus> `forall a. b` pretty much just means `(a: *) -> b`
05:45:04 <cocreature> in fact the wikipedia article linked by philippD specifically talks about polymorphism as one example :)
05:45:09 <Maxdamantus> That is, a value of type `forall a. b` is essentially a function that will give you back a `b` for any type `a` you come up with.
05:46:44 <fryguybob> maerwald: I am not aware of such strangeness with STM, do you have an example?
05:47:06 <maerwald> no
05:50:03 <fryguybob> Haskell's STM is sequentially consistent, for any outcome that happens, there exists a sequential ordering of performing the transactions that leads to that outcome.
05:51:02 <fryguybob> If you do  unsafe  things, that may not hold.
05:51:09 <c_wraith> is it?  I thought GHC's STM corresponded more to an SQL "READ COMMITTED" level than "SERIALIZABLE"
05:51:32 <fryguybob> c_wraith: No.  I think what Clojure has is like that.
05:51:43 <c_wraith> I was sure it was the other way around
05:51:59 <c_wraith> Clojure has true MVCC to prevent READ COMMITTED semantics
05:53:50 <Maxdamantus> Not familiar with STM or Clojure, but aiui, STM is meant to retry "failed" transactions, so you shouldn't need MVCC.
05:54:07 <Maxdamantus> (in order to get serialisability)
05:56:54 <Maxdamantus> If you can just detect that anything you've read has been potentially tampered with between your first read of it, and the final read in the transaction, you just throw away the transaction. No MVCC needed.
05:57:03 <c_wraith> what's silly is that I'm really good at *finding* race conditions, but really bad at constructing cases where ones exist in a specific pattern.  I can't see immediately how to test for the difference between the two sets of semantics
05:58:03 <Maxdamantus> (and with purity, you know that that's perfectly fine .. almost .. disregarding the looping-on-inconsistent-data issue)
05:58:34 <Ariakenom> bottoms will be bottoms
05:58:47 <fryguybob> I'm not very familiar with SQL semantics, but from what I am seeing one difference is what repeated reads of the same variable in a transaction see.
05:59:01 <c_wraith> hmm, right, STM can't be worse than REPEATABLE READ
05:59:10 <fryguybob> In Haskell STM, you always see the same value on repeated reads.
06:00:24 <Maxdamantus> In a successful transaction at least. I imagine it could be an implementation detail as to whether you can get different values on each read in a transaction that will later be determined to be invalid.
06:01:28 <fryguybob> Maxdamantus: Yes.  There are other implemntations that take a different approach on that, but still stick with sequential consistency.
06:01:57 <c_wraith> hmm.  so I'd have to figure out how to construct a phantom read problem in STM to test if GHC makes it truly serializable
06:02:12 <Maxdamantus> Yep, and the important thing should only be the successful transactions. Behaviour within transactions that are going to be retried anyway is irrelevant.
06:02:27 <Maxdamantus> (until you reach the looping issue; dunno if/what STM would do about that)
06:03:18 <Ariakenom> c_wraith: You could venture over to #ghc and see if there's someone knowledgeable
06:03:34 <fryguybob> Maxdamantus: A transaction that reads inconsistent data, but doesn't yet known it, is detected as long as it returns to the scheduler periodically.
06:03:35 <cocreature> that person is already here, it’s fryguybob :)
06:04:17 <Maxdamantus> fryguybob: okay, and does GHC guarantee that a computation will return to the scheduler periodically?
06:04:19 <fryguybob> Maxdamantus: So you have to use -fno-omit-yield.
06:04:26 <Ariakenom> indeed they are :p I just read that in the paper too https://www.microsoft.com/en-us/research/wp-content/uploads/2005/01/2005-ppopp-composable.pdf
06:04:36 <Ariakenom> ctrl+f "loop"
06:05:33 <fryguybob> We do have a bug right now where you can cause a huge allocation in a zombie transaction (one that has seen inconsistent state) where we are not in a place where we can go to GC.
06:06:11 <c_wraith> Hmm, yes, the phantom read problem can't exist given the difference between STM and SQL.  Guess it is serializable.
06:06:12 <fryguybob> It is fixable, I'm just waiting for Simon M to tell me the best way to do it :D.
06:16:16 <EdwardIII> is it too OT to ask what you guys are using haskell for?
06:16:39 <liste> EdwardIII: not at all
06:17:27 <EdwardIII> what are you using haskell for? :D
06:19:28 <liste> EdwardIII: I started writing a roguelike-ish game for it a few years ago, but haven't done anything for it in a while. atm I'm working on a simple, untyped, native-compiled programming language
06:20:42 <EdwardIII> two quite different applications heh
06:21:03 <EdwardIII> although i guess if you're doing a roguelike you end up with quite a complicated DSL-type thing anyway?
06:22:52 <desperek> hi; is http://learnyouahaskell.com a good place to learn about haskell? i already have experience in other prog. languages 
06:23:21 <liste> EdwardIII: well I had an elaborate "feature" system where the program was separated into loosely coupled modules, but in hindsight it's kinda over engineered
06:23:33 <Putonlalla> That depends on what you mean by other, desperek.
06:24:21 <desperek> Putonlalla, uh, are they called c-like or something. ruby go and such
06:24:23 <rotaerk> > enumFromTo 5 2
06:24:25 <lambdabot>  []
06:24:40 <rotaerk> > enumFromThenTo 5 4 2
06:24:43 <lambdabot>  [5,4,3,2]
06:24:56 <Putonlalla> Then I'm going with no, desperek.
06:25:01 <fryguybob> EdwardIII: I use Haskell as a platform for researching transactional memory performance.  And for everything else.
06:25:49 <desperek> Putonlalla, no as in that is a bad place to learn haskell? or did i miss something
06:26:36 <Putonlalla> The exposition is quite shallow, desperek. It helps if you know what to expect ahead of time.
06:26:40 <jose_zap> EdwardIII I use it in parts of our deployment pipeline: validating configuration, validating dockerfiles, building dockerfiles...
06:27:13 <jose_zap> and also for occasional scripts where I would before use bash
06:27:16 <Putonlalla> There are other books that are more friendly to the uninitiated.
06:28:06 <desperek> Putonlalla, is there possibly something online?
06:28:42 <_sras_> Can someone please take a look at a Servent like "thing" I ended up making in an attempt to learn some type level programming in Haskell? https://bitbucket.org/sras/yaar/src/master/ 
06:29:56 <_sras_> I want to know if this has any sort of potential and merit further working upon, or if there is something that is fundamentally flawed in its implementation?
06:30:02 <Putonlalla> I don't think so, which is why I couldn't recommend anything, desperek.
06:30:16 <desperek> i see, thanks anyways Putonlalla 
06:30:31 <Putonlalla> @where hpffp pfft huff puff
06:30:31 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
06:31:04 <desperek> oh, there's #haskell-beginners
06:31:05 <Putonlalla> Other people have said good things about this book.
06:31:42 <ski> desperek : note that beginners are also welcome in this channel
06:32:34 <dmwit> desperek: I still like the Gentle Intro. Though it was named with a particular audience in mind of which you probably aren't a member, so don't expect too-gentle an intro. =)
06:33:02 <ski> @where tutorial
06:33:02 <lambdabot> http://www.haskell.org/tutorial/
06:33:16 <dmwit> ?where tutorials -- a long list
06:33:16 <lambdabot> http://haskell.org/haskellwiki/Tutorials
06:33:41 <ski> the one i linked to is the "gentle" one
06:33:54 <desperek> i see i see :D
06:34:00 <desperek> thanks, i'll try it
06:34:17 <ski> @where CIS194
06:34:17 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
06:34:32 <ski> desperek : you could try that ^
06:34:41 <ski> it has exercises
06:38:16 <desperek> okay, thanks for everything. i'll check them all out.
06:40:06 <ski> desperek : you should know that learning a new programming paradigm is a bit like learning to program from scratch again. prepare to unlearn things you take for granted, and please wait a bit with comparing with what you know from other languages
06:40:44 <ski> (of course some things do carry over, but it's better to come at it with a fresh state of mind)
06:40:50 <desperek> ski, i am aware of this :p hence asked here
06:40:59 <ski> good good
06:42:49 <mniip> desperek, are you any good at mathematics?
06:43:26 <mniip> you're more likely to discover similarities with that than with other programming languages
06:45:11 <desperek> mniip, kind of hard to state if i'm good or not.
06:45:39 <ski> (you don't need to know advanced math. a little familiarity with very basic algebra (like solving simple equations) might help a little)
06:46:44 <mniip> desperek, on a basic level, substitution, function, variable
06:46:58 <hyperisco> cannot grade proficiency without first agreeing on a scale
06:46:59 <mniip> composition, perhaps basic set operations
06:47:18 <desperek> oh well, then kind of not bad, i would say. uh i dont like rating myself
06:48:19 <hyperisco> I rate you 7 eigenvalues out of a matrix
06:49:09 <desperek> hyperisco, i pass
06:49:27 <hyperisco> just barely
06:49:29 <ski> having a basic understanding of bound variables, as in sigma (big sum) notation, and integral notation, could also help a little
06:50:51 <desperek> ahm
06:51:33 <ski> or as in function definitions. the definition `f(x) = x^2 - 1' defines the same function `f' as the definition `f(t) = t^2 - 1' -- the name used for the parameter/input/argument in the definition doesn't matter
06:52:03 <ski> (although it's nice to stick to a convention where `t' is time, or whatever)
06:53:23 <ski> if you take the sum `Sum_{i = 0}^4 i^2', then that is the same as `Sum_{k = 0}4 k^2', both being equal to `0^2 + 1^2 + 2^2 + 3^2 + 4^2'
06:53:56 <ski> here in the first sum, `i' is a "dummy" variable, or a "loop variable" in programming jargon
06:54:07 <ski> we also say `i' is a bound variable
06:54:24 <ski> in the definition of `f' above (say the second one), `t' is a bound variable
06:54:25 <desperek> the notation is kinda confusing
06:54:27 <hyperisco> apparently equivalence is important
06:54:49 <ski> bound variables can be renamed at will, with no change in meaning, as long as it's done consistently
06:55:03 <ski> desperek : which notation ?
06:55:24 <desperek> ski, the sum one
06:55:32 <desperek> the ^4 in particular
06:55:44 <desperek> yea, why the ^4?
06:55:53 <hyperisco> that means it is written above
06:56:01 <desperek> oh right
06:56:25 <ski> oh, that's just TeX notation for the two-dimensional math notation
06:56:25 <hyperisco> math notations are confusing because there are no rules, and ASCII art makes it worse
06:56:38 <desperek> ski, yea yea, just didnt quite understand the 4 thing
06:57:00 <desperek> well, so that was quite easy
06:57:16 <desperek> i never touched the integral notation though
06:58:45 <ski>    4   ²
06:58:48 <ski>    ∑  i
06:58:49 <ski>   i=0
06:59:02 <ski> that's how you write it on paper
06:59:14 <desperek> but thats sigma and the sum, what about integral notation ski
06:59:17 <dolio> Superscript _and_ a line above? :)
06:59:20 <desperek> what is it, even
06:59:41 <ski> dolio : oh yeah, perhaps that was overkill :)
06:59:50 <hyperisco> http://mathb.in/27475
07:00:12 <hyperisco> there is some other delimiter than $... I think it is rendering for inline
07:00:13 <desperek> hyperisco, that doesnt look right
07:00:41 <ski> desperek : it doesn't matter, for the purposes of Haskell, what integral notation is. i only mentioned it because it has the same notion of "bound variable". if you had seen it before, then that might have helped a little. as it is, no matter
07:00:48 <desperek> http://mathb.in/27477 hyperisco 
07:01:02 <desperek> ah ok
07:01:07 <hyperisco> oh of course there is a special \sum command thingie
07:01:27 <desperek> hyperisco, the one you posted was bit off :D
07:02:07 <hyperisco> instead of a symbols that mean "above" and "below" they overloaded the superscript and subscript symbols
07:02:12 <hyperisco> not my fault how they designed it
07:02:22 <hyperisco> my fault for how I used it
07:02:28 <quchen> \sum is not \sigma – the latter is a letter with no special properties, the former a special symbol that’s bigger than a Σ and has indices typeset above/below
07:02:41 <quchen> Same for \prod and Π
07:02:44 <brachiel> So, when working with type-level Nats and I have two constraints 1 <= k, k + 1 <= n; why is GHC unable to prove k <= n and can I do something to help GHC?
07:02:56 <quchen> \Pi I mean. Autoreplace got me
07:03:27 <brachiel> Using GHC.TypeLits I forgot to mention
07:03:31 <hyperisco> there probably is not enough regularity to make a sane system though
07:03:59 <mnoonan> brachiel: iirc there are typechecker plugins that might help
07:04:13 <cocreature> brachiel: GHC is quite dumb in that regard, you probably want to use ghc-typelits-natnormalise which can probably help here
07:04:32 <brachiel> mnoonan: I tried ghc-typelits-natnormalise and ghc-typelits-knownnat; they're not able to prove
07:04:54 <brachiel> Or I'm too dumb to use it; that's the other option
07:05:08 <hyperisco> paste code
07:06:14 <cocreature> brachiel: hm, maybe try ghc-typelits-presburger?
07:07:19 <brachiel> cocreature: Ah, presburger arithmetic seems viable. I'll try, thanks!
07:08:10 <hyperisco> iirc there is a conversion of typelit nats to peano nats, and it'd be easily proven with peano nats
07:08:35 <ski> desperek : anyway, after a while, you'll understand better how this bound variables thing fits into Haskell, regardless of whether you've encountered the concept before or not
07:09:32 <desperek> ski, im also kind of confused by lack of for loop!
07:09:34 <cocreature> brachiel: I think ghc-typelits-natnormalise might be better for equalities than inequalities but I’m not sure
07:09:43 <hyperisco> well if you've written a function/procedure in a language you should be familiar with variable binding
07:10:32 <dolio> Yeah, it's very rare for languages to not have that.
07:10:45 <dolio> Unless you've been using BASIC or something.
07:11:01 <ski> desperek : also lack of mutable variables :)
07:11:05 <hyperisco> for is just a goto
07:11:16 <ski> variables in Haskell are like variables in math
07:11:45 <ab9rf> it's my experience that people don't really understand what "bindings" are until they either learn lisp or take a class in compiler design
07:11:45 <desperek> o-oh...
07:11:46 <ski> > sum [i^2 | i <- [0 .. 4]]
07:11:48 <lambdabot>  30
07:11:51 <ski> > sum [i^2 | i <- [0 .. 4]]  :: Expr
07:11:53 <cocreature> desperek: loops can be converted mechanically into recursive functions
07:11:53 <lambdabot>  0 + 0 * 0 + 1 * 1 + 2 * 2 + 3 * 3 + 4 * 4
07:11:53 <desperek> i didn't know that
07:11:58 <hyperisco> dolio, isn't BASIC structured? seems to be
07:12:08 <ab9rf> which is why there are so many bad tutorials on the web about scope
07:13:11 <ski> hyperisco : depends which BASIC you're talking about
07:13:21 <ab9rf> hyperisco: it can be but it does not have to be
07:13:38 <ab9rf> hyperisco: the 1970s was a popular time to write monographs on the merits of structured basic
07:13:56 <ab9rf> hyperisco: i have a few of those books around here somewhere
07:14:15 <ski> BASIC 2.0 on the Commodore 64 had `FOR', but no function calls (no local variables. it had `GOSUB')
07:14:44 <ab9rf> ski: functions are not a feature of "standard" (Dartmouth) BASIC
07:14:46 <ski> Basic on some calculators, like Casio, didn't have `For'
07:14:49 <_sras_> brachiel, I had to put this at the top of the file to get something similar working `{-# OPTIONS_GHC -fplugin GHC.TypeLits.Normalise #-}`
07:14:55 <ski> (i'm sore more recent ones did)
07:14:59 <gobby> What extension allows the function arrow in the parameter of another function eg: `matchAllConstrs (map cName -> passedNames) realCons@(map dcName -> realNames)`
07:15:13 <ab9rf> Visual BASIC is not represenative of what BASIC was originally
07:15:15 <desperek> oh no, does haskell like lambda calculus?
07:15:20 <hyperisco> used a pocket computer once... kind of a fun thing
07:15:26 <dolio> gobby: View patterns.
07:15:30 <ski> Hsakell has its roots in the Lambda calculus, yes
07:15:33 <gobby> dolio: thanks
07:15:46 <ski> s/Hsakell/Haskell/ :)
07:16:01 <AWizzArd> The compiler tells me that the type constructor or class '*' is not in scope. I maybe want to import (*) from Data.Kind.  As soon I try this GHC now tells me that Data.Kind does not export (*).
07:16:06 <ab9rf> ski: at least you got the bag-of-letters correct :)
07:16:33 <desperek> ski, maybe hence the lambda :D
07:16:34 <hyperisco> AWizzArd, the partial answer is I think you're supposed to use Type nowadays
07:16:37 <geekosaur> AWizzArd, what ghc version? I think in 8.6 * may be gone
07:16:55 <JonReed> In stack `connection-count` is per job, right? I put `connection-count: 1` into `.stack/config.yaml` and I see that running `stack build` still opens so many connections that it floods the network and all those connections fail. Is there a way to throttle connections but keep the job count high for building?
07:16:56 <brachiel> _sras_: Yup, sometimes it works with that for me, too - but not always.
07:18:29 <ski> desperek : if you define `f(x) = x^2 - 1' in Haskell, then that defines the same function as `f = (\x -> x^2 - 1)'. the backslash `\' is an ASCII representation of a lambda. `\x -> x^2 - 1' means "the (unnamed) function that given an input, call it `x', squares it and subtracts one". then `f = (...)' gives the name `f' to this function
07:18:58 <desperek> makes sense
07:19:31 <AWizzArd> hyperisco and geekosaur: yes seems that „Type” works. Thx.
07:19:48 <ski> desperek : then `f(x) = x^2 - 1' (normally written `f x = x^2 - 1' in Haskell, without the brackets) is a handy shorthand for this. focusing not on defining the function `f' itself, but defining what the result of `f x', calling the function `f' on an input `x', is to be, for all possible inputs `x'
07:20:11 * desperek nods
07:20:14 <ski> (but still indirectly defining the function `f')
07:20:27 <AWizzArd> So is `*`  gone and completly replaced by `Type` in modern GHCs, provided I’m using certain extensions?
07:21:39 <hyperisco> all I know is a while back I understood * was being outmoded for reasons
07:22:15 <hyperisco> I am guessing it has to do with parsing
07:23:28 <AWizzArd> hyperisco: Type now worked well for me.
07:23:50 <hyperisco> desperek, when you see  (x^2 - 1)  in the wild it also means you can replace it with  (f x)  and get the same result
07:24:03 <ski> and vice versa
07:24:28 <stiell> In conduit, is it possible to pass the input to conduit A, and when conduit A returns, pass the same input to conduit B, including the values that conduit A consumed as well as the remaining input values?
07:24:31 <hyperisco> well there is a tendency to think = is directional because of how it is used in other languages
07:24:33 <ski> (this is called "equational reasoning", and is why Haskell doesn't have side-effects)
07:27:04 <michalrus> Regarding `ReaderT Env IO`, would it make sense to split Env into several classes like `HasDBPool env`, `HasSendMail env` etc. for bigger applications, to make it clear in function constraints what they use, and also to make mocking easier in tests?
07:27:09 <EdwardIII> thanks fryguybob, jose_zap
07:27:27 <EdwardIII> the only haskell app i've knowingly used is xmonad
07:27:53 <EdwardIII> that config file in haskell used to make my head spin heh
07:28:16 <hyperisco> that is when = is used as assignment, or in other words  x = y  means to do y and assign the result to x
07:28:58 <hyperisco> such as,  x = new Object  would usually give you  x == x  but not  new Object == new Object
07:33:26 <geekosaur> hyperisco, iirc it's because they'd like type level * on Nat at some point
07:33:39 <geekosaur> but they can't have it be both a type level operator and a type at the same time
07:34:48 <hyperisco> are you assuming TypeInType?
07:35:09 <geekosaur> TypeInType is gone / on by default as of 8.6 iirc
07:35:26 <hyperisco> guess they're really ramping to dependency...
07:37:54 <hyperisco> can we use overloaded field names unpainfully yet? :P
07:38:47 <geekosaur> I don't think full ORF has landed yet
07:39:29 <geekosaur> and there's some question as to whether that will ever be "unpainful". but then there's always been question of whether "unpainful" is possible without losing type inference
07:40:22 <ab9rf> pain is what lets us know that we're still alive
07:40:29 <geekosaur> or at least making type inference painful or weird in other ways
07:40:44 <hyperisco> I would at least enjoy being able to qualify the field with the constructor name
07:41:12 <geekosaur> people keep saying they want TDNR, but it's already been pretty well demonstrated toat TDNR breaks a bunch of other things people want
07:41:23 <ab9rf> i feel acronymated
07:41:33 <geekosaur> type-directed name resolution
07:41:41 <ab9rf> thank you
07:42:00 <hyperisco> well, I am suggesting value-directed name resolution :P
07:42:15 <ab9rf> i think i knew that on some level, but that level is presently inaccessible, probably due to insufficient caffeineation
07:42:25 <geekosaur> dependent types?
07:42:43 <hyperisco> no, I am suggesting to use the constructor name as a qualifier
07:43:22 <geekosaur> I think that might be difficult to square with the rest of how haskell does qualified names
07:43:30 <geekosaur> (and some specific hairiness in how ghc does it)
07:43:51 <geekosaur> qualified names are themselves something of a mess even in standard haskell
07:44:15 <geekosaur> ghc cheats to avoid the mess, then can't do what you'd like to see here as a result
07:45:09 <hyperisco> I wonder how this is a problem when I could just define a class for every field
07:45:28 <geekosaur> that's what OverloadedRecordFields does
07:45:37 <geekosaur> it makes typechecking fairly expensive
07:46:09 <geekosaur> that part of the machinery is already in place as DuplicateRecordFields iirc
07:46:42 <hyperisco> I dunno, because my memory says there was zero inference
07:46:58 <hyperisco> which wouldn't be the case if it was honestly a class
07:47:26 <geekosaur> I may have the wrong extennsion, there was an older one that didn't use classes and therefore didn't do inference
07:48:10 <geekosaur> the new one makes every field an instance of Has "typeLevelStringOfFieldName"
07:49:24 <hexagoxel> Wizek: regarding ghcid/cpu usage: have you tried profiling?
07:49:46 <hyperisco> well, I started making a module per data type, so I can just qualify the fields with the module name
07:49:48 <cocreature> the one that does use classes never got implemented afaik
07:50:01 <cocreature> we have the class but no automatic instances
07:50:12 <dminuoso> So Ive been writing quite a few functions that go like `xFromInt :: Int -> Maybe X; xToInt :: X -> Int` - a typeclass wouldn't make sense just for the sake of capturing that interface, would it?
07:50:20 <dminuoso> Or is there some class that expresses a kind of partial equivalence to Integer?
07:50:43 <hyperisco> dminuoso, that is almost saying it is an Enum
07:51:03 <dminuoso> hyperisco: Enum doesn't quite fit because there may be gaps, so it's not necessarily enumerable
07:51:12 <dminuoso> Sadly. :(
07:51:58 <dmwit> dminuoso: I dare you to call the two functions "parse" and "prettyPrint".
07:51:59 <geekosaur> yeh, I don't know where it stalled out
07:52:23 <cocreature> dminuoso: do you want to abstract over things that have a partial equivalence to Integers? if not then I wouldn’t go for a typeclass (if yes then I wouldn’t necessarily use a typeclass either but I wouldn’t outright reject it)
07:52:24 <geekosaur> I know Ive seen complaints because two different development paths have led to #foo and @"foo" being essentially the same
07:52:36 <dminuoso> dmwit: Well strictly speaking its just serialize/deserializing 
07:52:44 <dmwit> exactly =)
07:52:50 <dminuoso> Hehe :)
07:53:07 <dminuoso> dmwit: Although... you know - this could work.
07:53:08 <benzrf> geekosaur: #foo is better bc i hate having to think about which type arguments have been filled in so far
07:53:20 <dminuoso> dmwit: Oh you're a genius. I should make them instances of Get and Put.
07:53:30 <hyperisco> dminuoso, well, lets talk about good abstraction classes then: it isn't about the members so much as it is about the laws. What laws are there for your class?
07:53:49 <dmwit> yay!
07:54:28 <dminuoso> hyperisco: just the obvious "identity" law
07:54:37 <hyperisco> and what law is that?
07:55:37 <Taneb> xFromInt . xToInt === Just, I presume
07:55:46 <dminuoso> Yeah
07:55:54 <EdwardIII> http://www.seas.upenn.edu/~cis194/spring13/ is a bit friendlier / more practical than LYAH?
07:56:04 <dmwit> The two obvious laws are `fromInt . toInt = Just` and ```toInt <$> fromInt x `elem` [Just x, Nothing]```.
07:57:16 <hyperisco> okay cool... next step... the usefulness of laws is not so much the laws themselves but the theorems they can prove
07:57:17 <dmwit> up to fixity, because who can remember that stuff
07:57:59 <dmwit> FWIW, I frequently define Parse and PrettyPrint classes just to have a uniform, type-directed name for the parsers and pretty printers, not because I care about the laws.
07:58:08 <dmwit> And I don't think there's anything wrong with that.
07:58:31 <hyperisco> if you just want to use classes to enforce canonicity in serialisation then sure, should work
07:58:58 <dmwit> I don't know what "enforce canonicity" means, but I'm pretty sure that's not the goal.
07:59:41 <dmwit> I really just find it silly to type `parseMaybeInt`, `parseInt`, `parseWhatever` instead of `parse @(Maybe Int)`, `parse @Int`, `parse @Whatever`.
07:59:42 <hyperisco> there are many ways to serialise data, so to make sense of serialised data you want to have some standard canonical form
07:59:48 <dmwit> Or just `parse` when inference gives it enough info.
08:00:16 <dmwit> Maybe you want some standard form and maybe you don't. Depends on the situation.
08:00:28 <dmwit> And I don't think one or the other choice makes or breaks the decision to use a class.
08:00:31 <hyperisco> well, then don't use a class if you don't, because then that just works against you
08:02:04 <dmwit> Classes are the right solution even if your *only* goal is a consistent naming+typing scheme for an API that applies to several types.
08:03:09 <hyperisco> I suppose but I don't know what the purpose of that goal is
08:03:44 <dmwit> It is catering to mere human programmers with limited long-term storage for names.
08:04:14 <dmwit> Or: why do you think Data.ByteString exports all the same functions as Data.List, with all the same names and essentially the same types?
08:04:23 <hyperisco> I am happy to use qualified names to disambiguate the same name from different modules
08:04:44 <dmwit> That helps, but does not address the "consistent type scheme" part.
08:04:54 <dmwit> The machine can check that for you. Why not have it do so?
08:05:27 <dolio> I like chocolate, ergo everyone likes chocolate.
08:05:31 <hyperisco> I have never come across a situation where that seemed important
08:06:47 <hyperisco> I like chocolate ergo you should try it :P
08:07:19 <dmwit> I think your argument is more analogous to "I don't like chocolate, therefore you should try avoiding it.".
08:07:19 <dolio> Yeah, I'm sure dmwit is lacking experience.
08:07:35 <hyperisco> okay, well I'd still use that reasoning
08:07:52 <hyperisco> hey, look, I am not saying there is one answer for everyone
08:08:08 <hyperisco> dmwit is suggesting one thing and I am suggesting another... just comparing
08:13:36 <realloc> hi, are there tools available for formal verification of Haskell code? For example, for Java there is JML which allows you to annotate Methods with specification in First Order Logic which can be automatically proven by tools like the KeY Project.
08:14:23 <lyxia> there's hs-to-coq and liquid haskell
08:14:23 <dmwit> I think the most advanced system in that direction is Liquid Haskell.
08:14:30 * jml blinks
08:14:54 <dmwit> jml: the danger of short nicks =)
08:16:37 <cocreature> liquid haskell is definitely the closest thing to jml (sorry for highlighting again :)) that we have atm
08:20:26 <realloc> Ok thx everyone, i'll look into those options. Meanwhile, I also found this: https://wiki.haskell.org/Applications_and_libraries/Theorem_provers
08:21:38 <cocreature> realloc: note that those are provers implemented in Haskell not provers for verifying Haskell code
08:21:53 <realloc> Haskabelle sounds especially interesting on that list, however, it seems like the project is dead (404, also cant find much information elsewhere)
08:22:33 <cocreature> if you are interested in that hs-to-coq is definitely worth a look
08:24:45 <realloc> cocreature: alright, thank you
08:39:14 <ChaiTRex> What is a good name for f? f (x:xs) = (x, xs) [this is for a type that doesn't have constructors like (:), so I need a name]
08:39:46 <ski> `uncons' ?
08:40:02 <ChaiTRex> OK, thanks.
08:50:11 <adjofun> Greetings!
08:50:54 <TCZ> ok
08:54:22 <adjofun> Is it possible to define parser combinators for XML?
08:57:46 <c_wraith> why wouldn't it be?
08:58:35 <adjofun> It should be the same principle as with sequences of chars, but with sequences of tags
08:58:43 <monochrom> Is this Jeopardy? Are we all conversing in question forms now?
08:58:53 <adjofun> Is there any work in that direction?
08:59:07 <monochrom> "What is HXT?"
08:59:17 <c_wraith> parsec doesn't requires streams of characters.
08:59:34 <c_wraith> nor does megaparsec.
08:59:47 <c_wraith> both are just fine with any stream type.
09:00:30 <adjofun> So, I can just grab (mega)parsec, and feed in an HXT representation of XML?
09:01:07 <c_wraith> hxt already does the structural parsing.
09:01:51 <c_wraith> if you wanted something that just lexes content, you'd want something more like tagsoup
09:02:10 <adjofun> I need to parse XSD, srtucture of XML is nice, but is not enough =)
09:02:53 <c_wraith> parsing XSD is just the same as parsing any other xml document.
09:03:08 <EvanR> when inventing html they should have went with lisp syntax. the mistake was thinking that ( and ) needed to balance out!
09:03:27 <EvanR> should have allowed ( and ) randomly
09:03:36 <c_wraith> challenges arise when you're looking to validate something against the content of the XSD document.
09:04:42 <c_wraith> you could do something fun involving translating an XSD to a parser using parser combinators.
09:05:20 <adjofun> I basically need an ADT of XSD, I need to generate some output from it, I am not interested in validation
09:05:26 <adjofun> But it can be a side-goal
09:05:51 <c_wraith> ah, so you need to extract a representation of the rules.
09:06:40 <adjofun> yes, and this representation is looking like it would be easy to parse with combinators
09:07:16 <c_wraith> it might work, though I worry it's not the most natural solution.
09:08:04 <adjofun> In what way, please elaborate =)
09:08:23 <c_wraith> the most common use of parsing is converting a flat list of tokens to some sort of tree representing a structured interpretation of the tokens.
09:08:54 <c_wraith> you're already starting with a tree. it might be an awkward fit.
09:09:02 <adjofun> That is exactly what I need. Tokens are XML tags, and tree is XSD.
09:09:50 <rawles> Is there a version of filter that outputs two lists, one for things for which the predicate was true for, and one false? ie --> filterthing :: (a -> Bool) -> [a] -> ([a], [a])
09:10:13 <c_wraith> rawles, partition
09:10:36 <rawles> c_wraith: thanks!
09:12:24 <c_wraith> adjofun, my point is that the xml structure of the XSD already roughly reflects the tree structure of the XSD data type. it's less of a parsing problem and more of a tree traversal problem.
09:14:30 <adjofun_> so, conversion `f :: XML -> XSD` is a tree traversal, more than parsing?
09:15:09 <monochrom> Orthogonal to parsing.
09:16:43 <EvanR> isn't this one of those generic operations
09:17:07 <monochrom> Unless you consider "parsing" to be a synonym of "general computing".
09:20:08 <ab9rf> i'd say it's parsing tree-structured data
09:20:54 <ab9rf> also, that really should be XML -> Maybe XSD, because not all well-formed XML is a well-formed XSD
09:21:27 <adjofun_> that goes without saying =)
09:22:56 <ab9rf> well, no, it does not
09:23:26 <ab9rf> the conversion of Text to XML is parsing
09:23:39 <ab9rf> the conversion of XML to XSD is something else
09:23:53 <ab9rf> filtering, i suppose
09:24:17 <ab9rf> it might be parsing, i'd have to review the XSD speci
09:28:53 <monochrom> Most people's reaction to seeing the word "parsing" does not include imagining taking an abstract syntax tree as input.
09:29:06 <ab9rf> monochrom: with that i would agree
09:29:47 <ab9rf> monochrom: in fact, to do so the way i think of "parsing" would require that you traverse the tree to produce a token stream, which rather defeats the purpose of having in represented as a tree in the first place
09:30:20 <ab9rf> if you have XML the process of identifting it as XSD is just validation
09:30:31 <ab9rf> "does this XML tree represent a valid XSD"?
09:31:20 <ab9rf> it's really just a special case of validating XML, specifically against XSD's own schema (which can be defined in XSD)
09:31:50 <EvanR> what... why would you turn it back into a stream
09:32:00 <ab9rf> EvanR: because you want to parse it? :)
09:32:07 <monochrom> We're saying "don't".
09:32:16 <EvanR> no...
09:32:29 <EvanR> you want to validate one tree, in the process of converting it into another
09:32:40 <monochrom> Yes.
09:32:51 <EvanR> streams would add extra nonsense
09:33:16 <ab9rf> the one reason you might want to uyse streams is to avoid having to instantiate the entire XML document in memory
09:33:38 <ab9rf> some XML documents are ginormous,
09:34:06 <EvanR> yeah i would love to do tree traversals without using memory
09:35:27 <minopret> Is there a clear relationship between a monad and a conjugacy class?
09:36:23 <ab9rf> would you like for there to be one?
09:36:29 <cocreature> minopret: I don’t see one, do you have some concrete idea for how they relate?
09:39:54 <minopret> I misunderstood I suppose. Thought a monad is perhaps an environment where instead of doing f(a) and f(b) we are saying that but implicitly doing in effect (g^(-1) . f . g)(a), (g^(-1) . f . g)(b)
09:40:40 <cocreature> I have no idea what g^(-1) is supposed to be here
09:40:43 <ab9rf> me neither
09:40:55 <cocreature> or what even is f? a function, a type constructor, …?
09:40:56 <ab9rf> there's nothing about the monad laws that suggest that any member has a inverse
09:41:08 <dolio> It's inverse of g.
09:41:11 <dolio> In a group.
09:41:20 <cocreature> sure but what is g :)
09:41:25 <dolio> An element of the group.
09:41:43 <cocreature> … I understand groups, I don’t understand what the group is supposed to be in the context of monads
09:42:23 <dolio> Dunno. You could probably define a monad on a group.
09:42:44 <dolio> And a conjugacy class might correspond to one.
09:43:07 <dolio> Is a conjugacy class a subgroup of the larger group?
09:43:14 <minopret> The group would be function application for some particular set of functions depending on the particular monad. But I could be missing the fundamentals about monads.
09:43:23 <ab9rf> dolio: not noecessarily
09:43:42 <dolio> Ah. That makes it unlikely, then, I guess.
09:43:47 <dolio> At least, in general.
09:44:04 <ab9rf> dolio: the conjugacy classes partition the group; obviously only the class containing the identity is guaranteed to be a subgroup
09:44:44 <ab9rf> and actually thatr might not be true
09:44:47 <ab9rf> come to think of it
09:44:57 <dolio> I rarely think about groups anymore, and it's been like 20 years since the class I took with them.
09:45:02 <ab9rf> i'm not sure about closure
09:45:32 <minopret> Like, the list monad. Storing something in the list is useless without its inverse, retrieval. The conjugacy class in question is the class of values of cells, rather than values. I'm guessing.
09:45:52 <ab9rf> hm, the identity is always in itso own conjugacy class, by itself, so that kinda kiboshes that
09:47:46 <minopret> Ok, I may want to take some occasion to sit down with the definitions and a pencil.
09:47:48 <ab9rf> i kinda understand where this idea springs, but i don't think it goes anywhere useful
09:48:58 <ab9rf> minopret: what's the inverse of getchar?
09:49:05 <dolio> Actually, conjugation might be a monad on a group.
09:49:18 <ab9rf> dolio: that's a possibility
09:50:54 <dolio> It's functorial, at least.
09:51:03 <dolio> I'm not sure what the monad stuff corresponds to.
09:51:29 <ab9rf> i'm not clear on what the natural transformations would be
09:51:51 <dolio> They're group elements with some property.
09:52:05 <dolio> I think.
09:52:40 <ab9rf> i'm failing to construct that, but i suck at this
09:52:42 <minopret> Like, we could define a monad, I guess, where we're computing /\ and \/ of the negations of Boolean values. And then return the negation of the result?
09:53:00 <dolio> eta . a = cong(a) . eta
09:53:52 <minopret> so g (and also g^(-1)) is Boolean negation, f is /\ or \/
09:55:57 <minopret> I may be lost here. But, not always when I wander am I lost :-)
09:56:17 <ab9rf> minopret: i'm not qualified to guide you
09:56:33 <ab9rf> at most, i can offer you badly brewed coffee
09:56:46 <ab9rf> or possibl cofree, you'll never know
09:57:42 <minopret> Or c . (f $ f) (e $ e)? Ok thanks
10:00:02 <chessai> siraben: https://www.datahaskell.org/
10:00:37 <chessai> siraben: https://github.com/DataHaskell/data-glue
10:11:38 <cobax> if the object mapping of a monad is represented as * -> * then aren't all Haskell functors really endofunctors?
10:11:51 <dmwit> All Functors are endofunctors, yes.
10:12:27 <cobax> Well, outside of haskell one can build a true C -> D functor, but not in Haskell, do I understand that right?
10:12:32 <dmwit> There are a couple packages out there that generalize further. But the uses of the more general functor classes are pretty niche, and sometimes a bit annoying to use.
10:12:56 <ab9rf> heh
10:12:59 <dmwit> No, "cannot" is too strong.
10:13:39 <dmwit> Certainly not all functors are expressible (not even all categories are expressible), but it is possible to talk about non-endofunctors. They just aren't instances of the blessed Functor class in Prelude.
10:13:44 <cobax> Ok, I just meant to say, the thing we call Functor in haskell, is always an endofunctor, because it always goes from Haskell types to Haskell types? And it doesn't seem straightforward what a functor C -> D would mean in Haskell to me
10:13:57 <cobax> ah that makes sense
10:14:24 <dmwit> cobax: One particularly general definition of a generalized functor that I've seen is:
10:14:59 <dmwit> class (Category c, Category d) => GFunctor c d f where gfmap :: c a b -> d (f a) (f b)
10:16:07 <hyperisco> gets annoying because inference cannot help you much
10:16:17 <cobax> Hmm... indeed it doesn't look familiar but I can understand it
10:17:36 <dmwit> cobax: If you take `c ~ (->)` and `d ~ (->)`, you get back to the familiar type for `Prelude.fmap`.
10:18:31 <cobax> dmwit: I'm afraid I'm not familiar with that infix tilde
10:18:57 <dmwit> type-level equality
10:19:08 <dmwit> If you choose `c` to be `(->)`, and `d` to be `(->)`...
10:19:23 <cobax> yes that is how I was seeing it!
10:20:13 <cobax> After banging my head for years against Haskell and CT (because they're endlessly interesting) I now think Monads are so helpful in Haskell because 1. their being endofunctors lends them to many uses and 2. T.T -> T (join) is an evaluator-like or interpreter-like pattern
10:20:24 <cobax> and many abstractions can be represented as interpreters of data structures
10:20:39 <cobax> especially if those data structures represent computation steps
10:21:17 <cobax> does that make sense?
10:22:05 <ab9rf> i'm not convinced that making sense is important
10:22:06 <ab9rf> :)
10:25:52 <cobax> It also seems to me that many of the useful Free things are endofunctors, and Free endofunctors and monads end up with this nice evaluator-like pattern
10:31:43 <sm> hey all.. a haskell layout question - could ghc be parsing lines 155-166 as part of 153's do block at https://hub.darcs.net/simon/darcsden/browse/src/DarcsDen/Handlers/RepoHandlerUtils/Forks.hs#145 ? I don't think so
10:36:05 <lyxia> that seems to be the case actually
10:36:43 <Wizek> hexagoxel: haven't yet. But now that I have ghcid building set up I guess I could give it a try.
10:39:32 <lyxia> sm: https://gist.github.com/Lysxia/a8b60c858a18d48d5f40fd5526235807 you can check whether this prints anything (it doesn't)
10:39:50 <ski> cobax : e.g. `StateT s' is a functor from `* -> *' to `* -> *'
10:40:00 <sm> lyxia: thanks.. wow!
10:42:33 <sm> aha. GHC complains about this with -XHaskell2010 
10:43:17 <lyxia> oh interesting
10:43:44 <sm> but without that, it does work as you say. Mystery solved
10:44:55 <ChaiTRex> What is WHNF for a function?
10:45:46 <cocreature> ChaiTRex: evaluate it until you hit a lambda
10:47:35 <ChaiTRex> Do arguments count as lambdas?
10:47:50 <ChaiTRex> Like f a b = 5 would only be evaluated to \ a b -> 5?
10:48:12 <geekosaur> sm, at a guess, -XNondecreasingIndentation, which is default unless you explicitly turn it off or request -XHaskell2010 or -XHaskell98
10:48:35 <geekosaur> and which tends to be a fertile source of indentation surprises
10:49:42 <sm> geekosaur: right you are, even clearer. Thanks
10:50:00 <EvanR> f = \a -> \b -> 5
10:50:43 <ChaiTRex> EvanR: Ahh, OK. Thanks.
10:50:48 <ChaiTRex> cocreature: Thanks.
11:52:06 <dolio> cobax: I think that's very close to the correct idea.
11:52:24 <dolio> One main thing monads are for is describing algebra.
11:52:35 <dolio> And embedded languages are algebraic.
11:53:15 <dolio> If you have a monad T, then an algebra for that monad is a carrier object A and a map TA -> A that behaves nicely with respect to the monad operations.
11:53:58 <dolio> And given any monad T and object A, the free T-algebra over A is the pair (TA, mu : TTA -> TA).
11:54:22 <dolio> And the category of free algebras is the Kleisli category.
11:55:11 <dolio> Oh, the algebra mapping shows how to interpret the 'syntax' of T into the carrier A, and the free algebra just flattens together the 'syntax'.
11:55:50 <dstolfa> and if you want inductive/coinductive definitions, make sure to use the initial F-algebra or the final F-coalgebra to describe them ;)
11:56:00 <dstolfa> because saying it that way sounds cooler!
11:57:43 <dolio> So the monad use in Haskell is generally writing things in embedded languages whose syntax is the free algebra of a monad.
11:59:51 <mniip> I've never once used a monad with the intention of using its free algebra
12:00:15 <dolio> That's difficult to believe.
12:00:20 <mniip> unless of course something I am familiar with has a second fancy name of a free algebra
12:11:25 <abstract_> Hi everyone! I am a newbie in Haskell and I would be happy if you help me with this: why does not "concatMap (^2) [1..3]" work? Isn't "(^2)" a function?
12:12:11 <lavalike> abstract_: it is but it doesn't return a list of results
12:12:35 <lavalike> abstract_: concatMap (\x -> [x^2,x^3,x^4]) [1..3] will, for example
12:13:07 <lavalike> abstract_: or map (^2) [1..3] if you want to keep the function and change the combinator
12:13:11 <mizu_no_oto> :t concatMap
12:13:12 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
12:13:38 <abstract_> Oh, I got it. Thank you so much.
12:13:43 <mizu_no_oto> abstract_: what are you trying to do?
12:13:44 <nbloomf> :t (^)
12:13:46 <lambdabot> (Num a, Integral b) => a -> b -> a
12:14:28 <mizu_no_oto> > map (^2) [1..3]
12:14:31 <lambdabot>  [1,4,9]
12:15:13 <abstract_> I was just following a tutorial and wanted to try something else by putting another function.
12:15:28 <mizu_no_oto> And the tutorial used concatMap?
12:15:47 <abstract_> Can I give a link here?
12:15:50 <mizu_no_oto> Sure
12:16:00 <abstract_> This: http://learnyouahaskell.com/modules
12:16:46 <c50a326> can't I install the snap binaries using stack?
12:17:44 <c50a326> if I try to use cabal, it says "cabal: The following packages are likely to be broken by the reinstalls:" and then 'store' and 'stack' are shown
12:17:45 <cocreature> c50a326: looks like snap is not on stackage so you will have to add it to the extra-deps section in your stack.yaml
12:17:54 <c50a326> so I don't really want to break my stack installation...
12:18:12 <mizu_no_oto> abstract_: as that mentions, concatMap is the same as mapping then concating the results, so it'll only work if the function you pass in returns a list
12:20:00 <mizu_no_oto> > concatMap (enumFromTo 1) [1..5]
12:20:02 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5]
12:20:02 <c50a326> cocreature: well I was able to `stack install snap` but there are no binaries in ~/.local/bin 
12:20:20 <mizu_no_oto> > map (enumFromTo 1) [1..5]
12:20:22 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
12:21:20 <cocreature> c50a326: snap is a library not an executable
12:21:33 <cocreature> c50a326: you add it to the dependencies of your project and don’t install it using "stack install"
12:22:56 <c50a326> cocreature: no, it's also an executable
12:23:01 <mizu_no_oto> > concatMap (\a -> concatMap (\b -> concatMap (\c -> if a*a + b*b == c*c then [(a,b,c)] else []) [1..10] ) [1..10] ) [1..10]
12:23:03 <lambdabot>  [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
12:23:14 <c50a326> http://snapframework.com/docs/quickstart http://snapframework.com/download etc
12:23:16 <cocreature> c50a326: no it is not, take a look at the cabal file https://hackage.haskell.org/package/snap-1.1.1.0/src/snap.cabal
12:23:20 <cocreature> there is no executable in that package
12:23:29 <cocreature> there might be a different package with a similar name that has an executable
12:25:44 <abstract_> I see. Thank you for the examples, mizu_no_oto. They sure helped me to understand it better.
12:26:30 <c50a326> cocreature: ah, yes, snap-templates, thanks!
12:40:01 <mniip> dolio, any more insight?
12:40:33 <dolio> For what?
12:41:03 <mniip> for free algebras
12:55:00 <dolio> So, `get` and `put x` are terms of the free `State s` algebra (among others).
12:55:30 <dolio> get is in the algebra over s, and put in the algebra over ().
13:00:55 <dolio> Homomorphisms of free algebras TA -> TB are determined completely by maps A -> TB which say what to do with the 'variables'.
13:01:20 <dolio> And are basically substituting, which allows you to build up bigger expressions from smaller ones.
13:01:34 <dolio> Which is what you're doing with do notation.
13:02:36 <mniip> dolio, isn't an algebra a tuple (X, TX -> X)
13:02:40 <mniip> rather
13:02:44 <mniip> (X, f : TX -> X)
13:03:16 <dolio> Yes.
13:03:35 <dolio> Free algebras are of the form X = TY, f = mu.
13:06:37 <dolio> In the case of most 'classic' monads, the free algebra has interesting semantics that people want to use kind of directly. But if your monad is just a free monad, you might want to write an 'interpreter' for it instead.
13:13:04 <dolio> Of course, this is because monad transformers nail down the semantics completely.
13:13:54 <dolio> So the free algebra of a concrete monad built out of transformers has all the semantic interactions between the pieces defined.
13:14:20 <Boarders> is it possible to use generalized new type deriving to get all the same instances as the underlying type?
13:14:34 <dolio> If you used coproducts of monads, or if you use mtl classes, which are more like Lawvere theories, then the decision is delayed.
13:14:35 <carter> mostly
13:17:09 <geekosaur> Boarders, there's no shorthand for "derive all instances", no
13:17:13 <geekosaur> if that's what you meant
13:17:22 <Boarders> it is what I meant, yeah
13:17:23 <Boarders> thanks
13:17:44 <geekosaur> mostly because that raises the question of why you're using newtype instead of type
13:19:06 <hyperisco> deriving everything
13:19:32 <Boarders> mostly because I have some data which should have the same lenses and that sort of thing but I want the type sytem to distinguish between the phases at which the data are used
13:19:35 <Boarders> something like that
13:21:02 <geekosaur> I think I'd use something like Tagged there, maybe
13:21:12 <Boarders> e.g. if I wanted to use a phantom type with all the same instances
13:22:10 <Boarders> does Tagged get you anything in terms of type classes?
13:23:43 <geekosaur> it just lets you attach a phantom type functioning as a tag to your data. might not be quite what you want though, you'd have to unwrap it. (I think. Might already be Iso in which case it might Just Work)
13:25:48 <Boarders> cool thanks, ill give it a spin and see if it fits
13:50:55 <dmrd_> hey folks, given a haskell source file with imports and all. Is there a way to get ghci (or any other tool for that matter) to tell me what which import is responsible for a function name being available?
13:51:01 <dmrd_> in scope?
13:51:51 <Hafydd> dmrd_: :i
13:52:04 <selfsymmetric-pa> dmrd_: So like `:i fmap` in ghci.
13:52:12 <Hafydd> dmrd_: oh, well, that tells you the module, not necessarily the import statement.
13:52:21 <geekosaur> ghci these days tends to tell you the ultimate module, not the import that led to it
13:52:44 <dmrd_>  thats perfect, I just need the 'full path' / namescope of it
13:52:52 <dmrd_> and this seems to handle that :)
13:53:01 <dmrd_> thanks again
13:53:27 <Hafydd> :i'm happy to help.
13:54:16 <monoidal> Suppose I have import Control.Arrow hiding (first). If I try to define "instance Arrow T where first = undefined" I get an error that first is not in scope
13:54:21 <monoidal> To my surprise, if I add "import qualified Control.Arrow", then this works. Is this documented/expected? It looks like a qualified import is affecting nonqualified identifiers
13:55:35 <dmwit> monoidal: When implementing a class, the method name is never permitted to be qualified.
13:56:35 <dmwit> You can see what that implies about how scoping must be done, and why it means it pretty much has to behave the way you're observing.
13:57:58 <monoidal> I understand, thanks
13:58:36 <dmwit> (Now, you might ask why the method can't be qualified. I don't have a good answer to that.)
13:59:26 <monoidal> (b) the class method is in scope in the module body regardless of whether it is in scope under a qualified or unqualified name.
13:59:47 <monoidal> (found this in report)
14:00:13 <monochrom> "ghc -ddump-minimal-imports" tells you who comes from where
14:01:02 <monochrom> or rather, who comes from which import line, because it actually tells you how to restrict every import line.
14:01:45 <monoidal> though this is part of export list definition, so it might not be it.
14:03:38 <monoidal> dmwit: it seems that this is an instance of the general rule that a qualified name cannot be in a binding position
14:04:19 <nan`> i have a problem with Data.Time (UTCTime). I am using this module postgresql-simple which defines an instance on UTCTime. I import UTCTime in the same way this instance-defining module does, but when i go to use the instance in my code i get instance not found. It points to an internal instance "time-1.8.0.2:Data.Time.Clock.Internal.UTCTime.UTCTime" where it is defined. Any ideas?
14:05:21 <nan`> i am doing import Data.Time (UTCTime) the same way postgresql-simple does. The instance is ToField https://hackage.haskell.org/package/postgresql-simple-0.5.4.0/docs/src/Database.PostgreSQL.Simple.ToField.html
14:06:08 <nan`> basically the instance is hidden and it is on the internal type but not the imported type, somehow
14:08:22 <mniip> nan`, do you have multiple versions of the time package?
14:09:02 <monochrom> Section 4.3.2 "Instance Declarations" has the rule and an example of what happens to qualified method names in an instance declaration. It also adds "yeah this is the same as the export story".
14:09:22 <nan`> mniip: maybe, i am using stack though i am new to it
14:10:35 <monochrom> Hey "C-T instance declaration" is a cool name.
14:10:42 <monochrom> or rather, cool phrase.
14:11:16 <nan`> i have "time >= 1.0 && < 1.9," one time in my cabal file
14:11:16 <mniip> % tyConModule $ typeRepTyCon $ typeRep (Proxy @Data.Time.UTCTime)
14:11:17 <yahb> mniip: "Data.Time.Clock.Internal.UTCTime"
14:11:21 <MarcelineVQ> nan`: what's the error you get
14:12:19 <nan`> MarcelineVQ: No instance for (ToField UTCTime)
14:12:25 <MarcelineVQ> the whole error
14:12:45 <nan`> "There are instances for similar types time-1.8.0.2:Data.Time.Clock.Internal.UTCTime.UTCTime"
14:13:18 <nan`> https://pastebin.com/WtcfgR6B
14:14:00 <nan`> so it is indeed finding an instance, it is just on the internal type and not my imported type from Data.Time
14:14:19 <monochrom> Please don't presume what "Internal" means.
14:14:24 <nan`> ok 
14:14:26 <geekosaur> not clear; usually those are re-exports
14:14:32 <geekosaur> so I think you have a different time package
14:15:22 <nan`> geekosaur: does that mean the module that defines the instance has a different time from me?
14:15:49 <geekosaur> what you have claimed is that your specification for the time package is compatioble with the one shown in the error message
14:16:08 <geekosaur> this does not mean that somehow time-1.8.0.1 got picked instead, whose UTCTime type will not match time-1.8.0.2's
14:16:36 <geekosaur> (structurally it will be the same but the typechecker will correctly treat them as different, because they're not going to hook up properly)
14:17:25 <realloc> hi, is it possible to let a udp socket time out (network lib), after some time, since it blocks indefinetly if nothing is received?
14:19:23 <nan`> geekosaur: i don't understand. how would i resolve something like this? in my cabal/stack config?
14:20:32 <geekosaur> stack normally won't let this happen; nor will cabal new-build. cabal build sometimes will especially if not sandboxed, since it will prefer certain versions
14:20:44 <geekosaur> I don't know how you;re building this so I can't really say any more
14:23:28 <monochrom> realloc: Consider the "timeout" package, or using async's "race" function (have the reading job and the timing job compete). You can also roll your own from first principle: one thread reads, another thread times and kills the reader thread.
14:25:03 <realloc> monochrom: Should I really consider killing a thread for this? Will the socket be in a defined state after that? 
14:27:01 <monochrom> It will be in a defined state.
14:28:46 <realloc> monochrom: First thx for your anwer. Do you know which state that is, when killing a udp socket, blocking on recvfrom? (e.g. will it still be usable/can it be closed?)
14:28:51 <realloc> *answer
14:29:29 <cobax> dolio: I think what you are talking about is exactly what I need to read next
14:29:58 <kyagrd> IHaskell docker image (lts-11.22, ghc 8.2.2, amd64) made available on Docker Hub https://hub.docker.com/r/kyagrd/ihaskell/
14:30:15 <monochrom> I don't know.
14:30:25 <kyagrd> is my message duplicated? seem to have kiked out by ChanServ and came back
14:33:56 <realloc> monochrom: alright
14:35:15 <EvanR> realloc: its possible to see what the alternatives are by investigating the code
14:35:37 <EvanR> it may be pretty deep though
14:39:39 <realloc> EvanR: Ok. Though I guess this way I have no "guaranteed" library behavior I can rely on. Maybe I'll try to think of another way first 
14:45:17 <mizunno> Hi, can someone link me some documentation to package a library, so others can install and import?
14:45:41 <mizunno> I am just playing around...
14:58:33 <threewood> realloc: It's been a while but I think there are typically platform specific ways to set UDP timeouts?
15:15:40 <realloc> threewood: There is a socket option, but it is unsupported in haskell's network lib
15:18:24 <ab9rf> threewood: what's a UDP timeout?
15:18:28 <ab9rf> threewood: UDP doesn't time out
15:18:53 <threewood> It's just the time that recvfrom waits before giving up
15:18:59 <threewood> or select
15:19:34 <threewood> ignore me, realloc knows everything I could remember to tell him
15:19:36 <ab9rf> it's whatever you specify in the select call or recvfrom call, if you don't specify one it waits forever
15:19:49 <ab9rf> iirc
15:19:57 <Average-user> Is there a way to use Radix sort from http://hackage.haskell.org/package/vector-algorithms-0.7.0.4/docs/Data-Vector-Algorithms-Radix.html, with [(a,Int)] where a is not an Unboxed type?
15:19:57 <threewood> I recall it being a little tricky
15:20:06 <threewood> but maybe I'm misremembering
15:20:09 <threewood> It's been years
15:20:16 <threewood> tricky = platform specific, not hard
15:20:59 <ab9rf> threewood: some but not all platforms allow ytou to set a read timeout on a socket using ioctl
15:21:14 <ab9rf> threewood: this is very platform specific, as you not
15:21:27 <threewood> yeah, sounds right
15:21:55 <ab9rf> it's probably better to poll for a ready socket instead of relying on calls to recv to timeout
15:22:46 <ab9rf> i _absolutely hate_ UNIX I/O
15:22:47 <geekosaur> but the ghc runtime does that which is why you stick it in a thread and kill the thread
15:23:00 <ab9rf> of course, i hate I/O on every other operating system i've ever used as well
15:23:09 <monochrom> realloc: If you're OK with using socketToHandle to convert to Handle, and then using Handle's usual input operations... Then "blocking read from Handle" is internally a select/epoll thing, so if you kill a thread that is waiting for "blocking read from Handle" you are just telling select/epoll one fewer thing to sorry about, you are not interrupting a recv call.
15:23:10 <threewood> ab9rf: agree
15:23:36 <EvanR> down with IO
15:24:09 <ab9rf> the Real World is a pain in the ass and should be disregarded as much as possible
15:25:25 <heebo> does eta-lang transpile to haskell. I say this because it seems you can put eta packages in cabal files as dependencies.
15:26:00 <monochrom> I agree about worrying about killing a thread that's blocking on recv/recvFrom because I read the code of network and they are directly foreign C calls to the OS's recv/recvfrom. Worse, they are "foreign import unsafe".
15:27:17 <monochrom> But if you convert to Handle and use Handle operations, you're back to GHC RTS's nice and safe multithreading land.
15:28:00 <ab9rf> monochrom: ugh!
15:28:32 <EvanR> what... recv and recvFrom are FFI... ?
15:28:37 <EvanR> not RTS
15:28:46 <ab9rf> monochrom: it would be a very odd use case for which converting to a handle and letting RTS deal with it is not a better solution
15:28:47 <EvanR> everything i know is wrong
15:29:38 <ab9rf> EvanR: RTS probably uses read instead of recvfrom; if you need the datagram headers you have to use recv. read on datagram sockets is... problematicx
15:30:22 <ab9rf> you're not supposed to read from a datagram filehandle, iirc, but most version of UNIX let you, just with Possibly Unexpected behavior
15:30:46 <ab9rf> like getting more than one datagram at a time
15:31:13 <ab9rf> how does network handle accept?
15:31:24 <monochrom> Oh yikes.
15:32:16 <monochrom> Yes I hate the real world now. :)
15:32:36 <ab9rf> monochrom: i've been writing netlibs since the 80s, it hasn't gotten any better in the past 3 decades
15:33:28 <ab9rf> well, ok, it is today somewhat harder to cause a kernel panic or a watchdog timeout solely from userspace code than it was in 1988
15:34:13 <mniip> easy as shit if you're working with GPU drivers of various stability
15:34:36 <ab9rf> mniip: TCP/IP drivers were like that in the 80s
15:34:41 <mniip> vendors being more and more shit at ACPI doesn't help either
15:35:01 <ab9rf> mniip: for the most part, they've been pretty reliable, with a  few exceptions, since the mid-90s
15:35:25 <mniip> man those were simpler times
15:35:51 <ab9rf> (thank you, phil karn)
15:36:09 <ab9rf> mniip: ayup
15:39:01 <arahael> Haskell stack seems to take a long time every time I tell it to build, at 'progres 0/2'.  What is it doing at that point?
15:39:06 <ab9rf> now i'm curious as to if RTS IO has any way to tie end-user code into its epoll loop
15:39:12 <arahael> (And how might I speed that up?)
15:39:48 <ab9rf> i assume it allocates a thread to IO which is just an epoll-and-dispatch loop
15:41:06 <arahael> "Progress 0/2", rather.
15:43:51 <mniip> ab9rf, each thread might do its own epolling
15:44:14 <mniip> I know if you don't do forkOS GHC wouldn't hesitate to run different haskell threads in one OS thread
15:44:18 <mniip> as they are lightweight
15:44:32 <mniip> as we don't use the OS stack
15:48:03 <c_wraith> iirc, even forkOS is only specified such that all IO from that haskell thread happens on the same OS thread. no requirement that it is the exclusive user of that OS thread for IO.
15:48:34 <c_wraith> err. s/IO/FFI/g
15:52:21 <emacstheviking> Hi. Trying to render a texture with sdl2-image but stuck. I have a Renderer but SDL.Raw.Video.renderCopy says it wants GHC.Ptr.Ptr and I have no ida what to do about it!
15:52:35 <emacstheviking> I have a scrolling star field, music, keys, but no textures yet!
15:54:54 <hexagoxel> emacstheviking: https://hackage.haskell.org/package/sdl2-2.4.1.0/docs/SDL-Video-Renderer.html#v:copy
15:55:17 <hexagoxel> or do you have a reason to use Raw.* ?
15:55:57 <emacstheviking> My *only* reason was pure ignorance of the alternatives! I have used it with C but this is a new way for me!! Thanks for that....I winder sometimes how I get as far as I do.
15:56:35 <emacstheviking> OK, well, thanks again list. Awesome performance as usual. Final half hour then beddie byes methinks. :)
15:59:02 <JonReed> How can I throttle IO actions? Lets say I want a max of 5 threads at the same time. The IO task should block until it can be executed, then execute and unblock.  So far I'm checking all libraries and async functions and they seems to be good for working with lists, but not I'm confused how to make it work when tasks are spawned by random threads and I want to block those tasks so that only 5 are done at the same time and threads can c
15:59:41 <hexagoxel> emacstheviking: you might want to have a look at the examples, e.g. Lesson07 does texture rendering
16:00:25 <hexagoxel> (the examples contained in the sdl2 package, that is)
16:00:27 <JonReed> I'm looking a way to throttle network requests, so presumably it should be concurrent pool (green threads) rather than parrallel (running on separate OS threads)
16:00:39 <emacstheviking> success!! I will indeed have a damned good read ...tomorrow! Thanks again.
16:01:01 <zzz> what is this "it's the right think to odôéóëêè
16:01:14 <zzz> *TM
16:01:31 <zzz> ?
16:01:55 <realloc> monochrom: Thx for the insights on socketToHandle
16:02:12 <zzz> ok let me rephrase that: what is this "it's the right thing to do ^TM" meme I keep seeing?
16:02:22 <hpc> JonReed: thread pool that you pass actions to
16:02:38 <hpc> with a Chan (IO ())
16:03:18 <MarcelineVQ> JonReed, hpc: there's also http://hackage.haskell.org/package/base-4.11.1.0/docs/Control-Concurrent-QSem.html which is a neat little thing
16:03:21 <hpc> each one runs forever $ do {action <- readChan actions; action; return ()}
16:04:20 <hpc> MarcelineVQ: that needs a with-function so you don't leak claims when a thread crashes
16:05:29 <hexagoxel> there are packages async-pool and async-extras, both containing some "pool" functionalities
16:05:37 <JonReed> hpc: Okay, thanks. I'll try this direction.
16:06:23 <hpc> (the funny thing is i actually don't know what packages provide thread pools because they're so easy to write on my own)
16:07:00 <JonReed> hexagoxel: I tried async-pool, but it requires to call `runTaskGroup` before execution. When tasks are spawned by random threads, I'm not sure where start execution of the pool from
16:08:31 <hexagoxel> create a pool initially, pass it around. You have to pass something around either way, be it a TaskGroup or a Chan (IO ()) or whatever else
16:08:39 <hpc> JonReed: wherever you would spawn the worker threads
16:08:44 <hpc> so it'd probably be at the very start of the program
16:09:42 <JonReed> hexagoxel: It creates the pool and I can pass it, but then `async-pool` will only start execution of any tasks after I also call runTaskGroup
16:10:20 <JonReed> hexagoxel: So I pass the pool and push actions there, but it doesn't execute until I also call `runTaskGroup` from somewhere
16:11:04 <ab9rf> i read "leak claims" as "leak clams"
16:11:49 <ab9rf> nobody wants a leaky clam
16:15:30 <jle`> you don't speak for me
16:17:49 <dyl> Is it possible to enforce typeclass constraints on associated typeS? 
16:18:26 <dyl> Moreover, is this even a good idea?
16:18:53 <dyl> i.e. contrived example, say you have class Taggable a where { type Tag a; tag :: a -> Tag a }
16:19:02 <dyl> But you also want to encode that Tag a must be Eq.
16:19:22 <hexagoxel> class Eq (Tag a) => Taggable a where ..
16:22:41 <dyl> hexagoxel with flexible contexts right?
16:22:54 <dyl> Is there no way to specify it *on* the associated type directly?
16:23:47 <jle`> dyl: hexagoxel effectively gave a method to constrain associated types
16:23:59 <dyl> Yes, and it works :p.
16:26:53 <hexagoxel> JonReed: but you only call `runTaskGroup` once and it keeps going, judging from the `forever`.. but perhaps you are right and it is for a different usecase.
16:36:35 <hexagoxel> (hmm that there is "syntactical disconnect" between constraint and type might highlight that the constraint is indeed connected to the class/instance, not the type.. which probably is a good thing.)
16:45:45 <dyl> Just discovered TypeFamilyDependencies.
16:45:47 <dyl> That's handy.
17:14:26 <ChaiTRex> What does the CONSTANT_FOLDED pragma do?
17:25:10 <sleepster> for someone just starting with Haskell, should I use Stack or Cabal?
17:25:23 <Clint> yes
17:26:16 <sleepster> oh, I thought Stack was different than Cabal
17:26:33 <sleepster> sorry, I meant, should I learn Stack or should I learn Cabal
17:27:19 <xsperry> did you install haskell through stack?
17:28:13 <OmegaDoug> I'd like to combine/compose functions kind of like <> does, but I'd like to ensure that only certain orders of combinations can compile. Any suggestions? 
17:28:14 <OmegaDoug> https://gist.github.com/DouglasBrunner/eaa6fcb4702ce0dc7a94f197e262b580
17:29:19 <xsperry> if you did cabal isn't even in your part, so you have to use
17:29:23 <xsperry> s/part/path
17:31:02 <sleepster> xsperry: yup, I installed everything through stack
17:31:05 <xsperry> stack uses curated packages from stack (unless you explicitly ask it not to) that are known to be mutually compatible
17:31:13 <sleepster> xsperry: is this the best way to go for a beginner?
17:31:28 <xsperry> sleepster, I think it is the best way to go for anyone. but not everyone agrees :P
17:31:33 <sleepster> :)
17:31:34 <sleepster> hah
17:33:56 <EvanR> i hate it when theres 2 right answers
17:34:24 <EvanR> or 2 tools that seem to be for the same thing at the same time, and everyone has to know both
17:34:57 <sleepster> Haskell seems like a very cool language.  I have been trying to find projects to use Haskell with but not sure what to do 
17:35:03 <sleepster> it would be nice if I can create an Android App
17:35:14 <sleepster> I am already very familiar with Android so it would work for me
17:39:22 <sm> sleepster: that's an advanced black-arts haskell kind of project
17:39:48 <dmwit> OmegaDoug: Sounds like you want Category, not Monoid.
17:40:49 <sm> or.. not ? https://wiki.haskell.org/Android
17:41:28 <OmegaDoug> dmwit: You saved my day. That looks perfect.
17:41:58 <OmegaDoug> dmwit: The writeup on Typeclassopedia sounds like it's exactly what I need.
17:42:04 <OmegaDoug> dmwit: Thank's a bunch
17:42:08 <dmwit> cheers!
17:46:36 <sleepster> sm: ah
17:46:56 <sleepster> sm: I think it'd be great if it supported Android
18:03:15 <ab9rf> android is a bit of a weird environment
18:04:38 <suzu> there was a game studio that made android games in haskell
18:04:40 <suzu> they're dead now
18:04:43 <ab9rf> heh
18:04:54 <suzu> i recommend you.. don't make android apps in haskell
18:04:57 <suzu> it's not a good fit right now
18:05:08 <ab9rf> there are a smattering of blog posts and such not about people using haskell on android
18:05:44 <ab9rf> http://keera.co.uk/blog/2017/06/01/haskell-android-ios/
18:06:14 <suzu> yeah this company is dead now i think
18:07:20 <ab9rf> last tweet was April 2
18:07:52 <ab9rf> and that was a retweet
18:08:09 <ab9rf> if they're not dead, they're being wery wery qwiet
18:09:15 <ab9rf> their facebook page is still active
18:09:19 <ab9rf> yesterday 
18:12:19 <mnoonan> ugh, lenses.. given "thing :: Maybe Thing" and "part :: Lens' Thing Part", I'm sure there must be an idiomatic way to write "view part <$> thing :: Maybe Part". What is it?
18:13:31 <ehegnes> Hey folks. First time here. I'm looking to generate coverage reports with `hpc`. I provide `-fhpc` to the testing module, but then the coverage report is generated for my testing module, not on the library that is being tested. Am I missing something?
18:14:37 <ehegnes> not for the library being tested*
18:14:52 <shachaf> mnoonan: preview (_Just . Part), maybe?
18:14:57 <shachaf> Depends on what you're going for.
18:16:32 <mnoonan> shachaf: mostly just trying to make some new code as idiomatic as possible to fit in with the old code.
18:17:10 <mnoonan> I have a bunch of lenses to "Maybe X" types, and then some more lenses into the X (and maybe those lead to Maybe Ys, etc)
18:17:29 <mnoonan> it's fine like it is I guess, but doesn't feel idiomatic
18:17:52 <shachaf> s/Part/part/, I mean
18:21:53 <Gurkenglas> mnoonan, you could make the interface provide Traversal' Foo Part
18:22:20 <Gurkenglas> Traversal' X Y
18:22:30 <Gurkenglas> (In your case they're affine traversals but whatever)
18:23:54 <Gurkenglas> mnoonan, if you link to your code I could get more specific
18:27:40 <mnoonan> Gurkenglas: thanks, I'll tinker with this a bit until I can at least get it to compile and then put something up
18:29:11 <crick_> can someone walk me through functors, applicatives and monads?
18:31:05 <crick_> I understand little bit but not fully..
18:34:04 <jle`> crick_: what have you read so far?
18:34:35 <crick_> I have read through chapters from learn you a haskell
18:34:52 <crick_> I know functors are things that can be mapped over
18:35:15 <jle`> so you're familiar with what typeclasses are?
18:35:19 <crick_> Yes
18:35:21 <jle`> like monoid, Eq, Num, etc.
18:35:35 <crick_> Yes, I know Eq and Num
18:35:40 <jle`> if you understand that functors solve a "mapping" problem, allowing you to do (a -> b) -> (F a -> F b)
18:35:53 <crick_> Yes
18:36:00 <jle`> then consider how you would "map" a multi-argument function
18:36:15 <jle`> like an (a -> b -> c) with an 'F a' and a n'F b'
18:36:24 <mnoonan> shachaf: thanks for the lead, "thing ^? _Just . part" will fit in well, I think.
18:36:29 <jle`> that's more or less what Applicative solves
18:36:44 <crick_> ohkay
18:36:54 <jle`> fmap lets you map a "single argument" function, and applicative lets you map a "multi-argument" function over many f a's
18:36:55 <crick_> Yeah
18:37:04 <crick_> Right
18:37:13 <jle`> there are many ways to define such a function for many types, of course
18:37:18 <ski> (including zero arguments)
18:37:30 <crick_> Hm..
18:37:35 <jle`> Applicative is a particular scheme that pops up in many different circumstances
18:37:58 <crick_> Can you show me one such circumstance?
18:38:02 <jle`> but yeah, if you can imagine what `fmap length getLine` does
18:38:12 <jle`> try imagining what `liftA2 (++) getLine getLine` does
18:38:32 <dmwit> % writeFile "foo" "bar"
18:38:32 <yahb> dmwit: 
18:38:42 <jle`> Applicative is meant to combine `f a`s in a "monoidal" manner
18:38:43 <dmwit> % writeFile "baz" "quux"
18:38:43 <yahb> dmwit: *** Exception: baz: hClose: resource exhausted (No space left on device)
18:38:49 <dmwit> ...oh
18:38:55 <ski> @type liftA2
18:38:56 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:39:05 <ski> @type liftA3
18:39:06 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
18:39:08 <dmwit> % liftA2 (++) (readFile "foo") (readFile "foo")
18:39:08 <yahb> dmwit: "barbar"
18:39:11 <ski> @type liftA
18:39:13 <lambdabot> Applicative f => (a -> b) -> f a -> f b
18:39:26 <ski> @type pure  -- "liftA0"
18:39:27 <lambdabot> Applicative f => a -> f a
18:39:31 <crick_> @type getLine
18:39:32 <lambdabot> IO String
18:39:58 <jle`> one way to think about its monoidalness is in terms of "effects" of an applicative value
18:40:17 <jle`> liftA2 etc. combines effects in an associative way with an identity
18:40:33 <jle`> so liftA2 (++) getLine (liftA2 (++) getLine getLine)
18:40:43 <crick_> jle`: Can you please start from monoids?
18:40:49 <jle`> should be the same as liftA2 (++) (liftA2 (++) getLine getLine) getLIne
18:41:07 <jle`> should be the same as liftA3 (\x y z -> x ++ y ++ z) getLine getLIne getLine
18:41:42 <crick_> Let me see the types and check for myself
18:41:44 <ski> (`liftA' is `fmap', implemented in terms of the `Applicative' operations. it can serve as an implementation of `fmap' for a type, if you already have an `Applicative' instance (not depending on `fmap' for that type))
18:41:50 <jle`> crick_: in this context, 'monoid' here is used to describe a sensible 'combination' action
18:42:00 <jle`> that is associative, and has an identity
18:42:15 <crick_> I see
18:42:42 <jle`> the intuition we get from this is things like, using <*>/liftA2 can only sequence IO actions's effects exactly once
18:42:52 <jle`> among other nice guaruntees we can make on behavior
18:43:06 <jle`> so we know that liftA2 (++) getLIne getLIne will only "get a line" twice, no more and no less
18:43:33 <jle`> if it did, it'd break the monoidal expectations of Applicative
18:43:54 <jle`> knowing that something is Applicative (and not just 'combinable') gives us some nice tools to reason with code
18:44:07 <jle`> but i suppose if you just know that Applicative lets you "combine" `f a`s, that is a good place to start
18:44:38 <crick_> Ya I just know that it lets me combine ` f a`s
18:45:21 <crick_> Where can I get some examples to practice?
18:45:24 <jle`> the real benefit is that it lets you combine f a's in a "sensible" way that lets you make conclusions/reason about the resulting f a
18:45:36 <jle`> crick_: have you looked at the Typeclassopedia?
18:45:40 <crick_> Okay
18:45:41 <jle`> they have a lot of good examples and exercises
18:45:43 <crick_> No
18:45:50 <sm> what's the status of ghc on netbsd+amd64, would anyone know ?
18:45:54 <crick_> Okay
18:46:08 <ski> @where Typeclassopedia
18:46:09 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
18:46:48 <crick_> ski: thanks
18:46:58 <xsperry> jle` those were very succinct and clear explanations. now I am curious if you can do it for monad
19:04:06 <infinisil> Stupid idea: to make haskell better for scripting, make an extension that transforms identifiers into strings if they would be invalid
19:05:05 <infinisil> >foo++bar would return "foobar" if neither a foo nor a bar is in scope
19:08:18 <geekosaur> haskperl?
19:08:46 <c_wraith> hasshell?
19:10:32 <byorgey> infinisil: that sounds truly awful =)
19:10:55 <c_wraith> also, we can then modify it so that anything that doesn't type-check is treated as a comment, so we can comment code more easily.
19:11:13 <c_wraith> we shall call it hastercal
19:12:08 <geekosaur> hasterical
19:12:32 <c_wraith> much better
19:13:09 <byorgey> interesting, note those have to reach a mutual fixpoint, since changing a not-in-scope identifier to a string could cause something to fail to typecheck, which could in turn cause things to not be in scope, etc.
19:13:19 <c_wraith> of course.
19:13:35 <geekosaur> which is where that name came from :)
19:13:52 <byorgey> I wonder if you could make a recursive definition which typechecks if and only if it is not in scope
19:14:28 <c_wraith> I don't think so.  the process feels monotonic to me.  Once something is a comment, it stays a comment.
19:14:41 <byorgey> yeah, good point
19:15:23 <byorgey> too bad.  this suggests we ought to rethink the design.
19:19:45 <techieAgnostic> can someone link me a good article for why monads are great in production code? i think i understand the idea of them but it hasnt clicked why i should use them yet
19:22:18 <jle`> techieAgnostic: i would say that 'monads are great in production code' is a backwards way to look at things.  it's more that, a lot of types are useful for production code.   and some of them happen to fit the monad interface
19:22:51 <jle`> techieAgnostic: the reason these types are useful is because ... they have useful functionality
19:22:57 <jle`> you have probably used some in the past, even
19:23:03 <jle`> if you've ever used a linked list, for example
19:23:20 <jle`> a linked list isn't useful because it's a monad... linked lists are just pretty useful in general
19:23:35 <ab9rf> is there some way in which productionc ode is different from nonproduction code that would affect the suitability of monads in such code?
19:24:16 <ab9rf> the only difference in my mind between nonproduction code and production code is that nonproduction code has typically been tested less
19:24:29 <maerwald> ab9rf: I don't get your question
19:25:04 <ab9rf> maerwald: i'm trying to wrap my head around the implied suggestion that monads are fine for nonproduction code but are not fine for production code.
19:25:26 <maerwald> that's a very weird question/statement
19:25:29 <jle`> techieAgnostic: the benefit of recognizing that some types ar emonads is that you can re-use functions that are written to work for all monads
19:25:46 <maerwald> that's not a very big advantage though
19:25:54 <maerwald> little bit over-estimated
19:25:58 <jle`> yeah, i agree
19:25:59 <techieAgnostic> ahh ok
19:26:11 <jle`> techieAgnostic: so for example in some languages you have "numeric" functions that work over all number types
19:26:18 <jle`> that's the benefit of recognizing that something is a number
19:26:25 <ab9rf> monads are themselves not necessarily good for anything
19:26:32 <c_wraith> techieAgnostic: many things form monads in many languages.  You probably use them without the slightest care.  Haskell recognizes that a pattern exists that most languages ignore.
19:26:32 <jle`> but, ints, doubles, etc. are all useful on their own
19:26:38 <ab9rf> however, there are many things--which happen to be monads--that are extremely useful
19:27:01 <ab9rf> it is also possible to define almost completely useless monads
19:27:04 <jle`> so the monad types themselves are benefit becasue of each individual type's usefulness (like lists, for example), and each type is useful for a different reason
19:27:36 <jle`> so you can see that answering "why are monads useful" is a bit of a meaningless question
19:27:42 <jle`> that's like asking "why are tools useful"
19:27:44 <ab9rf> although both Const and Identity, which don't seem useful on their face, are actually useful in certain situations
19:28:03 <blinkhard> at first i assumed the "monad in production code" question was sociological.  companies fine with FP for internal tools but not "real" use
19:28:12 <maerwald> higher-kinded types are exciting, monads are just... monads
19:29:10 <c_wraith> ab9rf: Const and Identity are the two most important types for what I think is the most compelling example of higher-kinded abstraction. :)
19:29:17 <maerwald> stop thinking about monads
19:29:34 <c_wraith> ab9rf: though..  Const isn't a Monad.
19:29:41 <ab9rf> c_wraith: well, true
19:30:17 <ab9rf> merely a lowly Functor
19:30:24 <c_wraith> It's an Applicative, too
19:30:46 <ab9rf> over a monoid
19:30:59 <ab9rf> it's also foldable and traversable, although trivially so
19:31:05 <c_wraith> Well, true.  But still useful with that constraint.
19:31:18 <maerwald> ab9rf: list monad is quite useless imo, but others may disagree
19:33:55 <techieAgnostic> hmm ok, lot to think about, think im starting to get it a bit more
19:34:09 <techieAgnostic> slowly trying to claw my way up haha
20:26:16 <cobax> could there be a connection between point-free and graphs? see: https://imgur.com/a/9BV4vSe
20:27:13 <suzu> yes
20:27:22 <suzu> in the same way that there is a connection between functions and arrows
20:27:26 <suzu> and arrows can be represented with graphs
20:27:37 <suzu> and so function composition in a point-free manner can be shown with graphs like this
20:29:04 <cobax> do you mean in it in a strong sense, i.e. I could write a function that mechanically draws a graph from a point-free representation?
20:30:31 <benzrf> cobax: you dont need it to be point-free
20:31:13 <cobax> benzrf: you're absolutely right. that's just what inspired my question
20:31:30 <benzrf> if you take the abstract syntax tree of an expression and then insert input nodes corresponding to the free variables, there's your dag :)
20:32:38 <cobax> well see, that I knew, but then I guess I must insist on the point-free aspect
20:32:48 <benzrf> well, regarding the point-free aspect
20:33:05 <cobax> turn the points into edges?
20:33:36 <benzrf> i think what you're looking for is string diagrams, w/ diagonal maps denoted by some nice fork symbol
20:34:09 <cobax> benzrf: could you give me a reference? I don't know where to start
20:34:13 <benzrf> in fact i am almost certain that's what you're thinking about
20:34:31 <benzrf> ill be back in like 5 minutes & i can talk your ear off about it then :V
20:34:42 <cobax> benzrf: take your time, thank you!
20:40:13 <zzz> Im having trouble understanding why Just(Just 7) >>= id >>= (\x -> Just(x*2)) == Just 14
20:42:41 <selfsymmetric-mu> `Just(Just 7) >>= id >>= (\x -> Just(x*2)) = Just 7 >>= Just (\x -> Just (x * 2)) = Just (7 * 2) = Just 14`
20:44:44 <selfsymmetric-mu> zzz: Here's the implementation of Monad for Maybe: http://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.Base.html#line-830
20:45:11 <selfsymmetric-mu> If you know how to substitute and pattern match, the rest works itself out.
20:45:21 <selfsymmetric-mu> Remember that `>>=` is associative.
20:45:30 <benzrf> cobax: kk back
20:45:40 <benzrf> how much category theory do you know?
20:46:22 <zzz> thanks!
20:46:24 <cobax> benzrf: you can throw some at me and I'll tell you when it starts to hurt
20:47:24 <benzrf> are you familiar with products & are you familiar with monoidal categories (sometimes also called tensor categories)
20:47:37 <cobax> I believe so
20:47:46 <benzrf> ok, cool
20:48:05 <benzrf> are you familiar with cartesian closed categories, & if so, the interpretation of the simply typed lambda calculus into them
20:48:22 <cobax> benzrf: I am aware that that relationship exists but have not seen it proven
20:48:32 <benzrf> i dunno if you'd "prove" it
20:48:38 <benzrf> it's more like a construction you make
20:49:01 <benzrf> anyway, essentially -
20:49:18 <cobax> I wouldn't be able to explain how those things map to each other
20:49:31 <cobax> is that the beginning of mapping functions to traceable, 2d things?
20:49:42 <benzrf> not exactly
20:49:53 <benzrf> actually, you don't even really need the full STLC or cartesian closure for what i'm talking about - only finite products and no need for lambda terms
20:49:57 <benzrf> well, in any case
20:51:40 <benzrf> suppose you have an STLC w/ a family T_i of basic types & a family f_j of "built-in" function names with specified types (not necessarily any reduction rules associated to them)
20:52:20 <benzrf> e.g., we could have STLC w/ one basic type Nat & some function symbols plus : Nat -> Nat -> Nat, times : Nat -> Nat -> Nat, for example
20:52:26 <cobax> ok
20:52:40 <benzrf> now suppose we have some cartesian closed category C
20:52:48 <zzz> selfsymmetric-mu: wait if `(Just x) >>= k = k x` shouldn't `(Just 7) >>= id = id 7` ?
20:53:22 <cobax> benzrf: ok
20:53:49 <monochrom> > Just(Just 7) >>= id >>= (\x -> Just(x*2))
20:53:49 <selfsymmetric-mu> zzz: Quite right. Note however that your left-hand side is `Just (Just 7)`.
20:53:50 <MarcelineVQ> zzz: not when you consider the type signature for >>=
20:53:51 <lambdabot>  Just 14
20:54:19 <monochrom> > Just 7 >>= id
20:54:21 <lambdabot>  error:
20:54:21 <lambdabot>      • No instance for (Num (Maybe ())) arising from a use of ‘e_17’
20:54:21 <lambdabot>      • In the expression: e_17
20:54:21 <selfsymmetric-mu> So `Just (Just 7) >>= id (Just 7) = Just 7`
20:54:35 <eiGHttt> > Just 7 >>= return . id
20:54:37 <lambdabot>  Just 7
20:54:53 <selfsymmetric-mu> > Just (Just 7) >>= id
20:54:55 <lambdabot>  Just 7
20:55:05 <zzz> MarcelineVQ: ah, the missing piece. that solves it thanks
20:55:38 <benzrf> let's additionally start out with a mapping from our family of basic types to objects of C. we extend this mapping to all types in the obvious way
20:56:11 <cobax> benzrf: sure
20:56:48 <benzrf> and as a final parameter, we choose for each "built-in" c : T a global element of |T| (where |T| is the object for the type T)
20:56:55 <benzrf> (a global element is a morphism 1 -> T)
20:57:46 <cobax> so a way of acquiring some T ?
20:57:56 <benzrf> i guess!
20:58:05 <cobax> ok
20:58:16 <benzrf> so: given these data, we'll provide an interpretation of arbitrary STLC terms as morphisms in the category
20:58:37 <benzrf> this turns out to be essentially point-free translation!
20:58:44 <benzrf> well, kind of
20:59:23 <cobax> I'm thinking
20:59:56 <benzrf> say Gamma is some typing context; let |Gamma| be the product of the objects for the types in Gamma (so for example we have |x : Nat, f : Nat -> Nat| = |Nat| × [|Nat|, |Nat|] )
21:00:08 <benzrf> (where [A, B] is the exponential B^A)
21:00:35 <cobax> yes I'm with you in that correspondence
21:00:38 <benzrf> :)
21:01:15 <benzrf> then we'll map judgments "Gamma |- t : T" to morphisms |t| : |Gamma| -> |T|
21:01:34 <benzrf> so the free variables provide the domain of the morphism and the codomain is the type of the term
21:02:02 <benzrf> this is done by simple structural recursion
21:02:25 <benzrf> for built-ins, we use our initially-assumed choice of interpretation
21:02:32 <benzrf> er, not quite
21:03:35 <benzrf> for "Gamma |- c : T" with c a "built-in", we have to compose the terminal morphism |Gamma| -> 1 with the global element 1 -> |T|
21:04:29 <cobax> could you explain exactly the help that the global element is providing here?
21:04:31 <benzrf> ("constant morphism" is sometimes defined to mean a morphism that factors thru 1)
21:04:58 <benzrf> cobax: the global element is our choice of interpretation for c
21:05:14 <benzrf> lemme go back and give an example
21:05:49 <benzrf> in the above example w/ Nat, plus, times - suppose we pick C to be Set and |Nat| to be N
21:06:11 <cobax> ok, to make it easy
21:06:15 <benzrf> :)
21:06:41 <benzrf> let's also say that we have zero : Nat and succ : Nat -> Nat as builtins
21:07:03 <cobax> without axioms we can't move
21:07:13 <benzrf> now to implement each builtin we pick a global element of the object for its type
21:07:50 <benzrf> our implementation of zero should be something 1 -> |Nat| = 1 -> N
21:08:07 <benzrf> our implementation of plus should be something 1 -> |Nat -> Nat -> Nat| = 1 -> [N, [N, N]]
21:08:49 <benzrf> (this is getting off topic, you wanna move it to ##math or something)
22:31:41 <crick_> Is there a type of kind * -> * which cannot be made an instance of functor?
22:32:07 <cocreature> crick_: newtype Pred a = Pred (a -> Bool)
22:33:57 <crick_> cocreature: can you explain a bit?
22:34:10 <monochrom> newtype USEconomy a = Ctor (a -> USEconomy a)
22:34:51 <cocreature> crick_: try making an instance, you’ll probably see the problem yourself :) if you don’t, I’m happy to explain it but it’s usually more enlightening to discover it yourself
22:47:46 <dyl> :t fmap
22:47:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:56:34 <dminuoso> dmwit: Sorry for the late response, was on a train trip and wifi connection dropped out.
22:57:34 <kc3> hi, i'm very new to haskell but i'm wanting to write a terminal program for fun
22:57:56 <kc3> i'm wondering what kind of references i should be looking at as i have no idea where to start
22:58:31 <kc3> basically, i want to create a game in the terminal where the terminal screen is updated.
22:58:48 <glguy> The vty package is a good place to start
22:58:48 <eiGHttt> brick?
22:59:05 <kc3> vty, brick. ok i'll take a look
22:59:25 <glguy> https://github.com/glguy/quarto
22:59:45 <glguy> I've got a bunch of vty based terminal programs on my GitHub
22:59:56 <glguy> A more complex example is my IRC client
22:59:57 <shiona_> my first haskell terminal game was in brick. It does similar things to ncurses, but in more haskell esque way
23:00:29 <glguy> Brick adds another later on vty you might need as things get complicated
23:01:12 <glguy> https://github.com/glguy/set-game
23:02:08 <glguy> https://github.com/glguy/irc-core
23:02:24 <kc3> ok, cool. i'll definitely take a look at both.
23:02:40 <kc3> brick looks like it's something i was really after
23:02:53 <kc3> says define a drawing function and input that interupts.
23:02:59 <shiona_> https://github.com/shiona/spede/ this is my first TUI game in haskell. It uses brick, but the code is probably pretty bad.
23:03:00 <kc3> exactly what i was after pretty much
23:03:36 <kc3> i'm no one to judge, i wrote a function in haskell about 5 minutes ago for the first time
23:04:00 <kc3> coming from a elixir background though, so it shouldn't be too rough.
23:06:06 <shiona_> I wish you luck. It took me about 7 years of haskell before I made that.
23:07:05 <kc3> thanks, the key is persistance :) cheers!
23:10:37 * dminuoso chuckles as he thinks about how different elixir is
23:12:53 <systemfault> Elixir might just be close to JavaScript than Haskell :/
23:12:58 <systemfault> *closer
23:14:51 <dminuoso> I used to think elixir was pretty functional until I finally grasped what functional programming was about: capturing as many semantics of the language as possible with first-class functions.
23:15:03 <dyl> Me: I should sleep early. 
23:15:08 <dyl> Also me: I should grill salmon 
23:15:35 <dyl> Salmon and FP papers 👌 
23:15:43 <opqdonut> dminuoso: what does that even mean?
23:16:26 <dminuoso> opqdonut: Consider how say C++ gives us sequentiality of statements with (;) - but we can't capture that semicolon as a first-class value, pass it around in functions and use it somehow.
23:16:38 <opqdonut> right
23:16:56 <opqdonut> ok now I see what you mean
23:17:17 <opqdonut> but these things you're capturing with functions aren't semantics of the language, they're libraries, right?
23:17:20 <opqdonut> e.g. Monads
23:17:47 <dminuoso> opqdonut: We dont require them to be semantics of the language because a user can just create them on the spot.
23:18:10 <opqdonut> yeah
23:18:16 <dminuoso> opqdonut: In the case of Haskell they are part of the language since the report defines IO together with instances for Functor/Applicative/Monad
23:18:29 <opqdonut> right ok IO is magical
23:19:58 <jedws> no, not magical, just a value
23:20:16 <opqdonut> magical in the sense that you couldn't've defined it yourself
23:20:28 <jedws> absolutely you can define it yourself
23:20:36 <opqdonut> not with Haskell2010
23:20:44 <opqdonut> unlike most of the other base stuff specified in the report
23:21:24 <dminuoso> opqdonut: ultimately this comes at a price - having this "programmable semicolon" (>>=) means you need a lot of utility functions to make use of this.
23:21:38 <dminuoso> This is partially why juryrigging Monad into other languages usually falls so incredibly short.
23:21:47 <jedws> there is nothing special about IO, you only need to be able to call some FFI directly
23:22:09 <opqdonut> dminuoso: indeed
23:23:05 <opqdonut> also, you need a surprisingly powerful type system to make use of the Monad abstraction: parametric polymorphism, higher-kinded type-classes
23:23:12 <jedws> wait what? you only need higher kinded types, which most langs don't have
23:23:16 <dminuoso> Well you dont actually need a type system to make use of it.
23:23:32 <opqdonut> it's kinda hard to define generic Monad operations
23:23:37 <opqdonut> but I guess you can live without those?
23:23:38 <jedws> ok, parametric polymorphism is entry ticket for higher kinded types
23:23:46 <nineonine> hello
23:23:54 <nineonine> i have a question about existentials
23:23:58 <nineonine> lets say i have this type
23:24:00 <nineonine> data ReportEntity = forall a. Ord a => ReportEntity a
23:24:07 <nineonine> how can I give it Ord instance ?
23:24:11 <dminuoso> opqdonut: You absolutely can - but suddenly diagnostics become useless. Try using monads in JavaScript (there's a couple implementations) - it's an absolute pain in the ass
23:24:13 <opqdonut> jedws: sure yeah, FFI is a more powerful primitive than IO in that sense, but I don't think the report specifies FFI either
23:24:24 <opqdonut> dminuoso: right, I haven't tried
23:24:32 <cocreature> nineonine: you can’t. if you have two values of type ReportEntity you don’t know that the "a" is the same for both values
23:24:37 <cocreature> so the Ord instance is entirely useless
23:24:59 <nineonine> ok got it
23:25:45 <nineonine> thanks
23:25:54 <jedws> opqdonut https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008
23:25:54 <dminuoso> opqdonut: Generally I'd say functional programming without a sufficient type system wastes too much time chasing down ominous errors like "null is not a function" in JS that are thrown deep inside libraries.
23:25:59 <dminuoso> Just because you mis-composed functions.
23:26:08 <cocreature> nineonine: generally, existentials are something that I would recommend that you try to avoid, especially if you’re somewhat new to Haskell
23:26:20 <nineonine> fair enough
23:26:21 <cocreature> there are some legitimate usecases but they’re fairly rare
23:26:21 <dminuoso> Though one might argue the same holds true for *any* programming style.
23:26:32 <cocreature> and very often they do not behave like people expect them to
23:26:34 <nineonine> I am trying to generalize my progress report but having trouble doing that
23:26:44 <nineonine> I will sketch the problem and come back in 5 mins
23:27:15 <opqdonut> jedws: oh okay!
23:28:39 <opqdonut> jedws: hmm, the report does define FFI in terms of IO actually...
23:29:00 <dminuoso> opqdonut: It kind of has to.
23:29:30 <opqdonut> yeah it definitely makes sense
23:29:30 <MarcelineVQ> funny question, not related to anything, but if haskell made you outrageously wealthy beyond the means of any reasonable metric, how would you give back?
23:29:41 <jedws> sure, so it privileges IO for side-effects, but you can define your own IO types using non-referentially transparent FFI calls
23:29:49 <opqdonut> but you could specify an "unsafePerformIO" style of FFI and then use that to build IO
23:29:52 <jedws> poor so
23:29:57 <opqdonut> yeah
23:29:59 <dminuoso> MarcelineVQ: Tooling.
23:30:22 <dminuoso> MarcelineVQ: Finance a work group to work on proper editor integration that doesn't make you rage every time you fire up intero.
23:30:30 <cocreature> MarcelineVQ: hire people to work fulltime on infrastructure projects, e.g., ghc, cabal, hackage, …
23:31:53 <jedws> MarcelineVQ fund an FP education effort, sponsor ICFP or any of a bunch of conferences, fund diversity in FP efforts
23:31:55 <dminuoso> Does Roman Cheplyaka hang around on freenode or some other IRC network?
23:32:34 <cocreature> dminuoso: I vaguely recall seeing him here but only very rarely so email or twitter is probably a better option if you want to contact him
23:37:23 <dyl> MarcelineVQ: I would help Haskell avoid success at all costs. 
23:40:32 <dminuoso> Wow! I love gmail: The address <...@foo.bar.> is invalid.
23:40:54 <opqdonut> hmph
23:41:29 <dminuoso> That dot at the end should be valid, should it not?
23:41:44 <opqdonut> yes
23:41:46 <nineonine> alright I am back
23:41:56 <nineonine> I hope someone could help me sovle this type riddle
23:41:57 <nineonine> https://lpaste.net/7270564086557966336
23:42:38 <dminuoso> Actually wow, TIL. It seems not
23:42:47 <opqdonut> yeah
23:42:50 <opqdonut> just checked the RFC!
23:42:52 <opqdonut> https://www.w3.org/Protocols/rfc822/#z8
23:42:58 <opqdonut> domain      =  sub-domain *("." sub-domain)
23:43:01 <dminuoso> dot-atom        =       [CFWS] dot-atom-text [CFWS]
23:43:04 <dminuoso> dot-atom-text   =       1*atext *("." 1*atext)
23:43:15 <opqdonut> oh right there's probably a fresher rfc too...
23:43:33 <hc> dminuoso: what does TIL mean?
23:44:14 <opqdonut> hc: Today I Learned
23:44:17 <geekosaur> trailing dot is a hack for unix resolvers, not part of any standard; it prevents searching the domain path. since email addresses never search the domain path, it's never useful there
23:44:18 <hc> oh, ok. :)
23:44:30 <hc> thanks, TIL
23:44:48 <geekosaur> alsoprevents adding the default domain
23:45:21 <dminuoso> geekosaur: Are you really sure about that? I thought the rfc for domain names specifically game domain names that ended in a dot a specific meaning in fact.
23:45:47 <nineonine> was my problem statement good enough? please let me know if unclear!
23:46:02 <nineonine> spent the whole day on that still no luck :\
23:46:17 <dminuoso> geekosaur: According to RFC1034 a domain name ending with a full stop is a so-called absolute (that is complete) domain name
23:46:31 <MarcelineVQ> nineonine: since that compiles, what are you trying that's causing an error?
23:46:47 <geekosaur> nineonine, the forall is local to the 'type' declaration, it can never match a type coming from outside of it 
23:47:06 <nineonine> it doesnt complile
23:47:08 <dminuoso> geekosaur: And RFC1035 repeats that, so..
23:47:09 <geekosaur> it must be a parameter for it to unify
23:47:17 <opqdonut> nineonine: what's ProgressPerDataSet?
23:47:28 <opqdonut> nineonine: also, have you considered making entity a type parameter of ProgressReportMessage?
23:47:32 <nineonine> just a tuple with some data
23:47:37 <nineonine> dont think it is relevant here
23:47:58 <opqdonut> nineonine: (and also as a parameter for ProgressReport)
23:48:20 <MarcelineVQ> what you have written compiles for me with dummies in for BatchInfo and ProgressPerDataSet    so if it doesn't compile for you you should include those
23:48:48 <geekosaur> dminuoso, it may have changed at some point. it used to be a compatibility issue with non-unix, they may have standardized it
23:50:31 <geekosaur> (because there were OSes where you couldn't stop the DNS component from appending the local domain, and trailing dot would throw an error because "the rfc didn't specify that")
23:52:37 <dminuoso> geekosaur: That's quite interesting, Ill dig a bit further to get further behind this. Thank you. :)
23:52:56 <geekosaur> (I think it was VMS, so they've had plenty of time to rethink things :)
23:53:50 <geekosaur> in any case, while we refer to that component of an email address as a domain name, technically it's not from the standpoint of DNS. go look at MX records
23:58:44 <geekosaur> (some historical cruft there too, at least at one point the standard required that an email domain always resolve to an MX record but directly connected machines almost never had them, so mail systems did a fallback to A record if there was no MX. these days that use case is somewhat rare)
