00:04:17 <doc_> cocreature: still it shows the same error https://pastebin.com/bjFfwvsz
00:05:35 <cocreature> doc_: please show us the error it is showing you now
00:09:10 <doc_> cocreature: thanks a lot it works  :) (my bad it was showing same error for different my type :()
00:09:31 <cocreature> np :)
00:27:27 --- mode: glguy set +v arpl1
00:30:50 <arpl1> Is there (or has there been) a Haskell compiler (or interpreter) hosted on DOS (16 or 32 bit)?
00:30:50 <arpl1> Likewise, does there exist (current or defunct) a Haskell compiler capable of producing 16 or 32 bit DOS executables?
00:35:08 <teto> I gave up on using nix or cabal with haskell, both generate an endless sequence of package conflicts/compilation error. stack + LTS seem exactly like what I need but the LTS is a subset of hackage ? LTS 12.6 doesn't contain https://hackage.haskell.org/package/netlink which I need. Can I make it available through stack.yaml ?
00:35:37 <cocreature> teto: yes, add the package to extra-deps
00:35:37 <koz_> teto: Yes.
00:35:47 <koz_> cocreature: I think I owe you a soda. :P
00:36:11 <teto> I wish there were some kind of lts in nixpkgs, seems like a dump hackage right now ?!
00:36:25 <cocreature> koz_: hm?
00:36:35 <koz_> cocreature: We said the same thing simultaneously.
00:36:38 <koz_> Thus, I owe you a soda.
00:36:55 <koz_> (well, not simultaneously - you beat me to it, just)
00:36:56 <teto> if anyone I owe you sodas :p
00:37:06 <koz_> teto: Cherry would be best.
00:37:18 <cocreature> teto: nixpkgs is based on stackage lts for packages that are in lts but also adds packages not in lts
00:37:20 <MarcelineVQ> well you hit jinx, whether a soda is involved depends on your area
00:37:43 <Ariakenom> culture is like different, dude
00:37:46 <cocreature> there are also tools like stack2nix that generate nix configs from a stack.yaml file
00:37:50 <MarcelineVQ> teto: are you on arch?
00:38:07 <teto> MarcelineVQ: nope on nixos-unstable
00:38:23 <koz_> MarcelineVQ: I got the soda thing from jle I think.
00:38:47 <MarcelineVQ> oh my, jle is from the moon don't trust him
00:39:41 <koz_> I didn't realize jle was a moon person.
00:39:43 <MarcelineVQ> you know how those cheese people are, with their waterless seas, and lunacy
00:40:03 <koz_> MarcelineVQ: From what I can tell, also very good at Haskell blog posts.
00:40:20 <MarcelineVQ> Oh sure, he's quite reliable
00:40:25 <koz_> Does that make Edward king of the moon people?
01:15:45 <ClaudiusMaximus> @hoogle liftST
01:15:46 <lambdabot> Control.Arrow.IOStateListArrow liftSt :: IOSLA s1 b c -> IOSLA (s1, s2) b c
01:15:46 <lambdabot> Control.Monad.ST.Trans.Internal liftST :: Applicative m => ST s a -> STT s m a
01:15:46 <lambdabot> Language.Haskell.TH.Syntax liftString :: String -> Q Exp
01:18:17 <ClaudiusMaximus> @hoogle MonadST
01:18:17 <lambdabot> Control.Monad.State.Class class Monad m => MonadState s m | m -> s
01:18:17 <lambdabot> Control.Monad.State.Lazy class Monad m => MonadState s m | m -> s
01:18:17 <lambdabot> Control.Monad.State.Strict class Monad m => MonadState s m | m -> s
01:19:22 <ClaudiusMaximus> is there nothing like liftIO but for ST?
01:19:47 <dminuoso> ClaudiusMaximus: what would it lift?
01:21:48 <ClaudiusMaximus> i want to use a monad transformer stack with ST s at the base, i can predict it getting boring remembering how many lift to write to call the ST s actions
01:24:20 <dminuoso> Interesting, is that even safe?
01:24:27 <dminuoso> A state transformer around ST that is.
01:24:31 <dminuoso> A *monad transformer
01:25:05 <ClaudiusMaximus> i don't know
01:25:34 <ClaudiusMaximus> the STT transformer is full of warnings about unsafety
01:27:37 <mniip> STT is about as unsafe as IOT
01:27:49 <mniip> a monad transformer with ST at the base is perfectly safe
01:27:56 <cocreature> ClaudiusMaximus: aybe you are looking for PrimMonad?
01:28:32 <dminuoso> mniip: Ah so IOT would be something that might produce say.. `Maybe IO` for `IOT Maybe`?
01:28:50 <mniip> @hackage acme-iot
01:28:50 <lambdabot> http://hackage.haskell.org/package/acme-iot
01:29:22 <dminuoso> mniip: Lovely. Is that production ready?
01:29:41 <dminuoso> Says "Sability none"
01:33:26 <ClaudiusMaximus> cocreature: possibly!
01:35:58 <arpl1> Is there (or has there been) a Haskell compiler (or interpreter) hosted on DOS (16 or 32 bit)?
01:35:58 <arpl1> Likewise, does there exist (current or defunct) a Haskell compiler capable of producing 16 or 32 bit DOS executables?
01:38:18 <int-e> arpl1: https://www.haskell.org/hugs/pages/hugsman/started.html <-- Hugs appparently supported DOS.
01:38:25 <int-e> (it's an interpreter though)
01:40:40 <int-e> arpl1: oh there's https://wiki.haskell.org/Implementations ... but DOS is only mentioned for Hugs.
01:41:54 <int-e> (Tbh, I wouldn't seriously consider running Haskell on a 16 bit platform... you'll have to be very careful when programming or you'll be running out of heap all the time.)
01:43:00 <mniip> only if your heap pointers are all near
01:43:55 <int-e> which, in this case, they are.
01:44:14 <int-e> but hopefully you get two 64kb semispaces at least :)
01:45:13 <mniip> I mean normally C is "the portable" language, but once you consider the problems of a C runtime on 8086...
01:45:34 <mniip> should void* be a near or a far pointer? what about void (*)()
01:46:22 <int-e> Well, I guess Hugs was used for teaching in the 90s... so somebody hacked DOS support into Hugs so that students could play with toy programs at home.
01:46:42 <MarcelineVQ> haha, /join #agda
01:46:42 <pgiarrusso> It’s more portable than assembler, and you *can* write code working in multiple platforms with enough effort, but that’s it
01:46:58 <MarcelineVQ> woops, had text left in buffer :X
01:52:04 <arpl1> Yes, I have seen Hugs once supported DOS but could only find a Windows version. I completely understand the limitations, was mainly looking at the DOS version as a ´scripting engine´ to glue scripts together. (Ran into some limitations with 4DOS.) And yes, some people still run DOS : ) [And DesqView!]
01:54:15 <mniip> arpl1, lua might be more fitting
01:54:25 <mniip> what not with less memory footprint and implementation size
02:00:47 <arpl1> Or Forth. But for this I was only looking if there was something Haskelly available for the DOS platform. (Just like I will be looking at HaLVM [Haskell on Xen].)
02:04:43 * hackage haskell-postal 0.2.1.2 - Haskell binding for the libpostal library  http://hackage.haskell.org/package/haskell-postal-0.2.1.2 (netom)
02:11:09 <lavalike> arpl1: wow never heard of DesqView before, cool program
02:13:43 <ArahaelPi> arpl1: I'm terribly new to the fp scene, but I'd wonder...  Maybe pure11 -> C++?
02:15:18 <iphy> if I have something like "contents <- mapM readFile filenames", what's the best way to make "contents" be a list of pairs (filename, contents)?
02:15:48 <iphy> something like ((return . id) &&& readFile), but correct :)
02:16:11 <Ariakenom> zip filenames contents
02:16:31 <Ariakenom> :p
02:16:48 <simon> iphy, define best?
02:17:00 <iphy> Ariakenom: hm, maybe
02:17:10 <iphy> simon: it's a matter of taste, I'm mostly asking for opinions
02:17:13 <iphy> how would you write it?
02:17:59 <Ariakenom> could maybe do something like traverse (\f -> readFile f >>= (f,)) filenames
02:18:10 <Ariakenom> :t traverse
02:18:11 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
02:18:29 <Ariakenom> :t (1,)
02:18:30 <lambdabot> Num t1 => t2 -> (t1, t2)
02:19:39 <Ariakenom> :t mapM
02:19:40 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
02:21:35 <lavalike> :t mapAndUnzipM (liftM2 fmap (,) readFile)
02:21:37 <lambdabot> [FilePath] -> IO ([FilePath], [String])
02:21:41 <lavalike> \o/
02:22:30 <lavalike> oops, just mapM
02:22:40 <lavalike> :t mapM (liftM2 fmap (,) readFile)
02:22:41 <lambdabot> Traversable t => t FilePath -> IO (t (FilePath, String))
02:22:52 <lavalike> got carried away (:
02:24:18 <lavalike> :t mapM (fmap <$> (,) <*> readFile)
02:24:19 <lambdabot> Traversable t => t FilePath -> IO (t (FilePath, String))
02:25:57 <Ariakenom> how pointless
02:28:19 <simon> iphy, I'd probably write it like https://gist.github.com/sshine/c90fa8ec574c12fa57b9dd224525d559
02:28:25 <Ariakenom> :t liftA2 fmap
02:28:26 <lambdabot> (Functor f2, Applicative f1) => f1 (a -> b) -> f1 (f2 a) -> f1 (f2 b)
02:29:44 <Ariakenom> pure evil, I like it
02:29:53 <lavalike> ^_^
02:30:03 <iphy> simon: LGTM
02:30:21 <lavalike> iphy: no love for mapM (liftM2 fmap (,) readFile)
02:30:32 <iphy> :)
02:31:21 <iphy> I like it, but I'll go with the more verbose version
02:32:06 <sshine> iphy, I might've gone for filePair filePath = readFile filePath >>= return . (filePath,), but I don't think I'd try to golf it any shorter. :)
02:32:13 * hackage hyraxAbif 0.2.3.10 - Modules for parsing, generating and manipulating AB1 files.  http://hackage.haskell.org/package/hyraxAbif-0.2.3.10 (andrevdm)
02:33:08 <lavalike> see, >>= return . is where fmap comes from
02:33:09 <iphy> needs TupleSections?
02:33:12 <merijn> Amateurs!
02:33:41 <merijn> :t runKleisli . (return &&& readFile)
02:33:43 <lambdabot> error:
02:33:43 <lambdabot>     • Couldn't match type ‘(m0 FilePath, IO String)’
02:33:43 <lambdabot>                      with ‘Kleisli m a b’
02:33:56 <arpl1> lavalike: Yes, it made very good use of the 386 (v86 mode) in particular in conjunction with QEMM-386 (both by Quarterdeck).
02:33:56 <arpl1> I like to keep old computer technology running. So I will list a couple of things here now that I still use and maybe you will see some other things from ´days gone by´ that you find interesting: Still run OS/2 (and eCS) and BeOS (Zeta/Haiku) as operating systems. 
02:33:56 <arpl1> We are here now in ´upper´ Haskell-land. Maybe check out MASM (or MASM32 or Randall Hyde´s HLA) to see where we come from in the ´nether regions´?
02:33:59 <merijn> oh, wait
02:34:02 <lavalike> merijn: runs onto the stage but falls flat on his face
02:34:09 <Taneb> :t runKleisli . (id &&& Kleisli readFile)
02:34:10 <merijn> :t runKleisli . (Kleisli return &&& Kleisli readFile)
02:34:11 <lambdabot> error:
02:34:11 <lambdabot>     • Couldn't match expected type ‘Kleisli IO FilePath c0’
02:34:11 <lambdabot>                   with actual type ‘a0 -> a0’
02:34:11 <lambdabot> error:
02:34:12 <lambdabot>     • Couldn't match expected type ‘a -> Kleisli m a1 b’
02:34:13 <lambdabot>                   with actual type ‘Kleisli IO FilePath (FilePath, String)’
02:34:26 <Ariakenom> iphy: what about zip filenames contents then?
02:34:27 <Taneb> :t runKleisli (Kleisli return &&& Kleisli readFile)
02:34:29 <lambdabot> FilePath -> IO (FilePath, String)
02:34:30 <merijn> lavalike: Stupid newtype nonsense
02:34:33 <lavalike> ^_^
02:34:40 <lavalike> beautiful!
02:34:42 <iphy> Ariakenom: contents <- zip sources <$> mapM readFile sources
02:34:44 <iphy> not too bad
02:34:45 <merijn> Taneb: Ah, damn, that was gonna be my initial, but though I had to compose
02:34:47 <arpl1> ArahaelPi: Hmmmm, C++? Don´t think I will ever return there.
02:34:57 <iphy> I didn't like the fact that it's only dynamically correct
02:35:00 <Ariakenom> XImplicitCoerce?
02:35:03 <iphy> it's not correct by construction
02:35:11 <merijn> Taneb: Might actually be able to abuse Coercible to get it simpler still
02:35:16 <sshine> iphy, ok, so I might golf it down to: mapM (\filePath -> readFile filePath >>= fmap (filePath,)) -- (thanks, lavalike)
02:35:39 <lavalike> I like the zip <$> version a lot
02:36:12 <sshine> lavalike, yeah, I like it also. I think it's an old strict-evaluation mindset that makes me like to map once.
02:36:25 <Ariakenom> I was thinking do {contents <- mapM readFile filenames; let files = zip filenames contents}
02:36:26 <iphy> sshine: it's not the strict evaluation for me
02:36:36 <sshine> iphy, you mean there are other reasons you like mapM?
02:36:42 <iphy> it's the wish for correct-by-construction
02:36:47 <sshine> iphy, oh, the correctness thing.
02:36:58 <sshine> iphy, right. I guess I don't like zip for that reason.
02:37:10 <lavalike> what's incorrect about it?
02:37:15 <iphy> it's dynamically correct
02:37:23 <sshine> every time I use zip, I think "but are the lists even length?" -- incidentally, you don't *have* to think that here, but I still do. :D
02:37:23 <lavalike> say what
02:37:35 <iphy> lavalike: it's arguably correct (and in fact it is correct)
02:38:01 <sshine> iphy, it is provably correct because you're zipping something with a map of that something.
02:38:05 <iphy> but it's only incidentally correct because sources == sources
02:38:21 <iphy> sshine: yes, provably, but not by construction
02:38:54 --- mode: glguy set +v cdupont
02:39:35 <lavalike> :t Kleisli
02:39:36 <lambdabot> (a -> m b) -> Kleisli m a b
02:39:51 <cdupont> I come here once again to ask enlighten me on the misteries of Haskell :)
02:40:03 <lavalike> howdy!
02:40:15 <lavalike> may you reach enlightenment
02:40:19 <sshine> cdupont, Haskell is very misty!
02:40:25 <cdupont> Thank you!
02:40:49 <merijn> lavalike: Kleisli composition is basically "(.), but for 'a -> m b'"
02:41:03 <cdupont> I try to decode some JSON. The JSON has optional fields
02:41:29 <cdupont> such as: {foo: ["bar"]}
02:41:42 <cdupont> foo is optional and might not appear at all
02:42:16 <cdupont> Generic FromJSON decodes it as Maybe [Text]
02:42:32 <merijn> lavalike: More specifically, there's a generalisation of (.) in Control.Category which has "class Categoy c where id :: c a a; (.) :: c y z -> c x y -> c x z" the simplest Haskell version of which is obviously "instance Category (->)", but we also have "instance Mond m => Category (Kleisli m)" which has >=> as (.) and return as id
02:42:36 <cdupont> But I'd prefer just a list: [Text]
02:42:48 <ArahaelPi> arpl1: I mean, as a compiler target.
02:42:58 <iphy> cdupont: I think you'll need to define your own non-Generic decoder then
02:43:10 <lavalike> merijn: this is what surprised me
02:43:12 <lavalike> :t Kleisli return &&& Kleisli readFile
02:43:13 <lambdabot> Kleisli IO FilePath (FilePath, String)
02:43:25 <lavalike> I'm used to think (&&&) is for tuples (:
02:43:40 <sshine> lavalike, tuples are the only arrows I understand, too. :D
02:43:54 <merijn> lavalike: It's for Arrow, which are closely related to Category
02:43:58 <merijn> :t (&&&)
02:44:00 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
02:44:08 <lavalike> reads very well
02:44:14 <cdupont> I tried to write the instance: parseJSON (Object v) = Buz  <$> v .:? "foo"
02:44:14 <sshine> I basically can't read that without concretizing it for tuples.
02:44:32 <cdupont> But I'm not sure how to conflate the Maybe and the list
02:44:33 <iphy> sshine: a b c :) totally makes sense, right?
02:44:35 <merijn> lavalike: Basically, most (all?) things that are Arrow instances are also Category instances
02:44:59 <lavalike> sshine: I think it works out but it wouldn't have occurred to me, you see b->c b->c' => b->(c,c')
02:44:59 <merijn> lavalike: So we can just use "instance Monad m => Arrow (Kleisli m)"
02:45:33 <merijn> lavalike: People normally (ab)use (&&&) with the (->) Arrow instance
02:45:34 <lavalike> that is exactly the instance I wasn't familiar with
02:45:36 <sshine> iphy, it does read like a b c. ;-D the confusing part to me is a's kind.
02:45:50 <lavalike> 'a' is ->, the 'a'rrow :D
02:45:54 <merijn> sshine: "a :: * -> * -> *"
02:45:55 <cdupont>  v .:? "foo" will return a Maybe [a]
02:46:08 <lavalike> (->) b c, if you will
02:46:11 <cdupont> How to make it return just a list?
02:46:21 <sshine> lavalike, ok!
02:46:39 <cdupont> empty list is OK if the JSON field is absent
02:46:43 <merijn> cdupont: "fromMaybe [] id"?
02:46:49 <merijn> :t fromMaybe [] id
02:46:50 <lambdabot> error:
02:46:50 <lambdabot>     • Couldn't match expected type ‘Maybe [a]’
02:46:50 <lambdabot>                   with actual type ‘a0 -> a0’
02:46:57 <merijn> oh, wait, duh
02:46:59 <merijn> :t fromMaybe []
02:47:01 <lambdabot> Maybe [a] -> [a]
02:48:33 <cdupont> merijn I'm not sure how to incluude that in the Applicative parser (with <$> and <*>)
02:49:25 <cdupont> instance FromJSON Foo where
02:49:25 <cdupont>    parseJSON (Object v) = Foo <$>
02:49:25 <cdupont>                             v .: "a" <*>
02:49:25 <cdupont>                             v .: "b" <*>
02:49:25 <cdupont>                             v .:? "bar"
02:50:45 <merijn> cdupont: You have 'v .:? "bar" :: Parser (Maybe [a])', yes?
02:51:23 <cdupont> yes
02:52:26 <merijn> cdupont: Right, so "fromMaybe [] :: Maybe [a] -> [a]", which gives
02:52:31 <merijn> :t fmap (fromMaybe [])
02:52:32 <lambdabot> Functor f => f (Maybe [a]) -> f [a]
02:52:44 <cdupont> mmh
02:52:55 <cdupont> So I have to use <$> :)
02:53:21 <merijn> So You can just do: ((fromMaybe []) <$> (v .:? "bar")) (probably wanna introduce some local binding to clean that up
02:53:55 <cdupont> merijn: that works, thank you so much
03:02:40 <thorsten`> If in a state monad my state is a finite list, how can I perform some action on each of it? I.e. something of type: Monad m => StateT a m r -> StateT [a] m [r]
03:08:47 <Taneb> :t zoom traverse
03:08:49 <lambdabot> (Applicative (Zoomed m c), Traversable t, Zoom m n s (t s)) => m c -> n c
03:09:08 <Taneb> That's... not what you want
03:09:21 <Taneb> thorsten`: there's not an easy way to do that, as far as I know
03:10:08 <thorsten`> okey, thanks! Then I'll build it manually using runState etc.
03:27:47 <thorsten`> here it is: http://thorsten-wissmann.de/p/f1f7c0c860f61f34d34746f8ed23dde3 -- is there a way to replace lists by Traversable here?
03:32:58 --- mode: ChanServ set +o Sigyn
03:56:44 --- mode: glguy set +v duairc
03:56:46 <thorsten`> yes: i only need to replace unzip by unfzip, e.g. https://hackage.haskell.org/package/category-extras-0.52.1/docs/Control-Functor-Zip.html
03:58:43 --- mode: glguy set -v duairc
04:00:05 <duairc> How do I get the tarball generated by cabal sdist to include include-dirs?
04:01:55 <merijn> duairc: List the header files as extra-source-files
04:02:24 <merijn> duairc: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/benchmark-analysis.cabal#L27
04:03:13 <duairc> merijn: Perfect, thanks! 
04:03:41 <merijn> duairc: At least, I'm *pretty* that's what's fixed my problems :p
04:04:39 <Myrl-saki> merijn: I think you a word? :P
04:05:15 <merijn> Myrl-saki: It's all in your mind *handwave*
04:06:59 <Ariakenom> At least I'm *pretty*. That's what's fixed my problems :p
04:07:10 <Ariakenom> LGTM
04:07:11 <Taneb> Has anyone ever tried running hpc using nix?
04:09:16 <hpc> has hpc ever tried to run nix?
04:10:17 <maerwald> Has anyone ever tried running <pkg> using <some-other-random-distro-pm>
04:10:26 <liste> at least nobody's using hpc
04:10:36 <hpc> i am not a package, i am a free man!
04:10:47 <maerwald> you're my little package :P
04:10:50 <hpc> https://www.youtube.com/watch?v=Sv813f2Xtrg
04:11:04 <Ariakenom> is hpc broken for anyone else?
04:12:37 <Taneb> hpc: I'm afraid I was asking about the program coverage tool
04:15:23 <Taneb> maerwald: hpc is part of GHC, not just some random package
04:16:13 --- mode: glguy set -v Ferdirand
04:18:38 <maerwald> didn't say it's random
04:19:10 <barrucadu> Taneb: I've run hpc on nixos, although via `stack --nix hpc` which does who-knows-what to the environment
04:20:15 <Taneb> barrucadu: end goal of this is to integrate it into our CI
04:20:42 <Taneb> I'm just experimenting with it right now
04:22:14 <Taneb> Following the instructions for Hpc with a Cabal project here: https://wiki.haskell.org/Haskell_program_coverage#Hpc_with_a_Cabal_project but that seems to just get me coverage for the code in the test suite and not the library
04:24:11 <Taneb> Which naturally is less than ideal
04:24:15 <barrucadu> I don't think I had to do anything special, let me just build dejafu and run it again
04:28:26 <lavalike> thorsten`: alternate impl without fancy unfzip https://pastebin.com/raw/nWaUBbtB
04:28:49 <Taneb> barrucadu: thanks
04:29:21 <lavalike> thorsten`: nevermind, I forgot to generalize the type, I see the need for the fancier version
04:44:05 <merijn> hmm, we need a term for codegolfing that's about making code nicer/more readable, rather than shorter...
04:44:58 <hpc> i believe that term is "programming" :P
04:45:09 <merijn> Speaking of which, anyone have a suggestion how to make this branch nonsense less awful? https://bpaste.net/show/3a15bcbd79d0
04:46:23 <hpc> looks fine to me
04:46:35 <hpc> it's right on the edge of maybe needing to be refactored, but i can tell what it does pretty easily
04:48:53 <MarcelineVQ> can save 2 lines by removing the do's in the Just case
04:48:56 <merijn> hpc: It's ok, yeah. But I'm just curious if someone sees an (non-)obvious way to improve it :)
04:49:18 <merijn> MarcelineVQ: Not really, it has to linewrap any
04:49:26 <merijn> Way too long for a single line!
04:50:09 <MarcelineVQ> just one of them then :>
04:51:01 <MarcelineVQ> https://bpaste.net/show/a8a3a4a6255b muahaha
04:51:28 <hpc> merijn: hmm, i think it would depend on how that function might change in the future
04:51:55 <hpc> you might refactor it in some way and then find it only makes the next change harder
04:52:06 <hpc> can't think of anything i would change
04:54:19 <asheshambasta> is the preferred way to use mapM infix? 
04:54:34 <merijn> asheshambasta: eh...definitely not
04:54:55 <merijn> hpc: Nothing improves your ability to write readable like constantly questioning the way you're writing!
04:56:02 <Ariakenom> :t forM
04:56:04 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
04:56:16 <asheshambasta> merijn: whats the best way to decide when to write infix? Is readability the only criterion?
04:56:50 <merijn> asheshambasta: Pretty much
04:56:51 <dminuoso> asheshambasta: basically yes.
04:57:19 <Myrl-saki> Well, you can also use infix for flipping.
04:57:23 <dminuoso> asheshambasta: Sometimes infix can be handy because it has different associativity and precedence than prefix application.
04:57:32 <dminuoso> asheshambasta: or if you want to create a section
04:57:40 <Myrl-saki> Wait, can you?
04:57:45 <dstolfa> dminuoso: cool :-)
04:58:07 <asheshambasta> merijn, dminuoso: okay, I see (somewhat))
04:58:19 <Myrl-saki> asheshambasta: Prelude> (`subtract` 5) 4
04:58:21 <Myrl-saki> 1
04:58:22 <thorsten`> lavalike: thanks anyway :)
04:58:56 <Myrl-saki> OTOH, flip subtract 5 4
04:59:18 <merijn> Myrl-saki: subtract's main function is to be a replacement for (-x)
04:59:28 <dminuoso> dstolfa: I think it may even be a free theorem. But my type-fu is too weak to make a case here.
04:59:53 <Myrl-saki> merijn: I know, it's just the first non-commutative function that I thought of that's easy to type. :P
05:00:07 <dstolfa> dminuoso: it is
05:00:09 <Myrl-saki> I guess I could have used take or something.
05:00:46 <dminuoso> Myrl-saki: elem is the standard example I suppose.
05:01:07 <dminuoso> > 5 `elem` [1,2,3]
05:01:10 <lambdabot>  False
05:01:32 <Myrl-saki> dminuoso: FWIW, I was using infix as a flip replacement.
05:01:34 <asheshambasta> dminuoso: yeah, one of the most commonly occuring in my experience so far 
05:02:02 <Myrl-saki> So, probably used with HOF. `fmap (`foo` bar) [..]`
05:02:02 <lavalike> thorsten`: ^_^ I was hoping one could do with just modify at first, but then you added the requirement of returning the results too in your solution so .. :D
05:03:10 <thorsten`> :)
05:03:30 <Myrl-saki> Hm.
05:05:24 <ArahaelPi> Parsing is easy. :)
05:06:43 <Ariakenom> Who would ever spend more than a chapter of a compiler book on it?
05:06:59 <ArahaelPi> Ariakenom: Parsing? :)
05:07:04 <dstolfa> ArahaelPi: yeah, ezpzp
05:07:11 <dminuoso> Parsing is arguably the most complicated part of a compiler..
05:07:15 <dstolfa> dminuoso: SHHH
05:07:17 <dstolfa> dminuoso: parsing is easy
05:07:19 <Ariakenom> ArahaelPi: yes
05:07:21 <dstolfa> dminuoso: everything is ok
05:07:42 <ArahaelPi> dminuoso: I'm very pleasantly surprised at how trivial megaparsec seems to make it. :)
05:07:44 <dstolfa> dminuoso: if you keep pretending parsing is easy, you can tell others to do it as an "exercise"
05:08:55 <Ariakenom> (referencing the dragon book ofc)
05:09:20 <liste> parsing is easy, unless you're doing C++
05:09:47 <merijn> ArahaelPi: You're discovering why no one really uses regexes in Haskell :)
05:09:53 <hpc> parsing in C++ is easy
05:09:56 <ArahaelPi> liste: C++ is... special.  Even so, at least a parser library exists (clang, itself)
05:09:58 <hpc> you write a parser in C and then import that
05:10:06 <merijn> ArahaelPi: The parsing libraries are *so* nice and 2 years from now you can still understand what they do :p
05:10:19 <Ariakenom> 1. Assume program eventually triggers undefined behaviour. 2. Generate empty program
05:10:33 <ArahaelPi> merijn: I wrote a parser in Python.  When I was done, I had no idea what it was doing!
05:10:36 <ArahaelPi> (And it was HARD)
05:10:40 * dstolfa likes parser combinators
05:10:45 * dstolfa wishes OCaml had parser combinators
05:11:04 <merijn> ArahaelPi: tbh, one of the main reasons I replaced almost all my python research code was just to be able to use parser combinators
05:11:31 <merijn> ArahaelPi: Also have a look at optparse-applicative, it's a parser combinator library for commandline parsers. By far the least sucky commandline parsing library I've used in any language :)
05:11:36 <ArahaelPi> merijn: A year ago I saw the lead data scientist at my company switch all his code to python.  I thought he was nuts. :)
05:11:38 <hpc> when i write parsers in languages without parser combinators, i end up stumbling on a style that reproduces parsers' (>>=) with a bunch of line noise
05:11:48 <dminuoso> ArahaelPi: Oh parsing itself is not complicated, but if you consider a language like Haskell - then writing a parser that is: a) fast, b) correct and c) has good error diagnostics is no longer trivial.
05:12:14 <dminuoso> ArahaelPi: And the parser needs to be maintainable too.
05:12:24 <maerwald> how do you get a list of all rules in shake? 
05:12:37 <mniip> hpc, "oh yeah just a state transformer on top of an exception monad"
05:12:43 <ArahaelPi> dminuoso: I suspect that with Haskell itself, the type rules become the tricky bit.  I haven't done the typing rules yet.  I'm only building an AST for the moment.
05:12:58 <dstolfa> hpc: yeah, except it sucks with eager evaluation
05:13:08 <dstolfa> hpc: i've stumbled on it a few times
05:13:52 <hpc> it works fine in eager languages, parsers are pretty strict computations anyway
05:14:32 <dstolfa> hpc: in ML, it becomes cumbersome because of value restriction and eager eval, so it makes you eta-expand your grammar rules
05:14:37 <dstolfa> it can be a bit annoying
05:14:56 <hpc> dstolfa: try it in python, you don't even really get to use lambdas
05:14:58 <dminuoso> I cant remember who argued that the parser might be one of the hardest parts of GHC. I think it was SPJ in some talk about core-to-core passes.
05:15:15 <dstolfa> hpc: i'm not gonna write python unless someone has a gun to my head, tyvm
05:15:29 <hpc> i write my parsers as functions that take the full string as input, and return a parsed piece plus the unconsumed remainder
05:15:36 <dstolfa> i'm ok with other people writing python, but i won't :-)
05:15:47 <hpc> and then you just do a bunch of those in order with if-then-else and loops all over
05:15:47 <merijn> dstolfa: Sometimes you have to because of libraries
05:16:06 <ArahaelPi> merijn: I think if I have a choice, I might start thinking of using the FFI for that. ;)
05:16:08 <dminuoso> merijn: Is there no IronHaskell?
05:16:13 <merijn> dstolfa: But I replaced most of the python I had with a super-thin wrapper around the library call and just use process to call it from Haskell :p
05:16:15 <dminuoso> You could then interop with Python through .NET
05:16:30 <ArahaelPi> dminuoso: Have you ever tried IronPython?
05:16:35 <merijn> dminuoso: I just use processes and stdin/stdout...
05:16:35 <ArahaelPi> dminuoso: It's... Weird.
05:16:36 <dstolfa> merijn: i don't because i either do kernel development or formal models/proofs/exploring allowable behaviours of some model so i usually just write Ott/Haskell/OCaml/Isabelle/Agda in that case
05:16:46 <dminuoso> merijn: That's hardly enterprise software.
05:16:47 <dstolfa> in my case it's C, C++ for LLVM or any of the ones above
05:17:14 <maerwald> I guess no one uses shake really 
05:17:18 <merijn> dstolfa: Oh, do you happen to know a good short overview how to set clang++ to "maximum sanitisers!" mode?
05:17:39 <dminuoso> merijn: remind me, what exactly is a sanitizer anyway?
05:17:48 <dminuoso> Is that just clang terminology for "instrumentation"?
05:17:51 <merijn> dminuoso: "valgrind, but compiled into the executable"
05:17:53 <ArahaelPi> merijn: -Weverything I think?
05:17:59 <ArahaelPi> merijn: Oh, it doesn't do valgrind.
05:18:01 <dstolfa> merijn: you can't do everything at once
05:18:03 <merijn> ArahaelPi: That's warnings, not sanitisers
05:18:12 <dstolfa> merijn: TSAN/ASAN/MSAN don't work together
05:18:12 <dminuoso> merijn: Okay yeah so just instrumentation.
05:18:16 <dstolfa> they all use the shadow stack
05:18:20 <ArahaelPi> merijn: For sanitisers, you need runtime magic.
05:18:57 <merijn> dstolfa: Yeah, I remember from last time, but I didn't write down what I did and don't want to dig through each individual flag *again* if someone happend to have written a nice short overview
05:19:04 <merijn> dstolfa: But I guess I'll dive into the docs again
05:19:25 <dstolfa> merijn: https://clang.llvm.org/docs/UsersManual.html#controlling-code-generation
05:21:46 <merijn> dstolfa: The thing that annoys me is that they list all individuals sanitisers and some groups, but nowhere gives you a nice overview what the maximum compatible set of sanitisers you can combine is. Anyway, I'll just start fiddling again
05:22:01 <dstolfa> merijn: yeah, docs are hard :<
05:22:25 <barrucadu> Taneb: Things have now finished running, and I didn't need to do anything special.  However, my testsuite is actually an executable in a separate package (because Cabal has/had issues with testsuite dependencies), so stack is doing some cross-package stuff, which probably makes my experience useless here :p
05:29:40 <ab9rf> supersanitize
05:31:38 <Taneb> barrucadu: thanks anyway :)
05:42:11 --- mode: glguy set +v kmelva
05:42:30 <kmelva> Could I expect any performance benefits going from manual Aeson instances to TemplateHaskell ones?
05:43:30 <liste> kmelva: no, unless you wrote bad instances
05:45:53 <kmelva> liste: nope, instances are pretty much vanilla, just ".:" and ".:?" here and there...
05:46:05 <kmelva> thanks!
05:46:42 <liste> that's basically what TemplateHaskell does
05:47:01 <liste> (in this case)
05:50:47 <kmelva> Trying to speed it up a bit, C++ version is about 6-8x faster ... :/
05:54:33 <dminuoso> kmelva: Why not simply try TH and see for yourself?
05:58:10 <kmelva> dminuoso: ah, it'll take me some while to do it, if there's slim to none chance it'll do 2x performance improvement, I'd rather not bother... 
06:03:00 <kmelva> I would so like to use Haskell for this, 99% because of the lens library... that thing is sometimes so amazing (I'm dealing with lots of HTML & JSON parsing)...
06:05:14 <liste> is the C++ version using a parsing library?
06:05:50 <liste> kmelva: also, are you using Text/ByteString instead of String?
06:06:07 <kmelva> liste: don't know, actually don't have the source... I'm guessing sajson
06:06:31 <dminuoso> kmelva: Without seeing profiling data and the code its really hard to give you any advice. :)
06:06:46 <kmelva> liste: I give strict ByteStrings to Aeson, and all textual fields of my datatypes are Text
06:06:55 <liste> sajson looks super fast indeed :)
06:07:33 <kmelva> dminuoso: I'm guessing it just comes down to C++ v Haskell :/ I have a quick and dirty Rust prototype, it also seems to parse about 6-8x times faster than Haskell
06:09:27 <kmelva> Hmh, I do have a lot of Text fields where actually ByteString would be okay... I think I could make that change quickly
06:09:58 <dminuoso> kmelva: Like I said, without profiling data and the code it's impossible to say.
06:11:02 <dminuoso> kmelva: Unless there's something super obvious, you should `+RTS -ssderr +RTS` maybe
06:11:17 <ArahaelPi> kmelva: I've done some naive benchmarks a while ago (which I didn't keep, of various C++ JSON parsers.
06:11:47 <ArahaelPi> kmelva: They are all over teh place, and they are faster in different situations.  There are some impressively fast ones though, I forget which.  The speed could just be related to the amount of work the authors put in for speed.
06:12:28 <ArahaelPi> kmelva: And some had a *lot* of work in for speed, like, it was designed from teh get go for raw performance. (Wish I could remenber the name)
06:12:50 <ArahaelPi> kmelva: It will be hard, I suspect, to make Haskell faster than those ones.
06:13:19 <dminuoso> kmelva: the factor 6-8x is just a bit too much generally, with well written code 2-3x is more likely
06:14:35 <ArahaelPi> dminuoso: If I remember, at least one of those C++ libs were pull parsers.
06:15:06 <dminuoso> ArahaelPi: Out of principle I dislike discussing performance issues without profiling data.
06:15:39 <ArahaelPi> dminuoso: Well, if you don't pull any values from the json, you're not going to beat the "C++ performance", unless you use a lazy data type in haskell and *also* don't take any values from it!
06:16:01 <ArahaelPi> So waiting for profiling data is sensible, I guess, in that case.
06:16:52 <crobbins> i was thinking that i could have a newtype wrapper around IO, say: newtype App a = App { runApp :: IO a }; then define an instance for MonadReader based on some IORef; but it seems that due to the `local` method from MonadReader this isn't really possible.
06:16:55 --- mode: glguy set +v oak
06:16:59 <kmelva> dminuoso: what kind of profiling data would help?
06:17:18 <oak> Did you try to build Aeson with cffi flag? There is also json-stream
06:17:28 <kmelva> dminuoso: I'm using criterion, benchmarking json decoding for a typical JSON data I have... 
06:17:38 <crobbins> i could temporarily modify the IORef during `local`, but that seems like a race condition just waiting to happen
06:17:42 <dminuoso> kmelva: GC data from `+RTS -sstderr`, `RTS -p` for profiling data
06:18:05 <kmelva> oak: nope, didn't know about cffi! I'll try it!
06:18:16 <dminuoso> kmelva: Maybe seeing core code for the serialization/deserialization code
06:18:55 <kmelva> dminuoso: thanks, let me see what can I do
06:19:15 <dmwit> crobbins: Why not have `local` allocate a fresh `IORef`?
06:19:18 <dminuoso> kmelva: note that the second requires you to recompile with profiling flags.
06:19:42 <kmelva> dminuoso: yeaaaaaaah... I see it, I've had some problems recompiling with it before
06:19:53 <oak> There are also sajson bindings, but I wouldn't use aeson with cffi, json-stream nor sajson in environments where security is needed, such as in web applications
06:19:59 <dminuoso> kmelva: It shouldn't create problems.
06:20:02 <dmwit> crobbins: Oh wait, like... a global IORef? Yeah, don't do that.
06:20:49 <crobbins> dmwit: yeah, i guess if `local` didn't exist a global IORef would be fine
06:21:02 <dmwit> No, no, I mean: don't make a global IORef in the first place.
06:21:23 <dmwit> I don't care whether you happen to name your IORef reader `ask`, that seems unimportant to me.
06:21:30 <dmwit> The bigger question is a program architecture one.
06:22:01 <philippD> Is there something like Data.Dynamic where I can specify a list of Constraints that the wrapped value has to fulfill?
06:24:13 * hackage observable 0.1.1 - Make your action to be observable and listen events from them.  http://hackage.haskell.org/package/observable-0.1.1 (iokasimovmt)
06:24:23 <Taneb> philippD: I don't know of a library but I think you can make one with GADTs
06:24:34 <crobbins> dmwit: hmm i guess actually in this case it doesn't need to be an IORef since the values shouldn't change. do you happen to know if there's a cost to ReaderT vs IO?
06:24:52 <Taneb> Something like Foo c where Foo :: c x => x -> Foo
06:25:34 <dmwit> crobbins: I expect `ReaderT r IO _` to have essentially the same preformance as `r -> IO _`.
06:25:45 <crobbins> i.e. i assume `ReaderT r IO` must be more costly than just IO
06:26:10 <dmwit> *performance
06:26:14 <crobbins> for sure, i'm wondering about the bind operations though
06:26:26 <crobbins> since ReaderT is a newtype around r -> m a
06:26:27 <dmwit> Although now I'm imagining a program which produces answers before you ask your questions.
06:26:43 <hexagoxel> philippD: i am pretty sure there is a library with that, one sec
06:27:22 <hexagoxel> "constrained-dynamic"
06:27:29 <dmwit> crobbins: I would be pretty surprised if you managed to create a program whose performance was so tight that ReaderT's bind was your bottleneck.
06:27:54 <Taneb> hexagoxel: oh, neat
06:27:59 <philippD> Taneb: I need more control over what Constraints are present. My current implementation is roughly `data Hide (cs :: [* -> Constraint]) where Hide :: ImplementsAll a cs => a -> Hide cs` where `ImplementsAll` is a typefamily that ensures that each Constraint is satisfied. The problem now is that I need to exectue a function with from one of these co
06:27:59 <philippD> nstraints
06:28:44 <crobbins> dmwit: for sure, and i'm not necessarily concerned about that so much, mostly interested in what's possible in terms of optimizing MonadReader for some newtype around IO, and if we really need to use ReaderT in the first place
06:28:50 <crobbins> but it seems because of `local`, we do
06:28:57 <crobbins> otherwise, we don't
06:30:28 <philippD> hexagoxel: I don't think that I can use that to capture individual classes. the `cs` type parameter models just one big Constraint. I really need the granularity of something like `[* -> Constraint]`
06:34:58 <Ariakenom> I can imagine a global IORef to be more expensive than ReaderT. The argument may well be passed in a register all the time.
06:40:33 <kmelva> dminuoso: here's -sstderr, does it shed any light? https://gist.github.com/kmelva/7f72c322bf491a9ed711b6bfdb744f83
06:43:02 <Ariakenom> is that 90GB allocated?
06:43:55 <merijn> Ariakenom: Yes, but that's ok
06:43:56 <kmelva> Ariakenom: well, it would seem so? :)
06:44:02 <merijn> Ariakenom: You shouldn't look at *allocated*
06:44:08 <merijn> You have to look at *resident*
06:44:24 <merijn> Max residency seems to be about 1 MB
06:45:03 <merijn> kmelva: Any specific problem you're trying to solve?
06:45:54 <merijn> Ariakenom: If you look closely you'll see the average allocation rate is about 6 GB/sec ;)
06:46:08 <kmelva> merijn: JSON parsing, looking if I can make it a bit faster compared to C++/Rust version... it's ~8x slower
06:46:20 <Ariakenom> merijn: :)
06:46:27 <merijn> But, GHC happens to be *very* good at allocating lots of things if you immediately discard them
06:46:37 <Ariakenom> I didn't mean it being a problem. Those numbers are interesting
06:46:38 <dminuoso> merijn: I just suggested they supply some profiling data - starting with GC just to rule out any pathological behavior there
06:46:58 <merijn> This looks mostly sane, to me. Are you compiling with -O2?
06:47:12 <merijn> kmelva: It might be that you need to handroll some ugly stuff if you wanna get faster
06:47:25 <Ariakenom> Seems like work for the ... mutators? ... if not for the GC. 1GB copied
06:47:30 <merijn> IF json parsing is actually a bottleneck for you
06:48:21 <kmelva> merijn: yup, 02, although it's not much of a difference. Also, passing -cffi to Aeson does a bit of difference, but nothing major
06:48:33 <Ariakenom> (that second sentence is not related to he first)
06:48:58 <merijn> kmelva: Depending on what the Rust/C++ version is doing they might just be skipping lots of steps and speeding up that way
06:49:05 <kmelva> merijn: I don't have the skill to do anything handrolled, that's for sure :)
06:49:19 <merijn> kmelva: Is it actually a bottleneck, or just curiosity?
06:50:28 <kmelva> merijn: yeah, it kind of is :/ Being 8x slower is not horrible, but definitely noticeable ... the app is mostly JSON/HTML parsing and keeping lot's of stuff in RAM
06:51:06 <kmelva> merijn: for example, Rust version parses faster and has no issues having 5 gigs of data in RAM. Haskell parses slower and the GC doesn't like having gis of RAM in use
06:51:08 <merijn> kmelva: You can try switching to processing in parallel and try and gain speed that way
06:51:19 <Ariakenom> What's the state of vector instructions in Haskell?
06:51:30 <merijn> Ariakenom: rough edges
06:51:36 <dminuoso> kmelva: Like I said, you probably should still profile it out of principle.
06:51:44 <merijn> Ariakenom: Talk to carter and people in #numerical-haskell to stay up to date :)
06:51:48 <mniip> merijn, there's edges?
06:52:15 <kmelva> dminuoso: profile build is still... building :D
06:52:16 <merijn> mniip: There's some exposed SIMD instructions in ghc-prim, but no real high level support yet
06:52:44 <mniip> I have an outstanding ticket regarding how some of those prims take 64-tuples
06:52:48 <kmelva> Oh yeah, I also had issues with Haskell SSL implementation... it was 3x-4x slower :D Fixed that one using stunnel... but I don't see quick fixes for parsing/GC
06:52:49 <kmelva> :/
06:52:51 <mniip> whereas the tuple limit in GHC is 62
06:53:42 <dminuoso> mniip: Is there a reason this was never bumped up higher? I thought the segfault bug went away over the years.
06:53:43 * hackage semilattices 0.0.0.2 - Semilattices  http://hackage.haskell.org/package/semilattices-0.0.0.2 (robrix)
06:53:54 <dminuoso> Not that a 63-tuple is something I want..
06:54:02 <Ariakenom> what's that thing called, compact regions?
06:55:54 <Ariakenom> But that may not be appropriate for what you, kmelva, are doing. I dunno
06:56:32 <kmelva> Ariakenom: yeah, looked into that a bit... it's still quite fresh, but I'm hopefull :)
06:59:17 <asheshambasta> Has anyone used both Opaleye and Selda? Pros and cons, if any? 
07:01:25 <kmelva> dminuoso: here's the profiling result: https://gist.github.com/kmelva/9fb1e3a8630fb5772b2d18659c4d67bf
07:01:51 <kmelva> It seems that most of the time is spent in Attoparsec...
07:02:08 <Ariakenom> "the factor 6-8x is just a bit too much generally, with well written code 2-3x is more likely" If the C++ is vectorised that's another 2-3x and the numbers add up?
07:02:44 <Ariakenom> oh but basic rust had sameish speed so I guess not
07:04:57 <kmelva> Ariakenom: serder (Rust library) is usually among the fastest in benchmarks, so I'm not that surprised that Rust ~ C++ in this case
07:06:08 <Ariakenom> yeah right. not sure why I assumed you used no lib in rust ... :p
07:12:30 <vaibhavsagar> does derivingvia work with standalonederiving?
07:13:31 <cocreature> vaibhavsagar: iirc yes
07:13:43 <vaibhavsagar> what's the syntax for that?
07:14:08 <cocreature> vaibhavsagar: https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0023-deriving-via.rst#31syntax-changes
07:15:09 <vaibhavsagar> Thanks cocreature! I was looking at the paper and didn't see anything like this
07:16:19 <cocreature> kmelva: which data type are you converting to?
07:17:46 <vaibhavsagar> I'm trying to follow the paper's example for `Maybe` and this seems to work: `deriving via (App Option a) instance Semigroup a => Semigroup (Option a)`
07:24:27 <ab9rf> dminuoso: i once ran into a database that had 1017 columns. given this, i'm sure there is someone who wants n-tuples for n>62
07:25:42 <Ariakenom> :t ('a',(1::Int,()))
07:25:44 <lambdabot> (Char, (Int, ()))
07:27:38 <philippD> I don't quite get why I'm getting error here. Does someone know what's going on here? https://lpaste.net/7128942629508612096
07:29:33 <cocreature> philippD: the problem is that "c" can’t be inferred from the arguments to applyDyn
07:30:42 * hackage hw-prim 0.6.2.8 - Primitive functions and data types  http://hackage.haskell.org/package/hw-prim-0.6.2.8 (haskellworks)
07:30:49 <cocreature> you have two options for solving this: either you add a Proxy argument or you enable AllowAmbigousTypes and use TypeApplications to specify c
07:31:08 <philippD> I went with the proxy argument
07:31:09 <philippD> thanks
07:31:25 <philippD> AllowAmbigousTypes doesn't fee right
07:31:31 <philippD> s/fee/feel/
07:32:14 <cocreature> it’s not as bad as it sounds
07:32:30 <cocreature> imho, the biggest reason to avoid it is that you can only turn it on for a whole module
07:42:43 <dmwit> I like TypeApplications. No Proxy's floating around at runtime just seems... right... even if the GC manages to make them all sit in the same spot in memory.
07:46:45 <dmwit> dminuoso: https://stackoverflow.com/questions/46412823/why-are-ghc-tuples-limited-to-size-62
07:52:48 <hololeap> how do i tell `stack new` to use LTS 9.21 instead of LTS 12.6?
07:54:42 * hackage Yampa 0.11.1 - Library for programming hybrid systems.  http://hackage.haskell.org/package/Yampa-0.11.1 (IvanPerez)
07:54:54 <liste> hololeap: https://docs.haskellstack.org/en/stable/GUIDE/#resolvers-and-changing-your-compiler-version
07:55:05 <liste> so I'd guess stack new --resolver lts-9.21
07:55:12 <liste> but didn't test it
07:56:11 <philippD> cocreature: Is GHC just not that far in this area or why do I still have to specify which c I'm refering to here `applyDyn @Show show` where `applyDyn :: (forall a. c a => a -> b) -> CSDyn cs -> b`
07:56:31 <hololeap> liste: thanks
07:56:50 <philippD> isn't it clear form the usage of `show` that `c` has to be `Show`?
07:58:39 <cocreature> philippD: let’s say you have "f :: Eq a => a -> a". c could be Eq in that case but it could also be Ord since you can treat f like it has the type signature "f :: Ord a => a -> a"
07:59:53 <philippD> Yeah but that doesn't matter since even if `c` was `Ord` `f` only requires `Eq` so `c` could safely default to `Eq`
08:01:26 <cocreature> that’s not how type inference works. either GHC can figure out what a type variable has to be by unifying it with something else or it will be ambiguous and GHC will yell at you
08:01:35 <cocreature> GHC doesn’t do any kind of defaulting if there is more than one option
08:02:01 <Ariakenom> > show $ 1+1
08:02:03 <lambdabot>  "2"
08:02:06 <Ariakenom> -.-
08:02:59 <liste> I think ghci has more comprehensive defaulting rules
08:03:02 <liste> than plain ghc
08:03:31 <cocreature> it does but given that GHC even warns about the limited warning that it does by default, I really don’t think you should rely on this for anything
08:04:06 <Ariakenom> :t (^)
08:04:07 <lambdabot> (Num a, Integral b) => a -> b -> a
08:04:13 <Ariakenom> > 2.0^2
08:04:16 <lambdabot>  4.0
08:04:48 <Ariakenom> ^ is where I've used defaulting most
08:07:16 <cocreature> Ariakenom: you’ll just make your code needlessly slow if you use defaulting here. in a lot of cases the exponent is a fairly small literal written in your code and using Integer for that is entirely useless
08:07:44 <Ariakenom> default (Word8) lets go
08:08:24 <cocreature> just add a type annotation
08:08:43 <Ariakenom> clearly defaulting to Word8 is the superior solution here
08:09:08 <cocreature> clearly …
08:10:08 <hololeap> > 5 :: Word8
08:10:10 <Ariakenom> Usually I'm mucking about and defaulting to Integer is fine.
08:10:11 <lambdabot>  5
08:10:31 <hololeap> > (255 :: Word8) ^ (255 :: Word8)
08:10:34 <lambdabot>  255
08:11:17 <dmwit> Just -fllvm and let constant propagation fix your laziness for you.
08:11:27 <liste> > (51531 :: Word8)
08:11:29 <lambdabot>  75
08:11:57 <Ariakenom> I do know llvm has native bigint support but will it work?
08:12:22 <dmwit> Yeah, I actually don't know if it's smart enough to fix (^) :: Num a => a -> Integer -> a.
08:12:30 <dmwit> Maybe it isn't.
08:14:09 <Ariakenom> default (Cyclotomic)  maximum speed
08:17:07 <Ariakenom> data Cyclotomic = Cyclotomic { order :: Integer, coeffs :: M.Map Integer Rational
08:17:08 <Ariakenom> }
08:17:22 <dmwit> ?hackage cyclotomic
08:17:22 <lambdabot> http://hackage.haskell.org/package/cyclotomic
08:17:33 <dmwit> No sense reinventing the wheel.
08:17:52 <dmwit> Oh, you actually copied and pasted from that.
08:17:53 <dmwit> Okay.
08:17:58 <Ariakenom> :p
08:18:14 <Mitsos101> f (x, y, z, w) = if p then (x,y,g,w) else (x,y,w,g)
08:18:18 <Mitsos101> Is there a shorter way to write this?
08:18:36 <dmwit> Yes, but not one that's actually useful to you.
08:18:55 <dmwit> Namely: since `p` is free, you can just evaluate it and choose your branch statically.
08:19:45 <dmwit> Which is not useful to you, because I expect in your actual program p is not free and you have minimized too far. =P
08:20:02 <Ariakenom> I just wanted to show the extent of the slowness.
08:20:11 <Mitsos101> Indeed, but I was wondering if there's a way so I don't have to rewrite most elements
08:20:44 <dmwit> No, there's nothing significantly better.
08:23:03 <dminuoso> ab9rf: 1017 columns sounds like a world of fun.,
08:24:13 <dminuoso> Mitsos101: What's the intent here?
08:25:05 <Mitsos101> dminuoso: Interactive binary search, the tuple is (left, right, a[left], a[right])
08:25:52 <Mitsos101> dminuoso: You print "? x", and the interactor prints a[x]
08:26:07 <Mitsos101> dminuoso: I've written that using mapAccumL & interact
08:26:21 <dminuoso> Mitsos101: what does a[left] and a[right] denote?
08:26:37 <Mitsos101> dminuoso: (a !! left), (a !! right)
08:26:45 <ab9rf> dminuoso: oh, yeah.
08:27:09 <ab9rf> dminuoso: it was really hard to work with, very few database engines will tolerate that many columns in a table.
08:34:56 <glguy> = (if p then id else flip) ((,,,) x y) g w
08:35:01 <glguy> Look at the savings!
08:35:14 <dmwit> By Grabthor's hammer!
08:36:06 <coldpresent> hey all, i'm writing many sorting functions in the same file
08:36:26 <dmwit> Mitsos101: But then wouldn't you want the first two parts of the tuple to also depend on p?
08:36:30 <glguy> bool flip id p ((,,,) x y) g w
08:36:53 <glguy> Now we're cooking with gas
08:36:54 <coldpresent> i want to declare one type signature in a sorting class, then instance each sorting function
08:37:03 <coldpresent> is that possible?
08:38:02 <dmwit> coldpresent: type Sorter = [Int] -> [Int]; quickSort, insertSort :: Sorter -- ?
08:38:24 <dmwit> coldpresent: Depends what you want. You could `type Sorter a = [a] -> [a]` and then `quickSort, insertSort :: Ord a => Sorter a`.
08:38:37 <coldpresent> dmwit, aliases to the rescue, thanks!
08:38:47 <coldpresent> i'll put the constraint in the alias
08:38:49 --- mode: glguy set +v khilan
08:38:58 <dmwit> Or if you just always want your sorts to work on only-`Ord`erable things, you could `type Sorter = forall a. Ord a => [a] -> [a]; quickSort, insertSort :: Sorter`.
08:39:01 <Mitsos101> I just thought of this: left m = (x,y,m,z), right m = (x,y,z,m)
08:39:02 <khilan> Hello! I've probably asked this question earlier but am facing some difficulty in understanding a concept. I'm trying to write a function which returns a random normal distribution (of fixed size, i.e height * width). I'm using `normals` function from Data.Random.Normal to do this but am unable to understand how exactly to use `normals`. Can someone plz help me out? Thanks in advance!
08:39:25 <Mitsos101> and then it's f (x,y,z,w) = if p then (left g) else (right g)
08:39:43 <coldpresent> dmwit: do you need the forall? isn't it implicit?
08:39:56 <dmwit> coldpresent: N.B. no 'a' on the left hand side of the equality
08:40:57 <dmwit> `type Sorter = a` is invalid because `a` is not in scope; `type Sorter a = Ord a => a` is invalid (maybe unless you have RankNTypes on?) for other reasons.
08:41:16 <coldpresent> dmwit: right, didn't know that, thanks again!
08:44:40 <khilan> Hello everyone! Can someone plz help me out with the question I posted above?
08:49:47 <NH> :t normals
08:49:48 <lambdabot> error: Variable not in scope: normals
08:52:52 <NH> khilan: you need a random generator
08:53:23 <NH> can use mkStdGen from System.Random or some other way
08:53:28 <khilan> yes, I do get that 😅 
08:54:09 <khilan> I don't understand how to get a array/matrix or something of fixed dimentsions
08:54:14 <khilan> say 10 x 10
08:55:02 <khilan> I'm getting a random generator by `g <- newStdGen`
08:55:14 <khilan> passing that into the function
08:55:39 <khilan> messing up with the next steps :-)
09:19:22 <ChaiTRex> Is it possible to use type-level naturals with some type, and to have T 0, T 1, and T n (n > 3) have different `data` definitions?
09:19:33 <ChaiTRex> Sorry, n > 1
09:20:04 <ChaiTRex> So it'd be like data T 1 = ...; data T 2 = ...; data T n = ...
09:20:59 <c_wraith> ChaiTRex, that's a data family
09:21:08 <c_wraith> ChaiTRex, you can certainly do it.
09:21:16 <ChaiTRex> c_wraith: Thanks. I'll use that as a search term.
09:21:41 <c_wraith> ChaiTRex, it's part of the TypeFamilies extension, if that helps the searching.
09:23:00 <ChaiTRex> c_wraith: How would the overlap of n with the explicit numbers be handled?
09:23:22 <c_wraith> not sure what you mean by that.
09:23:37 <c_wraith> you'd write something like... data family T (n :: Nat) ; data instance T 1 =... ; newtype instance T 2 =... ;
09:23:49 <`Guest00000> are patterns scoped in Haskell?
09:24:00 <ChaiTRex> How would you write the instance for T n where n > 2?
09:24:14 <c_wraith> ah. you can't do that with data families.
09:24:50 <c_wraith> you could do it with a closed type family, but it would get more roundabout.
09:24:51 <ChaiTRex> c_wraith: Darn. Any alternatives?
09:25:04 <ChaiTRex> c_wraith: Ahh, OK. I'll look for that. Thanks again.
09:25:41 <c_wraith> `Guest00000, variables bound in patterns have scopes, but I wouldn't say that patterns themselves do.
09:26:14 <ChaiTRex> c_wraith: Ahh, that looks like what I need. Thanks.
09:27:12 <`Guest00000> consider:   foo (x@(const y -> "abc"), y@(const x -> "def")) = y ++ x
09:27:31 <`Guest00000> i type this, GHCi says "variable not in scope: y"
09:27:45 <`Guest00000> but it looks like a sensible pattern
09:28:11 <c_wraith> ah, yes. variables bound in a pattern are not in scope in that pattern itself.
09:28:18 <geekosaur> not to me, becaause if it meant anything at all, it'd mean the two "y"s are the same which is probably not what you intended
09:28:30 <geekosaur> which is largely why you can't do that. (remember that let is recursive)
09:29:34 <c_wraith> this has other consequences, like you can't say foo x x = "same" ; foo _ _ = "different"
09:30:19 <`Guest00000> geekosaur: (const x -> "string") matches with any value, binding x to "string", so i think my example should be equivalent to: foo (x@"def", y@"abc") = y ++ x
09:30:20 <c_wraith> prolog let's you match like that. haskell forbids it because it doesn't want to be logic programming.
09:30:46 <`Guest00000> oooooops
09:30:47 <`Guest00000> no
09:30:53 <geekosaur> `Guest00000, you have y twice in there, recursive let means that you are asserting they're the same y
09:31:09 <geekosaur> but this is something Haksell can't do, because it's logic programming and fairly complicated to implement
09:31:17 <`Guest00000> matches with any value and succeeding if x matches "string"
09:31:37 <madnight> can i haz inline prolog with TH?
09:31:38 <`Guest00000> geekosaur: i have y only once in binding position
09:31:41 <`Guest00000> same with x
09:32:10 <[exa]> haskell variables (bindings) have different semantics from prolog variables (pointers), but I guess there's a simple TH way to wrap them to named refs
09:32:11 <lavalike> is there a nicer way to get the earliest UTCTime than UTCTime (ModifiedJulianDay 0) 0
09:32:14 <geekosaur> you are not getting the "recursive" part. you have y twive in there, you are asserting they are the same thing
09:32:29 <geekosaur> so the y@... means the same y as the const y
09:32:39 <geekosaur> which haskell doesn't support but prolog does
09:33:07 <`Guest00000> ok
09:33:12 <geekosaur> so haskell throws an error at the ambiguity
09:34:10 <`Guest00000> i think this is unrelated to "foo x x", or not directly
09:36:38 <int-e> > let foo x (y@(const x -> "abc")) = x ++ y in foo "abc" "def" -- confusingly there seems to be a left-to-right scoping going on here
09:36:41 <lambdabot>  "abcdef"
09:37:21 <int-e> > let foo (y@(const x -> "abc")) x = x ++ y in foo "def" "abc"
09:37:24 <lambdabot>  error:
09:37:24 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[Char]’
09:37:24 <lambdabot>      • In the pattern: "abc"
09:37:32 <int-e> :t x
09:37:33 <lambdabot> Expr
09:37:37 <`Guest00000> > x
09:37:40 <lambdabot>  x
09:38:08 <int-e> > foldl f x [y,z]
09:38:10 <lambdabot>  f (f x y) z
09:41:20 <`Guest00000> why is my example logic programming?
09:42:28 <geekosaur> you still want those "y"s to be different, which wouyldn't be. but they would be the same, which would be
09:43:09 <`Guest00000> i don't understand that
09:43:19 <geekosaur> this is the same thing going on as "let x = x in x" where all three "x"s are identical
09:43:41 <geekosaur> you cannot turn that off
09:44:10 <geekosaur> most people have the epectation that they are different, just like you expect the two ocurrenes of y in your pattern to mean different things
09:44:28 <`Guest00000> no... y is bound only once, the other occurence is in an expression
09:44:36 <`Guest00000> in a view pattern
09:44:42 * hackage primitive-extras 0.6.7 - Extras for the "primitive" library  http://hackage.haskell.org/package/primitive-extras-0.6.7 (NikitaVolkov)
09:45:13 <geekosaur> yes, this is where you expect them to be different but they are not different
09:45:26 <`Guest00000> i don't see why anyone would expect them to be different
09:45:39 <`Guest00000> one y is in an expression
09:45:55 <`Guest00000> which means it cannot be different from the y which is bound
09:46:02 <geekosaur> all variables in a pattern are bindings
09:46:55 <geekosaur> "expression" is not a thing. you have a suibpattern which is binding y, but the scope of variables is the full pattern, not the subpatterm, so using "y there asserts that it is the same "y" as other uses.
09:48:11 <int-e> geekosaur: there is an expression in a view pattern:  expr -> pat  
09:49:28 <int-e> `Guest00000: the way I see it, the problem is that patterns are matched from left to right... so there's no way fro the y that is bound by y@(const x -> "def")  to be used inside the earlier pattern  x@(const y -> "abc").
10:10:12 <hololeap> isn't there a function somewhere in base that "keeps an Ord within a range" like this: (\mn mx -> min mx . max mn)
10:11:35 <dmwit> lavalike: That's not the earliest UTCTime.
10:12:14 <dmwit> hololeap: No, I write it (and cri) every time.
10:13:02 <dmwit> :t let (f, f -> ()) = (id, ()) in f
10:13:03 <lambdabot> () -> ()
10:13:12 <dmwit> Neat.
10:14:06 <dmwit> `Guest00000: https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns#Semantics discusses the scoping rules around view patterns.
10:15:12 <ab9rf> dmwit: a truly useful function
10:24:06 <dmwit> ChaiTRex: Besides data families, consider GADTs: `data Foo n where Bar :: Int -> Foo 0; Baz :: Char -> Foo 0; Quux :: Foo 1; Blargle :: n > 1 => Foo n`
10:27:55 <dmwit> :t let x@(const x -> _) = () in x
10:27:56 <lambdabot> ()
10:28:11 <dmwit> wow
10:28:48 <dmwit> I guess why not? Your view function already gets handed the whole value anyway.
10:34:33 <philippD> I'm currently trying to build a version of Dynamic where you can specify a list of classes (or Constraints) that the Dynamic value has to implement. You then get a way of executing functions of specific classes. This works quite well if you only want to use a single captured constraint but I can't figure out how to use multiple constraints at once.
10:34:33 <philippD>  https://lpaste.net/8862601690298187776 Does somebody have an idea? The problem occured while trying to implement Eq. Or am I going at this problem wrong
10:36:25 <dmwit> (there's no "h" in "witness")
10:36:54 <dolio> Whitness.
10:37:25 <dolio> There might be in the South.
10:39:14 <dmwit> philippD: Just nest calls to applyDyn, I suppose.
10:40:01 <philippD> that wont work unfortunatly because applyDyn requires the argument to be a `DynWitness` and I can't repackage those
10:42:10 <philippD> once i use applyDyn lose all information other than the exact Constraint I requested
10:47:01 <glguy> philippD: is this related? https://github.com/glguy/operations
10:47:20 <glguy> https://github.com/glguy/operations/blob/master/src/Example.hs
10:47:40 <dmwit> philippD: Perhaps your basic operation should be `applyDynWitness :: ApplyDyn c cs => (forall a. c a => Witness a cs -> b) -> DynWitness cs -> b`, from which your existing `applyDyn` can be recovered by using `witnessValue`.
10:48:20 <dmwit> hm
10:49:10 <dmwit> That may not help, either. =P
10:49:13 <philippD> @glguy: usingN look exactly like what I would need
10:49:14 <lambdabot> Unknown command, try @list
11:10:13 <khilan> Plz forgive me for a silly question. I'm getting a parse error in line 17 in https://gist.github.com/khilanravani/d9f342d847ef9aa1a65e4383e36bb9be
11:11:32 <khilan> can someone plz look into it?
11:12:26 <merijn> khilan: eh, you can only have bindings in a where block
11:12:34 <merijn> khilan: line 17 is an expression
11:13:15 <merijn> It also looks like you're trying to compute by overwriting the value of sumT, which isn't possible
11:13:16 <khilan> merijn:  Oh ok, so I need a 'do' ?
11:13:32 <merijn> khilan: No, you *can't* have an expression/computation there
11:13:49 <glittershark> you can't change the value of a variable once it's been assigned
11:14:11 <khilan> merijn: so I need rankRef's?
11:14:24 <khilan> I mean STRefs
11:14:34 <merijn> khilan: In this case you just need a fold
11:16:11 <khilan> Oh okay, I'll try it out. Thank u!
11:16:12 <merijn> khilan: Write a small helper "foo sum idx = sum + (i * I.index image (0, i))", and write "sumT = foldl' foo 0 [0..255]"
11:16:49 <dmwit> philippD: got it
11:16:52 <khilan> merijn: Ok, thank u!!
11:17:15 <dmwit> philippD: https://lpaste.net/5831371015829061632
11:18:03 <dmwit> (I tried to stay as close to your original style as possible. There are a couple things I would change that would reduce the noise a little bit.)
11:20:08 <glguy> sum [ i * I.index image (0,i) | i <- [0..255] ]
11:20:15 <philippD> dmwit: Thanks. I scrapped my stuff and just ripped glguy's Object implementation.
11:20:33 <merijn> glguy: sum (sadly) leaks, unlike foldl'
11:20:34 <philippD> It's much more elegant
11:20:34 <dmwit> Yes, that's probably smart. Even so it can be useful to see how to modify an idea you had to work.
11:20:50 <dmwit> Because it will help you get it right next time you have to design something. =)
11:20:57 <glguy> merijn: optimizations kick in
11:21:56 <glguy> If you're concerned about that it would be cleaner to define a sum' locally using foldl' and solve the problem using it
11:22:10 <philippD> dmwit: I hadn't thought about just having something like (c a => b) in there. pretty cool
11:22:26 <dmwit> philippD: Yep. But the real advancement is taking a Whitness instead of a DynWhitness.
11:22:42 <dmwit> philippD: This way you can tie together the types in the Whitness across two calls to applyWitness.
11:22:49 <glguy> Witness?
11:22:53 <philippD> I was trying super hard to keep using Witness
11:22:59 <glguy> Or is this some color space deal?
11:23:14 <dmwit> glguy: Just copying his names.
11:23:49 <philippD> english not my first language so get off my back :-p
11:26:39 <dmwit> philippD: To be more clear: with applyDyn, when you `applyDyn (\v -> applyDyn (\v' -> ...) a) a`, it isn't known that `v` and `v'` have the same type. But when you `applyWitness (applyWitness ... a) a`, it *is* known that both constraints you get apply to the same type.
11:27:41 <philippD> Yeah, that was the main point I was struggling with
11:27:49 <dmwit> The switch from "function" to "any type" is just a bit of icing; the trick of unwrapping your existentials just once is the cake.
11:38:06 --- mode: glguy set +v green_
11:43:53 <olle> would it be possible to construct a model in haskell in which `1/10 + 2/10 == 3/10` is true?
11:44:23 <olle> meaning `1/10` is treated as a separate number, and not evaluated to float or double.
11:44:44 <int-e> > 1/10 + 2/10 == (3/10 :: Rational)
11:44:46 <lambdabot>  True
11:45:21 <olle> ha!
11:45:23 <olle> cool
11:45:47 <olle> > True
11:45:50 <lambdabot>  True
11:46:23 <olle> why are we still using float or double instead of rationals, I wonder?
11:47:17 <glguy> Sometimes we're not working with exact values and speed is more important
11:47:22 <olle> or another question: would it be possible to make 0.1 automatically evaluate to 1/10?
11:47:36 <olle> glguy: speed could be the same if we had hardware supported rationals.
11:47:42 <glguy> > 0.1 ::Rational
11:47:44 <lambdabot>  1 % 10
11:47:54 <davean> olle: no it couldn't
11:47:57 <olle> %?
11:47:59 <olle> davean: no?
11:48:00 <cocreature> olle: not really, the problem is that your rational don’t have a constant size
11:48:02 <glguy> No, hardware isn't magic
11:48:07 <davean> olle: not even remotely
11:48:15 <olle> davean: why?
11:48:28 <cocreature> so even assuming you can get it to the same speed for some fixed size, thing will get slower if the size grows
11:48:31 <davean> So many reasons ... area, memory bandwidth, cache effects, non-constant size ...
11:48:43 <davean> theres NOTHING about rationals that makes it sutible for HW
11:48:51 <olle> Sad.
11:48:55 <davean> and it won't be the same speed for fixed size even
11:49:07 <davean> the computations are simply harder, take more transisters, etc
11:49:14 <davean> physics says you can't have that
11:49:59 <green_> What's the current state of stack traces? Do I still have to enable profiling, or is there anything that lets me have stack traces without sacrificing (much) performance?
11:50:20 <olle> davean: on the other hand it would be correct.
11:50:33 <davean> olle: for a limited set of cases
11:50:52 <davean> olle: There are a lot of things that are reals, not rationals
11:51:13 <olle> just surprised me that there's no HW units for rationals, should be usable for some scientific stuff.
11:51:25 <davean> Nope
11:51:33 <davean> Scientific stuff does numerical methods
11:51:38 <davean> they're not short of compitent people
11:51:46 <davean> So its not a problem
11:51:47 <olle> well, reals are approximated in FPU too.
11:52:00 --- mode: glguy set -v puregreen
11:52:04 <puregreen> What's the current state of stack traces? Do I still have to enable profiling, or is there anything that lets me have stack traces without sacrificing (much) performance?
11:52:05 <davean> Yes, but I'm saying rationals wouldn't get you much at all for any serious use
11:52:16 <olle> hm
11:52:37 <merijn> olle: Contrary to popular belief IEEE754 was very carefully designed for engineers to be able to reason about precision loss, accuracy, etc.
11:53:00 <olle> machine epsilon?
11:53:02 <merijn> puregreen: You can manually insert call stack for stack traces
11:53:06 <ab9rf> IEEE754 was designed for engineers, not for mathematicians
11:53:23 <merijn> puregreen: But if you want traces without manually annotating you still need profiling, yes
11:53:59 <merijn> puregreen: Although, tbh, I haven't lost *that* much performance with profiling enabled
11:54:28 <davean> The people who IEEE754 is poorly designed for is programmers
11:55:22 <davean> programmers *lack* the specialized knowlege and skills related to it, HPC/Scientific programmers don't, not do mathamaticians who do numerical computations
11:55:35 <dminuoso> davean: IEEE754 is fine the way it is.
11:55:46 <davean> dminuoso: I tihnk thats what I just said
11:56:13 <dminuoso> davean: My point is, its not a programmer problem - I know of plenty programmers who understand its implications.
11:56:31 <puregreen> @merijn alright, then let's put it like this: do you see any reasons why it would be a bad idea to enable profiling for builds that go into production? (with "production" being a low-load Haskell backend)
11:56:31 <lambdabot> Unknown command, try @list
11:56:57 <davean> dminuoso: I know almost none that can do the proofs to show they got the right results and such.
11:57:06 <cocreature> puregreen: yes, profiling can break things quite badly, e.g., it can break fusion which some workloads rely on quite heavily
11:57:13 <davean> dminuoso: mostly they just get good enough results and don't have an active problem with it IME
11:57:23 <davean> dminuoso: I know very few who have actually studied it
11:57:29 <glittershark> cocreature: really? how do you do optimization of that code then?
11:57:45 <ab9rf> the main problem IEEE754 creates is with people who think that (1/3)*3 should be exactly equal to 1 :)
11:57:48 <olle> but maybe it's wrong to use float and int for all numbers?
11:57:50 <glittershark> if profiling causes code to perform more slowly in inconsistent ways, what's the point of profiling?
11:57:54 <olle> why not have rational as a third alternative?
11:58:09 <dminuoso> ab9rf: What I think is really bad, is how JavaScript gives everybody IEEE754 numbers and selsl them as "numbers"
11:58:13 <glittershark> olle: fixed-precision math is a thing too
11:58:16 <cocreature> glittershark: insert cost centres selectively, separate profiling and benchmarking, use ticky ticky profiling, …
11:58:16 <merijn> puregreen: The only reason it'd be bad is if it's too slow, but only you can say whether that's the case
11:58:18 <dminuoso> *especially* considering how garbage the average JS developer is
11:58:36 <glittershark> cocreature: :'(
11:58:44 <glittershark> feel like I need to go re-profile everything now
11:58:45 <merijn> puregreen: Also, read up on: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#hascallstack
11:59:14 <olle> dminuoso: consider our use-case at work: we use JS for our survey software to calculate so called skip logic (should this or that quesiton be skipped depending or previous answers)
11:59:14 <lavalike>  /win 24
11:59:17 <ab9rf> dminuoso: JS is one of many languages that either uses floats for everything, or "autopromotes" ints to floats under "appropriate" circumstances
11:59:18 <lavalike> oops
11:59:28 <cocreature> glittershark: to provide an example: https://ghc.haskell.org/trac/ghc/ticket/12893
11:59:29 <merijn> glittershark: Since GHC now supports dwarf you can use Intel VTune to profile! ;)
11:59:40 <cocreature> I’ve seen similar problems in my own code
11:59:49 <glittershark> > $899
11:59:49 <glittershark> lol
11:59:51 <lambdabot>  <hint>:1:1: error:
11:59:52 <lambdabot>      parse error on input ‘$’
11:59:52 <lambdabot>      Perhaps you intended to use TemplateHaskell
12:00:03 <ab9rf> dminuoso: worse yet are the people who view this as a "featur"
12:00:06 <merijn> glittershark: Free for non-commercial development, though
12:00:25 <glittershark> merijn: this is commercial
12:00:28 <cocreature> you can also just throw perf at it
12:00:29 <glittershark> I'm writing Haskell at work
12:00:47 <cocreature> but even with DWARF, I didn’t manage to get much useful information out of that
12:00:48 <merijn> glittershark: Anyway, VTune is *by far* the best profiling tool I've ever used. If your company cares about performance, they can chuck 800$ at a license :p
12:01:00 <ab9rf> $800 is peanuts for a business
12:01:02 <merijn> cocreature: Perf is hardly understandable with C/C++
12:01:02 <puregreen> merijn: I know about HasCallStack, the reason I want automatic call stacks is that I'd really like to avoid adding HasCallStack to probably a thousand (literally) different places
12:01:03 <dminuoso> ab9rf: Committee members even.
12:01:12 <glittershark> yeah I could probably get them to buy this
12:01:32 <dminuoso> ab9rf: Ive talked to one of them on numerous times. He strongly believes it's a good thing and makes things simpler. The willingness of JS to make things "fit" is a great thing.
12:01:37 <merijn> glittershark: Might wanna play with it a bit first on the non-commercial license to see if it's at all useful for Haskell
12:01:41 <merijn> glittershark: I haven't tried yet
12:01:49 <cocreature> merijn: for c++ I did at least manage to get a lot of useful info out of it, especially in combination with flamegraphs :)
12:01:50 <glittershark> yeah I'll give it a shot
12:01:55 <dminuoso> And since it follows specific and learnable rules, its predictable and deterministic. That you have to be a genius to remember the state-machine-type-of definition of ECMAScript is another story
12:01:57 <olle> glittershark: fixed-point is what's needed for economical applications.
12:02:12 <glittershark> we're quite perf-critical so this would make sense
12:02:17 <olle> one should always use DECIMAL(10, 2) in SQL for money.
12:02:22 <merijn> cocreature: I tried perf, but only after using VTune during my internship, it sucked...
12:02:32 <glittershark> in the meanwile, ticky-ticky seems worth checking out
12:02:45 <cocreature> merijn: sure, I never said it’s great. I said it’s useful :)
12:02:49 <ab9rf> dminuoso: i've met quite a few people who are ardent believers that the programming language should work as hard as possible to give whatever code is presented to it a "meaning"
12:03:07 <merijn> glittershark: VTune generally inserts about 15-20% overhead for profiling, but it will tell you *everything*, cache misses (and which cache), pipeline stalls, pipeline saturation, branch (mis)prediction, etc.
12:03:13 <glittershark> ooh
12:03:38 <glittershark> I mean, as long as the 15-20% is roughly even across workloads that's fine
12:03:49 <glittershark> could be 500% as long as it's consistent
12:03:51 <MarcelineVQ> ab9rf: denotational semantics?
12:03:53 <ab9rf> olle: DECIMAL(10,2) would have failed in Zimbabwe
12:04:02 <merijn> glittershark: And lots of detailed docs explaining what every metric means. Plus it lets you directly tie these metrics to assembly (or DWARF lines!)
12:04:14 <glittershark> the bit that scares me about -profile in GHC is this new knowledge that it makes different things slower by different amounts
12:04:28 <merijn> glittershark: It uses the hardware performance counters, so doesn't require modified executables at all
12:04:43 <glittershark> and it works with dwarf! that's cool
12:04:48 <merijn> glittershark: Whereas GHC -profile can disable some optimisations
12:05:05 <ab9rf> MarcelineVQ: not something i'm familiar with enough to comment
12:05:23 <merijn> glittershark: For C++ it was amazing, it'd just go "you have x% branch mispredictions on line 734 of file foo.cpp"
12:05:26 <glittershark> yeah fusion is especially important to us because the thing we're optimizing is a big stream processing pipeline
12:05:40 <glittershark> geez
12:05:45 <glittershark> haskell's probably not that good
12:06:11 <glittershark> especially since case analysis can cause branches to get compiled in our out during optimization entirely! 
12:06:14 <glittershark> but it's something
12:06:23 <merijn> glittershark: Yeah, doubt it'd be as good for haskell, since that mapping to bytecode is less predictable. But might still be better than -profile, etc.
12:07:02 <glittershark> I just want a real flame-graph :(
12:12:48 <ClaudiusMaximus> is there already a package with (Natural, STRef s a) wrapped up nicely and safely so you can have Ord as well as just Eq?  I wrote a module but happy to discard it if there's something better out there
12:13:37 <dmwit> ClaudiusMaximus: I, too, am sad that STRef, IORef, StableName do not have Ord instances.
12:14:10 <dmwit> ClaudiusMaximus: At least with StableName there is hashStableName, which lets you put them in finite maps.
12:14:14 <cocreature> ClaudiusMaximus: I wrote a package like that for IORefs some time ago (https://hackage.haskell.org/package/ioref-stable-0.1.1.0/docs/Data-IORefStable.html). I’d be happy to accept a PR that also adds support for STRef
12:14:20 <dmwit> ClaudiusMaximus: Perhaps that's enough for you.
12:15:11 <dmwit> cocreature: Nice! I didn't know about Unique, which looks nice.
12:20:45 <ClaudiusMaximus> cocreature: my hack was defining a new Monad (a StateT over ST, but with the implementation hidden to avoid breakage by user code), so you need to liftST or so to use other ST code, with all the interoperability problems that implies
12:21:28 <ClaudiusMaximus> (ie, the ST code can't get back into the ST-with-Ord-refs world)
12:22:35 <cocreature> hm yeah, for ST you can’t just use Data.Unique
12:35:00 <jgt> I have this line `mLocation <- pure mRadius >> runDB $ getBy $ UniqueLocation $ userPostcode u`. I want `runDB` to run only if `mRadius` is a Just. How do I make this short-circuit?
12:35:33 <jgt> I'm able to do this with `runMaybeT`, but it seems like there's probably a simpler way
12:36:35 <cocreature> :t for_ :: Applicative f => Maybe a -> (a -> f b) -> f ()
12:36:37 <lambdabot> Applicative f => Maybe a -> (a -> f b) -> f ()
12:37:02 <cocreature> so something like "for_ mRadius $ \mLocation -> runDB $ getBy …"
12:39:22 <jgt> cocreature: I'm doing it like this `mLocation <- for_ mRadius $ \_ -> runDB $ getBy $ UniqueLocation $ userPostcode u`, but the mLocation ends up being unit
12:39:50 <jgt> which I guess is suggested in the type signaure
12:39:53 <jgt> signature*
12:39:58 <cocreature> well that’s not what I suggested :)
12:40:05 <cocreature> so maybe try doing what I suggested instead
12:40:23 <cocreature> oh sry, misread your code
12:40:37 <cocreature> jgt: so what would you want mLocation to be if mRadius is Nothing?
12:40:45 <jgt> cocreature: also Nothing
12:41:00 <cocreature> ok, then use "mLocation <- for mRadius $ \_ -> …"
12:41:06 <cocreature> :t for
12:41:08 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
12:41:11 <cocreature> :t for_
12:41:12 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
12:41:43 <cocreature> depending on the code you could also consider traverse/mapM which is just "for" with the arguments flipped
12:41:43 <jgt> cocreature: that's exactly it :) thanks!
13:12:23 <chessandgo> are tchans fast enough that using them to implement the actor model (ala erlang style) wouldn't be worst than just giving the appropriate function the resources (like datbase handles)
13:15:09 <merijn> chessandgo: TChans are pretty fast
13:17:38 <zachk> chessandgo, if you want the actor model in haskell check out cloud haskell, they already wrote it years ago :) 
13:20:58 <chessandgo> zachk: is that maintained/good for local stuff?
13:21:10 <chessandgo> its in my tabs, but I hear about how its never used
13:21:24 <chessandgo> I was going to implement a simple actor like process because I stepped it up
13:21:53 <chessandgo> before*
13:21:57 <zachk> its decently maintained, docs are ok for it, it still works with the current haskell, I use it in my unfinished mud project no problem, you can even have actors communicate between processes, even supposedly on different machines
13:22:04 <zachk> it has monitors
13:22:12 <zachk> its like erlang 
13:22:42 <chessandgo> nice nice
13:23:02 <chessandgo> lastly, does anyone consider actors an antipattern? Theyre kinda like objects and maintain their own state
13:24:04 <zachk> chessandgo, I use some STM TVars with my actors for global state of the game as well
13:25:22 <chessandgo> ive been thinking of putting the state of the world just all within ram and try out some STM magic. Otherguys have worlds within MB sizes, size its not that bad
13:25:29 <chessandgo> use redis to backup the world on shutdown
13:26:56 <zachk> I tried neo4j, a graph database for my mud, it was slow at times , like 2 seconds to do a command , also getting the data out of the database took a lot of code that eventually became unreadable
13:27:17 <zachk> I dont know if there are many dbases that are fast enough for an interactive game :( 
13:27:27 <Eduard_Munteanu> Why would you want a graph database for a MUD?
13:27:31 <zachk> the slowness might just have been the one I chose
13:27:35 <chessandgo> wait are you the same guy that was using graph databases from before?
13:27:46 <zachk> not sure
13:27:50 <chessandgo> rooms via doors could been seen as a directioned graph Eduard_Munteanu 
13:28:52 <zachk> also the object being contained in other objects make a graph as well 
13:29:17 <chessandgo> if I actually keep my rooms in datbase and not in ram (and serialize it at shutdown)
13:29:30 <chessandgo> im just using look up and hashes in redis
13:30:10 <chessandgo> roomid:1       [hash list of connected rooms] [list of items] room description
13:30:35 <zachk> can the values in redis be compound , nested, or hashes/maps? 
13:30:43 <glittershark> redis has hashes, yes
13:30:49 <zachk> nice
13:31:03 <glittershark> you can also just like
13:31:05 <zachk> i have seperate room descriptions and room titles, might implement a brief command someday 
13:31:08 <glittershark> store Binary data
13:31:50 <chessandgo> you can store multiple values by using hashes as well
13:31:55 <chessandgo> (faking n-tuples)
13:32:12 <chessandgo> I have userid:1      [salt, hashedpassword]
13:32:17 <glittershark> also: key prefixes!
13:32:40 <chessandgo> I wrote a lua script that runs server side to make an arbitrary operation atomic
13:32:43 <chessandgo> pretty nice
13:32:52 <ab9rf> chessandgo: i used to work on mud software :)
13:33:33 <ab9rf> chessandgo: the ones i worked with kept the entire world in memory while running
13:34:15 <chessandgo> looks like thats what ill do ab9rf 
13:34:25 <chessandgo> did you serialize it in pieces, or one big blob
13:34:36 <ab9rf> one blob
13:34:43 <chessandgo> you think thats wise?
13:34:46 <ab9rf> no
13:34:55 <ab9rf> but hey, it was 1989, we didn't know better
13:35:12 <chessandgo> you probably wherent use a memory safe language or even a database!
13:35:18 <ab9rf> chessandgo: C
13:35:23 <ab9rf> chessandgo: and what's a database?
13:35:46 <ab9rf> the world save file was a flat text file
13:36:09 <chessandgo> are you about to tell me you could repair the world with a text editor
13:36:27 <ab9rf> chessandgo: except that most text editors couldn't open files that large
13:36:37 <ab9rf> again, 1989
13:36:37 <chessandgo> not even emacs?
13:36:50 <Ariakenom> Did you even support ö?
13:36:55 <ab9rf> Ariakenom: no
13:37:02 <chessandgo> my mud supports unicode
13:37:05 * chessandgo flexes
13:37:09 <ab9rf> Ariakenom: but unicode didn't exist then
13:37:18 <ab9rf> Ariakenom: so there was nothing to support
13:37:35 <chessandgo> could I put a \bel in my name to make everyones terminal ding when my name came on screen
13:37:49 <nklap> Hey
13:38:06 <Eduard_Munteanu> Hi.
13:38:21 <chessandgo> did you have any special parsers
13:38:32 <chessandgo> been reading about combinator parsers 
13:40:25 <Eduard_Munteanu> 1989 sounds like that time when you'd enter a 3-letter name on an arcade machine if you made the highscore list.
13:40:37 <ab9rf> chessandgo: i think we prohibited that
13:40:59 <ab9rf> Eduard_Munteanu: that's how it worked on the pinball machines i used to play back then
13:41:09 <Ariakenom> ab9rf: international/multilingual text character encoding system in August 1988, tentatively called Unicode
13:41:14 <Ariakenom> lol
13:41:29 <Ariakenom> exactly 1 year earlier :p
13:41:37 <ab9rf> heh, well, we never heard of it
13:41:54 <chessandgo> now we can have emojis in our MUDs
13:41:56 <ab9rf> some of the european muds did have various forms of alternate code page support
13:41:57 <chessandgo> surely we have come far
13:43:12 <ab9rf> i could probably whip up a driver that did what those old systems did in a day or less
13:43:26 <ab9rf> it's not interesting to me anymore, though
13:46:02 <chessandgo> what kinda of parser did you use for the game commands?
13:46:41 <ab9rf> split at the first space, then prefix match
13:46:50 <chessandgo> :(
13:47:03 <ab9rf> if i recall correctly, at least
13:47:16 <chessandgo> did you have a statemachine and custom parser for the login process
13:47:24 <ab9rf> um, no?
13:47:53 <chessandgo> unless they where typing commands like `username etc` and `password etc` instead of just writing them on a line when prompted
13:48:33 <ab9rf> it was a state machine of sorts, i guess
13:48:42 <ab9rf> when you weren't logged in, you could only issue two commands
13:48:46 <ab9rf> well, four
13:49:06 <ab9rf> login, create new player, who is on, and close-session
13:49:18 <ab9rf> maybe also help and yell-at-operator
13:49:26 <chessandgo> I had a primative statemachine before the rewrite, but have been investigating other methods because it felt like a dead end
13:49:47 <ab9rf> i think we used a privilege level system for that sort of thing
14:00:58 <reptar_> how do i message lambdabot privately?
14:01:09 <glittershark> reptar_: /q lambdabot
14:01:41 <reptar_> thanks
14:04:06 <merijn> or /msg
14:09:25 <nitrix> Would it be possible to have a n-tuple fst? I'm thinking fst :: AtLeastTuple1 t => t a -> a -- instance AtLeastTuple1 (,x), instance AtLeastTuple1 (,x,y))
14:10:05 <nitrix> Though, I know that's the wrong syntax for the instances. If I wanted to keep the tuples intact, I think I'd need type aliases to swap stuff?
14:10:54 <merijn> nitrix: Lens has that, afaik
14:11:05 <merijn> _1 works on any tuple, afaik
14:11:16 <nitrix> Correct :o !
14:11:33 <nitrix> Hopefully I can find my way in the abstraction spaghetti :P
14:11:50 <merijn> nitrix: Just ping edwardk :)
14:11:57 <ChaiTRex> dmwit: Thanks for the pointer to GADTs. They seem to be very nice.
14:12:37 <nitrix> merijn: I only dare asking him the though questions. I fear his time's too valuable x3
14:15:12 <nitrix> class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s where
14:15:14 <nitrix> _1 :: Lens s t a b
14:15:40 <nitrix> Oh it's actually simple. Each tuple from 1 to 16 has an instance for Field1 that implements _1 as a lens. Oh well.
14:18:17 <ab9rf> nitrix: that's the only way to do it currently
14:19:16 <ab9rf> i'm not sure that _1 would work on a sufficiently large n-tuple
14:19:26 <ab9rf> beause the instances haven't been defined
14:19:47 <nitrix> > view _1 (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20)
14:19:49 <lambdabot>  error:
14:19:49 <lambdabot>      • Could not deduce (Num t0)
14:19:49 <lambdabot>        from the context: (Num t, Num s, Num r, Num q, Num p, Num o, Num n,
14:19:57 <ChaiTRex> How can I, at compile time without Template Haskell, use one primitive String if the machine is big-endian and another if it's not?
14:20:05 <nitrix> > view _1 (1,2,3)
14:20:07 <lambdabot>  1
14:20:18 <nitrix> ab9rf: Seems right.
14:20:41 <ab9rf> it's just that people rarely use explicit n-tuples for n larger than about 8 or so
14:21:04 <mimi_vx> ab9rf: recommends max 5-tuple
14:21:16 <ab9rf> that lens defines them up to n of 16 is surprising to me
14:21:36 <ab9rf> the highest i'd seen elsewhere was 9, i think
14:22:06 <ab9rf> ChaiTRex: what are you attempting to acomplish?
14:22:47 <nitrix> > 's' - 'a'
14:22:49 <lambdabot>  error:
14:22:49 <lambdabot>      • No instance for (Num Char) arising from a use of ‘-’
14:22:49 <lambdabot>      • In the expression: 's' - 'a'
14:23:03 <nitrix> > ord 's' - ord 'a'
14:23:05 <lambdabot>  18
14:23:14 <nitrix> It defines 18 tuples, gosh.
14:23:23 <nitrix> Anyhow. Thanks :D
14:23:54 <ab9rf> i don't know of any way to detect endianness at compile time that doesn't involve using template haskell
14:24:54 <ChaiTRex> ab9rf: I want to compile literals for big fixed-width integers using primitive String literals, which are Addr#s to the bytes of the primitive String. To make it work correctly, I need one literal for each endianness.
14:24:58 <nitrix> http://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-ByteOrder.html
14:25:05 <nitrix> tagretByteOrder :: ByteOrder
14:25:22 <ChaiTRex> How can I conditionally compile on targetByteOrder?
14:25:31 <ab9rf> ChaiTRex: using template haskell :)
14:25:43 <ChaiTRex> Is there a way with type literals?
14:25:51 <mauke> CPP
14:26:16 <ChaiTRex> What header file and constant can I use for that?
14:27:38 <ab9rf> there are architecture ifdefs (i386_HOST_ARCH, etc.) from which you could infer endianness
14:27:41 <glguy> Don't both doing anything fancy
14:27:47 <glguy> just use case on targetByteOrder
14:27:51 <glguy> bother*
14:28:07 <ab9rf> glguy: that makes the decision at runtime, not at compilation time
14:28:15 <ab9rf> glguy: at least, in theory
14:28:18 <glguy> ab9rf: nope, thanks to optimizations
14:28:21 <ab9rf> it may be optimized
14:28:49 <ab9rf> and, yes, i would expect that it would be optimized 
14:28:56 <mauke> ChaiTRex: I have an endian.h and BYTE_ORDER
14:29:18 <ChaiTRex> mauke: Thanks :)
14:29:28 <glguy> ChaiTRex: You don't need TH or CPP, just use normal Haskell
14:30:15 <ab9rf> the compiler is most likely being smarter than you are
14:31:05 <ChaiTRex> glguy: I might end up doing that. It looks like endian.h isn't available always.
14:31:33 <ab9rf> ChaiTRex: i'd try doing it the obvious way first, and only worry about improving it if it doesn't work acceptabl
14:32:46 <ChaiTRex> I'm looking for speed as the foremost goal (after correctness, of course).
14:33:12 * hackage hlint 2.1.10 - Source code suggestions  http://hackage.haskell.org/package/hlint-2.1.10 (NeilMitchell)
14:43:04 --- mode: glguy set +v bas_
14:43:18 <bas_> Am I crazy or does `elem` have a big O of O(n)
14:43:40 <ChaiTRex> bas_: It does.
14:43:44 <bas_> the source seems to indicate a full list traversal
14:43:48 <noidedsuper> It has to
14:43:51 <ChaiTRex> bas_: Use a Set or something if you want speed.
14:44:03 <noidedsuper> Since it doesn't know if the list is sorted or not. Or even if the list *can* be sorted since it's just an Eq constraint, not an Ord
14:44:06 <monochrom> With merely Eq you have to do this.
14:45:26 <bas_> ah sorry for the tad bit stupid question
14:45:35 <bas_> that is completely logical
14:45:46 <bas_> you can not order the list
14:46:15 <bas_> my bad
14:46:15 <ChaiTRex> bas_: Even if you sort it, it has to traverse the list to get into position each time for binary search, since it's not random access.
14:46:29 <ChaiTRex> bas_: You'd need an array or vector to do a binary search.
14:46:44 <bas_> because it is a linked list right?
14:46:48 <ChaiTRex> bas_: Yep.
14:46:56 <bas_> same reason why we prefer a prepend over an append
14:47:07 <ChaiTRex> bas_: That's right.
14:47:19 <ChaiTRex> It has to construct an entirely new list for append.
14:48:20 <dmwit> Even if you can order the list, doing so first is slower than O(n).
14:48:30 <glittershark> !type fmap (flip id)
14:48:36 <glittershark> er
14:48:40 <glittershark> @type fmap (flip id)
14:48:41 <lambdabot> Functor f => f b -> f ((b -> c) -> c)
14:48:48 <glittershark> is this the Yoneda lemma?
14:48:53 <ChaiTRex> Is GHC guaranteed to have the same endianness on the compiler machine and the target machine or can it cross-compile?
14:49:12 <dmwit> I don't think cross-compilation is well supported yet, but it's planned and under current development.
14:49:27 <ChaiTRex> Ahh, OK. I'll work on making it work regardless.
14:49:31 <ChaiTRex> Thanks.
14:49:37 <dmwit> But you ask a good question, because TH runs on the host and so there's fun endian-ness questions there.
14:49:48 <glguy> ChaiTRex: If you're using GHC.ByteOrder.targetByteOrder then you'll get the byte order of the target, so you'll be all set
14:50:00 <ChaiTRex> glguy: OK, thanks for the function name.
14:50:17 <glguy> It's not a function, just a ByteOrder
14:50:40 <ChaiTRex> Ahh, yes :)
14:51:18 <monochrom> It would be awkward to say "the value name" and "what value do I use to print a string?"
14:52:04 <glguy> for printing a string you might want a function
14:52:10 <ZeuPiark> bye
14:52:14 <mauke> no, a value
14:52:18 <mauke> of type IO ()
14:52:24 <glguy> Where does the string go?
14:52:31 <mauke> stdout, usually
14:52:37 <monochrom> yeah well bad example but how about what value to use to read stdin.
14:52:47 <dmwit> The amount to which you two are cross-communicating cracks me up.
14:53:07 <monochrom> Or what value in parsec to check eof
14:53:09 <glguy> We're trying out for Arrested Development
14:53:21 <dmwit> =D
14:53:50 <mauke> for example, 'print 42' is a value that can be used to print a string
14:54:42 <glguy> Well there's always value in the banana stand
14:54:44 <ab9rf> can i use it for anythig else?
14:54:59 <monochrom> Maybe they're all thunks and we can say thunk.
14:55:18 <mauke> > length [print 42, print 42, print 42]
14:55:21 <lambdabot>  3
14:55:23 <ab9rf> what if i don't want to print 42?
14:55:32 <glguy> ab9rf: Just ask mauke for a different value
14:55:47 <ab9rf> glguy: seems inefficient
14:55:56 <glguy> ab9rf: profile first
14:56:06 <mauke> just pipe it into sed 's/42/whatever/'
14:57:02 <ab9rf> i need to stop laughing at this or my son will ask me to explain what i'm laughing at and i'll be totally hosed
14:57:57 <monochrom> What function do I use to profile mauke?
14:58:22 <dmwit> ?remember glguy <ab9rf> what if I don't want to print 42? <glguy> Just ask mauke for a different value <ab9rf> seems inefficient <glguy> profile first
14:58:22 <lambdabot> Done.
14:58:32 <merijn> monochrom: I believe that profiling people is considered racist/discriminatory...
14:59:16 <monochrom> Like the way the Olympic Games measure runner speeds?
15:00:23 <glguy> If the Olympics worked like GHC the runners would have to wear 50 pounds of profiling gear to have their performances analyzed
15:00:48 <monochrom> Haha
15:01:05 <chessandgo> atleast we'd make sure theyre not cutting corners and doing illegal optimizations
15:01:20 <monochrom> @remember glguy If the Olympics worked like GHC the runners would have to wear 50 pounds of profiling gear to have their performances analyzed
15:01:21 <lambdabot> It is stored.
15:01:52 * glguy quits while he's ahead
15:02:59 <chessandgo> sometimes I feel like an absolute fool
15:03:23 * chessandgo couldnt figure out why he wasnt getting a namespace conflict while importing qualified
15:04:00 <nitrix> 21:55:25           ab9rf | glguy: seems inefficient
15:04:02 <nitrix> 21:55:34          @glguy | ab9rf: profile first
15:04:05 <nitrix> You guys are great x]
15:06:12 <ab9rf> chessandgo: why were you trying to get a namespace conflict?
15:07:17 <chessandgo> I got a namespace conflict, imported differently, then undid it because it was cumbersome, and suddently it "worked"
15:07:24 <chessandgo> even though I undid "everything"
15:08:01 <ChaiTRex> Can Template Haskell figure out the type of the resulting expression that's expected in a splice?
15:09:16 <glguy> splices are pre-typechecking
15:09:50 <merijn> glguy: Typed TH splices aren't
15:10:23 <ChaiTRex> OK, I'll look up typed TH. Thanks.
15:10:36 <glguy> That probably won't help either
15:10:57 <glguy> but if you can  give more information about what you're trying to do we can better help
15:11:47 <ChaiTRex> Just trying to get the type-level natural for the required type at a splice site (if V 5 is required, I need my TH function to be able to get 5).
15:12:12 <ChaiTRex> I know the type will be V n for sure.
15:12:54 <glguy> I don't think typed splices work at the type level (ironically?)
15:12:57 <ChaiTRex> Also, if n isn't known, I'd like to be able to handle that.
15:13:30 <ab9rf> if you're not careful, your code will be eaten by an ouroborous
15:13:47 <ChaiTRex> Haha
15:13:59 <ab9rf> "this expression is well-typed if and only if it is well-typed"
15:15:35 <monochrom> Everyone loves my ouroboros, but my ouroboros loves only me.
15:15:51 <mauke> this expression is well-typed if and only if it is, well, typed
15:16:13 <MarcelineVQ> everyone is full of beans today
15:16:30 <monochrom> Actually maybe s/loves/eats/ works better.
15:17:27 <glguy> ChaiTRex: I don't think you're going to be able to do what you want here
15:18:37 --- mode: glguy set +v Titor
15:18:52 <ChaiTRex> If not, I'll just do it a more long-winded way.
15:19:33 --- mode: glguy set -v Titor
15:19:33 <glguy> Titor: "Set operations" http://hackage.haskell.org/package/base-4.11.1.0/docs/Data-List.html#g:20
15:21:11 <Titor> Intersect sounds like the right one I'm looking for thanks.
15:21:57 <fresheyeball> Anyone know how to do this?
15:22:09 <fresheyeball> (a -> b -> c) -> TVar a -> TVar b -> IO (TVar c)
15:22:11 <fresheyeball> ?
15:22:24 <fresheyeball> Is that out there somewhere?
15:22:54 <monochrom> What should it do?
15:23:01 <noidedsuper> thingy fun a b = atomically $ fun <$> a <*> b 
15:23:08 <noidedsuper> That should work right? 
15:23:20 <noidedsuper> Wait no 
15:23:27 <fresheyeball> noidedsuper: TVar is not a functor
15:23:28 <merijn> fresheyeball: You need readTVar's around a and b
15:23:47 <fresheyeball> merijn: right, but I want (TVar c) to stay uptodate
15:23:47 <noidedsuper> add some `readTVars` in there 
15:24:03 <fresheyeball> I know I need `retry` but don't see a clean way
15:26:13 --- mode: glguy set +v oskar
15:27:06 <dmwit> fresheyeball: Perhaps you mean `(a -> b -> c) -> TVar a -> TVar b -> TVar c -> IO ()`?
15:27:21 <dmwit> Oh, I see what you want.
15:27:33 <noidedsuper> Do you mean that you want the value of c to change whenever either a or b changes? 
15:27:36 <dmwit> You're not going to be able to guarantee that the three stay in synch.
15:27:40 <fresheyeball> dmwit: that would be internal I think
15:27:52 <fresheyeball> noidedsuper: yes
15:28:10 <dmwit> If you want them to stay in synch, write to the `TVar c` in each `atomically` block that writes to the `TVar a` and `TVar b`.
15:28:13 <dmwit> No other choice.
15:28:47 <dmwit> If you're okay with them drifting out of synch on occasion, then just fork a thread to run a loop that reads the two input `TVar`s and writes to the freshly created one.
15:29:10 <fresheyeball> dmwit: my situtation is blessedly simple
15:29:21 <fresheyeball> I want a TVar for a value from Data.Configurator
15:29:51 <fresheyeball> unfortunately, the type I actually want is essentailly a tuple of two conf options
15:30:16 <fresheyeball> TTL <$> require cfg "foo" <*> require cfg "bar"
15:30:25 <fresheyeball> works for getting it once
15:31:53 <dmwit> I have no idea why the things you just said lead you to want the operation you're asking for.
15:32:38 <monochrom> Especially it sounds like just one TVar (X,Y)
15:33:31 <monochrom> Or if you say "data Z = TTL X Y; TVar Z" that's OK too.
15:33:33 <dmwit> I don't really understand why TVar is even involved, to be honest. But I'm willing to suspend disbelief on that part for now if necessary.
15:33:54 <fresheyeball> I am just using TVar so I can query the current config value later
15:33:59 <fresheyeball> with readTVarIO
15:34:38 <monochrom> An IORef suffices for that.
15:34:51 <monochrom> And even that is probably an overkill.
15:35:01 <fresheyeball> well I am paranoid 
15:35:05 <fresheyeball> and went with TVar
15:35:35 <monochrom> No, I don't believe you. A paranoid person doesn't even allow any mutability at all.
15:35:47 <fresheyeball> monochrom: haha
15:36:30 <hpc> i never use variable names
15:36:38 <hpc> what if someone unsafeCoerces them to IORef?
15:36:51 <hpc> my whole program is one big lambda
15:36:52 <dmwit> Setting aside why you want `TVar MyConfigurationType` instead of `MyConfigurationType`, why does this lead you to want `(a -> b -> c) -> TVar a -> TVar b -> IO (TVar c)`?
15:37:06 <monochrom> Wait but lambda contains variable names too.
15:37:32 <monochrom> Also you can unsafeCoerce (1+2*3) so you don't need variable names either.
15:37:49 <hpc> monochrom: i see what you mean
15:37:53 <hpc> monochrom: maybe i should use TVars too
15:37:55 <hpc> :D
15:39:22 <monochrom> Perhaps first why need mutability, when and where the mutation happens.
15:39:41 <hpc> i also am curious where concurrency is needed here
15:40:03 <hpc> because that would decide if TVar is actually needed here
15:40:07 <fresheyeball> https://hastebin.com/lojijoyoqu.php
15:40:11 <hpc> because then you're fiddling with transactions and all that
15:40:16 <fresheyeball> I have this handy fellow, and wanted to re-use
15:40:22 <fresheyeball> that's my (poor?) motivation
15:40:43 <Eduard_Munteanu> Mutability is the root of all evil. Proof: it generates heat, hence it fuels the fires of hell.
15:40:55 <dmwit> I see I'm going to need my teeth-pulling equipment.
15:41:08 <monochrom> With that, HVAC is the root of all evil too.
15:41:13 <ab9rf> mootability
15:41:16 <dmwit> fresheyeball: Take me all the way down the garden path. I still haven't (yet) arrived at `(a -> b -> c) -> TVar a -> TVar b -> IO (TVar c)`
15:41:58 <buhman> is there a sane way to do something like: "map (f . g . h) xs" except where the result is something like: "(f(g(h(x))), g(h(x)), h(x))"?
15:42:24 <hpc> :t scanl
15:42:25 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
15:42:28 <Eduard_Munteanu> > scanl ($) [f, g, h] x
15:42:31 <lambdabot>  error:
15:42:31 <lambdabot>      • Couldn't match type ‘[a]’ with ‘a0 -> [a]’
15:42:31 <lambdabot>        Expected type: [a] -> a0 -> [a]
15:42:35 <dmwit> :t \f g h -> map (\x -> (f (g (h x)), g (h x), h x))
15:42:37 <lambdabot> (b -> a) -> (c -> b) -> (t -> c) -> [t] -> [(a, b, c)]
15:43:06 <hpc> > scanl ($) [f, g, h] z [x] :: [Expr]
15:43:06 <Eduard_Munteanu> > scanl (flip ($)) x [f, g, h]
15:43:08 <lambdabot>  error:
15:43:08 <lambdabot>      • Couldn't match expected type ‘[Expr] -> [Expr]’
15:43:08 <lambdabot>                    with actual type ‘[[a1]]’
15:43:09 <lambdabot>  [x,f x,g (f x),h (g (f x))]
15:43:09 <ab9rf> @pl \f g h x -> (f(g(h(x))), g(h(x)), h(x))
15:43:10 <lambdabot> flip flip id . (liftM2 ap .) . (`ap` (.)) . (liftM2 (liftM2 (,,)) .) . (. (.)) . (.) . (.)
15:43:23 <dmwit> These scanl things are great *if* f, g, and h are endofunctions.
15:43:47 <monochrom> But even then you have to convert [a,b,c] to (a,b,c)
15:44:00 <buhman> I think my question was imprecise
15:44:10 <dmwit> :t \f g h -> map (\x -> let hx = h x; ghx = g hx; fghx = f ghx in (fghx, ghx, hx)) -- in case some of them are expensive
15:44:11 <lambdabot> (b -> a) -> (c -> b) -> (t -> c) -> [t] -> [(a, b, c)]
15:44:19 <dmwit> buhman: me too
15:44:27 <buhman> "[(f(g(h(x))), g(h(x)), h(x)), ...]"
15:44:52 <dmwit> buhman: Oh, no, we all got that far.
15:44:55 <Eduard_Munteanu> Oh, a list of tuples? I still don't get it.
15:44:55 <hpc> ah, then Eduard_Munteanu's answer was perfect, except for maybe flipping it
15:45:00 <dmwit> We're humans with reasoning heads on our shoulders.
15:45:05 <hpc> oh wait what
15:45:29 <ab9rf> yeah, i thinl eduard wins the cookie
15:45:53 <dmwit> It's just that I included the `map` and the `scanl` racers didn't, assuming you were a human with a reasoning head on your shoulders. ;-)
15:47:42 <buhman> "map (\x -> scanl (flip ($)) x [f, g, h]) xs" seems perfect yeah
15:51:01 <monochrom> Human heads are overrated.
15:51:23 <ab9rf> most things are overrated
15:51:31 <dmwit> The smartest heads I know of are all human.
15:51:41 <monochrom> Human heads are the #1 cause of human problems.
15:52:05 <dmwit> Hm. I think you might have enjoyed being in France a little while ago.
15:52:23 <dmwit> Heard they were real fond of getting rid of problems.
15:53:09 <ab9rf> forehead problems
15:53:22 <hpc> nah, they were just mathematicians
15:53:33 <hpc> trying to separate the problem from outside context
15:57:45 <ChaiTRex> glguy: I got it! https://lpaste.net/5169372055635755008
15:58:28 <dmwit> oh yikes
15:59:25 <ChaiTRex> I'm hoping there's a way to shorten it somewhat.
16:00:57 <dmwit> Turn on ScopedTypeVariables, add a `forall n.`, and write `let bits = natVal (undefined :: UInt n) in [|| {- ... -} ||]`?
16:01:25 <dmwit> Or even `natVal (Proxy :: Proxy n)`.
16:02:45 <dmwit> I assume the `...` mentions `value` or something?
16:04:32 <glguy> ChaiTRex: let me see it when it's done. I don't understand what that's accomplishing yet that you couldn't do without template Haskell
16:12:33 <fresheyeball>  /join #haskell-beam
16:12:39 <ChaiTRex> dmwit: That works. Thanks.
16:12:39 <fresheyeball> ick sorry folks
16:12:47 <fresheyeball> \join #haskell-beam
16:12:50 <fresheyeball> wtf
16:12:53 <fresheyeball> now I am confused
16:13:00 <glguy> No leading space
16:13:09 <fresheyeball> \join #haskell-beam
16:13:14 <ChaiTRex> fresheyeball: Type "I'm typing: ', then what you're typing.
16:13:23 <zachk>  forward slash? /
16:13:26 <ChaiTRex> fresheyeball: Let's see what you're typing.
16:13:29 <fresheyeball> I didn't have a leading space
16:13:46 <fresheyeball> got it
16:13:50 <fresheyeball> not sure what is different
16:14:08 <johnw> does anyone know how to serve a wai StreamingBody using servant?
16:14:55 <ChaiTRex> dmwit: Right now it just does fromInteger, which gives an error with the input Integer as the message. Still have to implement things.
16:15:11 <ChaiTRex> dmwit: So, I'm getting an error with the number of bits that hackery got.
16:18:11 <ChaiTRex> Sorry, `[|| fromInteger bits ||]` to be more specific.
16:20:06 <dmwit> Haven't used TH much. What's [|| do?
16:20:24 <ChaiTRex> dmwit: It's a typed TH quoter.
16:20:37 <ChaiTRex> dmwit: Like [| |], but it's TExp a instead of Exp.
16:20:46 <dmwit> I see.
16:21:02 <dmwit> Well, I too will be interested to see what you end up doing with this.
16:21:40 <ChaiTRex> OK, I'll show you if I get to a working initial version.
16:21:44 <ChaiTRex> (and glguy)
16:27:28 <rish> I am trying to build a web API interface for a Haxl data source (using servant and wai/warp), but I am unable to build a working composition and understand how the threads are working: `runHaxl` is called inside a handler code. It works if you make a requests slowly and let the data source fulfil the requests, but the moment you make multiple web requests, none of the connections complete (chrome shows
16:27:29 <rish> pending for everything). warp was also throwing a "thread killed by reaper", so I tried increasing timeouts everywhere but I am not sure how to further debug this.
16:36:04 <ab9rf> don't fear the reaper
16:44:03 <ddellacosta> is Haskell poorly suited to writing audio software?
16:44:15 <Axman6> depends what you mean
16:44:40 <ddellacosta> I guess I mean, something that requires "soft real-time" reactivity, if that's not too vague
16:44:43 <Axman6> there's people who use it for live programmed musical performances
16:44:52 <ddellacosta> okay well that is about what I was interested in so...
16:44:54 <ddellacosta> thanks Axman6
16:45:06 <ddellacosta> btw do you know what libraries/apps folks are using for that?
16:45:47 <Axman6> ddellacosta: using haskell directly for that would probably be difficult, but there are also some very interesting projects for producing hard real-time C from Haskell which would probably be ideal
16:45:57 <ddellacosta> interesting--got any pointers?
16:46:04 <Axman6> um, I'll see if I can find it. I think the most common one controls supercollider or something
16:46:22 <ddellacosta> ah yeah, so something that sends the protocol SC uses, which I'm forgetting the name of now
16:46:30 <Axman6> https://tidalcycles.org/
16:46:34 <ddellacosta> right, thanks
16:47:10 <ddellacosta> I'm wondering if I should instead look at rust, since I want to get into the nitty-gritty of writing oscillators and whatnot from scratch
16:47:36 <ddellacosta> seems like laziness would make it hard to anticipate behavior for audio
16:47:37 <Axman6> hmm, that's not loading for me, try https://en.wikipedia.org/wiki/TidalCycles
16:47:50 <ddellacosta> oh, it worked for me for whatever reason
16:47:57 <Axman6> you don't have to use laziness though
16:47:59 <ddellacosta> but yeah, I have heard of this particular project before
16:48:10 <ddellacosta> that's true, but then it seems kind of silly to use Haskell I guess. Maybe not
16:49:05 <Axman6> http://leepike.github.io/Copilot/ is an EDSL for writing hard real-time systems with guaranteed constant memory usage, pretty important for audio processing (though not what it was initially designed for, it was designed for monitoring embesses systems for NASA)
16:49:14 <ddellacosta> oh interesting
16:50:55 <ddellacosta> Axman6: thanks. This is all helpful.
16:50:57 <Axman6> imo Copilot would be an ideal place to write oscillators from scratch
16:51:03 <ddellacosta> yeah, looks promising
16:51:37 <Axman6> the language/DSL is a little difficult to get your head around from memory, you have to be fine with programming on infinite streams
16:52:29 <ddellacosta> yeah that is interesting considering it seems like the exact opposite of what you want to do for hard real-time, haha
16:52:42 <ddellacosta> very cool
16:53:07 <Axman6> well, that is really what hard real-time systems do, they infinitely process inputs to produce infinite outputs
16:53:13 * hackage recursion 0.1.0.0 - A recursion schemes library for GHC.  http://hackage.haskell.org/package/recursion-0.1.0.0 (vmchale)
16:53:30 <ddellacosta> yeah, I guess because I haven't really written anything in that world I have the wrong notion of what it really is
16:54:30 <ChaiTRex> Is there a way to force V 0 to be accepted as V n when n is a "rigid type variable"?
16:54:47 <hpc> no
16:54:57 <ChaiTRex> OK, thanks.
16:54:58 <hpc> a rigid type variable is a lot like the variables inside a higher-ranked forall
16:55:04 <hpc> it's forced to be "polymorphic"
16:55:04 <Axman6> the Ada hard real-time profile, the Ravenscar profile, mandates that all code that runs is in a thread which a) is only ever allowed to allocate at thread creation, and b) its body bust be a loop which cannot terminate
16:55:35 <ChaiTRex> Is there a way to do cases (like if n == 0, then this V 0 expression, else ...)?
16:55:53 <droplet> I've got two Lens'es focusing on different fields of the same object, how can I combine them into a Traversal' which looks at both fields?
16:56:32 <ddellacosta> droplet: ooh I just did this the other day...
16:56:49 <hpc> ChaiTRex: at the type level that's the constraint (n ~ 0)
16:56:50 <ddellacosta> droplet: I used this: `runGetter $ (,) <$> Getter sgVPCId <*> Getter sgGroupId`, you need Control.Lens.Reified I believe
16:57:09 <ddellacosta> substitute your fields for sgVBCId and sgGroupId
16:57:12 <hpc> you can't really do "if this constraint then X else Y", but you can get a sort of backwards solution with GADTs
16:57:35 <hpc> do a pattern match on some type that introduces (n ~ 0)
16:57:46 <ddellacosta> Axman6: do you do realtime programming professionally or are you just into it in general?
16:58:01 <droplet> ddellacosta: I'll give it a go, thanks
16:58:11 <hpc> ChaiTRex: so imagine V is some sized vector type (even though maybe that's not what you're thinking of)
16:58:23 <ChaiTRex> hpc: It essentially is what I'm doing.
16:58:30 <ddellacosta> droplet: yeah, I think that gives you a pair btw so not sure it's exactly what you want, but hopefully it gets you closer
16:58:35 <hpc> ChaiTRex: data V n where Nil :: V 0; Cons :: Int -> V n -> V (n + 1)
16:59:04 <hpc> when you make a pattern match on some value of type (V n), you have two cases
16:59:16 <hpc> actually, let's say instead of (n + 1) there it's (Succ n)
16:59:23 <hpc> so you match on Nil
16:59:45 <hpc> the type of the expression on the other side of that match has (n ~ 0)
17:00:02 <hpc> the type of the expression on the other side of the Cons match has (n ~ Succ m)
17:00:35 <ChaiTRex> Ahh, OK. Thanks. I'll try to make a function to handle the different cases and then return a V n.
17:00:58 <droplet> ddellacosta: yeah I was hoping for a list but this seems helpful
17:02:23 <ddellacosta> droplet: yeah, I apologize because I'm not particularly proficient at working with lens, and this is a bit of me cargo-culting something I picked up somewhere on the web. I also could not figure out how to write a Traversal to do what you are trying to do, so I ended up poking around and found that, which was close enough for my purposes.
17:03:58 <droplet> ddellacosta: my concern with that is that a Getter is one way, so this needs a Contravariant f
17:04:09 <ChaiTRex> hpc: Thanks. That helped me to simplify things greatly.
17:05:31 <ddellacosta> droplet: oh yeah, I ended up with this type sig: https://lpaste.net/3988673520056926208
17:06:30 <ddellacosta> again, this was mostly be banging my head against the type checker until it did what I needed, so YMMV. Someone who actually knows what they're doing with lens could give you a better answer I'm sure.
17:07:32 <hpc> ChaiTRex: GADTs are probably the best language extension ghc has
17:07:39 <hpc> they're my favorite at least
17:08:48 <madnight> think of them as Gadts
17:09:43 <pong> shouldn't cons take in a new guy also?
17:10:10 <pong> oh it's not generic nvm
17:17:13 <Gurkenglas> droplet, http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Unsound.html#v:lensProduct
17:18:32 <Gurkenglas> droplet, wait actually not quite
17:18:47 <Gurkenglas> Misread your question
17:19:01 <Gurkenglas> What you actually want is traversalUnion, waiting for my PR to be accepted x) https://github.com/ekmett/lens/pull/778
17:19:26 <Gurkenglas> uhh rephrasing as "pr in progress" i guess, seeing that comment
17:22:34 <droplet> What's unsound about this?
17:28:13 * hackage dependency 1.2.0.3 - Dependency resolution for package management  http://hackage.haskell.org/package/dependency-1.2.0.3 (vmchale)
17:29:30 --- mode: glguy set +v albeit
17:29:55 <albeit> I have a local package "connection" listed in stack.yaml packages, and it compiles fine with "stack build". But ghcid complains about a type mismatch when it runs: https://lpaste.net/5051900697180635136. Any way to get ghcid working again?
17:30:29 <Gurkenglas> droplet, those combinators can make unlawful optics if given overlapping arguments
17:30:47 <Gurkenglas> The haddock page lists examples for the two exported functions
17:31:16 <droplet> Ah I see, but they're fine if the arguments aren't overlapping?
17:31:17 <Gurkenglas> It is expected of you that you make sure the arguments are disjoint, ie you don't pass the same field twice
17:31:22 <Gurkenglas> yep
17:32:24 <Gurkenglas> The law "fmap (t f) . t g ≡ getCompose . t (Compose . fmap f . g)" seems like it ought to have a more elegant form
17:33:31 <Gurkenglas> I think I once found one for an Applicative law that somehow seems analogous
17:34:43 * hackage recursion 0.1.0.1 - A recursion schemes library for GHC.  http://hackage.haskell.org/package/recursion-0.1.0.1 (vmchale)
17:34:48 <ab9rf> why is it that the notion of "unlawful optics" is strangely enticing?
17:34:51 <Gurkenglas> Can someone find a line in the #haskell logs that contains "Gurkenglas", "Applicative" and "law"?
17:36:58 <Axman6> ddellacosta: I studied it at uni
17:39:00 <ddellacosta> gotcha
17:44:57 <ChaiTRex> Is there a way to define a TH (Lift (T n)) where n :: Nat such that the instance declaration can access the type-level natural? It seems like KnownNat n can't be added as a constraint.
17:45:34 <ChaiTRex> (which is a bit weird since the compiler knows it's a Nat)
17:49:47 <droplet> ChaiTRex: I may be missing something but doesn't natVal (undefined :: T n) work?
17:50:34 <ChaiTRex> No, it needs the constaint KnownNat n on the type signature, but that constraint isn't on Lift and if I add it, I get an error saying I can't constrain it.
17:50:44 <droplet> Ah I see, my mistake
17:51:02 <ChaiTRex> I wish it just needed to know the kind of n was Nat.
17:57:13 * hackage language-ats 1.7.0.2 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.7.0.2 (vmchale)
19:40:30 <ChaiTRex> droplet: Sorry for the delay. I think natVal can't work without the constraint, because n might be unknown at compile-time.
19:41:23 <ChaiTRex> Is there any way to go from a Nat to a Maybe Integer, where Just v is for compile-time-known Nats and Nothing is for the rest?
19:46:08 <mniip> ChaiTRex, no that would violate parametericity
19:46:36 <ChaiTRex> Ahh, OK. Thanks.
19:46:58 <ChaiTRex> Have to go.
19:47:00 <mniip> ChaiTRex, think about it like this,
19:47:14 <mniip> the Nat kind doesn't actually hold any values
19:47:28 <mniip> any computation you do on them, is a computation on instance dictionaries of KnownNat
19:47:50 <ChaiTRex> (if I get disconnected, I'll check the logs)
20:04:09 --- mode: glguy set +v wdanilo
20:04:50 <wdanilo> Hi guys! Does anywhere exist some Text-like library that has TextBuilder which after concatenating text chunks updates silently under the hood its representation so that only the first conversion to strict Text is pricey whiile the next ones are free ?
20:05:01 <glguy> The text package has a builder
20:05:47 <wdanilo> glguy: it has, but if you use `toLazyText` several times it builds the lazy text over and over again. What I want is that after first `toLazyText` usage, the next ones should be free
20:07:16 <wdanilo> glguy: this would require some hack under the hood, like unsafeperformio + ioref, but it would provide very simple api for users. Right now if you use the builder you have to take care of converting it to lazy / strict text once, because otherwise the conversion performed multiple times will be pricey
20:11:19 <chessandgo> is it possible, with type level programming, to have a function that operates on a partically applied type constructure, giving it a default value
20:11:42 <pavonia> wdanilo: Can't you just wrap it into a new type and cache the strict result?
20:12:25 <chessandgo> say I have the type
20:13:04 <wdanilo> pavonia: yup I can create my custom "text builder cache". I was rather thinking if there is any library / ready functionality that I'm not aware of. It seems simple, but actually making whole API around it (all the text operations etc) requires some amount of work
20:13:18 <chessandgo> data MudMessage = MudMessage T.Text Color Color Font          , but its only partically applied so it has Text and the colors, would it be possible to pass the partically applied type constructure that would then give it a defautlt value, else, if its fully applied, continue with what itd normall do
20:17:53 <pavonia> chessandgo: It might work with overlapping type classes that have an associated type class
20:18:13 <chessandgo> isnt overlapping type classes recommended against?
20:19:05 <pavonia> I think so
20:20:32 <chessandgo> its not that important that id go for malpractice
20:20:44 <chessandgo> lenses work too
20:21:46 <dmwit> chessandgo: data MudMessage = MudMessage T.Text Color Color (Maybe Font) -- ?
20:22:38 <dmwit> Terminology note: It's "partially applied", not "partically applied".
20:23:47 <chessandgo> id be a maybe field for everything,
20:24:12 <chessandgo> which would then be a higher kinded type then if I wanted to have the ability to plug in any constructur
20:24:15 <chessandgo> I think
20:31:23 <pavonia> chessandgo: What about this? https://lpaste.net/410969030959038464
20:32:54 <pavonia> Btw, I really love the simplicity lpaste has evolved into :p
20:43:32 <maerwald> only the code is simple, not the ui
20:43:50 <maerwald> not even a button to get the raw paste
20:46:39 --- mode: glguy set +v adjofun
20:47:11 <adjofun> Hello everyone! Is anyone getting `Status {statusCode = 503, statusMessage = "first byte timeout"}` when trying to build anything with stack, or is it just me?
20:55:04 <JuanDaugherty> it's just you
21:16:38 --- mode: glguy set +v khilan
21:16:53 <khilan> Hello! Can someone plz guide me with the correct use of `foldl` in https://gist.github.com/khilanravani/d9f342d847ef9aa1a65e4383e36bb9be?
21:18:27 <jchia> khilan: Maybe it'll help to explain the specific problem you're trying to solve
21:18:50 <jchia> For one thing, I see you use accBin but it's not define, and this is not about foldl
21:19:59 <khilan> jchia: Yes, very sorry. I'm trying to get a summation (In sumT, from all values of i in [0 .. 255]
21:20:17 <khilan> Yes actually, I've pasted a portion of code that's y
21:20:48 <khilan> like I want sumT = sumT + I.index image (0, i)
21:20:49 <jchia> what's the problem you encountered?
21:21:38 <jchia> what is i?
21:21:42 <khilan> Incorrect use of fold
21:21:54 <khilan> i is from 0 to 255
21:22:07 <jchia> L17 doesn't make sense. i appears out of the blue
21:22:47 <jchia> you'll probable get a compiler error
21:23:01 <khilan> yes sorry, I messed it up a bit
21:24:00 <khilan> Can u plz show me the correct way to do this? sumT = sumT + I.index image (0, i) where i is to be iterated from 0 to 255
21:25:11 <maerwald> could there be any side effects on dynamic dependencies when you use environment variables for codepaths in shake rules?
21:25:19 <jchia> your code seems to have a lot of unrelated context. what is I.index?
21:25:24 <adjofun> khilan: is it a XY problem? If you need an Otsu's method, use it from http://hackage.haskell.org/package/friday-0.2.3.1/docs/Vision-Image-Threshold.html
21:25:52 <glguy> adjofun: No, khilan should learn how to make this code work. This is about learning Haskell at this point
21:26:22 <khilan> jchia:  yes actually, that's a reference to the pixels
21:26:54 <khilan> adjofun: thank u for the link sir, but I need to implement it using a specific set of library functions
21:27:19 <glguy> khilan:    summation sum idx = sum + (i * I.index image (0, i))
21:27:26 <glguy> You're naming 'idx' and using 'i'
21:27:30 <dminuoso> khilan: What is `i` supposed to be?
21:27:46 <glguy> sumT = P.foldl summation i [0..255] -- what is 'i' here? it should be the initial 'accumulator' for your sum
21:28:15 <khilan> glguy: Oh right, it is 'i'
21:29:14 <glguy> khilan: When you don't understand an error message you should be putting it in the paste
21:29:31 <khilan> glguy: yes sorry, initial accumulator should be 0 I think
21:29:39 <glguy> You need to learn how to read them, ask about the parts you don't understand in the error messages
21:30:12 <khilan> glguy: yes sir, I'll follow that the next time I ask something. Thank u!
21:58:25 <chessandgo> pavonia: hm, what does "type Full"  mean?
22:02:58 <pavonia> chessandgo: It's the result type. Though it's unnecessary because all instances return MudMessage for def, as I just realised
22:03:22 <pavonia> So def :: a -> MudMessage should be fine
22:13:13 * hackage stm-hamt 1.1.2.1 - STM-specialised Hash Array Mapped Trie  http://hackage.haskell.org/package/stm-hamt-1.1.2.1 (NikitaVolkov)
22:14:13 <chessandgo> ill have to read about it, im just a beginner at the move advanced type level programming
22:16:13 * hackage stm-containers 1.0.1.1 - Containers for STM  http://hackage.haskell.org/package/stm-containers-1.0.1.1 (NikitaVolkov)
22:17:45 <chessandgo> is Nikita the god of STM software?
22:21:46 <ChaiTRex> How can I give a custom type error if a GADT of type V (n :: Nat) has n > fromIntegral (maxBound :: Int)?
22:25:43 * hackage streamdeck 0.0.3 - Control library for the Elgato Stream Deck  http://hackage.haskell.org/package/streamdeck-0.0.3 (wuest)
22:42:35 <nshepperd> ChaiTRex: I don't know about 'custom', but you can add (n <= 9223372036854775807) as a constraint in the type of a function
22:43:02 <nshepperd> ChaiTRex: which will make ghc complain if it can't prove that the size is less than that number
22:43:50 <nshepperd> ChaiTRex: https://hackage.haskell.org/package/base-4.11.0.0/docs/GHC-TypeNats.html#t:-60--61-
22:45:21 <khilan> Hello! I'm getting a parse error at 93 and do know that it is because of an incorrect ending of the forM_ above (since my last line is an expression). Can someone plz suggest an alternative to this? <https://gist.github.com/khilanravani/3eb7bee5eab59695f43467f35ccc12f6> Thanks in advance!
22:45:58 <khilan> Also, the code is a bit messy at the point and will optimize it once I get it working. Please bear with me in that :-)
22:46:21 <glguy> There don't appear to be any parse error messages in that paste
22:46:54 <khilan> glguy: I'm getting one at 93 sir
22:47:03 <cocreature> khilan: then add it to the paste
22:47:31 <khilan> cocreature: yes sir, 1 min
22:49:59 <khilan> <https://gist.github.com/khilanravani/3eb7bee5eab59695f43467f35ccc12f6>
22:50:09 <khilan> At 90
22:50:45 <khilan> Error msg at 98
22:51:27 <cocreature> "return tresh" needs to be aligned with one of the do blocks
22:51:53 <cocreature> but I’m also not sure what the return is even supposed to do here, you never seem to use the result of that do block but instead you throw it away using forM_
22:52:31 <khilan> cocreature: I want to use `thresh` at line 94
22:53:03 <mniip> hmm
22:53:20 <mniip> what do free theorems tell us about non-algebraic types with smart constructors
22:53:20 <khilan> cocreature: Right sir, I guess there's no need for return but then how do I end my forM_ ?😅
22:53:29 <ChaiTRex> nshepperd: Ahh, OK. Thanks for the pointer.
22:53:32 <cocreature> khilan: where clauses don’t work like an imperative program. they are not executed in sequence
22:53:49 <cocreature> line 73 also doesn’t make sense since you can’t just have a random expression in a where clause
22:54:19 <khilan> cocreature: so, I should make it a different function, right?
22:54:43 <khilan> which takes the required variables as input and returns thres?
22:54:49 <khilan> *thresh
22:55:17 <cocreature> yeah, something like that
22:55:48 <khilan> Ok, trying it out. Thank u!!
22:55:54 <cocreature> I would also recommend against using STRef for everything. just write a recursive function that takes the variables that you want to “modify” as arguments
22:56:22 <khilan> sorry sir, can u plz elaborate a bit?
22:57:12 <cocreature> only if you stop calling everyone sir :)
22:57:30 <khilan> cocreature: sorry, I've a habit :-) No worries.
22:58:31 <sir> hi
22:58:48 <glguy> Everyone, not anyone
22:59:33 <khilan> glguy: Sure, will do that :)
22:59:53 <cocreature> khilan: if you have something like "do x <- newSTRef 5; for_ [0 .. 255] $ do …; modifySTRef x (+1)" replace it by "let f n x | n >= 255 = pure () | otherwise = do …; f (n + 1) (x + 1) in f 0 5"
22:59:59 <glguy> khilan: I was making a joke for buhman 
23:00:15 <khilan> glguy: Oh my bad. Very sorry
23:00:17 <cocreature> or replace the recursion by some fold or whatever
23:00:52 <khilan> Oh ok, getting it a bit. Kind of a type level trick optimization?
23:00:53 <cocreature> ST is useful if you want to do inplace mutation of things like arrays, for local variables of type Int (or similar) it will be both slower and harder to read
23:01:03 <cocreature> there is no type-level trick going on here
23:01:12 <khilan> cocreature: Okay, I'll remember that
23:01:40 <cocreature> generally each loop in an imperative program will become a recursive function and every variable modified by that loop will be an argument to that function
23:01:51 <khilan> I'll do one thing. First, for now, I'll make a different function as we discussed above and then once I get it working, I'll eliminate the STRef's...
23:03:01 <khilan> Thank u!
23:04:14 <ChaiTRex> Is there some easy way to use maxBound :: Int with <= with a Nat at the type level?
23:04:22 <ChaiTRex> Right now, I'm using TH.
23:04:54 <ChaiTRex> (I want to make sure it adjusts to the maxBound on 32 or 64-bit systems)
23:05:59 <Ariakenom> You can use Int32, Int64 instead of Int
23:06:30 <ChaiTRex> I need Int because it's the limit on ByteArray# indexing.
23:08:02 <Ariakenom> and related to "32 or 64-bit systems" "data Int: A fixed-precision integer type with at least the range [-2^29 .. 2^29-1]." https://www.haskell.org/onlinereport/haskell2010/haskellch18.html#x26-22300018
23:08:31 <ChaiTRex> Ariakenom: They recently removed < 32-bit support (coming in 8.6 I assume)
23:08:42 <ChaiTRex> Ariakenom: At least for GHC.
23:09:12 <ChaiTRex> I think they might still have > 32 and < 64 support, though.
23:09:13 <Ariakenom> Cool. Probably not an issue in practise anyway.
23:11:46 <nshepperd> they removed < 32-bit support?
23:11:49 <nshepperd> what does that mean
23:13:51 <Ariakenom> > GHC.Base.Int
23:13:53 <lambdabot>  error:
23:13:53 <lambdabot>      Not in scope: data constructor ‘GHC.Base.Int’
23:13:53 <lambdabot>      No module named ‘GHC.Base’ is imported.
23:13:59 <Ariakenom> > GHC.Base.maxInt
23:14:01 <lambdabot>  error:
23:14:01 <lambdabot>      Not in scope: ‘GHC.Base.maxInt’
23:14:01 <lambdabot>      No module named ‘GHC.Base’ is imported.
23:15:13 <ChaiTRex> nshepperd: They used to support tag bits for other backends.
23:15:49 <ChaiTRex> nshepperd: Now they don't support tag bits any more at least for 32-bit machine word size.
23:16:26 <ChaiTRex> nshepperd: Here's the commit: https://github.com/ghc/ghc/commit/290889927244c79479c4347dfa6c851a134dd6e0
23:19:46 <ChaiTRex> Ahh, I have an idea: n <= 2^(WORD_SIZE_IN_BITS - 1) - 1
23:20:27 <khilan> cocreature: Something along the lines of this : <https://gist.github.com/khilanravani/3eb7bee5eab59695f43467f35ccc12f6> ?
23:21:25 <Ariakenom> ChaiTRex: Is that CPP for type level programming?
23:21:44 <khilan> Will change the STRef's after this works :-)
23:23:23 <cocreature> khilan: that doesn’t look like it actually compiles does it? there is no expression in the do block in line 78-79. also the whole definition of thresh won’t typecheck since it is defined as "thresh = runST $ forM_ …" which will have type "thresh :: ()" not "thresh :: Int"
23:23:47 <ChaiTRex> Ariakenom: Yes. Is TH better?
23:24:02 <khilan> yes I've pasted the error at line 106
23:24:08 <cocreature> I wouldn’t really recommend trying to push through with the ST solution here. you are just needlessly making your life harder
23:24:18 <ziman> can I have TypeApplications with infix operators? I'd like to have (rec ^. @"fieldname")
23:24:24 <Ariakenom> ChaiTRex: I have no opinion. I just found the mix funny :p
23:24:31 <ChaiTRex> Ariakenom: Oh, OK :)
23:25:03 <khilan> cocreature: Okay, I'll try to make it work without ST. But for this one, how do I end my function?
23:25:45 <khilan> The error I'm getting is The last statement in a 'do' block must be an expression at78
23:25:45 <ChaiTRex> When an input doesn't fit a Nat <= Nat type constraint on a function, is there a way to get a better error message than "Couldn't match type ‘'False’ with ‘'True’"?
23:27:00 <cocreature> khilan: well I don’t know what you want that function to do. presumably you want to do modify some existing variable called current_max rather than assign something to a new variable current_max
23:27:12 <cocreature> but there is no variable called current_max that’s in scope
23:27:29 <khilan> I just want the value of `thresh` from that fucntion
23:28:20 <khilan> cocreature: And use that value at 103
23:29:18 <khilan> cocreature: yes sorry, defined that var now
23:29:20 <cocreature> which value? you are creating a new variable called "tresh" in each loop iteration and setting it to "i". I have no idea what "i" is supposed to be here nor do I know why you are creating a new variable in each iteration
23:30:14 <khilan> cocreature: Yes, so I want to return the value of thresh after the last iteration
23:30:23 <cocreature> I really would recommend that you remove that ST mess at least for tresh and write it without ST (or only use ST for the things you have to). you’ll just add to the mess if you try to fix this
23:30:40 <cocreature> ChaiTRex: https://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-TypeLits.html#g:4
23:31:10 <ZeuPiark> hello
23:31:15 <khilan> cocreature: Okay, I'll try it once again.
23:31:32 <cocreature> khilan: there is no value after the last iteration. you are creating a new variable called tresh in each iteration, not modifying a variable across iterations
23:32:39 <khilan> cocreature: Okay, getting it now. Trying it out some other way. Thank u!
23:34:11 <ChaiTRex> cocreature: Thanks. I'm having trouble figuring out where to put a TypeError .... If I have f :: (n <= 87) => V n -> Integer, how do I make it give an error when n exceeds 87?
23:35:43 * hackage alms 0.6.8 - a practical affine language  http://hackage.haskell.org/package/alms-0.6.8 (JesseTov)
23:42:14 * hackage alms 0.6.9 - a practical affine language  http://hackage.haskell.org/package/alms-0.6.9 (JesseTov)
23:43:44 <cocreature> ChaiTRex: something like https://gist.github.com/cocreature/33f9c62b652f2fa2235c27d25ea0eaa0
23:51:26 <typetetris> Is there a tutorial for those cabal new-* commands (i already read the manual).
23:52:39 <typetetris> When can I share relocatable sandboxes between ghc installs? Is it sufficient if it is the same ghc version and architecture or do the distributions of the linux machines need to be the same? Need the ghcs to be installed in the same paths on both machines?
23:53:34 <cocreature> afaik the best tutorial is the manual atm
23:58:43 <ChaiTRex> cocreature: Thanks a lot.
