00:00:34 <trcc> so when I use import Foreign.C.Types, then I can use CInt and CDouble in foreign export ccall. But when I use import Foreign.C.Types (CInt, CDouble) I cannot. I get an error stating that CInt's data constructor is not in scope. Howcome?
00:01:08 <geekosaur> because haskell distinguishes between type and data constructors. I fyou specify "CInt", you get only the type constructor
00:01:28 <geekosaur> "Cint (..)" or "CInt (CInt)" will bring in both
00:01:49 <geekosaur> (the former is a wildcard to get all data constructors. The space is optional)
00:02:51 <trcc> A thank you
00:04:51 <geekosaur> sometimes you want this so you can import the type unqualified and the constructors qualified. or for types like Data.Map.Map where the data constructors aren't exported (because you could break internal invariants, specifically that it's sorted by key)
00:07:41 <trcc> This is the sort of stuff that you just need to encounter to remember. 
00:08:16 <trcc> geekosaur: when I look at http://hackage.haskell.org/package/base-4.11.1.0/docs/Foreign-C-Types.html#t:CInt then I know that I need to import CInt(CInt) because there is both a newtype CInt and CInt listed under constructors right?
00:09:59 <geekosaur> you know it basically because you don't get a function to create one, like Map has "empty" and "insert". and yes, this is something you basically have to learn. in general you import SomeType(..) to get the type + constructors, and if you get an error because the constructors aren't exported then drop the '(..)'
00:10:21 <geekosaur> but there aren't many types aside from Map and Set that do that to you
00:10:35 <geekosaur> at least, not commonly used types.
00:10:43 <trcc> okay thanks
00:19:29 <Ariakenom> Interesting, how common is it? Rational, STM, the streaming pkgs
00:20:17 <cocreature> Ariakenom: how common is what exactly?
00:20:42 <Ariakenom> hides constructors
00:21:10 <cocreature> not exporting constructors from the main module is reasonably common but a lot of packages expose them in internal modules instead
00:21:31 <cocreature> not exporting them at all tends to produce situations where your users are annoyed because they can’t do what they want
00:21:55 <Ariakenom> Right. I assume that doesn't count.
00:22:40 <cocreature> depends on what you want to count :)
00:23:04 <Ariakenom> Well I was wondering when geekosaur said "but there aren't many types aside from Map and Set that do that to you"
00:23:54 <Ariakenom> So it's about the main API
00:25:35 <cocreature> Text is another common one
00:27:42 <Ariakenom> Can't quite decide if IO counts. I guess
00:29:09 <Ariakenom> and oh yes. very much so Text. 
01:27:40 <dminuoso> Ariakenom: IO is exposed in GHC.IO
01:27:54 <dminuoso> Ariakenom: ByteString makes use of this.
01:45:06 <Ariakenom> dminuoso: GHC.* is all "internal" though? I'd guess using IO breaks invariants
01:46:46 <dminuoso> Ariakenom: Yeah, the report does not specify a constructor or unIO function.
01:47:22 <dminuoso> Ariakenom: IO is particularly tricky because misusing its internals can lead to bizarre crashes or bizarre effects. :)
01:49:02 <Ariakenom> Yes. The only thing I was thinking about was whether it was too magical. More a language primitive than a yet another data type
02:13:27 <pong> why does the Prelude's (^) use two helper functions f and g when it appears to me that f x y == g x y 1?
02:14:09 <pong> in https://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.Real.html#%5E
02:16:28 <Saizan> i would guess efficiency
02:59:14 <dmwit> pong: gotta save that one extra multiplication ;-)
02:59:17 * hackage vector-text 1.1.5 - Text implementation based on unboxed char vector.  http://hackage.haskell.org/package/vector-text-1.1.5 (danilo2)
03:00:46 * hackage prologue 3.2.4 - Better, more general Prelude exporting common utilities.  http://hackage.haskell.org/package/prologue-3.2.4 (danilo2)
03:01:47 * hackage container 1.1.2 - Containers abstraction and utilities.  http://hackage.haskell.org/package/container-1.1.2 (danilo2)
03:11:22 <maerwald> stack can't be used on alpine?
03:11:24 <maerwald> seems it doesn't run
03:17:28 <dminuoso> maerwald: build your things from haskell or your own build setup
03:17:41 <dminuoso> maerwald: use a multi stage docker build and copy build artifacts onto alpine
03:22:07 <maerwald> "build your things from haskell"?
03:25:21 <bjobjo> maerwald: https://github.com/commercialhaskell/stack/issues/2387
03:25:39 <maerwald> yes, I'm looking at that, but I don't see a solution
03:26:14 <bjobjo> IIRC there's a static build linked in the thread somewhere
03:26:22 <bjobjo> but I'm still waiting for the "official" release
03:28:01 <dminuoso> maerwald: there's a haskell base image
03:28:47 <dminuoso> maerwald: in my eyes there's not so much value in building on alpine because stack/ghc and everything you drag behind you will increase your tiny base image from 10MiB to 2GiB
03:28:58 <bjobjo> the primary issue wrt to alpine is that you can't just copy over the binary artifacts due to libc differences
03:29:00 <dminuoso> So you might as well pick a different base image
03:29:10 <dminuoso> bjobjo: huh? I can?
03:29:34 <bjobjo> OK? That's what I gathered when I read about it a few weeks back
03:29:39 <bjobjo> but I must admit that I haven't actually tried it
03:30:13 <bjobjo> alpine uses musl rather than glibc
03:30:19 <cocreature> I don’t think you can take a binary that links against glibc and run it on alpine
03:32:07 <cocreature> the other way around usually works since you can link musl statically
03:32:34 <dminuoso> cocreature: Ah yeah my build setup statically links against musl 
03:33:19 <bjobjo> isn't the haskell image based on ubuntu?
03:33:46 <madnight> https://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
03:34:45 <madnight> "It's a bit silly really. Every library that comes with GHC is provided in no less than 4 flavours" static, dynamic, profiled, ghci
03:36:02 <cocreature> madnight: is that a question? I don’t see what you are trying to tell us here :)
03:36:23 <bjobjo> that's why having stack on alpine would help a fair bit, so you can use it as a builder image and then just copy over the compiled artifacts rather than having stack + ghc + whatever else installed in the production image
03:37:20 <cocreature> you don’t ned alpine for that, you can just as well build on ubuntu and copy the resulting binary to a similar ubuntu installation that does not have stack + ghc installed
03:37:20 <madnight> cocreature: that was a comment to why the docker images are so big
03:37:31 <maerwald> ubuntu fails fairly often in docker
03:37:38 <bjobjo> true, but then you'd still have an ubuntu based image :)
03:37:39 <maerwald> that's why I was trying to give alpine a go
03:38:03 <phadej> does it?
03:38:11 <madnight> dminuoso mentioned that alpine won't help (which is correct from my experience)
03:38:25 <bjobjo> note that ghc is available in alpine, so if you're using cabal-install, it may just work out of the box (I haven't tried)
03:39:39 <madnight> maybe it is possible to remove the dynamic, profiled and ghci flavor and cut down the size
03:40:10 <bjobjo> you don't need to do that if you use a builder image and just copy over the artifacts you need
03:40:14 <maerwald> there is an alpine-glibc image, but it seems to rely on hacks. I can run pre-built stack, but ghc will barf out at linking stage with weird errors
03:41:01 <bjobjo> madnight: https://docs.docker.com/develop/develop-images/multistage-build/ if you haven't seen it :)
03:41:12 <madnight> bjobjo: true, i already did that somewhere
03:41:23 <cocreature> maerwald: maybe try the binaries linked here https://github.com/nh2/static-haskell-nix/tree/master/static-stack (or build them yourself). they should be linked fully statically using musl so I would expect them to work on alpine
03:41:51 <bjobjo> I briefly tried those and got my yesod test built at least
03:42:00 <bjobjo> but haven't had time to test deployment
03:42:23 <madnight> bjobjo: here example https://github.com/madnight/grendel/blob/master/Dockerfile
03:42:33 <madnight> bjobjo: i used debian slim
03:42:36 <maerwald> cocreature: meh, not signed :(
03:43:56 <bjobjo> madnight: nice :) what's the resulting size of the image?
03:44:00 <madnight> if i remember it correctly i was able to cut down the Haskell image from 800 mb to 50 mb with multi stage builds
03:45:15 <bjobjo> I still feel that it is a bit scary to use different images for the builder and production containers, as you've also noted in the comment wrt to being careful about what you pick
03:45:19 <phadej> our prod images are <100MB, as they essentially "RUN apt-get install libgmp0" and "ADD binary /app"
03:45:26 <bjobjo> but it's cool to see that someone has done it
03:45:57 <phadej> bjobjo: they aren't different, builder image has dev stuff, production doesn't
03:47:03 <madnight> i think the haskell image itself is based on debian slim
03:47:26 <phadej> take for example NodeJS projects. You don't really want devDependencies to be in the production
03:47:44 <phadej> but I think that 99.9% of images do, because people don't think about these
03:47:58 <phadej> ===> Haskell is better, because it forces you think about things ;)
03:48:08 <phadej> though, in this case quite indirectly
03:48:28 <bjobjo> phadej: OK, did not know that
03:48:46 <maerwald> cocreature: well, that only solves half of the problem too, because the ghc stack downloads is still broken
03:49:00 <bjobjo> maerwald: you can tell stack to use the system-ghc
03:49:04 <bjobjo> --system-ghc IIRC?
03:49:05 <cocreature> maerwald: maybe use the one from the alpine repos and then use system-ghc?
03:49:15 <bjobjo> cocreature:that's what I did 
03:49:25 <cocreature> hopefully the repos have the version that you need
03:49:49 <maerwald> they don't
03:50:21 <cocreature> then I don’t think there is an easy solution here sadly :/ afaik building the ghc bindists for alpine is rather painful
03:51:17 <cocreature> you could consider using the static-haskell-nix approach to build your own application
03:54:36 <phadej> bjobjo: the problem with docker is that you cannot "uninstall" stuff (IIRC there's some way to flatten all containere layers, but that's sometimes not good enough either)
03:54:52 <phadej> i.e. even you uninstall it, it's still in the image's history
03:54:57 <maerwald> phadej: just install and uninstall in one layer
03:55:15 <bjobjo> phadej: I know
03:55:28 <maerwald> and flattening works very well
03:55:32 <bjobjo> it makes for a lot of && \ in the Dockerfile :)
03:55:42 <maerwald> bjobjo: or just use a script file
03:55:49 <bjobjo> true
03:55:57 <bjobjo> but I don't really mind having the "recipe" in the dockerfile itself
03:56:14 <phadej> maerwald: it breaks docker internal caching, I don't want to install GHC on every build, I want that cached :)
03:56:34 <maerwald> I don't see the problem.
03:56:40 <maerwald> You still have the cache
03:56:47 <maerwald> you just flatten to another image
03:56:55 <phadej> well, then yes
03:57:23 <phadej> but then your production servers won't share dependency install layers
03:57:37 <phadej> (or can you flatten selectively?)
03:57:48 <maerwald> Isn't that an overlayfs thing anyway?
03:58:17 <delYsid> is hackage upload broken right now?
03:58:25 <delYsid> My "stack upload ." hangs.
03:59:11 <phadej> maerwald: but there aren't any overlays if you flatten?
03:59:27 <maerwald> no idea, I don't use overlayfs
04:00:01 <phadej> ==> so it's not that simple :)
04:00:11 <maerwald> depends on what you want
04:00:16 * hackage diagrams-braille 0.1.0.2 - Braille diagrams with plain text  http://hackage.haskell.org/package/diagrams-braille-0.1.0.2 (mlang)
04:00:19 <maerwald> you want flattened images or not? ;)
04:00:34 <maerwald> in fact, you don't, so obviously it's not easy
04:01:14 <phadej> maerwald: i want `rebase -i` for docker
04:01:36 <phadej> so I can merge layers, but all
04:01:41 <phadej> but not* all
04:03:37 <asheshambasta> for a simple (enum?) type like `data Foo = Bar | Baz | Zing`,
04:03:38 <asheshambasta>                 is there a short way to define it as an instance of `Ord` in
04:03:38 <asheshambasta>                 the same order as its data constructors?              
04:03:57 <maerwald> phadej: interesting suggestion
04:04:05 <Ariakenom> asheshambasta: deriving (Ord)
04:04:10 <phadej> (Eq, Ord)
04:04:26 <asheshambasta> (yikes, apologies for the poor formatting there)
04:04:44 <Ariakenom> phadej: oh, does it complain without Eq?
04:05:02 <liste> @let data Foo = Bar | Baz | Zing deriving (Eq, Ord, Bounded, Show)
04:05:03 <lambdabot>  Defined.
04:05:09 <asheshambasta> Ariakenom: does that conserve the ordering of the data constructors as well? 
04:05:22 <Ariakenom> > bar < Baz
04:05:25 <lambdabot>  error:
04:05:25 <lambdabot>      • Variable not in scope: bar :: Foo
04:05:25 <lambdabot>      • Perhaps you meant one of these:
04:05:35 <Ariakenom> > Bar < Baz
04:05:38 <lambdabot>  True
04:05:52 <Ariakenom> > Baz < Zing
04:05:55 <lambdabot>  True
04:06:07 <Ariakenom> > [minBound..]
04:06:10 <lambdabot>  [()]
04:06:17 <Ariakenom> > [minBound..] :: [Foo]
04:06:20 <lambdabot>  error:
04:06:20 <lambdabot>      • No instance for (Enum Foo)
04:06:20 <lambdabot>          arising from the arithmetic sequence ‘minBound .. ’
04:06:46 <Ariakenom> asheshambasta: yes
04:06:51 <WilhelmVonWeiner> I'm learning to program in a functional style and I thought you boffins would know:
04:07:18 <WilhelmVonWeiner> is there a way to map a function to two lists? element by element? is there a word for that?
04:07:43 <Ariakenom> WilhelmVonWeiner: zip and zipWith?
04:07:59 <Ariakenom> > zipWith (+) [1,2] [3,4,5]
04:08:01 <lambdabot>  [4,6]
04:08:13 <asheshambasta> interesting, thanks Ariakenom, phadej 
04:08:26 <WilhelmVonWeiner> Ariakenom: exactly what I was looking for, wholly appreciated
04:09:02 <Ariakenom> great
04:12:57 <phadej> Ariakenom: it does
04:13:10 <phadej> @let data F = F deriving (Ord)
04:13:11 <lambdabot>  .L.hs:176:18: error:
04:13:11 <lambdabot>      • No instance for (Eq F)
04:13:11 <lambdabot>          arising from the 'deriving' clause of a data type declaration
04:13:29 <phadej> you might want to write the Eq manually, etc.
04:15:16 * hackage vector-algorithms 0.7.0.4 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.7.0.4 (ErikDeCastroLopo)
04:15:53 <Ariakenom> phadej: ah yeah makes sense
04:28:22 <dmwit> WilhelmVonWeiner: If you don't like the fact that the `5` was thrown away there, you can check out `align` and `alignWith`. https://hackage.haskell.org/package/these-0.7.4/docs/Data-Align.html#t:Align
04:29:28 <dmwit> The "fun factor" in that package is way too high.
04:30:17 <dmwit> "aligning with nil gives you back the same structure, modulo This or That"
04:30:25 <dmwit> just too cute
04:32:25 <Ariakenom> yikes. way too cute
04:34:06 <mniip> malign
04:34:16 <dmwit> malign is another favorite for sure
04:34:35 <dmwit> and crosswalk
04:35:03 <dmwit> All the names in MonadChronicle
04:37:28 <dmwit> Interesting. PackageImports doesn't seem to work right in ghci.
04:37:49 <dmwit> https://lpaste.net/6081032151870996480
04:39:14 <dmwit> Anyway I think I finally understand what bicrosswalk does.
04:40:23 <mniip> what does crosswalk do?
04:41:35 <mniip> is it just Traversable on a different lax monoidal category?
04:41:48 <mniip> (nil, align) instead of (pure (), liftA2 (,))
04:42:22 <mniip> ah yes indeed, These is the product in Kleisli Maybe
04:42:42 <mniip> so Align is evidencing "applicative" structure of functors from Kleisli Maybe
04:44:08 <c_wraith> I think my favorite in there is actually retcon
04:44:30 <dmwit> If that is explanatory for you, I applaud you. For me the light bulb went off when I realized crosswalk was a generalization of transpose.
04:44:50 <dmwit> Which was just the continuation of a light bulb that went off when I realized transpose was a generalization of zip.
04:45:13 <dmwit> So in retrospect it probably shouldn't have been too hard, but, well... I'm dumb. =P
04:45:29 <mniip> I wonder if  eval :: These a (a -> Maybe b) -> Maybe b  works out as the exponential in that category
04:47:01 <dmwit> Is there even a product in that category?
04:47:05 <mniip> These
04:47:15 <dmwit> oh sure
04:47:25 <dmwit> ...of course
04:48:29 <mniip> you have the obvious  Kleisli Maybe (These a b) a,  Kleisli Maybe (These a b) b
04:48:53 <mniip> and for any  (Kleisli Maybe c a, Kleisli Maybe c b) you can factor in   Kleisli Maybe c (These a b)
04:51:33 <dmwit> So, to expand definitions for my stupid brain, we're asking whether there's a natural isomorphism between `These x y -> Maybe z` and `x -> Maybe _`? But that doesn't seem sensible, since the former can produce things even when there's no `x` around.
04:54:27 <mniip> the natural isomorphism needs to be between  c -> Maybe (These a b)  and  (c -> Maybe a, c -> Maybe b)
04:54:51 <dmwit> Not for the product. You convinced me on that. I'm thinking about the exponential now.
04:54:56 <mniip> ah
04:55:35 <mniip> eval These x f = f x; eval _ = Nothing
04:55:43 <mniip> so now the question is whether it's universal
04:56:20 <lavalike> These is a or b or (a and b) right?
04:56:25 <dmwit> right
04:56:39 <mniip> suppose  ev :: These a z -> Maybe b
04:57:12 <mniip> ev = eval . fmap h,  h :: z -> (a -> Maybe b),  h = ?
04:58:12 <mniip> h z a = ev (These a z)
05:00:08 <mniip> eval = these (const Nothing) (const Nothing) (flip id)
05:00:19 <mniip> these (const Nothing) (const Nothing) (flip id) . fmap (\z a -> ev (These a z))
05:02:25 <mniip> that doesn't seem right because 'ev' could turn a This into a Just
05:02:34 <dmwit> So we want lambda :: (These a b -> Maybe c) -> (These a b -> These (These b (b -> Maybe c)) b) -- ?
05:04:20 <dmwit> Oops, no, lambda :: (These a b -> Maybe c) -> (a -> Maybe (These b (b -> Maybe c)))
05:05:04 <dmwit> Again that seems really unlikely, since the argument might choose Just/Nothing depending on the value in `b`.
05:05:31 <dmwit> But as implementors of `lambda` we don't get to see a `b` before we have to choose `Just`/`Nothing`.
05:06:17 * hackage hledger-iadd 1.3.6 - A terminal UI as drop-in replacement for hledger add  http://hackage.haskell.org/package/hledger-iadd-1.3.6 (hpdeifel)
05:06:53 <dmwit> Oh, no again: it's `lambda :: (These a b -> Maybe c) -> (a -> Maybe (b -> Maybe c))`. But the same argument applies.
05:07:58 <dmwit> In fact the argument appears to apply regardless of what exponential X you choose: `lambda :: (These a b -> Maybe c) -> (a -> Maybe X)` is hopeless.
05:11:08 <dmwit> mniip: I conclude in two different ways that there's no exponential, and in particular that your proposed one isn't it.
05:11:40 <dmwit> Oh, actually, just one way. Neat!
05:15:32 <dmwit> Ah, here's an explicit counterexample: `ouch :: These () Bool -> Maybe (); ouch = justThat >=> guard` (choose `Just ()` when you have a `True` and `Nothing` otherwise).
05:33:25 <blankhart> i am trying to link libhunspell into a project that i build with nix, and cabal new-repl/ghci can't find it.  has anyone done something like this?
05:36:47 <blankhart> if i specify "hunspell" in extra-libraries in the cabal file, cabal2nix will find and provision it from nixpkgs, but then i get a "missing dependency on a foreign library" error from cabal
05:40:42 <philippD> afaik cabal2nix only handles haskell dependencies right?
05:43:02 <blankhart> well it put a librarySystemDepends = [ hunspell ]; in my shell.nix and seeing is believing
05:44:41 <philippD> You're right
05:45:39 <blankhart> maybe the issue is with nix rather than cabal and i just need to find out where in the virtual directory structure it put hunspell
06:07:18 <ZeuPiark> hello
06:08:58 <philippD> hey
06:15:59 <blankhart> this still is not working one bit
06:29:10 <Guillaum> Is there a way to have a warning for non-exhaustive pattern match in do notation? In ghc 8.6 it generates a compile time error if the do notation is `Monad`, but it generates a fail without warning if the do notation in `MonadFail`.
06:35:18 <Ariakenom> is this correct?
06:35:18 <Ariakenom> value - type - kind - sort
06:37:54 <ski> i think at least the first three are traditional
06:39:11 <ski> i may have seen people use the term "sort" for anything (at or) above the "type" level/strata, iow for anything that can stand to the right of `::'
06:39:59 <Ariakenom> ski: thanks
06:41:07 <Ariakenom> other type systems use something like type - type2 - type3 - ... ?
06:42:21 <ski> hm, probably starting at zero
06:43:42 <dolio> I think 'sort' kind of comes from algebra.
06:43:47 * hackage ghc-typelits-presburger 0.2.0.4 - Presburger Arithmetic Solver for GHC Type-level natural numbers.  http://hackage.haskell.org/package/ghc-typelits-presburger-0.2.0.4 (HiromiIshii)
06:44:04 <dolio> And it kind of refers to different syntactic classifications of your algebra.
06:44:35 <mniip> value - type - type - type
06:44:38 <ski> i've heard the term "multi-sorted (predicate) logic", meaning that they allow any number of types, rather than just a single (unnamed) one
06:45:13 <dolio> So viewing your language _with_ types as a sort of algebra, values would make up a sort, types would make up a sort, kinds would make up a sort, etc.
06:46:15 <osa1> can I shrink a mutable vector without copying it?
06:46:28 <dolio> Yeah, I guess when I say 'algebra,' logic is rolled up into that some on the mathematical study side.
06:46:53 <ski> (well, in (uni-sorted) second- and higher- order predicate logic, they allow not only individuals (elements of the unnamed sort/type), but also predicates over individuals, and in 2nd-order, predicates over such predicates, and so on for higher orders. but these "types" are distinguished *syntactically*)
06:47:10 <dolio> Right.
06:47:51 <dolio> They act more like types if you describe the syntax of the logic as an algebraic/type theoretic structure.
06:48:23 <ski> (whereas in Haskell, there's no syntactical stratification akin to that. a variable is a variable. it's not a syntactic matter which type it has)
06:48:25 <dolio> But you can do that to some presentations of type theory itself.
06:49:33 <ski> hm, yea
06:49:44 * ski is reminded of judgements-as-types
06:50:12 <dolio> I mean, Haskell traditionally does have syntactic stratification of stuff to some degree.
06:50:41 <ski> (where no propositions, but rather judgements, in your object logic, are represented by types in your meta language)
06:50:59 <ski> well, yes, there's expressions vs. patterns, e.g.
06:51:14 <ski> and other syntactic categories
06:51:22 <dolio> Yeah.
06:51:53 <dolio> (::) : Term -> Type -> ?
06:52:09 <dolio> (There's more than one ::.)
06:52:20 <ski> an imperative language with l-values might also have l-value abstractions (so that you can have a "function" return the first element of a queue, as an l-value, without any (explicit) dereferencing subsequently needed to assign to it)
06:52:45 <dolio> I guess that one has ?=Term.
06:53:12 <dolio> But there's also `(::) : Identifier -> Type -> Signature`.
06:53:17 <dminuoso> Guillaum: Why have non-exhaustive patterns to begin with?
06:54:08 <dminuoso> Guillaum: You could use -Wwarn if you really needed to, but it's likely a better idea to have exhaustive pattern matches. If, for whatever reason, the additional cases can't happen because of some invariant - then match for it and produce an `error "blablab about invariant"`
06:54:17 <ski> "Any syntactic category that expresses some kind of computation may admit (parameter) abstraction, and local variable declaration (and these two correspond to each other)." (a principle one can consider, when designing a language)
06:54:37 <ski> e.g. in GHC, we have pattern synonyms which are pattern abstractions
06:56:12 <ski> dolio : i suppose in the first case you were thinking of ascriptions ?
06:56:30 <dolio> Yeah.
06:56:48 <dolio> `g (5 :: Int)`
06:56:53 * ski nods
06:57:22 <ski> sometimes i'd like that to be written differently from signatures (and typings in general)
06:57:38 <ski> perhaps `<expr> (:: <type>)'
06:57:51 <dminuoso> ski: You can with TypeApplications. Sort of.
06:57:51 <gobby> is there a way to output the time it takes to build and test a package in stack?
06:57:58 <gobby> separately?
06:58:15 * ski . o O ( `id : (A :) Set -> A -> A' )
06:58:45 <dolio> Didn't they add sections of (::) to GHC a release or two back?
06:58:55 <dolio> So you can write `(:: T)`
06:59:08 <ski> hm, i know we've talked about it before
06:59:37 <ski> (as in, people on this channel)
07:00:06 <dolio> I think there was an actual proposal somewhere.
07:00:12 <ski> ok
07:00:13 <dolio> But I guess I'm not sure if it was implemented.
07:00:59 <ski> hrm, so perhaps i'm saying that i prefer the syntactical form of casts in C ..
07:01:55 * ski . o O ( `map (\(x :: a) -> y :: b) (xs :: [a]) :: [b]' )
07:04:32 <Guillaum> dminuoso: Actually I want to avoid non exhaustive pattern (And I'm questionning the fact that pattern match issue are desugared into `fail`), but I cannot find a way to activate a warning for non-exhaustive patterns in the do notation.
07:04:43 <cocreature> dolio: there was a proposal but it was never implemented
07:06:04 <Ariakenom> ski: Are signatures and in expressions (::Type) is id that also enforces the type right? So for signature you just introduce a variable and leave it on the top level
07:06:12 <Ariakenom> But that doesn't make too much sense I suppose
07:06:12 <Guillaum> dminuoso: For example, the simple program `main = do {(x:xs) <- getLine; print x}` won't trigger any warning.
07:06:35 <ski> Ariakenom : i can't parsed that question
07:07:09 * ski idly notes that `(x:xs)' there can be replaced by just `x:xs'
07:07:15 <dolio> cocreature: Okay.
07:08:41 <Ariakenom> ski:  thats finew
07:09:25 <ski> Ariakenom : perhaps you can rephrase your question ?
07:12:26 <dminuoso> Guillaum: So the main issue is that `fail` used to be in Monad.
07:13:24 <Ariakenom> ski: I would but typing out the question answered it :p. 
07:13:34 <ski> oic
07:13:51 <Guillaum> dminuoso: I know, it is now in `MonadFail`, and, for example, IO is an instance of, so `main = do {(x:xs) <- getLine; print x}` is a valid exception throwing code.
07:13:53 * ski is still a bit curious what it was about
07:13:53 <Ariakenom> I noticed a difference I hadn't realized between signatures and (::) in an expression
07:14:17 <ski> Ariakenom : the latter i call "(type) ascriptions"
07:15:01 <ski> (i believe this term is more common in the ML community, but i think i've seen it in a Haskell context (apart from myself using it), as well)
07:15:05 <Ariakenom> ski: allright. It was that both signatures and ascriptions introduce a type judgement(?) into the environment and have the value of the term
07:15:16 <dminuoso> Guillaum: Are you perhaps looking for -Wincomplete-patterns, included by -Wall
07:15:30 <Ariakenom> well signatures don't but you can see them as just leaving the term to no effect on the top level
07:16:09 <ski> no ascriptions don't "introduce a type judgement (or a typing, if you prefer) into the environment", in any sense i can see
07:16:28 <ski> ascriptions constrain a given expression (or pattern) to have a particular type
07:16:29 <Ariakenom> ski: I realized that :)
07:16:52 <cocreature> dminuoso: that still doesn’t work for do notation
07:17:10 <ski> (indirectly, that may cause an inferred signature for a definition to be more specific, of course)
07:17:15 <dminuoso> cocreature: Oh :(
07:17:32 <dminuoso> cocreature: I suppose your best bet is to not use pattern matches in bind?
07:17:41 <Guillaum> dminuoso: unfortuntatly it does not work for do notation ;(
07:18:00 <Guillaum> dminuoso: I'm highly trying to avoid writting bug in my program too ;)
07:18:01 <dminuoso> I was not aware of this :(
07:18:02 <cocreature> if you enable MonadFailDesugaring and have a Monad that doesn’t have a MonadFail instance you should get an error afaik
07:18:04 <ski> but yes, apart from constraining the type, an ascription doesn't change the value of the expression, so one could say it acts like the identity function
07:18:10 <glguy> The flag has "uni" in it IIRC
07:18:15 <cocreature> but since all the standard monads have MonadFail instances, that’s somewhat hard
07:18:34 <cocreature> glguy: afaik the uni flag works for things like let bindings and lambdas but it’s not triggered in do notation
07:18:35 <glguy> Try: ghc --show-options | fgrep uni
07:18:41 <glguy> Oh :(
07:18:52 <ski> (it's not a cast, like in C. the type of the ascription expression `<expr> :: <type>' is the same as the type of `<expr
07:18:55 <Guillaum> cocreature: I confirm
07:19:06 <ski> ' (i.e. this occurance of it), which is `<type>'
07:19:09 <ski> )
07:20:02 <Ariakenom> > (300.0 :: Word8) --(char) 300.0
07:20:04 <lambdabot>  error:
07:20:04 <lambdabot>      • No instance for (Fractional Word8)
07:20:04 <lambdabot>          arising from the literal ‘300.0’
07:20:42 <cocreature> personally, I would like to have something like -Wincomplete-do-pattern
07:20:56 <ski> @type 300.0 :: Word8
07:20:57 <lambdabot> error:
07:20:57 <lambdabot>     • No instance for (Fractional Word8)
07:20:57 <lambdabot>         arising from the literal ‘300.0’
07:21:19 <hyperisco> not like a C cast in that it does not have a dynamic component
07:21:36 <ski> (one could say the type here is `Fractional Word8 => Word8', but then the constraint resolution here fails)
07:22:14 <ski> hyperisco : hm, which dynamic component in C are you thinking of ?
07:22:19 <Ariakenom> (indeed)
07:22:39 <hyperisco> well if you, for example, cast a float to an int, that is a conversion which will take place when the program runs
07:22:44 <dminuoso> cocreature: That sounds like a fun task. Maybe I should make it happen =)
07:22:55 <cocreature> dminuoso: go for it!
07:23:24 <ski> (i assume the C standard possibly allows a cast to be something else than an O(0) or O(1) operation, though that is not what is usually expected in an implementation of C)
07:24:10 <ski> hyperisco : touche :) that would be the coerce aspect of C casts, which weren't on our minds here
07:24:27 <Guillaum> dminuoso: go for it! +1 ;)
07:25:08 <Ariakenom> ski: It's even stated as a more expensive op
07:25:16 <Ariakenom> "[...] the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type."
07:25:38 <Ariakenom> for casting a signed to an unsigned
07:26:35 <Ariakenom> of course that's not how it's implemented
07:26:52 <hyperisco> wouldn't you just say that x :: a declares x has type a?
07:26:54 <ski> > let f :: (Integer -> Integer) -> Integer; f g = g 2 + g 3; h :: (forall a. a -> a) -> Integer; h = f in h id  -- in some sense, here we "coerce" from `(Integer -> Integer) -> Integer' to `(forall a. a -> a) -> Integer'
07:26:56 <lambdabot>  5
07:27:38 <ski> Ariakenom : interesting
07:28:26 <ski> in a type-passing implementation of Haskell, the above would require a non-O(0) operation to go from `f' to `h'
07:29:25 <ski> (type-passing meaning that we implicitly pass representations of types (perhaps a value size, perhaps more info about layout) to polymorphic functions)
07:30:07 <ski> hyperisco : depends on whether that's a declaration, or an expression
07:30:12 <dmwit> % :set -XNumDecimals
07:30:12 <yahb> dmwit: 
07:30:16 <dmwit> % 300.0 :: Word8
07:30:16 <yahb> dmwit: ; <interactive>:16:1: warning: [-Woverflowed-literals] Literal 300 is out of the Word8 range 0..255; 44
07:30:32 <hyperisco> ski, what does it matter?
07:31:08 <ski> hyperisco : those are conceptually different classes of things, can't be compared. they just happen, in Haskell, to share the same surface (concrete) syntax
07:31:40 <Ariakenom> isn't O(0) == O(1)?
07:31:53 <dmwit> no
07:32:02 <dmwit> Only the constant-0 function is in O(0).
07:32:19 <dmwit> All uniformly-bounded functions are in O(1).
07:32:34 <ski> by an O(0) operation, i mean a no-op
07:33:12 <ski> if you `map' such an operation over a list, that could be simplified to just a no-op on the list. no so for mapping an O(1) operation
07:33:15 <hyperisco> not sure what the difference is other than extraneous considerations such as good practice (always include top level sigs) or monomorphism restriction (afaik a top level problem)
07:33:25 <tcsiwula> anyone familiar with installing cloud haskell packages? I ran into cabal hell.
07:34:48 <dmwit> Maybe paste your error online and send us a link.
07:34:50 <glguy> Always just ask your actual question
07:36:00 <mnoonan> tcsiwula: I've only used it a small amount, and with stack, but I don't recall anything tricky about the setup.
07:37:00 <hyperisco> Ariakenom, because no multiple of zero gets you to one
07:37:18 <ski> languages with subtyping (like OO ones) typically want to allow a subsumption semantics, where to convert a value (or reference to an object) of type `T' into a super type `S', that would be a no-op, an O(0) opeation. ideally, we'd also like this for (covariant) containers, like converting from `Map<ID,T>' to `Map<ID,S>' shouldn't require traversing the finite map
07:37:46 <dmwit> % 0x0.12cp12 -- righteous
07:37:46 <yahb> dmwit: 300
07:38:01 <ski> iow, we'd like to represent our values of type `T' such that they can also be interpreted (sensibly) as representations of values of type `S'
07:38:43 <hyperisco> now what about Map<K1,T> to Map<K2,T>
07:40:00 <hyperisco> if you can do that one safely then you have an interesting language I think
07:40:02 <ski> (OO people often say that the values of `T' should be a subset of the values of type `S', but that's not accurate enough. subsets are one example of where this can be useful, but in OO, what's more immediately obvious to consider are not subsets, but rather quotient/factor sets. i.e. if you have a record type (an object type), and forget about some fields (methods), then you get a factor type of the original 
07:40:08 <ski> type)
07:40:32 <ski> hyperisco : co- or contra- variantly ?
07:41:44 <hyperisco> contra
07:42:02 <hyperisco> but hey, maybe we can talk about quotients
07:42:58 <hyperisco> guess contra is plausible for ordering but not for constructing the keys
07:43:32 <hyperisco> so I guess quotients would be the more natural thing to talk about, in addition to combining values, say if they're monoidal
07:44:59 <ski> hm, i'm not following really
07:45:38 <hyperisco> well what's the relation? S < T?
07:46:12 <ski> (i'll go do some laundry, bbiab. feel free to expound a little more, i'll check the backlog)
07:48:04 <hyperisco> if that's the relation of S and T, then say a:T and b:T and a < b, then presumably (S)a < (S)b  (subtypes preserve ordering)
07:49:24 <hyperisco> so then if you had a Map<S,A> you could, just considering the ordering, make sense of Map<T,A> but of course I didn't think about how you'd implement S → T
07:50:45 <hyperisco> derp I said that backwards
07:51:26 <hyperisco> meant T → S i.e. contravariant
07:52:36 <hyperisco> if you go Map<S,A> to Map<T,A> then because S < T we have less keys in T, but can make sense if A has a commutative monoid
07:53:02 <hyperisco> maybe you wouldn't actually need commutative either
07:53:30 <hyperisco> or say you had a quotient of S which preserved ordering, it'd be a similar affair
07:54:02 <hyperisco> not sure how closely quotients and subtypes run together
07:54:24 <dmwit> I suspect Map would have to be invariant in its first argument.
07:54:34 <hyperisco> at any rate, not a no-op
07:54:40 <dmwit> Because `assocs :: Map<k,v> -> [(k,v)]` means it has to be covariant.
07:55:05 <dmwit> And `lookup :: Map<k,v> -> k -> Maybe v` means it has to be contravariant.
07:55:27 <dolio> You can make it one or the other, but only by restricting the interface.
07:55:32 <dmwit> Right.
07:56:12 <hyperisco> yes it'd be a value conversion
07:56:21 <dmwit> No, that's not what we're saying.
07:56:27 <hyperisco> well it is what I am saying
07:56:32 <dmwit> Okay. It's not what I'm saying.
07:56:36 <ab9rf> hee
07:56:37 <dmwit> I still think you can have a no-op conversion.
07:56:56 <dmwit> But not with the rich interface we know and love from `Data.Map`.
07:56:56 <hyperisco> other than on equal types?
07:56:59 <mniip> dmwit, here's a thing to consider
07:56:59 <dmwit> Yes.
07:57:08 <mniip> Map comes bundled with a sort of "scalar product"
07:57:10 <dmwit> But you have to give up every function which returns a key.
07:57:11 <mniip> that lets you flip variance
07:57:25 <mniip> (>=) :: k -> k -> Ordering
07:57:36 <ab9rf> which means that Map was designed on the idea that its key would be invariant
07:58:14 <dmwit> Even things like `mapWithKey` have got to go.
07:58:24 <dmwit> Anything that has keys in a positive (covariant) position in its type.
07:58:51 <hyperisco> yes
07:59:25 <hyperisco> not quite sure what such an API would be useful for
07:59:44 <dmwit> Yes, I think it would be more sane to choose `k` to be invariant. =)
07:59:51 <dolio> If your subtyping system is right, you can even express the types for the restriction.
07:59:52 <dmwit> And keep the rich interface.
08:00:27 <dolio> exists (k' >= k). Map k v
08:00:33 <dolio> Or k' <= k
08:00:54 <dolio> Oops, that should be k' in the Map part.
08:00:59 <mniip> it is invariant if you bundle Map k v with the Ord k dictionary
08:01:15 <hyperisco> if you had subtypes which could be trivially constructed by their supertypes...
08:01:17 <mniip> because Map k v contains k's in covariant position but Ord k contains k's in contravariant position
08:02:37 <dolio> Anyhow, depending on whether you choose `k' <= k` or `k' >= k` you get contravariant or covariant parts of the map, essentially.
08:04:08 <coldpresent> hey all, i'm following this old paper, and i'm finding it hard to get the type signature of `eval` right http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
08:05:51 <Boarders> coldpresent: could you clarify what you mean by that?
08:05:51 <hyperisco> The types are given in the paper you linked. What do you mean you're having a hard time getting the type right?
08:08:09 <dminuoso> That ligature for ++
08:08:12 <coldpresent> Boarders: yeah, here is the same function with two signatures that don't compile, the second example is the same as in the paper https://pastebin.com/7dHkpqhM
08:08:15 <dminuoso> Looks so beautiful - I want it for emacs.
08:09:44 <Boarders> :t (/)
08:09:45 <lambdabot> Fractional a => a -> a -> a
08:09:48 <Boarders> :t div
08:09:50 <lambdabot> Integral a => a -> a -> a
08:09:53 <dminuoso> coldpresent: Read more closely, % is meant to denote integer division.
08:10:03 <dminuoso> coldpresent: So to implement that for `eval :: Term -> Int` you have to use
08:10:05 <dminuoso> :t div
08:10:06 <lambdabot> Integral a => a -> a -> a
08:10:06 <cocreature> dminuoso: pragmata pro has a ligature for ++ iirc
08:10:27 <pong> coldpresent: hi
08:10:31 <Boarders> :t fromIntegral
08:10:32 <lambdabot> (Num b, Integral a) => a -> b
08:10:33 <coldpresent> oh hey pong
08:11:12 <dminuoso> coldpresent: so replace / with `div` and you are good to go =)
08:12:23 <Boarders> coldpresent: haskell won't let you do automatic coercion from an Int like you have
08:12:39 <coldpresent> damn i somehow always assumed that (/) was integer division, guess i mixed it up with ocaml
08:12:42 <Boarders> e.g. the function f :: Num a => Int -> a; f n = n
08:12:44 <coldpresent> thanks guys
08:12:45 <Boarders> will not be happy
08:13:28 <Boarders> but you can do f' :: Num a => Int -> a; f n = fromIntegral n
08:14:20 <Boarders> I am trying to use compact regions but I get an error Data.Vector.Mutable: uninitialised element
08:14:29 <Boarders> has anyone who has tried to use this come across that?
08:19:14 <cocreature> Boarders: can you show us the code? I’m not sure it makes sense to have a mutable vector in a compact region
08:19:43 <Boarders> the code is not explicitly calling mutable vector is the thing
08:20:09 <Boarders> I'm not sure I can point to a sensible place in the code though unfortunately
08:20:48 <cocreature> well there has to be a mutable vector somewhere in your code, compact itself doesn’t even depend on vector so that’s not the internals of compact leaking
08:20:55 <dmwit> mniip: It is probably safe to make your co/contra-variant decisions based on the public API, independently of how the types are used internally.
08:21:21 <dmwit> mniip: So the fact that k's are stored and Ord k's are stored may not actually matter as long as all appearances of k in the API are contravariant.
08:21:31 <dmwit> mniip: Though this assertion would of course need careful proof.
08:22:39 <hyperisco> remember this is based on the assumption that subtypes preserve order
08:23:09 <hyperisco> that constraint alone isn't expressible in a subtype capable language I know of
08:24:24 <hyperisco> I haven't seen a language which can express hash equality implies equality
08:24:28 <cocreature> Boarders: if you’re not sure where the vector is coming from your best bet is probably to isolate it to some minimal example so that you can figure out where it’s used
08:24:54 <hyperisco> (that uses such things)
08:25:19 <Boarders> cocreature: I'll give that a go, but just to clarify the code does use Vector from but not MVector anywhere
08:25:29 <Boarders> would you still expect the same behaviour?
08:26:33 <cocreature> Boarders: the vector API might be using a mutable vector under the hood somewhere. it’s somewhat hard to guess what exactly is going on without seeing the code
08:26:49 <Boarders> I'll try to produce a minimal example
08:27:23 <cocreature> Boarders: the error message suggests that somewhere a mutable vector is being created. initially the elements of this array are all uninitialized and apparently something is trying to access them before they are initialized
08:42:14 --- mode: ChanServ set +o glguy
08:53:56 <cocreature> does criterion/cauge have a convenient way for plotting graphs of different implementations for varying size parameters? so if I compare 3 implementations, I’d like 3 lines with the size on the x axis
08:54:00 <cocreature> and time on the y axis
09:01:54 <Boarders> if you want to use cabal new-build what do you use for the equivlanet of extra-deps in stack
09:02:17 <glguy> Nothing, new-build figures those out
09:02:24 <jluttine> do you know any good online courses for haskell? perhaps with a possibility to get some certificate.
09:02:43 <cocreature> Boarders: extra-deps from hackage or extra-deps from some git repo?
09:03:51 <Boarders> cocreature: from hackage
09:04:13 <cocreature> then you don’t need to do anything
09:04:21 <cocreature> just add it to build-depends in your cabal file
09:05:40 <Boarders> cocreature: I get an error that it could not resolve the dependencies if I just do cabal new-build
09:06:45 <cocreature> then show us the error :)
09:07:24 <cocreature> presumably the versions of different packages are not compatible
09:07:34 <glguy> or you have a typo in a package name
09:07:53 <cocreature> heh, didn’t even think of that :)
09:08:59 <cocreature> if the package is new, you might also need a "cabal update"
09:10:04 <Boarders> I have this: https://lpaste.net/9104917968407494656
09:10:33 <glguy> Your GHC is too new and isn't supported by the packages you're installing
09:10:37 <glguy> [__2] rejecting: base-4.12.0.0/installed-4.1... (conflict: compact => base>=4.10 && <4.12)
09:11:08 <Boarders> can I specify a particular version of ghc to use?
09:11:23 <glguy> Yeah, you can use the -w flag to point to a different ghc
09:12:03 <glguy> For me that would look like: cabal new-build -w /Tools/ghc-8.4.3/bin/ghc
09:12:25 <Boarders> ok thanks
09:12:36 <Boarders> can you specify on a per project basis like stack?
09:12:50 <glguy> For me that would look like: cabal new-configure -w $HOME/Tools/ghc-8.4.3/bin/ghc
09:12:56 <glguy> that will set it for that project
09:13:03 <glguy> new-configure builds your cabal.project.local file
09:13:49 <glguy> and then that would be used for all the new-build invocations afterward
09:35:17 * hackage ghc-typelits-presburger 0.2.0.5 - Presburger Arithmetic Solver for GHC Type-level natural numbers.  http://hackage.haskell.org/package/ghc-typelits-presburger-0.2.0.5 (HiromiIshii)
09:58:01 <matheus23> how can i use a generated cabal.project.freeze file with cabal new-build?
10:05:17 * hackage xmonad-vanessa 2.0.0.0 - Custom xmonad, which builds with stack or cabal.  http://hackage.haskell.org/package/xmonad-vanessa-2.0.0.0 (vmchale)
10:07:42 <dminuoso> What exactly are .ghc.environment files for? Do you put them into repositories?
10:12:37 <cocreature> dminuoso: the idea is that cabal autogenerates them and then you can just run "ghci" in the project directory and it will pick up your dependencies
10:12:55 <cocreature> whether they are a good idea or not has been debated at length :) https://github.com/haskell/cabal/issues/4542
10:13:00 <cocreature> matheus23: cabal new-freeze should work
10:15:15 <matheus23> cocreature: well, the new-freeze generated it. But how do I use it? Do I just run cabal new-build? Seems so after some digging
10:15:28 <matheus23> btw, I'm Philipp, remember? :D
10:16:02 <cocreature> yep :)
10:16:17 <cocreature> matheus23: yeah just running new-build should be sufficient
10:29:33 <matheus23> cocreature: ok thanks. Sidenote to what I was doing: it was a little confusing that base versions are tied to ghc version. (Is that correct?) I guess cabal-new-style can't be quite as powerful as a complete nix build can be
10:29:53 <matheus23> I couldn't install, because I needed a specific base version (and therefore a specific ghc version)
10:31:21 <cocreature> right, cabal doesn’t attempt to manage GHC for you
10:31:27 <cocreature> and yeah base is tied to GHC
10:32:33 <matheus23> ok :)
10:33:20 <ChaiTRex> I wish base got the same version as the GHC it comes with.
10:33:30 <mniip> that's tricky
10:33:37 <mniip> the two aren't exactly parallel
10:34:03 <ChaiTRex> Ahh, I see.
10:36:21 <infinisil> Hey, how does cabal determine which ghc version to use?
10:36:42 <infinisil> Just whatever is on PATH?
10:36:57 <mniip> infinisil, normally yes
10:37:09 <mniip> it uses the ghc-pkg on the path to figure out what to work with
10:37:10 <glguy> Defaults to path, and it's overridable
10:37:22 <infinisil> Same with new-build style builds?
10:37:50 <glguy> Yeah, you can set it in the project file or it defaults to path
10:38:22 <glguy> cabal new-configure -w path/to/ghc
10:39:03 <infinisil> I see, thanks
10:39:37 <cocreature> you can also pass -w to new-build directly if you do not want to persist it
10:45:48 <matzy_> so i'm trying to learn haskell and was setting up emacs to start coding in it, but now i'm super confused on the whole stack/cabal thing. i'm already overwhelmed and just setting up the environment lol
10:46:23 <matzy_> i was using this guide, but it seems to be more cabal-based? should i use stack instead? is that more modern?
10:46:27 <matzy_> https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
10:46:41 <mniip> well you could not worry about packaging for now
10:46:55 <mniip> if you're learning you could just dump your code into a file and load it in ghci or compile with a single ghc command
10:47:18 <mniip> I've been doing that for 5 years now :P
10:47:23 <matzy_> hahaha
10:47:26 <cocreature> matzy_: both are fine don’t worry about it. what I would recommend is to not spend too much time on editor tool ing as you’re getting started. it tends to be somewhat complicated to setup and fragile once you’ve set it up so especially as a beginner it tends to lead more to frustration than it helps
10:47:39 <cocreature> matzy_: you can use ghci and ghcid to get fast feedback during development
10:48:59 <matzy_> cocreature: ok thanks a million. but i would still like to run my programs directly from emacs - should i just stick to CL compiling and running until I get better?
10:49:47 <matzy_> i'm also confused cause i installed haskell through the website but when i installed cabal it went and installed another version of ghc i think?  i believe the first is system-wide, and the cabal installation is isolated, right?
10:50:14 <matzy_> should i just remove cabal to avoid the confusion i've already dipped myself into?
10:51:36 <zachk> matzy_, did you use the haskell platform to install? 
10:51:49 --- mode: glguy set +v romanix
10:51:50 <romanix> matzy_, I don't mean to put a spanner in the works but I personally found Stack (https://docs.haskellstack.org/en/stable/README/) the easiest in terms of setting up Haskell
10:51:52 <zachk> you need cabal to install packages 
10:51:53 <matzy_> zachk: yeah
10:52:24 <romanix> matzy_, it installs ghc, packages and basically everything for you in an isolated way
10:52:28 <matzy_> zachk: well i went through the website and downloaded the dmg and installed that way (on mac until i fix my linux laptop)
10:53:30 <mniip> matzy_, my vim workflow is literally just  :!ghci %
10:53:33 <mniip> what more do you need
10:54:21 <matzy_> will stack install packages like cabal does? or will i end up needing both?
10:56:11 <romanix> matzy_, stack installs packages. You can start from a clean system without any Haskell stuff on it
10:56:53 <romanix> matzy_, afaik stack uses cabal underneath but I've never had to use cabal directly
11:11:22 <monochrom> Depending on what sense of "use" you mean, stack "uses" or "does not use" cabal underneath.
11:12:17 * hackage zeromq4-simple 0.0.0 - More constrained extensions to zeromq4-haskell  http://hackage.haskell.org/package/zeromq4-simple-0.0.0 (athanclark)
11:14:11 * slack1256 loves irc-core
11:14:33 <matzy_> sorry got disconnected, was in here a bit ago crying about already being confused trying to setup haskell with emacs. does stack download packages like cabal does?
11:14:59 <monochrom> Ah, another oversimplification.
11:15:14 <monochrom> And another unnecessary analogy.
11:15:40 <monochrom> stack downloads packages, but from stackage, not hackage. So does that count as "like cabal" or does it not?
11:15:56 <puregreen> does anybody know a library that would provide some lightweight sum-of-products type and FromJSON/ToJSON instances? I just had this (obvious in hindsight) idea that this would be very cool for ad-hoc JSON parsing (instead of lens-aeson and whatever)
11:16:03 <dolio> Is stackage like hackage?
11:16:14 <mmaruseacph2> monochrom, dolio: it does, as stackage is a subset of hackage
11:16:27 <matzy_> monochrom: ah, so there's not one remote repo for haskell packages?  there's multiple to choose from?
11:16:43 <monochrom> There are two.
11:16:44 <dolio> I thought 'stackage' was a list (or, set of lists) of things on hackage.
11:17:05 <mmaruseacph2> matzy_: stackage only has metadata on which package versions go in each snapshot, the download is still done from hackage
11:17:10 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #0
11:17:10 <puregreen> bonus points if it also provides a way to customize parsing, e.g. "and this field can correspond to any of these three keys because the spec writer is a moron"
11:18:38 <matzy_> ok, so there's really no difference to using stackage from hackage then?
11:18:56 <glguy> mmaruseacph2: No, it doesn't appear to download from hackage
11:19:08 <monochrom> What do you count as "different"?  Sorry but I am not telepathic.
11:19:44 <matzy_> I mean, it's my first time ever using haskell. Should a newbie care about which repo he uses or not? 
11:20:04 <mmaruseacph2> I think you shouldn't care about this; both should work
11:20:12 <mmaruseacph2> glguy: that's new to me, guess I was wrong
11:20:19 <glguy> matzy_: After the freebie of downloading GHC for you, stack adds a new layer of things to learn, but it's not that much more to learn
11:20:43 <puregreen> FPComplete has a Hackage mirror that Stack uses by default, but this is completely unrelated to Hackage vs Stackage
11:21:09 <mmaruseacph2> matzy_: mainly, the main difference is that some packages are not available (due to failing to build in the specific snapshot or not being added to the snapshot)
11:21:29 <mmaruseacph2> but if you're using common packages there should be no significant changes between the two
11:21:47 <glguy> stack got popular before cabal got its "new-build" functionality
11:21:59 <matzy_> mmaruseacph2: awesome, thanks for the actual explanation!  that helps a lot
11:23:28 <matzy_> is one more commonly used than the other? is one more "noob-friendly" or are both about the same?
11:24:35 <monochrom> I think stack is a lot to learn and is a distraction until you have a serious and large project.
11:25:13 <mmaruseacph2> I think "stack new; stack build; stack ghci" is all you need for learning
11:25:15 <monochrom> Then again people say "I learn best by dive-in projects" so maybe that's exactly the yak shaving they ask for.
11:25:17 <dolio> You can probably learn for months using the standard library.
11:25:22 <mmaruseacph2> but don't want another flame-war on this
11:26:23 <dolio> I guess it's not quite as comprehensive as when I started.
11:26:44 <monochrom> Don't worry, I won't do flame wars, but there are a bit of agreements and disagreements here and there I want to state.
11:27:03 <Boarders>  cocreature: here is an example of what I mentioned earlier about mutable vector in a compact region: https://lpaste.net/7759212553162457088
11:27:24 <Boarders> are you just not able to use Vector with Compact?
11:27:25 * ski . o O ( "Can we disagree to agree ?" )
11:28:13 <mmaruseacph2> I agree, monochrom
11:28:51 <dolio> I think every Richard Bird example I've ever seen probably still works using what comes with GHC, though.
11:29:47 * hackage cabal-helper 0.8.1.2 - Simple interface to some of Cabal's configuration state, mainly used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.8.1.2 (DanielG)
11:29:49 <monochrom> Yeah but today's people's notion of "learning" is "write a web app" not "do basic functional exercises".
11:30:31 <matzy_> monochrom: thanks for the advice, i already have cabal installed so i'll just go with that since stack is far above my needs rn
11:30:41 <ChaiTRex> Does anyone know the current overhead for ByteArray#s? Like how many bytes does it use to store the length and such?
11:31:05 <ChaiTRex> (not counting wasted space for alignment)
11:31:58 <dolio> They shouldn't call it learning, then. :)
11:32:47 * hackage purescript-iso 0.0.1 - Isomorphic trivial data type definitions over JSON  http://hackage.haskell.org/package/purescript-iso-0.0.1 (athanclark)
11:33:23 <matzy_> ah i didnt realize that stack is kind of a "front-end" for cabal.  so it's a debate of cabal-install vs stack moreso than stack vs cabal itself
11:34:10 <matzy_> thanks for the help!
11:34:24 <cocreature> Boarders: interesting, if you use an Array directly thinks work properly even though the Vector should just be a wrapper around an Array
11:36:35 <monochrom> I think I see why we disagree on whether stack is a big distraction or a small daily routine.
11:37:09 <dolio> Boarders, cocreature: What happens when you run that code?
11:37:21 <monochrom> Imagine I have finished marking exam papers and I'm adding up the marks.  (Because actually this is about to happen in a few days!)
11:37:47 <cocreature> dolio: Data.Vector.Mutable: uninitialised element
11:38:09 <monochrom> You could give me a basic $5 calculator that has only 15 buttons (0-9, + - * / =) and I would immediately know how to use that, no question here.
11:38:23 <dolio> Oh, interesting.
11:38:38 <dolio> So, here's my guess why.
11:38:56 <monochrom> Or you could give me a $2000 gamer laptop, which has like 100 buttons. Oh sure it has a calculator app too, I could use that.
11:39:02 <dolio> The vector creation makes a vector that's more than big enough.
11:39:15 <dolio> (For some reason.)
11:39:22 <monochrom> But now there are two possibilities depending on my personality.
11:39:54 <dolio> Then the region code just grabs the array and walks through it without consulting the length vector has for the array.
11:40:03 <mniip> monochrom, there's gotta be a most general unifier
11:40:05 <dolio> And runs into a bottom dangling off the end.
11:40:46 <cocreature> dolio: ah, that sounds reasonable!
11:40:51 <monochrom> One possibility: I could turn a blind eye on the other 88 keys I don't need, and the other 20 apps I am not using.  Then your $2000 laptop is not a big distraction for my basic task of adding a dozen of natural numbers.
11:41:56 <monochrom> The other possibility: I start asking why these other 88 keys, why those other 19 apps, and in fact inquirying the possibilities and impossibilities of a Turing machine, because it is right here staring into my face.
11:41:58 <cocreature> dolio, Boarders: looks like you’re right, if you add "force" to ensure that the underlying array is not larger, things work properly
11:42:20 <Boarders> dolio, cocreature: interesting
11:43:04 <mniip> 1535135414 [21:30:14] <ChaiTRex> Does anyone know the current overhead for ByteArray#s? Like how many bytes does it use to store the length and such?
11:43:10 <mniip> "a few machine words"
11:43:10 <monochrom> stack is a powerful tool, and it auto-generates a couple of config files.  If you are not the kind of persons who turn a blind eye on them, stack is a lot of distracting scaffolding and infrastructure.
11:43:33 <cocreature> monologuechrom
11:44:11 <mniip> monochrom, a thing to add to this analogy: when the calculator app breaks (it will break), you will be pissed because how can one mess up arithmetic; and have to figure out how to fix it
11:44:21 <dmwit> I am looking forward to the part of the monologue where they explain how cabal is not a powerful tool with a lot of distracting features.
11:44:56 <dolio> He didn't say that.
11:44:59 <mniip> dmwit, you're using cabal? I switched to dumping all source files for all libs I use into my home directory
11:45:03 <dolio> He said you should just use GHC.
11:45:13 <monochrom> Well yeah in my story it is the Windows running on that laptop that could suddenly blue-screen on you.
11:45:22 <dolio> I think.
11:45:36 <mniip> monochrom, that or updates
11:45:38 <ChaiTRex> mniip: OK, thanks.
11:46:36 <monochrom> dmwit: You won't. I keep advocating to use GHC directly.
11:47:07 <dmwit> monochrom: What's the largest program you have written using GHC directly?
11:47:30 <dmwit> Ah well.
11:47:34 <dmwit> For pedagogy, okay, I'm on board.
11:47:43 <dmwit> You can go a long way without it.
11:47:51 <glguy> I still want to hear about monochrom's large program
11:50:15 <monochrom> A lambda calculus parser and SECD machine.  A small library for symbolic formulas that can do substitution and MGU.
11:50:38 <mniip> sounds like 700 lines tops
11:51:06 <monochrom> Each below 100 actually.
11:51:12 <mniip> (I too just looked at what's the largest program I've written in haskell at all, I suspect it's the lambda calculus compiler: 500 loc)
11:53:00 <mniip> a DSL for compiling a lexically scoped language to brainfuck is 600 loc
11:54:23 <mniip> H6502 is 1000 lines total but that includes a tedious specification of each instruction so
11:55:05 <monochrom> I have some slightly larger exes.  I cabalize them, but that's just using *.cabal as a better makefile.
11:55:36 <monochrom> I don't even use sandboxing.
11:56:17 <monochrom> There are a few 20-line toys I use cabal new-build on. But that's just because I'm learning Backpack.
11:56:26 <Boarders> cocreature, dolio: do you know what would need to change so that this thing works out of the box without putting forces everywhere you have a vector?
11:56:41 <mniip> my team's last years' ICFPC submission was 1500 loc
11:57:07 <Boarders> I'm not really sure how compact works and thought it would have called force
11:57:12 <monochrom> I don't think it's so much "how many lines" as "how many in-house libraries to keep track of".
11:57:32 <dolio> Boarders: Does it still happen when you use `enumFromTo` for vectors, instead of going through lists?
11:57:41 <mniip> apparently I don't write haskell at all
11:57:45 <mniip> all I do is talk about it :)
11:58:00 <monochrom> Oh same here, I write Haskell tutorials :)
11:58:02 <dolio> I would guess that's your main problem. You're making it guess the size and it doesn't try to clip things off, because that's a waste of effort in most cases.
11:59:08 <dolio> There are fusion rules that turn `fromList (enumFromTo m n)` into `enumFromTo m n`, but they might not trigger depending on how you run this.
11:59:43 <Boarders> dolio: it does work with enumFromTo
12:00:09 <Boarders> my problem is I am trying to add it into a much larger code base with the same issue
12:00:16 <mniip> monochrom, maybe that means we are shortsighted and ignorant of the issues that arise when developing in haskell on the large?
12:01:52 <dolio> Boarders: Well, I don't know what's causing it there exactly. There might be multiple avenues.
12:02:03 <monochrom> But we can listen to people who have done large things.
12:02:07 <dolio> If it's always converting lists, then I think there's a conversion that specifies the exact length.
12:02:54 <dolio> The other option would be to use unboxed vectors, because those don't get pre-filled with bombs.
12:03:34 <Boarders> ah it does work with fromListN like you say
12:03:57 <Boarders> :)
12:05:04 <monochrom> I have taken a look at cabal new-build and the cabal.project file (or is it project.cabal?) and I can see that if your project consists of multiple in-house packages, it is saner to let cabal-install deal with them automatically, rather than you manually say "cabal install" 10 times, once for each directory.
12:06:08 <monochrom> And I presume stack offers a similar benefit in a similar context.
12:06:51 <monochrom> It is when those experts say "start using stack on day one! even when you're just doing beginner foldr exercises!" that I must protest.
12:07:34 <mniip> true
12:07:45 <monochrom> OK got to go. I want to watch a movie.
12:08:08 <mniip> naw you can't until this conversation is over
12:11:20 <Boarders> unfortunately this conversation will never end
12:11:38 <mniip> any homegrown type theorists wanna chime in? https://ghc.haskell.org/trac/ghc/ticket/15557
12:13:58 <kritzefitz> Is there some information about which versions of stack can handle which lts snapshots?
12:16:37 <MarcelineVQ> No, if stack can't handle some official snapshot then it's a bug and you need to update or should report it
12:17:30 <glguy> MarcelineVQ: it still could be useful to know which resolvers are too new for a stack executable
12:19:35 <dolio> mniip: Is this relevant? https://jesper.sikanda.be/files/overlapping-and-order-independent-patterns.pdf
12:20:35 <kritzefitz> Specifically I can't use lts-12.7 with stack 1.6.5, error can be seen here: https://gitlab.com/snippets/1748400
12:23:15 <sm> kritzefitz: you'll need to use a newer stack, as MarcelineVQ said
12:24:20 <kritzefitz> That seems like a small margin of compatibility there. Thank you for clarifying.
12:24:59 <sm> to pin down when that error appeared, you could cross-reference bhoogle's cabal file history and the versions in stackage snapshots
12:25:20 <sm> but it's not just that package. I don't know that there's any easy doc showing this info
12:26:18 <sm> it's because stack and cabal are quite separate teams, and the cabal format is quite rigid
12:26:47 <mniip> dolio, wow that server sure likes to chew up SSL
12:28:59 --- mode: glguy set +v catern
12:29:18 * hackage Kulitta 2.2.1 - Library for automated composition and musical learning  http://hackage.haskell.org/package/Kulitta-2.2.1 (DonyaQuick)
12:30:16 <mniip> dolio, I'm not sure you can quite do this here
12:30:27 <dolio> Ah.
12:30:28 <mniip> we have 'Eq a a = True' patterns
12:30:38 <mniip> can't quite translate that into unordered disjoint patterns
12:30:49 <kritzefitz> sm: A, I see. The problem proabably is that stack 1.6.5 uses Cabal 2.0, but bhoogle uses syntax that is only available since Cabal 2.2
12:31:11 <catern> hey #haskell, looking for inspiration, is there any library that provides an interface for writing serialization code such that, I can allocate chunks of memory and include their pointers into the serialized bytes (i.e. serialization of self-referential things), such that, the actual allocation at the end is all batched together into one big allocation?
12:31:22 <mniip> hmm I think I messed up in that comment
12:32:01 <catern> like, I think this would be nice with do-notation?
12:32:11 <sm> kritzefitz: correct. I think it first appeared with aeson, you'll find the issue by searching for that
12:32:17 * hackage composition-prelude 1.5.2.0 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.5.2.0 (vmchale)
12:32:28 <ski> hyperisco : hm, what you said about having the keys be in a commutative monoid reminded me of <https://en.wikipedia.org/wiki/Monoid_ring>
12:32:28 <mniip> ah, maybe not
12:33:22 <catern> (with a commutative monad I guess)
12:34:10 * mniip . o O ( key-ring )
12:35:01 <kritzefitz> catern: Sounds nice and too hard too write, though I know of no library that implements this currently.
12:36:47 * hackage git 0.2.2 - Git operations in haskell  http://hackage.haskell.org/package/git-0.2.2 (VincentHanquez)
12:36:53 <hexagoxel> @hackage compact
12:36:53 <lambdabot> http://hackage.haskell.org/package/compact
12:36:57 <hexagoxel> catern: ^
12:38:00 <catern> oh interesting, that's a lot more functionality than I expected I guess
12:43:43 <zachk> is there a way to destroy/free the memory that is used by a Compact?
12:44:05 <nitrix> Hi! https://media.discordapp.net/attachments/396456638950801409/481536747344494602/tenor.gif
12:47:17 * hackage hourglass 0.2.12 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.2.12 (VincentHanquez)
12:47:30 <hexagoxel> zachk: "The garbage collector considers the whole Compact to be alive if there is a reference to any object within it."
12:47:54 <hexagoxel> i.e. i read this as "the whole compact can/will be gc'ed"
12:48:13 <zachk> oic ty
12:59:12 <mniip> dolio, thanks for bringing this up anyway, made me realize a mistake
13:01:24 <dolio> Okay. :)
13:04:43 <glguy> Boarders: Becareful using enumFromTo, it segfaults if the upper bound is the maxbound on normal boxed vectors
13:04:51 <glguy> (I don't know what you were doing with it)
13:05:28 <MarcelineVQ> nitrix: https://www.youtube.com/watch?v=49ehyoi7qa0
13:06:19 <glguy> https://github.com/haskell/vector/issues/188
13:06:29 <Boarders> @glguy: thanks for the heads up
13:06:29 <lambdabot> Unknown command, try @list
13:34:55 --- mode: glguy set +v gobby
13:35:05 <gobby> ghc complains that it can't find a filepath when I use the relative file path string
13:35:19 <glguy> You use them the same as any other environment
13:36:00 <gobby> glguy: Not particularly helpful
13:36:21 <glguy> How do you figure? It means you don't have to use Haskell-specific knowledge to fix your bug
13:37:07 <glguy> You're either not running your program from the directory you thought you were or the file isn't where you thought it was
13:37:52 <glguy> or you're not using a relative path?
13:38:14 <Boarders> gobby: does https://hackage.haskell.org/package/directory-1.3.3.0/docs/System-Directory.html#v:makeAbsolute help?
13:38:27 <Boarders> or do you mean something else
13:39:09 <glguy> If using the relative path wasn't working, converting it to an absolute one first won't help either
13:39:31 <Boarders> yeah, I wasn't clear if gobby meant within their application or calling ghc from the command line itself
13:39:39 <Boarders> if it is the latter then it is not exactly a haskell issue
13:39:42 <glguy> Oh, but it could be useful to see what the actual absolute path was
13:39:48 <glguy> and then comparing that to what you'd expected it to be
13:39:49 <gobby> glguy: Ah fair enough
13:39:59 <gobby> I was calling from ghci
13:41:05 <gobby> thanks Boarders and glguy 
13:41:07 <glguy> We could help you debug your program if you wanted to put the program and the error message and some terminal output that demonstrated where the file actually was on gist.github.com
13:41:13 <gobby> I'll check out directory
13:41:17 * hackage http2-client-grpc 0.2.0.0 - Implement gRPC-over-HTTP2 clients.  http://hackage.haskell.org/package/http2-client-grpc-0.2.0.0 (LucasDiCioccio)
13:41:28 <glguy> but you shouldn't need the directory package to use relative paths
13:50:49 <Welkin> here's a fun one for you
13:51:25 <Welkin> I know that a list needs to contain two items that I want to match on. I don't care what order they are in. What's a reasonable way to do it?
13:51:46 <Welkin> Besides converting to a Map, which actually seems quite reasonable
13:52:18 <Welkin> it's already an association list anyway, so Map it is
13:53:25 <mniip> Welkin, a view pattern on a sort?
13:53:51 <mniip> alternatively, match guards on min/max
13:54:38 * ski . o O ( select/3 )
13:56:05 <mniip> ski, permutations/2 should be sufficient
13:56:26 <Welkin> what is this? erlang?
13:56:34 <mniip> prolog/1
13:57:22 <ski> > [(x,y) | Left (2,x):rest <- tails [Left (1,2),Right (4,4,5),Left (2,3),Right (1,1,1)],Right (1,y,1) <- rest]
13:57:24 <lambdabot>  [(3,1)]
13:57:59 <ski> mniip : sure, but that is often defined in terms of select/3
13:58:28 <ski> hm, i suppose my example does take order into account ..
13:58:43 <mniip> I have no idea what select/3 does
13:58:56 <mniip> select([x,y,z],x,[y,z]) ?
13:59:32 <ski> `select(XXs,X,Xs)' holds iff `XXs' is the list `Xs', with `X' inserted anywhere
13:59:59 <ski> iff `Xs' is the list you get by removing (selecting) the element `X' anywhere from `XXs'
14:01:02 <ski> (in Haskell terms, `exists front,back. xs = front ++ back /\ xxs = front ++ [x] ++ back')
14:01:39 <ski> it's a variant of member/2, which also gets you the remainder of the list
14:01:42 <kritzefitz> If I want to add modules to the autogen-modules read from the .cabal file in Setup.hs, is there a better place to do it than readDesc?
14:04:22 <Welkin> on second thought, you are right about sorting then matching
14:04:30 <Welkin> I can't pattern match on a Map
14:08:42 --- mode: glguy set +v meatwiggler
14:09:26 <mpickering> Is there a way to run hpack on a whole folder and recurse into subdirectories?
14:11:13 <glguy> find . -name "*.cabal" -exec hpack {} \; ?
14:13:01 <mpickering> hehe yes exactly what I just came up with
14:13:01 <mpickering> find . -name "package.yaml" -exec hpack --force {} \;
14:13:36 <glguy> and then: find . -name package.yaml -delete
14:14:04 <dmwit> Welkin: If the list is long, you have to touch every element just to learn that it isn't of length two. Maybe that doesn't matter for you, dunno.
14:14:40 <dmwit> Welkin: But if it does, you might consider `foo [x_, y_] = ... where x = min x_ y_; y = max x_ y_`.
14:15:01 <dmwit> This pattern will quickly not match even if given an infinite list.
14:15:54 <Welkin> for context, it is the request body from an http post request, parsed with `Network.Wai.Parse.parseRequestBodyEx`, which produces ([Param], [File a])
14:16:10 <Welkin> I only have two parameters and two files for this particular request
14:23:47 * hackage urlpath 9.0.0.1 - Painfully simple URL deployment.  http://hackage.haskell.org/package/urlpath-9.0.0.1 (athanclark)
14:30:22 <ph88> can somebody help with a small bug ?  https://github.com/snoyberg/packdeps/pull/45
14:37:13 <ZeuPiark> bye
14:40:21 <Welkin> can someone remind me how to use typed holes?
14:44:21 <Welkin> > sortBy (\(a, _) (b, _) -> compare a b) [("beetle", 2),("alligator", 1)]
14:44:23 <lambdabot>  [("alligator",1),("beetle",2)]
14:47:07 <mpickering> glguy: These aren't my package.yaml's don't get the wrong idea about me :P
14:48:30 <Welkin> https://lpaste.net/2238680410877853696
14:48:40 <Welkin> I don't know what to make of this
14:48:48 <Welkin> some issue with MonadBaseControl
14:49:14 <Welkin> I have no idea what the type of this function should look like, but it is pretty much just a fancy IO with some constraints
14:49:45 <Welkin> the FileInfo c is throwing me off
14:50:26 <Welkin> I didn't give it a type signature at all, hoping the compiler would tell me what it should be, but it gives me an error instead
14:52:08 <Welkin> I added FlexibleContexts as suggested and it now works
14:52:24 <Welkin> I have never used that pragma before so I don't know why I need it
15:01:55 <int-e> Welkin: You need it to instantiate a class constraint with something that is not a variable; in your case, the 'IO' for MonadBaseControl. Since ghc-8.4 (I think) that restriction even applies to inferred types rather than just explicit type signatures.
15:29:17 * hackage purescript-iso 0.0.1.1 - Isomorphic trivial data type definitions over JSON  http://hackage.haskell.org/package/purescript-iso-0.0.1.1 (athanclark)
15:41:31 --- mode: glguy set +v braulio77
15:41:36 <braulio77> I know that using lazy io is not usually recommended, but I'm just trying to learn about it and motivate the use of libraries such as pipes
15:42:28 <braulio77> the problem is, code I would expect to be behaving lazily is not
15:43:29 <glguy> braulio77: If you have questions about specific code you can put the code on gist.github.com and explain the mismatch in what you expected and observed
15:43:34 <braulio77> I have reduced the relevant code to two small functions here https://gist.github.com/BraulioVM/9e5d6495570eb6be5e221eb18210bbd7 and I have also written down the details of what I would expect that code to do and what is actually happening
15:43:42 <braulio77> right!
15:44:01 <glguy> Don't make it look like we're the same person
15:44:25 <braulio77> hahaha
15:45:06 <braulio77> I have also checked how `hGet` is implemented in `Data.ByteStrings.Lazy` and it's very similar to my implementation
15:46:51 <braulio77> one thing I thought could be going wrong is the `Show` instance of lazy bytestrings being strict in its argument, but that is not the case
15:48:51 <glguy> braulio77: ByteString's append is strict in both arguments, so you can't use it like this
15:49:04 <glguy> Oh, I'm looking at the wrong code so I'm not sure about what I just said now
15:49:40 <glguy> nevermind, for lazy BS it's fine
15:51:08 <braulio77> if instead of printing the whole input, for example, I `print (head input)`, the program returns inmediately
15:51:54 <braulio77> and it doesn't consume the rest of the received buffers, which makes sense to me
15:52:53 <braulio77> I mean "inmediately" as "after the client has sent the first buffer"
15:56:00 <glguy> You're getting an early lesson in how delicate lazy IO is.
15:56:54 <glguy> You just be very careful to never force any more than you needed which means you need absolute knowledge of how much each function you're using on the value forces
15:58:25 <braulio77> I'm getting a lesson for sure haha
15:58:52 --- mode: glguy set +v zipp
15:58:58 <hpc> to be precise, you're learning how delicate it is to control when something is evaluated
15:59:02 <hpc> (which is what drives lazy IO)
16:01:09 <braulio77> yes, I've been double checked that `show` in lazy bytestrings and `print` don't force values before `printing` (they can print infinite structures)
16:01:43 <braulio77> `BSL.append` also appears to be lazy in its arguments
16:02:37 <glguy> Yeah, I just had the wrong file open when checking and wasn't being very careful
16:02:53 <braulio77> and, as I understand, that would be all that one needs to have my program print the client's input lazily
16:03:20 <glguy> You could chunk the input into lines or whatever sort of units the program expects
16:05:02 <braulio77> yes, my intention was to use `Data.Binary` or something like that to parse the input and get a lazy `[Message]` list
16:07:00 <braulio77> I came up with something though, maybe `BSL.append` needs much more data than what I'm providing to "fill a chunk"
16:07:09 <braulio77> I'll be more precise in a second
16:09:54 <braulio77> ok I figured it out
16:11:54 <braulio77> I believe that the client has to send big enough buffers in order for `BSL.append` to add another chunk to the lazy bytestring
16:12:49 <braulio77> if I run the client like `(while true; do yes | head -n 1000; sleep 2; done ) | netcat localhost 8001` then it does not need to consume the whole client input before printing it
16:13:11 <c_wraith> you can create chunks of whatever size you like, if you're willing to deal with lazy IO
16:14:57 <c_wraith> hmm. depending on code structure, you might be able to get away with someone else's lazy IO doing the coordination
16:17:13 <c_wraith> toChunks and fromChunks are both lazy.
16:18:28 <braulio77> what do you mean "someone else"? My romantic idea of lazy IO would be that (if I even had to do) I would have a `[Message]` lazy list parsed from the client's input and my program would be some sort of `fold` or `forM` over that list
16:19:06 <braulio77> ok then I can probably write a hacky version of `append` that creates a new chunk each time
16:19:10 <braulio77> I'll try that
16:22:10 <c_wraith> sadly, lazy IO isn't magic. it's just sneaky concurrency
16:23:46 <braulio77> lol my intuition of what was going on is again flawed
16:25:17 <braulio77> if in the program I posted earlier I replace `print input` with `print (BSL.toChunks input)` then I can see that `BSL.append` creates a chunk for every message received
16:25:26 <glguy> It's probably fun to play with, but this really isn't a serious solution for doing network IO
16:26:04 <glguy> lazy byte strings are just a list of chunks, append on them just appends the two lists never altering the chunks
16:27:11 <glguy> One of the bad parts of this is that it's now hard to contain exceptions that can be raised while reading from the socket
16:27:23 <braulio77> maybe the reason I'm not seeing one message at a time is some sort of buffering while printing to stdout
16:27:39 <braulio77> right
16:27:39 <glguy> stdout has line buffering by default
16:29:00 <glguy> this also makes it hard to control when evaluation will cause your program to block which means it will be hard to support waiting on more than one event whether that's local input or a second socket
16:29:00 <braulio77> are there any other reasons while this would never work in production apart from exceptions (it's not that I need more than that, but am curious)?
16:29:20 <braulio77> right
16:29:24 <glguy> so you've lost error handling and multiple sources of input
16:30:11 <braulio77> and so libraries like pipe or conduit address these problems?
16:30:31 <glguy> not so much for the multiple sources of input
16:30:53 <nek0> hi folks, I just installed the haskell platform on a windows machine and found my way to the msys2 folder, but when I fire it up, it can't find either cabal or ghc in its PATH. Is there a step I missed?
16:31:22 <glguy> I like using forkIO to allocate one lightweight thread per client to handle input, chunking things into messages at that level and then using things like TQueue or Chan to get concurrency
16:32:40 <glguy> for example https://github.com/glguy/irc-core/blob/v2/src/Client/Network/Async.hs#L166-L184
16:33:22 <marvin2> nek0 IIRC platform doesn't update PATH 
16:33:38 <marvin2> so you have to do that step manually
16:34:06 <nek0> ah, ok.
16:34:17 * hackage hid-examples 0.2 - Examples to accompany the book "Haskell in Depth"  http://hackage.haskell.org/package/hid-examples-0.2 (bravit)
16:35:10 <braulio77> glguy I see 
16:36:02 <braulio77> I was also interested in handling bytestring input as streams and being able to send them back to other clients and writing to the filesystem while streaming
16:36:10 <glguy> braulio77: with stream processors like conduit or pipes you can run one thread for each client running one of the processors on each
16:36:41 <glguy> its not necessary to get streaming behavior, but it's an option
16:40:50 <braulio77> glguy and so how would you go about having streaming behaviour, with effects, would you write the loops manually?
16:41:40 <glguy> yeah
16:42:13 <braulio77> so actually the first example I posted here was working as expected but the problem was the terminal buffering, it was not lazy IO's fault but mine
16:43:11 <braulio77> glguy I see, but working on lazy lists was so magical.... hehe
16:43:28 <glguy> Yeah, it's certainly something :)
16:45:22 <braulio77> ok thank you all very much! I certainly learned
16:45:36 <braulio77> I'll see how far I can get with lazy IO and what other problems I encounter along the way
16:46:04 <zachk> you might want to use strict IO using strict bytestrings and use forkIO from Control.Concurrent
16:46:39 <braulio77> I am using a thread for each client, but I'm not sure that's what you mean
16:47:24 <zachk> yea thats what I mean with forkIO, I have had problems with lazy IO and network sockets before, it would print out results or process results, it seemed to be, when it felt like it 
16:48:14 <braulio77> I wanted the lazy bytestring for having a single bytestring (albeit a lazy one) representing the whole client's input, which we do not even have yet (and I felt that was pretty cool)
16:48:29 <philippD> Is there an `Add` Monoid in `base`? I need something like an `instance Num a => Monoid (Add a) where mempty = Add 0; Add a `mappend` Add b = Add $ a + b`
16:49:06 <glguy> ?index Sum
16:49:07 <lambdabot> Data.Monoid, Data.Functor.Sum
16:49:24 <philippD> Ahh, I was just searching for the wrong name
16:49:29 <philippD> Thanks, glguy
16:49:37 <zachk> braulio77, are you doing text over the network and is it line based? I would just break it up into lines if that is so 
16:50:21 <braulio77> my intention is to use binary serialization with `binary` or some library like that 
16:50:44 <braulio77> I will have a `Message` data type which I will send, serialized, over the network
16:51:23 <dmrd_> hey folks, here's a question on style. How would you write a `map (map f) listOfLists` in a cleaner way? Or is this the way to go?
16:55:19 <zachk> maybe fmap (fmap f) listOfLists ? 
16:56:28 <philippD> define `(<$$>) = fmap . fmap` and then use `f <$$> listOfLists`?
16:56:31 <dmrd_> zachk: lmao. Not sure if you're serious
16:57:01 <marvin2> I think map (map f) is just fine
16:57:35 <mizunno> I like to use composition: (map . map)
16:57:38 <dmrd_> I think so too marvin2 but I was actually hoping to use the opportunity to get better at using the '.' (dot)  operator
16:58:13 <dmrd_> so would it work as `map . map f listOfLists` or is there parenthesis needed here?
16:58:54 <philippD> > (map . map $ succ) [[1,2,3],[4,5,6]]
16:58:57 <lambdabot>  [[2,3,4],[5,6,7]]
16:59:45 <dmwit> If you're going to use parens, don't throw a $ in too.
16:59:54 <dmwit> > (map . map) succ [[1],[2]]
16:59:56 <lambdabot>  [[2],[3]]
17:00:12 <dmwit> dmrd_: Simple is best. `map (map f) xs`.
17:01:05 <glguy> +1
17:02:34 <dmwit> If you're feeling cheeky that day, choose `a` as your base variable and pluralize it twice to emphasize there's two layers of lists.
17:02:38 <dmwit> `map (map f) ass`
17:02:52 <dmwit> CAN'T. STOP ME. NOW
17:05:35 <dmrd_> thanks folks.
17:06:05 <philippD> @let ass = [[1},[2]]
17:06:05 <lambdabot>  Parse failed: Parse error: }
17:06:12 <philippD> @let ass = [[1],[2]]
17:06:13 <lambdabot>  .L.hs:177:1: error:
17:06:13 <lambdabot>      Multiple declarations of ‘ass’
17:06:13 <lambdabot>      Declared at: .L.hs:175:1
17:06:39 <philippD> @let (💩) = fmap . fmap
17:06:40 <lambdabot>  .L.hs:177:1: error:
17:06:40 <lambdabot>      Multiple declarations of ‘💩’
17:06:40 <lambdabot>      Declared at: .L.hs:176:1
17:06:48 <philippD> > succ 💩 ass
17:06:50 <lambdabot>  [[2],[3]]
17:11:00 <mniip> dmwit, fmap succ <$> ass
17:21:38 <N3RGY> I've had this problem in the past of trying to create flow graphs of streaming data, but running into complexities with different parts of the flow graph producing data at different rates. I think I might have come up with a pretty dumb but solid approach to offloading this to the compiler. It's a wrapper around Stream that counts the number of functor layers. Thoughts? 
17:21:43 <N3RGY> https://github.com/wyager/synk/blob/master/app/Main.hs
17:24:49 <N3RGY> actual implementation at https://github.com/wyager/synk/blob/master/src/Synk.hs . Basically just calls directly to stuff in Streaming but does length bookkeeping at the type level
17:31:47 <dmrd_> Ok here I go again. I'm trying to use something along the lines of `biplate` or anything on `lenses` to traverse to the leafs of a tree-like structure and perform a transportation there. Any clues as to how to go about this? I've been getting better about using `biplate` thanks to some tips I got here, but I'm still shaky on specifying something along the lines of: `go to the leafs and, say,  apply function 'f'`
17:31:55 --- mode: glguy set +v k0d3fr34k[m]
17:39:35 <glguy> k0d3fr34k[m]: read your messages
17:40:03 <k0d3fr34k[m]> Hello everyone, I am on linux, should I install ghc via stack or through its own package?
17:40:29 <glguy> k0d3fr34k[m]: depends on the Linux. For learning Haskell you'll do fine to go along without stack
17:41:22 <k0d3fr34k[m]> What about after learning. I am on archlinux, a package is available for ghc, as well as via stack (obviously)
17:41:46 <glguy> After learning cabal's new-build functionally is great
17:41:59 <k0d3fr34k[m]> okay
17:42:15 <k0d3fr34k[m]> but many people recommend against cabal?
17:42:19 <glguy> Arch Linux has issues using it's built-in packages. Make sure you get ghc-static
17:42:30 <k0d3fr34k[m]> What exactly are people using currently?
17:42:32 <glguy> And check out the wiki
17:42:47 <k0d3fr34k[m]> Arch Linux has issues using it's built-in packages. Make sure you get ghc-static
17:42:47 <k0d3fr34k[m]> Okay
17:43:22 <glguy> the devs got creative with static vs dynamic linking, so you have to be aware of what they did
17:43:26 <k0d3fr34k[m]> Is the wiki up to date? Cause many blogs are outdated, and there are mixed opinions all over the internet over the cabal vs stack issue
17:44:41 <glguy> You can find lots of opinions, but stack got popular before cabal got it's new-build functionality, which is what I'm recommending
17:45:19 <k0d3fr34k[m]> Okay, I'll surely check that out 🙂
17:45:20 <k0d3fr34k[m]> Thanks
17:47:24 <mizunno> dmrd_, Depends of your tree-like structure implementation, but if you have define a tree recursively you can apply a function recursively, stopping on leafs and applying f
17:48:58 <dmrd_> mizunno: eh it's a little trickier. This 'tree' comes from a third party and every node uses a different constructor (making thus dozens of combinations). In particular, it comes from `haskell-src-exts`. It's all good though, I think I may be a clue as to how to go about it. However, I'm ultimately exploiting some domain knowledge here and not finding a general solution / trick
17:51:58 <dmrd_> actually nevermind. My "domain knowledge" wont be enough here. whoops
18:06:09 <fragamus> Hey I’m learning about traverse and I understand it as far as the instance for [a] but I can’t fathom how it generalizes to be useful in other instances
18:06:49 <fragamus> :t traverse
18:06:50 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
18:06:57 <dmrd_> fragamus: can you clarify that further? I know some traverse. Emphasis on some
18:08:24 <N3RGY> The most obviously Traverse-related function is probably mapM
18:08:26 <N3RGY> :t mapM
18:08:27 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
18:08:48 <fragamus> It has a clear meaning for lists but I can’t understand how it is useful in other situations
18:09:29 <dmrd_> I used it, for example, on Abstract Syntax Trees. Are you familiar with `Haskell-Src-Exts` fragamus ? Or do you know what an AST is all about?
18:09:30 <N3RGY> It just performs some monadic action for every value in a data structure (roughly speaking)
18:10:25 <fragamus> Yes ast
18:10:31 <fragamus> Got that
18:10:37 <N3RGY> > mapM (*) [1,2,3] 5
18:10:40 <lambdabot>  [5,10,15]
18:10:47 <N3RGY> > mapM (*) (Just 10) 5
18:10:49 <lambdabot>  Just 50
18:10:54 <N3RGY> > mapM (*) Nothing 5
18:10:56 <lambdabot>  Nothing
18:11:20 <dmrd_> fragamus: Actually, nevermind. I ended up using a fold not a traverse. My bad. Please ignore my previous remark
18:11:32 <N3RGY> > mapM (*) (Data.Map.singleton 'a' 11) 5
18:11:33 <fragamus> Ok
18:11:35 <lambdabot>  fromList [('a',55)]
18:15:42 <N3RGY>  Practical example would be if you have "lookupPicInDB :: UserID -> IO ProfilePicture" and "usernames :: Map Username UserID", you could have "mapM lookupPicInDB usernames :: IO (Map Username ProfilePicture)"
18:17:25 <N3RGY> Notice that mapM and traverse are the same, but mapM has a more specialized type 
18:18:14 <fragamus> Thanks that’s starting to make sense
18:19:42 <N3RGY> Functor/Foldable/Traversable are incredibly useful for manipulating nested data structures with some sort of value stored in them. Large swaths of "business logic" turn out to be operations provided by these typeclasses
18:21:51 <N3RGY> (And, worth mentioning, GHC can derive them for you automatically in most cases)
18:22:01 <fragamus> > traverse (x-> [x*10+1, x*10+2,x*10+3]) [5,6,7]
18:22:03 <lambdabot>  error:
18:22:04 <lambdabot>      Pattern syntax in expression context:
18:22:04 <lambdabot>          x -> [x * 10 + 1, x * 10 + 2, x * 10 + 3]
18:22:21 <fragamus> Gah
18:23:02 <fragamus> > traverse (\x-> [x*10+1, x*10+2,x*10+3]) [5,6,7]
18:23:05 <lambdabot>  [[51,61,71],[51,61,72],[51,61,73],[51,62,71],[51,62,72],[51,62,73],[51,63,71...
18:24:26 <N3RGY> > sequence [[1,2],[3,4],[5,6]]
18:24:28 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
18:24:58 <fragamus> Clearly it is powerful but I still need to ponder
18:25:34 <N3RGY> I think using List as the applicative makes this a bit more confusing than it has to be
18:26:13 <N3RGY> > let failFive x = if x == 5 then Nothing else Just x in traverse failFive [1,2,3]
18:26:15 <lambdabot>  Just [1,2,3]
18:26:17 <N3RGY> > let failFive x = if x == 5 then Nothing else Just x in traverse failFive [1,2,5]
18:26:19 <lambdabot>  Nothing
18:27:02 <N3RGY> > let failFive x = if x == 5 then Left "Fail: 5 detected" else Right x in traverse failFive [1,2,5]
18:27:04 <fragamus> That’s instructive
18:27:05 <lambdabot>  Left "Fail: 5 detected"
18:29:53 <chessandgo> does anyone know of a good websocket library that isn't https://hackage.haskell.org/package/websockets-0.10.0.0
18:30:02 <chessandgo> apparently the "bug" with async exceptions is actually a feature
18:30:15 <chessandgo> which is a hurdle for my design
18:34:26 <blankhart> is there a reason Data.Text.Foreign only exports functionality for CStringLen and not CString, while Data.ByteString has both?
18:36:02 <N3RGY> blankhart: Unicode does not define string terminators
18:37:35 <blankhart> thank you N3RGY
18:37:37 <N3RGY> Honestly it seems a bit questionable that ByteString has a non-len cstring, but I guess realistically that's a common FFI requirement
18:39:20 <fragamus> > let failFive x = if x == 5 then Nothing else Just x in traverse failFive [1,2,5]
18:39:23 <lambdabot>  Nothing
18:39:25 <geekosaur> that's pretty much what it's there for, yes. C hasn't yet figured out that NUL terminators are problematic
18:39:37 <fragamus> > let failFive x = if x == 5 then Nothing else Just x in traverse failFive [1,2,7{
18:39:38 <blankhart> so if i am converting from Text to an external C library that expects a CString, i should encode/decode to UTF8 via ByteString?
18:39:40 <lambdabot>  <hint>:1:81: error:
18:39:40 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:39:55 <fragamus> > let failFive x = if x == 5 then Nothing else Just x in traverse failFive [1,2,5]
18:39:58 <lambdabot>  Nothing
18:40:06 <N3RGY> blankhart: Yeah, that sounds good
18:40:13 <fragamus> > let failFive x = if x == 5 then Nothing else Just x in traverse failFive [1,2,7]
18:40:16 <lambdabot>  Just [1,2,7]
18:40:54 <N3RGY> blankhart: That's assuming the C library won't break on unicode, which it might
18:41:16 <fragamus> > let failFive x = if x == 5 then Nothing else Just x in traverse failFive [1,5,7]
18:41:19 <lambdabot>  Nothing
18:41:22 <N3RGY> Anything that still uses null terminators is highly suspect
18:42:06 <mniip> system calls
18:42:33 <N3RGY> Like I said, highly suspect :)
18:43:05 <fragamus> > let failFive x = if x == 5 then Nothing else Just x in traverse failFive [1,2,3,4]
18:43:07 <lambdabot>  Just [1,2,3,4]
18:43:25 <N3RGY> fragamus, you might want to use ghci for this
18:43:37 <fragamus> > let failFive x = if x == 5 then Nothing else Just x in traverse failFive [1,2,3,4,5,6,7]
18:43:39 <lambdabot>  Nothing
18:43:47 <fragamus> I might
18:44:08 <fragamus> I have a question
18:44:17 --- mode: glguy set +v bigos
18:44:39 <bigos> ?
18:45:34 <fragamus> Obviously the list is being accumulated in a just but what operator is used to combine the Just [1,2,3,4] with the Nothing
18:46:03 <fragamus> Yielding Nothing
18:46:27 <koz_> fragamus: It's based on the Applicative instance for Maybe.
18:46:33 <N3RGY> :t (*>)
18:46:34 <lambdabot> Applicative f => f a -> f b -> f b
18:46:36 <fragamus> Oh
18:46:47 <koz_> If you look at how traverse is defined, you'll see it.
18:46:47 <glguy> bigos: read your messages
18:47:17 <fragamus> I shall have a look at that, thanks
18:47:28 <bigos> glguy: it's not worth it, time to go to sleep
18:54:57 <droplet> I'm using (stack) ghci for a package with lots of modules, and on each :r it reloads them all saying flags changed each time
18:56:30 <droplet> Even though I'm fairly sure I'm not changing any flags
18:58:58 <droplet> Any idea why?
19:00:09 <geekosaur> what version of ghc? one of them added optimization flags to the set of flags checked for changes… missing that ghci never compiles with optimization because the bytecode interpreter doesn't support it
19:01:20 <droplet> 8.2.2
19:04:36 <geekosaur> hm, nnot recalling versions but that could be it
19:05:05 <geekosaur> running ghci with -fobject-code might help (will have to edit the stack config)
19:05:15 <droplet> I am running with -fobject-code
19:06:44 <geekosaur> hm. this may be a different but related issue, then. there were several problems with flags and ghci
19:06:55 <geekosaur> which I think were fixed in 8.4
19:19:24 <fragamus> > let failFive x = if x == 5 then Nothing else Just x in traverse failFive [1,2,3]
19:19:26 <lambdabot>  Just [1,2,3]
19:20:14 <fragamus> Is it consing a new list from those x values
19:21:40 <fragamus> Oh I need to go look at the Applicative instance for Maybe
19:24:09 --- mode: glguy set +v Albufo
19:24:27 <Albufo> glguy
19:24:32 <Albufo> you  need  users
19:25:32 --- mode: glguy set +v xeni55
19:25:32 --- mode: glguy set +v killer_of_hearts
19:25:39 <xeni55> hi
19:25:39 <killer_of_hearts> hi
19:25:43 --- mode: glguy set +v ermali_boy
19:25:43 --- mode: glguy set +v Loni_it
19:25:43 --- mode: glguy set +v ergysi
19:25:44 --- mode: glguy set +v boy4boy
19:25:55 --- mode: glguy set +v LandofEagles-Com
19:25:57 --- mode: glguy set +v avvocat_lezhjan
19:25:58 <ermali_boy> hi
19:25:59 --- mode: glguy set +v monda
19:25:59 <LandofEagles-Com> hi
19:25:59 <monda> hi
19:25:59 <avvocat_lezhjan> hi
19:25:59 <xeni55> hi
19:25:59 <killer_of_hearts> hi
19:25:59 <boy4boy> hi
19:25:59 <Loni_it> hi
19:25:59 <ergysi> hi
19:26:00 --- mode: glguy set +v Beni-usa
19:26:01 --- mode: glguy set +v cuni_me_fiat_uno
19:26:03 --- mode: glguy set +v LEDIO
19:26:04 --- mode: glguy set +v milanistja
19:26:06 --- mode: glguy set +v ermali_love
19:26:40 <LEDIO> hi
19:26:41 <ermali_love> hi
19:26:41 <ermali_boy> hi
19:26:41 <LandofEagles-Com> hi
19:26:41 <milanistja> hi
19:26:41 <ergysi> hi
19:26:41 <monda> hi
19:26:41 <avvocat_lezhjan> hi
19:26:41 <killer_of_hearts> hi
19:26:41 <Loni_it> hi
19:26:41 <Beni-usa> hi
19:26:41 <xeni55> hi
19:26:41 <cuni_me_fiat_uno> hi
19:26:41 <boy4boy> hi
19:27:01 <LEDIO> hi
19:27:02 <ermali_love> hi
19:27:02 <LandofEagles-Com> hi
19:27:02 <monda> hi
19:27:02 <avvocat_lezhjan> hi
19:27:02 <Loni_it> hi
19:27:02 <killer_of_hearts> hi
19:27:02 <Beni-usa> hi
19:27:03 <ergysi> hi
19:27:13 --- mode: glguy set +j 3:5
19:27:42 <ermali_love> hi
19:27:42 <avvocat_lezhjan> hi
19:27:42 <Loni_it> hi
19:27:42 <Beni-usa> hi
19:27:42 <killer_of_hearts> hi
19:27:53 <ermali_boy> hi
19:29:54 --- mode: glguy set +r
19:34:28 --- mode: glguy set -r
19:36:36 --- mode: glguy set +f #haskell-unregistered
19:36:43 --- mode: ChanServ set +o dmwit
20:12:48 <CindyLinz> hi?
20:12:53 --- mode: glguy set +v CindyLinz
20:13:09 <CindyLinz> hi?
20:13:45 <lambdabot> Hello!
20:23:17 * hackage pointfree-fancy 1.1.1.9 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-fancy-1.1.1.9 (vmchale)
21:12:17 <olligobber> hi
21:29:54 <zipp> Anyone familiar with Wavefront? I've exported from text from Blender and I've run it into a program. The issue is that the front faces of the letters do not render, only the edges, so if you look at them head on, they appear "invisible"... Not sure if this is a Blender issue, or if there's an issue rendering the Normals of my Faces, which seems to be broken in that trying to get the normal index for a face
21:29:56 <zipp> always returns 1.
21:38:49 --- mode: ChanServ set +o glguy__
21:58:48 --- mode: glguy_ set -o glguy_
23:02:58 <kuribas> why isn't the strict writer monad strict in the acumulator?
23:03:01 <kuribas> For example using a strict tuple?
23:06:10 <glguy> because that wouldn't really help 
23:07:59 <kuribas> glguy: would a strict tuple evaluate the accumulator when it evaluates the monadic value?
23:08:35 <kuribas> Of course that would imply changing the MonadWriter typeclass...
23:09:53 <glguy> The problem comes from guessing what Writer's behavior is by looking at the MonadWriter class rather than focusing on what's possible from the writer type
23:10:48 <kuribas> glguy: if the tuple in the MonadWriter class was strict, the state accumulator would be strict as well, right?
23:10:52 <glguy> Making the "accumulator" strict can't fix the space leak issues people run into when then often reach for writer
23:10:53 <glguy> No
23:11:07 <glguy> Not in the way most people expect
23:11:36 <kuribas> glguy: because people expect evaluation to normal form?
23:11:45 <kuribas> which many monoids don't give...
23:11:46 <glguy> Maybe you could narrow down the behavior you're interested in so we can make sure we're talking about the same thing?
23:12:37 <kuribas> glguy: I had a discussion with someone that WriterT always leaks space.
23:12:57 <kuribas> And is therefor not very usefull.
23:13:11 <glguy> It doesn't always leak space, only when used incorrectly
23:13:24 <glguy> So you have to pick a specific instantiation
23:14:29 <kuribas> glguy: a strict tuple would evaluate it to normal form right?
23:15:07 <glguy> Not early enough, no
23:15:27 <kuribas> When you are appending strings, I don't think lazyness would be problem.
23:15:55 <glguy> Space leaks aren't a problem for strings
23:16:25 <glguy> The problem there is that you might have a left-nested expression
23:17:04 <glguy> But that's because of the way your >>= might be associated
23:17:59 <kuribas> I'd use DList or Endo
23:19:32 <glguy> Lists aren't a spaceleak worry because ++ evaluating doesn't shrink the space needed
23:19:54 <kuribas> yes.  It's more like when using Sum
23:20:01 <glguy> WriterT works well with an underlying monad that has a lazy >>=
23:20:07 <glguy> it's not suitable for use with Sum
23:20:24 <glguy> at least not in the large
23:20:49 <glguy> because as you're aware this will lead to a space leak. It's better to evaluate the <> aggressively
23:20:54 <cocreature> the space leaks for Sum are somewhat comparable to sum = foldr (+) 0
23:20:59 <glguy> so in this case you'd want to accumulate with StateT instead
23:21:58 <glguy> The problem with the way that the mtl classes are structured, or at least how people use them is that they think that they should pick the class with the minimum set of methods they need instead of the behavior they need
23:22:23 <glguy> So even if you need "write only state" that doesn't mean pick MonadWriter and shoehorn Writer into your problem
23:23:23 <kuribas> there's a lot of criticism that this is hard to reason about.
23:23:48 <kuribas> though I am not sure it's harder than performance in any other language.
23:25:06 <kuribas> there is this: http://hackage.haskell.org/package/writer-cps-mtl-0.1.1.5/docs/Control-Monad-Writer-CPS.html
23:25:22 <cocreature> yeah that’s basically the strict state version of the writer API
23:26:22 <kuribas> I'll direct my friend to that :-)
23:26:55 <cocreature> (sidenote: Control.Monad.State.Strict isn’t strict in the state either)
23:27:14 <kuribas> I kinda agree that reasoning about performance is hard, but I think it is still a lot easier than reasoning about side-effects in imperative programs.
23:33:16 * hackage bytestring-short 0.1.0.1 - Backport copy of ShortByteString  http://hackage.haskell.org/package/bytestring-short-0.1.0.1 (KeiHibino)
23:37:17 <glguy> I agree that it's easier to reason about these things in a strict language, but that's because you just get to reason about fewer things
23:39:42 <cocreature> I think part of the blame is also on the way Haskell is taught. a lot of people (myself included) tend to dive into type theory and category theory after they’ve grasped the basics instead of understanding how Haskell evaluation works and how to reason about performance
23:41:18 * hackage shake-ext 3.1.0.0 - Helper functions for linting with shake  http://hackage.haskell.org/package/shake-ext-3.1.0.0 (vmchale)
23:43:46 * hackage aeson-generic-compat 0.0.1.3 - Compatible generic class names of Aeson  http://hackage.haskell.org/package/aeson-generic-compat-0.0.1.3 (KeiHibino)
23:51:31 <kuribas> cocreature: yeah.  It also persists the myth that haskell is nice and theoretic, but fails in the real world.
23:52:43 <kuribas> Sadly I've heared the claim that haskell is not practical for side-effectful code even by people who do functional programming in other languages.
23:54:08 <kuribas> I am convinced that writing large programs in haskell is easier than in other language, given the same amount of expertise.
