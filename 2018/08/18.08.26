00:43:20 <asheshambasta> a strange generic question: is Linux the preferred OS amongst the Haskell users or is it 1:1 between MacOS and Linux(es)? 
00:43:20 <maerwald> I don't think we have any data on that
00:44:08 <olligobber> let's find out! http://www.strawpoll.me/16338876/r
00:44:14 <olligobber> wrong link
00:44:26 <olligobber> this one: https://www.strawpoll.me/16338876
00:44:44 <asheshambasta> okay, I'm currently using a 6 year old MBP and was doing some research on which direction to take for my next computer -- if and when my MBP gives up on me. 
00:45:33 <cocreature> I’d say it’s about 1:1 but that’s just a guess from personal experience
00:45:33 <olligobber> there we go, it's 1:1
00:45:41 <asheshambasta> olligobber: voted! 
00:48:49 <asheshambasta> cocreature: my gut feeling is that in the Emacs/Haskell world there's a hint of an inclination towards Linux
00:48:55 <asheshambasta> but that might be completely wrong. 
00:52:15 <cocreature> dunno, in the end it doesn’t really matter whether it’s 50:50 or 60:40 or whatever
00:56:50 <asheshambasta> yeah, I was just trying to gauge what to do for my next setup. My faith in Apple hardware has waned. Anyway. :-) 
01:00:07 <cocreature> asheshambasta: my point is either are used sufficiently often for Haskell development that from a Haskell pov I don’t think it should influence your decision too heavily
01:05:59 <asheshambasta> okay, yeah
01:59:07 <Sap4> Hi! Can anyone give ma link to an open-source app that uses Haskell?
01:59:32 <Sap4> I don't know where to look for some real-world haskell examples
02:03:59 <cocreature> Sap4: depends on what exactly you’re looking for. glguy’s irc client might be a nice example https://github.com/glguy/irc-core
02:11:55 <raichoo> Sap4: We have deployed quite of lof of web applications in production they are not open source though. Otherwise you might want to take a look at pandoc, darcs, xmonad just to name a few.
02:15:08 <Sap4> raichoo: Thanks, I'll take a look into those
02:15:54 <Sap4> cocreature: didn't see the message, sorry. Thanks for the link
02:30:31 <thyr15t0r> hello evevrybody
02:34:41 <cocreature> hey thyr15t0r 
02:40:13 <thyr15t0r> <cocreature> I am a beginner
02:40:29 <thyr15t0r> How to make this code easier and more elegant? let fun3 a=[[x|x<-[(xs*3-2)..xs*3], x<=a]|xs<-[1..if a `mod` 3 > 0 then (a `div` 3)+1 else a `div` 3]]
02:41:46 * hackage sized-grid 0.1.1.1 - Multidimensional grids with sized specified at compile time  http://hackage.haskell.org/package/sized-grid-0.1.1.1 (edwardwas)
02:44:49 <cocreature> thyr15t0r: I would split this problem into several parts: first write a functions "chunksOf :: Int -> [a] -> [[a]]" that groups a list into chunks of the given size (the last chunk might be smaller). then you can implement fun3 as "chunksOf 3 [1..a]"
02:47:29 <thyr15t0r> thnx
02:49:24 <int-e> thyr15t0r: the whole if-then-else can be replaced by (a+2) `mod` 3
02:49:42 <int-e> (but I would indeed follow cocreature's suggested route)
02:51:41 <ph88> can somebody help me with this bug ?  https://github.com/snoyberg/packdeps/pull/45
02:51:46 <thyr15t0r> thnx again
02:52:52 <cocreature> ph88: looks like you want to map over the hashmap and apply "fst" to the values?
02:55:39 <asheshambasta> speaking of xmonad; thats a huge reason to switch to Linux for me :-) 
03:10:55 <epta> is there any stack flag to suppress the warning about the fact that package.yaml is ignored and cabal file is being used?
03:17:12 <dmwit> epta: delete the package.yaml ;-)
03:23:47 <epta> dmwit: it sounds reasonable to leave cabal file in the repo for those who don't want to mess up with hpack and/or stack
03:24:11 <epta> and it sounds reasonable to keep package.yaml as well for the rest
03:28:03 <inquisitiv3> What's the current recommended extensions for Haskell in VS Code? There seems to be as many recommendations as there's extensions.
03:29:34 <ggVGc> inquisitiv3: HIE is quite good imo
03:29:40 <ggVGc> e.g Haskell Ide Engine
03:29:48 <ggVGc> I use it from vim, but the primary frontend is vscode
03:31:00 <inquisitiv3> ggVGc: Is it an official Haskell project? https://github.com/haskell/haskell-ide-engine
03:31:34 <cocreature> depends on what you mean by “official”
03:32:04 <liste> inquisitiv3: I'm happy with Haskero
03:32:16 <inquisitiv3> Is a project under the Haskell org. @ Github.
03:32:22 <liste> inquisitiv3: it's not as advanced as HIE but I had fewer problems with it
03:32:49 <cocreature> that mostly means that someone with the right permissions has deemed it as important and/or useful.
03:34:18 <jose_zap> inquisitiv3 I'm also using HIE, it's quite nice
03:35:21 <ggVGc> inquisitiv3: what is an official haskell project?
03:35:54 <ph88> cocreature, in the template you mean ?
03:35:56 <inquisitiv3> ggVGc: I don't know, just guessed it because it was a repo under the Haskell org. on Github.
03:36:20 <inquisitiv3> Thanks for the tips everyone! I'll try to get HIE running on my machine.
03:37:01 <cocreature> ph88: the error appears to be in the handler so I would start there
03:44:27 --- mode: glguy set +v romanix
03:44:31 <romanix> I'm having trouble catching exceptions using multiple "catch" calls. Could somebody have a look at https://lpaste.net/3165334096209510400? For some reason the second catch never executes and the exception gets rethrown. I'm trying to handle all exceptions that are not my custom ExceptionInParentThread using the second "catch".
03:45:12 <ggVGc> man wish I could do some haskell toda
03:45:20 <ggVGc> instead I'm writing a karaoke app in javascript to run in iPads
03:45:22 <ggVGc> :(
03:46:39 <cocreature> romanix: you probably want to use "catches" instead of multiple "catch"
03:50:59 <romanix> cocreature, Thanks. I will give it a try. I thought I could use multiple "catch", even though it's not efficient as the docs say.
03:51:41 <dmwit> romanix: I suspect the second `catch` is attaching to the `putStrLn`.
03:52:03 <dmwit> err
03:52:19 <cocreature> romanix: the docs also point out a difference between catches and multiple catch statements
03:52:21 <dmwit> Hm, maybe that would be a type error.
03:52:51 <cocreature> although your description doesn’t sound like that’s the error you are running into
03:52:59 <cocreature> oh yeah adding some parenthesis might also be a good idea :)
03:53:07 <dmwit> No, yeah, I think I got it right.
03:53:25 <romanix> cocreature, yes. The difference is that the second handler will catch exceptions in the first (that's not happening)
03:53:26 <dmwit> The intermediate `do` does all kinds of fun stuff to parsing fixities.
03:54:10 <romanix> I will try "catches", should be easier to indent/parenthesise
03:54:55 <dmwit> Oh, it's not even the `do` that's to blame, it's the lambda.
03:55:07 <dmwit> The second `catch` is inside the lambda because lambdas extend as far as possible.
03:55:44 <dmwit> Make it ```(\(Exception thrId) -> putStrLn $ ...) `catch` ...``` and you should be good to go.
03:55:50 <dmwit> Or use `catches`, yeah.
04:04:41 <romanix> "catches" worked like a treat :) Thanks for the tips cocreature and dmwit!
04:09:58 <Ariakenom> Does anyone have nice examples of type inferences to show people who don't know Haskell?
04:13:31 <infinisil> > length [ Nothing | i <- [1..10], i `mod` 3 == 0 ]
04:13:34 <lambdabot>  3
04:24:50 <Ariakenom> infinisil: that's a lot of defaulting. Maybe that's ok
04:26:45 <infinisil> Ain't not defaulting happening!
04:27:10 <infinisil> :t [ Nothing | i <- [1..10], i `mod` 3 == 0 ]
04:27:11 <lambdabot> [Maybe a]
04:27:25 <infinisil> :t length
04:27:26 <lambdabot> Foldable t => t a -> Int
04:27:59 <infinisil> Ariakenom: All as expected :)
04:28:49 <epta> how to rewrite lens-aeson'ish 'a ^.. key "ks" . values :: Value -> [Value]' in pure aeson?
04:34:20 <jose_zap> epta something along these lines https://gist.github.com/lorenzo/6d0047dbd7eaeb59e7ceaacadd413326
04:43:06 <WhatisRT> n
04:47:07 <Ariakenom> infinisil: There was defaulting
04:47:20 <Ariakenom> it doesn't show up in :t
04:47:45 <infinisil> Huh what defaulted?
04:48:11 <infinisil> If :t doesn't show it then it's not happening
04:48:36 <Ariakenom> Maybe () and the numbers to Integer
04:50:12 <infinisil> :t is the type, if you eval in in ghci it may default to something so it can show it
04:50:13 <lambdabot> error: parse error on input ‘type’
04:51:30 <epta> jose_zap: that helped, thanks
04:52:03 <Ariakenom> > l> minBound
04:52:05 <lambdabot>  False
04:52:06 <Ariakenom> > minBound
04:52:08 <lambdabot>  ()
04:52:50 <liste> > l
04:52:53 <lambdabot>  l
04:52:56 <infinisil> That's a repl thing, not inherent to haskell
04:53:04 <liste> what's `l` ?
04:53:06 <Ariakenom> Didn't mean to write that first one
04:53:06 <liste> :t l
04:53:07 <lambdabot> Expr
04:53:23 <liste> > 1 > minBound
04:53:25 <lambdabot>  error:
04:53:25 <lambdabot>      • Ambiguous type variable ‘a0’ arising from the literal ‘1’
04:53:25 <lambdabot>        prevents the constraint ‘(Num a0)’ from being solved.
04:53:29 <Ariakenom> infinisil: and that repl thing is the reason your example didn't type error
04:53:49 <infinisil> Totally not, try it in a file
04:54:22 <Ariakenom> ghc defaults too
04:54:33 <Ariakenom> the "default () " declaration
04:54:44 <infinisil> Oh hmm
04:54:50 <infinisil> How do you know?
04:55:23 <infinisil> I just realized that i can't know that it doesn't default
04:58:42 <dmwit> Ariakenom: "In this talk I'll give a brief retrospective on the history of type systems and an introduction to the type system of the Haskell language, including a remarkable example where the Haskell type checker diagnoses an infinite loop bug at compile time." https://blog.plover.com/talk/atypical-typing.html
04:58:43 --- mode: glguy set +v Andras
04:59:01 <Ariakenom> dmwit: sounds promising
04:59:42 <Andras> Hey guys! Im thinking of an elegant solution how to get the count of "Falses" in a tuple (Bool,Bool,Bool) but i can only think about ugly stufff
05:00:00 <dmwit> Andras: I would either produce a list in the first place, or convert it to a list.
05:00:08 <cocreature> Andras: write a function (a,a,a) -> [a] and then use that
05:00:08 <dmwit> Andras: Then `length . filter not` should do the trick.
05:00:24 <Ariakenom> infinisil: just add "default ()" to the top of a file to turn of defaulting
05:00:31 <cocreature> if you’re a lens user it can do it for you, if not just write the function yourself
05:00:37 <Andras> hmmm
05:00:42 <Ariakenom> your example won't type check
05:00:55 * dmwit sticks his tongue in in his cheek and mutters `(3-) . sum . map fromEnum`
05:01:14 <Andras> the list solution should fine
05:01:31 <epta> is there any SQL DSL library that could generate an expression to String/Text? I'm looking for a safe way to generate SQL queries for a rest api wrapper 
05:01:51 <infinisil> Ariakenom: ah neat, didn't know, sorry i doubted you :)
05:02:04 <Andras> and how do i merge a list like [[a,b,c],[d,e,f]] -> [a,b,c,d,e,f]
05:02:12 <dmwit> :t concat
05:02:13 <lambdabot> Foldable t => t [a] -> [a]
05:02:15 <Andras> sorry for the basic questions
05:02:20 <Ariakenom> no worries
05:02:36 <dmwit> ?. hoogle type \[[a,b,c],[d,e,f]] -> [a,b,c,d,e,f]
05:02:38 <lambdabot> Data.List subsequences :: [a] -> [[a]]
05:02:38 <lambdabot> Data.List permutations :: [a] -> [[a]]
05:02:38 <lambdabot> Data.List inits :: [a] -> [[a]]
05:02:45 <dmwit> ick
05:02:58 <cocreature> that’s … bad
05:03:03 <dmwit> so bad
05:03:35 <Ariakenom> infinisil: Now you can use default (Rational) like a rational person :p
05:03:58 <infinisil> :O
05:04:43 <Andras> inits [[1,2,3],[4,5,6]]
05:05:00 <Andras> how do I make lambdabot execute my stuff like ghci?
05:05:20 <dmwit> Ariakenom: Maybe even simple stuff like `x = fromList [("hello", Just True), ("world", Nothing), ("weird choices", Just False)]`, shown with and without the type ascription, would be nice intros.
05:05:30 <Ariakenom> > inits [[1,2,3],[4,5,6]] -- Andras 
05:05:31 <cocreature> > inits [[1,2,3], [4,5,6]]
05:05:33 <lambdabot>  [[],[[1,2,3]],[[1,2,3],[4,5,6]]]
05:05:34 <lambdabot>  [[],[[1,2,3]],[[1,2,3],[4,5,6]]]
05:05:48 <dmwit> Ariakenom: e.g. Java folks are very familiar with having to first write `Map<String,Maybe<Bool>> x` before being *allowed* to write such an equation.
05:06:05 <dmwit> Andras: Start your message with "> ".
05:06:13 <Andras> ahh  ohanks
05:06:17 <Andras> thanks
05:07:08 --- mode: glguy set +v mariatsji
05:07:33 <Ariakenom> dmwit: I like it. Maybe use mapFromList to not imply it's polymorphic?
05:07:54 <mariatsji> Hi, anybody willing to have a look at my should-be-simple-parser-but-will-not-compile? https://pastebin.com/FibuZPBM
05:08:04 <dmwit> Ariakenom: sure
05:08:12 <dmwit> mariatsji: What's the error?
05:09:01 <mariatsji> Couldn't match type ‘TE.Text’ with ‘ByteString.Internal.ByteString’
05:09:01 <mariatsji> (..)
05:09:45 <dmwit> mariatsji: Oh, you probably want to import `Parser` and `parseOnly` from `Data.Attoparsec.Text` instead.
05:09:56 <dmwit> `Data.Attoparsec` just reexports `Data.Attoparsec.ByteString`.
05:10:26 <dmwit> (Or drop your first import entirely and write `AT.parseOnly` in your `FromHttpApiData` instance.)
05:10:48 <dmwit> (...and `AT.Parser` in your `pointParser` type signature.)
05:14:44 <dmwit> Sure, or first.
05:16:16 * hackage leancheck 0.7.3 - Enumerative property-based testing  http://hackage.haskell.org/package/leancheck-0.7.3 (rudymatela)
05:17:39 <dmwit> Ariakenom: Another thought comes to mind: there's a lovely thread about errors caught by the occurs check that might be good mining. The error messages from the type inference engine often point out how to fix your code, and you can show the inferred type for the fixed code. Let me see if I can dig it up.
05:18:17 * hackage time-locale-compat 0.1.1.5 - Compatibile module for time-format locale  http://hackage.haskell.org/package/time-locale-compat-0.1.1.5 (KeiHibino)
05:19:34 <dmwit> Ariakenom: http://article.gmane.org/gmane.comp.lang.haskell.cafe/17105
05:23:17 * hackage fitspec 0.4.7 - refining property sets for testing Haskell programs  http://hackage.haskell.org/package/fitspec-0.4.7 (rudymatela)
05:29:46 <tim_nixos> hello guys, quick question: I want multiple lines in my function definition to make it easier to read, how would I do that? this is what I am trying to get to work: https://pastebin.com/HhKZuF2f
05:30:20 <c_wraith> indent further.
05:30:36 <tim_nixos> how much? :D
05:30:43 <c_wraith> You've aligned with s, which means it thinks you want to start a new definition, not continue the previous
05:30:59 <Ariakenom> dmwit: that example with errors is nice
05:31:42 <jose_zap> tim_nixos try this https://pastebin.com/67mk9e93
05:32:24 <tim_nixos> jose_zap: perfect, thanks. this is what I was looking for
05:32:32 <jose_zap> cool!
05:34:16 <Ariakenom> dmwit: dominus' intro is great.
05:34:23 <Ariakenom> good link
05:34:35 <tim_nixos> is there a tool to have automatic style checks for haskell?
05:34:49 <Ariakenom> for the target audience
05:36:12 <liste> tim_nixos: what kind of style checks? https://hackage.haskell.org/package/hlint
05:36:16 <jose_zap> tim_nixos hindent and brittany
05:36:48 <jose_zap> oh, style cheks... sorry. I thought you meat automatic formatting
05:39:46 <tim_nixos> liste: yeah, something like that. I think there was something like a 'hard' or 'wall' flag for the compiler..
05:40:24 <liste> tim_nixos: there's -Wall, but hlint finds more possible issues
05:40:46 <tim_nixos> liste: alright, thanks!
05:40:48 <jose_zap> tim_nixos if you are using stack you can do stack build --pedantic
05:40:58 <liste> tim_nixos: best to combine both!
05:41:05 <jose_zap> which enables a bunch of compiler warnings
05:46:47 * hackage th-reify-compat 0.0.1.5 - Compatibility for the result type of TH reify  http://hackage.haskell.org/package/th-reify-compat-0.0.1.5 (KeiHibino)
05:49:22 <jose_zap> Andras if using the lens package is an option, there is a simple one-liner for that
05:51:24 <jose_zap> length $ (False,True,False) ^.. each . filtered not
05:52:47 <dmwit> Ariakenom: totally agree
05:53:47 * hackage weeder 1.0.8 - Detect dead code  http://hackage.haskell.org/package/weeder-1.0.8 (NeilMitchell)
05:56:05 <inquisitiv3_> I get an error message when I try to create a new project with stack. When I run `stack new src simple` I get the following output: https://pastebin.com/TxD24HkZ
05:56:42 <inquisitiv3_> I removed `~/.stack` before running the command. I've installed Stack globally on my system running NixOS 18.03.
05:57:18 <inquisitiv3_> I'm a total beginner regarding Haskell and the surrounding ecosystem, so don't asume that I know stuff.
05:59:47 * hackage product-isomorphic 0.0.3.3 - Weaken applicative functor on products  http://hackage.haskell.org/package/product-isomorphic-0.0.3.3 (KeiHibino)
06:06:26 <pavonia> inquisitiv3_: so have you tried what the output says?
06:09:47 <inquisitiv3_> pavonia: Yeah. I only get the error message "Directory /home/user/referenser/g/gpwh/src/ already exists. Aborting."
06:11:38 <pavonia> Is this the directory you want to create the new project in?
06:13:20 <cocreature> inquisitiv3_: stack new creates a new project, it doesn’t work for an existing directory
06:14:22 <inquisitiv3_> pavonia, cocreature: I'm in the directory there I want to create the `src` directory for the source code. The directory didn't exist before I ran the command.
06:18:43 <cocreature> inquisitiv3_: try deleting the src directory, remove ~/.stack (or at least ~/.stack/buildplan) and then run it again
06:32:13 <inquisitiv3_> cocreature: I removed the `src` and `~/stack/` dirs and reran the command. Got the following error message: https://pastebin.com/6dvxRkzc
06:36:20 <cocreature> inquisitiv3_: that looks like you might be using an older version of stack. which version are you using?
06:43:36 <inquisitiv3_> cocreature: Version 1.6.5 x86_64. Do you need the output from `stack --version`?
06:44:08 <cocreature> inquisitiv3_: no, that’s sufficient to know it’s outdated :) try "stack upgrade"
06:44:22 <inquisitiv3_> stack upgrade
06:44:28 <inquisitiv3_> Wrong window...
06:44:34 <infinisil> inquisitiv3_: you need to use nix to upgrade
06:45:56 <inquisitiv3_> infinisil: Aha. No idea how I should do that. Do you want to take it here or in #nixos?
06:46:34 <infinisil> I'll tell you in nixos
06:46:35 <inquisitiv3_> Because I've just some hours ago ran `nixos-generate-reuild switch --upgrade`
06:46:42 <inquisitiv3_> Thanks
06:48:47 * hackage biohazard 1.0.3 - bioinformatics support library  http://hackage.haskell.org/package/biohazard-1.0.3 (ustenzel)
06:53:28 <romanix> Hmm. Strange things are happening with my GHC. I started getting an "internal error: Unable to commit [number] bytes of memory" after upgrading to GHC 8.2.2. Has anyone encountered this? The issues on GHC Trac only mention cases in GHCi but I'm getting this when executing a binary.
06:54:44 --- mode: glguy set +v rke2
06:55:52 <dmwit> rke2: There's a section in the manual about that. ;-)
06:56:05 <dmwit> https://ghc.readthedocs.io/en/latest/sooner.html
06:56:30 --- mode: glguy set +v Andras
06:56:41 <Andras> > foldl (\(r curr) -> if curr==False then r+1) 0 [False,True,False]
06:56:42 <lambdabot>  <hint>:1:10: error: Parse error in pattern: r
06:56:57 <Andras> hey guys anyone has any idea why this is happening?
06:57:13 <Andras> trying to count faleses in an array
06:57:24 <Andras> falses*
06:57:35 <dmwit> fewer parens
06:57:39 <dmwit> \r curr -> ...
06:57:49 <dmwit> You also need an `else` in your `if`.
06:58:32 <Andras> > foldl (\r curr -> if curr==False then r+1 else r) 0 [False,True,False]
06:58:34 <lambdabot>  2
06:58:35 <Andras> thanks :)
06:58:38 <dmwit> Don't like my `length . filter not` suggestion, huh? =)
06:59:06 <Andras> well I dont know what does '.' does
06:59:13 <rke2> dmwit: any more hints? I can't find the section on that. I have some problems with GHC taking too much memory on some ultra-portable hardware. 
06:59:25 <dmwit> Some other comments: you should generally use foldl' over foldl, and `curr == False` can also  be written `not curr`.
06:59:35 <rke2> I know that disabling optimizations and everything else would help.
06:59:41 <dmwit> rke2: Oh, I misread the question entirely, sorry.
06:59:58 <dmwit> rke2: I linked you to the manual, but that's for reducing memory usage of the program produced by GHC, not GHC itself.
07:00:11 <dmwit> ?src (.)
07:00:11 <lambdabot> (f . g) x = f (g x)
07:00:12 <dmwit> Andras: ^
07:00:27 <Andras> > foldl (\r curr -> if not curr then r+1 else r) 0 [False,True,False]
07:00:30 <lambdabot>  2
07:00:56 <dmwit> Andras: ...and now `if not foo then bar else baz` can be `if foo then baz else bar`.
07:01:07 <dmwit> > foldl (\r curr -> if curr then r else r+1) 0 [False, True, False]
07:01:09 <lambdabot>  2
07:01:14 <Andras> yea lol
07:01:53 <dmwit> Andras: Okay, stick with me. I've got a garden path for us to walk down.
07:02:27 <dmwit> No, never mind. I don't like where the path leads, forget it. =P
07:02:33 <Andras> hahhahaha
07:04:05 <Andras> just for some context, Im implementing some basic tasks
07:04:06 <Andras> https://pastebin.com/jcgR73Z0
07:04:07 <dmwit> Andras: Anyway, it's easy enough to adapt my original suggestion to avoid `(.)`.
07:04:13 <dmwit> > length (filter not [False, True, False])
07:04:16 <lambdabot>  2
07:04:16 <Andras> this is the current one
07:04:43 <Andras> dmwit: trying to make it more optimal 
07:05:35 <dmwit> Oh, there's a lot I would do differently here.
07:05:50 <dmwit> Nice work on getting something that does what you want, though! That's always the first step.
07:06:00 <Andras> yea
07:06:08 <Andras> Im pretty starter with the language
07:06:13 <Andras> I only have like 10 hrs in it
07:06:39 <Andras> Im hoping if I learn to write some haskell Ill become more mature with the OOP stuff
07:07:01 <Andras> especially all the languages are pushing out functional features
07:07:11 <royal_screwup21> Andras: OOP and haskell in the same sentence...?
07:07:12 <Andras> now*
07:07:48 <Andras> hahhaha
07:07:59 <dmwit> ?let areElementsNextToEachAreInceasing xs = [cond | a:b:c:_ <- tails xs, cond <- [a<b, b<c, a<c]]
07:08:01 <lambdabot>  Defined.
07:08:15 <dmwit> > areElementsNextToEachAreInceasing [1,2,1,2]
07:08:17 <lambdabot>  [True,False,False,False,True,False]
07:09:16 <royal_screwup21> I'm trying to figure out how to use (.) - here's what I tried: https://thepasteb.in/p/lOhO8RMDZoOTB I've put the traceback below, would love a pointer in the right direction
07:09:53 <dmwit> ?let almostIncreasingSequence ns = length [() | a:b:c:_ <- tails xs, cond <- [a<b, b<c, a<c], cond] <= 3
07:09:54 <lambdabot>  .L.hs:182:40: error:
07:09:55 <lambdabot>      • Variable not in scope: xs :: [()]
07:09:55 <lambdabot>      • Perhaps you meant one of these:
07:10:08 <dmwit> ?let almostIncreasingSequence ns = length [() | a:b:c:_ <- tails ns, cond <- [a<b, b<c, a<c], cond] <= 3
07:10:10 <lambdabot>  Defined.
07:10:16 <dmwit> > almostIncreasingSequence [1,2,1,2]
07:10:18 <lambdabot>  True
07:10:26 <Andras> lemme tryy
07:10:28 <dmwit> Okay, I didn't get it right, I guess. =P
07:11:29 <Andras> :t tails
07:11:30 <lambdabot> [a] -> [[a]]
07:11:33 <Andras> :tail
07:11:34 <dmwit> Oh, should be `not cond`.
07:11:40 <Andras> :t tail
07:11:41 <lambdabot> [a] -> [a]
07:12:14 <Andras> ?let almostIncreasingSequence ns = length [() | a:b:c:_ <- tails ns, not cond <- [a<b, b<c, a<c], cond] <= 3
07:12:14 <lambdabot>  Parse failed: Parse error in pattern: not
07:12:24 <dmwit> ?undefine
07:12:24 <lambdabot> Undefined.
07:12:35 <dmwit> ?let almostIncreasingSequence ns = length [() | a:b:c:_ <- tails ns, cond <- [a<b, b<c, a<c], not cond] <= 3
07:12:36 <lambdabot>  Defined.
07:12:41 <Andras> ?let almostIncreasingSequence ns = length [() | a:b:c:_ <- tails ns, cond <- [a<b, b<c, a<c], not cond] <= 3
07:12:42 <lambdabot>  .L.hs:162:1: warning: [-Woverlapping-patterns]
07:12:42 <lambdabot>      Pattern match is redundant
07:12:42 <lambdabot>      In an equation for ‘almostIncreasingSequence’:
07:12:46 <Andras> ohh haha
07:13:49 <Andras> >[
07:13:49 <Andras>     ((almostIncreasingSequence [1,2,1,2]), False), 
07:13:49 <Andras>     ((almostIncreasingSequence [1, 2, 5, 5, 5]), False), 
07:13:51 <Andras>     ((almostIncreasingSequence [40, 50, 60, 10, 20, 30]), False),
07:13:53 <Andras> 	((almostIncreasingSequence [1, 3, 2]), True)
07:13:55 <Andras> ]
07:14:12 <coldpresent> what do you vim guys use to format your haskell files?
07:14:32 <dmwit> coldpresent: ai, pi, noet
07:14:54 <coldpresent> im guessing vim-polyglot isn't good?
07:15:14 <dmwit> ...and occasionally Tabular.
07:15:23 <coldpresent> oh darn you have to install the haskell extension for polyglot
07:15:34 <royal_screwup21> I'm trying to figure out how to use (.) - here's what I tried: https://thepasteb.in/p/lOhO8RMDZoOTB I've put the traceback below, would love a pointer in the right direction :_
07:16:04 <dmwit> royal_screwup21: You probably meant `f = a . b`.
07:16:18 <dmwit> royal_screwup21: Or `f x = (a . b) x`, perhaps, depending on your aesthetics.
07:16:31 <royal_screwup21> ah thanks!
07:16:31 <Andras> dmwit: why do I not have tails?
07:16:33 <Andras> Perhaps you meant ‘tail’ (imported from Prelude)
07:16:36 <dmwit> ?index tails
07:16:36 <lambdabot> GHC.OldList, Data.List, Data.ByteString.Lazy, Data.ByteString.Lazy.Char8, Data.ByteString, Data.ByteString.Char8, Data.Sequence
07:16:55 <dmwit> Data.List is the right one, in this case.
07:20:14 <Andras> dmwit: http://oi64.tinypic.com/i3vuo9.jpg
07:20:24 <Andras> we almost got it :-(
07:20:55 <dmwit> Does your old code pass the tests?
07:21:11 <Andras> Actually it says its too slow so it fails
07:21:16 <dmwit> I wasn't attempting to find any bugs in the original code, just show how I would write the same logic.
07:21:20 <Andras> Im in the way of making it faster
07:21:25 <Andras> yea
07:22:03 <dmwit> Oh, yeah, reading the problem description this is not the right logic at all.
07:22:50 <dmwit> I'm a bit surprised your original code was too slow.
07:23:08 <Andras> Well there are lots of arrays and maps copying them
07:23:24 <Andras> I bet it uses alot of memory and cpu cycles
07:23:29 <dmwit> Perhaps changing the `foldl (\x a -> x++a)` to `concat` would be the biggest win.
07:24:11 <dmwit> All the rest is just a little bit wasteful in many places but not asymptotically worse.
07:30:24 <Andras> replaced foldl with concat and its got faster
07:30:33 <Andras> I get to the same place as you
07:30:52 <Andras> Now Iv gotta find out the error in my thinking
07:38:12 <liste> never use foldl, always foldl'
07:38:20 <liste> @src foldl'
07:38:20 <lambdabot> foldl' f a []     = a
07:38:20 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:39:47 <Andras> is it more efficient?
07:39:53 <Andras> @src foldl
07:39:54 <lambdabot> foldl f z []     = z
07:39:54 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:39:58 <lkurusa>  it's strict
07:40:33 <liste> Andras: yes, it's strict, so there won't be a thunk buildup
07:43:13 <Andras> Im a supernoob I do not know about such things
07:43:47 <royal_screwup21> I'm getting a parse errror on this line: data Suit = Club | Diamond (deriving Show) What am I doing wrong?
07:44:01 <royal_screwup21> error: parse error on input ‘deriving’
07:44:04 <lkurusa> Andras: strict means it's not lazy, so it will aim to do the computation at sight, instead of when needed
07:44:17 * hackage th-data-compat 0.0.2.7 - Compatibility for data definition template of TH  http://hackage.haskell.org/package/th-data-compat-0.0.2.7 (KeiHibino)
07:44:45 <lkurusa> this means that thunks (computation that needs to be done later) will not build up, since the values are computed as soon as possible (instead of when needed)
07:44:51 <Andras> but in the end it uses the same amount of cpu cycles
07:45:00 <Andras> ?
07:45:14 <lkurusa> that depends
07:45:14 <dmwit> royal_screwup21: data Suit = Club | Diamond deriving (Show)
07:45:25 <royal_screwup21> whoops
07:45:34 <royal_screwup21> really need some sleep sigh
07:46:23 <lkurusa> Andras: you will probably use a lot less memory, which can benefit caches, etc, improving your latency
07:46:47 <dmwit> Andras: v. unlikely to use the same number of cycles
07:47:24 <Andras> =/- ~10% range?
07:47:33 <Andras> +/- ~10% range?
07:48:12 <dmwit> Getting strictness right can easily make a 2x difference in runtime.
07:48:38 <ski> royal_screwup21 : or just `... deriving Show' in your case, since you have only one class to derive there
07:52:47 * hackage bytestring-short 0.1.0.2 - Backport copy of ShortByteString  http://hackage.haskell.org/package/bytestring-short-0.1.0.2 (KeiHibino)
07:58:11 <ab9rf> or more, in some cases
08:01:23 <royal_screwup21> data Suit = Club | Diamond, what is the exact term for Card and Diamond - is it a data type?
08:01:40 <dmwit> They are data constructors.
08:01:48 <royal_screwup21> ah cool
08:01:57 <dmwit> And Suit is a type constructor.
08:06:12 --- mode: glguy set +v mizunno
08:06:29 <mizunno> Hello, I am trying to explain what is Stack or Cabal. How would you define them?
08:06:57 <sclv> they are software programs
08:07:02 <sclv> On the computer
08:07:29 <hpc> cabal controls package databases by installing packages and their dependencies and such
08:07:33 <hpc> either globally or per-user
08:08:00 <hpc> stack is a wrapper for cabal that creates a sandboxed environment and precisely reproduces it based on a config file
08:08:33 <hpc> cabal has its own sandboxing as well, which i haven't used in a while so i can't speak intelligently about it
08:09:14 <[exa]> (about cabal sandboxing: it just works (TM), except for not trying to be as reproducible as stack's sandboxes)
08:10:45 <sclv> more generally: they are tools for  building and developing haskell programs in conjunction with their associated dependencies
08:11:26 <dmwit> You know the configure; make; make install dance? You know how annoying it is to have configure tell you about one missing dependency, then have to try to configure that dependency for it to tell you about a missing dependency, work your way all the way down to some basic library nad back up only to have the top-level configure tell you about the next missing dependency?
08:11:33 <dmwit> Stack and cabal fix that problem for Haskell.
08:12:09 <maerwald> configure, make and make install are not about dependency resolution
08:12:10 <mizunno> Good points, thx!
08:12:17 <maerwald> don't blame them
08:13:45 <royal_screwup21> so I'm trying to implement a typeclass like so: https://thepasteb.in/p/Mjhx1BYoDE4HV I've put the traceback below, would really love a pointer in the right direction :)
08:15:16 <c_wraith> that's a compiler error, not a traceback :)
08:15:42 <c_wraith> so, the problem is that numeric literals are polymorphic
08:15:51 <ab9rf> try doing yesno (3::Int)
08:16:03 <c_wraith> It doesn't know which numeric type you mean, and it can't use defaulting because there's a class it doesn't know about involved
08:16:52 <ab9rf> numeric literals are polymorphic, and have a defaulting rule unique to themselves
08:17:26 <dmwit> Why doesn't extended defaulting kick in here?
08:17:35 <royal_screwup21> ahh I see
08:18:20 <royal_screwup21> so the compiler doesn't know if it's an Int32 or Int64 or the other Ints...
08:18:37 <c_wraith> Yep
08:19:19 <royal_screwup21> what is the exact term for when you use (Num a) => a -> a -- specically that Num part? I guess that could solve my problem too
08:19:26 <dmwit> Ah, extended defaulting does kick in, but it doesn't help, because Int isn't in the list of defaults.
08:19:32 <ab9rf> royal_screwup21: that's called a constraint
08:19:42 <inquisitiv3_> I'm creating an issue regarding the problem with stack from stable. Should I write in the issue that infinisil was able to reproduce the problem?
08:19:54 <royal_screwup21> alrighty
08:20:07 <ab9rf> if Yesno had an Integer instance, I suspect it would have defaulted
08:20:09 <dmwit> royal_screwup21: You could also add `default (Int,Rational)` to your file (or your ghci session). =P
08:20:18 <dmwit> ab9rf: correct
08:20:44 <dmwit> ab9rf: ...though in ghci only. GHC itself still wouldn't allow it because YesNo is not a "standard class".
08:21:28 --- mode: glguy set -v kryft
08:24:19 <inquisitiv3_> Whoops, wrong channel...
08:28:17 * hackage text-builder 0.5.4 - An efficient strict text builder  http://hackage.haskell.org/package/text-builder-0.5.4 (NikitaVolkov)
08:51:26 <dataN> is there a way to write types infix as in how functions can use `f` ?
08:52:29 <cocreature> yes, enable TypeOperators
08:53:08 <glguy> % :kind Int `Either` Bool
08:53:08 <yahb> glguy: Int `Either` Bool :: *
08:54:59 <dataN> is there a standard way to write 'class Has a b where has :: a -> b' ?
08:56:43 <dataN> it can be written 'class Exists a where exists :: a; type Has a b = Exists (a -> b)'
08:56:51 <cocreature> you sure are persistent when it comes to using typeclasses for everything :)
08:57:20 <dataN> there is no other way to pattern match over them
08:59:14 <c_wraith> Why do you want to?  type-based behavior makes code hard to reason about.
08:59:24 <dataN> type families essentially give the sought after "type level lambda" but using them in practice requires synonyms akin to datatypes at type level, and thats what these tuples achieve. then type level functions can be written to convert between types programatically 
08:59:50 <glguy> And is something to be used sparingly
09:00:15 <dataN> all classes can be written this way
09:00:59 <dataN> and then pattern matched on, being identified by their name and the types of the functions they consist of
09:01:49 <c_wraith> but what do you gain?
09:02:01 <c_wraith> You lose a lot in terms of reasoning 
09:02:12 <c_wraith> What could you possibly gain to make it worthwhile?
09:03:30 <dataN> the ability to write functions between constraints 
09:03:46 <c_wraith> Do you need that?
09:04:36 <dataN> yes, for instance, lenses are good example of classes that can be "extended" by giving them an extra parameter.
09:04:45 <c_wraith> lenses aren't classes
09:06:12 <dataN> type Lens f = (Exists (Get_T f),Exists (Set_T f)); Get_T f = f a -> (a,f a);Set_T f = (a,f a) -> f a
09:06:32 <cocreature> you seem to insist to turn things that aren’t typeclasses (for good reasons) into typeclasses and then spend a lot of effort into working around the problems caused by that and I still have no idea what you hope to gain from that
09:06:50 <dataN> the one parameter extension 
09:06:59 <dataN> its available to all classes.
09:07:34 <dmwit> That's not even a good analog to lenses.
09:07:34 <dataN> unfortunately for lenses, being a pair of inverses, the parameter ends up on the wrong side...
09:07:45 <glguy> Maybe try writing some programs not about classes first to get a better sense of where you actually need them
09:08:13 <dataN> dmwit: it follows from bidirectional putback stype lenses, wait ill fetch the paper
09:08:28 <dmwit> I'm pretty familiar with the literature on lenses.
09:08:50 <dataN> http://research.nii.ac.jp/~hu/pub/pepm14.pdf
09:09:21 <dmwit> Your type doesn't capture e.g. getting a Word8 (or Maybe Word8 if you want to be pedantic) out of a ByteString.
09:09:24 <dmwit> Because the kinds don't match.
09:09:53 <dataN> anyway, pairs of inverses could be a good example of an abstraction where a mechanism over types can be generally applied
09:09:57 <dmwit> And your get type returns a spurious f a.
09:10:53 <dataN> dmwit: right, there are several variations depending on if its a stack or not
09:11:09 <dataN> or if its a stream, or nonempty
09:11:24 <ab9rf> that sounds not very general
09:11:25 <dataN> thats the version for stream
09:11:56 <ab9rf> it does not seem that you are gaining anything with all this scaffolding
09:11:58 <dmwit> Like I said: not a good analog to lenses.
09:12:16 <dataN> ab9rf: its less general than the most general case. but thats the next most important level to consider after the most general case has been exhaustively described.
09:12:57 <ab9rf> well, i suppose there is sometimes merit in exploring the road not traveled
09:13:02 <dmwit> Anyway even if you cared about the thing that was analogous to, I don't see why you want a typeclass.
09:13:19 <ab9rf> but sometimes the reason the road not traveled is not traveled is because it ends in a blank wall, a pit, or a den of bears
09:13:23 <dataN> there is a combinatoric exponential increase in terms which makes such considerations limited to a few parameters, but the majority of the factorisation of larger programs can be usefully described within these expansions.
09:14:05 <dataN> an9rf: certainly, for example, not much can be said about the most general polymorphic type. 
09:14:08 <royal_screwup21> is (3::Int) an example of type annotation?
09:14:13 <ab9rf> royal_screwup21: yes
09:14:21 <ab9rf> the :: Int is a type annotation
09:14:24 <royal_screwup21> ah cool
09:14:32 <ab9rf> the parentheses are required to constrain the scope of the annotation
09:14:37 <dataN> dmwit: what do you mean?
09:15:01 <royal_screwup21> curious, kind of work do y'all generally do? Not seen much demand of haskell in the market
09:15:13 <ab9rf> royal_screwup21: i'm a housewife :)
09:15:33 <ab9rf> i got laid off in 2008 and haven't had regular work since
09:15:46 <dmwit> ouch
09:15:57 <ab9rf> my wife makes enough for both of us
09:16:10 <dataN> type Lensi i f = (Exists (Geti_T i f),Exists (Seti_T i f)); Geti_T i f = f a -> (a,i,f a);Seti_T f = i -> ((a,f a) -> f a)
09:16:44 <dataN> that was the original motivation for this use of Exist...
09:17:20 <cocreature> royal_screwup21: I’m a student hoping to find a job soon :)
09:17:38 <ab9rf> there is always the chance that i'll do something that gets me income someday
09:17:45 <ab9rf> but i'm increasingly doubtful of that
09:17:53 <dmwit> ab9rf: I'm glad to hear that, though I can still understand how it could be frustrating anyway if that's not what you wanted. Financial considerations are just one reason to have a job, I think.
09:17:55 <dataN> essentially, any class of one defining function can be written using Exist, pattern matched on and a new class returned that is a one parameter extension, that is, returning the class defining function. 
09:18:41 <ab9rf> dmwit: my son's health has been a factor as well
09:19:00 <dmwit> ab9rf: Sure, I can believe that.
09:19:25 <dmwit> royal_screwup21: I hack on Haskell full-time for Galois, an R&D shop that focuses on high-assurance software.
09:19:27 <ab9rf> he has major surgery coming up in only a couple of weeks
09:19:46 <ab9rf> and so my life will be upside down for the next month or so
09:20:04 <glguy> Galois+1
09:20:12 <kryft> ab9rf: Sorry to hear that :/
09:20:44 <ab9rf> i was a software developer back in the late 90s and early 00s
09:21:12 <ab9rf> so i try to keep myself from going completely stale
09:22:39 <royal_screwup21> that sucks :( sorry about that
09:23:13 <ab9rf> i do not understand a lot of the new build stuff
09:23:20 <ab9rf> which is simply because i've never used it
09:23:33 <dataN> royal_screwup21: this is not a reasonable sentiment, haskell is a very good tool for programming with in any particular specialisation. e.g. if you are a full stack developer using haskell, then getting a job doing that will not be hindered because you use haskell. same for big data stuff as all the main libraries are ported, and employers can easily be convinced of the long term benefits of haskell for typesafe legible code
09:24:49 <ab9rf> the problem with doing a project in haskell is in finding enough competent haskell programmers to employ
09:24:56 <royal_screwup21> oh right, that might true, I was just putting forward an observation that the language in not all that in demand :)
09:25:13 <ab9rf> it's easy to find apparently competent javascript programmers. the problem is that 90% of them will actually not be competent.
09:25:29 <ab9rf> but it's difficult to even _recruit_ haskell developers
09:26:08 <ab9rf> HR people are made unhappy when they post a job and only get three responses 
09:26:13 <ab9rf> for three positions
09:26:14 <cocreature> ab9rf: is that really true? people keep claiming that but then a lot of people also seem to have trouble finding Haskell jobs
09:26:16 <ab9rf> and have to hire everytone
09:27:18 <dataN> ab9rf: again, this is missing the point. a higher level language is capable of doing everything easily. there is no need to employ swarms of haskell programmers, because an individual can wield the libraries crafted by generations of highly skilled and even ex-proprietary commercial code.  
09:27:35 <ab9rf> cocreature: that's ebcause it's hard to convince senior management to do a projet in haskell
09:27:45 <dataN> no it isnt 
09:28:04 <ab9rf> cocreature: it's too far from the beaten path. HR will go "we won't be able to staff that" and you'll get shut down by a VP
09:28:30 <ab9rf> youc an only do it if you have C*Os who ar ewilling to give you freedom
09:28:54 <ab9rf> and such organizations tend to be smaller, thus recruit less broadly and less visibly
09:29:06 <dataN> if any engineering department is unable to understand the clear and numerous very pronounced benefits, then they must not be engineers at all! 
09:29:08 <cocreature> I feel like the problem is more managers that stick to what they know than HR being worried that they won’t be able to hire for it
09:29:10 <ab9rf> which makes matching candidates with opportunities difficult
09:29:15 <ab9rf> cocreature: it's both
09:29:35 <Gurkenglas> ab9rf, if it's hard to convince management to provide Haskell jobs, that doesn't explain why there's both too few jobs and too few applicants per job
09:29:40 <ab9rf> cocreature: managers sticking to what they know is, in part, bcause they've been burned before by HR
09:30:40 <ab9rf> or simply by having a project fail because of recruitment issues
09:30:59 <Gurkenglas> One of the two must be wrong, right? Or is it just that everyone who seeks a Haskell job only ever sends on application?
09:31:04 <Gurkenglas> *one
09:31:05 <ab9rf> the "not enough jobs and not enough candidates simultaneously" isn't specific to haskell
09:31:09 <ab9rf> it's industry-wide
09:31:23 <glguy> Have you guys been doing a lot of hiring of Haskell people to get this data?
09:31:36 <ab9rf> i don't have a job
09:31:39 <ab9rf> despite being qualified
09:31:46 <dmwit> glguy: too subtle
09:32:03 <ab9rf> largely because i'm 49 and female
09:32:05 <Gurkenglas> I have no data, I'm only claiming the knowledge isn't valid
09:32:17 <Gurkenglas> -knowledge+logic o.o
09:32:27 <ab9rf> and because i have a gap in employment
09:32:33 <ab9rf> therefore, i'm "too much of a risk"
09:32:35 <dataN> oh, fearing the haskell developer will charge exorbitant fees as a consultant to maintain the code after retiring from the project?
09:32:50 <ab9rf> they'd rather hire a 21-year-old cute white guy with no track record 
09:33:02 <ab9rf> because he's less likely to quit to go have children 
09:33:08 <ab9rf> or whatever
09:33:23 <ab9rf> or because at 49 i expect ot be paid more than $45k a year
09:33:33 <dataN> right, so they just use open source code
09:33:45 <dataN> so we develop open source code
09:33:46 <Gurkenglas> ab9rf, that sounds to my naive ears like you could trade off your pay expectations for ability to find a job
09:33:47 * hackage creatur 5.9.25 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.9.25 (AmyDeBuitleir)
09:34:03 <Gurkenglas> ...which I thought of before you mentioned your pay expectations :D
09:34:36 <Gurkenglas> I mean if you expect more money than the other applicant, why do you think gender or age has anything to do with it?
09:35:22 <dataN> if it means that everyone has access to very efficient and general data access patterns produced through systematic and thorough efforts, then it of benefit to everyone, so normally would fall under the remit of academic sponsorship or a research grant 
09:35:29 <ab9rf> Gurkenglas: nope. if you do that, they tag you as "likely to bolt for higher pay elsewhere" and pass on you
09:36:08 <Gurkenglas> ab9rf, they should know as well as you do your chances of getting higher pay elsewhere
09:36:55 <ab9rf> Gurkenglas: the reality is that businesses do not want to hire older workers because they cost more to insure medically
09:37:12 <Gurkenglas> ab9rf, sounds like it can be offset by even more lowering of pay expectations
09:37:13 <ab9rf> if you hire me, i'm going to pull your group insurance rates up
09:37:21 <ab9rf> that's a fact
09:37:21 <dataN> another advantage of using open source code
09:37:34 <Gurkenglas> If they have to pay you less in accordance with your medical bills, that reasons puffs in a cloud of logic
09:37:57 <ab9rf> Gurkenglas: you're asusming that tehse decisions are made logically
09:38:03 <glguy> The person hiring you for their projects probably isn't taking your medical expenses into account
09:38:37 <Gurkenglas> If they are taking them into account, they should be convinced by money. If they don't, you have nothing to fear.
09:38:39 <ab9rf> i've simply accepted that i'm not going to get hired
09:38:44 <dataN> the real question is why no companies are taking these less accessible, more expertly developed projects and commercialising them
09:38:52 <Gurkenglas> I think firms that are controlled by shareholders can be influenced by money.
09:40:02 <dataN> lowering the barrier to widespread adoption by providing the pitch and deployment
09:40:13 <Gurkenglas> If you would rather have free time than being paid as little as they would be willing to pay you, that is a fine choice to make, but you should be aware of it
09:43:36 <dataN> but then it gets back to the point where all of the porting has already been done and is open source! so then thats where we stand, with access to and ability to use very powerful libraries. so what if a bank insists on using something outdated? they can afford to waste money
09:44:26 <Gurkenglas> dataN, sounds like it's about fearing black swans. If there's the first to move to available OS solutions and it backfires that's their head off
09:44:49 <Gurkenglas> Do startups avoid this?
09:45:30 <dataN> sure, they can use tensorflow or whatever they like in whatever language they like, so long as they have a good application
09:46:40 <dataN> the choice of language is totally immaterial, if there was a problem, which is doubtful, it would be to do with superstitious recruiters not being informed
09:48:13 <dataN> maybe the startups never get off the ground because they are plagued with runtime errors...
09:50:11 <dataN> tensorflow is a pretty impressive example of something that can be done better in matlab using good linear algebra, but that would never be able to compete with the name that google gives it
09:50:24 <dataN> and thats actually really sad
09:51:44 <dataN> so yeah, haskell linear algebra using lens is something that could be really really interesting 
09:52:00 <Gurkenglas> OS causes runtime errors? That sounds like a reason not to use it.
09:52:21 <dataN> lol, no I meant because they use python!
09:53:00 <dataN> anyway, its only the bindings that are OS, google writes the library
09:53:35 <glguy> Well probably time to get back on topic
09:53:40 <ab9rf> heh
09:54:31 <dataN> its unlikely to be broken. also, a haskell version could achieve similar guaranties that only the worlds larges company can do with good faith or perceived trust, and it can be done in such a way as to be *really* trustworthy, i.e. typechecking!    
09:55:47 <dataN> i cant imagine a world where these kind of transparent trust mechanisms dont lead to market dominance. 
09:56:58 <ab9rf> i've generally assumed that the reason haskell isn't as widely adopted as it might be is because it hasn't been widely adopted in the past :)
09:57:30 <ab9rf> it's well-established that a language being good has very little to do with how broadly it gets adopted
09:58:11 <ab9rf> the fact that haskell is paradigmatically very different than how most people learn to program likely also inhibits people
09:58:20 <dataN> but i dont want to give the impression that there is any reason for a company to fear that their envisaged product might already have existed for several years and having been delivered freely... 
09:59:25 <ab9rf> there's a huge network effect in adoption: the more people use a thing, the more people will use it
10:00:58 <warbo> hello, can someone help me figure out why my QuickCheck test is hanging (0% CPU, just sitting there) https://lpaste.net/7204064412129296384
10:01:17 <dataN> this idea that it isnt widely used is wrong. its not the mainstay of too big to fail financial institutes sure, but their legacy code is an issue unto itself. it simply shifts the focus away from struggling to write code that already exists, and from having difficulty finding capable developers to having it work out the box 
10:01:25 <glguy> warbo: Does your test doing blocking IO?
10:01:34 <warbo> nope, it's pure
10:01:45 --- mode: glguy set +v _sras_
10:01:48 <ab9rf> warbo: i don't see any tests in that paste
10:01:55 <_sras_> Can someone take a look at something I made over the past week, and tell me if you think it is worth building upon. It is something like the Servant framework.  https://bitbucket.org/sras/yaar
10:02:00 <warbo> prop_stringOfCorrectLength is the test
10:02:23 <warbo> stringLength' is the function being tested (counts chars in a 'State String' until hitting a '"')
10:02:35 <warbo> genString generates a quoted string of a given length
10:03:03 <dataN> ab9rf: how can that be the case when all the code already exists? isnt that a side effect of having to use teams for something?
10:03:14 <ab9rf> i don't undertand why it would hang without using either CPU or memory 
10:04:05 <warbo> yeah, I'm thinking maybe I've misused 'State' in a circular way or something? but I can't spot it
10:04:16 <ab9rf> warbo: even if you had it would still spin and use CPU
10:04:53 <ab9rf> to get a nonspin hang would require blocking IO or concurrency operations
10:05:00 <cocreature> for me it just dies with <<loop>>
10:05:01 <warbo> I'm using tasty-discover, and cabal new-test says "Running 1 test suites...; Test suite test: RUNNING..." so it's found it
10:05:01 <ab9rf> and i don't see anytyhing here that delves into either of those
10:05:29 <warbo> I also have another test in the same file, which worked fine (I removed from the paste to simplify)
10:09:08 <cocreature> warbo: "n = abs n `mod` 1000" that’s an infinite loop
10:09:22 <cocreature> you probably want "n = abs n' `mod` 1000"
10:09:50 <cocreature> if you compile with -Wall you get a warning about an unused variable here which would probably have pointed you to the bug
10:10:07 <warbo> cocreature: ah, nice spot
10:10:07 <glguy> _sras_: If you register with NickServ you won't have to keep getting voiced or be subject to the spam heuristic
10:10:53 <warbo> cocreature: yep, that fixed it
10:11:24 <warbo> Haskell's laziness is impressive
10:11:39 <warbo> it didn't bother calculating an infinite loop :P
10:12:03 <cocreature> it should have thrown an exception
10:12:11 <cocreature> and it does for me (although I only tested in ghci)
10:12:23 <ab9rf> cocreature: i'm wondering if quickcheck ate the exception
10:12:42 <warbo> yeah, quickcheck would certainly catch it
10:13:14 <warbo> although it would usually treat it as a failure
10:13:22 <ab9rf> that's what i would expect
10:13:25 <warbo> maybe it has an incomplete whitelist or something
10:13:28 <ab9rf> it certainly has in my experience
10:13:45 <ab9rf> having had many exceptions caught by quickcheck :)
10:15:04 <warbo> can I give an option like '-Wall' via 'cabal new-test'?
10:17:41 <dmwit> warbo: `cabal new-test --ghc-options=-Wall` maybe
10:18:23 <warbo> ah yeah "cabal new-test --ghc-option=-Wall" seems to work, thanks
10:18:32 * warbo wades through the warnings...
10:18:42 --- mode: glguy set -v _sras_
10:19:53 <warbo> thanks all
10:22:17 <cocreature> you can also add it to the ghc-options section for the test suite in your cabal file
10:22:35 <olle> test
10:22:54 <olle> can the IO monad be subclassed into finer classes, like DB for database access?
10:23:27 <warbo> olle: in principle, yes
10:23:38 <olle> warbo: but...?
10:23:40 <warbo> but it becomes tedious to combine different monads
10:23:58 <warbo> see "monad transformers" for example
10:24:06 <olle> ok
10:24:10 <warbo> an alternative is "algebraic effect systems", which are nicer to combine
10:24:26 <olle> warbo: I prefer row-polymorphism like in Koka.
10:24:57 <warbo> row polymorphism could be used to implement an algebraic effect system
10:25:03 <olle> but if it's not idiomatic in the lanuage, it's pretty meaningsless to do something "cool" and exotic.
10:25:04 <warbo> but Haskell doesn't have it
10:25:09 <warbo> yeah
10:25:26 <warbo> some implementations I've seen build up a type-level list of effects
10:25:36 <olle> ok
10:25:50 <warbo> and sometimes they need to be re-ordered
10:26:05 <warbo> e.g. "you claimed this used [DB, StdIO] but it's type is [StdIO, DB]"
10:26:13 <dolio> Haskell already has something that doesn't have that defect.
10:26:15 <warbo> that's where row polymorphism, etc. would help
10:26:16 <dolio> Called type classes.
10:26:25 <olle> warbo: yeah
10:26:43 <warbo> dolio: true
10:26:47 * hackage http-io-streams 0.1.0.0 - HTTP client based on io-streams  http://hackage.haskell.org/package/http-io-streams-0.1.0.0 (HerbertValerioRiedel)
10:27:10 <dolio> People have used them to create algebraic effect systems, too.
10:27:10 <warbo> Ive not played with them enough to say much though
10:27:12 <dolio> Called the mtl.
10:27:15 <warbo> heh
10:28:46 <warbo> olle: as you might tell, monad transformers vs algebraic effects is currently a disputed topic in Haskell
10:28:55 <olle> ok
10:28:58 <warbo> mtl is the "standard" approach
10:29:06 <olle> warbo: I thought linear types where the top topic?
10:29:09 <olle> were*
10:29:38 <warbo> yeah, but they're largely orthogonal
10:29:52 <olle> I guess. Except for exceptions.
10:30:03 <warbo> linear types can replace some effectful code (e.g. State and ST), but not all
10:30:23 <olle> warbo: what's the difference between State and ST?
10:30:44 <ski> `State s' carries a single piece of state, of type `s'
10:31:14 <warbo> State passes an extra value into and out of functions (using a tuple/pair)
10:31:17 <ski> `ST s' allows you to dynamically allocate new pieces of state of any type, all conceptually bundled inside the (abstract) state type `s'
10:31:24 <dolio> I don't think I'm 'disputing' anything but the idea that you should think of "algebraic effects" and "monads/mtl" as completely different and unrelated things.
10:31:31 <warbo> ST lets us make "memory cells" to read/write from
10:31:36 <dolio> Because they're actually almost the same thing.
10:32:07 <ski> `ST' is implemented in terms of update-in-place. `State' is not (it's just passing versions of the state as input to and output from function calls, threading the state)
10:32:18 <warbo> dolio: oh of course; AFAIK it's a question of where the plumbing is defined and evaluated
10:32:42 <olle> ski: ok, sounds pretty abstract.
10:33:04 <olle> wait.
10:33:06 <olle> OK, I got it.
10:33:36 <olle> F* uses ST, I think. "Dijkstra monads for free" is the paper called.
10:33:53 <ski> you can think of an `STRef s a' as akin to a list/map index/key, used to access (and replace) the value contained in the corresponding cell, which is kept separately (conceptually passed/threaded under the covers, as with `State')
10:34:34 <ski> of course, in the implementation, an `STRef s a' is just a memory address (an index into the heap array, if you will), and accessing is dereferencing
10:35:02 <olle> ok
10:35:26 <ski> anyway, conceptually, a value of type `STRef s a' doesn't contain a value of `a', it only referennces it. this explains why you can compare `STRef s a's for equality, without having equality on `a'
10:35:46 <ski> it's essenmtially just an index comparision, not touching any values of type `a'
10:35:55 <ski> (and ditto holds for `IORef', of course)
10:36:05 <olle> ski: pointer equality?
10:36:13 * ski nods
10:36:16 <olle> ok
10:36:36 <ski> (you don't get `Ord', because a compacting GC may move the reference cells out of order)
10:36:44 <olle> to return to linear types, is it clear yet if it will be merged?
10:36:58 <olle> ski: sure
10:37:07 <cocreature> the proposal has not been accepted so far
10:37:12 <cocreature> so I’d say no it’s not clear
10:37:19 <olle> ok
10:37:57 <Ariakenom> olle: ST was actually introduced in the original monad paper (within CS) "Imperative functional programming" https://www.microsoft.com/en-us/research/wp-content/uploads/1993/01/imperative.pdf
10:38:43 <olle> Ariakenom: Yeah?
10:39:01 <dolio> I think Moggi has that beat.
10:39:04 <dolio> 1991.
10:39:19 <dolio> Unless you don't count that for some reason.
10:39:28 <olle> What's Moggi?
10:39:35 <ski> Eugenio Moggi
10:40:10 <Ariakenom> dolio: Nice! I didn't know. 
10:40:49 <dolio> Moggi was talking about PL semantics, though. Not embedded languages.
10:40:50 <ski> he realized monads were useful in describing the semantics of (specifically effects in imperative) programming languages
10:41:20 <dolio> Although, those aren't exactly different things when you get down to it.
10:41:39 <ski> i think Wadler(?) was first to turn this around to actually use monads as a programming idiom, rather than as a tool to *describe* programming languages
10:42:17 <ski> (sometimes, description can serve as implementation)
10:51:20 <royal_screwup21> I'm trying to import filter from Preslude like so: import Prelude.filter as filter. getting an error: <interactive>:6:8: error: parse error on input ‘Prelude.filter’
10:51:37 <glguy> import Prelude (filter)
10:52:08 <royal_screwup21> ah thanks
10:54:58 <hpc> royal_screwup21: the syntax you were using is import <module> as <new module name>
10:55:21 <hpc> import Prelude as ThisIsStillPrelude
10:55:37 <hpc> would have given you ThisIsStillPrelude.filter
10:56:42 <glguy> and: import qualified Prelude as ThisIsStillPrelude
10:56:51 <glguy> would avoid importing everything unqualified, too
10:57:16 <Hafydd> import qualified Data.List as ThisIsNotPrelude
10:57:42 <monochrom> Time to let the kid read books and docs on their own.
10:57:47 <hpc> heh
10:59:06 <monochrom> Some people really think that they can learn something by getting all of you to be their private tutors and interactive textbooks. For free. You need to discourage that kind of behaviour. At least the exploitative "for free" part.
10:59:44 <hpc> #haskell needs a $0.99 hat store
11:04:20 <ab9rf> monochrom: i might as well do it for free, it's not like anyone is willing to pay me to do it
11:05:28 <ab9rf> monochrom: however, i can promise to endeavour to be as mediocre at it as possible so as not to meaningfully compete with people who think they can be paid to do that
11:05:57 <glguy> I had a non-Haskeller friend send me this today https://pbs.twimg.com/media/DlV96LRVAAErNVl.jpg:large
11:06:14 <monochrom> haha
11:06:42 <ab9rf> glguy: my wife's name is lee, which is what you get when you remove the monad from lemonade
11:07:02 <ab9rf> glguy: so this is oddly appealing to me
11:08:36 <warbo> certainly shows how meaningless phrases like "you can't spell FOO without BAR" are
11:09:18 <MarcelineVQ> you can't spell mediocre without okra
11:09:21 <glguy> warbo: there no I in TEAM
11:09:49 <monochrom> But there is E, meaning ego, in TEAM.
11:09:51 <glguy> I've got a picture at my desk that finds the I there, however
11:10:06 <monochrom> Oh w00t that's new
11:10:21 <warbo> I'm sure Hackage will eventually get a "lemonade" package
11:10:36 <warbo> probably "Left Extension Monad Endomorphism" or something
11:10:52 <hpc> you can't spell lisp without "defun"
11:10:54 <hpc> :D
11:12:13 <cocreature> now I’m slightly disappointed that there is not already a lemonade package
11:12:45 * warbo checked before writing that :P
11:20:47 * hackage servant-ruby 0.8.0.2 - Generate a Ruby client from a Servant API with Net::HTTP.  http://hackage.haskell.org/package/servant-ruby-0.8.0.2 (joneshf)
11:22:52 <dsal> I'm using attoparsec and want something a bit richer.  Is megaparsec still the thing?
11:23:58 <hpc> trifecta maybe?
11:24:00 <glguy> Richer probably isn't specific enough, what do you need that attoparsec doesn't do?
11:25:01 <nshepperd> attoparsec, but with chocolate ganache
11:25:23 <dsal> I used megaparsec a while back and it had some way of expression recursion.
11:25:39 <ab9rf> mmm, ganache
11:25:46 <dsal> I just want to parse simple expressions.   1+(2*3*4)  etc...
11:26:03 <ab9rf> there are no simple expressions
11:26:06 <ab9rf> there are only expressions
11:26:16 <glguy> Attoparsec and megaparsec can parse the same things. There's differences in their backtracking behavior and error messages
11:26:37 <dsal> Oh.  Then I'll just stick with attoparsec.  I thought megaparsec had a bit more magic.  It looks like it's just... more work.
11:26:50 <ab9rf> attoparsec is differently optimized
11:27:06 <cocreature> dsal: you’re probably thinking of https://hackage.haskell.org/package/megaparsec-6.5.0/docs/Text-Megaparsec-Expr.html
11:27:17 <dsal> Oh yes, I remember this.
11:28:03 <cocreature> attoparsec and megaparsec might be able to provide the same things but that doesn’t mean they make it equally easy, have error messages of equivalent quality, …
11:28:35 <dsal> Yeah, attoparsec is pretty easy at most things I've cared to do.
11:28:36 <nshepperd> 'expressions' sounds like you want operator-precedence parsing. is that the problem?
11:28:46 <dsal> I don't want operator precedence.
11:29:06 <dsal> I've not really started on this parser yet.  Trying to decide whether to switch parsers first.
11:29:15 <cocreature> you don’t want 1 + 2 * 3 to be parsed as 1 + (2 * 3)?
11:29:52 <dsal> (Fun +) [Val 1, (Fun *) [Val 2, Val 3]]
11:30:32 <cocreature> so you do want operator precedences?
11:30:42 <cocreature> otherwise this could also be parsed as (1 + 2) * 3
11:30:56 <dsal> It's just left to right, really.
11:31:36 <dsal> This is kind of upside down -- I've got a thing that generates (and can stringify) expressions.  I'm wanting to make a parser just to make it a little easier to write tests.
11:31:38 <cocreature> no it’s not? if * has higher precedence than + then it’s not necessarily left to right
11:32:21 <cocreature> anyway, I would generally go with megaparsec even if it’s just for the better error messages
11:32:22 <dsal> I don't care about precedence.  I just want     digit <|>   digit operator digit
11:32:34 <dsal> But I do have parens.
11:33:25 <dsal> Relearning megaparsec is probably not terrible.  This example code should bootstrap me.
11:33:42 <dsal> So far, I've only parsed RPN expressions, which was super easy.  :)
11:34:22 <cocreature> there is not that much to relearn if you’re familiar with attoparsec
11:34:46 <dsal> I did all of APRS in attoparsec.  It's just a bit of different types and stuff to get going.
11:37:56 <threewood> Is StrictPragma stable / safe?  Any gotchas around using Haskell as a strict language?
11:38:46 <warbo> threewood: control flow, I'd imagine
11:38:50 <geekosaur> much of the Prelude assumes non-strict semantics
11:38:53 <cocreature> threewood: -XStrict doesn’t make Haskell strict. it makes only the module that you enable strict
11:39:03 <cocreature> so things get really confusing if you import code from other modules
11:39:08 <warbo> if you have any function that chooses between arguments, strict mode would force all of them
11:39:12 <dolio> Also, what does it make strict?
11:40:04 <warbo> which I can imagine might break some recursive patterns
11:40:24 <ab9rf> as i recall, it only affects patterns defined in that particular modul
11:40:41 <threewood> Yeah that's about what I'd expect.  Thanks all
11:41:06 <cocreature> mostly Strict just makes things really confusing and I would recommend that you just place explicit bang patterns instead of switching the default
11:41:17 <Ariakenom> > True && undefined
11:41:20 <lambdabot>  *Exception: Prelude.undefined
11:41:26 <warbo> by "pattern" I should have said style
11:41:29 <Ariakenom> > False && undefined -- heh
11:41:31 <lambdabot>  False
11:41:44 <cocreature> ab9rf: patterns and data types but not nested patterns
11:42:05 <dolio> Oh, not nested patterns?
11:42:15 <warbo> I meant e.g. 'foo n = ifThenElse (n > 0) (foo (n-1)) "hello"'
11:42:21 <cocreature> if you have something like "f (x,y) = … " it won’t be strict in x and y
11:42:25 <cocreature> only in the tuple constructor
11:42:25 <dolio> Anyhow, this is why you shouldn't use it. :)
11:42:43 <cocreature> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#strict-by-default-pattern-bindings has a section on nested patterns
11:43:13 <warbo> if 'ifThenElse' is some strict function, this will keep evaluating the recursive case, even when we've hit the base case
11:44:58 <dolio> I think what -XStrict demonstrates, kind of, is that there are no "strict languages".
11:45:45 <warbo> dolio: lambda is almost always lazy
11:45:49 <dolio> Because nested patterns aren't even a factor when you're programming in e.g. ML. Functions only receive values as arguments.
11:46:08 <cocreature> I kind of wish we had never gotten -XStrict. I have yet to see a good usecase for it while I’ve seen multiple times that people turn it on blindly because they get confused by lazyness
11:46:18 <dolio> So you don't even need to think about whether `f (x, y) = ...` evaluates x and y, because it doesn't have to; it's already been evaluated.
11:46:38 <hvr> cocreature: StrictData is a bit more useful though
11:47:11 <hvr> although I'm happy putting in those !s manually
11:48:08 <cocreature> hvr: right, I’m not a fan of StrictData because I think being explicit is still the better option but I can accept it. -XStrict on the other hand is just a bad idea imho
11:49:00 <ab9rf> cocreature: i find -XStrict far more confusing than i do regular laziness
11:49:19 <ab9rf> cocreature: because with -XStrict you get this difficult-to-predict mess of strictness and laziness
11:49:21 <hvr> cocreature: here's more confusion on meta-level regarding -XStrict: https://ghc.haskell.org/trac/ghc/ticket/15562
11:49:26 <dolio> Strict functions are only something you can think about in the semantics built for lazy evaluation.
11:49:55 <ab9rf> it's not really that idfficult to predict, but it's nonintuitive
11:50:45 <dsal> How do I run a megaparsec parser with Text and get my parsed thing back?   i.e., (A.parseOnly myparser t)
11:50:46 <cocreature> I do think it is pretty difficult to predict. you need to constantly keep in mind whether -XStrict is turned on or not for the module you are currently looking at
11:51:02 <ab9rf> cocreature: well, that's not "difficult", it's just tedious and error-prone
11:51:08 <dsal> Oh, nevermind
11:51:14 <cocreature> dsal: "parse"
11:51:16 <dsal> I was confused by the String
11:51:53 <cocreature> getting tedious and error-prone tasks right is difficult :)
11:55:02 <dsal> Wait, doesn't megaparsec require an explicit try for <|> ?  Why is my test passing?
11:55:03 <warbo> it would be nice to see tooling like HLint around strictness, e.g. "this argument is used as an accumulator, use ! to prevent thunks building up"
11:56:21 <cocreature> dsal: depends on what you mean by “requires”
11:57:08 <warbo> projects like https://github.com/Genetic-Strictness/Autobahn give me hope :)
11:57:26 <dsal> I thought that was a difference between megaparsec and attoparsec.   Like, you needed to use try to backtrack in case you were going the wrong direction.
11:59:23 <cocreature> dsal: right if you want to backtrack you need the try but maybe there is no need to backtrack in your test?
11:59:27 <geekosaur> dsal, make sure your test actually consumes something
11:59:49 <MarcelineVQ> or maybe you're using something that has a built in try behavior
12:00:04 <dsal> So, this was my original parser:  https://github.com/dustin/numberpuzzle/blob/master/src/NumberPuzzle.hs#L161-L171
12:01:28 <geekosaur> right, that looks like it won't consume some input before failing any particular branch, so try is unnecessary
12:02:25 <geekosaur> something like `string "aa" <|> string "ab"` needs try, or the "a" will be consumed by the first parser and the second receives "b"
12:03:02 <nshepperd> the second doesn't receive anything, the whole thing just fails
12:03:07 <dsal> OK, so just one character doesn't count as "consuming" here?
12:03:29 <cocreature> it doesn’t consume the character because it fails parsing that character
12:03:43 <cocreature> if it would first consume a character and then fail on the second, it would have consumed one character
12:03:45 <dsal> Oh, OK.  That makes sense.
12:03:51 <dsal> Thanks.
12:04:05 <dsal> Parsing RPN is excessively simple.  heh
12:08:08 <cocreature> geekosaur: if you wanted to be pedantic in megaparsec it doesn’t require a try since "string" has try builtin :)
12:08:40 <dsal> Is there a reason everything doesn't try by default?
12:09:11 <nshepperd> two reasons. performance and better error messages
12:09:38 <dsal> I could imagine performance, but how does it help error messages?
12:09:40 <cocreature> http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/ provides some examples of the latter
12:09:42 <mbwgh> I have a question about mtl-style transformer usage. If I have something `newtype FancyT m a = FancyT { unFancyT :: ReaderT Stuff m a } deriving (Functor, Applicative, Monad, MonadIO, MonadReader Stuff)`, the pass-through instance `MonadReader r m => MonadReader r (FancyT m)` would now overlap. Which would mean that a user couldn't implement a function `fun :: (MonadReader SomethingDifferent, MonadFancy m) 
12:09:48 <mbwgh> => m ()` via `FancyT (ReaderT SomethingDifferent m) ()` anymore. They would have to newtype instead. Is that correct? Does that mean that if I want to expose some reusable component, I have to restrict myself to only implementing `MonadFancy`, and the rest "in pass-through style"? With this example, it would mean losing the benefit of newtyping ReaderT, and I could have implemented it as `newtype FancyT m 
12:09:53 <dsal> Ah, thanks.
12:09:54 <mbwgh> a = FancyT { unFancyT :: Stuff -> m a }` just as well. Thoughts?
12:11:22 <Ariakenom> (1 + length [True]) (1 + sin 2) (length 1 + sin 2) This looks like a nice example of type inference to me
12:11:36 <Ariakenom> int, float, error
12:14:50 <mbwgh> Does my question make any sense?
12:15:38 <cocreature> Ariakenom: seems unnecessarily obfuscated length [True] + sin 2 is sufficient to produce an error
12:16:08 <cocreature> mbwgh: sure but I think there is not much to add to what you’ve already discovered yourself.
12:16:58 <mbwgh> cocreature: With discovery comes doubt :)
12:18:21 <mbwgh> Mtl-style is something I keep bashing my head against. The Dark Souls of abstractions.
12:19:18 <cocreature> mbwgh: I’d say the fact that FancyT uses a ReaderT Stuff internally is probably also more of an implementation detail and not necessarily something that you should expose to users by providing a MonadReader Stuff instance
12:21:16 * hackage radix-tree 0.1 - Radix tree data structive over short byte-strings  http://hackage.haskell.org/package/radix-tree-0.1 (SergeyVinokurov)
12:21:29 <Ariakenom> cocreature: Oh yeah, I meant those as 3 examples :p
12:21:50 <mbwgh> cocreature: That makes sense. It's probably some reflex from reading too much in the way of "mtl-style for the end-user".
12:21:53 <cocreature> Ariakenom: ah I see, that makes more sense :)
12:22:17 * hackage emacs-module 0.1 - Utilities to write Emacs dynamic modules  http://hackage.haskell.org/package/emacs-module-0.1 (SergeyVinokurov)
12:23:14 <monochrom> Whenever you give your users a type, you need to think about what you allow your users to do.
12:23:49 <cocreature> conclusion: types are dangerous and shouldn’t be handed to users
12:25:02 <monochrom> StateT is a great example because it has a lot of diverse unrelated applications, and in almost every application you do not intend to give your users the full capability of StateT.
12:25:35 <mbwgh> I have been wrangling with haskeline's InputT for way too long because of this though. Can't define MonadUnliftIO at all, ExceptT instance is missing et cetera. But I would agree that you should be careful about what goes into an .Internal module. It should exist though
12:26:12 <monochrom> So for example you use StateT --- as an implementation detail --- to implement a randomization monad, but you newtype-wrap it and give your user only a "get the next random number" operation. You don't let them access the internal StateT.
12:27:16 <mbwgh> And I write every function as fun = RandomT $ do ... ?
12:27:50 <mbwgh> Or whatever kind of inlined lifting may be necessary.
12:28:27 <cocreature> you can still use an mtl-style typeclass, e.g., MonadRandom
12:28:46 <cocreature> the point is that the fact that your standard instance is built on top of StateT doesn’t matter to users
12:28:59 <cocreature> so your API shouldn’t leak that to users (an internal module is ofc completely fine)
12:29:07 <MarcelineVQ> give them all the types, give them no constructors :>>>
12:29:42 <cocreature> MarcelineVQ: I will hunt you down if you don’t give them to me in an internal modul :)
12:29:58 <mbwgh> So: (MonadState Internal RandomT) bad, (MonadState s m => MonadState s (RandomT m)) good
12:30:10 <cocreature> exactly
12:30:21 <mbwgh> okay
12:30:27 <mbwgh> It is all falling into place now!
12:31:15 <monochrom> No, why would you do (MonadState s m => MonadState s (RandomT m))?
12:31:44 <monochrom> Why would you allow your users to use get and set?
12:32:22 <mbwgh> They might want to implement something like (MonadRandom m, MonadState TheUserStuffNotDefinedByMe m) => m a.
12:32:45 <monochrom> Oh nevermind, misread.
12:36:05 <mbwgh> I think it is not ideal that there is not much terminology around what instances should exist and what not. For instance, I call instances like the MonadState s m => ... "pass-through" instances, but that is most likely not something everybody can associate something with. And depending on whether you implement `ReusableLibraryT m a` or `UserAppT m a`, you may want to define some instances, but not others. 
12:36:11 <mbwgh> I have yet to find a book or tutorial that gives a detailed explanations about these kinds of dos and don'ts.
12:37:07 <superguest> monochrom, is MonadState conceptually similar to the one you defined/showed us?
12:37:27 <cocreature> mbwgh: fwiw I would classify “pass-through instances” as standard terminology that most people can relate to
12:37:48 <mbwgh> cocreature: Oh, good. I probably picked it up somewhere then.
12:40:45 <mbwgh> cocreature: But then there is two more kinds of instances. Instances like MonadUnliftIO that need access to the monadic context (the r in `ReaderT r m`). If you don't define this, your user needs access to the internals in order to be able to do it. And then there is the kind of stuff you only do in application code, like `deriving (..., MonadReader ThatConcreteTypeIAmWorkingWith)`.
12:41:50 <mbwgh> I wouldn't call the MonadUnliftIO instance "pass-through" is what I mean. You can't just delegate to the base monad, since you would drop the monadic context.
12:42:15 <mbwgh> If you are familiar with MonadUnliftIO. I am sure it is similar with MonadBaseControl for instance
12:42:55 <cocreature> except that MonadBaseControl also makes your brain hurt
12:43:38 <mbwgh> Agreed
12:43:59 <cocreature> I don’t think there is really any terminology for this kind of instances but I’m also not sure that such terminology would be useful given that these instances are defined more vaguely than the pass-through instances
12:45:43 <monochrom> superguest: No. It is a class.
12:46:15 <monochrom> Err, maybe yes. I showed my MonadGetChar class.
12:46:56 <monochrom> But you can find MonadState in Typeclassopedia.
12:48:27 <mbwgh> cocreature: I am not suggesting to define some officially sanctioned words. We would probably define what it means to "lift" something first :) Still though, I need to think in terms of _something_ when I have to make decisions.
12:48:43 <mbwgh> monochrom: Did you give a talk about the subject or something?
12:49:43 <mbwgh> monochrom: Maybe I am being naive here. You could be Simon Peyton Jones and I would be none the wiser...
12:50:22 <MarcelineVQ> That's ideal, if you don't know who's saying it you can be more critical
12:51:36 <mbwgh> Makes it more tricky to go ad-hominem though if you don't have dirt on them.
12:56:47 * hackage pandoc-emphasize-code 0.2.4 - A Pandoc filter for emphasizing code in fenced blocks  http://hackage.haskell.org/package/pandoc-emphasize-code-0.2.4 (owickstrom)
13:01:12 <superguest> what does `m->s` in `class Monad m => MonadState s m | m -> s where`
13:01:58 <superguest> mean?
13:02:14 <jle`> superguest: it's a functional dependency
13:02:20 <jle`> if that helps you with the googling keywords
13:02:39 <jle`> in practice it means that you must declare instances of MonadState in a way that 's' can be inferred from 'm'
13:03:10 <jle`> for example, MonadState s (State s) is legal, since if you have m ~ State Int, then s has to be Int
13:06:18 <jle`> but not legal is MonadState s Maybe, since knowing that m ~ Maybe doesn't tell you anything about what 's' should be
13:07:23 <superguest> jle` that is a good explanation.
13:07:45 <superguest> next, let's take a look at `state :: (s -> (a, s)) -> m a`
13:07:55 <superguest> "Embed a simple state action into the monad."
13:08:11 <jle`> thanks :)  yeah, it's a necessary constraint to make MonadState practical/useful to use, since a lot of times ghc can only infer one or the other directly
13:08:30 <superguest> so to use it, just pass in a lambda of type ` (s -> (a, s))`, right?
13:08:30 <jle`> so having the FunDep makes things a lot easier for type inference
13:08:39 <jle`> superguest: yeah, or not necessarily a lambda
13:08:41 <jle`> just any function will do
13:09:21 <mbwgh> superguest: It is also the reason why (MonadState This m, MonadState That m) doesn't work, meaning that some `StateT This (StateT That) m` monad would have to be merged into `StateT (This, That) m` in order to be used via the `MonadState` class, and not via explicit calls to `lift`.
13:15:25 <mbwgh> superguest: People call the book outdated, but Real World Haskell still has one of the nicest introductions to mtl in my opinion: http://book.realworldhaskell.org/read/monad-transformers.html
13:16:02 <superguest> ` (MonadState This m, MonadState That m)`, since "This" and "That" start in caps, so those aren't type variables, right?
13:16:51 <mbwgh> superguest: Yeah, they are some concrete types you may want to work with.
13:18:12 <mbwgh> superguest: Maybe (MonadState s m, MonadState t m) would have been easier to grok :)
13:20:45 <mbwgh> superguest: By the way, this kind of usage is exactly what the functions `gets` and `puts` are for, which take record accessors as argument. So with `MonadState (This, That)` you would use `gets fst :: MonadState (a, b) m => m a` to get the first tuple element, for instance.
13:27:53 <cocreature> they don’t take record accessors as arguments, they take functions as arguments
13:28:03 <cocreature> it just happens to be the case that you can use record accessors as functions
13:30:35 <mbwgh> I wanted to be descriptive, but true. You can use `gets (+2) :: MonadState Int m => m Int` to get the "current integer", incremented by two for instance.
13:39:35 <superguest> The reason why I have  (had?) trouble understanding what you just explained is b/c my understanding of "record accessor" is in the following context:
13:39:59 <superguest> > newtype Foo = Tag1 {deFoo :: Int}
13:40:01 <lambdabot>  <hint>:1:1: error: parse error on input ‘newtype’
13:40:13 <superguest> x = Tag1 1
13:40:24 <superguest> deFoo x
13:41:02 <superguest> (lambdabot never likes me, so let's leave him alone, since you guys probably already know what I am saying)
13:43:32 <ab9rf> lambdabot exists to make fools of us in public
13:47:01 <MarcelineVQ> I use the sneaky-snake trick of trying things in /query first
13:47:36 <mbwgh> superguest: Yeah don't think too much into the "record accessor" term. When you define `data Record = Record { rInt :: Int; rBool :: Bool }`, you have functions indistinguishable from what you would get if you had defined `data Record = Record Int Bool; rInt (Record n _) = n; rBool (Record _ b) = b`. They are just functions, they pollute the global namespace, and we don't have "real" records like the big 
13:47:43 <mbwgh> boys do.
13:50:04 <mbwgh> We do have lenses though, but I am not allowed to talk about them.
13:56:17 * hackage emacs-module 0.1.1 - Utilities to write Emacs dynamic modules  http://hackage.haskell.org/package/emacs-module-0.1.1 (SergeyVinokurov)
13:56:50 <JordiGH> How do you do negative numbers in Haskell?
13:56:56 <JordiGH> sin -2  # This errors out.
13:57:33 <epta> JordiGH: sin (-2)
13:57:41 <JordiGH> Thanks.
14:22:11 <glguy> > (sin - 2) 10
14:22:13 <glguy> > (sin -2) 10
14:22:14 <lambdabot>  -2.5440211108893696
14:22:15 <lambdabot>  -2.5440211108893696
14:22:43 <glguy> Haskell doesn't have negative integer literals (without an extension), the - is either negation or subtraction depending on where you use it
14:23:22 <glguy> That allows you to negate things other than integer literals
14:23:26 <glguy> > let x = 10 in -x
14:23:29 <lambdabot>  -10
14:23:40 <JordiGH> How does "sin -2" parse, then?
14:23:52 <glguy> as subtraction
14:23:55 <JordiGH> Oh, as a section, right?
14:23:59 <glguy> no
14:24:07 <glguy> sin-2 is sin -2 is sin - 2
14:24:45 <JordiGH> But why doesn't "sin -" produce the same gibberish?
14:24:57 <glguy> which gibberish?
14:25:07 <JordiGH> The one that sin -2 produces.
14:25:23 <glguy> it's all the same, but to subtract functions you need an extra instance: http://hackage.haskell.org/package/NumInstances-1.4/docs/Data-NumInstances-Function.html
14:25:23 <int-e> > (sin -) cos $ 2
14:25:26 <lambdabot>  1.325444263372824
14:26:09 <JordiGH> Is -2 a function or a number? Just like that, by itself.
14:26:23 <glguy> JordiGH: function and number are separate categories
14:26:28 <glguy> they aren't exclusive
14:26:37 <int-e> this Num instance is confusing.
14:26:40 <int-e> > sin cos tan 1
14:26:43 <lambdabot>  1.3387802193205699e-2
14:26:43 <JordiGH> And no, "sin - 2" and "sin -" produce different gibberish.
14:26:51 <int-e> > sin (cos (tan 1))
14:26:53 <lambdabot>  1.3387802193205699e-2
14:26:53 <geekosaur> unary minus is something of a parsing glitch in Haskell
14:27:04 <glguy> > (- 2) 3
14:27:06 <lambdabot>  -2
14:27:09 <geekosaur> there are several extensions that change how it's handled, each with its own alternative glitches
14:27:18 <JordiGH> If sin is complaining about how it can't accept - as its first argument, then I don't understand why the incomprehensible complaint differs in each case.
14:27:57 <geekosaur> - there is an operator, not a parameter
14:28:09 <geekosaur> (-) with the parentheses would be needed to make it a parameter
14:28:31 <JordiGH> Ah, so sin (-) does produce similar gibberish.
14:28:35 <geekosaur> and section syntax is just inserting one or the otger parameter into that
14:29:49 <int-e> There is a NegativeLiterals language extension that would distinguish between  sin -1  and  sin - 1  but lambdabot doesn't have it enabled.
14:31:25 <JordiGH> I see.
14:32:07 <glguy> then you get funny behavior like: (x-1) means x applied to negative one
14:32:28 <JordiGH> Does Haskell have, uh, reader macros?
14:32:51 <geekosaur> nope
14:33:08 <JordiGH> So how do you implement stuff that modifies the parser?
14:33:16 <geekosaur> compiler plugins or preprocessors
14:38:24 <ab9rf> i would love an option to use - as always being an operator and ‾ being used for unary minus
14:39:23 <JordiGH> I remember when we made that distinction when I was a kid.
14:39:33 <ab9rf> APL used _ for negative numeric literals, but Haskell already uses _ for other porpoises
14:40:44 * [exa] wishes for map (-1)
14:41:15 <glguy> I want more keys on my keyboard
14:41:30 <ab9rf> i used a 21-button mouse once
14:41:32 <superguest> int-e, I tried  `(sin -) cos $ 2` in ghci and it emits the following error msg:
14:41:53 <superguest>  Non type-variable argument in the constraint: Num (r -> r)
14:41:53 <superguest>     (Use FlexibleContexts to permit this)
14:42:00 <glguy> superguest: to subtract functions you need an extra instance: http://hackage.haskell.org/package/NumInstances-1.4/docs/Data-NumInstances-Function.html
14:42:12 <hpc> just use (‐) for subtraction and (‑) for negation
14:42:27 <ab9rf> hpc: i get a missing-char box for that one
14:42:40 <hpc> unicode breaking and non-breaking hyphen
14:43:01 <glguy> ab9rf: https://imgur.com/a/RNYPGze
14:43:06 <MarcelineVQ> almost as confusing as reading the formatting of math forumlae on wikipedia
14:43:18 <ab9rf> wikipedia is programmed to confuse
14:43:53 <ab9rf> glguy: heh, very distinguishable visually
14:45:13 <MarcelineVQ> ab9rf​reads​this​as​seperate​words​? :>
14:45:43 <ab9rf> MarcelineVQ: no
14:45:56 <hpc> MarcelineVQ: that sentence could use some zero-width spaces
14:47:03 <MarcelineVQ> 'I was going to put some in but the bin was empty, I think'
14:47:51 <superguest> `import Data.NumInstances.Function` --  "Could not find module 'Data.NumInstances.Function'
14:48:35 <superguest>  > (sin -) cos $ 2
14:48:40 <superguest> > (sin -) cos $ 2
14:48:43 <lambdabot>  1.325444263372824
14:48:54 <superguest> so I guess lamdabot already has it preloaded.
14:48:56 <geekosaur> you need to install the NumInstances package
14:48:58 <Gurkenglas> Is there an Arbitrary instance for Haskell source files?
14:49:11 <geekosaur> I think someone loaded it manually into lambdabot; people do that occasionally
14:49:19 <hpc> Gurkenglas: become a professor :D
14:49:35 <Gurkenglas> (In particular, shrink could be useful)
14:49:50 <hpc> oh, that would be interesting
14:51:39 <Gurkenglas> Possible requirements to shrink would be that shrink on a compiling syntax tree gives compiling syntax trees, or perhaps that the only compilation errors are missing typed holes
14:51:54 <geekosaur> codegolf.stackexchange.com? :p
14:51:57 <Gurkenglas> -missing
14:52:07 <Gurkenglas> geekosaur, no it need not be semantics-preserving
14:53:17 <Gurkenglas> The usecase I had in mind was haskell-ide-engine taking longer to process a certain file on the latest version, so shrink could give us a smallest file it takes longer to process on the latest version
15:01:21 <superguest> how is `(sin -) cos $ 2` parsed though?
15:01:42 <superguest> if `-` is subtraction then, it expects two arguments.
15:01:51 <glguy> As subtraction
15:02:01 <glguy> It is an operator section
15:02:34 <glguy> (a +) is \x -> a + x
15:03:21 <superguest> glguy thank you.
15:03:40 <geekosaur> think of this as naming the operator by wrapping it in parentheses, then partially applying it.
15:08:35 <int-e> @undef
15:08:35 <lambdabot> Undefined.
15:08:39 <int-e> > sin cos 1
15:08:41 <lambdabot>  error:
15:08:41 <lambdabot>      • No instance for (Floating (Double -> Double))
15:08:41 <lambdabot>          arising from a use of ‘e_11’
15:08:52 <int-e> so no, it's not there by default.
15:09:30 <zuserm> I'm trying to build diagrams-lib from git, but cabal is having none of it :(
15:10:30 * glguy peeks at zuserm's screen
15:12:21 <glguy> Oh yeah, that does look bad!
15:12:49 <zuserm> sorry, one sec
15:13:25 <Average-user> I need to sort a list of list of Ints. Whats the fastest way? Is it possible to do radix sort? Maybe converting back and forth to Vectors or something like that?
15:15:18 <zuserm> https://gist.github.com/bacchanalia/3f41050bed387ee41544e6fd3722fa65
15:16:29 <glguy> You can either use new-build instead of build, or cabal install --dep
15:19:43 <zuserm> cabal new-build just prints "Resolving dependencies..." then exits
15:22:16 <zuserm> had to update. I thought I did, :| anyway, thanks.
15:22:47 * hackage cql-io 1.0.1.1 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-1.0.1.1 (romanb)
15:31:41 <superguest> what does it mean function subtraction mean for Num class instances?  (-) :: (a -> b) -> (a -> b) -> a -> b
15:32:07 <superguest> take int-e 's example: (sin - cos) $ 2
15:33:14 <mnoonan> (f - g) x = f x - g x
15:35:17 <superguest> <int-e> > (sin -) cos $ 2
15:35:17 <superguest> <lambdabot>  1.325444263372824
15:35:56 <superguest> answer from my calculator : −0.96449133
15:36:20 <mnoonan> > sin 2 - cos 2 -- I think you aren't using your calculator right :)
15:36:23 <lambdabot>  1.325444263372824
15:36:43 <geekosaur> or it's in degrees mode
15:36:43 <mnoonan> probably in degrees
15:41:15 <Gurkenglas> Can Dynamic be Serialized?
15:42:12 <hpc> maybe if you did an immense amount of cleverness with the TypeRep it contains?
15:42:29 <hpc> amusingly, it has a Show instance but it only shows the TypeRep
15:42:34 <ab9rf> i'm not feeling very dynamic right now
15:43:45 <Gurkenglas> Eh, someone did it. http://hackage.haskell.org/package/dynamic-state-0.3.1/docs/Data-DynamicState-Serializable.html
15:43:50 <geekosaur> Dynamic itself, no. if you make a variant that also imposes an appropriate serializable constraint on its contents, then yes
15:43:58 <geekosaur> which is presumably what that does
15:47:16 <croben> does the type signatures "a -> b -> a" and "a -> b -> b" uniquely define functions?
15:47:53 <threewood> not in Haskel
15:47:54 <threewood> Haskell
15:48:12 <threewood> you have  f x y = x and  f x y = f x y
15:49:09 <Gurkenglas> Well, the latter is more precisely "a -> b -> c"
15:49:23 <croben> agreed
15:49:41 <hpc> f x y = y `seq` x
15:49:59 <Gurkenglas> Well, that one only works because they forgot to make Seq a typeclass
15:50:12 <Gurkenglas> *because seq's older than typeclasses, I guess?
15:50:14 <hpc> f x y = error "ha! didn't see this coming"
15:50:19 <Gurkenglas> still a -> b -> c
15:50:36 <croben> hpc: good point
15:50:44 <hpc> `asTypeOf` const
15:50:56 <Gurkenglas> Should there be a language extension ExplicitSeq?
15:50:57 <hpc> somewhere in there
15:51:20 <Gurkenglas> Or perhaps a ghci flag that adds Seq to :t outputs?
15:51:42 <croben> is it uniquely defined enough to claim that it is when you're teaching someone haskell? 
15:52:35 <rotaerk> I'd just say that the signature strongly suggests what it does
15:52:40 <Gurkenglas> hpc, well asTypeOf is more precisely a -> b -> a
15:52:56 <croben> Gurkenglas: since bottom inhabits every type, error would be a -> b -> a or a -> b -> b
15:53:47 <Gurkenglas> croben, it would more precisely be "forall a b c. a -> b -> c", and of course it can be specialized to "forall a b. a -> b -> a", but that's not what we do when we want to derive code from types
15:55:02 <croben> where do you get this c from?
15:55:15 <Gurkenglas> from error being "forall c. String -> c"
15:55:51 <croben> it type checks
15:56:00 <Gurkenglas> What type checks?
15:56:20 <croben> f0 :: a -> b -> a
15:56:26 <croben> f0 = undefined
15:56:54 <croben> which means there are two possible implementations
15:56:57 <croben> in haskell
15:57:02 <Gurkenglas> undefined is "forall x. x", and you will not see the compiler complain to you if you specialize it to "forall a b. a -> b -> a"
15:57:47 <croben> there is no difference between an error and undefined
15:57:49 <croben> i thought
15:58:28 <Gurkenglas> error "asd" is also "forall q. q"
15:58:49 <Gurkenglas> (What I name the type variable is irrelevant.)
15:59:27 <croben> i'd argue that haskell has two possible implementations
15:59:42 <croben> of both of my type signatures
16:00:24 <Gurkenglas> croben, how do you define two implementations to be equal?
16:00:42 <croben> that is a very good question
16:01:20 <croben> by their return value
16:01:37 <croben> i guess
16:01:46 <Gurkenglas> How do you define two return values to be equal?
16:02:17 <croben> dang
16:02:26 <hpc> i think the word you're looking for is extensional equality?
16:02:40 <croben> Eq a => a -> b -> a :p
16:16:06 <ab9rf> not all types are instances of Eq
16:16:51 <croben> i know
16:17:03 <croben> that's why i changed it
16:18:46 <ZeuPiark> bye
16:19:16 <croben> i've decided not to claim anything, other than that "only id" for a -> a and "id + error/undefined" are accepted answers
16:48:57 <Gurkenglas> Good choice.
16:49:17 * hackage composition-prelude 1.5.3.0 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.5.3.0 (vmchale)
16:50:47 * hackage composition-prelude 1.5.3.1 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-1.5.3.1 (vmchale)
16:50:59 <infinisil> Ah yes, the <-=**< operator from above package, using it all the time
16:51:25 <infinisil> Not as much as I'm using the -.**** one though
16:52:19 <hpc> why does "reexports" have an umlaut?
16:52:39 <geekosaur> someone's being archaic?
16:52:42 <geekosaur> or french?
16:52:47 <dolio> Sometimes that's used for double letters.
16:52:53 <dolio> Like coördination.
16:52:59 <geekosaur> more specifically, when one is pronounced separately from theother
16:53:23 <geekosaur> you can find that in, say, public domain / copyright lapsed English dictionaries
16:53:34 <geekosaur> coöperation, etc.
16:54:03 <geekosaur> abotu the only instance that you ever see these days is naïve, and even that's uncommon
17:03:11 * monochrom hugs his résumé
17:04:42 <glguy> The New Yorker has an article about why they use that
17:04:57 <glguy> https://www.newyorker.com/culture/culture-desk/the-curse-of-the-diaeresis
17:08:50 <dolio> Yeah, the New Yorker is the only place I've ever actually seen it.
17:12:17 * hackage madlang 4.0.2.12 - Randomized templating language DSL  http://hackage.haskell.org/package/madlang-4.0.2.12 (vmchale)
17:25:29 <croben> would "you can curry functions in any language with closures" be a correct statement?
17:29:42 <threewood> no, a language could let you form closures, but not return them
17:30:36 <croben> would "any language that has anonymous functions" be better?
17:31:34 <croben> or "with first-class functions"
17:31:52 <threewood> first-class functions is better, I think
17:32:46 * hackage hunspell-hs 0.2.0.0 - Hunspell thread-safe FFI bindings for spell checking.  http://hackage.haskell.org/package/hunspell-hs-0.2.0.0 (ashutoshrishi)
17:33:54 <croben> threewood: thanks :)
17:34:46 <threewood> np what are you working on?
17:49:33 <cheater> hi
17:49:38 <cheater> how do i work with data types like that? type CommitOid r = Tagged (Commit r) (Oid r)
17:49:57 <cheater> i want to get at the Commit r.
17:50:02 <cheater> in specific one of its fields.
17:52:07 <geekosaur> if it's exported, you can pattern match on it
17:52:11 <geekosaur> which Tagged is it using?
17:52:12 <glguy> cheater: the value constructor for Tagged is also Tagged
17:57:46 * hackage brainheck 0.1.0.9 - Brainh*ck interpreter in haskell  http://hackage.haskell.org/package/brainheck-0.1.0.9 (vmchale)
17:58:01 <cheater> so what do i do? i'm using a function which hands a CommitOid to a callback i write.
17:58:18 <cheater> just pattern match?
18:13:32 --- mode: glguy set +v cobax_
18:13:46 --- mode: glguy set +v cosmia
18:13:54 <cobax_> Where can I read more about making types out of functions (like State { runState :: s -> (v,s) } instead of plain records? (which for me is an interesting leap in thinking that I'd like to explore more slowly)?
18:15:04 --- mode: glguy set -v cobax
18:20:22 <cheater> well, apparently you can't get at the first argument of Tagged, it's like a phantom type
18:20:36 <cheater> cobax: as opposed to MyData { foo :: String } ?
18:22:46 <cobax> cheater: Hmm, let me think about that. While I think, here is the sort of thing that inspired me to ask this question, it is this pattern: newtype ProjectId = ProjectId  { unProjectId :: Int  } deriving (Show, Eq, Num)
18:24:04 <cobax> I guess that, mixed with the only field being a function, is getting me confused unnecessarily. I think I get it now. so this comes from, first, generalizing the way to declare a project from "ProjectId = Int" to "newtype ProjectId = ProjectId  { unProjectId :: Int  } deriving (Show, Eq, Num)"
18:24:56 <cobax> and then on top of that pattern, deciding that the only "field" still depends on some other variable "state", thereby making the only field become a function that needs "state"
18:25:45 <cheater> ok so
18:25:59 <cheater> type ProjectId = Int is just an alias. it's another name for Int
18:26:39 <cobax> what about type ProjectId = ProjectId { unProjectId :: Int } ?
18:26:46 <cobax> how is that different?
18:26:51 <cheater> newtype ProjectId = ProjectIdConstructor Int is an actual, new, type, which is inhabited by values like ProjectIdConstructor 1, ProjectIdConstructor 10, ProjectIdConstructor 89
18:27:28 <cheater> newtype ProjectId = ProjectIdConstructor { unProjectId :: Int } is a syntax that also lets you get the Int out of a value of type ProjectId
18:27:47 <cheater> so if you have a p that is of type projectId, you can do unProjectId p, and that is an Int.
18:28:29 <cobax> That makes sense.
18:28:30 <cheater> that's it. now if you have a value x of type State, then runState x will be of type s -> (v, s), whatever s and v are
18:29:01 <cheater> you left out the type arguments to State, which are s and v
18:29:07 <cheater> :i State
18:29:38 <cheater> @hoogle State
18:29:38 <lambdabot> module Control.Monad.State
18:29:39 <lambdabot> Control.Monad.State.Lazy type State s = StateT s Identity
18:29:39 <lambdabot> Control.Monad.State.Strict type State s = StateT s Identity
18:29:41 <cheater> here you go
18:30:01 <cobax> cheater: Yeah, I always get confused about that. For example, if you look at line 3, I don't know how the author knows that it's (State s) and not (State) that he wants to write there: https://github.com/Agnishom/PRGH17/blob/master/tut5/stateExamples.hs
18:30:54 <cheater> look at what lambdabot just said
18:30:59 <cheater> Control.Monad.State.Lazy type State s = StateT s Identity
18:31:08 <cheater> that is missing one type argument, v
18:31:19 <cheater> so type State s v = StateT s Identity v
18:31:38 <cheater> basically, State s v is "a State s that holds v's"
18:31:41 <cobax> well we can pretend it's not based on a transformer for simplicity's sake like the code I linked above
18:31:48 <cheater> just like a list that compares v's
18:31:59 <cheater> just like a list that contains v's
18:32:01 <cheater> sorry
18:32:17 <cobax> cheater: I get all of that but how does the author know to write exactly (State s) there on line 3?
18:32:23 <cheater> what i'm saying is, State s is a thing that contains v's
18:32:31 <cheater> a Functor is a thing that contains things
18:32:59 <cheater> therefore, if you want to make something a Functor, you can make State s the Functor.
18:33:13 <cobax> why not (State s v) ? So is it always supposed to be the constructor almost full up to the last argument?
18:33:32 <cheater> State s v has no type parameters. Functor does.
18:33:36 <cheater> :k State s
18:33:38 <lambdabot> error: Not in scope: type variable ‘s’
18:33:40 <cheater> hm
18:33:42 <cobax> Sure , sure.
18:33:43 <cheater> :k State
18:33:44 <lambdabot> * -> * -> *
18:34:15 <cheater> State has kind * -> * -> *. this means that State s, ie State with one type argument applied, has kind * -> *
18:34:18 <cheater> :k Functor
18:34:20 <lambdabot> (* -> *) -> Constraint
18:34:29 <cobax> So 99% of the time it will be "instance Functor (MyCustomType n1 n2 ... nk-1)"  (leaving out nk so that it is a Functor) ?
18:34:34 <cheater> Functor needs something that's * -> *
18:34:42 <cobax> I get that.
18:34:50 <cheater> State s v, i.e. state with two type arguments applied, is going to be of kind *
18:34:53 <cobax> I am trying to understand in general if it will always look like that
18:35:08 <cheater> well, no, not necessarily, you just need to make the kind the same
18:35:29 <cobax> So if my type has 5 arguments I pick one to be the functor one? Or maybe I make a pair of two of them and make them be in the functor, accessible by fmap?
18:35:51 <c_wraith> cobax: you don't get to choose - the type application rules in Haskell mean it's always the last argument
18:36:11 <cheater> that's right. if your type has 5 arguments, you have to apply 4.
18:36:30 <cobax> c_wraith: ahh ok, so it is enforced that it will always look like the type almost full except for the last parameterized type
18:36:37 <cobax> cheater: I see
18:36:39 <cheater> c_wraith: couldn't you do type MyFoo' a b d c = MyFoo a b c d   to reshuffle the arguments?
18:36:58 <cheater> cobax: in this case yes, because Functor needs a free type argument
18:37:02 <c_wraith> cheater: you can use a newtype for that, but then you need to apply and move the newtype wrappers
18:37:07 <cheater> cobax: some type classes might need more or less
18:37:14 <cheater> c_wraith: right
18:38:20 <cobax> Will it ever happen that I want 2 types parameterized in the functor so that "instance Functor (MyType (n3,n4)) where" for some MyType n1 n2 n3 n4 ?
18:38:43 <cheater> no
18:38:53 <cheater> Functor can only ever have 1 type argument.
18:39:15 <c_wraith> cobax: https://stackoverflow.com/questions/44134833/order-of-type-variables-in-instance-declarations/44139690 has a longer answer that works through the rules Haskell applies
18:39:22 <cheater> but i'm not sure if that's what you're asking about.
18:39:29 <cheater> maybe you were asking about something else.
18:42:58 <cobax> So if I want to parameterize over two types, I'd better do "data MyTwoTypes T3 T4", then data TheTypeIWantToBuild T1 T2 MyTwoTypes, so that now I do "instance Functor (TheTypeIWantToBuild T1 T2) where" and now fmap can access MyTwoTypes, hence T3 and T4 ?
18:43:46 <cheater> yea
18:43:55 <cobax> Ahh...! :)
18:43:55 <Cale> cobax: those data declarations are not quite valid syntax, and I'm not 100% sure what you mean
18:43:59 <cheater> consider how this works with a list, that's the canonical example of a Functor
18:44:00 <cobax> sure sure
18:44:27 <Cale> If you write something like  data MyPair a b = P a b
18:44:35 <cheater> Cale: he wants a Functor that holds a pair of types, that's all.
18:44:50 <cobax> Yeah, I want to stuff two things in there for fmap to see
18:44:51 <Cale> You can write an  instance Functor (MyPair a) where fmap f (P x y) = P x (f y)
18:45:08 <Cale> But if you want fmap to act on both things, they'll have to be the same type
18:45:15 <Cale> and there will need to just be a single type parameter
18:45:19 <cobax> Oh, they'll have to be the same type?
18:45:23 <Cale> of course
18:45:24 <cobax> They cannot be parameterizable by the user?
18:45:26 <Cale> :t fmap
18:45:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:45:32 <Cale> They must both have type a
18:45:50 <Cale> If fmap is going to apply the function you give it to both of them
18:46:08 <cheater> Cale: cobax was asking about something else i think
18:46:20 <cobax> Yeah, allow me to re-frame the question
18:46:27 <cheater> he was asking about having something like [MyPair a b]
18:47:55 <cobax> For instance, nevermind transformers, see how newtype State s v = State { runState :: s -> (v,s) } needs to be "instance Functor (State s) where" (dropping the v, the final argument) ?
18:48:29 <cobax> From that, I wonder if I can have newtype MyType s1 s2 v1 v2 and have somehow "instance Functor (MyType s1 s2) where" so that fmap sees v1 and v2
18:48:52 <cobax> and I was wondering if the answer to that is "package up v1 and v2 into SomeType v1 v2" and then put it there as "the last argument"
18:49:11 <Cale> You can't.
18:49:23 <Cale> :k Functor
18:49:25 <lambdabot> (* -> *) -> Constraint
18:49:39 <cobax> so that "newtype MyType s1 s2 MyV1V2" so that now I can "instance Functor (MyType s1 s2) where" and now fmap sees MyV1V2 and hence operates over both types?
18:50:00 <Cale> Functor itself wants an argument of kind * -> *, i.e. something which accepts just a single ordinary type as its parameter, and produces another.
18:50:56 <cobax> Ok, I get that.
18:51:01 <Cale> There is a class called Bifunctor which might be more what you're looking for
18:51:27 <Cale> It defines   bimap :: (Bifunctor p) => (a -> b) -> (c -> d) -> p a c -> p b d
18:52:02 <Cale> https://hackage.haskell.org/package/bifunctors-5/docs/Data-Bifunctor.html
18:53:08 <cobax> Hmm, I guess because Bifunctor exists, that that answers my question.
18:53:25 <cobax> Since that means Functor is not generalizable to multiple arguments as I thought.
18:53:57 <cobax> So either Bifunctors are not of much use or there are also Trifunctors etc?
18:54:13 <Cale> Of course, if you have some functor F, and you have a value of type F (a,b), then you can apply fmap to some function (a,b) -> c to obtain F (a,b) -> F c
18:54:35 <Cale> You could go farther, but Bifunctor only sees a little bit of use as it is.
18:55:01 <cheater> nah what you want is newtype MyType s1 s2 (v1, v2)
18:55:02 <cobax> Cale: is your last sentence because of your penultimate sentence?
18:55:06 <cheater> that's what you want
18:55:12 <cheater> the thing you came up with was a good idea
18:55:19 <cobax> cheater: Yes basically
18:55:39 <cobax> well I don't know if I came up with anything lol let alone that it is a good idea
18:55:42 <Cale> cobax: Not *really* -- they're not actually very similar things
18:56:00 <cobax> Cale: I suppose I have trouble seeing how they are so different
18:56:14 <Cale> Note that you can have something like data Tree a b = Leaf a | Branch b (Tree a b) (Tree a b)
18:56:27 <Cale> This will be a Bifunctor
18:56:42 <Cale> But the a's and b's are in different locations throughout the structure
18:56:42 <cobax> bi referencing "a b" ?
18:56:52 <Cale> so it's not equivalent to any functor applied to a pair type
18:57:05 <Cale> bi referring to the two parameters, yeah
18:57:56 <cobax> so what would it look like for Tree, something like "instance Bifunctor (Tree) where" (instead of (Tree a) or obviously not (Tree a b)) ?
18:58:08 <Cale> Specifically, we'll have  bimap f g (Leaf x) = Leaf (f x); bimap f g (Branch y l r) = Branch (g y) (bimap f g l) (bimap f g r)
18:58:26 <Cale> yeah, instance Bifunctor Tree where ...
18:58:32 <cobax> Wow, I see...
18:59:00 <cobax> That tree is a good example... I didn't know Tree was a bifunctor, I thought it was (only?) a functor
19:01:19 <cobax> Cale: can you tell me an example of a structure shaped like Functor (a,b) ?
19:01:24 <Cale> You can think of it as just being a (mathematical) functor in each argument -- though it can only really be a Haskell Functor in the last.
19:01:59 <Cale> You mean like, if we apply something which is a functor to the type of pairs?
19:02:07 <cobax> Yes
19:02:17 <Cale> I guess just pick your favourite functor
19:02:20 <Cale> lists are good
19:02:21 <cobax> State is almost that, it just depends on one argument, making it a function, right?
19:02:23 <Cale> [(a,b)]
19:02:41 <Cale> you can have values of type  State s (a,b)
19:03:02 <cobax> Yeah... well, let me just ask you this, then
19:03:17 <cobax> And I'm taking as reference this exercise (no transformers): https://github.com/Agnishom/PRGH17/blob/master/tut5/stateExamples.hs
19:03:39 <cobax> Could it somehow be newtype State s v = State { runState :: (v,s) } ? And we handle the "s" dependency in code?
19:03:58 <Cale> That probably doesn't make sense
19:04:21 <Cale> What do you mean by "handle the s dependency in code"?
19:04:52 <cobax> the dependency referring to the fact that to build the pair (v,s) I depend on the caller supplying an s
19:05:43 <Cale> But that doesn't mean the same thing
19:06:27 <cobax> What made someone think to represent the dependency as a function on the type of State, instead of just saying "well state is a pair of (v,s)"?
19:06:56 <Cale> The whole point is that a value of type State s a is supposed to encode some sort of computation which manipulates a value of type s somehow while producing a value of type a.
19:07:24 <Cale> i.e. we're building a little language in which there is effectively just a single global mutable variable of type s
19:07:42 <cobax> For instance, there was a leap of thinking when DARPA ran that shape recognition project and the Haskell candidate chose to represent Shape as a function from Point to Region or something...
19:07:50 <Cale> and we don't just want to write the s
19:07:56 <Cale> we want to be able to read it as well
19:08:07 <Cale> and determine the new value for s in terms of the old one
19:08:41 <cobax> sure, hence why we make it fmappable.
19:08:46 <Cale> We could define State s a in a very different way
19:08:54 <Cale> It might be helpful to try that
19:09:06 <cobax> Oh please, show me how, is there a way to define it so that there is no function in the type?
19:09:09 <Cale> yes
19:09:14 <cobax> Really?
19:09:21 <cobax> That's what I want to see
19:09:25 <Cale> actually, no
19:09:27 <Cale> lol
19:09:29 <cobax> lol
19:09:35 <Cale> But it's a different function?
19:09:41 <cobax> that's good, I was prepared to have my mind blown
19:09:58 <Cale> data State s a = Done a | Get (s -> State s a) | Put s (State s a)
19:10:08 <cobax> like some iteratee pattern?
19:10:17 <Cale> If s were a fixed finite type, we could remove the function
19:11:05 <Cale> e.g. if s were Bool, then s -> State s a is more or less equivalent to a pair of State s a (one for when we observe False, and the other for True)
19:11:25 <Cale> So it's possible to think of this as a weird sort of potentially-infinitely-branching sort of tree
19:12:02 <Cale> The way you should interpret this is that every State s a computation is either simply finished, and gives us a result of type a, that's the Done a case
19:12:29 <Cale> or it begins by reading the state, and determines what to do next based on that, that's the Get case
19:12:39 <cobax> or by inputting state with Put
19:12:45 <cobax> I like how you broke that down
19:13:02 <Cale> Yeah, Put will replace the current state with a new value
19:13:10 <Cale> So we can write an interpreter for this:
19:13:20 <cobax> I just find it interesting how the function crept up to the type level... and how it couldn't be handled just by code
19:13:25 <Cale> runState :: State s a -> s -> (s,a)
19:13:43 <Cale> runState (Done x) s = (s, x)
19:14:00 <cheater> what do you call this syntax?
19:14:01 <Cale> runState (Get k) s = runState (k s) s
19:14:01 <cheater> lgLookupTree :: (MonadLg m, HasLgRepo m) => TreeOid -> m Tree
19:14:01 <cheater> lgLookupTree (untag -> oid)
19:14:20 <cheater> TreeOid = Tagged ... ...
19:14:34 <Cale> runState (Put s' c) _ = runState c s'
19:14:44 <cobax> the interpreter pattern?
19:14:53 <Cale> cheater: That's a view pattern
19:14:56 <cobax> Cale: I definitely see what you mean
19:15:21 <Cale> cobax: Note that this runState is basically the equivalent of the one which is defined by the other approach
19:15:30 <Cale> If we define a datatype like
19:15:46 <Cale> newtype State s a = S { runState :: s -> (s,a) }
19:15:55 <Cale> then this automatically defines a field extractor
19:16:06 <Cale> runState :: State s a -> s -> (s, a)
19:17:44 <cobax> That part is confusing to me, so why isn't that in the signature? newtype State s a = S { runState :: State s a -> s -> (s, a) }
19:17:52 <Cale> Because it's implied
19:18:02 <Cale> You're giving the types of the fields of the constructor there
19:18:07 <cobax> wow, ok. That has been confusing me all along
19:18:20 <Cale> and then you automatically obtain functions which extract each of the fields
19:18:38 <Cale> e.g. you might define  data Point = Pt { x :: Integer, y :: Integer }
19:18:40 <cobax> so I'm saying there, runState is a field, its type is s -> (s, a)
19:19:01 <Average-user> Is there a difference between doing (compare `on` f) and (comparing f)?
19:19:01 <Cale> and then that would get you the function x :: Point -> Integer
19:19:07 <Cale> Average-user: no
19:19:37 <cobax> Cale: ok
19:19:53 <Cale> Average-user: both of them probably inline away, if you're talking about performance
19:20:00 <Cale> and they're semantically the same
19:20:11 <cobax> Cale: it's interesting because runState is not even used in that script I linked
19:20:38 <Cale> Which is also unfortunate, because these definitions are way easier to read if you use it
19:20:42 <cobax> Cale: when (State g) is deconstructed on line 4, the type of g is the type of the field, I suppose
19:20:54 <cobax> and so the programmer just goes ahead and applies it
19:21:07 <Cale> Yeah, not pattern matching the State constructor away makes it more obvious what the meaning of the code is
19:21:15 <Cale> e.g.
19:22:10 <Cale> x >>= f = State $ \s -> let (v, s') = runState x s; (w, s'') = runState (f v) s' in (w, s'')
19:22:21 <Average-user> Cale: So they are essentialy the same, samanticaly and in performance?
19:22:39 <Cale> Average-user: yeah, it's just that with `on`, you're breaking it into smaller parts
19:22:51 <cobax> Cale: right, if you don't deconstruct, then you have to runState x
19:23:24 <Cale> cobax: and that reads a little more like how you'd describe the operation being performed in English
19:23:27 <Average-user> Cale: Is there any reason to preffer one of them?
19:23:54 <Cale> Average-user: Well, I invented comparing first, so it'll always have a special place in my heart, lol
19:24:07 <edmundnoble> Does anyone know the name of that tool Snoyman uses to send messages into the future, with a proof that the message was really written when he says it was?
19:24:08 <cobax> Cale: I agree
19:24:23 <Cale> Average-user: But you can use `on` with other operations
19:24:28 <Cale> e.g. (==) `on` f
19:25:40 <Cale> cobax: i.e. x >>= f is the computation which first runs x on the initial state, obtaining some new state s' and result v, and then continues by running f v on that new state s'
19:25:48 <Cale> producing its final state and result as its own
19:26:14 <Average-user> Cale: You invented comparing?
19:26:18 <Cale> Average-user: yeah
19:26:45 <Average-user> Cale: The whole Data.Ord too?
19:27:16 <Cale> Just that
19:27:37 <Cale> Well, there's not much else in there, is there?
19:27:46 <Cale> ah, there's Down
19:28:05 <MarcelineVQ> Down is handy
19:28:37 <Average-user> jaja
19:29:48 <Average-user> I've defined this function:
19:29:50 <Average-user> myNub :: Ord b => (a -> b) -> [a] -> [a]
19:29:50 <Average-user> myNub f = map (fst . head) . groupBy ((==) `on` snd) . sortBy (comparing snd) . map ((,) <*> f)
19:30:14 <Average-user> Would be better to just use (uniqueSortOn f)?
19:30:35 <Average-user> My benchmarks show no difference, at least with what I'm working
19:30:50 <Cale> Well, it's probably implemented something like that
19:31:42 <Cale> If you want to preserve the order of the original list though, there are ways to do that too
19:32:07 <Average-user> I don't
19:32:17 <Average-user> Performance is priority
19:32:39 <Cale> Are you sure you don't just want to use Data.Set?
19:33:20 <Average-user> I just have to eliminate duplicated elements once
19:33:37 <Average-user> What would be the advantage of using Data.Set?
19:33:54 <Cale> Often if something is really a Set, you're better off using that datatype just because it's more convenient, but also there are operations such as union and intersection which are implemented more efficiently than you're likely to obtain on a list
19:34:07 <Cale> You get efficient membership tests as well, rather than O(n)
19:34:26 <Average-user> Yeah, I've used it
19:34:42 <Average-user> But in this case, the only thing I want to do, is to remove isomorhisms out a list of trees
19:34:51 <Average-user> isomorphisms*
19:35:18 <MarcelineVQ> also   toList . fromList   is just nice to write sometimes after trying much longer things :>
19:35:20 <Average-user> and the f in (uniqueSortOn f) is an isomorphism invariant
19:35:42 <Average-user> But you cant use toList.fromList with your own comparing functions
19:35:47 <Average-user> or equality functions
19:36:31 <Average-user> And since I'm using Data.Tree, the Eq and Ord instances are already defined
19:37:31 <Cale> I was wondering where you found that uniqueSortOn thing -- is it the sort package on Hackage?
19:38:17 --- mode: glguy set -v badzergling
19:38:47 <Average-user> http://hackage.haskell.org/package/sort-1.0.0.0/docs/Data-Sort.html
19:38:57 <Average-user> Data.Sort
19:39:01 <Cale> Those monoidSort operations are pretty weird. I wonder when you'd actually want that.
19:39:16 <Average-user> Yeah, Thought something similar 
19:40:08 <Average-user> And if you look at the implementation of uniqueSortOn, is not that trivial either
19:40:14 <Cale> They're strange because of how they aggregate duplicates according to the original list -- but what if your list already also contains some power of the element? It seems unlikely to me that you would want some half-measure like that.
19:40:51 <Average-user> ¯\_(ツ)_/¯
19:41:12 <Cale> Like, if your list is [a, a, a <> a] then there will be a duplicate after the operation...
19:41:50 <Average-user> Maybe is for when you know more or less of what is your list composed
19:41:55 <Average-user> don't know though
19:43:21 <Average-user> At the end my deffinition of uniqueSortOn turned out to be a little faster than the one in Data.Sort, at least for my purposes
19:55:22 <cobax> Cale: thank you
20:01:47 * hackage hfmt 0.2.3.0 - Haskell source code formatter  http://hackage.haskell.org/package/hfmt-0.2.3.0 (danielstiner)
20:05:33 <Average-user> Is there something like Traversable t => (a -> b -> c) -> t a -> t b -> t c  ?
20:13:08 <Average-user> Or like this (Functor f, Functor f1) => forall f f1 . (a -> b -> c) -> f a -> f1 b -> f c
20:14:15 <monochrom> Applicative
20:14:22 <monochrom> Look for liftA3.
20:16:57 <Average-user> But isn't it possible with different types with applicative instance?
20:17:18 <Average-user> liftA2 :: (a -> b -> c) -> f a -> f b -> f c
20:18:00 <Average-user> I want that, with f a being different applicative than f b
20:18:13 <monochrom> I don't understand the question.
20:19:02 <MarcelineVQ> you want   liftA2 :: (a -> b -> c) -> f a -> g b -> f c ?
20:19:27 <Average-user> Something to "add" two different types with applicative instance, like: f (\a b -> a + b) [as] (Just bs) == [cs] 
20:20:36 <glguy> Applicative is slightly less magical that that suggests
20:20:46 <glguy> Just turn the Maybe Int into a [Int] and then use normal Applicative stuff
20:21:36 <Average-user> Right, but Maybe was just an example
20:21:51 <glguy> Just turn the <Whatever> Int into a [Int] and then use normal Applicative stuff
20:21:57 <Average-user> I want to "add" a list with a Tree, without doing dfs myself
20:22:06 <monochrom> I don't think anyone knows what you have in mind.
20:22:07 <Average-user> But the resulting must be a Tree
20:22:28 <glguy> Yeah, these things all have very well defined behaviors, there's no magical guessing of what it means to mix different types
20:22:33 <benzrf> ^
20:22:41 <benzrf> how can the compiler figure out what you want from it?
20:24:08 <Average-user> as it does with a lot of functions, looking at the context
20:38:47 * hackage hfmt 0.2.3.1 - Haskell source code formatter  http://hackage.haskell.org/package/hfmt-0.2.3.1 (danielstiner)
20:40:27 <geekosaur> conytext isn't magic either. something has to know what to do
20:41:06 <geekosaur> polymorphism works by *removing* possibilities, hopefully leaving behind something simple and obvious
20:48:40 <Average-user> Yeah, I know. But if for example we have an instance with, the function `next` (that I don't know if exist), then we could traverse two different types of that instance
20:48:59 <Average-user> where next would be something like, give me  the next element of this Traversable type
20:49:43 <Average-user> am I explaing my self?
20:51:00 <glguy> You have to answer questions like "how do we define next", "what happens when there are a different number of elements"?
20:51:12 <glguy> and when you answer those questions you'll have the function you wanted
20:51:59 <Average-user> I mean, next would be for just one Traversbale, but the function I wanted could be implementing doing next with both of the Traversables at the same time
20:52:18 <Average-user> But of course, The function next would have to be implemented in Traversable' instance
20:52:52 <Average-user> in lists would be: next (_:y:_) = Just y
20:52:58 <Average-user> and other cases Nothing
20:53:19 <Average-user> But other Types might be trickier to implement
20:53:26 <glguy> It'll be a good exercise to implement the thing you want and see how it works
20:55:14 <Average-user> at the end is like a zipper
20:55:25 <Average-user> but with some arbitrary defined direction to move
20:56:46 <ab9rf> turtle zipper
20:58:19 <ab9rf> the first thought i have is when traversing two trees in parallel is not the same as traversing those two tree's DFS
20:59:26 <ab9rf> or at lest might not be, depending on how you define the parallel traversal
21:02:52 <Average-user> I want to traverse a Tree with a list
21:03:39 <Average-user> In fact what I want is to assign a different number to every node in a tree. A elegant way to do it
21:03:54 <blankhart> has anyone built tensorflow with nix in the last few months?  i am in nix hell trying to build a working environment with all the dependencies
21:08:46 <dminuoso> Average-user: Do you mean something like: Traversable f => [a] -> f b -> f a
21:11:22 <Average-user> yeah
21:11:50 <Average-user> or Traversable f => (a -> b -> c) -> [a] -> f b -> f c
21:13:15 <Average-user> dminuoso: something like a zipWith between traversables, In this case, is not necessary something that general, but I thought something that general was more likely to exist
21:14:23 <dminuoso> Average-user: Well `f :: Traversable f => [a] -> f b -> f [a]` is just traverse in disguise.
21:16:55 <dminuoso> Average-user: I guess you could turn that into: (Foldable f, Traversable t) => t a -> f b -> f a
21:17:56 <dminuoso> Average-user: Or wait let me rephrase that, that doesnt sound right
21:31:30 <greymalkin> Food for thought: tensorflow seems like an obvious candidate for an arrowized syntax. Am I off my rocker here?
21:47:02 <dminuoso> Mmm, it's rather a degenerate case of traverse.
21:47:47 * hackage pointfree-fancy 1.1.1.10 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-fancy-1.1.1.10 (vmchale)
21:49:19 <dminuoso> :t \f xs -> traverse (\s -> do { n <- get; modify (+(1 :: Int)); pure (xs !! n)})
21:49:20 <lambdabot> (MonadState Int f, Traversable t) => p -> [b] -> t a -> f (t b)
21:49:33 <dminuoso> :t \xs -> traverse (\s -> do { n <- get; modify (+(1 :: Int)); pure (xs !! n)})
21:49:35 <lambdabot> (MonadState Int f, Traversable t) => [b] -> t a -> f (t b)
21:53:17 * hackage pointfree-fancy 1.1.1.11 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-fancy-1.1.1.11 (vmchale)
21:54:01 <dminuoso> :t \xs -> fst . (flip runState) 0 . traverse (\s -> do { n <- get; modify (+(1 :: Int)); pure (xs !! n)})
21:54:03 <lambdabot> Traversable t => [b] -> t a -> t b
21:55:53 --- mode: glguy set +v nshepperd1
21:57:03 --- mode: glguy set -v nshepperd1
21:57:28 <nshepperd1> greymalkin: it would be. the built in arrow syntax in ghc is rather impoverished though
21:57:59 <nshepperd1> For the same reason the Arrow class is pretty useless
21:59:54 <nshepperd1> Maybe with a custom quasiquoter or something you could do something nice
22:03:42 <nshepperd1> greymalkin: I have a categorical library for the same kind of stuff as what tensorflow does, that I've been tinkering with
22:04:19 <nshepperd1> It would sure be nicer to use some kind of arrow syntax than to have to write everything pointfree
22:05:25 <dminuoso> :t ((fst . flip runState 0) .) . traverse . const . (get >>=) . (((modify (1 :: Int +) >>) . pure) .) . (!!)
22:05:26 <lambdabot> error:
22:05:26 <lambdabot>     Not in scope: type constructor or class ‘+’
22:05:26 <lambdabot> error:
22:05:43 <dminuoso> Oi! Bug caught in @pl code.
22:08:56 <geekosaur> I don't think @pl understands type ascriptions
22:09:10 <dminuoso> geekosaur: mm it seems so
22:10:56 <nshepperd> what's (1 :: Int +) supposed to be
22:11:42 <geekosaur> it was originally a parenthesized (1 :: Int). @pl doesn't know about :: and treated it as an operator with default precedence, I think
22:11:45 <MarcelineVQ> (1 :: Int +) I'm guessing, thogh that's not valid with parens either
22:11:57 <nshepperd> oh, it's @pl foolishly removing parentheses
22:12:26 <MarcelineVQ> Meant to have the type there not the expression <_<
22:12:29 <geekosaur> modify (+(1 :: Int))
22:12:37 <geekosaur> was the original, if I read backscroll right
22:12:42 <dminuoso> Yup
22:12:55 <dminuoso> @pl \xs -> fst . (flip runState) 0 . traverse (\s -> get >>= \n -> modify (+(1 :: Int)) >> pure (xs !! n))
22:12:56 <lambdabot> ((fst . flip runState 0) .) . traverse . const . (get >>=) . (((modify (1 :: Int +) >>) . pure) .) . (!!)
22:25:48 <newsham> > 1
22:25:50 <lambdabot>  1
22:30:53 <cocreature> :t \xs -> fst . (flip runState) xs . traverse (\s -> get >>= \(x:xs) -> put xs *> pure x)
22:30:54 <lambdabot> Traversable t => [b] -> t a -> t b
22:31:04 <cocreature> dminuoso: no need for (!!) :)
22:31:37 <dminuoso> cocreature: That's interesting
22:31:45 <cocreature> it’s even shorter :)
22:31:53 <dminuoso> cocreature: It's not the size, it's the style.
22:32:01 <dminuoso> I like the fact it doesnt carry around an index.
22:32:17 <cocreature> right, it’s shorter, faster and imho easier to read :)
22:32:23 <dminuoso> Pretty nifty :)
22:32:38 <cocreature> you could also argue that it makes the partiality more explicit
22:34:37 <dminuoso> My mind is still infested with imperative thinking :)
22:37:18 <cocreature> :t set (partsOf traverse)
22:37:19 <lambdabot> Traversable t => [b] -> t b -> t b
22:37:34 <cocreature> meh :(
22:38:57 <nshepperd> :t partsof
22:38:58 <lambdabot> error:
22:38:58 <lambdabot>     • Variable not in scope: partsof
22:38:58 <lambdabot>     • Perhaps you meant one of these:
22:39:02 <nshepperd> :t partsOf
22:39:03 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
22:39:22 <cocreature> hm, is it not possible to write this for type-changing Traversals? I feel like that should work
22:39:23 * dminuoso sighs - re-configuring with --prefix and then having to *completely* rebuild GHC from stage 1...
22:39:26 <nshepperd> interesting, I wonder why it requires the type to be the same
22:39:56 <nshepperd> ah
22:40:04 <nshepperd> :t set (unsafePartsOf traverse)
22:40:05 <lambdabot> Traversable t => [b] -> t a -> t b
22:40:33 <glguy> the "safer" one requires them to be the same so that if the list is too short the previous values will stand
22:40:40 <cocreature> ah I see
22:40:42 <cocreature> makes sense
22:45:47 * hackage shift 0.2.1.0 - A tool to quickly switch between directories  http://hackage.haskell.org/package/shift-0.2.1.0 (vmchale)
22:48:24 <halogenandtoast> I'm not sure why, but for some reason my typing mode keeps switching from right to left, instead of left to right, any ideas what might cause that to happen?
22:49:36 <cocreature> halogenandtoast: at the very least you are going to have to tell us which editor you are using but it also seems like you might have more luck asking that question in the support channels for that editor than here :)
22:50:12 <halogenandtoast> cocreature: lol I opened the channel and somehow ended up here (probably automatic connect from irssi)
22:50:15 <halogenandtoast> I did not mean to ask here
22:50:40 <halogenandtoast> Thanks though!
22:55:49 <MarcelineVQ> :t (snd .) . mapAccumL (((swap . fromJust . uncons) .) . const)  --  <_<
22:55:50 <lambdabot> Traversable t => [c] -> t a -> t c
22:55:57 <dminuoso> :T mapAccumL
22:56:00 <dminuoso> :t mapAccumL
22:56:01 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
22:56:26 <MarcelineVQ> state but without saying the word
22:56:50 <dminuoso> Ah yeah
22:57:18 <dminuoso> MarcelineVQ: that pointfree notation of (((swap . fromJust . uncons) .) . const) is just annoying to look at :P
22:58:14 <MarcelineVQ> Some of the most beautiful things possible are only beautiful because of their scars.
22:58:15 <cocreature> if you have to ask @pl for the pointfree notation, chances are pretty high that it’s going to be annoying to look at :)
22:58:24 <dminuoso> cocreature: Heh.
22:58:28 <MarcelineVQ> hey now I wrote that without pl :>
22:58:55 <cocreature> MarcelineVQ: you really do like pain, don’t you? :)
22:59:12 <gregberns> The last couple days I removed all of haskell and stack and reinstalled 8.2.1 with cabal 2.0.0.0. Now I seem to be having a whole bunch of cabal issues. The main one is the following. If I go and manually add the file (`echo "" >> <log location>) and rerun, it will fail again but for another package.
22:59:13 <gregberns> I'll also see an issue running `cabal update`. Just wondering how there are so many issues. Was it a bad release? Did I do something wrong?
22:59:13 <gregberns> ```
22:59:13 <gregberns> Gregs-MacBook-Pro:js-parser greg$ cabal install --only-dependencies
22:59:13 <gregberns> Warning: --root-cmd is no longer supported, see
22:59:13 <gregberns> https://github.com/haskell/cabal/issues/3353 (if you didn't type --root-cmd,
22:59:13 <gregberns> comment out root-cmd in your ~/.cabal/config file)
22:59:14 <gregberns> Resolving dependencies...
22:59:14 <gregberns> Downloading free-5.1...
22:59:15 <gregberns> Downloading parsers-0.12.9...
22:59:15 <gregberns> Failed to install free-5.1
22:59:16 <gregberns> Failed to install parsers-0.12.9
22:59:23 <dminuoso> gregberns: Use gist perhaps? :-)
22:59:32 <dminuoso> gregberns: Or some other pasting service. 
22:59:43 <gregberns> ok
23:00:41 <gregberns> https://gist.github.com/gregberns/e485406541c1c6ea15935fc6c407a958
23:00:49 <cocreature> gregberns: if you want to be cabal, I would highly recommend that you use cabal 2.2 and new-build
23:01:06 <glguy> gregberns: What's your question about that output?
23:02:21 <gregberns> glguy: It fails to install the packages, I dont understand whywriting to the log would fail
23:04:15 <gregberns> cococreature: ok I'll give it a shot. So I tried to do cabal update and that failed miserably, is there a manual way to install? I'll check out the site again to see if I can find better instructions
23:05:37 <glguy> gregberns: Did editing your .cabal/config fix it?
23:05:57 <glguy> Oh, I guess that's just not related :)
23:06:19 <gregberns> is there something specific I should change?
23:06:31 <glguy> The error message suggested changing it
23:06:54 <glguy> but it's probably just ignoring that, not causing the failure
23:07:44 <glguy> If you got an error message from update that might be good to add to the paste. If you're not using the latest version you could download a new executable: https://www.haskell.org/cabal/download.html
23:09:03 <maqbool> I  found really weird issue when i load a module  into ghci fucntions inside the module  executes really fast.  While i define the function inside the ghci itself it doesn't execute fast block further input to the ghci? https://paste.gnome.org/pxknabqup 
23:09:40 <glguy> maqbool: lines 4, 5, and 7 each defined a different function
23:09:51 <glguy> lines 5 and 7 overwrote the previous definition of factorial
23:10:55 <gregberns> glguy: changing the config didnt help, I'll try the newer version
23:10:56 <glguy> You can use :{ and :} to do multi-line input, but it's better to define your functions in a file and load that file into GHCi
23:11:23 <glguy> or you can input the whole definition on one line with each clause separated by a ;
23:11:32 <glguy> factorial 0 = 1; factorial 1 = 1; ....
23:12:32 <maqbool> glguy: silly me thanks :)
23:22:28 <gregberns> cocreature: I downloaded the new cabal executable, ran it and ran into the same issue I ran into earlier today
23:22:28 <gregberns> https://gist.github.com/gregberns/e485406541c1c6ea15935fc6c407a958#file-cabal-2-2-0-0-fails
23:24:09 <glguy> Do you own all the files in your ~/.cabal ?
23:24:14 <gregberns> do I need to move the executable somewhere in particular? I ran down a rabbit hole of github issues and couldn't figure it out
23:24:27 <gregberns> I should
23:24:39 <glguy> You could chown -R greg .cabal
23:25:00 <glguy> The permission errors suggest you don't have ownership of some things
23:25:13 <glguy> Also what happens if you run cabal update?
23:25:20 <cocreature> what happens if you run "ghc-pkg check" as suggested?
23:25:58 <cocreature> ah you’re trying to install this globally. maybe use a sandbox instead
23:26:15 <gregberns> oh... "Operation not permitted", how do I fix that?
23:26:16 <cocreature> you can place the binary anywhere you want
23:26:19 <cocreature> just put it in the path
23:26:30 <gregberns> thats what I figured
23:26:51 <dminuoso> cocreature: https://gist.github.com/dminuoso/515016504a6462107f097e2865369487 =)
23:27:25 <dminuoso> Not quite sure about the name "bind-patterns" since it also applies to pattern synonyms and list comprehensions..
23:27:49 <cocreature> dminuoso: nice!
23:28:57 <cocreature> dminuoso: hm, pattern synonyms? do you have an example of that?
23:29:15 <glguy> gregberns: when did you get operation not permitted? If it was during chown you'll need to use sudo
23:29:25 <cocreature> obviously the right name is -Wincomplete-<--patterns
23:29:43 <dminuoso> 😂
23:30:05 <cocreature> or -Wincomplete-←-patterns for our unicode-loving friends
23:30:16 <glguy> Pattern guards?
23:34:15 <dminuoso> glguy: oh you are right
23:34:25 <gregberns> cocreature:  I ran 'ghc-pkg check', I'm not sure what thats supposed to do though
23:34:25 <gregberns> glguy: I ran `sudo chown -R greg .cabal`, then ran the cabal command as sudo with the same result. And `cabal update` is working.
23:40:54 <gregberns> cocreature: I did just create a sandbox in one of my projects and ran the `sudo ../../downloads/cabal install Cabal cabal-install` successfully, so thats very interestin
23:41:21 <cocreature> installing things globally tends to result in a mess
23:41:32 <glguy> The fact that it gets further when you use sudo is weird to me; you shouldn't need to use sudo with cabal at all
23:41:46 <gregberns> how do I get cabal to  be globaly 2.2?
23:42:10 <erikd> people should be actively discouraged from using cabal with sudo
23:42:12 <gregberns> glguy: thats kinda what I thought
23:43:31 <cocreature> gregberns: you can just copy the executable somewhere.
23:45:47 * hackage text-builder 0.5.4.1 - An efficient strict text builder  http://hackage.haskell.org/package/text-builder-0.5.4.1 (NikitaVolkov)
23:55:59 <gregberns> cocreature glguy: So running without sudo, installing a package in a sandbox results in this
23:55:59 <gregberns> https://gist.github.com/gregberns/e485406541c1c6ea15935fc6c407a958#file-cabal-install-megaparsec
23:56:54 <gregberns> just so confused...
23:57:15 <cocreature> maybe try passing -v3 to cabal or something like that
23:57:19 <cocreature> something is really weird in your setup
