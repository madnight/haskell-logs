00:09:50 <ab9rf> i have a proper keyboard again :)
00:17:52 <ThomasLocke> Any Slackware 14.2 users here who've managed to get stack 1.9.1 to work? 1.6.5 works a charm, but 1.9.1 fails with "I don't know how to install GHC on your system configuration, please install manually"
00:17:56 <ThomasLocke> Quite annoying
00:19:07 <pikpuk> https://stackoverflow.com/questions/52887011/how-to-include-the-xxx-stub-h-file-generated-from-a-haskell-source-file-when-b
00:19:37 <pikpuk> Can anyone kindly answer this question?
00:21:18 <pikpuk> A question about building process with Stack of a project with "main.c" which needs to include a "lib_stub.h" file.
00:40:27 <ar1a> are there any other languages with applicatives/monads used lots?
00:40:44 <cocreature> √º
00:40:47 <cocreature> ups sry
00:40:58 <cocreature> ar1a: Haskell-inspired languages like idris or agda
00:41:19 <ar1a> any common ones?
00:42:32 <TMA> ar1a: there is no perceived need (necessity) for these in the common languages
00:43:14 <cocreature> there are monadic APIs in some languages but there‚Äôs no Monad abstraction in most languages
00:44:12 <ggole> If you don't have the right type machinery it's pretty painful
00:44:25 <dminuoso> And the right amount of combinators.
00:44:41 <dminuoso> ar1a: Your question is kind of like: are there other languages where monoid is used
00:45:17 <dminuoso> while lists form a monoid under list concatenation, very few languages actually abstract over the pattern monoid
00:46:06 <Ariakenom> but monad has more stuff so it accidently fits less things
00:47:00 <Ariakenom> so mentioning async .andThen interfaces makes sense
00:47:31 <Ariakenom> also makes sense because it's been developed with someone at some stage thinking about it monadically
00:57:42 <Ariakenom> I've heard list comprehension in ex Python originally came from Haskell. True?
00:58:11 <dminuoso> Im just trying to point out the difference between "monadic code" and "having Monad as a first-class pattern"
01:00:01 <ventonegro> What is the criteria used to identify monadic code in other languages? Any time functions that return values with extra "contexts" are chained together?
01:00:03 <Ariakenom> Indeed. I was just saying it's not as easy to stumble into a monadic interface as a monoidal
01:01:33 <dminuoso> Ariakenom: Well I consider the `;` and `=` (assignment) to be monadic too. ;)
01:01:57 <dminuoso> and a function call is just >> ;p
01:02:10 <cocreature> and if you can‚Äôt come up with a useful way of interpreting something as monadic, you can always view it through Identity
01:02:20 <dminuoso> haha =)
01:02:24 <Ariakenom> Right. That analysis is older than monads in Haskell iirc
01:03:12 <Ariakenom> the one publication of monads in CS before Haskell iirc :p
01:04:22 <ggole> Or Cont
01:04:40 <ggole> Recapitulating Landin's treatment of Algol
01:10:55 <dminuoso> Ariakenom: JavaScript's promise (async/await is like do-notation) was the first monad instance I pretty much grasped. It took a while to truly understand why it was not so monadic though.
01:45:11 <asheshambasta> Hi guys, I need some advice (again) :-) Is it advisable to stack StateT + ExceptT over STM instead of IO? 
01:45:49 <asheshambasta> Also, if one needs to do some IO operation within STM, is it at all possible? I'm looking at things like HTTP requests, for example.
01:46:27 <asheshambasta> (caveat: as my questions probably show, I'm new to using STM in Haskell.)
01:48:05 <cocreature> asheshambasta: how do you expect to roll back an http request?
01:48:54 <cocreature> usually you use STM locally for relatively small operations which you want to happen transactionally
01:49:54 <cocreature> there is no way you can get transactional properties for arbitrary IO actions
01:50:35 <cocreature> there is unsafeIOToSTM but as the same suggests it‚Äôs not safe :)
01:50:41 <Ariakenom> You can put IO into a STM channel and have someone execute it after the transaction is finished
01:50:42 <cocreature> read the docs for more details
01:50:56 <kuribas> asheshambasta: the parallel and concurrent programming book is great for learning about concurrency and paralellism.
01:51:05 <kuribas> asheshambasta: I can lend it to you if you like.
01:51:11 <asheshambasta> cocreature: yeah, so my use case is writing to a hashmap within a StateT, so you'd keep the monad stack over IO and only use STM at the corner where you're inserting things into the state hashmap correct?
01:51:25 <ski> @where PCPH
01:51:25 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>,<https://web.archive.
01:51:25 <lambdabot> org/web/20180117194842/http://chimera.labs.oreilly.com/books/1230000000929>
01:51:40 <dminuoso> 10:47      cocreature | asheshambasta: how do you expect to roll back an http request?
01:51:41 <cocreature> asheshambasta: if you are keeping a hashmap in StateT I don‚Äôt see where STM comes into play at all?
01:51:58 <dminuoso> cocreature: Actually, if you consider the saga pattern - something like STM might be connectable with IO.
01:52:11 <dminuoso> It's something Ive been meaning to try in Haskell.
01:52:33 <cocreature> I don‚Äôt know what that is but I highly doubt it allows you to rollback arbitrary IO actions :)
01:52:58 <dminuoso> cocreature: Not arbitrary actions. It's basically a solution to gain distributed long-time transactions.
01:53:12 <dminuoso> But it requires describing how to undo an action that you can do.
01:53:36 <kuribas> asheshambasta: did you consider MVars?
01:55:01 <asheshambasta> cocreature: my confusion stems from a mapM within the monad stack, the mapM applies a function that modifies the state within the stack, and my understanding is that it does so concurrently. 
01:55:25 <asheshambasta> I'd like to be able to "detect" and avoid key conflicts
01:55:31 <asheshambasta> kuribas: no, not yet
01:55:33 <cocreature> asheshambasta: mapM for IO definitely will not modify things concurrently
01:55:56 <asheshambasta> so it iterates sequentially?
01:55:58 <cocreature> yes
01:56:05 <dminuoso> :t (>>=)
01:56:06 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:56:19 <cocreature> maybe you are looking for mapConcurrently
01:56:57 <cocreature> but that won‚Äôt work if you use "StateT s IO" for a good reason. StateT is never concurrent since it‚Äôs just parameter passing 
01:57:01 <asheshambasta> cocreature: what could be a concurrent alternative? Ideally, each "iteration" will only write a unique key to the state's map; but I just want to implement something safe for "when"
01:57:28 <cocreature> it sounds like maybe you want to throw away StateT, store your state in a TVar and then use mapConcurrently
01:57:44 <asheshambasta> cocreature: I see, interesting, and it makes sense for it not to be concurrent since the whole idea is to use the output state of one op. as the input state of the following.
01:57:59 <asheshambasta> (please correct me if my assumptions/understanding is incorrect)
01:58:46 <cocreature> that‚Äôs also why I pretty much never use StateT on top of IO. eventually, I find myself wanting to modify my state concurrently and at that case StateT is useless
02:00:25 <asheshambasta> cocreature: whats the alternative then? 
02:00:46 <cocreature> I already gave you the alternative: store the state in a TVar
02:00:55 <asheshambasta> performance wise, its important for me to have this mapM be concurrent, since the number of operations are potentially going to be large.
02:01:46 <asheshambasta> cocreature: okay, I see
02:04:00 <kuribas> cocreature: why not MVar?
02:05:17 <Ariakenom> kuribas: why not TVar?
02:05:17 <cocreature> because a) it probably doesn‚Äôt make sense semantically for your state to not be present and b) the TVar makes it easier to get transactional properties once you add more than one
02:05:39 <kuribas> Ariakenom: more expensive and not fair.
02:05:41 <cocreature> if you‚Äôre worried about performance, IORef + atomicModifyIORef is probably a better choice than either TVar or MVar
02:06:18 --- mode: glguy set +v muzzle
02:06:22 <cocreature> but usually I wouldn‚Äôt expect this to be my bottleneck
02:06:40 <muzzle> is there a way to put multiple pages into a pdf with the Chart using the Cairo backend?
02:06:52 <muzzle> I already googled but couldn't find anything?
02:07:04 <muzzle> i.e. multiple plots in a single pdf file?
02:10:05 <asheshambasta> cocreature: and once again, thanks for your (always) helpful suggestions!
03:06:14 --- mode: glguy set +v Guest56
03:22:43 <delYsid> Hmm, "stack new blog hakyll-template" is broken with stack 1.9.1.  It generates a {{name}}.cabal
03:25:07 <asheshambasta> cocreature: just one addition: in my case I'd like to be able to insert keys and values into a hashtable. If this hashtable is inside a tvar, that would mean that non-conflicting keys cannot be inserted "concurrently", is that assumption correct?
03:25:37 <asheshambasta> I'm considering also to use something like stm-containers, which seems to resolve these at the key level instead of the level of the entire hashtable.
03:43:01 <cocreature> asheshambasta: right
03:43:31 <cocreature> although you probably want to benchmark whether stm-containers is actually faster for your usecase
03:44:38 <Athas> Is there a way to disable optimisations for a single module, in order to speed up compilation?
03:59:16 <dminuoso> Athas: Mmm, cant you specify GHC_OPTIONS in a pragma?
04:00:00 <Athas> dminuoso: I tried.  Maybe it worked, but it didn't give the speedup I was looking for.
04:06:38 <dminuoso> "NOTE: the contents of OPTIONS_GHC are appended to the command-line options, so options given in the source file override those given on the command-line.
04:13:49 <noumenon> heh, from a slide on computational quantum chemistry: "A function takes a number and returns another number", and then: "An operator takes a function and returns another function"
04:14:55 <dminuoso> noumenon: Hah fancy. Are these slides available online to look at?
04:15:27 <__monty__> noumenon: That's a common definition of "operator" though. D for derivatives is an operator.
04:15:28 <noumenon> yep; and right under: "A functional takes a function and returns a number"; quite the definitions
04:15:41 <noumenon> yeah, I realize
04:15:41 <noumenon> http://rsc.anu.edu.au/~agilbert/gilbertspace/uploads/Chem3108.pdf
04:15:49 <[exa]> physicists need types.
04:15:53 <Athas> APL calls that an "operator" too, but then also has a non-Haskell definition of "monadic".
04:16:10 <Athas> Learning APL is a good way to encounter some weird nomenclature.
04:16:22 <Athas> And since APL was first, I guess they have dibs!
04:18:02 <__monty__> Wait, isn't that the commonplace math usage too? Monadic vs variadic, diadic, etc.?
04:55:34 <olligobber> > 0**0
04:55:36 <lambdabot>  1.0
04:55:44 <olligobber> this makes me unhappy
04:56:09 <Ariakenom> % 0^0
04:56:09 <yahb> Ariakenom: 1
04:56:27 <Ariakenom> % 0 ^^ 0
04:56:27 <yahb> Ariakenom: 1.0
04:57:56 <hpc> that happens in python, ruby, and javascript too
04:57:56 <Ariakenom> lim x**x = 1; lim 0**x = 0;
04:58:00 <hpc> i think it's specified by IEEE?
04:58:07 <olligobber> probably
04:58:13 <olligobber> still makes me unhappy
04:58:16 <hpc> yeah
04:58:24 <lieven> olligobber: why?
04:58:28 <hpc> it should be NaN
04:59:02 <hpc> all of the "you can't do this with real reals" operations produce an infinity or a nan
04:59:06 <hpc> except for this one
04:59:14 <olligobber> lieven, because the limit as (x,y) approaches (0,0) of x^y is path dependent
04:59:44 <lieven> A^B is the size of the set of functions from B to A
04:59:45 <Ariakenom> hpc: I doubt that claim
05:00:07 <olligobber> lieven, that's true if A is an integer, but ** is for floats
05:00:44 <olligobber> I'm ok with 0^0 being 1, but 0**0 is different
05:01:31 <hpc> i would rather have 0^0 be bottom
05:01:42 <Ariakenom> where nan is bottom?
05:01:58 <hpc> > 0 `div` 0
05:02:00 <lambdabot>  *Exception: divide by zero
05:02:08 <olligobber> isn't bottom a type rather than a value?
05:02:34 <hpc> what people casually call the "bottom type" is Void, which is the empty type
05:02:40 <hpc> in haskell it only contains bottom
05:02:51 <hpc> bottom is at the value level
05:03:11 <hpc> or i guess you could maybe use 'undefined at the type level?
05:04:40 <hpc> ah, i guess it's actually called that in type theory
05:04:52 <Ariakenom> I feel like the purpose of nan is to be bottom anyway. Even though it doesn't always do a great job of it.
05:05:18 <dminuoso> Ariakenom: but its not
05:05:27 <dminuoso> Ariakenom: the existence of isNaN defies that notion
05:06:03 <Ariakenom> yes
05:06:06 <hpc> it's as close to bottom as you can get in the language IEEE floats were defined in terms of
05:06:16 <Ariakenom> isNaN :: Double -> IO Bool
05:06:16 <hpc> which is processor IO bits
05:07:07 <hpc> and it was probably just easier than having the processor fault
05:07:33 <dminuoso> hpc: I actually would love to have RTS support for IEEE exceptions.
05:07:53 <dminuoso> NaN can be incredibly frustrating to work with
05:08:14 <dminuoso> but as merijn said: "Go make it happen" heh
05:08:22 <hpc> just use Rational :P
05:08:39 <Ariakenom> I did wrap Double with some new Eq, Ord instances once
05:08:51 --- mode: glguy set +v _gio
05:08:54 <Ariakenom> and new isNaN too
05:08:56 <dminuoso> Ariakenom: did you employ some delta logic
05:09:07 <Ariakenom> I threw exceptions :p
05:09:11 <dminuoso> Ah
05:14:29 <noumenon> what's the difference between lambdabot and yahb?
05:14:37 <noumenon> > 1 + 1
05:14:39 <lambdabot>  2
05:14:43 <noumenon> % 1 + 1
05:14:43 <yahb> noumenon: 2
05:14:49 <Ariakenom> noumenon: yahb is just ghci
05:14:52 <cocreature> noumenon: yahb is just a sandboxed ghci instance
05:14:55 <Ariakenom> lambdabot is custom
05:15:01 <noumenon> yahb has the common courtesy of addressing me by name
05:15:28 <Ariakenom> % x = 1
05:15:28 <yahb> Ariakenom: 
05:15:31 <Ariakenom> > x = 1
05:15:33 <lambdabot>  <hint>:1:3: error:
05:15:34 <lambdabot>      parse error on input ‚Äò=‚Äô
05:15:34 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
05:15:37 <Ariakenom> % x
05:15:37 <yahb> Ariakenom: 1
05:16:53 <Ariakenom> > putStrLn "hi"
05:16:55 <lambdabot>  <IO ()>
05:17:00 <Ariakenom> % putStrLn "hi"
05:17:00 <yahb> Ariakenom: hi
05:17:38 <jebes> is yesod the "standard" for web or should i consider snapp/happstack still? I need more than what scotty and the other microframeworks are offering.
05:20:24 <dminuoso> jebes: What do you need more?
05:22:06 <jebes> dminuoso: the libraries that come with a full framework, like session management, user registration, anti forgery form protections, etc.
05:22:33 <dminuoso> jebes: If you want something *that* complete, then Yesod or snap are your best candidates still.
05:22:44 <jebes> dminuoso: thank you.
05:23:13 <dminuoso> jebes: Keep in mind that building those things into a web application is not that hard. Most of the effort will be spend in other things.
05:26:01 <jebes> that is true, and i've done it before...
05:34:10 <Spaceman77> how many of you use haskell professionally?
05:36:17 <raichoo> Spaceman77: I do. Why?
05:37:40 <Spaceman77> Just wondering what kind of stuff is done with it :)
05:38:11 <julianleviston> https://wiki.haskell.org/Haskell_in_industry
05:38:17 <raichoo> Spaceman77: It's a general purpose programming language, so you can do pretty much everything with it. ;)
05:38:51 * Ariakenom looks to the avr8 embedded cpu next him with sad eyes
05:39:04 <raichoo> Whether or not it's suited for your use case is a different story.
05:40:24 <Spaceman77> I'm having a hard time deciding what language to learn. They all seem so interesting.
05:40:34 <Spaceman77> It's like min-maxing in video games
05:40:36 <julianleviston> I had to write some pretty complicated elixir at work a month or so ago, and I ended up writing it in Haskell first beacuse it was *much* easier. Haskell is so much smaller, simpler and easier to understand because of the types, purity and the fact that it‚Äôs less noisy than other languages.
05:41:19 <Ariakenom> % :t maxBound - 1
05:41:19 <yahb> Ariakenom: (Num a, Bounded a) => a
05:41:28 <Ariakenom> % maxBound - 1 :: Word8
05:41:28 <yahb> Ariakenom: 254
05:41:30 <cocreature> Spaceman77: learn a few that are radically different
05:41:31 <Ariakenom> % maxBound - 1 :: Int8
05:41:31 <yahb> Ariakenom: 126
05:41:36 <jebes> Spaceman77: just learn them all. The differnce between elixir and ruby isn't that big. The differnce between haskell and J... well...
05:41:41 <Ariakenom> polymorphism woo
05:42:04 <Spaceman77> well, currently i am torn between haskell, elixir(phoenix for web stuff), clojure and rust
05:42:04 <Ariakenom> % maxBound - 1 :: Int64
05:42:04 <yahb> Ariakenom: 9223372036854775806
05:42:25 <Putonlalla> You should start with Coq, because then everything else will seem easy, Spaceman77.
05:42:35 <julianleviston> lol. terrible advice :)
05:42:45 <Spaceman77> I do mostly OOP in my day job
05:42:52 <Putonlalla> Even more so, then.
05:42:54 <jebes> Putonlalla: Hahaha. Why not Idris ;)
05:42:57 <Athas> Coq is too easy; to straight to Twelf.
05:43:16 <julianleviston> I do JS in my dayjob Spaceman. :)
05:43:19 --- mode: glguy set +v Lowl3v3l1
05:43:24 <Spaceman77> Haskells type system is simply beautiful
05:43:29 <Spaceman77> Clojure is a LISP
05:43:34 <julianleviston> you might like purescript Spaceman
05:43:41 <Lowl3v3l1> if you already got a PhD in maths coq is absolutely straight forwards i suppose :D
05:43:43 <julianleviston> it‚Äôs essentially Haskell that builds Javascript.
05:43:45 <Spaceman77> Rust looks like a child of C and haskell, i prefer more performant languages
05:43:50 <jebes> Spaceman77: not to be pedantic, but clojure isn't really a lisp
05:44:04 <julianleviston> it‚Äôs a scheme ;-)
05:44:13 <julianleviston> but isn‚Äôt scheme a lisp? :shrug: 
05:44:14 <Spaceman77> and elixir/phoenix seems very practical for web, which i tend to do :)
05:44:15 <jebes> Its a bastardized one, but hey, its used
05:44:33 <Athas> jebes: why isn't Clojure a Lisp?
05:44:43 <julianleviston> is it because of the lack of TCO on the JVM?
05:45:06 <raichoo> Spaceman77: Haskell has performend very well for most of our applications. Sure there might be things that are a bit faster but I didn't come across a case where it was relevant for us.
05:45:33 <jebes> Athas: If you *really* want to start that: the lack of TCO is an element, but the tight integration with the JVM defeats a lot of the freedom lisp is supposed to espouse. The macros in clojure are finicky if not borderline broken, the syntax is questionable, and a lot seems restrictive to be really a part of lisp philosophically
05:45:42 <jebes> its like saying the JVM is FORTH. It just ain't
05:45:48 <cocreature> Spaceman77: Haskell is a pretty good language for writing web backends if that‚Äôs what you‚Äôre interested in
05:46:03 <raichoo> Spaceman77: What cocreature says.
05:46:11 <Spaceman77> cocreature: thats onw thing that interests me
05:46:12 <Athas> jebes: those restrictions seem like the old LISPs of the 70s.
05:46:18 <Lowl3v3l1> jebes: uhm some perceived "ideal" is a terrible reason for ordering languages.
05:46:30 <Spaceman77> second is performant AI sutff/algorithms for robotics
05:46:31 <Athas> They also did not have TCO, were heavily tied to specific machines, and had various questionable parts (like octal numbers by default).
05:46:35 <jebes> Lowl3vel1: welcome to Lisp ;) We're stuck in the 70's till
05:46:43 <Lowl3v3l1> jebes: and there's even lisps that have neither TCO nor macros ;)
05:46:51 <jebes> Those are 100% not lisp
05:46:59 <jebes> well, unless they have f-expr's
05:47:11 <jebes> tco isn't a hard constraint, macros and F R E E D O M are
05:47:27 <Spaceman77> Too bad i didn't start learning haskell earlier though, i am competing in a competition today :)
05:47:44 <Putonlalla> The second best time to start is now.
05:47:54 <jebes> I love going into hackathons and pulling out J. It garuntees no one works with you :)
05:48:02 <Athas> Pretty sure LISP 1.5 didn't have macros.
05:48:17 <Peter_Storm_> Learning haskell has been a lifechanger to me
05:48:18 <jebes> LISP 1.5 had f-expr's iirc
05:48:31 <Lowl3v3l1> Athas: and no TCO either ( in fact even common lisp has no TCO  in the specification)
05:48:38 <Peter_Storm_> I started with JS, then started implementing functional concepts in JS
05:48:43 <Athas> Looking at the MACLISP docs, it seemed like it only had reader macros(!).
05:48:54 <Peter_Storm_> And then just though, why not just go straight to the source, and Haskell is really really fun to learn and write
05:48:57 <Spaceman77> Also reading SICP is in my todo list
05:48:58 <Athas> Ah, no, MACLISP had macros.
05:49:05 <jebes> Athas: i was about to say...
05:49:26 <Lowl3v3l1> Spaceman77: it's like TAOCP. You absolutely should
05:49:28 <jebes> Macros are kinda the bread and butter of lisp. I'm undecided on how useful they actually are
05:49:49 <jebes> Laziness seems a better answer in a lot of cases...
05:50:36 <Lowl3v3l1> jebes both are not exclusive though. I used to teach university courses and i tended to play "let's reinvent features" with the students a lot
05:51:08 <jebes> lowl3v3l1: absolutely. Macros can do things laziness can't, you can implement laziness in macros if you hate yourself enough.
05:52:01 <Athas> You also need side-effects to implement laziness.
05:52:16 <jebes> has any other editors gotten haskell support? I'm still stuck in my glorious OS
05:52:18 <Lowl3v3l1> jebes: implementing basic laziness is actually not that hard. Though i am not sure wether you could do it with common lisp macros, scheme works a lot different.
05:52:21 <jebes> OS of emacs
05:52:31 <Athas> Why leave Emacs?
05:52:32 <Lowl3v3l1> jebes: why would you need anything else? xD
05:52:51 <jebes> Athas: just curious what other people use. I ain't leavin this beatiful church i've built.
05:53:26 <julianleviston> I just use the REPL lol
05:53:35 <julianleviston> GHCi all the way, baby :)
05:54:04 <julianleviston> I suppose I should use that new thing all the cool kids are using‚Ä¶ 
05:55:44 <julianleviston> https://github.com/rainbyte/haskell-ide-chart
05:56:42 <jebes> julianleviston: that chart is inaccurate
05:56:47 <jebes> should include ed with only rocket ships
05:56:55 <julianleviston> I didn‚Äôt write it.
05:56:58 <Spaceman77> ed is the standard editor
05:57:00 <julianleviston> I was just linking coz you asked :)
05:58:43 <jebes> anyone use nixos in prod? Or is there another irc to ask that on?
05:59:05 <hc> there is a dutch startup that's using it in production
06:00:20 <cocreature> jebes: there is #nixos :)
06:02:26 <exarkun1> I am about to use it in prod and I am also in #nixos
06:03:08 <exarkun1> Following the servant docs I get https://gist.github.com/exarkun/27a0af2a253aa64840232863ebd8c05f and this is not an error I have learned how to read yet
06:03:44 <cocreature> exarkun1: that looks like you‚Äôve applied liftIO at some point
06:04:14 <cocreature> in particular, you are not in Handler but in IO
06:04:25 <exarkun1> cocreature (IRC): Interesting!  I'm not sure if I would have guessed that in a million years.
06:04:32 <exarkun1> cocreature (IRC): How do you figure that?
06:04:47 <exarkun1> (You're entirely correct, fwiw.)(
06:05:06 <cocreature> exarkun1: ‚Äúarising from a functional dependency between: constraint ‚ÄòControl.Monad.Error.Class.MonadError ServantErr IO‚Äô‚Äù
06:05:37 <cocreature> the MonadError instance for IO (which imho should just not exist but that‚Äôs a separate debate) lets you throw IOException not ServantErr
06:05:39 <Peter_Storm_> How would I know something has a right or left adjoint in Haskell? If that is something I can ask here :D
06:08:19 <exarkun1> cocreature (IRC): Okay, that seems like something I might eventually understand.  Thanks.
06:17:15 <Spaceman77> regarding haskell for web dev, i've heard of haskell being "leaky"
06:17:31 <Spaceman77> as in, it tends to leak memory
06:17:37 <Spaceman77> Why is this?
06:17:49 <cocreature> it leaks memory if you have a bug in your application, not because you used Haskell
06:18:08 <Spaceman77> Ah, alright
06:19:27 <Putonlalla> They're not usually leaks in the sense of being unrecoverable.
06:23:11 <__monty__> exarkun1: What's this (IRC) thing about? Is this another matrix thing?
06:23:32 <mizu_no_oto> Spaceman77: Haskell leaks in the same way that Java leaks - you might hold onto garbage longer than you intended to, because the lifetime is longer than you expected.
06:25:42 <mizu_no_oto> One particular additional wrinkle in Haskell is that it's lazy, so one cause of leaks that you don't see in strict languages is one where you create a lot of unevaluated thunks before forcing them.
06:26:38 <ggVGc> and then blow up way later and it's hard to tell what the original reason was
06:27:37 <ggVGc> I'm still not sold on haskell being lazy by default, even though that is the main feature of the language
06:27:53 <ggVGc> In many ways I prefer purescript over haskell
06:28:25 <Spaceman77> What if there was a single language, with an option to have it compiled, interpreted, whichever is necessary
06:28:40 <ggVGc> it's called C
06:28:43 <Spaceman77> that can be configured in a meta-meta way
06:28:50 <ggVGc> it's called C
06:29:17 <Spaceman77> Static or dynamic, whichever is necessary
06:29:21 <ggVGc> it's called C
06:29:47 <ggVGc> Spaceman77: also you can do that in Haskell
06:29:50 <ggVGc> there's a Dynamic type
06:29:53 <Spaceman77> Welp
06:30:15 <Spaceman77> Does C support algebraic data types? higher order functions?
06:30:21 <exarkun1> __monty__ (IRC): Yes, apparently.  Last straw.  I am working on escaping from matrix now.
06:30:26 <ggVGc> Spaceman77: you didn't mention that
06:30:54 <Spaceman77> a single joint effort at programming as a whole
06:30:59 <exarkun1> __monty__ (IRC): It's probably a bug.  It seems to be intermittent, either across time or across users.
06:31:02 <ggVGc> C can be compile or interpreted, has static typing and void pointers, and can be configured with the C preprocessor
06:31:26 <liste> Spaceman77: check out racket
06:31:27 <exarkun1> Spaceman77 (IRC): Why do you want a monoculture?
06:32:01 <exarkun1> Spaceman77 (IRC): Polycultures are inherently more resistant to failure.
06:32:13 <ggVGc> then why did england brexit
06:32:36 <__monty__> Well they didn't : > They claim they're gonna.
06:33:13 <ggVGc> Spaceman77: would you be willing to use this hypothetical language if 70% of it was against your preferences? Because that's what it'll be
06:33:18 <ggVGc> mostly against everyones preferences
06:33:25 <ggVGc> but partly according to your preferences
06:36:39 <Spaceman77> I guess i dreamed of this hypothetical language because of my own little problem
06:37:02 <Spaceman77> All the languages, their features, their "secret sauce", are so interesting
06:37:11 <Spaceman77> I simply want to learn them all
06:39:26 <jebes> just learn J man
06:39:34 <ggVGc> Spaceman77: sure, everyone would like their favourite language to be able to build any type of program on any platform and that everyone else used the same one
06:39:44 <ggVGc> but that can never be true for more than a handful of people
06:39:58 <Putonlalla> The problem with one language to rule them all is that, if you put all the features of all the languages together, you get the benefits of none of them, Spaceman77.
06:39:59 <ggVGc> so if you're not the dictator of worldwide programming, you have to make a big compromised
06:40:03 <ggVGc> and no one wants to
06:40:12 <ggVGc> also what Putonlalla said
06:40:57 <ggVGc> also, I don't see the problem. just generate every language from haskell?
06:42:01 <mizu_no_oto> Features are often at odds with each other.  For example, if you want to have global type inference, you can't do subtype polymorphism
06:43:02 <jebes> mizu_no_oto: *scala noices*
06:43:12 <Spaceman77> I just looked up J
06:43:17 <Spaceman77> what. the. fuck.
06:43:45 <jebes> don't be hatin'
06:43:48 <__monty__> Isn't Ada this do-everything language?
06:44:51 <hodapp> found the DoD guy
06:44:56 <jebes> __monty__ BEGIN RESPONSE; BEGIN FUNCTION RESPOND; BEGIN BEGIN BEGIN...
06:44:57 * hodapp throws fruit at __monty__
06:45:05 <liste> __monty__: not really, it's quite conservative
06:45:38 <liste> C++ is more flexibl
06:45:44 <liste> flexible*
06:46:14 <Spaceman77> Yeah, i think that C++ is the closest language to this most "flexible" one
06:46:17 <liste> though I guess writing SPARK for C++ would be a nightmare
06:46:18 <mizu_no_oto> There's the notion that 'constraints liberate and liberties constrain' - if you want to say something about a piece of code, the fewer things it's allowed to do the more you can say about what it does.  Liberties let you do more with the current bit of code you
06:46:31 <__monty__> liste: Merely joking, don't really know Ada but it *is* the impression I've gotten from Ada talk titles and people discussing Ada though.
06:48:09 <mizu_no_oto> you're working on, but it constrains what you can say about it in other library code or at a tooling level.
06:48:10 <liste> Ada combines high assurance and general purpose computing though
06:48:53 <mizu_no_oto> jebes: if you notice, Scala doesn't have global inference but a left-to-right flow based inference that craps out exactly when you really want it.
06:49:03 <hodapp> SPARK?
06:49:53 <liste> hodapp: the high assurance companion to Ada
06:50:12 <hodapp> oh, good, not Apache Spark
06:50:37 <liste> that checks proofs you make about your code
07:00:55 <ggVGc> I prefer to not promise anything about my code
07:00:59 <ggVGc> to be on the safe side
07:01:45 <Ariakenom> constraining the promises to liberate the design. wise
07:07:52 <dminuoso> mizu_no_oto: What does "left-to-right flow based inference mean"? 
07:08:03 <dminuoso> mizu_no_oto: Note I do not know any scala, but Im curious at how theirs works.
07:08:55 <mizu_no_oto> It means type information really only flows in one direction: on a line, from left to right, and in a function from top to bottom
07:09:50 <mizu_no_oto> So information from later in a line can't help it infer stuff earlier in the line, and stuff from later in a function can't help it infer stuff earlier in the function
07:10:05 <dminuoso> mizu_no_oto: Ah so basically it consists of just.. [App]?
07:46:53 <ski> Spaceman77 : perhaps add Prolog, Forth, to that list
07:46:55 <ski> Peter_Storm_ : i suppose you make a guess, and then prove it ? or possibly you can sometimes try to derive what it should be, if it exists
07:47:11 <Spaceman77> ski: why so?
07:47:35 <Spaceman77> I have looked into those languages, but they didn't ignite any curiosity in me
07:47:47 <ski> Spaceman77 : because they're different (from what you've probably seen, so far)
07:48:09 <ski> ok
07:48:53 <ski> so you already know about backtracking, logic variables, stack shuffling then ?
07:49:08 <Spaceman77> Well, no
07:49:20 <Spaceman77> I didn't look at that much detail
07:50:14 <dminuoso> ski: stack shuffling, are you talking about Forth and its stack operators?
07:50:21 <ski> yes
07:51:01 <ski> it's interesting how you sometimes can get many for the price of one, in Prolog. multiple functionality with a single implementation
07:51:33 <Spaceman77> By the way, is there an IRC for language design
07:51:36 <Spaceman77> or compilers?
07:51:40 <ski> (an example would be append/3 doing the work of both `(++)' and `stripPrefix')
07:51:57 <Peter_Storm_> ski: from what I gathered, you could just kind of make up your own data type, and from that I could deduce my functor. So like if I have a way of going from a -> f a, there is almost just given a left adjoint going the other way. But that just seems simple. I dont know why that is üòÑ
07:51:59 <Spaceman77> I am currently implementing a code generator that analyses a single file and generates code based on it
07:52:10 <Spaceman77> Something similar to protocol buffers
07:53:22 <ski> there are channels #proglangdesign and #compilers
07:54:17 <ski> Peter_Storm_ : i assume you mean `a -> f b'
07:54:45 <Peter_Storm_> Ski: oh yeah, sorry
07:56:15 <ski> hm, somewhere i was reading of an adjunction (iirc) `(II ->) ---| Sqrt', where `II' is an interval type
07:57:07 <ggole> Prolog's append is such a seductive construct.
07:57:08 <ski> so `(II -> a) -> b' would be equivalent to `a -> Sqrt b', in that case
07:57:28 <ggole> Two lines and a bit of pattern matching and you get all this stuff.
07:58:06 <ggole> Then you write length and you just get length.
07:58:20 <ggole> And it was a lie all along.
07:58:20 <Weste> What does `\exc@BlockedIndefinitelyOnMVar` in the first code example in https://www.fpcomplete.com/blog/2018/05/pinpointing-deadlocks-in-haskell mean? What is this backslash and the @ sign for?
07:58:26 <ski> traditional arithmetic in Prolog is a wart, yes
07:58:42 <ski> using constraint arithmetic, it gets better
07:58:45 <ggole> The clpfd stuff fixes that a bit
07:58:46 <ggole> Right
07:59:21 <ski> there's also Curry and Escher which tries to combine the reversibility of Prolog with a functional paradigm
08:00:21 <ggole> Something is off when you need a heavyweight solver to add numbers, though.
08:00:28 <ski> Weste : `\<pat> -> <expr>' is a lambda expression, composed of a pattern `<pat>' and an expression `<expr>'
08:00:37 <hodapp> doesn't Mercury do something similar?
08:00:52 <ski> Weste : do you know about lambda expressions (aka function literals aka "anonymous functions")
08:01:31 <ski> Weste : `exc @ BlockedIndefinitelyOnMVar' is a pattern that both matches the input on `BlockedIndefinitelyOnMVar', and gives the input the name `exc', which can then be used in the body (the expression following the `->')
08:02:10 <ski> hodapp : yes, Mercury is logic-functional, adds (computing) functions to Prolog (also adds other things like a module system, static types, &c.)
08:02:44 <ski> Curry and Escher are functional-logic, starts with a functional language (with syntax similar to Haskell) and adds logic programming ideas to it
08:06:44 <ski> Mercury's mode (and determinism) checking (together with its declarativeness/purity) means that it can reorder conjuncts differently depending on which mode you call a predicate (or function) in. in Prolog either you have to be satisfied in all modes with the ordering you've chosen, or you must manually dispatch at run-time (or create multiple separate mode procedures, which is what the Mercury implementation does internally) to the correct ordering
08:06:59 <ski> (er, cut off near ".., which is what the Mercury implementation does internally) to the correct ordering")
08:07:07 <ski> Weste : makes sense ?
08:15:36 <Weste> ski: yes, now I understand, thank you.
08:57:26 <bsima> I can never decide how to organize my modules
08:57:50 <bsima> do I put third party API wrappers under 'Network' or 'Web' or 'Data'?
09:00:52 --- mode: glguy set +v chessai
09:01:28 <chessai> bsima: hackage has the cool property that packages cannot have duplicate names. we can often use this to our benefit by just having module names be prefixed with the library name
09:02:06 <chessai> bsima: for example, if i have a package named 'primitive', i might want to prefix all modules with 'Primitive'
09:02:28 <glguy> If you were going to do that you could just use the PackageImports extension
09:02:49 <chessai> this is less typing for users and implementors of the library, and provides somewhat less overhead for the readers of the library
09:02:58 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=packageimports#extension-PackageImports
09:03:30 <chessai> glguy: true, but this has the benefit of less typing, and shorter module names
09:03:48 <glguy> Yeah, using package imports you get shorter module names when they aren't ambiguous
09:04:14 <chessai> you still must type out the module name in full though?
09:04:18 <chessai> or am i mistaken
09:04:31 <glguy> only if it's ambiguous
09:04:42 <chessai> oh, makes sense
09:05:29 <bsima> so just call it 'ThirdParty' instead of 'Web.ThirdParty'
09:06:19 <bsima> or 'MyApp.ThirdParty'
09:23:30 <chessai> probably just 'ThirdParty'
09:23:38 <chessai> though thats a bit vague for a library
09:23:54 <chessai> unless that was just a placeholder or something
09:29:30 <reygoch> is there a syntax for `case` where I can cover multiple cases at once, something like : case someString of "a", "A" -> doSomethingOnA; "b", "B", "c", "C" -> doSomethingOnBC;...
09:29:43 <Ariakenom> who's the second party?
09:30:37 <ski> reygoch : unfortunately no disjunctive patterns in Haskell
09:31:03 <reygoch> ski: Shame, something similar is possible with guards though.
09:31:05 <ski> reygoch : in that case, you could use `elem' in a guard (or `if'-`then'-`else')
09:31:22 <reygoch> ski: yes, that's what I'm doing currently
09:31:29 * ski nods
09:32:13 <asheshambasta> Is there a way I can "use" a Wai Request inside a Wai Application to make another request to another address?
09:32:31 <asheshambasta> my use case is an application that does something akin to a request "fanout" concurrently.
09:43:39 <asheshambasta> I may have found the answer, I was merely looking at the types wrongly.
09:44:02 <asheshambasta> One has to love how Haskell's types almost "guide" you away from mistakes.
09:44:26 <asheshambasta> Haskell is hugely underrated
10:31:42 --- mode: glguy set +v dmrd_
11:31:38 <pzp> Why is defining `fmap` and `join` not alternative to defining `>>=` in the minimal complete definition of `Monad` in Prelude?
11:31:59 <c_wraith> pzp: something about the role system and GND
11:32:15 <c_wraith> pzp: like, it made it impossible to GND Monad
11:32:51 <c_wraith> I think the new QuantifiedConstraints extension allows that to be fixed, but I'm not 100% sure.
11:35:05 <c_wraith> pzp: https://ghc.haskell.org/trac/ghc/ticket/9123
11:35:14 <pzp> Thanks c_wraith 
12:08:58 <HenryCH> what's the easiest way to get a development environment up with syntax highlighting and debugger? or what is recommended today for beginners learning the language?
12:09:25 <hc> syntax highlighting and debugger? you want java *scnr*
12:09:38 <HenryCH> im using vscode, ive installed haskero, i have the syntax highlighting but i dont know how i could use it for interactive development
12:09:56 <cocreature> for a beginner I would recommend that you just have ghci open in a separate window
12:10:22 <HenryCH> what do experienced developers use? do they write their code in an editor and then just invoke the compiler separately to build?
12:10:27 <cocreature> the tooling that we have tends to be somewhat fragile and hard to set up and when you‚Äôre starting out you don‚Äôt want to have to fight tooling while you are also trying to grasp the language
12:10:40 <HenryCH> right
12:11:11 <cocreature> I use ghci + ghcid in separate terminals for quick feedback and then invoke cabal/stack when I want to do a full build
12:12:04 <HenryCH> ive gone through some starter material and it looks like the repl syntax is different from what your source code would ultimately be. I just saw the example of having to use let, is there anything else that's different or can I not worry about it?
12:14:27 <ammar2> the repl syntax should be more or less the same, what difference are you seeing?
12:14:34 <cocreature> you can write most of your source code in a regular Haskell file with the standard syntax and then load that using ":l Main.hs" in ghci
12:15:03 <cocreature> you also don‚Äôt need "let" these days but there are still some differences (e.g. for multi-line equations you need to be careful)
12:15:22 <cocreature> so I would recommend to use the repl to experiment with definitions that you have made in a file that you load with :l
12:15:35 <cocreature> but not define anything non-trivial in ghci itself
12:16:06 <HenryCH> ok
12:16:27 <HenryCH> ill give that a go, thanks
12:18:57 <ski> definitions in a source file can be out-of-order, and mutually recursive
12:19:45 <ski> definitions in the interactor has to be ordered, and can't be mutually recursive. unless you give multiple of them at the same time
12:21:55 <younder> ski: Explain multiple of them at the same time.
12:22:19 <cocreature> younder: wrap them in :{ :}
12:22:35 <ski> (hm, would it make sense to forward declare a definition, e.g. with a type signature, and later provide the definition. it would probably have to keep track of which definitions still depends on something that hasn't been defined yet. or one could imagine having a stub which gets replaced
12:22:41 <ski>  but now we get into the territory of wanting to update one of several mutually recursive definitions, at which point it seems simpler to just define in a file anyway)
12:23:14 <ski> younder : or, if it's value definitions, you can use `let', followed by multiple defining equations (and type signatures, if you like. also fixity declarations)
12:24:29 * ski can't help reading those as sad and happy smileys
12:26:33 <ski> hm, i suppose SLIME just replaces the current definition ? (what about cross-function optimizations ?)
12:26:49 <cocreature> :{ ‚Äúahrg, now I‚Äôm going to have to do work‚Äù :} ‚Äúgreat they‚Äôre finally done typing, this took ages‚Äù
12:27:14 <monochrom> Does "interactive development" mean typing code right into the REPL?  Why would anyone do that?
12:27:55 <__monty__> Closest I've come to interactive development is agda/coq.
12:28:21 <c_wraith> agda is weird.  I don't know of any other language where you expect the compiler to rewrite your source.
12:28:41 <akr> Hi there, what is the definition of the Ord instance for lists?
12:28:46 <ski> cocreature : yep :)
12:28:49 <akr> There's no source link in the docs
12:28:57 <c_wraith> akr: it's lexicographic, front-to-back
12:29:12 <c_wraith> > [] < [1,2]
12:29:15 <lambdabot>  True
12:29:20 <c_wraith> > [3] < [1,2]
12:29:21 <lambdabot>  False
12:29:39 <akr> c_wraith: is there any chance to read the definition, or is it too built-in?
12:29:46 <akr> for educational purposes
12:29:50 <c_wraith> akr: it's just the derived Ord instance
12:29:54 <akr> ah ok
12:29:58 <akr> I see, thank you
12:30:06 <c_wraith> akr: that is, compare the first field, then the second
12:30:25 <HenryCH> monochrom: no I meant, like in F# you can be just writing regular code on a file and then you can evaluate the whole thing or just portions of it, you dont need to compile and run the output
12:30:52 <c_wraith> HenryCH: ghci exists?
12:31:38 <HenryCH> right, but more than one person now has said that writing code directly there is not the best idea
12:31:51 <c_wraith> sure, but it can load arbitrary source files
12:32:16 <c_wraith> That's a rather normal thing to do.  Write source, load in ghci to experiment with it
12:32:23 <__monty__> HenryCH: Well, because you lose it immediately. GHCi is not an editor and there's small syntax differences.
12:32:31 <monochrom> Perhaps some people define "compile" to mean "switch to another window and enter a command"
12:32:34 <cocreature> HenryCH: writing code directly is not the best idea but the ‚Äúwriting regular code on a file and then you can evaluate the whole thing‚Äù-approach that you mentioned is perfectly fine
12:32:44 <cocreature> evaluating portions of it admittedly isn‚Äôt as easy
12:33:16 <c_wraith> cocreature: though deferring type errors and using type holes gets you most of the way there, if you want to do that sort of thing in ghci
12:33:38 <__monty__> HenryCH: Integration with the editor like lighttable has for clojure for example isn't available yet afaik. But, there's GHCid to automatically check your code and if it succeeds you can load the code into GHCi to play around.
12:33:41 <younder> so does C and with less effort
12:33:44 <younder> lol
12:33:56 <HenryCH> yep, I'll try just experimenting in a file and commenting stuff out i dont want as i feed it to ghci
12:34:04 <younder> Use the language, don't fight it.
12:34:51 <c_wraith> HenryCH: check out the -fdefer-type-errors extension with ghci, too.  It lets it load files with type errors, and just replaces the code with type errors with throwing an exception that describes the error
12:36:33 <ski> @type let compareList :: Ord a => [a] -> [a] -> Ordering; [    ] `compareList` [    ] = EQ; [    ] `compareList` _      = LT; _      `compareList` [    ] = GT; (x:xs) `compareList` (y:ys) = x `compare` y <> xs `compareList` ys in compareList
12:36:34 <lambdabot> Ord a => [a] -> [a] -> Ordering
12:36:40 <ski> akr : something like that ^, i think
12:36:56 <c_wraith> ski: you have a lot of spaces in your []s
12:37:02 <ski> aligning
12:37:07 <c_wraith> interesting
12:37:21 <akr> ski: cool, thank you
12:37:28 <monochrom> Alignment in a 1D medium?!
12:37:43 <c_wraith> And yeah, that will give you the exact same behavior as the derived Ord instance
12:37:51 <ski> akr : this uses the `Monoid Ordering' instance, for brevity
12:37:59 <akr> ski: and the Monoid instance is the one with disjunction I presume?
12:38:09 <c_wraith> > LT <> EQ
12:38:11 <lambdabot>  LT
12:38:12 <ski> monochrom : i imagine possibly they'll copy it into an editor, and break into multiple lines :)
12:38:14 <HenryCH> thanks for the tip c_wraith
12:38:17 <c_wraith> > LT <> GT
12:38:18 <lambdabot>  LT
12:38:23 <c_wraith> > EQ <> GT
12:38:25 <lambdabot>  GT
12:39:22 <c_wraith> > [ a <> b | let xs = [LT, EQ, GT], a <- xs, b <- xs]
12:39:24 <lambdabot>  [LT,LT,LT,LT,EQ,GT,GT,GT,GT]
12:39:37 <ski> > sortBy (comparing length <> compare) (words "The quick brown fox jumps over the lazy dog")  -- akr, this a nice example showing how one can use `(<>)' to primarily compare by one aspect, and secondarily by another aspect
12:39:39 <lambdabot>  ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
12:39:47 <ski> also see
12:39:48 <ski> @where monoids
12:39:48 <lambdabot> comment on "Monoids? In my programming language?" by Cale in 2008 (or 2009 ?) at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> about a use of `
12:39:48 <lambdabot> instance Monoid a => Monoid (rho -> a)'
12:40:49 <akr> c_wraith: I see, thanks :)
12:40:56 <ski> (it also uses ^ instance. but in the bottom it uses `Monoid Ordering' as well)
12:42:02 <akr> ski: oh wow, neat!
12:48:14 * ski liked interactive development in Agda1 (using Alfa) a bit more than in Agda2 (using the Emacs mode)
12:49:40 <__monty__> I've never used nor heard of Alfa. Is that the cli interface?
12:50:07 <ski> no, it was a structural GUI editor
12:50:54 <dolio> How did it differ?
12:51:36 <akr> ski: sounds interesting, are there any screenshots anywhere?
12:51:43 <ski> no freetext editing (well, you could open a subwindow on a hole and type in free text)
12:52:49 <[exa]> reminds me one thesis I recently reviewed, there's apparently a thing called projectional editors
12:53:03 <ski> if point was at a hole, you got a list of all operations that was in scope whose return type matched the type of the hole. it automatically abbreviated the names of the operations so that usually you'd just have to type one or a couple of keys to select the appropriate operation
12:53:51 <ski> it could display proofs as Natural Deduction trees (growing vertically or horizontally, at your option)
12:54:26 <ski> if you filled in a later argument, that would often automatically fill in earlier arguments at the same time
12:55:03 <ski> hm, i had some screenshots, but i'm not sure where i put them
12:55:18 <ski> [exa] : link ?
12:55:51 <dolio> Having richer visualization than what you can build with unicode text would be nice.
12:56:12 <[exa]> ski: sadly it was built above jetbrains MPS which is a javbomination
12:56:28 <ski> @where Alfa
12:56:28 <lambdabot> Proof editor, using Agda1 proof engine/checker, at <http://www.cse.chalmers.se/~hallgren/Alfa/>,(broken) <http://www.cs.chalmers.se/~hallgren/untested>,<http://ogi.altocumulus.org/~hallgren/untested>
12:56:28 <lambdabot> ,<http://ogi.altocumulus.org/~hallgren/untested/for_Linux/alfa-041029-bin-i386-Linux-RedHat9.tar.gz>,<http://ogi.altocumulus.org/~hallgren/untested/Source_code/alfa-050126.src.tar.gz>. Also see `
12:56:28 <lambdabot> Agda',`Fudgets',`GF'
12:57:45 <ski> akr,dolio : oh, actually, here's one screenshot i made <http://i.imgur.com/Fn6Gr.png>, at least
12:58:34 <dolio> Yeah, that's cool.
12:58:49 <ski> it was built using Fudgets
12:59:04 <dolio> I was trying to come up with a way to present proof trees in Agda, but couldn't figure out anything that looked okay except for linear deductions.
12:59:36 <[exa]> ski: anyway the guy tried to run Frege in that which partially succeeded, except the whole thesis basically screamed that it's a bad idea to use anything from jetbrains with java for this purpose
13:00:16 <ski> in practice, for larger proofs, you'd either go with plain terms, or use the tree view that growed horizontally. otherwise it'd quickly become far too wide
13:00:17 --- mode: glguy set +v koality
13:00:25 <koality> test message
13:00:44 <koality> Hey guys, I'm making a pretty simple function but am not sure what's causing an error
13:00:50 <koality> stringToStringList :: String -> [String]
13:00:55 <koality> stringToStringList xs = words xs : []
13:01:04 <[exa]> koality: check the type of (:)
13:01:12 <koality> getting     * Couldn't match type `[Char]' with `Char'       Expected type: [String]         Actual type: [[String]]     * In the expression: words xs : []
13:01:25 <ski> (also the algorithm for laying out those inference rule strokes could be smarter, not wasting as much space (a subtree should be able to be wider than a parent tree, as long as there's no collision). that would help with the "too wide" problem a bit)
13:02:03 <ski> [exa] : mhm
13:02:25 <koality> oh I see
13:02:44 <koality> should've used stringToStringList :: String -> [[String]], silly mistake
13:03:01 <[exa]> ski: it ended for me when I found no way to put brackets [  ] around an expression
13:03:06 <ski> hm, i also remember augustss having some GF integration with Alfa, so that you could use (some fragment of) natural language, with it
13:03:44 <ski> [exa] : what was the basic idea that made it "projectional" ?
13:04:17 * ski is also reminded of Peaker's Lamdu (or is it Bottles now ? .. can't recall)
13:04:32 <[exa]> ski: well-- it wasn't a good thesis, and the jetbrains thing had "projectional" written on that
13:04:40 <younder> What is the macro function extension available for Haskell? I have heard of it but I don't remember it's name.
13:04:49 <ski> koality : `words xs : []' is the same as `[words xs]', btw
13:05:04 <ski> younder : i suppose you're thinking of Template Haskell (TH)
13:05:07 <c_wraith> younder: not sure what you mean?  template haskell?  source plugins?
13:05:26 <ski> (there's also CPP, but i doubt that's what you're thinking of)
13:05:28 <younder> template Haskell it is.
13:05:37 <[exa]> "macro function" yay surprises
13:06:00 <younder> I am an old Lisper.
13:06:06 * ski knows :)
13:06:37 <koality> ski: thanks, didn't know that
13:06:48 * ski should get around to investigate the amount of hygienicity in TH ..
13:07:35 <ski> preflex: xseen augustss
13:07:44 <younder> Syfillitical Haskell?
13:08:01 <younder> lol
13:09:23 <younder> ski: So you are saying they are not hygienic macro's like in scheme?
13:10:26 <__monty__> Are they even macros?
13:10:29 <younder> Well I am a 'dirty' common lisper anyhow.
13:11:14 <__monty__> You definitely don't want to use TH like lispers use macros btw. It seems to be a sure fire way for people not to bother with your code : )
13:11:50 <[exa]> "if it partially evaluates, it's a macro"
13:12:15 <ski> __monty__ : depends on your definition of macros, i suppose. they definitely allow staged programming at compile-time, to fill in holes in source with ASTs, possibly computed from compile-time constants, and from ASTs coming from argument expressions
13:12:15 <younder> so does any curry
13:12:41 <ski> well, it doesn't do partial evaluation for you (afaik, at least)
13:13:09 <ski> a "macro" call will not look like a function call, though
13:13:18 <ski> (istr there being some Lisp that also did that ?)
13:16:02 <younder> I am not getting any love for TH from CL either.
13:16:26 <younder> They suggest to make better use of the type system.
13:18:15 <[exa]> younder: just curious, what's the target problem for TH?
13:18:46 <ski> akr,dolio : anyway, the window on the right contains the in-scope bindings whose return type can unify with the type of the hole at point. the abbreviations of the operation names (in square brackets) are computed dynamically (you'd give an ASCII name, and then possibly also give a symbolic name, possibly using some special custom syntax like quantifier, "big sigma"-sum, &c.)
13:19:09 <ski> you'd either click on the operation you'd want to fill the hole with, or start typing the letters
13:19:30 <younder> Oh, for a compiler. I am used to reader macros instead of your precompiler.
13:19:48 <ski> ("they" being ?)
13:20:52 <akr> ski: it sounds interesting, but I think I'd have to try it on my own to get a feel for it and decide whether I like it better than the current thing
13:21:00 <ski> [exa] : extending the constructions in the language (by expansion). e.g. before `ApplicativeDo', Philippa had a TH quasi-quoter that did something similar
13:21:06 <younder> parsec
13:21:42 <c_wraith> Source plugins are also a brand new thing, and I have *no* idea how they work.
13:21:48 <ski> akr : looks like hallgren semi-recently added a new version at <http://www.altocumulus.org/~hallgren/untested/Source_code/>. you could try compiling that
13:22:20 <akr> ski: so that is still using Agda 1, correct?
13:22:26 <ski> c_wraith : hm. are they in some way similar to `#!lang blah' in Racket ?
13:22:34 <c_wraith> https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0017-source-plugins.rst
13:22:35 <ski> (i suppose probably you wouldn't know)
13:22:47 <c_wraith> Looks like you get to hook into various points in the compile process to rewrite things
13:22:54 <ski> akr : afaik, yes
13:23:08 <akr> ski: alright, thanks a lot for the link
13:23:15 <c_wraith> after type checking, renaming, parsing, running TH, and loading interface files
13:23:22 <ski> one can of course edit Agda1 in a plain editor. but it's less fun than Alfa
13:23:46 <akr> :)
13:23:48 <c_wraith> So...  The stuff you do has to structurally be haskell, but you can add entirely new meanings for existing forms.
13:24:51 * ski . o O ( Camlp[45] )
13:25:22 <dolio> ski: I guess my worry would be that that doesn't really scale to having a large library of stuff.
13:25:58 <dolio> Like if your goal is `e1 = e2`, Agda 2 has dozens of ways you could potentially proceed.
13:26:08 <dolio> In the standard library for that.
13:27:06 <c_wraith> huh.  GHC has also added frontend plugins.  Which let you use the GHC frontend and then run your own code...  why isn't that called a backend plugin?  You're plugging in a new backend!
13:27:10 <ski> hm, i suppose sorting by specificity could be useful
13:27:23 <ski> dolio : good point
13:27:59 <younder> Haskell's type system is more of term rewriting system than, say C's type system.
13:28:23 <c_wraith> younder: well, it's also a code-prevention system.
13:28:40 <c_wraith> younder: one of the most important things it does is let you prevent large classes of bad code
13:29:29 <ski> unification of types is similar to unification in logic programming (like Prolog,Mercury,Oz,lambdaProlog,Twelf,&c.). resolution of type class instances is somewhat similar to resolution/solving of goals/queries (but more restricted. no backtracking)
13:30:38 <ski> knowing a little Prolog can help with better understanding the type system (and in general, any type system, or also operational semantics, given by inference rules)
13:32:14 <p0lyph3m> ski: prologs unification is based on resolution calculus , right
13:32:15 * ski isn't sure whether younder is thinking of type synonym expansion as term rewriting, or instance resolution as term rewriting, .. or perhaps something else
13:32:46 <ski> p0lyph3m : yes, that's a common way to present it
13:34:10 <younder> I feel the implementation of the Haskell type system would be clearer with a set of separate first order predicate rules, stashed as rues, implemented as a RETE graph. As it is the implementation is a mess.
13:34:39 <ski> <https://en.wikipedia.org/wiki/Resolution_(logic)>,<https://en.wikipedia.org/wiki/SLD_resolution>
13:36:06 <ski> younder : hm, i'm not sure to which extent it would make sense to use forward-chaining there
13:36:35 <younder> Seems in the days of satisfiabillity, with all these great algorithms, yo could do better in creating maintainable code.
13:36:48 <[exa]> younder: if you mean the GHC implementation, most of the mess is caused by tiny implementation details, like it should produce reasonable errors and so
13:37:04 <[exa]> younder: the sad thing is there's only 10% of the actual type system left :D
13:39:10 <younder> I know, it always is. Look to deep space one and it error recovery procedure in case of multiple errors. Again a RETE graph. Separate stachable rules are a good alternative in a sparse state matrix.
13:40:05 <ski> can you elaborate on what you mean by "stachable rule" ?
13:41:34 <ski> hmm .. i suspect that you're thinking of stuff like in expert systems, where you have reasonably declarative rules which (hopefully) can be understood without too much context (and where you can also ask the system *why* it reached a certain conclusion, and it can side the required rules (omitting the false starts and dead ends of the search)
13:41:38 <younder> You name a rule, you name it's dependencies. It forward chains it against it's existing rules. It keeps track of which perquisites it depends upon.
13:42:02 <ski> (s/side/cite/)
13:42:10 <ski> )
13:42:42 <cocreature> I‚Äôm not sure framing a unification-based type checker as a RETE graph makes things clearer for most people
13:42:44 <ski> younder : i would be interested in seeing such an approach to type systems
13:43:08 <ski> (i wonder how related stuff like "type systems in context", and being explicit about constraint generation, is)
13:43:35 <[exa]> it would be nice to have some kind of interpreter for the natural deduction rules though
13:44:27 <ski> [exa] : Prolog, or lambdaProlog (or Twelf) can possibly be of use there
13:44:43 <[exa]> O_O lambdaprolog?
13:44:48 <[exa]> wow
13:45:09 <ski> (lambdaProlog has a native way to represent bindings with (matchable !) HOAS, so you don't have to bother with substitution, alpha-conversion, &c.)
13:45:22 <[exa]> but I meant something such for ghc, to just put Fc-omega in one file and add all the technical stuff in other files
13:47:25 <[exa]> ski: ok thank you very much for mentioning Œªprolog, seems I've got a new favorite reasoning tool
13:47:31 <ski> lambdaProlog allows higher-order unification, iow unification of lambda-terms. however, there is no complete implementation of it. lambdaProlog is complete for a certain stylized fragment called L-lambda matching, iirc ?
13:48:33 <ski> [exa] : there's also Lolli, for (intuitionistic) linear logic reasoning. also see Lygon,Forum
13:48:47 <Unode> Is it possible to have all types derive Show by default?
13:48:55 <dolio> There's also beluga, which is more like Twelf.
13:49:42 <ski> dolio : link ?
13:50:01 <dolio> http://complogic.cs.mcgill.ca/beluga/
13:50:04 * ski finds <https://www.cs.mcgill.ca/~bpientka/papers/inductive-beluga.pdf>
13:50:09 <ski> ok, ty
13:51:19 <[exa]> Unode: what about types that contain functions?
13:51:41 <[exa]> ski: cool, thanks
13:52:12 <dolio> ski: The cool thing about beluga is that it lets you keep track of variables that are in scope, becuase it's based on contextual modal type theory.
13:52:18 <ski> or that contain other abstract data types, with no given `Show' instance (like `IO a' or `IORef a')
13:52:30 <ski> dolio : oh, that does sound interesting :)
13:53:05 <ski> dolio : so is that used for meta-programming reasoning, with open terms ?
13:53:26 <Unode> [exa]: default to some kind of representation, a placeholder of sorts?
13:53:39 <geekosaur> Unode, no, there si no way to say "derive these typeclasses whenever possible"
13:54:21 <dolio> ski: Yeah. The modality lifts terms in the HOAS level to the computational level, basically. And the computational level is a functional language instead of a logic language.
13:54:42 <Unode> feels silly that I need to manually add show instances to pretty much everything when debugging.
13:54:53 <Unode> how do you generally address this ?
13:55:01 <chessai> Uncode: just derive Show
13:55:07 <chessai> Unode*
13:55:20 <dolio> But then you can examine HOAS terms with free variables in a given context recursively.
13:55:28 <Unode> chessai: that was my question to begin with
13:55:42 <dolio> And when you go under a lambda, you can recurse in an extended context.
13:55:52 <sm> Unode: I derive Show as much as possible, overriding it when necessary to display some kind of valid haskell syntax, then display with pretty-show
13:55:52 <dolio> ski: https://hub.darcs.net/dolio/cmtt-talk-demo/browse/translate.bel
13:56:12 <dolio> That's an example I wrote that translates a term using HOAS to one using de Bruijn.
13:56:16 <Unode> sm: including for types coming from libraries?
13:56:29 <sm> I haven't had to deal with that much
13:56:39 <sm> usually they're simple and pretty show can handle them
13:56:47 <Unode> pretty show?
13:56:51 <sm> pretty-show
13:57:01 <Unode> googling
13:57:01 <[exa]> isn't there a debugging way to print contents of data?
13:57:05 <sm> it parses standard Show output and prints something human readable
13:57:27 <Unode> sm: hum but you still need to have 'derive show' present no?
13:57:42 <sm> yes, or implement a show instance
13:58:04 <sm> it's usually an easy thing to add. Not sure what it does to compile times though
13:58:11 <sm> all that deriving
13:58:59 <ski> Unode : there's also `:print'
13:59:27 <ski> dolio : nice :)
13:59:38 <koality> Hey guys, I'm trying to get this function working (as a utility function for something else). I know what the issue is but I'm not sure how to implement it properly... can someone please give me tips?
13:59:38 <koality> isUrl :: [String] -> [Bool]
13:59:42 <koality> isUrl xs = isPrefixOf prefix xs
13:59:46 <koality>   where prefix = "http://"
13:59:50 <dolio> I'm not sure you can do that easily using e.g. Twelf.
14:00:08 <ski> koality : `prefix' is a `String', while `xs' is a list of `String's
14:00:14 <dolio> I'm not a Twelf expert, though.
14:00:34 <ski> koality : they ought to be lists of the same type, if you want to pass them both to `isPrefixOf'
14:00:35 <monochrom> koality: Look for the function called "map".
14:01:01 <koality> ski: I'm aware but I'm not sure how to iterate through all words
14:01:04 <sm> Unode: one lib where this does break down is time - Day's show output is not valid haskell syntax, so pretty-show can't format it or any value which contains a Day
14:01:04 <ski> koality : if you want to check all `String's in a list .. what monochrom said. or list comprehensions
14:01:12 <koality> monochrom: I'll look into that
14:01:14 <koality> thanks
14:01:26 <ski> koality : it is also possible to do it directly, by recursion on the list of `String's, if you prefer that
14:01:48 <sm> you can work around that by giving the containing type a custom show instance that prints the day in double quotes, eg
14:02:04 <koality> ski: I was trying to do recursion but couldn't think of a way to do it. I'm looking into map now
14:02:04 <ski> (that's what `map' itself does. a recursion on a list. a call to `map' hides that explicit recursion from you)
14:02:31 <younder> First order logic is most efficient for Horn Clauses yes. But with todays algorithms of satisfiabillity they can be extended to most of first order logic.
14:03:19 <ski> dolio : i suspect you can do it in lambdaProlog, by dynamically (locally) assuming extra clauses that associate your local variables to corresponding de Bruijn indices (iiuc what the issue was)
14:03:42 <ski> (i don't recall whether Twelf allows you do to that, though i wouldn't be surprised)
14:04:20 <ski> koality : btw, it's also possible to call `isPrefixOf' as an infix operator
14:04:55 <younder> The requisite of just one conclusion is the limiting factor. You can have several and still have it give reasonable performance.
14:05:14 <ski> > "pro" `isPrefixOf` "prolog"
14:05:17 <lambdabot>  True
14:05:20 <ski> > "pro" `stripPrefixOf` "prolog"
14:05:22 <lambdabot>  error:
14:05:22 <lambdabot>      ‚Ä¢ Variable not in scope: stripPrefixOf :: [Char] -> [Char] -> t
14:05:22 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
14:05:28 <ski> er
14:05:34 <ski> > "pro" `stripPrefix` "prolog"
14:05:36 <lambdabot>  Just "log"
14:06:14 <Unode> sm: Basically what I'm wondering is if there's a better solution to https://youtu.be/8tpCcSIVLf4?list=PLxj9UAX4Em-Ij4TKwKvo-SLp-Zbv-hB4B&t=805 where during a debugging session you have to add as many deriving clauses as the number of objects you have to inspect.
14:06:39 <Unode> Half of that debugging session I've no idea what's going on but clearly the author knows
14:06:42 <ski> younder : by multiple conclusions i assume you mean multiple *alternative* conclusions (effectively a disjunction of them) ? .. as in Gentzen's sequent calculus system LK for classical logic, e.g.
14:06:42 <sm> can you summarise that
14:07:10 <sm> basically for debuggability, you want to define or derive Show instances for everything
14:07:32 <Unode> exactly. And I'm wondering if ghc couldn't simply do that for me
14:07:45 <sm> and no, I don't think ghc can yet, happy to hear otherwise
14:08:06 <ski> younder : my understanding was that if you add such smarts to your reasoning, then it becomes harder to predict the behaviour (and performance), and thus becomes harder to program in
14:09:08 <ski> that's one of the attractive points with Prolog's simple and stupid depth-first search on Horn clauses. one can be smarter, and still be reasonable, though ..
14:09:24 <__monty__> Unode: A different approach is writing tests. Quickcheck style or regular unit tests. I've personally found them more useful, as in they help a lot more than just showing data does.
14:09:51 <sm> each has its place
14:10:08 <ski> sm : did you try `:print' ?
14:10:30 <sm> not yet. Debug logging is better sometimes
14:10:52 <sm> I will though, now that you remind me!
14:10:59 * ski would like buddha resurrected again ..
14:12:01 <younder> ski: I have always found Horn Clause reasoning sufficient for logic problems.
14:12:21 <Unode> __monty__: isn't that an entirely different issue? I'm trying to debug in order to understand what is going on. Testing would come after, once I have some idea of what to test. 
14:12:24 <sm> ski: what does :print do that's good ? it hangs on my knot-tied types
14:13:02 <ski> "A declarative debugger for Haskell 98" <https://web.archive.org/web/20091122221642/http://ww2.cs.mu.oz.au:80/~bjpop/buddha/>
14:13:02 <sm> oh, it's show but without forcing evaluation ?
14:13:40 <__monty__> Unode: Testing helps you understand what goes wrong and with the tests already in place you can be more fearless in your refactoring. Why put off writing tests if you're going to eventually anyway?
14:13:40 <younder> ski: I am not that smart. I am missing something here. I just don't know what, yet.
14:13:44 <ski> sm : and can be used when there's no `Show'
14:13:55 <ski> younder : fair enough
14:14:27 <sm> hmm I see.. works with no Show instance. And does do some pretty-printing 
14:14:40 <sm> I wonder if you can log with that
14:14:50 <ski> sm : you have to force it enough, though
14:15:05 <_deepfire> cocreature, is it even clear if RETE graphs are expressive enough to express type relationships that are due to things like type families and GADTs?
14:15:21 <koality> I'm trying to do something along the lines of: 'map isURL ["http://test.com", "not a site", "http://anotherwebsite.ext", "123"]', where it returns [True, False, True, False]
14:15:30 <koality> am I using 'map' wrong?
14:15:31 <ski> _deepfire : let's start simple
14:15:46 <ski> koality : looks ok
14:16:03 <koality> I'm getting error: Variable not in scope: isURL :: [Char] -> b
14:16:11 <ski> you haven't defined it
14:16:11 <koality> where isUrl is defined as:
14:16:17 <glguy> case matters
14:16:17 <koality> isUrl :: String -> Bool
14:16:21 <koality> isUrl xs = isPrefixOf prefix xs
14:16:24 <koality>   where prefix = "http://"
14:16:40 <ski> > "isURL" == "isUrl"
14:16:42 <lambdabot>  False
14:17:05 <koality> wow...
14:17:10 <koality> thanks, I didn't notice that
14:17:12 <ski> > comparing (map toLower) "isURL" "isUrl"
14:17:14 <lambdabot>  EQ
14:17:21 <Unode> __monty__: I understand your argument, though in this case I don't even know what to test for. The code isn't exactly testable either. Sure I can test the function's output but it's what's happening inside that I'm trying to figure out.
14:17:30 <koality> I'm aware that they're not equal, but I accidently did caps lol
14:17:58 <Unode> __monty__: in other words, Debug.Trace and friends...
14:18:11 <_deepfire> ski, another problem is that RETE isn't known to be particularly memory-efficient, AFAICT from a quick read -- trading off memory for CPU efficiency
14:18:20 <__monty__> Unode: Then you don't want to test the function but the building blocks : )
14:18:38 <[exa]> Unode: btw what are you writing?
14:18:43 <_deepfire> and compiling Haskell is already a memory-intensive endeavour
14:18:50 <sm> __monty__: it's not that simple. Sometimes you can make headway with both approaches, but often one is much quicker
14:18:59 <sm> you need both
14:19:19 <ski> @hackage hood
14:19:19 <lambdabot> http://hackage.haskell.org/package/hood
14:19:27 <ski> Unode : perhaps ^ could also be helpful
14:20:20 * ski laments Buddha's demise
14:22:01 <_deepfire> But I think there is also larger question, whenever you choose representation of types in a compiler -- you don't really want to be constraining what you can express, since unification for advanced types is already a challenge.
14:22:30 <Unode> ski: looking under the hood seems interesting. Can it handle arbitrary types?
14:22:40 <__monty__> sm: Maybe. I've found that usually print-style debugging takes a lot longer because you just spend a while confirming your idea of the behavior, the reason for the bug is you're missing something and I tend to miss it with printing too, printing the wrong thing a couple times before finding the right thing to print. Tests on the other hand are more ruthless. They say "this" is wrong. Then you write 
14:22:46 <__monty__> tests for the parts that make up "this" and repeat.
14:22:53 <_deepfire> RETE seems like a specialised solution, which seems to imply a degree of shoe-horning if you want to use it to represent types in a compiler.
14:24:03 <ski> Unode : the main useful thing with it is that it can observe functions (so you see what pairs of input&output have actually been passed to and received from them)
14:24:50 <sm> __monty__: I'm sure it depends on the type of code. I often debug log to narrow down errors encountered only in production, eg
14:24:51 <ski> __monty__ : i think a declarative debugger could be of help, there
14:25:25 <sm> some of that logging would be better done with an interactive debugger, if I had one
14:25:44 <Unode> [exa]: hard to describe. Code is mostly written but I'm trying to add some functionality in order to fix https://github.com/ngless-toolkit/ngless/issues/56. Getting pulled deep into caveats...
14:25:52 <ski> (especially if it's smart enough to track data dependencies somewhat more accurately than just the plain call graph)
14:30:20 <sm> what does a declarative debugger look like ?
14:31:38 <dolio> It runs your program, remembering all the intermediate values, and lets you drill into where the wrong results came from.
14:31:52 <dolio> So you can trace them to the source.
14:32:18 <chessai> where did Data.Monoid live before base-4.9?
14:32:23 <chessai> did it even exist?
14:32:31 <sm> oh nice. I guess that's more than a post mortem debugger, which wouldn't have the history
14:32:56 <sm> necessarily
14:34:08 <hc> dolio: fascinating. does something like this exist for haskell?
14:34:43 <dolio> There have been multiple examples, but they all no longer work, because they're unmaintained.
14:35:24 <dolio> Buddha, hat, hood.
14:35:26 <sm> elm and codeworld have time travelling debuggers, which sounds similar
14:38:10 <dolio> Maybe. I saw the elm one demoed a long time ago, and what I remember of it isn't really the same. Maybe it can do the same thing, though.
14:38:35 <koality> Hi guys, thanks for your help from earlier. I got my code working but I'm not getting the correct output, details of expected and actual output are in the link
14:38:42 <koality> https://0bin.net/paste/w0GwGbpTtcc09R89#IC4MrMXXZvkCWc5NiOkCU3uxlEc-0WP0SgMB6nIpaO3
14:38:56 <dolio> Like, I remember being able to use a sort of slider to go back in the real-time state of the program, but that's not what you want at all for declarative debuggging.
14:39:10 <dolio> You want to trace through the data dependencies.
14:39:25 <dolio> Not points in time.
14:39:33 <koality> Assume that my isUrl function works fine, I've tested it
14:39:47 <koality> Something in the allUrls function is off... can't seem to find out what it is
14:40:15 <dolio> Being organized around time/sequence is kind of the whole problem with normal debugging.
14:40:54 <__monty__> Does elm still have the debugger? I thought that got neglected.
14:40:58 <sm> interesting
14:41:07 <dolio> Of course, with the time travelling thing, I guess it at least has the information available.
14:41:22 <__monty__> So there's no way to try out declarative debugging with haskel rn?
14:41:31 <sm> yes, capturing the whole lifecycle allows a full range of debugging techniques
14:41:38 <dolio> Whereas the other problem with a normal debugger is that you can tell it when exactly to stop, but it might not have the information you want to see available anymore.
14:42:48 <dolio> So you have to keeep doing things over and over until you get it to stop at a relevant point.
14:44:45 <dolio> __monty__: I don't know of anything that still works. I think someone tried to get hat going again most recently, but it's probably still way behind what would actually work.
14:45:03 <dolio> I think it hooked into GHC guts, and those guts have probably changed.
14:47:12 <ski> sm : a declarative debugger can ask the user (oracle) whether a certain call with certain inputs is supposed to produce stated output or not (and, if more advanced, you can point out which part of the output was wrong)
14:47:26 <ski> sm : time-travelling isn't the same thing (but is also helpful, yes)
14:48:08 <ski> (in Prolog, time-travelling (`retry') in the procedural debugging is common. istr hearing something about OCaml as well ?)
14:51:16 <__monty__> Hmm, if debugging were like git bisect that'd be great.
15:15:45 <koality> Can someone please help me fix the behavior of: https://0bin.net/paste/w0GwGbpTtcc09R89#IC4MrMXXZvkCWc5NiOkCU3uxlEc-0WP0SgMB6nIpaO3
15:15:55 <koality> I'm struggling to find what's causing the issue
15:19:41 <geekosaur> what you have is looking for a url and then stopping. and probably crashes on a list with no urls in it
15:20:39 <koality> geekosaur: the otherwise case makes a recursive call and first guard statement appends the url to the output list?
15:20:56 <geekosaur> it doesnt'append because it doesnt' recurse
15:21:06 <geekosaur> it grabs the first url, ends the result list,and returns
15:21:07 <koality> ah....
15:21:18 <geekosaur> if thefirstthng sn'ta url, then it recurses
15:21:26 <geekosaur> first thing isn't a
15:21:36 <koality> geekosaur: I understand now, thanks
15:21:48 <geekosaur> and if ou call it on a list with no urls, it will try to take the head of an empty list and crash
15:21:49 <koality> is there any simple way of fixing this...?
15:22:15 <Gurkenglas> How did you arrive at this code?
15:22:31 <Gurkenglas> Maybe we can see how to tweak that process to make it arrive at a working solution.
15:23:01 <koality> Ive tried like 5 different implementations, this is the first one that's bug free lol
15:23:15 <geekosaur> it's nto bug free. try allUrls []
15:23:27 <koality> aside from that case
15:23:31 <Gurkenglas> The first that compiles, he means. Can you also paste the previous versions?
15:24:43 <koality> gurkenglas: uhmmm... I kept rewriting ontop of old code
15:25:26 <koality> tried using map isURL(words (xs))
15:26:27 <geekosaur> I know how to rewrite it but just showing you that won't help you understand how to write it, how to think in order to write it
15:26:32 <Gurkenglas> koality, if your editor provides an edit history, you could explore that - but nevermind. What piece of code produces the difference between the "expected" and "actual" output?
15:27:28 <koality> I'll spend some more time on this and update if I find another method of doing this
15:27:56 <Gurkenglas> koality, one direction to try is to use pattern matching instead of "head" and then checking that you used all variables
15:28:36 <koality> Gurkenglas: thanks for the tip, I haven't tried much pattern matching
15:28:49 <koality> for this function
15:29:38 <koality> how would you do pattern matching for a string though...?
15:29:50 <koality> I'm only familiar with pattern matching for Integers
15:30:06 <Gurkenglas> What you want to pattern match is not xs, but the input to head: "words xs"
15:30:21 <koality> ahh... i see
15:30:41 <koality> Thanks, I feel like I'm heading in teh right direction now!
15:31:58 <rain2> hi guys
15:32:28 <chessai> koality: also, you can pattern match on 'String', 'String' is just '[Char]'
15:32:45 <chessai> so if you know how to pattern match on a list, you know how to pattern match on a String
15:32:46 <Gurkenglas> chessai, you can pattern match anything
15:32:55 <Gurkenglas> ...except functions I suppose?
15:33:22 <chessai> Gurkenglas: yeah, but koality specifically mentioned they didnt know how to pattern match on a String, so i explained how that is done.
15:33:28 * ski thinks one should be able to match on functions ..
15:34:14 <Gurkenglas> ski, "case f of ..." = "\x -> case f x of ..."?
15:34:29 <ski> nah
15:34:36 <ski> matching on `\<expr> -> <pat>' would behave the same as matching on `(($ <expr>) -> <pat>)' (view pattern)
15:35:10 <Gurkenglas> I don't follow.
15:35:12 <ski> this would go well with generalizing as-patterns to conjunctive patterns (which we want anyway, because of view patterns)
15:35:36 <ski> matching on `\3 -> x' would pass `3' to the function, and match the result with the pattern `x'
15:35:53 <Gurkenglas> You match before you know it's 3 tho
15:35:55 <ski> it's making an observation on the function
15:36:03 <ski> `3' there is an expression
15:36:11 <ski> i pass it to the function
15:36:27 <clever> Gurkenglas: i think template haskell can even pattern match on functions, but your matching the raw nodes in the AST
15:36:29 <Gurkenglas> that sounds like "case f of ..." desugaring to "\x -> case f x of ..."
15:36:30 <ski> i'm asking : given this input, does the corresponding output match this pattern ?
15:37:07 <ski> Gurkenglas : that passes an arbitrary input `x' to `f'. i'm talking about passing any expression
15:37:18 <Gurkenglas> You mean "case f where the argument is x of ..." , which desugars to "case f x of ..."? o.o
15:38:28 <ski> `case f of (\<expr> -> <pat>) -> ...' would amount to `case f of (($ <expr>) -> <pat>) -> ...' which amounts to `case f <expr> of <pat> -> ...', yes
15:38:32 <koality> I GOT IT
15:39:10 <koality> changed line from   | isUrl (head (words (xs))) = head (words (xs)) : []         to        | isUrl (head (words (xs))) = head (words (xs)) : allUrls (unwords (tail (words (xs))))
15:39:20 <koality> and checked for empty xs
15:39:42 <chessai> you could also factor out the `words xs`
15:39:47 <chessai> and pattern match on that
15:40:01 <chessai> youre calling `words xs` like 3 times there
15:40:22 <chessai> you could put it in a `where` or `let` to simplify the code a bit
15:40:34 <ski>   map (\x -> y)@(map -> (\xs -> ys)) (x:xs) = y:ys  -- Gurkenglas, here's a somewhat silly example of using function matching (together with a view pattern, for fun)
15:41:03 <koality> chessai: thanks, I'll clean things up
15:41:53 <ski> Gurkenglas : makes sense ?
15:43:39 <Gurkenglas> "We define map. It takes two arguments. The first has form (\x -> y), and also has form (map -> (\xs -> ys)). The second has form (x:xs). The result is y:ys." as a partial parsing
15:44:12 <ski> (otoh, if we consider your `case f of ...  =  \x -> case f x of ...', i'd say one problem with this would be that the type of the whole `case'-expression isn't the same as the type of each branch expression inside it ..)
15:44:33 <ski> Gurkenglas : *nod*
15:45:17 <Gurkenglas> Usually lines of a case match are prismy, but your specification of the input is lensy
15:45:18 <ski> by "The first has form (\x -> y)" we really mean "if we pass `x' to the first, the result will have form `y'"
15:45:36 <ski> hm, elaborate on what you mean by that ?
15:45:51 <Gurkenglas> Usually you can interpret them as "has form" :P
15:46:18 <Gurkenglas> Distinguishing between Left and Right gains information, while caring only about the output that corresponds to an input loses information
15:46:26 <dmwit> ski: May I write `f (\x -> y) (\y -> x) = ...`?
15:47:29 <ski> think of the function as large datastructure associating inputs to outputs. where we may think of inputs as "field names" and outputs as corresponding "values". then matching on `\<expr> -> <pat>' amounts to selecting a particular field and matching on its contents
15:47:51 <Gurkenglas> Right, and selecting a particular field isn't usually thing you do via pattern matching right
15:48:01 <ski> dmwit : if allowed, that would be an infinite loop (like `let x = y; y = x in ...') :)
15:48:10 <Gurkenglas> The closest you can come to that is replicating the entire spine in the match and _ing all the parts you don't need
15:48:39 <ski> Gurkenglas : right, but then functions aren't lefty data types (inductive types), they're more like righty data types (coinductive types)
15:48:48 <dmwit> ski: Perhaps. Though e.g. `let (x, y) = (f y, g x) in ...` isn't necessarily an infinite loop.
15:49:00 <ski> dmwit : *nod*
15:49:20 <dmwit> It's a fun syntax to consider. Thank you.
15:49:23 <ski> dmwit : good point
15:49:57 <ski> the book "Topology Via Logic" by Steven Vickers talks some about observations of functions in this sense (also cf. the package `hood')
15:50:04 <glguy> > let f ( (+1) -> x ) ( (+x) -> y ) = (x,y) in f 6 10
15:50:06 <lambdabot>  (7,17)
15:50:18 * ski spoke too soon with the `let'
15:51:15 <ski> anyway, the point is that if we're going to allow patterns that look like `\... -> ...' at all, then this basically seems like the reasonable semantics for it
15:52:07 <ski> (one could also consider `let'-patterns, and `if'-patterns ..)
15:53:24 <ski> (btw, this is a reason i'm not that fond of allowing `_' or `@' in expressions. if a syntax is allowed in both patterns and expressions, then imho the basic meaning should coincide (ignoring the reverse flow of information, and possibility for failure))
15:53:43 <dmwit> ?let strange (($y) -> x) (($x) -> y) = (x,y)
15:53:44 <lambdabot>  Defined.
15:53:49 <dmwit> that...
15:53:51 <dmwit> worked?
15:53:56 <dmwit> ?undefine
15:53:56 <lambdabot> Undefined.
15:54:08 <dmwit> ?let strange (($foo) -> bar) (($bar) -> foo) = (foo,bar)
15:54:09 <lambdabot>  .L.hs:159:13: error:
15:54:09 <lambdabot>      ‚Ä¢ Variable not in scope: foo
15:54:09 <lambdabot>      ‚Ä¢ Perhaps you meant ‚Äòfor‚Äô (imported from Data.Traversable)
15:54:14 <dmwit> Okay, that's better.
15:55:07 <dmwit> So this is one interesting thing about your proposal: I think at the moment scopes always go left-to-right ish. You seem to be proposing a syntax where scopes can be more recursive, which might make the conversion to Core-like one-case-at-a-time harder.
15:55:30 <Gurkenglas> clever, do you have a link to an example of that?
15:55:39 <dmwit> an example of what?
15:55:52 <ski> dmwit : or at least also right-to-left, as long as there's no cycles
15:56:18 <dmwit> Yes, the "as long as there's no cycles" bit was more or less what got me thinking about my original question. =)
15:56:55 <clever> Gurkenglas: https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial a lambda expression is just an LamE data record, and TH should give you access to that internal AST node, then its just a tree of data records
15:57:09 * ski was pondering the other month how to do dependent types where the dependency could be out-of-order, so to speak
15:59:17 * ski would like an axiomatic semantics treatment of view patterns, that better explains its declarative meaning, rather than only an operational/procedural one
16:00:45 <ski> (in some sense it seems that the view pattern `f -> p' means something like `f^-1 p'. but figuring out the details of this has eluded me)
16:01:59 * ski . o O ( `swap :: (b,a) -> (a,b); swap (snd p,fst p) = p' )
16:10:19 <Gurkenglas> You want to complete the rectangle of Left as a pattern, Left as a function and fst as a function? Makes sense D:
16:11:20 <ski> Gurkenglas : yea, this `fst' is another idea :)
16:11:43 <Gurkenglas> and using the fst pattern without the second pattern would have the same consequences as matching against Left but not Right
16:11:50 <Gurkenglas> *the snd pattern
16:12:05 <ski> well, it would either be an error, or produce a partial value
16:13:04 <ski> @let infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys =      ys; (x:xs) /\/ ys = x : (ys /\/ xs)
16:13:05 <lambdabot>  Defined.
16:14:09 <ski> > fix $ \ns -> 0 : tail (ns /\/ map (1 +) ns)
16:14:11 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
16:14:46 <ski> having to use `tail' here is bothersome
16:16:02 <ski> (btw, that's the ones bit count of binary numerals)
16:18:03 <ski> what if we could say `head ns = 0; tail ns = tail (ns /\/ map (1 +) ns)' or even maybe `head ns = 0; ns = ns /\/ map (1 +) ns'. a variant is `ns = (0 : _) | (ns /\/ map (1 +) ns)'
16:18:15 <ski> (perhaps `|' could be `unamb' ?)
16:20:41 <ski> > fix $ \ns -> repeat 0 /\/ map (1 +) ns  -- unapropos, bit position to change in Gray code, aka number of times something is divisible by two
16:20:43 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
16:37:04 <infinisil> Hey, is there a library that does this? https://stackoverflow.com/a/20871010/6605742
16:37:27 <infinisil> Namely, reading environment variables at compile time into Strings
16:39:43 <hpc> template haskell or CPP (CPP is just a guess)
16:40:00 <hpc> both are language extensions
16:41:07 <refold> yeah it should be possible to do this with TH
16:42:26 <geekosaur> CPP won't do it at compile time. TH can, and probably someone could package a quasiquoter
16:42:55 <hpc> i thought you could get environment variables out of CPP?
16:43:17 <geekosaur> only indirectly, by someone using a -D option to pass it in
16:43:23 <hpc> blah
16:43:58 <infinisil> hpc: refold: Look at my link..
16:44:23 <infinisil> I'm not asking how to do it, that's already done by that person. I'm asking for a library for that
16:47:35 <hpc> hmm
16:47:56 <hpc> reading https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code i think you should use cabal to pass the -D option
16:48:04 <hpc> or something along those lines
16:48:11 <hpc> instead of depending on environment variables
16:49:13 <infinisil> Ah yes, that's actually better for my usecase, thanks
16:49:17 <hpc> it keeps the code simpler, you just use the CPP flag
16:49:33 <geekosaur> I'd probably use a cabal flag then have that do -DDEBUG or whatever
16:49:51 <hpc> and then it's expressed in the package specification (which is where "input" to the package build "function" is defined)
16:50:09 <hpc> and!
16:50:17 <hpc> hackage will print out cabal flags and their default options
17:04:45 <infinisil> hpc: Hmm.. does data-files work with cabal repl?
17:04:52 <infinisil> Because it doesn't seem to
17:05:13 <infinisil> It just points to a location that doesn't exist
17:05:28 <chreekat> infinisil: might need to pass both -datadir -datasubdir (maybe with more hyphens)
17:06:29 <infinisil> Hmm..
17:13:19 <infinisil> chreekat: Well, these options are only available with new-style commands, which I'm currently trying to avoid. And in the new-style commands, it works without setting them anyways
17:13:59 <chreekat> infinisil: oh, in old-style, they must be passed to "configure"
17:16:01 <infinisil> Ahhh
17:16:02 <chreekat> I am not actually sure how datadir and datasubdir interact, but in scripts I used (not written or deeply inspected by myself), the usage was "--datadir $PWD --datasubdir $PWD", which put files in... $PWD. Seems buggy, but I don't know
17:16:47 <chreekat> s/put/expected to find/
17:17:49 <infinisil>  cabal configure --datadir . --datasubdir . works
17:18:08 <infinisil> I'm using this only for cabal repl later on
17:18:18 <chreekat> sweet
17:18:21 <chreekat> yeah
17:18:25 <infinisil> At which point the files are already at the correct place anyways
17:20:10 <infinisil> chreekat: Default datadir seems to be "$HOME/.cabal/share", default datasubdir seems to be "x86_64-linux-ghc-8.4.3/package-name-0.1.0.0"
17:20:27 <infinisil> So by default stuff would get installed to the concat of those
17:21:22 <chreekat> ah ok that makes sense. And your use (with '.') is what was actually used by my scripts. All is well
17:21:55 <infinisil> Neato
18:02:29 <boj> any ideas as to why the linking step might hang forever?
18:09:18 <leifmetcalf> Using servant, how would one describe an API in which the user, using a query parameter, may specify the response type?
18:10:50 <leifmetcalf> Should I start writing a new servant combinator? It seems like this would be a common want.
18:11:25 <buhman> isn't that normally a request header parameter?
18:13:17 <leifmetcalf> I don't know, the http API I'm working with is a bit funny.
18:13:59 <leifmetcalf> If this is an unusual use of query parameters I guess I'll write a combinator
18:16:25 --- mode: glguy set +v koality
18:29:19 <koality> does Haskell have a built-in xor?
18:29:49 <boj> koality: https://hoogle.haskell.org/?hoogle=xor
18:29:51 <mniip> are you looking for a boolean xor or for a bitwise xor
18:30:05 <koality> boolean
18:30:13 <mniip> (/=)
18:30:23 <koality> thanks
18:30:24 <boj> ah
18:30:43 <ski> @type xor  -- bitwise
18:30:44 <lambdabot> Bits a => a -> a -> a
18:31:14 <boj> hmm. i have tried ghc822 and ghc843 but the linker just hangs. what have i done wrong? :(
18:32:07 <mniip> Bool has a Bits instance too so it would work as well
18:32:17 <mniip> > True `xor` False
18:32:19 <lambdabot>  True
18:57:01 * boj was staring at his screen too long and didn't notice new-run vs. new-build
19:03:29 <alp> leifmetcalf, https://www.well-typed.com/blog/2015/12/dependently-typed-servers/ may be relevant
19:05:57 <leifmetcalf> alp: It does! Thank you!
19:53:54 --- mode: glguy set +v koality
19:53:58 <koality> random question, but would the first row in pascal's triangle be considered the 0th row or 1st?
19:55:16 <mniip> the one with just '1'?
19:55:50 <koality> mniip: yes
19:56:13 <mniip> yeah that better be the 0th row 0th column
19:56:26 <mniip> or else you lose correspondence with C^n_k binomial coefficients
19:56:58 <koality> makes sense, thanks
19:57:03 <koality> didnt think of that
20:32:50 --- mode: glguy set +v koality
20:37:17 <koality> hey guys, I'm wondering how I can implement this from 'foo :: Int -> [Int]' 'foo n... 
20:38:01 <koality> I want it to output [function n 0, function n 1, ..., function n n]
20:39:30 <koality> any ideas of what functions or utilities would be useful for achieving this? advice would be appreciated
20:45:44 <ski> koality : `map' or list comprehensions, or recursion
20:46:15 <ski> > [0 .. 9]
20:46:17 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
20:47:40 <koality> I'm trying the 'map' approach with: foo n = map (function [0..n] n)
20:47:52 <koality> but function only takes int, not [int]
20:50:59 <mniip> ski, any more insights into yoneda
20:52:24 <koality> anyone know how to make 'map (function [0..n] n)' work where 'function :: Int -> Int'?
20:55:22 <mniip> koality, look at the type of 'map'
20:55:27 <mniip> what does it tell you
20:55:55 <koality> map :: (a -> b) -> [a] -> [b]?
20:56:09 <koality> :t map
20:56:10 <lambdabot> (a -> b) -> [a] -> [b]
20:57:09 <mniip> right
20:57:35 <mniip> first of all make up your mind:
20:57:35 <mniip> 10/20/2018 [06:37:39] 18<koality18> I want it to output [function n 0, function n 1, ..., function n n]
20:57:42 <mniip> there's no way that works with function :: Int -> Int
20:58:17 <koality> foo :: Int -> [Int] outputs [function n 0, function n 1, ..., function n n]
20:58:41 <koality> where function :: Int -> Int
20:58:48 <dacto> koality: what does "function n 0" mean?
20:59:07 <koality> dacto: function is n choose k
20:59:23 <koality> dacto: implementing nth row of pascal triangle
20:59:34 <mniip> then how is it Int -> Int?
20:59:47 <mniip> what does Int -> Int mean?
20:59:48 <koality> n choose k = int
21:00:44 <koality> ex. choose 6 3 = 20
21:01:11 <mniip> koality, what does Int -> Int mean?
21:01:11 <ski> can you answer mniip's question ?
21:01:23 <dacto> koality: what about: take n $ map function_nCk [0..]
21:01:43 <koality> mniip: the function's input and output type I suppose
21:01:59 <koality> where you declare the function?
21:02:01 <dacto> koality: seems like you already have a function that does the nCk
21:02:09 <koality> dacto: yes
21:02:33 <dacto> and above you stated you need to map that function to a list of ints
21:03:37 <mniip> koality, 'A -> B' is the type of functions that take a value of type 'A' as input and produce a value of type 'B' as output
21:03:57 <mniip> "choose" is not an Int -> Int
21:04:03 <mniip> it doesn't turn one int into another
21:04:39 <koality> to clarify: https://0bin.net/paste/ddkIU4xArb4v5r8d#CXdLPYYCNV3JSU8NEE4K82irb21pkK4j9HWfVwxmhrt
21:04:52 <koality> (btw, yes I know choose can use a lot of optimization)
21:04:55 <ski> koality : what input does `function' take ? what output does it produce ?
21:05:00 <mniip> right
21:05:07 <dacto> ah that helps
21:05:11 <mniip> notice how in the source you specify
21:05:12 <mniip> choose :: Integer -> Integer -> Integer
21:05:40 <dacto> koality: starting with a paste when possible helps quite a bit :)
21:05:43 <mniip> do you understand the difference between 'Integer -> Integer -> Integer' and 'Integer -> Integer'
21:06:34 <koality> mniip: I thought you were asking in regards to the pascal function
21:06:57 <mniip> eh?
21:07:56 <koality> yes, I know Integer -> Integer -> Integer isn't the same as Integer -> Integer
21:08:11 <mniip> then why do you insist on one when you mean the other
21:08:16 <ski> koality : then why did you say `function :: Int -> Int' above ?
21:08:31 <koality> oh....
21:08:46 <koality> sorry... I misspoke 
21:08:51 <koality> my bad
21:09:01 <ski> perhaps this is related to the trouble you're having. perhaps not. regardless, you should clear up any misunderstanding here
21:10:28 <ski> <koality> I want it to output [function n 0, function n 1, ..., function n n]
21:11:11 <ski> you attempted to figure out how to use `map' to achieve this
21:11:20 <koality> here's the error and code: https://0bin.net/paste/uhNBuiuHs9RDLfzE#9jukuN-SG+pRsMgvQWSOkF0aI/U5IWdGS0uBZVUrRwN
21:11:31 <koality> I understand 'why' I'm getting this error
21:11:44 <ski> do you have a basic idea of roughly how such a call to `map' would look like, even if you're not sure on exactly what to pass as input to `map' yet ?
21:11:45 <koality> I just don't know how to accomplish what my goal is
21:12:12 <koality> I've looked at examples of map
21:12:30 <koality> from "learnyouahaskell"
21:12:38 <dacto> :t map
21:12:40 <lambdabot> (a -> b) -> [a] -> [b]
21:12:55 <ski> or, if you prefer, you could pick apart
21:12:56 <ski> <koality> I'm trying the 'map' approach with: foo n = map (function [0..n] n)
21:13:03 <ski> or
21:13:13 <ski>   pascal n = map (choose [0..n] n)
21:13:18 <ski> as you phrased it in the paste
21:13:53 <ski> (hrm, and when i said "you could pick apart", i really intended to say "we could pick apart")
21:14:22 <ski> koality : any preference ?
21:15:08 <koality> ski: I'm going to try a few things in the next few mins
21:15:14 <koality> will come back if still stuck
21:16:27 <ski> as you please
21:22:23 <koality> ski: show me the way sensei
21:24:38 <koality> ski: I'm now trying another approach 'pascal n = [choose 0 x | x <- [0..n]]'
21:24:52 <koality> although it crashes after '[1,
21:25:49 <koality> nvm
21:25:50 <ski> what does `[f x | x <- [0 .. 3]]' simplify to ?
21:25:50 <koality> I got it
21:25:56 <ski> ok ?
21:26:00 <koality> pascal n = [choose n x | x <- [0..n]]
21:27:00 <ski> with that definition, `pascal n' (for non-negative `n') will expand to `[choose n 0,choose n 1,choose n 2,...,choose n (n-1),choose n n]'
21:27:47 <ski> if you want to, you could try to figure out how to get the same result, using `map' instead of a list comprehension
21:31:13 <Zipheir> It's good to make sure you understand how to translate list comprehensions to higher-order functions, if only to remove any cargo-cult thinking.
21:56:53 <UniClown> quit
23:14:12 <cocreature> _deepfire: it is definitely not clear to me :)
23:17:00 <Lycurgus> channel needs a new log, the current one is unreliable, #lisp replaced it sometime ago
23:19:06 <cocreature> Lycurgus: how is it unreliable? from a quick look I can‚Äôt spot any problems
23:19:16 <Lycurgus> which one?
23:19:55 <Lycurgus> ok musta been a transient, the index is coming up now
23:20:20 <cocreature> the one linked in the topic
23:21:01 <Lycurgus> still I didn see anything by "_deepfire" in the last few hundred lines
23:21:55 <cocreature> it‚Äôs in http://tunes.org/~nef/logs/haskell/18.10.19
23:24:01 <Lycurgus> by "the index" i meant  http://tunes.org/~nef/logs/haskell
23:24:35 <Lycurgus> by which time I'd already scanned the recent non part/join activity from another source
23:47:54 --- mode: glguy set +v Guest20517
