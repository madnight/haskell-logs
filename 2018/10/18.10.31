00:28:49 <trcc> What is the difference between import Foreign (Storable) and import Foreign.Storable, except number 2 is working?
00:30:12 <cocreature> trcc: import Foreign.Storable imports the module called "Foreign.Storable". "import Foreign (Storable)" imports a symbol called Storable (could be a typeclass, a type, …) from the module called "Foreign"
00:30:17 <cocreature> and only that
00:30:20 <MarcelineVQ> import Foreign.Storable imports all the public exported things from the module  Foreign.Storable   import Foreign (Storable)  imports one thing called Storable from a module named Foreign
00:30:24 <tdammers> the first one imports the Storable type from a module named Foreign; the second one imports everything from a module named Foreign.Storable
00:31:44 <trcc> ah okay. Thank you. If I need to import multiple modules under Foreign, what is the best way to do it? Several lines each with import Foreign.*? i.e. Storable, Ptr, StablePtr and so forth?
00:32:01 <trcc> just best practices
00:32:47 <cocreature> Foreign reexports Foreign.Ptr, Foreign.Storable, … so importing Foreign should be sufficient
00:33:08 <cocreature> if you want to be more precise, then either use separate import lines or an explicit import list
00:33:23 <trcc> explicit import list?
00:33:52 <cocreature> import Foreign (Ptr, StablePtr, …)
00:34:00 <cocreature> that way you only import the names that you list there
00:34:26 <trcc> Ah ok. Thanks
00:35:32 <trcc> but import Foreign (Ptr) does not give me e.g. the nullPtr function right?
00:35:54 <trcc> nvm trying it out
00:35:54 <koz_> cocreature: I think I'll wait for the experts.
00:36:05 <koz_> I might even decide to play around with llvm-hs myself. :)
00:37:06 <cocreature> trcc: right but import Foreign (Ptr, nullPtr) does
00:37:19 <trcc> Great. Thank you!
00:58:11 <trcc> Yaay it compiles
00:58:29 <tdammers> ship it
00:58:57 <trcc> tdammers: only implemented 1 of 15 of the API functions required ^^
00:59:22 <tdammers> that was a jab at the "if it compiles, ship it" narrative
00:59:28 <trcc> hehe ye, inno
01:00:00 <trcc> I am a bit more careful when it is so tangled up with FFI with structs function ptrs and such...
01:01:28 <tdammers> oh sure
01:01:35 <tdammers> FFI basically means "you're on your own"
01:02:07 <tdammers> when you say "this foreign function is pure", then the compiler takes your word for it
01:02:24 <trcc> Seems like it :)
01:02:34 <tdammers> think about it, it has to
01:02:42 <tdammers> the alternative would be to not allow pure FFI functions at all
01:02:55 <tdammers> that would be more honest, but also outright terrible
01:03:34 <tdammers> because then you would just wrap all foreign functions that you know are effectively pure in unsafePerformIO, and nobody would be any the wiser, except there's now a lot more boilerplate that serves absolutely no purpose
01:03:56 <trcc> seems reasonable
01:05:15 <tdammers> now, if C itself had a reliable way of managing effects, then we might be able to marshal that information across the FFI barrier - but it doesn't, so we have to provide that information manually
01:05:58 <trcc> I guess hsc2hs, c2hs and similar exists to help. Though I find them fairly difficult to use, although I am using a bit of hsc2hs for structs
01:06:54 <tdammers> I think they help more with the marshalling boilerplate than with managing effects though
01:07:25 <trcc> hmm yes
01:08:17 <trcc> But I do not really see anything in the future taking C's position
01:08:22 <trcc> in the near future *
01:09:36 <MarcelineVQ> how near :>
01:09:44 <trcc> sooner rather than later
01:10:08 <tdammers> fortunately, FFI isn't something you need to deal with a lot usually
01:10:36 <trcc> The API I am implementing is in C
01:12:32 <trcc> 34 functions it seems like with associated structs, function pointers etc. Was thinking of creating a C-wrapper that conformed it better to Haskell, but decided I want it all in haskell for the challenge as well
01:12:53 <tdammers> the C shim might be saner and more idiomatic
01:13:18 <mreh> do I have vocie in here
01:13:55 <Ariakenom> mreh: yes
01:14:06 <Ariakenom> I mean I can hear you at least
01:14:09 <mreh> phew
01:14:12 * Ariakenom becomes paranoid
01:14:23 <mreh> maybe we can only hear each other...
01:15:51 <tdammers> I read you 5/5
01:15:54 <tdammers> both of you
01:16:13 <tdammers> although it is of course possible that I am only your heads
01:18:11 <trcc> tdammers: probably. But there is no deadline for the project, so maybe I will finish one day, maybe not
01:22:58 <Arahael> trcc: If it helps, for large(r) proejcts, the clang api is decent, so you could, if you chose to, make your own wrapper-generator.
01:23:42 <trcc> Not familar with clang, I will look at it! Thank you
01:24:07 <Arahael> trcc: Unfortunately, this particular API is 100% undocumented, but apparently stable.
01:24:14 <trcc> hehe amazing
01:24:31 <koz_> Apparently stable is the best kind of stable.
01:51:20 <tdammers> "abandoned" is the only true kind of stable
01:53:53 <[exa]> +1 tdammers 
01:54:03 <[exa]> did you recently stabilize a project?
01:54:51 <ion> @remember tdammers "abandoned" is the only true kind of stable
01:54:51 <lambdabot> Nice!
01:55:40 <tdammers> [exa]: most of my projects are very stable
01:57:46 --- mode: glguy set +v noipmups
01:57:48 <noipmups> How to deploy stack app to Amazon ec2 using nixops? Do you know some guide? I'm lost.
01:59:21 <echoreply> I'm trying to use a parser built using attoparsec to parse a user-agent string: https://github.com/owensmurray/http-grammar; I can load the code in ghci, but I can't manage to invoke it correctly; I guess it's generic attoparsec stuff, but there are no examples in the repo. Any ideas how to parse a string using this parser?
02:03:51 <ion> Data.Attoparsec.ByteString.parse Network.HTTP.Grammar.userAgent (Data.String.fromString "NCSA_Mosaic/2.0"), I assume
02:04:42 <ion> (Btw, don't manually call fromString in production)
02:05:06 <tdammers> ion: why not?
02:05:25 <tdammers> ion: or rather, why specifically not "in production"?
02:06:06 <ion> It is useful for string literals with OverloadedStrings but it almost certainly does not do the right thing in general if you use it as a String -> ByteString for some random string you got from somewhere.
02:06:53 <tdammers> oh
02:07:10 <tdammers> so the actual advice is "don't use the IsString instance for ByteString"
02:07:43 <echoreply> ion: yep, that worked. thanks!
02:07:45 <tdammers> except maybe for hardcoded literals that you have manually verified to be 7-bit-clean ascii
02:08:17 <tdammers> (but even that is a bit of a kludge IMO)
02:10:49 <merijn> tdammers: I've got a type-safe solution for that!
02:11:06 <merijn> (because this is Haskell, so of course I do!)
02:11:18 <merijn> https://hackage.haskell.org/package/validated-literals
02:11:52 <ion> merijn: neat
02:12:41 <merijn> ion: The API probably neats some more work/polish (I have an alternate/future branch which is slightly different), but should work enough to use
02:14:36 <merijn> (So, uh, be a bit strict with your upperbound if you use it, because the API will probably change in the next update)
02:16:08 <ion> merijn: Would class Validate a b benefit from an a -> b functional dependency?
02:16:26 <ion> Oh, never mind
02:16:39 <ion> I'm a bit too tired to brain.
02:18:19 <merijn> ion: Not really, unless Strings can only turn into one value ;)
02:19:12 <merijn> The real simplification is that I will probably eliminate "spliceValid" entirely in favour of depending more on Lift (which, wasn't reliably usable when I initially wrote it, but GHC now has -XDerivingLift
02:20:06 <merijn> ion: Like this: https://github.com/merijn/validated-literals/blob/test/ValidLiterals.hs
02:20:21 <merijn> (With bonus method for providing error messages!)
02:20:47 <ion> Oh, nice, I had not noticed Lift.
02:21:22 <merijn> ion: The use of Lift guarantees the actual result is computed and inlined at compile time, rather than redoing it at runtime
02:21:46 <merijn> You can still override it in the few cases that's not possible (e.g. ByteString can't be made an instance of Lift)
02:22:18 <ion> Alright
02:23:12 <merijn> But you shouldn't if at all possible. Anyway, I haven't gotten around to finishing that up.
02:24:47 <maerwald> codex: /home/maerwald/.cabal/packages/hackage.haskell.org/00-index.tar: openBinaryFile: does not exist (No such file or directory)
02:24:49 <maerwald> what is this
02:25:15 <maerwald> and why does it not use the existing 01-index.tar file
02:26:39 <merijn> I think 01-index is for new-build? But I could be mistaken
02:26:41 <MarcelineVQ> you need both don't you? 01 is for a newer package format? might be wrong about that
02:27:30 <maerwald> I don't know what that means. No one handles those files manually
02:29:39 <MarcelineVQ> Not typically no. Could you repeat your question with more words?
02:29:44 <merijn> maerwald: Translation: THe reason it doesn't use 01-index.tar is because those two files store different things and thus aren't interchangeable
02:30:09 <merijn> maerwald: have you run "cabal (new-)update" yet?
02:30:13 <maerwald> yes
02:30:15 <merijn> That should create those files if missing
02:30:18 <merijn> mmm
02:30:26 <merijn> that's odd
02:31:18 <merijn> I only have 01-index.tar with cabal HEAD, so I'm guessing MarcelineVQ is right
02:31:35 <merijn> 01-index is the newer package format, which codex then, presumably, doesn't support
02:34:48 <ion> merijn: Btw, nonAsciiVals is named a bit inaccurately, it would need (<=127) instead of (<=255) to match. As it is now, it could be named something like nonLatin1Vals. An alternative check could be unpack (pack s) == s, that wouldn't involve hardcoding a codepoint number.
02:37:56 <merijn> ion: I suppose, technically
02:38:45 <merijn> But since it's only an example/test I'm not too worried about the remaining 1% of pedantic accuracy ;)
02:39:11 <Ariakenom> merijn: but, like you said, this is Haskell :p
03:06:10 <c50a326> https://ptpb.pw/W-Qf/hs why won't OverloadedStrings make reqStr a Data.ByteString.Lazy.Internal.ByteString ?
03:06:52 <merijn> c50a326: OverloadedStrings only applies to *literals*
03:06:59 <merijn> c50a326: Not every String value (that'd be awful!)
03:07:30 <c50a326> :(
03:07:56 <merijn> c50a326: What's the type of req?
03:09:09 <c50a326> https://hackage.haskell.org/package/wai-3.2.1.2/docs/src/Network-Wai-Internal.html#line-93
03:09:19 <c50a326> it's okay, I just have to convert String to ByteString lol
03:10:21 <merijn> c50a326: Use "T.pack :: String -> Text" and then you can use the functions in Data.Text.Encoding to go "Text -> ByteString" if you know what encoding you want to return
03:11:17 <c50a326> oh yeah it's not as trivial as there being a simple function to convert lol
03:11:56 <merijn> c50a326: Well, you can define your own in one line
03:12:11 <merijn> "convert = encodeUtf8 . T.pack . show"
03:12:12 <c50a326> oh there's this https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Char8.html#v:pack
03:12:19 <merijn> c50a326: Don't use that
03:12:20 <c50a326> but you're suggesting this https://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text.html#v:pack
03:12:24 <merijn> Forget you ever saw it
03:12:28 <c50a326> oh right lol, why?
03:12:41 <c50a326> Char8 is bad I guess?
03:12:45 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
03:14:14 <byorgey> Char8 is great for solving programming contest problems
03:14:22 <byorgey> I would never use it in any other context
03:15:04 <merijn> Char8 seems like a great solution, until 2 years later you have a hard to reproduce problem you can't figure out that comes from it >.>
03:15:36 <merijn> c50a326: Incidentally, even using Char8 for ASCII literals is bad. So I wrote a library to do that type-safely in a different way :p
03:15:37 <c50a326> byorgey: hey I was reading the monad reader issue that included mighttpd2, like issue 20 or so, from some years ago, and your wrote an editorial that was something like "SDOIFDIAJSFJOISAJIJIFJIFJFJFIJFIJSIJSIJIJDJIJSDJISIJDSIJDIJAIJDAIJ" or something?
03:15:49 <c50a326> probably different characters completely, but something to that effect - what was that all about?!
03:16:01 <merijn> c50a326: This one linked earlier today: https://hackage.haskell.org/package/validated-literals
03:16:03 <c50a326> s/your/you/
03:16:39 <c50a326> yeah this one 19 https://themonadreader.files.wordpress.com/2011/10/issue19.pdf
03:16:41 <merijn> I should bug quchen to fix his fbut to remove the implication that Char8 is useful for that case...
03:17:46 <byorgey> c50a326: huh, I don't remember.  It's probably a cryptogram of some sort.
03:18:42 <c50a326> haha fair
03:38:32 <byorgey> c50a326: yes, definitely a cryptogram, I found the plain text, but I didn't find any code with it so no idea what encryption scheme I used
03:39:59 <Ariakenom> ghci based encryption for maximum security
03:40:24 <byorgey> hehe, right, exactly
03:40:28 <byorgey> it's not a Caesar cipher.  Perhaps a Vigenere.
03:41:53 <Lears> Do I need to do something special to get cabal new-repl to work with source that uses FFI? I've used nix-shell to make the foreign libraries available and cabal new-build works, but new-repl gives:
03:41:55 <Lears> <command line>: user specified .o/.so/.DLL could not be loaded (libX11.so: cannot open shared object file: No such file or directory) Whilst trying to load:  (dynamic) X11
03:44:05 <mlehmk> Hi!
03:44:30 <mlehmk> I think Semigroup is incomplete
03:44:46 <c50a326> ah how do I: Data.ByteString.Internal.ByteString to Data.ByteString.Lazy.Internal.ByteString
03:45:18 <c50a326> encodeUtf8 gives the former, responseLBS wants the latter
03:45:39 <ion> c50a326: You will find "fromStrict" in the API documentation of Data.ByteString.Lazy
03:46:12 <c50a326> h Data.Text.Lazy.Encoding is a thing, it looks like
03:46:19 <c50a326> s/h/ah/
03:46:21 <Solonarv> mlehmk: what do you mean?
03:48:58 <merijn> mlehmk: In what sense?
03:49:16 <mlehmk> I think I was a bit too quick in conclusions
03:50:00 <Solonarv> I'm still curious as to what made you think so, if you don't mind indulging me
03:50:47 <mlehmk> a Semigroup may have a neutral element, like an identity, but it'd only work left. Like. S(S,<>), there can be a sempty, where sempty <> a == a
03:51:52 <mlehmk> which is actually true for a type [a] -> NonEmpty a, as there's fromList, which is actually a sempty that has a property like this, it cannot be on the right side
03:52:34 <mlehmk> fromList <> a == a
03:52:47 <dmwit> I don't think so.
03:53:00 <merijn> mlehmk: A semigroup with a neutral element is a Monoid
03:53:03 <dmwit> > Data.List.NonEmpty.fromList [] <> Data.List.NonEmpty.fromList [3]
03:53:05 <lambdabot>  error:
03:53:05 <lambdabot>      Not in scope: ‘Data.List.NonEmpty.fromList’
03:53:05 <lambdabot>      No module named ‘Data.List.NonEmpty’ is imported.error:
03:53:16 <Taneb> mlehmk: if members of a typeclass *may* have a property, then that's when you add another typeclass
03:53:21 <dmwit> % import qualified Data.List.NonEmpty as N
03:53:26 <mlehmk> ahh
03:53:40 <merijn> mlehmk: As in, that's the literal definition of Monoid (and why Semigroup is now a superclass)
03:53:49 <dmwit> Anyway, fromList [] <> a is an exception, which /= a when a is not an exception.
03:53:57 <mlehmk> well, a Monoid has an identity element both left and right
03:54:08 <mlehmk> fromList <> a, not fromList []
03:54:40 <merijn> mlehmk: fromList [] is bottom
03:54:43 <mlehmk> a Semigroup may have a one sided identity element, which only goes on one side
03:55:08 <dmwit> mlehmk: Okay, well, that's either ill-typed (if you intend `<>` to combine `NonEmpty`s) or incorrect (if you intend `<>` to operate pointwise on functions).
03:55:17 <Solonarv> Sure. A semigroup may also have a two-sided identity element, or an absorbing element.
03:55:21 <Taneb> mlehmk: can you give an interesting example that isn't equivalent to either First a or Last a for some a?
03:55:28 <Taneb> And that actually works
03:55:31 <mlehmk> a semigroup with a two-sided identity element is a Monoid
03:55:43 <Solonarv> yes, and it's still a semigroup
03:55:48 <mlehmk> indeed it is
03:56:30 <Solonarv> analogy: Every monoid is a semigroup. Every square is a parallelogram. If a parallelogram happens to have equal edges, it's still a parallelogram.
03:57:01 <dmwit> I think he understands that and has already retracted his complaint before he even said it aloud...
03:57:19 <mlehmk> mh? I haven't retracted anything
03:57:55 <dmwit> Oh, okay! Then you are still as wrong as you were before. =)
03:57:58 <mlehmk> I just think I found something that isn't really possible to express in Haskell without errors
03:58:13 <geekosaur> haskell tpeclasses do have limitations
03:58:26 <mlehmk> Just check out semigroup with left identity element
03:58:26 <dmwit> You can express it. Just add a class with extra laws compared to Semigroup, but fewer laws compared to Monoid.
03:58:59 <kuribas> It'd be nice to have a lightweight interpreted haskell for scripting.
03:59:05 <dmwit> class Semigroup a => LeftId a where leftId :: a -- | leftId <> a = a
03:59:14 <kuribas> or haskell-like language.
03:59:16 <geekosaur> btu the standad typeclasses do't try to cover every possibility. semigrop + left identity doesn't get enough use to be standard
03:59:31 <geekosaur> kuribas, there's runghc, or ghc -e
03:59:56 <geekosaur> not sure a general scripting interface as opposed to main = ... gets you much
03:59:58 <kuribas> geekosaur: that still requires a 2GB install of haskell
04:00:06 <mlehmk> and class Semigroup a => LeftAbsorbing a where leftAbsorbing :: a -- | leftAbsorbing <> a = leftAbsorbing, if that even works
04:00:14 <geekosaur> so you want hugs back? :p
04:00:17 <Solonarv> kuribas: huh? haskell has an interpreted mode (that's what GHCi is), and runghc, and '#!/bin/env stack\n-- stack blah'
04:00:29 <dmwit> mlehmk: Sure, why not?
04:00:40 <kuribas> Solonarv: interpreted yes, lightweight no.
04:00:53 <dmwit> geekosaur, Solonarv: Have you intentionally misunderstood kuribas' wish?
04:00:54 <mlehmk> and with [a] -> NonEmpty a, the leftId is implemented by fromList
04:01:02 <geekosaur> not sure lightweight is really a thing, aside from hugs (lightbtu also kinda dumb these days)
04:01:10 <Solonarv> misunderstood yes, intentionally no
04:01:40 <dmwit> Hm. Perhaps it is I who has misunderstood.
04:01:43 <geekosaur> dmwit, 'lightweight' kinda isn't athing anymore except in terms of 'ships with every distribution. which is a different issue
04:02:01 <dmwit> dmwit-- for jumping to conclusions and yelling at others who didn't jump with him
04:02:16 <mlehmk> no worries
04:02:40 <dmwit> mlehmk: But fromList <> a /= a...
04:02:57 <mlehmk> actually it is
04:03:25 <mlehmk> you can try it yourself and in every case it works
04:03:29 <dmwit> mlehmk: e.g. (fromList <> fromList) [3] = fromList [3] <> fromList [3] = fromList [3,3] /= fromList [3]
04:03:32 <mlehmk> which can be proven even
04:03:37 <kuribas> geekosaur: but there isn't anything in the language itself that requires 2GB, is it?
04:03:52 <mlehmk> you did a mistake there
04:03:53 <geekosaur> depends on how much of "the language" you want
04:04:10 <dmwit> mlehmk: ghci agrees with me
04:04:24 <mlehmk> yeah, but you didn't show fromList <> a == a
04:04:32 <mlehmk> you did something different
04:04:37 <Solonarv> indeed - he *dis*proved it!
04:04:38 <dmwit> mlehmk: Correct. I showed that `fromList <> a /= a`.
04:04:48 <mlehmk> You showed that neither
04:04:56 <geekosaur> if you're wiling to stick to standard haskell, there's hugs. if you want all the newer stuff, yes you need something larger
04:04:59 <dmwit> mlehmk: Because in particular when `a = fromList`, `(fromList <> a) [3] /= a [3]`.
04:05:01 <mlehmk> you applied commutative law to semigroups... duh
04:05:10 <kuribas> geekosaur: I like "all of the language", but for scripting it could even be another language, but just with stronger safety garantuees than other scripting languages.
04:05:13 <geekosaur> and computers do not come with lazy evaluation runtimes wired into the cpu
04:05:19 <dmwit> mlehmk: ...what
04:05:26 <Solonarv> you're claiming "forall a. fromList <> a == a". dmwit showed "exists a. fromList <> a /= a", thereby disproving your claim.
04:05:49 <dmwit> mlehmk: Look, I just typed this into ghci: `let a = fromList in (fromList <> a) [3] == a [3]` and ghci told me `False`.
04:05:50 <mlehmk> Well, but fromList cannot be put right side either
04:06:02 <cppxor2arr> i want to have some packages installed and keep them up to date for using "stack ghci" globally outside any projects. i tried adding "clock" or "clock-0.7.2" to "packages:" in ~/.stack/global-project/stack.yaml but got this on running "stack.ghci":
04:06:03 <geekosaur> somene did ask about a "haskell shell" the other day, haven't seen one as such
04:06:05 <cppxor2arr> /home/cppxor2arr/.stack/global-project/clock-0.7.2/: getDirectoryContents:openDirStream: does not exist (No such file or directory)
04:06:33 <dmwit> mlehmk: That's okay, pick `a = const (3 :| [])` and the proof works exactly the same.
04:06:54 <mlehmk> that's an absorbing element
04:07:20 <dmwit> mlehmk: Can you please say what you believe the implementation of `(<>)` is for `[a] -> NonEmpty a`?
04:07:23 <Solonarv> mlehmk: you *are* talking about the Semigroup (a -> NonEmpty b) instance, right? just to clarify
04:07:25 <MarcelineVQ> cppxor2arr: stack ghci --package clock  is sufficient to add it to your global resolver, until you change resolver version
04:07:26 <dmwit> mlehmk: I feel as though we may not agree on that point.
04:07:38 <mlehmk> dmwit: \x y -> x . toList . y
04:07:39 <MarcelineVQ> Because it has to get and build clock to run that command
04:07:55 <cppxor2arr> thanks
04:08:17 <MarcelineVQ> But that error sounds like how you added it to stack.yaml is suspect, if anywhere it would go in the extra-deps section
04:08:25 <dmwit> mlehmk: Okay. That is not how the instance that ships with GHC works.
04:08:26 <MarcelineVQ> The can't find sounds like you added to packages maybe
04:08:39 <cppxor2arr> yeah i did
04:08:39 <mlehmk> dmwit, weird, as it did with when I tried it
04:08:57 <dmwit> mlehmk: It is also not a correct instance, because it is not total.
04:09:25 <Solonarv> mlehmk: the instance that ships with GHC is 'instance Semigroup b => Semigroup (a -> b) where f <> g = \x -> f x <> g x'
04:09:26 <dmwit> mlehmk: The instance that ships with GHC is `(f <> g) xs = f xs <> g xs`.
04:09:40 <geekosaur> also, the real problem ith a strongly typed shel i that it's interfacing to a system that's stringly typed
04:10:02 <mlehmk> ahh, there is the problem then
04:10:09 <geekosaur> and doesn't even know the difference between octet strings and utf8
04:10:51 <mlehmk> trying to disprove one semigroup with a different one, that behaves completely different
04:10:56 <dmwit> mlehmk: I'd like to pause in the argument here and make sure we don't proceed until we are in alignment on whether `\x y -> x . toList . y` is an acceptable Semigroup instance.
04:11:13 <dmwit> mlehmk: I claim it is not, okay? Convince me otherwise.
04:11:32 <mlehmk> S([a] -> NonEmpty a, \x y -> x . toList . y) to be exact
04:11:38 <dmwit> (Or I'm happy to switch roles, but not positions: you claim it is and I'll convince you otherwise.)
04:11:56 <dmwit> mlehmk: I make no objection to this clarification.
04:12:02 <mlehmk> sure thing
04:12:38 <mlehmk> this is implemented in Data.List.NonEmpty I think or Data.Semigroup, one of the two has (<>) x y = x . toList . y
04:13:19 <mlehmk> and I agree, it is incomplete
04:13:36 <Solonarv> that would overlap with the general Semigroup (a -> b) instance, so I certainly hope not!
04:13:49 <mlehmk> cause in that class? fromList is an incomplete left identity element thing
04:14:08 <dmwit> Hold on, hold on.
04:14:31 <mlehmk> cause putting it like a right identity can cause errors
04:14:35 <MarcelineVQ> What instance is this in what module?
04:14:48 <dmwit> I'd like to object to one thing at a time. There are three things on the table that I object to, but we gotta start slow. (1. "this is a law-abiding instance" 2. "this instance is provided in the libraries" 3. "this instance is incomplete")
04:15:33 <dmwit> Okay, you've convinced me that 1. is okay. (Strenuous work you had there, I know. I was wrong, and just understood why.)
04:15:50 <dmwit> So now for 2. What evidence do you have that this instance is provided by the standard libraries?
04:15:53 <MarcelineVQ> toList is part of the NonEmpty Monad
04:16:15 <mlehmk> for 2. it is in either Data.List.NonEmpty or Data.Semigroup
04:16:22 <dmwit> Prove it.
04:16:29 <dmwit> (It ain't here.)
04:16:48 <dmwit> (I've got them both imported, and `(<>)` behaves the way I described above, not the way you describe.)
04:17:51 <Solonarv> (additionally, that would overlap with the instance for (a -> b), and overlapping like that is verboten)
04:17:58 <MarcelineVQ> Both of the Semigroup instances for NonEmpty go to http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-324  With Semigroup (a -> b) right below it for easy perusal
04:19:06 <MarcelineVQ> *Both the links for the Semigroup instance for NonEmpty
04:21:51 <delYsid> How do I tell haskell-mode that it should *not* use unicode to display types in the minibuffer?
04:21:52 <MarcelineVQ> I keep forgetting stimes is a thing
04:26:11 <mlehmk> Ahh, I see there is something wrong
04:27:35 <mlehmk> (<>) isn't what I thought it is
04:28:48 <mlehmk> I'd have to first implement a new Semigroup over [a] -> NonEmpty a with a new operation (<>) for it
04:30:18 <mlehmk> so roughly a Semigroup (Monoid -> Semigroup) thing
04:30:40 <lavalike> :t (<>)
04:30:41 <lambdabot> Monoid m => m -> m -> m
04:30:58 <mlehmk> cause operating on NonEmpty ([a] -> NonEmpty a) actually
04:32:01 <dmwit> mlehmk: Sure, you could write `newtype Conjugated a = C ([a] -> NonEmpty a); instance Semigroup (Conjugated a) where C f <> C g = C (f . toList . g)`.
04:32:41 <dmwit> mlehmk: Okay, so we've made it through (1) and (2). I was wrong on (1), you were wrong on (2). Tiebreaker round: if I write the instance I described there for `Conjugated`, that instance isn't "incomplete".
04:33:31 <mlehmk> an example for one is: a = (3:|)
04:33:39 <mlehmk> that's one element
04:33:59 <dmwit> What is `a` an example of there?
04:34:11 <mlehmk> a is an example for the Conjugated Num
04:34:21 <dmwit> Sure.
04:35:01 <mlehmk> and I'd like: a <> a = \x -> (3:|(3:|x))
04:36:20 <mlehmk> no, not exactly
04:36:37 <mlehmk> I mean like, (3<|(3:|x))
04:36:44 <dmwit> Yep, no problem so far.
04:37:26 <mlehmk> and in this case a fromList <> a would effectively be a
04:38:31 <mlehmk> a <> fromList however is not defined for every case
04:41:15 <Solonarv> hmm... C fromList <> C g = C (fromList . toList . g) = C g -- because fromList . toList = id , for NonEmpty
04:41:33 <mlehmk> mhm, but error in case of []
04:41:52 <mlehmk> which can happen if fromList was right hand side
04:42:21 <Solonarv> right, so basically fromList isn't a valid member of C a if you only want total members
04:43:13 <mlehmk> well, I could define an element which behaves as identity if left hand side, but does something different but valid when it is on the right hand side, like a special case for []
04:44:03 <dmwit> I agree with everything you've said so far.
04:44:09 <mlehmk> I first thought it'd break the law a * (e * a) == (a * e) * a
04:44:24 <Solonarv> you can't define one that works for every choice of 'a', but you can for many concrete choices, yes
04:44:31 <mlehmk> but thinking about it, it doesn't break that law
04:44:39 <dmwit> (Indeed, your observation about empty lists shows that there are many left identities.)
04:45:14 <mlehmk> so yes, for this special Semigroup, left identities exist
04:45:22 <mlehmk> and yet, it isn't a Monoid
04:48:00 <Taneb> mlehmk: because this isn't the case for all semigroups, this shouldn't be added to the Semigroup class, which I think is what you were proposing
04:48:50 <mlehmk> You're right
04:49:42 <mlehmk> it's just realizing, just cause a Semigroup has a kind of an identity element, it isn't automatically a Monoid
04:50:27 <mlehmk> a Semigroup that has the same identity element as left and right identity is a Monoid
04:50:45 <Taneb> Yes, that is correct
04:52:03 <Taneb> In fact, if a semigroup has a left identity and a right identity they must be the same, so it must be a monoid if this is the case
04:52:20 <Solonarv> (and in that case there is also only one identity)
04:52:38 <mlehmk> I wonder if it is possible to construct separate left and right identities in a Semigroup
04:52:41 <Taneb> It is not
04:52:44 <Taneb> I can prove this
04:53:05 <Taneb> Assume that x is a left identity for a semigroup S, and y is a right identity
04:53:13 <Taneb> We have x <> y == x <> y
04:53:27 <Taneb> Because x is a left identity, we get y == x <> y
04:53:36 <Taneb> Because y is a right identity, we get y == x
04:53:49 <Taneb> So x and y are the same and both a left and right idenity
04:54:11 <mlehmk> wow, I hope there isn't a hidden division by zero in that
04:54:20 * dstolfa finds the <> notation in Haskell hopelessly confusing as to why it was picked
04:54:29 <mlehmk> that looks like one of those 1 == 2 proofs at first
04:54:34 <dstolfa> mlehmk: it doesn't matter even if there is
04:54:40 <dstolfa> mlehmk: we can define x / 0 = x and have it be sound
04:54:45 <dstolfa> because it doesn't become the multiplicative inverse
04:54:57 <dstolfa> i just find the <> ridiculous
04:55:12 <Taneb> mlehmk: I just use the property that they are left and right identities respectively
04:55:20 <Taneb> I don't even use associativity
04:55:23 <mlehmk> that is true
04:55:43 <dstolfa> well, i meant to say x / 0 = 0, but we could define it x / 0 = some fixed x
04:55:44 <dstolfa> not forall x
04:55:45 <dstolfa> :-)
04:56:24 <mlehmk> and if you define it like x / 0 = sx, you could xs * 0 = x
04:56:28 <mlehmk> sx even
04:56:36 <dstolfa> mlehmk: no
04:56:56 <Solonarv> dstolfa: what notation would you prefer? it should be an operator (for conciseness / less visual noise), and for the same reason it shouldn't be too long
04:56:56 <dstolfa> mlehmk: because defining x / 0 = 0 (or sx) doesn't imply that you can treat it as the multiplicative inverse
04:56:58 <dstolfa> you have to prove that
04:57:02 <dstolfa> it doesn't just magically hold
04:57:08 <mlehmk> well, yes, as for * the 0 is supposed to be the absorbing element
04:57:19 <dstolfa> mlehmk: except you have to prove that
04:57:21 <dstolfa> mlehmk: and you can't this way
04:57:30 <dstolfa> Solonarv: well, we're talking about a semigroup here right?
04:57:31 <mlehmk> it is an axiom
04:57:46 <Solonarv> indeed
04:57:51 <Taneb> mlehmk: prove that dstolfa is using the same / as you
04:57:57 <dstolfa> Solonarv: perhaps something akin to 'o' or '.'
04:58:25 <Solonarv> 'o' is not an operator in haskell syntax, '.' is taken by function composition
04:58:32 <dstolfa> i know :-), hence akin to
04:58:49 <dstolfa> the reason i find <> confusing is because of ML's use of <> for not equals
04:58:49 <mlehmk> you could still use like (<.>) or (<++>)
04:59:36 <Solonarv> see, I find (<>) being used for not-equals confusing
04:59:37 <dstolfa> Solonarv: it's a bit unfortunate really, but i appreciate that symbols are hard :-)
05:00:18 <mlehmk> Well, his / is not the a * b = c, c / b = a, c / a = b thing
05:00:20 <dstolfa> Solonarv: i mean, to your point, ML also uses "andalso" and "orelse" as an operator
05:00:32 <Solonarv> and confused! <> for not-equals arises from "greater-than or less-than", but there are types which support inequality but not ordering
05:00:50 <dstolfa> mlehmk: it is, you just can't axiomatise that x / 0 = 0 implies that the divisor 0 is 0- for multiplication
05:00:55 <dstolfa> you have to prove it
05:01:04 <dstolfa> in fact, you can prove that x / 0 = 0 is a sound definition
05:01:11 <dstolfa> it's been done many times
05:01:14 <dstolfa> many proof assistants define it that way
05:01:32 <dstolfa> fire up isabelle or coq and try to evaluate something like 2 / 0
05:01:33 <mlehmk> well, for any x where x /= 0, you cannot solve 0 * 0 = x
05:01:40 <dstolfa> yes, that's correct
05:01:44 <dstolfa> and that's fine
05:01:52 <dstolfa> you're defining division, not the multiplicative inverse
05:01:58 <mlehmk> so x should be 0 in that case
05:02:04 <mlehmk> so far so sound
05:02:04 <dstolfa> no
05:02:07 <dstolfa> it shouldn't
05:02:17 <mlehmk> I know it's wrong, but still kinda sound
05:02:23 <mlehmk> let me show how it's wrong
05:02:48 <dstolfa> if you're going to write out a proof of 1 = 2, let me spare you the time: you can't multiply by 0
05:02:54 <mlehmk> like that a * b = c is c / a = b for example, and a and b are both 0 in this case
05:03:11 <mlehmk> then 0 * 0 = x, cause x / 0 = 0
05:03:15 <dstolfa> again, no
05:03:17 <dstolfa> you can't do that
05:03:38 <mlehmk> mmm... that went backwards
05:03:39 <dstolfa> the only time you can use something as a multiplicative inverse is when you can prove that it is one
05:03:40 <merijn> Sure you can, just not in the reals :)
05:03:53 <dstolfa> you can't prove that 0 is one for the case of x / 0 = 0
05:03:57 <merijn> (or complex, afaik?)
05:04:04 <dstolfa> so you can't use it as one
05:04:24 <mlehmk> No, I wanted to go different. Assuming x is 0, then you'd need to get 0 from 0 / 0
05:04:33 <mlehmk> let me show, that 0 / 0 is not defined
05:05:36 <mlehmk> just using a * b = c equivalent to c / a = b, and we want 0 / 0 = x, then c = 0 and a = 0 and b = x, putting it into the multiplication, 0 * x = 0
05:05:54 <lavalike> I was thinking: in general it's better to return IO () and let the caller async/withAsync it if they need to, versus returning IO (Async ()), what could be reasonable circumstances to make IO (Async ()) functions that you can think of?
05:05:57 <mlehmk> x can be any real number in that case, it is therefore not defined
05:06:20 <dstolfa> mlehmk: again, you are completely missing the point
05:06:35 <merijn> lavalike: I don't think there is one. I'd rather get "IO (IO ())" so I'm free to pick what to do and when
05:06:49 <merijn> lavalike: Also, note that those two have slightly different semantics
05:06:50 <Solonarv> mlehmk: what you're saying is valid as long as we're confined to (complex | reals | rationals) with the usual notions of (+ | * | /), but isn't if you're talking about any (semigroup | monoid | group | field)
05:07:01 <merijn> lavalike: To return an "Async" the IO action must already be running
05:07:05 <mlehmk> maybe you confuse this woth 0 ** 0 = 0 is a sound definition, as is 0 ** 0 = 1
05:07:13 <merijn> lavalike: Whereas with the "IO ()" return I get to pick when it starts
05:07:20 <lavalike> merijn: good point
05:07:22 <dstolfa> the only thing that defining `forall x . x / 0 = x' is saying is that if you divide by 0, you get 0. that doesn't necessarily mean you can prove that you can do `x / 0 * 0 = 0 * 0' and arrive at `x = 0 * 0'
05:07:30 <dstolfa> you need to prove that this is true
05:07:31 <dstolfa> and it's not
05:07:35 <dstolfa> you can't prove it under the definition above
05:07:49 <Solonarv> well, there's a fork :: IO () -> IO (Async ()) somewhere (which basically just gives back an Async () instead of a bare ThreadId)
05:07:52 <merijn> lavalike: So for APIs, definitely return IO (). Inside your application, it depends. Maybe returning Async is easier, then do that
05:07:54 <dstolfa> whereas you CAN prove that just defining `forall x . x / 0 = x' is sound in the sense that it lets you prove true theorems
05:08:07 <mlehmk> so in that case * and / are distinct and cannot solve the other
05:08:08 <dstolfa> this is why most proof assistants define `forall x . x / 0 = 0'
05:08:16 <lavalike> merijn: I thought it would be, in multiple places, ended up rewriting it so that things return IO and it's nicer now
05:08:17 <merijn> Solonarv: Not sure how that's relevant?
05:08:18 <dstolfa> mlehmk: yes. in the case where you have 0
05:08:25 <dstolfa> mlehmk: which is why it's sound to define it as such
05:08:30 <mlehmk> once you add the definition of 0, they are distinct
05:09:01 <dstolfa> mlehmk: yes, and that's fine. the multiplicative inverse isn't necessarily the divisor
05:09:05 <merijn> lavalike: I think it's similar to exceptions vs Either/Maybe. In libraries/APIs you want to give the most control to the user (i.e. don't use exceptions in library APIs (unless you also provide a non-throwing alternative))
05:09:28 <Solonarv> it's an example of a function that returns IO (Async ()); perhaps your function forks something and a non-forking version doesn't make sense
05:09:44 <mlehmk> so in that case, it is just confusing to be written as /
05:09:47 <lavalike> merijn: yeah! I agree, it even applies to the async package, I'm always checking whether I'm using something that will explode on me or not :D
05:09:54 <dstolfa> mlehmk: / is confusing anyway
05:09:59 <merijn> Solonarv: My point is that *creating an Async* already forks something
05:10:13 <mlehmk> I see / as an inverse of *
05:10:20 <dstolfa> but it's not
05:10:29 <merijn> Solonarv: So the IO action is already running by the time you can return an Async. Which is annoying as library user, when I want to control when it starts running
05:10:31 <dstolfa> because not even in the situation you're describing can you prove that for 0
05:10:39 <dstolfa> it's just undefined because ZFC set theory doesn't talk about it
05:11:06 <merijn> lavalike: Async itself shouldn't throw unless the thing you're running with it throws
05:11:19 <mlehmk> if I invert a * 0 = 0, I get 0 / a = 0, a left absorbing element
05:11:32 <mlehmk> into a right absorbing element
05:11:41 <dstolfa> mlehmk: but again, that's not true for the case of `x / 0 = ??'
05:12:06 <dstolfa> precisely because it's undefined and ZF set theory not talking about it lets us define it to be anything we want
05:12:15 <dstolfa> and it turns out that `forall x . x / 0 = x' is very convenient
05:12:16 <mlehmk> for the case x / 0 = ??, I'd have to invert differently
05:12:23 <mlehmk> actually...
05:12:31 <dstolfa> argh, i wrote x again
05:12:36 <dstolfa> `forall x . x / 0 = 0' :-)
05:12:38 <lavalike> merijn: the wait functions
05:12:44 * dstolfa needs to stop doing 5 things at once
05:13:04 <merijn> lavalike: wait only rethrows whatever gets thrown inside the IO action
05:13:08 <mlehmk> x * 0 = x can be inverted into x / 0 = x and x / x = 0
05:13:16 <merijn> lavalike: i.e. if the IO you run via async never throws, neither does wait
05:13:26 <mlehmk> which contradicts, that the fact x / x for x /= 0 is 1
05:13:27 <lavalike> merijn: that happened to me with "thread locked indefinitely on stm action"
05:13:45 <lavalike> merijn: thanks for shedding light on this
05:13:46 <merijn> lavalike: That means your STM code deadlocked
05:14:23 <lavalike> I thought the reason was I did a withAsync (codeusingstm) $ \_ -> ..
05:14:27 <dstolfa> mlehmk: yeah things get a bit more broken for `forall x . x / 0 = x', as you're quantifying forall. however, in `forall x . x / 0 = 0', which is what i MEANT to write, you can't multiply by 0 and cancel out the division
05:14:27 <mlehmk> actually, the only solution to n * x = n, is x = 1, for n /= 0 again...
05:14:33 <dstolfa> it doesn't matter what your intuition is
05:14:36 <dstolfa> what matters is what the logic tells you
05:14:40 <merijn> lavalike: "locked indefinitely on stm action" means "this atomic block is retrying (for example due to a TVar condition being false), but no one else has a reference to update the TVar!"
05:14:42 <dstolfa> and the logic doesn't speak about division by 0
05:14:49 <dstolfa> so if we define it to be something
05:14:51 <mlehmk> actually, group theory alone is enough to show something is wrong
05:14:55 <lavalike> merijn: I'm using 2 TQueues
05:15:01 <dstolfa> we have to show that it's a sound definition, i.e. if |- P ==> |= P
05:15:02 <lavalike> (and nothing else)
05:15:12 <dstolfa> mlehmk: it's not
05:15:28 <dstolfa> mlehmk: because using rings, you can show that it's fine
05:15:37 <dstolfa> you can go look it up 
05:15:44 <dstolfa> but i have no time to discuss this anymore unfortunately, as much as i'd like to
05:15:48 <dstolfa> i have to go refactor some bs
05:15:56 <mlehmk> okay, better it is
05:16:07 <merijn> lavalike: Suppose you have 2 async's accessing those queues. One of those always reads from queue 1 and the other is the only one writing to queue 1. Now the second one finishes (i.e. never writes to queue 1 anymore), the other thread is stuck forever trying to read from the TQueue
05:16:30 <lavalike> merijn: right
05:16:33 <merijn> lavalike: GHC can (sometimes) detect these deadlocks and will (in those cases) helpfully async except your code, rather than make you wait forever
05:16:44 <merijn> lavalike: So the proper solution is: Make sure your code doesn't deadlock ;)
05:17:12 <merijn> You might want to add a TVar that signals when a queue is permanently closed
05:17:37 <merijn> (Alternatively, if you don't specifically need STM, I have a library with closable channels)
05:17:39 <lavalike> I haven't thought about what happens when queues close
05:17:57 <lavalike> I never actually close them manually
05:18:02 <merijn> (I plan to at some point at STM variants, but haven't gotten around to it)
05:18:28 <lavalike> merijn: so say the writing thread dies, what happens?
05:18:48 <merijn> lavalike: the reading thread gets stuck forever, followed by sadness from you :)
05:18:55 <lavalike> I guess I could just avoid it ever dying
05:19:14 <lavalike> its writing is tied to reads from a tcp connection, so just reconnect in a loop
05:19:20 <merijn> lavalike: Or bracket the channel process with "TVar Bool" that indicates whether it's still alive
05:19:32 <lavalike> the whole thing doesn't need to work if the tcp connection dies anyway
05:19:37 <merijn> lavalike: So that when the thread dies it sets the TVar to False (as in, channel dead) and have the reader check that
05:19:58 <merijn> Actually. Thank you, excellent point this!
05:20:37 <merijn> I need to add "withChan :: (Chan a -> IO b) -> IO b" to my library that auto-closes the channel when an exception gets thrown!
05:20:45 <lavalike> that's nice
05:21:00 <merijn> That's a brilliant addition
05:21:52 --- mode: glguy set +v zincy
05:22:20 <lavalike> ^___^
05:22:34 <merijn> lavalike: What are you using these queues for?
05:23:42 <lavalike> merijn: the tcp connection speaks 1 protocol, a first module handles it and produces haskell data in another protocol, a SECOND module has a pair of threads & queues handling this other protocol and processing it into a SECOND protocol, the application uses this one to do its things
05:24:20 <merijn> So basically just translating and forwarding 1 protocol into another?
05:24:24 <lavalike> yes
05:24:31 <lavalike> in both read and write directions
05:24:32 <merijn> Would it maybe make sense to use conduit/pipes/machines instead?
05:24:41 <lavalike> I have no idea
05:24:46 <merijn> hmm
05:25:02 <infinisil> Probably
05:25:31 <lavalike> this is not the *only* think this will do, it's just the start, I think it'll need to get events from the user too, for example
05:25:37 <lavalike> s/think/thing/
05:25:50 <locallycompact> Does anyone here use obelisk?
05:25:56 <lavalike> (as well as events from timers)
05:26:04 <locallycompact> Struggling to get basic reflex tutorials working with obelisk
05:26:23 <locallycompact> https://github.com/obsidiansystems/obelisk/issues/292
05:26:33 <zincy> Is there a simple way of debugging the resulting bash command string which is used when I apply readProcessWithExitCode
05:26:38 <Solonarv> lavalike: do these things need to happen in parallel? somewhat relatedly, do conduit & friends parallelize "for free"?
05:26:52 <lavalike> atomically $ asum [ ProtocolEvent <$> .., UserEvent <$> .., TimerEvent <$> .. ] is how I was planning to handle these
05:26:56 <merijn> zincy: Debugging in what sense?
05:27:16 <lavalike> Solonarv: I don't really know anything about conduit & friends, and yes they need to happen in parallel for my use
05:27:17 <zincy> I am trying to run a shell command with certain args
05:27:23 <merijn> Solonarv: No, but I do have a library for running a conduit in parallel :p
05:27:31 <merijn> Solonarv: So it's almost free now ;)
05:27:32 <zincy> I would like to see the resulting command which is called by System.process
05:27:42 <Solonarv> merijn: link?
05:28:00 <merijn> Solonarv: https://hackage.haskell.org/package/broadcast-chan-conduit
05:28:38 <merijn> Solonarv: Lemme know if you have any feedback/comments on the API. It's been working pretty great in my own projects
05:29:06 <geekosaur> zincy, it's not using bash
05:29:13 <geekosaur> unless you do
05:29:15 <merijn> I haven't really optimised it, so maybe the overhead is too much for super short IO tasks, but if have IO actions that take, say, 0.5 second and up it should definitely help
05:29:17 <zincy> oh what is it using then?
05:29:25 <merijn> zincy: The system shell, whatever that happens to be
05:29:26 <geekosaur> executeFile
05:29:31 <merijn> geekosaur: Not necessarily
05:29:44 <merijn> geekosaur: Depends on the CreateProcess configuration
05:30:15 <geekosaur> readProcessWithExitCdoe doesn't give you access and the documentation points at RawCommand
05:30:56 <merijn> geekosaur: Ah, that's what I get for assuming readProcessWithExitCode uses CreateProcess :)
05:31:24 <geekosaur> it does under the covers, but is documented as using the RawCommand whih doesnt' go through the shell
05:32:00 <Solonarv> I've never had a need for a library of that kind, so to be honest I don't have any feedback on it
05:32:38 <merijn> Solonarv: I meant more in the sense of "if you ever use it and have comments" not in a "look at the API and guess" ;)
05:32:48 <Solonarv> haha, fair enough
05:34:19 <geekosaur> it uses the exec syscall and passes the arguments exactly as specified. the executable name is as per https://downloads.haskell.org/~ghc/latest/docs/html/libraries/process-1.6.3.0/System-Process.html#v:RawCommand
05:35:05 <delYsid> hmm, how do I handle include directives in a parser?
05:36:33 <lavalike> merijn: in the diagram I designed, can the deadlock happen the other way around? I.e. on the writing queue going down into the TCP connection.
05:36:38 <merijn> delYsid: CPP style includes or things like "import"?
05:37:03 <merijn> lavalike: Eh, which diagram? :)
05:37:29 <lavalike> merijn: Main <==> Module2 <==> Module1 <==> Server
05:37:58 <lavalike> where <==> represents a pair of threads & queues to process and read/write up and down a protocol
05:38:23 <delYsid> merijn: Hmm, I am not sure.  I am guessing CPP style includes.
05:38:47 <lavalike> anything that writes, if it dies, locks a reader
05:39:12 <lavalike> (since everybody only reads and writes to 1 other thread)
05:39:56 <Solonarv> depending on your use case: run the input through a preprocessor *first*, just skip them, or do something fancy
05:40:20 <merijn> delYsid: You'll have to do some preprocessing. i.e. first parse the file as [Token] with "data Token = Include FilePath | Line String", then read all files, flatten everything into a single piece of text, then parse that
05:41:12 <delYsid> gah, I was hoping there was some sort of nested IO trick :-)
05:41:43 <merijn> lavalike: Consider using closable channels and/or having a single TVar that indicates the connection has died for each pipeline. Change all the reads from queues to also check that error condition
05:41:44 <geekosaur> nto easily, if it's actually cpp style, because cpp doesn't actually care about the language syntax
05:41:46 <lavalike> well if you are using Parsec you can do IO :D
05:41:59 <merijn> delYsid: Well, you could write a parse for [IO String] instead
05:42:07 <lavalike> merijn: hmpf
05:42:15 <merijn> delYsid: Where you do "return line" for the regular case and "readFile path" for the includes
05:42:17 <Solonarv> if you're free to choose the syntax, the cheeky answer is "use the C preprocessor's syntax and call out to that first"
05:42:21 <merijn> delYsid: Then sequence the whole thing
05:42:36 <geekosaur> you can do #include in the middle of random language constructs, which is rather painful to handle directly
05:42:49 <geekosaur> (but can be done if you must)
05:43:00 <merijn> lavalike: I mean, realistically the best answer is "don't do textual includes at all"
05:43:23 <lavalike> that's delYsid 
05:43:27 <merijn> eh
05:43:35 <geekosaur> it's much easier fi you let a tokenization step process the includes so the lanuage parser doesn;t have to deal with includes in random places
05:43:36 <merijn> s/lavalike/delYsid
05:43:40 <lavalike> I was just annoyed that a couple TQueues don't quite do it :)
05:44:17 <delYsid> I am parsing an existing file format, so no liberty in "this I shit, I do it differently"
05:45:46 <lavalike> I find recursively calling the parser you're defining a fun idea to try
05:46:16 <merijn> lavalike: Just define "Parser (Parser a)" and join the result :p
05:46:30 <lavalike> you and your combinators
05:46:41 <Solonarv> probably works fine if you don't need to handle #include - equivalents inside of language constructs
05:49:09 <delYsid> Parser (Parser a) was actually kind of like what I was thinking of.  But I still have no intution how that should work.
05:52:02 <Solonarv> roughly: eat some input to make a Parser a, which will eat more input to finally give you an a
05:52:22 <Solonarv> I'm not entirely sure how that's helpful for processing #include-equivalents, though
05:54:14 <merijn> Solonarv: Only works if your parser is a MonadIO instance in that case
05:54:27 <merijn> Although, actually, then you don't need to nest
05:54:27 <Solonarv> ah, right
05:54:51 <merijn> or do you? hmm
05:55:04 <delYsid> ah, MonadIO, that gets me thinking.
05:57:59 <dmwit> join @Parser is generally concatenation of languages, not nesting of languages.
06:00:44 <Ariakenom> lavalike: did you have a problem with just 2 TChans?
06:01:31 <merijn> Ariakenom: That allows the same deadlock
06:01:51 <merijn> Well, technically this'd be "starvation", rather than deadlock, but still
06:06:16 <Ariakenom> Right, but was that actually a problem? Maybe I missed that bit
06:07:41 <merijn> Ariakenom: Yes, the problem was "writer dies, reader stuck forever"
06:11:23 <Ariakenom> but shouldn't the reader just die too?
06:11:31 <merijn> Ariakenom: How?
06:11:46 <merijn> You need to somehow tell it to die
06:12:32 <Ariakenom> Oh I thought it was dying from locked-indefinitely
06:14:58 <__monty__> merijn: Have the writer write a heartbeat?
06:16:08 <merijn> Ariakenom: Right now it is, but that's not guaranteed
06:16:21 <merijn> Ariakenom: If you made the code more complex GHC might not be able to detect that
06:16:47 <merijn> blocked indefinitely on MVar/STM exceptions are GHC *courtesies*, they are not and cannot be guaranteed
06:17:04 <merijn> So if you ever encounter them, the right solution is to fix the root cause properly
06:17:25 <Ariakenom> makes sense. I just thought you were trying to solve the "getting exception bit". But making sure to get the error makes sense
06:18:23 <lavalike> Ariakenom: it did die by stm exception of infinite lock
06:18:38 <lavalike> oh yeah what merijn said (:
06:19:46 <hodapp> Death by STM Exception of Infinite Lock sounds ominous.
06:20:03 <lavalike> lol
06:20:14 <merijn> lavalike: You can probably use async's stuff to make sure that when one thread dies everyone dies
06:20:36 <lavalike> merijn: did you just find a way to legitimize returning Asyncs
06:20:51 <merijn> You can try doing it yourself, but that's...hairy business
06:21:15 <Ariakenom> "race reader writer" async is nice
06:21:26 <merijn> lavalike: More like, recommend using withAsync ;)
06:21:37 <lavalike> but how do you do that from different modules
06:23:14 <lavalike> oh I *am* using race_ in each of the two modules (:
06:27:00 <ggVGc> merijn: sounds a lot like an OTP supervisor ;)
06:27:06 <Ariakenom> lavalike: can you add a root for the threads. a tree structure for threads is nice
06:27:17 <ggVGc> sounds even more like OTP
06:27:20 <Ariakenom> :)
06:27:58 <merijn> ggVGc: Well, yes
06:28:16 <merijn> ggVGc: It's not too hard to build something like that on top of forkIO
06:29:07 <lavalike> hm
06:29:41 <hodapp> "reinvent OTP", they said. "it'll be easy."
06:40:41 <merijn> hodapp: I mean, a more elaborate version of async with OTP style functionality would be a super-cool addition to the Haskell ecosystem
06:41:17 <Ariakenom> What are the juicy features? I'm not familiar with OTP, only heard of it
06:41:44 <merijn> Ariakenom: A sort of "just crash on error" mentality with supervisors taking care to handle crashes and restart tasks
06:43:12 <lavalike> https://www.erlang-in-anger.com
06:47:03 <c_wraith> async needs better tools for "if this dies, kill all its children"
06:47:11 <c_wraith> You can write it, but it's awkward
06:47:19 * dstolfa thinks it would be cooler if haskell had a DSL in it for pi calculus
06:47:36 <lavalike> c_wraith: it's just withAsync right?
06:48:29 <c_wraith> No, that's the other direction
06:49:19 <c_wraith> there's lots of stuff for "if the child dies, kill the parent"
06:49:31 <lavalike> ah the various waits
06:51:21 <Ariakenom> oh withAsync doesn't do that? I would've expected that
06:52:06 <c_wraith> withAsync raises exceptions from the execution of the Async, but it doesn't kill the execution of the async if the parent raises an exception
06:53:19 <c_wraith> link2 is the closest to what I want, but it is very awkward to use in a parent/child relationship.  The parent somehow has to know its own Async value to use it.
06:53:23 <lavalike> «withAsync is like async, except that the Async is automatically killed if the enclosing IO operation returns before it has completed.»
06:53:30 <lavalike> doesn't this mean kill the children if the parent dies?
06:54:06 <c_wraith> Huh, I totally misread that.  You are right.
06:54:06 <lavalike> I guess enclosing means something else
06:54:09 <lavalike> o
06:54:43 <c_wraith> Then the only problem is that you are stuck with the bracket pattern.  Codensity it all, I guess!
06:56:04 <jose_zap> there's also cloud haskell for OTP like architectures, anyone tried it before?
06:56:52 <c_wraith> cloud haskell is like the multiple nodes with message passing portion of erlang/otp.
06:57:03 --- mode: glguy set +v mreh
06:57:55 --- mode: glguy set -v mreh
07:02:37 <max3> i'm using the haskell layer with spacemacs. does anyone know how to restart intero (not the shell but the buffer integration) after changing package.yaml
07:03:14 <max3> SPC m i r
07:03:56 <cocreature> capataz might be worth mentioning when it comes to OTP in Haskell but I’ve not used it myself
07:04:46 <max3> does anyone know how to make the intero tooltip popup instead of waiting
07:07:58 <max3> is there no way to drop into a different monad in a do without implementing a transformer?
07:08:27 <max3> eg using a let?
07:11:56 <Rembane> max3: Any monad? Or a specific one?
07:12:23 <max3> Rembane, any? i'm just curious about how locked into the type chain i am when using bind/do/<--
07:12:41 <merijn> max3: No, because that doesn't really make sense?
07:12:52 <merijn> max3: do is just syntactic sugar for nested >>=
07:13:00 <cocreature> you can totally use a do block for a completely different monad in a let binding
07:13:00 <max3> yes i understand that
07:13:02 <Rembane> max3: There are a family of monads that have a run-function that unlocks you, and then there are some other monads which you can pattern match on.
07:13:12 <cocreature> the question is how you use the binding you define that way
07:13:23 <cocreature> and that’s not something that you can answer in general
07:13:38 <c_wraith> max3: I mean, that's what Monad *is*.  A pattern for composing computations that deal with the *same* structure.
07:13:59 <c_wraith> max3: if you want to deal with multiple different structures, you're no longer in monadland
07:14:35 <max3> c_wraith, sure but for example, in my elementary understanding (so far), transformers are exactly for use cases where i have different (though complementary) structures
07:14:53 <lavalike> :t (>>=)
07:14:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:15:01 <max3> yes
07:15:02 <lavalike> same m all the way through
07:15:07 <cocreature> transformers combine the effects of two Monads in a single structure
07:15:12 <max3> yes
07:15:26 <lavalike> so (>>=), hence `do', can't change m
07:15:35 <max3> lavalike, yes i know that
07:15:49 <lavalike> I would say that's pretty locked in to the type
07:16:10 <max3> cocreature, combine and delegate are two ways to solve this problem
07:17:43 <cocreature> not sure what you mean by “delegate” here
07:17:49 <c_wraith> Sometimes you don't need a transformer, though.
07:19:05 <c_wraith> It's not uncommon for me to use a do block for type `m1' inside a do block for type `m2' - it's just about using a combinator that makes the types work together properly
07:19:29 <c_wraith> As with all Haskell.  Follow the types.  They're there to do the bookkeeping for you.
07:22:26 <delYsid> where is manyTill?
07:24:17 <jose_zap> https://www.haskell.org/hoogle/?hoogle=manyTill delYsid 
07:25:35 <cocreature> if you want even more options https://hoogle.haskell.org/?hoogle=manyTill
07:27:22 <lavalike> Text.Parsec.Combinators
07:27:24 <lavalike> -s
07:27:35 <delYsid> yeah, but I need it in megaparsec
07:27:41 <delYsid> (or, I think I do)
07:28:11 <cocreature> delYsid: it’s in parser-combinators not in megaparsec
07:28:24 <cocreature> protip: you can use package:megaparsec in hoogle, e.g., https://hoogle.haskell.org/?hoogle=manyTill%20package%3Amegaparsec
07:28:58 <cocreature> but megaparsec has basically no combinators, they all come from parser-combinators
07:29:09 <delYsid> k, tnx
07:29:11 <lavalike> I didn't know that
07:29:30 <lavalike> why aren't the modules links here? http://hackage.haskell.org/package/megaparsec
07:29:52 <MarcelineVQ> lavalike: http://hackage.haskell.org/package/megaparsec-7.0.2/docs/Text-Megaparsec.html#g:1
07:30:09 <lavalike> o_O
07:30:20 <cocreature> lavalike: because the docs builder hasn’t yet built the docs for the newest version
07:30:34 <lavalike> I was feeling short-changed there, makes sense
07:30:35 <MarcelineVQ> delYsid: in short if you have Text.Megaparsec imported, manyTill is already available
07:30:58 <cocreature> people should just upload docs themselves but the tooling for that is sufficiently shitty that I don’t blame people that don’t
07:31:06 <lavalike> ^____^
07:44:17 <merijn> cocreature: It's not so bad now, is it?
07:44:26 <merijn> Used to be a lot worse
07:44:46 <merijn> cocreature: new-haddock + manually running "cabal upload -d" works just fine here
07:45:55 <shapr> What's the suggested XML library these days?
07:46:05 <merijn> shapr: Depends
07:46:16 <cocreature> merijn: right but that’s only usable since 2.4, it’s still an extra step that you need to perform manually and not the default, it doesn’t default to building docs of deps so you don’t get hyperlinks by default, …
07:46:19 <merijn> shapr: Do you have actually structured XML with a schema and need validation?
07:46:31 <shapr> merijn: I want to generate XML to match a schema
07:46:33 <cocreature> so while things have definitely improved it’s still stupid that this is something that users need to actively think about at all
07:46:45 <merijn> cocreature: Sure
07:47:30 <shapr> I want to convert YAML or something else into XML, this tool's xml input is not especially fun to write.
07:48:25 <shapr> merijn: any suggestions?
07:48:36 <merijn> shapr: Not really, I've only done scraping of messy xml
07:48:48 <shapr> ok
07:50:26 <lavalike> in go there are nice tools to do this, you feed it an example and it generates the various types needed with their struct tags https://github.com/miku/zek
07:50:36 <cocreature> shapr: xmlbf might be worth a look, it’s basically aeson for xml
08:01:24 <vilu> Hey, I'm trying to get used to emacs. I'm trying to understand why I'll only see the function signature when selecting a function from the prelude. I would love to get this for dependencies as well.
08:01:37 <vilu> I can't even figure out what this feature is called so that I can find some documentation.
08:01:45 <vilu> I'm using Spacemacs if that's any help.
08:05:58 <shapr> cocreature: oh thanks!
08:12:19 <bgavran> vilu: I have the same question as well. For me it even sometimes works for other libraries, but I haven't figured out a pattern
08:17:17 <vilu> :/
08:24:10 <geekosaur> sadly, it's a hack. per https://github.com/haskell/haskell-mode/blob/master/haskell-doc.el you have to enable it for fucntions it doesn't know about (basically, Prelude) and provide an alist of function names and docstrings
08:26:00 <max3> does anyone know how to force hte tooltip to popup in spacemacs?
08:26:52 <danza> max3, not really on topic in this chat ... :)
08:27:46 <vilu> Oh, geekosaur that's a pity.
08:27:55 <MarcelineVQ> danza: the actual line is  <max3> does anyone know how to make the intero tooltip popup instead of waiting
08:28:31 <max3> danza, well i mean in particular for the haskell layer
08:28:38 <MarcelineVQ> If it's anything like ghc-mod the waiting is just the tool taking its sweet time though, not some inherent delay that has been set
08:29:02 <max3> MarcelineVQ, well even after the hint is generated i have to wait for the tooltip
08:29:09 <max3> because the hint does appear in the status line
08:29:17 <max3> or minibuffer (whatever it's called)
08:33:57 <max3> what do you call x = Either a b for some concrete a,b?
08:34:00 <max3> not an instance right?
08:34:59 <Ariakenom> max3: call as in relation to unapplied Either?
08:35:56 <max3> yes
08:36:39 <mnoonan> max3: not an instance, that means something specific. mostly people just abuse terminology and call x "an Either type"
08:37:09 <max3> but a type and a variable of a particular type aren't the same thing right?
08:37:16 <max3> variant?
08:37:34 <mnoonan> max3: that's why I said it is an abuse of terminology :)
08:38:14 <merijn> max3: "a variable of type Either"
08:38:33 <mnoonan> but actually it isn't so bad, because there is no Either type (that is, of kind *). so if somebody said "x has a Maybe type", I'd assume they mean x has a type that comes from fully saturating Maybe
08:39:12 <max3> Either is * -> * -> * right?
08:39:29 <Ariakenom> so m isnt a type in
08:39:31 <Ariakenom> :t join
08:39:32 <lambdabot> Monad m => m (m a) -> m a
08:39:47 <max3> m isn't a type? is a type constructor?
08:39:57 <Ariakenom> it's not a Type aka * at least
08:40:12 <max3> so what is it?
08:40:28 <Ariakenom> (that was a question)
08:40:40 <Ariakenom> ((about m))
08:40:44 <mnoonan> a higher-kinded type
08:42:18 <MarcelineVQ> "I call Either a type constructor, what do I call Either Int String?" A type constant or a fully saturated type constructor. Some people call it a concrete type.
08:43:16 <merijn> Hah!
08:43:20 <merijn> This time I'm prepared!
08:43:25 <MarcelineVQ> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-630004.1
08:43:41 <merijn> Why you should stop saying concrete type: https://gist.github.com/merijn/796b8e041885df870fbb53b7191644b6
08:44:25 <MarcelineVQ> :>
08:45:01 <merijn> As for the 'm' question. 'm' is a type of kind * -> * would the description I'd use
08:45:30 <Ariakenom> right, the m thing was meant as a response to mnoonan 
08:45:49 <Ariakenom> merijn: max3 already said concrete earlier. you need to set up an alert
08:45:54 <merijn> Ariakenom: !
08:45:54 <Taneb> merijn: the Romans had concrete types that are lighter and quicker-setting than the types of concrete we have today!
08:46:15 <max3> lol
08:46:16 <merijn> Taneb: ಠ_ಠ
08:46:21 <max3> is that true?
08:46:25 <MarcelineVQ> Taneb: but was it better?
08:46:57 <Taneb> max3: more or less
08:47:05 <merijn> max3: I recall an MIT article from several years ago (re)discovering a technique in Roman types that drastically increased the quality of mortar, making it longer lasting
08:47:09 <merijn> max3: So it seems plausible
08:47:55 <merijn> Ariakenom: I'm just happy I no longer have to rewrite my rant from scratch nowadays!
08:48:08 <merijn> I should get quchen to link it from fbut
08:48:21 <MarcelineVQ> data Mortar (a :: Region) = ...
08:49:09 <Ariakenom> at least it isn't concrete
08:50:29 <MarcelineVQ> This is true, though standard mortar is the same as the cement component of most concrete
08:55:08 --- mode: glguy set +v noipmups
08:55:11 <noipmups> Haskell records are pain in the ass. Is there something else similar to http://nikita-volkov.github.io/record/? Lenses solve majority, but not all of these problems.
08:56:21 <Solonarv> off the top of my head: vinyl, and (depending on your use case) dependent-map
08:57:03 * ski disagrees with calling `Maybe a' a polymorphic type
08:57:57 <Solonarv> you're right, 'Maybe a' isn't a polytype - 'forall a. Maybe a' is!
08:58:10 <merijn> ski: In Haskell it is
08:58:28 <merijn> ski: Absent any binder or other variables "Maybe a = forall a . Maybe a" in Haskell
08:58:43 <ski> i could stretch as far as calling `forall a. Maybe a' a polytype, but it's still not a polymorphic type in my estimation
08:58:53 <merijn> ski: Why not?
08:59:02 <Solonarv> then what *is* a polymorphic type?
08:59:05 <MarcelineVQ> because ski thinks in kinds my man
08:59:10 <ski> imho, *values* of that type are polymorphic
08:59:39 <ski> also the second argument passed to `fromMaybe' is certainly not polymorphic, despite having type `Maybe a'
09:00:31 <ski> Solonarv : `Maybe' has kind `* -> *'. so `Maybe' is monomorphic, just like `not' is monomorphic, having type `Bool -> Bool'
09:00:33 <dmj`> noipmups: there’s a few extensions, like DuplicateRecordFields, YMMV
09:01:05 <ski> Solonarv : an example of a polymorphic type would be `Const' defined by `newtype Const c a = MkConst', here the type of `Const' is `forall k. * -> k -> *'
09:01:18 <merijn> ski: How would you name "the types of values that are polymorphic", then?
09:01:29 <ski> merijn : `forall'-type, or universal type
09:01:41 <merijn> ski: Anyway, all this draws in a whole ton of stuff that people that most need this explanation won't understand
09:01:44 <Solonarv> ah, so what you call a "polymorphic type" is what the rest of us call "poly-kinded type"
09:01:57 <merijn> ski: So I don't think it's helpful for the intended audience
09:02:53 <ski> Solonarv : `reverse' is a polymorphic value, this means that it has lots of types, like `[Int] -> [Int]', `[(String,Int -> IO Bool)] -> [(String,Int -> IO Bool)]', &c. all sharing the same pattern `[a] -> [a]' with `a' replaced (consitently) by a specific type (not involving type variables, say)
09:03:29 <dstolfa> ski: erm, the forall type isn't necessarily a universe type, if that's what you mean. it's usually the pi type, as the pi type is isomorphic to forall in logic
09:03:42 <ski> Solonarv : similarly, `Const' is a polymorphic type, because it has lots of kinds like `* -> * -> *', `* -> ((* -> *) -> *) -> *', &c., all sharing the template pattern ("schema") `* -> k -> *'
09:03:57 <merijn> ski: Most people seem to use/mean "type of polymorphic values" when speaking of "polymorphic types". Your usage seems to very clearly be in the minority (although I think someone else here has previously said the same thing)
09:04:37 <ski> Solonarv : to capture all these distinct, but related types of `reverse' say that we have a single general type `forall a. [a] -> [a]' of `reverse'. and similarly `Const' has the general type `forall k. * -> k -> *'
09:04:43 <Solonarv> noipmups: have a look through this search: https://hackage.haskell.org/packages/search?terms=record
09:05:23 <ski> the `forall' part of the type of a polymorphic value is essential. if there's no `forall' at the front of the type, it's not a polymorphic value. similarly, if the kind doesn't start with `forall', it's not a polymorphic type
09:05:32 <noipmups> Solonarv: Thanks a lot. So far, vinyl seems to be very nice.
09:06:14 <Solonarv> I'll be honest and say I haven't really used any of them, so I can't make a recommendation that isn't based on hearsay
09:06:26 <Ariakenom> ski: the type can have a type variable from somewhere else too. with scoped type variables
09:06:28 <ski> it appears that sometimes people here get confused, because you're allowed to elide the initial `forall', in type *signatures* (not just in any type at all, otherwise `isJust :: Maybe a -> Bool' could be interpreted to mean `isJust :: (forall a. Maybe a) -> Bool', which is nonsense)
09:07:37 <ski> merijn : me dragging this in is mainly intended to encourage people to stop saying "polymorphic type" for e.g. the type `Maybe a', or the type `forall a. Maybe a' (not the same thing)
09:07:40 <nshepperd> we already have a term for ski's "polymorphic types" though. they're called polykinded
09:07:55 <ski> nshepperd : yes, i dislike that term :)
09:08:06 <nshepperd> figures
09:08:19 <dstolfa> ski: this is why you don't write type-theoretically in haskell ;)
09:08:29 <dstolfa> ski: you'll be frustrated by a lot of things in haskell if you want to write things type-theoretically
09:08:39 <ski> nshepperd : because i think it unnecessarily confuses the picture by not relying on the clear analogy between polymorphic values having universal types, and polymorphic types having universal kinds
09:08:55 <ski> (and in a dependently typed language, these are really the same thing !)
09:08:57 <dstolfa> ski: universal is a bad word here
09:09:15 <ski> hm, perhaps
09:09:20 <ski> do you have a better suggestion ?
09:09:33 <ski> (i assume you're thinking of confusion with universe types ?)
09:09:41 <dstolfa> ski: cofibrant would be the most accurate
09:09:43 <dstolfa> yeah
09:09:56 <dstolfa> but perhaps just type families?
09:10:03 <phadej> in dep-typ-language lambdas and pi-types are different things
09:10:11 <phadej> polymorphic value is \(a  :Type) -> ...
09:10:12 <Ariakenom> using different terminology that may be equal in another context is not problematic
09:10:20 <phadej> which has pi-type Pi (a : Type) ->  ...
09:10:21 <ski> a type family is certainly not the same thing
09:10:27 --- mode: glguy set +v blah09
09:10:37 <dstolfa> ski: well, perhaps just pi types quantified over some type family then
09:10:38 <blah09> Hi, I use servant-auth-server and used generateKey to get secret key, but now I want to read the secret from env variable? I tried to use fromRSA in jose package but for some unknown to me reason it fails to parse my private rsa key. :(
09:10:40 <dstolfa> i'm trying to shrink it
09:10:43 <dstolfa> but it's a bit difficult
09:11:00 <ski> anyway, i have used the term "universal type", partly because people in logic uses "universal formula" for a formula like `forall x. P(x)', and "existential formula" for a formula like `exists x. P(x)'
09:11:27 <ski> (i may also have read "universal type" in some paper, i don't recall for sure)
09:12:08 <lortabac> hello, there was a wiki page explaining a workaround to not being able to select an instance based on the constraints
09:12:16 <lortabac> does anyone remember where it is?
09:12:18 <dstolfa> ski: PI-quantified? :-)
09:12:21 <dstolfa> i'm bad at anming
09:12:22 <dstolfa> naming*
09:12:26 <ski> merijn : "Most people seem to use/mean \"type of polymorphic values\" when speaking of~\ "polymorphic types\"" -- i agree, but i argue that this is confusing (or will cause confusion down the line)
09:12:38 <dstolfa> it's just that universal quickly becomes ambiguous in type theory, as people often don't even agree on what a "universe" is at times
09:12:48 <ski> merijn : some people also call `Maybe' a polymorphic type. i'd call it a type function, or a parameterized type
09:13:06 <ski> dstolfa : yea, i'm not talking about universes
09:13:21 * monochrom plans a rant that follows merijn's but this time complaining about "polymorphic" because it's ambiguous because Either a Int and Either Char b are polymorphic in different ways.
09:13:41 <dstolfa> ski: i know, but it's still ugh-y wording. i clearly don't have anything better other than expanding the full definition :-)
09:13:45 <ski> Ariakenom : "the type can have a type variable from somewhere else too. with scoped type variables" -- of course, which is why i want to clearly distinguish between `Maybe a' and `forall a. Maybe a'
09:14:40 <Ariakenom> ski: what would you call forall . Mayba a with a defined elsewhere?
09:16:06 <ski> merijn : anyway, i agree talking about kinds, and types like `Const' aren't that helpful for the intended audience of people learning the basics of polymorphism. however *my* intended audience for the criticism above is not those people, but the people who talk about `Maybe a' (or `forall a. Maybe a' or `Maybe') as being polymorphic
09:16:35 <ski> Ariakenom : do you mean `forall b. Maybe a' ?
09:17:13 <lortabac> oh, I found the page I was looking for: https://wiki.haskell.org/GHC/AdvancedOverlap
09:17:20 <Ariakenom> ski: no I added an empty forall to indicate it being defined elsewhere
09:17:23 <ski> (and by "the people who talk about ...", i mean the people who want to explain and teach about these matters to aformentioned beginners)
09:17:32 <ski> "it" being ?
09:17:44 <nshepperd> who calls Maybe polymorphic? I've never heard of that
09:18:32 <Ariakenom> it being "a"
09:18:40 <ski> nshepperd : i've several times seen that people say stuff like : in SML you can define polymorphic types, like  datatype 'a option = NONE | SOME of 'a
09:19:38 <ski> `forall a b. ..a..b..' is just  `forall a. forall b. ..a..b..'. so if we have an empty variable list being quantified by `forall', then i suppose `forall . ...' must mean simply `...'
09:19:52 <texasmynsted> I saw a great blog post about haskell validation and error handling and can not find it. It compared techniques and where the responsibility for validation would be moved.
09:20:03 <ski> Ariakenom : in which case your type is just `Maybe a', which is an open type (iow depending on some free type variables)
09:20:06 <dstolfa> ski: the tricky thing in all disciplines ever is naming
09:20:16 <MarcelineVQ> texasmynsted: be sure to link it when you find it again
09:20:17 <texasmynsted> It is driving me crazy-er
09:20:25 <texasmynsted> that I can not find it.
09:20:27 <ski> (just like `x + 1' is an open expression, depending on some free value variable `x' being bound externally to this value expression)
09:20:28 <nshepperd> and you've rephrased that to "option is polymorphic"?
09:20:34 <ski> dstolfa : *nod*
09:21:29 <ski> nshepperd : i think i've also seen it expressed more directly. in any case, either the type  option  or the type  'a option  is claimed to be polymorphic there, i don't see how else to interpret it
09:22:38 --- mode: glguy set +v yellowchar
09:23:26 <ski> anyway, i think it's unhelpful to set up different uses of the term "polymorphic", so that people will stumble over these different uses, in the future
09:23:48 <dstolfa> ski: what do you suggest to call 'a option though
09:24:07 <dstolfa> i usually just call them sum types or datatypes
09:24:08 <ski> a type, parameterized over the type variable  'a
09:24:14 <dstolfa> yeah but that's too long
09:24:21 <dstolfa> 2 word limit!
09:24:28 <ski> open type
09:24:44 <MarcelineVQ> p-parametric type ..?
09:24:47 <ski> if you're talking about the type  option  then you can say parameterized type, or type function
09:24:49 <dstolfa> ski: n-ary sigma type?
09:25:05 <nshepperd> that seems to be what you're doing. the standard use of "polymorphic" means "of a value that can have several different types"
09:25:19 <ski> right
09:25:20 <dstolfa> no, sigma type si weird
09:25:21 <dstolfa> is*
09:25:31 <dstolfa> doesn't capture the notion of a sum
09:25:32 <dstolfa> :<
09:25:46 <ski> similarly, `Const' is a polymorphic type, because it can have several different kinds
09:25:54 <nshepperd> no
09:25:54 <Ariakenom> texasmynsted: I know the one but I can't find it either
09:25:56 <nshepperd> no similarly
09:26:08 <nshepperd> "of a value that can have several different types" is the standard usage
09:26:16 <nshepperd> end of.
09:26:33 <ski> i'm generalizing "polymorphic" to apply on all levels, in a uniform way
09:26:38 <dstolfa> BAH, it's just a datatype
09:26:49 <texasmynsted> If you find it Ariakenom, please link it.
09:26:49 <dstolfa> screw naming
09:26:51 <dstolfa> write maths
09:26:55 <nshepperd> *you* are setting up different uses of the term by adding your own interpretation
09:26:56 <dstolfa> english is ambiguous anyway
09:26:59 <ski> that seems to me to be better that generalizing it in an ad hoc way to apply in different senses, in different contexts/levels
09:27:04 <texasmynsted> How could I have lost this.
09:27:13 <ski> a third alternative would be to refuse to generalize it at all, i agree
09:27:16 <Ariakenom> texasmynsted: ~restricting your past to gain freedom in your future~?
09:27:17 <texasmynsted> now that I can not find it, I am sure it is exactly what I am looking for
09:27:34 <ski> (and i'm not arguing against that. i'm arguing that if we're generalizing it, we should do so in a uniform way)
09:28:01 <Ariakenom> texasmynsted: https://www.parsonsmatt.org/2017/10/11/type_safety_back_and_forth.html
09:28:25 <texasmynsted> yes!
09:28:30 <texasmynsted> That is it. :-D
09:28:31 <Ariakenom> MarcelineVQ: ^
09:28:32 <texasmynsted> Thank you!
09:29:06 <nshepperd> according to my definition: '(+) is a value that can have several different types: it's polymorphic'
09:29:33 <nshepperd> 'forall a. Maybe a is the type of a value that can have several different types: it's polymorphic'
09:30:02 <Ariakenom> texasmynsted: np, thanks for reminding me
09:30:03 <ski> nshepperd : do you agree that there's a useful analogy between "value vs. type" and "type vs. kind" (which can then be extended further, if we have more levels in the hierarchy. if we go `TypeInType', then the collection of kinds is simply included in the collection of types)
09:30:47 <ski> nshepperd : yes, i'm objecting to arbitrarily (imho) injecting the "the type of" in the second line there
09:31:54 <ski> nshepperd : just because a value has some property doesn't mean its type in any useful sense has "the same property"
09:32:23 <ski> (i remember talking to someone who insisted that one should be able to apply a function type, like `Int -> Bool', to an argument, as if a function type was a function)
09:34:12 <ski> so, imho, if we're to apply the term "polymorphic" to types at all, it should be like : "... is a type that can have several different kinds: it's polymorphic" (rephrasing your first line of definition)
09:34:36 <ski> (and `Const' is an example of such a type)
09:36:14 <nshepperd> it's not the 'same' property
09:36:19 --- mode: glguy set +v boxscapeR
09:36:21 <jose_zap> ski are you saying that "polymorphic type" is not a valid term?
09:36:49 <ski> no, i'm saying some people are using that term in a, imho, confusing and inappropriate way
09:37:07 <nshepperd> or, it's the same property, but not in the sense you are imagining
09:37:52 <ski> nshepperd : if it's not the "same property", then why do people want to call `forall a. Maybe a' polymorphic, rather than a completely different word/term ?
09:37:55 <nshepperd> it's the property of "having" (in some sense) value polymorphism
09:38:09 <nshepperd> Const doesn't even have values
09:38:22 <ski> (or at least a distinctly dissimilar term, even if clearly derived from the term "polymorphic")
09:41:22 <ski> yes, so i'm generalizing from "value (expression)" to "term / expression" (at any level in the hierarchy), and from "type (expression)" to "term / expression" (at any level in the hierarchy above the ground level", so that in `E0 :: E1', `E0' might be a value expression, and `E1' its corresponding classifying type expression, or `E0' might be a type expression, and `E1' its corresponding classifying kind expression, &c.
09:42:12 <ski> if we're to generalize the term "polymorphic" at all from only applying to "value( expression)s", then this seems the sensible way to do it, imho
09:42:30 <ski> otherwise, why would we already use the same notation `::' on both pairs of levels, here ?
09:42:43 <ski> (or do you believe that to be a bad idea ?)
09:44:36 <ski> anyway, i don't see the point of `Const' not having any values (or inhabitants, more generally)
09:44:40 <nshepperd> idk, it seems to me you've generalized so hard you've forgotten what values are
09:44:48 <ski> `reverse' doesn't have any values, either
09:45:00 <ski> (which doesn't stop us from calling it polymorphic)
09:45:35 <nshepperd> none of those things, or the analogies between types and kinds, require us to not have terms that are specifically about value polymorphism
09:45:43 <ski> can you elaborate on your point re values ?
09:45:57 <ski> nshepperd : agreed
09:47:16 <nshepperd> you don't need to generalize 'value polymorphism' to 'anything polymorphism' in order to apply such a term to a type
09:47:48 <ski> i don't follow your argument here
09:48:35 <ski> if it originally only applies to values, then it seems to me we must generalize in some way (ad hoc, or uniformly, or perhaps in some other fashion), in order to apply it to types, where it previously wasn't applied, or at least certainly not covered by the motivating definition
09:49:16 <nshepperd> it's about values
09:49:27 <nshepperd> which is different from "only applies to values"
09:50:04 <ski> i see it as being about "having multiple shapes", which i don't see as necessarily intrinsically tied to being about values
09:50:18 <oo_miguel> Do i have to unpack a ByteString.Char8 before converting it to Int or Double.. ? Or is there some direct way?
09:50:40 <f-a> I forgot: where should i put the password so that `cabal upload` runs unattented?
09:51:39 <ski> in the case of values, "shape" gets formalized as "the type of the value". so in `(reverse "abc",reverse [0,1,2,3])', the two different occurances of `reverse' have "different shapes"
09:52:00 <Solonarv> oo_miguel: the cheeky answer is "you have to rip it out and use a string type that isn't incorrect"
09:52:50 <Solonarv> the quick-and-dirty answer is "turn it into a String and pass it to readMay"
09:52:59 <ski> (and similarly, in `Const Int Maybe -> Const Int Bool -> Const Int (Maybe Bool)', not all three occurances of `Const' have the same "shape" (kind in this case))
09:53:50 <oo_miguel> Solonarv: For me both answers are the same ;) I was just concerned with performance penalties for turining it into a string... 
09:53:56 <ski> nshepperd : so, in which sense, in your opinion, is it "about values", as opposed to "only applies to value" ? (genuine question)
09:54:11 <oo_miguel> Solonarv: but it seems I can not get around it, thank you
09:54:50 <Solonarv> you almost certainly shouldn't be worrying about "performance penalties" here
09:55:28 <oo_miguel> Solonarv: allright, thanks
09:56:51 <cocreature> oo_miguel: https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Char8.html#v:readInt
09:56:55 <Solonarv> 1) that's premature optimization; 2) if it's being turned into a number it's presumably a rather short string, so constant factors will dwarf most everything else; 3) converting into a number is usually something you do to *input*, which means you're IO-bound anyway
09:58:08 <cocreature> while that’s probably true, the fast solution here isn’t any longer so not using it is somewhat silly
09:58:28 <oo_miguel> Solonarv: It is a short string, and I read it from a file. however I repeat it many times
09:58:53 <Solonarv> if you're *really* worried about performance, the correct answer is "use a parser"
10:00:24 --- mode: glguy set +v boxscapeR
10:01:16 <oo_miguel> Solonarv: ok you are right
10:06:09 <nshepperd> ski: 'polymorphic type' means that it has polymorphic values
10:10:18 <nshepperd> well, it seems obvious to me, which means I can't explain it :)
10:10:24 --- mode: glguy set +v mike_
10:11:05 <Guest56595> Is there a subclass of Ord that provides a least element?
10:11:58 <f-a> Bounded you mean, Guest56595 ?
10:12:01 <geekosaur> not of Ord as such, but most instances of Ord are also instances of Bounded
10:13:10 <Guest56595> I'd like something like "Ord and Bounded" but without the upper bound
10:14:13 <Guest56595> Or rather, "Ord and LowerBounded"
10:15:55 <f-a> could that be a semilattice?
10:16:16 <Guest56595> e.g. natural numbers have lower bound 0 but no upper bound.
10:18:21 <f-a> Guest56595: sorry, not aware of anything like that. Stay put for other suggestions, though!
10:18:39 <Guest56595> Is Min what I'm looking for?
10:19:30 <f-a> @hoogle Min
10:19:30 <lambdabot> Data.Semigroup newtype Min a
10:19:31 <lambdabot> Data.Semigroup Min :: a -> Min a
10:19:31 <lambdabot> Control.Lens.Internal.Fold data Min a
10:20:21 <Solonarv> so: nope, Min isn't even a class
10:21:21 <gobby> Currently getting this error: `test: thread blocked indefinitely in an STM transaction`
10:21:27 <gobby> while running hedgehog tests
10:21:32 <gobby> there is no STM in my module
10:21:37 <gobby> where the tests exist
10:21:53 <gobby> other tests modules run fine
10:23:20 <Solonarv> if you're not using STM directly, then something you're using is probably using STM under the hood
10:23:43 <Solonarv> but without knowing what code is throwing the error, it's rather difficult to figure out why it's being thrown
10:24:27 <geekosaur> hedgehog depends on stm, which is something of a hint
10:26:20 <geekosaur> https://github.com/hedgehogqa/haskell-hedgehog/issues/183 isn't quite the same thing but is suggestive
10:31:30 <exarkun2> Which is the good URI or URL package?
10:31:41 <exarkun2> Network.URI and Network.URL are underwhelming
10:33:11 --- mode: glguy set +v codedurr
10:33:54 <gobby> geekosaur: thanks
10:34:01 <gobby> Solonarv: thanks
10:34:06 <codedurr> personally I use Network.URI and find it complete enough
10:34:06 <Welkin> for an http client library: HTTP, req, or wreq?
10:34:51 <Solonarv> consider servant-client, if you're querying a known API
10:34:55 <Welkin> I normally use servant-client because I bind to web apis often, but this time I need to make a few http requests
10:39:00 <Welkin> req looks like it might work best
10:39:13 <Welkin> even if just to avoid bringing in lens
10:39:41 <dmj`> Welkin: wreq is def. nice
10:41:37 <cocreature> Welkin: I mostly use req these days
10:46:49 <c_wraith> lone_ranger: went to bed right before you asked me a question last night.  Ever figure that out?
10:47:18 <lone_ranger> c_wraith: no, still thinking about it
10:48:01 <c_wraith> any questions that getting answers to might help with?
10:49:31 <lone_ranger> yeah so getting the recprocal of factorials works like this: scan (g) 1 [1,2,3..] where g n x = 1 / (*) n x
10:49:46 <lone_ranger> and I know how to do powers
10:49:56 <lone_ranger> just not sure how it fits together
10:50:38 <lone_ranger> c_wraith: I also remeber you said a scan reduces to a map, any more cooments on that?
10:51:04 <c_wraith> Well, scanl *can* reduce to a map, if it ignores the accumulator argument.
10:52:09 <c_wraith> though it will always prepend the base case to the input, so you have to throw that out if you want it to turn into exactly map
10:52:40 <c_wraith> Have you considered just using zipWith?
10:53:07 <lone_ranger> c_wraith: No, its just that I was told it's possible so I have to know how now
10:54:02 <lone_ranger> if I dont figure it out ill be thing about it for a loooong time :/
10:54:10 <c_wraith> There are a bunch of slightly different ways to do it.  Not one magical single approach
10:55:11 <c_wraith> You can put varying amounts of logic in the generation of the list vs the scanning function
10:55:38 <lone_ranger> c_wraith: lets go with list generation
10:55:59 <lone_ranger> its the most intuitive for me right now
10:57:14 <c_wraith> Well, let me suggest a slightly different way of thinking about the inverse factorials:
10:57:45 <c_wraith> > scanl (*) 1 (map (1/) [1..])
10:57:48 <lambdabot>  [1.0,1.0,0.5,0.16666666666666666,4.1666666666666664e-2,8.333333333333333e-3,...
10:58:03 <c_wraith> ok, that probably should have started at 2. :)
10:58:07 <c_wraith> > scanl (*) 1 (map (1/) [2..])
10:58:09 <lambdabot>  [1.0,0.5,0.16666666666666666,4.1666666666666664e-2,8.333333333333333e-3,1.38...
10:58:39 <lone_ranger> hmm using map eh
10:58:47 <lone_ranger> thats rather creative
10:58:59 <c_wraith> Just to make a list of 1/n values.
10:59:13 <c_wraith> Then the scan converts them into 1/n! values
10:59:15 <ggVGc> remind me again why arch packages all the haskell packages separately?
10:59:21 <ggVGc> maybe all distros do this?
11:00:09 <MarcelineVQ> ggVGc: Reduction of real duplication at the expense of lexical duplication.
11:00:28 <MarcelineVQ> That is to say, those are dynamicly linked packages iiuc
11:00:31 <Solonarv> the better question is why it configures them to dynamic linking when that tends to Break Things (tm) in practice
11:00:48 <cocreature> ggVGc: most distros do this. the difference is that for Haskell the executables tend to depend on all of the library packages while that’s not the case for a lot of other distros
11:01:22 <lone_ranger> c_wraith: ok, so I can generate the inverse then I cn just scan to multiply each by the power?! (for x^k/k!)
11:02:28 <ggVGc> hm
11:02:37 <ggVGc> yeah I remember now
11:02:46 <ggVGc> I think I'm gonna stop using the distro haskell packages though
11:02:54 <ggVGc> and just use stack manually installed
11:03:08 <c_wraith> lone_ranger: you can make a small modification to multiply each one by the correct number of x values, sure
11:03:14 <ggVGc> I started plaing with Nix again after many years of not using it
11:03:26 --- mode: glguy set +v mson__
11:03:30 <ggVGc> seems quite nice, and feels better then when I tried it first time
11:03:45 <ggVGc> do you guys use it for haskell projects? Or other projects?
11:03:52 <cocreature> ggVGc: yeah ignoring disto-provided libraries tends to be a good idea on all distros. on arch that also extends to distro-provided executables since they depend on all libs
11:04:10 <ggVGc> cocreature: yeah, but I think the only haskell executable I use is shellcheck
11:04:15 <ggVGc> and I can install that manually too
11:04:36 <c_wraith> watch out for the surprising number of tools that use pandoc internally
11:04:41 <ggVGc> I stopped using xmonad, for this reason among other things
11:04:51 <ggVGc> cocreature: still remember you helping me a lot with xmonad in the past :) thanks for that
11:05:05 <ggVGc> or maybe I am mixing you up with someone?
11:05:09 <ggVGc> but I don't think so
11:05:48 <ggVGc> c_wraith: well I guess I can blacklist haskell-* packages
11:05:49 <cocreature> could be :)
11:05:53 <ggVGc> and avoid that surprise
11:06:21 <cocreature> if you do use stack, then it actually doesn’t matter what you do via pacman since the two don’t interact
11:06:38 <cocreature> (at least if you don’t enable system-ghc)
11:06:55 <ggVGc> hm, I'm not entirely convinced. I've had weird stack breakages
11:06:58 <ggVGc> related to ncurses
11:07:14 <ggVGc> either way I think I'm quite intersted in nix again
11:07:27 <ggVGc> which should really solve it all
11:08:02 <cocreature> don’t worry, it has other problems that you can complain about :)
11:08:13 <ggVGc> :( I'd like to not complain and have a smooth ride
11:08:14 <ggVGc> please
11:17:34 <Ariakenom> I have Haskell described as "very functional and very typed programming language" for a talk. you like?
11:20:09 <boxscapeR> ggVGc: if you end up wanting to develop haskell with nix, this is a good starting point https://www.reddit.com/r/NixOS/comments/7h8np7/stack_or_cabal_which_one_is_more_preferable_for/dqp268b/
11:20:44 <ggVGc> Ariakenom: as long as you don't say it's productive ;)
11:20:53 <ggVGc> as in.. actually producing software to use
11:21:05 <ggVGc> boxscapeR: thanks, will check it
11:22:28 <Ariakenom> ggVGc: Of course. I will explain that it's mostly for type checking and navel gazing
11:25:03 <cocreature> Ariakenom: the important part is that you make it very clear that you should never attempt to run programs if they typecheck
11:26:12 <boxscapeR> ship it instead?
11:26:26 <Solonarv> if it doesn't typecheck, sprinkle a few unsafeCoerce's around and run it
11:27:15 <Solonarv> the unsafeCoerce's are needed to circumvent a long-standing bug where the compiler will refuse to produce an executable if your program doesn't typecheck
11:28:27 <boxscapeR> we should make a proposal to outsource typechecking onto third-party tools so the compiler can focus on compiling
11:29:21 * Ariakenom keeps nodding and taking notes
11:29:56 <cocreature> also important: performance is measured by the number of uses that have a magic hash in their name
11:32:04 <Ariakenom> % let f :: a -> Void#; f a = undefined ; x = f 1; in "nothing at all"
11:32:05 <yahb> Ariakenom: "*** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:7:28 in interactive:Ghci5
11:32:53 <Ariakenom> will also mention that sometimes it evaluates and sometimes it doesn't
11:35:57 <boxscapeR> does that happen because of the #?
11:36:51 <Solonarv> just in case that's a serious question: sort of; # doesn't actually have special meaning, it's just used for primitive/unlifted stuff by convention
11:37:03 <dmwit> boxscapeR: Yes, unboxed lets are evaluated before their bodies.
11:37:06 <boxscapeR> heh, it is a serious question
11:37:09 <boxscapeR> okay
11:38:14 <Zemyla> Hmm, I think this function flip' should be in the profunctors library just for simplicity's sake.
11:38:24 <Zemyla> :t lmap (,) . closed . rmap (\(x, f) -> f x) . second' -- flip'
11:38:26 <lambdabot> (Strong p, Closed p) => p b1 (a -> b2) -> p a (b1 -> b2)
11:38:40 <Zemyla> They already have curry' and uncurry'.
11:39:00 <Solonarv> so it's because of the Void#, which is just what that type happens to be named, and is not a priori related to Void
11:40:05 <boxscapeR> ok
11:40:05 <Ariakenom> # isn't special but is usually used in names of special things
11:41:03 <Solonarv> ^ that
11:41:36 <Ariakenom> You can probably stretch the "usually" to "always"
11:41:41 <lavalike> :t second'
11:41:42 <lambdabot> Strong p => p a b -> p (c, a) (c, b)
11:41:46 <lavalike> what are these things?
11:43:28 <nitrix> The letters?
11:43:37 <lavalike> Strong things
11:43:57 <nitrix> Profunctors -.-
11:43:59 <MarcelineVQ> https://hoogle.haskell.org/?hoogle=second'   https://hackage.haskell.org/package/profunctors-5.3/docs/Data-Profunctor.html#v:second-39-
11:44:06 <lavalike> o
11:44:07 <geekosaur> http://hackage.haskell.org/package/profunctors-5.3/docs/Data-Profunctor-Strong.html
11:44:09 <lavalike> thanks
11:44:35 <nitrix> The sigh is because I hate the names in that package, lol.
11:44:41 <lavalike> aw the paper is dead
11:44:49 <infinisil> Lol, Tambara
11:44:57 <infinisil> Pastro
11:46:14 <lavalike> yay the wayback machine has it
11:46:35 <MarcelineVQ> lavalike: also http://sci-hub.tw/10.1145/1863597.1863607
11:47:04 <MarcelineVQ> I dunno if that link is session depentend come to think of it. anyway you can find lots of papers on sci-hub
11:47:15 <lavalike> gotcha
11:47:22 <cocreature> I’m glad my interest in papers only really started when scihub was a thing
11:47:53 <MarcelineVQ> arxiv isn't too shabby, there's usually enough people duplicating work on there to get up to speed on a subject
11:48:30 <lavalike> I was hoping to get some a more human touch than that documentation page lends
11:48:57 <infinisil> Arghhh I need to do a bachelors thesis, but I really am not a fan of academic writing. I can hopefully spend most time implementing something with code, but some paper is still required.
11:49:47 <cocreature> infinisil: heh, I just finished my master’s thesis and I also don’t really like writing
11:51:05 <infinisil> I just proposed an idea for my thesis, and the assistant said it's uninteresting and nothing really novel. Meanwhile a friend of mine is working on his online multiplayer game for his thesis..
11:51:37 <cocreature> :/
11:51:55 <Ariakenom> cocreature: same, except not quite finished
11:52:25 <cocreature> infinisil: which field are you planning to work in?
11:52:43 --- mode: glguy set +v slickmick
11:52:56 <Ariakenom> at least did it together with someone so I had someone to constantly complain to
11:53:07 <slickmick> is a bachelor's thesis required at your university?
11:53:29 <infinisil> cocreature: Well I'm studying computer science, but I just really wanna get a programming job after that (haskell preferably).
11:53:37 --- mode: glguy set -v slickmick
11:53:56 <dstolfa> infinisil: use it as an opportunity to practice persuasive writing. even if you work in the industry, you'll have to persuade others to your ways :-)
11:53:58 <cocreature> infinisil: right, I was more interested in which subfield of CS
11:54:11 <infinisil> cocreature: Ah, well nothing specific really
11:54:14 <cocreature> also we might want to move this to #haskell-offtopic
11:54:31 <infinisil> dstolfa: I'll just find an assistant that doesn't mind me just implementing something with a minor writing part lol
11:56:22 <bsima> hey, does anyone know the root of this "haddock internal error extractDecl" error? I can't generate my docs
11:56:37 <bsima> is it something I can do to fix, or a haddock bug?
11:59:52 <Lycurgus> maybe it's bebugging
12:14:02 <Welkin> I'm finding req to even be too high-level (and painful) for what I am trying to do
12:14:22 <Welkin> which is: PUT localhost:5984/some_string
12:14:39 <Welkin> maybe http-client will be easier?
12:15:45 <cocreature> it is definitely not as high-level. whether that makes things easier or harder is hard to say :)
12:22:30 <Welkin> this dialog is driving me nuts "Allow <application> to accept incoming connections?"
12:23:03 <Welkin> is there a wa yto get rid of this stupid (on mac) every single time I run my web server?
12:23:17 <Welkin> stupid dialog*
12:23:19 <lavalike> disable the firewall in system preferences > security
12:23:49 <Welkin> I wonder if using a daemon to restart it would also have the same issue
12:24:00 <Welkin> that's a good question
12:24:17 <lavalike> I like to disable that one and use littlesnitch which has a better UI
12:24:23 <Welkin> what do you use for file watching/recompiling your app in develoment?
12:24:59 <lavalike> (ghcid but I never work on haskell web services so it might not be what you're looking for)
12:25:13 <cocreature> Welkin: fwiw a variation of `runReq def (req PUT (http "localhost" /: "some_string") NoReqBody ignoreResponse (port 5984))` should work with req
12:26:43 <lavalike> I have been suggested this before https://github.com/cortesi/modd
12:27:03 <Welkin> cocreature: I figured tht out just a few minutes ago
12:27:05 <Welkin> thanks anyway
12:27:38 <Welkin> I'm still getting used to the api
12:29:35 <Welkin> this project has been a smorgasbord of protocols, datastores, and architectures so far
12:29:52 <lavalike> what is it about?
12:29:54 <Welkin> time to set up an endpoint in scotty as a reverse proxy
12:30:13 <Welkin> it is for playing a tabletop RPG online with live synced updates across all clients (and the server)
12:30:21 <lavalike> nice!
12:30:23 <Welkin> like a collaborative document
12:30:33 <lavalike> is it open source?
12:30:44 <Welkin> it will be once I get it fully working
12:31:19 <Welkin> it was pretty easy to build without user accounts
12:31:34 <Welkin> adding user accounts (and auth) is what added a lot of complexity
12:31:38 <tdammers> why not release now and see if others want to help make it work
12:31:43 <lavalike> makes sense
12:32:04 <ggVGc> why isn't there a ready to use standalone service for user management that every project can just use
12:32:07 <ggVGc> maybe I should build that
12:32:09 <ggVGc> or maybe it exists
12:32:17 <tdammers> LDAP?
12:32:20 <ggVGc> because people keep fucking it up, and it's boring to make
12:32:24 <ggVGc> tdammers: hm, yeah maybe
12:32:46 <ggVGc> is it general purpose enough?
12:33:34 <geekosaur> too general, perhaps
12:34:01 <Welkin> I sure learned a ton about auth in the last 7 days though
12:34:13 <tdammers> Welkin: -entication or -orization?
12:34:16 <Welkin> so at least I have some idea what I am doing now, and how to safely handle it
12:34:19 <Welkin> both
12:34:20 <lavalike> what was the most surprising lesson
12:34:28 <tdammers> one is very difficult, but doesn't add much complexity
12:34:36 <Welkin> the most surprising lesson is that the most straightforward solution was the best one
12:34:37 <tdammers> the other is easier, but adds a lot of complexity
12:34:50 <Welkin> standard server-side sessions with cookies
12:34:58 <tdammers> well, duh
12:35:09 <tdammers> what else did you consider?
12:35:15 <Welkin> I had a lot of problems that needed to be solved though
12:35:32 <Welkin> luckily I figured it out after a week of research and talking to people
12:35:37 <lavalike> Welkin: I like doing client-side sessions with often-expiring cookies
12:35:42 <Welkin> I considered using a token-based system
12:36:00 <Welkin> yes, the other problem was that I didn't want the session to expire while they are connected to the game
12:36:08 <tdammers> IME, most of the alternatives amount to reinventing session cookies badly
12:36:25 <tdammers> token-based means you have to store tokens on the client somewhere
12:36:27 <Welkin> refrssh tokens (for a token-based system) could solve that, but puts a burden on the client to know implementation details of the server
12:36:31 <lavalike> Welkin: the idea being if a user interacts, it implicitly gets an updated token, so it will always last the given timeout from the last action
12:36:38 <lavalike> yeah
12:36:54 <lavalike> I forget if fetch() does set the tokens for non-fetch()-ed things
12:36:55 <Welkin> in the end, I realized I can just extend the life of a cookie and send it back to the client when it is close to expiring
12:36:59 <Welkin> rolling sessions
12:37:06 <tdammers> but handling and storing tokens in the client means client-side scripts need to know the token
12:37:26 <tdammers> and given the JS security situation, this opens a whole can of worms
12:37:49 <Welkin> cookie to store a session id with HttpOnly and Secure set
12:37:56 <tdammers> exactly
12:38:00 <tdammers> problem solved
12:38:15 <tdammers> now, things like JWT have a place
12:38:34 <tdammers> which is, when you need to prove something across application boundaries
12:38:40 <Welkin> love this flowchart http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/
12:39:44 <tdammers> like, you send someone from site A to site B, but you want site A to testify to some fact about the user without having to directly contact site B
12:40:29 <Welkin> but it is a one-time-use token
12:40:35 <Welkin> and is invalid after that one use
12:41:36 <tdammers> doesn't have to be
12:44:14 <Welkin> the only reason I took so much time to figure out a solution is because I wanted to have clients authenticate with one server, but then connect directly to a database (which exposes an http api) directly for replication/syncing
12:44:41 <Welkin> but the same result should be attainable through a reverse proxy in my server application
12:45:51 <Solonarv> Welkin: oh that sounds like a cool project, I've idly thought about making something similar (but never did because blech effort)
12:47:53 <Welkin> when I started I had no idea how complex it could get
12:48:05 <Welkin> I thought it would be easy, and it was pretty easy, until I added user accounts
12:48:37 <Welkin> that's how it always works though
12:49:01 <Welkin> if you want to do anything with syncing data from client <-> server, check out couchdb and pouchdb
12:50:17 <lavalike> Welkin: are you using those?
12:50:36 <lavalike> I had considered them for a project in the past, but ended up not
12:54:58 <Welkin> yes
12:55:07 <Welkin> I am using postgres, redis, and couchdb/pouchdb
12:56:54 <lavalike> so many moving pieces
13:02:40 <tdammers> I like to factor users and authorization concerns into the application from early on, but I may postpone authentication concerns until later
13:02:41 <nitrix> I know this is going to sound absurd, but is a functional language without first class functions and recursive functions "limitating"? As in, would there be things that are impossible to implement due to this?
13:02:59 <nitrix> (No lambda either)
13:03:04 <tdammers> "limitamatating"
13:03:30 <tdammers> depends what other features it has
13:03:34 <[exa]> nitrix: how's that a functional language then?
13:03:39 <nitrix> Oh, limiting.
13:03:43 <tdammers> ;)
13:03:46 <nitrix> Sorry, it's not a word I use often :)
13:03:53 <tdammers> [exa]: by having pure functions
13:04:44 <nitrix> [exa]: My definition of functional language would say it's no longer functional, but I think there's a broader definition that I'm willing to venture into to thinker about this case.
13:04:51 <[exa]> well if it has SKI then there are no limits
13:05:22 <nitrix> Oh, clever. I actually just need to prove SKI.
13:06:06 <[exa]> which might be complicated if you can't handle functions as "values"
13:06:17 <cocreature> ski is the limit!
13:06:18 <Solonarv> it can still be limiting though - have you heard the phrase "turing tarpit" ?
13:07:29 <tdammers> from a purely theoretical point of view, if you have turing completeness, you're set
13:07:43 <nitrix> Right. I'll keep those in mind.
13:08:18 <tdammers> but there's also the practical consideration that while it may be provably possible to implement anything, the practicalities of actually doing it may be prohibitive (i.e., turing tarpit)
13:09:13 <tdammers> informally, if your language still has some way of producing infinite loops or recursion, then you can implement a simple lambda calculus or a turing machine; either is enough to bootstrap all the other stuff
13:09:15 <[exa]> nitrix: btw how do you define functions there?
13:09:38 <nitrix> [exa]: It's essentially a graph. Nodes are computations and edges are message passing.
13:09:50 <Solonarv> note: if you want to prove SKI, you actually just need SK - SKKx reduces to x, so you don't need I
13:10:03 <nitrix> [exa]: I'm not allowing a node to send a message to itself, for complicated reasons.
13:10:25 <nitrix> I'm wondering what the implications of that choice will lead me into.
13:10:53 <tdammers> can nodes mutually send messages to one another?
13:11:05 <nitrix> Yes, though it's directed.
13:11:09 <nitrix> It can be cyclic though.
13:11:25 <tdammers> ah, so then you can probably bootstrap recursion via that route
13:12:11 <nitrix> True. Actually, since the nodes expand into other graphs internally (it's nested like russian dolls), I suppose I do have recursion in principle.
13:12:38 <nitrix> Kind like how we do foo = go x where go ... in haskell.
13:12:44 <[exa]> nitrix: sounds like petri nets. Those are T-complete.
13:13:12 <nitrix> Omg. They are petri nets, yes x]
13:13:44 <nitrix> Don't you have to take the two inputs/outputs at exactly the same time with petry nets?
13:13:54 <nitrix> Transitions they are called faik
13:13:56 <nitrix> *afaik
13:14:29 <[exa]> nitrix: well petri nets are slighly more limited but it you can simulate them, you know that you are tarpit-complete
13:14:38 <[exa]> oh i mean turing
13:14:50 <nitrix> Tarpit complete, haha :)
13:14:55 <nitrix> I'll start there, thanks c:
13:15:45 <[exa]> btw Kahn networks are slightly less degenerate petri nets, I guess that'd be closest to your model
13:16:42 <[exa]> also kahn nets have the "nice" property of requiring all inputs before producing the output, which kindof matches the requirement for N parameters
13:17:10 --- mode: glguy set +v zincy
13:17:14 <[exa]> (hopefully I remember that correctly)
13:17:26 <berndl> nitrix: it sounds like you are talking about data flow graphs?
13:17:29 <zincy> How do I fix this error given by stack? The following executables are missing and must be installed: bzip2, make, tar
13:17:41 <cocreature> zincy: install them?
13:18:14 <nitrix> Oh, I do not have a petri net actually. Since with a petri net, if a place is shared by two transitions, you get non-deterministic behavior.
13:18:26 <nitrix> In my case, the message gets copied and both nodes receives it.
13:18:47 <nitrix> berndl: correct sir :)
13:18:58 <[exa]> nitrix: "always sending to the left" is a perfect nondeterminism
13:19:05 <[exa]> :]
13:19:40 <max3> why can't you have vararg functions in haskell?
13:19:46 <[exa]> nitrix: btw you don't need to prove that you _have_ a petri net, you only need to know that if someone gives you a petri net, you can produce a program in your language/net that works the same
13:19:52 <Solonarv> you can, it's just a pain
13:20:00 <max3> Solonarv, how?
13:20:12 <cocreature> max3: printf is an example
13:20:18 <cocreature> but mostly it isn’t worth it
13:20:19 <max3> why do liftM1/2/3 exist then?
13:20:41 <Solonarv> because variadic functions are a giant pain in the rear most of the time
13:21:03 <[exa]> max3: well, mostly because no one knows which parts of the type are arguments and which are return value
13:21:13 <Solonarv> also, please don't use liftM1/2/3; use the liftA* equivalents instead
13:21:21 <nitrix> If you think of what problem variadic functions attemps to solve, you'll find that there are alternative ways to go about it.
13:21:27 <zincy> cocreature: they are installed :D
13:21:43 <cocreature> zincy: show us the full error message and the command that caused it
13:21:48 <max3> Solonarv, why?
13:21:48 <[exa]> max3: see map :: (a->b) -> ([a] -> [b]) -- does it take 2 arguments (function and list, to return list) or 1 argument (function, to produce a better function) ?
13:22:24 <max3> [exa], ah
13:22:26 <Solonarv> the thing is, if you have a function 'f :: Foo -> Bar -> Baz' it's actually a 1-arg function (takes a 'Foo') which returns another function; that one takes a 'Bar' and returns a 'Baz'
13:22:55 <nitrix> Partial application with variadic functions, ouch.
13:23:31 <nitrix> How does it knows when you're done applying :P ?
13:23:57 <Solonarv> vararg interacts especially badly with polymorphism; if you want e.g. a variadic sum (restricted to only work on some monomorphic number type, e.g. Int) that's not too bad
13:25:54 <[exa]> cocreature: wow PrintfType is evil. :D
13:26:18 <cocreature> [exa]: not that much worse than printf in C :)
13:26:18 <nitrix> [exa]: How does SKI works when you don't have first class functions?
13:26:30 <nitrix> [exa]: I and K are fine, but 
13:26:34 <[exa]> nitrix: "not much."
13:26:39 <nitrix> I see.
13:26:48 <[exa]> cocreature: I didn't imply that :D
13:27:07 <ggVGc> I saw a presentation on petri nets once, but I never understood why I'd want to use them over state machine
13:27:10 <ggVGc> s
13:27:11 <ggVGc> or how they're very different
13:27:23 <ggVGc> the talk was about replacing state machines with petri nets
13:27:26 <ggVGc> I found it weird
13:28:10 <[exa]> ggVGc: it's a better model for distributed and nondeterministic processes
13:29:19 <[exa]> ggVGc: (don't ask me why though)
13:29:27 <ggVGc> I guess the talk told me why
13:29:35 <[exa]> nitrix: anyway, how do you e.g. compute IKII ?
13:29:36 <ggVGc> I just remember leaving the talk going "hm, that doesn't seem worth the effort"
13:30:45 <nitrix> [exa]: From my understanding right now, I don't think I can pass I to K either.
13:31:21 <Solonarv> side note: if you *just* want SKI, they don't actually need to be functions
13:31:22 --- mode: glguy set +v dmrd_
13:31:40 <nitrix> [exa]: The graph, nodes are computation, edges are message passing. The computations cannot pass themselves to each others, it's the messages that moves around.
13:31:41 --- mode: glguy set -v dmrd_
13:32:10 <[exa]> nitrix: can you pass a reference to the graph? (say, a continuation)
13:32:28 <dmrd_> hey peeps, anyone familiar with regex in Haskell? Trying to read this SO answer: https://stackoverflow.com/questions/45467695/extract-string-between-two-substrings-in-haskell
13:32:33 <nitrix> Nope, but you can arbitrarily connect any node to any other node :/
13:32:38 <nitrix> Assuming the types matches.
13:32:52 <[exa]> on the fly?
13:33:09 <nitrix> Nope.
13:33:18 <nitrix> The graph is static.
13:33:28 <[exa]> then SKI is probably not the right model, you'll need something with simpler values
13:33:50 <[exa]> OTOH I guess a turing machine won't be that hard
13:34:00 <[exa]> you can make up a graph that simulates the DFA
13:34:10 <[exa]> and a long line of vertices that are the tape
13:34:35 <[exa]> and some command that makes them all pass messages "to the left" and "to the right" so that you've got movable tape
13:34:41 <[exa]> and done.
13:35:23 <nitrix> I can just have the tape be a message and pass the tape around and mutate that.
13:35:39 <[exa]> we're usually proving that brick-laying is T-complete first, but I have no idea how that problem is called in english
13:35:54 <[exa]> also.
13:36:20 <nitrix> The messages are ADTs.
13:36:45 <[exa]> what can you do with the ADT in one message?
13:36:56 <[exa]> oh, I mean "in one vertex"
13:38:14 <nitrix> You can deconstruct the ADT, access what it contains, reconstruct it, etc.
13:38:19 <[exa]> anyway, if you can store 2 lists with 0/1 there, you're done; you can send the tape as the message that marks the "program pointer" in the machine, and have the nodes mutate that using the turing machine
13:38:32 <nitrix> Crearting an ADT generates new kinds of vertices that you're able to use.
13:38:39 <[exa]> which is usually at most one patternmatch and one deconstruction/construction at the lists
13:39:02 <[exa]> can you choose where to send the message next?
13:39:38 <nitrix> [exa]: The edges between vertices are static, but you can chose which edge the message is sent on, so you do have branching in that manner.
13:39:59 <[exa]> *music playing* Your system is now Turing-Complete!
13:40:06 <nitrix> Whooo!
13:40:32 <nitrix> So I throw SKI out of the window then.
13:40:35 <nitrix> ski: Sorry friend.
13:40:35 <Solonarv> if you have ADTs you can also do SKI: 'data SKI = App SKI SKI | S | K | I'
13:40:37 <cocreature> *confetti*
13:41:23 <[exa]> also, it could be T-complete even if you could have just 1 integer message and 1 infinite loop, rest being the gödel's one-step interpreter
13:41:31 <nitrix> Solonarv: Right, it ends up being encoded as data, then you need to interpret it.
13:42:02 <nitrix> I see.
13:42:02 <[exa]> (which is a degraded case of what Solonarv suggests)
13:42:04 <Solonarv> yep, same as the turing-machine approach really
13:42:13 <[exa]> yeah
13:42:34 <nitrix> Thank you good sir :)
13:43:13 <nitrix> [exa]: Here's you complimentary catgirl https://media.discordapp.net/attachments/396456638950801409/506896685142638592/cyan.gif
13:44:08 <nitrix> Also good Halloween to others c:
13:44:24 <[exa]> hopefully they sing about turing completeness
13:44:33 * [exa] from non-halloweenish part of the world
13:46:43 <djbeau> /buffer clear
13:47:12 <nitrix> http://i.imgur.com/t7qWf.jpg
13:47:17 <nitrix> Reddit sure is creative.
13:48:12 <cocreature> nitrix: I found https://twitter.com/SWI_Prolog/status/1057427428161728512 to be significantly more scary :)
13:49:37 <Solonarv> nitrix: in case you were wondering: https://gist.github.com/Solonarv/2dd9edc4a496d439bab44d1a06d0a42b - if I'm guessing right this should be fairly straightforward to encode
13:49:44 <nitrix> BUT lazy-evaluated, so that everything seems to work for a while, until it doesn't.
13:50:28 <Solonarv> sp00py
13:50:52 <nitrix> Solonarv: A is an application, which is just more reduction?
13:51:01 <nitrix> Fancy.
13:51:59 <Solonarv> yes, reducing application is basically just "reduce the function & arg, then see if one of the rules matches"
13:52:11 <Solonarv> hmm... actually don't need to reduce the arg so eagerly
13:52:43 <nitrix> It makes no difference in my case. My language has neither eager nor lazy evaluation.
13:53:29 <cjay-> cocreature: Why are Prolog people joking about dynamic typing?
13:54:37 <nitrix> In theory the expressions ecode are a graph, which you'd think is eager, but the connections are also bounded, which creates back-pressures and behaves like lazy-evaluation too.
13:54:56 <Solonarv> hah
13:55:13 <cocreature> cjay-: because some people are able to laugh about themselves? :)
13:55:17 <nitrix> The generators wont generate messages of the bounded edges are full, so yeah, fancy stuff c:
13:55:25 <Solonarv> but the change I was referring to doesn't have anything to do with laziness-as-a-language-feature, really
13:55:32 <nitrix> Oh ok
13:55:45 <nitrix> I forked it to digest it home tonight :)
13:56:37 <Solonarv> I updated it, so... you may need to re-fork it or something? I'm not familiar with how forking gists works, exactly
13:56:41 <nitrix> Done
13:57:22 <Solonarv> disclaimer: it may be subtly wrong in some way, I jst banged it out from memory
13:57:58 <Welkin> how do I pretend a character is a word8?
13:58:28 <Solonarv> you feel bad because that's not how unicode works?
13:58:30 <nitrix> ata.ByteString.Char8 ?
13:58:33 <Clint> throw away a bunch of bits
13:58:54 <Welkin> > Data.ByteString.dropWhile (/= ('/' :: Word8)) ("hello/world" :: ByteString)
13:58:57 <lambdabot>  error:
13:58:57 <lambdabot>      Not in scope: type constructor or class ‘ByteString’
13:58:57 <lambdabot>      Perhaps you meant one of these:
13:59:11 <Welkin> that's what I am trying to do
13:59:26 <Welkin> I suppose I could convert to Text to do it and then convert back to bytestring
14:00:34 <cocreature> Welkin: there is an utf8-string package
14:00:45 <Solonarv> fromEnum / toEnum will let you convert between a Char and its codepoint; the rest is simple stuff like "die screaming if the value is >=255"
14:01:19 <cocreature> or if you really hate yourself, truncate silently, i.e., do what Data.ByteString.Char8 does
14:01:47 <Solonarv> it should really throw an error instead of silently doing the wrong thing IMO
14:01:58 <nitrix> For a character literal, I see no harm.
14:02:04 <Welkin> well, it is a either a specific string that I am chopping off, or it is not valid and should fail
14:02:10 <nitrix> (An ASCII one)
14:02:24 <Welkin> it is for the rawPAthInfo of the Request object in my reverse proxy
14:02:27 <Welkin> which works!
14:02:37 <Welkin> but I have to modify rawPathInfo instead of pathInfo
14:03:41 <Welkin> > toEnum '/'
14:03:44 <lambdabot>  error:
14:03:44 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Char’
14:03:44 <lambdabot>      • In the first argument of ‘toEnum’, namely ‘'/'’
14:03:53 <Welkin> > ord '/'
14:03:55 <lambdabot>  47
14:04:12 <Solonarv> > fromEnum '/'
14:04:15 <lambdabot>  47
14:04:19 <Solonarv> other way 'round
14:04:22 <Welkin> how do I convert an Int to a Word8?
14:04:52 <cocreature> fromIntegral
14:05:01 <Ariakenom> Solonarv: "die screaming if the value is >=128"
14:05:06 <Welkin> maybe it would be easier to just decode/encode ByteString <-> Text
14:05:13 <Solonarv> yes, it would
14:05:17 <Solonarv> and more correct to boot
14:05:45 <Ariakenom> :t fromIntegral . fromEnum
14:05:47 <lambdabot> (Enum a, Num c) => a -> c
14:08:09 <dminuoso> Mmm. throwTo kind of reminds me of POSIX signals in linux that, in effect, do not propagate until a thread yields (by doing a syscall) - after all preemption is nowadays a rare thing.
14:08:46 <Solonarv> % :i Data.Text.Encoding.encodeUtf8 -- this is the function you (probably) want
14:08:46 <yahb> Solonarv: ; <interactive>:1:3: error: parse error (possibly incorrect indentation or mismatched brackets)
14:08:59 <Solonarv> well, or its decodeUtf8 counterpart
14:10:16 <cocreature> dminuoso: not sure what you mean by that. the exception gets thrown without the thread yielding explicitely
14:12:31 <Ariakenom> does throwTo interrupt blocking operations?
14:13:16 <cocreature> define “blocking” :)
14:14:01 <Ariakenom> haskell-thread blocked. file io, mvars, stm transactions
14:14:16 <dminuoso> cocreature: So in effect when a process in linux does a syscall, it acts as an implicit yield so the scheduler is called.
14:14:29 <johnw> is there a function that turns a Float into its IEEE formatted bits? Should I just use Binary.Put and then take the first 32 bits of the ByteString?
14:14:52 <dminuoso> cocreature: Similarly in GHC a throwTo'd exception would not be raised until a memory allocation is done. 
14:15:16 <jle`> johnw: that's what i have heard people say to do in the past fwiw
14:15:50 <johnw> kk
14:16:26 <cocreature> Ariakenom: yes, for those operations in particular even if they’re inside "mask" (uninterruptibleMask forbids even that)
14:17:01 <cocreature> dminuoso: I guess I have a hard time seeing a memory allocation as yielding given how common they are
14:17:16 <johnw> jle`: https://stackoverflow.com/questions/6976684/converting-ieee-754-floating-point-in-haskell-word32-64-to-and-from-haskell-floa
14:18:59 <Ariakenom> does Binary specify endianness?
14:19:15 <dminuoso> cocreature: The same could be said about syscalls. ;)
14:19:44 <dminuoso> cocreature: at what point does the RTS scheduler get called? Is it on each allocation?
14:20:24 <Ariakenom> cocreature: thanks. An exception being -fno-omit-yield related and inconsistent data loop in stm
14:21:01 <cocreature> dminuoso: not entirely sure, as Ariakenom mentioned if you compile with -fno-omit-yields then even a non-allocating loop gets killed
14:23:41 <Welkin> wow!
14:23:45 <Welkin> everything works
14:24:02 <Welkin> couchdb syncing works fine through my reverse proxy inside a wai application
14:24:12 <Solonarv> \o/
14:30:31 <jle`> johnw: ah interesting, thanks :)
14:53:02 <max3> so how many monads can i stack using monad transformers?
14:53:25 <o1lo01ol1o> max3: as many as you want.
14:53:38 <johnw>  millions, billions
14:53:43 <max3> of course but i'm going to get lift lift lift ...
14:53:44 <max3> right?
14:53:47 <johnw> yep
14:54:02 <max3> is there a simpler way to do this?
14:54:09 <o1lo01ol1o> you can alwasy alias the lifts though 
14:54:11 <int-index> yes but you don't have to write them manually if you use mtl-style classes
14:54:16 <o1lo01ol1o> myLift = lift .lift
14:54:18 <johnw> usually most of the functions you write only need to address a specific part of the stack
14:54:32 <johnw> then you can write those functions using the mtl (MonadReader, etc.) and just compose them
14:54:57 <max3> hmm
14:55:14 <Solonarv> I can't recall the last time I saw a real codebase that used transformers, but not mtl
14:55:35 <int-index> if you use `ask` from mtl it's about the same as `(lift . lift . lift ...) ask` from transformers, where the amount of `lift` is computed automatically
14:55:36 <glguy> I do
14:55:48 <glguy> I mostly see transformers used without mtl
14:55:59 <ggVGc> more than meets the eye?
14:56:04 <max3> lol
14:56:08 <ggVGc> autobots waging war, against, the evil forces of
14:56:11 <ggVGc> the deceptikon
14:56:12 <ggVGc> sorry
14:56:54 <ggVGc> I feel awkward that I never use transformer stacks
14:56:58 <int-index> In any case, what's the use case for stacking more than 2-3 transformers?
14:57:01 <ggVGc> and everyone else seems to
14:57:34 <ggVGc> int-index: isn't the answer to that the same as "what's the reason for stacking 2-3 transformers"?
14:57:36 <Solonarv> I don't
14:57:57 <Solonarv> most of the time I use (a newtype over) ReaderT blah IO
14:58:29 <int-index> ggVGc:  hmm not really, 2-3 transformers could be ReaderT, ExceptT, ResourceT, but even more?
14:59:00 <Solonarv> occasionally I might wrap a small section in MaybeT / ExceptT (or ResourceT I suppose, but that hasn't come up yet)
14:59:50 <jle`> Solonarv: using transformers and not mtl is like using String, but not Monoid
15:00:11 <jle`> sure, String is an instance of Monoid, but there are other usages of it besides being used in monoid-polymorphic functions
15:00:52 <Solonarv> eh, I don't quite agree
15:01:19 <glguy> Yeah, there are a lot more valid uses of Monoid than the mtl classes
15:01:32 <jle`> Solonarv: there is no usage formonad transformers than just mtl class insatnces?
15:01:38 <jle`> what about using MaybeT for the Alternative instance?
15:01:57 <jle`> like using MaybeT to wrap [m (Maybe a)]'s so you can asum them to find the first non-Nothing reuslt
15:02:16 <johnw> MaybeT seems like the most unusable of the transformers
15:02:23 <johnw> any code I ever write using it ends up looking horrible
15:02:37 <johnw> probably because there's no good way to lift an a -> Maybe b arrow
15:02:47 <jle`> i use it for the Alterantive instance all the time
15:02:54 <jle`> usually not for its Monad instance
15:03:02 <Solonarv> no, I meant specifically something where you could've used mtl but instead used only base transformers
15:03:12 <jle`> it's a way to do m (Maybe a) <|> m (Maybe a)
15:03:30 <jle`> Solonarv: that's the opposite of what you originally said though, isn't it?
15:03:33 <glguy> The mtl doesn't really buy much other than saving a couple uses of lift when you're defining your domain-specific operations on the type you're using transformers to define, if you're using them at all
15:03:35 <jle`> you said you can't imagine someone using transformers without using mtl
15:03:51 <jle`> here's an example -- using MaybeT in a way that is unrelated to its Monad instance
15:03:55 <johnw> glguy: it lets you write functions that work with multiple transformer configurations
15:03:55 <Solonarv> i.e. using mtl methods to cut out lift-spam, or using it to restrict what effects are available in some particular function
15:04:14 <glguy> johnw: the mtl classes are almost always the wrong level of abstraction for that
15:04:51 * _deepfire waits until someone mentions free/freer monads..
15:05:09 <Solonarv> I expressed my thoughts badly earlier; I meant choosing not to use {thing from mtl} when it would cover the transformers-wrangling you're doing
15:05:26 <johnw> glguy: how so?
15:05:31 <int-index> I'm fairly convinced that it's a bad idea to write non-utility functions that use mtl classes
15:05:44 <Solonarv> what about mtl-*style* classes?
15:05:45 <glguy> They're far too generic, your classes should be more specific to the problem you're solving
15:06:11 <johnw> I don't see how MonadReader Foo is far too generic, when all I need to know is that there's a Foo accessible in the environment
15:06:17 <glguy> They're the class equivalent to using raw tuples and either everywhere instead of defining types specific to your domain
15:06:42 <dminuoso> So I have some `forall a. Async a` and some `Async Dat` - now I'd like to wire them such that errors from the first propagate to the second but not the other way around.
15:06:43 <Solonarv> ah, fair enough - in that case I retract my earlier statement
15:07:10 <glguy> You should be defining a class specific to Foo for the kinds of types that have access to a Foo, there's no need to drag MonadReader into your interface
15:07:23 <johnw> going to agree to disagree on this one, glguy
15:07:26 <glguy> and then hopefully no one else is using MonadReader at the same time
15:07:38 <glguy> because the fundep means you'll conflict, it's not not a good abstraction
15:08:27 <glguy> You can generally tell you're misusing mtl when you have to turn FlexibleContexts on
15:08:36 <glguy> then you know you're writing more than mtl utility functions out fo them
15:09:54 <dminuoso> Or maybe let me reapproach entirely. I have a bunch of TQueues which I use to communicate with a network service. Now there may be any number of threads using these TQueues to do their thing - how can I propagate errors from my TQueue threads to the users?
15:10:31 <johnw> you could have another TQueue thread where you post errors
15:11:26 <dminuoso> johnw: Would there be something like: TQueue a -> TQueue b -> STM (Either a b) then?
15:11:51 <johnw> i suppose you could right that, sure
15:12:00 <dminuoso> Mmm, it's almost <|>
15:12:13 <johnw> you may even want: TQueue a -> TQueue b -> STM (These a b)
15:12:44 <johnw> depends on what you're doing
15:14:11 <metreo> Interesting debate here: https://discourse.mc-stan.org/t/choosing-the-new-stan-compilers-implementation-language/6203/65
15:16:09 <dminuoso> :t \l r -> (Left <$> readTQueue l) <|> (Right <$> readTQueue r)
15:16:14 <lambdabot> TQueue a -> TQueue b -> GHC.Conc.Sync.STM (Either a b)
15:16:53 <johnw> that's going to block until an error occurs
15:17:02 <johnw> you'll want to tryReadTQueue
15:17:48 <dminuoso> johnw: Are you sure? I thought the Alternative on STM instance gave me non-determinism
15:17:58 <dminuoso> Sort of.
15:19:00 <dminuoso> I mean it uses `orElse`
15:19:06 <glguy> For STM, (<|>) = orElse, which is ordered
15:19:52 <dminuoso> Mmm.
15:26:07 <johnw> you can tryReadTQueue both, and then retry if they're both Nothing
15:26:12 <johnw> then you'll restart when one of them has data
15:27:20 <dminuoso> johnw: Mmm yeah it may be workable, but not exactly what Im looking for. Right now my internal TQueue magic are infinite loops of workers - my original thought was to propagate errors using throwTo.
15:27:55 <johnw> async can propogate nicely
15:28:05 <johnw> you might be interested in async-pool if you want a fixed set of workers
15:32:47 <dminuoso> johnw: Mmm I guess I could use waitEitherCatch and then propagate manually with `cancel` in one direction.
15:46:35 <bsima> Has anyone gotten hoogle to work with nix's 'developPackage'?
15:49:47 <johnw> bsima: I have
15:50:34 <johnw> it's not trivial, but: https://github.com/jwiegley/nix-config/blob/master/overlays/10-haskell.nix#L139
15:52:39 <bsima> johnw: thanks! this looks helpful, but do you have an example of using it in a defaul.nix file? I'm trying to avoid user-specific overlays
15:52:59 <bsima> I'd rather keep it in the project-specific git repo
16:05:57 <Axman6> @hoogle Alternative f => f a -> f b -> f (Either a b)
16:05:58 <lambdabot> Data.Attoparsec.ByteString eitherP :: Alternative f => f a -> f b -> f (Either a b)
16:05:58 <lambdabot> Data.Attoparsec.ByteString.Char8 eitherP :: Alternative f => f a -> f b -> f (Either a b)
16:05:58 <lambdabot> Data.Attoparsec.Combinator eitherP :: Alternative f => f a -> f b -> f (Either a b)
16:06:08 <Axman6> @more
16:06:13 <Axman6> :(
16:08:48 <o1lo01ol1o> I'm having some issues with a tls certificate.  I search through the store, get the correct certificate, make that a CertificateStore in sharedCAStore and set the supportedCiphers to ciphersuit_all.  However, the tls handshake to the server fails with a 443 certificate not supported: self-signed.  I'm not sure why, the same cert works in the browser when i view the test server's endpoint.  Can any one spitball some reasons why this might
16:08:48 <o1lo01ol1o>  be?
16:11:48 <inkbottle> > (.) _ flip take [1..5] 2
16:11:50 <lambdabot>  error:
16:11:51 <lambdabot>      • Found hole:
16:11:51 <lambdabot>          _ :: ([a0] -> Int -> [a0]) -> [Integer] -> Integer -> t
16:12:30 <inkbottle> My ghci doesn't give me the type of the hole...
16:12:55 <inkbottle> but instead: GHC internal error: ‘Ghci54.it’ is...
16:13:30 <geekosaur> version?
16:15:06 <inkbottle> how do I get the version with 'stack ghci'?
16:15:18 <bsima> johnw: FYI looks like shellFor might do it https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/make-package-set.nix#L234-L261
16:15:55 <johnw> bsima: I use it in combination with a regular default.nix by having a pkgs parameter that I override to point to my locally overriden package set
16:15:59 <inkbottle> geekosaur: version 8.4.3
16:16:49 <geekosaur> I think that's expected; the 8.4.4 release notes said something about fixes to typed holes in ghci
16:17:03 <inkbottle> OK, thanks
16:17:43 <marvin2> you can use  `stack ghc --' to pass options directly to ghc. ie, `stack ghc -- --version'
16:18:13 <marvin2> I have 8.0.2, and I get hole error. so it is a new error, and an even newer fix
16:28:11 <inkbottle> I changed the resolver to lts-12.16, and did a 'stack build', and 'holes' is working again :)
16:31:00 <inkbottle> But `stack install --resolver lts-12.16 intero` fails
16:34:14 <inkbottle> maybe it doesn't matter
16:53:28 <tnks> infrastructure question:  Cabal check says that -Werror is not great to turn on by default without a flag, but I couldn't figure out how to get make-travis-yml to set a flag.
16:54:06 <tnks> are people just editting the .travis.yml through more rudimentary means?  or is there a better way?
16:56:47 <Solonarv> travis has a command-line app which can maybe help? I don't really know what it does, only that it exists
17:03:07 <tnks> Solonarv: I think that's what I'm using... make-travis-yml.  the output is markedly fancier than what I'd likely handroll myself.
17:03:49 <tnks> the script is called make-travis-yml, but the Hackage package is called haskell-ci
17:31:35 --- mode: glguy set +v jackdk
18:08:19 <inkbottle> intero was not compatible with resolver: lts-12.16; I added "allow-newer: true" in "~/.stack/config.yaml" as suggested; and it did work.
18:13:08 <MarcelineVQ> that's useful to know, thank you
18:30:57 --- mode: glguy set +v fen
18:31:42 <fen> hi! here is the "slow" implementation of the class Graph;
18:31:42 <fen> https://bpaste.net/show/edd38464d2d9
18:32:12 <fen> it uses the example of creating a differencelist for NonEmpty 
18:33:37 <fen> no it doesnt, the example is using Skip
18:33:52 <fen> it differs from the "fast" example; https://bpaste.net/show/06f2ba790c31
18:34:07 <fen> which has much less friendly types
18:34:12 <fen> but is faster...
18:35:53 <_deepfire> inkbottle: if you are using emacs, you can try dante, which only needs ghci
18:36:46 <fen> the reason this newer slow versions types are preferable is that the Segment corresponds directly with a "structure directing index" which is used in the argument to SetiS, the safe way to create and append containers using Nothing in place of empty
18:37:44 <fen> the faster version avoids much use of Maybe by unsafely collapsing the difference list on undefined instead of Nothing
18:38:23 <fen> this is done using foldr (.), while this slower safer version of difference list is [Maybe a -> a]
18:39:56 <fen> the sequence of differences are produced using a default implementation of GetiS provided by Graph
18:40:56 <fen> this is the central result, that the class of Graphs, which are those things that can have difference lists made of them, provides a default for the type of GetiS;
18:41:05 <fen> getiS :: f a -> ((i,a),Maybe (f a))
18:42:02 <fen> comparing this with the (safe) opposite of (:), uncons :: [a] -> (a,Maybe [a])
18:42:49 <fen> the "structure directing index" can be seen. this type 'i' allows the "shape" of the container to be retained as an additional argument to the constructor
18:42:58 <fen> setiS :: ((i,a),Maybe (f a)) -> f a
18:44:12 <fen> combining these (retrieving a value from the container, along with its structure directing index, and applying this to getiS) returns the safe difference;
18:44:14 --- mode: glguy set +v jackdk_
18:44:17 --- mode: glguy set -v jackdk_
18:44:24 <fen> (Maybe (f a) -> f a)
18:45:43 <fen> the class Graph, by providing a default for GetiS, serves as an interface for the construction of such containers that support a difference list representation
18:46:15 <fen> this (to be presented later) gives rise to Comonad, MonadPlus and Traversable
18:46:40 <fen> and captures most useful containers, and gives a reasonable notion of "Pointers"
18:47:15 <fen> replacing the implementation of these central classes with defaults (for use with DerivingVia)
18:48:59 <fen> I shall return later for an example of this for StemTree, an example of a "shaped" container
18:49:27 <fen> (the previous demonstraition of this was with the fast implementation which does not have such nice types)
18:51:05 <Welkin> apparently apache has a custom http status code: 218 This is fine
18:51:06 <Welkin> https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#Unofficial_codes
18:51:20 <Welkin> it's from a meme
18:53:35 <fen> note; the Comonad is actually over the "Pointer" which is can be thought of as a higher dimensional version of a Zipper...
18:55:25 <fen> this is the "one hole context" or derivative of a Graph
19:12:42 <rotaerk> code: https://ptpb.pw/rkn0/hs  error: https://ptpb.pw/fNGc
19:12:53 <rotaerk> why won't the e type parameter unify there?
19:17:53 <rotaerk> of course, my unify function could be replaced with proxyT, but that also doesn't work
19:17:53 <ClaudiusMaximus> rotaerk: try rewriting it with parentheses instead of . and $
19:18:29 <rotaerk> hrm, that worked ...
19:18:42 <geekosaur> this is impredicativity vs. (.)
19:18:53 <Welkin> in aeson, to use direct encoding via toEncoding, how can I use this on a Text value?
19:19:04 <geekosaur> aak wy you can't say runST  (...) but ($) will work because of a typechecker hack
19:19:10 <geekosaur> er, runST . (...)
19:19:18 <geekosaur> *aka why
19:19:29 <Welkin> I have a Text in a newtype wrapper. Using Generic doesn't work because it fails to unwrap it for me
19:19:56 <rotaerk> weird; kinda don't want to use ()s in this context though; will need to figure out a way to eliminate that
19:19:57 <Welkin> of course I can do it with toJSON, but I am converting everything to using direct encoding
19:20:40 <rotaerk> oh, I can just replace . with $ and it works
19:21:05 <rotaerk> anyway, thanks guys
19:21:07 <Welkin> avoiding parentheses is stupid
19:21:13 <Solonarv> how about turning on -XDerivingStrategies and going 'newtype MyText = MyText { unMyText :: Text } deriving newtype (ToJSON, FromJSON)' ? that should do hat you want
19:21:25 <Welkin> parentheses will never get you in trouble and they always make it clear what is happening
19:21:32 <Welkin> $ on the other hand will screw you up bad
19:22:13 <Solonarv> 'deriving newtype' is basically just "please reuse the instances for 'Text'" (in this context)
19:22:27 <rotaerk> Welkin, depends.
19:22:32 <Welkin> but does that write the instance with direct encoding?
19:22:42 <Welkin> using toEncoding instead of toJSON
19:22:59 <Solonarv> sure, if the 'Text' instance has toEncoding defined
19:23:02 <Solonarv> I would assume it does
19:23:10 <Welkin> I typically avoid letting the compiler write instance for me because I don't know what it is generating
19:23:13 <geekosaur> I thik (.) also works with an explicit type; impredicative types can't be inferred
19:23:21 <Solonarv> it isn't generating anything
19:23:27 <Welkin> there is no ToEncoding instance for Text
19:23:30 <Welkin> which is the problem
19:23:31 <Solonarv> it's reusing the instance for 'Text'
19:23:33 <heptahedron> Welkin: I think `-ddump-deriv` lets you see what it generates :)
19:23:51 <Solonarv> I was under the impression toEncoding was a method of ToJSON ?
19:24:28 <Welkin> oops
19:24:35 <Welkin> I mean there is no Generic instance for Text
19:24:53 <Solonarv> it doesn't need a Generic instance! it already has a ToJSON instance
19:24:59 <Welkin> tell that to ghc
19:25:09 <lyxia> note Solonarv said "derive newtype"
19:25:21 <Solonarv> yes, that's the important part
19:25:40 <Welkin> I haven't used DerivingStrategies before
19:25:56 <Welkin> how is that different from DeriveGeneric or GenericNewtypeDeriving
19:26:14 <lyxia> it allows you to choose between GenericNewtypeDeriving and DeriveAnyType
19:26:21 <Solonarv> 'deriving newtype' explicitly tells ghc to please use GeneralizedNewtypeDeriving
19:28:07 <geekosaur> basically, if generics and newtype deriving are both active, generics wins. deriving strategies lets you say "no, I want the newtype here"
19:29:13 <Welkin> so https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extensions-to-the-deriving-mechanism
19:29:20 <Welkin> wow there are a lot of thes extensions
19:29:36 <Welkin> which ones are recommended for use with 8.4+?
19:30:37 <Solonarv> there are three different deriving strategies:
19:30:37 <Solonarv> 'stock', which does Actual Work (tm) and actually writes an instance. This is the mechanism for Eq, Show &c; and also for DeriveFunctor/Foldable/Traversable/&c
19:30:37 <Solonarv> 'newtype', aka GeneralizedNewtypeDeriving. This doesn't do any actual work, and basically just 'coerce's the instance methods
19:30:37 <Solonarv> 'anyclass', which essentially just writes an empty instance; i.e. 'deriving anyclass MyClass' is equivalent to 'instance MyClass Foo where {}'
19:32:44 <Welkin> okay
19:32:56 <Welkin> to DerivingStrageies replaces most of the others
19:32:58 <Welkin> so*
19:36:13 <Solonarv> from a quick scroll through: none of the deriving extensions are problematic, so just turn on whichever ones you need
19:38:41 <Welkin> it still is wrong
19:38:58 <Welkin> it fails to unwrap the newtype, which is what I expect it to do
19:39:20 <Solonarv> I really can't help you any more than that without seeing some sample code
19:41:27 <Welkin> https://hastebin.com/onayewogej.hs
19:42:01 <Welkin> sadly there is no syntax highlighting, but lpaste is broken these days too
19:44:34 <Welkin> I was using: toJSON (GameId id_) = toJSON id_
19:44:45 <Welkin> which works perfectly, so I may as well keep using it
19:44:48 <Solonarv> https://hastebin.com/wiqelupevo.hs
19:44:57 <Solonarv> this is what you want, I think
19:45:00 <Welkin> even though, supposedly, you are supposed to be able to use the new direct encoding method
19:46:05 <Solonarv> does what I wrote make sense to you?
19:46:38 <Welkin> yes, it does
19:46:42 <Welkin> but it doesn't work
19:46:47 <Welkin> I tried something very similar earlier
19:47:02 <Welkin> No instance for (Generic Text)
19:47:13 <Welkin> The type family application ‘Rep Text’
19:47:13 <Welkin>         is no smaller than the instance head
19:47:25 <Welkin> so back to toJSON I suppose
19:47:44 <Solonarv> so, what did you try that is similar?
19:48:03 <Welkin> those errors are form your example
19:48:20 <Welkin> I did the same thing earlier but without the `stock` in deriving Show
19:48:52 <Welkin> also my editing mode doesn't like multiple dericing clauses
19:48:57 <Welkin> deriving*
19:49:05 <Welkin> maybe it needs an update
19:49:17 <Solonarv> probably, deriving strategies are new-ish
19:52:21 <Solonarv> FYI: I'm having a look at aeson, but my laptop is being horrendosly slow
19:56:54 <Solonarv> well there is definitely a ToJSON Text instance, so I'm not sure what's going on
19:58:22 <Solonarv> if you're writing it yourself, it should look like the following: instance ToJSON GameId where toJSON = coerce (toJSON @Text); toEncoding = coerce (toEncoding @Text)
19:58:27 <Solonarv> Welkin: ^
19:59:18 <Welkin> right, there is a ToJSON instance, but no Generic instance of Text
20:00:23 <Solonarv> ...why would it need a Generic instance?
20:02:22 <Welkin> for generictoEncoding, which I was using
20:02:58 <Solonarv> why would you use genericToEncoding!?
20:03:21 <Welkin> it's in the docs for aeson on how to use direct encoding
20:03:34 <Welkin> I never thought of using coerce
20:03:44 <Welkin> is that from Data.Coerce or GHC.Prim?
20:03:47 <Solonarv> *how* are you using genericToEncoding, if you're just writing 'deriving newtype (ToJSON)'
20:04:01 <Welkin> I was deriving Generic
20:04:07 <Solonarv> what for?
20:04:18 <Welkin> https://hackage.haskell.org/package/aeson-1.4.1.0/docs/Data-Aeson.html#g:7
20:04:21 <Solonarv> (it's in Data.Coerce, btw)
20:04:22 <Welkin> there
20:05:15 <Solonarv> that link says "To write a **minimal implementation of direct encoding**"
20:05:19 <Solonarv> which is not what you're doing!
20:05:36 <lyxia> This documentation only explains how to use generic deriving, but in this case you want newtype deriving.
20:05:42 <Solonarv> you need Generic to that aeson can automatically figure out what the instance should look like
20:06:34 <Solonarv> if you're telling GHC "please re-use the Text instance", aeson doesn't need to automatically figure out anything, and you don't need a Generic instance
20:07:48 <Welkin> oh nice
20:07:56 <Welkin> deriving newtype (ToJSON) works
20:08:18 <Welkin> as I expect, unwrapped
20:11:15 <Welkin> but I wonder if it is using direct encoding or not
20:12:38 <Solonarv> yes, it is
20:12:44 <Solonarv> because the Text instance is
20:12:52 <Welkin> in ghci it works with toEncoding
20:13:06 <Solonarv> toEncoding always works
20:13:09 <Welkin> so does my instance of a sum type I derived using Generic
20:13:39 <Solonarv> toEncoding has a default definition which is roughly 'toEncoding = encodeJSON . toJSON'
20:13:59 <Solonarv> the reason it's a separate method is that it's faster to skip the intermediate Value
20:14:08 <Welkin> which is what I'm trying to do
20:14:13 <Welkin> but may be pointless anyway
20:14:27 <Solonarv> and which you successfully did with 'deriving newtype (ToJSON)'
20:16:58 <Welkin> I wonder if there is a way to do this for my simple sum type too
20:17:04 <Welkin> without deriving generic first
20:17:42 <Solonarv> how do you want to 'derive *newtype*' on something that *isn't a newtype* ?
20:18:28 <Welkin> not newtype obviously
20:18:49 <Welkin> I just see so many deriving mechanisms, I wonder which ones I should be using
20:19:21 <Welkin> I can derive Generic (which seems to just use a default Show instance)
20:19:24 <Solonarv> in that case, your options are: write an instance by hand; get one for free via Generic; or get one for free via template haskell
20:19:40 <Solonarv> generic is *completely* unrelated to show
20:19:43 <Welkin> I avoid template haskell at all costs
20:20:05 <Solonarv> I avoid it too, I just wanted to mention it for completeness' sake
20:20:09 <Welkin> what I mean is that the derived instance looks like it gives the same result as a derived Show
20:20:25 <Solonarv> ...what?
20:20:35 <Welkin> Player becomes "Player"
20:20:52 <Welkin> in a json instance derived using generic
20:20:57 <geekosaur> it's not quite the same and there are knobs to change that
20:21:00 <Welkin> ToJSON
20:21:04 <geekosaur> verymuch unlike Show
20:21:56 <Welkin> I usually write explicit instance anyway to control exactly how the transformation happens in each case
20:22:11 <geekosaur> basically the defaultis to use Show to get the name, but you can specify a transformation to match whatever the JSON consumer expects
20:22:22 <Welkin> are these deriving mechanisms really worth it?
20:22:49 <Solonarv> they let you write 'deriving newtype (ToJSON)' and then boom! you have an instance
20:23:23 <Solonarv> and presumably when you're doing this you know what the underlying instance (in your case, the one for Text) does and want to reuse it
20:24:07 <Welkin> I already had one in one line I wrote myself too, using toJSON = toJSON . unGameId
20:24:23 <Solonarv> yes, but that one didn't have fast toEncoding
20:25:15 <Solonarv> and it's also not as immediately clear (IMO) that you're simply reusing the underlying instance
20:34:45 <koz_> If I have something like 'do s <- get; return (HS.size s == i)', is there a way I can rewrite it without do-notation?
20:35:20 <Welkin> of course
20:35:20 <glguy> fmap
20:35:29 <Welkin> do-notation is just sugar for bind and lambda
20:35:36 <Welkin> you never have to use it
20:35:38 <jle`> and sometimes case statements
20:35:51 <glguy> and when following a 'c'
20:35:54 <Welkin> get >>= \s -> HS.size s == i
20:36:08 <jle`> (== i) <$> gets H.size
20:36:14 <koz_> :t gets
20:36:16 <lambdabot> MonadState s m => (s -> a) -> m a
20:36:26 <koz_> Ah, I see now.
20:36:39 <Solonarv> desugaring do notation is very straightforward; even lambdabot can do it!
20:36:51 <Solonarv> @undo do { s <- get; return (HS.size s == i) }
20:36:52 <lambdabot> get >>= \ s -> return (HS.size s == i)
20:36:55 <koz_> I'm clearly dafter than a bot.
20:37:01 <koz_> jle`: Thanks!
20:37:05 <Welkin> I forgot the return/pure 
20:37:14 <jle`> there are a lot of things lambdabot can't do that most people can't
20:37:18 <jle`> > 283740234834 * 89023409234
20:37:22 <lambdabot>  25259523041778444057156
20:37:26 <Solonarv> not dafter, you just don't know the algorithm
20:38:42 <Solonarv> how to @undo 101: 'x <- blah' turns into 'blah >>= \x ->', 'foo; bar' turns into 'foo >> bar'
20:38:51 <Solonarv> congratulations! that's pretty much it
20:39:15 <jle`> it's a little more complicated when you get into pattern matches
20:39:18 <jle`> and there's also 'let'
20:39:27 <koz_> Solonarv: Thanks, but I was after more something like jle`'s use of <$> and gets.
20:39:33 <jle`> but for the most part it's pretty mechanical
20:39:34 <koz_> In particular, gets isn't something I knew about.
20:39:54 <jle`> you can also just use get and compose functions
20:40:01 <jle`> hm actually you could compose the get function to
20:40:09 <jle`> (== i) . HS.size <$> get
20:40:19 <koz_> Oooh, nice.
20:40:24 <jle`> gets ((== i) . HS.size)     -- also works
20:40:29 <Solonarv> right, I forgot about let; that one's just 'let y = blah' turns into 'let y = blah in'
20:41:03 <Solonarv> you may notice that the desugarings of 'let' and '<-' aren't valid syntax; that's why they can't be the last statement in a do block
20:42:54 <koz_> Solonarv: Thanks for the refresher.
20:44:20 <heptahedron> jle`: how does it get more complicated in terms of pattern matches?
20:44:28 <koz_> @pl \s -> HS.insert r s
20:44:29 <lambdabot> HS.insert r
20:44:34 <koz_> ... wow I'm slow today.
20:44:38 <jle`> heptahedron: consider do Just x <- blah; blahblah
20:45:06 <Solonarv> the TL;DR is that the desugaring inserts a case statement which will call 'fail "some informative error message' if the pattern match fails
20:45:08 <jle`> this desugars to blah >>= \xx -> case xx of Just x -> blahblah; _ -> fail "pattern match failure"
20:45:22 <jle`> but we can just check @undo
20:45:27 <jle`> @undo do Just x <- blah; blahblah
20:45:28 <lambdabot> blah >>= \ a -> case a of { Just x -> blahblah; _ -> fail ""}
20:45:35 <jle`> oh looks like i got the string wrong
20:45:45 <koz_> jle`: Empty string, maximally informative. :P
20:45:51 <Solonarv> no I think that's just lambdabot being simplistic
20:46:27 <heptahedron> Ah, interesting. So in non-do notation that would do, what, `error "pattern match failure"`?
20:46:41 <Solonarv> also, that 'fail' used to be 'Control.Monad.fail' (a method of the 'Monad' class); it's supposed to be the sae method, but from MonadFail
20:46:55 <jle`> heptahedron: it wouldn't be any desugaring
20:47:18 <Solonarv> heptahedron: depends on the monad; there's a bit of ugly history there, because 'fail' doesn't actually work/isn't meaningful for every monad
20:47:32 <heptahedron> I just meant in the general case for e.g. lambdas or let
20:47:50 <jle`> yeah, it wouldn't be desugard to anything
20:47:58 <Solonarv> oh that; fail isn't special syntax, it's an ordinary typeclass method
20:48:00 <jle`> it might just explode if you try to evaluate
20:48:33 <koz_> Oh, interesting - Typeclassopedia now has a MonadFail section, but hasn't been fully edited to fit.
20:49:39 <Solonarv> in 'IO', fail throws a runtime exception (which is more or less correct, IMO); in 'Maybe', it gives you Nothing; in '[]', it gives you [] (the empty list)
20:49:43 <heptahedron> Solonarv: No I know, I just expected that it would do something similar if you did 'let Just x = Nothing in x', but instead of generating a value of 'm a' for the missing cases it would generate a value of 'a', using 'error'
20:50:02 <Solonarv> heptahedron: desugaring doesn't change the type of the expression
20:50:07 <jle`> heptahedron: yeah, it doesn't do that
20:50:14 <heptahedron> Solonarv: I know it doesn't
20:50:39 <Solonarv> so, you were expecting something like 'pure (error "urk")'?
20:51:28 <heptahedron> Solonarv: No, I was referring to non-covering pattern matches in the general case, outside of do-notation, in lambda and let expressions--no monads involved
20:51:52 <Solonarv> oooh, outside of do-notation - yeah that just gives you 'error "urk"'
20:52:01 <jle`> that isn't "replaced" or "desugard" or anything, because it's already as-it-is
20:52:23 <jle`> it's not the same as error
20:52:34 <jle`> > let Just x = Nothing in "hello"
20:52:37 <lambdabot>  "hello"
20:52:45 <jle`> there is no error or anything going on
20:52:47 <Solonarv> incomplete pattern matches only turn into 'fail' calls in a do block (or a list comprehension, which is basically the same thing)
20:53:23 <Solonarv> jle`: sure there is, it just doesn't get tripped because you're not using x
20:53:34 <Solonarv> > let Just x = Nothing in (x :: String)
20:53:37 <lambdabot>  "*Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Ju...
20:53:49 <jle`> where is the 'error' coming from?
20:54:04 <jle`> it's not really a desugaring
20:54:08 <jle`> it's just a separate thing
20:54:27 <Solonarv> the fact that 'error''s argument is "urk" was meant to indicate that I'm not being exact
20:55:04 <jle`> so what would the exact statement be?
20:55:34 <Solonarv> no idea, I don't know internals well enough
20:55:50 <rotaerk> hmm looking for something like... Monad m => (s -> a -> Maybe s) -> s -> m a -> m [a]
20:56:35 <rotaerk> basically runs `m a` an initially unknown number of times, and collects all the a's.  the function tells it when to stop
20:56:37 <jle`> \_ _ -> fmap (const []) ?
20:56:47 <jle`> ah, okay, that's more information
20:56:51 <Solonarv> you could probably cook up something using unfoldrM
20:57:01 <rotaerk> :t unfoldrM
20:57:03 <lambdabot> error:
20:57:03 <lambdabot>     • Variable not in scope: unfoldrM
20:57:03 <lambdabot>     • Perhaps you meant one of these:
20:57:06 <rotaerk> :t unfoldM
20:57:08 <lambdabot> error:
20:57:08 <lambdabot>     • Variable not in scope: unfoldM
20:57:08 <lambdabot>     • Perhaps you meant one of these:
20:57:19 <Solonarv> @hoogle unfoldrM
20:57:19 <lambdabot> Data.Vector unfoldrM :: (Monad m) => (b -> m (Maybe (a, b))) -> b -> m (Vector a)
20:57:19 <lambdabot> Data.Vector.Fusion.Bundle.Monadic unfoldrM :: Monad m => (s -> m (Maybe (a, s))) -> s -> Bundle m u a
20:57:19 <lambdabot> Data.Vector.Fusion.Stream.Monadic unfoldrM :: Monad m => (s -> m (Maybe (a, s))) -> s -> Stream m a
20:57:22 <jle`> rotaerk: what about the 's' ?
20:57:31 <jle`> is it updated every time?
20:58:01 <jle`> rotaerk: can you write it from scratch using explicit pattern matching and recursion?  then we can know what behavior you really want
20:58:08 <rotaerk> hmm yeah
20:59:24 <jle`> the pattern you're talking about feels a little obscure, i don't think you'd find it in a library
21:00:20 <rotaerk> I might have the signature a bit off; unfoldrM might do it
21:00:36 <Solonarv> it's basically unfoldrM + a bit of plumbing, actually
21:00:54 <dmrd_> get folks, quick question, suppose I have an expression `let a = 1 in a + 1`.... how can I query ghci or ghc to give me the type of a instead of the type of the whole expression
21:00:58 <Solonarv> I don't actually know where unfoldrM lives, but it's somewhere
21:01:09 <rotaerk> monad-loops
21:01:10 <mniip> % :i unfoldrM
21:01:10 <yahb> mniip: ; <interactive>:1:1: error: Not in scope: `unfoldrM'
21:02:25 <heptahedron> dmrd_: might be able to do `let a = 1 in (a :: _) + 1`
21:02:49 <rotaerk> my use-case is that I've got a known length of bytes, and an action `m a` that consumes a varying number of bytes to produce an a, and I know when to stop running the action when the total number of bytes consumed reaches (or exceeds, I guess) that known number
21:03:06 <rotaerk> I can determine number consumed from the a
21:03:27 <Solonarv> that does sound like a use case for unfoldrM
21:05:18 <ar1a> you can use do notation in javascript with https://github.com/pfgray/babel-plugin-monadic-do now lol
21:06:57 <dmj`> rotaerk: you could use fix
21:08:13 <rotaerk> yeah, though that really just saves me from having to actually name my recursive function
21:13:43 <Solonarv> fix is almost always the wrong level of abstraction for defining recursive functions, IMO
21:14:29 <Solonarv> (note: this is about fix specifically, not combinators with similar signature but different behavior, e.g. memoFix or mfix)
21:14:43 <rotaerk> I use fix sometimes when I would otherwise already be doing recursion, and I just want to eliminate the name
21:15:11 <rotaerk> as in, it's a convenient way to make a recursive lambda
21:15:59 <rotaerk> well, technically its name isn't eliminated, it just becomes a parameter, but it doesn't require a binding
21:16:17 <Solonarv> eh, fair enough
21:16:33 <Solonarv> I rarely find myself in need of a recursive lambda tbh
21:19:09 <rotaerk> https://ptpb.pw/dCdu/hs#L-61  got it
21:20:30 --- mode: glguy set +v jackdk_
21:20:34 --- mode: glguy set -v jackdk_
21:23:51 <koz_> Having to jump in and of monads, whether in or out of stacks, makes me feel like Xzibit.
21:24:00 <koz_> In the 'sup dawg, we herd u liek monads...' sense.
21:25:57 <MarcelineVQ> yo dawg we herd you like monads so we kept it simple and newtyped one for you with its neccesary instances
21:26:11 <koz_> MarcelineVQ: Lol, if only my case were that simple.
21:26:32 <koz_> In one case, I have to staple on a StateT temporarily, then eval it immediately and return the remaining stack untouched.
21:26:52 <koz_> In the other, I have to fiddle with mutable arrays in ST, while in a stack without ST.
21:27:03 <koz_> (which, yeah, you guessed it, I have to return unchanged)
21:33:14 <koz_> How do I import things into yahb?
21:36:01 <Solonarv> same way you import stuff into ghci: 'import SomeModule' or ':m + SomeModule' (prefixed with '% ' in both cases)
21:36:23 <Solonarv> yahb is just a ghci running in a sandbox
21:36:41 <Solonarv> % :!ls # even shell commands work!
21:36:42 <yahb> Solonarv: ClosureType.hs; LC.hs; ghci
21:37:03 <MarcelineVQ> % :set -package profunctors
21:37:03 <yahb> MarcelineVQ: package flags have changed, resetting and loading new packages...
21:37:15 <MarcelineVQ> ^ also an option
21:37:33 <mniip> koz_, depends, what do you want to import
21:37:33 <mniip> a module from a well-known library or a snippet of your own?
21:37:45 <koz_> mniip: Well-known (base stuff)
21:37:52 <koz_> It's OK, I got it figured out.
21:38:00 <mniip> % import Control.Monad
21:38:00 <yahb> mniip: 
21:38:04 <mniip> just like that
21:39:57 <koz_> I have a newtype T over Maybe Bool, and I wanna write a function foo = coerce isJust. However, it's complaining about representations. I assume I need to use TypeApplications somehow, but I'm not sure how. Could someone advise me?
21:40:22 <mniip> specify the type of foo
21:40:42 <mniip> % :t coerce
21:40:43 <koz_> mniip: I have a toplevel specification foo :: T -> Bool
21:40:43 <yahb> mniip: forall {a} {b}. Coercible a b => a -> b
21:40:50 <koz_> It's not enough for it.
21:41:22 <mniip> quite literally  newtype T = T (Maybe Bool)  ?
21:41:29 <koz_> Quite literally that.
21:41:56 <mniip> ah
21:41:57 <mniip> indeed
21:42:03 <mniip> % :t isJust
21:42:04 <yahb> mniip: forall {a}. Maybe a -> Bool
21:42:23 <mniip> % foo :: T -> Bool; foo = coerce (isJust @Bool)
21:42:23 <yahb> mniip: 
21:42:39 <koz_> Oh, so you gotta spell it _that_ way.
21:42:54 <mniip> otherwise 'isJust' is too polymorphic
21:42:58 <koz_> I'm still not entirely clear on what GHC can and can't infer by way of coerce.
21:43:18 <mniip> it requires a clear understanding of what "Coercible" is
21:43:24 <mniip> hint: it's not a typeclass
21:44:04 <jle`> koz_: you can just do: foo = coerce (isJust :: Maybe Bool -> Bool)
21:44:05 <koz_> What would you suggest I read to get a better understanding?
21:44:30 <mniip> I don't know
21:44:43 <mniip> for me it was a long journey of reading GHC core and pondering about GHC internals
21:44:50 <koz_> Woah.
21:45:00 <MarcelineVQ> % :info Coercible
21:45:01 <mniip> reading the System FC paper too
21:45:03 <yahb> MarcelineVQ: {-; Coercible is a special constraint with custom solving rules.; It is not a class.; Please see section 9.14.4 of the user's guide for details.; -}; type role Coercible representational representational; class Coercible a b => Coercible (a :: k0) (b :: k0); -- Defined in `GHC.Types'
21:45:57 <koz_> The link to that paper is dead: http://www.cis.upenn.edu/~eir/papers/2014/coercible/coercible.pdf
21:46:11 <koz_> So that section of the User's Guide isn't very useful right now.
21:47:12 * koz_ would love to read that paper.
21:47:16 <koz_> Who do I report this as a bug to?
21:47:34 <MarcelineVQ> what version of the docs did you go to?
21:47:55 <MarcelineVQ> nvm it didn't matter anyway
21:48:46 <koz_> 8.2.2 because it was in my browser history.
21:48:49 <MarcelineVQ> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/coercible.pdf
21:48:53 <koz_> In latest, I don't even think that's a section.
21:49:12 <MarcelineVQ> it's 10.14.4 in latest
21:49:17 <koz_> Awesome, thanks MarcelineVQ.
21:49:39 <koz_> Same broken link though.
21:50:54 <MarcelineVQ> old paper version here it looks like https://www.microsoft.com/en-us/research/uploads/prod/2018/05/coercible-JFP.pdf
21:51:23 <MarcelineVQ> oh ehe, 2 years newer, 2014 and 2016
21:52:12 <koz_> Who do I report this to?
21:53:14 <MarcelineVQ> ghc stuff is usually trac territory https://ghc.haskell.org/trac/ghc
21:54:05 <koz_> Huh, guest login fails, sigh.
21:59:23 <koz_> OK, looks like I have a Trac account now, in case I find anythign else broken.
22:46:35 <dmrd_> hey folks, does anyone know how to call the GHC renamer in the GHC API?
23:19:40 <dminuoso> johnw: How does async-pool relate to Haxl? They seem somewhat related in their purpose.
23:41:22 <cocreature> dmrd_: you might want to look at HscMain. that contains the main driver code that GHC itself uses. afaik the renamer and the typechecker are interwoven so you probably can’t just call the renamer
23:43:55 <dminuoso> A somewhat related question: Let's say you have a resource-pool for some network resource. How would you deal with a resource that has become invalid?
23:44:35 <dminuoso> Or would I reset the entire pool with destroyAllResources
