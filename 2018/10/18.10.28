00:07:36 <julianleviston> BartAdv: were you reading the paper https://arxiv.org/pdf/1710.09756.pdf or the proposal?
00:08:19 <MarcelineVQ> dunno much about it but as it reads to me,  Unrestricted a  is a promise that a particular a will not be a linear variable   re the "Isn't linear IO unsound in presence of exception?" section of the faq at https://ghc.haskell.org/trac/ghc/wiki/LinearTypes
00:09:18 <MarcelineVQ> consider that  read :: MArray a -o Int -> (MArray a,Unrestricted a)   is also   read :: MArray a -o (Int -> (MArray a,Unrestricted a)) and a is used twice there
00:09:45 <MarcelineVQ> That's about as far as I got so far though
00:11:58 <MarcelineVQ> put another way it might be that,  Unrestricted a  let's us be able to say  a -o (a, Unrestricted a)  at all since  a -o (a, a) is using a twice
00:15:41 <MarcelineVQ> The  Unrestricted ByteString  in the IO section following the MArray section suggests linearity affects not just variables though
00:16:39 <julianleviston> linearity is on the arrows, is it not?
00:16:42 <MarcelineVQ> so then  (MArray a,Unrestricted a)  is a result that remains linear in MArray a, and not linear in Unrestricted a
00:21:13 <MarcelineVQ> julianleviston: hmm yeah, looks like it, and Unrestricted is the tag used to say that "this part of the ADT doesn't count towards being linear" when linearity means what's specified at 2.1
00:21:46 <MarcelineVQ> *at 2.1 https://arxiv.org/pdf/1710.09756.pdf
00:21:59 <julianleviston> It’s important that the meaning of the linear arrow .. yeah what you just said.
00:22:14 <julianleviston> that’s probably the most important point to understanding this paper, IMO.
00:22:28 <julianleviston> as SPJ said in his talk… what exactly does “consumed exactly once” mean… 
00:23:15 <julianleviston> it’s not great that the paper doesn’t start with that, IMO. But that’s okay… standard paper reading methodology applies: read the intro, read the end, skip around until you find some meat and then broaden from there
00:24:01 <julianleviston> that’s pretty darn complex
00:26:04 <julianleviston> Might need a lot of examples to explain.
00:27:36 <MarcelineVQ> BartAdv: only things said in the last 6 minutes are relevant
00:31:04 <MarcelineVQ> 'standard paper reading methodology applies: read it all, don't get it, read it all again, google the stupid symbols people use, read it all again, realize the symbols are defined in the paper and don't even mean what you googled, read again'
00:31:55 <MarcelineVQ> 'realize some of the symbols aren't from the paper, most of them look like T's and U's in various stages of drunkeness, google these, be completely unsure if what you found is what you're looking at in the paper'
00:32:37 <MarcelineVQ> 'find out you're kind of getting it, declare victory, it's late, look at different paper the next day'
00:35:43 <BartAdv> julianleviston: the paper. Or rather only example from paper :)
00:37:16 <jle`> for me the main benefit of linear types will be catching bugs and helping me write programs
00:42:53 <BartAdv> The Unrestricted itself is pretty nicely explained in that talk. It's mentioned that "consuming once" for gadts means consuming each linear component once, and the content of Unrestricted is not linear,   so you can use it freely. Then, if I'm right, newMArray makes sure the Unrestricted returned by continuation is consumed once, just to extract the component to be final returned value
00:44:00 <BartAdv> I'm just not sure if it's just property of newMArray, or is it restricted by type system. Would it be possible to make bogus newMArray implementation that consumes continuation result more than once?
00:44:58 <BartAdv> It's funny how such seemingly simple thing (consume once) is confusing ;D
00:50:26 <BartAdv> Oh and I haven't even noticed the last lollipop in newMArray.  Now I need to think about it again D;
00:53:48 <BartAdv> Oh great, it's different here: https://github.com/tweag/linear-types/blob/master/Examples/src/FreezeArray.hs ;D
01:01:52 <BartAdv> Now it's easier I think. So, in order to provide the guarantee, one has to return Unrestricted, because it is allowing you to unpack the value while only consuming the whole Unrestricted only once, thus, consuming the linear MArray once as well
01:03:27 * hackage envstatus 1.0.0 - Display efficiently the state of the local environment  http://hackage.haskell.org/package/envstatus-1.0.0 (gbataille)
03:08:06 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
03:08:06 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
03:08:06 --- names: list (clog cpup desperek enarjord nuncanada _kwstas hamishmack thc202 tromp tzemanovic foojin coot_ yyy hiroaki henriksod Ariakenom julianleviston LKoen Icewing catsup visof_ davenall jchia_2 elgoosy noya revprez_stg oberstein isBEKaml revprez_1nz revprez apoc Philonous pagnol aurieeeh Nikotiini auri_ tdammers mcc cppxor2arr erikd soncodi salva pranz1 niklasl chin-tastic acidjnk baweaver jw358 Athas max3raza betawaffle pfurla_ acowley fairfieldt mdim NB0X-Matt-CA)
03:08:06 --- names: list (troydm animeshs_ magicman habbah patche fr33domlover pikhq ByronJohnson absence M2tias Moyst armyriad violeta DexterLB cesardv_ delYsid` Kneiva tylerjl bollu verement jdt mattp__ aplainzetakind wildlander shiro[cloud] ztf timfi cynick mobile_c_ travv0 simukis shutdown_-h_now vlatkoB oo_miguel lnostdal Ayo ericsagnes sektor jle` BartAdv ggole revtintin rval shafox nowhereman_ alx741 otto_s orion theDon dsturnbull nshepperd lucca lagothrix d3lxa selfsymmetric-mu)
03:08:06 --- names: list (emmanuel_erc mnoonan lassulus harfangk XCE ph88 ziyourenxiang Zipheir olligobber perrier-jouet Lord_of_Life cynapse pong kav coldpress darjeeling_ CurryWurst mkoenig pavonia machinedgod Bergle_1 kipras aarvar justanotheruser neobrain bilal80 hajma joachifm Forlorn_ gehmehgeh phreedom alp SCHAPiE tomboy65 tombusby StoneToad telser Eduard_Munteanu dolio notzmv Guest13389 Wamanuz salek_ huytd8 mjoldfield younder howdoi zar pie_ devurandom djellemah ekrion noam)
03:08:06 --- names: list (mountaingoat poljar djbeau martingale ekleog bartavelle stammon Snircle Natch liyang davr0s gxt nullifidian Zoddo cjwelborn riatre Sgeo inkbottle rofl_ nurupo Lears Axman6 jakehehrlich__ nfd jluttine Jesin benjamin-l yrid wollw2 alfredherr[m] p0lyph3m wagle kingofmemes Destol foton[m] ecx PifyZ[m] vk3wtf noumenon teej sykloid dxml[m]1 lastmanstanding adamCS gienah_ infinisil midi[m] cvoges12[m] kaol mariatsj_ mfukar Paks juri_ MarcelineVQ alyptik ruffy_ moei)
03:08:06 --- names: list (rcdilorenzo Neo-- emerson immae bas080 drbean_ valdyn EricZou Spooktober orzo ironChicken Guest53441 zyla esp32_prog urdh lkurusa loli atraii khlieng linduxed domenkozar cyberlard obiwahn APic sssilver slickmick catern xpoqp jp secretmessage mahalex Ekho hpc rootmos tessier koz_ nashimus_ giraffe wraithm_ Dabo gsingh93 joehillen ralu_ madnight_ arianvp Guest83774 Rembane_ ski noctux remexre_ platz_ c50a326_ avn mceier Liskni_si yarnspinner_ jmnk_ jol_ Anthaas_)
03:08:06 --- names: list (a3f_ uwap_ joeytwiddle_ dysfigured Ur_Nammu wayne_ brandon_ UnlawfulMonad NirvinM[m] cyphase gentauro ctag1 datajerk mantovani diginet Taneb Fairy ninedotnine so bind ggVGc WilhelmVonWeiner pbodev1 coeus sun777 sis7 Ericson2314 PLPD-Bot divVerent hc betz\[m] jwynn6 Enigmagic mutantmell seizo dibblego maerwald Neuromancer vaibhavsagar danguita averell kw_ wonko7 Ferdirand milesrout Ring0` marble_visions Bish DrAwesomeClaws heaven NightA aldum subleq monochrom)
03:08:06 --- names: list (drewbarbs Sose Braveheart[m] Martin333[m] tripty tinwood ketralnis MindlessDrone zaquest phaazon leafiest ephemera_ SrPx MonkeyNOS spoonm toppler` onesadcookie[m] psmaj[m] aidecoe ft int-e ClaudiusMaximus lenstr Guest43012 ammar2 Ranhir echoreply fluxi- jix winny +Putonlalla xanderio johnw d6e sshine mxf edwtjo cbmuser exio4 hiredman pakettiale Jonno_FTW Fubar^ mmaruseacph2 rntz pwestling aksz EdwardIII shachaf +aleator kosmikus mrm Squarism Patternmaster)
03:08:06 --- names: list (fionnan joeyh bcoppens spacebug flebron veverak s4msung dfordivam Intensity redrooster[m] fxkrait[m] gnocchi88 peel jschaefer152[m] Annihitek adius nisstyre forsakennobility drager guillaumecherel[ rgh[m] qxjit[m] ludovicdanjoumad dkasak[m] lierdakil[m] ocharles v0d1ch ZeWeaver[m] applecluster[m] slugwurths-reven jlavelle[m] +k0d3fr34k[m] telser[m] tmallard[m] arthurxavierx[m] acertain lycium[m] elijordan tfc[m] Barnabas[m] jangsentry10032[ nitrix Forkk)
03:08:06 --- names: list (jgornick saftsuse christianpoveda jonrh iravid TomartoCat[m] philippirrip vin-ivar jerme_ testsdewfsd[m] Randy dh bertschneider srhb umpc sud0 ids1024 pulec Syllo[m] awal jvanbure greeny__ ion monad_cat ramslee gregoiregeis[m] killjoyy[m] random_tester[m] natim87 SegFaultAX mikeplus64 TimWolla moony michalisko sm runit jackhill iron_houzi Jello_Raptor Zemyla metalrain zymurgy drewr` idupree2 DwarfMaster bspar_ dfranke noexcept thi asjo Meanirelli ftop zxrf)
03:08:06 --- names: list (Grominet cods xnyhps redfish64 jtcs kristjansson lyxia deu mud jackieh__ shrifbot_ lortabac ambrosia mulderr_ kubrat_ dustinm- geekosaur raid implementation nille nonzen hexagoxel yushyin Heartmender opqdonut MasseR cjay- happy_gnu[m] Guest72811 utonx[m] yaocihuatl[m] kaaloo[m] Blkt_ kdatta[m] hraza8g[m] montykarl[m] ktorek[m] bradparker c_wraith vodkaInferno hyp3rbor3ax[m] luqui cross dueltodeath[m] tsmc[m] yajaru[m] lurpam[m] ArchieTMichaKrzy arsaes[m])
03:08:06 --- names: list (revskill[m] pagoda_5bIvanoPa etarnvik[m] guest3321[m] Noughtmare[m] qwqdw[m] trixon[m] mith[m] masaeedu[m] alanz[m] obfusk kloeri UserOO7 Guest40074 lachenmayer Guest11673 epta CindyLinz sclv +unsymbol_ edwardk billstclair +danza-cloud_ +paf31_ nh2 kipras`away Adluc aib rain2 akermu zabracks Wizek vaibhavsagar_ ventonegro runde mpickering hpd Ckat quaestor Xandaros Ewout solarus haveo michaelpj Detson mingc Ke jetpack_joe stvc rhc[m] banjiewen georgew richi235)
03:08:06 --- names: list (sariyar heyj carter underikar lukeshu integral Nascha mgttlinger ancarda jzelinskie fingerzam sppky dmj` johs adamse comboy angerman elvishjerricco +newhoggy rom1504 azahi tazjin dexterfoo darthThorik PotatoGim dsal gothos Jon thoradam dgpratt dukedave kipd earthy thallada tuckerwales ManiacTwister debugloop PoliticsII thoughtpolice jinblack Bigcheese gonz_ feepo coot NemesisD milessabin Orbstheorem mikeavenatti[m] trimple[m]1 volslinger[m] Peter_Storm_)
03:08:06 --- names: list (cocreature hydraz w1gz test05[m] zygentoma[m] +petrolifero[m] kxra[m] tismith ephemeron jkarni anderson beka greymalkin techieAgnostic Tritlo pgiarrusso aweinstock JSharp Jaxan rizary rann shapr tolt scav jml cjh` bitonic etrepum HalfEatenPie amuck sudden t36s Cathy awx_ qz drdo codedmart pdxleif canta pikajude abrar ivegotasthma Vq nano- martin--t_ pyrtsa sigmundv_ rslima_ bdw cbarrett cloudhead statusbot Flonk gregberns stefan-__ nyaray__ galingale iross)
03:08:06 --- names: list (rodgzilla andjjj23 alanz verlet64 cic geal peschkaj dredozubov iomonad barrucadu pacak micro hiptobecubic lukelau Zajcev_ stilgart burp fiatjaf Hijiri wz1000 infinity0 petercommand Profpatsch koala_man ynyounuo dan64 kqr blackdog_ centril rzmt flogfr Mon_Ouie bitemyapp runawayfive nuxdie PierreM dyl arw Nik05_ michalrus zfnmxt Arahael pharaun cow-orker bsima lag djanatyn_ aramiscd vimto codenix suzu abuss SquidDev syamaoka dschoepe Saizan sms qdickon PHO)
03:08:06 --- names: list (davean piccolo __4matter @ChanServ stux|RC quarters exferenceBot hsiktas eldritch dminuoso Tops2 mankyKitty TommyC beaky koankeeper spinda pasukon +isacl_ +cyjiao typetetris AndreasK fnurglewitz ryzokuken Kamuela amatecha graingert rihardsk[m] v45h[m] nemesit|znc _6a68 Konehaltia n-st Klumben tjbp ab9rf bbaren scinawa sivs ajmcmiddlin acro Izeau mupf systemfault PyroLagus Nizumzen NinjaTrappeur xcesiv[m] silforion[m] lpsmith korans mr_yogurt atomi)
03:08:06 --- names: list (flyingclam[m] dotglitch[m] frump[m] thisiswhereitype sudoreboot02[m] George[m]1 Obscurity[m] M0mer[m] rogerduran[m] roberth danielr[m]1 apigeon[m] clownpriest[m] silasnordgren[m] ddowl[m] vqrs thebnq M2mol[m] nshepperd1 Makinit[m] tet[m] Etsi[m] TuXic[m] dnk8n[m] vistefan[m] xobroll[m] jibby[m] ddavidd[m] chocopowwwa[m] M12407-[m] asm[m]1 videled[m] unclechu Grgoire[m] ocharles[m]1 bmjh[m] riquipuig[m] reedhhw[m] lixl03[m] andresbach[m] yahb jokester pierrot)
03:08:06 --- names: list (kedah[m] fiddlerwoaroof exit70 wildsebastian tabaqui1 BL[m] psiska[m] krksgbr[m]1 jansc[m] homotopy[m] chreekat[m] exarkun1 dvgroc[m] mujx[m]2 XiaopongTran[m] biox[m] _flow_ deba5e12_ __name__ chelfi lieven asm89 fredcy WarzoneCommand Geekingfrog rucleuc[m] bb010g CrazedProgrammer ds- loco_joe[m] fregex hsw[m] ibraheemmoosa[m] KevinMGranger[m] kitsune[m] gspia freusque[m]1 benzrf bluepixel salparadise bob_twinkles jrslepak Ornedan zzz Deadhand tnks efskap)
03:08:06 --- names: list (Logio texasmynsted e2 noko_ bafain ninjatrappeur[m] freeFall3 bod_ lilduckie6431[m] noteventime sw4n a3Dman bandali ryjm joncfoo zombs emilypi abbe Xal sdx23 markus1189 nek0 tsahyt lambdabot fre[m]1 sevanspowell[m]1 Christophe[m]1 vars[m]1 kaychaks[m]1 lainon[m]11 mskowr[m]1 M0x8badf00d[m] mathNcs[m]1 fgaz kini jonge jayjay[m] mulk[m] gremax kbobyrev[m] glguy[m]1 monomono[m] ixian acomar[m] chaseroycroft[m] DarkBuzz[m] pauls_sondrel[m] aquarial[m] Fede[m])
03:08:06 --- names: list (mverkleij[m]1 rj1 johnnyv[m] dandan[m]1 jeroenbulters[m] knoppaz[m] silvio[m] luke-clifton[m] tauoverpi[m] mrhania[m] pikachoum[m]1 pnutus[m] wuffie[m] mtncoder[m] GGMethos piluex[m] leonardo2718[m] melancholia kalhuzcxv[m] michbad[m] thejonny[m] squallcx[m] tuxitagnu[m] Bimmie[m] lightandlight[m] fmease mrbackend[m] albertsg[m] alexshpilkin feuerligin[m] PsySunrise[m] wto cemerick KeeferRourke[m] jtb[m] simony_ trigalero[m] cryptomann[m] citrusmunch[m])
03:08:06 --- names: list (Maxdamantus lpvb Tehnix malthe bigs @Sigyn siraben mystfox xacktm ego jorj lstdgtfp macerbi[m] valardohaeriz[m] SolarAquarion geronimogarcia twk- sriehl[m] Hafydd pent[m] noah-seltzer[m] rembo10 frodot9[m] rodlogic[m] mnrmnaugh toure|gone Novitsh animeshs saurik nopf ycheng liurnd mtift sgraf defanor miklcct_ fingerzam[m]1 ktaylora[m]1 MatrixTravelerb4 sudoreboot[m]1 mimi55555[m]11 srid[m]1 +ahri[m]1 throughnothing[4 Twey abhir00p[m] thekyriarchy bengt_)
03:08:06 --- names: list (jbweston[m]1 geodesic[m] dr34dl0ck[m] effjay[m] el_tejon[m] coscomo[m] pqwy[m] javjarfer[m] braunseb[m] capitalistsuprem lukebfox[m] kwibus[m] roninkaizen[m]1 hdurer[m] mubareksd[m] tigermants[m] thebioalchemist4 mniip dbosk[m]1 gluegadget Ekho[m]1 +ranberry__ dotty[m] bsd4life[m] carc asoltysik[m] vizowl[m] IAM[m] td_dt[m] arrdem[m] mcspud nbardiuk[m] WilliamHamilton[ PokaiChang[m] lavalike h30 Guest30230 veggero[m] strangeglyph shafoo lantti raoulb)
03:08:06 --- names: list (samueloliveira[m lions[m] aloiscochard[m] saidinwot iceskins[m] eacameron pent bjobjo yumh scav_ arkeet wtw Cthalupa somni[m] feuerbach kittenz[m] ent ahihi higherorder m1dnight_ flux sujeet gentooboontoo[m] gondwe[m] dilinger bjs mimi_vx jebes elazar[m] m0rphism sdrodge lowryder srid gmind[m] dmwit amiri klugez Tspoon_ kircm[m] terrorjack Franciman ringer1 Guest87593 adarshaj hodapp kjak furnost samurikun[m] alexelcu stass agrim dpn` srust99[m] trobotham)
03:08:06 --- names: list (dstolfa jophish cchalmers Uniaika ullbeking hardcore_yonath[ Unhammer nkaretnikov case_ seliopou m4lvin qzo jhammons megaTherion nwf worch Deewiant Fuzen[m] UpstreamSalmon esph leah2 realloc ma27 Guest77842 trebuh jakubdaniel[m] lmiskiew[m] Robin_Jadoul hvr beeman Niamkik avocado TMA xintron Velpoman atk bydo meck sqrt2 jchia dogui phadej bongseo[m] YellowOnion_ [exa] radim[m] rotaerk Tesseraction_o `slikts hive-mind cpape Adeon iphy SlashLife _deepfire abra0)
03:08:06 --- names: list (tomku pepijndevos marinelli rodlogic jan_007centrumcz dsfox puffnfresh dmiles _dga c-rog stiell swalladge caa51h mounty1 bwe polux36 benedik[m] buhman Majiir Clint markhuge M0ddba11[m] +Janta Zialus tabylon dut jmg[m] voiceftp dura_lex[m]1 duncan^ toovs glguy Foritus keep_learning ps-auxw chessai nyaomi Myrl-saki luigy thaumavorio kuttifunk aprillust paraseba pita typedrat imp0s5ible LastTalon enojelly fryguybob johnnymacs dcoutts_ bgamari Charn tv bt turol)
03:08:06 --- names: list (pta2002 amx sz0 milli sw1nn amosbird haasn statusfailed nicoulaj mada akshayn hackage pigsalsa_ mauke_ carbolymer_ loc_ nckx davl _jzl Arguggi_ haircode electrocat mjrosenb_ tureba mikolaj Firedancer_ nbathum eagleflo cheater forell ScriptRunner themagician_d bluesmonk srk HunterJozwiak condy Fylwind- brisbin [df] cgoldamm1r plaerema1s ryantm_ dave_uy noan chindy Tuplanolla oak Reisen niko Amadiro albel727 petermw Willis parenthetical Lowl3v3l capisce tabaqui)
03:08:06 --- names: list (Soft droplet jfredett)
03:09:00 <foojin> Okay, I've read the source code of QuickCheck and tf-random and it seems that `Int` in `newtype Gen a = MkGen {unGen :: QCGen -> Int -> a}` stands for "size", which QuickCheck defaults to 30 in `generate`.
03:09:27 <foojin> The question thus becomes: how does that influence the output given that I'm merely using `Gen` as an Applicative in my instance?
03:20:02 <foojin> Nvm, found it in the manual.
03:36:02 <artempyanykh> Happy Sunday, guys! Beginner question -- is DuplicateRecordFields considered the best when it comes to working with records that have same field names? The fact that the extension cannot use type information from a function definition inside which a selector is used to disambiguate seems rather limiting.
03:53:31 <ion> The lens library might be useful there. https://www.stackage.org/haddock/lts-12.15/lens-4.16.1/Control-Lens-TH.html#v:makeFields
03:55:45 <hexagoxel> is there an established way of testing whether some code applies exception masking correctly?
03:58:28 <ion> I wonder if it would be feasible for GHC to represent any data type shaped like data Nat = Z | S !Nat as an integer internally while making it look like the data structure in expressions and pattern matching?
03:59:05 <hexagoxel> a related question: is there any way of establishing whether `throwTo` has started execution? the calling thread blocks, so cannot report that it has entered throwTo, and the receiving thread is supposed to be masked, so it won't see the exception.
04:01:30 <hexagoxel> it appears that all testing code for masking is prone to race conditions itself :/
04:01:42 <hexagoxel> i have to prove stuff instead of testing? heresy :p
04:04:04 <artempyanykh> ion oh looks neat, thanks! I'm a bit concerned with possibly cryptic compiler errors, have you found this to be an issue?
04:07:19 <ion> artempyanykh: The types lens uses (and therefore the type errors) may seem cryptic, but should you decide that lens is better than DuplicateRecordFields for your purposes, always feel free to ask for advice here.
04:10:35 <int-e> ion: Why would ghc (that is, its maintainers) bother with optimizing that particular special case? It looks like something a programmer would do themselves for performance critical code... (and if you like, you can even define corresponding pattern synonyms for Nat)
04:32:13 <__monty__> int-e: To get fast type-level nats : )
05:00:10 <dexterfoo> artempyanykh: check out https://hackage.haskell.org/package/generic-lens
05:06:23 <ion> neat
05:18:13 <Axman6> according to the ifcp talk on generic-lens, it's also really fast, only marginally slower than hand written lenses (generally it ends up producing what you would have written by hand)
05:19:37 <fen> ok so there was something in an ealier paste that needed to be fixed;  data NonEmpty a = a :| NonEmpty a | End a deriving Show  --  type Differences f a = [f a -> f a]  --  type SafeState s a = s -> Maybe (a,s)  listSafeState :: SafeState [a] a listSafeState (x:xs) = Just (x,xs) listSafeState [] = Nothing  unfoldSafeState :: SafeState s a -> s -> [a] unfoldSafeState f s0 = go ([],s0)  where   go (xs,s) = maybe xs (\(a,s') -> go (a:xs,s'
05:20:02 <fen> oops thats the paste still in the clipboard! one sec
05:20:32 <fen> https://bpaste.net/show/c69583eb3b40
05:21:50 <fen> it shows the "safe slow" way to create differences lists by unfolding, along with the faster way using direct recursion. 
05:23:08 <lyxia> what about it?
05:25:00 <lyxia> You're using (:) and [...] to construct Differences.
05:25:16 <lyxia> oh nvm they're lists
05:29:25 <fen> its just that the last element of the unfolded difference list needed to be rewound and changed to have const so that the NonEmpty version could work
05:29:55 <fen> well it needed to be rewound and have the last element changed to const...
05:30:21 <fen> an earlier paste didnt have that
05:31:28 <fen> the "safe state unfolding" process turns the difference list backwards...
05:31:48 <fen> another thing that makes it slower than the direct recursion
05:32:25 <fen> though of course it could just be unfolded again when applying the differences instead of folding with (.)
05:32:31 <fen> hmm, maybe should do that
05:35:33 <fen> yeah, thats the thing with State unfold, it can produce a list, but alternatively, anything the returned values "act" on can be used to accumulate them
05:37:53 <fen> :t \f s0 = go ([],s0)  where   go (xs,s) = let (xs',(a,ms)) = (a:xs,f s) in maybe xs' (\s' -> go (xs',s')) ms
05:37:54 <lambdabot> error:
05:37:54 <lambdabot>     parse error on input ‘=’
05:37:54 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
05:37:59 <fen> :t \f s0 -> go ([],s0)  where   go (xs,s) = let (xs',(a,ms)) = (a:xs,f s) in maybe xs' (\s' -> go (xs',s')) ms
05:38:00 <lambdabot> error: parse error on input ‘where’
05:38:26 <fen> @let unfoldStateSafe f s0 = go ([],s0)  where   go (xs,s) = let (xs',(a,ms)) = (a:xs,f s) in maybe xs' (\s' -> go (xs',s')) ms
05:38:27 <lambdabot>  Defined.
05:38:39 <fen> :t unfoldSafeState 
05:38:40 <lambdabot> error:
05:38:40 <lambdabot>     • Variable not in scope: unfoldSafeState
05:38:40 <lambdabot>     • Perhaps you meant ‘unfoldStateSafe’ (line 161)
05:38:52 <fen> :t unfoldStateSafe 
05:38:53 <lambdabot> (b -> (a, Maybe b)) -> b -> [a]
05:39:27 <fen> so where the list is returned, this corresponds to (a:xs) being used to "accumulate" the values 'a'
05:39:47 <fen> where the "action" is (:)
05:39:51 <fen> :t (:)
05:39:52 <lambdabot> a -> [a] -> [a]
05:40:23 <fen> which allows a value :: a to "act" on a list :: [a]
05:41:53 <fen> @let unfoldStateSafeAct act xs0 f s0 = go (xs0,s0)  where   go (xs,s) = let (xs',(a,ms)) = (act a xs,f s) in maybe xs' (\s' -> go (xs',s')) ms
05:41:54 <lambdabot>  Defined.
05:42:01 <fen> :t unfoldStateSafeAct 
05:42:02 <lambdabot> (t -> a -> a) -> a -> (b -> (t, Maybe b)) -> b -> a
05:42:17 <fen> which is pretty general looking recursion scheme 
05:42:25 <lyxia> Can you remind me what problem you were trying to solve.
05:42:50 <fen> it was about having to rerewind the difference list produced by this unfolding process
05:43:22 <fen> where this could be done instead of folding, by using this more general recursion scheme of unfolding onto an arbitrary accumulator 
05:51:39 <fen> > egTree
05:51:40 <lambdabot>  error: Variable not in scope: egTree
05:51:49 <fen> @let data StemTree a = Branch (StemTree a) (StemTree a) | Stem (StemTree a) | Leaf a deriving Show
05:51:50 <lambdabot>  Defined.
05:51:56 <fen> @let egTree = Branch (Stem (Leaf "hello")) (Branch (Stem (Stem (Leaf "difference"))) (Leaf "tree"))
05:51:57 <lambdabot>  Defined.
05:51:59 <fen> > egTree
05:52:01 <lambdabot>  Branch (Stem (Leaf "hello")) (Branch (Stem (Stem (Leaf "difference"))) (Leaf...
05:52:26 <fen> lyxia: the overall problem is trying to write a difference list for arbitrary datatypes such as this StemTree
05:53:07 <fen> (from which a comonad can be derived)
05:53:43 <lyxia> What is the difference list of that egTree for example?
05:55:02 <fen> thats the problem!
05:55:06 <fen> i dont have that
05:59:04 <lyxia> that does make things kind of difficult
06:02:00 <fen> it makes it unfinished at least
06:02:39 <fen> seems reasonable to expect it would kind of break off the branches where they could be turned from branches to stems, as there is not an option of having a stem that does not end in a leaf with a value
06:02:44 <fen> if that helps at all...
06:02:51 <fen> thats why its not Free []
06:03:07 <fen> its Free (Either (,) ())
06:03:18 <fen> with some composing to get the args to go in those tuples
06:04:10 <fen> if it were Free [] the stems could have no leafs and then it would be ambiguous where to detatch the branch, which needs to have a constructor for the difference list
06:04:33 <fen> but other than that, it seems complicated...
06:05:30 <fen> as these composite constructors have to be derived by recursing on the container to reach the branch point
06:10:10 <dminuoso> co-log: composable contravariant combinatorial comonadic configurable convenient logging
06:10:13 <dminuoso> everything is so clear.
06:39:39 <dmwit> contravariant and comonadic is a surprising combination.
06:44:10 <dmwit> Okay, it's contravariant in one variable and comonadic in another. That makes more sense.
06:45:24 <dmwit> (And the comonad isn't on Hask, either.)
06:59:15 <hexagoxel> does this abide the monad laws? https://gist.github.com/lspitzner/378e0413505b1d6fa581e67720763d11
06:59:55 <hexagoxel> (if yes, include a full proof, please. do my homework for me, chat :p)
07:01:14 <hexagoxel> (but seriously, if someone can spot a reason for "no", i'd appreciate a hint before i start working through the proof)
07:03:34 * hackage composition-prelude 2.0.1.0 - Higher-order function combinators  http://hackage.haskell.org/package/composition-prelude-2.0.1.0 (vmchale)
07:04:55 * hexagoxel . o O (great, i was always looking for the >-=*> operator)
07:05:40 <berndl> lol
07:23:09 <fendor> that is the prelude to go in order to win the code obfuscation contest
07:40:54 <srid> https://elv.sh/ <- Hmm, why has no one set forth to write a Haskell inspired shell?
07:41:24 <srid> (I'd love to have stuff like algebraic data types in my shell scripting; eg: case'ing on `$OSTYPE`)
07:41:45 <rotaerk> why not use haskell itself as your shell
07:42:00 <srid> plain ghci?
07:42:06 <rotaerk> perhaps with that turtle package
07:43:03 <srid> does anyone actually do this? i suppose you wouldn't get the full shell experience anyay
07:43:12 <rotaerk> *shrug*
07:44:03 <srid> To be honest, bash is just fine - but I'm bored and want a toy to play with :-P cf. https://lobste.rs/s/ew31wd/what_are_you_doing_this_weekend#c_78dqgr
07:47:21 <opqdonut> srid: "haskell shell" on google turns up multiple packages
07:48:01 <opqdonut> e.g. https://github.com/jekor/hesh https://github.com/yesodweb/Shelly.hs
07:48:27 <opqdonut> hmm ok those aren't for interactive use
07:48:34 <opqdonut> I see what you mean
08:00:21 * hackage haskus-utils-types 1.1 - Haskus utility modules  http://hackage.haskell.org/package/haskus-utils-types-1.1 (SylvainHenry)
08:01:03 <dminuoso> rotaerk: It's called nix-shell :P
08:01:24 <dminuoso> Or wait, that should have gone towards srid.
08:02:22 * hackage haskus-utils-data 1.1 - Haskus utility modules  http://hackage.haskell.org/package/haskus-utils-data-1.1 (SylvainHenry)
08:03:20 * hackage haskus-utils-variant 2.0 - Haskus utility modules  http://hackage.haskell.org/package/haskus-utils-variant-2.0 (SylvainHenry)
08:04:21 * hackage haskus-utils 1.1 - Haskus utility modules  http://hackage.haskell.org/package/haskus-utils-1.1 (SylvainHenry)
08:07:06 <rotaerk> don't really see how nix-shell resembles what he's looking for
08:08:10 <kuribas> is there a guide for writing formal languages, like you see in haskell papers?
08:08:32 <kuribas> or is it just the author who invents them?
08:10:17 <kuribas> we have a rule based engine in common lisp for analysing and aggregating time series data, we'd like to formalise it.
08:10:42 <kuribas> maybe even write an implementation of the model in haskell.
08:22:29 <hodapp> I guess one approach sometimes seen is to present the grammar in BNF or similar
08:45:58 <__monty__> kuribas: TAPL by Pierce is often recommended.
08:47:13 <dstolfa> kuribas: you could use proof assistants like HOL4, Isabelle, Coq, Agda and the likes to do it
08:47:41 <dstolfa> kuribas: often the natural-deduction style rules you see are written in implication form, i.e. P1 /\ P2 /\ ... /\ Pn ==> C, where P1 ... Pn are premises and C is the conclusion
08:48:11 <dstolfa> the BNF grammar is specified as sum types
08:49:05 <kuribas> for example, we have time series where sometimes data is not present, or invalid, and the engine behaves different in each case
08:49:36 <kuribas> would I implement it as a sum type?  valid Double | invalid | void ?
08:49:46 <dstolfa> kuribas: it's hard to say as to what you actually want without first carefully thinking about a mathematical formalism of the behaviour you are seeing
08:49:52 <dstolfa> what do you mean by a "time series"
08:49:55 <dstolfa> and what do you mean by "data"
08:50:10 <kuribas> dstolfa: a mathematical formalism is what I want :)
08:50:33 <dstolfa> kuribas: right, well, if you just want to say that something is either nothing, invalid or valid, you can create a sum type that represents that, sure
08:50:44 <dstolfa> but the tricky bits are your inductive definitions, if you are going to formalise like that
08:51:01 <kuribas> dstolfa: time series is a function from time to data (mostly numbers)
08:51:02 <dstolfa> alternatively you could formalise it in a denotational way with domain theory or something along the lines, but i would recommend against that :-)
08:51:59 <dstolfa> kuribas: well, if it's just a function then you have no problem, right? you create a function that returns some "state" if you will, where your "state" is invalid 'b, void or valid 'a
08:52:03 <dstolfa> where 'b and 'a are some types
08:53:21 <kuribas> dstolfa: and another with the numeric data?
08:53:38 <kuribas> dstolfa: oh you mean 'a can be Double
08:53:41 <dstolfa> kuribas: yeah
08:53:45 <kuribas> right
08:55:05 <rotaerk> hmm I'm gonna write a package for reading/writing the Khronos Texture format; I'm not sure if I should make the module Codec.Ktx, Codec.Image.Ktx, Codec.Picture.Ktx, Codec.Texture.Ktx
08:55:07 <rotaerk> or what
08:55:27 <rotaerk> leaning away from Codec.Picture.Ktx because that could end up clashing with JuicyPixels, if they ever add support
08:56:19 <rotaerk> leaning towards Codec.Image.Ktx
08:59:54 <monochrom> Have you also considered Codec.Image.Texture.Ktx? >:)
09:00:29 * monochrom will leave "Graphics.Texture.Codec.Ktx" for tomorrow. >:)
09:02:48 <kuribas> Data.Ktx
09:02:50 <alexelcu> In `Control.Concurrent.MVar`, does anybody know from where the `M` in `MVar` comes from? Just curiosity.
09:03:10 <kuribas> alexelcu: mutable?
09:03:58 <alexelcu> probably :)
09:09:34 <monochrom> 40% mutable and 60% message.  Because MVar is a bounded message queue with queue length 1.
09:11:48 <atchoum> my code does not compile but I don't see how I can solv this
09:11:51 <atchoum> http://vpaste.net/2fQcu
09:12:48 <monochrom> Maybe "Random a => Integral a =>" should be "(Random a, Integral a) =>"?
09:13:21 <atchoum> nope, same error
09:13:28 <atchoum> :w
09:13:49 <hydraz> they're equivalent ime
09:14:08 <atchoum> http://vpaste.net/tDdAY <- the error
09:14:34 <hydraz> you don't use the numbers so GHC has no way of figuring out what kind of random data you want
09:14:47 <atchoum> haaaa
09:14:48 <atchoum> okay
09:16:06 <atchoum> how can I add teh correct type hint ?
09:16:36 <hydraz> genRandomNumbers :: IO [Int] or whatever
09:17:47 <atchoum> the new error I get : http://vpaste.net/rgKKO 
09:18:01 <hydraz> as in do { numbers <- genRandomNumbers :: IO [Int]; ... }
09:18:40 <atchoum> okay
09:18:47 <atchoum> it's not needed to put it in the function signature
09:18:55 <atchoum> just as a hint.
09:19:00 <atchoum> in the `main` function
09:19:11 <atchoum> I wanted to do that but wasn't sure it was correct syntactically.
09:21:26 <atchoum> it seems that you are stuck in the IO monad as long as you want to work with random numbers 
09:21:31 <atchoum> (in haskell I mean)
09:23:05 <hydraz> mkStdGen :: Int -> StdGen, split :: RandomGen g => g -> (g, g), etc
09:23:34 <geekosaur> you only need to be in it once if you want a random seed
09:23:51 <monochrom> Seeding comes from IO.  The rest can be purely functional, although you have to carry an extra StdGen parameter.
09:24:06 <geekosaur> once you have StdGen, you can pass it around or thread ti through your code (see MonadRandom)
09:24:37 <atchoum> monochrom: yes but if seeding comes from IO, then you are stuck in IO :)
09:24:45 <geekosaur> main is in IO
09:24:49 <geekosaur> I don't see a problem
09:25:10 <UnkDevE> Hello I've made an artifical neural network library however it doesn't run, I've narrowed it down to the function which gets the image part of the training data(getImageFromFile), I seem to be trying to load all the image data at once is there another way of doing this? https://github.com/UnkDevE/ANN/blob/master/Data.hs
09:25:19 <monochrom> OK you need to read this very self-obvious thing: http://www.vex.net/~trebla/haskell/IO.xhtml#organization
09:25:48 <monochrom> The function "calculate :: String -> Int" is outside IO.
09:26:49 <atchoum> monochrom what I mean if that the seed is eg IO Int, then you create your generator in a do block
09:27:03 <monochrom> Currently you're doing the equivalent of "calculate :: IO Int" and have mixed up the separable concerns of seeding and generating.
09:28:03 <atchoum> monochrom: then the alternative is to have to give either a seed or a generator as a function's parameter.
09:28:11 <hydraz> yeah, that's how you oughtta do it
09:28:25 <monochrom> <monochrom> Seeding comes from IO.  The rest can be purely functional, although you have to carry an extra StdGen parameter.
09:28:49 <monochrom> And "calculate" takes an "extra" string parameter.
09:29:09 <monochrom> Try to sleep on why this is called "functional" programming.
09:29:12 <hydraz> if the RandomGen parameter is really *that* annoying, you can hide it in a State monad, so your generating function would be something like (RandomGen g, MonadState m g, Random a, Integral a) => m [a]
09:29:47 <hydraz> s/m g/g m/ every time
09:30:23 <dmwit> (...but use MonadRandom instead of (MonadState m g, RandomGen g).)
09:30:51 <hydraz> is that a thing?
09:30:53 <hydraz> TIL
09:31:03 <monochrom> It's in some package on hackage.
09:31:04 <dmwit> ?hackage MonadRandom -- yes
09:31:04 <lambdabot> http://hackage.haskell.org/package/MonadRandom -- yes
09:31:39 <monochrom> It is better than MonadState because MonadState gives you a too-exposing API.
09:32:58 <dmwit> It is also better because you can mix it with another MonadState. =)
09:33:24 <hydraz> that's very fair
09:33:40 * monochrom wonders how to teach a course that nurtures separation of concerns and designing APIs that fit the usage rather than the internal details.
09:34:08 * hydraz has never used random numbers
09:37:53 <hydraz> 4
09:38:18 * hydraz curses his failing meta key
09:39:03 <monochrom> Congratulations, you have just used a random number for the first time!  (The "4" there heehee.)
09:39:21 * hackage simple-cmd 0.1.2 - Simple String-based process commands  http://hackage.haskell.org/package/simple-cmd-0.1.2 (JensPetersen)
09:39:36 <yushyin> https://www.xkcd.com/221/
09:39:38 <hydraz> monochrom: I *do* choose which buffer to go to based on fair dice roll, haha
09:40:58 <atchoum> what is a MonadState ?
09:41:06 <atchoum> is it worth investigating ?
09:41:25 <monochrom> It's a type class from mtl.  It generalizes State and StateT.
09:42:35 <monochrom> Maybe investigate MonadRandom first.  Then MonadState will not be too far off.
09:43:50 <hydraz> atchoum: Just use a function
09:44:13 <hydraz> (Random a, Integral a, RandomGen g) => g -> ([a], g)
09:44:55 <atchoum> yes but I want to learn too :)
09:45:20 <atchoum> Those things are probably needed for using Haskell thorougly.
09:47:01 <mho> has anyone here experience with the book "learning haskell data analysis" by james church?
10:02:21 * hackage gi-gtk-hs 0.3.6.3 - A wrapper for gi-gtk, adding a few more idiomatic API parts on top  http://hackage.haskell.org/package/gi-gtk-hs-0.3.6.3 (inaki)
10:12:23 <dminuoso> Some people in here like to prefer a different name than "type annotations" for `... = s :: T` inline annotations. What is the term that ski for example prefers?
10:12:24 <Welkin> I suppose it's not possible to have a websocket endpoint as part of a standard wai application
10:13:04 <Welkin> looking at this package seems to confirm that https://hackage.haskell.org/package/wai-websockets-3.0.1.2/docs/Network-Wai-Handler-WebSockets.html
10:13:10 <Welkin> unless there is a way to do it
10:13:47 <Welkin> that makes sense since websockets run directly on tcp, not through http
10:13:51 <dminuoso> Welkin: The implementation of that package seems overly trivial..
10:16:16 <dminuoso> @let altMap f = foldr ((<|>) . f) empty
10:16:17 <lambdabot>  Defined.
10:16:20 <dminuoso> :t altMap
10:16:21 <lambdabot> (Foldable t, Alternative f) => (a1 -> f a2) -> t a1 -> f a2
10:16:24 <dminuoso> This should be in base :<
10:16:35 <dminuoso> It's more expressive than asum.
10:16:42 <Welkin> to include them in the same application running side by side, I would need to run them in separate threads, or put them into separate applications entirely, right?
10:19:14 <geekosaur> dminuoso, tyep ascriptions?
10:20:33 <monochrom> After a while, I think you can use any wording you want, since no one is using Haskell 2010's wording anyway --- therefore you can conclude that everyone has been making up their wordings.
10:20:35 <Solonarv_> dminuoso: I'd prefer altMap f = getAlt . foldMap (Alt . f)
10:20:55 <monochrom> Haskell 2010's wording is "expression type signature".  (Ever heard of that?  QED.)
10:21:12 <Solonarv_> foldMap >= foldr performance-wise, AFAIK
10:21:42 <dminuoso> Solonarv_: oh cool, didn't know about Alt :)
10:22:23 <Solonarv_> there are a lot of wrappers like that in Data.Monoid / Data.Semigroup, always worth having a look if you're using a monoidal structure
10:22:27 <nitrix> glguy: Can you confirm me quickly (verbally is enough) that the glguy on keybase is also you from freenode?
10:25:04 <dminuoso> Solonarv_: Ah turns out it was the only one I was missing. :)
10:25:06 <dminuoso> Thank you.
10:25:08 <Welkin> glguy: also include your GPG public key so they can send you an email
10:25:40 <dminuoso> Solonarv_: It's just a slight shame that the type signature has that noise in it
10:25:51 <Solonarv_> what noise?
10:25:56 <dminuoso> :t \f -> getAlt . foldMap (Alt . f)
10:25:58 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Monoid (Alt f a1), Foldable t) => (a2 -> f a1) -> t a2 -> f a1
10:26:09 <dminuoso> Solonarv_: the `Monoid (Alt f a1)` constraint, rather than `Alternative f`
10:26:26 <Solonarv_> ah, that shouldn't be an issue if you write the right signature yourself
10:26:46 <dminuoso> @undef
10:26:47 <lambdabot> Undefined.
10:27:02 <dminuoso> @let altMap :: (Foldable t, Alternative f) => (a1 -> f a2) -> t a1 -> f a2; altMap f = getAlt . foldMap (Alt . f)
10:27:03 <lambdabot>  Defined.
10:27:08 <dminuoso> Huh..
10:28:01 <dminuoso> Solonarv_: Oh indeed. :)
10:28:31 <Solonarv_> that works because there is an instance Alternative f => Monoid (Alt f a), so the Monoid (Alt f a1) constraint can be discharged using the Alternative f context
10:30:26 <dmwit> Why isn't the context simplified?
10:31:59 <Solonarv_> I'm not sure, actually
10:34:58 <dmwit> nitrix: FWIW, I can vouch that github.com/glguy is the same as glguy here (and there's already a declaration linking keybase's glguy with github's glguy). But if you are especially distrustful you should wait for him to show up and say the same. =)
10:35:18 <nitrix> dmwit: That's solid enough for me. Thanks.
10:36:48 <dmwit> Solonarv_: I think it is because `Monoid (Alt f a)` is actually more general: it could work if `f` has the wrong kind to be `Alternative`.
10:37:41 <dmwit> Arguably `Alt` should be made *less* kind polymorphic to help this kind of thing along.
10:37:52 <Solonarv_> Alt's definition implies that `f :: * -> *` PolyKinds isn't enabled in that module, so `a :: *`
10:37:58 <Solonarv_> ...it doesn't look polykinded to me?
10:38:41 <dmwit> Perhaps we're looking at different things. https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Semigroup.Internal.html has PolyKinds on
10:39:10 <Solonarv_> oh, you're right - I was looking at the Data.Monoid haddock
10:39:23 <Solonarv_> for some reason that doesn't show the polymorphism
10:40:05 <dmwit> I'm not sure how haddocks traditionally show kind polymorphism. But it does say in part, `instance Generic1 (Alt f :: k -> Type)`
10:40:15 <dmwit> ...which seems like a sign that it at least knows about the kind polymorphism.
10:40:51 * hackage haskus-utils-variant 2.0.1 - Variant and EADT  http://hackage.haskell.org/package/haskus-utils-variant-2.0.1 (SylvainHenry)
10:40:55 <dminuoso> geekosaur: Right, type ascriptions was the term.
10:42:20 <Solonarv_> haddock can show it in the type declaration, see e.g. stuff in Data.Type.Equality - but it doesn't show kind polymorphism for Proxy, which is a bit odd
10:42:32 <dmwit> Perhaps it only shows what is explicitly declared.
10:43:05 <Solonarv_> that could be it
10:43:40 <dmwit> Seems consistent with a quick spot check of a couple different ones that do and don't show it.
10:44:07 <geekosaur> I think it also depends on what extensions are enabled in the source it's processing (e.g. PolyKinds)
10:44:47 <fosterite> I'm trying to use plugins with gitit but it's failing saying it can't find some modules. Could this be due to installing with stack
10:44:54 <dmwit> Turning on PolyKinds does not appear to be enough to get haddock to show kind signatures, which is part of what started the confusion in this conversation.
10:45:34 <dmwit> e.g. look at the documentation of Alt, which has a polymorphic kind, but no kind signature in the haddocks.
10:51:52 <rotaerk> hmm, if I have a ByteString or a list of 4 Word8s, and knowledge of the endianness, how would I construct a 32 from it
10:52:55 <dmwit> shifts and ors?
10:52:59 <dmwit> :t shiftL
10:53:00 <lambdabot> Bits a => a -> Int -> a
10:53:07 <dmwit> :t (.|.)
10:53:09 <lambdabot> Bits a => a -> a -> a
10:53:15 <dmwit> :t fromIntegral
10:53:16 <lambdabot> (Num b, Integral a) => a -> b
10:53:33 <rotaerk> hmm I guess
10:54:01 <rotaerk> figured there'd be something standard for it, but not finding it
10:54:28 <dmwit> readIntAtBase was supposed to save us, but the language designers specialized it to Char. =(
10:55:05 <dmwit> Oh, sorry, might be just readInt. I can never remember whether it's readInt or showInt that has the AtBase suffix.
11:06:16 <govno> what is a `let polymorphism` ?
11:07:46 <dmwit> Compare:
11:07:53 <dmwit> > let x = 3 in (x :: Int, x :: Double)
11:07:55 <lambdabot>  (3,3.0)
11:08:02 <dmwit> > (\x -> (x :: Int, x :: Double)) 3
11:08:04 <lambdabot>  error:
11:08:04 <lambdabot>      • Couldn't match expected type ‘Double’ with actual type ‘Int’
11:08:04 <lambdabot>      • In the expression: x :: Double
11:09:04 <govno> thanks
11:09:06 <dstolfa> govno: when you let parameters in lambdas be polymorphic, you end up with undecidable type inference. let polymorphism is simply a way around it, i.e. anything of form let v = e1 in e2 can be polymorphic for v, but paramters in lambdas can't
11:09:51 <dstolfa> which is demonstrated with the example that dmwit gave
11:17:01 <fen> ok, so trying to make a difference list from StemTree seems quite complicated. essentially, it is isomorphic to a Free structure, and this means that a Zipper over Free is needed before it can be properly turned into a difference list. 
11:17:16 <fen> perhaps it would be easier to consider this type instead;
11:17:19 <fen> data Skip a = SkipL (a, Skip a) | SkipR (Skip a) | SkipE 
11:18:13 <fen> its like a list that can have empty placed between the values as well as at the end
11:18:23 <artempyanykh> dexterfoo: thanks for pointing out to generic-lens!
11:18:42 <fen> it should be a good way to consider the concept of composite constructors 
11:18:58 <fen> needed for the difference list of more complex types
11:19:04 <fen> (containers)
11:30:12 <fen> @let data Skip a = SkipL (a, Skip a) | SkipR (Skip a) | SkipE 
11:30:13 <lambdabot>  Defined.
11:30:28 <fen> @let toSkip xs = case xs of [] -> SkipE; (Nothing:xs) -> SkipR (toSkip xs); (Just x :xs) -> SkipL (x,toSkip xs)
11:30:29 <lambdabot>  Defined.
11:30:40 <fen> @let egSkip = toSkip [Just 1,Nothing,Just 3]
11:30:41 <lambdabot>  Defined.
11:30:50 <fen> @let fromSkip xs = case xs of SkipE -> []; SkipR xs' -> (Nothing:fromSkip xs'); SkipL (x,xs') -> (Just x :fromSkip xs') 
11:30:51 <lambdabot>  Defined.
11:30:59 <fen> @let instance Show a => Show (Skip a) where show = show . map (maybe "" show) . fromSkip 
11:31:01 <lambdabot>  Defined.
11:31:08 <fen> > egSkip
11:31:10 <lambdabot>  ["1","","3"]
11:39:45 <fosterite> I'm trying to use plugins with gitit but it's failing saying it can't find some modules. Could this be due to installing with stack and some sandbox issue?
11:48:52 * hackage axel 0.0.8 - The Axel programming language.  http://hackage.haskell.org/package/axel-0.0.8 (jgrosso256)
11:49:02 <fosterite> according to a google groups post from2016 the answer is "don't try to use plugins with gitit if you installed with stack"
11:51:14 <sm> fosterite: have you tried starting gitit in the stack environment, eg stack exec -- gitit ... 
11:52:12 <geekosaur> iirc the rpoblem is more that stack's notion of sandboxing is incompatible with how gitit does plugins
11:54:46 <fosterite> sm: I'll try that. otherwise I'll try cabal install
11:59:23 <fosterite> sm: no change
12:03:27 <fosterite> sm: actually there is a change: "bad interface file" looks like I need to change my global stack default ghc or something
12:03:35 <fosterite>         mismatched interface file versions (wanted "8043", got "8022") 
12:25:39 <Clortox> hey
12:33:32 <Welkin> the implementation of dupChan looks like it makes it possible for either channel to consume the other if you read enogh items from one or the other
12:34:15 <Welkin> or is this not correct?
12:36:38 <Welkin> for example, if you have chan1 = [2,4,6,8,10]; chan2 = [3,5,8,10], where [8,10] is chared between both channels, and you consume [3,5] from chan2, what happens when you consume [8] from chan2?
12:36:54 <Welkin> shared*
12:37:49 <Welkin> it seems tat chan1 would become [2,4,6] suddenly, chopping off the end
12:39:19 <hpc> Welkin: test it
12:40:53 <Welkin> I'm in the middle of reading the parconc book, so it would be easier to get an answer if anyone has one
12:44:00 <hpc> hmm, i just tested and it doesn't behave that way
12:44:20 <Ariakenom> Welkin: I think the use is supposed to be write-ends and read-ends
12:44:34 <hpc> but looking at the code i can't immediately point out where your reading of it is wrong
12:44:37 <Ariakenom> where one written item can be read several times
12:45:04 <Ariakenom> from distinct ends
12:47:10 <nshepperd> dupChan gives the new Chan a new readVar, so reading from one won't affect the other
12:49:18 <Ariakenom> dupChan should be used with newBroadcastChan I would think. But the implementations are mashed together?
12:49:18 <fosterite> Installing cabal fixed it, finally
12:49:28 <nshepperd> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Control.Concurrent.Chan.html#readChan seems pretty clear - the new Chan gets a separate readVar, and readChan only modifies the readVar, so two read-ends of the two Chans are totally independent
12:50:01 <Welkin> but they share a writeVar
12:51:05 <nshepperd> sure
12:51:19 <nshepperd> it's basically a linked list of MVars
12:51:29 <nshepperd> the writeVar points to the end
12:51:36 <Welkin> but they share the same data
12:51:53 <nshepperd> the two readVars are the different Chan's idea of where the start is
12:52:18 <Welkin> I understand that part, but what happens when the start of one channel is inside the other channel?
12:53:13 <nshepperd> nothing
12:53:57 <Welkin> I don't understand then
12:53:59 <nshepperd> the readVars are two pointers outside the list that just point to one of the nodes
12:54:07 <Welkin> they are like linked lists that share a tail
12:54:43 <Welkin> how does that not cause a problem?
12:54:59 <nshepperd> it's a single linked list
12:55:01 <Welkin> or better described as queues with a shared tail
12:56:48 <Welkin> so my example above is flawed then, because it's not possible for it to be in that state
12:57:30 <nshepperd> in the same way 'let x = [1, 2, 3, 4, 5] in (,) <$> newMVar x <*> newMVar (drop 2 x)' makes two MVars that point to the same list
12:57:56 <nshepperd> you could advance the two pointers independently with 'modifyMVar_ tail'
12:58:42 <Welkin> chan1 = [2,4,6,8,10], chan2 = [6,8,10], then writeChan 12 gives chan1 = [2,4,6,8,10,12], chan2 = [6,8,10,12]. readChan chan1 3 times gives back [8,10,12], while chan2 is still [6,8,10,12]?
12:58:49 <nshepperd> the difference is in a Chan the cons cells are MVars, so you can make the list longer by writing to the end
12:59:34 <nshepperd> Welkin: yeah
13:06:26 <nshepperd> ah, yeah, you couldn't get to the state "chan1 = [2,4,6,8,10]; chan2 = [3,5,8,10]" just by using the regular Chan functions
13:08:31 <Welkin> thanks for helping me understand
13:22:48 <koz_> When I 'stack build', I get parallel builds _across_ packages, but not within them. What can I pass to stack to have it build the packages themselves in parallel?
13:31:31 <Mrbuck> https://github.com/namecoin/electrum-nmc/tree/master/electrum_nmc/gui/kivy   any project like this in haskell ? I was trying to read that code and I feel it is so hard I just want to check similar one with haskell if any 
13:37:04 <ztf> beginner question: the reason 'toEnum 97' in ghci gives me an exception but '(toEnum 97) : ['a']' gives me "aa" is just type inference? is there a way if I'm messing around in ghci I can tell it I want a Char without having it infer? 
13:37:30 <Rembane_> > toEnum 97
13:37:33 <lambdabot>  *Exception: Prelude.Enum.().toEnum: bad argument
13:37:33 <hpc> > toEnum 97 :: Char
13:37:35 <lambdabot>  'a'
13:37:40 <Rembane_> :D
13:37:57 <ztf> hm i could have sworn i tried that 
13:38:11 <ztf> must have mistyped it or something, thanks :) 
13:38:22 <hpc> ztf: try wrapping it in parens, (toENum 97 :: Char)
13:38:58 <hpc> the (::) "operator" effectively has a low precedence from being syntax
13:41:03 <Welkin> :t ord
13:41:04 <lambdabot> Char -> Int
13:41:28 <Welkin> > chr 97
13:41:30 <lambdabot>  'a'
14:12:42 <Zemyla> Is there a way to create a subset of the functions from Natural -> Natural that are provably bijections? Basically, I want its structure to as far as possible disqualify functions that aren't bijections.
14:13:07 <dstolfa> Zemyla: are you asking about mathematics or haskell here?
14:13:22 <Zemyla> Haskell.
14:13:58 <dstolfa> and by `provably', do you mean that haskell's type system could prove that, or that you could by hand prove it?
14:14:30 <rom1504> here is a subset : {identity}
14:15:33 <Zemyla> My first thought is a stream of permutation cycles, and as long as the process that creates the stream is productive, evaluating the function is total.
14:16:07 <dstolfa> Zemyla: okay but for that you still need coinduction
14:16:13 <dstolfa> it's not like the type system can magically prove totality
14:17:03 <dstolfa> at least i'm not aware that haskell automatically generates totality theorems :-)
14:17:17 <Zemyla> True. That's something you need Coq, Agda, or Idris for.
14:20:47 <Zemyla> Now I'm wondering what the strongest provably total programming language that currently exists is.
14:21:02 <Solonarv_> the first approach I thought of is this: https://gist.github.com/Solonarv/bb1920e617d0eb7baa9ff7c56fcb52a3
14:21:50 <dstolfa> Zemyla: what do you mean by "strongest"
14:21:59 <dstolfa> we need totality for any proof assistant for consistency of its logic
14:22:03 <dstolfa> all proof assistants require that
14:22:09 <dstolfa> or at least all those worthy of a name
14:22:23 <MarcelineVQ> what do you mena by programming language :>
14:23:23 <Welkin> they mena pena
14:23:32 <dstolfa> recall that one of the rules of typed lambda calculus, at least one that corresponds to IPL is forall x t . x : 0 ==> abort x : t
14:24:06 <dstolfa> this essentially says that for any void-typed term that is constructed (which is true only when we loop), we can prove any proposition t with an abort x proof
14:24:56 <dstolfa> this is given by determinacy, progress and type preservation
14:25:04 <dstolfa> (the looping part)
14:36:11 <justhsu> hello, I am trying to use cabal new-build and I am getting a strange error. when trying to build my executable, I get: "CallStack (from HasCallStack):   die', called at ./Distribution/Client/ProjectOrchestration.hs:917:8 in main:Distribution.Client.ProjectOrchestration cabal: Failed to build website-0.1.0.0-inplace-website. The failure occurred during the configure step. The exception was: realpath: permission denied (Permission deni
14:36:42 <justhsu> this is for a fresh installation from haskell platform
14:38:41 <__monty__> justhsu: Do you have write permission in the directory?
14:41:10 <justhsu> monty: which directory? I have write permissions in the project directory and in the .cabal directory.
14:43:15 <__monty__> Is there more to the error? Maybe pastebin it.
14:46:07 <justhsu> There's not much more. The full output with -v is here: https://pastebin.com/zGKgDBjc
14:54:24 <__monty__> justhsu: Sorry, have no idea. It seems like there's information missing from the error message.
14:56:18 <carter> What platform ?
14:56:36 <edwardk> is anybody here familiar with the guts of conal's compiling to categories stuff?
14:56:38 <justhsu> carter: OSX
14:58:26 <carter> justhsu: how’d you install it ?
14:58:35 <carter> edwardk: me more than most folks.
14:58:56 <carter> edwardk: in that I have a patch or so in it. And accidentally broke it for a few days ?
14:59:45 <edwardk> any idea how to retarget it to use a custom set of classes rather than his?
15:00:25 <edwardk> https://github.com/ekmett/nominal/blob/master/src/Nominal/Category.hs has the same general "shape" as conal's class hierarchy
15:00:39 <edwardk> at least combinator for combinator they should drop in as a replacement more suited to my needs
15:01:11 <justhsu> carter: from the haskell platform website yesterday. I had a previous version of ghc from macports, which I have uninstalled.
15:01:12 <carter> edwardk:  so the lazy question is : can you use your stuff to write an instance for his?
15:01:20 <edwardk> i have that too
15:01:56 * hackage entwine 0.0.2 - entwine - Concurrency tools  http://hackage.haskell.org/package/entwine-0.0.2 (lambda_foo)
15:02:03 <carter> justhsu:  have you tried building something else just to make sure its not you its cabal?
15:02:04 <edwardk> https://github.com/ekmett/nominal/blob/master/plugin/Nominal/Plugin.hs
15:02:14 <edwardk> but the classes are a little wrong in places
15:02:27 <edwardk> in particular treating () as initial, etc.
15:02:55 <edwardk> and the version i have there gets away with far fewer constraints right up until it needs to manipulate environments
15:03:14 <edwardk> i noticed the core of the plugin seems to have some magic for saying what Id provides each combinator
15:03:22 <edwardk> so I made sure to name mine the same way
15:03:49 <carter> edwardk:  https://github.com/conal/concat/blob/master/plugin/src/ConCat/Plugin.hs#L73 
15:04:02 <carter> seems to be the main bit?
15:04:08 <edwardk> yeah
15:04:16 <edwardk> that is about as far as i got
15:08:48 <lavalike> what is the difference between returning an IO () and an IO (Async ()) for a user of such a function?
15:08:52 <carter> edwardk:  mkCccEnv is where you want
15:08:54 <carter> same module
15:08:57 <lavalike> is the first one preferable in general?
15:08:57 <carter> just farther down
15:09:34 <carter> edwardk:  so a tad less magic with the power of full text search in a decent text editor ;)
15:10:59 <carter> plus some rewrite rules stuff in the other two modules
15:14:23 <edwardk> carter: yeah. my current thoughts are i'd like to hijack the plugin around this point and just point that environment at my own code
15:14:39 <edwardk> and see if i can't get it to work that way
15:14:47 <carter> you may find some cleanups :))
15:14:50 <carter> to upstream
15:14:50 <edwardk> i don't _really_ want to cut and paste the whole thing or fork the project
15:14:56 <carter> plus CPP to delete :)))
15:15:23 <edwardk> right now my focus is on making nominal arrows usable to program with directly
15:15:40 <edwardk> and then only incidentally making it so i can use the compiling to categories stuff as a secondary goal
15:16:00 <edwardk> it'd be really badass if you could just write normal haskell and get proper name support a la fresh-ml or something
15:18:26 <edwardk> my current thought is to use a little class to produce each nominal arrow like for instance for mapping over "Ties", nmap :: N k => k a b -> k (Tie a) (Tie b) -- and having that produce (->) or "Nom" based on what you use it as
15:18:39 <edwardk> normal functions can be used directly, but have no computable support
15:18:50 <edwardk> Nom arrows have computable support
15:18:54 <justhsu> carter: cabal new-build fails for me even on the default package from running cabal init, so something is definitely weird. 
15:19:15 <justhsu> cabal build works, but fails with this error when I add one dependency (split) to test.cabal: https://pastebin.com/qWhyhBbv
15:19:43 <edwardk> (at least a computable superset of their actual supports)
15:24:39 <carter> justhsu: 
15:24:44 <carter> did you ever run cabal update?
15:25:03 <carter> sounds like you maybe never run cabal update ever?
15:25:20 <carter> cabal --version says what?
15:25:27 <carter> which ghc is in your path
15:25:38 <carter> edwardk:  do share what you learn from this hackery?
15:25:48 <carter> i've been wanting ot make use of a differnt class hiearchy myself
15:26:02 <edwardk> carter: well i rather deliberately lobotomized it down to just what i needed
15:26:21 <edwardk> my goal right now is suitability for _this_ purpose not generality
15:26:35 <edwardk> i now what a rabbit hole going into full 'hask' mode is like ;)
15:27:25 <justhsu> carter: I have run cabal update (no errors). cabal --version: cabal-install version 2.2.0.0 compiled using version 2.2.0.1 of the Cabal library
15:27:48 <justhsu> in my path: ghc --version: The Glorious Glasgow Haskell Compilation System, version 8.4.3
15:27:53 <carter> try doing cabal install cabal-install 
15:28:21 <carter> 1) theres a new cabal (lib and binary)
15:28:27 <carter> 2) maybe that runs fine and then you're ok
15:28:33 <carter> ohhh
15:28:46 <carter> justhsu:  .... check your ~/.cabal/config
15:28:51 <carter> well
15:28:54 <carter> that shouldn't matter
15:29:44 <carter> justhsu:  i think haskell platform has some stuff it does custom in cabal config
15:29:47 <carter> i could be out of date
15:30:10 <carter> its been years since i last looked at this stuff
15:30:18 <carter> sclv:  might be able to help you better justhsu  :) 
15:33:21 <justhsu> hmm. cabal install cabal-install fails, again due to the realpath permissions problem: https://pastebin.com/LtrXSeHg
15:33:43 <carter> umm
15:33:48 <carter> somethings weird on your mac
15:33:50 <justhsu> something seems really screwed up. if only I knew where that permission error is coming from...
15:34:31 <carter> justhsu:  check your cabal ~/.cabal/config
15:34:44 <carter> justhsu:  something is writing to a folder you dont have write perms too
15:35:48 <carter> justhsu:  delete your ~/.cabal/config and do cabal update
15:35:54 <carter> and then you should be OK
15:35:56 <carter> i think
15:36:20 <carter> honestly file a bug report with haskell platform issue tracker too
15:36:23 <carter> i think theres one on gh
15:38:00 <carter> justhsu:  sudo chown -R `whoami` /Users/justhsu/Library/Haskell
15:38:02 <carter> might fix it
15:38:25 <carter> ` sudo chown -R `whoami` /Users/justhsu/Library/Haskell `
15:38:50 <anchpop> whoops
15:38:59 <anchpop> I put my book in here last night and then got distracted
15:39:11 <anchpop> so I didn't see if anyone had any comments on it
15:40:06 <rawburtz> looking for something along the lines of: [Maybe [a]] -> Maybe [a]
15:41:16 <anchpop> rawburtz, what exactly would it do?
15:41:33 <Rembane_> rawburtz: My intuition says sequence or traverse 
15:41:35 <justhsu> yeah. I wonder which folder? whatever it is, I get the same error whether with cabal and stack
15:41:45 <carter> justhsu:  i gave you the command
15:41:49 <carter> did you run it?
15:41:50 <justhsu> I tried changing owner for that folder, but doesn't seem to help
15:42:05 <carter> did you do the config file looking?
15:42:06 <MarcelineVQ> anchpop: haven't had a chance to read it but I'm glad there's another resource out there    the book if anyone is interested https://anchpop.github.io/wise_mans_haskell/
15:42:08 <carter> or white and cabal update
15:42:12 <carter> *wipe
15:42:13 <rawburtz> Rembane_ sequence worked, thanks
15:42:31 <anchpop> rawburtz, `head :: [Maybe [a]] -> Maybe [a]`
15:42:32 <carter> honestly open an issue with platform
15:42:36 <Rembane_> rawburtz: No worries. 
15:42:37 <justhsu> the config file looked normal before, but I've wiped and updated. still same error
15:42:46 <Rembane_> unsafeCoerce. :D
15:42:52 <justhsu> yeah, I think I should try on github. thanks anyways!
15:43:04 <carter> what about cabal new-install cabal-install
15:43:05 <carter> try that
15:43:07 <anchpop> MarcelineVQ, my goal is to be better than LYAH
15:43:15 <carter> justhsu:  try that
15:43:16 <carter> please
15:43:40 <carter> please make sure ~/.cabal/bin is in your path after that if it works,
15:43:49 <anchpop> just having another resource isn't very good if it's worse than what already exists
15:43:54 <MarcelineVQ> If you have exercises in your book you're ahead of many resources already
15:44:26 <anchpop> I do, although I don't have very many
15:44:47 <MarcelineVQ> one of lyah's main weaknesses is a lack of exercises that make the reader learn what's being read, so people end up halfway in and suddenly don't know what's being talked about because the basics were half a book ago
15:44:53 <hexfive> % sequence [Just [1,2,3], Just [4,5,6]]
15:44:53 <yahb> hexfive: Just [[1,2,3],[4,5,6]]
15:45:00 <hexfive> % sequence [Just [1,2,3], Just [4,5,6],Nothing]
15:45:00 <yahb> hexfive: Nothing
15:45:04 <hexfive> hmm
15:45:18 <anchpop> MarcelineVQ I try to avoid that with exercises and by sometimes re-going over old topics
15:45:22 <carter> i was thinking concatMap
15:45:25 <carter> :t concatMap
15:45:26 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
15:45:43 <anchpop> also it should be less of an issue anyway since my book is less verbose than lyah
15:45:50 <anchpop> don't spend 15 years on monads for example
15:46:13 <hexfive> % concatMap sequence [Just [1,2,3], Just [4,5,6],Nothing]
15:46:14 <yahb> hexfive: [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Nothing]
15:46:17 <justhsu> carter: cabal new-install cabal-install complains about symlink-bindir: cabal: symlink-bindir is not defined. Set it in your cabal config file or use --symlink-bindir=<path>
15:46:44 <carter> justhsu:  do --symlink-bindir=~/.cabal/bin
15:46:50 <carter> mkdir -p ~/.cabal/bin
15:47:00 <carter> add that to your path
15:47:06 <anchpop> but also I discuss things like stack and testing, which lyah doesn't but are essential for haskell development 
15:47:08 <carter> then cabal new-install cabal-install
15:47:19 <anchpop> or essential knowledge anyway
15:47:21 <carter> then rm ~/.cabal/config ;
15:47:24 <carter> cabal update
15:47:42 <carter> and then just to make sure things are nice
15:47:49 <carter> do cabal v2-install cabal-install
15:48:13 <carter> justhsu:  things looking better?
15:49:32 <justhsu> it's odd. with --symlink-binder=~/.cabal/bin, it complains: /Users/justhsu/.cabal/~/.cabal/bin: createDirectory: does not exist (No such file or directory)
15:49:43 <carter> well yeah
15:49:45 <justhsu> so I tried with --symlink-binder=/bin
15:49:46 <carter> you didn't make it
15:49:49 <carter> justhsu:  no
15:49:52 <carter> stop
15:50:01 <carter> if that didn't shell substitute
15:50:04 <carter> use $HOME
15:50:07 <carter> instead of ~
15:50:29 <carter> justhsu:  i want you to do literally my directions
15:50:32 <carter> or i cant help
15:50:40 <carter> because ... icant :) 
15:50:56 <carter> if my literal directions have an error, i can help you
15:51:09 <carter> if you try to be clever instead of telling me the rror, :P
15:51:17 <justhsu> OK. I have made the directory ~/.cabal/bin
15:51:43 <justhsu> cabal new-install cabal-install --symlink-bindir=$HOME/.cabal/bin again gives realpath permission denied error.
15:51:59 <carter> reinstall your platfomr install
15:52:04 <carter> and or reboot your computer
15:52:27 <carter> what shell are you using?
15:52:39 <justhsu> zsh
15:53:00 <justhsu> I'll try rebooting first, then if that fails I'll reinstall.
15:53:29 <carter> this seems like something in your setup is busted
15:53:33 <carter> and its not askell :) 
15:53:35 <carter> *haskell
15:53:41 <MarcelineVQ> it's pretty weird to have permission denied for realpath for things in a user dir
15:53:49 <carter> yeah
15:53:50 <MarcelineVQ> Or at all, but especially there
15:54:05 <carter> it tells us you have some custom weird thing on your comptuer
15:54:15 <carter> MarcelineVQ:  i think maybe justhsu  is being messed with by dint of macports
15:54:28 <carter> justhsu:  i think if you remove macports stuff from your path... maybe things would work
15:54:29 <carter> OR
15:54:33 * dmwit . o O ( sudo mkdir ~/.cabal/bin )
15:54:38 <carter> chown /opt
15:54:45 <MarcelineVQ> Dunno, errors on google I can find for realpath are mostly related to containers of various sorts
15:54:49 <carter> yeah
15:54:53 <carter> its weird either way
15:55:08 <carter> like, the only "exotic" part i see so far is macports
15:55:09 <carter> ;)
15:55:18 <justhsu> yeah. maybe my past macports installation screwed up something :/
15:55:38 <dmwit> Just for fun I'd want to try --symlink-bindir=/tmp or similar.
15:55:48 <carter> justhsu:  whats $PATH
15:55:56 <carter> your $PATH seems to have the dark side
15:56:05 <carter> even though brew is worse, its a simpler worse
15:56:22 <carter> justhsu: you probably have dangling stuff in $PATH
15:56:53 <carter> justhsu:  do you have some FUSE / network file mount?
15:58:26 <justhsu> yes, my $PATH has a bunch of stuff: https://pastebin.com/15NT90Tk . I don't know about FUSE/network file mount, so I probably don't have that.
15:59:08 <carter> 1) some of those seem dpulicated
15:59:13 <carter> 2) remove the /opt stuff
15:59:19 <carter> 3) add ~/.cabal/bin :) 
16:00:12 <hexagoxel> how many "haskell 2018" surveys are there?
16:00:21 <carter> hexagoxel:  none i feel like doing
16:00:28 <hpc> hexagoxel: 2018 of them obviously
16:00:55 <MarcelineVQ> best to be suggesting absolute paths when troubleshooting path issues :>  Possibly relevant sidenote: on my weird system I​ have to relog to have path changes take effect. some people can use  source  but that doesn't work for me
16:01:14 <carter> MarcelineVQ:  but i'm lazyyyy
16:01:15 <carter> ;)
16:01:42 <rawburtz> any ideas to transform `Just [Just [1,2,3],Just [4,5,6],Just [7,8,9]]` to `Just [1,2,3,4,5,6,7,8,9]` ?
16:02:01 <justhsu> yes, source is not changing my path. i'll try relogging.
16:02:35 <hexagoxel> every survey needs to open with "why don't you want to participate and will not answer any of the remaining questions?" :D
16:03:19 <carter> cause taylor seems like a person i wanna talk with?
16:04:19 <boxscapeR> > fmap concat . sequence . map join . sequence $ Just [Just [1,2,3],Just [4,5,6],Just [7,8,9]]
16:04:21 <lambdabot>  Just [1,2,3,4,5,6,7,8,9]
16:04:22 <MarcelineVQ> > Just [Just [1,2,3],Just [4,5,6],Just [7,8,9]] >>= fold
16:04:23 <lambdabot>  Just [1,2,3,4,5,6,7,8,9]
16:04:27 <boxscapeR> ah there you go
16:04:33 <boxscapeR> I was gonna say there's almost certainly a better way
16:04:38 <rawburtz> :)
16:04:44 <rawburtz> thanks!
16:04:56 <carter> justhsu:  opening a new terminal window usually wroks for me 
16:09:43 <hexagoxel> rawburtz: what are Nothings supposed to do?
16:10:35 <rawburtz> return `Nothing` i suppose
16:11:18 <MarcelineVQ> hexagoxel: oh good point there
16:11:56 <hexagoxel> yeh, i noticed only after asking the bot :p
16:12:10 <rawburtz> at this point. i'm not sure what i prefer 
16:12:11 <hexagoxel> :exf "Maybe [Maybe [a]] -> Maybe [a]"
16:12:12 <exferenceBot> \ m1 -> m1 Control.Monad.>>= mconcat
16:12:22 <hexagoxel> > (>>= mconcat) $ Just [Just [1,2,3],Just [4,5,6],Just [7,8,9]]
16:12:24 <lambdabot>  Just [1,2,3,4,5,6,7,8,9]
16:12:31 <hexagoxel> > (>>= mconcat) $ Just [Just [1,2,3],Just [4,5,6],Nothing]
16:12:33 <lambdabot>  Just [1,2,3,4,5,6]
16:13:00 <justhsu> carter: OK, my path is now just: /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/justhsu/.cabal/bin
16:13:33 <sclv> “which cabal” tells you which its picking
16:14:20 <justhsu> sclv: /usr/local/bin/cabal
16:15:40 <sclv> So pick the path you want to take precedence and put it first or put the desired binary in the local bin
16:17:04 <anchpop> what are some interesting haskell topics?
16:17:13 <Rembane> Laziness!
16:17:29 <boxscapeR> expressive types
16:17:58 <anchpop> besides the well-known cool examples of laziness (take 3 . sort), how in-depth can you get? Rembane
16:18:38 <anchpop> boxscapeR, I'm not familiar with that term
16:18:49 <sclv> google “tying the knot”
16:19:08 <sclv> and “repmin”
16:19:13 <boxscapeR> I guess the more usual term to use would be "expressive type system", i.e. you can encode a lot of information about what your program should be doing on the type level, rather than the term level
16:19:34 <hpc> data kinds are pretty neat
16:19:50 <am3sito> This server is down!! Now join on THE BEST SERVER: /server irc.chathispano.com !!! GO GO GO!!!!
16:19:51 <am3sito> This server is down!! Now join on THE BEST SERVER: /server irc.chathispano.com !!! GO GO GO!!!!
16:19:53 <am3sito> This server is down!! Now join on THE BEST SERVER: /server irc.chathispano.com !!! GO GO GO!!!!
16:20:19 <Rembane> anchpop: I usually get bitten by too much laziness. 
16:20:55 <anchpop> hpc, I don't know much about data kinds other than some cursory knowledge of how they can be used with GDATs
16:21:14 <hpc> anchpop: have you used GADTs?
16:21:29 <anchpop> only for trivial examples
16:21:40 <anchpop> like a vector
16:22:00 <MarcelineVQ> hexagoxel: is  Just [Just [1,2,3],Just [4,5,6],Just [7,8,9]]  >>= fmap concat . sequence  as pretty as it gets?
16:23:13 <anchpop> I've used them slightly with easytensor as well hpc
16:25:51 * hackage fused-effects 0.1.0.0 - A fast, flexible, fused effect system.  http://hackage.haskell.org/package/fused-effects-0.1.0.0 (robrix)
16:30:45 <justhsu> sclv: OK, I am not sure what is going on. it's picking up the cabal in /usr/local/bin/cabal, which I believe is the one from the haskell platform
16:30:48 <hexagoxel> MarcelineVQ: probably, yes. the bot only gives the slightly longer  (=<<) (sequence . (=<<) sequence)
16:31:26 <justhsu> in .cabal/bin, there is a symlink from cabal to ../store/ghc-8.4.3/cbl-nstll-2.4.0.0-ccc88e5f/bin/cabal
16:32:46 <MarcelineVQ> there's probably a cuter version using <=< then, but it's time to do something else :>
16:33:32 <carter> justhsu: yes.  That’s the one I told you to install
16:34:05 <carter> Now make sure that’s the one which picks up. By having cabal bin be in front of the path
16:36:56 <justhsu> carter: I put cabal bin to be the first entry in my path. but I think that cabal installation did not finish (due to realpath error)
16:37:33 <carter> Well. Fix your Mac.
16:37:36 <carter> :))
16:37:39 <justhsu> the target directory of that symlink cbl-nstll-2.4.0.0-ccc88e5f doesn't appear to exist
16:38:01 <carter> I think something is wrong with your computer.
16:38:21 <carter> Could you try installing again ?
16:38:31 <justhsu> this whole thing is super mysterious :)
16:38:35 <justhsu> installing what, the haskell platform?
16:38:37 <sclv> You can just download the binary from the cabal website
16:38:42 <geekosaur> where did the vowels in that go?
16:38:59 <carter> geekosaur: I sold them on eBay?
16:47:24 <anchpop> sclv those things you said to google are really cool
16:53:17 <justhsu> sclv: interesting. I got the binary from the cabal website and I am trying cabal new-install cabal-install. so far it has not failed
16:53:43 <sclv> great
16:53:43 <justhsu> both the binary from the website and the binary from the haskell platform say version 2.2.0.0 (for OSX)
16:53:46 <justhsu> but they are slightly different
16:54:29 <sclv> they shouldn't be?
16:54:31 <sclv> idk
16:54:40 <sclv> the platform packages up the official binary from the cabal team
16:56:16 <justhsu> their file sizes are different. if this is not normal (I am not sure how these releases are coordinated) I can try to file an issue to hp github
17:08:05 <justhsu> anyways, thanks a lot for everyone's help with this issue!
17:26:16 <fen> > egSkip
17:26:18 <lambdabot>  ["1","","3"]
17:26:20 <fen> https://bpaste.net/show/06f2ba790c31
17:26:35 <fen> here is a difference list implementation for Skip 
17:27:38 <fen> it uses an abstraction (class Graph) which might be a general way to implement difference lists for many containers
17:40:42 <carter> justhsu:  file a ticket just in case
17:40:50 <carter> and do include the hashes of the files and the sizes etc
17:41:05 <carter> justhsu:  also run otool -L on both files 
17:41:11 <carter> to include info on what they link to
17:57:46 <sayola> is it just me, or do you guys also prefer `for` instead of `map`, when the given function isn't a single word?
17:59:06 <geekosaur> thats more or less why for exists
17:59:16 <kadoban> sayola: I like having whichever is more complicated last, the thing being iterated over or the function. But ya usually the function is more interesting.
18:00:01 <Axman6> for xs $ \x -> ...is quite nice
18:00:25 <Axman6> forM xs $ \x -> do ... is something I use a lot
18:05:16 <selfsymmetric-mu> Doesn't `for` work in all situations where `Applicative => Monad`?
18:05:30 <Axman6> :t for
18:05:31 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
18:06:39 <sayola> oh, right .. i was talking about  for = flip map  . not the applicative one. 
18:12:00 <selfsymmetric-mu> Oh okay, I normally think of `for` as `flip traverse`, not `flip map`.
18:18:54 <fen> sorry, internet broke earlier, was trying to ask about the class Graph used in this paste;
18:18:55 <fen> https://bpaste.net/show/06f2ba790c31
18:19:23 <fen> as a way to classify those containers which support a representation as a difference list
18:19:27 <Solonarv_> well, for = flip traverse is in base, so that makes sense
18:20:12 <Solonarv_> I occasionally use (<&>) = flip fmap
18:23:26 <fen> the idea is to make some kind of general representation of Graphs that can act like Zippers
18:23:30 <selfsymmetric-mu> Yep. In general, I see `(&)` being used as an idiom for `flip ($)`, and `<op>` as a pun for making something applicative.
18:24:01 <selfsymmetric-mu> fen: like finding the type derivative of Graph?
18:24:08 <fen> yes
18:24:12 <fen> exactly
18:24:16 <selfsymmetric-mu> That's really cool.
18:24:53 <fen> actually, its even better than just a derivative, as it leads to a comonad, it can even be thought of as integration
18:25:05 <selfsymmetric-mu> Wow I'm interested.
18:25:31 <selfsymmetric-mu> What does the one-hole context look like? Is there a nice intuition for it?
18:25:35 <fen> that is, replacing each of the values of a graph with a copy of the graph "pointing" to some element
18:25:42 <jackdk> Solonarv: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor.html#v:-60--38--62- is in base now (<&>)
18:25:43 <selfsymmetric-mu> Oh hmmm.
18:26:01 <fen> remind us about one hole contexts
18:26:09 <selfsymmetric-mu> Oh, same meaning as derivative.
18:26:25 <selfsymmetric-mu> Since it's like taking a single element and making it a hole.
18:26:34 <fen> whats the derivative of a list again? a pair of lists?
18:26:40 <selfsymmetric-mu> Exactly.
18:26:49 <fen> so, this approach is slightly different
18:26:50 <selfsymmetric-mu> With the hole being the element at which you're taking the derivative.
18:27:10 <fen> it uses a difference list as the portion of the list already traversed over
18:27:31 <selfsymmetric-mu> Oh yeah this is the Hughes representation, right?
18:27:43 <selfsymmetric-mu> With `Representable`?
18:27:46 <fen> Hughes difference lists
18:27:57 <fen> not using Representable no, see the paste
18:28:00 <selfsymmetric-mu> Nice. But for graphs?
18:28:50 <fen> traditionally, a zipper would collapse this difference list as the traversal progressed sequentially, but leaving the differences unapplied allows them to be used for containers without empty
18:29:07 <fen> but essentially they are equivalent 
18:29:20 <selfsymmetric-mu> And what use are the unapplied differences?
18:29:43 <fen> and the task of taking the derivative, and creating the zipper as the one hole context, is essentially that of creating a difference list
18:30:55 <Welkin> is there any way to embed another wai application inside of a scotty endpoint?
18:31:00 <Welkin> for SSE https://hackage.haskell.org/package/wai-extra-3.0.15.2/docs/Network-Wai-EventSource.html
18:31:04 <fen> selfsymmetric-mu: they serve the same purpose as the refolded version of the difference list normally used to hold the "already traversed" elements which form one of the lists of the pair of lists as the derivative of a list
18:31:26 <fen> so actually, it can be more general than lists, thats really the point.
18:31:29 <Welkin> I know this is easily doable with servant using Raw endpoints (bundling multiple wai applications together)
18:31:36 <selfsymmetric-mu> Very neat. What's your usecase for this library?
18:32:14 <fen> that is the differential of any container is a pair of the difference list of the previously traversed values, and the rest of the container with the yet to be traversed values
18:33:09 <fen> ok, the use for this is mainly for then doing the integration step, and creating a comonad, where each of the values of a container is replaced with this generalised zipper, (aka derivative)
18:34:09 <fen> the class of containers that can be traversed one value at a time, those that have a difference list representation, is then a comonad
18:34:43 <fen> where the way that the zipper can be navigated left and right allows for adjacent elements to be used in a "stencil convolution"
18:35:17 <dmwit> Is that really true? e.g. `Writer Any a` doesn't seem like it can sensibly be reconstructed from the values traversed so far + the values left to traverse.
18:36:15 <selfsymmetric-mu> Very cool. Thanks for the explanation. 
18:36:15 <fen> (there are also zippers over free zippers, which allow this to be done in higher dimensions, to access all the surrounding values in orthogonal directions, such as nd cartesian grids, or arbitrary hetrogenous graphs)
18:36:43 <selfsymmetric-mu> Wait where did geometry sneak in?
18:37:06 <selfsymmetric-mu> Can't you just make a graph that represents your grid? In any n-dimensional space?
18:37:31 <dmwit> Um... that's quite a claim. As far as I know constructing an efficient functional zipper for 2D grids is still an open problem.
18:38:14 <fen> well then you could only access the elements to the left and right, in one direction, but e.g. for fluid simulations, the neighbours in each direction are used
18:38:58 <fen> dmwit: the efficiency is very good.  
18:40:07 <fen> especially if partition trees are used, which are very nicely handled by this approach 
18:41:37 <fen> rather than using trees of bounded balance, the intrinsic structure of the system can be incorporated (such as if sparse access locations change only slightly between iterations)  
19:15:51 * hackage hjugement 2.0.0.20181029 - Majority Judgment.  http://hackage.haskell.org/package/hjugement-2.0.0.20181029 (julm)
19:25:27 * hackage hjugement 2.0.0.20181030 - Majority Judgment.  http://hackage.haskell.org/package/hjugement-2.0.0.20181030 (julm)
19:28:28 * hackage sws 0.4.3.0 - A simple web server for serving directories.  http://hackage.haskell.org/package/sws-0.4.3.0 (DerekElkins)
21:02:56 <pzp> Is there a way to derive a standalone instance only if there is not an existing instance?
21:03:26 <glguy> not without template haskell
21:03:45 <glguy> or a version number guided CPP solution
21:05:33 <pzp> I suppose you could always wrap it a newtype and then derive the instance on that but that's a bit of a pain
21:28:13 <jle`> it's really the main way to deal with this sort of stuff, and it isn't too bad if it's only for internal use pzp 
21:34:47 <slack1256> pzp: Plus you can use Data.Coerce.coerce to deal with the newtype as if it was not there
21:47:33 <NanoSector20> /!\ AᎢΤΝ: This channel һɑs ⅿovеԁ to іrc.frᥱеnode.ᥒet #/joiᥒ ᜵!\
21:47:37 <NanoSector20> Ꮃⅰth our IRC aⅾ ѕer∨ⅰce yo∪ cɑn rеach a glοbaⅼ auԁieᥒcᥱ of eᥒtreрreneurs ɑnd fеntanyl addicts wіth eⅹtrɑorԁiᥒarу enɡaɡeⅿent ratеѕ! һttрѕ:⁄/willⅰampіtⅽoϲk．com/
21:49:37 <jackdk> the winds of spam blow across IRC again...
21:52:54 * hackage toodles 0.1.0.14 - Manage the TODO entries in your code  http://hackage.haskell.org/package/toodles-0.1.0.14 (aviaviavi)
22:06:42 --- mode: ChanServ set +o glguy
22:06:42 --- mode: glguy set +q $~a
22:28:01 <fr33domlover> Hi people! I've been getting an error "unable to commit [1MB] bytes to memory" and then my program crashes. I never had this before (I deployed the app on a new server recently, but it's the same program). Is that a GHC bug? Or a memory leak in my code? How to I start debugging such a thing? (It's a Yesod web app btw)
22:28:21 <fr33domlover> (Using GHC 8.2.2)
22:29:55 * hackage jmonkey 0.1.0.0 -   http://hackage.haskell.org/package/jmonkey-0.1.0.0 (opyapeus)
22:32:47 * fr33domlover has a request log, if lucky maybe can see the last request there before server crashes
22:33:30 <pavonia> Do you know how much memory it has used before crashing?
22:37:48 <haasn> ^ if you have `atop` running you can check the memory usage retroactively. love that program for servers, has solved many a mystery
22:45:38 <fr33domlover> pavonia, nope. haasn, cool! I'll try it
22:48:08 <fr33domlover> One possibility is that someone uploaded some big file, and when that file gets requested, it's uploaded into RAM entirely
22:48:35 <fr33domlover> Hmm although all the files together are just 188MB total
22:48:52 <fr33domlover> So it can't be very big hmmm maybe just a memory leak in my code
23:13:12 <heptahedron> I'm having difficulty encoding a less-than relationship on the type level with multiparamtypeclasses, any pointers?
23:13:41 <heptahedron> Trying to enforce a maximum depth on a tree data structure.
23:13:41 <dminuoso> heptahedron: Can you show us what you have tried so far?
23:13:53 <heptahedron> dminuoso: sure, one sec
23:20:23 <nkaretnikov> is there something like rose tree that would allow me to go backwards from a child to the root?
23:20:26 <nkaretnikov> a*
23:20:50 <heptahedron> dminuoso: https://gist.github.com/heptahedron/28321de7b33a11daefcfb6dedbeb4f9a
23:21:02 <nkaretnikov> something that in c would be implemented with a pointer to the parent
23:21:10 <jle`> nkaretnikov: it's sort of the same issues with doubly-linked lists in haskell
23:21:37 <nkaretnikov> jle`: could you elaborate?
23:22:00 <heptahedron> I guess I can see why that causes a reduction stack overflow, because it could keep trying to find an instance for `(IsDeeper d d)` using the transitive instance, and it never will. Maybe I could make an instance that causes a TypeError?
23:22:25 <jle`> nkaretnikov: this SO answer talks about some of the issues https://stackoverflow.com/questions/10386616/how-to-implement-doubly-linked-lists
23:27:41 <heptahedron> Oh wait, if I made some type family `DepthBelow` then that would probably solve the issue
23:31:52 <mniip> heptahedron, yeah no you have to write out all instances
23:33:36 <mniip> heptahedron, one solution is to encode the depths using peano numerals
23:34:02 <mniip> then `instance Less Z (S x)` and `instance (Less a b) => Less (S a) (S b)`
23:34:05 <mniip> always terminate
23:35:07 <heptahedron> mniip: ahhh, thanks!
23:36:09 <heptahedron> mniip: well I can get around writing all the instances by using an injective multiparamtypeclass to take the position of `S` right?
23:36:42 <mniip> maybe
23:36:50 <heptahedron> mniip: I'll report back with results haha
23:36:56 <mniip> probably
23:37:38 <mniip> no, I think you need the disjointness of Z and (S a) in the first argument of Less
23:43:23 <dminuoso> cocreature: Look at my latest toy with light transformer stacks: altMap :: (Alternative p, Foldable f) => (a -> p b) -> f a -> p b
23:43:57 <dminuoso> This is a neat drop-in replacement for a global MaybeT if you care about the Alternative instance =)
23:44:20 <dminuoso> do { r <- runMaybeT (altMap MaybeT handlers); ... }
23:45:26 <dminuoso> Kicking MonadBaseControl out was the best thing. :)_
23:45:52 <cocreature> dminuoso: I keep being surprised that altMap is not a thing in base
23:49:07 <Axman6> what's altMap?
23:49:21 * Axman6 reads up -_-
23:50:27 <cocreature> Axman6: altMap f = asum . fmap f
23:51:03 <Axman6> right, so foldMap for alternative
23:51:22 <cocreature> exactly
23:59:01 <jle`> asum . fmap f doesn't work if f is not Functor
