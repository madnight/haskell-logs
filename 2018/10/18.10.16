00:01:36 <ion> Now, to make it more generic, it's a good idea to parameterize the thing the caller wants to do with the nth element. You can do something like: atElem :: (a -> a) -> Int -> [a] -> [a]; atElem f n [] = []; atElem f 0 (x:xs) = _; atElem f n (x:xs) = x : atElem f (n - 1) xs
00:01:46 <ion> with the 0 case left as an exercise
00:02:21 <ion> With that function, you can do things like: atElem (*2) 1 [3,4,5]
00:02:41 <ion> or: doubleAt = atElem (*2)
00:03:26 <deviantfero> ion, is that what we call composite functions?
00:03:56 <ion> Higher-order functions is the term you would use when your function (atElem) takes a function (*2) as a parameter.
00:04:05 <deviantfero> nice
00:06:33 <deviantfero> ion: would this be correct? atElem f n [] = []; atElem f 0 (x:xs) = (f x):xs
00:06:41 <ion> Yes
00:06:45 <deviantfero> excelent
00:06:48 <deviantfero> of course
00:06:53 <deviantfero> I still need to think about it myself
00:07:03 <deviantfero> I mean, I still need to learn to think like this
00:07:13 <deviantfero> but you've been absolutely awesome
00:07:18 <ion> :-)
00:07:19 <deviantfero> I have to sleep tho
00:07:24 <deviantfero> thanks for the help
00:07:26 <ion> np!
00:07:35 <deviantfero> be seeing you around guys!
00:07:39 <ion> o/
00:10:39 <mniip> dminuoso, I cam up with such a monoid
00:12:17 <mniip> if we have a family of permutations s_i : i <-> i
00:12:27 <mniip> where i in N
00:12:41 <mniip> then with s_i we can act on X^i for some set X
00:12:48 <mniip> and with the whole family we can act on X*
00:12:51 <mniip> aka [X]
00:13:17 <mniip> this construction is an (Set) isomorphism natural in X
00:13:43 <mniip> calling that action S : [X] -> [X]
00:13:57 <mniip> we can then define a monoid with mappend xs ys = S^-1 (S xs ++ S ys)
00:14:22 <mniip> now I'm thinking
00:19:59 <mniip> still thinking
00:20:24 <mniip> basically I want an interleave type of thing
00:42:51 <POGtastic> stupid question: why doesn't this print "Input a number." before asking for input from the user? https://repl.it/@pogtastic/VigilantJovialLine
00:43:19 <POGtastic> it waits for input and *then* prints the message.
00:44:08 <ion> POGtastic: You'll need to flush the output manually. In operating systems, IO to terminals, files, the network etc. generally gathers output to a buffer and uses some rule to flush it unless flushed manually.
00:44:23 <ion> @hoogle hFlush
00:44:24 <lambdabot> System.IO hFlush :: Handle -> IO ()
00:44:24 <lambdabot> GHC.IO.Handle hFlush :: Handle -> IO ()
00:44:24 <lambdabot> Sound.File.Sndfile hFlush :: Handle -> IO ()
00:44:38 <POGtastic> ion: thanks, i'll look into that.
00:46:42 <ion> Btw, print = putStrLn . show
00:47:21 <POGtastic> ion: ooooo
00:47:39 <POGtastic> ion: looks like `hflush stdout` did it. thanks a lot
00:47:46 <ion> (The rule is often to flush after each full line, it may also be to flush after a certain amount of bytes have been written.)
00:47:55 <ion> (and it can be configured)
01:19:45 <infinisil> I pretty much solved my logging problem very nicely, I think
01:20:04 <infinisil> I can't show it though, because my laptop has no battery left :P
01:22:08 <infinisil> Well the main thing is: Use TMQueue for logs, run thread to output until closed. Main thread closes it when done, then waits until the channel is empty to terminate
01:22:26 <infinisil> Oh hold on, this might still drop the last message
01:22:29 <infinisil> Darn
01:24:47 <infinisil> Ohh I can just wait until the other thread terminates actually
01:25:21 <infinisil> At which point I should use async's withAsync, mentioned my cocreature yesterday..
01:25:28 <infinisil> by*
01:25:32 * infinisil gets it now
01:26:33 <dminuoso> Argh, why is there no `instance IOException ServantErr`
01:27:04 <dminuoso> Oh wait. Heh.
01:30:02 <Ariakenom> infinisil: :p
01:30:38 <Ariakenom> infinisil: You abandoned synchronous?
01:38:01 <robstr> Is there an explanation why so many rest apis return jsons and decode numbers as strings with \" ?
01:44:12 <yushyin> what? Like this "\"1234\""?
01:44:41 <yushyin> interesting!
01:45:10 <tdammers> yes
01:45:20 <tdammers> numbers in JSON are somewhat ill-defined
01:45:37 <tdammers> the "spec" just talks about "numbers", which means that the choice of numeric type is implementation-defined
01:45:50 <tdammers> which is of course terrible
01:46:15 <tdammers> 1234, for example, might be represented as a float, or as an int
01:46:32 <tdammers> and as a consequence, it is unclear whether 1234 should be considered equal to 1234.0 or not
01:47:37 <tdammers> the most likely consumer language however is JavaScript, so you can expect all JSON numbers to be interpreted as floats; if you want your data to be handled exactly, that is a terrible choice
01:48:29 <tdammers> using strings instead, we can expect the consumer to extract an exact decimal representation, without loss of precision, and from there, it's up to them how they want to do numeric calculations, if any
01:50:08 <Ariakenom> number is the name of the float type in js, no? 
01:52:16 <dminuoso> 01:45:37 <tdammers> the "spec" just talks about "numbers", which means that the choice of numeric type is implementation-defined
01:52:18 <dminuoso> That's not correct.
01:52:27 <dminuoso> ECMAScript defines number as a IEEE 754 double precision value.
01:52:39 <dminuoso> https://www.ecma-international.org/ecma-262/9.0/index.html#sec-terms-and-definitions-number-value
01:53:06 <dminuoso> Though the fact that everybody gets this wrong one way or another should be a good indication that this is a really deep issue.
01:53:38 <robstr> tdammers: thank you i was always curious about this 
01:54:31 <dminuoso> And in all fairness, number can represent many numbers accurately.
01:54:43 <dminuoso> That is, an IEEE 754 can represent a whole bunch of numbers accurately.
01:54:53 <dminuoso> *an IEEE 754 double precision number
01:56:06 <Ariakenom> > 0.1 + 0.2 -- obligatory
01:56:09 <lambdabot>  0.30000000000000004
01:56:44 <cocreature> dminuoso: that’s not the json standard
01:57:35 <cocreature> just because some other spec defines numbers as ieee754 double precision doesn’t mean that they are defined that way in json
01:58:17 <dminuoso> Ah.
01:58:38 <cocreature> https://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf
01:58:39 <dminuoso> This is retarded. :(
01:58:46 <dminuoso> Yeah looking at it, cocreature.
01:58:48 <cocreature> “JSON is agnostic abou
01:58:50 <cocreature> t the semantics of numbers.
01:58:52 <cocreature> ”
01:59:11 <dminuoso> It's so sad because IEEE 754 was invented so a standard existed..
01:59:16 <cocreature> “JSON instead offers only the representation of numbers that humans use: a sequence of digits.”
01:59:34 <cocreature> funnily enough you can’t even represent ieee754 doubles as JSON numbers due to infinity and nan
01:59:35 <dminuoso> "All programming languages know how to make sense of digit sequences even if they disagree on internal representations. That is enough to allow interchange."
01:59:39 <dminuoso> Haha this is hilarious.
01:59:40 <infinisil>  Ariakenom Yeah, while sync would make it neater, it seems too inefficient for bigger applications that might log a lot. I want a solution i can reuse wherever I need
02:02:53 <Ariakenom> Obviously not allowed to send a third. Because that's not a number humans use.
02:04:00 <tdammers> dminuoso: I was talking about the JSON spec
02:05:05 <tdammers> Ariakenom: ["1","3"] // problem solved
02:06:12 <Ariakenom> "1 / 3", {numer=1, denom=3}
02:07:22 <Ariakenom> standardisation pls
02:07:37 <yushyin> dminuoso: https://tools.ietf.org/html/rfc8259#section-6 'allows implementations to set limits' allows but not restrict
02:10:12 <Entroacceptor> {[{"encoding": "Haskell", "value": "1 % 3 :: Rational"}]}
02:11:21 <MarcelineVQ> Don't you guys ever get tired of being so cool?
02:11:25 <Ariakenom> "The representation of numbers is similar to that used in most
02:11:25 <Ariakenom>  programming languages. A number is represented in base 10 using
02:11:26 <Ariakenom>  decimal digits."
02:11:29 <mniip> MarcelineVQ, no
02:12:06 <tdammers> how about {value: "<?xml version="1.0"?><?php public final (RATIO I III) :: Ratio Integer /** @type: std::ratio<int> */ ?> ;;;\nPLEASE GIVE UP"}, that should appeal to everyone
02:12:12 <MarcelineVQ> Geeze, it looks completely exhausting. I guess that's just one of the many skills and powers of the coolkid.
02:12:41 <cocreature> MarcelineVQ: you are assuming that we actually are cool :)
02:13:53 <MarcelineVQ> I checked the meter, cocreature 
02:14:11 <MarcelineVQ> It's completely off the scale.
02:14:22 <mniip> tdammers, you forgot a blob of x86_64 shellcode in there that places the numerator in %rax and denominator in %rdx
02:14:24 <cocreature> it’s probably broken
02:14:35 <MarcelineVQ> Of course it is, from the coolness.
02:14:53 <Ariakenom> negative overflow, I'm sure
02:15:25 <mniip> MarcelineVQ, it's the kilogram that should be on the scales, not the meter
02:15:32 <MarcelineVQ> Luckily a negative overflow is a positive value
02:17:28 <MarcelineVQ> As an unrelated side, being too cool for compliments only makes you cooler.
02:22:10 <cocreature> MarcelineVQ: you’re here so you’re part of whatever coolness may or may not exist here :)
02:23:51 <tdammers> mniip: my bad
02:35:23 <dminuoso> Mmm, is there a way to proxy/derive all instances through a newtype wrapper without having to specify each?
02:35:57 <dminuoso> Or do I really have to tap into GeneralizedNewtypeDeriving and put some 15 instances on there?
02:38:08 <tdammers> if you're going to derive all the instances, then what's the point in having the newtype in the first place?
02:44:11 <dminuoso> tdammers: So I have a monad stack `type Frejya = ReaderT Pool IO` and I want to create another variant `type FreyjaTrans = ExceptT Rolllback (ReaderT Connection IO)` that should run transactionally safe.
02:45:27 <dminuoso> tdammers: If this was just a type alias then I could run this without the transaction, since nothing would stop me from carelessly doing: runExceptT (stack `runReaderT` conn)
02:45:39 <tdammers> ah
02:47:08 <tdammers> in that case, I fear GND-ing all the required typeclasses individually will be inevitable
02:48:30 <dminuoso> Ah well, it's quickly typed I guess.
03:16:14 --- mode: glguy set +v Guest56
03:23:24 --- mode: glguy set +v tmp123123123
03:24:52 --- mode: glguy set +v newbie886
03:25:31 <newbie886> hey all 
03:25:38 <newbie886> what is quantum computing
03:27:37 <yushyin> newbie886: this is #haskell, ask in ##cs or ##computerscience
03:28:37 <newbie886> yushyin:  Ok I did 
03:28:44 <newbie886> ut curious what it is 
03:29:02 <tmp123123123> Hi, one question: Imagine I do the following in ghci: "Prelude> let x  = 1  :: Int" "Prelude> let y = 1" "Prelude> :sprint x" "Prelude> :sprint y" "Prelude> x" "Prelude> y" "Prelude> :sprint x" "Prelude> :sprint y". What I do not understand is why does "Prelude> y" print "1" but afterwards ":sprint y"  still says that  y is  a  thunk (I image it has something  to do with ys polymorphic type?).
03:33:26 <dminuoso> tmp123123123: Can you make that as a gist?
03:33:33 <dminuoso> It's a bit hard to read that in one line.
03:35:14 <tmp123123123> one  sec  pls
03:35:34 <dminuoso> tmp123123123: Ah I think I understand already.
03:35:49 <dminuoso> tmp123123123: Polymorphic variables should be understood as kind of "functions" abstracted over a type.
03:36:06 <dminuoso> tmp123123123: As such the thunk can't be replaced with a concrete value
03:36:57 <dminuoso> % :set -XTypeApplications
03:36:58 <yahb> dminuoso: 
03:37:06 <dminuoso> % x = 1
03:37:06 <yahb> dminuoso: 
03:37:07 <tmp123123123> dminuoso: In the sense that y is a function  still  taking the Num dictionaryy?
03:37:15 <dminuoso> tmp123123123: Right.
03:37:47 <dminuoso> tmp123123123: Although I'd be careful with the word "function" here.
03:37:59 <tmp123123123> What word else to  use?
03:44:52 <tmp123123123> dminuoso: Thank you very much!
03:45:46 <__monty__> Isn't it more because of the literal than the variable?
03:47:11 <dminuoso> __monty__: No. He created two bindings `x :: Num a => a` and `y :: Int` respectively and forced their evaluation and then noted that `x` still looked like a thunk `_`
03:50:15 <dminuoso> This is actually a neat little example showing that polymorphism can possibly have performance impacts.
03:50:49 <__monty__> dminuoso: But does the binding to a variable matter? With the annotation the fromIntegral instance is known and can be evaluated. Without the annotation you can't. I.e. can't you make this problem surface without binding the literal to a name?
03:52:31 <dminuoso> __monty__: Well you'll have a bit of a harder time looking at thunks in GHCi if you don't bind them to variables.
03:52:41 <dminuoso> Oh.
03:52:45 <dminuoso> I misunderstood you.
03:52:48 <dminuoso> Yeah, good point.
03:53:19 <dminuoso> So I should have said "polymorphic *values* should be understood as kind of "functions" abstracted over a type"
03:55:08 <__monty__> Ok, thanks for clearing it up. Was just remembering a blog post about variables not being 0-arity functions so you were shaking up my worldview ; )
03:57:09 <dminuoso> __monty__: The one by Conal Elliott?
03:58:48 <govno> very strange `forall` keyword
03:58:55 <__monty__> Yes `"Everything is a function" in Haskell?`
03:59:08 <govno> a types variable it is a variable
03:59:10 <mniip> it's not the polymorphic values
03:59:18 <mniip> it's the constrained types
03:59:31 <mniip> they are quite literally functions runtime-wise
03:59:50 <govno> forall it is constranted ???
04:00:04 <mniip> `x :: Num a => a' is not a function that takes the type a, it's a function that takes 'Num a'
04:00:47 <govno> geterogenious list it is norm
04:01:38 <dminuoso> mniip: Ah I forgot about _|_ 
04:01:57 <dminuoso> And yay. Bottom has a ligature too in FiraCode =)
04:02:21 <mniip> dminuoso, what does _|_ have to do with anything
04:02:50 <dminuoso> mniip: what else would fit into an unconstrained polymorphic value?
04:03:04 <mniip> % x = Nothing
04:03:04 <yahb> mniip: 
04:03:06 <mniip> % x
04:03:06 <yahb> mniip: Nothing
04:03:08 <mniip> % :sprint x
04:03:08 <yahb> mniip: x = Nothing
04:03:12 <mniip> % :t x
04:03:12 <yahb> mniip: Maybe a
04:03:34 <dminuoso> Mmm interesting.
04:04:08 <dminuoso> % x = Nothing; x :: Num a => Maybe a
04:04:09 <yahb> dminuoso: 
04:04:11 <dminuoso> % x
04:04:11 <yahb> dminuoso: Nothing
04:04:15 <dminuoso> % :sprint x
04:04:15 <yahb> dminuoso: x = _
04:04:39 <dminuoso> mniip: Okay this surprises me now.
04:04:49 <dminuoso> TIL. :)
04:10:22 <mniip> one sec
04:13:29 <govno> when in haskell use `forall` keyword?
04:13:47 <dminuoso> govno: In the more basic cases a `forall` is implied whenever you have a type variable.
04:14:28 <mniip> neat
04:14:41 <mniip> unpackClosure# in GHC.Prim has changed type since I last used it ...
04:15:19 <dminuoso> govno: `x :: Maybe a` actually implies `x :: forall a. Maybe a` 
04:17:13 <cocreature> mniip: I’m curious, what are you using unpackClosure# for?
04:17:32 <mniip> I was hoping to use it for demonstration purposes
04:17:40 <mniip> but it seems I'd have to update a certain package of mine first
04:19:48 <dminuoso> govno: So for most starter situations it's trivial and unnecessary, it's the same whether you write it or not.
04:20:09 <dminuoso> govno: With ScopedTypeVariable you use `forall` to change the scope of a type variable. This is one of the simpler uses.
04:52:43 <mniip> ok, I figured it out
04:52:44 <mniip> dminuoso,
04:52:51 <mniip> % closureType ()
04:52:51 <yahb> mniip: CONSTR_0_1
04:52:54 <mniip> % closureType Nothing
04:52:54 <yahb> mniip: CONSTR_0_1
04:52:58 <mniip> % closureType id
04:52:58 <yahb> mniip: FUN_STATIC
04:53:01 <mniip> % closureType 1
04:53:01 <yahb> mniip: CONSTR_0_1
04:53:19 <mniip> hm, that one might have defaulted
04:53:50 <mniip> % x = 1
04:53:50 <yahb> mniip: 
04:53:53 <mniip> % closureType x
04:53:53 <yahb> mniip: AP
04:55:07 <mniip> it's AP because it's taking the type of the closure (x $fNumInteger)
04:55:38 <Ariakenom> % closureType fmap
04:55:38 <yahb> Ariakenom: ; <interactive>:33:13: error:; * Ambiguous type variable `f0' arising from a use of `fmap'; prevents the constraint `(Functor f0)' from being solved.; Probable fix: use a type annotation to specify what `f0' should be.; These potential instances exist:; instance Arrow a => Functor (WrappedArrow a b) -- Defined in `Control.Applicative'; instance Monad m => Functor (Wr
04:56:09 <Ariakenom> % closureType (+)
04:56:09 <yahb> Ariakenom: AP
04:56:36 <Ariakenom> % closureType ($)
04:56:36 <yahb> Ariakenom: FUN_STATIC
05:00:16 <dminuoso> mniip: What is closureType?
05:00:44 --- mode: glguy set +v moth_
05:00:44 <mniip> closureType x = compose_3pba unpackClosure# x (\a _ _ -> tagToEnum# (indexInt32OffAddr# a 2#) :: ClosureType)
05:01:09 <dminuoso> And compose_3pba ?
05:02:58 <moth_> hello
05:03:31 <moth_> is this work test
05:03:37 <moth_> do u guys know how whether do i get a girlfreind
05:03:38 <moth_> or not
05:04:20 <dminuoso> moth_: I do not believe someone here is able to answer that question. But while you are waiting for one to find you, perhaps pick up a Haskell book and learn this top notch functional non-strict programming language?
05:08:19 <hodapp> having gainful employment, which technical skills certainly help along, tends to make it easier to find a mate.
05:12:38 <mniip> dminuoso, well there's a little package that I wrote http://hackage.haskell.org/package/box-tuples-0.1.1.0/docs/Data-Tuple-Unboxed.html#v:compose_3pba
05:41:28 --- mode: glguy set +v govno
06:05:38 --- mode: glguy set +v zincy_
06:08:07 <arianvp> ~
06:10:22 <zincy_> Say you have an extra stack proj with shared types. When I run nix build I get this https://pastebin.com/tTUnD9ep
06:10:26 <zincy_> any ideas?
06:10:50 <Taneb> turtle library question: I want to run a proc but redirect stderr to a file. How could I do this?
06:12:53 <Taneb> And I want to get the exit code at the end
06:15:50 <lyxia> zincy_: it's complaining the library "shared" doesn't exist
06:17:39 <zincy_> Yeah weird I specified it in extra deps 
06:17:45 <zincy_> for stack 
06:17:54 <zincy_> Actually stack seems to build it so thats ok
06:19:13 <lyxia> maybe nix build doesn't call stack
06:21:09 <mniip> can closures ever be stack-allocated
06:21:48 <zincy_> lyxia: yeah good point maybe it just uses cabal
06:22:16 <ventonegro> mniip: In general yes, dunno about GHC
06:22:40 <mniip> definitely not talking about GHC
06:22:48 <mniip> but rather about a generic lambda calculus + ADT language
06:23:00 <max3> why does `fmap show (return True)` bug out ghci?
06:23:17 <ventonegro> So, if the closure doesn't escape or only escapes downwards, then yes
06:23:19 <mniip> % fmap show (return True)
06:23:19 <yahb> mniip: "True"
06:23:27 <max3> interesting. intero claims it's a bug
06:23:28 <mniip> max3, what is the bug?
06:24:06 <mniip> ventonegro, 'id' is not a function you can invoke then
06:24:15 <max3> pprPanic, called at compiler/basicTypes/Name.hs:241:3 in ghc:Name
06:24:51 <ventonegro> mniip: What do you mean?
06:25:00 <max3> mniip, https://i.imgur.com/dNllBdl.png
06:25:14 <Ariakenom> I think both C++ and rust can stack allocate closures
06:25:18 <mniip> ventonegro, you construct a closure, pass to id, destroy the closure, the thing returned from id is invalidated
06:25:19 <Ariakenom> mniip
06:25:33 <mniip> C++ has closures?
06:25:49 <mniip> unless you mean C++ lambda functions
06:26:14 <Ariakenom> I do
06:26:22 <mniip> max3, do you have a funky .ghci
06:26:45 <mniip> Ariakenom, you have to watch their lifetimes very closely though
06:26:56 <tdammers> C++'s closures avoid the problem though because C++ doesn't do GC, and its closures are in line with the rest of the "explicit by-ref or by-val" system
06:26:59 <max3> mniip, no .ghci at all - it's a stack project
06:27:42 <ventonegro> mniip: When you use a closure as data it is escaping
06:27:48 <ski> mniip : how about <https://en.wikipedia.org/wiki/Region-based_memory_management#Region_inference> in ML Kit ?
06:27:57 <mniip> the general meta-question is to what extent can GC be reduced/simplified for a lambda calculus language
06:28:08 <dminuoso> mniip: Mmm where can I find documentation about the different STG closure types?
06:28:34 <lyxia> you can have no GC by copying everything on the stack
06:28:42 <mniip> dminuoso, rts/storage/ClosureTypes.h
06:28:50 <tdammers> I've been pondering what a non-GC'd lambda-calculus-based language might look like myself, and indeed, passing everything by-value would be the first naive solution
06:29:05 <ski> you can do Cheney-on-the-MTA by simulating a heap on the stack, as Chicken (a Scheme implementation) does
06:29:14 <mniip> tdammers, that obviously doesn't allow for recursive datatypes no?
06:29:44 <tdammers> mniip: true
06:29:48 <dminuoso> mniip: Well that is just where some macros are defined.
06:30:10 <mniip> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
06:30:20 <ski> (iirc, there's an internal language, PreScheme, which is used inside Scheme48, which has restrictions such that things get stack-allocated)
06:30:40 <Ariakenom> lyxia: if its immutable
06:30:40 <dminuoso> Ahh that's the one, thanks :)
06:30:50 <lyxia> max3: maybe there's some funny incoherent instance in scope?
06:30:53 <Ariakenom> recursive datatypes are fine as long as they're not cyclic?
06:31:05 <max3> lyxia, instance of what though?
06:31:05 <lyxia> Ariakenom: good point
06:31:24 <lyxia> max3: Functor or Monad
06:31:29 <mniip> Ariakenom, if they're a flat tree
06:31:40 <mniip> otherwise a copy becomes a super tricky operation anyway
06:32:03 <mniip> while a tree can be linearly stored with a size header at every node
06:32:05 <max3> hm
06:33:28 <Ariakenom> mniip: *flat* tree?
06:33:54 <max3> lyxia, not by me at least. restarting repl still produces same bug
06:33:57 <Ariakenom> what does flat mean there?
06:34:10 <mniip> Ariakenom, nothing, just saying it's not merely a dag but also a tree
06:34:51 <Ariakenom> got it
06:37:45 <dminuoso> mniip: Okay this is a really interesting tool, closureType I mean.
06:37:54 <dminuoso> Some mighty deep black magic behind it.
06:38:44 <dminuoso> How comes (+) has a different closure than ($)? Is the AP related to needing the Num dictionary?
06:38:56 <dminuoso> > closureType (+)
06:38:59 <lambdabot>  error:
06:38:59 <lambdabot>      Variable not in scope:
06:38:59 <lambdabot>        closureType :: (Integer -> Integer -> Integer) -> t
06:39:04 <dminuoso> % closureType ($)
06:39:04 <yahb> dminuoso: FUN_STATIC
06:39:06 <dminuoso> % closureType (+)
06:39:06 <yahb> dminuoso: AP
06:39:38 <Putonlalla> % closureType const
06:39:38 <yahb> Putonlalla: FUN_STATIC
06:40:51 <ggole> % closureType ((+) :: Int -> Int -> Int)
06:40:51 <yahb> ggole: AP
06:41:09 <ggole> Hmm.
06:41:22 <Ariakenom> % closureType flip
06:41:23 <yahb> Ariakenom: FUN_STATIC
06:41:40 <dminuoso> % closureType (fmap @[])
06:41:40 <yahb> dminuoso: AP
06:41:46 <dminuoso> % closureType (fmap @[] Int Int)
06:41:46 <yahb> dminuoso: ; <interactive>:49:23: error:; * Data constructor not in scope: Int :: a0 -> b0; * Perhaps you meant variable `int' (imported from Text.PrettyPrint.HughesPJ); <interactive>:49:27: error:; * Data constructor not in scope: Int :: [a0]; * Perhaps you meant variable `int' (imported from Text.PrettyPrint.HughesPJ)
06:41:52 <dminuoso> % closureType (fmap @[] @Int @Int)
06:41:52 <yahb> dminuoso: AP
06:42:24 <mniip> 10/16/2018 [16:38:21] <dminuoso> How comes (+) has a different closure than ($)? Is the AP related to needing the Num dictionary?
06:42:25 <mniip> pretty much
06:42:34 <mniip> you have a bit of defaulting here
06:42:53 <mniip> \num -> closureType ((+) num)
06:43:00 <dminuoso> mniip: Ohhh.. so it's a partial application with the Num dictionary already in for Int?
06:43:10 <max3> are integer literals cast as Int or Integer by default?
06:43:11 <dminuoso> (Or whatever that may default to)
06:43:19 <mniip> Integer
06:43:23 <Ariakenom> % closureType closureType
06:43:23 <yahb> Ariakenom: BCO
06:43:33 <mniip> BCO because it's defined interactively
06:44:29 <Ariakenom> % closureType (closureType closureType)
06:44:29 <yahb> Ariakenom: AP
06:44:43 <mniip> I wonder if
06:44:45 <dminuoso> mniip: This makes a lot of sense, also explains why this fails
06:44:48 <dminuoso> % closureType fmap
06:44:48 <yahb> dminuoso: ; <interactive>:56:13: error:; * Ambiguous type variable `f0' arising from a use of `fmap'; prevents the constraint `(Functor f0)' from being solved.; Probable fix: use a type annotation to specify what `f0' should be.; These potential instances exist:; instance Arrow a => Functor (WrappedArrow a b) -- Defined in `Control.Applicative'; instance Monad m => Functor (Wr
06:44:53 <mniip> % closureType $! (+)
06:44:53 <yahb> mniip: FUN_STATIC
06:44:59 <mniip> there you go
06:45:03 <dminuoso> Cool :)
06:47:22 <mniip> here's a bit of a surprise
06:47:28 <mniip> % closureType ""
06:47:28 <yahb> mniip: CONSTR_0_1
06:47:30 <mniip> % closureType "hi"
06:47:30 <yahb> mniip: AP
06:48:05 <mniip> I think that's because strings are compiled into "fromAddr <pointer to a memory region containing the string>"
06:48:33 <ski> % closureType $! "hi"
06:48:33 <yahb> ski: CONSTR_2_0
06:48:51 <dminuoso> :t ($!)
06:48:54 <lambdabot> (a -> b) -> a -> b
06:49:02 <ski> @src ($!)
06:49:02 <lambdabot> f $! x = x `seq` f x
06:49:20 <Ariakenom> missed an opportunity to go with interrobang there
06:49:36 <dminuoso> :t ($! (+))
06:49:37 <lambdabot> Num a => ((a -> a -> a) -> b) -> b
06:49:44 <ski> i think `UnicodeSyntax' wasn't a thing, back then ?
06:50:16 <Ariakenom> I was mostly meaning swapping them
06:50:18 <ski> (hm, perhaps unicode in identifiers were still allowed, not sure)
06:51:45 <dminuoso> Why does `closureType $! (+)` give me a FUN_STATIC? Is that because the stg closure is forced into WHNF giving back the implemention of the defaulted (+)?
06:57:01 <lyxia> what else could it be
07:04:40 <mniip> dminuoso, (+) is kind of a selector from the Num record
07:04:56 <mniip> when applied to a fixed dictionary and forced it gives you the element of the record
07:05:38 <awal> Hi, everytime I run `stack build` or `stack build intero`, it starts to download ghc-tinfo6. Why does it not cache it somewhere?
07:14:43 <dminuoso> lyxia: Well it could be a PAP
07:16:08 <dminuoso> % let l = \a -> \b -> 1 in closureType $! (l ())
07:16:08 <yahb> dminuoso: PAP
07:17:15 <dminuoso> % let l = \a b -> 1 in closureType $! (l ())
07:17:15 <yahb> dminuoso: PAP
07:17:28 <dminuoso> Interesting.. 
07:18:42 <lyxia> awal: maybe it's a version you don't have cached
07:18:58 <max3> anyone famliiar with this book? https://www.amazon.com/Algebra-Programming-Prentice-hall-International-Computer/dp/013507245X
07:19:11 <max3> isn't there another one by a russian guy that's the original source material for the theory?
07:22:35 <ski> not sure about russian guy
07:23:11 <max3> maybe not russian but eastern bloc i think
07:23:36 <max3> *former eastern bloc
07:24:13 --- mode: glguy set +v dmwit
07:24:36 <infinisil> Goddamnit, disappointed by monad-logger again
07:24:44 <infinisil> It's not composable at all
07:25:15 <infinisil> Unless I'm missing something, it's impossible to log to multiple targets without copying half of the library
07:27:45 <max3> opinions on huttons programming in haskell vs bird's thinking functionally with haskell?
07:30:40 <dminuoso> infinisil: Is that different targets from the same module?
07:30:51 <infinisil> No not that kinda targets
07:31:02 <infinisil> I mean to log to stderr and a file at the same time
07:31:11 <infinisil> Can't do it
07:31:37 <Taneb> max3: Programming in Haskell has a more recent edition
07:32:22 <dminuoso> infinisil: It seems to me that if you wrote your own instance MonadLogger that just discriminates on the LogLevel and then does either it should work
07:32:33 <max3> Taneb, yes i'm reading that one
07:32:39 <max3> "for any parameterised type in Haskell, there is at most one function fmap that satisfies the required
07:32:39 <max3> laws" proof?
07:33:19 <infinisil> dminuoso: Yeah I can, but then I need to copy a lot of code from the package to make it work
07:33:56 <dminuoso> infinisil: Wait a sec..
07:34:02 <Taneb> max3: roughly, "fmap id = id" and you can't tell if the function you've just been given is id
07:34:04 <infinisil> There's no way to get to the code used for runFileLoggingT here: https://hackage.haskell.org/package/monad-logger-0.3.29/docs/src/Control.Monad.Logger.html#runFileLoggingT
07:34:12 <Taneb> And you can't do different things for different types, either
07:34:43 <max3> Taneb, mapping over compositions isn't needed for the proof?
07:35:50 <Taneb> max3: I don't think so
07:35:57 <dminuoso> infinisil: Ah I misread it. So writing your own runFileOrStderrLoggingT seems easy enough, no?
07:36:07 --- mode: glguy set +v Boarders
07:36:23 --- mode: glguy set -v Boarders
07:36:34 <infinisil> dminuoso: As said, to get the same behaviour as running runFileLoggingT combined with runStderrLoggingT I need to copy a whole lotta code from monad-logger
07:37:19 <infinisil> Sure it can work, but I'd rather not have duplicated code
07:37:38 <infinisil> The library is not compositional at all in that regard
07:39:48 <infinisil> I already had to write my own components for asynchronous logging with channels (and couldn't use the ones from monad-logger), and now this
07:41:32 <Putonlalla> Time to create `monad-loggerer`, infinisil?
07:42:17 <infinisil> I should probably evaluate other logging packages first before writing my own
07:42:54 <infinisil> But I've checked out a few and never found good async logging
07:43:28 <phadej> one way is to write your own logging lib, dogfood it, and then check if the "grown up" design is something existing
07:44:00 <phadej> e.g. you might think there isn't one, but it might be that after some maturing, you'll end up with something existing
07:44:22 <phadej> and if your think isn't anything existing, then you can release it to others :)
07:45:18 <dminuoso> Ah, MonadBaseControl again :(
07:46:03 <Boarders> does anyone know why mono-traversable doesn't have a notion of mono-indexable, is it just not very useful as a concept?
07:46:23 <infinisil> phadej: Seems easier to just give the other libraries a go and use them thoroughly. If it solved my problem I don't need my own
07:46:49 <phadej> infinisil: well, if it feels that none of libraries solve the problem (or is tricky to use, or ...)
07:46:59 <infinisil> Ah yeah
07:47:25 <infinisil> Katip looks interesting, but it's a lot more complicated than monad-logger
07:47:29 <infinisil> ?hackage Katip
07:47:29 <lambdabot> http://hackage.haskell.org/package/Katip
07:48:01 <Cale> Boarders: I'm tempted to snark that if that were the criterion, you wouldn't see mono-traversable either
07:48:04 <dminuoso> infinisil: https://gist.github.com/dminuoso/11906256bd371d9c7e802c553a068607
07:48:06 <dminuoso> Something like this?
07:48:21 <cocreature> Cale: hah, I resisted making that comment but it was hard :)
07:48:48 <dminuoso> Oh well. There's that bit about defaultOutput not being exposed...
07:50:50 <dminuoso> infinisil: Though after that it's just defaultOutput and defaultLogStrBS which you'd copy, and they are kind of small.
07:51:04 <dminuoso> 15 lines of code is not too much to ask for to have a custom logger..
07:51:15 <Boarders> Cale: fair enough :)
07:51:46 <Boarders> What is the alternative to generic monomorphic container code? Is it something with lenses or do you just not want such code?
07:51:59 <cocreature> Boarders: the latter
07:52:26 <Cale> It's just relatively uncommon to ever need that
07:52:35 <cocreature> ofc you can up with cases where it might be nice to make such code polymorphic but it’s just so rare that I don’t bother
07:59:25 <infinisil> dminuoso: Hmm yeah, thanks, i might just use that
07:59:58 <Wizek> hello! Is it possible to see a graphviz visualization of a stack project's *module* dependency graph? 
08:00:28 <Wizek> I know of `stack dot` and `stack list-dependencies`, but AFAIR those are only for package level dependencies
08:01:50 <cocreature> Wizek: graphmod
08:02:15 <Wizek> And a related question: Does ghc/cabal/stack build an hs file if it is present in `hs-source-dirs` but not imported in main or one of its descendant imports?
08:02:45 <Wizek> cocreature: interesting, checking it out!
08:04:21 <Taneb> cocreature: neat, I was looking for something like that last week
08:05:26 * dminuoso gives cocreature the oddly G-shaped high five
08:05:41 <dminuoso> Would have responded first, but the trains wifidog kicked me out before I could press enter.
08:06:15 <cocreature> dminuoso: I’m having trouble picturing what a G-shaped high five looks like :)
08:07:29 <dminuoso> cocreature: https://i.imgur.com/NogYlHH.jpg ;-)
08:08:08 <dminuoso> Presuming you did what I did of course.
08:08:31 <cocreature> actually I didn’t. I’ve used graphmod myself before :)
08:08:41 <dminuoso> Oh neat. :)
08:15:15 <infinisil> dminuoso: oh also: i intended to filter the logs of stderr to only contain important messages but leave it unfiltered for the file
08:15:22 <mniip> hmm
08:15:23 <infinisil> Can't do that like this
08:15:55 <infinisil> A compositional logging framework should be able to handle that
08:19:41 <asheshambasta> How many Monad transformers stacked together is too much? 
08:20:20 <ski> infinitely many ?
08:20:29 <cocreature> over 9000
08:20:49 <asheshambasta> I need to pass a configuration and during some computations, maintain State across a series of steps. So I'm thinking ReaderT with StateT with ExceptT
08:20:57 <max3> something i have trouble with in haskell are the type errors that are like expected type, actual type, because it's not clear which part of my expression is causing the type error
08:20:58 * ski . o O ( ISO 9001 )
08:21:07 <asheshambasta> Is that acceptable practice or is that considered bad design?
08:21:30 <cocreature> asheshambasta: does all of that sit on top of IO?
08:21:36 <asheshambasta> cocreature: yeah
08:21:37 <max3> any suggestions on how to grapple with this?
08:21:38 <ski> max3 : it would be nice to have something like type error slicing, in GHC
08:22:27 <cocreature> asheshambasta: in that case, I would stuff your state in an IORef, think about whether you might want to use an exception instead of ExceptT and check if ReaderT is really making things easier than explicit parameter passing
08:22:37 <max3> ski, yes something like this http://www.macs.hw.ac.uk/ultra/skalpel/ would be fantastic
08:22:53 <max3> also like rust's type errors
08:23:12 <asheshambasta> cocreature: so, you're advising against stacking 3 monad transformers, right?
08:23:15 --- mode: glguy set +v skregas
08:23:43 <cocreature> asheshambasta: it depends, I’m a lot more open to transformer layers when they do not sit on top of IO
08:23:54 --- mode: glguy set -v skregas
08:23:56 <asheshambasta> cocreature: I'd like to have a read-only config., hence the ReaderT, I could've done with StateT instead with the config. being in a datatype.
08:24:20 <cocreature> you also get a read-only config if you pass it explicitely as a parameter
08:24:39 <tdammers> ...which, incidentally, is pretty much exactly the reader monad ;)
08:24:43 * ski . o O ( implicit parameters )
08:24:56 <asheshambasta> cocreature, tdammers: good point
08:25:00 <cocreature> tdammers: well, except for the “explicit” part
08:26:05 <asheshambasta> cocreature: but any reason why you'd prefer the explicit passing over 3 monad transformers?
08:26:11 <tdammers> cocreature: yes, sure - personally, if I'm going to write heavily pseudo-imperative code, and the readonly context needs to be passed deep into a call hierarchy without being used in most layers, then I'd prefer the ReaderT solution, OTOH the explicit passing encourages following a "minimum knowledge" design
08:26:35 <mniip> 10/16/2018 [18:19:18] <asheshambasta> How many Monad transformers stacked together is too much? 
08:26:39 <mniip> I guess,
08:27:06 <mniip> newtype FixT t a = FixT (t (FixT t) a)
08:27:07 <cocreature> tdammers: sure I’m definitely not saying ReaderT is always wrong! my initial statement was “check if ReaderT is really making things easier than explicit parameter passing”. I find that people sometimes tend to switch to ReaderT even if it actually doesn’t buy them anything
08:28:33 <tdammers> ah yes, exactly
08:29:08 <tdammers> a less obvious downside is that once you have ReaderT MyAppContext in place, it's tempting to just stuff everything in MyAppContext and pass it around wholesale
08:29:20 <asheshambasta> cocreature: the other option could be to have StateT computations within my ReaderT ExceptT stack - without the need for stacking it up.
08:29:26 <cocreature> asheshambasta: 1. if you’re on top of IO, you are fairly likely to eventually run into MonadBaseControl-style problems which is pretty hard to reason about if your stack is anything else than ReaderT. 2. explicit passing vs ReaderT has the advantage that it is very easy to see which parts depend on what as opposed to a ReaderT that will probably end up passing the config to things that don’t need it. 3.
08:29:28 <cocreature> I find that I often want to eventually share my state between multiple threads and then StateT doesn’t help
08:30:16 <cocreature> none of those are hard criteria. there are cases where such a stack might make sense but they are at least worth thinking about
08:30:22 <quicksilver> I find that if I really want ReaderT then what I actually want is MonadReader foo and HasFoo bar etc etc
08:30:27 <asheshambasta> cocreature: interesting
08:31:03 <asheshambasta> mniip: woah, now that's one hell of an onion.
08:31:34 <fresheyeball> hey out there
08:31:45 <fresheyeball> is there a way to customize the html served by jsaddle-warp?
08:33:24 * ski used an unboundedly deep stack
08:33:40 <ski> (of `ContT's)
08:40:14 <patrl> Hi all. I've been trying to define overloaded function application via a type class, but I haven't been able to succeed and I can't figure out why
08:40:32 <patrl> Here is my attempt: https://0bin.net/paste/AWsXAESq5Bxc9AVw#vgUIFobVwlk2FPHfPJekfstidcvsUmL3lJ44QIdkPmP
08:40:51 <patrl> I was wondering if someone smarter than me can tell me (a) why this doesn't work, and (b) whether or not it's even possible
08:41:24 <patrl> the goal is a function `apply` that is interpreted as either forwards or backwards function application, depending on the types of the arguments
08:41:38 <Cale> patrl: Did you read the error?
08:42:05 <patrl> yes, but I'm quite new to haskell
08:42:14 <patrl> I've tried asking in #haskell-beginners, but they were stumped
08:42:31 <Cale> To turn on FlexibleContexts, add {-# LANGUAGE FlexibleContexts #-} to the top of your module
08:42:54 <patrl> of course I tried enabling the pragma mentioned in the error, but it makes no difference
08:44:14 <cocreature> at the very least it should change the error message
08:45:18 <Cale> Ah, right, it just becomes ambiguous
08:47:14 --- mode: shapr set -o shapr
08:47:48 <Cale> > apply ((+2) :: Int -> Int) (1 :: Int) :: Int
08:47:48 <Cale> 3
08:47:50 <lambdabot>  error:
08:47:51 <lambdabot>      Variable not in scope: apply :: (Int -> Int) -> Int -> Int
08:47:56 <Cale> If you fully annotate the thing, it'll work
08:48:15 <Cale> Of course, this class isn't terribly useful, for that reason
08:48:49 <patrl> right, it's not for an actual program, but an exercise to try to understand the limits of overloading
08:48:53 <Cale> These instances are a bit too polymorphic to really help pin things down, and there's no functional dependency to help out either
08:49:48 <patrl> Cale: great, you're right this works with type annotations
08:49:54 <the_2nd> lpaste down?
08:50:08 <patrl> I still don't understand why Haskell's type inferencing can't figure out what the type should be
08:50:36 <patrl> is there a better way to achieve overloaded application?
08:51:25 <Cale> If you :t the expression you were trying, you can see perhaps more clearly what it's stuck on
08:51:28 <cocreature> the_2nd: lpaste has been fairly unreliable these past few months. there is a reason the topic now links to github gists instead of lpaste :)
08:51:44 <Cale> There's a constraint (A (a -> a) (t1 -> t2), Num a, Num t1)
08:51:55 <Cale> and it still can't decide which instance it ought to use
08:52:06 <Cale> It really could be either one
08:52:32 <patrl> ah, yeah OK I see the issue
08:52:36 <Cale> because it's not going to rely on the fact that there *isn't* an instance of Num for function types
08:53:39 <Cale> (There could be, if you add one.)
08:53:44 <patrl> right
08:53:59 <patrl> I guess this is the kind of thing that is *supposed* to be difficult to define
08:57:11 <bsima> is there a way to get cabal or stack to use my git tags as the version number when compiling my package?
08:57:51 <the_2nd> I want to use the guard syntax within a monad, is that possible? : https://pastebin.com/XJD5UF31
08:58:07 <the_2nd> *out => outer
08:58:45 <the_2nd> so instead of guarding on bool, I now want to guard on m Bool
09:02:16 <cocreature> the_2nd: no that’s not possible
09:03:05 <p0lyph3m> x <- m Bool ; guard x ???
09:03:32 <the_2nd> then it would stop on first, instead of returning last?
09:04:08 <the_2nd> I have multiple m Bool checks, and a default case that will be returned if all were pure but false
09:04:16 <the_2nd> hm
09:04:46 <cocreature> depending on your checks it might be reasonable to execute all of them and then use a regular if that branches over the results you get back
09:05:34 <cocreature> if not, you could probably throw something together using MaybeT IO and asum
09:05:44 <the_2nd> what's a regular?
09:06:06 <the_2nd> I guess a list of all checks could work
09:06:11 <cocreature> just a standard if clause
09:06:14 <pikajude> regular if
09:06:16 <pikajude> lol
09:06:20 <pikajude> not "regular, if"
09:06:26 <the_2nd> :D
09:07:21 <pikajude> you could also use async if you want to execute them all at the sam etime
09:08:10 <p0lyph3m> x <- fmap and $ sequence [m Bool] ; guard x ; return "otherwise"
09:15:44 <Synthetica> Does this sort of morphism have a name? https://gist.github.com/Synthetica9/2fd591cd4560eed189206e19c8ae3259
09:25:37 <Weste> https://ghc.haskell.org/trac/ghc/roadmap does not list 8.6.1 anymore but https://ghc.haskell.org/trac/ghc/milestone/8.6.1 shows that there are 98 open issues. Are those 98 automatically part of fixes for 8.8.1?
09:39:42 <c_wraith> Weste, well, 8.6.1 was released. and found to have a couple serious bugs. lots of current work is on getting 8.6.2 ready.
09:41:32 <texasmynsted> I checked my ~/.hlint.yaml but I do not see anything for eta reduction. It seems like hlint used to suggest eta reductions but it does not seem to for me any more.
09:41:52 <texasmynsted> anybody know of a setting for this?
09:42:01 <the_2nd> if there's a monadic function using monad fail
09:42:14 <the_2nd> what decides e.g. what my Left of Either can be?
09:42:34 <the_2nd> I assume String just becomes the fail message?
09:42:57 <c_wraith> the_2nd, you are restricted by the Monad instance.
09:43:23 <c_wraith> the_2nd, it starts "instance Monad (Either a) where..."
09:43:24 <the_2nd> so is MonadFail not implemented for all Either?
09:44:57 <c_wraith> the_2nd, it's not implemented for Either at all...
09:45:12 <c_wraith> the_2nd, https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-Fail.html#t:MonadFail
09:47:48 <c_wraith> the_2nd, this is a side effect of making fail more principled. a lot of monads don't have a sensible implementation of fail, so they no longer will need to fake it when MonadFail desugaring becomes the default.
09:48:56 <lyxia> the_2nd: fail for Either used to be error
09:50:01 <the_2nd> thanks for the info
09:51:07 <the_2nd> If I have a list of e.g. [Maybe a] I can use sequence to get Maybe [a]
09:51:25 <c_wraith> yes, but it may not be exactly what you want
09:51:36 <the_2nd> I now have [(Maybe a, b)] any way to get the Maybe out of the tuple?
09:51:45 <c_wraith> it will return Nothing if *any* element in the list was Nothing.
09:51:49 <the_2nd> so finally I have Maybe [(a, b)] ?
09:52:11 <pikajude> there's a library for that already though
09:52:12 <c_wraith> you can certainly pull the maybe outside the tuple.
09:52:15 <pikajude> strong functors, or something?
09:52:48 <c_wraith> pikajude, it's more of a theoretical thing than a practical library.
09:53:09 <lyxia> the_2nd: you can compose sequence and Data.Bitraversable.bitraverse
09:53:10 <the_2nd> then I'll just implement the function myself
09:53:14 <pikajude> sure
09:53:18 <pikajude> but there's a name for it already, is what i'm saying
09:53:36 <pikajude> :t \ (a, b) -> (, b) <$> a
09:53:37 <lambdabot> Functor f => (f t1, t2) -> f (t1, t2)
09:53:40 <c_wraith> ah, yes. it is a strength operation.
09:54:03 <lyxia> Synthetica: doesn't look like anything to me. does it have any interesting properties?
09:54:15 <c_wraith> in Haskell, all instances of Functor are strong, so it's not a huge deal.
09:54:50 <pikajude> indeed
09:54:56 <pikajude> i'm not sure what it would take for an instance of functor not to be strtong
09:55:26 <p0lyph3m> thr
09:55:28 <Synthetica> lyxia: Well, it allows me to define a catamorphism without specifying all the "boring parts" (eg. `alg (Foo bar baz) = bar + baz`, for example)  
09:55:30 <p0lyph3m> the 
09:55:56 <c_wraith> pikajude, it needs to be a functor in some different category
09:56:01 <p0lyph3m> the_2nd: catMaybe :: [Maybe a] - [a]
09:56:08 <p0lyph3m> the_2nd: catMaybe :: [Maybe a] -> [a]
09:56:20 <pikajude> ah okay
09:57:24 <the_2nd> p0lyph3m, I need to fail on first Maybe, tho
09:57:40 <the_2nd> I just defined a helper myself
09:58:03 <c_wraith> :t bitraverse id pure
09:58:05 <lambdabot> error:
09:58:05 <lambdabot>     • Variable not in scope:
09:58:05 <lambdabot>         bitraverse :: (a0 -> a0) -> (a1 -> f0 a1) -> t
09:58:52 <pikajude> :t tritraverse
09:58:53 <lambdabot> error:
09:58:54 <lambdabot>     • Variable not in scope: tritraverse
09:58:54 <lambdabot>     • Perhaps you meant one of these:
09:58:55 <pikajude> bah
09:59:13 <c_wraith> @let import Data.Bitraversable
09:59:14 <lambdabot>  Defined.
09:59:22 <c_wraith> :t bitraverse id pure
09:59:24 <lambdabot> (Applicative f, Bitraversable t) => t (f c) d -> f (t c d)
09:59:27 <Synthetica> lyxia: For example, I can check if a variable is referenced in some AST with the following: https://gist.github.com/Synthetica9/c4158b342fffe578f1322edf34f1d9d0
09:59:39 <c_wraith> looks right to me!
09:59:48 <Synthetica> Note that I don't have to specify all AST nodes, only the interesting ones
10:00:10 <lyxia> Synthetica: that looks similar to a fold (in the Foldable sense, not cata) for (Free f).
10:01:17 <Synthetica> lyxia: Could you give an example how to write this with `Free`?
10:01:50 <lyxia> Synthetica: sure
10:04:13 <c_wraith> :t traverse (bitraverse id pure) -- the_2nd if you want to be cute...
10:04:14 <lambdabot> (Bitraversable t2, Applicative f, Traversable t1) => t1 (t2 (f c) d) -> f (t1 (t2 c d))
10:09:48 <benzrf> :t rtraverse
10:09:50 <lambdabot> error:
10:09:50 <lambdabot>     • Variable not in scope: rtraverse
10:09:50 <lambdabot>     • Perhaps you meant one of these:
10:09:52 <benzrf> aw
10:14:17 <Hijiri> Would quickcheck generators be a good way to define random generators for syntax trees?
10:14:19 <Hijiri> or maybe there is a more specialized package that would be quicker to do it in
10:15:38 <lyxia> Synthetica: https://gist.github.com/Lysxia/93a17923663faa0d28e89ab7d7a11425
10:16:06 <Hijiri> this grammar would be a little bit context sensitive, I want variable assignments to only refer to variables in scope
10:17:23 <c_wraith> it's easy to accidentally create *huge* trees with Arbitrary instances. like thousands of nodes deep with high branching factors.
10:18:07 <c_wraith> something creating random syntax trees should be aware of that danger and provide mechanisms to counteract that tendency
10:18:23 <c_wraith> but I don't know of anything that does that offhand.
10:18:39 <lyxia> generic-random does
10:20:20 <int-e> :t arbitrary
10:20:22 <lambdabot> Arbitrary a => Gen a
10:21:03 <Hijiri> lyxia: awesome, looks like I just need to write the ADT
10:21:12 <lyxia> Hijiri: that won't handle scope though
10:21:17 <cocreature> if you want to write it yourself, take a look at http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
10:21:20 <Hijiri> oh yeah
10:21:25 <cocreature> that explains how you can limit depth
10:21:38 <Hijiri> I could give it placeholders and fill them in afterwards
10:22:19 <lyxia> it's not hard to limit the depth in a handwritten Gen
10:22:25 <Hijiri> It looks like the generic-random package has generators which limit size
10:22:29 <Hijiri> so I will probably just use that
10:23:10 <int-e> cocreature: there's even a comment on this in the haddock for arbitrary: "The QuickCheck manual goes into detail on how to write good generators. Make sure to look at it, especially if your type is recursive!"
10:24:00 <cocreature> int-e: that doesn’t meant hat people actually read that comment :)
10:24:36 * ski . o O ( there ought to be a comment telling people to read that comment .. and itself, for good measure )
10:25:23 <pikajude> -- please read the above comment
10:25:24 <int-e> cocreature: some do, apparently!
10:27:49 <int-e> ski: we should just make RTFM part of all 5th graders' curriculum.
10:28:22 <the_2nd> I'm still working on the regex problem (worked fine so far). Currently matching via =~ will throw if the regexp itself is invalid
10:28:31 <the_2nd> how can I validate a regexp beforehand?
10:28:58 <the_2nd> I tried using =~~ and e.g. return Maybe Bool
10:29:12 <the_2nd> but then not matching already returns Nothing, instead of Just False
10:32:21 <Hijiri> what happens if someone improves some software used in a publication but doesn't publish anything based on the improvements (maybe they are incremental and don't need their own paper)
10:32:29 <Hijiri> should new papers compare against the pblished version?
10:32:37 <Hijiri> Or the improved version sitting in a github repo?
10:33:12 <Hijiri> Both is an option, I guess
10:34:29 <cocreature> Hijiri: I’d say they should benchmark against the improved version
10:39:17 --- mode: glguy set +v stilbruch
10:39:31 --- mode: glguy set -v stilbruch
10:39:41 <stilbruch> Wot
10:40:05 * ski blinks
10:40:29 <awal> lyxia: Hm, possible
10:45:32 --- mode: glguy set +v emmanuel_erc
10:47:05 --- mode: glguy set -v emmanuel_erc
10:48:26 <Synthetica> lyxia: Thanks, I'll have a look at it
10:48:35 <emmanuel_erc> Does anyone here use haskell-mode in emacs? Have you ever experienced serious input lag whilst writing Haskell Code?
10:49:15 <max3> this is a weird off-topic question but i think someone in here must know the answer: how do you retrieval for a hash table with collision resolution strategies? like if the hash table uses chaining for collision resolution and you want to retrieve that value at a key that's experienced collisions prior to retrieval what does the hash table return?
10:51:39 <cocreature> max3: the value associated with the key?
10:51:45 <cocreature> not sure I understand the question
10:51:54 <max3> cocreature, if there have been collisions then there's, for example, a chain of values associated with the key
10:52:07 <cocreature> max3: no there is a chain of values associated with the hash of the key
10:52:14 <cocreature> you then do a linear search through those to find the right key
10:52:23 <max3> ah
10:52:25 <max3> right
10:53:00 <max3> cocreature, thanks
11:11:46 <Boarders> Is it the intended behaviour that the order you have language extensions effects whether they are turned on or off
11:12:21 <Boarders> e.g. putting {-# LANGUAGE TypeFamilies #-} after {-# LANGUAGE NoMonoLocalBinds #-} turns mono local binds back on
11:12:34 <Boarders> (this arrangement by alphabetical order was done after by stylish-haskell
11:16:16 <max3> i don't understand this definition that makes [] an instance of monad: xs >>= f = [y | x <- xs, y <- f x]
11:16:23 <max3> isn't it circular? isn't <- defined interms of >>=
11:17:55 <mnoonan> Boarders: that sounds like a bug (but I don't envy the stylish-haskell maintainers having to work out which language extensions imply what)
11:17:58 <ski> @undo [y | x <- xs, y <- f x]
11:17:59 <lambdabot> concatMap (\ x -> concatMap (\ y -> [y]) (f x)) xs
11:18:10 <max3> weird
11:18:19 <ski> @src [] (>>=)
11:18:19 <lambdabot> xs >>= f = concatMap f xs
11:18:30 <max3> ski, btw is there a way to desugar in ghci?
11:18:46 <ski> iirc, there's a way to get lambdabot in GHCi
11:18:53 <ski> never tried to, myself
11:19:07 <mnoonan> Boarders: it looks like stylish-haskell will respect your grouping if you put an empty line in between, though
11:19:17 <max3> interesting
11:19:21 <mnoonan> similar to import statement groups
11:19:44 <Boarders> mnoonan: Thank you!
11:31:27 <disconsis> @pl x +++ y = Append ((tag x) <> (tag y)) x y
11:31:27 <lambdabot> (line 1, column 10):
11:31:27 <lambdabot> unexpected " "
11:31:27 <lambdabot> expecting operator
11:31:53 <disconsis> \x y -> Append ((tag x) <> (tag y)) x y
11:32:00 <disconsis> @pl \x y -> Append ((tag x) <> (tag y)) x y
11:32:00 <lambdabot> join . (flip =<< (Append .) . (. tag) . (<>) . tag)
11:32:17 <ski> tag soup
11:32:21 <lavalike> clear as day
11:32:36 <disconsis> XD
11:34:32 <disconsis> btw I've been using this channel exclusively for the @pl's
11:34:35 <disconsis> XP
11:34:43 <disconsis> is there a way I can set it up on my local machine?
11:36:27 <lyxia> disconsis: you can PM lambdabot
11:37:00 <lyxia> disconsis: the source is online but I have no idea how much trouble it is to set up
11:37:07 <ski> disconsis : i find that it's usually nicer to pointless code yourself, than use what the lambdabot command gives
11:38:43 <disconsis> lyxia: mostly need it for when offline, so PMing isn't an option
11:39:07 <disconsis> ski: true. most every time i use @pl is when I *know* the output's gonna be something crazy
11:41:14 <lyxia> There's a library that provides the pl functionality, that's probably easier to install than lambdabot
11:42:23 <lyxia> https://hackage.haskell.org/package/pointfree actually it's just an executable not a library but still
11:42:45 <disconsis> hey nice. thanks!
11:44:06 <cocreature> disconsis: fwiw you can talk to lambdabot in a private query which might be preferable to spamming the channel :)
11:44:21 <disconsis> aah
11:44:57 <disconsis> but then my only line of communication with #haskell will be cut off ;P
11:46:07 <cocreature> that might be a good reason to start being a bit more diverse in your communication here :)
11:49:45 <disconsis> cocreature: started learning haskell a few weeks ago. lurked on here for a few days, didn't understand anything XD
11:52:38 <cocreature> disconsis: asking questions is what this channel is for so just ask about the things you’re having trouble with
11:55:49 --- mode: glguy set +v stilbruch
11:56:01 --- mode: glguy set -v stilbruch
12:05:03 <disconsis> i have to reach a certain level of proficiency before i can figure out what to ask
12:05:54 <ski> asking is one of the main ways in which you can learn
12:05:57 <isBEKaml> Or ask anyway, and you can grow proficient quicker?
12:06:12 <tdammers> indeed, it's never too early to ask questions
12:06:34 <disconsis> well, there *are* stupid questions
12:06:40 <tdammers> such as?
12:07:05 <disconsis> how to do X, when there's articles on the haskell wiki on exactly that
12:07:12 * ski . o O ( "There are no stupid questions, just stupid people." )
12:07:31 <isBEKaml> They are lazy questions. Not stupid
12:07:42 <tdammers> if you ask how to do X, and there's an article on the haskell wiki explaining it in great detail, then people will just tell you to go look there
12:08:17 <disconsis> isBEKaml: that's a nice angle
12:09:40 <davean> "How do I do Y, using X, and how do I do X?" when X and Y are deeply unrelated?
12:11:23 <disconsis> davean: okay yeah, those sort of questions are a good match for this place
12:11:47 <tdammers> davean: still not a stupid question - maybe not the best way to ask, but it hints at an underlying misundestanding which would have gone unnoticed if you hadn't asked the question
12:14:28 <Rembane> I have quite some proficiency in giving stupid answers.
12:15:04 <isBEKaml> Useless answers?
12:15:21 <isBEKaml> 10,99Rembane99,99: ^
12:16:46 <Rembane> isBEKaml: Nah, slightly misdirecting usually. 
12:20:44 <monochrom> And then people forgot there was so a thing as "help vampire".
12:20:49 <monochrom> s/so/such/
12:21:50 <Rembane> monochrom: A person that sucks up all help? Like a very specific black hole?
12:22:12 <isBEKaml> Eats all your time and your grace
12:23:52 <monochrom> https://meta.stackoverflow.com/questions/258206/what-is-a-help-vampire
12:24:27 <Rembane> Oh. Dang. 
12:24:32 <cocreature> does asking about help vampires make you a help vampire?
12:24:48 <ski> if you have to ask ..
12:25:18 <Rembane>  ... you are a fight club?
12:25:55 <ski> perhaps :)
12:28:02 <monochrom> It is actually healthy to think "I won't ask this question since I can go to wiki or google".  Note that this "ask" just means "ask in public".  This does not preclude asking oneself and taking self-study actions to investigate.
12:29:26 <monochrom> Indepdent study skills are the most important learning skills.  High-frequency chatting is not learning.
12:30:13 <Rembane> Rubber ducks are really good tools.
12:36:41 <__monty__> monochrom: Would you say this applies more to questions of a practical nature, i.e. the typical SO java questions? Monads for example are hard to understand just by reflecting on the types. Gentle nudges along the way can open up whole new opportunities for expanding your horizon.
12:38:15 <Ariakenom> right high-frequency chatting can surely be great for learning. Not "What's the name of the function of type T gain" ofc
12:42:29 <Rembane> One of my favourites is when someone wants monads explained and seven people gives explanations in parallell.
12:52:07 <[exa]> is there a cabal option to set sandbox path for run/exec etc. ?
12:52:24 <[exa]> there's --sandbox but that appears to only work with cabal sandbox subcommands
12:54:45 <[exa]> oh, CABAL_SANDBOX_CONFIG, good.
12:55:41 <[exa]> but it seems that it didn't solve the original issue... is there any reason why hindent would tell me that $HOME/.cabal: openFile: inappropriate type (is a directory) and fail~?
13:00:14 <monochrom> __monty__, Ariakenom: "due diligence" is the key.  Asking --- scratch that, any discussion after due dilegence is fine.
13:02:35 <brisbin> my team just discovered that we weren't seeng correct re-compilation when a file included via a Q expression using qAddDependentFile was changed. we fixed it by adding said files to extra-source-files. i don't remember ever having to do that before, and the docs for extra-source-files and qAddDependentFile don't talk about this requirement. we're happy to have figured it out, but i'm still uneasy about not
13:02:36 <brisbin> knowing why/how/when this became the case. does anyone happen to know the details?
13:03:42 <cocreature> brisbin: how are you building?
13:04:02 <brisbin> cocreature: stack build, and we use hpack too
13:04:28 <cocreature> hm, I thought stack handled that correctly. I know cabal new-build definitely doesn’t handle it properly
13:05:43 <cocreature> brisbin: are you on the most recent stack release?
13:06:01 <brisbin> i'm on 1.7.1
13:06:19 <cocreature> in that case I would open an issue
13:06:37 <brisbin> so you expect it to work without having to add things to extra-source-files?
13:06:50 <cocreature> yes
13:13:14 <brisbin> cocreature: thanks for the info. glad i'm not crazy that it worked before without that too :)
13:19:32 <max3> can you use where in a lambda (rather than let)?
13:20:25 <Rembane> :t \a -> b * 2 where b = a + 3
13:20:27 <lambdabot> error: parse error on input ‘where’
13:20:33 <Rembane> Hm...
13:20:44 <__monty__> max3: Afaik no. It's part of the equation syntax.
13:21:08 <max3> well that's unfortunate
13:21:36 <__monty__> Why exactly?
13:21:48 <dolio> let is the expression version of where.
13:22:20 <max3> fmap g st = S (\s -> let (x,s’) = app st s in (g x, s’)) 
13:22:23 <max3> doesn't read clearly to me
13:23:12 <Tuplanolla> You need to write more OCaml, max3.
13:23:34 <max3> why? how is that expressed in ocaml? also i tried but i couldn't get opam to cooperate 
13:23:49 <Tuplanolla> There's so much `let`.
13:24:30 <Rembane> :t lmap
13:24:31 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
13:24:34 * ski . o O ( `app (fmap g st) s = (g x,s’) where (x,s’) = app st s' )
13:25:04 <__monty__> max3: If it's not clear, maybe you shouldn't be defining it as a lambda in the first place?
13:25:09 <dolio> Yeah, that's the real answer. You need to write more Agda.
13:25:43 <Rembane> max3: Try first from Data.Bifunctor.
13:25:46 * ski . o O ( `fmap g st = S st’ where st’ s = (g x,s’) where (x,s’) = app st s' )
13:26:20 <shapr> disconsis: I agree, I'm learning FPGA stuff, and I asked a few no-context questions a month so I could spend sufficient time with google to have the context to ask good questions
13:26:51 <Rembane> max3: \s -> first g (app st s)
13:27:02 <Rembane> max3: Or even: first g . app st 
13:27:37 <__monty__> max3: Yes, I like Rembane's suggestion. Often there's already combinators out there that can clearly express what you're trying to do. Hoogle would've helped you find less general versions of `first`.
13:29:17 <Rembane> __monty__: Hoogle only gave me swap. What to search on on Hoogle to get useful suggestions?
13:29:25 <ski> there's something to be said for doing it from the ground up, though
13:30:12 <__monty__> Rembane: This query `(a,b) -> (a -> c) -> (c, b)` suggested onLeft and a bunch of mapFst's.
13:30:27 <__monty__> I like the more generalness of first though.
13:30:37 <geekosaur> make sure your'e both using the same hoogle. having oen with a recent db and one with workingtype search is kindaq painful
13:30:44 <Rembane> __monty__: Nice! Thank you! 
13:31:11 <Rembane> This one gave nice answers: https://www.haskell.org/hoogle/?hoogle=%28a%2Cb%29+-%3E+%28a+-%3E+c%29+-%3E+%28c%2C+b%29
13:31:54 <Rembane> Oh well, Control.Arrow are the nicest.
13:32:14 <Rembane> Way too much Agda here: https://hoogle.haskell.org/?hoogle=%28a%2Cb%29+-%3E+%28a+-%3E+c%29+-%3E+%28c%2C+b%29&scope=set%3Astackage
13:34:16 <__monty__> Wait, why didn't I get the former rather than the latter results? Does haskell.org/hoogle search stackage by default?
13:35:47 <geekosaur> default is an older version of the libs that ship with ghc only, for haskell.org/hoogle
13:36:27 <Rembane>  /hoogle is better with types afaik
13:36:46 <geekosaur> suppose you missed the pont of my earlier remark: hoogle.haskell.org is not just another name for haskell.org/hoogle. it searches more things, but its type search is broken
13:37:25 <geekosaur> (those are related, the older one's database facilitates type search but can't handle large databases)
13:38:23 <Tuplanolla> How long do you expect this situation to stand?
13:40:05 <Rembane> geekosaur: The word workingtype didn't make sense so I dropped it. Sorry. Thank you for clarifying. :)
13:40:34 <geekosaur> until someone does something about it. it's been over a year :/
13:41:07 <geekosaur> I gather ndm has no free time and nobody else has stepped up; the hoogle 5 readme is almost begging for help
14:12:00 <__monty__> When hoogle says something's in Util you can't access that from code outside of ghc, right?
14:12:15 <mniip> you have to enable the ghc package
14:12:32 <mniip> % import Util
14:12:33 <yahb> mniip: ; <no location info>: error:; Could not load module `Util'; It is a member of the hidden package `ghc-8.6.0.20180620'.; You can run `:set -package ghc' to expose it.; (Note: this unloads all the modules in the current scope.)
14:12:36 <mniip> % :set -package ghc
14:12:36 <yahb> mniip: package flags have changed, resetting and loading new packages...
14:12:38 <mniip> % import Util
14:12:38 <yahb> mniip: 
14:13:11 <mniip> not generally a good idea though unless you're depending on the compiler in more ways than just Util
14:14:10 <__monty__> Depending on it will make code depend on all of ghc?
14:17:21 <mniip> yes
14:17:38 <mniip> what is it that you want from Util?
14:18:54 <__monty__> Was just playing around with the query from before with my local hoogle. Realized it wasn't turning up useful results because it has a small database though.
14:22:01 <geekosaur> yes, Util is a part of ghc-api
14:22:32 <geekosaur> it's rather unfortunately named, but that's partof why ghc-api is a hidden module
14:23:11 <geekosaur> nobody had really thought through ghc's internals with respect to publishing an API
14:30:15 <max3> is there anyway to write this newtype ST a = S (State -> (a,State)) without the dummy constructor if i want to make ST an instantiation of some type class?
14:36:09 <mniip> max3, no, that would drive typechecking/type inference crazy
14:36:15 <max3> lol
14:37:42 <mniip> when unifying  f Int ~ State -> (a, State)
14:37:53 <mniip> there's no reasonable (decidable) way to infer  f ~ ST, a ~ Int
14:38:36 <mniip> or in fact, when unifying  f x ~ State -> (a, State)
14:39:02 <mniip> {f ~ ST, x ~ A} and {f ~ (->) State, x ~ (a, State)}
14:39:04 <mniip> are two right answers
14:39:15 <mniip> no most general unifier, no good
14:41:43 <max3> one sec i'll post a code snippet and ask a question
14:42:27 <max3> is s' necessarily equal to s here https://paste.rs/Fsu.hs
14:42:34 <max3> in <*> for ST
14:47:50 <lyxia> let fInSt = S (\s -> (id, s + 1))   -- no s is not equal to s' (s + 1 = s')
14:49:25 <max3> ah i guess i just imagined that fInSt = pure f
14:49:31 <max3> for some f
14:49:52 <max3> but in general i understand it needn't be
15:10:56 <MarcelineVQ> Does anyone know if there is a video somewhere that goes along with Domain Specific Languages past, present and future - HiperFit  http://hiperfit.dk/pdf/HIPERFIT-2-sheeran.pdf ?      tag: Athas
15:25:43 --- mode: glguy set +v onebyy
15:29:12 <onebyy> hi in what scenerios Haskell will be best language to use for ?
15:29:34 <onebyy> a friend of me asked when I say him I am learning haskell
15:29:44 <onebyy> canI know please?
15:29:50 <boj> onebyy: it is a general purpose language
15:30:02 <c_wraith> 1) you have freedom to choose the language and buy-in from the team. 2) the performance overhead of garbage collection is acceptable.
15:30:26 <mniip> acceptable for some things
15:30:26 <c_wraith> that's it. if you have those two things, haskell is a good choice.
15:30:46 <mniip> ah er didn't realize the mode of the sentence there
15:30:52 <onebyy> I did not understand 1 
15:31:19 <c_wraith> it's a social consideration
15:31:43 <lavalike> 1. "if you can" 2. "if your computer can"
15:32:01 <c_wraith> Haskell is different, unlike most languages. you need to be working with a team that isn't afraid of different things.
15:33:28 <dstolfa> c_wraith: heh, try convincing people to write standard ML in 2018. haskell is a breeze to convince people to use
15:34:40 <davean> dstolfa: whats so hard about standard ML?
15:34:48 <davean> I never had an issue with it
15:35:16 <c_wraith> honestly, it's probably easier to get people to use. they don't need to learn laziness.
15:35:16 <dstolfa> davean: it's not that the language is bad, it's really good actually. it has formal semantics and is quite fast. it's shattering the barrier of it being a `niche' language with `no users'
15:35:25 <dstolfa> and it has like 10 compilers
15:35:29 <dstolfa> out of which only 2 make real sense to use
15:35:35 <c_wraith> it has Bob Harper!
15:35:35 <dstolfa> and moreover, are different from eachother
15:36:14 <dstolfa> "does it have a library for X"? -- probably not
15:36:22 <dstolfa> but you can make it!
15:37:47 * dstolfa is currently working on a codebase that is a serious melting pot of languages. HOL4, Isabelle, Haskell, OCaml, SML and C
15:38:01 <lavalike> dstolfa: what does it do?
15:38:08 <dstolfa> lavalike: formal semantics-y things
15:38:17 <c_wraith> HOL and Isabelle? that's some serious proving.
15:38:33 <lavalike> dstolfa: what does *that* do?
15:40:04 <dstolfa> lavalike: well, the tooling mix of tools all together is supposed to allow you to explore all allowable behaviours of any program, automatically generate VCs to prove in HOL4 from CSL annotations, fuzz the implementation for user-specified edge cases without guessing and check adherence to the specification (no proof of refinement as the software still changes quite often)
15:41:14 <dstolfa> and in reality, proving refinement for a CPU without formal semantics of its ISA is hard. best we can do is guses what they are and hope we never trigger a trace that doesn't match up with the model
15:41:57 <boj> dstolfa: is that research or industry?
15:42:01 <c_wraith> and you really don't want to model all those speculative access timing issues, anyway. :)
15:42:05 <dstolfa> boj: research
15:42:10 <boj> interesting
15:42:16 <dstolfa> c_wraith: definitely not
15:42:28 <lavalike> I was about to ask who do you sell it to, broadly speaking
15:42:31 <dstolfa> c_wraith: at least not by guessing :-)
15:50:54 <Wizek> Does stack or cabal support lazy builds? i.e. only build modules that are actually imported directly or indirectly into main?
15:51:42 <orzo> i don't thin so
15:54:13 <Wizek> orzo: so if I were to have two executable build targets with a large common shared library section, would that be excessively be built for both? Even if one only uses a very small portion? Is my best bet manually tweezing the library code into separate `hs-source-dirs`? 
15:55:16 <lyxia> yes the whole library gets built
15:58:00 <Wizek> Unfortunate.
16:24:28 --- mode: glguy set +v jackdk
16:24:28 --- mode: glguy set -v jackdk
16:40:59 <tsaka__> is there a way to disable debug.trace output
16:41:51 <tsaka__> or are there logging libraries built on top of trace
16:42:01 <tsaka__> for debugging/development not monitoring
17:00:54 <c_wraith> tsaka__, the various Debug.Trace functions aren't really intended to be production-strength.
17:03:17 <c_wraith> tsaka__, among other things, compiler changes can cause output ordering changes. that's fine if you are using them interactively, but potentially bad if you build up tooling around their output.
17:04:45 <c_wraith> tsaka__, for real production-quality logging, you should use one of the real logging libraries
17:06:48 <tsaka__> c_wraith: I just need something practical for personal debugging where you don't always want the output
17:07:24 <tsaka__> I suppose I could just overload it and have a constant somewhere ...
17:12:17 <sm> tsaka__: http://hackage.haskell.org/package/hledger-lib-1.11/docs/Hledger-Utils-Debug.html are some helpers I use
17:13:10 <tsaka__> wonderful
17:21:29 <zachk> is there a cabal uninstall command?
17:22:15 <sclv> No
17:22:34 <sclv> There is a ghc-pkg unregister
17:27:52 <zachk> thank you
17:44:57 <mniip> p0lyph3m, thanks for reintroducing me to debug! working my way to bootstrap a programming environment from a clean install! http://tcp.st/q6g7.jpg
17:45:17 <mniip> ah er, this is not -offtopic
18:05:05 <Solonarv_> if the thing you want to uninstall is an executable, you can simply `rm` it afaik
18:05:51 <eschnett_> i just uploaded a package to hackage (http://hackage.haskell.org/package/mpi-hs). it fails to build since it requires an external library to be present. how can i set things up to make it work? i have a working CircleCI script if that helps...
18:10:24 <Solonarv_> if the issue is just that failure to build means there are no docs, you can manually upload them instead
18:12:46 <eschnett_> Solonarv: no, the issue is that an additional system library needs to be installed that's not present on the hackage build system.
19:07:11 --- mode: glguy set +v QQQQQ
19:27:55 <fiatjaf> does anyone know how to fix/override a subdependency on haskell in a nix expression?
19:28:30 <fiatjaf> 'rerebase' is dependencing on an incorrect version of 'rebase' in the default nix channel
19:33:46 <boj> fiatjaf: you can do something like  cabal update && cabal2nix cabal://rerebase > ./deps/rerebase.nix  and then load it in your default.nix, passing it where necessary
19:34:23 <boj> and then pray it has no out of sync sub-deps
19:35:00 <fiatjaf> but it isn't necessary anywhere in my default.nix
19:35:01 <boj> you can also cabal2nix github commits as well, if you need a particular version there
19:35:08 <fiatjaf> it is a sub-sub-dependency
19:35:22 <boj> in that case you will have to override it all the way down
19:35:32 <fiatjaf> that's what I'm trying to do
19:35:44 <fiatjaf> but I don't know how to
19:35:57 <fiatjaf> what is the different between pkgs.haskellPackages and pkgs.haskell.packages?
19:36:09 <boj> maybe look at gabriel's tutorial for some hints https://github.com/Gabriel439/haskell-nix
19:36:31 <fiatjaf> I've tried that, but doesn't seem to work
19:38:13 <boj> you would probably just override the sub-dependency with your new dep
19:38:43 <fiatjaf> the problem is that I'm using nix since yesterday and don't know how exactly to do that
19:39:01 <fiatjaf> apparently some people use an `override` function
19:39:13 <boj> yeah, it's not the easiest thing to get started with, and there are a million ways to do the same thing
19:39:13 <fiatjaf> others pass a `config.packageOverrides`
19:39:28 <fiatjaf> others `config = { packageOverrides = { ... } }`
19:39:38 <fiatjaf> boj, thank you for saying that :P
19:39:59 <boj> i have been using it in a production setting for 2 years now and i still get confused at times
19:40:38 <fiatjaf> but surely you can clarify to me the difference between haskellPackages and haskell.packages
19:41:24 <boj> i think haskellPackages is tied to whatever the default GHC is, and haskell.packages.${compiler} where compiler is like ghc843
19:41:59 <boj> so you can either use the default, or declare which compiler you want
19:42:17 <fiatjaf> so haskellPackages is the same as haskell.packages.${default compiler}?
19:42:34 <boj> i believe so
19:43:27 <fiatjaf> thank you very much
19:44:48 <boj> fiatjaf: this may be relevant https://github.com/NixOS/nixpkgs/issues/42022
19:45:39 <fiatjaf> boj, I've seen that too, and I've tried that
19:45:48 <boj> you would then do  self.rerebase = callPackage ./deps/rebase.nix { }; inside the body
19:45:51 <fiatjaf> and variants with haskellPackages instead of haskell.packages
19:46:51 <fiatjaf> let me see
19:47:11 <boj> i think that would be self.haskellPackages.callPackage actually
19:49:59 <fiatjaf> my override is ignored
19:50:14 <fiatjaf> I've tried self.rerebase = super.doesntmatteritwillbeignored;
19:50:18 <fiatjaf> and it is ignored
19:50:25 <fiatjaf> doesn't raise an error
19:50:48 <fiatjaf> I've tried using haskellPackages.extend instead of that tree of haskell . packages . ghc822 
19:52:12 <fiatjaf> self.haskellPackages.callPackage ./whocares.nix {}
19:52:15 <fiatjaf> is also ignored
19:52:32 <fiatjaf> https://nixos.org/nixos/nix-pills/nixpkgs-overriding-packages.html#idm140737315537456 this one doesn't work also
19:52:44 <fiatjaf> sorry for being so hopeless
19:52:51 <fiatjaf> and thank you very much for your help
19:53:12 <boj> no worries, it takes a little experimenting and issue diving to figure out
21:17:02 --- mode: glguy set +v govno
21:17:38 <govno> Whereis class and instanses `Monad Reader` in ghc?
21:24:56 <govno> class Monad m => MonadReader r m | m -> r where
21:25:10 <glguy> http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader
21:25:38 <govno> what mean r m | m -> r ?
21:26:13 <jackdk> functional dependency. the choice of `m` fixes `r`
21:28:10 <maerwald> it's just type inference
21:28:20 <jackdk> normally every parameter of a typeclass can vary independently. the functional dependency says that's no longer possible which helps type inference ^
21:32:46 <maerwald> stack seems quite slow with ghc updates given that there is a serious floating point arithmetic bug in 8.4.3
21:33:51 <govno> {-# LANGUAGE FunctionalDependencies #-}
21:34:04 <govno> this directive
21:43:48 <ski> govno : logically, `MonadReader r m | m -> r' means `forall m. unique r. MonadReader r m', iow for every `m', there can be at most one `r' with an instance `MonadReader r m'. expanding, it means `forall m r0 r1. (MonadReader r0 m,MonadReader r1 m) => r0 = r1', iow given two instances with the same `m', it must be the case that the `r's are also the same, can't be different
21:44:13 <ski> we say `m' functionally determines `r' in `MonadReader r m'
21:45:27 <ski> (if you know anything about the relational model in data base theory, there's something called a functional dependency of a relation there. it's basically the same concept as here, a relation corresponding to a type class)
21:47:15 <ski> as jackdk says, apart from expressing a constraint how what instances of the type class you can make, the practical effect of it is to reduce ambiguity in instance resolution
22:50:55 <dminuoso> What is then the meaning of something like this
22:50:59 <dminuoso> @let class Foo a | -> a
22:51:00 <lambdabot>  Defined.
22:51:34 <dminuoso> Is that some kind of `() -> a` dependency?
22:55:00 <cocreature> dminuoso: does this actually work? the user guide states “More generally, dependencies take the form x1 ... xn -> y1 ... ym, where x1, ..., xn, and y1, ..., yn are type variables with n>0 and m>=0” and it doesn’t look like n > 0 holds here
22:57:15 <dminuoso> @let class Bar a | -> a where numbify :: a -> Int
22:57:17 <lambdabot>  Defined.
22:57:24 <dminuoso> @let instance Bar Int where numbify = id
22:57:26 <lambdabot>  Defined.
22:57:35 <dminuoso> > numbify (5 :: Int)
22:57:37 <lambdabot>  5
22:57:38 <cocreature> @let instance Bar Bool where numbify = undefined
22:57:39 <lambdabot>  .L.hs:166:10: error:
22:57:39 <lambdabot>      Functional dependencies conflict between instance declarations:
22:57:39 <lambdabot>        instance [safe] Bar Int -- Defined at .L.hs:166:10
22:57:42 <cocreature> huh
22:57:45 <cocreature> that seems useless
22:58:05 <cocreature> and at the very least it is a documentation bug afaict
22:58:57 <dminuoso> cocreature: I guess semantically it's `() -> a` then?
22:59:27 <dminuoso> @let class Once | () -> a
22:59:28 <lambdabot>  Parse failed: Parse error: (
23:00:04 <cocreature> dminuoso: yeah, I just don’t see why you would ever want that
23:00:46 <dminuoso> cocreature: Maybe it's for the same reason you can have 0-parameter typeclasses? Just for consistency/symmetry?
23:00:56 <dminuoso> @let class Blah
23:00:58 <lambdabot>  Defined.
23:01:11 <dminuoso> > Blah => 1
23:01:13 <lambdabot>  <hint>:1:6: error: parse error on input ‘=>’
23:01:24 <dminuoso> > a :: Blah => Int; a = 1
23:01:27 <lambdabot>  <hint>:1:17: error: parse error on input ‘;’
23:01:29 <cocreature> yeah maybe
23:01:29 <dminuoso> @let  a :: Blah => Int; a = 1
23:01:31 <lambdabot>  Defined.
23:01:37 <dminuoso> > a
23:01:39 <lambdabot>  error:
23:01:39 <lambdabot>      Ambiguous occurrence ‘a’
23:01:39 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.a’,
23:01:42 <dminuoso> > L.a
23:01:45 <lambdabot>  error:
23:01:45 <lambdabot>      No instance for Blah arising from a use of ‘L.a’
23:01:50 <dminuoso> @instance Blah
23:01:50 <lambdabot> Maybe you meant: instances instances-importing
23:01:52 <dminuoso> @let instance Blah
23:01:54 <lambdabot>  Defined.
23:01:54 <dminuoso> > L.a
23:01:57 <lambdabot>  1
23:02:29 <dminuoso> cocreature: at the very least the syntax is rather curious then.
23:04:06 <cocreature> dminuoso: how so? seems quite natural to me
23:51:42 <YellowOnion> Could someone give me some tips on what kind of code would allow me to write code like this https://gist.github.com/YellowOnion/6c8b4f3971324f9ef4af2a31ed0135d0
23:51:52 <YellowOnion> s/code/monad
23:52:51 <opqdonut> YellowOnion: if you're careful to order the brackets by size
23:52:56 <opqdonut> then <*> could just be function composition
23:53:15 <opqdonut> so taxBracket :: Int -> Float -> Account -> Account
23:54:48 <YellowOnion> opqdonut, specifically curious how to bail at step line ten (when remaining income is < 1)
23:54:48 <Ariakenom> No Float money pls
23:55:22 --- mode: glguy set +v rlj
23:55:22 <Ariakenom> Rational money
23:55:48 <YellowOnion> Hmm actually 0 * x is 0 so I don't need to bail lol...how'd I not realise this earlier.
23:55:50 <mniip> I say Double the money
23:56:20 * Ariakenom stares flatly at mniip
23:56:27 <mniip> don't take anyone else's Word for it
23:57:30 <YellowOnion> There's fixed package for the actual number, but I'm not worried, I'm just trying to draw graphs.
23:57:59 <mniip> Ariakenom, you could say money is an Integral part of economy
23:58:17 * Ariakenom sips coffee
23:58:28 <YellowOnion> :-|
