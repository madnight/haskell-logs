00:02:31 <dminuoso> opqdonut: Im curious, how is <*> function composition rather than application?
00:07:08 <opqdonut> dminuoso: I mean if he gives taxBracket a straightforward definition, he can use (.) instead of (<*>)
00:08:12 <dminuoso> Ah okay
00:08:22 <dminuoso> Still too early in the morning ;)
00:45:41 <merijn> ooh, this Extrapolate stuff looks cool
00:46:48 <lavalike> what is it?
00:48:18 <merijn> lavalike: Property-testing like QuickCheck, but with a method for generalising counter-examples
00:48:29 --- mode: glguy set +v foldrr
00:48:49 <merijn> https://github.com/rudymatela/extrapolate#using-extrapolate
00:49:03 --- mode: glguy set -v rfold
00:49:47 <rfold> Hi, when the Haskell program quits, the RTS will first run a GC before exiting. However, I have a heap of about 90 GB and this GC takes a long time. Is it possible to avoid the GC that occurs before exiting the program?
00:50:27 <rfold> I don't mind if finalizers aren't run. But there doesn't seem to be a way to disable the GC.
00:50:54 <merijn> rfold: How is the program quitting?
00:51:08 <merijn> Maybe you can just "quit harder" to avoid running the GC
00:51:19 <rfold> merijn: running off the end of main.
00:51:20 <merijn> (i.e. the C equivalent of calling _Exit)
00:51:41 <merijn> rfold: So, if you run System.Exit.exitSuccess, do you get the same result?
00:51:41 <Ariakenom> I wouldn't think a GC should run upon exit
00:51:51 <merijn> Ariakenom: It has to to run finalizers
00:53:43 <cocreature> exitSuccess doesn’t call exit directly either. it just throws an exception
00:54:27 <merijn> cocreature: Yeah, I was just going to suggest incrementally harder ways of quitting :)
00:54:45 <merijn> cocreature: Note that even exit isn't the same as
00:54:57 <merijn> eh, "as _Exit"
00:55:25 <rfold> exitSuccess doesn't help. I'll try _Exit, I'm sure it'll work. :')
00:55:51 <merijn> The final option, of course being to just SIGKILL yourself (assuming you only need *nix support)
00:56:19 <merijn> rfold: And/or write a patch for the RTS that adds a flag to skip final GC!
00:57:13 <rfold> raise(SIGKILL) is what I used to do in C before I learned about _Exit.
01:00:15 <merijn> rfold: I mean, that'll definitely work if all else fails :p
01:00:32 <merijn> rfold: Have you also played with the RTS flags controlling GC? Not sure if any of those help
01:00:49 <merijn> Also, what sorta data structure is this 90 GB of heap?
01:03:41 <anohigisavay> hello
01:04:12 <anohigisavay> i'm confused with an error
01:04:24 <anohigisavay> https://bpaste.net/show/d8db13bc101c
01:04:28 <anohigisavay> https://bpaste.net/show/39db3e1dadbd
01:04:30 <rfold> merijn: most of it is Data.Compact'ed arrays of hash maps which shouldn't be problematic, the rest is mostly uncompacted hash maps and text.
01:04:34 <anohigisavay> these are the two files involved
01:04:46 <anohigisavay> this is the error: https://bpaste.net/show/0fbeca47a3b9
01:05:19 <anohigisavay> i'm using duplicate record fields
01:05:26 <rfold> merijn: yeah, have tweaked the GC flags, sometimes GC still take a very long time while the program is running, but _Exit is a nice "quick fix" for when exiting for a deployment of a new version
01:05:41 <anohigisavay> i don't know why it tries to match Neo4jConfig with BoltCfg
01:08:05 <rfold> merijn: we already have concrete plans for reducing the memory usage and for keeping more objects from moving to G2
01:08:10 <anohigisavay> does GHC infer that the two occurrences of 'host' refer to the same record field?
01:10:29 <bahamas> hello. I'm working with a YAML file and I want to add a value to an array. my array is sorted and I want to add the new value in a way that keeps the array sorted. what's the way to do that?
01:11:01 <bahamas> I was thinking of simply looping through the array and my comparing my value with the current value, but I've read that it's inefficient to do that with vectors
01:11:24 <mniip> bahamas, what does the library translate yaml lists into
01:11:27 <cocreature> bahamas: what exactly do you mean by “array”? i.e. which Haskell type are you using
01:11:48 <bahamas> mniip: cocreature: it uses Data.Vector to represent Array
01:11:49 <merijn> rfold: If it's arrays couldn't you drastically reduce the GC by using Storable Vector?
01:12:57 <cocreature> bahamas: in that case you can’t do any better than creating a new vector
01:13:02 <merijn> rfold: Because with Array it'd copy the entire array on GC (which is costly if you have 90GB worth...), with Storable Vector they'd just be ForeignPtrs which get freed, which would both speed up the regular GCs as freeing them in the end
01:13:39 <rfold> merijn: most values are Text. Inlining them into a Word16 array is also not an option, because many of the Text values are the same one (duplicates, but interned). But these are in a compact region anyway, so shouldn't be an issue.
01:13:45 <merijn> ah, wait, I'm not sure whether you can sensibly turn the Data.Compact stuff into Storable stuff
01:14:14 <cocreature> bahamas: you can use findIndex to find the index where you insert, split the original vector using splitAt and then concatenate the two vector splices and your new element
01:14:50 <cocreature> if you are going to do repeated inserts it might make sense to switch to a different data structure as an intermediate representation
01:15:09 <cocreature> but if your input is a Vector and your output is a Vector you don’t really have a choice if you are only doing a single insert
01:15:54 <mniip> you could try to implement a ToJSON instance skipping the toJSON method and instead going for toEncoding
01:16:10 <mniip> which is essentially a builder that doesn't store the Value tree in memory
01:16:11 <bahamas> cocreature: it's just one insertion. I'll go with your suggestion. thanks!
01:18:07 <mniip> ah seems that the answer is simpler
01:18:22 <mniip> you could use the ToJSON/FromJSON instances of [] rather than Array
01:25:02 <bahamas> mniip: I don't know how to use those instances yet, so I'll just go with manipulating the vector
01:40:21 <tysonzero> instances declared in a module and imported should work exactly the same as instances declared in the same module right?
01:40:47 <tysonzero> I get "Could not deduce (Flat (V2 (Maybe (Diff a))))         arising from a use of ‘Data.Flat.Class.$dmsize’       from the context: Flat (Diff a)"
01:40:55 <tysonzero> when I import the `Flat a => Flat (V2 a)` orphan
01:41:01 <tysonzero> but it works when I define it inline
01:46:38 <cocreature> tysonzero: can you show us the full error and the code causing it?
01:47:11 <cocreature> are you sure you are actually importing the module with the orphan instance?
01:47:31 <tysonzero> https://pastebin.com/muUn3Xqm
01:47:34 <tysonzero> https://pastebin.com/xEz66ny5
01:48:06 <cocreature> you are importing Data.Flat.Instances not Data.Flat.Orphans
01:48:17 <tysonzero> https://pastebin.com/i48ZCB6Z
01:48:21 <tysonzero> wow
01:48:22 <tysonzero> god
01:48:24 <tysonzero> IOJSADaisjdasoda
01:48:28 <tysonzero> cocreature: thank you
01:48:31 <tysonzero> sorry
02:15:11 <bahamas> with lens, how do I update the value corresponding to a key?
02:16:18 --- mode: glguy set +v kritzcreek_
02:18:12 <__monty__> bahamas: Isn't that what `set` is for?
02:19:04 <Ariakenom> % :t set
02:19:04 <yahb> Ariakenom: ASetter s t a b -> b -> s -> t
02:23:57 <bahamas> __monty__: is there better documentation for Lens than this http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens.html? if I don't know what I'm looking for, I don't know where to find it
02:25:36 <__monty__> bahamas: No idea. Lens is pretty dense. I just guessed there'd be a `set` combinator and found it in the index: http://hackage.haskell.org/package/lens-4.17/docs/doc-index-S.html
02:26:54 <__monty__> It's also in the UML diagram though. (I'm not sure how to read the rest of it but Getter and Setter seem familiar.)
02:27:24 <Boomerang> You can also you hoogle to search by type or by name if you can guess the name: https://hoogle.haskell.org/?hoogle=set%20package:lens&scope=set:stackage
02:28:27 <dminuoso> bahamas: what kind of documentation are you looking for?
02:28:36 <__monty__> Althought searching by type for lens sounds difficult unless you're already familiar.
02:31:46 <Boomerang> You could have a look at the lens cheat sheet: https://github.com/ekmett/lens/wiki/Operators
02:32:14 <bahamas> Boomerang: thanks for that
02:32:57 <bahamas> dminuoso: I'm looking for a way to set the value associated with a key. I haven't used lens before, that's the problem
02:33:57 <dminuoso> bahamas: https://github.com/ekmett/lens/wiki/Overview
02:34:07 <dminuoso> Gives a good and short introduction into how lens is used.
02:34:32 <bahamas> thanks!
02:40:41 <infinisil> I recently found a great lens introduction
02:41:35 * infinisil tries to find it
02:41:48 <__monty__> Was about to say "Good for you."
02:45:03 <Ariakenom> % set id 42 0 -- powerful lens magicks
02:45:03 <yahb> Ariakenom: 42
02:47:30 <Ariakenom> % 0 & id .~ 42  -- 0.this = 42
02:47:30 <yahb> Ariakenom: 42
02:48:52 <__monty__> What is this 0.this monstrosity?
02:49:08 <Ariakenom> new java 12 features
02:51:32 * Ariakenom goes to check what the current Java version actually is.
02:53:48 <Ariakenom> Oh I was right? I was trying to overshoot.
03:14:54 --- mode: glguy set -v remexre
03:35:05 <freeman42y> let's say you would have a Prolog DSL inside Haskell. Are there any Prolog programs which using that DSL it would not be possible to write?
03:35:47 <Athas> Depends on the DSL, but generally no.
03:36:12 <Athas> But I suspect that the syntax for unification would be more awkward in Haskell.
03:36:49 <freeman42y> Athas, I am talking to someone right now who is 100% convinced that any Prolog DSL in a statically typed programming language can NOT be complete
03:37:14 <Athas> Nothing prevents you from encoding dynamic types in Haskell.
03:37:31 <Athas> You can obviously write a Prolog interpreter in Haskell, so why not a DSL?
03:37:55 <freeman42y> that's what I think also. It seems that this should just be allowed by turing completeness.
03:38:15 <freeman42y> Athas, he did not provide any evidence yet for why he thinks it is not possible, still discussing
03:38:21 <Athas> Yes.  In the worst case, the "DSL" would just be writing the Prolog AST directly and passing it to an interpretation function.
03:38:34 <dmiles> Would the haskell static type checker be of any use after you wrote a Prolog interpreter?
03:38:34 <Athas> The good question is how much nicer you can make it.
03:39:00 <freeman42y> dmiles, yay
03:39:10 <dmiles> (usefull at type checking your users using your interpreter?)
03:39:18 --- mode: glguy set +v ar3a
03:39:31 <Athas> dmiles: it would be useful for writing extralogical features (like built-in functions).
03:39:42 <tdammers> I think a useful insight in this whole conundrum is that "dynamically typed" and "unityped" are synonyms
03:40:06 <ar3a> looking to learn a functional language for full stack web apps (although mostly the back end as the front end has react and whatnot that sort of satiates me). Is haskell suited for this or is there something else that has a nice web community? graphql is a bonus
03:40:07 <tdammers> that is, a dynamically-typed language can be considered a pathological case of a statically-typed language, where there is only one type, and all values inhabit it
03:40:15 <dmiles> yes.. prolog programs are ofen unityped
03:40:16 <ar3a> sorry, dont know if that sent - just got +v
03:42:33 <freeman42y> ar3a, yes, it got sent. Haskell would work for your use case. But there are a lot of factors weighting in like available libraries, IDEs, etc. Haskell will give you very elegant and high quality code, other languages might give you more of the other things
03:42:48 --- mode: glguy set +v sgraf_
03:43:02 <dmiles> yeah the ATP-Haskell code at Haskell.org is that kind of pathological as it even destroyed haskells ability to be helpfull to compile it
03:43:15 <ar3a> freeman42y: what are some other languages?
03:43:35 <freeman42y> dmiles, Athas so who should I believe now? is it possible to have a complete Prolog DSL in Haskell or not?
03:43:59 <dmiles> the problem is the DSL is just a AST (abstract syntax tree)
03:44:46 <freeman42y> a3Dman, for web stuff: C#, Scala (I might go to hell for recommending this), maybe F#
03:45:00 <freeman42y> Java also
03:45:12 <dmiles> if we are very disciplined we *might* be able to make lots of skelectons that wrap the DSL units into something that Haskell vetted what we are capabable of construcing
03:45:22 <Athas> freeman42y: here is an implementation of the purely logical part of Prolog in Haskell: https://github.com/kfl/pure-prolog
03:45:32 <Athas> You can easily make a (bad) DSL from that, by writing the AST manually.
03:46:14 <freeman42y> dmiles, it is a yes or no question though: either you can have a complete DSL or not
03:46:24 <Athas> It is not "complete", because it does omit all the extralogical features of Prolog (cuts, IO, etc), but I don't think those are the ones that would give you trouble.
03:47:08 <dmiles> prologs DSL is by-design incomplete
03:47:09 <Athas> dmiles: ATP?
03:47:57 <freeman42y> dmiles, what evidence do you have for that?
03:48:18 <dmiles> https://hackage.haskell.org/package/atp-haskell
03:48:25 <dmiles> ( yes Athas )
03:48:31 <ar3a> freeman42y: no, i meant functional languages for web stuff
03:49:18 <tdammers> ar3a: Haskell is fine for server-side, and if you like mild amounts of pain, GHCJS works for frontend; otherwise, there's PureScript, which is easy to learn if you already know Haskell, and much easier to get working
03:49:25 <dmiles> Prolog's DSL is by-design incomplete so that the programmer is required to invent a new programming language everytime they write a prolog application
03:49:34 <freeman42y> ar3a, all the languages I mentioned have higher order functions. Are you asking about purely functional programming languages?
03:50:01 <dmiles> So of how in Haskell the programmer might feel required to invent types
03:50:01 <tdammers> ar3a: there's also Elm, which personally I abhor quite a bit, but it's undeniably popular
03:50:16 <dmiles> Sort of how in Haskell the programmer feels required to invent types
03:50:28 <tdammers> ar3a: and if your definition of "functional" is sufficiently lax, there's also clojurescript, a compile-to-JS flavor of clojure
03:51:22 <tdammers> dmiles: that doesn't matter though; there's a finite number of building blocks that you can arrange into programs, as long as you implement all the building blocks and combinators (of which, again, there is a fixed, finite number), you have a complete DSL
03:51:46 <tdammers> dmiles: it's just like how you can implement a complete Scheme in Haskell, with macros and all
03:51:54 <freeman42y> dmiles, you keep saying it can only be incomplete but you are not actually showing any evidence to conclude that
03:52:32 <dmiles> I sur eiut can be "complete" once you are trying to make sure that the program cannot be extended anymore in new ways
03:54:04 <tdammers> dmiles: no, it can be complete in the sense that whatever ways you come up with to extend the language will be supported
03:55:33 * ski . o O ( "Embedding Prolog into Haskell" by Silvija Seres,Michael Spivey in 1999-09 at <http://www.silvija.net/0000OxfordPublications/seres_haskell99.pdf> )
03:55:36 * ski . o O ( "Typed Logical Variables in Haskell" by Koen Claessen,Peter Ljunglöf in 2001 at <http://www.cse.chalmers.se/~peb/pubs/ClaessenLjunglof2000a%20-%20Typed%20Logical%20Variables%20in%20Haskell.pdf> )
03:56:03 <dmiles> yeah the macros can continue to extend the possiblities.. what i mean by a complete DSL is one that no more macros can be added to
03:56:13 <ar3a> freeman42y: yes
03:57:06 <merijn> What sort of "web stuff"?
03:57:32 <dmiles> (i mean i think I am answe4ring freeman42y "the DSL wil always be incomplte" since we wont be able to publish a user manular with all that can be done in it)
03:58:42 <freeman42y> dmiles, I don't see what publishing user manuals has to do with whether the DSL can run any Prolog program possible
03:59:45 <__monty__> At most that'd be a measure of how complete the manual is, not the DSL.
04:00:20 <tdammers> dmiles: "a DSL that no more macros can be added to" is not what "complete" is usually taken to mean
04:01:00 <dmiles> freeman42y: i am saying if you have a language that cant tell the differnce between "data" and "code".. you can only document the code up to a certain day
04:01:16 <tdammers> dmiles: otherwise, by your own definition, there cannot be a "complete" implementation of any language with any kind of macro support
04:02:16 <jgt> this line typechecks: `mSubscription <- runDB $ getBy $ UniqueSubscriptionUser (entityKey user)`, but I'm wondering how I'd write this if I have `(entityKey <$> mUser)` instead
04:02:35 <jgt> do I use `(<*>)` here somehow? I haven't grokked applicatives yet
04:02:39 <tdammers> dmiles: documentation is a completely orthogonal concern; and apart from that, the extension mechanism is a part of the language, and while you certainly cannot preemptively document all the macros that people are going to write, you most certainly can document the entire language, including the macro mechanism
04:03:13 <lyxia> jgt: u <- entityKey <$> user ; mSubscription <- runDB $ getBy $ UniqueSubscriptionUser u
04:03:46 <jgt> lyxia: ah ok, so this can't be done in one line (nicely)
04:04:55 <dmiles> tdammers: *nod* and that is the *best* that can be done
04:04:56 <freeman42y> dmiles, ok, I get what you are saying but documentation does not show whether DSL can or can not be complete
04:04:57 <lyxia> jgt: who said that.   mSubscription <- runDB . getBy . UniqueSubscriptionUser . entityKey =<< user
04:05:39 <dmiles> freeman42y: in tdammers example he specifically by documejing the macro system made sure the end user knows their DSLs are open ended
04:06:15 <dmiles> (completely open-ended :P)
04:06:46 <jgt> lyxia: ah! thanks!
04:06:56 <jgt> now I just need to figure out some transformer thing
04:08:41 <freeman42y> dmiles, you haven't shown why the DSL can only be incomplete while 2 other people gave reasons why it can be complete
04:08:50 <dmiles> also any typechecking on what is considered on our pre-existing functions and macros (aka or DSL structure)  not pre-emptively typechecked future scheme code
04:09:10 <dmiles> (aka our DSL structure)  
04:09:31 <tdammers> scheme is unityped, so our DSL doesn't have to bother with typechecks
04:09:40 <dmiles> We would still need to convert the Scheme code to Haskell and run the typechecker 
04:10:18 <freeman42y> dmiles, the question of whether everything can be type checked is a different issue. What we were discussing is whether the DSL can be complete or not.
04:10:35 <dmiles> What would be an example of an incomplete DSL?
04:10:55 <dmiles> Also what would be an exmaple of a complete DSL?
04:11:26 <freeman42y> dmiles, are you saying that we talked all this time without us having a common understanding of what that is?
04:11:38 <dmiles> freeman42y.. haha yep
04:12:21 <jgt> lyxia: I think I have to stick a lift somewhere. Do you know where? http://ix.io/1pnz
04:12:31 <jgt> (also haven't learned transformers yet)
04:12:38 <freeman42y> dmiles, not possible, I put this in multiple ways: one way was, if you can have a Prolog program that can not be translated into the DSL, that means the DSL is incomplete
04:12:51 <dmiles> for me a DSL is what the  "interperetor can understand"
04:13:08 <dmiles> or "what the system can translate to code"
04:13:19 <merijn> jgt: I'd recommend taking a bit of time to understand transformers first before diving straight in
04:14:12 <lyxia> jgt: mUser is probably just a Maybe in which case that trick with =<< is not supposed to work
04:14:42 <jgt> merijn: Sure. I'm not aversed to learning. I see this as part of it.
04:14:56 <lyxia> jgt: you need to decide what to do when mUser = Nothing
04:15:03 <jgt> lyxia: indeed, mUser is a `Maybe (Entity User)`
04:15:32 <__monty__> freeman42y: I think the question mostly depends on what you call a DSL. Do you allow calling out to an external process for the execution of the DSL?
04:15:37 <merijn> jgt: Lucky for you I already wrote down homework for people to understand transformers :) https://gist.github.com/merijn/098106abd45c940dab09
04:15:38 <jgt> lyxia: if mUser is Nothing, then the runDB would not be run, and mSubscription would also be Nothing
04:15:58 <jgt> lyxia: Oh… Maybe I've done this before with MaybeT
04:16:24 <merijn> jgt: Basically, starts out with State and then generalised that to StateT. Although I should probably also add a MonadTrans instance in there for people to implement "lift"...
04:16:43 <freeman42y> __monty__, I will just use the DSL meaning that is used in computer science, there are no multiple definitions afaik
04:17:54 <__monty__> freeman42y: That's news to me.
04:18:21 <jgt> merijn: Thanks! I'll bookmark that, but I think also I'll need to go through the HPFFP chapter on it
04:18:48 <merijn> jgt: afaik that has mostly the same exercises
04:19:01 <freeman42y> __monty__, but for the purpose of our discussion I was discussing a DSL that would be type checked in the language in which the DSL is written
04:19:05 <dmiles> freeman42y: lets say person A has program that B wrote macros for.. bwetween them they would have a DSL..   person C comes along and writes in this DSL..  this all makes sense..     now think of it another way..   person A and C exist .. but person B has not come to join them yet.. person C has in his/her head a DSL speced out
04:19:37 <ar3a> tdammers: im not a fan of elm because im sort of sorted on the front end, more looking at backend
04:20:26 <__monty__> freeman42y: So you're basically asking whether you can implement any type system in haskell? The answer is you can.
04:21:55 <dmiles> if person person B and person C  have two different impressions of what this so called DSL contains.. how can we say that their DSL is complete?
04:22:24 <freeman42y> __monty__, I was specifically interested whether a complete Prolog DSL can be implemented in Haskell. But your point is probably correct
04:22:49 <dmiles> Prolog is in designed to still operate even when person  B or C is missing
04:22:49 <tdammers> ar3a: OK then, fair enough... so... haskell, then?
04:22:58 <ar3a> mmmmmm...
04:22:58 <jgt> for now with my runDB problem, I'm doing this: mSubscription <- maybe (return Nothing) (runDB . getBy . UniqueSubscriptionUser . entityKey) mUser
04:23:04 <ar3a> where do i learn haskell :D
04:23:09 <ar3a> best practices, real world apps, etc 
04:23:42 <freeman42y> __monty__, your statement basically says that not only for Prolog but for any programming language a complete DSL can be written
04:23:53 <dmiles> Haskell is designed to complain until persons B and C can come to an agreement ... they know they come to an agreement when the compiler says so..
04:24:18 <__monty__> freeman42y: Whether a DSL can be typed in haskell and whether it is complete are two different things though. Every untyped or unityped language is trivially typable in haskell. But you could still implement an incomplete DSL for python for example. (Although a DSL for a GP language is strange of course.)
04:25:00 <freeman42y> __monty__, the question is not whether you can implement an incomplete DSL, but whether it is possible to implement a complete one
04:25:14 <dmiles> vs Prolog which is designed to never annound that it belive B and C came ot a complete understanding
04:25:22 --- mode: glguy set +v vin_
04:26:29 <dmiles> Prolog will unify and unify expecting that B and C would not have started the program had they not agreed
04:26:48 <julianleviston> Maybe you want CHR… it’s very similar to prolog from my understanding.
04:27:01 --- mode: glguy set +v vin_
04:27:03 <julianleviston> (constraint handling rules)
04:27:37 <siraben[m]> glittershark:  I've begun using Coq more.  Theorem proving is fun, like you said.
04:27:51 <siraben[m]> Going over my set theory notes and formalizing them.
04:30:00 <dmiles> freeman42y .. an incomplete DSL would be one that we have no way to "type-check"?
04:30:04 <julianleviston> I found this an interesting read about CHR with Haskell: https://www.researchgate.net/publication/241685738_Haskell_-_Join_-_Rules
04:30:40 <ar3a> moving onto my account ar1a in a sec
04:30:57 <__monty__> freeman42y: Yes, I'm just saying that whether it can be typed is not a measure of whether it is complete or not.
04:31:14 <freeman42y> dmiles, I don't understand your example. Haskell complains if things do not type check which is good. Also, I don't get this "if person person B and person C  have two different impressions of what this so called DSL contains" if there is 1 DSL why do they think they work differently and why is this DSL related? They could think that Prolog works differently also, human error.
04:31:25 <freeman42y> __monty__, of course, I agree
04:31:40 <ar1a> aight im here :D
04:32:11 <ar1a> where should i head to learn me some haskell
04:33:28 <freeman42y> dmiles, as I said before: if you can have a Prolog program that can not be translated to the DSL then you have proven that the DSL is incomplete. Your first need a complete DSL to test that ofc.
04:34:03 <dmiles> freeman42y:  B and C  are both programmering experts in the Domain.. they both have a specific language they expect thngs to work in
04:34:40 <dmiles> they will probably come up with a differnce desing language for the domain specifics!
04:36:36 <freeman42y> dmiles, I do not understand what is the issue
04:36:39 <julianleviston> ar1a: https://www.youtube.com/watch?v=NzIZzvbplSM This is pretty interesting — brian mckenna going through a reasonably well known course… he’s pretty good at explaining things… it’s a bit of a dry introduction, tho.
04:37:20 <ar1a> julianleviston: oh cool! i think my gf works with them
04:37:28 <dmiles> the issue is that a programming language that is exendable will always need a DSL to be extended
04:37:35 <julianleviston> ar1a: with atlassian?
04:37:52 <ar1a> yeah she works at atlassian
04:37:54 <dmiles> (*unless it is extends from that DSL)
04:38:30 <dmiles> once a DSL is extends from a DSL..  (as it is in prolog) than you cannot ever safely call a DSL complete
04:38:38 <freeman42y> dmiles, that doesn't make the DSL incomplete though. If you extend the programming language obviously you need to update the DSL also
04:38:56 <__monty__> freeman42y: Since both haskell and prolog are turing complete if you don't restrict what DSL means I think it's trivially provable that you can implement a complete one for prolog in haskell.
04:39:18 <freeman42y> __monty__, I think that too, try to convince dmiles though :)
04:39:44 <dmiles> one problem is i think i think freeman42y wants to see that a DSL is complete
04:40:04 <dmiles> or that is it possible to make a DSL unextendable
04:40:48 <dmiles> i think that as long as the language is extendanble you will never have a complete enough DSL
04:41:17 <dmiles> expecially when the interpretor in a blank unspecified thing
04:41:23 <freeman42y> dmiles, you say that a Prolog DSL in a statically typed programming language can not be complete. You have not yet provided a proof for that claim. That is the only thing I am focused on right now
04:42:34 <dmiles> it cant be complete and staticly typed both
04:42:58 <freeman42y> dmiles, wait, so you agree that if the interpreter is open source and specified and the language is not extendable then you can have a complete DSL?
04:43:01 <dmiles> is what __monty__ and I are effectly saying
04:43:14 <tdammers> the key thing is that it doesn't matter at all whether the host language is statically typed or not; depending on your definition of "complete", a complete DSL either can or cannot be implemented, regardless of host language (as long as it's turing complete)
04:43:56 <freeman42y> dmiles, where did __monty__ say this: "it cant be complete and staticly typed both" ?
04:43:58 <tdammers> but I think what you're trying to get at is that it may not be possible to fully typecheck prolog
04:44:05 <dmiles> freeman42yL: yes if we cannot extend some language at some point we could write the haskell interpetor to actualyl typecheck it
04:44:21 <__monty__> I don't think turing completeness actually matters much.
04:44:42 <freeman42y> dmiles, woohoo, we did it, we agree. Let's pour champagne. Oh wait. Even if we agree we could still be all wrong :/
04:44:44 <tdammers> __monty__: it does, in the sense that you cannot implement a turing complete language in a turing-incomplete language
04:45:29 <__monty__> tdammers: That's not true though. As long as the compiler for that language doesn't require TCness your implementing language doesn't have to be TC.
04:45:30 <freeman42y> tdammers, "that it may not be possible to fully typecheck prolog" <- if that is what he means, that is another issue, orthogonal to what we were discussing
04:45:56 <tdammers> freeman42y: yes, it's orthogonal, but it would explain the confusion
04:46:27 <freeman42y> tdammers, after I explained so many times what I meant I find it very hard to believe it was confusing. Possible though
04:46:29 <tdammers> __monty__: OK, let me rephrase that then... in order to evaluate a program written in a TC language, you need a TC interpreter
04:47:01 <dmiles> Complete DSL = DSL that can implent everything? even non TC things :P
04:47:08 <__monty__> dmiles: I don't agree on our agreeing btw. I think it's perfectly possible to implement a DSL in a statically typed language that is complete.
04:49:05 <dmiles> __monty__: it is that i thought that "a complete DSL" means a DSL that can effectively describe everyhting
04:49:19 <dmiles> oops.. sorry.. wrong thohght
04:49:30 <freeman42y> 4 people think it is possible to have a complete DSL, 1 person thought it is not possible
04:49:47 <freeman42y> I think I will now head to Prolog channel to see if we reach same conclusion
04:49:56 <__monty__> tdammers: I'm not so sure that's true. I'm gonna assume you mean an arbitrary program. But let's take a total language for example. They can express infinite calculation with coinduction. So it can still implement the interpreter probably.
04:50:28 <freeman42y> dmiles, a complete DSL can run any program Prolog can
04:50:42 <dmiles> but prolog can run non-programs
04:50:57 <dmiles> we'd need that DSL to run non-programs to
04:51:18 <freeman42y> dmiles, https://i.imgur.com/FujpquX.png
04:51:49 <freeman42y> dmiles, I have no idea what a non-program is, but so be it, let me rephrase
04:52:07 <freeman42y> dmiles, a complete DSL can do ANYTHING Prolog can
04:52:36 <hpc> i mean, C can do anything prolog can
04:52:44 <hpc> php can do anything prolog can, prolog can do anything php can
04:53:25 <freeman42y> hpc, yes, turing completeness
04:54:28 <dmiles> " but prolog can run non-programs"  what i mean by this is prolog's interpretor can run even programs that are not yet compiliable
04:54:57 <dmiles> (in a very trusting wya that by the time it gets to the part you care about it might be present)
04:55:11 <dmiles> this is the magic of an unbound variable
04:55:31 <dmiles> not saying haskell cant implemnt prolog
04:55:55 <freeman42y> dmiles, and I am pretty sure Haskell can do that also. I know for sure C# can
04:57:38 <dmiles> orignally what my point of DSL non completness (in the ##AQGI channel) is that I was trying to say that we cant really pre-emptively predict what a complete DSL will be
04:57:43 <freeman42y> another question would be the question of what would be the verbosity ratio between writing Prolog vs. DSL code
04:58:32 <freeman42y> dmiles, "pre-emptively predict what a complete DSL will be" <- I don't know that this means
04:59:31 <dmiles> if we had person A writting a program and person B writting a DSL ( for how that program will get used)  .. it would be impossble for person B to write a complete DSL until A got done writting the program
04:59:52 <dmiles> in other words the DSL can never be compelte
04:59:57 <hpc> this whole conversation is mired in undefined terminology, i can't follow this at all
05:00:09 <dmiles> unless that DSL was the same language as the program
05:01:00 <freeman42y> hpc, what terms are unclear?
05:01:25 <hpc> "complete"
05:01:32 <dmiles> well there are 4 very differnt topics being talk where DSL and Program is filling in for 8 concepts
05:01:39 <hpc> and it sounds like "DSL" is being used in a way that attaches some magic to it beyond just being a language
05:01:53 <freeman42y> hpc, have you read the discussion from the start, I mentioned multiple times what I mean by that
05:02:27 <hpc> ah, i think it's past my scrollback then
05:03:21 <dmiles> it was ina  differnt channel
05:03:27 <freeman42y> dmiles, I only used 1 meaning for complete DSL, not sure where you are getting all the diversity 
05:04:21 <dminuoso> hpc: dunno, I didn't find a specific definition of DSL here.
05:04:27 <dmiles> here is what *i* am trying to defined:    <dmiles> "Yes" I am saying that a DSL for using Prolog inside Curry even if written by a human can not possibly be equivalent to all things Prolog can do
05:04:45 <freeman42y> hpc, a complete DSL can do anything Prolog can
05:04:57 <dminuoso> freeman42y: What is a "DSL" to you?
05:05:38 <freeman42y> dmiles, domain specific language, you can check it up online what it means. I do not have a specific meaning that differs from what it is commonly defined as
05:07:17 <freeman42y> dmiles, so in the end you do not agree that you could have a complete DSL?
05:07:31 <dmiles> well startign fresh..  a domain specific language usually is an attempt to shed away the non-essentials particulars of what is going to be interacted in the use of a systemwahere system 
05:08:06 <dmiles> well startign fresh..  a domain specific language usually is an attempt to shed away the non-essentials particulars of what is going to be interacted in the use of a software system .. this frees up the mind of the user ot work with what they need
05:08:31 <dminuoso> freeman42y: I still do not understand what the idea of "DSL" has to do with Haskell.
05:08:49 <dminuoso> freeman42y: Do you have some particular way of implementing that DSL in mind?
05:09:11 <Ariakenom> runProlog :: String -> IO ()
05:09:57 <freeman42y> dminuoso, the question was about completeness of a Prolog DSL written in Haskell. No particular way.
05:10:02 <dmiles> for the sake of #haskell .. i have been using DSL as either a whole programiong languag
05:10:03 <ion> unRunProlog :: IO () -> String
05:10:05 <dminuoso> freeman42y: What does "written in Haskell" mean
05:10:18 <dminuoso> freeman42y: Take Ariakenom's `runProlog :: String -> IO ()`
05:10:25 <dminuoso> its written in Haskell, and it implements the domain specific language prolog.
05:10:46 <freeman42y> dminuoso, ^ yes, what you just said
05:11:21 <dminuoso> freeman42y: so your question is just about "what programs can I write in Prolog" ?
05:11:53 <hpc> i mean
05:11:58 <hpc> how was prolog originally implemented?
05:12:05 <hpc> just do that same exact thing in haskell and bam, prolog
05:12:21 <dminuoso> freeman42y: I *think* you may have some twisted/odd notion of DSL in mind that is incompatible what others are thinking.
05:12:38 <freeman42y> dminuoso, this was my question: "let's say you would have a Prolog DSL inside Haskell. Are there any Prolog programs which using that DSL it would not be possible to write?"
05:12:43 <dminuoso> freeman42y: Is it possible that by DSL you are thinking in terms of "embedded in Haskell using the Haskell value and type system"?
05:12:56 <dminuoso> freeman42y: Prolog *is* a DSL.
05:13:03 <dmiles> freeman42y is wondering why i think that a DSL to create DSLs will always be incomplete
05:13:04 <dminuoso> freeman42y: So if you implement Prolog in Haskell, you can do anything in Prolog.
05:13:58 <dminuoso> If its a Prolog implementation, you can write any valid Prolog program in t
05:14:05 <freeman42y> dminuoso, this is pretty close to what DSL means: "embedded in Haskell using the Haskell value and type system"
05:14:14 <dminuoso> freeman42y: Okay, thats *not* what DSL means at all.
05:14:39 <dminuoso> freeman42y: Here's some domain specific languages: SQL for modelling relational data and querying said data. VHDL for describing hardware circuitry
05:14:47 <dminuoso> Each language is tied to a specific *domain*
05:14:54 <freeman42y> dminuoso, provide a link to the correct definition please
05:14:55 <dmiles> i mean to say I was answering that a "a DSL to create DSLs will always be incomplete" meaning no one can jump out ahead of such a proces and write a DSL that will be doing all that a the "a DSL to create DSLs" will do unless it has "free varaibles"
05:15:03 <opqdonut> what freeman42y describes is usually called an EDSL, an Embedded Domain Specific Language
05:15:19 <opqdonut> but I often see people just using DSL for EDSL
05:15:40 <dminuoso> And when we start with EDSL it depends on what techniques you have available.
05:15:44 <dminuoso> QQ means you can do basically *anything*
05:17:04 <freeman42y> opqdonut, EDSL is definitely closer to what I meant, but why would it be confusing in this case? I can't think of how it could be misinterpreted
05:18:07 <dmiles> "let's say you would have a Prolog DSL inside Haskell. Are there any Prolog programs which using a static DSL it would not be possible to write?"   ===  You mean a prolog interpretor?
05:18:20 <xsperry> hi. is it possible to embed ghci and my library into a single, self-containing executable?
05:18:35 <dminuoso> xsperry: curious, why do you want to embed ghci?
05:20:00 <xsperry> dminuoso, to avoid parsing user input and then converting that to appropriate haskell. basically, I find it convenient to just use my library functions in a ghci, but I want a stand alone executable, and not dealing with start up penalty of loading all the libraries (~15 seconds)
05:20:00 <merijn> xsperry: Possible, sure. Whether it makes sense depends
05:20:36 <merijn> xsperry: FYI: GHC is a library you can just use in your code
05:20:46 <dminuoso> xsperry: I wonder whether it may be possible to precompile the libraries into the appropriate GHCi bytecode and just load that
05:20:58 <dminuoso> It's just a wild thought
05:21:21 <merijn> xsperry: ghc (the executable) is just a very thin wrapper around ghc (the library). Also, you might wanna look up dons' work on plugins/dynamically loading Haskell?
05:21:27 <freeman42y> dmiles, how would a prolog interpreter perform the static type checking? that is obviously not what I meant by DSL in Haskell. Let's just call it EDSL from now on since it is more appropriate
05:22:23 <dmiles> freeman42y: Ahah I found something that you and most of this channel might be able to disagree with me about... and heck it realy is what was trying to convery.. "it would be impossible to write  most prolog programs to haskell!"  ..
05:22:29 <dmiles> "unless you didnt first write a prolog interpretor is haskell"
05:22:53 <dmiles> "unless you write a prolog interpretor *in* haskell  first "   :)
05:23:14 <dmiles> prolog was designed to be differnt in this way than every other computer language
05:23:17 <quicksilver> isn't prolog hiding in plain sight as the typeclass Constraint resolver (if you enable appropriate extensions) ?
05:23:45 <freeman42y> dmiles, I am confused. Did you change your mind and now you are saying that it is NOT possible to have a complete EDSL?
05:24:08 <cocreature> dmiles: the problem with that statement is that “the class of Haskell programs that are not prolog interpreters” isn’t particularly well defined
05:24:11 <dmiles> i am saying DSL for prolgo is imp[ossible without implementing Prolog
05:24:49 <cocreature> quicksilver: the typeclass constraint solver is fairly restricted compared to prolog
05:24:56 <cocreature> since instances are selected only based on the instance head
05:24:57 <dmiles> so the class of programs that need prolog to run.. need you (in haskell0 to implment prolog .. :)
05:26:27 <freeman42y> dmiles, the class of programs that need Prolog to run... ehm... can be run by using the complete EDSL to run them...
05:26:35 <quicksilver> http://okmij.org/ftp/Prolog/index.html
05:26:48 <quicksilver> ^^ I'm pretty sure there is some relevant stuff in that lot
05:27:55 <dmiles> for exmale.. take this prolog program and implment in haskell  "repreat,read(X),call(X),fail"
05:28:22 <dmiles> that is several 1000s of lines of haskell
05:28:54 <cocreature> there are definitely programs that are much easier to write in prolog if that is the point you are trying to make
05:29:16 <freeman42y> dmiles, is it several 1000s lines of Haskell Prolog EDSL code? THAT is the question!
05:29:55 <freeman42y> one of the points of the EDSL is reducing friction in writing Prolog programs such as verbosity...
05:30:20 <dmiles> well the 1000s lines of Haskell Prolog EDSL code can already do that
05:30:34 <dmiles> so yay!   do we get typechekcing .. sorry boo!
05:31:16 <dmiles> do we get a complete DSL of what that program can do? sorry no
05:31:26 <freeman42y> dmiles, I do not get how you are saying that we do not get type checking. And even if you had 1 example in which type checking does not work as long as you still get it in other cases it is still valuable.
05:31:34 <dmiles> so we get no typechecking and no DSL :(
05:31:35 <Boomerang> You don't even need to implement an interpreter in Haskell to have a Prolog eDSL, just have your eDSL do some IO and use a standalone prolog interpreter.
05:31:42 <xsperry> merijn plugins package looks interesting. can it evaluate any valid haskell expression?
05:31:55 <merijn> xsperry: Honestly, I haven't really used it
05:32:16 <freeman42y> Boomerang, that would not count as an eDSL because there is no embedding
05:32:25 <merijn> xsperry: Might also wanna ask around on the haskell-cafe mailing list. Better odds of being seen by someone who's used it
05:32:41 <__monty__> dmiles: Well, any DSL is impossible without implementing the DSL. I don't see how tautologies help us.
05:32:56 <Boomerang> Sure you can embed it in QuasiQuotes and pass Haskell values one way and parse Prolog values the other way
05:34:07 <freeman42y> Boomerang, sorry, I don't know how that works. But as long as you are not just throwing Prolog strings at an interpreter it is probably an eDSL 
05:34:08 <dmiles> ghc-prolog  -e "repeat,read(X),call(X),fail."  << echo "(Y is 1 + a,write(y=Y))"
05:34:33 * dmiles gets a type erorr :(
05:35:27 <__monty__> freeman42y: Afaik embedded DSL just means you're not parsing text, you make use of the already existing lexer/parser/etc. infrastructure of the host language. That doesn't mean you can't shell out to other interpreters.
05:35:33 <dmiles> freeman42y:  and if i didnt crearte a type error it never terminates
05:37:14 <quicksilver> I would say one characteristic of an embedded DSL is that elements of the DSL exist as haskell terms
05:37:27 <__monty__> freeman42y: So building a prolog string and calling SWI-prolog is a valid implementation for an eDSL.
05:37:40 <quicksilver> if you pipe a bunch of text to an external interpreter that isn't.
05:38:31 <freeman42y> __monty__, "That doesn't mean you can't shell out to other interpreters" I am not saying that is not allowed. I am just saying it is not allowed to just throw Prolog strings at an interpreter, as in, with no processing.
05:39:03 <freeman42y> quicksilver, "one characteristic of an embedded DSL is that elements of the DSL exist as haskell terms" this is what I understand by eDSL
05:39:18 <cocreature> if you build some kind of combinator-based that under the hood constructs a prolog string and passes it on to a prolog interpreter, I’d say that’s an edsl
05:39:28 <cocreature> *combinator-based dsl
05:39:55 <__monty__> Yes, I think we're all in agreement here now.
05:39:58 <freeman42y> __monty__, "So building a prolog string and calling SWI-prolog is a valid implementation for an eDSL." ehm, no, I do not agree with that, I think it does not fit the eDSL definition
05:40:26 <freeman42y> cocreature, "if you build some kind of combinator-based that under the hood constructs a prolog string and passes it on to a prolog interpreter, I’d say that’s an edsl" yes, that is a good example
05:40:39 <quicksilver> Also if you have to use unsafePerformIO in your implementation I'd say you're not actually embedding into haskell.
05:40:39 <__monty__> That's literally what I was talking about.
05:41:34 <freeman42y> __monty__, ah sorry, you said /building/ a Prolog string, I thought you meant just throwing entire Prolog program at the interpreter
05:42:13 <cocreature> in my view the “e” is for the interface that users use to interact with your DSL, not how you implement it behind the scenes
05:42:39 <freeman42y> did anyone get dmiles last argument? the one which concludes with "do we get typechekcing .. sorry boo!" and "do we get a complete DSL of what that program can do? sorry no"
05:42:52 --- mode: glguy set +v dmwit
05:43:22 <__monty__> That's what you end up doing. The difference is in how you write the program in the DSL. I.e. `runProlog "some prolog code"` is not embedded, `runProlog (PrologProgram (Clause ["A", "B", "C"] ...))` is embedded.
05:43:48 <freeman42y> __monty__, yes, exactly
05:43:58 <Boomerang> @package prolog
05:43:58 <lambdabot> http://hackage.haskell.org/package/prolog
05:44:11 <Boomerang> You can already write Prolog AST in plain Haskell
05:44:40 <freeman42y> an eDSL creates some in memory representation of the Prolog code to be run and is defined using Haskell terms/symbols, and then some code evaluates that
05:45:26 <dmiles> part of the problem with a unityped language in Haskell end up not up having any qualities of Haskell in the unityped language  
05:46:19 <dmiles> so you cannot construct a DSL for the unityped language and make it a non-unityped language
05:46:20 <freeman42y> Boomerang, is that library an eDSL or just taking entire program strings from Haskell to run?
05:46:40 <Boomerang> It can do both, it depends if you use the parser or not
05:47:27 <freeman42y> Boomerang, yeah, makes sense it should be able to do both. The other question is then: is it complete? Or are there some Prolog programs that can not be represented in it?
05:48:23 <Boomerang> It doesn't really matter if this specific implementation is complete. A complete Prolog implementation is possible in Haskell, bash or even brainfuck if you're patient enough :)
05:48:46 <dmiles> so if a Prolog program *needs* a "free pass" from haskell to by either unityped or untyped.. than Haskell has to give it a "free pass" as it does 
05:49:22 <cocreature> sure you can’t pretend a language has a different type system than it has
05:49:31 <freeman42y> dmiles, I have no idea what that means :) At this point I do not understand what you believe or not. But I am ok since other people gave reasons for the conclusion that a complete Prolog eDSL is possible
05:49:36 <merijn> cocreature: Sure you can, just convert everything to Dynamic! :)
05:50:17 <remexre> I'm trying to build a program that does real-time logging through a nominally pure (but in IO for FFI reasons), long-running computation; currently I've got calculate :: (MonadError Text m, MonadWriter [Text] m, MonadIO m) => m Text, and I'm trying to make the MonadWrite-written logs print "instantaneously"
05:50:23 <remexre> is this sanely possible?
05:50:41 <cocreature> merijn: that’s just allowing too many instead of too few programs :)
05:51:02 <delYsid> Hmm, I wonder if guanxi will go somewhere.
05:51:08 <freeman42y> Boomerang, yes, I agree that complete implementation is possible. But I am trying to find reasons for dmiles to convert to the statically typed religion, so actual complete eDSL examples would be very powerful. Since he says that he keep running into problems that can't actually be formulated into the eDSL he used
05:52:10 <dmwit> remexre: Probably not, if your MonadWriter plan is WriterT.
05:52:39 <lyxia> you can define a transformer that implements MonadWriter with IO
05:52:58 <lyxia> listen and pass are going to be a pain though
05:53:17 <remexre> yeah, I might just define a MonadLogger then instead
05:53:26 <delYsid> PureScript has a LoggerT thingy which uses IORef under the hood.
05:53:28 <remexre> and then instance MonadLogger IO
05:54:44 <delYsid> https://github.com/purescript/purescript/blob/master/src/Control/Monad/Logger.hs
05:55:13 <__monty__> dmiles: Type systems *restrict* the allowed programs. So by definition a stricter type system can *not* be complete.
05:56:00 <remexre> delYsid: so would lazy IO make it "just work" in that approach?
05:56:29 <remexre> or do they have an advantage by being strict?
05:58:10 * dmwit . o O ( There are two reactions you can have to discovering you don't agree with someone on what a word means. One is to argue about what the word means. The other is to stop using that word and have your conversation anyway. )
05:58:43 <merijn> dmwit: But what if the other person is wrong?! :O
05:58:48 <cocreature> dmwit: but nitpicking words is so much easier!
05:59:13 <dmiles> yes ot what __monty__ that crossed my mind but was afraid it was too general for me to say outloud
05:59:43 <dmwit> merijn, cocreature: =D
06:00:00 <merijn> Also, arguing words is more fun than cleaning up OpenCL C >.>
06:00:05 <cocreature> a type system does restrict programs but that does not mean that there is not a way to write the program in a slightly different way in the same type system
06:00:21 --- mode: glguy set +v ahri[m]
06:00:49 --- mode: glguy set +v tmp123123123
06:00:57 <dmiles> part what is difficult for me is porting my program from prolog to haskell is my program reads text in the "inform7 language" and translates  "a box is a type of container"  into the prolog program .. if i made it convert to a Haskell program instead.. it seems it would be in constant conflict .. even if i make basicalyl a cokpy of the "inform 7" C++ code.. I will have lost the ability to 
06:00:58 <dmiles> redefine the the entire source code in a single statement like "now instead of seeing..."
06:01:45 <freeman42y> https://ro-che.info/ccc/17.html :)
06:02:10 <cocreature> dmiles: if you have a program that makes a strong use of prolog-specific features, you will very likely have to redesign significant parts of it to end up with an idiomatic Haskell program
06:02:36 <cocreature> that’s also not limited to Haskell and Prolog. if you go from language A to language B and A and B are significantly different, the translation will rarely be 1-to-1
06:03:17 <dmiles> https://arxiv.org/pdf/1109.0776.pdf  <- here is someone that did port it to Haskell
06:03:49 <tmp123123123> Hi I have a question regarding custom type errors and type synonyms. I don't understand why I get type errors in this ghci session https://pastebin.com/EU4qWp4Z
06:04:05 <dmiles> (page 56 shows a program written in it)
06:05:45 <cocreature> especially if you are just learning Haskell, writing programs from scratch trying to come up with somewhat idiomatic Haskell is probably a better idea than trying to translate programs written in a significantly different language
06:06:32 <dmiles> cocreature: yeah.. i been entertaining *maybe* re-writting it in Haskell .. since lots of peopel say they'd love to help with it
06:07:04 <dmwit> tmp123123123: I don't think the evaluation order of type-level computation has been carefully specified, so you must assume eager.
06:07:13 <cocreature> dmiles: sure that might be a nice thing to do at some point but I don’t think it’s a good learning project
06:07:26 <dmiles> but it is such a formidable task .. expecially when its already mind numbly difficult even in prolog
06:07:37 <cocreature> you probably didn’t learn Prolog by translating C programs either :)
06:07:42 <dmiles> (and i been coding prolog for 20 years!)
06:08:37 <tmp123123123> dmwit: So type synonyms get reduced at definition time?
06:09:01 <dmwit> No, I don't think so. But arguments may be reduced before calls are made.
06:09:17 <ahri[m]> connected to my Stack question; is there a reason (i.e. should I consider it a warning) that the "wx" package is not in Stackage?
06:09:23 <dmiles> cocreature: if i having a Haskell project it will be taking an existing prolog-in-haskell and making it ISO compliant
06:09:52 <dmwit> tmp123123123: i.e. `If p t f` may evaluate `p`, `t`, and `f` fully before checking which clause of the definition of `If` to use.
06:09:53 <tmp123123123> dmwit: Im not using the type synonym I get the error right after the type synonym definition
06:10:22 <tmp123123123> This is what make me curious
06:10:46 <dmwit> tmp123123123: Ah, sorry, I misread; I thought your question was "do type families get reduced at definition time".
06:10:58 <dmwit> Which.... sounded impossible to me, since you haven't seen the arguments yet. =)
06:11:44 <dmwit> tmp123123123: But, okay, now I understand the question. And now I reiterate my comment from before: the evaluation order of type-level computation has not been carefully specified.
06:11:45 <dmiles> porting it to haskell will be a nice thing i can pay somone else to do after its done in a year :)
06:12:27 <dmwit> tmp123123123: I always assume it's picking the order that I like the least. =P
06:12:40 <tmp123123123> dmwit: So if I understand right type synonyms get evaluated as far as possible right after definition? and a second time at application?
06:12:57 <dmwit> That matches my experience. But again I don't think that's promised.
06:13:23 <tmp123123123> Thats really suprising, but nice to know :)
06:17:54 <freeman42y> cocreature, dmiles if the eDSL is more a 1:1 translation than trying to make it idiomatic Haskell then the code size should be roughly the size regardless of Prolog program translated. And by writing the program into the eDSL you also get the benefits of: static type checking, code refactoring, code navigation, etc.
06:18:09 <freeman42y> *the same size
06:19:49 <cocreature> I don’t think a 1:1 translation is an improvement
06:21:12 <cocreature> you’re probably going to get worse error messages, worse debugging facilities, you can’t integrate with existing code written in the original language, …
06:21:31 <cocreature> if you do translation you need to have a good selling point for that and a 1:1 translation rarely provides such points
06:23:52 <freeman42y> cocreature, "worse error messages, worse debugging facilities, you can’t integrate with existing code written in the original language" <- why do these happen in 1:1 translation but not in more idiomatic translations?
06:24:23 <freeman42y> static type checking, code refactoring, code navigation are pretty good selling points and are just some of the benefits
06:26:03 <freeman42y> I don't know how you could get debugging facilities at all when using an eDSL, as in the debugger that can attach, not debug logging
06:27:10 <freeman42y> also I don't understand why the errors would be worse, if they are runtime errors they would be the same, you would just need a mapping to the correct lines of Haskell eDSL
06:27:53 <freeman42y> and the compile time eDSL error catching is a nice bonus that Prolog is not doing
06:28:33 <freeman42y> "you can’t integrate with existing code written in the original language" that sounds like a huge benefit :) lol jk
06:29:14 <dmiles> https://github.com/TeamSPoon/prologmud/blob/master/prolog/prologmud/mud_builtin.pfc.pl#L627-L644   <- here is an example of hwo the code is written .. that code righter ther geretates  5 new properties on all class that are deduced to be temorally existing
06:29:27 <freeman42y> dmiles and me are considering this for the purpose of writing AGI code so it would most probably not use external code
06:30:00 <freeman42y> *external code in another language
06:30:15 <cocreature> if you’re edsl allows a 1:1 translation it’s not going to perform any significant form of type checking on your edsl
06:30:22 <dmiles> it also it adds a domains and randge to the 5 new function types
06:30:50 <cocreature> you get worse error messages because GHC doesn’t provide error messages specific to your dsl
06:30:56 <freeman42y> cocreature, it will perform some type checking and that is enough. Even just making sure that the symbol names are matching is enough
06:31:06 <cocreature> you get worse debugging facilities since GHC’s debugging facilities debug Haskell code not your DSL
06:31:09 <dmiles> (well this part of the code is what the AGI uses rtor persist immaginary scenrios)
06:32:28 --- mode: glguy set +v benhart
06:32:28 <freeman42y> cocreature, worse than what? "you get worse error messages because GHC doesn’t provide error messages specific to your dsl" you are compiling the Haskell compile time errors to what? Prolog does not do compile time errors. An the runtime errors will be useful if the line mapping is done correctly.
06:32:44 <dmiles> in my system i had to even write a whole new debugger for my DSL since the one with Prolog was inapropriate as well
06:32:49 <freeman42y> *you are comparing the Haskell compile time errors to what?
06:33:09 <cocreature> the runtime error will come from your custom prolog interpreter which has probably done multiple translations by that time and mapping that to the source you’ve written in your dsl is non-trivial
06:34:04 <freeman42y> cocreature, but how can you get any debug facilities at all? I mean, the eDSL code just represents building the memory object that will be run, so putting breaking on it won't actually break when it is running but when it is created
06:34:28 <cocreature> exactly, that’s why your edsl has shitty debugging facilities :)
06:35:04 <freeman42y> cocreature, yes! that is what I am saying also: ANY eDSL, it is not specific to 1:1 translation like you mentioned. Even an idiomatic eDSL will have this issue
06:35:36 <cocreature> oh I wasn’t referring to an idiomatic edsl. I was referring to translating a program to idiomatic Haskell code that doesn’t use an edsl
06:35:45 <freeman42y> cocreature, but if you use a 1:1 translation why do you think mapping of lines would be hard? you are not doing any complicated translations
06:35:52 <__monty__> A prolog eDSL doesn't sound useful. What could be way more useful is an eDSL around inform7. I could imagine that giving you more opportunities for abstracting.
06:35:54 <freeman42y> cocreature, oh, I see
06:35:55 <benhart> hey folks,   having trouble reasoning about a problem,  trying to map/fold lists strings so that each character goes to its corresponding index - example: https://gist.github.com/Benjmhart/45c5003336b0cb2576968761b4f242f6
06:36:25 <tmp123123123> dmwit: Just for completeness, I looked at GHCs bugtracker and found the following https://ghc.haskell.org/trac/ghc/ticket/12048
06:36:26 <cocreature> freeman42y: well, the easiest way to setup an edsl is to have it build up some AST that you then pass to your interpreter. but that AST doesn’t store the line number where you constructed that AST
06:37:14 <__monty__> What a prolog eDSL sounds useful for is the very specific usecase where you have a haskell codebase and you're gonna need to call out to prolog often. The eDSL can smooth over the impedance mismatch.
06:38:44 <freeman42y> cocreature, I am pretty sure there is a solution for this that is not too complicated
06:38:53 <sm> morning all. How does this work: I'm running program in ghci. It does unsafePerformIO (appendFile "debug.log" output). This worked a few times, now it's giving "Exception: debug.log: openFile: resource busy (file is locked)" - even after restarting ghci. lsof | grep "debug" shows nothing holding on to it. No other ghc processes are running. Any ideas ?
06:40:20 <sm> (how the file remains locked ?)
06:40:21 <cocreature> freeman42y: I’d be interested to see that. the only way I can see this work is TH or CPP to get the line number and I wouldn’t call either of those simple
06:41:40 <freeman42y> cocreature, I'll trust you on this, still you only need to write that code once to get the line numbers to work
06:43:03 <cocreature> freeman42y: it’s not just a case of you having to write that code. now you’re forcing CPP or TH on your users
06:43:30 <freeman42y> cocreature, why is that?
06:43:33 <cocreature> and even then you can get the line number but if you want nice error messages that show the original source and place carets below the error you are going to have a very hard time
06:43:46 <cocreature> freeman42y: well how else do you get the line number?
06:44:20 <freeman42y> are you saying that the only way to make it work is to rely on the user to add some code to the files he is writing?
06:44:59 <cocreature> at least I don’t see any other way atm, as I mentioned I’m happy to be proven wrong here
06:47:58 <lortabac> cocreature: maybe GHC's CallStack mechanism can help, I don't have much experience with it
06:48:08 <lortabac> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.12.0.0/GHC-Stack.html
06:48:31 <cocreature> lortabac: ah good point but even that will only solve the “how do I get the line number” problem. you won’t get the original source so you can show pretty errors and place carets
06:49:03 <lortabac> right, that's probably impossible without TH
06:49:28 <arianvp>  but... the information about source code locations is in the binary
06:49:31 <arianvp> for debugging purposes...
06:49:38 <arianvp> and also the source code itself right?
06:49:54 <arianvp> isn't that the whole DWARF story
06:49:59 <arianvp> that was recently added
06:50:51 <freeman42y> cocreature, oh ok, I thought there is some way to use TH/CPP without having the user do that
06:55:52 <feuerbach> Hey sm. Which platform are you on?
06:58:44 <sm> feuerbach: macos
06:58:54 <sm> hi feuerbach 
07:02:49 <feuerbach> sm: I assume if you try appendFile directly, without unsafePerformIO, the result will be the same?
07:03:13 <feuerbach> and this is a fresh ghci session, right?
07:05:53 <sm> feuerbach: I'll try that
07:09:42 <sm> feuerbach: actually I just found a second call to this log routine
07:09:52 <sm> doh. Thank you!
07:10:31 <feuerbach> haha, yeah, that'd explain it
07:11:08 <sm> now I'm wondering how you could force that close
07:16:33 --- mode: glguy set +v bahamas_
07:17:41 <Boomerang> Maybe you could try something like: log path str = unsafePerformIO $ withFile path AppendMode (\handle -> hPutStrLn handle str)
07:17:49 <bahamas_> hello. I'm trying to modify an Aeson Value with lens, but I can't figure it out. the Value is an Object and I'm trying to set a new value for the "dependencies" key. can anyone help?
07:17:50 <Boomerang> https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:withFile
07:18:02 <delYsid> I am trying to understand LogicT.  I fail to see why msplit allows for backtracking.  Any examples you can suggest that might clear my confusion up?
07:19:13 <bahamas_> I figured it out that `aesonValue ?. key "dependencies"` returns the value at "dependencies", but that's about it
07:19:18 <Lycurgus> is it a fake cut?
07:19:28 <__monty__> benhart: That was a nice little exercise. What exactly are you having trouble with? I did need zipWith to solve it.
07:19:29 <duncan^> Good afternoon, trying to install labdabot from cabal: https://paste.debian.net/hidden/36fa2725/
07:19:38 <duncan^> It seems to be failing due to some dependency conflict.
07:20:01 <duncan^> The environment is a Debian stretch box, with cabal-install 1.24.0.1
07:20:52 <feuerbach> sm: does any of your functions try to read the file? my understanding is that only writing/appending does close the file properly
07:22:51 <feuerbach> unless they collide in time somehow
07:22:59 --- mode: glguy set +v zincy_
07:26:07 <Cale> delYsid: A type with msplit is basically similar to a type of lists.
07:27:32 <Cale> But I'm not really sure what your question means exactly...
07:28:29 <max3> does anyone know how to use brittany with intero rather than hindent?
07:29:10 <Cale> delYsid: For lists, you'd have msplit [] = [Nothing], and msplit (x:xs) = [Just (x,xs)]
07:29:14 <sm> Boomerang: I tried that, with a hClose handle, but no difference. appendFile probably does the same
07:29:58 <sm> feuerbach: no, in the program I'm just appending (elsewhere I'm watching the log with tail)
07:30:33 <Boomerang> sm: You shouldn't hClose the handle that withFile gives you since it's already suppose to close it for you
07:30:49 <sm> Boomerang: oh, right
07:31:04 <Boomerang> But it might still not work, unsafePerformIO is not reliable ^^
07:31:39 <feuerbach> sm: is there a high chance of different calls colliding in time? (e.g. your program is multithreaded and there's a lot of logging)
07:32:32 <feuerbach> sm: I'd suggest opening the file once and passing the Handle around or keeping it in a global variable
07:32:52 <sm> I'm think there's just one thread, at least I'm only logging in one thread. A couple of small logs seems to work but adding a big one breaks it (eg)
07:33:22 <sm> thanks for the idea
07:35:25 <Boomerang> If you do want to log from several threads, have a look at stm and TChan, you can then do the IO and append to a file in a single thread waiting for other threads to send logs over the TChan
07:36:01 <Boomerang> That's not compatible with a unsafePerformIO approach though
07:36:35 <feuerbach> 'Handle's already have a locking mechanism inside them, they should be fine for concurrency
07:36:53 <Boomerang> Alright! Much easier then :)
07:37:49 <sm> I guess multiple calls to unsafePerformIO from a single thread, can be executed concurrently by GHC ?
07:38:18 <merijn> sm: Yes, no, maybe
07:38:33 <feuerbach> that depends on the number of capabilities ("threads")
07:38:42 <merijn> sm: GHC does not guarantee if/when unsafePerformIO will actually happen. Or if it even happens at all
07:38:42 <Boomerang> Yemnsaoybe?
07:39:04 <sm> and this program is built with -threaded
07:39:07 <merijn> sm: unsafePerformIO == "I'm okay with this code running 0, 1, or more times at some unspecific time"
07:39:21 <sm> yep
07:39:23 <merijn> sm: If you are, in fact, not ok with that, then you don't want unsafePerformIO
07:39:32 <merijn> Which, honestly, for logging sounds pretty awful
07:39:34 <codedmart> Can you pattern match on a proxy argument? If if @a is Maybe Text do this otherwise do this?
07:39:41 <sm> I'm debugging, it's fine
07:39:48 <dmwit> If you're doing IO, maybe don't call unsafePerformIO. Just a thought.
07:40:00 <sm> just seeing how far I can usefully push it
07:40:01 <merijn> codedmart: @a is a type application, not a proxy argument
07:40:16 <dmwit> codedmart: One way to think of typeclasses is as a pattern match on types.
07:40:18 <merijn> codedmart: And no, you can't pattern match on type applications.
07:40:33 <merijn> You can *maybe* abuse Typeable into doing what you want, but you shouldn't
07:40:51 <dmwit> ...so I have a slightly different answer than merijn. =)
07:41:04 <feuerbach> codedmart: no, that'd break parametricity. You can use Typeable or singletons for that
07:41:06 <codedmart> Hmm... ok that makes sense thanks.
07:41:14 <merijn> dmwit: Well, technically "using typeable" would combine both our answers
07:42:08 <eschnett> would a type class with overlapping instances work for matching Maybe Text?
07:42:23 <dmwit> Why use overlapping instances?
07:42:30 <dmwit> I prefer non-overlapping ones.
07:42:59 <merijn> eschnett: 1) probably not, 2) this sounds like a recipe for making yourself cry, be it now or in the future
07:43:39 <dmwit> (...and non-overlapping ones seem sufficient for the task.)
07:45:59 <sshine> can I provide an HSpec test with a timeout?
07:46:08 <sshine> like, fail unless it succeeds within some timespan.
07:46:30 <merijn> sshine: Use System.Timeout.timeout?
07:47:25 <sshine> merijn, thanks!
07:53:32 <xsperry> what? unsafePerformIO may not be performed at all?
07:53:37 <xsperry> why?
07:54:26 <merijn> xsperry: Because nothing forces it to be?
07:54:38 <Boomerang> > False && (unsafePerformIO $ putStrLn "Hello" >> pure True)
07:54:41 <lambdabot>  error:
07:54:41 <lambdabot>      Variable not in scope: unsafePerformIO :: IO Bool -> Bool
07:54:49 <merijn> xsperry: The IO gets performed when the thunk containing the unsafePerformIO call is forced, which may never happen
07:54:56 <merijn> % False && (unsafePerformIO $ putStrLn "Hello" >> pure True)
07:54:56 <yahb> merijn: False
07:55:19 <merijn> xsperry: There's a *reason* it's called unsafe
07:55:33 <xsperry> well that is obvious and expected. I assumed it had something specifically to do with unsafePerformIO
07:56:01 <tdammers> the unsafePerformIO may also be executed multiple times
07:56:08 <merijn> xsperry: No, there's no specific magic about unsafePerformIO that makes that happen. It's just a result of removing the restrictions IO enforces for GHC
07:56:29 <merijn> xsperry: Specifically, IO ensures that inlining, sharing, etc. do not mess with the resulting behaviour
07:56:45 <dminuoso> IO also ensures that effects *are* sequenced properly.
07:56:48 <merijn> xsperry: But with unsaferPerformIO GHC is free to inline, duplicate, share as it wants
07:57:05 <dminuoso> unsafePerformIO kills any expectations you can have.
07:57:26 <sm> unsafer ? oh lord
07:57:46 <dminuoso> xsperry: if it says "unsafe" - be sure that it's really *unsafe* to use, and requires care and deeper knowledge.
07:57:57 <merijn> sm: See also accursedUnutterablePerformIO :)
07:59:15 <sm> does any library provide that ? hoogle doesn't know it
07:59:23 <merijn> sm: https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L566-L597
07:59:32 <sm> thanks
08:00:09 <Ariakenom> good comment
08:00:51 <sm> doesn't explain what it does though 
08:01:45 <merijn> sm: It picks apart the seams of reality
08:01:59 <merijn> sm: Also, the implementation is like 10 characters :p
08:02:20 <sm> I see it but it bends my mind
08:02:33 <sm> and I dare not look for too long
08:02:39 <Ariakenom> Don't yield to it's blasphemous ways!
08:02:49 <merijn> sm: GHC has multiple ways of representing thunks (i.e. whether they are locked or not) this affects, for example, evaluation when multiple threads are trying to evaluate the same unevaluated thunk
08:03:13 <merijn> sm: Sometimes a thunk is cheap to compute, so rather than locking it and preventing concurrent access you can just go "eh, just evaluate it multiple times!"
08:03:31 <merijn> sm: Other times you want to wait for the original thread to finish evaluating
08:03:59 <merijn> sm: unsafePerformIO produces thunks that cannot be raced (i.e. if someone is evaluating, you wait until they're done, then read their result)
08:04:23 <merijn> unsafeDupablePerformIO says "naah, this is fine to be raced, just compute it multiple times instead of waiting!"
08:05:04 <merijn> accursedUnutterablePerformIO doesn't have any safety at all, not even any memory consistency guarantees
08:05:31 <merijn> It just literally rips things out of the IO data constructor
08:05:55 <tdammers> "just shut up and do as I tell you"
08:06:07 <sm> thanks!
08:06:33 <merijn> sm: When you start importing the IO constructor and enabling -XMagicHash is when you have to start worrying about your sanity ;)
08:06:39 <sm> I suppose if you added that to the doc, your soul would be in peril
08:07:05 <merijn> sm: tbh, if you don't know this level of implementation detail about GHC, you have no business using that function :)
08:08:35 <sm> who said anything about using.. I'm thinking only of pure knowledge :)
08:08:37 <merijn> sm: See also: most/all of the contents of GHC.Prim ;)
08:08:40 <sm> now I wonder who is using it
08:09:20 <sm> oh there it is
08:09:30 <sm> bytestring. So.. everybody
08:09:33 <merijn> sm: It's all over the ByteString internals :)
08:10:20 <merijn> sm: "Who uses this?" Well, dons, basically :p
08:11:11 <nshepperd1> 'It may even happen that one of the duplicated IO actions is only run partially, and then interrupted in the middle without an exception being raised. Therefore, functions like bracket cannot be used safely within unsafeDupablePerformIO.' hm
08:11:28 <Ariakenom> Note that 2 of the issues linked pointed to bytestring code ofc
08:13:15 <dminuoso> xsperry: One of the useful things of unsafePerformIO is that it signifies that Haskell really has a different evaluation model.
08:14:05 <dminuoso> xsperry: One where execution of effects and evaluation of values are separated - unsafePerformIO ties effects into the evaluation - so if you don't understand how evaluation happens in Haskell it may be quite surprising.
08:16:39 <dminuoso> xsperry: As an additional cherry: unsafePerformIO can be used to implement unsafeCoerce which *completely* circumvents the type system.
08:16:55 <xsperry> yes I know
08:17:29 <xsperry> I used unsafePerformIO only a couple of times, and it was always to have top-level IORef
08:18:35 <dminuoso> xsperry: Did you remember to NOINLINE those?
08:18:48 <xsperry> yes
08:24:37 <cocreature> unsafePerformIO top-level IORefs: global variables are such a great idea in C so let’s replicate it in Haskell!
08:25:28 <zincy_> Is reader a global variable?
08:25:46 <zincy_> I guess not but its close
08:25:48 <merijn> zincy_: No, it's scoped to the Reader
08:26:11 <zincy_> Ah ok
08:26:18 <zincy_> How do type families work?
08:26:20 <merijn> zincy_: It's only "global" if you share that reader to every individual piece of IO and each thread
08:26:39 <merijn> zincy_: Have you read the "Fun with Type Functions" paper?
08:26:45 <zincy_> Yeah
08:27:00 <zincy_> Maybe I should try and write some and then ask questions
08:28:52 <dminuoso> zincy_: The haskell wiki has a decent article on indexed type families.
08:31:24 <zincy_>  thanks
08:32:18 <dminuoso> cocreature: So far I managed to dodge all my top-level IORefs by not being lazy and initializing my program.
08:32:51 <dminuoso> I've started to make `ReaderT Env IO` an almost default setup for small programs :P 
08:33:08 <cocreature> I don’t even go there half of the time. I just use Env -> IO 
08:33:35 <merijn> cocreature: That depends on how experimental your code is
08:33:44 <xsperry> cocreature, there are cases where top level IORef/MVar is a lot cleaner than the alternatives, and just as safe
08:34:02 <dminuoso> xsperry: When are globally mutable refs a clean solution?
08:34:06 <merijn> cocreature: If you're doing exploratory programming, the ability to modify the Env without adjusting every bit of code is nice
08:34:30 <cocreature> sure that’s why I only avoid it half of the time :)
08:35:10 <xsperry> one example where I used it, synced putStrLn, that can be used it from multiple threads, without outputs interleaving
08:35:17 <cocreature> top-level IORefs make it hard to figure out dependencies in your code, they prevent you from making multiple independent instances of the things that depend on the IORef, …
08:36:27 <c_wraith> they create pure havoc in dynamic code reloading...
08:36:33 <xsperry> top-level MVar is pure implementation detail, and user of syncPutStrLn shouldn't have to know about it, and can just replace putStrLn with syncPutStrLn and have the code work
08:36:54 <dminuoso> c_wraith: Oh man I so need to play with marlow/facebooks hot code reloading machinery.
08:37:48 <monochrom> getStdGen is backed by a global mutable cell.
08:38:00 <c_wraith> as far as I know, they just used the ghc library, same as everyone else - and Simon fixed the ghc issues that prevented it from unloading code objects, so unused code can be GC'd now.
08:38:23 <c_wraith> so not *quite* like everyone else.  Helps to have a ghc author to fix pressing issues. :)
08:38:36 <monochrom> Binding GTK to Haskell requires a global queue for a functional multi-threading experience.
08:39:05 <monochrom> (i.e., postSync and postAsync.)
08:39:38 <c_wraith> yeah, sometimes you're stuck with global mutable state when working with native code that assumes global mutable state is easy.
08:41:55 <dminuoso> c_wraith: Well yeah it's not something mindblowing new, but it's still pretty cool.
08:41:57 <monochrom> A global boolean flag to remember whether network has called Windows "initialize socket system" or not so you neither have to remember it yourself nor have to remember to wrap with withSocketDo.
08:42:06 <dminuoso> c_wraith: It's mainly an adation of GHCi.ObjLink from what I can tell
08:42:35 <bollu> is there some way to get access to the underlying pointer / memory address of an object?
08:42:51 <bollu> I'm teaching myself purely functional data structures, and it would be nice to understand exactly where sharing happens
08:42:59 <c_wraith> bollu: to what end?  remember, it uses a copying gc
08:43:07 <bollu> c_wraith to view sharing
08:43:23 <dminuoso> bollu: Do you know how STG works?
08:43:26 <bollu> dminuoso yep
08:43:34 <monochrom> ghci debugger may tell you something.
08:43:49 <c_wraith> bollu: https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Exts.html#v:reallyUnsafePtrEquality-35- also exists
08:43:51 <bollu> dminuoso I don't see how that's related, I want to access the heap node you allocate for a constructor
08:43:57 <bollu> c_wraith ooh, interesting
08:44:13 <bollu> c_wraith so I can build equivalence classes of objects that are pointer-equal!  nice. 
08:44:35 <cocreature> ghc-heap-view or rather the version that’s built into ghc starting from 8.6 is probably also useful
08:44:42 <cocreature> and ghc-vis which builds on top of that
08:44:48 <Wizek> Is there a way to build only the tests with stack? Even when I try to specify the build target stack says `foo-0.23.15.0: build (exe + test)`, and proceeds to build a bunch of things twice. 
08:44:55 <c_wraith> bollu: though it's not 100% accurate.  If it tells you things are different, they might still be the same
08:44:59 <cocreature> matthew pickering has a fork of ghc-vis that uses the new stuff in 8.6
08:45:28 <bollu> cocreature yeah, that's something like what I wanted
08:45:40 <bollu> cocreature I'll take a look at it, much appreciated
08:57:55 <kuribas> why is the installation size so big?
08:58:36 <greymalkin> "Couldn't match type 'GHC.IO.Exception.IOException' with 'MyException'" when I have an instance of `Exception` implemented.  The more I use it, the more I dislike mtl.
08:59:14 <cocreature> not sure what that has to do with mtl
08:59:43 <kuribas> is there a minimal installation for building a simple webserver with servant?
08:59:53 <kuribas> and aeson
09:00:02 <kuribas> that's not 1.6Gb in size?
09:00:41 <phadej> haskell installations sizes has a bit same shape as the learning curve :( quite steep up front
09:00:51 <cocreature> kuribas: you’re not going to get your development environment much smaller but ofc the resulting binary doesn’t need to be that big
09:01:05 <dminuoso> phadej: Luckily you can get rid of a lot if you extract build artifacts and deploy them.
09:01:38 <greymalkin> cocreature: It's just another in a long line of problems I've had with MonadX over the last few weeks.  I'm finally dragging it out into IO and I get confronted with this.
09:01:59 --- mode: glguy set +v skregas
09:02:00 --- mode: glguy set -v skregas
09:03:27 <phadej> yes, hopefully most people don't deploy GHC itself to places where they run webservices
09:04:00 <cocreature> greymalkin: oh are you using MonadError?
09:04:08 <dminuoso> cocreature: MonadError is tied to IOException, so thats what it has to do with mtl
09:04:14 <dminuoso> For IO at least
09:05:40 <cocreature> right, MonadError is not for throwing exceptions use MonadThrow for that
09:05:41 <tdammers> "fat binary" is actually a very comfortable deployment model for haskell
09:05:52 <cocreature> imho the instance for IO just shouldn’t exist
09:06:04 <merijn> tdammers: "fat binary" is very comfortable in any language that has binaries :p
09:06:11 <cocreature> just like the MonadThrow instance for Either SomeException shouldn’t exist
09:07:19 <fiatjaf> I can build my project with nix-build, then I want to enter nix-shell and use cabal there to build it.
09:07:23 <merijn> kuribas: Because GHC ships like 4 runtimes (threaded, unthreaded, with profiled/unprofiled versions of each), then there's also a debug runtime, different versions of all the libraries, etc.
09:07:31 <fiatjaf> should cabal build all the packages from scratch in the first run?
09:07:37 <cocreature> fiatjaf: no
09:07:50 <fiatjaf> what is wrong, then?
09:07:57 <cocreature> fiatjaf: that sounds like you might have forgotten to enter the shell for the env attribute instead of the package itself
09:08:06 <tdammers> merijn: well, not all languages make embedding dependencies into binaries as easy as Haskell does
09:08:14 <greymalkin> cocreature: Not by choice; I'm trying to salvage an undermaintained library which has an API implementation that I need.  It's a client library written in the School of Snoyman style where almost everything was done inside a massive stack of IO-based MonadX's with conduits.  I've salvaged the types and reduced the conduit and monad usage down to a three line function; but it's in adapting the test 
09:08:20 <greymalkin> cases that I'm running into this.
09:08:55 <fiatjaf> cocreature, yeeeah, you're right
09:09:05 <fiatjaf> but what does it mean?
09:09:25 <fiatjaf> 'nix-shell -A env' means what and how is it different from 'nix-shell'?
09:10:42 <cocreature> it’s mostly a technical detail due to how nix handles Haskell derivations
09:10:59 <cocreature> for other languase entering the shell for the derivation itself usually works
09:11:02 <cocreature> *languages
09:14:18 <fiatjaf> hmm
09:14:22 <fiatjaf> thank you!
09:23:18 --- mode: glguy set +v ranberry__
09:25:01 --- mode: livingstone.freenode.net set +v orzo
09:25:01 --- mode: glguy set +v pent
09:59:20 --- mode: glguy set -v eacameron
10:05:45 <gentauro> Boomerang now around anymore?
10:18:53 <gentauro> now = not
10:22:00 <c_wraith> if you mean the library, it still seems to be on hackage
10:25:31 <Weste> Marlow’s book about concurrent programming in Haskell: is it still very up-to-date?
10:26:14 <cocreature> Weste: yep, I don’t recall any major changes that would have outdated it
10:26:34 <Weste> good
10:39:19 <cemerick> anyone have experience using Asterius for anything serious?
10:41:06 <cocreature> cemerick: I don’t think it is at a state where you can use it for anything serious
11:25:42 <elvishjerricco> hexagoxel: Ping. Curious if brittany performs a round-trip check on every output it produces?
11:27:43 <hexagoxel> yes, but it does _not_ check that the first parse and the second parse are identical syntax trees (up to formatting)
11:28:31 <__monty__> It just checks whether it parses at all?
11:28:37 <hexagoxel> yes
11:29:10 <elvishjerricco> hexagoxel: Any reason for not checking that the syntax trees are identical? Seems like it'd be a nice assurance that the meaning of the program doesn't change
11:29:11 <hexagoxel> so if a brittany bug causes semantic changes that are still syntactically valid, this is not caught.
11:31:00 <hexagoxel> i agree, that would be nice to have.
11:31:55 <fiatjaf> :t map
11:31:56 <lambdabot> (a -> b) -> [a] -> [b]
11:32:39 <elvishjerricco> It'd also be kinda nice if it reformatted the second syntax tree so it could throw a warning if the output isn't idempotent, and suggest that the user to open an issue.
11:33:45 <hexagoxel> (there are a few cases where brittany can affect the syntax tree, so you'd need to work around those somehow, but that is probably doable.)
11:33:56 <elvishjerricco> Interesting. What cases?
11:35:39 <hexagoxel> uh, i fear i have not tracked them. we discussed one case just yesterday, in https://github.com/lspitzner/brittany/pull/189
11:36:39 <hexagoxel> i.e. retaining parenthesis exactly on the LHS of a type synonym is rather annoying, due to the way the information is encoded in the annotations.
11:37:17 <hexagoxel> think "type (((MyType a b)) c) = ()"
11:42:40 <hexagoxel> ah, i think the only other case is not even merged/implemented yet. So currently i think the syntax tree is not changed ever.
11:43:39 <hexagoxel> it has to do with how "let" inside "do" appears to be not supported when having explicit braces.
11:44:20 <hexagoxel> i am not even sure this is true - good opportunity to ask maybe?
11:45:26 <c_wraith> well.  "let expression vs let statement" isn't ll(k) for any k.
11:45:34 <c_wraith> So yeah, it's an interesting case for a parser
11:46:03 <__monty__> Hmm, braces not allowed in ghci?
11:46:35 <cocreature> % do {putStrLn "foo"; putStrLn "bar";}
11:46:35 <yahb> cocreature: foo; bar
11:46:38 <hexagoxel> ah, you need to brace the let too, then it works
11:46:44 <cocreature> __monty__: works fine?
11:46:48 --- mode: glguy set +v mckeanalicej
11:47:33 <hexagoxel> ok, nevermind with that line of thought, i was mistaken.
11:47:47 <__monty__> Brace the let?
11:47:58 <hexagoxel> do { x <- getLine ; let {y = reverse (x :: String)}; putStrLn y }
11:48:01 <__monty__> cocreature: Yeah, it seems to be the let.
11:48:05 <hexagoxel> ^that works
11:48:11 <hexagoxel> do { x <- getLine ; let y = reverse (x :: String); putStrLn y }
11:48:26 <hexagoxel> ^ this breaks, because parsing is hard around when the "let" ends
11:48:38 <mckeanalicej> When I run cabal configure --enable-benchmarks I get the following error: https://gist.github.com/mckeankylej/90be1124cd6e8a4a1573b2af1dfc5e24
11:48:52 <mckeanalicej> the relevant cabal file is inclued in the error
11:48:58 <mckeanalicej> what am i doing wrong?
11:49:35 <cocreature> mckeanalicej: try "cabal install --only-dependencies --enable-benchmarks"
11:50:22 <mckeanalicej> cocreature: im using nix
11:51:01 <cocreature> mckeanalicej: in that case, set doBenchmark to true
11:51:32 <mckeanalicej> intresting cabal2nix doesnt set doBenchmark
11:51:37 <mckeanalicej> thats so werid
11:51:41 <mckeanalicej> probably a bug
11:52:00 <cocreature> no that’s just the default in nix
11:52:13 <cocreature> tests are enabled by default, benchmarks aren’t
11:52:32 <mckeanalicej> ah thanks!
11:53:10 <cocreature> there might be some argument that you can pass to cabal2nix to enable benchmarks, not sure
11:53:50 <hexagoxel> elvishjerricco: not much there, but there is an open issue about roundtrip checking: https://github.com/lspitzner/brittany/issues/69
11:58:50 --- mode: glguy set +v foojin
11:58:51 <foojin> I can get a value of type Size from that using size and I can operate on Size values but there's no way to put my Size back into a
11:59:00 <foojin> Sized a => a, because I don't know what type the caller would choose and there are no polymorphic functions that construct these.
11:59:04 <foojin> Am I missing something or is this exercise actually unsolvable?
12:02:25 <cocreature> foojin: I think your first message got lost
12:05:16 <foojin> cocreature: Does the first one you see start with "I can get a value" ?
12:06:00 <geekosaur> yes. nobody has any ideas what exercise you mean
12:06:43 <foojin> OK, resending.
12:07:01 <foojin> I'm working through CIS 194 (https://www.seas.upenn.edu/~cis194/spring13/lectures.html) homework assignments and I'm stuck on exercise 2.2 from homework 7.
12:07:10 <foojin> I have to implement a function that requires adjusting subtree sizes, which have type Sized a => a (see Sized.hs from the webpage above).
12:08:42 <cocreature> afaict exercise 2.2 requires you to implement dropJ not adjust sizes?
12:10:28 <foojin> cocreature: If I just leave them alone, they would get out-of-sync with the contents.
12:10:53 <foojin> cocreature: And I have to change the contents in order to implement dropJ.
12:11:07 <cocreature> foojin: no, when you are removing elements from the list, you are also removing the monoidal annotations which represent the size
12:12:49 <foojin> cocreature: Doesn't it invalidate every annotation structurally "above" them?
12:13:45 <cocreature> do you have some partial implementation? it might be helpful if we have some starting point that we can talk about
12:16:06 <foojin> I got stuck writing it because of this, but I can write one which simply puts the annotations back without touching them.
12:17:51 <cocreature> foojin: let’s go through the cases: you call dropJ n on a singleton list. what are the two possibilities that you need to handle here?
12:22:45 <foojin> cocreature: If n == 0, then I wrap it in a Just and hand it back, else I recur on its tail.
12:23:44 <cocreature> foojin: you’re not supposed to return a Maybe, so no wrapping
12:23:50 <cocreature> and a singleton list doesn’t have a tail
12:23:53 <foojin> cocreature: The second case is (Append _ _ _) and anything after that results in Empty.
12:24:17 <foojin> cocreature: That's right, I was about to fix that.
12:24:33 <cocreature> don’t worry about Append, just think about the two possibilities for the first case, implement them and then show us your implementation
12:26:07 <foojin> cocreature: Ok, brb.
12:29:04 <foojin> Can someone recommend a pastebin, preferrably without too much JS bloat?
12:31:03 <cocreature> github gists are fine (and are what the topic points to)
12:31:30 <fiatjaf> :t Array (Int, Int) a
12:31:31 <lambdabot> error:
12:31:31 <lambdabot>     Ambiguous occurrence ‘a’
12:31:32 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.a’,
12:31:55 <fiatjaf> foojin, sprunge.us, pastery.net
12:32:22 <xacktm> lpaste.net seems down, but that was tailored to haskell
12:32:38 <geekosaur> until it went dumb
12:32:44 <fiatjaf> does 'Array (Int, Int) a' mean a bidimensional array?
12:32:51 <fiatjaf> I don't understand it
12:33:06 <fiatjaf> :t elems
12:33:07 <lambdabot> Array i e -> [e]
12:34:54 <cocreature> fiatjaf: it’s an Array indexed by pairs of Ints so yeah you can think of it is a 2d array
12:40:23 <tdammers> all 2D array implementations are fake, somehow
12:41:00 <tdammers> you always have to map two coordinates onto one, one way or another
12:41:32 <foojin> cocreature: https://www.pastery.net/xbbbgn/
12:44:02 <foojin> cocreature: There seems to be no need for singleton checking, since I return either it or Empty.
12:44:41 <cocreature> right you can merge multiple cases here. but if you are having trouble it can make sense to first write each of them separately
12:44:58 <cocreature> either way, the problem here is “Append i (dropJ n l) r” since "i" is not the correct annotation
12:45:34 <cocreature> however, if you look at the previous exercise you have written a function that is going to be very useful here!
12:47:24 <foojin> I agree that i is a stupid name, but s, n and k are already taken and it's not like I can pattern-match on a Sized instance.
12:48:17 <cocreature> I didn’t say that "i" is a stupid name. I said that it is not the correct annotation. it was the annotation of the original list not the annotation of the new list
12:49:47 <foojin> Right, and that's because I can't do anything to it other that getting a Size value by using size.
12:50:31 <cocreature> so think about my comment that the previous exercise is going to be very helpful here :)
12:51:49 <foojin> Ok, I'll try to come up with something.
12:57:51 <foojin> cocreature: Wait, do you possibly expect me to put a correctly adjusted Size value there?
12:59:08 <foojin> I don't think this would typecheck though.
13:00:40 <cocreature> foojin: so +++ gives you a way to append two JoinLists. any idea what two lists you might want to append here?
13:03:33 <foojin> Ah, I see, there's a Monoid constraint there. I think I get it.
13:04:47 <hexagoxel> humm.. "ApplicativeDo requires a final statement of a form pure/return x" "MonadComprehensions imply a final statement of the form pure/return x"
13:05:09 <hexagoxel> but ApplicativeMonadComprehensions is not a thing?
13:05:27 <hexagoxel> *ApplicativeDoComprehensions
13:06:48 <hexagoxel> % :set -XMonadComprehensions
13:06:48 <yahb> hexagoxel: 
13:06:53 <hexagoxel> % :set -XApplicativeDo
13:06:53 <yahb> hexagoxel: 
13:07:14 <hexagoxel> % [ x + y | x <- pure 1, y <- pure 2 ] :: ZipList Int
13:07:15 <yahb> hexagoxel: ; <interactive>:100:11: error:; * No instance for (Monad ZipList) arising from a statement in a monad comprehension; * In a stmt of a monad comprehension: x <- pure 1; In the expression: [x + y | x <- pure 1, y <- pure 2] :: ZipList Int; In an equation for `it': it = [x + y | x <- pure 1, y <- pure 2] :: ZipList Int
13:07:34 <hexagoxel> % do { x <- pure 1; y <- pure 2; return (x+y) } :: ZipList Int
13:07:40 <yahb> hexagoxel: ZipList {getZipList = [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3
13:10:16 <foojin> cocreature: I solved it by combining the annotations with <>. If only I could also make it look less ugly...
13:10:56 <cocreature> foojin: you shouldn’t have to invoke <>. just replace Append i (dropJ n l) r by dropJ n l +++ r
13:15:04 <foojin> cocreature: Thanks, I didn't even think it could be of use here!
13:15:23 <cocreature> I told you two times that it’s going to be useful :)
13:16:08 <foojin> cocreature: BTW, do I have to live with plumbing like k = getSize $ size $ tag l or is there a better way also?
13:16:43 <cocreature> you could go for Size k = size (tag l) but that’s just moving things around
13:24:50 <foojin> cocreature: At least it does away with two $.
13:41:18 <__monty__> Replacing them with two parens...
13:41:21 <__monty__> : )
13:41:30 <koala_man> I'm trying to debug what might be a proxy issue in a CI system. cabal update is failing. Is there a way to wget the file and then have cabal use the local version?
15:04:27 <HenryCH> Hi everyone, im trying to get haskero up and running in vs code, following the instructions it seems i need intero
15:05:08 <HenryCH> does "stack build intero" install intero just for the current project or how does that work_
15:26:33 <gentauro> HenryCH: haskero is intero but for vs code
15:27:00 <gentauro> `stack build intero` will build your project
15:27:24 <gentauro> I don't think it's wise to call your project intero, it might result in some conflicts ...
15:27:53 <HenryCH> im just following the instructions, i thought "stack build" in my project dir would build my project
15:28:07 <HenryCH> and "stack build intero" would install intero
15:35:20 --- mode: glguy set +v jackdk
15:43:17 <royal_screwup21> can someone explain to me in simple terms what Fix does?
15:44:32 <hpc> as in data Fix f = Fix (f (Fix f))?
15:44:36 <hpc> or thereabouts?
15:44:50 <royal_screwup21> yeah I just don't quite understand what it's doing there
15:45:20 <hpc> a good trick with type-level programming stuff like that is mentally erase "data" and the data constructors
15:45:23 <royal_screwup21> sorry I'm being super vague here, but I've read a few tutorials and threads and I'm as close to understanding it as I was when I first heard of the term
15:45:25 <hpc> Fix f = f (Fix f)
15:45:32 <hpc> or at the value level
15:45:35 <hpc> fix f = f (fix f)
15:45:53 <hpc> so it's the type-level fixed point operator
15:46:28 <royal_screwup21> what would be a concrete example that uses Fix?
15:46:39 <hpc> Fix (Either Int) is roughly the same type as [Int]
15:46:52 <hpc> wait, no it isn't
15:46:55 <hpc> uh
15:47:05 <hpc> Fix ((,) Int) is an infinite stream of Ints
15:47:09 <hpc> that's a better one
15:47:18 <hpc> because you have (Int, (Int, (Int, ...
15:47:44 <hpc> at the value level you can write
15:47:58 <hpc> fixFive = Fix (5, fixFive)
15:48:04 <fragamus> is there a vim mode for ghci
15:49:27 <hpc> royal_screwup21: you can enter that in ghci with that definition of Fix to try it out too
15:49:41 <hpc> royal_screwup21: and to confirm your understanding i suggest seeing what Fix (Either Int) means
15:51:44 <jackdk> fragamus probably. DDG search for "haskell vim" turns up several promising leads. (I use emacs so that's all I know)
16:15:21 <tsaka__> where to enable the "--allow-newer" when installing a package with stack?
16:20:13 <royal_screwup21> can someone explain to me what sentence means? "A shallow embedding allows for the extension of a new data construct in an embedding without
16:20:13 <royal_screwup21> changing any existing code." I know what shallow embedding are (it's when you use raw haskell types like tuples, Ints, etc, as opposed to defining your own data type). I can't understand what the sentence means in its entirety though
16:23:00 <royal_screwup21> I'd love a pointer or two in the right direction, even a guess...googling for shallow semantics isn't yielding anything
16:31:53 <lyxia> royal_screwup21: it might help to provide some context
17:04:19 <royal_screwup21> I'm trying to define a functor instance on tree like so: https://thepasteb.in/p/GZhW70z8E2QIV pasted the error below - I'm not qutie sure where I'm going wrong. Would love a pointer or two
17:04:56 <jackdk> :kind Functor
17:05:06 <Axman6> instance Functor Tree
17:05:53 <jackdk> the kind of types that can be Functor is Type -> Type (sometimes written * -> *). Note that you do not apply the type variable
17:05:56 <Axman6> if you look at the instances for other functors, you'll see they look like instance Functor Maybe, instance Functor [], not instance Functor (Maybe a), instance Functor [a]
17:06:04 <jackdk> ^
17:06:29 <Axman6> the thing which is a functor is Tree, not Tree a, basically
17:06:46 * Axman6 high fives jackdk
17:07:23 * jackdk high fives Axman6
17:07:31 <Axman6> Good tag team bro
18:21:02 <_deepfire> Is there a way to define a type family indexed by type-level lists?: type family Foo (xs ∷ '[Type]) ∷ Constraint
18:22:20 <glguy> Yes
18:22:22 --- mode: glguy set +v mckeanalicej
18:22:47 <mckeanalicej> how big is a Char#?
18:23:03 <Welkin> variable sized
18:23:43 <_deepfire> glguy: the above doesn't seem to fly in 8.4.. Expected a type, but ‘'[Type]’ has kind ‘[*]’
18:23:56 <glguy> _deepfire: drop the '
18:24:26 <Welkin> actually a Char should be 4 (or 8) bytes
18:24:32 <Welkin> most of it empty
18:24:39 <Welkin> I don't remember
18:24:43 <_deepfire> glguy, oh, wow.. thank you!
18:24:45 <Welkin> look it up in the ghc guide
18:25:46 <geekosaur> it's a machine word containing a unicode codepoint
18:25:59 <Welkin> when I look at how rust handles strings and characters, I am reminded that haskell's handling isn't so crazy after all. It's complicated data
18:27:12 <geekosaur> everyone wants strings to be simple. they never are.
18:27:38 <geekosaur> at least, not once you hit the real world of a utf8 web
18:30:11 <ar1a> im just picking up haskell, following through puffnfresh s video. I don't really understand how "foldRight (const (1 +)) 0" gets the length of a list. can someone please explain it to me?
18:30:45 <Welkin> what is a puffnfresh?
18:31:18 <Welkin> also, that code golf example is bullshit. Just ignore it and learn properly
18:31:43 <ar1a> okay, how can i get the length of a list using foldRight?
18:31:49 <Welkin> I think you mean foldr instead of foldRight (that doesn't exist)
18:31:53 <ar1a> puffnfresh is a person 
18:32:02 <ar1a> also, foldRight is a function that we implemented
18:32:12 <ar1a> not using haskell list, sort of implementing our own and working through it
18:32:15 <Welkin> okay, then you should know how it works
18:33:03 <Welkin> > foldr (\_ acc -> acc + 1) 0 [1..10]
18:33:05 <lambdabot>  10
18:33:15 <Welkin> that is what the code gold example is doing
18:33:31 <Welkin> const is just a stupid way to write (\_ b -> ... )
18:33:36 <Welkin> :t const
18:33:37 <lambdabot> a -> b -> a
18:33:46 <Welkin> code golf*
18:34:04 <ar1a> ah okay ty
18:34:13 <Welkin> I don't think you should follow that person's advice
18:34:31 <Welkin> they are not using reasonable examples. It looks more like they are trying to impress you with code golf
18:35:15 <ar1a> nah the rest of it makes perfect sense, it was just that one answer 
18:35:30 <ar1a> and they didnt just write that initially, they worked from the basic implementation, but how they did it intitally didnt make any sense to me either
18:37:24 <puffnfresh> Welkin: no, not trying to impress, trying to teach
18:38:03 <puffnfresh> fold right is constructor replacement, that's the important thing
18:38:17 <puffnfresh> e.g. 1 :. 2 :. 3 :. Nil
18:38:31 <puffnfresh> constructor replacement means "replace :. and replace Nil"
18:39:00 <jle`> yea, 'mind bendy' things like this make sense in a teaching context to help you solidify your understanding. not necessarily that it's something that you will write in actual code
18:39:10 <puffnfresh> foldRight (const (+ 1)) 0
18:39:32 <puffnfresh> i.e. replace every ":." with "const (+ 1)" and replace "Nil" with "0"
18:40:09 <puffnfresh> const (+ 1) would mean "ignore the head, just add 1 to the rest"
18:40:20 <puffnfresh> :t const (+ 1)
18:40:21 <lambdabot> Num a => b -> a -> a
18:40:31 <puffnfresh> > const (+ 1) 10 20
18:40:34 <lambdabot>  21
18:41:12 <puffnfresh> I would write this in actual code, and I advocate for that
18:41:30 <Welkin> that is overly complex
18:41:46 <ar1a> not really with the context
18:41:46 --- mode: glguy set +v Koality
18:41:49 <Welkin> why not just explain a fold as what it is: a recursive function
18:41:52 <Koality> Hello
18:42:29 <Koality> Anyone online?
18:42:42 <Welkin> no, go away. We are all dead
18:42:50 <Koality> D:
18:42:52 <jle`> Koality: about 1277 people :)
18:42:56 <jle`> give or take some bots
18:43:04 <puffnfresh> Welkin: fold right is exactly constructor replacement
18:43:14 <puffnfresh> that's why I explain it, to NOT confuse people
18:44:33 <Koality> What's best resource to learn Haskell?
18:44:44 <Koality> I'm in uni and my prof is trash
18:45:36 <ar1a> puffnfresh's video is working for me
18:45:39 <Welkin> ask here, read the typeclassopedia
18:45:50 <Welkin> the upenn cis 194 course
18:45:54 <Welkin> do a project
18:46:03 <ar1a> youtu.be/NzlZzvbplSM
18:46:04 <jle`> i don't think 'a recursive function' is a helpful way of explaining foldr
18:46:18 <ar1a> ah shit typed it wrong
18:46:31 <jle`> constructor replacement is a pretty fundamental and illuminating way i think :)
18:46:39 <Welkin> I came up with a derivation of foldr by starting with a simple recursive implementation of sum
18:46:40 <jle`> if someone had told me that first i would have understood it a lot better
18:46:43 <Welkin> I have it somewhere
18:46:44 <puffnfresh> jle`: yeah I totally agree, that's actually the feedback I get most
18:47:02 <puffnfresh> I've gotten a few things like "I really liked your foldRight explanation, that helped me a lot"
18:47:14 <ar1a> ^ it cleared it up for me 
18:47:23 <jle`> sum probably makes more sense as a left fold honestly
18:47:23 <ar1a> just binging this series today
18:47:30 <jle`> i stopped thinking of foldr's second argument as an accumulator
18:48:44 <jle`> er, the second argument of the function that foldr takes, i mean
18:49:01 <jle`> the first argument in foldl's function makes sense to think of as an accumulator
18:49:48 <puffnfresh> yeah jle`, I say "foldLeft is a for-loop"
18:50:18 <puffnfresh> ar1a: let me know if you have any questions!!
18:50:23 <ar1a> yeah i msg'd ya one
18:50:27 <puffnfresh> oh sweet thanks
18:50:27 <jle`> yea i usually say something similar, that foldl is an implementation of an imperative algorithm
18:50:33 <puffnfresh> gonna get some lunch then I'll take a look
18:51:15 <ar1a> no worries, im gonna cook a pizza soon too
18:52:16 <ar1a> yeah the way i understood it, foldl is just reduce
18:52:42 <jle`> well, that's only helpful if you know what is already ;)
18:52:47 <jle`> *what reduce is
18:53:15 <ar1a> fair nuff
18:54:46 <Koality> What's the best approach to making a boolean function that checks if a password is good? (8 or more characters + numbers + uppercase + lowercase)
18:55:11 <ar1a> regex?
18:56:28 <Koality> Without using anything other than Data.List, Data.Char, Data.String, etc.
18:56:59 <ar1a> this is like blwoing my mind -- all these list/array functions can be written with foldr
18:57:42 <byorgey> ar1a: fundamentally, *any* list function can be written with foldr =)
18:58:11 <ar1a> yeah thats insane, this is so cool
18:59:12 <jle`> Koality: you can probably make functions to check each property, and then and them all together
19:00:10 <Koality> Thanks jle`
19:15:15 <Koality> What's the difference betweed 'mod' and 'rem'?
19:15:42 <jackdk> > -2 `mod` 5
19:15:45 <lambdabot>  -2
19:15:48 <jackdk> > -2 `rem` 5
19:15:50 <lambdabot>  -2
19:16:08 <Koality> Same thing? lmao
19:16:20 <jackdk> it's something to do with negatives iirc
19:16:22 <geekosaur> there's a difference in some cases
19:17:20 <Koality> Ah, rem can return negative numbers I think
19:17:29 <Koality> don't really understand tho
19:17:38 <geekosaur> mod goes with div, rem with quot, quot truncates toward 0 always, div takes the floor always     
19:17:47 <Koality> mod (-5) 6 = 1; rem (-5) 6 = -5
19:18:03 <Koality> thanks
19:19:14 <Koality> Makes a lot more sense now geekosaur
19:39:50 --- mode: glguy set +v dmwit
19:40:12 --- mode: glguy set -v dmwit
20:37:20 <ar1a> ?pf (\_ -> ())
20:37:20 <lambdabot> Maybe you meant: pl bf
20:37:31 <ar1a> ?pl (\_ -> ())
20:37:31 <lambdabot> const ()
20:39:02 <ar1a> oh duh
20:50:52 <ar1a> is there a way to simplify this expression with like function composition or something?
20:50:54 <ar1a>   (<*>) eoab =
20:50:56 <ar1a>     mapExactlyOne (runExactlyOne eoab) 
20:54:35 <jle`> ar1a: mapExactlyOne . runExactlyOne
20:59:04 <dmwit> ?pl (<*>) eoab = mapExactlyOne (runExactlyOne eoab)
20:59:04 <lambdabot> (line 1, column 13):
20:59:04 <lambdabot> unexpected " "
20:59:04 <lambdabot> expecting operator
20:59:14 <dmwit> ?pl f eoab = mapExactlyOne (runExactlyOne eoab)
20:59:14 <lambdabot> f = mapExactlyOne . runExactlyOne
20:59:29 <dmwit> lambdabot: lern2infix
21:09:41 <ar1a> ?pl (<*>) tab ta t = tab t (ta t)
21:09:41 <lambdabot> (line 1, column 17):
21:09:41 <lambdabot> unexpected " "
21:09:41 <lambdabot> expecting operator
21:09:54 <ar1a> ?
21:10:22 <ar1a> uhhhhhhuhhh...
21:11:22 <geekosaur> it's not smart enough to handle (operator) args =
21:13:46 <ar1a> so what do i do
21:15:03 <glguy> ar1a: You shouldn't be trying to write the result of ?pl into your source file (in case that's what you're up to)
21:17:25 <ar1a> glguy: how come?
21:18:19 <glguy> It's not a general improvement for code, it mostly just makes the code less readable
21:18:30 <glguy> Not something to aspire to
21:18:34 <geekosaur> usualy youd' like to be able to understand it in 6 months
21:19:19 <ar1a> lol
21:19:21 <ar1a> alright ty
21:24:49 <leungbk> if i have something like:
21:24:49 <leungbk>  
21:24:49 <leungbk> foo :: Monad m => ParsecT s u m a -> ParsecT s u m a
21:24:49 <leungbk> foo = try $ do
21:24:52 <leungbk> updateState{something...}
21:24:55 <leungbk> PARSING FAIL
21:25:03 <leungbk> both the `s` and the `u` are unchanged, right?
21:26:40 <boj> i don't know much about parsec, but it says s is a stream and u is a state type, so i imagine they change
21:28:22 <leungbk> i know that they can both change if `try` succeeds, but i'm not sure if one or both remain unchanged upon `try` failing
21:29:37 <ar1a> ?pl (\_ b -> b)
21:29:38 <lambdabot> const id
21:29:57 <ar1a> wat
21:30:00 <boj> well, if it fails it would rewind the stream, but it has to know to try a difference branch next, so possibly state is updated?
21:32:42 <leungbk> thanks for your answer.
21:32:51 <geekosaur> pretty much the whole reason it has a user state is so it can rewind it the way you expect
21:33:13 <geekosaur> internal state is separate
21:34:02 <geekosaur> ar1a, it might do ou some good to sit down with the types of those and figure out why
21:34:25 <ar1a> yeah... i thiiiiink i get it
21:34:34 <leungbk> i should clarify, `updateState` is being used here to update the user state
21:34:48 <leungbk> so does this mean the user state is reverted upon failure?
21:35:27 <geekosaur> yes. it'd be bad if it weren;'t, generally since there's no good way for you to know how to unwind it yourself
21:35:43 <leungbk> i see, thanks for your answer.
21:36:05 <geekosaur> it is possible to get that with a separate state, but it requires soem care; so parsec gives you a canned one that does the right thing
22:08:01 --- mode: glguy set +v mckeanalicej
22:08:14 <mckeanalicej> is there a non unsafeCoerce# way to convert from Word32# to Word#
22:18:31 <cocreature> mckeanalicej: I’m curious, how did you end up with a Word32#?
22:20:06 --- mode: glguy set +v tires
22:20:19 <mckeanalicej> cocreature: im writing a replacement for bytestring that doesnt use ffi calls
22:20:28 <cocreature> ah I see
22:20:33 <mckeanalicej> its 3-7 times faster btw ;)
22:20:40 <cocreature> although even then I’m not sure how you end up with Word32#?
22:20:45 <cocreature> I can’t find anything that operates on that
22:21:15 <cocreature> and even things like readWord8ArrayAsWord32# don’t return a Word32#
22:21:15 <mckeanalicej> Im making parsers for Word things
22:21:21 <mckeanalicej> but everything is unlifted
22:21:29 <mckeanalicej> lol ghc
22:21:40 <cocreature> I’m not wondering how you end up with unlifted types in general, I’m specifically wondering about Word32#
22:21:45 <mniip> cocreature, because GHC.Prim is generated differently depending on bitness of your machine
22:22:27 <cocreature> mniip: not sure I understand that. if my machine has the capabilities to support Word32#, why shouldn’t Word32# be used?
22:22:33 <dmwit> ?pl ap f g x = f x (g x)
22:22:33 <lambdabot> ap = ap
22:22:40 <dmwit> excellent
22:22:46 <mckeanalicej> im writing parsers that have the folliwing type word32Dec :: Parser Word32# 
22:23:08 <mckeanalicej> but because there arent any operations on Word32#s im just gonna drop the idea
22:23:54 <cocreature> mniip: afaict it also will always return Word# not Word32# regardless of your machine
22:25:24 <cocreature> https://github.com/ghc/ghc/blob/master/compiler/prelude/primops.txt.pp#L151
22:25:42 <cocreature> that seems kind of weird, it seems like on a 64bit system that should be Word32#
22:28:27 <Koality> I have a recursive function, but when I call it, I want the "second parameter" to be ignored for the first iteration
22:28:35 <Koality> e.g. Function :: Integer -> [Integer] -> [Integer]
22:28:44 <Koality> is there a way I can get around this?
22:28:55 <Koality> without making two functions
22:29:31 <Koality> ex. I want to call "Function 10" instead of "Function 10 []"
22:30:47 <dmwit> No, you can not get around this.
22:30:57 <Koality> thanks
22:31:10 <cocreature> Koality: there is nothing wrong with making a separate function. it is quite common to define function as Integer -> [Integer] and then define a separate function in a where clause
22:31:11 <dmwit> You can use a different name for the function that takes fewer arguments, or you can use a `where` or `let` block to hide the function that takes more arguments.
22:31:15 <jackdk> define a helper within a `where` clause? func = go [] where go ...?
22:31:25 <jackdk> man, you are all quick on the draw today!
22:31:57 <cocreature> jackdk: caffeine does that to you :)
22:31:59 <Koality> hmm... haven't learned about where or let blocks yet
22:32:03 <Koality> let me look it up
22:32:08 <Koality> thanks for the help
22:32:08 <dmwit> > let x = 3 in x+5
22:32:10 <lambdabot>  8
22:32:11 <dmwit> v. complicated
22:32:16 <Koality> lmao
22:32:17 <cocreature> Koality: also just a slight side note, functions never have uppercase names
22:32:18 <Koality> i bet
22:32:41 <Koality> I used lowercase in my implementation
22:32:43 <cocreature> uppercase is reserved for types and constructors
22:33:12 <dmwit> ?define koality = let helper xs [] = xs; helper xs (y:ys) = helper (y:xs) ys in helper []
22:33:13 <lambdabot>  Defined.
22:33:20 <dmwit> > koality "abcde"
22:33:22 <lambdabot>  "edcba"
22:33:40 <jackdk> > koality "yvan eht nioj"
22:33:43 <lambdabot>  "join the navy"
22:33:53 <jackdk> aye aye, lambdabot!
22:34:11 <dmwit> helper takes two arguments, but is hidden (uncallable) from outside the koality function (which takes only one argument).
22:34:20 <dmwit> > helper "abc" "def"
22:34:23 <lambdabot>  error:
22:34:23 <lambdabot>      Variable not in scope: helper :: [Char] -> [Char] -> t
22:49:38 <Koality> lets say I have a guard, and in one of the conditions, I want to append "n" to the output and recursively call the function with "n"
22:49:39 <Koality> How do I do both?
22:50:31 <Koality> for instance,   | even n = n : []
22:50:40 <cocreature> just like that?
22:50:43 <Koality> but I want to recursively call the function with n
22:50:52 <Koality> that just appends it to the list
22:50:59 <cocreature> "| even n = f (n : [])"
22:51:07 <cocreature> if f is the function that you want to call
22:51:22 <Koality> ohhhhhh i think i see
22:51:26 <Koality> let me try
22:53:21 <Koality> but the function is: function :: Integer -> [Integer]
22:53:29 <Koality> so I can't put the list as an input
22:54:59 <cocreature> Koality: maybe you are looking for something like "| even n = n : function n"?
22:55:00 <mniip> you're thinking imperatively
22:55:08 <cocreature> although you probably don’t want to pass "n" directly
22:55:22 <mniip> probably what you want is either | even n = n : function n,  or  | even n = function n ++ [n]
22:55:33 <mniip> the latter is probably best rewritten in a different way for performance reasons
23:00:58 <Koality> thanks! one of those worked
23:01:06 <Koality> although the output is wrong lmao
23:02:03 <mniip> both of these should work - the types work out the same way
23:02:12 <mniip> but they produce different outputs of course
23:02:26 <mniip> Koality, what is the function you are writing?
23:04:14 <johnw_> bgamari_: yes, I do
23:05:30 <Koality> halistone numbers
23:06:16 <Koality> if even -> n`div`2; otherwise -> n*3+1; exit when 1 is reached
23:06:30 <Koality> where n is the input
23:07:24 <Koality> so for 7, the output would be 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1
23:08:43 <Koality> wait i got it!
23:08:52 <Koality> but it's reversed for some reason now
23:08:56 <Koality> LOL
23:11:47 <Koality> for: | even n = function (n*3+1) ++ [n], is there any way to prepend n instead of append? 
23:12:16 <cocreature> n : function (n * 3 +1)
23:15:03 <Koality> n : function (n * 3 +1), make's sense but I get "Couldn't match type Integer with [Integer]" error
23:15:22 <Koality>   | even n = [n] : function (n`div`2)
23:15:41 <mniip> that sounds wrong
23:15:52 <mniip> have you annotated the type of your function?
23:16:29 <Koality> function :: Integer -> [Integer]
23:16:34 <Koality> function n
23:16:37 <c_wraith> Koality: take out the []
23:16:47 <Koality> but i want output to be list
23:16:52 <mniip> then "n : function (n * 3 +1)" should typecheck
23:17:00 <mniip> otherwise you messed up elsewhere
23:17:14 <c_wraith> use "n : ...", not "[n] :..."
23:17:32 <c_wraith> Haskell isn't perl.  [] isn't some magic sigil that means "I'm doing something list related"
23:18:09 <Koality> THANK YOU GUYS
23:18:12 <Koality> I'm an idiot lol
23:18:19 <dminuoso> c_wraith: But [] is a magic sigil...
23:18:19 <c_wraith> it's actually a common mistake
23:18:41 <c_wraith> dminuoso: sure, but it has a more exact meaning than that. :)
23:18:42 <dminuoso> It has a special syntax compared to all the other type/data constructors..
23:18:44 <dminuoso> :-P
23:19:13 <dminuoso> c_wraith: Does Perl have some special meaning attached to []?
23:19:21 <Koality> I just started Haskell, only used Python, C, Java, and Assembly so far
23:19:38 <Koality> it's different...
23:19:38 <c_wraith> dminuoso: no, I was thinking of stuff like @ and $ which magically make the same variables do different things
23:20:20 <c_wraith> Koality: it certainly is different.  I think the difference pays off in the end, but there's a heck of a hurdle along the way.
23:20:26 <Ariakenom> Koality: but fun right?
23:20:31 <dminuoso> Koality: Oh yeah, Haskell is different. I consider that a good thing because it doesn't try to imitate another language for the sake of it.
23:21:04 <dminuoso> Koality: While it does borrow some ideas from other languages like ML-type of languages or Clean, it's not "yet another Java/Python clone"
23:21:31 <dminuoso> Like when you pick up Ruby after Python I guarantee your mind wont be expanded. It's the same exact language in most respect.
23:22:24 <dminuoso> Sorry that shouldn't have read Clean. I meant to write Miranda.
23:23:09 <maerwald> just because you are in the same paradigm space doesn't mean you are imitating other languages
23:23:16 <maerwald> ruby is not imitating python at all, or vice versa
23:25:08 <Koality> I'm suprised how active this IRC is
23:25:16 <Koality> luckily I found it on Reddit
23:29:02 <mniip> for some reason the type of people who do haskell seems to intersect well with the type of people who's use IRC
23:29:12 <mniip> who'd
23:29:31 <Ariakenom> Koality: Why are you doing Haskell? I'm curious as to where people come from
23:29:38 <mniip> this channel is occasionally one of the largest channels on freenode. Top 10 or so
23:30:06 <maerwald> python is bigger and archlinux maybe
23:30:08 <Koality> It's a part of a university class
23:30:18 <Koality> where it teaches u how to teach urself languages
23:30:25 <Ariakenom> huh
23:30:29 <Koality> and different paradigms
23:30:39 <mniip> maerwald, linux, freenode, python, archlinux, debian, haskell
23:30:46 <Ariakenom> university class was expected, interesting subject though
23:30:55 <yushyin> http://irc.netsplit.de/channels/?net=freenode
23:30:58 <ar1a> is there something like prettier (https://prettier.io/) for haskell?
23:31:40 <maerwald> lots of different options, which are all annoying to some degree, because haskell formatting is hard :D
23:31:55 <dminuoso> ar1a: there's hident/brittany/stylish-haskell
23:31:57 <maerwald> Even knowing whether your code is correct after formatting is hard
23:32:03 <dminuoso> ar1a: *hindent
23:32:13 <Koality> do you guys program in haskell professionally or are just enthusiasts of the language?
23:32:19 <mniip> maerwald, just use { and ; liberally!
23:32:29 <maerwald> like SPJ? :P
23:32:45 <mniip> I think that one might be using them conservatively :P
23:32:47 <dminuoso> ar1a: I dont consider it that valuable though. I mainly just use hindent for import lists.
23:34:12 <Ariakenom> Koality: no one has payed me for it yet
23:35:34 <mniip> I wish someone did but my relocation options are limited and that's a can of worms once you open it :P
23:36:34 <maerwald> Koality: not many professional options, so most are "just" enthusiasts. Which has two sides: 1. more experiments and interesting stuff, 2. people don't care that much about API stability
23:37:11 <mniip> remember that time unpackClosure# changed type and no one noticed
23:38:33 <johnw_> Koality: professionally here
23:38:51 <ar1a> i wonder what australian companies even use haskell
23:40:15 <Ariakenom> digital asset
23:40:58 <cocreature> qfpl
23:45:07 <Ariakenom> just know it because it was mentioned the other day
23:49:39 <tdammers> the fact that autoformatting haskell is hard is, in a way, a good sign
23:50:21 <tdammers> it means that whitespace carries meaningful information
23:51:56 <maerwald> I don't think that's a good sign :D
23:52:08 <maerwald> it means your syntax is more complicated
23:52:57 <Koality> btw, is 2 spaces before something like a guard normal/good  practice?
23:53:17 <Koality> how many spaces lol
23:53:22 <Cale> some number of spaces greater than 0
23:53:39 <tdammers> well, compare this to C, where whitespace has absolutely no meaning - this means that you can have indentation that conflicts with the actual code structure
23:53:47 <tdammers> not saying the way haskell does it is perfect
23:53:48 <Koality> 2 > 0 == True :D
23:54:03 <Ariakenom> > 2 > 0
23:54:05 <lambdabot>  True
23:54:34 <tdammers> in fact I'd say the way C does it is perfectly appropriate for a language like C, where you're completely on your own as far as certainty and safety go
23:54:36 <maerwald> tdammers: well, you can have that in haskell too
23:54:45 <Cale> (it really doesn't matter how many, 2 tends to be good -- sometimes I like 4 for guards and 2 for the where clause)
23:54:56 <Koality> see ya tomorrow guys
23:55:01 <Koality> this is a cool IRC
23:55:07 <Ariakenom> while (x < 3); x++;
23:55:11 <Koality> haven't used any IRC for like 8 years lol
23:55:50 * Ariakenom waves
23:56:14 <tdammers> anyway, I dislike code autoformatters, generally - formatting is part of the whole communication deal, I want to use it consciously and purposefully
23:56:36 <mniip> I use hard tabs but that's considered bad practice in the community
