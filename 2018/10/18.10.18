00:06:19 <ar1a> so i just started a new project with `cabal init`, went into my cabal file, added "ncurses" to my build-depends and im getting an error when i run `cabal install` -- cabal: The program 'c2hs' version >=0.15 is required but it could not be found. -- i tried installing c2hs with `cabal install c2hs` but then it says -- cabal: The program 'alex' is required but it could not be found. -- Isn't this what a
00:06:21 <ar1a> package manager is for? :/
00:08:17 <Ariakenom> nono the manager supervises you when you get the packages
00:08:49 <ar1a> 🙄
00:09:12 <glguy> The new v2-build stuff manages build tools automatically
00:09:34 <glguy> the old system just lets you know that it needed a tool that you didn't have
00:09:42 <ar1a> so how do i get that then
00:10:01 <glguy> https://www.haskell.org/cabal/users-guide/nix-local-build.html#quickstart
00:10:11 <tdammers> "cabal isn't a package manager"
00:10:52 <dminuoso> Are there folks here (maybe from TNG or Well-Typed) that manage Munihac? 
00:10:58 <tdammers> seriously though, it's a build tool, and while it does manage haskell dependencies, anything not-haskell is out of scope, you have to manually install those things: utility programs, C libraries, etc.
00:11:29 <tdammers> dminuoso: I think andres löh (kosmikus) is involved with that
00:11:38 <ar1a> how ancient 
00:11:58 <ar1a> is that what stack does then? also a name i've heard thrown around
00:12:40 <tdammers> nope, stack does essentially the same thing as cabal, but with a different philosophy. it does manage GHC installs for you (which cabal doesn't), but any other non-haskell dependencies are out of scope for stack, too
00:12:41 <glguy> No, stack doesn't help with non-Haskell things, either
00:12:48 <dminuoso> tdammers: Ah that's helpful thanks.
00:18:56 <dmwit> This commentary about non-Haskell things is weird. c2hs and alex are Haskell things.
00:19:24 <dmwit> cabal doesn't do this for stupid technical reasons, but they aren't really defensible.
00:26:30 <sclv> dmwit: but cabal does do it with the new- system
00:26:48 <sclv> and actually for non-haskell  things like c libs you can track them as deps properly now
00:35:45 <maerwald> yes
00:53:45 --- mode: glguy set +v Mrbuck
01:01:00 <Mrbuck> which os you guys use Haskellers love windows or some linux flavour 
01:01:37 <merijn> Mrbuck: I'd say the people in this channel are heavily biased to *nix (be it Linux, macOS, or BSD)
01:02:02 <Mrbuck> I got holidays from 19 October to 10th November so will that be enough time for haskell
01:02:05 <Ariakenom> and nix*
01:02:07 <Mrbuck> merijn:  I see ok 
01:02:34 <merijn> Mrbuck: Depends what your goal is :)
01:02:44 <Mrbuck> merijn:  learn haskell languahe
01:03:16 <merijn> Mrbuck: To learn it enough to write production ready code? Maybe, but probably not. To learn a ton of stuff and realise how much more there is to learn? Sure.
01:03:46 <Ariakenom> Mrbuck: I'm curious. Why have you chosen Haskell?
01:04:13 <Mrbuck> Ariakenom:  I feel it is doifferent
01:04:18 <Mrbuck> no one do it thats why
01:04:40 <merijn> Mrbuck: Well, if the goal is "learn something very different from what you already know", then yes. That's pretty accurate :)
01:04:44 <Ariakenom> cool thanks
01:04:56 <Mrbuck> Thanj merijn  Ariakenom 
01:05:32 <ar1a> https://ptpb.pw/UB-w.webm hmmm 🤔
01:07:23 <Mrbuck> merijn but I should be ale to write toy programs I believe 
01:07:36 <merijn> Mrbuck: Sure
01:07:44 <Mrbuck> Cool merijn  
01:08:26 <merijn> hmm, so I have a set of strings, some which may start with a number and I want to sort those by numeric value, what's the best way to tackle this?
01:09:44 <merijn> I'm thinking it's probably easiest to just do 'reads' on each string, trying to parse a number and then sort all strongs that succeed based on that...
01:16:06 <thevishy> can i create an executable that posts requests to a site using haskell for windows?
01:16:28 <thevishy> i mean i don't want to have a client installed (it is for customers)
01:17:31 <lavalike> thevishy: for sure
01:17:47 <thevishy> thanks lavalike, i will consider that
01:18:14 <thevishy> i mean python is simple and all, but building an executable is always better for customers
01:20:34 <ventonegro> thevishy: http://www.serpentine.com/wreq/
01:20:51 --- mode: glguy set +v anon9002
01:21:13 <anon9002> Is it possible to run OpenGL programs with runhaskell?
01:21:39 --- mode: glguy set -v anon9002
01:21:55 <thevishy> okay ventonegro, will check out wreq! thanks
01:22:06 <ventonegro> thevishy: np
01:38:28 <infinisil> anon9002: i don't see a reason for it not working
01:43:59 <Ariakenom> I think OpenGL might need to be called from the main thread. Which may cause issues
01:44:23 <merijn> Ariakenom: It doesn't have to be called from the main thread
01:44:34 <merijn> Ariakenom: It just has to always be called from the same thread(s)
01:46:05 <Ariakenom> ok
01:46:37 <merijn> Ariakenom: Basically, AFAIK it uses Thread-Local State, so if you call it from different OS thread the TLS gets lost and things get ugly
01:46:54 <merijn> So, basically, always use bound threads for stuff like OpenCL
01:47:00 <merijn> eh, OpenGL
01:47:24 <quicksilver> merijn: I think it probably also needs to be called from the same thread as any GUI toolkit you're using
02:34:30 --- mode: glguy set +v araadkins
02:34:52 --- mode: glguy set -v araadkins
02:46:08 <Ariakenom> % (1 :+ 1) & _magnitude .~ 2 -- best way to compute sqrt 2
02:46:08 <yahb> Ariakenom: 1.414213562373095 :+ 1.414213562373095
02:50:04 <[exa]> Ariakenom: a.k.a. writing "2" in the most complicated way :]
02:50:39 <Maxdamantus> It's not complicated, just complex.
02:50:47 <Ariakenom> ha
02:51:00 <Maxdamantus> The complication is just imaginary.
02:51:06 <Ariakenom> mmhm
02:57:19 <Ariakenom> % ((-1/0) :+ 1) ^. _phase
02:57:19 <yahb> Ariakenom: 3.141592653589793
02:57:21 <Ariakenom> right
02:57:31 <ar1a> what's the difference between <> and ++?
02:58:02 <quicksilver> ++ is only for String, <> works for any Monoid
02:58:09 <merijn> ar1a: ++ only works on lists, <> works on any Monoid (or Semigroup, depending on GHC version)
02:58:10 <quicksilver> agh
02:58:15 <quicksilver> ++ is only for lists, <> works for any Monoid
02:58:41 <ar1a> haha
02:58:47 <ar1a> thanks
02:58:53 <quicksilver> apaprently more caffeine needed this morning
02:59:30 <ar1a> we got there in the end and thats what matters 
03:06:58 --- mode: glguy set +v govno
03:15:26 <__monty__> Is it just me or did Ariakenom just divide by 0.
03:16:06 --- mode: glguy set +v asib
03:16:41 <Taneb> __monty__: floats are insane
03:16:45 <Taneb> That's a way of getting negative 0
03:16:51 <Taneb> > -0.0
03:16:53 <lambdabot>  -0.0
03:16:55 <Taneb> > -0.0 == 0.0
03:16:57 <lambdabot>  True
03:17:18 <Taneb> % ((-0) :+ 1) ^. _phase
03:17:18 <yahb> Taneb: 1.5707963267948966
03:17:28 <Taneb> Ohy no
03:17:37 <Taneb> It's a way of getting negative *infinity*
03:17:39 <Taneb> My mistake
03:20:10 <__monty__> Wasn't expecting floats.
03:20:24 <__monty__> > :t (:+)
03:20:27 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
03:20:46 <Taneb> (:+) :: a -> a -> Complex a
03:21:04 <__monty__> Not even a (Num a) =>?
03:21:24 <Taneb> No, it's a constructor so that'd be a bad idea
03:21:41 <Taneb> As well as being unnecessary
03:21:56 <Taneb> A Complex is just a pair with a special Num instance
03:25:58 <jle`> __monty__: usually we like to add constraints to operations that require them
03:26:14 <jle`> that way users can tell what sort of things an operation can do
03:26:35 <jle`> (:+) :: a -> a -> Complex a means that (:+) must preserve the same numbers that you put in, and not add or subtract them
03:26:39 <jle`> or use a zero somewhere
03:26:49 <jle`> if it was Num a => a -> a -> Complex a, then we don't really know that
03:29:32 <asib> Hi guys, I've got a question about the list monad
03:29:34 <Myrl-saki> TIL,
03:29:36 <Myrl-saki> Prelude> :k []
03:29:38 <Myrl-saki> [] :: * -> *
03:30:21 <Taneb> asib: it's a general guideline that it's better to ask your question, rather than just saying you have one
03:31:17 <Mrbuck> jle`:  I found some neural network video using haskell on youtube was that you ?
03:32:15 <__monty__> jle`: Hmm, interesting. Makes sense but at the same time being able to construct a Complex from Strings seems weird.
03:32:43 <asib> Fair enough. I've got an MxN matrix and I want to write a function that returns a list of lists, where each of the lists contains one element from each row of the matrix. The returned list of lists should therefore contain all possible combos of lists containing one element from each row.
03:33:02 <asib> I've written this out in a gist to make it a bit clearer: https://gist.github.com/asib/1f45a1f2001e9c9aa456937d68777d31
03:34:09 <asib> I figured using the list monad would be best, since you get the non-determinism for free
03:34:45 <asib> but like I wrote in the gist, I can't figure out how to write it to work for any number of rows
03:34:59 <julianleviston> asib so you want the diagonal?
03:35:44 <asib> no, I want all possible combos of lists containing a single element from each row
03:35:44 <julianleviston> By the way, the code in the comment is a list of pairs, not a list of lists.
03:36:15 <julianleviston> what’s the input?
03:36:27 <asib> the input to the function is the matrix
03:36:31 <julianleviston> a list of lists of pairs?
03:36:36 <asib> yeh, the elements of the matrix are pairs
03:36:45 <asib> but I think that doesn't matter, they could be anything
03:37:26 <julianleviston> Sorry I don’t get it still.
03:37:45 <asib> so say the matrix is [[1,2],[3,4]]
03:37:52 <julianleviston> yeah..
03:37:56 <lavalike> julianleviston: [[a,b],[c,d]] -> [[a,c],[a,d],[b,c],[b,d]]
03:38:00 <asib> I want the function to return [[1,3],[1,4],[2,3],[2,4]]
03:38:08 <asib> yeh exactly
03:38:13 <julianleviston> okay. that’s not quite the same as what you asked in the gist.
03:38:16 <asib> but it needs to work for any number of rows
03:38:54 <asib> ah sorry, I thought that matched the bit of code I had written
03:39:00 <julianleviston> ok so cols of rows to rows of cols
03:39:57 <julianleviston> :t sequenceA
03:40:01 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
03:40:04 <julianleviston> or did you want to write it yourself?
03:40:22 <julianleviston> > sequenceA [[1,2],[3,4]]
03:40:27 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
03:40:47 <asib> ah perfect
03:41:04 <asib> no, not bothered about writing it, it's a means to an end haha
03:41:08 <julianleviston> sweet :)
03:41:17 <asib> thanks so much!
03:43:02 <julianleviston> asib: it’s probably worth pondering why it’s Applicative, and not Monad, if you like...
03:47:13 <asib> julianleviston: will have a good 'ol thonk about it
03:48:37 <julianleviston> I mean why it doesn’t need to be Monad. But yeah, cool :)
03:50:14 <lavalike> how do you write this with a fold
03:50:18 <lavalike> > ($[]) <$> ((.) <$> ((:) <$> [1,2]) <*> ((:) <$> [3,4]))
03:50:20 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
03:52:33 <bbear> hello
03:52:46 <bbear> how do you think the concept of a monoid is useful for programming applications ?
03:53:25 <milesrout> bbear: well it was just useful for me
03:53:32 <Ariakenom> > "hello" <> " " <> "world"  <> mempty
03:53:34 <lambdabot>  "hello world"
03:53:56 <milesrout> Ariakenom: don't confuse 'the concept of a monoid is useful' and 'particular monoids are useful'
03:54:15 <milesrout> bbear: it's just a concept that you can abstract over in order to write less code
03:54:25 <Ariakenom> compare to: "hello"<>(mempty<>mempty<>" ")<>"world"<>mempty
03:55:12 <Mrbuck> why i dont find any good proects in haskell in github ? what software writeen in haskell
03:55:32 <bbear> Mrbuck: pandoc is written in Haskell mostly
03:55:37 <Ariakenom> having an intuitive understanding of monoids you can see that they're the same. Same for any monoid replacement for the string parts
03:55:42 <yushyin> xmonad
03:55:58 <yushyin> shellcheck
03:55:58 <julianleviston> Mrbuck: the shake build system
03:56:04 <bbear> milesrout: Ariakenom, i am thinking of how the concept may be useful even in non-haskell languages.
03:56:11 <julianleviston> bbear: it totally is.
03:56:28 <milesrout> bbear: and for example the lens library provides Monoid m => Applicative (Const * m) which means you can just do x^.blah where blah is a field of a variant of an ADT that is of a type that has an instance of monoid
03:56:55 <milesrout> instead of having to do fromMaybe mempty x^?blah 
03:57:07 <Mrbuck> not good enough
03:57:29 <milesrout> Mrbuck: how are you +v here and yet asking flamebait questions about how practical haskell is in 'the real world'?
03:57:49 <Ariakenom> Mrbuck: https://wiki.haskell.org/Haskell_in_industry
03:58:24 <julianleviston> lavalike: I think it’d require more than a foldable woudln’t it?… because we want to collect the effect at the same time…
03:58:38 <Mrbuck> thank you Ariakenom 
03:58:44 <julianleviston> lavalike: which is why sequenceA has Traversable as one of its contexts rather than Foldable, I think.
03:59:10 <julianleviston> lavalike: further reading: https://wiki.haskell.org/Foldable_and_Traversable
03:59:45 <Mrbuck> milesrout:  you can be +v if you are unregisteed
03:59:47 <infinisil> :t sequenceA
03:59:48 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
04:00:02 <julianleviston> Also this might help: https://stackoverflow.com/questions/34629132/how-sequencea-works
04:00:05 <Ariakenom> bbear: My point applies to other languages as well. It was about how intuitively knowing monoids mean you can reason about monoids you dont know other specifics of
04:01:10 <julianleviston> yeah if you understand the “function monoid” (ie Reader) you can do some pretty cool things in Javascript or other mainstream languages.
04:11:08 <noumenon> for example?
04:13:25 --- mode: glguy set +v alisag[m]
04:16:31 <julianleviston> well you can merge functions if the return type is a monoid, too… which is pretty crazy :)
04:17:51 <julianleviston> Well I think it’s pretty cool anyway :)
04:20:06 <tdammers> abstractions like Monoid are great, because they allow you to skip over a lot of details while reasoning about code
04:25:28 <julianleviston> :t mintercalate
04:25:30 <lambdabot> error:
04:25:30 <lambdabot>     • Variable not in scope: mintercalate
04:25:30 <lambdabot>     • Perhaps you meant one of these:
04:32:15 <quicksilver> tdammers: I think abstractions like Monoid are great when people can reuse an algorithm which I thought was really about list or strings with some very clever Monoid and it suddenly does something amazingly useful
04:40:47 <tdammers> quicksilver: to me, the part where you can think with the "big brush" is ultimately a bigger productivity boost
04:41:35 * quicksilver nods
04:48:25 <dminuoso> tdammers: Monoid is my favourite typeclass indeed =)
04:48:56 <tdammers> dminuoso: my favorite is Functor :D
04:50:04 <hpc> i like IO
04:50:16 <dminuoso> If only that were a typeclass :P
04:50:20 <Ariakenom> mine is Field2
04:50:25 <Ariakenom> % :t _2
04:50:25 <yahb> Ariakenom: (Field2 s t a b, Functor f) => (a -> f b) -> s -> f t
04:50:29 <hpc> not just because you can reason about things that don't have IO
04:50:42 <hpc> but because now things like (IO String) are values independently of the String they produce
04:50:54 <hpc> or well, getLine is the value
04:51:12 <cocreature> "class IO m where unsafePerformIO :: m a -> a" that’s a great typeclass for IO
04:51:20 <[exa]> instance HasRealWorld IO
04:51:20 <tdammers> well, there's MonadIO...
04:51:39 <[exa]> cocreature: lol
04:52:33 <hpc> anyway, type classes aren't the only form of abstraction ;)
04:53:51 <dminuoso> cocreature: Isn't that Costar?
04:54:23 <dminuoso> No wait, Copointed.
04:54:44 <dminuoso> % import Data.Copointed
04:54:44 <yahb> dminuoso: ; <no location info>: error:; Could not find module `Data.Copointed'; It is not a module in the current program, or in any known package.
04:55:08 <dminuoso> Clearly we should have `instance Copointed IO where copoint = unsafePerformIO`
04:58:58 <cocreature> and "instance Copointed [] where copoint = head
04:59:00 <cocreature> "
04:59:24 <cocreature> "instance Copointed Maybe where copoint = fromJust"
04:59:32 <cocreature> great instances
05:03:31 <dminuoso> It typechecks, so it must be correct right?
05:06:33 <dminuoso> f x y = do { c <- ask; g c x y }
05:06:43 <dminuoso> is there some idiom for this?
05:07:04 <hpc> g <$> ask <*> pure x <*> pure y?
05:07:24 <hpc> there's not a whole lot you can do with that if your goal is just to make it shorter
05:07:42 <hpc> but maybe if you're thinking of f being some composition of g, that applicative bit is better?
05:08:23 <lyxia> you also need a join here
05:08:49 <hpc> don't think so
05:09:16 <hpc> @do g <$> ask <*> pure x <*> pure y
05:09:16 <lambdabot> g <$> ask <*> pure x <*> pure y
05:09:18 <hpc> bah
05:09:48 <lyxia> otherwise that's   do { c <- ask ; return (g c x y) }
05:10:21 <dminuoso> Okay I guess do-notation it is. ;)
05:10:29 <hpc> lyxia: gah, you're right
05:11:19 <delYsid> I want idiombrackets for haskell :-)
05:23:21 <xsperry> I don't have access to haskell compiler right now, but I was wondering if there's any runtime speed penalty if I make a function more generic? for example,  `function :: Floating a => a -> a -> a' vs `function :: Double -> Double -> Double'
05:23:45 <Mrbuck> hi
05:23:48 <Mrbuck> hi
05:23:56 <xsperry> hi
05:24:12 <tdammers> xsperry: it depends. Without optimizations, polymorphic functions have to drag typeclass dictionaries around, which makes them slower
05:24:31 <xsperry> does -O2 eliminate that?
05:24:36 <tdammers> it may
05:24:41 <tdammers> but that's not always possible
05:24:52 <dminuoso> xsperry: the problems mainly appear cross module/library
05:25:42 <Ariakenom> GHC may specialise the generic function. Otherwise I would think inlining and unboxing differences with double would be large
05:26:16 <tdammers> exactly. if the function isn't exported, and all usages are such that the monomorphic type can be determined statically, then GHC will typically specialize - but things like inlining and RULES may get in the way of that too
05:27:19 <dminuoso> xsperry: It's one of the issues behind mtl actually - making your parts polymorphic using typeclass based transformers can hinder optimizations.
05:27:37 <cocreature> if you want to be sure, look at the core
05:27:39 <dminuoso> I think edward held a rather complicated talk in Poland about monad transformer lenses to address this?
05:27:48 <Ariakenom> in this case it will probably specialise to the same thing
05:29:12 <Ariakenom> I mean even the monomorphic function has a bunch of optimisation that you want GHC to do. So you're not being safe either way :p
05:33:58 <tdammers> in theory, we could go for full-program optimisations, then we could inline and specialise across modules, but we would also lose incremental builds, which is kind of a big deal
05:34:29 <dminuoso> tdammers: I suppose it might completely destroy performance as well?
05:34:35 <dminuoso> I mean the performance of GHC itself.
05:35:27 <Ariakenom> well GHC exports some interface files that lets it do some cross module optimisations, don't it?
05:36:01 <tdammers> dminuoso: yes, because GHC would have to recompile the entire dependency tree every time
05:38:07 <dminuoso> Ariakenom: Right, but that's not the same as full program optimization.
05:38:48 <tdammers> the key word in that sentence being "some"
05:39:17 <dminuoso> Dont interface files mainly exist to facilitate *inlining* across modules?
05:41:31 <cocreature> you also need the source if you want to specialize
05:42:28 <__monty__> Couldn't full program optimisation be another -O level? Then you can decide whether it's worth giving up incremental builds or not.
05:43:24 <tdammers> __monty__: it's not that simple; full-program optimization implies that GHC's intermediate code gets merged at a much earlier stage of compilation
05:43:52 <Ariakenom> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/IfaceFiles
05:45:01 <dminuoso> I've already heard of people needing 32GiB to compile their haskell programs.
05:45:10 <dminuoso> And that's with module-by-module...
05:45:27 <berndl> Wow. That sucks.
05:46:49 <dminuoso> But that was on reddit, lets see if I can find that thread again..
05:46:54 --- mode: glguy set +v Mrbuck
05:49:02 <Putonlalla> I've gone up to 4 GB before.
05:51:15 <dminuoso> Or maybe it was this trac issue https://ghc.haskell.org/trac/ghc/ticket/15304?cversion=1&cnum_hist=3
05:56:15 <exarkun1> How do I make `stack hoogle ...` return a package name with the search results?
05:57:33 <exarkun1> And how do I make intero notice changes to my cabal file?
06:05:06 <Dark_Ethereal> exarkun1: WRT intero, I run "stack build --dependencies-only" then I run the intero restart command in emacs.
06:06:26 <Dark_Ethereal> I use spacemacs so I just hit "SPACE m i r" and it does the rest.
06:08:24 <xsperry> Dark_Ethereal, did you manage to get proper autoindenting of haskell code in spacemacs? I am using spacemacs' haskell layer, but the auto indentation is useless to the point where I'd just prefer if it just kept indentation of last line and let allow me to indent myself
06:08:51 <xsperry> (note: I am using rather old spacemacs)
06:09:06 --- mode: glguy set +v Mrbuck
06:09:54 <Mrbuck> hi
06:10:51 <Dark_Ethereal> xsperry: Uuuh... probably not? Whenever I start a new line it starts indented by one level and it drives me mad...
06:10:51 <Dark_Ethereal> But it often indents by the amount I want it to when hitting tab to make sure things align with what's on the line before.
06:11:47 <Dark_Ethereal> Mrbuck: \o
06:11:56 <Mrbuck> hi I want to explore haskell languahe and I fonf haskell wiki boon only free one 
06:12:03 <Mrbuck> but its very big 
06:12:20 <Mrbuck> Haskellreally very big language ?
06:12:49 <xsperry> Dark_Ethereal, same thing happens here. I thoroughly enjoy spacemacs otherwise, being a long-time emacs and vim user. 
06:13:14 <Putonlalla> Perhaps big, but not very, Mrbuck.
06:13:30 <Dark_Ethereal> xsperry: I'm pretty sure there's a way to disable the newline indent behavior... I just haven't got round to it.
06:13:49 <Mrbuck> Putonlalla:  bigger than java ?
06:13:51 <__monty__> I consider the language quite small actually. The concepts are pretty big though : )
06:14:03 <Putonlalla> Certainly not. Java is enormous.
06:14:38 <Mrbuck> I am asking because I got few holodays and I want to finish eiher racket or haskell bioth I want to do but only 20days holidays
06:14:40 <Dark_Ethereal> Mrbuck: It's a smallish language, but you have to learn a lot of the ecosystem to understand how to use it and be useful with it, IMO
06:16:02 <xsperry> Dark_Ethereal haskell-indent-mode and haskell-indentation-mode control indentation mode, but I wasn't able to make it work properly
06:16:33 <Dark_Ethereal> Learning haskell as a syntax is pretty easy. Learning how to use it to make professional programs? That takes a lot longer...
06:21:04 <dminuoso> Mrbuck: Haskell is not something you learn in x days and are competent.
06:21:10 <dminuoso> This actually applies to most languages.
06:21:34 <dminuoso> http://norvig.com/21-days.html
06:22:14 <Mrbuck> dminuoso:   I read it so many times but I feel I need one language I should be equipped with write everything in it...be good in it 
06:22:38 <dminuoso> Mrbuck: Becoming good is a process that takes time and practice.
06:22:59 <dminuoso> Mrbuck: The other part, Haskell would work just like Java or any other general purpose programming language would.
06:23:10 <Mrbuck> ok I agree and every one here Haskell is their primary langauge 
06:23:17 <dminuoso> No.
06:23:33 <dminuoso> There's some people here that just learn Haskell as a private project, others may use Haskell from time to time
06:23:46 <Mrbuck> what is your primary one ?
06:23:52 <dminuoso> Mrbuck: Mine has become Haskell.
06:24:03 <dminuoso> But that's relatively new.
06:24:16 <Mrbuck> racket is not bad too i feel
06:24:26 <Mrbuck> but its not used as primary language atleast
06:24:45 <dminuoso> Mrbuck: The "primary language" depends on what you do mainly.
06:25:04 <Mrbuck> what we can do with racket it is only educational 
06:25:09 <dminuoso> Mrbuck: If you do web development, then perhaps something like JavaScript or a language that compiles into JS would be a good candidate.
06:25:47 <dminuoso> Mrbuck: Racket is also used in production software.
06:26:06 <Mrbuck> really ? I dont know 
06:26:09 <dminuoso> Albeit it's not very popular for that. But popularity might not mean anything.
06:26:24 <Mrbuck> even haskell isnt popular yeah
06:26:41 <dminuoso> Right, but we have a vibrant community and a pretty rich ecosystem of packages. :)
06:26:49 <dminuoso> Which is what, to me at least, really counts.
06:27:09 <Mrbuck> dminuoso:  you either self employed or student ?
06:27:15 <dminuoso> Mrbuck: Im employed.
06:27:41 <__monty__> As they're both schemes learning racket would probably make it easy to pick up guile which is the language of choice of the GNU project going forward it seems. So could be useful.
06:29:55 <Mrbuck> I see many people use haskell even in AI and deep learning
06:30:11 <Mrbuck> Good
06:30:58 <Taneb> Mrbuck: the company I'm at uses Haskell with both deep learning and hardware design
06:31:24 <Mrbuck> Taneb:  which company ?
06:31:39 <dminuoso> Mrbuck: Haskell is a general purpose programming language that can be used for virtually anything.
06:31:51 <Taneb> Mrbuck: Myrtle
06:31:57 <dminuoso> Mrbuck: Maybe it might be helpful to understand areas where it is *not* good at.
06:32:03 <Taneb> Mrbuck: https://www.myrtle.ai/
06:32:41 <Mrbuck> Thank you Taneb 
06:32:47 <Mrbuck> dminuoso:  where it is not good at ?
06:33:19 <dminuoso> Mrbuck: It's not particularly good for embedded systems where you need tight control over memory management, because Haskell uses a garbage collector.
06:33:30 <dminuoso> Mrbuck: Or generally for bare metal development.
06:33:37 --- mode: glguy set +v norb
06:33:58 <norb> > catch @SomeException (return (error "fail")) (const (return "sucess!"))
06:33:59 <Mrbuck> ok I dont even know what are embeded systems
06:34:00 <lambdabot>  error:
06:34:00 <lambdabot>      Pattern syntax in expression context: catch@SomeException
06:34:00 <lambdabot>      Did you mean to enable TypeApplications?
06:34:08 <norb> % catch @SomeException (return (error "fail")) (const (return "sucess!"))
06:34:08 <yahb> norb: "*** Exception: fail; CallStack (from HasCallStack):; error, called at <interactive>:54:31 in interactive:Ghci43
06:34:59 <norb> isnt it supposed to return "success!"?
06:35:09 <dminuoso> norb: catch catches exceptions thrown by throwIO
06:35:17 <dminuoso> error is something.. different.
06:35:29 <Mrbuck> I have one question may be funny....Say I know only haskell and I will apply to java job what are the odds they can select me when I solve all the problems they gave using haskell...It should be 100% right
06:35:36 <norb> so it cant catch e.g.
06:35:39 <norb> > undefined
06:35:41 <lambdabot>  *Exception: Prelude.undefined
06:35:46 <dminuoso> or.. mmm
06:36:01 --- mode: glguy set +v LaurentRDC
06:36:23 <Taneb> Mrbuck: if I was looking for applicants for a Java position I wouldn't consider someone who didn't know a language reasonably close to Java.
06:36:57 <Taneb> (I'd also rethink my life choices, I don't know Java)
06:37:05 <Mrbuck> Taneb:  but you see Python guys can apply to java and vice versa
06:37:46 <__monty__> dminuoso: How about Ivory, Atom, Copilot, Lava? Don't these make haskell suited for embedded work?
06:38:16 <norb> how can a polymorphic value like (error (x::String)) or undefined be caught in an IO setting ?
06:38:19 <Taneb> Mrbuck: those are a lot closer together
06:38:34 <dminuoso> norb: You first have to `evaluate` it.
06:38:37 <Taneb> But, I'm not hiring Java programmers. If you want to apply for a job, apply for a job and let them decide
06:38:40 <dminuoso> norb: the thing you need to understand is how `error` works.
06:38:46 <exarkun1> Mrbuck: Software hiring practices are kind of like flipping a coin.
06:38:55 <exarkun1> Mrbuck: If you can come up with a prediction method that's better than 50% accurate you'll make billions.
06:39:04 <__monty__> Mrbuck: There's too many candidates who *do* know java. The other way around is different though. There's far fewer applicants for haskell jobs so they may hire java developers.
06:40:15 <Mrbuck> I want to learn Haskell and the where can I find jobs I see stackoverflow job no results at all :(
06:40:22 <dminuoso> norb: You're getting stabbed by a bottom lingering in a thunk. Exceptions are something different.
06:40:27 <norb> > catch @SomeException (evaluate undefined) (const (return "sucess!"))
06:40:30 <lambdabot>  error:
06:40:30 <lambdabot>      Pattern syntax in expression context: catch@SomeException
06:40:30 <lambdabot>      Did you mean to enable TypeApplications?
06:40:34 <norb> % catch @SomeException (evaluate undefined) (const (return "sucess!"))
06:40:34 <yahb> norb: "sucess!"
06:40:52 <Mrbuck> https://stackoverflow.com/jobs?q=haskell
06:41:08 <higherorder> Hi! I am having an issue with Stack (dependencies). My dependencies seem well specified in package.yaml, and yet hwne i try to compile (stack build) I am getting errors (i.e. Could not find module ‘Data.Aeson.Embedded’, etc).
06:41:13 <dminuoso> norb: may I ask what you are trying to do?
06:41:14 <mlehmk> Haskell has so many tools to avoid exceptions alltogether
06:41:25 <higherorder> here is my package.yaml: https://gist.github.com/hmaurer/5931e4cf1955a537b8f817b073fcebc3
06:42:01 <norb> dminuoso: instead of using maybe to always be able to return a value, but to catch the error it throws.
06:42:04 <norb> :t undefined
06:42:05 <lambdabot> a
06:42:12 <dminuoso> norb: that sounds wrong.
06:42:20 <norb> its faster?
06:42:21 <dminuoso> norb: You might be interested in this:
06:42:33 <dminuoso> % let note = flip maybe pure . throwIO
06:42:33 <yahb> dminuoso: 
06:42:36 <dminuoso> % :t note
06:42:36 <yahb> dminuoso: Exception e => e -> Maybe a -> IO a
06:43:09 <dminuoso> norb: Use Maybe, it's really valuable.
06:43:27 <Dark_Ethereal> Mrbuck: Yeaaaah, getting a job in your area in Haskell is going to be... a struggle, especially if you haven't already done Haskell professionally
06:43:45 <norb> but fmaping over it can be avoided? it almost doubles the time taken for a simple trverse
06:44:03 <Mrbuck> Dark_Ethereal:  I am thinking to fill my github page with projects is haskell
06:44:10 <Mrbuck> then ?
06:45:05 <dminuoso> norb: Do you have a code sample to look at?
06:45:14 <Dark_Ethereal> Haskell is my preferred language, but unfortunately it's not a super popular language, industry-wise
06:45:21 <dminuoso> norb: Trying to escape `Maybe` might be an indication of bad design/thinking.
06:45:22 <norb> dminuoso: nearly 
06:45:38 <norb> if its faster it might be good thinking!
06:45:58 <norb> not sure how the maybes get inlined...
06:46:08 <dminuoso> norb: Just show us what you have maybe :)
06:46:09 <Ariakenom> Mrbuck: "I am thinking to fill my github page with projects is haskell" like this? https://github.com/ekmett
06:47:21 <Mrbuck> Ariakenom:  yeah but he look like a very big guy who does a lot, i am very small guy :( 
06:47:29 <dminuoso> Mrbuck: How do you think he got there?
06:47:38 <dminuoso> By just writing stuff. :-)
06:47:43 <Dark_Ethereal> I don't have the formal education to be Kmett...
06:47:43 <dminuoso> And learning. And reading.
06:47:52 <tdammers> norb: can you post some benchmarking code that shows the performance difference? because I'm kind of sceptical about blaming Maybe for it
06:48:04 <dminuoso> Dark_Ethereal: funny thing, so I was just in london - phadej gave a really fancy talk about implementing statically typed functional languages.
06:48:16 <norb> tdammers: ok, brb
06:48:24 <dminuoso> Dark_Ethereal: The thing is - formal education is nonsense. :P
06:48:27 <dminuoso> Students are not taught.
06:48:31 <dminuoso> Students learn by themselves.
06:49:03 <dminuoso> University just gives you some direction - but in the end it's you who's spending endless nights reading books, writing papers, testing things.
06:49:50 <Dark_Ethereal> As someone who has screwed up an Aerospace engineering course, that direction can be really valuable... and the certification sure is handy for CVs
06:50:22 <tdammers> well, formal education isn't really about maximizing learning
06:50:33 <tdammers> the main purpose is a bureaucratic one
06:51:26 <tdammers> a formal degree is proof of proficiency - but only in the bureaucratic reality. whether you are actually competent in the physical reality is quite orthogonal.
06:52:01 <milesrout> what a load of crap
06:52:31 <__monty__> I think the main learning advantage you get from universities is the concentration of like minded people. That definitely helps imo.
06:52:34 <exarkun1> tdammers (IRC): Don't forget wealth transfer away from middle class
06:52:44 <lkurusa> __monty__: YES
06:52:53 <lkurusa> word
06:53:02 <Dark_Ethereal> _monty_: aye
06:53:09 <tdammers> that said, the rituals that tie the bureaucratic reality to the physical reality often lead to circumstances that can help actual learning
06:53:14 <merijn> __monty__: I think that *highly* depends on your specific university and lecturers
06:53:24 <milesrout> __monty__: and access to experts in the field to learn from
06:53:42 --- mode: glguy set +v Mrbuck_
06:53:43 <merijn> __monty__: I've had quite a large number of classes that'd be extremely hard to learn yourself without guidance unless you were extremely motivated and stubborn
06:53:45 <milesrout> university courses teach you what you need to know
06:54:29 <milesrout> the number of people that learn to program from online tutorials or learn maths from youtube videos who don't actually understand what they're doing but are just basically cargo culting
06:54:33 <milesrout> it's not a small number
06:54:54 <Mrbuck_> who is aerospace engineer here ?
06:55:02 <exarkun1> milesrout (IRC): yes but the same is true for programmers who learn at university.
06:55:06 <Mrbuck_> haskell used in aerospace ?
06:55:09 * [exa] read "who is aerospace beginner here"
06:55:14 <[exa]> I am beginner yes.
06:55:15 <__monty__> The number of people that learned to program at my uni and don't understand what they're doing isn't negligible either though.
06:55:23 <dminuoso> milesrout: Equivalently there's a whole battery of bad university out there.
06:55:37 <merijn> exarkun1: There's a bunch of knowledge gaps I frequently encounter in self/online taught people that's less common in people that studied at the 2 universities I'm familiar with
06:55:56 <Dark_Ethereal> Mrbuck_: I said I failed an Aerospace Engineering course, I'm not an aerospace engineer. 
06:56:03 <dminuoso> milesrout: When an institute gets financed by the number of PhD titles it awards, then suddenly a professor is starting to have 10+ PhD students with very little interest in the actual research.
06:56:09 <milesrout> yeah but there's a way to measure that. taking 'got a degree' as a measure of anything? probably not worth much, I'll give you that
06:56:21 <milesrout> 'got a degree with an A average' means a lot even at a 'bad' university
06:56:26 <Mrbuck_> Dark_Ethereal:  I was disconnected aerospace is most difficult field I believe 
06:56:46 <__monty__> milesrout: Heh, I've experienced the opposite.
06:57:08 <exarkun1> merijn: yes, and vice versa.
06:57:12 <merijn> milesrout: I dunno, average grades in a good program might be more useful than great grades in an awful program
06:57:18 <merijn> exarkun1: vice versa less so
06:57:30 <merijn> exarkun1: tbh, I've never really encountered the reverse
06:57:33 <exarkun1> merijn: maybe in your experience
06:57:46 <exarkun1> merijn: all I can say is that my anecdotal experience is different from yours.
06:57:47 <Mrbuck_> My doubt i this : " many jobs dont care language and they do care concepts and we can use any language we like" wehn appearing such job interviews do we still bother language?
06:57:48 <merijn> exarkun1: What kind of knowledge gaps do you see frequently in university grads?
06:57:51 <milesrout> merijn: i doubt that. most 'good programs' at least in the US have enormous levels of grade inflation
06:57:59 <exarkun1> merijn: if you want a concrete answer go do a high-quality study :)
06:58:20 <milesrout> still this is all very anecdotal
06:58:27 <Dark_Ethereal> Mrbuck_: I don't know if Aerospace is harder than say, a degree in pure Maths or Physics... but aye, it was tough... too tough. I should've done something else instead of wasting my cushy UK government backed student loan.
06:59:08 <milesrout> obviously people exist with every combination of smart/not, competent/not, goodgrades/not, degree/not, etc.
06:59:24 <Mrbuck_> Dark_Ethereal:  I am not aerospace student or had any edcation but out of intretst I read book of aerodynamics by JD anderson 
06:59:41 <__monty__> merijn: I'd expect practical knowlegde to be lacking among the uni candidates if both groups have spent the same number of years either learning about programming or actually programming.
06:59:45 <milesrout> i don't think it's a stretch though to say that having good grades is going to correlate with being smart, knowing the material and being highly competent in practice
07:00:10 <Mrbuck_> I liked it but I couldnt use that knowledge anywhere and as times passed I forgot everything 
07:00:25 <Mrbuck_> now Looking to learn some programing
07:00:34 <milesrout> __monty__: I think fairer would be to compare someone with a degree and two years experience vs. someone with five years experience. I'd much rather the former, all things being equal. 
07:01:09 <merijn> __monty__: Yes, but if you've got a shitty program that only taught you cargo cult Java, then you'll have spend all that effort on not very useful things
07:01:27 <Dark_Ethereal> Mrbuck_:  good call. The world still needs more of us.
07:01:34 <merijn> It also depends what kinda work we're talking about
07:01:35 <milesrout> if you only learnt cargo cult Java then you didn't learn computer science
07:01:48 <milesrout> i don't want to be elitist but yikes
07:01:56 <merijn> If it's frontend CSS wrangling then sure, a CS degree isn't going to be very useful
07:02:23 <milesrout> I'd have more respect for someone with a CS degree that didn't involve programming at all than one that involved Java
07:02:47 <milesrout> and i don't know why people expect people with (real) computer science degrees to be software engineering extraordinaires with no experience
07:02:56 <dminuoso> milesrout: I honestly believe that just as many cargo cults are amongst students in university as there are outside. 
07:02:57 <milesrout> nobody expects someone with a BSc in Physics to build them a bridge
07:03:00 <__monty__> milesrout: CS degrees that don't involve java *at* *all* are kind of a rarity though.
07:03:09 <Dark_Ethereal> milesrout: Ah, but there's computer science degrees, and there's "computer science" degrees.
07:03:26 <Mrbuck_> I lack cs degree and I reget now
07:03:49 <merijn> dminuoso: I think that depends on country and university
07:03:50 <Mrbuck_> my enture life could have been something if I had studied cs in my life
07:03:51 <milesrout> my university moved all the java crap into a 'software engineering' BE specialisation a few years ago
07:03:56 <Putonlalla> Speaking of CSS, I recently wrote a module to perform exact unit arithmetic, so that the resulting code doesn't cause rendering defects due to rounding errors in browsers. Do you think it would be useful enough to finish up and put on Hackage?
07:03:59 <milesrout> a NZ university for what it's worth
07:04:07 <norb> tdammers: cant seem to install criterion...
07:04:21 <Taneb> milesrout: my uni seems to have been going the other way
07:04:23 <Dark_Ethereal> I'm guessing it's more of an issue in the US but it seems like they label the study of software development "computer science" and nobody studies "software development/engineering".
07:04:50 <milesrout> Taneb: nice to see you again btw :)
07:04:59 <Taneb> You too!
07:05:14 <milesrout> i forgot you were also into Haskell-y stuff
07:05:21 <Dark_Ethereal> Mrbuck_: I know that feeling
07:05:41 --- mode: glguy set +v norb_
07:06:07 <Taneb> milesrout: been here a lot longer than you have :P
07:06:26 <norb_> would anyone be able to run this? https://pastebin.com/ViNFnSEX
07:06:54 <milesrout> Taneb: yeah I remember you were into Haskell stuff like 5+ years ago
07:07:06 <Mrbuck_> Dark_Ethereal:  ok but now what you are doing ? Why you are in haskell now ?Doing any thing related to haskell ?
07:09:34 <Ariakenom> Putonlalla: sounds cool, I wouldn't have any use of it myself though. do you wanna entertain me with details, I enjoy numeric stuff?
07:10:15 <gentauro> Putonlalla: does you module make fonts load faster?
07:10:17 <gentauro> :|
07:10:22 <gentauro> (I hate CSS with a passion)
07:10:32 <tdammers> norb_: I don't think this you need criterion to figure this one out.
07:10:48 <Dark_Ethereal> Mrbuck_: I've been learning Haskell in my free time for about 2... 3 years now? But I haven't really made anything useful and functional yet... I'm getting there with my current project but... progress has been slow.
07:10:50 <gentauro> https://imgur.com/gallery/Q3cUg29
07:11:00 <tdammers> norb_: run it with profiling, and observe memory usage
07:11:09 <merijn> Dark_Ethereal: What is your current project?
07:11:51 <gentauro> somebody forwareded me today that their bank is going to have an inspiration talk about Haskell
07:11:55 <gentauro> which is nice
07:11:56 <Mrbuck_> Dark_Ethereal:  but for 2-3 years what yu are doing ?
07:12:09 <Mrbuck_> 2-3 years is hell lot of time isnt it ?
07:12:39 <mniip> Mrbuck_, "how to learn haskell in less than 5 years"
07:12:46 <Dark_Ethereal> Mrbuck_: Not with my dire mental health
07:13:15 <gentauro> Mrbuck_: I would rather spend 2-3 years learning Haskell than C++
07:13:38 <merijn> Meh, I think learning haskell properly took me like 4 attempts spread over 2-3 years
07:13:49 <veverak> ahmm
07:13:52 <Ariakenom> % print "Hello world!"
07:13:52 <yahb> Ariakenom: "Hello world!"
07:13:58 <veverak> interesting like C++ is spelled a lot here :)
07:13:58 <Ariakenom> how hard could it be?
07:14:20 <Mrbuck_> 2-3 years I think you guys kidding if it takes 2-3 years why do we hve 1000+ users here who know haskell
07:14:26 <gentauro> C++ and Haskell came from the same place and the same time (Cambridge Uni)
07:14:44 <Mrbuck_> haskell glasgow no ?
07:14:46 <veverak> gentauro: that explains a lot
07:14:55 * veverak uses both of them a lot
07:14:59 <tdammers> I only took one attempt, but it certainly took me on the order of 2-3 years to get fully productive (in the sense of matching or outpacing my productivity in other languages)
07:15:04 <dminuoso> Mrbuck_: It does not make much sense to put a time on how long it takes.
07:15:13 <gentauro> There is a talk from SPJ where he puts on his old jerser (red one) where he talks to Bjarne Stroustrup
07:15:15 <veverak> well, I learned haskell at uni but tbh I did not took much from the course
07:15:17 <gentauro> and reminds of that
07:15:20 <dminuoso> unless you put it into context like tdammers said.
07:15:21 <veverak> real "learning" started year later
07:16:04 <gentauro> I use to say: "If you want to learn a programming language, code some real stuff, don't go through tutorials"
07:16:08 <gentauro> and it seems to work
07:16:13 <Ariakenom> gentauro: seems like an interesting talk. is it uploaded somewhere?
07:16:19 <Mrbuck_> I have a queation how long it takes to learn python like you said 2-3 years for haskell
07:16:29 <gentauro> you only know the usability of a `tool` if you test it
07:16:31 <Dark_Ethereal> Mrbuck_: here's the way I think about it: learning to program for the first time takes about 2-4 years... and then your average student will know imperative and Object Oriented programming... but Purely Functional Programming? That's like a whole new paradigm... in fact it's like a new paradigm of paradigms. It's very similar to starting from scratch in some ways... but most of us are probably here because we feel that it's worth the 
07:16:31 <Dark_Ethereal> fort.
07:16:32 <Mrbuck_> even python takes ayear is your answer I belive
07:16:46 <tdammers> no, python takes about 3 weeks
07:17:05 <Mrbuck_> tdammers:  why do you say like that ?
07:17:11 <Mrbuck_> both need practise
07:17:15 <tdammers> because it took me 3 weeks to learn python
07:17:26 <Mrbuck_> tdammers:  what about Haskell ?
07:17:35 <tdammers> 2-3 years, I'd say
07:17:40 <gentauro> Ariakenom: I will try to find the talk
07:17:49 <Dark_Ethereal> Haskell is one of the very few purely functional programming languages you're ever likely to learn. Learning Haskell isn't just about learning the syntax, it's about learning the purely functional paradigm.
07:17:49 <Ariakenom> nice
07:17:55 <tdammers> however, that's mostly because after 3 weeks with Python, I started hitting its limitations
07:18:01 <Mrbuck_> soething wrong both need oractsie and how this can happen ?
07:18:07 <tdammers> while with Haskell, I'm still mostly running up against my own mental limitations
07:18:31 <berndl> Dark_Ethereal: I don't the "purely" part applies.
07:18:45 <Dark_Ethereal> I think it does... from a certain point of view
07:19:09 <tdammers> and of course, Python is extremely similar to languages I already knew very well at the time - PHP, C, C++, Java, JS, C#; whereas Haskell is different enough to make your brain hurt quite a bit
07:19:11 <Dark_Ethereal> In the same way Darth Vader killed Anakin Skywalker... from a certain point of view.
07:20:17 <gentauro> Ariakenom: It's this one -> https://www.youtube.com/watch?v=06x8Wf2r2Mc
07:20:42 <gentauro> (I don't remeber the exact minute/second but it's in the begining where he talks to Bjarne)
07:21:10 <__monty__> gentauro: Thanks!
07:21:15 <gentauro> u welcome
07:22:02 <gentauro> where I see the power of Haskell (if used correctly) with regard of other languages is that it helps you enforce structure and design
07:22:33 <haasn> Is there something like a "parallel filter"? parMap is easy to write using `parallel`, by just forcing the resulting elements of the map in parallel. But the naive approach `filter f list `using` parList rseq` doesn't directly work, since the decision between (:) and [] on the filter already forces the evaluation of `f x` for each element
07:22:38 <Ariakenom> gentauro: Oh nice, thanks! I've seen some version of that. I'll have a look for bjarne later
07:22:40 <haasn> so this is serialized
07:22:41 <gentauro> many people start out with Python tools libraries. Once the developer base become to big, it's very difficult to maintain design
07:23:10 <haasn> What I could do in theory is return something like [ (x, f x) | x <- list ], then force the second tuple pair of each list element in parallel, and then `filter` the result of that
07:23:13 <haasn> But this is ugly
07:23:15 <haasn> isn't there a cleaner way?
07:23:28 <gentauro> Ariakenom: IIRC, SPJ mentions how Haskell and C++ come from the same place but are totally different
07:23:50 <maerwald> gentauro: I don't feel like maintaining design in haskell is easier
07:24:10 <maerwald> the only thing that is constantly easier is refactoring (but that doesn't mean you are actually maintaining design)
07:24:28 <maerwald> refactoring a large python codebase is difficult
07:24:54 <veverak> "where I see the power of Haskell (if used correctly) with regard of other languages is that it helps you enforce structure and design" -> I think same of C++
07:25:10 <veverak> of course it is more complex because C++ has the philosophy "it's coders decision to use unsafe things.."
07:25:13 <Ariakenom> haasn: that looks good to me. tweak: parmap to [Maybe a] and filter Nothings
07:25:27 <veverak> strong type system = <3
07:25:33 <haasn> Ariakenom: oh good idea
07:25:38 <gentauro> maerwald: it's easy if you use Haskell "in a special way" ;) -> http://uniprocess.org/effects.html
07:25:43 <Ariakenom> <3 = strong type system
07:25:58 * Ariakenom must always reverse = used casually
07:26:05 <veverak> lol :)
07:26:31 <gentauro> veverak: "C++ has the philosophy "it's coders decision to use unsafe things.." You have the same thing in Haskell
07:26:40 <gentauro> just use referential transparency
07:26:45 <veverak> gentauro: I know
07:26:48 <maerwald> gentauro: I don't see your point
07:26:48 <haasn> catMaybes $ parWith rseq (\x -> if f x then Just x else Nothing) list
07:26:52 <haasn> I wonder if there's a way to make that lambda cleaner
07:26:58 <veverak> gentauro: it 's just that both languages has different approach to it
07:27:04 <haasn> maybe x <$ guard (f x)
07:27:06 <gentauro> maerwald: many Haskellers doesn't ;)
07:27:06 <maerwald> that site explains very basic concepts
07:27:07 <haasn> but that's not exactly prettier
07:27:09 <veverak> gentauro: (hence I consider both preferable for differentasks)
07:27:15 <maerwald> gentauro: doesn't what
07:27:46 <gentauro> well that site tells you have to limit effects recursively in your app
07:28:03 <gentauro> which means that code branches are limited to `only` specific logic
07:28:07 <maerwald> again: that is basic concepts
07:28:13 <gentauro> what you normally see in most Haskell is IO everywhere
07:28:19 <maerwald> no.
07:28:20 <gentauro> that makes code unmantainable
07:28:30 <merijn> gentauro: "most haskell" that depends a lot on where you look
07:28:43 <gentauro> I mean IO is like global variables in other languages
07:28:45 <merijn> Also, most "IO everywhere" definitely does not make code unmaintainable
07:28:52 <maerwald> exactly
07:28:55 <gentauro> Haskellers need to learn how to limit/granulate effects
07:28:58 <gentauro> for better designs
07:29:05 <dminuoso> The thing with IO is that you can *connect* pure code to it.
07:29:07 <maerwald> I think they already know it
07:29:10 <norb_> it seems to be slower, but maybe thats because the IO stuff is slowing it down... https://pastebin.com/GvsvbJx4
07:29:13 <maerwald> and it doesn't make design that much easier
07:29:17 <dminuoso> I mean there is no: (+) :: Num a => a -> a -> IO a
07:29:28 <dminuoso> So clearly we are using plenty of *pure* code by fact of most of base being pure.
07:29:43 <maerwald> effects are just a tiny part in the design space
07:29:51 <maerwald> there are tons of more problems
07:29:53 <gentauro> maerwald: I agree
07:30:09 <merijn> norb_: GHCI benchmarks are a bad idea
07:30:28 <gentauro> but ensuring a clear separation between layers, makes design and implementation very easy
07:30:28 <merijn> norb_: GHCI uses interpreted bytecode and not all optimisations are active
07:30:30 <maerwald> and haskell doesn't shine that much when it comes to effects. We don't have an effects system and different kind of effects expressions are not composable
07:30:36 <norb_> right, it wont do the inlining at all?
07:30:39 <dminuoso> norb_: Also do you have the *real* code you are trying to use?
07:30:51 <dminuoso> norb_: Trying to profile with toy code in GHCi is just doubly wrong. :P
07:31:11 <norb_> its not best to show a least working example?
07:31:18 <maerwald> imo, the only thing that makes haskell really easier is refactoring...
07:31:30 <maerwald> but that is basically what you should do most of your time...
07:31:45 <gentauro> maerwald: I find it very easy to prototype
07:31:50 <maerwald> I disagree strongly
07:31:55 <maerwald> python is much better for prototyping
07:31:57 <gentauro> when I'm done, I begin the refactoring to make code clearn and concise
07:32:13 <gentauro> and ofc limit the effects on code branches
07:32:33 <maerwald> I start with python, then I throw it away and start with haskell after I know the rough edges and have a working MVP
07:32:35 <gentauro> that will make others that need to refactor understand initial desgin before "breaking" everything
07:32:53 <gentauro> I worked profesionally with F# for 3 straight years
07:32:59 <gentauro> I tend to do the same POC in F# and then Haskell
07:33:23 <gentauro> First when I decided to not install F# on my new laptop and only Haskell, I begin to understand `the ways` of Haskell
07:33:23 <maerwald> I don't know what professionally means, you mean for money?
07:33:26 <gentauro> ;)
07:33:29 <gentauro> maerwald: yes
07:33:57 <gentauro> that's where you see how you go from beatifull code to usable code
07:33:58 <maerwald> usually, it's much more valuable when you don't do something professionally, because you tend to explore the design space way more
07:34:09 <maerwald> don't have feature pressure
07:34:12 <maerwald> don't have project managers
07:34:17 <maerwald> don't have other people get in your way
07:34:20 <maerwald> don't have deadlines
07:34:25 <gentauro> maerwald: if I give you access to my bitbucket, you will see the graveyard of all my `unfinished` projects
07:34:27 <maerwald> those things don't make your code any better ;)
07:34:37 <gentauro> I learned that you only push yourself if you actually have a deadline
07:34:51 <maerwald> my experience is different, but ok
07:34:56 <noumenon> you mean you learned that *you* need someone to push you
07:35:07 <gentauro> not really
07:35:07 <dminuoso> cocreature: By the way, thanks a lot again for helping me out on monad transformers. It finally completely *clicked* - and Im getting a feeling on how to use mtl to create local effects - unliftio has become my best friend too now!
07:35:16 <maerwald> gentauro: how do you know how other people work then ;)
07:35:23 <dminuoso> But that really required reducing my main stack to just ReaderT. :)
07:35:31 <quicksilver> I'm fairly confident, having worked along and in big teams both with and without pressure and deadlines of this: people are different :)
07:35:32 <gentauro> if you want to make Haskell on a professional level
07:35:36 <norb_> dminuoso: is there a chance that the exception handling would be faster than the Maybe when compiled with optimisation flags?
07:35:45 <maerwald> gentauro: you mean haskell for money?
07:35:53 <gentauro> you will need to know where to compromise (and how) when a customer says: "There is no more money or time, wrap it up"
07:35:56 <dminuoso> norb_: I have no ability to tell you what faster means if I dont know what you are doing exactly.
07:36:10 <maerwald> I don't talk to customers
07:36:15 <gentauro> I can hear
07:36:19 <gentauro> and that's a huge problem
07:36:21 <norb_> well the loop functions are exactly as they would appear in a larger example..
07:36:22 <maerwald> why so?
07:36:24 <Putonlalla> What if that happens on day two, gentauro?
07:36:37 <gentauro> because you make what others tell you to do instead of what you customer base really wants
07:36:47 <maerwald> we don't have a customer base :)
07:36:56 <gentauro> maerwald: ?
07:36:57 <maerwald> too many assumptions :)
07:37:03 <dminuoso> norb_: So you are using exactly that code in production?
07:37:11 <maerwald> you are just talking about your own experience
07:37:17 <gentauro> maerwald: so you live on public funds?
07:37:17 <maerwald> in a specific domain
07:37:51 <gentauro> I mean if you don't have customers, you don't have a business
07:37:56 <maerwald> gentauro: lol
07:38:23 <gentauro> and if you don't have a business, I don't think your points are any valid when speaking about Haskell code in production (just my opinion)
07:38:26 <maerwald> gentauro: if you are running an online advertisement company, your developers don't talk to customers 
07:38:26 <remexre> Is there a good way to have a global variable for "maximum log level?" Right now my logger functions are (Show a => a -> IO ()), and I'd prefer not to make them ((Show a, MonadIO m, MonadReader LogLevel m) => a -> m ()), which was my second thought
07:38:35 <norb_> the slowLoop function, yes, the question is if there is a faster way if the use of Maybe is replaced by the handling of errors
07:38:36 <maerwald> gentauro: and many more examples
07:38:42 <maerwald> less assumptions please
07:39:23 <gentauro> if you run an online ad company, your customers are the people who buy your services
07:39:26 <gentauro> I mean ...
07:39:30 <dminuoso> norb_: the main issue with `catch` is that it will also catch async exceptions
07:39:33 <maerwald> gentauro: no
07:39:33 <gentauro> and so on
07:39:46 <maerwald> gentauro: you don't know your "customers"
07:39:59 <maerwald> you're just doing the backend, there are no customer requirements *anywhere*
07:40:31 <gentauro> maerwald: not to sound like a `c*nt` but how far down in the company are you placed?
07:40:32 <norb_> not sure if thats an issue
07:40:32 <dminuoso> norb_: but really try to profile this with GHC and optimizations enabled, it shouldn't be that bad - the type safety gained from Maybe greatly outweight the pains of filling pure with exception handling and unsafePerformIO
07:40:34 <dmwit> That's a weird way to think. Why not rebrand "customer" to talk about the folks that rely on your backend? Then you have customer requirements again as usual.
07:40:42 <gentauro> you clearly don't have a grasp on how you make money
07:40:46 <maerwald> gentauro: looool
07:41:25 <gentauro> nevermind, I can see that this will not go anywhere and it's also an off-topic
07:41:37 <maerwald> yes, disqualified
07:41:44 <norb_> dminuoso: if its a safe use of UnsafePerformIO and its faster there might be a counterargument 
07:42:25 <maerwald> dmwit: those are not customers, those are users (e.g. operations)
07:42:41 * dmwit shrugs
07:42:46 <dmwit> Okay. So you have user requirements.
07:42:48 <dminuoso> norb_: Be sure to at least catch only `ErrorCal` - also know that once you mix code with other code that may call `error` - then there's more interference
07:42:52 <maerwald> dmwit: yes
07:43:04 <Putonlalla> Here's a proof of concept, Ariakenom: http://tuplanolla.no-ip.org/tmp/csspc/
07:43:05 <dmwit> Why is that an important distinction to make for this discussion?
07:43:09 <dminuoso> norb_: But really, I'd like to see *your* code profiled with actual optimizations enabled.
07:43:14 <norb_> also, not sure how to benchmark the omptimised compiled code without criterion, which is not installing 
07:43:16 <maerwald> dmwit: a very important one
07:43:30 <dminuoso> norb_: you can use the RTS to profile your code
07:43:55 <maerwald> dmwit: development workflow and communication is fundamentally different
07:44:13 <dminuoso> norb_: or maybe just measure CPU time? *shrugs*
07:44:32 <gentauro> norb_: I learned here on how to use RTS for mem usage -> http://blog.stermon.com/articles/2018/08/13/haskell-safe-base64-only-depending-on-prelude.html
07:44:41 <dmwit> Development workflow and communication were not part of the discussion, so far as I can see.
07:44:51 <gentauro> when I write here (I mean this IRC channel) :)
07:44:52 <maerwald> dmwit: ofc communication was.
07:44:55 <maerwald> see above
07:45:40 <gentauro> norb_: wrong blog post -> http://blog.stermon.com/articles/2018/07/24/haskell-base64-encoding-with-profiling.html
07:45:41 <dmwit> You believe the communication is sufficiently different that the *medium itself* would prevent your users from saying "we've got to transition to go mode, wrap it up"??
07:46:14 <Taneb> I remember seeing a website where you could take diffs between different versions of libraries on Hackage
07:46:19 <Taneb> Does anyone know where that is?
07:46:22 <maerwald> dmwit: I cannot follow
07:46:30 <dmwit> same
07:46:33 <merijn> Taneb: "github"? ;)
07:46:42 <gentauro> Taneb: just like Elm semver?
07:46:47 <gentauro> that sounds interesting :o
07:46:59 <Taneb> gentauro: I'm not familiar with that
07:47:14 <cocreature> dminuoso: np, glad you figured it out :)
07:47:15 <Taneb> merijn: close but a lot of libraries are either not on GitHub or make it hard to see when they uploaded
07:47:35 <dminuoso> cocreature: MBC is so crazy, it made my head spin. :-)
07:47:39 <gentauro> Taneb: http://elm-lang.org/ (search form "Enforced Semantic Versioning")
07:47:44 <cocreature> dminuoso: mbc?
07:47:49 <dminuoso> MonadBaseControl
07:47:53 <cocreature> ah, yeah
07:47:58 <norb_> timeit just returned 0.00
07:48:06 <norb_> rrg
07:48:08 <gentauro> Taneb: that's one of the features I really miss in any language
07:48:09 <merijn> MonadBaseControl is super confusing
07:48:13 <dminuoso> cocreature: Like I had no idea how to reason whether any MonadBaseControl instance was lawful or not.
07:48:20 <gentauro> once you try it out, it's like "why is this not everywhere"
07:48:50 <cocreature> the problem with MonadBaseControl is also that even once you have somewhat understood it, it still behaves badly half of the time
07:48:57 <Dark_Ethereal> Urgh... How do you learn to solve problems with functions you compose with other functions instead of writing functions that just knock a small chip off the problem then call yet another function that does the next chip. I'm terrible at structuring a solution.
07:49:09 <merijn> Dark_Ethereal: Practice :)
07:50:01 <cocreature> functions solving part of the problem and delegating the rest to another function doesn’t sound too bad
07:50:01 <norb_> gentauro: that is a very complicated example
07:50:23 <gentauro> norb_: which one?
07:50:30 <norb_> the blog post linked
07:51:01 <norb_> might just try to see why criterion isnt installing properly...
07:51:26 --- mode: glguy set +v codedurr
07:51:31 <norb_> was trying to use cygwin for unix stuff and it might have broken something
07:51:54 <codedurr> albeit mostly to learn functional programming as a concept more than to use it in what we do
07:51:58 <cocreature> Taneb: are you looking for http://hdiff.luite.com/?
07:52:10 <gentauro> norb_: search for `profiling.bash` on that page
07:52:19 <gentauro> it shows how to write a script in order to profile :)
07:52:35 <gentauro> I think it was cocreature who pointed me in the right direction IIRC ;)
07:53:50 <Taneb> cocreature: that's exactly it
07:53:52 <gentauro> cocreature: oh Hdiff digs into implementation. Hmmm I guess that would be real `semantic versioning`
07:57:46 <norb_> ./base64 +RTS -p -h does not produce any output
07:58:06 <gentauro> norb_: you have to write the name of your binary
07:58:52 <codedurr> I worked with haskell years ago, have done several projects in it since then, but I get a general feeling that it is dying now more than it was then. Several major contributors have moved on and package updates less frequent. How does the community feel in general?
07:59:03 <gentauro> ./YOUR_BINARY_NAME_GOES_HERE like in `ghc -prof -fprof-auto -rtsopts -Wall -Werror -O2 --make Main.hs -o YOUR_BINARY_NAME_GOES_HERE`
07:59:47 <cocreature> codedurr: if anything, I feel like it has grown more popular rather than dying.
07:59:50 <gentauro> codedurr: I would say that thanks to `tooling` Haskell is really becoming usefull in PROD
07:59:57 <maerwald> uh-oh
08:00:07 <norb_> ghc -prof -fprof-auto -rtsopts -Wall -Werror -O2 --make Main.hs -o base64
08:00:12 <gentauro> I mean, just the thing that you can reproduce your builds with `stack` and their `LTS`
08:00:16 <maerwald> tooling war is one of the reasons major contributors left ;)
08:00:19 <gentauro> is pretty much a game changer
08:00:36 <norb_> so thats not it
08:00:47 <gentauro> norb_: yeah, that seems correct
08:01:08 <cocreature> norb_: it doesn’t write the output to stdout. it writes it to some *.prof file
08:01:12 <cocreature> so look for that
08:01:25 <maerwald> codedurr: I wouldn't say it's dying, but it's fleshing out it's primary domains, which are still well maintained
08:01:38 <cocreature> oh you passed -h in that case it’s a .hp file
08:01:39 <gentauro> norb_: you should see `base64.aux`, `base64.prof` and `base64.hp` files
08:01:44 <Ariakenom> Putonlalla: nice thanks
08:01:44 <maerwald> but it isn't as general purpose as other languages for sure
08:02:02 <gentauro> norb_: I convert my HP ouput to a graph with `hp2ps -c base64.hp`
08:02:02 <maerwald> in terms of ecosystem coverage
08:02:19 <norb_> ooh, fancy 
08:02:23 <gentauro> :)
08:02:32 <dolio> It isn't?
08:02:50 <maerwald> also, why not do reproducible builds with freeze files ;)
08:03:08 <codedurr> maerwald: kind of what I thought, thanks!
08:04:15 <merijn> codedurr: I think that's a wrong impression. Haskell adoption now is *much* higher than it was when I started around 2009
08:04:50 <merijn> codedurr: It's just that a bunch of big contributors (*cough* dons, Simon Marlow, etc.) are now getting paid obscene amounts of money by big corporations leaving less time for open source stuff
08:05:29 <gentauro> merijn: I would like to say the work the people from FP Complete has put in is amazing
08:05:41 <maerwald> Yes, adoption is higher, but also more focused on those domains that work well
08:05:42 <norb_> test1       Main     Main.hs:24:1-38          12.0   29.4
08:06:03 <gentauro> https://www.fpcomplete.com/blog/2018-haskell-survey-results
08:06:04 <maerwald> Maybe experimentation is a bit less than a few years ago, but that's ok
08:06:28 <norb_> test2       Main     Main.hs:27:1-38          20.0   29.4 
08:06:57 <merijn> gentauro: tbh, the fpcomplete survey has massive sampling bias
08:07:01 <norb_> so the version using maybe is still faster than the version using exception
08:07:30 <gentauro> merijn: yeah, but it helps "sell their product"
08:07:35 <gentauro> which in the end hels us all
08:07:39 <merijn> gentauro: My experience (from previous years, I haven't looked at this year) is that it is heavily skewed to newcomers and people buying into their ecosystem
08:07:45 <gentauro> I would <3 if every country had a FP Complete company
08:08:08 <maerwald> not sure starting a tool war was an amazing thing, but they maintain useful libraries
08:08:09 <gentauro> more of us would work with Haskell on a daily basis
08:08:19 <merijn> (Not to say you can't look at their results, just saying: Take them with a grain of salt)
08:09:06 <dminuoso> merijn: who is dons?
08:09:12 --- mode: glguy set +v koality
08:09:31 <merijn> dminuoso: Don Stewart, Haskell performance wizard extra-ordinaire
08:09:55 <merijn> Currently mostly known for posting pictures of cycling and sunsets to twitter when he's not working on closed source bank stuff :p
08:11:02 <maerwald> I prefer SPJs skiing pictures
08:11:16 <cocreature> merijn: he switched to facebook so no bank stuff these days :)
08:11:42 <sm> gentauro: you are right, but there's a continual pushback against fp complete-related things from a subset of the community
08:11:52 <Mrbuck_> Machine Learning engineer really do focus on language be it python or haskell...because they may just need to solve matrices ?
08:12:02 <ski> @quote dons
08:12:02 <lambdabot> dons says: i wish you success and may your lambdas always beta reduce.
08:12:12 <sm> so expect diverse opinions on that :)
08:12:24 <merijn> dminuoso: See also: https://ro-che.info/ccc/2
08:12:50 <dminuoso> merijn: Oh haha! I never understood that.
08:13:03 <dminuoso> Now that I do it's quite hilarious. :)
08:14:10 <gentauro> sm: Why is that? I mean, they made some awesome stuff?
08:15:05 <merijn> gentauro: Because a lot of their stuff is rather opinionated on how you "should" write Haskell. Specifically in a style that a lot of people strongly disagree with (for example a lot of the original mtl heavy style)
08:15:22 <norb_> but if a loop has to return maybe to see where it stops it becomes slower, it seems like just running it until it crashes should be faster, how can the exception handling be made to not slow it down?
08:15:26 <merijn> Also, Yesod's "lots of TH magic" approach.
08:15:54 <ski> norb_ : continuations ?
08:16:02 <norb_> go on!
08:16:17 <gentauro> merijn: ahhh. So they are "loud" :)
08:16:24 <gentauro> I don't see that as a problem
08:16:28 * ski quietly squeezes a codensity monad over norb_'s cuppa tea
08:16:35 <maerwald> You mean aggressive
08:16:55 <maerwald> Otherwise you haven't followed all those discussions that happened
08:16:56 <sm> gentauro: too long to explain. I think basically some healthy resistance to corporatisation/profit-infection of a common good, and some reactionary NIH, FUD and envy
08:17:07 <merijn> gentauro: I'm not saying it's a problem, I'm just saying whether those things are "high quality" depends a lot on your point of view
08:17:13 <dminuoso> merijn: The one thing I dislike, is not as much the TH part for example of Yesod, but that it's not very composable with other parts. That is it's not easy to pull something out of Yesod and just reuse it.
08:17:20 <sm> ie: growing pains 
08:17:21 <dminuoso> Thats what makes opinionated rather difficult.
08:17:44 <gentauro> dminuoso: I find that in a lot of Haskell libraries. So I choose to write my own :D
08:17:54 <dminuoso> Right now I started using postgresql-simple, for a bit I was afraid that it would be cumbersome to basically write out queries from hand and interact with the database.
08:18:08 <merijn> dminuoso: I take to make mine orthogonal and easily composable for that reason :)
08:18:09 <dminuoso> Turns out it requires maybe 50 lines of code to write my own abstraction that is clean and easy to reason about.
08:18:10 <ski> @quote reinvent.wheel
08:18:10 <lambdabot> sproingie says: i'd rather reinvent wheels when i have to learn how they roll anyway
08:18:12 <gentauro> I mean, I really dislike opinionated people who don't do any coding. But when people code alternatives, I welcome it :)
08:18:24 <norb_> ski: are you trolling?
08:18:33 <maerwald> dminuoso: not composable is a feature of strongly typed languages, haha...
08:18:35 <merijn> dminuoso: Today I found out I actually have non-zero users! \o/
08:18:46 <dminuoso> merijn: I heard!
08:18:46 <ski> norb_ : no, i'm a bit tired. what was the actual code you were wondering about ?
08:18:58 <dminuoso> merijn: I have *no* clue where I read about it, but I did somewhere.
08:19:02 <dminuoso> Or what library it was.
08:19:04 <merijn> #programming
08:19:09 <dminuoso> Right!
08:19:14 <merijn> aka where I go to troll when bored
08:19:14 <dminuoso> That must have been it
08:19:43 <norb_> ski: https://pastebin.com/ViNFnSEX
08:20:23 <merijn> dminuoso: I'm happy I finally did a first release of it, because it very elegantly solves a really annoying problem I kept having to reimplement :p
08:20:42 <gentauro> gotta grap a bite of food (starving)
08:20:46 <dminuoso> merijn: Do you have a link to the library?
08:21:11 <merijn> dminuoso: https://hackage.haskell.org/package/broadcast-chan-conduit-0.2.0.1/docs/BroadcastChan-Conduit.html#v:parMapM
08:21:28 <norb_> ski: this is the version that the numbers above were for; https://pastebin.com/VtQ5WaiP
08:21:44 <merijn> dminuoso: Basically the problem of "I have a conduit pipeline and a slow, blocking IO operations that I wanna do in parallel to speed things up"
08:21:54 <dminuoso> merijn: gotcha
08:22:17 <ski> norb_ : instead of `a -> Maybe a', you could use `a -> o -> (a -> o) -> o' (or perhaps even `a -> (a -> a) -> a'). so instead of using `maybe' to dispatch to the correct branch, you pass the two branches separately, and let the producer directly call the appropriate one
08:22:20 <merijn> dminuoso: Plus some boilerplate for handling failures/exception (i.e. retry, drop, abort the entire thing)
08:22:46 <dminuoso> Looks quite trivial actually, I like it. :)
08:22:49 <ski> norb_ : the two arguments of type `o' and `a -> o' would be known as "continuations" (in this particular case, a failure continuation, and a success continuation)
08:23:03 <merijn> dminuoso: The API is, the implementation is...intimidating :)
08:23:37 <merijn> dminuoso: Because you have to properly rate limit, make sure you kill of threads, handle async exceptions, etc.
08:23:44 <haasn> hmm the catMaybes thing doesn't work
08:23:52 <dminuoso> Heh
08:23:53 <maerwald> merijn: sounds like the right order 
08:24:10 <maerwald> I often see intimidating API and trivial implementation :D
08:24:12 <merijn> dminuoso: But yes, "trivial API for something complicated I kept having to reinvent all the time" was the goal :p
08:26:21 <norb_> ski: how would that work? the loop would still have to try both branches, and handle the exception?
08:26:36 <merijn> maerwald: Most of my code follows that pattern :p
08:28:17 <ski> @type let cpsTail :: [a] -> o -> ([a] -> o) -> o; cpsTail [] failure _ = failure; cpsTail (_:as) _ success = success as; cpsLoop :: (forall o. [a] -> o -> ([a] -> o) -> o) -> [a] -> [a]; cpsLoop cpsStep seed = cpsStep seed seed id in cpsLoop cpsTail [0 .. 999999]
08:28:19 <lambdabot> (Enum a, Num a) => [a]
08:28:19 <merijn> maerwald: This one also has a surprisingly nasty implementation, given the simplicity of the API: https://hackage.haskell.org/package/paramtree-0.1.1.1/docs/ParamTree.html
08:29:09 <ski> norb_ : you could try something like that
08:29:57 <ski> instead of the rank-2 type `(forall o. [a] -> o -> ([a] -> o) -> o) -> [a] -> [a]', you could use `([a] -> [a] -> ([a] -> [a]) -> [a]) -> [a] -> [a]'
08:30:16 <ski> (but the rank-2 type more clearly points out what's going on)
08:31:35 <ski> hrm, sorry, the loop should actually loop
08:31:37 <ski> @type let cpsTail :: [a] -> o -> ([a] -> o) -> o; cpsTail [] failure _ = failure; cpsTail (_:as) _ success = success as; cpsLoop :: (forall o. [a] -> o -> ([a] -> o) -> o) -> [a] -> [a]; cpsLoop cpsStep seed = cpsStep seed seed (cpsLoop cpsStep) in cpsLoop cpsTail [0 .. 999999]
08:31:39 <lambdabot> (Enum a, Num a) => [a]
08:32:00 <Mrbuck_> what is equivalent  to request to make api call in haskell ?
08:32:09 <Mrbuck_> Can I have small snipet to amke api call please
08:32:48 <ski> > let cpsTail :: [a] -> o -> ([a] -> o) -> o; cpsTail [] failure _ = failure; cpsTail (_:as) _ success = success as; cpsLoop :: (forall o. [a] -> o -> ([a] -> o) -> o) -> [a] -> [a]; cpsLoop cpsStep seed = cpsStep seed seed (cpsLoop cpsStep) in cpsLoop cpsTail [0 .. 999999]
08:32:51 <lambdabot>  []
08:33:21 <ski> > let cpsTail :: [a] -> o -> ([a] -> o) -> o; cpsTail [] failure _ = failure; cpsTail (_:as) _ success = success as; cpsLoop :: (forall o. [a] -> o -> ([a] -> o) -> o) -> [a] -> [a]; cpsLoop cpsStep seed = cpsStep seed seed id in cpsLoop cpsTail [0 .. 999999]  -- non-loop
08:33:24 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:34:41 <ski> norb_ : making any sense ?
08:36:22 <greymalkin> :t mapM undefined :: ConduitT i o m ()
08:36:23 <lambdabot> error:
08:36:24 <lambdabot>     Not in scope: type constructor or class ‘ConduitT’
08:37:24 <ski> @let import Data.Conduit
08:37:25 <norb_> almost
08:37:25 <lambdabot>  .L.hs:83:1: error:
08:37:25 <lambdabot>      Data.Conduit: Can't be safely imported!
08:37:26 <lambdabot>      The package (conduit-1.2.12.1) the module resides in isn't trusted.
08:37:32 <ski> hm
08:38:09 <greymalkin> What am I missing? That statement doesn't typecheck; it's requiring lists on my end.
08:38:41 <ski> perhaps they have their own `ConduitT' version of `mapM' ?
08:38:52 <merijn> Conduit has it's own mapM, yes
08:39:10 <ski> @type mapM
08:39:11 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
08:39:13 <Solonarv_> % :i mapMC
08:39:13 <yahb> Solonarv_: ; <interactive>:1:1: error: Not in scope: `mapMC'
08:39:19 <ski> would be a different `mapM'
08:39:48 <greymalkin> No. Otherwise it would be "ambiguous" (and I qualified the import and tried calling it directly to find it was not defined there)
08:40:36 <Eduard_Munteanu> Conduit has one mapM as a monad and another as a collection, I guess.
08:40:53 <Solonarv_> it's in Data.Conduit.List (which you're meant to import qualified, I think)
08:41:05 <ski> greymalkin : <https://hackage.haskell.org/package/conduit-1.3.1/docs/Data-Conduit-Combinators.html#v:mapM> ?
08:41:16 <greymalkin> Ah! That might be it.
08:41:41 <ski> i suppose in `D.C.List' as well, yes
08:41:44 <greymalkin> I'm looking at Combinators, but not importing it.  I knew it had to be something dumb I was doing.
08:42:14 <greymalkin> Yup.  Thanks, and sorry.
08:43:19 <Mrbuck_> hi
08:43:24 <Mrbuck_> what is equivalent  to request to make api call in haskell ?
08:43:36 <Mrbuck_> Can I have small snipet to make api call please
08:43:47 <dmwit> Mrbuck_: You're not getting an answer because your question is way too vague. I want to snarkily answer "`id ()` is a call to the `Prelude` API" but I can't make myself do it.
08:43:53 <merijn> An "API" call to what?
08:44:10 <Mrbuck_> any api 
08:44:26 <dmwit> Mrbuck_: But it might be instructive for you anyway to say whether you would accept `id ()` as an answer or not, and if not, try to articulate why not.
08:44:27 <ski> then dmwit's example should suffice ?
08:44:30 <Mrbuck_> just as an exaple like regquests.get("ur",autj)
08:44:32 <Eduard_Munteanu> What do you mean by API? Some REST API? WinAPI?
08:44:47 <berndl> Mrbuck_: Are you talking about HTTP requests?
08:44:48 <Mrbuck_> dmwit:  I am not understanding your answer
08:44:53 <Mrbuck_> berndl:  Yes
08:45:00 <ski> then you should say so
08:45:12 <cocreature> Mrbuck_: take a look at the "req" package
08:45:20 <norb_> HTTP.Simple ?
08:45:29 <dmwit> Mrbuck_: You may like http://www.serpentine.com/wreq/tutorial.html
08:45:36 <ski> norb_ : any luck with the CPS ?
08:45:57 <Mrbuck_> Thank you I got my answer
08:46:53 <norb_> ski: it looks like it could be faster
08:47:37 <norb_> but it passes the looping function into the tail function, so maybe it might not work as desired
08:48:19 <norb_> depending on if an arbitrary computation can be used. this specifically matches on [] instead of polymorphic errors 
08:49:12 <norb_> but perhaps everything that could return a maybe value would have to be able to match this way
08:50:08 <norb_> i.e. the error would be thrown (or undefined returned as the value) instead of returning Nothing, and then the cps failure branch would be used
08:50:16 <norb_> so it could be ok, just working through it
08:54:56 <ski> > let cdTail :: [a] -> Codensity Maybe [a]; cdTail [] = empty; cdTail (_:as) = return as; cdLoop :: ([a] -> Codensity Maybe [a]) -> [a] -> [a]; cdLoop cdStep seed = maybe seed (cdLoop cdStep) (lowerCodensity (cdStep seed)) in cdLoop cdTail [0 .. 999999]
08:54:59 <lambdabot>  []
08:55:15 <ski> see <https://hackage.haskell.org/package/kan-extensions-5.2/docs/Control-Monad-Codensity.html>
08:56:45 <ski> norb_ : not sure i understand your last comments
08:57:34 <ski> hmm
09:00:06 <remexre> Is there a good way to have a mutable global variable for e.g. "maximum log level?"
09:00:21 <merijn> remexre: A good way? Not really
09:00:38 <c_wraith> ways?  yes.  good?  no.  :)
09:01:12 <remexre> is there a better way than a global unsafePerformIO newIORef that I make sure to demand early in main, then?
09:01:27 <cocreature> the better way is to not use a mutable global variable :)
09:01:34 <c_wraith> The best approach is to have the logging functions close overa  non-global mutable variable.
09:01:54 <c_wraith> Since you need to configure a logger anyway
09:01:59 * ski . o O ( ML module functors )
09:02:02 <c_wraith> And you need to pass that configuration around somehow
09:02:09 <remexre> Right now they're (Show a => a -> IO ()); is there a way to do that other than to add a StateT in?
09:02:20 <c_wraith> Just make the IORef holding the log level also part of the configuration
09:03:21 <remexre> Right now there's no configuration at all; this is a short-lived, user-interactable process, not a server
09:03:28 <remexre> so it's assumed that the user can read everything
09:03:54 <remexre> I just want to disable my debug logs unless the user passes -v, since those are actually too many to read
09:04:08 <ski> hmm .. i suppose an exception monad, rather than `Maybe', would be better, with `Codensity'
09:04:14 * ski is slow today
09:04:51 <merijn> mmm, is there an easy way to compare two Maybe values, but treating Nothing as > than Just, rather than the other way around?
09:05:35 <merijn> remexre: If you have MonadLogger you can just parse the verbosity from the user and then use that to change the log level
09:06:08 <merijn> Writing out all possible cases of comparing 2 maybe values sounds really annoying
09:06:35 <cocreature> Down (Maybe (Down a))?
09:06:41 <cocreature> not that this is really better :)
09:07:02 <merijn> cocreature: That's...surprisingly awful :p
09:07:14 <merijn> Wait, maybe I can fix this by just using Either
09:07:28 <cocreature> Down (Either e (Down a)) is clearly better
09:07:50 <remexre> merijn: Okay, I'm not using that right now, but how does it work? Would that add another transformer to the monad transformer stack?
09:08:08 <merijn> cocreature: No, I basically have a string and if it can be converted to a double I wanna compare on that, otherwise compare on String
09:08:16 <merijn> cocreature: So Either might have the right semantics anyway
09:08:40 <merijn> Just do "String -> Either Double String" that should get me the write semantics
09:08:54 <merijn> Since Left < Right and then Left gets compared by Double value and Right by String
09:09:56 <merijn> "either Right Left . readEither"
09:10:06 <pmade> Does this function have a name? \x -> a1 x >> a2 x
09:10:18 <merijn> pmade: "liftA2 (>>)" :p
09:10:18 <cocreature> comparing values as doubles if possible and as strings otherwise sounds like something js would do :)
09:10:22 <dminuoso> ski: Okay how does that optimization work? Is this somehow related to Codensity?
09:10:24 <merijn> cocreature: Yes
09:10:33 <ski> dminuoso : hm, which optimization ?
09:10:48 <pmade> merijn: cute.
09:10:48 <dminuoso> ski: the one you were talking to norb_ about.
09:10:55 <merijn> cocreature: Naah, I'm just trying to make sure my benchmarks/tests get ordered by numerical value
09:11:19 <merijn> cocreature: Right now they're sorted by string value so "10 writes" becomes before "2 writes" and "5 writes" which is just ugly
09:11:20 <ski> dminuoso : the basic idea is to avoid (re)assembling and disassembling `Maybe's all the time
09:11:47 <merijn> cocreature: But since my code is polymorphic in the value, the easiest way is to just take the total String label and try and parse if it starts with a number
09:11:56 <ski> dminuoso : which left-associated `(>>=)' in the `Maybe' monad does. it's the same problem as left-associated `(++)', with the same solution : right-associated
09:11:58 <tdammers> jeez, it's not rocket science. you want a log level; so you need to pass it around to everything that may want to log anything. you want it to be mutable, you put it in an IORef or some other mutable primitive
09:12:02 <ski> dminuoso : `Codensity' does that for you
09:12:03 <c_wraith> merijn: are you reinventing perl?
09:12:06 <tdammers> and then you follow the compiler errors
09:12:23 <merijn> Ah, readEither doesn't work, I have to use reads :)
09:12:35 <c_wraith> merijn: (this value looks like a number, therefore it's a number!)
09:12:40 <ski> (yay `reads' :)
09:12:43 <tdammers> if you want to go fancy, use a ReaderT AppState ... to pass around application context (things that you would make global if Haskell allowed you to)
09:12:46 <merijn> c_wraith: Don't you care about pretty ordering of your tests/benchmarks?! :p
09:17:33 <c_wraith> merijn: no.  I care about consistent ordering
09:18:29 <merijn> This is consistent!
09:19:05 <dminuoso> ski: Okay this is a bit over my head heh.
09:19:44 <ski> dminuoso : to actually use a `Maybe a' result, you have to do a `case' with one branch of type `o' and another branch of type `a -> o'
09:19:54 <koality> I'm making a function that tests if a [char] has certain characteristics (size greater than x, has digits, etc.). The function will return true is all the characteristics are met
09:20:26 <koality> I'm thinking of making a datatype (boolean?) but im not sure if this is the right approach
09:20:30 <dminuoso> ski: Oh in the sense that you have to build a `Just a` just for the answer, and then scrutinize on it to figure out what `maybe` has already spend work on figuring out?
09:20:30 <ski> dminuoso : so, we can replace `foo :: ... -> Maybe A' by `foo :: ... -> o -> (a -> o) -> o', passing the two branches directly to `foo', rather than wrapping the `foo' call with a `case' having those two branches
09:20:55 <ski> dminuoso : you could think of this as fusing `foo' with `maybe', yes
09:21:07 <cocreature> it is probably worth pointing out that GHC can often do this kind of fusing itself
09:21:27 * ski likes guarantees
09:21:58 * ski would like an implementation of "unboxed variants", giving said guarantees
09:22:09 <dminuoso> ski: inspection tests could give you such guarantees - possibly. :P
09:22:18 <cocreature> sure everyone likes guarantees but it is also pretty unrealistic to write code and not rely on GHC’s optimizations if you care about performance
09:22:37 <ski> (by which i *don't* mean that the "tuple" of the tag, and arguments, is unboxed. rather that the continuation (containing the `case' branches) is unboxeD)
09:22:48 <ski> dminuoso : "inspection tests" ?
09:22:52 <koality> is it possible to have a "let" var [bool] in a function? that is initialized NULL, and if all conditions are met, the function exits and returns true
09:23:11 <cocreature> that reminds me, does anybody know what happened to the nested cpr patch that was floating around a few months back?
09:23:25 --- mode: glguy set +v raynold_
09:23:30 <dminuoso> ski: Joachim Breitners GHC plugin: http://hackage.haskell.org/package/inspection-testing
09:23:31 <johnw_> koality: variables are just names of values in Haskell; there is no concept of "changing" one. That idea requires some kind of state, or argument to the function.
09:23:35 <ski> cocreature : i would like a reasonably simple syntactic criterion for when i can expect the more improved efficiency
09:23:48 <ski> similar to the "tail call" criterion in e.g. Scheme
09:24:33 <ski> koality : what problem are you trying to solve ?
09:25:06 <ski> dminuoso : interesting, ty
09:25:28 <koality> isGoodPassword :: [Char] -> Bool (newline) isGoodPassword (x:xs) (newline)   | isUpper x =  (more guard conditions)
09:25:29 <cocreature> ski: that’s a nice ideal but it breaks down as soon as there is more than one optimization that you could apply at some point
09:25:42 <koality> btw how do you reply to someone's message?
09:25:55 <cocreature> prefix your message with "nick:"
09:26:11 <koality> cocreature: thanks
09:26:13 <c_wraith> irc is strictly textual.  Write the text you want to appear.  :)
09:26:24 <cocreature> koality: isGoodPassword (x:xs) = isUpper x && more guard conditions
09:27:14 <ski> cocreature : perhaps. which is one reason i don't want this as an optimization, but as a guarantee (of language, or language extension)
09:27:34 <c_wraith> koality: also, tell your instructor that comprehensive research has determined password rules like those have resulted in people using weaker passwords to fit the rules and therefore is bad policy.
09:27:43 <cocreature> ski: well then you either only get the guarantee for one optimization or you run into the same problem
09:27:47 <c_wraith> ...  *are* bad policy
09:28:17 <koality> c_wraith: I'm aware of this but this is just programming practice
09:29:31 <ski> cocreature : hm, i don't think i get what you're saying
09:29:56 <dminuoso> ski: Your CPS trick only solves one local optimization problem.
09:31:01 <dminuoso> I think he's trying to hint at that.
09:31:15 <cocreature> ski: my point is that there are quite a few optimizations that on their own seems like things that you would have guaranteed but guaranteeing all of them isn’t possible because there are situations where more than one applies and in that case you have to violate some guarantees
09:31:32 <cocreature> *would want to have guaranteed
09:34:00 <koality> I'm familiar with 
09:34:05 <koality> ^ignore
09:34:09 <dminuoso> ski: Okay I understand your code now, though how is that related to "left-associativity" of >>= exactly?
09:34:21 <dminuoso> Where is the "right-associativity" in cpsLoop/cpsTail
09:35:01 <ski> cocreature : fair enough
09:35:16 <cocreature> if you only look at a single rewrite rule you might want that this rule is always applied but as soon as you have multiple rewrite rules things quickly break down
09:35:34 <koality> I'm familiar with object oriented languages. Does "conditionsMet Bool = length | digit | upper | lower" make sense for my program?
09:35:34 <cocreature> *might want to guarantee
09:35:49 <ski> (possibly switching to a separate type would mean there is no longer multiple rules which applies)
09:35:52 <cocreature> koality: I’m not sure what that syntax is supposed to mean
09:36:09 <koality> as an enumeration type
09:36:35 <dminuoso> koality: data Condition = Length | Digit | Upper | Lower
09:36:36 <dminuoso> Perhaps?
09:37:33 <cocreature> not sure what you are hoping to achieve with that enumeration type
09:40:30 <ski> dminuoso : on second look, there is no right-associativity in that particular snippet. i suppose i mentioned that because that's a common reason for `Codensity'. shows i'm tired enough i should probably shut up for the while
09:42:01 <dminuoso> ski: Oh dont worry, you piqued my interest.
09:44:03 <bohadi> :join #haskell-beginners
09:49:07 <koality> if a guard expression is evaluated as True, can it preform 2 operations? e.g. add something to another list and make a recursive call (using xs)
09:50:11 <dminuoso> koality: check this out:
09:50:26 <dminuoso> koality: Yes.
09:50:41 <dminuoso> koality: Its best to not think in terms of "perform operations" though
09:50:54 <dminuoso> koality: It does not fit well with how Haskell works and leads to bad intuition. :)
09:51:16 <koality> dminuoso: how would this be done? Sorry I'm new to functional programming languages in general
09:51:25 <dminuoso> koality: What exactly are you trying to do?
09:52:30 <koality> For instance: | x == 1 = recursiveCall(xs) "and preform" add x to an array 
09:52:41 <koality> not sure about how to do the "and preform" part
09:52:48 <glguy> There's no "and perform"
09:52:53 <dminuoso> koality: add `x` to what array exactly?
09:52:58 <exarkun1> I tried to make a Show instance for Crypto.Saltine.Core.Sign.Keypair but turns out Keypair is (SecretKey, PublicKey) and ghc is angry that there is already a Show instance for (Show a, Show b) ... but there is no show instance for SecretKey afaict?
09:53:43 <glguy> exarkun1: You can't make a Show instance for Keypair, it's a type alias
09:53:57 <dminuoso> koality: For starters accept that you can't mutate things, a function has no ability to "perform work" on its own.
09:54:02 <dminuoso> koality: a function can just produce data.
09:54:20 <koality> I gotta get used to this stateless design lol
09:54:37 <koality> I'm going to try a few other ways to figure this out
09:54:40 <dminuoso> koality: You can encode state quite simply, but it takes some other appraoches.
09:54:54 <exarkun1> glguy: what about FlexibleInstances
09:55:13 <glguy> You're going in the wrong direction
09:55:28 <exarkun1> glguy: The error seems to be the same if I try to make an instance for (SecretKey, PublicKey) though
09:55:38 <dminuoso> koality: One of the first techniques is to just use recursion, while keeping the "state" in the parameter - passing it through.
09:55:54 <glguy> exarkun1: Right, instances are for a type constructor applied to zero or more type variables
09:56:00 <glguy> exarkun1: and (,) already has a Show instance
09:56:41 <glguy> exarkun1: You can either just make a new function that isn't show to view these keypairs, or you can create a newtype for Keypairs that has a Show instance you've implemented
09:57:18 <koality> Basically, I have a "function :: [Char] -> Bool" and if all guard statements have been executed (e.g. isUpper), I want function to return True
09:57:29 <dminuoso> koality: what does "executed" mean?
09:57:58 <koality> like all guards have been evaluated at true at some point
09:58:10 <koality> as*
10:00:14 <cocreature> koality: have you considered combining the guards with && as I suggested earlier?
10:01:01 <koality> cocreature: I'm not sure if I understand what that means
10:01:38 <cocreature> koality: let’s say you have three functions f, g, h of type [Char] -> Bool that each check some condition holds on the string
10:01:48 <cocreature> you can then define function xs = f xs && g xs && h xs
10:01:56 <cocreature> which will return True if all checks hold
10:02:29 <koality> cocreature: ah, I see. I'm trying to do this all in one function
10:02:44 <koality> Maybe ill do that approach and see if I can think of anything else later on
10:03:03 <dminuoso> ski: Do you have an example that illustrates the associativity topic you had in mind though?
10:04:08 <[exa]> is there an extension where && could be overloaded?
10:04:24 <johnw_> [exa]: there are libraries that do that
10:04:27 <johnw_> && isn't core syntax
10:04:36 <koality> cocreature: thanks, that implementation actually makes more sense
10:04:41 <cocreature> koality: you don’t need to define separate functions, e.g. if you want to check the length, use function xs = length xs > 10 && …
10:05:10 <[exa]> it would be nice to have True := fromBoolean True with that
10:07:06 <koality> cocreature: I think I see what you're saying with not needing multiple functions. But i'm trying to iterate through a [Char], I don't think I can have a case where char 'x' will be uppercase, lowercase, and a digit
10:11:05 <cocreature> koality: I’m not quite following. can you provide more details of what you are trying to do or maybe even a code sample (pseudocode or some other language is fine)
10:11:46 <koality> Are we allowed to copy/paste code into here?
10:12:14 <cocreature> use a pastebin site, e.g., github gists which is linked in the topic
10:12:21 <koality> I'm going to put up my solution that I think will work, maybe let me know if there's any improvements that can be done
10:12:31 <koality> Not finished quite yet
10:17:56 <koality> cocreature: https://cryptobin.co/f541h0n3 with password 'koality'
10:18:09 <koality> Currently has errors, but is general idea of it
10:18:52 <cocreature> I get a 404 if I use that password
10:19:08 <cocreature> also password protecting a paste while sending the password in a public irc channel is silly :)
10:21:14 --- mode: glguy set +v foojin
10:21:22 <EvanR> creating secret keys on computers which are all equipped with big brother hardware is silly :D
10:21:34 <foojin> koality: Do you want to check if, for every predicate of your choosing, there is a character in the input string for which it holds?
10:22:19 <koality> foojin: it's like a password checker. So, it must have uppercase, lowercase, numbers, x length
10:22:41 <koality> https://0bin.net/paste/nTLFpcz-naDsVxfE#h1Ckpnz-yVvMM7RkniXwKdBpppRydSpxp1gTDr7gY3G
10:23:14 <EvanR> ensures your password is easy guess and hard to remember
10:23:58 <koality> evanR: lmao
10:24:16 <cocreature> koality: isGoodPassword xs = length x > 7 && any isUpper xs && any isLower xs && any isDigit xs
10:24:59 <hololeap> is there a cleaner/more idiomatic way of writing this with Parsec? `endBy1 (many (noneOf "\r\n")) endOfLine`
10:25:29 <koality> cocreature: thank you
10:26:00 <glguy> hololeap: http://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec.html#v:manyTill
10:26:02 <koality> I'm still getting a "Variable not in scope : TestPassword47 :: [Char]
10:26:25 <cocreature> your code snippet doesn’- contain TestPassword47
10:26:36 <glguy> variable names are lowercase
10:26:37 <cocreature> maybe you want to use a string literal, i.e., "TestPassword47"?
10:27:02 <hololeap> glguy: thanks, i must have missed that
10:27:04 <koality> Wow...
10:27:33 <koality> concreature: you saved me like 3 hours mentioning I need to add " "
10:27:37 <koality> thank you
10:28:00 <koality> Everything is working now
10:28:18 <disconsis> could anybody clue me on the use of (<*), and why it
10:28:33 <disconsis> isn't just implented using a mix of const and seq?
10:29:27 <disconsis> the reasons in the typeclassopedia seem to suggest it's used like `seq`
10:29:33 <disconsis> > :t (<*)
10:29:35 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
10:29:45 <disconsis> >:t (<*)
10:29:48 <johnw_> it's related to Applicative, not seq
10:30:02 <johnw_> but I can see why that comment was made
10:30:12 <johnw_> x <* y evaluates y, throws away it's value, and then evaluates x
10:30:20 <johnw_> which you'd do because you want the "effects" in y
10:30:32 <disconsis> as in, side effects?
10:30:37 <johnw_> and y `seq` x always evaluates y before x, but not for "effects"
10:30:44 <johnw_> whatever effects are defined by the Applicative instance
10:31:03 <cocreature>  think you got things the wrong way around. x <* y will first execute the effects of x not the effects of y
10:31:15 <cocreature> % putStrLn "Hello" <* putStrLn "World"
10:31:16 <yahb> cocreature: Hello; World
10:31:28 <cocreature> *I think
10:31:37 <disconsis> cocreature: consider *> then
10:31:55 <cocreature> disconsis: that will also first execute the effects of x and then the effects of y
10:32:10 <cocreature> the difference is not the order in which effects are executed, the difference is the value they return after executing the effects
10:32:22 <cocreature> x <* y returns the value computed by x, x *> y returns the value computed by y
10:32:34 <johnw_> ah, right
10:32:45 <johnw_> execute 'x', then execute 'y', then return the value from x
10:32:54 <johnw_> thanks for catching that
10:33:19 <cocreature> I don’t think a comparison to 'seq' is really useful here
10:33:39 <johnw_> yeah, it's a pretty oblique comparison
10:33:53 <johnw_> and confusing to all but those who don't need the comparison ;)
10:34:25 <disconsis> the type signature is what made me make the comparison 
10:35:46 <disconsis> sorry, could you guys give a few more examples of "effects"?
10:36:02 <disconsis> all I'm imagining is "IO"
10:36:21 <johnw_> State
10:36:28 <mniip> Maybe, Either e, Reader e, State, Writer w
10:36:37 <cocreature> Parsers 
10:36:41 <foojin> >[1,2,3] <* [4,5]
10:37:04 <cocreature> that doesn’t look like spam
10:37:07 <mniip> Parsers are just StateT or FreeT depending on whether you're cool or not
10:39:29 <mniip> so, here's a vague question but I'm sure everyone understands what I mean by it
10:39:39 <mniip> what is the deep meaning behind yoneda?
10:40:06 <johnw_> that an object is equivalent to what you can do with it
10:40:32 <johnw_> i.e., beyond your capacity to interact with something, you know nothing about it
10:40:52 <mniip> I don't immediately see how that translates to the formal statement
10:41:06 <um1b0zu> mniip https://bartoszmilewski.com/2013/05/15/understanding-yoneda/
10:41:25 <mniip> um1b0zu, seen that, that's a haskell version
10:41:35 <mniip> addressing the much simpler issue of yoneda in a CCC
10:42:38 <um1b0zu> I mean, CT is abstract
10:42:53 <johnw_> mniip: so you want a better intuition of the formal statement?
10:43:09 <mniip> johnw_, I don't know
10:43:24 <um1b0zu> the only real concrete statement one can make about yoneda is that if I give you a box and it meows, but you can't look in it, there's no way you can tell if the box contains a cat or a recording of a cat.
10:43:51 <mniip> um1b0zu, care to elaborate on the analogy?
10:44:29 <monochrom> That is how all software should work. :)
10:45:01 <um1b0zu> "an object is equivalent to what you can do with it" can also be understood as, "if I give you a block box that has a machine inside it, which acts like another machine, there's now way to tell if it's the original machine or the "actor" machine.
10:45:13 <monochrom> If I present you an API for a queue, you shouldn't be able to tell whether I use a linked list or an array or a binary search tree inside.  It's a queue to you, what's the problem?
10:45:15 <um1b0zu> becuase you can only see it's actions from the outside
10:45:15 <mniip> johnw_, in the formulation we have Hom(A, -), F and a natural transformation
10:45:29 <mniip> which of these is the thing, which is the interaction?
10:45:41 <johnw_> mniip: Hom(A,-) is the complete set of "what you can do from an A"
10:46:27 <johnw_> which can be naturally transformed into a mapping of F over any object
10:46:49 <monochrom> Conversely, if you ask me for an implementation of "infinite set", and you neglect to specify the actual API, then what's wrong with me using () as the internal implementation?  You aren't going to do anything with it anyway, are you?
10:47:22 <mniip> monochrom, it's infinite, so an API is a monomorphism onto N
10:47:25 <mniip> er
10:47:27 <mniip> epimorphism
10:47:41 <mniip> monomorphism from N
10:48:41 <mniip> also it's a set and nonempty
10:48:44 <mniip> we can invoke choice on it
10:48:52 <mniip> compare to other sets
10:49:12 <mniip> johnw_, and then?
10:50:33 <mniip> so far it's like you're telling me monads are burritos. Which part of a burrito the mu?
10:51:17 <nshepperd1> What if the deep meaning is that Yoneda is the Setter version of Context from lens
10:54:04 <koality> I have a pretty simple question for List Comprehension: How can I make it so I can get [2, ..., square root of (x)]
10:54:06 <koality> I've tried [2..(sqrt(fromIntegral x))]
10:55:15 <cocreature> koality: what do you want to happen if the sqrt is not an integer?
10:55:49 <cocreature> e.g. what should [2 .. square root of 5] be?
10:56:15 <koality> oh... ceiling?
10:56:26 <koality> or actually floor
10:56:29 <koality> floor would work
10:56:42 <cocreature> > [2  ..  floor (sqrt (fromIntegral 5))]
10:56:43 <koality> so 4
10:56:44 <lambdabot>  [2]
10:57:45 <koality> thank you!
10:58:05 <cocreature> you don’t need the fromIntegral if you actually have a constant value since numeric literals are polymorphic
10:58:36 <koality> without fromIntegral, I was getting errors for some reason
10:59:18 <cocreature> presumably you didn’t just use a numeric literal :)
11:00:56 <koality> Found out [2..isqrt k] does the same thing!
11:02:37 <cocreature> not sure where you are getting isqrt from. I don’t think that is in any reasonably popular Haskell package and it’s definitely not in base
11:05:34 <mniip> takeWhile (\x -> x * x < k) [2..]
11:11:51 <mniip> johnw_:
11:16:26 <ztf> my prof requires us to use a latex template that makes code listings non-monospaced and has ligatures ie for ->, is this common? 
11:16:54 <dstolfa> ztf: good god no
11:16:56 <yushyin> no
11:17:34 <koz_> That sounds horrifying to read.
11:18:28 <ztf> it kind of is, but its week one of an intro course so the longest snippets have been like 3 lines 
11:18:33 <cocreature> I’m not a fan of it but I’ve seen it quite a bit
11:18:41 <cocreature> so I’d say yes it is fairly common
11:18:44 <mniip> anyone else willing to explain yoneda to me?
11:19:20 <dstolfa> mniip: ask me during the weekend if you don't figure it out by then. i'm really busy and am getting no sleep currently
11:22:09 --- mode: glguy set +v hhefesto
11:23:39 <koality> How can I get a function to accept "two parameters"? For instance
11:23:43 <koality> function :: Integer -> [Integer] -> [Integer]
11:23:46 <koality> function n list
11:23:52 <monochrom> Latexifying plus ligature is pretty common in research papers. But not in inflicting it on poor undergrad students on mere homework.
11:23:52 <koality>   | ...
11:24:25 <monochrom> OTOH if a latex template is already provided then there is little extra work.  Just one run more command and get one more file.
11:24:46 <monochrom> Yes that's correct syntax so far.
11:24:49 --- mode: glguy set +v koality
11:25:07 <monochrom> If there is a problem, then (logically) it's with what you haven't shown.
11:25:08 --- mode: glguy set +v test-name
11:25:21 <test-name> pointfree
11:25:24 <test-name> @pointfree
11:25:24 <lambdabot> Unknown command, try @list
11:25:31 <monochrom> It's @pl
11:25:32 <test-name> @pointfree x -> x
11:25:33 <lambdabot> Unknown command, try @list
11:25:35 <test-name> @list
11:25:35 <lambdabot> What module?  Try @listmodules for some ideas.
11:25:39 <test-name> @listmodules
11:25:39 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
11:25:39 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
11:25:44 <mniip> koality, you pretty much said it
11:25:53 <test-name> @unlambda \x -> x
11:25:53 <lambdabot>   unlambda: Unknown operator '\\'
11:25:53 <lambdabot>   CallStack (from HasCallStack):
11:25:53 <lambdabot>     error, called at Main.hs:45:38 in main:Main
11:26:05 <monochrom> OK test-name doesn't want to read.
11:26:05 <test-name> @djinn a -> a
11:26:06 <lambdabot> f a = a
11:26:23 <test-name> @pointful \x -> x
11:26:23 <lambdabot> \ x -> x
11:28:26 <koality> I get "Couldnt match expected type '[Integer]' with actual type '(Integer -> [Integer]) -> [Integer] -> [Integer]]'
11:29:37 <cocreature> koality: you’ll have to show us the code producing the error
11:29:46 <koality> nevermind, it's actually: couldn't match expected type 'Integer' with actual type '[Integer]'
11:29:50 <cocreature> and the full error message is probably also going to be useful
11:30:31 <monochrom> The cause is always where you don't look.
11:31:03 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
11:31:42 <hhefesto> Hi, Haskell gurus!
11:31:49 <hhefesto> How can I extract from within the do notation of a monad the head of a list? Here is my code and a little better explanation of what I mean: https://gist.github.com/hhefesto/2d5c052a6ab4271f8f6d0ab3515f1996
11:32:47 <koality> https://0bin.net/paste/oYAYi7jCVdK196Oa#cyAD3bQunej3u25k8qzMWWvnE9RpvFxTjv+QHYKFxjX
11:34:09 <koality> nevermind
11:34:12 <koality> just needed brackets
11:34:16 <koality> loool
11:34:16 <cocreature> that’s not the code snippet producing the error
11:34:48 <monochrom> hhefesto: What error did you get?
11:34:51 <koality> I made that function so it's a more abstract version
11:35:30 <cocreature> hhefesto: let customer_info = listToMaybe customer_info_list
11:35:42 <monochrom> Oh, right.
11:35:52 <cocreature> koality: eliminating the part of the code mentioned in the error message from your snippet isn’t very useful :)
11:37:22 <koality> Different error now
11:37:23 <koality> https://0bin.net/paste/jRv2Mi0KLJVAZFqe#XEoPfKTzA7OH3J6J8mUmH+o0RJtOrhF3WIVojo9a5P7
11:37:47 <EvanR> that story about yoneda and "interaction is everything" is interesting
11:38:12 <koality> disreguard the guard statements and what they do, just testing it out rn
11:38:35 <EvanR> and the API story is interesting by itself, but what is the practical reality. you want to limit how pile-of-code X is used so that when you change it, or improve it, you dont break the usage?
11:38:59 <monochrom> "[list]" does not mean what you think.  Change it to "list".
11:39:22 <EvanR> anything that acted on the implementation details might find itself incorrect when details change
11:39:33 <cocreature> [list] will match on a list with a single element and bind that element to the name "list"
11:39:35 <monochrom> Haskell is neither Prolog nor Perl. You don't wrap [ ] around a variable name just because the variable type is list.
11:39:41 <EvanR> so the details are somehow unreal
11:39:51 <koality> I tried list before, but that gave me error:
11:39:54 <koality>     * Couldn't match expected type `Integer'                   with actual type `[Integer]'     * In the expression: list       In the second argument of `(:)', namely `[list]'       In the expression: n : [list]    | 50 |   | n == 1 = n : [list]
11:39:58 <hhefesto> cocreature: why does the let expresion solve it?
11:40:12 <hhefesto> Thanks!
11:40:14 <koality> one sec ill upload the error msg
11:40:20 <monochrom> Show the actual code that causes that error.
11:40:33 <cocreature> hhefesto: "x <- y" expects something of type "f a" if you’re in a do block for "f" and binds "x" to a value of type "a"
11:40:41 <koality> https://0bin.net/paste/RSHLYIPifKGkKPlx#vNH+qjuFzLeJhGzZX7BWItYOhI8-ZKs8WwTHnPH8GOi
11:40:49 <cocreature> hhefesto: but that’s not what you want to do here, you just want to bind x to y
11:40:54 <cocreature> that’s what a let does
11:41:04 <monochrom> hhefesto: That "let" is part of the syntax of do-notation for this very purpose.
11:41:10 <cocreature> koality: remove those brackets as well
11:41:18 <hhefesto> Perfect!
11:41:22 <hhefesto> Thank you so much
11:41:26 <ski> monochrom : you don't do it in Prolog, either :)
11:41:32 <cocreature> list is already a list [list] is a singleton list that contains as its single element another list
11:41:37 <koality> actual code and error: https://0bin.net/paste/WeArV4vYUVTkiI2O#hYkmU6B-vSz5zWIMPcr4lewVOpRu0ezwmux04baRc8x
11:41:43 <yushyin> nor in perl
11:41:49 <koality> ah I see
11:41:55 <monochrom> In perl it's @list
11:42:01 <monochrom> Same crime.
11:42:15 <koality> THANKS AGAIN
11:42:24 <ski> (however, `x : xs' is written `[X | Xs]' in Prolog. that's a different thing, though)
11:42:25 <monochrom> Yes, alt.sigils.die.die.die
11:42:26 <koality> made the same mistake twice
11:42:31 <koality> hopefully I don't make it again
11:42:48 <yushyin> monochrom: https://xkcd.com/1306/ :)
11:43:22 <monochrom> Yeah next time I need to add BASIC to the list.
11:43:39 <monochrom> "Haskell is not Prolog, BASIC, or Perl"
11:44:09 <yushyin> monochrom: did you know, perl6 has twigils! https://docs.perl6.org/language/variables#Twigils
11:44:15 <yushyin> twice the fun
11:44:16 * ski doesn't see why Prolog is included
11:44:42 <EvanR> #hashtag store https://i.hipinpakistan.com/large/2016/03/56f91cc39ba15.jpg
11:44:43 <monochrom> Because [X|Y] is crazy syntax.
11:45:18 <EvanR> 'quote
11:45:24 <ski> but it's not a sigil thing
11:45:36 <monochrom> You also need to stand back a bit and see its mentality of "need [ ] just because it has something to do with list".
11:46:14 <monochrom> haha EvanR
11:46:25 <yushyin> monochrom: you can include ruby in your list (has sigils for scopes)
11:46:31 <ski> hm, i suppose you could compare it with `STR$(...)' and so
11:46:41 <koality> what does "xs" mean, I know what it means logically, but why is it named xs?
11:46:48 <ski> koality : plural of `x'
11:47:01 <monochrom> Sigil = compulsory Hungarian notation
11:47:02 <koality> ski: makes sense lmao
11:47:25 <ski> (is the plural convention basically hungarian ?)
11:47:38 <monochrom> Until you have to decide whether it's "xs" or "xes".
11:47:53 <monochrom> Yes.
11:48:16 <EvanR> x : x-en
11:48:29 <monochrom> You could have chosen "head : tail", "first : rest", "one : more" for example.
11:49:15 <ski> naming is hard
11:49:25 <tdammers> head : tail would be thoroughly confusing, considering there are functions of the same names in Prelude
11:49:49 <EvanR> naming is hard, code should be an unlabeled cyclic graph
11:50:16 * ski . o O ( LabVIEW )
11:50:16 <tdammers> anyway, x:xs is as good as it gets IMO, at least as long as there is no more meaning to those variables than "a value, and some more values"
11:50:49 <tdammers> there's the fact that they are the head and tail of a list, but this is already obvious from the : construct, no need to redundantly state the obvious again, redundantly
11:50:50 <cocreature> and if you already used x:xs, there’s always y:ys :)
11:51:14 <EvanR> in another language you should be encouraged to write item:items box:boxes enemy:enemies or myAwesomeName : myAwesomeNames (no matter how long)
11:51:48 <monochrom> Oh yeah is it "y : ys" or is it "y : ies"?  >:)
11:52:09 <tdammers> EvanR: that also works, but Haskell code is often abstract enough that there is no meaning to them other than "thing", "other thing", etc., so might as well use single-letter names
11:52:18 <c_wraith> foo (x:items) (item:xs) = ...
11:52:19 <tdammers> if they're more specific, then by all means use more specific names
11:52:26 <EvanR> a lot of list code is generic yes
11:52:44 <cocreature> firstListElement : restOfTheList
11:52:46 <cocreature> very generic
11:52:50 <tdammers> and I'd much rather see 'x' than some longer but equally generic name
11:53:02 <tdammers> information density matters
11:53:10 * ski . o O ( "Let's invent pointless pattern-matching." )
11:53:10 <EvanR> is it as generic as in, in PHP all my variables were called "data" because its an Array of "anything" ? :)
11:53:19 <EvanR> so name every such thing data
11:53:36 <ski> (and name every type `T')
11:53:45 <EvanR> haha
11:53:49 <tdammers> gawd
11:55:28 <monochrom> Yeah when I don't feel like "x:xs" I use "hd:tl" so it is not too long.
11:56:20 <monochrom> "maybe" and "either" are examples of pointless pattern matching.  Apart from missing out @ patterns.
11:56:48 <monochrom> Just look at how Oleg writes "maybe id x" all the time :)
11:56:57 <lavalike> x:xs also generalizes in directions such as y:ys and xs:xss
11:57:05 <cocreature> ski: hello henning
11:57:17 <c_wraith> Why doesn't Henning put all his functions in their own modules and name them all f?
11:57:30 <monochrom> heehee
11:57:38 <monochrom> Yes someone should tell him that.
11:57:43 <EvanR> lol
11:58:02 <EvanR> so a form of move all naming into one name-able feature
11:58:03 <EvanR> the modules
11:58:19 <monochrom> No, someone should pull an April 1st joke and override Henning's packages on Hackage to do that.
11:58:33 <cocreature> nobody would notice
11:58:52 <EvanR> acme-henning
11:59:05 <monochrom> Announce it on haskell-cafe.
12:00:23 <ski> monochrom : i was thinking of something more like a concatenative language with pattern matching. where you'd have something like `: nil length = 0 | cons length = drop length +1 ;'
12:02:11 <ski> the Haskell version would be like `length [] = 0; length .: (:) = const ((+1) . length)', perhaps
12:04:49 <Athas> Does anyone here have experience with generating fairly large Template Haskell expressions?  I find that they slow compilation to a crawl, and I'm wondering if there are any tricks I could use.
12:05:10 <Athas> I've considered first serialising the data I want to embed to a ByteString, as my experience is that these can be 'lift'ed fairly efficiently.
12:06:57 <EvanR> template template haskell?
12:07:34 <EvanR> should exist
12:08:07 <cocreature> how many levels of template haskell are you on
12:08:15 <c_wraith> Athas: have you considered just throwing the file into the data section of the package?
12:08:56 <EvanR> fix template
12:10:17 <Athas> c_wraith: it's not a file.  I'm writing a compiler, and I'm embedding the parsed and type checked "standard library" directly in the compiler binary, in order to speed up compilation.
12:10:31 <Athas> So I'm basically embedding a big-ish AST.
12:10:44 <c_wraith> Oh.  so you're speeding up compilation by slowing meta-compilation? :)
12:10:47 <Athas> Yes!
12:10:57 <Athas> But I would like to speed up meta-compilation a bit.
12:11:04 <EvanR> with meta-meta-compilation
12:11:04 <Athas> It really sucks to have a module that takes 5+ minutes to compile.
12:11:46 <Athas> It's not the parsing/type-checking (in the TH action) that takes the time; I don't even think it's the 'lift' call itself.  It's whatever GHC does with the result of the TH splice.
12:12:16 <dolio> Maybe you should just have a switch that doesn't do that part.
12:12:24 <c_wraith> yeah, GHC isn't great with huge nested literals
12:12:35 <adius> I'm a little late to the party, but x:xs is awful. I don't know how many times I read it until I realized it's supposed to mean one x, several xs
12:12:38 <dolio> So most of the time you build with it off.
12:12:59 <adius> Or maybe I never realized it and someone hat to explain it to me. 
12:14:20 <EvanR> i may recall x : xs being explicitly explained in the gentle introduction to haskell
12:14:38 <EvanR> that no one ever recommends anymore
12:15:19 * ski liked it
12:15:36 <Athas> dolio: I do that, sure, but it would be even better if it was fast enough that no switch was needed.
12:24:48 <geekosaur> EvanR, monochrom recommends it every so often. As do I.
12:25:15 <EvanR> huzzah, there is still hope
12:33:44 <koality> is it possible for a function to output a tuple where both elements are of type Double?
12:34:10 <koality> would: -> (Double, Double), work?
12:34:20 <zachk> > let f x = (x,x) in f (5::Double) 
12:34:22 <lambdabot>  (5.0,5.0)
12:35:02 <koality> more particularly, function :: Double -> Double -> Double -> (Double, Double)
12:35:34 <koality> zachk: I'm interpreting that as a yes?
12:35:46 <zachk> yea you can do that
12:35:52 <koality> awesome
12:35:58 <zachk> though my f would be like a -> (a,a) 
12:36:17 <zachk> tuples can be made of any combination of types 
12:36:33 <zachk> great for multiple return values
13:01:35 <trcc> Oh god it takes a long time to install hakyll. Been on it 15 minutes now!
13:02:11 <cocreature> building hakyll and all its deps takes more like 15h rather than 15min :)
13:02:45 <trcc> is there any better way when I need to use it?
13:06:46 <monochrom> Offer money for someone else to build it for you.
13:08:03 <EvanR> joking aside... 
13:08:41 <EvanR> are we leaving the garden of able-to-compile-everything-at-home-on-your-toaster eden with these compilation times or
13:08:46 <EvanR> just haskell just suck
13:08:48 <MarcelineVQ> I can't tell if I somehow ended up with a supercomputer or everyone else uses potatoes :X Haskell compile times were never to extreme on my end
13:08:49 <EvanR> does it*
13:09:15 --- mode: glguy set +v Guest18
13:09:29 --- mode: glguy set +v codedurr
13:09:52 <cocreature> for hakyll the problem is more that it depends on all of hackage
13:10:06 <cocreature> rather than the compile times for individual modules being unreasonably high
13:10:12 <codedurr> heh you should try nodejs
13:11:00 <codedurr> but yeah, it does generally need more dependencies than something in Java or C but less than node / python as far as I can tell
13:11:45 <codedurr> although I wonder if the community were to grow as large as node, dependencies might get just as bad?
13:12:49 <phadej> well, hakyll depends on pandoc. If you want that power, you have to pay
13:12:54 <noumenon> just thinking about haskell and the underlying mathematics in general, am I correct in intuitively thinking that expressions like "f a" and "m a" used in the definitions of a functor and a monad respectively mean something along the lines of "something of type a in the context of a functor f/monad m"?
13:13:44 <phadej> noumenon: it's just "f of a" like in "list of ints"
13:13:59 <geekosaur> (You have a Haskell problem, and you decide to use lens. Now you have the whole ecosystem's problems too.)
13:14:18 <phadej> hakyll doesn't use lens :)
13:16:16 <tdammers> lens, a.k.a., the convenient metapackage that you use to install all of hackage at once
13:16:51 <phadej> really, barely 30 packages of almost 10000?
13:17:31 <phadej> repating that myth does more harm than is fun
13:17:53 <Athas> EvanR: my impression is that compilation times are shorter than they used to be.
13:18:39 <Athas> E.g. when I used Gentoo around 2004, there would be packages (like OpenOffice) that took an entire weekend to build.  That never happens anymore.  Of course, those packages weren't in Haskell!
13:18:39 <tdammers> point in case, lens is practically never the source of nasty dependency conflicts
13:18:43 <davean> EvanR: I an compile a Linux kernel with default config in under 2 minutes.
13:18:52 <glguy> the packages it does depend on tend to be pretty small, we went through and eliminated most of the seemingly superfluous ones
13:19:01 <Athas> And most Haskell programs are not large enough to take hours to compile, even with the slowness of GHC.
13:19:18 <davean> Athas: I never had OpenOffice take more than an evening
13:19:20 <tdammers> Athas: GHC itself can take hours to compile and validate...
13:19:47 <davean> tdammers: I can get a full optimized compile and evaluation in under 2 hours, even on ARM
13:19:53 <EvanR> davean: yeah, thats not haskell
13:20:01 <davean> EvanR: You asked "is it just haskell"
13:20:17 <EvanR> does haskell just suck
13:20:33 <EvanR> for compilers
13:20:51 <davean> GHC is a very slow compiler, I don't think that says anything about Haskell.
13:21:04 <EvanR> mmhmmmmmmmm
13:21:29 <davean> Other Haskell compilers haven't been as slow.
13:22:11 <Athas> Haskell requires a lot of work from the compiler to get decent performance.
13:22:12 <davean> GHC is a research project - if you want things other than new features from it, provide some developers?
13:22:55 <EvanR> a project focused mostly on pumping out new features?
13:23:19 <glguy> Yeah, if you want something suitable for use in production there are lots of other languages
13:23:43 <tdammers> that's not entirely fair; GHC has long been mainly a research project, but by now there are plenty of stakeholders in "the industry" who push for things like robustness, performance, etc.
13:23:45 <Athas> There is very little research on making compilation itself efficient, and the people who do it don't do it for GHC.
13:24:18 <codedurr> meh industry, seems to know what they want, mostly won't do anything about it
13:24:38 <Athas> tdammers: the industrial interests also contribute directly to GHC, right?
13:24:57 <tdammers> Athas: some of them do, yes; some also provide funding
13:25:22 <davean> Few
13:25:27 <Athas> Then how come GHC is generally so unstable?  I'd expect industry to be a bit risk-averse.
13:25:35 <davean> Athas: Very few.
13:25:37 <Athas> I even feel that GHC has become *less* stable over time.
13:25:39 <codedurr> same with any language, how many use java, how many contribute to openjdk...
13:26:21 <davean> Does anyone care? Thse seems a non-issue
13:26:46 <glguy> There have been some attempts to have an organization that companies that use Haskell could support, but it didn't work out. Industrial Haskell Group was going for a bit
13:26:53 <Athas> Of all the compilers I use, GHC is the only one that semi-regularly crashes (not counting experimental compilers).  Not saying I haven't ever seen GCC crash or miscompile code, I just can't even remember when last that was.
13:27:17 <davean> Huh, I've almost never seen GHC crash - WTF did you do?
13:27:21 <dolio> I can't remember when GHC last crashed for me.
13:27:37 <davean> I have seen GCC crash or produce invalid code a bunch
13:27:43 <johnw_> I think the head explosion error is even gone now :(
13:27:44 <tdammers> Athas: I think this impression is at least in part caused by a fairly massive increase in Haskell adoption in the wild - people have started using it for mission-critical stuff lately, so edge cases and dark corners are hit more often
13:28:04 <Athas> davean: for example, the lexer in GHC before 8.6 will segfault if you run haddock on language-c-quote.
13:28:24 <Athas> And GHC 8.4 and 8.2 is really crash-happy on Windows, although I don't remember the specifics as to why.
13:28:28 <davean> Athas: GHC, not haddock?
13:28:32 <Athas> davean: yes.
13:28:37 <davean> Oh, yah, I hear people use windows sometimes.
13:28:38 <Athas> Haddock uses the GHC lexer.
13:28:47 <davean> I tihnk I even meet one of them at ICFP
13:28:50 <Athas> GHC 8.6 has that infamous code generation bug for some Ord instances.
13:28:56 <davean> Athas: Using the GHC lexer, and GHC are seperate
13:29:16 <Athas> I've also had 'the impossible' happen in GHC semi-regularly.
13:29:28 <Athas> But that's usually due to type errors in my own code, so it's not so bad.
13:29:38 <davean> Oh, if you're going to talk about known code gen bugs VS. ones you actually encounter, than GCC is REALLY scary
13:29:49 <dstolfa> davean: C is really scary in general
13:30:36 <davean> Athas: I'm amused you call out 8.6 but not 8.4
13:30:39 <Athas> I really hope GHC 8.6 will be the version that fixes all my outstanding issues (no idea whether the Ord thing will affect me), because right now I'm actively using *three* different major versions because each has deficiencies on some platforms.
13:30:44 <davean> I'd consider the code gen bugs in 8.4 to have been far more serious
13:31:05 <Athas> davean: I don't go looking for bugs; I just find them sometimes.  Offhand, I can't recall whether I've had 8.4 miscompile on me.
13:31:11 <tdammers> another thing is that a large portion of those crashes happen with relatively new features; so those bugs didn't exist in, say, GHC 6, not because that version was more robust, but because you simply couldn't write the code that triggers the bug at all
13:31:37 <Athas> Definitely!  All else equal, fewer features means fewer bugs!
13:32:05 <Athas> I really don't think I'm pushing GHC much, though.  Except for the library changes, I don't think I'm using anything that wasn't in 7.0.
13:32:16 <Athas> (But maybe my deps are.)
13:32:50 <koality> I'm making a pretty simple function but can't figure out what the issue is. Can someone here please point me to the right direction?
13:32:56 <tdammers> well, there are a few strange things going on with optimizations, too, and some of them need nothing beyond haskell98, really
13:32:57 <koality> https://0bin.net/paste/Xdw6wV627frboaKs#s8NH69YTsu7Ju4mRAr9OMWmVH1DtDG64yG+ZUaXQrGE code and error produced
13:33:35 <tdammers> in fact, I'm dealing with such a bug right now
13:33:49 <glguy> koality: (-) b + discRoot    should be:  -b + discRoot
13:34:00 <glguy> (-) is the prefix name of subtraction
13:34:29 <Athas> I wonder how often the OCaml compiler miscompiles.
13:35:11 <dstolfa> Athas: in fun ways!
13:35:26 <koality> thank you!
13:35:40 <dolio> We ran into mis-compilation problems at work not that long ago for... JavaScript maybe.
13:36:23 <dolio> Like, if you're assuming that that precludes 'industrial use', I think you're wrong.
13:38:13 <dolio> Lots of the tools I have to use at work aren't very good. :)
13:39:38 <dstolfa> dolio: `industrial use' is a fancy word for `i think i can use this tool to do work'
13:39:56 <dstolfa> i've yet to run into a tool that hasn't annoyed the living hell out of me at some point
13:41:58 <Athas> dolio: oh, I know that actually proprietary tools are awful.  Hardware-specific C compilers for embedded platforms are supposed to be a joke.
13:42:21 <dolio> Not just the proprietary ones.
13:42:25 <Athas> But those are used when there are no or worse alternatives.  GHC, on the other hand, does have alternatives!  (Well, Haskell has.)
13:42:29 <koality> is there any way I can get rid of -0.0 output for a double? (not absolute value)
13:42:38 <Athas> koality: get rid?
13:42:44 <koality> the negative part
13:42:51 <Athas> Why not absolute value?
13:43:02 <koality> it outputs negative numbers too
13:43:12 <koality> but -0 = 0
13:43:20 <Athas> So what's wrong with -0?
13:43:41 <Athas> Just do something like 'if x == -0 then -x else x'.
13:43:49 <koality> thanks
13:44:00 <dolio> That's not going to work.
13:44:14 <Athas> Oh, right, it's not.
13:44:15 <dolio> > if 0 == -0 then -0 else 0
13:44:17 <lambdabot>  0
13:44:23 <koality> I'll just leave it as -0, was just wondering if there was anything built in
13:44:24 <dolio> Hmm.
13:44:27 <Athas> You need to check whether it's zero *and* whether the signum is negative.
13:44:27 --- mode: glguy set +v mckeanalicej
13:44:30 <dolio> Oh, right. That's not doing doubles.
13:44:40 <Athas> But keeping it as -0 is really the right thing to do.
13:44:59 <mckeanalicej> Does anyone know why the first three instances work fine but the last instance doesn't work?: https://gist.github.com/mckeankylej/b6630f5230c034200d0364aff98f6a41
13:45:00 <geekosaur> that's abs. and negative zero does have significance if your'e doing limits or trigonometry around the zero point
13:45:06 <mckeanalicej> The type error is at the bottom
13:45:49 --- mode: glguy set +v verement
13:45:57 <verement> > map (\x -> if isNegativeZero x then -x else x) [0.0, -0.0]
13:45:59 <lambdabot>  [0.0,0.0]
13:46:49 <mckeanalicej> Its like the type family doesnt get evalutated
13:46:58 <mckeanalicej> which is weird because I thought type families were strict
13:59:49 --- mode: glguy set +v MrTweetyMuch
14:00:40 <MrTweetyMuch> hi there
14:00:56 <saml> hi mr
14:01:45 <MrTweetyMuch> I am new to IRC and I wonder what are good IRC channels to meet nice people.
14:04:05 <glguy> Hi MrTweetyMuch. This channel isn't for finding channels to chat in, it's for talking about the Haskell programming language. Most channels on Freenode are specific to some open source project or language.
14:05:39 <saml> i'm nice people
14:09:37 <koality> If i was making a boolean function that checks if 'x' is in a list, is it possible for a single function to support multiple data types for 'x' and the list? 
14:10:40 <verement> :t elem
14:10:42 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
14:10:56 <koality> Like can I make it so a function that tests if x is in a list supports all types?
14:11:21 <remexre> Is there a Getter (in lens) that always gets the same value?
14:11:54 <verement> > elem 3 [0..9]
14:11:56 <lambdabot>  True
14:12:02 <verement> > elem ‘x’ [‘a’..’f’]
14:12:04 <lambdabot>  <hint>:1:6: error: lexical error at character 'x'
14:12:45 <saml> > elem 'x' ['a'..]
14:12:47 <lambdabot>  True
14:13:19 --- mode: glguy set +v cozachk
14:13:30 <cozachk> @type elem
14:13:32 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
14:13:49 <saml> is Foldable covariant?
14:13:51 <koality> cool, thanks I'll try it out
14:14:42 <koality> When defining the function, how would I go about doing this so it supports any type? I tried: "function a -> b -> Bool" but that doesn't work
14:14:45 <c_wraith> saml: well, an instance of Foldable must be covariant in its type variable, if that's what you mean
14:15:24 <glguy> koality: You'll probably want to find a good book or tutorial on Haskell to help you learn the basics
14:15:33 --- mode: glguy set +v chessai
14:15:34 <koality> function :: a -> b -> Bool
14:15:38 --- mode: glguy set +v chessai
14:16:12 <chessai> it seems to be a problem in the ordering of type inference by GHC 
14:16:51 <chessai> since box and unbox are levity polymorphic, when you pattern match on (# a, b #), it doesnt yet know what to unify a and b with
14:17:11 <chessai> since you cant pattern match on levity polymorphic variables, it's rejected
14:17:19 <chessai> but if you instead define some functions
14:17:39 <chessai> stuff# :: (# Int#, Int# #) -> Stuff; stuff# (# x, y #) -> Stuff x y
14:17:40 <chessai> and
14:18:03 <chessai> unStuff :: Stuff -> (# Int#, Int# #); unStuff# (Stuff x y) = (# x, y #)
14:18:12 <cozachk> koality, you want something like yourFunctionNameHere :: a -> [a] -> Bool 
14:18:21 <chessai> box = stuff#; unbox = unStuff#;
14:18:26 <chessai> it compiles just fine
14:18:37 <c_wraith> cozachk, koality:  You probably want an Eq constraint, too
14:18:39 <chessai> this seems sort of annoying, almost like a half-bug,
14:18:49 <cozachk> yeap forgot that
14:19:08 <cozachk> koality, you want something like yourFunctionNameHere :: (Eq a) => a -> [a] -> Bool 
14:19:36 <koality> I'm very sleep deprived... I forgot the "::" as well
14:19:46 <koality> thank you kind peoples
14:20:00 <c_wraith> koality: take the time to get some sleep.  Haskell will still be around when you wake up. :)
14:20:18 <koality> Working 60hrs/week + full time student D:
14:25:25 <chessai> mckeanalicej: https://gist.github.com/chessai/64c4f08dde865371d9a536d43c3917e5
14:28:15 <mckeanalicej> chessai: its dependent on where you define stuff and unStuff in the file
14:28:50 <mckeanalicej> if you move them to the bottom of the file it doesnt compile
14:29:02 <mckeanalicej> that is bizarre this is def a bug in ghc 
14:30:06 <cozachk> does anyone have any experience using or playing with Data.Depdendent.Map or something similar?
14:30:07 <mckeanalicej> this means that that typeclass is worthless because you cant define functions outside the file
14:31:05 <mckeanalicej> actually its dependent on where you define the datatype
14:31:16 <mckeanalicej> if you put it after the typeclass it fails
14:32:01 <chessai> mckeankylej: really? wow
14:32:08 <chessai> mckeanalicej*
14:39:04 <chessai> mckeanalicej: https://ghc.haskell.org/trac/ghc/ticket/15777#ticket
14:40:19 <koality> Anyone here familiar with the "Occurs check: cannot construct the infinite type: a ~ t0 [a]" error?
14:40:22 <koality> https://0bin.net/paste/C5p4c9F-lsRGgc7s#qkhu6Kc001FDyirZl8MgfCoS0cNCqP4DsC645RIjh8e
14:40:42 <koality> This checks if all elements in list1 are present in list2
14:40:55 <chessai> koality: you got the arguments of elem fixe
14:40:59 <chessai> mixed up
14:41:01 <chessai> :t elem
14:41:02 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
14:41:12 <chessai> it should be 'elem x y' 
14:41:14 <chessai> not elem y x
14:41:32 <chessai> its telling you that it wants something of type 'a' there, but you gave it something of type 't a'
14:41:42 <chessai> or rather, t [a]
14:42:06 <koality> chessai: so you're saying change   | elem y x = allOccursIn y xs to   | elem y x = allOccursIn xs y   ?
14:42:16 <chessai> on line 3
14:42:31 <chessai> elem y x -> elem x y
14:43:05 <chessai> also, this isnt a type error, but im not sure you mean to flip y and xs in 'allOccursIn'
14:43:09 <chessai> also on line 3
14:43:31 <chessai> in the recursive call, youre flipping the order of the lists, so its alternating between the lists for membership checks
14:43:36 <koality> chessai: Hmm... it got rid of the error but now the program isn't working as intended 
14:43:55 <chessai> probably cuz of the thing i just said about flipping the lists
14:44:10 <chessai> also, this program can never return True
14:44:27 <chessai> once the second list is empty, it will return False
14:44:48 <chessai> what are you trying to write?
14:44:50 <koality> This is my intended behavior:
14:44:56 <koality> allOccurIn [1,2,3] [3,2] False  allOccurIn [1,2,3] [3,2,1,5,6] True  allOccurIn [1,2,3,2] [3,2,1,5,6] True
14:45:47 <chessai> so allOccursIn x y means that x is a subset of y
14:46:13 <koality> chessai: exactly
14:50:14 <chessai> koality:
14:50:18 <chessai> you probably want 
14:50:27 <chessai> allOccursIn :: Eq a => [a] -> [a] -> Bool;
14:50:34 <michalrus> • Could not deduce (Database.PostgreSQL.Simple.ToField.ToField CleartextPassword)
14:50:37 <michalrus> ♥
14:50:38 <chessai> allOccursIn [] [] = True;
14:50:44 <michalrus> I almost did that. :p
14:50:46 <chessai> allOccursIn _ [] = False;
14:50:57 <chessai> allOccursIn [] _ = True;
14:51:09 <chessai> allOccursIn (x:xs) ys = elem x ys && allOccursIn xs ys
14:51:22 <chessai> is one of those pattern matches redundant cuz of the ordering?
14:52:09 <chessai> koality: that does what you want i believe
14:52:17 <koality> chessai: thanks so much! I'll test that out later! I gotta head off to work
14:52:25 <chessai> koality: ok
14:53:16 <koality> actually ill try it out really quick rn
14:55:19 <koality> chessai: you're a legend mate
14:55:23 <koality> it worked
14:55:45 <koality> I'll test for redundancy and any possible potimizations
14:55:47 <koality> thanks again
15:12:06 --- mode: glguy set +v jackdk
15:35:04 <__monty__> You can ditch the [] [] = True if you put [] _ = True first.
16:58:04 <fragamus> can ghc emit c code instead of object code
17:00:16 <hpc> -fvia-c used to be the thing for it, not sure if it's still there
17:00:27 <hpc> but it's pretty crap
17:00:40 <hpc> you most likely want the FFI
17:01:15 <fragamus> haha i am sure but if it compiles it'll be great fun
17:04:19 <Solonarv_> it can also emit LLVM, which is probably slightly less broken/abandoned
17:04:30 <hpc> i still think someday it'd be really cool if rust got a rich abi that ghc could be aware of
17:04:50 <hpc> they both have ADTs and care about their type systems
17:04:59 <hpc> ghc is getting affine types
17:05:01 <hpc> it'd be incredible
17:37:12 <romildo__> @pl \((_,y),v) -> (y,v)
17:37:12 <lambdabot> first snd
17:45:23 <jackdk> @pl \(x,(y,_)) -> (x,y)
17:45:23 <lambdabot> uncurry ((`ap` snd) . (. fst) . (const .) . (,))
17:46:44 <MarcelineVQ> because  second fst  was too obvious
17:47:31 <ar1a> say you have 3 maybes, foo bar baz, and you want to check that all of them are Just instead of Nothing, how can you do that without a case switch for each one, and nesting them one by one -- seems like a big smell
17:48:01 <ar1a> for example https://i.imgur.com/yFnYpyG.png
17:48:21 <jackdk> what do you want to do with the just values after? The Applicative instance for Maybe will let you do things like
17:48:24 <jackdk> :t liftA3
17:48:25 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
17:48:34 <jackdk> :t liftA3 @Maybe
17:48:35 <lambdabot> error:
17:48:35 <lambdabot>     Pattern syntax in expression context: liftA3@Maybe
17:48:35 <lambdabot>     Did you mean to enable TypeApplications?
17:48:47 <jackdk> :set -XTypeApplications
17:49:18 <MarcelineVQ> jackdk: yahb does TypeApplications but lambdabot does not
17:49:19 <jle`> lambdabot doesn't let you set extensions
17:49:24 <jle`> % :t liftA2 @Maybe
17:49:24 <yahb> jle`: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
17:49:24 <jackdk> anyway with f ~ Maybe that will apply a function across all of your things
17:49:59 <jle`> ar1a: yea in your code that's `Person <$> mkName n <*> mkAddress a`
17:50:07 <ar1a> im not sure, i just saw the snippet in the wild and thought i'd ask
17:50:12 <jle`> or liftA2 Person (mkName n) (mkAddress a)
17:50:22 <ar1a> how does that work?
17:50:26 <ar1a> the fmap and apply 
17:50:29 <jle`> it's a typeclass method
17:50:32 <ar1a> havent got a great mental model of them
17:50:39 <jle`> it's defined separately for each type
17:50:45 <jle`> and for Maybe, its behavior is combine-if-both-are-Just
17:50:46 <jackdk> you could use do notation, and use Maybe's Monad instance to construct something like do { f <- foo; b <- bar; z <- baz; ... }
17:51:08 <jle`> ar1a: ah yeah, remember that it's (f <$> foo) <*> bar
17:51:18 <jackdk> if they're all of the same type, you could put them in a list and catMaybes, or use sequenceA to go from [Maybe a] to Maybe [a]
17:51:20 <jle`> % :t (<*>) @Maybe
17:51:20 <yahb> jle`: Maybe (a -> b) -> Maybe a -> Maybe b
17:51:29 <jle`> <*> applies a function 'in maybes' to each other
17:52:21 <ar1a> so, x = Just id, y = Just 5, x <*> y == 5?
17:52:29 <ar1a> or == Just 5
17:52:51 <jackdk> Just 5.
17:53:05 <ar1a> not really sure how you can fmap Person into mkName n though
17:53:19 <ar1a> what does that even do 🤔
17:53:30 <jle`> ar1a: it's partial application
17:53:56 <ar1a> ohh okay so...
17:54:07 <jle`> what is the type of Person?
17:54:29 <MarcelineVQ> newtype Name = Name String deriving (Eq, Show)  newtype Address = Address String deriving (Eq, Show)  data Person = Person Name Address  deriving (Eq, Show)    mkName :: String -> Maybe Name   mkAddress :: String -> Maybe Address
17:54:33 <ar1a> foo x y = x + y, foo <$> 3 == Integer -> Integer
17:55:10 <jle`> ar1a: so if Person :: Name -> Address -> Person
17:55:19 <jle`> Person <$> Just 3 would be Just (Person 3)
17:55:40 <jle`> er, Person <$> Just myName = Just (Person myName)
17:55:53 <ar1a> uhhhhuhhhhh
17:56:00 <MarcelineVQ> The very source of this snippet is the prelude to explaining Applicative for it, so if you have this resource time would be better spent reading it instead of asking about it :>
17:56:13 <MarcelineVQ> Time of yours and others
17:56:17 <jle`> Person myName :: Address -> Person
17:56:33 <ar1a> i probably didnt scroll down far enough then, seemed like the author started going on a tangent and i figured i'd ask
17:57:15 <jle`> ar1a: if Person :: Name -> (Address -> Person), then Person myName :: Address -> Person
17:57:30 <jackdk> ar1a: the thing that really helped me to "get" Applicative was to sit down and work through the paper that introduced it with a pencil and paper, tracing the types of each subexpression: http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf
17:57:46 <jackdk> your learning style may be different but I'm just putting it out ther
17:57:59 <ar1a> ill take a look in a bit
17:58:53 <MarcelineVQ> Don't scroll down, read down :>  everything jle` is saying and going to say is also about to be said in your book there hehe
18:01:11 <MarcelineVQ> Except the part about caiman, that's not in the book, jle` just likes them.
18:01:27 * ar1a facepalms
18:07:56 <ab9rf> p
18:08:08 <ar1a> h
18:08:20 <ab9rf> sirry
18:08:31 <ab9rf> thus terminal is too small
18:09:22 <ab9rf> and behaces weurdky
18:12:06 <ar1a> okay so once you have Person <$> mkName n <*> mkAddress a, if you want to add another argument
18:12:09 <ar1a> is it just append another apply
18:13:25 <jackdk> yeah the general pattern is func <$> thing1 <*> thing2 <*> thing3 <*> ... <*> thingN
18:13:49 <ar1a> cheers
18:14:04 <ar1a> i understand why it works, but... i wouldnt think of it 
18:14:08 <ar1a> if that makes sense
18:15:04 <jle`> if it makes you feel any better, it took a long time for people to invent this too
18:15:11 <ar1a> lol
18:15:14 <jle`> it's a relatively new thing in terms of haskell history
18:15:21 <ar1a> really?
18:15:44 <jackdk> yeah, and plumbing it into the standard libraries was a big refactoring effort that spanned multiple GHC versions
18:15:45 <jle`> applicative wasn't really adopted until around 18 years or so after haskell was invented
18:15:54 <jle`> er, haskell was...born?
18:16:02 <jle`> so haskell was already a legal adult
18:16:06 <ab9rf> heh
18:16:07 <ar1a> hatched
18:16:18 <ar1a> 🥚
18:16:26 <jle`> a baby born at the same time as haskell would be able to grow up and gain the right to vote before applicative was adopted
18:16:26 <ab9rf> quacked
18:16:55 <ar1a> lol, funnily enough im 18
18:17:16 <ab9rf>  feel old
18:17:30 <jle`> we actually had to go through some growing pains along the way; there were a few abstractions that were invented to do what we use applicative for today, but we recognize them now as failed-ish abstractions
18:17:42 <jle`> so the road to applicative was bumpy indeed
18:17:53 <jle`> i'm glad we got here eventually though :)
18:18:09 <ar1a> me too 
18:18:10 <jackdk> which ones are you thinking of when you say that, jle`?
18:18:21 <Solonarv_> yeah I'm curious too
18:18:22 <jle`> most famously Arrow, which actually got absorbed into base
18:18:39 <jle`> it got far enough to get built into the compiler actually
18:19:02 <jle`> but nowadays most of the problems that Arrow was invented to solve are now exposed through Applicative interfaces
18:19:12 <jle`> things like static analysis of effects
18:19:16 <ab9rf> i do not really understand arrows
18:19:23 <jackdk> yeah arrow is interesting. I used it a bit with Opaleye, but the abstraction is a bit of an odd duck
18:19:29 <jle`> ab9rf: and it's a good thing now that you don't ever have to :)
18:19:57 <ab9rf> i caf
18:20:13 <Solonarv_> wasn't there an arrow-based build system somewherr? that seems like a good fit for the abstraction if there's any
18:20:28 <ab9rf> i came to thr cinclusion that the effort to kearn arriws was not wotyh it
18:20:45 <jle`> it's very rare to have an arrow-based abstraction that applicative wouldn't be a better fit for
18:20:49 <ab9rf> tgis jeybosrd sucjs
18:21:14 <jle`> nobody ever actually liked using arrows, the way we enjoy using applicative today
18:21:34 <jle`> and i say that as someone who maintains a couple of arrow-based libraries
18:21:36 <ar1a> "hey what are you doing tonight, wanna go bowling" "na gonna stay in and apply"
18:22:04 <jackdk> good life choices
18:22:10 <ab9rf> can you model bowling using applicatives?
18:22:45 <ar1a> ball <*> pins
18:23:42 <Solonarv_> I want someone to write a blog post which is just a series of puns like that
18:24:04 <Solonarv_> unfortunately this is ~6 months too late (or early)
18:24:17 <ar1a> be the change you want to see in the world
18:25:05 <ab9rf> 57 more minutes
18:25:10 <Solonarv_> nyeeeehh effort
18:43:27 <ar1a> haskell has a serious lack of graphql libraries :[
18:57:15 <jle`> :[
18:58:33 <ar1a> :{
18:59:08 <MarcelineVQ> :<
18:59:19 <ar1a> :-
18:59:58 <ab9rf> write one
19:00:12 <ar1a> i can barely apply functions :p
19:17:23 <MarcelineVQ> What is a serious lack?
19:25:34 --- mode: glguy set +v mckeanalicej
19:26:04 <mckeanalicej> does anyone know if readWord32ByteArray from GHC.Prim reads little endian or big endian words?
19:28:59 <ab9rf> tesy it abd see
19:31:06 <geekosaur> my guess is it's the platform default
19:39:16 <MarcelineVQ> I got lost in STG internals trying to find out
19:40:24 <MarcelineVQ> readWordnArray# is fairly general it seems
19:58:08 --- mode: glguy set +v jackdk_
19:58:11 --- mode: glguy set -v jackdk_
20:03:25 <mniip> jle`, do you understand yoneda
20:09:44 <jle`> mniip: the type or the lemma
20:10:00 <mniip> the lemma
20:10:12 <dyl> I mean clearly the type is a proposition... 
20:10:31 <koz_> :t Yoneda
20:10:32 <lambdabot> error: Data constructor not in scope: Yoneda
20:10:35 <koz_> :(
20:10:47 <dyl> > fix error 
20:10:47 <mniip> dyl, "the type" would be the yoneda embedding
20:10:49 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
20:10:53 <jle`> i suppose so, mniip 
20:10:59 <mniip> :t Data.Functor.Yoneda.Yoneda
20:11:01 <lambdabot> (forall b. (a -> b) -> f b) -> Data.Functor.Yoneda.Yoneda f a
20:11:08 <mniip> jle`, can you explain?
20:11:36 <jle`> isn't it roughly that Yoneda f a ~ f a ?
20:12:10 <dyl> But doesn’t that imply f a ~ f a?
20:12:37 <jle`> i mean i suppose the non-trivial thing is that (forall b. (a -> b) -> f b) is equivalent to (f a)
20:13:01 <cemerick> is there a set of bindings available for node (for example) that would make integrating a javascript codebase easier/faster than just running a node process alongside and basically doing RPC?
20:13:01 <dyl> That’s a good way to put it.
20:13:02 <jle`> or (forall b. (A -> b) -> F b) is equivalent to F A, to be explicit about what is quantified
20:13:36 <dyl> cemerick can you qualify what you mean? 
20:14:07 <jle`> i believe it's often used to re-associate some fmaps or something in haskell for efficiency purposes or something
20:14:51 <dyl> cemerick: there’s the important question of whether you want to make the assumption that your Haskell and Node processes are running in the same process space. 
20:15:11 <dyl> Is that actually easier or better in any way? 
20:15:23 <dyl> Or does it just undercut modularity?
20:15:56 <cemerick> dyl: that would be ideal; as an analogue, I'd point to jpype, which embeds a JVM in python, and allows you to call JVM libraries completely transparently and without e.g. data copies if you're passing around e.g. byte[]s
20:16:10 <dyl> That doesn’t sound good. 
20:16:27 <dyl> Most IPC-esque communications are not CPU bound, they’re IO bound. 
20:16:42 <dyl> So the savings on “completely transparent” calls don’t pass the utility smell test.
20:16:59 <dyl> Why would I want to call a JVM library in Python with no copies?
20:17:35 <dyl> What’s the use case? 
20:18:52 <dyl> I mean, I could just use mmap on both ends.
20:19:12 <dyl> With a lock file or OS primitive of some kind.
20:21:11 <jle`> mniip: i sometimes think of yoneda like cps-for-functors, kinda.  we know that (forall b. (A -> b) -> b) is equivalent to A, so yoneda is the same thing, (forall b. (A -> b) -> F b) is equivalent to F A.  not sure if that gets anywhere towards the insight that ti's supposed to provide though
20:22:04 <mniip> that makes sense to me in a CCC like Hask
20:22:07 <mniip> but not in general
20:24:25 <jle`> hm, if we rewrite it a bit
20:24:55 <jle`> and use type f ~> g = forall a. f a -> g a, to represent a natural transformation
20:25:22 <jle`> then it's saying that `Reader A ~> F` is isomorphic to `F A`
20:25:46 <ktonga> hey everyone. quick question: if I want to type-annotate a function within `where` refering to type params from the top-level function... can I?
20:26:02 <ktonga> if i try using the same name for the type it seems to be creating a new different one
20:26:13 <mniip> jle`, yes but what is the deep meaning of this
20:26:16 <jle`> there is a one-to-one correspondence between all nat-trans Reader A ~> F, and all elements of F
20:26:28 <jle`> ktonga: you'd have to turn on ScopedTypeVariables
20:26:36 <geekosaur> ktonga, the defalt scope of a type variable is the signature *only*
20:26:37 <jle`> and also explicitly scope your type variables with 'forall a b. ....' at the top level signature
20:26:50 <jle`> mniip: good question
20:27:05 <ktonga> ok thanks
20:27:23 <jle`> i suppose it's a nice thing to be able to make a bijection between natural transformations and the image of a functor
20:27:24 <mniip> jle`, apparently some people claim that after you get it it's so tautological you don't even think about it
20:27:46 <mniip> and I mean category theorists, not programmer
20:28:08 <jle`> it rings to me like how we can talk about objects in Set by referring to morphisms () -> a
20:28:19 <jle`> er, values of a type
20:28:35 <mniip> good luck with that in Grp
20:28:44 <jle`> instead of talking about values inside a type (our object), we can instead talk about unique morphisms () -> a
20:28:57 <jle`> but i'm not sure if there's any deeper connection
20:29:01 <mniip> you can use a free group on one generator (Z) for that but no obvious connectin
20:29:46 <jle`> yeah, i can't help you too much with the deeper significance
20:30:21 <mniip> jle`, I see people providing the analogy that an object is just what you can do with it
20:30:30 <mniip> but I don't at all see how that translates into the formal symbols
20:33:45 <jle`> hm, yoneda establishes an isomorphismb etween a category C and the category of functors from C to Set.  maybe the category of functors from C to set refers to "what you can do with it"?
20:34:53 <mniip> er?
20:34:57 <mniip> where do you see that
20:35:05 <jle`> which part
20:35:50 <mniip> which part of yoneda is the isomoprhism you describe
20:37:04 --- mode: glguy set +v dmwit
20:37:15 <jle`> ah hm, not an isomorphism, but an embedding
20:37:31 <jle`> i'm looking at https://bartoszmilewski.com/2015/10/28/yoneda-embedding/
20:39:21 <jle`> but https://en.wikipedia.org/wiki/Yoneda_lemma#The_Yoneda_embedding seems to say that it's an isomorphism
20:39:26 <jle`> but i'm just stabbing in the dark here :)
20:40:41 --- mode: glguy set +v Daniel_F
20:41:17 <Daniel_F> Hello! Could anyone helpme out with instancing read?
20:41:38 <dmwit> I think you need to be a bit careful about exactly what the "it" is in "it's an isomorphism".
20:41:40 <glguy> Daniel_F: You rarely need to write your own instances, the deriving clauses handle them
20:41:49 <glguy> What are you trying to do?
20:42:07 <Daniel_F> Im trying to build a data Tree instance from a string
20:42:25 <mniip> jle`, you've got a fully faithful functor A mapsto Hom(A, -)
20:42:37 <mniip> that's the embedding
20:42:43 <glguy> Daniel_F: for that you should just make a normal function that parses the string like you have in mind, not a Read instance
20:42:47 <dmwit> jle`: For each object in the source category, there's an isomorphism. But that's different than saying the whole thing is an isomorphism.
20:44:36 --- mode: glguy set -v dmwit
20:44:40 <Daniel_F> I've thought about that, but because it is recursive I haven't discovered how to call the function for specific parts of the string
20:46:18 <dmwit> Daniel_F: If you show us some example inputs and outputs, and your best attempt at writing code to do the parsing, we can give you suggestions for getting you over whatever hump is blocking you.
20:46:43 <dmwit> (But please don't put long code snippets here in the channel. Use an online pastebin and send us a link.)
20:47:46 <Daniel_F> Sure thing. Thank you. I'm on it
20:56:03 --- mode: glguy set +v pikpuk
20:56:33 <pikpuk> hello
20:58:08 <pikpuk> Help! How to include a xxx_stub.h in main.c when building with Stack?
20:59:20 <pikpuk> The xxx_stub.h is generated under ".stack-work/dist/x86_64-linux/Cabal-2.2.0.1/build"
21:31:28 <mniip> jle`, I think I kind of figured out the yoneda embedding
21:31:53 <jle`> oh?
21:34:05 <mniip> consider f : B -> A, g : C -> B
21:34:32 <mniip> you get Hom(f, -) : Hom(A, -) -> Hom(B, -),  Hom(g, -) : Hom(B, -) -> Hom(C, -)
21:35:09 <mniip> Hom(g, -) . Hom(f, -) = Hom(f . g, -)
21:35:11 <mniip> by construction
21:35:33 <mniip> but also
21:35:59 <mniip> if you have eta : Hom(A, -) -> Hom(B, -)   and eps : Hom(B, -) -> Hom(C, -)
21:36:15 <mniip> the yonedian moprhisms eta_A(id_A) and eps_B(id_B) compose too!
21:36:40 <mniip> eps_B(id_B) . eta_A(id_A) = (eps . eta)_A(id_A)
21:36:46 <mniip> due to naturality!
21:37:11 <jle`> ah :o
21:37:34 <mniip> so when you have e.g a natural isomorphism Hom(A, -) <-> Hom(B, -)
21:37:46 <mniip> not only you get a pair of morhisms A -> B and B -> A
21:37:54 <mniip> but you can also say that their compositions are identities
21:38:05 <mniip> because compositions of the parts of the natiso are the identity isos
21:39:27 <jle`> so what are the implications here?
21:40:26 <mniip> not only you can drag morphisms into Hom functor nat transformations, but als you can drag them back and reason about all the equalities
21:44:37 --- mode: glguy set +v jackdk_
21:44:41 --- mode: glguy set -v jackdk_
21:50:46 <remexre> is there a lens for working with IOArrays?
21:50:58 <remexre> Or in general, when getting and setting are in a monad?
21:53:39 <koz_> remexre: There's a bunch of stuff in lens for MonadState specifically, but not monads in general I don't think.
21:53:46 <cemerick> dyl: this is an interesting perspective, thank you
21:54:24 <glguy> remexre: No, lenses don't really make sense in that context other than to be used with readIORef or modifyIORef directly
21:54:39 <glguy> or readArray and writeArray, etc
21:54:44 <remexre> koz_: Does it do that using Control.Monad.State.state, do you know?
21:54:52 <remexre> glguy: Yeah, I'm doing readArray and writeArray
21:55:10 <remexre> I'm fairly certain the bottleneck is going to be reading+writing these values
21:55:12 <glguy> MonadState isn't relevant to this
21:57:32 <remexre> Is lens-action what I want, then?
21:59:27 <glguy> Probably not
22:00:47 <cocreature> remexre: read the value first and then use lens to operate on the result
22:01:18 <remexre> The only reason I'm using lens is to write an "advanced" query on the array
22:01:44 <remexre> I'm writing a concolic executor (pretend I said VM if you're unfamiliar), and want to use this to make e.g. register access nice
22:02:16 <remexre> so I can do like Add l r ->    l <~ (add <$> use l <*> use r)
22:03:16 <cocreature> what is the type of l and r?
22:03:40 <remexre> ideally (Lens' SimState Expr) and (Getter SimState Expr)
22:04:03 <remexre> defined such that a 64-bit access "glues together" 8-bit accesses to make it work
22:04:19 <remexre> and add automatically adds type coercions
22:06:38 <cocreature> I’m not sure lens helps you very much here. I would define a datatype that represents memory addresses, constants, … and then write a function that given an index gives you back the corresponding value. you can then use that instead of "use"
22:07:07 <remexre> For <~ though?
22:07:42 <jle`> koz_: ah btw, i have a draft of the final part of the singletons series if you're interested in helping proof :)
22:07:54 <cocreature> remexre: define your own function as well
22:08:28 <remexre> cocreature: okay, that's what I suspected I'd have to do, just wanted to be sure there wasn't an obvious way I was missing
22:11:57 <mniip> jle`, now imagine a category with products
22:12:27 <mniip> you have Hom(-, AxB) ~~ Hom(-, A) x Hom(-, B)
22:12:38 <mniip> and Hom(-, 1) ~~ 1
22:13:34 <jle`> mhm
22:31:42 <koz_> jle`: Would love to!
23:29:51 <jle`> koz_: it's https://blog.jle.im/entry/introduction-to-singletons-4.html :o
23:30:05 <koz_>  jle`: Reading now.
23:32:25 <koz_> Nice way to sneak type-level lists into it. :P
23:33:28 <jle`> heh i thought i introduced them in part 1 ;_;
23:33:31 <jle`> or 2
23:33:38 <koz_> It's very obvious here.
23:33:54 <koz_> It's also got a serious Inception flavour with all the door-merging and hallway-collapsing.
23:34:23 <koz_> Also, are Doors monoids under door merging?
23:35:00 <koz_> s/Doors/DoorStates
23:35:15 <koz_> s/door merging/door state merging/ argh
23:35:37 <jle`> yeah it's the Max monoid :)
23:36:16 <jle`> Bounded a => Monoid (Max a)
23:36:22 <koz_> You might wanna consider mentioning it at the end of the 'Functional Programming' section, right after you define using foldr, that you can actually write it using fold instead.
23:36:31 <koz_> It's not necessary, but it'd be a nice touch IMHO.
23:36:41 * koz_ has monoids on the brain lately.
23:36:48 <jle`> oh huh! i just realized Monoid is in singletons as of 2.5
23:37:26 <jle`> that would be a cute way to tie everything together.
23:37:45 <koz_> I say do it.
23:37:55 <koz_> Monoids are a very cool thing and I encourage mentioning them everywhere.
23:38:07 <jle`> unfortunately it might not work tho because of #339
23:38:13 <koz_> I recently had a 'mind=blown' moment with foldMap.
23:38:15 <jle`> going to cross my fingers
23:38:16 <koz_> #339?
23:38:54 <jle`> some problems with lambda lifting in the current TH https://github.com/goldfirere/singletons/issues/339
23:39:07 <koz_> Also, I'm guessing defunctionalization was originally designed to 'fake' having HOFs in languages where functions weren't first-class or something?
23:39:21 <jle`> if we use the built-in mconcat/fold
23:40:05 <jle`> koz_: yeah, it was originally a trick for writing compilers for languages with hof's, to compile to a language that doesn't
23:40:12 <koz_> Interesting.
23:40:23 <mniip> 10/18/2018 [20:39:40] <johnw_> that an object is equivalent to what you can do with it
23:40:26 <jle`> i don't think it's very often meant for end-users
23:40:34 <mniip> johnw_, are you talking just about the yoneda embedding here?
23:40:51 <jle`> so me talking about directly defunctionalizing by hand might be a bad idea
23:41:19 <dminuoso> jle`: You know, if I had read your article "IO monad considered harmful" you would have sped up my Haskell learning by perhaps 2 months - and spoiled all the category theory fun I've had.
23:41:31 <dminuoso> I mean if I had read it right at the beginning.
23:41:39 <koz_> jle`: You mean the stuff you do about TyFun and Apply and friends?
23:41:46 <jle`> dminuoso: haha i'm not sure if that's a net positive or negative :)
23:41:48 <koz_> I'd leave that in - it's very good.
23:42:12 <jle`> yeah, my motivations were mainly because it's fun though heh
23:42:41 <koz_> Also jle` - isovector's book uses the terms 'unsaturated' to mean 'partially applied at the type level' and 'saturated' for 'fully applied at the type level'.
23:42:48 <koz_> You might wanna use those.
23:43:02 <jle`> ah hm, thanks for the tip :)
23:43:06 <jle`> i should read that book actually
23:43:21 <koz_> Yeah, it's very good, and a lot of the work you're doing goes together with it very well.
23:43:43 <dminuoso> jle`: Well in retrospect I'd say it was a net positive, it gave me a unique perspective to fully relate to your article..
23:45:01 <koz_> I certainly understand the APL-like names for some of the singletons functions now.
23:46:01 <koz_> Also, what's the basis for the name Sigma?
23:46:18 <jle`> it's actually literally called sigma in deperndently typed languages :)
23:46:29 <ski> mniip : perhaps it helps somewhat to think of `forall o. (a -> o) -> f o' as `forall o. f o ^ Hom (a,o)', where `Hom (a,o)' is a hom-set, and `f o ^ Hom (a,o)' is a product of the constant family of objects `f o', indexed by (the set) `Hom (a,o)'. so no exponentials in sight, at least
23:46:30 <jle`> it stands for sum, since it's a dependent sum
23:46:38 <koz_> Ah, OK. When I see 'sigma' my first thought is 'arithmetic hierarchy'.
23:46:49 <koz_> But it's probably because my Master's supervisor loved logic.
23:47:00 <koz_> (as do I, in my own limited way)
23:47:29 <jle`> yea, Sigma and Pi are sort of the iconic constructs of dependently typed programming
23:47:37 <koz_> Pi being a dependent product?
23:47:40 <jle`> mhm
23:47:47 <koz_> (sigma and pi always come in pairs)
23:47:58 * ski . o O ( dependent function space )
23:48:00 <koz_> (c.f. arithmetic hierarchy, as well as _damn near everything else_)
23:48:15 <mniip> you mean polynomial hierarchy?
23:48:21 <koz_> mniip: I probably do.
23:48:26 * koz_ checks.
23:48:39 <mniip> P = Pi_0, NP = Pi_0, etc?
23:48:41 <mniip> Pi_1*
23:48:42 <koz_> mniip: Yep, that one.
23:49:03 * koz_ clearly shouldn't make mathy pronouncements when tired.
23:49:06 <mniip> ski, I don't see where you're going with this
23:49:51 <koz_> jle`: Looks really good to me. Publish it ASAP so you can make next week's Haskell Weekly.
23:49:59 <mniip> I had a bit of epiphany regarding the yoneda embedding earlier, is this *the* deep meaning behind yoneda or is there something else to seek for?
23:50:28 <mniip> when people say "by yoneda", do they use the general statement, or just the one specialized to homs?
23:51:40 <jle`> koz_: thanks, i appreciate it! :)  i'm not in any specific hurry though, i usually let these marinate in case i think of anything else haha
23:52:00 * ski isn't going anyway further with that, atm
23:52:02 <koz_> jle`: Fair enough. I'm gonna start work on my Gamberger-Lavrac writeup, since I'm not being crushed by teaching, finally.
23:52:16 <jle`> haha. always a good opportunity to start writing :)
23:52:18 <Lycurgus> mniip, they mean "avast"
23:52:26 <ski> (just wanted to state it, in case you hadn't seen it yet)
23:52:44 <koz_> jle`: Well, I'm also working on a thesis, a conference submission and probably another paper based on something my supervisor and I discussed on Wednesday so yeah... 
23:52:54 <koz_> But then again, I'm pretty sure I'm doing some choir-preaching right now.
23:53:06 <jle`> i understand your joy :)
23:53:42 <koz_> But definitely still wanna do that writeup.
23:53:56 <koz_> (after I check over my code and make it less hideous for public consumption)
23:54:26 <mniip> ski, I think "natural transformation" is more 'natural' than a forall and then some indexed product
23:54:59 <jle`> dminuoso: sometimes things are better taken the winding way around, i suppose :)
23:55:55 <ski> possibly
