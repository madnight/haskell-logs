00:17:00 <alexelcu> newbie question — in a `case` expression, how can I have a branch with multiple alternatives, like `Nothing | Just "that" ->`?
00:17:42 <Axman6> you can't
00:21:25 <Zemyla> alexelcu: I'd do "Just x | x /= "that" -> ...; _ -> whatever the first proposed case was"
00:29:22 <alexelcu> Zemyla: yeah, I'll do that, thanks
00:46:59 <elgoosy> hi, every time i paste some haskell in my emacs buffer, it's not aligned well, but I have to go line by line and Tab them. What do you do in those situation? I didn't find anything in haskell mode to align a block
00:49:27 <lieven> M-x indent-region usually bound to C-M-\
01:08:09 <elgoosy> lieven: that doesnt do anything in haskell mode. At least for me
01:13:02 <lieven> hmmm seems haskell-mode doesn't turn on indentation by default
01:13:10 <lieven> perhaps they're not entirely happy with it
01:13:19 <shafox> I am having trouble understanding the basic of haskell in this program: https://gist.github.com/shadow-fox/538a5a6d748067929ee5d76287b7f48c 
01:13:21 <lieven> (add-hook haskell-mode-hook 'haskell-indentation-mode)
01:13:41 <lieven> or just call haskell-indentation-mode and see if you like it
01:29:12 <cocreature> shafox: length fields tries to calculate the length of the function field
01:29:16 <cocreature> *fields
01:31:34 <elgoosy> lieven: I have haskell-indentation-mode enabled, but does nothing. Neither selecting the region, neither in general. Maybe it's because im using dante extension too? 
01:32:26 <cocreature> elgoosy: Haskell is indentation sensitive. there is no way to automatically format a piece of code where the indentation is completely messed up since different levels of annotation can have different meanings
01:37:03 <shafox> cocreature: i am just starting out. bear with me. ```fields :: Document -> [Field]``` this is the type for fields. if I do ```length . fields``` the fields function takes a document and returns list of fields. 
01:37:22 <cocreature> shafox: exactly and then you calculate the length of this list
01:38:48 <shafox> cocreature: so to calculate on the fields member I would be calling the function which takes Document and returns list of Field. To add a new field how would I go  ? 
01:39:20 <cocreature> shafox: addField newField document = document { fields = newField : fields document }
01:42:22 <shafox> cocreature: One more question, how would I create a empty Document, so that I would be operating on that rather than creating instances of the Document that is defined in the file. I want the user to create a empty document and then add field to it. 
01:51:22 <cocreature> shafox: emptyDocument = Document []
01:53:51 <Weste> Why does `True == True == True` result in a "Precedence parsing error: cannot mix ‘==’ [infix 4] and ‘==’ [infix 4] in the same infix expression"? But `10 + 10 + 10` not?
01:55:26 <Ferdirand> because (==) is infix, not infixr or infixl
01:55:48 <tdammers> which is probably for the best
01:55:55 <Ferdirand> (+) is infixl
01:56:15 <tdammers> because otherwise `True == True == True` would have to amount to either (True == True) == True or True == (True == True)
01:57:31 <tdammers> consider True == False == False
01:57:51 <Ferdirand> well that's true either way, no ?
01:58:43 <tdammers> hmm, yes, you're right
01:58:50 <tdammers> but that's more of a happy accident
01:59:14 <Ferdirand> xor is associative too
02:02:48 <Bish> if i have a function that maps a "data" to another thingie
02:02:53 <Bish> why do i get a runtime error?
02:03:00 <Bish> i mean.. if that function is partial
02:03:13 <Bish> isn't that something that falls in the category "type error"?
02:05:01 <Ferdirand> some languages do totality checking, not haskell
02:05:48 <Bish> hm.. that really confused me
02:06:01 <Ferdirand> the moral reason for it would be that unless you forego general recursion, you can always trick it into accepting a partial function
02:07:41 <Bish> Okay, next funnier question:
02:07:57 <Bish> https://de.wikipedia.org/wiki/Blokus#/media/File:BlokusTiles.svg
02:08:09 <Bish> how do you generate these in haskell, programaticially
02:08:30 <Bish> i've thought about that alot, and didn't get to something that makes me happy
02:09:16 <Bish> (those are all blocks u can build with 1-5 "pixels" without counting their rotations)
02:11:06 <cocreature> Bish: that’s not quite true is it? e.g. the 5 pixel block |_| is missing
02:12:57 <Bish> [3][2]
02:13:03 <Bish> is that "U" to me
02:13:58 <cocreature> oh right
02:14:02 <cocreature> silly me
02:14:46 <Bish> and i wonder how i would do that if i was pendantic
02:15:55 <Bish> because every way i did it, i wasn't happy
02:16:16 <Bish> writing them down as 2 dimensional arrays: sucks in code, and doesn't give me a list tht really ends
02:16:50 <Bish> doing every pixel combination on a 3x5 grid and filtering out the non-desireable: super expensive
02:17:02 <opqdonut> Bish: n-omino generation is a fairly well known algorithmic puzzle
02:17:08 <opqdonut> Bish: you could try googling
02:17:10 <Ariakenom> % 2^(3*5)
02:17:10 <yahb> Ariakenom: 32768
02:17:17 <Bish> modeling them as graphs 
02:17:47 <Bish> opqdonut: well it's a hard one, isn't it
02:17:48 <Bish> i hope
02:18:17 <Ariakenom> 33k doesn't sound super expensive
02:18:19 <opqdonut> typically in combinatorial enumeration you want to figure out some sort of "normal form"
02:18:28 <opqdonut> so in this case, a standard rotation for the piece
02:18:38 <opqdonut> that can help you narrow down the search space
02:18:38 <Bish> Ariakenom: well, i said if i was pendantic
02:18:51 <Bish> opqdonut: i didn't know that problem had a name, thank you, i have everything for googling that now
02:19:21 <opqdonut> oh it's polyomino not n-omino
02:19:23 <opqdonut> of course
02:19:42 <opqdonut> https://en.wikipedia.org/wiki/Polyomino#Algorithms_for_enumeration_of_fixed_polyominoes
02:20:09 <opqdonut> the recursive approach sounds nice, you just need an efficient duplicate check
02:20:15 <opqdonut> i.e. the standard rotation
02:21:04 <opqdonut> though for polyominoes since there are only 8 rotations/flips you can probably just check all of them in the equality check
02:21:53 <opqdonut> oh, wikipedia has a better trick
02:22:06 <opqdonut> grep for Redelmeier
02:22:34 <opqdonut> as for picking a representation for the pieces, I don't think it matters, what matters is you'll need a nice small dsl for operating on them
02:22:53 <opqdonut> I'd probably use arrays/bitmaps
02:24:03 <cfraz89> @shafox: fields is not the variable holding your data
02:24:03 <lambdabot> Unknown command, try @list
02:24:08 <Ariakenom> [[Int]], Set (Int,Int), Array Bool, bitvector
02:24:38 <cfraz89> its a function that given a document, returns your data
02:24:56 <cfraz89> fields is actually of type Document -> [Field]
02:25:04 <shafox> cfraz89: yep
02:26:12 <cfraz89> thats why length fields won't compile
02:27:27 <shafox> cfraz89: if it was `fields :: [Field]` then `length fields` would work right ?
02:27:42 <cfraz89> yep
02:32:50 <Bish> opqdonut: but how actually save them?
02:33:08 <Bish> a graph? [[Bool]]?
02:33:37 <Bish> is there something clever anyone can do to put them in a typeclass so
02:33:48 <Bish> rotation1 of a block == rotation2 of a block?
02:35:01 <Bish> should i not do that? so many questions
02:37:28 <Ariakenom> Bish: did you look at opqdonut's suggestion for normal form?
02:37:58 <Bish> oh shit i overread that
02:38:11 <Bish> yeah a nice DSL, i thought about this for days
02:38:20 <Bish> thank god that is a known problem, that would've drove me crazy
02:38:58 <Ariakenom> I meant Redelmeier generation
02:39:32 <Ariakenom> You can consider Set (Int,Int) for representation
02:40:04 <Bish> that's cool, will read about it
02:40:13 <Bish> sorry for not reading carefully enough
02:44:31 <dminuoso> f :: Semigroup s => [ZipList s] -> ZipList s
02:45:22 <dminuoso> So the way Im thinking this should be kind of `foldMap`, but there is no appropriate instance Monoid a => Monoid (ZipList a)
02:45:35 <Bish> dminuoso: o/
02:45:46 <opqdonut> Set (Int,Int) sounds nice actually
02:45:56 <dminuoso> Bish: \o
02:46:14 <Bish> dminuoso: that one is illegal in our country, i think
03:06:33 <dminuoso> @let foo = [ZipList [1,2,3], ZipList [10,20,30], ZipList [100,200,300]]
03:06:34 <lambdabot>  Defined.
03:06:50 <dminuoso> > foldr1 (liftA2 (+)) foo
03:06:52 <lambdabot>  ZipList {getZipList = [111,222,333]}
03:11:06 <dminuoso> @let instance Monoid m => Monoi (ZipList m) where mappend = liftA2 mappend; mempty = pure mempty
03:11:06 <lambdabot>  .L.hs:196:22: error:
03:11:07 <lambdabot>      Not in scope: type constructor or class ‘Monoi’
03:11:07 <lambdabot>      Perhaps you meant ‘Monoid’ (imported from Data.Monoid)
03:11:09 <dminuoso> @let instance Monoid m => Monoid (ZipList m) where mappend = liftA2 mappend; mempty = pure mempty
03:11:10 <lambdabot>  Defined.
03:12:05 * dminuoso is curious why this instance does not exist
03:12:44 <cocreature> dminuoso: you can easily get it via Ap (ZipList m)
03:12:50 <cocreature> eh Ap ZipList m
03:22:37 <dminuoso> cocreature: Ah it looks as if `Ap` does *exactly* that. :)
03:22:49 <dminuoso> Thanks for the hint.
03:23:27 <shafox> @:t :
03:23:27 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
03:23:58 <bor0> :t (:)
03:23:59 <lambdabot> a -> [a] -> [a]
03:46:19 <SaraDT_> Hey everyone. Can anyone throw some procs/cons for using ReadP for parser library? Seemed like a harder than expected thing to google up.
03:48:05 <SaraDT_> I mean, a clear downside is the horrible error messages on failed parsing :<
03:48:26 <fiatjaf> dmj`, I applied the patch from PR 680 to ghcjs, but the problem persists
03:49:15 <fiatjaf> http://sprunge.us/hMQplo
03:49:54 <fiatjaf> dmj`, however, since I was unable to compile my thing using the old ghcjs version (because for some reason the qrcode package doesn't compile and crashes my computer when using that old ghcjs) I can't say anything
03:49:56 <fiatjaf> but just to let you know
03:50:21 <dminuoso> SaraDT_: Isnt ReadP centered around String/Char?
03:51:11 <dminuoso> SaraDT_: Also isnt it completely non-deterministic? I reckon depending on how much backtrack is generated, this might be costly.
04:07:52 <cocreature> SaraDT_: tbh I don’t think there is any good reason for using ReadP
04:08:09 <cocreature> even dependencies aren’t a good argument these days since parsec is a boot lib
04:08:40 <infinisil> :t ReadP
04:08:41 <lambdabot> error: Data constructor not in scope: ReadP
04:08:48 <`slikts> if something is a dual of something else, are those things also isomorphic?
04:08:54 <infinisil> :i ReadP
04:09:00 <cocreature> and if you don’t care about adding a dependency (which is reasonable for most non-core packages), there’s megaparsec which is more pleasant to use, faster and has better error messages
04:09:18 <cocreature> % :i ReadP
04:09:18 <yahb> cocreature: ; <interactive>:1:1: error: Not in scope: `ReadP'
04:09:32 <cocreature> % import Text.ParserCombinators.ReadP
04:09:32 <yahb> cocreature: 
04:09:34 <cocreature> % :i ReadP
04:09:35 <yahb> cocreature: newtype ReadP a = Text.ParserCombinators.ReadP.R (forall b. (a -> Text.ParserCombinators.ReadP.P b) -> Text.ParserCombinators.ReadP.P b) -- Defined in `Text.ParserCombinators.ReadP'; instance Alternative ReadP -- Defined in `Text.ParserCombinators.ReadP'; instance Applicative ReadP -- Defined in `Text.ParserCombinators.ReadP'; instance Functor ReadP -- Defined in `Text.ParserCombinators.ReadP'; insta
04:09:36 <cocreature> ^ infinisil 
04:11:09 <infinisil> Ahh, I had something different in mind
04:11:54 <infinisil> Oh I thought of ReadS
04:12:06 <infinisil> % :i ReadS
04:12:06 <yahb> infinisil: type ReadS a = String -> [(a, String)] -- Defined in `Text.ParserCombinators.ReadP'
04:13:01 <dminuoso> `slikts: No.
04:13:20 <dminuoso> `slikts: Duality is a rather general term that has no precise meaning when not constrained to some specific field in mathematics for example.
04:14:09 <`slikts> I'm using duality with this meaning: http://csl.stanford.edu/~christos/pldi2010.fit/meijer.duality.pdf
04:15:05 <shafox> Is there any better solution to nested records ? I cant build  parent record without all the nested record has been built. 
04:15:44 <fiatjaf> shafox, lenses
04:15:52 <fiatjaf> but nested records isn't as hard as you think
04:16:14 <infinisil> And lenses also just use nested records, it's just more convenient
04:18:37 <dminuoso> `slikts: So let me give you one duality we have in Hask: The dual of a product type in Haskell is a coproduct type. We also call that a sum type.
04:19:45 <dminuoso> `slikts: So in category theory duality expresses the relationships between properties in some category C and its corresponding dual properties in the opposite category C^op
04:20:49 <dminuoso> There's some pretty cool implications, such that the ability to prove one thing in C, you may get something "for free" in C^op
04:21:18 <dminuoso> It should be pretty clear that sum types are not isomorphic to product types.
04:21:32 <`slikts> I see, thanks
04:23:01 --- mode: glguy set +v drets
04:24:40 --- mode: glguy set +v infty_
04:27:38 <dminuoso> `slikts: The paper names some further examples using duality. But even in Haskell you can find them, whether its Yoneda and Coyoneda, Lens and Prism, State and Costate, Monad and Comonad.. it's pretty pervasive in programming. :)
04:34:58 <ski> record and variant
04:35:08 <ski> (oh, you already said that before)
04:36:25 <ski> `slikts : sometimes something is dual to itself. it's called self-dual in that case
04:36:57 --- mode: glguy set +v baghyasree
04:38:25 <ski> the property of being a monomorphism (in many cases, means roughly "injective homomorphism") is dual to the property of being an epimorphism (similarly, approximately, but not quite, "surjective homomorphism"). however the property of being an isomorphism is dual to itself
04:39:50 <ski> (the two "homomorphism" cases i mentioned really applies only for "algebraic things". however, not all categories are algebraic in character. some aren't even concrete (means roughly that an object is a set, with some extra structure))
04:41:18 * ski isn't sure whether these attempts at examples makes any sense to `slikts ..
04:42:02 <dminuoso> I think duality is deeply related to Functors.
04:42:07 <dminuoso> *functors
04:43:03 <dminuoso> Maybe duality can be seen as a faithful functor?
04:43:27 <mniip> much more than that
04:44:11 <mniip> any true proposition about categories can be dualized into a true dual proposition
04:44:28 <dminuoso> mniip: Im talking way beyond the category theory notion of duality pinned to opposite categories.
04:45:10 <mniip> >functors
04:45:16 <mniip> >far beyond category theory
04:45:54 <dminuoso> mniip: the way I understand duality, it's about establishing a one-to-one correspondence between to ideas/concepts/propositions
04:46:01 <dminuoso> *between two
04:53:27 <ski> s/about categories/about categories in *general*/
04:54:13 * alexelcu I'm on MacOS, so when compiling a binary for Ubuntu, is there any way to target another architecture like Ubuntu's, without some sort of virtual machine?
04:54:22 <alexelcu> I'm on MacOS, so when compiling a binary for Ubuntu, is there any way to target another architecture like Ubuntu's, without some sort of virtual machine?
04:54:55 <alexelcu> (as a side note, I'm on IRCCloud and somehow I end up inserting a `/me` at the start of the message, I don't understand why 🙂)
04:55:10 <mniip> dminuoso, are you saying  op : Cat -> Cat is a functor?
04:56:27 <dminuoso> mniip: mmm
04:57:22 <hpc> alexelcu: VMs are by *far* the easiest way to cross-compile
04:57:47 <hpc> if it's too much effort to create one manually i recommend vagrant
04:57:56 <dminuoso> alexelcu: We use docker to make it bearable (docker for mac does the VM part completely transparent)
04:58:09 <hpc> use a hosted ubuntu base box, bump its resources, install stack or whatever
04:58:59 * alexelcu yeah, I was about to install a vagrant machine, was going through the tutorial 🙂
04:59:11 <alexelcu> yeah, I was about to install a vagrant machine, was going through the tutorial :)
05:00:02 <dminuoso> mniip: It would be a contravariant functor at the least, no?
05:00:23 <ski> alexelcu : no disjuctive patterns in Haskell, unfortunately
05:00:34 <ski> dminuoso : nope. it's covariant
05:01:09 <ski> dminuoso : if you extend it to `2'-categories, it's contravariant on the `2'-morphisms (natural transformations), though, iirc
05:02:07 <ski> dminuoso : if `F : C >---> D', then also `F^op : C^op >---> D^op', hence covariant
05:03:19 <dminuoso> Oh well actually, the case of op : Cat -> Cat would be an isomorphism.
05:03:34 <dminuoso> So it doesnt make sense to talk about co/contravariance
05:04:21 <ski> why wouldn't it ?
05:04:44 <ski> there are contravariant isomorphisms of categories
05:06:55 <dminuoso> What exactly is a contravariant isomorphism?
05:08:09 <Lycurgus> it googles
05:09:55 <ski> an isomorphism (more generally, an equivalence) between a category `C' and `C^op'
05:10:25 <ski> take `Rel' as a simple example
05:11:37 <ski> (well, more generally, we'd have between `C' and `D^op', where we prefer thinking in `D' directly, rather than in `D^op')
05:17:46 <rfold> Hi, found that this CPS version of MaybeT is more efficient than the regular MaybeT version in some specific use cases: "newtype MaybeT m a = MaybeT (forall r. m r -> (a -> m r) -> m r)". It also does not require Monad m for its Monad instance. Is there an existing name/package for it? It looks very much like Codensity.
05:19:05 <dminuoso> Oh ski! There we go, we should resume the talk about Maybe/Codensity ^- :-)
05:22:01 <rfold> I think that a la Codensity, it right-associates all binds.
05:22:41 <ski> rfold : how do you get out of your `MaybeT m a' ?
05:22:47 <dminuoso> newtype CodensityT m a = CodensityT { runCodensityT :: forall b. (a -> m b) -> m b }
05:22:58 <ski> (it's not quite `Codensity')
05:24:18 <ski> er, hmm
05:24:36 <rfold> ski: given Applicative m, runMaybeT action (pure Nothing) (pure . Just)
05:24:44 <ski> actually, yea, it's just a fused `Codensity MaybeT'
05:25:40 <ski> hmm
05:25:58 <int-e> ski: \m. Codensity (MaybeT m) ?
05:26:03 * ski restarts
05:26:39 <Dark_Ethereal> Codensity is one of those things I've heard of wrt Haskell but have no clue what it is, and so far have never needed to have a clue... Profunctor is another.
05:26:44 <int-e> probably wrong too, but at least the kinds kind of fit
05:27:03 <ski>   Codensity m (Maybe a)  =  forall r. (Maybe a -> m r) -> m r  =  forall r. m r -> (a -> m r) -> m r
05:27:04 <rfold> Ah right, it's like Codensity (MaybeT m), but instead of a function receiving a sum, you have a product of functions.
05:27:05 <dminuoso> Dark_Ethereal: Profunctor is actually easy. :)
05:27:11 <dminuoso> Dark_Ethereal: Are you familiar with Functor?
05:27:12 <Ariakenom> Dark_Ethereal: have you used lenses?
05:27:12 <ski> that much is clear
05:27:30 <dminuoso> Dark_Ethereal: And if yes, are you familiar with Contravariant?
05:27:45 <Dark_Ethereal> Yes, I know what a Functor is, Yes, I have used the Lens library
05:27:45 <Ariakenom> Dark_Ethereal: prepare for concurrent profunctor tutorial!
05:27:48 <lyxia> dminuoso: MaybeT (Codensity m)
05:27:57 <dminuoso> Dark_Ethereal: Great. Do you know what Contravariant is?
05:28:12 <lyxia> rfold: ^ I meant you
05:28:31 <Dark_Ethereal> Uuuuuuh, I think I remember watching a video about contravariant functors once, and I didn't understand any of it and I've forgotten it all
05:28:45 <ski> using lyxia, we get `MaybeT (Codensity m) a' iso to rfold's `MaybeT m a'
05:28:48 <dminuoso> :t contramap
05:28:50 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
05:28:58 <dminuoso> :t fmap
05:28:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:29:00 <lyxia> how dare you use me
05:29:09 * ski smiles
05:29:10 <Dark_Ethereal> Yeah, I know it's all backward like that
05:29:11 <Dark_Ethereal> but
05:29:15 <Dark_Ethereal> I don't get how that even works
05:29:19 <rfold> lyxia: yes, thanks! :)
05:29:33 <ski> now, is there a relevant `CodensityT', distinct from `Codensity' ?
05:29:43 <dminuoso> Dark_Ethereal: Okay so do you know how a function is a Functor in its second type argument?
05:30:02 <ski> s/a function/a function type/
05:30:12 <Dark_Ethereal> dminuoso: yes.
05:30:13 <dminuoso> ^- :)
05:30:34 <lyxia> Codensity is arguably what would be named CodensityT with transformer's conventions.
05:30:45 <dminuoso> Dark_Ethereal: Great. So if you took some function of type `f :: Int -> String`, and some other `g :: String -> Float`, then you could use `fmap g f` to make some `Int -> Float` right?
05:31:13 <Dark_Ethereal> Yup
05:31:56 <dminuoso> Dark_Ethereal: So now assume you have some function `f :: Int -> Bool`, and some function `g :: Float -> Int`
05:32:09 <dminuoso> Dark_Ethereal: Do you think you can turn that first function into `h :: Float -> Bool`
05:32:22 <Dark_Ethereal> Yup
05:32:48 <dminuoso> :t contramap
05:32:49 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
05:33:15 <dminuoso> Dark_Ethereal: ^- can you see where I might be getting at? :)
05:34:26 <dminuoso> Dark_Ethereal: In order for this to work with Haskells type system, we need to introduce a newtype wrapped of (->) that just flips the arguments, called Op
05:34:44 <dminuoso> newtype Op a b = Op { getOp :: b -> a }
05:35:11 <dminuoso> You can then define an: instance Contravariant (Op x)
05:36:46 <dminuoso> Using a bit of pseudo syntax you could think that: instance Contravariant (i -> _) where ...  and instance Functor (_ -> o) where ...
05:38:21 <Dark_Ethereal> wait wait wait wait....
05:38:41 * dmwit . o O ( Functor is for things what produce 'a's. Contravariant is for things what consume 'a's. )
05:39:12 <Dark_Ethereal> we got f, g, h...
05:39:12 <Dark_Ethereal> and you're suggesting that contramap is what makes the h out of f and g?
05:39:12 <Dark_Ethereal> So h = contramap f g?
05:39:26 <dminuoso> Yes!
05:39:31 <Dark_Ethereal> so hang on
05:39:54 <dminuoso> Dark_Ethereal: Or wait no. contragmap g f
05:40:00 <Dark_Ethereal> so the type in this particular case for contramap would be...
05:40:01 <Axman6> data Predicate a = Predicate (a -> Bool); instance Contravariant Predicate where contramap f (Predicate p) = Predicate (p . f) -- Apply f to the argument before passing to the old predicate
05:41:04 <rfold> ski: lyxia: thanks! I'll see if MaybeT (Codensity m) has similar performance, it could clean up a bunch of boilerplate.
05:42:01 <dminuoso> Dark_Ethereal: The idea is really about: If we have some `A -> B` and some `f A`, then we can make some `f B`. For functions we just compose *at the end* because we are changing the output type. But we can also compose *at the beginning*, which changes the output type "in reverse". :)
05:42:29 <dminuoso> So contravariant functors are about: `If we have some `A -> B` and some `f B`, then we can make some `f A`
05:42:40 <dminuoso> For every choice of a functor f.
05:43:58 <Dark_Ethereal> Nope I'm lost
05:44:08 <dminuoso> Dark_Ethereal: Okay let me give you some simple excercises
05:44:12 <Dark_Ethereal> hold on hold on
05:44:14 <Dark_Ethereal> so
05:45:15 <Dark_Ethereal> for the f, g and h you gave before
05:45:15 <Dark_Ethereal> If h = contramap g f
05:45:15 <Dark_Ethereal> Then what does the type of contramap become when you've substituted in the types of g and f?
05:45:31 <Dark_Ethereal> I've tried to work through it my self but I must be making a mistake somewhere
05:47:04 <mnoonan> here's one example: take `newtype Subset a = Subset (a -> Bool)`, where the function picks out the elements of `a` that belong to your subset.
05:47:30 <Dark_Ethereal> g :: String -> Float, so is the contravariant functor instance here (String ->)?
05:47:44 <Dark_Ethereal> no wait
05:47:45 <mnoonan> then try to implement `fmap :: (a -> b) -> Subset a -> Subset b` or `contramap :: (a -> b) -> Subset b -> Subset a` and see what happens
05:47:47 <dminuoso> Dark_Ethereal: The contravariant functor would be on (-> Bool)
05:48:05 <Dark_Ethereal> oooh it's the other side
05:48:09 <dminuoso> Yes!
05:48:23 <dminuoso> Dark_Ethereal: But haskells type system does not allow you to actually type that. So you need to be tiny bit more creative.
05:48:29 <mnoonan> (oops, I just saw that I'm repeating Axman6's example :| )
05:48:52 <dminuoso> Dark_Ethereal: ^- take mnoonan's example and work it out
05:49:19 <Axman6> for a second exercise, you can try newtype Comparison a = Comparison (a -> a -> Ordering) and make it Contravariant
05:50:14 <Axman6> :t (>$<)
05:50:15 <lambdabot> error:
05:50:15 <lambdabot>     • Variable not in scope: >$<
05:50:15 <lambdabot>     • Perhaps you meant one of these:
05:50:18 <Axman6> :(
05:50:24 <Axman6> :t (>*<)
05:50:27 <lambdabot> error:
05:50:27 <lambdabot>     • Variable not in scope: >*<
05:50:27 <lambdabot>     • Perhaps you meant one of these:
05:50:30 <Axman6> :((
05:52:36 <Dark_Ethereal> contramap :: (Float -> Int) -> (-> Bool)  Int -> (-> Bool) Float
05:52:36 <Dark_Ethereal> So that makes sense...
05:53:51 <Dark_Ethereal> But I guess unlike Functor, there aren't many data structures that are contravariant functors, since that would imply... weird stuff... probably. IDK, my brain hurts.
05:54:10 <Dark_Ethereal> or rather
05:54:40 <Dark_Ethereal> There aren't many common Functors that are contravariant functors
05:55:51 <Dark_Ethereal> Like how would a contravariant Maybe instance work?
05:55:51 <Dark_Ethereal> Contramap :: (a -> b) -> Maybe b -> Maybe a, what? How could we assume we could work out an a from b given a way from a to b?
05:56:06 <dminuoso> Dark_Ethereal: It wouldn't, Maybe is not a contravariant functor. :)
05:56:11 <dminuoso> Maybe is a covariant functor.
05:56:12 <Dark_Ethereal> aye
05:56:41 <dminuoso> Dark_Ethereal: So do you understand how both Contravariand and Maybe work on something (* -> *) kinded?
05:56:46 <dminuoso> *Contravariant
05:58:03 <mnoonan> you can only be contravariant and covariant in the same type variable if it is a phantom type variable, e.g. `data Box a = JustAnEmptyBox`
05:58:18 <mnoonan> aka `Proxy` :)
05:58:24 <dminuoso> Dark_Ethereal: So a profunctor (p :: * -> * -> *) is something that is contravariant in the first argument, and covariant in the second argument. That is you can use `lmap :: (a -> b) -> p b c -> p a c` and `rmap :: (b -> c) -> p a b -> p a c`
05:59:12 <dminuoso> So it's a kind of bifunctor that is contravariant in one argument, and covariant in the other argument.
05:59:17 <dminuoso> The most common profunctor is (->)
06:00:12 <dminuoso> because remember: you can contravariantly map over its input, and covariantly map over its output
06:00:33 <Dark_Ethereal> Yeah I'm just going to stare at that for a while with my eyes splaying in opposite directions while stuffing food in my mouth for a few minutes
06:02:18 <Dark_Ethereal> Ok ok so I think I get that profunctor stuf
06:02:42 <Dark_Ethereal> the question is... when the heck is the fact that it exists useful?
06:03:48 <__monty__> When you want to abstract over things that behave contravariantly in the first and covariantly in the second argument?
06:04:09 <Dark_Ethereal> What things are there other than (->)?
06:04:24 <dminuoso> Dark_Ethereal: For example `Monad m => Profunctor (Kleisli m)`
06:04:47 <dminuoso> In pseudo syntax you might think of it as `_ -> m _`
06:04:52 <Taneb> Boring example: data Foo x y = Foo
06:06:00 <opqdonut> Dark_Ethereal: something like 'data MyFun arg res = MyFun (Context -> arg -> [res])' for example
06:07:34 <dminuoso> Dark_Ethereal: Profunctor basically abstracts over the pattern of being able to adapt on the input and output side.
06:07:50 <dminuoso> Dark_Ethereal: So you might want to write code that doesnt really care whether its ->, or a kleisli arrow or something completely else - as long as you have a meaningful way to adapt these two thiings.
06:08:31 <Dark_Ethereal> Ok... well my brain is fried right now and I feel like I derailed somebody else's question so uuuh
06:08:40 <Dark_Ethereal> As you were.
06:08:50 * Ariakenom relaxes
06:14:08 * ski . o O ( `Difunctor' )
06:15:52 <mniip> a bifunctor is like a parallelogram, a profunctor is like a trapezoid
06:16:35 <mniip> an end is a triangle
06:19:39 <Dark_Ethereal> Time is a cube.
06:20:09 <Dark_Ethereal> Ignorance of 4 day harmonic cubic nature indicts humans as unfit to live on earth. 
06:20:21 * Dark_Ethereal tips tinfoil hat
06:20:22 <mniip> I am the smartest programmer that ever lived
06:29:49 <Dark_Ethereal> In case you aren't familiar with the wonder of internet history that is Time Cube...
06:29:51 <Dark_Ethereal> http://timecube.2enp.com/
06:33:32 <elgoosy> cocreature: Right. Anyway, those who use emacs with haskell-mode. If you paste a block of code and then need to tab every line of that block to the left or right, what do you do? 
06:36:27 <lieven> M-x indent-rigidly
06:38:24 <cocreature> elgoosy: if you want to apply the same indentation to all lines, make a rectangular selection (C-space) and C-x r t to insert a string, e.g. 4 spaces
06:39:26 <nitrix> In CT, does every object needs a morphism back to itself or can I have the equivalent of a directed graph?
06:40:01 <nitrix> I dont mean identity, I mean if there's a f :: A -> B, are you required to have a g :: B -> A ?
06:40:17 <ski> Dark_Ethereal : you are educated stupid :)
06:40:43 <elgoosy> lieven, cocreature thank you!
06:42:40 <ski> nitrix : nope, that's not required
06:42:58 <ski> nitrix : every directed graph generates a free category, by adding all composites
06:43:35 * ski . o O ( "Free the categories !" )
06:44:41 <shafox> nitrix: I would suggest to CT https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_ This has helped me understand what map is.
06:44:59 <nitrix> Can have have objects made of other objects, by composing ... actually I already know the answer will be yes. Okay, I'll go straight to my point then:
06:45:07 <nitrix> ski: https://en.wikipedia.org/wiki/Flow-based_programming
06:46:02 <nitrix> shafox: This seems like it maps very directly to CT. I'm wondering just how throughout someone could bring that stuff to CT, because then, I'd have my first real reason to learn it :)
06:46:08 <nitrix> ski: ^ *
06:46:17 <Geraldus> Hi friends! 
06:46:36 <ski> Bartosz is cool :)
06:47:07 <Geraldus> Facing 'could not deduce `m ~ HandlerFor site0` in my custom Yesod Auth plugin.  The code and error message are here https://gist.github.com/geraldus/f9ac57463e0ec462175fff56ee289ae1
06:47:10 <nitrix> I liked Bartosz but his lecture was all over the place.
06:47:14 <nitrix> I need more structure.
06:47:17 <Geraldus> Can anyone take a look?
06:47:56 <ski> there's also <https://www.youtube.com/user/TheCatsters>
06:48:42 <shafox> nitrix: that is a intro to CT. to make you understand the jargons and concepts on how it is related to programming. 
06:49:04 <ski> Geraldus, 404 ?
06:49:43 <Geraldus> ski: hmm... hold a second
06:50:39 <cocreature> might be due to the problems github is having atm
06:51:48 <Geraldus> cocreature: yeah
06:51:56 <Geraldus> looks like this is the case
06:52:04 <Geraldus> ski: let me use another way
06:52:10 <Dark_Ethereal> ski: are you saying I've got bad education, or that I'm educated and I should stop talking myself down?
06:52:48 <ski> Dark_Ethereal : hehe, i'm not sure. the latter perhaps :)
06:53:01 <Dark_Ethereal> both can be correct I suppose
06:53:41 <Geraldus> ski: https://pastebin.com/VbBNXtef
07:11:19 --- mode: glguy set +v foojin
07:11:26 <foojin> mnoonan: I've been reading through those Contravariant examples and I feel like I finally get it, but it seems to me that implementing `fmap :: (a -> b) -> Subset a -> Subset b` is impossible without additional information.
07:11:34 <foojin> mnoonan: I see how to go about that if I had an `[a]` inside instead of `a -> Bool` (map and wrap into a Subset), but one can only get `[x | x <- xs, f x] :: a` out of `f :: a -> Bool` by checking all xs. Is this (having all elements of the superset available) what you had in mind?
07:12:38 <ski> foojin : `Subset a = a -> Bool' ?
07:14:14 <ski> Geraldus : how's `AuthHandler' defined ? what's the signature of `runDB' ?
07:14:25 <foojin> ski: `newtype Subset a = Subset (a -> Bool)`
07:14:41 <ski> foojin : affirmative, then
07:15:13 <ski> foojin : there are two different powerset functors, one covariant, the other contravariant. `a -> Bool' gives the contravariant one, but it seems you want to be covariant
07:20:42 <foojin> ski: How can there be two of them? Maybe I don't understand enough of CT, but should something about sets as a concept depend on the way (list/predicate) we represent them?
07:23:08 <dolio> There are two functors whose action on objects is power set.
07:23:19 <dolio> The action on arrows is different.
07:25:10 <foojin> dolio: Ah, I see, that's how.
07:29:46 <dolio> Strictly speaking, they go between different categories, too.
07:30:58 <ski> one is a (covariant) functor from `Set' to `Set'. the other is a (contravariant) functor from `Set' to `Set', which can be expressed as a covariant functor from `Set^op' to `Set' (or from `Set' to `Set^op', if you prefer)
07:33:18 <ski> (in fact, the codomain category can be `PO' (partial orders), rather than `Set', since subsets are ordered by inclusion. also, if you like to, you could take the codomain category as `Cat', since all partial orders can be considered as categories)
07:34:02 <mnoonan> foojin: sorry, to be clear: I was suggesting *trying* to implement both fmap and contramap in order to see why only contramap is possible in general for that type
07:40:55 <foojin> ski: Are these further functor variations (to PO and Cat) related somehow to the concept of a "forgetful functor" that I've heard about? It looks like they "add structure" somehow, so is there a name for them?
07:51:17 <ski> foojin : yes
07:51:27 <ski> a forgetful functor forgets structure
07:52:30 <ski> in this case, there'd be forgetful functors. one from `PO' to `Set', and another from `PO' to `Cat' (note the different direction, wrt above discussion !)
07:53:00 <ski> the one from `PO' to `Set' would simply forget the ordering structure on the given set
07:54:03 <ski> the one from `PO' to `Cat' would forget that the partial order, considered as a category, is a category with at most one morphism between two objects (and also isomorphic objects must be equal)
07:56:29 <ski> if `F : PO -> Set', then considering the covariant `P : Set -> Set', we can add extra info (the inclusion ordering of subsets) to `P', making it `P′ : Set -> PO', such that if we forget the extra structure, we get back `P' : `F . P′ = P'
07:57:46 <ski> otoh, if we instead consider the forgetful `F : PO -> Cat', and continue with `P′ : Set -> PO', we can compose these into `F . P′ : Set -> Cat'
07:58:46 <ski> these two cases are not analogous to each other. in one case we (post)compose with a forgetful functor. in the other case, we make a new functor such that is we (post)compose that with a forgetful functor, we get back the old functor
08:02:27 * ski also had something more to say about powerset, but didn't recall it that well, and have to leave presently
08:02:30 <ski> perhaps next time
08:04:27 <foojin> ski: Thanks! I'll try to understand you examples better in the meantime.
08:04:32 <foojin> *your
08:30:29 <akegalj> is hackage down?
08:31:28 <orion> akegalj: It loaded slower than normal for me.
08:45:40 <alexelcu> Trying to build my project with `stack` on an Ubuntu virtual machine with 2 GB of RAM fails with:
08:45:40 <alexelcu> > ghc: internal error: Unable to commit 1048576 bytes of memory
08:45:40 <alexelcu> I guess it needs more memory than 2 GB, but that's a lot ☹️
08:45:42 <lambdabot>  <hint>:1:53: error: parse error on input ‘of’
08:46:17 <maerwald> compiling haskell stuff with 2gb ram is impossible
08:46:35 <maerwald> also note that stack defaults to $(nproc) jobs
08:48:02 <monochrom> Yeah you want to kill parallelism if low on RAM.
08:49:02 <monochrom> Another angle is that 32-bit GHC uses half as much memory as 64-bit GHC.
08:49:22 <monochrom> (Both GHC itself and the exes it builds.)
08:52:44 <alexelcu> limiting parallelism is a good tip; btw, it crashed when compiling Cabal, increased memory to 4 GB, set CPUs to 1, now it seems to be staying at 2.15 GB of RAM usage
08:52:55 <alexelcu> what would be the minimum requirements in your opinion?
08:53:16 <maerwald> 8
08:53:16 <the_2nd> I am using ghcid for quite some time now
08:53:29 <the_2nd> I added a test executable to my project
08:53:30 <maerwald> and even with 8 you can get into problems
08:53:59 <the_2nd> now ghcid seems to check this one instead of Main, not noticing errors in my Main code. Any idea on how to tell it which one to watch?
08:54:01 <maerwald> selenium occasionally triggers my earlyoom killer on 16gb
08:54:19 <maerwald> (ofc, with other stuff open)
08:58:22 <alexelcu> 😱
09:01:25 <maerwald> ghc is a good example of how hard it is to reason about performance in haskell :)
09:02:13 <monochrom> I was doing OK with 3GB RAM.
09:02:56 <maerwald> compiling filepath maybe
09:03:26 <monochrom> No, building all of Haskell Platform.
09:04:05 <maerwald> try amazonka, gogol, selenium webdriver, ...
09:05:05 <monochrom> Sure, I haven't tried those.  But I have built GHC itself.
09:22:26 <akegalj> alexelcu: try something like this `stack build --ghc-options="+RTS -A256m -n2m -RTS"`
09:23:38 <akegalj> alexelcu: also setting `--jobs=1` will limit to one core (which should help with RAM as well if you have multicore proc)
09:24:22 <akegalj> alexelcu: tldr; this might do the trick `stack build --ghc-options="+RTS -A256m -n2m -RTS" --jobs=1 ...`
09:24:44 <cocreature> the_2nd: how are you launching ghci?
09:24:51 <cocreature> *ghcid
09:40:31 <alexelcu> akermu: thanks, that looks useful, will try
10:12:37 <masterkraft0r> hello
10:13:40 <masterkraft0r> is there a haskell newbie irc? i have a question about random number generation and i'm not sure where to ask.
10:15:36 <yushyin> masterkraft0r: here is fine
10:15:58 <rain2> hey can you help with continuations again ?
10:16:31 <rain2> single prompt shift/reset can implement multi-prompt version using a mutable cell.. I found code that does it but no real explanations of how it works
10:17:05 <jeetu>  /CLOSE 
10:18:35 <sm> masterkraft0r: have you tried searching for "haskell random numbers" and seen eg the School of Haskell article ?
10:23:07 <noumenon> posted this in haskell-beginners, but doesn't seem to be much activity over there
10:23:09 <noumenon> https://pastebin.com/raw/CpGD0NrK
10:24:18 <cocreature> noumenon: why don’t you just try it out?
10:26:13 <noumenon> sure, I'll try
10:26:31 <noumenon> is there an easy way to define those functions I described though?
10:26:41 <noumenon> I guess I could think of other functions as well
10:27:26 <cocreature> the first is \x -> ord x - ord 'a' + 1
10:27:49 <cocreature> > [f, g :: Expr -> Expr] <*> [x, y]
10:27:51 <lambdabot>  [f x,f y,g x,g y]
10:27:55 <cocreature> this might also be helpful
10:28:07 <foojin> noumenon: It just goes through the functions and the arguments and applies them, varying the ones from the rightmost list first.
10:28:19 <noumenon> not helpful at all; I'm still a total noob; the ord function is helpful though
10:28:43 <noumenon> foojin: that made zero sense, sorry
10:28:50 <foojin> > [(+1), (*2)] <*> [1..3]
10:28:52 <noumenon> the rightmost list?
10:28:52 <lambdabot>  [2,3,4,2,4,6]
10:29:09 <noumenon> oh, it just concatenates all the resulting lists
10:29:14 <noumenon> well that answers that
10:30:53 <fendor> > [f a | f <- [(+1), (*2)], a <- [1..3]]
10:30:56 <lambdabot>  [2,3,4,2,4,6]
10:31:55 <noumenon> so Just (+1) <*> Just 4 would yield 5 then, and Just (+1) <*> Nothing would yield Nothing
10:32:53 <noumenon> although in that case, it's not really different from fmap, is it?
10:33:23 <foojin> noumenon: It's somewhat like using only empty and singleton lists in your first example.
10:33:38 <foojin> noumenon: And it's quite different from fmap.
10:34:10 <cocreature> if your first argument is always Just then you can replace it with an fmap but if it’s always Just why are you using a Maybe :)
10:34:31 <noumenon> right; that makes sense
10:34:55 <noumenon> because fmap Nothing (Just 3) doesn't make sense at all
10:35:19 <noumenon> but Nothing <*> Just 4 would yield Nothing?
10:35:22 <foojin> fmap accepts a "plain" function (without the `f` context), while <*> takes the context into account too.
10:36:28 <noumenon> guess I can follow cocreature's advice and just try it out for myself on that one
10:36:31 <noumenon>    Nothing <*> Just 4
10:36:31 <noumenon> => Nothing
10:36:57 <monochrom> I think you've mistaken <*> for <$>.
10:37:28 <foojin> Without <*> (using fmap only) you'd just end up with a Maybe (Maybe a) with no way to flatten it.
10:37:31 <monochrom> fmap f m = f <$> m = pure f <*> m ⇍ f <*> m
10:37:56 <monochrom> err s/⇍/≠/
10:38:44 <noumenon> I'd love to be able to make that mistake, but I'm definitely not advanced enough to be even close to making any such mistake
10:39:07 <noumenon> also, how come (+2) is happily accepted as a function, but not (-2)?
10:39:26 <monochrom> -2 is the number negative two.
10:39:47 <monochrom> The pain of supporting unary minus.
10:40:02 <noumenon> right
10:40:19 <noumenon> what's the easiest way of writing the equivalent function, i.e. subtractTwo
10:40:27 <monochrom> subtract 2
10:40:54 <__monty__> (-2 +)
10:40:57 <__monty__> : >
10:41:17 <fendor> question unspecific to haskell: what should an application log? JSON messages? Time? in which function it was invoked?
10:41:22 <fendor> :t subtract
10:41:23 <lambdabot> Num a => a -> a -> a
10:42:01 <monochrom> For best privacy, an application should log nothing.
10:42:05 <noumenon> yeah, (-2 +) works; figured I could use (+(-2)) as well, which indeed I could, but that's longer
10:42:12 <foojin> > fmap (\x -> fmap (\f -> f x) (Just (+1))) (Just 42)
10:42:14 <lambdabot>  Just (Just 43)
10:42:34 <fendor> monochrom, so not user information :P
10:42:45 <monochrom> For best eavesdropping, an application should log every key press.
10:43:52 <fendor> fair enough
10:44:57 <foojin> noumenon: Just like that ^, you can't get your "flat" Maybe Int out, so some functors admit <*> for combining these.
10:45:44 <noumenon> I didn't understand that at all
10:46:45 <ski> rain2 : .. i don't know, sorry. haven't looked into it
10:47:11 <foojin> noumenon: You might want a function to have a context similar to the one that your values are in (meaningful application of binary operators is but one example of that).
10:47:42 <noumenon> yes, I tried Nothing <*> Just 4, and it yielded Nothing as expected
10:48:37 <foojin> noumenon: It works if you do stuff like (+) <$> Just 1 <*> Just 2, but try doing it with fmap alone and you'll see the nesting issue.
10:48:55 <noumenon> I have no idea what <$> even is
10:49:03 <foojin> noumenon: It's fmap.
10:49:08 <noumenon> aha
10:50:03 <noumenon> but yeah, I think I get it, cocreature pretty much summed it up with: <cocreature> if your first argument is always Just then you can replace it with an fmap but if it’s always Just why are you using a Maybe :)
10:52:08 <foojin> noumenon: That's right, but I thought you wanted to know why <*> is a thing.
10:52:40 <Nolrai> Hey so I am getting absurdly high std devs on a toy use criterion, std devs longer then the benchmark takes to run. Is it actually the variance or something? https://gist.github.com/Nolrai/359d260430aa9dfc2efd89fc2fbfe823
10:52:55 <noumenon> yes, briefly I wanted to know how it was different from fmap, but that reply I just quoted answered it
10:53:23 <noumenon> since you can't do Nothing <$> Just 4
10:54:16 <Nolrai> @t Nothing <*> Just 4
10:54:16 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
10:54:28 <Nolrai> @type Nothing <*> Just 4
10:54:29 <lambdabot> Maybe b
10:54:42 <foojin> noumenon: And it gets even more interesting with things other than Maybe, when you can't create all possible contexts or pattern match on them freely.
10:55:27 <noumenon> yeah, I still think it's a bit weird that the default behavior for lists is to return a big, concatenated list of all the resulting lists
10:55:58 <Nolrai> Its for implementing "non-determanism".
10:56:03 <cocreature> noumenon: what behavior are you proposing instead?
10:56:12 <Nolrai> Err modulo my bad spelling.
10:56:37 <noumenon> heh, got me there; I guess that's the only thing that makes sense if you have to return a list
10:56:45 * ski . o O ( "angelic non-determinism" )
10:57:03 <foojin> noumenon: There's an alternative way though (ZipList).
10:57:37 <noumenon> it's just more intuitive for me that when you have a list of functions, and a list full of things you can apply those functions to, that you'd end up with a list of lists instead of a flattened one, but that would be something else entirely of course
10:57:40 <ski> > getZipList (ZipList [(+ 2),(* 2),(^ 2)] <*> ZipList [1,2,3])
10:57:42 <lambdabot>  [3,4,9]
10:58:17 <ski> > [[f x | x <- [1,2,3]] | f <- [(+ 2),(* 2),(^ 2)]]
10:58:19 <lambdabot>  [[3,4,5],[2,4,6],[1,4,9]]
10:59:09 <noumenon> yes, that's more intuitively what I'd expect to get when applying a list of functions to a list
10:59:26 <ski> @type \f x -> fmap (\f -> fmap (\x -> f x) x) f
10:59:27 <lambdabot> (Functor f2, Functor f1) => f1 (t -> b) -> f2 t -> f1 (f2 b)
10:59:35 <Nolrai> > [(*2),(*3),(+2)] <$> (fmap [2,4,-1])
10:59:37 <cocreature> the “downside” of that instance is that there is no corresponding Monad instance
10:59:37 <lambdabot>  error:
10:59:37 <lambdabot>      • Couldn't match expected type ‘f b0 -> b’
10:59:37 <lambdabot>                    with actual type ‘[Integer -> Integer]’
10:59:51 <ski> works for any two functors, doesn't need to be equal
10:59:51 <noumenon> all those function definitions and type declarations are going completely over my head though
10:59:54 <noumenon> can't follow at all
11:03:32 <cocreature> noumenon: take some time to digest and play around with those definitions
11:03:38 <foojin> This would hopefully be more clear (at least it doesn't have crazy infix operators):
11:03:44 <foojin> > fmap (\x -> fmap (\f -> f x) [(+1), (*2)]) [1..3]
11:03:46 <lambdabot>  [[2,2],[3,4],[4,6]]
11:03:52 <cocreature> the only thing that will really make things more clear is practice
11:03:55 <noumenon> those definitions don't even fit in my mouth
11:04:26 <noumenon> yeah, I want to program game of life in haskell, but struggling with where to even begin
11:05:03 <noumenon> I got some useful advice, use an Array for my Grid, but that's as far as I've gotten conceptually
11:05:52 <Ariakenom> noumenon: have you drawn anything on the screen?
11:06:21 <Nolrai> In haskell infix opperators are just another way to name functions, its good to get practice seeing how infix and normal are equivalent.
11:06:51 <noumenon> Ariakenom: yes: "data Grid = Array"
11:07:10 <noumenon> but not sure if it even makes sense or how to finish that line...so probably not advanced enough to begin doing that yet
11:07:27 <Ariakenom> noumenon: not written in text editor. but graphics
11:07:41 <noumenon> but trying to digest all those function definitions being thrown around all the time feels like "wax on, wax off", and I don't feel confident they'll teach me karate
11:07:52 <nitrix> noumenon: Probably a Simulation newtype that's a MonadState, and your state will be the Grid.
11:08:08 <noumenon> lol, no; saving that for last for sure, would want it represented in the command-line before anything
11:08:11 <nitrix> noumenon: Then you build your application out of those Simulation functions.
11:08:11 <Nolrai> "data Grid = Array" makes a enum with one value: Array.
11:08:16 <noumenon> nitrix: gee, thanks man
11:08:33 <noumenon> a Simulation newtype that's a MonadState, makes perfect sense, haha
11:09:03 <foojin> noumenon: You don't need functors and applicatives to manipulate arrays and print to console, if you don't mind the lack of UI.
11:09:15 <noumenon> no offense man, just joking around with how little sense that makes to me; I mean, I can understand vaguely that I'm going to be making some kind of simulation and that it'll involve state
11:09:44 <noumenon> foojin: that may be, I wasn't really checking out functors and applicatives for that specifically just now, that was separate
11:09:53 <Nolrai> state is just plumbing, you can do it by hand just fine.
11:10:01 <foojin> noumenon: Think about how to transform your array at each step.
11:11:04 <Nolrai> Having a 2d array comonad would actually save you more work..but you can also do that by hand just fine too.
11:11:10 <the_2nd> cocreature, no args with ghcid, just the exe
11:11:16 <noumenon> I mean, I could spin up game of life in python in 10 minutes, it's doing it the haskell way that's conceptually hard for me, especially if I don't even know whether or not I have the knowledge to do it right...but I'll keep trying
11:11:30 <cocreature> the_2nd: are you using stack, cabal, …?
11:11:32 <noumenon> Nolrai: I barely understand what a monad is (eh, I don't really), so a comonad...man
11:11:40 <nitrix> noumenon: Start with small functions do takes a Grid and produces a Grid.
11:12:06 <nitrix> noumenon: Once you get comfortable with that, we can introduce an abstraction for all those functions that takes a state and produce a new state.
11:12:21 <the_2nd> cocreature, stack + cabal
11:12:21 <noumenon> yes; however, I want my Grid to be made out of Cells
11:12:21 <the_2nd> stack build works correctly
11:12:21 <the_2nd> ghcid seems to use the test as entry
11:12:29 <__monty__> Stack + cabal?
11:12:47 <the_2nd> I mean I use stack and have the .cabal too
11:12:53 <nitrix> noumenon: The Array type in Haskell has two type parameters.
11:12:59 <nitrix> noumenon: data Array i e
11:13:12 <nitrix> noumenon: `i` is the type of the index, `e` is the type of the element.
11:13:14 <cocreature> the_2nd: try "ghcid -c 'stack ghci <yourtargethere>'"
11:13:24 <noumenon> ah, I see
11:13:36 <noumenon> so data Grid = Array Int Cell
11:13:42 <nitrix> noumenon: So something like `Array Int Cell` would work fine for you.
11:13:44 <nitrix> Yep.
11:13:49 <lavalike> I really really really really love ghcid
11:13:52 <noumenon> I was told Array had intrinsic support for 2D indexing though
11:13:54 <nitrix> Well, you'll want `type` not `data`.
11:13:54 <cocreature> not quite like that, that is missing the constructor name
11:14:03 <lavalike> I still haven't gotten around understanding how it reloads so fast with errors or success.
11:14:12 <noumenon> why type and not data?
11:14:12 <cocreature> either "type Grid = Array Int Cell" or "data Grid = MkGrid (Array Int Cell)"
11:14:18 <cocreature> lavalike: it reloads just as fast as ghci
11:14:18 <nitrix> noumenon: `type` defines a type alias. `data` creates a new data type with its own constructors and stuff.
11:14:21 <noumenon> that's not what I read in LYAH :[
11:14:28 <Nolrai> noumon: just do a function (Array Int Int -> Array Int Int) and a loop in IO for now. Later you can comeback and refactor and see how a comonad will save you work. (Honestly here a state monad wont actually save you much if at all),.
11:14:31 <noumenon> ah, because in this case Grid is just an Array
11:14:53 <the_2nd> cocreature, nice, thank you
11:15:35 <Nolrai> Oh, yeah it would be Array (Int, Int) Cell, for a 2D array.
11:15:55 <lavalike> cocreature: not if I run stack ghci
11:16:05 <nitrix> I'd argue that array still has one dimensiion :P
11:16:06 <noumenon> right; better get on to defining Cell though
11:16:30 <nitrix> noumenon: For Cell you'll probably want your own data type using `data` :)
11:16:45 <cocreature> lavalike: then you’re not using the same options. the options ghcid passes by default vary depending on whether you use stack, cabal, -c, … but iirc the default is -fno-code which can make quite a difference
11:17:01 <nitrix> data Cell = Alive | Dead ?
11:17:20 <lavalike> cocreature: that must be it
11:17:40 <noumenon> yes, that seems reasonable; I guess it could even be extended later to more than two types of cells, that's neat
11:18:09 <nitrix> noumenon: Yeah and if you do, GHC will tell you everywhere where a Cell is used and enforce that you take care of all the new cases.
11:18:26 <noumenon> since it's compiled, I guess I can refer to Cell in the type constructor of Grid further up in my code than Cell is defined, right?
11:18:34 <noumenon> perhaps it's better by convention to do it the other way around anyway
11:19:02 <noumenon> that's nice to know, thanks GHC
11:19:05 <nitrix> noumenon: The order of the definitions dont matter.
11:19:25 <nitrix> As long as they are in scope.
11:19:37 <noumenon> right
11:20:08 <nitrix> Share your code as soon as you have something going :)
11:20:37 <noumenon> still just those two definitions, but let me think for a while on what to do next
11:21:27 <nitrix> Probably a function that calculates the next grid state from the previous grid state.
11:21:39 <nitrix> Play with it in the REPL until you're happy :P
11:22:06 <noumenon> yep, and one to generate initial grid state
11:22:12 <nitrix> Yup!
11:22:35 <nitrix> Use `array`
11:22:53 <noumenon> what do you mean?
11:23:01 <nitrix> :t array
11:23:02 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
11:23:13 <nitrix> There's a function to create an array and it also initialize the elements.
11:23:37 <noumenon> hmm
11:23:50 <nitrix> Or maybe listArray if that's easier.
11:23:54 <nitrix> :t listArray
11:23:55 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
11:24:09 <nitrix> > listArray 0 5 (repeat 42)
11:24:11 <lambdabot>  error:
11:24:11 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
11:24:11 <lambdabot>                    with actual type ‘Array i0 e0’
11:24:17 <noumenon> how does it know what to initialize the elements as?
11:24:24 <nitrix> :t listArray (0, 5) (repeat 42)
11:24:25 <lambdabot> (Num e, Num i, Ix i) => Array i e
11:24:38 <nitrix> noumenon: Dead ?
11:24:53 <noumenon> why is that default?
11:25:06 <mizu_no_oto> > listArray (0, 5) (repeat 42)
11:25:08 <lambdabot>  array (0,5) [(0,42),(1,42),(2,42),(3,42),(4,42),(5,42)]
11:25:21 <nitrix> The elements are Cell, so you have the choice between Alive and Dead. The cells should probably be all dead when you begin, then you set a handful to be alive and let the simulation run.
11:25:27 <nitrix> Game of life :P
11:25:34 <noumenon> also, I would ideally want to be able to initialize it however way I like; best way would in fact be to read from a text file where it's represented as an ASCII grid
11:25:49 <noumenon> i.e. which ones are dead and alive
11:25:57 <nitrix> Sure. Read the file, turn it into a list, feed it to listArray :)
11:26:01 <hyperisco> nitrix, that doesn't answer the mystery of biogenesis though
11:27:01 <noumenon> I don't really understand listArray and how I'd do that with it, but I'll think about it
11:27:33 <noumenon> like, since it takes a list, which I presume is 1D, how does it know the dimensions of the array?
11:27:39 <nitrix> noumenon: listArray takes two arguments. The first one is a tuple that says what the boundaries of the array is (the lowest and the highest). The second argument is a list of all the initial values.
11:28:08 <mizu_no_oto> > listArray ((0,0), (2,2)) [1..]
11:28:10 <lambdabot>  array ((0,0),(2,2)) [((0,0),1),((0,1),2),((0,2),3),((1,0),4),((1,1),5),((1,2...
11:28:16 <noumenon> but...how is that 2D?
11:28:30 <nitrix> noumenon: The array has only one dimension, but you can use 2d-tuples for the key to make it easier to use.
11:28:39 <noumenon> oh, I see.
11:28:44 <dmwit> noumenon: Well, each element is associated with an index that has an x and y coordinate. How is it not 2D? =)
11:29:16 <nitrix> dmwit: I'd argue it's still one dimension. It relies on the Ord instance of that 2D tuple :P
11:29:25 <dmwit> (Actually the Ix instance.)
11:29:26 <noumenon> so if I want a 10x10 Grid the bounds would be (0, 99)?
11:29:33 <nitrix> dmwit: Oh :o
11:29:44 <dmwit> noumenon: No, of course not. ((0,0), (9,9)) would be much more suitable for a 10x10 grid.
11:29:58 <noumenon> yes...but that's 2D
11:30:10 <dmwit> Yes. And you want 2D1
11:30:14 <dmwit> s/1/!/
11:30:24 <noumenon> yep; so if that works, great, awesome
11:30:26 <nitrix> noumenon: If you enumate the values from (0,0) to (9,9) you'll have 100 of them.
11:30:32 <mizu_no_oto> noumemon: indexes have to be some type with an Ix instance.  Examples of types with an Ix instance are Int, (Int, Int), and (Int, Int, Int)
11:30:36 <nitrix> noumenon: (0, 0),  (0, 1),  (0, 2) , .....
11:30:56 <nitrix> enumerate*
11:31:04 <dmwit> noumenon: Not only does it work, mizu_no_oto *demonstrated* it working above. =)
11:31:21 <noumenon> oh, nice, I see now
11:31:22 <hyperisco> How would one characterise 2D with an adjacency relation? Hrm.
11:31:52 <noumenon> so...I'd read the grid from a file and determine the bounds and list based on that, and construct the array then
11:32:07 <noumenon> alright, got a mouthful to chew on now, time to try writing some code
11:32:31 <mizu_no_oto> So listArray and array can work with n dimensional arrays because they're polymorphic over the index type
11:32:53 <hyperisco> I suppose you should want 2 relations. So an order basically works as one dimension… hrm
11:32:58 <nitrix> noumenon: You'll probably be passing Grid around alot. Eventually, with various Monad or Comonads, we can abstract that. For the moment, you just want to get it working :)
11:33:39 <noumenon> right, plumbing
11:34:11 <dmwit> I think a plumbus can help with that. Not easy to get your hands on one in our galaxy, though.
11:34:17 <nitrix> It's easier to learn the more complex abstractions when you have a tangible example, so lucky you :P
11:34:20 <johnjay> hey what's a good reason to learn haskell?
11:34:28 <hyperisco> to impress the ladies
11:34:32 <dmwit> Greed, sloth, avarice
11:34:53 <nitrix> To stand tall on top of our ivory tower, of course.
11:35:10 <johnjay> dmwit: shouldn't that be laziness, hubris, and impatience?
11:35:27 <dmwit> I like it!
11:36:08 <mizu_no_oto> hubris is the inverse of why I like Haskell
11:36:33 <dmwit> (It feels a bit like Jeapordy, in that the order of question and answer seems reversed. "I have already decided to do X. Why did I decide that?")
11:37:10 <dmwit> (Or maybe even, "I have already decided to do X, now let me figure out how to justify that decision.".)
11:37:10 * ski . o O ( equation solving )
11:37:24 <nitrix> dmwit: You're just theorem proving at this point.
11:37:59 * nitrix goes on to write a dmwit proof.
11:38:29 <noumenon> nitrix: yeah, that was kind of the point to actually get down to it and write something tangible
11:38:35 <cocreature> noumenon: can you proof dmwit constructively?
11:38:40 <cocreature> *prove
11:39:04 <noumenon> yes, let me get my magic wand
11:39:05 <nitrix> We'll use deductive reasoning.
11:39:10 <ski> johnjay : i suppose one reason could be that it's fun ?
11:39:16 * dmwit holds his breath
11:39:38 <dmwit> I'm not sure what will happen if noumenon answers "no"...
11:40:17 <cocreature> don’t worry, we’ll just use good old lem to prove you
11:42:26 <mizu_no_oto> Just need to call the crush tactic, right?
11:42:46 <ski> johnjay : perhaps to learn more about variant types and pattern-matching. or more about immutability. or (non-stupid) static typing. or what difference laziness makes
11:42:49 <cocreature> crushing dmwit seems a bit extreme
11:43:27 <hyperisco> you know I have been programming strictly for several months now and I gotta say I hardly notice anything
11:45:57 <mizu_no_oto> hyperisco: Programming strictly?  With Purescript or Idris or something?
11:46:04 <hyperisco> ps
11:46:21 <hyperisco> I'd say Idris too but I never actually ran any of my Idris programs… just compiled them :)
11:47:17 <mizu_no_oto> You tend not to notice strictness until you need to tie the knot or something.
11:48:03 <hyperisco> I find it only comes up now and then. That's all.
11:49:06 <hyperisco> I haven't been comparing efficiency between the two approaches or anything. I just care that it terminates/produces.
11:49:10 <mizu_no_oto> Oh, certainly.  I spent a year writing PS and there were only a handful of times I had to jump through hoops because I needed laziness
11:50:44 <hyperisco> mizu_no_oto, it is a little weird how eta expansion/reduction isn't semantically identical
11:58:15 <ski> hyperisco : wrt efficiency or termination ?
11:58:24 <hyperisco> ski, termination
11:58:45 <hyperisco> well you sometimes end up with an invalid program too
12:02:04 <ski> hm, invalid in which sense ?
12:03:36 <hyperisco> does not compile
12:04:09 <geekosaur> ghc has certain limitations
12:04:40 <geekosaur> althug the one I'm thinking of only applies with multiple equations
12:05:32 <hyperisco> x = 1 + y; y = x * 2;  does not compile, but  x _ = 1 + y (); y _ = x () * 2;  does
12:07:02 <ski> in PS ?
12:07:21 <ski> that's not simple eta, though
12:08:09 <hyperisco> I wasn't trying to give an eta example there
12:08:50 <ski> oh, ok
12:08:58 <hyperisco> f = g; g = f;  does not compile but  f x = g x; g x = f x  does
12:10:31 <xsperry> hyperisco both compile, but types are different
12:11:13 <ski> hyperisco isn't talking about Haskell, i think
12:11:15 <hyperisco> xsperry, was talking about strict languages, particularly PS, in contrast to Haskell
12:11:24 <xsperry> ah
12:11:25 <zachk> whats PS?
12:11:25 <hyperisco> not sure what Idris does in this scenario
12:11:29 <ski> Purescript
12:39:48 <zachk> do I lose anything or does enabling FlexibleInstances cause any problems?
12:41:05 <zachk> and what about FlexibleContexts as well?
12:43:20 <fendor> zachk, basically, you can use concrete types in type constraints
12:43:40 <zachk> does it cause any problems, say with type inference? 
12:43:56 <fendor> no
12:44:09 <fendor> at least, nothing ever happened to me
12:44:50 <fendor> zachk, https://stackoverflow.com/questions/31251163/what-is-the-flexiblecontexts-extension-good-for-could-you-please-explain-it-usi
12:47:30 <slack1256> TIL: ghci :script plust the :m *module syntax can help you play with the internals of a library with strict export lists.
12:53:14 <butterthebuddha> Are there good resources for modern Haskell design patterns?
12:53:22 <butterthebuddha> Are there good resources for modern Haskell design patterns?
12:54:17 * __monty__ cringes at the terminology.
12:54:40 <Rembane> butterthebuddha: They are many and we don't have consensus on which are good.
12:55:04 <Rembane> butterthebuddha: ...or rather, in which cases they are good and when they are to be avoided.
12:55:59 <butterthebuddha> Rembane: I'd appreciate any input I suppose
12:56:15 <butterthebuddha> More than anything, I want to strive for more readable code; atm I don't care much for efficiency
12:56:24 <fendor> butterthebuddha, while I agree with that, the ReaderT pattern as described here: https://www.fpcomplete.com/blog/2017/06/readert-design-pattern is pretty cool!
12:57:30 <fendor> personally, i also enjoyed this post where the author describes a REST API. https://vadosware.io/post/rest-ish-services-in-haskell-part-1/
12:59:10 <Zemyla> Is there, like, a simple monad for HTML/CGI?
12:59:30 <butterthebuddha> fendor: Ty!
12:59:54 <fendor> Zemyla, why do you need a monad? 
13:00:00 <Zemyla> Like, I'd be able to do value <- request "VALUE" or h1 $ bold $ write "This is a bold header".
13:00:07 <fendor> butterthebuddha, np!
13:00:15 <fendor> what would request do?
13:00:26 <foojin> Does Purescript still enforce that annoying "_ <- foo" in do blocks?
13:00:28 <fendor> do you want to build a web service?
13:00:35 <Zemyla> Get the variables in the URL or something.
13:01:21 <paf31_> foojin: only for non-Unit results
13:01:30 <paf31_> which GHC also does, but it's behind a flag
13:01:31 <hyperisco> only for non-Discard results
13:01:40 <paf31_> Right
13:02:50 <fendor> Zemyla, well, blaze defines a monad for markup. 
13:03:29 <jle`> it's more like a monoid
13:03:31 <foojin> I remember trying to write a Discard instance to shut it up, but it turned out that orphan instances are also disallowed.
13:04:01 <paf31_> Is _ <- such a burden to type? :)
13:04:08 <hyperisco> yeah well you have to let go of what you're used to
13:04:40 <fendor> while probably true, it defines a monad instance :D 
13:04:42 <jle`> i write _ <- in haskell ...
13:05:12 <hyperisco> I don't like change either but I try and put things in perspective… then I often ignore that assessment but that's beside the point
13:05:24 <foojin> paf31_: It just starts to look weirder and weirder when most of the lines have arrows and some do not.
13:05:33 <foojin> I never noticed that in Haskell.
13:06:12 <dmwit> I have a cunning plan.
13:06:23 <dmwit> If the problem is that some lines have arrows and some do not.
13:06:25 <hyperisco> put syntax low on your list of priorities and you'll be a happier person
13:06:27 <dmwit> Eliminate the ones that do not.
13:06:34 <Rembane> Can you stick a tail on it and call it a weasel?
13:07:02 <cocreature> arrows for everyone \o/
13:07:21 <Rembane> Arrows are just functions! 
13:07:23 * Rembane ducks
13:08:17 <foojin> dmwit: Like moving stuff to the next <- line and attaching it there with >> or *> ?
13:08:40 <dmwit> I was thinking just type `dd` with your editor.
13:08:53 <dmwit> But if you must, `I_ <-<ESC>` would be okay, too.
13:09:00 <Zemyla> But yeah, it's probably just a ReaderT (HashMap Text Text) (WriterT Text IO).
13:10:17 <Zemyla> Also, does Haskell automatically convert "_ <- x; y" into "x >> y"? Because the latter can be much more efficient.
13:10:20 <foojin> dmwit: I like how you assume that I use the editor that I actually use (if it makes sense).
13:11:51 <dmwit> ^_^
13:11:57 <foojin> dmwit: At least it's the one that doesn't bug me to the point of not wanting to use it.
13:12:28 <dmwit> Zemyla: I think no. But consult your local -ddump-simpl to be sure.
13:13:48 <foojin> BTW what's the deal about orphan instances? Don't they make it easier for people to add functionality without having to ask someone upstream?
13:14:42 <geekosaur> the problem is they do wo without bound
13:14:45 <geekosaur> so
13:14:54 <dmwit> The party line is that orphan instances are dangerous because two libraries could add conflicting instances and prevent you from ever mixing and matching those two libraries.
13:14:57 <benzrf> instances are a global namespace
13:14:59 <geekosaur> instances are global, so spooky action at a distance
13:15:50 <dmwit> (My own personal line is a bit more flexible.)
13:15:53 <geekosaur> (they're also runtime via dictionary passing, your comiled code is not safe from future instances)
13:16:13 <jle`> foojin: orphan instaces are ok for application code usually, but they can be disastrous for library code
13:16:14 <foojin> hyperisco: It's a little late, but still: if I didn't worry about syntax that much, I would probably use Guile or CL. Trying to align arrows and pipes at least makes it bearable to look at.
13:16:15 <benzrf> non-orphan instances can be viewed as sort of belonging to the module in which they are defined
13:16:32 <jle`> foojin: imagine a situation where two different libraries you use both define orphan instances for the same type
13:17:09 <jle`> and one of the libraries just uses the instance internally with no expectation that a user uses it
13:17:15 <foojin> hyperisco: The code that is.
13:17:16 <jle`> instances are global, so you can't hid from them
13:18:04 <hyperisco> foojin, *shrug* I think familiarity will set in soon enough
13:19:16 <hyperisco> what makes good programs doesn't have much to do with what looks pretty to a human in a text editor
13:19:33 <jle`> well, good code has to be readable
13:19:41 <jle`> i wouldn't go to that extreme
13:20:22 <hyperisco> sure, but aesthetically good code doesn't have much to do with good programs, is just what I was saying
13:20:40 <jle`> from an end-user perspective, maybe not
13:20:52 <jle`> but from a maintainer and writer and programmer perspective, there is a relationship
13:21:24 <jle`> but in the end it might affect end-user experience, as well, since difficult-to-maintain programs can often leak bugs to end-users
13:21:30 <foojin> So the problem (as I see it) could possibly be solved by providing means to selectively import/export them (possibly referring to them by names).
13:21:44 <foojin> (BTW it's not newtype wrappers all over again, because no plumbing should be needed after importing properly)
13:21:51 <jle`> foojin: the problem with that is that it defeats the purpose of typeclass instances
13:21:55 <jle`> and coherence
13:22:11 <jle`> typeclasses *have* to be global in order to work properly and obey expectations
13:22:45 <hyperisco> jle`, it is so subjective I can't make any sense of it
13:22:45 <jle`> for example, let's say you create a Data.Set set of Foo in one module with Ord instance for Foo, and then later use it in a different module that 'imports' a different Ord instance for Foo
13:23:20 <Athas> I guess GHC will grow linear types, now.
13:23:38 <jle`> foojin: that would then make sets incoherent/unusable since the internal representation is corrupted between module boundaries
13:23:56 <jle`> hyperisco: code aesthetics can affect maintainability and readability
13:24:08 <cocreature> Athas: itshappening.gif
13:24:30 <jle`> hyperisco: if you mean 'good programs' as in good for end-users, then it might not affect them directly. but on the long term end-users will notice
13:24:54 <hyperisco> I'm not arguing with any of that
13:25:11 <hyperisco> there are some gross features that might apply to everyone, such as line length and formatting consistency
13:25:35 <Athas> cocreature: sharkjump.webm
13:26:00 <hyperisco> _ <- vs not is so small as to probably be lost in the noise of preference
13:26:22 <foojin> jle`: Ah, I see. It would impede separate compilation that way. Also some things inexpressible in the type system might break (like the laws that "connect" Functor and Monad).
13:26:26 <jle`> hyperisco: yeah, i agree
13:26:50 <hyperisco> and if you just allow yourself to become familiar then I doubt you'll have much problem
13:26:56 <jle`> aesthetics isn't the whole picture, but it isn't not a part of it at all
13:27:09 <hyperisco> as long as you can readily get the information to your eyes and as long as similar information is presented similarly, sounds like reasonable syntax to me
13:27:36 <jle`> that particular example is reasonable.   but it is a reasonable thing in *this* specific situation
13:27:47 <jle`> er, _ <- is reasonable in particular
13:27:57 <jle`> it is not a general principle that aesthetics don't matter; it's a case by case basis
13:28:39 <jle`> it matters sometimes and doesn't in others
13:28:41 <hyperisco> I've watched what particular senses of aesthetics have done to APIs
13:28:45 <foojin> hyperisco: Then again, maybe I'm just too concerned about that because after a while working on any program of mine starts to look like I'm making it more and more ugly to me.
13:28:55 <jle`> it helps in some situations and doesn't help in others
13:29:04 <jle`> it is not a general principle that it always helps or always harms/doesn't help
13:29:13 <hyperisco> some programmers bend the program backwards to play to the syntax
13:29:28 <hyperisco> always a mistake, in my view
13:30:10 <jle`> that's kind of a tautology, because bending backwards is always bad, whether it is for syntax or not
13:30:23 <hyperisco> I'm not in a court of law so I'm allowed to load things :P
13:30:24 <jle`> but some programmers can change their programs to play to the syntax, and the result can be beneficial in certain situations
13:30:25 <foojin> I'm guilty of trying to find a set of names which all have the same length for the things of the same type just to have them align in similar expressions.
13:30:51 <jle`> bending program backwrads to play to syntax is always bad yes, but formatting your program differently to play to syntax is sometimes bad, sometimes good
13:31:26 <hyperisco> I don't think I'm talking to you, is the problem
13:32:07 <dmwit> This is why I use a hex editor to write assembly directly.
13:32:08 <elgoosy> https://hackage.haskell.org/package/containers-0.4.2.0/docs/Data-Map.html why are there two lines of import there at the beginning? Isn't it enough the second one only? `import qualified Data.Map as Map`
13:32:15 <dmwit> It is not possible to be beautiful, so who would try?
13:32:38 <foojin> hyperisco: ?
13:32:43 <cocreature> elgoosy: the first allows you to use the Map type unqualified
13:32:48 <dmwit> elgoosy: You could do that, but then the bare name `Map` would not be in scope.
13:32:49 <jle`> bending program backwrads to play to syntax is always bad yes, but formatting your program differently to play to syntax is sometimes bad, sometimes good
13:32:51 <cocreature> elgoosy: otherwise you would have to use Map.Map for that
13:32:54 <dmwit> elgoosy: Only `Map.Map`.
13:33:30 <jle`> sorry, accidentally sent twice :)
13:33:33 <oo_miguel> how can I convert LocalTime to an miliseconds since 1970 ?
13:35:11 <elgoosy> got it, thanks
13:36:00 <hyperisco> jle`, there is a design philosophy that orients around syntax. Personally I see it nowadays in JavaScript but it is around in many languages. You can discern this philosophy is used easily because the project home page will talk about how simple and concise the code is and how few lines there are.
13:38:12 <jle`> i do consider that an extreme yes
13:38:34 <foojin> hyperisco: If my input ended up being unneeded, then forgive me for butting in. I probably misunderstood who was talking to whom.
13:40:20 <hyperisco> then you see a lot of overloaded functions and possibly string-typed dsls… certainly fluid syntax
13:41:02 <dmwit> oo_miguel: http://hackage.haskell.org/package/time-1.9.2/docs/Data-Time-Clock-POSIX.html
13:42:02 <hyperisco> and in sufficiently dynamic languages, objects that are constructed at runtime in a piecewise manner
13:42:03 <foojin> dmwit: Hex dumps do provide an example of extreme regularity, but they don't highlight the details well enough (at least not when your editor can change the width of the dump and reflow it for the structs to end up right next to each other).
13:42:21 <oo_miguel> dmwit: thank you very much
13:42:53 <hyperisco> foojin, I just meant that jle` is too sophisticated to learn from my blunted advice
13:43:31 <foojin> hyperisco: Putting anything other than human language in string literals is blasphemy.
13:43:44 <hyperisco> I left out detail to make the point simpler and jle` poked out all the holes
13:44:36 <foojin> But then again only Lisps can let you have your structure and compile it away when it's known in advance.
13:45:36 <foojin> I cringe every time I have to write XPath when working with lxml in Python.
13:46:14 <hyperisco> foojin, that's what TH is for too
13:47:58 <hyperisco> I will say though that the desire to reduce syntax at least has the right spirit, if the wrong implementation
13:48:50 <hyperisco> reducing syntax is roughly the idea of throwing out irrelevant information, which is roughly the idea of designing a new language / eDSL
13:49:10 <hyperisco> you just want to start on top with the simple concepts, and the simple syntax will follow
13:49:13 <foojin> hyperisco: I don't have fond memories of working with it, trying to make simple lenses for a library that didn't have them. If I recall correctly, those TH bits from Lens ended up not being useful in my quest.
13:50:14 <foojin> I learned enough to generate simpler stuff however.
13:52:58 <hyperisco> If you wanted to use regexp in Haskell, TH is an ideal tool with which to do it. Just an example.
13:53:59 <foojin> hyperisco: I see it (DSL proliferation) as something that can be understood through a general principle of sorts when people confuse two kinds of "simple" things.
13:56:32 <hyperisco> A DSL is about inventing a new vocabulary in which to declaratively express a domain of ideas. This is in contrast to imperatively explaining those ideas in a different vocabulary.
13:57:31 <hyperisco> Then there are many ways in which the DSL can manifest. It can have its own compiler, or be an eDSL, or be more mundanely be recognised as a library.
14:00:26 <hyperisco> In my opinion and preference, this is a good mental model for all programming problems.
14:00:35 <dolio> I don't know if it's ideal. It might be the best GHC has to offer.
14:00:57 <foojin> hyperisco: Do you use the term to include certain patterns of writing code, like how some people claim that $ from JQuery is a monad? Otherwise I don't see a nice (not string literal-related) way of providing such a language in something like JS.
14:01:24 <hyperisco> foojin, which term particularly? DSL?
14:01:35 <foojin> hyperisco: Yes.
14:03:08 <hyperisco> As far as I am concerned, you graduate to a language when expressions become transparent objects
14:03:26 <foojin> hyperisco: I hope I've got the point across. The beginning of my previous message seems quite confusing to me now.
14:04:09 <hyperisco> Something which is a Monad may have some of that quality. By being a Monad there are necessarily some opaque parts (because of bind) but you can choose interesting things to be transparent/observable
14:04:14 <noumenon> hmm, is a game of snake where you can exit the left side and enter the right, and vice versa, and the same for top and bottom, equivalent to playing on a torus?
14:04:52 <foojin> noumenon: Seems like it.
14:05:17 <nitrix> Can I have a category where objects are a mixed bag of nullary functions and more regular functions?
14:06:49 <hyperisco> Maybe you'd say a Monad in this sense is like metaprogramming
14:07:19 --- mode: glguy set +v mho
14:07:26 <hyperisco> Simple example is monadic parsers. They represent a language of grammars but the Monad instance allows you to construct your grammar based on prior results
14:07:29 <ski> nitrix : by "nullary functions" you mean ?
14:07:55 <hyperisco> Like you could take well-typed macros to runtime, or something :)
14:08:01 <nitrix> ski: I'd like to have `f :: A` and `g :: A -> B`  both being objects.
14:08:21 <ski> @where applicative-vs-monadic
14:08:21 <lambdabot> "Applicative vs Monadic build systems" by ndm in 2014-07-23 at <https://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html>. (cf. "static sequencing" vs. "dynamic sequencing")
14:08:37 <hyperisco> Though another perspective is that the Monad instance lets you borrow the host language's features in your language without redeclaring them all
14:08:44 <nitrix> ski: Heck, even compose some of those to make more complicated objects, and then ponder what it means for morphisms.
14:08:49 <hyperisco> essentially then it can be seen as a compiler from the host language to your language
14:09:22 <hyperisco> well, maybe that's a bit too vague… anyways. gotta run :)
14:09:23 <ski> nitrix : `f :: A' can be represented by `f_ :: () -> A', via `f_ () = f', vs `f = f_ ()' (defining each in terms of the other, such that going one way and back amounts to the identity)
14:10:28 <foojin> hyperisco: I usually use the second one to reason about monads. The first one seems somewhat artificial to me, even though I know what you mean by your explanation of it.
14:10:30 <ski> here `()' would often be a terminal object in the category. or, at least, if the category is concrete over `Set', it'd be the free thing over a singleton set
14:10:43 <nitrix> ski: What are the morphisms between functions? Functors?
14:11:05 <nitrix> ski: I'm working with a concrete example in mind and somehow my understanding of CT is falling.
14:11:15 <ski> nitrix : hm, sorry, i missed the "being objects" part
14:11:23 <nitrix> ski: Yes! :)
14:12:00 <nitrix> ski: Have you ever worked with a node editor, from visual programming?
14:12:09 <ski> one idea for morphisms between functions (not function types), would be a way to rewrite one to become the other
14:12:32 <ski> nitrix : is that the same as a "structural editor" ?
14:13:13 <nitrix> ski: https://answers.unity.com/storage/temp/27622-unityforum2.jpg
14:13:25 <ski> (more generally than values or functions, you could take substitutions. and then rewritings between them as morphisms)
14:13:59 <ski> nitrix : oh, more a bit like LabVIEW, i suppose
14:14:02 <nitrix> ski: Usually you have two node types. One is just constant data, the other accepts data, has effects and potentially produces more data.
14:14:05 <nitrix> ski: Yeah exactly.
14:14:29 <nitrix> If I try to abstract a little, you have nodes of type `n :: A` and some of type `n :: A -> B`.
14:14:29 * ski say part of a video with someone manipulating something like in that pic, the other day
14:15:05 <ski> this makes be think of incremental/adaptive computation. and of forward-chaining (like RETE)
14:15:25 <nitrix> Now, if I pretend for a moment those are objects in CT, what the heck do the connections between those represent? Morphisms of course but I still don't understand their meaning, haha.
14:15:30 <ski> @where adaptive
14:15:30 <lambdabot> "Adaptive Functional Programming" by Umut Acar,Blelloch,Harper in 2002 (POPL) at <http://www.umut-acar.org/publications/popl2002.pdf> and in 2006 (TOPLAS) at <http://www.umut-acar.org/publications/
14:15:30 <lambdabot> toplas2006.pdf>
14:15:31 <ski> @where incremental
14:15:31 <lambdabot> "Monads for Incremental Computing" (Functional Pearl) by Magnus Carlsson in 2002 (ICFP) at <http://www.carlssonia.org/ogi/papers/icfp-2002.pdf>,<http://www.carlssonia.org/ogi/Adaptive/>,in Hackage
14:15:31 <lambdabot> at <http://hackage.haskell.org/package/Adaptive>
14:15:43 <nitrix> It's a relation for sure.
14:16:07 <nitrix> The connection shows composition.
14:16:22 <zachk> whats the preferred paste bin for haskell these days?
14:16:52 <nitrix> And you can collapse a very complicated graph like that into yet another node, whose inputs and outputs corresponds to what's free.
14:16:55 <ski> i'd say <lpaste.net>, but i'm not sure what's up with it recently ..
14:17:34 <zachk> lpaste seems to be down for me, at least, any good alternatives with haskell syntax highlighting?
14:17:58 <rain2> ski np!
14:18:09 <rain2> http://okmij.org/ftp/continuations/cc-monad.ml
14:18:15 <nitrix> ideone.com serves me well.
14:18:28 <ski> <someone:#somechannel> ski: Yeah, what happened to lpaste? All the good pastebins seem to be dying.
14:18:46 <ski> (also <paste.lisp.org> .. has there been a wake ?)
14:19:23 <rain2> this is where i found it
14:19:40 <nitrix> Probably not sustainable without the ads. And people using internal pastebin at their companies or slack/discord/hipchat/whatnot snippets.
14:19:49 <ski> rain2 : i noticed that link earlier, but haven't had time/energy to delve into it
14:20:00 <nitrix> Maybe we should start DCC-ing code to stay in the IRC spirit :P
14:20:45 <slack1256> (nitrix jokes but I am adding DCC capabilities to glirc2)
14:21:06 <nitrix> You're a visionary man (:
14:21:14 <ski> nitrix : well .. given a graph, there's a free category on it
14:21:21 <foojin> nitrix: These editor things look like a graph to me. There's probably a known way to view certain graphs as categories, although I'm not well-versed enough in CT to comment on that.
14:21:31 <ski> and collapsing corresponds to quotienting
14:21:48 <nitrix> Quotienting :O
14:22:07 <ski> i'd prefer a better word, not suggesting a relation to "quotient"
14:22:20 <ski> but i fear that if i said "factoring", people wouldn't know what i meant
14:22:42 <nitrix> You're fine. I knew I'd be able to find something interesting if I asked the right people c:
14:25:11 <ski> (i think that, etymologically, "quotient" is the wrong word to use. there's a difference between "multiplier" and "multiplicand", even if that difference doesn't always make a difference. see <https://en.wikipedia.org/wiki/Quotition_and_partition>. also factor ("quotient") groups)
14:25:28 <nitrix> I'm just confused a little. If these nodes are essentially the equivalent of haskell functions, the connection should be functors, but nothing that I know about functors resembles what that line between them does. It encodes what that function composes with.
14:25:46 <foojin> ski: Does it have something to do with how the analogue of quotient is defined w.r.t. graphs? I've read about that recently while trying to solve a particular problem.
14:25:55 <nitrix> Like, I can encode the entire program, as CT.
14:26:04 <nitrix> Which is why I'm interested.
14:26:06 <ski> nitrix : i'm not sure whether one needs some notion of "multi-arrow", with multiple sources, or not (in some graphs like your, that's what one wants)
14:26:39 <zachk> ok this code compiles just fine, but when I call counterNew I get ambiguous types https://ideone.com/oRsv7a how can I simply resolve that? I am trying to bind a function to a functional dependency of a multi parameter type class that is not fully specified at binding time, is that possible?
14:26:57 <MarcelineVQ> zachk: gist
14:27:15 <ski> nitrix : btw, let me check. the `f :: A' and `g :: A -> B' you were talking about would correspond to the boxen in the pic ? or to the arrows ?
14:27:41 <nitrix> ski: The boxes, though the picture is a bit misleading. Imagine that the far most boxes don't take inputs.
14:28:03 <ski> "far most" = "farthest to the right" ?
14:28:26 <Clint> a/win go #linguistics
14:28:29 * Clint sighs.
14:28:52 <nitrix> ski: To the left. Sorry, I'm so horrible at everything today.
14:29:03 * ski . o O ( wingo is in #scheme )
14:29:18 <rain2> i wonder how multi prompt continuations relate to algebraic effects
14:29:34 <nitrix> https://docs.blender.org/manual/nb/dev/_images/editors_node-editor_nodes_frame_example.png
14:29:45 * ski never got around to really grokking multi prompt
14:29:48 <MarcelineVQ> to answer your earlier question
14:29:56 <nitrix> This is where it gets interesting because those nodes can just be containers for yet more nodes.
14:29:58 <slack1256> Will Debug.Trace.trace be memoized if compiled with -O? If so how do I avoid that?
14:30:08 <rain2> they seem to be strongly related to dynamic binding
14:30:29 <ski> rain2 : dynamic binding, in which sense ?
14:30:33 <argent0> Hi, is it possible to index types with a Float?
14:30:50 <argent0> data Foo :: Float -> * where ...
14:30:50 <rain2> the dynamic scope variables
14:30:52 <geekosaur> slack1256, it shudl be as memoized as the traced expression, thus still showing you what actually happens
14:31:20 <geekosaur> fi you were xepcting to use it for anything other than debuggig when an expression is evaluated, you might rethink; it is never reliable for that
14:31:37 <slack1256> I just want to debug with it :-).
14:31:40 * ski was thinking of dynamic reloading of the behaviour of nodes (or else dynamic update of the "input nodes" on the left, with propagation through the network)
14:32:11 <slack1256> So you are saying the side-effects should ocurr anytime this pure function is called? (I trace a pure function)
14:32:17 <geekosaur> slack1256, it does not and should not change strictness
14:32:18 <slack1256> But I see the effects just once.
14:32:52 <geekosaur> it shows you when the traced expression is evaluated, which will be affected by optimization. it does not and will not show you when the resutl is used
14:32:58 <geekosaur> even without optmization
14:32:58 --- mode: glguy set +v _kwstas
14:33:25 <ski> MarcelineVQ, ?
14:33:32 --- mode: glguy set -v _kwstas
14:33:32 <ski> nitrix : hmm
14:34:16 <Zemyla> You know, I figured out how to turn Set into a Monad in such a way that it's still Foldable and Traversable.
14:34:33 <slack1256> I see
14:34:42 --- mode: glguy set +v boxscape
14:35:01 <ski> nitrix : "If these nodes are essentially the equivalent of haskell functions, the connection should be functors" -- i think it's possibly better to think here of the lines ("arrows") between the boxes as the objects (or perhaps rather instances of objects, in a diagram), and the boxes themselves as morphisms
14:36:17 <ski> nitrix : then there's implicit products of objects in the pic, introduced by juxtaposing (above and below) objects (lines). and we're using that products have a monoidal structure, and also that they're functors, to be able to juxtapose boxes (above and below each other)
14:37:02 <Zemyla> @let cartesianProduct sa sb = S.fromDistinctAscList $ liftA2 (,) (toList sa) (toList sb)
14:37:03 <lambdabot>  .L.hs:223:41: error:
14:37:03 <lambdabot>      Ambiguous occurrence ‘toList’
14:37:03 <lambdabot>      It could refer to either ‘F.toList’,
14:37:04 <nitrix> (Their position doesn't matter btw, it's all about what's connected where).
14:37:25 <nitrix> ski: This is huge. You're right, the lines should be objects and boxes should be morphisms. How weird.
14:37:27 <ski> nitrix : i think similar diagrams have been used in other contexts (perhaps related to Feynman diagrams ?). iirc one of the Catsters movies used them for monads
14:37:47 <nitrix> ski: It's weird because now I'm really questioning what those objects ARE. The morphisms are clear.
14:38:07 <ski> (possibly also the "Rosetta stone" paper by Baez, &al. used them ?)
14:38:12 <Zemyla> @let cartesianProduct sa sb = S.fromDistinctAscList $ foldr (\a r -> foldr ((:) . (,) a) r sb) [] sa
14:38:12 <nitrix> They are typed, but they encode a lot more information than just type :/
14:38:14 <lambdabot>  Defined.
14:39:09 <nitrix> ski: Thank you. Just this will be enough to throw me in a completely different direction.
14:39:17 <ski> nitrix : typed nodes in a diagram category, or somesuch, perhaps
14:39:17 <nitrix> ski: I'll try to work it out. I appreciate!
14:39:21 <Zemyla> @let disjointSum sa sb = S.fromDistinctAscList $ foldr ((:) . Left) (foldr ((:) . Right) [] sb) sa
14:39:22 <lambdabot>  Defined.
14:39:38 <ski> nitrix : happy to be able to offer some useful advice
14:40:29 <ski> Zemyla : i vaguely remember something like that. any reference, perhaps ?
14:40:32 <Zemyla> @let data SetM a where { SetM :: (u -> a) -> !(S.Set u) -> SetM a }
14:40:34 <lambdabot>  Defined.
14:41:21 <Zemyla> @let instance Functor SetM where { fmap f (SetM g s) = SetM (f . g) s; a <$ SetM _ s = SetM (const a) s }
14:41:23 <lambdabot>  Defined.
14:42:13 * ski . o O ( `Coyoneda Set' )
14:42:53 <Zemyla> @let instance Applicative SetM where { pure a = SetM (const a) (S.singleton ()); liftA2 f (SetM ga sa) (SetM gb sb) = SetM (\(a, b) -> f (ga a) (gb b)) (cartesianProduct sa sb) }
14:42:54 <lambdabot>  Defined.
14:43:51 <Zemyla> @let instance Alternative SetM where { empty = SetM absurd S.empty; SetM ga sa <|> SetM gb sb = SetM (either ga gb) (disjointSum sa sb) }
14:43:54 <lambdabot>  Defined.
14:45:00 <Zemyla> @let instance Foldable SetM where { foldMap f (SetM g s) = foldMap (f . g) s; null (SetM _ s) = S.null s; length (SetM _ s) = S.size s }
14:45:02 <lambdabot>  Defined.
14:45:45 <Zemyla> @let instance Monoid (SetM a) where { mempty = empty; mappend = (<|>) }
14:45:48 <lambdabot>  Defined.
14:46:26 <ski> Zemyla : hm, will you need `Ord u' ?
14:46:59 <Zemyla> @let instance Monad SetM where { return = pure; (>>) = (*>); SetM g s >>= f = foldMap (f . g) s; fail = const empty }
14:47:02 <lambdabot>  Defined.
14:47:30 <Zemyla> ski: Only to unwrap it.
14:47:41 <Zemyla> @let toSetM = SetM id
14:47:43 <lambdabot>  Defined.
14:47:57 <Zemyla> @let fromSetM (SetM g s) = S.map g s
14:47:59 <electrocat> w
14:47:59 <lambdabot>  Defined.
14:48:11 <ski> @type toSetM
14:48:12 <Zemyla> @let instance MonadPlus SetM
14:48:12 <lambdabot> S.Set a -> SetM a
14:48:13 <ski> @type fromSetM
14:48:14 <lambdabot>  Defined.
14:48:16 <lambdabot> Ord a => SetM a -> S.Set a
14:48:51 <ski> @type S.map  -- `Ord' on the codomain, i see
14:48:52 <lambdabot> Ord b => (a -> b) -> S.Set a -> S.Set b
14:49:19 <Zemyla> Honestly, the Applicative and Alternative methods could be optimized by checking for 0 or 1 elements.
14:49:27 <dmwit> (The price: you could get lots of duplicates, so you will occasionally want to `toSetM . fromSetM` to eliminate them.)
14:50:24 <Zemyla> @let class Functor f => Orderable f where order :: Ord a => f a -> f a
14:50:27 <lambdabot>  Defined.
14:50:52 <Zemyla> @let instance Orderable SetM where order = toSetM . fromSetM
14:50:54 <lambdabot>  Defined.
14:51:42 <Zemyla> @let instance (Orderable m, Ord e) => Orderable (EitherT e m) where order = mapEitherT order
14:51:43 <lambdabot>  .L.hs:262:45: error:
14:51:43 <lambdabot>      Not in scope: type constructor or class ‘EitherT’
14:51:43 <lambdabot>      Perhaps you meant ‘Either’ (imported from Data.Either)
14:52:05 <Zemyla> Oh, it's ExceptT.
14:52:38 <dmwit> Zemyla: See also http://okmij.org/ftp/Haskell/set-monad.html
14:52:47 <Zemyla> @let instance (Orderable m, Ord e) => Orderable (ExceptT m e) where order = mapExceptT order
14:52:48 <lambdabot>  .L.hs:262:53: error:
14:52:48 <lambdabot>      • Expecting one more argument to ‘m’
14:52:48 <lambdabot>        Expected a type, but ‘m’ has kind ‘* -> *’
14:53:19 <Zemyla> dmwit: I saw. The Codensity approach has disadvantages compared to this one.
15:10:09 <supersaiyan> how does one write a function, to apply map to a list of functions, for example, function [reverse, take2] "candy" returns, "ydanc" and "ta" ?
15:10:27 <supersaiyan> "ca"
15:11:27 <jle`> supersaiyan: you can just map application
15:11:38 <jle`> > map (\f -> f "candy") [reverse, take 2]
15:11:41 <lambdabot>  ["ydnac","ca"]
15:12:16 <supersaiyan> jle`: what if the input isn't candy though ? what if it could be anything ?
15:12:17 <Twey> > let func = map . flip id in func [reverse, take 2] "candy"
15:12:19 <lambdabot>  error:
15:12:19 <lambdabot>      • Couldn't match type ‘Char’ with ‘[[a0] -> [a0]] -> b’
15:12:19 <lambdabot>        Expected type: [[[a0] -> [a0]] -> b]
15:12:23 <jle`> supersaiyan: take it as a parameter
15:12:39 <jle`> @let mapAp candy = map (\f -> f candy) [reverse, take 2]
15:12:41 <lambdabot>  Defined.
15:12:45 <jle`> > mapAp "candy"
15:12:47 <lambdabot>  ["ydnac","ca"]
15:12:55 <jle`> > mapAp "vegetable"
15:12:58 <lambdabot>  ["elbategev","ve"]
15:13:19 <supersaiyan> jle` , instead of just reverse take 2, how can you use Map to map to any function? like more than reverse and take 2
15:13:21 <jle`> supersaiyan: in general the rule is, if you want to paramaterize something over something, you can pull it out as a function parameter/argument
15:13:37 <jle`> supersaiyan: so instead of hard-coding [reverse, take 2],try taking it as a parameter instead
15:13:47 <jle`> the process is pretty similar to what i did with candy
15:13:59 <jle`> do you see how instead of typing in "candy" directly, i pulled it out as a parameter?
15:14:18 <supersaiyan>  map (\f -> f* something ?)
15:14:33 <jle`> instead of theThing = map (\f -> f "candy") [...]
15:14:42 <jle`> i wrote theThing myString = map (\f -> f theString) [...]
15:14:56 <jle`> instead of writing "candy" directly, i took it out as a parameter
15:15:00 <jle`> *myString, not theString
15:15:14 <supersaiyan> oooooo
15:15:18 <supersaiyan> im starting to see it
15:17:28 <supersaiyan> jle` thank you so much, i got it
15:17:47 <jle`> no problem :)
15:18:08 <jle`> some tricks people often do also for this is that you can section ($)
15:18:15 <jle`> > map ($ "candy") [reverse, take 2]
15:18:17 <lambdabot>  ["ydnac","ca"]
15:18:25 <jle`> since ($) is function application, and you're basically mapping function application
15:19:05 <jle`> and also if you're familiar with the Applicative instance for lists (and the Applicative abstarction), you can also use it here:
15:19:12 <jle`> > [rerse, take 2] <**> ["candy"]
15:19:15 <lambdabot>  error:
15:19:15 <lambdabot>      • Variable not in scope: rerse :: [a0] -> [a0]
15:19:15 <lambdabot>      • Perhaps you meant ‘reuse’ (imported from Control.Lens)error:
15:19:20 <jle`> > [reverse, take 2] <**> ["candy"]
15:19:22 <lambdabot>  error:
15:19:22 <lambdabot>      • Couldn't match expected type ‘([a0] -> [a0]) -> b’
15:19:22 <lambdabot>                    with actual type ‘[Char]’
15:19:27 <jle`> > [reverse, take 2] <*> ["candy"]
15:19:29 <lambdabot>  ["ydnac","ca"]
15:19:59 <jle`> you can also leverage the Traversable instance for lists too, if you're familiar with Traversable
15:20:08 <supersaiyan> jle` , im a very haskell beginner haha... that is very complex to me.
15:20:10 <jle`> > sequence [reverse, take 2] "candy"
15:20:12 <lambdabot>  ["ydnac","ca"]
15:20:23 <jle`> ah yeah ok, then mapping application is fine too :)
15:20:44 <jle`> just saying that there are a lot of ways using list's API to do something similar, but mapping application is the simplest way
15:23:54 <supersaiyan> jle` thanks , ill keep that in mind haha
15:27:30 <beka> what's the preferred way to make haskell libraries? raw cabal? or is stack good too? or..?
15:27:40 <jle`> either is ok
15:28:01 <beka> ok cool
15:28:04 <jle`> note that cabal-install and stack are more like parallel branches from a tree
15:28:24 <jle`> stack isn't quite 'cabal plus more'
15:28:54 <jle`> cabal-install and stack both provide different ways of initializing and developing haskell projects :)
15:28:59 <jle`> neither is built on top of the other
15:29:11 <beka> well, i know stack does sometimes use parts of cabal?
15:29:23 <jle`> both stack and cabal-install use the Cabal library
15:29:41 <beka> but anyway, im just thinking more like.. if im going to put something on hackage, what's the preferred mechanism for creating the package
15:29:54 <jle`> but as executable tools, neither is built on top of the other
15:30:01 <jle`> hackage is agnostic to stack and cabal-install
15:30:16 <beka> ok cool. so i can just pick what works best for me when developing this and it'll be fine
15:30:22 <jle`> mhm, yes
15:30:23 <beka> awesome <3
15:31:03 <Zemyla> @let instance Traversable SetM where traverse f (SetM g s) = fmap (SetM snd . S.fromDistinctAscList) $ S.foldr (\a r n -> seq n $ liftA2 ((:) . (,) n) (f $ g a) $ r $ n + 1) (const $ pure []) s (0::Word)
15:31:05 <lambdabot>  Defined.
15:41:39 <jle`> Zemyla: you get all these instances for free withFree
15:42:03 <jle`> but they are admittedly less performant
15:42:49 <jle`> oh actually no, you don't get Alterantive/MonadPlus instances
15:46:43 <foojin> After reading https://stackoverflow.com/questions/10753073/whats-the-theoretical-basis-for-existential-types I have a few questions about existential types.
15:46:51 <foojin> First of all, how typeclass constraints correspond to variables bound by quantifiers (after recasting a type as a proposition)? I think of them as "labels" that are attached only to those types that satisfy the constraint.
15:49:32 <jle`> you can reframe typeclass constraints as explicit parameters
15:49:44 <jle`> by thinking about them as dictionaries
15:49:57 <c_wraith> foojin, that's one viewpoint. it's not wrong, but it isn't always the full story.
15:50:19 <jle`> instead of `blahblah :: Show a => a -> String`, you can think of think of it as `blahblah :: ShowDict a -> a -> String`
15:50:32 <jle`> where data ShowDict a = ShowDict { show :: a -> String }
15:50:39 <jle`> a dictionary that contains all of the class methods
15:51:07 <jle`> in this sense the existential type data S where S :: Show a => a -> S, can be thought of as data S where S :: ShowDict a -> a -> s
15:51:12 <jle`> * ShowDict a -> a -> S
15:51:32 <foojin> My interpretation seems to suggest that a certain tag is passed that the function used to obtain the correct compiled implementation.
15:51:41 <foojin> *a function uses
15:52:11 <jle`> here it is not a tag, but rather explicitly the methods/implementaitons themselves
15:54:40 <sssilver> hi, any haskell beginners here?
15:55:06 <foojin> I see. Seeing as it's more or less an implementation detail (where to put the dictionary), it doesn't look like  I'not missing anything if I view them like this, do I?
15:55:26 <foojin> *it doesn't look like I'm missing anything, do I?
15:57:08 <jle`> sssilver: a lot of us :)
15:58:04 <jle`> foojin: i think it's a part of the formalization of system f + typeclasses, but i'm not totally sure
16:00:04 <foojin> Regarding the (∀x. Q(x) ⇒ P)  =  (∃x. Q(x)) ⇒ P from that answer: shouldn't there be a condition that x is not free in P? If yes, how does that map to types and Haskell? Is it about disallowing a return type to be an instance of a certain typeclass?
16:12:22 <zachk> ok, how come I cant return a generalized typeclass function from a function? 
16:13:11 <jle`> what do you mean zachk ?
16:13:21 <jle`> it should be possible:
16:13:28 <jle`> :t foo = (2+)
16:13:29 <lambdabot> error:
16:13:29 <lambdabot>     parse error on input ‘=’
16:13:29 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
16:13:33 <jle`> :t (2+)
16:13:34 <lambdabot> Num a => a -> a
16:13:58 <jle`> @let addToInt n = (+) (fromInteger n)
16:14:00 <lambdabot>  Defined.
16:14:04 <jle`> :t addToInt
16:14:06 <lambdabot> Num a => Integer -> a -> a
16:14:19 <rain2> https://en.wikipedia.org/wiki/Lambda-mu_calculus this is pretty interesting, i  wonder if there's something like it but for shift/reset instead of call/cc
16:16:25 <zachk> im using return inside an (IO) monad 
16:16:41 <zachk> its specializing (+) to Integer -> Integer -> Integer
16:17:03 <zachk> and I was trying to do an OO system with a multiparameter typeclass earlier and was getting crazy ambiguous types
16:20:05 <jle`> zachk: can you show some examples
16:20:36 <jle`> be aware of the monomorphism restriction, but still, adding explicit type signatures should always cancel out the DMR
16:20:48 <zachk> {-# language FunctionalDependencies #-}
16:20:48 <zachk> {-# language FlexibleInstances #-}
16:20:48 <zachk> {-# language FlexibleContexts #-}
16:21:01 <zachk> newPlopper :: (Monad m,Num a) => m (a -> a -> a)
16:21:02 <jle`> don't paste the code in chat heh
16:21:02 <zachk> newPlopper = do 
16:21:02 <zachk> 	return (+)
16:21:06 <zachk> -_-
16:21:11 <zachk> thats it
16:21:26 <jle`> there you go then, you are returning a polymorphic function :)
16:21:44 <jle`> does it not do what you expect?
16:23:59 * hexagoxel .oO no, it needs more RankNTypes to return a polymorphic function
16:24:30 <jle`> @let newPlopper = return (+)
16:24:32 <lambdabot>  Defined.
16:24:51 <jle`> > map (\plus -> plus 3 9) newPlopper
16:24:53 <lambdabot>  [12]
16:24:57 <jle`> > map (\plus -> plus 3.0 9.0) newPlopper
16:24:59 <lambdabot>  [12.0]
16:25:21 <jle`> > map (\plus -> plus (1:+3) (4:+2)) newPlopper
16:25:24 <lambdabot>  [5.0 :+ 5.0]
16:25:39 <hexagoxel> yeah, the action is polymorphic. the returned value is monomorph.
16:25:44 <jle`> fair
16:26:19 <supersaiyan> :r
16:27:01 <hexagoxel> Ok, channels loaded: #haskell
16:27:25 <zachk> jle how come yours is polymorphic? 
16:27:33 <zachk> wait
16:27:42 <hexagoxel> zachk: so you might want newPlopper (Monad m) => m (forall a . Num a => a -> a -> a)
16:27:56 <jle`> the above is not possible without impredicative types
16:28:16 <jle`> but really we really need to know more about the problem to find a good solution
16:28:19 <zachk> what are impredicative types?
16:28:23 <hexagoxel> yeh, might need a newtype wrapper. might become ugly :/
16:28:46 <jle`> rank-n types as parameters to type constructors.  but it's probably not what you want here
16:28:47 <zachk> i was just seeing what happens when I return an "overloaded" function from inside another function
16:28:51 <jle`> and it's also broken in ghc
16:29:04 <jle`> zachk: can you show a situation where what you're already doing doesn't work?
16:29:13 <supersaiyan> :r
16:29:22 <supersaiyan> sorry
16:30:41 <zachk> https://ideone.com/Wu1waC
16:31:00 <zachk> counterNew gives me ambiguous types, even with the uncommneted code put back in 
16:31:09 <zachk> it loads fine in ghci
16:31:21 <jle`> what about with the type signature?
16:31:25 <zachk> but when I call counterNew with valid input i get a slew of ambiguous types
16:31:30 <jle`> it might be a DMR thing, since the MonomorphismRestriction is turned off in ghci
16:31:33 <jle`> but is on normally
16:31:35 <jle`> @where DMR
16:31:36 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
16:31:54 <zachk> i had put one in before but it was still doing the same thing
16:32:02 <zachk> the inferred type looks correct
16:32:11 <jle`> what is the ambiguous type warning?
16:32:17 <jle`> *error
16:32:49 <supersaiyan> map (\x -> x ys) filter(\f -> f==x)  ( zip ys [1..]))  ---  how would i modify my code to give me indices of a word? for example , something 'c' calculator returns [1,4] ?
16:33:21 <zachk> jle`, here's the error in ghci https://ideone.com/rCnB8C 
16:33:23 <zachk> brb
16:43:21 <zachk> i shut the monomorphism off in my source code and ghci and plus from newPlopper still specialiazes to Integer -> Integer -> Integer
16:52:04 --- mode: glguy set +v jackdk
16:52:04 --- mode: glguy set -v jackdk
17:02:17 <supersaiyan> anyone know whats wrong with this syntax error? filter(\(f,ys) -> f==x) ( zip ys [1..]))
17:03:06 <supersaiyan> aww nevermind figured it out
17:03:09 <MarcelineVQ> which error?
17:03:57 <supersaiyan> MarcelineVQ, i had that variable defined elsewhere in my haskell code
17:04:17 <hpc> are you sure it's not the extra paren?
17:04:21 <MarcelineVQ> I ​mean you're asking about an error but didn't show an error :>
17:14:39 <oo_miguel> hmm what am I doing wrong again: http://paste.debian.net/1048572/ Why does haskell not garbage collect the old values from the Map, when I reinsert new ones?
17:17:18 <oo_miguel> should I manually force evaluation?
17:17:51 <MarcelineVQ> oo_miguel: have you seen https://wiki.haskell.org/Foldr_Foldl_Foldl' ?
17:18:38 <oo_miguel> MarcelineVQ: yeah, but some time ago. I will reread it, thanks
17:23:43 --- mode: glguy set +v sdfsdfdffbr
17:24:03 --- mode: glguy set +v stphrolland
17:25:11 <sdfsdfdffbr> hi! a little question about Haskelll/GHC: I want to issue a warning at compilation with custom message. Is it possible ?
17:29:01 <jle`> zachk: how are you checking the type of newPlopper?
17:29:16 <jle`> zachk: oh ah, just saw the ghci session
17:29:32 <jle`> yes, using counterNew requires you to pick all of your type variables
17:29:38 <zachk> I gave it a type signature and it still specialiazes
17:29:55 <jle`> newPlopper is polymorphic, but when you *use* it, you must pick all the type variables
17:29:58 <zachk> jle`, is there no way around the counterNew with me having to pick all my type variables?
17:30:52 <sdfsdfdffbr> I found what I wanted: {-# WARNING unsafePerformIO "This is unsafe; I hope you know what you're doing" #-}, and any function can be attached a warning
17:30:55 <jle`> it depends on what you want to do after
17:31:16 <jle`> zachk: what do you eventually want to do with the result?
17:31:22 <jle`> do you have a speicifc type you want to use it with?
17:31:54 <zachk> I want to use it as an "object" that takes a message and returns a function the operates on its internal state
17:32:28 <zachk> I also want to be able to use the same object message type for different methods on different objects
17:33:31 <clever> dang, didnt get to mention accursedUnutterablePerformIO to sdfsdfdffbr, lol
17:33:53 <slack1256> oo_miguel: https://paste.debian.net/1048573/
17:35:10 <slack1256> Two things: foldr is worse than foldl' if you aren't lazy on the second argument of your function. Your func function has to force the value inserted on the tree for it to mark the old values as garbage.
17:35:18 <zachk> alright thank you for your help, jle` , and good night
17:35:52 <slack1256> Also, is lpaste the preferred pastebin on #haskell?
17:39:45 <hpc> the topic indicates gists are preferred now
17:41:27 <oo_miguel> slack1256: wow thank you, this does the trick.. 
17:43:51 <stphrolland> :q
17:43:53 <jle`> st
17:43:54 <jle`> git add .
17:43:55 <stphrolland> :q
17:44:05 <jle`> sorry :)
17:58:33 <Zipheir> Maybe recommending a pastebin that doesn't require an account on a service would be a good idea.
18:05:00 <MarcelineVQ> If there's something else as full featured out there I'm sure it'd be a welcome suggestion
18:12:12 --- mode: glguy set +v OddDuck
18:13:44 * slack1256 thinks linear arrows inside HOF are confussing.
18:19:47 <MarcelineVQ> slack1256: continue the thought
18:29:08 <AfC> Can someone point me where I might learn abut the cost of allocating closures (ie, the allocation or runtime cost of making *lots* of lambda functions and passing them around)?
18:31:24 <AfC> (I'm always a bit weirded out by the idea of constructing functions on the fly, even though I totally get passing functions as first class values around and that creating functions at runtime has been a fundamental capability of Haskell since the earliest days)
18:32:41 <c_wraith> AfC, what's there to know? it's just another heap object. pointers to the values it closes over, a pointer to the object code, the stg overhead.
18:35:20 <AfC> c_wraith: that's encouraging.
18:36:07 <AfC> Is there a greater overhead than say just using an existing data constructor over and over? [clearly I need to read the book about GHC internals at some point]
18:36:58 <c_wraith> no.
18:37:41 <AfC> Wow. That's very cool (or using constructors is already so expensive that using anonymous created-on-the-fly functions is no more so)
18:37:55 <c_wraith> allocation is fast in ghc
18:38:05 <c_wraith> just a pointer bump
18:38:10 * AfC waves hi to everyone, btw Been ... years? since I've logged into #haskell
18:38:45 <c_wraith> (of course, you need to initialize the memory next, which takes somewhat more work, but most values are small)
18:39:04 <c_wraith> Haskell code tends to fit the generational hypothesis well.
18:39:32 <c_wraith> so few objects live long enough to need to be copied out on the next garbage collection.
18:40:15 <c_wraith> the nice thing about ghc's garbage collection is that collecting unused nursery generation objects is basically free.
18:40:57 <Solonarv_> found the wiki page: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects @AfC
18:41:09 <Solonarv_> I believe this is what you're looking for
18:41:14 <AfC> Solonarv_: thanks!
18:41:49 <supersaiyan> "(something [5,3,1,4]) should
18:41:49 <supersaiyan>  return "***** *** * **** " how would i do that in haskell?
18:42:15 <slack1256> @type replicate
18:42:17 <lambdabot> Int -> a -> [a]
18:42:24 <slack1256> > replicate 3 '*'
18:42:26 <lambdabot>  "***"
18:42:30 <slack1256> start there
18:42:39 <supersaiyan> thanks slack1256 :)
18:42:44 <Solonarv_> another useful function: words
18:42:54 <Solonarv_> er, unwords
18:42:57 <slack1256> heh STARt, heh get it? english is fun
18:43:09 <Solonarv_> > unwords ["hello", "there"]
18:43:12 <lambdabot>  "hello there"
18:50:53 <nshepperd_> huh, lpaste is not even up now?
19:06:08 <supersaiyan> how do you take each individual integer from list of integers ?
19:06:29 <slack1256> supersaiyan: read about pattern matching lists
19:06:42 <supersaiyan> thanks slack1256
19:06:53 <slack1256> https://en.wikibooks.org/wiki/Haskell/Pattern_matching
19:07:05 <slack1256> In particular the map example.
19:07:53 <dmj`> supersaiyan: do you mean, how do you group a list of integers?
19:08:45 <supersaiyan> dmj`, no, so I have a list of integers, and i want to take each one individually from it... to make a histogram
19:09:28 <supersaiyan> right now i have g :: [Integer] -> String
19:10:16 <slack1256> supersaiyan: Remember, [] lists have two cases: you either have a (x:xs) or you reached the last element []. Do a case analysis and a bit of recursion
19:11:08 <supersaiyan> thanks slack1256
19:11:40 <julianleviston> slack1256: is there a chance teaching basic recursion when he might actually be searching for how to do something imperatively where he might need to be shown expression-driven programming instead might cause pain?
19:12:30 <slack1256> Knowing how to do stuff recursively is useful in anycase.
19:13:26 <dmj`> supersaiyan: Data.Map.fromListWith (+) is what you want.
19:14:06 <supersaiyan> thanks dmj`, appreciate the help.
19:22:31 <dmj`> > (\xs -> Data.Map.toList $ Data.Map.fromListWith (+) (zip xs (repeat 1))) [3,3,4,4]
19:22:33 <lambdabot>  [(3,2),(4,2)]
19:22:39 <dmj`> supersaiyan: ^
19:22:42 <julianleviston> slack1256: I agree — I wasn’t trying to disparage you helping… 
19:23:46 <slack1256> I didn't take it wrong :-)
19:25:15 --- mode: glguy set +v fen
19:26:27 <fen> how can datatypes imported from prelude be imported hiding particular instances, specifically list.
19:26:42 <geekosaur> you can't hide instances
19:26:53 <stevie> playing with haskell. Why do I need to say sqrt(fromIntegral num9) and cannot say sqrt fromIntegral num9
19:27:08 <stevie> Not that I would want to, but why can I do that with fromIntegral and mod
19:27:21 <fen> use $
19:28:32 <geekosaur> aplication has highest precedence, so sqrt fromIntegral ... is giving sqrt fromIntegral as parameter
19:28:41 <geekosaur> remember that functions are values
19:29:30 <geekosaur> I don'rt understand your comment abut mod, unless you are confusing infix application `foo` with this
19:29:31 <fen> geekosaur: can list be redefined in another module using the same syntax? for use with import prelude hiding list and no implicit prelude?
19:29:49 <geekosaur> lists in particular are special, you can't reuse the syntax
19:30:16 <stevie> geekosaur, thanks I see what you mean now
19:30:19 <geekosaur> you can define one with your own Nil and Cons but you can't reuse (:) easily, the compiler has to know about list syntax
19:30:50 <fen> so instances for list cant be rewritten without a major refactor of all code that uses that syntax?
19:30:54 <geekosaur> there is RebindableSyntax which might let you replace it, bt it's problematic with lists\
19:30:56 <geekosaur> iirc
19:31:41 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=overloadedlists#extension-OverloadedLists
19:31:44 <geekosaur> there is also OverloadedLists which lets you use list syntax with arbitrary types (by converting them to lists on the fly, so probably you dont really want this)
19:32:04 <geekosaur> unless you have provided ways to avoid constantly converting to and from lists
19:32:42 <fen> that sounds expensive 
19:33:53 <fen> whats the problem with using RebindableSyntax for lists?
19:37:02 <AfC> OverloadedLists is just for literals in your code. Once you've converted that into your type you're not dealing with cons lists any more. You don't have *that* many items in your source code file, do you?
19:37:51 <AfC> [It's been pretty awesome for a thing we've been working on here, but as ever in Haskell land if you step off the beaten path too far the error messages get a bit awkward]
19:37:51 <fen> that does not sound like redefining a list instance
19:38:45 <geekosaur> actually it looks like they resolved the issues by making it work with OverloadedLists. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#id36 https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-RebindableSyntax
19:38:57 <glguy> fen: the problem with using RebindableSyntax for lists is that doesn't have anything to do with list syntax
19:39:14 <glguy> That's what OverloadedLists is for
19:39:36 <fen> seems that was for anything list-like except lists
19:40:06 <glguy> it would let you redefine what class the syntax goes through, but would still do the same thing at the end of the day
19:40:14 <glguy> via OverloadedLists
19:40:14 <geekosaur> basically, the list stuff is all hardwired intot he comiler and can't be ovrrideen or replaced easily. but you can use OverloadedLists
19:40:48 <geekosaur> you get to hack on ghc source if you *really* want to change what a list is. and t will teach you why it is that way
19:41:25 <geekosaur> (that, or make you run away screaming)
19:42:10 <fen> so, the only way is to change ghc source. 
19:42:27 <nshepperd_> "Illegal binding of built-in syntax: :" -- what happens when you try to redefine : and []
19:42:29 <glguy> To do what?
19:42:36 <nshepperd_> disappointment.
19:42:58 <geekosaur> could you explain what problem you are trying to solve? there may be better approaches
19:43:17 <fen> possibly 
19:43:40 <fen> but it is simply to redefine an instance
19:43:53 <geekosaur> list syntax actually breaks a bunch of rules, which makes it difficult to redefine or override them.
19:44:00 <fen> and it seems there are no other alternatives 
19:44:16 <glguy> List syntax isn't related to instances in particular
19:44:28 <geekosaur> and overriding instances in general tends to be a bad plan because you can't do so locally and so can break a lot of code that isn't expecting it
19:44:35 <fen> ok, no need to redefine list, just need to get at the instances
19:45:25 <fen> after testing with a synonym so ghc doesnt explode 
19:45:35 <Sheilong> What am I doing wrong  https://www.irccloud.com/pastebin/CLIeYuyF/
19:45:55 <dmwit> fen: newtype is the standard way to make a new type with different instances but the same in-memory representation.
19:46:19 <dmwit> Sheilong: Using (/) instead of div, probably.
19:46:51 <fen> dmwit: that wont affect the existing occurences of list, so isnt an option
19:47:34 <dmwit> fen: Correct. You cannot affect any existing occurrences of values of any type, list or otherwise. That is the meaning of immutability.
19:47:54 <glguy> fen: You'll probably just need a new approach. What you're asking about isn't an option so far. What are you trying to do?
19:47:59 <fen> not at runtime! the occurences in the code
19:48:21 <fen> glguy: alter an instance of list
19:48:28 <glguy> at a higher level than that
19:48:31 <glguy> that's not one of your options
19:48:43 <fen> why?
19:49:34 <Sheilong> dmwit: thanks
19:51:30 <fen> glguy: it was surgested above as an option by geekosaur with "run away screaming" as an additional comment 
19:51:38 <geekosaur> uh
19:51:55 <geekosaur> next tme I wil try to be more explixcit abut "this is nto a sensible option"
19:52:03 <fen> [03:40] <geekosaur> you get to hack on ghc source if you *really* want to change what a list is.
19:52:05 <geekosaur> hacking the compoiler to do something is rarelyt he right route
19:52:27 <fen> apparently this is such a time
19:52:31 <geekosaur> btu apparently you want to do this so very badly that obviously really bad ideas are good ideas
19:52:49 <fen> if thats the nesacary condition 
19:54:22 <fen> other than suggesting testing the alternative implementation sufficiently to avoid any errors it could cause, there isnt much else that would could be reasuring
19:55:08 <apostolis> hello, I am trying to use the module Data.List.Split but GHC fails to find it. Is there a reason?
19:55:42 <glguy> apostolis: You'll need to add the dependency on the split package to your .cabal file
19:57:15 <fen> so, having given sufficient warnings to desuade the unwary reader, how can this be done?
19:57:43 <apostolis> @glguy : After I did , it did find it but there were some strange errors, like the 'Maybe' and 'String' data constructor were missing even though I had Data.Maybe Data.String.
19:57:43 <lambdabot> Unknown command, try @list
19:58:47 <glguy> apostolis: OK. If you need help understanding error messages you can put the code that generates them and the compiler output on a pastebin service list gist.github.com and we can help you with it!
20:00:23 <fen> a google search for "how to hack GHC" gives; https://github.com/ghc/ghc/blob/master/HACKING.md
20:00:38 <glguy> fen: It's not a serious option. The point is that it's a program that you could change to do what you had in mind. There's no setting in the source code to change; you'd just have change GHC to be a different program that does what you have in mind.
20:00:46 <fen> is says that #ghc might be a better place to get the relavent help...
20:01:42 <fen> maybe with some build tools to hand to quickly add the desired hack to ghc releases as they appear
20:02:03 <apostolis> @glguy : It was just a stupid mistake by me that produced strage errors that confused me.
20:02:03 <lambdabot> Unknown command, try @list
20:02:12 <apostolis> thanks.
20:02:37 <heptahedron> Hello! Would anyone happen to know of any good resources for using Megaparsec to parse messages sent over TCP?
20:02:54 <fen> its just an instance for list after all, not that much code
20:03:35 <heptahedron> I can hack something together that threads the parse state through invocations to `recv` but I didn't know if there was a cleaner ready-made solution available.
20:03:36 <glguy> heptahedron: Binary protocols are better parsed  by libraries like attoparsec, have you tried that one?
20:03:44 <fen> and actually, it would allow access to the class that the instance is of aswell, so it might be a good option
20:05:06 <heptahedron> glguy: They're actually quite comparable in that area if you look at this: https://github.com/mrkkrp/megaparsec#performance
20:05:32 <exio4> it's not about performance but the tools available on them
20:05:43 <exio4> e.g. binary has quite many more helpers for parsing binary :)
20:06:31 <heptahedron> binary has more helpers for parsing binary? What?
20:06:46 <MarcelineVQ> binary is a library
20:07:50 <exio4> heptahedron: http://hackage.haskell.org/package/binary
20:08:10 <nshepperd_> fen: hacking ghc won't help at all. if you can even do it, it'll probably break all the standard haskell libraries so you won't be able to use them
20:08:35 <nshepperd_> fen: meanwhile, i'm sure there's a totally sensible plain-haskell way to solve your actual problem
20:08:35 <fen> how would it?
20:09:01 <fen> ok, so the class itself shouldnt be changed
20:09:08 <heptahedron> Alright, well it doesn't really seem as though `binary` is helpful in my situation. Really, I just need to detect the header and footer of a message body so I can pass the contents to a parser I've already written for it in Megaparsec. Neither `attoparsec` nor `binary` appear to be of more use here in order to accomplish that
20:09:21 <fen> it would make the hackage repo uncompatible
20:09:26 <MarcelineVQ> whether the hacking does or doesn't break things, what is the problem being solved with the ghc modification?
20:09:37 <nshepperd_> fen: which typeclass instance are you trying to redefine for [] and why?
20:12:19 <fen> traversable, to be consistent with the other code which uses an alternative definition 
20:12:32 <ethanrakoff> I'm looking to play around with haskell (only ever done imperative programming) and I'm on an arch machine. What is the typical way of installed the build tools and deps? I want to avoid installing everything from the offical repos. Do people typically just use stack to manage everything, or should I build a docker environment (or something like that)?
20:13:15 <glguy> heptahedron: attoparsec works out to be a win because it knows that it's working with a ByteString as the source and so you get better support for extracting bytestrings from the thing you're parsing
20:13:18 <heptahedron> ethanrakoff: I personally use stack, a lot of people would advocate nix, and if I knew more about it I imagine I'd probably use it as well. 
20:13:45 <glguy> ethanrakoff: Most people install the core haskell platform, or even just the bindist GHC from haskell.org
20:15:05 <glguy> heptahedron: megaparsec can use a ByteString as a source value, it's just less convenient for writing binary parsers. Did you get stuck trying to parse from a ByteString?
20:15:23 <ethanrakoff> ok cool, i'll probably just install what i need from the repo and use stack for as much as i can, because that will likely be a lot easier than managing every single dep with pacman. I was just curious what people typically did.
20:15:37 <fen> is the normal way to make such a change via a ghc trac proposal?
20:16:20 <fen> there must have been some consideration about the Semigroup Monoid superclass which "breaks everything" 
20:16:40 <fen> so many Traversable instances to redefine
20:16:51 <MarcelineVQ> ethanrakoff: On Arch I advocate using a binary for stack, via aur if you know how to use aur or downloading directly yourself, to avoid pulling in pacman depdendencies
20:17:06 <fen> admitedly a very serious thing
20:17:27 <ethanrakoff> my motivation for learning haskell is to play around with xmonad. would you guys recommend working through a book first or learning by doing through xmonad?
20:17:33 <maerwald> ethanrakoff: give https://github.com/haskell/ghcup a try
20:17:43 <ethanrakoff> MarcelineVQ: that is what i am probably going to do
20:17:45 <fen> but if its with good reason maybe there is a chance it would be accepted 
20:17:53 <maerwald> stack is overkill, unless you have a good use case for it
20:19:05 <fen> seems like getting it working on a local ghc build would be a first step
20:20:17 <heptahedron> glguy: I am parsing messages over a TCP connection which naturally arrive as bytestrings. The messaging protocol is defined at a layer above character encoding, and so those parsers' inputs are Text. What minimal binary parsing must be done is finding the bytes 0x0B and 0x1C, and feeding the decoded bytestring between those delimiters to the parsers I've already written.
20:20:39 <fen> is it worth asking at #ghc?
20:20:57 <glguy> heptahedron: Oh, if you're just parsing the Text type, the megaparsec sounds great :)
20:22:10 <nshepperd_> fen: huh? what alternative Traversable instance could lists possibly have
20:22:28 <fen> same as any other traversable instance!
20:22:37 <heptahedron> glguy: I know, that's why the choice of parsing library was not part of my question, as I had already weighed the benefits of both libraries, haha
20:23:12 <glguy> heptahedron: It's not good for parsing TCP messages. If you hadn't included that part I wouldn't have said anythign
20:23:30 <nshepperd_> I suppose you could do the effects in reverse order, but apart from that it seems pretty constrained.
20:23:38 <fen> maybe here is the best place to ask as its where some people who might end up using it could give a yay/nay on if they would be willing to use it
20:24:04 <heptahedron> I am nonetheless interested in exactly how megaparsec fails to be as convenient for parsing bytestrings as attoparsec.
20:25:12 <fen> nshepperd_: all traversable instances can be suspended
20:25:52 <fen> this theorem (along with a proof not now) motivates a superclass
20:25:54 <nshepperd_> suspended? what does that mean
20:26:14 <fen> to proceed elementwise
20:28:40 <nshepperd_> i don't understand still
20:29:20 <fen> traversable=countable=ordered visitation
20:29:41 <fen> proceeding to traverse one value at a time is thus always an option
20:30:22 <heptahedron> glguy: Do you have experience parsing TCP streams with both mega- and attoparsec?
20:32:00 <nshepperd_> 'one value at a time' means what?
20:32:12 <dmj`> heptahedron: what data over TCP are you parsing?
20:32:21 <glguy> No, I wouldn't use megaparsec for that, but I have experience using the various parsing combinator libraries
20:32:40 --- mode: glguy set +v brando
20:32:42 <glguy> and with using attoparsec for network protocols
20:32:53 <nshepperd_> traverse does things one at a time in one sense, so does turning it into a list with toList and looking at the values
20:33:16 <fen> when sets are countable, they must have an ordering to the values they contain. proceeding from one value to the next as defined by this ordering
20:33:22 <heptahedron> dmj`: It's HL7 messages
20:33:36 <brando> why is
20:33:37 <brando> -- Booleans b1, b2 :: Bool b1 = True b2 = False
20:33:39 <brando> wrong code?
20:34:01 <brando> pg.hs:1:1: error:     The IO action ‘main’ is not defined in module ‘Main’   | 1 | -- Booleans   | ^
20:34:29 <glguy> brando: If you omit the module  declaration it defaults to this:  module Main (main) where
20:34:31 <fen> nshepperd_: right, but traverse always proceeds to the end of the container, not pausing, hence the term "suspended" to mean the opposite 
20:34:42 <glguy> brando: so add a module declaration to that module that matches its filename
20:34:53 <brando> gluguy: ah ok, I guess the tutorial Im doing is incomplete or something
20:34:58 <brando> https://www.schoolofhaskell.com/school/starting-with-haskell/introduction-to-haskell/1-haskell-basics#abstraction
20:34:58 <fen> the idea is that it always *can* be suspended, as a result of it being ordered 
20:35:40 <glguy> > firstOf traverse (repeat True)
20:35:42 <lambdabot>  Just True
20:35:43 <fen> the traverse class currently requires specification of this order
20:35:53 <glguy> traverse doesn't have to finish "traversing" the list thanks to non-strict evaluation
20:36:22 <nshepperd_> nothing stops you from using an appropriate Applicative with lazy behaviour to return early before reaching the end
20:36:31 <fen> glguy: it also applies to product datatypes of only one value
20:36:35 <nshepperd_> like glguy just demonstrated
20:37:21 <fen> being able to suspend a traversal does not prevent it from being lazily evaluated 
20:37:59 <glguy> Do you have your idea written up in a Haskell source file that you can share?
20:38:01 <fen> though the values would be accessed from the part not yet traversed 
20:38:14 <glguy> It would be easier to understand what you want to do if you had code to share
20:38:48 <dmj`> heptahedron: cool!
20:38:56 <dmj`> heptahedron: seems similar to csv
20:41:05 <fen> glguy: not really, its quite long
20:41:36 <fen> definatly easier to understand without having to read the whole implementation 
20:42:04 <fen> that would be the proof, which it would be better to present very neatly some other time
20:42:34 <fen> the essence of which is very simple 
20:42:56 <heptahedron> dmj`: It is a bit like a rank-5 tensor version of CSV, yeah, haha. One of our systems only accepts data in JSON format, but most healthcare systems only output via HL7v2 messages, so my project has been to make an integration system for us. I've made a DSL with which to describe the transformation from HL7v2 to JSON as well so that our non-developers should hopefully be able to manage site variations etc. 
20:42:57 <fen> the discussion would be easier if it was supposed to be true
20:43:38 <MarcelineVQ> pretend people can't read your mind fen
20:44:07 <nshepperd_> superclasses are for things that can be constructively implemented in terms of their subclasses, but where there are some types that have the superclass but not the subclass
20:44:13 <dmj`> heptahedron: very cool, had no idea healthcare systems were this far along :) do you work for epic ?
20:44:31 <nshepperd_> it's impossible to be sure, but it sounds like what you're describing is just equivalent to Traversable
20:44:57 <nshepperd_> in which case it could just be a plain function
20:45:24 <heptahedron> dmj`: I would not call this "far along" by any means, haha. I don't, but I see that name literally every day. I believe we expect to be interfacing with a lot of their systems. They have a more modern interface called FHIR that
20:45:31 <fen> or an alternative to the Traversable class
20:45:57 <fen> though it is easier to implement Traversable in terms of it, rather than the other way round 
20:46:10 <fen> making traverse "just a function"
20:46:20 <heptahedron> 's over HTTP, but not all sites have that capability. HL7v3 is actually encoded in XML, I'm not sure if that would be more or less painful than working with this weird proprietary encoding scheme lol
20:47:54 <heptahedron> What's especially great is that neither of the other 2 developers know any haskell and I'm coding this essentially blind since we don't have access to a production HL7v2 system! So I sure hope it works out. Didn't really expect them to be so on-board with using haskell for a project but I told them it was essentially the best for DSL design/implementation
20:48:07 <dmj`> heptahedron: yes, you can totally tell somebody just made this scheme up haha, “put a pipe here, a carrot here"
20:48:08 <glguy> fen: If you can implement traverse in terms of this class, then you can make Traversable a superclass of it and you won't need to change Traversable itself
20:48:32 <dmj`> heptahedron: you in the chicago suburbs? haskell in healthcare, now I’ve seen it all
20:49:03 <heptahedron> dmj`: What makes you ask about the Chicago suburbs?
20:50:17 <dmj`> saw the ".hsd1.il.comcast.net"
20:50:48 <heptahedron> dmj`: I'm in the city itself, haha
20:50:59 <fen> glguy: but that does not have the effect of forcing the user to implement the equivilant and more useful version 
20:51:47 <brando> why does
20:51:48 <brando> -- Compute the sum if the integers from 1 to n. sumtorial :: Integer -> Integer sumtorial 0 = 0 sumtorial n = n + sumtorial (n - 1)  main = print (sumtorial 10)
20:51:53 <brando> result in an error?
20:52:05 <glguy> fen: That's fine. THe goal isn't to force anyone to implement anything
20:52:10 <fen> so its like an empty subclass?
20:52:39 <glguy> It's like how Functor is a superclass of Traversable and you can use fmapDefault to derive fmap in terms of traverse
20:52:55 <jackdk> brando: possibly a formatting error? pastebin the code and the error you get?
20:53:03 <dmj`> heptahedron: ah nice, that’s where I’m from, lived in old town, logan, lakeview. 
20:53:17 <fen> but Functor is strictly less than Traversable, wheras this is exactly equivilant 
20:53:28 <brando> jackdk: how do I pastebin?
20:53:53 <nshepperd_> fen: why do you want to force people to implement things
20:54:00 <fen> its informative 
20:54:12 <fen> why was Semigroup added?
20:54:12 <nshepperd_> why not just implement your function in terms of traverse and call it a day
20:54:24 <fen> because thats backwards!
20:54:32 <nshepperd_> it's not backwards
20:54:46 <heptahedron> dmj`: Yeah I wouldn't have guessed I'd get to use Haskell in my day-to-day work but I'm stoked that I got the chance. I'm worried that if this gets near production there'll be some space leak or other strange behavior due to its laziness that I won't know how to debug :s
20:54:50 <fen> it is, traverse should be defined in terms of it, it being a subclass
20:54:56 <nshepperd_> Semigroup exists because there are things that don't have mempty, but it's still useful to use <>
20:55:26 <fen> it really seems like its just a replacment of Traversable
20:55:30 <brando> jackdk https://pastebin.com/HbCUH6AZ
20:55:51 <glguy> fen: Traverse as it exists isn't going anywhere, but you should definitely put this together into a form that is suitable for sharing with other people. Your first step will be to get it to a form that is OK to share and installable as a package
20:57:26 <fen> regardless of if it is accepted as a replacment for traversable, it still makes most sense to alter GHC to use it this way, but that means it cant be distributed
20:59:27 <brando> help? https://pastebin.com/bMLxUYZ7
21:00:00 <fen> glguy: you mean with a traverseDefault function?
21:00:02 <nshepperd_> i find that implausible tbh
21:00:10 <alexelcu> I'm getting a warning that I'd like to fix or silence when compiling my project, if possible:
21:00:10 <alexelcu> ```
21:00:10 <alexelcu> clang: warning: argument unused during compilation: '-nopie' [-Wunused-command-line-argument]
21:00:10 <alexelcu> ```
21:00:21 <fen> nshepperd_: why?
21:00:32 <nshepperd_> traverse is pretty elegant, and defining Traversable instances is correspondingly dead simple
21:00:44 <brando> whats wrong with
21:00:44 <brando> -- Compute the sum if the integers from 1 to n. sumtorial :: Integer -> Integer sumtorial 0 = 0 sumtorial n = n + sumtorial (n - 1)  main = print (sumtorial 10)
21:01:01 <fen> and also exactly equivilent to defining the cons and uncons parts sepperatly, which is definatly better
21:01:06 <fen> as its always an option
21:01:18 <dmj`> heptahedron: heh, if that does happen, profiling is a great way to track down space leaks, or do Neil Mitchell’s trick and set the stack size of a thread to 1K.
21:01:18 <MarcelineVQ> brando: ghci commands start with  :
21:01:24 <MarcelineVQ> You can see a list of them with  :?
21:01:49 <nshepperd_> no, that sounds worse...
21:01:51 <glguy> alexelcu: You can edit your ~/Tools/ghc-8.4.3/lib/ghc-8.4.4/settings file (edited for your computer and GHC version)
21:01:55 <fen> how!?
21:01:59 <glguy> ("C compiler supports -no-pie", "NO"),
21:02:20 <brando> MarcelineVQ: still get error
21:02:22 <brando> Prelude> load: pg.hs  <interactive>:1:1: error: Variable not in scope: load  <interactive>:1:7: error:     • Variable not in scope: pg :: b0 -> c0     • Perhaps you meant ‘pi’ (imported from Prelude)  <interactive>:1:7: error:     • Couldn't match expected type ‘[a]’ with actual type ‘a0 -> c0’     • Probable cause: ‘(.)’ is applied to too few arguments       In the second argument of ‘(:)’, namely ‘pg 
21:02:31 <MarcelineVQ> brando: ghci commands start with  :
21:02:46 <monochrom>  :load pg.hs
21:03:00 <brando> oh
21:03:01 <brando> darn it
21:03:02 <brando> thnx
21:03:48 <jackdk> brando: chill man, I tabbed away from IRC for a minute. Also what the others said. Your file loads on my GHCi, are you still having trouble?
21:03:50 <fen> its much more reusable than trying to derive e.g. cons from traverse
21:04:39 <glguy> fen: You can't define a cons and uncons for many of the traversable types, assuming those names mean something common. We can't really discuss your idea in detail since you haven't written it down yet
21:05:17 <fen> there are equivilant elementwise constructors and deconstructors
21:05:57 <fen> thats why foldable is a superclass, as it only needs the deconstructor 
21:06:45 <fen> its much more helpful to make this obvious by using these functions directly
21:06:47 <monochrom> wth is elementwise constructor and what does it mean for binary trees?
21:07:25 <fen> they are visited in a particular order
21:07:42 <monochrom> constructor visits?
21:08:09 <monochrom> what is there to visit? I'm building a new tree, not consuming an existing tree.
21:08:15 <fen> the traversable implentation for your chosen shaped container will have the details, but it recombines the constructor and deconstructor inside the applicative
21:09:25 <fen> oh, your question is about the corresponding superclass to traversal, almost dual to foldable, where the constructor is used in isolation rather than the deconstructor
21:09:28 <monochrom> But you said elementwise constructor specifically, not vague abstract constructor that could be non-elementwise.
21:09:34 <fen> yes thats interesting, its an unfold 
21:10:15 <fen> the theorem could be phrased something like "traversable = fold+unfold"
21:10:15 <nshepperd_> traversable isn't an unfold
21:10:18 <monochrom> OK can you write down the type of "elementwise constructor" or "unfold" or whatever you choose to word-mince it?  Words no longer mean anything now.
21:10:19 <glguy> fen: Does it make sense to you that as a result of the idea not being in a form that you can show us that it might not be ready to discuss as an alternative to Traversable?
21:10:56 <monochrom> And you still haven't answered what does it mean for binary trees.
21:11:05 <fen> monochrom: part of the dificulty of doing so is that there are various alternatives
21:11:33 <monochrom> That's an easity not difficulty.  Write down all.
21:11:43 <monochrom> Difficulty is when there are 0 choices.
21:11:44 <fen> (s->(a,s)), (s->Maybe(a,s)), (s->(a,Maybe s)), (s->Maybe(a,Maybe s))
21:11:51 <fen> those all work
21:12:00 <monochrom> No, none of those work.
21:12:04 <fen> !?
21:12:59 <monochrom> (s->(a,s)) doesn't work for finite lists.  (s->Maybe(a,s)) doesn't work for binary trees.  Etc etc.
21:13:11 <fen> right, thats the difficulty 
21:13:15 <fen> many options
21:13:23 <fen> but still one common class
21:13:25 <monochrom> And those are destructors not constructors.
21:13:38 <fen> those give values for the unfold
21:13:48 <fen> the constructor itself is particular to the datatype
21:14:15 <monochrom> Therefore the conclusion is that Traversable is as good as you can get.
21:14:20 <fen> no
21:14:40 <fen> there is certainly a way to use the simplest of these
21:14:51 <fen> it just prevents streams
21:15:04 <fen> which are arguably not traversable
21:15:10 <fen> or is that a mistake?
21:15:41 <heptahedron> fen: What makes you believe streams aren't traversable?
21:15:58 <fen> you cant reach the end of them 
21:16:14 <heptahedron> you can't really reach the end of `[1..]` either, but you can traverse it, can't you?
21:16:18 <monochrom> You can use a multiple parameter type class.
21:16:35 <fen> heptahedron, that would use (s->Maybe(a,s))
21:16:45 <fen> streams use (s->(a,s))
21:17:32 <glguy> fen: Have you read this yet? https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
21:17:37 <fen> some containers can also be empty, but the non-empty version (s->(a,Maybe s)) can be used here, then e.g. [] is just equivilent to Nothing
21:17:58 <fen> glguy: classic 
21:18:28 <fen> :t unfold 
21:18:29 <lambdabot> error:
21:18:30 <lambdabot>     • Variable not in scope: unfold
21:18:30 <lambdabot>     • Perhaps you meant one of these:
21:18:37 <fen> :t Data.List.unfold 
21:18:39 <lambdabot> error:
21:18:39 <lambdabot>     Not in scope: ‘Data.List.unfold’
21:18:39 <lambdabot>     Perhaps you meant one of these:
21:18:44 <heptahedron> fen: I think you shouldn't find any difficulty writing a `Traversable` instance for `data Stream a = SCons a (Stream a)`
21:18:46 <fen> >:|
21:19:25 <fen> heptahedron: sure, thats because it has a constructor and a deconstructor
21:19:32 <c_wraith> > runIdentity $ traverse pure [1..] -- fen
21:19:32 <glguy> and you shouldn't find any difficulty writing an instance for: data T a = C Int a a
21:19:35 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:19:36 <fen> the thing about the unfold is confusing me now
21:20:07 <c_wraith> fen: being infinite doesn't mean traversing the structure *can't* work.  It depends on the specific applicative used.
21:20:16 <fen> c_wraith: list is not the same as stream
21:20:27 <c_wraith> an infinite list is exactly the same as a stream
21:20:31 <fen> yes, because of lazy evaluation 
21:20:52 <fen> no, there is no equivalent to empty for stream
21:21:01 <c_wraith> there's also no empty in an infinite list
21:21:05 <glguy> fen: How does my type fit into your system?
21:21:30 <fen> its not using its product type
21:21:37 <fen> recursivly 
21:21:46 <fen> its just the first
21:21:49 <monochrom> Why should it? Maybe isn't recursive either.
21:21:55 <fen> same situation
21:22:28 <fen> very easy to unfold
21:22:31 <monochrom> OK so your idea is less general than Traversable because Traversable covers Maybe and T, yours doesn't.
21:23:15 <fen> sure, you can define Just as the constructor and pattern match on it for the deconstructor
21:23:49 <glguy> Anyway, let's discuss this more when there's an implementation to explore
21:23:57 <fen> it as Nothing which is like an Empty so it would be unfolded using the form (s->(a,Maybe s))
21:24:10 <fen> it as Nothing which is like an Empty so it would be unfolded using the form (s->Maybe(a,s))
21:24:12 <fen> sorry
21:24:49 <fen> glguy: up for a paste now or later later?
21:28:49 <alexelcu> My search fu is failing me — how can I add GHC compiler options (e.g. `-Wall -Werror`) to my `.cabal` or `stack.yaml` files?
21:29:14 <monochrom> ghc-options: -Wall -Werror
21:29:38 <alexelcu> this would be `stack.yaml`, right?
21:29:43 <monochrom> *.cabal
21:30:11 <alexelcu> ok, thanks
21:30:31 <monochrom> And it is put under the library section or an executable section. And if you have multiple such sections you have to repeat it once for every section.
21:58:37 <dminuoso> @let dat = [ZipList [1,2,3], ZipList [10,20,30], ZipList [100,200,300]]
21:58:38 <lambdabot>  Defined.
22:03:47 <dminuoso> > foldMap (Ap @ZipList @(Sum Int)) dat
22:03:49 <lambdabot>  <hint>:1:13: error: parse error on input ‘@’
22:04:01 <dminuoso> % let dat = [ZipList [1,2,3], ZipList [10,20,30], ZipList [100,200,300]]
22:04:01 <yahb> dminuoso: 
22:04:11 <dminuoso> % foldMap (Ap @ZipList @(Sum Int)) dat
22:04:11 <yahb> dminuoso: Ap {getAp = ZipList {getZipList = [Sum {getSum = 111},Sum {getSum = 222},Sum {getSum = 333}]}}
22:04:26 <dminuoso> Is there a concise way of doing this without TypeApplications?
22:04:37 <dminuoso> % foldMap (Ap @_ @(Sum Int)) dat
22:04:37 <yahb> dminuoso: Ap {getAp = ZipList {getZipList = [Sum {getSum = 111},Sum {getSum = 222},Sum {getSum = 333}]}}
22:05:37 <dminuoso> % coerce @_ @(ZipList Int) $ foldMap (Ap @_ @(Sum Int)) dat
22:05:37 <yahb> dminuoso: ZipList {getZipList = [111,222,333]}
22:11:24 <dminuoso> % f :: forall p (m :: * -> *) c a t. (Foldable t, Monoid (m c)) => p m -> (a -> (m c)) -> t a -> (m c); f p = foldMap
22:11:24 <yahb> dminuoso: 
22:12:13 <dminuoso> mmm
22:19:36 <dminuoso> % foldMapAp :: forall p (m :: * -> *) c a t. (Foldable t, Monoid (m c)) => p m -> t a -> (m c); foldMapAp p = coerce @_ @(t a) . foldMap (Ap @t @(Sum a))
22:19:36 <yahb> dminuoso: ; <interactive>:134:109: error:; * Occurs check: cannot construct the infinite type: a ~ t (Sum a); Expected type: t a -> m c; Actual type: t (t (Sum a)) -> t a; * In the expression: coerce @_ @(t a) . foldMap (Ap @t @(Sum a)); In an equation for `foldMapAp': foldMapAp p = coerce @_ @(t a) . foldMap (Ap @t @(Sum a)); * Relevant bindings include foldMapAp :: p m -> t a -> m
22:20:21 <ion> Where's yahb's code, btw?
22:22:02 <dminuoso> ion: It's a sandboxed GHCi
22:23:00 <ion> Thanks, my question still stands. :-)
22:23:29 <dminuoso> % foldMapAp :: forall p (m :: * -> *) c a t. (Foldable t, Monoid (m c)) => p m -> t a -> t a; foldMapAp p = coerce @_ @(t a) . foldMap (Ap @_ @(m a))
22:23:29 <yahb> dminuoso: ; <interactive>:136:14: error:; * Could not deduce (Monoid (m c0)); from the context: (Foldable t, Monoid (m c)); bound by the type signature for:; foldMapAp :: forall (p :: (* -> *) -> *) (m :: * -> *) c a (t :: * -> *). (Foldable t, Monoid (m c)) => p m -> t a -> t a; at <interactive>:136:14-90; The type variable `c0' is ambiguous; * In the ambiguit
22:23:34 <dminuoso> Gah. Why wont you just.
22:23:52 <dminuoso> Oh.
22:24:29 <haasn> what's wrong with just foldMap Ap dat :: _ (Sum _)  ?
22:25:15 <dminuoso> % foldMap Ap dat :: _ (Sum _)
22:25:15 <yahb> dminuoso: ; <interactive>:137:19: error:; * Found type wildcard `_' standing for `Ap ZipList :: * -> *'; To use the inferred type, enable PartialTypeSignatures; * In an expression type signature: _ (Sum _); In the expression: foldMap Ap dat :: _ (Sum _); In an equation for `it': it = foldMap Ap dat :: _ (Sum _); * Relevant bindings include it :: Ap ZipList (Sum w) (bound at <interacti
22:25:29 <dminuoso> % :set -XPartialTypeSignatures
22:25:29 <yahb> dminuoso: 
22:25:29 <dminuoso> % foldMap Ap dat :: _ (Sum _)
22:25:29 <yahb> dminuoso: ; <interactive>:139:19: warning: [-Wpartial-type-signatures]; * Found type wildcard `_' standing for `Ap ZipList :: * -> *'; * In an expression type signature: _ (Sum _); In the expression: foldMap Ap dat :: _ (Sum _); In an equation for `it': it = foldMap Ap dat :: _ (Sum _); * Relevant bindings include it :: Ap ZipList (Sum w) (bound at <interactive>:139:1); <interactive>:139:1
22:25:36 * dminuoso sighs
22:25:53 <dminuoso> % :set -w
22:25:53 <yahb> dminuoso: 
22:25:55 <dminuoso> % foldMap Ap dat :: _ (Sum _)
22:25:55 <yahb> dminuoso: Ap {getAp = ZipList {getZipList = [Sum {getSum = 111},Sum {getSum = 222},Sum {getSum = 333}]}}
22:26:43 <dminuoso> haasn: I guess thats not too bad
22:27:14 <haasn> -Wpartial-type-signatures should probably be suppressed if -XPartialTypeSignatures is enabled
22:33:25 <haasn> % :t Ap `asTypeOf` \[Sum _] -> undefined
22:33:25 <yahb> haasn: [Sum a] -> Ap [] (Sum a)
22:35:04 <haasn> % :t Ap `asTypeIn` \f -> f [Sum 0] -- dminuoso
22:35:04 <yahb> haasn: Num a => [Sum a] -> Ap [] (Sum a)
22:38:29 <haasn> actually you can even use this trick to do it without -XPartialTypeSignatures
22:38:32 <haasn> let x :: a (Sum Int); x = x in foldMap Ap dat `asTypeOf` x
22:39:01 <ion> % :info Ap
22:39:01 <yahb> ion: type role Ap representational nominal; newtype Ap (f :: k -> *) (a :: k) = Ap {getAp :: f a}; -- Defined in `Data.Monoid'; instance Alternative f => Alternative (Ap f) -- Defined in `Data.Monoid'; instance Applicative f => Applicative (Ap f) -- Defined in `Data.Monoid'; instance forall k (f :: k -> *) (a :: k). Eq (f a) => Eq (Ap f a) -- Defined in `Data.Monoid'; instance Functor f => Functor (Ap f) 
22:41:52 <dminuoso> haasn: Mmm, that's pretty neat actually :)
22:41:57 <dminuoso> % foldMapAp :: forall p t m a. (Foldable t, Monoid (m a)) => p m -> t a -> Ap t (m a); foldMapAp _p = foldMap (Ap @t @(m a))
22:41:57 <yahb> dminuoso: ; <interactive>:154:101: error:; * Occurs check: cannot construct the infinite type: a ~ t (m a); Expected type: t a -> Ap t (m a); Actual type: t (t (m a)) -> Ap t (m a); * In the expression: foldMap (Ap @t @(m a)); In an equation for `foldMapAp': foldMapAp _p = foldMap (Ap @t @(m a)); * Relevant bindings include; _p :: p m (bound at <interactive>:154:96); f
22:42:15 <dminuoso> Was trying to chase down that road, but it's a bit beyond me how that occurs check triggers
22:47:07 <haasn> 1. that's the wrong number of parameters, 2. `p` is not used in your type signature, 3. the return type of foldMap has nothing to do with the `t` you folded over
22:48:02 <dminuoso> haasn: Why is it the wrong number of parameters?
22:48:04 <dminuoso> % :t foldMap
22:48:05 <yahb> dminuoso: (Foldable t, Monoid m) => (a -> m) -> t a -> m
22:48:18 <haasn> because you already applied it to `Ap`
22:48:32 <dminuoso> haasn: p m -> t a -> Ap t (m a)
22:49:01 <dminuoso> haasn: it takes the proxy parameter, disregards it - and returns foldMap partially applied
22:49:18 <haasn> Oh, I missed that
22:49:46 <haasn> Still, I suspect the third point stands and that `t` being on both the input and the output of foldMap is what gives rise to the infinite type
22:50:01 <dminuoso> haasn: and equivalently Im applying the `t` in foldMap, if you look at the type of foldMap..
22:50:05 <dminuoso> mmm
22:51:33 <haasn> hmm no that can't be the reason, since `m` can itself involve `t`
22:52:35 <haasn> ah, actually it's the `a` causing problems here
22:53:30 <haasn> you have `t a` as the input which means the output type should be `Ap` applied to `a` somehow
22:54:43 <haasn> Ap :: t (m a) -> Ap t (m a) so it tries constructing t a ~ t (t (m a)) for the input of foldMap
22:54:57 <haasn> which implies the invinite type a ~ t (m a) as it was saying
23:56:14 --- mode: glguy set +v kritzcreek_
