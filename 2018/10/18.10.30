00:06:16 <pavonia> Re that Alex output, it seems the line "Accept(s)" indicates the next state to go into if no other input matches
00:06:18 --- mode: glguy set +v k0d3fr34k[m]
00:06:34 <k0d3fr34k[m]> What functional language is best to pick up after Haskell?
00:07:08 <tdammers> k0d3fr34k[m]: depends on your goals and requirements
00:08:53 <Zemyla> k0d3fr34k[m]: Unlambda.
00:08:55 <phadej> someone stay with Haskell :)
00:09:16 <k0d3fr34k[m]> <freenode_Zem "k0d3fr34k: Unlambda."> Okay
00:10:33 <k0d3fr34k[m]> <freenode_tda "k0d3fr34k: depends on your goals"> Like? I am a student and I am new to functional programming. Haskell is nice but I'd also like to see some other functional language that is good to learn. F# didn't seem that nice. How is Scheme?
00:15:49 <ion> Scheme pros: Lisp syntax; cons: untyped
00:16:11 <k0d3fr34k[m]> untyped?
00:16:40 <winny> you  could do the unthinkable and try typed racket
00:17:01 <ion> It only has one type, every possible value is an inhabitant of it. A.k.a. dynamic typing.
00:17:25 <winny> (typed racket is statically typed)
00:18:23 <ion> Sorry for ambiguity, I was responding to kdfrk.
00:18:55 <k0d3fr34k[m]> <freenode_ion "It only has one type, every poss"> Oh
00:19:57 <k0d3fr34k[m]> <freenode_pha "someone stay with Haskell :)"> I am XD. I am just keen to try out other languages too.
00:20:26 <ion> That's always a good idea.
00:20:45 <ion> I have been meaning to learn Idris.
00:24:49 <k0d3fr34k[m]> Yes, I was going to take a look at Idris too
00:27:32 <mniip> matrix mentions are getting worse by the month
00:28:16 <ion> <freenode_mni Why, is there a problem?
00:29:08 <mniip> no it's just the progression
00:29:18 <mniip> eventually we'd be called IRC Person 83426058734
00:30:10 <ion> I am not a number. I am a free monoid!
00:30:37 <mniip> a number is just a free monoid on one generator
00:30:43 <ion> Touche
00:31:00 <Zemyla> My suggestion of Unlambda was in jest, though writing an Unlambda interpreter could be an interesting exercise.
00:33:47 <Kartha> hi haskellers
00:37:39 <ion> o/
00:47:35 <koz_> Sup Kartha.
00:57:06 <Kartha> koz_: lab
00:57:10 <Kartha> gtg bye
01:04:00 <bahamas> what does it mean to call a function by surrounding it with tildes? like userLogin ~catchE~ wrongPasswordHandler
01:04:51 <cocreature> bahamas: that’s not builtin syntax, presumably you are using a library that has defined (~) as an infix operator
01:06:42 <ion> Are you sure it's not userLogin `catchE` wrongPasswordHandler?
01:07:11 <bahamas> cocreature: it's the code from the end of this article https://two-wrongs.com/a-gentle-introduction-to-monad-transformers
01:08:29 <ion> I think that is a really weird typo. I mean, it's the same key with shift but OTOH one would assume that code was compiled successfully and then copied and pasted into the article.
01:08:30 <bahamas> ion: see the link above. previously, the article used `catchE`, but in the final version of the code, it changed to tilde
01:08:47 <bahamas> a, so the tildes don't make sense
01:09:26 <cocreature> yeah that looks like a typo
01:09:44 <bahamas> I'll write an email to the author, so he can fix it. there's one other issue I found anyway
01:10:27 <ion> So there are two wrongs in the article? I see what the author is doing.
01:10:40 <geekosaur> fwiw I am seeing `s (at loginDialogue, at least)
01:11:16 <bahamas> geekosaur: at the end of the article? higher up, the article uses `catchE` correctly
01:11:23 <geekosaur> ah, in the final listing. that might be a typo; on US QUERTY keyboards ~ is often shifted `
01:11:34 <bahamas> ion: you think he did it on purpose?
01:11:43 <ion> bahamas: No, I was joking.
01:11:49 <Taneb> bahamas: ion is making a joke, "two wrongs make a right"
01:12:29 <bahamas> Taneb: yes, I know the saying :)
01:12:52 <bahamas> it's actually, don't make a right
01:13:01 <Taneb> ...yes
01:13:11 <Taneb> (I've just got out of bed, in my defense)
01:13:11 <ion> Correct, three wrongs make a right.
01:13:27 <geekosaur> but do three Rights make a Left? :p
01:13:44 <Taneb> > Right (Right (Right ())) == Left ()
01:13:46 <lambdabot>  False
01:13:47 <geekosaur> bah, slow down to deal with this keyboard and end up too slow
01:13:52 <Taneb> geekosaur: signs point to "no"
01:17:18 <mniip> > three rights ()
01:17:21 <lambdabot>  Left ()
01:19:04 <MarcelineVQ> > flip three lights ()
01:19:06 <lambdabot>  Left "****"
01:23:40 <bahamas> :t three
01:23:41 <lambdabot> error: Variable not in scope: three
01:23:59 <bahamas> what is this sorcery?
01:24:00 <MarcelineVQ> It was all a lie.
01:25:07 <bahamas> btw, there is a typo on this page. where can I file an issue/pull request? http://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-Trans-Except.html
01:25:46 <mniip> what's the typo
01:26:00 <ion> > how many lights
01:26:03 <lambdabot>  THERE ARE FOUR LIGHTS
01:28:12 <ion> bahamas: Contents -> 0.5.5.0 (the latest version) -> Bug tracker
01:29:41 <bahamas> mniip: "...with the ability throw exceptions."
01:30:09 <bahamas> ion: thanks!
01:46:32 <bahamas> I'm making an account on darcs, and it's asking me this as an anti-spam measure: what RCS is hosted here ?. what's RCS?
01:47:04 <geekosaur> 'revision control system'
01:47:05 <bahamas> actually, I'll just login with github
02:13:52 --- mode: glguy set +v Jimmy_
03:01:13 <__monty__> I'm working on a church encoding exercise, trying to implement subtraction. I'm having trouble understanding this type error: http://ix.io/1qr3
03:03:00 <Lycurgus> you know an occurs check is a well known thing?
03:03:08 <Lycurgus> prolly has a wiki article
03:03:18 <Lycurgus> not unique to hs
03:04:13 <Lycurgus> https://en.wikipedia.org/wiki/Occurs_check
03:04:16 <__monty__> Maybe I should rephrase. I understand the problem but I don't know how to solve it.
03:04:51 <Ariakenom> example:
03:04:51 <Ariakenom> % let x = [x] in x
03:04:52 <yahb> Ariakenom: ; <interactive>:4:10: error:; * Occurs check: cannot construct the infinite type: a1 ~ [a1]; * In the expression: x; In the expression: [x]; In an equation for `x': x = [x]; * Relevant bindings include x :: [a1] (bound at <interactive>:4:5)
03:05:38 <Ariakenom> in that it's a list of list of list ... which isn't allowed
03:05:54 <koz_> It's a black list hole.
03:05:57 <Ariakenom> It's not a list in your case but it's infinite in the same way
03:07:51 <Ariakenom> ~ is type equality. so m :: a and m :: (a->a) -> a is implied from different parts of the expression
03:07:58 <Ariakenom> and both can't be true
03:09:09 <rfold> Hi, is it possible to get the address of a compact region? I can't find a relevant function in GHC.Prim. I'd like to madvice it.
03:12:13 <rfold> Ah, seems to be compactGetFirstBlock# and compactGetNextBlock#.
03:12:37 <Ariakenom> __monty__: I can't really see the issue right away. I'll suggest splitting the expression up and typing individual parts
03:15:00 <Dark_Ethereal> Is `Endo` just a newtype for functions `:: a -> a` where the Monoid is function composition and mempty is `id`?
03:15:09 <cocreature> Dark_Ethereal: yep
03:15:40 <koz_> Dark_Ethereal: Yeah, that's right. This is what enables us to write foldr in terms of foldMap.
03:15:53 <koz_> (essentially, we 'cook up' a custom function to do the fold)
03:20:56 <Dark_Ethereal> The World Health Organization renames diseases when the names become problematic for treating the disease.... I wish mathematicians could get together at a big conference and agree to rename certain concepts because the names problematically scary compared to the actual concept.
03:21:13 <Dark_Ethereal> But such is life I suppose
03:21:26 <koz_> Dark_Ethereal: Specialist fields have specialist nomenclature.
03:21:31 <koz_> It's just how it goes.
03:21:31 <rfold> Like, Clown and Joker.
03:21:36 <koz_> It only _looks_ scary.
03:21:44 <koz_> rfold: Nice McBride reference you got there.
03:21:56 <tdammers> clowns *are* scary though
03:22:08 <rfold> McBride sure isn't coulrophobic.
03:22:24 <Ariakenom> You just need more zygohistomorphic prepromorphisms
03:22:27 <merijn> Dark_Ethereal: How should it be called instead, then?
03:22:59 <tdammers> just need to get over that hippopotamosequialpediaphobia
03:23:02 <koz_> McBride's papers are certainly rather unique.
03:23:04 <merijn> Dark_Ethereal: I mean, I empathise with the name being intimidating, but I honestly wouldn't know what a good non-intimidating name would even look like?
03:23:29 <cocreature> “FunctionCompositionMonoid”? :)
03:23:41 <koz_> cocreature: So, the Java Naming Convention?
03:23:42 <merijn> Dark_Ethereal: I mean "newtype CompositionOfAtoAFunctions a" seems rather undesirable too
03:24:02 <merijn> cocreature: Pfft, only if you want to imply privileged status of composition via . !
03:24:07 <[exa]> FunctionCompositionFactoryMonoidInterfaceHandle
03:24:27 <koz_> [exa]: You forgot 'PatternFactoryInterface'.
03:24:32 <merijn> Clearly there's only one true monoid for functions
03:24:34 <cocreature> merijn: well that’s the entire reason for its existence
03:24:34 <koz_> Wait never mind, you had Interface.
03:24:37 <rfold> I'm more worried about Endo being specialized to (->) instead of any Category.
03:24:45 <[exa]> koz_: oh noes my code isn't semantic
03:24:57 <koz_> rfold: How would a more general Endo be written?
03:25:03 <[exa]> anyway, what's wrong about endomorphisms?
03:25:12 <rfold> koz_: newtype Endo c a = Endo (c a a); instance Category c => Monoid (Endo c a)
03:25:18 <koz_> Ah, I see.
03:25:28 <__monty__> Wow, tdammers, please check a dictionary, horrible spelling.
03:25:55 <rfold> Together with ala foldMap it'd be useful for Kleisli composition.
03:25:59 <tdammers> __monty__: I'm so sorry
03:26:07 <rfold> But it's a pet peeve of mine. :')
03:26:08 <koz_> rfold: I was about to mention Kleisli.
03:26:31 <mniip> Dark_Ethereal, do you know what "endo" means?
03:26:45 <merijn> rfold: Or you just "foldr (>=>) return" which seems shorter than all the newtype wrapping?
03:27:35 <Dark_Ethereal> _mniip
03:27:37 <Dark_Ethereal> yes
03:27:47 <mniip> what's so scary about it
03:28:13 <koz_> merijn: I think this is the first time I've seen someone folding using fish.
03:28:47 <Solonarv> to be fair, how often do you have a container full of arrows?
03:29:26 <merijn> koz_: pfft, that means your life doesn't have enough IO :p
03:29:39 <koz_> merijn: Lol.
03:30:53 <koz_> (as an aside, 'fish' is my favourite function name)
03:30:54 <mniip> koz_, ever fold using (.) and id?
03:31:06 <Dark_Ethereal> _mniip_ First, knowing what "endo" means and knowing what "endomorphism" means are two different things. If you know what "endo" and "morph" means, that doesn't mean you can work out what "endomorphism" means.
03:31:26 <koz_> mniip: Can't say I remember the last time I did that.
03:31:32 <koz_> Dark_Ethereal: I'm not sure I agree.
03:31:45 <Ariakenom> % liftA2 (,) [1,2] [3,4] -- has a list of functions in a step
03:31:45 <yahb> Ariakenom: [(1,3),(1,4),(2,3),(2,4)]
03:31:48 <mniip> if you know morphisms in general
03:31:55 <mniip> concluding what an endomorphism is trivial imo
03:32:20 <mniip> koz_, might come up occasionally when writing showsPrec by hand
03:32:27 <merijn> mniip: SUre, if all that stuff is second nature already
03:32:33 <merijn> mniip: It's now when you just start
03:32:37 <koz_> mniip: Probably _why_ I don't remember the last time I did that.
03:32:48 <koz_> I'm not sure I understand {read,shows}Prec.
03:32:51 <merijn> And as I said, I empathise the name isn't good for beginners. But I can't think of a non-sucky name that is
03:33:18 <merijn> And I prefer "short and unambiguous, but slightly intimidating" over "long, ambiguous, or sucky"
03:33:47 <mniip> I don't claim to understand readsPrec but showsPrec is pretty simple
03:33:55 <koz_> :t showsPrec
03:33:56 <lambdabot> Show a => Int -> a -> ShowS
03:34:04 <koz_> What's ShowS?
03:34:10 <mniip> String -> String
03:34:22 <koz_> Mapping what to what?
03:34:32 <mniip> showsPrec d (Just a) = showParen (d > 10) $ showString "Just " . showsPrec 11 a
03:34:41 <mniip> koz_, it's a difference list of chars
03:34:43 <merijn> koz_: Are you familiar with DList?
03:34:45 <koz_> Oh, right.
03:34:53 <mniip> shows x xs = show x ++ xs
03:34:57 <koz_> Thanks mniip, that makes a world more sense.
03:35:08 <mniip> shows x = showsPrec 0 x
03:35:23 <Dark_Ethereal> koz_: So do you think if you met a person knew ancient greek, but had no higher mathematical background, you could say "endomorphism" and they'd be able to infer the idea of endomorphism, and that they wouldn't just have some sort of vague idea that you're talking about something to do with "same shapes"
03:35:28 <mniip> the int is obviously for precedence
03:35:44 <mniip> Dark_Ethereal, you're a programmer, you're familiar with functions
03:35:51 <koz_> Dark_Ethereal: That's a rather contrived counter-example.
03:35:52 <mniip> endofunction is as good as endomorphism
03:36:24 <koz_> Admittedly I speak only for myself, but I certainly didn't find the idea of 'endomorphism' hard to make sense of when I saw it.
03:36:29 <geekosaur> someoen who knows ancient Greek isn't going to know any of the stuff mathematicians, scientists, or doctors have done with it
03:36:36 <koz_> (and I don't know ancient Greek)
03:36:42 <dstolfa> what is the alternative you propose though
03:36:45 <dstolfa> fnSelfToSelf?
03:37:19 <Lycurgus> Dark_Ethereal, yes, I think that
03:37:57 <Lycurgus> presuming you mean a person that has learned koine in this time
03:44:43 <Dark_Ethereal> mniip: I'd guess there's a good chunk of programmers who aren't used to calling functions "morphisms"... "endofunctions" would be a whole lot more approachable than "endomorphism" in cases where you're talking about just the instance of functions... 
03:44:43 <Dark_Ethereal> That being said, that doesn't make a difference to the newtype being "Endo"... and I suppose what annoys me a little is that I'm like "hey functions from a to a should be a monoid. Are they a Monoid instance? Let me check. No, I don't see an instance for (a -> a)... what's Endo? That's probably it isn't it. Is it?"
03:45:21 <mniip> you can't make an instance for (a -> a), not in Haskell 98 I think at least
03:45:31 <mniip> needs -XFlexibleInstances
03:45:50 <Dark_Ethereal> The use of newtypes to specify what typeclass instance to use has this obscuring effect: it makes it harder to find the instances you're looking.
03:45:51 <Dark_Ethereal> I get that it's a mechanical nessecity ofc
03:45:59 <mniip> understandable
03:46:09 <koz_> It's something that bothered me too, at first.
03:46:14 * koz_ is OK with it now.
03:46:40 <merijn> Dark_Ethereal: That's because functions have a way better Monoid instance than Endo!
03:46:56 <koz_> merijn: ???
03:47:01 <merijn> Dark_Ethereal: "instance Monoid m => Monoid (a -> m)"
03:47:08 <merijn> Best monoid instance around
03:47:15 <merijn> I'll fight anyone who disagrees!
03:47:27 <MarcelineVQ> Is it possible to disagree with that in good faith?
03:47:30 <koz_> merijn: Wait, how is that defined?
03:47:31 <merijn> MarcelineVQ: No!
03:47:36 <Rembane> Newtypes are like inheritance in OO
03:47:36 <mniip> koz_, pointwise
03:47:45 * Rembane ducks and runs 
03:47:48 <merijn> koz_: "mappend f g = \x -> f x <> g x"
03:47:57 <merijn> koz_: The best part, it's recursive!
03:48:14 <merijn> koz_: So you can mappend any function whose eventual result is a Monoid!
03:48:27 <merijn> "mempty = const mempty"
03:48:38 <koz_> merijn: That's... dirty and amazing.
03:48:47 <merijn> koz_: How is it dirty? It's imminently sensible
03:49:14 <koz_> More in the 'sneaky, clever and unexpected'. Like 'dirty manouevre'.
03:49:18 <koz_> Or 'dirty trick'.
03:49:57 <Rembane> That mappend looks like something from Control.Arrow. 
03:50:09 <Rembane> Maybe a &&& ? 
03:50:16 <koz_> :t (&&&)
03:50:18 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
03:50:28 <mniip> that generalizes to an arbitrary applicative
03:50:31 <koz_> Not quite.
03:50:34 <mniip> mappend f g = liftA2 mappend f g
03:50:38 <mniip> mempty = pure mempty
03:50:44 <mniip> there's a newtype for that iirc
03:50:46 <merijn> koz_: It's really cool with stuff like Any/All
03:51:19 <mniip> hmm maybe not
03:51:29 <merijn> koz_: Have 10 different "a -> Bool" predicates you need to compose? Just 'coerce' them to 'a -> Any' (or 'a -> All', depending on use) and mconcat all your predicates together!
03:51:45 <koz_> merijn: Yeah, sounds about right.
03:52:15 <merijn> koz_: Works great for maintaining large sets of predicates: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/GHC.hs#L133-L155
03:52:56 <Rembane> Ach. My pattern matching is off.
03:53:08 <koz_> merijn: Woah, cool.
03:53:20 <koz_> mniip: Yeah, I think the closest to that is Alt.
03:53:37 <merijn> koz_: In fact, the entire surrounding 150 or so lines is just multiple different uses of Monoid for all sorts of things :)
03:53:53 <koz_> merijn: I have monoids on the brain lately, so this brings me joy.
03:54:14 <merijn> koz_: I'm also really proud of this composable way of doing version gating: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/GHC.hs#L59-L62
03:54:19 <koz_> How does the old saying go? 'Give me a monoid and I'll compose you a universe? Associatively.'
03:54:54 <MarcelineVQ> We used to worry about the coming monoids, but now we are all monoids.
03:54:55 <merijn> Should I ever need it I can just add a corresponding "to :: Monoid m => [Int] -> m -> m" to go along with it and everything will "just work"
03:57:13 <koz_> merijn: Thank you for showing me, once again, that monoids are amazing.
03:57:58 <merijn> koz_: Another use of Monoids and the function monoid instance is lexicographical ordering by mappend'ing "comparing"
03:58:01 <merijn> :t comparing
03:58:02 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
03:58:10 <koz_> I'm familiar with that one.
03:58:10 <merijn> (Ordering is a Monoid instance)
03:58:27 <koz_> c.f. Down as well.
03:58:33 <merijn> koz_: Yes, but I mean you can just directlyg do "mconcat [comparing fst, comparing snd]"
03:58:39 <merijn> (or something more complicated
03:58:51 * hackage kind-apply 0.1.0.0 - Utilities to work with lists of types  http://hackage.haskell.org/package/kind-apply-0.1.0.0 (AlejandroSerrano)
03:58:51 <merijn> because of the Monoid instance on functions
03:59:15 <merijn> Getting back "b -> b -> Ordering"
03:59:25 <merijn> No lambda's or ugly wrapping/unwrapping :)
03:59:30 <merijn> No manual nonsense!
04:00:18 <Axman6> > sortBy (comparing snd <> comparing fst) $ (,) <$> "ABC" <$> [1,2,3]
04:00:21 <lambdabot>  error:
04:00:21 <lambdabot>      • Couldn't match expected type ‘Integer -> (a, a1)’
04:00:21 <lambdabot>                    with actual type ‘[b0 -> (Char, b0)]’
04:00:37 <Axman6> > sortBy (comparing snd <> comparing fst) ((,) <$> "ABC" <*> [1,2,3])
04:00:40 <lambdabot>  [('A',1),('B',1),('C',1),('A',2),('B',2),('C',2),('A',3),('B',3),('C',3)]
04:01:00 * hackage kind-generics 0.1.0.0 - Generic programming in GHC style for arbitrary kinds and GADTs.  http://hackage.haskell.org/package/kind-generics-0.1.0.0 (AlejandroSerrano)
04:01:14 <koz_> Axman6: I mentally filled in the ZipList instance there. :P
04:02:59 <Axman6> > sortBy (comparing snd <> comparing fst) ((\a b -> [a,b]) <$> "ABC" <*> "XYZ")
04:03:01 <lambdabot>  error:
04:03:01 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘(a, a1)’
04:03:01 <lambdabot>        Expected type: [(a, a1)]
04:03:27 <Axman6> > sortBy (comparing (!!1) <> comparing (!!0)) ((\a b -> [a,b]) <$> "ABC" <*> "XYZ")
04:03:29 <lambdabot>  ["AX","BX","CX","AY","BY","CY","AZ","BZ","CZ"]
04:22:30 <Taneb> Is there a way to have two copies of a target in a cabal file but passing in different flags to GHC? (in particular, difference CPP defines)
04:23:08 <merijn> No, but with common stanzas in the most recent cabal you can define a single stanza and share it between two targets
04:23:17 <merijn> Setting the GHC flags different in each
04:24:07 <mniip> hmm
04:25:10 <Taneb> merijn: I'm not sure that's an option for me :(
04:25:12 <merijn> Taneb: Alternatively, define a cabal flag that controls the CPP flags, but then you can't build both simultaneously
04:25:15 <merijn> Taneb: Why not?
04:26:39 <Taneb> Large pile of packages tied to nixpkgs 18.03 and updating cabal feels like it's going to involve updating a lot more and I don't feel like doing that right now
04:26:45 <cocreature> you don’t even need the most recent cabal for that. 2.2 is sufficient
04:27:09 <Taneb> (We're currently on 2.0)
04:27:57 <merijn> Taneb: Cabal-install should be backwards compatible
04:29:11 <merijn> Unless you're using GHC older than, like 7.10 or something
04:29:20 <merijn> Maybe even then it should still work...
04:29:50 <merijn> Taneb: So yeah, afaik you shouldn't need to update anything other than cabal-install
04:32:26 --- mode: glguy set +v smitop_
04:37:50 <Solonarv> mniip: the newtype for lifting a monoid into an applicative pointwise is Ap, it's in base-4.12 IIRC
04:38:25 <mniip> wouldn't quite call it pointwise
04:38:31 <mniip> for an aribtrary applicative
04:39:25 <Solonarv> if I knew a better word, I'd use that
04:39:40 <mniip> the fact that applicative is a lax monoidal functor comes to mind
04:39:43 <Solonarv> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:Ap
04:39:56 <mniip> so the same way you push products and terminals through the functor you can push a monoid object
04:41:51 <Rembane> How do you use Ap? 
04:43:33 <Solonarv> in combination with foldMap, most of the time
04:44:03 <Rembane> :t foldMap Ap
04:44:04 <lambdabot> error:
04:44:05 <lambdabot>     • Data constructor not in scope: Ap :: a -> m
04:44:05 <lambdabot>     • Perhaps you meant one of these:
04:44:20 <Rembane> lambdabot doesn't give me an intuition.
04:44:21 <Solonarv> Ap is fairly new, I don't think lambdabot has it
04:44:54 <Solonarv> % :t getAp . foldMap Ap
04:44:54 <yahb> Solonarv: forall k (t :: * -> *) (f :: k -> *) (a :: k). (Foldable t, Monoid (Ap f a)) => t (f a) -> f a
04:46:04 <Rembane> Nice! 
04:46:26 <Solonarv> % :t getAp @Type . foldMap Ap -- slightly less confusing
04:46:27 <yahb> Solonarv: (Foldable t, Applicative f, Monoid a) => t (f a) -> f a
04:46:27 <cocreature> % Ap (ZipList [Sum 1, Sum 2]) <> Ap (ZipList [Sum 1, Sum 2])
04:46:27 <yahb> cocreature: Ap {getAp = ZipList {getZipList = [Sum {getSum = 2},Sum {getSum = 4}]}}
04:47:33 <merijn> Needs more coerce
04:54:29 <mniip> hmm
04:54:42 <mniip> I'll be doing some maintenance on yahb soon
04:54:52 <mniip> hopefully that won't compromise the sandbox
04:56:22 <Taneb> Hmm, is Ap f (Dual a) ~ Ap (Backwards f) a?
04:56:32 <Taneb> (where ~ is monoid isomorphism)
04:57:32 <Solonarv> hmm...
04:58:10 <lyxia> Ap (Backwards f)  also composes the *effects* right-to-left
04:58:18 <cocreature> Taneb: I don’t think it is. Backwards changes the order of the effects, Dual doesn’t
04:59:17 <Taneb> Hmm, yeah
05:02:19 <Solonarv> informal reasoning: https://gist.github.com/Solonarv/74a6880e99c7823fc59832f7a4b4dc39 @Taneb
05:02:39 <cocreature> and Backwards _only_ changes the order of effects, it doesn’t change the order of the monoid operation
05:03:06 <Taneb> Right, I was completely off track :D
05:03:10 <cocreature> > Ap (Identity (Dual (Last True))) <> Ap (Identity (Dual (Last False)))
05:03:12 <cocreature> % Ap (Identity (Dual (Last True))) <> Ap (Identity (Dual (Last False)))
05:03:12 <yahb> cocreature: ; <interactive>:27:26: error:; * Couldn't match expected type `Maybe a' with actual type `Bool'; * In the first argument of `Last', namely `True'; In the first argument of `Dual', namely `(Last True)'; In the first argument of `Identity', namely `(Dual (Last True))'; * Relevant bindings include it :: Ap Identity (Dual (Last a)) (bound at <interactive>:27:1); <interactive>:27:62: 
05:03:12 <lambdabot>  error:
05:03:12 <lambdabot>      • Data constructor not in scope:
05:03:12 <lambdabot>          Ap :: Identity (Dual (Last a0)) -> m
05:03:27 <cocreature> % Ap (Identity (Dual (Data.Semigroup.Last True))) <> Ap (Identity (Dual (Data.Semigroup.Last False)))
05:03:27 <yahb> cocreature: Ap {getAp = Identity (Dual {getDual = Last {getLast = True}})}
05:03:41 <Solonarv> the identity you're looking for is Dual (Ap f a) ~= Ap (Backwards f) (Dual a)
05:03:44 <cocreature> % Ap (Backwards (Identity (Last True))) <> Ap (Backwards (Identity (Last False)))
05:03:44 <yahb> cocreature: ; <interactive>:29:5: error:; * Data constructor not in scope: Backwards :: Identity (Last a0) -> f a; * Perhaps you meant variable `backwards' (imported from Control.Lens); <interactive>:29:46: error:; * Data constructor not in scope: Backwards :: Identity (Last a1) -> f a; * Perhaps you meant variable `backwards' (imported from Control.Lens)
05:04:02 <cocreature> % Ap (Control.Applicative.Backwards.Backwards (Identity (Last True))) <> Ap (Control.Applicative.Backwards.Backwards (Identity (Last False)))
05:04:02 <yahb> cocreature: ; <interactive>:30:61: error:; * Couldn't match expected type `Maybe a' with actual type `Bool'; * In the first argument of `Last', namely `True'; In the first argument of `Identity', namely `(Last True)'; In the first argument of `Control.Applicative.Backwards.Backwards', namely `(Identity (Last True))'; * Relevant bindings include it :: Ap (Control.Applicative.Backwards.Backwar
05:04:11 <cocreature> % Ap (Control.Applicative.Backwards.Backwards (Identity (Data.Semigroup.Last True))) <> Ap (Control.Applicative.Backwards.Backwards (Identity (Data.Semigroup.Last False)))
05:04:12 <yahb> cocreature: Ap {getAp = Backwards (Identity (Last {getLast = False}))}
05:06:05 <Solonarv> uh.. I don't think Backwards Identity is meaningfully different from just Identity; there aren't any effects to reverse the order of!
05:06:47 <cocreature> right, I was trying to demonstrate that this does not reverse the underlying Monoid operation
05:08:06 <Solonarv> ah, right
05:10:21 <Taneb> Probably more correct thing: Const (Dual m) ~ Backwards (Const m) (as applicatives)
05:18:50 <Solonarv> yes, that's definitely true - but it doesn't have anything to do with Ap
05:19:47 <Taneb> It has a lot to do with what my brain was doing ;)
05:25:48 <delYsid> Hmm, libraries/unix in GHC depends on time < 1.9, but time 1.9.2 is now in.  And there appear to be two time repos, one on github with the fix, and one at git.haskell.org without the fix.  Wha?
05:39:54 <merijn> delYsid: git.haskell.org is, presumably, just a mirror of what shipped with GHC
05:41:51 * hackage hw-streams 0.0.0.4 - Primitive functions and data types  http://hackage.haskell.org/package/hw-streams-0.0.0.4 (haskellworks)
05:54:24 --- mode: barjavel.freenode.net set +o Sigyn
06:02:51 --- mode: glguy set +v fen
06:06:51 --- mode: glguy set +v gentauro
06:06:56 <gentauro> Is there a timeline for Monads? I'm guessing it all started with Moggi and then with Danvy/Filinski, but is there somewhere this is stated?
06:07:21 --- mode: glguy set -v gentauro
06:08:40 <merijn> gentauro: There was a "history of Haskell" written down at some point, which I guess might mention that?
06:08:52 <merijn> gentauro: But I don't think there's a very concrete text about it, why?
06:09:08 <jose_zap> the SPJ talk about haskell's history mentions a few things about it
06:10:27 <jose_zap> gentauro this is where the do notaion was announced, https://www.haskell.org/definition/from12to13.html
06:11:02 <gentauro> Moggi 1988, Danvy/Filisnki 1991, Wadler 1992 ...
06:11:54 <phadej> there was a reddit /r/haskell question/thread about do-notation this year
06:12:23 <phadej> (do notation was originally in https://en.wikipedia.org/wiki/Gofer_(programming_language))
06:12:30 <jose_zap> this one? phadej https://www.reddit.com/r/haskell/comments/9gbbwv/do_notation_is_20_years_old_today/
06:12:46 <phadej> jose_zap: probably, thanks!
06:12:59 <merijn> It's a shame augustss isn't here very often anymore to ask these details :p
06:15:21 <aiowej> Hi! Does Haskell have Phil Bagwell-style collections, such as hashtriemap or the vector made of a trie? Scratching my head as I'm implementing a compiler/typechecker, and am pondering whether to even include the List type at all, and why haskellers use List rather than something like a vector. Is there some benefit, or is it just not a big deal, or does GHC optimize this somehow? 
06:15:40 <dminuoso> aiowej: We have `vector` =)
06:15:46 <dminuoso> aiowej: It's just not in base, that's all.
06:15:51 <merijn> aiowej: In a lazy setting lists are basically "loops waiting to happen"
06:16:13 <phadej> yes, lists are "control structures" quite often, not only "data structures"
06:16:30 <merijn> aiowej: Lists and vectors are used for very different things. For example, you can easily "unroll" a vector on-demand, it can't be sensibly infinite, etc.
06:17:28 <merijn> aiowej: People use lists because often the performance just doesn't matter, or accesses are completely sequential. If you need truly random access, then yes lists suck. But we have multiple alternative datastructures
06:21:27 <aiowej> Interesting. My compiler produces eagerly evaled programs - so having loops waiting to happen isn't of use then. Thanks everyone for the answers - think I'll go with having Tuples (for program representation - code is data like in lisp), Vectors, HashTrieMap and HashTrieSet in the stdlib, and then you can define lists using union types. Fucking looooove this hobby, it's consuming me...  
06:24:46 <ScriptRunner> Hi everyone, whats the best way of using the mouse to draw with haskell. Thanks for any help.
06:25:10 <ski> dminuoso : type ascription
06:25:14 <merijn> ScriptRunner: Probably something build with gloss?
06:25:16 <fen> lists formalise a common pattern, an implementation of a language that didnt support it, and the common recursion schemes such as defined in the implmentation of Prelude classes over list, would be an incomplete tratment of a language implmentation, as it would ommit common and highly reusable patterns. 
06:25:47 <ScriptRunner> merijn: Thanks for the suggestion, I'll look into that
06:26:22 <merijn> ScriptRunner: Kinda depends on what you wanna do with the things you draw, though
06:26:47 <ScriptRunner> I'm wanting to implement an A* algorithmn
06:27:21 --- mode: glguy set +v boris_rh
06:27:30 <fen> ScriptRunner, whats the desired output? just to screen? to save an image e.g. bitmap? is it something OpenGL would be used for, does it matter about having the ability to run in a browser? what about the platform? is it supposed to compile to various architectures?
06:28:26 --- mode: glguy set +v boxscapeR
06:28:31 --- mode: glguy set -v boxscapeR
06:28:51 <fen> there was somthing about both webGl and openGl
06:29:09 <fen> not sure if gloss can use both these backends
06:29:10 <fen> https://github.com/bergey/bothgl
06:29:21 <ScriptRunner> fen: Yeah its just to the screen
06:29:52 <fen> no need to save or run in browser or e.g. android?
06:30:12 <merijn> ScriptRunner: I'm about 90% confident gloss even has examples of drawing on screen
06:31:38 <fen> try: Graphics.Gloss.Interface.IO.Game
06:32:55 <fen> and; http://hackage.haskell.org/package/gloss-1.13.0.1/docs/Graphics-Gloss-Interface-IO-Interact.html#t:MouseButton
06:34:41 <fen> a way to use gloss with WebGL would be really good
06:37:54 <fen> the ghcjs backend seems to have other options such as;http://hackage.haskell.org/package/shine
06:38:09 <fen> "Shine wraps javascript's drawing functions in a declarative API. "
06:38:21 * hackage gssapi-wai 0.1.2.3 - WAI Middleware for SPNEGO authentiaction  http://hackage.haskell.org/package/gssapi-wai-0.1.2.3 (ondrap)
06:38:33 <fen> but thats not WebGL... it does not have the support or completness of OpenGL
06:40:28 <fen> also, using ghcjs seems to be using a different compiler... does ghcjs support the same language extensions as GHC? is it maintained by the same team?
06:41:34 <merijn> fen: ghcjs is a different compiler, in some sense. But it supports the entire input language that ghc accepts
06:41:43 <merijn> It is not maintained by the same team
06:42:01 <cocreature> it’s not maintained by the same team but it reuses GHC’s compilation pipeline up to stg
06:43:35 <Solonarv> very roughly, GHCJS re-uses a large portion of GHC but emits JS instead of emitting C/LLVM/native
06:44:01 <merijn> Solonarv: GHC can't emite C anymore. Hasn't been able to for years in the release builds
06:44:16 <Solonarv> right, scratch that one then
06:46:42 <hugbubby> object oriented programming is a misnomer - change my mind
06:46:51 <fen> oh great, so the updates made to GHC are immidiatly available to GHCjs compiler...
06:46:56 <fen> what about libraries?
06:47:13 <fen> can standard OpenGL be compiled strait to js to use in a browser?
06:47:24 <fen> wouldnt that kind of mean WebGL wasnt needed?
06:47:38 <cocreature> anything that uses the C ffi doesn’t work easily with ghcjs
06:47:43 <cocreature> which includes opengl
06:47:51 <merijn> fen: "immediately" <- well, for some value off
06:48:02 <merijn> fen: ghcjs has to be updated to support the new GHC release
06:49:47 <fen> oh no!
06:50:00 <fen> is there no pure haskell solution?
06:50:14 <merijn> fen: In what way is ghcjs not pure Haskell?
06:50:27 <fen> no,t ghcjs, OpenGL
06:50:33 <merijn> ah
06:51:07 <merijn> You can make WebGL bindings for ghcjs (or check if someone already has), but libraries using OpenGL probably don't support that directly
06:51:32 <fen> hmm, how would mouse input be used in js... is that why the C ffi is needed, to access those APIs (e.g. for mouse io)
06:51:53 <hodapp> IIRC, WebGL also only supports something closer to a subset of OpenGL.
06:51:54 <merijn> fen: In JS you'd use mouse events from the browser
06:52:07 <hodapp> mostly based around GLSL.
06:52:14 <fen> merijn: so why is WebGL ok for use with ghcjs?
06:52:37 <merijn> fen: Because WebGL supporting browsers have a JS API for it?
06:52:39 <hodapp> because one writes WebGL in Javascript
06:52:50 <merijn> fen: ghcjs doesn't support a C FFI, but it supports a JS FFI
06:53:34 <fen> ah, so where OpenGL uses C forign functions for things like mouse io, WebGL would use the corresponding js calls?
06:53:56 <cocreature> ghcjs has a js ffi instead of a c ffi
06:54:08 <cocreature> so you can access all the usual browser APIs
06:54:08 <fen> right
06:54:54 <fen> and probably android io calls (e.g. tilt) which are available in java ?
06:55:25 <fen> or is android java and js totally unrelated?
06:55:28 <merijn> fen: If the browser has a JS API for it, you can access it via FFI from ghcjs
06:55:37 <cocreature> java and javascript have nothing to do with each other
06:55:41 <merijn> fen: Java is completely unrelated to JavaScript
06:55:47 <ClaudiusMaximus> Emscripten does C to JS, any way to combine it with GHCJS to get a C FFI in the browser?
06:55:47 <cocreature> regardless of whether it’s android java or not
06:56:04 <merijn> ClaudiusMaximus: Yes
06:56:12 <merijn> ClaudiusMaximus: But that way lies pain and madness :)
06:56:20 <fen> just thinking that using the browser as an middle level to traslate the phone hardware features into js calls (as this interface is well maintained by the browser company)
06:56:24 <merijn> ClaudiusMaximus: Better of waiting for better Web ASM support in GHC
06:56:29 <ClaudiusMaximus> ok
06:56:49 <hodapp> fen: JS already exposes a lot of this, but some of it isn't really standardized
06:57:09 <hodapp> but you can, for instance, access phone cameras and Bluetooth (to an extent)
06:57:18 <cocreature> you can run the js compiled with ghcjs in a webview on a phone
06:57:46 <cocreature> or you can use some kind of weird jsaddle-style hybrid that is used by reflex
06:57:53 <fen> hodapp: seems like thats what either targeting the browser for phone apps or making them target android java or android c directly
06:58:01 <fen> depends on
06:58:29 <fen> cocreature: whats that? is it a viable soultion
06:58:30 <fen> ?
06:58:49 <fen> the good thing about compiling to naitive android is that then the apps can be deployed on the play store
06:59:18 <cocreature> it’s used by some companies, in particular obsidian
06:59:23 <fen> probably there is a similar situation with the apple store? or is haskell easier to make mac apps with?
06:59:28 <cocreature> so yeah I’d say it’s viable but I haven’t used it myself
07:00:51 <cocreature> basically jsaddle abstracts over the interaction with js so you can either compile your code with ghcjs and run it in a browser, or you can compile it natively to android where a webview is used to display the ui and you communicate with that
07:00:57 <fen> maybe the easiest thing to do then is not to make a web app, but to compile to js and build wrapper to the program in android java. not sure how java really works but that might be something like importing a jar file
07:01:00 <merijn> fen: It's possible to compile Haskell for iOS or Android, but at the moment it's quite painful/involved still
07:01:23 <fen> really?
07:01:42 <merijn> fen: Android supports running machine code (like compiled Haskell), but most phones run on ARM hardware, so you have to cross-compile which is...not quite well polished atm
07:01:59 <fen> i.e. is it really that hard on iOS, and does it not just use ghcjs for android (which is whats being discussed...)
07:02:01 <merijn> If your stubborn and motivated it works, but it requires a bit of masochism
07:02:38 <merijn> fen: Cale worked on an action RPG for mobile that got quite far done, but that was a while ago, so not sure to what extend things have changed/improved
07:02:55 <merijn> fen: You can do the same for iOS with a similar amount of pain
07:03:06 <fen> the idea is to access the API provided to the phones hardware, so machine code seems like less good than js integrated into an android java app
07:03:24 <cocreature> Cale is working for obsidian these days which uses the jsaddle-solution I mentioned above
07:03:35 <fen> hmm
07:03:57 <fen> isnt that GPU stuff?
07:04:11 <fen> oh, guess thats why the graphics libs are relavent 
07:05:02 <mniip> yahb seems to be back in order, save for a minor issue where it can't resolve tcp.st
07:05:21 <mniip> % fix $ (0:) . scanl (+) 1
07:05:27 <yahb> mniip: [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,53316291173,86267571272,139583862445,22585143371
07:08:11 <orion> Hi. This error occurs when building my package with the nightly resolver. It makes no sense to me: "hlint needed, but the stack configuration has no specified version  (latest matching version is 2.1.10)"
07:08:17 <orion> All my package.yaml file is asking for is hlint. hlint is on stackage: https://www.stackage.org/package/hlint/snapshots
07:08:22 <orion> I never specified a hlint version, so shouldn't it match against any version?
07:11:08 --- mode: glguy set +v azgralion
07:11:37 <azgralion> Hello is anybody here?
07:12:55 <boxscapeR> feel free to ask a question, if people are here, they will answer, azgralion
07:13:05 --- mode: glguy set +v fen_
07:15:13 <hugbubby> So how efficient has haskell gotten in recent years?
07:15:21 <boxscapeR> orion: haven't used stack in a while, but right now it sounds to me like you're using the latest nightly snapshot (2018-10-30), while your link shows that the latest nightly snapshot to have hlint is 2018-10-28?
07:15:48 <hugbubby> compared on a gradient from C/Go/C++/Java/Python
07:15:50 <merijn> hugbubby: What's your metric for efficiency?
07:15:50 * hackage nuxeo 0.3.0.0 -   http://hackage.haskell.org/package/nuxeo-0.3.0.0 (apeyroux)
07:16:21 <azgralion> I would like to know, if anyone has some idea for school project to do in haskell? Last things I did, was conversion from non-finite automaton to finite automaton and regular expression evaluation. So I am looking for some nice alghorithm to write in max 200 LOC. :)
07:16:41 <merijn> hugbubby: Does that ordering imply C is more efficient than Go, Go more efficient than C++, etc.? Because if so, that's already plenty questionable :)
07:16:54 <hugbubby> C/C++/Go*
07:17:04 <orion> boxscapeR: Oh man, good eye!
07:17:04 <hugbubby> imo
07:17:42 <merijn> What makes you put Java last? The JIT in the JVM is pretty amazing and can definitely beat C on some benchmarks...it all depends on the problem, implementation, compiler quality, etc.
07:17:55 <dmwit> Idiomatic C and idiomatic Haskell are generally about a factor of 2x speed difference for the same algorithm.
07:18:08 <dmwit> Tuned C and tuned Haskell are generally on par with each other.
07:18:18 <orion> boxscapeR: The diff doesn't show hlint being removed though: https://www.stackage.org/diff/nightly-2018-10-28/nightly-2018-10-29
07:18:37 <boxscapeR> orion: I just realized that the latest nightly snapshot from your link is 2018-09-28, i.e. september not october
07:18:58 <hugbubby> I would really like to see the problem for which java can do somethin faster than C
07:19:04 <orion> boxscapeR: Ah, yup. :/
07:19:26 <orion> So I guess my package can't be included in stackage because it requires hlint.
07:19:39 <merijn> dmwit: I have a Haskell port of a (trivial) C algorithm, which is 50% slower than the original C, but *faster* when used in the actual code, as GHC further optimises the Haskell compared to calling the C FFI
07:20:06 <fen_> yeah haskell is faster than C and Java
07:20:33 <maerwald> huh?
07:20:35 <merijn> hugbubby: Probably horrifically outdated, but see: https://www.stefankrause.net/wp/?p=4
07:20:49 <fen_> less time on runtime errors
07:21:00 <fen_> less time reinventing the wheel
07:21:02 <merijn> The slowness of Java is grossly exaggerated, because people always think of bloated factory, factory, instance handler, factories
07:21:11 <fen_> more time compiling, less time running!
07:21:41 <Solonarv> hugbubby: JIT compilation allows for some optimizations that aren't possible with AOT compilation, because it happens at runtime, where more things are known
07:21:43 <maerwald> dmwit: I don't think tuned C and tuned haskell are on par at all
07:21:44 <fen_> more time typechecking, less time on runtime errors
07:21:47 <fen_> fast fast fast
07:22:07 <maerwald> because you have way more tools to tune in C
07:22:27 <hodapp> a lot of people are still pretty much just quoting '90s memes when it comes to Java slowness
07:22:32 <fen_> like, what does a business care about most in terms of fastness? maintainance? adaptability? maintainability?
07:22:42 <hodapp> the JVM has had a crazy amount of optimization done in the past 2 decades or so
07:23:14 <fen_> but then you just compile up all the optimisation autmoation and recompile via haskell and its fast
07:23:22 <maerwald> and if you want to tune performance, you first have to 1. reason about performance and 2. debug performance bottlenecks... both is very hard in haskell
07:23:32 <hodapp> fen_: there are some specific problems where Haskell may have a performance edge but in general tuned C is almost always going to be faster
07:23:45 <fen_> common subexpression memoisation and ellimination 
07:24:00 <hugbubby> haskell beats C every time on multithreading though, I'd bet. Multithreading in C makes my head ache.
07:24:02 <hodapp> it may not be enough faster to matter, but it depends on the problem
07:24:30 <hugbubby> im really coming to hate object oriented programming languages for how hard they make tasks like multithreading
07:24:37 <fen_> hodapp: dmwit said pretty much the opposite of that a few lines above.
07:24:52 <fen_> (about tuned C)
07:25:36 <merijn> hugbubby: Haskell is definitely much better when you consider the combination of time to implement + debug in relation to achieved performance
07:25:40 <fen_> anyway, normally it just matters if your program runs and does what its supposed to.
07:25:49 <fen_> which is way easier to do in haskell
07:26:02 <merijn> And generally Haskell's performance is "good enough" and replacing slow bits with faster implementations is generally easy enough
07:26:06 <fen_> making use of higher order functional programing paradigms for ease of maintainable code
07:26:31 <fen_> merijn: so its "easier to tune" ?
07:26:36 <hodapp> fen_: that's not really "pretty much the opposite"; I wasn't talking so much about tuned Haskell code there
07:26:38 <fen_> what about all these fancy C tuning tools?
07:26:48 <maerwald> merijn: I would say naive implementations are likely faster in haskell, which is a nice property
07:27:09 <maerwald> but as soon as you go the hardcore route, it's very hard to achieve similar performance
07:27:31 <fen_> hodapp: comparing a slow haskell implmentation with a fast C implementation is pretty similar to comapring a fast haskell implementation to a slow C implementation. basically uninformative!
07:27:38 <Wizek> Hello
07:27:51 <hodapp> fen_: comparing speeds is almost never informative
07:27:53 <Wizek> What can cause stack to enter into an "unregister loop"?
07:27:54 <hodapp> yet here we are
07:28:22 <fen_> what maerwald just said is pretty much the standard view
07:28:24 <fen_> but why?
07:28:29 <merijn> fen_: I mean, the C FFI from Haskell is absolutely lovely. People used to call python the "high level glue for C"
07:28:38 <fen_> why is there this idea that haskell cant be made as fast as C easily?
07:28:40 <merijn> fen_: But I think Haskell is an even better "high level glue for C"
07:28:56 <maerwald> fen_: have you tried?
07:28:59 <merijn> FFI to C is cheap, easy, low effort
07:29:02 <maerwald> I mean, not just for quicksort...
07:29:04 <Wizek> I get the same 7 packages unregistered even if I build without changing anything
07:29:08 <Wizek> and rebuilt
07:29:20 <hodapp> fen_: uh, probably from actual empirical tests, regardless of how contrived they might be
07:29:32 <fen_> maerwald: i write all my C using GHC
07:29:41 <merijn> It depends on the kind of C you wanna write too
07:29:49 <maerwald> fen_: that doesn't answer my question
07:29:57 <fen_> come on, industrial code is millions of lines long
07:29:59 <merijn> I mean, if you're doing lots of read only vector indexing, that's pretty easy to make fast
07:30:31 <fen_> its a problem of code reuse, standardised approaches and the resulting legibility and maintainablity 
07:30:40 <fen_> thats the only really industrially relavent aspect
07:30:49 <Wizek> stack build --dry-run tells me the list
07:30:51 <fen_> as at the end of the day haskell can be made to run very fast
07:31:01 <maerwald> fen_: the reasons are as I already explained. In order to write performant code, you need to be able to 1. easily reason about performance and 2. debug performance. Both is not easy in haskell
07:31:09 <Wizek> "Would unregister locally", but doesn't tell me why
07:31:23 <maerwald> 1. because of laziness and a lot of indirection, 2. because we don't even have a callstack
07:31:35 <hodapp> a lot of things make something "industrially relevant", and maintainability and legibility can often be low on the list
07:31:37 <fen_> fast fast fast5
07:32:06 <fen_> hodapp: hence the shocking state of industrial code today
07:32:18 <hodapp> fen_: what "industrial code" are you talking about?
07:32:21 * hackage bench-show 0.2.2 - Show, plot and compare benchmark results  http://hackage.haskell.org/package/bench-show-0.2.2 (harendra)
07:32:44 <fen_> like bank code, trading code e.t.c. to security systems - like OpernSSL
07:33:03 <fen_> OpenSSL even had a bug in because it was so hard to read
07:33:17 <maerwald> GHC never had bugs :>
07:33:49 <fen_> heartbleed affected millions of devices and made SSL - the most fundamental security layer to networked devices - untrusted until it was repared 
07:34:10 <maerwald> err, crypto in haskell is more problematic than in C =)
07:34:24 <hodapp> also you just shifted from speed to security for some reason
07:34:27 <fen_> industrial codes poor design (which could be blamed on bad language choice) is a serious global situation
07:34:40 <hodapp> it could be blamed on the Jews, too
07:34:43 <hodapp> but are you trying to make sense?
07:35:09 <fen_> speed in terms of hours of work is a more significant metric than the codes actuall performance is the argument that im making
07:35:24 <maerwald> that's not generally true
07:35:34 <hodapp> that also doesn't sound anything like the argument you were making
07:35:36 <fen_> and that talking about "fast code" is detracting from the real advantages of using higer order languages
07:35:57 <hodapp> then why did you say "fast fast fast" several times in a row?
07:36:20 * hackage nuxeo 0.3.0.1 -   http://hackage.haskell.org/package/nuxeo-0.3.0.1 (apeyroux)
07:36:38 <hugbubby> fen_, you realize in some cases it's very important to get the fastest code, more important than development speed. that is an actual use case for a language
07:36:51 <hugbubby> there are industries out there like high frequency trading where milliseconds matter
07:37:06 <hugbubby> not saying that you're not right in most scenarios but that's not really what we're talking about
07:37:12 <Putonlalla> No rule to make `sense`.  Stop.
07:37:27 <fen_> because as well as being eaiser to read - shorter with good code reuse using established termanology and well documented traditionally estableshed approaches and standards, its also FAST in the way that for some unknown reason, issomething that people talk about as if it were some unsolved problem
07:37:36 <hodapp> it is indeed, and "fastest" can also mean a lot of different things (high throughput, extremely low average latency, latency that is guaranteed below a known limit)
07:37:47 <hyperisco> Putonlalla, the wisdom of makefiles
07:37:54 <maerwald> haskell is not easier to read even!
07:37:56 <fen_> hugbubby: YES! but the way you phrase it sounds like this is something haskell can do easily!
07:38:11 <hodapp> there are applications where the only way for code to be "correct" is for it to meet some kind of performance requirement
07:38:15 <hodapp> hard realtime is one
07:38:15 <lone_ranger> can a function be defined anonymously in haskell? or does it become an expression
07:38:18 <maerwald> The argument for haskell is only one thing, imo: refactoring! That is easy.
07:38:35 <hyperisco> lone_ranger, both things you said are true
07:38:46 <maerwald> I mean in terms of: explain the advantage to someone who doesn't care about languages at all (e.g. business people)
07:39:21 <fen_> hugbubby: there are high frequency trading companies using higher order languages, with bleedingly fast code! and they will survive in the long run because of thier language choice, well, providing the code itself isnt badly written, but thats another issue
07:39:27 <fen_> another important issue
07:39:38 <fen_> which is how easy it is for people to mess up
07:39:40 <fen_> or not
07:39:46 <fen_> given the choice of language
07:39:53 <Solonarv> "\x y -> blah" is en expression. that expression's value is a function. the function doesn't have a name, so it's anonymous.
07:39:55 <hodapp> fen_: actually, they'll probably die in the long run because they're hedge funds
07:40:11 <fen_> a good C coder is very valuble, because of how much experience is needed to avoid common pitflls of badly designed programs
07:40:13 <machined1od> How's it going?
07:40:29 <fen_> hodapp: but thier code will be good
07:40:32 <lone_ranger> Solonarv: thank you, but does it awlays require a lamda?
07:40:58 <hodapp> fen_: except for if it's not, because it was written by a bunch of coked-up traders
07:41:22 <merijn> lone_ranger: All values in Haskell are always expressions
07:41:26 <merijn> lone_ranger: What else would they be?
07:41:36 <Solonarv> no, you can use combinators like (.) to make functions too
07:41:46 <fen_> hodapp: the traders dont write the code you fool!
07:41:59 <fen_> that would be hilarious, like twitch writes OCaml
07:42:05 <Solonarv> or partial application of other, previously-defined functions
07:42:55 <hodapp> fen_: they typically employ people who have some actual trading experience
07:43:41 <merijn> hodapp: Not if judging by the recruiters contacting me :p
07:43:46 <hyperisco> you guys here that? I think there's a conversation lost in the weeds over there
07:44:47 <fen_> yeah, hilarious if billions of peoples lives depended on its smooth functioning 
07:45:33 <hugbubby> nowadays lots of stock traders are learning to code. it's becoming a thing.
07:45:50 <lone_ranger> merijn: ok, let me see if I understand is fac n = product [1..n] is function since it has an argument, but odd_sum = sum [1,3..100] is not
07:45:52 <Putonlalla> Are you suggesting hft has a meaningful impact on the world?
07:46:23 <Solonarv> lone_ranger: both of those are *declarations*
07:47:05 <fen_> haskell is the superglue the buisness world needs
07:47:28 <lone_ranger> Solonarv: yeah but fac is a function right?
07:47:30 <Solonarv> the first one says "whenever I write 'fac', I mean '\n -> product [1..n]'". The second one says "whenever I write 'odd_sum', I mean 'sum [1,3..100]'"
07:47:41 <Solonarv> yes, 'fac' is a function
07:47:41 <merijn> lone_ranger: Correct
07:47:46 <hyperisco> fen_, C is a little closer to how our computers operate. That is why you can achieve some efficiencies in C that you cannot in Haskell. Simple.
07:47:57 <hodapp> I can suggest another superglue that the business world needs, and exactly where it might be applied
07:48:00 <merijn> hyperisco: Not on any current hardware
07:48:17 <hyperisco> Well you're wrong.
07:48:28 <merijn> C is close to the C abstract machine, which behaves like a PDP-11 or something
07:48:37 <hodapp> obligatory (re: C): https://queue.acm.org/detail.cfm?id=3212479
07:48:55 <merijn> Compilers then twist those semantics into crazy bends to execute on multi-scalar out of order execution CPUs
07:49:11 <hyperisco> if you go back, I said "a little closer"
07:50:42 <hyperisco> but if it bothers you that much, then it is a little closer in some ways that Haskell is not, so in those ways it can have an advantage
07:52:31 <Ariakenom> hyperisco: but such a weak claim means the conclusion doesn't follow
07:52:31 <sm> Welkin: I saw that you're using pollen for your site.. what's that like to install, manage, use etc ?
07:52:41 <sm> for a haskeller
07:52:46 <hyperisco> I hate you all.
07:52:47 <Ariakenom> not that I necessarily disagree. no comment
07:53:06 <rain2> I would like to learn the basics of effect type systems, can you recommend a paper?
07:53:25 * hyperisco retreats to isolation on the mountaintop
07:53:58 <hugbubby> got a question btw
07:54:37 <hugbubby> my compsci professor told me recursive factorial is bad and inefficient. If I try to define it that way in haskell will I be bad and inefficient?
07:54:50 <hugbubby> or will the compiler do some wizardry that makes it not so bad
07:55:23 <tdammers> well, at least C lacks the garbage collection abstraction; manually manipulating pointers and memory addresses definitely is a few abstraction layers closer to the hardware than haskell's garbage-collected lazy pure evaluation semantics
07:55:25 <hyperisco> I think it is generally inappropriate to cast moral judgements on people for their programs
07:55:50 <merijn> hugbubby: Recursive factorial in Haskell should end up fairly efficient, tbh
07:56:15 <hugbubby> hyperisco: you havent seen the code I've seen
07:56:21 <Solonarv> with optimizations turned on it should compile to more or less the same machine code as a simple loop in e.g. C
07:56:25 <tdammers> obligatory: https://www.willamette.edu/~fruehr/haskell/evolution.html
07:57:30 <rain2> hugbubby: recursive is fine
07:57:32 <hyperisco> hugbubby, if you trade efficiency for beauty and simplicity, that's justifiable, or at least arguable
07:59:01 <hodapp> also, tail-recursive factorial can be pretty much identical in performance to iterative
07:59:46 <inkbottle> hugbubby: `foldl (*) 1 [1..3]` might be tail recursive
08:00:04 * Solonarv hisses
08:00:09 <hyperisco> hugbubby, I'm just too exhausted nowadays to worry about whether something is fast. Too many other things to do.
08:00:11 <Solonarv> use foldl' not foldl
08:00:13 --- mode: glguy set +v imp0s5ible
08:00:20 <inkbottle> or it would be in a strict language
08:00:28 <inkbottle> ;)
08:00:57 <hugbubby> efficiency is for nerds
08:01:25 <asheshambasta> When defining a function within a typeclass for an instance (i.e. overriding its default), is it possible to "call" thedefault super-implementation for some cases? 
08:02:20 <lone_ranger> ok so if I want to apply that to a list, it would be foldl fac 0 [1,2,3], I'm just wondering if you can "define" fac in that expression
08:02:24 <merijn> asheshambasta: "super implementation"?
08:02:26 <lone_ranger> where clause?
08:02:29 <merijn> asheshambasta: You mean the default code?
08:02:35 <asheshambasta> merijn: yeah
08:02:37 <ski> `foldl' is tail-recursive (and hence bulky), `foldr' is not tail-recursive (it can be incremental, depending on the callback)
08:02:47 <merijn> asheshambasta: Not if you mean for the current instance
08:03:11 <ski> lone_ranger : lambda ?
08:03:15 <Solonarv> hugbubby: that squares with the stereotype of the jocky coder who does "modern web dev" using at least 12 JS frameworks
08:03:20 <lyxia> the default implementation needs to be defined in a separate toplevel binding
08:03:26 <asheshambasta> merijn: yeah that is what I meant:  I wanted to do something like methodWithDefault (SomeDataConsPattern) = myImplementation 
08:03:48 <jose_zap> I'm confused, why is laziness cited as a problem for performance while at the same time an optimization pass is called full-laziness ?
08:03:48 <lone_ranger> ski: yeah that withstanding
08:03:49 <asheshambasta> and methodWithDefault o = default . methodWithDefault $ o 
08:04:14 <asheshambasta> but ok, I see that is probably not possible
08:04:28 <Solonarv> laziness-as-a-language feature makes it harder to reason about performance, which makes optimization more difficult
08:04:51 * hackage nuxeo 0.3.0.2 -   http://hackage.haskell.org/package/nuxeo-0.3.0.2 (apeyroux)
08:05:13 <Solonarv> but the essence of laziness is "not evaluating things you don't need to", which has obvious performance benefits
08:05:32 <hugbubby> Solonarv: If I ever own my own business I will ruthlessly discriminate against JS programmers
08:10:37 <phadej> fwiw, writing performant JS is comparably difficult as writing performant Haskell.
08:10:54 <phadej> I bet that naive Haskell performs better though.
08:11:51 <fen_> writing performance haskell is easy!
08:11:56 <fen_> its easy to reason about
08:12:12 <hugbubby> (here we go again)
08:12:25 <hyperisco> going down the only road I've ever known
08:12:38 <fen_> so whats this PDP-11 stuff? why doesnt haskell target that?
08:12:53 <fen_> does it use some of the better features of the intermidiate C layer?
08:13:11 <hyperisco> doesn't target it because you didn't write the backend for it fen_
08:13:27 <fen_> compile C?
08:13:35 <fen_> how would that even work!?
08:13:38 <hyperisco> should get started on that immediately
08:13:42 <fen_> the gnu c compiler?
08:14:08 <merijn> fen_: PDP-11 is a computer architecture from 50 years ago...
08:14:12 <fen_> isnt there a way to port anything written in C to haskell?
08:14:29 <fen_> so the c compiler could be written in pure haskell?
08:14:49 <fen_> wait whats the C virtual machine!?
08:15:32 <fen_> is it like haLVM?
08:16:17 <Putonlalla> @google c abstract machine
08:16:20 <lambdabot> https://blogs.msdn.microsoft.com/larryosterman/2007/05/16/the-c-abstract-machine/
08:17:10 <fen_> hmm, 500 pages of C language spec
08:17:14 <fen_> attoparsec?
08:18:08 <hyperisco> you know how kids ask questions ad nauseum as an attention seeking game?
08:18:35 <fen_> wait, i can still hear hedge fund managers laughing 
08:20:10 <fen_> plenty of help writing this backend
08:20:18 <fen_> why not comment on llvm?
08:21:45 <fen_> "mer mer mer haskell is slow" - "no it isnt" - "but C!" - "ok what about it, can we do that?" - "your silly..."
08:22:44 <fen_> if the conversation actually went towards how, given that old language specs are difficult to read, consider how these legacy systems may be updated, or rewritten / complied
08:22:44 <hugbubby> didnt mean to do this hyperisco im sorry
08:23:22 <fen_> "haskell makes you write faster code"
08:23:32 <hyperisco> like a drifter I was born to walk alone
08:24:33 <hyperisco> but I've made up my mind; I'm not wasting no more time
08:24:52 <maerwald> all I read are slogans, not arguments
08:26:35 <fen_> hyperisco: whats that, beastie boys? 
08:29:34 <asheshambasta> hugbubby: the JS programmers I've met throughout my career have been some of the worst programmers I've come across.
08:30:01 <asheshambasta> hugbubby: they're also the most ignorant.
08:30:41 <hyperisco> now now, lets not type cast dynamic programmers
08:31:27 <asheshambasta> no, I'm just looking at them through the _lens_ of a Haskell programmer.
08:31:52 <boxscapeR> There seems to be some ecmaphobia going on here
08:32:02 <fen_> this is no functor
08:34:13 <hyperisco> asheshambasta, let me postulate a different criteria. There is what I call the "happy path programmer" who is pleased once the program succeeds in the best of circumstances.
08:35:30 <hyperisco> asheshambasta, this is what I do at hackathons where I have 24 hours to make a prototype. However I also know people who do this on production work.
08:36:41 <Welkin_> I have met many programmers who don't really care to understand how something works. They simply bang away at it until they get something that sort of works and move on
08:36:57 <Welkin_> and then when it breaks, they have no idea why
08:37:01 <dmwit> maerwald: Your real objection  does not seem to be to "tuned Haskell and tuned C are on par", but rather to "it is equally easy to tune Haskell and to tune C". But I never made the latter claim.
08:37:13 <asheshambasta> hyperisco: yeah I see what you mean. The thing is, this kind of happy programming over extended periods of time damages the brain of the programmer and makes the progammer too foolishly arrogant to acknowledge there are better ways to solve the problem.
08:37:21 <maerwald> dmwit: both
08:38:19 <maerwald> haskell doesn't give you the same low-level control, so there will be cases you simply cannot achieve reasnoably (no matter how long you try)
08:41:34 <hyperisco> asheshambasta, at any rate it isn't the language but rather the surrounding culture and community. I used to program PHP. Fact is, PHP attracts large numbers of new programmers. Naturally, average PHP code is worse off.
08:41:53 <orion> hyperisco++
08:42:18 <orion> Welkin: Yes!
08:42:45 <orion> I'm currently a professional python programmer, and I don't find meaning or value in my work.
08:43:08 <maerwald> Welkin: I've seen that in haskell code too :)
08:43:09 <Solonarv> PHP has the additional issue of being a horrible language
08:43:09 <Solonarv> I hear recent versions aren't as bad, but that doesn't help when cheapo web hosts only provide old versions
08:43:17 <maerwald> so in my opinion, this is language agnostic
08:43:47 <tdammers> recent versions fixed a bunch of superficial symptoms, but the language, and especially its culture, are maybe even worse for it
08:44:59 <orion> I've spoken with very intelligent people who say, "orion, isn't there a Wordpress plugin for this? What's wrong with off-the-shelf solutions for this problem?"
08:45:05 <tdammers> the worst part of PHP culture IMO is the vicious apologetic cycle - you report a flaw in something, they challenge you for an example, you provide one, they fix the example, you say that the flaw is still there, they challenge you for another example, etc.
08:45:42 <orion> Their perspective is valuable when you're trying to start a business with little time/money, but when things blow up you have a problem.
08:46:09 <orion> I wish getting management buy-in for Haskell were easier.
08:46:49 <maerwald> It isn't easy, because of employment market
08:46:54 <Welkin> orion: the secret is that management doesn't care what language you use. They just want to make monet/look good
08:46:56 <sm> I work with PHP, and there are a lot of things to enjoy. It's like a holiday.
08:46:58 <asheshambasta> orion: We've got quite a bunch of Scala in production but we're transitioning to Haskell after our initial experience with it. 
08:47:00 <Welkin> only the "engineering managers" care
08:47:04 <Welkin> and they are the worst
08:47:04 <phadej> orion: there should be Wordpress in Haskell :)
08:47:08 <maerwald> Welkin: of course they care about bus factor
08:47:10 <Welkin> has-been programmers
08:47:20 <Welkin> they don't keep up with technology
08:47:34 <orion> I empathize with the need to handle the bus factor.
08:47:46 <fen_> what factors could oppose a competative language?
08:47:55 <tdammers> one big problem in all this is that the benefits a language like Haskell provides over something like PHP aren't directly quantifyable
08:48:12 <maerwald> Especially when you are unlucky to happen to hire a very smart haskell programmer, it's likely your code will end up so complicated, the next generation of developers have no clue what is going on.
08:48:16 <orion> Is there a Heroku style service for Haskell?
08:48:27 <maerwald> So bus factor now is bad
08:48:41 <phadej> tdammers: I think it's easier to find good Haskell programmer, than good PHP programmer. Finding _a_ PHP programmer is definitely easier :)
08:48:54 <maerwald> while in other languages with very poor expressivity you can hire and fire all you want (e.g. in Go), because everything always looks the same
08:48:57 <phadej> orion: you can run Haskell on heroku
08:48:58 <Welkin> maerwald: I'd argue not-so-smart
08:49:07 <fen_> the real task seems to be consolidating the specialist experience of programmers from each language so that they can be addapted in a cross-language effort for language unification standardisation and long term maintainance 
08:49:09 <asheshambasta> maerwald: Haskell has this "click" factor, that you, as a student of it, reach at some point. 
08:49:09 <maerwald> Welkin: no
08:49:19 <maerwald> asheshambasta: huh?
08:49:24 <Welkin> if they were smart, they would write code that people can understand
08:49:28 <orion> phadej: Yeah, but I want a fancy control panel with a window in to the RTS.
08:49:33 <asheshambasta> At that time, the abstractions just "click" and you begin to really see how the pieces fit together. 
08:49:34 <maerwald> Welkin: I don't think so :)
08:49:41 <maerwald> reasonable and smart is not the same
08:49:45 <phadej> orion: is there something as fancy for PHP runtime?
08:49:45 <maerwald> there are tons of examples ;)
08:50:03 <orion> Welkin / maerwald: I wrote a huge/complicated system for a company over the course of three months totally in Haskell -- with their blessing.
08:50:20 <Welkin> complicated is not a desirable trait for software
08:50:22 <maerwald> asheshambasta: I don't understand what you are trying to say
08:50:23 <Solonarv> I'm not aware of such a window into the RTS existing for *any* style of deploying haskell
08:50:25 <asheshambasta> maerwald: I've gone through the same phases being relatively new to Haskell, there's a point at which I reached the click factor, and I can now work and understand large parts of Haskell code without as much effort as before.
08:50:27 <maerwald> Welkin: YES
08:50:28 <orion> They hired a VP of Engineering, I got in to an argument with him, and was fired.
08:50:38 <orion> They didn't even let me document the code!
08:50:39 <maerwald> asheshambasta: I'm not new to haskell :)
08:50:47 <orion> Their loss I suppose.
08:50:49 <tdammers> phadej: well, finding good programmers is difficult regardless of language; but if you have found *a* haskell programmer, then the probability of them being a good programmer is orders of magnitude greater than if you had found *a* PHP programmer
08:51:04 <phadej> tdammers: yes, that what I tried to say :)
08:51:13 <asheshambasta> maerwald: yeah I was using the word "you" figuratively, "you" as in "you as a student of haskell" 
08:51:20 <maerwald> Welkin: but I've met a fair amount of smart people, who I admire, but who have a completely different attitude towards complexity and expressivity
08:51:36 <maerwald> asheshambasta: yes, but my point was, this is unrelated to that
08:51:48 <maerwald> asheshambasta: because the range of weird things you can do is so high
08:52:01 <orion> Solonarv: That's what I want to build.
08:52:02 <asheshambasta> maerwald: yeah, I was going off on a bit of a tangent there.
08:52:05 <fen_> is the point that the availability of programmers dictates the language used by industry?
08:52:19 <tdammers> fen_: not dictates, but it is certainly a factor
08:52:42 <Welkin> no one wants to hire a "smart" programmer to write some over-engineered crap that no one understand but them
08:52:43 <maerwald> tdammers: please don't abuse PHP to promote haskell :P
08:52:46 <maerwald> that's too cheap!
08:52:49 <fen_> what about the lack of ability for existing code to be used in conjuction with that of another language?
08:52:59 <fen_> thats got to be the biggest factor
08:53:07 <Welkin> they want replaceable cogs
08:53:10 <phadej> Welkin: someone have to write code for intristically complex system though
08:53:14 <maerwald> Welkin: oh, but that's what happens all the time. People like to hire smart people =)
08:53:18 <phadej> systems*
08:53:24 <fen_> its what this "compiling the c compiler" was supposed to get at. there needs to be a way to compile to pure haskell
08:53:24 <maerwald> And don't pay attention to attitude
08:53:33 <phadej> not all systems are intristically complex, that's true
08:53:46 <Welkin> most systems are crud apps
08:53:51 <tdammers> well, most of the work out in "the industry" is the boring kind - in-house CRM systems, CRUD stuff, wordpress website, that kind of stuff
08:53:54 <Welkin> anyone can write them
08:54:12 <tdammers> for those, the language doesn't matter so much as frameworks, libraries and tooling
08:54:16 <Welkin> if yu are talking about research projects, sure, that is different
08:54:35 <sm> orion: ha! Should have documented first or as you went. That would have shown them.
08:54:35 <fen_> as well as from haskell. there are several projects that make a start at this, but there isnt anything that is just out of the box capable of e.g. compiling gcc source to pure haskell, and refactoring it using higher order abstractions
08:54:46 <Welkin> or some new thing no one has ever done before
08:55:15 <asheshambasta> maerwald: and what I was trying to say is that while Haskell is much more complicated than most mainstream languages, there's this stage (the click factor) that you reach from which point on, things start getting exonentially easier to understand. 
08:55:20 <tdammers> fen_: why would you want that? what would the use case be?
08:55:38 <asheshambasta> exponentially* 
08:55:39 <fen_> now if that did exist, and also that the forign language code produced by haskell adhered to some format that was easy to read, then bad languages could be refactored via haskell with great results
08:56:03 <tdammers> asheshambasta: Haskell is not more complicated. The reason most people's brains hurt while learning Haskell is because it is quite radically different from what they know
08:56:09 <maerwald> asheshambasta: depends whose code you read
08:56:23 <tdammers> fen_: sounds like a pipe dream
08:56:31 <fen_> ...
08:56:42 <fen_> sounds like something everybody wants
08:56:42 <orion> sm: Exercising my stock options *before* telling the emperor he has no clothes proved to be a profitable strategy.
08:56:44 <Welkin> haskell has a steeper learing curve than most languages, sure, but it also is made worse by so many libraries (and example applications) abusing features of haskell like typeclasses and deep transformer stacks (or type-level programming that is totally not necessary for the domain)
08:57:02 <sm> orion: hurrah
08:57:04 <maerwald> asheshambasta: : the space of expressivity is magnitudes higher, so whenever you think you "know the language" or something "has clicked", I can show you haskell code you don't understand *at all*, most probably :P
08:57:15 <tdammers> fen_: not only would you have to somehow express the semantics of C in Haskell, you would also have to find a way to do it losslessly, so that you can reverse the process, and at the same time, you would want the generated Haskell code to be idiomatic, so that you can meaningfully refactor
08:57:21 <maerwald> because someone else does things fundamentally different
08:57:30 <asheshambasta> tdammers: I don't find Haskell complicated now, but just about 10 months ago, I used to find it quite challenging. 
08:57:35 <Welkin> As an example of an over-engineered disaster, I found this example the other day, which uses typeclasses for *everything*: https://github.com/eckyputrady/haskell-scotty-realworld-example-app
08:57:40 <fen_> asheshambasta: what about if its your first language, there is always a difficulty in learning a new language, where the things you are used to are absent 
08:57:53 <tdammers> asheshambasta: it is challenging, but not because it's complicated. it's just different.
08:58:23 <c_wraith> I still don't think there's anything in Haskell that's as complicated as subclassing.
08:58:44 <tdammers> asheshambasta: when you're coming from, say, Java, and you're learning Python, there's a lot of new stuff - dynamic types, top-level script code just running directly, a whole new ecosystem of libraries, a bunch of pythonisms, different syntax
08:58:50 <tdammers> but a lot of other stuff transfers
08:59:33 <merijn> asheshambasta: Haskell is quite consistent and predictable, so while it's different, when things click everything seems to magically get MUCH simpler
08:59:34 <tdammers> there's still mutable variables, classes, statement-based imperative control flow, side effects, etc.
08:59:44 <asheshambasta> maerwald: the thing is, do you need to read code that varied in the Haskell ecosystem? From my experience, I've just happened to pace myself and not dive head first into things like Lenses (earlier). That has been quite a smooth approach imho, and it has helped me learn "kinds of haskell" at a more convenient pace, whilst being productive in it.
08:59:54 <hyperisco> c_wraith, not even instance resolution?
09:00:29 <hyperisco> what about list notation :P
09:00:46 <asheshambasta> The thing is, at its simplistic level, Haskell being clean and strongly typed, you're still writing better code in it than you were before, most probably. You can steer clear of code/libraries you don't completely grasp from the get go and you're quite okay.
09:00:52 <merijn> hyperisco: Only if you add tons of extensions
09:00:53 <fen_> haskell seems to give several ways to do things which are equivalent, and the lack of a single way to do things results in much puzling considerations
09:01:04 <Welkin> haskell is as complicated as you want it to be
09:01:10 <maerwald> asheshambasta: you write good code if you are a good programmer :)
09:01:19 <maerwald> language doesn't matter too much
09:01:20 <fen_> extend this over all languages and the unification and standardisation task becomes insurmountable 
09:01:24 <sm> Welkin: sometimes a little bit more :)
09:01:29 <maerwald> but for maintenance and refactoring... language matters
09:01:29 <hyperisco> merijn, I suppose but in my mind that's the norm.
09:01:35 <Welkin> I avoid using things I don't absolutely need
09:01:49 <merijn> hyperisco: I rarely use multiparam typeclasses, so I never really think about instance resolution
09:02:03 <Welkin> I never write my own typeclasses
09:02:20 <Welkin> I avoid transformers unless I really need to use ReaderT or similar
09:02:25 <tdammers> fen_: the classic "one obvious way" dilemma
09:02:31 <hyperisco> merijn, not even undecidable super classes? how do you get by
09:02:31 <Welkin> I don't use any typelevel programming
09:02:35 <orion> Welkin: What kinds of problems are you trying to solve with Haskell?
09:02:45 <Welkin> orion: web applications
09:02:50 <merijn> hyperisco: What would I need those for?
09:02:53 <Welkin> distributed systems
09:02:57 <tdammers> if you make a language in which there is "one obvious way to do it", then that language is going to get in your way at least on some occasions, when you try to do things that the authors did not anticipate
09:03:02 <orion> Welkin: Basic business needs?
09:03:06 <orion> CRUD, etc.
09:03:10 <Welkin> no
09:03:15 <Welkin> more than that
09:03:16 <asheshambasta> maerwald: I draw a lot of inspiration from the language and what the langauge lets me do elegantly though, so I do think it affects the quality of my work. 
09:03:23 <hyperisco> merijn, honestly I can't remember. All I do is write type classes and GHC tells me the pragmas I need to add. Heh.
09:03:35 <maerwald> asheshambasta: elegant? uh-oh
09:03:38 <asheshambasta> I'm significantly less inspired by languages like JS/Python/Scala etc.
09:03:44 <merijn> hyperisco: I prefer type families + GADTs over multiparam typeclasses, way more straightforward
09:03:45 <tdammers> however, as long as you stay within the constraints of "what the authors anticipated", then the "one obvious way" approach can be a blessing - you can just churn along the trodden paths and go from one obvious step to the next
09:04:38 <maerwald> asheshambasta: I'll be confrontational then: elegant code is the worst. You want simple code, not elegant code :)
09:04:39 <tdammers> then again, if the problems you are going to solve are this predictable, then I would argue they are actually solved problems, and there should be a tool, library, framework or off-the-shelf software that reduces the solution to a few simple configuration steps
09:04:44 <hyperisco> merijn, I don't need to tell you how similar those are
09:05:02 <merijn> hyperisco: The machinery is less confusing though
09:05:09 <maerwald> especially if you are maintaining stuff and are not doing your own one-man project
09:05:13 <merijn> hyperisco: typeclass resolution, fundeps, etc. way to complicated for me
09:05:58 <hyperisco> merijn, did you know you can use constraint kinds plus closed type families to aid in inference and thus in instance resolution? :P
09:06:03 <asheshambasta> maerwald: Elegance is also a colloquial term, maybe I mean "simple" when I say elegant as well :-) 
09:06:33 <maerwald> asheshambasta: all the programmers I know who use that term and show me their code don't mean "simple" :P
09:06:49 <hyperisco> merijn, C++ is a language so complicated it has this arcane magical aura about it. Like the most proficient C++ programmers are actually grisly old wizards. I get a similar vibe from type level programming in Haskell :P
09:06:52 <fen_> this idea about learning a new language fits into this. there are features that you get used to, and think in a particular way as a result design algorithms or applications according to kind of how the language gets you to. there are many options even in one language. so, e.g. scala as combination of imperative and functional paradigms, becomes almost clumsy if badly written.
09:06:56 <maerwald> they are referring to witty abstractions, concise code, ...
09:07:06 <asheshambasta> maerwald: I'd be an exception in your observation then. 
09:07:31 --- mode: glguy set -v ahri[m]1
09:07:36 <orion> maerwald: What is an example of a "whitty abstraction"?
09:07:40 --- mode: glguy set +v skregas
09:07:52 <fen_> its not like all approaches are good things to preserve either, but the task of assesing and reasoning about which features to prioritise and which ways of thinking about programs that result, is a really difficult design space to contend with
09:07:56 --- mode: glguy set -v skregas
09:09:23 <maerwald> orion: transformers
09:09:56 <maerwald> but this is about taste
09:10:06 <hyperisco> merijn, it is unhealthy. You get too invested and then don't want to switch to the drastically simpler solution that comes out later.
09:10:45 <merijn> hyperisco: A sprinkling here and there can do wonders
09:11:43 <maerwald> hyperisco: but it's so more elegant if you do it with lots of GHC extensions :D
09:12:39 <hyperisco> Once more but this time with implicit parameters!
09:13:06 <Welkin> you need at least 20 LANGUAGE pragmas at the top of your file
09:13:26 <maerwald> hypothetical question: what would you prefer as a language background (only one, high proficiency) of someone you want to hire as a haskell developer?
09:13:27 <hyperisco> or 1 pragma and 19 commas
09:13:38 <Welkin> especially the stupid/useless ones like LambdaCase
09:13:41 <maerwald> except haskell ofc
09:13:45 <hyperisco> maerwald, English
09:13:53 <maerwald> I mean programming languages
09:14:00 <Solonarv> LambdaCase is stupid/useless? whaaaa...?
09:14:20 <Welkin> it saves you from typing a few letters
09:14:35 <hyperisco> PureScript
09:14:41 <Rembane> And coming up with a name. 
09:14:42 <Welkin> at the expense of people going "what is this?"
09:14:51 <orion> maerwald: Rust.
09:14:57 <maerwald> orion: interesting
09:15:19 <maerwald> but too much love for complexity in my opinion (macro system, they might be TH lovers)
09:15:19 <maerwald> ;)
09:15:49 <merijn> Welkin: Wut? LambdaCase is amazing...
09:15:53 <merijn> There's a reason it was added
09:16:30 <tdammers> lambdacase isn't about saving a few keystrokes
09:16:33 <phadej> maerwald: Miranda :P; but less far fetched, prolly OCaml / SML, but why not Scheme/Clojure
09:16:36 <Welkin> a language like elm teaches better programming practices than haskell
09:16:41 <tdammers> it is about not having to name things that aren't important enough to be named
09:16:47 <asheshambasta> Also, why is there a pattern match warning here: https://gist.github.com/asheshambasta/9134abed68bb8148815f2e83b9163808#gistcomment-2746836 ? 
09:16:49 <orion> maerwald: https://www.fpcomplete.com/blog/2018/10/is-rust-functional
09:16:53 <tdammers> Welkin: I strongly disagree
09:17:26 <Welkin> tdammers: having been part of the elm community for a while now, I have seen it firsthand and grown a lot of a programmer since then, even after having much more experience with haskell
09:17:35 <maerwald> orion: what is your point?
09:17:35 <fen_> like, java factories were mentioned earlier, there are so many cool ways people have come up with for abstracting code, but with all these options, and only a few being the style of programming that dictates how programms are thought about by the user, even if they are aware of or experienced in many, they will normally have phases or preffered styles
09:17:36 <Welkin> a lot as a*
09:17:49 <`slikts> parallelism and concurrency are orthogonal concepts, y/n
09:17:54 <merijn> `slikts: Yes
09:17:54 <tdammers> Welkin: well, it teaches better coding habits than PHP, so it absolutely matters where you come from
09:18:10 <Welkin> tdammers: I came from haskell, and elm improved my haskell
09:18:10 <merijn> `slikts: Concurrency is about semantics, parallelism is about implementation
09:18:10 <dstolfa> `slikts: define orthogonal
09:18:41 <orion> maerwald: I started reading what Michael Snoyman had to say about Rust and have been intrigued.
09:18:58 <maerwald> I've done rust and I find that post a bit weird
09:19:00 <Solonarv> asheshambasta: the line with '-- WARNING HERE' has a typo, you wrote 'idR' instead of 'isR'
09:19:10 <tdammers> Welkin: I'm curious - how?
09:19:24 <`slikts> merijn: isn't performance part of operational semantics?
09:19:37 <`slikts> dstolfa: define "define"
09:19:52 <maerwald> his definition of "total function" alone is wrong
09:19:53 <Welkin> tdammers: the mental approach to solving problems using ADTs, organizing your code, etc
09:20:00 <merijn> `slikts: I mean denotational semantics, not operational
09:20:02 <dstolfa> `slikts: you're shallowly comparing 2 very deep ideas. this is not helping your case
09:20:08 <dstolfa> `slikts: also, operational semantics don't define performance
09:20:15 <dstolfa> they define the runtime behaviour
09:20:20 <monochrom> No, operational semantics does not distinguish between, for example, having list fusion vs not having list fusion.
09:20:24 <fen_> its not possible for anyone to learn all languages, to find all of the different styles or abstractions, so it could be speculated that many of these would not be transfered to future generations, e.g. this is probably the case with old languages nobody uses now
09:20:24 <dstolfa> they may have an IMPACT on performance
09:20:26 <`slikts> performance is part of the runtime behavior
09:20:28 <dstolfa> but that doesn't mean they define it
09:20:52 <dstolfa> `slikts: again, that doesn't mean it is defined by opsem
09:21:24 <monochrom> Operational semantics gives you the correct big-Theta time but not the correct constant multiplier and change.  It doesn't take into account all kinds of micro-optimizations we expect.
09:21:28 <merijn> `slikts: Monochrom's list fusion comment is illustrative
09:21:30 <ski> Welkin : "I have met many programmers who don't really care to understand how something works. They simply bang away at it until they get something that sort of works and move on","and then when it breaks, they have no idea why" reminds me of "mappers vs. packers" in "Programmer's Stone" <http://web.archive.org/web/20080101170439/http://www.reciprocality.org:80/Reciprocality/r0/index.html>
09:21:42 <monochrom> Plus, operational semantics doesn't even talk about garbage collection.
09:22:08 <fen_> you would like to think that the lessons learned from these old languages shapes the way the newer languages are designed, but the impossiblity of actually getting the experience nesacary to know what it feels like to think about programs in fortran e.g. or smalltalk or something, how can these considerations be standardised and easily communicated to those tasked with these language maintainance and design roles?
09:22:20 <ski> monochrom : it could, to some extent
09:22:59 <`slikts> I guess it makes sense; thanks all
09:23:07 <monochrom> Even then it won't care whether you're doing generational or reference counting or copying or ...
09:23:11 <asheshambasta> Solonarv: ah, thanks, well spotted!
09:23:12 <ski>   let x = M in N  ~~>  N   if x \notin FV(N)
09:23:26 * ski nods
09:23:28 <tdammers> Welkin: I see. It's not like Haskell does a worse job at any of that than Elm though. It's just that Elm is more prescriptivist about it (including the culture and the documentation)
09:23:53 * hackage hsPID 0.1 - PID control loop  http://hackage.haskell.org/package/hsPID-0.1 (jlamothe)
09:24:07 <fen_> its not like the problem is compiling between languages, its capturing these design considerations. is that even a well defined concept!?
09:24:59 <fen_> maybe machine learning can charicterise "programming styles" and output the kind of code you would be able to read most easily 
09:25:21 <`slikts> just let the machines program already
09:25:49 <maerwald> reading code, writing new code and maintaining existing code are all different things and I know no language that can make all 3 pleasant at the same time
09:25:50 <fen_> legibility is essental if mallicios code edits are to be identified
09:25:51 <`slikts> ape-free computation
09:26:07 <fen_> ... think i should use a browser with a spellchecker. sry
09:26:13 <tdammers> machines already to the majority of programming
09:26:20 <tdammers> s/to/do/
09:26:30 <`slikts> they do the executing
09:26:34 <kadoban> tdammers: Ehhh, no.
09:26:38 <ski> hyperisco : i suppose it makes some sense for age to be correlated with experience and proficiency
09:26:41 <ent> compilation?
09:26:44 <monochrom> The purpose of operational semantics is to be a reference of compiler/interpreter correctness (especially where denotational semantics becomes too difficult), and to show that whatever denotational semantics you thought up can actually be implemented.  It has to leave open whether you have code optimizations or not.
09:26:55 <fen_> it would be great to know if there was a body of knowledge put into a particular "style" as its these considerations that are the most commonly rederived aspects of day to day programmers thinking
09:26:56 <kadoban> tdammers: For that to be anywhere near true you'd have to define "programming" very strangely indeed.
09:27:43 <tdammers> well, what would a programming AI look like? how would the AI know what exactly to program?
09:27:49 <tdammers> you'd have to tell it
09:27:57 <ski> a compiler (or parser generator) spitting out code could be seen as (and probably was seen as, by some) as the machine programming
09:28:10 <Welkin> tdammers: or said another way, the haskell culture doesn't provide any guidance to newcomers, which is a problem, because in haskell there are many ways to do everything, and it is up to your personal preference. This works fine for people who know exactly what they are doing, but for newcomers it is a nightmare, and they will end up defaulting to their old (perhaps OOP) ways of doing things, or just copy 
09:28:13 <fen_> the compiler could say, "why are you trying to write it like that, this isnt fortran, read about these relavent developments and the associated standards, and then learn this new style"
09:28:16 <Welkin> random things from other codebases that they see
09:28:41 <fen_> which is kind of what this human based chat is supposed to do...
09:28:45 <Welkin> I know I just latched onto whatever codebases I started with (yesod) for a while
09:29:06 <maerwald> Welkin: or buy into the hype of overusing things that are not needed :)
09:29:28 <tdammers> Welkin: I think there is plenty of guidance, but we have a strongly non-prescriptivist culture, so we tend to not tell people what to do, we prefer providing the information and letting them sort it out. Which is not for everyone.
09:29:32 <maerwald> let's say there is little cultural consistency in the haskell ecosystem
09:29:42 <maerwald> you can experience wildly different things
09:29:51 <`slikts> tdammers: trying to imagine the initiatives of an AI is like trying to imagine the mind of a god
09:30:00 <`slikts> tdammers: it's not for mere apes
09:30:22 <tdammers> Welkin: that said, Stephen Diehl's "What I Wish..." is excellent in that regard and strikes a great balance between hands-on telling you what you need to know while not going overboard with the indoctrination
09:30:29 <merijn> We're nowhere near that level of AI
09:30:34 <`slikts> well, strong AI, that is
09:30:45 <maerwald> tdammers: but for the advanced topics it's quite lacking imo
09:30:46 <`slikts> merijn: we can think about it, though
09:30:54 <monochrom> I tell you what real AI will do in this context.
09:30:55 <`slikts> merijn: just like we can try to understand our own minds
09:31:01 <`slikts> which we are also not even close to understanding
09:31:03 <tdammers> maerwald: yes, but by the time you hit those, you should have a bit of an opinion of your own
09:31:22 <monochrom> The compiler will start telling you "this is not fortran, why are you coding like this?"
09:31:40 <`slikts> monochrom: will it look like Clippy
09:31:43 <monochrom> Then the compiler has another split personality that says "no no no, the human is right, this is fine!"
09:31:50 <fen_> its not a case of AI lacking, it can easily cluster styles, its more a case of the lack of systematic documentation and communication of styles of different languages
09:32:12 <monochrom> Then the compiler goes on to have two or more split personalities debating among themselves and ignoring you.
09:32:22 <monochrom> Like #haskell.
09:32:34 <fen_> haha
09:32:40 <`slikts> #haskell is the worst AI ever
09:32:43 <maerwald> wait, do you guys need cloud and containers to deploy your AI in? more *buzzwords*
09:32:53 <monochrom> AI is not strong AI until it manifests all the flaws of humans.
09:33:10 <`slikts> monochrom: some people uniroinically think that
09:33:12 <monochrom> Hell, s/manifests/suffers from/
09:33:15 <`slikts> *unironically
09:33:19 <ski> fen_ : reminds me of "I think of Alan Creak's STUBOL compiler, which hallucinated the missing bits of students' COBOL programs and showed in the listing what the program should have been.  I think of Peter Fenwick's STUFOR compiler, which went to great lengths to display exactly where in Fortran formatted I/O a problem was:  ..."
09:33:26 <ski> fen_ : in the second post of "Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-(09,10) at <http://lists.mercurylang.org/archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html>
09:33:26 <`slikts> they're called bio-chauvinists
09:33:38 <fen_> no, just that it could recognise the style you were using or notice you changing styles i.e. rederiving some style which is new to you but is already well documented, and tell you the name of this style, so that you could look it up. 
09:34:20 <monochrom> We need UUIDs for styles.
09:34:47 <`slikts> ipv6 addresses
09:34:53 <maerwald> I want classes
09:34:56 <fen_> well really this idea of styles was that they result from languages supported syntax
09:35:18 <Welkin> css styles?
09:35:21 <fen_> and that language design itself should use these 
09:35:31 <Solonarv> if you have a proper programming AI, the only thing you need to say is "do what I mean" ;)
09:35:46 <fen_> i.e. "dont design the language like that, people will start rederiving this bad way of thinking"
09:36:02 <fen_> which is really difficult to understand without a lot of commnetary from the users
09:36:06 <hyperisco> Solonarv, then it will ask: "What is it that you mean, Solonarv?"
09:36:26 <Solonarv> if it has to ask, it's not a proper strong AI
09:36:30 <fen_> and a good understanding of the issues, so a good repository of such literature would be needed, and this process itself standardised.
09:36:57 <hyperisco> Solonarv, really? Because if you gave me that instruction that is what I'd ask. Not that I mean to flatter myself as strong AI.
09:36:58 * ski . o O ( <https://en.wikipedia.org/wiki/Programming_by_example>,<https://en.wikipedia.org/wiki/Inductive_programming>,<https://en.wikipedia.org/wiki/Inductive_logic_programming> )
09:37:47 <Solonarv> well duh, I never said you're a strong AI - and I never said any exist today
09:38:11 <hyperisco> I just mean, strong AI is not telepathic
09:38:48 <Taneb> Solonarv: there's a huge gap between "able to function and communicate as a sapient entity" and "actually magic"
09:39:04 <Solonarv> I *was* being a bit facetious
09:39:50 <orion> ski: I just started reading the text to which you linked. In your own words, how would you define "mapper" and "packer"?
09:40:53 <Welkin> I too busy reading http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/
09:41:27 <fen_> to be sure, the task for the AI is just to recognise these styles, supervised with the styles names and linked with references by humans
09:42:38 <ski> orion : the idea would be that some people are more interested (or proficient ?) in memorizing facts, while others want to impose associations, and connections, and understanding to a greater degree
09:43:00 <fen_> ffs, mention a classification algorith people start fantasizing about emotional deception e.t.c. its a clustering task calm down
09:43:32 <ski> (orion : btw, i'm not sure i buy everything Carter and Sanger says in there. but i think it's still interesting reading)
09:43:53 <carter> Autocorrect?
09:44:05 <fen_> no!
09:44:08 <carter> Or aliasing
09:44:35 <ski> carter : not talking about you, if that's what you're asking
09:48:52 * hackage rounded 0.1 - Correctly-rounded arbitrary-precision floating-point arithmetic  http://hackage.haskell.org/package/rounded-0.1 (ClaudeHeilandAllen)
09:58:16 --- mode: glguy set -v imp0s5ible
10:34:12 <Athas> When I do 'C-c C-l' in haskell-mode on a file with a type error, the error is only shown in the *haskell-process-log* buffer, and Emacs complains with 'Haskell process command errored with: (error "Unexpected response from haskell process.")'.
10:34:42 <Athas> Is there a guide somewhere to setting up haskell-mode in at least one way that actually works?  That thing has so many knobs that I get confused whenever I read the documentation.
10:34:54 <Athas> There is apparently also a comint-based mode, but I don't know how to enable it.
10:43:52 <Athas> At least flycheck-mode works OK.
10:44:20 <Athas> I'm honestly a little shocked that haskell-mode is so brittle.  Has Emacs fallen completely out of favour with Haskellers?
10:44:51 <orion> Are there currently any beautiful HTML5 front ends for the RTS?
10:45:40 <geekosaur> Athas, I think many people use either intero (stack) or dante now
10:46:02 <cocreature> orion: does ekg count?
10:46:03 <geekosaur> partof the problem being that the ghci-based interface used by haskell-mode is brittle with respect to output canges in ghci
10:46:10 <geekosaur> such as pretty error messages
10:46:39 <Athas> Intero was OK when I used it for a stack project (if slow), but now I just want to hack a bit on an .hs file by itself.
10:46:45 <geekosaur> there's also haskell-ide-engine in the works but not quite there yet
10:46:53 <Athas> It's sad, but perhaps understandable if all the tools require ceremony now.  Haven't checked dante, though.
10:47:26 <cocreature> I’ve mostly stopped using haskell-mode for anything but syntax highlighing. I spent more time trying to fix things that it saved me
10:48:03 <Athas> Is there something about ghci that makes it much harder to write a standard Emacs mode?
10:48:08 <geekosaur> (haskell-ide-engne will give editor modes a well defined interface to program to, instead of suffering the whims of ghci which is intended for people, not editors)
10:48:10 <merijn> I hope ghc-mod or something gets around to new-build support soon, or else haskell-ide-engine (LSP seems like a good enough idea)
10:48:22 <Athas> E.g. python-mode and sml-mode work decently, and I've written a language mode myself with the usual comint integration.  Wasn't very hard.
10:48:44 * dmwit ponders how much time he has saved by being too inexpert to help people fix problems with editor plugins
10:48:53 <Athas> If you want completion or type-under-cursor or whatnot, then sure, things may be difficult, but I just want to load my file into a REPL.
10:49:00 <cocreature> just starting ghci correctly is a non-trivial problem with the various build tools we have in Haskell
10:50:44 <Welkin> is there a way to auto-derive the FromField instance for a newtype wrapper over a supported type like Int64?
10:50:50 <Welkin> in postgresql-simple
10:50:54 <merijn> Mostly I just want direct error/warning highlighting, jump to definition (for local sources) and type under cursor, I'll live with just error/warning highlighting, but right now most things are still very brittle with new-build :\
10:51:08 <orion> cocreature: Nice! I didn't know about that project. It seems to do what I want. I also want to have an interface which allows remote killing of threads.
10:51:12 <merijn> Welkin: GeneralizedNewtypeDeriving?
10:51:50 <dmwit> merijn: Oh, yeah, it would be real nice for new-build to give full-er paths to errors somehow. Probably requires changes to GHC, though.
10:51:51 <orion> Not just live statistical output, but actual control.
10:52:14 <orion> I want to make a JSON API which allows the user to send async exceptions to threads, for example.
10:52:18 <orion> Not sure if ekg supports that.
10:52:34 <cocreature> the RTS interface for that is fairly limited. e.g. there is not even a way to list all threads via the Haskell API to the rts
10:52:55 <cocreature> you might be able to mess around with FFIng into the C API
10:52:58 <orion> cocreature: Right, difficult work would need to be done.
10:53:26 <orion> But if I succeed, I might be able to build a business around this product.
10:53:57 <Welkin> orion: why not distributed haskell?
10:54:36 <Welkin> you can assign names to each thread in erlang, so I assume you can do the same in haskell, and then access them by name
10:55:13 <orion> Welkin: This is my vision: https://mail.haskell.org/pipermail/haskell-cafe/2017-November/128130.html
10:56:19 <orion> https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-Conc-Sync.html#v:labelThread
10:57:10 <geekosaur> at present thread names only work with a debugging rts
10:57:25 <davean> orion: theres a fundimental issue in that providing an interface like that can change code behavior
10:59:38 <merijn> orion: The ability to throw async exception to arbitrary threads is super dangerous
11:00:40 <davean> just having the ability to do it will change the semantics if you're not very careful
11:00:43 <merijn> orion: I've written multiple things where the semantics of code and its exception safety is strongly dependent on the fact that no one outside my code can async exception my threads
11:00:45 <davean> not even using it
11:00:56 <davean> never mind merijn's concerns
11:01:42 <merijn> orion: Would it be more sensible to implement your own fork function on top of forkIO that stores your thread ids with a label in a global mutable variable? Then you can just use that to lookup thread ids for exceptions
11:02:36 <merijn> orion: In fact, I've done things like that several times to get a more "erlang-like" style of programming
11:03:49 <merijn> It helps to see forkIO is the ugly low-level primitive it is, on top of which you build nicer, more useful abstractions like async
11:09:45 <orion> Okay, so one gripe I have with Haskell in production is that when performance starts to drop under load, I have to re-compile the code with a debugging/profiling RTS and re-deploy.
11:10:09 <orion> I have to gather data, generate graphs, etc.
11:10:16 <orion> That involves me needing to SSH in to production machines.
11:10:34 <merijn> orion: which OS?
11:10:38 <orion> merijn: Ubuntu./
11:10:43 <orion> It's very annoying, and the problem might go away during that time.
11:10:55 <merijn> ok, so dtrace is no go
11:11:13 <orion> As a result of this pain I experienced in a professional capacity, I think there is a business need for such a tool.
11:12:31 <Welkin> orion: or use erlang for that layer of your application
11:15:45 <merijn> Welkin: I think it could be a valuable addition to Haskell, but we should be careful not to arbitrarily break things
11:17:32 <cocreature> deploying with a profiling RTS probably isn’t a reasonable option. I think the DWARF info is a more useful direction to look into here
11:17:41 <davean> orion: you can stread the data out
11:17:56 <davean> orion: also perf tools.
11:18:06 <davean> orion: Haskell supports dwarf symbols
11:18:46 <merijn> cocreature: better fleshed out DTrace support would be cool
11:18:52 <davean> the perf output has been quite adiquate in my experience for any of the sorts or problems that won't be shaken out in dev
11:21:09 <cocreature> davean: oh really? perf didn’t seem to handle the dwarf info produced by ghc particularly well and there was even an issue for that iirc
11:21:40 <davean> cocreature: It might be I shake my code out more before I put it in production than most
11:21:53 <davean> I'd consider it a personal embarasement if my code failed in production
11:22:43 <davean> I've found the perf output quite useful in what to work on though
11:22:51 <davean> Maybe also because I've spent some time in the RTS/IO Manager
11:23:00 <davean> to the extend of having customised the IO Manager
11:23:11 <davean> and some parts of the RTS
11:23:51 <davean> most of my production "issues" end up being whole-system-behavior
11:23:53 <davean> not local
11:25:27 <davean> I really like the perf output though 
11:32:20 <hugbubby> am I being way too eager, trying to learn the syntax of haskell in a single week
11:33:27 <merijn> hugbubby: tbh, the syntax isn't particularly hard or complex, mostly just different
11:34:00 <geekosaur> syntax ought to be fairly simple, at least if your'e not trying to wot out type/kind level shenanigans. laziness and purity will be harder
11:34:18 <cocreature> I don’t think it makes sense to learn the syntax on its own
11:34:52 <orion> < davean> most of my production "issues" end up being whole-system-behavior <-- This.
11:36:00 <hyperisco> takes a bit getting used to layout especially in do blocks
11:36:52 <orion> In my experience, a Haskell process might experience a performance issue that causes a backup of RabbitMQ queues, which causes the RabbitMQ server to run out of memory, which causes the machine to stop responding, which causes ...
11:37:05 <Rembane> There's a really good page about Haskell indentation.
11:37:27 <orion> Which is why I really want to know what's going on inside the RTS in production.
11:37:54 <orion> bgamari and I had a conversation about this actually. He says that the impact of a profiling RTS is likely not going to be the bottleneck.
11:38:26 <hyperisco> it is all fairly sensible except if/then/else, and indenting let blocks in do blocks sucks
11:38:42 <davean> Profiling RTS isn't much overhead but does have a few issues
11:38:54 <davean> I've no problem running profiling in production but it can't stream its output
11:39:20 --- mode: glguy set +v bgamari
11:40:07 <bgamari> davean, http://downloads.haskell.org/~ghc/master/users-guide//profiling.html#profiling-memory-usage
11:40:28 <davean> bgamari: why are you telling me?
11:40:37 <bgamari> <davean> I've no problem running profiling in production but it can't stream its output
11:40:46 <c50a326> ah I'm getting this error running intero in emacs with any stack project (this is just with default template and 0 changes) https://ptpb.pw/4UEN
11:40:46 <davean> oh did they change that?
11:40:51 <bgamari> I changed that
11:40:57 <c50a326> didn't have this problem before, wondering what might have happened :s
11:41:19 <davean> bgamari: more useful for my laptop than production :)
11:41:26 <bgamari> oh?
11:41:34 <davean> bgamari: but maybe I can solve that taffybar issue without too much time input now ...
11:42:00 <c50a326> adding that - ghc-8.4.3 to the stack.yaml of global project doesn't resolve it btw
11:42:14 <davean> bgamari: oh yah, killing a process preventing profiling output sometimes is super annoying.
11:42:26 <bgamari> right
11:42:36 <bgamari> but I would imagine it would be annoying in production too, no?
11:42:44 * bgamari was confused by "<davean> bgamari: more useful for my laptop than production :)"
11:42:47 <cocreature> c50a326: what is “this error”
11:42:50 <davean> Nah, all my apps can shutdown cleanly
11:43:00 <davean> things like taffybar don't know to :)
11:43:01 <bgamari> fair enough
11:43:16 <davean> I only need non-clean shutdown support outside the ecosystem I maintain
11:43:17 <c50a326> cocreature: I put that link https://ptpb.pw/4UEN
11:43:31 <bgamari> c50a326, there's no error there
11:43:47 <davean> I mean, in taffybar's case I just though my way through the issue
11:43:51 * hackage lentil 1.1.0.0 - frugal issue tracker  http://hackage.haskell.org/package/lentil-1.1.0.0 (fffaaa)
11:44:09 <c50a326> ah maye I should just stack install intero, from the cli
11:44:24 <cocreature> c50a326: you did but that link doesn’t contain an error message
11:45:21 <[exa]> very general FP question: is there some kind of monad-like abstraction useful for masking parts of computation in order not to redo them unnecessarily?
11:45:22 <c50a326> oh shit, wrong paste, sorry https://ptpb.pw/WnPD
11:45:39 <c50a326> that other paste was the package.yaml but then I tried with just the default project template stuff and still same problem
11:46:23 <c50a326> sorry I've been away from technology for 10 days
11:46:43 <Solonarv> ghc 8.4.4 ? that doesn't seem right...
11:46:47 * Solonarv scratches head
11:46:59 <cocreature> c50a326: you need to choose a resolver that comes with 8.4.3
11:47:03 <cocreature> Solonarv: why not?
11:47:34 <jose_zap> cocreature what lts are you using?
11:49:16 <cocreature> jose_zap: you probably want to ask c50a326 that question, not me :)
11:49:25 <jose_zap> oops, wrong autocompletion
11:49:28 <jose_zap> thanks
11:52:51 * hackage crf-chain1-constrained 0.6.0 - First-order, constrained, linear-chain conditional random fields  http://hackage.haskell.org/package/crf-chain1-constrained-0.6.0 (JakubWaszczuk)
11:53:09 <c50a326> ah, `stack new` is creating projects with the lts of 12.16
11:53:19 <c50a326> in my global project I have lts 12.10 ... so what's up with that?
11:54:11 <jose_zap> run `stack solver --update-config` in your project
11:54:20 * hackage crf-chain2-tiers 0.6.0 - Second-order, tiered, constrained, linear conditional random fields  http://hackage.haskell.org/package/crf-chain2-tiers-0.6.0 (JakubWaszczuk)
11:54:21 <jose_zap> that may fix your problem
11:56:24 <c50a326> that doesn't do anything (No changes needed to stack.yaml)
11:57:01 <c50a326> ah I guess I can just use `stack new --solver ...`
11:57:47 <Solonarv> you can do 'stack solver --update-config --resolver blah'
11:57:56 <Solonarv> that might help
11:58:31 <c50a326> ah yeah resolver, not solver
11:58:40 <Ariakenom> [exa]: like caching?
11:59:23 <merijn> [exa]: What do you mean by masking?
11:59:44 <c50a326> Solonarv: ah and that works for my existing projects too, ty!! :)
12:00:34 <Solonarv> yep
12:01:14 <Solonarv> if you're making a new project and want a specific resolver, you can also do 'stack new foo bar --resolver blah'
12:03:37 <[exa]> Ariakenom: almost, just "skip the part of monad" if it (somehow) doesn't seem necessary to recompute
12:03:45 <[exa]> I'm kindof searching for design patterns
12:04:03 <[exa]> merijn: ^, masking as in masking the computation
12:04:42 <[exa]> I'm trying to find a way to reimplement immediate-mode GUI in haskell so that it doesn't need the constant 30+ fps updates
12:05:46 <[exa]> a smart way to see what parts of the gui-drawing function aren't necessary to redo would open a possibility to map the imgui-like programming to desktop stuff like gtk/qt
12:05:59 <[exa]> btw if you didn't already see it,  zaměření odpovídá návrhu projektu. Pokusíme prosadit na prestižních mezinárodních fórech typu ICFP (International Conference on Functional Programming) či WFLP (International Workshop on Functional and Constraint Logic Programming). Volba konkrétní konference bude záviset též na charakteru nových výsledků, které budou prezentovány.
12:06:08 <[exa]> oh noes, bad paste.
12:06:21 <[exa]> if you didn't already see it, https://github.com/ocornut/imgui
12:08:05 <[exa]> (colleague is writing a grant proposal for improving the gui programming in Haskell (part of which is the bad paste you've seen), immediate-mode programming style is a really hot candidate)
12:12:13 <Ariakenom> Cool!
12:15:14 <[exa]> "not cool yet" :D
12:15:26 <lavalike> not... immediately
12:18:12 <[exa]> well, there's a direct way to replace the pointers/references that are 'secretly' used by Imgui by lenses that work with State or something related, which makes a very nice result
12:18:26 <hodapp> did agocorona ever get anywhere with some of his functional UI work?
12:20:49 <[exa]> that was something with javascript right?
12:21:00 <hodapp> not sure. this was years ago
12:22:04 <[exa]> meh, this is gonna need sub-states
12:25:13 <hugbubby> >reading the higher order functions chapter in Haskell
12:25:28 <hugbubby> https://i.imgur.com/L7gaN1s.png
12:25:39 <hugbubby> in LYAH*
12:28:44 <johnw> hugbubby: they're deceptively powerful
12:29:08 <hugbubby> deceptively?
12:29:19 <johnw> they seem like a simple enough thing
12:29:33 <Rembane> They're just functions...
12:29:54 <[exa]> Schoenfinkel your arity!
12:30:00 <johnw> but the a large part of Haskell's more powerful abstractions boil down to just passing around functions...
12:30:15 <hugbubby> THEYRE not functions... EVERYTHING ELSE is functions
12:30:26 <johnw> Haskell has both functions and values
12:30:34 <hugbubby> it's f(x) all the way down
12:30:50 <Ariakenom> lambda calculus has both functions and values, because functions are values
12:30:55 <[exa]> :D
12:31:22 <[exa]> Ariakenom: this is gold
12:32:03 <johnw> if anyone tries to hand you a 0-arity functions, treat them to the business end of a wet salmon
12:32:32 * kadoban wonders which end is the business end
12:32:49 <johnw> the part that you strike 0-arity salesmen with
12:32:55 <__monty__> kadoban: It's the end opposite the party end.
12:33:01 <kadoban> Ahhh
12:33:11 <davean> johnw: hum, I mean operationally ... but you mean at the Haskell level?
12:33:25 <johnw> davean: hmm?
12:33:35 <monochrom> The business end of a wet salmon is a 0-arity function.
12:33:49 <johnw> monochrom: oh snap
12:34:00 <johnw> salmons as values
12:34:05 <merijn> ugh...I wish people didn't use submodules :(
12:34:18 <monochrom> I like red snap too.
12:34:28 <johnw> merijn: we just moved our company to mono repo.  been loving it.
12:34:58 <merijn> johnw: I'm using Mercurial to interact with git (still! \o/) but support for git submodules is...brittle
12:35:12 <merijn> Currently it's refusing to rebase some changes because of this BS
12:35:14 <johnw> I forgot about Mercurial
12:35:22 <[exa]> hugbubby: anyway, it you have something you want explained better than in LYAH then please just ask; mentioning subtle philosophical trouble ends up like that ^
12:35:36 <merijn> So now I need to checkout all this code in git and rebase there
12:35:54 <johnw> hugbubby: yeah, we're a bit famous for nitpicking semantic details until you wonder what the word "the" actually means
12:36:01 <davean> johnw: I mean it seems pretty clear there are 0-arity functions in the implimentations of Haskell
12:36:01 <merijn> johnw: Which is agony, because when not using git, git's lack of userfriendliness is even more obvious when you have to use it :(
12:36:18 <monochrom> I prefer to wonder what "it" means.
12:36:18 <johnw> davean: yeah, I'm usually not thinking operationally these dasy
12:36:26 <Ariakenom> Where does the 0-arity function thing come from, anyway?
12:36:26 * Ariakenom looks up pitchforks on amazon
12:36:29 <hugbubby> i'm good, just wanted to express my emotions about the chapter
12:36:40 <monochrom> http://captionsearch.com/image.php?id=244
12:36:56 <bsima> anyone know where the hackage/haddock "quick search" feature is implemented? I'd like to know how it works
12:37:00 <johnw> Ariakenom: back in the day, the revelation of some was that "everything's a function", which makes values awkward
12:37:15 <Ariakenom> lakshdkahdf
12:37:19 <johnw> hugbubby: were they good emotions?
12:37:28 <johnw> I really enjoyed LYAH, personally
12:37:34 <hugbubby> johnw: they are good emotions
12:37:34 <[exa]> in the ideal world 0-arity functions can't be evaluated because there's no way to pass in a computer
12:37:48 <lone_ranger> does haskell have a scan function? I'm searching for one but I cant find any documentation
12:37:52 <davean> johnw: I will reserve my sales of 0-arity functions to your CPU, not you
12:37:59 <bsima> lone_ranger: scanl
12:38:02 <[exa]> lone_ranger: scanl/scanr?
12:38:10 <bsima> > :t scanl
12:38:12 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
12:38:19 <Ariakenom> johnw: once more, in the spirit of nitpicking I must again reiterate my previous point of functions being values, like I said
12:38:22 <johnw> now, I'm all good with function from (). Call them operationally equivalent to 0-arity and we can be friends.
12:38:33 <johnw> Ariakenom: my agreement with you is complete, fear not
12:38:34 <davean> :)
12:38:56 <lone_ranger> wow I'm dumb lol
12:38:58 <lone_ranger> thanks guys
12:39:18 <johnw> my new favorite toy is 'scanl mappend mempty'
12:39:20 <[exa]> lone_ranger: good you weren't searching for scanf :]
12:39:27 <johnw> conal introduced me to it
12:39:55 <lone_ranger> [exa]: no not this time ;)
12:41:57 <byorgey> johnw: I don't think I've ever used scanl when it wasn't that pattern!
12:42:25 <lavalike> :t scanl mappend mempty
12:42:27 <lambdabot> Monoid b => [b] -> [b]
12:42:31 <byorgey> except sometimes I do e.g.  scanl (+) 0  to avoid doing everything under the Sum newtype, but same thing =)
12:42:48 <johnw> byorgey: conal showed me that you can use it to reason about "state" as the monoid over a 'scanl mappend mempty' applied to a stream transformer
12:43:14 <[exa]> johnw: could we have a function that produces a matrix of the subresults? like, first row of the matrix is from 'scanl mappend mempty', first column is from 'scanr mappend mempty' and the rest gets filled as in dynamic programming
12:43:30 <johnw> lavalike: it's easier to think of as: [a, b, c, d, ...] => [a, a <> b, a <> b <> c, a <> b <> c <> d, ...]
12:43:39 <[exa]> that would be the best generalization of dynamic programming I've seen so far
12:43:41 <lavalike> johnw: yup
12:44:07 <lavalike> > scanl (<>) z [a,b,c]
12:44:09 <lambdabot>  [z,z <> a,(z <> a) <> b,((z <> a) <> b) <> c]
12:44:31 <lavalike> > scanr (<>) z [a,b,c]
12:44:33 <lambdabot>  [a <> b <> c <> z,b <> c <> z,c <> z,z]
12:45:37 <johnw> I think there's a choice of Monoid that allows 'scanl mappend mempty' to model blockchains, using the endo Chain -> Chain
12:45:42 <byorgey> johnw: neat, that makes sense
12:47:18 <johnw> and they definitely model mealy machines, this I was able to prove
12:49:14 <[exa]> johnw: moore or mealy though?
12:50:17 <[exa]> oic, monoid has 2 inputs there :]
12:50:33 <johnw> mealy: { s : Type & s × (s × a -> s × b) }
12:50:56 <johnw> proof here: https://gist.github.com/feb86d8749697c4bf5ef4a7cb8a28a30
12:51:33 <johnw> byorgey: is it well known that Either a (Either b (a, b)) is the cartesian product for the category of partial functions?
12:54:13 <hugbubby> it feels like, intuitively, there are things that I can do with haskwell's higher order stuff that I just cant do with OOP, and vice versa, even though I know that's not true
12:54:55 <johnw> I feel that OOP can be simulated easier than higher-order functions can be
12:55:16 <[exa]> hugbubby: there are things from one system that are not directly/easily rewritable to another
12:55:45 <johnw> but yeah, when you get into fancy dynamic dispatch and virtual inheritance lookup and such, it gets cumbersome either way
12:57:26 <davean> passing around dictionaries of functions is annoying but works to some degree
12:57:37 <tdammers> interestingly, you can do full-blown OOP on top of Haskell, but you end up sacrificing many of the niceties of Haskell's type system in the process, and the resulting OOP system ends up sharing practically all the issues with existing implementations
12:58:09 <tdammers> you need a bit more than passing around dictionaries (or records) of functions though
12:58:15 <davean> Yes
12:58:45 <hugbubby> can u make a turing machine in haskell
12:58:50 <davean> Well, depends on what OOP style you wnat
12:59:02 <davean> I can pass around one function and get SOME types of OOP with DSum
12:59:22 <orion> 14:40:24 < davean> oh did they change that?
12:59:23 <orion> 14:40:30 <+bgamari> I changed that
12:59:23 <tdammers> one extra ingredient you need to figure out is "open recursion", that is, the ability of an inherited method to call into overridden methods and have them resolved correctly
12:59:25 <kadoban> hugbubby: Yes, modulo the infinity part
12:59:27 <davean> but if I did, and you murdered me and I ended up on your jury I'd not be able to find you guilty
12:59:38 <orion> bgamari: Nice. :)
12:59:44 <tdammers> it doesn't really matter which "style" you want, the mechanism is pretty much common to all of them
13:00:08 <Solonarv> actually, *not* modulo the infinity part - the language spec allows data of unbounded size, AFAIK
13:00:24 <davean> tdammers: DSum allows me to pass a typed message. So the resolution is obvious
13:01:32 <tdammers> well, without any kind of inheritance, the problem goes away, if that's what you mean
13:02:05 <hugbubby> C code -> haskell x86 processor
13:02:09 <tdammers> and it's not actually a severe problem, really, all you need is some sort of mechanism that conveniently passes the 'this' object around
13:02:15 <davean> I mean it becomes "pass it up the stack" with the new message handler being passed the one above it - or a set of them if we're tlaking multiple - which becomes a 'super'
13:02:17 <Solonarv> 'data Tape a = Tape (Stream a) a (Stream a)' and there's your infinite-in-two-directions tape
13:02:36 <tdammers> davean: oh, sure - but you also need to be able to reach back down the stack, don't you
13:02:44 <tdammers> the object needs to be able to send messages to itself
13:03:34 <davean> tdammers: Thats one style - I've never seen it a requirement of the message passing model - but thats already handled there
13:03:49 <davean> tdammers: We haven't moved "this", we're just resolving the method on it
13:04:03 <davean> they all get to have it curried in or whatever
13:04:14 <davean> Its a bit too smalltalk for my tastes
13:04:25 <tdammers> ah, but closing over 'this', or currying it in, doesn't work
13:04:35 <davean> what do you mean?
13:04:42 <tdammers> suppose you have an object A with methods foo and bar, such that foo depends on bar
13:04:49 <tdammers> that is, foo calls this.bar somewhere
13:04:49 <davean> Sure
13:05:04 <davean> Yep
13:05:04 <tdammers> and now you have an object B, which inherits from A, but overrides bar
13:05:08 <davean> Sure
13:05:17 <tdammers> it does inherit foo from A though
13:05:21 <davean> Yep
13:05:41 <royal_screwup21> can someone explain to me what this is supposed to mean? https://prnt.sc/lcee9k
13:05:49 <tdammers> now, if we have A.foo close over A, then B.foo, which inherits A.foo, will get a reference to A.bar, but we need it to resolve to B.bar
13:05:53 <davean> No
13:05:58 <davean> A.foo closes over B
13:06:04 <davean> because there is no foo
13:06:06 <davean> foo is a message
13:06:06 <hugbubby> I believe it's a link to an internet resource, royal_screwup21
13:06:10 <davean> there is just the routing function
13:06:36 <davean> As I said, message based
13:06:47 <tdammers> then foo "calling" bar means foo needs to send another message
13:07:02 <davean> It sends "bar"
13:07:12 <tdammers> but, yeah, that works - the message closes over the object, yeah
13:07:55 <davean> This is why it needs the DSum and stuff
13:07:59 <davean> its a lot of type hackery :/
13:08:02 <tdammers> right
13:08:17 <tdammers> I thought you meant the code that handles the messages would close over the 'this' object
13:08:17 <davean> and your routing function is "your class implimentation" really
13:08:20 <davean> and it overrides the lower parts
13:08:26 <davean> its ... ugh
13:08:34 <davean> As I said, I couldn't find you guilty
13:08:57 <davean> Its not Haskell2010
13:09:00 <tdammers> well, I haven't seen a *nice* implementation of OOP in Haskell yet
13:09:17 <davean> What I mention though is easy to impliment and reasonable to use
13:09:24 <davean> inb the same way you can program python and have it be ok
13:09:27 <davean> :)
13:09:51 <dstolfa> i'm not sure i've ever needed OOP features in haskell
13:09:53 <tdammers> you can? introduce me to your magic!
13:10:19 <tdammers> dstolfa: I've "needed" them probably exactly once so far
13:10:22 <davean> tdammers: It starts be learning a all of the edge cases, memorizing them, and then removing ANYONE else from the project.
13:10:31 <dstolfa> i've certainly wanted them in C, but i can't say i've ever felt the need to use them in haskell, or that it would be the `better solution' to something
13:10:47 <tdammers> dstolfa: the use case was generating SQL queries from a structured but dialect-agnostic AST
13:11:24 <tdammers> davean: ain't nobody got time for learnin' all dem edge jesus
13:11:55 <davean> tdammers: If you can't write a python implimentation from scratch without reference material you probably can't use python safely
13:12:09 <Ariakenom> filter else project
13:12:13 <tdammers> dstolfa: so I'd have a bunch of methods calling into one another, e.g. the selectFieldList method would call into the quoteFieldName method
13:13:04 <dstolfa> davean: i mean, you can't use python safely anyway
13:13:20 <tdammers> dstolfa: so I could override the quoteFieldName method for different SQL dialects, e.g. SQL Server would use [fieldname], postgres would use "fieldname", etc., but the selectFieldList method would be the same for all of them
13:13:52 <dstolfa> tdammers: couldn't you do that with a record?
13:14:14 <tdammers> dstolfa: I did
13:14:19 <tdammers> dstolfa: but you still need open recursion
13:14:29 <dstolfa> i mean, sure
13:14:31 <tdammers> (when I said "method", I meant in the OOP sense)
13:14:39 <dstolfa> it's a problem that would be ugly regardless
13:15:04 <tdammers> well, it was reasonably nice due to the fact that I didn't need anything mutable anywhere
13:15:26 <tdammers> state updates, no matter how you model them, make things considerably uglier
13:15:58 <tdammers> you can either give up multi-interface and retain a pure s -> s update model
13:16:21 <dstolfa> yeah, state is a bit nasty
13:16:28 <tdammers> or you can give up purity and use mutable-variable primitives, but then the mutability bleeds through your entire object and everything becomes mutable
13:16:49 <tdammers> or you can throw type safety out the window and implement a unityped dictionary-of-everything approach
13:17:01 <tdammers> and then just duck type along like they do in python
13:17:12 <tdammers> but at that point, you might as well just use python
13:18:04 * dstolfa shivers at unityping
13:21:08 --- mode: glguy set +v noipmups
13:21:12 <noipmups> Given [Int], how to find min value greater than some threshold (when there is no such value, return global minimum instead)?
13:23:08 <glguy> filter the list, find the smallest remaining value, use a default value if the list was empty
13:23:18 <mniip> I've got a better idea
13:23:53 <mniip> snd . minimum . map ((< threshold) &&& id)
13:24:15 <phadej> heh
13:24:21 <mniip> using the default Ord instance for pairs, this would prefer elements that fail the (< threshold) test to those that pass it
13:24:46 <glguy> make sure you write all that down in a comment for the reader later
13:26:26 <mniip> if you drop the 'snd' you can even recover whether the found value was the one satisfying the threshold or if it was the fallback
13:26:33 <royal_screwup21> say I have: data Expr = Val Int | Add Expr Expr  .Let Expr' be a type alias for Fix Expr . I'm trying to figure out some possible examples of Expr'
13:27:01 <mniip> royal_screwup21, that doesn't seem right
13:27:09 <mniip> Fix :: (* -> *) -> *
13:27:15 <mniip> Expr :: *
13:28:17 <royal_screwup21> mniip: am I right in thinking Fix is defined like so: data Fix f  = In (f (Fix f) ) ?
13:28:21 <mniip> yes
13:28:30 <mniip> that's what gives it the (* -> *) -> * kind
13:29:52 <glguy> data ExprF a = Val Int | Add a a
13:29:56 <glguy> type Expr = Fix ExprF
13:30:02 <mniip> that sounds more like it
13:30:13 <mniip> I was expecting royal_screwup21 to realize the mistake themselves
13:32:35 --- mode: glguy set +v boxscapeR
13:34:18 <boxscapeR> I can make an instance of [] by just writing `instance <class> [] where`. Can I make an instance of [[]] somehow? I.e. for the type constructor that takes a type and returns the types of lists of lists of that type.
13:36:09 <boxscapeR> Or, I guess to maybe make it less confusing, the same question could be asked about `\t -> Maybe t` and `\t -> Maybe (Maybe t)`,  where those are type-level lambdas
13:37:21 <Zemyla> boxscapeR: No, you use the Compose newtype in Base.
13:37:28 <boxscapeR> ah, okay, thanks
13:37:51 * hackage hackage-whatsnew 0.1.2 - Check for differences between working directory and hackage  http://hackage.haskell.org/package/hackage-whatsnew-0.1.2 (JeremyShaw)
13:43:40 <Solonarv> to whoever was asking about haskell's turing completeness earlier: https://gist.github.com/Solonarv/0116f6d8a7f22716e68d843d4fb4e6ec
13:46:13 --- mode: glguy set +v noipmups_
13:46:16 <noipmups_> mniip: Did you mean something like "snd . minimum . fmap (arr (< threshold) &&& id)"?
13:48:20 * hackage HaXml 1.25.5 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.25.5 (phadej)
13:48:21 <noipmups_> > snd . minimum . fmap ((< 3) &&& id) $ [1, 3, 5]
13:48:23 <lambdabot>  3
13:48:29 <noipmups_> > snd . minimum . fmap ((< 6) &&& id) $ [1, 3, 5]
13:48:31 <lambdabot>  1
13:49:50 * hackage polyparse 1.12.1 - A variety of alternative parser combinator libraries.  http://hackage.haskell.org/package/polyparse-1.12.1 (phadej)
13:50:06 --- mode: glguy set +v boxscapeR
13:50:11 <koz_> phadej: Thank you for that push, from the bottom of my heart.
13:50:12 --- mode: glguy set +v anax
13:52:46 <koz_> How long will it be before stack can 'see' that update on Hackage (if I 'stack build' with 'polyparse-1.12.1' in extra-deps)?
13:56:23 <phadej> koz_: half an hour is a safe bet
13:56:30 <koz_> phadej: OK, thanks!
13:56:37 <phadej> cheers
13:56:42 <koz_> Sweet, delicious QuantifiedConstraints, here I come!
13:59:54 <infinisil> noipmups_: Whew, arrows sure are something
14:01:56 <fragamus> Can somebody tell me about the lazy/strict state monads
14:02:27 <fragamus> Like is the strict one strict on each action 
14:04:05 <merijn> I forgot, with cabal.project how do I add ghc-options to a specific package?
14:05:54 <phadej> package pkg\n  ghc-options: -Wall
14:06:20 <merijn> phadej: \o/
14:07:00 <merijn> phadej: btw, I just noticed that my ghc 8.6 flag patch still needs to be cherry-picked to master
14:07:23 <merijn> Who do I bug, seeing how I don't have time
14:07:35 <phadej> I'll cherry-pick it
14:07:50 <merijn> oh, wait
14:08:08 <merijn> It's not on the 2.4 branch, no one merged it at all :O
14:08:45 <merijn> phadej: I have one travis failure that seems unrelated https://travis-ci.org/haskell/cabal/jobs/432875501
14:08:49 <merijn> Should I just merge it?
14:09:51 <phadej> I restarted that job. Will figure it out. No worries.
14:10:36 <merijn> That one should definitely go into master ASAP and on the 2.4 branch, or else everyone will revert to rebuilding world again :)
14:12:39 --- mode: glguy set +v masaeedu[m]
14:13:36 <masaeedu[m]> both success continuations also have a parameter for a `ParseError`, which in most places seem to be passed a dummy `unknownError`
14:13:46 <masaeedu[m]> can successful parses in Parsec still have error messages?
14:15:04 <royal_screwup21> say I have: data ExprF k = Val Int | Add k k .Let Expr' be a type alias for Fix ExprF . I'm trying to figure out some possible examples of Expr'. Is In (Val 3 (In (Val 3) ) a valid example?
14:15:29 <phadej> hm... masaeedu[m] came and left... :/
14:15:51 --- mode: glguy set +v masaeedu[m]
14:15:55 <geekosaur> and came back
14:16:16 <phadej> masaeedu[m]: http://hackage.haskell.org/package/parsec-3.1.13.0/docs/src/Text.Parsec.Prim.html#parserPlus <- look at that
14:16:44 <lyxia> royal_screwup21: Val has only one field, so no.
14:17:19 <lyxia> royal_screwup21: In (Val 3),    In (Add (In (Val 3)) (In (Val 3)))
14:17:41 <merijn> A pox upon persistent's incoherent typeclass mess
14:18:17 <royal_screwup21> I don't understand :( I get that Fix F = In (f (Fix f) ) but I can't match up the types
14:18:22 <royal_screwup21> data Fix f*
14:19:19 <phadej> masaeedu[m]: in short the ParseError given to success continuations are "what we tried, but didn't work; so if you don't work either report all the errors"
14:19:44 <masaeedu[m]> phadej: Ok, so in that one `cok` just gets propagated unchanged down both underlying representations. That leaves `neok y s' err' = eok y s' (mergeError err err')`
14:19:49 <koz_> Well, hlint now builds with GHC 8.6. hdevtools still baroke.
14:20:02 <lyxia> royal_screwup21: So you start with this hole    ??? :: Fix ExprF   first you need an In:   In (??? :: ExprF (Fix ExprF))    now you need an ExprF    In (Add (??? :: Fix ExprF) (??? :: Fix ExprF))    repeat.
14:20:05 <merijn> koz_: hdevtools is never getting fixed
14:20:09 <koz_> merijn: How come?
14:20:13 <merijn> koz_: I maintained my own fork for a while
14:20:32 <merijn> koz_: The setup is just fundamentally broken and can never be fixed to work with new-build
14:20:46 <koz_> merijn: I see. Do I have (m)any alternatives?
14:20:48 <merijn> ghc-mod might *eventually* be fixed, but DanielG is too busy atm
14:20:59 <koz_> merijn: Yeah, ghc-mod is definitely far behind.
14:21:03 <merijn> I have my own 70% finished solution that I don't have time to fix
14:21:04 <masaeedu[m]> phadej: But if there was an error, wouldn't you want to invoke the appropriate error continuation?
14:21:34 <koz_> merijn: I see.
14:22:23 <koz_> That's... rather obnoxious, because I have basically no options in Neovim outside of ghc-mod, hdevtools and hlint, and ghcid's nvim plugin is mysteriously broken.
14:23:32 <phadej> masaeedu[m]: neok is "n's empty ok continuation"
14:23:50 <masaeedu[m]> right
14:24:28 <merijn> koz_: Tell me about it
14:24:33 <royal_screwup21> lyxia: thanks for explanation. I can't see why In (Add "foo" "bar") wouldn't be valid...k could be anything, right?
14:24:43 <phadej> i like to think visually, so I'd draw a "diagram" where all these continuations go
14:24:53 <koz_> I can stay on 8.4 for a while, but that's obviously _not_ a long-term fix.
14:25:05 <phadej> so one can simulate operations by looking at he picture :)
14:25:13 <phadej> it might work for you, or might not
14:25:23 <koz_> I might have to chase up precisely what's breaking with ghcid's nvim plugin, but I know even less about Neovim than ghcid. :P
14:25:31 <merijn> koz_: Your choices appear to be: 1) Wait for DanielG to update ghc-mod for new-build, 2) Wait for me to finish my thesis and finish my project, or 3) write your own solution
14:25:52 <merijn> Or pay someone to fix it for you >.>
14:26:14 <royal_screwup21> I'm going crazy trying to understand fix :(
14:26:30 <koz_> merijn: Well, I guess there's also 4) See if I can get Ghcid's plugin fixed.
14:26:35 <koz_> Which might be easier than all the others.
14:26:40 <koz_> So I guess that's my next thing to chase.
14:26:44 <phadej> ghc-mod is something which would benefit haskell-ide-engine
14:26:45 <merijn> koz_: I thought that was basically topic 3
14:26:51 <phadej> which is IMHO better than hdevtools
14:26:54 <phadej> in long run
14:26:58 <merijn> phadej: They're already collaborating afaik
14:27:13 <phadej> yes, but ide-engine cannot new-build because ghc-mod cannot
14:27:14 <koz_> merijn: Well, it could be something that Neil can fix on his end.
14:27:14 <royal_screwup21> lyxia: am I completely mistaken there thinking  In (Add "foo" "bar") is valid?
14:27:16 <lyxia> royal_screwup21: At the beginning you want a (Fix ExprF), so you need to apply a constructor  ... -> Fix ExprF   and that is In :: f (Fix f) -> Fix f, if you set f = ExprF, so  In :: ExprF (Fix ExprF) -> Fix ExprF
14:27:17 <koz_> For all I know.
14:27:25 <merijn> phadej: I know :(
14:27:28 <lyxia> royal_screwup21: so no it's not just ExprF k with any k.
14:27:31 <merijn> phadej: My own thing new-builds!
14:27:45 <phadej> koz_: I just have `ghcid -c 'cabal new-repl mypkg'` in a terminal
14:27:48 <merijn> phadej: It's just the vim integration to daemonise that's missing
14:28:00 <merijn> phadej: But I want highlighting in the editor :\
14:28:03 <koz_> phadej: I'd like to have Neovim integration.
14:28:06 <masaeedu[m]> phadej: that makes sense. the first step would be to find out where these continuations actually get eliminated. I believe this happens in `runParsecT`, where it finally passes in four continuations that ultimately produce an `m (Consumed (m (Reply s u a)))` (or for simplicity, just a `Consumed (Reply s u a)`)
14:28:16 <koz_> It's alright, I'll chase up this weird issue methinks.
14:28:28 <koz_> Thanks for the info merijn - you are both handsome _and_ helpful!
14:28:56 <masaeedu[m]> phadej: so then I look at what actually invokes `runParsecT` in turn, which is `runPT`, and lo and behold, it simply throws away the error component of `Ok`.
14:29:37 <phadej> masaeedu[m]: yes, if at the end things are successful, one don't care what failed before that
14:30:31 <phadej> CPSd things are always a brain-twister
14:31:31 <masaeedu[m]> but what then is the use of having a `ParsecError` value in the success continuations (if it's only ever going to get wrapped into an `Ok`) and then thrown away. Are there cases where the `ParseError` on the success continuations actually gets inspected and used to fail the computation?
14:33:49 <royal_screwup21> lyxia: I'm not totally sure how the 'k' in data ExprF k comes into play
14:34:06 <royal_screwup21> data ExprF k = Val Int | Add k k
14:34:53 <jle`> royal_screwup21: do you know what ExprF is supposed to represent?
14:34:57 <lyxia> royal_screwup21: See what ExprF gets applied to in the type of In.
14:35:00 <lone_ranger> not sure how to explain myself, so a general answer is ok, is it possible to use scanl to generate a series? e.g like macluarin series for e^x
14:35:20 <jle`> royal_screwup21: how familiar are you with ADT's?
14:35:25 <jle`> like data Maybe a = Nothing | Just a
14:35:32 <jle`> the 'a' there (and the 'k' in ExprF) is a type parameter
14:35:50 <jle`> meaning that the type 'Maybe Int' has a constructor Nothing, and a constructor Just, that takes a single Int
14:36:08 <masaeedu[m]> Maybe I'm thinking about it backwards
14:36:32 <jle`> lone_ranger: you can use scanl to generate a series
14:36:37 <jle`> lone_ranger: if by series you mean list
14:37:06 <jle`> in fact scanl's return type is a list, so it pretty much always generates a series/list
14:37:49 <lone_ranger> jle`: thank you, i'm doing it on paper and it makes sense, just need to code it
14:37:50 * hackage concraft 0.14.2 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.14.2 (JakubWaszczuk)
14:38:41 <jle`> when in doubt, check the types:
14:38:44 <jle`> :t scanl
14:38:45 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
14:39:07 <lone_ranger> ok cool bot
14:39:17 <lone_ranger> :t (+)
14:39:18 <lambdabot> Num a => a -> a -> a
14:42:18 <royal_screwup21> welp, this is my quantum mechanics. I just cannot understand this.
14:42:19 <dmwit> lone_ranger: Have you seen https://www.cs.dartmouth.edu/~doug/powser.html ?
14:42:35 <koz_> Is accelerate-* still being worked on? It's still on LLVM6 from what I can see.
14:42:49 <lone_ranger> dmwit: thanks but you almost runined it for me lol
14:42:57 <lone_ranger> want to figure it out first
14:43:06 <dmwit> oh whoops =P
14:43:47 <Welkin> what is the most reasonable way to generate a session id/token? UUID seems wrong, especially the totally random ones
14:43:49 <jle`> royal_screwup21: do you know what Expr is supposed to be?
14:43:54 <jle`> what it is supposed to represent?
14:44:03 <jle`> it might help to have a familiar with the problem they are trying to solve
14:44:21 <Welkin> jle`: you need to summon or choose a familiar first
14:44:40 <royal_screwup21> jle`: Expr or ExprF? data Expr = Val Int | Add Expr Expr. data ExprF k = Val Int | Add k k
14:44:58 <jle`> Welkin: ah yes, i shouldn't gloss over that part
14:45:05 <jle`> royal_screwup21: yeah, Expr = Val Int | Add Expr Expr
14:45:10 <jle`> do you know what that type is supposed to be?
14:45:17 <lyxia> royal_screwup21: it takes time to get used to it.
14:45:19 <royal_screwup21> Expr?
14:45:22 <jle`> yes
14:45:38 <jle`> what it might be used for, what a value of that type represents, and some sample values of that type
14:46:23 <Welkin> it looks like wai-session uses System.Entropy.getEntropy to generate a random sequence of bytes
14:46:33 <Welkin> I don't know which is better, that or a uuid
14:47:10 <lone_ranger> jle`: just to clarify functions like scanl and foldl need a function of at least two arguments?
14:47:20 <jle`> royal_screwup21: if not, then it might be helpful to look at a more familiar recursive type, intead of a foreign one that you haven't seen before like Expr
14:47:26 <jle`> lone_ranger: check the types :)
14:47:55 <jle`> royal_screwup21: or at least, spend some time getting to know what Expr does and what it is, before trying to refactor it in terms of a new abstraction
14:48:08 <royal_screwup21> jle`: oh yeah an example of that could Add (Val 3) (Val 4)
14:48:17 <royal_screwup21> that's of type Expr
14:48:19 <jle`> right, what would it represent?
14:48:43 <jle`> what does Add (Val 3) (Val 4), or Add (Val 3) (Add (Val 1) (Val 2)) *mean* ?
14:48:56 <royal_screwup21> it's an abstract syntax tree? idk
14:49:13 <royal_screwup21> you could write a function to evaulate it
14:49:14 <lone_ranger> so thinking out loud: yes since it requires a binary operator
14:49:29 <jle`> right, if you aren't familiar with what a type like this represents, then it's not going to be very useful to use it as an example for helping you learn about fix
14:49:53 <jle`> lone_ranger: well, because the type of the function it takes is `b -> a -> b`, which is a function with at least two arguments
14:49:57 <jle`> just count the arrows :)
14:50:21 <jle`> royal_screwup21: your problem isn't about understanding Fix, i think, but maybe about understanding Expr
14:50:35 <jle`> royal_screwup21: can you write a function to 'evaluate' it ?
14:50:37 <royal_screwup21> what have I not understood about?
14:50:38 <royal_screwup21> sure
14:50:41 <royal_screwup21> eval Val x = x
14:50:48 <jle`> well, you don't sound very sure about what it means/represents
14:50:48 <royal_screwup21> eval Add a v = eval a + eval b
14:51:06 <royal_screwup21> Add a b*
14:51:21 <lone_ranger> jle`: yeah I get that,  but all binary operators are going to be a function of two arguments
14:51:29 <lone_ranger> since they are functions themselves
14:51:36 <lone_ranger> right?
14:51:39 <mniip> jle`, I'm puzzles as what you think the correct answer is
14:51:42 <jle`> yeah, i'm just saying that the asier way is to look at the number of ->'s
14:51:49 <mniip> a free magma on natural numbers and a binary operator?
14:51:56 <lone_ranger> ok gotcha
14:51:59 <jle`> mniip: just wanted to get an answer from royal_screwup21 that didn't end with "...? idk", heh
14:52:09 <jle`> it just sounded like they were unsure about what it was
14:53:31 <jle`> royal_screwup21: okay, yeah, it looks like you are thinking about Expr as representing an abstarct syntax tree, or unevaluated expression, made up of additions and literal values.
14:53:40 <jle`> royal_screwup21: now do you see what mechanical thing we do when we go from:
14:53:51 <jle`> data Expr   = Val Int | Add Expr Expr
14:53:56 <jle`> to data ExprF k = Val Int | Add k k
14:54:31 <jle`> instead of directly recursing back onto Expr, we parameterize it on some type parameter k
14:54:54 <jle`> now, what are values of type `ExprF ()` ?
14:55:00 <jle`> can you give some examples?
14:55:31 <royal_screwup21> is Add "foo" "bar" valid? I'm going to paramterize it on a string
14:55:51 <jle`> that's valid if we have ExprF String, yes
14:55:55 <jle`> but what about ExprF () ?
14:56:18 <jle`> what are some examples of values of type ExprF () ?
14:56:42 <royal_screwup21> hmm not sure what () means. googling tells me it might be a unit but I don't get the significance of it
14:56:55 <royal_screwup21> Val 4
14:56:59 <jle`> in Haskell, () is the type with one constructor, ()
14:57:04 <jle`> it's basically used as a dummy value/dummy type
14:57:07 <royal_screwup21> oh o
14:57:10 <jle`> so yeah, we have Val 4, and Add () ().  that's it
14:57:23 <royal_screwup21> I sorta see it
14:57:25 <jle`> (and Val 5, Val 6, etc.)
14:57:31 <jle`> now, what about values of type ExprF (ExprF ()) ?
14:58:15 <jle`> remember we have two constructors, Val Int and Add k k...so in our case, Val Int and Add (ExprF ()) (ExprF ())
14:58:17 <royal_screwup21> that would be Val <some_number> , Add Val 4 Val 5
14:58:27 <jle`> yeah, Add (Val 4) (Val 5) works
14:58:35 <jle`> same as Add (Val 4) (Add () ())
14:58:58 <jle`> so basically ExprF () is "one layer deep", ExprF (ExprF ()) is "two layers deep", kinda
14:59:14 <jle`> do you see how ExprF (ExprF ()) is like tree that is at most two layers deep?
14:59:42 <royal_screwup21> yup, trying to write out examples on paper, I think I see it
15:00:00 <jle`> what about ExprF (ExprF (ExprF ()))?
15:00:13 <royal_screwup21> ya, that's 3 layers deep
15:00:21 * hackage concraft-pl 2.4.0 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-2.4.0 (JakubWaszczuk)
15:00:44 <jle`> would you believe me that if i could make a type ExprF (ExprF (ExprF (ExprF ... forever ...))), it would be potentially infinite layers deep
15:00:48 <jle`> ...and that it would be the same as our original Expr ?
15:01:22 <merijn> ...
15:01:26 <merijn> Well that's just fucking rude...
15:01:32 <merijn> persistent-qq has no cabal file...
15:02:04 <royal_screwup21> hmm okay
15:02:09 <merijn> I don't suppose I can somehow turn package.yaml into a cabal file without installing a bunch of stack bullshit?
15:02:20 <jle`> you can use the standalone hpack binary
15:03:09 <merijn> jle`: Still bullshit >.<
15:03:12 <jle`> royal_screwup21: let's pretend I had a magic data type Fox that did that.  where Fox f = f (f (f (f ... forever ...)))
15:03:22 <jle`> then we could say type Expr = Fox ExprF
15:03:41 <marvin2> isn't package.yaml part of hpack, not stack? stack just includes it by default. so you may just have to install a bunch of hpack bs, instead!
15:03:58 <jle`> so at a high level, that's the "point" of Fox.  instead of writing Expr with direct data type recursion, you can write it parameterized on the recursion instead 
15:04:20 <merijn> marvin2: The entire repo has cabal file for each package, except one, so I now need this BS just to build and test shit...ugh
15:04:28 <jle`> and then the magical Fox combinator do Fox ExprF = ExprF (ExprF (ExprF (ExprF (ExprF ...)))), to get your original type back
15:04:49 <jle`> spoilers, Fox is Fix
15:05:36 <jle`> royal_screwup21: to be honest, I don't think people usually manually work with the explicit constructors of Fix (In, here).  that's sort of an implementation detail, and it's not even the only way you could implement such a f (f (f (f (f ...)))) data type
15:05:39 <jayspeer> hi. can someone™ recommend a good introduction to haskell for a person with a bit of background with functional programming in lisp, scheme and such? I'm mostly interested in mathematical and cs concepts rather than practical applications of haskell
15:06:23 <jle`> if you're not interested in learning haskell to be able to use it, and just want to learn some interesting math, how about Category Theory for Programmers, by bartosz milewski?
15:06:42 <zachk> I liked programming in haskell but graham hutton, coming from scheme , but it was pretty basic, cleared up all my newbie questions though 
15:06:57 <jle`> royal_screwup21: usually when people work with Fix, they do it through combinators that hide the implementation details like In.
15:07:15 <merijn> why the hell does hpack need to install an entire certificate validation and tls toolchain? :(
15:07:24 * hackage hasktorch-codegen 0.0.1.0 - Code generation tools for Hasktorch  http://hackage.haskell.org/package/hasktorch-codegen-0.0.1.0 (stites)
15:07:49 <jle`> royal_screwup21: because actually, depending on how you consume your Expr, there might be more efficient implementations of ExprF (ExprF (ExprF ...))) than just the plain Fix you gave earlier
15:08:24 <royal_screwup21> jle`: data Fix f = In (f (Fix f)). Now I want examples of Fix ExprF. If I do, In (Val 3)...am I parameterizing the f (which is of type Expr) on an int?
15:08:39 <jle`> i think 'understanding fix' isn't about understanding the implementation, but rather at a high level, what it does to a data type, and the benefits you get from it over the explicit recursion case
15:08:53 <jle`> but if you really want to understand this implementation, we can talk about it too.  just remember that this is the trees, not the forest
15:09:11 <jle`> royal_screwup21: look at the type of 'In':
15:09:35 <jle`> In :: f (Fix f) -> Fix f
15:09:40 <jle`> or, in our case:
15:09:44 <jle`> In :: ExprF Expr -> Expr
15:09:50 <jle`> (if we say Expr = Fix ExprF)
15:10:09 <jle`> it means that it takes an ExprF Expr, and returns a shiny Expr from it
15:10:44 <jle`> so you can do In (Val 3), because Val 3 :: ExprF Expr
15:12:17 <royal_screwup21> thanks for the explanation btw, appreciate it. This is genuinely beyond my level of comprehension :(
15:13:26 <jle`> do you understand the 'point' of Fix, though, and how ExprF (ExprF (ExprF ...))) etc. is equivalent to our original Expr? if so, then you understand Fix
15:14:07 <royal_screwup21> data ExprF k = Val Int | Add k k. So, isn't Val 3 :: ExprF? as opposed to  Val 3 :: ExprF Expr
15:14:11 <jle`> in the end, the implementation details vary between implementation to implementation, and people really don't care when they actually use the data type
15:14:19 <jle`> royal_screwup21: are you familiar with the 'Maybe' data type?
15:14:24 <jle`> data Maybe a = Nothing | Just a
15:15:30 <royal_screwup21> what would be the type of Nothing? Nothing::Maybe?
15:15:45 <jle`> not quite, the type of Nothing is Nothing :: Maybe a
15:15:52 <jle`> so you can have Nothing :: Maybe Int, Nothing :: Maybe Bool, etc.
15:15:57 <hexfive> :t Nothing
15:15:58 <lambdabot> Maybe a
15:16:02 <hexfive> :t Nothing :: Maybe Int
15:16:03 <lambdabot> Maybe Int
15:16:10 <jle`> remember, Maybe is not a type
15:16:15 <jle`> or well, not the type of any value
15:16:25 <jle`> Maybe Int is the type of a value, and it has two constructors: Nothing, and Just :: Int -> Maybe Int
15:16:25 <merijn> jle`: I was about to pedant you ;)
15:16:37 <jle`> can't out-pedant the pedanter
15:16:48 <jle`> ;)
15:17:18 <mniip> Maybe is not a type
15:17:19 <mniip> fight me
15:17:30 <royal_screwup21> ok I sort of see why Val 3:: ExprF doesn't hold true..what about .Val 3 :: ExprF Int?
15:17:36 <jle`> royal_screwup21: yup
15:17:43 <jle`> in fact, the type of Val is Val :: Int -> ExprF a
15:17:48 <merijn> mniip: I'll see you outside!
15:17:54 <jle`> meaning it can be an ExprF a, where a can be any type
15:18:03 <merijn> mniip: How is Maybe not a type?
15:18:04 <royal_screwup21> ok, so why not Val 3 :: ExprF Int as opposed to  ExprF Expr
15:18:07 <jle`> it can be Val 3 :: ExprF String, Val 3 :: ExprF Bool, etc.
15:18:14 <jle`> royal_screwup21: it can be ExprF Int, too :D
15:18:17 <jle`> it can be *any* 'a'
15:18:27 <mniip> one could say that Maybe is merely a type constructor, a part of "type expressions"
15:18:34 <masaeedu[m]> mniip (IRC): you mean in the sense that it has the wrong kind
15:18:37 <masaeedu[m]> ?
15:18:38 <mniip> and types are only those type expressions of kind *
15:18:43 <merijn> mniip: What?
15:18:48 <merijn> mniip: Why?
15:18:50 <royal_screwup21> hmm right, but the 3 in the Val 3  is of type Int...it's not of type Expr
15:19:01 <mniip> I don't know, I don't really stand by that but it kinda makes sense
15:19:04 <jle`> right, but look at the definition
15:19:09 <jle`> data ExprF a = Val Int | Add a a
15:19:18 <merijn> mniip: That's definitely contrary to all the literature I've seen and read
15:19:20 <royal_screwup21> oh
15:19:22 <jle`> if we specialise to, say, a ~ Bool, we get:
15:19:28 <jle`> data ExprF Bool = Val Int | Add Bool Bool
15:19:36 <jle`> ^ see how no matter what we set 'a' to, Val always takes an Int ?
15:19:38 <merijn> mniip: Values have types of kind *, but that doesn't limit the notion of type to *
15:19:50 <royal_screwup21> yeah I see that now
15:20:01 <jle`> so Val 3 has type ExprF a, for any 'a' we want
15:20:04 <mniip> right but then the judgment (x : A) has an intrinsic implication that (A : *)
15:20:04 <royal_screwup21> hm
15:20:24 <jle`> so Val 3 can be ExprF Bool, it can be ExprF String, it can be ExprF Double, it can be ExprF Expr ... anything we want
15:20:28 <royal_screwup21> so Val 3:: ExprF String  holds true
15:20:28 <Athas> koz_: it is still being worked on, yes.
15:20:32 <royal_screwup21> I see
15:20:42 <merijn> mniip: I mean, what would you call "things of kind '* -> *'" then?
15:20:59 <jle`> right, it's the same as, say, data Either e a = Left e | Right a
15:21:07 <jle`> Left "hello" :: Either String Bool
15:21:09 <koz_> Athas: If I need to inform accelerate that LLVM lives somewhere else (specifically llvm-config), how do I do that with Stack?
15:21:10 <masaeedu[m]> @merjin type constructors?
15:21:10 <lambdabot> Unknown command, try @list
15:21:12 <koz_> (in case you know)
15:21:14 <jle`> is just as valied as Left "hello" :: Either String Double
15:21:28 <jle`> masaeedu[m]: they are not necessarily type constructors int he sense that mniip is talking about
15:21:29 <merijn> masaeedu[m]: Not all things of kind "* -> *" are type constructors
15:21:41 <mniip> type expressions
15:21:42 <merijn> masaeedu[m]: Consider "Either Int" <- not a type constructor
15:21:47 <mniip> again, literally playing devil's advocate here
15:22:11 <jle`> it's a little funky because there are two layers of meaning here; there's the 'literal'/'syntactic' sense, and the denotative sense
15:22:12 <merijn> mniip: Do you call "even 5" not a value because it's a "value expression"?
15:22:21 <masaeedu[m]> merijn: I don't follow why that's not a type constructor. maybe my terminology is wrong
15:22:28 <merijn> mniip: That seems a useless and confusing distinction
15:22:37 <mniip> merijn, is "let x = x in x" a value
15:22:39 <merijn> masaeedu[m]: Because it's an expression, not a constructor
15:22:50 <merijn> mniip: Yes. An evil one, but still
15:22:54 <jle`> masaeedu[m]: a type constructor is a purely syntactical construct, it refers to 'type literals', in a way --- the things you type into a source code to build type expressions
15:22:56 <masaeedu[m]> you can apply `Either Int` to `String` and get a type, hence `Either Int` is a type constructor
15:23:14 <jle`> type constructors are tokens that start with capital letters (or :'s if they are operators)
15:23:23 <jle`> it's a syntactical construct, not a semantic/denotative one
15:23:27 <mniip> mathematically I wouldn't say so
15:23:31 <jle`> it's on the same category as string literals
15:23:37 <merijn> masaeedu[m]: Is "even" a value constructor for Bool because you can apply it to create a Bool?
15:23:54 <jle`> "HELLO" and (map toUpper "hello") are both two expressions that denote the same string
15:24:00 <mniip> "fix id" might be an inhabitant of every lifted type, but it isn't a member of every set
15:24:31 <masaeedu[m]> merijn: I would say yes.
15:24:42 <jle`> if we had type family Id a where Id a = a, then 'Either (Id Int)' and 'Either Int' would be two different type expressions that refer to the same .... what?
15:24:53 <merijn> masaeedu[m]: Most of the functional programming world will disagree with you :)
15:25:00 <jle`> i want to say, Either (Id Int) and Either Int are two type expressions that denote the same type
15:25:19 <merijn> masaeedu[m]: In fact, the Haskell Report directly contradicts that interpretation
15:25:23 <masaeedu[m]> merijn: what is the correct meaning of value constructor?
15:25:29 <mniip> constructors are injective and generative
15:25:58 <jle`> royal_screwup21: so, you can give In any ExprF Expr, and it'll return an Expr
15:25:59 <merijn> masaeedu[m]: the "value" part is just to distinguish "constructor" at the value level from "constructor" on the type level (i.e. Nothing vs Maybe)
15:26:22 <merijn> masaeedu[m]: So [], Nothing, True, Left, all are (value) constructors
15:26:25 <merijn> "even" is not
15:26:32 <jle`> royal_screwup21: Val 3 :: ExprF Expr is a valid one.  and so is Add (In (Val 3)) (In (Val 2))
15:26:48 <mniip> is "\ -> " a constructor
15:27:08 <merijn> mniip: No
15:27:21 <mniip> but it definitely is (part of) an introduction axiom
15:27:22 <merijn> Functions don't have constructors (in Haskell)
15:27:33 <jle`> royal_screwup21: if it helps, try, with data ExprOld = ValOld Int | AddOld ExprOld ExprOld, write functions that convert back and forth between ExprOld and type Expr = Fix ExprF
15:28:30 <jle`> royal_screwup21: you'll find that the process is pretty mechanical
15:29:00 <mniip> maybe it is a constructor after all
15:29:10 <mniip> but its fields arent a binder and an expression
15:29:18 <jle`> but it's not injective?
15:29:34 <mniip> but rather an equivalence class of binder-expression pairs under whatever reduction axioms we have
15:30:25 <mniip> ah this is probably nonsense
15:30:39 --- mode: glguy set +v jackdk
15:30:51 --- mode: glguy set -v jackdk
15:31:48 <Welkin> what is this nightmare now
15:32:07 <Welkin> I have multiple libraries in use in the same module, some use lazy bytestrings, others use strict
15:32:22 <Welkin> text too
15:32:37 <Welkin> welcome qualified names: T, LT, BS, LBS
15:32:45 <Welkin> what a pain
15:32:53 <Welkin> don't forget BS8
15:33:09 <johnw> and Strings, and CStrings, yay
15:33:11 <koz_> Yeah, the 'BS' qualifier for ByteString never ceases to amuse me.
15:33:24 <royal_screwup21> thanks a lot jle`  so I'm going to define things as such: data Expr = Val Int | Add Expr Expr , data ExprF k = Val Int | Add k k, and type Expr' = fix ExprF. Trying to convert Expr -> Expr' . So, conv:: Expr -> Expr'. So conv (Val x) = In (Val x). conv (Add a b) = In (Add (conv a) (conv b))?
15:34:18 <jle`> yeah, that's exactly it :) (assuming you typechecked it and it works)
15:34:24 <jle`> try going the other way too
15:34:36 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/MuExbXKZUfUbOYrtsuZWtIbY >
15:34:48 <jle`> and then next, try writing your 'eval' to work on your Expr' instead of the original Expr
15:35:00 <mniip> Welkin, well at least it's not  Fully.Qualified.Module.Name.T
15:35:29 <mniip> masaeedu[m], type level functions are never constructors
15:35:33 <mniip> they aren't generative
15:35:54 <masaeedu[m]> idk what generative means. `Either Int` does at least seem to be injective
15:35:57 <mniip> C x = D y  implies C = D, x = y
15:36:31 <masaeedu[m]> mniip (IRC): oh. do you have a definition for generative?
15:36:40 <mniip> I just stated it
15:37:23 <mniip> it's not a property of single specific constructors or pairs of constructors though,
15:37:29 <mniip> it's a propoerty of the system as a whole
15:37:34 <jle`> masaeedu[m]: Either Int is as injective as it gets
15:37:46 <jle`> can you find a counter-example?
15:38:05 <masaeedu[m]> jle` (IRC): no, it always just maps to a distinct type
15:38:12 <jle`> exactly :)
15:38:18 <jle`> oh i see
15:38:23 <jle`> i misread what you wrote as "doesn't"
15:38:35 <jle`> my bad :)
15:38:48 <masaeedu[m]> no worries, thanks for following up anyway :)
15:39:22 <mniip> anyway, I find this exercise of analytically defining what constructors are and aren't; fairly weird
15:39:38 <mniip> usually in type theories/logic constructors are introduced synthetically
15:40:09 <nshepperd1> I like to imagine that "generative" means the juxtaposition operator is injective
15:40:30 <masaeedu[m]> ok, i think i see now. so based on your `C x = D y => C = D, x = y` definition, only things like `Either` itself that introduce a new unique type into the program can be type constructors
15:40:34 <masaeedu[m]> ignoring aliases i guess
15:41:28 <mniip> nshepperd1, as a binary function?
15:41:29 <royal_screwup21> jle`: what would it mean to write a functor instance over ExprF? I know functor instances are about fmaps on custom data types, so would I do something like: instance Functor ExprF k where fmap f (Val x) =  Val (f x)?
15:41:40 <mniip> royal_screwup21, wrong
15:41:51 <jle`> royal_screwup21: try seeing if it typechecks :O
15:41:51 <nshepperd1> mniip: yeah
15:42:31 <jle`> royal_screwup21: you're close, but remember what type the Val constructor expects
15:42:50 <Welkin> just make the errors go away!
15:43:14 <Welkin> it really is a nightmare
15:43:15 <royal_screwup21> jle`: an Int if I understand correctly, since data ExprF  k = Val Int | Add k k
15:43:20 <jle`> royal_screwup21: yeah
15:43:23 <Welkin> I can't keep track of what is lazy or strict any more
15:43:30 <jle`> so the type of fmap for ExprF is fmap :: (a -> b) -> ExprF a -> ExprF b
15:43:54 <royal_screwup21> oh
15:44:00 <mniip> Welkin, unsafeCoerce
15:44:11 <royal_screwup21> f (Val x) I guess...
15:44:16 <jle`> so fmap f (Val x) = Val _    <- this has to be an Int, but f doesn't necessarily return an Int
15:44:23 <jle`> it also doesn't necessarily take an Int, either
15:44:28 <geekosaur> Welkin, there's mono-traversable if you don't mind things occasionally going exponential time
15:44:39 <jle`> but an Int has to go in the _. what Int could you put in there?
15:44:47 <jle`> you have a few choices
15:44:57 <jle`> but only one will satisfy the Functor laws
15:45:00 <mniip> I like the number 4
15:45:32 <Welkin> I got it to work
15:45:44 <Welkin> just took a lot of digging through documentation to figure out what is what
15:45:51 * hackage serverless-haskell 0.8.1 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.8.1 (AlexeyKotlyarov)
15:46:31 <mniip> Welkin, you can hover over a type on hackage to see what page it would take you to
15:46:34 <Welkin> and knowing that you can only transform between text and bytestrings with the same strictness
15:46:44 <Welkin> I forgot about that
15:46:57 <royal_screwup21> jle`: so just Val x ?
15:47:04 <masaeedu[m]> the specific functor law of interest i guess would be `fmap id = id`
15:47:05 <jle`> yeah :)
15:47:06 <royal_screwup21> like, f (Val x) = Val x
15:47:09 <geekosaur> someday peopel will start phrasing libraries in terms of backpack so we can specify theyr'e instaniated for the typ fo string-lke thing we're using
15:47:11 <royal_screwup21> hm
15:47:23 <geekosaur> or maybe add ml-style functors
15:47:24 <jle`> royal_screwup21: fwiw, most people these days don't define Functor instance by hand; we just let GHC derive it for us
15:47:49 <jle`> but it can be a good learning experience
15:48:07 <jle`> yeah, in Haskell, the only functor law you ever need to test is fmap id = id
15:48:34 <jle`> parametricity takes care of the rest of the way
15:50:04 <mniip> that reminds me
15:50:21 <mniip> who was the first to proclaim the relationship between free theorems and profunctors
15:50:38 <masaeedu[m]> jle` (IRC): you mean you can't break the associativity law if you satisfy the identity law?
15:50:42 <mniip> I am unable to define a strict correspondence, nor find a reference
15:50:54 <mniip> masaeedu[m], that and your function has the correct typ
15:50:56 <mniip> e
15:50:59 <merijn> masaeedu[m]: In Haskell the two imply each other, yes
15:51:37 <merijn> masaeedu[m]: You need both laws in proper category theory land, but in Haskell one of the two laws suffices
15:52:00 <Welkin> how can I generate a random sequence of utf-8 characters?
15:52:08 <Welkin> getEntropy gives me garbage sometimes
15:52:20 <mniip> Welkin, Arbitrary Char?
15:52:28 <merijn> Welkin: That's a nonsensical question
15:52:48 <Welkin> how is it nonesense?
15:52:49 <merijn> Welkin: You can either mean: 1) random sequence of bytes that is valid utf-8 or 2) a random sequence of unicode characters
15:52:55 <Welkin> I need a valid utf-8 token
15:53:09 <Welkin> really?
15:53:13 <mniip> including overlong sequences?
15:53:17 <Welkin> please keep the semantic nonsense to yourself
15:53:43 <Welkin> overly long?
15:53:55 <Welkin> maybe getEntropy isn't the right solution
15:53:59 <Welkin> I was going to use uuids
15:54:05 <merijn> Welkin: It's not nonsense. If you mean the latter, just generate a random String and encode it
15:54:14 <Welkin> how exactly?
15:54:19 <merijn> Welkin: If you mean the former, that's a pretty difficult task
15:54:27 <merijn> Welkin: Char has a Random instance
15:54:38 <Welkin> I want the easiest solution
15:54:40 <koz_> Am I right in thinking that massiv is a repa wrapper?
15:54:56 <merijn> > randoms (mkStdGen 5) :: [Char]
15:54:57 <mniip> Welkin, something like 0xE0 0x82 0x80
15:54:58 <lambdabot>  "\199391\1038085\982415\721864\1037478\362923\769934\1003400\293698\1046985\...
15:54:59 <Welkin> using getEntropy I got this error: Cannot decode byte '\xc2': Data.Text.Internal.Encoding.decodeUtf8: Invalid UTF-8 stream
15:55:02 <mniip> to mean U+0080
15:55:24 <mniip> whereas the correct encoding is the shorter sequence 0xC2 0x80
15:55:55 <glguy> Welkin: You can randomly select codepoints from the range (['\0'..'\xd7ff'] ++ ['\xe000'..'\xfffd'] ++ ['\x10000'..'\x10ffff']) and then UTF-8 encode that
15:56:08 <merijn> > Data.Text.Encoding.encodeUtf8 . T.pack . take 10 $ randoms (mkStdGen 42) :: [Char]
15:56:09 <lambdabot>  error:
15:56:10 <lambdabot>      Not in scope: ‘Data.Text.Encoding.encodeUtf8’
15:56:10 <lambdabot>      No module named ‘Data.Text.Encoding’ is imported.error:
15:56:10 <masaeedu[m]> I can't think of counterexample, but is there a way to mechanically derive `fmap f . g = fmap f . fmap g` from `fmap id = id` in Haskell?
15:56:17 <Welkin> actually I think this might need to be base64 only
15:56:29 <masaeedu[m]> *derive the fact that ... from the fact that ...
15:56:30 <Welkin> since this is a token that will be send over http in acookie  header
15:56:51 <Welkin> which is why uuid seemed good
15:57:21 <merijn> masaeedu[m]: Well, not sure what you mean "mechanically derive" it's possible to prove the two equivalent, though
15:57:43 <merijn> masaeedu[m]: The proof is a bit involved compared to the fairly straightforward intuition, thoug
15:57:57 <koz_> masaeedu[m]: If you want the details: https://github.com/quchen/articles/blob/master/second_functor_law.md
15:58:00 <masaeedu[m]> right, i mean prove one starting from the other
15:58:18 <merijn> quchen to the rescue!
15:58:24 <merijn> Now I don't have to write that out
15:58:46 <koz_> quchen is also a handsome and intelligent human.
15:58:53 <koz_> s/handsome/attractive/
15:59:16 <merijn> hmm, that's not the sketch I'd give
15:59:26 <masaeedu[m]> thanks
16:00:33 <merijn> masaeedu[m]: Generally I sketch the proof like so "data Type a = ??" is basically a spine/structure with a bunch of 'a' shaped holes inside it, right? From "fmap id = id" it follows that fmap doesn't alter the overall structure
16:00:48 <merijn> (If fmap did alter the structure "fmap id = id" wouldn't hold)
16:01:48 <merijn> So, fmap only affects the 'a' holes inside Type. But can it somehow only modify *some* of those 'a's? Well, no, because fmap works on any function "a -> b", so if we'd skip any of the 'a' shaped holes, the whole thing would no longer type check
16:03:34 <merijn> So, if it can't alter the structure per "fmap id = id" and we know it can't selectively decide which 'a's to affect then "fmap f . fmap g" must both affect all "holes". Purity says the order is irrelevant, so "fmap f . fmap g" must be equivalent to "fmap (f.g)"
16:04:57 <dmwit> mmmm
16:05:13 <dmwit> That sketch appears to be missing some of the pretty deep and interesting parts of the proof.
16:05:28 <merijn> dmwit: Like?
16:05:28 <mniip> like induction on all terms?
16:05:42 <dmwit> e.g. your argument that `fmap id = id` implies that `fmap` doesn't alter the overall structure itself relies on parametricity.
16:06:04 <dmwit> (You can't avoid parametricity for this. But you haven't sketched the proof of parametricity, which is the deep and interesting part of the proof.)
16:06:20 <merijn> dmwit: Well, yes, it's an intuition for why 1 law is sufficient. Not a proof for parametricity or free theorems
16:06:43 <merijn> dmwit: Sure, the free theorem part is the interesting bit, but not required for understanding the reason you need only one law
16:07:12 <mniip> my question seems to be ignored
16:07:19 <masaeedu[m]> does the proof depend on `a` actually appearing on the RHS of `Type`?
16:07:20 <merijn> I'm not smart enough to provide an intuitive sketch for parametricity, people are better of reading the wadler paper :)
16:07:27 <mniip> what /is/ the relation between parametricity and profunctors
16:07:39 <merijn> masaeedu[m]: No
16:08:07 <mniip> masaeedu[m], "a bunch of" includes none
16:08:28 <merijn> masaeedu[m]: If there's no 'a' on the RHS than "fmap" can only be a noop
16:08:31 <Welkin> is there a way to list all existing keys?
16:08:38 <merijn> masaeedu[m]: Or "fmap id = id" wouldn't hold
16:08:38 <Welkin> wrong channel
16:09:07 <masaeedu[m]> yeah, i suppose the only such functor that satisfies the first law is Const
16:09:19 <merijn> masaeedu[m]: Proxy?
16:09:25 <mniip> Proxy = Const ()
16:09:26 <dmwit> Const () ;-)
16:09:29 <merijn> Sure
16:09:46 <mniip> masaeedu[m], in general for a particular type there is no more than one possible functor instance for it
16:10:21 <merijn> masaeedu[m]: Phil Wadler's "Theorems for Free!" is an interesting and relevant paper here
16:10:24 <Solonarv> and on top of that, figuring out what that instance is is fairly mechanical (which is why we have -XDeriveFunctor)
16:10:46 <mniip> unless you have higher kinded variables
16:11:10 <dmwit> mniip: Yeah, I was about to throw your own Compose example in your face. =)
16:11:36 <masaeedu[m]> merijn: I'll check it out. Your sketch of a proof was quite helpful for getting a general intuition
16:11:52 <Solonarv> can you write 'deriving instance (Functor f, Functor g) => Functor (Compose f g)' ?
16:12:06 <merijn> masaeedu[m]: As dmwit points out, the free theorem is the *actual* workhorse that's interesting :)
16:12:23 <mniip> anyway
16:12:27 <mniip> profunctors, right?
16:12:45 <merijn> masaeedu[m]: Which is a more thorough definition of what "must apply to all 'a's" means
16:13:05 <dmwit> Solonarv: WFM
16:13:19 <Solonarv> what? I don't know that acronym
16:13:26 <dmwit> "works for me"
16:13:41 <Solonarv> ah, thanks!
16:15:15 <Welkin> windows for men
16:15:46 <Solonarv> that makes sense; the kind of 'Compose' is too general to infer that instance; 'f', 'g', and 'Compose f g' don't necessarily have the right kind to be Functor
16:15:48 <mniip> urbandictionary has a few interesting alternatives
16:17:15 <mniip> oh hey calwoo
16:17:42 <rotaerk> oh hi mark
16:17:53 <dmwit> Solonarv: I mean, `newtype Compose f g x = Compose (f (g x)) deriving Functor` also WFM.
16:18:05 <dmwit> Solonarv: So I'm not too sure what you're on about with "too general to infer that instance".
16:19:04 <mniip> dmwit, with PolyKinds, Compose :: (l -> *) -> (k -> l) -> k -> *
16:19:13 <Solonarv> oh, huh? I guess I don't know enough about the typechecker, then
16:19:27 <dmwit> mniip: does not appear to matter
16:20:23 <calwoo> mniip: sup
16:21:35 <mniip> % :set -ddump-deriv
16:21:35 <yahb> mniip: 
16:21:45 <mniip> %% newtype Compose f g x = Compose (f (g x)) deriving Functor
16:21:46 <yahb> mniip: http://qp.mniip.com/y/36
16:22:11 <mniip> not sure if like
16:25:23 * nshepperd . o O ("data StaticMaybe (t :: Maybe *) where { StaticJust :: a -> StaticMaybe (Just a); StaticNothing :: StaticMaybe Nothing }"; Compose StaticMaybe Just ~= Identity)
16:34:45 --- mode: glguy set +v jackdk
16:34:49 --- mode: glguy set -v jackdk
16:36:19 <Welkin> what is with the hedis library?
16:36:27 <Welkin> is this really the best library for redis?
16:36:42 <Welkin> pattern matching on the result of a query is confusing
16:37:02 <Welkin> https://hackage.haskell.org/package/hedis-0.10.4/docs/Database-Redis.html#v:get
16:37:29 <Welkin> get :: RedisCtx m f => ByteString -> m (f (Maybe ByteString))
16:37:32 <Welkin> really now
16:37:57 <Welkin> what's with the fundep and the extra f?
16:38:59 <dmwit> What would you have done instead?
16:39:57 <Welkin> query :: (ToRow q, FromRow r) => Connection -> Query -> q -> IO [r] 
16:40:03 <Welkin> from postgresql-simple
16:40:09 <Welkin> it gives back IO [r]
16:40:11 <Welkin> simple!
16:40:21 * dmwit squints
16:40:26 <Welkin> or for one result, could it Maybe r
16:40:44 <glguy> https://hackage.haskell.org/package/hedis-0.10.4/docs/Database-Redis.html#g:2
16:40:45 <Welkin> I have no idea what this m f thing is
16:40:59 <Welkin> m is probably IO
16:41:02 <rotaerk> abstractions are generally built from concrete cases, so to understand the purpose for the m and f, look at what types take their place in the existing instances
16:41:12 <rotaerk> I see two instances of RedisCtx defined
16:41:18 <glguy> Welkin: It doesn't look like IO is an instance of that class
16:41:20 <dmwit> Welkin: But, like... redis and postgres are not the same tool.
16:41:38 <glguy> Welkin: You might start reading that section I linked, it seems to explain what's happening
16:41:49 <rotaerk> `RedisCtx Redis Queued` and `RedisCtx Redis (Either Reply)` are the instances
16:42:00 <rotaerk> err first should be RedisTx *
16:42:03 <dmwit> Anyway, if you click `RedisCtx` it doesn't seem like it's that hard to use.
16:42:07 <Welkin> yeah I see now m is Redis, which is an instance of MonadIO
16:42:25 <rotaerk> RedisTx is as well
16:43:09 <rotaerk> basically they wanted to unify the interface for transactional contexts and non-transactional contexts
16:43:10 <Welkin> I don't get what the extra Either is for
16:43:19 <Welkin> Either Reply (Maybe ByteString)
16:43:28 <Welkin> wher Reply could be another Maybe ByteString
16:44:29 <bsima> I quite like the hedis library
16:44:42 <bsima> I've only used it lightly though, to implement a job queue
16:45:12 <dmwit> Presumably `Left (Bulk m)` and `Right m` do not mean the same thing, and you would like to be able to differentiate between the two possible replies.
16:45:50 <dmwit> I guess I don't really understand the question. I've never used redis, but I have used `Either a a` and it is not the same as `a`.
16:45:52 <Welkin> another thing is that it looks like the type changes based on if it is inside or outside a transaction
16:46:01 <Welkin> seems like a lot of extra complexity
16:46:19 <rotaerk> I would think that Left (Bulk m) is converted into a Right m
16:46:33 <rotaerk> err Left (Bulk (Left m)) would be converted into Right m
16:46:43 <rotaerk> and any *other* response would be packed into Left
16:48:06 <Welkin> it feels like an awful lot of pattern matching to do
16:48:12 <Welkin> is there a simpler way to extract the result?
16:49:07 <Welkin> I don't know how to interpret the Left here
16:49:12 <Welkin> it looks like it could be a valid reply
16:49:48 <bsima> I think its a valid reply but it's the reply is that Redis failed at whatever you told it to do
16:51:21 <Welkin> I have 3 nested case expressions at this point, alternating between Maybe and Either
16:52:06 <bsima> yeah, I have 2 nested cases in my 'pop' function for my redis-backed job queue
16:55:49 <bsima> One option is to factor out the nested cases into small, top-level functions
16:58:26 <argent0> hi, is it possible to avoid unsafeCoerce here? https://paste.pound-python.org/show/GWdDGAE0b5SvS0rVSmPo/
16:58:33 <Welkin> and now starts the huge compiler errors
16:59:38 <mniip> argent0, it looks like you have a lexical error
16:59:45 <mniip> (a' : as) vs (a ': as)
16:59:50 <mniip> in the type of HCons
17:00:26 <mniip> which is why pattern matching on HCons did not give sufficient evidence
17:01:57 <dmwit> Well, that's a new one. I like it.
17:01:59 <dmwit> mniip++
17:02:25 <argent0> mniip: Thanks that solved the issue
17:03:00 <Axman6> huh, fun. I wonder how I've never run into that one
17:03:25 <mniip> Axman6, I'm blunt and I never prime my datakinds unless necessary
17:03:46 <Axman6> you madman
17:06:23 <lyxia> adding spaces around operators avoids that issue
17:36:57 <jackdk> I'm sad that people don't prime their datakinds. I'm also sad that too many syntax highlighters are still assuming every ' is a char literal and not a promoted ctor
17:38:30 <rotaerk> hmm is there some way to specify a type signature without replicating the name, and while satisfying -Wmissing-signatures
17:38:57 <rotaerk> I'd rather not double the number of lines here just to add signatures to these patterns:  https://github.com/Rotaerk/ktx-rw/blob/master/ktx-rw/src/Codec/Image/Ktx.hs
17:39:11 <rotaerk> when I could just add a :: GLEnum to the end of each line
17:40:20 <rotaerk> could also do something like:  pattern GL_RED :: GLEnum; pattern GL_RED = 0x1903
17:40:25 <rotaerk> but so repetitive
17:41:14 <lyxia> maybe use CPP/TH to generate it
17:42:22 <rotaerk> hmm maybe I'll just -Wno-missing-signatures >_<
17:42:33 --- mode: glguy set +v jackdk_
17:43:18 <lyxia> The inferred type will be wrong though
17:43:53 <rotaerk> I don't mind if it's more general
18:13:20 --- mode: glguy set +v fen
18:15:34 <fen> hey did anyone manage to check this? https://bpaste.net/show/06f2ba790c31
18:16:00 <fen> that was the paste on difference lists for NonEmpty using a class "Graph" ?
18:18:07 <fen> it would be good to get some feedback on it before trying to do the more involved example over StemTree
18:23:22 <fen> like, about how much it seems like a good representation for a graph
18:23:52 <fen> or at least, a class of things that can be made into a difference list
18:26:09 <fen> ok, well, here is the example for StemTree anyway;
18:26:09 <fen> https://bpaste.net/show/830142510d8c
18:26:42 <fen> the class is slightly different...
18:26:55 <fen> but it shows its use over a more complex kind of graph
18:27:35 <fen> as the StemTree has "shape" but NonEmpty is "linear"
18:28:35 <fen> it uses Free NonEmpty as the Graph, which is larger datatype but StemTree is a subset of things it can be used to represent
18:29:23 <fen> really it should be something like Free (Either (,) ()) 
18:30:06 <fen> ie \x -> Free (Either (x,x) (x))
18:30:29 <fen> but that has newtypes and compose to make this work
18:31:06 <fen> really type level lambdas would be great for this, but the type level function equivalent using type familes would only confuse the presentation
18:31:59 <fen> so it just uses Free NonEmpty and would break if trying to cast from Free NonEmpty if the NonEmpty lists had more than two elements 
18:32:10 <fen> to StemTree
18:32:35 <fen> ...
18:32:41 <fen> the line  data FNEZDirections = UP | RIGHT | DOWN
18:33:00 <fen> shows how "directions" are given to navigate over the free structure
18:33:57 <fen> these navigations are updated along the path between values, over intermediate locations that dont contain values
18:34:37 <fen> which are Zippers over e.g. (Stem (Stem (Leaf a))) which are navigated part of the way down
18:35:23 <fen> it goes up from the value until it reaches a branch, and then down along that branch, detaching the previous branch and adding it to the difference list
18:36:29 <fen> it repeatedly does this, forming the difference list of all the branches, until it hits the top right corner, and then it does  const . createi undefined
18:36:56 <fen> the integer values which are accumulated along the path between values acts as an argument to seti
18:37:44 <fen> reversing the navigation up from the value currently pointed to, until it reaches the place the detached branch should be rejoined
18:38:24 <fen> and then down along that branch until it reaches the value,ready to recieve the next reconstructing difference (seti ((Int,Int),a)
18:39:08 <fen> all the branches that are detached are linear, i.e. just consist of Stems and Leafs without branches
18:39:17 <fen> thats why StemTree was used for the example
18:40:06 <fen> as if Empty values were included (leafs without values, e.g. using [] instead of NonEmpty) then the branches could have funkey shapes
18:58:13 <enterprisey> via Mastodon:
18:58:15 <enterprisey> "What's that Haskell repo with all the unsafe operations with the really long names"
19:00:23 <zenspider> having problems with `stack ghci` not finding my test deps when `stack test` works fine: https://gist.github.com/zenspider/24b0b494d6d4e0cbcb91d8621c8476e8
19:00:54 <zenspider> can someone clue me in? I'm about to nuke stack and start clean with a plain ghc install... this tooling is driving me bonkers
19:04:20 <zenspider> further data: if I run `stack ghci --test` it seems to work... but why isn`t `stack ghci` aware of the stack declared deps?
19:05:45 <zenspider> I've rolled back EVERYTHING trying to get my dev enviroment smoothed out and only just realized that this has nothing to do with emacs / haskell-mode / intero
19:20:27 <freusque> what is the design pattern or language feature that allows to configure a function's type via a value-level argument?
19:20:52 <freusque> i.e. https://gist.github.com/freuk/172ac94e45228f6c4f251d2cdc3f6eaa
19:21:59 <infinity0> freusque: you probably want type families and datakinds
19:23:19 <freusque> thanks, do you know of an example of this in the wild?
19:23:59 <infinity0> no, sorry
19:25:01 <freusque> thx :) I'm a bit worried going that route. I assume it would make the codebase less accessible.
19:25:29 <infinity0> also with type families you wouldn't match on the "type constructor of the first argument" but you'd have a separate type param of kind NAG|OGD
19:25:45 <infinity0> in order to write code that you want that actually "matches on the type constructor" you'd need dependent types which is not yet in haskell
19:26:00 <maerwald> what's wrong with boilerplate?
19:26:12 <maerwald> unless it's a lot and repetitive
19:26:59 <freusque> this example is the proof of concept for that codebase
19:27:05 <freusque> it will be a lot and repetitive :)
19:27:20 <infinity0> type families are pretty nice and powerful but it takes a while to know how to use them appropriately
19:27:35 <infinity0> so yeah if this code is going to live a long time, and it's your first time using type families, you probably want to practise with smaller non-trivial examples first
19:35:04 <zenspider> `stack ghci test/Test.hs` works fine, even with `:load`, but `stack ghci` followed by `:load` blows up
19:40:08 <jle`> freusque: having a type depend on a value-level argument is pretty much the definition of dependent types
19:40:35 <jle`> ah, it looks like you don't mean having the type of a function depend on its agument, but rather on the type of a function call within the function
19:40:43 <maerwald> zenspider: blows up?
19:40:45 <jle`> that doesn't necessarily imply dependent types
19:41:08 <jle`> freusque: in your specific code example, you can use -XTypeApplications to make things a little nicer in the call to makeSupervisedLearner
19:41:11 <maerwald> zenspider: it will probably load the whole project I think
19:42:07 <freusque> I do mean having the type of a function depend on its argument
19:42:22 <freusque> that wrapper 'go' function is just there to help this code compile
19:42:51 <freusque> I'm not familiar with that extension. looking into it. Thank you for your answer.
19:43:03 <jle`> bu the result of the function is the same in either case
19:43:26 <jle`> in maincall learner problem dataBackend
19:43:48 <jle`> the reuslt of maincall learner problem dataBackend is always the same type, but the type of the internal functions you use to compute the result can change
19:43:52 <freusque> the result of this 'makeSupervisedLearner' is what I'd like to programatically express
19:43:57 <freusque> yes, I agree
19:45:41 <zenspider> maerwald: please see my gist above
19:45:42 <jle`> hm, if you want to programatically express the type of the parameters to makeSupervisedLearner, you can turn Learner and Problem into GADTs
19:46:02 <jle`> that way, the constructors are also associated with specific type variables, which can be passed to makeSupervisedLearner
19:46:08 <zenspider> maerwald: https://gist.github.com/zenspider/24b0b494d6d4e0cbcb91d8621c8476e8
19:46:17 <freusque> t's the return type I'd like to programatically express, just to be clear
19:46:48 <maerwald> zenspider: you already seem to have answered your question
19:46:49 <jle`> yes, the return type is a part of the type variables, so it is fair game
19:47:05 <zenspider> maerwald: I haven't answered anything... only added more questions
19:47:15 <maerwald> "further data: if I run `stack ghci --test` it seems to work... but why isn`t `stack ghci` aware of the stack declared deps?"
19:47:20 <maerwald> there is your answer: use stack ghci --test
19:47:43 <zenspider> and yet, there's another question that is unanswered...
19:48:08 <zenspider> maerwald: ultimately, I want to fire up a repl in haskell-mode ... it isn't specifying --test (nor should it most of the time)
19:48:20 <maerwald> zenspider: did you try without stack?
19:49:13 <zenspider> maerwald: I don't have much of a choice. ALL of my current pain is being caused by trying to switch to stack.
19:49:23 <maerwald> why would you switch to it?
19:49:32 <zenspider> but, if you want to work on pretty much anything, you need to use stack
19:49:37 <maerwald> not really
19:50:08 <freusque> okay, one vote for type families, one vote for gadts then :)
19:50:16 <zenspider> maerwald: we're done. You're not actually interested in helping. I'm not interested in justifying to a devil's advocate.
19:50:28 <maerwald> zenspider: no, I'm trying to understand your use case
19:50:29 <freusque> thank you jle` 
19:50:31 <zenspider> thank you, but your line of questioning isn't clarifying anything
19:50:36 <maerwald> you don't need stack to use GHC
19:50:54 <maerwald> there are use cases, but if you don't know why you use stack, you probably don't need it
19:51:01 <maerwald> just use cabal
19:53:05 <maerwald> don't make people guess what you want :)
19:53:25 <MarcelineVQ> zenspider: what version of stackdo you have? what does your cabal file look like?
19:53:49 <freusque> one question about the gadt approach jle`  though,
19:54:16 <freusque> I'm unfamiliar with them, basically I use these Learner and  Problem to parse some configuration
19:54:42 <freusque> it's quite important that I should be able to derive something like Read for these
19:54:58 <freusque> would turning them into gadts be problematic?
19:56:15 <hexfive> thoughts on this? https://repl.it/repls/SubduedUglyHypothesis
19:56:25 <zenspider> MarcelineVQ: stack v 1.9.1. the cabal file is from the very first exercise in exercism.io... it has 2 targets and the test target specifies hspec (which is the dep not being looked up on :load)
19:56:39 <zenspider> I can paste it, but 90% of it is unrelated noise
19:56:51 <MarcelineVQ> zenspider: stack doesn't load things from the testing stanza's unless you pass a --test flag
19:56:53 <jle`> freusque: you can still derive Read and Show for GADTs
19:57:07 <freusque> tremendous
19:57:10 <freusque> :)
19:57:18 <zenspider> MarcelineVQ: "stanza" == "target"? 
19:58:21 <zenspider> MarcelineVQ: but.. will doing `--test` when I'm firing up the repl from a non-test file cause problems?
19:58:57 --- mode: glguy set +v M566754567gh[m]
19:59:55 <zenspider> looks like I need to tweak out haskell-process-args-ghci
20:01:46 <maerwald> cabal always attempts to solve test suite dependencies
20:01:48 <MarcelineVQ> there's overlap between the terms, though they're not the same, a stanza is some particular section of a cabal file. a target is a buildable component of some package.
20:02:30 <maerwald> so with cabal, this should just work
20:03:32 <zenspider> MarcelineVQ: thank you. that helps some things click
20:12:36 <zenspider> ok... that variable fixed it... tho it still feels like I might need to advise around its usage when I'm firing up w/o a test
20:12:47 <zenspider> now I'm getting process errors because of "Some flags have not been recognized: prompt2, λ|"
20:12:56 <zenspider> was that removed or something?
20:13:33 <zenspider> renamed to prompt-cont ?
20:15:22 <maerwald> https://github.com/haskell/haskell-mode/issues/1569#issuecomment-345376987
20:17:34 <zenspider> unfortunately there's a LOT of issues open on this topic... even some PRs to fix it... starting to wonder if I should look at alternative packages for haskell dev
20:17:45 <zenspider> it seems like most ppl stick to this one
20:18:25 <maerwald> there is only one tool that works for me, which is codex. I've stopped trying intero, ghc-mod, hie and everything else
20:18:43 <maerwald> either bugs or they blow up your memory on big projects
20:19:52 <slack1256> try ghcid
20:20:08 <MarcelineVQ> maerwald: ghc 8.6 made some changes that may assist with the memory use
20:20:38 <maerwald> slack1256: I did.
20:20:41 <maerwald> buggy
20:20:52 <slack1256> ;_;
20:21:11 <zenspider> I haven't heard of codex yet
20:21:34 <maerwald> it's less precise, but... hey it's instant and memory footprint is zero (after you've created the tags file)
20:21:55 <maerwald> so I frequently jump to function definitions just to see their types, because it's fast enough
20:22:38 <maerwald> comparing that with intero... it tries to load type info for your entire project at start and then gets oom killed 
20:22:44 <zenspider> a tags generator? I think I was using hasktags or somesuch but I mostly use ctags
20:23:08 <slack1256> intero was the reason I learned to use cgroups. It was a kind of win in the end
20:23:20 <maerwald> codex uses hasktags
20:23:54 <zenspider> ah. shit. ctags doesn't do haskell
21:27:59 <johnw> could someone who also knows ocaml tell me what "type1 ref type2" might mean?
21:28:09 <johnw> i'm trying to transcode some ocaml into Haskell
21:33:26 --- mode: glguy set +v bronto_
21:33:54 <lone_ranger> mniip: I can can the factorial and reciprocal of the factorial, but I cannot get a list of powers with scan, some pointers would be great
21:34:39 <c_wraith> like n^0, n^1, n^2, etc?
21:35:21 <c_wraith> That's really better done with iterate than a scan, but you could do it with a scan
21:39:14 <MarcelineVQ> johnw: hmm, just seeing ref as its own single argument type, like a -> a ref   related to pointers. Is there any more context?   If you find no leads and it's important is it possible to be cheeky and go  ocaml -> coq -> haskell?  like with coq-of-ocaml
21:42:52 <johnw> i think it means that type2 has kind * -> *, and takes a Ptr type1 as a parameter, essentially
21:43:09 <johnw> which seems to bear out
21:43:22 <johnw> i've never looked at OCaml before
21:50:06 <lone_ranger> c_wraith: yeah I've seen it with iterate
21:50:17 <lone_ranger> I am just trying to get scan figured out
21:50:23 <lone_ranger> but on paper its possile
21:50:54 <lone_ranger> so I'd appreciate any pointers
21:51:09 <c_wraith> consider what you'd like the input list to look like
21:51:50 <johnw> think of the meaning of ^
22:11:03 <lone_ranger> c_wraith: well I can only think of the input list being all the same, if I was to do all the powers of 2 like so scanl (*) 2 [2,2,2] but thats not going anywhere
22:11:58 <c_wraith> I'd make the base case 1...  But why isn't that satisfactory?
22:12:55 <lone_ranger> c_wraith: becuase I'm not sure how to create a list filled with two's I guess
22:13:07 <lone_ranger> but thats ok? my solution?
22:13:13 <c_wraith> yeah, that's how I'd do it
22:13:20 <c_wraith> > repeat 1
22:13:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:13:37 <lone_ranger> neato
22:13:40 <c_wraith> > [2,2..] -- or this
22:13:42 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
22:15:31 <c_wraith> But yeah, I'd use something like...
22:15:38 <c_wraith> :t scanl (*) 1 . repeat
22:15:40 <lambdabot> Num b => b -> [b]
22:15:56 <c_wraith> > (scanl (*) 1 . repeat) 5
22:15:58 <lambdabot>  [1,5,25,125,625,3125,15625,78125,390625,1953125,9765625,48828125,244140625,1...
22:16:05 <koz_> c_wraith: That's pretty cool.
22:16:18 <lone_ranger> yeah I was gonna ask how you avoided the infinite list
22:16:23 <lone_ranger> awesome thanks
22:16:40 <lone_ranger> didnt know about repeat , that definitly helps
22:18:33 <lone_ranger> :t rep
22:18:34 <lambdabot> error:
22:18:35 <lambdabot>     • Variable not in scope: rep
22:18:35 <lambdabot>     • Perhaps you meant one of these:
22:19:14 <lone_ranger> :t repeat
22:19:15 <lambdabot> a -> [a]
22:19:20 <koz_> Does anyone here have experience configuring ALE for linting Haskell? I wanna pass some additional args to its invocation of 'stack ghc'.
22:21:19 <Arahael> I only have experience drinking it.
22:21:25 <lone_ranger> lol
22:21:37 * koz_ was expecting at least _one_ similar answer.
22:22:11 <lone_ranger> I always wonder, is it correct to say at least one?
22:22:18 <lone_ranger> could have none I guess
22:23:53 <c_wraith> yep.  perfectly reasonable thing to say
22:28:11 <koz_> What does the -v0 option do when passed to GHC? I'm trying to understand what ALE's invoking.
22:28:33 <c_wraith> is that the option for turning off the virtual timer interrupts?
22:29:26 <c_wraith> Hmm, no, that's -V0
22:29:42 <geekosaur> that's uppercase V and part of the rts optios. -v0is a way to among other things make ghci less chatty
22:29:58 <geekosaur> and trn off progress messages during compilation
22:30:38 <koz_> geekosaur: Ah, thanks. That makes sense.
22:30:51 <koz_> For some reason, enabling extra warnings isn't being friendly, lol.
22:43:27 <koz_> Wow, ALE is really wacky.
22:43:43 <koz_> It allows you to configure the options passed to _every_ Haskell linter _except_ stack ghc.
22:43:48 <koz_> What is this I don't even.
23:01:43 <koz_> But at long last, I can have the sweet, delicious QuantifiedConstraints _and_ checking in Neovim.
23:11:34 <lone_ranger> is it possible to represent the taylor series for e with scanl? (i.e list of x^k/k!) ) i've tried everything...
23:12:51 <c_wraith> scanl can always reduce to a map by ignoring the current state, so sure.  But you can probably do better.
23:14:10 <c_wraith> take your values of k from the input list.  how do you go from x^(k-1)/(k - 1)! to x^k/k! ?
23:14:22 <lone_ranger> sure I scan, I could just do sum [x^k / fac k | k <- [0..k]] where fac k = product k, but trying scanl
23:14:38 --- mode: glguy set +v markso
23:16:18 --- mode: glguy set +v chaseries
23:16:36 <chaseries> (Knowing virtually nothing about compilers, that is. I imagine I should start there, but I don't know where to begin!)
23:17:43 <lone_ranger> c_wraith: not sure, but its a list with values less than k to k
23:18:06 <lone_ranger> at least the input
23:20:08 <lone_ranger> chaseries: writing a compiler in haskell you mean?
23:21:12 <chaseries> lone_ranger: Yeah, writing a compiler of a Haskell in Haskell to JavaScript.
23:21:32 <chaseries> PureScript's deal, essentially.
23:21:42 <lone_ranger> ambitious
23:22:05 <lone_ranger> if its your first
23:23:25 <chaseries> yeah, i'm not sure where it's going to go, but i'd like to give it a shot.
23:23:36 <chaseries> at least to learn something
23:24:22 <lone_ranger> i humbly recommend a smaller language like oberon
23:29:04 <chaseries> i'm more than happy to take the recommendation! i don't mean to sound overly-ambitious; i realize there's in insane amount of work by many people involved in a real PL. just trying to poke around, really, and i enjoy haskell.
23:29:45 <lone_ranger> yeah I'm no one to talk but oberons or some subset would be much simpler
23:29:50 <lone_ranger> the grammar fits in one page
23:29:54 <lone_ranger> iirc
23:30:30 <lone_ranger> chaseries: good luck!
23:32:03 <chaseries> lone_ranger: thank you. i'm checking out oberon right now.
23:34:30 <cocreature> chaseries: depending on your goals a typechecker for simply-typed lambda calculus + an interpreter might be a good start
23:35:01 <koz_> cocreature: Thanks for responding on llvm-hs's Github! Would the symlink executable suggestion break anything else?
23:35:18 <koz_> (shuffling my PATH around is a tricky business, as Gentoo sets up LLVM in, ahem, an interesting way)
23:35:45 <cocreature> koz_: I don’t see how it would. the ubuntu and debian packages for LLVM already ship with the renamed executable
23:35:53 <koz_> Ah, OK. I'll try that, then.
23:35:59 <koz_> Might as well shave _one more_ yak.
23:36:53 <koz_> Also, I assume you meant llvm-config-6, right?
23:37:05 <koz_> Since I'm trying to get it to find LLVM6, not LLVM7 which it's currently grabbing.
23:37:12 <koz_> (Accelerate doesn't support LLVM7 sadly)
23:37:53 <cocreature> oh right, I didn’t read your error message properly
23:46:07 <koz_> Aww, no GHC 8.6 with this, damn.
23:46:13 <koz_> Oh well, I'll just wait for a release then.
23:46:54 <cocreature> koz_: llvm-hs 7.0 supports GHC 8.6 ;)
23:47:05 <cocreature> but at this point you probably don’t want to use 8.6 anyway
23:47:21 <koz_> cocreature: Yeah, but Accelerate doesn't as-yet.
23:47:22 <Athas> koz_: while Accelerate *is* actively developed, it's not as actively developed as LLVM is. :-)
23:47:35 <koz_> I guess I _could_ just generate the LLVM stuff I want myself.
23:47:40 <Athas> These compatibility issues have also been something I constantly encounter.
23:47:47 <koz_> Athas: Tell me about it...
23:48:17 <cocreature> in the past trevor has been quite fast, usually a matter of days but I guess he’s probably busy with something else atm
23:48:19 <Athas> It's a shame.  Accelerate's API is pretty nice, but the setup is always a struggle.
23:48:27 <Athas> (Repa is the other way around.)
23:48:31 <koz_> Athas: Linking to C things is a pain.
23:48:41 <koz_> (C++ things I guess would be more accurate)
23:49:18 <Athas> LLVM just moves really fast and has dubious compatibility guarantees.
23:49:25 <Athas> A lot like a Haskell library, really!
23:49:31 <koz_> Athas: Yep, had _that_ hit me a few times.
23:49:43 <cocreature> oh they’re quite clear that they’re not making any compatibility guarantees :)
23:49:47 <koz_> (it's one reason why Gentoo won't be able to unmask Julia > 0.6.3 this end of... ever?)
23:50:11 <cocreature> they even changed their versioning scheme to only have x.* releases and *.*.x to make it clear that all major releases are breaking
23:52:07 <Athas> Is it their bitcode format that remains stable?
23:53:04 <cocreature> yeah, they do offer some guarantees for that
23:57:27 <cocreature> koz_: fwiw the number of breaking changes in llvm-hs-7 has been relatively small so if you’re interested, fixing accelerate should be relatively straight forward
