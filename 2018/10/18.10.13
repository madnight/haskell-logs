00:27:12 --- mode: glguy set +v frustrateddd
00:28:50 <frustrateddd> https://www.seas.upenn.edu/~cis194/spring13/lectures.html    is this for experienced programmers?
00:29:17 <frustrateddd> I am complete programming newbie other than knwoing syntax in few languages
00:38:42 <Lycurgus> as CS 1nn, presumably not
00:38:55 <frustrateddd> hi
00:51:17 <frustrateddd> any one online ?
01:00:41 <Lycurgus> frustrateddd, there are 1215 users in this channel right now, not all of whom are human. Do you have a specific question about haskell?
01:01:51 <ryjm> who isn't human 
01:01:52 <ryjm> show yourself!
01:02:20 <frustrateddd> I asked above
01:02:31 <frustrateddd> https://www.seas.upenn.edu/~cis194/spring13/lectures.html    is this for experienced programmers?
01:02:39 <frustrateddd> I am complete programming newbie other than knwoing syntax in few languages
01:03:04 <ryjm> but are you human
01:03:14 <frustrateddd> What ?
01:05:09 <koz_> frustrateddd: At a quick glance, it doesn't appear to be for experienced programmers.
01:06:41 <Lycurgus> haskell isn't oriented toward 'experienced programmers' anyway so the question is somewhat moot
01:06:42 <ryjm> iuno it goes pretty fast
01:07:51 <frustrateddd> OK I got my answer
01:21:49 <oldandwise> need help, with an error today with an update: http://termbin.com/1tlw
01:26:15 <Lycurgus> are you running in cygwin?
01:26:45 <cocreature> looks like nixos
01:26:58 <cocreature> oldandwise: which version of stack are you using?
01:26:59 <Lycurgus> on win64?
01:27:38 <Lycurgus> nixos runs on windows now?
01:28:34 <cocreature> I don’t think that’s on win64, that’s just a comment in the install script which is presumably crossplatform
01:29:08 <Lycurgus> i thought that too but seemed less likely
01:29:49 <Lycurgus> since I would expect the display to occur only when apropos
01:29:54 <cocreature> I’ve never seen “/run/current-system/sw/” on anything but nixos
01:30:00 <cocreature> but anyway there is no point in guessing :)
01:30:24 <Lycurgus> i suppose you could run nix on cygwin
01:30:30 <Lycurgus> but not nixos ofc
01:31:04 <Lycurgus> but I haven't been a nix/nixos regular user in nearly a decade
01:31:16 <MarcelineVQ> oldandwise: what are you typing to get that output?
01:31:44 <oldandwise> i'm using nixos. Stack is Version 1.6.5 x86_64
01:32:25 <oldandwise> MarcelineVQ: from 'exercism' on haskell. I typed `stack test'
01:33:41 <cocreature> as a first step, I would recommend that you upgrade to the latest stack release
01:34:35 <cocreature> iirc stack on nixos only works with stack’s nix integration. I think that’s the default these days so try upgrading and if that doesn’t help try passing --nix
01:43:31 --- mode: glguy set +v funrep_
01:43:32 <funrep_> hello, is it possible to use attoparsec with lazy bytestrings? it says in the docs it still uses strict bytestrings internally, does this mean the parser will be performed strictly?
02:05:58 <electrocat> funrep_: for each chunk of the lazy bytestring, the strict parser is called
02:08:05 <electrocat> it just means lazy parsing is implemented using the strict version
02:30:48 --- mode: glguy set +v funrep_
02:44:55 --- mode: glguy set +v govno
02:55:52 --- mode: glguy set +v reactormonk
02:56:10 --- mode: glguy set -v reactormonk
03:12:38 <lkurusa> is there a way convert a String to a Data.ByteString.Lazy.ByteString ?
03:13:00 <dminuoso> lkurusa: Of course. :)
03:13:03 <lkurusa> i'm trying to read in a csv file and decode it with cassava but reading the file in is giving me a hard time because of the type the decode function of cassava is expecting
03:13:14 <lkurusa> dminuoso: i looked at pack
03:13:25 <lkurusa> but that complains about GHC.*.Word8
03:13:36 <dminuoso> lkurusa: Well the first consideration is encoding.
03:13:46 <dminuoso> lkurusa: GHC can't know in advance what encoding your bytestring should be in.
03:14:02 <lkurusa> fair point
03:14:05 <lkurusa> it's ascii
03:14:06 <lkurusa> :)
03:16:45 <dminuoso> % import Data.ByteString.Lazy
03:16:45 <yahb> dminuoso: 
03:17:41 <dminuoso> lkurusa: Oh. Data.ByteString.Lazy.Char8
03:17:43 <dminuoso> Is what you want :)
03:17:44 <Axman6> lkurusa: can you tell us a bit more about what you're trying to do?
03:18:07 <lkurusa> Axman6: read in a csv file, and then extract some data :)
03:18:27 <Axman6> are you reading the file as a String? because yo can read a lazy ByteString directly from a file
03:18:29 <lkurusa> dminuoso: ah, let me try
03:18:29 <dminuoso> lkurusa: Oh. Then use something that gives you a bytestring/text off the bat. Don't go through `String`
03:18:34 <kuribas> is there a haskell replacement for apache shiro?  We've started writing a rest API, and there was interest in using haskell insteaod of clojure.
03:18:42 <lkurusa> you're right actually
03:18:48 <dminuoso> lkurusa: String/[] is about the most inefficient datatype we have for non-trivial data amounts
03:18:50 <kuribas> They wanted to use apache shiro, so we need a haskell replacement for that;
03:18:51 <Axman6> % import Data.Bytestring.Lazy as LazyBS
03:18:51 <yahb> Axman6: ; <no location info>: error:; Could not find module `Data.Bytestring.Lazy'; Perhaps you meant; Data.ByteString.Lazy (from bytestring-0.10.8.2); Data.ByteString.Lens (from lens-4.16.1); Data.ByteString.Char8 (from bytestring-0.10.8.2)
03:18:51 <lkurusa> i can then use overloadedstrings when testing via ghci
03:19:00 <Axman6> % import Data.ByteString.Lazy as LazyBS
03:19:00 <yahb> Axman6: 
03:19:09 <lkurusa> thanks, that's great advice!
03:19:11 <lkurusa> i'll try now
03:19:13 <Axman6> % :t LazyBS.readFile
03:19:13 <yahb> Axman6: FilePath -> IO ByteString
03:20:14 <Axman6> % import Text.CSV as CSV
03:20:15 <yahb> Axman6: ; <no location info>: error:; Could not find module `Text.CSV'; It is not a module in the current program, or in any known package.
03:20:33 <dminuoso> lkurusa: So `String` is just a typealias for `[Char]` - so you get an box with indirection for every single character.
03:20:37 <Axman6> % import Text.Csv as Csv
03:20:37 <yahb> Axman6: ; <no location info>: error:; Could not find module `Text.Csv'; It is not a module in the current program, or in any known package.
03:20:45 <lkurusa> yeah i remember that :)
03:20:45 <Axman6> % import Data.Csv as Csv
03:20:46 <yahb> Axman6: ; <no location info>: error:; Could not find module `Data.Csv'; It is not a module in the current program, or in any known package.
03:20:51 <Axman6> :(
03:21:08 <lkurusa> i used to do a lot more haskell in college, but i got rusty (funnily, enough via the Rust language)
03:21:25 <lkurusa> that comma was a mistake, but yeah, thanks for the help :)
03:21:52 <Axman6> kuribas: what does Shiro do?
03:22:21 <kuribas> Axman6: I wish I knew...  Acording to the website:  authentication, authorization, cryptography, and session management
03:22:45 <Axman6> yeah that doesn't tell me very much :(
03:23:11 <Axman6> there's auth libraries for Servant, which is my goto for web dev
03:23:16 <kuribas> https://shiro.apache.org/introduction.html
03:23:39 <kuribas> Axman6: it servant auth production ready?
03:24:20 <Axman6> is anything? =)
03:24:48 <kuribas> Axman6: Apache shiro apparently..
03:25:14 <dminuoso> lkurusa: A single string of 100 characters would consume at least 4KiB of memory if my math is not off. And you get piss poor cache locality when linearly going through that because of double pointed indirection. 
03:25:32 <lkurusa> wow that *is* inefficient
03:25:36 <dminuoso> Yes.
03:25:42 <lkurusa> crazy
03:25:46 <lkurusa> thanks for the headsup!
03:25:47 <Axman6> dminuoso: it'll be slightly less awful than that, but not much
03:25:49 <dminuoso> There's two pointers in between each character.
03:26:07 <dminuoso> Axman6: What do you mean?
03:27:40 <ggole> Persistent lists tend to cache much better than the worst possible case
03:27:47 <ggole> It's still a hilarious representation
03:28:36 <dminuoso> ggole: What is a persistent list? Is that one that is baked into compile time?
03:29:30 <ggole> Immutable lists with sharing, as in Haskell
03:29:40 <dminuoso> ggole: in a best case, how many consecutive characters would you into one cache line though?
03:29:51 <dminuoso> assuming modern intel architecture with 64 byte cachelines
03:30:05 <ggole> Oh, far fewer than with a real string. No question there.
03:30:47 <Axman6> it's quite likely the data is read into a CString and lazily read
03:31:29 <dminuoso> Axman6: Even when you use say System.IO.hGetContents ?
03:31:49 <Axman6> I'd be really surprised if it's not reading in a buffer at a time
03:32:02 <Axman6> anyway, don't use String
03:32:38 <dminuoso> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Handle.Text.html#lazyReadBuffered
03:32:47 <dminuoso> Ah that's still interesting to know, thanks Axman6.
03:52:54 <kuribas> is there a DSL for sql that doesn't do database management?
03:53:09 <kuribas> just generating SQL statements?
03:59:04 <kuribas> hmm, maybe relational-record
04:09:19 <jluttine> it's not possible to lift over record syntax, so what would be a nice way to implement this correctly: https://gist.github.com/jluttine/7e7256108b281b8db79f4df6924c942f
04:09:53 <jluttine> (i hope that example gives the idea what i want although it's obviously incorrect syntax)
04:10:48 <Axman6> well, you can do Person <$> Just "John Doe" <*> Nothing
04:11:08 <jluttine> yep
04:11:22 <jluttine> but i'd like to use record syntax so that it doesn't depend on the order
04:11:41 <jluttine> i can use do-notation too, yes
04:11:48 <jluttine> but would like avoid that too :)
04:11:50 <Axman6> kuribas: it's _possible_ to do that with beam
04:12:15 <jluttine> just thinking if there was some other simple nice way to use the record syntax in this case
04:12:27 <kuribas> Axman6: beam is nice, but it's also heavy with extensions...
04:12:30 <jluttine> but i'm now using the exact same thing Axman6 suggested
04:12:32 <kuribas> Axman6: I try to keep it simple
04:12:41 <Axman6> step #1, don't use record syntax ever =)
04:13:02 <jluttine> :(
04:13:07 <jluttine> why not? :o
04:13:11 <kuribas> I use record syntax
04:13:16 <kuribas> though not so often
04:13:19 <Axman6> (well, records have their place, but they stop being useful pretty quickly)
04:13:23 <kuribas> lenses are better
04:13:32 <jluttine> hmm..
04:13:41 <Axman6> records + (automatically generated) lenses are great
04:14:01 <kuribas> records also give you easy serialisation for json etc...
04:15:41 <Axman6> I've gone off automatic json serialisation
04:15:55 <Axman6> it's caused a lot of problems in our project
04:16:35 <Axman6> (particularly the interacting between Aeson and Swagger, where the latter makes assumptions about the former which are often not true for things like newtypes)
04:17:13 <kuribas> Axman6: you can tune it
05:17:32 --- mode: glguy set +v deargod
05:17:34 <deargod> Dear God(s) and/or anyone else who is able to help me (e.g. superintelligent alien intelligence(s)):  The next time I wake up, please transform my physical form to that of Finn McMillan of South New Brighton at 8 years old and keep it that way FOREVER.  Thank you.  - Chaul Jhin Kim
05:18:29 <Rembane> Good plan. 
05:29:09 <boj> maybe we can encode that into the type system
05:31:42 <Rembane> I really hope so
05:35:04 <coldpress> is that a parody of the freenode pedo bots?
06:20:43 <hpc> i have an existing service i am controlling with some haskell code
06:21:03 <hpc> its config file format can do things like for example, you can write port 80 or "http"
06:21:30 <hpc> since i am wrapping around it anyway, is it worth writing a data type for the config that supports the names?
06:21:56 <hpc> this is more of a philosophical question than a technical one
06:25:07 * Lycurgus notes that only the default public non encrypted http uses port 80
06:25:16 <hpc> that's just an example
06:25:29 <hpc> 443 would be "https"
06:35:40 --- mode: glguy set +v frustratedd
06:36:48 <frustratedd> hi https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
06:36:59 <frustratedd> any one checked this m?
06:37:14 <frustratedd> it is a Haskell Book ?
06:37:24 <frustratedd> but I need to know Scheme ?
06:37:36 <frustratedd> I am a complete beginner can I use  above resource
06:38:40 <dstolfa> frustratedd: starting by writing an interpreter and a parser is probably not the right thing to do if you're a complete beginner. it might be good to familiarise yourself with some concepts in functional programming first, ignoring any kind of effects
06:39:50 <frustratedd> dstolfa:  Okay bit that author mentioned "By the time you finish, you should become fairly fluent in Haskell and Scheme. "
06:39:59 <frustratedd> So I am curious
07:00:54 <Amras> another sdl question; googling around says that a loaded image should be put through SDL_DisplayFormat when it's loaded to prevent conversion every time it's blitted. Doesn't seem like haskell's sdl2 exposes that though, and none of the other methods I've tried seem to work
07:01:36 <Amras> If I'm understanding right, what I want is a Surface identical to the Surface I've loaded but with its surfaceFormat set to that of the display
07:04:42 <cocreature> Amras: SDL_DisplayFormat is an sdl 1 function. I think for sdl2 you want SDL_ConvertSurface
07:05:49 <dmwit> hpc: I wouldn't put the names in the data type unless you're planning to support exact-printing of configs back to disk after modifying them.
07:06:00 <dmwit> Having them in the parser is enough.
07:06:30 <dmwit> (Or maybe I've misunderstood?)
07:10:23 <frustratedd> https://www.youtube.com/watch?v=XrNdvWqxBvA  love the way he explain
07:12:18 <Amras> thanks, cocreature 
07:15:56 <hpc> dmwit: that makes sense
07:16:57 <hpc> my code is basically a frontend for the config plus automatically reloading it
07:17:28 <hpc> so the flow of data goes read from disk, present it in a pretty way, let users edit it, and write it back
07:17:57 <dmwit> Oops, all of a sudden maybe it does sound like you're planning to support exact-printing. =)
07:18:05 <hpc> so the whole question hinges on how difficult/ambiguous it is to go back and forth between a canonical form and human-readable form, i suppose?
07:18:11 <hpc> because it's going both ways
07:18:41 <hpc> for port numbers it's probably safe from a practical perspective to not have service names in the canonical form
07:18:49 <hpc> they don't really ever change
07:19:34 <hpc> unless you want to express some more complicated things maybe?
07:19:48 <hpc> like if you want to sneak past a hotel's captive gateway you might run ssh on port 53
07:20:07 <hpc> so in rules being able to distinguish between "intended" dns and stuff that happens to share the port is reasonable?
07:21:41 <hpc> although this wouldn't be able to distinguish anyway...
07:21:46 <hpc> dmwit: i think you've solved my problem :D
07:24:24 <dmwit> All my coworkers agree, I'm one of the finest brick walls around.
07:24:40 <dmwit> (...or do they say "brick brain"? I can never remember...)
07:26:09 <hpc> rubber duck
07:26:18 <hpc> https://en.wikipedia.org/wiki/Rubber_duck_debugging
07:26:38 <hpc> sometimes just being able to state the obvious is enough to get someone past a mental block
07:27:08 <hpc> i do that all the time too, someone will ask "what is x y z about $complicated_thing"
07:27:14 <rgr> that is very true. A relation to just "thinking out loud". 
07:27:26 <hpc> and i always start with saying what $complicated_thing is, from some perspective that relates to x y z
07:28:05 <rgr> Its the same with teaching nOObs something you are very familiar with. By adapting your thought process to theirs to help them along you can frequently re-evaluate something and totally rethink it.
08:19:55 --- mode: glguy set +v jean-lopes
08:21:49 <jean-lopes> Hello! quick question... I am building a command line tool, and want it to have the "--version" command, is there anyway to automagically get the current version of the project? (I am using stack)
08:23:05 <hpc> off the top of my head this seems like something template haskell would be perfect for
08:23:38 <jean-lopes> reading the package.yaml for example?
08:24:06 <hpc> i was thinking cabal might set an environment variable, just gotta confirm
08:25:59 <hpc> i would recommend reading from the cabal file instead of stack's files
08:26:14 <hpc> the cabal file is the package definition, stack generally just defines the build environment
08:26:32 <jean-lopes> i see
08:26:56 <jean-lopes> thank you kind sir =)
08:29:15 <hpc> i need to get my host os instance of stack to work
08:29:20 <cocreature> there is a CURRENT_PACKAGE_VERSION macro that you can access with CPP
08:29:22 <hpc> it takes a while when i have to reinstall it in a vm every time
08:29:46 <hpc> i think it's not new enough to handle something about the latest lts version
08:30:11 <cocreature> alternatively there should also be a way to get the version number in a custom setup script but CPP is easier
08:30:40 <cocreature> you might also be interested in https://hackage.haskell.org/package/githash which lets you easily embed the git hash in your binary so that you can show it in --version
08:30:51 <int-e> what about Cabal's Paths_foo module? It exports 'version'...
08:31:08 <cocreature> oh nice, I didn’t know it had the version in there
08:33:05 <zzz> where should I look for a huge list of primes?
08:33:25 <hpc> oeis
08:34:11 <hpc> zzz: do you want to compute the primes yourself, or have a giant pre-computed list?
08:34:16 <infinisil> Haskell has a library that contains a list with all primes
08:34:40 <liste> is there a difference list in base? I couldn't find one
08:34:40 <zzz> pre
08:35:44 <zzz> infinisil: can you point me to it? i've been looking
08:35:58 <infinisil> Just search hackage
08:36:05 <infinisil> https://hackage.haskell.org/packages/search?terms=primes
08:36:57 <zzz> none of the results gives me a list
08:37:04 <hpc> jean-lopes: here's an idea
08:37:05 <hpc> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#options-affecting-the-c-pre-processor
08:37:33 <zzz> pre computed that is
08:37:34 <hpc> jean-lopes: have the executable depend on the library, and maybe that will be defined for CPP?
08:37:35 <liste> zzz: https://hackage.haskell.org/package/primes-0.2.1.0/docs/Data-Numbers-Primes.html#v:primes
08:37:53 <jean-lopes> hummm
08:38:31 <hpc> you usually want executables to be structured that way anyway
08:40:25 <hpc> something like this should work, for your cabal file: http://hackage.haskell.org/package/mueval-0.9.3/mueval.cabal
08:40:41 <hpc> if stack is managing it with package.yaml, i have no idea what you have to write instead
08:41:19 <govno> (# State# RealWorld, a #) it is not a comment?
08:41:47 <cocreature> govno: it’s an unboxed tuple
08:42:10 <jean-lopes> I believe the package.yaml is used to modify the .cabal file
08:42:16 <geekosaur> # isn't a comment in haskell anyway.
08:42:21 <cocreature> jean-lopes: the cabal file is generated from the package.yaml file
08:42:22 <hpc> -- start a single line comment
08:42:26 <hpc> {- is a block comment -}
08:42:48 <jean-lopes> cocreature: how can I call the macro you said earlier? never done that
08:43:04 <geekosaur> convention is stuff ending in # is a primitive or an unboxed value
08:50:23 <jean-lopes> Ok, its really simple xD
08:50:39 <jean-lopes> putStrLn $ CURRENT_PACKAGE_VERSION
08:50:57 <jean-lopes> (ignore the $)
08:51:13 <cocreature> jean-lopes: and enable CPP
08:54:00 <hpc> here's an example of the Paths_foo thing int-e mentioned
08:54:02 <hpc> http://hackage.haskell.org/package/alex-3.2.4/src/
08:54:09 <hpc> specifically http://hackage.haskell.org/package/alex-3.2.4/src/src/Main.hs
08:54:20 <hpc> that looks a lot simpler, i think i would prefer that method
09:01:41 <the_2nd> I want to support user supplied regular expressions. There seem to be quite a few regex packages, any you'd recommend?
09:04:53 <monochrom> I recommend regex-tdfa
09:04:57 <infinisil> Yeah ^^
09:05:01 <infinisil> See https://wiki.haskell.org/Regular_expressions#regex-tdfa
09:09:54 <the_2nd> hm I don't see any usage examples there
09:12:33 <the_2nd> http://hackage.haskell.org/package/regex-compat-0.95.1/docs/Text-Regex.html
09:12:53 <the_2nd> here I see directly what to do to match via regex, no idea how to in -tdfa   hm
09:13:06 <monochrom> Do the same thing.
09:13:21 <monochrom> Err
09:13:48 <infinisil> You basically just import the tdfa library, but use the interface for regex base
09:14:00 <monochrom> Go to Text.Regex.TDFA.{String, ByteString, etc} and those functions follow the same convention.
09:15:32 <monochrom> Or yeah, use the class methods in regex-base because regex-tdfa is an instance.
09:16:11 <monochrom> Unfortunately the class methods are too abstract.
09:16:43 <infinisil> Let's be honest, the regex docs are pretty bad
09:16:54 <infinisil> I mean, they have lots of info, but none that could get you started
09:17:02 <monochrom> Yes.
09:17:15 <the_2nd> result of regexec
09:17:16 <the_2nd> -> Either String (Maybe (String, String, String, [String]))
09:17:38 <the_2nd> I guess I'll stick with execute then
09:17:40 <the_2nd> :D
09:18:10 <monochrom> Yeah I would start with Text.Regex.TDFA.{String, etc}.  Down to earth.
09:18:26 <the_2nd> it's right there
09:18:53 <infinisil> the_2nd: Simple example:
09:19:12 <monochrom> In (String, String, String, [String]), it is: (prefix, matched part, suffix, list of those things caught by ()'s)
09:19:18 <infinisil> import Text.Regex.TDFA
09:19:19 <infinisil> "Hello" =~ ".*" :: [[String]]
09:19:26 <infinisil> returns [["Hello"],[""]]
09:20:15 <infinisil> The type determines what result you get
09:20:26 <monochrom> Example: input "a12b", regex (1)(2) --> ("a", "12", "b", ["1", "2"])
09:21:05 <infinisil> All types you can use for this are here: https://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-Context.html
09:21:13 <infinisil> Right under "XXX THIS HADDOCK DOCUMENTATION IS OUT OF DATE XXX" ...
09:22:10 <infinisil> Oh I guess they're here too: https://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-RegexLike.html
09:22:16 <infinisil> Under RegexContext
09:22:25 <infinisil> Although without descriptions
09:31:24 <the_2nd> ~= returns all matches?
09:31:37 <the_2nd> "does match" would be good enough for me
09:31:54 <the_2nd> tried via "match" but no luck yet
09:34:10 <geekosaur> I think if you use it at Bool you get just success/fail
09:34:30 <geekosaur> yes
09:35:18 <the_2nd> just force the type to Bool instead of [[String]] or what do you mean?
09:35:44 <geekosaur> I guess that whiole earlieriscussion meant nothing
09:36:22 <geekosaur> haskell ahs return tyep polymorphism. if you use the result of =~ as a Bool, it will use the Bool version of =~
09:36:40 <the_2nd> wasn't aware there were this many options
09:36:51 <the_2nd> just wheter [[Text]] or [[String]] etc
09:37:21 <geekosaur> someone pointed at docs earlier
09:38:02 <the_2nd> now it clicked, thanks
09:47:39 <the_2nd> sorry for taking so long ;) And good bye everyone
10:26:08 <flogfr> hey there o/ I have a question about ghci, is it possible to load multiple component or not? I have an executable and a library that I would like to load at the same time. What is the syntax?
10:34:09 <flogfr> to be more precise, I'd like to know if something like: `cabal repl mylib:myexe` is possible?
10:38:50 <infinisil> flogfr: Nope
10:40:17 <infinisil> flogfr: "cabal: Cannot open a repl for multiple components at once. The targets 'a' and 'b' refer to different components.. The reason for this limitation is that current versions of ghci do not supportloading multiple components as source. Load just one component and when you make changes to a dependent component then quit and reload."
10:40:52 <infinisil> This is when doing `nix new-repl a b`
10:42:23 <flogfr> infinisil: ok thanks for the answer. The first paragraph of the GHCI got me into the wrong direction: "stack ghci allows you to load components and files of your project into ghci."
10:43:36 <flogfr> infinisil: so I have a simple web server for the executable, which depends on a library that has all the logic. I would like the library to reload automatically on every change. I don't care much about change in the executable / main.hs as it shouldn't change much.
10:44:35 <infinisil> Yeah I don't know if that's possible via some other way
10:44:38 <flogfr> right now, I can `cabal repl --repl-options="-iapp" mylib` and have the right search paths, but my main.hs isn't load. Only the lib files.
10:45:02 <flogfr> I'm almost there ^^ what's the missing part to load mylib + app/main.hs from the cabal repl?
11:44:53 <adius> Hi, when I add `BL.appendFile logFile content` to my `main` function, the code seems to freeze.
11:45:08 <adius> Also I have set `hSetBuffering stdout LineBuffering`
11:45:17 <adius> Why is this happening?
11:46:02 <cocreature> adius: how have you created "content"
11:46:43 <adius> `contents <- BL.getContents`
11:47:21 <adius> Oh yeah, this seems problematic as it's lazy
11:50:53 <cocreature> adius: the stream that you get from getContents will only end once stdin is closed
11:51:10 <cocreature> pressing ctrl+d in your terminal usually does that
11:51:19 <cocreature> until that happens appendFile will hang
11:51:32 <cocreature> or wait for more input to be precise
11:51:38 <adius> Ah ok, yes that works
11:52:39 <adius> And how can I write it to work like a stream?
11:54:51 <monochrom> It already works like a stream.  You don't see output because there are multiple levels of buffering on the output side.
11:55:16 <adius> So I need to change the buffer mode for the appendFile?
11:55:42 <monochrom> Yes.
11:57:34 <monochrom> Lazy bytestring also has its own buffering.  It is a lazy list of 64KB chunks.  If you haven't accumulated 64KB of stuff, it probably doesn't even start working.
11:59:13 <monochrom> The whole system is so full of these leaky abstractions that most counterintuitive, undesirable, unexpected, surprising behaviours are actually correct.  "This is not a bug, this is a feature."
12:01:21 <geekosaur> and you can't actually change its buffering mdoe anyway because you told it not to expose the file, just "do it somehow"
12:03:04 <geekosaur> (live by implicit magic, die by implicit magic)
12:10:46 <dmj`> Can we download Haskell exchange videos ?
12:11:45 <dmj`> We need a Haskell Netflix
12:14:14 <lavalike> yes
12:14:34 <lavalike> you have to create a free account on some site in order to do it, but then you have access to them
12:19:10 <Ariakenom_> D:
12:20:46 <adius> I don't get it. Even if disable it with `NoBuffering` it only flushes the data when I Ctrl + D
12:21:08 <adius> Is there maybe a good readup to understand this? 😕
12:21:35 <hpc> i wonder if you're running it in ghci, and it has its own buffering
12:22:32 <adius> No, not in ghci
12:24:06 <adius> https://www.irccloud.com/pastebin/BajOOkCo/
12:34:38 <kuribas> is there a xml serialization library like aeson for JSON?
12:34:46 <kuribas> which allows you to use typeclasses?
12:35:16 <lavalike> good question, one would suspect yes
12:36:37 <cocreature> kuribas: xmlbf is the closest thing I know of
12:37:07 <geekosaur> as you were told earlier, a lazy bytestring is a lazy list of strict 64KB chunks. so you'd need that much data to see output.
12:37:31 <geekosaur> er. was scrolled back. adius ^^
12:38:28 <kuribas> I found this: http://hackage.haskell.org/package/xmlbf-0.4.1/docs/Xmlbf.html
12:40:43 <adius> geekosaur: But the first `hPutStr logHandle contents` works, so this can't be true?!
12:41:11 <geekosaur> then you have a deeper problem and it's still lazy IO. the first en consums all of it
12:41:27 <geekosaur> I had been hping you hadn;'t actually ttied to do both
12:41:43 <geekosaur> contents is an empty string after the first one
12:42:25 <adius> But when I Ctrl + D it correctly prints the rest
12:42:42 <adius> So it all works correctly, but only if I Ctrd + D
12:44:27 <geekosaur> I think you're stil sking fr too much magic
12:47:26 <geekosaur> in particular youreally want the terminal to act like a disk file. it's nto one
12:48:33 <adius> Mh, http://dev.stephendiehl.com/hask warns about lazy IO. Their solution is pipes ...
12:48:48 <monochrom> The "first hPutStr" happens immediately because has nothing to do with BL.getContents or contents.
12:49:30 <monochrom> Subsequently all output calls are data-dependent on the lazy bytestring and this is where waiting-for-64KB comes in.
12:49:55 <hpc> sometimes i feel like lazy IO should get the unsafe label
12:50:33 <monochrom> We also need a richer spectrum than "lazy, not lazy".
12:50:45 <geekosaur> lazy I/O can get you, terminal I/O can get you, there is no "magically make it work"
12:51:05 <cocreature> IO considered harmful
12:51:10 <monochrom> Like, [Char] is lazy down to per character, but "lazy" bytestring is eager within a chunk.
12:51:45 <hpc> to be fair, that's documented in the data type
12:52:17 <monochrom> But I wouldn't say lazy I/O is unsafe.  Let's reserve "unsafe" for partial functions and type system circumventions.
12:52:23 <jd823592> hi, I added an extra-lib and -include into ~/.stack/config.yaml and when I run stack test, everything gets built but I still get an error that the library cannot be found, manually running LD_LIBRARY_PATH=... .stack-work/.../test/binary works, (if it helps I am on nixos and I am a newbee), what can I do about this?
12:52:36 <hpc> monochrom: it has the same unsafety as unsafeInterleaveIO
12:52:48 <hpc> it ties execution to evaluation
12:53:05 <cocreature> it doesn’t just have the same unsafety as unsafeInterleaveIO, it relies on unsafeInterleaveIO :)
12:53:10 <monochrom> I think the right wording for lazy I/O is "leaky abstraction" because correct use of it requires you to know lazy evaluation and mix it with I/O.
12:53:30 <hpc> that's one of the conditions for unsafe
12:53:37 <monochrom> Well that's why I disagree with the name "unsafeInterleaveIO" too.
12:53:45 <hpc> leaking an abstraction provided by the language
12:54:19 <monochrom> I'll just close with my quote:
12:54:23 <hpc> the abstraction of data types is that they are only the values in the data type
12:54:28 <monochrom> @quote monochrom safeFromJust
12:54:28 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
12:54:47 <hpc> a string coming from lazy IO isn't just the string, it's also the circumstances of the IO behind it
12:55:16 <geekosaur> jd823592, nix messes with paths, you need to add it at the nix level and nto just stack, or get nix out of the loop somehow (which will be hard on nixos)
12:55:16 <hpc> that's classic unsafety
12:55:24 <cocreature> you could see that string as “partial” (it can now throw IO exceptions during evaluation) so even according to monochrom’s definition it falls under unsafe
12:55:47 <monochrom> No, getContents doesn't throw, it just ends the string.
12:55:59 <hpc> so it catches exceptions instead
12:56:05 <hpc> :t catch
12:56:06 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
12:56:13 <geekosaur> apparently that changed at some point, it's no longer documetned as ignoring exceptions tu throwing tem
12:56:17 <geekosaur> but throwing them
12:56:25 <geekosaur> at least, last I checked
12:56:26 <monochrom> Oh well.
12:57:31 <jd823592> geekosaur: thanks for advice, any idea how the stack nix integration works? so that I know where to go digging
12:57:41 <monochrom> On the bright side, you find that I tell people not to use lazy I/O in my I/O tutorial.
12:58:13 <geekosaur> this is a nix level problem, it wraps all the compiler and linker invocations with scripts that remove or modify non-nix-controlled paths
12:58:27 <geekosaur> stack can neither tell nor change it
12:59:01 <monochrom> Moar leaky abstractions known as nix, stack, and cabal.
12:59:23 <monochrom> unsafeStack would be a name I would agree with!
12:59:28 <geekosaur> and if you figure out how to make stack use the unwrapped liker, it won't have access to nix-installed libraries
12:59:35 <geekosaur> *linker
13:00:42 <geekosaur> hm, docs have gone back to claiming exceptions are discarded
13:00:46 <monochrom> Also, "nix level problems are next level problems" :)
13:02:49 <monochrom> P.S. Streaming is an anti-thesis to performance.
13:03:19 <hpc> how so?
13:04:00 <monochrom> For performance you start doing buffering, you refuse to "wake up and work per input character".
13:04:12 <monochrom> So now the user sees stalling, not streaming.
13:04:21 <hpc> ah
13:04:28 <monochrom> which is what adius's program is running into.
13:04:36 <nshepperd> throughput isn't the only kind of performance
13:05:27 <monochrom> Performance is an anti-thesis to performance.  Is that better now? :)
13:06:12 <cocreature> geekosaur: it looks like the bytestring version rethrows while the String version discards
13:06:18 <hpc> this is why so many programs get slower with new versions
13:06:23 <hpc> they optimize for performance instead of performance
13:12:34 <nshepperd> a latency viewpoint on performance would say: appendFile has potentially unlimited latency for an input character to be written to the output, since it waits forever for the next 64KB. so it's not good for that kind of performance
13:14:14 <nshepperd> the answer is to wait only a bounded time for the buffer to fill up, before writing whatever you've got. but you're too late to do that when you're input is already a lazy bytestring
13:15:51 <monochrom> I'm sure a homebrew variant of BL.getContents implemented in terms of unsafeInterleaveIO and async could restore the "it's just a pure lazy bytestring" illusion. >:)
13:15:52 <nshepperd> so really you could blame the lazy getContents instead
13:16:49 <monochrom> unsafeInterleaveIO (race (read something) (threadDelay 1000000)) etc
13:19:51 <monochrom> Let's make lazy I/O great again. >:)
13:20:08 <nshepperd> you would use select or something to wait until either there are 64KB or t milliseconds passed
13:20:13 <hpc> let's make all IO a lazy list of actions
13:20:29 <lavalike> this is gold: <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a 
13:20:37 <nshepperd> whatever is the normal IO-based solution for reading from a fd with bounded delay
13:20:46 <monochrom> That's what "race" does after unwrapping many layers of abstraction.
13:21:23 <monochrom> "race" creates two asyncs and two corresponding threads and use STM to find out which one finishes first (and kills the other).
13:21:34 <cocreature> hpc: everything was better when we had [Request] -> [Response]
13:21:59 <monochrom> Now one thread is attempting a read, another thread is threadDelaying.
13:22:27 <monochrom> Now the RTS turns these two threads' actions into a select/poll.
13:23:10 <monochrom> Or rather, the RTS is a select/poll loop that juggles those two threads (and others).
13:23:10 <nshepperd> wouldn't race be buggy? since the threadDelay could finish after the read advances the input buffer but before it returns
13:23:59 <monochrom> Yes but maybe we could code the reading thread to not suffer data loss when "killed".
13:24:44 <cocreature> race (threadWaitRead …) (threadDelay …) 
13:25:15 <nshepperd> yeah, that
13:25:15 <cocreature> (ofc you still need to do the actual read if the threadWaitRead won
13:25:26 <monochrom> Neat.
13:27:29 <hpc> we should make some kind of streaming library that does all of this
13:27:36 <hpc> :P
13:28:22 <cocreature> hpc: and then hide the complexity of that streaming lib using unsafeInterleaveIO
13:28:28 <adius> I was able to make it work: Simply remove `hPutStr logHandle contents` and write `forM_ (BL.lines contents) $ \request -> do hPutStrLn logHandle request`
13:28:30 <nshepperd> anyway, this is the correct way of reading things with bounded delay
13:28:52 <adius> I guess that's what I intended anyways 🙈
13:29:18 <nshepperd> this isn't just a lazy IO thing either
13:30:51 <nshepperd> if you're calculating counterexamples to the abc conjecture and putting them in a lazy bytestring (and the conjecture, which says there are only a finite number, is true), your program will hang before printing them all
13:31:07 <nshepperd> if you blindly buffer it at 64KB
13:32:11 <hpc> it should be buffered at 8k instead
13:34:25 <sm> heh, way to succeed despite #haskell's advice adius :)
13:35:23 <monochrom> Now, any plan to get [x | x <- some_infinite_list, x > 0 ] to stop by a timeout so all those Project Euler people are not caught in surprise? >:)
13:36:56 <adius> sm: Hehe 😁, it just felt like it should work on this scale despite the listed problems of lazy IO
13:38:17 * monochrom rubs his hands.
13:38:34 <lavalike> lazy IO got to be balanced by very laborious programmer
13:38:59 <infinisil> monochrom: Well you could just do something like fun (x:xs) timeout = do { t <- getCurrentTime; if t > timeout then return [] else (x:) <$> fun xs; }
13:39:49 <infinisil> (Probably want to take more than 1 element per check though)
13:58:48 <monochrom> http://codepad.org/qhur1mGm  (Too bad they don't have async to run it.)
14:00:26 <nshepperd> lol
14:01:05 <nshepperd> well, producing a totally different output based on a timeout is a different thing
14:11:13 <zzz> what's the recommended way to update ghc to the latest version?
14:11:47 <monochrom> Just go to GHC website and download it and install.  I do that.
14:12:38 <monochrom> You can even use "./configure --prefix=/xxx" before "make install" to choose where to put it.
14:13:54 <monochrom> But I should be forthcoming to you.  There is no "the".
14:14:32 <monochrom> There are like 5 rivaling ways and all of them are recommended by sufficiently many people, possibly even more or less the same number of people.
14:15:44 <monochrom> As time goes by you will discover that this is a general phenomenon in the Haskell community.  There is no "the".  All conceivable ways have their fans.
14:15:56 <c_wraith> also, there really is no such thing as "updating" ghc.
14:16:07 <c_wraith> there's just "starting to use a different version."
14:16:25 <monochrom> Yeah, whatever libraries you built with an old GHC are unusable by the new one.  You always rebuild.
14:16:50 <monochrom> Because too-heavy inlining of asm code.
14:17:30 <monochrom> Or rather, too-heavy inlining of code so that different GHC versions are asm-level incompatible.
14:20:00 --- mode: glguy set +v pae6Eedi
14:20:21 <pae6Eedi> Why are lists left-to-right (i.e. x:xs and not xs:x)? Is it just because english is a left-to-right language?
14:20:33 <monochrom> Yes.
14:22:37 <benzrf> pae6Eedi: there wouldn't be any real difference if the arguments of (:) were swapped - it's just a choice
14:22:57 <pae6Eedi> If I implement my own right-to-left list, what are the problems I'll run into? I guess I'll have to reverse everything when I want to print it, is that it?
14:23:28 <monochrom> I don't think you need to reverse anything for printing.
14:23:30 <zachk> you could write your own custom list printing function as well 
14:23:46 <monochrom> In fact print upside down.
14:24:05 <zachk> if you had a reverse list constructor, when printing it it would print it in reverse of how you defined it though
14:25:39 <pae6Eedi> Wait, that's right. Yeah, of course! But it would just seem backwards compared to how I construct it.
14:26:02 <monochrom> Provide both printing so the user can choose. :)
14:26:57 <pae6Eedi> I bet it'll get confusing rather quickly... :) But wait, what I'm thinking is, other languages have lists where you add elements in the end
14:27:08 <pae6Eedi> E.g. clojure has vector that grow at the end
14:27:18 <pae6Eedi> And lists that grow in the beginning
14:27:33 <pae6Eedi> ("end" being right and "beginning" being left)
14:27:55 <monochrom> If you have mutable cells you can add anywhere left right and centre.
14:28:32 <pae6Eedi> No, they're immutable, but the vectors are implemented with trees I believe, and the lists are just plain lists (possibly infinite)
14:29:08 <monochrom> That would correspond to our Data.Sequence.
14:29:54 <monochrom> logarithmic time for adding to either end and asking for the ith item.
14:30:15 <nshepperd> print your right-to-left list in a spiral
14:30:55 <pae6Eedi> monochrom: I may be mistaken, but I think they only support adding to the one end, and constant time for the ith item
14:31:13 <pae6Eedi> Though that's probably "amortized constant", i.e. logarithmic, yes
14:31:51 <monochrom> Array supports amortized constant time adding to one end.
14:32:10 <monochrom> Make it mutable array.
14:32:34 <monochrom> Data.Sequence is immutable but it uses a tree.
14:36:00 <pae6Eedi> Hmm, now I'm wondering why couldn't they make adding to the beginning fast then
14:37:31 <monochrom> Hey that's a cool homework problem I can give to the students next time I teach the data structure course.
14:39:45 <nshepperd> you could make inserting at both the beginning and end of a mutable array O(1) amortized
14:40:16 <nshepperd> just put the values in the middle of your allocation instead of at the start
14:40:59 <monochrom> Unfortunately no language standard library provides it.
14:42:37 <pae6Eedi> monochrom: glad you're making something out of this too, haha
14:42:57 <pae6Eedi> nshepperd: no no, I'm asking only about immutable persistent arrays/vectors/sequnces
14:43:19 <monochrom> Immutable arrays are hopeless.
14:43:37 <zzz>  while we're on the subject, why are lists defined as `data [] a = [] | a : [a]` instead of `data [a] = [] | a : [a]` ? whouldn't it make sense for the type constructor's syntax to be consistent?
14:44:34 <monochrom> Yes but unfortunately people love "[Int]" too much.
14:44:53 <monochrom> People will look at you strangely if you speak like "[] Int" all the time.
14:44:54 <geekosaur> consistent for you, not so consistent for the parser that has to figure out what you meant
14:45:06 <geekosaur> I think thy asked the opposite question
14:45:13 <monochrom> Oh yeah, oops.
14:45:39 <monochrom> But the whole thing is m00t. The parser does not have to see "data [] a = ..." either.
14:45:46 <zzz> well I didn't mention `data [] a = [] | a : ([] a)` for a reason
14:46:06 <monochrom> err moot
14:46:28 <pae6Eedi> hmm, indeed, why is that? I don't see what problem would arise from data [a] = ...
14:46:45 <monochrom> Harder to write a parser to support it.
14:47:23 <pae6Eedi> Well, but I mean, it's still unambiguous, is it not?
14:47:52 <geekosaur> [] kinda has too many meanings, and a parser that tries to be as smart as a human ends up doing indefinite lookahead
14:48:22 <geekosaur> whch we'er fairly good at but causes computers to do unfortunate things
14:48:54 --- mode: glguy set +v pae6Eedi
14:49:18 <geekosaur> (actually we're not good at it either, see jokes about German professors tat spit out all the verbs at the end of the lecture)
14:49:38 <zzz> geekosaur: exactly because it has two meanings, i think it would be simpler for the parser to know that [a] is == List a instead of having to deal with `[] a`, which you very righteously pointed out is ambiguous
14:49:55 <geekosaur> well, that one is because it matches the way other types work
14:50:01 <benzrf> :k [] Int
14:50:02 <lambdabot> *
14:50:03 <geekosaur> how do you circumfix Maybe?
14:50:40 <geekosaur> and you can't define your own circumfix constructors anyway, so [x] has to be a magical form
14:50:40 <pae6Eedi> but in other contexts it doesn't match... so it'd be "matchier" to not match in this context too?
14:51:26 <zzz> yea that's my point
14:52:42 <zzz> i think
14:55:28 <pae6Eedi> Well, I guess in the end it's just one of those little quirks ¯\_(ツ)_/¯
14:55:54 <pae6Eedi> it's not like you're writing those 'data [] a = ...' everyday (or ever) anyway
14:57:36 <geekosaur> my point is thatany time you seea [] with soemthing inside of it, there is a special rule in the compiler to handle it
14:58:38 <geekosaur> I'm not sure that special rule exists for data declarations, since the only use it would have is that one and it's only allowed so the info table for lists is generated
15:00:42 <pae6Eedi> actually that makes sense - since it'd used literally only once (to define the list in the prelude), there's no much need to handle it in the parser. And the parser can't simply rewrite any and all occurences of [a] to [] a, since [a] can be a singletone list too
15:09:51 <dmwit> This whole conversation appears to be predicated on the "fact" that "lists are defined as `data [] a = [] | a : [a]`". But this fact is not correct.
15:10:46 <pae6Eedi> hmm?  Prelude> :info []
15:10:46 <pae6Eedi> data [] a = [] | a : [a] 	-- Defined in ‘GHC.Types’
15:10:46 <pae6Eedi>  
15:11:00 <zzz> http://hackage.haskell.org/package/ghc-prim-0.5.3/docs/src/GHC.Types.html#local-6989586621679009803
15:11:11 <dmwit> Both are lies.
15:11:17 <dmwit> [] is baked into the compiler.
15:11:38 <zzz> why so many lies?
15:11:49 <dmwit> Those "definitions" exist to make the documentation more complete, not because they're actually functional.
15:12:19 <geekosaur> because you can't parse this stuff sensibly, nor canyou defien tem; lists and tuples end up being baked in instead of "defined" as such]
15:12:49 <geekosaur> they're also surprisingly difficult to describe in a parser
15:13:46 <dmwit> It isn't even a question of how hard it is to parse. If you write `data [] a = Foo` into ghci, you will see what I mean: the parser must already handle it.
15:14:27 <dmwit> (It has a special error message just for this construct!)
15:14:33 <harpocrates> They do parse though...
15:14:46 <harpocrates> The whole point of GHC.Prim is to give Haddock something that it can use to generate docs.
15:15:00 <geekosaur> btu there si sucha  definition, it's used to generate an info table or the runtime (so there don't have to be 3 different info table enerators: lists, tuples, and everything else)
15:15:11 <harpocrates> The typechecker/renamer is the one that has some magic to accept those defs..
15:15:15 <geekosaur> *for the runtime
15:15:52 <geekosaur> it is however sepcial cases so thatr's all it does, since the actual list and tuple types must be baked in to work
15:16:01 <geekosaur> *special cased so
15:22:26 <monochrom> I agree with geekosaur.  The Haskell Report specifies that the list syntax is built-in.  GHC has to comply.  But then GHC also has its own needs for an explicit definition, so it puts one there and then hide it away.
15:23:48 --- mode: glguy set +v vahhie6A
15:24:30 <monochrom> Rather than referring to the piece of code "data [] a = ..." in GHC.Types, please take a look at the comments concerning it.  "NB: lists are built-in syntax, and hence not explicitly exported" and also in the export list "Data types that are built-in syntax
15:24:30 <monochrom>  / They are defined here, but not explicitly exported"
15:25:03 <monochrom> This is yet another data point that if you take something out of context, you can "prove" anything.
15:29:00 --- mode: glguy set +v dei6touM
15:29:50 <dei6touM> Guys, so I've read about clojure's persistent vectors, and their implementation uses (unlike Data.Sequence) tries with paths being the indexes of the elements. So they indeed CANNOT be grown on both sides, they grow effectively only on one side (on the end, i.e. the side where the indexes are larger)
15:30:28 <dei6touM> But then we have (possibly infinite) lists, which - it seems to me at least - can only grow on one side too, that side being the beginning of the list
15:32:01 <dei6touM> So the question remains, how can we have both infinite lists AND effective ith element lookup AND the same order of adding elements? Of course we can use a different implementation, but as I understand tries were chosen over the finger trees because they're more effective?
15:34:00 <dmwit> You live in a strange world, where people know how to perform magic but choose not to.
15:34:39 <monochrom> Hey! I know how to code in C but choose not to. :)
15:34:53 <dei6touM> I feel silly already (it is kinda silly, isn't it?), and your comment does not help at all, dmwit!
15:34:55 <dmwit> And you consider coding in C to be magic? =)
15:35:12 <monochrom> I can perform magic in C too.
15:35:27 <monochrom> Like 5["abcdefg"]
15:36:45 <dmwit> dei6touM: You're question appears to be positing a world in which people know how to 1. keep the same asymptotics 2. keep the same *implementation* 3. provide a richer interface 4. choose not to write the code to do this and 5. sit in #haskell waiting for somebody to ask about it instead.
15:37:59 <dmwit> Actually #5 doesn't seem unreasonable to me. I sit in here all the time unwinding even though there is code I know how to write and am not writing.
15:38:17 <dmwit> But hoping for 1-4 to all be true at the same time seems a bit unreasonable.
15:40:36 <dei6touM> dmwit: I'm really sorry, but I don't understand. I'm just asking if it's possible somehow to have an effective `cons` function that have the same semantics and works on both lazy lists and vector tries (or a similarly effective random-access immutable datastructure)
15:41:02 <dei6touM> Well, I do understand that you're saying "no" in a very roundabout way, but it's still to roundabout for me. :)
15:42:24 <zachk> dei6touM, and you want the cons to run in O(1) on all those datastructures?
15:42:59 <dei6touM> zachk: const or log, yes
15:43:04 <monochrom> How do you take a trie that stands for an array, and grow on the index-0 side?  What does it even mean?  So, it probably means you have to increment every existing item's index by 1.
15:44:17 <dei6touM> monochrom: as I've said earlier, I don't see how that's possible.
15:44:26 <monochrom> So now you have two options.  You could bite the bullet and do exactly that (spending linear time).  Or you remember "I have to shift everyone's index" somewhere and adjust for it.
15:45:01 <zachk> dei6touM, I think you could just use a Data.IntMap with a counter you keep track of , inserts on that are O(log n) I believe
15:45:33 <zachk> lookups are log n as well I believe
15:46:04 <dei6touM> *I don't see how that's possible in an effective manner, that is.
15:46:07 <monochrom> Plus you now have to allow negative indexes.
15:46:47 <dei6touM> zachk: but then we can just take Data.Sequence, no?
15:48:44 <zachk> not really familiar with Data.Sequence, looked at it, and it could be faster for what you want
15:50:26 <pgiarrusso> dei6touM: ignoring the "infinite list" part, at least the latest version of Clojure persistent vectors supports insertions IIUC, seeing https://infoscience.epfl.ch/record/213452/files/rrbvector.pdf
15:51:32 <pgiarrusso> not claiming that it's trivial to implement
15:57:08 <dei6touM> pgiarrusso: thanks for the link, looks like it indeed does the job
15:57:49 <dmwit> I am not saying "no". I am saying the fact that we use libraries today that do not offer the features you want is evidence that nobody knows "yes".
15:58:38 <dmwit> (It is also possible, I suppose, that nobody wants "yes".)
15:59:28 <pgiarrusso> dmwit: or nobody wants yet *enough* for all the costs (see: all research not adopted)
15:59:48 <pgiarrusso> (all research that would work in practice, that is)
16:00:37 * dmwit nods agreeably
16:02:21 <dei6touM> But, approaching in from the other end... Maybe it's better simply to ditch plain lists and use trees instead of them? We can concat them in const and we can concat an infinite list (i.e. a totally unbalanced tree with the generator in one branch) to get the infinity... would that work?
16:02:47 <dmwit> FWIW, I also vote to close SO questions about "is there a library for X" even if I know the answer is yes. Because the reasons described on the site for that vote-to-close reason are correct. But then I am that kind of grumpy, I suppose.
16:03:24 <zzz> data Solution a = No | Research a | Library (Research a)
16:03:59 <zzz> data Research a = WorksInPractice a | DoesNotWorkInPractice
16:04:10 <zzz> sorry i'm bored
16:05:37 <dmwit> (And no, I do not say we should import SO's rules here. Many of them -- including rejecting "is there a library for X" -- are specific to the SO model of having an answer that lives for eternity, a property that isn't really necessary on IRC.)
16:13:18 <dei6touM> Seriously though, now thinking about it, I fail to see a single downside of using a tree instead of a list. Why do we use plain lists at all?
16:13:31 <dei6touM> #Exposed #IWantToBelieve
16:13:59 <monochrom> Some list operations are constant time.
16:14:15 <monochrom> Lazy list is a excellent control-flow construct.
16:15:04 <dmwit> Infinite lists are occasionally very convenient, often (but not always) as a control-flow construct as monochrom said. Tree implementations which offer good asymptotics for the operations that lists don't do well generally don't support infinite-ness.
16:15:43 <monochrom> People are unimaginative and they only understand linear lists not branching trees.
16:15:53 <dei6touM> monochrom: growing a tree is constant time too, but now we have that on both sides. Lazy list is just a tree with all the elements on one (say, the right-most) branch, is it not?
16:16:02 <monochrom> For example compare the old Usenet newgroup days vs the web forum days.
16:16:40 <monochrom> i.e., newgroup "threads" are trees, web forums only give you lists.
16:17:32 <monochrom> Either the author of phpbb failed CS 101 or they anticipated end-users to be too dumb for trees.
16:17:52 <dei6touM> Wait, are you saying that every functional language up to nowadays ships a 50-years old list implementation in the stdlib because Usenet no more?
16:18:16 <dmwit> No. He is saying there is a central reason that causes both.
16:18:23 <dmwit> But I don't agree. =)
16:19:26 <dmwit> I realize now my explanation was not clear. So: he is not saying X causes Y, he is saying A causes X and A causes Y.
16:21:54 <geekosaur> or one can cut to the chase: "people don't like change"
16:22:54 <dei6touM> dmwit: yeah, I understand that. But it's just so weird. In fact, too weird to be easily believable. Basically, haskell have an inferior datastructure in the Prelude and clojure has 'cons' that adds to the left and 'conj' that adds to the right simply because people are so used to the good ol' list?
16:23:06 <monochrom> I don't like change either. This is why I changed to using credit cards and debit cards, and even set up Apple Pay to further streamline them. >:)
16:23:22 <dei6touM> There *has* to be something other than that, something rational\objective
16:23:57 <geekosaur> wel, the real reason haskell has it is that it's a teaching language gone mainstream. the prelude was optimized for reading by CS students, not for use. see also non-strict sum
16:25:06 <pgiarrusso> dei6touM: lists are a control-flow structure, and those used that way are mostly not used as a data structure (see: fusion)
16:25:53 <pgiarrusso> dei6touM: people have said that above, but I feel like repeating it *because* your summary says “haskell have an inferior datastructure”
16:26:23 <dei6touM> pgiarrusso: I don't quite understand that argument, could you explain please? How a tree would be different in that respect?
16:26:59 <pgiarrusso> dei6touM: also, I forgot the important point that all these trees have much bigger constant factors
16:27:29 <dei6touM> if you rebalance them - yes
16:28:03 <pgiarrusso> as necessary for those asymptotics, it’s necessary
16:28:18 <pgiarrusso> dei6touM: at least in Scala, which also has Clojure vectors in the stdlib, you often still want lists because of the costant factors — Vectors have pretty big ones
16:29:18 <pgiarrusso> dei6touM: back to fusion, I expect it’s at least more complicated for trees — and I remember that years ago I looked into it and saw significant complication
16:29:46 <monochrom> Haskell is not a new language.  At the beginning of Haskell, which was like 25 even 30 years ago, functional languages were still more an educational thing, and list was still a great educational vehicle.  Clojure is significantly newer and doesn't have a list legacy to carry.
16:30:44 <monochrom> But note how Clojure still carries the 70-year-old legacy of "code is plain text file" as opposed to getting rid of text and showing you the bloody syntax tree already.
16:32:35 <dei6touM> pgiarrusso: but I'm not talking about fancy vectors, what I have in mind are simple binary trees instead of plain single-linked lists! The addition is the same, and iteration is basically not worse than a list even without rebalancing (plus you get the parallelization benefits)
16:34:10 <pgiarrusso> dei6touM: parallelization benefits require the rebalancing. and if you use the trees as lists, the downside is the space waste
16:34:57 <pgiarrusso> also, iteration *is* going to be worse, if nothing else in code size
16:35:09 <dei6touM> monochrom: fair point about the age. I'm not sure about the "code is plain text file" though; the whole thing with lisps is that you're writing in literal datastructure instead of plain text, so what do you mean exactly? Fancy editor that disallows edits that break the structure? Emacs actually had that for a long time
16:38:36 <dei6touM> pgiarrusso: true, agreed on all counts. But... you can add elements to both ends... and a single 'conj' that works for both vectors and "lists"... for the price of a small overhead here and there... Well, it's fair though - a non-academic language wouldn't necessarily want to include new things with their own (not well-known) set of trade-offs.
16:40:55 <dei6touM> Yeah, that actually makes perfect sense. #NotExposedAtAll #IWantToBelieveNoMore
16:41:33 <pgiarrusso> dei6touM: “add elements at both ends” but without performance guarantees better than a list? and why would you want a single `conj`? Seems a weird tradeoff
16:43:24 <pgiarrusso> having a *polymorphic* `concat` operation would be more desirable, but that’s a very different question
16:43:58 <pgiarrusso> I mean, we all want lots of perfect data structures, but we usually don’t have them — that’s one of the things one learns when studying algorithms
16:47:49 <dei6touM> I think that's a good conclusion, pgiarrusso. Anyway, I'm going to get some sleep - thank you all for the conversation guys! Cheers.
16:51:57 <Solonarv_> :t asum
16:51:58 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
16:52:15 <Solonarv_> ^ "polymorphic concat"
16:52:42 <Solonarv_> or, if you prefer, fold :: (Monoid m, Foldable t) => t m -> m
17:01:31 <monochrom> Logically, no one wants a lot of perfect data structures.
17:02:07 <monochrom> If there is a perfect data structure, then you just need one. :)
17:02:47 <monochrom> (Either that, or you want/accept a lot of various trade-off data structures.)
17:05:45 <tnks> to test that some type-level phantom-type stuff doesn't compile, is there a better framework than `should-not-typecheck`?
17:05:54 <tnks> I feel like better can be done, but that's all I found.
17:12:54 <pgiarrusso> Solonarv_: right, I should have said "polymorphic insert" or lookup — those lawless operations where you either use classy-prelude or use backpack
17:13:22 --- mode: glguy set +v Boarders
17:13:56 --- mode: glguy set -v Boarders
17:24:53 <jle`> hi all, i was pretty lazy with annotating my changes, so i was wondering if there was a way to diff my external API between two versions of a package
17:25:02 <jle`> besides just manually diffing the source code
17:25:57 <c_wraith> I seem to recall someone built a tool for that.
17:26:10 <c_wraith> But I have no idea what it was called
17:26:16 <jle`> hm, looking at hackage-diff
18:14:56 <suzu> can i use new lts releases with an old ghcjs? 8.02
18:21:25 <suzu> i am trying to share code between ghc and ghcjs and having dep issues :/
18:27:33 <sm> no
18:27:48 <suzu> thought not
18:27:58 <sm> just no. ok maybe. depending on how you define "use"
18:28:35 <suzu> i have a server project that is using latest shiny lts, a client that uses ghcjs 8.02 on an older lts, and a desire to create a common package that shares code between them
18:28:59 <suzu> e.g. servant routes are shared
18:29:15 <suzu> how do i pick a version of the servant dependency for the common package?
18:29:23 <suzu> that will make both compilers happy
18:32:57 <suzu> it seems to not be a stupid idea..
18:33:03 <suzu> https://www.reddit.com/r/haskell/comments/56ucmt/how_do_you_structure_web_projects_that_share/d8mfs0e
18:38:01 <sm> sounds good!
19:05:02 <suzu> dmj`: any advice on this? :)
19:22:09 <dmj`> suzu: hi
19:22:40 <dmj`> suzu: miso has cpp for this
19:23:33 <davean> kate
19:25:07 <MarcelineVQ> we have to go back?
19:40:11 --- mode: glguy set +v jkachmar
19:41:52 <jkachmar> Has anyone seen GHC memory leaks on Alpine?
19:41:54 <jkachmar> I hadn't heard of it before finding this issue (and the issue linked in the thread) today, but can't find much/any additional info searching around online
19:41:57 <jkachmar> https://github.com/PostgREST/postgrest/issues/867
19:45:25 <c_wraith> I guess there *might* be a way alpine causes memory issues that other distros don't see, but it seems unlikely
19:48:36 <jkachmar> The only substantial difference I can think of is musl vs glibc
21:04:31 <suzu> dmj`: cpp?
21:11:11 <dmj`> suzu: since servant changes so much (servant-client changes the most), miso has CPP to account for changes to its API
21:11:53 <suzu> seems a little fragile
21:14:38 <suzu> so i should use CPP in my shared library to account for differences between client/server lts?
21:15:15 <dmj`> suzu: works well in practice. Miso has a very small dependency footprint, it doesn’t set any version bounds since most packages it relies on are boot packages, and most of the functions it uses never change signature (e.g. Data.Text.pack) 
21:16:18 <dmj`> suzu: what differences are you encountering?
21:16:49 <suzu> i had an issue with servant
21:17:05 <suzu> wherein latest servant uses Servant.Link, but older variant uses Servant.Util.Link
21:17:35 <suzu> and so i'm wondering if i should simply pin use of the older servant and use that across the server and the client
21:17:46 <suzu> and if this may introduce some kind of dependency hell later down the road
21:18:34 <dmj`> suzu: there’s CPP to account for the typesafe Link changes, unles they’ve changed it yet again recently
21:18:36 <dmj`> suzu: https://github.com/dmjio/miso/search?q=.Link&unscoped_q=.Link
21:19:02 <suzu> err what i mean is that /i/ was using servant Link in my shared code
21:20:20 <dmj`> suzu: ah, I guess I do use CPP.
21:20:24 <dmj`> suzu: https://github.com/dmjio/miso/blob/master/examples/haskell-miso.org/shared/Common.hs#L303
21:20:26 <dmj`> suzu: in shared
21:20:26 <suzu> the idea that i need to write my shared library in a manner where it can compile with either version X of some dep, or version Y of that dep
21:20:40 <suzu> feels bad
21:20:42 <suzu> lol
21:20:53 <dmj`> suzu: I agree, that’s not desirable, but it’s an artifact of us choosing servant instead of writing our own implementation 
21:21:18 <suzu> well, not just servant, but i will likely wish to use aeson in the shared code later
21:21:42 <suzu> so I may need to reach for the CPP hammer to get that work, just as you've done
21:21:59 <dmj`> suzu: I doubt it for aeson, it’s much more stable
21:22:04 <suzu> oh. okay
21:22:15 <suzu> then maybe this is nearing the end of my troubles
21:22:27 <suzu> but supposing this occurs again -- are there any other ways I can deal with it?
21:22:31 <dmj`> suzu: servant is problematic for this reason in miso, since the deck chairs keep moving around on teh ship
21:22:36 <suzu> :P
21:23:53 <dmj`> suzu: links should be your only problem, and only if you’re using Links with ghcjs-7.10.3. With 8.x a newer servant shouldn’t have these problems
21:24:14 <dmj`> suzu: so no CPP is necessary, but then you lose GHCJSi
21:24:17 <suzu> this is because you wish for miso to compile against the versions of its dependencies in the same LTS, plus also compile against the latest deps that the ghcjs releases work with, correct?
21:27:04 <dmj`> suzu: Stack has stopped supporting ghcjs afaik. GHCJS was pretty stable in 7.10.3, a few pretty severe regressions have been introduced since, and GHCJSi is no longer working (as of 8.x). Peti has dropped support for ghcjs-7.10.3 in nixpkgs. I’d recommend using my cache (https://hydra.dmj.io/nix-cache-info) and the pinned nixpkgs version in default.nix 
21:27:45 <dmj`> suzu: I also have some stack files with known to work GHCJS compilers
21:27:56 <suzu> i have a stack file working with the 7.10.3 compiler
21:28:05 <suzu> i had thought the only ghcjs versions that exist are 7.10.3 and 8.0.4
21:29:49 <dmj`> suzu: That’s probably your best bet in the immediate. GHCJS has newer versions though, including on latest nixpkgs (8.4), but there are some big bugs that need to get resolved like this https://github.com/ghcjs/ghcjs/issues/666
21:30:46 <dmj`> suzu: This might be fixed on a branch and used elsewhere. This would resolve your CPP woes, but you’d still be without a REPL for development.
21:30:46 <suzu> i have been able to avoid nix thus far
21:30:58 <suzu> ah yeah ghcjsi
21:31:27 <suzu> argh
21:31:54 <dmj`> There might be a ghcjs-8.4 stack file lying around somewhere. https://github.com/tolysz would know more.
21:31:55 <suzu> why cant shit just work nicely :(
21:32:53 <suzu> alright, ill go all in on CPP life
21:32:55 <dmj`> suzu: because we haven’t figured out an effective way to clone luite
21:33:00 <suzu> hahaha
21:34:28 <suzu> ok hybrid haskell webapp
21:34:30 <suzu> here we go
21:34:49 <suzu> gonna cargo cult ittttt
21:35:09 <dmj`> suzu: I know CPP sucks, but if you can put up with it, I plan on migrating to 8.4 (w/ fixes), on nix and stack, along with working on something similar to GHCJSi.
21:36:14 <dmj`> suzu: sweet, join the slack if you run into anything, or make an issue
21:36:40 <suzu> 8.4 with fixes?
21:36:43 <suzu> #666 has been open since june
21:36:57 <suzu> s-slack??
21:37:17 <suzu> hmmmm alright
21:38:30 <dmj`> suzu: wouldn’t be suprised if the fix for #666 will land in ghcjs-8.6
21:38:35 <dmj`> suzu: https://haskell-miso-slack.herokuapp.com/
21:38:55 <dmj`> suzu: #666 is another reason to stay on 7.10.3
21:39:06 <suzu> there's a ghcjs 8.6?
21:39:13 <suzu> or, there are plans for one?
21:39:44 <dmj`> suzu: I assume so
21:40:38 <suzu> ok!
21:42:23 <dmj`> suzu: what are you building? just curious
21:43:38 <suzu> im making a web app that'll let you send pdfs as faxes
21:44:01 <dmj`> suzu: Nice!
21:44:07 <dmj`> suzu: will it be public-facing?
21:44:11 <suzu> yep
21:44:22 <dmj`> suzu: solid, can’t wait to see it
21:44:23 <suzu> hopefully it is also my bank account-facing
21:44:36 <suzu> and i can make some money with it
21:44:39 <suzu> :P
21:52:09 <dmj`> suzu: that would be cool :) 
22:02:53 <dmj`> suzu: this seems promising https://github.com/NixOS/nixpkgs/tree/master/pkgs/development/compilers/ghcjs-ng
22:03:20 <suzu> i have no idea what im looking at here
22:03:24 <suzu> idk jack about nix/nixos
22:03:57 <suzu> i assume this is a nix package that gets ghcjs 8.2, and looks like it 'just works'?
22:04:37 <suzu> oh and 8.4
22:05:24 <cocreature> ghcjs without nix sadly tends to be even more painful than ghcjs with nix ime
22:06:05 <suzu> ghcjs with stack works
22:06:43 <cocreature> it works for some very specific versions, then you stumble upon some bug that has been fixed since and your problems start
22:07:03 <suzu> g..uess it's time for me to ditch stack
22:07:54 <cocreature> don’t get me wrong, if it works for you great! but it didn’t work particularly well for me
22:08:33 <dmj`> suzu: see how far you can get with it, switching won’t be that bad, miso doesn’t go hog wild on its nix usage
22:09:18 <suzu> why is nix such a big deal in the haskell community?
22:09:31 <suzu> afaict it's a package manager that has nothing to do with haskell
22:10:46 <dmj`> suzu: It has cached versions of all haskell packages, and encompasses dev, ci, process monitoring and cloud deployment under a single abstaction (the nix language)
22:11:07 <cocreature> Haskellers tend to get excited when something claims to be “purely functional
22:11:08 <cocreature> ”
22:11:24 <dmj`> suzu: getting into a nix-shell that has profiled versions of your haskell packages is instant if its cached, with stack you’d have to rebuild the world with profiling afaik
22:11:27 <dmj`> cocreature: haha
23:01:58 <maerwald> dmj`: cabal new-* also caches profiling 
23:39:01 <dmj`> maerwald: nice
23:39:14 <maerwald> so it's separate from non-profiling builds
23:39:35 <lavalike> is there a timeline for the transition of new-* commands to default commands?
