02:40:24 <govno> "class Monad m where" m must be type with kind * -> * ?
02:40:37 <Taneb> Yes
02:40:59 <Taneb> Due to the types of the member functions of the Monad typeclass
02:41:20 <Taneb> Not due to the line you posted
03:05:11 <gentauro> just saying -> https://imgur.com/a/12McvgP :D
03:05:25 <gentauro> I simply had to have that IO wine :D :D :D
03:05:36 <ventonegro> heh
03:14:16 <lavalike> gentauro: that's very host of them to print it out it has side effects on its label!
03:16:51 <gentauro> lavalike: that wine is awesome
03:17:05 <gentauro> the only side-effect is has, is that I get pretty drunk :D
03:20:59 <maerwald> is it a side effect?
03:21:12 <maerwald> I think it just evaluates to it
03:22:42 <gentauro> maerwald: I would say that the pure computation of wine is taste right?
03:22:49 <gentauro> and hydration
03:22:59 <gentauro> and the side-effect is drunkness
03:23:08 <maerwald> taste is side-effect to me xD
03:23:10 <gentauro> that's why I like to have it separated by IO
03:23:31 <gentauro> maerwald: so you are one of those that doesn't eat food but just consume fuel?
03:23:33 <gentauro> got it
03:23:52 <maerwald> no
03:24:30 <gentauro> like body builders, they eat for every meal 150 gr rice and grilled chicken breast
03:24:39 <gentauro> I mean, that has no taste so it has to be "fuel"
03:27:49 <cfraz89> grilled chicken breast is the best what you talking about
03:45:33 <gentauro> cfraz89: tasteless and dry af
03:46:12 <gentauro> I mean "grilled" with no other condiment
03:54:49 <[exa]> gentauro: you need a tastier flame
04:00:01 <govno> How to understand `forall` keyword in haskell ?
04:05:07 <dminuoso> govno: Think of a type containing a type variable as a type that is abstracted over that variable.
04:05:39 <dminuoso> Just like (\x -> x + 1) is an increment abstracted over x, a type `forall a. Maybe a` is abtracted over a variable a.
04:09:03 <dminuoso> govno: So take the function: (\x -> x + 1), if you apply this to 5 you subtitute x for 5 on the right hand side yielding: 5 + 1
04:09:25 <dminuoso> govno: Equivalently if you take the type `forall a. Maybe a` and apply it to Int you replace `a` with Int on the right hand side yielding `Maybe Int`
04:11:14 <hpc> the other thing to know about it is, suppose you have any polymorphic type
04:11:19 <hpc> :t either
04:11:20 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
04:11:29 <hpc> so that has type variables a, b, and c
04:11:42 <hpc> there's an implicit "forall a b c." at the start of the type
04:14:33 <govno> dminuoso: I can replace a with any type in `forall a. Maybe a` and a must be any kind  or only monomorphic?
04:15:03 <dminuoso> govno: the kind is usually inferred, but you could specify it.
04:16:38 <dminuoso> > let f :: forall (a :: * -> *). Maybe (a Int); f = undefined in ()
04:16:41 <lambdabot>  ()
04:16:43 <dminuoso> > let f :: forall a. Maybe (a Int); f = undefined in ()
04:16:45 <lambdabot>  ()
04:18:29 <dminuoso> govno: The extension `TypeApplications` might also be useful, since it lets you manually apply types
04:18:34 <dminuoso> :t fromJust
04:18:36 <lambdabot> Maybe a -> a
04:18:48 <dminuoso> Which actually should read: forall a. Maybe a -> a
04:18:50 <dminuoso> so if you do:
04:18:53 <dminuoso> :t fromJust @Int
04:18:54 <lambdabot> error:
04:18:54 <lambdabot>     Pattern syntax in expression context: fromJust@Int
04:18:54 <lambdabot>     Did you mean to enable TypeApplications?
04:19:06 <dminuoso> % :set -XTypeApplications
04:19:06 <yahb> dminuoso: 
04:19:10 <dminuoso> % :t fromJust @Int
04:19:10 <yahb> dminuoso: Maybe Int -> Int
04:19:42 <dminuoso> Useful for experimenting I mean. Whether its useful to you in production is up to you.
04:20:11 <hpc> % :t fromJust @(Maybe a)
04:20:11 <yahb> hpc: ; <interactive>:1:18: error: Not in scope: type variable `a'
04:20:16 <hpc> blah
04:20:24 <hpc> % :t forall a. fromJust @(Maybe a)
04:20:24 <yahb> hpc: ; <interactive>:1:28: error: Not in scope: type variable `a'
04:20:43 <dminuoso> hpc: do you perhaps mean
04:20:51 <dminuoso> :t fromJust @(forall a. Maybe a)
04:20:53 <lambdabot> error:
04:20:53 <lambdabot>     Pattern syntax in expression context: fromJust@(forall a . Maybe a)
04:20:53 <lambdabot>     Did you mean to enable TypeApplications?
04:20:54 <dminuoso> % :t fromJust @(forall a. Maybe a)
04:20:54 <yahb> dminuoso: ; <interactive>:1:1: error:; * Illegal polymorphic type: forall a. Maybe a; GHC doesn't yet support impredicative polymorphism; * In the expression: fromJust @(forall a. Maybe a)
04:21:13 <hpc> i don't even know what i mean anymore, i'll just wait for tomorrow when i can think again :P
04:21:18 <dminuoso> Haha. :)
04:21:24 <dminuoso> hpc: Why cant you think today?
04:21:30 <hpc> it's friday, probably
04:22:37 <dminuoso> % :set -XImpredicativeTypes
04:22:37 <yahb> dminuoso: 
04:22:40 <dminuoso> % :t fromJust @(forall a. Maybe a)
04:22:40 <yahb> dminuoso: Maybe (forall a1. Maybe a1) -> Maybe a
04:22:47 <dminuoso> hpc: There you go!
04:23:24 <hpc> yay
04:23:39 <dminuoso> No idea what that even means, but it looks pretty.
04:26:14 <dminuoso> govno: What may also be interesting to you, is that the underlying mechanism of `TypeApplications` is already used by GHC internally.
04:26:40 <dminuoso> Every time you use a polymorphic function (that is one that is abstracted over types), GHC applies it to the inferred types automatically.
04:28:05 <dminuoso> So `fmap nub ["11", "22"]` actually becomes `fmap @[] @String @String nub ["11", "22"]`
04:29:28 <Tops2> Is it possible to declare an undefined pattern synonym?
04:30:29 <dminuoso> govno: If you look at it, it should make obvious why type variable polymorphism moves the `choice` of the type variable to the *consumer*
04:30:49 <dminuoso> because the *consumer* gets a function `forall a. ...` and the *consumer* can decide what type to apply it to.
04:31:37 <dminuoso> Just like `\x -> x + 1` moves the choice of `x` to the *user* of the function - the implementor cant know what `x` is going to be in advance
04:35:12 <govno> dminuoso: Ok, thanks
04:40:00 <lyxia> Tops2: what would that do
04:41:48 <Tops2> Allow me to compile my tests
04:42:31 <Tops2> I just solved it: pattern Pat a b c = Pat a b c
04:44:14 <lyxia> oho
04:44:30 <ggole> Is that actually recursive?
04:44:34 <Tops2> Otherwise I would have needed to add typeclass constraints everywhere in depending module :/
04:46:21 <Tops2> oh noes, it doesn't work... the error wasn't highlighted at pattern line so I thought it worked :/
04:46:28 <Tops2> at the*
04:47:53 <ski> hmm .. are pattern synonyms guaranteed to terminate (let's say we refrain from using view patterns, and also that the input is assumed to not contain bottoms) ?
04:48:26 <lyxia> Tops2: (undefined -> (a, b, c))
04:48:35 <ski> (not sure whether one can use guards or pattern guards in pattern synonyms. if one can, then let's say we also refrain from using those)
04:53:15 <Tops2> thanks lyxia
04:59:16 <Ariakenom> ski: as far as I can tell, yes
04:59:44 * delYsid just discovered Debug.Trace
04:59:55 <Ariakenom> Heathen!
05:00:15 * Ariakenom goes to grab torches and pitchforks
05:01:57 <delYsid> I have a parMap over a very long list which uses up all CPUs at the beginning, but very very slowly drops down to just one thread.  The work packages are reasonably small enough to not be suspect, so what could that be?
05:04:24 <Ariakenom> one task taking longer?
05:04:37 <Tops2> lyxia: Actually now it complains about my exports: Pattern synonyms can only be bundled with matching type constructors
05:05:47 <delYsid> Ariakenom: That is what I ment by "the work packages are reasonably small enough to not be suspect".
05:07:23 <Ariakenom> right, just wondering if it could be the mean is small but the worst is big
05:08:01 <tsaka__> is there a program to remove all unused imports from all source files .. 
05:08:36 <hpc> tsaka__: vim :P
05:08:44 <Tops2> lyxia: Ahh, sorry that was in another similar named module
05:09:23 <hpc> (you don't usually have so many imports that you need a tool to do the deleting for you, just the ghc warnings to point you at them)
05:09:34 <Ariakenom> tsaka__: -ddump-minimal-imports
05:09:59 <tsaka__> i just want a tool to do it for me
05:10:15 <tsaka__> haskell-process-minimum-imports inserts ddump-minimal-imports
05:10:32 <tsaka__> but it does not remove the original imports, and only works on 1 file at a time
05:11:08 <tsaka__> maybe I'm lazy; i find it a chore to manage the import list in haskell ...
05:11:39 <tsaka__> it seems more of a task in functional languages
05:12:01 <tsaka__> managing the name space, that is
05:13:19 <Ariakenom> Namespaces pffft. Just use C. 
05:16:59 <hpc> naming things is a solved problem in javascript, just use a minifier
05:17:17 <dminuoso> Quite a few interesting talks here at Haskell eXchange in london. I should really linear types a try =)
05:17:36 <Ariakenom> mumble mumble affine mumble
05:17:44 <hpc> mumble mumble rust mumble
05:18:14 * ski . o O ( woof woof arf affine variety wurf ? )
05:18:55 <hpc> gesundheit
05:28:21 <__monty__> Ariakenom: You mean because of exceptions? The authors argue against this in their faq.
05:28:50 <Ariakenom> I guess I've read it but can you link?
05:29:23 <Ariakenom> __monty__: and yes it was because exceptions
05:30:06 <__monty__> Ariakenom: https://ghc.haskell.org/trac/ghc/wiki/LinearTypes#Dontlinearguaranteesdegradetoaffineinthepresenceofexceptions
05:38:11 <Ariakenom> __monty__: interesting stuff
05:38:18 <Ariakenom> The previous answer is interesting. So catch needs to change type?
05:43:15 <Ariakenom> no it is compatible
05:46:09 <Ariakenom> (I think ...)
05:46:26 <govno_> what I can read about existen–µial types?
05:47:19 <ski> @where existential-antipattern
05:47:19 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
05:47:22 <ski> govno_ ^ ?
05:49:38 <cocreature> that focuses only on the negative aspects :)
05:49:39 <ski> govno_ : i mean .. i could give you a basic tutorial on them
05:49:45 <ski> yes
05:52:55 <govno_> ski: thanks
05:54:09 <ski> govno_ : .. but i'm leaving soon, so perhaps a later day ? feel free to remind me
05:59:10 <cocreature> the user guide is probably not a bad place to start https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#existentially-quantified-data-constructors
06:19:07 <humblewolf> webapis for moderate to high performance - cpp or haskell ???
06:19:56 <cocreature> ‚Äúwebapi‚Äù doesn‚Äôt strike me as something that will require levels of performance only achievable with c++, so Haskell :)
06:20:13 <dminuoso> @let data HK a
06:20:14 <lambdabot>  Defined.
06:20:46 <dminuoso> > let () :: (HK a ~ a) => () in ()
06:20:48 <lambdabot>  <hint>:1:5: error:
06:20:48 <lambdabot>      Invalid type signature: () :: ...
06:20:48 <lambdabot>      Should be of form <variable> :: <type>
06:20:52 <dminuoso> Uhh
06:21:43 <dminuoso> @let f :: (HK a ~ a) => (); f = ()
06:21:44 <lambdabot>  .L.hs:173:6: error:
06:21:44 <lambdabot>      ‚Ä¢ Occurs check: cannot construct the infinite type: a0 ~ HK a0
06:21:44 <lambdabot>      ‚Ä¢ In the ambiguity check for ‚ÄòL.f‚Äô
06:21:59 <dminuoso> Why is GHC complaining about the infinite type here?
06:22:47 <dminuoso> Oh well it doesn't matter.
06:23:14 <Gurkenglas> Layman's guess: a is unpacked to HK a is unpacked to HK (HK a) etc and it notices that won't go anywhere
06:24:08 <Gurkenglas> :t let foo :: ([a] ~ a) => [a]; foo = [] in foo
06:24:08 <cocreature> dminuoso: are you asking why the type is infinite or why GHC doesn‚Äôt allow for infinite types?
06:24:08 <lambdabot> error:
06:24:09 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ [a]
06:24:09 <lambdabot>       arising from a use of ‚Äòfoo‚Äô
06:24:56 <dminuoso> cocreature: The former.
06:25:12 <humblewolf> best path for learning haskell ?? any suggestion guys ??
06:25:53 <cocreature> dminuoso: if you repeatedly unify the type variables you end up with HK (HK (HK (HK ‚Ä¶)))
06:26:42 <ggole> It's quite possible to allow types inside themselves
06:27:11 <ggole> The problem is more that code will typecheck that you probably did not want to typecheck.
06:27:26 <cocreature> right, I think ocaml supports infinite types iirc
06:27:28 <dminuoso> cocreature, Gurkenglas: oh yeah.. I see. :)
06:27:39 <ggole> It does. You have to turn it on, though.
06:28:21 <ggole> It's great for when you want a list of itself.
06:30:20 <ski> cocreature : yea, but only in restricted contexts (unless you use `-rectypes')
06:30:43 <cocreature> I was thinking of -rectypes
06:31:32 <ski> (more specifically, without that, a cycle is only allowed if it goes through at least one object type. the idea is that equi-recursive types can be useful for objects with "binary methods" or "clone methods" (like "functional update"))
06:31:42 <dmwit> :t let f :: HK a ~ b => (); f = () in f
06:31:43 <lambdabot> ()
06:31:47 <ggole> Polymorphic variant types often contain themselves, even without -rectypes
06:32:18 <ski> hm, perhaps there's an exception for them as well, now
06:32:44 <ski> (i suspect polymorphic variants didn't exist when i initially read about `-rectypes')
06:33:26 * ski idly ponders coinheritance for polymorphic variants
06:33:50 <ggole> Variants are annoying because there's all sorts of sensible operations on them you just can't do
06:33:56 <ggole> eg, remove a constructor
06:34:20 <ski> from the type ? or with `match' ?
06:35:18 <ggole> From the type
06:37:29 <ski> what should happen if the row doesn't include the name ?
06:38:39 <ggole> That would be a problem, but it should be ok to be able to say something like f : 't + `Foo -> 't
06:38:49 <ggole> But you can't range over the row variable in that way
06:40:23 <ggole> Might not be the best example, since you can write that one naturally enough.
06:40:59 <ski>   let f = function `Foo -> ... | t -> t
06:41:11 <ski> that doesn't do what you suggested ?
06:54:24 <adius> Hi, I remember that there was a cool project to initialize Haskell projects, but I can't find it anymore. Can anyone help me out?
06:55:58 <cocreature> adius: summoner is the most recent one that I am aware of
06:56:47 <adius> YES! That's what I was thinking about. Thanks a lot!
07:19:41 <Zipheir`> demonstration
07:19:50 <Zipheir`> i never pay attention to it
07:40:26 <adius> Summoner has no support for hpack üòû ... I guess I'll stick with `stack new`
07:47:43 --- mode: ChanServ set +o glguy
07:47:43 --- mode: glguy set +q $~a
07:49:44 <glguy> natim87WH: You'll probably have to repeat that
07:50:00 <glguy> I just turned the screening back on for the channel and I don't think you're logged in
08:08:27 <delYsid> How do I invert an Ordering?
08:08:38 <bgamari_> johnw_, do you have much experience working with the integers in SMT (z3 in particular)?
08:08:43 --- mode: glguy set +v bgamari_
08:09:27 <bgamari_> johnw_, do you have much experience working with the integers in SMT (z3 in particular)?
08:09:42 <bgamari_> delYsid, I'm not sure there is a single function; I'd just case
08:10:07 <delYsid> ok
08:10:52 <Putonlalla> Can you use `Down` before producing the `Ordering`, delYsid?
08:10:57 --- mode: glguy set +v Putonlalla
08:12:07 <delYsid> Putonlalla: No, since I am trying to work with Text.compareLength
08:12:13 <delYsid> (which takes an Int)
08:14:58 <Taneb> :t compare EQ
08:14:59 <lambdabot> Ordering -> Ordering
08:15:09 <Taneb> > map (compare EQ) [LT, EQ, GT]
08:15:11 <lambdabot>  [GT,EQ,LT]
08:15:18 <Taneb> delYsid: :D
08:18:28 <Putonlalla> Funny corollary: `on compare Down EQ = id`.
08:26:22 <nshepperd> > comparing Down EQ [LT, EQ, GT]
08:26:24 <lambdabot>  error:
08:26:24 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚ÄòOrdering‚Äô
08:26:24 <lambdabot>                    with actual type ‚Äò[Ordering]‚Äô
08:26:28 --- mode: glguy set +v nshepperd
08:26:39 <nshepperd> > comparing Down EQ <$> [LT, EQ, GT]
08:26:41 <lambdabot>  [LT,EQ,GT]
08:28:31 <nshepperd> glguy: that's weird, I am already logged in
08:37:07 --- mode: glguy set +v reactormonk
08:37:08 --- mode: glguy set -v reactormonk
08:49:58 --- mode: glguy set -v nshepperd
08:50:28 <glguy> nshepperd: The account got desynced because I had the enforcement turned off overnight
08:51:03 <nshepperd> ah
08:51:08 --- mode: glguy set +v nshepperd
08:51:14 <glguy> <_<
08:51:16 <nshepperd> >_>
08:51:35 <glguy> Oh, I'm not running my script on this computer :)
08:51:51 --- mode: glguy set +v Guest44397
08:52:29 --- mode: glguy set -v nshepperd
08:53:17 <glguy> nshepperd: Better now?
08:53:34 --- mode: glguy set -v zzz
08:53:39 <zzz> where can I see the definition of foldr for lists? (instance Foldable [a])
08:53:50 <dmwit> ?src foldr
08:53:50 <lambdabot> foldr f z []     = z
08:53:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:53:57 <glguy> zzz: Did you click the [Source] link in the haddocks by the instance?
08:57:01 * nshepperd tests it
08:57:10 <nshepperd> cool :)
08:58:18 <zzz> glguy: where can i find that?
08:58:26 <zzz> (im new to haskell)
08:58:52 <glguy> Package documentation is hosted on hackage.haskell.org
08:59:07 <glguy> there's a [Source] link on the right side of the type signatures
08:59:10 <glguy> ?hackage base
08:59:10 <lambdabot> http://hackage.haskell.org/package/base
09:03:07 <zzz> thanks
09:03:11 <fendor> @src foldr
09:03:11 <lambdabot> foldr f z []     = z
09:03:11 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:03:21 <fendor> @src forever
09:03:22 <lambdabot> forever a = let a' = a >> a' in a'
09:03:28 <fendor> :t forever
09:03:29 <lambdabot> Applicative f => f a -> f b
09:03:54 <benzrf> @src is telling lies !
09:03:54 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:06:49 <zzz> ah. i was getting this http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data-Foldable.html#foldr (Not found because its Data.Foldable.html instead of Data-Foldable.html)
09:07:07 <infinisil> :t let a' = a >> a' in a'
09:07:08 <lambdabot> error:
09:07:08 <lambdabot>     ‚Ä¢ Couldn't match expected type ‚Äòm1 a0‚Äô with actual type ‚ÄòExpr‚Äô
09:07:08 <lambdabot>     ‚Ä¢ In the first argument of ‚Äò(>>)‚Äô, namely ‚Äòa‚Äô
09:07:16 <infinisil> Booo
09:07:25 <infinisil> :t \a -> let a' = a >> a' in a'
09:07:26 <lambdabot> Monad m => m a -> m b
09:07:30 <infinisil> Ahhh
09:07:49 <glguy> zzz: What link specifically were you clicking on that was broken?
09:08:05 <zzz> glguy: wait
09:09:18 <zzz> glguy: the source link on Hayoo!
09:09:30 <zzz> http://hayoo.fh-wedel.de/?query=foldr
09:09:46 <glguy> zzz: Oh, OK. I just wanted to make sure the docs weren't broken :)
09:10:16 <zzz> all source links on Hayoo! have dashes instead of dots (so all broken)
09:10:47 <zzz> is this a known issue?
09:11:29 <glguy> I don't know, it might be worth shooting the maintainer an email. I don't know how many people are using hayoo and figured that out
09:12:03 <zzz> will do. as a beginner, Hoogle and Hayoo! are presented as the two main sources
09:14:04 <glguy> I'd recommend going directly to hackage to see the documentation for the package you're interested in
09:14:28 <zzz> well... looks like Hayoo! it not being actively maintained
09:14:42 <zzz> this in an open issue from 3 yrs ago https://github.com/hunt-framework/hayoo/issues/47
09:47:10 --- mode: glguy set +v tedd
10:06:27 --- mode: glguy set +v govno
10:14:05 <noan> how do people typically set up their feedback look while developing web applications? Namely, on file change, kill the current process, build the new version, and start it?
10:16:18 <cocreature> noan: one option is to use ghcid to track file changes. you can tell it to execute a command each time it detects a change and you could use that to restart the process
10:18:28 <maerwald> unless the process takes 30 minutes to start
10:22:02 <noan> maerwald, I'm expecting a max 1 second start.
10:25:35 <maerwald> that's a slim web app
10:41:23 <noan> json api only, not a lot of endpoints either.
10:41:43 <noan> Frontend is a totally separate stack, a light nginx container which takes a whole 8mb
11:14:35 <Amras> could I get some help marshalling? I'm trying to draw some text with an sdl2 binding, "renderText_Solid". One of the arguments is a GHC.Ptr.Ptr Color
11:15:55 <Amras> Color is Storable, which according to Ptr's documentation should be helpful
11:16:25 <dmwit> You might be interested in https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Marshal-Alloc.html
11:16:26 <cocreature> Amras: are you sure you want to use the raw bindings in SDL.Raw.Font instead of the high-level bindings in SDL.Font?
11:17:39 <Amras> oh, right
11:17:55 <Amras> apparently I'm just blind and didn't notice SDL.font existed
11:17:56 <Amras> thanks
11:28:02 <dysfigured> anyone used haskell's Turtle library? trying to figure out how to do the equivalent of  x=$(find | fzf)  and  y=$(fzf <<< $'foo\nbar\n')
11:30:52 <Solonarv_> Amras: you might want to build some sort of cache so that you don't end up rendering the same string to a texture each frame
11:32:40 <Amras> this sounds reasonable; I guess SDL is slow at text?
11:33:26 <dysfigured> view (shell "fzf" empty)   is about as far as i got from the Turtle docs, i can't figure out how to properly pass data as stdin to a stream
11:35:24 <cocreature> dysfigured: how about something like inShell "fzf" (inShell "find" empty)
11:36:18 --- mode: glguy set +v govno
11:37:54 <Solonarv_> I don't think SDL is *particularly* slow at text, but that doesn't mean rendering the same texture 30/60 times per second is a great idea
11:38:25 <rom1504> not particularly slow at text, but SDL sure is slow
11:38:28 <dysfigured> cocreature: ah thank you!
11:38:42 <Solonarv_> may be a bit of premature optimization but I was building a generic cache data structure anyway
11:41:54 <dysfigured> hmm there's a noticable lag in responsiveness from fzf using this..
12:02:32 --- mode: glguy set +v sleepster
12:02:56 <sleepster> how far is haskell away from being able to cross compile to arm64-v8a and arm-v7a architectures?
12:23:04 <sm> perhaps related: https://www.reddit.com/r/haskell/comments/9mxfsy/what_is_new_in_cross_compiling_haskell/
12:46:50 --- mode: glguy set +v dmesg
12:46:51 <monochrom> Oh, reddit has new page design.
12:47:50 <infinisil> monochrom: Most people really don't like it I think
12:48:04 <monochrom> Predictable.
12:48:05 <infinisil> I'm using the old style
12:48:25 <Tuplanolla> I don't think I've ever seen an improvement in modernized web designs.
12:48:45 <infinisil> But all that js!
12:48:49 <Tuplanolla> Things only ever get worse.
12:49:01 <monochrom> When Windows XP came out, people said they hated how it looked, they're going back to Windows 2000.
12:49:21 <monochrom> Then, when Windows Vista came out, people said they hated how it looked, they're going back to Windows XP.
12:49:49 <stilbruch> The reddit redesign isn't very new though
12:49:51 <monochrom> At which point I was enlightened about human nature.
12:49:54 <ggVGc> I liked windows Vista, because I was learning GPU programming at the time, and it was the first version where they moved graphics drivers from kernel space
12:49:54 <geekosaur> it looks a bit cleaner to me. I was unfond of the old design
12:50:02 <ggVGc> so when I fucked up a shader, I didn't get a blue screen anymore
12:50:07 <ggVGc> \,,/
12:50:47 <__monty__> Ime since the redesign I've had far more page load problems.
12:52:55 <davean> When XP came out I said I liked tiling window manager's design and went back :-p
12:53:34 <__monty__> Windows 2000 had tiling?
12:53:34 <monochrom> I still have Windows 3.11 diskette images.
12:53:47 <davean> __monty__: no thats my point.
12:54:04 <ggVGc> monochrom: but do you have a diskette station?
12:54:08 <davean> __monty__: actually back then there *were* replacement window managers! Apps didn't know what to do with them though
12:54:13 <monochrom> Hrm, so what did you gone back to?
12:54:32 <davean> monochrom: *nix
12:55:06 <Tuplanolla> Psychoanalyze me next, monochrom. I never used Windows 95, but I made my Xfce look like it.
12:55:31 <monochrom> ggVGc: No. In fact, I threw out the physical diskettes, I am keeping the bunch of 1.44MB binary image files instead.  I would use VirtualBox when I wanted to load them up.
12:55:48 <dmesg> Hi there! I'm experimenting with effect systems, and don't quite understand the compile error I'm getting from this code: http://dpaste.com/332REEF
12:56:50 <dmesg> From my understanding it should be opaque to `funcMap` what's in an EffectfulFunc other than it having it an unFunc function?
12:56:50 <monochrom> Tuplanolla: I think everyone around that time made Linux window managers look like Windows 95.  For example fvwm.
12:57:11 <dmesg> and it would be the call site when using one of those functions that the compiler would complain about?
12:57:13 <Tuplanolla> Around that time is now, monochrom.
12:57:18 <monochrom> Oh!
12:58:21 <geekosaur> I thik the only time I ever used w95 look and feel on unix was wen I was stuck with a selection of window managers where that was the least obnxoius choice
12:58:27 <monochrom> Yeah why are you using Xfce in this the 21st century of the common era of our lord?!! XD
12:58:34 <cocreature> dmesg: no, you have defined EffectulFunc such that the function it has to work for _any_ choice of effs in particular one that doesn‚Äôt satisfy any additional constraints
12:58:59 <Tuplanolla> Only a heretic would make their rectangular windows not visually rectangular.
12:59:07 <geekosaur> (since before win95 style had come motif style with its ridiculously thick and fugly borders and such)
12:59:22 <cocreature> dmesg: your description makes it sound like you want an existential data type instead although in practice they don‚Äôt often tend to help with the problems people try to use them for
13:00:33 <dmesg> cocreature: that sounds comforting. So your saying the issue is actually with the newtype? Where the forall is allowing for any list of effects, and therefore all implementations must also?
13:01:12 <cocreature> dmesg: it‚Äôs not ‚Äúallowing for any list of effects‚Äù. it _requires_ that the function works for all choices of eff
13:01:47 <cocreature> just like if you write a top level definition with that signature
13:02:13 <dmesg> cocreature: the desire is to have funcMap contain a map of functions, some of which may have side effects. Others may not.
13:02:42 <cocreature> dmesg: right but what can you do with that map of functions without knowing anything about the effects they require?
13:02:43 <monochrom> Consider "foo :: forall a. a -> Bool", and you're the one to code up foo.  What choice do you have?
13:03:35 <dmesg> cocreature: they'd be passed to a runner function, that would be in the context of knowing all the plausible effects that any sub function could carry out
13:04:10 <cocreature> dmesg: but how do you define ‚Äúall the plausible effects‚Äù if it could literally be any effect?
13:04:31 <cocreature> you need to put some kind of constraint on the list of effects for this to be useful in any way
13:04:54 <dmesg> cocreature: no, the runner would only have certain effects that these functions would be allowed to carry out. In this case it would be just [TestEffect]
13:04:58 <dmesg> cocreature: right, exactly
13:05:02 <cocreature> otherwise you will be able to define funcMap but you won‚Äôt be able to do anything with the functions inside since you don‚Äôt know what effects they require
13:05:44 <dmesg> the individual functions in funcMap will know what effects they require. The runner will be executing them in the union of all effects.
13:06:15 <cocreature> you are still assuming that there is a notion of ‚Äúall effects‚Äù. that doesn‚Äôt make sense
13:06:23 <dmesg> but this makes sense, I think I should modify the newtype to instead contain that list - replacing the forall
13:06:33 <dmesg> (and therefore adding the constraint)
13:06:50 <cocreature> I can come up with a new effect that you haven‚Äôt considered, wrap my function in EffectfulFunc and now you need to handle the effect that you have never seen before
13:07:30 <dmesg> not if I replace the forall in EffectfulFunc with the list of effects that are allowed?
13:07:42 <cocreature> right
13:09:17 <dmesg> so how would I go about expressing that? Do I even need the newtype then?
13:09:34 <dmesg> say for example, I want to only allow EffectfulFuncs to have access to the TestEffect
13:10:03 <infinisil> I have one case of a programming problem that I don't know how to express in Haskell
13:10:59 <cocreature> dmesg: something like "newtype EffectfulFunc = EffectfulFunc { unFunc :: T.Text -> Eff.Eff '[TestEffect] (Either T.Text ()) }" should work I think
13:11:56 <dmesg> cocreature: I tried `newtype EffectfulFunc = EffectfulFunc { unFunc :: (Eff.Member TestEffect effs) => T.Text -> Eff.Eff effs (Either T.Text ()) }` but got back that effs was not in scope
13:12:25 <cocreature> right that‚Äôs missing a forall
13:12:48 <cocreature> but I don‚Äôt think that is an improvement over Eff.Eff '[TestEffect] (Either T.Text ())
13:13:23 <cocreature> if your function can be used as "forall effs. Eff.Member TestEffect effs => ‚Ä¶" it can also be used as "Eff.Eff '[TestEffect] (Either T.Text ())"
13:13:26 <cocreature> the converse is not true
13:14:07 <dmesg> sorry for being dumb, the converse here being?
13:14:53 <dmesg> I'd prefer to not pick a concrete list of effects, in case the runner has some extra for whatever reason. I know the EffectfulFunc won't be able to use them in both cases if I understand correctly?
13:15:34 <cocreature> if you have something of type Eff.Eff '[TestEffect] (Either T.Text ()) you cannot use it as if it had type forall effs. Eff.Member TestEffect effs
13:16:26 <dmesg> right, I agree the former is more restrictive than the latter case. I'm just not sure why I would want the former case?
13:18:03 <cocreature> no the former is more permissive. if you have x :: forall effs. Eff.Member TestEffect effs => ‚Ä¶ you can use y :: Eff.Eff '[TestEffect] (Either T.Text ()); y = x
13:18:22 <cocreature> but you can‚Äôt use x :: forall effs. Eff.Member TestEffect effs => ‚Ä¶; x = y
13:18:48 <dmwit> (It might be interesting to distinguish between "permissive for the implementor" and "permissive for the caller".)
13:20:55 <cocreature> I would probably just stop trying to hide the type parameter
13:20:58 <cocreature> so something like https://gist.github.com/cocreature/b7e2a40fd4dbee53f27d922aad7efd52
13:21:49 <dmesg> hmm, I hadn't thought of htat
13:22:37 <cocreature> if you don‚Äôt actually need to hide the type parameter for some reason (and afaict for your example you don‚Äôt) that‚Äôs usually the easiest option
13:23:19 <dmesg> cocreature: okay, thank you for your help! Let me play around with that and I'll come back if I get myself tangled up again. Thanks again!
13:24:04 <cocreature> (you‚Äôll have to add a constraint to the type signature of funcMap to get GHC to stop complaining)
13:57:23 <_edouard> ls
15:08:56 <zzz> what is the easiest way to draw pixels on a 2d canvas with haskell?
15:12:09 <monochrom> I might try "diagrams".
15:17:29 <orzo> i've used juicy-pixels before
15:17:36 <orzo> don't know how it compares to diagrams
15:18:50 <hpc> juicy pixels is good if the "lots of pixels" objects you want to interact with are images
15:18:55 <hpc> diagrams is good if they are shapes
15:20:21 <orzo> i used rasterific with jucy-pixels
15:20:44 <zzz> i'll try diagrams! thanks
15:31:43 <zachk> zzz, I'd say cabal install gloss is nice if you can live with vector graphics and bitmaps
15:34:05 <zzz> can i have good control over single pixels in diagram?
15:37:50 <zzz> well, nothing like trying
15:38:05 <Tuplanolla> Do you want still images or animations, zzz?
15:39:08 <zzz> still will suffice for now
15:39:16 <zzz> animation would be awesome in the future
15:40:22 <zzz> they dont seem hard to learn, i might try both of them
15:43:25 <lpvb> how is cloud haskell these days? last activity on http://haskell-distributed.github.io/ is 2016. Is it a viable competitor to elixir/erlang?
15:53:07 <zzz> i dont know if this is the right place, but i found an error @ http://hackage.haskell.org/package/naturals-0.2.0.2/docs/Data-Natural.html in the first line where it reads "non-positive integers" it should read "non-negative"
15:53:52 <zzz> *"non-negative integers"
15:54:01 <glguy> It's not the right place. You should contact the maintainer to report bugs
15:54:30 <Tuplanolla> Click Contents and see if there's a bug tracker or an email address, zzz.
15:54:42 <zzz> ok thanks
16:11:17 <sleepster> thanks sm for the link
16:12:05 <sleepster> I think it'd be great if I can run my code on an Android device
16:12:15 <sleepster> I have quite a bit c code that I'd like to replace with Haskell
16:17:33 <orzo> I have some c++ modules i want cabal to build and link, but i want to pass compiler options that apply only to these files, not to any intermediate c modules.  Based on warning messages, I suspect cc-options is not doing what I want.
16:17:53 <orzo> Anyway to do this?
16:19:58 <orzo> cabal seems to recognize .cc as a c++ extension, but when i give c++ related options, i get warnings about them being ignored for non-c++ moduels
16:42:01 <lyxia> orzo: maybe you can use the custom build setup instead of the simple one
17:04:14 <orzo> lyxia: turns out i needed cabal-version: 2.1 at the top and use cxx-options and cxx-sources 
17:35:22 <jle`> is there a nice way yet to get "either-or" constraints?
17:38:13 <csaurus> Has anyone ever had a problem with haskell-mode where when interactive-haskell-mode is enabled syntax highlighting turns off and a lambda shows up at the bottom of the buffer?
17:38:19 <csaurus> and it's no longer editable?
17:40:18 <Solonarv_1> I'm not aware of one, and it seems difficult even in principle due to the open-world assumption
17:41:25 <jle`> indeed
17:41:38 <jle`> i'm looking for a situation determined completely at compile-time
17:41:46 <jle`> but i'm not sure if that helps at all
17:41:59 <Solonarv> you can probably throw something together using overlapping instances
17:42:27 <jle`> that works in certain specific situations
17:42:38 <jle`> in my particular one at the moment, it does not, unfortunately
17:45:26 <Solonarv> this is roughly what I had in mind: https://gist.github.com/Solonarv/2c280eafccdcb570ce7b8de1f2f8f467
17:47:53 <jle`> oh hm, i hadn't thought of mixing overlapping with overlaps :)
17:48:21 <Solonarv_> eh, I don't think that actually does anything (as long as there are no other instances)
17:48:28 <jle`> hm, doesn't quite compile
17:49:02 <Solonarv_> I'm guessing it's asking you to turn on IncoherentInstances?
17:50:26 <jle`> the error is "duplicate instance declarations"
17:50:39 <jle`> with or without incoherent instances
17:51:00 <Solonarv_> ah, I was afraid of that - they have the same head
17:51:23 <Solonarv_> you can obviously kludge it with templatehaskell
17:53:18 <jle`> yeah, that's what i'm triyng to avoid :)  but i guess that makes sense as an escape hatch
17:54:08 <Solonarv_> hmmm, or a compiler plugin
17:55:14 <jle`> ah, hm, perhaps :o
17:55:24 <jle`> that might work, i've seen some plugins doing similar things
17:56:21 <Solonarv_> you can definitely write a plugin that makes Or (and its uses) typecheck
17:56:54 <Solonarv_> but idk enough about compiler plugins to tell you how to provide an instance dictionary
17:58:24 <Solonarv_> obviously if you don't provide a dictionary you'll get a runtime crash whenever you try to use an instance method
18:00:53 <monochrom> exclusive-or is non-monotonic.
18:04:58 <orzo> has anybody put an st-like interface on pointers for doing storable/cereal things with region-bound buffers?
18:07:41 <monochrom> I think yes. Let me see if I can find what I saw.
18:11:49 <monochrom> OK, try these two package names: "regions" and "compact".  I am not sure which one suits you more.
18:12:52 <orzo> i found a "/regional-pointers" package that uses your "regions" suggestion
18:13:13 <monochrom> Yeah
18:18:08 <orzo> i'm reading about compact
18:18:55 <orzo> i don't yet udnerstand it.  Does it make use of some fancy magic compiler support?
18:19:14 <monochrom> I think compact is for pure functional data structures, regions is where you can do Storable stuff.
18:19:59 <monochrom> Yeah it calls up some primitives in GHC.Compact that comes with GHC.
18:20:59 <orzo> regions is probably what i want, but the compact thing is interesting
18:21:08 <monochrom> Yeah!
18:27:35 <boj> compact would be for long lived data that never changes. like textures and models in a game engine, or a data set you plan on examining in a myriad of different ways but not mutating
18:28:13 <boj> hmm, is that last bit really a valid use?
18:28:21 * boj shrugs
18:28:52 <monochrom> Yes.
18:30:53 <jle`> is compact really meant to be stable over different ghc releases?
18:32:33 <monochrom> I don't know yet. :)
18:34:47 <orzo> i read the tutorial in the readme  and boj's comment
18:34:59 <orzo> can't say I really confidently understand what compact does
18:35:39 <monochrom> It's OK. It's a bit wacky.
18:36:28 <boj> i think the "ensures efficient garbage collection" is the key takeaway, but yeah, a bit wacky
18:36:37 <boj> there's a short white paper out there about it
18:38:30 <orzo> "The object in question must not contain any functions or mutable data; if it does, compact will raise an exception. In the future, we may add a type class which will help statically check if this is the case or not." That sounds like the Data type-class would sufficie
18:39:14 <boj> here it is http://ezyang.com/compact.html
18:43:08 <orzo> thanks
19:00:33 --- mode: glguy set +v st33med
20:31:13 <c_wraith> um.  hackage is now asking for credentials to see package descriptions?
20:31:29 <c_wraith> Oh, now it's not.  Ok, that was a transient issue
21:49:40 <pimlu> I have an exception in Y, which is called from X.  X calls Y in two different places.
21:49:57 <pimlu> The stack trace doesn't give line numbers, so how do I know which Y it was?
22:15:59 <cocreature> pimlu: maybe try adding explicit cost centres. I think they should show up in a +RTS -xc stack trace
22:20:42 <BaneAliens> question about 'foo x y = x - y' I always thought currying was right associate, so if I do foo 10 it would be x - 10
22:20:52 <BaneAliens> am I understanding right associative wrong here?
22:21:42 <cocreature> right associativity in the context of currying refers to a -> b -> c being equivalent to a -> (b -> c)
22:21:49 <cocreature> I‚Äôm not really sure what that has to do with your example
22:21:57 <cocreature> but foo 10 is 10 - y not x - 10
22:22:02 <cocreature> or rather \y -> 10 - y
22:23:45 <glguy> foo x y = x - y === foo = \x y -> x - y === foo = (\x -> (\y -> x - y))
22:54:16 <dmwit> pimlu: Uh... the stack trace *should* give line numbers.
22:54:51 <dmwit> I mean, it does here, anyway.
22:54:56 <pimlu> cocreature: thanks, I'm working on trying that now
22:55:06 <pimlu> dmwit: are you doing +RTS -xc?
22:55:55 <dmwit> No. Have I missed some context, then?
22:56:52 <dmwit> With +RTS -xc I get two call stacks, one from HasCallstack and one from -prof. The one from -prof doesn't have line numbers, ouch.
22:57:19 <pimlu> I see, so if I use HasCallstack, I will have line numbers?
22:57:29 <dmwit> But then perhaps you can just add some HasCallstack constraints and then you'll have line numbers.
22:57:35 <dmwit> Yes, you should.
23:00:47 <pimlu> I guess this might be a good time to ask, why doesn't the callstack from -prof have line numbers?
23:05:17 <pimlu14> sorry, if you said something, my internet died
23:05:24 <Axman6> because it;s a completely different thing from GHC.Stack IIRC
23:05:44 <pimlu14> yeah https://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html says there
23:05:57 <pimlu14> there's at least 3 different concepts of stacks lol
23:06:03 <Axman6> the -prof stuff is quite old, the GHC.Stack stuff is relatively new and uses a very different machanism
23:06:17 <Axman6> stacks are hard in lazy functional languages :)
23:06:38 <pimlu14> yeah :( sadly
23:09:23 <Axman6> sprinkling HasCallStack all over the place can do a lot of good though :)
23:11:39 <pimlu14> is that something that can just get ignored in production?
