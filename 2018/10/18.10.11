00:01:05 <Maxdamantus> But you can't dereference a `void *` for example, whereas dereferencing a `Ptr ()` would presumably give you a `()`, which seems misleadingly sensible.
00:01:33 <quicksilver> there isn't a lot of difference though
00:01:39 <quicksilver> I mean a () contains no information
00:02:06 <quicksilver> dereferencing to something with zero information content is not so different from not being able to dereference at all
00:02:37 <Ariakenom> Consider "void print(char[] x)" here void is clearly ()
00:03:06 <Maxdamantus> Right. That's the case where unit would be better than void.
00:03:47 <Ariakenom> The unboxed representation of () needs no bits.
00:03:50 <quicksilver> the difference between () and Void in haskell is clearest in the types `() -> a` and `Void -> a`
00:04:06 <quicksilver> but that difference doesn't really carry through the C void* analogy
00:04:23 <Ariakenom> I say "it's just weird language semantics" that stops it from being first class
00:04:23 <quicksilver> or maybe my brain has insufficient caffeine and can't see the progression
00:05:26 <Ariakenom> Well the unknown type example would be some cast, unsafeCoerce-like, anyway
00:05:42 <Maxdamantus> Think of it this way: if C had used unit instead of void, it would not use `unit *` to represent random pointer types.
00:06:10 <Maxdamantus> `void *` kind of works for representing random pointer types *because* it's a void type.
00:06:22 <Ariakenom> whats a "void type"
00:06:28 <Maxdamantus> A type with no values.
00:06:58 <Maxdamantus> (that is, because `void *` is a void type, not because `void *` is a void type, which it's not)
00:07:10 <Maxdamantus> er, because `void` is a void type*)
00:07:22 <Ariakenom> ok
00:07:37 <Maxdamantus> That correction is ambiguous. Hopefully people can figure out what I meant.
00:09:07 <Ariakenom> yes
00:09:40 <trcc> Interesting discussin
00:09:45 <Ariakenom> well any choice is technically valid for something that we cast anyway, right?
00:10:08 <Ariakenom> int*
00:11:05 <tdammers> you could say that void* says "it's a pointer, but whatever it points to isn't inhabited by anything, so in order to dereference this pointer, you need to unsafe-cast it to something that is inhabited"
00:13:17 <Ariakenom> But should Ptr Void be uninhabited due to Void being uninhabitated?
00:14:24 <Maxdamantus> Disregarding null pointers, that would be optimal.
00:14:26 <quicksilver> I'd suggest that 'allocating memory for a value of an uninhabited type' doesn't make any sense
00:14:27 <trcc> Void * is not uninhabited. It points to something that is uninhabited.
00:14:43 <quicksilver> so Ptr Void doesn't really make sense
00:14:49 <Maxdamantus> but C lets you convert between object pointer types anyway, so there isn't really an uninhabited pointer type.
00:14:58 <quicksilver> unless you admit that you're really just planning to cast it
00:15:05 <quicksilver> and then it's a fairly dishonest type anyway
00:15:20 <quicksilver> Ptr (exists a . a) would be more honest
00:15:30 <quicksilver> (but still not actually right)
00:15:50 <Ferdirand> why is that, not actually right ?
00:15:56 <Ariakenom> Ya, I was considering that one.
00:16:06 <quicksilver> because Ptr (exists a . a) says that you don't know what the type a is
00:16:12 <quicksilver> and you can never find out
00:16:30 <quicksilver> whereas what you really mean is "some other part of my program does actually know what type this is, or it would be useless"
00:16:50 <Ferdirand> so you would float the a up the type of anything that uses such a pointer ?
00:16:52 <trcc> quicksilver: agreed. A different word that void should be used in context of void*
00:17:00 <trcc> Unknown *
00:17:18 <quicksilver> it doesn't bother me in C. In C it's just an idiom of the language and it means what it means :)
00:17:33 <quicksilver> but in terms of trying to find a sensible mirror in haskell, it's unsatisfactory.
00:17:52 <Maxdamantus> "Unknown" basically means the same thing to me as "∃x. x"
00:19:32 <Maxdamantus> I was actually about to bring up an analogy from Java .. if you have a "list of unknown things", `List<?>` is more correct than `List<Object>`
00:20:01 <trcc> I am unaware of the type hierarchy in Java, but if Object sits at the top, then why?
00:20:11 <trcc> Like Any in Scala right?
00:20:28 <Maxdamantus> It would still be unsound to cast `List<?>` to some other `List<T>`, just as it's basically unsound to cast `void *` to some other `T *`
00:20:45 <Maxdamantus> but it's at least a "more honest" type, as quicksilver put it.
00:20:59 <trcc> Maxdamantus: why is it unsound if you know the full context?
00:21:31 <Maxdamantus> trcc: if you know the full context, you shouldn't need to represent it as `List<?>`
00:22:02 <trcc> hehe in that we agree. However, a framework might not know how it is used
00:22:44 <liste> Java has subtyping and use-site variance, so List<Object> and List<? extends Object> (ie. List<?>) are different
00:23:29 <liste> List<Object> means that both the upper and lower type bound is Object, ie. no subtypes of Object are allowed
00:23:43 <liste> proper subtypes*
00:23:55 <trcc> So you advocate for ? 
00:25:36 <liste> well List<Object> would only contain empty objects (ones created with "new Object()") so it'd be kinda pointless
00:25:50 <Maxdamantus> No. That's not right.
00:26:15 <Maxdamantus> A `List<Object>` list can contain any object.
00:26:16 <trcc> liste: it could contain anything subtyping object. E.g. an instance of a user-defined class
00:26:41 <Maxdamantus> It's just that a `List<String>` is not a `List<Object>`
00:26:43 <realloc> throwTo requires a ThreadId, however, how can I throw an asynchronous exception to a thread started using async (which gives me (Async a) instead of ThreadId)=
00:26:55 <Maxdamantus> but a `List<String>` is a `List<?>`, aka `List<? extends Object>`
00:27:21 <liste> yes, you're right
00:27:37 <realloc> should I use cancelWith? Looks right, but sounds unintuitive
00:27:49 * liste gets more coffee
00:28:04 <Ariakenom> realloc: why unintuitive?
00:28:59 <realloc> Ariakenom: What if I just want to inform the thread of an unexpected event, but not cancel it? 
00:29:31 <Ariakenom> realloc: interesting. don't think I've heard of that use case
00:30:02 <Ariakenom> realloc: seems fine though. make sure you don't catch too broadly
00:30:25 <realloc> Ariakenom: alright, thank you
00:30:40 <Ariakenom> you don't want to catch Ctrl-C
00:32:18 <realloc> Ariakenom: I dont? Thats one of the problems I'm facing right now. I've multiple threads piping data into tcp connections using runConduit. Right now I'm trying to figure out how to handle Ctrl-C and shut everything down correctly
00:33:25 <Ariakenom> Eh right. For cleanup stuff its fine ofc.
00:33:30 <boj> realloc: you may be interested in something i wrote https://github.com/uncannyworks/armoredbits/blob/master/src/ArmoredBits/Control/Tasks.hs
00:33:31 <Maxdamantus> Hm. Actually, `Ptr (exists a. a)` would be wrong. It should be `exists a. Ptr a` if anything.
00:33:32 <trcc> Maxdamantus: List<String> is also List<Object>, not only List<?>
00:33:40 <Maxdamantus> trcc: it's not.
00:33:50 <boj> realloc: it allows for proper thread shutdown as you desire
00:33:52 <trcc> why not? String is an instance of Object
00:33:53 <Maxdamantus> trcc: you can't store an `Integer` in a `List<String>`
00:34:02 <Ariakenom> Maxdamantus: Ptr a where a is bound somewhere else :p
00:34:08 <Maxdamantus> trcc: you can store an `Integer` in a `List<Object>`
00:34:36 <trcc> That means List<Object> is not List<String>, but the other way around it still holds
00:34:43 <opqdonut> this is the challenge of polymorphism and mutability
00:34:53 <Maxdamantus> Ariakenom: it's not really about where it's bound. A `Ptr (exists a. a)` would allow you to dereference the address to store anything in it.
00:34:59 <Maxdamantus> Ariakenom: *ptr = 4;
00:35:02 <opqdonut> it seem like you should be able to cast List<String> into List<Object>, but then if you store an Integer in it, the original List<String> is no longer valid
00:35:28 <Maxdamantus> Ariakenom: since `*ptr = a;` expects `a` to be a `exists x. x`, which any value can satisfy.
00:35:36 <opqdonut> reads are covariant and writes are contravariant, so if you support both you must be invariant
00:35:42 <realloc> boj, yes, that sounds very useful, I'm looking into it, thank you!
00:35:57 <Ariakenom> yes true. I was just going for kick the problem up the tree
00:36:55 <Maxdamantus> trcc: a `List<Object>` is not a `List<String>` because someone can expect to only get `String`s out of a `List<String>`, but a `List<Object>` might have an `Integer` in it.
00:37:31 <trcc> Maxdamantus: I agree. But List<String> is still List<Object>.
00:37:42 <trcc> but List<Object> is not List<String>
00:37:46 <Maxdamantus> trcc: it's not. You can't store an `Integer` in a `List<String>`
00:37:56 <trcc> hence my second clause
00:38:02 <opqdonut> https://stackoverflow.com/questions/3763192/java-collections-covariance-problem
00:38:09 <opqdonut> https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super
00:38:14 <opqdonut> this is a fairly known thing in the Java world
00:38:23 <Maxdamantus> trcc: no, the reason `List<Object>` is not a subtype of `List<String>` is because of what I said above.
00:38:46 <Maxdamantus> trcc: there is no subtyping relationship between `List<Object>` and `List<String>`
00:38:55 <Maxdamantus> trcc: no relationship in either direction.
00:39:10 <trcc> why not? String is an instance of Object
00:39:13 <Maxdamantus> trcc: because `T => List<T>` is invariant.
00:39:20 <opqdonut> trcc: because that's how it's been specced
00:40:26 <opqdonut> because otherwise it wouldn't be safe
00:40:35 <trcc> hmm
00:41:00 <opqdonut> if you could cast List<String> into List<Object>, you could add an Integer, which would break the List<String>
00:41:22 <opqdonut> if you could cast List<Object> into List<String>, you could try to read a String, which might be an Integer instead
00:42:24 <opqdonut> reading is covariant (you can read out a supertype), writing is contravariant (you can write in a subtype), if you support both, you must be invariant
00:42:40 <trcc> Thank you
00:43:10 <opqdonut> you can make co-/contravariant generics using the ? super and ? extends syntax
00:43:16 <opqdonut> see PECS
00:43:27 <Ferdirand>   
00:43:42 * Maxdamantus thinks "SECS" would've been catchier.
00:44:04 <Maxdamantus> and it would align with java.util.function
00:44:16 <realloc> boj, I'm probably going to implement it a bit differently for my use case, however, I think I'll copy your idea of a TaskManager, since it could be indeed very useful for managing my thread-mess ;)
00:44:37 <boj> realloc: cool, glad it was helpful
00:48:50 <trcc> Maxdamantus and opqdonut: thanks for discussion, learned a lot!
00:48:59 <trcc> Just looked up the links
00:49:12 <opqdonut> variance can be really subtle
00:49:23 <opqdonut> and subtyping is hard to get right
00:49:26 <Maxdamantus> np
00:49:41 <Maxdamantus> imo subtyping is ultimately more trouble than it's worth.
00:50:14 <opqdonut> yep
00:50:16 <Maxdamantus> When you actually need those constraints, you can just implement them using functions from the supposed "subtype" to the supposed "supertype".
00:50:38 <Maxdamantus> and writing code that way is obviously just a more generic way of writing.
00:50:47 <opqdonut> reading the TaPL chapter on subtyping really drove that home
00:50:56 <opqdonut> IIRC
00:50:56 <koz_> opqdonut: TaPL?
00:51:06 <Maxdamantus> Types and Programming Languages, Ben Pierce
00:51:09 <koz_> Ah.
00:51:10 <opqdonut> https://www.cis.upenn.edu/~bcpierce/tapl/
00:51:29 <opqdonut> (I can never remember if it's Pierce or Peirce for some reason)
00:51:33 * koz_ appends it to his reading list.
00:51:57 <opqdonut> there's a newer book that some people praise
00:51:57 <trcc> Maxdamantus: I'll add it to my huge bunk of ToRead stuff :D
00:52:01 <opqdonut> I wonder what it was called...
00:52:14 <Maxdamantus> HoTT?
00:52:27 <opqdonut> https://softwarefoundations.cis.upenn.edu/plf-current/index.html
00:52:34 <opqdonut> probably that one
00:52:48 <Maxdamantus> Ah, nvm then.
00:52:52 <opqdonut> Maxdamantus: I don't think HoTT is as beginner-friendly as TaPL :D
00:53:06 <koz_> Oh, Brett Yorgey was involved in that one, cool.
00:53:15 <koz_> s/Brett/Brent argh
00:53:32 <Maxdamantus> HoTT was what finally made the whole Curry–Howard/BHK stuff click for me.
00:53:50 <Maxdamantus> though that's probably just because it's the first thing I tried reading properly on that subject.
00:54:08 <Maxdamantus> (I don't understand the homotopy stuff)
00:54:17 <trcc> HoTT?
00:54:24 <koz_> trcc: Homotopy Type Theory.
00:54:29 <koz_> (I think)
00:54:33 <Maxdamantus> (I just remember it having a decent introduction to the Curry–Howard correspondence)
00:54:40 <trcc> Thanks. Can that be read by someone relatively new to type theory?
00:54:44 <Maxdamantus> yes, homotopy type theory, also the name of the main book involved.
00:55:22 <Maxdamantus> Yes, I think it can, though at some point you're probably going to get lost, like I did.
00:55:34 <Maxdamantus> unless you're already very familiar with type theory and homotopy type theory.
00:55:39 <trcc> hehe I am not
00:56:15 <Maxdamantus> afair it was decent at just building up to wherever the reader was capable of getting to.
00:56:37 <trcc> ah sounds good
00:57:01 <Maxdamantus> er, meant "type theory and homotopy theory"
01:45:23 <realloc> any ideas, why conduit's "Sink" type is deprecated? I think its a lot more readable than the ConduitT variant
01:49:48 <cocreature> afaik, the various type synonyms which sometimes had a different order in the type parameters caused more confusion than they were helpful so michael deprecated them
02:57:24 <dminuoso> So I have a situation in which I need to read/write from/to sockets indirectly in chunks, effectively simulating input/output of a terminal. I want to rig some `execute :: Monad M => String -> M String` interface ontop of it by reading the `output` stream looking for indicators whether a given command has finished, and taking the read bytestring putting it into a String. 
03:00:56 <dminuoso> My original thought was to start with conduit but Im kind of in the situation where I need to build a premonadic Requests/Responses style and make it monadic.
03:36:15 <dmwit> Is there a question lurking in there? If so, I couldn't understand the setup *and* I don't know what the punchline is.
04:52:01 <tsaka__> Given this:
04:52:04 <tsaka__> pattern EC :: Exp Int -> Exp Int -> Exp (Int, Int); pattern EC a b <- (unlift -> (a, b))
04:52:36 <tsaka__> Which is a (working) way of pattern matching on a tuple inside a functor
04:53:20 <tsaka__> is there any way to overload tuple pattern matching, that is, so it can be pattern matched like "(a, b)" instead
04:53:45 <tsaka__> or maybe "<a, b>"
04:54:01 <[exa]> just fmap the pattern matching function to the functor?
04:55:52 <[exa]> btw what is the programming language of your sample?
04:56:36 <tsaka__> that is haskell.
04:56:57 <tsaka__> I don't know what you mean by your suggestion. Can you write it out?
04:57:56 <tsaka__> (its haskell with viewpatterns and patternsynonyms and ";" as newline)
05:02:29 --- mode: glguy set +v cloudmark
05:07:19 <OFN> Hello all, I am currently running Void Linux, and installing ghc via stack doesn't seem to work. Stack will happily setup any ghc version prior to version 8.x, but previous versions are not compatible with my set up
05:07:48 <OFN> I get "exitFailure 2" "raw command error: /usr/make install"; has anybody else had this issue?
05:08:52 <tdammers> is stack trying to build GHC from source here?
05:11:25 <cloudmark> When using the type constructor in `data` I can understand the relationship between the type and its values; look at the RHS of the type declaration.    e.g.   data Newbie a = Newbie' a  I'm finding it hard to understand how the (->) - in the function type - binds the function value since there are no Data constructors.  Given that the type of (->) does not have a Data constructor, when is the function as a value "created"?   Wha
05:12:45 <OFN> tdammers, if I understand you correctly, yes it is
05:13:16 <ggole> cloudmark: functions (any many other types) are built-in.
05:13:21 <ggole> *and
05:13:21 <ventonegro> cloudmark: When the function is bound to some variable, either at top level or locally
05:14:01 <cloudmark> What is the use of having type constructors without data constructors in practice? 
05:14:29 <ggole> You can have types for values that are not data types
05:14:53 <cloudmark> can you help me understand that perhaps with an example
05:15:19 <cloudmark> are they usually built in types?
05:15:23 <ventonegro> cloudmark: the `data` keyword is for declaring inductive, algebraic data types
05:15:26 <ggole> Well, think about how you would define Integer as a data type
05:15:35 <mnoonan> You could think of lambda (\) as the value constructor for ->
05:15:38 <cloudmark> aha so built in types, that I can understand
05:15:40 <ventonegro> cloudmark: Functions are another type of data
05:16:00 <ggole> You can't just say datatype Integer = 0 | 1 | -1 | 2 | -2 | ...
05:16:07 <ggole> Because that would take a bit too long.
05:16:31 <hpc> "a bit too long" :D
05:16:33 <ggole> So integral types are built-in
05:16:42 <cloudmark> but is there a benefit in defining a Type Constructors without any Data Constructors in your own code? 
05:17:14 <ventonegro> cloudmark: Well, there is Void
05:17:16 <hpc> cloudmark: the empty data type is usually called Void, and it's useful when you're doing type-level programming
05:17:38 <hpc> but relatively less useful normally because its only value is undefined
05:17:53 <hpc> (and the other various bottoms like error "foo")
05:18:34 <hpc> if you think about the algebra of data types (which is where "ADT" comes from)
05:18:36 <hpc> Void is 0
05:18:38 <hpc> () is 1
05:18:47 <hpc> Either is (+), tuples are (*)
05:18:56 <hpc> (a -> b) is (b ** a)
05:19:23 <hpc> the number corresponds to how many defined values inhabit the type
05:20:58 <cloudmark> Given the two operators + and * it feels that values should always be finite in the set of a type.  Or am I missing something? 
05:21:13 <geekosaur> also types without data constructors are useful as type-level "tags"
05:22:56 <ggole> cloudmark: datatypes are recursive in general
05:23:16 <ggole> So the set of values would be infinite
05:23:20 <cloudmark> ah ok so recursive datatypes can have infinite members 
05:23:31 <cloudmark> yup! dang I feel silly!
05:23:41 <cloudmark> Thanks for explaining 0, 1, + and *
05:34:01 --- mode: glguy set +v klarvilje
06:10:14 <noan> for those of you using docker and ci... assuming you build your haskell build inside a docker container, how do you run the tests? do you build a tests layer and copy over the needed binary, then have your CI run that image to do the tests prior to doing a push?
06:14:17 <OFN> Sorry for leaving earlier, I had an to deal with something IRL as soon as I asked the question
06:14:39 <OFN> I was having trouble installing and ghc version 8.x through stack
06:15:02 <OFN> Is anyone else having the same issue? I get exit failure 2 "Raw command: /usr/bin/make install" fails, running Void Linux
06:17:40 <cocreature> OFN: can you show us the full error message and the command you ran to get it?
06:20:17 <OFN> cocreature: I apologize, I am new to irc, what is the best way to show my error message?
06:20:23 <OFN> If I copy paste, will it keep the format?
06:21:25 <cocreature> use some pastebin site, e.g., the one linked in the topic and then post the link here
06:24:50 <OFN> Here you go cocreature: https://pastelink.net/h4dy
06:26:33 <cocreature> OFN: try "stack setup -v"
06:28:14 <OFN> cocreature: I still get the same error with "stack setup -v"
06:29:01 <cocreature> OFN: but you should get more output
06:29:29 <OFN> cocreature: except I get an extra "make[1]: *** [ghc.mk:1002: install_packages] Error 127" "make: *** [Makefile:51: install] Error 2"
06:29:39 <OFN> cocreature: I can post the entire output, but it is quite large
06:30:14 <cocreature> don’t worry about it being large, just show it :)
06:32:41 <OFN> cocreature: https://pastelink.net/h4e2
06:40:16 <cocreature> OFN: looks like it is selecting a bindist that expects libtinfo which you don’t appear to have. you can either find a way to get libtinfo on your system or maybe try playing around with ghc-build to see if one of the other bindists works on your system https://docs.haskellstack.org/en/stable/yaml_configuration/#ghc-build
06:45:34 <OFN> cocreature: Thank You for the help; my distro doesn't seem to have "libtinfo" as an available package, I'll see if I can build it myself
06:45:59 <cocreature> it’s usually part of ncurses
06:46:09 <cocreature> so maybe look for ncurses related packages
06:47:21 <OFN> cocreature: Well that was the odd thing, because I have ncurses6 installed, as well as ncurses6-devel; GHC installs fine when installing from my package manager, but not through stack
06:47:57 <cocreature> the bindist that stack selects for you was probably built on another distro that has a different setup wtr ncurses and libtinfo
06:48:22 <cocreature> you can always enable system-ghc if your distro provides the right version of ghc
06:48:26 <cocreature> or build it yourself
06:49:04 <OFN> cocreature: I think I'll try build it myself, see if I can get it to work
06:49:11 <OFN> cocreature: Thanks a lot for the help :)
06:49:19 <cocreature> you might also be able to get by by creating a symlink to the ncurses lib
06:49:39 <cocreature> so something like ln -s /usr/lib/libncurses… /usr/lib/libtinfo…
06:52:31 <OFN> cocreature: I have also tried using a symlink, it didn't work before
06:54:20 <OFN> cocreature: Thank You for your help, I have to go now though; I'll see if I can fix it ASAP
06:54:30 <cocreature> OFN: if it doesn’t help, the error message should at least be different so it would be helpful if you show us the new error message
06:55:19 <OFN> cocreature: Sounds good
06:55:40 <OFN> cocreature: Bye
06:55:44 <matheus23> Is there a way to configure the .cabal directory?
06:57:00 <matheus23> My issue is that using .gitlab-ci.yml can't cache the ~/.cabal (It seems to be one of its restrictions). However, I'd like to cache the .cabal/store so I don't rebuild tons of libraries again and again
06:57:12 <cocreature> matheus23: --store-path iirc
06:58:09 <cocreature> ah no --store-dir
06:58:10 <matheus23> cocreature: hmm cabal doesn't seem to recognize that path
06:58:11 <cocreature> close enough :)
06:58:42 <cocreature> that will at least work for ~/.cabal/store, it won’t change ~/.cabal/config but caching doesn’t seem as important for that
06:58:48 <matheus23> cabal new-build --store-dir=asdf doesn't seem to work for me? ôo
06:59:01 <matheus23> cocreature: I'm alright with 'only' caching store ;)
06:59:17 <cocreature> “doesn’t seem to work” as in throws an error or doesn’t change the directory?
06:59:41 <matheus23> throws an error. It seems I have to say: cabal --store-dir=... new-build, alright
06:59:48 <matheus23> cocreature: It works now, Thank you! :)
07:00:29 <dmwit> cabal's argument parsing is a mess.
07:02:06 <matheus23> dmwit: cabal's newstyle let me hope for it to be really nice, however, more and more things are bugging me again when using it
07:02:22 <matheus23> --enable-test was/is something very confusing for me
07:02:29 <matheus23> --enable-tests*
07:05:34 <dolio> Presumably that's because --store-dir is a global option, not a new-build specific option?
07:06:18 <dolio> I think a lot of programs with subcommands work that way.
07:07:03 <cocreature> wasn’t there something silly with the new-* argument parsing only supporting global options? iirc that’s why we ended up with the --haddock-for-hackage flag instead of having a --for-hackage flag that only applies to new-haddock
07:07:24 <dolio> Dunno.
07:11:25 <matheus23> Using --store-dir results in errors like these: cabal:
07:11:27 <matheus23> '/opt/ghc/8.4.3/bin/ghc-pkg' exited with an error:
07:11:29 <matheus23> ghc-pkg: cabal-store-cache/ghc-8.4.3/package.db:
07:11:31 <matheus23> getDirectoryContents:openDirStream: does not exist (No such file or directory)
07:11:44 <matheus23> I used --store-dir=cabal-store-cache
07:12:11 <matheus23> I executed cabal --store-dir=cabal-store-cache new-configure
07:12:19 <matheus23> then cabal --store-dir=cabal-store-cache new-build
07:13:00 <cocreature> maybe try an absolute path? not sure --store-dir with relative paths works
07:13:33 <cocreature> also you don’t need to run new-configure if you don’t have any arguments. new-configure is just for persisting things in cabal.project.local so you don’t need to repeat them in each invocation of new-build
07:13:38 <haasn> is there a function :: (a -> Bool) -> [a] -> Maybe (a, [a]) somewhere that "extracts" an element from a list based on some criteria?
07:13:41 <matheus23> Ah, it seems to be known https://github.com/haskell/cabal/issues/5485
07:13:51 <matheus23> cocreature: yeah this seems to be the issue
07:14:04 <haasn> f (< 0) [2,3,1,-5,-9,7] would return Just (-5, [2,3,1,-9,7])
07:14:33 <matheus23> cocreature: Thanks, I wanted to be safe with new-configure. Hoped it would provide the needed directory structure maybe, I'll remove it again
07:15:02 <cocreature> haasn: I don’t think there is something builtin but it’s easy to build it using span
07:15:58 <haasn> I guess in the spoecial case that the function is given as (== a) you can use some combination of \\ and elem instead
07:16:40 <haasn> (or `delete` rather than \\)
07:17:45 <c50a326> I've been looking at some stuff on type theory and it's all so abstract... I don't get how it can be applied... e.g. before this I am playing with parser combinators, let's say I want to do some parser combinators to parse SGML... how can I use "type theory" or "formal methods" or proof stuff or anything to aid with this?
07:17:59 <cocreature> haasn: I suppose deleteBy works but that just seems wrong :)
07:18:08 <matheus23> cocreature: absolute paths seem to work, awesome!
07:18:08 <cocreature> deleteBy is a weird function
07:18:30 <cocreature> why would you make deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a] instead of deleteBy :: (a -> Bool) -> [a] -> [a]
07:19:14 <lortabac> cocreature: IIRC a colleague of mine wrote his own deleteBy for this reason
07:19:49 <Taneb> cocreature: isn't that second one "filter . (. not)"?
07:20:06 <cocreature> Taneb: no it only deletes the first occurence
07:20:16 <Taneb> Oh, right
07:22:28 <lortabac> maybe the reason why it has this signature is for consistency with the other *By functions
07:24:23 <cocreature> call it deleteFirstMatching or something silly if you don’t want to call it deleteBy
07:24:36 <cocreature> but that type is just wrong :)
07:24:44 <lortabac> I agree
07:37:06 <dmwit> ?let zippers = go [] where go ls [] = []; go ls (r:rs) = (ls,r,rs) : go (r:ls) rs
07:37:07 <lambdabot>  Defined.
07:37:25 <dmwit> :t \p -> find p . zippers
07:37:27 <lambdabot> (([a], a, [a]) -> Bool) -> [a] -> Maybe ([a], a, [a])
07:37:33 <dmwit> ;h, no
07:37:45 <dmwit> :t \p -> find (\(_,v,_) -> p v) . zippers
07:37:46 <lambdabot> (t -> Bool) -> [t] -> Maybe ([t], t, [t])
07:38:46 <dmwit> (I really wish `zippers` existed somewhere central. I reach for it all the time.)
07:39:34 <dmwit> haasn: Anyway that was for you. =)
07:39:40 <haasn> I saw, thanks :)
07:40:39 <haasn> cocreature: alternatively get rid of deleteBy and make that the signature for delete
07:43:44 <dmwit> Neat, I had never considered how wrong the type of deleteBy is before.
07:44:20 --- mode: glguy set +v _sras_
07:46:35 --- mode: glguy set +v Darwin226
07:47:01 <Darwin226> Is there a way to determine is my function was called during the runtime or during template haskell execution?
07:48:13 --- mode: glguy set +v SrPx
07:48:29 <dmwit> `trace` for the former, `putStrLn` for the latter since you're already in an IO-y monad.
07:48:52 --- mode: glguy set -v SrPx
07:48:57 <dmwit> `trace` should really be considered just a debugging tool, though. Don't let it sneak through into production code.
07:50:07 <Darwin226> dmwit: Hmm, I don't get it. Can you explain
07:51:28 <dmwit> I can try. What don't you get?
07:52:21 <Darwin226> How do those two functions help me determine if my code is being ran during compile-time or during runtime
07:52:51 <Darwin226> Oh, I think I see where the confusion arose
07:52:59 <Darwin226> I want to differentiate between those two cases
07:53:28 <dmwit> % let didIRunThis | Debug.Trace.trace "yes" False = undefined | otherwise = () in ()
07:53:28 <yahb> dmwit: ()
07:53:34 <dmwit> % let didIRunThis | Debug.Trace.trace "yes" False = undefined | otherwise = () in didIRunThis
07:53:34 <yahb> dmwit: yes; ()
07:53:50 <dmwit> Ah, I see.
07:57:15 <Spaceman77> Wait, haskell can run at compile-time?
07:58:02 <haasn> Spaceman77: if your question is concerning the "trace" example above, that's not what's happening here
07:58:22 <Spaceman77> No, it was a general question
07:58:41 <haasn> Okay. Well the general answer is that haskell expressions can be evaluated at compile time
07:59:07 <haasn> But this is not really new, other languages do it too - your C compiler might turn int x = 3+5; into int x = 8; at compile time
07:59:31 <haasn> In fact, C compilers can also do it with pure inlinable function calls
07:59:36 <Spaceman77> Ah
07:59:47 <haasn> The main advantage haskell has here is that all haskell functions are pure
07:59:51 <Spaceman77> I guess what i wanted to ask is if haskell can do wacky-lisp stuff at compile time
08:00:02 <haasn> so the "pure, inlinable" restriction is a given
08:00:11 <haasn> Yes and no
08:00:41 <haasn> There's a haskell extension known as TemplateHaskell which can allow you to write haskell code to generate the haskell code you actually want at compile time
08:01:17 <haasn> that's the closest thing to lisp-style metaprogramming that haskell has
08:02:17 <haasn> The key thing to point out here is that TemplateHaskell uses a strictly typed ADT: to produce the code you want, you actually have to synthesize the ADT representation of the thing you want to compile
08:02:36 <haasn> whereas in lisp that distinction between code and data doesn't really exist
08:02:38 <haasn> oh he left :(
08:04:34 <dmwit> Darwin226: Perhaps this is dumb, but... maybe just pass a different Bool at compile-time than at runtime.
08:05:30 <Ariakenom> what's a cool haskell value?
08:06:25 <dmwit> rep :: (Bool -> a) -> Pair a a
08:06:41 <dmwit> uh, I mean ... -> Pair a, of course
08:06:53 <hexagoxel> Darwin226: System.Environment.getProgName gives "<interactive>" in repl, "ghc" in qRunIO and $PROG when compiled to $PROG.
08:07:10 <hexagoxel> so unless you name your executable "ghc" you are set.
08:07:38 <haasn> Ariakenom: 42 is a pretty cool haskell value
08:08:05 <hexagoxel> Darwin226: no promises regarding portability tested on linux.
08:08:06 * dmwit . o O ( Is "What's a cool Haskell value?" a good interview question? )
08:08:11 <Ariakenom> what do you like about rep?
08:08:13 <Ariakenom> 42 is nice
08:08:47 <haasn> (>>=) is also a pretty cool haskell value
08:08:50 <haasn> it's even in the logo!
08:08:53 --- mode: glguy set +v Tritlo_
08:08:59 <Ariakenom> strong argument there
08:09:25 <dmwit> higher-order, comes from a very abstract and yet useful class, really nails down the "functions are data" distinction, plus is a gateway drug to memoization
08:10:10 <Ariakenom> That's a lot of depth. Good interview answer
08:10:24 --- mode: glguy set -v Tritlo
08:10:40 <Tritlo> Anyone here familiar with Lens?
08:10:57 <haasn> Tritlo: which Lens?
08:11:07 <Ariakenom> the stabby kind
08:11:07 <haasn> a lot of people here are very familiar with the package `lens`
08:11:17 <dmwit> ?where justask
08:11:33 <dmwit> Hm, our bot friend is a bit slow today.
08:11:37 <Ariakenom> join :: Ask (Ask x) -> Ask x
08:11:43 <Tritlo> I'm looking for an operator for mtl that's basically `l <%~ mb = mb >>= (l %=)`
08:12:05 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
08:12:27 <Tritlo> i.e. it's the same as the `<~` operator, but uses the value already there as an argument instead of just replacing it.
08:12:53 <dmwit> :t \mb l -> mb >>= (l %=)
08:12:54 <haasn> are you talking about <%= ?
08:12:55 <lambdabot> MonadState s m => m (a -> b) -> ASetter s s a b -> m ()
08:13:22 <Tritlo> no, it should have type (a -> m b), not m (a -> b)
08:14:28 <haasn> MonadState s m => Setter s s a b -> (a -> m b) -> m b  like this?
08:14:38 <Tritlo> It's weird, since `<~` is there and `%=` is there, but this one is not (even though it seems like it follows the same pattern)
08:14:56 <haasn> <%= which combines those two pattersn exists, but it's (a -> b) -> m b
08:14:58 <haasn> not a -> m b
08:15:11 <Tritlo> hassn: yeah, that's the one
08:15:12 <haasn> :t modify
08:15:27 <Ariakenom> % :t modify
08:15:28 <yahb> Ariakenom: MonadState s m => (s -> s) -> m ()
08:15:45 * Ariakenom looks at watch
08:16:28 <elgoosy> hi, what does this mean: nix-shell -A shells.ghc? There's no shells.ghc file in dir. What does it do?
08:17:00 * Ariakenom taps watch to see if broken
08:17:20 <lambdabot> MonadState s m => (s -> s) -> m ()
08:24:49 <Tritlo> hmm, I'm probably thinking this wrong
08:28:24 <Tritlo> But the idea is that I want to zoom in on a value, monadically modify that value, and then replace the value with the modified value
08:29:22 <matheus23> Tritlo: have you seen this? http://www.well-typed.com/blog/2018/09/compositional-zooming/
08:30:22 <nshepperd> in 'MonadState s m => Setter s s a b -> (a -> m b) -> m b' what is supposed to happen if you also modify the state inside the modify action
08:30:57 <matheus23> at the very bottom of thearticle is a link to this module: 
08:30:59 <matheus23> http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Zoom.html
08:33:26 <noan> Anyone who works with building inside a docker context here know why this would fail? It builds locally without issues. https://travis-ci.org/DukkhaLess/DukkhaLessServer
08:34:55 <nshepperd> (also i don't think setters are sufficient for this? you need a lens to apply a functorial action to the value inside)
08:39:39 <Tritlo> hmmm
08:40:11 <Tritlo> another puzzle: can I go from `(a -> m b)` to `m (a -> b)`?
08:40:52 <nshepperd> nope
08:40:54 <cocreature> Tritlo: no, for the former, you can make the effects depend on a
08:40:58 <cocreature> for the latter you can’t
08:41:32 <Tritlo> Alright, then this lens probably just doesn't exist
08:47:08 <dmwit> Tritlo: Yes, sure, just call the function on every possible `a` input, and build a lookup table, then use that lookup table inside the resulting action.
08:47:26 <dmwit> Tritlo: But I bet you don't want to do that.
08:47:28 <Tritlo> dmwit: If only my functions were that total
08:47:37 <dmwit> If you do, then I've got a package for you that bundles this up in a nice interface. =)
08:48:25 <dmwit> :t sequence
08:48:27 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
08:48:40 <dmwit> (What if `t` were `b ->`?)
08:49:42 <cocreature> that brings up the good ol’ times where I was trying to figure out why we cannot have a Traversable instance for (->) r :)
08:49:52 <dmwit> We can and do. =)
08:50:18 <cocreature> huh?
08:50:21 <dmwit> http://hackage.haskell.org/package/universe-reverse-instances-1.0/docs/Data-Universe-Instances-Traversable.html
08:50:49 <nshepperd> :t \l f -> get >>= cloneLens l f >>= put
08:50:51 <lambdabot> MonadState s m => ALens s s a b -> (a -> m b) -> m ()
08:51:07 <dmwit> instance (Ord e, Finite e) => Traversable ((->) e)
08:51:09 <nshepperd> but this throws away any state changes made by f
08:51:16 <cocreature> right if you add more restrictions it can work out, I was specifically referring to (->) r without further constraints
08:51:20 <nshepperd> and also doesn't return the b
08:51:24 <dmwit> cocreature: Ah, right.
08:51:24 <Tritlo> What took me a while was to realize the difference between `(a -> m b) -> m (a -> b)` and `a -> m b -> m (a -> b)`
08:52:22 <Tritlo> nshepperd: thanks! I ned the state change to happen though.
08:52:26 <nshepperd> Zoom is a better solution for this sort of state stuff
08:53:19 <cocreature> just hope you don’t find yourself in a situation where you are trying to use Zoom with MonadState as opposed to a concrete state type :)
08:57:43 <dmwit> :t \l f -> get >>= f . (^.cloneLens l) >>= (cloneLens l.=)
08:57:44 <lambdabot> MonadState s m => ALens s s a a -> (a -> m a) -> m ()
08:58:10 <dmwit> does not throw away the modifications that `f` does
08:58:29 <nshepperd> if you need arbitrary MonadStates you can use 'newtype Zuum s b m a = Zuum {runZuum :: ALens' s b -> m a}'
08:58:48 <nshepperd> which is like Zoom but just overrides the MonadState instance instead of doing type family stuff
08:59:26 <dmwit> :t \l f -> gets (^.cloneLens l) >>= f >>= (cloneLens l.=) -- maybe more idiomatic
08:59:27 <nshepperd> instance MonadState s m => MonadState b (Zuum s b m) where { state f = Zuum $ \l -> state (cloneLens l f) }
08:59:27 <lambdabot> MonadState s m => ALens s s a a -> (a -> m a) -> m ()
09:01:32 <elgoosy> Hi, in a obelisk skeleton project's source file I see an expression this expression for example: 'elAttr "img" ("src" =: static @"obelisk.jpg") blank'. I have dante extension loaded in the buffer of this file, so I can use c-c,c-, to get info about names. However, I want to know what is and where it is defined the '=:' operator? How do I do that? 
09:03:24 <nshepperd> Zuum is interesting because if you feel like it you can use 'lift' to mess with the whole state inside your action
09:05:02 <dmwit> Doesn't it sort of defeat the "just run the view of the lens once and the set of the lens once" attraction of Zoom, though?
09:05:39 <dmwit> elgoosy: Hoogle or Hayoo might help. If not, consider trying hasktags and including the directory with obelisk's source in it.
09:05:45 <nshepperd> is that the main attraction of Zoom?
09:10:17 <cocreature> nshepperd: oh I like that! for some reason that never occured to me
09:14:26 --- mode: glguy set -v nh2
09:14:31 <Tritlo> thanks dmwit!
09:27:34 <nshepperd1> "devoid :: Over p f Void Void a b -- There is a field for every type in the Void. Very zen." Heh, hadn't seen this before
09:29:52 --- mode: glguy set +v malyono
10:06:11 <fweht> hi, i want to do an introductory university course on machine learning, they let us do the assignments in any languague of choice, id like to use haskell because i enjoy using it (only worked on combinatorical problems so far though), do you think that makes any sense?
10:06:47 <Clint> sure, why not
10:07:22 <liste> fweht: expect model training to be slower than the big ones
10:07:35 <liste> also GPU support may be lacking
10:08:23 <fweht> liste: thanks for the input.  i will check out whether were supposed to work on large data sets!
10:10:07 <liste> fweht: check out http://haskelldata.com/
10:10:21 <fweht> nice
10:14:04 <cocreature> fweht: it probably depends on how your course is structured. if you have to implement algorithms yourself then Haskell is probably a fine choice. if it’s more the “apply tensorflow/<insert other fancy lib here> to this dataset” you might have a hard time if there are no Haskell bindings for that lib
10:16:07 <fweht> cocreature: that sounds good, i dont think it will depend on some specific fancy libs
10:53:32 <dmwit> Huh? There are official tensorflow Haskell bindings.
10:53:57 <texasmynsted> I recall reading an article about best practices for Haskell but am not finding that one. I am looking for an opinionated haskell file header.
10:54:01 <dmwit> Well. There are tensorflow Haskell bindings hosted on the tensorflow github. Apparently they are "not an official Google product".
10:54:04 <dmwit> Whatever that means.
10:54:15 <texasmynsted> With things like {-# OPTIONS_GHC -Wall -Werror #-} and overloaded strings, perhaps a custom prelude, etc.
10:54:37 <texasmynsted> Anybody have a link or opinion on this?
10:58:16 --- mode: glguy set +v Boarders
10:59:18 --- mode: glguy set -v Boarders
11:00:33 <Boarders> does anyone know the easiest way to monoidally prepend using a lens, you can append with the operator (<>=)
11:01:11 <dmwit> :t Dual
11:01:13 <lambdabot> a -> Dual a
11:01:16 <dmwit> Boarders: ^
11:01:26 <dmwit> > Dual "abc" <> Dual "def"
11:01:28 <lambdabot>  Dual {getDual = "defabc"}
11:01:54 <Boarders> :(
11:01:59 <Boarders> too verbose
11:02:05 <Boarders> why not just  =<>
11:02:08 <glittershark> foo . _Wrapped @Dual <>= x
11:02:35 <Boarders> ok, well thank you
11:02:37 <glittershark> or 
11:02:49 <glittershark> foo . _Wrapping' Dual <>= x
11:02:54 <glittershark> if you don't want to use type applications
11:03:45 <dmwit> I mean.... you can define (=<>) yourself with this...
11:04:37 <cocreature> about 90% of the time when people complain about verbosity I have no idea why they are worried about having to type a few more characters
11:04:48 <glittershark> it's haskell lol
11:04:53 <texasmynsted> oh this is nice --> http://dev.stephendiehl.com/hask/#flags
11:04:55 <glittershark> it's already like one of the least verbose languages out there
11:05:09 <dmwit> glittershark: Let me introduce you to CJam... =)
11:07:04 <Boarders> cocreature: I am not at all worried about typing, I am worried about the next person who gets to the code and doesn't know that much about lenses
11:07:12 <glittershark> Dual isn't a lens thing
11:07:12 <Boarders> and now has to look up this newtype stuff and so on
11:07:17 <glittershark> Dual is in base
11:07:21 <Boarders> yes, I am well aware
11:07:22 <Boarders> ...
11:07:25 <cocreature> Boarders: right, so just stick to (%=) and don’t bother with <>= or with coming up for another operator
11:07:41 <glittershark> yeah I mean `foo %= (x <>)` is fine
11:07:46 <cocreature> eh the grammar in that sentence is broken but hopefully you get the idea
11:08:06 <cocreature> heck, I use lens a fair bit and I would have to look up what <>= does
11:08:28 <cocreature> whereas foo %= (x <>) isn’t really any longer but I know immediately what it does
11:08:42 <dmwit> You're worried about somebody who doesn't know much about lenses, yet you would be okay with expecting them to know the difference between (=<>) and (<>=)?
11:09:04 <monochrom> All first world problems. :)
11:09:31 <Boarders> surely you can guess what <>= does by analogy
11:09:50 <cocreature> I definitely cannot guess if <>= prepends or appends
11:09:53 <Boarders> but I think your suggestion is better cocreature
11:09:59 <Boarders> yeah good point
11:10:34 <dmwit> No, I can't guess, because the analogy I know for forming lens operators doesn't include rules about putting suffixes first.
11:10:44 <Boarders> ok thanks
11:10:54 <dmwit> Why would putting the suffix first flip the function being applied? Makes no sense.
11:11:20 <Boarders> your objection has been heard, sorry for asking
11:11:48 <cocreature> no need to apologize :)
11:14:04 --- mode: glguy set +v govno
11:15:00 <govno> How to understand monads in haskell?
11:15:57 <monochrom> Start from functor and then applicative.  Work out examples, ignore essay philosophy analogy fluffy talk.
11:16:26 <monochrom> Look for "typeclassopedia".
11:16:55 <[exa]> in soviet russia, monads learn you.
11:17:06 <koz_> Agreed with monochrom 100%. Typeclassopedia is here: https://wiki.haskell.org/Typeclassopedia
11:17:20 <monochrom> If you know how to answer "how to teach numbers to kids" then the same techniques apply.  For example no kids ask "what are numbers?" and even if they did you wouldn't answer.
11:18:19 <monochrom> Instead you only teach kids how to use, what laws to apply/obey, and "deal with it".
11:18:37 <dmwit> I also liked sigfpe's "You Could Have Invented Monads".
11:18:52 <[exa]> govno: is there something particular you struggle with?
11:19:01 <dmwit> ?where ychim
11:19:01 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
11:19:09 <realloc> is it me, or does Control.Concurrent.Async.race eat AsyncCancelled exceptions without rethrowing?
11:19:34 <dmwit> ?where aam is also good
11:19:35 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
11:20:06 <cocreature> and I thought aam stands for abstracting abstract machines
11:20:33 <monochrom> ychgtychimiaaychim = you could have guessed that "you could have invented monads" is acronymized to ychim. :)
11:21:10 <monochrom> I thought air-to-air missiles.  Sorry have been playing F117A for to long.
11:21:32 <monochrom> aah = acronyms are hard
11:23:05 <nshepperd> launchMissiles is the canonical monadic action so you're not far off
11:23:27 <monochrom> haha
11:25:54 <realloc> nvm, found the problem, i guess
11:33:19 <realloc> hmm what happens to a child thread created with async, if the parent does not wait and exit?
11:34:22 <realloc> I could be blind, but https://www.stackage.org/haddock/lts-12.12/async-2.2.1/Control-Concurrent-Async.html#v:async doesnt seem to say anything about it
11:34:50 <realloc> does that mean, that the behavior is undefined?
11:36:03 <govno> Left "Error 123" >> Right 1 >>= \x -> Right x   Why output is Left "Error 123"?
11:36:35 <cocreature> govno: because the Monad instance of Either shortcircuits on Left
11:36:47 <cocreature> Left x >>= … = Left x
11:37:51 <monochrom> realloc: Thread behaviour is more specified in the doc of Control.Concurrent.  async assumes knowledge on that.
11:39:09 <monochrom> The child thread goes on.
11:39:36 <cocreature> the only exception to that is the main thread
11:39:57 <cocreature> if you want your child thread to die use withAsync
11:43:56 <realloc> monochrom: cocreature: Thx. I read that about the main thread in Control.Concurrent, but I could not find that information about children and their grandchildren
11:45:48 <realloc> I've got a server thread which listens for connections and creates threads for each new one. I'd like to collect their Async handles. For this, I thought about using a TMChan to store the handles or a list within a TVar. What would you recommend?
11:49:30 <monochrom> I recommend first specifying what you will do with the bunch of one thousand Async handles.  For example will you want to lookup, if so lookup by what key?  Generally the same questions you ask before choosing a data structure.
11:50:08 <realloc> monochrom: I just want to cancel each of them, when the server thread receives a AsyncCancelled
11:50:31 <hexagoxel> IORef is sufficient for single, non-incremental consumer "channel" usage.
11:50:32 <monochrom> Sorry what is AsyncCancelled?
11:51:05 <realloc> the exception a thread receives, when canceled using Control.Concurrent.Async.cancel
11:51:36 <hexagoxel> (a list withing a IORef, that is)
11:52:38 <realloc> background information: When main receives a UserInterrupt exception (Ctrl-C) it will do some cleanup and cancel the server thread. And the server thread shall also cancel its children
11:52:45 <realloc> an
11:52:55 <monochrom> A linked list sufficients.  IORef of immutable list is fine with atomicModifyIORef' .
11:54:05 <monochrom> OTOH if you are already importing TVar, and nothing else makes you import IORef, then TVar is the same deal.
11:55:48 <realloc> monochrom: TVar it is. Thx
11:56:05 <monochrom> Just beware that comparing linked list vs array as data structures for "I just want to add and wholesale enumerate", linked list uses more memory than array.  Unfortunately Haskell doesn't have a cool story for growable array.
11:57:29 <davr0s> yikes, i'm finding curly braces offputting.. i spent too long in haskell and lisp
11:57:42 <tdammers> syntax, shmyntax
11:58:20 <monochrom> You can use curly braces in Haskell.  do { x <- xxx; let {b = f x; c = g x}; yyy b c; ...}
11:58:33 <yyy> monochrom, yes?
11:58:41 <yyy> you pinged me ... :D 
11:58:44 <monochrom> Sorry typo.
11:58:46 <tdammers> you can also use C without curly braces
11:58:51 <tdammers> #define BEGIN {
11:58:52 <yyy> monochrom, j/k mate :)
11:58:55 <tdammers> #define END }
11:59:07 <gentauro> tdammers: yes?
11:59:09 <tdammers> saw that in a sound blaster programming book from the early 1990s
11:59:11 <geekosaur> bourne dialect!
11:59:37 <monochrom> I think someone wrote a suite of C macros to make C look like Pascal.
11:59:39 <tdammers> author had a thing for pascal, so he had these two defines in all source samples
11:59:48 <gentauro> but you have to replace with BEGIN .. END everywhere right?
11:59:55 <gentauro> which makes it more verbose :P
12:00:04 <tdammers> yes, it does
12:00:39 <monochrom> I found Pascal's begin-end offputting and it is why when I learned C I found {} to be a relief.
12:01:44 <monochrom> Also I like "every statement ends with ;" as more uniform than "between every two statements you add ; and don't add anywhere else"
12:02:20 <monochrom> IOW "{ x; y; z; }" vs "begin x; y; z end" note no ; after z in Pascal, not allowed.
12:02:44 <monochrom> Similarly life would be simpler if Haskell allowed [1,2,3,]
12:03:10 <monochrom> The only reason intersperse and intercalate exist is because of that.
12:04:06 <gentauro> with the BEGIN / END, you turn C into OCaml :D
12:04:43 <monochrom> Well yeah there is a reason why I became a Haskell fan instead of an OCaml fan.
12:04:48 <lavalike> monochrom: how does the trailing , remove the need for the functions intersperse and intercalate?
12:05:32 <monochrom> I was exaggerating.
12:05:45 <lavalike> oops >_<
12:06:20 <monochrom> Or understatement.
12:06:22 <geekosaur> well, unless you're a neat freak :)(
12:06:24 <geekosaur> :)
12:07:41 <geekosaur> then again definitions there differ… hence comment about bourne, who thought algol 60 syntax was "neater" than C's so all his programs started with those BEGIN/END macros and other algol60-isms
12:08:20 <monochrom> Because suppose all natural languages such as English allowed you to go "I have apples, oranges, bananas,; their total count is 34,120,." and don't insist on "I have apples, oranges, bananas; their total count is 34,120." then you won't need intersperse and intercalate.
12:08:26 <unroute> > print "a" >> print "a"
12:08:28 <lambdabot>  <IO ()>
12:08:40 <unroute> > :t forever $ print "a" >> print "a"
12:08:42 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
12:09:00 <unroute> i forgot my haskell
12:09:15 <monochrom> lambdabot won't do I/O for you.
12:09:17 <geekosaur> lambdabot just wants":t"not "> :t"
12:09:30 <geekosaur> :t ()
12:09:32 <lambdabot> ()
12:11:12 <monochrom> begin-end is uglier because begin and end have different lengths and furthermore there is no symmetry to speak of in their geometry.
12:12:03 <unroute> i just wanted to know whether 'forever $ io1 >> io2 >> ..' was valid syntactically
12:12:28 <monochrom> Here:
12:12:33 <monochrom> :t forever $ print "a" >> print "a"
12:12:34 <lambdabot> IO b
12:12:35 <geekosaur> :t forever $ print "a" >> print "a"
12:12:36 <lambdabot> IO b
12:12:36 <monochrom> OK?
12:13:00 <monochrom> That will be cdn$10 thank you very much.
12:14:08 <monochrom> Actually why should the payee be the one saying "thank you"?  The payee is the payee because the payer is the one in need.
12:14:14 <monochrom> That will be cdn$10 you're very welcome.
12:21:00 <jle`> considering we're dealing in cdn, presumably both the payee and the payer would be saying "sorry"
12:23:02 <shapr> that's the currency I use to store data on a content distribution network?
12:23:21 <tdammers> it's theoretically a mutually beneficial transaction, so it should be more like 'that will be cdn$10, congratulations'
12:23:40 <tdammers> I'd assume so
12:23:43 <tdammers> CDN-dollars
12:24:02 <geekosaur> somewhere in here is a coment about nerds vs. social skills >.> (not that I have any business talking there)
12:24:13 <monochrom> haha jle`
12:24:56 <dmwit> I think just try them all. That will be cdn$10 than you're welcomulations.
12:25:06 <dmwit> s/than/thank/ dang
12:25:13 <monochrom> haha that's neat
12:25:36 <monochrom> thank you're welcomulationsorry
12:25:45 <unroute> can dyre handle stuff like sockets?
12:26:25 <unroute> nevermind.
12:26:41 <monochrom> Is dyre on hackage?
12:26:47 <geekosaur> yes
12:27:27 <monochrom> Does it reconfig by recompiling and execing the new exe?
12:27:37 <geekosaur> question was too vague but likely answer is no because OS level resources like file descriptors sdon['t persist across restarts withut special support
12:27:43 <geekosaur> and, yes
12:27:59 <shapr> would be cool to have a way to handle sockets across re-exec
12:28:00 <geekosaur> (alsomeans windows support would be "exciting")
12:28:14 <shapr> Wasn't dons' thesis on dynamic run-time reloading of Haskell programs?
12:28:24 <geekosaur> this is OS level stuff
12:28:41 <shapr> iirc, dons ended up with a simple stub and the real code was loaded at run time
12:28:49 <shapr> that would work if the stub could keep track of sockets
12:28:55 <monochrom> dons's is reloading of Haskell modules.
12:29:06 <geekosaur> best yopu can geenrally do there is mark the fd as no-close-on-exec, note file descriptor number, add extra parameer that takes that fd and constructs a new socket abstraction based on it
12:29:44 <monochrom> Yeah reload-module-but-the-module-is-90%-of-your-program can work.
12:29:53 <geekosaur> for mroe involved stuff it's worse, only sanbe way to handle a db connectionis close and reopen in new instance
12:30:32 <davr0s> tdammers ... dont, just dont.  BEGIN END is way more obtrusive
12:30:48 <davr0s> historical note. someone did try to actually push that on me once..
12:31:55 <geekosaur> you'd have loved the original bourne shell source code >.>
12:33:46 <monochrom> I have a crazy idea.  A language with C syntax (or close enough) but Algol semantics.  (What about CPP macros? See below.)
12:34:03 <monochrom> The CPP macro part has CPP macro syntax (or close enough) but Haskell semantics!
12:34:41 <davr0s> is there a stdlib way to initialize a [T;N] from a lambda expression called sequentially.. last time i was messing with haskell i did make some sort of 'list comprehension-esque' macro ,  i wonder what your vec![] does these days (but it's really a [T;N] i'm after..  )
12:34:59 <monochrom> Sorry what's [T;N]?
12:35:06 <davr0s> yikes wrong channel
12:35:12 <monochrom> haha OK
12:35:19 <davr0s> (rust fixed length array. c++ array<T,N> basically)
12:35:47 <davr0s> and see how i flipped 'haskell' and 'rust. YIKES.
12:36:00 <davr0s> freudian -esque slip
12:36:07 <davr0s> what have you done 
12:36:50 <monochrom> I do that all the time to Haskell and Java.  I write "public class C where".
12:44:18 <hexagoxel> is there an acme package that exposes System.IO with curried and extra-tuple arguments? getLine :: () -> IO String etc.
13:02:51 <hyperisco> Why might attoparsec not have been made as a transformer? My guess is due to inlining. If that is the reason, why does specialising for Identity not suffice?
13:03:03 <tsaka__> is there a function to run a monadic function fn at most N times, but stop if the function result of fn becomes Nothing? Either case return list of results.
13:03:31 <hyperisco> Does even Identity mess with inlining?
13:03:55 <hyperisco> tsaka__, look in monad loops
13:06:29 * nshepperd . o O (a language with Algol syntax but php semantics)
13:07:20 <monochrom> haha
13:10:56 --- mode: glguy set +v lambdamichael
13:14:16 <nsnc> #freejpaglier
13:17:07 <WarzoneCommand> can anyone reccomend a package for open-unions? preferrably something *fast*. I'm currently using CoRec from vinyl, but they are a bit clunky. 
13:20:46 <glittershark> I remember seeing something announced a few months ago that looked really good
13:21:10 <glittershark> but I can't remember what it was called
13:21:33 <glittershark> oh! https://github.com/patrickt/fastsum maybe
13:21:44 <WarzoneCommand> ah, I'll have a look :) 
13:24:53 <lambdamichael> Hi, does anyone know a term for the design pattern where an API uses Template Haskell/Generics to update everything based on a "core location" for the API, i.e. some class of API changes only need to occur in one place instead of scatted around the app?
13:35:01 --- mode: glguy set +v jakubd1
13:37:04 <jakubd1> hello, i am trying to build a package using stack on nixos and I get `hClose: resource exhausted (No space left on device)` on building the singleton dependency, I never experienced such a thing outside nixos, I know many haskellers use nix, any ideas? (there is enough disk space)
13:38:10 <jakubd1> or at least for the root partion
13:39:11 <ggVGc> sounds like you ran out of diskspace?
13:39:24 <ggVGc> jakubd1: maybe you ran out of /tmp?
13:40:02 <jakubd1> well might be, how can I tell (df -h shows bunch of Use% 0% 1% and only the root is 17%)
13:40:13 <cocreature> also for /tmp?
13:40:41 <jakubd1> cocreature: funny enough there is no entry for /tmp so it seems it should be sharing space with the rest of /
13:41:34 <cocreature> that sounds weird, /tmp is usuall a tmpfs
13:41:40 <cocreature> does it show up in "findmnt"?
13:42:31 <jakubd1> https://pastebin.com/jJAGCvRj
13:43:45 <jakubd1> cocreature: i never heard of `findmnt`, there is no /tmp, but /nix/store suprised me
13:43:54 <cocreature> oh right, I remember having changed tmp to actually be tmpfs because that’s weirdly not the default on nixos
13:47:19 <jakubd1> I am really at a loss here
13:50:13 <jakubd1> cocreature: root parition has 38G of free space, /tmp is on that partition, I don't really understand why I should change /tmp to tmpfs but would you say it could help? I also have 8G swap partition
13:51:11 <dukedave> @hoogle Functor f => f a -> (a->b) -> (a->c) -> f (b, c)
13:51:11 <lambdabot> Data.Functor.Foldable coelgot :: Functor f => ((a, f b) -> b) -> (a -> f a) -> a -> b
13:51:11 <lambdabot> Data.Functor.Foldable elgot :: Functor f => (f a -> a) -> (b -> Either a (f b)) -> b -> a
13:51:11 <lambdabot> Data.EventList.Relative.TimeTime zipWithTime :: (time0 -> time1 -> time2) -> (time0, [time0]) -> T time1 body -> T time2 body
13:51:32 <dukedave> ^ isn't that a thing? 
13:52:51 <greymalkin> Looking at https://hackage.haskell.org/package/uuid-aeson; dependencies list aeson < 1.1, but the .cabal file mentions no version. How was that dependency determined?
13:53:44 <sclv> There’s a revision
13:54:01 <sclv> You can see it in the cabal file from the “package description” link
13:54:33 <greymalkin> sclv: not if you download the tarball.
13:54:45 <sclv> Right
13:55:13 <sclv> revisions don't alter the tarball
13:55:21 <sclv> so the hash remains intact
13:55:29 <sclv> https://github.com/haskell-infra/hackage-trustees/blob/master/revisions-information.md
13:56:20 <greymalkin> Ah, I never knew about these.
13:56:26 <greymalkin> (obviously)
13:56:51 <sclv> yeah, its useful but a bit subtle
13:58:43 <koz_> % :t join bitraverse
13:58:43 <yahb> koz_: ; <interactive>:1:6: error:; * Variable not in scope: bitraverse :: m (m a); * Perhaps you meant one of these: `itraverse' (imported from Control.Lens), `traverse' (imported from Prelude), `gtraverse' (imported from Data.Data.Lens)
13:58:49 <koz_> Awww.
14:01:08 <cocreature> jackhill: no if /tmp isn’t full then tmpfs shouldn’t help
14:01:21 <cocreature> jackhill: might be helpful to run strace to see what call is actually failing
14:17:49 --- mode: glguy set +v fragamus_
14:18:21 <fragamus_> can anyone explain why Data.ByteString is not found by stack build
14:19:11 <lyxia> fragamus_: did you add bytestring as a dependency to your package
14:19:30 <lyxia> in yourpackage.cabal or package.yaml, not stack.yaml
14:19:41 <fragamus_> no... I assumed it was part of the standard stuff
14:22:18 <lyxia> fragamus_: even the standard library needs to be listed there, and you can browse its contents here https://hackage.haskell.org/package/base
14:23:30 <fragamus_> thank you lyxia
14:26:20 <glittershark> dukedave: that'd require Applicative
14:26:30 <glittershark> :t liftA2 (&&&)
14:26:31 <lambdabot> (Arrow a, Applicative f) => f (a b c) -> f (a b c') -> f (a b (c, c'))
14:27:34 <glittershark> stranth
14:30:54 <monochrom> Use a = (->) to get Applicative f => f (b -> c) -> f (b -> c') -> f (b -> (c,c'))
14:44:01 <bsima> "stack build" in a docker container keeps failing with a timeout
14:44:11 <bsima> anyone have strategies to fix this?
14:45:43 <monochrom> Is the timeout inflicted by docker?
14:46:23 <monochrom> Are you supposed to build inside a container?  As opposed to build outside, then containerize the built thing.
14:48:30 <oak> What causes the timeout?
14:48:44 <oak> or what is the thing that timeouts?
14:49:13 <bsima> yeah I gotta build inside a container to appease my coworkers
14:49:16 <monochrom> Yeah my question is "who imposes the limit" and oak's is "who is taking too longer".
14:49:44 <bsima> I think it's just running out of memory. Apparently 2GiB is default, which is not quite enough for most haskell programs :)
14:49:59 <bsima> I bumped to 4, should probably fix it
14:50:24 <monochrom> Yeah you need memory or you need 32-bit GHC.
14:50:47 --- mode: glguy set -qo $~a glguy
14:50:52 <bsima> It only failed with "Error 137" so I wasn't sure what was going on
14:50:57 <oak> I tried to ask whether it is docker build or docker run and what kind of error message you get from the stack and in which point of the build process
14:51:37 <bsima> It's "docker build" and "stack build --system-ghc"
14:51:47 <bsima> It fails when downloading/compiling dependencies
14:55:42 <lavalike> don't take it the wrong way but why build ghc?
14:56:13 <tathougies> presumably someone needs to build GHC so we could all use it?
14:57:22 <oak> Maybe you could also try to use -j1 with the stack build to use less parallelism if you want to use less memory
14:57:36 <hpc> being ahead of whatever binary distribution is easy to install otherwise
14:57:55 <hpc> ghc is THE compiler to build ahead on for features
14:59:52 <lavalike> reconciling a world where I want to appease coworkers and one where I need unreleased ghc features is hard for me, but there might be an intersection I'm not seeing
15:01:10 <bsima> oh I'm using the fpco/stack-build docker image, so it comes with the correct GHC version
15:01:13 <bsima> i'm not building it
15:14:23 <hexagoxel> when compiling without -threaded, what is numCapabilities?
15:17:27 <hexagoxel> hmm, 1 apparently. that is sane.
15:18:29 <hexagoxel> I don't get what hspec does when you set `configConcurrentJobs = Just 1`, but apparently it is not very useful.
15:31:59 <bb010g[m]> > 't' : "est"
15:32:00 <lambdabot>  "test"
15:33:30 <bb010g[m]> lambdabot doesn't seem to be running @pl queries in PM
15:33:54 <geekosaur> seems to work fro me?
15:34:32 <bb010g[m]> Oh, nevermind, for some reason I'm not set up with services
15:34:43 <tysonzero> Does anyone know how to list package versions in cabal new-build?
15:34:46 <hexagoxel> ah, it is not hspec fault. i just need the magic right invocation to pass the right RTS stuff when doing cabal test.
15:35:10 <tysonzero> I'm not sure what version cabal new-build is building with, but I need to know to build a freeze file of sorts, ghc-pkg list doesn't seem to have everything
15:35:43 <hexagoxel> is there any way to pass rtsopts that do not break for targets not compiled with -rtsopts?
15:36:21 <hexagoxel> is there a downside to just compiling everything with -rtsopts?
15:38:29 <hexagoxel> wait, -rtsopts is not the problem. How can i prevent the error i get when passing -N1 when compiling without -threaded?
15:40:05 <hexagoxel> "+RTS -N_feel_free_to_ignore1"
15:43:27 <hpc> the N stands for "nah"
15:44:17 <hpc> hexagoxel: does setNumCapabilities fail without -threaded?
15:44:33 <hpc> the nuclear option here might be making it a real program option
15:50:59 <hexagoxel> i will just compile all testsuites with -threaded.
15:51:25 <hexagoxel> hpc: it fails, but softly (prints to stderr, does not halt)
15:54:04 <hpc> ah
16:06:34 <dmwit> tysonzero: There is cabal new-freeze to make a freeze file for you, or check out dist-newstyle/plan.json
16:07:22 <dmwit> tysonzero: (And see the cabal-plan package for parsing the latter file.)
16:09:14 <dmwit> hexagoxel: You can use rtsSupportsBoundThreads to determine whether you were compiled with -threaded or not.
16:09:27 <dmwit> hexagoxel: (i.e. to choose whether to call setNumCapabilities or ignore a flag)
16:17:14 <hexagoxel> dmwit: yeah thanks; i think i have a functioning workaround now.
16:22:56 <davr0s> so with haskell's strict options and unboxed options.. could one implement,say, a UnrolledLinkList8  (2,4,8,16 variations perhaps) - would that give you a sequential, strictly evaluated small array-like container that is a single unit of garbage collection  (and then you could  experiment swapping those in , with code just generally written for passing generic sequences around).  is it even possible to use type system
16:22:57 <davr0s>  magic to make an list type that will select a variation chosen per element type (e.g.   MyList Float,   MyList Double   translating to UnrolledLinkList 16 and 8 respectively)
16:23:15 <davr0s> i suppose the answer 'just use vectors' might come up
16:31:49 <nshepperd> davr0s: data families?
16:32:07 <davr0s> not heard of that, shall i google..
16:34:06 <nshepperd> davr0s: check out Data.Vector.Unboxed in the vector package as well
16:58:00 <dmwit> davr0s: No, you can't make a parameterized, unpacked type. But for concrete types, yes; e.g. you could make an UnrolledLinkedListInt8 and an UnrolledLinkedListBool8 no problem.
17:19:16 <tysonzero> dmwit: Thanks!
17:21:25 <boj> is there a GHC flag one can turn on that will complain about  case a of; _ -> ...  and force a full pattern match?
17:23:53 <boj> it would be nice to try and compile a large code base and find places where data types weren't fully pattern matched on
17:24:27 <dmwit> Hm. I don't know of one. GHC's documentation has a page listing warnings and a full flag reference; you could poke through those if you're motivated enough.
17:24:54 <boj> yeah, i didn't see anything, but figured i'd ask in case i missed something obvious
17:26:44 <lyxia> boj: Maybe hlint can detect that
17:30:25 <boj> lyxia: ah right, thanks. will give that a shot
18:49:50 <blackbart> Hey. I'm trying to learn haskell. Curious if there is a way to do this. I want to represent a deck of cards. I can do rank = [ "2", "3
18:50:05 <blackbart> oops, prematurely hit enter
18:51:44 <blackbart> rank = [ "2", "3", "4", "10", "J", "Q", "A"] (skipped a couplel cuz whatever). I'm just wondering if there is some way to do something along the lines of [2..10, "J", "A"]. I know that doesn't work because items in a list can only be one type.
18:53:09 <blackbart> I tried playing with show but haven't been able to get it to work using that
18:53:31 <geekosaur> not with thatstyle. We'd probably define data Rank = R1 | R2 | (...) | RQ | RK | RA deriving Enum
18:53:55 <monochrom> Yeah minimize the use of strings because unstructured.
18:54:23 <geekosaur> the general syntax ou'd liek for enumeratiosn also doesn't exist; you can't simply drop a `..` into a general list, [x..y] is actally spcal syntax
18:54:31 <geekosaur> actually special syntax
18:54:43 <geekosaur> (it expands to (enumFromTo x y)
18:56:13 <monochrom> There are a handful of good ways, each with its strength and weakness. You will have to ask yourself "what will I actually do with this?" and choose wisely.  Nonetheless, string is not one of them.
18:56:20 <geekosaur> > [2..10,13] -- syntax error
18:56:22 <lambdabot>  <hint>:1:7: error: parse error on input ‘,’
18:57:16 <monochrom> Read this for why types matter: http://rea.tech/the-abject-failure-of-weak-typing/
18:58:17 <blackbart> I'm reading through LYAH and haven't gotten up to data yet, but I searched this briefly online and saw thats how others represented cards as well. I'm still curious if there's a shorthand. Any possibility of combinging them together as in [2..10] ++ ["J","Q"] but with somehow converting the items in the first list to String. I think I was able to do it with Char's, but the 10 card fucks that up (that 
18:58:23 <blackbart> one list item needs to be [Char] or String)
19:00:00 <monochrom> I don't know whether your progress in the book has got up to the two functions "map" and "show" yet.  Because down this road the shorthand will involve them.
19:02:38 <monochrom> Also I wouldn't trust Internet opinions.
19:03:40 <blackbart> I mean, I googled poker haskell and saw that most solutions used that 'data' keyword that I'm not familiar with yet
19:03:58 <monochrom> There are equal amounts of "why the Earth is flat" and "why the Earth is sphere" on the Internet.  What do you make of this?
19:06:48 <blackbart> I have walked to The Edge and saw
20:10:55 <anohigisavay> hi
20:11:15 <anohigisavay> :t epochTime
20:11:16 <lambdabot> error: Variable not in scope: epochTime
20:11:27 <anohigisavay> :m +System.Posix.Time
20:11:32 <anohigisavay> :t epochTime
20:11:34 <lambdabot> error: Variable not in scope: epochTime
20:11:45 <glguy> anohigisavay: Did you have a question?
20:11:51 <anohigisavay> i'm using this function to get the current timestamp
20:11:54 <glguy> You can play with lambdabot in a private window or use your local ghci
20:12:04 <anohigisavay> it's always nearly a minute slower than time.time() in python
20:12:52 <anohigisavay> ~70 secs slower
20:15:10 <anohigisavay> same thing with Data.Time.Clock.getCurrentTime
20:17:48 <glguy> which one matches the current system time?
20:21:28 <anohigisavay> glguy: sorry, the python time seems wrong
20:22:46 <anohigisavay> glguy: i was playing with an third-party api that requires a very precise timestamp parameter. i made the request with wreq and it was rejected. i thought it was time in haskell that was slower
20:25:22 <anohigisavay> glguy: i'm so sorry, my python terminal window was ssh'ed to my office and i forgot that
20:39:15 <jle`> no need to be sorry
20:39:33 <jle`> just pointing out a helpful tip :)
21:21:24 <boj> i am about to lose my mind here. can anyone see why this would not have an accompanying binding, even though it is defined down at 228? if i comment out the second function it works fine - https://gist.github.com/boj/b2c5cc9ffae83a7a81ffc44133e7d9dd
21:21:47 <boj> i have a dozen other files that look exactly like this. must be staring at it too long...
21:22:21 <glguy> boj: template haskell between the sig and def
21:22:40 <boj> oh man
21:22:52 <boj> this is why people hate TH
21:23:00 <boj> glguy: thanks
21:25:01 <glguy> Oh, I've been wondering why that was.
21:27:12 <boj> it was not obvious that TH defs in between would break that
21:27:45 <boj> i am admittedly speaking from the depths of frustration at the moment
21:30:38 --- mode: ChanServ set +o glguy
21:33:34 --- mode: glguy set -o glguy
21:57:41 <cocreature> does criterion have a builtin way to generate graphs that compare multiple implementations at different sizes? so let’s say I have two implementations A,B and I want to run them for size 10,100,1000,10000 and then see a graph with the size on the x axis and the time on the y axis (and ideally also error bars)
21:58:01 <cocreature> ofc I can use criterion to dump json and write my own postprocessing, I’m just wondering if I really have to :)
