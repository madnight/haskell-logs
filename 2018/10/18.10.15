00:00:00 <Axman6> (possibly a bit out of date, not sure)
00:00:07 <alp> https://haskell-servant.readthedocs.io/en/stable/tutorial/Client.html is up to date
00:00:15 <leifmetcalf> The API endpoints are like /query?foo=thing&bar=thing2
00:00:20 <Axman6> alp: thanks
00:00:26 <leifmetcalf> As opposed to /query/thing/thing2
00:00:40 <Axman6> alp: it'd be great if the servant docs had syntax highlighting :(
00:01:08 <jhu> cocreature: Ok, that's good enough for me. I was struggling with this for quite a while. The infinite lists make things... interesting. Thanks!
00:01:12 <alp> Axman6, they do on master: https://haskell-servant.readthedocs.io/en/latest/tutorial/Client.html (notice the 'latest' instead of 'stable' in the URL)
00:01:29 <alp> so it'll work for 'stabe' once we push a new release
00:01:32 <alp> stable*
00:01:59 <leifmetcalf> Any clean way of doing that?
00:02:30 <Axman6> leifmetcalf: that becomes an endpoint like "query" :> QueryParam "foo" Thing :> QueryParam "bar" Thing2 :> Get '[JSON] ResponseType, and with servant-client this will write for you the function with type Maybe Thing -> Maybe Thing2 -> ClientM ResponseType
00:03:40 <Axman6> leifmetcalf: Capture lets you get information from specific positions in the URL, QueryParam lets you get information from named parameters
00:03:57 <leifmetcalf> Right, but which query parameters are required depends on the value of the query params specified earlier.
00:04:08 <Axman6> (The order of QueryParams doesn't really matter)
00:04:31 <Axman6> That's an interesting usecase I haven't heard of before
00:04:36 <leifmetcalf> Here's the actual api: https://www.alphavantage.co/documentation/#time-series-data
00:05:51 <leifmetcalf> Depending on the value of ?function=, other params like ?series_type and ?to_symbol are required.
00:05:55 <Axman6> actually,newer versions of Servant let you specify whether query params are required
00:06:03 <cocreature> jhu: here’s one possible implementation which may or may not behave like you want https://gist.github.com/8fa04b0b3dbcbae97406e6b06a857e6b
00:07:31 <Axman6> do they have a swagger description of the API?
00:07:39 <leifmetcalf> Eh?
00:08:45 <Axman6> openapi, https://en.wikipedia.org/wiki/OpenAPI_Specification
00:08:54 <leifmetcalf> I don't think so
00:09:30 <Axman6> if that exists, it is possible to automatically generate the haskell library (bothe the client and a server)
00:11:11 <Axman6> so, the real question is how well do you want to describe the API. Servant can definitely be used to implement that API, with the constraints you want to enforce, but it would require writing a bit of code
00:13:51 <jhu> cocreature: That was fast! It seems to work for the integer test case. I will take a closer look at your code and evaluate it in my real project. Impressive. Gotta respect a line with 3 'sequence's, 3 'map's and a 'join.' Kudos.
00:15:21 <cocreature> jhu: that was just me playing type tetris until it compiled. there is probably a simpler way to get the same result :)
00:16:10 <ion> jhu: I suppose it would be a good idea to start with a simpler value such as [Right 1, Right 2, Left "", Right 3] and figure out a function that does what you want for that one. Once you have it, make the input more nested and figure out how to use your existing function with it.
00:16:36 <dminuoso> Mmm, how do you "close" a conduit?
00:19:00 <dminuoso> Specifically Id like to terminate a conduit from upstream.
00:19:11 <jhu> ion: There was a solution for even this more complicated case yesterday for finite lists, but that involved the use of sequence or traverse, and it did not play well with infinite lists. Hence this full-blown problem.
00:19:32 <c_wraith> dminuoso: just don't yield any more values.
00:20:28 <leifmetcalf> Axman6: How would that code work? I'm still stuck making the type for a queryparam with a known value
00:20:51 <Axman6> leifmetcalf: you end up with things which look like this: https://gist.github.com/axman6/0e9d2f8ca9acfb3f4b30ad483f148a7e (the data TIME_SERIES_INTRADAY = TIME_SERIES_INTRADAY is a bit of a hack to make sure that you provide akll the required and optional params for a given function)
00:21:41 <leifmetcalf> Ah right
00:22:16 <leifmetcalf> Thank you. Is there no syntax for anonymous types so you don't have to write a `data THING = THING` for every function?
00:22:18 <dminuoso> c_wraith: Well the thing is Im implementing SSH right now, so at any point the remote server might decide to close a channel prematurely. Not yielding more values would keep any `awaitForever` blocked.
00:22:46 <dminuoso> c_wraith: To me "not having a value right now" and "not having a value ever again" are two different things.
00:23:02 <Axman6> You'd need to define the data types for things like Itnerval, OutputSize etc, but the is the safe way to get what you want; there'll be a fair few data types you need to define up front, and make instances for things like ToHttpApiData for those types, but a lot of that will be reusable between the different API calls
00:24:16 <dminuoso> Perhaps the MonadState instance is what I want - just dont understand Conduit well enough to know what a stateful conduit means/is.
00:24:24 <c_wraith> dminuoso: well then don't have the producer keep running.
00:24:32 <Axman6> leifmetcalf: I don't know of a way to specify a flag with a known value, but it also wouldn't be too hard to write a combinator which does it, like KnownFlag "flagname" "FLAG_VALUE". there'd be a few classes to write instances for but those are easily cribbed from the ones which alrady exist in servant
00:25:01 <dminuoso> c_wraith: What do you mean? The issue is that I have to (essentially) do a blocking read on the socket, because I never know how much more data will come on the wire.
00:25:18 <dminuoso> So I have to indefinitely read (until the remote send closes the channel)
00:25:33 <c_wraith> So when the remote side closes the channel, stop looping
00:25:50 <leifmetcalf> Axman6: Alright, I think I'm good. Thank you!
00:26:17 <Axman6> leifmetcalf: good luck; servant is a truly awesome library, but you're working with a slightly off API so it might be a little harder than most
00:26:59 <dminuoso> c_wraith: My apologies, I still do not follow you completely.
00:27:11 <Axman6> s/off/odd/
00:27:32 <dminuoso> c_wraith: If the producer stops yielding, how would that be any different form the producer *blocking* on a read and not producing? The thing is, I want to communicate downwards that no more data is coming.
00:27:53 <dminuoso> So that the consumer can implement exceptions if he desires to do so.
00:28:10 <c_wraith> dminuoso: there's a difference between "not yielding but running" and "not running"
00:30:07 <dminuoso> c_wraith: You lost me completely. :(
00:30:34 <c_wraith> dminuoso: runConduit ((yield () >> yield () >> return ()) .| awaitForever (liftIO . prin
00:30:34 <c_wraith> t))
00:30:50 <c_wraith> err, sorry.  apparently my terminal copies line breaks that don't exist
00:31:49 <c_wraith> dminuoso: conduit is a kind of coroutine system.  An await in the consumer causes the producer to run until it either yields a value or terminates.
00:32:40 <c_wraith> dminuoso: if the producer terminates without yielding another value, the consumer knows that.
00:32:40 <dminuoso> c_wraith: Ohh.. so `returning` from upstream terminates the conduit as well?
00:33:26 <c_wraith> dminuoso: nah, you could take the (>> return ()) off the end
00:33:35 <dminuoso> c_wraith: Well yeah, same thing. ;)
00:33:42 <c_wraith> dminuoso: the important part is that there is no more code to run.
00:33:47 <c_wraith> dminuoso: it has completed
00:33:47 <dminuoso> c_wraith: Okay I see what you are getting it. :)
00:36:14 <c_wraith> dminuoso: even more fun:   runConduit ((yield () >> yield ()) .| (awaitForever (liftIO . print) >> liftIO (putStrLn "done!")))
00:37:21 <dminuoso> c_wraith: Ah yeah, conduit is the way to go for me - curious how much fun writing the attoparsec parser for conduit will be.
00:37:53 <c_wraith> I'm pretty sure there are already libraries to help use them together.
00:38:05 <dminuoso> conduit-extras has bits
00:43:28 --- mode: glguy set +v robstr
00:58:07 <redfish64> Is there any list like structure (with cons, uncons) that has a length function O(1)?
00:59:49 <yushyin> Data.Sequence maybe?
01:01:09 <redfish64> yushyin: That looks promising, thanks
01:01:20 <ion> (Integer, [a])
01:22:23 <robstr> When using TH, do I always need to define it in a different module ? Trying to modify `defaultoptions` from Aeson and receive `options is used in a top-level splice, quasi-quote, annotation, and must be imported, not defined locally` ?
01:27:59 <liste> robstr: yes, you need a different module
01:27:59 <akr> Hi there, is there some trick to use an unexported function inside ghci?
01:30:52 --- mode: glguy set +v [scrooge]
01:33:22 <robstr> liste: ty :)
01:41:51 <cocreature> akr: yes, see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#what-s-really-in-scope-at-the-prompt
01:42:30 <cocreature> however it only works for interpreted modules, so in particular it won’t work for modules from a library that you are using
01:43:12 <akr> okay, I see, that's reasonable
01:43:16 <akr> cocreature: thanks!
01:45:55 <kvda> How would you describe a data record that must have either key A or key B, but not both?
01:47:23 <cocreature> Either A B?
01:47:57 <kvda> No other option? cocreature 
01:48:18 <cocreature> not sure what you are looking for
01:48:31 <kvda> In Ocaml I believe you can do keyA: TypeA | TypeB
01:48:41 <cocreature> we don’t have anonymous sumtypes in Haskell
01:49:28 <cocreature> you can sort of emulate it with a lot of type-level trickery but in most cases it is not worth it
01:50:01 <kvda> Gotcha, thanks cocreature 
02:34:40 <fiatjaf> I've got a problem building my app with nix, how can I understand that?
02:35:07 <fiatjaf> Setup: Encountered missing dependencies: miso -any
02:35:33 <fiatjaf> is that the line that tells me the problem? the stuff is so verbose
02:35:39 <cocreature> sounds like your cabal file states that you depend on miso but your nix config doesn’t provide miso
02:35:52 <fiatjaf> my nix does indeed provide miso!
02:36:29 <fiatjaf> it's on executableHaskellDependes = [ ... miso ... ], just like all other dependencies
02:36:41 <cocreature> can you show us your cabal file and your nix config?
02:41:12 <fiatjaf> cocreature, https://www.pastery.net/wyadvg+tjfdde+eyrugw/
02:42:51 --- mode: glguy set +v javjarfer[m]
02:46:01 <javjarfer[m]> Does anyone knows why when I try to use the semigroup operator (<>) with Either I get:
02:46:02 <javjarfer[m]> Variable not in scope: (<>)
02:49:52 <cocreature> fiatjaf: try using callCabal2nix on the result you get from fetchFromGithub. so something like "result = pkgs.haskell.packages.ghcjs.callCabal2nix "miso" (pkgs.fetchFromGithub …) {}"
03:00:31 <fiatjaf> javjarfer[m], import Data.Monoid
03:00:41 <fiatjaf> ?
03:01:58 <robstr> I'm a bit lost using servant-client with a bearer token, especially defining the API and clients. I started with https://gist.github.com/rsoeldner/3bec6b57f285c14abbf2803f9eaf2514 can someone point me to an example or help here ?
03:03:19 <fiatjaf> cocreature, error: attribute 'miso-ghcjs' missing, at /home/fiatjaf/comp/piln/client/default.nix:16:10
03:05:09 <kvda> Any reason why a module import works fine in Main.hs but ghci complains about the same in another module?
03:06:10 <cocreature> fiatjaf: just use result directly not result.miso-ghcjs
03:07:30 <kvda> (I'm using cabal)
03:07:54 <deltasquared> here's me having to write a lua function to write JSON from an iterator, and have to pass in a "write output" function... god I miss lazy evaluation right now, it was easier to think about
03:08:08 <javjarfer[m]> fiatjaf: oh... thanks, I didn't needed for Maybe, and didn't notice that for Either
03:08:12 <deltasquared> welp, unless anyone knows a "ghclua" akin to ghcjs I guess I'm stuck :P
03:08:17 <javjarfer[m]> Now I get, • No instance for (Monoid (Either () [Char]))
03:08:37 <nkaretnikov> my package is structured like hoogle: it's a library that provides everything + an executable. i don't get why cabal build complains about missing-home-imports, suggesting to add library modules to other-modules, if I have my library in build-depends? somehow it still tries to rebuild the library when building the executable. any ideas?
03:11:17 <cocreature> nkaretnikov: sounds like you are importing a module in your executable that’s part of the library but not exposed
03:11:31 <cocreature> and you have setup the directories such that GHC will still find it
03:12:11 <nkaretnikov> cocreature: i think i've figured it out
03:12:33 <fiatjaf> javjarfer[m], that's because Either doesn't implement Monoid?
03:12:40 <fiatjaf> Maybe also doesn't, I think
03:12:53 <fiatjaf> but I'll stop answering you because I'm a beginner and know nothing about haskell
03:12:55 <nkaretnikov> cocreature: the main difference between my package and hoogle is that hoogle exposes one module that depends on a bunch of other-modules, which mine exposes everything. is there a way to make this configuration work still?
03:13:52 <javjarfer[m]> fiatjaf: in Data.Either instances I can see "Semigroup"
03:13:54 <cocreature> nkaretnikov: can you show us your cabal file and the error message?
03:14:03 <nkaretnikov> cocreature: no, sorry can't do that :(
03:14:31 <nkaretnikov> anyway, i'll see if i can do what hoogle does
03:14:37 <nkaretnikov> thanks!
03:14:48 <fiatjaf> cocreature, now I get this: https://www.pastery.net/bxthuw/raw/
03:15:51 <fiatjaf> javjarfer[m], I don't see that here
03:15:58 <cocreature> fiatjaf: doctests doesn’t work with ghcjs so you need to disable the tests for the packages that use it
03:15:59 <fiatjaf> jayjay[m], oh, wait, I was looking at an older version
03:16:08 <cocreature> which is at least http-types but probably others as well
03:16:09 <fiatjaf> maybe your versions are wrong there
03:17:07 <javjarfer[m]> fiatjaf: oooh come on... can believe I run into a versions issue, thanks you, I think could be that
03:17:59 <cocreature> javjarfer[m]: import <> from Data.Semigroup not Data.Monoid if you want to use the Semigroup instances
03:22:37 <javjarfer[m]> cocreature: uff, thanks, wasn't a version issue, was actually that
03:23:22 <fiatjaf> cocreature, how can I do that? :P
03:23:23 <cocreature> in newer versions that’s exported from the Prelude
03:24:00 <cocreature> fiatjaf: use an override "http-types = pkgs.haskell.lib.dontCheck super.http-types;"
03:28:29 <dminuoso> Is there an efficient way to express something like `(.*)foo` with attoparsec?
03:30:43 <dminuoso> I mean `manyTill anyChar end` would perform... horribly obviously.
03:33:27 <xsperry> several record improvements were suggested in the past years, and I was wondering if any of them were (or will be in near future) incorporated into ghc?
03:33:42 <fiatjaf> I'm reading every page on the internet looking for how to do that on nix, but still can't do it
03:35:47 <cocreature> fiatjaf: I have an example for how I setup ghcjs + nix projects at https://github.com/cocreature/nix-miso-template/blob/master/final/default.nix. it doesn’t use dontCheck (since that was apparently unnecessary) but it should show you where you can insert it
03:36:22 <fiatjaf> thank you very much!
03:38:18 <cocreature> fiatjaf: you probably also want to go through Gabriel’s tutorial. in particular https://github.com/Gabriel439/haskell-nix/tree/master/project1 shows how you can disable tests (it takes a slightly different approach but it should work just as well)
03:53:53 --- mode: glguy set +v govno
04:12:24 --- mode: glguy set +v asido
04:12:27 --- mode: glguy set -v asido
04:16:41 --- mode: glguy set +v Guest56
04:18:52 <asido> I am using `cabal install Graphalyze` and got the following error: https://bpaste.net/show/c4623d943bfc . I thought it's weird it tries to install 10 years old graphviz, so I try to install the version that is listed as the highest in Graphalyze dependencies, but got the following error: https://bpaste.net/show/82772a1eb331
04:19:35 <asido> I don't understand how that version of base cannot be resolved, when there are many versions available falling into the range 
04:20:15 <asido> Most of the listed version fall in the range base>=4 && <4.11
04:20:34 <hpc> do you have one of those versions?
04:20:40 <hpc> base is tied to ghc
04:23:25 <asido> hpc: I see. Means I got to downgrade ghc
04:48:56 --- mode: glguy set -v Peter_Storm_
04:52:14 <ClaudiusMaximus> asido: you could try   cabal install --allow-newer=base   and hope that it works
05:06:13 <Franciman> Hi
05:06:29 <Franciman> Is there any library to decode a bytestring by trying to detect its encoding?
05:06:40 <Franciman> e.g. utf8, latin1, etc..
05:06:58 <Franciman> Data.Text.Encoding doesn't handle BOM and also you need to know which format the bs is in
05:07:06 <Franciman> bytestring is in*
05:09:23 <quicksilver> Franciman: http://hackage.haskell.org/package/charsetdetect
05:09:31 <quicksilver> never used it, don't know how good it is
05:09:49 <quicksilver> but it uses the mozilla algorithm which is better than starting from scratch
05:12:28 <asido> How can it happen that I run `cabal install` and it fails with different error every time: https://bpaste.net/show/39d61ab219dd
05:13:23 <Franciman> thanks quicksilver 
05:13:35 <Franciman> I saw it
05:13:53 <Franciman> but how do I use a TextEncoding object?
05:18:34 <tdammers> having to guess the encoding is a shitty situation to be in
05:19:34 <quicksilver> call hSetEncoding, Franciman 
05:19:51 <quicksilver> and then just read from the handle as string or text
05:20:06 <quicksilver> what I can't tell you is whether or not it will then skip the BOM
05:20:22 <quicksilver> tdammers: sure, but a pretty common and realistic situation so not unreasonable to have tools for :)
05:24:23 <Franciman> quicksilver, ugh I have the ByteString in memory
05:24:26 <Franciman> well thanks
05:44:17 --- mode: glguy set +v himzo
05:52:23 <tdammers> quicksilver: I try to stay away from situations where this is an inevitable requirement
06:04:12 <__monty__> So you don't do any file IO whatsoever? : >
06:06:07 <tdammers> of course I do. I just prefer to arrange things such that I don't have to guess the encoding.
06:07:45 <__monty__> That's rarely an option though.
06:11:19 <tdammers> why not? most of the time, when you read from a file, you have some degree of control over whatever it is that wrote the file
06:11:44 <tdammers> could be you wrote the file yourself; then it's a matter of picking an encoding and just sticking with it
06:12:03 <tdammers> could be the file format is in your hands, in which case you just specify which encoding to use
06:12:13 <dminuoso> tdammers: Sometimes it's out of your hands.
06:12:39 <merijn> dminuoso: But in most cases where it's out of your hands it's still specified and fixed
06:12:44 <tdammers> sure, but again, IME the situations where that is truly the case are less common than you'd think
06:13:03 <dminuoso> merijn: Even then you might want to guess it regardless.
06:13:36 <merijn> dminuoso: If by "guess" you mean "just use utf8, unless you know it's something else", then sure...
06:14:08 <tdammers> using guesswork over specifications can even be a security risk
06:14:31 <tdammers> for example, IE used to have this heuristic that would override content-type headers based on detected body type
06:15:15 <tdammers> so you could trick it into executing a JPEG file as HTML, just by putting enough stuff that looks like HTML into the "remarks" field of the JPEG file structure
06:19:51 --- mode: glguy set +v metafity
06:20:04 <ClaudiusMaximus> you can put PHP into JPEG comments too...
06:24:17 <tdammers> yes, but that won't run inside IE
06:24:25 <tdammers> JavaScript however would
06:26:19 <oak> I think it is quite common technique in 1K and 4K browser demos to include JavaScript in PNG pixel values, the PNG then provides compression through zlib
06:31:40 <dminuoso> :t flip fix
06:31:41 <lambdabot> b -> ((b -> c) -> b -> c) -> c
06:32:21 <Ariakenom_> :t fix flip
06:32:22 <lambdabot> a -> a -> c
06:41:35 --- mode: glguy set +v Guest56
06:52:38 <dminuoso> That looks.. useful!
06:52:48 <dminuoso> :t flip
06:52:50 <lambdabot> (a -> b -> c) -> b -> a -> c
07:04:42 --- mode: ChanServ set +o Sigyn
07:05:29 <akr> :t fix
07:05:30 <lambdabot> (a -> a) -> a
07:10:30 <__monty__> tdammers: So you just choose to not handle files that were messed up by someone opening and saving them in a text editor for example? It's convenient to pretend things like that don't happen but they do.
07:11:20 <__monty__> Not saying it's not a valid way to deal with the problem. Just that it's not really *dealing* with the problem.
07:11:49 <Ariakenom_> Hey user! You messed up here.
07:11:55 <Ariakenom_> pls fix
07:19:09 <tdammers> if the file is in encoding A despite the fact that it's supposed to be in encoding B, then the right thing to do is to interpret it in encoding B, or error loudly if the input is malformed according to encoding B
07:19:19 <tdammers> it is then up to the user to deal with the error
07:19:45 <tdammers> unless of course you are writing some sort of detective tool whose purpose it is to help the user in fixing broken data
07:20:33 --- mode: glguy set +v dmwit
07:20:38 <dminuoso> Mmm. Is there a way to connect a parser onto a conduit that streams ByteString chunks (but not tokens)
07:21:23 <__monty__> tdammers: That's not much better than trying to find out the encoding though. The errors could be similarly obscure.
07:21:31 <dmwit> ?hackage conduit-extra dminuoso
07:21:31 <lambdabot> http://hackage.haskell.org/package/conduit-extra dminuoso
07:22:01 <dminuoso> dmwit: The Data.Conduit.Attoparsec appears to consume a conduit that produces *tokens*
07:22:48 <tdammers> __monty__: but at least the user is made aware of the fact that there is an error
07:22:53 <dmwit> Okay. What makes it appear that way to you?
07:23:14 * ski is reminded of implementations that automatically guess how to fix syntax errors in source
07:23:30 <tdammers> __monty__: the alternative is to guess, and probably guess wrong more often than not, and then the broken data gets sent down some pipeline and people complain about "weird characters" somewhere down the chain, probably in a place that isn't to blame
07:23:53 <dmwit> Or: what is a token? What are you planning to use for tokenizing?
07:23:56 <tdammers> fail early, fail loudly. best for everyone involved, usually.
07:24:31 <dmwit> I mean, the type doesn't look like it expects tokens to me. But I'm pretty green with conduit, so maybe I'm confusing things.
07:25:20 <maerwald> tdammers: no, fail late, but throw the whole stack trace at the users face xD (java style exception handling)
07:25:50 <tdammers> maerwald: a.k.a. "I didn't do it, here's 500 suspects, have fun"
07:25:58 <maerwald> lol
07:26:10 <__monty__> tdammers: Why can you report a useful error without guessing but not after guessing incorrectly? Seems counterintuitive.
07:26:45 * ski . o O ( <https://en.wikipedia.org/wiki/Postel's_law> ; "The Harmful Consequences of the Robustness Principle" by Martin Thompson in 2017-10-27 at <https://tools.ietf.org/html/draft-thomson-postel-was-wrong-02> )
07:26:48 <dminuoso> dmwit: The fact that the documentation says "Consume a stream of parsed tokens [...]" for conduitParser
07:27:06 <dmwit> dminuoso: Okay, sure, but conduitParser is not the only thing exported...
07:27:27 <cocreature> conduitParser works if you give it a stream of strict bytestrings
07:27:39 <cocreature> which seems exactly what I would expect a “ByteString chunk” to be
07:28:59 <dmwit> Also I suspect the documentation is wrong.
07:29:06 <dmwit> I think that was a thinko.
07:29:17 <dminuoso> Fair enough, trial time then. :)
07:29:20 <dmwit> More likely it means "*Produce* a stream of parsed tokens [...]"...
07:30:31 <tdammers> __monty__: you can of course report useful errors in both cases. but programs that take guesses instead of obeying are problematic, especially when the user knows better.
07:30:37 <dmwit> (and `conduitParser p` corresponds more or less to `parse (many p)`, I think, whereas `sinkParser p` corresponds roughly to `parse p`.)
07:30:38 <tdammers> better just do what was asked
07:30:56 <dmwit> This is my interpretation of the types and documentation given. It is not empirically backed.
07:31:02 <dmwit> Nor backed by looking at the source.
07:32:05 --- mode: glguy set +v Guest56
07:32:28 <cocreature> who needs empirical backing if you have types
07:33:13 * dmwit hands cocreature an Int -> Int
07:33:30 * ski . o O ( "Beware, I have only proved the implementation correct; I haven't tested it." )
07:34:26 * cocreature hands dmwit a type system with parametric polymorphism
07:34:45 * dmwit hands cocreature a forall {}. Int -> Int
07:34:45 <reygoch> I want to use Reader to log some text messages into a list which I would like to lazily print on the screen when executing Reader. However, will this work since I'm using `tell :: [Text] -> WriterT w m ()` which in the background appends the two lists instead of constructing a new one like `t1 : t2 : t3 : []`?
07:35:00 <matzy_> so i think i may have totally messed up install haskell (first-timer).  i was running arch, and installed the base packages from pacman (ghc, cabal, and some others), which was working fine since I'm just learning, but I went to install HIE and everything has gone to hell
07:35:11 <dmwit> cocreature: this is fun =)
07:35:33 <cocreature> :)
07:36:04 <Eduard_Munteanu> reygoch, consider [a] ++ [b] ++ [c] ++ ..., you can read it lazily.
07:36:07 <matzy_> it takes forever, my /tmp runs out of memory during installation so I have to change TMPDIR to my /home, then I left it running all night and it still didnt install correctly
07:36:07 <cocreature> reygoch: when you want to stream the results a streaming lib is usually a better choice than WriterT
07:36:55 <cocreature> reygoch: see http://www.haskellforall.com/2014/02/streaming-logging.html
07:37:04 <Eduard_Munteanu> > let as = ['a'] ++ as in as
07:37:07 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
07:37:40 <maerwald> matzy_: afair the official ghc on arch is kinda broken, just install ghc directly
07:38:15 <cocreature> the ghc packages on arch are fine, the problems start when you install more than ghc via pacman
07:38:44 --- mode: glguy set +v mnoonan_
07:38:51 <mnoonan_> matzy_: https://www.reddit.com/r/haskell/comments/8vu73f/haskell_on_arch/
07:40:35 <matzy_> mnoonan_: thanks, i had actually just finished reading that when i came here.  problem is, i get a lot of different suggestions.  should i install it directly like maerwald said (which i assume means compile and install globally), or use stack-static and use stack to manage everything?
07:40:49 <maerwald> stack is another layer of complexity
07:41:11 <__monty__> tdammers: Well, if a guess is needed at all apparently the user *doesn't* know better. A guess is only necessary if the file isn't in the expected encoding.
07:41:22 <matzy_> or is the pacman version of ghc fine, like cocreature was saying?  there's so much different info it's hard to know what's best/easiest
07:41:36 <maerwald> matzy_: ghc upstream already provides precompiled binaries you can install into any prefix
07:41:37 <yushyin> matzy_: I use separate ghc for development anyway, sucks if every ghc release breaks everything
07:41:52 <maerwald> you can also use ghcup to install/manage ghc
07:42:16 <maerwald> https://github.com/hasufell/ghcup
07:42:41 <yushyin> matzy_: and I let stack install ghc for me
07:42:57 <maerwald> well, then you have to use... stack xD
07:43:06 <cocreature> matzy_: note when say “more than ghc” I really mean it. the only things that you should install via pacman (if you want to use ghc from the arch repos) are ghc, and ghc-static (and their deps). no cabal or anything else
07:43:33 <reygoch> Eduard_Muntenau: how does that affect performance if I'm doing a lot of writing?
07:45:03 <reygoch> Eduard_Muntenau: what's bugging me here is that to add new entry I have to traverse the whole list again, right?
07:45:06 <matzy_> for some reason, stack seems simpler to me.  from what i understand, it pretty much acts like any other languages package manager, right?  except it also contains the compiler and manages installing/updating that
07:45:27 <matzy_> like npm or pip or something
07:45:30 <yushyin> yes and no
07:45:30 <maerwald> stack does 10 things at the same time, but is not very good at it
07:45:48 <matzy_> ok, cause i was advised away from stack when i first asked how to install
07:46:02 <tdammers> __monty__: no, if the file is not in the correct encoding, then displaying it wrong is better than guessing, usually. at most, I'd do the guessing, but ask the user explicitly whether they want us to apply the guessed encoding rather than the declared one
07:46:04 <matzy_> but then i ended up not getting more info and ended up with arch-system-install-hell
07:46:07 <reygoch> cocreature: Thanks, this is very informative.
07:46:25 <yushyin> matzy_: because different opinions exists
07:46:36 <matzy_> so what's the alternative to stack, that's better then?
07:46:39 <tdammers> __monty__: if the user says "as far as I know, this is UTF-8, but if you have a better idea, go ahead", then guessing is fine - but otherwise, it's better not to
07:46:42 <yushyin> matzy_: IMHO every way to install and manage ghc and deps of ghc sucks
07:46:47 <maerwald> matzy_: just use ghcup and cabal new-install
07:46:52 <tdammers> __monty__: if only because it'd lead to a proliferation of bad habits
07:47:27 <__monty__> tdammers: I think we're just thinking of different situations.
07:47:47 <__monty__> yushyin: Have you tried nix?
07:47:58 <matzy_> maerwald: ok i think i get what it does now.  definitely seems simple.  thanks!
07:48:10 <matzy_> but how will i install things like HIE with it?
07:48:22 <maerwald> sec
07:48:36 <yushyin> __monty__: i tried nixos but not nix for haskell/ghc
07:48:55 <__monty__> maerwald: Is ghcup an official tool?
07:49:24 <maerwald> https://github.com/haskell/haskell-ide-engine/issues/380
07:49:27 <maerwald> __monty__: no
07:50:14 <maerwald> matzy_: "cabal new-install hie hie-wrapper" works fine with cabal-install-2.4.0.0
07:50:49 <maerwald> see the comment in the thread
07:51:05 <matzy_> ok cool.  so cabal-install is like a better stack?  it functions as the haskell package manager?
07:51:16 <maerwald> it's the official tool
07:51:35 <matzy_> oh ok
07:52:17 <matzy_> so hcup will take care of different compiler versions needed by different programs, i still use the arch installs of ghc, ghc-libs and cabal-install, and then cabal handles the packages
07:52:40 <matzy_> is that right?
07:52:55 <maerwald> depends on your PATH
07:53:31 <matzy_> ghcup says to add it's bin to your path
07:53:36 <maerwald> yeah
07:54:05 <xsperry> stack has reproducible builds. it also downloads ghc, and allows different versions to coexist on the same system. cabal-install doesn't do either AFAIK
07:54:17 <xsperry> it managers ghc installations for you
07:54:30 <maerwald> xsperry: weird, i use cabal with different ghc versions just fine
07:54:42 <maerwald> and can say what ghc version I want for which project
07:54:59 <maerwald> and I can have reproducible builds with freeze files and proper .cabal dependencies
07:55:08 <xsperry> maerwald, does it do that for you, or you did all that manually?
07:55:20 <maerwald> xsperry: check the cabal new-* documentation
07:55:21 <xsperry> freeze files?
07:55:46 <maerwald> https://www.haskell.org/cabal/users-guide/nix-local-build.html#configuring-builds-with-cabal-project
07:55:48 <maerwald> yes
07:55:53 <maerwald> see link
07:56:32 <maerwald> the only interesting thing stack does for you these days is using stackage by default (cabal can do that too if you tell it to)
07:56:35 <xsperry> maerwald, I can give a complete newbie haskell project that is built stack, and he will be able to get it working, without even having haskell installed on the computer.
07:56:53 <maerwald> Ok
07:56:59 <maerwald> then do that ;)
07:57:09 <xsperry> maerwald, why would I do that, instead of just using stack?
07:57:17 <xsperry> what is the benefit?
07:57:18 <maerwald> I'm not convincing you
07:57:38 <maerwald> I just explained you the features you didn't know about cabal ;)
07:58:39 <maerwald> stack has a different usability approach, but feature wise there is nothing fantastic... in fact, it's more problematic (e.g. with profiling builds)
07:58:41 <tdammers> __monty__: maybe so. what is the situation, if I may ask?
07:59:43 <xsperry> maerwald, it seems like if you bend over backwards with cabal-install, do everything manually, and use stackage, you may get something that is close to stack
07:59:46 <maerwald> cabal new-* caches even different optimization levels
07:59:51 <xsperry> but.. why would you?
07:59:54 <maerwald> while in stack I get build failures and ghc panics if I mess around
08:00:00 <maerwald> you need that for development.
08:00:25 <maerwald> xsperry: you clearly haven't used cabal new-* much
08:01:13 <tdammers> right now, the only part of my workflow that stack does better than cabal new-* is copying binaries to a convenient location on my $PATH
08:01:39 <infinisil> Hey, question on MVars
08:01:40 <tdammers> cabal new-install is supposed to symlink build output into a directory of your choice, but that feature doesn't seem to work 100% yet
08:01:47 <__monty__> I didn't even have a complicated setup, yet I grew weary of stack and am now happily using cabal new-* with nix. Stack is not the amazing tool its proponents like to pretend it is ime.
08:01:48 <xsperry> maerwald, no I haven't, so if I got it wrong, it is because of your inability to explain its features
08:01:50 <maerwald> tdammers: 2.4.0.0?
08:01:55 <tdammers> maerwald: yes.
08:01:55 <maerwald> xsperry: lol
08:02:01 <infinisil> (I'll wait until there's less going on here)
08:02:05 <maerwald> xsperry: rtfm
08:02:08 <tdammers> maerwald: 2.2 apparently doesn't do it at all
08:02:12 <maerwald> tdammers: yeah
08:02:15 <xsperry> maerwald I don't care to. I am quite happy with stack
08:02:38 <__monty__> infinisil: Tbh, your question'd be a welcome distraction from the cabal v. stack stuff.
08:02:47 <cocreature> xsperry: if you’re happy with stack just keep using it :)
08:02:51 <tdammers> I'v also reached the point where stack's snapshot model starts being a proper hindrance to my workflow
08:03:08 <cocreature> infinisil: yes please! I’ll take mvars over yet another stack v cabal debate :)
08:03:21 <__monty__> tdammers: It's not in a haskell project but we generate file previews on the fly. Binary garbage is a pretty poor preview.
08:03:23 <maerwald> xsperry: sure, I just used both tools heavily
08:03:27 <infinisil> Hehe
08:03:35 <matzy_> as a newbie this is very fascinating, i'm learning a lot about both tools
08:03:47 <tdammers> __monty__: file previews of what? plain text files?
08:03:50 <maerwald> matzy_: basically, one is unix philosophy, the other not ;)
08:04:32 <__monty__> tdammers: All kinds of files. But encoding detection is mostly useful for plain text, yes.
08:05:02 <infinisil> Well I had a problem with monad-logger, I'm using runChanLoggingT and unChanLoggingT, which uses Control.Concurrent.Chan which uses an MVar underneath
08:05:36 <maerwald> tdammers: I completely abandoned stack, especially caching of profiling and optimization builds and being able to maintain a reasonable .cabal file and test against latest hackage is useful
08:05:39 <infinisil> The problem was that messages were sometimes dropped if the program quit right after a message was sent in it
08:05:57 <__monty__> maerwald: Just because stack handles ghc installs? I could see a compiler being handled just like any other dependency, it's not really a completely unrelated extra functionality.
08:06:05 <infinisil> But I guess I know what the problem is: The separate thread doing the printing to stdout gets terminated before it can log all messages when the main thread quits
08:06:16 <maerwald> __monty__: not just that, it even integrates hpack
08:06:21 <maerwald> and does other weird things
08:06:35 <cocreature> infinisil: right if the main thread dies all other threads die immediately. even if you have a finalizer on that thread (e.g. using bracket) it won’t be run
08:06:37 <matzy_> maerwald: so i should install cabal-install and ghc from the arch repos, right?
08:06:49 <maerwald> matzy_: I would install nothing from arch repos
08:07:09 <maerwald> stacks nix integration is broken for example
08:07:31 <infinisil> cocreature: I guess I'll use a TMVar to signal the separate thread that the log stream is done, or so
08:07:32 <cocreature> infinisil: that’s why in a lot of cases it is a bad idea to use "forkIO" directly to spawn new threads. you can instead use withAsync to ensure that finalizers are run
08:08:05 <matzy_> oh ok, i was reading the ghcup docs and i thought it said to install from the system repos, it really said to prepare your system for ghc installation
08:08:11 <infinisil> Well unChanLoggingT just logs from the channel forever, it never terminates
08:08:13 <maerwald> matzy_: ghcup can also install cabal-install, but currently only version 2.2.0.0, after that you can run "cabal new-install cabal-install"
08:08:19 <dminuoso> cocreature: Okay it seems it works nicely. Thanks.
08:08:23 <infinisil> So I don't think I can use any finalizers with that
08:08:34 <maerwald> 2.4.0.0 doesn't have official binaries yet
08:08:54 <maerwald> it will print information as you go
08:08:55 <infinisil> monad-logger should use a closeable channel implementation instead
08:09:01 <matzy_> maerwald: see though, the ghcup docs refer me to here: https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation/Linux, and under arch it says to install that stuff from pacman
08:09:01 <infinisil> imo
08:09:12 <maerwald> matzy_: no, that's only if you want to compile from source
08:09:37 <maerwald> "ghcup install 8.4.4" will fetch precompiled upstream binaries
08:09:51 <matzy_> ohhh ok i see, sorry
08:10:10 <matzy_> so i need to remove everything related to haskell from my system before doing this i assume
08:10:21 <maerwald> not really, but make sure your PATH is properly set up
08:10:43 <matzy_> the random ghc and cabal-install pacman installations wont mess anything up?
08:10:46 <cocreature> infinisil: iirc most of the API doesn’t depend on how you log so if you replace runChanLoggingT and unChanLoggingT (which are 3-line functions) you should be able to use whatever Chan implementation you want
08:11:06 <maerwald> matzy_: only if you used legacy "cabal install"
08:12:55 <matzy_> maerwald: i installed ghc, cabal-install, stack, haskell-haddock-library, alex, and happy from the arch repos when i initially setup haskell
08:13:16 <matzy_> basically everything in the haskell-platform but from pacman instead
08:13:40 <infinisil> cocreature: Yeah just noticed this too
08:13:59 <yushyin> matzy_: should not matter if you use ghcup properly
08:14:15 <matzy_> ok
08:14:17 <matzy_> thanks
08:14:42 <matzy_> as a C guy, it seems weird that there's a compiler in my system bin folder that will just magically be ignored
08:15:59 <yushyin> that’s why you setup PATH accordingly so the ghcup symlinked compiler is preferred
08:16:45 <shapr> I've had issues with ghcup, but I am glad it exists
08:16:51 <maerwald> shapr: which ones
08:17:18 <yushyin> matzy_: things I’ve done often even with C compiler for custom toolchains in different variants for embedded stuff
08:17:22 <matzy_> ahhh cause .local/bin comes first in PATH :)
08:17:22 <shapr> it failed to find libtb or something with a name like that, and then thought ghc was installed
08:17:29 --- mode: glguy set +v dmwit
08:17:39 <maerwald> shapr: libtinfo
08:17:48 <shapr> yeah, that's it
08:17:50 <maerwald> shapr: https://github.com/hasufell/ghcup#precompiled-binaries
08:17:55 <maerwald> mentioned in the README ;)
08:17:58 <maerwald> stack has the same problem
08:18:09 <runjutsu> hi, I would like to report a jew. Can someone point me to the proper authorities?
08:18:21 <maerwald> most distros provide compatibility symlinks
08:18:35 --- mode: ChanServ set +o shapr
08:18:37 <infinisil> Alright so I'll do this for logging: Use a closeable channel instead, start separate thread that logs this channel, when it closes signals this on an MVar. When the main thread is done it waits on the MVar until it terminates
08:18:40 --- kick: runjutsu was kicked by shapr (Kicked by shapr)
08:18:45 <infinisil> cocreature: ^
08:18:54 <hodapp> wtf.
08:19:10 <cocreature> infinisil: you are reinventing half of "async" here. I would recommend that you use withAsync instead
08:19:21 <infinisil> Hehe alright will do
08:19:35 <cocreature> getting this right in the presence of exceptions is somewhat tricky 
08:19:38 <greymalkin> infinisil: I use a chan with a "Maybe LogMessage" and just send "Nothing" when it's time to close; otherwise, the same.
08:20:22 <infinisil> greymalkin: Yeah, doesn't feel as clean as a closeable channel though
08:21:10 <greymalkin> ;-p I didn't know there is a closable channel.
08:21:34 <shapr> I hear Go got all of its channel stuff from Haskell :-P
08:21:49 <dminuoso> shapr: Except none of that annoying type stuff.
08:22:00 <shapr> too true
08:22:07 <infinisil> greymalkin: https://hackage.haskell.org/package/stm-chans-3.0.0.4/docs/Control-Concurrent-STM-TMChan.html
08:22:12 <infinisil> I'll probably use that one ^
08:22:33 <infinisil> Or rather https://hackage.haskell.org/package/stm-chans-3.0.0.4/docs/Control-Concurrent-STM-TMQueue.html
08:22:41 <infinisil> Because I don't need all the channel stuff, queue is enough
08:23:39 <infinisil> Although, the reads there return a Maybe
08:23:53 <infinisil> Oh I guess that has to be
08:24:14 <marxS> hi, im trying to create a functor instance of this datatype but it's not working: https://paste.ofcode.org/xcSVxZzPXJjZpfhx92zQPe
08:24:20 <marxS> could somebody please explain why without giving it away
08:24:49 <cocreature> marxS: you can’t pattern match on "g a"
08:25:02 <cocreature> what do you expect g and a to be bound to if the match succeeds?
08:25:02 <marxS> so how do i incorporate it?
08:25:16 <marxS> yeah thats my problem cocreature 
08:25:20 <cocreature> just because the type has the form "f a", doesn’t mean the constructor has the same form
08:25:27 <marxS> but idk how to express it otherwise
08:25:34 <cocreature> fmap f (LiftItOut a) = …
08:25:56 <marxS> = LiftItOut (fmap f a) ?
08:26:13 <cocreature> right
08:26:35 <greymalkin> infinisil: I was using a TChan at one point, but after much consideration, realized that anything STM is overkill for a logger and just went back to a standard Chan.
08:26:56 <lavalike> that requires `a` to be a functor
08:26:59 <greymalkin> I didn't need "log this message" to be retryable, basicall.
08:27:10 <infinisil> I use STM whenever possible, I don't think it's overkill :)
08:27:15 <matzy_> maerwald: so ghcup install continually fails for me, without any error messages
08:27:48 <matzy_> I get a curl error - "Failed writing body (8202 != 16375)"
08:27:57 <cocreature> as long as you’re not concerned about performance, STM doesn’t get in the way even if you don’t use its full power
08:28:10 <matzy_> like it's not getting all the data?  but i've tried two different ghc versions now - 8.4.3 and 8.4.4
08:28:30 <maerwald> matzy_: at which step?
08:28:46 <maerwald> sounds like something with your curl is wrong
08:28:48 <matzy_> ghcup install 8.4.3  and   ghcup install 8.4.4
08:29:04 <matzy_> yeah lemme try some other curl test
08:30:11 <matzy_> well i mean i installed ghcup via curl, i just realized
08:30:25 <maerwald> oh
08:30:39 <maerwald> just download it manually via your browser maybe
08:30:45 <matzy_> which ghc versions do you have installed with it?
08:30:51 <maerwald> ghcup show
08:31:04 <shapr> maerwald: do you know of a fix for the libtinfo on debian?
08:31:53 <maerwald> shapr: uh, debian shouldn't have this problem
08:32:19 <maerwald> https://packages.debian.org/stretch/libtinfo5
08:32:51 <shapr> I have that installed, same issue
08:33:08 <shapr> ohh, it wants libtinfo.so.6
08:33:16 <maerwald> ah
08:33:27 <maerwald> does it fetch the fedora ghc by any chance?
08:33:31 <matzy_> maerwald: no i meant what versions do you personally have installed via ghcup, so i could try installing one of those
08:33:38 <maerwald> 8.4.4
08:33:42 <matzy_> ah damn
08:34:00 <marxS> cocreature, when I try that I get error "No instance for (Functor g) arising from a use of ‘fmap’"
08:34:13 <marxS> idk why it thinks g is a functor lol
08:34:33 <maerwald> matzy_: you can open the script and replace DOWNLOADER and DOWNLOADER_OPTS to use wget...
08:34:36 <marxS> or g as arg to functor, sorry
08:34:41 <maerwald> maybe your curl has a problem
08:34:48 <cocreature> marxS: right, "LiftItOut f" is only a Functor if "f" is a functor
08:34:53 <shapr> maerwald: not sure, it says "Host platform inferred as: x86_64-unknown-linux"
08:34:56 <cocreature> marxS: so you need to add that constraint to your instance
08:35:01 <shapr> and that's for 8.4.4
08:36:34 <maerwald> shapr: that message is not from the script :o
08:36:44 <maerwald> probably from ghc install script
08:36:59 <matzy_> maerwald: ok a restart magically fixed it :D  but now it runs out of space while installing
08:37:07 <shapr> it is output from ghcup install "8.4.4"
08:37:09 <matzy_> what is it with haskell stuff installing and killing my /tmp
08:37:14 <shapr> so, output from the command, if nothing else
08:37:24 <maerwald> matzy_: ah, you're just out of space lol
08:37:42 <maerwald> shapr: you can run with "ghcup -v install 8.4.4"
08:37:43 <matzy_> df -h says otherwise lol
08:37:46 <maerwald> for verbosity
08:37:54 <maerwald> and see what it actually fetches
08:38:04 <matzy_> guess 2gb for /tmp isnt enough
08:38:20 <maerwald> yes, that might not be enough
08:39:03 --- mode: glguy set +v Guest56
08:41:15 <dmwit> marxS: "idk why it thinks g is a functor": It thinks that because you called `fmap` with the data contained in the `LiftItOut` constructor as its second argument, and `fmap` demands that its second argument's type be a `Functor` instance applied to some type.
08:42:11 <marxS> dmwit, ya i see, thanks
08:42:15 <maerwald> shapr: yes, it's the ghc that fails, not the script: https://github.com/commercialhaskell/stack/issues/4274#issuecomment-417751785
08:42:17 <maerwald> similar problem
08:42:50 <shapr> is ghcup installing stack binaries? je suis confuse
08:42:52 <tdammers> maerwald: yeah, the "test against current hackage" thing is kind of a big deal to me as well... especially since most of my projects are libraries, not programs
08:43:00 <maerwald> shapr: no, the official precompiled ghc tarballs
08:43:05 <maerwald> https://www.haskell.org/ghc/download_ghc_8_4_4.html#linux_x86_64
08:43:07 <shapr> or is stack installing ghc binaries? :-) ah
08:43:49 <maerwald> shapr: but... it's not raw binaries, it's an install script that makes sure prefixes work etc... and the configure script seems to do some (needless) toolchain checking
08:44:03 <shapr> I have a big pile of gcc versions installed, and probably gcc 4.9 is default gcc
08:44:10 <shapr> might not be needless
08:44:16 <maerwald> well, what is the full error?
08:46:12 <shapr> it's large, but the last line is "/home/serisson/.ghcup/ghc/8.4.4/lib/ghc-8.4.4/bin/ghc-pkg" --force --global-package-db "/home/serisson/.ghcup/ghc/8.4.4/lib/ghc-8.4.4/package.conf.d" update rts/dist/package.conf.install
08:46:19 <shapr> and that's where it fails with libtinfo
08:47:21 <maerwald> can you open a ticket?
08:47:35 <maerwald> what debian version etc
08:47:40 <maerwald> I might try tomorrow
08:48:19 <shapr> debian 9
08:49:01 <phadej> shapr: http://downloads.haskell.org/debian/
08:49:40 <shapr> phadej: I teach Haskell to roughly 5-10 new people a month, so I want ghcup to work
08:49:59 <phadej> ah, for cross-platform it might be better, yes
08:51:54 <maerwald> I'll try in a docker container
08:55:06 <maerwald> shapr: indeed, it fetches fedora binary
09:07:03 <sm> g'day all
09:07:24 <sm> another day, another libtinfo problem I see
09:09:18 <maerwald> yeah, apparently fedora packaged binaries don't work well on debian ;)
09:09:35 <maerwald> not surprising
09:09:52 <maerwald> but we are far away from statically linked GHC :P
09:16:14 <maerwald> shapr: https://github.com/hasufell/ghcup/commit/256d81eb13cfac65d8715f2d0f53637afcd8e6f5
09:16:17 <maerwald> that should fix it
09:23:07 --- mode: adams.freenode.net set +v billstclair
09:23:07 --- mode: adams.freenode.net set +v billstclair
09:23:07 --- mode: glguy set -v billstclair
09:23:49 --- mode: glguy set +v knupfer3
09:33:33 --- mode: glguy set +v skregas
09:34:10 --- mode: glguy set -v skregas
10:13:31 <matzy_> maerwald: you still there?  ghcup is great but i cannot get hie to install for the life of me, and i dont get how that guy got it using cabal new-install in that link you sent me
10:15:13 <cocreature> matzy_: what problems are you running into?
10:16:10 <matzy_> that guy said "cabal new-install hie hie-wrapper works just fine with the current cabal-install-2.4.0.0" but that command doesn't work at all for me.  in fact, i dont see an "hie" package on stackage or hackage
10:16:38 <matzy_> i also dont understand the rest of his message, where he describes the issue
10:16:52 <cocreature> “doesn’t work at all” is not a useful description of the problems you are running into
10:17:04 <matzy_> "unknown package: hie"
10:17:45 <cocreature> you need to clone the hie repo and run the command in that directory
10:17:51 <matzy_> his 'cabal new-install hie hie-wrapper' command doesnt work, even though i have the exact same cabal version as he mentioned.  do i need to do something per the rest of his comment?
10:18:05 <matzy_> ahhh ok, i thought it was pulling from hackage
10:19:52 <matzy_> cocreature: you're the best :D
10:23:28 * shapr hops cheerfully
10:35:38 <matzy_> cocreature: it got so far and then failed to build :( 
10:35:46 <matzy_> I got the message: "cabal: Failed to build ghc-exactprint-0.5.8.1 (which is required by exe:hie-wrapper from haskell-ide-engine-0.2.2.0 and exe:hie from haskell-ide-engine-0.2.2.0)."
10:36:16 <matzy_> could it be that i'm using 8.4.4 from ghcup?
10:36:33 <matzy_> should i try a different ghc version or would that not matter
10:38:24 <cocreature> the actual error is somewhere above that message
10:39:32 <govno> What actual tutorial to understand monads?
10:40:22 <mooper> https://youtu.be/yjmKMhJOJos -- this doesn't suck
10:40:30 <c_wraith> govno, I strongly recommend learning haskell instead.
10:40:55 <greymalkin> govno: I didn't "get" monads until I found myself writing one in Java.
10:40:58 <Cale> govno: How much Haskell do you know?
10:41:03 <greymalkin> Before that it was all confusion.
10:41:10 <Cale> Are you familiar with type classes?
10:41:12 <matzy_> cocreature: yeah it printed out tons of lines of code
10:41:52 <matzy_> "src-ghc86/Language/Haskell/GHC/ExactPrint/Annotater.hs:2569:44: error:     Not in scope: ‘GHC.unpackHDS’" "src-ghc86/Language/Haskell/GHC/ExactPrint/Annotater.hs:2569:44: error:     Not in scope: ‘GHC.unpackHDS’" "src-ghc86/Language/Haskell/GHC/ExactPrint/Annotater.hs:2569:44: error:     Not in scope: ‘GHC.unpackHDS’"
10:42:04 <govno> c_wraith: ok, i will be not learn haskell
10:43:05 <c_wraith> govno, did you demand a tutorial on iterators before learning Java?
10:43:06 <matzy_> i mean that package is on hackage, could i run 'cabal new-install ghc-exactprint-0.5.8.1" or would that not work with the HIE git repo?
10:43:48 <cocreature> matzy_: ah apparently ghc-exactprint is broken with 8.4.4 since it expects that anything > 8.4.3 is 8.6.x
10:43:56 <cocreature> ^ alanz 
10:43:58 <govno> c_wraith: you may be read a STL C++ library
10:44:12 <govno> with iterators classes
10:44:18 <matzy_> cocreature: ahhh ok
10:44:28 <cocreature> matzy_: unfortunately I don’t think there is a fix short of editing the cabal file
10:44:49 <c_wraith> govno, and how much did that help you before you understood what functions were?
10:45:08 <matzy_> cocreature: if i change my ghc version to 8.4.3 with ghcup shouldn't it work?
10:45:23 <cocreature> sure
10:45:36 <mooper> c_wraith: i was under the impression that govno already knew some haskell and was havving difficulty grasping what monads are/do
10:45:37 <cocreature> I was referring to there being no fix to make it work with 8.4.4
10:46:03 <c_wraith> govno, if you want to read source, https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#Monad
10:46:07 <matzy_> oh ok.  yeah i dont care what version i use, i just used 8.4.4 becuase of the guy who recommended ghcup
10:46:31 <c_wraith> govno, but it's sort of meaningless to just read source unless you understand what all the constructs in it do.
10:47:55 <c_wraith> govno, this is why I recommend learning haskell. once you understand higher-kinded type classes and Haskell's approach to polymorphism, "monad" becomes a simple (though pretty abstract) concept.
10:48:32 <c_wraith> govno, before that, you haven't built up a model to make sense of the abstractions it uses.
10:49:23 <dminuoso> govno: My personal recommendation to learning monads is: Don't think about it really. Just use (>>=) for each single instance - over time you will develop an intuition of the pattern it captures.
10:49:45 <dminuoso> It happens on its own really.
10:49:48 <govno> in C++ polymorphism realized by overloaded and virtual function
10:50:03 <greymalkin> govno: There are plenty of examples of monads in other languages; they should be about as easy to read as an STL class (which is to say, not very, unless you're quite steeped in template code)
10:51:26 <c_wraith> govno, in Haskell neither of those apply. instead you have parametric and bounded polymorphism.
10:51:55 <dminuoso> govno: How well do you understand `Semigroup`?
10:52:09 <hodapp> govno: err, doesn't C++ accomlish a form of parametric polymorphism via templates too?
10:52:14 <hodapp> as well as ad-hoc
10:52:29 <dminuoso> hodapp: its not really parametric polymorphism because of partial specializations.
10:52:43 <dminuoso> all theorems gone for free.
10:53:15 <hodapp> I was being charitable by calling a dumpster fire a form of heater.
10:53:18 <dminuoso> Heh
10:54:42 <dminuoso> On an unrelated matter, is there an elegant way to write: maybe (pure ()) (f >=> const go)
10:55:16 <govno> dminuoso: Semigroup is Monoid without neutral element
10:55:37 <dminuoso> govno: Right. Do you understand the *abstract* notion of a Semigroup well enough?
10:55:37 <lyxia> dminuoso: traverse_?
10:56:08 <govno> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#Semigroup
10:57:59 <govno> dminuoso: it is a set of elements with only one associative operation
10:59:12 <cocreature> :t \f go -> traverse_ (const go <=< f)
10:59:14 <lambdabot> (Monad f, Foldable t) => (a -> f b1) -> f b2 -> t a -> f ()
10:59:39 <__monty__> Not necessarily just one though, right?
11:00:51 <govno> with unboxed types I can write in procedure language
11:01:03 <dminuoso> lyxia: Yeah that would work I guess. I was really surprised about `instance Foldable Maybe`, never knew it existed. :)
11:01:35 * dminuoso never thought about folding some `Maybe a`
11:02:58 <c_wraith> dminuoso, it's just folding a short list.
11:03:42 <dminuoso> c_wraith: Oh yeah, it just never crossed my mind. When lyxia mentioned it, I was staring at that for a moment wondering "wait.. Maybe is a Foldable?" 
11:03:54 <dminuoso> This is kind of neat. :)
11:05:27 <dminuoso> > foldMap Sum (Just 2)
11:05:30 <lambdabot>  Sum {getSum = 2}
11:06:16 <dminuoso> > sum (Just 2)
11:06:19 <lambdabot>  2
11:07:17 <dminuoso> govno: My point really is, Semigroup captures a rather abstract notion. It doesn't really tell you *what* it does, but merely what laws it obeys.
11:08:12 <MarcelineVQ> > foldMap id (Sum (Sum 3)) -- hmm...
11:08:15 <lambdabot>  Sum {getSum = 3}
11:08:45 <MarcelineVQ> > (Sum (Sum 3)) >>= id
11:08:48 <lambdabot>  Sum {getSum = 3}
11:10:43 <dminuoso> > traverse id (Sum (Sum 8))
11:10:46 <lambdabot>  Sum {getSum = Sum {getSum = 8}}
11:13:21 <dminuoso> > traverse id (Product (Sum 8))
11:13:24 <lambdabot>  Sum {getSum = Product {getProduct = 8}}
11:14:23 <matzy_> cocreature: it FINALLY got to the very end, started to symlink hie, and then reported the following error:
11:14:40 <matzy_> GhcMod/Monad/Newtypes.hs:24:2: error:      fatal error: Compat.hs_h: No such file or directory             ^                | 24 |     |  ^ compilation terminated. `gcc' failed in phase `C pre-processor'. (Exit code: 1) cabal: Failed to build ghc-mod-core-5.9.0.0 (which is required by exe:hie-wrapper from haskell-ide-engine-0.2.2.0 and exe:hie from haskell-ide-engine-0.2.2.0).
11:21:40 <cocreature> matzy_: please show us the full output. that doesn’t look like the output from symlinking
11:21:54 <cocreature> (on some pastebin site)
11:21:55 --- mode: glguy set +v govno
11:22:27 <matzy_> yeah sorry that was more text than i thought.  https://pastebin.com/vY9zZxh7
11:23:11 <matzy_> i then got the idea to try and install ghc-mod myself from within the hie main directory.  i ran 'cabal new-install ghc-mod' and got basically the same error
11:24:38 <matzy_> i cant find anything about a similar error on google either.  nothing on that missing header file (Compat.hs_h) or on the build error
11:25:24 <cocreature> matzy_: just to be sure, is the header file in submodules/ghc-mode/core/GhcMod/Monad?
11:25:44 <matzy_> let me check
11:27:41 <matzy_> cocreature: yup it's there
11:28:58 <cocreature> not sure why it’s failing then. maybe it resolves the include path relative to the root directory and not relative to the file that it’s in
11:29:06 <cocreature> so you could try playing around with that path
11:31:02 <matzy_> is the include path in the cabal.project file?
11:31:25 <cocreature> no I mean the path in GhcMod/Monad/NewTypes
11:31:28 <cocreature> +.hs
11:33:23 <pikajude> is it possible to define a printfarg-style variadic function to construct HLists?
11:33:30 <shafox> When to use typeclasses ? 
11:34:55 <matzy_> cocreature: so near the top it has '#include "Compat.hs_h" - where is that supposed to be housed?
11:35:05 --- mode: glguy set +v testt
11:35:15 <matzy_> is that supposed to be installed on the system? would using ghcup be the problem?
11:35:17 <Cale> shafox: When you want to have a global convention about how certain operations are implemented on a per-type basis.
11:35:18 <cocreature> matzy_: try something like #include "GhcMod/Monad/NewTypes/Compat.hs_h"
11:36:18 <shafox> Cale: And those types I can decide upon like, for a MyType implement the add function as such and for OtherType implement add in different way ? 
11:36:31 <Cale> yeah
11:38:20 <Cale> shafox: A nice thing is that when you define stuff using type class polymorphic things, it can itself be polymorphic in the same way
11:38:41 <shafox> Nice 
11:38:45 <Cale> shafox: For example, because the sort function in Data.List only relies on the ordering operations specified in the Ord type class
11:38:47 <Cale> :t sort
11:38:49 <lambdabot> Ord a => [a] -> [a]
11:39:12 <Cale> It is also polymorphic, and works on any list whose elements have such an ordering operation
11:39:53 <Cale> Another nice thing is that instances can depend on other instances, so for example, there is an instance (Ord a) => Ord [a]
11:40:42 <Cale> which gives you an ordering on lists of any type which is ordered (and then lists of lists, and so on)
11:41:20 <Cale> This can end up removing quite a lot of boilerplate
11:42:11 <shafox> Is there any specific downside of using typeclasses ? As I skim through the StackOverflow questions there are answers which suggest not to use typeclasses extensibly. 
11:42:36 <govno> what is a best book to learn low level programming?
11:42:45 <Cale> Well, if you want to have and use multiple instances on the same type, then it might have been a better idea just to go with records of functions
11:43:03 <Cale> (which you can then pass around explicitly, and decide which one you really want in any situation)
11:43:39 <matzy_> cocreature: ok i navigated to the file directly, copied the $PWD, and pasted it in the #include......this better work
11:43:44 --- mode: glguy set +v leifmetcalf
11:44:26 <shafox> Cale: so start with records and then see if typeclass fit the problem set or not. 
11:45:08 --- mode: glguy set -v leifmetcalf
11:47:16 <Cale> shafox: That's reasonably safe. You could also start without polymorphism, and see where you really end up wanting it.
11:48:24 <Cale> There are a lot of good uses for type classes though -- I wouldn't be *too* scared to define one if it seems sensible.
11:49:04 <Cale> But it's also easy to go down a rabbit hole where you're defining all sorts of classes and they're not actually buying you all that much.
11:49:17 <matzy_> cocreature: you are the freaking best.  that was it!
11:49:24 <cocreature> if you do run into a problem with a typeclass you defined you can always go back :)
11:49:40 <matzy_> had to change it in every file that referenced that header, but it finally worked!  thank you so much for all the help, i really appreciate it
11:49:49 <Cale> If you only have one instance, it's hard to know that you have your class right though.
11:49:56 <cocreature> it’s not like you can only move from explicit record passing to typeclasses, the other direction is just as reasonable
11:50:02 <Cale> yep
11:50:32 <cocreature> matzy_: might be worth opening an issue for. that seems like a problem that should be fixed either in ghc-mod-core or cabal
11:51:07 <Cale> Also, if there are only a small number of instances per type, you can consider the option of using newtype wrappers to determine which instance you want.
11:51:14 <Athas> This is excellent news: https://blog.travis-ci.com/2018-10-11-windows-early-release
11:51:18 <matzy_> i was thinking about that, but wasn't sure which one to open the ticket with
11:51:29 <Athas> Now we just need somebody to package GHC/Stack for Travis on Windows!
11:51:41 <matzy_> i mean the repo was for HIE, but doesn't seem like that line of code should be wrong when the file is in the same dir
11:51:51 <matzy_> so i dont think it's their fault...werid
11:52:06 <cocreature> I would open the issue in hie and see if you get redirected by one of the devs
11:52:19 <shafox> Cale: and cocreature Mind giving a link or two for using typeclass in real world scenario ? 
11:53:14 <cocreature> the ones in base are pretty good examples of when you might want to use a typeclass, so Eq, Ord, Monoid, Functor, …
11:53:37 <cocreature> Athas: looks like that uses chocolatey which already has packaged ghc (not sure about stack)
11:54:06 <Athas> cocreature: can you also install older/specific versions of GHC through Chocolatey?
11:54:25 <Athas> (I know only just enough about Windows to keep an AppVeyor setup running.)
11:55:10 <cocreature> no idea, I know even less about windows :)
11:57:19 <sm> Athas: agreed, but why do we need special packaging for travis ?
11:57:57 <Cale> shafox: Another example would be that there are ToJSON and FromJSON classes in the aeson library, used to specify standard ways of turning various data structures into JSON.
11:57:57 <sm> just download stack with curl, as on appveyor
12:01:32 <Cale> shafox: You might also have a situation where you'd like to build forms for users to input different types of values, and select appropriate widgets based on the type of value required. It would often be sensible to define a type class for that.
12:07:57 <veverak> is there a way to have multiple definitions of '/' ?
12:08:03 <veverak> I have library that exports '/'
12:08:15 <veverak> and I would like to use it in same file as Prelude./
12:08:27 <cocreature> import one of them qualified
12:09:12 <veverak> that is ugly
12:09:18 <veverak> or, wait
12:09:44 <veverak> yeah, that would mean I have to use prefix? P./ ?
12:12:15 <matzy_> cocreature: if you're still there i have one more question
12:12:23 <boeingx> alternatively you can disable the automatical import of Prelude, but that means you cannot use many handy functions
12:12:26 <boeingx> https://wiki.haskell.org/No_import_of_Prelude
12:12:44 <veverak> I know, but I want to use the one from Prelude
12:13:35 <Cale> veverak: Maybe consider using another infix operator for whatever the other operation is
12:13:42 <Cale> you can make up anything you like
12:13:53 <matzy_> cocreature: since i did 'cabal new-install hie hie-wrapper' from that dir, do i still need to run make?  at the end of the cabal process it said it symlinked hie and hie-wrapper, but i can't find them as executables
12:14:34 <matzy_> is there a special way i run them since i installed with cabal new-install?
12:14:38 <veverak> Cale: but it's a dvision ...
12:14:42 <veverak> I mean, this kind of sucks
12:17:35 <matzy_> inspecting the haskell-ide-engine.cabal file, it does list two executables, hie and hie-wrapper.  but running them from the cl does nothing
12:19:14 <cocreature> matzy_: they should be in ~/.cabal/bin
12:19:24 <cocreature> presumably you haven’t added that to your PATH
12:19:46 <matzy_> cocreature: goddamn you are a one-stop shop of haskell solutions
12:20:24 <cocreature> maybe I should make that my twitter bio “your one-stop shop of haskell solutions”
12:20:46 <Cale> veverak: What kind of division though? If it doesn't already fit in with Fractional, it's probably different enough to deserve some sort of distinction notationally.
12:20:51 <davr0s> i'm back in Rust-land now
12:21:20 <davr0s> enjoyed my recent haskell excursion. rust certainly looks fugly by comparison but its a more practical balance for me
12:21:25 <matzy_> cocreature: no wait i do have that in my path.  maybe the symlink is wrong
12:22:14 <veverak> Cale: https://github.com/bjornbm/dimensional
12:22:23 <cocreature> matzy_: do you have hie in ~/.cabal/bin?
12:23:35 <matzy_> yes, but this is weird.  i had a problem originally where one of the libraries it needed to build didn't support ghc 8.4.4, so i used ghcup to switch to 8.4.3, which is my current (and was when i installed hie).  but the symlink for the binary is: ../store/ghc-8.4.4/haskell-ide-engine-0.2.2.0-45ae0c9133839161cbc343bc220662e2997d70112e6d14cd7f40acbb7bdad741/bin/hie
12:24:08 <cocreature> maybe try unlinking that and run new-install again
12:24:13 <matzy_> it  put it in ghc 8.4.4, even though i needed to switch to 8.4.3 to even install it correctly with cabal
12:24:18 <cocreature> not sure what it does if there is already a symlink
12:25:11 <pikajude> okay, so the hlist library already has a variadic hBuild function
12:25:19 <pikajude> but it doesn't compile with any new version of cabal :(
12:26:20 <matzy_> ok it installed it in the correct ghc dir (8.4.3), but it's just symlinked to the wrong one
12:29:30 <pikajude> is there a way to get ghci to show list types sanely
12:29:39 <pikajude> instead of ((':) * [Char] ...
12:38:48 <boeingx> I was told that in ghci the variable `it` always refers to the last (successful) result, but how could this be possible? Two expressions may even have different types
12:39:31 <Cale> It's possible because it rebinds what 'it' refers to every line.
12:40:03 <boeingx> Cale: but we cannot do this in general in Haskell right?
12:40:23 <Ariakenom> let it = 3 in let it = " hi" in it
12:40:32 <hyperisco> Ghci casts a long shadow.
12:40:33 <Cale> boeingx: Sure we can...
12:40:37 <Ariakenom> let it = 3 in (let it = " hi" in it)
12:40:49 <cocreature> Ariakenom: just add "instance Num [Char] " and now they can have the same type ;)
12:41:02 <Cale> boeingx: You'll get lots of warnings about shadowing, but you can do it.
12:41:04 <liste> what'd be the best way to do a "seekable" version of Writer?
12:41:07 <davean> boeingx: its not the same it
12:41:14 <davean> boeingx: a name is not the thing in it
12:41:20 <hyperisco> liste, what does it mean to be seekable?
12:41:37 <davean> boeingx: they're entirely seperate namings, hence shadowing.
12:41:55 <boeingx> Ariakenom: Nice example! I wan't aware it is shadowing
12:42:10 <liste> hyperisco: being able to change the append point and not always appending to the end
12:42:35 <boeingx> davean: You are right. I was misleading by dynamic typed languages :(
12:43:08 <liste> hyperisco: I guess I could "tell" (pos, val) pairs and sort them at the end
12:43:17 <hyperisco> liste, you can concatenate endomorphisms
12:43:38 --- mode: glguy set +v cherrybl0ss0m_
12:44:17 <hyperisco> liste, more detail: a function f :: A -> A can concatenate something to the start or end of an A, and endomorphisms are themselves concatenatable
12:44:27 <hyperisco> by function composition
12:44:43 <liste> start or end isn't enough :/
12:44:55 <hyperisco> > ((++ " world!") <> ("hello" ++)) ""
12:44:56 <liste> I need middle
12:44:57 <lambdabot>  " world!hello"
12:45:13 <hyperisco> liste, well that's fine, that can be an endomorphism too
12:46:05 <xsperry> davr0s, out of curiosity, what makes rust "uglier"? i dont know anything about it, but I may consider using it one day when I need something lower level
12:46:18 <hyperisco> I think I was using the reader
12:46:22 <hyperisco> > ((++ " world!") <> ("hello" ++)) "x"
12:46:25 <lambdabot>  "x world!hellox"
12:46:44 <davr0s> xsperry to be fair: it has a lot more upfront to specify, because it uses no GC. it's compile-time memory managemnt like C++, 
12:46:56 <liste> I basically need N "sections" of which I always append to the end
12:46:59 <davr0s> xsperry but with an added burden of proving safety with lifetime annotations
12:47:20 <hyperisco> how do you unEndo =\
12:47:24 <liste> and the number of sections can increase during execution
12:47:26 <hyperisco> @define unEndo (Endo f) = f
12:47:28 <lambdabot>  Defined.
12:47:40 <hyperisco> > unEndo (Endo (++ " world!") <> Endo ("hello" ++)) "x"
12:47:42 <lambdabot>  "hellox world!"
12:48:16 <davr0s> xsperry but besides that, there's some stylistic choices I find a bit frustrating, e.g. whilst they have the same type inference engine, they require *all* signatures tohave types, even the 'instances' of 'typeclasses' ('impl's of traits' ) , adn little 1 line helpers
12:48:53 <hyperisco> liste, what is the type you want to operate on?
12:48:55 <davr0s> and they have this naming convention "Type::new()" for constructors (insead of just makeType) , i find this really grates
12:49:15 <liste> hyperisco: a list/dlist of opcodes
12:49:16 <davr0s> but you can go against the grain and make smaller cnstructors if you like
12:49:38 <hyperisco> liste, okay, well you can write any  f :: Endo [a]
12:49:46 <davr0s> spoilt by haskells elegance but ultimately i want to spend more time in a no-GC language 
12:49:51 <davr0s> keep me on my toes
12:49:52 <hyperisco> which is to say you can write any  f :: [a] -> [a]
12:49:58 <liste> yeah
12:50:03 <liste> that's what I'm basically doing atm
12:50:24 <hyperisco> > unEndo (Endo reverse <> (++ "!")) "hello sailor"
12:50:28 <lambdabot>  error:
12:50:28 <lambdabot>      • Couldn't match expected type ‘Endo [Char]’
12:50:28 <lambdabot>                    with actual type ‘[Char] -> [Char]’
12:50:30 <hyperisco> > unEndo (Endo reverse <> Endo (++ "!")) "hello sailor"
12:50:33 <lambdabot>  "!rolias olleh"
12:50:58 <liste> but it's hard to "seek" to arbitrary points (=ends of sections) while `tell'ing
12:51:19 <hyperisco> well I don't know what seeking means
12:51:23 <hyperisco> maybe you want more than a writer
12:52:25 <liste> I guess I'll go with Writer [(SectionNumber, Opcode)] for now
12:52:38 <liste> and then sort by SectionNumber at the end
12:52:47 <hyperisco> why not a Map then?
12:52:55 <liste> could work too
12:53:00 <cocreature> State (Map SectionNumber Opcode)
12:53:04 <liste> I guess a Map would be better
12:53:10 <EvanR> a Map in a State
12:53:21 <EvanR> with a seek and a tell built on top
12:53:35 <liste> I already have a State
12:53:42 <liste> maybe I should ditch Writer?
12:53:58 <liste> (I have a RWS with () reader)
12:54:03 <hyperisco> if you just need to write then use Writer… if you need to read too then use State
12:55:28 <liste> I'm outputting bytecode, most of it is just linear `tell'ing but functions can be defined anywhere and their bytecode needs to be at the end
12:55:50 <cocreature> Writer is mostly good at producing spaceleaks
12:56:12 <hyperisco> call the Timelords!
12:57:54 <hyperisco> is State any different cocreature if you're never reading?
12:59:36 <cocreature> hyperisco: what do you mean by “never reading”? only calling “put”? that seems pretty useless
13:01:05 <pgiarrusso> cocreature: I heard a State you never read is the easiest non-space-leaky way to implement Writer?
13:01:33 <hyperisco> cocreature, I guess the mechanics of modify are quite different than tell
13:01:58 <kosmikus> pgiarrusso: if you define Writer via State, you'll modify the state (you're not replacing the state everytime you "tell")
13:02:13 <cocreature> I wouldn’t have thought of “modify” as “never read” but yeah you can implement Writer using that
13:02:24 <cocreature> which is pretty much what writer-cps-transformers does
13:02:31 <pgiarrusso> http://hackage.haskell.org/package/strict-writer
13:02:54 <cocreature> note that State (regardless of whether you use strict or lazy State) isn’t strict in the state so you still have a space leak if you use modify
13:04:47 <hyperisco> huh neat I rewrote a writer to cps just a few days ago but my motivation there was stack overflows… wasn't in Haskell
13:05:13 <pgiarrusso> wait this looks strict, no? http://hackage.haskell.org/package/writer-cps-transformers-0.1.1.4/docs/src/Control.Monad.Trans.Writer.CPS.Internal.html#writerT cocreature
13:05:48 <cocreature> pgiarrusso: sure, I didn’t say you can’t implement it strictly. I said that if you just use Control.Monad.State.Strict and modify it won’t be strict automatically
13:08:31 <pgiarrusso> ooooh right strict state is strict in the computation (tho that’s at least documented)
13:46:58 <matzy_> i have a question about cabal new-install.  does that install packages globally or locally?
13:47:22 <matzy_> does haskell do local (per-project) packages or is it just use system packages?
13:50:32 <davean> matzy_: It uses a local configuration. It can share packages globally
13:50:55 <davean> and then it symlinks th name to the result if the package contains executables.
13:52:46 <matzy_> ah ok, so that way you avoid the npm problem where you have 5 different installs of the same package
13:53:05 <fiatjaf> I can build by program successfully with nix-build, but running cabal configure inside a nix-shell fails
13:53:09 <fiatjaf> it can't find any dependencies
13:53:26 <fiatjaf> maybe I should ask this on #nixos
13:54:04 <davean> matzy_: yes, and its neither of the two options you proposed :)
13:54:56 <philippD> fiatjaf: how do you open the nix-shell?
13:55:14 <fiatjaf> nix-shell
13:55:22 <fiatjaf> I have a default.nix
13:55:33 <philippD> can you share the default.nix?
13:56:40 <fiatjaf> philippD, https://www.pastery.net/sdaftd+supvza/#sdaftd
13:57:26 <fiatjaf> philippD, actually, https://www.pastery.net/sdaftd+supvza+rqqtew/#rqqtew
14:01:25 <cocreature> fiatjaf: try nix-shell -A env
14:01:33 <cocreature> and cabal configure --ghcjs
14:02:52 <fiatjaf> now it is building stuff again
14:02:54 <fiatjaf> why?
14:03:06 <fiatjaf> and downloading packages from npm
14:04:12 <mizu_no_oto> matzy_: the previous thing was cabal sandboxes, which installed packages locally.  Previous to that Cabal did global installation. 
14:05:25 <fiatjaf> cocreature, whoa, that worked, it's amazing
14:05:27 <mizu_no_oto> The big problem with sandboxes was the amount of time you'd spend compiling libraries when you started up a new project
14:05:35 --- mode: glguy set +v reygoch
14:05:42 <reygoch> So, I have list of items to which I want to apply some operation from which I do not expect any result and processing of every element is independent from another. Can I just mapM_ forkIO over them?
14:06:40 --- mode: glguy set -v reygoch
14:06:42 <philippD> what is the actuall difference between calling nix-shell on env instead of the derivation itself? I have never encountered any difference
14:06:50 <c_wraith> reygoch, you could, but in general I'd use the async library for that - it has some additional niceties.
14:07:21 <reygoch> c_wraith: I'm just starting out simple and don't really have any experience with concurrency
14:07:51 <reygoch> c_wraith: ok, thanks I'll try the simple way first and upgrade to async later
14:08:07 <c_wraith> reygoch, in async, it's just https://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#v:mapConcurrently_
14:08:38 <reygoch> c_wraith: oh, cool
14:09:10 <mizu_no_oto> matzy_: cabal new-build was inspired by https://en.wikipedia.org/wiki/Nix_package_manager
14:09:14 <__monty__> philippD: It depends on your derivation. In this case you had to specify an attribute because otherwise nix-shell complained about missing default arguments.
14:09:14 <c_wraith> reygoch, in any case, proceed however makes you comfortable right now. :)
14:09:44 <reygoch> c_wraith: sure will ;)
14:14:35 <reygoch> c_wraith: just a quck question, I actually have a custom monad which supports IO actions but I'm not sure how I can use `mapConcurrently_` in it?
14:15:44 <c_wraith> reygoch, ah, yes. that will need some more work. but it's the same work needed to use forkIO
14:16:45 <reygoch> c_wraith: anything complicated or do I just have to do couple of lifts?
14:18:31 <c_wraith> reygoch, the problem is lift goes the wrong direction. you need something more complicated. what precisely is required depends on what monad you're working with and how you want to deal with loss of state across threads.
14:18:47 <reygoch> base control?
14:19:27 <c_wraith> that's an approach. it can handle it automatically, but it may not do exactly what you want. just depends.
14:20:44 <reygoch> c_wraith: hm.. I've found this https://hackage.haskell.org/package/lifted-async-0.10.0.3/docs/Control-Concurrent-Async-Lifted.html#v:mapConcurrently_
14:30:49 <fiatjaf> does Debug.Trace work on GHCJS?
14:31:05 <fiatjaf> apparently it isn't working here. is there an alternative?
14:33:23 <[exa]> fiatjaf: ghcjs can't do unsafePerformIO?
14:33:42 <fiatjaf> I don't know, it should
14:35:46 <fiatjaf> oh
14:35:51 <fiatjaf> I guess haskell is smarter than me
14:37:37 <fiatjaf> I was calling trace on a function whose return value wasn't used anywhere else, so haskell was simply ignoring it
14:38:19 <geekosaur> that's par for laziness
15:17:54 <royal_screwup21> I'm trying to figure out a data type for a graph that conforms to the following description: A graph is a set of vertices V and a bag of edges E, where all the vertices
15:17:54 <royal_screwup21> in the edges E are contained in V . A bag (sometimes called a multiset) is a structure like set except that
15:17:54 <royal_screwup21> duplicate elements are allowed.
15:19:09 <royal_screwup21> data Graph = [Vertex] [Edge] | Empty was my initial thought, except that I need a set and a multi set respectively. And I'd need to define Vertice and Edge
15:19:22 <Dynasty> royal_screwup21: is your graph acyclic?
15:20:43 <royal_screwup21> Dynasty: ah it isn't mentioned anywhere, but I think I'll assume yes for the sake of simplicity
15:21:06 <Dynasty> Multisets are only needed for multigraphs
15:21:31 <Dynasty> Otherwise you can use a set for the vertices and a set for the edges
15:22:14 <Dynasty> (an adjacency list)
15:22:22 <royal_screwup21> ah I see...tbh the question is in the context of deep embedding so I'm trying to play around with different data structures and see what works
15:23:19 <Dynasty> I would say that graphs in particular are hard to work with in functional languages
15:23:25 <Dynasty> Certainly much harder than trees
15:23:38 <Dynasty> I haven't found a solution for representing them that I really like
15:23:50 <Solonarv> you can always do data MultiGraph = MultiGraph { vertices :: IntSet, edges :: MultiSet Int } -- not entirely sure where you could find multiset though
15:23:53 <Dynasty> You should read the paper "Inductive Graphs and Functional Graph Algorithms"
15:24:16 <royal_screwup21> ah thanks for the pointers folks
15:25:05 <Dynasty> royal_screwup21: You should take a look at adjacency lists, adjacency matrices, and incidence matrices
15:25:17 <Dynasty> Those are three different ways of representing graphs
15:26:35 <royal_screwup21> ah yup, I'm familiar with those, especially with oop and imperative language...it's just I'm doing a course on language engineering and it turns out they're doing it all in haskell
15:27:07 <subttle> royal_screwup21: I didn't see it mentioned yet but algebraic-graphs is what's hot right now XD https://github.com/snowleopard/alga
15:27:39 <subttle> Not sure if you need the multiset though if that's an option but it's worth looking at
15:27:42 <royal_screwup21> right now we're doing some stuff with deep embedding which has mostly gone over my head, cuz it feels like I'm fighting two battles: one with haskell, another with theory of language engineering itself hehe
15:29:59 <philippD> couldn't you just define `type Graph a = [(a,a)]` and treat the type `a` itself as the set of edges? That should work as long as `a` is an instant of `Bounded` and `Enum`
15:30:18 <philippD> s/set of edges/set of vertices/
15:30:38 <philippD> s/instant/instance/
15:33:45 <royal_screwup21> philippD: if I'm not mistaken (and someone please correct me :) ), we can,  and that would be a form of shallow embedding
15:44:21 <matzy_> so while installing other things today with cabal new-install, i installed ghc-mod, and have an executable in the "~/.cabal/store/ghc-mod-5.9.0.0-{has}/bin/" folder, but it's not in the "~/.cabal/bin" folder.  does anyone know why or how this could be? 
15:44:36 <matzy_> *{hash}
15:45:18 <matzy_> sorry that path was "~/.cabal/store/ghc-8.4.3/ghc-mod-5.9.0.0-{has}/bin/" bc i'm using ghcup and have multiple versions
15:49:08 <matzy_> ok i fixed it.  don't understand why though.  i had installed it as a dependency for another package in a haskell app, so I just went back to that app's root folder and ran 'cabal new-install ghc-mod' and it went through like it was updating, said there was no need to update, and then symlinked ghc-mod and ghc-modi.  thing is, it actually worked
15:50:16 <matzy_> but now i have two questions.  1. why didnt that happen when it installed the package the first time (as a dependency)?  and more importantly, 2. why when I ran that in my ~/ folder did it not work (cabal new-install ghc-mod)?  if it's linking to a binary in a different folder, why do i need to run that command from the project?
15:51:01 <matzy_> if the package is a binary in a folder in PATH, then what's the difference where you install it from?  versioning?
15:53:19 --- mode: glguy set +v jackdk
15:53:19 --- mode: glguy set -v jackdk
15:59:47 <geekosaur> the whoel point of cabal new-* is compartmentalization, so if you have multiple versions of things they don't conflict with each other,. the install done as part of a normal build only installs in the compartment
16:00:13 <geekosaur> "new-install" might be better thought of as "exporting" from the compartment
16:01:13 <matzy_> geekosaur: ok thanks, that kinda makes sense.  so there is no such thing as installing a global cabal package?
16:02:02 <geekosaur> (and is in general a bad idea for ghc-mod in particular because it's very tightly tied to the ghc it was built with; you are better off adding a dependency on the version you need so the correct version becomes part of the compartment you're working in)
16:03:19 <geekosaur> there are ways to do it. it causes major problems, because ghc requires fairly tight control of versions. (internal source becomes part of the package, as inlining information in the .hi file, so even small differences between versions can cause problems)
16:03:47 <geekosaur> basically the same thing behind libz complaining f its header doesn't match its library version because so much of it is macros
16:05:02 <matzy_> ahhhh ok, thanks for explaining
16:05:08 <matzy_> so really, you never need global packages
16:06:28 <geekosaur> ideally the global package set is the ons that comewith ghc itself
16:07:05 <matzy_> ahhhhhh ok
16:07:10 <geekosaur> because they have to match ghc for ghc-api to work (which is also why ghc-mod needs to match since it's a wrapper for ghc-api)
16:07:59 <matzy_> it just seems weird, since i'm already using a versioning tool for ghc, that i would need to go into that package to install something globally
16:08:28 <matzy_> that package isn't what needs it, it's my text editor.  and i'm already locked into a specific ghc version thanks to ghcup
16:08:51 <matzy_> (well both that package and my text editor need it)
16:20:05 --- mode: glguy set +v sam2205
16:29:00 <dmwit> ?tell royal_screwup21 http://hackage.haskell.org/package/multiset for your direct question; http://hackage.haskell.org/package/fgl for the higher-level question
16:29:00 <lambdabot> Consider it noted.
16:30:55 * dmwit crosses his fingers that they don't come back with 22 or something as their suffix this time
17:04:37 --- mode: glguy set +v jkachmar
18:42:53 <dmj`> ghc bytecode compiler can’t handle unboxed tuples / sums?
18:52:43 <erikd> dmj`: use -fobject-code on the command line
18:55:14 <geekosaur> dmj, strictly speaking itcan handle them fine. the bytecode runtime will coredump if it sees one
18:55:23 <geekosaur> so the compiler's spiked
18:56:24 <dmj`> erikd: thanks, worked
18:57:09 <dmj`> geekosaur: why does the bytecode interpreter core dump at unboxed tuples?
18:57:59 <geekosaur> there's a deeply baked-in assumption that all tuples are boxed, and it's hard to get the boxed./unboxed satsu passed through to where it needs to be
18:58:04 <geekosaur> status
18:58:27 <geekosaur> so unboxed tuples lead to the guts treating a value as a pointer to a value *crash*
18:59:09 <geekosaur> every so often someoen hacking on ghc rediscovers this, goes to see how hard it woudl be to fix… a decade later, problem still there.
18:59:32 <geekosaur> suspect the bytecode runtime and possibly the bytecode spec has to be redesigned
19:00:02 <geekosaur> not that it has a formal spec, which is probably adecent part of whee the problem ame from
19:00:41 <dmj`> geekosaur: interesting, is this because the bytecode interpreter is used solely by ghci and that’s an unloved portion of the ghc code base?
19:00:49 <geekosaur> yes
19:01:19 <geekosaur> well, it;s use d by more than ghci (TH also uses it) but this isn't something you often run into with TH either
19:02:44 <geekosaur> although the ghc devs woudl love to see someone adopt it and give it some love, I suspect. it's just a rather large job for relatively little gain
19:03:16 <geekosaur> although these days TH might benefit from being able to optimize bytecode
19:04:32 <dmj`> geekosaur: ah, found the relative doc, https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/GHCi#Unboxedtuples:aRightRoyalSpannerInTheWorks
19:06:19 <geekosaur> such a lovely kluge
19:07:44 <dmj`> heh
19:08:15 <dmj`> geekosaur: I have wondered if GHC bytecode would be useful as an IR, for some target
19:08:24 <dmj`> http://hackage.haskell.org/package/ghc-8.6.1/docs/ByteCodeInstr.html
19:08:56 <geekosaur> the factthatthere's no load/save for it is kinda a warning that it wasn't designed for much in the way fo practicality
19:09:15 <geekosaur> otherwise, a neat ghci extension would be ability to save and reload "workspaces"
19:09:52 <dmj`> geekosaur: that would be fantastic.
19:19:25 <dmj`> geekosaur: wouldn’t be too crazy to translate one stack based machine into another...
19:19:36 <dmj`> geekosaur: I can’t even get -ddump-bcos to work :) 
19:20:25 <geekosaur> works for me, although my test was a ghc -e
19:20:58 <dmj`> geekosaur: nice, that works great
19:21:41 <dmj`> ghc Main.hs -ddump-bcos does nothing it seems
19:23:33 <geekosaur> well, it wouldn't. it's using the asm backend, not bco
19:23:50 --- mode: glguy set +v jkachmar
19:24:00 <dmj`> geekosaur: ah, of course 
19:25:13 <dmj`> but there is a -fbyte-code flag… hmm
19:31:20 --- mode: glguy set -v jkachmar
19:53:29 <lstdgtfp> I have a probably dumb question, but I can't find the answer
19:53:44 <lstdgtfp> if I have an Either monad stacked inside a State monad
19:53:51 <lstdgtfp> like so: StateT MyStateType (Either MyErrorType)
19:54:12 <lstdgtfp> and I want to apply a function to an error (if there is one)
19:54:15 <lstdgtfp> how do I do that?
19:57:26 <Axman6> leifmetcalf: Did you get anywhere with that Servant stuff?
19:58:39 <geekosaur> lstdgtfp, fmap (or Applicatives) gets you to the Either, then use the either function or a pattern match
20:01:03 <lstdgtfp> geekosaur: The type error I get makes it look like it is applying my function to the inner result type
20:01:20 <lstdgtfp> geekosaur: thanks! Another dumb question: What do I apply fmap to? A result of 
20:01:28 <lstdgtfp> oops, copy paste fail
20:01:38 <lstdgtfp> Couldn't match type ‘b’ with ‘Either Error c0’
20:01:53 <lstdgtfp> 'b' is the type parameter I'm using for the inner result type
20:02:26 <geekosaur> best paste stuff to gist.github.com or other reasonable paste site, and showing actual code would be helpful
20:03:35 <lstdgtfp> https://gist.github.com/jmikkola/81a6bbf724d3b4f0f32788fc83dd30a0
20:05:01 <lstdgtfp> I most likely got the structure of the monad wrong or something like that
20:07:33 <geekosaur> take a look at the type on line 8
20:08:24 <lstdgtfp> `StateT InferState (Either Error) (Either Error c0)` isn't something I actually want, is it?
20:11:06 <geekosaur> what's the type of mapLeft?
20:11:34 <lstdgtfp> mapLeft :: (a -> b) -> Either a c -> Either b c
20:12:27 <lstdgtfp> and WithLocations takes a second parameter, which is another Error value
20:13:01 <geekosaur> I'm suspicious of it inferringa n extra Either on both legs; it makes me think mapLeft already expects the StateT but gets an inferred Either there by fmap having removed it leaving the Either
20:13:59 <lstdgtfp> I'm using the StateT from the `mtl` package, if that maters
20:15:01 <lstdgtfp> I feel like the fmap call is trying to apply the function to just the right side of the Either, not the whole thing
20:15:58 <lstdgtfp> Now that I think about it, is what I'm trying to do even possible? 
20:16:01 <geekosaur> the fmap should only remove the StateT. and your interpretation doesn't explain why it thinks it's Either (Either Error) (Eitther Errr...)
20:16:12 <lstdgtfp> I think it would have short-circuited the computation if it hit a Left
20:17:37 <lstdgtfp> holy cow I just found it. Replacing fmap with mapStateT does the trick
20:17:54 <lstdgtfp> Thanks for your help!
20:18:02 <lstdgtfp> I would not have found that without first trying fmap
20:19:36 <Solonarv> there's a more generic version of mapStateT in mmorph, it's called hoist IIRC
20:22:03 <lstdgtfp> looking at the hackage page for mmorph
20:22:13 <lstdgtfp> that's a level of magic I'm not ready for yet :)
20:22:27 <lstdgtfp> I have more to learn before I can weild such tools
21:09:40 <leifmetcalf> Axman6: Yes! I have a working library! All I need to do now is to get JSON parsing to work, which shouldn't be too hard.
21:11:06 <Axman6> leifmetcalf: yeah there's native support for SON in servant using Aeson, and you can also support CSV using the servant-cassava package if you prefer
21:11:18 <Axman6> JSON too
21:12:09 <Axman6> leifmetcalf: If you'd like, I'd be happy to take a look and see if there's any improvement you could make; I'm curious to see how it turns out as it's a bit of an addball API
21:14:41 <leifmetcalf> Ah, It's really messy atm, let me clean it up first. There are some obvious changes that I should make.
21:26:48 <leifmetcalf> Axman6: Here: https://gitlab.com/leifmetcalf/alpha-vantage
21:27:39 <leifmetcalf> I've only implemented two endpoints(?) so far, and it returns plain text. Mostly this was just me poking servant a lot.
21:28:04 <Axman6> Looks good (Looks familliar ;)
21:28:42 <leifmetcalf> Is there a generally agreed-on way to split code into modules?
21:29:29 <Axman6> not really, it depends on the app (it'll vary much more between apps than it varies between libraries in my experience)
21:30:48 <Axman6> I was thinking that to make life a little simpler, you could implement your own servant combinator for functions, so you dfon't need to invent new datatypes which don't actually do anything; You'd end up being able to write Function "TIME_SERIES_INTRADAY" :> Opt "foo" Thing :> ...
21:32:40 <Axman6> the HasServer instance for Function would use the Symbol to fill in the function query param
21:32:58 <Axman6> This isn't necessary mut might make the code a little prettier
21:34:50 <leifmetcalf> Ohhh is HasServer/HasClient where the behaviours of servant combinators is defined
21:35:39 <leifmetcalf> I was looking at the definition of queryparam to see how I would make one and it just said `data QueryParam' (mods :: [*]) (sym :: Symbol) (a :: *)`
21:37:51 <c_wraith> leifmetcalf: so you can't make one.  It only exists as a type
21:39:15 <leifmetcalf> Yeah, but then how does `client` make a function out of it
21:39:26 <leifmetcalf> I'm guessing with Typeable
21:39:53 <c_wraith> classes are the only way to write functions from types to values.
21:40:03 <c_wraith> But it probably isn't Typeable.
21:40:11 <c_wraith> It probably has some more direct class
21:41:44 <c_wraith> leifmetcalf: looks like it's just the HasClient class
21:42:36 <c_wraith> leifmetcalf: https://hackage.haskell.org/package/servant-client-core-0.14/docs/src/Servant.Client.Core.Internal.HasClient.html#line-432
21:50:28 <leifmetcalf> Axman6: I get what you mean with `Function` now, I'll start writing it. Thank you again!
22:13:28 <Axman6> leifmetcalf: It'd be nice to have a StaticParam :: Symbol -> Symbol -> * which lets you write things like Function = StaticParam "function" as part of servant
22:16:27 <Axman6> (I can imagine there's plenty of cases where it would be good to specify pparameters which don't change in the type system so youy don't need to write it in the code
22:17:50 --- mode: glguy set +v robstr
22:20:47 <robstr> Morning, is it possible to parse directly this directly into `[Account]`, currently getting "Error in $: expected [a], encountered Object" ? https://gist.github.com/rsoeldner/eb2f6aa3fea0ef80d9311cea13332f6c
22:29:05 <Axman6> newtype Accounts = Accounts [Account]; instance FromJSON Accounts where parseJSON = withObject "Accounts" \o -> Accounts <$> o .: "
22:29:16 <Axman6> newtype Accounts = Accounts [Account]; instance FromJSON Accounts where parseJSON = withObject "Accounts" \o -> Accounts <$> o .: "accounts" ?
22:29:19 <jackdk> that's because the derived `FromJSON` instance for `[Account]` will expect a JSON array in the text
22:52:59 <robstr> Axman6: jackdk thank you :)
23:02:00 <infinisil> Okay hold on
23:02:52 <infinisil> Yesterday I asked about logging on a separate thread, then it can happen that the main thread exits before the separate thread logged everymessage
23:03:19 <infinisil> Using monad-logger's Chan's (from Control.Concurrent.Chan)
23:04:03 <infinisil> So, I'm just realizing that the real solution here is that logging operations should be synchronous!
23:04:03 <Axman6> Am I still holding on?
23:04:11 * boj holds on
23:04:42 <infinisil> When `logDebugN "foo" "bar"` waits until the logging operation was done, there's no problem with the main thread exiting before the logging thread
23:05:00 <infinisil> It might be a bit slow though? Not sure
23:05:20 <infinisil> But that seems to be the way to go. No need to do ugly thread waiting and stuff
23:05:24 <boj> killing the main thread immediately causes all children threads to exit
23:05:30 <jackdk> yeah so once you've decided to quit you probably want to turn everything off, wait for the logger channel to empty, then terminate
23:05:38 <Axman6> you could always send a message to the logging thread with an MVar () which it writes to when it can finished writing all known log messages, so the main thread can exit
23:06:06 <Axman6> generally making your app slow because you're waiting to write logs isn't desirable 
23:06:08 <infinisil> jackdk: Exactly, but there's no need to that if the main thread always waits for the logging operations to finish before it continues
23:06:37 <infinisil> Axman6: I guess you have a point
23:06:40 <jackdk> at the cost of making all your logging synchronous, yes. that might be suitable for your situation. tradeoffs.
23:07:56 <infinisil> Alternative: Yeah that's what I intended to do with a closeable channel yesterday
23:08:04 <infinisil> s/Alternative://
23:09:47 <Ariakenom> not waiting means you can have actions taken but not logged in case of a crash
23:10:16 <MarcelineVQ> Unless waiting is part of your exception handling, not that that's foolproof
23:10:39 <Axman6> as long as they have send their log mesage to the channel before the message to exit was sent, and that's basically the definition of what it means to log something in a system like that
23:10:53 <Axman6> sent*
23:10:58 <Axman6> message*
23:11:03 <Ariakenom> I meant power loss type of crash
23:11:05 * Axman6 should learn to type one day
23:11:47 <infinisil> Hmm..
23:12:47 <Ariakenom> I feel like asynchronous semantics are a bit subtle wrt stuff like power loss
23:13:14 <MarcelineVQ> handling power loss is best done by being in more than one place at the same time :O
23:13:17 <boj> you mean like, there are no such thing as semantics because the power is off? XD
23:13:38 <infinisil> Okay well in my application it's not really important for it to absolutely not lose any logs, it does to stderr anyways, it's a CLI application
23:13:55 <infinisil> I just don't want to lose any logs in normal usage
23:14:14 <infinisil> I guess I'll use closeable channels with an MVar (or TMVar)
23:14:38 <Axman6> just make sure you log things before actually executing the action, then you will never do something which isn't logged, but might log something which didn't happen
23:15:02 <infinisil> Well yesterday cocreature said I'm reinventing async, but I tried to use async and it kinda doesn't work how I want
23:15:21 <Ariakenom> there are some more ops errors in that category beside power loss I'd think
23:15:25 <Axman6> this doesn't feel like async to me
23:15:30 <Axman6> well, the logging thread could be
23:15:48 <infinisil> Yeah that
23:16:10 <deviantfero> hey everyone
23:16:15 <deviantfero> I'm getting started with haskell
23:16:21 <MarcelineVQ> I think merijin is a good person to ask about this sort of thing as well
23:16:43 <deviantfero> I wanted to show you a couple of functions I made, could you please tell me if I'm missing something really basic?
23:17:06 <Axman6> deviantfero: go for it 
23:17:11 <Axman6> @where lpaste
23:17:11 <lambdabot> http://lpaste.net/
23:17:18 <infinisil> Man, isn't there some logging framework that does that for me? I feel a bit stupid having to run my own closeable channel + TMVar thing, there must be something out there already
23:17:22 <Hijiri> congrats deviant
23:17:57 <deviantfero> let me know if you're not able to see it
23:17:59 <deviantfero> oh
23:18:01 <deviantfero> https://p.teknik.io/I6X3O
23:18:17 <deviantfero> I used this page, it highlights haskell syntax too
23:18:22 <deviantfero> but I'll give that one a shot too
23:18:31 <ion> Any pastebin is fine
23:18:49 <dminuoso> deviantfero: Instead of those if/then/else statements it might be more idiomatic to use guards.
23:19:08 <ion> You may want to apply hlint to your code, it will give some useful suggestions as well.
23:19:30 <deviantfero> dminuoso, ion, thanks guys, does hlint come by default with haskell?
23:19:42 <Ariakenom> infinisil: Feel like there should be yes. havent looked myself
23:19:48 <ion> No, you'll need to install it (e.g. stack install hlint)
23:19:50 <dminuoso> deviantfero: Furthermore your doubleAt is problematic because it uses (!!) which is partial.
23:19:52 <deviantfero> I'm just getting started, but my goal is to write a compiler/parser/lexer
23:20:06 <deviantfero> I think haskell is perfect for that task
23:20:09 <dminuoso> deviantfero: Great, Haskell is a first class language for such a goal. :)
23:20:37 <ion> deviantfero: In doubleAt, length will iterate through the whole list, then take will iterate through n elements, then (!!) will iterate through n elements, then drop will iterate the list as well.
23:20:54 <deviantfero> so too many iterations
23:21:01 <dminuoso> deviantfero: And it's wrong for other reasons as well.
23:21:11 <mniip> heh
23:21:15 <deviantfero> what's an alternative? the function is clear in what it does right?
23:21:18 <deviantfero> lol
23:21:20 <deviantfero> such a noob at this point
23:21:21 <mniip> I wrote my first compiler in haskell after ~5 years into it
23:21:44 <deviantfero> mniip, it's for college so it doens't have to be that big of a deal
23:21:55 <deviantfero> I'll probably manage to come up wit hsomething really basic
23:22:00 <deviantfero> with*
23:22:18 <ion> deviantfero: One exercise could be to go through the list using pattern matching and self-recursion while carrying a counter, and doing something to the current value when the counter reaches a certain number.
23:22:55 <deviantfero> self-recursion while carrying a counter sounds pretty loaded to me yet, but it's exciting to learn haskell
23:23:04 <ion> or alternatively keep subtracting 1 from the "n" of "doubleAt n" and do something when n is 0
23:23:04 <deviantfero> if it's not too much trouble, would you mind showing me ion?
23:23:14 <deviantfero> I'm still reading through learn you a haskell for good
23:23:20 <dminuoso> deviantfero: You wouldn't do such a thing with a list anyway, in all likelihood.
23:23:34 <robstr> Axman6: Regarding your solution, I'm using servant-client and using a newtype wrapper feels ugly, is there an alternative ? Like dropping the toplevel object , https://gist.github.com/rsoeldner/eb2f6aa3fea0ef80d9311cea13332f6c
23:23:40 <deviantfero> dminuoso, yeah i don't doubt it's a weird excersize
23:24:17 <POGtastic> hi guys, got a couple questions dealing with the following code: https://repl.it/@pogtastic/VigilantJovialLine. 1. For whatever reason, I can't prompt in the same function that I ask for input. Is there any reason why this is the case? 2. Is this a ridiculous way to parse complex numbers?
23:24:19 <mniip> ooh
23:24:20 <mniip> oof*
23:24:24 <mniip> that doubleAt looks bad
23:24:46 <mniip> you should seek to define it recursively, using pattern matching on : or []
23:25:09 <deviantfero> yeah I've been learning haskell for two days now, so I'm really new to all this
23:25:24 <deviantfero> nice
23:25:30 <deviantfero> kinda like prolog i see
23:25:42 <deviantfero> guards everywhere possible
23:25:43 <mniip> you should get used to the idea that everything you're looking at (in terms of data) is a tree and you use pattern matching to examine a certain number of nodes of that tree
23:25:57 <dminuoso> deviantfero: there are some prolog like bits, but you havent touched those yet.
23:26:09 <mniip> as opposed to e.g. "length" which examines the entire list to compute a summary about it
23:26:55 <deviantfero> you think if I keep reading "learn you a haskell for good" I will come up with an improved version of that function?
23:27:03 <mniip> this especially works out with laziness
23:27:05 <deviantfero> or do you guys recommend another resource?
23:27:10 <ion> Here's a template with the _s signifying holes to be filled in. Can you think of what the definitions should look like, even roughly? I'll be happy to fill them in more if you are not sure. doubleAt n [] = _; doubleAt 0 (x:xs) = _; doubleAt n (x:xs) = _
23:27:16 <mniip> because laziness implies that nodes you haven't looked at yet haven't been computed yet
23:27:45 <dminuoso> deviantfero: You will come up with improved versions of any function you are writing.
23:27:54 <deviantfero> dminuoso I hope so :)
23:28:34 <dminuoso> deviantfero: Haskell has an overwhelming number of ways to solving the same problem, so learning Haskell is also about understanding the different approaches you can take.
23:28:49 <mniip> and the perks of those approaches
23:28:54 <ion> I guess one big problem with Learn You a Haskell is that it doesn't have exercises.
23:29:18 <deviantfero> it does have examples, but yeah, hadn't noticed that
23:30:35 <mniip> hmm
23:30:44 <jackdk> robstr I think you can do something like `decodeWith json (withObject "Accounts" $ do ...) someByteString`
23:31:09 <mniip> are there many functors Hask -> Mon(Hask) that send X to [X]
23:31:26 <dminuoso> :k Mon
23:31:27 <lambdabot> error:
23:31:27 <lambdabot>     Not in scope: type constructor or class ‘Mon’
23:31:37 <mniip> dminuoso, the category of monoids in Hask
23:32:30 <robstr> jackdk: yea but how to friggle this into servant-client ?
23:32:42 <mniip> dminuoso, think Control.Applicative.Alternative
23:33:04 <mniip> if 'Alternative f' then 'f' sends every type 'X' into a monoid 'f X'
23:33:28 <dminuoso> mniip: Mmm, but that's just a restricted form of X -> [X] is it not?
23:33:42 <dminuoso> Strictness aside
23:33:59 <mniip> if you have a morphism X -> Y you send it to a monoid homomorphism 'f X -> f Y'
23:34:14 <cocreature> robstr: a newtype is probably your best option here
23:34:19 <mniip> which evidences that the monoid  'f X' must be "natural" in the X
23:34:52 <mniip> dminuoso, you mean X mapsto [X]
23:35:51 <dminuoso> mniip: Oh yeah.
23:36:07 <dminuoso> It was just some handwavy notation.
23:36:08 <mniip> that defines a mapping between Ob(Hask) and Ob(Hask)
23:36:22 <mniip> [X] does not determine an object in Mon(Hask)
23:36:40 <dminuoso> mniip: I was just thinking about lists as free monoids.
23:36:53 <mniip> X mapsto ([X], ++, [])
23:37:05 <mniip> is indeed such a mapping evidenced by haskell's builtin instance Alternative [[]
23:37:09 <dminuoso> Not the list monoid ([] a, ++, []
23:37:12 <mniip> I'm asking whether there are others
23:37:48 <jackdk> robstr I agree with cocreature: if you're expecting to accept this json structure as an argument through servant's type-level API descriptions, then a new type is the best bet
23:37:52 <ion> deviantfero: In case you missed it among all the chat, I wrote a starting point for a doubleAt that uses pattern matching above.
23:37:54 <mniip> i.e whether there's a family of monoids whose carrier set is [X], natural in X
23:39:03 <robstr> jackdk: cocreature I see, thank you
23:39:03 <mniip> might as well cross-post to ##math I guess
23:42:01 <deviantfero> ion: yep
23:42:04 <deviantfero> I saw it
23:42:16 <deviantfero> thanks ion, I hope to get leveled with haskell soon
23:42:36 <deviantfero> are the ; dividing lines? or... something else?
23:42:47 <deviantfero> i remember having read something about that
23:42:51 <deviantfero> but I've forgotten
23:42:58 <ion> The ; is equivalent to a new line in that code.
23:43:05 <deviantfero> ah, nice!
23:43:12 <mniip> deviantfero, you can write a series of equations for a function each on a new line
23:43:17 <mniip> or you can separate them with ;
23:43:42 --- mode: glguy set +v SrPx
23:43:47 <dminuoso> Oh that note, the GHC team sometimes likes to use do-notation while prepending lines with `;` - why is that style used?
23:43:59 --- mode: glguy set -v SrPx
23:44:02 <ion> deviantfero: What would you write as the implementation for the first case? doubleAt n [] = _
23:44:26 <deviantfero> I would just return the empty list wouldn't I?
23:44:34 <ion> Correct
23:44:39 <ion> So doubleAt n [] = []
23:44:46 <deviantfero> doubleAt n [] = []
23:44:49 <deviantfero> so this
23:44:51 <deviantfero> yep
23:44:59 <MarcelineVQ> dminuoso: as a random response, possible because spj is an odd character :> what are you looking at as you ask though?
23:45:04 <ion> How about the second case? doubleAt 0 (x:xs) = _
23:45:17 <deviantfero> hmmm let me think for a minute
23:45:38 <deviantfero> would it be x*2:xs ?
23:45:42 <ion> Indeed
23:45:51 <deviantfero> is there any way to make it more generic?
23:45:56 <deviantfero> like x + x maybe?
23:46:10 <deviantfero> I think that only works with numbers too anyway
23:46:11 <ion> There is a very nice way to make it more generic, but let's figure out the third case first
23:46:34 <ion> doubleAt n (x:xs) = _   (we know n is not 0 because that was handled by the previous case)
23:46:35 <deviantfero> I think it has to do with recursion
23:47:04 <deviantfero> but I'm not really sure how to return the list with the correct element modified
23:47:18 <deviantfero> I would try to use recursion until I get to one of my two base cases
23:47:25 <ion> Indeed
23:47:30 <dminuoso> MarcelineVQ: Oh yeah, odd indeed - but in a very good sense. :)
23:47:32 <deviantfero> something like ...
23:47:56 <deviantfero> doubleAt n (x:xs) = doubleAt (n - 1) xs
23:48:00 <dminuoso> MarcelineVQ: Say the desugarer.
23:48:04 <deviantfero> but I'm really not sure if that would work
23:48:06 <deviantfero> let me try
23:48:21 <ion> That's a very good starting point, but we are not doing anything with the x in that.
23:48:55 <deviantfero> yeah, I'm leaving it behind
23:48:58 <deviantfero> hmm...
23:49:09 <deviantfero> because of that, I'm not getting the result I want
23:50:00 <deviantfero> should I append the x at the end? then reverse the list when I'm done?
23:50:08 <deviantfero> no, that doesn't sound good either
23:50:09 <dminuoso> MarcelineVQ: I mean the one advantage I see, is that it makes the indention easier to read if you have larger code pieces because it aligns with the do itself.
23:50:29 <ion> Perhaps you can compare that with what the n=0 case does for a hint.
23:50:30 <MarcelineVQ> dminuoso: ah yeah, hmm, makes it easy to add another line above I guess, or move around chunks, not sure
23:50:51 <MarcelineVQ> does seem pretty extraneous
23:51:13 <dminuoso> Though mmm, no. It does not align with do.
23:51:46 <dminuoso> MarcelineVQ: It does offer more symmetry *if* you are using {} to begin with I suppose.
23:52:00 <deviantfero> I'm thinking ion 
23:52:02 <deviantfero> lol
23:52:56 <MarcelineVQ> dminuoso: ghc/compiler/deSugar/Desugar.hs:130 is a pretty good example of "so what is ; even adding to this?" hehe
23:53:12 <MarcelineVQ> It's consistent at least
23:53:14 <ion> In both cases, you are deconstructing the input list into the first element and the rest by pattern matching with :, and you will be constructing an output list using : as well.
23:54:05 <dminuoso> MarcelineVQ: well yeah but if you dropped the {} and the semicolons, the code would align still...
23:54:26 <MarcelineVQ> indeedor
23:54:41 <deviantfero> the last part is what I'm not getting, I'm trying to keep the numbers that aren't in 'n' position the same
23:55:03 <deviantfero> but right now, if I try to assemble the list like x:xs before passing it to doubleAt
23:55:11 <deviantfero> I'm never moving along the list
23:56:50 <ion> Say, you are evaluating doubleAt 1 [3,4,5], so you will hit the third case with n = 1, x = 3 and xs = [4,5]. You'll want to construct a list as the result with y:ys where y is the first element and ys is the rest. What would you like the first element to be?
23:58:23 <deviantfero> THANKS
23:58:26 <MarcelineVQ> dminuoso: try to ask bgamari_ mpickering or hvr but I suspect the answer in this case will be something along the lines of, because it was already that way
23:58:32 <deviantfero> you're great stimulating these neurons ion
23:58:39 <deviantfero> oubleAt n (x:xs) = x:doubleAt (n - 1) xs
23:58:43 <ion> Bingo
23:58:44 <deviantfero> this is the answer right?
23:58:47 <ion> Exactly
23:58:49 <deviantfero> doubleAt n (x:xs) = x:doubleAt (n - 1) xs *
23:58:52 <deviantfero> nice
23:58:58 <deviantfero> absolutely beautiful code
23:59:33 <deviantfero> I definetly have to think about it a bit more
23:59:38 <deviantfero> till it makes more sense to me
