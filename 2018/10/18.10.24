00:12:17 <dminuoso> koz_: You could pronounce it as `then`
00:12:26 <dminuoso> Or no. `after`
00:12:34 <dminuoso> `f . g` is f after g
00:12:48 <dminuoso> `Maybe :.: Either e` is Maybe after (Either e)
00:15:17 <gentauro> dminuoso: you read from right to left
00:17:49 <dminuoso> gentauro: Mmm?
00:35:31 <Athas> Many newer languages seem to use |>, which is left-to-right composition.  I like it.
00:37:15 <Ariakenom> >>> is the the common one in Haskell I tihnk
00:42:29 <merijn> Well, I would hardly call it common, but sure
00:44:59 <Athas> I just use '.' in Haskell, because it's more common.  I think it's important that my code sticks to community norms.
00:47:42 --- mode: glguy set +v Guest26914
00:48:59 <Guest26914> test
00:49:42 --- mode: glguy set +v Mejiha
00:51:16 --- mode: card.freenode.net set +v Test
00:51:17 --- mode: glguy set -v Test
00:52:28 <dminuoso> Athas: do you also use <=< over >=>?
00:53:15 <Athas> dminuoso: I tend to use right-to-left composition in Haskell, because it's more common.
00:54:01 <tdammers> I think it's nice to have the possibility to use either, depending on the circumstances
00:54:17 <tdammers> "pipe into" vs. "pull from"
00:54:31 <tdammers> it's technically the same, but sometimes one feels more natural than the other
00:55:03 <Athas> I do have a few places where I use >=>, I think.
00:55:11 <Athas> But it easily gets confusing if its mixed with '.'.
00:55:14 <tdammers> yes
01:25:32 <pukey420> US Election Party Mon. 11/5/18 23:59
01:30:47 <Dark_Ethereal> Aaaa Persistant. How does it work!
01:31:08 <merijn> Dark_Ethereal: Barely ;)
01:40:10 <cocreature> keep calm and use *-simple
01:41:57 <tsaka__> Is there any way to get this to type check: https://paste.ofcode.org/38fHGujbDJmTPHjvtFWnkEZ
01:42:28 <tsaka__> do I have to lift that into the reader monad somehow?
02:03:19 <merijn> tsaka__: The problem is that the 'm' in the body is completely unrelated to the 'm' in your top type signature
02:03:29 <merijn> tsaka__: You probably want "ScopedTypeVariables"
02:06:17 <tsaka__> merijn: Yes. I've tried that, and adding a "forall m.". The error message changes from "m1" to "m" but its still there
02:06:58 <tsaka__> Meaning, I think, it has problems because the function that's called is not in IO
02:09:10 <cocreature> tsaka__: that looks like accRunLogIter doesn’t have a polymorphic type
02:09:26 <cocreature> but you’re trying to use it in a context that requires that it has a polymorphic type
02:09:28 <jle`> tsaka__: the problem is that runStateT gives you a ReaderT
02:09:53 <jle`> er, or whatever the type of accRunLogIter is
02:10:05 <jle`> oh i see it now, it's defined as a parameter
02:10:24 <jle`> tsaka__: yeah, runStateT gives you a Reader Opt ....
02:11:19 <cocreature> if you change the type of the parameter to StateT SimState m (String, Maybe SimStop) it should typecheck
02:11:30 <cocreature> ofc that might mean that your callsite also needs to change
02:11:30 <jle`> you basically need to convert a Reader Opt a into a forall m. MonadReader r m => m a
02:11:49 <jle`> er, a forall m. MonadReader Opt m => m a
02:12:02 <jle`> which isn't too bad, it's just asks (runReader r)
02:13:25 <Bish> how does one do repeated permututations in haskell?
02:13:27 <jle`> :t asks . runReader
02:13:28 <lambdabot> MonadReader r m => Reader r a -> m a
02:13:41 <Bish> say i want all bitwords having 5 bits with Bool
02:13:59 <Bish> (don't say count up, because that's an example)
02:14:41 <cocreature> > replicateM 5 [False, True]
02:14:43 <lambdabot>  [[False,False,False,False,False],[False,False,False,False,True],[False,False...
02:15:28 <Bish> hm, naming of that function wouldn't suggest to me what it does
02:16:27 <Bish> im guessing that's not it's usecase?
02:16:31 <Ariakenom> % replicateM 5 (putStr "hi")
02:16:31 <yahb> Ariakenom: hihihihihi[(),(),(),(),()]
02:16:33 <cocreature> :t replicateM
02:16:34 <lambdabot> Applicative m => Int -> m a -> m [a]
02:16:40 <cocreature> it’s quite a bit more general
02:16:43 <cocreature> but it does the job :)
02:16:54 <Bish> and if i want it pure?
02:17:06 <cocreature> how is this not pure?
02:17:20 <tsaka__> thank you guys, using a constraint instead of an instance for the reader, in conjuction with runStateT worked (no scoped types needed even!)
02:17:25 <Bish> im guessing the M stands for Monad, and i am to new to haskell to fully understand
02:17:32 <cocreature> Bish: in this case m = []
02:17:36 <geekosaur> not all Monads are IO
02:17:40 <cocreature> so you have Int -> [a] -> [[a]]
02:17:49 <Bish> and Ariakenom's example is doing IO
02:18:02 <Bish> so to my understanding haskells runtime does not know it's pure?
02:18:15 <Dark_Ethereal> "replicateM n act performs the action n times,  gathering the results." Now you just gotta figure out how a list is an action
02:18:29 <Dark_Ethereal> huhuhu
02:18:48 <cocreature> Bish: you can choose to use it with m = IO but that will give you a different operation
02:18:59 <Bish> i see, so if i have an IO thingie inside there
02:19:04 <Bish> it's rather doing 5 times unpureness
02:19:09 <Bish> than the thing itself being impure
02:20:14 <Bish> but without explanation i won't understand why that function does all permutations of those 2 elements
02:20:36 <Ariakenom> you will not. but do you need it?
02:20:54 <Bish> Ariakenom: i really like to understand, that's the whole point of the progrm im writing
02:21:01 <Dark_Ethereal> IO is a special monad that represents impure actions. but there are other monads that represent other kinds of actions. replicateM takes an action and does it by the number of times you specify, in sequence, and what it means to be "in sequence" is important.... then it gathers up the results in a list
02:21:02 <cocreature> Bish: are you familiar with the Applicative instance of lists?
02:21:14 <Bish> cocreature: i read about it.. but mainly got confused
02:21:28 <Ariakenom> you can learn other things and accept that as permutations for now
02:21:33 <Dark_Ethereal> you have to understand the Applicative instance of lists to understand what it means to sequence lists with Applicative
02:22:09 <cocreature> replicateM 3 [True, False] is equivalent to "do x0 <- [True, False]; x1 <- [True, False]; x2 <- [True, False]; return [x1, x2, x3]"
02:22:35 <Bish> cocreature: thanks, that helps
02:22:44 <Bish> but that shit is abstract, jesus
02:22:53 <Dark_Ethereal> You'll hate it now... love it later
02:22:59 <Bish> no i love it already
02:23:02 <Bish> i hate that i don't understand it
02:23:08 <Bish> so it's kinda like what happens with
02:23:11 <ski> all operations in Haskell are pure, including I/O ones
02:23:18 <Bish> [(a,b) | x <- ... ]
02:23:40 <cocreature> or in general "replicateM 0 _ = pure []; replicateM n a = do x <- a; xs <- replicateM (n - 1) a; return (x : xs)"
02:24:19 <ski> Bish : yep, exactly. "cartesian product" of lists
02:24:31 <merijn> Bish: The entire point of *having* IO is that it *isn't* impure. People have the (very sloppy!) tendency to refer to IO as "impure", but it isn't, that's the point of having it
02:24:43 <Bish> ski: well in case of n == length list
02:24:46 <Bish> it would be
02:24:53 <__monty__> Bish: Yes, you can replace list comprehension with do-notation: do {x <- ...; return (a,b)}
02:24:58 <merijn> Bish: Have you read: https://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html ?
02:25:05 <Bish> merijn: i understand that part
02:25:17 <Bish> when i say it is impure, i am aware that is not entirely correct
02:25:33 <Bish> but haskell won't be able to memoize something that is IO, and that is part of what i want to benefit from
02:25:46 <Bish> so my poor understanding told me, that this would be "slow"
02:26:02 <__monty__> merijn: Is it because of people sometimes talking about IO what happens, rather than IO the monad?
02:26:09 <Ariakenom> . o O (unsafeInterleaveIO)
02:26:12 <Dark_Ethereal> Steady on chaps, a guy comes in here with a question on getting permutations and you're trying to explain the purity of IO
02:26:14 <cocreature> Bish: Haskell doesn’t do automatic memoization for functions either way
02:26:25 <Bish> cocreature: another thing i'd like to understand
02:26:28 <merijn> __monty__: It's because strictly correct terminology is often very verbose and most listeners will get what you mean while being sloppy
02:26:33 <Bish> since i've seen it doing it
02:26:43 <Bish> cocreature: does it do it for lists?
02:27:06 <cocreature> if you bind the result in some let binding it will only be evaluated once
02:27:35 <Bish> first thing i did in haskell was writing prime numbers as endless list
02:27:40 <cocreature> Bish: but recalculating the list of permutations is pretty cheap so I doubt that there is a point in memoizing it
02:27:43 <Bish> and when invoked a second time, it started later
02:27:56 <Bish> was that because of ghci?
02:28:05 <Ariakenom> merijn: effectful or whatever isn't verbose
02:28:41 <cocreature> Bish: no, when you give things a name they will only be evaluated once
02:28:49 <Bish> ah, okay
02:28:51 <Ariakenom> it's more like it is a tool for learning
02:28:56 <cocreature> so if you define a list called "primes" it will only be evaluated once
02:29:11 <Bish> well, and if it's endless, and i get "index" 5000
02:29:12 <cocreature> but if you call "f x" five times it might be reevaluated
02:29:13 <Ariakenom> say imprecise things meant to give intuition
02:29:14 <Bish> and then 10000?
02:29:28 <cocreature> if you want to avoid that use "let y = f x in …" and use y instead of repeating f x
02:33:59 <dmj`> phadej: ping
02:35:17 <marvin3> Bish, if you are computing an infinite list, which you evaluate partially, each element will be computed only once
02:35:45 <marvin3> (kind of hard NOT to evaluate infinite list partially :P)
02:36:19 <phadej> dmj`: pong
02:36:52 <Ariakenom> % let ones = 1: ones in take 2 ones
02:36:52 <yahb> Ariakenom: [1,1]
02:36:57 <dmj`> phadej: had a question, on the github api, is there a PushEvent payload w/ a FromJSON I‘m missing?
02:37:03 <Ariakenom> marvin3: all the ones are evaluated :)
02:37:21 <dmj`> phadej: I see a FromJSON PullRequestEvent, but no PushEvent
02:37:32 <Ariakenom> and (:) constructors too
02:37:46 <Lycurgus> Dark_Ethereal, it is a pretty basic/important point and Ariakenom mentioned unsafeIO
02:39:07 <Ariakenom> well interleave because has the same memoization properties as non-IO
02:46:19 <dmj`> phadej: nvm, cocreature found one http://hackage.haskell.org/package/github-webhooks-0.10.0/docs/GitHub-Data-Webhooks-Events.html#t:PushEvent
02:53:10 <Bish> cocreature: is it also equivalent to: [ [a,b] | a<-[True,False], b <- [True,False] ] ?
02:54:20 <cocreature> Bish: yes
02:54:55 <Bish> so i do applicative stuff as soon as i do that?
02:57:05 <Bish> and on your definition of replicateM you wrote.. you only write once x0 <- (some rest-list), how does haskell then put every value possible in there
03:00:15 <ski> Bish : the list monad (or idiom) is equivalent to doing that. not sure i'd say you do the former as soon as you do the latter, though
03:01:10 <ski> Bish : `do x <- xs; ...' means `xs >>= (\x -> ...)'. if `xs' is a list, so we're using the instance `Monad []', then that amounts to `concatMap (\x -> ...) xs'
03:02:00 <ski> > concatMap (\c -> if c = 'f' then "***" else [c]) "alfalfa"
03:02:02 <lambdabot>  <hint>:1:23: error:
03:02:02 <lambdabot>      parse error on input ‘=’
03:02:02 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
03:02:11 <ski> > concatMap (\c -> if c == 'f' then "***" else [c]) "alfalfa"
03:02:13 <lambdabot>  "al***al***a"
03:03:12 <ski> Bish : so, it "put every value possible in there", by running across the list `xs', and try binding `x' to an element of `xs' in every possible way, concatenating the respective results of `...', for each possible choice of `x'
03:03:35 <ski> the list monad models "non-determinism", choosing an element from a list, in every possible way
03:04:05 <ski> > do x <- "abc"; y <- [0,1]; [(x,y)]
03:04:08 <lambdabot>  [('a',0),('a',1),('b',0),('b',1),('c',0),('c',1)]
03:04:23 <ski> using multiple lists to choose from, we get every possible combination
03:04:48 <ski> > do x <- [0 .. 3]; y <- [0 .. x]; [(x,y)]
03:04:49 <lambdabot>  [(0,0),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3)]
03:05:22 <ski> in this case, the values to choose from for `y' depends on the particular value that was chosen for `x'. so the ranges aren't independent in this case
03:05:38 <ski> one can also think of this roughly as "nested loops"
03:05:52 <Bish> ski: i think i understad that, but i don't get how it knows to do that multiple times
03:05:59 <Bish> is that action just doing that recursively?
03:06:05 <ski> do what multiple times ?
03:06:24 <ski> @undo do x <- [0 .. 3]; y <- [0 .. x]; [(x,y)]
03:06:24 <lambdabot> [0 .. 3] >>= \ x -> [0 .. x] >>= \ y -> [(x, y)]
03:06:29 <Bish> in the last thing you wrote.. y knows it has to go from 0 to x for every 0..3
03:06:37 <ski> multiple calls to `(>>=)', iow to `concatMap'
03:06:49 <Bish> i don't know why this gets done .. x times
03:07:32 <Bish> cool, that undo command.. is that available osmewhere?
03:07:33 <ski> well, the bounds for `y' are from `0' to `x'. so each `y' can be chosen in `x+1' ways
03:07:45 <Bish> yeah that explains what happens but not how
03:07:51 <ski> @undo [(x,y) | x <- [0 .. 3],y <- [0 .. y]]
03:07:51 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [0 .. y]) [0 .. 3]
03:08:17 <Bish> that's cool!
03:08:23 <ski>      concatMap (\x -> concatMap (\y -> [(x, y)]) [0 .. y]) [0 .. 3]
03:08:38 <Bish> if that [0..y] part was more explicit that'd be cool
03:09:02 <ski> er, actually, typo
03:09:09 <ski>      concatMap (\x -> concatMap (\y -> [(x,y)]) [0 .. x]) [0 .. 3]
03:09:43 <ski>   =  concatMap (\y -> [(0,y)]) [0 .. 0] ++ concatMap (\y -> [(1,y)]) [0 .. 1] ++ concatMap (\y -> [(2,y)]) [0 .. 2] ++ concatMap (\y -> [(3,y)]) [0 .. 3]
03:10:12 <Bish> great.
03:10:29 <Bish> that's magic
03:10:57 <Bish> i have no clue how that >>= operator d oes something to lists, but i will get there
03:10:57 <ski>   =  [(0,y)] ++ ([(1,0)] ++ [(1,1)]) ++ ([(2,0)] ++ [(2,1)] ++ [(2,2)]) ++ ([(3,0)] ++ [(3,1)] ++ [(3,2)] ++ [(3,3)])
03:11:25 <ski>   =  [(0,y),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3)]
03:11:31 <ski> that's he gist of what happens here
03:11:39 <ski> @src [] (>>=)
03:11:39 <lambdabot> xs >>= f = concatMap f xs
03:12:01 <Bish> so that has just been defined?
03:12:09 <marvin3> @src concatMap
03:12:09 <lambdabot> concatMap f = foldr ((++) . f) []
03:12:14 <ski> for the list monad, `(>>=)' means `concatMap' (with arguments in opposite order)
03:12:21 <ski> another definition of `concatMap' is just
03:12:28 <ski>   concatMap f xs = concat (map f xs)
03:12:31 <Bish> uhm.. [] is syntactic sugar for a special monad i guess?
03:12:38 <ski> the list monad
03:12:49 <Bish> so i can't read nowhere about how >>= works on list
03:12:53 <Bish> except for this irc channel ?
03:13:05 <ski> the type `[Int]' of lists of `Int's, is syntactic sugar for `[] Int'. `[]' is the monad here
03:13:23 <ski> you can read the source of `instance Monad [] where ...'
03:13:44 <merijn> Bish: ">>=" doesn't work on list in a special way. It's a typeclass function, so it has a different implementation for each type. In this case we're just discussing "the implementation for []" aka lists
03:14:06 <Maxdamantus> rather, the list type constructor.
03:14:17 <merijn> Bish: It's not a "special monad" it's just "a list" and it just happens that "lists can be instances of Monad"
03:14:26 <ski> `(>>=)' is overloaded. in this case, overloaded over different monads
03:14:30 <Maxdamantus> the "list monad" would be the thing defined by "instance Monad [] where ..."
03:14:35 <ski> just like `(+)' is overloaded over different numeric types
03:14:41 <Bish> that's crazy.
03:15:16 <ski> the overloading (via type classes) is convenient, but isn't required to be able to do computations expressed in a monadic way
03:15:41 <Bish> im reading https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/13-the-list-monad right now
03:15:45 <Bish> and they have a Nil in there
03:15:54 <Bish> does the list monad included in haskell have a nil too?
03:16:05 <ski> we could call `concatMap' manually, instead of `(>>=)' (or its syntactic sugar `do')
03:16:21 <ski> the list data type includes an empty list
03:16:32 <Bish> so [(a,b)| <implicit do block?> ]
03:16:38 <ski> not quite
03:16:50 <ski> but, list comprehensions are similar to `do'-expressions, yes
03:17:08 <Bish> oh.. [] is Nil.. i get it.
03:17:12 <ski> yes
03:17:50 <Bish> and im guessing since the type of [] is not available it's a bit more complicate
03:18:43 <ski> > [(d,n) | n <- [1 .. 9],d <- [2 .. n-1],n `mod` d == 0]
03:18:45 <lambdabot>  [(2,4),(2,6),(3,6),(2,8),(4,8),(3,9)]
03:19:30 <ski> in list comprehensions, you can use "guards", which act as a "filter", letting particular combinations "through" or not, depending on whether the `Bool'ean expression evaluates to `True' or `False'
03:19:44 <ski> in this case, we only get (proper) divisors `d' of `n'
03:20:41 <Bish> wohoo
03:20:45 <ski> using a guard  n `mod` d == 0  here would be similar to using a generator  () <- if n `mod` d == 0 then [()] else []  -- selecting from a list with one answer, or zero answers. selecting from zero answers corresponds to not "letting through"
03:21:19 <ski> > do x <- [0,1,2]; y <- []; z <- [0,1]; [(x,y,z)]  -- no possible value for `y', so no solutions at all
03:21:21 <lambdabot>  []
03:21:34 <ski> > [(d,n) | n <- [1 .. 9],d <- [2 .. n-1],() <- if n `mod` d == 0 then [()] else []]
03:21:37 <lambdabot>  [(2,4),(2,6),(3,6),(2,8),(4,8),(3,9)]
03:22:11 <ski> anyway, if you want to express the same thing, using `do'-notation, with the list monad, you have to wrap your guard(s) in the `guard' function
03:22:36 <ski> > do; n <- [1 .. 9]; d <- [2 .. n-1] ; guard (n `mod` d == 0); return (d,n)
03:22:38 <lambdabot>  [(2,4),(2,6),(3,6),(2,8),(4,8),(3,9)]
03:22:54 <ski> where `guard' is defined as
03:22:55 <ski> @src guard
03:22:55 <lambdabot> guard True  = pure ()
03:22:55 <lambdabot> guard False = empty
03:23:10 <Bish> my head ~
03:23:14 <ski> `empty' in this case is just the empty list, and `pure' gives a singleton list
03:23:36 <ski> (so it's the same as the `if ...' i gave above)
03:24:13 <ski> my main point is that list comprehensions are "basically" the same as using `do' with the list monad, except for some minor syntactic details
03:24:55 <Bish> thanks i learned a lot
03:25:07 <ski> (in list comprehensions, you also write a "result expression" to the left of the `|'. with `do', you have to write it at the right end, wrapped in `return' (or `pure', the same thing), or a singleton list)
03:25:09 <Bish> shouldn't ghci be able to show implementation of functions?
03:26:01 <ski> that would break equational reasoning (at least if it was programatically possible to do it)
03:26:53 <ski> given `f x = x * x' and `g x = x ^ 2', we can reason that `f' and `g' are equal functions. so we don't want to be able to distinguish, from within a program, between `f' and `g'
03:27:30 <ski> since being able to do so, would preclude refactoring (sometimes for optimization) a program using `f' into one using `g' (or other way around)
03:27:52 <ski> (and such refactorings are things we want both a human, and an implementation, to be able to do)
03:29:19 <ski> (of course, `f' and `g' may be different in how efficient they are, say. which can be a reason for doing the refactoring. but we still want to keep the *behaviour* of the program, while hopefully improving efficiency (or sometimes we replace for other reasons). so we don't count efficiency into the "behaviour" for this reason)
03:31:05 <ski> .. one could imagine being able to get at the implementation of a function, when testing/debugging in an interactor like GHCi, though, as long as we can't do the same automatically from within a program that gets a hold of a function value at run-time, say
03:31:22 <ski> Bish : making any sense ?
03:32:38 <Bish> yeah i was thinking about simply being able to hoogle it from within there not the real implementation inside the runeitme
03:32:44 <Bish> but i guess that would break the purpose a bit
03:33:20 <ski> having hoogle in the interactor would be ok
03:34:13 <ski> or even having it output the implementation of an operation, if known, given some specific command
03:34:54 <ski> i was just giving an argument for why we can't have say `functionImplementation :: (a -> b) -> String', which people do ask about, at times
03:44:19 <phadej> dmj`: I'm not sure
03:45:50 <phadej> ah, if something is missing than it probably does
03:49:00 <Dark_Ethereal> Does anyone here have experience with Persistant?
03:49:46 <Dark_Ethereal> Is there a way to update a record in a database with a lens?
03:52:24 <dmj`> Dark_Ethereal: probably not without using unsafePerformIO
03:52:59 <dmj`> Dark_Ethereal: that’s an interesting idea though
03:53:51 <Dark_Ethereal> I'm trying to do something like this:
03:53:51 <Dark_Ethereal> upsertUserField uid field value = upsert (set field (defaultUser uid) value) [field =. value]
03:53:51 <Dark_Ethereal> But there's a type error since the first use of field wants a lens, and the second use wants an EntityField
03:55:15 <Dark_Ethereal> All I want to do is try to update a user record, but if there isn't one, make one from a default but with the update applied
03:55:20 <merijn> You have to obtain the EntityField belonging to that type
03:57:00 <merijn> I don't suppose anyone here has used any of the 4 or 5 or so OpenCL bindings in existence?
03:57:18 <Dark_Ethereal> But here's the thing: if I want to update field x, I need to alter the default value, which I'm currently using a lens to do, and I need to provide an EntityField for the database update...
03:57:37 <Dark_Ethereal> They need to update the same field
03:58:11 <Dark_Ethereal> so I have to be able to get a way to alter the haskell value from whatever I use to create the database update action
03:58:28 <merijn> Dark_Ethereal: Sure, but how does that relate to the problem?
03:58:54 <merijn> You might be able to somehow query the EntityField from persistent, I don't know. If not, you'll have to pass it in explicitly to upsertUserField
04:01:16 <Dark_Ethereal> Is EntityField something native to the haskell record system? I hadn't given much thought about how the record update syntax worked until now
04:02:42 <merijn> No, it's a datatype auto generated by persistent's template voodoo
04:03:01 <merijn> Dark_Ethereal: The point is that the EntityField stuff *doesn't* update a record
04:03:18 <Dark_Ethereal> what do you mean
04:03:19 <merijn> Dark_Ethereal: It's a query that updates the database table directly, so you need to describe what column/field to update in the database
04:03:59 <merijn> Which is why you can't use a lens, because the lens is for Haskell records, but the EntityField stuff doesn't consider Haskell records at all
04:04:27 <Dark_Ethereal> so wait wait
04:08:33 <Dark_Ethereal> Bloody hell.
04:08:37 <Dark_Ethereal> That's what I've got to say.
04:09:54 <merijn> "Update record" is a datatype describing an update to a record, which you can construct by combining a "EntityField record" (which describes a single column) with one of the update operators. But none of that has anything to do with actual Haskell records
04:10:25 <Dark_Ethereal> So there's no way to derive any kind of setter from the matching EntityField for the field you want to set?
04:10:42 <merijn> I don't know
04:10:55 <merijn> I'd assume there's some way to do this, but I don't know how
04:11:34 <Dark_Ethereal> I've come to the conclusion that databases are evil
04:11:50 <merijn> Databases are fine
04:11:59 <merijn> Persistent's TH voodoo just overcomplicates things
04:12:14 <Dark_Ethereal> So what's better?
04:12:53 <merijn> postgres-simple and sqlite-simple?
04:13:11 <merijn> Selda looks promising, but is still missing some crucial things
04:16:27 <Dark_Ethereal> I think I'll just stick with what I'm using atm
04:17:15 <Dark_Ethereal> Just gotta figure out how to try to set a field of a record, and if the record doesn't exist, make an updated default.
04:40:59 <ph88> MarcelineVQ, i get "Unknown package: bnfc"
04:49:57 <Ariakenom> How do I get a binary representation of an integer?
04:50:35 <merijn> Ariakenom: For what purpose?
04:50:53 <Ariakenom> displaying 0b00100100
04:51:23 <hpc> start with http://hackage.haskell.org/package/base-4.12.0.0/docs/Numeric.html#v:showIntAtBase
04:52:10 <Putonlalla> > showIntAtBase 2 (\ i -> chr (ord '0' + i)) 42 "" -- End up with this.
04:52:12 <lambdabot>  "101010"
04:52:26 <hpc> > showIntAtBase 2 intToDigit 126543987
04:52:28 <lambdabot>  <[Char] -> [Char]>
04:52:39 <hpc> > showIntAtBase 2 intToDigit 126543987 ""
04:52:42 <lambdabot>  "111100010101110100001110011"
04:53:04 <Putonlalla> Of course, `intToDigit` already exists.
04:53:24 <hpc> slight tangent, but it bothers me that 0b10101 literals aren't a thing in ghc
04:53:36 <Putonlalla> We have an extension for it.
04:53:37 <Axman6> the formatting library is quite good for dealing with things like different bases
04:53:44 <hpc> i find myself wanting them way more often than i want octal
04:54:01 <merijn> hpc: There was an extension for it, or it was in the works, I forget which
04:54:04 <Putonlalla> % :seti -XBinaryLiterals
04:54:04 <yahb> Putonlalla: 
04:54:07 <Axman6> you can also use underscores in numbers now too, 1_000_000
04:54:13 <merijn> Axman6: Yeah, <3
04:54:16 <Putonlalla> % 0b00101010
04:54:16 <yahb> Putonlalla: 42
04:54:34 <Axman6> (a great feature from Ada [but also probably something else before that])
04:54:45 <Axman6> % 1_000_000
04:54:45 <yahb> Axman6: ; <interactive>:16:1: error: Use NumericUnderscores to allow underscores in integer literals
04:54:53 <Axman6> y u no :(
04:54:57 <hpc> heh
04:55:08 <hpc> i have only ever used one language with binary literals
04:55:14 <hpc> i think it was rust? i completely forget now
04:55:14 <merijn> % :seti -XNumericUnderscores
04:55:14 <yahb> merijn: 
04:55:20 <merijn> % 1_000_000
04:55:20 <yahb> merijn: 1000000
04:55:27 <Axman6> <3
04:55:29 <merijn> Of course there's also the amazing NumDecimals
04:55:35 <Putonlalla> % 0b0010_1010 -- ?
04:55:35 <yahb> Putonlalla: 42
04:55:35 <Axman6> ?
04:55:35 <merijn> % :seti -XNumDecimals
04:55:36 <yahb> merijn: 
04:55:40 <mnoonan> common lisp has 'em
04:55:41 <merijn> % 1e6 :: Int
04:55:42 <yahb> merijn: 1000000
04:55:48 <Axman6> :o
04:55:52 <hpc> oh i like those too
04:55:59 <Putonlalla> % 0b0010_1010e+3 -- ??
04:55:59 <yahb> Putonlalla: ; <interactive>:22:12: error: Variable not in scope: e
04:56:00 <hpc> % 0b1e8
04:56:00 <yahb> hpc: ; <interactive>:23:4: error:; * Variable not in scope: e8; * Perhaps you meant `_8' (imported from Control.Lens)
04:56:02 <Axman6> % 1.0e6 :: Int
04:56:02 <yahb> Axman6: 1000000
04:56:05 <hpc> aw
04:56:06 <merijn> Axman6: Allows exponent notation for non-fractional types IFF they're non fractional
04:56:10 <Axman6> % 1.5e6 :: Int
04:56:10 <yahb> Axman6: 1500000
04:56:14 <Axman6> :O
04:56:17 <hpc> if that printed 256 that would have been incredible
04:56:42 <merijn> Axman6: I mean, it's a trivial check that they're integral values at compiletime. It was stupid they didn't include it from the start
04:56:55 <Axman6> yeah
04:57:06 <Axman6> % 1.5678912e6 :: Int
04:57:07 <yahb> Axman6: ; <interactive>:26:1: error:; * No instance for (Fractional Int) arising from the literal `1.5678912e6'; * In the expression: 1.5678912e6 :: Int; In an equation for `it': it = 1.5678912e6 :: Int
04:57:12 <Axman6> % 1.567891e6 :: Int
04:57:13 <yahb> Axman6: 1567891
04:57:19 <Axman6> that's awesome
04:57:28 <Axman6> How'd I miss that
04:58:09 <hpc> maybe the next standard will pull them in
04:58:24 <Putonlalla> Don't forget `NegativeLiterals`.
04:58:48 <Axman6> % :seti -XNegativeLiterals
04:58:48 <yahb> Axman6: 
04:58:59 <Axman6> % 1 + -2
04:58:59 <yahb> Axman6: -1
04:59:03 <Axman6> <3
05:00:41 <ski> % 0.001e-4 :: Int
05:00:41 <yahb> ski: ; <interactive>:30:1: error:; * No instance for (Fractional Int) arising from the literal `0.001e-4'; * In the expression: 0.001e-4 :: Int; In an equation for `it': it = 0.001e-4 :: Int
05:00:51 <merijn> Axman6: You forget to read the GHC release notes? :p
05:01:29 <ski> % 100000e-4 :: Int
05:01:30 <yahb> ski: 10
05:01:33 <Putonlalla> % :seti -XBlockArguments -- Do we have this yet?
05:01:34 <yahb> Putonlalla: Some flags have not been recognized: --, Do, we, have, this, yet?
05:01:40 <Axman6> yeah I guess so, I picked up on the NumericUnderscores but not the others
05:02:06 <Axman6> % :seti -XBlockArguments
05:02:06 <yahb> Axman6: 
05:02:15 <Putonlalla> % let anything = pure ()
05:02:16 <yahb> Putonlalla: 
05:02:26 <Putonlalla> % don't do anything
05:02:26 <yahb> Putonlalla: ; <interactive>:35:1: error: Variable not in scope: don't :: f0 () -> t
05:02:37 <Putonlalla> Sweet.
05:02:58 <Putonlalla> Time to upgrade GHC.
05:23:49 <tdammers> dammit, cabal new-build is too smart... I added a dependency, and it just figured out that the previously installed versions wouldn't work, and smoothly found a new solution, and now it's installing all the dependencies anew
05:24:26 <merijn> tdammers: new-build (unlike old build) *intentionally* doesn't try to use already installed versions
05:24:38 <merijn> tdammers: It always defaults to "newest known" in it's buildplans
05:25:13 <tdammers> merijn: yes, ofc, and that's a great feature, actually
05:25:35 <tdammers> merijn: I'm just amazed at how this amounts to automatically doing the "nuke the sandbox and start afresh" dance in this case
05:25:44 <merijn> ah
05:25:46 <tdammers> (but without actually throwing anything away, that is)
05:25:57 <merijn> "dammit, it's too smart" sounds like "it's breaking things by being smart"
05:26:30 <merijn> Also, not sure I'd describe that as "smart", rather than dumb, but in a nicely orthogonal/compositional way ;)
05:27:18 <mniip> % fix \x -> ()
05:27:18 <yahb> mniip: ()
05:27:21 <mniip> sweet
05:28:00 <mniip> % map do { \x -> x } [1..5]
05:28:00 <yahb> mniip: [1,2,3,4,5]
05:30:02 <tdammers> nah, it's not really breaking anything, other than making me wait for all those deps to recompile
05:33:56 <aplainzetakind> What's the difference between running `stack install foo` from ~  and cloning the foo repo and running `stack install` from inside the folder?
05:35:52 <opqdonut> aplainzetakind: well for one `stack install foo` uses the version of foo from the selected snapshot, whereas cloning the repo uses latest master (or whatever)
05:36:01 <opqdonut> might be other differences too
05:38:47 <aplainzetakind> opqdonut: I don't completely understand everything I'm trying to do, but I had at some point installed ghc-mod (presumably with `stack install ghc-mod`) against ghc 8.0.2. Now the stack version moved on and I don't know how to update ghc-mod. Running `stack install ghc-mod` reports a lot of conflicts with my global stack.yaml.
05:40:16 <aplainzetakind> Basically what I'd like to know is if installing from a cloned repo would cleanly overwrite the old installation without a mess.
05:42:09 <opqdonut> no clue sorry
05:42:46 <aplainzetakind> OK, thanks.
05:43:35 <opqdonut> the built ghc-mod versions definitely go in different isolated directories
05:43:46 <opqdonut> and I guess the only global part is some symlinks from ~/bin or wherever
05:43:53 <opqdonut> so it should be fine
05:44:20 <opqdonut> hmm ok not symlinks, statically linked executables in ~/.local/bin
05:45:13 <opqdonut> `stack uninstall help` says: stack does not manage installations in global locations. The only global mutation stack performs is executable copying. For the default executable destination, please run stack path --local-bin
05:46:11 <aplainzetakind> `file ~/.local/bin/ghc-mod` says ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, stripped
05:46:38 <aplainzetakind> So only this would be overwritten and it's pretty safe right?
05:47:12 <Solonarv_> you can just "rm $(which ghc-mod)" and the global executable will be gone
05:47:46 <Solonarv_> also, next time you install a dev tool: use "stack build --copy-compiler-tool ghc-mod"
05:48:34 <Solonarv_> that'll copy the binary into a folder specific to that compiler version, instead of the global folder
05:49:00 <opqdonut> nice
05:49:28 <Dark_Ethereal>  now if only all text editors were set up to call compiler tools through stack...
05:49:32 <Solonarv_> of course, it won't be on the $PATH in that case
05:51:40 <Solonarv_> but you can set up a script like so: https://gist.github.com/Solonarv/a89c2f594dac72931ce8691ddaf88be8
05:51:48 <Solonarv_> and put *that* on your $PATH
05:52:35 <aplainzetakind> Solonarv_: Nice.
06:04:19 <__monty__> Dark_Ethereal: Please no. Not all of us want to use stack.
06:16:08 <Solonarv_> it *would* be nice if text editor plugins more commonly allowed you to configure the executable they use to call a tool
06:17:55 --- mode: glguy set +v TorkMattar
06:22:08 --- mode: glguy set +v ahri[m]1
06:27:03 <johnnymacs> I have invented an immutable chan: https://pasteboard.co/HJW0i93.png
06:28:57 <merijn> Solonarv_: So...like the Language Server Protocol? https://langserver.org/
06:30:42 <aplainzetakind> The ghc's under .stack/ look for an old gcc. Can I just manually remove them to get them to rebuild?
06:30:56 <Solonarv_> yes, LSP is a solution to the issue, I think
06:32:49 * ski . o O ( Liskov Substitution Principle )
06:40:21 <ahri[m]1> hmm... so does nobody do any UI work in Haskell? or is Stack just not the common tool for this niche?
06:41:19 <dminuoso> ahri[m]1: what does stack have to do with UI?
06:42:27 <ahri[m]1> nothing directly, but I need to get UI bindings from somewhere and Stackage doesn't have wx
06:43:13 <ahri[m]1> https://www.stackage.org/package/wx
06:43:19 <cocreature> you can use packages that are not in stackage just fine
06:43:23 <cocreature> just add them to extra-deps
06:43:38 <cocreature> you could also use gi-gtk which is in stackage
06:45:47 <ahri[m]1> which route is most sensible? I was looking at wx as a native look and feel is preferable
06:46:05 <cocreature> depends on where you want it to look native :)
06:46:08 <merijn> ahri[m]1: Almost all of the GUI frameworks are gonna involve a certain degree of pain
06:46:30 <cocreature> there are also qt bindings but I haven’t used those myself
06:46:37 <ahri[m]1> cocreature (IRC): fair point! win32/linux/mac
06:47:03 <ahri[m]1> being able to make a simple app that looks fairly native with the same codebase would be nice
06:51:36 <ahri[m]1> when I try getting Stack to install wx, and keep adding the stuff it tells me to extra-deps, I end up adding `- base-4.10.1.0` and from there on Stack just keeps telling me the same thing; to add `- base-4.10.1.0` to my extra-deps, so this doesn't work
06:53:59 <ahri[m]1> I even threw `allow-newer: true` in my `~/.stack/global-project/stack.yaml` for good measure
06:55:48 <merijn> ahri[m]1: That's stack being naive
06:55:54 <merijn> ahri[m]1: base is hard-tied to GHC
06:56:01 <merijn> ahri[m]1: You cannot upgrade it without upgrading GHC
06:56:22 <merijn> ahri[m]1: aka, the version of wx you're trying to use is not compatible with the GHC your stack resolver is trying to use
06:56:53 <ahri[m]1> ah... :\ that's... unfortunate?
06:57:07 <merijn> Solution: Use a different GHC
06:58:13 <merijn> wx itself seems to support all the recent GHCs so perhaps your stack resolver is ridiculously old? Or some other dependency is conflicting
06:59:01 <ahri[m]1> In the dependencies for process-1.4.3.0: base-4.11.1.0 from stack configuration does not match >=4.4 && <4.11  (latest matching version is 4.10.1.0) needed due to wx-0.92.3.0 -> process-1.4.3.0
06:59:47 <ahri[m]1> Stack's on 1.71, LTS 12.14
07:00:18 <merijn> ok, so the version of 'process' in your stack resolver only supports GHC 8.2 and earlier
07:00:42 <ahri[m]1> I tried again with Stack 1.9.1 and got the same error
07:02:21 <merijn> ahri[m]1: Stack is trying to use GHC 8.4 (which ships with base 4.11), but looks like wx is (indirectly) requiring "process <= 1.5" which only supports base < 4.11
07:02:28 <ahri[m]1> so I need to match the base version to a GHC version and then to an LTS to go forward?
07:03:36 <merijn> ahri[m]1: Or patch wxdirect to accept a newer version of process
07:04:13 <hexagoxel> is there a simple way of avoiding the missing-home-modules warning that is more-or-less unavoidable when using :load in ghci?
07:04:57 <hexagoxel> i mean, i can alias :load to :set -Wno-missing-home-modules; :load, but that's stupid.
07:05:50 <hexagoxel> (and probably recursive? no idea how these macros are evaluated)
07:06:56 <ahri[m]1> merijn: yeah, that sounds a bit scarier than accepting a lower version of GHC! I managed to backtrack via https://wiki.haskell.org/Base_package and then https://www.stackage.org/ "Latest LTS per GHC version" to arrive at 11.22 being a viable LTS
07:07:12 <ahri[m]1> thanks to your illumination - I'd have been completely stuck otherwise
07:07:50 <merijn> ahri[m]1: It's not that scary. 9 times out of 10 you can just change the version limit and check if it still works
07:08:12 <merijn> ahri[m]1: Because usually the code hasn't actually broken, it's just that no one remembered to update the upper version limit
07:08:24 <merijn> And when it does break, it's usually not too hard to fix
07:09:13 --- mode: glguy set +v sagax_
07:10:22 <hexagoxel> .. and of course you lose auto-complete when defining a ghci alias.
07:11:38 <ahri[m]1> merijn: ok, perhaps I'll give that a go after getting this building; it would be more convenient. out of interest is there a way to specify extra-deps on the command line when using `stack script` ?
07:12:45 <merijn> ahri[m]1: I don't actually use or know stack, so...maybe?
07:13:31 <ahri[m]1> hah, fair enough - out of interest, then - why don't you use Stack?
07:14:02 <merijn> Because it didn't exist when I started and I never problems with cabal :)
07:19:22 <aplainzetakind> I'm trying to stack-init in a cloned repo (ghc-mod), and stack init can't find a dependency (ghc-mod-core). How do I find/include it when there's no stack.yaml to edit yet?
07:20:55 <merijn> aplainzetakind: By writing a stack.yaml?
07:21:37 <aplainzetakind> Isn't the whole point of stack init to autogenerate that?
07:22:04 <aplainzetakind> From what I understand --solver is supposed to take care of situations like these.
07:22:53 <merijn> aplainzetakind: That just creates a fresh stack.yaml file. It won't magically add all the necessary stuff to build an existing project
07:23:40 <Ariakenom> how do I make a 0x prefixed, 0-padded Formatting.Format for ints?
07:23:50 <gentauro> I tend to make my own very basic `stack.yaml` and `packages.yaml` files
07:23:55 <turol> does some haskell build/packaging system support "vendoring" dependencies?
07:23:58 <gentauro> it's just a few lines :)
07:24:29 <turol> vendoring = adding a copy of them to the repository
07:24:38 <cocreature> turol: sure, both cabal new-build and stack handle that
07:24:40 <merijn> turol: What do you mean by vendoring? Prefering local copies over the Hackage version?
07:25:01 <turol> yes, and "local" specifically meaning "in my source control"
07:25:04 <merijn> turol: Yeah, new-build supports that
07:25:11 <turol> so if i add/update them on one computer, then push to another
07:25:20 <turol> the other computer doesn't need to consult hackage when i build next time
07:26:00 <gentauro> turol: stack `hashes` packages locally based on LTS and GHC version
07:26:13 <gentauro> so if one of your projects uses some package
07:26:28 <gentauro> others can re-use them withtout having to download the again
07:26:30 <turol> i don't want that
07:26:34 <merijn> turol: new-build supports both local copies and specific remote version control revisions as dependencies
07:26:37 <turol> i want the whole thing contained in my working directory
07:26:37 <gentauro> turol: why not?
07:26:46 <turol> no touching globals, no touching $HOME
07:26:46 <gentauro> turol: you can do that as well
07:26:56 <turol> because i'm anally retentive like that
07:27:00 <gentauro> turol: it's deterministic
07:27:08 <gentauro> if it isn't in cache it will download
07:27:19 <turol> and i don't want yet another cache which i might have to clean up at some point
07:27:20 <gentauro> I really hope you don't submit local packages to git ...
07:27:23 <gentauro> that would be a no-go
07:27:38 <turol> if it's my personal project it absolutely is a go
07:27:45 <gentauro> :o
07:27:49 <cocreature> you’ll have to do the vendoring aspect yourself, stack and cabal allow you to depend on local directories but there is no "cabal vendor" command that automatically vendors all your deps
07:27:55 <gentauro> I can't help, sorry
07:28:04 <cocreature> but I’m also not sure why you would want that for all deps
07:28:09 <turol> cocreature: that's exactly what i would have wanted
07:28:10 <merijn> cocreature: Cabal lets you depend on remote repos too!
07:28:30 <cocreature> merijn: sure stack does too
07:28:57 <turol> cocreature:  well, all dependencies that aren't included when i "aptitude install ghc"
07:29:18 <cocreature> turol: right, what are you hoping to achieve by doing that?
07:29:18 <turol> so when i copy the latest version to my laptop and go offline i know i can still build it
07:29:36 <turol> with all the required packages and exact versions
07:29:49 <cocreature> so it’s only about being able to compile without being online?
07:29:56 <turol> partially
07:30:15 <turol> also when i put the project on ice for a year and come back i know none of the dependencies have changed under me
07:30:26 <hexagoxel> you may want to include "no need for any sort of package index" to your specification. and unfortunately, i think avoiding a package index is not supported at all by cabal/stack.
07:30:28 <turol> i just got bitten by that over in javascript/npm -land
07:30:32 <cocreature> stack pins package versions by default, for cabal there is "cabal new-freeze"
07:30:40 <turol> someone elses project didn't specify versions and now it doesn't work
07:30:41 <cocreature> so if that’s all you want, there is no need for vendoring
07:31:10 <turol> it's not all i want
07:31:31 <cocreature> not sure what the best way is to avoid online access.
07:34:53 <hexagoxel> manually compile and execute Setup.hs, place build results in a sandbox-like local package-db. figure out the correct build order on your own.
07:36:10 <turol> write tool to automate it
07:36:12 <hexagoxel> that is, write your own minimal build-tool, because our existing build-tools are too stupid to do this one thing (building local packages) properly.
07:36:45 <merijn> hexagoxel: No they're not
07:36:46 <turol> isn't cabal available as a library? just invoke it multiple times in correct order
07:36:57 <merijn> hexagoxel: cabal-install lets you have a local mirror of Hackage
07:37:06 <merijn> hexagoxel: So you just download all of Hackage and call it a day
07:41:08 <hexagoxel> that is not "properly" by my standards.
07:44:16 <shapr> is this where davean's skete fits in?
07:44:31 <merijn> hexagoxel: Why not?
07:44:42 <shapr> I like having a local --depth=1 mirror of hackage
07:46:52 <hexagoxel> because it still needs stuff in $HOME. And requires you to run a local mirror. And involves a package index without any need for a package index.
07:47:50 <Jetien> can somebody recommend a haskell code generation library? i need to convert a small custom language to haskell
07:48:14 <Jetien> i'd like to create the ast myself
07:48:40 <hexagoxel> (i am aware that my attitude here qualifies as "anally retentive", too)
07:50:42 <gentauro> turol: what you aim for is to use `stack` with the LTS (Long-Time-Support)
07:50:47 <shapr> hexagoxel: or you could say you have piercing insight :-)
07:50:48 <hexagoxel> (but there is a argument for having a build tool do one thing properly, and that one thing seems to be to take a set of local packages and build them, placing artefacts into the specified output directory. and not touching anything else, not network, no local files, apart from /tmp.)
07:50:49 <gentauro> I mean, try it out
07:50:54 <gentauro> and you will see it for yourself
07:51:14 <gentauro> I use it in order to make `reproducible builds` -> http://uniprocess.org/builds.html
07:51:34 <merijn> gentauro: How is that different from, say, new-freeze?
07:51:39 <gentauro> and it works `every`, `single` `time`.
07:51:49 <gentauro> merijn: I don't know what new-freeze is?
07:51:59 <glguy> Jetien: The haskell-src-exts package is the first thing that comes to mind
07:52:22 <gentauro> I have only used `cabal` (horrible experience back in the days) and now `stack` (absolutely <3 it)
07:52:38 <Jetien> glguy: thanks
07:52:53 <merijn> gentauro: new-build command that takes a list of the entire transitive dependency graph on your system *now* and pins all versions to those exact versions
07:53:24 <gentauro> merijn: ahhh. That sounds nice :)
07:53:39 <gentauro> turol: here is my build script -> https://gitlab.com/uniprocess/haskell-template/blob/master/binary.build.bash
07:54:30 <gentauro> no matter how many times I wipe my docker images, I always get the same SHA-256 hash
07:54:59 <gentauro> merijn: I think LTS gives a bit more of security as they store the packages online so I can access them for any build server
07:55:07 <maerwald> stack lts is still running a buggy ghc version :P
07:55:08 <gentauro> I don't know if Hackage does the same?
07:55:20 <gentauro> maerwald: seems to wokr
07:55:21 <gentauro> :P
07:55:29 <gentauro> (and pretty well if you ask me)
07:55:38 <hexagoxel> deterministically buggy :p
07:56:05 <gentauro> Have you guys ever worked with other `build` stuff?
07:56:11 <gentauro> I mean, JVM / .NET
07:56:14 <maerwald> gentauro: good you're not deploying something then
07:56:19 <maerwald> unless you think https://ghc.haskell.org/trac/ghc/ticket/14251 is not critical
07:56:27 <gentauro> stack + LTS is the bestest thing that was ever created. After elm-package ofc
07:56:29 <tnks> gentauro: I have, I'd be surprised if anyone has only seen Haskell and nothing else.
07:56:34 <rain2> hi
07:56:57 <Lycurgus> yello
07:57:16 <gentauro> maerwald: I don't allow `crappy` code :P
07:57:25 <tnks> I feel we're conflating Stackage (which I almost never hear a complaint about) with Stack (plenty of people saying boo).
07:57:35 <gentauro> tnks: `The dream` !!!
07:57:39 <Lycurgus> https://wiki.haskell.org/Web/Content_Management was the answer to my question about hs CMS
07:58:13 <gentauro> tnks: stack depends on Stackage when using `LTS`
07:58:16 <Lycurgus> unfortunatetly they all do stereotypical base CMS things that are better worked out elsewhere which is a pity
07:58:17 <gentauro> they go hand in hand
07:58:20 <maerwald> gentauro: that's a llvm code generation bug
07:58:32 <tnks> gentauro: you can use Stackage with Cabal, though.
07:58:40 <gentauro> I tend to see a lot of people here trying to "say bad things" about `stack` so people will use `cabal`
07:58:44 <gentauro> is not happening ;)
07:58:55 <gentauro> tnks: You can, but why would you?
07:59:12 <tnks> gentauro: for me, I prefer to use Nix for building.
07:59:15 <gentauro> tnks: You could also code in JavaScript instead of Haskell ...
07:59:19 <Lycurgus> since there's an advanced data integration based on monads that predates practical hs and would be perfect for a generalized CMS that actually did stuff with data
07:59:20 <tnks> And Stack gets in the way of that.
07:59:22 <maerwald> gentauro: because stack is buggy =)
07:59:33 <maerwald> try to use it with profiling
07:59:41 <maerwald> it doesn't even cache that properly
07:59:49 <maerwald> or optimisation levels 
07:59:57 <maerwald> so you end up with broken cache
08:00:03 <maerwald> quite regularly
08:00:06 <Lycurgus> *integration techique (use in integrating genomic info) and whp's author is conveniently deceased
08:00:11 <tnks> I lean less on the "it's buggy" because both Stack and Cabal have had their share of defects.  And they do get fixed with time.  Neither project is stagnant.
08:00:14 <gentauro> maerwald: Yeah, there are a few flags that aren't easy to use
08:00:16 <gentauro> but that will come
08:00:19 <gentauro> (hopefully)
08:00:24 <Lycurgus> *used
08:00:38 <maerwald> gentauro: well, cabal can do that already, why would I wait and also use a buggy ghc version that has broken code generation
08:01:30 <tnks> I guess that's one thing that's good about Nix... I almost never have a broken cache.  I want to say never, but I don't want to jinx it.
08:01:41 <gentauro> maerwald: so when stack updates to a newer GHC version, the issue will go away?
08:02:17 <gentauro> so the issue is that cabal already moved to the newer version because they have more people/ressources that could de it before?
08:02:31 <maerwald> gentauro: no
08:02:33 <gentauro> I don't think it's a stack issue. More an issue with one of it's dependent components
08:02:38 <maerwald> yes it is a stack issue
08:02:56 <maerwald> because stack doesn't follow unix philosophy and locks you into a ghc version (unless you want more pain)
08:03:08 <tnks> gentauro: I think there's a flip side of the argument.  Why use Stack?  There's two things I always end up with -- both a bit about accessibility for beginners.  1) it's just one download and gets GHC separately  2) --file-watch
08:03:15 <merijn> gentauro: I'm *very* confident cabal has *less* resources and people than stack
08:03:17 <maerwald> deviating from the stack ghc version is just pain
08:03:26 <merijn> gentauro: On account of stack being pushed by FP Co
08:03:49 <merijn> gentauro: There's like 3-5 people regularly working on cabal and most of them part time in their spare time
08:03:52 <shapr> huh, surprising
08:04:55 <maerwald> yes, interestingly I found cabal support to be better (as in: actually talking to their developers) compared to stack where you get mixed results on the issue tracker (if at all), but that's very subjective
08:05:04 <gentauro> merijn: "their spare time" so no real PROD support?
08:05:10 <maerwald> what? :D
08:05:14 <gentauro> I'm not using that for a PROD project
08:05:31 <merijn> I think like 90% of it is hvr, phadej, and Mikhail. Then there's the occasional contributions from ezyang and Duncan
08:05:50 <phadej> Cabal? don't forget fgaz
08:05:56 <merijn> gentauro: Well, if the stack people had invested the money and time into improving cabal-install, rather than starting from scratch...
08:05:57 <phadej> it's like 99% of recent stuff
08:06:05 <merijn> phadej: oh, right!
08:06:16 <fgaz> o/
08:06:41 <gentauro> and a wil fgaz appear :D
08:06:42 <merijn> There's some haddock related stuff from Alex, and then a whole lot of Monoid abuse from me
08:06:44 <maerwald> merijn: I think it's fair they did their own thing, because if you look at it, the philosophy behind both tools is pretty much incompatible
08:06:44 <gentauro> wil = wild
08:07:30 <merijn> gentauro: "I'm not using that for production stuff" <- and still it's like 2 orders of magnitude more robust then literally all JS, python, and ruby tools I see in production...
08:07:44 <gentauro> I vote for a third tools (clone elm-package) and force everybody to use `syntactic versioning`. Then I will be very very happy :)
08:08:24 <gentauro> merijn: Putting Haskell in the same sentence as JS, Python, Ruby with the term `robust`
08:08:28 <gentauro> that you can't do
08:08:32 <gentauro> :'(
08:08:33 <merijn> gentauro: The PVP already tries to enforce a more subtle version of that and look at how loudly people complain about it
08:08:44 <maerwald> I vote for people caring about backwards compatibility and not breaking API all the time, then we don't need esoteric versioning scheme and overcomplicated tools, because our resolvers need to map that API breakage introduced complexity
08:08:48 <merijn> gentauro: Hell, one of the main reasons stack exists is *because* of people hating on the PVP
08:10:01 <gentauro> I have tried to convince people to use `semver` (better said `synver`) but "normal" people don't seem to get it
08:10:23 <gentauro> I don't know if it that they just like builds to break and work weekends so they can stay away from family
08:10:36 <merijn> gentauro: tbh, the PVP is a lot better defined than semver
08:10:40 <phadej> what's the difference between semver and PVP?
08:10:42 <gentauro> but given my age, I have done my share of working over
08:10:48 <merijn> phadej: semver is underspecified :)
08:10:52 <maerwald> builds *should* break
08:11:01 <hexagoxel> is it possible to un-deprecate hole packages on hackage?
08:11:03 <merijn> I mean, arguably the PVP is underspecified too. But semver more so
08:11:12 <gentauro> semver enforced by code is synver
08:11:25 <maerwald> if you want reproducible builds, use freeze files
08:11:28 <gentauro> Evan (Elm) actually writes it incorrectly
08:11:30 <merijn> gentauro: Are you familiar with the PVP?
08:11:36 <maerwald> otherwise keep your library up to date
08:11:56 <gentauro> merijn: no
08:11:59 <merijn> gentauro: https://pvp.haskell.org/
08:13:25 <merijn> Time to head home
08:13:31 <gentauro> merijn: Does it automatically update the versioning for me based on the code? Otherwise, not interested
08:13:41 <gentauro> merijn: travel safely
08:13:52 <merijn> Not yet, but that's only because that's a hard problem
08:14:14 <gentauro> merijn: which Evan seems to solve pretty nicely ;)
08:16:07 <phadej> Elm is ridiculously simple language. E.g. one doesn't need to worry about type-classes and their instances
08:16:18 <phadej> Every problem with Elm is way easier.
08:16:59 <hexagoxel> sounds like we should all switch from haskell to elm
08:17:03 <cocreature> elm can detect type changes but it still can’t detect if you change the behavior of a function without changing its type
08:17:24 <barrucadu> I'm sure I've seen a tool which tells you how you should increase the version of a package, based on an api diff
08:17:33 <barrucadu> But of course that doesn't catch behavioural changes
08:17:44 <phadej> So "elm does it" doesn't generalise to Haskell. Even Evan itself mentioned tha problem of "Why don't just you..."
08:18:27 <barrucadu> Maybe I'm just misremembering this https://github.com/blitzcode/hackage-diff/issues/8
08:18:38 <phadej> yes, there are such tools, but it's impossible to make them complete in haskell
08:18:50 <cocreature> it’s impossible in elm too :)
08:18:52 <phadej> different versions of dependencies might affect things, different ghc etc.
08:19:09 <phadej> e.g. to my undersanding there's only one "Elm" the current one.
08:19:23 <phadej> which also makes things simpler
08:20:51 <__monty__> Could you test for behavioral changes automatically with quickcheck?
08:21:21 <dminuoso> __monty__: Yes, especially with quickchecl.
08:21:45 <barrucadu> You could catch some behavioural changes, but you can't really get a guarantee that there are none, in general
08:22:12 <dminuoso> But "some testing" is still better than "none" - outside of crypto the value remains high.
08:22:57 <barrucadu> Sure.  I mean, that's why we have testsuites at all - to catch undesired behaviour changes
08:25:39 <the_2nd> usually I use stylish-haskell src/*
08:25:53 <the_2nd> since just running it here will result in it touching .git etc
08:25:57 <the_2nd> at least checking
08:26:22 <the_2nd> but since I have flags such as RecordWildCards in my .cabal and not within the single files
08:26:37 <the_2nd> it'll fail on files using it implicitly
08:26:45 <the_2nd> any idea on how to resolve this?
08:34:54 <hexagoxel> the_2nd: see the very bottom of https://hackage.haskell.org/package/stylish-haskell-0.9.2.0/src/data/stylish-haskell.yaml
08:35:31 <the_2nd> okay, so I'll need a config file then?
08:35:46 <hexagoxel> yes
08:35:52 <the_2nd> will do
08:36:58 <hexagoxel> you may keep it as a project-specific config file
08:44:30 <the_2nd> went with that, worked fine. Thank you
09:03:58 --- mode: glguy set +v fen
09:25:20 --- mode: glguy set +v Borders
09:26:21 <Borders> Does anyone know if there is a standard way to represent a symmetric pair?
09:26:34 <Borders> (I am happy for it to have an ord constraint)
09:27:12 <Borders> I can do it with a smart constructor and something like an underlying set or pair where I order them but I wondered if there is something I can just use?
09:29:16 <cocreature> Borders: what exactly do you mean by symmetric pair?
09:30:25 <merijn> cocreature: I'm guessing Pair 1 2 == Pair 2 1?
09:30:29 <Borders> I mean that SymPair 4 5 and SymPair 5 4 are the same
09:30:37 <merijn> Sweet! Guessed right
09:30:41 <Borders> :)
09:31:43 <cocreature> you could use Interval for that but that feels kind of wrong if you only care about it being a pair
09:31:46 <Borders> like I can do: SymPair a = SymPair {getSymPair :: (a, a)}; symPair :: Ord a => a -> a -> SymPair a
09:31:57 <cocreature> https://hackage.haskell.org/package/intervals-0.8.1/docs/Numeric-Interval.html#v:...
09:32:13 <fen> use a pair of constraints instead?
09:32:47 <Borders> how do you mean?
09:33:04 <fen> like a dictionary 
09:33:24 <fen> probably using implicit parameters to avoid having to use reflection 
09:37:47 <fen> would that work for you?
09:43:24 <Borders> fen: sorry I didn't understand your idea
09:44:49 <fen> oh, ok
09:49:37 <fen> hmm, there was a reference somewhere for a neural network that I wanted to implement in Haskell, because it was recursive and could use a fixed point approach, but I cant find it.
09:50:08 <Solonarv> Borders: here's my take on it https://gist.github.com/Solonarv/40015f000601641e5ed5bc8f6bf5a9dc
09:52:03 <Borders> Solonarv: nice!
09:52:04 <fen> does anyone know what it would be called? I thought it was "functional neural network" but this seems to be about "functional link neural networks" or "functional artificial neural networks" and the use of filters or functionals at the weights is not quiet the recursive representaion I recall
09:52:53 <Solonarv> the key takeaway is that you don't actually need Ord to have the Eq instance not care about order
09:53:40 <Solonarv> unfortunately you can't give it foldable / traversable / applicative instances without allowing observation of the order
09:55:59 <fen> anyway, the idea that I wanted to share can be described without a reference
09:56:44 <cocreature> fen: recurrent neural network?
10:00:31 <fen> no, more like using networks as neurons 
10:01:48 <fen> a RNN is just on a cylic tree iirc
10:05:04 <fen> the filterbank/functional approach seems to be something like replacing the sigmoid with an arbitrary nonlinear function, which could be moddled as a NN, but they use e.g. a cosine basis; https://pdfs.semanticscholar.org/e60f/07ffef18aa892ac7b323fe64d8ab28c8815c.pdf
10:05:47 <fen> the problem with that is that the usual proof of universality requires the nonlinear activation function to be monotonic.
10:06:45 <fen> so im not sure if this is the best approach, but at least there is a recursive stage by using NNs to model the actvation functions of the neurons 
10:07:58 <fen> there was another approach to do with something like a combination of experts that was like bundling together various different neural nets and forming a network from them...
10:08:41 <fen> mixture of experts*
10:09:39 <fen> but maybe the way they are combined is not the same way that the individual component networks is structured, so then it wouldnt be recursive. might have to read up on that
10:09:44 <fen> but it gives the idea
10:13:27 --- mode: glguy set +v jh___
10:15:32 <fen> porbably if the NN was approximating a cumulative PDF then the monotone property would hold on a recurive version over the neurons and the proof of univasality would hold
10:16:57 <noumenon> what's the best way to make my Cell = Alive | Dead able to be used show on? I read that you can both define it using instance Show Cell where something, or in some way just use deriving Show
10:18:03 <noumenon> apparently deriving Show worked just fine
10:19:50 <fen> there was also this for trying to algebrically compose networks; https://link.springer.com/chapter/10.1007/978-1-4615-6099-9_70
10:20:14 <fen> and some stuff about information geometry...
10:20:49 <fen> all pretty complex stuff, but the haskell implementation would be much eaiser to understand!
10:21:02 <__monty__> I'm doing a church encoding exercise and am having trouble wrapping my head around subtraction. Is it impossible without doing something like reifying from church to Nat = Z | S Nat?
10:21:14 <fen> just like, unfolding downwards instead of forwards.
10:22:00 <fen> and how to do so addaptively to achieve a bound on complexity of the network from the desired quality of the approximation
10:25:07 <kuribas> @hoogle Text -> Text
10:25:07 <lambdabot> Data.Text tail :: Text -> Text
10:25:08 <lambdabot> Data.Text init :: Text -> Text
10:25:08 <lambdabot> Data.Text reverse :: Text -> Text
10:29:19 <adius> Is there an alternative to https://github.com/huginn/huginn written in Haskell?
10:30:39 <Zemyla> __monty__: You'll want to use something like this, because subtraction is kind of like a zip and Church numerals are like lists of (). http://arxiv.org/pdf/1309.5135.pdf
10:32:10 <Zemyla> Here's a library for them: https://hackage.haskell.org/package/hyperfunctions-0/docs/Control-Monad-Hyper.html
10:32:24 <Zemyla> Written, of course, by Edward Kmett.
10:36:44 <fen> there are also some pretty decent ways to train newtorks using conjugate gradients, which are something like this; https://www.semanticscholar.org/paper/Information-geometry-of-the-EM-and-em-algorithms-Amari/84b32dc90e10bbf1ee5f8ab8063981e2169a025d
10:37:53 <__monty__> Zemyla: Thanks, looking into it. Didn't expect a paper but I'll probably learn something : )
10:37:56 <fen> and some of the most powerful linear algebra from IHT is applied to NNs here; https://arxiv.org/abs/1410.5137
10:38:53 <fen> would be really interested if someone from the Haskell comunity was interested in a project based on this
10:41:33 <fen> (hard thresholding is kind of like pruning) see https://tongliang-liu.github.io/papers/CVPR2017compression.pdf and http://www.jmlr.org/papers/volume18/16-505/16-505.pdf
10:42:30 <fen> the combination of linear algebra and network structure would be very nice to see in Haskell
10:43:37 <fen> and the idea of maximally compressed networks fits nicely with the "fixed point hylomorphism" in an obvious way
11:09:03 <fen> the way that iterative linear algebra methods such as gradient decent can be translated into neural networks directly is explored here; https://arxiv.org/abs/1409.2574
11:10:13 <lone_ranger> so the base definition of foldr is foldr f z [] = z
11:10:25 <lone_ranger> does that men folder is  a function with 3 arguments?
11:10:37 <lone_ranger> s/men/mean
11:11:54 <fen> the geometry of networks arising from various linear algebra methods such as dictionary learning and sparse persuit is derived by "unfolding" the network according to the structure of some iterative algoritm from linear algebra and provides a essential link between the two approaches 
11:15:05 <hyperisco> lone_ranger, I suppose so. There's a spiel about curried vs uncurried functions but casually you'd describe foldr as taking three arguments.
11:16:29 <lone_ranger> hyperisco: thank you, also are brackets used for grouping as well as tuples?
11:16:36 <lone_ranger> or is everything a tuple in ()
11:18:15 <cocreature> lone_ranger: they are used for both
11:18:21 <cocreature> tuples also have a comma in them
11:18:30 <cocreature> (at least one)
11:18:33 <hyperisco> :t ([1,2])
11:18:34 <lambdabot> Num a => [a]
11:18:37 <hyperisco> trolololol
11:20:15 <lone_ranger> kk, thanks guys
11:20:21 <fen> from https://arxiv.org/pdf/1806.00701.pdf; "The concept of unfolding an iterative sparse coding algorithm is clearly not new. The first instance of such idea was formalized by [15] with their Learned ISTA (LISTA)." 
11:20:45 <fen> which refers to; http://yann.lecun.com/exdb/publis/pdf/gregor-icml-10.pdf
11:21:09 <fragamus> Howdy all.    How many bits in Integer?
11:21:37 <fragamus> I’m looking for speed in bitwise operations
11:22:01 <hyperisco> fragamus, infinite
11:22:12 <fragamus> Oh right
11:22:34 <fragamus> Which means slow as you want
11:22:41 <hyperisco> also it doesn't make any sense to do bitwise operations on numbers
11:23:07 <hyperisco> a sort of unfortunate historical artifact of computing
11:23:21 <fragamus> What would you suggest
11:23:34 <mniip> foldr can take 4 arguments though
11:23:53 <hyperisco> foldr can take as many arguments as the imagination allows
11:23:56 <lone_ranger> mniip: example?
11:24:29 <hyperisco> fragamus, well I dunno, I haven't done bitwise in Haskell, but I'd presume to look for some sort of word type
11:24:40 <hyperisco> to make sense of bitwise you need to be talking about bitfields
11:24:53 <mniip> :t \xs -> foldr (\x f a -> f (x:a)) id xs []
11:24:54 <lambdabot> Foldable t => t a -> [a]
11:25:09 <mniip> @let rev xs = foldr (\x f a -> f (x:a)) id xs []
11:25:10 <lambdabot>  Defined.
11:25:11 <mniip> > rev "helllo"
11:25:13 <lambdabot>  "ollleh"
11:25:35 <mniip> :t foldr
11:25:36 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:25:40 <mniip> in this case 'b' is a function type
11:26:38 <fragamus> hyperisco: I shall try hoogle for word types
11:27:26 --- mode: glguy set +v [exa]
11:28:11 --- mode: kornbluth.freenode.net set +v [exa]
11:28:11 --- mode: glguy set -v [exa]
11:29:53 <hyperisco> http://hackage.haskell.org/package/base-4.12.0.0
11:30:08 <hyperisco> uh that wasn't helpful… http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bits.html
11:31:05 <hyperisco> looks like they give instances for several number types… so up to you to figure out how the numbers are encoded as bitfields lol
11:31:56 <mojjoo> hi! `data T = A | B | C`... is there a way to get `[A, B, C]` out of this?
11:32:42 <geekosaur> deriving Enum
11:33:10 <ski> @let data T = A | B | C deriving (Show,Enum)
11:33:11 <lambdabot>  .L.hs:187:10: error:
11:33:11 <lambdabot>      Multiple declarations of ‘A’
11:33:11 <lambdabot>      Declared at: .L.hs:162:12
11:33:21 <geekosaur> probably also Bounded so it can be [minBound .. maxBound]
11:33:52 <ski> yea, was just thinking the same
11:33:53 <ski> @let data T = A | B | C deriving (Show,Enum,Bounded)
11:33:55 <lambdabot>  Defined.
11:34:11 <ski> > [minBound .. maxBound]  :: [T]
11:34:13 <lambdabot>  [A,B,C]
11:34:18 <ski> mojjoo ^
11:35:37 <mojjoo> nice...
11:35:52 <ski> > range (minBound,maxBound)  :: [T]  -- alternative, using `Ix', instead of `Enum'
11:35:54 <lambdabot>  [A,B,C]
11:36:08 <Solonarv_> can you derive Ix though?
11:36:11 <ski> sure
11:36:19 <ski> (you also need `Eq' and `Ord', then)
11:37:04 --- mode: glguy set +v sigtriv
11:37:05 <ski> in this case, `Enum' is probably better, unless you intend possibly using `T' for array indices
11:37:41 <ski> (`Ix' can be derived for product types. `Enum' can only be derived for plain "ranges of constant constructors")
11:37:59 --- mode: ChanServ set +o mniip
11:38:00 --- mode: mniip set -qo hackage!*@* mniip
11:39:07 <ski> mojjoo ^
11:51:54 <kuribas> I wish you could have instance resolution work on constraints.
11:52:57 <kuribas> maybe as a syntax extension: instance MyClass (Constraints => MyData) where
11:52:58 <ski> how do you mean ?
11:53:17 <ski> oh, take constraints into account, when resolving instance, you mean ?
11:53:22 <kuribas> yeah
11:53:51 <kuribas> it would simplify a lot of type level programming.
11:54:02 <ski> perhaps if one could declare classes to be disjoint
11:54:25 <ski> (we can already declare FDs, which are restrictions on what instances there may be. so why not disjointness as well ?)
11:55:04 <kuribas> ski: even without disjointness this would be useful
11:55:26 <kuribas> ski: you can make sure the classes are disjoint by picking the right constraints.
11:55:45 <ski> then, if `D0 a' can't happen at the same time as `D1 a', then if we have one instance with constraint `D0 a', and another with `D1 a', the implementation could actually go ahead and check whether it can determine whether one of them holds (then the other doesn't hold), and so commit to an instance
11:56:38 <ski> (since otherwise, the problem with OWA is that a third party could make sure that both instances could apply, and so we can't commit)
11:56:44 <ski> kuribas : elaborate ?
11:57:26 <kuribas> ski: oh, I had particular cases in mind, but perhaps that would be indeed useful in the generic case
11:58:27 <kuribas> ski: like using a boolean type family in the constraint
11:58:51 * hackage easytest 0.2.1 - Simple, expressive testing library  http://hackage.haskell.org/package/easytest-0.2.1 (joelb)
11:58:52 <ski> hm, i suppose, yea
11:59:49 <ski> there may be a problem with declaring disjointess in a module distinct from the module(s) declaring the two classes
12:00:01 <kuribas> right
12:00:19 <ski> since then someone might instance both classes with the same type, then a third party imports that, together with a module stating the disjointness
12:00:21 * hackage haskoin-store 0.3.1 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.3.1 (xenog)
12:00:30 <kuribas> hmm, I see
12:00:54 <ski> so, either that needs to be detected, or one need to require the disjointness to be stated in the same module as one of the two classes
12:01:53 <ski> (i suppose one could allow stating disjointness of more than two classes at the same time. but it would amount to pairwise disjointness, anyway)
12:03:15 <ski> the simplest is stating `not (D0 a,D1 a)'. multiple disjointness is e.g. `not (D0 a,D1 a,D2 a)'
12:03:34 <kuribas> ski: I was thinking of something simpler.  Basically a second constraint set, which when failed, would just discard this instance as a match.
12:03:53 <kuribas> but not cause an error.
12:04:46 <disconsis> @pl distance x = popCount . xor x
12:04:46 <lambdabot> distance = (popCount .) . xor
12:04:51 * hackage bizzlelude 1.5.0 - A lousy Prelude replacement by a lousy dude  http://hackage.haskell.org/package/bizzlelude-1.5.0 (TheBizzle)
12:05:15 <ski> one could imagine stating `D0 a => (not (D1 a),not (D2 a))', at the same time as `D1 a => not (D0 a)' and `D2 a => not (D0 a)' (those two are just `not (D0 a,D1 a)' and `not (D0 0,D2 a)'
12:05:34 <ski> hm, i suppose the first `D0 a => (not (D1 a),not (D2 a))' also just expresses `not (D0 a,D1 a)' and `not (D0 0,D2 a)'
12:06:23 <ski> `not (D0 a,D1 a)' and `not (D0 0,D2 a)' as opposed to `not (D0 a,D1 a)' and `not (D0 0,D2 a)' *and* `not (D1 a,D2 a)', which is the pairwise disjointness
12:06:50 <ski> (actually `not (D0 a,D1 a,D2 a)' is not pairwise disjointness, it's weaker. it states "not more than two of these three")
12:07:30 <ski> kuribas : failed, not succeded, then ?
12:08:29 <kuribas> ski: I mean when the constraint is not met
12:09:15 <ski> (hm, also `not (D0 a,D1 a)' entails `not (D0 a,D1 a,D2 a)', therefore also `not (D0 a,D1 a)' and `not (D0 0,D2 a)' entails `not (D0 a,D1 a,D2 a)')
12:09:25 <ski> kuribas : yes, hm
12:11:18 * ski ponders what (procedural) semantics of such disjointness constraints could be in logic programming
12:11:57 <kuribas> what's a type class in logic?
12:11:59 <ski> kuribas : "a second constraint set, which when failed, would just discard this instance as a match" suggests that if the first constraint set fails, then that would cause an error ?
12:12:10 <ski> kuribas : it corresponds to a predicate/relation
12:12:11 <kuribas> yeah
12:12:25 <ski>   add(zero,N,     N ).
12:12:45 <kuribas> if the second constraint set is met, and the first (the current one) fails, it's an error.
12:12:47 <ski>   add(succ(M),N,succ(O)) :- add(M,N,O).
12:13:18 <kuribas> I saw it as pattern matching on type level...
12:13:39 * kuribas should really learn idris...
12:13:42 <ski> can be expressed as `class Add m n o | m n -> o,m o -> n', then `instance Add Zero n n' and `instance Add m n o => Add (Succ m) n (Succ o)'
12:14:04 <ski> in this case, the matching in the head selects the clause, not the constraint
12:15:20 <ski> in Prolog, it doesn't need to be the head matching that selects the clause. more than one clause can match, and we'll try them all, with backtracking (some of them may fail when checking their constraints. or may fail, not directly, but because of further constraint satisfaction not working "up the call tree")
12:16:14 <ski> the problem with backtracking for type classes is that we'd really want at most one instance in the end, otherwise we don't know which one to use
12:16:41 <ski> also, perhaps, that it's less efficient to backtrack. but i don't think that's as important a reason
12:17:38 <ski> (and it's not that obvious to see how to allow backtracking (iow trying out constraints, before committing to a clause / instance), but still ensure that there'll be at most one winning one at the end)
12:18:02 <orzo> Is there a newtype that gives me a Monoid instance using mplus?
12:18:06 <ski> (hm, i suppose one could TIAS .. but it would be nicer with a design which statically ruled this out)
12:18:18 <kuribas> ski: hmm, it seems more complicated than I thought at first
12:20:15 <ski> orzo : perhaps `Alt' is good enough for you ?
12:20:35 <ski> (assuming you don't need/want to use any `Monoid' instance on the monadic result type)
12:23:11 <orzo> hm, you were too slow, i made a MPlus monoid
12:25:15 <ski> i'm assuming you were looking for `MonadPlus m => Monoid (MPlus m a)'
12:25:49 <ski> hm, now that i'm pondering it, i'm not even sure `(MonadPlus m,Monoid m) => Monoid (Blah m a)' makes any sense
12:26:14 <ski> (er, `Monoid a', rather than `Monoid m')
12:26:36 <orzo> MonadPlus m => Monoid (MPlus (m x))
12:27:10 <ski> well, i think that looks a bit strange
12:27:15 <ski> @kind Ap
12:27:16 <lambdabot> error:
12:27:16 <lambdabot>     Not in scope: type constructor or class ‘Ap’
12:27:16 <lambdabot>     Perhaps you meant one of these:
12:27:17 <orzo> yeah, FlexibleInstances
12:27:39 <orzo> FlexibleInstances ain't too weird tho
12:27:45 <ski> do you actually need that, or would `MPlus m x' be just as fine ?
12:28:12 <orzo> hm, probably it'd be fine
12:28:22 <ski> @kind Alt
12:28:23 <lambdabot> (k -> *) -> k -> *
12:28:29 <ski> @type Alt
12:28:30 <lambdabot> forall k (f :: k -> *) (a :: k). f a -> Alt f a
12:28:41 <ski> that uses `Alt m a', anyway
12:28:45 <orzo> i'm actually trying to use this with Either
12:28:54 <ski> in `instance Alternative m => Monoid (Alt m a)'
12:28:54 <orzo> dunno if Either has <|> out of hte box
12:30:47 <orzo> hm
12:30:58 <orzo> both of Either's Alternative and MonadPlus are orphan instances
12:31:05 <orzo> in the same module
12:31:24 <orzo> so yeah, fuckaduck
12:31:56 <ski> *argh*
12:32:38 <exarkun1> trying to override a Haskell package on nix, failing.  <https://github.com/LeastAuthority/S4-2.0/blob/11.provision-endpoint/ops/nixpkgs-overlays.nix#L34-L44>.  any chance anyone has any idea about this?
12:32:58 <ski> `instance Error e => Alternative (Either e)' is still in `Control.Monad.Trans.Except', even though the `Error e' constraint is gone on `instance Applicative (Either e)' (in `Data.Either')
12:33:22 <ski> that `Error e' constraint must be scrapped !
12:34:38 <orzo> yeah, i'm just going to make my own Either-like at this point
12:35:18 <orzo> sucks tho
12:36:13 <selfsymmetric-mu> exarkun1: What error are you getting?
12:37:37 <exarkun1> selfsymmetric-mu (IRC): no error from nix, the build goes just as if I didn't have an override (and so the build fails because the spake2 test suite fails in the nix env)
12:39:21 <ski> hm, or is it only lambdabot that's using an old version of the libs ?
12:39:57 <ski> > Left (Sum 2) <|> Right "a"  -- this is what i tried, giving unwelcome error message
12:39:59 <lambdabot>  error:
12:39:59 <lambdabot>      • No instance for (Control.Monad.Trans.Error.Error (Sum Integer))
12:39:59 <lambdabot>          arising from a use of ‘e_12’
12:40:43 <ski> i know the `Monad' instance of `Either e' had `Error e' as constraint, before
12:41:08 <ski> @type return () :: Either (Sum Int) ()  -- but that's gone here, as you can see
12:41:09 <lambdabot> Either (Sum Int) ()
12:41:49 <ski> but looking at <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/transformers-0.5.5.0/src/Control-Monad-Trans-Except.html>, i don't see `instance Error e => Alternative (Either e)'
12:41:57 <ski> perhaps i'm looking in the wrong place, though
12:42:12 <ski> (i also looked in some other modules, like `Control.Applicative',`Data.Either')
12:42:48 <lyxia> ski: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/transformers-0.5.5.0/Control-Monad-Trans-Error.html orphans here
12:43:35 <ski> lyxia : yea, but is that used in lambdabot ?
12:43:46 <ski> (the module is deprecated)
12:44:02 <ski> perhaps it's still imported, for something (like the `Error' type class)
12:44:45 <exarkun1> selfsymmetric-mu (IRC): someone in another channel pointed out my s4/default.nix had its own nixpkgs without my overlays
12:44:56 <selfsymmetric-mu> Ah, gotcha. Glad you got help!
12:45:14 * ski sighs
12:45:55 <lyxia> It seems to somehow import it and that does seem like a bad idea.
12:48:31 <ski> (on second thought, i suppose `Alternative (Either e)' isn't reasonable at all (since `Alternative' has `empty'), for arbitrary `e', which makes it somewhat more understandable, in the absence of `Monoid e' or `Default e' or something. i think i'd prefer not having an `Alternative (Either e)' instance at all, to having one with an `Error a' constraint, at least not imported automatically when `Control.Monad.Trans.Except' is imported)
13:07:10 <Welkin> why does `jsonData` from scotty raise an exception if parsing is unsuccessful? It seems that ti should use Except/Either instead
13:07:17 <Welkin> aeson's `decode` uses Maybe
13:08:48 <Welkin> of course I can always grab the request body as a bytestring using `body` and then parse it myself, but I'm wondering what the reason is behind jsonData being the way it is
13:09:00 <exarkun1> as a new Haskeller, I find the number of choices for reporting failure pretty much overwhelming.
13:09:20 <exarkun1> sometimes it feels like I get to learn a new error handling pattern with every new library I pick up
13:10:04 <Welkin> really?
13:10:10 <Welkin> There is really only Except/Either and Maybe
13:10:20 <Rembane> And some exceptions
13:10:24 <tdammers> Welkin: that's not entirely true. We also have exceptions.
13:10:26 <Welkin> other than that, you have Exceptions, which I have never used/never needed to use
13:10:29 <Rembane> And EitherT
13:10:42 <davean> Welkin: I do not understand how you can avoid using Exceptions
13:11:01 <Welkin> I use Except/Either instead
13:11:18 <tdammers> you can choose to not raise any exceptions yourself, and ignore all exceptions raised from elsewhere, but you can't "not use exceptions" really
13:11:19 <davean> That doesn't work though ... You can't use Except Either. Do you never do any IO?
13:11:39 <davean> Yah, what tdammers said - though many things simply can only be implimented with Exception
13:11:55 <tdammers> the closest thing you can do is pretend exceptions don't exist, and just have the entire program crash and burn when something raises one somewhere
13:11:58 <davean> and don't get me started on "mask" ...
13:12:11 <tdammers> which is actually not too bad for small, short-lived CLI programs
13:12:19 <davean> I have 4 exception handlers just to list the times in a directory ...
13:12:22 <glguy> EitherT is a legacy type, at least. It's not one of the current choices
13:12:40 <davean> *items
13:12:51 * hackage data-tree-print 0.1.0.2 - Print Data instances as a nested tree  http://hackage.haskell.org/package/data-tree-print-0.1.0.2 (lspitzner)
13:12:56 <tdammers> or you can use libraries like scotty, which create islands of pretend-that-exceptions-don't-exist for you, and you can crash and burn those islands individually
13:13:18 <Rembane> glguy: Is it ExceptT that is the current incarnation?
13:13:32 <glguy> yeah
13:13:52 <Rembane> Cool.
13:19:10 <Welkin> I pretty much only write web server applications, or one-off cli programs in haskell
13:19:26 <Welkin> if the request fails, the server keeps going
13:19:31 <Welkin> no need for an exception
13:20:07 <davean> Hopefully it fails *in the correct way*
13:20:23 <Welkin> and the database libraries handle all of that for me
13:20:26 * ski . o O ( <https://wiki.haskell.org/Error_vs._Exception>,<http://book.realworldhaskell.org/read/error-handling.html>,<http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/>,<https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell>,<https://wiki.haskell.org/Error_reporting_strategies> )
13:20:28 <davean> not, say, give a 404 when it should be an error about the wrong type
13:20:50 <Welkin> I don't even know how to handle exceptions in haskell
13:20:56 <Welkin> because I have never done it
13:21:56 <glguy> 500 ¯\_(ツ)_/¯
13:22:00 <Welkin> I like to manually handle problems by sending the appropriate response status code
13:22:36 <Welkin> back to my original question, why does scotty's `jsonData` raise an exception?
13:22:46 <Welkin> and what exceptions does it/can it raise?
13:23:06 <Welkin> and how would you even handle them if you used it instead of parsing the body yourself using aeson's `decode`?
13:23:58 <Welkin> https://hackage.haskell.org/package/scotty-0.11.2/docs/src/Web.Scotty.Action.html#jsonData
13:24:11 <Welkin> wow, that is kind of a stupid use for an exception
13:24:14 <Welkin> I can do that myself
13:26:21 * hackage haskoin-store 0.4.0 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.4.0 (xenog)
13:28:46 <ski> @quote stark
13:28:46 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
13:29:34 <ski> i wonder why they didn't add an extra case to `ActionError', rather than putting stuff into a string
13:46:26 <dmj`> @pl \x -> f <$> g x
13:46:26 <lambdabot> (f <$>) . g
13:47:06 <shapr> Tritlo: is your typed hole suggestions available in a released version of GHC?
13:48:21 <Tritlo> Yeah, it's in 8.6 (partly in 8.4)
13:49:21 <Tritlo> shapr: and no, it's not up yet, but should be up in a few weeks I hope
13:49:48 <shapr> spiffy, the combination of humor and content in your talk was excellent
13:50:10 <Tritlo> :)
13:50:52 <shapr> are there instructions on how to make it go in 8.6?
13:51:07 <shapr> did you demo editor integration? I forget :-(
13:51:13 <shapr> no, that was alanz
13:53:04 <mcbear> I often see modification on a record type data: w { current = n }. Isn't this non-functional programming practice where you can modify variables?
13:53:28 <Welkin> mcbear: that is syntactic sugar for creating a copy with that change
13:53:28 --- mode: glguy set +v zachk
13:53:40 <Welkin> there is no modification happening
13:53:43 --- mode: rajaniemi.freenode.net set +v zachk
13:53:43 --- mode: glguy set -v zachk
13:53:51 <zachk> it returns a new record with the field updated
13:54:00 <mcbear> i see
13:54:51 <mcbear> Is this syntatic sugar explained in the GHC doc or Haskell report?
13:54:56 <mcbear> Is there a name for this?
13:55:00 <monochrom> Haskell report.
13:55:06 <monochrom> record update syntax
13:55:14 <mcbear> great thanks
13:55:48 <monochrom> section 3.15.3 "updates using field labels"
13:56:33 <Tritlo> shapr:  just put in an underscore somewhere
13:56:51 * hackage toodles 0.1.0.11 - Manage the TODO entries in your code  http://hackage.haskell.org/package/toodles-0.1.0.11 (aviaviavi)
13:56:51 <Tritlo> shapr: here's the output from the talk https://www.mpg.is/papers/gissurarson2018suggesting-talk.html
14:04:16 <zachk> is new a keyword in haskell?
14:04:50 <davean> no? Why? What would new even be in Haskell?
14:05:20 <monochrom> {-# LANGUAGE JavaSyntax #-}  >:)
14:07:44 <davean> I mean the closest thing to an implimentation of "new" in Haskell I can think of would be "id".
14:08:06 <davean> Which is why the question strikes me as so odd, I feel I'm missing something in the thought process that lead to it.
14:08:26 <davean> (I've thought also of a few typeclasses that might have a "new" member()
14:08:31 <monochrom> Yeah!  My "JavaSyntax" means changing "foo (Just 4)" to "foo (new Just 4)".
14:09:11 <davean> I feel my answer isn't the correct one for zachk because it doesn't get at whatever had to have gone through their head to ask it.
14:09:20 <davean> So I've answered the asked question but not the pertinent one
14:09:27 <monochrom> Don't second-guess.
14:10:01 <monochrom> Don't answer to answer. Just don't answer.
14:10:15 <ggVGc> is that your final answer monochrom?
14:10:24 <monochrom> No.
14:10:30 <ggVGc> sounded like an answer
14:10:33 <ggVGc> what about that one?
14:10:35 <zachk> making objects in haskell -_- 
14:10:41 <monochrom> Unless I'm dying the next minute.
14:10:46 <zachk> just playing around
14:10:57 <Tuplanolla> Coq has `fresh` as a keyword, which could just as well be `new`.
14:11:00 <ggVGc> monochrom: there's another variant, where you follow your own advise
14:11:07 <ggVGc> and never again answer
14:11:20 <monochrom> You write "Just 4" you already create a new object.  You can think of it as Java's "new Just(4)".
14:11:47 <hyperisco> My version of 'new' would pair a value with a unique number in ST. Such fun :D
14:12:02 <monochrom> You write record update syntax "x{f=5}" you also create a new object already.
14:12:06 <ggVGc> zachk: we don't have "new" because in haskell because of referential transparency and immutability. E.g any "Just 4" is the same as any other "Just 4", and you can bind values to a name or not
14:12:14 <ggVGc> but you don't "create objects" in the same sense
14:12:18 <davean> Theres something of a lack of destinction between functions and data in Haskell since functions are first class and Haskell is non-strict
14:12:28 <tdammers> fwiw, there's newIORef, newMVar, newTVar, etc
14:12:37 <ggVGc> zachk: like, if you wrote down some math and said "x = 20", you didn't create a 20. You just named it "x" for now
14:12:49 <tdammers> those are probably the closest thing to "create a new mutable variable"
14:13:09 <shapr> Tritlo: thanks, I'll try it
14:13:13 <ggVGc> zachk: when you don't have mutability, the idea of "an object" that you create doesn't make sense anymore
14:13:21 <zachk> im putting IORefs in closures and returning a function to access them, but non of the polymorphism of typeclasses is playing nice 
14:13:36 <tdammers> if you want full object-oriented masochism, I suggest https://programming.tobiasdammers.nl/blog/2017-10-17-object-oriented-haskell/
14:13:44 <ggVGc> zachk: put some code in a paste and show us
14:13:51 <ggVGc> and we'll say what might be confusing
14:14:24 <Cale> Yeah, the important thing to realise is that many languages conflate the notion of a variable with the notion of a location in memory whose value can change, or at least, the notion of a mutable abstract cell of some kind.
14:15:33 <hyperisco> data Object a = Object Integer a; instance Eq (Object a) where eq (Object i _ ) (Object j _ ) = i == j; new x = do { i <- get; put (i + 1); pure (Object i x) };
14:15:40 <Cale> and there's a bit of punning which normally goes on in imperative languages where even though the variable corresponds to a mutable cell, using it in code will look up the present value contained in that cell
14:15:46 <hyperisco> don't remember what managing a state look like in ST but there's my concept
14:17:05 <zachk> here is the code to my current version of an object like system : https://ideone.com/7NC7Om it compiles, I can create new objects, but I can't call the methods on them 
14:17:06 <monochrom> C makes this very clear with the two terms "L value" and "R value".
14:18:16 <monochrom> Most other imperative languages just look the other way.
14:18:28 <zachk> here is the errors in GHCi https://ideone.com/BnB6BR , I dont know what GHC.Types.Any is/are
14:18:35 <Cale> If you think of variables in C as referring not to the current value of a memory location, but rather, the memory location itself, then they behave a lot more like Haskell variables, in that they tend to be bound to exactly one thing while they're in scope.
14:20:49 --- mode: glguy set +v hhefesto
14:21:22 <hhefesto> Hello, haskell Gurus :)
14:22:55 <hhefesto> I am using yesod and some code just breaks when I uncomment code on a hamlet template (breaks code outside of the template). Here is my code and my compile errors: https://gist.github.com/hhefesto/6114d49f4882c55d9ed93aff9dab5f28
14:25:26 <Welkin> hhefesto: my advice is to avoid using hamlet/shakespeare templates
14:25:43 <Welkin> I was really into those tmeplating languages when I started, but they are incredibly brittle
14:25:49 <Welkin> use blaze-html instead
14:26:47 <Welkin> the problem is that it uses template haskell to parese the template, so it just breaks without any information for why
14:27:04 <Welkin> with blaze-html (or other html combinator libraries) your html is real haskell code already
14:28:52 <Welkin> if you are new to haskell I would advise against yesod. Even if you are experienced I would adise against it, too. It is too over-engineered and has too much "magic" using template haskell. Scotty or Spock or others are a better choice
14:29:24 <hhefesto> thanks!
14:29:32 <Welkin> I started with yesod, and while it worked out in the end, I could have avoided a lot of frustration. Eventually I moved away from it.
14:32:19 <mniip> I think adjunctions make a limited amount of sense to me now
14:34:02 <hyperisco> handy word to know for word games anyways
14:34:15 <hyperisco> tough to find words with j's in the middle
14:35:11 <Welkin> ajax
14:36:17 <hyperisco> adj*, abj*, and obj* are handy ones I know of
14:36:44 <Welkin> aljabr
14:37:30 <Welkin> does warp automatically use http2 where it can?
14:37:35 <hyperisco> yeah well I try and keep usual words in memory rather than trying to memorise words I've never heard before
14:40:21 * hackage pretty-show 1.9 - Tools for working with derived `Show` instances and genericinspection of values.  http://hackage.haskell.org/package/pretty-show-1.9 (IavorDiatchki)
14:41:41 <Welkin> hyperisco: aljabr is a word you have known most of your life
14:41:57 <Welkin> it is the source of "algebra"
14:42:44 <hyperisco> all the word games I play are only concerned with syntax, not semantics
14:43:43 <hyperisco> hence why I know the words "haj", "haji", "hajj", and "hajji" but haven't a clue what they mean. But I did look up what a "zarf" was.
14:44:12 <Welkin> "Haji was a Cando-American actress renowned for starring in Russ Meyer's sexploitation classic Faster, Pussycat! Kill! Kill! (1965), in which she made her theatrical film debut."
14:44:21 <MarcelineVQ> it's all greek to me
14:44:34 <Welkin> "Hajji (sometimes spelled Hadji, Haji, Alhaji, Al hage, Al hag or El-Hajj) is a title which is originally given to a Muslim person who has successfully completed the Hajj to Mecca."
14:45:30 <hyperisco> Goes along with "qaid" then.
14:46:51 <Tuplanolla> Are words with j in them that rare?
14:47:14 <hyperisco> No idea. As far as recall goes, I find them difficult. Especially when the j is not leading.
14:47:26 <mniip> just get something that begins with j and add a prefix
14:48:03 <Welkin> kanji
14:48:06 <Welkin> of course
14:48:14 <Welkin> I was thinking congee at first
14:48:15 <Welkin> haha
14:48:24 <Welkin> rice gruel
14:48:33 <hyperisco> yeah, a lot of g words pop up which doesn't help
14:48:41 <Rembane> Joker?
14:48:47 <monochrom> The jam jar was jammed, so I jolted it open but then it spilled all over my pajama. Oh joy.
14:48:51 <mniip> jujube
14:49:30 <mniip> monochrom, was it jujube jam :P
14:49:34 * ski . o O ( lovly jubly )
14:49:44 <Tuplanolla> "Although the door is ajar, the meeting has been adjourned due to abject poverty. We hope you are not dejected by this unjust rejection and enjoy your sojourn."
14:50:17 <ski> (is jujube jam bad juju ?)
14:50:28 <monochrom> I don't know what's jujube.
14:50:50 <hyperisco> Ah I should definitely add rej* to my thoughts. dej* doesn't look that helpful but de* is always on the mind so doesn't hurt.
14:53:24 <hyperisco> Adding a prefix is easy but that means the root word has to actually be a word. "joice" is not a word but "rejoice" is, for example.
14:53:49 * ski . o O ( "jubilate" )
14:53:57 <hyperisco> jamboree!
14:54:45 <nshepperd> rejubilate?
14:56:14 <Tuplanolla> "I have still not conjured away the major injury I got in the prejudiced hijack."
14:56:48 <hyperisco> For length, good prefixes include "over" and "under". There are a couple "after" words too.
14:57:34 <mniip> Coendosemirepresentableoid
14:58:30 <hyperisco> Oh and "fore"
15:00:18 <hyperisco> I'll never get around to it but it would be interesting to compute the best word fragments to remember
15:01:55 * ski . o O ( "No, rather I abjure all roofs, and all roofs, and choose to be a comrade with the wolf and owl.","Want will perjure the ne'er-touched vestal." )
15:02:26 <ski> don't forget "ab-"
15:03:20 <hyperisco> well it is moreso I want to know a prefix such as "ab" together with what letters it commonly precedes
15:03:27 <Tuplanolla> "Never eject without first adjusting the turbojet fuel injection valve."
15:03:47 <Tuplanolla> That's all the j I have.
15:03:53 * ski . o O ( "Abaft, you land-lubbers!" )
15:03:55 <hyperisco> there are so many words that begin with "ab" which do not have "ab" as a prefix, such as ones where "a" is the prefix, like "aboard"
15:04:58 <hyperisco> so in the mind I want to think the sorts of things I can "ab" as a prefix, which can be hinted by the letters likely to come next
15:07:23 <hyperisco> for example when I went over the alphabet and hit 'h', immediately "abhorrent" also popped into my head
15:07:38 --- mode: glguy set +v srpx_
15:07:47 <hyperisco> probably because I don't know any other words beginning with "abh" lol
15:09:01 <Welkin> abhuelita?
15:11:15 * ski . o O ( "abgroup" )
15:11:57 <hyperisco> there's also something to knowing particular orders of consonants
15:12:14 <hyperisco> I don't know any "abg" words but if I think of "ab*g*" I can come up with "abrogate"
15:12:58 <MarcelineVQ> abrego
15:14:00 <hyperisco> probably because there are not that many options for vowels to fill in the gaps
15:14:13 <Welkin> look to other languages, of course
15:14:17 <Welkin> ndizi, mtu
15:14:24 <Welkin> you can always win scrabble then
15:14:26 <SrPx> My Haskell is a little bit rust, how can I type Scott encoded nats? i.e., type SNat = forall p . (SNat -> p) -> p -> p
15:14:46 <hyperisco> Welkin, lets play in the language dot star :)
15:14:54 <MarcelineVQ> dz'isu
15:15:18 <ski> SrPx : you need `newtype' (or `data'), since it's recursive
15:15:55 * ski . o O ( "abzu" )
15:19:46 <SrPx> but how?
15:20:10 <SrPx> something like: `data SNat = SNat (forall p . (SNat -> p) -> p -> p)` ?
15:20:25 <SrPx> newtype*
15:28:33 <ski> SrPx : sure
15:32:21 * hackage simple-smt 0.9.3 - A simple way to interact with an SMT solver process.  http://hackage.haskell.org/package/simple-smt-0.9.3 (IavorDiatchki)
15:40:54 --- mode: glguy set +v jackdk
15:41:19 --- mode: glguy set -v jackdk
15:56:45 --- mode: glguy set +v fen
15:58:23 <fen> how are the intermidiate representations of recursive computations unfolded?
15:59:01 <fen> > iterate (+1) 0
15:59:03 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
15:59:10 <mniip> fen, what do you mean unfolded
15:59:23 <fen> like, as thunks
15:59:31 <Welkin> it's just a big data structure
15:59:38 <Welkin> that gets evaluated one part at a time
15:59:43 <fen> a list>
15:59:44 <fen> ?
15:59:54 <Welkin> an AST
16:00:05 <fen> because the functions can take several arguments?
16:00:07 <mniip> wouldn't call it an AST
16:00:18 <mniip> also it's not a T
16:00:20 <mniip> a DAG rather
16:00:38 <hpc> and not even the same A
16:00:49 <fen> thats kind of the question (not really sure what "abstract" syntax means)
16:00:50 <Welkin> or even an S!
16:00:56 <fen> whats a DAG?
16:01:03 <hpc> directed acyclic graph
16:01:11 <Welkin> I don't know the actual details. I was just trying to give a general idea
16:01:16 <hpc> it's the thing that almost everything useful can be represented as :D
16:01:37 <hpc> it's the best data structure since balanced binary trees
16:01:41 <fen> so its a cyclic graph that is turned into an acyclic graph, that must be what "unfolding" was supposed to mean
16:01:56 <Welkin> where did you hear this term "unfolding"?
16:02:06 <mniip> we don't turn cyclic graphs into acyclic graphs...
16:02:06 <MarcelineVQ> acyclic means not cyclic
16:02:35 <MarcelineVQ> I'm not sure why I said that, I'm reading like a goof today, nvm me
16:02:53 <fen> Welkin, some references presented earlier used the term to describe the process of converting an iterative linear algebra algorithm into a neural network
16:02:53 <Welkin> a sick lick?
16:03:25 <mniip> a psyche lick
16:03:46 <fen> mniip: really? but a recursive definition is a cyclic graph?
16:04:06 <mniip> x = "foo" ++ x
16:04:07 <fen> maybe thats the more essential aspect of the question
16:04:11 <mniip> is a cyclic graph
16:04:14 <fen> right
16:04:38 <fen> and it would "unfold" to give some kind of DAG, in this case, a list, as its not branching
16:04:51 <mniip> no
16:04:52 --- mode: glguy set +v serendependy
16:04:56 <mniip> it's stored cyclically in memory
16:05:15 <fen> hmm, so there is no intermidiate thunk like representation
16:05:21 <fen> anywhay, there could be
16:05:29 <mniip> what do you think a thunk is
16:05:30 <serendependy> I saw (something like) the following definitions as an example of an infinitary data structure, and I was hoping someone here might give me an intuition for how to understand it: `data PTree = Leaf | Node ((PTree -> Bool) -> PTree)`
16:05:32 <fen> but maybe it would need to be made explicit
16:05:49 <fen> mniip: like a list of unevaluated functions, such as could be folded with (.)
16:06:14 <fen> a difference list essentially, but here extended to include branching
16:06:17 <ski> (`map' is also a cyclic value)
16:06:29 <fen> yes, all recursivly defined functions are
16:06:33 <mniip> ski, I wasn't sure if I should comment on that
16:06:44 <mniip> because that depends on how we encode functions in our graph
16:06:54 <serendependy> It's supposed to be a variation of `data ITree = Leaf | Node (Int -> PTree)` -- but while I understand this, I don't understand the above
16:06:54 <hpc> i think you're assigning too much magic to the notion of being recursive
16:07:05 <mniip> and then a cyclic graph can indeed be reduced into an acyclic one if a cycling portion is simply discarded
16:07:21 <fen> so the idea is that these programs that can be represented as cyclic graphs, should also have a representation where these loops are written in full
16:07:57 <mniip> well then the representation would require infinite memory
16:08:09 <fen> maybe
16:08:20 <fen> but then maybe its lazily consumed
16:08:30 <fen> not sure how to view that process as part of the graph though
16:09:05 <leafiest> can't the structure be cyclic without the values being cyclic? Like a DAG represented by a recursive structure?
16:10:23 <mniip> when it's consumed you walk over the cycles
16:10:24 <isd> Hey all. I've got a situation where I have a bunch of threads which should all terminate when a particular connection dies, but other than that there isn't really any particular structure to their lifetimes. They may be created and terminate in basically arbitrary patterns. So I want to find some way to set things up so that when I detect that the connection is shutting down, all of the other threads are stopped, but memory usage is pro
16:10:24 <isd> portional to the number of threads that are actually alive. I can't figure out a way to do this with the stuff in the async package I could build the abstraction I need myself using mask and friends, but before I go shave that yak, does anyone know of a more well-trodden way of going about this?
16:10:43 <fen> so maybe the cyclic parts are kind of left not unfolded until they are called, in which case it either crashes, or has fusion and a lazy process to consume the values, but where it could still be written in its unfolded representation, just using exactly many terms as are called
16:11:16 * ski idly wonders what "has fusion" means, here
16:11:20 --- mode: glguy set +v Calledine
16:11:37 <zachk> can existentially quantified types have more then one typeclass constraint?
16:11:40 <hpc> isd: suppose you have a value that uniquely identifies one thread, say data ThreadId
16:11:43 <fen> serendependy: it looks like it uses a continuation, do you understand those?
16:11:49 <hpc> isd: and a function killThread :: ThreadId -> IO ()
16:11:49 <Calledine> the asio genius 
16:11:51 <mniip> zachk, sure why not
16:12:03 <fen> maybe thats not the case, sorry
16:12:26 <hpc> isd: all you need is for the part of your computation that knows about the connection, to have all of those values
16:12:37 <hpc> isd: which you might keep in some mutable thread-safe data structure
16:12:47 <Solonarv> zachk: sure, the constraints can be whatever you want
16:12:52 <serendependy> fen: I understand continuations, more or less. But I don't quite see how this is one.
16:13:18 <fen> ski: maybe thats not nesacary actually, just that the loops wouldnt extend more than the thing which consumes its values needs it to
16:13:24 <isd> Yeah, like I said, I could build it myself, but it's fiddly enough that I wanted to make sure I wasn't re-inventing the wheel.
16:13:31 <zachk> something like this should work? : data Object = forall a . (Show a, Value a, Increment a) => Object a  
16:13:42 <zachk> @type race
16:13:43 <lambdabot> error: Variable not in scope: race
16:13:48 <zachk> @type race_
16:13:50 <lambdabot> error: Variable not in scope: race_
16:14:13 <ski> zachk, sure
16:14:26 <hpc> isd: it shouldn't be very hard to implement, i think
16:14:30 <fen> serendependy: sorry it was a mistake, then it just looks like it requires a function is supplied before the brach is returned. difficult to tell though
16:14:49 * ski . o O ( `exists a. (Show a,Value a,Increment a) *> a' )
16:14:52 <Solonarv> race :: IO a -> IO b -> IO (Either a b) -- runs both actions, as soon as one returns you get that action's result and the other thread is killed
16:14:52 <zachk> isd, link or race from this http://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html , maybe
16:15:03 <ski> (`(Show a,Value a,Increment a)' is a single (compound) constraint)
16:15:23 <zachk> i need to use exists instead of forall?
16:15:41 <hpc> oh, that might be better
16:15:52 <ski> `exists' is pseudo-Haskell, used to talk about what type we want to *encode*
16:16:02 <isd> It's doable. but there's subtleties around spawning threads racing with the the shutdown. Sounds like it doesn't already exist though.
16:16:09 <ski> (and one can encode `exists' in two different ways, in Haskell, with extensions)
16:16:36 <fen> anyway, the ideas that allowed neural nets to be derived from recursive algorithms seemed to be exactly this conversion from a recursivly defined value into a graph
16:16:47 <zachk> so once I define an existential type it will be an instance of all its type class constraints?
16:16:50 <ski> (there were one, or a couple, of Haskell implementations (not GHC), which accepted `exists' as syntax. unfortunately only in argument types, though, where one can already express the same thing without `exists')
16:17:05 <hpc> isd: there might be a simpler design that avoids this problem entirely
16:17:08 <fen> also, it looks as though its not branching, which simplifies things
16:17:11 <Solonarv> you can turn "exists a. a" into "(forall a. a -> r) -> r" -- that's one of the options to encode exists
16:17:15 <ski> (it might be slightly more handy, if one could abstract such argument types under a type synonym, i suppose)
16:17:24 <isd> Can't really think of one.
16:18:01 <serendependy> fen: The function of type `PTree -> Bool` presumably selects one of an infinite number of branches. 
16:18:07 <fen> mniip: does that seem to fit into the idea of converting cyclic graphs into DAGs?
16:18:18 <isd> The thing I'm working on is rpc support for the capnp package (https://hackage.haskell.org/package/capnp). It's kinda the nature of the beast that I can't say much about the lifetimes of exported objects.
16:18:34 <isd> I guess I have a yak to shave :P
16:19:33 <fen> serendependy: wouldnt that be [PTree] -> PTree, or just (?extract :: f a -> a) => f a
16:20:46 <hpc> link seems like the best place to start here, i think
16:20:52 <fen> ski: how do you do that thing where you have thoughts on the irc
16:20:55 <ski> zachk : i don't think so. consider `exists a. Bounded a *> a'. to be able to use `minBound :: forall b. Bounded b => b', replacing `a' with the existential type, we'd need to get a hold of evidence of `Bounded a' (for the hidden/forgotten/opaque/abstract/skolem type `a'). that is what a *value* of type `exists a. Bounded a *> a' gives us. but `minBound' doesn't *take* such a value as *input*, it's expected to *produce* such a a value as *output*
16:21:04 <serendependy> fen: No, it is suppose to correspond to `Nat -> PTree' somehow. What you've written is isomorphic to `Nat` assuming an infinite list
16:21:07 <isd> Yeah, link is definitely part of the solution. I will figure it out.
16:21:14 <ski> (possibly cut off near : ".. but `minBound' doesn't *take* such a value as *input*, it's expected to *produce* such a value as *output*")
16:21:28 <ski> zachk : so, i don't think "once I define an existential type it will be an instance of all its type class constraints" works
16:21:28 <hpc> yeah, i can't think of a better alternate design here either
16:21:45 <serendependy> er, I guess not strictly speaking isomorphic
16:21:48 <hpc> it's tricky when you're using another library, most of the design space is out of your control
16:22:01 <ski> (zachk : i mean, it may work for some classes. but not all)
16:22:15 <isd> ?
16:22:15 <MarcelineVQ> "<isd> ... I have a bunch of threads which should all terminate when a particular connection dies, but other than that there isn't really any particular structure to their lifetimes." afaik this is exactly what aync is for, making and managing a tree of threads. re: https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/ch11.html
16:22:15 <ski> zachk : also, in practice, with encodings, you'd need to manually make instances for your new datatypes, anyway
16:22:40 <ski> fen : `/me ...' aka `ACTION'
16:22:42 <Solonarv> actually, that's wrong: minBound takes evidence of Bounded a, and returns an a.
16:22:44 <zachk> if Object a is an existential type , I can't get the a out of the Object a can I ? Object a -> a ? 
16:22:57 <fen> ah, thats why it looks like a continuation, but really it could be generating these braches from a function taking the nat as an argument, rather than using it as a lookup of an implicitly stored list of candidates
16:23:04 <ski> zachk : nope
16:23:09 <ski> that's the point, sortof
16:23:32 <ski> (in very specific cases, you can. if you have more info available inside the quantifier. but not in general)
16:25:02 <isd> MarcelineVQ: right, I'm familiar with async, but it doesn't have the facility I want out of the box; all of the monitoring constructs either hang on to the memory for their children until the whole subtree stops, or don't allow me to spawn new tasks without having to worry about the race conditions myself. I will probably use things from async, but I've still got a bit of hacking to do.
16:26:24 <geekosaur> there are packages atop async
16:26:35 <geekosaur> dunno if any do what you want though
16:26:43 <isd> Probably the form it will take is that a task will spawn and then link itself to the root. But I think I'm going to have to write that, including getting the sync logic right.
16:27:10 <isd> geekosaur: yeah, I was fishing for pointers to something higher-level before I wrote my own; I didn't find what I needed by googling.
16:27:59 <fen> so whats the function that turns a recursive definition into a difference list or DAG (just considering the linear case currently)
16:28:00 <fen> ?
16:29:02 <fen> sorry, it would surely need the recursive function to be written as a cyclic graph to begin with
16:30:05 <fen> thats why it seems to be an "intermideate" representation, as this graph would be produced from the haskell syntax
16:30:54 <fen> damn, that seems really hard to work with
16:31:41 <ski> zachk,Solonarv : hm, i may have managed to confuse myself there, sorry. to make `instance Bounded (exists a. Bounded a *> a)' we need to define `minBound,maxBound :: exists a. Bounded a *> a', which obviously can be done (they can even use different `a's) .. but i don't think this is useful
16:31:58 <Solonarv> yeah fair point
16:32:05 <zachk> ski, I can't even seem to show types using this data type data Object = forall a . Show a => Object a  :(
16:32:19 <fen> ski: whats this exists syntax you are using?
16:32:48 <fen> its not RnakNTypes...
16:33:06 <fen> is it ermine or something?
16:33:15 <ski> zachk : one can also consider more constraints, like `instance Bounded (exists a. (Bounded a,Foo a) *> a)' requiring `minBound,maxBound :: exists a. (Bounded a,Foo a) *> a', which can't (in general) use the *same* `minBound',`maxBound' as before (since the `a's we picked may not be instance of `Foo'. if they are, just pick another `Foo')
16:33:32 <ski> fen : existential quantification. pseudo-Haskell syntax
16:33:38 <fen> brarg
16:33:56 <fen> is it just a Default constraint?
16:33:57 <zachk> ski, whats *> ? 
16:34:11 <fen> :t *>
16:34:13 <lambdabot> error: parse error on input ‘*>’
16:34:18 <fen> :t (*>)
16:34:19 <lambdabot> Applicative f => f a -> f b -> f b
16:34:29 <fen> :t (>>)
16:34:30 <lambdabot> Monad m => m a -> m b -> m b
16:34:38 <ski> (please note that usually when people say "existential type" here, they either mean "the `data' encoding of existential types" or "the CPS encoding of existential types")
16:34:55 <ski> fen : `*>' is also pseudo-Haskell
16:35:39 <ski> fen : a value of type `forall a. ..a..', aka a polymorphic value is such that for any type `a' the user/consumer/caller picks, that value *can* be regarded as having type `..a..' for the particular type `a' chosen
16:36:40 <koala_man> I can successfully build a tool with 'stack build foo'. I want my CI system to copy the executable somewhere. How do I know where it ended up?
16:36:59 <fen> yeah RankNTypes makes sense, but not sure about what is CPS vs datatype encodings of existential types
16:37:39 <ski> fen : a value of type `exists a. ..a..', perhaps to be called an "abstract value" (there's a connection to abstract data types) is such that the definer/producer/callee has already picked some type `a', and a value of type `..a..' for that type `a'. so the value of type `exists a. ..a..' can be regarded (by the user) as being a value of type `..a..' for some *unknown*/*forgotten*/*hidden*/*abstract* type `a'
16:38:33 <ski> fen : now, a value of type `Cxt => ...' is a value such that, *if* the user/consumer/caller can manage to provide evidence of the constraint `Cxt', *then*, they may use the value as if it had type `...'
16:39:07 <fen> right, so the program doesnt work with any type, just some specific type, which is not being written explictly for some reason
16:39:28 <zachk> oh I just have to define the instances for the existential type!
16:39:51 <fen> well im glay *you* get it!
16:39:52 <ski> fen : while, a value of type `Cxt *> ...' is a value such that, the definier/producer/callee has *already* provided, and bundled evidence for the constraint `Cxt' together with a value of type `...'. so when using such a value, you freely get evidence for `Cxt', which you can use, in addition to a value of type `...'
16:40:16 <fen> WHAT!?
16:40:21 <fen> this is madness
16:40:41 <ski> fen : now, `=>' is mostly used together with `forall' as in `forall a. C a => ..a..', and likewise `*>' is mostly used together with `exists', as in `exists a. C a *> ..a..'
16:40:44 <fen> so its like the exists vs forall but for constraints?
16:41:05 <ski> `forall' and `=>' are both similar in a sense to `->'
16:41:21 <ski> and `exists' and `*>' are in the same sense similar to `(,)'
16:41:58 <ski> (`*>' is to `(,)', as `=>' is to `(->)')
16:41:59 <fen> oh, speaking of dual things, I think there is a hot chocolate company called rokoko
16:42:09 <ski> fen : what's madness ?
16:42:22 <fen> the opposite of which would be the "co rokoko coco co"
16:43:02 <fen> soory, please, go on with your discussion
16:43:20 <Calledine> hehe ris
16:43:52 <fen> and thanks, the syntax you describe is more clear now
16:44:18 <isd> Are there any problems with calling atomically inside of mask, assuming that the transaction doesn't ever call retry?
16:44:22 <ski> fen : `data' encoding of existential `exists a. C a *> F a' is `data SomeCF where WrapCF :: (exists a. C a *> F a) -> SomeCF' (obviously), which is actually written as `data SomeCF where WrapCF :: forall a. (C a => (F a -> SomeCF))' (extra brackets for emphasis)
16:45:15 <ski> this is because `(exists a. ..a..) -> ...' is basically the same thing as `forall a. (..a.. -> ...)', and similarly `(Cxt *> ...) -> ...' is basically the same thing as `Cxt => (... -> ...)'
16:46:13 <ski> (one can think of these as currying/uncurrying. but since we don't *explicitly* provide either type arguments (for `forall') or evidence (for `=>'), there's no syntactic difference between the values of the two sides)
16:46:16 <fen> not quite sure how communting with the parenthesis leads to that conversion
16:46:28 <ski>   WrapCF :: (exists a. C a *> F a) -> SomeCF
16:46:36 <ski>   WrapCF :: forall a. ((C a *> F a) -> SomeCF)
16:46:42 <ski>   WrapCF :: forall a. (C a => (F a -> SomeCF))
16:46:49 <ski> these are equivalent
16:47:08 <ski> therefore, a value of type `SomeCF' encode a value of type `exists a. C a *> F a'
16:47:51 <ski> are you saying you're not following why they should be equivalent (or why the two more general equivalences i gave before should be valid) ?
16:48:33 <MarcelineVQ> koala_man: if you just typed  stack build hlint  from within a project it'll end up at that project's snapshot bin dir, afaict the way to find this is  $(stack path --snapshot-install-root)/bin
16:48:37 <ski> anyway, note that the data constructor `WrapCF' is *polymorphic* in `a' (with constraint `C a' on it)
16:48:41 <fen> well, foralls seem to move through parentheses fairly normally so its not familiar to see why this changing of an exist into a forall and a *> into a => is happening
16:49:12 <ski> therefore, it's proper to also be able to write `data SomeCF = forall a. C a => WrapCF (F a)', instead of the GADT syntax `data SomeCF where WrapCF :: forall a. (C a => (F a -> SomeCF))'
16:50:00 <koala_man> MarcelineVQ: neat, thanks
16:50:06 <fen> how is the use of the pseudo-haskell syntax helpful?
16:50:25 <ski> (writing `data AllCF = GenCF (forall a. C a => F a)' is something else, here it's the *argument* of `GenCF' which is polymorphic, not `GenCF' instead. in fact, `GenCF' has a rank-2 type, `(forall a. C a => F a) -> AllCF')
16:50:37 <fen> that polymorphic dictionary version seems pretty easy to understand
16:51:06 <ski> fen : imho, it's clearer to be able to state the existential quantification directly, instead of having to invent a name for a data type encoding it, especially when refactoring the type
16:51:32 <ski> fen : also, because we might not yet want to decide on *which* of the two encodings of the existential that we want to use
16:51:50 <MarcelineVQ> koala_man: however, it is more direct to just tell stack where to place things:  stack --local-bin-path="path" build hlint --copy-bins  equivalently:   stack --local-bin-path="path" install hlint
16:51:56 <fen> this is all very distressing
16:52:05 <ski> the other encoding uses the general equivalence between `a' and `forall o. (a -> o) -> o' (which is related to CPS, and to a special case of Yoneda)
16:52:11 <mniip> hmm
16:52:55 <ski> namely, `exists a. ..a..' is equivalent to `forall o. ((exists a. ..a..) -> o) -> o', which by an earlier equivalence corresponds to (the rank-2) `forall o. (forall a. ..a.. -> o) -> o'
16:53:11 <mniip> so limits and colimits, if "general", are adjunctions?
16:53:38 <ski> so, if one wants to have `foo :: ... -> exists a. C a *> F a', then either one can define `SomeCF' as above, and go `fooData :: ... -> SomeCF'
16:54:03 <fen> oh no, dont combine adjections at this stage!
16:54:09 <ski> or one can go `fooCPS :: forall o. ... -> (forall a. C a => F a -> o) -> o'
16:55:18 <ski> `fooCPS' can be more appropriate if one expects the caller to want to take apart the existential directly. while `SomeCF' can be more appropriate when the caller doesn't necessarily want to do that directly, but rather wants to store it inside some data structure instead
16:55:34 <mniip> if for all F : J -> C, lim F exists, then C^J(Delta A, F) ~~ C(A, lim F) is an adjunction!
16:55:43 <fen> argh!
16:56:21 <ski> also, if we want `foo :: ... -> T (exists a. C a *> F a)', then we basically have to go the `SomeCF' way anyway (because of predicativity, we can't directly nest quantifiers inside type constructors, apart from `(->)')
16:56:32 <ski> (`T' could be a data structure, or a monad, or perhaps something else)
16:57:30 <ski> mniip : yep
16:57:35 <fen> why is it upper case?
16:57:47 <Calledine> tiepe filosofie I like them speculative sciences with this
16:57:54 <ski> (for small diagram categories `J', one usually says, because of size issues)
16:58:10 <ski> why is what upper case ?
16:58:12 <ski> `T' ?
16:58:13 <fen> oh its a type signature sorry
16:59:03 <fen> used to seeing monads as lowercase types with a constraint
16:59:13 <ski> fen : anyway, i invented (or started using) `exists' and `*>' in discussions, to *avoid* having to talk about these encodings all the time, when discussing existentials
16:59:27 <fen> well that didnt work!
16:59:35 <fen> but thanks for the explanation 
16:59:46 <ski> only because you asked the notation :)
17:00:24 <ski> also to try to better convey the essential thing (*what* we're trying to express) about existentials to newbies, before i add the additional complication of *how* to encode it in current GHC
17:01:34 <MarcelineVQ> koala_man: ping, making sure you saw last message
17:01:37 <ski> both in the case when i'm talking to someone who didn't know about what existentials was about, and when i'm talking to someone who already knows about both the concept and the encoding, i can (when suitable) ignore talking about the encoding, focusing on the concept, the essential thing
17:02:05 <ski> fen : e.g. examples like
17:02:11 <MarcelineVQ> koala_man: oh just having stack do it, to remove the brittleness of hoping we're asking about the right dir
17:02:14 <MarcelineVQ> *of
17:03:02 <ski>   mystery :: Bool -> exists a. (a,a -> a,a -> String)
17:03:06 <ski>   mystery False = (False,not,show)
17:03:07 <ski>   mystery True  = ("True",reverse,id)
17:03:25 <ski> which i think is easier to understand, conceptually, than going directly to encodings of that
17:04:41 <ski> or `type QueueOps a = exists q. ({- empty -} q,{- enqueue -} a -> q -> q,{- dequeue -} q -> Maybe (q,a))'
17:04:52 <Squarism> I want to create a DSL for creating nested forms that depend on their input. Im pondering what options I have. When-Then feels too crude and typed lambda calculus feels like way too much. Ive sketched the requirements here if someone feels hot on DSLs and the computation landscape. https://ideone.com/E1pgkv 
17:05:45 <ski> a value of type `QueueOps a' is intended to represent a particular implementation of queues over elements of (the specific) type `a', in terms of some unknown/hidden/abstract/opaque/forgotten implementation type `q'
17:05:59 <ski> two different such values, for the same `a', may well use different `q's
17:06:27 <fen> so you write; ((forall p a. p a => x) -> x) and (data DictAndValue p x :: forall a. p a => DictAndValue x) as (exists p a. p a *> x) ?
17:07:23 <ski> fen : in general, `x' may depend on `a' (otherwise it's not that useful)
17:07:38 <aplainzetakind> Warning: Installed version of cabal-install (2.2.0.0) is newer than stack has been tested with.
17:07:45 <fen> sure x could be e.g. f a
17:07:48 <fen> forall f
17:07:49 <aplainzetakind> So what version has stack been tested with?
17:08:01 <fen> or something... 
17:08:05 <ski> fen : and i'd state the first of those as `forall o. (forall a. p a => f a -> o) -> o'. what you said wasn't right
17:08:14 <fen> ok
17:08:43 <Axman6> I'm using a libraty where there are a lot of functions that look like fun1 :: Foo -> Bar -> a -> b -> Req c, fun2 :: Foo -> Bar -> g -> Req h, and I'm working in a transformer stack m which can provide Foo and Bar; is there an easy way to get back those functions so they allow me to not explicitly provide Foo and Bar, so I have `execute $ something fun1 a b >> execute $ something fun2 g`?
17:08:49 <Axman6> library*
17:08:52 <ski> (your `x' became `f a'. but the `x' in the first one shouldn't be `f a', but `o', which should be `forall'ed. also `p' shouldn't be `forall'ed there)
17:09:05 <fen> still not sure how that mystery function manages to have 2 different types 
17:09:06 <ski> fen : otherwise, yes
17:09:26 <ski> fen : which `a' is selected depends on the run-time value of the input of type `Bool'
17:10:07 <Axman6> I came up with something that looks like: something :: (Foo -> Bar -> a) -> m a, which can be used to write: something fun1 <&> \f -> f a b but it feels pretty awkward
17:10:28 <fen> as its kind of a way of writing e.g. a CPS encoding of forall a. ?
17:11:05 <ski> fen : `(False,not,show)' has type `(Bool,Bool -> Bool,Bool -> String)'. therefore it also has type `exists a. (a,a -> a,a -> String)') (it also happens to have type `exists a. (Bool,a -> Bool,a -> String)' and type `exists a. (Bool,Bool -> Bool,Bool -> String)', and `exists a. (a,a -> Bool,a -> String)', &c. these not being that useful, certainly not in this case)
17:12:01 <fen> hmm
17:12:06 <ski> fen : and `("True",reverse,id)' has type `(String,String -> String,String -> String)'. we can decide to hide as many or as few of the `String's in there by `a', but we *want* the particular pattern `exists a. (a,a -> a,a -> String)', keeping only one of the `String's concrete
17:12:23 <fen> ok
17:13:21 <ski>   mysteryData :: Bool -> Mystery
17:13:35 <ski>   mysteryData False = Hide False not show
17:13:48 <ski>   mysteryData True  = Hide "True" reverse id
17:13:50 <ski> given
17:14:08 <ski>   data Mystery = forall a. Hide a (a -> a) (a -> String)
17:14:29 <ski> (i also curried the data constructor `Hide', for simplicity, instead of having a single argument which is a triple)
17:14:37 <fen> sure
17:14:59 <c_wraith> isn't Hide basically just Stream String?
17:15:23 <c_wraith> hmm, no. it's slightly more constrained.
17:16:24 <ski> a use of `mysteryData' (that actually unwraps, rather than just stores/returns the value somewhere) would look like `case mysteryData (...) of Hide z f s -> ..z..f..s..', where the hidden type is brought into scope in the branch as an unknown (aka "rigid" or "skolem") type `a', and which isn't allowed to "escape" the branch (isn't allowed to occur in types outside the branch, e.g. the type of the whole `case'-`of'-expression
17:16:25 <c_wraith> well. maybe not. the constraint is that the steam has to be computable. but in computers that's a requirement either way
17:16:37 <c_wraith> *stream
17:16:42 <ski> the other encoding would be
17:17:03 <ski>   mysteryCPS :: forall o. Bool -> (a -> (a -> a) -> (a -> String) -> o) -> o
17:17:16 <ski>   mysteryCPS False k = k False not show
17:17:22 <fen> oh those errors about the escape of rigid skolems are the worst
17:17:30 <ski>   mysteryCPS True  k = k "True" reverse id
17:18:19 <ski> where a use now would look like `mysteryCPS (...) (\z f s -> ..z..f..s..)'
17:18:24 <c_wraith> I always am afraid the skolems are angry at me and dangerous.
17:18:37 <fen> they undoubtedly are
17:19:03 <ski> (i moved the `forall o.' to the front, since GHC will do that for you anyway)
17:19:34 <ski> (er, and i forgot to write the `forall a. ' in the type of `k', sorry)
17:20:30 <ski> i should perhaps also say that with the `data' type encoding of existentials, it's more properly the data *constructor* (not the type itself), which is "existential"
17:21:26 <ski> because you can have stuff like e.g. `data Exp a = Lit a | forall b. App (Exp (b -> a)) (Exp b)', where only *some* of the data constructors encode existential quantifiers
17:21:57 <fen> isnt this when GHC complains about impredictive polymorphism?
17:22:10 <fen> or is that just with types?
17:22:16 <ski> (but if there's only one data constructor, there's not much harm in the terminology "existential (data) type", as long as one remembers that the "real thing" is the existential quantification, and that we're doing a particular *encoding* of it)
17:22:20 <fen> (as opposed to datatypes)
17:22:39 <isd> Is there a way to just block indefinitely, only terminating if you get an async exception?
17:23:15 <koala_man> MarcelineVQ: turns out the stack version I'm targeting is too old for that flag :(
17:23:16 <c_wraith> isd, generally just use threadDelay and forever
17:23:19 <Axman6> forever yeild?
17:23:24 <Axman6> yield*
17:23:31 <ski> impredicative is when you have `T (forall a. ..a..)' (and presumably also `T (exists a. ..a..)' should be counted), where `T' is some other type than `(x ->)' or `(-> y)'
17:23:35 <isd> That was the backup plan. Works for me.
17:23:45 <koala_man> MarcelineVQ: oh no, just a typo. phew. thanks!
17:24:46 <mniip> ski, tell the tale of sigma, rho, tau, phi, and theta types
17:25:02 <mniip> no wait, theta is a substitution
17:25:19 <ski> fen : now, a rank-2 `blah :: (forall a. [a] -> [a]) -> (String,[Bool])' (which btw is not polymorphic at all) is in some sense similar to an operation with `exists' in the return type. both "contains" a hidden type inside the implementation
17:25:56 <ski> fen : however, because a rank-2 op may use its polymorphic argument more than once (or not at all), there may in fact be several (or no) hidden types that it uses for `a'
17:26:08 <ski> (there can be infinitely many as well, via polymorphic recursion, say)
17:27:11 <ski> fen : also note that for me "polymorphic value" means "value with type of shape `forall a. ..a..'" (especially note that the *type* `forall a. ..a..' is *not* polymorphic (in the terminology i prefer). i call it a universal type, or a `forall'-type)
17:28:59 <ski> (also, `a' is not a "polymorphic type variable". i've seen people use that turn of words as well, and i think it only adds confusion to the whole business. and `Maybe a' (or `Maybe') is not a polymorphic type, it's a parametric type, aka a type function. unfortunately, even some books call such "polymorphic data types")
17:29:49 <fen> :t []
17:29:50 <lambdabot> [a]
17:29:56 <ski> (i think these were most of my pet peeves with "polymorphic" terminology. you may or may not agree, i'm just stating what term usages i deem problematic, and trying to say why i think so)
17:30:19 <fen> [] :: forall a. [a] is a polymorphic type?
17:31:10 <ski> (`forall a. [a] -> [a]' is not polymorphic, since its kind is `*'. just as `not' is not polymorphic, since its type is `Bool -> Bool'. no `forall' on the right of `::' in either case)
17:32:03 <ski> (otoh, if you define `data Const c a = MkConst c', then you get `Const :: forall k. * -> k -> *', so `Const' *is* a polymorphic type !)
17:32:11 <fen> so the value [] is polymorphic, as is the type '[] ?
17:33:09 <ski> (because of the `forall' on the top-level of its kind. or rather that's how we notice it in syntax. `Const' is polymorphic, since it can assume kinds `* -> * -> *',`* -> (* -> *) -> *',`* -> (* -> * -> *) -> *',`* -> ((* -> *) -> *) -> *',&c.)
17:33:21 <fen> and Nothing is a polymorphic value but its type forall a. Maybe a is not polymorphic ?
17:33:48 <ski> (similarly, `reverse' is polymorphic, since it can assume types `[Bool] -> [Bool]',`[(Int,Char -> IO String)] -> [(Int,Char -> IO String)]',&c.)
17:34:17 <ski> the empty list value `[]' is polymorphic, its type is `forall a. [a]' (which itself is not a polymorphic type)
17:34:28 <fen> ok I think its clear, thanks!
17:34:36 <ski> `Nothing' is a polymorphic value, having type `forall a. Maybe a'
17:34:49 <fen> what was mniip saying before about ends and coends?
17:34:59 <fen> and a bunch of greek letters
17:35:02 <mniip> what
17:35:07 <ski> `exitSuccess :: forall a. IO a' is an example of a non-data-constructor value, that is not a function, but is still polymorphic
17:35:12 <ski> (there's also parser examples)
17:35:12 <mniip> unless you're referring to something that was months ago
17:36:22 <fen> if for all F : J -> C, lim F exists, then C^J(Delta A, F) ~~ C(A, lim F) is an adjunction!
17:36:23 <ski> fen : the reason why i'm being so strict about what's to count as "polymorphic type" is that i want "polymorphic" to mean "the same" (or analogous) property, whether we apply it to a value, or a type
17:36:34 <mniip> adjunctions not ends
17:36:42 <ski> fen : this is especially important, now that we have more extensions for doing computations on the type level
17:36:48 <mniip> none of the letters here are greek
17:36:53 <mniip> oh, Delta
17:37:08 <fen> nothing to do with nonholonomic type constraints?
17:37:13 <mniip> no
17:37:20 <mniip> wait what
17:37:22 <mniip> holonomic?
17:37:29 <fen> <mniip> ski, tell the tale of sigma, rho, tau, phi, and theta types
17:37:50 <fen> mniip: like <= instead of ==
17:38:15 <mniip> a holonomic constraint is one that doesn't depend on velocities but instead only on position and time
17:38:18 <fen> probably a bad idea
17:38:19 <mniip> I have no idea how that applies to haskell
17:39:38 <fen> anyway that definition isnt right; https://en.wikipedia.org/wiki/Holonomic_constraints
17:40:12 <fen> r^2 - a^2 = 0 compared to <= 0
17:40:42 <fen> its not type inequality or type equality, it might not be anything at all
17:40:45 <mniip> that's not the main point
17:41:05 <mniip> but also again that only applies to mechanical system
17:41:06 <mniip> s
17:41:16 <fen> not types?
17:41:22 <fen> damn
17:41:42 <mniip> I've never heard any of these words used with discrete constraints
17:41:42 <fen> ok, nvm, but what about these greek letters and adjuctions and limits?
17:42:46 <ski> yea .. there's a tradition in type inference for polymorphism to use `tau' as a meta-variable for types not involving `forall', and `sigma' as a meta-variable for types starting with an initial sequence of nested `forall's, then continuing with a type of `tau' form. i here choose to interpret the term "polytype" for types bound by meta-variables `sigma' as meaning "type of polymorphic value", rather than "polymorphic type"
17:42:55 <fen> i thought in linear logic types were supposed to be continuously differentiable?
17:43:21 <mniip> in what metric
17:44:06 <fen> like how zipper comonads are integration
17:44:24 <mniip> you said the word continuously
17:44:32 <fen> ah
17:44:33 <mniip> you left abstract algebra
17:44:34 <fen> ok
17:44:46 <fen> so no <= then
17:45:06 <fen> and maybe some lebegues around
17:45:08 <mniip> what's you proposed ordering on types for that to make sense
17:45:46 <fen> hmmm, isnt [] differentiable somehow?
17:46:45 <fen> probably limits and colimits and adjunctions are more accessible 
17:46:57 <mniip> haha
17:47:25 <fen> i didnt mean to upset anyone by surgesting non-holonomic type inequalities 
17:48:09 <fen> maybe the value intuition that types have algebric properties is too confusing
17:48:22 <fen> vague*
17:49:19 <fen> but there is precious little understanding of;
17:49:41 <fen> if for all F : J -> C, lim F exists, then C^J(Delta A, F) ~~ C(A, lim F) is an adjunction!
17:49:55 <fen> you cant say things like that and run off leaving no explanation 
17:50:31 <mniip> well I didn't say that to you
17:50:45 <mniip> rather to whoever here is familiar with category theory
17:50:52 <fen> even exponentials appearing as little power signs being supposed to mean something is confusing
17:51:12 <mniip> if you mean C^J that's just a functor category
17:51:22 <fen> now exponentials I can differentiate all day!
17:51:26 <mniip> similar notation is adopted in sets where X^Y is the set of functions from Y to X
17:52:02 <fen> oh right its that curry howard lambeck thing
17:52:27 <fen> propositions as types etc.
17:52:42 <dmwit> wut
17:52:50 <fen> you know
17:52:52 <fen> anyway
17:53:12 <fen> what about the ~~, lim F, Delta A 
17:53:33 <fen> ~~ is like ~ but different somehow, so maybe thats not important 
17:53:54 <fen> are limmits like fixed points?
17:54:22 <fen> what does the theorem you stated actually mean?
17:54:48 <fen> is the Delta a difference?
17:56:24 <fen> category theory for programmers! very accessible
17:57:55 <fen> oh well, at least we got that ^ is an exponential 
17:58:06 <fen> ie a function
17:58:11 <fen> ...
17:59:40 <mniip> except C and J are categories
17:59:52 <mniip> so C^J is a category of functors
18:00:03 <mniip> Delta is the diagonal functor C -> C^J
18:00:44 <mniip> lim F is the limit of the diagram that F embeds into C
18:01:20 <mniip> i.e an initial cone into the diagram
18:01:26 <ski>   Delta c = \j. c
18:02:09 <mniip> yes and Delta f  is the natural transformation whose components are all f
18:03:14 <ski> (hm, i started writing down stuff like that, re Yoneda's lemma, in my own (more explicit) notation. i should probably try to finish that some time)
18:03:37 <mniip> ski, I should figure all of this out in arrows-only notation
18:03:43 <mniip> I feel like it might be more compact
18:03:52 <mniip> and infinitely more rigorous than objects-only you often see
18:03:59 <ski> by "arrows-only" you mean here ?
18:04:18 <fen> the fisher information tensor can be used as a measure on the pace of neural networks defined by their weight vecotrs, and this can be extended to being a functional, how does that translate to category theory?
18:04:28 <fen> space*
18:04:53 <mniip> a category is a set with idempotent endofunctions dom and cod, and a partial compose
18:05:08 <fen> so no metrics
18:05:18 <mniip> a natural transformation maps a function x -> y to a function fx -> gy
18:05:30 <koala_man> I want to build my project with stack, but I'm getting a "Ignoring unknown section type: custom-setup". Can I have stack use a more modern Cabal than what it was built for?
18:05:33 <mniip> (s.t. some identities hold)
18:07:18 <mniip> even more rigorously, given F, G : C -> D, a natural transformation n maps arrows of C to those of D such that dom(nf) = F(dom(n)), cod(nf) = G(cod(n))
18:07:37 <mniip> where of course for any functor dom(Ff) = F(dom(f))
18:08:57 <fen> does the concept of an initial cone of a diagram embeded into a category by another category somehow relate to a metric space of weights?
18:09:09 <mniip> what
18:09:41 <fen> how are geometry and category theory used together?
18:10:01 <fen> (measure theory)
18:11:44 <fen> like, if a learning process is the specification of a path throught the space of possible weights of NNs, basically a convergent process, and similarly, the optimal learning direction being another kind of extreemisation, isnt that like a limmit?
18:12:57 <fen> or are the concepts of limmits as terminal objects of a convergent sequence totally unrelated to category theory?
18:13:09 <mniip> topological spaces under continuous maps or under homomorphisms, metric spaces under isometry, and manifolds under smooth maps are all examples of categories
18:13:22 <mniip> they are related but it's a very distant relationship
18:14:03 <fen> isnt it the kind of relationship that would be used to understand the realisation of such programs in a functional language?
18:16:09 <fen> the exmples you gave all seem to be mappings between different spaces, as opposed to geodesics as subsections of a space
18:16:41 <fen> a section does not seem to be a very smooth map
18:17:30 --- mode: glguy set +v Guest95
18:18:38 <Guest95> Hey all - I'm trying to write a binding to an HTTP API. I would ideally like to model each API operation as a newtype that's an instance of a typeclass that I have defined. My end goal is to essentially have a single entrypoint to the API that's something like
18:19:09 <Guest95> runOperation :: APIConnectionInfo -> Operation -> IO a
18:19:20 * hackage hs2ats 0.4.0.0 - Create ATS types from Haskell types  http://hackage.haskell.org/package/hs2ats-0.4.0.0 (vmchale)
18:19:34 <Guest95> Is there any way to write my typeclass/instances such that a can be derived from the Operation instance supplied
18:20:40 <Guest95> Sorry, I feel like this question is a little unclear. Essentially I would like to bundle the response type with the operation definition (since I know it ahead of time)
18:22:06 <fen> as in (MyConstraint Operation a) => ?
18:22:37 <Guest95> Hmm
18:23:15 <Guest95> Possibly (sorry I am still quite new to Haskell); a single Operation instance should have exactly one associated response type
18:23:25 <fen> or like, class MyConstraint operation where type getA operation :: * ...
18:23:59 <fen> sounds like an associated type
18:24:04 <Guest95> Yes
18:24:06 <Guest95> Right
18:24:21 <Guest95> Unfortunately I don't know enough to be able to find this information on my own right now :)
18:25:29 <Kaye> When I was searching for things about associated types earlier I was coming across a lot about type families, which didn't seem like quite what I was going for
18:26:06 <fen> you could learn about type families, associated types are just those type families appearing in classes, where the 'type family getA opperation ..' becomes 'type getA ...' when it appears within a class
18:26:11 <ski> mniip : right, ok
18:26:39 <Kaye> Hmm, okay. I can read into them more if you think that'll get me there
18:26:43 <Kaye> I'll report back 
18:27:10 <fen> good luck
18:28:16 <fen> mniip: so how does a function like iterate appear in Category theory? as in, has that got anything to do with limits?
18:28:53 <fen> or fixed points of hylomorphisms?
18:29:01 <fen> are they like terminal objects?
18:29:13 <ski> mniip : if `Arr' is the category with two objects, `Dom',`Cod', and one non-identity arrow `arr : Dom >---> Cod', then a functor `F : Arr >---> C' specifies objects `F Dom,`F Cod' in `C', and an arrow `F arr : F Dom >---> F Cod', and any arrow in `C' can be described by such a functor `F'
18:29:34 <mniip> right
18:29:42 <mniip> C^2 the category of arrows in C
18:30:06 * ski doesn't like using `2' for this category, preferring `2 = 1 + 1' to hold
18:30:17 <mniip> how about I the interval
18:30:29 <ski> (you could say something like `Ord 2', for the ordinal two)
18:30:41 <ski> mniip : not that bad, i suppose
18:31:02 <mniip> well mac lane uses digits for ordinal categories
18:31:05 <shachaf> I've also seen that category called →
18:31:16 <shachaf> Actually, no I haven't, that was a misunderstanding.
18:31:39 <mniip> well it wouldn't be inconsistent with other notation in mac lane
18:31:43 <shachaf> You could also call it [2] or something.
18:32:23 <mniip> in his notation ↓↓ stands for the category that is the domain for co/equalizer diagrams
18:32:44 <mniip> similarly -> . <- for pullbacks
18:33:22 <shachaf> I like Σ_{i ∈ [n]} for what's often written as Σ_{i=0}^{n-1} or Σ_{0 <= i < n}
18:33:34 <ski> mniip : if we like, we can consider functors `Dom_,Cod_ : 1 >---> Arr' given by `Dom_ () = Dom' and `Cod_ () = Cod', so then `F . Dom_,F . Cod_ : 1 >---> C' specifies objects in `C' as functors. given an arrow in `C' represented by a functor `F : Arr >---> C', its domain and codomain, represented as functors, are `F . Dom_,F . Cod_ : 1 >---> C'
18:34:08 <fen> is differention something like a pushforward?
18:35:02 <ski> mniip : given an object in `C' specified by `O : 1 >---> C', it's identity arrow is specified by `O . <>_Arr : Arr >---> C', where `<>_C : C >---> 1' is the unique morphism from the category `C' to the terminal `1'
18:36:09 <mniip> ok?
18:36:28 <mniip> not seeing anything spectacular yet
18:39:08 <fen> how obscure 
18:41:10 <mniip> shachaf, but [2] is the list of length 1
18:41:24 * hackage shake-ats 1.10.1.0 - Utilities for building ATS projects with shake  http://hackage.haskell.org/package/shake-ats-1.10.1.0 (vmchale)
18:43:09 <ski> shachaf : i sometimes write just ⌜∑_{i : n} a_i⌝ (or ⌜∑_{i < n} a_i⌝), alternatively ⌜(i <) n · a_i⌝. similarly ⌜∏_{i : n} a_i⌝ (or ⌜∏_{i < n} a_i⌝), alternatively ⌜a_i^{(i <) n}⌝
18:46:12 <fen> so is category theory too much about latices and not enought about dense or continuous spaces to be useful for understanding linear algebra processes?
18:46:31 <Lycurgus> it's not about lattices at all
18:46:40 <Lycurgus> or minor topic anywho
18:47:02 <Lycurgus> lattices of groups mayhap
18:48:36 <fen> it just seems really difficult to bridge the gap between hetrogenous graphs and dense homegenous regions with some connection.
18:49:20 <Kaye> @fen Type families have certainly gotten me close! And I feel like there is a way to get to the end. I have an associated type right now, but I can't seem to find a way to constraint it so that it must satisfy the FromJSON constraint
18:49:20 <lambdabot> Maybe you meant: wn run let free faq
18:51:04 <fen> you can place the constraint on the associated type at the class decleartion like; class (fromJSON (GetA object)) MyConstraint object where type GetA object; ... 
18:51:49 <fen> soory there should be a => after the constraint
18:52:01 <ski> mniip : sorry, got stuck on that ^. anyway, given `F,G : C >---> D' and `eta : F >---> G', we can represent `eta' by `eta_ : C >---> D^Arr' such that `eta_ c = \{Dom. F c; Cod. G c; arr. eta_c}', where we have `(c |-> (eta_ c) Dom) = F',`(c |-> (eta_ c) Cod) = G '
18:53:07 <ski> (btw, if `Arr' is an interval, it's a *directed* (oriented ?) interval)
18:53:45 --- mode: glguy set +v space_potato_900
18:55:08 <ski> btw, we can kleisli extend `eta_ : C >---> D^Arr' to `eta_^* : C^Arr >---> D^Arr' which given an arrow in `C', gives the diagonal of the naturality square in `D'
18:56:30 <ski> alternatively, we can uncurry `eta_' as `eta__ : Arr * C >---> D', so that `eta__ (i,c)' represents an interval in `D', `i' being the interval parameter
18:56:40 <mniip> hold on hold on
18:56:46 <mniip> is (- ^ Arr) a monad
18:57:01 <ski> well, it ought to be, unless i'm missing something
18:57:31 <ski> (the environment/input/reader monad, over `Arr' in this case)
18:59:35 <ski> (i suppose one could also cokleisli "preserve" `eta__' into `eta__^# : Arr * C >---> Arr * D', but i'm not sure whether that's useful)
19:01:15 <ski> anyway, considering `eta_ : C >---> D^Arr', instead of just thinking of it mapping objects of `C' into objects of `D^Arr' (arrows of `D'), we can think of it "abstractly" mapping generalized elements (diagrams) in `C' into ditto in `D^Arr'
19:02:25 <ski> e.g. such a diagram in `C' could be `Arr'-shaped (`i : Arr |- ..i.. : C', corresponding to a functor `f : Arr >---> C')
19:02:55 <fen> all this for one greek letter!?
19:03:20 <fen> oh wait there is something that looks like an adjunction
19:03:50 <shachaf> ski: I think ∈ isn't quite a good symbol to use for Σ anyway, because addition is ordered.
19:03:58 <shachaf> Though I suppose it doesn't matter in the finite case.
19:04:44 <shachaf> But if you wrote Σ_{i ∈ ω} it would look problematic.
19:04:59 <ski> so then `eta_ . f : Arr >---> D^Arr', which uncurries into a functor of type `Arr * Arr >---> D'. if we compose with `Delta : Arr >---> Arr^2', that corresponds to selecting the diagonal `uncurry (eta_ . f) . Delta : Arr >---> D' out of the naturality square `eta_ . f : Arr >--> D^Arr'
19:05:22 <shachaf> I wonder whether anyone writes something like Σ_{i ∈ ω+1} f(i) where f is a convergent function.
19:05:53 <ski> shachaf : yea, that's a good point, about the potential ordering
19:06:27 <fen> [x|x<- ...] has intrinsic ordering
19:06:38 <shachaf> I've thought about this problem with Σ before but it didn't occur to me until today that Σ takes an ordinal.
19:06:58 <shachaf> Though I guess it should be obvious that it does something like that.
19:07:31 <koz_> If I'm planning to read CSV with Cassava, should I 'load in' the ByteString it expects with readFile, or hGetContents?
19:07:37 <koz_> What's the difference between them?
19:07:52 <fen> somthing about Enum and Ix...
19:08:11 <lyxia> koz_: one takes a filename one takes a handle?
19:08:21 * hackage ats-pkg 3.2.3.0 - A build tool for ATS  http://hackage.haskell.org/package/ats-pkg-3.2.3.0 (vmchale)
19:08:26 <koz_> lyxia: Oh, lol. So what's a Handle?
19:09:02 <ski> shachaf : where ⌜ω+1⌝ is supposed to mean the generic convergent sequence, the one-point compactification of ⌜ℕ⌝/⌜ω⌝ ?
19:09:28 <fen> some of the things you say make me want to cry
19:09:30 <shachaf> Right.
19:09:31 <lyxia> koz_: to a first approximation, it's an open file.
19:10:04 <lyxia> koz_: what do the docs say
19:10:15 <shachaf> What is the argument of Σ? Is it something other than an ordinal?
19:10:16 <koz_> Ah, I think I see.
19:10:35 <koz_> Basically, by the looks of it, I should use readFile, since I don't really care about buffering or encoding.
19:11:00 <fen> whats all this about compactification!? are we doing string theory now or what?
19:11:16 <ski> (i wonder how that not constructively being ⌜ω+1⌝ (with ⌜+⌝ being disjoint union / coproduct) can be thought of in terms of (constructive) ordinals)
19:13:45 <fen> do you mean "the next value"
19:15:02 <shachaf> ski: Ordinal addition isn't commutative so I'm not sure how much you can relate it to coproducts.
19:16:54 <Kaye> fen: Unfortunately that doesn't seem to work because it seems to assume that my operation type must be FromJSON when in reality it's the associated type that I need to constrain
19:17:08 <Kaye> I looked into Data Kinds and even TypeInType but neither of those seem to get quite there either
19:17:09 <ski> fen : ⌜ℕ_∞⌝ is defined as ⌜{f : ℕ → 2 | increasing f}⌝, where the inclusion ⌜ι : ℕ → ℕ_∞⌝ is given by ⌜ι n i = (n ≤ i)⌝
19:17:17 <ski> shachaf : *nod*
19:17:28 <fen> :t range
19:17:29 <lambdabot> Ix a => (a, a) -> [a]
19:18:21 <ski> fen : ⌜ℕ_∞⌝ being (the generic convergent sequence, the) said one-point compactification of ⌜ℕ⌝
19:19:10 <shachaf> Is there a natural topology for ordinals that gives you the discrete topology for finite ordinals and ω and the one-point compactification of ℕ for ω+1?
19:19:20 <ski> (note that ⌜increasing f⌝ is a proposition, it has at most one proof)
19:19:23 <fen> Kaye: you must have written it wrong, the associated type takes the argument (your "opperation type" - the parameter to the class) and the constraint is over this
19:19:42 <ski> shachaf : i dunno. wouldn't be surprised
19:20:12 <shachaf> And if so what does it give for ω+2, ω+ω, etc.?
19:20:30 <ski> yeap, that's what i was wondering .)
19:20:33 <Kaye> Yeah, that is the issue I think. Perhaps I've written the whole thing incorrectly because that isn't the thing I want to constrain. Btw I think I could get this to work with MultiParamTypeClasses and AllowAmbiguousTypes but I really don't want to do that
19:20:56 <fen> nono, all these extensions you mention are not needed
19:21:25 <Kaye> Yeah I'm probably confusing something
19:21:33 <fen> just constraint the associated type instead of the argument to it
19:21:40 <Kaye> Basically, I need the * in the associated type to be constrained to FromJSON
19:21:56 <Kaye> OH
19:22:04 <Kaye> I think I am associating data
19:22:06 <Kaye> And not a type
19:24:11 <Kaye> Nope, still the same problem, because it's the * that I want to constrain here which I do not know how to do
19:25:25 <ski> shachaf : hm, i hadn't thought of a convergent series as being indexed by an ordinal, before ..
19:25:34 <fen> yes, the type of kind * that results from applying the type opperator GetA to the parameter that the class is defined over 'operation' is what appear in the constraint. thats FromJSON (GetA operation), not FreomJSON operation
19:26:27 <ski> shachaf : what if one takes other ordinals greater than ⌜ω⌝ (or ⌜ω+1⌝) ? what kind of series is that ?
19:27:05 <shachaf> I'm not sure whether it makes sense.
19:27:45 <fen> convergence acceleration?
19:28:49 <ski> mniip : btw, what i was talking about wasn't really that deep, just some reflections on how one can conceive of NTs if one doesn't want to look "inside" categories, talking about objects and arrows via functors, iow being pointless on this level as well (but not on the next)
19:29:25 <ski> (it may be that i had some more realization about this, when i thought about it last time (several years ago). i don't recall)
19:29:30 <shachaf> If Σ_{i : ω} f(i) converges then presumably it converges to the same value as Σ_{i : ω+1} f(i), anyway?
19:30:32 <ski> shachaf : hm, istr i recall hearing that one can e.g. measure the diameter of a graph with an ordinal
19:30:33 <fen> not if you violate the cfl condition wrt the chaircteristics
19:30:45 <mniip> ski, my prolem was that you can't write \x y -> x to mean a functor
19:30:47 <ski> coinciding with the usual notion of diameter, in the finite case
19:30:53 <mniip> because you didn't specify actions on morphisms
19:31:11 <shachaf> In fact maybe you can say something like Σ : (o : Ordinal) -> (o -> R) -> (o+1 -> R) for the series of partial sums
19:31:33 <ski> mniip : yea .. that's one of the things that i hope to fix with my notation (not shown above)
19:31:43 <shachaf> This is like scanl (+) 0 but also applying to infinite sum
19:31:44 <shachaf> s
19:32:06 <fen> like when representing a pde as a system of odes
19:32:18 <fen> and then you need 2 initial conditions
19:32:24 <fen> like a verlet algo
19:32:55 <fen> :t mapAccumR
19:32:56 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
19:33:23 <fen> except then its hard to express a central difference scheme
19:33:41 <Kaye> fen: I needed FlexibleContexts, but now it's working!
19:33:47 <Kaye> Thank you so much!
19:33:49 <fen> yay!
19:33:55 <Kaye> Did I so something wrong to need that extension?
19:34:06 <Kaye> s/so/do/g
19:34:20 <ski> that's a pretty harmless extension
19:35:06 <Kaye> It seemed innocuous, I'm just trying to make sure that I'm not abusing things as I'm learning
19:35:12 * ski didn't follow what context Kaye ended up using
19:35:27 <infinity0> is there a "standard" way of recursing through a DAG but only visit each node once? i.e. the structure is similar to a tree but one should be able to detect when you're visiting the "same" node via different paths
19:35:29 <ski> (are you using associated types ?)
19:35:53 <infinity0> one issue with just implementing a normal breadth-first search is that you lose some ability to parallelise stuff (using *> instead of >>)
19:35:59 <ski> infinity0 : i suspect that something based on IVars could be used for that
19:36:20 <Kaye> ski: Yup, final signature for the beginning of the typeclass is
19:36:28 <infinity0> hm but i'd like to do this outside of IO..
19:36:32 <fen> infinity0 thats just traverse, there are no cycles
19:36:42 <Kaye> class (FromJSON (Response a)) => Operation a where type Response a :: * 
19:37:06 <Kaye> Which allows my entrypoint function to look like
19:37:13 <ski> (or something similar to IVars, but without a write operation)
19:37:16 <ski> @hackage ivar-simple
19:37:16 <lambdabot> http://hackage.haskell.org/package/ivar-simple
19:37:21 <Kaye> doThing :: (Operation a) => a -> IO (Wreq.Response (Response a))
19:37:22 <infinity0> fen: is there an example of that working for a DAG?
19:37:37 <fen> well a list is a DAG no?
19:37:54 <ski> fen : i think infinity0 wants to encode the sharing explicitly, somehow
19:38:01 <infinity0> sure, so if it's cyclic then traverse doesn't terminate
19:38:04 <infinity0> i want explicit termination
19:38:05 <fen> what sharing?
19:38:22 <fen> oh, a cyclic graph
19:38:30 <ski> acyclic
19:38:39 <infinity0> the graph is actually acyclic, but the important point is to detect when you're visiting the same node twice
19:38:54 <infinity0> it's easy to define traverse recursively for a tree-like structure, but it's less trivial if you want different branches to collapse
19:39:12 <monochrom> fgl has functional breadth first search.
19:39:15 <fen> the best way to write those is to have a different constructor so that the cycles can be detected to avoid retraversal, thought that does make the comonad instance and stencils on it a little difficult
19:39:47 <ski> infinity0 : if you look at `ivar-simple', you see that there's an instance `Eq (IVar a)' that isn't constrained by `Eq a'. also there's an operation `IVar a -> a'. however, ignore/scrap the write operation
19:39:54 <infinity0> another property i'd like is to be able to use *> to parallelis the traversal when needed
19:40:03 <ski> (also scrapping `new', keeping `newFull')
19:40:31 <fen> wait, whats this about paralell traversal?
19:40:34 <infinity0> but obviously this is conditional on the nodes being in independent paths. for grandchild nodes we'd need to use >>
19:40:38 <fen> over one graph?
19:40:50 <fen> oh right, a tree
19:40:56 <ski> infinity0 : if we call the result `IDVar', then an `IDVar a' contains an `a', and a unique ID, that can be used to check when two nodes are the same
19:41:48 <mniip> reallyUnsafePtrEquality#
19:42:07 <ski> yea, i'm not talking about that :)
19:42:09 <fen> anyway, a tree that has a different constructor for branches which are cyclic connections can be used so the traversal just proceeds as normal
19:42:16 <infinity0> ski: i'm also trying to do this outside of IO
19:42:44 <ski> allocating an `IDVar a' (specifically the ID inside) would be an effectful operation. one could imagine using `ST' rather than `IO', though
19:42:50 <fen> as it wont encounter any repeated nodes, there is no need to worry about how the parallelisation works
19:43:11 <ski> infinity0 : the building of the DAG also, or just the traversal ?
19:43:21 <infinity0> fen: do you have a concrete example, i fail to see how that's possible in advance. you don't know in advance that the children might share grandchildren
19:43:42 <fen> if they do, you wont be able to specify a traversal instance
19:44:03 <fen> its up to you to construct it so that there is only one path to each node
19:44:08 <infinity0> the DAG is pure, and i'd like to traverse it and execute an action for each node, only visit each node once, and do stuff in parallel that can be done in parallel
19:44:43 <infinity0> so take the example of A -> (B, C, D) and D -> (E, F, G), B C and D can have their actions executed in parallel using *> or something, but the action for E can only happen after traversing D
19:44:45 <fen> it will not terminate if the different constructor for cyclic connections is not used propoerly
19:44:52 <fen> hmm, thats tricky
19:45:13 <fen> just build you cyclic graph carfully, and dont call it a DAG if its cyclic
19:45:22 <infinity0> it's weakly cyclic
19:45:28 <fen> meaning?
19:45:52 <infinity0> the standard meaning, which is that the edges are directed and cycles exist if you consider the edges as being undirected
19:46:04 <infinity0> but no cycles exist that solely go "forwards"
19:46:58 <fen> well a shared descendent node is the important point anyhow
19:47:03 <infinity0> i can of course easily write a breadth-first search based on a queue but then there is no parallelism here
19:47:22 <fen> is carful construction and explicit choice of the chosen traversable ordering not an option?
19:47:40 <infinity0> what does "careful" mean here?
19:48:07 <fen> dont forget to choose and label which branch a node is part of
19:48:39 <fen> that is, pick one traversable ordering
19:48:56 <infinity0> ah during construction you mean. i'd like to avoid that yes
19:48:59 <fen> otherwise the sared descendent nodes leave this ambiguous
19:49:16 <infinity0> choosing a traversal order is fine
19:49:21 <infinity0> but not during construction
19:49:33 <fen> how are you going to do that!?
19:49:56 <fen> there is not a way to specify the traversable instance except this way, unless im missing something
19:50:29 <fen> not during construnction...
19:50:41 <fen> its supposed to have any number of choices of traversable instances?
19:51:03 <infinity0> i mean, it doesn't have to be "instance Traversable", i don't care too much about that
19:51:04 <fen> to be specified when?
19:51:17 <fen> you do care about that
19:51:35 <fen> thats this order of visitation you requsted earlier
19:51:44 <infinity0> well are DAGs in general instances of Traversable?
19:52:18 <infinity0> traverse says "Map each element of a structure to an action, evaluate these actions from left to right,"
19:52:20 <fen> there could be many, and it would need to be specified hich is to be used
19:52:21 <infinity0> with a DAG there is no "left to right"
19:52:25 <infinity0> it's a partial order not a total order
19:52:40 <fen> that leaves the traversable instance ambiguous
19:52:45 <fen> it must have a total order
19:52:54 <infinity0> i guess i was hoping if haskell had a PartialOrderTraversable but i guess not, heh
19:53:11 <fen> how would that work? a race?
19:53:26 <fen> its not type safe
19:53:56 <infinity0> i guess the f cosntraint would be something other than Applicative, but i don't know what
19:54:43 <fen> that depends if its fine to consume the braches to a single value before using this in the chain of applicatives of the other branch
19:55:06 <fen> then it is exactly Applicative, and Traversal that is needed
19:56:38 <ski> fen : if we assume a commutative idiom or monad ..
19:57:30 <fen> ski: when?
19:57:39 <ski> when traversing
19:57:46 <ski> so that order of actions doesn't matter
19:58:15 <fen> right 
19:58:34 <fen> like summing all the values at the nodes
19:58:45 <fen> it does not matter which branch is summed first
19:59:28 <infinity0> yeah that's fine for what i want to do
19:59:32 <fen> :t mconcat
19:59:33 <lambdabot> Monoid a => [a] -> a
19:59:35 * ski . o O ( `abtraverse :: (AbApplicative i,AbTraversable t) => (a -> i b) -> t a -> i (t b)' )
20:00:08 <fen> whats that?
20:00:15 <ski> an imagine operation
20:00:20 * hackage extensible-effects-concurrent 0.7.2 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.7.2 (SvenHeyll)
20:00:21 <ski> s//d/
20:00:37 <infinity0> the issue is that the children have to be traversed after the parent, so we can't just collapse the DAG structure into a list and execute everything in parallel
20:01:02 <ski> infinity0 : hm, ok. breadth-first ?
20:01:23 <infinity0> one hand-wavy way to think about it is that combining the actions is commutative but not associative
20:01:23 <ski> hmm
20:01:46 <infinity0> i haven't seen any BFS implementations that doesn't use a linear queue
20:01:53 <infinity0> i guess i could try writing one though
20:01:54 <fen> well again, that would require some direction for the order of traversal
20:02:18 <infinity0> anyway nvmd, this is not urgent for me, was just wondering if it was a common problem
20:02:20 <ski> well, you have a control dependency on actions that are below each other in the DAG, i assume
20:02:22 * hackage extensible-effects-concurrent 0.7.3 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.7.3 (SvenHeyll)
20:02:24 <infinity0> i can do with visiting each node twice for the time being
20:02:54 <infinity0> right yes the DAG encodes the control dependency as well
20:03:04 <ski> with depth-first on a tree, you get this anyway. but with multiple occurances (paths) in a DAG, it's harder to ensure
20:03:28 <ski> (with preorder depth-first, i.e.)
20:03:53 <fen> what is this control dependency? does it alter the order of visitation?
20:04:26 <ski> if `B' is a (transitive) child of `A', then `A' should be processed before `B'
20:04:48 <infinity0> the order of visitation is exactly specified by the DAG
20:04:57 <ski> so if `B' has multiple parents (because of DAG), then they (and their transitive parents) have to be processed before `B'
20:04:58 <fen> thats good!
20:05:32 <fen> ski: thats bad
20:05:47 <ski> it's what infinity0 wants, afaicu
20:05:55 <fen> yes, yes, thats bad
20:06:02 <fen> oh no
20:06:03 <infinity0> right. by "exactly specified" one might also call it "underspecified", because it's a partial order not a total order
20:06:15 <infinity0> but the underspecification could in theory allow for parallelism
20:06:35 * ski . o O ( "exactly specified partial order" vs. "underspecified total order" )
20:06:42 <infinity0> if you want a concrete example you can think of writing a lazy-evaluator for haskell itself
20:06:59 <infinity0> my real-world use case is a bit different but similar, will take longer to describe
20:07:20 <infinity0> you have a AST that is a DAG because parts are shared
20:07:38 <infinity0> you want to evaluate it and do some stuff in parallel, but the DAG structure describes the dependencies between different subexpressions
20:08:04 * ski . o O ( macros duplicating sub-ASTs )
20:08:37 <fen> well this does not seem like a traversable instance at all!"
20:09:27 <ski> of course not
20:09:52 <fen> can the order of visitation even be determined?
20:10:18 <infinity0> well of course, as we said one can do BFS but that means no parallelism
20:10:23 <suzu> there's a child support joke somewhere in here
20:10:33 <fen> woop!
20:10:41 <koala_man> how can I pre-download Hackage packages for cabal-install?
20:10:49 <koala_man> I want to install them offline later
20:11:29 <fen> yes, the parallelism and such is mighty confusing
20:12:09 <MarcelineVQ> koala_man: using?
20:12:18 <koala_man> what?
20:12:35 <fen> MarcelineVQ: presumably cabal
20:12:40 <MarcelineVQ> well are you using cabal-install, or getting packages cabal-install depends on?
20:12:42 <maerwald> There is a way to download entire hackage and uses it, but I don't know off-hand how
20:12:59 <ski> infinity0 : i wonder whether something like `abtraverse' couldn't work, if you first stratify according to level
20:13:03 <koala_man> MarcelineVQ: yes, I'm using cabal-install. but I want to download all the packages on a different machine first
20:14:27 <infinity0> ski: the type signature looks fine but how would one implement it?
20:14:33 <koala_man> there's no cabal fetch --dependencies-only
20:15:31 <MarcelineVQ> you can't  cabal install foo --only-dependencies  ?  or in a project  cabal install --only-dependencies  ?
20:15:50 <fen> ski: is that like taling its transpose?
20:16:13 <infinity0> ski: actually AbApplicative can probably just be Monad, basically we need to sometimes to sequenced actions but sometimes actions in parallel, assuming that is allowed by Monad
20:16:26 <koala_man> MarcelineVQ: no. my cabal version has a proxy bug, so it can't download anything
20:16:42 <fen> how would join help?
20:16:45 <koala_man> I'm trying to work around it by pre-downloading using a different tool
20:16:50 <ski> infinity0 : well, `abtraverse' wouldn't give any guarantees about ordering of actions (or rather, it would only work when the idiom you use promises ordering to not matter (at all))
20:17:24 <ski> infinity0 : so in that case, there'd need to be a separate stratification step .. not sure how ugly this would be
20:17:25 <MarcelineVQ> So you're asking, how can I download dependencies for a cabal project without using cabal-install?
20:17:46 <koala_man> MarcelineVQ: pretty much
20:18:00 <ski> anyway, it should be possible to have a parallel version of `abtraverse', i think ..
20:18:05 <MarcelineVQ> hmm, no clue here, someone else may know
20:18:15 <MarcelineVQ> Is this a known bug?
20:18:27 <koala_man> yes, and it was fixed three years ago
20:18:38 <fen> that would just make a list at each level, and progress along each branch simultaniously, probably having a list of all active branches which gets braches added to it as they split
20:18:50 <ski> with dependencies (perhaps expressed using `Par' monad or similar ?), i'm not quite sure how to nicely express it
20:19:22 <ski> infinity0 : `Monad' itself doesn't give any parallel composition primitive
20:20:20 <infinity0> ski: what about (>>) which is the same as (*>) ?
20:20:21 <ski> infinity0 : btw, ty for the interesting problem (it reminds me of something somewhat similar i wanted to be able to express)
20:20:30 <infinity0> ah, welcome :)
20:20:41 <infinity0> i mean, for most monads (>>) is sequential, but the type signature doesn't force it to be sequential
20:20:56 <infinity0> one could imagine a monad where (>>) is parallel but (>>=) is sequential right?
20:21:04 <ski> `(>>=)' is inherently asymmetrical. `(<*>)' (or `liftA2 (,)', if you prefer), is better in that regard
20:21:24 <fen> % :t (>=>)
20:21:24 <yahb> fen: forall {m :: * -> *} {a} {b} {c}. Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:21:57 <ski> `(>>)' has a law `act0 >> act1 = act0 >>= \_ -> act1', which enforces a particular sequencing
20:22:30 <fen> % :t (<*>)
20:22:30 <yahb> fen: forall {f :: * -> *} {a} {b}. Applicative f => f (a -> b) -> f a -> f b
20:22:59 <ski> infinity0 : hmm
20:23:02 <fen> oh, they are not easy to comapre, sorry
20:23:46 * ski idly wonders since when `{'&`}'s, rather than `('&`)'s are used with `forall'
20:23:53 <fen> yah, im out. ciao
20:24:22 <infinity0> so there is (*>) with applicative laws, not sure if that is forced to be sequential if the surrounding monad is sequential..
20:24:23 --- mode: glguy set -qo $~a glguy
20:25:25 <MarcelineVQ> % :set -fno-print-explicit-foralls
20:25:25 <yahb> MarcelineVQ: 
20:25:26 <MarcelineVQ> % :t (>=>)
20:25:26 <yahb> MarcelineVQ: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:25:31 <infinity0> cos usually people define (*>) = (>>) for their applicative instance
20:27:53 <ski> well, monads express "dynamic sequencing", while idioms express "static sequencing" (my terms / ways of expression)
20:28:19 <ski> but since you're talking about traversal, we only need (something like) the latter here, i think
20:44:51 * hackage network-byte-order 0.0.0.0 - Network byte order utilities  http://hackage.haskell.org/package/network-byte-order-0.0.0.0 (KazuYamamoto)
20:45:49 <orzo> I used a library once that had an interface that gave me a result + error code, and that if i ignored the error code, I could consume the result lazily 
20:46:21 <orzo> i have a similar interface now and I want to see what other people have done with that (constructor names and so on)
20:46:35 <orzo> but i don't remember a library that does that
20:46:49 <orzo> anyone know an example?
20:47:17 <c_wraith> uu-parsinglib, maybe?
20:50:27 <orzo> i'm looking at haddock for that and haven't found the relevant type
20:51:32 <orzo> i guess execParser
20:51:36 <orzo> they return a pair
20:52:07 <c_wraith> that's the one I was thinking of
20:53:25 <jle`> infinity0: it is forced that (*>) = (>>) if the type has both an Applicative and Monad instance
20:54:24 <jle`> infinity0: so a type where (*>) is parallel and (>>) is sequential (like simon marlow's famous haxl lib) is not law-abiding
20:54:36 <koz_> Is there any particular reason why unboxed Vectors lack a Foldable instance?
20:55:11 <glguy> They require the types to have Unbox instances
20:55:21 <glguy> While Foldable promises to work for all types
20:55:35 <c_wraith> You might actually be able to write a Foldable instance
20:55:47 <c_wraith> As it never creates a t
20:55:58 <c_wraith> It only reads the values
20:56:04 <jle`> it's in a weird spot
20:56:21 <koz_> glguy: Wouldn't this disqualify the Foldable instance for Set, then?
20:56:22 <glguy> You'll find it hard to do anything with the vector in the Foldable instance implementation
20:56:27 <jle`> since all of the accessing requires Unbox a
20:56:31 <infinity0> jle`: ah thanks for the clarification. that's a shame, i wonder if something else exists that does have the semantics we want
20:56:39 <glguy> koz_: No, you don't need to know the Ord instance to get the elements out of a Set
20:56:56 <glguy> (!) :: Unbox a => Vector a -> Int -> a
20:57:21 <glguy> Data.Set.toList :: Set a -> [a]
20:57:23 <glguy> No Ord
20:57:38 <koz_> glguy: Ah, I see.
20:57:38 <jle`> infinity0: i don't think we really want that, because substituting (>>) with (*>) or liftM2 with liftA2 is someting we do without thinking about changing anything observable
20:57:41 <koz_> That makes sense.
20:58:03 <infinity0> jle`: i mean a different typeclass
20:58:28 <jle`> it's in a weird spot because it's impossible to *construct* an unboxed vector with an types that aren't instances of Unbox
20:58:57 <glguy> It's not enough to know that it was constructed correctly, you have to actually know how to index the packed representations
20:58:58 <jle`> but the type signature of Foldable methods doesn't work
21:00:34 <jle`> it'd technically be possible if you wrapped unboxed vectors with an associated Unbox instance
21:01:10 <c_wraith> Yeah, you could have a wrapper for an unboxed vector that makes it a Foldable
21:01:19 <jle`> data Vector' a = Unboxed a => Vector' (Data.Vector.Unboxed.Vector a)
21:03:23 <jle`> but it's a little inefficient because you have to store a copy of the reference for every vector
21:03:45 <jle`> a copy of the a reference to the typeclass dictionary
21:07:01 <heptahedron> I think I finally got a minimal dependently-typed language implementation working!
21:08:33 <jle`> congrats :D
21:09:01 <fresheyeball> hey out there
21:09:08 <heptahedron> thanks haha, I considered this to be a goal for quite a while
21:09:18 <fresheyeball> is there a way to tell what MVar is causing a "blocked in MVar Operation" error?
21:09:27 <fresheyeball> I have a stack trace, but it's not that helpful
21:09:30 <heptahedron> unfortunately not really sure of any good expressions with which to smoke test it to make sure I haven't made any glaring mistakes 
21:26:18 <suzu> fresheyeball: why is the stack-trace not helpful?
21:26:26 <suzu> are you working with multiple mvars in the same function?
21:27:53 <fresheyeball> suzu I have more than one exception in there
21:28:02 <fresheyeball> I can't tell which one is the problem
21:28:09 <suzu> time for wolf-fence debugging
21:28:12 <suzu> Debug.Trace?
21:29:24 <fresheyeball> what is wolf-fence?
21:30:11 <MarcelineVQ> it's when you stack up a few wolves to dim the light a little but let the wind through
21:30:19 <suzu> lol
21:30:30 <suzu> its when you try to search for the problem with debug prints
21:36:26 <Athas> Is there a way to refer to specific Hackage revisions in extra-deps in stack.yaml?
21:36:42 <koz_> I haven't ever heard of 'wolf-fence' debugging.
21:36:44 <suzu> you can add version numbers
21:36:45 <koz_> TIL I guess.
21:38:20 <MarcelineVQ> Athas: is this what you mean?  - algebraic-graphs-0.1.1.1@sha256:af54e89839521f04f3b4bd980112701a31c7cf0d612776f8aa65083bcd1f3090
21:39:17 <Athas> MarcelineVQ: which revision will that pin?
21:39:42 <MarcelineVQ> I've no idea, it was machine-made ^^;
21:39:50 <Athas> I specifically want to use the newest revision of haskell-src-meta-0.8.0.3 (r2), but it looks like stack is picking up the first/original revision.
21:40:25 <Athas> It took several weeks just to get the author to put up the revision bumping the 'base' bound so GHC 8.6 will work, and I little patience for waiting another few weeks to get a new release as well...
21:40:50 <Athas> s/little/have little/
21:41:35 <Athas> And s/author/maintainer/, I guess.  I don't really blame anyone.
21:42:54 <MarcelineVQ> hmm the docs say that  - haskell-src-meta-0.8.0.3   should use the most recent revision there is, did you try a  stack update?
21:43:02 <Athas> I did not.
21:43:20 <Athas> Lovely, that seems to do the trick.
21:43:23 <MarcelineVQ> nice
21:43:30 <Athas> stack normally seems to update on itself.  What's the policy here?
21:44:08 <MarcelineVQ> stack update updates the hackage references specifically, I guess it hadn't been long enough since that was done to warrant rechecking? dunno really
21:44:48 <geekosaur> doesn't it rely on a mirror + index job on aws?
21:45:05 <geekosaur> which may not be running often enough to have caught this
21:54:17 <dminuoso> % :set -XDataKinds
21:54:17 <yahb> dminuoso: 
21:54:25 <dminuoso> % data Te = Ta | Tb | Tc
21:54:25 <yahb> dminuoso: 
21:54:30 <dminuoso> % data F (a :: Te) = F
21:54:30 <yahb> dminuoso: 
21:54:34 <dminuoso> % f :: forall (a :: Te) (b :: Te). (a ~ b) => F a -> F b -> (); f = undefined
21:54:35 <yahb> dminuoso: 
21:54:47 <dminuoso> Is there a way to constrain it such that `a !~ b`
21:55:43 <MarcelineVQ> in the source it seems like it only updates the indices if it can't find the version of a package you've asked for in the snapshot/known-hackage
21:56:14 <MarcelineVQ> Athas: ah k so the syntax for revs is   - acme-missiles-0.3@rev:0   0 being original
21:56:42 <MarcelineVQ> So if you had said rev:2 it wouldn't have had it in the indices, presumably, and probably done an update at that time
21:56:50 <dminuoso> Im really wondering why we do not have an inequality constraint. Does this impose restrictions on type inference?
21:57:31 <dminuoso> I mean I could go this route
21:57:34 <geekosaur> it's problematic when new instances and types can appear in the future
21:57:35 <dminuoso> % :set -XTypeFamilies
21:57:36 <yahb> dminuoso: 
21:57:41 <geekosaur> there's a hack,with limitations, iirc
21:58:21 <dminuoso> yahb: data True; data False; type family Neq a b where Neq a a = True; Neq a b = False
21:58:23 <dminuoso> % data True; data False; type family Neq a b where Neq a a = True; Neq a b = False
21:58:23 <yahb> dminuoso: 
21:58:40 <dminuoso> % f :: forall (a :: Te) (b :: Te). (Neq a b ~ False) => F a -> F b -> (); f = undefined
21:58:40 <yahb> dminuoso: 
21:58:51 <dminuoso> geekosaur: Mmm. How is that?
21:59:09 <geekosaur> and yeh, that's more ro less the hack, except it's usually phrased as an equality typeclass and then take the False case
21:59:26 <Athas> MarcelineVQ: ah, thanks.
21:59:37 <geekosaur> an equality consrtaint is just a sort of alias inside the typechecker. inequality requires actual checking
21:59:58 <Athas> A bit annoying that there is no grammar for stack.yaml that I could find.  That would have answered the question immediately.  All I found was a lot of of imprecise prose.
22:00:44 <MarcelineVQ> Athas: 3rd example here, for future ref https://docs.haskellstack.org/en/stable/yaml_configuration/#package-index
22:01:03 <geekosaur> and actual checking has to be den at runtime, because the typechecker dos not know all the types it could be used at ahead of time
22:01:07 <dminuoso> geekosaur: Is an unsatisfied equality constraint not the same thing as a qualified non-equality constraint?
22:01:08 <dminuoso> Im probably thinking too naive here.
22:01:14 <dminuoso> Ah.
22:01:27 <geekosaur> or at least at final link, btu inekrs don't have haskell tyepcheckers buil;t into tem so in practice it'd hae to be runtime
22:01:42 <geekosaur> gah
22:01:50 * dminuoso gives geekosaur a cup of coffee
22:02:05 <geekosaur> or at least at final link, but linkers don't have haskell typecheckers built into them so in practice it'd have to be runtime
22:02:20 <geekosaur> I;'m already typing too fast for this damn keyboard >.>
22:02:38 <dminuoso> Maybe an IBM Model M would help. ;-)
22:02:52 <dminuoso> These things are getting way too expensive nowadays. :(
22:04:33 <Martin333[m]> dminuoso (IRC): I'm not objecting the superiority of Model M but, wouldn't just about any mechanical keyboard suffice just for the sake of stroke registration?
22:05:10 <jackdk> unicomps are decent if you're in the cult of the model m but I went more for programmability and splits. ergodox with zealios here
22:05:58 <Athas> I can recommend a Kinesis Advantage.  It's stunningly expensive, though.
22:06:05 <dminuoso> Martin333[m]: The build quality of unicomps for example is massively lower. There's only few keyboards with comparable switches.
22:06:06 <Athas> But I've written a lot of Haskell code on it!
22:06:15 <Martin333[m]> jackdk (IRC): If it doesn't say 'IBM', it doesn't count!
22:06:31 <dminuoso> I switched to a Ducky keyboard which Im quite happy with now.
22:06:36 <dminuoso> But it doesn't have the same feeling as an IBM Model M. :(
22:06:37 <Martin333[m]> dminuoso (IRC): But is stroke registration noticeably worse?
22:06:39 <geekosaur> anyway the typeclass works because yo have to provide an instance for every type you use with it, so it is again back in a shape the typechecker can deal with. arbitrary types are a problem
22:06:50 <dminuoso> Martin333[m]: Well it's brown switches because office.
22:06:57 <dminuoso> Martin333[m]: Or do you mean unicomps?
22:07:46 <dminuoso> geekosaur: Mmm. Ill have to sink it in, right now it's not obvious how inequality is different from equality. To me it seems that checking for inequality could be just the same as checking for equality and inverting the "raise type error" logic.
22:08:11 <Martin333[m]> dminuoso (IRC): In my (limited) experience, mechanical keyboards in general are extremely consistent with stroke registration, so using Model M specifically is just extra neat for other reasons.
22:08:14 <geekosaur> the point is the typechecker can just replace every equal type with the same type variable and it's done
22:09:21 <dminuoso> geekosaur: Oh you mean that if it notices `a ~ b` then it will use the same type variable for inference/unification and see if it blows up?
22:09:27 <geekosaur> you can't do this for *in*equality, and making them distinct tyvars isn't quite the same thing because they coudl still be isntantiated at the same types
22:09:36 <geekosaur> more or less, yes
22:09:51 <dminuoso> I think I can see where you are getting at.
22:10:02 <geekosaur> it doesn't need to do actual work, just make them the same reference to a given type
22:11:55 <geekosaur> you can also draw a parallel to de morgan's rule
22:47:21 * hackage decidable 0.1.3.0 - Combinators for manipulating dependently-typed predicates.  http://hackage.haskell.org/package/decidable-0.1.3.0 (jle)
22:48:15 <geekosaur> actully I guess that doesn't help much, you can do it but it obscures tings
22:48:21 * hackage Villefort 0.1.2.17 - Villefort is a task manager and time tracker  http://hackage.haskell.org/package/Villefort-0.1.2.17 (AliceReuter)
22:48:41 <geekosaur> the real poitn is the opposite of (a ~ b) is not (a /~ b), it's "I don't know enough to say one way or the other"
23:19:04 <maerwald> type agnosticism?
23:35:09 <matzy_> Can someone explain why this throws an error?
23:35:30 <matzy_> let printNum x = print x in filter printNum [1,2,3,4]
23:36:05 <matzy_> I'm working through 'Learn you a haskell', and the following example works:
23:36:18 <matzy_> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
23:38:21 <boj> matzy_: you are trying to print (an IO action) inside a pure function
23:39:30 <matzy_> I also tried this and it failed:
23:39:35 <matzy_> let addTwo x = sum 2 x in filter addTwo [1,2,3,4,5]
23:39:58 <matzy_> boj: which doesn't involve an IO action (I realized that could cause issues)
23:40:10 <chessandgo> I believe the domain of this question has to to do with the ScropedTypeVarible extension. How to I specify a typeclass in a typesignature in the body of a function
23:40:16 <clever> filter expects a boolean as the result, `sum 2 x` doesnt return a bool
23:40:49 <int-e> :t sum 2 x
23:40:50 <lambdabot> error:
23:40:50 <lambdabot>     Ambiguous occurrence ‘x’
23:40:50 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.x’,
23:40:55 <int-e> :t sum 2 ?x
23:40:56 <lambdabot> (?x::t2, Num (t2 -> t3), Num (t1 (t2 -> t3)), Foldable t1) => t3
23:41:14 <chessandgo> using cloud haskell, there is a "function" with the type signature
23:41:15 <int-e> boo
23:41:15 <matzy_> clever: ahhhhh i forgot filter wants a bool
23:41:17 <chessandgo> CH.expect :: (Typeable a, Binary a) => CH.Process a
23:41:29 <matzy_> thanks!!
23:41:29 <int-e> matzy_: sum 2 x  doesn't really make sense.
23:41:37 <chessandgo> I would like to keep it just as (Typeable a, Binary a) as I have a function that accepts that
23:42:54 <matzy_> int-e: but couldnt you have: addTwo x = sum 2 x 
23:43:00 <int-e> matzy_: basicaly, sum takes a list and adds all the elements.
23:43:14 <matzy_> oh i see, whoops
23:43:14 <int-e> matzy_: so giving it two arguments makes no sense. do you mean 2+x?
23:43:22 <matzy_> yeah basically
23:43:43 <int-e> > (+) 2 40
23:43:44 <lambdabot>  42
23:43:53 <int-e> > 2 + 40
23:43:54 <lambdabot>  42
23:43:57 <matzy_> int-e: THAT'S what i was looking for :)
23:44:26 <matzy_> I remembered reading there was a way to call via currying
23:44:54 <matzy_> that first form was what i was thinking of
23:45:16 <int-e> you can also use a section: addTwo = (2 +) ... at which point it doesn't deserve a name anymore.
23:45:37 <int-e> > filter (> 23) [1,10..100]
23:45:40 <lambdabot>  [28,37,46,55,64,73,82,91,100]
23:47:59 <matzy_> int-e: sections as in conditional applications you can write in functions?  with the "|" symbol?
23:49:43 <matzy_> myfun x y = zip x y  |  myfun _ [] = [] | myfun [] _ = [] ...and so on.  that what you mean by "sections"?
23:49:50 <lucca> those are guards
23:50:04 <int-e> matzy_: no, those are guards... sections are a special kind of partial applications.
23:50:04 <lucca> er, oh nm
23:50:24 <matzy_> oh i mixed up sections and guards.  i know what they are, sorry about that
23:50:26 <lucca> foo x y | x==y = ...
23:50:40 <matzy_> divideByTwo = (/2)
23:51:02 <matzy_> where it automatically pushes the extra arg to the correct spot
23:51:03 <int-e> matzy_: given en infix operator ?, (?) is the corresponding function, x ? y and (?) x y are the same, and (x ?) stands for (?) x while (? y) stands for \x. x ? y.
23:52:33 <matzy_> :t (?)
23:52:34 <lambdabot> error: Variable not in scope: ?
23:52:37 <int-e> > ((+) 3 4, (3 +) 4, (+ 4) 3, (+) 3 4)
23:52:39 <lambdabot>  (7,7,7,7)
23:53:35 <int-e> The Haskell syntax embraces infix operators. It can be a bit overwhelming at first.
23:54:33 <lucca> > take 20$Data.List.nubBy(((>1).).gcd)[2..]
23:54:35 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
23:55:13 <int-e> :t L.nubBy
23:55:14 <lambdabot> error:
23:55:14 <lambdabot>     Not in scope: ‘L.nubBy’
23:55:14 <lambdabot>     No module named ‘L’ is imported.
23:55:17 <matzy_> int-e: ok, i was totally with you until the \x
23:55:33 <matzy_> i havent come across \ in haskell yet, maybe something i haven't learned
23:56:00 <lucca> \ is for constructing lambda expressions
23:56:03 <matzy_> i totally get (x ?) standing for (?) x though
23:56:11 <lucca> id = \x->x
23:56:12 <int-e> matzy_: Oh you will. The \ is a lambda, \x. x  is an anonymous function taking one argument and returning it (so the identity function)
23:56:27 <int-e> danmn
23:56:40 <int-e> \x -> x  is the right syntax
23:56:47 <matzy_> oh it's just a lambda function declaration?
23:56:48 * int-e is mixing too many functional programming languages.
23:56:53 <matzy_> (i know some lisp)
23:57:25 <int-e> I made the same mistake above: \x -> x ? y  would have been correct for (? y).
23:57:46 <lucca> it's just lambdas like you know from lisp, however the full power of destructuring binds applies
23:57:53 <Martin333[m]> matzy_: Yes, `\x -> f x` in Haskell is like `(lambda (x) (f x))` in Scheme.
23:58:19 <lucca> e.g. if you have ADTs you can match on them much like case can with \(Foo x y _) -> x+y etc
23:58:29 <matzy_> Martin333[m]: and scheme is the dialect i know. you're a saint :)
23:58:29 <lucca> as many levels deep as you desire
23:58:53 <int-e> all the way down the rabbit hole
23:59:04 <matzy_> int-e: i dont get the need for the labda addition.  you already have the function being applied, ?.
23:59:09 <matzy_> or (?)
