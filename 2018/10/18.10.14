00:05:43 <Peaker> in a nix build of a Haskell package, what change on a derivation would add a -I flag for the C builds in the package? in a cabal file it is "include-dirs". in the resulting ghc invocation it is just "-I". in nix?
00:07:16 <Peaker> oh actually I see that cabal invokes gcc directly for the C sources
00:34:17 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
00:34:17 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
00:34:34 <maerwald> could be a stateful parser maybe
00:35:48 <ggole> This is for telling lisp-style symbols from numbers?
00:36:04 <remexre_> I was hoping there'd be like a (filter :: (a -> Bool) -> Parser a -> Parser a) combinator I've been missing :'(
00:36:14 <remexre_> ggole: In essence yes, though not for parsing Lisp
00:36:56 <ggole> You can parse a sequence of [a-zA-Z0-9] and pass along a bool that indicates whether you've run into a [a-zA-Z]
00:37:04 <ggole> Then at the end you know whether the chars are a number or a symbol.
00:37:16 <remexre_> Would that involve having a (ParsecT _ _ (State _) a) parser type?
00:37:37 <remexre_> Or just having a (Bool -> Parser (a, Bool)) subparser
00:37:43 <ggole> Dunno how you'd encode that in a particular parsing library though
00:38:18 <remexre_> I'll try the Bool -> Parser (a, Bool) one then, I guess
00:38:20 <remexre_> thanks!
00:38:45 <ggole> I suppose one thing to look out for here is number suffixes
00:38:50 <cocreature> you could also parse, then check and fail if it doesnâ€™t pass the check
00:39:21 <remexre_> ggole: Thankfully I don't have them (the grammar I'm parsing doesn't, that is)
00:39:34 <remexre_> cocreature: Yeah, the combinator to use for checking is what I'm not finding
00:39:36 <ggole> OK, that always makes things easier
00:40:25 <cocreature> remexre_: check predicate parser = do r <- parser; unless (predicate r) (fail "foobar")
00:40:44 <cocreature> (you might want to wrap that in "try")
00:41:11 <remexre_> TIL unless
02:41:20 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
02:41:20 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
03:11:34 <akr> lavalike: so the problem I have is that I already have literally hundreds of computations of type `IO (Maybe a)`â€¦ Now in my `MaybeT IO a` I need to lift them every time
03:11:46 <akr> is there something I can do to avoid that?
03:12:09 <lavalike> akr: no :(
03:12:33 <lavalike> maybe search and replace from the old to the new monad and adjust accordingly?
03:12:52 <akr> there's also thousands of places where the old computations are used
03:13:03 <akr> and expected to return IO (Maybe a)
03:13:31 <lavalike> that's a lot of code!
03:13:35 <akr> yeah
03:13:41 <akr> there should be a language extension to define implicit type conversions or something like that :/
03:13:47 <lavalike> I don't think that's a good idea
03:14:23 <akr> well, that would seem to be the best solution in my case
03:14:40 <lavalike> it'd leave you with some weird "re-interpreted" code, alongside old safe code
03:14:57 <lavalike> that has a bad aftertaste
03:15:52 <akr> the type conversion would only apply in my new MaybeT IO a
03:16:00 <lavalike> you could define  f' :: MaybeT IO a  for the  f :: IO (Maybe a)  that you actually use in the new code, and then port the old code slowly over time
03:16:24 <akr> now that has a bad aftertaste :D
03:16:30 <lavalike> when done you can remove all the non-primes, and then remove the "'" chars
03:16:44 <lavalike> but it is clean and type safe! :D
03:17:23 <akr> so you're saying that implicit type conversions are never type safe?
03:17:37 <lavalike> the word "implicit" scares me
03:17:56 <akr> I think there are case where it can be justified
03:18:41 <lavalike> haskell used to have a feature called "implicit parameters" that was disabled at some point, "implicit" doesn't have a good track record :D
03:19:12 <akr> hmm, not sure about that
03:19:19 <akr> implicit parameters in Agda are awesome though
03:19:23 <lavalike> this also isn't a case where unsafeCoerce would be safe, the two monads are different beasts
03:19:38 <akr> yeah, I'm not saying to convert unsafely
03:19:49 <akr> rather, have a user-defined function which says how to convert
03:20:05 <lavalike> MaybeT :: IO (Maybe a) -> MaybeT IO a ?
03:20:14 <akr> yeah
03:20:14 <lavalike> sorry (:
03:20:32 <lavalike> I think you have to decide which monad you want to use, that's mostly it
03:21:16 <akr> well, then I have to use the first one
03:21:30 <cocreature> implicit parameters are not disabled. it was always hidden behind an extension flag and still is
03:21:38 <petercommand> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameters
03:22:17 <lavalike> I thought they got the axe, I remember reading some strong comments in that regard
03:22:57 <cocreature> it isnâ€™t particularly popular but Iâ€™ve never seen any serious proposal to remove it
03:24:16 <lavalike> I guess I blown something out of proportion
03:24:35 <akr> oh, interesting
03:25:13 <akr> they seem to work like instances in Agda
03:25:34 <electrocat> HasCallStack is implemented using implicit params iirc
03:31:12 <geekosaur> lavalike, you're thinking of linear implicit parameters, an extension that didn't pan out
03:31:21 <lavalike> !
03:31:24 <geekosaur> more because of the linear than the implicit
03:31:47 <lavalike> Â«Linear implicit parameters have been scheduled for removal for some time. In 6.6 we've removed them from the user manual, and they may well disappear from the compiler itself in 6.6.1.Â»
03:31:51 <lavalike> my bad
03:31:54 <lavalike> thank you geekosaur 
03:32:10 <akr> ah got it, I'll just define a new version of (<-) that does the conversion
03:32:31 <geekosaur> akr, you can't define that, at least nto directly
03:32:31 <akr> hmm
03:32:35 <geekosaur> it turns into >>=
03:32:45 <akr> yeah, it's not going to play with `do`
03:33:13 <akr> haskell syntax is so stringent :D
03:33:27 <cocreature> technically you could use RebindableSyntax
03:33:39 <Ariakenom> strict no-magic zone
03:33:54 <cocreature> if you enjoy that everyone gets confused when they read your code
03:34:30 <akr> cocreature: interesting, haven't heard of that extension before
03:34:40 <lavalike> cocreature: and then you redefine >>= ?
03:35:28 <cocreature> lavalike: yeah
03:35:40 <akr> cocreature: I think then I will have a hard time mixing regular <- and my new one on the same file though, right
03:36:07 <lavalike> maybe you need a >>= with a different type
03:36:32 <cocreature> you can override it locally
03:36:48 <akr> so I can shadow the existing definition of (>>=) with my new one when I need it?
03:36:51 <cocreature> but as I said, itâ€™s terribly confusing for everyone that reads your code and I definitely wouldnâ€™t recommend it :)
03:38:02 <lavalike> I'm curious to see how that is swung tho
03:38:03 <akr> well, guess I'm willing to take that risk
03:38:21 <akr> not like this project is the shining example of good practices anyway
03:38:27 <akr> (not my fault tho! :))
03:39:22 <cocreature> adding more bad practices to a project thatâ€™s already full of them is usually a bad idea :)
03:40:03 <akr> haha
03:40:05 <akr> fair point
03:40:32 <akr> well I can just try it out, see how it goes
03:40:43 <akr> not like anyone else is going to read this code any time soon anyway
03:40:57 <cocreature> akr: Iâ€™m not entirely sure I understand the problem you are trying to solve. You have an existing code base that uses IO (Maybe â€¦) in various places right?
03:41:07 <akr> yup
03:41:15 <cocreature> so presumably that code already handles the shortcircuiting correctly, otherwise the current code is broken
03:41:33 <cocreature> so are you trying to simplify the existing code or add new code that uses IO (Maybe â€¦)?
03:41:35 <akr> yeah, I'm not looking to rewrite old code
03:41:52 <geekosaur> switching to MaybeT IO with minimal code rewrtiting, is my understanding
03:41:55 <cocreature> alright, so what is the problem with wrapping a few calls in your new code in MaybeT?
03:42:14 <akr> cocreature: because it means wrapping almost every single line
03:42:28 <akr> in certain case, all the lines
03:42:32 <akr> sometimes fewer
03:42:39 <cocreature> akr: do you use tons of different functions or repeat the same functions very often?
03:42:51 <akr> tons of different functions
03:43:20 <lavalike> maybe hire an intern
03:43:32 <cocreature> I would just bite the bullet and define MaybeT wrappers for those functions in some module (TH might be worth considering)
03:43:34 <cocreature> and then use those
03:44:10 <akr> TH could be interesting
03:44:15 <akr> but I'm not terribly familiar
03:44:16 <cocreature> itâ€™s a bit of boilerplate but itâ€™s easy to understand and hard to get wrong and youâ€™re probably not going to have to touch it too often
03:45:43 <akr> true
03:47:16 <akr> anyway thanks a lot for all the information
03:47:33 <akr> I think I'll give rebindable syntax a try, it's a nice hack
03:47:42 <lavalike> but how do you define your >>=
03:48:17 <cocreature> x >>= f = runMaybeT (MaybeT x Prelude.>>= MaybeT . f)
03:48:18 <lavalike> add a class for the 'a' in m a and a -> m b?
03:48:25 <lavalike> uhm
03:48:48 <lavalike> oh so you change the definition of >>= for just *one* instance in a do block?
03:49:03 <akr> no, in front of teh do block
03:50:14 <lavalike> so inside of that do block *all* of the binds (<-) use it
03:50:58 <akr> yeah
03:51:00 <akr> oh
03:51:08 <akr> this GHC from year 25 doesn't support rebindable syntax
03:51:13 <lavalike> so you have the same problem, but flipped the other way
03:51:29 <cocreature> akr: year 25?
03:51:49 <akr> I just mean that it's old :)
03:52:18 <cocreature> must be very old, RebindableSyntax has been around for ages
03:52:52 <geekosaur> some specific rebindables are rather younger though
03:55:08 <geekosaur> https://downloads.haskell.org/~ghc/6.6.1/docs/html/users_guide/syntax-extns.html#rebindable-syntax
03:55:23 <geekosaur> with several warnings and a rather shorter list of rebindable features
03:56:08 <cocreature> should be sufficient for rebinding >>= :)
03:57:09 <lavalike> I still don't quite get it, you won't be able to use the *new* actions you define in MaybeT IO a in the re-bound do blocks, at all
03:57:24 <lavalike> whereas in Prelude.>>= you can mix them
03:58:56 <cocreature> lavalike: huh? why wouldnâ€™t you be able to use them?
03:59:44 <lavalike> I'm thinking what happens when you stick a   mia :: MaybeT IO a   in a rebound   do { x <- mia; ... }
04:00:25 <cocreature> ah I see, right that wonâ€™t work
04:00:34 <geekosaur> I think the point here is they're all IO a?
04:00:53 <lavalike> and you don't seem, to me, to have a recurse, unlike in the standard-do case where you *could* stick a MaybeT there for IO (Maybe a) actions
04:00:55 <geekosaur> or enough of them that the occasional MaybeT IO a coudl eb handled with Prelude.>==
04:00:57 <geekosaur> er
04:00:59 <geekosaur> >>=
04:01:06 <cocreature> lavalike: sure you do, runMaybeT
04:01:09 <lavalike> haha!
04:01:17 <lavalike> thank you
04:01:28 <lavalike> so that's the devil we bought, now I get it
04:01:50 <cocreature> if youâ€™re really masochistic you could make some stupid typeclass that allows you to mix this but please donâ€™t
04:02:13 <lavalike> that's what I meant with "adding a class to a in m a and a->m b" precisely!
04:02:26 <lavalike> >:)
04:13:36 <akr> hmm, I've got GHC 6.12.3
04:13:58 <cocreature> akr: Iâ€™m curious, how did you manage to get stuck on such an ancient version?
04:14:18 <akr> cocreature: took over a project after some other guy left
04:14:25 <akr> before him it was just one guy working on it as well
04:14:29 <akr> never enough time to update
04:14:50 <lavalike> that's a rather longevous haskell project!
04:14:51 <cocreature> sounds rough :/
04:15:38 <akr> cocreature: the real kicker is that .cabal files changed syntax about a year ago (they added a new flag or something) and now our ancient cabal crashes when it tries to read an up-to-date hackage index
04:15:47 <cocreature> hopefully you are at least getting paid a fortune to maintain their ancient crap :)
04:15:52 <akr> solution: fish out an old hackage index form before the change, use that forever
04:16:17 <akr> from before*
04:16:35 <akr> cocreature: eh, $ is not great, but I'm currently based in eastern europe
04:16:42 <lavalike> needs a perspective change: beautiful program that has been serving us well for a long time != ancient crap
04:17:30 <fiatjaf> I'm writing a webapp with scotty. is there a way to return a response and close the request, but then continue doing stuff in the background?
04:18:04 <akr> fiatjaf: you can probably just fork before you close the request
04:18:36 <akr> you could also have a different thread running in parallel and have a channel between your request-response thread and send workloads to the other thread over the channel
04:20:39 <fiatjaf> oh, that seems to complicated. I'm a beginner. what should I read?
04:20:54 <fiatjaf> the different thread looks like a cleaner solution.
04:21:11 <cocreature> @where parallel
04:21:11 <lambdabot> http://www.haskell.org/haskellwiki/Parallel
04:21:19 <cocreature> @where concurrent
04:21:19 <lambdabot> I know nothing about concurrent.
04:21:25 <cocreature> thanks for nothing lambdabot 
04:21:47 <cocreature> fiatjaf: https://simonmar.github.io/pages/pcph.html is definitely worth a read in particular the second half on concurrent Haskell
04:22:01 <cocreature> you can read it freely online
04:22:35 <akr> I'm huge fan of actor-style concurrency, for that you could use https://hackage.haskell.org/package/distributed-process
04:22:38 <dminuoso> cocreature: Where can you read it freely online?
04:22:53 <cocreature> dminuoso: there is a link on the website that I just posted
04:22:55 <lavalike> the link is in the first paragraph
04:22:56 <dminuoso> Ohh it's still on archive.org I guess
04:23:01 <dminuoso> Right.
04:23:33 <dminuoso> cocreature: I just started reading the book - this is yet another *great* example of non-strict semantics being incredibly amazing. :)
04:23:55 <dminuoso> To be able to sprinkle your program with parallelism without talking about parallelism.
04:24:26 <dminuoso> (I mean the Eval monad)
04:25:49 <cocreature> I never really had a reason to make use of the parallel part but the concurrency part is great
04:28:01 <akr> I don't get it, according to this https://downloads.haskell.org/~ghc/6.8.2/docs/html/users_guide/syntax-extns.html#rebindable-syntax I should have RebindableSyntax
04:28:40 <akr> but I only have these https://paste.ee/p/voKGr
04:28:49 * dminuoso ponders why akr is using 6.8.2 GHC documentation
04:29:20 <akr> cause I'm using GHC 6.8.2 :)
04:29:28 <dminuoso> That sounds.. why?
04:29:39 <akr> industry
04:30:23 <dminuoso> What a shame, the git repo only goes back as far as 7.2 it seems
04:32:08 <dminuoso> akr: Did you just try it in GHCi or with plain GHC as well?
04:32:49 <akr> I tried both
04:34:13 <dminuoso> akr: According to the 7.0.1 release notes it was not an extension before.
04:34:29 <dminuoso> 1.5.2: Language changes [...] Rebinadble syntax now has its own extension, RebindableSyntax, and thus is no longer enabled by NoImplicitPrelude.
04:34:53 <dminuoso> akr: So that would suggest NoImplicitPrelude might have that effect.
04:35:15 <akr> oh
04:35:22 <dminuoso> akr: Heh. It's even documented that way in the docs you linked. :)
04:35:23 <akr> hmm
04:35:45 <the_2nd> I tried building my project with stack lts 12.12 on windows but it fails there (works on Linux), due to the license string of bhoogle here https://github.com/andrevdm/bhoogle/blob/master/bhoogle.cabal#L7
04:35:52 <akr> dminuoso: ah yeah
04:35:55 <akr> thanks
04:36:01 <the_2nd> why does the windows stack build behave differently? Any way to resolve that?
04:36:06 <cocreature> the_2nd: fails how?
04:36:20 <the_2nd> "line 7 license could not be parsed"
04:36:23 <the_2nd> something like that
04:36:31 <cocreature> sounds like you are using an older version of stack on windows
04:36:33 <the_2nd> I can get the exact string if that helps
04:36:44 <the_2nd> just reinstall stack?
04:36:46 <dminuoso> akr: Out of curiosity, what do you want to rebind?
04:36:47 <the_2nd> I'll try
04:36:54 <cocreature> "stack upgrade"
04:37:02 <the_2nd> thanks, I'll report back
04:37:12 <akr> dminuoso: (>>=)
04:57:41 --- mode: glguy set +v reactormonk
04:57:42 --- mode: glguy set -v reactormonk
05:02:19 --- mode: glguy set +v qxg
05:10:55 <fiatjaf> thank you, akr and cocreature
05:28:10 <jhu> Hello fellow Haskellers. I think I have a need for composing applicatives in my code. Does Haskell provide a "double-apply" out of the box, or do I need to define it myself as has been done here: https://stackoverflow.com/questions/7040844/applicatives-compose-monads-dont
05:29:18 <desperek> hi
05:29:26 <desperek> how do i specify multiple directories to cabal install?
05:29:32 <desperek> or is it recursive?
05:34:08 <dmwit> jhu: Data.Functor.Compose
05:34:36 <dmwit> desperek: There's a couple things you could mean. If you just have several directories with one package each, then `cabal install dir1 dir2 dir3` works.
05:35:02 <jhu> dmwit: Thanks, I will take a look.
05:35:08 <desperek> dmwit, installing gtk and i need to specify INCLUDE directories... well, i can just append to the env INCLUDE
05:35:10 <dmwit> If you have a single package with source spread across multiple directories, look at the `hs-source-dirs` field in your cabal file. (But this is rarely done; why are you spreading it across multiple directories?)
05:35:11 <desperek> (S)
05:35:32 <dmwit> desperek: Perhaps you are looking for --extra-include-dirs ?
05:35:47 <desperek> dmwit, yea, but how do i specify multiple directories there?
05:35:54 <desperek> it doesnt go recursive on me
05:36:07 <dmwit> ...why do you want it to be recursive?
05:36:28 <desperek> dmwit, uh, i have gtk+ installed and i want it to get all the libs
05:37:20 <dmwit> Okay, but usually all the headers go in a single directory, and callers #include <gtk/subdir/header.h> e.g.
05:37:37 <dmwit> So you only need to add the directory that contains the gtk subdirectory to your --extra-include-dirs.
05:38:24 <desperek> dmwit, when i add a dir gtk/include there it looks like it ignores everything in subdirs
05:38:28 <desperek> also, on windows
05:38:34 <desperek> env vars are not recursive here
05:38:52 <tpsinnem> would it make sense to consider using Cloud Haskell for creating tests for distributed systems?
05:39:04 <fiatjaf> jsonData :: FromJSON a => ActionM a; Parse the request body as a JSON object and return it. Raises an exception if parse is unsuccessful.
05:39:13 <fiatjaf> what does "Raises" mean?
05:39:37 <desperek> dmwit, when i put include dir  in --extra-include-dirs it says its missing * Missing (or bad) C libraries: gobject-2.0, glib-2.0, intl and when i add include/glib-2.0 it says it missed z and cairo :D
05:41:04 <desperek> though cairo is also in its subdir...
05:41:05 <desperek> im lost
05:41:08 <dmwit> Usually a "missing C libraries" message is about pkg-config, not headers. So I'm a bit surprised.
05:41:52 <dmwit> But anyway, you could look in the documentation for how to specify multiple directories. Or I would try commas, then colons, then multiple flags.
05:42:32 <desperek> oh i didnt try i think colons wont work
05:42:44 <desperek> ive tried commas and multiple flags
05:43:49 <desperek> dmwit, my bad. it missed all of the libs
05:45:33 <dmwit> fiatjaf: I would assume it means "calls throwIO".
05:45:52 <dmwit> tpsinnem: Sure, why not.
05:46:17 <desperek> dmwit, pkg-config var should be set to the directory called pkgconfig, right?
05:46:40 <dmwit> I don't remember. I recommend the Windows installation instructions for gtk2hs (written by yours truly) on the wiki.
05:47:15 <dmwit> https://wiki.haskell.org/Gtk2Hs/Installation
05:48:09 <desperek> dmwit, well, i kinda followed it :/ https://wiki.haskell.org/Gtk2Hs/Installation#Windows
05:48:26 <desperek> oh.. spaces
05:48:33 <desperek> yea.. that sorts it out kinda
05:56:22 <desperek> oh i apparently have 2.16.2...
06:00:09 <dmwit> Oh dear. These instructions may be a bit out of date (from before the existence of gtk3).
06:01:02 <tpsinnem> dmwit: thanks
06:01:58 <desperek> ;-;
06:03:11 <desperek> uh i got 2.22 now let me try...
06:04:25 <desperek> hmm
06:04:34 <desperek> it seems that gtk+ 2.16 is just a bad version
06:04:47 <desperek> weird af
06:07:07 <dmwit> To be fair, the instructions do say so...
06:16:35 <desperek> dmwit, yea yea ;-; i know but i didnt see it then 
06:16:40 <desperek> sorry for bothering you
06:36:23 --- mode: glguy set +v unclechu
06:37:00 <unclechu> hi there. i'm readying a tutorial about singletons: https://blog.jle.im/entries/series/+introduction-to-singletons.html writing some code while doing exercises.
06:37:01 <unclechu> in the particular part of the code you could see i'm implemeted `Eq` instance for `SomeDoor`: https://gist.github.com/unclechu/5d84770376fe8fc91dfe999445b278d6#file-studying-singletons-part-2-hs-L41-L45 but as you can see i involve my bare hands to do so, and it's not that safe, so i could forget to add new pattern when i add new constructor for `DoorState`, is there more elegant way to do so?
06:38:13 <unclechu> i could add some patterns like `MkSomeDoor SOpened a == _ = ...` for each constructor and remove `_ == _` completely to get proper warnings, but is there a way to avoid involving my bare hands to make such patterns?
06:38:46 <unclechu> i can write some templates but maybe they're alrady written?
06:47:07 --- mode: glguy set -v unclechu
06:47:56 <unclechu> hi there. i'm readying a tutorial about singletons: https://blog.jle.im/entries/series/+introduction-to-singletons.html writing some code while doing exercises.
06:47:57 <unclechu> in the particular part of the code you could see i'm implemeted `Eq` instance for `SomeDoor`: https://gist.github.com/unclechu/5d84770376fe8fc91dfe999445b278d6#file-studying-singletons-part-2-hs-L41-L45 but as you can see i involve my bare hands to do so, and it's not that safe, so i could forget to add new pattern when i add new constructor for `DoorState`, is there more elegant way to do so?
06:48:06 <unclechu> i could add some patterns like `MkSomeDoor SOpened a == _ = ...` for each constructor and remove `_ == _` completely to get proper warnings, but is there a way to avoid involving my bare hands to make such patterns?
06:48:10 <unclechu> i can write some templates but maybe they're alrady written?
06:48:26 <coldpress> did you just copy paste your messages?
06:49:44 <unclechu> coldpress: yes, i got messages from bot that i need authentication on freenode so i did and sent them again
06:49:58 <coldpress> cool
06:50:29 <the_2nd> cocreature, the upgrade solved it, thanks
06:51:36 <fiatjaf> > 7 * 10 ^^ 1
06:51:39 <lambdabot>  70.0
06:52:01 <fiatjaf> > scientific 7 1
06:52:03 <lambdabot>  error:
06:52:03 <lambdabot>      Variable not in scope: scientific :: Integer -> Integer -> t
07:13:45 --- mode: glguy set +v mbieleck
08:20:47 <jhu> Let's say I have the following types:
08:21:10 <jhu> data: foo :: Either String [Int]
08:21:24 <jhu> function: func :: Int -> Either String Int
08:22:23 <jhu> So calculating the data could have failed and produced a (Left error), or the function could fail. How should I apply the function to the data?
08:22:48 <Clint> how do you want to?
08:22:48 <jhu> I could do:
08:22:51 <jhu> Î»> :t (fmap . fmap) func foo
08:22:53 <jhu> (fmap . fmap) func foo :: Either String [Either String Int]
08:23:44 <EvanR> (sequence . fmap (map func)) foo   ?
08:24:25 <dminuoso> jhu: What exactly do you want to achieve? What do you want to obtain?
08:24:51 <EvanR> what is the type of the final product
08:25:37 <jhu> The final type should be Either String [Int].
08:28:07 <jhu> So the final result should be (Left error) if calculating the data failed originally, or if applying the function to any value in the list fails.
08:28:13 <EvanR> maybe there is a fancy way but i would use do notation on your first step to get a list, then use sequence
08:28:37 <EvanR> to turn the [Either String Int] into a Either String [Int]
08:29:08 <jhu> EvanR: That makes sense.
08:29:38 <dminuoso> @ let f :: Either String [Int]; f = undefined
08:29:46 <dminuoso> @let d :: Either String [Int]; f = undefined
08:29:46 <Solonarv_> > let { foo = undefined :: Either String [Int]; func = undefined :: Int -> Either String Int } in foo >>= fmap sequence . func
08:29:47 <lambdabot>  .L.hs:174:1: error:
08:29:47 <lambdabot>      The type signature for â€˜dâ€™ lacks an accompanying binding
08:29:47 <lambdabot>        (The type signature must be given where â€˜dâ€™ is declared)
08:29:48 <lambdabot>  error:
08:29:48 <lambdabot>      â€¢ Couldn't match type â€˜[Int]â€™ with â€˜Intâ€™
08:29:49 <dminuoso> @let d :: Either String [Int]; d = undefined
08:29:49 <lambdabot>        Expected type: [Int] -> Either String (m (t a))
08:29:51 <lambdabot>  Defined.
08:30:24 <EvanR> well if its just xs <- _; sequence xs, then you just sequence =<< _
08:30:32 <Solonarv_> :t let { foo = undefined :: Either String [Int]; func = undefined :: Int -> Either String Int } in foo >>= fmap sequence . func
08:30:34 <lambdabot> error:
08:30:34 <lambdabot>     â€¢ Couldn't match type â€˜[Int]â€™ with â€˜Intâ€™
08:30:34 <lambdabot>       Expected type: [Int] -> Either String (m (t a))
08:31:07 <dminuoso> @let f :: Int -> Either String Int; f = undefined
08:31:08 <lambdabot>  Defined.
08:31:16 <dminuoso> :t d >>= traverse f
08:31:17 <lambdabot> error:
08:31:17 <lambdabot>     Ambiguous occurrence â€˜dâ€™
08:31:17 <lambdabot>     It could refer to either â€˜Debug.SimpleReflect.dâ€™,
08:31:21 * dminuoso sighs
08:31:25 <dminuoso> :t L.d >>= traverse L.f
08:31:27 <lambdabot> Either String [Int]
08:32:03 <dminuoso> jhu: thos?
08:32:24 <MarcelineVQ> pssst, if you try these things in pm first you look like a genius when it works first try :>
08:34:34 --- mode: glguy set +v jkachmar
08:34:46 <jhu> I have a lot of lambdabot clutter on my screen, trying your suggestions atm.
08:35:45 <glguy> MarcelineVQ: That's the first use of italics I think I've noticed in channel :)
08:36:22 <EvanR> almost missed the control codes for that being garbled in my terminal
08:36:57 <glguy> I had to create a custom terminfo entry so that I'd be able to see it after adding support to my client
08:39:11 <jhu> Ok, this works like a charm: foo >>= \lst -> sequence $ func <$> lst
08:39:29 <dminuoso> jhu: uh, like I said:
08:39:34 <dminuoso> foo >>= traverse func
08:40:29 <jhu> dminuoso: True, thanks, that got lost in the clutter. I need to filter out the lambdabot stuff.
08:40:51 <dminuoso> jhu: I've developed a habit of always thinking about `traverse` when I see sequence. 
08:41:09 <jhu> Brilliant.
08:47:40 <Ariakenom> dminuoso: same here
08:57:49 <jhu> That sort of worked, but then it didn't. In my app the lists can be infinite, and naturally both traverse and sequence fail to terminate. I have to rethink. But thanks, learned something new again.
09:34:25 --- mode: glguy set +v govno
09:43:26 <bsima> i've got this yesod app, the deployable docker container (on alpine) is 4GB
09:43:30 <bsima> is this normal?
09:47:16 <Rembane> bsima: Do you have all your build stuff left in the container? 
09:50:42 <bsima> hmm, maybe
09:51:06 <bsima> i'm actually useing nix's dockerTools.buildImage
09:55:41 <cocreature> bsima: make sure you are using justStaticExecutables or whatever that nix function is called
09:59:06 <bsima> cocreature: ah, thanks! searching "justStaticExecutables" landed me on this page, which goes into more details https://github.com/Gabriel439/haskell-nix/blob/master/project3/README.md#minimizing-the-closure
10:03:24 <akr> Is there some TH magic I can use to define a function of type `showType :: a -> String` which returns the type of the value?
10:03:40 <akr> so that `showType "dsfs"` return "String" for example
10:03:56 <glguy> no, type checking happens after template haskell
10:04:17 <benzrf> i thought it was interleaved
10:04:17 <akr> ok I see
10:04:49 <glguy> It's interleaved for top-level declaration splices, but that don't help to get the types of arbitrary expressions with TH
10:04:50 <akr> what would be the best way to do this? Have a type class which has a method to return that information?
10:05:44 <glguy> You can use Data.Typeable
10:06:13 <cocreature> akr: if you can get away with a Typeable constraint, that method just becomes showType :: forall a. Typeable a => a -> String; showType _ = show (typeRep :: TypeRep a)
10:06:13 <akr> ah, I see
10:06:36 <cocreature> not sure if Typeable exists in your ancient version of GHC though :)
10:06:44 <akr> good point :D
10:07:30 <akr> oh, it does
10:08:03 <cocreature> the types will be slightly different, my implementation uses the new representation that we got in 8.2 iirc
10:09:21 <akr> yeah I've got Data.Typeable.typeOf :: (Typeable a) => a -> TypeRep
10:19:39 <akr> > Can't make a derived instance of `Data.Typeable.Typeable Username' (even with cunning newtype deriving)
10:19:42 <lambdabot>  <hint>:1:22: error: parse error on input â€˜instanceâ€™
10:19:46 <akr> Not cunning enough :)
10:20:07 <akr> well at least it says I need -XDeriveDataTypeable
10:23:02 <bsima> lol docker size reduced by 3.8 GB
10:24:08 <akr> docker is crazy, I just deleted 10GB worth today
10:24:54 <akr> cocreature, glguy: Typeable works pretty well it seems, thank you
10:25:57 <cocreature> bsima: without justStaticExecutables you end up depending on all your dependencies, ghc itself, â€¦
10:32:40 --- mode: glguy set +v zincy
10:32:55 <zincy> What are views for? Should you have one view per controller?
10:50:57 <Athas> I can't help but shake the feeling that something is off when it takes so long for even relatively standard tools (like hlint or cpphs) to grow support for new versions of GHC.
10:51:01 <zincy> What do you call a route typically if it shows a login form?
10:51:17 <zincy> resource/login is already taken for the actual POST to login
10:51:27 <cocreature> Athas: hlint doesnâ€™t depend on the GHC API does it?
10:52:30 <Athas> cocreature: no, but it depends on polyparse, which does not work with GHC 8.6 (for trivial reasons related to the MonadFail change).
10:52:35 <cocreature> ah I see
10:53:13 <Athas> I don't blame the maintainers - they do this work for free and sometimes there are more important things to do than to touch Haskell - but I wonder how other language communities handle this.
10:53:16 <cocreature> zincy: I would also call it login but have it listen for GET instead of POST
10:53:24 <cocreature> but thatâ€™s also not a Haskell question
10:53:34 <Athas> This will be an increasingly intolerable problem with the higher pace of GHC releases.
10:58:07 <hpc> Athas: the tooling gets absorbed in the main project umbrella, usually
10:58:52 <cocreature> Athas: Iâ€™m not sure hlint and cpphs are great examples here. for executables upgrading to newer GHC releases isnâ€™t really a pressing issue. users can just keep compiling hlint with an older GHC release regardless of what release of GHC they use personally
10:59:24 <cocreature> also 8.6 has a showstopping bug which has probably slowed down things a bit
11:00:57 <zincy> thanks!
11:10:16 --- mode: glguy set +v B
11:11:35 --- mode: glguy set +v hoot
11:13:17 <Athas> cocreature: it is fairly frustrating in a CI setting to use different versions of GHC to build hlint/cpphs and your main code.
11:13:33 <Athas> And with Stack it's super awkward.
11:14:02 <Athas> But maybe hlint just isn't as widespread as I thought.  Perhaps *I'm* the odd one and I just have odd semi-abandoned dependencies for my project.
11:17:59 <cocreature> Athas: how about just disable hlint for all GHC versions except one (8.4.3) in CI? I donâ€™t see what you gain by running GHC-agnostic tools such as hlint for every version
11:18:19 <hpc> https://www.youtube.com/watch?v=hYAuR5bkIlQ
11:18:23 <Athas> cocreature: yes, that is what I did.  But I had hoped to remove 8.4.3 entirely from my CI setup, since I have to work around *other* bugs in that version.
11:18:23 <hpc> no, it's upstream that is wrong :D
11:18:34 <Athas> (It's a bit tragic that every single GHC version has showstopper-ish bugs...)
11:18:58 <cocreature> Athas: Iâ€™m curious, what showstopper bug does 8.4.3 have?
11:19:29 <Athas> cocreature: there's a bug in the lexer that makes Haddock segfault sometimes.
11:19:43 <Athas> (I have no idea how that could possibly happen, but it does.)
11:20:15 <cocreature> ouch that does sound bad
11:20:16 <Athas> 'stack --haddock' seems to trigger it with near-100% certainty when language-c-quote is involved (probably related to quasiquotes).
11:20:34 <cocreature> although Iâ€™ll take haddock segfaulting over broken derived Ord instances in 8.6 :)
11:21:00 <Athas> And GHC 8.2 segfaults often on Windows, so I use GHC 8.0.2 there.
11:21:15 <Athas> I had hoped that with GHC 8.6.1 I could finally consolidate things, but well...
11:36:08 <Athas> Does GHC itself use cpphs?
11:41:01 <cocreature> afaik no
11:41:16 <cocreature> you can tell it to explicitely but by default it just uses gcc for preprocessing
11:45:59 <SaraDR> Hey! I'm trying to learn QuickCheck. Can I mark than one outcome with classify? https://hastebin.com/nejoqexasu - e.g. if I wanted to also denote the percentage of cases where something else was true.
11:46:37 <SaraDR> Right now I just get OK, passed 100 tests (..%..)
12:01:44 --- mode: glguy set +v govno
12:06:03 <blankhart> you could use 'collect'?
12:07:20 <blankhart> see classifying, collecting and combining sections of the manual http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
12:08:19 <SaraDR> But collect will output each different result per line if I understand.
12:08:27 <SaraDR> And not grouped like I want.
12:10:15 <SaraDR> Hmm, well there's an example of using multiple classify in the manual. Lemme try that.
12:12:14 <SaraDR> Ah got it. Thanks :)
12:24:44 --- mode: glguy set +v Wreckless
12:24:46 --- mode: glguy set +v esap1
12:48:29 --- mode: glguy set +v jurkis
12:52:00 <Amras> Could I ask someone with a windows machine to build me a thing from source and send me the binaries?
12:52:23 <Amras> not a big thing, just a game jam entry I'm trying to put on more systems
12:52:40 <Amras> I'm trying to set up a ghc environment on my system but it's taking ages
13:17:28 <sm> Amras: I don't have one, but appveyor (and now travis) can be another way to get it
13:18:10 <sm> or even wine
13:20:25 <Amras> I'm not sure those will work well with sdl
13:22:30 <sm> agreed
13:23:28 <sm> at least, it increases the risk of time suck
13:24:10 <sm> but you actually have a windows system ?
13:26:14 <Solonarv_> Amras: if you still need it, I can do it. Whisper me.
13:31:03 <hpc> every time i see kan-extensions in my code's transitive dependencies, a little voice in my head whispers "you should learn some more CT"
13:34:16 <dstolfa> hpc: why just then? i can't think of when learning more CT would be a bad thing
13:35:18 <hpc> dstolfa: i need the reminder every once in a while
13:37:03 <monochrom> There too many good things to learn and too little time.
13:37:50 <Amras> I for one cannot wait until humanity merges into a hivemind
13:38:07 <Amras> I could know how to everything :v
13:38:27 <dstolfa> in reality, it's a trade-off of how much of it you really need and how much time you're willing to spend on learning it. but who cares about reality? it's messy. just learn more CT!
13:39:04 <monochrom> You give too much credit to other humans.  I suspect 90% of what you get will be porn.  Just look at the Internet today.
13:41:17 <LACampbell> hello. I want to convince another programmer - who is an open minded guy but hasn't had any exposure to FP - on the merits of using the Either datatype for error handling. I grokked either the hard way, and was wondering if there was a shortcut that helps people. Also, not sure if this is OT.
13:41:45 <aplainzetakind> Is it advisable to remove all system packages (gentoo) and work only with stack?
13:41:47 <dstolfa> LACampbell: if something can error out, it's good to not throw an exception and let the user handle an error the way they want to
13:42:06 <dstolfa> LACampbell: it's a flexible way to deal with errors without requiring stack walking
13:42:12 <dstolfa> (implementation-wise)
13:42:13 <[exa]> aplainzetakind: yes. even better only with local cabal and ghc self-build
13:43:08 <[exa]> LACampbell: there are also several places where Either sucks for error handling :]
13:43:27 <LACampbell> dstolfa: yes that's a good advantage. i was also thinking of going with the 'fork in the road we resolve later' analogy
13:43:34 <monochrom> Do not convince. Instead, show it as an alternative. There are times exception is better, and other times Either is better.
13:43:48 <dstolfa> [exa]: imagine dealing with overflows using Either
13:44:13 <dstolfa> [exa]: every time you manipulate a fixed size integer, you have to check for overflow
13:44:16 <monochrom> Exception is actually better in imperative programming.
13:44:20 <LACampbell> yeap, exceptions have their place, but as in most enterprise programming they're over used or silently caught. caused us a lot of grief
13:44:45 <[exa]> LACampbell: anyway, for persuasion-- superior example code wins
13:44:45 <dstolfa> monochrom: even there people frown upon them unless it would be much worse to not use them
13:45:02 <aplainzetakind> [exa]: Is there anything to watch out for while migrating from system xmonad/xmobar to stack ones?
13:45:08 <dstolfa> monochrom: surprisingly, a lot of C++ developers building compilers have strict coding guidelines against using exceptions
13:45:25 <monochrom> What do they use instead?
13:45:36 <dstolfa> monochrom: something like an Either type, but implemented in a messy way
13:45:36 <veverak> Either
13:46:38 <monochrom> OK so here is the deal. After you start using Either in anger, you evolve it into ExceptT, at which point it is an exception system again.
13:46:56 <[exa]> aplainzetakind: none I'd remember, so probably nothing serious; make sure you try to run everything from the local ghc before you annihilate the system one
13:47:00 <LACampbell> I have used Either in anger, and I've never done that monochrom 
13:47:31 <[exa]> "look left in anger"
13:47:46 * dmwit glares to his left
13:47:52 <aplainzetakind> [exa]: OK, thanks.
13:47:58 <monochrom> OK so you have deeply indented code instead because you have so many "case ... of Left ... Right ..." at every point, every level.
13:48:16 <[exa]> could we have a type with Front and Back so that the book reference could make sense?
13:48:40 <veverak> monochrom: sometimes you have only left... or only right
13:48:49 <monochrom> Recall that if you say "I use Either as a monad and write in do-notation" then you're back to an exception system again.
13:49:05 <dmwit> I'm coming in with pretty minimal context here, but... https://stackoverflow.com/q/33005903/791604 "How do I deal with many levels of indentation?" may be of interest.
13:49:18 <monochrom> See my http://www.vex.net/~trebla/haskell/exception.xhtml
13:49:51 <monochrom> dmwit: <monochrom> OK so here is the deal. After you start using Either in anger, you evolve it into ExceptT, at which point it is an exception system again.
13:50:27 * dmwit nods agreeably
13:50:28 <dstolfa> monochrom: stack unwinding is not efficient
13:50:29 <LACampbell> eww pattern matching either. I use functions
13:50:42 <dstolfa> monochrom: especially if you need to carry stack state across threads
13:50:47 <dstolfa> monochrom: which people often do
13:50:55 <dmwit> I didn't have enough scrollback to know that "having an exception system" was considered verboten. (Why is that?)
13:51:04 <hpc> you could always write your code so you don't have so many operations that can maybe fail
14:01:52 <fiatjaf> where can I find an updated list of this table? https://docs.haskellstack.org/en/stable/ghcjs/
14:03:13 <monochrom> I think I overheard yesterday that recent stack resolvers no longer help you with GHCJS.
14:03:41 <monochrom> Basically expect to go back to 7.10
14:03:46 <monochrom> (GHC version)
14:06:57 <fiatjaf> I'm using lts-7.19 with GHCJS 0.2.1
14:07:15 <fiatjaf> I guess that's the last one
14:07:19 <fiatjaf> but why?
14:07:54 <fiatjaf> is it impossible to use ghcjs with newer stack releases?
14:11:42 <fiatjaf> actually, I want to withdraw my questions
14:11:48 <fiatjaf> and ask: what is stack?
14:14:24 <hpc> fiatjaf: so, you know how cabal is the thing that downloads dependencies and calls ghc on all the right files to build your code?
14:15:21 <hpc> stack is the next layer above that, it takes control of the environment so the packages cabal downloads are the exact same version every time
14:15:45 <hpc> and that they only apply when you're in whatever project you're building
14:16:25 <fiatjaf> hpc, are packages built independently?
14:16:29 <hpc> an "LTS" is a set of packages pinned at specific versions
14:16:40 <hpc> and a pinned version of ghc to build them with
14:16:45 <fiatjaf> such that they don't have to be rebuilt every time
14:16:50 <hpc> yeah
14:16:55 <fiatjaf> hpc, what about packages that aren't in that set?
14:16:58 <hpc> it all goes into your project's .stack-work directory iirc?
14:17:10 <hpc> you can specify packages to get from hackage as well
14:17:35 <hpc> one other note, stack has two different files you can pick from to define a project
14:17:43 <hpc> stack.yaml, which defines only the build environment
14:17:53 <hpc> or package.yaml which takes over and writes the cabal file too
14:18:05 <hpc> imo package.yaml was a mistake to add
14:18:06 <fiatjaf> what is the advantage of using package.yaml?
14:18:11 <fiatjaf> oh, right
14:18:14 <fiatjaf> I'm deleting it here
14:18:25 <hpc> not having to write a cabal file is the advantage
14:18:42 <hpc> but the disadvantage is stack now takes up multiple layers of abstraction
14:18:54 <fiatjaf> all packages I may want that are not in stackage I must add to extra-deps
14:18:56 <fiatjaf> ?
14:19:03 <Athas> The .cabal file format used to be really bad.  Now it is just fairly bad.
14:19:18 <hpc> fiatjaf: right
14:19:35 <fiatjaf> why can't we have an architecture like npm's?
14:20:01 <fiatjaf> in which each package specifies its dependencies and a build tool downloads everything recursively?
14:20:01 <hpc> npm is a disaster if you want reproducible builds
14:20:12 <hpc> fiatjaf: that's what cabal does
14:20:29 <hpc> if you just want to do an unsandboxed build, cabal does exactly what npm does
14:20:40 <hpc> each package's cabal file says what it depends on
14:20:42 <Athas> npm supports multiple versions of a package being used concurrently, which is havoc in a statically typed language (especially one with type classes).
14:20:42 <fiatjaf> hpc, I've tried to use raw cabal in the past and my computer was unable to handle it, builds were taking hours
14:20:47 <fiatjaf> but with stack it's very fast
14:21:10 <hpc> cabal downloads recursively and builds in order
14:21:22 <Athas> fiatjaf: that sounds strange.  While I do prefer stack to cabal, the build times should not be affected.
14:21:32 <Athas> hpc: cabal has been doing parallel builds by default for years, I think.
14:21:35 <Athas> It certainly does now.
14:21:52 <fiatjaf> oh, I guess my computer was too old, then
14:22:19 <fiatjaf> so if cabal does that, it means that if we use cabal we'll have multiple versions of a package used concurrently?
14:22:41 <Athas> No.  Cabal comes up with a version number for every package used in a build.
14:22:45 <hpc> the other issue npm has, is packages aren't sourced from a single repository
14:22:48 <Athas> If that's not possible, then cabal complains.
14:23:10 <hpc> when you download an npm package you're getting the metadata from the npm repo, and then if it says "go to this random aws bucket", that's where the code lives
14:23:18 <hpc> if that bucket goes down, tough
14:23:27 <Athas> Both Stack and cabal use Cabal-the-library underneath, so they essentially build the same way.  The only difference is how they resolve the version numbers and how they download the code.
14:23:39 <hpc> if that bucket spontaneously rewrites all its source files with different stuff, tough
14:23:41 <Athas> hpc: is the bucket at least content-addressed or checksummed?
14:23:44 <Athas> Ugh.
14:23:48 <hpc> 1.0 today might not be the same as 1.0 tomorrow
14:24:07 <monochrom> Perhaps if you're low on memory then parallel build is actually slower than sequential build.
14:24:31 <monochrom> What is npm?
14:24:41 <hpc> monochrom: node package manager, it's for javascript
14:25:01 <fiatjaf> <Athas> If that's not possible, then cabal complains.
14:25:10 <fiatjaf> that's what happened most times
14:25:13 <fiatjaf> when I tried
14:25:19 <monochrom> Yeah OK it assumes an intepreter not a compiler so its job is easier.  cabal + hugs would be the same.
14:25:52 <monochrom> 90% of cabal hell is because GHC is a heavily inlining compiler.
14:26:04 <fiatjaf> what about nix? what approach does it take?
14:26:06 <monochrom> i.e., why all those "version mismatch" talk.
14:26:18 <Athas> fiatjaf: yes, that is because cabal uses a complicated resolver to find valid bounds among an ever-changing pool of packages (Hackage).
14:26:33 <Athas> fiatjaf: in contrast, Stack uses a fixed snapshot of packages guaranteed to build with each other.
14:27:00 <hpc> fiatjaf: nix is even more controlling than stack
14:27:28 <hpc> nix builds are reproducible down to the byte, iirc
14:27:36 <hpc> timestamps on files are zeroed out, etc
14:27:36 <Athas> Stack is like a tiny ad-hoc Haskell-specific projection of Nix.
14:28:37 <aplainzetakind> Why does stack look for the old gcc?: https://paste.pound-python.org/show/6DaxifsZkFMgQfrm1fXi/
14:31:03 <sm> aplainzetakind: stack --version ?
14:31:44 --- mode: glguy set +v newhoggy
14:32:53 <hpc> fiatjaf: https://app.vagrantup.com/nixos is probably a good place to start if you really want to learn how nix works
14:33:15 <fiatjaf> hpc, but if stack is a handpicked set of packages, what is nix? does it have something like that?
14:33:57 <Clint> stack isn't a set of packages; stackage is sets of packages
14:34:26 <hpc> nix does some deep magic that allows multiple versions of everything to interact
14:34:29 <geekosaur> it's less about "hand picked to work together" and more abotu enablng you to pick; once you getup tot hat complexity, there;'s no single "hand-picked set" that works in all cases
14:34:59 <hpc> you can have foo-1.0.0 build with base-4.5.0.0 living right alongside foo-1.0.0 built with base-4.6.0.0
14:35:04 <geekosaur> so nix works on letting you make your own package sets that work together while keeping them from getting in each others' hair
14:36:19 <hpc> the logical conclusion of this is nixos, where the entire operating system is built with nix
14:37:24 <hpc> you can do things like write a nix config that hosts a website
14:37:43 <hpc> then you make a change and rebuild your os, now the website doesn't work
14:37:56 <hpc> so you reboot it, and your previous os builds are on the boot menu
14:38:54 <aplainzetakind> sm: Version 1.7.1, Git revision 681c800873816c022739ca7ed14755e85a579565 (5807 commits) x86_64 hpack-0.28.2
14:38:59 <aplainzetakind> Just upgraded
14:39:17 <hpc> and this isn't just different kernels like regular linux
14:39:33 <hpc> you can go back on the boot menu to a configuration with a different version of apache
14:39:59 <adius> Is anyone here a Spacemacs user and can help me get https://github.com/emacs-lsp/lsp-mode running? I'm feeling really lost ðŸ˜ž
14:40:44 <fiatjaf> oh, sorry
14:40:48 <fiatjaf> that's too much for me
14:40:57 <hpc> heh
14:41:26 <fiatjaf> are people using nix for solving other kinds of dependencies?
14:41:29 <hpc> it's definitely a logical extreme, but a good one to learn if you want to understand packaging
14:41:29 <fiatjaf> besides haskell packages?
14:41:45 <hpc> fiatjaf: yes
14:41:47 <fiatjaf> I'm planning on learning that, but slowly and gradually :P
14:42:34 <hpc> https://nixos.org/nixos/packages.html
14:42:58 <newhoggy> I'm trying to learn fusion by following the paper "Exploiting Vector Instructions with Generalized Stream Fusion", but I'm stuck on why my version of zipWith is slower than that in Data.Vector.
14:43:04 <newhoggy> My source code is here: https://github.com/haskell-works/hw-streams/tree/fusion-discrepancy
14:43:11 <newhoggy> The paper is here https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/haskell-beats-C.pdf
14:43:30 <fiatjaf> examples are sometimes better than explanations, now I get the advantages of using nix as an os
14:43:33 <fiatjaf> :P
14:43:56 <newhoggy> Benchmark results:
14:44:04 <newhoggy> https://www.irccloud.com/pastebin/NMKNufEw/
14:44:15 <sm> aplainzetakind: and what's your distro version and install gcc --version ? gcc installed in usual place ?
14:44:27 <newhoggy> https://www.irccloud.com/pastebin/Rn8uX4BH/
14:45:20 <newhoggy> I noticed that the GHC-core for my implementation still has constructors in it like `Yield` and `Done`.  Where as these have disappeared in the Data.Vector version.
14:45:26 <sm> aplainzetakind: and what resolver is configured in the global stack.yaml under ~/.stack ?
14:47:23 <aplainzetakind> sm: gcc is 6.4.0
14:48:10 <aplainzetakind> Gentoo Base System release 2.4.1
14:49:00 <aplainzetakind> There's no stack.yaml in ~/stack
14:49:10 <aplainzetakind> ~/.stack I mean
14:49:15 <sm> find ~/.stack -name stack.yaml  ?
14:49:45 <aplainzetakind> ah ok
14:50:08 <aplainzetakind> lts-9.14
14:51:14 <sm> what's your end goal, for running stack setup in ~ ?
14:51:39 <sm> stack setup is usually redundant these days
14:52:02 <sm> normally you just "stack install PKG" or "stack build" in a project dir
14:52:15 <aplainzetakind> I wanted to follow a recipe to install xmonad through stack.
14:52:28 <sm> got a link ?
14:52:36 <aplainzetakind> https://brianbuccola.com/how-to-install-xmonad-and-xmobar-via-stack/
14:54:10 <sm> most docs in this space age pretty quickly
14:54:42 <sm> I don't know why step 2 is failing that way, I would try it again after mv ~/.stack ~/stack.old maybe
14:54:55 <aplainzetakind> I guess. But xmonad official page has no instructions for stack.
14:55:01 <aplainzetakind> OK I'll try.
14:55:04 <aplainzetakind> Thanks.
14:56:29 <sm> lts-12.13 is the current stable resolver, FYI
14:56:50 <aplainzetakind> Yes, it's getting that one.
14:57:09 <aplainzetakind> I'll just remove .stack.old after this. Any danger?
14:59:28 <sm> probably not. You might have projects depending on old stuff in there, which stack would re-download/rebuild
15:09:32 <aplainzetakind> sm: stack setup fails still.
15:10:01 <sm> aplainzetakind: what about "stack install xmonad"
15:10:27 <sm> and if that fails, what about "stack install" from the xmonad source dir
15:11:13 <aplainzetakind> "stack install xmonad" wouldn't mess with my present system xmonad right?
15:11:54 <sm> sorry, that's above my pay grade.. I'll let an xmonad user speak
15:12:16 <aplainzetakind> btw "stack setup" fails saying "Received ExitFailure 2 when running Raw command: /usr/bin/gmake install"
15:12:56 <sm> at a guess, there's something old/broken/different about your gcc installation
15:13:09 <aplainzetakind> Apparently so.
15:13:45 <aplainzetakind> But the system is up to date.
15:14:12 <aplainzetakind> There are many haskell packages that are not up to date but they shouldn't concern stack.
15:17:03 <sm> aplainzetakind: can you paste the full "stack setup" output again, now that you've changed global resolver to 12.13 ?
15:20:08 <sm> https://github.com/commercialhaskell/stack/issues/4122 looks similar
15:21:46 <tnks> I noticed that my builds seem to work without a Setup.hs, but I never found the documentation saying it is optional.  Does Cabal infer a default one?
15:23:07 <aplainzetakind> https://paste.pound-python.org/show/MFCSPdgZJSt3GPufXQSE/
15:23:54 <aplainzetakind> sm: It seems to fail while running gmake.
15:24:13 <aplainzetakind> Not while looking for a nonexistent version of gcc.
15:29:04 <sm> aplainzetakind: how does stack setup --verbosity=debug  look
15:29:50 <sm> any more details ?
15:29:56 <geekosaur> tnks, build-type: simple
15:30:06 <geekosaur> it doesn;t even use Setup.hs in that mode
15:32:56 <aplainzetakind> sm: Very verbose. I'm teeing to a file, will post when done.
15:33:36 <sm> I mean, any more details of the failing /usr/bin/gmake command ?
15:34:07 <sm> like at https://ghc.haskell.org/trac/ghc/ticket/14526
15:34:57 <aplainzetakind> It can't find libtinfo.so
15:35:15 <aplainzetakind> At the end: https://paste.pound-python.org/show/otv3u7q5pqZOAukYvx5I/
15:35:37 <geekosaur> that's a system dev library for ncurses, stack can't install it for you
15:38:45 <aplainzetakind> find / -regex '.*libtinfo.*' returns nothing.
15:40:40 <sm> aplainzetakind: ok, you need to install libterminfo or similar
15:41:02 <sm> terminfo
15:41:30 <tnks> geekosaur: thanks.  I very circumstantially was right above the section in the Cabal manual where that was explained.
15:42:09 --- mode: glguy set +v Stu
15:42:10 <Stu> Hi
15:42:27 <Stu> What does prelude stand for?
15:42:44 <Stu> Is that mean helper methods
15:43:14 <geekosaur> 'introduction', sort of. think 'prelude and fugue'
15:43:19 <sm> Stu: yes. Preliminary definitions
15:43:20 <geekosaur> (music)
15:43:33 --- mode: glguy set +v jackdk
15:49:34 <aplainzetakind> sm: I installed terminfo, but still no libtinfo.so.6
15:50:03 <sm> sometimes it's the dev version. terminfo-dev  ?
15:51:47 <sm> I see "You may add USE flag 'tinfo' to sys-libs/ncurses and re-emerge it, then libtinfo.so will be installed in /usr/lib64/" but I have no idea if that's good advice
15:51:55 <aplainzetakind> A forum post says it comes from ncurses?
15:52:43 <aplainzetakind> Alright.
15:54:09 <MarcelineVQ> "<glguy> MarcelineVQ: That's the first use of italics I think I've noticed in channel :)" I'm a little oldschool, one would use some whisper emoji these days I suppose :>
15:54:44 <sm> aplainzetakind: good luck. I'd say this is worth a stack bug report, it should have shown that error more clearly
15:55:18 <geekosaur> aplainzetakind, there's some complex history there leading to the best bet for building on multiple different systems being programs using libtinfo and seeing what's needed to get it installed
15:56:00 <geekosaur> if someone's building ncurses in sysv mode (several linuxes do this), libncurses.so won't have the symbols from libtinfo.so
15:56:23 <Stu> So what should go in prelude, do sum type and product definitions go in the prelude or just helper functions
15:56:56 <hpc> the haskell report specifies what goes in the prelude
15:58:12 <hpc> it contains everything that's in scope when you don't import anything
15:58:34 <hpc> IO, Num, Int, show, read, etc
15:59:29 --- mode: glguy set +v jkachmar
16:00:10 <aplainzetakind> sm: stack setup is now downloading ghc-tinfo
16:00:33 <aplainzetakind> I expected it to go ahead and do the same thing and not hit that error.
16:00:40 <aplainzetakind> Let's see what happens.
16:01:24 <sm> stack can't know how to install system packages on every distro.. but it should have reported the error more clearly
16:10:57 <consord> Hi all, does anyone know what stack options to set to statically link in dynamic libraries?
16:11:37 <consord> I've got the following dynamic libraries reported by otool
16:11:42 <consord> /usr/lib/libSystem.B.dylib
16:11:44 <consord> /usr/lib/libz.1.dylib
16:11:46 <consord> /usr/lib/libiconv.2.dylib
16:11:48 <consord> /usr/local/opt/gmp/lib/libgmp.10.dylib
16:11:50 <consord> y
16:12:14 <consord> Disclaimer, I don't know much about this kind of thing!
16:24:38 <geekosaur> consord, for starters, libSystem can't be statically linked
16:39:09 <consord> geekosaur: that's okay
16:39:27 <consord> I'm really aiming for portable binaries, so the libSystem dependency should just be available
16:41:29 <geekosaur> the stuff in /usr/lib you can rely on; Apple doesn't permit overwriting or replacement, and they come with all systems. libgmp, I would expect a bundled one is used unless you are using a ghc from homebrew (in whcih case you will be better off requiring homebrew to be insatlled)
16:42:07 <consord> I really don't want to require any installation as this is for non-technical users
16:42:57 <consord> I'm going to go through similar exercise for linux and windows too, but starting with os x
16:44:13 <consord> maybe I'm taking the wrong aproach and should have some kind of installer bundle the dlls
16:45:46 <xsperry> just found out about package.yaml when it was mentioned in this channel. is it worth exploring further for someone who uses stack? 
16:46:18 <geekosaur> I am serious if yu got ghc or anyting sle you are using from homebrew. at msot you can look up how to build a "cask" or whatever they're calling it these days; you can'rt build a standalone package from it, or any other third party package system
16:47:31 <consord> geekosaur: understood, it's fine for me as a dev, but some of the end users are not going to be able to handle setting up homebrew as part of running the program
16:47:34 <geekosaur> apple doesn't build their systems so they can work that way, you have to commit to either system libs or the third party package system. otherwise you end up conflicting wth OS libraries
16:47:47 <geekosaur> ten make sure none of homebrew is visible to the build
16:47:49 <geekosaur> none of it
16:47:55 <geekosaur> or macports or whatever
16:48:28 <consord> geekosaur: won't that then just fail to build due to lack of libgmp?
16:48:29 <geekosaur> you don;'t getto pick adn chose, you go all-appleofr you go all-homebrew or etc. you *cannot* build a working standalone setup that way
16:48:48 <consord> as I mentioned I don't really know what I'm doing :)
16:48:58 <jle`> unclechu: i think the way you have written already should cause a warning when you add a new constructor to doorstate?
16:50:06 <monochrom> Hrm, interesting, GHC 8.4.4
17:00:09 <unclechu> jle` (IRC): i just made another change today with a `case` inside of every match, this way it's getting me warnings for incomplete patterns
17:00:48 <unclechu> you probably see this last change, not previous one, i'm just wondering if there's another way to do it
17:06:06 <jle`> unclechu: ah, i see! glad you figured out a nice way :)
17:06:24 <jle`> yeah, writing these sorts of instances are inherently unsafe, because SomeDoor is essentially just an un-typed door
17:06:32 <aplainzetakind> How does one go about resolving an error during a stack build, which stack thinks lies with a dependency source?
17:06:39 <jle`> so it's about as safe as writing an instance for an untyped door
17:06:47 <MarcelineVQ> aplainzetakind: depends on the error
17:07:20 <jle`> unclechu: but actually hm, at least having SomeDoor enforces the compiler that you can't compare doors unless they are matched with the same SDoorState, so that does help actually
17:07:38 <aplainzetakind> MarcelineVQ: https://paste.pound-python.org/show/oyh9RW54ahbpl1ZlZjXu/
17:07:43 <unclechu> <freenode_jle "so it's about as safe as writing"> i'd say it's not true, because when singletons are matched it means both `Door`s have the same state
17:08:50 <unclechu> otherwise i coulnd't do `==` stuff on them
17:09:31 <geekosaur> aplainzetakind, you're building with a later version of ghc and base than it expects; MnadFail is new
17:09:52 <geekosaur> you need to add MonadFail instances to varius things
17:10:06 <geekosaur> or use an older ghc
17:10:44 <aplainzetakind> geekosaur: How can I find out exactly what ghc to use?
17:11:03 <MarcelineVQ> geekosaur: which ghc is requring MonadFail from?
17:12:28 <Clint> MarcelineVQ: 8.6 changed things
17:12:30 <geekosaur> 8.6 is when it became default
17:12:45 <geekosaur> 8.4 has it but you need -XMonadFailDesugaring
17:13:44 <jackdk> is https://wiki.haskell.org/MonadFail_Proposal up to date?
17:13:56 <geekosaur> aplainzetakind, so ^^ 8.4 or earlier wil work, if you want 8.6 then you need to add MonadFail instances. see http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-Fail.html
17:14:01 <MarcelineVQ> aplainzetakind: what does you stack.yaml look like? 8.6 is from the nightly which doesn't have libmpd
17:14:08 <geekosaur> which has compat information
17:14:56 <geekosaur> unless you used 8.4 with -XMonadFailDesugaring in which case you want to turn that off
17:15:12 <aplainzetakind> The stack.yaml was autogenerated with nightly.
17:15:16 <aplainzetakind> I'll change that.
17:15:34 <aplainzetakind> But to what exactly?
17:15:58 <monochrom> Now you have to look up which resolver corresponds to which GHC version.
17:16:15 <MarcelineVQ> aplainzetakind: do you care what ghc you're using?
17:16:45 <aplainzetakind> Not really.
17:16:55 <aplainzetakind> I'm trying to install xmonad.
17:17:08 <aplainzetakind> Following this: https://brianbuccola.com/how-to-install-xmonad-and-xmobar-via-stack/
17:18:49 <MarcelineVQ> That's weird that it choose nightly.  changing to  lts-12.13  may be enough to avoid this issue, assuming those xmonad deps don't themselves require something newer
17:18:52 <aplainzetakind> Is lts-12.13 good?
17:18:54 <aplainzetakind> OK/
17:18:56 <aplainzetakind> .
17:26:44 <MarcelineVQ> Where can you find out what non-base libraries come with ghc currently
17:27:40 <realfascism> is ghc 8.6 or 8.4 latest? is 8.6 unstable?
17:27:43 <MarcelineVQ> seems to be https://www.haskell.org/platform/contents.html
17:27:54 <MarcelineVQ> *answering myself
17:28:08 <monochrom> 8.6 is stable.
17:28:15 <monochrom> and latest.
17:28:56 <monochrom> But 8.4 gets an exceptional bugfix so 8.4.4 is newer than 8.6.*
17:29:15 <koz_> monochrom: Isn't 8.6 also getting a fix soon-ish?
17:29:22 <monochrom> I don't know.
17:30:54 <monochrom> One of the fixes is for a serious bug in the text library.  Possibly 8.6.1's text version doesn't have that bug to begin with.
17:33:31 <realfascism> I am on archlinux and stack seems to give 8.4.3
17:33:39 <realfascism> now call me a loser but I want 8.6
17:33:48 <realfascism> how can I install 8.6? just download?
17:33:59 <koz_> realfascism: Stack defaults to an LTS resolver I think.
17:34:04 <koz_> You have to change stack.yaml to use a nightly.
17:34:10 <koz_> Since the current range of nightlies are 8.6s.
17:34:34 <realfascism> when I use pacman on archlinux for stack it wants to install like 40 pacakges
17:34:49 <realfascism> I kinda just want a basic stack and then yeah to point to 8,6
17:34:50 <realfascism> how?
17:34:58 <realfascism> 8.6
17:35:13 <koz_> realfascism: When you use 'stack new', it'll make you a project with an LTS resolver in the stack.yaml.
17:35:27 <koz_> Go there, and change 'lts-whatever' to 'nightly-today's-date'.
17:35:43 <koz_> https://www.stackage.org/ <-- this lists the current LTS and nightly versions.
17:35:47 <realfascism> ok so I should let archlinux pacman install all this stuff?
17:35:48 <koz_> (along with which GHC they use)
17:35:50 <koz_> No.
17:36:00 <koz_> If you're gonna use Stack, it will handle everything.
17:36:03 <MarcelineVQ> "<realfascism> when I use pacman on archlinux for stack it wants to install like 40 pacakges"  get a bin here https://github.com/commercialhaskell/stack/releases and put it in  ~/.local/bin then put  ~/.local/bin on your path   from now on to get new stack versions you can just type  stack upgrade
17:36:04 <realfascism> ok
17:36:42 <realfascism> curl -sSL https://get.haskellstack.org/ | sh      this to install basic stack?
17:36:42 <koz_> MarcelineVQ: I've always been curious - does the VQ in your nick stand for something?
17:36:46 <MarcelineVQ> alternatively you can use the AUR to install stack-bin
17:36:52 <MarcelineVQ> koz_: Yep
17:37:00 <koz_> OK, good to know.
17:40:04 <realfascism> curl -sSL https://get.haskellstack.org/ | sh      this to install basic stack?
17:40:32 <realfascism> is this the way to go?
17:40:50 <realfascism> then repoint to the nightly ?  https://www.stackage.org/nightly-2018-10-15
17:42:48 <realfascism> hmmmmmmm
17:42:50 <MarcelineVQ> If you like, I wouldn't do that myself since I think it puts the stack executable in /usr/local/bin/stack
17:43:09 <realfascism> or should I let pacman install everything then change the yaml and update?
17:43:12 <realfascism> oh crap
17:43:35 <MarcelineVQ> Which is not where it puts the executables it makes when you upgrade it, so you can end up with mysterious pathing issues
17:46:06 <aplainzetakind> Now stack thinks there's an error in a C header.
17:46:08 <realfascism> ok so what would u do? use pacman to get 8.4.3 then change the yaml file to nighly then update?
17:46:26 <MarcelineVQ> I said what I would do
17:46:33 <MarcelineVQ> So scrol up if you missed it :>
17:48:05 <aplainzetakind> https://paste.pound-python.org/show/OMxGtdrxPyp9XrPY3jPJ/
17:50:41 <realfascism> https://github.com/commercialhaskell/stack/releases  ok I see x86_64   gmp static or seemingly plain.... which one?
17:51:46 <MarcelineVQ> realfascism: try just the plain guy and see if it works
17:52:46 <MarcelineVQ> That's what I used on arch, though my arch won't neccesarily be your arch, so we'll see
18:00:01 <realfascism> ok have it in .local/bin
18:00:21 <realfascism> now I wonder if I need gcc n stuff that the other method mentioned as needing dependencies
18:00:38 <realfascism> Since this installer doesn't support your Linux distribution,
18:00:39 <realfascism> there is no guarantee that 'stack' will work at all!  You may
18:00:39 <realfascism> need to manually install some system info dependencies for GHC:
18:00:39 <realfascism>   gcc, make, libffi, zlib, libgmp and libtinfo
18:00:59 <realfascism> or should I just let rip
18:01:33 <MarcelineVQ> should just require gmp and zlib which is likely you already have, so give it a try
18:02:32 <realfascism> # stack upgrade
18:02:32 <realfascism> Current Stack version: 1.9.0.1, available download version: 1.7.1
18:02:33 <realfascism> Skipping binary upgrade, you are already running the most recent version
18:03:00 <realfascism> so far so good
18:04:08 <realfascism> ok hmm so to get ghc 8.6.....
18:04:32 <realfascism> https://docs.haskellstack.org/en/stable/README/  so I want to start a new project?
18:07:21 <MarcelineVQ> If you want a new project yes, which you usually do. Whether you're working in a project or not you modify a stack.yaml to choose what libraries and compiler are available. For a project, that will be its stack.yaml, for running stack outside of a project you would edit .stack/global-project/stack.yaml
18:12:13 <realfascism> resolver: nightly-2018-10-15
18:12:26 <realfascism> ok have this in stack.yaml in my-project
18:13:36 <realfascism> stack build working sofar!!
18:13:39 <realfascism> very excisiting!
18:13:43 <realfascism> thx for help!
18:14:10 <realfascism> I want to try happstack.com for web domination!
18:19:03 <realfascism> ok it built some stuff but ghci doesnt work
18:19:15 <realfascism> wonder where it put ghc 8.6.1
18:19:34 <MarcelineVQ> when using stack you use things via stack, so that's stack ghci   or stack exec ghci
18:21:04 <realfascism> oh wow it works
18:21:20 <realfascism> so evrything runs thru stack....ok heh I am new to haskell
18:21:24 <realfascism> gota get used to these kinks
18:22:03 <monochrom> If you don't use stack then you can use GHC directly.  I use GHC directly.
18:23:14 <monochrom> You may dominate the web, but stack dominates you now.
18:23:25 <realfascism> totally
18:23:52 <realfascism> so is it liek simpler to install ghc then just grab things with cabal?
18:24:07 <realfascism> I have stack now
18:24:09 <MarcelineVQ> Side-issue, I don't think happstack-server is available for ghc 8.6.1 yet
18:24:24 <monochrom> Life with stack can be simple too.  The trick is to obey stack.
18:24:26 <realfascism> damn I am stepping on my own dik tonight a lot
18:24:42 <realfascism> I need to wise up
18:24:55 <realfascism> haskell does look cool n powerful to me
18:25:24 <MarcelineVQ> If you want to use happstack-server tonight then you'll need to drop back to  lts-12.13   which is ghc 8.4.3
18:25:34 <realfascism> ok
18:26:35 <realfascism> so what I could just mkdir my-project2 and then repeat above with that adjustment?
18:27:15 <realfascism> or is it globally stuck on that resolver
18:27:29 <realfascism> does it key off of the project folder its in currently?
18:27:48 <realfascism> sorry for being such a n00b
18:28:04 <MarcelineVQ> It depends on the stack.yaml it can find. If there's one in the directory you're running stack from it'll use that, if there isn't it'll use the global one mentioned earlier
18:28:41 <realfascism> ah ok
18:30:54 <MarcelineVQ> monochrom: I wouldn't advocate for stack for everyone but it's been the most painless route on arch for me so far so I would there
18:31:13 <MarcelineVQ> realfascism: have a gander at https://docs.haskellstack.org/en/stable/GUIDE/ when you can
18:31:28 <realfascism> ok
18:32:19 <monochrom> Yeah I advocate using GHC directly first.
18:32:28 <geekosaur> of late, pretty much anything is a better route on arch
19:08:17 --- mode: glguy set +v abhiroop
19:08:35 <abhiroop> Any recommended readings/literature for graph reduction machines (except the STG paper)?
19:20:15 <MarcelineVQ> geekosaur: did you know there's a package manager on arch made in haskell? it's called aura, dunno much about it, just installed
19:20:58 <MarcelineVQ> aha, seems to be for AUR packages, naturally I suppose :>
19:23:45 <MarcelineVQ> Gosh, worth it just for "-O,--orphans             Display all orphan packages."  "-j,--abandon             Uninstall all orphan packages."
19:58:37 <suzu> yep i use aura
19:58:43 <suzu> i did not know about those two flags
20:01:13 <suzu> i am.. wary about using this
20:01:23 <suzu> it is claiming that tons of things are orphan packages
20:02:05 <MarcelineVQ> Yeah depending how they were installed I guess it doesn't know, I had to  aura -O --adopt PKG  a few things before nuking the rest
20:05:04 <maerwald> my package manager is written in C++
20:10:03 <joebobjoe> what is meant by "it is possible to deadlock in any turing complete language"? is that true? even without parallelism?
20:10:56 <selfsymmetric-mu> That seems like an odd thing to say. Where did you read that?
20:10:58 <MarcelineVQ> depends what deadlock means and then in what context it's being said
20:11:32 <selfsymmetric-mu> How do you make a Turing machine deadlock?
20:11:57 <selfsymmetric-mu> You can make it halt, you can make it loop, but you can't make it _lock_.
20:12:21 <joebobjoe> selfsymmetric-mu MarcelineVQ, https://github.com/ziglang/zig/wiki/Why-Zig-When-There-is-Already-CPP,-D,-and-Rust%3F
20:13:16 <tnks> I see that I can pass arguments to tasty when I use new-run as in "cabal new-run test -- --color never", but how can I do something similar with "new-test"?
20:13:23 <tnks> I don't see a switch to pass options.
20:14:00 <joebobjoe> the zig irc chan hasn't responded so I asked here since I thought haskellers would know and it is kind of a generic statement
20:14:22 <geekosaur> I think they're using "deadlock" rather looselyt here
20:14:30 <geekosaur> so it includes loops, etc.
20:14:35 <selfsymmetric-mu> joebobjoe: In this context, I believe the author is saying that "Rust and D both have features that can prevent `bar` from being called even if `foo` otherwise terminates in a finite amount of time. However Zig does not, so you can be sure that `bar` will be called."
20:15:31 <selfsymmetric-mu> I think it's poorly phrased, to be honest. To me, deadlock always implies locked contention for shared resources.
20:15:43 <MarcelineVQ> deadlock seems to be ther name for unproductive loop here
20:15:49 <joebobjoe> selfsymmetric-mu, yea my question was about the "turing completeness" statement
20:15:54 <selfsymmetric-mu> Here they're just highlighting Zig's lack of hidden control flow.
20:16:28 <selfsymmetric-mu> joebobjoe: If your language is total, then all functions terminate in a finite amount of time.
20:16:36 <joebobjoe> zig is total?
20:16:47 <selfsymmetric-mu> I did not mean to imply that.
20:16:54 <geekosaur> yeh. iot leaves me worried as to whether (a) their understanding si good enough, or (b) I have to go check what *they* man by any given term with a well-defined standard meaning
20:17:03 <geekosaur> mean by
20:17:11 <geekosaur> they themselves say it is not
20:17:18 <geekosaur> the are saying there's o *hidden* control flowe
20:17:22 <selfsymmetric-mu> I can unwrap it more.
20:18:29 <selfsymmetric-mu> In total languages all functions return in finite time. Turing complete languages contain non-total functions. Zig is Turing complete. Rust and D are Turing complete. Therefore in any of them `foo` could take infinite time. However Zig does not have exception handling or operator overloading. This makes it harder to hide control flow.
20:18:50 <selfsymmetric-mu> joebobjoe: Does that make sense?
20:19:32 <geekosaur> "if it doesn't look like it's doing extra stuff behind your back, it isn't"
20:20:13 <geekosaur> whereas "foo()" is explicitly telling you that you need to look at the definition of foo to be sure what it's doing
20:21:38 <joebobjoe> who would design a function that takes infinite time
20:21:41 <joebobjoe> that sounds stupid
20:22:18 <MarcelineVQ> Well, if that's all it does it seems a little useless yes, there's plenty of things that run forever that are useful though
20:22:44 <joebobjoe> yes, "useless", not "stupid" sorry
20:22:59 <blankhart> > [1..]
20:23:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:23:24 <joebobjoe> that computation halted though
20:23:31 <joebobjoe> unless lamdabot is still running it
20:23:38 <geekosaur> joebobjoe, the more interesting cases are the ones where runtime is determined by external data. lie, say, processing data from a network connection
20:23:56 <geekosaur> (nwo go look at e.g. the "Slowloris" network attack)
20:24:04 <joebobjoe> geekosaur, like relying on foreign input for control flow?
20:24:41 <geekosaur> unbounded looping or recursion controlled by an outside source, yes
20:24:45 <tnks> in case anyone read my question... I just found the answer:  
20:24:54 <tnks> https://github.com/haskell/cabal/issues/4643
20:25:17 <nshepperd> sometimes being stupid is the only way
20:25:42 <geekosaur> total languages require all loping and recursion to be internally bounded
20:25:50 <joebobjoe> would it be smart, then,  to write network-facing code in a "total" language, as you say?
20:26:30 <geekosaur> no, you cant write many useful network services in a total language.
20:27:00 <joebobjoe> well I meant, just the parsing parts
20:27:06 <geekosaur> or even non-network services. you can't do much with databases ina  total language because you can only deal with a fixed maximum mount of data, fro example
20:27:55 <joebobjoe> what are total languages useful for then?
20:30:38 <geekosaur> for examle, some safety and industrial control-based stuff where you need bounded execution guarantees or limits
20:31:10 <blankhart> idris has a totality checker but does not enforce it in order to be a general purpose language iirc
20:31:15 <MarcelineVQ> Total languages aren't neccesarily that limiting: Totality can also be defined for a finite prefix of some infinite process. As such we may produce output without terminating and remain total, since we can determine the totality of a finite prefix, and by induction we're going to be able to keep producing output.
20:31:27 <geekosaur> you don't want anythng that can lead to unbounded looping in the controller for a traffic light
20:32:12 <geekosaur> (it does "loop" but by running the same program over and over)
20:33:05 <MarcelineVQ> But at some point you probably need a non-total spark to get going with so I might be off-base there, hmm
20:34:23 <joebobjoe> yea but how do you guarantee the prefix is a pattern that continues to repeat forever?
20:35:25 <joebobjoe> I guess that would be the traffic light scenario... a prefix that repeats forever?
20:37:29 <MarcelineVQ> data Stream a = MkStream a (Stream a)   structurally this guarantees there's always more Stream to see, since the only way to make a Stream is with some value of a, and more Stream
20:38:33 <MarcelineVQ> Unlike say, list  data List a = Nil | Cons a (List a)  which can abruptly end in a Nil instead of there being more List
21:03:20 <fragamus> Hi do we have a way to make recursive lambda functions
21:06:49 <MarcelineVQ> fix is often used for this
21:07:05 <fragamus> :t fix
21:07:07 <lambdabot> (a -> a) -> a
21:07:48 <fragamus> Thank you
21:40:25 <tnks> I'm noticing some people intentionally not putting version bounds on some dependencies, which seem to be lower-level libraries.  Does anyone know the rationale there?
21:41:16 <MarcelineVQ> where do you notice it?
21:49:57 <tnks> MarcelineVQ: Vinyl and Bloodhound to start with.  acowley just replied (on Twitter) that he didn't bound libraries coming with GHC.
21:57:38 <MarcelineVQ> ah neato. the two options that sprung to mind from your question were people stuck in a stack mindset where your resolver solves the versions which is not a particularly good habit, and libraries that came with ghc. having a gander at bloodhound it looks like the unbounded things are bounded by their own dependencies, e.g. blaze-builder depends on bytestring-builder depends on bytestring which comes with ghc, idk if that's good 
21:57:38 <MarcelineVQ> practice at all though
21:59:07 <MarcelineVQ> *I don't know what is good practice.
21:59:16 --- mode: glguy set +v monadic
22:40:43 <jle`> tnks: well libraries that come with ghc are fixed by the version of base, so it's no different than restricting base essentially
22:44:32 <dminuoso> phadej: By the way, thanks for the talk in London. It was quite overwhelming, but there were quite a few useful bits for me there. :)
22:44:45 <dminuoso> Never thought it was *that* easy
22:47:39 <cocreature> jle`: thatâ€™s not quite true, e.g., transformers comes with GHC but as long as you donâ€™t depend on the ghc library you are perfectly free to upgrade to a different version
22:48:36 <jle`> oh huh
22:48:49 <jle`> thanks for letting me know
22:48:53 <jle`> my life is changed today
22:50:27 <cocreature> thatâ€™s one of the things that annoys me the most about stackage. the insistence on a consistent snapshot which includes the ghc lib results in stackage never upgrading transformers, containers, â€¦
22:51:04 <cocreature> so people are stuck on a version of transformers that doesnâ€™t have the fix for the space leaks
22:51:11 <MarcelineVQ> Yes, it has mattered once or twice for me in the past and I don't even write that much
22:51:59 <koz_> cocreature: Which version _does_ fix those space leaks, out of interest?
22:54:10 <cocreature> koz_: I think 0.5.3 started fixing some but the latest version 0.5.5 fixed a few more
22:54:26 <cocreature> and itâ€™s just a minor release so if you can there is little reason not to upgrade
23:27:55 <phadej> dminuoso: thanks!
23:32:57 <jhu> Another quiz here. Say I have the following data: let d = [Right $ Right <$> [1..]] :: [Either String [Either String Int]]. Is there a way to use takeWhile on this so that the result is of type Either String [Int]?
23:34:31 <maerwald> cabal new-exec is trying to load a wrong environment file
23:35:08 <cocreature> jhu: can you be a bit more precise? how exactly do you want to apply takeWhile to this?
23:35:35 <maerwald> https://privatebin.net/?0573632a51c7c5b4#2tCM17nTerrn0//l+8iSi6VGTFaP0Mk+lQwfpVgAQiE=
23:38:05 <jhu> cocreature: For the data "d" given above, I would want a function "fun" for which "fun (takeWhile (<3)) d" equals "Right [1, 2]"
23:41:39 <ion> @type fmap (takeWhile (<3))
23:41:40 <lambdabot> (Num a, Ord a, Functor f) => f [a] -> f [a]
23:41:57 <cocreature> do you want to limit the individual lists or the total number of elements here?
23:42:27 <cocreature> what should be the result for Right [Right [1,2,3], Right [1,2,3]]
23:43:10 <cocreature> and for [Right [Right 1,Right 2], Left "", Right [Right 3]]
23:48:15 <jhu> Hold on... The type of result would actually have to be Either String [[Int]], and "fun (takeWhile (<3)) d" should equal "Right [[1,2]]" Therefore the result for "Right [Right [1,2,3], Right [1,2,3]]" should be "Right [[1,2], [1,2]]" and for "[Right [Right 1,Right 2], Left "", Right [Right 3]]" it should be 'Left ""'. I should take a break, I have been staring at these for too long. :)
23:49:08 <leifmetcalf> What's an example of a well-written API wrapper library?
23:52:40 <xacktm> by "API wrapper library" do you mean like how bloodhound is to elasticsearch?
23:53:19 <Axman6> or one of the Servant libraries?
23:54:10 <leifmetcalf> Looking at the bloodhound examples I think a lot simpler than that
23:54:58 <leifmetcalf> Just a library that provides functions like (Request -> IO Response)
23:55:09 <alp> http-client, wreq, req ?
23:55:13 <Axman6> that doesn't sound like a good API to me
23:56:03 <leifmetcalf> I don't really know how these things are done
23:56:25 <leifmetcalf> I have an API, I want to easily Get things from it
23:56:30 <Axman6> IMO Servant is dwefinitely the way to go when defining an API for a web API
23:56:58 <Axman6> the servant-client can automatically generate the client functions from an API description
23:57:21 <xacktm> yeah, sounds like you want an *HTTP* API wrapper library, and I can second servant
23:57:27 <leifmetcalf> Right, I'll try servant
23:58:09 <leifmetcalf> Sorry I forgot to specify it was over HTTP
23:58:57 <Axman6> I love servant so much I don't even know how to make webAPIs (both client and server) without it anymore
23:59:27 <alp> leifmetcalf, http-client, wreq, req are libraries that let you build and send arbitrary HTTP requests, while servant-client "forces" you to define the API you're hitting precisely so that it can then derive (i.e write for you) functions to hit every endpoint of the API
23:59:29 <Axman6> https://haskell-servant.github.io/client-in-5-minutes.html
23:59:50 <alp> that page might be a bit out of date, but that's the spirit.
23:59:56 <cocreature> jhu: I donâ€™t think there is an easy codegolf-style solution here. you probably just have to get your hands dirty and write some code
