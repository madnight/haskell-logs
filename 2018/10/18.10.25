00:00:15 <matzy_> oh you switched the order of the var and ?
00:00:44 <matzy_> damn i'm confused.  could you re-do that using a common function?  is ? just a normal function?
00:00:48 <srhb> Probably clearer with division
00:02:25 <int-e> matzy_: in (? y) the second argument is fixed rather than the first one
00:02:41 <Martin333[m]> matzy_: Yes, if you put the operand to the right, the function defining the operator is flipped before being applied to the operand.
00:02:57 <srhb> > [(/2) 1, (2/) 1]
00:02:59 <lambdabot>  [0.5,2.0]
00:03:16 <int-e> > let (?) = div in (? 3) 7 -- evaluates to div 7 3
00:03:19 <lambdabot>  2
00:03:32 <Martin333[m]> So `(? y) x` = `x ? y`.
00:03:32 <srhb> (divide by 2 applied to 1) vs (2 divided by applied to 1)
00:04:00 <Martin333[m]> Therefore, `(? y)` = `\x -> x ? y`.
00:05:49 <matzy_> Martin333[m]: ok that clarifies it. but wnehy is it needing a lambda instead of just needing to curry another number?
00:06:07 <matzy_> i should check what ? does first, one sec
00:06:53 <Martin333[m]> It is similarly true that `(x ?)` = `\y -> x ? y`, but unlike with `(? y)`, it is the case with `(x ?)` that it can be confusingly defined by `(x ?)` = `(?) x` instead, because `(?) x y` = `x ? y` and so `(?) x` = `\y -> x ? y`.
00:07:27 <Martin333[m]> matzy_: `?` is just an infix operator.
00:07:45 <Martin333[m]> Such a name is chosen because only special characters are infix by default.
00:08:12 <Ariakenom> non alphanumerical basically
00:08:46 <matzy_> but i can't find a typedef for it
00:09:11 <Martin333[m]> Just assume `(?) :: a -> b -> c`.
00:09:53 <matzy_> so it's a generic function which take two args and returns a third?
00:10:11 <matzy_> :t (+)
00:10:11 <Martin333[m]> Yes.
00:10:13 <lambdabot> Num a => a -> a -> a
00:10:20 <matzy_> :t (?)
00:10:21 <lambdabot> error: Variable not in scope: ?
00:10:24 <Ariakenom> > let a ? b = a + b in 1 ? 2
00:10:26 <lambdabot>  3
00:10:41 <Martin333[m]> matzy_: Note that, since `x ? y` = `(?) x y`, if we want to provide `y` but not `x` (and get a function that, given `x`, returns `x ? y`), then we are sort of getting ahead of ourselves because the `(?)` function actually takes `x` before it takes `y`. So, we need to *pretend* that we have `x` already, and talk about what should happen then. This is, of course, what lambda lets us do.
00:10:44 <matzy_> whoa need to dissect that one real quick
00:11:19 <Ariakenom> > let (?) = (+) in (1 ? 2)
00:11:21 <lambdabot>  3
00:12:07 <Martin333[m]> Intuitively, the syntaxes `(x ?)` and `(? y)` allow us to put in one of the operands and get a function taking the missing one.
00:12:09 <matzy_> Martin333[m]: ahhhh i get it!
00:12:15 <Martin333[m]> :D
00:12:50 <matzy_> yeah i haven't learned infix operators yet, just infix functions
00:12:56 <matzy_> or at least haven't learned ? yet
00:13:01 <Martin333[m]> So whereas putting in the first of two operands is extremely easy in Haskell due to currying, putting in the second operand but not the first one is a relative hassle.
00:13:05 <matzy_> are they the same thing?
00:13:24 <matzy_> ok i see.  so that's the problem it solves
00:13:38 <Martin333[m]> Yes, I used the word operator because I was thinking on the syntax level of things.
00:14:40 <matzy_> so would this be a similar situation? 'sevenDividedBy = (7/)' ?
00:14:44 <Martin333[m]> Maybe infix function is what it is called (not sure); IMO that makes it sound like it's some integral property of the function, which I wouldn't say because the whole infix thing really boils down to syntactic conveniences.
00:15:17 <Martin333[m]> (Note that infix is entirely about convenience and not at all necessary, and without it Haskell would look more like Lisp. :P )
00:15:39 <Martin333[m]> matzy_: Yes!
00:15:42 <Ariakenom> > ((+) 1 2)
00:15:44 <lambdabot>  3
00:16:54 <Ariakenom> > negate `map` [-1,0,1]
00:16:56 <lambdabot>  [1,0,-1]
00:17:16 <matzy_> Martin333[m]: so how would i do that then?
00:17:29 <Martin333[m]> matzy_: Sorry, what?
00:17:37 <matzy_> wait one sec lemme try.  i meant my example
00:18:03 <Martin333[m]> `sevenDividedBy 2` will give `3.5`.
00:19:01 <Ariakenom> > let sevenDividedBy = (7/) in sevenDividedBy 2
00:19:03 <lambdabot>  3.5
00:19:46 <matzy_> oh yeah i guess that's not the same thing as with the ?
00:20:11 <matzy_> no lambdas necessary
00:20:39 <Martin333[m]> If you don't have a computer, you can put GHC in your brain and think it through mechanically: `sevenDividedBy 2` = `(7 /) 2` = `(\y -> 7 / y) 2` = `7 / 2` = `3.5`. (Note that installing GHC into brain may lead to headaches.)
00:21:10 <Martin333[m]> Oh right I forgot we were using the definition of `x ?` = `(?) x`.
00:21:18 <Martin333[m]> So maybe that was just confusing.
00:21:47 <Martin333[m]> matzy_: No, it is exactly the same thing; the difference here is that you are fixing the left operand (i.e. the first argument).
00:22:13 <Martin333[m]> Or actually I'm not quite sure what you mean since you are using the syntax and not defining it.
00:24:57 <matzy_> i think i get it.  i was understanding the role the lambdas played without realizing they were actually being used
00:25:04 <matzy_> i just thought it was some more haskell magic
00:25:32 <Martin333[m]> Huh.
00:26:43 <Ariakenom> ((?) x = (x ?)) => ((?) x = (?) x) => not very constructive
00:26:50 <matzy_> but maybe not.  let's say we have 'divideByTen = (/10)' and 'sevenDividedBy = (7/)'.  are those basically the same thing (just using currying?)
00:27:10 <Ariakenom> same how?
00:27:39 <Martin333[m]> matzy_: In the first, you are fixing `y`; in the second, you are fixing `x` (as in `x ? y`).
00:28:05 <matzy_> and they both use lambdas for the currying?
00:29:01 <matzy_> i'm confused on the whole 'we have the second arg but needed to get the first one first, so we need a lambda'
00:29:21 <Martin333[m]> Well I mean I don't know how they're implemented.
00:29:31 <tauoverpi[m]> <freenode_mat "i'm confused on the whole 'we ha"> (/n) = \x -> x/n
00:30:25 <Martin333[m]> I'm just saying what it means by giving an equivalent expression.
00:30:33 <heaven> hello martin
00:30:36 <heaven> why are you using matrix
00:30:51 <Martin333[m]> While code is meant to be read by computers, my messages are meant to be read by humans.
00:31:30 <Martin333[m]> heaven: Hello, why do you ask? Do I know you?
00:31:41 <Ariakenom> > "por que no los dos"
00:31:43 <lambdabot>  "por que no los dos"
00:32:06 <matzy_> Martin333[m]: this message is what's confusing me:
00:32:15 <matzy_> "matzy_: Note that, since `x ? y` = `(?) x y`, if we want to
00:32:15 <matzy_> 			   provide `y` but not `x` (and get a function that, given `x`,
00:32:15 <matzy_> 			   returns `x ? y`), then we are sort of getting ahead of
00:32:15 <matzy_> 			   ourselves because the `(?)` function actually takes `x` before
00:32:18 <matzy_> 			   it takes `y`. So, we need to *pretend* that we have `x`
00:32:21 <matzy_> 			   already, and talk about what should happen then. This is, of
00:32:24 <matzy_> 			   course, what lambda lets us do."
00:32:27 <matzy_> oh my lord formatting
00:33:13 <matzy_> "matzy_: Note that, since `x ? y` = `(?) x y`, if we want to provide `y` but not `x` (and get a function that, given `x`, returns `x ? y`), then we are sort of getting ahead of ourselves because the `(?)` function actually takes `x` before it takes `y`. So, we need to *pretend* that we have `x` already, and talk about what should happen then. This is, of course, what lambda lets us do."
00:33:54 <matzy_> would that situation you described apply to any of my functions if they were both called with just one int as the argument?
00:34:23 * hackage docusign-base 0.0.1 - Low-level bindings to the DocuSign API  http://hackage.haskell.org/package/docusign-base-0.0.1 (maerwald)
00:34:41 <Martin333[m]> Well yes, since you're using the infix notation feature.
00:34:53 <heaven> is this related to pointfree style?
00:35:09 <Martin333[m]> But you're using the syntax; that thing I wrote explains why lambda is a good way to define the syntax.
00:35:46 <matzy_> oh so you were explaining the logic behind the syntax?
00:36:08 <Martin333[m]> heaven: We are talking about how infix notation and lambda notation works & stuff.
00:36:16 <Martin333[m]> matzy_: Yes, exactly!
00:36:37 <matzy_> AHA!  Ok, i thought that was something I needed to apply when currying a certain way
00:37:19 <Ariakenom> Anyone know a nice way to reverse bits of an int?
00:37:28 <Martin333[m]> I see, sorry to confuse haha.
00:37:42 <matzy_> so 'divideByTen = (/10)' and 'sevenDividedBy = (7/)' can both be curried (and called like 'divideByTen 200' and 'sevenDividedBy 3')?
00:38:52 <Martin333[m]> Well, you could say that the answer to your question is yes, but on another note, I would like to ask: what do you mean by 'can be curried'?
00:39:25 <Ariakenom> sevenDividedBy = (/) 7 
00:39:26 <Ariakenom> divideByTen = flip (/) 10
00:41:01 <Martin333[m]> matzy_: The fact that everything is curried is just a part of Haskell. That's why, given `f x y` = `bla`, you can write `f x` and get `\y -> bla`.
00:41:43 <matzy_> assuming y is a function, right?
00:41:58 <matzy_> what if y is an Int?
00:42:08 <Martin333[m]> Although `curry` is also a verb and means to turn a function `\(x, y) -> bla` into `\x -> \y -> bla` (for which there is a shortcut syntax, `\x y -> bla`).
00:42:36 <Martin333[m]> (In fact, `curry` is a standard function that does just that.)
00:42:51 <Martin333[m]> matzy_: `x` and `y` can be anything.
00:43:03 <tdammers> it may be easier to grok this if you approach it from the other side
00:43:06 <matzy_> oh yeah, beacuse when you curry it returns a function always
00:43:14 <tdammers> suppose you have a language where all functions are unary
00:43:20 <tdammers> that is, you can only have x -> y
00:43:25 <tdammers> but x and y can be anything you want
00:43:36 <tdammers> so you can also have x -> (y -> z)
00:43:43 <matzy_> ok
00:43:56 <Ariakenom> Anyone know a nice way to reverse order of bits in an int?
00:44:35 <tdammers> so suppose you have an expression that you want to wrap in a function; but that expression has more than one free variable that you want to pass in
00:44:43 <tdammers> e.g., x + y + 4
00:45:18 <tdammers> so the first thing you can do is wrap it in a unary function to get one of the two variables: f x = x + y + 4
00:45:33 <Martin333[m]> Ariakenom (IRC): Stringify in base 2, reverse, and parse in base 2? But that should be slow and bad for machine ints.
00:45:47 <Martin333[m]> Oh and you would have to zero-pad it of course.
00:46:13 <tdammers> if you want, you can write f x = x + y + 4 in f
00:46:37 <Ariakenom> Martin333[m]: yes, was asking for nicer than that
00:46:48 <tdammers> (as an aside: try to figure out the types of the entire expression, x, y, and f here)
00:46:59 <koz_> Ariakenom: Nothing prebuilt, although ZThere are these: https://graphics.stanford.edu/~seander/bithacks.html#BitReverseObvious)
00:47:02 <Martin333[m]> Ariakenom (IRC): Ah, you mean *faster*.
00:47:15 <koz_> I recommend the lookup table method, especially if you're going to do this _a lot_.
00:47:23 <matzy_> x & y :: Int 
00:47:33 <matzy_> f is a lambda?
00:47:52 <tdammers> f is a function
00:47:57 <matzy_> no f is the function itself
00:48:01 <matzy_> it's recursive
00:48:11 <tdammers> no, it's not recursive
00:48:20 <matzy_> in f?
00:48:30 <tdammers> sorry... let f x = x + y + 4 in f
00:48:42 <tdammers> that's let (f x = x + y + 4) in f
00:49:06 <Ariakenom> Martin333[m]: No I didn't mean faster.
00:49:07 <tdammers> we're just using a let-binding to define f in the expression f
00:49:21 <tdammers> :t let f x = x + y + 4 in f
00:49:23 <lambdabot> error:
00:49:23 <lambdabot>     Ambiguous occurrence â€˜yâ€™
00:49:23 <lambdabot>     It could refer to either â€˜Debug.SimpleReflect.yâ€™,
00:49:24 <matzy_> ok and then call it at the end.  i get it
00:49:38 <tdammers> ah no, we're not calling it. just gettings its value
00:49:43 <tdammers> but as you see, we're still missing y
00:49:55 <matzy_> right
00:50:04 <Martin333[m]> Ariakenom (IRC): Oh? But my suggested way is very nice in that it is very 'direct', I think.
00:50:22 <matzy_> why not just have the function take two args
00:50:27 <Martin333[m]> Since you are precisely asking to reverse the 'bits' (that is, digits in base 2).
00:50:31 <tdammers> because we only have unary function
00:50:32 <tdammers> s
00:50:36 <matzy_> oh right
00:50:40 <tdammers> functions cannot take two args
00:50:49 <tdammers> but we can write a function that takes one arg and returns f
00:51:00 <Ariakenom> Martin333[m]: yes the string way is ok. just wanted to see if there were anything clearer I hadn't thought of
00:51:19 <tdammers> :t let g y = (let f x = x + y + 4 in f) in g
00:51:20 <lambdabot> Num a => a -> a -> a
00:51:55 <Martin333[m]> Ariakenom (IRC): I suppose a list of booleans would be more representative of the contents.
00:52:05 <tdammers> note that a -> a -> a is exactly the same as a -> (a -> a)
00:52:08 <matzy_> so when you call it you return a function that will add whatever number x was to the input arg
00:52:19 <tdammers> kind of, yes
00:52:36 <Ariakenom> Martin333[m]: good point
00:52:45 <matzy_> what's the real explanation
00:52:49 <tdammers> g is a function that takes a number and returns a function that takes another number and returns a number that is the sum of that first number and the second number and four
00:53:57 <tdammers> you could also say that g takes a number and uses it to create a function f using that number, and returns that f; and f takes another number and adds it to the original number and adds 4 to it and returns the result
00:54:02 <matzy_> got it!
00:54:14 <matzy_> what is the 'in g' for at the end though?
00:54:41 <matzy_> i get 'let myfun ... in filter myfun ...'
00:54:49 <tdammers> the whole thing is a big expression with a let binding, so that lambdabot's :t command gets us the type of g
00:55:00 <Ariakenom> koz_: yes I remember the swap thing as an assembly instruction somewhere, but parameterised. it's not 
00:55:02 <matzy_> ah ok
00:55:05 <tdammers> > let x = 3 in x + x -- same idea
00:55:08 <lambdabot>  6
00:55:29 <matzy_> ahhhhh
00:55:47 <matzy_> so i have to say, learning haskell has been a blast so far
00:56:02 <Ariakenom> so it's a somewhat standardised way I guess. but I'd think a list reverse is clearer inthis case
00:56:05 <Martin333[m]> (You gotta use the let syntax if you want to give a definition for `f x` but then retrieve `f`.)
00:56:22 <matzy_> i've literally been spending what little free time i have doing it. but will there ever be practical applications for using it?
00:56:24 <tdammers> it also helps to remember that f x y == (f x) y, and a -> b -> c == a -> (b -> c)
00:56:52 <matzy_> like aside from those of you who use it at work, what else do you use it on?
00:57:03 <matzy_> seems like the strict typing would make it a bad choice for simple scripting
00:57:22 <Ariakenom> I don't think so. type inference is great
00:57:39 <tdammers> well, let's say Haskell pays my bills, people are building mission-critical systems in it, we have a rather sophisticated compiler built in it, facebook uses it for some clever spam filtering stuff, I know people who are building a computer-assisted helpdesk chat system with Haskell, etc.
00:57:44 <Martin333[m]> Hey, it still has better job prospects than other forms of meditation.
00:57:59 <Ariakenom> used it yesterday to generate numbers for a test case. it's great with list munging for searches
00:58:06 <matzy_> Martin333[m]: lol
00:58:21 <tdammers> the "strict typing", I really see that as an advantage - it adds expressivity, which is a win
00:58:31 <tdammers> I mean, if you want to go stringly-typed, you still can
00:58:53 <matzy_> i agree completely, but i would want that in the large apps i build at work, and less so when trying to make a one-off script to do something annoying
00:59:03 <tdammers> (there's a satirical package out there called acme-php that allows you to do arithmetic on strings by defining a Num instance for String)
00:59:26 <tdammers> sure, it becomes more useful as the complexity and size of the codebase increase
00:59:43 <tdammers> but I'd say the tipping point is as small as maybe 100 lines or so
01:00:00 <matzy_> tdammers: right, i feel that's where this language would really shine. yet most employers wont let me write things in haskell :)
01:00:18 <Ariakenom> lol since standard number notation is backwards I won't even call reverse, formatting it is reverse :p. somewhat confusing
01:00:32 <matzy_> instead i have a disaster of a php api to maintain written by jr devs in india
01:00:48 <Martin333[m]> Keep in mind though that people in a channel dedicated to a particular topic tend to like that topic a lot. Personally I think Perl can be good for annoying little things.
01:01:24 <matzy_> like do you use it for your larger side projects?  or just random programming needs in general?
01:01:31 <matzy_> trying to get an idea
01:01:36 <Martin333[m]> There are people in the Python channel that say that static typing restricts expressitivity.
01:01:48 <matzy_> LOL now thats a new one
01:02:07 <Martin333[m]> There are people that say that C is the only language that is usable, and there are people that use Electron to make text editors.
01:03:09 <__monty__> Electron gets a bad rap though. It's only slow if you use it wrong.
01:03:09 <tdammers> Martin333[m]: objectively speaking, they are right, in the sense that any type system will disallow some programs that can be expressed in an untyped language
01:03:21 <Martin333[m]> I suppose they work in different areas, and similarly people have varying luck when it comes to using their favourite tool at job.
01:03:29 <Martin333[m]> at work.*
01:03:42 <maerwald> tdammers: C is not untyped though
01:03:50 <maerwald> neither is python
01:04:11 <tdammers> Martin333[m]: OTOH, types provide a whole new dimension of expressivity, in that they allow you to state facts about your program that you can't easily express without them (or at least not without essentially inventing your own type system)
01:04:24 <tdammers> maerwald: unityped, if you prefer
01:04:32 <tdammers> maerwald: also, not going to have this discussion
01:04:38 <matzy_> i know everyone has their preferences and religions about all this stuff, i was more wondering what is the averge thing you guys are writing in haskell when you're usign it
01:04:38 <maerwald> aww
01:05:07 <maerwald> matzy_: web applications or DSLs, I think those are the main use cases?
01:05:33 <__monty__> matzy_: Tbh? Everything. Even if haskell's not especially suited to the task.
01:05:41 <tdammers> matzy_: I don't think there's an "average" thing - Haskell is my go-to language for pretty much anything; I will, however, pick C++ for things that are realtime-sensitive (like audio / DSP stuff), and shell scripts for small workflow automation tasks
01:06:17 <koz_> matzy_: I echo what tdammers says; however, most of what I write is PhD research code, and there, Haskell's type system is _invaluable_.
01:06:30 <matzy_> interesting, wow. i could really see it shining for writing web APIs
01:06:33 <Martin333[m]> tdammers (IRC): And in that sense, it is restrictive to use a traditional computer as a server instead of licking the network cable with your tongue.
01:06:36 <koz_> Mostly because the 'translation impedance mismatch' between the work I do and 'basically any language that's not Haskell' is a mountain.
01:06:47 <tdammers> Martin333[m]: yeah, something like that
01:07:03 <Martin333[m]> Obviously, you should still use a traditional computer, so I am just showing that it's not black and white, I guess.
01:07:04 <maerwald> I have a mixed feeling about "strong" type systems. As in: I generally don't like the expressivity they give. I'm solely interested in the part that lets me reason more easily about things. Which types may or may not do.
01:07:11 <Martin333[m]> Kind of late reply by me there.
01:07:20 <tdammers> matzy_: yep. you may want to check out servant at some point - right now it's probably going to be overwhelming, but it is amazing what you can do with types in this problem domain
01:07:51 <bahamas> hello. I'm going through this article and I have a couple of questions: https://two-wrongs.com/a-gentle-introduction-to-monad-transformers
01:08:01 <matzy_> tdammers: types are the nightmares when it comes to full-stack web apps with separate apis
01:08:17 <matzy_> *with a separate api
01:08:22 <tdammers> matzy_: not having a type checker is the nightmare IMO
01:08:33 <Martin333[m]> The thing about Haskell that makes me sad sometimes is that it is almost perfect, and then you start comparing it to math and wishing that it were perfect, and at some point you conclude that life is pointless because there is just no way.
01:08:51 <koz_> Martin333[m]: Been there, keep going back there regularly. :(
01:08:55 <tdammers> maerwald: but that's the same thing, isn't it? you can reason about things better because the language allows you to express more facts about the code (and have the toolchain verify them)
01:09:06 <maerwald> tdammers: not necessarily
01:09:20 <maerwald> higher expressivity usually means less easy to reason about
01:09:27 <maerwald> at some point
01:09:47 <tdammers> fsvo "usually"
01:09:55 <maerwald> yes, like servant
01:09:57 <Lycurgus> computing is bigger than math, just as thought generally is
01:10:09 <maerwald> or lens
01:10:10 <maerwald> or ...
01:10:22 <koz_> tdammers: fsvo?
01:10:22 <Lycurgus> an life/the real world
01:10:23 <maerwald> with expressivity comes complexity
01:10:26 <Martin333[m]> koz_ (IRC): It's like a drug: it's too good so you die, and that's why I use Java. :/
01:10:31 <tdammers> koz_: for some value of
01:10:33 <maerwald> even if it's just intellectual complexity
01:10:37 <bahamas> first, when pattern matching, I always assumed that what you put after the value constructor (in this case Left) is going to be a variable. in what situations can you use can you match the expected value of the variable? I'm taking about `Left InvalidEmail` in the `printResult'` function
01:11:16 <Martin333[m]> Lycurgus (IRC): Nah, math is everything, because it isn't restricted by uninteresting rules.
01:11:19 <koz_> Martin333[m]: You have my sympathies.
01:11:19 <tdammers> maerwald: most of that complexity was already there, you just chose to take a gamble and ignore it
01:11:30 <maerwald> huh?
01:11:32 <tdammers> def foo(a, b): return a + b
01:11:35 <tdammers> easy, no?
01:11:49 <maerwald> I have no idea how that relates to my examples 
01:11:59 <tdammers> foo :: Num a => a -> a -> a; foo x y = x + y -- more complex
01:12:10 <Martin333[m]> koz_ (IRC): Thank you, same to you. Do you think that maybe Typed Racket could be a good middle ground?
01:12:20 <tdammers> in the first case, you can just say "OK, so it adds two values"
01:12:25 <koz_> Martin333[m]: I have no experience with Racket, typed or otherwise, so I can't say.
01:12:30 <maerwald> tdammers: those are trivial examples with little meaning
01:12:38 <koz_> I'm OK with Haskell's assorted deficiencies, though, so it's not a worry for me.
01:12:44 <tdammers> whereas in the second case, the types say "those values have to be of the same type, and that type must have a Num instance"
01:12:45 <maerwald> I'm talking about more real use cases of type expressivity
01:13:04 <tdammers> I'm boiling it down to a tiny problem so that it can be discussed on IRC
01:13:11 <tdammers> the point is the same though
01:13:13 <Martin333[m]> koz_ (IRC): Oh, good to hear.
01:13:28 <maerwald> so there are diverging properties of strong type systems... one is giving you ways to reason, the other is increasing complexity by giving you complex expressivity
01:13:30 <bahamas> anyone?
01:13:30 <__monty__> bahamas: No, you can pattern match on values too.
01:13:46 <tdammers> the additional complexity of "oh, but they have to be numbers, and you can't just use any combination of numeric types, because what would happen then?", etc.; it's not actually "additional", it's already there
01:13:55 <tdammers> Python doesn't magically make those considerations go away
01:13:57 <maerwald> tdammers: it's not a tiny problem and you cannot express GHC extensions, type families, data kinds etc with those two lines 
01:13:59 <tdammers> it just allows you to ignore them
01:14:01 <Lycurgus> Martin333[m], it would be as valid to say math isn't anything, because it's abstracted from everything real
01:14:02 <bahamas> __monty__: any value? like Left "hello"?
01:14:20 <maerwald> so expressivity always comes with a price too
01:14:25 <__monty__> bahamas: Yes, as long as the type is correct of course.
01:14:28 <Lycurgus> not mention non mathematical abstractions
01:14:33 <Lycurgus> *not to
01:14:37 <maerwald> it's not just "more expressivity, easier to reason"
01:14:46 <Martin333[m]> Lycurgus (IRC): Yes, if you mean 'anything real', which is why you can make it to be what is best.
01:14:54 <tdammers> no, but it's not "more expressivity, more complexity" either
01:15:16 <tdammers> and if anything, my claim was that a more expressive language has more ways of making code easier to reason about
01:15:27 <maerwald> Well, not sure 
01:15:35 <Lycurgus> Martin333[m], because that which is unreal is better than that which is real
01:15:36 <maerwald> Thinking of Scala, which is quite expressive
01:15:38 <tdammers> foo x y = x + y -- is about as easy to reason about as the python equivalent
01:16:04 <maerwald> so I don't think you can pick one property of a language and deduct the language is easier to reason about
01:16:14 <Martin333[m]> Lycurgus (IRC): When perfection cannot be real, why stay in reality?
01:16:59 <__monty__> bahamas: Keep in mind monad transformers aren't exactly the easiest of topics. If you don't understand the language well enough yet you might not learn much from that article. Don't be discouraged by me though, there's still tons of valid reasons to read about them even if you won't completely understand.
01:17:08 <tdammers> but if you add an explicit type signature, e.g. foo :: Int -> Int -> Int -- then it becomes easier to reason about, because now you no longer have to worry about "what if it's a floating-point number? what if I pass in non-numbers? how does + behave for custom types? how will I know when I fucked up and passed the wrong args?"
01:17:48 <tdammers> so, no, you can't do that; but you *can* say that Haskell provides some features that can be used to make code easier to reason about that many other languages do not have
01:18:13 <tdammers> i.o.w., the expressivity gained by having a type system can help write code that is easier to reason about
01:18:15 <maerwald> hm, Java has strong types 
01:18:20 <bahamas> __monty__: ok. I think I understand pattern matching better now. you can match on a value or you can assign the value to a variable (like when you assign to `_`). that's why lower in the article, the author, instead of writing `Left foo`, he just writes `left` and returns it
01:18:23 <maerwald> so not sure I agree with "many other languages do not have"
01:18:35 <tdammers> you and I know that Java's type system is a joke
01:18:41 <tdammers> compared to Haskell's, that is
01:18:51 * Lycurgus well there it is.
01:18:52 <maerwald> It still makes it easier to reason about some parts
01:19:04 <maerwald> Haskell is not unique on "strong type system" :)
01:19:17 <__monty__> bahamas: Yes, a pattern can be a variable or a constructor with patterns for the fields, more or less.
01:19:19 <tdammers> no, but Haskell's type system strikes a more useful balance IMO
01:19:21 <maerwald> it's quite unique on laziness
01:19:41 <maerwald> tdammers: balance is very subjective
01:20:04 <bahamas> __monty__: I'm not discouraged. I think I have a decent grasp on Haskell but I have enough perseverence to keep going, even if I won't understand monad transformers just from this article
01:20:19 <Lycurgus> what is the deal with 8.4 vs 8.6?
01:20:33 <koz_> Lycurgus: QuantifiedConstraints is a big one.
01:20:33 <maerwald> Lycurgus: ghc?
01:20:39 <tdammers> maerwald: sure, but it's pretty obvious that Haskell's type system is both more expressive and less verbose than Java's
01:20:43 <maerwald> note that 8.6.1 is kinda broken
01:20:43 <Lycurgus> yeah I thought so
01:20:46 <koz_> Also the next stage of the MonadFail Proposal.
01:20:57 <Lycurgus> is it expected to wreak breakage?
01:21:00 <koz_> I _think_ those are the big two?
01:21:00 <__monty__> Lycurgus: 8.4.4 was released after 8.6.1 because there were bugs to fix. There's a new 8.6 release coming though.
01:21:11 * koz_ mostly wants the sweet delicious QuantifiedConstraints.
01:21:34 <dminuoso> DerivingVia is also juicy :)
01:21:38 <dminuoso> Simple but yet powerful
01:21:43 <__monty__> I'm also not sure you should care about the bug in 8.6.1 if you're just starting out.
01:21:45 <koz_> dminuoso: Oh yeah, forgot about that one.
01:21:55 <koz_> That is very tasty too, agreed.
01:22:00 <Lycurgus> i am not just starting out
01:22:21 <Lycurgus> that would have been about 12 ya for haskell
01:22:44 <Lycurgus> and 40 for computing
01:22:51 <matzy_> i'm off to bed, thanks again for the help and advice!
01:23:07 <__monty__> Lycurgus: https://ghc.haskell.org/trac/ghc/ticket/15696
01:23:21 <Lycurgus> __monty__, ty
01:23:33 <maerwald> tdammers: yeah and I'm not convinced the higher expressivity is a good thing
01:23:40 <maerwald> it's hard to say
01:24:15 <maerwald> it would need a haskell-like language that focuses on restricting expressivity and still being very strongly typed to see if there is a "better" alternative
01:24:40 <maerwald> those things are not purely logical
01:24:54 <maerwald> because programming has an artistic component, right?
01:25:23 <__monty__> maerwald: Doesn't elm qualify for that?
01:25:46 <__monty__> It's the go of the fp world.
01:25:47 <maerwald> No idea, never looked at it in-depth
01:25:55 <maerwald> It's not general purpose, so
01:27:34 <asheshambasta> Is Text -> ByteString conversion expensive?
01:27:53 <asheshambasta> (I don't see why it should be, but just asking to know if there's a caveat)
01:28:10 <cocreature> asheshambasta: depends on what you mean by expensive, itâ€™s a linear time operation
01:28:47 <asheshambasta> I guess I'm asking for the constant factor in that O(n)
01:28:51 * hackage docusign-client 0.0.1 - Client bindings for the DocuSign API  http://hackage.haskell.org/package/docusign-client-0.0.1 (maerwald)
01:29:08 <cocreature> should be fairly small
01:29:53 <asheshambasta> okay, cool, I'll try benchmarking this. 
01:30:15 <maerwald> tdammers: https://hackage.haskell.org/package/docusign-base-0.0.1/docs/DocuSign-Base.html look at that easy to reason about servant API xD
01:31:06 <[exa]> maerwald: I like the lisp-inspired part at the end
01:31:11 <maerwald> hehe
01:36:13 <bahamas> I noticed I made a mistake by calling getLine instead of Text.getLine. what do people do to avoid calling String functions?
01:36:37 <asheshambasta> bahamas: qualified imports?
01:38:26 <cocreature> there is also the option of using a custom prelude, e.g., protolude
01:38:46 <maerwald> How many custom preludes do we have?
01:39:02 <maerwald> Should write a DSL to combine arbitrary preludes
01:40:27 <cocreature> one prelude to rule them all
01:40:38 <barrucadu> Maybe we need a new alternative prelude which combines the best aspects of all the other alternative preludes!
01:41:12 <maerwald> I want import combinators
01:41:13 <cocreature> <insert xkcd on standards here>
01:43:25 <heaven> :t splitOn
01:43:27 <lambdabot> Eq a => [a] -> [a] -> [[a]]
01:44:04 <bahamas> asheshambasta: do you mean to import Text as qualified? I already did that, but what I want is to not have `getLine` available. although it's true that I get a compile error if I accidentally use it
01:51:53 <koz_> barrucadu: Something something that XKCD about 11 competing standards.
01:57:12 <__monty__> bahamas: You can import the prelude qualified as well.
01:57:37 <__monty__> bahamas: Or just explicitly and hide getLine.
01:58:35 <asheshambasta> bahamas: in that case, I'd also suggest using a custom prelude. 
02:02:12 <__monty__> I'm not a fan of the custom preludes tbh. Especially for someone learning the language. They take a lot of decisions for you.
02:15:05 <tdammers> alternative preludes are kind of alright for applications, but a bad idea for libraries
02:15:09 <tdammers> (my $0.02)
02:15:46 <tdammers> problem in an application is that every application needs its own special prelude, so I have found general-purpose alternative-prelude packages relatively useless
02:15:59 <cocreature> I mostly use them as a basis for my custom preludes
02:16:34 <maerwald> Yeah, I just shamelessly copy paste
02:16:40 <cocreature> so I have an application specific prelude module that reexports some fairly minimal custom prelude (mostly protolude for me) + anything specific to the application
02:28:02 <Ariakenom> Does anyone know a data with Fractional a => Bits a => a? I have in mind but haven't seen that combination I think.
02:28:26 <Ariakenom> Does anyone know a data with Fractional a => Bits a => a? I have in one mind but haven't seen that combination anywhere else.
02:28:43 <Ariakenom> wow, words are not my frined right now
02:28:47 <Ariakenom> -.-
02:36:04 <koz_> Ariakenom: Do you mean something which is both a Fractional _and_ a Bits instance?
02:36:11 <Ariakenom> yes
02:36:48 <koz_> I don't think there are any.
02:37:56 <Ariakenom> cool. I'm trying to make some from a paper I got from this channel http://www.cs.toronto.edu/~hehner/ratno.pdf
02:40:18 <Ariakenom> a finite bit sequence is natural numbers. in two's complement the sign bit is an extension bit, that says repeating 1s or 0s at the end. If you allow for repeating a pattern of more than 1 bit you get fractions!
02:42:03 <Ariakenom> actually a nice connection to the bit tricks for reversing ints linked earlier. it used masks 0x5555..., 0x3333...
02:43:01 <Ariakenom> > complement 0
02:43:03 <lambdabot>  -1
02:43:40 <mniip> sweet jesus Ariakenom that's not fractions
02:43:45 <mniip> you're eating p-Adic numbers
02:44:35 <heaven> > complement 1
02:44:37 <lambdabot>  -2
02:46:09 <jle`> > compliment 1
02:46:11 <lambdabot>  Hello 1, you are looking very nice today.
02:47:47 <ventonegro> heh
02:50:12 <Ariakenom> mniip: s/fractions/rationals/
02:50:19 <ion> > complaint 1
02:50:19 <mniip> still not rationals
02:50:21 <lambdabot>  1, may I speak to your manager?
02:50:25 <mniip> different metric/topology
02:51:03 <mniip> > comment 1
02:51:05 <lambdabot>  -- 1
02:51:47 <Putonlalla> > compassion 1
02:51:49 <lambdabot>  I am sorry for your small magnitude.
02:56:27 <ruffy_> What is an easy and good lib to plot things? thx :)
02:56:41 <heaven> since file descriptors are passed to children when the parent forks
02:57:05 <heaven> and dyre can seemingly be used to store binary state
02:57:26 <heaven> is it possible to write a server that can rebuild itself and keep clients connected?
02:59:15 <ion> > communist 1
02:59:17 <lambdabot>  Seize the means of production of 1
03:26:24 <ski> bahamas : fwiw, (talking about pattern-mathing), it's not assignment, but binding. Haskell variables (immutable) are *bound* to values (or to expressions that eventually may reduce / be evaluated to values). there is no assignment (in the sense of *changing* values) here
03:27:05 <mcbear> When and why would you derive your data from Typeable?
03:27:32 <mcbear> When and why would someone derive your data from Typeable
03:29:51 <lyxia> you don't need to, it's already done for all types
03:30:51 <mcbear> lyxia: I'm looking at the git history of xmonad source code. Apparently in 2007 people still need to do it
03:31:43 <lyxia> Long ago we needed to derive Typeable explicitly, not anymore.
03:31:47 <mcbear> lyxia: anyway, i'm reading a blog post by Chris Done on the subject. I think it could answer my question
03:32:44 <lyxia> Typeable gives you a form of dynamic typing
03:38:09 <ski> Martin333[m] : static typing commonly increases reasonability (predictive power), you better understand what the program may do (so that it's easier to keep it doing the right thing); while decreasing expressivity (cavalier power), you're not as free to make the program behave as you please
03:39:09 <clever> ski: related, i ran into a bug where i assumed `MonadIO m` was just `IO` because it was being called as `fromThing $ do ....` inside `IO`
03:39:33 <clever> turns out, `fromThing` changed the monad to something entirely different, and that was the cause of the problem
03:39:43 <__monty__> ski: But being able to reason about something better allows you to formulate more complex things that still make sense, hence increasing your expressivity.
03:39:56 * ski hopes they got the monochrom terms right
03:41:14 <ski> (there perhaps ought to be a catchy quote which expresses the terms clearly and concisely ?!)
03:41:47 <ski> clever : yah, that happens. know your types
03:42:06 <mcbear> are we still talking about my original question on Typeable?
03:42:17 <ski> __monty__ : yes, it's not quite as simple as i suggested
03:42:38 * ski was commenting on an earlier discussion/statement, not really on `Typeable'
03:43:52 <__monty__> ski: I know, just wanted to point out that the discussion wasn't really about the PLT definition of expressiveness.
03:46:32 <Martin333[m]> __monty__: I would maybe say it as: 'Increasing clarity by reducing expressitivity increases manageability, thereby increasing complexity handling ability so that the program can be more expressive.'
03:48:35 <__monty__> I don't think throwing more words at the problem makes it any clearer : ) The problem is having different interpretations of some words, so more words, more points to disagree on : )
04:02:26 <ski> __monty__ : the present, or the earlier, discussion ?
04:03:36 <__monty__> The earlier discussion.
04:05:27 <ski> ok
04:43:25 * hackage secp256k1-haskell 0.1.4 - Bindings for secp256k1 library from Bitcoin Core  http://hackage.haskell.org/package/secp256k1-haskell-0.1.4 (xenog)
05:07:16 <NewUser2> Hey guys im trying to debug a haskell function I tried to import Debug.Trace  with this : 
05:07:18 <NewUser2> module Arithmetik where    import Debug.Trace
05:07:39 <NewUser2> but i get this error module Arithmetik where    import Debug.Trace
05:08:09 <NewUser2> Arithmetik.hs:4:1: parse error on input â€˜pow1â€™
05:08:23 <NewUser2>  pow1 is the first function after the import statement
05:09:12 <hpc> can you paste your code on a pastebin site?
05:12:10 <NewUser2> https://pastebin.com/RefDbueJ
05:13:09 <hpc> don't indent the import statement
05:14:04 <ski> alternatively indent *all* the items inside your module
05:14:15 <ski> (i often do that)
05:18:20 <NewUser2> https://pastebin.com/3BBGnnKk
05:18:24 <NewUser2> still not working
05:20:08 <ski> `import' must be indented to the *same* level as all your definitions inside the module
05:20:13 <ski> NewUser2 ^
05:20:23 <Ferdirand> why do you want to use Debug.Trace on such code ?
05:20:46 <Putonlalla> The compiler currently assumes you're continuing the `import` line with `pow1 b e`, NewUser2.
05:20:52 <ski> (and the other ones must be aligned to the same column, among themselves)
05:29:50 <mcbear> what is the difference between: const $ return () and return ()
05:30:37 <ski> one has type `a -> m ()', the other has type `m ()', for some types `a' and `m', with `m' being an instance of `Monad'
05:30:55 <ski> the former will ignore the argument that it receives
05:31:23 <ski> both will express a trivial action that doesn't express any effects, and that doesn't return an interesting value (`()')
05:31:40 <ski> mcbear : hard to say much more, without more context
05:32:20 <mcbear> catch (executeFile prog True (args ++ args') Nothing) (const $ return ())
05:32:36 <ski> @type catch
05:32:37 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
05:32:52 <ski> `catch' passes the caught exception to its second argument (the exception handler callback)
05:33:14 <ski> in this case, the `const' expressed not caring about the exception value passed to the handler, throwing it away
05:33:25 <mcbear> great thanks
05:33:36 <ski> one could also say `\_ -> return ()'
05:34:19 <ski> btw, it may be nice to fix in source *which* exception type is to be used (since that determines which exceptions can be caught here)
05:35:04 <mcbear> how in this case?
05:35:09 <rotaerk> to me, catch feels like it's named to be used infix style
05:35:50 <ski> well, you could use `const (return ()) :: SomeParticularExceptionType -> IO ()'
05:36:08 <ski> or `\(_ :: SomeParticularExceptionType) -> return ()'
05:36:23 <mcbear> nice
05:36:25 <rotaerk> executeFile prog True (args ++ args') Nothing `catch` \(_ :: SomeParticularExceptionType) -> return ()
05:38:26 <ski> pbodev1,mcc : sorry ?
05:50:40 <NewUser2> ok i got it now :D (after 10 minutes) many THANKS to ski was a bracket error i had after youre advice ^^
05:53:17 <ski> NewUser2 : ooc, where was the bracket error ?
05:53:53 <NewUser2> last line           | e `mod` 2 == 1 =  pow3Acc (b*b) ((e-1)) ((acc * b)
05:54:50 <NewUser2> i think i use brackets too often because i want to structure it but many bracket = many errors
05:55:57 <ski> what was the exact error, you say ?
05:56:42 <NewUser2> ((e-1)) ((acc * b) i forgot the last bracket
05:56:47 <ski> (btw, on closer look, i think i see three problems with your last paste. i could go into them, if you like. but perhaps you've fixed (or changed) some of them, so perhaps it'd be better if you pasted your current code first)
05:56:59 <ski> ah, right
05:58:03 <NewUser2> yeah trying to use this function with acc but got the false results and thought it would be nice to debugg code for later if the code gets more complicated
05:59:13 <ski> NewUser2 : so, would you like to repaste ?
06:00:21 <NewUser2> https://pastebin.com/Bfh92yzb
06:01:54 <ski> `pow1' doesn't check for negative exponent, while the other ones do
06:01:58 <ski> perhaps you should be consistent
06:02:32 <NewUser2> yeah youre right 
06:02:36 <ski> in the `((e `mod` 2) == 1)' case of `pow2', you call with exponent :  (e-1) `div` 2
06:02:59 <ski> however, if `e' is odd (as is the case here), that's the same as (the simpler) :  e `div` 2
06:03:04 <ski> btw, there's also
06:03:06 <ski> @type even
06:03:07 <lambdabot> Integral a => a -> Bool
06:03:09 <ski> @type odd
06:03:10 <lambdabot> Integral a => a -> Bool
06:03:17 <ski> which *could* be used instead of `mod'
06:05:04 <ski> btw, all the brackets that you have in guards, are redundant
06:06:01 <ski> (also the brackets around the recursive call of `pow1')
06:06:35 <ski> now, there's further problems, re `pow3'
06:07:13 <NewUser2> i use even e for example right
06:07:14 <ski> i *could* point you directly to them ..
06:07:22 <NewUser2> and even e is true or false
06:07:53 <ski> .. but it may be better if i point to how you can find the problems, as a more general strategy
06:08:37 <ski> (you have problems with edge condition, and with how you update)
06:08:58 <ski> so
06:09:31 <ski> perhaps we should attempt some simple symbolic execution (by hand), trying to get a better grip of what happens
06:10:08 <ski> let's start with simple examples. in fact the most simple one
06:10:26 <ski>     pow3 b 0
06:10:38 <ski>   =  b
06:10:48 <ski> is this correct ?
06:10:58 <NewUser2> yeah
06:11:25 <ski> multiplying zero copies of `b' with itself ought to yield `b' as answer ?
06:11:47 <ski> ok, let's go on to the next case, then
06:11:54 <kw_> Is there a special term for haskell `Category`class-like categories, which have a parametric (global) identity arrow?
06:12:06 <ski>      pow3 b 1
06:12:25 <ski>   =  pow3Acc b 1 b
06:12:38 <NewUser2> oh pow 3 b 0 = 0 not b :D
06:12:45 <NewUser2> = 1
06:12:52 <NewUser2> ... :D
06:12:56 <ski>   =  pow3Acc (b*b) (1-1) (b*b)
06:13:04 <ski>   =  pow3Acc (b*b) 0 (b*b)
06:13:10 <ski>   =  b*b
06:13:17 <ski> NewUser2 : yeah, right :)
06:13:29 <ski> now, how about this reduction/evaluation trace ?
06:13:39 <ski> does it yield the correct answer ?
06:13:54 <ski> (perhaps i should first ask : do you understand every step i made there ?)
06:14:31 <ski> (iow, understand how those steps follows from the code you're written)
06:15:16 <NewUser2> b*acc not b*b ?
06:15:30 <NewUser2> oh acc is b ok
06:15:51 <ski> in this case `acc' was `b', since we called `pow3Acc b 1 b' from `pow3 b 1'
06:15:56 <ski> *nod*
06:17:45 <ski> NewUser2 : what's your verdict about the reduction sequence/chain above, then ?
06:17:46 <NewUser2> ok  i try to modify pow2 with a acc variable but i need to get a end recursive form but i got b* pow2 b e-1 'div' 2
06:18:27 <NewUser2> b^1 = b yeah my code is false
06:18:35 <ski> i thought `pow3' was the version where you tried to add an accumulator to `pow2'
06:18:40 <NewUser2> because i got b^2
06:18:50 <NewUser2> yeah
06:18:51 <ski> NewUser2 : right, but what's the cause of the wrong answer ?
06:19:27 <ski> it must be in (at least) one of the four places used in the four steps above
06:19:37 <NewUser2> i did it wrong :D thats why i tried to trace the values too see what happend wrong
06:19:59 <ski> at least for simpler stuff, i think it's often nicer to trace stuff by hand, as above
06:20:58 <NewUser2> yeah but tried to learn it because it not gets easier and i think a key to write code without bugs is to know how to find and eliminate them for later
06:20:59 <ski> (i omitted showing the evaluation of the guards, which in these cases aren't that complicated)
06:21:09 <codedmart> Why do I get a lexical error when I try to do this with replace from Data.List.Utils `replace " " "\ " str`
06:21:40 <ski> one key to write less bugs is probably to get better to think about such reductions, in your head
06:21:57 <ski> this is the "stare hard at code" version of debuggin :)
06:22:06 <mniip> % "\ "
06:22:06 <yahb> mniip: ; <interactive>:76:4: error: lexical error in string/character literal at character '"'
06:22:17 <ski> (or on paper, or in scribblings in a text editor, if it doesn't fit in your head)
06:22:22 <mniip> codedmart, presumably you want "\\ "
06:22:28 <dmwit> codedmart: Because `\ ` starts a string gap that never ends.
06:22:55 <dmwit> codedmart: String gaps are a backslash, some whitespace, and another backslash. The backslashes and everything between them are removed from the final meaning of the string literal.
06:23:03 <dmwit> > "gap\      \deleted"
06:23:05 <lambdabot>  "gapdeleted"
06:23:08 <codedmart> mniip: No cause then that literally replaces " " with "\\ "
06:23:26 <dmwit> Under normal circumstances, whitespace does not need to be escaped at all.
06:23:30 <dmwit> > "gap not deleted"
06:23:32 <lambdabot>  "gap not deleted"
06:23:54 <ski> codedmart : how many characters do you want to replace each space with ?
06:24:13 <dmwit> Oh, I see. You are just confused about how it's displaying the (correct) result of `replace " " "\\ "`.
06:24:26 * ski suspects so, yea
06:24:47 <dmwit> codedmart: Okay, I ask you two prediction questions. If I write `"\\ "` into lambdabot, what will it say? If I write `length "\\ "` into lambdabot, what will it say?
06:25:15 <dmwit> > "foo" -- to help you with your predictions, I show a similar example without the escaping twist
06:25:17 <lambdabot>  "foo"
06:25:18 <dmwit> > length "foo"
06:25:20 <lambdabot>  3
06:25:49 <codedmart> dmwit: Well now that you say that I am thinking `"\\ "` and `2`.
06:25:53 <ski> NewUser2 : any suggestion for where the problem might lie ?
06:25:57 <dmwit> codedmart: Perfect!
06:26:05 * ski smiles
06:26:23 <dmwit> codedmart: Do you now understand the disconnect between what you were expecting and what you saw with `replace`?
06:26:38 <codedmart> So it is actually replacing what I want with `"\\ "` just the show is what is confusing me.
06:26:44 <ski> right
06:26:44 <dmwit> right!
06:26:55 <ski> codedmart : now try using `putStrLn', on the result string
06:27:15 <ski> (also compare with using `print' on it)
06:27:35 <codedmart> OK problem then. Which reveals that I probably should be doing this differently.
06:28:01 <codedmart> I am building a command as a `String` to pass to `runCommand`.
06:28:16 <dmwit> Oh, yes, don't do that unless you're on Windows.
06:28:22 <dmwit> Maybe not even then.
06:28:27 <codedmart> This is just suppose to be a quick hack script.
06:28:39 <dmwit> Not even for a quick hack script.
06:28:56 <codedmart> What is the better approach? Because I am just trying to escape spaces in folder paths.
06:29:30 <dmwit> runProcess or runInteractiveProcess accepts a list of strings to use as arguments.
06:29:58 <dmwit> rawSystem is simpler but less flexible.
06:31:12 <codedmart> OK thanks!
06:31:23 <dycan> Hi, newbie here. How to get newest package in nixos? The newest persistent is 2.9.0 but in channel nixos-unstable it's 2.8.2.
06:32:57 <cocreature> dycan: https://github.com/Gabriel439/haskell-nix/tree/master/project1#changing-versions
06:33:05 <cocreature> you can also simplify this using callHackage
06:33:39 <cocreature> e.g. persistent = super.callHackage "persistent" "2.9.0" {};
06:37:22 <dycan> coreature: Thank you!  I'll see if I can understand nix expression this time! :p
06:37:48 <Synthetica> If you can't figure it out, feel free to hop on by in #nixos :P
06:37:57 <Synthetica> (Had to double-check I wasn't there)
06:39:01 <dycan> Synthetica: Thanks!
06:49:57 * ski looks at NewUser2
07:05:12 <codedmart> dmwit: I can't seem to figure how to get this command to work on folders with spaces in them.
07:05:50 <codedmart> I tried rawSystem, tried my cheap replace hack, tried shell-escape.
07:08:27 <codedmart> I want to run `notmuch tag -inbox +foo folder:Personal/Sent\ Mail ;` using runCommand or rawSystem or something. I have `Personal/Sent Mail` which doesn't work.
07:10:17 <dmwit> rawSystem "notmuch" ["-inbox", "+foo", "folder:Personal/Sent Mail"] -- ?
07:10:58 <dmwit> Oops, lost the `tag` part. Is the `;` just a shell directive that you've inadvertently left in, or is `notmuch` expecting to see a semicolon as an argument?
07:12:30 <codedmart> It is expecting to see it as an argument on the end from what I can tell.
07:12:42 <codedmart> Still new to notmuch
07:15:52 <dmwit> Then `rawSystem "notmuch" ["tag", "-inbox", "+foo", "folder:Personal/Sent Mail", ";"]`.
07:16:48 <dmwit> The man pages for `notmuch-tag` don't mention expecting a semicolon. Why do you believe it is expecting one?
07:18:14 <dmwit> codedmart: This part of the man page looks relevant: The  <query>  should be quoted using Xapian boolean term quoting rules: if a term contains whitespace or a close paren or starts with a  double quote,  it must be enclosed in double quotes (not including any prefix) and double quotes inside the term must be doubled (see below for  examâ€ ples).
07:18:59 <dmwit> codedmart: So you'll likely need something like `rawSystem "notMuch" [..., "\"folder:Personal/Sent Mail\""]`
07:19:23 <codedmart> Oh interesting
07:19:37 <dmwit> always RTFM
07:19:54 <codedmart> I know I suck at that :|.
07:20:33 <codedmart> dmwit: Thanks for your help.
07:21:17 <Ariakenom> exponential escaping scheme? nice
07:25:36 <dmwit> Ariakenom: Yeah, I had that same fun thought when I pondered how to control deeply-nested tmux sessions.
07:25:54 <dmwit> 2^n ctrl-b's needed to make it through to the n'th nested tmux. Don't lose count.
07:39:11 <Putonlalla> That's even better with a timeout.
07:46:47 <int-e> dmwit: so configure it such that the escape sequence is ^b b or something like that. Then it's n+1 key presses instead of 2^n.
07:47:13 <dmwit> int-e: Are you sure?
07:47:24 <dmwit> (Think about it!)
07:47:46 <int-e> dmwit: Hmm, wrong terminology. I mean the key sequence for sending a ^b.
07:47:51 <dmwit> The first layer eats half your keypresses exactly. The second layer eats half your keypresses, too.
07:47:59 * hackage comfort-array 0.1.2 - Arrays where the index type is a function of the shape type  http://hackage.haskell.org/package/comfort-array-0.1.2 (HenningThielemann)
07:48:27 <int-e> dmwit: they're not the same key anymore; the b goes through unimpeded.
07:48:49 <dmwit> I don't think so.
07:49:20 <dmwit> It goes through *to the next tmux*. Not all the way to the deepest-nested tmux.
07:49:51 <dmwit> (Or else how would you say at which tmux nesting level to stop and actually do the command you wanted to do?)
07:50:38 <int-e> dmwit: if ^b b  sends a ^b to the inner program, and that is a tmux, then ^b b b will send a ^b to the program contained inside the second tmux
07:51:10 <int-e> The 2^n is really a result of using exactly the same key twice.
07:51:31 <dmwit> Ah, you're totally right! Nice.
07:52:48 <ski> (the same in Screen)
07:53:08 <ski> (this is probably an argument for not using `\\' to escape `\')
07:56:27 <int-e> ski: yes it is. &amp;amp;amp; scales much better, for example :)
07:56:49 <dmwit> (The Principle of Least Surprise is the argument for yes using \\ to escape \. But if you need it to deeply nest strings, \92 is available.)
07:58:37 <int-e> > read "\"\92\&92\"" :: String
07:58:39 <lambdabot>  "\\"
07:59:17 <int-e> (eww)
07:59:38 <ski> int-e : i've noticed this phenomenon before (since i'm using GNU Screen), but i hadn't seen anyone else talk about it before, that i can remember
08:03:22 <maerwald> how do you install binaries of a local package with cabal new-*?
08:03:27 <Putonlalla> If all ^B B does is send ^B into the inner terminal, surely you need 2 n inputs instead of 1 + n inputs, int-e.
08:03:52 <dmwit> > read (read (read "\"\92\"\92\&92\92\"hi\92\&92\92\"\92\"\"")) :: String
08:03:55 <lambdabot>  "hi"
08:04:31 <dmwit> Putonlalla: but the next b sends a ^B into the inner inner terminal
08:05:11 <dmwit> (Feels weird to be correcting you on something I was so recently wrong about. Maybe I should leeave the corrections to my guru, int-e.)
08:05:13 <Putonlalla> Oh, I see now. The regular B just goes through.
08:05:41 <maerwald> cabal new-install does literally *nothing* for local packages
08:06:42 <int-e> ski: though I'm not actually using that idea in practice; my .screenrc has  escape ^B^B
08:07:56 <ski> what's your `other', then ?
08:08:49 <int-e> There is none. I don't nest screens.
08:13:19 <int-e> ski: Oh. Sorry, I see what your question was... I just don't use `other'.
08:13:55 <int-e> but perhaps we've wandered far enough off topic anyway, for now :)
08:14:09 <ski> heh, ok
08:14:27 * ski does nest them
08:43:09 <inkbottle> Is it generally speaking a bad idea to try to use `many :: Parser a -> Parser [a]` in a *recursive* parser definition? Or are there simple ways to "adjust" the types.
08:46:02 <davean> inkbottle: I'm confused as to what you think is special about it being recursive
08:50:11 <kosmikus> inkbottle: the more interesting question is usually whether the argument parser accepts the empty string, because then many can lead to ambiguities. some parser libraries can handle this better than others.
08:50:25 <inkbottle> davean: https://paste.debian.net/1048980/
08:50:39 <mcbear> Do people still use Happy the parser generator? in what kind of applications? 
08:51:20 <inkbottle> kosmikus: I've posted one very bad example, 2 lines above
08:51:36 <inkbottle> I'm sure what i'm trying to do is bad
08:51:52 <davean> mcbear: GHC
08:51:55 <inkbottle> but I don't exactly understand why and how to fix it
08:52:55 <inkbottle> this in contrast works: `runParser (fix $ \paren -> do {symbol "("; s <- paren <|> symbol "3"; symbol ")"; s' <- paren <|> return []; return (s ++ s')}) "(3)((3)((3)))"`
08:54:59 <ski> inkbottle : paste looks like type error ?
08:55:36 <Guest44285> Hello, Haskellers
08:55:37 <inkbottle> ski: yes, exactly; trying to adjust them, even though, I sort of know it's bad
08:56:12 <inkbottle> the version w/o many works fine
08:56:16 <ski> inkbottle : replace `many paren' by `fmap concat (many paren)', perhaps ?
08:56:33 <ski> inkbottle : or introduce a proper Parsetree or Abstract syntax tree ?
08:56:35 <inkbottle> ski: yes, that's it :0
08:56:39 <inkbottle> :)
08:56:49 <kosmikus> what are you even trying to return?
08:57:05 <Janta> When I have long-lived data â€“ is there a way to tell the GC to not look at it?  Compact regions?  Weak pointers?
08:57:18 <ski> kosmikus : from the other example above, just a list of tokens, for now
08:57:19 <inkbottle> kosmikus: like the `runParser (fix $ \paren -> do {symbol "("; s <- paren <|> symbol "3"; symbol ")"; s' <- paren <|> return []; return (s ++ s')}) "(3)((3)((3)))"`
08:58:11 <inkbottle> But ski answer is the right one: it's contrived!
08:58:21 <inkbottle> Then "bad"
08:58:49 <inkbottle> I was wondering: I now know
08:58:55 <ski> inkbottle : btw, note that your paste (fixed) will only parse a single bracketed thing (possibly containing multiple things), while your other example will parse multiple bracketed things
08:59:16 <kosmikus> yes, I'm still wondering what the grammar is you actually want to parse
08:59:35 <ski> inkbottle : not so much "bad" as "not that useful" (the "returning list of tokens" thing), i think
08:59:58 * ski thinks it looks like simple SExprs
09:00:08 <Athas> Man, profiterole is incredibly good.
09:00:14 <kosmikus> the version with fix doesn't use many, the version without does
09:00:30 <kosmikus> yet you make it sound like it's somehow the use of recursion and many that make it difficult
09:00:44 <Athas> Neil Mitchell is my favourite Haskell toolsmith.
09:01:42 <inkbottle> ski, kosmikus: was just toying, to improve my understanding or parsers ans monads, not having anything very useful in mind; the answer provided exactly lifted my doubts 
09:03:15 <kosmikus> inkbottle: ok :)
09:03:49 <hhefesto> Hi, Haskell community!
09:05:44 <hhefesto> I am trying to do a join of three tables using Esqueleto, but I can't seem to make it compile, and I don't understand the error. Here are two different ways I tried to solve it and their corresponding errors: https://gist.github.com/hhefesto/2b8b7cee5837fa217e8eea5f8c89a72d
09:06:51 <hhefesto> If someone could point me to "the way", I would really apreciate
09:10:20 <yayforj> hello from china
09:10:32 <hhefesto> hello from MÃ©xico :)
09:10:37 <yayforj> didn't expect it work really
09:11:48 <hc> why should't it work? :)
09:12:06 <yayforj> great firewall and all that
09:12:17 <hc> oh ok
09:12:47 <yayforj> i had difficulties contacting my family last couple of days coz of that
09:13:13 <yayforj> but freenode works like a charm
09:14:22 <yayforj> random ish question
09:14:46 <yayforj> should i use QuickCheck or something "newer"?
09:16:38 <mnoonan> hedgehog is nicer imo, you don't have to make so many orphans or weird newtypes
09:29:06 <asheshambasta> `return . Right . foo $ something` vs `return $ Right $ foo something`? 
09:29:20 <ski> the former over the latter
09:29:36 <asheshambasta> okay, that was my preference as well. 
09:29:39 <ski> personally, i prefer `(return . Right . foo) something', though
09:29:55 <asheshambasta> ski: any reasons why? 
09:30:30 <ski> with a composition chain of functions, you can more easily break out any subcomposition chain into its own definition, or vice versa, inline/unfold such a definition
09:31:01 <ski> both `return . Right' and `Right . foo' are valid subexpressions (conceptually) of `return . Right . foo'
09:31:07 <ski> not so for the `$' use
09:31:36 <ski> otoh, i wouldn't shy away from using `return (Right (foo something))', either. multiple brackets is nothing to be afraid of, in and of themselves
09:31:54 <dminuoso> Use the representation that is most expressive for your problem.
09:32:39 <asheshambasta> Okay, but I see your point. 
09:32:40 <delYsid> It is funny how I grew into "functional" programming via Lisp, loving to navigate via parens through complex code blocks with Emacs C-M-f and alike.  But when I write Haskell, I tend to kill every paren in sight and just love $ :-)
09:32:48 <dminuoso> In my personal experience ($) frequently is in the way when refactoring code.
09:33:04 <ski> i tend to want to kill every `$' is sight ;)
09:33:12 <dminuoso> It leads to additional work very frequently you want to touch code. :)
09:33:19 <mnoonan> delYsid: lispy parens without paredit would be no way to live life :)
09:33:21 <dminuoso> ski: Yup!
09:33:41 <ski> now that we can pass `do' and `\...' as arguments, without brackets, that'll kill off most of the lingering `$'s, for me
09:33:52 <dminuoso> asheshambasta: another thing is, (.) tends to promote thinking about program composition
09:34:00 <dminuoso> asheshambasta: whereas () and $ tend to promote thinking about data shuffling.
09:34:08 <dminuoso> because quite literally
09:34:10 <asheshambasta> delYsid: To me, indented languages like haskell make more sense as a human. Even if we have languages where braces are used to denote blocks, we end up indenting them anyway (to make the code readable to us), so why not just use indentations as blocks instead of using 2 things for the same thing? 
09:34:11 <dminuoso> :t (.)
09:34:12 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:34:21 <dminuoso> is the tool to *connect* to matching program fragments with.
09:34:39 <asheshambasta> dminuoso: true 
09:35:15 <dminuoso> it's quite literally the composition tool in haskell :-)
09:35:33 <asheshambasta> dminuoso: (.) is like solving a mental jigsaw of "logic" pipes to me.
09:35:37 <dminuoso> :t ($)
09:35:38 <lambdabot> (a -> b) -> a -> b
09:36:13 <ski> `$' is just noise, to me, with little redeeming features
09:36:54 <delYsid> asheshambasta: I have nothing against indented languages.  They are a bit icky to use in a REPL though.
09:37:01 <dminuoso> In smaller situations its frequently not necessary, and in larger blocks it makes it really hard to spot how things will associate.
09:37:38 <asheshambasta> I tend to agree with ski that using () around the function composition is cleaner. 
09:38:38 <ski> (or eta reduce / extensionality, if you can)
09:38:39 <asheshambasta> delYsid: true, although for pretty much anything that has to do with more than one line, I quickly write it in a module and load it in the REPL. 
09:38:54 <asheshambasta> I've reached a sweet-spot of being productive with intero and emacs that way.
09:39:22 <asheshambasta> (moving to Linux and hence Xmonad has also done wonders to my productivity)
09:39:38 <Solonarv_> I mean, we can already use braces+semis instead of layout
09:39:54 <Solonarv_> and there's also :{ ... :}
09:40:24 <delYsid> asheshambasta: I loved how you could decide in the middle of growing an expression to kill it into a buffer with M-x ielm and friends.  But sure, if you are into serious coding, you usually do the work in a file.
09:41:51 <delYsid> I still miss C-x C-e, thats the one thing that really hurts loosing.
09:42:51 <asheshambasta> delYsid: intero has `intero-repl-eval-region`, but yeah, that means you need to have a selection around the region first.
09:43:04 <asheshambasta> its not as convenient/elegant as C-x C-e
09:43:21 <delYsid> my point, yes.
09:44:00 <asheshambasta> but hey, we've got types.
09:44:11 <delYsid> yeah
09:44:44 <delYsid> Felt strange when I read typed-racket, I think I wouldn't want to merge both worlds.
09:46:53 <markus1189> ls
09:46:57 <markus1189> whoopsie
09:48:03 <michaelsdunn1> Is anyone having issues with intero on macos? Syntax highlighting and error detection flashes in and out with a keystroke. I can't seem to figure out what is going on.
09:51:06 <delYsid> asheshambasta: Besides, M-x ielm indents interactively, which does actually make it pretty easy to write somewhat bigger expressions in a REPL.  Not that the Lisp syntax would care, but auto-indentation in a REPL makes it a lot easier for you.
09:51:58 <dminuoso> Oh yes. Explicitly splicing lens TH helpers and using makeLensesFor over makeLenses feels *so* satisfying.
09:52:02 <asheshambasta> michaelsdunn1: that rings a bell, yes. You might want to check the logs in the intero messages buffer. 
09:52:05 <delYsid> Hmm, come to think of it, did Yi ever take of as a programmable Haskell IDE sort of thing?
09:52:07 <dminuoso> No more magic.
09:52:59 <asheshambasta> dminuoso: I'm still new to Haskell and I somehow instantly took a disliking toward TH. 
09:53:23 <asheshambasta> Its just too much magic, albeit convenient. 
09:53:49 <dminuoso> asheshambasta: Well if you splice explicit it makes it *much* more obvious where it happens, and something like `makeLensesFor` is really just for convenience.
09:54:02 <dminuoso> I could construct them by hand - but it's too mechanical and not really beneficial.
09:54:35 <asheshambasta> Hm
09:54:52 <glguy> It's also error prone to write them by hand and get the strictness right along with inlining
09:55:20 <glguy> and now that you've written them by hand your readers have to carefully read what you wrote to see if it's the same as the default TH generated ones everyone else uses
09:56:20 <ski> yes
09:57:38 <dminuoso> The thing I dont like is just `makeLenses` because it forces you to tailor your identifiers according to lenses TH magic. 
09:59:04 <glguy> You can pick your own arbitrary naming rule
09:59:26 <glguy> using a consistent rule saves your reader from having to manually infer your rule at each makeLensesFor use
10:00:06 <dminuoso> glguy: Oh you mean if you did some `yourMakeLenses = makeLensesWith yourRules`>?
10:00:08 <glguy> If you build a single ruleset to use with makeLensesWith for your codebase you can save the reader having to learn one naming convention
10:00:30 <dminuoso> Oh that's not too bad either I guess :)
10:00:32 <adjofun> Greetings. I have a theoretical question. THere is a Turing machine, and lambda-calculus. They are isomorphic. Imperative programming is about state, and at its heart is Turing machine. Functional programming is about transformations, and at its heart is lambda calculus. For concurrent environments there are a lot of math models (pi-calculus), which make use of *channels* for commumication. Imperative world uses *mutexes*. Do mutexes 
10:00:34 <adjofun> correspond to channels? Can I somehow use pi-calculus when I model low-level kernel driver code? 
10:03:03 <Jetien> Can I somehow let the ghc derive somehting so that I can treat "Compiler" like a reader monad? : newtype Compiler a = Compiler { runCompiler :: ReaderT Env IO a } deriving (Functor, Applicative, Monad, MonadIO, MonadThrow, MonadCatch)
10:04:42 <glguy> even better would be to write: getEnv :: Compiler Env; getEnv = Compiler ask
10:05:45 <glguy> The various classes like MonadReader are best used to help you implement domain specific operations for your Compiler type
10:05:58 <Janta> When I have long-lived data â€“ is there a way to tell the GC to not look at it?  Compact regions?  Weak pointers?
10:06:16 <glguy> compact regions
10:06:52 <Janta> Good, thanks.
10:06:54 <glguy> http://hackage.haskell.org/package/compact
10:07:21 <glguy> Or in some cases just manually using malloc and free from the Foreign modules
10:08:32 <Jetien> glguy: thanks. do you know a online where i could get advice like you just gave me? I find it hard to find "idiomatic" ways to program in Haskell. Common practices etc.
10:08:40 <Jetien> s/online/online resource
10:08:44 <dmwit> Jetien: The answer to your direct question is "yes, just add `MonadReader Env` to your list of derived classes".
10:17:09 <alanz> does anyone know how to set a "cabal configure" time flag for a stack subproject? I need to set `--enable-library-for-ghci`. https://github.com/fbsamples/ghc-hotswap/blob/master/ghc-hotswap-so/ghc-hotswap-so.cabal
10:19:06 <alanz> I am looking for the equivalent of cabal.project configure-options
10:22:32 <Janta> I read that with dependend types one can get a compile-time guarantee that only authenticated users get access to certain resources at runtime of my server app.
10:22:35 <Janta> I wonder though what is so special about this â€“ couldnâ€™t I have a smart constructor that checks  the authentication status at runtime and then constructs a phantom type which I use throughout the web app. In that case I also seem to have a guarantee that my resources can only be reached when the user is authenticated.
10:24:36 <dmwit> Janta: The difference is in trusted code base. In the smart constructor solution, the module containing the smart constructor is the TCB, and that TCB is reviewed/checked only by you and your customers. In the DT solution, the TCB is pushed into the compiler, which is checked and used by many more people.
10:25:06 <dmwit> (Well, and in the spec that the compiler is checking, which is used only by you. But that spec exists in pretty much the same form in your smart constructor approach.)
10:26:19 <Janta> I am not sure I understand it correctly. In both cases, DT and Smart Constructor there is a check that takes place. With SCs at runtime. And from that point on itâ€™s safe/proven that access has to be authenticated.
10:26:45 <dmwit> In the SC solution, there is another check that needs to be done: you the programmer needs to check that the runtime check you wrote is correct.
10:27:03 <dmwit> And that all uses of the non-smart constructor in that module use that check.
10:27:03 <Janta> I still fail to see what the improvement is. Also in the DT case certain runtime checks need to be made â€“ because we have to handle that a user is not authenticated there too.
10:27:24 <dmwit> And all other invariants you have about your type must also be maintained (and checked by the programmer) throughout the module that has access to the non-smart constructor.
10:27:56 <Janta> dmwit: yes, I would have to ensure that the non-smart constructor is not usable and that all devs in the projects will only use the smart one.
10:28:35 <dmwit> No, you've misunderstood. I am saying that in the module with the smart constructor, you likely have other API than the smart constructor. And all of that other API must be checked, because it has access to the non-smart constructors.
10:28:57 <dmwit> Outside the module boundary, things look the same in SC and DT land, roughly, I agree.
10:29:01 <dmwit> Inside the module boundary no.
10:29:21 <Janta> I agree that inside my module, yes, other functions (and other devs in the team) have access to the non-smart constructors.
10:31:54 <Janta> So, with DT the scope of safety would also encompass the module itself. I wouldnâ€™t have to ensure that it is just a small module  and devs wouldnâ€™t require the discipline to not edit it in the future in a bad way.
10:32:00 <Janta> dmwit: does that make sense?
10:32:05 <dmwit> yep
10:34:04 <Janta> dmwit: oki, understood
10:35:22 <Janta> dmwit: But good that we wonâ€™t have to use DT for everything. The existing Haskell type system seems to be extremly powerful already and for many unimportant aspects of our applications DTs will probably just a time sink without much return.
10:37:46 <dmwit> I think there are many who would agree with you. =)
11:11:28 <o1lo01ol1o> I'm trying to pull a specific certificate (x.509) out of the system store using `hs-certificate`.  Does anyone know how I can create a DistinguishedName from a string?  There's no documentation on how to use the libraries and I want to avoid learning the RFC spec for this if I can . . . 
11:19:06 <exarkun1> o1lo01ol1o: hs-certificate seems to be deprecated in favor of x509
11:20:05 <o1lo01ol1o> exarkun1: sorry, I'm using x509, x509-store, etc.  the github repository is called `hs-certificate`
11:20:23 <exarkun1> o1lo01ol1o: I don't see a constructor for Data.X509.DistinguishedName other than `DistinguishedName { getDistinguishedElements :: [(OID, ASN1CharacterString)] }`
11:21:34 <exarkun1> o1lo01ol1o: If that's the way to go, here's some OIDs: https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772812(v=ws.10)
11:25:27 <o1lo01ol1o> exarkun1: That's what I was beginning to have to recken with.  Thanks
11:29:05 <jbr69> hi, i have a question concerning pandoc filters - where can i paste?
11:29:59 <jbr69> ... hpaste.org doesn't work for me
11:30:47 <cocreature> jbr69: paste code samples on some pastebin site, e.g., github gists and then post the link here
11:31:51 * hackage initialize 0.1.0.0 - Initialization and Deinitialization of 'Storable' values.  http://hackage.haskell.org/package/initialize-0.1.0.0 (chessai)
11:32:27 <Arney> how does one get the set of subsets in haskell
11:33:04 <zachk> @type subsets
11:33:05 <lambdabot> error:
11:33:05 <lambdabot>     â€¢ Variable not in scope: subsets
11:33:05 <lambdabot>     â€¢ Perhaps you meant â€˜substâ€™ (imported from Data.Number.Symbolic)
11:33:10 <zachk> :(
11:34:18 <davean> Arney: http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Set.html#v:powerSet
11:34:34 <davean> Right in the set docs, if you search "subset"
11:34:36 <Arney> uhm and if i have a list?
11:34:58 <davean> Then thats not a set
11:35:03 <exarkun1> I'm having trouble with exceptions.  I have `forkIO x` and I think `x` is failing with ConnectionClosed but I can't figure out how to confirm this or do anything about it.
11:35:08 <davean> but you can also search in Data.List
11:35:43 <davean> Theres two related functions, but the concept is not as clear in the list case since order matters in litss
11:35:58 <cocreature> Arney: what exactly are you looking for? do you want to convert the list to a Set and then get the subsets of that or get subsequences of the list (potentially containing duplicates)?
11:36:21 <exarkun1> I failed to influence the behavior in any useful way with `catch`.  All I managed to do was suppress the printing of "ConnectionClosed" (without obviously getting code into the exception handling code path).
11:36:32 <Arney> well, it's hard to describe.. im writing a program in ruby right now.. i have sets of people, and those overlap
11:36:36 <davean> Yah, the closest analog on litss is http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:subsequences
11:36:41 <davean> but lists are inherantly different
11:36:57 <Arney> i wanted to be able to tell the people in those sets.. (they're in a database)
11:37:23 <cocreature> not sure where having the powerset comes into play
11:37:25 <davean> Arney: ... so why aren't you looking at union and interections?
11:37:33 <Arney> so i calculated the intersections (which works).. now i wanted a function that has maps inputâ‡’output.. and noticed it's 2^n
11:37:46 <Arney> and i was wondering if such alghorhithm was possible in haskell
11:37:52 <Arney> like.. atleast i could model it that way
11:38:01 <davean> Thats a really weird approach
11:38:16 <davean> I mean the concept is trivial
11:38:20 <davean> but you sure thats what you want?
11:38:29 <Arney> yes. i want to count people without inersections
11:38:38 <davean> ... thats different
11:38:47 <Arney> well i meant it that way
11:39:01 <davean> just do set difference after a union of the interesections
11:39:57 <jbr69> I took the example from http://pandoc.org/filters.html to start writing my own pandoc filter and learn haskell on the trip. Unfortunately the example doesn't work: https://pastebin.com/Mc6Rr0nF. The ghci tells me "Couldn't match type `Text' with `Char'    Expected type: String -> String      Actual type: Text -> [Text]." I use pandoc 2.3.1.
11:40:10 <Arney> okay.. i said it wrong.. the intersection should be in there, but shouldn't counted twice
11:40:21 <davean> ... then just union all the sets
11:40:42 <Arney> yeah the example is big and in the database.. it was a theoretical thought
11:40:46 <Arney> that's why i modeled it so weird
11:41:01 <davean> What you were suggesting is even *worse* if its large
11:41:08 <cocreature> jbr69: please show us the full error. I donâ€™t want to guess where exactly in the snippet that error occurs
11:41:11 <Arney> there are millions of people inside of those groups.. but they overlap only slighty
11:41:17 <Arney> still i need to be exact
11:41:46 <Arney> but i know how many are in there, and i can calculate intersections in 6s :o so i could count in 6 seconds, but programming this sucks
11:42:23 <davean> well, you can count the size of the intersections and count the side of the sum of the size of all sets and subtract
11:42:25 <davean> thats also easy
11:42:37 <davean> also IN NO WAY touches the ginormous power set
11:43:27 <the_2nd> Is there a function similar to mapM, but returning the first valid element instead of the list if all valid?
11:44:01 <the_2nd> or similar to sequence
11:44:26 <cocreature> the_2nd: how do you define â€œvalidâ€?
11:44:27 <Arney> i guess my thought was just stupid, haven't eaten in a while
11:44:52 <the_2nd> if Either then first Right
11:44:58 <the_2nd> if Maybe, then first Just etc
11:45:08 <the_2nd> or does that not work on Monad in general?
11:45:36 <the_2nd> hm, I guess for IO it wouldn't make sense
11:46:20 <cocreature> :t \f -> runExceptT . asum . map (ExceptT . f)
11:46:21 <lambdabot> (Monoid e, Monad m) => (a1 -> m (Either e a2)) -> [a1] -> m (Either e a2)
11:46:23 <the_2nd> maybeToList . catMaybes ?
11:46:24 <cocreature> how about that?
11:46:48 <avremel>    /join #haskell
11:46:52 * hackage haskoin-store 0.4.1 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.4.1 (xenog)
11:47:34 <the_2nd> I guess maybeToList . mapMaybe f
11:47:47 <the_2nd> should work for my case
11:48:21 <cocreature> that doesnâ€™t typecheck
11:48:39 <jbr69> ok, here is the full error message: https://pastebin.com/q95PzbQa. I have the following questions: 1. did the signatures of readMarkdown, writeMarkdown change / is the documentation outdated? if so, 2. how do i pass Text correctly for being processed by includeBlock in function readDoc? 3. ditto for writeDoc? 
11:48:43 <cocreature> :t \f -> runMaybeT . asum . map (MaybeT . f)
11:48:45 <lambdabot> error:
11:48:45 <lambdabot>     Variable not in scope: runMaybeT :: f0 a0 -> c
11:48:45 <lambdabot> error:
11:48:55 <the_2nd> *listToMaybe
11:49:24 <cocreature> @let import Control.Monad.Trans.Maybe
11:49:26 <lambdabot>  Defined.
11:49:28 <cocreature> :t \f -> runMaybeT . asum . map (MaybeT . f)
11:49:29 <lambdabot> Monad m => (a1 -> m (Maybe a2)) -> [a1] -> m (Maybe a2)
11:50:44 <Solonarv> replace map with fmap, and it'll work for any foldable+functor instead of just []
11:51:28 <koz_> jle`: Congratulations on making Haskell Weekly, again.
11:51:50 <cocreature> jbr69: use interact from Data.Text.IO
11:51:58 <the_2nd> nice
11:52:10 <cocreature> jbr69: the docs are fine afaict, you are probably looking at the docs for an old version
11:52:22 <cocreature> and yes afaik pandoc used to use String but switched to Text
11:52:41 <inkbottle> `stack script --resolver lts-12.1 --ghc-options "-isrc" -- hello.hs` (is there a better way to specify "search path" with "stack script"? Meaning not involving "--ghc-options".)
12:05:12 <jbr69> when i try to use Text to pass to readMarkdown / writeMarkdown i get the following errors: https://pastebin.com/1ViRcg2S
12:05:46 <jbr69> can someone explain to me what that means and why they occur?
12:09:26 <geekosaur> all the pandoc routines need to be run in the Pandoc monad, but you're trying to use them directly
12:10:38 <jbr69> but the example code on http://pandoc.org/filters.html demonstrates it like that, doesn't it?
12:10:51 <Darwin226> This should compile, right? https://gist.github.com/LukaHorvat/159924e341287a671a1dbbb432190e90
12:10:56 <Darwin226> Is it a bug if it doesn't?
12:11:42 <Darwin226> Complains that "asd" has the kind Symbol when it's expecting a *, but the issue is in the derived instance that uses type applications and forgets to first apply the kind parameter
12:12:13 <geekosaur> http://hackage.haskell.org/package/pandoc-2.3.1/docs/Text-Pandoc.html the example here suggests you need runIOorExplode, or a relative that allows exceptio handling
12:12:52 <exarkun1> Do forkIO'd threads need to be kept alive explicitly somehow?
12:14:23 <jbr69> @geekosaur: thanks, but how do i do filtering in that case? can i still have a pure function includeBlock :: Block -> Block?
12:14:24 <lambdabot> Unknown command, try @list
12:15:21 * hackage initialize 0.1.1.0 - Initialization and Deinitialization of 'Storable' values.  http://hackage.haskell.org/package/initialize-0.1.1.0 (chessai)
12:16:58 <geekosaur> exarkun1, I'm not sure what you're asking. no threads survive the main thread exiting because that is process exit, not thread exit; the async package provides a way to wait until all child threads have completed
12:23:31 <geekosaur> jbr69, I'm not sure. this makes me think there's been an API change somewhere and the docs don't match the released version :/
12:23:53 <exarkun1> geekosaur (IRC): X/Y I guess, sorry.  I have an IO and it doesn't run to completion and I'm at a loss.  <https://github.com/LeastAuthority/S4-2.0/blob/11.provision-endpoint/s4/src/Lib.hs#L135-L139>
12:25:25 <exarkun1> The main thread doesn't exit
12:25:35 <exarkun1> And I've never used forkIO before
12:25:58 <jbr69> geekosaur: ok, thanks. where can i read more to understand how to run "pandoc routines in the  Pandoc monad"?
12:28:23 <Darwin226> Oh... it is a bug
12:28:35 <Darwin226> seems like it's fixed somewhere between 8.2.2 and 8.6.1
12:30:12 <geekosaur> jbr69, I don't kkow. the examle in the hackage doc wants runIOorExplode and it won't work with interact (but presumably replaces it). there's also runPure but it has no documentation
12:30:41 <delYsid> jbr69: https://pandoc.org/using-the-pandoc-api.html#the-pandocmonad-class
12:40:28 <exarkun1> I switched from forkIO to async and the IO doesn't die halfway through anymore but I have no enlightenment. :/
12:43:42 <Squarism> anyone spent time with mongodb and haskell? If i wanted to persist big nested datastructures, what is the least-work-required long term Document <-> SomeType conversion?
12:45:16 <leshow> in haskell when you give a 'type hint' to something like val :: Integer
12:45:23 <leshow> what's what called, the proper terminology
12:45:30 <leshow> say that val is some polymorphic type
12:45:35 <hyperisco> leshow, type annotation
12:45:49 <leshow> not type ascription?
12:46:11 <hyperisco> sounds like the same thing to me but I am sure a superior pedant can disagree
12:46:14 <exarkun1> or maybe it still dies halfway through and I just don't get any indication of that anymore...
12:46:41 <ski> leshow : a type ascription attaches to an expression (or pattern)
12:46:47 <ski> leshow : a type signature is a declaration
12:46:51 * hackage btrfs 0.2.0.0 - Bindings to the btrfs API  http://hackage.haskell.org/package/btrfs-0.2.0.0 (MariosTitas)
12:47:28 <ski> (and i suppose people also use the term "type annotation" for the former)
12:47:36 <leshow> yeah. there's a feature in rust that they call 'type ascription'
12:47:42 <leshow> has never made it into stable
12:47:52 <ski> i think the term comes from the MLs (afaik)
12:47:55 * ski likes it
12:55:41 <geekosaur> exarkun1, it sounds to me liek you want an exception handler in te thread; normally, an exception in a thread just vanishes ebcause there's nothing to catch it
12:56:46 <geekosaur> exception thrown -> unwinds to top of thread -> nothing waiting for exceptions etc. in a parent thread -> "welp"
12:58:30 <sun777> >:t (+) <$> (*2)
12:58:48 <sun777> oops, how do i get the type for this expression? 
13:00:03 <heaven> :t (+) <$> (*2)
13:00:04 <lambdabot> Num a => a -> a -> a
13:00:28 <heaven> !
13:01:54 <sun777> thnaks!
13:33:22 * hackage statsdi 0.1.0.0 - A lovely [Dog]StatsD implementation  http://hackage.haskell.org/package/statsdi-0.1.0.0 (iostat)
13:35:22 * hackage statsdi 0.2.0.0 - A lovely [Dog]StatsD implementation  http://hackage.haskell.org/package/statsdi-0.2.0.0 (iostat)
13:35:41 <jbr69> geekosaur: thanks, i will try to use the weekend to increase knowledge :)
13:42:41 <hyperisco> ski, "ascription" is a better word but everyone has been saying "annotation" around here forever
13:42:42 * Arney doesn't get what applicative is good for
13:43:34 <Rembane> Parsers! 
13:43:41 <hyperisco> Arney didn't mean it Applicative, it's okay.
13:44:20 <Arney> no, i mean i don't understand
13:44:23 <Arney>  wish i knew
13:49:25 <dmwit> Arney: regex-applicative and optparse-applicative are posterchildren Applicative-not-Monads
13:49:59 <tdammers> more generally, parsers often don't need to be monads, applicative is enough
13:50:24 <dmwit> For regex-applicative, if it was made monadic parsers would lose O(n) asymptotic complexity. For optparse-applicative, if it was made monadic you wouldn't be able to print a help message.
13:51:09 <Arney> well, can you make it easy?
13:51:09 <dmwit> (You would lose other things, too, but those examples are particularly concrete and it is easy to understand why you'd want them.)
13:51:10 <hyperisco> Applicative would be even more exciting if recursion was observableâ€¦ but the general advantage is that you can observe all the constructors without executing anything
13:51:17 <Arney> is it really just for chaining stuff?
13:51:27 <hyperisco> whereas with Monad you cannot, because the rest is dependent on executing the first
13:51:44 <Arney> can u give me an example where applicative do something that would not be possible without?
13:51:52 <Arney> or rather more complicated?
13:51:59 <dmwit> Arney: No, everything that can be done with Applicative can be done without.
13:52:04 <hyperisco> uh, well you might not be excited by such examples Arney
13:52:11 <hyperisco> :t sequenceA
13:52:12 <Arney> hyperisco: i am, trust me
13:52:12 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
13:52:18 <hyperisco> okay, well there is one
13:52:30 <Arney> i mean a simple one.. not an existing function
13:52:40 <hyperisco> what's wrong with an existing function
13:52:43 <Arney> like (+) <$> (*2) this thing
13:52:48 <hyperisco> that's pointless
13:52:51 <Arney> is there a reason i can't do that without?
13:52:54 <hyperisco> also doesn't use Applicative
13:53:01 <Arney> hm, what does it use?
13:53:05 <hyperisco> Functor
13:53:13 <Arney> yeah the type said that
13:53:21 <dmwit> Okay, I conclude that I don't understand the question.
13:53:22 <hyperisco> if you pick any particular instance of Applicative then you can always do without Applicative
13:53:35 <hyperisco> the only time you *need* Applicative is when you do not know the instance
13:53:35 <Arney> why do i need to know about it then?
13:53:55 <hyperisco> which is a function like sequenceA which works on any Applicative
13:53:59 <Rembane> It's much nicer working with Applicative than without.
13:54:01 <Rembane> imo
13:54:20 <hyperisco> well yeah, it is also an idiom for APIs
13:54:20 <Arney> well, why
13:54:27 <dmwit> You don't need to know about it. You can get by without it.
13:54:34 <Arney> yes, but why people do that
13:54:56 <Arney> you could go without languages, you can go without them
13:55:11 <hyperisco> I guess if you're dead? seems difficult :P
13:55:21 <dmwit> Arney: Suppose I showed you a new type. And I told you that type had an addition operator.
13:55:44 * Arney supposes
13:55:45 <dmwit> Arney: I bet you'd quickly go, "Oh, neat! I know how to use that, because I have lots of experience with how addition works on integers and reals and fractions and stuff.".
13:56:00 <dmwit> Arney: A similar situation exists around the Functor-Applicative-Monad hierarchy.
13:56:01 * Arney thinks exactly that
13:56:12 <dmwit> Arney: Many libraries expose a type, and say, "This is a monad.".
13:56:29 * Arney believes that
13:56:42 * hyperisco took "need" vs "want" too literally
13:56:43 <dmwit> And the experienced Haskell programmer goes, "Oh, neat! Now I know I can use replicateM and forM and sequenceA and all these other fun combinators that I have a lot of experience with from other combinators.".
13:57:06 <dmwit> And that makes understanding the API much simpler, and also makes the API itself much smaller because many pieces of useful functionality are already written for you.
13:57:14 <Arney> okay, that goes for monads, yes
13:57:56 <dmwit> Same argument is true about Applicative. There's lots of nice combinators that only require Applicative (not Monad), and so saying a thing is Applicative tells you a lot about what you can do with it.
13:58:11 <Arney> oh.. it's a watered down monad?
13:58:23 <dmwit> Sure, why not.
13:58:24 <vaibhavsagar> something like that
13:58:56 <vaibhavsagar> Arney: you know how Functor is also a watered down Monad?
13:59:20 <hyperisco> "watered down" makes it sound impotent
13:59:28 <benzrf> rude
13:59:37 <Solonarv_> forM ? you heathen! use for ! it doesn't need a monad constraint!
13:59:45 <benzrf> :t for
13:59:47 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
13:59:53 <benzrf> @src for
13:59:53 <lambdabot> Source not found. stty: unknown mode: doofus
13:59:54 <ski> hyperisco : hehe, i've been saying "ascription" in here "forever" as well, so it's not "everyone" ;)
14:00:05 <Solonarv_> for = flip traverse
14:00:14 <lantti> how does that work then? i was told that a monad is a space suit floating in water with fruit inside. now if you water it down, wont it sink?
14:00:25 <Rembane> Mmmmmfruit...
14:00:32 <dmwit> The advantage of Monad over Applicative is that the user of a type which implements Monad can do more stuff with it. The advantage of Applicative over Monad is that the implementor of a type which promises to be Applicative but not Monad can write more analyses on their "parcel".
14:00:41 <glguy> lantti: You'll have to ask the joker who told you that
14:01:46 <hyperisco> the user of a generic function can benefit more if it just requires Applicative rather than Monad
14:02:27 <dmwit> Oh, rats. I completely ruined the parallelism of my analogy. I should have said "...all these other fun combinators that I have a lot of experience with from other *Monads* [not combinators].".
14:02:49 <lantti> glguy: i believe the analogy was from here: http://koweycode.blogspot.com/2007/01/think-of-monad.html
14:04:11 <ski> (perhaps other people don't adopt it. that's their choice. i won't be deterred by other people not following along, will continue to use "ascription" unless someone can convince me of a relevant reason why something else is better. that's not to say i'll fault people for using differing terminology, of course)
14:04:21 <dmwit> lantti: Therefore you should ask dons. But I have bad news for you: he's too busy making big tall piles of $ to answer petty questions these days.
14:04:57 <hyperisco> why did I think of ($) first
14:05:22 <dmwit> ski: (I suppose you have already considered and rejected the "consensus makes communication more efficient" angle?)
14:06:13 <Arney> can i have the @undo feature in ghci?
14:06:14 <ski> well, as i understand it, "ascription" predates "annotation"
14:06:39 <dmwit> Arney: You can install lambdabot locally. Google also "ghci on acid" although those tutorials are... probably way out of date.
14:07:02 <hyperisco> that's not much reason to revert the great vowel shift though is it
14:07:40 <dmwit> ski: "predates" is, perhaps surprisingly, only vaguely related to where consensus lands.
14:07:42 <Arney> dmwit: shouldn't this be a default feature :(?
14:08:12 <dmwit> Arney: Oh, sure. There's a way to ask GHC to dump out the result of desugaring.
14:08:24 <ski> (i'm not saying i won't change my mind. i'm just saying i haven't found a reason to do so yet. i agree about common termonology making things more efficient, but i don't think is the only thing to consider)
14:08:25 <dmwit> Arney: But it's a lot less pretty than ?undo for a lot of things.
14:09:04 <dmwit> Arney: https://stackoverflow.com/q/21463903/791604
14:09:59 <Welkin> predate, to catch and eat prey
14:10:13 <dmwit> predator, one who comes before another
14:10:31 <ski> (generally, i'm often more in favor of letting people make their own choices, choose their own style. i can e.g. suggest a particular indentation style, and elaborate on why i use it. but ultimately it's up to themselves to decide what serves them best)
14:11:14 <ski> (it's another thing when there's something actively confusing, ambiguous, or misleading, of course)
14:11:51 <Welkin> ski: in other languages there is a standard way to format your code (elm-format, rust-format)
14:11:55 <Welkin> and it is automatic
14:12:05 * ski nods
14:12:14 <Welkin> I like that a lot for those cases (elm in particular)
14:12:52 <Arney> ohwow ddump-simpl looks ugly af
14:14:59 <Arney> but it's explicitness can be useful too i gues
14:15:22 <lavalike> Arney: first step is obtaining and running lambdabot, then there's some ghci integration around
14:16:13 <o1lo01ol1o> Does anyone have experience with p12 certificates and TLS requests in haskell (or another language)?
14:16:15 <delYsid> Arney: A simple example I found interesting is the -> Applicative instance.  You can use that to pass an argument to several functions. \x -> f (g x) (h x) (i x) = f <$> g <*> h <*> i
14:18:00 <dmwit> -ddump-simpl is the Truth about what GHC thinks of your code. As such it can be invaluable in certain circumstances.
14:18:27 <Darwin226> How come I sometimes can't derive something in a deriving statement but have to write a standalone deriving instance with a manually specified context?
14:18:33 <dmwit> `case foo of (Left True, False) -> ...` can not happen, it is exploded into four nested `case` statements on the tuple, the `Either`, and the two `Bool`s. Which happens first? Core will tell you.
14:18:40 <Darwin226> What are the rules for which contexts must be manually specified
14:19:18 <dmwit> How many allocation points does your code have? The Core will tell you; there's one allocation per let.
14:19:57 <Arney> delYsid: that's a god example
14:19:57 <hyperisco> :t (lift2 . lift2) (+) (const (*2)) (const . (+1)) -- delYsid
14:19:58 <lambdabot> error:
14:19:58 <lambdabot>     â€¢ Variable not in scope:
14:19:58 <lambdabot>         lift2
14:20:06 <hyperisco> too much of a different language
14:20:27 <dmwit> Darwin226: The Report has a section on how the contexts are built for the standard classes. For GND I believe GHC's documentation has the precise rules.
14:20:49 <hyperisco> :t (liftA2 . liftA2) (+) (const (*2)) (const . (+1)) -- delYsid
14:20:50 <lambdabot> Num b => b -> b -> b
14:20:57 <Darwin226> I'm guessing for anyclass as well
14:21:00 <dmwit> Darwin226: In fact, I'd go to GHC's documentation for any of the extended deriving mechanisms. It should have the rules used for building the contexts in there.
14:21:16 <dmwit> Darwin226: For AnyClass it uses the Eq rules. Which is... especially obtuse, but that's what it does.
14:21:20 <lavalike> delYsid: I think that's wrong, the results has a bunch of different arguments, the one that applies the same one over and over is join
14:22:02 <Darwin226> dmwit: There was some mention of things chaning with 8.2 IIRC, is that still the case?
14:22:22 <Darwin226> https://ryanglscott.github.io/2017/04/12/improvements-to-deriving-in-ghc-82/
14:22:26 * ski . o O ( gustave :: Bool -> Bool -> Bool -> Either Bool Ordering; gustave True  False _     = Right GT; gustave _     True  False = Right LT; gustave False _     True  = Right EQ; gustave True  True  True  = Left  True; gustave False False False = Left  False )
14:22:55 <lavalike> delYsid: nevermind, I am wrong
14:22:59 <hyperisco> lavalike, liftAn g f1 f2 â€¦ fn = \x -> g (f1 x) (f2 x) â€¦ (fn x)
14:23:01 <dmwit> Darwin226: Yes, I believe DerivingStrategies was implemented and shipped.
14:23:25 <lavalike> yes sorry
14:23:35 <Darwin226> No no, I mean, is what you say about it being the same as Eq still true?
14:23:38 <delYsid> > ((*) <$> (+1) <*> (+2)) 1
14:23:40 <lambdabot>  6
14:24:09 <hyperisco> so  (liftA2 . liftA2) g f1 f2 â€¦ fn = \x y -> g (f1 x y) (f2 x y) â€¦ (fn x y)
14:24:10 <dmwit> Darwin226: Yes. You just have more control over whether it chooses to create the instance via DeriveAnyClass or via some other mechanism.
14:24:24 <Darwin226> The post isn't only about deriving strategies
14:24:29 <hyperisco> liftAn . liftAn  I mean
14:24:45 <Darwin226> Specifically, the "DeriveAnyClass overhaul" part
14:25:16 <dmwit> Darwin226: I don't know. Check the release notes, and the documentation. That's what I would do.
14:25:29 <Darwin226> Ok, thanks
14:25:41 <dmwit> Darwin226: And then, if I were feeling especially paranoid, I would install the versions I cared about and run experiments.
14:27:15 <hyperisco> which is a particularly helpful technique for pointless form
14:28:48 <hyperisco> I haven't done that in a long time nowâ€¦ converted something to pointfree
14:29:07 <lavalike> > (join . join . join) (\x y z h -> x * (y + z) - h) 2 -- this is what I was thinking of
14:29:09 <lambdabot>  6
14:29:47 <lavalike> same argument to one function not several ones
14:34:54 <delYsid> I want idiom brackets btw :-]
14:35:43 <delYsid> [| noteValue * dotsFactor |]
14:36:06 * ski . o O ( reflective syntax )
14:36:29 <ski> (imho better than idiom brackets)
14:38:51 * hackage asset-bundle 0.1.0.1 - A build-time Cabal library that bundles executables with assets  http://hackage.haskell.org/package/asset-bundle-0.1.0.1 (deech)
14:40:27 <hyperisco> ski, what is that
14:40:44 <ski> a not-completely-baked idea of mine
14:41:08 * hackage arraylist 0.1.0.0 - Memory-efficient ArrayList implementation  http://hackage.haskell.org/package/arraylist-0.1.0.0 (chessai)
14:41:26 <ski> the idea is to introduce local, *lexically*-scoped side-effects
14:42:31 <ski> given `data Person = MkPerson Name Age', `parseName :: Parser Name' and `parseAge :: Parser Age', we could write something like
14:42:40 <ski>   parsePerson :: Parser Person
14:43:20 <ski>   parsePerson = [< MkPerson [{parseName}] [{parseAge}] >]
14:43:30 <ski> the types are as follows
14:43:41 <ski>   MkPerson :: Name -> Age -> Person
14:43:48 <ski>   parseName :: Parser Name
14:44:07 <ski>   [{parseName}] :: Name  -- with `Parser'-side-effects
14:44:15 <ski>   parseAge :: Parser Age
14:44:23 <ski>   [{parseAge}] :: Age  -- with `Parser'-side-effects
14:44:39 <hyperisco> oh gotcha
14:44:49 <ski>   MkPerson [{parseName}] [{parseAge}] :: Person  -- with `Parser'-side-effects
14:45:02 <ski>   [< MkPerson [{parseName}] [{parseAge}] >] :: Person Person
14:45:09 <hyperisco> all you actually need then is extensible effects
14:45:35 <ski> the difference with idiom brackets is that there you need to annotate the whole path from the root of the expression, down to where you want to include an effect
14:46:21 <ski> with my idea, you only annotate the exact subexpressions where you want to reflect your effects (and also delimit the whole expression in a "reify" operation to get back into the pure world)
14:46:59 <ski> also, if there's no `[{...}]' inside a sub-expression, then that sub-expression is pure. you can't hide side-effects behind calling an ordinary function
14:47:05 <patrl1> hello. Does anyone here have any experience writing a haskell wrapper around a nodejs module (using ghcjs...I guess?). I'd like to write a wrapper around ssb-client https://github.com/ssbc/ssb-client which is a fairly simple node module with some dependencies
14:47:11 <ski> that's what i mean by "lexically-scoped side-effects"
14:47:27 <patrl1> I haven't been able to find any examples of anyone doing something similar, and I'm wondering if that's because it's a terrible idea
14:47:38 <hyperisco> yeah well if you can point to how to do extensible effects in Haskell this idea is readily doable
14:47:50 <patrl1> If anyone knows of anything along these lines, I'd appreciate being pointed in the right direction!
14:47:57 <ski> for this reason, you can't use `[{...}]' (reflect) inside the body of a lambda, without there being a wrapping `[{}]' (reify) also inside the body
14:48:25 <ski> hyperisco : now, the same notation readily works both for `Functor',`Applicative' and `Monad'
14:48:36 <hyperisco> yup
14:49:10 <ski> e.g. `[< let x = [{act}] in ..x.. >]' means `do x <- act; [< ..x.. >]'
14:49:36 <mniip> hmm, is lpaste up
14:49:57 <suzu> if you want extensible effects, Eff is quite nice
14:49:58 <ski> also, you can write `[< if [{act}] then ... else ... >]' (also for `case') without first having to bind the result of `act' with `<-' in `do'
14:50:03 <suzu> i cargo cult it as my replacement for IO
14:50:31 <ski> mniip : still down, it seems
14:50:42 <mniip> dammit
14:50:52 * ski doesn't know what's up with it
14:51:19 <hyperisco> you want an extensible effect type because then that is what [{}] works on, and all the effects collect from the uses of [{}]
14:51:48 <ski> hyperisco : now .. i'd also like this to interact reasonably with monadic transformers, and that's where i haven't thought it out completely
14:52:26 <hyperisco> mmâ€¦ I don't think you do :P
14:52:26 <ski> hyperisco : in my case, i just have a single `f', being instance of `Functor'/`Applicative'/`Monad', that describes the effect
14:52:37 <ski> well, i'm not sure
14:52:47 <hyperisco> transformers are obviated by extensible effects
14:52:55 <ski> anyway, if there's only a single reflect, then only a `Functor' contraint is imposed
14:53:23 <hyperisco> I have been working with extensible effects for the past month daily and so can very clearly see how this could work
14:53:48 <ski> if you use `let x = ..[{...}].. in ..x..' inside a reify, then that means you need `Monad'. also if you use reflect inside the condition of `if', and the scrutinee of `case'
14:54:07 <ski> also effects are performed in the order that the reflects are given in, syntactically
14:54:26 <hyperisco> good point :)
14:55:00 <ski> so `[< [{foo}] [{bar}] >]' is `foo <*> bar', while `[< flip [{foo}] [{bar}] >]' is `foo <**> bar'
14:55:41 <ski> btw, i'm not married to the concrete syntax of `[< .. >]' and `[{ .. }]'. perhaps there's a nicer alternative
14:56:42 <ski> i was inspired by one of the idiom papers by Ross Paterson and Conor McBride, but also by quasiquotation in the lisps
14:57:29 <ski> `[< .. >]' (reify) corresponds to `quasiquote', and `[{ .. }]' (reflect) to `unquote'
14:57:54 <ski> so, in lispy syntax, one'd have  `(make-person ,parse-name ,parse-age)
14:59:07 <ski> oh, i forgot, also inspired by Andrzej Filinski's "Monadic Reflection" paper about how, given any monad implemented in a language with composable continuation side-effects (or alternatively, ordinary continuation and state side-effects), you can *reflect* it so that it appears as a *built-in* side-effect in the language
15:03:41 <delYsid> interesting.
15:07:56 <hyperisco> ski, point I am making I suppose is that with extensible effects you just have idiom brackets again
15:08:27 <hyperisco> it becomes polymorphic over effects by other means
15:08:37 <ski> why would i want that ?
15:08:59 <hyperisco> I don't know what else you're looking for
15:11:15 <ski> why would i want `[| f [| g (pure (...)) [| h act0 act1 |] |] (pure (...)) |]' rather than `[< f (g (...) (h [{act0}] [{act1}])) (...) >]' ?
15:11:58 <ski> with idiom brackets, you have to annotate the whole path down to the bracket where `act0' and `act1' are placed, and also shield the non-effectful side expressions with `pure'
15:12:20 <hyperisco> guess they're more particular than I imagined
15:12:35 <ski> with my reflective syntax, you just need to delimit the whole thing (reify), and annotate the actual places (reflect) where you want to insert your effects
15:13:27 <hyperisco> yeah I'm on board I just didn't think idiom brackets were that restrictive
15:13:28 <ski> `[| f E0 E1 E2 E2 |]' expands to `f <$> E0 <*> E1 <*> E2'
15:13:36 <Puka> hello guys
15:14:09 <ski> they only work on a (multiple-argument) application node, they don't apply to a whole syntax tree (unlike my reify)
15:14:27 <hyperisco> okay then forget the idiot brackets :)
15:14:41 <Puka> i'm learning haskell but i'm having a problem. When i enter ''x :: Int " it tells me "variable not in scope" i'm in GHCi
15:15:23 <ski> so, if you wanted `[| f (pure x) E0 E1 |]', i think you could actually get that easier by `[| (f x) E0 E1 |]', but that's it for easier expression with idiom brackets, i think
15:16:04 <hyperisco> right but you're doing the "protection" by instead marking what is effectful
15:16:39 <ph88> is ghcjs dead ?
15:16:40 <ski> (can't do that with `[| f E0 (pure x) E1 |]', without introducing a lambda, or using `flip', like `[| (flip f x) E0 E1 |]' or `[| (\a -> f a x) E0 E1 |]')
15:16:55 <julianleviston> ph88: haha no why?
15:17:06 <ph88> because commit history of recents years
15:17:15 <MarcelineVQ> Puka: each line in ghci is independent unless you specify otherwise with brackets and ;  or use the commands :{   and   :}    so you probably wanted to write,  x :: Int; x = 3   or something similar
15:17:19 <hyperisco> so you say  [< f [{E0}] x [{E1}] >]
15:17:45 <hyperisco> so instead of saying what is pure you say what isn't
15:17:46 <ski> hyperisco : right. the idea is that it's easier and nicer to spot the exact places where effects are inserted, rather than having to look at such annotations on the full paths down to those places, hunting visually for the endingpoints of those paths, in the code
15:17:48 <Puka> oh thanks
15:18:03 <ski> right
15:18:19 <hyperisco> just don't worry about transformers
15:18:22 <hamishmack> ph88: last commit was 3 days ago https://github.com/ghcjs/ghcjs/tree/ghc-8.4
15:18:22 <ski> `[{...}]' marks a side-effectful expression
15:18:39 <ph88> what's up with the main branch then
15:19:10 <ski> an expression which doesn't contain a `[{...}]' (unprotected by a surrounding `[<...>]'), doesn't have side-effects
15:19:12 <hyperisco> that's a pretty smart idea ski because one would be able to more or less write ordinary Haskell with effects handled invisibly
15:19:19 <ph88> ghc-8.4 branch is also not very active
15:19:58 <ski> finally, `[< blah (\x -> bleh [{...}]) >]' isn't possible, since we can't go from `a -> m b' to `m (a -> b)'
15:20:38 <ski> (or at least, using a reflect inside a lambda would require an extra class constraint that assumed we had such an operation. we can actually do that for `Reader r' ..)
15:20:40 <julianleviston> ph88: you might not be using a good metric for determining activity
15:21:14 <hyperisco> why isn't that   do y <- m; pure (blah (\x -> bleh y))  ?
15:21:28 <MarcelineVQ> gosh, that's actually a pretty annoying thing on github, not showing branch commits as the most recent activity by default
15:21:37 <ski> hyperisco : yep. still there's never any implicit side-effects when calling operations defined elsewhere. we must eventually reify our side-effects, by wrapping the whole expression in `[{...}]', before returning from function
15:21:39 <julianleviston> or, maybe phrased better: maybe your metric for determining project life isnâ€™t accurate
15:21:59 <ski> (and then the caller does `[<...>]' on such a call to get back into side-effect-mode)
15:22:09 <MarcelineVQ> I â€‹mean, it could just say    Latest commit 3959a93  on Dec 2, 2017 (branch commit a541ce9  3 days ago)
15:23:06 <jle`> koz_: thanks :)
15:23:12 <ski> hyperisco : `[< blah (\x -> bleh [{...}]) >]' asks for the effects of `...' to be done, before we've called the function, passing a value for `x'. even if `...' doesn't depend on `x', this doesn't work
15:23:18 <koz_> jle`: You're welcome - fully something more folks should see.
15:23:57 <hyperisco> nah I don't think you want that
15:24:02 <MarcelineVQ> koz_: Then link it you silly ;>
15:24:03 <ski> hyperisco : consider `\x -> if x > 0 then [{...}] else [{...}]'. even if the branches doesn't depend on the input `x', we still need to know `x' to determine which branch to executre
15:24:22 <hamishmack> ph88: ghcjs master branch should perhaps be renamed ghc-7 or something
15:24:30 <hyperisco> maybe I'll think about the syntax transformation later but for now I gotta go
15:24:35 <koz_> MarcelineVQ: https://blog.jle.im/entries/series/+introduction-to-singletons.html
15:24:47 <ski> hyperisco : of course, `[< blah (\x -> [< bleh [{...}] >]) >]' is something else, is ok, and is what i think you had in mind with your `do y <- m; pure (blah (\x -> bleh y))'
15:24:58 <hyperisco> ski, in my mind, [{m}] should just be bind on m
15:26:20 <ski> yes, `[< ..[{act}].. >]' corresponds to `do x <- act; [< ..x.. >]' (even though that would always require `Monad', and i don't always require that. but assuming `Monad' holds, it should be the same thing
15:26:22 <hamishmack> ph88: Lots of the effort is in libraries and toolsets using ghcjs (like reflex-platform)
15:26:24 <ski> )
15:26:43 <ski> (assuming `[{act}]' is the (syntactically) first reflect inside the reify, of course
15:26:47 <ski> )
15:26:55 <hyperisco> okay well we recognise certain degeneracies and lower to Applicative or Functor when able
15:27:01 <hyperisco> but generally we're talking Monad
15:27:09 <hamishmack> ph88: https://github.com/reflex-frp/reflex-platform/commits/develop
15:27:16 <ski> hyperisco : you could say so, yes
15:28:25 <julianleviston> I quite like !-notation for stuff thatâ€™s less simple.
15:28:33 <julianleviston> (Idris uses itâ€¦)
15:28:39 <julianleviston> http://docs.idris-lang.org/en/latest/tutorial/interfaces.html#notation
15:29:09 <ski> hyperisco : but rewriting `[< f (\x -> g [{ h x }]) >]' to `do y <- h x; [< f (\x -> g y) >]' doesn't make any sense. `x' is not in scope outside the lambda
15:29:27 <hyperisco> oh I see what you mean
15:29:37 <ph88> hamishmack, is there an easy interface for command line tools ?   maybe just some function to call where the arguments to the tool can be given   .. btw what about file io in browser ?
15:30:00 <hyperisco> I was thinking of [{}] like quasi quoting so x was not in scope
15:30:21 <ski> hyperisco : and rewriting `[< f (\x -> if p x then [{ foo }] else [{ bar }]) >]' to `do x <- foo; y <- bar; [< f (\x -> if p x then x else y) >]' doesn't make much sense either, i think
15:31:26 <ski> hyperisco : a side-effectful subexpression, of type `T', with `M'-side-effects, will be translated to a normal Haskell expression, of type `M T'
15:31:41 <hyperisco> ski, which is why you'd say  [{if p x then foo else bar}]
15:32:51 <hyperisco> no I get what the trouble is now with how you're doing scope
15:33:10 <hyperisco> anyways g2g
15:33:47 <ski> hyperisco : following that, in `[< \x -> [{act}] >]', if `act :: M U', then `[{act}] :: U' with `M'-side-effects, and then continuing the same pattern as before, we'd expect (if `x :: T') `\x -> [{act}] :: T -> U' with `M'-side-effects, and finally `[< \x -> [{act}] >] :: M (T -> U)'
15:34:11 <ski> @tell hyperisco following that, in `[< \x -> [{act}] >]', if `act :: M U', then `[{act}] :: U' with `M'-side-effects, and then continuing the same pattern as before, we'd expect (if `x :: T') `\x -> [{act}] :: T -> U' with `M'-side-effects, and finally `[< \x -> [{act}] >] :: M (T -> U)'
15:34:12 <lambdabot> Consider it noted.
15:36:09 <ski> @tell hyperisco so, this is assuming lambda "behaves the same wrt typing" when inside `[< .. >]' as outside (as we already assumed for application, `let',`if',`case'), except that we now also want to propagate side-effects. i don't see how one could avoid requiring a transformation from `T -> M U' to `M (T -> U)', to be able to use lambda like in this example
15:36:09 <lambdabot> Consider it noted.
15:39:46 <hamishmack> ph88: For a command line executable you can normally run the output of ghcjs with node and it will work like the executable ghc would have output.  In the browser stdout and stderr are written with console.log (so not ANSI support) and there is no stdin by default.  I can't remember what the thunks for C file IO functions (like open) do by default, but ghcjs-dom contains lots of browser IO options.
15:41:03 <ph88> ok
15:50:12 <Solonarv_> ski: do { x <- act; ... } doesn't always require Monad if you turn on ApplicativeDo
15:57:57 <ski> Solonarv_ : yea, i know. `
15:58:11 <ski> ApplicativeDo' didn't exist back when i started thinking about this
16:00:30 <ski> (also, Philippa made a quasi-quoter for applicative do (also before `ApplicativeDo' existed), and mmorrow one for idiom brackets)
16:00:40 <ski> @hackage applicative-quoters
16:00:40 <lambdabot> http://hackage.haskell.org/package/applicative-quoters
16:01:42 <ski> (perhaps i should make a quasi-quoter for reflective syntax ?)
16:02:19 <sun777> `f n = do {a <- (+2); b<-(*2); return (a, b);}` expects 2 numbers. how do i make it expect 1 number and return a tuple? 
16:03:22 <MarcelineVQ> sun777: did you mean to use n?
16:03:27 <jle`> sun777: what do you want to do?
16:03:30 <jle`> with the two numbres?
16:03:38 <jle`> er, with the one numbe ri mean
16:03:42 <ski> > let f n = do {a <- (+ 2); b <- (* 2); return (a,b)}  in  f undefined 3
16:03:44 <lambdabot>  (5,6)
16:03:51 <sun777> yes yes sorry
16:04:06 <jle`> sun777: what do you want to do with 'n' ?
16:04:06 <sun777> i meant a <- n+2, b<- n*2 sorry
16:04:12 <ski> it expects one input that it ignores, and then expects one number
16:04:22 <jle`> ah, then you can jus twrite f = (a, b) where a = n + 2; b = n * 2
16:04:30 <jle`> err, f n = (a, b)
16:04:32 <ski> both `(+ 2)' and `(* 2)' will be fed the same number
16:04:40 <jle`>         where a = n + 2; b = n * 2
16:04:44 <sun777> i want n to be feed to those function
16:04:58 <sun777> i can use where/let, but i want to know to do in do notation
16:04:59 <jle`> what functions, (+ 2) and (* 2)?
16:05:06 <jle`> ah, you can use do notation to build a function
16:05:06 <sun777> yes those two jle`
16:05:18 <jle`> myFunction = do { a <- (+ 2); b <- (* 2); return (a, b) }
16:05:20 <ski> > let f n = (do {a <- (+ 2); b <- (* 2); return (a,b)}) n  in  f 3  -- sun777, like this ?
16:05:22 <lambdabot>  (5,6)
16:05:31 <sun777> yes like that ski
16:05:31 <jle`> that creates a functino that takes a number and returns the number plus two and the number times two
16:05:45 <jle`> @let myFunction = do { a <- (+ 2); b <- (* 2); return (a, b) }
16:05:46 <lambdabot>  Defined.
16:05:48 <jle`> > myFunction 10
16:05:50 <lambdabot>  (12,20)
16:05:56 <ski> > let f = do {a <- (+ 2); b <- (* 2); return (a,b)}  in  f 3  -- same thing, simplified by function extensionality
16:05:58 <lambdabot>  (5,6)
16:06:01 <sun777> why can i omit n ?
16:06:09 <ski> function extensionality
16:06:09 <jle`> sun777: you're defining a function
16:06:14 <jle`> f is a function
16:06:25 <jle`> and do { ... } is a function
16:06:26 <ski> if `f x = g x' holds for every `x', then `f' and `g' behaves the same, so `f' and `g' are equal functions
16:06:36 <sun777> hmm i think i got it
16:06:38 <jle`> sun777: the do { ... } thing isn't a number... it's a function
16:06:43 <jle`> so f = myFunction
16:06:45 <jle`> f *is* the function
16:06:50 <jle`> f n is not the function, f is the function
16:06:54 <sun777> ah
16:06:58 <sun777> makes sense
16:07:06 <ski> (functions are determined, *only*, by what outputs they map their possible inputs to. so if the same inputs gives the same outputs, it's considered the same function)
16:07:07 <jle`> :t do { a <- (+ 2); b <- (* 2); return (a, b) }
16:07:09 <lambdabot> Num a => a -> (a, a)
16:07:14 <jle`> ^ see, the do notation expression is a function
16:07:21 <jle`> it's not a number, it's a function
16:07:29 <ski> so `toUppers s = map toUpper s' can be simplified to just `toUppers = map toUpper'
16:07:38 <sun777> what if i wanted 2 inputs? is it doable in do notation?
16:08:00 <jle`> it's simple if you have it take a tuple
16:08:08 <ski> (function extensionality is related to eta reduction/expansion/conversion (for functions))
16:08:14 <jle`> :t do { a <- fst; b <- snd; return (fst + snd) }
16:08:15 <lambdabot> Num ((a1, a1) -> a1) => (a2, b) -> (a1, a1) -> a1
16:08:20 <jle`> oops
16:08:25 <jle`> :t do { a <- fst; b <- snd; return (a + b) }
16:08:26 <lambdabot> Num b => (b, b) -> b
16:09:02 <sun777> ahhh got it now
16:09:04 <sun777> i think i got it
16:09:05 <sun777> thanlks!
16:09:11 <sun777> will play around ghci some mre
16:11:40 <ski> > (map . map) (fst^2 + fst * snd + snd^2) [[(m,n) | m <- [0 .. n]] | n <- [0 .. 3]]
16:11:42 <lambdabot>  [[0],[1,3],[4,7,12],[9,13,19,27]]
16:11:55 <MarcelineVQ> plunking away in ghci, is there a nicer only-base way to grep a text file for a word than    filter (any (isPrefixOf "ski") . tails ) (lines g)
16:12:12 <ski> sun777 : `fst^2 + fst * snd + snd^2' is a polynomial in two variables
16:13:05 <ski> @type isInfixOf
16:13:07 <lambdabot> Eq a => [a] -> [a] -> Bool
16:14:12 <jle`> note isInfixOf is pretty much defined like MarcelineVQ wrote it
16:14:14 <MarcelineVQ> aha neat, they named the prefix tails :>
16:17:03 <jle`> @src isInfixOf
16:17:03 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
16:17:12 <jle`> isInfixOf needle = any (isPrefixOf needle) . tails
16:18:13 <ski>   needle `isInfixOf` haystack = (needle `isPrefixOf`) `any` tails haystack
16:20:07 <_deepfire> kosmikus: is there a profound reason why lens-sop doesn't handle sums?
16:20:54 <_deepfire> I understand the partiality issue for non-aligned constructors makes things messy, but is there anything beyond that?
16:23:22 * hackage pretty-show 1.9.1 - Tools for working with derived `Show` instances and genericinspection of values.  http://hackage.haskell.org/package/pretty-show-1.9.1 (IavorDiatchki)
16:23:42 <_deepfire> Code a ~ '[xs]
16:26:38 <_deepfire> Recovering "sameness" of accessor is just slightly ambiguous, as the field name must match in addition to type..
16:27:26 <_deepfire> But then the problem suddenly blows up into simulating type-level sets..
16:28:12 <_deepfire> Messy..
17:27:58 * hackage metar 0.0.1 - Australian METAR  http://hackage.haskell.org/package/metar-0.0.1 (qfpl)
18:29:30 <Zemyla> Hmm, the profunctors package doesn't list the laws various Profunctor subclasses need to follow.
18:31:37 <Zemyla> For Closed, probably dimap const ($ undefined) . closed === id and dimap uncurry curry . closed === closed . closed.
18:38:02 <lyxia> you can make a pr to document them
18:43:21 * hackage metar 0.0.2 - Australian METAR  http://hackage.haskell.org/package/metar-0.0.2 (qfpl)
18:47:54 <oldandwise> i'm testing some FFI... I have ghc 8.4.3 in NixOS. From Foo.hs, I'm not getting a Foo_stub.c. I only get Foo.hi, Foo.o, Foo_stub.h and i am not seeing any errors...
18:49:15 <jle`> is there a non rank-n implementation of bazaar?
18:50:11 <jle`> or, at least bazaar (->)
18:50:25 <jle`> i'm thinking Bazaar (->) a b t = Bazaar ([b] -> t) [a]
18:53:34 <geekosaur> I think you only get the .c if you use capi instead of ccall
18:54:48 <geekosaur> back when ghc produced mutant C from Haskell, you got the .c; these days it's handled at assembler level. but if you're calling a varargs function or a macro, you need to go through C and use the capi FFI extension
18:56:15 <Zemyla> jle`: Nope, it's Bazaar a b t = Done t | More a (Bazaar a b (b -> t)).
18:57:46 <jle`> Zemyla: nice, thanks :)
18:57:58 <jle`> is this talked about anywhere?
19:00:37 <Zemyla> jle`: https://bartoszmilewski.com/2018/10/12/trading-funlists-at-a-bazaar-with-yoneda/
19:00:57 <jle`> ah nice.  sounds like a fun type :)
19:01:02 <jle`> thank you again!
19:04:15 <jle`> now to figure out how to write the Applicative instance ...
19:04:43 <linearity> I just figured out why `randomR (0.0, 1.0) g` wasn't working
19:05:14 <linearity> I didn't implement `genRange` in the instance of `RandomGen` for `g`
19:05:40 <linearity> Is something wrong with the default?
19:05:55 <linearity> I was getting a huge bias toward 0.0
19:06:53 <jle`> hard to know without seeing your implementation of 'next'
19:07:13 * jle` . o ( next g = (0, g) )
19:08:25 <linearity> I was just wrapping a `StdGen` in another data type
19:09:11 <linearity> `data A = A { rgen :: StdGen, x :: Int, ... }`
19:09:46 <jle`> so what's your implementation of 'next' ?
19:10:45 <linearity> then `instance RandomGen A where next a = let (k, g) = next (rgen a) in (k, a { rgen = g }) ...`
19:11:28 <jle`> hm, that seems sane
19:11:46 <jle`> are you aware that StdGen is pretty biased?
19:11:47 <linearity> same idea for `split`
19:11:51 <c_wraith> note that mkStdGen is really bad, and produces really biased generators on small inputs
19:11:53 <jle`> your bias might come from there
19:11:56 <linearity> I was reading about that
19:12:07 <jle`> you shouildn't really expect unbiased output from StdGen
19:12:22 <jle`> especially for small gens
19:12:29 <linearity> But the egregious bias I was seeing goes away if I just implement `genRange` in the same way
19:12:32 <linearity> all of a sudden I start getting the whole range of (0.0, 1.0)
19:13:04 <linearity> should I expect 0.0000000000001, like, every time?
19:13:34 <jle`> what is [minBound, maxBound] :: [Int] on your system?
19:14:03 <jle`> hm, that might be it, the range of StdGen is (1, 2147483562)
19:14:20 <jle`> so your stdgen-based generator gives ints from 1 to 2147483562
19:14:44 <jle`> the default implementation of genRange is (minBound, maxBound), so it's meant for generators that can produce all Int's
19:15:03 <linearity> [minBound, maxBound] = [-9223372036854775808,9223372036854775807]
19:15:18 <linearity> how does that translate to Doubles?
19:15:39 <jle`> it's probably that the Random instance for Doubles scales the number based on the range
19:15:55 <jle`> so StdGen always outputs integers between 1 and 2147483562
19:16:17 <c_wraith> yeah, it looks like StdGen doesn't use the default genRange
19:16:21 <jle`> but the Random instance for Doubles was expecting integers between -9223372036854775808 and 9223372036854775807
19:16:26 <jle`> so it scales appropriately
19:16:32 <linearity> OH...
19:17:15 <Zemyla> jle`: A thing I like doing is newtype FlipBazaar t b a = FlipBazaar { unflipBazaar :: Bazaar t b a }
19:17:18 <c_wraith> I'm going to argue that MINIMAL pragma is really misleading
19:17:40 <jle`> ah yeah, looking at the Random instance for Double, it basically does a linear scaling
19:17:45 <c_wraith> it's only minimal if your next can cover the full range of Int
19:18:02 <Zemyla> It's a Profunctor in that order as well, and a Monad, and a Traversable.
19:18:02 <linearity> those two points elucidate the issue, thanks
19:18:23 <jle`> randomR (mn, mx) basically picks a Int and scales it betweenthe min and max ofgenRange
19:18:23 <linearity> yeah minimal is pretty strong language for that
19:19:13 <Zemyla> *I meant unflipBazaar :: Bazaar a b t
19:19:35 <linearity> argh, well mystery resolved. I appreciate the explanations
19:19:47 <jle`> so if genRange = (1,100), then it would pick a random int between 1 and 100 and scale linearly against (mn,mx)
19:19:56 <jle`> Zemyla: ah interesting :)
19:20:18 <jle`> i'm writing an Applicative instance from scratch but i hope I'm writing the correct one
19:21:04 <jle`> it seems that more than one compiles
19:21:47 <jle`> More f b <*> More x c = More f $ More x $ (\g h y z -> g y (h z)) <$> b <*> c
19:21:59 <jle`> you can swap 'f' and 'x' and it'll still typecheck
19:22:02 <jle`> and also 'y' and 'z'
19:24:07 <Zemyla> jle`: Try writing it without expanding the right argument.
19:24:18 <jle`> type tetris can only get me so far is uppose
19:24:24 <jle`> ah hm
19:25:17 <Zemyla> Because your proposed version interleaves the values from the first and second arguments.
19:25:24 <c_wraith> I typically go with "what makes pure id <*> x === x?" as my heuristic for Applicative
19:25:58 <c_wraith> that's not the only law, but it has served me well as a guide.
19:26:25 <Zemyla> c_wraith: This one doesn't cause that problem, but it violates the associative laws.
19:27:10 <monochrom> The combination of it and the type probably does a lot.  Because afterall with Functor you just need fmap's parametrically polymorphic type plus fmap id = id to get the rest.
19:28:45 <orzo> I want to create a type error if two known (type-level) nat values, n and k, do not satisfy the equation n = k * q for some q.  What's a good way to achieve that?
19:29:20 <jle`> there are no parametrically polymorphic tricks to get around associativity for Applicative unfortunately
19:29:27 <c_wraith> hmm, right, doesn't help there because the only question is in the case when both constructors haven't come from pure.
19:30:07 <jle`> it's not too difficult to concoct an instance with pure id <*> x but violates associativity laws
19:30:23 <Zemyla> But yeah, try not expanding the right-side argument. This gives the proper behavior of appending instead of interleaving.
19:33:55 <geekosaur> orzo, one of the nat math plugins plus https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#custom-compile-time-errors ?
19:34:15 <jle`> ah, More a b <*> c = More a $ flip <$> b <*> c
19:35:32 <Zemyla> jle`: Also, you should probably define liftA2, because fmap is rather expensive on this data type.
19:35:33 <jle`> yay, cloneTraversal wasn't too bad
19:35:45 <orzo> geekosaur: I'm looking at TypeLits, and I was hoping ot use TypeError as described at your link, but it doesn't matter much.  If your link has advise about the particular problem, division, I don't see it.
19:35:57 <jle`> ah i'm writing this at the type-level, so i hope that people don't do anything too fancy
19:36:05 <jle`> this is for my type-level lens library :)
19:36:09 <geekosaur> that's where natnormalize or another plugin comes in
19:36:36 <jle`> but maybe i might as well write liftA2, to shave compiletimes perhaps
19:37:15 <orzo> oh hm
19:37:22 <geekosaur> you should be able to express that constraint with it
19:38:18 <geekosaur> look around on hackage, there's a couple compiler plugins that help with type-nats math
19:38:55 <orzo> i've never used compiler plugins, how does that work with a cabal build?
19:40:37 <orzo> maybe i set the plugin as a package dependency and then specify to use it with a ghc-options field?
19:40:42 <geekosaur> that I don't know
19:41:23 <geekosaur> normal usage is with a GHC_OPTIONS pragma; that and a dep on the package may be good enough since you're not developing the plugin, just using it
19:41:51 <geekosaur> there's some known gotchas (even with raw ghc) when using a plugin not from a package, although 8.6 may have resolved some of them
20:44:01 <solidus-river> hey all, i'm trying to install ghc-mod with stack on windows 10 and i'm getting a dep problem
21:02:35 <koz_> How does Data.Massiv.Array.Array D ix e implement Floating and Fractional (for Floating and/or Fractional e)?
21:23:31 <solidus-river> oh
21:23:42 <solidus-river> it looks like ghc-mod is just incompatable with the latest version of the haskell platform
21:28:33 <ski> koz_ : pointwise, perhaps ?
21:30:20 <koz_> ski: So how would it define 'pi'? Just 'fill with pis'?
21:37:30 <Solonarv_> yes
21:53:39 <orzo> In the user guide, regarding the hsc2hs tool, it documents a command #let for defining a macro, but I'm having trouble understanding the documentation
21:53:45 <orzo> anyone know how to use #let properly?
21:54:32 <orzo> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/utils.html#input-syntax
21:56:09 <dminuoso> 06:47          jle` | [02:28:58] there are no parametrically polymorphic tricks to get around associativity for Applicative unfortunately
21:56:11 <dminuoso> Provably?
22:03:45 <jle`> i mean that there's a counter-example
22:03:58 <jle`> of an instance that typechecks, and follows pure id <*> x = fmap x
22:04:02 <jle`> but still breaks the laws
22:07:06 <ania123> is here english native speaker?
22:07:29 <dminuoso> ania123: Very likely to have english native speakers with 1293 other folks in the room, wouldn't you agree?
22:10:05 <ania123> dminuoso: do not know. Are you?
22:10:23 <Solonarv_> and, additionally, people who aren't native speakers but speak just as well (e.g. me)
22:11:04 <ania123> Solonarv_: Do you speak fluently? 
22:11:14 <Solonarv_> I do
22:11:21 <ania123> I have some technical sentence in englush, what I need to correct
22:11:52 <ania123> since it is technical, that is why i am asking here and not in english chanel 
22:12:06 <Solonarv_> I assume it's haskell-related?
22:12:12 <Solonarv_> sure, whisper me
22:12:29 <ania123> it is not haskell related 
22:12:57 <Solonarv_> well send it to me anyway
22:13:55 <ania123> I pmed u
22:23:22 * hackage docusign-example 0.1.0.0 - DocuSign examples  http://hackage.haskell.org/package/docusign-example-0.1.0.0 (maerwald)
22:36:51 <jle`> dminuoso: you didn't ask for an example, but consider an Applicative instance for Const r where _ <*> Const x = Const x
22:37:20 <jle`> this satisfies pure id <*> x = x, but fails the associativity laws
22:37:37 <jle`> oh actually this one passes the associativity laws
22:37:53 <jle`> just not the other identity one ... i pulled out the wrong example v.v
22:38:27 <dminuoso> jle`: Well Im just wondering whether there may be an alternative representation for Applicative that would give us associativity for free from parametricity.
22:39:09 <dminuoso> Or is the represeentation irrelevant here?
22:47:31 <jle`> hm, I'm not sure if there's another way to express applicative that would give us free theorems strong enough to enforce laws
22:47:54 <jle`> the problem is that there are many 'almost-monoids', that have identities but not associativity
22:48:31 <lucca> err, why aren't semigroups sufficient for what you want
22:48:41 <jle`> there's even a way to construct a non-associative monoid from a given associative one 
22:49:01 <lucca> semigroup is monoid without identity
22:50:04 <jle`> we're talking about how because of parametric polymorphism, we can prove that functor laws are legal based on only a few restrictions
22:50:38 <Zemyla> jle`: I know how you make an associative monoid from a non-associative one (use Endo), but how do you do the reverse?
22:50:41 <jle`> one functor law + parametric polymorphism implies the other law
22:51:06 <jle`> but that's not the case for applicative, i think; none of the laws imply the other laws even with parapoly
22:52:19 <jle`> let me try to remember what i was thinking of Zemyla :)
22:54:01 <Zemyla> I really wish there were a class that was had methods one :: f () and both :: f a -> f b -> f (a, b)
22:54:17 <johnw> both = liftA2 (,)
22:54:35 <johnw> one = pure ()
22:54:38 <Zemyla> johnw: But it also works for contravariant functors, too.
22:55:29 <Zemyla> Another class in this vein would have zero :: f Void and oneOf :: f a -> f b -> f (Either a b)
22:58:55 <jle`> hm, a class that would cover both liftA2 and divided ?
22:59:28 <johnw> Zemyla: i.e., lax monoidal functors
23:21:55 <dacto> with ReadP, is there a way to prefer the result that contains more optional parses than the rest?
23:27:31 <jle`> readp is kind of weird because although the type has the opportunity for optional parses, i don't think any of the combinators actually ever return more than one option
23:28:37 <pukey420> US Election Party Mon. 11/5/18 23:59
23:29:14 <Axman6> @where ops
23:29:14 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
23:29:34 --- mode: ChanServ set +o dibblego
23:29:41 --- mode: dibblego set +b *!*@71-92-120-45.dhcp.knwc.wa.charter.com
23:29:43 --- kick: pukey420 was kicked by dibblego (pukey420)
23:29:45 --- mode: ChanServ set -o dibblego
23:29:49 <Axman6> Thanks mate
23:29:53 <dibblego> np
23:31:56 <Zemyla> jle`: That's because it has to maintain backwards compatibility with all the code that uses ReadS.
23:33:01 <Zemyla> Also, many returns 0-n options.
23:36:08 <dacto> There are several parses that are "correct" but the one containing the most optional pieces is most correct. So far i've resorted to not using RP.option and instead using left bias with the different combinations..seems like there is a better way
23:38:15 <dacto> and RP = ReadP  :)
23:51:27 <Spaceman77> Hello! I know that function monoids are binary, associative functions with an identity element
23:51:33 <Spaceman77> But what is a monoid value?
23:51:43 <koz_> Spaceman77: I don't understand your question.
23:51:51 <Ariakenom> % :t (<>)
23:51:51 <yahb> Ariakenom: Semigroup a => a -> a -> a
23:51:59 <Ariakenom> % :t mempty
23:51:59 <yahb> Ariakenom: Monoid a => a
23:51:59 <jle`> hm, it might be referring to values of your monoid type
23:52:04 <Axman6> s/Semigroup/Monoid
23:52:16 <jle`> so String is a Monoid, so "hello", "world", etc. are values
23:54:39 <Axman6> Spaceman77: a Monoid is a set of thre things: a type, a binary associative function which takes type -> type -> type, and an identity value of that type. Examples would be (Bool,(&&),True), (Int,(+),0). the term 'function monoids' doesn't make much sense to me
23:54:44 <Axman6> three*
23:56:46 <Spaceman77> Yeah, i guess i am confisung monoids with functions that have those three things.
23:57:04 <Spaceman77> confusing*
23:57:50 <Spaceman77> What would one call a monoid?
23:58:34 <Ariakenom> note that a function is a value too
23:58:42 <Axman6> technically I believe it's the combination of those three things, but people might say Bool is a monoid (though not a Haskell Monoid, because there are a few ways to make Bools monoids and we would have to pick one)
