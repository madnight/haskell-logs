00:00:00 <Axman6> list has a Monoid instance, so we can say "list is a Monoid" (as in, a Haskell Monoid)
00:01:47 <kosmikus> _deepfire: not sure what you mean by not handling sums. do you mean why it cannot compute prisms? 
00:05:09 <Spaceman77> So a monoid is a certain context involving certain function and property types?
00:05:38 <Spaceman77> type properties*
00:11:38 <jle`> Spaceman77: i wouldn't really call it a 'context', because that doesn't really have any meaning
00:11:51 <tdammers> not quite. A monoid (in theory) is just a tuple of these things: a type (or set, same thing if you squint a little), a binary operation on values of that type, and one "zero" element of that type
00:12:00 <tdammers> e.g., (Int, (+), 0) is a monoid
00:12:08 <johnw> and the laws
00:12:15 <jle`> in general a monoid is some set along with an associated function/operation, where that operaiton has certain properties
00:12:17 <tdammers> right, yes, the laws must be met
00:12:22 <johnw> algebra = carrier, operations, laws
00:12:55 <tdammers> but also (String, (++), ""), (a -> a, (.), id), and a bunch of other things
00:13:45 <Ariakenom> I'd say (Monoid [a] => X) is a context for X
00:14:38 <Ariakenom> depends on if we're talking Haskell Monoid or math monoid. not sure if that was made clear
00:14:49 <tdammers> in Haskell, we don't express monoids as triples though; instead, we insist that each type can be part of no more than one monoid, so that we can define it as a typeclass; and then the binary operation and the neutral element are picked based on the type, that is, the typeclass says '"the" monoid for this type uses this as the binary operation and that as the neutral element'
00:15:01 <Ariakenom> well (Monoid a => X) makes more sense
00:15:10 <tdammers> so yes, the distinction between monoids in Math, and Monoid the Haskell typeclass, matters
00:21:36 <dminuoso> tdammers: by convention we do express them as triples though. I mean we make newtype wrappers to express the third part of the tuple - the set.
00:21:49 <dminuoso> Dont we?
00:24:22 <Ariakenom> well a newtype isn't a triple
00:24:58 <jle`> the implementation in ghc is kinda like a triple
00:25:16 <jle`> not that that's too important
00:25:26 <Ariakenom> or rather. an instance has more structure than a triple, the type is special
00:43:44 <Lycurgus> trivially, because every non monad (as a (fuzzy) linguistic variable) is the product of at least two other things
00:47:04 <warrshrike> guys you have the following change in register 
00:47:07 <warrshrike> .01, .05, .10, .25, .50, 1, 2, 5, 10, 20, 50, 100
00:47:10 <warrshrike> given a change amount, either give proper chance (i.e. 2, .50 for 2.5 in change) or say not possible
00:47:12 <warrshrike> now i know we can easily bruteforce this 
00:47:15 <warrshrike> but what is a more efficient way to do this
00:55:51 <bahamas> hello. I'm noticing a pattern and I'm curious about the reasoning. I see that the EitherIO type here has the record field called `runEitherIO`. I've seen this pattern of calling the field `runSomething`. why is the word 'run' used?
00:59:14 <dminuoso> bahamas: consider State s a = State { runState :: s -> (s, a) }
01:00:05 <dminuoso> bahamas: It's only convention though. Sometimes people use `un` to denote the "unwrapping"
01:00:26 <dminuoso> bahamas: `run` seems to be preferred when the act of unpacking is done in order to apply a function/run an IO effect/something along those lines.
01:02:07 <bahamas> dminuoso: I see. I was also thinking that "un" would be more appropriate, but using "run" when the type is a function makes sense
01:07:11 <Zemyla> dminuoso: I like to use un for the type itself and run for the interaction which produces the user-visible results, since the types tend to be complicated internally.
01:07:45 <Zemyla> I think my record was three nested foralls.
01:36:44 <jle`> 'get' is also a pretty common pattern
01:36:54 <jle`> data Sum a = Sum { getSum :: a }
01:37:29 <phadej> unwrap
01:37:49 <phadej> appEndo is a alone with its prefix
01:38:22 <phadej> @src Const
01:38:22 <lambdabot> Source not found. stty: unknown mode: doofus
01:38:28 <phadej> :/
01:39:44 <phadej> getConst, getCompose but runIdentity - there probably is some logic
01:40:24 <phadej> (Const and Compose aren't Monads, Identity is)
01:42:46 <geekosaur> probably about as much logic as Control vs. Data >.>
01:49:21 <bahamas> why am I getting a syntax error with this code? https://gist.github.com/LucianU/eb8ddbb1c0581c00f2356176d8035511 the error complains about the closing parenthesis after `T.getLine`
01:50:23 <bahamas> if I bring the parenthesis on the same line with T.getLine, the error goes away
01:51:11 <Janta> On https://github.com/tweag/capability this type signature is mentioned: twoStates :: (HasState "a" Int m, HasState "b" Int m) => m ()
01:51:27 <Janta> Are "a" and "b" here types? Using an extension that allows to use string literals?
01:51:30 <phadej> bahamas: you need to indent closibg parens more
01:51:32 <geekosaur> because it's indented to the level of the do, so is treated as a separate expression there
01:51:46 <geekosaur> you don't get 100% freeform, indentation matters
01:52:02 <phadej> Janta: yes, DataKinds
01:53:02 <Janta> That was what I was looking for, danke.
01:53:50 * hackage hw-streams 0.0.0.1 - Primitive functions and data types  http://hackage.haskell.org/package/hw-streams-0.0.0.1 (haskellworks)
01:54:43 <bahamas> then the identation in this article is wrong https://two-wrongs.com/a-gentle-introduction-to-monad-transformers
01:54:45 <bahamas> indenting the parens a little also made it work
02:00:38 <Janta> What is `@` in `@k` doing here? https://github.com/tweag/capability/blob/master/examples/WordCount.hs#L39
02:00:56 <koz_> Janta: Type application.
02:01:05 <koz_> Look up the TypeApplications extension if you want more info.
02:02:42 <Janta> got it
02:23:11 <jle`> appEndo is probably just a pun on append in a "presto appendo" sort of way
02:23:35 <koz_> jle`: Your blog breaks in Firefox's reader view.
02:23:40 <koz_> (specifically all code sections turn invisible)
02:23:52 <jle`> hmm, thanks, i'll try to investigate
02:24:04 <koz_> It's not just you - Hackage has this issue as well I think.
02:24:17 <jle`> i originaly designed it to work with some specific reader view things
02:24:21 <jle`> i wonder what is going on with firefox
02:24:35 <jle`> that was about 5 years ago though, so a lot has changed on the web since then
02:24:38 <koz_> I'm on 63 if that's any indication.
02:24:46 <koz_> (i.e. the latestest)
02:24:58 <koz_> Hackage mega-super-breaks with that view as well.
02:25:45 <koz_> (as does Stackage)
02:26:29 <koz_> As a complete aside, I decided to try and give massiv the vector-sized treatment.
02:26:35 <koz_> It's... harder than it looks.
02:26:40 <phadej> fwiw, code goes away in reader mode in firefox in my blog as well
02:26:42 <phadej> oh dear
02:27:01 <koz_> phadej: What stack does your blog use?
02:27:05 <phadej> so if jle` finds a reason (and solution) please share
02:27:08 <phadej> koz_: hakyll
02:27:36 <koz_> Could be a Hakyll issue. Is there another blog I can test?
02:28:00 <koz_> Since I think jle`'s blog uses Hakyll too.
02:28:16 <jle`> it's always weird when software doesn't work well with displaying code and stuff like this...presumably the people who develop these things are also regular consumers of displayed code
02:28:42 <jle`> i use hakyll, but i don't think that should make a difference, since hakyll doesn't generate any of my html or css
02:28:47 <koz_> jle`: It might just be one of those weird corner cases.
02:29:04 <jle`> i'm talking in general, there are a lot of reader apps that don't display any code well at all
02:29:14 <koz_> My blog has no issues with Firefox's reader mode, but I use Pelican.
02:29:29 <phadej> well, hakyll (or pandoc) code block markup is somewhat involved
02:29:42 <phadej> reader shows the blocks without syntax highlighting
02:30:05 <koz_> On jle`'s blog, they're not even visible in reader mode.
02:30:21 <jle`> hm, yeah, it could conceivably be a pandoc thing
02:30:26 <koz_> I don't mind lack of syntax highlighting - for small snippets it hardly matters - but not being visible at all isn't a good thing.
02:30:47 <jle`> but the generated markup is pretty simple
02:30:50 <phadej> and e.g. http://oleg.fi/gists/posts/2018-06-21-colors-in-lhs2tex.html doesn't offer reader view at all  :(
02:31:35 <koz_> jle`: Let me check how Pelican does the code blocks on my blog.
02:31:40 <jle`> <div class="sourceCode"> <pre class="sourceCode"> <code class="sourceCode"><a class="sourceLine"> ... </a> ...
02:31:42 <phadej> http://oleg.fi/gists/posts/2018-06-19-prisms-are-constructors.html is a post with both highlighted and not code blocks.
02:32:11 <jle`> maybe firefox reader hides <code> tags
02:33:32 <koz_> jle`: This is the way code blocks get generated on my blog: http://paste.debian.net/1049103/ 
02:33:39 <koz_> Can confirm that this works fine in reader mode.
02:33:54 <jle`> hm yeah, two differences
02:34:18 <phadej> jle`: non highlight code block is <pre><code>
02:35:06 <phadej> does firefox have some way to investigate why reader mode is rendered as it is?
02:35:17 <koz_> phadej: Your guess is as good as mine on that one.
02:35:23 <koz_> I dunno how Firefox does much of anything.
02:35:28 <jle`> two differences seem to be that pandoc generates code in <code> .. </code>, and that lines are <a>, with spans for tokens within a line; on your blog there is no <code> and it uses <span> for entire lines
02:35:44 <koz_> jle`: Pelican uses Pygments for its code blocks.
02:36:15 <koz_> So probably you're right in that reader mode hides <code>?
02:36:38 <phadej> it doesn't always.
02:36:48 <phadej> non highlighted  blocks are visible
02:36:54 <phadej> see http://oleg.fi/gists/posts/2018-06-19-prisms-are-constructors.html
02:37:17 <phadej> (appendix: coq code block is shown, and it's <pre class="coq"><code>....)
02:37:36 <jle`> hm, i don't have firefox installed atm to test
02:37:40 <phadej> also inline <code>indentifier</code> are shown
02:37:50 <jle`> but does firefox have a DOM inspector mode like chrome, where you can go in and make ad-hoc changes?
02:37:55 <jle`> and see the changes reflected in real time?
02:38:37 <koz_> jle`: I think so?
02:38:45 <koz_> Never tried anything like that though.
02:39:22 <jle`> hm, it be the <a> tags then, comparing the different blocks on phadej's post
02:39:58 <jle`> pandoc uses <a> to delimit lines, and <span> to delimit tokens within a line
02:40:20 <phadej> changing a to span doesn't help :/
02:40:29 <jle`> s/pandoc/kate or skylighting
02:40:44 <phadej> no it does
02:40:46 <jle`> hm, i'm probably going to head to bed, but thanks for the heads up
02:40:49 <phadej> ok, a -> span might work
02:41:02 <phadej> but all a's have to be changed
02:41:17 <phadej> hmm...
02:41:22 <alexelcu> I installed the Haskell Core Platform, but I believe that GHC 8.4.3 is too new — because now the stable Emacs Intero plugin complains about it ...
02:41:34 <alexelcu> https://www.irccloud.com/pastebin/PgzNYCCD/intero.log
02:42:23 <koz_> phadej: Thanks for pointing me at  your blog by the way.
02:42:25 <alexelcu> should I uninstall Haskell Platform or upgrade the intero plugin to the unstable version? WDYT?
02:42:29 <koz_> It's got some very interesting stuff on it.
02:42:37 <jle`> hm yeah, then that's up to skylighting http://hackage.haskell.org/package/skylighting-core-0.7.4/docs/src/Skylighting.Format.HTML.html
02:42:42 <phadej> koz_: thanks :)
02:42:56 <jle`> unfortunate that firefox hides these. it could be tweaked on-the-fly with js, but that probably won't affect reader mode
02:43:21 <jle`> hm ah. the reason skylighting uses <a> is to enable things like line numbers
02:43:47 <phadej> anchors?
02:44:23 <phadej> they work without `name` too
02:44:31 <phadej> I mean <span id="anchor"> works fine too
02:45:06 <jle`> presumably <a> instead of <span> is for semantic web reasons
02:45:23 <phadej> not semantic enough (shouldn't _Semantic_ work well in reader :)
02:45:50 <jle`> i mean, it might be that the reader is misinterpreting the semantics, heh
02:45:56 <jle`> or, someone is
02:46:07 <jle`> either skylighting is or the reader is, or the semantics aren't clear to both parties
02:46:47 <jle`> what if you had href's to the anchors?  skylighting has an option to add href's to the anchor tags, that's the only configuration w.r.t. the line formatting they offer
02:47:20 <jle`> might install and check tomorrow :)
02:47:29 <phadej> arg, and firefox doesn't offer reader for local file://
02:53:51 * hackage http-client-openssl 0.3.0.0 - http-client backend using the OpenSSL library.  http://hackage.haskell.org/package/http-client-openssl-0.3.0.0 (alexbiehl)
02:57:30 <phadej> koz_: could you try my blog again?
02:58:25 <koz_> phadej: This page works now: http://oleg.fi/gists/posts/2017-11-22-why-peano-and-not-typelits.html
02:58:34 <phadej> good
03:00:02 <koz_> So what was the issue?
03:00:19 <phadej> I changed a -> span in generated code blocks
03:00:19 <phadej> https://github.com/phadej/gists/commit/31dc16f3b219eca452f79f5a21ba7e5a6b2b7f9b
03:00:30 <phadej> a hacky way, but less hacky than JS
03:01:23 <koz_> Well, can confirm it works.
03:01:37 <koz_> I tried searching up 'how does reader work', but got nothing.
03:01:46 <koz_> (which isn't very good on Firefox's part)
03:01:53 <phadej> thanks for reporting the issue, anyway
03:01:58 <koz_> (or Mozilla's I guess)
03:02:04 <koz_> No problem - glad you could fix it so fast!
03:04:10 <phadej> there's no such thing a Traversal couldn't fix
03:05:11 <phadej> (maybe I should write about plated stuff, they are cool and mind bending, therefore a bit tricky to get around)
03:05:25 <koz_> phadej: Please do.
03:05:40 <phadej> :)
03:05:51 * hackage web3 0.8.0.0 - Ethereum API for Haskell  http://hackage.haskell.org/package/web3-0.8.0.0 (akru)
03:06:02 <koz_> Just read your Functor Optics.
03:06:22 <koz_> That was really interesting
03:07:04 <phadej> (for the record, I don't think I have written anything kmett & co haven't thought about; they just didn't blog about _everything_ they thought about)
03:07:31 <koz_> Yeah, well, Edward think of a lot of things.
03:07:50 <phadej> e.g. Functor optics "existed" before Profunctor optics, and latter came because former are tricky
03:08:39 <phadej> splitting the argument into two is a nice "trick"
03:19:21 * hackage structured-cli 2.2.0.0 - Application library for building interactive console CLIs  http://hackage.haskell.org/package/structured-cli-2.2.0.0 (erick)
03:42:51 * hackage canonical-json 0.5.0.0 - Canonical JSON for signing and hashing JSON values  http://hackage.haskell.org/package/canonical-json-0.5.0.0 (DuncanCoutts)
03:46:57 * hackage canonical-json 0.5.0.1 - Canonical JSON for signing and hashing JSON values  http://hackage.haskell.org/package/canonical-json-0.5.0.1 (DuncanCoutts)
04:00:49 <somewone> Hey guys I'm running into an `Incomplete(Size(1))` in Nom when parsing a file. It basically parses the whole file and I can not figure out for what reason this still fails, I have even added nom-trace. Any ideas what I am missing ?
04:02:04 <somewone> Sorry wrong channel ;)
04:05:28 <phadej> maybe using haskell is the solution to your problem ;)
04:05:35 <Dark_Ethereal> Ewww bracket function application
04:06:01 <Dark_Ethereal> Hey, does anybody here have experience using Persistant?
04:07:26 <Clint> no, i've only used persistent
04:08:01 <Dark_Ethereal> Dyslexia. Don't judge me!
04:09:31 * shapr yawns
04:10:00 <Dark_Ethereal> I'm trying to define an action that sets a field in a database if a record is there but fills in a default record and updates it if no record is found. It's not type checking yet I have no idea how to figure out what's wrong from the error it's giving me
04:10:14 <Dark_Ethereal> Here's the function and the error
04:10:16 <Dark_Ethereal> https://hastebin.com/ijoxekumic
04:15:19 <sun777> i never used this library and im very newb, but should you be using one of the extensions?
04:15:34 <sun777> `(Use GADTs or TypeFamilies to permit this)`
04:16:23 <lyxia> Dark_Ethereal: or pick a concrete backend
04:17:49 <lyxia> the error is saying upsertUser has type  ... => Int64 -> ... -> ReaderT backend m ()   but you need an extension to accept the inferred constraint
04:18:10 <lyxia> you can either enable the extension, or specialize backend so you don't need the constraints
04:18:20 <Dark_Ethereal> sun777: I think I've tried that. In my experience those recommendations are usually wrong unless you're expecting them.
04:19:31 <sun777> welp luckily someone else is here this early
04:20:43 <Ariakenom> hi american
04:21:38 <Dark_Ethereal> lyxia: that looks like it might have done it
04:22:02 <Dark_Ethereal> Now I've got type errors that look actually intelligable!
04:22:20 <Dark_Ethereal> or intelligible
04:22:57 <Dark_Ethereal> English... what a trash language...
04:24:36 <Dark_Ethereal> gets you used to the -able suffix, then pulls the rug out from underneath you when you get comfortable.
04:25:31 <hpc> comfortible? :P
04:25:56 <Ariakenom> Dark_Ethereal: you just need to apply some tough thorough thought though
04:38:59 <buiweht> ghc.EXE: C:\sr\snapshots\cd07658e\lib\x86_64-windows-ghc-8.0.2\text-icu-0.7.0.1-49UrgfAmcU4m7qvgxZmfr\HStext-icu-0.7.0.1-49UrgfAmcU4m7qvgxZmfr.o: unknown symbol `ucnv_getMaxCharSize_62'
04:39:32 <buiweht> Could anybody help me resolve this error on windows?
04:40:11 <phadej> try to remove C:\sr\snapshots\cd07658e\lib\x86_64-windows-ghc-8.0.2\text-icu-0.7.0.1-49UrgfAmcU4m7qvgxZmfr\ folder and try again
04:41:43 <buiweht> doesn't work
04:41:57 <phadej> same error?
04:42:12 <buiweht> this text-icu package was installed and worked well on windows 7 but giving me that error on windows 10
04:42:27 <buiweht> ghc.EXE: addDLL: HStext-icu-0.7.0.1-49UrgfAmcU4m7qvgxZmfr (Win32 error 126): The specified module could not be found.
04:43:53 <buiweht> Do I have use any other alternative to text-icu? If so, any suggestion would be great.
04:46:43 <phadej> did you started from scratch on win10?
04:47:40 <phadej> if you need ICU, then I'm afraid there's no other option than to figure out why things don't work together
04:47:47 <phadej> but windows is tricky :/
04:48:23 <phadej> one option is to remove C:\sr and start from very beginning
04:49:17 <buiweht> Right. I will try. Thanks.
05:05:09 <Dark_Ethereal> Alright so I got the upsertUser function to typecheck, now I'm trying to make a generic version that can do the same thing to any record as long as you give it a function that makes the default instance... but I can't get it to typecheck ofc
05:05:11 <Dark_Ethereal> https://pastebin.com/7MyAxmAa
05:05:27 <Dark_Ethereal> I know there are constraints missing for `record`...
05:05:33 <Dark_Ethereal> I just don't know what they should be
05:07:14 <Dark_Ethereal> I just don't understand what these backend types mean...
05:12:31 <Dark_Ethereal> Wait, maybe I've got that the wrong way round... maybe I need to make the backend polymorphic and constrain it to backends that are compatible with the record?
05:13:08 <Dark_Ethereal> I'm going to learn how to use this stuff if it kills me!
05:13:40 <Dark_Ethereal> Does it count as killing me if I die of old age before I get it? Hmmmm
05:20:20 <Athas> How do I figure out why 'stack install' decides to unregister a bunch of dependencies and rebuild them?
05:20:42 <Athas> This is incredibly frustrating.
05:38:05 <dkasak[m]> Which version of stack?
05:38:31 <dkasak[m]> Might it be this? https://github.com/commercialhaskell/stack/issues/3899
05:39:49 <Athas> It's 1.9.1, which I think is pretty new.
05:43:45 <dkasak[m]> Yeah, that should be merged into 1.9.1.
06:02:33 <fen> when making a difference list from a list, or e.g. nonempty-list, if a polymorphic value cant be returned (e.g. empty list []) as the last value, it is tempting to return Nothing instead, as Maybe NonEmptyList is similar to List (isomorphic?) 
06:02:58 <fen> but, then the difference list should of values of type (Maybe a -> a)
06:03:03 <fen> and this is slower
06:03:23 <fen> than using undefined as the polymorphic value
06:03:24 <fen> https://bpaste.net/show/f391676f1672
06:03:49 <fen> which allows the difference list to still be over (a -> a)
06:03:51 <mlehmk> since a list is already a monadic thing, I would just use the empty list as such
06:04:36 <mlehmk> well, for the exception, that I want to differentiate between a list at all and actually nothing (not even a list at all, not even empty)
06:04:36 <fen> trying to find an approach that works for many traversable containers including nonempty list and list
06:05:06 <mlehmk> Maybe is very similar to a list that contains 0 or 1 elements
06:06:02 <fen> it just adds the datatype constructor with no values, the parameters of the datatype are discarded
06:06:34 <fen> its like () added as a sum type
06:07:02 <marvin2> sometimes Maybe [T] makes sense. for example, when fetching a list from a database, you may want to distinguish between no entry and entry containing an empty list
06:07:36 <mlehmk> well, () can be seen as a field that only has the identity value which is itself
06:07:50 <fen> no its, (Maybe a) or [a], not Maybe [a]
06:08:28 <mlehmk> I'd go with (Maybe a) then
06:08:42 <mlehmk> not knowing actually what you want to do though
06:08:54 <fen> its slower to have the difference list over (Maybe a -> a)
06:09:10 <fen> using Nothing as a replacment for [] is slower
06:09:34 <fen> instead, undefined can be used to replace [] as a polymorphic value 
06:09:44 <mlehmk> wait... you mean between [Maybe a] and [a]?
06:11:44 <fen> a list might not be able to return a value to make a difference list, while a nonempty list always can. however, a nonempty list might not return the rest (its tail) after having matched on its head value, while a list can always return [] as its tail, if it has a value to match on.
06:13:06 <fen> the point is that it seems to be faster to use undefined instead of [] to work with lists, instead of using Nothing to function like [] when working with nonempty lists
06:14:01 <fen> :t (:[])
06:14:02 <lambdabot> a -> [a]
06:14:38 <mlehmk> huh?
06:14:54 <fen> :t const (:[])
06:14:56 <lambdabot> b -> a -> [a]
06:15:34 <fen> the undefined needs to be discarded, instead of collapsing the difference list on []
06:16:10 <fen> the (:[]) is applied to the last value in the list and combined with cons to destroy the undefined
06:16:42 <fen> :t flip const (:[])
06:16:43 <lambdabot> c -> c
06:16:57 <fen> oh, nvm
06:17:57 <fen> see test2 of the paste
06:18:05 <fen> https://bpaste.net/show/f391676f1672
06:19:24 <mlehmk> I don't see the actual problem
06:20:13 <fen> how to make a difference from the values of an arbitrary container
06:20:25 <fen> that may or may not have something like an empty list
06:20:40 <mlehmk> then the type should be [a -> a] -> a -> a
06:21:11 <fen> right, but how would that work if there was no empty list?
06:21:51 <fen> thats why it ends up looking like ([Maybe a -> a] -> Maybe a -> a 
06:21:55 <fen> )
06:21:56 <mlehmk> if empty list means no difference, the result would be to be defined, like id
06:22:27 <fen> no the empty list is what the difference list is collaped onto
06:22:47 <fen> (really its [[a] -> [a]])
06:23:00 <fen> folded with foldr (.) []
06:24:05 <fen> but if its [Maybe [a] -> [a]] folded with 'foldr (\f b -> Just (f b)) Nothing', its slower
06:24:21 <fen> that is, when Nothing is used instead of [] as the basecase of the fold
06:24:37 <fen> for trying to work with nonempty lists
06:25:07 <mlehmk> for me it looks like you are doing function composition
06:25:22 <fen> and then its faster to use undefined instead, for both cases, and so instead of replacing the lack of [] for nonempty lists with Nothing, its better to discard [] for lists and use undefined
06:25:38 <fen> mlehmk: thats what difference lists are
06:25:41 <mlehmk> or at least do something that'd end up as function composition, which would have the type [a -> a] -> a -> a
06:25:58 <mlehmk> where given [] it'd return id
06:26:29 <fen> oh right. so its 'foldr (.) id xs undefined'
06:26:32 <fen> sorry
06:26:48 <mlehmk> huh?
06:26:53 <fen> so its not the basecase of the fold, but its the thing the folded difference list is applied to
06:27:16 <mlehmk> foldr (.) id xs
06:27:19 <fen> fastDifference :: [a -> a] -> a; fastDifference xs = foldr (.) id xs undefined
06:27:20 <mlehmk> not undefined
06:27:32 <mlehmk> :t foldr (.) id xs
06:27:33 <lambdabot> error:
06:27:33 <lambdabot>     • Variable not in scope: xs :: [b -> b]
06:27:34 <lambdabot>     • Perhaps you meant one of these:
06:27:58 <mlehmk> anyway... foldr (.) id xs would end as the type [a -> a] -> a -> a
06:28:25 <fen> that has type (a->a), which is actually ([b]->[b]) in this example
06:28:38 <mlehmk> no, [[b]] -> [b]
06:28:38 <fen> then that returned function is applied normally to []
06:28:57 <fen> :t \xs -> foldr (.) id xs
06:28:59 <lambdabot> Foldable t => t (b -> b) -> b -> b
06:29:14 <mlehmk> that is function composition
06:29:40 <fen> :t foldr (.) id [(:2),(:1),(:0)]
06:29:41 <lambdabot> error:
06:29:41 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ [b]
06:29:41 <lambdabot>       Expected type: b -> b
06:30:04 <mlehmk> :t foldr (.) id [(2+),(1+),(0+)]
06:30:05 <lambdabot> Num b => b -> b
06:30:20 <fen> :t foldr (.) id [(2:),(1:),(0:)]
06:30:21 <lambdabot> Num a => [a] -> [a]
06:30:30 <fen> > foldr (.) id [(2:),(1:),(0:)] []
06:30:32 <lambdabot>  [2,1,0]
06:31:01 <mlehmk> > foldr (.) id [(1+),(2+),(3+)] 0
06:31:03 <lambdabot>  6
06:31:15 <fen> > foldr (.) id [(2:),(1:),const (0:[])] undefined
06:31:17 <lambdabot>  [2,1,0]
06:31:21 <mlehmk> no
06:31:28 <fen> yes!
06:31:39 <mlehmk> that feels wrong again
06:32:14 <fen> its faster when using Nonempty lists, where otherwise you would be folding up [Maybe a -> a] and applying Nothing where [] and undefined were used above
06:32:21 * hackage opaleye 0.6.7003.0 - An SQL-generating DSL targeting PostgreSQL  http://hackage.haskell.org/package/opaleye-0.6.7003.0 (tomjaguarpaw)
06:32:29 <mlehmk> you don't even need to at all
06:32:42 <fen> ...
06:32:59 <ggVGc> when are we inventing a new SQL
06:33:09 <ggVGc> that fills the same uses cases. (e.g not no-sql)
06:33:18 <mlehmk> :t foldr (.) id mempty
06:33:19 <lambdabot> (Monoid (t (b -> b)), Foldable t) => b -> b
06:34:03 <hyperisco> ggVGc, I thought that was happening ad nauseum
06:34:23 <mlehmk> wait
06:34:28 <fen> mlehmk: nonempty lits are not monoids
06:34:32 <mlehmk> :t \xs -> foldr (.) id xs mempty
06:34:33 <fen> they lack memepty
06:34:34 <lambdabot> (Monoid b, Foldable t) => t (b -> b) -> b
06:34:36 <ggVGc> hyperisco: okay, point me to a successful one then
06:34:38 <mlehmk> that's what I meant
06:35:02 <mlehmk> > foldr (.) id [(2:),(1:),(0:)] mempty
06:35:04 <hyperisco> ggVGc, just count the number of languages which compile to SQL… I'll give you the weekend
06:35:05 <lambdabot>  [2,1,0]
06:35:16 <ggVGc> hyperisco: yeah, I meant a new SQL. Not a meta-sql
06:35:18 <fen> > mempty : [a]
06:35:18 <ggVGc> that's the point
06:35:20 <lambdabot>  [mempty,a]
06:35:25 <fen> !?
06:35:27 <hyperisco> ggVGc, what's the difference
06:35:29 <fen> > mempty :: [a]
06:35:32 <lambdabot>  []
06:35:43 <fen> there is not this for nonempty lists
06:35:49 <fen> that why Maybe is added
06:35:57 <hyperisco> so you want a query language impossible to compile to SQL?
06:36:04 <fen> so that Nothing can act as mempty
06:36:15 <mlehmk> Nothing is mempty
06:36:20 <fen> right
06:36:26 <ggVGc> hyperisco: that SQL is not the only way to implement relational and queryable databases. An alternative to SQL that isn't just something that compiles to SQL would me new semantics for runtime implementaiton too
06:36:34 <mlehmk> Nothing is [] of a list that can contain at most 1 item
06:36:47 <fen> but using Maybe to wrap nonempty lists so they can be worked with like lists, its slow as the paste shows
06:36:53 <ggVGc> the NoSql stuff I've seen are basically kv-stores, afaik, which isn't relational
06:37:14 <fen> instead undefined should be used instead of [] and const used in the last value of the differnce list
06:37:23 <mlehmk> no
06:37:27 <fen> yes!
06:37:29 <fen> why not?
06:37:33 <fen> its faster
06:37:37 <mlehmk> that's the crux in thinking wrong about it
06:37:39 <ggVGc> hyperisco: yes, I think it's useful to revisit an idea from the ground up. Now that we know that things of SQL are very useful, we can take those and start from scratch, and avoid the things that make SQL implementation hard
06:37:44 <ggVGc> or inefficient
06:37:47 <mlehmk> you have a difference list of a -> a
06:38:00 <mlehmk> so the fold of that list results into a single value of a -> a
06:38:04 <ggVGc> what things*
06:38:09 <hyperisco> ggVGc, *shrug* I don't get it but I am sure you have some ideas
06:38:15 <mlehmk> function composition returns a function
06:38:21 <hyperisco> basically you're saying you don't want to use relational algebra anymore
06:38:48 <fen> but if it were a nonempty list it would be a difference list of [Maybe (Nonempty a) -> Nonempty a]
06:38:54 <fen> right?
06:39:15 <fen> and thats the slow form
06:39:24 <fen> one Maybe per value, v v slow
06:39:34 <hyperisco> ggVGc, for many computer programs I think it more practical to work on whole records rather than columns
06:39:41 <mlehmk> what are you just trying to reimplement, the Applicative or the Monad?
06:39:41 <fen> according to the paste, more than twice as slow
06:39:43 <fen> fastDifference :: [a -> a] -> a fastDifference xs = foldr (.) id xs undefined
06:39:45 <fen> oops
06:39:51 <fen> https://bpaste.net/show/f391676f1672
06:40:01 <hyperisco> ggVGc, and on relations of records
06:40:05 <fen> (that was still in the clipboard)
06:40:25 <hyperisco> ggVGc, but that has no reason to depart from an SQL backend
06:40:32 <mlehmk> I just see the applicative here
06:40:45 <fen> mlehmk: just trying to write a difference list for containers that may or may not be empty
06:40:59 <fen> and not use the slow version...
06:41:17 <mlehmk> can you define container?
06:41:29 <mlehmk> as I see difference list as a list of functions, not a list of containers
06:41:43 <fen> [Maybe [a] ->[a]] would work too, and [] wouldnt be used, Nothing would take its place
06:41:50 <Ariakenom> ggVGc: maybe this is interesting to you https://github.com/agentm/project-m36
06:42:08 <fen> but instead, the nonempty version should use undefined, and so should the list version
06:42:24 <hyperisco> ggVGc, I came up with something three years ago for that… you essentially defined a category where objects were records and morphisms were relations, and you could then query this category
06:42:34 <fen> mlehmk: the difference list is of functions over the container
06:42:41 <ggVGc> hyperisco: that does sound interesting
06:42:57 <mlehmk> so like [[a] -> [a]] -> [a] -> [a]
06:42:59 <fen> which are values drawn from it sequentially, partially applied to the constructor
06:43:25 <fen> :t [0:]
06:43:26 <lambdabot> error:
06:43:26 <lambdabot>     A section must be enclosed in parentheses thus: (0 :)
06:43:29 <hyperisco> ggVGc, I thought so anyways. It is interesting how joins work out, for example. I'd have to dig it all back up again though. Yet another project that never saw the light of day…
06:43:33 <fen> :t [(0:)]
06:43:34 <lambdabot> Num a => [[a] -> [a]]
06:43:52 <fen> :t [const (0:[])]
06:43:53 <lambdabot> Num a => [b -> [a]]
06:44:15 <mlehmk> forget const, that is your initial value, which should be the empty element
06:44:17 <fen> mlehmk: yes like that
06:44:34 <fen> there is no empty element!
06:44:54 <fen> and if you meant empty list, thats not available for NonemptyLists
06:46:02 <mlehmk> and with nonempty lists, you need a non-empty list as a starting point for the function
06:46:15 <mlehmk> thus your result will always be a -> a
06:46:28 <dmwit> I feel like somebody in this conversation is confused.
06:46:28 <hyperisco> ggVGc, my main motivation didn't come from GraphQL but GraphQL ends up being somewhat similar.
06:46:41 <mlehmk> dmwit, who is? You can be frank if it is me
06:46:51 <dmwit> The standard representation of a difference list is `[a] -> [a]`, not `[a -> a]`. Have we established some context for why we're not doing the standard thing?
06:47:56 <mlehmk> so, fmap x is a difference list?
06:47:56 <hyperisco> ggVGc, I should also mention that compose is join, of course.
06:48:01 <fen> dmwit: then whats [a -> a] ? its just an abstraction of the concept to arbitrary partially applied monoids 
06:48:28 <dmwit> I don't see why we can't have a difference NonEmpty with the same trick, `NonEmpty a -> NonEmpty a`. The eliminator for it just has a different type.
06:48:40 <fen> :t \x -> x `mappend` []
06:48:41 <lambdabot> [a] -> [a]
06:48:57 <dmwit> fen: But why involve a list at all? `Monoid a => a -> a` is a perfectly cromulent generalization and no lists to be seen anywhere.
06:49:01 <fen> what is this eliminator?
06:49:17 <dmwit> For difference lists, the eliminator is `($[])`.
06:49:19 <fen> dmwit: because nonempty list does not have mempty
06:49:29 <fen> :t ($[])
06:49:31 <lambdabot> ([a] -> b) -> b
06:49:35 <dmwit> Sure. So you can't use the eliminator that works for all monoids. So what?
06:49:36 <fen> :t ($mempty)
06:49:37 <lambdabot> Monoid a => (a -> b) -> b
06:49:42 <dmwit> You can use an eliminator that works for NonEmpty.
06:49:51 <fen> namely?
06:50:06 <fen> :t const . (:[])
06:50:07 <lambdabot> a -> b -> [a]
06:50:12 <fen> hmm
06:50:16 <fen> not that
06:50:19 <dmwit> \diffNonEmpty x -> diffNonEmpty (NonEmpty (x :| []))
06:50:36 <dmwit> s/NonEmpty//
06:50:44 <dmwit> :t (:|)
06:50:44 <fen> right, it needs the last value
06:50:45 <lambdabot> error:
06:50:45 <lambdabot>     • Data constructor not in scope: :|
06:50:45 <lambdabot>     • Perhaps you meant one of these:
06:50:57 <asheshambasta> What exactly is the purpose of `localLogger` here? https://hackage.haskell.org/package/monad-log-0.1.1.0/docs/Control-Monad-Log.html#t:MonadLog 
06:51:12 <fen> for simplicity these can be called "create" types
06:51:14 <asheshambasta> Is it somehow supposed to modify the logger contained within the monad? 
06:51:15 <fen> :t pure
06:51:16 <lambdabot> Applicative f => a -> f a
06:51:16 <dmwit> Sure. Or you could use `[a] -> NonEmpty a` as your difference NonEmpty, then it is the diffNonEmpty's responsibility to provide the first element.
06:51:18 <fen> :t return
06:51:19 <lambdabot> Monad m => a -> m a
06:51:39 <fen> a class just implementing something of that type could be called the Create class
06:51:55 <fen> class Create f where create :: a -> f a
06:52:09 <mlehmk> and first element is quite similar to the mempty again, or am I confused then?
06:52:18 <hyperisco> class Apply f <= Applicative f where pure :: a -> f a
06:52:35 <fen> its not quite the same as mempty, as it requires an actual value to be applied to
06:52:51 <hyperisco> if you want to see the hierarchy broken into more pieces, look at how PureScript did it
06:52:53 <fen> but (:[]) is an implementation of create for lists
06:52:58 <fen> :t (:[])
06:52:59 <lambdabot> a -> [a]
06:53:14 <mlehmk> turns a value into a list with just that value in it
06:53:18 <fen> so its easyest to work with create in all situations
06:53:23 <exarkun1> "cannot set breakpoint on MagicWormhole.withEncryptedConnection: module MagicWormhole.Internal.Peer is not interpreted" - how do I make it possible to set such a breakpoint?
06:53:30 <fen> as it can be used for both empty and nonempty lists
06:53:37 <hyperisco> fen, Create is not a good class unless you can state laws for it
06:53:39 <fen> but whats the eliminator then?
06:53:45 <dmwit> ?let type DiffNE a = [a] -> NonEmpty a
06:53:46 <lambdabot>  .L.hs:161:24: error:
06:53:46 <lambdabot>      • Expected a type, but ‘'NonEmpty a’ has kind ‘NonEmptyList a0’
06:53:46 <lambdabot>      • In the type ‘[a] -> NonEmpty a’
06:54:12 <fen> hyperesco: hmm, well the laws could be taken from Applicative..
06:54:24 <hyperisco> no because where is apply?
06:54:30 <fen> yeah exactly
06:54:44 <dmwit> ?let type DiffNE a = [a] -> Data.List.NonEmpty.NonEmpty
06:54:46 <lambdabot>  .L.hs:161:24: error:
06:54:46 <lambdabot>      Not in scope:
06:54:46 <lambdabot>        type constructor or class ‘Data.List.NonEmpty.NonEmpty’
06:55:07 <fen> ok, but you would still basically know whats meant if someone said "create" now right?
06:55:14 <dmwit> :k Data.List.NonEmpty.NonEmpty
06:55:15 <lambdabot> * -> *
06:55:17 <hyperisco> no I wouldn't
06:55:18 <dmwit> wut
06:55:39 <hyperisco> if you said Maybe was a Create for example I wouldn't know if I'd get Just or Nothing
06:55:45 <dmwit> exarkun1: one moment
06:55:47 <delYsid> Create sounds like Singleton to me.
06:55:55 <fen> maybe it would be better to write the laws in terms of a class just with extract
06:56:06 <fen> which is like an inverse
06:56:20 <fen> :t extract
06:56:21 <lambdabot> error: Variable not in scope: extract
06:56:26 <fen> % :t extract
06:56:26 <yahb> fen: Comonad w => w a -> a
06:56:27 <dmwit> exarkun1: https://stackoverflow.com/q/10838785/791604 I think (in short: interpret the library, not compile it)
06:57:12 <dmwit> hyperisco: How about `fold (create x) = x`? =)
06:57:28 <fen> well, it is Exactly an inverse, thats the defining law
06:57:40 <hyperisco> :t fold
06:57:41 <lambdabot> (Monoid m, Foldable t) => t m -> m
06:57:45 <fen> not sure if thats a mutual definition thought, maybe extract is only defined by the laws of Comonad
06:57:45 <dmwit> hyperisco: Still doesn't help you with `Writer Any`, I guess.
06:57:54 <dmwit> hyperisco: But then maybe that's okay.
06:58:50 <fen> anyway thats enough of a law probably
06:58:54 <hyperisco> dmwit, looks fine but I'm not sure what I'd like to do with that law
06:59:28 <dmwit> See? Now you must admit that your real objection is an aesthetic one. Which is fine, but you should say so from the beginning.
06:59:45 <hyperisco> what?
07:00:04 <dmwit> Ah, never mind. I've just got a dumb bee in my bonnet. I think people are much too strident about the "it's got no laws, it's no good" thing.
07:00:35 <fen> create is the opposite of extract, thats fine
07:00:51 <fen> it at least tells you what it does exactly
07:01:15 <hyperisco> the laws are all that a class is as an abstraction, it isn't a triviality
07:01:22 <dmwit> fen: Hm. I think you will get in trouble with that law, if your goal is to be able to use this on both lists and nonempty lists: [] isn't (can't be) a comonad.
07:01:35 <hyperisco> otherwise all you have is an overloaded function, which is fine but serves a different purpose
07:01:37 <fen> argh
07:01:45 <dmwit> Different than what?
07:02:05 <fen> whats extract on its own as a class defining function? which class does it define?
07:02:19 <dmwit> fen: Why does it matter? Lists can't support extract.
07:02:19 <fen> maybe the same problem of it being unlawful to do so
07:02:35 <fen> nonempty lists can
07:02:48 <dmwit> NonEmpty lists can support the whole Comonad infrastructure.
07:02:50 <dmwit> So no big deal.
07:03:01 <fen> ANYWAY
07:03:15 <fen> the point is to use create as the last element of the differnce list
07:03:20 <fen> along with const
07:03:25 <fen> to give it the right type
07:03:31 <fen> and then use undefined as theeliminator
07:03:57 <ruffy_> I want to get every n-th element of a list with this function (I found it on stackoverflow), but I always get the error error: Illegal tuple section: use TupleSections. Does anyone know the reason?
07:04:00 <ruffy_> unfoldr ((\x-> fmap (,drop m x) (listToMaybe x))) interval
07:04:06 <dmwit> fen: You don't like `type DiffNE = [a] -> NonEmpty a; diffNE :: DiffNE a -> NonEmpty a; diffNE = ($[])`?
07:04:23 <ruffy_> I want to get every n-th element of a list with this function (I found it on stackoverflow), but I always get the error error: Illegal tuple section: use TupleSections. Does anyone know the reason?
07:04:25 <ruffy_> unfoldr ((\x-> fmap (,drop m x) (listToMaybe x))) interval
07:04:28 <fen> :t [1:,const (return 0)]
07:04:29 <lambdabot> error:
07:04:29 <lambdabot>     A section must be enclosed in parentheses thus: (1 :)
07:04:35 <fen> :t [(1:),const (return 0)]
07:04:36 <lambdabot> Num a => [[a] -> [a]]
07:04:52 <hyperisco> dmwit, an overloaded function you're always going to use instantiated. It is just about sparing yourself the hassle of suffixing or prefixing a name for every type.
07:04:54 <dmwit> ruffy_: Have you tried following GHC's advice...?
07:05:05 <fen> > foldr (.) id [(2:),(1:),const (0:[])] undefined
07:05:07 <lambdabot>  [2,1,0]
07:05:10 <dmwit> hyperisco: Was that an answer to my question? If so, I don't understand the answer.
07:05:22 <ruffy_> dmwit: with this TupleSections?
07:05:24 <hyperisco> dmwit, maybe I don't understand your question
07:06:11 <dmwit> hyperisco: You say, "All you have is an overloaded function, which serves a different purpose.". But I don't know what the original purpose, which is different than the one overloaded functions serve, was.
07:06:34 <dmwit> ruffy_: Yes.
07:06:44 <dminuoso> Im not quite sure what "a typeclass is only useful if you have laws for it" intends to accomplish.
07:07:02 <ruffy_> Im not quite sure how to do this
07:07:22 <dmwit> ruffy_: Call the compiler with `-XTupleSections` or add `{-# LANGUAGE TupleSections #-}` to the top of the module.
07:07:26 <hyperisco> the other purpose is to use the function not instantiated, i.e. in its abstract form, which means you only have the laws to go by
07:07:55 <dmwit> Why is that the canonical purpose of a typeclass?
07:08:26 <hyperisco> it was immediately obvious what sort of class fen was trying to make
07:08:57 <dminuoso> Im pretty sure the canonical purpose of a typeclass is *overloading*
07:09:03 <ruffy_> dmwit: th, this soled my issue :D
07:09:12 <dminuoso> At least that's how SPJ phrased it a few times.
07:09:52 <hyperisco> I gave a specific meaning for what I meant by overloading
07:10:07 <dmwit> I can't make head or tails of "what sort of class fen was trying to make". What sort of class was fen trying to make?
07:10:16 <hyperisco> dmwit, one with laws :)
07:10:24 <dminuoso> Why does a typeclass need laws?
07:10:27 <fen> dmwit: no, i do not like that, its totally wrong! its supposed to return a Nonempty a 
07:10:32 <fen> :t ($[])
07:10:34 <lambdabot> ([a] -> b) -> b
07:10:42 <dmwit> Why is that obvious? And if it was obvious, why did you need to ask what the laws were?
07:10:42 <__monty__> Not, ad-hoc polymorphism?
07:10:48 <dmwit> fen: It *does* return a NonEmpty a.
07:10:52 <fen> oops
07:11:31 <mlehmk> all you actually need it difference lists as [a] -> NonEmpty a
07:11:40 <dmwit> mlehmk: That was my suggestion above. =)
07:12:17 <mlehmk> or at least a function composition like (.) that takes (NonEmpty a -> NonEmpty a) -> (NonEmpty a -> NonEmpty a) -> [a] -> NonEmpty a
07:12:20 <fen> nargh, thats the same as using Nothing as [] for NonemptyList
07:12:21 <hyperisco> dminuoso, I explained that above with dmwit if you'd like to go back
07:12:38 <fen> might as well use undefined
07:12:49 <fen> at least it will throw an error then
07:12:51 <hyperisco> dmwit, I know it when I see it. Spidey sense :)
07:12:52 <dmwit> hyperisco: s/explained/asserted/ =)
07:12:59 <fen> if the last ellement ist const . create
07:13:06 <hyperisco> didn't say I convinced you of everything. Obvious that I haven't.
07:13:09 <mlehmk> it won't be const . create
07:13:32 <mlehmk> what you compose will always be a function, that will prepend to a nonempty
07:13:43 <hyperisco> also mysterious to me why people would be fervently against type class laws
07:13:50 <mlehmk> So a set of difference lists need a nonempty as the rightmost
07:13:58 <fen> :t [(1:),const (return 0)]
07:13:59 <lambdabot> Num a => [[a] -> [a]]
07:14:10 <fen> ok, const . create applied to a value ...
07:14:22 <dmwit> hyperisco: I'm not against them. I'm against blindly rejecting classes that don't have them.
07:14:24 <mlehmk> so, in the end you composition of multiple difference lists will be [a] -> NonEmpty a, so that it can work
07:14:41 <dminuoso> hyperisco: Looking at "Type Classes in Haskell" by Hall, Hammond, SPJ and Wadler I dont see much about laws really.
07:14:45 <hyperisco> well I didn't roll a die to figure out if I should reject Create ;)
07:15:08 <dmwit> I agree. Instead, you blindly rejected it because it doesn't have class laws.
07:15:12 <dmwit> ...to which I object.
07:15:15 <hyperisco> exactly
07:15:46 <fen> no its fine to want the laws, but its just hard to give them if defining it as the inverse of a class just having extract is a mutual definition 
07:15:48 <Ariakenom> % randomIO :: IO Bool
07:15:48 <yahb> Ariakenom: True
07:16:12 <hyperisco> it isn't "blind" to reject it because it doesn't have class laws
07:16:38 <fen> its just saying its not immidiatly clear what it should do
07:16:41 <hyperisco> you might as well say it is blind to reject a car purchase because it doesn't have wheels or an engine
07:16:43 <dmwit> hyperisco: Could there be any redeeming quality which would lead you to accept a class that had no laws? If not, then it is blind.
07:16:53 <fen> but perhaps thats not a requirement, other than being of the desired type
07:16:57 <dmwit> hyperisco: Yes, I will blindly reject a car with no engine.
07:17:00 <hyperisco> but it has shiny hub caps!
07:17:06 <fen> in which case you just say, no laws.
07:17:40 <dmwit> (Hm. Now that I say it, I wonder if it's true. If you offered me a Ferrari with no engine for $1, I might take it!)
07:17:58 <fen> but in this case, it does have the normal laws of pure and return and is the opposite of extract, but then it gets all complicated because duplicate and join are not nesacarily available for use in these laws!
07:18:05 <fen> anyway this is all very clear
07:18:13 <hyperisco> point is that it is missing the features that make it useful in the first place
07:18:21 * hackage hw-streams 0.0.0.2 - Primitive functions and data types  http://hackage.haskell.org/package/hw-streams-0.0.0.2 (haskellworks)
07:18:21 <hyperisco> so it isn't blind, it is evidenced
07:18:48 <fen> okok
07:19:25 <fen> feynmans ferrari 
07:20:09 <hyperisco> now if you said you want a bunch of type names in scope that all need a create-like operation but you really don't want to come up with umpteen renamings of "create", then go ahead, that's the overloading use
07:21:06 <shapr> I want to hear more about edwardk's idea for first class type class laws
07:21:13 <hyperisco> it doesn't come up a lot because qualified imports are typically reasonable
07:21:16 <fen> but why are you talking about "what is it to be a typeclass" instead of this fancy new difference list deconstruction of pottentialy nonempty containers...
07:21:56 <dmwit> I don't think it has ever been important to me to guarantee that a list was nonempty. Maaaaybe once.
07:22:17 <fen> free nonempty is way better than free list
07:24:37 <fen> its a rose tree 
07:24:41 <mlehmk> what about this
07:24:42 <mlehmk> > init $ foldr (.) id [(3:),(2:),(1:)] [undefined]
07:24:44 <lambdabot>  [3,2,1]
07:24:46 <fen> while free list could have empty leaves
07:25:17 <fen> how slow are you trying to be!?
07:25:27 <fen> actually maybe that fusions up nicely
07:25:27 <mlehmk> init shouldn't be slow
07:26:18 <hyperisco> @remember fen how slow are you trying to be!?
07:26:18 <lambdabot> I will never forget.
07:26:27 <fen> ffs!
07:26:56 <hyperisco> command should be called @quotemine instead
07:27:14 <fen> whats wrong with doing it this way? https://bpaste.net/show/f391676f1672
07:28:21 <mlehmk> cause you want to compose difference lists, which would be [[a] -> [a]] -> [a]
07:28:39 <mlehmk> or in your special case a [NonEmpty a -> NonEmpty a] -> NonEmpty a
07:28:44 <fen> right, thats the fast version, with the const . create at the end
07:29:10 <mlehmk> the thing is, function composition is actually [a -> a] -> a -> a
07:29:50 <mlehmk> so, you combine difference lists into a single difference list first [[a] -> [a]] -> [a] -> [a]
07:29:53 <fen> well then its just const at the end
07:30:11 <mlehmk> then you need an initial value for the end, which could be nonEmpty [undefined]
07:30:39 <mlehmk> and init will make sure that element is removed
07:30:49 <fen> or create undefined which would work also for NonEmpty
07:30:54 <mlehmk> exactly
07:31:07 <mlehmk> init $ difflist (create undefined)
07:31:42 <fen> but that requires the user to define the build fold fusion
07:32:01 <mlehmk> or you build the fold for it
07:32:16 <fen> while the const at the end wont be slow
07:32:34 <fen> :t init
07:32:35 <lambdabot> [a] -> [a]
07:32:46 <fen> so that would need to be defined using fold
07:32:59 <fen> and it better fuse
07:33:24 <fen> seems more spec than just using const at the end
07:33:29 <mlehmk> your fold would actually be: fold xs = init $ foldr (.) id xs [undefined]
07:33:42 <mlehmk> uhm... not exactly
07:33:49 <mlehmk> I know it's fold f xs
07:34:02 <fen> init $ foldr (.) id xs [undefined]
07:34:14 <fen> polyInit $ foldr (.) id xs (create undefined)
07:34:28 <fen> :t foldr1
07:34:30 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
07:34:35 <fen> no?
07:34:55 <fen> argh this is getting confused
07:35:19 <fen> trying to mash the init into the foldr
07:35:44 <MarcelineVQ> whatchudoin
07:36:00 <fen> MarcelineVQ, see this; https://bpaste.net/show/f391676f1672
07:37:14 <hyperisco> 0.02s vs 0.05s?
07:37:15 <fen> the idea is that instead of creating a fake empty for nonempty lists, the empty list should not be the thing the difference list acts on, instead const.create is used for the last difference in the difference list and undefined is a polymorphic thing the difference list can be applied to after its folded
07:38:20 <fen> the alternative surgestion is just to use create undefined as the "target" and use fuse with init to discard it
07:38:51 <hyperisco> I'd be interested to know the application in which this 2.5x difference is significant
07:39:17 <fen> whenever trying to make a difference list from a nonempty container
07:39:19 <mlehmk> if that 2.5x difference is significant, I'd use [a] instead of NonEmpty a
07:39:33 <fen> but free nonempty is better than free list
07:39:48 <fen> motivating its significance
07:40:11 <mlehmk> you are effectively creating a void empty nonempty here
07:40:17 <noipmups> What is the shortest way to concat list of triples? I'm looking for function f :: [([a], [b], [c])] -> ([a], [b], [c]).
07:40:52 <mlehmk> wouldn't concat be a -> a -> a?
07:41:32 <fen> the idea is that nonempty is like list when combined with maybe, but thats slower than making list like nonempty by not using []
07:41:59 <fen> and instead using create, which is easily implemented for []
07:42:13 <fen> and NonEmpty
07:42:30 <fen> :t zip3
07:42:30 <hyperisco> :t foldr (\(xs',ys',zs') (xs,ys,zs) -> (xs'++xs, ys'++ys,zs'++zs)) ([],[],[])
07:42:31 <lambdabot> [a] -> [b] -> [c] -> [(a, b, c)]
07:42:32 <lambdabot> Foldable t => t ([a1], [a2], [a3]) -> ([a1], [a2], [a3])
07:42:41 <fen> :t unzip3
07:42:42 <lambdabot> [(a, b, c)] -> ([a], [b], [c])
07:43:12 <fen> noipmups: ^
07:43:54 <fen> MarcelineVQ: does that make sense?
07:44:04 <mlehmk> a function like [a] -> a looks like a fold to me
07:45:18 <fen> :t mconcat
07:45:19 <lambdabot> Monoid a => [a] -> a
07:45:30 <fen> % :t extract
07:45:30 <yahb> fen: Comonad w => w a -> a
07:46:24 <hyperisco> > ([1,2],[3,4],[5,6]) <> ([7,8],[9,10],[11,12])
07:46:26 <lambdabot>  ([1,2,7,8],[3,4,9,10],[5,6,11,12])
07:46:30 <hyperisco> oh jolly good
07:47:42 <hyperisco> > fold [("hello ", "greetings ", "heya "),("sailor!", "mam.", "pal!")]
07:47:44 <MarcelineVQ> hyperisco: that does make it easier
07:47:45 <lambdabot>  ("hello sailor!","greetings mam.","heya pal!")
07:48:05 <hyperisco> I like it when a problem comes together in a four character solution
07:50:31 <noipmups> Wat?! Thanks everyone.
07:51:46 <MarcelineVQ> the monoid of my monoid is a monoid
07:51:49 <MarcelineVQ> fen: what's the original task which ended up in creating the paste?
07:52:34 <mlehmk> concatening difference lists
07:52:50 <mlehmk> and folding it into a final list, but the lists are supposed to be NonEmpty
07:58:51 * hackage haskoin-store 0.4.2 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.4.2 (xenog)
08:00:47 <mlehmk> the problem is, to fold difference lists the result is another difference list, if you have no empty value, the list cannot be finite
08:01:33 <mlehmk> > fold (.) [(2:),(1:),(0:)] mempty
08:01:35 <lambdabot>  error:
08:01:35 <lambdabot>      • Couldn't match type ‘t0 -> b0’ with ‘[[Integer] -> [Integer]]’
08:01:35 <lambdabot>        Expected type: (b0 -> t) -> [[Integer] -> [Integer]] -> t0 -> t
08:01:43 <mlehmk> I need to learn more Haskell
08:01:54 <c_wraith> the base case is id, not mempty
08:02:08 <mlehmk> I want to avoid giving a base case
08:02:40 <c_wraith> then what would it return if given 0 difference lists to fold?
08:02:52 <mlehmk> like I just want [(2:),(1:)] to be (2:(1:))
08:03:12 <c_wraith> well, that's a type error...
08:03:19 <mlehmk> haha... good question actually
08:03:39 <c_wraith> I mean, that question is why there is a base case. :)
08:03:48 <mlehmk> I see, so fold returns the initial condition, but only if the list is empty?
08:04:34 <fen> > fold (.) id [(2:),(1:),(0:)] mempty
08:04:36 <lambdabot>  error:
08:04:36 <lambdabot>      • Could not deduce (Monoid t0)
08:04:36 <lambdabot>        from the context: (Monoid t1, Monoid t, Num a,
08:04:36 <c_wraith> well, fold doesn't. it will always use the base case. but you could theoretically write some variant that doesn't always use it.
08:04:47 <hyperisco> > fold [a,b,c,d,e]
08:04:49 <lambdabot>  a <> b <> c <> d <> e <> mempty
08:04:55 <fen> > foldr (.) id [(2:),(1:),(0:)] mempty
08:04:57 <lambdabot>  [2,1,0]
08:05:10 <hyperisco> the secrets are revealed
08:05:36 <mlehmk> > fold [(2:),(1:),(0:)]
08:05:38 <lambdabot>  <[Integer] -> [Integer]>
08:06:00 <fen> > fold [(2:),(1:),(0:)] mempty
08:06:03 <lambdabot>  [2,1,0]
08:06:25 <mlehmk> > fold (toNonEmpty [(2:),(1:),(0:)])
08:06:28 <lambdabot>  error:
08:06:28 <lambdabot>      • Variable not in scope:
08:06:28 <lambdabot>          toNonEmpty :: [[Integer] -> [Integer]] -> [m]
08:06:30 <c_wraith> it's not right, though
08:06:41 <fen> butb NonEmpty has no mempty
08:06:58 <mlehmk> exactly, so it cannot be finite
08:07:07 <c_wraith> > fold [(1:), (2:)] [3]
08:07:09 <lambdabot>  [1,3,2,3]
08:07:24 <c_wraith> so..that's not difference list concatenation
08:07:30 <mlehmk> I see
08:07:34 <fen> grarg
08:07:40 <mlehmk> fold isn't what I thought it is
08:07:51 <c_wraith> you want foldr, most likely
08:07:58 <hyperisco> or fold Endo
08:08:24 <fen> > foldr (.) id [(2:),(1:),const (0:)] undefined
08:08:26 <lambdabot>  error:
08:08:26 <lambdabot>      • Couldn't match type ‘[Integer] -> [Integer]’ with ‘[a]’
08:08:26 <lambdabot>        Expected type: [a] -> [a]
08:08:27 <c_wraith> hyperisco, foldMap Endo? :)
08:08:32 <mlehmk> forget the const element
08:08:38 <hyperisco> sure
08:08:38 <fen> > foldr (.) id [(2:),(1:),const (0:[])] undefined
08:08:41 <lambdabot>  [2,1,0]
08:09:22 <fen> > foldr (.) id [(2:),(1:),(const . pure) 0] undefined
08:09:24 <mlehmk> cause then you have to do like: foldr (.) id ([(2:),(1:)] ++ [const (0:[])]) undefined, which you don't want to do, cause you want to eliminate ++
08:09:25 <lambdabot>  [2,1,0]
08:09:32 <hyperisco> so we're trying to what? fold nonempty lists?
08:09:41 <fen> make difference lists of them
08:09:53 <hyperisco> well w/e, a list of some monoid
08:09:53 <fen> in a way that can also be used with lists
08:10:01 <fen> its not a monoid!
08:10:04 <hyperisco> what isn't?
08:10:06 <mlehmk> to make a difference list from difference lists, you do: \xs -> foldr (.) id xs
08:10:09 <fen> nonempty list
08:10:14 <hyperisco> the elements
08:10:49 <mlehmk> which is actually, difflist . difflist
08:11:39 <fen> :t \ xs -> foldr (<>) id xs undefined
08:11:39 <mlehmk> to boot a list from a difflist, you need mempty, so to do: difflist mempty
08:11:41 <lambdabot> (Monoid a, Foldable t) => t (a -> a) -> a
08:11:52 <fen> hmm, whats monoid without mempty?
08:12:04 <Axman6> Semigroup
08:12:13 <hyperisco> https://hackage.haskell.org/package/semigroups-0.18.1/docs/Data-List-NonEmpty.html
08:12:13 <fen> whats the mappend for semigroup?
08:12:35 <hyperisco> you concatenate NonEmpty lists with <> and fold them with fold
08:12:47 <hyperisco> if you want difference lists then foldMap Endo
08:13:29 <fen> hmm maybe id is mempty...
08:13:46 <fen> > (mempty :: a -> a) 0
08:13:49 <lambdabot>  error:
08:13:49 <lambdabot>      • Could not deduce (Monoid a1) arising from a use of ‘mempty’
08:13:49 <lambdabot>        from the context: Num a
08:13:50 <mlehmk> but that's the mempty of no difference lists
08:13:53 <fen> ok nvm
08:14:04 <hyperisco> mempty is id
08:14:07 <mlehmk> actually, I just see a type error
08:14:20 <int-e> > appEndo mempty 0
08:14:22 <lambdabot>  0
08:14:30 <Axman6> > (mempty :: Endo Int) 7
08:14:32 <lambdabot>  error:
08:14:32 <lambdabot>      • Couldn't match expected type ‘Integer -> t’
08:14:32 <lambdabot>                    with actual type ‘Endo Int’
08:14:37 <fen> just not sure why lambdabot sees Monoid in ':t \ xs -> foldr (<>) id xs undefined'
08:14:43 <Axman6> > appEndo (mempty :: Endo Int) 7
08:14:45 <lambdabot>  7
08:14:52 <fen> % :t \ xs -> foldr (<>) id xs undefined
08:14:52 <yahb> fen: (Foldable t, Semigroup a) => t (a -> a) -> a
08:14:55 <fen> hmm
08:15:05 <hyperisco> don't bother yourself with using undefined, unnecessary
08:15:23 <mlehmk> that's what I said... split it
08:15:26 <fen> well then need foldr combined with init
08:15:43 <fen> like, foldr that does not use the last element
08:16:26 <fen> wait no thats doing the init before the foldr, thats the wrong way round. the idea was to take init of the recombined difference list
08:17:44 <fen> why is the idea of using const . create (for Create instance containers) or just const to return the last difference being fought against?
08:17:55 <mlehmk> you don't need const
08:18:04 <mlehmk> it's the initial condition
08:18:19 <fen> what!?
08:18:35 <fen> oh the basecase of fold?
08:19:04 <mlehmk> actually the last (x:[]) becomes your create x
08:19:25 <mlehmk> actually last (x:) I mean
08:19:54 <fen> no, maybe foldr1 would work...
08:20:03 <fen> but id is fine
08:20:18 <mlehmk> well, you are trying to do two things in one
08:20:41 <fen> what, unfold the difference list and fold it up?
08:20:49 <mlehmk> first would be to reduce your difference lists into a single difference list [[a] -> [a]] -> [a] -> [a]
08:21:10 <drets> Hi, I use servant and looking for the way to validate client's Google ID token (https://developers.google.com/identity/sign-in/web/backend-auth#using-a-google-api-client-library). Is there any wrapper for Google API Client Library which I can use with servant?
08:21:37 <mlehmk> then your actual problem would be to get that difference list into a list without using mempty to generate it
08:21:50 <mlehmk> so, if you had mempty, you could just difflist mempty
08:22:58 <mlehmk> the problem is, you have a semigroup and thus you cannot simply do that
08:24:19 <fen> correct
08:24:24 <MarcelineVQ> Would it make sense to simply have the thing that eventually turns your dlist into a NonEmpty take a default value? like how fromMaybe operates?
08:24:50 <fen> you mean maybe?
08:25:01 <fen> % fromMaybe Nothing
08:25:01 <yahb> fen: ; <interactive>:98:1: error:; * No instance for (Show (Maybe (Maybe a0) -> Maybe a0)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
08:25:18 <fen> :t fromMaybe
08:25:19 <lambdabot> a -> Maybe a -> a
08:25:20 <fen> oh
08:25:22 <MarcelineVQ> I mean more specifically the pattern that fromMaybe encapsulates, but yes maybe is the more general form.
08:25:42 <fen> how would that work?
08:26:01 <MarcelineVQ> e.g.  toNonEmptyList :: a -> DList a -> NonEmpty a
08:26:41 <fen> that does not look right, what is this extra value?
08:27:04 <mlehmk> the extra value is the requirement to close the semigroup on the other side
08:27:28 <fen> but the last element of the nonempty list should be used to do that
08:27:42 <mlehmk> you need something to apply your difflist to. As that cannot be empty, it requires a value
08:27:56 <fen> undefined is good
08:28:01 <fen> :t undefined
08:28:02 <lambdabot> a
08:28:04 <fen> see 
08:28:30 <mlehmk> so, your difflist to nonempty is then: \xs -> init $ xs [undefined]
08:28:46 <fen> alternativly, error could be used to give a better error message if th user does not unfold the difference list to have const.create at the end
08:28:47 <mlehmk> prepend to a void value that is removed again
08:29:23 <fen> why is this version with init and [undefined] better? because then the user cant unfold the difference list badly?
08:29:32 <mlehmk> if there's a const.create at the end, then it is not a difference list
08:29:40 <fen> hmm
08:29:42 <fen> why/
08:29:53 <mlehmk> actually... it can be a difference list
08:30:05 <mlehmk> although it is not appending, but replacing
08:30:12 <fen> the values are of the right type
08:30:24 <mlehmk> that doesn't mean it is conceptually correct
08:30:33 <fen> maybe there is some kind of law it isnt satisfying, but i never heard of such
08:31:04 <mlehmk> not a law, but, if the purpose of difference lists is to prepend values to a list, then the only valid operations in that list are prepending
08:31:30 <fen> yeah, a const . create could be put in the middle too and it would just disregard the rest of the list
08:31:49 <mlehmk> which is then probably not the difference list, that you wanted
08:31:58 <fen> true
08:32:03 <mlehmk> ahh, it breaks kind of commutative law
08:32:11 <fen> go on
08:32:23 <mlehmk> like a <> b, vs b <> a
08:32:41 <mlehmk> if b needs the const.create, then b <> a would be b
08:33:03 <mlehmk> but with difference lists you should be able to just do that to reverse application
08:33:16 <fen> who says?
08:33:47 <fen> trying to foldl it to get the reverse would just give the wrong half if the const was in the middle
08:33:51 <mlehmk> if you want instead of (show a) ++ (show b) to do (shows a) . (shows b)
08:34:08 <fen> so maybe your law is reverse . reverse = id or some rephrasing of that to work with difference lists
08:34:36 <fen> ok, that might start to justify the version using init instead
08:34:47 <mlehmk> No, I mean: (show a) ++ (show b) to (show b) ++ (show a) verses (shows a) . (shows b) to (shows b) . (shows a)
08:34:48 <fen> but its worrying that a user defined datatype might not fuse properly
08:35:24 <fen> mlehmk: not following that last part
08:36:08 <mlehmk> as a conclusion, nonempty difference lists just doesn't apply to finite lists
08:36:22 <fen> what!?
08:36:44 <mlehmk> you have no initial empty nonempty to prepend to
08:36:54 <fen> the wole idea is to make the same unfolding opperation create a difference list from a list and a nonempty list alike
08:37:37 <mlehmk> there is no problem to just do that like [a] -> NonEmpty a
08:38:02 <fen> which would fail on []
08:38:07 <mlehmk> it would actually require your difflist to produce a list with at least one element in it, even on the empty list
08:38:33 <mlehmk> which is actually better than requiring the difflist to only work on nonempty lists
08:39:08 <mlehmk> and the result of this would be a NonEmpty a
08:39:35 <fen> hang on, so your saying by having [undefined] as the target, and then taking the init of the resulting reconstructed container, its better because the empty version can be handled
08:39:45 <mlehmk> No, having mempty
08:40:04 <fen> create undefined = mempty
08:40:08 <mlehmk> but you composition has NonEmpty ([a] -> NonEmpty a) -> NonEmpty a then
08:40:08 <MarcelineVQ> mempty of what?
08:40:18 <fen> argh, that does not look good for lists!
08:40:51 <mlehmk> else it'd be a type error
08:41:07 <fen> what on earth is that?
08:41:31 <mlehmk> You need to be sure your list of difflists is nonempty
08:41:32 <fen> why is the difference list nonempy itself? and why is it turning lists into nonempty lists!?
08:41:45 <mlehmk> so it does what you want
08:41:53 <fen> thats not clear
08:42:13 <mlehmk> Isn't it you want to append NonEmpty lists by using difference lists?
08:42:27 <fen> yes
08:42:52 <mlehmk> okay, so you need to make sure you can always produce NonEmpty a in the end. Which means your input of difference lists may not be empty either
08:43:10 <mlehmk> so that's why NonEmpty is required there as well
08:43:33 <fen> ok, otherwise it would just be id applied to undefined or [undefined] 
08:43:49 <mlehmk> on the other hand, your composition itself needs a mempty as the bottom, thus the difference lists must accept an empty element
08:44:05 <fen> well, if the init was being taken with the [undefined] it would be ok to have an empty list of differences over nonempty lists
08:44:15 <mlehmk> alternatively you could do NonEmpty (Maybe NonEmpty a -> NonEmpty a) -> NonEmpty a
08:44:45 <fen> which is the original "slow" version of the paste
08:44:51 <mlehmk> not quite
08:45:18 <fen> other than its a nonempty list of "slow" differences as opposed to a regular list of them
08:45:31 <mlehmk> yes, thus the version I mentioned above
08:45:43 <fen> but that wouldnt compose
08:45:56 <mlehmk> it does
08:46:05 <fen> or at least, where are the [a] coming from
08:46:30 <mlehmk> there's a NonEmpty a -> [a] version called toList
08:47:22 <mlehmk> so, I think you fold with (.toList) then, I think, if I got this right
08:47:23 <fen> you are surgesting to make the [a] from the NonEmpty? then its just NonEmpty (NonEmpty -> NonEmpty a) -> NonEmpty a
08:47:31 <fen> NonEmpty (NonEmpty a -> NonEmpty a) -> NonEmpty a
08:47:48 <mlehmk> that's the start, but you neen mempty to fold a finite list
08:47:55 <fen> :quote fen
08:47:59 <mlehmk> so: NonEmpty ([a] -> NonEmpty a) -> NonEmpty a
08:48:00 <fen> hmm
08:49:13 <hyperisco> ah I get now why we have 64 bit machines
08:49:27 <fen> @quote fen
08:49:28 <lambdabot> fen says: how slow are you trying to be!?
08:49:33 <hyperisco> it is because it takes 64 bits to lay out all the hexadecimal characters 0x0123456789ABCDEF
08:49:43 <MarcelineVQ> hyperisco: so we can compute debrujin indices?
08:49:51 * hackage avers-server 0.1.0.1 - Server implementation of the Avers API  http://hackage.haskell.org/package/avers-server-0.1.0.1 (wereHamster)
08:50:40 <fen> no, it can be a list and not a nonempty list of difference, and no, the differences are not of the form [a] -> Nonempty a. that is silly
08:51:54 <MarcelineVQ> It is at this point you'd be best served by writing the thing you're imagining and asking about it concretely when you get stuck somewhat into the writing of it
08:52:00 <mlehmk> if you want to create different lists of the form NonEmpty a -> NonEmpty a, the lists are infinite
08:52:31 <MarcelineVQ> Along the way you can consider things like, what is my interface to this thing I want to write, how much hassle do I want to create or avoid with my interface
08:53:05 <fen> infinite!?
08:53:12 <fen> are you trolling?
08:53:17 <mlehmk> you cannot create a finite list from just difference lists that are only taking NonEmpty
08:54:00 <MarcelineVQ> Does it make sense to be both for NonEmpty and normal lists at once, how do I express this in my interface/api if it does, can I just work on lists and worry about NonEmpty at the start or end of the process a user takes
08:54:08 <fen> because you are saying that using const.create breaks this reverse . reverse = id type law?
08:54:31 <mlehmk> const.create is breaking the whole encapsulation thing
08:54:57 <mlehmk> it should make no difference between any difference list or the last one
08:55:21 <mlehmk> beside, you could just compose like this: difflist . difflist nonempty
08:55:24 <fen> MarcelineVQ: the idea is that the user just specifies how to make difference lists, and how to handle the end of the list is taken care of
08:55:35 <Putonlalla> I much preferred 16-bit machines, because 2 ^ (2 ^ 2) = 2 ^ 2 ^ 2 = (2 ^ 2) ^ 2 and it played nice with binary logarithms, hyperisco.
08:55:42 <MarcelineVQ> Don't tell me, tell you, while writing it, this conversation isn't progressing :>
08:55:53 <fen> i.e. they just implement get set and create
08:56:48 <fen> MarcelineVQ: ok, recent progress seems to be that there is contension about using const.create and this is ruining everything
08:57:01 <lopezlu> ?wiki Monad
08:57:01 <lambdabot> https://wiki.haskell.org/Monad
08:57:10 <fen> im going to use it anyway and retun later with an example
08:57:14 <fen> but thatks for the help
08:57:36 <Putonlalla> The size of a 16-bit number fits into 4 bits, whose size fits into 2 bits, whose size fits into 1 bit.
08:59:06 <fen> (the real problem is the unfolding process to produce the difference list)
08:59:06 <mlehmk> this conversation has pretty much teached me about semigroups and monoids
08:59:45 <mlehmk> and that folding needs the identity property of monoids to create a list out of difference lists
08:59:45 <hyperisco> Putonlalla, :o
09:00:13 <mlehmk> without identity, you can only fold difference lists into a difference list
09:00:34 <hyperisco> that is a response both to the fact and to starting at 1
09:01:02 <fen> mlehmk: yar, thats the root of the problem
09:01:12 <fen> andusing maybe is a slow way round it
09:01:18 <mlehmk> the size of 1 bit fits into unit
09:01:39 <fen> and using create breaks some laws that probably are not important
09:02:12 <mlehmk> fen, I wanted to guide you to just using foldr (.) id to fold your difference lists into one
09:02:34 <fen> but thats what was being done anyway in the paste
09:02:36 <mlehmk> and to finally create your list, you need a list as a starting point
09:02:45 <mlehmk> no, it wasn't
09:02:54 <fen> https://bpaste.net/show/f391676f1672
09:02:55 <mlehmk> you did \xs -> ... xs undefined
09:03:17 <fen> no, the undefined was the argument supplied to the result of folding the difference list
09:03:19 <mlehmk> undefined is that smell, it was pointing out that something with your types is going wrong
09:03:39 <fen> nothing with the types is going wrong, everything is fine
09:04:00 <fen> the fear of undefined here is superstitious 
09:04:19 <fen> its a very good way to give a fake empty to nonempty lists
09:04:20 <mlehmk> what you can actually only do with those is like: [(NonEmpty a) -> (NonEmpty a)] -> (NonEmpty a) -> (NonEmpty a)
09:04:30 <fen> its fast, where as using Nothing is slow
09:04:39 <mlehmk> it is not possible to just have a NonEmpty a as a result
09:05:12 <fen> that why it gets applied to undefined :: NonEmpty a
09:05:13 <mlehmk> to get, what you want, you need more like what we found above
09:05:29 <mlehmk> which is then a type error
09:05:32 <hyperisco> define a new Foldable1 class if there isn't one out there already
09:05:36 <hyperisco> sounds like problem solved
09:05:56 <mlehmk> yeah, a foldable needs a monoid, doesn't it?
09:05:58 <hyperisco> http://hackage.haskell.org/package/semigroupoids-5.3.1/docs/Data-Semigroup-Foldable.html#t:Foldable1 done
09:06:08 <fen> the init version is ok, using create undefined instead 
09:06:21 <fen> but might not be as fast if the user doesnt know about fusion
09:06:57 <fen> it would be better just to provide an API which unfolded to have the last value use const . create and start everything off by applying it to undefined
09:07:04 <fen> but i dont really want to say that again
09:07:52 <fen> the fact it does not reverse properly is not important here
09:07:53 <mlehmk> the init version throws an error on empty difference lists
09:08:06 <fen> no it doesnt!
09:08:14 <mlehmk> thus your difference lists should be of type [a] -> NonEmpty a
09:08:36 <fen> no!
09:08:50 <fen> > init [undefined]
09:08:52 <lambdabot>  []
09:08:54 <mlehmk> so they cannot be empty. With NonEmpty a -> NonEmpty a, you have the possibility to have empty difference lists, which I have id as example of an empty difference list
09:09:18 <mlehmk> having the type [a] -> NonEmpty a prevents empty difference lists
09:09:31 <fen> there is no problem with empty difference lists 
09:09:44 <mlehmk> there isn't?
09:09:48 <fen> no!
09:09:51 <mlehmk> so you can just use [a] -> [a] then
09:10:29 <fen> ...
09:10:51 <fen> ok fine ill use the init version
09:11:07 <mlehmk> no, the init version was a mistake of mine and produces errors
09:15:26 <nshepperd1> data HasElement = N | Y; data List (h :: HasElement) a = List [a]; type NonEmptyDifflist a = forall h. List h a -> List Y a
09:20:23 <glguy> (minor fix: newtype)
09:21:10 <midi[m]> request for e2e?
09:27:51 * hackage slate 0.12.0.0 - A note taking CLI tool.  http://hackage.haskell.org/package/slate-0.12.0.0 (evuez)
09:41:05 <mlehmk> I guess I found what fen looked for: \xs -> (foldr (\x y -> x . (toList) . y) (fromList) . toList) xs []
09:42:46 <mlehmk> that way you can make difference lists typed [a] -> NonEmpty a and create a NonEmpty of these and transform them into a NonEmpty a
09:46:10 <nshepperd1> If you're doing that why not just do NonEmpty (NonEmpty a)
09:47:26 <mlehmk> cause concatenation can be slower than difference lists
09:48:03 <nshepperd1> I think the best option is probably just a newtype of [a] -> [a] with smart constructors
09:56:55 <cfsloth> hi
09:58:19 <mlehmk> nonempty difflist type has been found already, it's [a] -> NonEmpty a
09:59:16 <mlehmk> though that doesn't really compose
10:01:07 <mlehmk> wait, it does, with <>
10:02:25 <mlehmk> mind blown
10:04:21 * hackage toodles 0.1.0.12 - Manage the TODO entries in your code  http://hackage.haskell.org/package/toodles-0.1.0.12 (aviaviavi)
10:05:12 <dolio> The analogue to DList would be forgetting NonEmpty on one end.
10:05:41 <dolio> f ++ g = f . toList . g
10:05:49 <mlehmk> yay
10:05:55 <mlehmk> solved
10:06:18 <mlehmk> it's just \xs -> sconcat xs []
10:06:52 <mlehmk> where xs :: NonEmpty ([a] -> NonEmpty a)
10:07:38 <mlehmk> that does, what I think fen attempted
10:08:07 <mlehmk> concatenate a nonempty list of nonempty difference lists
10:08:37 <mlehmk> at least, that's how I'd do it
10:09:58 <mlehmk> for the generic case just flip sconcat mempty
10:11:15 <mlehmk> uhm... this kind of Haskell feels like golf
10:11:39 <Welkin> for anyone who is experienced with authentication/authorization methods, I am getting a lot of conflicting information on server-side storage of sessions vs client-side (or using something like JWT). Any advice on that?
10:11:48 <mlehmk> do you do this often in Haskell?
10:12:14 <mlehmk> what you give client side isn't a session at all
10:12:16 <Welkin> mlehmk: code golf? No. That is just bad programming.
10:12:52 <mlehmk> JWT is an authenticated authentication token that can be validated by the server
10:13:22 <Welkin> by client-side I mean an auth token, or JWT, or the way yesod does it by encrypting the user data and storing it in a cookie (which is bad)
10:13:41 <mlehmk> encrypting and storing in cookie is bad indeed
10:13:59 <mlehmk> You have to add an authenticating hash, then you can store it in a cookie
10:14:55 <mlehmk> a client side stored auth token should consist of a nonce, message authentication hash and expiration time
10:15:07 <Welkin> a lot of the information I have found on stack exchange and similar places is fom several years ago
10:15:15 <[exa]> Welkin: for what purpose btw?
10:15:29 <Welkin> this is for authenticating users in a web application
10:15:30 <mlehmk> yeah, this isn't exactly Haskell talk
10:15:53 <mlehmk> though we can continue to talk about this in private if no one else is interested in this matter
10:16:02 <Welkin> mlehmk: #haskell-offtopic 
10:16:41 <[exa]> Welkin: client storage has brutal tradeoffs in the "protocol" design, you need to prevent easy copying etc.
10:18:26 <[exa]> Welkin: server-side OTOH has the overhead of state management. So choosing is mostly about application design
10:19:30 <Welkin> [exa]: feel free to join us in #haskell-offtopic
10:31:31 <exarkun1> trying to understand Async, having trouble.  this example might isolate my difficulty, <https://gist.github.com/exarkun/a092f92078aea127edb1f0b598edebb0>.  notice the differing type of `echo` in the two versions and the different way it is handled.  as implied, working.hs works fine, broken.hs never produces any output from `reader`
10:31:35 <exarkun1> can someone explain what the difference is?
10:37:55 <cemerick> while in ghci, using `undefined` as the default to `fromRight` works (e.g. when I just want the known-good result), but I wonder if there's a less sledgehammer-y option I'm not aware of?
10:43:28 <pie__> is it possible to set the path of ghci_history?
10:45:26 <pie__> * from an environment variable
10:55:46 <exarkun1> Seems like an Async's IO doesn't happen if you don't wait on the Async
11:00:59 <michalrus> If I have a `data AB = A | B` and a `proxy :: Proxy (ab :: AB)`, and a `value :: AB`, how can I check if this `value` matches the `proxy`?
11:01:20 <c_wraith> exarkun1, I don't think that's true. any chance the program is just exiting too soon? haskell threads are all shut down when the main thread ends
11:02:10 <exarkun1> c_wraith (IRC): I didn't find any documentation to support this and a talk by Simon Marlow seems to be saying that it's not true
11:02:19 <exarkun1> c_wraith (IRC): But the program definitely is not exiting too soon.
11:02:37 <exarkun1> And I've run out of ideas for other explanations
11:02:47 <glguy> michalrus: You can write a class that has a method :: class C ab where Proxy ab -> AB
11:02:50 <dmwit> michalrus: What does "match" mean?
11:02:54 <glguy> michalrus: and then you can compare that with ==
11:03:09 <dmwit> Oh, I see.
11:03:18 <michalrus> dmwit: well, intuitively match, A ↔ Proxy 'A, B ↔ Proxy 'B
11:03:19 <c_wraith> exarkun1, one other idea - is it a laziness problem in the async?
11:03:25 <michalrus> glguy: okay. ^^
11:03:32 <glguy> class C (ab :: AB) where method :: Proxy ab -> AB -- filling tha tout
11:04:03 <michalrus> Mhm. =)
11:04:16 <exarkun1> c_wraith (IRC): Hm!  I don't know.  I posted a complete example above, fwiw.
11:04:37 <exarkun1> well, complete-with-external-dependencies
11:04:44 <glguy> michalrus: The type-level 'A and 'B are only related to the value A and B in that they have similar names. You'll have to manually define any other correspondence
11:04:44 <michalrus> exarkun1: you could also try to wrap that async’s body in a handleAll with logging, since any exception won’t be logged…
11:05:00 <dmwit> cemerick: Right x = thingIKnowReturnsARight
11:05:02 <michalrus> glguy: yes. I just hoped that there might be something already
11:05:07 <michalrus> (=
11:05:30 <cemerick> dmwit: ech, ofc, thanks
11:05:43 <hexagoxel> exarkun1: the difference is whether or not you complete the action within "withEncryptedConnection"
11:05:49 <glguy> michalrus: You can generate that class and instances using this package: http://hackage.haskell.org/package/singletons but that's a really heavy solution
11:05:59 <michalrus> Oh. :o
11:06:57 <exarkun1> hexagoxel (IRC): Oh
11:07:07 <hexagoxel> (any sort of forking inside a with.. function is risky business, naturally)
11:08:30 <dmwit> exarkun1: That "(IRC)" tag is weird. What bridge are you using? Can that be turned off?
11:08:40 <dmwit> Not really critical, just looks odd.
11:08:58 <exarkun1> dmwit (IRC): sorry.  it's matrix.  I plan to switch to something else as soon as I have a chance.
11:09:35 <mlehmk> try writing username, instead to address someone
11:09:45 <exarkun1> (know any good haskell irc bouncers that are easier to set up than znc?)
11:09:45 <monochrom> Matrix is good but it ought not add these annoying tags.
11:10:08 <monochrom> znc is already an easiest.
11:10:19 <monochrom> Or at least, zero maintenance.
11:11:01 <dmwit> I don't know how easy znc is to set up. I use ssh+tmux, and that was very easy, because it was tools I already knew.
11:11:54 <tdammers> same here
11:12:04 <tdammers> weechat in a tmux session, and then just ssh into that
11:12:06 <monochrom> There was a time matrix didn't add the annoying obnoxious " (IRC)".
11:12:19 <davean> exarkun1: why do you want a bouncer instead of a client that you can control remtely?
11:12:30 <exarkun1> hexagoxel: Thanks.  That makes sense.  I wish I had gotten an error from the compiler for using resources created inside a `with...` outside of it.  I am still new enough to Haskell that I guess I don't know if that's feasible or not.  I have another case with a similar error that doesn't seem to be explained by this, sadly. :(
11:12:33 <davean> tdammers: or connect to it via a weechat frontend
11:12:54 <exarkun1> davean: Because my last-mile link is often >1s RTT
11:12:55 <monochrom> A bouncer is a client you can control remotely.
11:13:17 <dmwit> exarkun1: ST is the standard trick for doing it, and yes it's pretty heavyweight.
11:13:24 <davean> exarkun1: exactly why you should use something like a remote frontend ...
11:13:39 <dmwit> exarkun1: Having your API just do IO is v. convenient for users. Nothing to learn, and easy interop with other existing tech.
11:13:40 <exarkun1> davean: I'm not sure what you're suggesting
11:13:41 <monochrom> And bouncer+localClient is a pair where you can control things both remotely and locally.
11:13:44 <davean> exarkun1: like weechat
11:14:33 <buttons840> for a parameterized type "T a b" to be an instance of typeclass C, then T must be an instance of C, and a and b must be instances of C?
11:14:50 <dmwit> buttons840: No, not necessarily.
11:15:00 <dmwit> buttons840: e.g. `Proxy a` is an instance of `Eq` whether `a` is or not.
11:15:17 <exarkun1> davean: Okay.  I see.  Is this really all that different from a bouncer?
11:15:32 <dmwit> buttons840: And `Identity` is an instance of `Functor`, whereas its parameter wouldn't even have the right kind to be an instance.
11:15:36 <tdammers> davean: too lazy to figure out how to do that
11:15:51 <davean> exarkun1: rather a bit. For one it doesn't have to spool the data across, also you don't get disconnection boundaries.
11:16:01 <davean> exarkun1: so its both less bandwidth and less lossy
11:16:05 <buttons840> dmwit: hmmm, Ok, i've never had much touble with this in practice, but I started thinking about the underlying rules and I'm getting confused
11:16:16 <monochrom> If you ssh to an irc client that's 5 seconds away from you, it means that every time you press a key, it takes 10 seconds to provide visual feedback.  A bouncer 5 seconds away doesn't have this problem.
11:16:44 <exarkun1> Oh.  I like having a spool of messages from when my client was offline.
11:16:47 <davean> monochrom: Well of course. Was anyone proposing that?
11:17:12 <dmwit> Yes. Me. Because it uses only tech you have probably already used.
11:17:13 <davean> exarkun1: With the split front-end/backend the client is never offline
11:17:24 <monochrom> Yes. Or at least that's how I interpreted the Q&A "the last mile is >1s RTT" "therefore use ssh".
11:17:38 <Tuplanolla> Type `T` and class `C`? I didn't know it's contagious.
11:17:49 <marxS> type C
11:17:52 <monochrom> Anyway I use a bouncer, so bite me.
11:18:03 <dmwit> I have no objection to "using tech I already know doesn't work well for me because I am in some exceptional circumstances", though.
11:18:09 * monochrom <-- tired of arguing with ssh ideologies.
11:18:14 <monochrom> s/with/against/
11:18:29 <exarkun1> davean: Do you have a link to the Weechat docs for this feature?  I see "Relay" but I'm not sure if that's what you're talking about.
11:18:33 <Boarders> I have a list comprehension and if one of the guards fails I want to create a new list of those failures
11:18:33 <exarkun1> And then we should probably take this off-channel if we continue, I guess
11:18:38 <Boarders> does anyone know of a nice way to do this?
11:18:49 <dmwit> :t partitionEithers -- Boarders
11:18:50 <lambdabot> [Either a b] -> ([a], [b])
11:19:19 <Boarders> dmwit: ooh yeah, nice. Thank you!
11:19:24 <monochrom> Well "using tech I already know" is the root cause of using regex for CFG parsing.
11:20:12 <monochrom> in which case the #haskell recommendation is actually "don't use this tech you're so familiar with unless you're in an exceptional situation"
11:20:56 <dmwit> monochrom: You should know as well as any of us: the answer depends on the question. =)
11:23:25 <exarkun1> What's a sensible way out of my used-outside-of-with pickle?  Should I take over responsibility for manually allocating and freeing the resource?
11:23:55 <dmwit> yep
11:24:19 <dmwit> I vaguely recall a ResourceT that may be interesting to look into.
11:24:31 <dmwit> I don't have enough experience to recommend or warn against it.
11:24:33 <marxS> do you think the best way to learn haskell is to work through textbook (classical), or to just jump in and learn as you go?
11:24:43 <buttons840> dmwit: so whether or not "Maybe a" is an instance of Eq depends on a, but "Proxy a" is a member of Eq regardless of a, so I'm guessing the difference is because of the Eq instances for Maybe a and Proxy a?
11:24:53 <monochrom> Work through textbook.
11:24:56 <dmwit> buttons840: Correct.
11:25:40 <exarkun1> marxS: Everyone has their own learning style and set of past experiences.  What have you learned in the past and how have you gone about it?
11:25:56 <monochrom> Jump-in is OK if it's jump-in "implement a parser and interpreter for Scheme or a simple programming language".  Total loss if it's "web app".
11:25:56 <hyperisco> Is the best way to Avonlea to wander through the forest or to take the road?
11:26:02 <marxS> exarkun1, every programming language I learn is just "jump-in"
11:26:08 <marxS> but when I learn math it's textbook
11:26:49 <monochrom> Did you learn your first programming language by jump-in too?
11:27:09 <Tuplanolla> Yes.
11:27:11 <monochrom> Anyway consider Haskell your first language all over again.
11:27:36 <dmwit> I learned C from my brother. Did I use a textbook or did I jump in?
11:27:38 <hexagoxel> exarkun1: i agree it is not ideal. we might need to adopt rust's "lifetime"s together with RAII to get a flexible, statically safe story to this kind of problem.
11:27:59 <monochrom> You did not jump in.  Your brother is a talking textbook oracle.
11:28:12 <dmwit> I find it difficult to argue with you. =)
11:28:40 <mlehmk> Haskell might be a nice first language
11:28:47 <monochrom> Every textbook wants to become like your brother.  Because he dynamically changed order and refined content as he observed you.
11:29:09 <mlehmk> go from all the functional aspects to the Monad and do notation and then jump into a language that is only do notation
11:29:24 <zzz> now i want a brother
11:30:09 <hexagoxel> exarkun1: and it is hard to say anything without knowing the complete interface of "MagicWormhole"
11:30:35 <monochrom> I'm a bit puzzled that the name "RAII" only talks about allocation but people use it like it solves deallocation problems.
11:30:59 <monochrom> I mean shouldn't you say "RDID" instead?
11:31:21 <exarkun1> Does Network.WebSocket.runClient have this same behavior?
11:31:32 <mlehmk> RAII acquires and initializes a resource in a scope, which also deallocates it, if it leaves the scope
11:31:49 <exarkun1> I would guess so, it takes a (WebSocket -> ...) function as an argument.  Probably can't use that WebSocket after runClient returns?
11:32:08 <monochrom> And if "RAII" already includes RDID by consensus, then I don't see why people blog about how RAII ≠ bracket
11:32:32 <mlehmk> to not have it deallocated, the resource needs to be moved outside the scope into another placeholder that is bound to an outer scope
11:32:40 <hexagoxel> yeah the RAII name is a bit confusing, but the meaning of "connect resource to object lifetime" is pretty established.
11:32:43 <exarkun1> Yea: "Once this IO action finished, the underlying socket is closed automatically."
11:32:45 <hexagoxel> but bracket is different?
11:32:49 <exarkun1> Okay I guess that explains my other failure as well.
11:33:00 <exarkun1> hexagoxel: Thanks again.
11:33:04 <fen> ok, so the idea of collapsing a difference list into a list by folding it and applying the result to some argument is NOT the way to do it Because, there is a Requirement that the process can be partially performed. that is, it is more like state used to produce the difference list in the first place, getting values one at a time, and updating some accumulator. 
11:33:11 <mlehmk> what the heck shall bracket be?
11:33:16 <monochrom> Yeah I saw some blog or maybe someone here said "bracket is inapplicable for this, do RAII instead".  WTH.
11:33:36 <dmwit> :t bracket -- mlehmk
11:33:37 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:34:07 <mlehmk> looks like (*>) to me
11:34:19 <dolio> monochrom: RAII is the resource usage behavior that everyone complains about in Haskell for some reason. :)
11:34:50 <dolio> Where resources are freed by the garbage collector.
11:34:51 <dmwit> mlehmk: first argument is initalizer; second is finalizer and is always run (even if there's an exception); third is the action of interest to perform with the initialized object
11:34:58 <hexagoxel> bracket has no guarantees whatsoever about the lifetime of the "allocated thingy" (the `a`)
11:35:03 <codedurr> I see it as a little different, bracket is something you have to remember to do when using the thing, where as RAII is usually part of construction / destruction so no exposure outside of module
11:35:17 <hexagoxel> you can write it into an IORef. Or forkIO and use it there.
11:35:46 <hexagoxel> so resource lifetime is not connected to the lifetime of your `a` value.
11:35:46 <mlehmk> ahh, then bracket is a try {...} finally {...}
11:36:02 <codedurr> yes pretty much
11:36:14 <mlehmk> and because C++ doesn't have that, they use RAII
11:37:05 <mlehmk> RAII is pretty much the try...finally but as a class, where the destructor is always executed when leaving the scope
11:37:09 <codedurr> yes, although again RAII is invisible to the user of an API where try/finally is not
11:37:14 <monochrom> Only region forbids you from smuggling out the resource handle.
11:37:54 <mlehmk> you don't need to smuggle it out, you can move it out
11:38:09 <codedurr> sort of like finalize in java, except then you have to wait for the GC to happen
11:38:21 <monochrom> Yes. But I'm saying both bracket and RAII still allow you to move it out.
11:38:25 <mlehmk> no, finalize in java is a very different concept
11:38:34 <mlehmk> finalizers in java might not even be executed at all
11:38:50 <mlehmk> RAII is more like also try...finally in java
11:39:34 <monochrom> Consider class X { public X() { /* allocate resource */ }   X* leaky() { return this; }  ... } 
11:40:04 <monochrom> or &this
11:40:24 <fen> then, using [undefined] as this target value results in the wrong lengthed partially reconstructed list as the deference list is rewound sequentially updating a growing reconstructed list. this means that rather than using a varient of init after the container is fully reconstructed, it should instead discard the extra value undefined at the first stage of reconstruction
11:40:31 <mlehmk> ohh, hi fen
11:40:55 <mlehmk> fastDifference = flip sconcat mempty
11:41:19 <fen> :t sconcat
11:41:21 <lambdabot> error:
11:41:21 <lambdabot>     • Variable not in scope: sconcat
11:41:21 <lambdabot>     • Perhaps you meant one of these:
11:41:26 <fen> whats that?
11:41:36 <mlehmk> it's in another module and I don't know how to get modules into lambdabot
11:41:50 <fen> @hoogle sconcat
11:41:50 <lambdabot> Data.Semigroup sconcat :: Semigroup a => NonEmpty a -> a
11:41:50 <lambdabot> Data.Singletons.Prelude sConcat :: forall (t_a1TId :: [[a_a1SE3]]) . Sing t_a1TId -> Sing (Apply ConcatSym0 t_a1TId :: [a_a1SE3])
11:41:50 <lambdabot> Data.Singletons.Prelude.List sConcat :: forall (t_a1TId :: [[a_a1SE3]]) . Sing t_a1TId -> Sing (Apply ConcatSym0 t_a1TId :: [a_a1SE3])
11:42:03 <mlehmk> Data.Semigroup is it
11:42:34 <mlehmk> your nonempty difference lists are then [a] -> NonEmpty a
11:42:49 <mlehmk> you can concatenate them using (<>) or sconcat
11:43:09 <mlehmk> and you can finalize them into a NonEmpty a, by just calling them with argument mempty
11:43:21 * hackage seqid 0.6.0 - Sequence ID production and consumption  http://hackage.haskell.org/package/seqid-0.6.0 (wraithm)
11:43:33 <fen> % :t sconcat
11:43:33 <yahb> fen: Semigroup a => GHC.Base.NonEmpty a -> a
11:44:26 <hyperisco> monochrom, if you're using C++ the only way you survive is by electively following the rules
11:44:37 <t7> is there a StateT equivalent for ST ?
11:44:38 <mlehmk> to construct a nonempty difference list, you could do like (1:|) then
11:44:43 <fen> not sure why [a] or mempty are appearing in your explanation 
11:44:48 <monochrom> Yes but then I also electively follow the rules when using bracket.
11:44:52 <marxS> [a] -> a
11:44:58 <glguy> t7 how are those two things related?
11:45:06 <mlehmk> fen because of the Monoid property that is needed to create a finite list
11:45:15 <monochrom> People speak like "bracket doesn't statically forbid violation, RAII does". That's BS.
11:45:24 <fen> but NonEmpty is not a Monoid
11:45:29 <mlehmk> exactly
11:45:30 <monochrom> Only region statically forbids violation.
11:45:55 <t7> STT :O
11:46:06 <hexagoxel> monochrom: should "leaky" not return a different type? and what is "region"?
11:46:14 <monochrom> No, STT does not exist, IOT neither.
11:46:22 <fen> oh right, so it requires a value of type `Semigroup a => a' explicitly
11:46:26 <lyxia> Internet Of Things
11:46:27 <mlehmk> % :t flip sconcat mempty
11:46:27 <yahb> mlehmk: (Monoid b, Semigroup c) => GHC.Base.NonEmpty (b -> c) -> c
11:46:31 <glguy> monochrom: You haven't experienced the Internet of Things?
11:46:40 <monochrom> That's IoT.
11:46:45 <glguy> ah, ok
11:46:54 <codedurr> it is also now more correct to not pass around pointers in C++ but to use the smart pointers which follow raii
11:47:33 <fen> mlehmk: do you mean the Semigroup property?
11:47:49 <mlehmk> that, too
11:47:57 <mlehmk> let's see if I can give an example
11:48:11 <fen> well it shouldnt use mempty
11:48:35 <fen> as this does not exist for NonEmpty, it being a SemiGroup not a Monoid
11:48:36 <mlehmk> % diffa x = (1<|(2<|(3<|(4:|x))))
11:48:36 <yahb> mlehmk: ; <interactive>:102:25: error:; * Data constructor not in scope: (:|) :: Integer -> t -> s; * Perhaps you meant one of these: `Seq.:<' (imported from Data.Sequence), `:<' (imported from Control.Lens), `Seq.:>' (imported from Data.Sequence)
11:48:59 <mlehmk> fen, exactly that's why
11:49:55 <fen> % :t (:|)
11:49:55 <yahb> fen: ; <interactive>:1:1: error:; * Data constructor not in scope: :|; * Perhaps you meant one of these: `Seq.:<' (imported from Data.Sequence), `:<' (imported from Control.Lens), `Seq.:>' (imported from Data.Sequence)
11:50:20 <mlehmk> % diffa x = (1<|(2<|(3<|(4:|x))))
11:50:20 <yahb> mlehmk: ; <interactive>:107:13: error:; Ambiguous occurrence `<|'; It could refer to either `Data.List.NonEmpty.<|', imported from `Data.List.NonEmpty'; or `Control.Lens.<|', imported from `Control.Lens' (and originally defined in `Control.Lens.Cons'); <interactive>:107:17: error:; Ambiguous occurrence `<|'; It could refer to either `Data.List.NonEmpty.<|', imported fro
11:51:05 <mlehmk> % :t diffa
11:51:05 <yahb> mlehmk: Num a => [a] -> NonEmpty a
11:51:19 <mlehmk> % diffb = (33:|)
11:51:20 <yahb> mlehmk: 
11:51:44 <mlehmk> % sconcat (diffa :| [diffb]) mempty
11:51:44 <yahb> mlehmk: 1 :| [2,3,4,33]
11:52:04 <mlehmk> there you have it, nonempty difference lists
11:52:35 <mlehmk> % (diffa <> diffb) []
11:52:35 <yahb> mlehmk: 1 :| [2,3,4,33]
11:53:36 <fen> wow whats up with that? how is [] :: NonEmpty!?
11:53:58 <mlehmk> that's why nonempty difference lists need to have the type [a] -> NonEmpty a
11:54:03 <mlehmk> % :t diffa
11:54:03 <yahb> mlehmk: Num a => [a] -> NonEmpty a
11:54:23 <fen> oh, so they just use list
11:54:28 <fen> thats confusing
11:54:38 <fen> ok, what about Cofree Maybe?
11:54:51 <mlehmk> well, if you have NonEmpty a -> NonEmpty a, you'd have a monoid, as those would have identity, which would be an empty difference list
11:55:15 <fen> id
11:55:19 <mlehmk> so to restrict it to just nonempty difference lists, the type needs to be [a] -> NonEmpty a
11:55:25 <fen> but, thats not the thing the collapsed list is applied to
11:55:44 <fen> the difference list after its folded with (.)
11:56:01 <mlehmk> that's why it isn't folded with foldr, but concatenated with sconcat
11:56:19 <fen> and the new additional requirement is that it is a State, returning values one at a time
11:56:22 <jle`> fen: (:|) :: a -> [a] -> NonEmpty a
11:56:38 <jle`> note that the left hand side of the (:|) takes a list, not a NonEmpty
11:56:48 <jle`> er, right hand side\
11:57:05 <fen> its confusing though, its not like Cofree
11:57:20 <fen> (Cofree Maybe)
11:57:33 <mlehmk> let's see
11:57:45 <fen> but its good that it can use [] as the target
11:57:59 <fen> But, not All nonempty containers could use this implementation
11:58:14 <jle`> yeah, this is specifically non empty lists.
11:58:23 <jle`> but you can make the link with cofree:
11:58:39 <jle`> if we "add" an empty element to NonEmpty, we get a normal list
11:58:45 <mlehmk> yeah, but you need to allow for the empty element left hand side to enforce the list nonempty
11:58:47 <jle`> [a] ~ Maybe (NonEmpty a)
11:58:50 <mlehmk> it sounds backwards, but that's how it
11:58:51 <mlehmk> is
11:59:01 <jle`> do you see how Maybe (NonEmpty a) is equivalent to [a] ?
11:59:09 <fen> yes
11:59:11 <jle`> Maybe lets us 'add' an extra element to any type
11:59:23 <jle`> so then we can make this substitution in the type of NonEmpty
11:59:29 <jle`> instead of data NonEmpty a = a :| [a]
11:59:31 <jle`> we can write:
11:59:37 <fen> this was discussed earlier and led to a slow implementation of difference list fold
11:59:37 <jle`> data NonEmpty a = a :| Maybe (NonEmpty a)
11:59:53 <fen> yeah thats just Cofree Maybe
11:59:55 <jle`> which is the same because [a] is the same as Maybe (NonEmpty a)
12:00:00 <jle`> and yeah, then that's Cofree Maybe exactly
12:00:02 <nshepperd1> I don't think (<>) really does the right thing there
12:00:03 <mlehmk> I'd bet the flip sconcat mempty is faster
12:00:35 <nshepperd1> In terms of asymptotics. And also what happens when you apply it to a list that isn't []
12:00:49 <mlehmk> well (a <> b) <> c is equivalent to a <> (b <> c), so I think it does the right thing
12:01:09 <nshepperd1> But you can compose those like (diffa . (toList . diffb))
12:01:20 <fen> oh, i see what you mean jle`
12:01:20 <mlehmk> just diffa <> diffb
12:01:25 <glguy> https://gist.github.com/glguy/0f517f8388682be116e83d3aab5fb668
12:01:34 <glguy> nonempty difference lists as being discussed?
12:01:35 <jle`> data Cofree f a = a :| f (Cofree f a)
12:01:38 <mlehmk> as (<>) is most probably (<>) x y = x . toList . y
12:01:43 <jle`> data Cofree Maybe a = a :| Maybe (Cofree Maybe a)
12:01:51 <nshepperd1> % (diffa <> diffb) [113]
12:01:51 <yahb> nshepperd1: 1 :| [2,3,4,113,33,113]
12:01:54 <jle`> data NonEmpty   a = a :| Maybe (NonEmpty a)
12:01:59 <nshepperd1> mlehmk: ^^
12:02:12 <glguy> nshepperd1: That's fine, it's your responsibility to run the difference list on [] when you're done
12:02:19 <fen> glguy: the problem is that it wont work for Cofree Maybe
12:02:40 <fen> as its a class of all difference list able containers it has to be able to work for that
12:02:57 <glguy> fen: Sure, I haven't seen the problem concisely described yet, I'm just creating a file that loads from what people are talking about
12:03:10 <fen> and not just using this sneaky trick for (:|) :: a -> [a] -> NonEmpty a
12:03:37 <mlehmk> well, the [a] -> NonEmpty a, is analogous to (Maybe a) -> a
12:03:40 <fen> glguy: thanks, yahb is not perfect
12:04:20 <fen> :t (:<)
12:04:21 <lambdabot> Cons b b a a => a -> b -> b
12:04:26 <fen> !?
12:04:31 <mlehmk> that's lenses
12:04:37 <mlehmk> % :t (:<)
12:04:37 <yahb> mlehmk: ; <interactive>:1:1: error:; * Data constructor not in scope: :<; * Perhaps you meant one of these: `:|' (imported from Data.List.NonEmpty), variable `<' (imported from Prelude)
12:05:01 <mlehmk> could it be you maybe meant this
12:05:05 <mlehmk> % :t (<|)
12:05:05 <yahb> mlehmk: a -> NonEmpty a -> NonEmpty a
12:05:56 <mlehmk> although the type says NonEmpty on both sides, there is an empty difference list that has the same type, id
12:05:58 <fen> no i want it to work with Cofree
12:06:15 <fen> well, the Cofree Maybe implementation of NonEmpty
12:06:38 <fen> oh that would just take Nothing
12:06:54 <fen> ok, so it seems like the mempty is always available as a target
12:06:56 <fen> thats good
12:06:59 <monochrom> glguy's code can be modified for that.  Just define your own NonEmpty and don't import Data.List.NonEmpty.
12:07:50 <fen> or wait, does it end up with the slowDifference...
12:08:56 <monochrom> The gist is that NonEmpty a -> NonEmpty a is painting yourself into a corner.  You need [a] -> NonEmpty a.
12:09:29 <fen> @quote fen
12:09:29 <lambdabot> fen says: how slow are you trying to be!?
12:09:54 <fen> hmm, that isnt the best way to put it...
12:10:07 <fen> @forget fen
12:10:07 <lambdabot> Incorrect arguments to quote
12:10:41 <fen> does that no require converting the resulting NonEmpty a into [a] which is slow ?
12:11:02 <fen> at every incramental reconstruction stage, it seems very slow
12:12:02 <mlehmk> why would that be slow?
12:12:42 <monochrom> Yeah, present empirical evidence or mathematical proof, don't talk.
12:12:43 <fen> well it doesnt compose with (.) and instead requires NonEmpty a -> [a]
12:12:55 <mlehmk> wth?
12:13:23 <mlehmk> yep, as nonempty difference lists are a semigroup, you compose them with (<>)
12:13:27 <monochrom> It's [a] -> NonEmpty a, and glguy's code uses (.)
12:13:28 <fen> ([a] -> NonEmpty a) is not a Semigroup
12:13:41 <fen> no it uses toList
12:13:50 <fen> in (<>)
12:14:00 <monochrom> toList is O(1) time, probably O(0) time too.
12:14:08 <mlehmk> yes, and toList efficently converts NonEmpty a -> [a]
12:14:34 <monochrom> I think I should just walk away.
12:14:47 <jle`> toList for NonEmpty is O(1) ... it's pretty much almost completely sharing
12:14:50 <mlehmk> yep... up to him to find out why things are as they are
12:15:01 <jle`> toList (x :| xs) = x : xs
12:15:01 <fen> benchmarking now...
12:15:22 <jle`> note that xs doesn't have to be touched at all, it doesn't require any traversls, it can be completely shared in memory
12:15:46 <jle`> toList for NonEmpty is algorithmically pretty much as fast as they come
12:15:54 <mlehmk> toList only ever does compute on traversing the list
12:17:37 <koz_> jle`: Did you see phadej's solution to the reader problem?
12:17:39 <mlehmk> % head (diffa [])
12:17:39 <yahb> mlehmk: ; <interactive>:118:1: error:; Ambiguous occurrence `head'; It could refer to either `Data.List.NonEmpty.head', imported from `Data.List.NonEmpty'; or `Prelude.head', imported from `Prelude' (and originally defined in `GHC.List')
12:17:43 <jle`> i saw it :)
12:17:50 <mlehmk> % Prelude.head (diffa [])
12:17:50 <yahb> mlehmk: ; <interactive>:119:15: error:; * Couldn't match expected type `[a]' with actual type `NonEmpty Integer'; * In the first argument of `Prelude.head', namely `(diffa [])'; In the expression: Prelude.head (diffa []); In an equation for `it': it = Prelude.head (diffa []); * Relevant bindings include it :: a (bound at <interactive>:119:1)
12:17:54 <koz_> jle`: Is this workable for your blog?
12:17:56 <jle`> looked like the <a> suspicions were correct
12:18:04 <jle`> but i haven't been able to implement yet
12:18:09 <koz_> Ah, OK.
12:18:29 <koz_> Is this an issue with skylighting/pandoc that's worth reporting?
12:18:40 <fen> % :t flip sconcat mempty
12:18:41 <yahb> fen: (Monoid b, Semigroup c) => NonEmpty (b -> c) -> c
12:18:43 <mlehmk> % Data.List.NonEmpty.head (diffa [])
12:18:43 <yahb> mlehmk: 1
12:19:07 <__monty__> koz_: Sounds more like a firefox issue to me.
12:19:39 <koz_> __monty__: Yeah, that's true as well. Not helped by there being literally _no_ documentation on what Firefox's reader mode expects.
12:19:53 <koz_> (that I could find anyway)
12:23:16 <_deepfire> kosmikus: yes, precisely speaking -- and I understand, lens are lens, prisms are prisms..
12:23:27 <Zemyla> Huh. I think I found out that whenever 'a' is a Monoid, 'Bazaar a' is a Category.
12:23:57 <koz_> % :t Bazaar
12:23:57 <yahb> koz_: ; <interactive>:1:1: error: Data constructor not in scope: Bazaar
12:24:05 <koz_> Awww.
12:24:29 <Solonarv_> let's see if I can remember this...
12:24:38 <Solonarv_> % import Control.Lens.Internal.Bazaar
12:24:38 <yahb> Solonarv_: 
12:24:43 <Solonarv_> % :i Bazaar
12:24:43 <yahb> Solonarv_: type role Bazaar representational nominal nominal nominal; newtype Bazaar (p :: * -> * -> *) a b t = Bazaar {runBazaar :: forall (f :: * -> *). Applicative f => p a (f b) -> f t}; -- Defined in `Control.Lens.Internal.Bazaar'; instance [safe] Applicative (Bazaar p a b) -- Defined in `Control.Lens.Internal.Bazaar'; instance [safe] Functor (Bazaar p a b) -- Defined in `Control.Lens.Internal.Bazaar'; in
12:24:49 <Solonarv_> ^ there you go koz_
12:25:16 <jle`> newtyle Bazaar a b t = Bazaar { runBazaar :: forall f. Applicative f => (a -> f b) -> f t }
12:25:28 <jle`> or we were also working with the non-rank n version yesterday
12:25:53 <jle`> data Bazaar a b t = Done t | More a (Bazaar a b (b -> t))
12:26:11 <koz_> Why that name though?
12:26:25 <jle`> it comes from Store
12:26:31 <jle`> but like...it's many stores
12:26:35 <Zemyla> koz_: Because it's a generalization of the Store Comonad.
12:26:39 <koz_> Oh yeah, that makes sense.
12:26:53 <koz_> I think lens also has Market or something?
12:26:54 <Tuplanolla> That one is also called `FunList`.
12:27:01 <Tuplanolla> You might have seen it.
12:27:11 <Solonarv_> in fact, bazaar is the free applicative over Store
12:27:21 <MarcelineVQ> FP is 73% puns, 18% references, and 9% made up on the spot
12:27:27 <Solonarv_> have a blog post: https://bartoszmilewski.com/2018/10/12/trading-funlists-at-a-bazaar-with-yoneda/
12:28:04 <koz_> Solonarv_: Thanks - I love Bartosz's stuff.
12:28:18 <koz_> MarcelineVQ: I think Edward is responsible for many of said puns.
12:28:23 <koz_> % :t confusing
12:28:23 <Zemyla> instance Monoid a => Category (Bazaar a) where { id = Bazaar ($ mempty); Bazaar mf . Bazaar mg = Bazaar $ \c -> mf $ \a -> mg $ c . mappend a }
12:28:23 <yahb> koz_: ; <interactive>:1:1: error: Variable not in scope: confusing
12:28:30 <koz_> :t confusing
12:28:31 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
12:28:36 <Zemyla> It goes like that.
12:28:46 <jle`> from the type of the RankN version you can see that it's basically just a partially applied travresal
12:29:09 <jle`> a traversal is a forall f. Applicative f => (a -> f b) -> (s -> f t)
12:29:27 <jle`> rearrange it to get forall f. Applicative f => s -> ((a -> f b) -> f t)
12:29:39 <jle`> partially apply to an s to get forall f. Applicative f => (a -> f b) -> f t
12:29:58 <jle`> so something like:
12:30:02 <jle`> :t for [1,2,3]
12:30:03 <lambdabot> (Num a, Applicative f) => (a -> f b) -> f [b]
12:30:05 <jle`> is a bazaar
12:30:12 <__monty__> koz_: This looks like the appropriate place to notify the ff devs: https://bugzilla.mozilla.org/show_bug.cgi?id=1102450
12:30:30 <jle`> describe something to do with every 'a' inside the list, and the bazaar stores the information of reconstructing it back into a [b]
12:31:06 <jle`> :t for (M.fromList (zip "abc" [1,2,3]))
12:31:07 <lambdabot> (Num a, Applicative f) => (a -> f b) -> f (M.Map Char b)
12:31:07 <koz_> jle`: Ah, OK. That makes sense.
12:32:14 <jle`> Zemyla: hm i wonder if that's related to any other category instances
12:39:27 <xinming>  charset: terminal: ANSI_X3.4-1968, internal: UTF-8
12:39:42 <xinming> Is it possible to force the termianl to be ANSI_X3.4-1968?
12:42:09 <xinming> It's probably a gentoo bug, With the same kernel. I run a debian container. And that works fine
12:42:26 <fen> ok! benchmarked it; https://bpaste.net/show/0a6b56a7c766
12:42:33 <fen> it sucks!
12:42:48 <fen> what went wrong?
12:43:19 <MarcelineVQ> you benched with ghci for a start :O
12:43:51 <xinming> oops, sorry, wrong channel, I didn't realized it.
12:44:09 <fen> rrg
12:44:10 <MarcelineVQ> best to compile with -O or -O2 when you benchmark things
12:44:11 <fen> ok
12:44:37 <MarcelineVQ> and it's a good idea to use a bench suite like criterion if you really want to be sure
12:44:52 <MarcelineVQ> Since it tracks for outliers
12:45:24 <edwardk> jle`: there is a reason for using the rank-n verson of a store. that is if you want to actually characterize things like traverse for [] and not randomly bottom out on infinite lists
12:45:41 <edwardk> infinite traversals don't exist in coq. some of them terminate under many usecases in haskell
12:46:06 <edwardk> jle`: s/store/bazaar/
12:46:16 <edwardk> and yeah, the name was chosen to be indicative of many stores =)
12:46:50 <edwardk> re: puns, the puns tend to be memorable, which helps
12:51:39 <fen> new benchmark! https://bpaste.net/show/9736cb5fc862
12:52:20 <fen> its slower
12:52:30 <fen> what went wrong?
12:52:58 <jle`> edwardk: yeah, i do rather like the rank n version better, it's a little more illustrative too. unfortunately i had to stick with the non rank-n version in a recent situation where i'm writing lenses/traversals at the type level and rank-n support is not too great :(
12:53:33 <edwardk> jle`: at the type level they coincide as you don't have bottoms or infinite traversals!
12:53:36 <edwardk> so its okay =)
12:53:43 <jle`> oh yes, that is true :)
12:53:51 <Zemyla> The Category instance seems to be related to the indexed Monad instance that the reverse Bazaar has.
12:53:55 <jle`> hooray for theoretical justification
12:54:38 <fen> glguy, mlehmk ^
12:54:56 <Zemyla> It really is a shame that it's not Strong, because then it would be an Arrow.
12:55:48 <mlehmk> fen, neither of those is like we suggested
12:57:00 <fen> sure it uses toList in the composition
12:57:25 <fen> got confused about how it was supposed to handle the target though
12:57:31 <kosmikus> _deepfire: there's no deep reason why we couldn't derive prisms or partial lenses, no. it's simply not done in that library, but it's an easy exercise :)
12:58:14 <mlehmk> fen, as long as your difference lists aren't nonempty difference lists with type [a] -> NonEmpty a, there is nothing how I could help
12:58:17 <kosmikus> _deepfire: or you can use generic-lens, which isn't based on generics-sop, but rather GHC.Generics, but it offers both lenses and prisms
12:58:48 <marxS> is there an easy way to use standard functions but with Integer instead of Int?
12:58:49 <fen> (NonEmpty.fromList (map (:|) [1..100000])):: NonEmpty ([Int]->NonEmpty Int)
12:58:53 <fen> thats exactly what it is
12:58:57 <marxS> so like use replicate but with replicate :: Integer -> a -> [a]
12:59:03 <marxS> not Int -> a -> [a]
12:59:19 <kosmikus> marxS: genericReplicate in this case
12:59:24 <kosmikus> marxS: in Data.List
12:59:35 <mlehmk> fen, yes, that's what it should be
12:59:41 <fen> thats what it is!
12:59:44 <kosmikus> but no, there's no way to use a function defined on just Int on Integer instead
12:59:48 <fen> areyou reading the correct paste?
12:59:49 <marxS> nice, thanks. is there generic versions of most functions kosmikus ?
12:59:52 <mlehmk> fen, that is not what you benchmarked though
13:00:02 <fen> https://bpaste.net/show/9736cb5fc862
13:00:21 <mlehmk> it's like you totally forgot what we talked about. I am not going to repeat everything again
13:00:22 <Tuplanolla> If the `Int` is the first argument, you can just compose with `fromIntegral`, marxS.
13:00:29 <kosmikus> marxS: drop, index / (!!), length, replicate, splitAt, take
13:00:41 <marxS> cool , thanks
13:00:48 <fen> its like your not reading the correct paste...
13:01:10 <fen> see the definition of test2
13:01:50 <fen> the composition opperation (\f g -> f . NonEmpty.toList . g) seems to be really slowing it down
13:01:53 <mlehmk> the definition of fastDifference is even wrong
13:02:07 <mlehmk> indeed
13:02:08 <fen> how?
13:02:18 <mlehmk> I am not going to repeat this stuff
13:02:22 <fen> its good and fast
13:02:47 <fen> you mean it isnt using init and [undefined] ?
13:03:05 <mlehmk> forget it
13:03:21 <mlehmk> it is like you haven't been in the discussion earlier
13:03:23 <fen> that doesnt matter, the idea of the benchmark is to show the other way is slow
13:03:38 <fen> what, about bazaar?
13:03:50 <Solonarv_> Tuplanolla: that'll only work for Integer's that are small enough to fit into Int as well
13:04:06 <Tuplanolla> That's true.
13:04:40 <zenspider_> hi hi. I'm having problems switching to stack and having a happy dev setup. I'm using emacs + dante + flycheck. my code works fine in a shell, but loading it into emacs flycheck and my repl blow up on my imports. 
13:05:02 <fen> its just using the composition glguy described which is slow...
13:05:04 <mlehmk> fen, you are just comparing the old stuff with non-sense
13:05:06 <zenspider_> It LOOKS like dante handles stack just fine by looking for stack.yaml in a sequence w/ other config files. It looksl ike it should find it first.
13:05:14 <fen> bs
13:05:20 <mlehmk> which isn't even the composition we talked about earlier
13:06:07 <fen> my point is that folding 'NonEmpty ([a] -> NonEmpty a)' using toList is slow, which is what was surgested
13:06:14 <zenspider_> I'm not married to dante... I like some of the features but I don't need them. it worked great pre-stack but now it is crapping the bed. 
13:07:52 * hackage seqid-streams 0.7.0 - Sequence ID IO-Streams  http://hackage.haskell.org/package/seqid-streams-0.7.0 (wraithm)
13:08:26 <fen> and having shown that with a benchmark you claim its just sillyness. why?
13:08:35 <mlehmk> fen, I didn't suggest that
13:11:38 <fen> sure
13:11:54 <fen> https://gist.github.com/glguy/0f517f8388682be116e83d3aab5fb668
13:12:18 <mlehmk> what I have is just a difference from 0.03 to 0.04 here with what I suggested to use
13:12:21 <fen> uses toList to implement (<>) which is slow
13:12:33 <mlehmk> toList is efficient
13:12:42 <fen> can you share this?
13:12:52 * hackage streamly 0.5.2 - Beautiful Streaming, Concurrent and Reactive Composition  http://hackage.haskell.org/package/streamly-0.5.2 (harendra)
13:13:42 <mlehmk> actually, it is faster
13:13:50 <fen> (\f g -> f . NonEmpty.toList . g) is slower than (.)
13:13:59 <mlehmk> like I said, I won't repeat... read the past log
13:14:06 <fen> ...
13:14:27 <zenspider_> fen: walk away? this doesn't seem worth it.
13:14:27 <mlehmk> told you earlier, I don't want that stress again
13:14:39 <Tuplanolla> You could repeat once for the rest of us.
13:14:40 <fen> so making a difference list of ([a] -> NonEmpty a) is slower than (NonEmpty a -> NonEmpty a)
13:15:46 <fen> zenspider: if its a case of being clear for the audience and not being deterred it should at least not have the adverse commentary detract from the discussion
13:16:29 <fen> "oh no it istn" "oh yes it is"
13:16:37 <fen> ...
13:16:55 <fen> trying to make fast code here
13:18:57 <fen> not in bloody parliment 
13:19:28 <mlehmk> if you want fast, then just do: foldr (.) id (fmap (:) [1 :: Int ..100000]) []
13:21:17 <fen> that looks NonEmpty
13:21:31 <mlehmk> actually. mconcat (fmap (:) [1 :: Int ..100000]) []
13:22:26 <mlehmk> but that allows for empty
13:23:03 <mlehmk> so, you can either look for a fast or a correct implementation
13:23:50 <phadej> https://github.com/phadej/dlist-nonempty/ FWIW
13:24:34 <phadej> the append is O(1), constant factor shouldn't be a problem
13:24:48 <mlehmk> the non empty one is: sconcat (fromList (fmap (:|) [1 :: Int ..100000])) mempty
13:25:25 <Zemyla> Hmm, why isn't Bazaar in the lens library a Profunctor, Choice, or Closed?
13:25:51 <phadej> maybe in the "fast" code, the dlist isn't the right choice to begin with
13:26:19 <Solonarv_> mlehmk: need an Endo/appEndo in there
13:26:42 <Solonarv_> actually maybe not?
13:26:56 <Solonarv_> > foldMap (:) [1..10] []
13:26:59 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:27:15 <zachk> @src foldMap
13:27:15 <lambdabot> Source not found. It can only be attributed to human error.
13:27:20 <zachk> @type foldMap
13:27:22 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
13:28:09 <MarcelineVQ> > foldMap (:) [1..10] [1]
13:28:11 <lambdabot>  [1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10,1]
13:28:21 <phadej> Zemyla: isn't Bazaar internal type, than it had only instances needed in the lib?
13:29:39 * hackage lens-typelevel 0.1.0.0 - Type-level lenses using singletons  http://hackage.haskell.org/package/lens-typelevel-0.1.0.0 (jle)
13:31:32 * hackage d10 0.1.0.1 - Digits 0-9  http://hackage.haskell.org/package/d10-0.1.0.1 (chris_martin)
13:34:13 <mint> hi
13:42:42 <mint> hi
13:44:22 <zachk> hello mint
13:45:50 <mint> hello zachk pm me
13:49:11 <pzp> What are the problems with the Default Superclass Instances / Intrinsic Superclasses / Instance Templates proposals?
13:58:08 <lavalike> is there a way to invoke ghci, have it load the module(s) specified, have it evaluate 1 given expression, and quit?
13:58:30 <davean> (I've got nothing useful)
13:58:38 <Welkin> runghc
13:59:16 <monochrom> There is also "ghc -e" but I have forgotten all the details and whether it can load modules first.
14:00:14 <Tuplanolla> You could `runhaskell <(echo "import This; main = print that")`.
14:00:14 <monochrom> Ah there is also "xxx | ghci Foo.hs" i.e. redirect its stdin.
14:01:06 <monochrom> Although, ghci spams stdout with startup banner and prompts first.
14:01:46 <Welkin> runhaskell is an alias for runghc
14:02:26 <_deepfire> kosmikus: sometimes one adopts one tool, which leads to adoption of another, that shares the same language.. you cannot simply get back to using generic-lenses, sometimes : -)
14:02:40 <lavalike> how does runghc solve this problem?
14:03:06 <Welkin> it compiles and runs a file, which could be a string you pass in through stdin as well
14:03:18 <Welkin> it does what you want
14:04:24 <lavalike> it complains I don't have a main defined
14:04:30 <lavalike> but I might be misunderstanding
14:04:55 <mint> where you make money easily, give me one reason why
14:05:16 <Welkin> lavalike: echo "main = putStrLn \"Hello\"" | runghc
14:06:25 <Welkin> you may as well just make a temporary file so you can format your one-liner and all the imports nicely
14:06:50 <Welkin> mint: are you some kind of spam bot?
14:07:00 <lavalike> hehe yeah I went echo -e 'import Foo\nmain = print myexpr\n" | runghc
14:07:08 <mint> no
14:07:13 <lavalike> rather involved
14:07:13 <MarcelineVQ> mint: funeral home, distraught people don't want to haggle
14:07:13 <Welkin> yeah that sucks
14:07:24 <Welkin> just make a file and `runghc Test.hs`
14:07:29 <Welkin> you can keep chaning Test.hs
14:07:32 <Welkin> changing*
14:07:49 <lavalike> :/
14:07:52 <Welkin> as you know, in haskell, imports can easily take up dozens of lines
14:08:20 <lavalike> hey ghc Foo.hs -e 'expr' works nicely
14:08:42 <geekosaur> ghc -e cant iport as such, but a fully qualified name will look up the name in all accessible packages
14:08:52 <Welkin> generally, if you need more than a few imports and a one-liner, use a file
14:08:57 <lavalike> it's okay I just have this single hs file
14:09:22 <lavalike> I'll keep the runghc way in mind too, appreciate it
14:10:01 <Welkin> of course you can also have a file that imports things and :load that into ghci
14:10:06 <Welkin> then do whatever you want in the session
14:11:13 <monochrom> lavalike: You can use semicolons.
14:11:44 <lavalike> monochrom: haha fun
14:12:25 <lavalike> as well as multiple `-e's
14:17:50 * hackage gingersnap 0.2.2.0 - Tools for consistent and safe JSON APIs with snap-core and postgresql-simple  http://hackage.haskell.org/package/gingersnap-0.2.2.0 (TomBop)
14:18:38 <_kwstas> hello there! When I want to concatenate 3 or more string values, is there an idiomatic way to do that? I suppose the 2 most common ways is  (++/<>) and `concat`, but is there any prevailing one?
14:19:34 <monochrom> No.
14:19:48 <Rembane_> _kwstas: Use the one that makes you happiest.
14:20:01 <saml> how do you do software design ?
14:20:14 <saml> something like uml for functional programming?
14:20:40 <Tuplanolla> Write the user manual first, saml.
14:20:41 <Welkin> ew
14:20:44 <Welkin> uml? really?
14:20:58 <Welkin> you design the software like a normal human being
14:21:00 <monochrom> You forgot the keyword "like".
14:21:18 <dstolfa> i don't think i've ever used uml seriously, only when i was forced to and that looked disastrous
14:21:19 <_kwstas> Rembane_: so I suppose there is not any ;) Thx!
14:21:26 <Welkin> you start by designing the appropriate data structures
14:21:29 <monochrom> But think up what types you need and what operations you do on them.
14:21:37 <saml> i guess split problems and how to compose things with what abstraction
14:22:24 <Rembane_> _kwstas: No worries. :)
14:22:39 <Welkin> the elm community has a really clean approach to this: https://www.youtube.com/watch?v=XpDsk374LDE
14:22:46 <Welkin> this is one of the best talks on software design I have ever seen
14:22:58 <Rembane_> saml: Unfold the problems and then fold the really small pieces.
14:23:05 <zachk> try a module main where at the top in the string you are passing to runhaskell
14:23:11 <Welkin> it also matches up well with Casey Muratori's concept of "exploratory programming"
14:23:36 <Welkin> you don't start with a grand vision, you start by building it and let it become what it needs to be as you sculpt it
14:23:42 <Welkin> like a painter or sculptor
14:24:16 <Rembane_> OTOH, both Haskell and Elm let you refactor mercilessly, so you could just start coding.
14:24:18 <Welkin> for languages like Elm or Haskell in particular, you start with the data structures
14:24:18 <emmanuel_erc> hello there everyone
14:24:25 <orzo> I'm trying to make a kind alias, but it is interpretting * as an operator:  type Spec = [(Symbol,*)]
14:24:31 <orzo> How do fix that?
14:24:35 <Welkin> algebraic data types and pattern matching make this very easy
14:24:41 <orzo> I tried using Type but it isn't in the Prelude
14:29:36 <Solonarv_> import Data.Type (Type)
14:30:45 <orzo> It's Data.Kind
14:31:27 <orzo> Do I need TypeInType to use kind aliases?
14:31:28 <Zemyla> So here's what the Category instance for Bazaar does.
14:31:33 <Zemyla> > let { ta = traverse bsell [0,3,6,9]; tb = each bsell (-1,0,1 :: Sum Int) } in bextract $ lmap getSum $ ta C.. tb
14:31:35 <lambdabot>  [(-1,0,1),(2,3,4),(5,6,7),(8,9,10)]
14:32:00 <isd> Hey all. If an exception is caught using catchSTM, is the part of the transaction it was covering still rolled back, or does that only happen if the exception escapes the entire call to atomically?
14:36:32 * isd reads the source code
14:36:49 <isd> If I'm understanding this correctly, yes, catchSTM still rolls back the bit that it covers
14:37:21 * hackage fltkhs 0.6.0.0 - FLTK bindings  http://hackage.haskell.org/package/fltkhs-0.6.0.0 (deech)
14:38:00 <monochrom> Strangely, throwSTM's doc has that information.
14:38:21 * hackage patat 0.8.1.1 - Terminal-based presentations using Pandoc  http://hackage.haskell.org/package/patat-0.8.1.1 (JasperVanDerJeugt)
14:39:48 <lyxia> I find it rather unclear.
14:39:57 <isd> Yeah, it's not particularly clearly stated though -- it wasn't clear to me how they interacted in any case.
14:40:13 <isd> (maybe I'll submit a patch that makes it more clear).
14:40:13 <lyxia> that "the transaction" mentioned by "throwSTM" is delimited by "catchSTM"
14:40:17 <lyxia> please do!
14:42:32 <monochrom> Ah.
14:42:50 <monochrom> To be fair, the same information should be repeated at both places.
14:43:17 <monochrom> Either that, or don't write javadoc-style doc at all. Write holistic doc instead.
14:43:49 <lyxia> one of them could point to the other
14:44:08 <monochrom> The greatest crime of javadoc-style docs and dependent-type-style types.
14:45:11 <monochrom> The crime that pretends that it is OK to specify each operation individually indepdently, as if the point was not their mutual interactions and interferences.
14:47:24 <pie_> mostly off topic, but anyone know a good irc bouncer?
14:47:30 <monochrom> znc
14:48:58 <monochrom> Perhaps throw and catch should not be a top-level pair.  Instead, should be one single with-style or callcc-style function.  Whenever two things are tightly dependent on each other, maybe they should be just one thing.
14:49:48 <Welkin> bitchx
14:50:19 <glguy> Are you trying to maintain balance between good and bad answers?
14:50:25 <monochrom> haha
14:50:43 <zachk> bitchx has some bugs iirc
14:51:22 <monochrom> mIRC plus custom script to double it as bouncer. Plus turn off Windows Firewall.
14:53:28 <lavalike> (a . b . c . d) $! [] only goes as far as (a . b . c) <evaluated application> or does it apply all of the composed functions?
14:53:53 <glguy> $! isn't doing anything there, [] is already evaluated
14:53:54 <monochrom> None.  It only seqs the [] there.
14:54:00 <dmwit> hexchat in xpra, then forward that X session wherever via ssh. If you need Windows start a VNC server on a middleman.
14:54:05 <mobile_c> is it true that haskel uses asm self modification 
14:54:10 <lavalike> I wasn't sure how to figure that out
14:54:17 <monochrom> No.
14:54:23 <glguy> lavalike: You can look at the implementation of $!
14:54:29 <dmwit> ?src ($!)
14:54:30 <lambdabot> f $! x = x `seq` f x
14:54:30 <lavalike> @src ($!)
14:54:30 <lambdabot> f $! x = x `seq` f x
14:54:39 <Welkin> is it true that haskell will turn you into a werewolf if you use it on the nihgt of a full moon?
14:54:46 <mobile_c> lol
14:54:46 <monochrom> Err, oops.
14:54:55 <monochrom> Err, nevermind, I was right.
14:54:59 <dmwit> No, but only because I am already a werewolf.
14:55:04 <mobile_c> does haskill use any kind of self modification
14:55:07 <mobile_c> haskell*
14:55:07 <lavalike> I guess I want !$
14:55:08 <glguy> At least in the past the GHC runtime would need to write executable code at runtime for some FFI stubs
14:55:12 <dmwit> Now if you ask whether it will turn mobile_c into a werewolf that's a whole different story.
14:55:14 <glguy> but that's its
14:55:25 <koz_> dmwit: Werewolf?
14:55:25 <monochrom> No.
14:55:47 <dmwit> koz_: Werewolf!
14:55:51 <lavalike> f !$ x = f `seq` f x
14:55:54 <koz_> dmwit: That'd be a great name for a library.
14:56:08 <monochrom> I once, was lost. Were wolf, now human. Was blind, now ~, I see.
14:56:31 <glguy> I don't remember the details, but I'd guess it was to support wrappers exporting Haskell code to a C function pointer
14:56:34 <monochrom> f `seq` f x = f x
14:56:54 <glguy> You would have to run GHC compiled programs with special SELinux label
14:57:12 <dmwit> lavalike: Maybe you'd better start talking about what's motivating these questions.
14:57:16 <lavalike> (($) $! f) x
14:57:26 <monochrom> Because lazy or eager, both lambda calculi evaluates f until it's a lambda first.  And seq f whatever does just that too.  seq f whatever is redundant.
14:57:28 <lavalike> let's say (($) $! f) []
14:57:41 <glguy> lavalike:   f `seq` f x   is the same as     f x
14:59:23 <lavalike> I am using the   prefix . (element:)   structure to build a list, applied to [] to finalize it
14:59:42 <monochrom> Yeah I was telling a white lie when I said "no" to "does it self-modify?".  If you use the "foreign wrapper" thing, it contains a bit of self-modification.
14:59:48 <dmwit> ooo, it's like a seq law. seq a b c = seq a (b c)
14:59:50 <monochrom> But that's it.  None other.
15:00:00 <dmwit> lavalike: Cool, I'm with you so far.
15:00:19 <lavalike> I was thinking it would be a good idea to make sure I don't leave unevaluated compositions hanging there if the consumer doesn't look at them
15:00:51 <dmwit> GC should already take care of that for you, no?
15:00:58 <mobile_c> variables cannot be re declared? 0.0 "But in Haskell, the language is defined such that you can only assign a value to a variable once, and then never assigned anything to it ever again "
15:01:09 <glguy> lavalike: There's nothing to fix with seq there
15:01:23 <dmwit> mobile_c: There's shadowing.
15:01:42 <mobile_c> eg x = 0; x = x + 1
15:01:53 <dmwit> mobile_c: You might like https://stackoverflow.com/q/44406434/791604
15:01:57 <monochrom> There is no looping construct.  You don't need mutable variables.
15:02:03 <mobile_c> would that be illigal in haskell
15:02:04 <lavalike> suppose you're not returning 1 of such lists, but a list of lists made up of compositions applied to []
15:02:11 <dmwit> mobile_c: `x = x + 1` will almost certainly not do what you are hoping. It is valid syntax, though, with a well-defined meaning.
15:02:28 <lavalike> if the consumer calculates length of that value, the memory will look like a list of pointer to thunks right?
15:02:40 <dmwit> > let x = 1 : x in x -- v. similar example to your x = 1 + x thing
15:02:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:02:45 <glguy> lavalike: You can't ask for the length of a function
15:02:51 <zachk> mobile_c, if you want mutable variables you can try Data.IORef's for starters
15:03:03 <Welkin> avoid IORef unless you now what you are doing
15:03:04 <zachk> but it might not be what you really need!
15:03:08 <Welkin> it is almost never the solution
15:03:17 <lavalike> glguy: I guess I didn't express myself well: I meant if you return a list of lists, and the element-lists are built as compositions applied to []
15:03:22 <mobile_c> like, every declared valiable is a constant read-only regardless of how it is declared and attempting to re-declare it or update its value will immediatly fail
15:03:32 <dmwit> ?let data N = Z | S N deriving (Eq, Ord, Read, Show); instance Num N where Z + n = n; S n + n' = S (n + n'); fromInteger 0 = Z; fromInteger n = S (fromInteger n-1)
15:03:34 <lambdabot>  .L.hs:238:10: warning: [-Wmissing-methods]
15:03:34 <lambdabot>      • No explicit implementation for
15:03:34 <lambdabot>          ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
15:03:40 <mobile_c> thus any changed need to go to a new variable
15:03:44 <dmwit> > let x = 1+x in x
15:03:47 <lambdabot>  *Exception: <<loop>>
15:03:54 <glguy> lavalike: Ok. You can just apply length to the result of applying your function to []
15:04:05 <lavalike> glguy: code is clearer I guess https://pastebin.com/raw/rtsVvAWm
15:04:17 <dmwit> > let x = 1+x in x :: N
15:04:19 <lambdabot>  error:
15:04:19 <lambdabot>      Not in scope: type constructor or class ‘N’
15:04:25 <monochrom> lavalike: Yes. But consider the tools in Control.Seq.
15:04:32 <dmwit> ...huh
15:04:41 <lavalike> monochrom: OK
15:04:53 <orzo> Is there a type-level nat somewhere for the size of types Int and Word?
15:05:21 <Welkin> > maxBound :: Int
15:05:23 <lambdabot>  9223372036854775807
15:05:24 <Welkin> > maxBound :: Word
15:05:25 <monochrom> I don't expect lambdabot to know "N".
15:05:27 <lambdabot>  18446744073709551615
15:05:34 <Welkin> no idea about a type level value for that
15:05:44 <glguy> lavalike: You don't need $ to apply a function to an argument
15:05:49 <mobile_c> god how do haskel programs work with immutable values o.o
15:05:49 <Welkin> oh, byte size?
15:05:53 <glguy> [ys []] is fine
15:05:55 <lavalike> glguy: I only did it for clarity there, to be explicit
15:05:56 <orzo> i want a byte-count, not a maximum 
15:06:02 <dmwit> mobile_c: Even though I declared it via ?let earlier?
15:06:04 <Welkin> mobile_c: you are thinking about it wrong
15:06:07 <orzo> even so, i need type-level
15:06:09 <dmwit> monochrom: That was for you, not mobile_c, sorry.
15:06:10 <mobile_c> do they like have 100 times the variables of a standard language with mutable variables
15:06:13 <julianleviston> mobile_c: primarily by scoping.
15:06:16 <glguy> lavalike: OK, you can make the code better by not doing that. There's nothing to do with forcing those compositions
15:06:16 <Welkin> you don't declare/assign  variable
15:06:24 <monochrom> Oh oops.
15:06:33 <glguy> lavalike: It might be more efficient to just build up a list and then reverse it at the end, you'd need to benchmark it
15:06:35 <julianleviston> Welkin: it’s usually not a great idea to tell someone they’re thinking about it wrong :) I guess it depends how you want them to feel :)
15:06:43 <lavalike> glguy: I thought it would be equivalent, using $ there is worse in some respect?
15:06:46 <monochrom> Perhaps someone issued an @undefine?
15:06:54 <glguy> lavalike: It's just noise, it's not making anything more explicit
15:07:02 <dmwit> Yes, perhaps.
15:07:05 <julianleviston> mobile_c: not really
15:07:07 <mobile_c> like let a = 0; let b = 1 + a; if a == 0 let c = 5 + b
15:07:11 <monochrom> Perhaps someone even implemented my evil wish of "issue @undefine every 15 seconds"? >:)
15:07:26 <mobile_c> or something like that
15:07:28 <lavalike> glguy: my first stab at it had a couple of reverses but I like this one better, do you mean reversing the inner lists or the outer one?
15:07:43 <Welkin> mobile_c: just start learning haskell and you'll understand
15:07:43 <julianleviston> mobile_c: we usually think of the in and out types for a function first
15:07:51 <glguy> lavalike: reversing any list you were building up using difference lists and composition
15:08:04 <mobile_c> anyway
15:08:05 <lavalike> difference list is the name of this construction! I couldn't remember
15:08:15 <mobile_c> what type of parser does haskell use
15:08:27 <mobile_c> to parse its own language
15:08:30 <julianleviston> mobile_c: using rosetta code to look up common things will help you to undersatnd, tho I’d be wary of assuming you undersatnd the haskell — what Welcon said is great advice
15:08:55 <julianleviston> mobile_c: the answer to that depends on how much you know about parsers.
15:08:57 <monochrom> mobile_c: You shall use recursion. And when you make a recursive call with modified parameters, that subsumes what mutable variables do in loops.
15:09:46 <dstolfa> if you want mutability, use the state monad vOv
15:09:52 <dmwit> mobile_c: GHC uses a grammar implemented with happy, a parser generator for Haskell (akin to bison for C).
15:09:54 <dsturnbull> the in and out types concept is a good way to think about it. imagine how map/reduce works where you can't mutate the variables. you can still get a lot of processing done
15:09:54 <monochrom> And at the beginner level, the only purpose of mutable variables is to make loops meaningful.  But we're getting rid of loops.
15:10:01 <julianleviston> mobile_c: it’s a thing called Happy
15:10:06 <Welkin> recursion is the same as a loop
15:10:21 <julianleviston> mobile_c: https://www.haskell.org/happy/
15:10:33 <dstolfa> Welkin: modulo some things being easier with recursion
15:10:35 <mobile_c> like most languages use a context sensitive or context free parser right?
15:10:38 <julianleviston> mobile_c: tho I’m not sure why you want to know how it parses its source code
15:10:43 <dstolfa> Welkin: like proving termination for primitively recursive fns
15:10:51 <isd> Patch submitted: https://github.com/ghc/ghc/pull/210
15:10:59 <mobile_c> or a type 1 or type 2 parser
15:11:03 <dstolfa> Welkin: i appreciate this is not relevant, but i don't have a better input :<
15:11:05 <Welkin> they both get compiled to similar jump instructions in machine code
15:11:26 <lavalike> glguy: do you know what does "difference" refer to in this composition construction? I don't see what's subtracted from what, it seems more about summing
15:11:28 <Welkin> they accomplish the same objective
15:11:41 <monochrom> Down that slippery slope you also get to conclude that recursions and loops are the same as jumps.
15:11:43 <dstolfa> Welkin: just... don't mind me, i'm derailing the conversation :-)
15:11:54 <julianleviston> mobile_c: if you want to know more about the compiler, https://wiki.haskell.org/GHC
15:12:07 <dstolfa> also, ackermann function
15:12:12 <monochrom> (I'm fine if you swear you stand by that too.)
15:12:33 <monochrom> Oh oh dstolfa I have something for you on that note.
15:12:39 <mobile_c> like does haskell use a type 0, 1, 2, or 3 parser
15:13:06 <monochrom> http://www.vex.net/~trebla/compsci/imperative-functional.html
15:13:24 <dmwit> I have no objection to this question, but I do find it strange. Did you ask what parser GCC used before you learned C?
15:13:42 <glguy> lavalike: Dunno :)
15:13:50 <monochrom> mobile_c: I don't understand the question.  How would you answer it if the language were C?  Perl?
15:14:04 <lavalike> ^_^
15:14:14 <dstolfa> monochrom: :-)
15:14:18 <Welkin> the programmer never needs to know the internals of a compiler. If they do, then the language is broken
15:14:26 <glguy> monochrom: I think for Perl the answer is that it doesnt' use a parser
15:14:28 <mobile_c> im trying to find a valid language that uses a type 0 or type 1 parser
15:14:36 <MarcelineVQ> Welkin: It's good to know them anyway
15:14:43 <julianleviston> mobile_c: what does type 0 or type 1 parser mean *to you*
15:14:44 <monochrom> I should just walk away.
15:15:00 <julianleviston> do you mean an LR 0 parser?
15:15:06 <monochrom> Like, why do we have so many crackpot questions lately.
15:15:13 <Welkin> monochrom: easy money!
15:15:22 <julianleviston> it’s probably for a assignment is my guess
15:15:25 <julianleviston> an*
15:15:29 <zachk> earn easy money, with this one weird trick!
15:15:31 <Rembane_> I wonder which assignment.
15:16:24 <monochrom> lavalike: I think ("xxx" ++) . ("yyy" ++) . ("zzz" ++) is called a difference list because "xxx" is a difference, "yyy" is a difference, etc.
15:16:48 <julianleviston> mobile_c: if you’re really interested, I suggest reading this http://www.aosabook.org/en/ghc.html and learning a bit of haskell and reading this https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Parser
15:16:54 <mobile_c> as in CHOMSKY HEIRACHY
15:17:05 <Welkin> gnome chompsky
15:17:30 <julianleviston> https://www.reddit.com/r/haskell/comments/6dwutk/chomsky_hierarchy_parsec/
15:17:35 <hpc> kde chompsky
15:17:55 <julianleviston> mobile_c: does that reddit question answer it for you?
15:17:58 <monochrom> I prefer whisky to chompsky.
15:19:39 <julianleviston> mobile_c: interestingly, haskell is a rich breeding ground for parsers… due to the fact that we have algebraic data types in the language as first class citizens (ie you can make your own data types)… which means BNF is often quite easily translated to Haskell… as a result, there are many many different types of parsers in Haskell
15:20:34 <mobile_c> https://i.imgur.com/2lGpLeK.png
15:20:39 <julianleviston> mobile_c: that’s one reason why we have the Happy tool/library — it lets us generate parsers in other languages from a parser definition file.
15:21:03 <julianleviston> mobile_c: did you read the linked reddit post?
15:21:32 <juanxc> Hi there, I wanted to know if somebody can help me with this. Is there a way to make this? (Lens s a, Lens s b) -> Lens s (a, b) ?
15:22:01 <juanxc> ps: i was wondering why was happy around haskell, where there are so many parser options
15:22:07 <glguy> juanxc: Not in general, no. things fall apart if the two input lenses refer to overlapping regions
15:22:20 <hpc> juanxc: sometimes you just want to use a stand-alone parser
15:22:24 <dmwit> juanxc: https://stackoverflow.com/q/36521208/791604
15:22:37 <mobile_c> how can type 2 target a type 0 grammar
15:22:48 <glguy> http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Unsound.html#v:lensProduct
15:23:15 <t7> is there a lazy mapM ?
15:23:17 <monochrom> juanxc: Parsec etc may be too slow.  Yacc generates C code not Haskell code; GHC wants Haskell code.  Probably Hugs uses Yacc or Bison actually, haven't really checked.
15:23:23 <juanxc> thanks dmwit :)
15:23:36 <dmwit> juanxc: There is also https://stackoverflow.com/q/26722458/791604 if you only need the getter.
15:23:45 <glguy> t7: mapM is as lazy is the underlying Monad's >>= implementation and the underlying Traversable instance is
15:24:07 <juanxc> thanks everyone
15:24:07 <julianleviston> mobile_c: this channel is mostly for haskell, so most people here know more about haskell than parsers, necessarily. Just saying you might not get a huge amount of feedback about abstract parser knowledge in here
15:24:58 <julianleviston> mobile_c: on the other hand if you asked a question on SO or reddit, I’m fairly sure someone would pipe up and answer your question pretty quickly :)
15:25:01 <lavalike> monochrom: ah I see what you mean, it's like git commits, I mean, git differences (;
15:25:10 <monochrom> Yeah!
15:25:14 <glguy> juanxc: Happy is good for making efficient parsers for languages where you can more clearly see what it is the parser handles, The grammar is clearly separated from the code, and you get feedback when your grammar is ambiguous
15:25:24 <dmwit> lavalike: seems http://logicaltypes.blogspot.com/2008/08/using-difference-lists.html discusses the etymology a bit
15:25:33 <monochrom> "commit list".
15:25:52 <monochrom> newtype CommitList a = CL ([a] -> [a])
15:26:11 <dmwit> lavalike: dlists are `(xs++)` for some `xs`, which the Prolog folks thought of as `xs++ys - ys`.
15:26:39 <monochrom> Oh, the difference is the suffix not the prefix?
15:26:55 <lavalike> I define subtraction as A + B - B as well
15:27:09 <monochrom> Err nevermind, the difference is still the prefix.  A+B-B = A.
15:27:33 <monochrom> Anyway, neato.
15:27:51 * hackage yoda 0.1.0.0 - Parser combinators for young padawans  http://hackage.haskell.org/package/yoda-0.1.0.0 (NicolasWu)
15:27:57 <lavalike> it must have something to do with the fact that such a shape in prolog will let you explore the definition both ways or something to that effect
15:28:24 <dmwit> lavalike: Yes, it is a bizarre way to arrive at the name, I agree.
15:28:51 <mobile_c> happy supports dynamic tokens right?
15:29:05 <lavalike> if I'm not too mistaken in prolog you can provide X and calculate Y just as well as providing Y and calculating X
15:29:21 * dmwit nods agreeably
15:29:31 <monochrom> Yes.
15:30:21 <ski> (fwiw, diff. lists in LP isn't quite the same concept than diff. lists in FP. they are just somewhat similar, used for somewhat similar purposes)
15:30:42 <orzo> I have a type class for polykinded argument.  I want to provide a default definition for kind *.  Can DefaultSignatures do this?
15:31:31 <Solonarv_> probably? I suggest just trying it
15:31:41 <orzo> i can't figure out the syntax
15:31:45 <mobile_c> for example,   Exp   : let var '=' Exp in Exp  can 'var' itself change dynamically during parsing as if it is a literal global mutablevariable
15:32:19 <orzo> how do i default a type using DefaultSignatures?
15:32:37 <orzo> i've only used it for defaulting functions
15:33:00 <ski> mobile_c : it's immutable
15:33:37 <mobile_c> eg home : $HOME { HOME=A }           and say HOME was previously B, if B is seen it will change HOME to A and then look for A instead of B, is happy capable of accomplishing that
15:33:47 <ski> mobile_c : you can still express changing stuff (e.g. parser state)
15:34:13 <orzo> i have: type TypeOf t :: Type for polykinded t, but I want to default it to type TypeOf t = t for t::*
15:34:53 <mobile_c> thus making, for example, the string "BA" parsable in just the home sentence provided HOME is iniially B
15:34:55 * ski doesn't follow `$HOME { HOME=A }', and what it would have to do with parsing with Happy
15:36:12 <ski> hm, sounds likt you're talking about manipulation of the parser state of the remaining tokens to parse
15:36:48 <mobile_c> eg sees "BA" goes to home : B { ... } changes B to A and consumes B, sees "A" and goes to home : A { ... } changes A to A and consumes A
15:36:52 <ski> pushback of `"A"' to the remaining tokens, after parsing `"B"
15:36:58 <ski> ', mobile_c is that right ?
15:37:38 <mobile_c> ski: i guess
15:38:57 <ski> hm, you can express that with an extension to DCG, in Prolog
15:39:51 <mobile_c> ski: tho if u wanted "[08:36] <ski> pushback of `"A"' to the remaining tokens, after parsing `"B"" u could just do home : VAR { VAR=whatever_the_input_stread_variable_is[1]} to automatically change VAR to the next letter of the stream
15:40:31 <mobile_c> provided VAR is initially the first letter of the stream
15:40:35 * ski doesn't follow
15:41:38 <mobile_c> in wich u could do first : . {VAR=whatever_the_input_stread_variable_is[1]} to make VAR be the next character after reading any char provided VAR is reached before the any char is
15:42:08 <mobile_c> otherwise the first will always be executed cus it is the first to match and will always match
15:42:29 <mobile_c> as it matches anything and everything
15:43:05 <ski> with DCG, you can e.g. express a parser `B => BA' such that if the tokens to consume is `"A"', then the parser will (first) *add* `"B"' (in front of `"A"') to the parser state, before attempting to parse using parser `BA', which then may succeed (say) by consuming the tokens `"BA"', thus succeeding
15:43:37 <ski> however, `B => BA' *first* adds (assumes) `B', before attempting to parse using `BA'
15:44:04 <mobile_c> but that only works for a fixed string right
15:44:34 <ski> while in your case (which can also be expressed using DCG, but which isn't clear has a logical reading), we had the opposite order
15:44:59 <ski> you could compute `"B"' at run-time, if you wanted to
15:45:06 <mobile_c> how
15:47:05 <mobile_c> an exemple which is extreamly common would be attempting to parse a heredoc in wich its actual terminator is dynamic and CANNOT be parsed statically
15:47:12 <mobile_c> example*
15:47:47 <ski> let's say `ts ||- p' means that given tokens `ts', `p' can succeed, consuming all the tokens. then by `lit ts' we can express a parser succeeding when consuming exactly `ts' (and otherwise failing). so `ts ||- lit ts' (or more precisely `ts0 ||- lit ts1' iff `ts0 = ts1')
15:49:18 <ski> also, `p0 /\ p1' means the parser that will first parse according to `p0', then by `p1', iow if `ts0 ||- p0' and `ts1 ||- p1', then `ts0 ++ ts1 ||- p0 /\ p1'
15:49:21 * hackage fltkhs-themes 0.1.0.0 -   http://hackage.haskell.org/package/fltkhs-themes-0.1.0.0 (deech)
15:50:17 <ski> (more exactly, `ts ||- p0 /\ p1' iff there exists `ts0' and `ts1' with `ts = ts0 ++ ts1' such that `ts0 ||- p0' and `ts1 ||- p1')
15:50:34 <mobile_c> ?
15:51:09 <ski> this is just a (logical style) formalization of the acceptance relation between a parser and its consumed input
15:51:34 <indomitable> This channel scares me.
15:51:42 <julianleviston> indomitable: aw why?
15:51:42 <mobile_c> indomitable: same x.x
15:51:57 <ski> (DCG (Definite Clause Grammar) in Prolog works something similar to this. though using somewhat different syntax)
15:52:05 <monochrom> Talk to me.  I am not scary.
15:52:15 <julianleviston> I don’t think any of us are, personally :)
15:53:04 <julianleviston> if we take that we can’t possibly know everything because we’re just one person… then it stops being so scary, and it’s just a bunch of folks trying to help each other understand more about Haskell and related topics
15:53:16 <ski> .. anyway, i'm just reflecting on mobile_c's operation "first parse using `B', then add `A' to token state", pondering how (if) that could be fit into the same scheme, and what it'd (logically) mean then
15:53:56 <ski> i'm more thinking aloud, that expecting you to necessarily follow the details of the reasoning
15:54:15 <ski> (but perhaps someone else here is interested in following the details more)
15:54:30 <ski> mobile_c : makes any sense ?
15:56:15 <ski> anyway, for alternation, `p0 \/ p1' means a parser that will accept anything `p0' accepts, and also anything `p1' accepts. iow `ts ||- p0 \/ p1' if and only if `ts ||- p0' and `ts ||- p1' (this one was simpler than `p0 /\ p1', iow sequencing of parsers, above)
15:57:41 <ski> now, one can extend DCG to express a parser `lit ts0 => p1' such that it will first add `ts0' to (the front of) the token state, before attempting to parse using `p1'
15:59:00 * _deepfire wishes TypeCompose's (:.) was polykinded
15:59:02 <ski> i.e. we want the parsing problem `ts1 ||- lit ts0 => p1' (iow attempt parsing tokens `ts1', using parser `lit ts0 => p1'), which continues by `ts0 ++ ts1 ||- p1' (attempt to parse `ts0 ++ ts1', using `p1')
16:00:08 <ski> (more specifically, `ts1 ||- lit ts0 => p1' if and only if `ts0 ++ ts1 ||- p1')
16:01:56 <ski> (btw, attempting to generalize `lit ts0 => p1' to `p0 => p1', where `p0' is any parser, is harder to implement. the problem is that `p0' may succeed in several different ways, and we want to check that, adding the corresponding tokens in front of the token state, we can make `p1' succeed for *every* such case)
16:03:18 <indomitable> julianleviston, do you understand what ski is saying?
16:04:06 * ski would be glad to get ski fully understanding what ski is saying
16:04:17 <Rembane_> ski: fix ski ... 
16:05:03 <ski> anyway, so far i'm skirting the edges of what mobile_c was asking about
16:05:38 <ski> now, how to express "first parse using `p0', then add `ts1' to parser state" ?
16:05:48 <sssilver> I was surprised to find out that Haskell was created early 90ies... I thought it'd come from like 60ies
16:05:53 <sssilver> but like
16:06:07 <Zemyla> Rembane_: I'm pretty sure you need mfix ski.
16:06:14 <sssilver> why create Haskell at a time and in a world that already had C and C++
16:06:24 <Rembane_> Zemyla: Good point. 
16:06:28 <_deepfire> monochrom: can I ask you to help me validate my wish? I think that TypeCompose's (:.) is unable to be instantiated as ((* -> *) -> ([*] -> *) -> [*] -> *)
16:07:01 <Rembane_> sssilver: To have one research language to put in the research papers so you didn't need to invent your own language for every research paper. Saved lots of time. 
16:07:09 <monochrom> I haven't looked at TypeCompose.  But if you already tried and you got a kind error, then your conclusion was right.
16:07:27 <_deepfire> http://hackage.haskell.org/package/TypeCompose-0.9.13/docs/Control-Compose.html#t::.
16:08:18 <monochrom> No, why create C and C++ in a world that already had Haskell.
16:08:20 <Zemyla> sssilver: Why not just stop language development altogether once Stroustrup created C++?
16:08:27 <mobile_c> ski: is that for me
16:08:46 <mobile_c> "[09:05] <ski> now, how to express "first parse using `p0', then add `ts1' to parser state" ?"
16:09:08 <monochrom> And why create Perl when the world already had TCL.
16:09:08 <ski> hm, `lit ts0 => (lit ts0 /\ p1)' is equivalent to just `p1' (adding `ts0' in front of parsing state, then consuming `ts0' from front of parsing state, continuing with letting `p' consume the remainder, is the same as just letting `p' consume the initial tokens)
16:09:16 <ski> mobile_c : that's regarding your query, yes
16:09:16 <sssilver> Zemyla: yeah, tbh idk why people don't just code everything in C++
16:09:21 <sssilver> that'd make everything a lot easier
16:09:41 <monochrom> No, C++ is harder for me, Haskell is easier.
16:09:41 <Tuplanolla> Except the actual code, most likely.
16:09:56 <monochrom> But are you trying to troll this channel.
16:10:15 <dstolfa> monochrom: it's quite obvious that he/she is
16:10:21 <sssilver> well, C++ does have const, and lambdas, and map, and filter, and reduce, so.. but guess that's offtopic
16:10:28 <sssilver> also not trolling
16:10:34 <sssilver> I was legitimately surprised to find out how new Haskell was
16:10:37 <monochrom> C++ didn't have lambda for a long time.
16:10:42 <sssilver> that's true
16:10:43 <hpc> sssilver: it doesn't have zygohistomorphic prepromorphisms though :D
16:10:45 <mobile_c> would ts1 be defined as a rule
16:11:03 <monochrom> C++ learned lambda from Java, and Java from Haskell.  C++ is still struggling to learn type classes.
16:11:04 <mobile_c> like ts1 : ,,,
16:11:15 <sssilver> monochrom: "concepts" are a thing, kind of
16:11:15 <ski> `ts1' is just some example stokens, like `"DEF"'
16:11:23 <ski> s/stokens/tokens/
16:11:30 <monochrom> Yes, C++ is still learning how to do concepts.
16:11:47 <Rembane_> C++ templates though. Cool stuff.
16:11:49 <dstolfa> C++ is still learning how to be as insane as it can be
16:12:09 <_deepfire> entrenched
16:12:10 <hpc> Rembane_: not that cool, it's just code generation
16:12:26 <mobile_c> then it would be (rough estimate) first : p0 { p0 = "DEF" + p0 }
16:12:32 * dstolfa -> bed
16:12:41 <sssilver> it'd be intriguing to see a flavor of Haskell that leverages the type system in a way that allows it to ditch the garbage collector and focus on performance
16:12:47 <mobile_c> ski: 
16:12:54 <_deepfire> Rembane_: given that you find templates cool -- are you familiar with Lisp macros?
16:12:58 <Rembane_> hpc: Code generation is cool! 
16:12:59 <ski> mobile_c : yes ?
16:13:05 <mobile_c> ski: then it would be (rough estimate) first : p0 { p0 = "DEF" + p0 }
16:13:09 <Rembane_> _deepfire: Nope. Haven't really lisped any. 
16:13:19 <monochrom> Perhaps you should consider Rust.
16:13:29 <sssilver> monochrom: I code in it every day for a living
16:13:37 <sssilver> but it's not quite Haskell
16:13:43 <monochrom> If you ditch GC you ditch purity as well.
16:13:46 <ski> mobile_c : i'm not quite sure i understand that notation. can you elaborate on what it means ?
16:13:58 <monochrom> If you ditch purity you ditch 90% of Haskell.
16:14:08 <_deepfire> Rembane_: there is a chance you might find yourself terrified by Lisp macros being regular Lisp & partially sharing function namespace with run-time code.
16:14:18 <sssilver> monochrom: do you mind elaborating on how ditching gc impacts purity?
16:14:19 <mobile_c> ski: or first : p0 { p0 = ts1 + p0 }    if ts1 is also a dynamic variable
16:14:23 <ski> (or at least, not quite sure how it applies in this case)
16:14:33 <ski> what does `p0 = ts1 + p0' mean here ?
16:14:47 <mobile_c> ski: idk how to join strings in halkell/happy xP
16:14:51 <monochrom> Consider how absurd it is to say "like Haskell but can solve xs++ys = zs for ys and yet I refuse to call it logic programming".
16:15:14 <ski> mobile_c : don't worry about Haskell/Happy atm. use any notation you like, as long as you explain what you mean
16:15:17 <monochrom> If you ditch GC you have to add back explicit "new" and "free".
16:15:46 <monochrom> So now the heap is an explicit mutable state you mutate via "new" and "free".
16:15:56 <Tuplanolla> You could also give up dynamic memory allocation.
16:16:28 <mobile_c> ski: then assuming all variables start with $ , it would be first : $p0 { p0 = "$ts1$p0" }
16:16:32 <ski> monochrom : .. or, perhaps, you have to restrict in some way so that e.g. (inferred) region-based memory management is enough
16:16:41 <monochrom> OK.
16:16:48 <Rembane_> _deepfire: That sounds insane in a very interesting way.
16:16:55 <monochrom> JHC got really close.  It gave up deallocation.
16:17:03 <mobile_c> assiming variable substitusion takes plase in strings
16:17:08 <mobile_c> place*
16:17:10 <ski> hehe, the trivial GC, which never frees
16:17:56 <_deepfire> Rembane_: Lisp has a very profound, very old kind of insanity that has a name -- homoiconicity -- code is data. #'COMPILE is a run-time function
16:18:16 <lavalike> Garbage Hoarder, not just Collector
16:18:26 <ski> mobile_c : i assume that is a rule saying what to do if we reach parser state `$p0' (by which we mean when we attempt to parse using parser `$p0', the token state not mentioned explicitly here), yes ?
16:18:38 <Rembane_> _deepfire: I really dig that. Assembler has it too. :D
16:18:51 <_deepfire> Rembane_: http://clhs.lisp.se/Body/f_cmp.htm
16:18:52 <ski> mobile_c : but i'm still not sure what parser action `p0 = "$ts1$p0"' is meant to express, there
16:19:05 <indomitable> _deepfire, lest it also stare into you
16:19:14 <Rembane_> _deepfire: Thank you! 
16:19:24 <_deepfire> indomitable: I ran away screaming after years of Lisp
16:19:37 <mobile_c> ski: p0 = the value of ts1 and the value of t0 as a string
16:19:39 <_deepfire> untyped languages are for _really_ strong minds
16:19:40 <mobile_c> p0*
16:19:42 <monochrom> Regions are pretty restrictive; either that, or it degenerates to "just don't deallocate".  Consider how, for example, the observer pattern spreads the reference to your object all over the place.
16:19:58 <hpc> i learned lisp after haskell, and treated it as if it was unlambda with syntax sugar
16:20:02 <indomitable> _deepfire, your mind will never be the same. you have been lisped.
16:20:58 <mobile_c> (as it would be difficult if ts0 was a rule instead of a string as you would need to further evaluate the rule ts0 before you can obtain its value
16:21:10 <ski> <mobile_c> happy supports dynamic tokens right?
16:21:15 <ski> <mobile_c> for example,   Exp   : let var '=' Exp in Exp  can 'var' itself change dynamically during parsing as if it is a literal global mutablevariable
16:21:30 <ski> <mobile_c> eg home : $HOME { HOME=A }           and say HOME was previously B, if B is seen it will change HOME to A and then look for A instead of B, is happy capable of accomplishing that
16:21:34 <ski> <mobile_c> thus making, for example, the string "BA" parsable in just the home sentence provided HOME is iniially B
16:21:48 <ski> <mobile_c> eg sees "BA" goes to home : B { ... } changes B to A and consumes B, sees "A" and goes to home : A { ... } changes A to A and consumes A
16:22:01 <indomitable> every time you say "Happy" I think of that Christmas-themed psychotic murder TV show
16:22:09 <mobile_c> XD
16:22:09 <ski> <mobile_c> ski: tho if u wanted "[08:36] <ski> pushback of `"A"' to the remaining tokens, after parsing `"B"" u could just do home : VAR { VAR=whatever_the_input_stread_variable_is[1]} to automatically change VAR to the next letter of the stream
16:22:15 <ski> <mobile_c> provided VAR is initially the first letter of the stream
16:22:25 <ski> <mobile_c> in wich u could do first : . {VAR=whatever_the_input_stread_variable_is[1]} to make VAR be the next character after reading any char provided VAR is reached before the any char is
16:22:32 <mobile_c> ski: lol
16:22:33 <ski> <mobile_c> otherwise the first will always be executed cus it is the first to match and will always match
16:22:39 <mobile_c> ski: spam abuse XD
16:22:41 <hpc> indomitable: yeah it's not a very good name - whenever i think of yacc the word "happy" is last on my mind
16:22:46 <ski> <mobile_c> as it matches anything and everything
16:22:54 <ski> <mobile_c> but that only works for a fixed string right
16:23:09 <ski> <mobile_c> an example which is extreamly common would be attempting to parse a heredoc in wich its actual terminator is dynamic and CANNOT be parsed statically
16:23:24 * mobile_c wonders if ski will get kicked for spamming
16:23:40 <indomitable> ski, can you and mobile_c talk this out in pm?
16:23:40 <ski> (ok, sorry for repetition. i wanted to keep what you said initially, closer, so that we can more easily refer to it, and discuss it)
16:23:56 <mobile_c> ski: lol ok
16:23:58 <ski> hm, sure, we could move to #haskell-overflow
16:23:59 <indomitable> I feel like your relationship has some issues and you need to talk things out before you can kiss and make up
16:24:06 <ski> hehe :)
16:24:13 <mobile_c> indomitable: lmao
16:24:29 <monochrom> Wait, I thought they had to be married for that.
16:24:37 <monochrom> "You may kiss your bride."
16:24:39 <indomitable> I don't think the church of Haskell minds.
16:24:54 <indomitable> In fact they might ... Curry favour.
16:24:55 <indomitable> :D
16:25:20 <hpc> /kick indomitable :D
16:25:31 <indomitable> :<
16:30:56 <julianleviston> I just read “the church of haskell minds”… then realised minds wasn’t a plural noun but rather a verb in a subordinate clause.
16:31:20 <_deepfire> Sorry to be an attention whore, but does anyone see a reason why
16:31:20 <_deepfire>   http://hackage.haskell.org/package/TypeCompose-0.9.13/docs/Control-Compose.html#t::. wouldn't
16:31:20 <_deepfire>   be instantiable as ((* -> *) -> ([*] -> *) -> [*] -> *) ?
16:31:36 <_deepfire> argh, sorry for multiline, paste mishap
16:31:50 <indomitable> julianleviston, I'm sorry for confusing your brain.
16:32:00 <julianleviston> indomitable: au contraire, I enjoyed it :)
16:32:25 <julianleviston> indomitable: and it wasn’t a confusion, it was a plasti-fusion ;-)
16:32:55 <indomitable> That's the best fusion, at least after jazz-fusion.
16:33:07 <indomitable> Arguably nuclear fusion depending on the context.
16:33:23 <julianleviston> I often enjoy confusion. list/collection fusion is pretty great.
16:37:20 <c_wraith> I'm a big fan of Korean-Mexican food fusion.
16:37:44 <julianleviston> That sounds super interesting
16:37:56 <c_wraith> :t confusing -- there is also this.
16:37:58 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
16:38:00 <chessai_> are those expressible in rewrite rules?
16:38:13 <julianleviston> c_wraith: oh that’s cool :) haha
16:41:44 <julianleviston> is Data.Functor.Day day convolution?
16:41:50 <c_wraith> yes
16:41:53 <julianleviston> nice
16:42:33 <c_wraith> iirc, day convolution is the category you work in to get Applicatives to be a monoid (at the type level)
16:43:26 <julianleviston> oh that’s a nice observation
16:45:16 <julianleviston> I used to hate the fact that learning one thing would involve basically a comonadic effect of learning, but now I really enjoy it
16:45:35 <julianleviston> https://ncatlab.org/nlab/show/convolution+product
16:45:40 <c_wraith> I think that's actually related to what confusing does, which is rewriting things that look like lenses that have been built by composition into a flatter structure.
16:46:20 <julianleviston> In what sense do you mean a flatter structure?
16:46:55 <hpc> julianleviston: it says nice things about you
16:47:16 <c_wraith> purely in terms of runtime efficiency. it fuses functions together so that fewer operations at an outer layer are required
16:47:31 <julianleviston> c_wraith: ooh
16:47:48 <julianleviston> c_wraith: like… flattening conditionals to booleans?
16:48:19 <hpc> julianleviston: it's a bit more like the distributive property
16:48:20 <julianleviston> c_wraith: I don’t mean exactly like that, but I mean in a sort of analogy? I often find that’s more undersatndable code when it’s rewritten like that.
16:48:33 <julianleviston> hpc: yeah, fusion is literally that after all 
16:48:41 <c_wraith> I think hpc has a better description than I was coming up with
16:49:00 <hpc> (a + c) * (b + c)
16:49:04 <hpc> or c * (a + b)
16:49:06 <julianleviston> I guess conditionals -> boolean logic is effectively a natural transformation? what is that, actually?
16:49:11 <hpc> imagine a world where (+) is crazy expensive
16:49:31 <julianleviston> also, I wnated to ask… what *IS* imperative programming? in the declarative sense? is it a state machine?
16:49:46 <julianleviston> hpc: right nice :)
16:50:00 <ski> julianleviston : "comonadic effect of learning" 
16:50:01 <ski> ?
16:50:03 <c_wraith> Hoare logic is a formal description of imperative programming
16:50:13 <c_wraith> that might be what you want
16:50:25 <julianleviston> ski: ah… sorry… so you open one thing to learn, then you end up opening two more, then five, then etc.
16:50:34 <ski> ah :)
16:50:36 <julianleviston> c_wraith: oooh I’ll have to look into that. :)
16:50:58 <julianleviston> c_wraith: tho I was interested in encoding that logic in Haskell I suppose - or not actually encoding it but rather bieng able to talk about it as data… like you can with FSMs
16:51:27 <julianleviston> ski: so that the effect is pretty much comonadic in terms of … opening things out continually like a stream would at each step.
16:51:52 <julianleviston> ski: not exactly precise tho, coz it’s a particular type of comonad that has almost explosive properties
16:52:03 <julianleviston> ski: just an amusing analogy, I guess
16:52:48 <ski> julianleviston : <https://en.wikipedia.org/wiki/Hoare_logic>,<https://en.wikipedia.org/wiki/Weakest_precondition_calculus>,<https://en.wikipedia.org/wiki/Dynamic_logic_(modal_logic)>
16:52:54 <julianleviston> ski: I wonder if there’s a way we could apply that to education… which I suppose is why we teach small children a very wide shallow range of things… so we can see if something piques interest and then they can get their own comonadic effect :)
16:53:09 <julianleviston> ski: marked to read . Thankyou :heart:
16:55:48 <julianleviston> c_wraith: so in the same way that we can say “here’s a Moore machine written in Haskell” can we also say “here’s a … Hoare logic machine? written in Haskell?” or is that like say “here’s a Boolean logic machine written in haskell” which one actually could do pretty easily.
16:56:15 <ski> (learning is often like a "spiral". first you learn A superficially, which enables (or points (piques)) you to learn B, and then C, and then you come back to learning A somewhat deeper (with more context about the things it's related to), and so on
16:56:18 <julianleviston> like… one can encode an algebra in haskell in a heartbeat
16:56:19 <ski> )
16:56:20 <c_wraith> you could certainly build encodings for Hoare logic in Haskell
16:56:45 <c_wraith> I liked edwardk's "learning as iterative deepening" analogy
16:56:49 <julianleviston> Yeah me too
16:56:57 <hpc> julianleviston: just look at what ADT stands for :D
16:57:02 <ski> that's also a nice one
16:57:08 <julianleviston> hpc: exactly :)
16:58:01 <julianleviston> c_wraith: it’s nice he referenced spaced repetition. As a language nut I’ve known about that for ages, but it’s cool that he’s bringing it to a larger crowd (ie logicians / programmers / software engineers)
16:58:31 <c_wraith> yeah, and I like how iterative deepening implies the repetition part directly.
16:58:51 <julianleviston> c_wraith: martial arts teaches this, too.
16:59:12 <c_wraith> I mean, the fact that it retraverses edges is a key feature of iterative deepening. 
16:59:28 <ski> what's "spaced repetition" ?
16:59:31 <julianleviston> ski: I often find it really fascinating that a multidisciplinary approach to things gives one a really good view of something. You attack something from many angles and you get a really nice rounded undersatnding of it.
17:00:02 <julianleviston> ski: it’s iterating on learning at intervals depending on how much you remember it
17:00:12 * ski . o O ( Den Ding an Sich )
17:00:20 <julianleviston> https://en.wikipedia.org/wiki/Spaced_repetition
17:00:23 <c_wraith> ski, do something, stop for a while, do it again. empirically it has the best results of learning methods that have been studied.
17:00:25 <_deepfire> I think the answer to my question is the lack of PolyKinds and kind signatures.
17:00:28 <ski> ok, ty
17:00:54 <ski> i suppose that describes my general pattern of getting interested in various topics
17:01:08 <julianleviston> :) yeah most people who are good at learning have “discovered” this by themselves anyway :)
17:01:30 <Rembane_> My method of screaming at a screen has worked quite well for Haskell, Agda and logic.
17:01:31 <julianleviston> and this is the talk everyone’s referencing: https://www.youtube.com/watch?v=Z8KcCU-p8QA
17:01:39 <ski> ty
17:02:13 <ski> @quote autodidact
17:02:13 <lambdabot> shapr says: I've tried to teach people autodidactism, but I've realized they have to learn it for themselves.
17:02:42 <c_wraith> that is a very shapr thing to say
17:02:56 <julianleviston> lol that’s awesome
17:03:08 <julianleviston> interestingly, tho, one can *inspire* it ;-)
17:03:40 <ski> (perhaps one could accelerate, or at least induce better conditions for, someone to learn it by themselves)
17:03:43 <julianleviston> and also, create conditions
17:03:51 * ski low fives julianleviston
17:03:52 <julianleviston> ski: :perfect:
17:03:55 <julianleviston> totes :)
17:08:38 <indomitable> @quote ski
17:08:38 <lambdabot> ski says: the truth (semantics), the whole truth (completeness), and nothing but the truth (soundness)
17:09:03 <MarcelineVQ> you boys are poets and you didn't even know, you were
17:13:25 <ski> heh
17:15:30 <ski> recently, i read something to the effect of (iirc) "each attribute depends on the key (1NF), the whole key (2NF), and nothing but the key (3NF)", regarding the first three formal forms in normalization in relational database theory
17:20:05 <ab9rf> ugh
17:20:08 <ab9rf> i hate normal form
17:23:26 <c_wraith> yeah, evaluating under a lambda is hard.
17:24:00 <ski> ab9rf : which / why ?
17:24:18 <geekosaur> it does complicate database design
17:24:35 <ski> (afaiui, there are a lot of misunderstandings about 1NF. e.g. about what "atomic attribute" means)
17:24:39 <geekosaur> on the other hand, not doing ti complicates everyhting after that
17:24:41 <ab9rf> ski: database normal form. slavish adherence to it leads to overcomplicated and inefficient schemas
17:25:06 <ski> ab9rf : well, i can probably agree to that :)
17:25:16 <ab9rf> it's a good thing to know about, though
17:25:27 <geekosaur> and yes, it can be overdone. but that requires some care, I've run into cases where it looked like it was overdoen and then suddenly was needed
17:25:36 <ab9rf> and i agree that failing to be aware of it can also lead to extremely poor database schemas as well
17:26:21 <geekosaur> (unwritten rule of database design: the customer never knows what they actually need)
17:26:26 <ski> (e.g. i don't think "atomic attribute" means, or at least, i don't think it ought to be read (interpreted) as, meaning that you can't have say records, lists, relations, trees, graphs, &c. as values in your tuple attributes)
17:26:37 <ab9rf> geekosaur: that's a general software engineering maxim
17:26:46 <geekosaur> ye
17:26:59 <ski> (generally, what i read about Date's reading of 1NF, sounds reasonable to me)
17:27:31 <ab9rf> iirc, there is rarely a good reason to fail to normalize to 1NF
17:28:17 <ski> that said, that doesn't excuse the usual ways in which to fail to adhere to 1NF that Codd wanted to get at
17:29:08 <ski> (oh, sorry, the "each attribute depends on the key (1NF), the whole key (2NF), and nothing but the key (3NF)" continued as "so help me Codd" :)
17:29:42 <ab9rf> i've seen far too many database applications that either had serious performance issues or had to be redesigned because someone went "sure, we can store a list as a single data element"
17:30:11 <ab9rf> microsoft active directory comes to mind
17:30:24 <ab9rf> it stored the membership of groups as a single element of list type
17:30:41 <ab9rf> this made updating the membership of large groups exceedingly expensive
17:31:11 <ab9rf> they ended up special-casing such element types in their engine
17:31:31 <ab9rf> so that accenture could actually use active directory
17:32:26 <ski> @remember normalization_folklore The data depends on the key [1NF], the whole key [2NF] and nothing but the key [3NF] (so help me Codd).
17:32:26 <lambdabot> Done.
17:33:03 <ab9rf> heh
17:33:37 <ski> (i read that at <https://stackoverflow.com/questions/723998/what-are-database-normal-forms-and-can-you-give-examples>. not sure where it comes from, originally)
17:34:04 <ski> ab9rf : yes, usually it's better to use a relation to individual list members, instead
17:34:34 <ski> (especially if the ordering in the list doesn't matter, and if it doesn't make sense to have duplication in the list)
17:35:27 <Rembane_> The more tables the merrier...
17:35:37 * ski grins
17:35:47 * ski dances on the table
17:36:36 <ab9rf> ski: the issue is that when a group has thousands or tens of thousands or even hundreds of thousands of members, any change requires replicating a Very Large object
17:36:58 <ski> aye
17:37:12 <ab9rf> but if you use an association table, a change of membership only erquires replicating a very small record
17:37:55 <ab9rf> it also allows for the relationship to be queried efficiently from either direction
17:39:07 <ab9rf> i've yelled at i don't know how many people for this sort of design error
17:39:57 <ski> yes
17:40:45 <ab9rf> i also want a mechanism that electroshocks any database design instructor who uses mailing addresses as an example for normalization
17:40:45 <ski> one example someone mentioned was wanting to store a graph (with nodes, and an edge relation between them) in a database
17:41:21 <ski> and then wanting to store *several* graphs, in a relation, associated with IDs, say
17:41:26 <ab9rf> i can't count how many times i've seen someone assert that you can determine postal city and state from zip code
17:41:41 <ski> the argument being that this would naturally be expressed via a relation-valued attribute
17:42:27 * ski doesn't live in the U.S., doesn't know how Zip codes work
17:42:43 <ab9rf> ski: they work great for the post office, and not so great for any other purpose
17:43:03 <ab9rf> ski: while there is a relationship between postal city and state and zip code, it's Complicated
17:43:28 <ski> does zip code together with state determine postal city ?
17:43:34 <ab9rf> ski: no
17:43:40 <ab9rf> ski: i live in one of the zip codes where it does not
17:43:55 <ab9rf> 60164 can be either Melrose Park or Northlake
17:44:00 <ski> ah, i see
17:44:18 <ab9rf> all of Northlake is in 60164, but some parts of Melrose Park are instead in 60160
17:44:23 <ski> messy/leaky abstractions, perhaps
17:44:44 <ab9rf> zip codes simply reflect carrier delivery routes
17:45:03 <geekosaur> whereas cities often reflect politics
17:45:16 <Rembane_> Joggrafy!
17:45:18 <ab9rf> and carriers don't care about municipal jurisdictional boundaries, since the postal service is run by the federal government
17:45:30 * geekosaur is in a similar situation, compounded by that he's in a different city for different purposes
17:45:45 <ab9rf> my postal city is melrose park, but i don't live in melrose park
17:46:17 <geekosaur> and then there's the folks who don't recognize the city, but instead an artificial "city" consisting of it and two or three others depending on what it's being used for
17:46:36 <geekosaur> you weren't really expecting sense here, were you?
17:46:59 <ab9rf> there is one zip code that is over 400 miles long end to end
17:47:20 <ab9rf> and others that are smaller than a breadbox
17:48:04 <ab9rf> there used to be a zip code that covered almost 90% of the world, but it was done away with about 20 years ago
17:48:47 <indomitable> geekosaur, I want to quote a wise man who once said "SANITY IS FOR THE WEAK"
17:49:14 <ski> anyway, another case where it makes sense to allow relational attributes in the model is "GROUP BY", which can be decomposed in terms of a "NEST" and an "UNNEST" primitive (so that "HAVING" then degenerates to a normal "WHERE")
17:49:28 <ab9rf> the thing is, postal addresses are exceedingly complicateed, very arbitrary, and rarely coherent, and yet database instructors persist in acting like there's enough of a functional dependency to justify trying to eliminate one or more of the components
17:49:28 <ski> that's more like allowing a relational attribute in a view, though
17:50:35 <geekosaur> indomitable, it's worse than that, it's all politics. sanity doesn't apply.
17:51:01 <ab9rf> the lovely town of Apo, New York
17:51:13 <Rembane_> ab9rf: I wonder if this implies that database instructors are insane.
17:51:14 <geekosaur> heh
17:51:19 <ab9rf> Rembane_: most likely
17:51:31 <geekosaur> lazy, and not in the useful haskell way
17:52:13 <ab9rf> i'm totally onboard with being lazy
17:52:26 <indomitable> geekosaur, politics is easy, input what people want to hear, output what people want to hear
17:52:44 <geekosaur> …actually do what makes more money
17:52:58 <indomitable> that's the side-effect
17:52:59 <indomitable> :P
17:53:01 <geekosaur> which s wy I'm in oe of fourdifferent cities depending on who gets their cut of what
17:53:14 * ski . o O ( "We will encourage you to develop the three great virtues of a programmer: laziness, impatience, and hubris." -- Larry Wall and Randal L. Schwartz )
17:53:49 * ski . o O ( "The Swine Before Perl" (Scheme/Racket talk) by Shriram Krishnamurthi in 2001-11 at <https://cs.brown.edu/~sk/Publications/Talks/SwineBeforePerl/> )
17:54:24 <ski> (hadn't seen/heard that one, until a couple of days ago. though i remember seeing the title before. possibly on LtU)
17:55:24 <geekosaur> "laziness, impatience, and hubris" has been a catchphrase in a number of programming circles for some years, mostly due to Randal
17:55:47 <fen> hey, could someone check this benchmark? https://bpaste.net/show/763f4676d8bb
17:55:48 <ski> ok
17:56:23 <ski> (by "that one", i mean that talk. the quote came from that talk, but i've probably seen some variation of it before)
17:57:05 <ski> (sigh. rather i mean i got the quote from that talk. not that the talk originated it)
18:01:33 <fen> the fastest version using NonEmpty is twice as slow as for []
18:01:42 <fen> cant figure out why...
18:04:57 <dmwit> fen: length on lists does fancy unboxing and stuff
18:05:23 <fen> hmm
18:05:34 <fen> ok ill make a foldable instance
18:05:49 <fen> or an instance of NFData...
18:05:59 <zenspider> UGH. I still need help trying to get emacs + stack + intero happy. I swear what I'm doing is not rocket surgery and yet...
18:06:18 <zenspider> `stack test` works fine in the terminal.
18:06:30 <zenspider> intero can now build and install its tooling
18:06:58 <zenspider> but opening a source file still shows errors on the imports (HSpec) and the repl agrees with those errors
18:07:05 <zenspider> WTF am I doing wrong?!?
18:09:21 * hackage toodles 0.1.0.13 - Manage the TODO entries in your code  http://hackage.haskell.org/package/toodles-0.1.0.13 (aviaviavi)
18:10:50 <fen> yes! https://bpaste.net/show/9ba36d946cc0
18:12:14 <fen> much faster 
18:12:23 <fen> as fast as for list
18:14:39 <fen> here this version has slightly lower varience https://bpaste.net/show/ce67e9912fc9
18:15:24 <fen> so, this should show the approach using undefined far out performs the versions using the other approaches surgested earlier 
18:16:48 <jmcarthur> Is there a reasonably standard function out there satisfying this type, with short circuiting behavior, or do I need to roll my own?   (Foldable f, Monad m) => (a -> m (Maybe b)) -> f a -> m (Maybe b)
18:17:50 <fen> if f /= m then you cant use join, and its Monad, not MonadPlus so you cant use fold
18:18:26 <c_wraith> maybe something in monad-loops?
18:18:53 <koz_> c_wraith: I just checked, nothing seems suitable.
18:19:00 <c_wraith> huh.
18:19:08 <jmcarthur> That was my first thought. The most similar I can find there is firstM.
18:19:18 <Solonarv_> % :t asum @Maybe . traverse
18:19:18 <yahb> Solonarv_: ; <interactive>:1:1: error:; * Cannot apply expression of type `t1'; to a visible type argument `Maybe'; * In the first argument of `(.)', namely `asum @Maybe'; In the expression: asum @Maybe . traverse
18:19:41 <Solonarv_> ...what
18:19:48 <jmcarthur> Solonarv_: I don't want to use traverse. It doesn't short circuit the way I want.
18:20:14 <fen> dmwit: does it look ok? the fast difference list with undefined?
18:20:41 <Solonarv_> % :t (fmap asum .) . traverse
18:20:41 <yahb> Solonarv_: ; <interactive>:1:7: error:; * Variable not in scope: asum :: t b -> b1; * Perhaps you meant `sum' (imported from Prelude)
18:21:04 <Solonarv_> % import Control.Applicative; import Data.Foldable; import Data.Traversable
18:21:04 <yahb> Solonarv_: error: expecting a single import declaration
18:22:17 <jmcarthur> Maybe I just do something with MaybeT.
18:24:52 <jmcarthur> runMaybeT . asum . map (MaybeT . f)
18:26:51 <fen> this seems to indicate that its normally slower to work with NonEmpty difference lists; https://github.com/phadej/dlist-nonempty/
18:27:32 <fen> did the way with undefined really make it so much faster, or is it confused somehow?
18:27:59 <fen> https://bpaste.net/show/9ba36d946cc0
18:31:40 <fen> note that the version for list can have its application to undefined replaced with [] and the last value not use const,whereas for NonEmpty this isnt an option.
18:31:53 <fen> it makes it the same approach for both this way
18:35:35 <fen> ok l8r
18:43:11 <jle`> jmcarthur: that only works if f is Functor
18:43:18 <jle`> (assuming you mean fmap instead of map)
18:44:52 <jle`> jmcarthur: you can make it work with all foldable by using MaybeT and Alt
18:45:29 <jle`> @let mapMaybeM :: (Foldable f, Monad m) => (a -> m (Maybe b)) -> f a -> m (Maybe b); mapMaybeM f = getAlt . foldMap (Alt . MaybeT . f)
18:45:30 <lambdabot>  .L.hs:247:15: error:
18:45:30 <lambdabot>      • Couldn't match type ‘m’ with ‘MaybeT m’
18:45:30 <lambdabot>        ‘m’ is a rigid type variable bound by
18:45:43 <jle`> @let mapMaybeM :: (Foldable f, Monad m) => (a -> m (Maybe b)) -> f a -> m (Maybe b); mapMaybeM f = runMaybeT . getAlt . foldMap (Alt . MaybeT . f)
18:45:45 <lambdabot>  Defined.
18:46:14 <jle`> runMaybeT . getAlt . foldMap (Alt . MaybeT . f)
18:46:21 <jle`> although in the end it's just coerce . foldMap (coerce f)
18:46:22 <koz_> jle`: You should gone gone all the way and used ala' for that one. :P
18:46:33 <jle`> or coerce (foldMap (coerce f)), hm
18:46:33 <koz_> (I think even just ala would have worked)
18:47:14 <koz_> (the one from CoercibleUtils that is)
18:47:46 * ski just relistened to that Racket talk (nice one, imho)
18:48:27 <jle`> might have to use Compose Alt MaybeT
18:48:34 <jle`> if want to work with ala i think
18:48:50 <koz_> Yeah, probably.
18:48:59 <koz_> I just have all things foldMap on the brain lately.
18:53:49 <Solonarv_> hmmm, maybe just "coerce foldMap" would work?
18:55:38 <koz_> Solonarv_: You need two coercions - one to 'wrap' things up in the right newtype, then another to 'get out' the answer you want.
18:55:46 <koz_> ala does this quite nicely.
18:56:01 <Axman6> :t coerce foldMap
18:56:03 <lambdabot> error:
18:56:03 <lambdabot>     • Variable not in scope: coerce :: ((a0 -> m0) -> [a0] -> m0) -> t
18:56:03 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
18:56:17 <Axman6> :t foldMap ^. coerced
18:56:18 <lambdabot> (Coercible a1 ((a2 -> m) -> t a2 -> m), Monoid m, Foldable t) => a1
18:56:21 <Solonarv_> % :t \f -> coerce (foldMap @_ @(Alt (MaybeT _) _)) f
18:56:22 <yahb> Solonarv_: ; <interactive>:1:28: error:; Not in scope: type constructor or class `Alt'; Perhaps you meant `All' (imported from Data.Semigroup); <interactive>:1:33: error:; Not in scope: type constructor or class `MaybeT'; Perhaps you meant `Maybe' (imported from Prelude)
18:56:41 <Solonarv_> % :m + Data.Monoid Control.Monad.Maybe.Trans
18:56:41 <yahb> Solonarv_: ; <no location info>: error:; Could not find module `Control.Monad.Maybe.Trans'; Perhaps you meant Control.Monad.Trans (from mtl-2.2.2)
18:56:42 <koz_> yahb has a mixed bag of imports I see.
18:56:50 <jle`> it looks like hackage is still running ghc 8.4, so my ghc 8.6-only package docs won't build :(
18:56:57 <jle`> it's Control.Monad.Trans.Maybe fwiw
18:57:06 <Solonarv_> % :m + Control.Monad.Trans.Maybe
18:57:06 <yahb> Solonarv_: 
18:57:13 <Solonarv_> % :t \f -> coerce (foldMap @_ @(Alt (MaybeT _) _)) f
18:57:13 <yahb> Solonarv_: ; <interactive>:1:28: error:; Not in scope: type constructor or class `Alt'; Perhaps you meant `All' (imported from Data.Semigroup)
18:57:32 <Solonarv_> % :m + Data.Monoid
18:57:32 <yahb> Solonarv_: 
18:57:33 <Solonarv_> % :t \f -> coerce (foldMap @_ @(Alt (MaybeT _) _)) f
18:57:33 <yahb> Solonarv_: ; <interactive>:1:7: error: Variable not in scope: coerce :: ((a0 -> Alt (MaybeT w1) w0) -> [a0] -> Alt (MaybeT w1) w0) -> t -> t1
18:57:53 <Solonarv_> % :m + Data.Coerce
18:57:53 <yahb> Solonarv_: 
18:57:55 <Solonarv_> % :t \f -> coerce (foldMap @_ @(Alt (MaybeT _) _)) f
18:57:55 <yahb> Solonarv_: (Foldable w1, Monad w2, Coercible t1 (w1 a -> Alt (MaybeT w2) w3), Coercible t2 (a -> Alt (MaybeT w2) w3)) => t2 -> t1
18:58:35 <Solonarv_> % :t (\f -> coerce (foldMap @_ @(Alt (MaybeT _) _)) f) :: (Foldable f, Monad m) => (a -> m (Maybe b)) -> f a -> m (Maybe b)
18:58:35 <yahb> Solonarv_: ; <interactive>:1:8: error:; * Couldn't match representation of type `w1 (Maybe w0)' with that of `m1 (Maybe b1)' arising from a use of `coerce'; * In the expression: coerce (foldMap @_ @(Alt (MaybeT _) _)) f; In the expression: (\ f -> coerce (foldMap @_ @(Alt (MaybeT _) _)) f) :: (Foldable f, Monad m) => (a -> m (Maybe b)) -> f a -> m (Maybe b); * Relevant bindings include f :: a1 -
18:58:51 * hackage decidable 0.1.3.1 - Combinators for manipulating dependently-typed predicates.  http://hackage.haskell.org/package/decidable-0.1.3.1 (jle)
18:58:56 <Solonarv_> well, pretty close!
18:59:52 <Solonarv_> sorry for the spam btw -- point is, you can coerce functions, and that's equivalent to coercing their argument(s) and result type
19:00:01 <koz_> Solonarv_: Oh wait really?
19:00:17 <koz_> Wait, so for a -> b, what are the roles of a,b?
19:00:26 <Solonarv_> representational, iirc
19:00:31 <Solonarv_> % :i (->)
19:00:31 <yahb> Solonarv_: data (->) (a :: TYPE q) (b :: TYPE r) -- Defined in `GHC.Prim'; infixr 0 ->; instance Applicative ((->) a) -- Defined in `GHC.Base'; instance Functor ((->) r) -- Defined in `GHC.Base'; instance Monad ((->) r) -- Defined in `GHC.Base'; instance Monoid b => Monoid (a -> b) -- Defined in `GHC.Base'; instance Semigroup b => Semigroup (a -> b) -- Defined in `GHC.Base'
19:00:52 <Solonarv_> bleh, doesn't tell
19:01:51 <koz_> Solonarv_: Thanks, that's gonna come in very handy.
19:02:29 <Solonarv_> % coerce @Sum @_ (<>) (Sum 5) (Product 3)
19:02:29 <yahb> Solonarv_: ; <interactive>:139:9: error:; * Expecting one more argument to `Sum'; Expected a type, but `Sum' has kind `* -> *'; * In the type `Sum'; In the expression: coerce @Sum @_ (<>) (Sum 5) (Product 3); In an equation for `it': it = coerce @Sum @_ (<>) (Sum 5) (Product 3); <interactive>:139:16: error:; * Couldn't match expected type `Sum' with actual type `a0 -> a0 -> a0'; * I
19:02:41 <Solonarv_> % coerce @(Sum _) @_ (<>) (Sum 5) (Product 3)
19:02:41 <yahb> Solonarv_: ; <interactive>:140:20: error:; * Couldn't match expected type `Sum w0' with actual type `a0 -> a0 -> a0'; * Probable cause: `(<>)' is applied to too few arguments; In the third argument of `coerce', namely `(<>)'; In the expression: coerce @(Sum _) @_ (<>) (Sum 5) (Product 3); In an equation for `it': it = coerce @(Sum _) @_ (<>) (Sum 5) (Product 3)
19:02:57 <Solonarv_> ...ah, you get the idea, I'll stop spamming
19:03:19 <koz_> Coerce sure can do some magical things.
19:03:47 <Solonarv_> https://ghc.haskell.org/trac/ghc/wiki/Roles has some more info, as does the documentation of Data.Coerce
19:09:27 <koz_> It's a pity GHCi doesn't have ':role' or something liek it.
19:17:19 <Solonarv_> I actually thought it showed up with :i
19:17:35 <Solonarv_> % :set -XRoleAnnotations
19:17:35 <yahb> Solonarv_: 
19:17:53 <Solonarv_> %% :i Data.Set.Set
19:17:53 <yahb> Solonarv_: http://qp.mniip.com/y/5
19:18:14 <Solonarv_> ah, maybe you need the language feature turned on
19:18:26 <koz_> %% :i (->)
19:18:26 <yahb> koz_: http://qp.mniip.com/y/6
19:18:34 <koz_> Doesn't say...
19:19:07 <Solonarv_> hmm... maybe it only reproduces explicit annotations, and leaves inferred roles out
20:15:21 <ski> hmm .. parsing over a group sounds fun
20:17:39 <pi__> good evening?
20:18:48 <ski> good morning
20:19:07 <pi__> maybe where you are, but not here
20:19:43 <ski> i just replied to your greeting :)
20:20:33 <pi__> I know your tricks
20:21:27 * ski smiles
20:24:14 <koz_> It's afternoon here.
20:24:23 <koz_> But it's _always_ morning somewhere.
20:30:31 <Cinnabar> aaaaaaaaaaaaand good evening
21:02:48 <Cinnabar> Everything's Fine
21:17:20 <Zemyla> I was thinking about the potential interaction between Distributive and Traversable.
21:19:23 * hackage graphql-w-persistent 0.1.0.7 - Haskell GraphQL query parser-interpreter-data processor.  http://hackage.haskell.org/package/graphql-w-persistent-0.1.0.7 (jasonsychau)
21:19:38 <Zemyla> If f is Distributive, then it's isomorphic to (->) e for some e. And some of those fs are Traversable as well, which raises the question: For which e is there a Traversable and Representable f such that Rep f ~ e?
21:20:53 <Solonarv_> ...I thought Representable f meant f ~ (->) Rep f
21:21:20 <Zemyla> I mean, some are obviously possible, like Bool. Some are possible and sensical in a lazy language, like Integer. Some are theoretically possible yet don't really make much sense, like Float. And some aren't possible at all, like Integer -> Bool.
21:22:12 <Zemyla> Solonarv_: Yeah, but I got muddled terminology wise midway through and I'm on a phone so editing is difficult.
21:22:41 <Solonarv_> aaaah, this explains it: "Every Distributive Functor is actually Representable." (from the Representable docs)
21:22:45 <Cinnabar> stylet time
21:24:21 <Zemyla> Basically, Distributive is a Haskell 98 class which applies to all (->)-like Functors with unknown parameter.
21:24:43 <Solonarv_> so (at least in Hask) Distributive and Representable are actually the same thing (or, have the same instances)
21:25:45 <Zemyla> Pretty much.
21:26:11 <Zemyla> A Traversable Distributive is isomorphic to Vec n for some n.
21:26:42 <Solonarv_> The haddocks for both classes (Representable and Distributive) pretty much outright say so
21:27:29 <Zemyla> Also, we really need the categorical dual of Distributive, which would be a subclass of Traversable.
21:28:19 <Solonarv_> huh? Distributive is the dual of Traversable, and duality is symmetric, so Traversable is the dual od Distributive
21:28:52 <Zemyla> Solonarv_: Nope. The dual is equivalent to (,) e for some e.
21:29:08 <Solonarv_> the docs disagree: http://hackage.haskell.org/package/distributive-0.5.3/docs/Data-Distributive.html#t:Distributive
21:30:33 <Zemyla> The main function for a Codistributive class would be codistribute :: (Codistributive f, Functor g) => (a -> g b) -> f a -> g (f b)
21:30:46 <Zemyla> Note the difference between that and traverse.
21:31:22 <Zemyla> And the similarity between it and collect.
21:31:49 <Solonarv_> oh, right - because Distributive relaxes Traversable's Applicative f to Functor f, which it does because there isn't a co-Applicative
21:32:02 <Zemyla> Actually, the functions would be named codistribute and llect.
21:32:51 <Zemyla> Subscribe for more category theory humor.
21:34:40 <Zemyla> Welp.
21:43:21 <koz_> Zemyla: LOL
21:43:27 <koz_> (especially at llect)
21:52:51 * hackage metar-http 0.0.1 - HTTP for METAR  http://hackage.haskell.org/package/metar-http-0.0.1 (TonyMorris)
22:50:30 <koz_> Are there Sings for Nats in Data.Singletons?
23:25:08 <jle`> yeah, in Data.Singletons.TypeLits
23:25:18 <jle`> the constructors are SNat @1, SNat @2, etc.
23:26:31 <jle`> (koz_)
23:26:41 <koz_> jle`: Woo, thanks!
23:26:55 * koz_ is _still_ trying to give Data.Massiv.Array the vector-sized treatment.
23:27:43 <jle`> i talk a lot about using them in https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html
23:32:53 <koz_> jle`: I wanna do something like 'if n is the Nat for 0, then do this, else this'. How would I write that?
23:39:55 <Rick10> Ꮤith οᥙr ΙRϹ ad ѕerᴠice уou can reach a gⅼοbaⅼ audⅰence ഠf ᥱᥒtrᥱpreneᥙrs ɑnd fᥱntanyⅼ aԁԁіcts ᴡitһ eⅹtrаοrdiᥒary engаgeⅿent rates! httpѕ︓//willⅰɑⅿpitcοck.com/
23:41:13 <koz_> Also jle`: Could you please tell me why it's asking for a SingI constraint here? https://gist.github.com/kozross/9bc9cfd7d90e3d8c09ebecdfd18c40dc
23:41:55 <jle`> SingI doesn't refer to the kind
23:42:01 <jle`> it refers to 'Seq and 'Par
23:42:18 <koz_> Ah, that makes sense.
23:42:29 <koz_> So I'm gonna have to carry around that constraint then.
23:42:53 <jle`> it's essentially the same as carrying around Seq or Par
23:43:15 <jle`> remember a SingI s constraint is basically an implicit argument for Sing s
23:43:35 <koz_> OK, that makes sense.
23:43:43 <jle`> so the type of pure :: SingI s => a -> DelayArray s n a, is "really" pure :: Sing s -> a -> DelayArray s n a
23:43:55 <jle`> but it's only necessary if you ever branch on or use the 's'/Sing s
23:43:57 <koz_> Teaches me to try lifting thigns to the type level.
23:44:01 <koz_> Yeah, it is necessary.
23:44:13 <jle`> yeah, if it's necessary, then you need to pass it because of type erasure
23:44:15 <koz_> Because Massiv has every array implicitly carry an evaluation strategy around.
23:44:25 <jle`> otherwise 'Seq or 'Par is erased at compiletime
23:44:34 <koz_> I decided explicitly lifting it to the type level would be better.
23:44:57 <jle`> in the end the result is the same, runtime-wise
23:45:03 <jle`> you're still carring around Seq or Par at runtime now
23:45:29 <jle`> passing a Strategy vs. Sing s ->/SingI s =>/ is just passing around Seq or Par at runtime
23:45:36 <jle`> the difference is that with it at the type level, you get type safety
23:46:35 <koz_> The only difference between those in terms of semantics is that Seq says 'compute everything sequentially', while Par says 'parallelize this plz'.
23:46:45 <koz_> Is this something you'd _want_ to be typesafe about?
23:48:19 * koz_ genuinely isn't sure.
23:59:12 <koz_> %% :i (->)
23:59:12 <yahb> koz_: http://qp.mniip.com/y/7
