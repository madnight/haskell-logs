00:07:43 <dminuoso> haasn: Ohh yeah, the `t` is completely misplaced there - I see my mistake.
00:10:45 <BaneAliens> would it be correct to say Ord is a subclass of Eq?
00:10:49 <BaneAliens> since it's a subset of Eq
00:11:18 <Ariakenom> yes and Eq is a superclass of Ord
00:11:21 <dminuoso> BaneAliens: Since Eq is called the superclass of Ord, it may be applicable - albeit confusing due to the meaning in other subtyped languages
00:11:32 <Ariakenom> instance Eq a => Ord a where ...
00:11:56 <BaneAliens> dminuoso: , agreed, which is why I like saying subset
00:12:01 <ski> > for_ [0 .. ] $ \n -> when (2 ^ n >= 1000) (throwError n)  :: Either Integer ()  -- traversing an infinite list
00:12:03 <lambdabot>  Left 10
00:12:29 <dminuoso> ski: Oh that's pretty cool :)
00:12:46 <ski> (re the discussion with fen, earlier)
00:13:21 <Ariakenom> % head . filter (\n -> 2^n >= 1000) $ [0..]
00:13:21 <yahb> Ariakenom: 10
00:13:52 <BaneAliens> anyone gone through the Haskell Programming Book by Christopher Allen? How long it take you to finish?
00:15:29 <ski> in fact, i'm happy the `Error e' constraint on `MonadError e (Either e)' got scrapped, so that my error/exception doesn't have to be "stringly"
00:16:16 <Ariakenom> stringly typed error handling is the only reasonable way
00:17:05 <ski> BaneAliens : for that question, you may also ask #haskell-beginners (which was created in large part for people following that book)
00:17:29 <ski> (note that beginner questions are also welcome in here)
00:19:54 * ski wouldn't hesitate using the term "subclass" in Haskell ..
00:20:44 <ski> .. noting that the notion of "subclass" in OO languages isn't directly linked to "subtyping"
00:21:21 <BaneAliens> thanks, I'll have to add that to my autojoin chans
00:23:04 <ski> (in Java, a class corresponds to a type (an "interface"). but also consists of more, a dynamic / run-time aspect. there's also the LSP point on subclasses not necessarily behaving like superclasses. and in presence of binary or cloning methods, a subclass may not even formally yield a subtype)
01:40:14 <bwe> Hi, my requirement: SQL -> Types -> JSON (with Aeson). Is there already a library that does exactly that?
02:02:16 --- mode: glguy set +v haskellnewbiee
02:09:06 <Ariakenom> % atomically $ do {c <- newTChan; writeTChan c 1; writeTChan c 2; Control.Applicative.some (readTChan c)}
02:09:06 <yahb> Ariakenom: [1,2]
02:09:28 <Ariakenom> -- just some random code
02:23:39 <cocreature> bwe: you need to be more precise, what do you mean by “SQL”? a query? the results of a query? which db? what do you mean by “Types”? what should the JSON encode? …
02:26:45 <tdammers> bwe: I'd aim for two libraries: SQL <-> Types and Types <-> JSON
02:27:21 <tdammers> bwe: and in fact, the degree to which you will want to tune the conversions tends to be so large that you might just as well write them yourself, or whip up some project-specific TH or Generics code
02:28:38 <tdammers> bwe: it also matters a lot what exactly you want out of the "SQL" part - do you want to generate just the Haskell <-> SQL data conversions, or do you also want to derive CRUD queries from the types?
02:50:43 <cemerick> why is my aeson fieldLabelModifier seemingly not being used? https://gist.github.com/cemerick/d2f3c279df9cc3ceb827fb64354dcc0a
02:51:50 <cocreature> cemerick: fieldLabelModifier works the other way around. it is applied to the record field name not the json key
02:52:39 <cemerick> oh! Well, that's too bad
02:55:37 <cemerick> cocreature: Is there any hook for twiddling `Value`s prior to their arriving at the derived `FromJSON` instance? Writing them out manually is going to be a lot of drudgery for records that have just one slot that needs tweaking, etc.
02:56:46 <merijn> cemerick: Why a lot of drudgery? You can just reuse the existing FromJSON for all the other fields, no?
02:57:38 <tdammers> a popular approach is to have two sets of types - one set to match the JSON structure exactly, and another to match what you want to work with; and then you write a bunch of conversion functions between those
02:58:00 <tdammers> but seriously, writing JSON instances by hand is much nicer than you'd think
02:59:38 <cemerick> merijn: for the types of all of the other fields, yes.
03:00:02 <cemerick> tdammers: sure, I'll get by :-)
03:01:49 <cocreature> cemerick: if you are fine with transforming the kebab-case in json to camelCase field names, it should be fairly easy to use fieldLabelModifier
03:01:57 <cocreature> otherwise yeah, just write the instance manually
03:05:57 <mniip> okay so the real thing to take out of yoneda is
03:06:17 <mniip> universal arrows/elements, free functors, limits, and functor representations are really the same things
03:06:49 <MarcelineVQ> @quote mniip okay so the real thing to take out of yoneda is ne
03:06:50 <lambdabot> No quotes match. You untyped fool!
03:06:59 <MarcelineVQ> ehe :>
03:09:48 <mniip> ne?
03:10:30 <MarcelineVQ> nandato?
03:11:02 <mniip> I don't understand
03:11:19 --- mode: glguy set +v foojin
03:11:36 <foojin> ^_^
03:13:59 --- mode: glguy set +v chris__bacon
03:14:24 <MarcelineVQ> > fold [take 2, drop 4] $ "yoneda"
03:14:26 <lambdabot>  "yoda"
03:14:45 <dstolfa> the yoda lemma
03:14:47 <MarcelineVQ> oh that's just <> anyway, I'm dumb
03:17:12 <chris__bacon> Hi I have a question regarding Core.
03:17:22 <chris__bacon> I am just a bit confused about something atm
03:17:38 <chris__bacon> If I have the following program: 
03:17:46 <chris__bacon> a :: Int; a = 1
03:17:50 <chris__bacon> The core dump I see is 
03:18:01 <chris__bacon> a :: Int; a = GHC.Types.I# 1#
03:18:09 <mniip> I# is the constructor of Int
03:18:15 <chris__bacon> However, I would have expected `a :: Int` to be `a :: Int#`
03:18:23 <mniip> no
03:18:26 <mniip> a is a lifted value
03:18:33 <mniip> it has a uniform closure representation
03:18:41 <mniip> so that it can be passed to, say, 'id'
03:19:15 <chris__bacon> I see, so it's enough just to see that the value is GHC.Types.I# to know that it's been unboxed?
03:19:48 <mniip> not sure what you mean by that
03:20:24 <cocreature> it hasn’t been unboxed, a is a boxed value
03:21:02 <chris__bacon> I don't follow why that would be. If we know the value at compile time, wouldn't it be better for GHC to unbox?
03:21:13 <mniip> but then you'd have to box it at every use
03:21:23 <cocreature> you can’t have top-level unboxed bindings iirc
03:21:29 <mniip> pretty sure you cant
03:21:31 <mniip> can*
03:21:31 <chris__bacon> Ahh I see
03:21:46 <mniip> chris__bacon, unboxing is incompatible with parametric polymorphism
03:21:48 <cocreature> mniip: oh you can? I might be mixing things up here
03:22:01 <mniip> % :set -ddump-simpl
03:22:01 <yahb> mniip: 
03:22:04 <mniip> %% let {}
03:22:04 <yahb> mniip: http://qp.mniip.com/y/3
03:22:04 <Athas> GHC operates with an open-world assumption, so it can't know whether you'll want to pass 'a' to something polymorphic.
03:22:17 <mniip> %% f = f
03:22:17 <yahb> mniip: http://qp.mniip.com/y/4
03:22:17 <chris__bacon> That makes sense 
03:22:18 <Athas> I'm pretty sure GHC will inline the unboxed '1' into any concrete uses it sees.
03:22:25 <mniip> see the Addr# bindings
03:22:28 <mniip> %kill
03:22:28 <yahb> mniip: Done
03:22:44 <cocreature> ah interesting, thx
03:23:52 <cocreature> “You cannot bind a variable with an unboxed type in a top-level binding.” https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unboxed-type-kinds
03:23:54 <cocreature> so is that wrong?
03:24:12 <cocreature> or is that true in Haskell but not in Core?
03:25:05 <mniip> maybe it is true
03:25:19 <mniip> you probably can't compile a global binder that is an unboxed application of a function
03:25:26 <mniip> but unboxed literals are okay
03:25:47 <alexelcu> What’s the easiest way to execute an IO action on another thread without waiting for its completion? `forkIO`?
03:26:41 <bwe> tdammers: Thanks for your comments. I realised the SQL view needs to be rewritten from scratch. Since MS SQL supports JSON, I can directly pull a JSON out of the SQL. 
03:29:10 <MarcelineVQ> % geh = 1#
03:29:10 <yahb> MarcelineVQ: ; <interactive>:2:1: error: Top-level bindings for unlifted types aren't allowed: geh = 1#
03:29:37 <chris__bacon> So just going back to the Core `a :: Int; a = GHC.Types.I# 1#`.... is that saying that `a` is boxed... but the implementation of `a` is that it is using unboxed types? I'm assuming `GHC.Types.I# 1#` is unboxed?
03:29:51 <chris__bacon> Maybe that is what is confusing me 
03:32:33 <merijn> alexelcu: Do you care if it completes at all, or?
03:39:20 <Jetien> Hi! I'd like to define a monad that builds upon the state monad. What's the idiomatic way to do this? Should I implement it as a transfomer? Or is there a simpler way? If so, how can I somehow make use of the instance provided by StateT in my code? Can some somebody point me to some exmaple code or tutorial?
03:39:33 <Solonarv_> "I# 1#" is of type Int, which is boxed. "1#" is of type "Int#", which is unboxed.
03:41:01 <Solonarv_> Jetien: afaik the idiomatic way is something along the lines of "newtype MyMonadT m a = MyMonadT { runMyMonadT :: StateT MyState m a } deriving (Functor, Applicative, Monad)"
03:41:36 <Solonarv_> you may want to add a few more classes to that deriving clause depending on your use case; also, you'll need to enable -XGeneralizedNewtypeDeriving
03:41:55 <chris__bacon> Thanks that explains it! 
03:42:58 <Jetien> Solonarv_: thanks! If i derive Monad doesn't that mean that I won't be able to define my instance?
03:43:12 <dminuoso> Jetien: You still have to define your instance for `m`
03:43:25 <lyxia> you don't need the explicit StateT layer with DerivingVia
03:43:30 <dminuoso> Jetien: The thing is, there an instance Monad m => Monad (StateT s m)
03:43:41 <alexelcu> merijn: yes, I care, I mean I want it to execute — on raising an error or something it will log it; this is in the context of a simple web server, I don't want the requests to block for that result
03:44:09 <Jetien> ah, okay. thank you all. Need some time to process this
03:44:15 <Solonarv_> that is indeed what it means, but that's an upside - there's almost always only one correct instance anyway, and having it auto-derived saves you the effort of writing it yourself
03:44:17 <merijn> alexelcu: I ask because the problem with forkIO is that all threads get killed when the main thread exits
03:44:45 <merijn> alexelcu: You could also simply fork of one or more worker threads that read work items from a Chan and have your main thread write requests to said chan to avoid blocking
03:47:13 <alexelcu> merijn: I'm a rookie — so I can probably build a loop that consumes from a `Chan`,  which seems to work like a queue
03:47:22 <alexelcu> but how do I create the thread(s)?
03:47:25 <alexelcu> `forkOS`?
03:47:31 <merijn> alexelcu: With forkIO
03:47:36 <lavalike> or async
03:47:40 <merijn> alexelcu: Or by using the async library
03:47:55 <lavalike> v good library
03:48:17 <alexelcu> so if I do `forkIO` from `main`, I'm assuming the threads don't get killed until the app quits
03:48:23 <merijn> alexelcu: Basically, forkIO creates green threads and the runtime system lets you run N green threads on M system threads
03:48:46 <merijn> alexelcu: Correct, but if main exits before the threads finish, the *will* get killed
03:49:08 <lavalike> http://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#g:3
03:49:25 <merijn> alexelcu: By default GHC uses the single-threaded runtime which uses only a single OS thread to run all your green threads (so it's basically a traditional select/epoll event loop)
03:49:50 <merijn> alexelcu: If you compile with -threaded GHC will use the threaded runtime which lets you use multiple OS threads (see GHC user's guide for details)
03:50:40 <alexelcu> merijn: thanks, this is useful; but what if I just start that loop with `forkOS`, won't that work?
03:51:14 <merijn> alexelcu: forkOS doesn't create OS threads, it merely forces the created green thread to always run on the exact same system thread
03:51:43 <merijn> alexelcu: This is important for some foreign libraries (things like OpenGL, GUI frameworks, etc.) which have to always be called from the same thread
03:51:57 <alexelcu> I need to read that book on Concurrency 🙂 was it "_Parallel and Concurrent Programming in Haskell_"?
03:52:08 <merijn> alexelcu: Because otherwise the green thread can be moved between system threads, depending on how busy each system thread is
03:52:16 <merijn> That'd help, yes ;)
03:52:34 <alexelcu> I see, OK, got it
03:52:36 <alexelcu> Thanks
03:53:17 <merijn> In entirely unrelated news: Anyone here familiar with signal processing? Specifically, any recommended tutorials/explanations of how the hell (F)FT works?
03:57:22 <Putonlalla> I'd take a look at the documentation of FFTW, merijn. I recall it was good.
03:58:25 <mniip> merijn, it's simple
03:58:48 <mniip> you're probably looking for DTFT?
03:59:44 <Jetien> Solonarv_: If i'd MyMonad like my custom monad won't have access to the state, right? What I'm trying to achieve is to have a custom monad that does stateful things under the hood but doesn't expose the full implementation of the state monad.
03:59:47 <merijn> mniip: Probably?
04:00:19 <mniip> merijn, I suppose this is more appropriate in ##math
04:00:26 <Jetien> Solonarv_: s/If i'd MyMonad like/If i'd define MyMonad like this/
04:00:55 <merijn> mniip: Yeah, I was just hoping someone had a nice "Fourier Transforms for Dummies" link lying around :p
04:00:56 <dstolfa> he may be looking for DFT rather than DTFT, as FFT is an algorithm for computing the DFT
04:01:39 <mniip> er right, DFT
04:02:00 <dstolfa> as for books... let me dig
04:02:07 * dstolfa used to do a bunch of control theory 3-4 years ago
04:02:10 * dstolfa might have something laying around
04:02:27 <mniip> the gist is that if you have nth root of unity w, then you can build a nxn matrix with W_i,j = w^(ij)
04:02:27 <ski> Jetien : if you add `MonadState MyState' to the `deriving' clause, then you can use `get' and `put'. not adding that, you hide the state, so that only your operations that look inside the ADT can access the state via those operations
04:02:35 <mniip> and then fourier of an array A is WA
04:02:40 <mniip> and W*conj(W) = n*E
04:02:49 <mniip> so inverse fourier of B is conj(W)B/n
04:03:29 <mniip> and FFT is just a divide and conquer way of computing either of these
04:04:22 <dstolfa> hrm, nothing i can find that explains that and that alone really well without refering back to laplace transforms and how they relate + using a bunch of previously worked out examples from the book
04:04:34 <mniip> i'th element of WA is the one that corresponds to the (j mapsto w^(ij)) harmonic, which oscillates i times in the length of the A array
04:04:40 <Jetien> ski: thanks
04:05:35 * dstolfa notes that the category theory course that he's auditing is shrinking in student numbers each week
04:06:14 <mniip> dstolfa, unless it's a steady exponential decay I woulnd't worry
04:08:05 <Jetien> ski: hmmm... but i still like to be able to define my own instance of a monad somehow, (return and (>>=). In the implementation of these two functions I'd like to make use of "put" and "get".
04:20:50 <foojin> What's the nicest way to initialize a small `table :: Map Char Int` with constant values? Are there any constraints that, when satisfied, would make GHC precompute it?
04:21:31 <merijn> foojin: How big is the map?
04:23:24 <foojin> merijn: 26 entries, one for each Char in ['A' .. 'Z']
04:23:58 <merijn> foojin: Might be fastest to just define it as a function instead?
04:25:35 <foojin> merijn: The problem is that the integers don't depend nicely on these Char keys, so I have to write them out explicitly.
04:26:01 <int-e> > M.fromList [('a',123),('b',42)]
04:26:02 <merijn> foojin: Maybe I misunderstood what you mean by "precompute"?
04:26:03 <lambdabot>  fromList [('a',123),('b',42)]
04:26:13 <lyxia> I don't think ghc will optimize Map that way, because its functions are recursive
04:26:16 <int-e> foojin: what's wrong with doing something like that?
04:27:05 <foojin> int-e: That's how I've done it, but it seems somewhat ugly with 26 entries split over several lines.
04:27:07 <int-e> foojin: I don't think precomputing the map is going to make a noticable difference (and I can only think of an ugly way, involving Template Haskell and Data.Map.Internal)
04:27:43 <int-e> > zip ['A'..'Z'] [1..26]
04:27:45 <lambdabot>  [('A',1),('B',2),('C',3),('D',4),('E',5),('F',6),('G',7),('H',8),('I',9),('J...
04:28:44 <merijn> foojin: Well, I don't see what else you'd do if the values aren't nicely derived from the letters
04:28:50 <foojin> merijn: I meant creating the map at compile time instead of it going through the list. But I don't particularly mind if that can't be done, because it's the style that bothers me.
04:29:12 <foojin> s/instead of it/instead of fromList/
04:29:13 <merijn> foojin: I mean, you probably *can* do it, it's probably not worth the effort of doing so
04:29:14 <int-e> foojin: I don't think it gets nicer than that. (that zip idea works but then matching the numbers to letters becomes hard)
04:29:29 <merijn> foojin: Since a map of 26 elements is so small it's going to cost you almost nothing to initialise once
04:29:38 <merijn> (at runtime)
04:29:47 <cocreature> it depends on how expensive it is to compute the values in the map
04:30:04 <merijn> cocreature: Well, if written out numbers, probably damn cheap :)
04:30:05 <int-e> cocreature: they're constant, is what I understood
04:30:19 <int-e> which I took to mean integer literals
04:30:41 <foojin> int-e: That's what I had in mind.
04:32:10 <Lycurgus> there's nothing like a hs CMS, presumably layered off yesod oder, anyone knows of?
04:32:13 <foojin> Zipping doesn't seem to buy me anything style-wise, because the string literal and the list of Ints won't match nicely column-wise.
04:32:13 <int-e> foojin: I also think merijn's suggestion shouldn't be dismissed... it seems quite reasonable to define   f 'A' = nnn; f 'B' = nnn; ...; f 'Z' = nnn; f _ = -1 (say), and use that instead of the map.
04:33:45 <int-e> foojin: in any case I think there's not much to be gained style wise.
04:34:42 <int-e> > let a ~> b = (a,b) in ['A' ~> 1, 'B' ~> 3] -- you can play tricks like this I suppose
04:34:44 <lambdabot>  [('A',1),('B',3)]
04:34:54 <Squarism> How does one split on delimiter string best? 
04:35:01 <Squarism> split string
04:35:13 <int-e> @hackage split
04:35:13 <lambdabot> http://hackage.haskell.org/package/split
04:35:30 <Squarism> ok, thought there might have been something in base
04:35:45 <Clint> you said "best"
04:36:11 <cocreature> there are also functions for that in the "text" package if you’re working with Text instead of String (which you might want to consider anyway)
04:37:11 <foojin> I see. Then what's about GHC computing the value at compile time? Can it call functions like fromList (and others, possiblt from other modules) if it knows their input?
04:37:55 <foojin> It's not like this is needed in my case, I'm just asking for future reference.
04:37:59 <merijn> foojin: You can do this, but it's more effort than it's worth unless you have a good reason
04:38:13 <merijn> foojin: For example, you can do it via Template Haskell
04:38:40 <cocreature> GHC won’t constant-fold recursive function calls automatically
04:38:48 <merijn> foojin: Which you can (ab)use to do things like performing partial conversions at compile time: https://github.com/merijn/validated-literals
04:40:10 <foojin> cocreature: Is there a profound reason for it not to do that?
04:41:14 <merijn> foojin: Yes; People don't like waiting 50 hours for compilation to finish :)
04:41:50 <ggole> foojin: nope
04:41:54 <ggole> There are various compilers that will do that
04:42:59 <foojin> Making it unclear whether the compilation would diverge if something goes wrong inside that function looks like a possible explanation.
04:43:20 <noumenon> so, continuing on game of life from yesterday; since I've made the type Grid = Array (Int, Int) Cell, am I correct in assuming that I construct it by making an Array of Cells by passing listArray a list of Cells and then passing that array to Grid?
04:43:42 <ggole> You place limits on the unfolding, so compilation doesn't diverge no matter the contents of the function.
04:44:03 <noumenon> i.e. Grid listArray ((0, 0), (9, 9), [Alive, Alive, Dead, etc..])
04:44:12 <cocreature> noumenon: remove the Grid part
04:44:12 <ggole> (This means that there are some calls that could be constant-folded that are not, but that's usually OK.)
04:44:28 <cocreature> noumenon: a type synonym is just another name for a type. there is no conversion or wrapping necessary
04:45:00 <noumenon> ah, so in my initializeGrid, with type Int -> Grid, I can just return the Array then
04:46:55 <foojin> ggole: I see.
04:47:44 <noumenon> I want to initialize Cells as Dead or Alive with a certain probability, is generating random numbers using Haskell straightforward? I've heard it can be tricky
04:48:01 <merijn> noumenon: See System.Random
04:48:06 <hpc> noumenon: you might try using IO to get a truly random initial seed
04:48:08 <hpc> :t random
04:48:10 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
04:48:13 <noumenon> yeah, I'm reading it @ merijn
04:48:22 <hpc> but getting random numbers out of the rng you create from that seed is pretty easy
04:48:26 <noumenon> but I'm still getting used to reading the rather technical documentation
04:48:44 <hpc> noumenon: getting a random number is a pure operation that takes a seeded rng and produces a number and the updated rng
04:49:27 <noumenon> sure, I guess that makes sense
04:50:03 <noumenon> still trying to wrap my head around using that to create a list of numbers between 0 and 1 chosen at random
04:50:24 <noumenon> which I could then map to Dead or Alive based on a probability passed to the initializeGrid function
04:50:59 <hpc> noumenon: hint, look in the System.Random documentation for something that produces an infinite list from a seeded rng
04:51:32 <merijn> That doesn't let you limit the range of values in the list, but you could just map "even" to Alive and "odd" to Dead, that should be simple enough
04:52:28 <hpc> you can also ask for random booleans instead of random ints
04:52:35 <hpc> or write your own instance of Random
04:53:02 <hpc> http://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html#instance%20Random%20Bool
04:53:09 <merijn> Oh, yeah
04:53:34 <noumenon> I still haven't understood how you make the seeded rng to begin with, but thanks for the hint; I'm reading the docs and trying to understand
04:53:38 <merijn> hpc: Well, writing your own Random instance would be nice, but I wasn't sure whether that'd just make their life harder :)
04:54:33 <merijn> noumenon: You can create own yourself using "mkStdGen :: Int -> StdGen" or by using the default system StdGen from IO "getStdGen :: IO StdGen"
04:54:40 <noumenon> is it mkStdGen?
04:54:42 <noumenon> right
04:55:05 <merijn> noumenon: All the RandomGen class stuff is simply so that you can implement your own custom random generators if you want/need to
04:55:19 <noumenon> hmm, in the latter case, the StdGen is wrapped in IO though; will that make it harder to use?
04:55:23 <merijn> noumenon: Which is something you can just ignore/file under "worry about later"
04:55:44 <merijn> noumenon: Well, you can just call it once inside main and then pass the result to any function you like
04:55:50 <merijn> So, "not really"
04:56:05 <merijn> noumenon: All programs start with "main" (and thus inside IO) anyway.
04:56:54 <hpc> main = do {rng <- getStdGen; print (nonIOFunction rng)} -- for example
04:57:33 <noumenon> I thought brackets and semicolons weren't used in Haskell
04:57:43 <julianleviston> they can be used.
04:57:56 <delYsid> You can choose if you want to rely on layout or not.
04:57:57 <noumenon> also, I've barely learned how to operate within main, but what you're saying makes some sense
04:58:06 <hpc> it's rare that they are used in real code, but on irc it's sometimes easier than writing multiple lines
04:58:26 <julianleviston> One thing that wasn’t super obvious to me when I began Haskell was the fact that we don’t write a series of executable steps when we’re programming, we write expressions, which Haskell turns into an executable program.
04:58:30 <noumenon> oh, so the compiler actually registers newlines?
04:58:31 <delYsid> hpc: GHC is full of {...;...;} stuff
04:58:38 <hpc> noumenon: oh, since you'll probably find yourself reading lots of documentation a good trick is to focus on the type signatures first
04:58:52 <noumenon> I thought you could essentially just write everything on the same line without brackets or semicolons and that the compiler would still understand
04:59:03 <hpc> most of the time they will tell you everything you need to know about a function
04:59:38 <noumenon> maybe for someone experienced
04:59:50 <delYsid> hpc: Last time I pasted a type signature here, I was told the contrary :-)
05:00:48 <merijn> delYsid: That's because it's SPJ's code style
05:00:53 <hpc> delYsid: in base and the other "standard" packages it's usually true, not so much if you're using something like an opengl package
05:01:52 <merijn> noumenon: By "look at" he doesn't mean "skim" he means "really stare at and think about what it means for several minutes" (although with practice "several minutes" quickly becomes "several seconds are faster")
05:02:04 <hpc> ^
05:02:06 <tsaka__> say I have a game loop or similar, and want to catch CTRL-C in order to exit cleanly. 1) Must the loop be in IO if I want to catch it there 2) Is there polling like method, i.e. "status <- checkForCtrlC :: IO Bool" instead of continuation passing style
05:02:15 <noumenon> merijn: trying
05:02:23 <noumenon> still needs experience
05:02:25 <foojin> noumenon: You can do without line breaks in simple cases, but sooner or later you'll either need to rely on layout / off-side rule (look these up) or braces and semicolons.
05:02:59 <hpc> tsaka__: the signal from ^C is asynchronous, so you're going to have to write a handler that turns it into something you can check synchronously in the loop
05:03:01 <merijn> noumenon: As for the brackets/braces, GHC basically has two modes "layout" (which uses whitespace/indentation to control grouping) or classic braces + semicolons. The latter is almost universally unused, but can be useful for summarising on one line on IRC
05:03:21 <hpc> tsaka__: or let it stay async if you don't want to say, lock yourself out of terminating the program
05:03:25 <noumenon> yeah, I see; so not only newlines, but indentation is also relevant
05:03:32 <foojin> noumenon: Also see how people write multiline list literals in Haskell and why they do it.
05:03:47 <noumenon> where can I find an example of that?
05:03:51 <foojin> I.e. "why they do it like that".
05:03:51 <merijn> noumenon: Here's a good summary of how the layout rules work: https://en.wikibooks.org/wiki/Haskell/Indentation
05:03:54 <noumenon> google perhaps
05:04:07 <hpc> noumenon: but yeah, learning to think in terms of types first is going to wrinkle your brain at first but it's worth the effort
05:04:20 <hpc> and you'll only get faster at reading through documentation as you get better at it
05:04:25 <noumenon> I don't mind, that's one of the main reasons I want to learn Haskell
05:04:43 <noumenon> just saying, I need the actual experience before I can just "look at the type signatures and comprehend the universe"
05:04:54 <hpc> the endgame of thinking with types is writing type signatures for definitions first, then discovering that there's exactly one well-defined definition anyway
05:04:59 <hpc> and your code just writes itself
05:05:04 <noumenon> right
05:05:11 <noumenon> back to the drawing board
05:05:28 <tdammers> hpc: and according to Idris propaganda, you can literally let an editor plugin write the implementations for you
05:05:51 <tdammers> you just type the function name and signature, and then f = _, and then you hit <Tab>, and the editor plugin fills in the blank
05:06:08 <merijn> noumenon: Well, consider the function "random :: (Random a, RandomGen g) => g -> (a, g)" and try and answer this: What *exactly* can you tell just from reading this type?
05:06:17 <cocreature> and then you realize that you’ve just done the exact same work that you’ve done before only now you claim that it’s types not values
05:06:22 <noumenon> also, I see the multiline list literals now, I think I've seen that in Python before as well
05:06:23 <ggole> But didn't you essentially write your function at type level?
05:06:23 <tsaka__> hpc: I'm not sure I understand how a signal is asynchronous. Is a "checkforCtrlC" function impossible? It could just check if the key has been pressed since the last time it was called
05:06:26 <hpc> tdammers: i am convinced that someday that's how every IDE will work
05:06:31 <ggole> And then ask the compiler to duplicate it for you at value level
05:06:42 <tdammers> cocreature: that is probably the big gotcha with dependent types ;)
05:06:43 <merijn> hpc: *mumbles something about Lamdu*
05:06:45 <hpc> tsaka__: it's possible, but you need to set a callback to catch it first
05:06:59 <tdammers> hpc: it's a rehash of the self-writing code pipe dream
05:07:00 <hpc> tsaka__: otherwise it's going to go to the default handler which rudely terminates your program
05:07:37 <merijn> hpc: Default handler for SIGINT is to raise an async exception
05:07:43 <hpc> oh
05:07:45 <tdammers> hpc: "if only we had a nice human-friendly language that is precise and unambiguous enough, then we could build tools to automatically write the code for us based on those specifications" - except that tools like that already exist, they're called "compilers"
05:07:49 <noumenon> merijn: well, not sure if that's proper since we've been discussing it for 20 minutes now, including mentions of exactly what it does, but it takes a random generator and returns something randomly produced by said generator and a new generator
05:07:50 <merijn> In main, to be precise
05:08:24 <hpc> tdammers: okay then, imagine cutting out the extra step of writing the values
05:08:31 <hpc> tdammers: now you're writing well-typed prolog
05:08:36 <noumenon> not sure what Random a is supposed to represent though, since I'd expect it to generate something of a specific type
05:08:49 <hpc> but you can still drop down to another language for the bits that a logic language doesn't express well
05:09:05 <merijn> noumenon: "Random" is a typeclass, so it's saying "I can do this for any type that happens to be an instance of the Random typeclass"
05:09:16 <Solonarv> just shout "do what I mean" at your friendly neighborhood AGI ;)
05:09:26 <noumenon> oh, right, those constraints refer to typeclasses
05:09:42 <merijn> noumenon: So, if you had "data Cell = Dead | Alive" you could write "instance Random Cell where ..." to implement it for your own datatype
05:10:15 <asheshambasta> Hi all, can anyone point me in the direction where I can create streaming request bodies for http-conduit? 
05:10:17 <noumenon> could you provide as an example how I would complete that?
05:10:21 <merijn> noumenon: Next step of the exercise would be, ok, so now if we look at all the other functions in System.Random (intentionally ignoring the text around them), what can you tell from those
05:10:21 <noumenon> i.e. where what?
05:10:32 <noumenon> yeah, I'd have to look at those then
05:11:12 <noumenon> could probably understand it from that, but I think I'll just use numbers and map for now, I'd like to get down to it and write some more code
05:11:13 <merijn> noumenon: Well, if you look at the docs for Random it says "Minimal complete definition: randomR, random". In other words, all functions have default implementations you don't have to write (but you can, if you think your version will be faster)
05:11:25 <asheshambasta> I'm looking at https://hackage.haskell.org/package/http-conduit-2.3.2/docs/Network-HTTP-Conduit.html#t:RequestBody and I have a source of ByteString (IO ByteString) but I'm totally thrown off by GivesPopper/etc.
05:11:40 <cocreature> asheshambasta: how about https://hackage.haskell.org/package/http-conduit-2.3.2/docs/Network-HTTP-Conduit.html#g:4
05:11:42 <asheshambasta> I cannot seem to find many examples of this online.
05:11:58 <julianleviston> hpc: sounded like you were describing a prolog to me there
05:12:03 <merijn> noumenon: So you'd write "instance Random Cell where { randomR (x, y) gen = ??; random gen = ?? }"
05:12:26 <julianleviston> hpc: or a solver language
05:12:58 <noumenon> where does the name "gen" come from there?
05:13:05 <cocreature> generator
05:13:11 <julianleviston> hpc: oh… haha I missed you saying exactly that :)
05:13:15 <hpc> julianleviston: :D
05:13:47 <asheshambasta> cocreature: ah I seem to have missed that somehow :-) 
05:13:48 <hpc> but yeah, the trick is that you have three layers of abstraction you can deal with then
05:14:01 <hpc> types only, and you're writing in a logic language and the compiler figures out how
05:14:06 <julianleviston> hpc: have you found a well typed prolog? I was reading a few papers about this stuff last week and it sounded pretty interesting
05:14:08 <cocreature> adding another layer of abstraction solves every problem
05:14:18 <hpc> more elaborate dependent types, where you need to babysit the compiler to find the solution
05:14:25 <merijn> noumenon: Then you'd use the functions of RandomGen to actually write the ?? parts. Or, easier, piggyback on an existing Random instance! There's already a "Random Bool" instance, so rather than implement "RandomGen g => g -> (Cell, g)" we can just take "random :: RandomGen g => g -> (Bool, g)" (aka the Bool instance) and convert the Bool to Cell by mapping over the tuple's first element
05:14:34 <hpc> and independent types, where you're writing just haskell-y code, doing IO, or whatever
05:14:37 <julianleviston> hpc: yeah, idris term searching springs to mind
05:14:41 <merijn> noumenon: gen is just short for "generator", because that's what 'g' is
05:14:50 <noumenon> lol
05:14:59 <hpc> you can naturally switch between them and not write anything more than you have to
05:15:00 <noumenon> sorry, not trying to be dense, but that's over my head
05:15:10 <merijn> noumenon: The reuse part?
05:15:18 <noumenon> just too much information at once
05:15:25 <noumenon> not sure where to begin
05:15:34 <merijn> noumenon: Copy it somewhere and read it again tomorrow or something :)
05:15:35 <julianleviston> noumenon: begin with something super simple and build up from there 
05:16:28 <tdammers> hpc: yeah, you could say that prolog is also an attempt at that - instead of specifying how to do it, you just say what you want done, and let the system figure out how to get there
05:17:08 <lavalike> :t Last -- why does this take a Maybe?
05:17:08 <lambdabot> Maybe a -> Last a
05:17:41 <cocreature> lavalike: how else do you make a Monoid out of it?
05:18:24 <julianleviston> oh cos of mempty?
05:18:45 <cocreature> Data.Semigroup has a non-maybe version
05:19:00 <cocreature> which you can wrap in "Option" to get the Monoid instance
05:19:04 <hpc> tdammers: there's also the fact that (imo) dependent types and logical follow-ups are going to be the next 20 years of programming language development
05:19:10 <hpc> but that's a whole other thing, and i gtg unfortunately
05:19:12 <lavalike> cocreature: that's what I was looking for!
05:19:24 <cocreature> but before we had Semigroup in base, that was hard
05:19:30 <lavalike> got fooled by them having the same name but being different types
05:19:33 <cocreature> so that’s why Data.Monoid still has the Maybe version
05:20:46 <lavalike> I think I haven't grokked yet that seeing "Text" doesn't mean the same thing everywhere, say
05:21:16 <merijn> lavalike: You mean strict vs lazy Text?
05:21:28 <lavalike> yep
05:21:54 <lavalike> same now for Last, I have the bias that seeing a name makes me think of 1 type, but it could be different types
05:22:04 <merijn> That's why I prefer using LT and LBS as qualifications for lazy Text/ByteString
05:23:29 <lavalike> at least in the case of Text the lazy version is the one least often useful so I use Text for the strict one and Lazy.Text for the other, here in the case of Last I'm unsure what to go for
05:25:50 <merijn> lavalike: I'd just consider the Monoid one deprecated and avoid it wherever possible
05:26:08 <foojin> BTW is there a list of common abbreviations used by the majority of people for qualified imports?
05:26:47 <lavalike> merijn: makes sense
05:27:08 <lavalike> foojin: no, but it would be a fun project to scan hackage packages and compiling such a list (:
05:28:36 <Ariakenom> brb uploading 1m packages with import qualified Prelude as Text
05:28:59 <lavalike> *gasp*
05:29:18 <foojin> lavalike: I've heard that GHC has a lot of library functions to help with analyses like this one. Parsing could be a problem otherwise.
05:29:22 <merijn> foojin: I'd say the following are common: T for Text, LT for lazy Text, BS for ByteString, LBS for lazy ByteString, M for Map, S for Set, IM for IntMap, IS for IntSet...
05:29:40 <merijn> foojin: C for Conduit modules
05:30:06 <lavalike> I like {Map,Set,…} for {Map,Set,…}
05:30:18 <Solonarv> yep, I do that too nowadays
05:30:55 <Ariakenom> mumble mumble Data mumble Control mumble
05:31:35 <merijn> lavalike: That's like 2 entirely redundant letters! :p
05:32:19 <foojin> merijn: Thanks, I've never seen the last few in the wild.
05:32:54 <noumenon> hmm: https://pastebin.com/raw/ndjrMVs6
05:33:25 <merijn> noumenon: Ah, yeah System.Random is from the "random" package
05:34:11 <merijn> Simply add that to your dependencies (by adding it to your build-depends if you're using cabal)
05:34:25 <foojin> By the way, if one does HTTP GET requests using Conduit, can the transferred bytes be salvaged if the server closes the connection randomly after about a megabyte sent?
05:34:32 <noumenon> I'm actually just coding in repl.it atm
05:34:56 <foojin> I've only used Wreq for that particular case, so I'm curious if it would have worked better with another lib.
05:35:00 <noumenon> but I guess I'm going to have to install it
05:35:22 <merijn> noumenon: I have no idea how repl.it works and if/how you can use dependencies
05:35:32 <noumenon> not yet apparently
05:35:55 <noumenon> I remember using Stack before formatting my pc though, rather than Cabal, any reason to prefer one over the other?
05:36:30 <tdammers> noumenon: many reasons... but realistically, it's a workflow thing for most people, plus "what I'm used to"
05:36:47 <noumenon> which do you prefer?
05:37:20 * Ariakenom steps down into the bunker
05:37:22 <noumenon> I'm not used to either, so I'd love to hear some arguments from people who I assume actively use either or both
05:37:39 <tdammers> I used to prefer stack, but recently it kind of broke my workflow, and now that cabal new-build is a thing, I really don't have a reason to put up with stack anymore
05:38:15 <merijn> noumenon: Personally I just use cabal-install, since I've been using it since before stack existed and stack's workflow never seems to match mine
05:38:37 <noumenon> cabal 2 - stack 0.5
05:38:49 <tdammers> particularly, what initially feels like a blessing with stack, namely, having a pre-vetted set of package versions that are "guaranteed" to work together, becomes a problem when that pre-vettedness prevents you from using a particular compiler version, or a particular combination of a compiler and library version
05:39:19 <merijn> noumenon: With new-build being fairly polished, I think the main argument in favour of stack is "the installer takes care of installing GHC for you", but then again, the installer relies on me piping a shell script from the internet, so I think that evens out in the pro/con matchup
05:39:27 <cocreature> the only thing I would recommend is that if you do use cabal, that you use cabal new-build
05:39:30 <merijn> noumenon: Which OS do you use?
05:39:37 <noumenon> Arch
05:39:46 <Solonarv> I started with cabal, fell into dependency hell, and switched to stack; recently I've been growing increasingly annoyed with its limitations
05:40:05 <tdammers> "the installer takes care of installing GHC for you" is actually a bit of a nuisance for me
05:40:07 <Solonarv> at some point I'll probably get frustrated enough to nuke it and use cabal instead
05:40:12 <merijn> noumenon: On windows installing GHC can be a nasty hassle, where stack can help. On *nix it's easy enough yourself
05:40:34 <merijn> noumenon: The only crucially important thing on Arch is: Don't install anything other than GHC/cabal from the arch packages!!
05:40:45 <Solonarv> since you're on arch, there's a special annoyance you should be aware of; let me find the page
05:40:56 <merijn> noumenon: The Arch maintainers insist on making the package repo completely broken for normal Haskell development
05:41:03 <noumenon> ghc and cabal-install?
05:41:12 <tdammers> realistically, I'm either working on an application, in which case I usually want to stick with the compiler I have installed as the system default, or I'm developing a library, in which case I want to test against a range of compilers, which I prefer to manage manually and explicitly
05:41:25 <merijn> noumenon: yeah
05:41:32 <Solonarv> found it: https://wiki.archlinux.org/index.php/Haskell
05:41:33 <cocreature> no not cabal-install
05:41:35 <cocreature> only ghc
05:41:39 <merijn> cocreature: oh?
05:41:40 <merijn> hmmm
05:42:00 <merijn> noumenon: Listen to cocreature, I'm just going off memory from other people ranting about arch ;)
05:42:01 <noumenon> cabal-install has a lot of haskell-* deps though
05:42:07 <cocreature> ghc and ghc-static (and their deps) should be the only things you install via pacman
05:42:16 <noumenon> ghc-static?
05:42:31 <cocreature> https://www.archlinux.org/packages/community/x86_64/ghc-static/
05:42:53 <merijn> noumenon: The normal/default Haskell workflow builds libraries statically. Arch, for some reason, insists to default to dynamic, breaking things in many "fun" and interesting ways :)
05:43:21 <yushyin> ghc* workflow?
05:43:33 <cocreature> if they actually defaulted to dynamic, things wouldn’t be so bad. the problem is the GHC they install defaults to static linking but they distribute dynamic libs
05:43:40 <merijn> yushyin: The normal/dfault haskell workflow is GHC, so... :p
05:43:47 <noumenon> cocreature: I'm not that experienced with Arch; I found that page too, but can't see where it tells me what exactly that package does
05:44:02 <Solonarv> they're really synonymous most of the time, since ghc is the only widely-used haskell compiler
05:44:14 <cocreature> noumenon: “Static Libraries and Documentation”
05:44:15 <noumenon> but oh, it's required by ghc anyway
05:44:53 <merijn> noumenon: The alternative is ignoring Arch repos completely. I personally just install GHC binary distributions then build cabal-install myself. Which has the benefit of being portable to literally any *nix OS :)
05:44:56 <yushyin> cocreature: ghc/cabal doesn’t allow such defaulting as compile time option, you have to change configs manually :/
05:45:29 <noumenon> maybe I'm not a good enough hacker, but doing things outside of pacman has only brought me pain in the past
05:45:44 <cocreature> yushyin: well then they should patch ghc or whatever or just stop annoying everyone and distribute static libs like the rest of the world
05:45:50 <cocreature> the current behavior is just stupid
05:46:29 <merijn> noumenon: That's because most tools are really user unfriendly when not using a package manager. But GHC and cabal-install are exceptions (I normally have to install manually, since I don't have root on the clusters I work on)
05:46:49 <yushyin> cocreature: well, yes and no. I don’t have any problems, I never use distributed packages for development anyway because that would be PITA in case of ghc
05:47:06 <merijn> noumenon: I just install GHC into $HOME/ghcXY (XY being the version) and cabal just installs all it's stuff in $HOME/.cabal
05:47:09 <cocreature> yushyin: so it’s not stupid because you don’t use it?
05:47:17 <cocreature> that doesn’t seem like a useful argument to make
05:48:01 <merijn> noumenon: Anyway, not saying you *should* do that, just pointing out it's an option (one that I personally find preferable to figuring out subtle ways different distro's like to break things :))
05:48:16 <yushyin> cocreature: ok yes, but ghc and libs on hackage break so often anyway it’s not useful to use a rolling release distribution’s packages for development
05:48:59 <noumenon> right, I see; well, for now I'll just be working on personal stuff here, but I'll keep it in mind in case I'll be writing stuff meant to be easily installed and run on other OSes
05:49:14 <cocreature> yushyin: I still don’t see your point. I argued that the way Arch distributes GHC doesn’t make sense and you’re telling me to not use the Arch packages
05:52:32 <alexelcu> merijn, lavalike: related to my problem from 2 hours ago, I implemented a solution based on `Chan` and  `forkIO`, works well. Haven't introduced the "async" package yet, too much novelty for me in one day, but will play with it soon :)
05:53:54 <yushyin> cocreature: it does make sense for their packages,  I see the problem if you wanna use them for development but I argue that this would be a problem to itself because it’s a PITA to nurse my projects every time some packages were updated and I’m no longer able to build until I fix dozens of api change erros or whatever.
05:54:25 <merijn> yushyin: It doesn't make sense for their packages either, because they end up installing 100+ packages for pandoc for no good reason
05:54:42 --- mode: glguy set +v J
05:54:54 <merijn> yushyin: And unlike C, you can't sensible in-place upgrade any of those packages anyway, so why have them?
05:55:08 <yushyin> yes that’s true
05:55:22 <cocreature> I’ve only seen people that just use pandoc or whatever that they now have to install 100 packages
05:56:01 <quicksilver> some people, when faced with a problem, decide they need a package system with dependency support. They now have 100 problems?
05:56:05 <merijn> cocreature: The Arch subreddit had a huge thread complaining about "updating Haskell packages" (i.e. xmonad, pandoc, etc.)
05:56:25 <Rembane> I use Arch, good distro, but I use nix for all things Haskell.
05:56:37 <cocreature> the only time dynamic linking would provide a benefit is if there are users that install quite a few Haskell packages with shared deps
05:56:48 <merijn> quicksilver: 100s of dependencies when building an executable is fine. Having them in your system package manager...not so much
05:56:56 <cocreature> given the number of popular Haskell tools, that’s just not a good scenario to optimize for
05:57:41 <yushyin> I see only one good solution, more awesome haskell tools users want to use!
05:57:59 <quicksilver> I'm reasonable sure that when dynamic linking was brought in, that wasn't the advantage discussed
05:58:02 <Ariakenom> cocreature: Clearly arch has more faith in Haskell than you!
05:58:02 <quicksilver> (?)
05:58:11 <quicksilver> it was a few years ago and I'm hazy on the events
05:58:31 <Ariakenom> (/s)
05:58:31 <cocreature> so the advantage was that everyone is pissed off? :)
05:58:32 <alexelcu> dynamic linking would have the benefit of distribution without source code, which is important for some orgs
05:58:50 <noumenon> yeah, actually, when I used Stack before last formatting my computer, it was kinda annoying with the zillions of haskell-* packages
05:59:34 <noumenon> when doing system updates, that is
06:00:13 <quicksilver> I can't remember. When I first used haskell all haskell libraries were statically linked in.
06:00:29 <noumenon> btw cocreature, here it tells me to install cabal-install as well to achieve what I think you were describing, or? https://wiki.archlinux.org/index.php/haskell#Building_statically_linked_packages_with_Cabal_.28without_using_shared_libraries.29
06:00:52 <noumenon> "For these reasons, you have to make sure that the only two related Haskell packages you have installed are ghc, the compiler, and ghc-static, the boot libraries on its static form, (not stack, cabal-helper[broken link: package not found], cabal-install and none of the haskell-* dynamic libraries available in the official repositories)."
06:00:58 <cocreature> noumenon: it doesn’t tell you to install cabal-install via pacman
06:01:09 <noumenon> oh, right, that's the point
06:01:46 <noumenon> got confused by the brackets, didn't realize cabal-install was inside the parantheses; it specifically says -not- to install cabal-install, heh
06:02:00 <quicksilver> ah. it was because GHC was previously using a hand-rolled linker
06:02:02 <quicksilver> see https://ghc.haskell.org/trac/ghc/wiki/DynamicLinkingDebate
06:02:07 <quicksilver> 7.8 is when the change was made
06:02:12 <yushyin> noumenon: of course that’s annoying :( ghc not providing any abi compatibility between builds means to rebuild _every_ dependency every time, so you got a lot of haskell updates.
06:02:26 <merijn> yushyin: The alternative is sacrificing lots of performance
06:02:38 <noumenon> yushyin: a lot indeed
06:03:39 <cocreature> quicksilver: I think you are confusing things here. This is about an Arch specific “problem” where maintainers decided to distribute all libraries dynamically linked. not a change in GHC’s default behavior
06:03:42 <noumenon> but I seem to recall that I was using Stack, and it says here: "You can also use Stack as an alternative build tool for Haskell packages, which will link statically by default."
06:04:17 <merijn> Pretty sure static is the default in cabal and GHC too
06:04:19 <quicksilver> cocreature: oh, ok
06:04:54 <yushyin> noumenon: that’s what I do, works so far.
06:05:05 <noumenon> ah, but the point is again that I would then install stack from ghc and not from the arch repos, right
06:06:04 <yushyin> that’s up to you? You can install static stack from the website or ghc/ghcup
06:06:59 <noumenon> I don't really like going outside package managers, at least it's only brought me pain in the past
06:07:28 <noumenon> not a particularly leet hacker, me
06:07:29 <yushyin> I was lazy enough to install stack by pacman and use it to install static ghc and all packages in my user directory
06:07:58 <noumenon> yes, that's what I seem to recall that I did the last time
06:08:14 <noumenon> or at least that I installed stack by pacman
06:09:12 <yushyin> not perfect I guess and some users don’t like stack but yeah ... works for me
06:10:28 <noumenon> uh, but I thought that brought on the problem of system updates updating haskell packages en masse?
06:10:33 <noumenon> at least that's what happened then
06:14:31 <yushyin> noumenon: no? I only have the packages which are needed by stack system-wide (and maybe packages from other tools), other stuff like static ghc or packages for projects are independently installed by stack to my user directory ~/.stack or something like that
06:15:11 <noumenon> hmm, ok, I'll try installing stack via pacman then, seems like the easiest method personally
06:15:32 <yushyin> a very similar approach is possible with ghcup, I think.
06:16:09 <rain2> where could i find a formal treatment of lambda calculus plus dynamic scope?
06:18:14 <yushyin> noumenon: maybe you have to tell stack to not use system-ghc 
06:22:52 <noumenon> https://pastebin.com/raw/X2XdDg7b
06:22:53 <noumenon> uh oh
06:23:10 <noumenon> abort mission
06:30:04 <tsaka__> i'm having som etrouble catching control C (userinterrupt) https://paste.ofcode.org/kZX6hTcpKhzbkarwdqa2Dr
06:30:29 <tsaka__> The code compiles but it doesn't work; ctrl-c is not handled, 
06:30:42 <tsaka__> (it just quits raw)
06:31:10 <cocreature> tsaka__: does runPeriodWrapper run in the main thread?
06:31:17 <tsaka__> cocreature: yes
06:32:22 <mcbear> Which tool do people use to count lines of code for Haskell?
06:34:46 <mniip> why would you do that
06:35:13 <hyperisco> grep/find cat and wc -l don't they? not a bash guy
06:35:37 <mcbear> Just found out that cloc supports Haskell
06:35:38 <hyperisco> maybe wc can read files itself
06:35:52 <yushyin> noumenon: other option you have are to install stack-bin from aur, or stack by hand, or ghcup by hand
06:36:25 <tsaka__> thats on linux, btw
06:37:02 <hyperisco> WSL baby
06:37:26 <cocreature> tsaka__: it seems quite unlikely that the exception is thrown during "return fn" so it’s probably thrown somewhere before or after that and your catch never gets triggered
06:38:07 <Putonlalla> Wrap the whole program in an exception handler and see if that works first, tsaka__.
06:38:15 <tsaka__> cocreature: the program spends all of its time inside "fn"
06:38:19 <cocreature> tsaka__: maybe you’re looking for "evaluate fn"?
06:38:29 <cocreature> potentially combined with deepseq
06:44:15 <Ariakenom> tsaka__: Still could happen between periods?
06:44:43 <tsaka__> Ariakenom: that's a chance ill take
06:45:07 <Ariakenom> keeping it as a bubbling exception would be my suggestion
06:45:18 <cocreature> my point is "return fn" does not evaluate fn
06:45:25 <cocreature> so you aren’t spending any time on this
06:46:17 <Ariakenom> and adding handle or finally as high up as possible
06:47:26 <tsaka__> I switched to "evaluate", now the code gives non-exhaustive-pattern, added a print, waiting for compile ..
06:52:54 <tsaka__> quiz: given you press Ctrl-C when running "fn" in this code -- what gets printed? https://paste.ofcode.org/HjGDMyDqUkscgTYhKYqMUb
06:53:06 <tsaka__> (the code compiles and works)
06:56:50 <adius> Hi everyone, I'm currently writing a book in which I'll compare most major programming languages (https://www.programmiersprachenbuch.de/).
06:56:50 <adius> Are there any book / papers / articles I should definitely have read?
06:57:53 <Taneb> adius: it's an old one, but "Why Functional Programming Matters"
06:58:31 --- mode: glguy set +v fen
07:00:30 <fen> how can a constructor such as for a traversable type of the form data A a = A Int a a be partially applied such as first A Int, then A Int a and finally A Int a a
07:02:20 <merijn> fen: What exactly do you mean by that?
07:03:01 <fen> similarly, how can it be deconstructed sequentially to yield a,a,Int one value at a time
07:03:13 <merijn> fen: It can't be
07:03:18 <hyperisco> When you destruct it you get all the values at once
07:03:33 <merijn> Pattern matching always matches the entire thing
07:03:50 <adius> Taneb: Thanks! Added it to my "toread" directory 😁
07:05:12 <Putonlalla> That's a funny name for a write-only directory.
07:05:13 <hyperisco> If you like, 'A' the constructor is ternary (Ac), but 'A' also names a function (Af) which curries Ac.
07:05:33 <fen> so would matching all the values and returning e.g. (a,A Int a) and then (a,A Int) and finally (Int,A) be expensive?
07:06:08 <hyperisco> That's not how it works fen. You match as  A x y z
07:06:39 <hyperisco> @define data A a = A Int a a
07:06:40 <lambdabot>  Defined.
07:06:48 <fen> :t A 0
07:06:49 <lambdabot> a -> a -> A a
07:06:53 <hyperisco> @define anA = A 0 1 2
07:06:54 <lambdabot>  Defined.
07:07:06 <hyperisco> > let A x y z = anA in (x, y, z)
07:07:07 <lambdabot>  (0,1,2)
07:08:07 <reygoch> So, is it possible instead of this: class NV a where nv :: Proxy a -> Integer
07:08:15 <fen> > :t let A x y z = anA in (z,A x y)
07:08:15 <reygoch> to do something like this: class NV a where nv :: forall a. Integer
07:08:17 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
07:08:23 <fen> :t let A x y z = anA in (z,A x y)
07:08:25 <lambdabot> (Num a2, Num a1) => (a1, a2 -> A a2)
07:08:44 <reygoch> I'm trying to use TypeApplications instead of Proxy
07:09:26 <hyperisco> fen, you haven't constructed an 'A' (the type, At) until you have saturated Ac
07:09:41 <fen> the problem seems to be trying to pattern match on the partially applied datatype
07:09:54 <hyperisco> you cannot pattern match on functions
07:10:06 <merijn> fen: It's not a "partially applied datatype" it's a partially applied function that (when fully applied) will give you a datatype
07:10:18 <reygoch> *value
07:11:29 <fen> reygoch: the version of the class NV with the forall can be used with TypeApplications and AllowAmbiguousTypes
07:11:54 <reygoch> Yes, but I was hoping to avoid AllowAmbiguousTypes
07:11:57 <exarkun1> Attempting to build a package for Hackage, `cabal sdist` complains "Warning: Cannot run preprocessors. Run 'configure' command first.".  `cabal configure` fails.  `cabal new-configure` seems to succeed but doesn't have any side-effects.  What do I do?
07:12:00 <Putonlalla> Perhaps you want type families instead, reygoch.
07:12:26 <fen> reygoch: but thats what TypeApplications is for, to allow ambiguous types to be resolved by specific type annotations
07:12:28 <reygoch> Putonlalla: no I don't think so
07:13:07 <reygoch> Also, is it possible to create instance of type class for promoted data type?
07:13:35 <fen> thats where you would need type families
07:13:38 <reygoch> like data AB = A | B, instance NV A where nv
07:13:48 <merijn> exarkun1: Well, does your package use any preprocessors? (c2hs, hsc2hs, etc.)
07:13:57 <hyperisco> with PolyKinds should be able to
07:14:03 <exarkun1> merijn: I don't think so
07:14:08 <fen> the class NV would also be a type family instead of a class
07:14:12 <merijn> exarkun1: Then just ignore that warning :p
07:14:33 <exarkun1> ignoring warnings seems less than optimal?
07:14:46 <lavalike> is there a generic Semigroup g => a -> g?
07:14:47 <reygoch> fen: but wouldn't that mean it can only operate on type level? I actually want to extract a value from type level in this case
07:14:56 <exarkun1> is it typical to use preprocessors?  or do 98% of projects get this warning and maintainers just ignore it?
07:15:01 <merijn> exarkun1: Basically, "cabal sdist" might have to run preprocessors, which relies on "cabal configure" to succeed. But if you're using new-build configure isn't likely to succeed
07:15:19 <fen> there are not values at type level
07:15:22 <merijn> exarkun1: The problem is that you're mixing new-build and non-new-build commands
07:15:52 <merijn> exarkun1: If you were using "regular" build, then configure and sdist would "just work".
07:15:59 <exarkun1> is there something I should do instead of sdist?  I'm just following hackage upload instructions.
07:16:04 <reygoch> fen: Singletons?
07:16:06 <lavalike> e.g. if your type is inferred to be g = Last a, such function becomes Last :: a -> Last a
07:16:19 <merijn> exarkun1: "new-sdist" would solve this, but new-sdist doesn't yet produce packages that are Hackage legal, last I tried.
07:16:20 --- mode: glguy set +v mnoonan_
07:16:22 <mnoonan_> lavalike: http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-328 ?
07:16:48 <fen> lavalike: wouldnt it be forall b. b -> Last a ?
07:16:55 <merijn> exarkun1: If you're using new-build and not using any preprocessors, the simplest solution is: Just use sdist and ignore that warning :)
07:17:07 <merijn> exarkun1: Hence, that being my initial advice
07:17:19 <lavalike> fen: I mean in the context of a more complicated function, that unifies g with something specific and a with something else specific
07:17:31 <merijn> exarkun1: In the very near future new-sdist should work properly and avoid this issue
07:17:42 <lavalike> mnoonan_: so that's semigroup
07:17:48 <exarkun1> Okay, thanks.  And I do appreciate the explanation as well as the suggestion. :)
07:18:34 <lavalike> to give more context, I have this:  Semigroup g => (a -> g) -> (g -> Bool) -> [a] -> [[a]]  and I wonder if I can get rid of the first param
07:18:51 <merijn> exarkun1: Also "new-configure" does have side-effects, it creates a cabal.project.local file inside you working directory, which overrides cabal.project :p
07:19:35 <mnoonan_> lavalike: what is it supposed to do? I can't tell just from that signature.
07:19:50 <merijn> exarkun1: The idea is that cabal.project should be the "standard" everyone should use this to build the project settings that's checked into version control, while cabal.project.local lets you override settings from cabal.project while hacking on it (and should thus not be in version control)
07:20:29 <fen> reygoch: how are you meaning to use type families to extract a value?
07:21:09 <lavalike> mnoonan_: it's a scan, except it keeps an accumulator that you define with the projection to g, when the predicate g->Bool is false, it starts a new scan
07:21:17 <reygoch> fen: I don't mean to use a type families that's what you suggested. I'd like to have a data kind for which values I'd have class instances
07:21:54 <reygoch> fen: than I'd be able to have data AB = A | B; instance NV A where nv = 1; instance NV B where nv = 2;
07:22:01 <shapr> bitonic: nice to finally meet you!
07:22:03 <reygoch> fen: at least that's what I tried
07:22:21 <bitonic> shapr: likewise 🙃
07:22:27 <shapr> :-D
07:22:44 <exarkun1> merijn: got it
07:23:20 <fen> reygoch: wouldnt AB be the thing that instances are defined over?
07:23:56 <reygoch> fen: but since A is promoted data and I can pass it as a type I want to have instance for A
07:24:16 <fen> lavalike: how would that work without (a->g), is the idea just to have this as a constraint?
07:24:28 <fen> (the availabilty of a function of that type)
07:24:50 <fen> reygoch: you would use a type family to do that
07:24:59 <lavalike> fen: yeah I think it actually is not possible in general nor wanted, tinkering with it a bit
07:25:02 <fen> it can match on the type A
07:25:19 <lavalike> f Last (all isLower . getLast) ["aa","AA","bB","cc","CC","dd"] => [["aa","AA"],["bB"],["cc","CC"],["dd"]]
07:25:33 <lavalike> f (Sum . length) ((<=6) . getSum) ["aa","AA","bb","cc","CC","dd"] => [["aa","AA","bb"],["cc","CC","dd"]]
07:25:38 <reygoch> fen: I'm struggling to imagine how to do that :D, do you have time for a quick example?
07:25:43 <lavalike> you can't express th second with just Sum there
07:26:16 <reygoch> fen: oh wait, I think I just managed to imagine :D
07:27:09 <reygoch> fen: no, wait, it went away :(
07:27:31 <lavalike> fickle thoughts!
07:27:48 <reygoch> indeed
07:28:20 <fen> reygoch: would you like to try and write it?
07:29:05 <reygoch> fen: I'll try to write this on my own. I think it's crystalizing in my head.
07:31:13 <shapr> bitonic: are you doing any interesting researchy stuff at the moment?
07:31:55 <bitonic> shapr: well, edwardk and ddarius plan of having system f + ext equality seems a nice researchy thing
07:32:07 <bitonic> and then the usual computer vision routine
07:32:15 <shapr> I heard a small part of that discussion, but would like to read more
07:32:32 * shapr follows bitonic on github
07:32:39 <reygoch> fen: ok, so I see how I'd write something like that with proxy but I'm struggling to do it without proxy. can you help?
07:32:43 <fen> lavalike: how would you specify that you mean to have length as the Int "measure"
07:33:09 <bitonic> shapr: the idea is just to have system f and extensional equality a-la nuprl so that we can do a lot of cool stuff that edwardk wants to do, mostly with type classes
07:33:09 <lavalike> fen: exactly
07:33:29 <fen> what about implicit params?
07:33:31 <lavalike> fen: my previous example all just had the semigroup's constructor in there so I thought I didn't need it
07:34:14 <lavalike> fen: and the counterpart that is given as part of the other function would be enough to select it in as the first function
07:34:35 <lavalike> even tho I don't need this it is still an interesting question as to how one would do that
07:34:48 <fen> do what?
07:35:40 <lavalike> have a function   g (all isLower . getLast) [...]   that is the same as   f Last (all isLower . getLast) [...]
07:36:30 <fen> that removes the ambiguity introduced by the example with length
07:36:31 <Saizan> bitonic: a-la nuprl really meaning like types as predicates on "realizers", or just equality reflection?
07:36:43 * shapr hugs Saizan 
07:36:53 * Saizan hugs shapr 
07:36:55 <bitonic> Saizan: hey! long time no see
07:37:00 <bitonic> Saizan: equality reflection
07:37:01 <lavalike> fen: but how does g figure out it needs to apply Last to the elements of the list?
07:37:05 <Saizan> bitonic: indeed :)
07:37:07 <bitonic> although I do not know what "realizers" are actually
07:37:09 <dolio> So, not like nuprl. :)
07:37:53 <fen> you want to specify that Last is the inverse of getLast and use that?
07:37:59 <lavalike> yep
07:38:03 <Saizan> i guess Cedille is going more the nuprl way in that sense
07:38:20 <bitonic> dolio, Saizan: actually, the right answer to Saizan's question is a question: what are "realizers"?
07:38:20 <dolio> Kind of.
07:38:22 <fen> then whats the question?
07:38:43 <lavalike> fen: how do you write g
07:38:57 <shapr> I wish to realize what are realizers.
07:39:07 <fen> using the constraint that the constructors have a specified inverse
07:39:18 <Saizan> bitonic: so, for nuprl the idea is that the type judgment really means that a certain untyped (lambda calculus
07:39:20 <lavalike> fen: how do you express that in haskell?
07:39:23 <dolio> bitonic: nuprl is really a completely different philosophy than intensional/extensional type theory, if you hear people talk about it.
07:39:25 <fen> with a typeclass
07:39:38 <lavalike> fen: ah so I need something that is a group not a semigroup
07:39:41 <bitonic> my rough understanding of nuprl is that you need to produce the typing judgements to match the untyped lambda calculus rather than a proof term of the right type (a-la coq, agda, ...)
07:40:19 <Saizan> bitonic: right, the realizers are these untyped LC terms
07:40:22 <bitonic> i see
07:40:39 <Saizan> bitonic: and types are partial equivalence relations over them, which carve out the proper ones
07:40:43 <fen> lavalike: how would that help, anyway, it would be Monoid not Group
07:40:50 <bitonic> so i think my answer is correct
07:41:08 <lavalike> fen: I confused things, I don't need the inverse of the group element, I need the inverse of the "destructor" if you will
07:41:15 <fen> thats nothing like the invertable coerce you have surgested, its just an identity element
07:41:20 <bitonic> you have a typed core, but you also have equality + equality reflection, so to prove equalities you do need to show the judgements rather than just a proof term
07:41:25 <bitonic> (the typed core being system f)
07:42:00 <Saizan> makes sense
07:42:10 <bitonic> the background here is that edwardk wants to have a very rich type class system where you can talk about laws first-class
07:42:23 <dolio> I think maybe the simplest analogy is that it's almost more like building things in set theory, except instead of sets, it's lambda terms.
07:42:30 <bitonic> right, yes
07:42:40 <shapr> first class laws sounds amazing
07:43:01 <lavalike> fen: it's a bit annoying that the solution is writing your own new class instead of working out of the box with all semigroups
07:43:26 <Saizan> dolio: what's that an analogy for?:)
07:43:31 <dolio> nuprl
07:43:39 <fen> its not semigroup, the resulting value is not unique 
07:43:55 <Saizan> right, it's more material than structural
07:44:39 <bitonic> Saizan: i have a question for you! do you know how nuprl uses higher-order unification? specifically what the interplay is between "manually" constructing judgements and unification simplifying equations for you
07:45:00 <bitonic> i wanted to try it out but actually using nuprl seems impossible
07:45:06 <lavalike> fen: which resulting value?
07:45:07 <bitonic> you need to download a 5GB VM or something :P
07:45:18 <dolio> bitonic: Yeah, probably better to try e.g. redprl.
07:45:21 <Saizan> bitonic: not really, i've never used nuprl itself either
07:45:30 <dolio> I think that was developed because it's so hard to actually run nuprl.
07:45:37 <bitonic> dolio: but that brings all the cubical jungle with the extensional banana :(
07:45:37 <fen> lavalike: whatever is wrapped and unwrapped by the newtype
07:45:56 <Saizan> bitonic: andromeda might be something to look at too
07:46:00 <dolio> I don't think that's right. Isn't that in the new thing he's working on?
07:46:05 <bitonic> i have grepped redprl and it does implement higher-order unification
07:46:17 <bitonic> dolio: redprl implements cubical type theory as far as i can tell
07:46:29 <lavalike> fen: sorry I lost you
07:46:55 * bitonic googles andromeda
07:46:58 <fen> (Coercible a (MyNewtype a),Coercible (MyNewtype a) a) is the bijection you describe as a constraint
07:47:24 <bitonic> Saizan: http://www.andromeda-prover.org/ ah, very cool! that looks interesting
07:47:50 <Saizan> that one, yes
07:48:06 <bitonic> the us air force is behind equality reflection, it seems 😌
07:48:35 <dolio> Hmm. Maybe you're right. I thought they started a rewrite before the cubical stuff. But I don't pay close attention.
07:48:40 <Saizan> too powerful to care about termination
07:48:55 <bitonic> > Whenever the nucleus needs to check a non-trivial equation, it triggers an operation (question) which propagates to the meta-level. There it is intercepted by a user-defined handler which handles (answers) the equation by providing a witness for it.
07:48:57 <lambdabot>  <hint>:1:59: error: parse error on input ‘,’
07:48:57 <dolio> Now I don't understand what the rewrite is for.
07:49:06 <bitonic> Saizan: this gives a hint of what the interplay might be
07:49:16 <bitonic> but intuitively, it seems like things might get really confusing
07:49:16 <Saizan> dolio: i think they also have an intensional proof assistant with cartesian cubes
07:49:43 <bitonic> sorry lambdabot didn't mean to summon you
07:50:17 <lavalike> fen: right
07:50:33 <dolio> Saizan: Was it 1-dimensional but still presented as cubes before?
07:51:40 <bitonic> Saizan: the terms seem to be typed for andromeda though http://www.andromeda-prover.org/type-theory.html
07:51:46 <Saizan> bitonic: i think in practice it means that you have to locally say which equalities you want to hold definitionally, either during reduction or during eta-expansion, so it's a bit more directed
07:52:39 <asheshambasta> Attoparsec or Megaparsec?
07:52:44 <Saizan> bitonic: right, it seems that beta-reducing actually needs to the type of the function to match the type of the argument, if you want things to be sound
07:53:16 <bitonic> mhm ok
07:53:32 <bitonic> Saizan: what i'm mostly wondering here is how it can work without ending up being a bit insane for the user
07:53:36 <Saizan> so andromeda is not nurpl style at all
07:54:25 <bitonic> well i don't care so much for nuprl, i'm mostly wondering about the ergonomics of eq. reflection + higher order unification working together and with the user
07:54:25 <fen> ok, with the question about partially applied constructors, the defunctionalisations symbols can be sequntially returned
07:54:31 <Saizan> bitonic: their point is that the user does not write the actual terms, but more like simple tactics that produce it
07:55:06 <Saizan> bitonic: although andromeda is indeed a research project, so i bet it hasn't had many users yet
07:55:14 <Saizan> i haven't really tried it either
07:55:18 <bitonic> Saizan: right but -- is unification a tactic in the same sense, and does it fire automatically everywhere or does the user invoke it?
07:55:38 <cocreature> asheshambasta: for most applications megaparsec
07:55:39 <bitonic> basically i'm trying to figure out how the pieces fit together to offer a decent experience
07:55:46 <fen> lavalike: still not sure how that was anything to do with Semigroup...
07:55:46 <cocreature> asheshambasta: especially if your input is generated by humans
07:56:24 <lavalike> fen: it doesn't, my example just had a random type variable of class semigroup that started the process
07:56:35 <asheshambasta> cocreature: okay, whats the major advantage over attoparsec? Fancier error messages ?
07:56:38 <fen> oh ok
07:56:40 <Saizan> bitonic: i think unification would fire automatically, but putting an equality as something you should use definitionally to typecheck the rest of the term would be a tactic
07:57:18 <dolio> I think Cedille is not very much like nuprl, either. The semantics are similar, but it's kind of more like OTT, where you have a language with its own constructs that are elaborated into the lambda term semantics.
07:57:19 <Saizan> bitonic: you could also check the REWRITE pragra in Agda, though that gives fewer guarantees
07:57:23 <cocreature> asheshambasta: better error messages, a more comprehensive API, …
07:57:46 <lavalike> fen: it is probably better just to be explicit and say what those two functions are anyway, I was wondering if I could unify a magical function proj :: a->g inside the definition of my f since the 'g' is fixed 
07:58:11 <dolio> Although some of the surface stuff may involve talking about the elaboration.
07:58:12 <Saizan> dolio: equality checking looks at the "realizers" though, right?
07:58:56 <asheshambasta> cocreature: understood. Thanks!
07:59:40 <dolio> Yeah, I think it probably does.
08:00:09 <dolio> Doesn't nuprl let you define your own equality for types that may have little to do with the realizers?
08:00:29 <fen> lavalike: do you have the way to do what you need now?
08:00:38 <Saizan> dolio: i think it still has to respect reduction at least
08:00:52 <dolio> Yeah, I guess that makes sense.
08:01:56 * Saizan goes for dinner now
08:01:56 <mnoonan_> is hoogle.haskell.org working for other people? I'm not successfully getting query results back.
08:02:20 <lavalike> fen: I just realized I don't need to do it, I am still curious whether there is a way to do g p xs = f (???) p xs for some ???
08:02:22 <mnoonan_> and I recently took a shot at fixing type search, so I'm a bit concerned that I've killed it :|
08:02:44 <mniip> ECONNREFUSED
08:02:49 <mnoonan_> hmm
08:03:46 <cocreature> mnoonan_: doesn’t seem to work for me
08:03:52 <elgoosy> hi, {-# LANGUAGE OverloadedStrings #-}. Where do i find documentation or something about these kind of template language imports? Are these produced like packages by users? Or are they baked in the ghc compiler?
08:04:28 <fen> lavalike: i wonder if anyone else is following this, your last comment seems absurd
08:05:13 <fen> is it a question about modifying whats in wider scope?
08:05:15 <mnoonan_> cocreature, mniip: damn. thanks.
08:05:16 <bitonic> Saizan, dolio: i guess i brought up nuprl just because it's the only thing i know with equality reflection. maybe i should have phrased the question as "how does human-directed equality reflection interact with machine directed unification?"
08:05:30 <mniip> elgoosy, these are called language pragmas, they enable extensions in the compiler
08:05:48 <elgoosy> mniip: so template haskell is not that? 
08:05:49 <mniip> elgoosy, see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/lang.html
08:05:57 <mniip> template haskell is one of the extensions
08:06:05 <mniip> {-# LANGUAGE TemplateHaskell #-}
08:06:12 <elgoosy> thank yoU!
08:09:45 <fen> bitoinic: it breaks it completely
08:10:36 <merijn> elgoosy: The GHC user's guide has lots of documentation on all extensions
08:13:03 <lavalike> fen: no just a simple haskell definition, suppose you have f :: Semigroup g => (a->g) -> (g->Bool) -> [a] -> [[a]] is it possible to write f' :: Semigroup g => (g->Bool) -> [a] -> [[a]]; f' = f x where x = ???
08:14:25 <fen> where is it supposed to get this ommited function from? a constraint? the global scope?
08:14:47 <lavalike> fen: so as it is, no, it's not possible, it needs the get the info from say, another constraint
08:15:17 <lavalike> fen: was trying to figure out if there was a way to go from the type "Last a" to the constructor "Last :: a -> Last a" and similarly for all Semigroups
08:16:04 <lavalike> (again nothing specific to semigroups, it is just the class I was working with there)
08:16:18 <shapr> Tritlo: was the video for your talk uploaded at some point?
08:16:39 <fen> what was wrong with the bijection constraint above?
08:16:40 <shapr> I want to give a lightning talk about "suggesting valid hole fits for typed holes"
08:17:49 <fen> shapr: wouldnt it also need exaustive unit tests?
08:17:51 <lavalike> fen: I don't understand it I guess
08:18:20 <fen> it just recoverse the constructor of a newtype from the newtype
08:18:28 <phadej> shapr: i.e. how they work, not how to use them?
08:18:31 <lavalike> fen: how do you use it?
08:19:34 <fen> the newtype constructor is the implementation of one direction, and pattern mathcing is used to implement the other direction
08:19:40 <shapr> phadej: more that I want to give a talk on how type inference and suggesting valid hole fits can make type driven development very much fun
08:20:38 <lavalike> fen: interesting! in my construction I don't give g the newtype constructor, I give it that other function that takes the newtype and unwraps it, and I want the constructor, are you saying I can use pattern matching to do that?
08:21:26 <shapr> phadej: mind you, I'm giving the talk to a company where the most common languages are go and python with some C/C++
08:21:41 <fen> if your newtype implements that constraint it captures the abstraction you describe
08:22:12 <lavalike> fen: do the newtypes I am interested about implement your constraint?
08:22:23 <inkbottle> Does ghc use an execution stack at all? (example in mind: `let {f 0 () = 1 ; f n () = n * f (n-1) () ; g = f 3} in g ()`)
08:23:12 <fen> shapr: something like autocompletion, they have that in Coq right? as long as the search is over modules that compile it would work, but it fails then on the current module
08:23:50 <cocreature> inkbottle: there is no call stack
08:24:24 <fen> lavalike: not sure if there is a module that provides these, maybe it would just be a good personal preactice to addopt to write these instances when declaring newtypes
08:24:45 <lavalike> fen: but I'm not writing new newtypes, I'm just using the library ones
08:24:49 <cocreature> inkbottle: but there is a stack for pattern matches
08:25:29 <fen> well since they dont provide these you would need to write the implementation of that bijection if you wanted to use it
08:25:43 <inkbottle> cocreature: OK, no call stack at all, hum...
08:26:10 <lavalike> fen: thanks for indulging the questions, appreciate it
08:26:47 <cocreature> inkbottle: if you’re interested in how Haskell is actually executed, I recommend the STG paper https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf
08:27:10 <fen> not sure why this isnt standard practice really, possibly as the record access syntax provides a better interface where specific names are given to the deconstructors as apposed to using type annotation to resolve the coerce. oh right that would overlap horribly, probably not a good idea then
08:27:17 <phadej> shapr: https://skillsmatter.com/skillscasts/12641-lightning-talk-moving-towards-dialogue-collaborating-with-your-computer-using-typed-holes might be a good start
08:27:34 <inkbottle> cocreature: Nice, was what I was going to ask ;)
08:27:48 <phadej> shapr: or then the Alex Zimmerman's talk on HIE: he demoes typed-holes there too
08:28:20 <cocreature> inkbottle: don’t be scared by the length, chapter 4 and 5 are what you probably want to focus on
08:28:24 <fen> maybe including the constructor explicityly is the only way round that, and then it would probably just be best to adhere to some naming convention like runNewtype or somthing
08:29:00 --- mode: glguy set +v Janta
08:29:13 <fen> as the constructor itself can be matched on, without a way to generate the defunctionalisation symbol
08:29:23 <fen> cant*
08:30:19 <mnoonan_> whee, I didn't break hoogle after all!
08:31:30 <inkbottle> cocreature: roger that; not even scared a bit ;)
08:33:03 <fen> wait sorry thats wrong, for newtypes there is only one constructor so its ok
08:33:13 <lavalike> fen: :D
08:33:33 <fen> the coerce can be resolved using the newtype 
08:34:46 <merijn> inkbottle: I second the STG paper, it's a very good read and pretty accessible if you know the basics of Haskell and maybe a little bit of C/asm
08:40:14 <inkbottle> merijn: I've got a little bit of background in that matter; plus, seems like a must read: obstacles will be overcome ;)
08:48:59 <vaibhavsagar> shapr: I also gave that talk at !!Con - https://www.youtube.com/watch?v=0oo8wIi2qBE
08:58:33 <oo_miguel> I do not see how to tell hp2ps to show data from a longer range? It gets cut off after a few seconds.. 
08:58:35 <cppxor2arr> dminuoso: btw could you elaborate on what you meant when you learned to be careful with StateT?
09:00:08 <dminuoso> cppxor2arr: So one revelation I've had, was that I quickly ended up having resource management problems in monad transformers.
09:00:49 <cppxor2arr> oh is the garbage collector a problem?
09:00:53 <dminuoso> No.
09:01:23 <dminuoso> Basically the thought is `bracket` doesnt work for monad transformers unless you use something like MonadBaseControl which is really difficult to understand, and still more difficult to get right.
09:02:38 <cppxor2arr> does ReaderT have this problem too?
09:02:49 <dminuoso> For ReaderT you can have unlift-io
09:02:59 <cppxor2arr> oh cool
09:03:08 <dminuoso> *unliftio
09:04:58 <cocreature> it might be worth pointing out that these gotchas are caused by using StateT on top of IO. StateT in pure code is totally fine
09:10:13 * asheshambasta is in love with Haskell
09:10:38 * asheshambasta is also in love with ghcid
09:10:51 <jose_zap> <3
09:13:07 <Solonarv> when I need state + IO I usually just do something along the lines of ReaderT (bunch of IORefs) IO
09:16:48 <dminuoso> cocreature: It's pretty cool if you understand StateT not as "How to do state in Haskell" but rather "How to do *pure* state in Haskell if you dont want to do it in IO"
09:16:50 <amosbird_> hi, why does "Currying != Partial function application" ?
09:16:59 <dminuoso> It's quite liberating to have the choice of "either do it in IO" or "use State/StateT"
09:18:27 <Solonarv> currying is the transformation from ((a, b) -> c) to (a -> (b -> c)); partial application is *anything* that lets you supply only some arguments to a function, and get back a function that just expects the remaining ones
09:18:52 <dminuoso> amosbird_: Let me give you a real world Haskell example of displaying the difference
09:18:54 <dminuoso> > let f = \(!a) -> \b -> () in f undefined `seq` ()
09:18:56 <lambdabot>  *Exception: Prelude.undefined
09:18:58 <dminuoso> > let f = \(!a) b -> () in f undefined `seq` ()
09:18:59 <lambdabot>  ()
09:19:44 <ski> also, it's not "Partial function application" (or at least, that to me suggests the reading "(Partial function) application". it's not about partial functions). i simply say "Partial application"
09:20:20 <dminuoso> amosbird_: currying is about stating that every function can have only one argument. so a "multi arg function" is actually constructed by functions returning functions.
09:20:33 <cocreature> dminuoso: that seems more like a Haskell-specific oddity rather than something fundamental to the difference between currying and partial application
09:20:44 <dminuoso> cocreature: Mmm I guess
09:21:13 <Solonarv> indeed, and also rather confusing to a newbie - what's the exclamation mark mean? what does `seq` do?
09:21:16 <ski> `curry f' is a currying of `f'. `curry f x' is a partial application of `f' to `x' (as is `\y -> f(x,y)', which is the same thing). `flip (curry f) y' (which is equal to `\x -> f (x,y)') is another partial application of `f', on another argument `y'
09:21:17 <amosbird_> dminuoso: aren't partial function application returning functions ?
09:22:15 <ski> if `g :: A -> B -> C', then `g x' (which is `\y -> g x y') is a partial application of `g', and `\x -> g x y' (aka `flip g y') is another partial application of `g'
09:22:26 <ski> amosbird_ ^
09:22:34 <ski> amosbird_ : "aren't partial function application returning functions ?" -- no
09:22:36 <dminuoso> amosbird_: so take `fmap (+)` - then in every sense this is not "partially applied" - currying suggests there is more going on. This is even reflected in the type syste,.
09:22:42 <dminuoso> :t fmap
09:22:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:22:59 <dminuoso> fmap is a function that takes a function (a -> b) and turns it into `f a -> f b`
09:23:07 <cocreature> currying refers to transforming a function that takes multiple arguments into a chain of functions each of which takes a single argument
09:23:38 <amosbird_> cocreature: oh, thanks
09:23:43 <cocreature> when your function is curried you get partial application for free
09:23:48 <ski> amosbird_ : partial application is about supplying some, but not all, of *multiple* arguments. strictly speaking, all functions in Haskell takes exactly one argument. it's a figure of speak to say that `x' and `y' in `f (x,y)', or in `g x y', are multiple arguments of `g'. and that's what we're talking about, when we're talking about partial application
09:24:00 <dminuoso> amosbird_: I mean ignore the implementation details for a moment. Once you have done `fmap (+)` be assured your function has already been transformed.
09:24:01 <ski> s/speak/speech/
09:24:09 <dminuoso> That is the action of `fmap` has been done the moment you apply it to a function
09:24:14 <dminuoso> l
09:24:34 <dminuoso> (Ignoring evaluation order here because that's not my focus)
09:24:37 <amosbird_> so all haskell functions are curried by default ?
09:24:43 <ski> no
09:24:48 <ski> currying is a convention
09:24:57 <Solonarv> not *all* of them, but close enough ;)
09:25:03 <amosbird_> ok
09:25:03 <dminuoso> amosbird_: IT depends on how you look at it.
09:25:12 <amosbird_> dminuoso: huh?
09:25:23 <cocreature> at least when it comes to the type system they are all curried
09:25:33 <ski> there is no "this function is curried". there is only "this function is curried (or not), if you *consider* these as being *multiple* arguments"
09:25:36 <dminuoso> amosbird_: so when C has a function `char f(char, int)` then the direct equivalent would be `(Char, Int) -> Char`
09:25:40 <dminuoso> amosbird_: is this a multi-arg function?
09:25:45 <cocreature> the operational semantics can be slightly different but the type system only knows single-argument functions
09:25:52 <dminuoso> Kind of depends on how you look at it really :)
09:26:29 <ski> Solonarv : all functions take exactly one argument, in Haskell. currying is a convention. a way of construing functions. it's not an objective property of the function in the language itself, it's a statement about how you *think* about it
09:27:02 <dminuoso> `fmap` is a function that transforms functions - this was one of my brightest days in my early haskell :)
09:27:13 <ski> then it's another matter that the syntax of Haskell is *designed* to make such curried functions nice to use :)
09:27:33 <dminuoso> amosbird_: the important thing is to remember how (->) really associated. 
09:27:39 <dminuoso> *associates.
09:27:43 <dminuoso> :t fmap 
09:27:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:27:57 <dminuoso> fmap :: Functor f => (a -> b) -> (f a -> f b)
09:28:06 <dminuoso> This is the same with just optional parens added.
09:29:40 <ski> Solonarv : if i define `foo ((x0,x1),(y0,y1)) = ...', then i *could* think of `foo' as taking a single argument (being a certain nested pair), or two pairs, or perhaps four arguments (groups in a certain way, perhaps for emphasis)
09:30:24 <Solonarv> I know all this; why are you explaining it to *me*?
09:31:34 <ski> you said "not *all* of them, but close enough", suggesting that "all haskell functions are curried by default" would hold for most of them at least ?
09:32:03 <ski> while i was focusing on the objective vs. subjective
09:32:18 <Solonarv> what I meant was "most function are 'curried', but some arguably aren't"
09:32:53 <maerwald> nitpicking time
09:33:08 <Solonarv> examples of arguably-not-(fully-)curried functions: stuff in Data.Array / Data.Ix; also fst/snd if you want to be cheeky
09:35:14 --- mode: glguy set +v mnoonan_
09:35:15 <mnoonan_> :t uncurry  -- extra cheeky
09:35:16 <lambdabot> (a -> b -> c) -> (a, b) -> c
09:36:53 <c_wraith> :t uncurry snd
09:36:54 <lambdabot> ((a, b -> c), b) -> c
09:37:05 <c_wraith> err. that's backwards!
09:37:09 * Clint blinks.
09:37:41 <Solonarv> :t curry . uncurry -- hah!
09:37:42 <lambdabot> (a -> b -> c) -> a -> b -> c
09:38:03 <Solonarv> :t uncurry uncurry -- double hah!
09:38:04 <lambdabot> (a -> b -> c, (a, b)) -> c
09:41:52 <t7> can i play with linear types in haskell without building my own ghc?
09:42:13 <dminuoso> t7: I think not
09:44:14 <cocreature> I think there might have been a cachix repo with a build for linear types at some point but I might be misremembering
09:44:35 <dminuoso> t7: https://hub.docker.com/r/tweag/linear-types/
09:44:57 <dminuoso> t7: Gives you access to a linear-types GHC
09:45:46 <t7> awesome, thanks
09:48:00 <int-e> :t flip (flip . curry (flip uncurry))
09:48:01 <lambdabot> (a1 -> a2 -> c) -> a1 -> a2 -> c
09:49:23 <Solonarv_> :t curry . flip . uncurry id
09:49:25 <lambdabot> (b1 -> a1 -> (a2, b2) -> c, b1) -> a2 -> b2 -> a1 -> c
09:56:16 <exarkun1> How do you supply a changelog for a hackage release?
09:56:27 <SegFaultAX> How do you usually pronounce (<$) in English?
09:56:36 <c_wraith> :t curry fst -- this function looks useful!
09:56:38 <lambdabot> c -> b -> c
09:58:57 <int-e> c_wraith: you're a source of constant surprises
09:59:24 <ski> Jetien : "i still like to be able to define my own instance of a monad somehow, (return and (>>=). In the implementation of these two  functions I'd like to make use of \"put\" and \"get\"." -- i strongly suspect that if you do that, you'll break the monadic laws
10:01:31 <ski> (`return x >>= k' should be equal to `k x'. so `return x' can't sensibly use `put' i think, since the other side of the equation wouldn't call `return', so no `put' call (`put' is not a discardable effect). `get' is discardable, but i don't think you can meaningfully use it either, inside `return' here)
10:02:02 <ski> (also the `(>>=)' disappears here on the right hand side, so similar remarks applies to that, i think)
10:03:07 <dminuoso> SegFaultAX: Im thinking about using `apconst`
10:04:02 <c_wraith> dminuoso, that operator really isn't a variant of ap. there's no function type involved.
10:04:13 <dminuoso> c_wraith: No, the ap is meant to hint at Applicative.
10:04:20 <SegFaultAX> I was thinking something like replace or fconst
10:04:27 <dminuoso> c_wraith: Im trying to figure out how to use the word `const` really
10:04:30 <exarkun1> It's like "freplace"
10:04:35 <dminuoso> Because both *> and <* are const-like
10:04:40 <c_wraith> :t (<$)
10:04:42 <lambdabot> Functor f => a -> f b -> f a
10:04:49 <dminuoso> Oh. 
10:04:53 <c_wraith> dminuoso, there isn't even an Applicative in there!
10:04:57 <dminuoso> Heh.
10:04:59 <ski> `ap' is `(<*>)'. this is a variant of `(<$>)', not `(<*>)'
10:05:08 <dminuoso> c_wraith: I kept staring at it seeing <* really.
10:05:15 <dminuoso> 2 hours of sleep will do that. :(
10:05:24 <Jetien> ski: thanks for replying. after some thinking i've arrived at: i don't actually do to stateful things in (>>=). I just want to define the monad instance and also have a state monad at the same time. Currently I'm at this, in case you're interested https://gist.github.com/smatting/595f8156b8d8642079ce47754d685d26
10:05:51 <SegFaultAX> How do you usually pronounce (<*) and (*>). I feel like my internal monologue reads them as left shark right shark or something.
10:05:57 <SegFaultAX> But there has to be a more precise name
10:06:08 <dminuoso> SegFaultAX: apconst and ignore
10:06:19 <reygoch> If I have type class like this: class NV a where nv :: forall a. Word how can I bind type variable from class instance that looks like this (which currently doesn't work): instance NV ( Proxy ( S n ) ) where nv = 1 + ( nv @( Proxy n ) )
10:06:24 <c_wraith> SegFaultAX, which one dances better? (that may be too USA-oriented of a meme)
10:06:27 <dminuoso> SegFaultAX: there we go! Now I should be right. :P
10:06:37 <SegFaultAX> dminuoso: :)
10:06:57 <dminuoso> SegFaultAX: or maybe `flapconst`
10:07:02 <reygoch> I can't really figure out how to bind type variable from type class instance to my function implementation
10:07:05 <dminuoso> If you see what I did there :P
10:07:06 <SegFaultAX> I'm not sure ignore is a good name
10:07:18 <SegFaultAX> Both effects are still run, it's just which side gets discarded.
10:07:42 <c_wraith> reygoch, you'll probably need the ScopedTypeVariables extension
10:07:47 <SegFaultAX> I almost want apLeft apRight, but that's confusing for the same reason ignore is.
10:08:08 <dminuoso> SegFaultAX: so apconst and flapconst! :P
10:08:49 <SegFaultAX> flapconst heh.
10:09:13 <dminuoso> SegFaultAX: *> might be pronounced `then` 
10:09:16 <reygoch> c_wraith: I've enabled it, but now I'v noticed that I'm missing class constraint on n. GHC was giving me some weird error
10:09:25 <reygoch> c_wraith: thanks anyway
10:09:40 <ski> Jetien : try removing the `Monad' part from the `deriving' clause
10:09:57 <ski> (Jetien : and also `Functor',`Applicative', in case you want to do those by hand as well)
10:11:02 * ski prefers calling `Functor f => f a -> f ()', `ignore'
10:11:23 <c_wraith> :t void
10:11:24 <lambdabot> Functor f => f a -> f ()
10:11:25 <SegFaultAX> Yea that's a much better ignore.
10:11:33 <c_wraith> too many names!
10:11:53 <ski> `void' should not (under that name) be in `Data.Functor' and `Control.Monad'
10:11:58 <ski> (in the FFI is another thing)
10:12:06 <ski> i want `void :: Void -> a'
10:12:59 <c_wraith> that ends up getting called absurd for some reason. probably the same reason foldr isn't called "list"
10:13:07 <dminuoso> ski: Go! Go fight for mathematical justice and shed all the bikes on the mailing list.
10:13:28 <dminuoso> c_wraith: Why should it be called list?
10:13:39 <c_wraith> :t maybe
10:13:40 <lambdabot> b -> (a -> b) -> Maybe a -> b
10:13:45 <c_wraith> :t foldr
10:13:46 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
10:13:54 <dminuoso> c_wraith: I consider foldMap to be the defining method of that class
10:13:58 <c_wraith> err. if you specialize it to []
10:14:23 <Jetien> ski: then it won't typecheck. In "instance Applicative Larala" i need LaralaState to be a monad. I think from the code in the gist I can build everything I need. I only suspect that it could be done much simpler
10:14:32 <cocreature> hm, I definitely prefer absurd :: Void -> a over void :: Void -> a
10:14:42 <dminuoso> Jetien: `LaralaState` cannot be a monad if that would not kind check.
10:15:20 <dminuoso> Or wait. Bah.
10:15:23 <dminuoso> I stop and go to bed.
10:15:27 <Jetien> :)
10:15:43 <ski> Jetien : did you try ?
10:16:24 <ski> Jetien : ohh
10:16:28 <Jetien> ski: of course. No instance for (Monad LaralaState)
10:16:37 <ski> sorry, i didn't notice you had both `Larala' and `LaralaState'
10:17:15 <Jetien> sorry. Yes, Larala is what it's about. I'm using this newtype wrapper to define my own monad. Should probably be monad transformer, right?
10:17:26 <ski> `Larala' looks like `WriterT [Text] LaralaState'
10:17:47 <ski> `pureLarala' is then `lift'
10:18:04 <Jetien> ski: yes.. probably... hmm..
10:21:12 <tathougies> Any haskell syntax generators like haskell-src-exts but with a smaller footprint
10:21:17 <tathougies> it's a massive dependency. Only generation, no parsing
10:24:15 <c_wraith> tathougies, if all you want is generation, can you get away with template Haskell's pretty printer?
10:24:28 <tathougies> is that in the template-haskell package?
10:24:30 <tathougies> yeah i probably could
10:24:58 <c_wraith> yeah, https://hackage.haskell.org/package/template-haskell-2.14.0.0/docs/Language-Haskell-TH-Ppr.html
10:25:08 <tathougies> that's a standard library, right? Should be pre-installed?
10:25:13 <tathougies> That sounds like it could work real well
10:25:20 <c_wraith> it comes with ghc, at least.
10:25:30 <tathougies> Oh nice it even looks haskell-src-exts compatible. Thank you c_wraith!
10:25:38 <c_wraith> whether or not that makes it part of the standard libraries could be argued.
10:29:44 <tathougies> c_wraith I'm already using enough of GHC-specific features in beam that there's no point pretending
10:30:52 <c_wraith> in practice, haskell is mostly a monoculture. nothing available to the general public really competes with ghc
10:31:32 <c_wraith> I was just commenting on the difference between "standard" and "comes with the compiler" :)
10:41:25 <alexelcu> This would be my first Haskell project 🙂
10:41:25 <alexelcu> https://github.com/alexandru/github-webhook-listener
10:41:46 <Solonarv_> I've been using stack for too long, I don't actually remember what all libraries come with ghc
10:42:45 <Solonarv_> alexelcu: oh damn I've quietly bemoaned the lack of this piece of glue before, nice!
10:44:23 <lavalike> alexelcu: cool
10:44:34 <cocreature> alexelcu: nice work!
10:45:13 <cocreature> alexelcu: two small suggestions: 1. use sequence_ instead of () <$ sequence … and 2. you can use finally instead of bracket_ (return ())
10:46:00 <alexelcu> thanks — that `bracket` should probably go away completely, since it's a file lock and deleting that file afterwards might create a race condition
10:48:22 <Solonarv_> also: import qualified Logger as Logger - "as Logger" is redundant
10:50:54 <alexelcu> Thanks, I fixed it ❤️
10:52:16 <Ariakenom> Improvements after IRC review :p
10:56:05 <lavalike> haskellLinter
10:58:54 <cocreature> we need a GHC plugin that automatically pastes your code here and outputs the responses as compiler warnings
11:00:23 <Solonarv_> from hlint to #haskell-lint
11:12:06 --- mode: glguy set +v fen
11:16:19 <bsima> Has anyone gotten the mysql library compiling on macOS? For me it fails with a bunch of C errors.
11:17:39 <pavonia> What errors?
11:19:21 <bsima> the mysql package includes a 'mysql_signals.h' file, which errors like "unknown type name 'my_bool'"
11:19:42 <t7> am i right in thinking that linear haskell is less expressive than rust, well in the ways that values with lifetimes can be restricted 
11:19:50 <bsima> presumably 'my_bool' is defined in libmysql or whatever, but it can't find that lib
11:20:05 <t7> there are functions we can write in rust that we can't in a language without lifetime variables and subtyping 
11:20:13 <bsima> I've added the correct (i think) paths to extra-lib-dirs
11:20:52 <cocreature> an unknown type is more likely to be caused by an incorrect header so extra-include-dirs not extra-lib-dirs
11:21:53 <cocreature> although the fact that you don’t get an error about a missing header suggests that the headers are present but that you might be using an unsupported version
11:22:16 <cocreature> bsima: which mysql library are you trying to compile?
11:22:29 <bsima> cocreature: I get the same error using 'extra-include-dirs'
11:22:45 <bsima> cocreature: https://github.com/paul-rouse/mysql
11:22:53 --- mode: glguy set +v dmrd_
11:24:31 <cocreature> bsima: https://bugs.mysql.com/bug.php?id=85131
11:24:49 <cocreature> bsima: is there a reason you are using this specific library? it doesn’t seem to be maintained very actively
11:24:54 <cocreature> maybe consider mysql-haskell instead
11:25:01 <bsima> it's used in persistent-mysql
11:26:06 <cocreature> apparently there is persistent-mysql-haskell which uses mysql-haskell instead
11:26:27 <bsima> hm, thanks i'll look at that
11:26:45 <bsima> so is this bug report saying that all I have to do is change "my_bool" to "bool"?
11:27:32 <cocreature> I think so but I’ve only taken a very brief look at it
11:27:40 <cocreature> might be worth opening an issue for
11:28:26 <bsima> yeah, thanks for your help. I'll probably just go with persistent-mysql-haskell, but I'll document what we learned in a ticket on the 'mysql' repo
11:32:40 <Ariakenom> t7: what weakness do you see compared to lifetime variables?
11:42:34 <Psybur> @hoogle F (G a) => F a => F (G a)
11:42:34 <lambdabot> Text.ParserCombinators.HuttonMeijerWallace item :: Parser s t e t
11:42:34 <lambdabot> Text.ParserCombinators.HuttonMeijerWallace stget :: Parser s t e s
11:42:34 <lambdabot> Text.XML.Basic.Attribute value :: T (T name string) string
11:42:57 <Psybur> @hoogle F (G a) -> F a -> F (G a)
11:42:58 <lambdabot> Control.Monad.Free.Church iter :: (f a -> a) -> F f a -> a
11:42:58 <lambdabot> Type.Hint hintType2 :: f ? ? -> p f -> f ? ?
11:42:58 <lambdabot> Type.Hint hintType2Arg1 :: f ? ? -> p ? -> f ? ?
11:43:50 <Psybur> @hoogle F (G a) -> (F a -> F a) -> F (G a)
11:43:51 <lambdabot> Control.Monad.Free.Church hoistF :: (forall x . f x -> g x) -> F f a -> F g a
11:43:51 <lambdabot> Control.Monad.Free.Church iterM :: Monad m => (f (m a) -> m a) -> F f a -> m a
11:43:51 <lambdabot> Glazier.React.Maker hoistWithAction :: (act -> act') -> F (Maker act) a -> F (Maker act') a
11:44:31 <Ariakenom> t7: can you write a pure mutation interface in rust, like with linear haskell?
11:44:31 <dmrd_> hey folks, quick question: is there a way to call GHC on a file with many undeclared names such that GHC gives me back the list of unrecognized names?
11:44:48 <MarcelineVQ> Psybur: anything here tickle your fancy? https://hackage.haskell.org/package/distributive-0.6/docs/Data-Distributive.html
11:44:50 --- mode: glguy set -v dmrd_
11:46:32 <MarcelineVQ> ehe nvm, for some reason I was reading your end type as G (F a), what sort of function are you looking for?
11:48:05 <Psybur> I have a Functor (Functor a) and a function that takes a Functor a. Im wondering if theres an existing pattern to apply that function to my value and retain that shape
11:48:52 <Solonarv_> uhhh... what? could you post a code example? (using e.g. gist.github.com)
11:49:06 <MarcelineVQ> mm, such as fmap?
11:49:25 <Ariakenom> bold suggestion
11:49:37 <cocreature> sounds like fmap to me :)
11:49:38 <Psybur> Well, specifically I have a Maybe (T a) and a function Maybe a -> Maybe a
11:50:11 <cocreature> function application?
11:50:33 <MarcelineVQ> I'm with Solonarv_ on this one now :>
11:50:36 <cocreature> assuming that function is actually polymorphic you can use it as Maybe (T a) -> Maybe (T a)
11:50:54 <Psybur> Oh, no its not polymorphic my b
11:51:04 <cocreature> what is b?
11:51:05 <Psybur> Well, it might be able to be
11:51:08 <Psybur> My bad
11:51:26 <cocreature> I’m going to join the ranks of Solonarv_ and MarcelineVQ and request a code sample :)
11:51:46 <Psybur> haha I might be able to just use fmap 
11:51:52 <Psybur> If I get stuck youll get your sample ;p
11:52:48 <ski> Psybur : so you have `Maybe (T a)', where `Functor Maybe' and `Maybe T'. that's not the same as `Functor (Functor a)' (it doesn't make sense to replace a type with a type class that it instances, in that way)
11:54:01 <ski> (sorry for notpicking, but this is confusing. both for us, and probably for you as well)
11:59:38 <Ariakenom> % :t fmap . fmap
11:59:38 <yahb> Ariakenom: (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
12:02:07 <Solonarv_> % :t fmap . fmap @Maybe
12:02:07 <yahb> Solonarv_: Functor f => (a -> b) -> f (Maybe a) -> f (Maybe b)
12:02:27 <Solonarv_> % :t fmap . fmap @_ @Maybe -- whoops, now it's right
12:02:27 <yahb> Solonarv_: ; <interactive>:1:17: error:; * Expecting one more argument to `Maybe'; Expected a type, but `Maybe' has kind `* -> *'; * In the type `Maybe'; In the second argument of `(.)', namely `fmap @_ @Maybe'; In the expression: fmap . fmap @_ @Maybe
12:02:41 <Solonarv_> er, or not - nevermind
12:03:58 <geekosaur> % :t fmap @Maybe . fmap
12:03:59 <yahb> geekosaur: Functor f => (a -> b) -> Maybe (f a) -> Maybe (f b)
12:10:01 <Solonarv_> ah there we go. I thought type applications bound less tightly, for some reason.
12:16:12 --- mode: glguy set +v foojin
12:18:03 <foojin> @type fmap . fmap . (. Just)
12:18:04 <lambdabot> (Functor f2, Functor f1) => (Maybe a -> b) -> f1 (f2 a) -> f1 (f2 b)
12:27:24 <foojin> Having that Maybe (T a) turn into a Nothing if the function gives at least one Nothing on the "contents of T" might be a trickier requirement.
12:29:53 <ski> @type traverse :: Traversable t => (a -> Maybe b) -> t a -> Maybe (t b)  -- ?
12:29:54 <lambdabot> Traversable t => (a -> Maybe b) -> t a -> Maybe (t b)
12:30:10 --- mode: glguy set +v brando
12:32:05 <Psybur> @hoogle These (F a) (F a) -> (a -> Maybe a) -> These (F a) (F a)
12:32:06 <lambdabot> Control.Monad.Trans.Free.Church iterM :: (Functor f, Monad m) => (f (m a) -> m a) -> F f a -> m a
12:32:06 <lambdabot> Data.Align alignVectorWith :: (Vector v a, Vector v b, Vector v c) => (These a b -> c) -> v a -> v b -> v c
12:32:06 <lambdabot> Data.These these :: (a -> c) -> (b -> c) -> (a -> b -> c) -> These a b -> c
12:35:42 <foojin> ski: Won't work for any Functor (that is, if the actual thing isn't already Traversable).
12:36:06 <ski> sure
12:36:32 <Psybur> @hoogle F (G a) -> G (F a)
12:36:33 <lambdabot> Control.Monad.Free.Church retract :: Monad m => F m a -> m a
12:36:33 <lambdabot> Control.Monad.Trans.Free.Church retract :: Monad f => F f a -> f a
12:36:33 <lambdabot> Control.Monad.Free.Church iter :: (f a -> a) -> F f a -> a
12:36:44 <ski> @type sequence
12:36:45 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:36:47 <ski> @type sequenceA
12:36:48 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
12:37:09 <Psybur> word
12:37:40 <brando> why does (x,y) not match x with the first 3 elements and it only matches the first?
12:37:55 <ski>   sequenceA = traverse id
12:38:19 <hyperisco> brando, (x,y) is a 2-tuple. I am not sure what your question is asking.
12:38:33 <ski> brando : could you provide more context about what you're wanting to do, what you're trying, what you expected, and what you got instead ?
12:43:20 <brando> ski: I wasn't trying to do anything, I was wondering why the syntax (a,b) only matches a list with 1 element and the rest of the lest and not some abrarity division of the list
12:44:08 <ski> brando : it doesn't match a list at all, so you must be misunderstanding something
12:44:28 <ski> brando : what is the actual code you tested, what is the actual result of testing it ?
12:45:10 <geekosaur> brando, (x,y) is not [x,y] nor is it (x:y), they all man different things\
12:45:13 <geekosaur> mean
12:45:14 <marvin2> brando, did you mean to say (a:b)?
12:45:43 <geekosaur> a list is fundaentally a chain of cells constructed with (:); [1,2,3] is shorthand for 1:2:3:[]
12:45:56 <geekosaur> and : is indeed head:rest
12:45:58 * ski is suspecting brando has used something like `(x,y):zs' or `[(x,y)]', but isn't sure
12:46:10 <geekosaur> :t (:)
12:46:11 <lambdabot> a -> [a] -> [a]
12:46:34 <mnoonan> and 1:2:3:[] means 1:(2:(3:[]))
12:46:44 * ski waits for brando to respond
12:47:30 <zachk> what would I need Data.These for?
12:48:44 <hyperisco> I had this very confusion and the resolution is to fix the misunderstanding in how cons works.
12:48:54 <ski> zachk : when you have one or the other, or possibly both, i suppose
12:49:27 <hyperisco> zachk, when you want to zip lists of different lengths without truncating elements, amoung other things.
12:49:45 <brando> ski: I was reading this sentence: "The second clause says that if the input list looks like (x:xs)"
12:49:59 <ski> yes ?
12:50:03 <brando> oops I menat (a:b)
12:50:27 <brando> like the sytnax (a:b) mathces a=1 and b=[2,3,4]
12:50:40 <brando> but not a = [1,2] and b=[3,4]
12:50:50 <ski> because the list `[1,2,3,4]' really is an abbreviation for `1:[2,3,4]'
12:50:52 <brando> I guess the syntax (a:b) extract things from the front
12:51:03 <brando> ah! i see
12:51:04 <brando> thanks
12:51:27 <hyperisco> actually that is not an abbreviation per se :P
12:51:51 <ski> (and that is in turn an abbreviation for `1:(2:[3,4])', which is an abbreviation for `1:(2:(3:[4]))', which is an abbreviation for `1:(2:(3:(4:[])))'. by convention, if we write `1:2:3:4:[]', it will mean the same thing (with brackets "associated" to the right))
12:52:05 <Solonarv_> the word you're looking for is "syntax sugar", or just sugar
12:52:18 <ski> that's an alternative term, yes :)
12:52:47 <brando> Ive never understood what syntax sugar meant
12:52:52 <ski> every list is either (a) the empty list `[]', or (b) a non-empty list `x:xs', where `x' is the first (head) element, and `xs' is the *list* (the tail/rest) of remaining elements (possibly the empty list)
12:53:04 <brando> so it just means abreviations = sugar?
12:53:10 <benzrf> more or less
12:53:37 <ski> it means an abbreviation which makes it look prettier to humans, but which doesn't add any extra expressive power to the language
12:53:37 <benzrf> syntactic sugar refers to syntactic features whose functionality is already essentially present in the language but in a more verbose form
12:53:39 <hyperisco> I think abbreviations should be shorter than what they are abbreviating, but maybe that's taste.
12:53:59 <benzrf> well, maybe not "more verbose"
12:54:02 <ski> (yea, in some cases, they may not be shorter, but still clearer in some sense)
12:54:02 <geekosaur> well, in this case it means more readily understood by people
12:54:06 <benzrf> but "less nice to write & look at"
12:55:00 <brando> ok, so sugaring is the act of changing syntax to human likable form
12:55:02 <brando> essentially
12:55:11 <ski> (there's also "syntactic salt", when you add some extra noise, to make the programmer think twice before using a particular feature in the language. that also helps the reader of the code realize that something strange is probably going on)
12:55:14 <hyperisco> the best description yet, I'd say
12:55:22 <zachk> brando, you can easily write your own List a type using a data declaration with two constructors a Cons and a Nil 
12:56:07 * ski idly wonders whether brando has seen how to define new data types, yet
12:56:29 <brando> I have not
12:56:42 <ski> then don't worry, it will come in time
12:56:44 <brando> I was just curious about how pattern matching actually worked
12:56:55 <brando> :)
12:56:58 <brando> I wont worry
12:56:59 <oo_miguel> I've been told a few days ago, that reading a file striclty with ByteString.readFile will consume the double amount of bytes of RAM. Why does it happen? And can I do anything about it?
12:57:05 <hyperisco> That is interwoven with how data types are defined, brando.
12:57:16 <brando> what is?
12:57:22 <hyperisco> Pattern matching.
12:57:22 <c_wraith> ski, is that what haskell does to mutable arrays?
12:57:24 <brando> pattern matching
12:57:26 <brando> ?
12:57:26 <ski> brando : "how pattern matching actually worked"
12:57:30 <dolio> Double relative to what?
12:57:54 <oo_miguel> to the filesize
12:57:54 <brando> Im dont think I understand haskell enough to know what ur reffering to
12:58:15 <c_wraith> oo_miguel, "up to double" maybe?
12:58:35 <c_wraith> oo_miguel, that would be consistent with reading into an exponentially resized buffer.
12:58:52 <hyperisco> c_wraith, is that a veiled jab at Haskell's mutable array APIs?
12:58:55 <ski> c_wraith : hm. i suppose it's a matter of perspective there. Haskell certainly doesn't treat them differently from other data structures, apart from needing to be in a monad to capture the effects. but that's not specific to mutable arrays in particular
12:58:58 <oo_miguel> It seems almost exactly double now.. readding a 5g file, results in the profiler reporting 5g pinned memory BUT my os tells me that haskell is eating 10g
12:59:16 <c_wraith> oo_miguel, oh, ignore what your OS tells you.
12:59:42 <oo_miguel> heh, it begins paging out as soon as it tells me that haskell eats 32g :P
12:59:59 <oo_miguel> which I can not ignore ;)
13:00:10 <ski> c_wraith : otoh, in Mercury, one can declare predicates and functions to be impure (distinct from normal I/O, which is done by passing around a state of the world, uniquely). impurity is mainly intended for FFI, and for low-level implementations of e.g. constraint solvers, which are then to be wrapped in a declarative interface
13:00:42 <c_wraith> oo_miguel, 64 bit ghc on Linux grabs 1TB from the OS on program startup. it's meaningless noise. (except to the Linux subsystem on windows, which fails at doing that)
13:01:02 <oo_miguel> c_wraith: Ive ssen that, but I am talking about the RESIDENT mem
13:01:03 <ski> c_wraith : anyway, all calls to an impure predicate or function have to be preceded by the keyword ("salt") `impure'. and of course it's contagious (until you promise at some point that the side-effects doesn't leak beyond that point)
13:02:11 <ski> c_wraith : still, if you think of what might be considered "syntactic sugar", or at least specialized support for mutable arrays in some other languages, Haskell's treatment of them as "just another library", may perhaps feel like syntactic salt, in comparision
13:02:21 <c_wraith> oo_miguel, it's still probably the result of an exponentially growing backing buffer.
13:02:28 <ski> (specialized support in allowing arrays in lvalues, say)
13:03:03 <zachk> why does ghc try to grab 1 tb of memory on startup?
13:03:17 <ski> (if you allow the user to declare their own lvalue abstractions for library mutable structures, all the more power to you)
13:03:27 <geekosaur> zachk, its' reservingt he address spce, tot he memory
13:03:30 <geekosaur> not the memory
13:03:36 <zachk> oh
13:04:16 <c_wraith> oo_miguel, for what it's worth, exponentially growing the backing buffer is a performance optimization to avoid O(n^2) copying when you don't know the input size.
13:04:20 <monochrom> Yeah, only "resident memory" is reliable.
13:04:32 <ski> c_wraith : ok ?
13:04:33 <geekosaur> it's allocatuig page table entries without populating them, then managing them itself. which confuses naïve versions of top. you can look for "2-stage allocator" for details
13:05:07 <oo_miguel> c_wraith: ok. this is possible, thanks. And I am fine with it :)
13:05:40 <oo_miguel> somebody was telling me the other day that some strucutres (I think when exchanged with underlying c/c++ libs) eat double memory, but I do not remember exactly
13:05:47 <hyperisco> time to go back to real mode
13:07:12 <c_wraith> oo_miguel, yeah, that's definitely not the case. the backing structure is an array of bytes with a small bit of bookkeeping overhead. that overhead can matter on very small ByteString values, but it's irrelevant on huge ones.
13:09:31 <c_wraith> oo_miguel, oh! when used with the FFI, a ByteString does have to be copied to be used safely. maybe that's what was meant. 
13:09:54 <c_wraith> oo_miguel, if you don't copy it, you run the risk of the native code mutating it, breaking purity.
13:13:59 <hyperisco> I wonder if there is some complicated copy-on-write memory scheme
13:15:02 <c_wraith> I don't think that can work unless the native code cooperates
13:15:27 <geekosaur> it can work if you have access at kernel page tabel level. userspace is harder
13:15:41 <hyperisco> yeah which is why I was thinking of hardware support, or maybe that can be resolved by the OS, not sure
13:15:42 <geekosaur> also evry string has to go in its own page(s)
13:15:53 <c_wraith> yeah, a kernel can do it. not sure if ghc can. :)
13:20:16 <c_wraith> so how does that work again? you mark the page not-writable, catch the fault if it is written to, copy the contents, and remap the page table entry to point to the new copy which is writable?
13:20:49 <hyperisco> That may be more curse than not because the time for copying isn't spent at a predictable time.
13:21:37 <hyperisco> If we're working with protected paged memory I suppose so c_wraith. Sounds plausible.
13:23:17 <geekosaur> you'd have to repoint anyting pointing at it as well, so it's gc-like
13:23:46 <geekosaur> andthe most important thing pointing at it is the code that triggered the write falt
13:24:00 <c_wraith> iirc, the Linux kernal does something like this for process memory on calls to fork.
13:24:02 <hyperisco> Why would you have to do that?
13:24:13 <c_wraith> *kernel
13:24:34 <hyperisco> The copy page would point to the same physical memory as the source page, until a write occurs. As far as virtual addresses go nothing changes.
13:25:44 <geekosaur> mm, yes, could be done that way. at the expense of lots of pages, and there's a limit
13:26:20 <hyperisco> For GB files I think page resolution is alright.
13:27:28 <geekosaur> btu you nowhave to distiguish between bytestrings managed that way and normal ones
13:28:00 <hyperisco> Yeah which is why I suspect it might be a curse because timing becomes unpredictable.
13:28:14 <hyperisco> But hey that's just laziness for you :)
13:29:26 <hyperisco> You could force it to be strict though just by rewriting a byte somewhere.
13:30:10 <merijn> geekosaur: That's why we have 64bit virtual memory! Plenty of pages to go around!
13:30:33 <geekosaur> merijn, the OS imposes per-process limits beyond the hardware
13:52:45 <sm> hey brew deps --tree --installed is nice.. we should have it for cabal/stack
13:53:40 <sm> https://hastebin.com/adiniyeyek.pl
13:53:53 <marxS> are there any good projects which are a good example of a haskell project but which isnt too complex/large for a beginner to understand?
13:54:10 <merijn> sm: We do!
13:54:15 <sm> hurrah!
13:54:16 <merijn> @hackage cabal-plan
13:54:16 <lambdabot> http://hackage.haskell.org/package/cabal-plan
13:54:22 <merijn> sm: Only works with new-build, though
13:54:48 --- mode: glguy set +v gentauro
13:54:59 <marxS> i want to see some examples of how functors, monads, applicatives, etc are used in projects
13:55:18 <gentauro> marxS: that should give you a good understanding on how to at least use those 3 concepts ;)
13:55:22 <sm> not quite the same then.. any sample output ?
13:55:29 <gentauro> functors = <$>
13:55:32 <gentauro> monaps = >>=
13:55:34 <marxS> gentauro, what should?
13:55:38 <gentauro> applicatives = <*>
13:55:42 <gentauro> marxS: https://gitlab.com/spisemisu/cleanse-facebook
13:55:45 <gentauro> that project
13:55:48 <marxS> ok thanks, will check it out
13:55:53 <gentauro> w8, I will log in to IRC
13:56:14 --- mode: glguy set -v gentauro
13:56:41 <gentauro> marxS: I think my first message wasn't shown here cos I hadn't loggedin
13:57:00 <glguy> gentauro: You could have repeated it as soon as you were marked +v
13:58:30 <gentauro> glguy: I forgot ;)
13:59:30 <merijn> sm: I don't have it installed on this machine, but the executable shipping with the library has a whole bunch of stuff for querying new-build info, including a plot like that for dependencies, iirc
14:00:32 <sm> nice. Would be great to have in stock cabal 
14:02:01 <merijn> sm: You should ask hvr why it's not in cabal-install yet. It makes sense to have a separate lightweight tool without the cabal dependency, but I'm not sure why cabal couldn't depend on it and integrate it...
14:03:16 <marxS> I'm reading some source code and it has this:
14:03:28 <marxS> inprod :: Num a  =>  [a] -> [a] -> a 
14:03:30 <marxS> inprod  = sum `o` zipWith (*)
14:03:35 <marxS> but how is that valid, what even is `o` ?
14:04:27 <glguy> You can turn any variable identifier into an operator by surrounding it with bacticks `
14:04:49 <glguy> identifiers in general, actually. Constructors, too.
14:04:58 <oo_miguel> c_wraith: sorry, I've been afk for a while...  So the ByteString _is_ using this FFI and doubling everything? (Or is this something I can decide on?)
14:05:19 <marxS> oh glguy I see, thanks
14:06:07 <glguy> > let plus = (+) in 10 ` plus ` 20
14:06:09 <lambdabot>  30
14:06:49 <ski> marxS : looks like `o = (.) . (.)' (aka `(.:)')
14:07:20 <merijn> glguy: Non-operator identifiers!
14:07:28 <glguy> ?
14:07:42 <ski> > 2 `+` 3
14:07:44 <lambdabot>  <hint>:1:4: error: parse error on input ‘+’
14:07:51 <merijn> glguy: Operators are identifiers too, but you can't turn them infix with `, on account of already being operators
14:07:53 <glguy> + is a symbol, not an identifier
14:07:58 <merijn> glguy: I disagree
14:08:13 <merijn> It's an identifier that happens to be made up of operator characters
14:08:21 <glguy> It's right there in the lexical specification
14:09:15 <glguy> An identifier consists of a letter followed by zero or more letters, digits, underscores, and single quotes. Operator symbols are formed from one or more symbol characters, as defined above, and are lexically distin- guished into two namespaces
14:10:14 <glguy> operator positions can be identifiers surrounded by ``s or symbols
14:10:28 <glguy> and then we've got the additionally separate notions of variable and constructor
14:18:19 <zachk> @src fix
14:18:19 <lambdabot> fix f = let x = f x in x
14:20:11 <c_wraith> if it helps in some way, you could pretend the implementation is fix f = f (fix f)
14:20:35 <c_wraith> they have the same denotational semantics.
14:20:44 <merijn> If it helps in some way, feeling your brains leaking out of your ears is a completely normal part of understanding fix
14:20:49 <c_wraith> the library version has better sharing properties
14:20:52 <c_wraith> also, yes.
14:21:04 <c_wraith> if it helps, you don't have to understand fix.
14:21:16 <c_wraith> it's not a necessity for anything
14:22:19 <merijn> Well, it's a necessity for some things. Just most of those things are not "practical programming"
14:24:13 <Dark_Ethereal> Just spent a while wondering why  `(Applicative f, Monoid a) => Monoid (Ap f a)` had `Ap` in it... Then I remembered that there's a bunch of Applicative instances that are themselves Monoid instances and you'd need a way to block their Monoid behavior in favour of their Applicative behavior.
14:24:13 <Dark_Ethereal> Clever!
14:24:32 <merijn> Dark_Ethereal: Correct
14:24:44 <mniip> > fix $ (0:) . scanl (+) 1
14:24:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:24:48 <c_wraith> there are a ton on newtypes for that exact reason
14:25:01 <c_wraith> Data.Monoid is full of them.
14:25:07 <merijn> Dark_Ethereal: The problem is that there's at least 2 monoids for each Applicative with a Monoid element. Possibly even more...
14:26:24 <merijn> Also, you'd be really annoyed if lists Monoid instances was cartesian product of the internal Monoid...
14:26:26 <ski> Dark_Ethereal : also, we don't want overlapping instances
14:28:44 <_kwstas> hello everyone! I I'm working on a haskell project and use nix. I have already configured project.nix and default.nix. I want to configure shell.nix  as well, but I want shell.nix to have some extra dependencies (e.g. hlint), but I do not know how :(. I tried to do something like: devEnv = (import ./project.nix).project.overrideAttrs (oldAttrs: rec {
14:28:46 <_kwstas>     libraryHaskellDepends = oldAttrs.libraryHaskellDepends ++ [ pkgs.haskellPackages.hlint ] ;
14:28:48 <_kwstas>   }); but it seems that this does not work
14:28:49 <c_wraith> oo_miguel, it's an issue when you are passing a ByteString to something using the FFI (foreign function interface - the way ghc talks to native code)
14:29:08 <_kwstas> any help?
14:29:22 <mniip> hmm
14:29:24 <mniip> neat!
14:29:31 <mniip> :t fix ((const id :) . scanl (liftA2 (.)) id)
14:29:33 <lambdabot> [(a -> a) -> a -> a]
14:29:41 <mniip> > ($ 0) <$> ($ succ) <$> fix ((const id :) . scanl (liftA2 (.)) id)
14:29:47 <lambdabot>  mueval-core: Time limit exceeded
14:29:55 <mniip> > take 10 $ ($ 0) <$> ($ succ) <$> fix ((const id :) . scanl (liftA2 (.)) id)
14:29:57 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
14:30:00 <heptahedron> Anyone well-versed in the `bound` library? I feel like I'm on the cusp of really grasping it but I don't quite understand the description given for the `fromScope` and `toScope` functions.
14:30:18 <c_wraith> oo_miguel, but if don't pass the ByteString to some native code, that doesn't become an issue.
14:34:05 <foojin> Isn't fix just a pointfree way of tying knots?
14:34:21 <glguy> yeah
14:34:41 <oo_miguel> c_wraith: oh allright. so before I pass something via ffi, a copy is created beacuse we do not TRUST the native code will not mess with the data? 
14:34:53 <merijn> foojin: It's also the classical "recursion primitive". i.e. every recursion can be written as fix
14:35:02 <oo_miguel> (in my scenario I just use the bytesring in haskell, afaik)
14:35:22 <merijn> foojin: TaPL discusses only supporting "fix" in your typechecker for simplicity, then treating every recursive binding as syntactic sugar for fix, for example
14:36:32 <mniip> merijn, err
14:36:41 <mniip> polymorphic recursion
14:37:11 <merijn> mniip: Does that happen without typeclasses?
14:37:31 <mniip> sure why not
14:37:39 <mniip> you can always pass dictionaries by hand
14:38:24 <merijn> I forget the details of the point in TaPL, so I honestly can't say what assumption makes that untrue
14:38:53 <mniip> the respective chapter of TaPL probably didn't support polymorphic recursion
14:39:39 <glguy> heptahedron: Those two are the functions for the isomorphism between using: Monad f => f (Var b a)   and   Scope b f a
14:40:06 <glguy> heptahedron: the point of the bound library is that many operations are more efficient using the "Scope" representation than without
14:40:17 <glguy> so you use that as much as you can only unwrapping it when you have to
14:40:52 <glguy> You represent your expressions as a type parameterized by its variables
14:41:04 <glguy> introducing a new scope adds a new layer to that type of variables
14:42:39 <rain2> hi
14:42:50 <rain2> is anybody somewhat familiar with the algebraic effects alternative to monad transformers
14:43:01 <rain2> i was wondering if they can do dynamic scoped variables?
14:43:10 <rain2> would that just be the state monad?
14:43:53 <heptahedron> glguy: I read the slides on it, as well as this https://www.schoolofhaskell.com/user/edwardk/bound , but I'm having difficulty visualizing what he means by "fromScope quotients out the possible placements of F in Scope by distributing them all to the leaves"
14:45:16 <heptahedron> rain2: I think you might be able to get away with just the reader monad and `local` for that
14:45:26 <rain2> ah i see, thank you
14:45:55 <heptahedron> rain2: What are you working on?
14:45:59 <glguy> heptahedron: The Scope representation delays updating all of the variables of the expressions being lifted into the new scope
14:46:28 <heptahedron> glguy: oh so this is reliant upon haskell's laziness?
14:46:32 <glguy> newtype Scope b f a = Scope { unscope :: f (Var b (f a)) }
14:47:25 <glguy> The operation just isn't performed until you perform it with fromScope
14:47:55 <c_wraith> oo_miguel, that's correct. note that you can use the unsafe .Internal modules in the bytestring library to skip that copy if you do trust the native code - but if it goes wrong, it can really mess things up badly.
14:47:58 <glguy> in the Scope representation, instead of your expression actually being parameterized over variables, it's parameterized over either local variables or lifted subexpressions
14:48:36 <glguy> when you run the Scope layer and get f (Var b a), that flattens everything back out to being parameterized over just variables, not lifted subexpressions
14:48:38 --- mode: glguy set +v Bors_
14:49:16 <oo_miguel> c_wraith: ok thank you very much. I Will keep this in mind. For now I do not pass anything by myself anyway.
14:50:31 <heptahedron> glguy: Okay this is helping, I feel like I'm getting a bit closer. So earlier when you said "delay", that wasn't reliant upon the evaluation semantics, you just mean that it's being wrapped in a constructor that will eventually have to be sort of propagated through the tree?
14:51:03 <heptahedron> I'm trying to write the basic functions myself right now so I can get a better feel for what's happening
14:52:02 <glguy> Right, it's not about being lazy, it's just that we do operations on this alternative representation for a while and then eventually convert it back to the one we wanted in the end
14:52:18 <ph88> what's a term 4## with two hashes ?
14:52:25 <glguy> so like using a Data.Sequence.Seq internally for a bit before going back to List []
14:52:40 <glguy> >>> :t 4##
14:52:40 <glguy> 4## :: GHC.Prim.Word#
14:52:56 <concaveirc> Which is a faster reverse string, given the base cases are implemented properly: rev1 (x:xs) = rev1 xs ++ [x] or rev2 xs = (last xs) ++ rev2 xs?
14:53:13 <ph88> ok just checking .. didn't expect this
14:53:44 <ph88> is there also notation for 32, 64, 128 unboxed ?
14:53:46 <ph88> bits
14:53:49 <jle`> concaveirc: is rev2 correct?
14:53:49 <heptahedron> So it doesn't really /avoid/ traversing the entire tree, then, it just defers it?
14:54:15 <concaveirc> jle: Oops, rev2 xs = (last xs) ++ rev2 (init xs)
14:54:38 <concaveirc> Oops again, rev2 xs = (last xs): rev2 (init xs)
14:55:19 <glguy> heptahedron: I think it helps you to avoid traversing the entire tree as often as you would have had to
14:55:26 <jle`> concaveirc: hm, it's not obvious at first glance i think, but do you know the general way to investigate and check?
14:55:58 <glguy> I wouldn't expect last and init to get merged into one traversal of the list, so I would expect that version to be slower
14:55:58 <jle`> try a sample input, and figure out how many evaluation steps you need to do do until you can get the first item in the list, then the second item...
14:56:06 <concaveirc> jle1`: No, but I would be pushed to do a large output.`
14:56:43 <concaveirc> By evaluation steps, do you mean assembly steps?
14:56:47 <jle`> so let's look at something like rev (1:2:3:4:5:[])
14:56:55 <jle`> concaveirc: do you know how evaluation/reduction works in haskell?
14:57:02 <jle`> it starts from the out-side in
14:57:16 <jle`> first look at the outermost function application, and figure out which case branch you go down
14:57:28 <jle`> then replace the expression with the right hand of the =
14:58:16 <concaveirc> I see. so I'd start from rev1 (rev1 [2,3,4,5]) 1 and go deeper?
14:58:19 <ph88> instead of  {-# LANGUAGE KindSignatures #-}  data Connection (s :: ConnectionStatus) = MkConnection ...    why not just   data Connection = MkConnection ConnectionStatus    ?
14:58:32 <jle`> concaveirc: that's not quite the evaluation step but yeah
14:58:45 <jle`> for rev1 (1:(2:(3:[])), for instance, we see that it matches the cons step
14:59:00 <jle`> so that's rev1 (2:(3:[])) ++ [1]
14:59:04 <jle`> *cons pattern
14:59:22 <jle`> now we need to check the definition of (++) to figure out where to go from here
14:59:23 <concaveirc> Makes sense.
14:59:24 <mniip> ph88, the two are very different types?
14:59:34 <jle`> [] ++ ys = ys
14:59:39 <jle`> (x:xs) ++ ys = x : (xs ++ ys)
14:59:50 <jle`> concaveirc: you can count the number of steps you take until you reach the final result, just a list
14:59:57 <ph88> yes but why keep polymorphism in type when putting such a constraint .. i don't see the benefit of KindSignatures
15:00:16 <concaveirc> So I keep counting the amount of :'s which appear in the expansion?
15:00:23 <jle`> concaveirc: no, count the number of steps you take
15:00:27 <jle`> the number of times you have to expand something
15:00:39 <jle`> ph88: are we talking about kind signatures, or datakinds/phantom types?
15:00:43 <concaveirc> Okay. Thanks jle``
15:00:45 <mniip> ph88, without KindSignatures it would've inferred Connection :: k -> *
15:00:50 <mniip> or worse * -> *
15:01:03 <mniip> you want Connection :: ConnectionStatus -> *
15:01:05 <jle`> in the second case data Connection = MkConnection ConnectionStatus, Connection :: Type
15:01:48 <jle`> ph88: oh ah, you are asking why to constrain something to Connection, instead of just letting it be polykinded?
15:01:55 <ski>   rev1 (0:1:2:3:[])  =  rev (1:2:3:[]) ++ [0]  =  (rev (2:3:[]) ++ [1]) ++ [0]  =  ((rev (3:[]) ++ [2]) ++ [1]) ++ [0]  =  ...
15:01:58 <ski> concaveirc ^
15:02:34 <jle`> ph88: as in, why have Connection :: ConnectionStatus -> Type, instead of Connection :: k -> Type
15:02:48 <ph88> well i've been reading into it .. and it's not the same .. but to me it seems the same. So not sure why to prefer one situation of the other
15:02:57 <jle`> which situations are we comparing to
15:03:02 <jle`> since we've mentioned three different situations here
15:03:34 <jle`> there's data Connection s = ..., data Connection (s :: ConnectionStatus) = ..., and data Connection = ...
15:03:57 <ph88> well i thought that in     data Connection (s :: ConnectionStatus) = MkConnection ...       s can only be ConnectionStatus .. so why not just put ConnectionStatus there directly without "s"
15:04:10 <jle`> what would that look like?
15:04:26 <jle`> data Connection = ... ?
15:04:32 <ph88> i think so yes
15:04:41 <ph88> since there is no more variable then
15:04:43 <jle`> ah. well in that case, it's no longer in the type, but at the value level
15:05:03 <jle`> so you can't write a function that, say, takes only an 'Opened connection
15:05:07 <ph88> ah ok thx
15:05:18 <jle`> i actually explore this pretty deeply in my singletons tutorial :) with a similar example
15:05:26 <ph88> link plz
15:05:30 <jle`> https://blog.jle.im/entry/introduction-to-singletons-1.html
15:05:46 <ph88> i've read somewhere some people where not too happy about singletons
15:05:47 <heptahedron> jle`: I saw your post on reddit about the recent update to that series! Very nice
15:05:54 <jle`> the type i talk about is basically the same thing as your type
15:06:05 <jle`> heptahedron: thanks! :)  appreciate it, happy to be able to finish it finally too haha
15:06:21 <jle`> ph88: yeah, nobody is really 'happy' with singletons; we use it in the hope that it is one day going to be obsolete
15:06:27 <jle`> ph88: but it's the best we have for now :)
15:06:28 <heptahedron> ph88: They tend to be very messy but they're a clever workaround for the lack of dependent types
15:06:53 <ph88> messy as in difficult to understand, or more boilerplate ?
15:06:58 <heptahedron> bless that poor soul working on the depdendent type support
15:07:06 <mniip> jle`, when is Introduction to singletons (Part ω) coming out
15:07:12 * ph88 blesses poor soul
15:07:36 <jle`> ph88: it's basically built on a tower of clever hacks.  boilerplate is abstracted away using TH
15:07:39 <heptahedron> ph88: Template Haskell and an ABUNDANCE of definitions made by defunctionalization, not to mention hard-to-read error messages if you don't know what you're doing
15:07:49 <jle`> mniip: in Year ω
15:08:18 <jle`> but for simple usage you don't need to worry about defunctionalization
15:08:28 <jle`> the only time defunctionalization is important is when you want to write higher-order functions at the type level
15:08:45 <ph88> is Symbol just for tagging types ?
15:08:55 <jle`> admittedly once you get started writing type-level functions, the desire to write and use higher-order functions becomes...intoxicating 
15:09:08 <heptahedron> ph88: It's for representing non-fully-saturated applications of type families/synonyms, which GHC doesn't allow
15:09:16 <mniip> because that's what you've been doing at value level for years
15:09:22 <jle`> ph88: yeah, it's only usable as a phantom type. if you're talking about Symbol from GHC.TypeLits
15:09:38 <jle`> symbol from GHC.TypeLits is pretty simple, we've had it in ghc for a looong time
15:09:49 <heptahedron> ph88: For instance, you can't really use functions like `map` at the type-level, at least not in the intuitive way you'd expect
15:10:04 <heptahedron> Oh whoops I'm thinking of sym or whatever aren't I
15:10:25 <jle`> defunctionalization symbols maybe :)
15:10:30 --- mode: glguy set +v tcsiwula
15:10:32 <heptahedron> that's it, yeah
15:10:47 <jle`> but that's different from the Symbol kind from GHC.TypeLits, that libraries like servant take advantage of to great effect
15:11:13 <tcsiwula> need some help installing a dep: `Could not find module ‘Network.TLS’ Perhaps you meant Network.Wai`
15:11:22 <heptahedron> love me some type-level strings
15:12:35 <rawburtz> looks like Network.TLS is from https://hackage.haskell.org/package/tls-0.9.2/docs/Network-TLS.html so maybe... cabal install tls ?
15:12:43 <rawburtz> tcsiwula ^
15:13:49 <ph88> does singleton library make programs slower ?
15:14:00 <tcsiwula> rawburtz: thank you. will try now. detailed output: https://gist.github.com/tcsiwula/f28048b251d03588f252ac8d2e48f01d
15:14:18 <jle`> ph88: compared to what?
15:14:33 <ph88> compared to not have fake-dependent types in haskell program
15:14:40 <jle`> well..they're different programs
15:14:43 <jle`> so it'd be hard to compare heh
15:15:07 <tcsiwula> rawburtz: no go --> https://gist.github.com/tcsiwula/f28048b251d03588f252ac8d2e48f01d#gistcomment-2740740
15:15:07 <ph88> different on runtime ?
15:15:10 <jle`> that's like asking if containers makes your programs slower
15:15:13 <jle`> ph88: you'd be writing different programs
15:15:34 <heptahedron> glguy: So given `Scope f a = MkScope { f (Var b (f a)) }`, the outer f is the portion of the expression that has been abstracted that doesn't have any variables, and the inner f contains all the free variables?
15:15:39 <ph88> it's not possible to write the same runtime program when adding singletons ?
15:16:34 <heptahedron> Oh wait, the outer f contains the variables that were bound directly in that scope and the lifted expressions that contain only free variables?
15:16:34 <ph88> for some hello world with and without singleton example or something like that
15:16:45 <rawburtz> tcsiwula : given you're using stack, perhaps you need to add the tls dependency to the "build-depends:" section in your projects .cabal file, or something 
15:17:18 <jle`> ph88: there isn't really any runtime overhead ideally, but also it's still kind of weird to compare without talking about specific things
15:17:29 <ph88> got it
15:17:32 <ph88> thx
15:17:34 <jle`> but yeah i don't ever really consider any run time overheahd when using singletons
15:17:56 <heptahedron> Depending on how one uses it, I would guess it might inhibit some inlining in places, what with the rampant polymorphism, but I don't want to underestimate GHC
15:18:19 <heptahedron> ^ re: singleton performance
15:18:47 <jle`> if we're comparing 'dependent type' things vs no dependent types, the runtime overhead isn't too signifcant
15:19:06 <rawburtz> tcsiwula : depending how you have stack setup, this might help https://docs.haskellstack.org/en/stable/GUIDE/#adding-dependencies
15:19:20 <jle`> it's not something i consider, meaningfully
15:20:40 <heptahedron> Oh yeah I mean if you're using dependent types you're most likely in a situation where you're allowed to have a little fun despite the minor costs it would incur, but I think it's good to be mindful that they aren't by any means magic 
15:21:01 <heptahedron> I mean the length-indexed vectors gotta keep the length data somewhere
15:21:20 <jle`> length-indexed vectors alone don't have any runtime cost because of type erasure
15:21:28 <jle`> but manipulating those lengths at runtime have runtime costs
15:22:01 <monochrom> Fortunately that cost is just the same as runtime bound checking.
15:22:25 <jle`> yeah, that's my point ;)  i don't consider that to be a meaningful cost
15:22:44 <jle`> if you embrace dependently typed proofs then there will be some runtime costs incurred because of lack of proof erasure in ghc.  but there are hacks to get around this
15:22:45 <oo_miguel> when I call a function twice with identical paramaters, does haskell cache the results of the first call?
15:22:48 <tcsiwula> rawburtz: yeah that got rid of the import errors, thank you. I have another one for importing Network.Socket. Should I add (socket) in .cabal build deps again for it?
15:22:51 <jle`> oo_miguel: no, it doesn't
15:22:57 <jle`> oo_miguel: that's a good way to lead to cache explosion
15:23:08 <jle`> > sum $ map (+1) [1..10000000000]
15:23:15 <lambdabot>  mueval-core: Time limit exceeded
15:23:19 <jle`> > sum $ map (+1) [1..1000000]
15:23:22 <jle`> um you get the point heh
15:23:22 <lambdabot>  500001500000
15:23:47 <jle`> for some reason though, cached functions seems to be something everyone who is starting to learn haskell seems to expect
15:23:57 <jle`> but from a practical standpoint it doesn't make any sense
15:24:02 <heptahedron> oo_miguel: If you're looking to memoize, you can lean on haskell's laziness and map your function over a data structure that contains all the inputs to it, and the memoized version of your function just indexes this data structure
15:24:42 <rawburtz> tcsiwula : you should lookup the name of the package. searching for "haskell Network.Socket" on google show the "network" library is what you want https://hackage.haskell.org/package/network-2.8.0.0/docs/Network-Socket.html
15:25:12 <oo_miguel> heptahedron: nice suggestion than you. 
15:25:24 <tcsiwula> rawburtz: ahh thank you. was kinda confused how the import names mapped to the package names :)
15:25:47 <oo_miguel> jle`: ... and I was not really 'expecting' it... maybe more suspecting ;)
15:25:57 <rawburtz> tcsiwula: no worries :D
15:26:25 <ski> oo_miguel : in fact, that's one way to do lazy, top-down, dynamic programming : with an immutable datastructure (e.g. an array), recursively defined, elements lazily constructed
15:27:16 <tcsiwula> rawburtz: https://gph.is/1FNu5t7 
15:30:00 <ph88> jle`, this piece   One “hello world” use case of phantom type parameters is  ..   you would have already lost me if i just hadn't read another blog post
15:30:44 <ph88> jle`, >>  only basic to intermediate Haskell knowledge (Types, kinds, typeclasses, data types, functions).   but this uses DataKinds already, no ?
15:34:06 <ph88> ah i see this sentence came early in the text, you explain afterwards
15:39:40 <ph88> why haven't i read this blog post before :D
16:15:51 <sm> how do you create the ~/.cabal/store/* stuff so cabal new-* commands don't give an error ?
16:16:14 <hexagoxel> what's the error?
16:16:32 <sm> https://hastebin.com/mijexuyofo.sql
16:16:44 <glguy> Try: cabal new-build fail
16:16:57 <glguy> I think you have to new-build anything before you first new-install something...
16:17:09 <sm> and I have to be in a project dir to do that ?
16:17:20 <sm> seems so
16:18:39 <sm> and the package has to be one mentioned in the cabal file
16:19:30 <sm> hmm. cabal new-build array -> "Up to date", but still no ~/.cabal/store/
16:19:30 <glguy> The way I fixed it was building fail outside of a project directory
16:19:51 <glguy> https://github.com/haskell/cabal/issues/5516
16:20:04 <glguy> Oh, hvr said: cabal new-repl -w ghc-8.6.1 --build-dep fail
16:20:31 <glguy> I think the -w is only needed if you're using a ghc executable other than your default PATH one
16:22:25 <sm> thanks.. I have cabal-install 2.4.0.0 which says "'repl' doesn't take any extra arguments when outside a project"
16:23:14 <sm> oh well
16:23:21 <glguy> that means you might have missed aflag
16:23:38 <sm> ack, you're right
16:24:49 <sm> thanks! new-* working. Now I can race it against stack
16:26:08 <sm> pardon me if this is a RTFM, but cabal wants symlink-bindir configured - what is this ?
16:27:00 <glguy> That's a setting in your ~/.cabal/config that tells cabal where to put symlinks to executables you new-install
16:27:24 <glguy> You might try: "cabal user-config diff" to see how your .cabal/config is different than the default
16:27:42 <sm> nice, thank you
16:27:52 <glguy> There's also "cabal user-config update" which tries to update your config with defaults you don't have
16:29:11 --- mode: glguy set +v jackdk
16:29:19 <sm> cabal used to copy executables there.. so now it's just symlinks ? which work as long as you don't move or cabal clean the src dir ? or am I misunderstanding
16:29:47 <glguy> It symlinks things to ~/.cabal/store
16:30:05 <sm> ah, right. Thanks
16:32:25 <hexagoxel> does the property that is described via "positive"/"negative" for argument positions have a name? "sign" of arguments?
16:33:04 <hpc> hexagoxel: covariant or contravariant
16:33:23 <lyxia> hexagoxel: polarity
16:34:04 --- mode: ChanServ set +o glguy
16:34:48 <hexagoxel> yeah i think that variance is often connected, but is only a related property. negative does not imply covariant or the other way round.
16:34:58 <hexagoxel> polarity sounds promising.
16:39:52 <hexagoxel> none of the explanations of positive/negative argument positions mention polarity, but i'll take it. thanks :)
17:04:57 <zachk> and this code doesnt compile as well: newBind = do return (>>=) :(
17:05:42 <geekosaur> what did you thik that was supposed to do?
17:06:10 <geekosaur> :t return (>>=)
17:06:11 <lambdabot> (Monad m2, Monad m1) => m1 (m2 a -> (a -> m2 b) -> m2 b)
17:07:32 <geekosaur> it's not /per se/ meaningless but it suggests some significant misunderstanding of what's going on
17:09:28 <zachk> i thought it would compile 
17:10:14 <zachk> i basically want to return typeclass functions inside an IO monad, but it seems if there is more then one type parameter it's not allowed as with this example
17:12:25 <zachk> > let myBind = return (>>=) in  Just 'a' `myBind` (\k -> lookup k [('a',1)])
17:12:27 <lambdabot>  error:
17:12:27 <lambdabot>      • No instance for (Typeable b0)
17:12:27 <lambdabot>          arising from a use of ‘show_M400498986793738961530331’
17:12:52 <zachk> >  Just 'a' >>= (\k -> lookup k [('a',1)])
17:12:53 <lambdabot>  Just 1
17:13:11 <geekosaur> you don't want 'return' there
17:13:40 <zachk> i know that its a paired down example of something I am trying to get to work, and this is the simplest example I can find of it not working
17:14:14 <zachk> i am more interested in "why" it doesn't work, or what I could do to get it to work 
17:14:36 <geekosaur> it's in a monad, you need to fmap over the mnad to use it
17:14:38 <geekosaur> > let myBind = (>>=) in Just 'a' `myBind` (\d -> lookup k [('a',1)])
17:14:40 <lambdabot>  error:
17:14:40 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘Char’
17:14:40 <lambdabot>      • In the expression: 'a'
17:14:48 <geekosaur> right, forgot the typo fix
17:14:50 <zachk> oh yea 
17:14:51 <geekosaur> > let myBind = (>>=) in Just 'a' `myBind` (\d -> lookup d [('a',1)])
17:14:53 <lambdabot>  Just 1
17:15:10 <zachk> put yea stick it in a monad first
17:15:49 <zachk> > let myBind = return (>>=) in  do {bound <- myBind ; return $ Just 'a' `bound` (\k -> lookup k [('a',1)])}
17:15:51 <lambdabot>  error:
17:15:51 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M481961790449...
17:15:51 <lambdabot>        prevents the constraint ‘(Show
17:17:15 <geekosaur> it has no idea what mmonad now
17:17:42 <geekosaur> (ghci would default to IO; lambdabot doesn't do IO)
17:21:07 <zachk> > let myBind = return (>>=) in  (do {bound <- myBind ; return $ Just 'a' `bound` (\k -> lookup k [('a',1)])}) :: (Maybe Integer)
17:21:09 <lambdabot>  error:
17:21:09 <lambdabot>      • Couldn't match type ‘Maybe Integer’ with ‘Integer’
17:21:09 <lambdabot>        Expected type: Maybe Integer
17:21:32 <zachk> > let myBind = return (>>=) in  (do {bound <- myBind ; return $ Just 'a' `bound` (\k -> lookup k [('a',1)])}) :: (Maybe (Maybe Integer))
17:21:34 <lambdabot>  Just (Just 1)
17:21:51 <zachk> hmm works in lambdabot ...
17:43:41 <ph88> can i install package from hackage with stack that are not on stackage into my global project ?
17:46:04 <MarcelineVQ> yes, if you need to, in the same way you'd do it in a project
17:52:03 --- mode: glguy set +v Oliveira
17:52:12 --- mode: glguy set +v zoldyck
18:04:58 <slack1256> Is halvm still alive?
18:35:43 <blankhart> > fmap (+1) (1,1)
18:35:44 <lambdabot>  (1,2)
18:36:15 <blankhart> why does that instance exist?
18:37:50 <heptahedron> blankhart: I don't want to be that guy, but why not?
18:38:23 <heptahedron> I think the lens library makes an example of using its applicative instance to collect effects along a traversal while retrieving a specific value, too 
18:46:23 <blankhart> well, i will put it down to TIL.
18:47:40 <johnw> blankhart: if you think of '(,) e a' as a value paired with some kind of "additional stuff", perhaps the functor interpretation might make more sense
18:48:08 <johnw> it's simply that (a,b) is functorial in b
18:49:12 <ski> > [fmap (+ 1) e | e <- [Left 2,Right 7]]
18:49:15 <lambdabot>  [Left 2,Right 8]
18:59:41 <heptahedron> blankhart: are you aware of bifunctors? They're included in base now!
19:02:36 <drano> Where should I start learning Haskell if I know Scheme?
19:03:48 <ski> a textbook is probably a good thing
19:03:50 <heptahedron> I don't know what state the Haskell Book is in now, but it was a good resource before. Some people like learn you a haskell. Go nuts
19:04:07 <ski> asking questions, e.g. here, also lurking, can be helpful
19:05:31 <ski> there's a "gentle" tutorial, that some people don't that that gentle. iirc, it assumes some functional programming background
19:05:34 <ski> @where tutorial
19:05:34 <lambdabot> http://www.haskell.org/tutorial/
19:05:44 <ski> you could try it, and see what you think
19:06:23 <ski> i learned from "Haskell: The Craft of Functional Programming", by Simon Thompson. i thought it was nice
19:06:47 <ski> (i remember reading that tutorial pretty early as well, but not after the book, i think)
19:06:58 <ski> there are other books, e.g.
19:07:02 <ski> @where PIH
19:07:02 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
19:07:29 <joehh> hello, is there a prism for getting through resourceProperties in Stratosphere?
19:07:38 <drano> I've seen recommendations for LYAH, but I've also seen bad reviews. The Haskell Book isn't free. I've heard A Gentle Intro To Haskell isn't so gentle, but that might be exactly what I want since I already have some experience with (impure) FP. I'll check out those other books. Thanks.
19:07:44 <ski> @where SOE
19:07:44 <lambdabot> "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
19:07:57 <ski> @where HPFFP
19:07:58 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
19:08:05 <drano> I'd like to learn about FRP. Is the Hudak one about it?
19:08:07 <ski> @where HR
19:08:08 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
19:08:08 <joehh> ie for the big sum type: https://www.stackage.org/haddock/lts-12.10/stratosphere-0.24.4/Stratosphere-Resources.html#t:ResourceProperties
19:08:40 <ski> drano : i don't think so. you should probably ask conal about FRP (he's often here, though apparently not atm)
19:08:42 <heptahedron> I don't imagine I'm legally allowed to loan my digital copy of the haskell book, am I? I haven't cracked it in a year
19:09:25 <ski> @where HTAC
19:09:25 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
19:09:31 <ski> @where wikibook
19:09:31 <lambdabot> http://en.wikibooks.org/wiki/Haskell
19:10:20 <ski> drano : hm, you could also try following some course material :
19:10:23 <ski> @where CIS194
19:10:23 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
19:10:30 <ski> @where NICTA
19:10:30 <lambdabot> https://github.com/nicta/course
19:10:43 <ski> @where Data61
19:10:44 <lambdabot> Data61 Functional Programming Course <https://github.com/data61/fp-course>,<https://qfpl.io/links/2017-october-fp-course/> by Tony Morris,Mark Hibberd
19:10:54 <dibblego> being held in Brisbane, end of November: http://qfpl.io/links/201811-26-28-brisbane/
19:11:12 <ski> afaiu, CIS194 (that year in particular) is quite well regarded
19:11:37 <ski> (and i think NICTA and Data61 is more advanced, so don't start with them)
19:12:06 <dibblego> I think it's more fast-paced; we cover all of CIS194 (and a bit more) in three days
19:12:14 <ski> right
19:12:23 <dibblego> FYI, NICTA doesn't exist anymore (it became Data61)
19:12:49 <ski> yea, but the material is still available, no ?
19:12:54 <dibblego> sure
19:14:37 <ski> there's a book "Real World Haskell", but i understand people are saying that it hasn't aged that way, in that it refers to things in libraries which have subsequently changed ?
19:14:49 <ski> s/aged that way/aged that well/
19:15:39 <jle`> i think it's mostly libraries yeah, but there is a good list of errata/corrections out there too
19:15:43 <blankhart> johnw, heptahedron, thanks, yeah i guess it makes sense by analogy to (a, b) ~ a -> b and dimap covariant in the second. i was just startled to find it used without ceremony in someone else's code where the tuple didn't have an obvious interpretation in that way.
19:15:50 <jle`> from what i've heard, the principles have aged fine
19:15:55 <drano> What's the recommended setup for Haskell in Emacs? I'm currently using Intero and both the ghc-mod and ghci backends for company. I've heard good things about flycheck-haskell (I think that package; there are several flycheck integration packages).
19:16:10 <glguy> drano: I prefer using dante and flycheck
19:16:14 <ski> drano : the problems with LYAH i've heard is about it being too shallow, and also not offering exercises. i've heard it compared to a four-hour long trailer
19:16:29 <glguy> dante is pretty lightweight and doesn't require installing extra tooling per GHC version/project
19:16:32 <joehh> +1 for dante
19:16:41 <ski> (but it sure has funny pics)
19:16:50 <joehh> just works
19:17:26 <heptahedron> blankhart: I'd be careful there--`(a, b)` is a bifunctor, not a profunctor, iiuc. `bimap`, not `dimap`, and `(a, b)` is not isomorphic to `a -> b`, but rather `forall r. (a -> b -> r) -> r`
19:17:28 <drano> I'll check out dante. ski: So I won't get much out of besides the basics of the type system it if I already know about closures and continuations?
19:17:34 <ski> drano : hope this helps, and that you're not too overwhealmed with info now
19:17:42 <drano> much out of it*
19:17:52 <ski> talking about LYAH ?
19:17:55 <drano> yeah
19:18:06 <ski> iirc, it didn't even teach type system that well
19:18:12 <drano> RIP
19:18:26 <ski> btw, there's also non-strictness to learn (unless you've already done say Clean)
19:18:42 <drano> Oh, right. The lazy business.
19:19:28 <ski> (non-strictness is typically implemented with laziness, as in GHC. non-strictness is a (denotational) semantic property about what answers you get. laziness is a particular implementation strategy (operational semantics) for non-strictness, with a cost (time and space) semantics)
19:19:33 * ski nods
19:20:02 <ski> in practice, people usually talk about laziness in Haskell. but strictly speaking, the correct property at the level of the language is non-strictness
19:20:16 <joehh> re dante, only thing I had to set was some .dir-locals.el files when I had/have multiple targets
19:21:37 <ski> it's similar to e.g. TCO in Scheme. TCO is a particular implementation strategy for "proper tail recursion" (which btw doesn't in itself has to do with recursion. it applies to all tail calls), which is a statement about supporting an unbounded number of active calls in tail position, in bounded space, regardless of how that's implemented
19:22:03 <ski> (well, or at least it's comparable to that)
19:23:06 <blankhart> heptahedron, thanks, i didn't mean to indicate an isomorphism between the types but the identification of a function with its graph
19:23:07 <drano> ski: laziness is just one way of getting non-strict eval semantics?
19:23:34 <ski> drano : yep. there's some experimental implementation (not sure how active it is
19:23:36 <joehh> https://paste.debian.net/1048717/
19:24:05 <ski> drano : ) where you speculatively evaluate things that you think *might* be needed, in free threads of execution
19:24:29 <drano> ski: ahead-of-time memoization?
19:24:37 <ski> drano : (with a timeout, and making sure not to let exceptions escape and abort the rest of the program)
19:25:13 <supersaiyan> how would i write a zero of a function in haskell? preferably in list comprehension ?
19:25:16 <heptahedron> blankhart: ah I gotcha
19:25:18 <ski> that's certainly not lazy evaluation, but it'd still qualify as non-strict, because of the timeouts and shielding rest of program from failures in the speculative evaluation
19:26:05 <ski> drano : not really memoization, at least not in the sense of memoizing a function, making it remember some input-output associations it has computed
19:26:51 <ski> (which is something that GHC doesn't give you either. there are libaries where you can ask for that, but it doesn't happen automatically. one reason is that it can lead to space accumulation, which needn't be a net win)
19:29:52 <ski> (otoh lazy (aka by-need) evaluation does "memoize activated (sub)expressions", so that if you call `f (g x)', and `f' calls its argument `y', then if (during that call to `f') `y' ever needed, the corresponding evaluation of the actual parameter `g x', calling `g' will only be done once, so that demanding the value of `y' again will just reuse the earlier result. but if you call `f' again, you get a new `y')
19:31:29 <ski> e.g. if you define `square x = x * x', and evaluate `square (2 + 3)', then the addition will, under by-need / lazy evaluation, be performed at most once. in this case exactly once, since the multiplication in `square' demands both arguments directly
19:33:38 <ski> otoh, if you define `foo x y z = x < y && y < z', and you call `foo (a - b) (a + b) (a + c)', then `a + c' may not be evaluated at all, namely in case `a - b < a + b' is `False' (short-circuiting evaluation of `(&&)', which is just a special case of how by-need evaluation works)
19:33:41 <ski> @src (&&)
19:33:42 <lambdabot> True  && x = x
19:33:42 <lambdabot> False && _ = False
19:34:04 <ski> is the definition of conjunction. it's not built-in, and it's not a macro either
19:35:01 <ski> (that uses "pattern-matching", in the form of "multiple defining equations", the first one which matches the input arguments (which are evaluated enough to decide) is committed to)
19:35:33 * ski isn't sure whether drano has used the `match' macro (or similar) facilities in Scheme
19:36:28 <ski> (i'll stop here, unless you have any further question or comment)
19:38:00 <heptahedron> Could anyone answer if sigma types are recoverable from pi types in the same way that you can e.g. church-encode a product type
19:39:26 <ski>   Sigma x : A. B x  =  Pi C : Type. (Pi x : A. B x -> C) -> C
19:40:10 <ski> aka `exists a. ..a..  =  forall o. ((exists a. ..a..) -> o) -> o  =  forall o. (forall a. ..a.. -> o) -> o'
19:40:42 <ski> because `a  =  forall o. (a -> o) -> o', together with `(exists a. ..a..) -> o  =  forall a. (..a.. -> o)'
19:41:07 <heptahedron> is that coq? I'm not fluent but I'll pore over this haha
19:41:23 <ski> (the first of those are related to the CPS transform. and to a special case of Yoneda)
19:41:40 <ski> the latter equations are (pseudo-)Haskell types
19:42:07 <ski> the former one, involving `Pi' and `Sigma' are some unspecified dependently typed language
19:43:04 <ski> (the expansion to the right requires quantifying over a type, though, which may bump up your universe level)
19:44:04 <ski> (pseudo-Haskell, because there is no `exists' (well, there is in UHC, iirc. but only to the left of `->', where you don't need it ..)
19:44:11 <ski> (perhaps LHC as well. i can't recall)
19:46:41 <drano> ski: I haven't used the match macro because I haven't used Racket (which is the only one with it), but I have used pattern matching in Erlang. Thanks for the help.
19:46:58 <ski> hm, istr there was also a freestanding implementation ?
19:47:36 <ski> ok, knowing a little Erlang will help with the pattern-matching part then
19:48:25 <ski> presumably you're already familiar with using recursion to expression iteration, and more complicated looping
19:49:20 <ski> and, presumably, you have at least some familiarity with using (mainly tail) recursion (with changing "state/accumulator" parameters) instead of iteration with mutation
19:50:00 <ski> and some experience with using higher-order functions, i suspect
19:50:27 <ski> all this will help, so that you can focus more on the parts that are new to you
20:16:13 <MarcelineVQ> ski: you're full of beans today :>
20:18:35 <rotaerk> is there any way in haskell to turn an `IO x` into a lazily evaluated `x`?  as in, it's convenient to specify the `IO x` for obtaining the `x` earlier than it's actually needed, but I don't want to have to use it for the first time (and thus trigger the actual execution of the IO) from an IO context
20:19:20 <dolio> unsafeInterleaveIO
20:19:22 <ion> rotaerk: That way lies madness.
20:19:58 <rotaerk> thanks, dolio 
20:20:06 <rotaerk> ion, yeah :P
20:33:20 <Axman6> yeah don't do that - doliois correct, but is handing you a powerful footgun
20:35:19 <rotaerk> Axman6, why not
20:40:18 <rotaerk> in vulkan I have a handle to a physical device, and there are a bunch of vulkan functions for obtaining various sets of properties about that physical device.  I would like to make a record type containing all of them, say VkPhysicalDeviceDetails, and a `VkPhysicalDevice -> IO VkPhysicalDeviceDetails` function, but I don't want to *actually* fetch each of those sets of properties until the user needs them
20:42:21 <davean> ok, so
20:42:27 <davean> the device is disconnected
20:42:30 <davean> they look at your record
20:42:32 <davean> what happens?
20:44:19 <rotaerk> the handle and the record of details will not exist in a context where the handle is no longer valid
20:45:24 <davean> I question your claim there
20:45:49 <davean> How would you even know? Haskell is non-strict
20:46:27 <davean> Something that was decided by something that made a decision based on one of these lazy IO contents could cuase the execution of that IO 
20:46:41 <davean> Theres so many ways for this to leak
20:47:13 <davean> And this is the simple, obvious, case of how it can go wrong
20:47:42 <rotaerk> I'm not sure how it would leak if I don't return it from the ResourceT IO () block in which the vulkan instance is acquired
20:47:55 <davean> If you return something calculated from it
20:48:05 <rotaerk> right, I won't be doing that
20:48:14 <davean> So you say.
20:48:52 <rotaerk> the risk of returning something that depends on any resources acquired within the ResourceT block is always present
20:48:59 <rotaerk> it's something you just have to ... not do
20:49:52 <glguy> It's just sloppy and risky, but as long as you're OK with that you're good to go.
20:50:28 <davean> rotaerk: its entirely different when you're talking about something hiding as pure computation
20:50:53 <davean> Its easy enough to "not do" when it has a specific type
20:51:00 <davean> when it could be even the (), thats different
20:51:27 <davean> and yes, it might sneak out in the ()
20:52:04 <rotaerk> how?
20:52:52 <davean> well, if which () it is depends on a branch thats based on the lazy value for example ...
20:52:55 <davean> its rather trivial
20:53:05 <davean> Its *entirely* different when you're talking interleaved IO
20:53:18 <davean> This is *not* the normal issues you have with ResourceT at all
20:54:01 <rotaerk> also, what would you recommend I do? seems like the only other options are to either 1) pre-fetch all these properties together (regardless of whether some are ultimately unused), or 2) don't combine them into a single data structure at all
20:54:37 <davean> Either seems quite reasonable
20:54:56 <ion> Maybe an IO-based interface to query the properties upon a need.
20:56:43 <rotaerk> hmm
20:56:50 <davean> Just how expensive are we talking anyway to query them all?
20:57:54 <rotaerk> I'm not sure, but at least one of them is allocating and filling an array, and this data structure will be filled for every physical device on the system
20:58:25 <rotaerk> probably not a notable performance hit since I'm only iterating over the devices once; just seems wasteful to fetch something I won't use
20:58:40 <rotaerk> but I'll just go with the prefetch approach
20:58:56 <p0a> Hello
20:59:00 <rotaerk> (until profiling shows me it's actually a problem, which it probably won't)
20:59:23 <p0a> Suppose I have a recursion x(n) = 2x(n-1). How can I create a list that follows this recursion?
20:59:29 <p0a> with x(0) = 1 for example
20:59:55 <supersaiyan> how would i write, in list comprehension, x < 0, return [] ?
21:00:01 <ion> @type iterate
21:00:02 <lambdabot> (a -> a) -> a -> [a]
21:03:20 <ion> supersaiyan: What does your list comprehension look like now and what would you like the result to be?
21:11:34 <emilypi> supersaiyan if there are no elements in the list that satisfy your predicates, then you'll have an empty list result
21:11:45 <emilypi> > [ x | x <- [1..10], x < 0]
21:11:47 <lambdabot>  []
21:38:49 <anuraghkp> hai i am new in Haskell language
21:39:52 <p0a> ion: thank you
21:57:40 <cocreature> anuraghkp: hi! feel free to ask questions
21:57:47 <jle`> hi anuraghkp :)
21:57:51 <Axman6> anuraghkp: welcome!
22:03:26 <ion> o/
22:04:35 <dminuoso> \o/ anuraghkp 
23:39:44 <koz_> I know that '(->) e' is 
23:40:11 <koz_> the type of functions from type e to something. Is there some equivalent of functions from e1 to e2 to something?
23:40:32 <koz_> So something that would be e1 -> e2 ->, just like (->) e should really be e ->.
23:40:32 <Ariakenom> from e1 and e2 o something?
23:41:23 <jle`> (->) (e1, e2) ?
23:41:31 <koz_> jle`: Wait, that compiles?
23:41:34 <jle`> cause of currying/uncurrying
23:41:38 <cocreature> Compose ((->) e1) ((->) e2)
23:41:43 <opqdonut> koz: `e1 -> e2 -> x` is `(->) e1 (e2 -> x)` which is `(->) e1 ((->) e2 x)`
23:41:54 <opqdonut> right, you can express this via Compose like cocreature said
23:42:01 <koz_> cocreature, opqdonut: Thanks, those make sense.
23:42:05 <Ariakenom> e0 -> e1 -> r = (->) e0 (e1 -> r) =  (->) e0 ((->) e1 r)    so  (->) e0 ((->) e1)
23:42:07 <jle`> currying is the act of transforming Compose ((->) e1) ((->) e2) into a (->) (e1, e2)
23:42:15 <jle`> er, uncurrying i mean
23:42:23 <koz_> jle`: I get them mixed up too.
23:42:59 <koz_> What module's Compose in?
23:42:59 <jle`> curry :: (->) (e1, e2) ~> Compose ((->) e1) ((->) e2)
23:43:04 <jle`> Data.Functor.Compose
23:43:13 <jle`> it's also called (:.:) in GHC.Generics, which is a name i kind of like better
23:43:36 <koz_> jle`: I don't think I can pronounce (:.:), except maybe as 'hamster'. Or possibly 'alien'.
23:43:46 <jle`> it's meant to be similar to (.)
23:44:02 <jle`> `Maybe :.: Either e`
23:44:06 <jle`> is `Maybe . Either e`
23:44:20 <jle`> (f . g) x = f (g x)
23:44:25 <jle`> (f :.: g) a = f (g a)
