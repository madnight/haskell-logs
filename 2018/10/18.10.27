00:06:20 * hackage opaleye 0.6.7003.1 - An SQL-generating DSL targeting PostgreSQL  http://hackage.haskell.org/package/opaleye-0.6.7003.1 (tomjaguarpaw)
00:07:27 <jle`> koz_: are there any partial functions you'd want to prevent?
00:07:35 <jle`> or is there any interesting transitional functions?
00:07:35 <koz_> jle`: None that I can find.
00:10:55 <typetetris> does someone mess with hackage.haskell.org or is it just me, that I can't resolve its name from time to time?
00:12:08 <jle`> then yeah, potentially not worth it heh
00:12:22 <jle`> maybe one use would be return type polymorphism
00:12:49 <jle`> like how we have replicate :: a -> Vector n a, you don't need to provide the number of items as an argument, and it can be inferred from the expected return type
00:13:20 <koz_> Yeah, but I can't really see why you'd wanna do that with computation strategy for arrays.
00:13:25 <koz_> Oh well, it was good singletons practice.
00:13:44 <koz_> A more curious question is 'how do I handle multi-dimensional indices uniformly at the type level'.
00:13:49 <koz_> ANd then my brain asplode.
00:14:02 <jle`> usually people do it with [Nat]
00:14:15 <jle`> i have a couple of libraries that do that and there are a few others that i've seen as well
00:14:36 <koz_> That would be interesting to try and hammer into Massiv.
00:14:46 <koz_> Especially when we consider 'construction' functions.
00:14:51 * hackage hevm 0.20 - Ethereum virtual machine evaluator  http://hackage.haskell.org/package/hevm-0.20 (mbrock)
00:15:24 <koz_> I also believe Massiv inherently stops at 5D arrays.
00:16:34 <koz_> Nope, I was wrong - it provides synonyms up to 5D.
00:18:29 <Lycurgus> typetetris, it's a transient in your hosts name resolution
00:19:20 <typetetris> Lycurgus: What does that mean?
00:20:59 <Lycurgus> it means that at the point at which you access hackage
00:21:52 <Lycurgus> your ISPs connection to the haskell.org, or maybe just your browser or in any case
00:22:15 <Lycurgus> a component between the haskell.org servers and you
00:22:45 <Lycurgus> fails on a given access or small set of them to resolve the name
00:24:22 <Lycurgus> and I meant the name server which is
00:24:28 <jle`> koz_: yeah, you can make a type that is a list with up to 5 elements
00:24:40 <jle`> i do that for some of the BLAS abstraction libs
00:24:53 <koz_> So something like None | One a | Two a a | Three a a a | ... ?
00:25:03 <Lycurgus> LEX.NS.CLOUDFLARE.COM
00:25:03 <Lycurgus> Name Server: POLA.NS.CLOUDFLARE.COM
00:25:09 <jle`> data Dim = Scalar | Vec Nat | Mat Nat Nat
00:25:11 <jle`> yeah
00:25:25 <jle`> or data Dim n = Scalar | Vec n | Mat n n, so you can use it at both type and value level
00:25:34 <jle`> oh man i totally forgot to talk about that trick in the singleton series.
00:26:20 <koz_> There's always room for 'Extra Single(ton)s' or something similar. :P
00:26:55 <jle`> yeah it's an important one heh.  maybe i'll add an appendix.
00:26:57 * ski . o O (  Tensor :: [Nat] -> * -> *  )
00:26:58 <Lycurgus> except when someone has b0rken it (it hackage), others don't see the transient
00:27:56 <Lycurgus> and that (hackage being offline) does occur but quite rarely
00:32:33 <Lycurgus> also the likelihood of failure decays exponentially from your browser/host command line, due to the distributed nature of the name system
00:39:52 <jle`> i also wonder when hackage will switch to ghc 8.6
00:41:21 <c_wraith> well, probably not before the 8.6.2 is released
00:41:33 <c_wraith> with that whole "don't use 8.6.1, it has a bad bug" thing
00:42:43 <Lycurgus> 8.6.2 will mark a merge back into a single line?
00:42:58 <Lycurgus> (from the 8.4/8.6 split)
00:43:18 <Lycurgus> i.e. 8.4 will truncate?
00:55:29 <c_wraith> that depends entirely on whether an issue comes up that convinces the ghc devs to make a new 8.4 release
01:05:50 <Athas> When I do 'stack upload', it just stalls after asking me for username and password.  What could be the reason?
01:06:15 <jle`> do you enter the password?
01:06:26 <jle`> if you type things in, it might not show up in your terminal window
01:06:34 <jle`> but the input is still being received
01:08:16 <Athas> Yes, I do.  It's after I press Enter at the password prompt.  Looking at the process in 'strace', it's just blocked on futex(), which I surmise means it's waiting for some other kind of IO.
01:09:08 <Athas> I guess I'll just do an sdist instead this time.
01:10:21 * hackage futhark 0.7.3 - An optimising compiler for a functional, array-oriented language.  http://hackage.haskell.org/package/futhark-0.7.3 (TroelsHenriksen)
01:10:44 <Athas> Well, the webserver gave an error, but looks like it went through.
01:11:59 <jle`> :D
01:33:33 <mcbear> is the chapter on FFI in the book "Real world haskell" still up to date?
01:34:16 <[exa]> mcbear: observing any issues?
01:34:52 <mcbear> No, I'm still learning FFI and that chapter seems still the best tutorial out there
01:35:08 <edwardk> well, crap. github integrations are deprecated. umm.. that means i have no way to send my buildbot spam to IRC that i can see
01:35:21 <edwardk> er 'github services'
01:35:36 <edwardk> now i have to have it talk to some webhook that i use to do it myself for new projects?
01:35:52 <edwardk> this rather drastically impacts my workflow, ideas?
01:36:26 <pavonia> mcbear: I don't thnik the FFI changed much over the last years (if at all)
01:36:57 <[exa]> yeah, changes will be mostly cosmetic, if any
01:37:08 <mcbear> I see. Thanks!
01:39:16 <geekosaur> it did change slightly because of the asm backend
01:40:44 <geekosaur> it usedto go through the c compiler, now you need to use "capi" to get that (and CApiFFI extension) otherwise ti cals directly. so data, CPP macros, etc. don't work with ccall any more
01:41:30 <[exa]> edwardk: how many people used the github services? I'd say that someone's going to create some webhooks->services adaptation layer soon
01:42:44 <MrA> Hu
01:42:47 <MrA> Hi*
01:42:56 <geekosaur> [exa], it's been deprecated for over 6 months, fi someone were going to do so they probably would have by now
01:42:56 <edwardk> [exa]: well, i used irc hooks for every single project i've written for the last several years
01:43:25 <geekosaur> iirc they have docs for how to do irc hooks from webhooks
01:43:31 <MrA> I started to learn Haskell last year and still I didn't even do chapter 3 in LYAH
01:43:41 <MrA> I want to understand how you people learn ?
01:44:32 <MrA> Not only Haskell but other things I thought of achieving them by last may and another year coming and still I am so looser
01:44:46 <MrA> I don't understand why I couldn't do it 
01:46:36 <MrA> How can I have good learning ?
01:52:13 <MrA> Hello ?? 
01:52:32 <maerwald> @where cis
01:52:32 <lambdabot> I know nothing about cis.
01:52:49 <maerwald> @where learnhaskell
01:52:49 <lambdabot> https://wiki.haskell.org/Learning_Haskell
01:53:00 <maerwald> err, no
01:53:07 <Lears> @where cis194
01:53:07 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
01:53:11 <MrA> My problem is not resource but my mindset
01:53:32 <maerwald> MrA: take 3-6 weeks intense studying
01:53:43 <maerwald> if you are a student, that should be easy
01:54:09 <maerwald> long breaks in-between is not good, because too much new stuff that is quickly forgotten
01:57:02 <MrA> Maerwald I am not student but a year back I was in this same room and if I recall I was even in 2014 asking how to learnhaskell ....now I know the resources where and how to start but I never did it time passed I am so worried and not understanding what went worng in my life :(
01:57:16 <MrA> May be always I was trying to build Rome in a day 
01:57:57 <maerwald> Despite popular belief, haskell is not easy to learn. And even more so if you don't have sufficient time and only do a bit here and there
01:58:25 <Athas> MrA: having a project that you *must* (or *want*) to complete is a good way to learn.
01:58:46 <Athas> I really learnt Haskell when I did my undergraduate project, where I had to modify a sizeable existing Haskell program.
01:59:26 <MrA> Ok  and I was always trying to do things in a day
01:59:36 <MrA> I think I should change that mindset 
02:00:20 <MrA> I lack confidence which I should work and learn or do project daily small time but regularly should help right ?
02:00:35 <Athas> Also, I forced myself to learn Haskell by switching to xmonad, because Haskell was the only way I could fix the things that bothered me.
02:00:56 <koz_> I agree with Athas - necessity is a great instructor.
02:00:57 <Athas> I've sometimes used the strategy of switching to programs written in the language I want to learn.
02:01:37 <MrA> Ok 
02:01:41 <maerwald> starting off with a project might lead to frustration too
02:01:46 <maerwald> complete a proper course first
02:01:50 <maerwald> this isn't python
02:02:01 <[exa]> :]
02:03:04 <Athas> Haskell is just another programming language.  It's nothing special.  You can learn on the job (for various values of "job").
02:03:26 <hc> :)
02:03:41 <maerwald> Haskell is different. It requires more structured learning than in other languages, because so much stuff builds up in terms of concepts
02:03:48 <[exa]> MrA: btw what's the biggest programming project you've finished? (in any language)
02:03:50 <Athas> Any language that is usable for applied programming is best learnt by just writing code.
02:04:07 <maerwald> I disagree
02:04:15 <Athas> I disagree.  Haskell's concepts are much shallowers (in what you *need* to know) than e.g. C++ or Lisp, even though Haskell has deeper theory behind it.
02:04:54 <Athas> In Haskell, I guess you *need* to know things like typeclass hierarchies and (most difficult) how do-notation desugars... but that's not really a lot.
02:05:00 <MrA> [exa] nothing in my life 
02:05:10 <MrA> That make me feel so sad 
02:05:16 <[exa]> MrA: what operating system are you using?
02:05:23 <davr0s> Athas .. 2 problems: lots of jargon (monad framework) and unusual syntax (for most people coming from c-like languages)
02:05:38 <davr0s> haskell made a lot more sense to me after Rust as an intermediate
02:05:50 <dstolfa> turns out that if you explain monads without using the words and say "effects" and "sequencing", everyone understands them
02:06:05 <[exa]> MrA: (sorry for the questioning, I'm trying to find the facts to help you find the best way to start quickest)
02:06:10 <dstolfa> it's just made unnecessarily difficult by using terminology
02:06:39 <davr0s> i was eventually surprised to discover that there's a simpler languaeg on whch all the monad patterns etc are built.  if you like , a "C" under the "C++".
02:06:41 <maerwald> Just jumping into a project will be a horrible experience, because he will lack almost all tools (in terms of expression space) and won't know how to do anything. Then you google for ad-hoc answers and build fragile semi-knowledge
02:07:12 <Athas> I think I read Real World Haskell while I was learning.
02:07:15 <davr0s> perhaps part of the problem is dumping people in at the deep end with all the complex jargon filled monad patterns, instead of "learning C before you learn C++"
02:07:38 <davr0s> learning to do things with the datatypes and tail recursion ec
02:07:42 <dstolfa> davr0s: haskell likes using terminology
02:07:51 <davr0s> the haskel community :)
02:07:56 <dstolfa> davr0s: which i like btw, but i can appreciate sucks for anyone who's not at least a half-mathematician
02:08:17 <dstolfa> (though some of the terminology bothers me a bit :-))
02:08:23 <MrA> [exa] no problem but I am comfortable with any os used arch Linux to windows now due to office I use windows
02:08:37 <davr0s> you know
02:08:56 <davr0s> if haskell was introduced before BASIC, i dont think it would be that hard, because actually the language engine is doing more for you
02:09:16 <davr0s> and one doesn't need to have taken maths particularly far to master basic (or C)
02:09:28 <dstolfa> davr0s: it's not really haskell that's difficult per se
02:09:39 <dstolfa> davr0s: it's just FP that people are struggling to wrap their head around, especially when you add types
02:09:41 <dstolfa> which is fair enough
02:09:41 <davr0s> i also know more maths than most people, i'd never encountered the jargon here
02:09:59 <geekosaur> I would't even say FP as much
02:10:10 <dstolfa> i've encountered people struggling with languages like SML as well, which is consistent and doesn't use too much terminology
02:10:42 <geekosaur> I mean, I knew some SML coming in; it was laziness and purity that really caused confusion, because you need tolearn a whole new way fo thinking about problems
02:10:45 <[exa]> MrA: ever wrote a calculator? Something that you pass a line with numbers and operators and it gives you the result
02:10:55 <geekosaur> whch sinot to say FP isn't aproblem, just that its not necesarily the biggest one
02:11:15 <[exa]> MrA: (btw what's the office job? maybe there will be some useful simple app you can do for helping yourself)
02:11:17 <davr0s> honestly i look at how haskell clicked a bit better with me recenly (past few weeks, after lots of rust), and I really think it could be introduced better *for C conditioned people* e.g. without a community telling you "your brain is poisoned, C is terrible , you are wrong for wanting mutation etc etc"
02:11:43 <davr0s> i guess each language needs a specific guide... "language X for people who use languge Y mostly", 
02:11:50 <dstolfa> geekosaur: sure, i mean i come from a background where i have to explain complicated things to students that just encountered them for the first time by having ridiculous amount of information dumped on them before they come to me, often with a Z-shaped curve. trying to explain it as simply as possible without saying wrong things is very, very tricky :-)
02:12:13 <davr0s> the set of languages in 'Y' wont need to be exhaustive. just C, Java, Python perhaps as a starting point..
02:12:16 <[exa]> davr0s: i like the term "C conditioning"
02:12:39 <davr0s> i'll admit i've used C and C++ so much.. they've patterned my brain somewhat
02:12:42 <geekosaur> andwhen haskell hits you with FP, laziness, and purity all at once, it is kinda daunting 
02:12:54 <dstolfa> davr0s: mutation is fine-ish, you just have to be explicit about it to be able to deal with some analyses :-)
02:13:04 <maerwald> rust is explicit about it
02:13:15 <davr0s> Rust is the best compromise for me .. i think of it as controlled mutation.
02:13:29 <dstolfa> maerwald: i know, i'm just responding to the part where it's stated that mutation is bad
02:13:43 <davr0s> best all rounder because it's got the same memory model/executiaon model as C++; it can be used for the same niches
02:13:46 <maerwald> davr0s: Yes, in a lot of domains I consider it doing a better job, but it's way more verbose ofc
02:13:58 <davr0s> right Haskell makes Rust look fugly!
02:14:06 * dstolfa admits to not actually liking a lot of Rust
02:14:12 * dstolfa also admits that he'd rather write Rust than C
02:14:33 <davr0s> they could streamline it a bit with a bit more inference, e.g. you have to repeat the types in impl's .. i like that in Haskell you dont
02:14:53 <[exa]> davr0s: C++/haskell leap is done by reading about how RTS and thunk-based evaluation works
02:15:06 <[exa]> davr0s: the differences mostly disappear after that
02:15:28 <MrA> Ok [exa] but I feel people misunderstanding my problem with language problem ...... My problem is with my mindset liek I start then I waste time jumping to other things....and I always want I learn anything ins. Month or less which is so bad because I want to rush and change my life so fast, today I understand it wont work. I am deciding now like this : Monday to Friday everyday 3 days I spend learning onsnometjong and 2 days on Haskell an
02:15:35 <MrA> I will try to do some open-source project
02:15:42 <MrA> In this way I should help myself 
02:15:46 <MrA> Am I right ?
02:16:00 <[exa]> davr0s: only C++ looks totally unwieldy after that
02:16:32 <MrA> Also what ever I see I want to become expert  though I enevr became expert in anything 
02:16:36 <dstolfa> davr0s: the part i don't like about rust is the lack of GC and the messy model it imposes as a result of framing
02:16:41 * dstolfa doesn't think GC is evil
02:17:04 <davr0s> dstolfa if you can tolerate GC you have way more options in languages. Rust wont be a big deal
02:17:16 <davr0s> dstolfa the big deal with Rust is the features it brings to niches that can't use GC
02:17:40 <[exa]> MrA: jumping from project to project is a common problem. finish a _small_ project and reward yourself to get motivation (that's how neural nets are taught to do the right thing anyway)
02:18:57 * dstolfa has seen many programs that got faster once written in a GC'd language
02:19:14 <dstolfa> just because managing memory manually, thinking about cache lines and fragmentation is just... difficult manually
02:19:25 <dstolfa> naturally this GC'd language wasn't java.
02:19:29 <dstolfa> java's GC is a disaster
02:19:41 <maerwald> show me a GC that is not a disaster =)
02:19:46 <[exa]> :]
02:19:47 <maerwald> C#, Go, ... all of them have problems
02:19:50 <maerwald> and eventually leak
02:19:52 <dstolfa> maerwald: ocaml's GC and mlton's GC are really good
02:19:52 <davr0s> dstolfa it's possible that for less programming time, a GC might be faster in some cases, but if you need maximum performance I think no-GC will always win.. it's just it will take more programming time to refine.
02:20:09 <davr0s> dstolfa there's also cases where GC wins... by wasting memory :)
02:20:35 <davr0s> size/speed tradeoff
02:20:56 <dstolfa> davr0s: not necessarily, it really depends on what the architecture exposes to you. if you have a quick way to traverse pointers without having to keep them aside and trace them, i.e. you can do quick destruction as a result, the GC will wil because it can do runtime checks for fragmentation
02:21:01 <dstolfa> whereas you're just... guessing
02:21:29 <davr0s> i am not convinced
02:21:48 <dstolfa> davr0s: and i'm not trying to convince you, i'm saying i'm unconvinced with the anti-GC arguments :-)
02:21:55 <dstolfa> so we both remain unconvinced
02:21:59 <int-e> I'd look at it this way: your "no-GC" program may end up implementing a garbage collector just to be efficient.
02:21:59 <davr0s> i am certainly convinced 'some programs got faster' on GC, but i'd put that down to a developper time/performance tradeoff
02:22:11 <[exa]> dstolfa: do you know the usual "performance programming" trick with branch prediction and virtual methods in c++?
02:22:20 <davr0s> dstolfa  what i will say is GC is fine for "most work programmers do"
02:22:36 <dstolfa> davr0s: turns out it's also really good for high performance trading :-)
02:22:38 <dstolfa> [exa]: yeah
02:22:55 <davr0s> it's just there are *important* niches where GC is unsuitable, so the world still needs "non-GC languages". hell, there are niches where *dynamic memory allocation* is unsuitable, let alone GC.
02:23:37 <dstolfa> davr0s: "dynamic memory allocation" is a funny word. i've worked on stuff that can't acquire locks, let alone try to allocate memory yet it still has "dynamic allocation" via pre-allocation of a scratch space to work in
02:24:01 <dstolfa> it's basically a runtime with interrupts turned off
02:24:01 <davr0s> heavily controlled dynamic allocation that must reason up-front
02:24:18 <davr0s> such that it will never try to do something where an allocation fails - it's a big difference.
02:24:28 <dstolfa> davr0s: not necessarily, allocation can fail
02:24:32 <davr0s> no
02:24:35 <dstolfa> it's just that you have to be careful abuot it
02:24:37 <dstolfa> about*
02:24:38 <[exa]> MrA: btw you should try the calculator thingy, it's a very good first project
02:24:39 <davr0s> there are niches where you are not allowed to fail
02:24:51 <dstolfa> davr0s: well, if you write C or rust you have failure modes that are implicit
02:24:55 <dstolfa> so then don't use those languages?
02:25:03 <davr0s> so you must plan before you use memory: "how much is there, how do i prioritize the work to ensure i do the most important parts.."
02:25:12 <MrA> Thanks you [exa] i think I can write calculated even in Haskell but not with GUI
02:25:17 <[exa]> MrA: you input 1+1, press enter, it writes 2 and waits for another input until you e.g. write "quit"
02:25:18 <dstolfa> davr0s: i think you're conflating too many things here
02:25:20 <davr0s> dstolfa i'm saying thre are nichces where *the program is not allowed to fail*
02:25:37 <davr0s> the possibiliy of failiure is itself a failiure of the design, *in the context of such a niche*
02:25:40 <[exa]> MrA: certainly not with gui, UI programming is, say, frustrating at best
02:25:51 <dstolfa> davr0s: there's the notion of hard failure, and some things failing. there's also the notion of managing memory, allocations failing and handling them in a non-destructive way versus panicking the system
02:25:54 <[exa]> MrA: commandline interfaces are best for starting
02:25:55 <davr0s> and again i issue the disclaimer, *most programming is not like this*
02:26:00 <dstolfa> davr0s: and i'm telling you that i'm working in such a niche
02:26:03 <dstolfa> and that it's not black and white
02:26:13 <davr0s> greyscale
02:26:26 <davr0s> if you're accepting GC, then my niche was closer to the edge :)
02:26:27 <dstolfa> if you can handle a failed allocation without crashing the entire thing, you're fine with allocations possibly failing
02:26:44 <dstolfa> davr0s: oh the kernel tool itself is written in C, i'm unhappy about that
02:26:58 <dstolfa> but it implements a very stupid GC itself actually
02:27:08 <dstolfa> which is leaky as a result
02:27:24 <[exa]> what was the saying with the half of a common lisp?
02:27:31 <davr0s> ok a 'failed allocation' -> alternate code path is closer
02:27:44 <dstolfa> davr0s: yeah, that's fine. hard failing on a failed allocation is not acceptable
02:28:05 <MrA> [exa] I decided like this 3 days a week 4hours a day after office I will spend time on my area of interest it's not with programming say a lot of maths then 2 days 4 hours I will stick to Haskell learning then Saturday and Sunday as much as possible I will do some projects I like or take rest sometimes ....I think in this way I can change my mindset. Thanks a lot. I would like to know the learning habits of people here but it's hard for pe
02:28:14 <MrA> I should just change my habits and discipline
02:28:20 <dstolfa> davr0s: for context: this tool is used when production systems have problems that you want to diagnose, and you don't get to diagnose them if the system is brought down as a result of using the tool :-)
02:28:40 <dstolfa> so obviously, it crashing will bring the entire system down, leaving you with 2 problems instead of 1
02:29:05 <[exa]> MrA: you should quit making timetables before you know what task you're taking :]
02:29:54 <[exa]> MrA: btw I'm usually idling there, report back after you have the calculator. Handling just simple "number operator number" expressiosn is a good thing for the first version
02:30:19 <haasn> fwiw I prefer my programs crashing on OOM rather than entering some fallback error handling code path
02:30:33 <haasn> as long as they crash in a safe way, like immediately segfaulting or aborting
02:30:49 <haasn> these fallback code paths for when malloc() fails I can guarantee you were never tested or debugged for security issues
02:30:57 <haasn> they probably don't even work
02:31:42 <dstolfa> haasn: i'm not talking about C here though, i'm talking about you interacting with a debugging tool deeply baked into the kernel and that tool crashing the kernel while you're trying to debug your problem
02:31:45 <dstolfa> you do not want that to hard fail
02:31:53 <[exa]> haasn: you can't crash a boeing
02:32:08 <haasn> [exa]: a boeing also doesn't malloc
02:32:13 <dstolfa> again, not black and white :-)
02:32:15 <typetetris> Why are people hopping onto this discord thing instead of irc
02:32:16 <typetetris> ?
02:32:32 <dstolfa> typetetris: ease of access, not requiring a bouncer or ssh session
02:32:36 <[exa]> haasn: tell that to people who hear the windows boot sound from the speakers mid-flight
02:32:39 <haasn> but fair enough, I understand that this is both off topic of the channel and off topic of the actual discussion :)
02:32:58 <dstolfa> [exa]: brrrrr, but that's probably the navigation software :-P
02:33:06 <maerwald> OOM is not even reliable ;)
02:33:09 <haasn> s/doesn't/shouldn't/
02:33:37 <maerwald> it may cause crazy cache swapping until your PC becomes as unresponsive as with a swap
02:34:03 <dstolfa> maerwald: it can be reliable if you catch traps that would do that
02:34:09 <[exa]> typetetris: I've already heard that several times in my (short) life, IRC is still here
02:34:12 <maerwald> dstolfa: ?
02:34:12 <dstolfa> or if you just wire memory
02:34:18 <MrA> Ok [exa] I will be back then with calculater
02:34:26 <dstolfa> maerwald: if you're working in the kernel, you can wire memory, so it can never end up in swap
02:34:37 <[exa]> MrA: btw there's the lesson for developing fast, lemme find it
02:34:46 <maerwald> dstolfa: I don't have a swap
02:34:48 <dstolfa> alternatively you can prevent access to paged out data if you don't want to access anything paged out and take a fault
02:35:13 <[exa]> MrA: this one: http://www.catb.org/esr/writings/taoup/html/ch01s07.html
02:35:17 <dstolfa> maerwald: everything kind-of-swaps though :-)
02:35:23 <dstolfa> even if you don't have a dedicated swap partition
02:35:28 <maerwald> dstolfa: and you have no control over what the kernel does, unless you patch it
02:35:35 <dstolfa> maerwald: well, hence i said if you work in the kernel
02:35:42 <davr0s> haasn you're tlaking about the more rigourous solution of not mallocing, right
02:35:45 <haasn> it's the virtual memory system desperately trying to free up memory in order to pay back all the virtual memory loans it took out
02:35:50 <davr0s> haasn that's what i'm getting at
02:35:53 <maerwald> well, you can rewrite anything, that doesn't make the OOM killer any more reliable
02:36:00 <maerwald> and there is earlyoom, which works in userspace
02:36:02 <dstolfa> maerwald: the OOM killer is pretty bad
02:36:07 <davr0s> "niches where dynamic memory allocation isn't acceptable"
02:36:23 <haasn> a better solution in practice is to use cgroups to subdivide your operating system and your workload
02:36:30 <haasn> so that the latter can never fully starve the former of any resource
02:36:44 <[exa]> MrA: also, you might want to try the IO function interact from here: http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:interact
02:36:55 <dstolfa> haasn: modulo bugs and malicious behaviour :-)
02:37:01 <MrA> Thanks k you so much [exa] I will read it first as I am much interested here today to know the learning habits 
02:37:01 <dstolfa> never discount that in operating systems, they're terrible
02:37:45 <haasn> dstolfa: you don't have to tell me twice, my system just semi-froze because I exhausted my GPU's resources from an unprivileged userspace program
02:38:03 <[exa]> btw guys is there an `interact' version that would e.g. work with State or RWST?
02:38:07 <haasn> modern graphics APIs allow you to take down a system by accident, one hardly needs to imagine what can be done on purpose
02:38:20 <dstolfa> haasn: WebGL on android has direct access to the GPU memory
02:38:30 * dstolfa wonders if this will cause people to turn it off on their phones
02:38:39 <[exa]> but more like with lines of input
02:39:04 <haasn> [exa]: that's really sort of the domain of the various iterator libraries out there
02:39:20 <haasn> doing chunk-wise I/O processing with side effects
02:39:20 <[exa]> hm iterators, ok
02:39:58 <haasn> but here's a simple thing you could do:
02:40:33 <haasn> :t \f -> mapM f =<< fmap lines getContents
02:40:34 <lambdabot> (String -> IO b) -> IO [b]
02:41:07 <haasn> or replace by something like  mapM_ (putStrLn . f)
02:41:19 <[exa]> yeah
02:41:35 <[exa]> I wanted to avoid coding it myself (like, for finding inspiration in the library etc) :]
02:41:40 <[exa]> thanks
02:42:38 <haasn> :t \f -> interact (unlines . f . lines)
02:42:39 <lambdabot> ([String] -> [String]) -> IO ()
02:51:42 <haasn> [exa]: heh, the pipes version could look like this: runEffect $ P.stdinLn >-> P.map reverse >-> P.stdoutLn
02:51:47 <haasn> but that's not really any shorter or more convenient in this case
02:52:41 <haasn> oh wait you wanted a version that would work with something like State or RWST, right?
03:07:05 <xourt> Hey guys, I have a beginners issue, reading a bunch of files in Haskell:
03:07:46 <xourt> I have a [IO String] with the file contents, but I would like to get a IO [String]
03:08:12 <xourt> I have succeeded to get a an IO String with mconcat
03:08:14 <Ariakenom> :t sequence -- xourt 
03:08:15 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
03:08:33 <Ariakenom> well that's a bit general I suppose
03:09:13 <Ariakenom> [IO String] -> IO [String]    fits into that signature
03:09:27 <Ariakenom> see also traverse
03:09:30 <xourt> ok great! I'll look into this
03:09:41 <Ariakenom> % traverse putStr ["hi ", "w"]
03:09:41 <yahb> Ariakenom: hi w[(),()]
03:09:51 <Ariakenom> % traverse_ putStr ["hi ", "w"]
03:09:51 <yahb> Ariakenom: ; <interactive>:146:1: error:; * Variable not in scope: traverse_ :: (String -> IO ()) -> [[Char]] -> t; * Perhaps you meant `traverse' (imported from Prelude)
03:16:31 * ski idly wonders what xourt's issue was
03:19:59 <Geekingfrog> Hello. I have a typeclass where I want to have a constant for each type: class Foo a where fooSize :: Proxy a -> Int. This works, and I can call fooSize (Proxy :: Proxy MyType). What's the "modern" way to do that with typeApplications ?
03:21:10 <geekosaur> fooSize :: a, with fooSize @a ?
03:21:15 <Geekingfrog> If I try fooSize :: Int I get some errors "could not deduce (Foo a0) from the context Foo a" and the hint to enable AllowAmbiguousType which seems a bit sketchy
03:21:19 <geekosaur> er, fooSize:: Int
03:22:24 <geekosaur> I think that's more or lss required, because tyep applicatio is the only way to disambiguate it
03:23:50 <Geekingfrog> Ok, it is less scary when presented this way indeed.
03:24:03 <Geekingfrog> AmbiguousTypes it is then
03:28:21 * hackage multiset 0.3.4.1 - The Data.MultiSet container type  http://hackage.haskell.org/package/multiset-0.3.4.1 (TwanVanLaarhoven)
03:36:16 <aplainzetakind> a = 5; ambi' = replicate x y where x = 7 `mod` a; y = 10 / a
03:36:32 <aplainzetakind> I'm surprised that this works
03:37:21 <aplainzetakind> a would be both Fractional and Integral
03:37:32 <aplainzetakind> Apparently that's not how things work.
03:38:48 <Axman6> aplainzetakind: it'll compile, but you'll need to find a type which is actually an instance of both classes
03:45:04 <aplainzetakind> Axman6: It actually returns [2.0,2.0] as it is.
03:47:48 <ski> "It" being ?
03:49:21 * hackage network-carbon 1.0.14 - A Haskell implementation of the Carbon protocol (part of the Graphite monitoring tools)  http://hackage.haskell.org/package/network-carbon-1.0.14 (OliverCharles)
03:50:25 <ski> hm, perhaps you have `a' of type `forall n. Num n => n'
03:52:25 <aplainzetakind> ski: I load up a file with these in, and `a' with a specified type signature of Num a => a
03:53:02 <aplainzetakind> I don't really know how quantified types work so maybe I'll understand what's going on.
03:53:06 <opqdonut> literals are polymorphic. it gets "downcast" into Int or Double dependingont he use
03:53:11 <ski> yea, as i suspected
03:53:21 <ski> so, `a' is polymorphic
03:53:28 <opqdonut> just like [] :: [a] can be used in [True] ++ [] and [7] ++ []
03:53:38 <ski> it has every type that is an instance of `Num'
03:53:38 <Ariakenom> % let a = 5; x = 7 `mod` a; y = 10 / a; in replicate x y
03:53:38 <yahb> Ariakenom: [2.0,2.0]
03:53:52 <ski> so, in particular, it has type `Int', and it also has type `Float'
03:54:21 <ski> (or maybe it's `Double', not `Float'. i don't recall which it defaults to)
03:54:41 <aplainzetakind> opqdonut: I know, but I thought that once it was cast, it would have to commit to that type.
03:54:51 <ski> in the definition of `x', `a' has the particular type `Int'
03:55:10 <ski> in the definition of `y', `a' has the particular type `Float' (or is it `Double' ?)
03:55:18 <Ariakenom> Integer and Double are the defaults
03:55:22 <ski> ok, ty
03:55:25 <ski> well
03:55:28 <ski> @type replicate
03:55:29 <lambdabot> Int -> a -> [a]
03:55:41 <ski> so it's `Int', not `Integer', for `x'
03:55:48 <Ariakenom> indeed
03:56:24 <ski> aplainzetakind : there is no cast
03:56:38 <ski> there is specialization of a polymorphic value
03:57:06 <ski> `a' has type `forall a. Num a => a' (that `a' is a type variable, not the same as the ordinary (value) variable `a')
03:57:38 <ski> which means that for every type `a' that is an instance of `Num', the value variable `a' is (or can be used as) having type `a'
03:58:16 <ski> so, in particular `a' has (or can be used as having) type `Int', because that's an instance of `Num'
03:58:29 <ski> and, in particular `a' also has (or can be used as having) type `Double', because that's an instance of `Num'
03:58:46 <ski> one case applies in the definition of `x', the other in the definition of `y'
03:59:10 <ski> the general type of `a', i.e. `forall a. Num a => a', applies for the definition of `a' itself
03:59:28 <ski> the two uses of `a' however uses the two specializations
03:59:33 <ski> aplainzetakind : making any sense ?
04:01:08 <aplainzetakind> It does of course. I just thought the way things worked was that everything had to have a concrete type, which the compiler deferred inferring as long as possible.
04:01:27 <aplainzetakind> Apparently the polymorphism is in fact stronger than that.
04:01:42 <Ariakenom> consider fmap
04:01:44 <Ariakenom> % (fmap (+1) [1], fmap (+1) (Just 1))
04:01:44 <yahb> Ariakenom: ([2],Just 2)
04:02:16 <Ariakenom> or rather
04:02:17 <Ariakenom> % let f = fmap (+1) in (fmap (+1) [1], fmap (+1) (Just 1))
04:02:17 <yahb> Ariakenom: ([2],Just 2)
04:02:27 * Ariakenom sighs
04:02:35 <Ariakenom> % let f = fmap (+1) in (f [1], f (Just 1))
04:02:35 <yahb> Ariakenom: ([2],Just 2)
04:03:23 <aplainzetakind> Indeed.
04:03:24 <Ariakenom> aplainzetakind: You can only run non-polymorphic code though, yes.
04:04:51 <aplainzetakind> How are the above examples not running polymorphic code?
04:05:14 <mniip> Ariakenom, err?
04:05:25 <Ariakenom> f is polymorphic in general but monomorphic (but with different types) in its uses
04:05:30 <mniip> > length $ reverse []
04:05:33 <lambdabot>  0
04:05:35 <mniip> what is the type of reverse here?
04:05:49 <Ariakenom> [()] -> [()]
04:06:02 <Ariakenom> % maxBound
04:06:02 <yahb> Ariakenom: ()
04:06:18 <mniip> why do you think that
04:06:23 <Ariakenom> see maxBound
04:06:29 <mniip> maxBound is defaulting
04:06:33 <Ariakenom> so is []
04:06:39 <mniip> because Bounded is one of the prelude typeclasses
04:06:48 <mniip> in 'reverse [] :: [a]' there's no constraints
04:06:52 <mniip> so defaulting does not apply
04:08:56 <mniip> GHC uses an entirely different trick when translating this code into Core (where all types are explicitly applied)
04:12:12 <ski> is that instantiating it to a concrete `Any' or something ?
04:12:34 <Ariakenom> huh, that compiles in ghc?
04:13:11 <mniip> ski, yes, where Any is a type family with no instances
04:13:19 <mniip> so GHC knows it's not an algebraic type
04:13:30 <mniip> this has implications on pointer tagging and the like
04:14:18 <ski> iirc, SML/NJ generates a fresh skolem type, that it instantiates with, a type which is not known to be equal to any other type
04:14:50 <ski> so if you define `val xs = reverse []' and then `val ys = reverse []', then `xs' and `ys' will have incompatible types
04:15:05 <ski> (it can't generalize here, because of the value restriction)
04:16:05 <ski> OCaml (which also doesn't generalize here), otoh, gives both `xs' and `ys' a type involving a metavariable (a placeholder), which stands for some concrete, but as of yet undetermined type
04:17:12 <ski> if you later compute `xs @ ([2,3,4] : int list)', then it automagically fixes that metavariable for `xs' to be `int'. then you can't go on and use `xs @ ([1.1,2.1] : real int)' (`xs' is still monomorphic, not polymorphic)
04:17:43 <ski> however, you *can* say `xs @ ys' (unless you've already fixed their respective placeholders to incompatible types)
04:18:17 <ski> anyway, the skolem type that SML/NJ uses is generated on the fly, it's not a predefined thing like `Any'
04:18:51 <ski> (if it wasn't clear, `@' is list append in the MLs)
04:18:56 <ggole> The MLs tend not to introduce explicit type applications at all during compilation
04:19:08 <ggole> (Some of the type passing compilers might.)
04:23:10 <Guest8612> do you want to be online mitc 24/7 even you are disconnecred ? shell account + psybnc for only 1$ per month email rekk0881@gmail.com
04:23:20 <ski> (i think type passing can be used for (a) info on the layout of values of this type, for use by the GC, for a GC that needs/wants to know the type of what it's tracing; (b) size information, for unboxed representations of types)
04:23:34 --- mode: ChanServ set +q *!*@197.55.205.44
04:23:53 <indomitable> lol
04:25:20 <dycan> Hi, I encounter "Could not find module" in some executables...However, the package needed is in the build-depend list. Is there any other possible mistake? My cabal, stack.yaml and error is here: https://gist.github.com/4c37778780ef59c6d1493e050a29ef6d
04:26:15 <ggole> You can attach most of that without going full system-f, though
04:28:06 <ski> (hm, Mercury also uses it for a generic implementation of equality and ordering, iirc. and for some kind of reflective composition and decomposition)
04:29:11 <ggole> There was an SML implementation that was a bit like that
04:29:21 <ggole> Um, TIL? By Morriset?
04:29:51 <ski> with generic equality and ordering ?
04:30:23 <ggole> Yeah. It used type passing to implement a bunch of generic operations. Printing, etc.
04:30:33 <ski> makes sense
04:31:09 <ski> of course, this probably breaks free theorems and so (parametricity, in general)
04:31:38 <ggole> Mmm.
04:31:50 <ggole> Seems like it would expensive to construct and pass the type info, too.
04:32:44 <ski> perhaps it could use memoization
04:33:27 <ski> (and precomputed stuff at compile-time, for what it can easily determine doesn't need to be computed at run-time)
04:33:40 <ggole> Hash-consing of just the types? Maybe.
04:34:20 <ski> OCaml has support for polymorphic recursion now, right ?
04:35:12 <ggole> It's had it for quite a while, yeah
04:35:19 * ski nods
04:35:23 <mniip> ski, did you know cokernel pairs are left adjoint to equalizers
04:35:28 <dycan> Hi
04:36:19 <ski> mniip : i've probably heard it, but i don't recall offhand what (co/)kernal pairs are, so
04:36:30 <ggole> Hmm, interesting - apparently TIL used the type info to avoid GC tagging 
04:36:41 <ski> (i could possibly reconstruct it, with some thought, and pen and paper)
04:37:05 <mniip> ski, given  f : A -> B, a cokernel pair is an object K with arrows a,b : B -> K
04:37:05 <ski> ggole : yea, that's what i meant, by "a GC that needs/wants to know the type of what it's tracing"
04:37:18 <ski> (though i forgot to say "tag-less")
04:37:24 <ggole> Oh, I thought you meant the usual int-or-pointer stuff.
04:37:49 <mniip> such that a.f=b.f and for any  K', a', b' with a'.f=b'.f exists unique h : K -> K' such that  a'=h.a, b'=h.b
04:37:49 <ski> mniip : it's pushout of `f' and `f', right ?
04:37:53 <mniip> yes
04:38:04 <ski> (that i remembered, at least)
04:39:00 <ski> ggole : no, i meant that it wants to know the layout of the value, which parts are pointers. and then tagging wouldn't be needed for that
04:39:10 <mniip> consider the category ↓↓ with 2 objects and 2 parallel arrows
04:39:57 <mniip> if K : C^I -> C^↓↓ sends each arrow to its cokernel pair, and E : C^↓↓ -> C^I sends a pair of parallel arrows to their equalizer
04:40:07 <mniip> (excercise: prove K and E *are* functors after all)
04:40:22 <ggole> Actually, I wonder how that could work.
04:40:39 <mniip> K -| E
04:40:40 <ski> ggole : iirc, "Modern Compiler Implementation in {ML,Java,C}" talks a little about this ?
04:40:56 <ski> (by Andrew Appel. in 1992, iirc ?)
04:41:01 <ggole> For a generational GC you have to track pointers from the old to the new heaps, to be able to copy the live value in the new heap for the next GC.
04:41:12 <ggole> Don't you need to know the type of the edge if you are 'tagless'?
04:41:33 <ggole> ski: I have it, a nice book.
04:41:40 <ski> indeed
04:42:27 <ggole> Hmm, if you are passing type reprs I suppose you can just store that in the remembered set
04:42:47 <ski> ggole : "the type of the edge" ?
04:43:24 <ski> the GC would know the types of all things that it handles, including the things that it moves across generations, no ?
04:43:39 <ski> btw, i'd like better GC support for TCMC
04:43:41 <ggole> The GC needs to know that, yes.
04:43:41 <tv> 15
04:43:43 <tv> oops :)
04:45:04 <ggole> ski: it's fairly easy to support (without needing a write barrier), there was an experimental patch for OCaml at some point
04:45:25 <ski> ggole : oh, nice. any reference/link re that ?
04:45:39 <ggole> iirc the approach was to fill the will-be-assigned-later field with a special value that the GC knew about
04:46:16 <ggole> Thus if a GC happens and such a tagged field is seen, it can be placed in the remembered set (since it will end up pointing into the young generation later).
04:46:29 <ski> ggole : is the object automatically moved to a generation at least as old as what it points to ? or does it still involve old pointing to new ?
04:46:57 <ggole> It still involves old pointing to new
04:46:59 <ski> ggole : hm, ok
04:47:08 * ski would like to see more details on this
04:47:20 <ggole> I can probably dig up the patch...
04:47:46 <ski> mniip : btw, i wonder whether there's further adjunctions extending one or the other way ..
04:48:05 <davenall> I'm kind of new to IRC, it said "#haskell-unregistered" when I joined, is that normal? I have registered with NickServ already if that's what it means
04:48:39 <ggole> Oh, there's some slides. Nice.
04:48:50 <ski> davenall : i think that's join throttling (currently enabled on #haskell), to avoid getting surges of too many new users at the same time
04:48:53 <mniip> ski, you mean?
04:48:53 <ggole> gallium.inria.fr/seminaires/transparents/20141027.Frederic.Bour.pdf
04:49:26 <ski> mniip : i mean `F ---| K' or `E ---| G', for some `F' or `G'
04:49:58 <davenall> ski: thanks. It appears it joined me in that channel and then dumped me here afterwards, so that makes sense. Happy to be here, long time fan of Haskell :)
04:50:01 <mniip> intuition says delta
04:50:03 <ski> ggole : ty :)
04:50:09 <mniip> but that's of the wrong type
04:50:50 <mniip> I figure adjunction chains are never too long because you only cycle between two categories
04:51:39 <ski> iirc seeing that they can be four or five functors long, at least
04:52:24 <ski>   ConnectedComponents ---| Discrete ---| Underlying ---| Codiscrete
04:52:47 <mniip> that in Cat <-> Set?
04:53:12 <ski> possibly. i think i saw this example with some category of graphs
04:53:38 <mniip> codiscrete = thin connected groupoid?
04:53:57 <mniip> this is actually an exercise in mac lane
04:53:59 <ski> complete graph, yes
04:54:36 <ski> possibly this also worked for dynamical systems
04:55:05 <mniip> Ob : Cat -> Set, show that it has left adjoint the discrete category functor, and that *that* has in turn a left adjoin the connected components functor, and that Ob has a right adjoint the thin conencted groupoid functor
04:55:16 <mniip> I should probably do that exercisse
04:55:18 * ski str something with connected components in relation to groups as well. possibly that was with representations of groups
04:55:32 <ski> (a representation being transitive means that it's connected)
04:56:40 <ski> iirc, there was some topos example (which i didn't grok), with five functors in an adjunction chain
04:57:10 * mniip . o O ( How to talk to short exact sequences )
04:57:39 <ski> (yea, i wonder whether exact sequences are related, somehow)
05:15:51 * hackage hw-streams 0.0.0.3 - Primitive functions and data types  http://hackage.haskell.org/package/hw-streams-0.0.0.3 (haskellworks)
05:44:20 <noan> How would I specify the type for a specific constraint in a function? I specifically need to constraint syntax here as PgCommandSyntax
05:44:24 <noan> https://hackage.haskell.org/package/beam-migrate-0.3.2.1/docs/Database-Beam-Migrate-Generics.html#v:defaultMigratableDbSettings
05:47:56 --- mode: ChanServ set -q *!*@197.55.205.44
05:49:36 <dminuoso> noan: You could use type annotations or TypeApplications.
05:49:43 <dminuoso> Or create a proxy wrapper if you do not want to use TypeApplications.
05:50:26 <dminuoso> Mmm, in this case - since it seems to be an ambiguous type - I think you have to use TypeApplications to apply the `syntax` type variable
05:50:50 <dminuoso> So `defaultMigratableDbSettings @YourSyntaxType ...`
05:51:28 <dminuoso> noan: Or you pick one of the HasDefaultSqlDataType instances
05:51:54 <noan> dminuoso, yeah just finally found it :D
06:37:09 <noan> anyone used the beam library for their database here? I'm trying to wrap my head around doing migrations and I'm very close to considering the library too incomplete for serious use.
06:37:30 <noan> I was recommended it, but it seems to lack a classical migration system
06:45:02 <noan> nevermind, finally found the right combination of incantations.
06:45:51 * hackage haskell-lsp-types 0.8.0.1 - Haskell library for the Microsoft Language Server Protocol, data types  http://hackage.haskell.org/package/haskell-lsp-types-0.8.0.1 (AlanZimmerman)
06:47:21 * hackage haskell-lsp 0.8.0.1 - Haskell library for the Microsoft Language Server Protocol  http://hackage.haskell.org/package/haskell-lsp-0.8.0.1 (AlanZimmerman)
07:12:21 * hackage yampa-test 0.1.1 - Testing library for Yampa.  http://hackage.haskell.org/package/yampa-test-0.1.1 (IvanPerez)
07:15:52 * hackage term-rewriting 0.3.0.1 - Term Rewriting Library  http://hackage.haskell.org/package/term-rewriting-0.3.0.1 (BertramFelgenhauer)
07:23:50 * hackage nix-deploy 1.0.3 - Deploy Nix-built software to a NixOS machine  http://hackage.haskell.org/package/nix-deploy-1.0.3 (ParnellSpringmeyer)
07:30:52 <alanz> domenkozar, see https://matrix.hackage.haskell.org/#/package/haskell-lsp
07:31:46 <sm> hello hackagebot, is that you I see ?
07:38:29 <domenkozar> alanz: thanks!
07:38:50 <alanz> I'm looking forward to see what you produce with it :)
07:42:13 <domenkozar> hnix-lsp that will format code :)
07:43:20 <alanz> yes, you already have a star on your repo, from me
07:45:46 <domenkozar> hehe
07:55:17 <__monty__> Zemyla: So, I read "Coroutining Folds with Hyperfunctions, Launchbury et al." And I'm pretty sure the coroutining stuff is what I need for minus in church encoding but I don't see how I can make an existing church number do this coroutining for part of the `s` applications.
08:00:10 <deltasquared> imperative operations on filesystems with not that many ordering guarantees in the event of a crash... I wonder if anyone in functional land has invented a filesystem that doesn't involve destructive updates
08:00:37 <deltasquared> (not entirely haskell related I'll admit, but it made me think of it a bit)
08:01:21 * hackage fltkhs-themes 0.1.0.1 -   http://hackage.haskell.org/package/fltkhs-themes-0.1.0.1 (deech)
08:07:19 <ski> deltasquared : perhaps not quite what you asked for, but "Zipper-based file server/OS" by Oleg Kiselyov in 2011-02 at <http://okmij.org/ftp/continuations/zipper.html#zipper-fs>, and the following "Delimited continuations in operating systems" by ibid,Chung-chieh Shan in 2007-06-01 might perhaps be of interest anyway ?
08:09:01 <deltasquared> ski: well, this looks intriguing to say the least
08:09:52 <ski> (more generally, i suppose <https://en.wikipedia.org/wiki/Journaling_file_system> (e.g. log-structured file systems) may also be relevant ?)
08:10:11 <dfee> Wⅰtһ oᥙr IRC aԁ sᥱrvicе yoᥙ cɑn reɑch ɑ ɡlobаⅼ aᥙⅾienсe ⲟf ᥱᥒtreprᥱneurs aᥒⅾ fentаnỿl аԁԁiⅽts ᴡith extraorԁⅰnаrу еngɑɡemᥱᥒt rаtesǃ һttрs:／᜵willіampitϲock．ϲοm/
08:10:54 <deltasquared> spam bots using unicode substitution chars now, welp
08:11:05 <ski> (hm, and <https://en.wikipedia.org/wiki/Nix_package_manager> is perhaps closer to your question)
08:11:33 <ski> (deltasquared : has been going on for some while now. to attempt to avoid automatic detection)
08:12:13 <deltasquared> ski: I just tried compiling the zipperFS code here, I guess it would need updating, ghc complains about an ambiguous type variable.
08:12:52 <deltasquared> I will certainly have a look at the talk pdf though in a minute
08:13:13 <ski> btw, feel free to elaborate on what more particularly you had in mind re "not that many ordering guarantees in the event of a crash","filesystem that doesn't involve destructive updates" in your question
08:16:14 <deltasquared> ski: I admit I was venting frustration a little. something I was dealing with elsewhere. like I said, the issue wasn't to do with haskell - it was to do with lua actually, and it being a bit difficult to ensure half-written files weren't picked up on reload. However it did make me wonder if there existed Better Ways (tm) if you were to think about more than just a single process
08:16:40 <deltasquared> and uh, I guess if anywhere were to know it'd be here ;)
08:19:02 <ski> deltasquared : hm, just guessing, but mayhaps the ambiguity is related to newish language `MonoLocalBinds', which can be turned off with `NoMonoLocalBinds'. or perhaps it's something else
08:19:22 <deltasquared> ski: I'll try putting that in pragma
08:19:34 <ski> deltasquared : hm .. sounds like a want for transactional operations on the filesystem
08:20:12 <deltasquared> ski: essentially. alas most OSes don't give you anywhere near that
08:20:35 <ski> (there's also the related issue of whether combining exceptions with state behave transactionally on the state or not : whether throwing an exception resets the state back to the one present when the handler form was entered)
08:20:54 <deltasquared> it'd be great to create an anonymous tree on a given FS (referred to by an existing path, perhaps?), do ops including create files in it., sync that sub-tree, and link it in - the link would be an atomic operation.
08:22:04 <ski> (hm, also it'd be nice to have a `readFile' operation that used COW in filesystem/OS to ensure that when we later read further parts of the file, we don't see changes to the file made concurrently, since the opening. iow conceptually we capture the whole state of the file at the time of opening)
08:23:07 * ski agrees about local/private/temporary FS, with atomic link in
08:23:20 * hackage ghc-exactprint 0.5.8.2 - ExactPrint for GHC  http://hackage.haskell.org/package/ghc-exactprint-0.5.8.2 (AlanZimmerman)
08:23:27 <deltasquared> ski: I mean btrfs sort of does that under the hood on disk, but for processes with FDs open it still forces concurrent updates down their throats
08:23:54 <deltasquared> (barring files marked +C for nocow, that is)
08:24:03 <ski> "that" being the "conceptually capture state of file at open" ?
08:25:08 <deltasquared> ski: well, more than btrfs tends to avoid overwriting files in-place on disk, so in theory it *could* do that
08:25:24 <deltasquared> s/than/that/
08:26:02 <ski> interesting
08:27:39 <deltasquared> ski: also that error I was getting, it's interesting, the error is unable to solve Foldable, but ghc almost got it right - it knew it was supposed to be "t0 CInt -> IO ()", so I just made it explicitly "Foldable t => t CInt -> IO ()" and it's shut up now
08:27:46 <ski> (if one could register a handler with the OS/filesystem to copy over the blocks of the file that someone else modifies, and arrange for self to read from the copies instead, that could work. but i'm not sure how easy it would be to arrange such a thing, with most OSes/FSes)
08:28:12 <ski> deltasquared : hm, ok. i hope that solved it
08:28:33 <deltasquared> ski: well it's missing another library seemingly from the author now xD I think I may look on that page again
08:28:50 <deltasquared> CCCxe, now what on earth
08:29:31 <ski> ?
08:30:51 * hackage QuickCheck-safe 0.1.0.5 - Safe reimplementation of QuickCheck's core  http://hackage.haskell.org/package/QuickCheck-safe-0.1.0.5 (BertramFelgenhauer)
08:31:48 <deltasquared> > import CCCxe
08:31:51 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
08:31:57 <deltasquared> ... oops, forgot that
08:32:15 <deltasquared> there's a comment in the code with http://okmij.org/ftp/continuations/implementations.html so I guess I go look at that for it now...
08:33:42 <fen> ok, have benchmarks now also for the unfolding of the difference list, to go with the ones for folding them given previously
08:34:18 <fen> https://bpaste.net/show/f8a0407ae39c
08:36:00 <fen> it shows its much faster to not use maybe to safely unfold the difference list and instead using recursion and matching on the last value of a list or NonEmpty 
08:37:05 <ski> ok
08:37:28 <fen> again, there is no equivilent to [] to apply the difference list to for NonEmpty, so it uses const for use with undefined as this "target" value
08:39:13 <fen> the "safe" unfolding, not using recursion, can proceed piecewise per element, such as for a Zipper. the benchmarks show that this is a slow way to implement traverse
08:39:44 <fen> if the whole list is to be consumed it does not need this slower mechanism to proceed elementwise
08:40:10 <Ariakenom> ZFS does COW in general
08:40:53 <fen> the use of maybe is replaced by explicit pattern matching, which is only available for the recursive version
08:42:25 <ski> i wonder if one could write fusion rules for `NonEmpty', to compare
08:43:00 <ski> (using something similar to `foldr' and `GHC.Exts.build' .. or perhaps some other approach)
08:43:13 <deltasquared> ski: hmm, now in that CCCxe module there's a three-param type "CC" and the code tries to instance Monad for it, it's complaining about can't deduce Applicative - I'm going to guess simply it needs to be told an Applicative instance?
08:44:33 <deltasquared> original code is at http://okmij.org/ftp/continuations/CCmonad/CCCxe.hs on line 94 where it tries to do instance Monad m => Monad (CC p m)
08:45:07 <ski> deltasquared : you could try to drop in `instance Monad m => Applicative (CC p m) where pure = return; (<*>) = ap'
08:45:37 * deltasquared crosses fingers and hopes it type checks
08:45:48 <ski> (or you could try to write a proper instance. presumably (?) only requiring `Applicative m' ?)
08:46:10 <deltasquared> ski: I don't know enough about this monad to try that yet
08:46:18 <deltasquared> I just wanted to see if the code could still be compiled
08:46:24 * ski either, but would be tempted to try, anyway
08:46:31 <deltasquared> :t ap
08:46:32 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:47:13 <ski> @type (<*>)
08:47:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:47:27 <deltasquared> reee, functor now
08:47:54 <ski> ah, right, use `instance Monad m => Functor (CC p m) where fmap = liftM'
08:48:06 * ski hadn't checked whether the source had `Functor' or not
08:49:32 <fen> ski: what was the test that fusion was for?
08:49:58 <deltasquared> ski: ok, that appears to type check, now just to hide this naming conflict for "traverse" real quick
08:50:19 <deltasquared> is that like IIRC import Prelude hiding traverse
08:51:01 <ski> fen : test ?
08:51:16 <ski> deltasquared : bracket `traverse'
08:51:41 <deltasquared> ski: yeah, I saw. now needing Network.Socket, let's see...
08:52:05 <fen> ski: thought you might have something in mind for its use...
08:53:24 <fen> anyway, the most significant result of this benchmark is that it shows that while a zipper can point to the upper branches of a tree that do not contain values, that these should be quickly navigated over without stopping to get to the next leaf with a value.
08:53:51 <deltasquared> conflict on "drop" and not-in-scope type variables... this code has gone without love evidently
08:54:19 <fen> so that the next value is attained without providing the ability to pause at each intermediate location 
08:55:00 <fen> well, its faster to do it like that at least
08:56:26 <fen> the comonad got from zipper would have to stop at each value, but need not stop at each intermediate place between the values 
09:00:19 <ski>   iab <*> ia = CC (\ki kd -> unCC iab (\ab -> unCC ia (\a -> ki (f a)) (\ctx -> kd (\x -> ab <$> cxt x))) (\ctx -> kd (\x -> cxt x <*> ia)))
09:00:31 <ski> deltasquared : you could try that ^
09:01:13 <ski> (for `pure' you can just copy the code for `return'. and i believe you can now change from using `Monad m' to `instance Applicative i => Applicative (CC p i) where ...')
09:02:03 <fen> i wonder if its faster to use mapAccumR with the faster recursive traverse and update a carried copy of the zipper or if the fact that this is the same as the traversal suspended at each value sequentially, that this shared representation means its not slower to use the picewise navigation for the traverse
09:02:13 <ski> (beware, i don't know what this code does, i was just attempting to follow the types in my head. hopefully it type-checks, at least)
09:03:32 <ski> fen : well you (or someone talking to you) said (earlier ?) that one reason the plain list version was faster than `NonEmpty', was possibly because of list fusion stuff
09:04:01 <ski> you could look into `foldt/build' fusion. and see whether you could express something similar for `NonEmpty', that was my idea
09:04:07 <deltasquared> ski: the other approaches appear to type check. I've gotten the various bits and bug patches and there's a main function now... it appears it expects TCP clients to connect though. I think at this point I should probably read the paper.
09:04:28 <ski> (note : i haven't really followed in detail what you're doing. so take what i say with a pinch of salt)
09:04:49 <deltasquared> *^C's it* oh fml socket in use errors...
09:04:55 <ski> deltasquared : did you try the implementation of `(<*>)' i gave above ?
09:05:13 <deltasquared> ski: no, I taw usivg the other one from earlier, aliasing it to ap
09:05:19 <deltasquared> *was using
09:05:23 <ski> ok
09:05:31 <fen> ski: I gave a benchmark showing the NonEmpty working just as fast as list....
09:06:05 <ski> hm, would that be `test4' ?
09:06:22 <fen> oh wow, thats actually faster
09:06:27 <ski> (what is ?)
09:06:30 <fen> no, i meant before, for folding them
09:06:45 <ski> mhm
09:07:01 <ski> (as i said, i didn't follow in much detail what you've been doing)
09:07:13 <fen> test4 shows NonEmpty unfolding faster than List (probably because of the order of pattern matching is swapped)
09:07:37 <ski> try changing the order ?
09:08:19 <fen> to make it slower? ok, just to see if that makes it as slow as list
09:08:31 * ski idly wonders whether GHC should (or does ?) reorder matches, in order to improve branch-prediction (and perhaps locality of code ??)
09:09:21 <fen> it has to match in that order
09:09:25 <fen> for list at least
09:10:17 <fen> and yes, if there was a way it could do that it could make some savings at some point, but its essentially an algorithm design consideration probably best left to the user
09:10:34 <fen> for the sake of ease to the GHC team at least
09:11:03 <fen> wouldnt it be difficult to tell when its possible to do so?
09:11:26 <ski> well, if there's one recursive case, then probably that will be the most common case ?
09:11:41 <fen> cant even imagine if its possible in some specific situations and how to determine that
09:11:58 <fen> that = what the specific situations are
09:12:53 <dstolfa> ski: how would you improve branch prediction by reordering cases in the general case without being absolutely disgusting in terms of heuristics?
09:13:05 <fen> actually that reordering is making almost twice performance, within the varience 
09:13:37 <dstolfa> ski: you could do some PGO i guess?
09:13:41 <dstolfa> but that would still heavily depend on your inputs
09:14:28 <deltasquared> ski: oooooh the ZFS code presents a telnet prompt, was in the slide deck. I'ma play around with this now I guess
09:14:35 <dstolfa> i.e. you'd have to have a representable set of inputs to optimise it correctly by profiling -- anything unrealistic would probably make it worse
09:15:55 <fen> thats a pretty lame way to do it
09:16:13 <fen> like, its clear that matching [] should happen after matching (x:xs)
09:16:19 <ski> dstolfa : PGO ?
09:16:25 <dstolfa> ski: profile guided optimisation
09:16:29 <dstolfa> fen: yes but you might screw up other code that it calls into
09:16:35 <ski> ah... yea, i was wondering about that
09:16:42 <fen> dstolfa?
09:16:43 <dstolfa> fen: while you may improve branch prediction for that particular branch, you could screw up L1i caches for the rest
09:16:48 <dstolfa> reordering is tricky
09:16:54 <dstolfa> especially across indirect calls
09:17:05 <fen> as it will be encountered less often. but thats not something ghc can easily tell except for in this single example
09:17:13 <ski> fen : are you saing having `End' before `(:|)' makes it slower ? or faster ?
09:17:38 <fen> that would make it slower right?
09:17:54 <fen> but for list you have to check (x:[]) before (x:xs)
09:18:43 <ski> Ariakenom : Sun's ZFS, or Oleg's ?
09:18:56 <dstolfa> also note that because haskell is CBN rather than CBV, it makes it even trickier because at a later stage, something else might happen :-)
09:19:03 <fen> just benchmarking that now ski
09:19:18 <fen> cant get the varience down without running out of memory... 
09:24:17 <nshepperd1> For list you can check for (x:y:xs) first
09:25:35 <nshepperd1> Dunno if that would be faster though
09:25:56 <monochrom> GHC also reorders your pattern matching order where it doesn't change correctness.
09:26:35 <monochrom> Suppose you write this code "f A = 0; f B = 1".  A and B are my data constructors.
09:27:06 <monochrom> Then GHC-generated code keeps that order if "data T = A | B", flips if "data T = B | A".
09:28:14 <monochrom> Similarly if you write "g (x:xs) = xxx; g [] = yyy", GHC will put it back as "g [] = yyy; g (x:xs) = xxx" because that's how the data declaration orders them.
09:29:06 <fen> hmm, looks like the variance is messing it up, but it might be reordering these cases on its own... https://bpaste.net/show/2fb4862ec838 
09:29:17 <nshepperd1> So actually, worrying about the order of this pattern matching is futile?
09:29:26 <fen> could be
09:29:53 <monochrom> Yeah, between x:[] and x:_:_ you have no control.
09:30:44 <fen> oh wow, so pattern matching should maintain the order of the data declaration?
09:31:15 <fen> and that itself should be ordered in terms of what ordering would be dangerous to match in..
09:31:19 <fen> no that does not seem right
09:31:30 <monochrom> If you are interested in micro-optimizations, you will have to learn to read Core.
09:31:37 <fen> otherwise it would have caused an error at some point and it never has
09:31:56 <fen> Core is ghastly
09:32:44 <fen> anyway, im off to try and get a demonstration of what i meant about this tree zipper thing mentioned above 
09:33:30 <fen> there looks like there is a chance this slowness of traversing using a zipper can be allowable for the comonad instance...
09:33:45 <monochrom> Actually Core probably doesn't show the order either.  You need to get down to Cmm.
09:34:45 <monochrom> But when reading Cmm you also want to use Core to guide your way.
09:37:15 <fen> ok that sounds worth a try
09:37:17 <fen> what is it?
09:37:53 <fen> isnt there some system-f to be read somwhere down there?
09:38:39 <monochrom> Go to GHC user's guide section "debugging the compiler" for starters.
09:39:00 <monochrom> It pays to have read manuals from cover to cover.
09:39:05 <fen> yikes
09:39:33 <fen> https://ghc.haskell.org/trac/ghc/wiki/Debugging/Compiler
09:39:39 <nshepperd1> This difference we're supposed to be "explaining" seems small enough that it might not be real. But if it is real it could also just be that the list version has to check two constructors, not just one.
09:41:05 <nshepperd1> And nothing to do with the ordering
09:41:20 <fen> yeah, maybe if you have a system with more memory to add and extra 0 to the length of the list you could get the varience down below the performance difference. looks like the original idea that the NonEmpty version was faster could have been a mistake
09:41:49 <fen> but at least its not as slow as those first two versions which unfold elementwise 
09:41:58 <nshepperd1> Making the list longer would normally increase your variance, not decrease it
09:42:24 <fen> and at least its not *slower* than list. as some other ways were shown to be previously
09:42:40 <fen> (well, thta was for folding them, not unfolding them like here)
09:44:11 <fen> i wonder what C programers have that compares to these considerations....
09:44:22 <nshepperd1> Criterion repeatedly runs the test. It will get less repeats in before giving up if the test takes longer
09:45:05 <fen> no, running on length 1000 instead of 1000000 seems like its converging to 100% rubbish 
09:45:16 <fen> variance introduced by outliers: 91% (severely inflated)
09:46:10 <fen> the fact that small variations in running time are smaller compared to total running time probably outcompetes the consideration you mention
09:48:22 <nshepperd1> If you want to decrease the variance you should probably fiddle with whatever criterion option controls the number of repeats
09:48:48 <nshepperd1> Also, compile it with optimisations
09:49:07 <nshepperd1> Running benchmarks in ghci will give nonsense generally
09:56:50 <nshepperd1> (also, name your benchmarks properly. Having to scroll up to correlate "test4" to what that test actually measures is annoying >:)
10:18:28 <nshepperd> are cabal sandboxes going away?
10:18:43 <nshepperd> latest cabal is telling me to stop using 'cabal sandbox' :O
10:19:01 <__monty__> nshepperd: Maybe because they're redundant with new-*?
10:21:44 <nshepperd> alright, guess i'd better learn new-* 
10:25:23 <ski>   "val letlazy : (unit -> 'a) -> (unit -> 'a)  ... You see the magical function /letlazy/, which at first blush looks like an identity function. It takes a thunk and returns a thunk. When we force that thunk, we force the original one, /and/ remember the result. All further forcing return the same result. In functional-logic programming, this is called “call-time choice”."
10:25:31 <ski>   "In quantum mechanics, it is called “wavefunction collapse”. Before we observe a system, for example, a still spinning coin, there could indeed be several choices for the result. After we observed the system, all further observations give the same result."
10:25:37 <ski>   -- p. 44-45 of "Guess Lazily! Making a program guess, and guess well" (talk) by Oleg Kiselyov in 2012-09-25 at <http://okmij.org/ftp/kakuritu/logic-programming.html#StrangeLoop>
10:27:24 <ski> hmm, on p. 48, it talks about "mutation [as in ordinary laziness] affects all possible worlds","`letlazy' memoizes different results in different possible worlds","`letlazy' needs world-local memory","remember `fork ()' and Unix processes?","Non-deterministic laziness needs first-ckass memory"
10:28:04 <ski> that reminds me of how STM effectively uses thread-local memory inside of a transaction
10:30:16 <ski> monochrom : btw, your terms were "cavalier power" vs. "predictive power", right ? (just checking)
10:30:55 <ski> (i wanted to mention them the other day, but couldn't find any catchy quote in lambdabot)
10:53:18 <Ariakenom> sun's ZFS. now I have to question oleg's naming there
10:57:33 <ski> ok, that's what i thought initially
10:57:58 <ski> then i got confused when deltasquared talked about ZFS in relation to Oleg
10:59:08 <sm> hey all, a lens question. spreadsheet ^. sprProperties . spTitle doesn't type-check because the sprProperties lens gets a Maybe value. What's a right way to compose here ?
10:59:52 <sm> to get the title as a Maybe Text
11:03:41 <alanz> domenkozar, you can bring https://thestrangeloop.com/2018/tree-sitter---a-new-parsing-system-for-programming-tools.html into your hnix atom support
11:03:54 <alanz> for syntax highlighting etc
11:04:02 <lyxia> sm: sprProperties . _Just . spTitle ?
11:04:33 <lyxia> you'll have to use ^? because there may be Nothing
11:05:54 * hackage http2-client 0.8.0.2 - A native HTTP2 client library.  http://hackage.haskell.org/package/http2-client-0.8.0.2 (LucasDiCioccio)
11:09:18 <sm> lyxia: thanks!
11:11:20 * hackage servant-http2-client 0.1.0.2 - Generate HTTP2 clients from Servant API descriptions.  http://hackage.haskell.org/package/servant-http2-client-0.1.0.2 (LucasDiCioccio)
11:56:04 <ddellacosta> does anything like this exist somewhere (or is there a simpler way to formulate it that I'm missing)? https://gist.github.com/ddellacosta/85ddab8a506fa3eeddbc7b1c79877e8b
11:59:36 <int-e> > (S.Max False, [1]) <> (S.Max True, [2,3])
11:59:38 <lambdabot>  (Max {getMax = True},[1,2,3])
11:59:55 <int-e> ddellacosta: it's isomorphic to that one (modulo bottoms).
12:00:04 <ddellacosta> int-e: thanks! I had a feeling there was some way to encode this using tuples
12:00:29 <ddellacosta> where is Max, in Data.Monoid?
12:00:45 <ski> > Any False <> Any True
12:00:47 <lambdabot>  Any {getAny = True}
12:00:53 <ddellacosta> oh Semigroup
12:01:58 * hackage d10 0.1.1.0 - Digits 0-9  http://hackage.haskell.org/package/d10-0.1.1.0 (chris_martin)
12:04:57 <ddellacosta> I don't love having to extract the value out using `getMax` or whatever but I also don't like writing my own Semigroup instance so...
12:05:04 * ddellacosta wonders if DeriveVia could do this
12:18:35 <Ariakenom> ddellacosta: seems reasonable
12:24:21 <Taneb> Is it possible to have a constraint "Entails :: Constraint -> Constraint -> Constraint" that works like "Entails c d = forall x. c x => d x" without quantified constraints?
12:27:49 <ski> if `c' and `d' have kind `Constraint', then you can't say `c x' and `d x'
12:28:07 <ski> perhaps you meant `Entails :: (* -> Constraint) -> (* -> Constraint) -> Constraint' ?
12:30:06 <ski>   class Entails c f where entails :: forall x. c x => Dict (d x)  -- something like this ?
12:32:40 <ski> (or `entails :: forall x. c x :- d x', using `(:-)' from the `constraints' package)
12:48:09 <Taneb> ski: sorry, yeah, that was what I meant
13:04:12 <noan> decent fuction to generate random ByteString?
13:06:07 <indomitable> noan, pseudorandom*? I don't have an answer but precise questions help
13:06:17 <noan> cryptographically secure, sorry
13:06:34 <noan> and obviously, unless someone has some quit quantum realm shit going on I don't know about
13:07:43 <int-e> noan: http://hackage.haskell.org/package/entropy-0.4.1.3 maybe (looks maintained, but I just googled "urandom hackage" so there may be something better)
13:07:58 <indomitable> noan, take a look at https://hackage.haskell.org/package/cryptonite
13:08:17 <noan> indomitable, feels a bit overkill :/
13:08:28 <indomitable> presumably you can look at the source
13:08:32 <indomitable> and find a function for it
13:08:37 <indomitable> then shamelessly steal it
13:08:48 <indomitable> If you need "cryptographically secure", overkill is not a word I'd associate
13:09:02 <indomitable> almost nothing needs cryptographically secure generators
13:09:12 <noan> password salt
13:09:15 <indomitable> for the stuff that does, you definitely want something well made, lol
13:09:27 <indomitable> you can always take a webcam image of a bunch of lava lamps
13:09:29 <indomitable> hash that somehow
13:09:29 <indomitable> ;D
13:12:11 <int-e> indomitable: https://en.wikipedia.org/wiki/Lavarand ... hmm, I need to investigate the 2017 update
13:13:18 <indomitable> lol, there's a youtube video on it int-e 
13:13:21 <indomitable> obviously there are a lot of ways of doing this
13:13:24 <indomitable> that's just the flashiest one
13:13:47 <Ariakenom> There was some quantum usb hw for random. I think it was buggy though. But cool.
13:14:19 <Ariakenom> oh that was a link nevermind
13:14:36 <Ariakenom> no it was actual lavalamps :P
13:20:22 * hackage libmpd 0.9.0.9 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.9.0.9 (JoachimFasting)
13:23:08 <foojin> Does using Either as part of a zipper-like datatype look weird? It seems to be mostly used to signal errors, but it feels nice not to have to write `lefts` and `rights` analogues from Data.Either myself.
13:36:21 * hackage cuckoo-filter 0.1.0.0 - Pure and impure Cuckoo Filter  http://hackage.haskell.org/package/cuckoo-filter-0.1.0.0 (ChrisCoffey)
13:47:45 <consord> Hey haskellers, does anyone know if there is source code available for http://conal.net/papers/compiling-to-categories/ ?
13:48:07 <consord> I am very excited about experimenting with these ideas
13:48:28 <dmwit> foojin: There is nothing wrong with using Either as a sum type; that's what it's for.
13:49:14 <Ariakenom> consord: I just searched and didn't check but like this? https://github.com/jwiegley/categorical
13:50:25 <consord> I'm especially interested in the code to actually render the graphs
13:50:52 <consord> Conal said in his lecture that he used this method
13:51:48 <conal> consord: the github repo is linked on that page.
13:52:16 <conal> consord: have fun!
13:52:26 <consord> @conal Thank you!
13:52:26 <lambdabot> Unknown command, try @list
13:52:31 <conal> :)
13:55:15 <consord> I'm looking to see how to go about decoration of subgraphs for operational concerns - things like buffer sizes for streams, server instance constraints for distributed compute, etc.
13:59:32 <shafox> If one object has multiple projections in another set. I have several objects which has several sets of projections. I want to find the similarities between the projections how would I go about it ? 
14:17:55 <foojin> Why does Gen from QuickCheck need both a QCGen and an Int to produce a value? mkQCGen won't give me a QCGen without an Int anyway. Both of them seem to influence the result, but which one is the actual seed?
14:22:29 <foojin> BTW, I do know how to use QuickCheck, it's just that I was trying to see how refactoring an Arbitrary instance of mine affects the output on known seeds.
14:24:09 <jcob> Hey so hope you dont mind me popping in and asking a question right off the bat but
14:25:17 <jcob> have any of you guys used tagless final interpreters before? If so, how do you pass a value of one kind of one kind of tagless final interpreter to another
14:25:36 <jcob> I'm talking about an implementation  as in this post https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/
14:27:43 <jcob> Something like this https://hastebin.com/osuqijukuz.hs
14:28:11 <jcob> In this case, I can't figure out how to use the (StringInsertable b => b) parameter
14:29:08 <jcob> the goal of mine is to break down a big dsl into one that takes values of smaller dsls
14:33:12 <jcob> I know I just asked a question but I have to close my irc client.. be back in a second
14:34:14 <jcob> back :)
14:35:09 <jcob> aaaand I have to leave and come back again. Sorry if anyone was formulating a response to my question TT
14:40:15 <Solonarv_> I think you want some sort of "dup" interpreter, i.e. an analogue to `dup :: a -> (a,a); dup x = (x,x)`
14:40:34 <jcob> hmmm
14:40:53 <jcob> are you referring to my question? If you are, how that works goes over my head :x
14:41:24 <Solonarv_> I am, yes
14:41:43 <Solonarv_> I can't explain further though, because I'm not very well-versed when it comes to tagless final
14:42:01 <jcob> Okay. Did you get this idea from a paper/resource somewhere?
14:43:51 <Solonarv_> I most recently saw it in this paper: http://web.eecs.umich.edu/~cpeikert/pubs/alchemy.pdf
14:44:11 <Solonarv_> but I'd heard of it before
14:44:36 <jcob> Oh geez, now I'm going to have to wade through encryption language ;P jk, thank you very much
14:45:22 <Solonarv_> this stackoverflow question might help: https://stackoverflow.com/questions/51457533/typed-tagless-final-interpreters-what-is-the-use-of-duplicate
15:00:32 <noan> anyone used scotty much? I'm trying to figure out how to run a state monad over scotty. Namely I have a CryptoRandomGen I need to use inside its context
15:01:49 <zachk> noan, just pass the state as a variable into your functions and recurse when you update it? 
15:02:29 <noan> but that would start at the same ground state for each scotty request.
15:02:51 <zachk> oh
15:03:59 <zachk> maybe a global TVar or MVar created using unsafePerformIO and NoInline...probably not the best solution 
15:05:47 <noan> nah, if I was doing that I'd do the update inside of http://hackage.haskell.org/package/scotty-0.11.2/docs/Web-Scotty-Trans.html#v:scottyT
15:07:00 <fvr> Does join point optimisation not work for monadic streams?
15:20:08 <haasn> I wonder if anybody would be opposed to extending .lhs to allow ```haskell and ``` to serve as code terminators
15:20:33 <haasn> markdown seems popular enough that this could be justified
15:23:57 <__monty__> haasn: There's opposition against integrating markdown into haddock, and with good reasons. I think they might extend to .lhs
15:24:26 <fen> how can a difference list be made from a tree?
15:24:43 <lyxia> fen: can you be more specific
15:24:51 * hackage ansi-terminal 0.8.2 - Simple ANSI terminal support, with Windows compatibility  http://hackage.haskell.org/package/ansi-terminal-0.8.2 (mpilgrem)
15:24:54 <geekosaur> they don't; with hadock its ambiguity, with .lhs that devolves onto the user btu doesnt' affect the compilers unlit
15:25:47 <fen> with a tree like; data Tree a = Branch (Tree a) (Tree a) | Stem (Tree a) | Leaf a
15:25:53 <fen> lyxia: how so?
15:25:56 <__monty__> geekosaur: I was thinking about haddock in literate haskell files but maybe that's not a problem?
15:26:14 <haasn> I didn't realize haddock was allowed in literate haskell files
15:26:24 <geekosaur> haddock issues are unaffected by this
15:26:27 <geekosaur> and vice vrsa
15:28:01 <haasn> wouldn't haddock comments only get parsed for haskell comments *inside* the code block?
15:28:24 <__monty__> Is there anything that prevents writing .lhs files with markdown rn? Except for the indication of what is code.
15:30:22 <fen> @let listDifference xs = case xs of (x:[]) -> [const [x]]; (x:xs) -> (x:) : listDifference xs
15:30:24 <geekosaur> no. and if the markdown variant supports > then you could theoretically use Bird tracksnow
15:30:28 <lambdabot>  Defined.
15:30:39 <fen> @let fromListDifference xs = foldr (.) id xs undefined
15:30:44 <lambdabot>  Defined.
15:30:50 <fen> > fromListDifference $ listDifference [1..10]
15:30:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:31:10 <fen> lyxia: thats how it can be done for list
15:31:57 <noan> zachk, found it, it's fairly easy to do with ReaderT
15:31:57 <__monty__> geekosaur: They're named after Bird?
15:32:25 <fen> but for the Tree type above its hard to see how to use the constructors like how (:) was matched on and used to construct the difference list
15:32:28 <lyxia> fen: show an example of a tree and a difflist you want to get from it
15:32:58 <geekosaur> actually I don't know
15:33:30 <MarcelineVQ> bird tracks   :>>
15:34:25 <fen> ok
15:34:33 <fen> @let data Tree a = Branch (Tree a) (Tree a) | Stem (Tree a) | Leaf a deriving Show
15:34:35 <lambdabot>  .L.hs:450:23: error:
15:34:35 <lambdabot>      Ambiguous occurrence ‘Tree’
15:34:35 <lambdabot>      It could refer to either ‘Data.Tree.Tree’,
15:35:01 <fen> @let data StemTree a = Branch (StemTree a) (StemTree a) | Stem (StemTree a) | Leaf a deriving Show
15:35:06 <lambdabot>  Defined.
15:35:35 <fen> @let egTree = Branch (Stem (Leaf "hello")) (Branch (Stem (Stem (Leaf "difference"))) (Leaf "tree"))
15:35:37 <Solonarv_> you can already use markdown in .lhs : https://hackage.haskell.org/package/markdown-unlit
15:35:40 <lambdabot>  Defined.
15:35:46 <fen> > egTree
15:35:48 <lambdabot>  Branch (Stem (Leaf "hello")) (Branch (Stem (Stem (Leaf "difference"))) (Leaf...
15:35:51 * hackage windns 0.1.0.1 - Domain Name Service (DNS) lookup via the <windns.h>/dnsapi.dll standard library  http://hackage.haskell.org/package/windns-0.1.0.1 (HerbertValerioRiedel)
15:35:53 <fen> hmm
15:36:07 <fen> then how to make the difference list?
15:37:09 <fen> lyxia: thats the question though...
15:37:29 <glguy> fen: Yes, the question for you is, what do you think a difference list on trees means
15:37:42 <glguy> once that's established then people can explore how to implement it
15:38:14 <fen> um, like kind of the same as it does for list? like, with constructors partially applied to values in a list
15:38:43 <glguy> A tree doesn't have a distinguished "end" like a list does, so it's not a straight forward translation
15:39:20 <glguy> You could decide that a difference list picks a particular point in the tree to be that distinguished place that the next tree should be inserted
15:39:21 <fen> oh ok, can it be ordered so that the sentence "hello difference tree" are visited in order of each word
15:39:59 <fen> glguy: the example with NonEmpty seems relevant to that, it should not need an empty constructor
15:40:43 <glguy> Can what be ordered?
15:41:14 <fen> glguy: it should have the property that the difference list when folded and applied to undefined would recover the original tree
15:41:31 <glguy> undefined doesn't feature in difference lists as an identity
15:41:37 <fen> so it should be able to identify the "last" Leaf
15:42:19 <fen> hmm, well it was a good way to get round the fact that NonEmpty does not have an empty constructor
15:42:49 <glguy> Not really, that's an indication that the encoding was wrong
15:43:05 <fen> here was the latest benchmark that implements that idea for NonEmpty and is as fast as for list; https://bpaste.net/show/2fb4862ec838
15:44:23 <fen> but how else would all the values end up in a difference list and still have something to apply the folded list to?
15:44:58 <fen> its ok for the resulting `[a] -> [a]' of a difference list of list differences, as this can be applied to []
15:45:26 <fen> but for a difference list of NonEmpty, there is no such value, and undefined works fine so long as the last element uses const, like in the paste
15:46:39 <Solonarv_> aaah, I *was* wondering why the undefined wasn't bubbling up
15:47:06 <fen> so for the tree, thats why it should have some kind of way to tell if its the "last" Leaf
15:47:21 * hackage resolv 0.1.1.2 - Domain Name Service (DNS) lookup via the libresolv standard library routines  http://hackage.haskell.org/package/resolv-0.1.1.2 (HerbertValerioRiedel)
15:47:29 <fen> and it does not matter then that it does not have an empty constructor 
15:47:36 * ski isn't sure why one'd want `const' at the end ..
15:48:01 <fen> ski: to remove the undefined
15:49:19 <fen> for lists it matched the last element like; (x:[]) -> [const [x]]
15:49:32 <ski> but why do you pass in an `undefined', to begin with ?
15:49:59 <fen> so that for containers without an empty constructor, that there is something to apply the folded difference list to
15:50:20 <fen> e.g. (f::(NonEmpty a -> NonEmpty a)) undefined
15:50:21 <ski> why not `x:[] -> (x:)', and then pass in `[]' instead of `undefined' ?
15:50:27 <ski> unless i'm missing something ?
15:50:48 <fen> because thats only an option because list has an "empty constructor" which takes no values, namely []
15:50:48 <ski> hmm
15:51:29 <fen> [] is a polymorphic value, as is undefined
15:51:30 <ski> i thought you converted `NonEmpty a' to `[[a] -> [a]]', not to `[NonEmpty a -> NonEmpty a]'
15:52:00 <fen> @let data NonEmpty a = a :| NonEmpty a | End a
15:52:00 <lambdabot>  .L.hs:458:24: error:
15:52:01 <lambdabot>      Ambiguous occurrence ‘NonEmpty’
15:52:01 <lambdabot>      It could refer to either ‘Data.List.NonEmpty.NonEmpty’,
15:52:18 <fen> @let data NonEmpty2 a = a :| NonEmpty2 a | End a
15:52:22 <lambdabot>  Defined.
15:53:45 <fen> @let type Differences f a = [f a -> f a]
15:53:49 <lambdabot>  Defined.
15:54:02 <fen> @let nonEmptyDifferences2 xs = case xs of (End x) -> [const (End x)]; (x:|xs) -> (x:|) : nonEmptyDifferences2 xs :: NonEmpty2 a -> Differences NonEmpty2 a
15:54:03 <lambdabot>  .L.hs:481:12: error:
15:54:03 <lambdabot>      Ambiguous occurrence ‘:|’
15:54:03 <lambdabot>      It could refer to either ‘Data.List.NonEmpty.:|’,
15:54:37 <fen> @let data NonEmpty2 a = a :|| NonEmpty2 a | End a
15:54:38 <lambdabot>  .L.hs:463:1: error:
15:54:38 <lambdabot>      Multiple declarations of ‘NonEmpty2’
15:54:38 <lambdabot>      Declared at: .L.hs:458:1
15:54:49 <fen> ffs, this isnt going to work
15:54:57 <fen> its in the paste anyway
15:55:51 <Solonarv_> speaking of which, is there a reason you're using that paste site? it doesn't even have syntax highlighting, which makes it a bit hard to read
15:56:19 <fen> no ads?
15:58:01 <ski> @let nonEmptyDifferences2 :: NonEmpty2 a -> Differences NonEmpty2 a; nonEmptyDifferences2 xs = case xs of End x -> [const (End x)]; x L.:| xs -> (x L.:|) : nonEmptyDifferences2 xs
15:58:05 <lambdabot>  Defined.
15:58:37 <Solonarv_> ...actually it does have syntax highlighting, you just didn't set it to haskell
16:00:32 <fen> > fromListDifference $ nonEmptyDifferences2 (0:|1:|2:|End 3)
16:00:35 <lambdabot>  error:
16:00:35 <lambdabot>      Ambiguous occurrence ‘:|’
16:00:35 <lambdabot>      It could refer to either ‘Data.List.NonEmpty.:|’,
16:00:54 <fen> > fromListDifference $ nonEmptyDifferences2 (0 L.:|1 L.:|2 L.:|End 3)
16:00:56 <lambdabot>  error:
16:00:56 <lambdabot>      • No instance for (Show
16:00:56 <lambdabot>                           (NonEmpty2 (NonEmpty2 (NonEmpty2 Integer))))
16:01:12 <fen> no
16:02:24 <MarcelineVQ> need to derive Show on your datatypes to print them
16:02:55 <Solonarv_> at least you don't have to re-define it - you can just deriving instance .... (StandaloneDeriving)
16:03:40 <fen> > derive instance Show NonEmpty 
16:03:43 <lambdabot>  <hint>:1:8: error: parse error on input ‘instance’
16:03:53 <fen> > deriving instance Show NonEmpty 
16:03:55 <lambdabot>  <hint>:1:1: error: parse error on input ‘deriving’
16:03:58 <fen> ...
16:04:08 <fen> i dont know how to do that
16:04:28 <fen> at this point its easiest just to make a neat paste with all syntax highlighting e.t.c.
16:04:32 <MarcelineVQ> so look it up :>  you can try that stuff in ghci or /query lambdabot to see if they work ahead of time
16:04:54 <fen> its not the best way to use lambdabot for this example
16:05:02 <Solonarv_> @let deriving instance Show a => Show (NonEmpty2 a)
16:05:06 <lambdabot>  Defined.
16:05:11 <Solonarv_> ^ there you go
16:05:20 <MarcelineVQ> you can use yahb if you want to avoid the crufty stuff lambdabot is stuck with
16:05:23 <MarcelineVQ> % :q
16:05:23 <yahb> MarcelineVQ: 
16:05:45 <Solonarv_> the "> " syntax expects an expression, definitions start with "@let" or "?let"
16:05:59 <Solonarv_> yahb is just "% " and then whatever you'd type into GHCi
16:11:26 <fen> https://bpaste.net/show/cf477fade7fd
16:12:06 <fen> > fromListDifference $ nonEmptyDifferences2 (0 L.:|1 L.:|2 L.:|End 3)
16:12:08 <lambdabot>  error:
16:12:08 <lambdabot>      • No instance for (Num (NonEmpty2 (NonEmpty2 Integer)))
16:12:09 <lambdabot>          arising from a use of ‘e_120123’
16:12:24 <fen> no
16:13:10 <fen> its just making everything untidy 
16:13:12 <ski> > fromListDifference (nonEmptyDifferences2 (0 L.:| (1 L.:| (2 L.:| End 3))))
16:13:15 <lambdabot>  0 :| (1 :| (2 :| End 3))
16:13:28 <ski> you forgot to declare `:|' `infixr'
16:14:08 <fen> anyway! thats how to make a difference list for NonEmpty
16:14:18 <fen> but what about that StemTree ?
16:16:37 <fen> (not the only way, just the most performant way)
16:37:11 <ruffy_> Whats the best way in Haskell to partition a list into n partitions? e.g.: having [1,2,3,4,5,6,7,8,9,10] I want to partition it into [[1,2,3], [4,5,6], [7,8,9,10]] or e.g. [1..11] into [[1,2,3], [4,5,6,7], [8,9,10,11]]
16:37:34 <ruffy_> If i set 3 as the number of partitions
16:37:54 <Axman6> when should be the result with [1..]?
16:37:58 <rotaerk> have you hoogled Int -> [a] -> [[a]]
16:39:00 <ruffy_> Axman6: What do you mean?
16:39:04 <ruffy_> rotaerk: yes
16:39:16 <Axman6> what result do you expect when you run foo 3 [1..]?
16:39:36 <domenkozar> alanz: nice!
16:41:19 <ruffy_> Axman6: hmmmm havent thought about that
16:41:24 <Axman6> ruffy_: also what should happen with foo 3 [1,2]?
16:41:49 <fen> :t chunksOf
16:41:51 <lambdabot> Int -> [e] -> [[e]]
16:41:58 <ruffy_> the number of elems in the list must be bigger than the partition
16:42:07 <Axman6> fen: that works if you know the chunk size
16:42:13 <rotaerk> really gotta think about the corner cases and figure out a consistent logic for them
16:42:20 <ruffy_> fen: I dont want chunks with a specific length. I want a specific number of chunks
16:42:45 <fen> how do you determine those sizes?
16:42:50 <fen> that wont be a library function
16:42:54 <rotaerk> [1,2,3,4,5,6] -> [[1], [2], [3,4,5,6]]
16:43:01 <rotaerk> there's 3 chunks
16:43:01 <fen> as this is a user defined choice
16:43:11 <Solonarv_> @let foo n xs = chunksOf (length xs `div` n) xs -- inefficient and doesn't cover all corner cases, don't use this
16:43:12 <ruffy_> I understand
16:43:14 <fen> what api would be provided?
16:43:15 <lambdabot>  Defined.
16:43:19 <Solonarv_> > foo 3 [1..11]
16:43:22 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11]]
16:43:43 <Solonarv_> a-ha, almost! need to subtract 1 or something
16:44:03 <ruffy_> Solonarv_: Yeah thats almost what I want.
16:44:11 <fen> nonono, the way to determine the chunk sizes should be specified by the user
16:44:13 <Axman6> there's tricks you can play with dropping n elements at a time... there's a classic example of splitting a list in two lazily, let me see if I can remember it
16:44:32 <Solonarv_> here's a question: does it *have* to be for lists? it seems like Set might be a better fit
16:44:49 <ruffy_> fen: hmmmm
16:45:02 <ruffy_> Solonarv_: I need it for lists
16:45:18 <fen> :t splitPlaces
16:45:20 <lambdabot> Integral a => [a] -> [e] -> [[e]]
16:46:09 <fen> :t Data.List.Split 
16:46:11 <lambdabot> error:
16:46:11 <lambdabot>     Not in scope: data constructor ‘Data.List.Split’
16:46:11 <lambdabot>     Perhaps you meant one of these:
16:46:12 <drdo> Has there been any talk of ending implicit instance imports?
16:46:17 <fen> :t Data.List.Split.split
16:46:19 <lambdabot> Splitter a -> [a] -> [[a]]
16:46:58 <monochrom> No.
16:47:10 <geekosaur> only tot he extent of explaining why it won't happen
16:47:12 <Axman6> % let  f xs = go xs xs where go as [] = ([],as); go as [a] = ([],as); go (a:as) (_:_:bs) = case go as bs of (ys,zs) -> (a:ys,zs)
16:47:13 <yahb> Axman6: 
16:47:22 <Axman6> % f 1,2,3,4,5]
16:47:22 <yahb> Axman6: ; <interactive>:2:4: error: parse error on input `,'
16:47:25 <Solonarv_> drdo: not that I'm aware of, and since instances are supposed to be coherent it shouldn't be a problem
16:47:26 <Axman6> % f [1,2,3,4,5]
16:47:26 <yahb> Axman6: ([1,2],[3,4,5])
16:47:41 <drdo> Solonarv_: I think it's a problem for versioning reasons
16:47:44 <Solonarv_> importing an instance should never change the meaning of a program, only make programs compile that didn't before
16:47:47 <Axman6> fen: how does that look as a start?
16:47:57 <ruffy_> looks good
16:48:01 <drdo> Adding an instance to a module should really not be an API breaking change
16:48:03 <Axman6> actually, yeh, this can work
16:48:29 <ruffy_> I will try to figure something out on my own, thx for the help
16:48:39 <fen> np
16:48:53 <drdo> geekosaur: Care to point me in the direction of this sort of discussion?
16:49:16 <Axman6> instead of using a tuple, you return a list of n lists, and you just need a function which has the type: [a] -> [[a]] -> ([[a]],[a]) -- basically zipWith (:) but returns the remainder of the first list after zipping
16:49:54 <geekosaur> I don't have any on tap because it's the same discussion every month or so when someone is inconvenienced by the type system being consistent instead of convenient for what they want
16:50:01 <Axman6> argh, no, maybe not
16:50:51 <fen> :t chop
16:50:53 <lambdabot> ([a] -> (b, [a])) -> [a] -> [b]
16:51:26 <Solonarv_> geekosaur: maybe that's a reason you *should* have one on tap ;)
16:51:33 <drdo> geekosaur: I'm genuinely curious what the issues are
16:52:01 <Axman6> you could use a function with the type above to do a shuffle placing each element in a new list, but not to split into consequtive lists
16:52:35 <fen> could modify that to take another argument for the length `n' and use (\xs -> (take n xs,drop n xs))
16:53:36 <Axman6> ruffy_: do you understand how the function f above works? (also it probably needs to have the pattern match be ~(ys,zs) in the case statement because reasons)
16:54:51 <fen> @let chopn fn n f as = b : chopn fn (fn n) f as'   where (b, as') = f n as
16:54:54 <Axman6> I'm not really sure how to generalise it to more lists - the trick would be to drop n elements from the second list in each recursive call, and doing that makes determining the first and last list easy, but the middle ones not so much
16:54:55 <lambdabot>  Defined.
16:55:00 <fen> :t chopn
16:55:02 <lambdabot> (t1 -> t1) -> t1 -> (t1 -> t2 -> (a, t2)) -> t2 -> [a]
16:55:56 <Axman6> ruffy_: the simplest solution is probably to just stick the list in a Vector and then split that, and jope your lists are never too big =)
16:56:02 <Axman6> hope*
16:56:33 <fen> whats wrong with splitPlaces?
16:59:16 <lockestep> shameless plug https://anchpop.github.io/wise_mans_haskell/
16:59:22 <lockestep> it's a guide I wrote for beginner haskell developers - trying to be more helpful than LYAH. contains exercises, notes on stack configurations, testing with hspec and quickcheck, discussion of gdats and datakinds, and other nice things
17:06:34 <MarcelineVQ> nat
17:06:35 <MarcelineVQ> nat
17:06:38 <MarcelineVQ> gdi, neat
17:15:55 <sm> a script to fetch a google sheet as CSV, and some stack scripting notes: https://gist.github.com/simonmichael/cca05bac19499ba4ac7a70d1944647fe
17:19:11 <sm> if it doesn't work for you, I'd be glad to see the error(s)
18:01:21 <slack1256> Is there a way to do `cabal new-clean`?
18:23:40 <davean> slack1256: I mean exactly that?
18:23:52 <davean> davean@loento:~/projects/AlON$ cabal new-clean
18:23:54 <davean> davean@loento:~/projects/AlON$
18:23:58 <davean> maybe I don't understand the question?
18:29:38 <slack1256> `cabal new-clean` doesn't exist, but `cabal clean` does. I was thinking there must be a way to clean build artifacts on the "new-*" style commands.
18:29:47 <davean> YOu must be on an old cabal install - update
18:30:34 <slack1256> Mmmmm cabal-install v2.2, what version are you on?
18:30:45 <davean> 2.5.0.0
18:30:50 <davean> It should be in 2.4.0.0 though
18:31:22 <davean> just cabal new-install cabal-install?
18:34:30 <slack1256> I am on nixos. Plus the environment for yi-editor is still on ghc802, that explains the old cabal.
18:34:43 <delYsid> Hmm, should "observeAll (empty <|> pure 1) == (empty <|> pure 1)" be True?
18:35:17 <delYsid> Cos I am looking at a LogicT impl where it isn't.
18:36:28 <slack1256> Thanks davean
18:37:11 <davean> delYsid: Well, <|> is Alternative, and all the results of those are the same ... what leads you to want it not to be true? what consistent rules allow that?
18:39:45 <delYsid> davean: I actually think it should be true, but it isn't.  So either I am seeing a bug, or I am misunderstanding the similarity between Logic and [].
18:41:48 <davean> Prelude Control.Monad.Logic Control.Applicative> observeAll (empty <|> pure 1) == (empty <|> pure 1)
18:41:50 <davean> True
18:41:52 <davean> so, uh
18:42:22 <delYsid> ok, thanks.
18:43:13 <davean> Maybe there is more going on in your program
18:43:14 <delYsid> Logic.Reflection from ekmett/guanxi gives False.
18:43:56 <delYsid> I was just playing with the code, and this popped up while experimenting.
18:51:59 <KAT> Wіtһ o∪r IᏒC aԁ ѕеr∨ice yoᥙ caᥒ reaсh a ɡⅼobɑl ɑᥙdienⅽe of еntrepreneurs and feᥒtaᥒyl aԁԁісtѕ wіth ехtraorԁіnary еᥒɡagemᥱᥒt ratᥱs! https︓／/wіlliɑⅿрitcock．com/
18:54:16 <Squarism> im using test-framework + hunit. I want to move to hspec. Now i wonder if i should adopt my hunit tests or test-framwork (adapts the hunit tests) to be part of my new hspec suite. Any hints?
19:04:49 <mobile_c> i keep getting lost ;-;
19:08:32 <smutans> \tools
19:21:51 * hackage cuckoo-filter 0.1.0.1 - Pure and impure Cuckoo Filter  http://hackage.haskell.org/package/cuckoo-filter-0.1.0.1 (ChrisCoffey)
19:23:55 <cemerick> is it right that using `where` in an expression context is disallowed, e.g. on the RHS of an `if` arm or in `case` results?
19:27:04 <slack1256> Yes
19:30:14 <slack1256> `where` is basically a `let` that is valid across guard (|) branches.
19:31:04 <geekosaur> cemerick, where is part of a declaration, not an expression
19:32:00 <cemerick> sure; I had previously thought it was just sugar over `let`, but that's obviously not the case
19:32:01 <dmwit> "in an `if` arm" is correct, but `case` is a binding location and can have where blocks attached.
19:33:09 <dmwit> > case True of { False -> y where { y = 3 }; True -> y where { y = 4 } }
19:33:12 <lambdabot>  4
19:34:19 <slack1256> TIL
19:36:51 <cemerick> dmwit: given that, I guess multiwayif expressions don't desugar to `case`, as suggested by the docs
19:38:05 <geekosaur> they do, b he stingin the tail is they desugar to guards, and where scpes over guards
19:38:16 <geekosaur> so a multiwayif gets *one* where, not one per guard
19:38:40 <cemerick> huh
19:38:47 * dmwit sometimes wonders if geekosaur IRCs by mobile phone
19:39:26 <cemerick> > 4
19:39:26 <koz_> dmwit: I've tried that, for about 5 minutes.
19:39:28 <lambdabot>  4
19:39:29 <koz_> Never again.
19:39:36 * cemerick just testing
19:39:36 <dmwit> Yes, it's a horrible experience. Read-only.
19:39:51 <cemerick> so then....
19:39:58 <cemerick> > f a = [b * 3 where b = a + 1]
19:40:00 <lambdabot>  <hint>:1:5: error:
19:40:01 <lambdabot>      parse error on input ‘=’
19:40:01 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
19:40:15 <dmwit> > f a = [b * 3] where b = a + 1
19:40:17 <lambdabot>  <hint>:1:5: error:
19:40:17 <lambdabot>      parse error on input ‘=’
19:40:18 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
19:40:25 <dmwit> hah, right
19:40:29 <dmwit> > let f a = [b * 3] where b = a + 1 in f 7
19:40:32 <lambdabot>  [24]
19:40:49 <dmwit> The where is attached to the =.
19:41:09 <cemerick> whoa, I didn't expect that at all
19:41:11 <MarcelineVQ> iow
19:41:15 <MarcelineVQ> @let ef a = [b * 3] where b = a + 1
19:41:16 <lambdabot>  Defined.
19:42:04 <MarcelineVQ> since lambdabot isn't quite ghci
20:46:49 <dycan> Hi all, cabal&stack newbie here. I try to build-depends on a package, and when `stack build`, I got: collect2: error: ld returned 1 exit status     `cc' failed in phase `Linker'. (Exit code: 1) . What does that mean? (Here is my configration files and error msg: https://gist.github.com/bb7afc5f2551b52a2dabfe93080a0945)
20:53:04 <monochrom> Out of memory?
20:54:34 <geekosaur> error 1 is usually missing symbols or library not found. stack should be able to give you a log file somewhere
20:55:50 * hackage d10 0.2.0.1 - Digits 0-9  http://hackage.haskell.org/package/d10-0.2.0.1 (chris_martin)
20:57:07 <MarcelineVQ> but what is d10, for :O
20:58:39 <dmwit> great question
21:01:19 <dycan> geekosaur: Error msg told me that it happens when "Preprocessing executable 'Example-SimpleClient' for project-m36-0.5.1.." ...
21:02:48 <geekosaur> no, it's past that, it prerocessed, built modules, ten tried to lik them. and stowed the actual output from the linker that says what went wrong in a logfile somewhere
21:08:11 <dycan> geekosaur: okay, now I `stack build -v --dump-logs` to see if it gives more info..thx for the heads-up!
21:17:01 <dycan> Stll, it happens when "Linking .stack-work/dist/x86_64-linux-nix/Cabal-2.0.1.0/build/Example-SimpleClient/Example-SimpleClient " No more info.  Something happen similarily before and it just need to add a module to exposed-module field. But I can't see what need to be added this time.
21:18:50 <dycan> monochrom: It doesn't feel interrupted by limited memory...but thx!
21:20:17 <geekosaur> normally that one shows as "Killed" or "ExitFailure 9" or etc.
21:24:16 <dycan> geekosaur: Thx, lesson learned!     Now I `stack build` the original package to see if it happens when compiling it alone....   I love haskell when there are only pure functions....:p
21:33:55 * hackage d10 0.2.1.0 - Digits 0-9  http://hackage.haskell.org/package/d10-0.2.1.0 (chris_martin)
21:44:29 <emmanuel_erc> hello there 
21:45:38 <emmanuel_erc> Is it reasonable to consider some abstract mechanism (or concept) for modifying ASTs without need for writing out the explicit recursion?
21:47:43 <dmwit> The search term you are looking for is "generic programming".
21:48:00 <ski> emmanuel_erc : perhaps check SYB, Compos, biplate, multiplate, "polytypic programming" ?
21:48:51 <Solonarv_> also, recursion schemes
21:48:52 <emmanuel_erc> hmm interesting
21:49:26 <emmanuel_erc> because it seems to me that you would need somethin more specific than what functor, applicative, monad already give you
21:49:39 <emmanuel_erc> At least as far as I can tell.
21:50:00 <emmanuel_erc> I'll look those terms up
21:51:42 <ski> @wiki Applications and libraries/Generic programming
21:51:42 <lambdabot> https://wiki.haskell.org/Applications_and_libraries/Generic_programming
21:51:53 <ski> @wiki Applications and libraries/Generic programming/SyB
21:51:53 <lambdabot> https://wiki.haskell.org/Applications_and_libraries/Generic_programming/SyB
21:52:12 <ski> @wiki Scrap your boilerplate
21:52:12 <lambdabot> https://wiki.haskell.org/Scrap_your_boilerplate
21:52:26 <ski> @wiki Multiplate
21:52:26 <lambdabot> https://wiki.haskell.org/Multiplate
21:52:29 <dycan> I compiled successfully when I treat it as a local package to depend on. So something went wrong when I depend it on hackage. Maybe it's because I am using nixos and it need to add zlib things to local stack.yaml.
21:53:00 <ski> @hackage multiplate
21:53:00 <lambdabot> http://hackage.haskell.org/package/multiplate
21:54:24 <dycan> geekosaur: I found a workaround now. Thank you for the support!
21:54:43 <ski> <https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Plated.html>
21:55:20 <ski> @wiki Uniplate
21:55:21 <lambdabot> https://wiki.haskell.org/Uniplate
21:55:40 <ski> @hackage uniplate
21:55:40 <lambdabot> http://hackage.haskell.org/package/uniplate
21:56:14 <ski> <https://github.com/ndmitchell/uniplate>,<https://ndmitchell.com/#uniplate_09_oct_2013>
21:57:08 <ski> "A pattern for almost compositional functions" by Björn Bringert,Aarne Ranta in 2008 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.233.3357>
21:58:28 <ski> <http://community.haskell.org/~ndm/uniplate/>
21:59:54 <ski> <http://www.cse.chalmers.se/~patrikj/poly/>
22:00:30 <ski> @hackage recursion-schemes
22:00:30 <lambdabot> http://hackage.haskell.org/package/recursion-schemes
22:01:59 <ski> also "Algebra of Programming" by Richard Bird,Oege de Moor in 1996 at <https://www.cs.ox.ac.uk/publications/books/algebra/>,<http://lambda-the-ultimate.org/node/1117>,<http://wiki.c2.com/?AlgebraOfProgramming>,<https://www.goodreads.com/book/show/2727190-algebra-of-programming>,&c. is a bit related to the last one
22:03:23 <ski> @hackage syb
22:03:23 <lambdabot> http://hackage.haskell.org/package/syb
22:03:26 <MarcelineVQ> Given too many options the typical human ends up choosing none of them. If you reccomend any single one of these over the others it'd be the best reccomendation due to that alone :>
22:06:01 <Solonarv_> you have a point, but I don't think we know enough about the use case to make a concrete recommendation (at least I don't)
22:06:11 <rotaerk> is the "bananas, lenses and barbed wire" in that recursion schemes package a joke
22:06:13 <rotaerk> or is that a real thing
22:06:26 <MarcelineVQ> rotaerk: that's the name of a good paper
22:06:30 <Solonarv_> probably both tbh
22:06:36 <rotaerk> doesn't turn up via web search
22:06:52 <Solonarv_> i.e. it's the name of the paper, but the paper was named that way for joke-ish reasons
22:06:57 <MarcelineVQ> it's the first hit on my end <_<
22:07:08 <MarcelineVQ> https://www.google.com/search?q=bananas%2C%20lenses%20and%20barbed%20wire
22:07:45 <rotaerk> I included "generalized" in my search
22:07:59 <rotaerk> since that's part of the title according to the package
22:08:23 <rotaerk> oh, guess google finds it if I do that, but duckduckgo doesn't
22:09:48 <MarcelineVQ> You're right though, the title is a little different. edwardk: Is "Generalized bananas, lenses and barbed wire" also "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire" ?
22:09:55 <dmwit> Bananas, Lenses, and Barbed Wire ought to be the go-to paper for pointing out that avoiding technical names for things doesn't help comprehension at all.
22:13:21 <rotaerk> hmm that paper looks way over my head
22:14:05 <MarcelineVQ> They're all over someone's head at some point, reading it now when you don't get much will help you get it when you read it again later
22:17:30 <emmanuel_erc> I am just trying some simple things out (deriving mathematical expressions) in my use case.
22:18:02 <emmanuel_erc> So, yea. That was a lot of information at once. But I think I'm at a place where I can begin to understand this stuff.
22:20:40 <emmanuel_erc> I know that probably is not very exciting
22:20:48 <MarcelineVQ> It's exciting
22:22:31 <emmanuel_erc> Well that's cool that you think that.
22:26:06 <emmanuel_erc> the derivation is generally straightforward, as long as the allowable expressions are kept to a certain "category". The simplificiation was getting a bit hairy, and I figured there has to be a way I can do this without having to write out the recursion. Seems like this is old hat to the Haskell community (which is great for me).
22:27:31 <Solonarv_> aaah, expressions? that's a recursive data type, sounds like a good fit for recursion-schemes
22:48:25 <ski> @where generics
22:48:25 <lambdabot> `SYB',`Compos',`uniplate',`multiplate',`Plated',`Stratego',`Strafunski',`recursion-schemes',`polytypic',`GenericHaskell',<https://www.haskell.org/haskellwiki/Research_papers/Generics>,<https://wiki.
22:48:25 <lambdabot> haskell.org/Applications_and_libraries/Generic_programming>
22:51:30 <ski> emmanuel_erc : perhaps see <http://community.haskell.org/~ndm/darcs/uniplate/uniplate.htm> to begin with, and see what you think
22:52:26 <ski> (`recursion-schemes' is also worth looking at, at some point, to learn at least what a catamorphism, and what an anamorphism, is)
22:52:48 * ski isn't really fond of SYB
22:57:22 <julianleviston> the scrap your boilerplate paper is much easier to read than the bananas one, tho
22:58:41 <julianleviston> bananas’  general syntax is old (it’s not Haskell it’s an using a now archaic defunct language), and so makes it quite difficult to approach unless one is used to blurring ones eyes and just trying to get the gist of it.
23:01:15 <julianleviston> tho I really like the idiom-bracket style approach, I have to say.
23:11:13 * ski isn't really happy with idiom-bracket
23:13:21 * hackage servant-kotlin 0.1.1.3 - Automatically derive Kotlin class to query servant webservices  http://hackage.haskell.org/package/servant-kotlin-0.1.1.3 (matsubara0507)
23:15:27 <julianleviston> yeah me neither
23:17:05 <julianleviston> I mean the approach of using some piece of syntax to illustrate an abstraction that lets us compare the differnet recursion schemes as contexts, separately from the content of the recursion.
23:17:28 <julianleviston> basically, saying that I like the appraoch of making a calculus to talk about them.
23:25:44 * ski just checked who he explained the basics of reflective syntax to, the other day .. not julianleviston, apparently
23:32:30 * hackage axel 0.0.7 - The Axel programming language.  http://hackage.haskell.org/package/axel-0.0.7 (jgrosso256)
23:39:21 <MarcelineVQ> ski: your last idiomconvo was with hyperisco
23:41:20 <BartAdv> Eh, seems I'm too stupid to grasp the need for Unrestricted in linear types proposal. I thought I get it after watching SPJ talk, but now I'm looking at the MArray API from the proposal paper and I just don't get it :(. Throughout the Api, MArray is used only linearly. Great. But read, for example, returns pair, and I don't understand where the restriction that this pair is linear as well (and thus need for Unrestricted) comes
23:41:20 <BartAdv> from
23:50:03 <MarcelineVQ> Which talk is that BartAdv?
23:50:22 <julianleviston> https://www.youtube.com/watch?v=t0mhvd3-60Y
23:51:57 <BartAdv> Hm, maybe I get it. newMArray returns b, there's no restriction on how many times we consume b, but we have to assure value returned from continuation is consumed once, is that right?
23:53:23 <BartAdv> If continuation would return b as well, then consuming result of newMArray would mean consuming the result of continuation, which could be from linear MArray... 
