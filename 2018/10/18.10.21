00:03:10 <Mrbuck> Hi can someone join offtopic channel please I asked some question there
00:03:45 <[exa]> maybe they were too offtopic even for offtopic?
00:03:57 <Mrbuck> no
00:04:04 <Mrbuck> it is related to programming
00:04:47 <chessandgo> I've heard that since unit is the only value of type Unit, all usages of it actually are just pointing to the same one, to save memory
00:04:57 <[exa]> Mrbuck: you'll need to repost that anyway because newjoiners aren't gonna see it... whats the problem anyway?
00:05:17 <chessandgo> is this true for sum types, do all Nothing :: Maybe a point to the same one
00:05:25 <chessandgo> and not take up excess space
00:05:29 <Mrbuck> [exa]:  Hi I have one Question I decided to learn Haskell after a Month  and for a Month I decided to improve my python skills through some Algorithm book...Now I feel along with python I should parallely do another imperative laguage which one is suggested ? I ca spend maximum 30 days only and later I will move to funtional programming
00:05:31 <[exa]> chessandgo: there's evaluated unit unit, and unevaluated unit-type thunk
00:05:54 <chessandgo> assuming they're all evaluted
00:06:14 <[exa]> chessandgo: which is 2 values in runtime. Evaluated unit is AFAIK a "plain zero" that doesn't have to point to anything
00:06:15 <chessandgo> [(),(),(),()] would that take up less space than 4 seperate instances of unit?
00:06:27 <kadoban> Mrbuck: I personally find rust interesting
00:06:45 <[exa]> chessandgo: list there is going to take up a lot of space
00:06:48 <Nizumzen> does anyone here run the official Haskell wiki? I'd like to ask if I could put something on it or not - I don't want to break any rules
00:07:06 <chessandgo> ignoring the overhead of the list, pretend its an array
00:07:11 <cocreature> Nizumzen: if it’s Haskell related, it’s probably fine :)
00:07:40 <Mrbuck> kadoban:  and I want to do it parallel to python means I have a python algorithm book and along with that I want to wrote snippet in another Language so rust is well suited imerative to follow along with python 
00:07:47 <chessandgo> I'm asking because I'm going to be using some large 3d arrays (using Vector) and many of the cells will be identicle values of a sum type
00:08:00 <[exa]> chessandgo: the point is that representation of () is smaller than pointer so there's no point in saving space by pointing to a single instance of it
00:08:09 <kadoban> Mrbuck: They're very little alike, python and rust. But if they were, what would be the point?
00:08:11 <Nizumzen> cocreature: it is about a business that will be in the Haskell sphere - I'm just not sure if commercial stuff is allowed
00:08:20 <[exa]> chessandgo: anyway if you do  let a=() in [a,a,a,a], you'll have that "sharing" done manually
00:08:37 <chessandgo> what if I did
00:09:00 <cocreature> Nizumzen: I don’t think you should use the wiki to promote a company but you could add it to https://wiki.haskell.org/Haskell_in_industry
00:09:11 <Mrbuck> kadoban:  if they are alike I dont have to spend to much time, because my ultimate goal is functional language and before that learn imperative languages along with algorithms to job secure
00:09:30 <chessandgo> data MyType = Value1 | Value2 | Value 3 | Value4                    let list = [Value1, Value1, Value1, Value1]
00:09:35 <Nizumzen> cocreature: yeah you are right - I'll leave it for now
00:09:45 <kadoban> Mrbuck: I'd just stick with python then
00:09:56 <[exa]> Mrbuck: programming experience is actually portable except for totally language-specific stuff
00:10:27 <BaneAliens> I'm trying to define this function r::[a]->[a]
00:10:28 <Mrbuck> kadoban:  python alone not adding value in my resume
00:10:38 <BaneAliens> anything else I can do besides the identity function and something like r a = a ++ a?
00:10:47 <[exa]> chessandgo: I assume you want to know the size of 'list'....it's very probably not even going to get allocated as a whole btw :]
00:10:50 <cocreature> having python on your resume is probably better than not having python on your resume
00:11:07 <Eduard_Munteanu> :t reverse -- BaneAliens 
00:11:08 <lambdabot> [a] -> [a]
00:11:09 <cocreature> BaneAliens: depends on what you mean by “something like”
00:11:09 <Mrbuck> [exa]:  ok so I try rust along with python ? I also heard rust is some functional 
00:11:25 <BaneAliens> oh good one Eduard_Munteanu!
00:11:30 <kadoban> BaneAliens: An infinite number of different variations, but yeah mostly of the form a ++ a or random nonsense.   r _ = []  would be an interesting one I guess
00:11:33 <MarcelineVQ> BaneAliens: At least two basic things, related to the constructors of list
00:11:36 <BaneAliens> I'm just going through an exercise from this haskell book
00:11:37 <[exa]> Mrbuck: it's not functional, just sometimes looks like it. But certainly a good experience because of the low-levelness
00:11:54 <cocreature> BaneAliens: basically you can rearrange, duplicate and remove elements but you can’t create any new elements
00:11:55 <chessandgo> [exa]: more or less im wondering, im going to use some 3d arrays, but many of the cells will have an empty value, should I assume that each cell will have a constant size regardless of value, or that the default values will have sharing
00:12:41 <Mrbuck> I though java and python should add more value but again java not low level language  c is very hard 
00:12:51 <[exa]> chessandgo: depends on what implementation of array you choose; I strongly suggest Data.Vector
00:13:06 <chessandgo> thats the one im currently using, it seems to be a good one
00:13:30 <chessandgo> (my only complaint is that I cant have length in the type, but thats a case for dependant types)
00:13:31 <Mrbuck> go is low level language ? go is very similar to python again when I do the go-lang tour
00:13:40 <cocreature> Mrbuck: I wouldn’t worry too much about what adds value to your resume. focus on what interests you and maybe look for the job requirements in that area
00:14:19 <[exa]> Mrbuck: lowlevel like less automated stuff and more closer to CPU. In your case I'd suggest just trying it out and you'll see
00:14:53 <kadoban> Go isn't particular low level, no.
00:15:00 <Mrbuck> cocreature:  My real intrest is Haskell, Racket (scheme) and the prolog  along with AI and ML but its hard to achive them soon ...so I nee to survive before with some day job where anything would be ok and evening I can learn 
00:15:02 <chessandgo> go has only recently gotten generics (parametric polymorphism), so take that how you wil
00:15:07 <[exa]> chessandgo: IIRC Vector is strict in data so there isn't gonna be the extra indirection
00:15:31 <chessandgo> [exa]: no thunks but still pointers?
00:15:37 <cocreature> Mrbuck: it depends on your requirements but if you’re willing to move, finding a Haskell job is definitely possible
00:15:41 <chessandgo> because there is boxed and unboxed version in the library
00:16:45 <chessandgo> what universe do I have to move to in order to get an irdis job?
00:17:24 <BaneAliens> cocreature: just do scala
00:17:33 <BaneAliens> even more job opportunities
00:17:37 <Mrbuck> cocreature:  sure but it eventually takes time I believe. So I want to be good at 2 imperative languages before 
00:17:39 <BaneAliens> and it's FP still
00:18:34 <cocreature> sure if you like scala, do scala
00:18:58 <cocreature> my point is, don’t spend too much time optimizing your resume
00:19:43 <chessandgo> you could always resign yourself to becoming a front end javascript programmer
00:19:47 <kadoban> At the very most, learn enough of the say 2 biggest languages in your area to put them on there and the rest just do whatever you want.
00:19:47 <chessandgo> they make a lot of money
00:20:21 <kadoban> JS isn't very high pay relatively, is it? Never seemed to be ... too many people coming out of coding bootcamps can do it well enough.
00:20:51 <BaneAliens> yea front-end usually get paid less in my experience
00:20:59 <BaneAliens> but who needs money
00:21:32 <dmj`> BaneAliens: I’ve seen js people make a ton, all about the business value of the application to a company, has nothing to do with poor the language is
00:21:44 <dmj`> how poor*
00:22:02 <chessandgo> you can make even more if you also have graphic design in combination to your web dev
00:22:06 <chessandgo> at least in what ive read
00:22:46 <dmj`> BaneAliens: java (android), objective-c (ios), javascript (web), are the highest human interfacing languages, maybe .net C# too
00:23:39 <kadoban> Yeah you can make a lot with any language, as far as I know, just I never noticed JS being particularly high on the scale intrinsicly.
00:24:43 <chessandgo> I've been learning kotlin, pretty nice if you have to interpolate with java
00:25:26 <BaneAliens> optimize for growth, $$$ comes later
00:25:33 <zfnmxt> Is there a function that is the same as (fmap . fmap)? (Or, maybe, (fmap . fmap . fmap ....))?
00:26:06 <jle`> some people have an alias for (fmap . fmap), but for me personally (fmap . fmap) is probably the most readable way to write it
00:27:09 <[exa]> chessandgo: Data.Vector.Unboxed fixes that for some types
00:27:15 <zfnmxt> Okay, thanks. Just checking to see if there was a more idiomatic way to do it. :) 
00:27:55 <[exa]> chessandgo: the boxed thing is quite opaque but there should be a reasonable description of how the box looks in runtime
00:28:08 <chessandgo> wouldnt I want boxed? as unboxed would mean that each item would have to take up a constant amount of space
00:28:19 <chessandgo> let ffmap = fmap .fmap
00:28:29 <chessandgo> its like sheet music, the more f's the better
00:28:49 <[exa]> chessandgo: your data is sparse?
00:28:55 <chessandgo> yes
00:29:13 <chessandgo> or atleast not consistantly sized
00:30:06 <[exa]> chessandgo: so you have something like data X = X1 SmallThing | X2 Big1 Big2 Big3 ?
00:30:33 <Mrbuck> rust cahnnel in mibbit no so friendly like #haskell :(
00:31:03 <chessandgo> [exa]: yes
00:31:21 <kadoban> Mrbuck: Why not on irc.mozilla.org ? That's the official one afaik
00:31:44 <Mrbuck> kadoban:  they are rude  
00:32:48 <[exa]> chessandgo: IIRC there's gonna be just pointer. If you want to have it both unboxed (avoid one indirection) and small, do something like X= X1 Small | X2 OneBoxedBoxOfBigThings
00:33:17 <Mrbuck> one last question  c VS rust in 2018 ?
00:33:41 <[exa]> chessandgo: anyway, if your data is _very_ sparse, I'd suggest going with non-arrays
00:34:00 <[exa]> Mrbuck: You can't be a good rust programmer without implicitly knowing C
00:34:00 <Mrbuck> I think c also similar to python and low level right ?
00:34:18 <chessandgo> [exa]: its semi sparce, when there is data, its next to each other, which is why I want the arrays
00:34:27 <Mrbuck> [exa]:  I see then starting with rust makes no sense I know only python 
00:34:28 <[exa]> and C is totally unlike python, except for "also being imperative"
00:34:47 <[exa]> chessandgo: intervals? :]
00:34:59 <chessandgo> [exa]: voxels
00:35:14 <[exa]> aaaaaaaah yes. Use octrees! :]
00:35:22 <chessandgo> really?
00:35:28 <chessandgo> Ive seen those recommended quite a lot
00:35:43 <chessandgo> but as far as I know, voxel engines just use plain onld 3d arrays
00:36:44 <[exa]> plain old 3D arrays will run out of space no matter how tiny you make the array elements. Octrees are both very good for representing "empty" space and for lots of other computation (like collisions, visibility, etc)
00:37:22 <chessandgo> seems that its decided then
00:37:26 <[exa]> it depends on how big your world will be though, if it's small it's probably best to just start with Vectors and abstract out the operations so that you can plug octrees in later
00:37:37 <[exa]> mantra: don't optimize before you've got a prototype
00:37:40 <chessandgo> I was afraid that octotrees nature would make moving stuff messy, as itd have to remake the tree
00:38:03 <[exa]> you usually don't remake the whole tree if the movement is local
00:38:20 <Mrbuck> [exa]:  I heard lua is similar to python in many way true ?
00:38:34 <chessandgo> hm, sounds good
00:38:58 <chessandgo> I was planning on enough data that I was going to build the world out of chunks (dont really see any way how you wouldnt do that)
00:38:59 <[exa]> chessandgo: also, it's quite natural to stop the octree expansion at some level and have the lowest levels as arrays, say, 16x16x16
00:39:48 <chessandgo> [exa]: use octotrees as the top level data structure?
00:39:51 <[exa]> Mrbuck: lua is extremely simple and embedding-oriented
00:40:03 <[exa]> chessandgo: that's the usual way to do that, yes.
00:40:06 <Mrbuck> and what ever it is learning c always helpful I belive now 
00:40:08 <chessandgo> I was planning on having chunks (16^3 for example, like you said) and just put them in  a map
00:40:28 <chessandgo> and then perhaps If space was killing me id have something like Maybe Chunk if it was just empty
00:40:43 <[exa]> chessandgo: that would also work, octrees are a bit better for better representing the 3d-space index
00:40:50 <Mrbuck> [exa]:  I do c and python alternatively first then along with solving many algorithms and problem in both languages
00:40:56 <chessandgo> yeah, I think ill go with octotrees
00:41:27 <MarcelineVQ> octotrees :D
00:41:37 <[exa]> chessandgo: like, the "neighborhood" is always a nice local neighborhood in octrees, not with linearly-ordered indexes though
00:42:12 <chessandgo> [exa]: I assume I should be able to abstract over that to get my nice X,Y,Z space though, right?
00:42:18 <MarcelineVQ> For when you want an undulating eldritch christmas
00:42:52 <[exa]> chessandgo: yeah, block-index is easily indexable in octree as well as in Map
00:43:26 <chessandgo> excellent
00:45:13 <chessandgo> [exa]: on the topic of datastructures, if pure languages, is there anyways to keep a "reference" to a value without IO
00:45:57 <chessandgo> I've having trouble with the fact that I want to pure data deep within my datastructure, but then I wont be able to find it again without traversing it each time
00:46:14 <chessandgo> put data deep*
00:47:50 <[exa]> chessandgo: you can always use zipper to have the locality benefits, but generally not
00:49:14 <chessandgo> I dont think that'd work as id have to be a zipper with multiple focus poitns
00:49:54 <[exa]> chessandgo: anyway, what would be the usecase?
00:49:55 <chessandgo> well thats a shame, the current method i've thought up requires a couple maps, and making sure to update them insync with each other
00:51:11 <chessandgo> [exa]: players within the voxel space. You need fast access to the player data, but I'd like the players to be directly in the datastructure so that a scan of the local area gets everything that can be seen
00:52:16 <[exa]> there's a way to hold the tree by multiple points functionally, but it starts to get pretty complicated
00:52:58 <[exa]> Finger trees are one such example (they are in Data.Sequence), very roughly it's zipper from both sides of the tree
00:53:11 <chessandgo> ohhh, nice
00:53:22 <chessandgo> ive been looking at bi direction map like structures 
00:53:27 <chessandgo> whats the ugly part?
00:53:36 <c_wraith> yeah, the finger tree paper pointed out that you could have as many fingers as you like - but it gets a lot more complex when you add more
00:53:54 <[exa]> it's complicated and you'll need to totally reinvent it for combination of players+octrees
00:54:34 <chessandgo> ah, thats a shame
00:54:56 <[exa]> it would make a brutally cool data structure library though :]
00:55:24 * [exa] adds that to student thesis topics
00:55:27 <oo_miguel> I need a Map, where each value contains an Array. I started with Map.Map and plain Lists. Now I migrated to BasicHashTable but it is still quite slow. I suppose this is because I reinsert the lista new elemet each time I have to add a new element to an Array. Any suggestions how to improve it?
00:55:46 <chessandgo> the method ive currently divised works with having a map of players to positions, then positions to players (or player like things)
00:56:01 <chessandgo> and you have to make sure to keep both maps in sync with each other
00:56:25 <[exa]> oo_miguel: if you're frequently modifying the things inside the lists/arrays, use Data.Sequence inside instead
00:56:59 <oo_miguel> [exa]: oh thanks I will have a look!
00:57:18 <[exa]> oo_miguel: how big's your data? (it's the most important thing to know before you run for optimization). Also, hash tables almost never help (even complicate the stuff in functional settings, imagine rewriting the hashtable on each update!)
00:57:19 <chessandgo> [exa]: on the topic of datastructes that dont exist as libraries in haskell, are datastructures usually implemented in haskell, or some other language and using the FFI 
00:58:22 <[exa]> chessandgo: AFAIK most of the containers package is in haskell. The only primitive is the GHC-ish Array
00:58:57 <chessandgo> wait really? I thought to get decent performance they were all in C under the hood
00:58:59 <[exa]> chessandgo: like, Data.Sequence is fingertree, Maps/Sets are also some kind of trees, Vector is a wrapped array, there's the functional queue somewhere, etc
00:59:31 <chessandgo> thought fingertrees would have to be implemented in some langauge with pointers
00:59:51 <[exa]> chessandgo: fun fact: data structure performance is 99% about cache behavior and 1% about what language you use to mess up the pointers
01:00:12 <oo_miguel> [exa]: I have ~100million small records which I wanted to group and make accessible but one non-unique integer each of them contains
01:00:20 <chessandgo> well, if you dont have pointers in the first place...
01:00:32 <chessandgo> although there is references in haskell, but those are always impure, right?
01:00:34 <oo_miguel> s/but/by
01:00:44 <[exa]> chessandgo: well there are implicit pointers everywhere.. :]
01:00:53 <chessandgo> we dont count those
01:01:06 <[exa]> these count for the performance concerns :]
01:01:22 <[exa]> oo_miguel: how large are the groups and what are they indexed by?
01:01:39 * chessandgo just wanted a good excuse to learn rust to have to implement a datastructure so he could use it in haskell
01:01:42 <MarcelineVQ> finger trees are a somewhat famously purely functional data structure, check out  https://en.wikipedia.org/wiki/Finger_tree  for all kinds of interesting notes
01:02:34 <oo_miguel> [exa]: They are indexed by an Int and I expect to be many records in few groups... (something like 5k groups)
01:03:14 <[exa]> chessandgo: well go for it :] but as I said, the rule for optimization success is to prototype first, polish later
01:03:53 <[exa]> oo_miguel: and you're doing the operation that you insert/erase a value somewhere in the middle of one group, right?
01:03:54 <chessandgo> perhaps I will implement that convoluted finger-octo-tree-comonad (but probably not)
01:04:03 <oo_miguel> [exa]: no
01:04:07 <MarcelineVQ> [exa]: Make it work, make it correct, make it fast :>
01:04:31 <chessandgo> harder, better, faster, stronger
01:04:53 <[exa]> MarcelineVQ: after which you can shred the design to pieces to get cache-efficient version which is 500 times faster
01:05:01 <oo_miguel> [exa]: but I now have something like: "insert hashtable key (value:list)"
01:05:12 <MarcelineVQ> Or use depedent types and do the first two at once, with an exchange of mental book-keeping and some sanity. Or do all three at once with correct by construction program synthetsis if you're okay with the santiy bargain and want to go darker.
01:05:13 <oo_miguel> which basically reinserts the complete list right?
01:05:44 <[exa]> oo_miguel: it certainly rewrites the hashtable, but the list should stay intact
01:05:59 <oo_miguel> [exa]: oh so maybe it won't get any faster :P
01:06:01 <chessandgo> yes, just implement the data structure inductively in Coq, thatll be much less work ;)
01:06:02 <bollu> davean you asked what prompted the question about Machines/Plans. I was reading through Machines, and I wanted to understand how "await" worked.
01:06:16 <[exa]> oo_miguel: can you try whether the slowness is worse when you have more hashtable elements or more list elements?
01:06:29 <MarcelineVQ> chessandgo: Right, exactly, https://www.cs.purdue.edu/homes/bendy/Fiat/FiatByteString.pdf
01:06:39 <oo_miguel> [exa]: allright, I Will do some benchmarking. thank you
01:06:45 * chessandgo squints at that link
01:06:54 <[exa]> chessandgo: anyway -- how big's your world going to be?
01:06:55 <chessandgo> if I open this, will an abyss open up
01:07:20 <MarcelineVQ> It's not just an abyss, it's a many-eyed grey hole of the angler.
01:07:45 <MarcelineVQ> No matter how deep you reach all you pull out is lint, but the glow keeps drawing you deeper.
01:08:00 <[exa]> chessandgo: the point is that octree depth is logarithmic, so having a single-zipper octree to make local operations quick will probably be fast enough if you e.g. don't process all the players at one time
01:08:04 <chessandgo> [exa]: so, so. depends, its not a game about building or anything like minecraft, but everything in the world is constructed out of voxels
01:08:39 <[exa]> chessandgo: so you'll have O(1)* ops_on_one_player + O(log n)*switches_between_players
01:08:50 <chessandgo> the alternative is making a proper 3d poly engine. Voxels seem much easier and work *enough* for what I want
01:09:06 <[exa]> which won't be very much if you process the players one-by-one as the usual games do
01:09:13 <[exa]> go for voxels, voxels are amazing
01:09:24 <chessandgo> they're sharp around the edges though
01:09:34 <[exa]> apply shaders
01:09:42 <chessandgo> no graphics
01:09:55 * [exa] raises eyebrow
01:10:12 <chessandgo> its a MUD, and im trying to break free of the limitations of room based world
01:10:57 <[exa]> yesss, digging? :D
01:11:01 <MarcelineVQ> Remake simant, everyone will love you and you can use voxels for the food and tunneling
01:11:27 <chessandgo> no, more like mechs and other moving objects
01:11:31 <chessandgo> turns out
01:11:32 <[exa]> I always wanted digging + rail transport simulator
01:11:42 <chessandgo> trying to have flying objects in a graph/room based mud
01:11:44 <chessandgo> doesnt really work
01:12:06 <MarcelineVQ> Red Faction: Heavy Gear?  :D
01:12:42 <[exa]> no, more like OpenTTD: GetTheCoalOut
01:12:47 <chessandgo> [exa]: im a noob at data structure analysis, what that *switches_between_players part?
01:12:58 <chessandgo> its event driven, so only one player processed at a time
01:13:26 <[exa]> chessandgo: how many octree operations near the player are going to be processed in this "one at a time"?
01:14:10 <chessandgo> [exa]: a decent amount
01:14:22 <[exa]> chessandgo: go with the single-zipper then, it will work
01:15:00 <chessandgo> if I was doing something quite heavy I was just going to focus on some chunks, do my thing, and reconstruct the world. time complexity shouldnt matter for that
01:16:17 <chessandgo> [exa]: wont I have to traverse my data structure every time I switch between players
01:18:32 <chessandgo> rethinking this, I think I can actually get around this with just a bidirectional map, but it may just be my tiredness
01:18:56 --- mode: glguy set +v [exa]_
01:19:32 <[exa]_> chessandgo: my other connection died, if you wrote something I didn't see it
01:20:03 <chessandgo> [exa]_:  wont I have to traverse my data structure every time I switch between players
01:20:11 <[exa]_> chessandgo: anyway, the point in zipper was that if you don't switch the player views often (which requires O(log n) ops) you will basically have around O(1) for each operation
01:20:42 <[exa]_> chessandgo: and O(log n) isn't a very big deal, the trees are in fact quite shallow even for very large worlds
01:21:25 <chessandgo> I think thats what my map solution ends up being anyways
01:21:46 <chessandgo> multiple levels of indirection that'll ultimately have to traverse X points to get into the chunks
01:21:52 <[exa]_> in your case, world of size 16384^3 will require max 20 ops to jump between players in extreme case
01:21:58 <chessandgo> its constant as the world is shallow
01:22:15 <chessandgo> thats quite a large world
01:22:37 <chessandgo> where did you get the number 16384?
01:23:04 <chessandgo> shouldnt that number be much smaller, assuming chunks of 16^3
01:23:26 <[exa]_> I wanted 10 levels for demonstration, which is 2^n = 1024 leaf chunks, times 16 because you've got 16x16x16 chunks
01:23:53 <chessandgo> thats a lot of blocks in anycase
01:24:16 <[exa]_> yeah, hopefully much of that will be sparse
01:24:33 <chessandgo> sparser is faster in the case of octotrees, right?
01:25:04 <[exa]_> not necessarily
01:25:30 <[exa]_> but in your case, the 16k^3 would fill 4TB of memory so you certainly want sparsity
01:26:06 <chessandgo> egad
01:26:32 <chessandgo> do you got a link to that octotree paper?
01:26:40 <chessandgo> fingertree I mean
01:26:56 <[exa]_> chessandgo: anyway the usual octree construction doesn't exploit sparsity but if you make "shortcut edges" you'll have much less levels for sparser data
01:27:18 <[exa]_> chessandgo: http://www.staff.city.ac.uk/~ross/papers/FingerTree.html
01:27:59 <chessandgo> shortcut edges?
01:29:36 <chessandgo> this is making me question how minecraft is able to work at all
01:29:41 <[exa]_> chessandgo: for example, if your octree system has 10 levels and you only have 1 datapoint, you would need to allocate 10 octree nodes with just one node to child. Shortcut edges encode this information in something like "yeah there's only one block here at X,Y,Z" in a single node
01:30:14 <chessandgo> ah, thats not standard octotree?
01:30:30 <[exa]_> not the "simplest" one :]
01:30:48 <[exa]_> this is also applicable to whole subbranches with that kind of deep nesting
01:31:09 <[exa]_> requires a bit of coding but works marvelously
01:32:37 <chessandgo> the problem gets deeper and deeper!
01:33:30 <chessandgo> is there something like a tree, except each node is doubly linked 
01:33:50 <[exa]_> The Usual Imperative Tree
01:34:05 <chessandgo> im thinking, using C or whatever, to make a datastructure where esentually two trees share leaf nodes
01:34:06 <[exa]_> if I got "doubly linked" right
01:34:35 <chessandgo> so the tree I want to access certain much fewer elements (players), I can traverse the other tree
01:34:51 <chessandgo> and then travel up the other tree if I need to do some mucking around with the structure
01:35:32 <[exa]_> oh, player index with pointers to data structure
01:36:07 <[exa]_> well that's PITA in functional programming, saving player positions and zipping there is probably the best thing you can do purely
01:36:54 <chessandgo> the arguement here is that doing it inpurely, writing a pure iterface to haskell, vs doing it completly purely in haskell
01:37:08 <chessandgo> wouldn't zipping have worst performance as well?
01:37:35 <[exa]> certainly not worsy but worse than finetuned C most probably
01:37:42 <[exa]> *worst
01:38:17 <[exa]> anyway, prototype first :]
01:38:22 <chessandgo> only slightly?
01:38:43 <[exa]> depends on how much steroids you put to the C implementation
01:39:20 <chessandgo> nothing special, just taking advantage of pointers, nothing more
01:39:30 <[exa]> also, pure-behaving datatypes need to do copy-on-write very efficiently, not sure if you can cope with that very well in C
01:39:35 <Mrbuck> [exa]:  I see from above discussions also c is mandatory language for every good programmer right
01:39:39 <chessandgo> welp, comonads/zippers it is I suppose!
01:40:51 <[exa]> Mrbuck: I don't really consider people who don't know C or some its equivalent as programmers :]
01:41:24 <cocreature> that seems extremely condescending
01:41:26 <kadoban> Mrbuck: C is completely unnecessary to be a programmer.
01:41:29 <chessandgo> I wish there was a modern low level language like C, but better
01:41:34 <Mrbuck> [exa]:  Oh Good to know to me when you mean equivalent what are they 
01:41:45 <chessandgo> C doesnst represent how modern hardware operates
01:41:50 <kadoban> There are purposes for which C is fine, ideal even. But unless you end up there, there's little point.
01:41:55 <Mrbuck> kadoban:  but I see every good programmer know it
01:42:04 <kadoban> Mrbuck: Not even close
01:42:43 <chessandgo> every good programmer knows lisp and fortran, the true languages of the gods
01:42:55 <[exa]> cocreature: I expected someone is going to object
01:42:56 <chessandgo> and they own a personal lisp machine too
01:43:05 <[exa]> :]
01:43:07 <MarcelineVQ> chessandgo: and prolog
01:43:14 <chessandgo> mercury is where its at now days
01:43:34 * chessandgo is jealous mercury has linear types and haskell doesnt (yet, hopefully)
01:44:06 <cocreature> [exa]: this isn’t just about objecting, that kind of condescending bullshit needs to stop.
01:44:17 <kadoban> Mrbuck: Many programmers can probably bullshit their way through a bit of C, mostly because there's like 10 common languages that have C as some sort of influence. But not that many use it commonly, relatively. I'd guess maybe 20% of the programmers I've worked with know it to any degree, and I don't even know the last time I've seen it used professionally in a project I was involved in.
01:44:47 <[exa]> cocreature: ok, sorry, I didn't want it to sound like that. But I didn't see many programmers who don't implicitly know C either. There's just that category of people who explicitly avoid knowing that a real computer is processing their data that I wanted to point out.
01:45:10 <chessandgo> C doesnt represent how modern hardware works anymore
01:45:16 <chessandgo> which is a shame(?)
01:45:21 <MarcelineVQ> I know c just well enough to really really mess something up
01:45:30 <kadoban> I don't even know what 'implicitly' knowing C means. Are you using that to mean some level of knowledge of computer architecture?
01:45:34 <MarcelineVQ> Which means I look like I​ know it, which is good enough for employers right?
01:46:18 <chessandgo> depends if your employer is linus trovalds ;)
01:47:04 <MarcelineVQ> ehe, I just mean it's not so hot a metric
01:47:25 <[exa]> kadoban: you know there's the memory with addresses and stuff... I should probably have said assembly instead of C :]
01:47:56 * chessandgo cough
01:47:57 <chessandgo> https://www.youtube.com/watch?v=eunYrrcxXfw
01:48:08 <Mrbuck> ok kadoban 
01:48:09 <chessandgo> Assembly is too high level *:)*
01:48:19 <[exa]> :]
01:48:58 <kadoban> [exa]: Probably something like that. Ya, C doesn't really have ... as far as I know anything to do with how machines work, it's full of abstractions (not even very good ones) like every other language. If one wants to know that stuff, they should study it directly, not learn a language and hope that teaches it.
01:49:10 <Geraldus> Hi folks!
01:49:23 <chessandgo> to truly understand how machines work
01:49:28 <chessandgo> you should study webassembly /s
01:51:06 <[exa]> kadoban: and these bad portable abstractions are used to build runtimes and operating systems for all other languages.. :[
01:51:24 <Geraldus> Having troubles sending emails via Hailgun.  Very likely the crux of the matter is email addresses format I'm using.   Can anybody help with this?
01:51:31 <chessandgo> redox is a microkernel coded in rust :]
01:51:49 <kadoban> [exa]: Well, portable-ish. I'm not saying they aren't useful, certainly to some extent they very much are. I just mean if your goal is to understand machines, they're not helping.
01:52:09 <[exa]> yeah.
01:55:42 <[exa]> chessandgo: anyway I like to throw this paper around, esp. the hardware-related part is good https://www.cs.kent.ac.uk/people/staff/srk21//research/papers/kell17some-preprint.pdf
01:56:37 <chessandgo> so it looks like I have to implement octotrees myself, and then turn them into zippers
01:57:41 <[exa]> chessandgo: there's package Octree btw
01:58:38 <chessandgo> [exa]: I can't just throw the a zipper onto of it though, can i?
01:59:17 <[exa]> perhaps some code could be reused
02:00:12 <chessandgo> I only like looking at other peoples code as last resort, feels like im cheating :]
02:00:18 <[exa]> re "throw the zipper onto it"  ---- could TH do the zipper-like differentiation to produce them automatically?
02:00:57 <Eduard_Munteanu> Rust is on my list, but the problem with C is weak typing and the whole myriad of stupid little rules and corner cases. I wonder if Rust does away with those.
02:01:06 <[exa]> chessandgo: opensource is for learning not cheating! :D
02:01:21 <chessandgo> and you learn by struggling first! not getting it on a silver platter!
02:01:30 <[exa]> fair point
02:01:49 <chessandgo> I feel like TH for zippers would be a cure worst than the illness
02:05:41 <chessandgo> welp, it was greating talking to you guys, but i'll be going now. A lot of work ahead of me :)
02:12:43 <[exa]> regarding the spatial tree problems... is there a typeclass that would represent stuff in metric space? like HasDistanceMetric or so. Or is it better to do that simply using Num (-) and 'abs', and somehow neglect the cosmetic problem that abs doesn't return scalar type?
02:21:45 <cocreature> [exa]: https://hackage.haskell.org/package/linear-1.20.8/docs/Linear-Metric.html#t:Metric
02:27:16 <[exa]> kindof thinking whether vantage-point metric has to be linear
02:27:36 <[exa]> don't see any usage where it shouldn't be. Thanks cocreature
02:38:00 <sshine> I've got a function 'foo :: Monad m => ...' in its signature, and a 'where bar = ...' and it complains that there is a discrepancy between the 'm' of foo and the 'm1' of bar. can I somehow tell it that I'm talking about the same monad type?
02:38:34 <cocreature> sshine: enable ScopedTypeVariables and change the type signature of foo to forall m. Monad => …
02:38:35 <sshine> if I take the body of 'bar' and replace it in the many places I use it in 'foo', I don't have a problem.
02:38:46 <sshine> cocreature, excellent! I thought it was something with forall. thanks. :)
02:39:05 <alexelcu> I need help with Dhall — I don't understand how to work with Maps (e.g. Data.Map, Data.HashMap, anything) — I see that I have dhall `1.15.0`, so not exactly the latest
02:41:14 <__monty__> alexelcu: Hmm, can't find Data in the standard library, where'd you get it?
02:42:45 <MarcelineVQ> __monty__: those modules are typically provided by the  containers  package 
02:43:04 <__monty__> MarcelineVQ: No, no. Can't find it in the Dhall standard library.
02:43:06 <__monty__> : )
02:44:47 <alexelcu> __monty__: that's another problem; I don't understand what the native Map is for haskell. `Data.Map` is from `containers` package and `Data.HashMap` is from `unordered-containers` package.
02:45:46 <revtintin>  /quit
02:46:36 <alexelcu> can't Dhall do maps? :-)
02:46:55 <__monty__> alexelcu: Not afaics.
02:47:28 <__monty__> I mean, you could probably implement them. Probably easier to translate to dhall's records though.
02:47:52 <__monty__> alexelcu: Usually Data.Map is fine.
02:51:21 <alexelcu> ok, thanks
02:58:23 <__monty__> alexelcu: Hmm, I'm actually not sure it'll be easy to produce a record from a Map, cause records have a fixed number of fields.
02:59:02 <__monty__> Why do you need a Map? Maybe we can reformulate.
03:06:12 <fiatjaf> dmj`, my miso onClick handlers have suddenly stopped being called, they were working and at some point they aren't called anymore. everything else still works. is that a trivial problem you've seen many times and are able to quickly help me or should I open an issue?
03:07:19 <__monty__> alexelcu: Maybe an association list will be the easiest translation?
03:08:39 <Geraldus> Hey folks, any Mailgun users here? )
03:10:00 <dmj`> fiatjaf: can you open the console and see if any errors are present
03:11:39 <fiatjaf> no errors
03:13:21 <dmj`> fiatjaf: can you gist me your code
03:13:25 <fiatjaf> dmj`, just a 'unreachable code after return statement' that is always there, I believe some ghcjs bug?
03:13:41 <dmj`> fiatjaf: which version of ghcjs are you using
03:14:02 <fiatjaf> dmj`, http://sprunge.us/wG0LD0
03:14:34 <fiatjaf> I'm using the latest nixpkgs, I guess
03:15:13 <fiatjaf> The Glorious Glasgow Haskell Compilation System for JavaScript, version 8.4.0.1 (GHC 8.4.2.20180420)
03:15:47 <dmj`> fiatjaf: master of nixpkgs? or nixpkgs-unstable
03:17:34 <fiatjaf> dmj`, master
03:17:47 <fiatjaf> I copied the last commit sha 2 days ago
03:20:28 <fiatjaf> http://sprunge.us/HXSgOf
03:21:05 <dmj`> fiatjaf: I’d try to compile with the hash that miso ships with, 7.10.3 was a lot more stable and then regressions were introduced (https://github.com/ghcjs/ghcjs/issues/666). I’ve never heard of the error you’re referring to, others have mentioned bugs 8.4 that may or may not be patched in nixpkgs. If you can repro on 7.10.3 then we know miso is problematic. Can you paste the error? Or make an issue on miso and we can
03:21:11 <dmj`> triage on ghcjs’s issue tracker
03:21:47 <dmj`> fiatjaf: pinging Sonarpulse would also be good (aka nixpkgs jesus), he has written the new infra for ghcjs
03:22:21 <fiatjaf> you mean the hashes on miso's README?
03:22:29 <fiatjaf> I'll try those
03:23:41 <dmj`> fiatjaf: https://github.com/dmjio/miso/blob/master/default.nix#L1-L6
03:23:41 <fiatjaf> it seems related to event bubbling or something like that, I guess
03:24:51 <dmj`> fiatjaf: was there a specific action taken that after caused the behavior you’re seeing
03:25:18 <fiatjaf> I'm not sure
03:25:40 <fiatjaf> oh
03:25:50 <fiatjaf> now that you're saying
03:26:03 <fiatjaf> I think it was when I moved from stack to nix
03:26:09 <fiatjaf> and changed ghcjs versions in the process
03:26:11 <fiatjaf> :P
03:27:16 <dmj`> fiatjaf: that might have something to do with it :) 
03:31:24 <dmj`> fiatjaf: Ah, someone else made an issue about this. It’s due to the Ord/Eq instances of JSString ~ MisoString being broken, which causes the map of events that body listens on to be unpopulated when the app starts.
03:31:31 <dmj`> fiatjaf: this demonstrates the nasty bug https://github.com/dmjio/miso/issues/414#issuecomment-405792399
03:32:04 <dmj`> fiatjaf: if you inspected defaultEvents, it would be near empty
03:33:09 <dmj`> fiatjaf: there was a fix for this
03:33:12 <srk> I've patched ghcjs 8.4 with #666 fix (https://github.com/ghcjs/ghcjs/pull/685) - https://github.com/sorki/haskell-ttn-dashboard/blob/master/app.nix
03:33:13 <dmj`> fiatjaf: https://github.com/ghcjs/ghcjs/pull/680
03:35:17 <dmj`> srk: oo! very nice. Thanks for doing this
03:35:32 <dmj`> fiatjaf: you could then apply srk's patch: https://patch-diff.githubusercontent.com/raw/ghcjs/ghcjs/pull/680.patch
03:36:05 <srk> or just re-use nix expressions ;)
03:36:25 <dmj`> ghcjs = pkgs.lib.overrideDerivation pkgs.haskell.compiler.ghcjs (drv: { patches = [ ./ghcjsEqPatch.patch ]);
03:36:29 <dmj`> srk: sure :) 
03:37:33 <lavalike> .ghc.environment produced at some point by using stack is something that should get .gitignored right?
03:40:23 <oo_miguel> Is there any "document" about the state of the art haskell libraries "to use" in production? I feel that when searching by myself I often find many of them serving same/overlapping purposes... SO i simply keep asking here again and again (and often forgetting... :P )
03:41:01 <oo_miguel> s/in production//
03:45:24 <hexagoxel> lavalike: yes. (i think only cabal produces those. but "stack solver" might involve that (?))
03:47:04 <hexagoxel> % :t 18
03:47:04 <yahb> hexagoxel: Num p => p
03:47:11 <hexagoxel> % 18 @Int
03:47:11 <yahb> hexagoxel: ; <interactive>:90:1: error:; * Cannot apply expression of type `p0'; to a visible type argument `Int'; * In the expression: 18 @Int; In an equation for `it': it = 18 @Int
03:47:19 <lavalike> hexagoxel: right, I'm trying out stack and it's been an adventure
03:47:35 <hexagoxel> % let x :: forall a . Num a => a; x = 18 in x @Int
03:47:35 <yahb> hexagoxel: 18
03:48:03 <hexagoxel> strange case of referential opaqueness
03:50:02 <lavalike> oh it might have indeed be the result of running stack solver now that I think about it
03:50:16 <tsaka__> I'm getting stack build errors..     cannot find object file ‘.stack-work/dist/x86_64-linux-tinfo6/Cabal-2.2.0.1/build/dca-exe/dca-exe-tmp/Gridneighs.dyn_o’     while linking an interpreted expression
03:50:20 <tsaka__> what to do with that?
03:50:37 <lavalike> I was still trying to figure out why some dependencies did not work our of the box, it was because LTS didn't include them, so they needed to be added via stack.yaml, but the error message suggested to try solver
03:52:50 <hexagoxel> i wonder if that has the potential to break stack. if you switch lts but don't run solver again.
03:53:48 <hexagoxel> stack calls ghc, ghc picks up mismatching env.
04:04:38 <cocreature> hexagoxel: afaik "stack solver" invokes cabal such that it doesn’t produce environment files
04:05:34 <cocreature> but it breaks if you use stack & cabal new-build on the same project or at least it did break until fairly recently
04:12:03 <hexagoxel> ahaha stack requires more than 1GB of heap? good thing I have set up an upper bound by default.
04:16:23 <chindy> stack build always unregisters multiple libs etc and hence takes a loong time. Anyone know why that may be ?
04:31:50 <fiatjaf> dmj`, what is that 'ghcjs' that is being returned from your nix expression? how do I insert it back into the derivation?
04:32:10 <fiatjaf> because previously I had 'pkgs.haskell.ghcjs'
04:38:29 <ski> @tell chessandgo actually Mercury doesn't have linear types, it has uniqueness types (actually not types, that what Clean has. it has uniqueness modes. but the distinction isn't that important here). linearity and uniqueness are in some way related, but it's not the same thing
04:38:29 <lambdabot> Consider it noted.
04:38:33 <ski> [exa] : interesting paper, ty
04:42:34 <tsaka__> How come <printf "\n %s" (show x)> actually displayes the "\n" character instead of the newline?
04:42:40 <tsaka__> in stdout on linux ..
04:44:59 <hexagoxel> % putStrLn (printf "\n %s" (show True))
04:44:59 <yahb> hexagoxel: ; True
04:45:46 <hexagoxel> tsaka__: because you print the result instead of putStr ?
04:45:58 <tsaka__> oooh
04:46:38 <tsaka__> well, no actually
04:47:49 <tsaka__> i use "putStrLn $ fst (MyData,_)" where "MyData = MyData1 | MyData2 String"
04:48:02 <tsaka__> i tried switching to print but I get the same behavior
04:50:57 <ski> tsaka__ : is `MyData' a data type you've defined using the `data' keyword ? also using a `deriving' clause mentioning `Show' ?
04:51:16 <tsaka__> yep
04:51:20 <hexagoxel> and where does `printf` come into play?
04:51:30 <ski> tsaka__ : by `putStrLn $ fst (MyData,_)', i suspect you mean `putStrLn $ fst (md,_)', where `md' has type `MyData', correct ?
04:51:44 --- mode: ChanServ set +o glguy
04:51:51 <tsaka__> @hexagoxel the string put into the data type is made using printf
04:51:51 <lambdabot> Unknown command, try @list
04:51:51 <ski> (and where `_' is actually replaced by some real expression)
04:52:06 <tsaka__> ski: yes
04:53:26 <ski> > printf "\n %s" (show True) :: String  -- tsaka__, "the string put into the data type is made using printf" -- something like this ?
04:53:28 <lambdabot>  "\n True"
04:53:41 <hexagoxel> Show is supposed to produce a string that is valid haskell, so this is as expected
04:53:52 <ski> (wrapping that `printf' call in `MyData2', in which case the `:: String' type ascription can be omitted)
04:54:09 <tsaka__> ski: correct
04:54:18 <hexagoxel> either way, printf is not at fault. invoking show on String is responsible.
04:55:09 <hexagoxel> if you really need it, you can write a custom newtype wrapper around String with a Show instance that does not do escaping.
04:55:12 <ski> `Show' is mainly meant for debugging (and as a quick and easy means of serialization where you don't care that much about the serialization format, i suppose, apart from having it be in Haskell syntax making for easier debugging of it)
04:55:57 * ski would recommend against making a `Show' instance that outputs something not conforming to Haskell syntax
04:56:02 <ski> (and ditto for `Read')
04:56:17 <tsaka__> I see. Well I'm free to use any type to carry what to print
04:58:19 <ski> (if you want to do some kind of custom or pretty printing, please define your own operation (or even type class) for doing so, don't attempt to coopt `Show' (and `Read') for this)
05:00:32 <ski> (`Show' is meant to be used in a compositional way. if you have a type `T' that has a `Show' instance that doesn't output stuff conforming to Haskell syntax, then when i use the (automatically derived) `Show' instance of `Maybe T', `(T,T)', `[T]' or `Ratio T', &c. i will get a mix of Haskell and non-Haskell syntax, which is bad)
05:01:25 <alexelcu> __monty__: thanks, yes, I really need a map, I might try an association list, I guess it’s not awful, since I only have a couple of entries. Maps are pretty fundamental though, I hope Dhall adds support. I could switch to plain JSON too I guess. I’m basically exploring the landscape by building a toy project 🙂
05:03:15 <mniip> ski, which is why you should always go for showPrec/showsPrec instead of show
05:03:48 <ski> indeed
05:04:24 <ski> or at least `shows', in case you never potentially need to bracket your output (e.g. with enumerations like `Bool')
05:06:50 <royal_screwup21> suppose I have a data type like so: data Expr = Lit Int |  Add Expr Expr. What does it meant to add "new semantics" to this? Does it mean extend the data constructors to something like data Expr = Lit Int | Add Expr Expr | Sub Expr Expr?
05:08:17 <mniip> btw I've been giving more thought to yoctoparsec
05:08:54 <mniip> going back to the fundamental question of making a more "safer" State [t]
05:09:12 <mniip> State [t] allows for lookahead, which is tricky in yocto
05:09:43 <mniip> State [t] also has a natural notion of end of stream
05:12:22 <mniip> now that's where monadic machines come into play
05:14:24 <mniip> data Action t m a = Look (t -> Parser t m a) | Shift (Parser t m a) | Yield a
05:14:33 <mniip> data Parser t m a = Parser (m (Action t m a))
05:14:55 <mniip> this has the complication of having to maintain two stream pointers kinda
05:14:59 <mniip> one for shifts, one for looks
05:15:02 <ski> royal_screwup21 : it might be that what's meant. another interpretation would be that a new semantics is another operation `computeSomething :: Expr -> Something' (presumably defined in a compositional way)
05:15:28 <ski> (another, in addition to an existing `evalExpr :: Expr -> Int', say)
05:15:50 <royal_screwup21> ski: I see, thanks for clarifying
05:16:32 <ski> (e.g. `Something' might be an indication whether the result would be even or odd. this can be computed, without actually computing all the internal additions on the actual `Int' literals)
05:18:13 <ski> mniip : .. i'm not convinced "end of stream" is a helpful concept to reflect on, in parsing. (for roughly "compositional reasons")
05:18:35 <mniip> practically, it is
05:20:03 <ski> (in short, if `x' is a possible result of parsing the input `s' with parser `p', and `y' is a possible result of parsing the input `t' with parser `q', i'd like `(x,y)' to be a possible result of parsing the input `s ++ t' with parser `liftA2 (,) p q')
05:20:30 <mniip> yeah that might fail if p relies on EOS
05:20:41 <__monty__> alexelcu: How is a map represented in JSON?
05:20:46 <ski> also lookahead is suspect
05:21:03 <mniip> although your consideration is very theoretical
05:21:05 <ski> (also, if "end of stream", why not also "beginning of stream" ?)
05:21:08 <mniip> here's a very practical one instead:
05:21:09 <ski> granted
05:21:25 <mniip> consider p = q = parse an Int
05:21:44 <mniip> in most cases you wouldn't like 'liftA2 (,) p q' to try all splittings of the input into two numbers
05:21:56 <mniip> that would mean p is inefficient
05:22:54 <ski> yes, maximal munch and similar has to be accomodated in some way
05:24:04 <mniip> oh!
05:24:13 <mniip> I remember where I got stuck last time
05:24:59 <mniip> considering the typeclasses Monad (return, >>=) and Bind (>>=)
05:25:03 <mniip> is there a free functor
05:25:28 <mniip> Map k is a Bind but I'd like to lift it into a Monad
05:27:34 <ski> hmm, interesting question
05:28:37 <mniip> the construction used in Free : Apply -> Applicative  doesn't work here
05:29:44 <mniip> Bind ~ Join, I think?
05:29:44 <ski> you want `return :: v -> FreelyAddReturn (Map k) v' -- but `k' is not pointed, so we can't use `singleton :: k -> v -> Map k v', it seems
05:30:02 * ski doesn't recall how `Free : Apply -> Applicative' works
05:30:20 <mniip> data Free f a = Pure a | Free (f a)
05:30:52 <ski> with the law `Free (pure a) = Pure a' ?
05:30:59 <mniip> no
05:31:04 <mniip> f is not Applicative
05:31:08 <mniip> so presumably has no pure
05:31:16 <ski> hrm, yea right. sorry
05:31:29 <mniip> pure = Pure
05:31:50 <mniip> then <*> is four equations, two of which use fmap, one uses direct application and the last uses the Apply operator
05:31:58 <ski> yea, i see
05:35:06 <mniip> restating in terms of join,
05:35:30 <mniip> the problem with  Free f (Free f a) -> Free f a  is satisfying the  join . fmap return = id
05:35:45 --- mode: glguy set +v honungsburk
05:35:59 <mniip> in general, you need to be able to see if all of your leaves are Pure
05:36:07 <mniip> I suspect we can actually afford that in Map
05:36:42 * mniip . o O ( Traversable)
05:38:31 <mniip> we don't actually even need to concern ourselves with this for Map
05:41:48 <ski> both `Bind' and `Join' assumes `Functor' ?
05:48:19 <mniip> yes
05:53:38 <mniip> consider this
05:53:40 <mniip> @let data MMap k v = Pure v | Map (M.Map k v) deriving (Eq, Ord, Show, Functor)
05:53:41 <lambdabot>  .L.hs:188:1: error:
05:53:41 <lambdabot>      Multiple declarations of ‘MMap’
05:53:41 <lambdabot>      Declared at: .L.hs:165:1
05:53:51 <mniip> @let data MMap k v = Pure v | Map (M.Map k v) deriving (Eq, Ord, Show, Functor)
05:53:52 <lambdabot>  Defined.
05:54:03 <mniip> @let instance Ord k => Applicative (MMap k) where pure = Pure; Pure f <*> Pure x = Pure (f x); Pure f <*> Map x = Map (f <$> x); Map f <*> Pure x = Map (($ x) <$> f); Map f <*> Map x = Map (M.intersectionWith ($) f x)
05:54:04 <lambdabot>  Defined.
05:54:20 <mniip> @let instance Ord k => Monad (MMap k) where return = Pure; Pure x >>= f = f x; Map m >>= f = Map $ M.mapMaybeWithKey (\k v -> case f v of Pure x -> Just x; Map n -> M.lookup k n) m 
05:54:22 <lambdabot>  Defined.
05:56:50 <ski> hm, so `Pure v' corresponds to a finite map that maps every key to `v' ?
06:00:09 <mniip> yes
06:00:23 <mniip> @check \xs -> join (return xs) == (xs :: MMap Int Int)
06:00:28 <lambdabot>  +++ OK, passed 100 tests.
06:00:33 <mniip> @check \xs -> join (return <$> xs) == (xs :: MMap Int Int)
06:00:36 <lambdabot>  +++ OK, passed 100 tests.
06:00:57 <ski> hm, so you're reusing the same key `k' in the further lookup on `n'. this feels `ZipList'y
06:01:10 <mniip> this one will be though
06:01:11 <ski> (or `Reader'y, if you prefer)
06:01:12 <mniip> @check \xs -> join (join xs) == join (fmap join (xs :: MMap Int (MMap Int (MMap Int Int))))
06:01:14 <lambdabot>  +++ OK, passed 100 tests.
06:01:27 <mniip> qed?
06:01:57 <mniip> ski, readers are too lazy and not thunky enough
06:02:21 <mniip> I mean, memoization 
06:02:51 <ski> i only meant in the way the index/position/key was duplicated in `join'/`(>>=)', extracting a diagonal
06:02:58 <mniip> sure
06:03:47 <mniip> now the problem is I don't remember why this was important
06:03:51 <ski> heh
06:04:23 <mniip> I think the problem was there were multiple ways to represent the same parser with FreeT trees
06:04:33 <mniip> basically you could have branching at different depths
06:04:51 <ski> this is vaguely reminding me of wrapping an implementation of a set (say) in way to make extraction of minimum element an O(1) operation
06:04:54 <mniip> and you always want to cut off dead branches as early as possible
06:04:59 <ski> (or bootstrapping PQs)
06:05:34 <ski> okay
06:06:37 <mniip> oh yeah
06:06:58 <mniip> hmm
06:09:38 <ski> (initially, i was thinking that `Map k (Map k v) -> Map k v' would be some kind of flattering. perhaps using `Monoid k' (rather that `const' vs. `flip const', which feels unsatisfactorily, for symmetry reasons))
06:12:22 <mniip> the problem was,
06:12:35 <ski> hm, now i idly wonder whether there is a `Map' which enforces monotonicity
06:12:40 <mniip> [\t -> empty, \t -> empty, ...] is extensionally the same parser as 'empty'
06:12:45 <mniip> and you want to optimize that out
06:12:51 * ski nods
06:12:52 <mniip> but you can't because \t -> is a function
06:13:02 <mniip> and you can't test them for equality or anything
06:13:14 <ski> is that list nondeterminism in the parser ?
06:13:19 <olligobber> you can if the domain is finite
06:13:21 <ski> (`t' being current input ?)
06:13:27 <mniip> yes
06:13:47 <mniip> consider  FreeT ((->) t) []
06:14:17 * ski . o O ( `instance (Compact a,Eq b) => Eq (a -> b)' )
06:14:23 <mniip> Parser t a = [Action t a]
06:14:30 <mniip> Action t a = a | t -> Parser t a
06:15:11 <mniip> olligobber, that gets tricky if the domain is Char
06:15:50 <Gurkenglas> "class Compact a where foldMapC :: Monoid m => (a -> m) -> m"?
06:16:16 <ski> remind me of `FreeT', again ?
06:16:26 <mniip> I pretty much wrote it out
06:16:30 <mniip> but there you go:
06:17:39 <ski> Gurkenglas : i was thinking more like `where forallS :: (a -> Sierpinski) -> Sierpinski'
06:17:48 <mniip> newtype FreeT f m a = FreeT (m (FreeF f a (FreeT f m a)))
06:18:02 <mniip> data FreeF f a b = Pure a | Free (f b)
06:18:20 <mniip> I was using it up there with m ~ [], f ~ ((->) t)
06:18:53 <ski> and `FreeT' (`FreeT f' ?) is a functor from what to what. what does it assume, and what free structure does it introduce ?
06:19:08 <mniip> good question
06:19:23 <mniip> Free ~ FreeT Identity is a functor from endofunctors to monads
06:19:24 <Gurkenglas> FreeT f m is the functor, because haskell functors are * -> *
06:19:36 <Gurkenglas> huh, I'm wrong?
06:19:39 <mniip> not sure if FreeT has a categorical meaning
06:20:05 <mniip> I think it's just a "natural" monad transformer construction out of a monad
06:20:51 <mniip> if your monad is an ADT just sprinkle 'm' at any choice point
06:21:13 <mniip> MaybeT, EitherT, LogicT, FreeT are constructed this way
06:21:42 <Gurkenglas> I'd bet it has the categorical meaning of being the free construction
06:21:46 <ski> ok, `FreeT f m a = m (a + f (FreeT f m a)) = m (a + f (m (a + f (m (a + ...)))))'
06:21:52 <mniip> yes
06:22:30 <mniip> Gurkenglas, hmm, let's say M is a monad transformer
06:22:42 <ski> Gurkenglas : yea, i was asking about general functors, not `Functor'
06:22:55 <mniip> M mapsto (M Identity, an endofunctor)
06:22:59 <mniip> is a forgetful functor
06:24:31 <ski> mniip : "if your monad is an ADT just sprinkle 'm' at any choice point" -- yeah, it seems kleislish, in some sense
06:26:20 * lyxia . o O ( http://blog.poisson.chat/posts/2017-05-28-free-monad-transformers.html )
06:27:31 <Gurkenglas> My bet rests on vaguely having in memory *googles* "The very definition of a free monad transformer is that given a natural transformation you get a monad transformer homomorphism." http://hackage.haskell.org/package/free-5.1/docs/Control-Monad-Trans-Free.html#v:foldFreeT
06:27:43 <mniip> lyxia, ha! I knew it
06:29:03 --- mode: glguy set +v nut
06:29:07 <Gurkenglas> I think when you try sprinkling ms without good reason you get things like ListT done wrong
06:29:37 <mniip> ListT done wrong is *not enough* sprinkline
06:29:42 <mniip> sprinkling
06:30:24 <mniip> m (1 + a * (1 + a * ( ... )))
06:30:24 <mniip> vs
06:30:37 <mniip> m (1 + a * m (1 + a * m ( ... )))
06:30:41 * Gurkenglas . o O (is sprinkling a free construction?)
06:31:29 <bollu> is there a category of monad transformers?
06:31:39 <mniip> probably
06:31:42 <bollu> If so, what does it look like? what are monad transfrormer morphisms? :) 
06:31:49 <Gurkenglas> bollu, mmorph is the library for that
06:32:06 <Gurkenglas> its fmap's called hoist
06:32:10 <bollu> Gurkenglas nice
06:33:04 <Solonarv_> > is sprinkling a free construction -- it looks to me like FreeT is that free construction, actually
06:33:06 <lambdabot>  error:
06:33:06 <lambdabot>      • Variable not in scope: is :: t0 -> Expr -> t1 -> t2 -> t
06:33:06 <lambdabot>      • Perhaps you meant one of these:
06:33:11 <bollu> Gurkenglas It doesn't seem to explore the algebra of said objects, though. (can I take products? sums? etc)
06:33:16 <Solonarv_> grrr go away lambdabot
06:33:57 <Solonarv_> well every monad is a functor, so those are the same as functor sum/product/etc
06:34:29 <Solonarv_> (when they exist and are well-behaved, that is; I'm not entirely sure when that's the case)
06:34:39 <bollu> hm, I suppose
06:35:03 <ski> lyxia : ty
06:36:51 <mcbear>   lbs <- wrapException (_CsvIoError #) $ (LBS.readFile fn) What does that # mean here?
06:38:06 <nonzen> What are these "Variable not in scope: (^?)" etc errors?  I am just trying to load microlens-aeson example into ghci.
06:38:16 <nonzen> https://gist.github.com/sajith/1aa27fca48b034bceaead8e31d88ce4c
06:38:41 <ski> @type ( # )  -- mcbear ?
06:38:42 <lambdabot> AReview t b -> b -> t
06:38:59 <mcbear> ski, type?
06:39:06 <lyxia> nonzen: import Lens.Micro
06:40:31 <ski> mcbear : i suspect it's a lens operation
06:41:00 <ski> @type review
06:41:02 <lambdabot> MonadReader b m => AReview t b -> m t
06:41:03 <ski> @type view
06:41:04 <lambdabot> MonadReader s m => Getting a s a -> m a
06:41:21 <mcbear> ski, it IS using lens libraries
06:41:24 <Gurkenglas> I suppose mmorph doesn't actually discuss the category of monad transformers. hmm. let's try its objects to be the instances of MFunctor. Then a morphism should be t m a -> t' m a. IdentityT would be initial, and UnitT would be terminal.
06:41:46 <ski> in your case, presumably it gives you the "field extraction" function corresponding to the lens `_CsvIoError'
06:42:11 <mniip> bollu, are you familiar with functor categories?
06:42:32 <bollu> mniip objects are functors, arrows are natural transformations? yep
06:43:09 <mniip> this is the same but a level deeper
06:44:01 <mniip> you have a category of functors from functors to functors
06:44:09 <ggVGc> trying to understand what tasty gives me over hspec
06:44:19 <nonzen> lyxia: That worked, thank you!  But now there are a bunch of new errors: https://gist.github.com/sajith/95ab4c75bd11eb2c24ec52aa1e057140
06:44:47 <ski> from functors to functors, or from functor categories to functor categories ?
06:47:27 <lyxia> nonzen: you might want to annotate those strings with their types for slightly better error messages
06:48:06 <Gurkenglas> <Solonarv_> well every monad is a functor, so those are the same as functor sum/product/etc <- i'm not sure that reasoning is enough, because the definitions of sum and product include forall and exists quantifiers that are now easier/harder to satisfy
06:48:37 <Solonarv_> that's why I added the caveat aboout half a minute later
06:50:31 <nonzen> lyxia: Hmm, I'm just trying to load the example from microlens-aeson into repl.  Is that example supposed to work out of the box, or is that meant to be just a borad overview?
06:54:56 <lyxia> nonzen: Ah I see. it should work out of the box, so you might want to tell the maintainer about this.
07:04:47 <nonzen> lyxia: Ok, thanks!
07:38:13 <tsaka__> is there any way to import a module by file name in GHCi without loosing what you already have in scope
07:45:42 <Solonarv_> by file name? nope
07:50:02 <cocreature> tsaka__: :add instead of :load
07:51:38 <haasn> are threads turing complete? given the capabilities to launch threads, send and catch signals to them, and block until any thread in a specified set completes
07:52:04 <haasn> what else is needed to make it so you can compute stuff using only threading primitives?
07:58:36 <benzrf> haasn: check out the pi-calculus
08:04:38 <royal_screwup21> I can't quite understand what Fix does or is...can someone give me a simple example to tinker with?
08:04:51 <deltasquared> never did manage to wrap my head around even the lambda calculus, though I recall the way you got conditionals out of it to be quite ingenious
08:04:59 <haasn> royal_screwup21: perhaps the simplest possible non-degenerate case is Fix Maybe
08:05:21 <haasn> try expanding the definition of Fix using Maybe and seeing what the resulting data type would look like if you were to write it directly (instead of using Fix as a helper)
08:05:28 <deltasquared> something tells me that's not just Maybe (Maybe (Maybe ...))
08:06:15 <haasn> Well, it is Maybe (Maybe (Maybe (Maybe ....))), that's what Fix does - but I mean, what can you do with this resulting data type? what other data types (not using Fix) is it equivalent to?
08:06:17 <deltasquared> I was reading how "fix" (the function, not the type) worked linked from haskell weekly recently, man that was another brain implosion
08:06:34 <deltasquared> :k Fix Maybe
08:06:36 <lambdabot> error:
08:06:36 <lambdabot>     Not in scope: type constructor or class ‘Fix’
08:06:44 <haasn> Fix Maybe :: *
08:06:51 <haasn> Fix :: (* -> *) -> *
08:07:09 <royal_screwup21> I have this university course where they teach language engineering with haskell :( masochists, all of them
08:07:15 <haasn> data Fix f = Fix { unFix :: f (Fix f) }
08:07:21 <rain2> hey
08:07:33 <cocreature> Haskell sounds like a pretty good choice for a language engineering course :)
08:07:38 <deltasquared> haasn: so... just a linked list if you were to follow it?
08:07:42 <deltasquared> in a sense
08:08:19 <haasn> deltasquared: yeah sort of
08:08:41 <haasn> or posed another question: can you enumerate all possible values of type Fix Maybe ?
08:08:57 <deltasquared> that haskell weekly linked article was interesting in any case, I finally got a nice-ish explaination of what the mysterious Y-combinator was for. sort of.
08:09:01 <Gurkenglas> haasn, it corresponds to Nat
08:09:37 <deltasquared> Gurkenglas: holy crap, like Zero, Succ Zero, Succ (Succ Zero) ... nice catch
08:09:47 <haasn> the y combinator is how you do recursion in a language without recursion :p
08:09:55 <haasn> deltasquared: yeah exactly
08:10:02 <haasn> except here it's Nothing, Just Nothing, Just (Just Nothing), ...
08:10:12 <Gurkenglas> wait that was supposed to be a teachable moment dangit
08:10:13 <dolio> But it does have recursion, because of the y combinator. :)
08:10:19 <deltasquared> haasn: hence why I never got it, as I've never used a language that couldn't recurse but had the Y-combinator
08:10:24 <haasn> data FixMaybe = Nothing | Just FixMaybe
08:10:35 <hpc> deltasquared: here's another perspective on it:
08:10:39 <hpc> deltasquared: fix is a function
08:10:52 <hpc> that means you have recursion available as a first-class value in the language
08:11:01 <hpc> and you can maybe imagine writing other recursion schemes as well?
08:11:13 <deltasquared> this is how I know haskell is good for me, I get my brain turned inside out every other week xD
08:11:24 <hpc> say you wrote a memoization function
08:11:36 <hpc> (which there's a package for this)
08:11:40 <haasn> what really made `fix` click to me is the whole idea of `fix f` meaning that function f gets called with itself as the argument
08:11:45 <hpc> you expand out the recursion in your say, fib function
08:11:52 <hpc> fib rec n = ...
08:11:59 <deltasquared> uhm, memoization sounds a bit impure unless you just thread the memoization cache along immutably, in which case sure go ahead
08:12:06 <hpc> if you want a memoized fib function you pass fib memoize n
08:12:15 <deltasquared> hold up a sec
08:12:15 <hpc> or you can do fib fix n, or something along those lines
08:12:24 <hpc> you get to pick your recursion scheme with a function parameter :D
08:12:28 <deltasquared> I SAIZ ONE SEC xD
08:12:30 <haasn> so say you want to write a recursive function like `map f l = case l of [] -> []; (x:xs) -> f x : map f xs` using the y combinator
08:12:33 <royal_screwup21> haasn: I think I sort of it see it when you put it that way...butwhy would anyone want to do that?
08:12:49 <haasn> it's completely mechanical to translate this to  fix (\map f l -> case l of [] -> []; (x:xs) -> f x : map f xs)
08:12:59 <deltasquared> celestia damnit I take a bit longer to grasp this stuff, slow dahn
08:13:34 <Gurkenglas> Solonarv_, it's not lambdabot's fault, lambdabot's older than greentext :P
08:13:36 <haasn> royal_screwup21: in haskell there's no real need for it because you can write `fix f` as `let x = f x in x`
08:13:44 <haasn> (and actually that is also the definition of `fix`)
08:13:55 <haasn> but usually giving names to things makes things easier in haskell world
08:14:35 <hpc> deltasquared: read through https://wiki.haskell.org/Memoization and http://hackage.haskell.org/package/memoize-0.8.1/docs/Data-Function-Memoize.html
08:14:38 <royal_screwup21> haasn: hmmm off to googling what "in" does...if it does what I think it does, the fix f should return...a bool?
08:14:42 <hpc> deltasquared: maybe check out the source for memoFix
08:14:44 <haasn> in a sense, `fix` isn't even the real y combinator, it short circuits using haskell language features rather than function application
08:14:47 <haasn> if that makes sense
08:14:48 <hpc> deltasquared: then read back through the scrollback :D
08:15:02 <haasn> > let x = 5 in x + x -- royal_screwup21
08:15:05 <lambdabot>  10
08:15:18 <dolio> Well, it's not the y combinator because y is a specific definition.
08:15:33 <dolio> There are many fixed point combinators in untyped lambda calculus that aren't y.
08:15:47 <Solonarv_> purity doesn't say anything about performance, only about the final results - allocating memory does not count as a side effect
08:16:02 <haasn> dolio: doesn't that depend on whether you care about intensional or extensional sameness to consider something the same function/combinator?
08:16:16 <royal_screwup21> haasn: what does "in" mean in haskell?
08:16:28 <hpc> the secret sauce behind that memoization technique is using a thunk to store "this isn't computed yet", and then if the thunk is evaluated twice it only does the computation the first time
08:16:37 <__monty__> royal_screwup21: It's part of the let syntax.
08:16:42 <haasn> royal_screwup21:  "let  (definitions)  in  (expression)" is a fundamental language feature
08:16:45 <__monty__> royal_screwup21: let name = value in body.
08:16:49 <haasn> it introduces the (definitions) within the scope of (expression)
08:17:15 <haasn> it serves two purposes: 1. allowing you to refer to things by name, and 2. allowing recursion
08:17:35 <deltasquared> hpc: oh wait, so it's just a means to stuff data sharing in one place?
08:17:41 <hpc> yep
08:17:43 <dolio> haasn: I'm saying that if you start talking about 'extensionality' you're wrong. The y combinator is a specific lambda term, not a function.
08:17:45 <royal_screwup21> what's the diff bw let x = 5 and let x = 5 in x?
08:17:49 <deltasquared> oh, that actually kinda makes sense
08:18:03 <Solonarv_> "let x = 5" isn't an expression, "let x = 5 in x" is
08:18:26 <deltasquared> *reads source* oh look, the dreaded template haskell appears
08:18:35 <haasn> royal_screwup21: the former is not legal (except in GHCi where it's a feature of GHCi)
08:18:39 <royal_screwup21> Solonarv: ah okay, thanks for  clarifying. Just to confirm, when you say it's not an expression, you mean it's not legal?
08:18:52 <Solonarv_> "let x = 5" *is* valid syntax, but only as a statement in a do block
08:18:52 <__monty__> I'm pretty sure it *is* an expression in do-syntax.
08:18:56 <royal_screwup21> haasn: ahh I see okay. Yeah, I was confused since it worked in ghci
08:18:58 <Solonarv_> but it's not an expression
08:19:01 <deltasquared> :t fmap
08:19:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:19:03 <haasn> oh, indeed Solonarv_, it's allowed in a do block
08:19:03 <deltasquared> :t <$>
08:19:04 <lambdabot> error: parse error on input ‘<$>’
08:19:08 <deltasquared> :t (<$>)
08:19:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:19:15 <haasn> basically ghci treats your input like a big `do` block
08:19:16 <deltasquared> ah, thought so, infix veresion
08:19:21 <haasn> If you don't know what `do` blocks are you can safely ignore this for the time being
08:19:32 <__monty__> Solonarv_: Why is it not an expression?
08:19:49 <haasn> __monty__: a haskell expression is a specific thing that can be evaluated to produce a value
08:19:53 <haasn> what does "let x = 5; y = 10" evaluate to?
08:20:01 <deltasquared> > reads instance of Memoizable for Integer > laziness rules, did this guy just map the function over all integers, the madman!
08:20:04 <lambdabot>  <hint>:1:7: error: parse error on input ‘instance’
08:20:11 <deltasquared> no, bot... no
08:20:24 <deltasquared> I need a new symbol for that >_<
08:20:32 <Gurkenglas> "/me"
08:20:39 <deltasquared> Gurkenglas: doesn't always fit
08:20:59 <haasn> you can also remove the space in between > and `reads`
08:21:20 <haasn> dolio: fair enough
08:21:27 <dolio> haasn: Also, on a tangent, I think that's an important distinction to make in general. Lambda terms vs. the functions they represent.
08:21:47 <rain2> can you serialize functions in haskell?
08:22:03 <Solonarv_> __monty__, cheeky answer: because the haskell report says so
08:22:08 <deltasquared> hpc: this is absolute madness to read the source of (memoize), I love it :D
08:22:09 <haasn> Yeah, I understand that in lambda calculus, the specific representation of a term matters - even down to variable naming (otherwise alpha equivalence wouldn't be called "equivalence")
08:22:23 <Solonarv_> here's the relevant section: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003
08:22:33 <hpc> deltasquared: the important realization to have here is that the type of memoFix unifies with the type of fix
08:22:49 <hpc> deltasquared: and fix expresses ordinary recursion, so memoFix must express recursion with extra behavior tacked on
08:23:01 <dolio> Well, I don't think variable naming is as important. :)
08:23:03 <hpc> this means you can abstract over recursion schemes
08:24:15 <Solonarv_> @let myFib y = y $ \self n -> if (n <= 1) then 1 else self (n-1) + self (n-2)
08:24:16 <lambdabot>  Defined.
08:24:40 <Solonarv_> > myFib fix 20
08:24:42 <lambdabot>  10946
08:24:43 <haasn> like, λx.x and λy.y are technically separate terms but you can define a meaningful equivalence relation for working with lambda terms that disregards this distinction?
08:24:48 <dolio> But, one thing you can do with the idea of distinguishing them is say that lambda terms are available as 'data' structures, rather than notation for functions.
08:25:05 <dolio> So you can inspect them by matching, which is inappropriate for functions.
08:25:05 <haasn> so put another way, I could define an equivalence relation where two functions are equivalent only if they have the exact same semantics, regardless of the internal representation?
08:25:07 <Solonarv_> > myFib memoFix -- would be the same thing but memoFix isn't in scope
08:25:10 <lambdabot>  error:
08:25:10 <lambdabot>      Variable not in scope:
08:25:10 <lambdabot>        memoFix :: ((Integer -> Integer) -> Integer -> Integer) -> t
08:25:22 <__monty__> Solonarv_: Thanks, couldn't find it. I assumed it'd be desugared as let...in... and since that's an expression would therefore be deemed an expression itself.
08:25:50 <dolio> And you can have both functions (denoted by lambda terms) and lambda terms as data in the same language.
08:26:06 <Solonarv_> __monty__: it *is* desugared to let ... in ... IIRC, but that's only as part of the overall do-block desugaring
08:26:14 <haasn> dolio: If you use lambda functions as data structures, say church bools, then a function with identical semantics would still "represent" the same number
08:26:23 <hpc> yahb doesn't have memoize either
08:26:23 <haasn> any operation you could do on that number (within the lambda calculs) you can do equally on the substitute
08:26:46 <hpc> but myFib memoFix would be faster and more memory-intensive for really large inputs
08:27:21 <dolio> No, I mean you can pattern match on the lambda term type.
08:27:42 <hpc> i can imagine debugFix s f = Debug.Trace s (f (debugFix s f))
08:27:46 <hpc> being quite useful too
08:27:46 <haasn> isn't the whole point of lambda-terms-as-data that pattern matching is just function application?
08:27:55 <__monty__> Solonarv_: Yeah, the desugaring's in that section too. I guess sugar is still a seperate syntactic entity though.
08:28:05 <dolio> No, that is 'data as lambda terms' not 'lambda terms that are data.'
08:28:06 <hpc> you might write myFib (debugFix "fib function") 20, and see how many steps it takes
08:28:19 <deltasquared> hpc: cheers for my daily dose of brain implosion anyways xD
08:28:23 <haasn> Ah, I see
08:28:52 <dolio> Or, representing data as functions, even. The lambda term part of denoting functions is kind of irrelevant.
08:29:19 <deltasquared> data as functions, functions as data... S-expr syntax for haskell and we'd be all set :P
08:29:21 <haasn> True, but wasn't this about the untyped lambda calculus to begin with? You don't have pattern matching in that 
08:30:02 <dolio> Well, it isn't what I'm talking about. I'm talking about, in general, making a distinction between lambda terms and functions.
08:30:45 <haasn> __monty__: true, but that applies to the entire do block - which *is* an expression
08:31:21 <haasn> it's like how "case x of A -> foo; B -> bar" is a valid expression, but "A -> foo" is not
08:31:35 <haasn> any context where the language tree expects an expression, you can put the former - not the latter
08:32:33 <Solonarv_> data Lambda d = Ap (Lambda d) (Lambda d) | Abs (Lambda (d + 1)) | Var (Fin d) -- here's a datatype for lambda terms, haskell already has functions ;)
08:33:06 <rain2> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/remote.pdf
08:33:29 <realloc> hi, when trying to install liquidhaskell for my project, it complains about dependencies. A lot of them seem to be outdated. Am I doing something wrong, or does liquidhaskell just use older versions of libraries? 
08:33:40 <realloc> *via stack
08:34:09 <Solonarv_> in more absurd terms: "[ 1, 2, 3 ]" is an expression, but that doesn't make "[" an expression, even though it's part of the whole
08:35:21 <haasn> Solonarv_: I would argue that the textbook definition of the lambda calculus is data Lambda = Var String | Abs String Lambda | App Lambda Lambda
08:35:42 <Solonarv_> I know, but then you have to mess about with alpha renaming
08:37:31 <Solonarv_> de bruijn indexes (which is what my example uses) obviate that
08:37:59 <haasn> Indeed; and there's also the separate question of whether you want to restrict your representation to only allow closed terms
08:38:21 <haasn> technically it would be justified to allow representing and working with lambda expressions with open variables
08:39:18 <Solonarv_> my example allows that! just have d > depth of your AST
08:39:49 <Solonarv_> d - depth-of-AST is the number of free vars it can have
08:39:53 <haasn> Oh, you're right
08:40:17 <deltasquared> haasn: erm, possibly dumb question to ensure I follow, would that require tracking which variables require substitution into the expression
08:40:37 <deltasquared> "hey, I reference x but I don't have that, gimme"
08:40:46 <haasn> if you want to evaluate it, sure
08:41:04 <haasn> or I should say "reduce"
08:41:06 <deltasquared> haasn: right, you could still inspect the tree and find open variable references just find
08:41:10 <deltasquared> *fine
08:42:17 <Solonarv_> that's a function you need to write anyway in order to implement the interpreter, so that's not very hard to do
08:42:27 <haasn> like maybe you could imagine reduce :: Universe -> Lambda -> Lambda
08:42:28 <deltasquared> nothing like taking a trip to the most abstract of computing while whacking your head on a shell script :P
08:42:36 <haasn> where Universe = [(String, Lambda)] or whatever
08:42:56 <deltasquared> or some map from var references to expressions. yeah that figures
08:43:29 <haasn> this is sort of how compilers work internally anyway
08:43:42 <haasn> like if you look at GHC, it uses concrete variables to represent pretty much everything, which requires renaming often
08:43:54 <haasn> rather than debruijn indices or other fancy constructions
08:44:58 <deltasquared> I wonder if compilers for imperative languages have such rigourous foundations
08:45:17 <Solonarv_> define "rigourous"
08:45:19 <deltasquared> it would not surprise me if they didn't, but I would like to think they did, given the somewhat more intractable tasks thrown at them
08:45:28 <haasn> GHC's foundations are anything but rigorous
08:45:36 <deltasquared> heh, ok then
08:45:43 <haasn> it's not even known whether haskell's type system is consistent
08:45:56 <deltasquared> erm, which meaning of consistency was this again
08:45:58 <haasn> because there are so many GHC extensions and modifications that "haskell's type system" isn't even something you can readily define
08:46:16 <Solonarv_> consistency in the sense of "you can't prove a falsehood", IIRC
08:46:18 <haasn> consistency here means that for example you can't write unsafeCoerce :: a -> b
08:46:36 <haasn> i.e., separate types are separate
08:46:56 <haasn> actually a number of features get added to GHC and then years later people find out they're inconsistent
08:46:58 <deltasquared> so, no way to magically make one become the other without knowing more about them?
08:47:00 <Solonarv_> or possibly consistency of the sense "for any x, you can prove x, or (not x), or neither; never both"
08:47:31 <haasn> for example there were times when you could use concoctions of GADTs, TypeFamilies and similar language features to coerce Int to Bool (or whatever)
08:47:43 <Solonarv_> I mean, unsafeCoerce is not magic - it (often, if you use it on random types) fails at runtime
08:48:00 <haasn> and in the case of GeneralizedNewtypeDeriving for example it eventually required coming up with the concept of type roles in order to patch this hole
08:48:19 <Solonarv_> other example: you can write unsafeCoerce using unsafePerformIO + a polymorphic IORef
08:48:26 <deltasquared> there's a latin quote that comes to mind that I found while reading about Void that seems a bit relevant here... I can't remember the original, but I think it's translation was "from falsehood comes anything"
08:48:39 <Solonarv_> "ex falso quodlibet", IIRC
08:48:58 <haasn> Solonarv_: right, but I mean you can't write unsafeCoerce or unsafePerformIO in haskell. If they weren't part of the standard library, you'd be unable to define them yourself
08:49:07 <haasn> the type system prevents you from being able to do so
08:49:13 <deltasquared> Solonarv_: bingo, that was the phrase
08:49:27 <cocreature> exfalso is one of my favorite coq tactics :)
08:49:57 <haasn> deltasquared: I think that's a different concern - namely whether or not haskell functions are required to terminate
08:50:08 <haasn> writing a :: Void doesn't require violating the type system
08:50:23 <haasn> in haskell it's trivial to do
08:50:27 <haasn> and it fully type checks
08:50:34 <haasn> :t let x = x in x
08:50:35 <lambdabot> t
08:50:45 <Solonarv_> you can write unsafePerformIO using unsafeIOtoST (or whatever it's actually called) + runST, as well - the rabbit hole never ends
08:50:46 <haasn> this passes through hindley milner etc. just fine, and gives you the correct result
08:50:52 <deltasquared> haasn: I wasn't bringing up Void in particular, just the phrase
08:50:57 <haasn> ah
08:51:36 <haasn> Solonarv_: I think actually all of those are GHC extensions anyway and not part of the haskell spec? :)
08:51:37 <deltasquared> reading the wiki article, I can see how a situation where you get a contradiction makes everything explode
08:51:47 <haasn> actually you can write unsafePerformIO using the features from the haskell spec only
08:51:51 <Solonarv_> haskell is horribly inconsistent if you include all the unsafe**** functions and other obvious candidates (like let x = x in x)
08:52:00 <haasn> the haskell spec includes the FFI and the FFI lets you write unsafe functions
08:52:22 <haasn> again I don't think `let x = x in x` and `unsafePerformIO` are in the same category of things
08:52:52 <Solonarv_> as far as the type checker is concerned, they can be
08:53:07 <shafox> I have a type as this: ```newtype Document = Document {
08:53:07 <shafox>     fields :: [Field]
08:53:07 <shafox> } deriving (Eq, Show, Read, Ord)```
08:53:07 <shafox> How do I calculate the length of the fields property ? 
08:53:16 <haasn> you mean like undefined :: IO a -> a ?
08:53:20 * deltasquared reads Russell's paradox
08:53:24 <Solonarv_> (unsafePerformIO :: IO a -> a; unsafePerformIO = let x = x in x) is a valid definition
08:53:26 <haasn> I guess that makes sense, I see now where you're coming from
08:53:36 <deltasquared> this gives me a chuckle in the sense of relief I'll never have to deal with this kind of thing
08:54:56 <haasn> I guess there's a more subtle interplay between the type system and the execution semantics here; like the type system prevents you from writing any variable that would break the type system in a way that it would be observable at runtime
08:55:14 <haasn> and breaking the type system means breaking that "safety net"
08:55:41 <haasn> almost like an event horizon - everything touched by something that broke the type system is hidden inside a black hole (literally)
08:55:55 <shafox> Is there any way to get the length of fields property from the newtype Document  
08:55:56 <shafox> ?
08:56:23 <cocreature> shafox: length . fields?
08:56:24 <deltasquared> haasn: I wonder what would the consequence of such an observeable runtime break would be could it occur... I guess something like C's undefined behaviour, generally meaning crashes on real-world inplementations?
08:56:25 <haasn> shafox: fields :: Document -> [Field]
08:56:37 <haasn> you can combine this with `length` in the way cocreature just elaborated
08:56:59 <haasn> deltasquared: yeah, actually let's see what the haskell spec says
08:57:17 <deltasquared> "thou shalt not blow up the type system"
08:57:32 <deltasquared> I need that on a t-shirt
08:58:34 <haasn> 03>If a function that is not pure is not imported in the IO monad, the system behaviour is undefined.
08:58:46 <haasn> so it literally is exactly that, undefined behavior
08:59:28 <deltasquared> haasn: so say you "forgot" to mark an imported C function unsafe...
08:59:55 <deltasquared> not surprising given that guarantee of eval order goes out the window in pure code
09:02:21 <shafox> cocreature: haasn this is what I can without getting an error: https://gist.github.com/shadow-fox/538a5a6d748067929ee5d76287b7f48c . However is there any alternate way to get the same ? 
09:03:11 <haasn> You don't need the definition of `allfields`
09:03:18 <haasn> `fields` is already that function
09:03:40 <haasn> you generally also don't need to prefix Prelude. for prelude functions like `length`
09:03:51 <haasn> (and indeed, you don't prefix the . either)
09:04:41 <the_2nd> I was using attoparsec to parse multiple items that were delimited by '\n'
09:04:57 <the_2nd> I now changed it to use '\0' but the parser fails
09:05:11 <the_2nd> the nuls are correctly present in the string
09:05:16 <shafox> haasn: as it was complaining from where the length is hence as I have text and bytestring dependency library. 
09:05:17 <the_2nd> did I hit some special case?
09:05:24 <haasn> shafox: Ah, okay
09:05:35 <haasn> Usually people e.g. import Data.Text qualified as T
09:06:02 <haasn> (but you could also import Prelude as P and use P.length to disambiguate in a slightly shorter way)
09:06:22 <haasn> the_2nd: show the code?
09:07:42 <shafox>  haasn thanks. will add that. 
09:07:56 <the_2nd> just noticed that I still had a skipSpace somewhere as well
09:08:09 <the_2nd> replaced it with skipWhile (== '\0')
09:08:16 <the_2nd> working now ;)
09:53:06 <Solonarv_> a lot of my imports end up looking like this: "import Data.Text (Text); import qualified Data.Text as Text"
09:57:53 <hololeap> how would i nest Parsers so that a big match can be broken down further? would i have to run `parse` in a do block and return `Parser (Either ParseError a)`?
09:58:42 <Rembane> hololeap: I usually make a parser that consists of more parsers.
09:58:52 <__monty__> alexelcu: Did you solve your dhall issues?
09:59:53 <alexelcu> __monty__: yeah, switched to a list 🙂
09:59:58 <cocreature> how do I exit on SIGINT when using gi-gtk? I tried adding "installHandler sigINT (Catch Gtk.mainQuit) Nothing" before calling "GI.Gtk.main" but that doesn’t seem to help
10:01:03 --- mode: glguy set +v ferdov_
10:01:45 <hololeap> Rembane: i've been starting to gather that what you described is *the* way to do it
10:03:30 <monochrom> Normally SIGINT is handled by the RTS, and it throws UserInterrupt :: AsyncException to your main thread.  Maybe you can do a "finally" for that.
10:03:56 <__monty__> alexelcu: Why'd you need a Map btw?
10:04:20 <cocreature> monochrom: right but it seems like GI.Gtk.main somehow messes with signals
10:04:22 <Rembane> hololeap: Does it make things harder than you think they should be?
10:05:23 <hololeap> Rembane: no, it's just that I generally start with big patterns and break them down if/when needed. it's just a matter of style, honestly
10:05:35 <alexelcu> __monty__: Because I’ve got a variable list of items identified by keys, and I need to look them up by key, so it really is a Map
10:05:38 <cocreature> ah unixSignalAdd from gi-gobject seems to work
10:05:46 <cocreature> no idea if that is the right way to do this but at least it works :)
10:06:33 <hololeap> also, i would like to know what interesting things can be done with the Monad instance of ParsecT
10:07:21 <monochrom> GTK is like stack.  It wants you to limit yourself to its ecosystem walled garden.
10:08:12 <__monty__> alexelcu: How can you look up by key if you don't know the key's gonna be there beforehand?
10:08:54 <__monty__> alexelcu: It sounds like maybe it *is* actually a record but just has a couple Optional fields.
10:09:00 <alexelcu> __monty__: the keys are received as input from web requests
10:09:31 <Rembane> hololeap: Yeah. You can use the Monad instance for ParsecT when a part of your parsing depends on an earlier already parsed value, or if you want to use do-notation to make it all prettier.
10:11:02 --- mode: glguy set +v Mrbuck
10:11:15 <Mrbuck>  Forimmutableobjects, thereisnodiﬀerencebetween a variable and an object diﬀerence  what does it mean ?
10:11:44 <Mrbuck>  For immutable objects, there is no diﬀerence between a variable and an object diﬀerence  what does it mean ?
10:11:49 <monochrom> ParsecT being monadic means you can exceed context-free languages.
10:13:11 <maerwald> monochrom: lol, gtk is so low-level you can hardly call it an ecosystem just because some simple wrappers exist to fix their hacky way of dealing with threads
10:15:02 <maerwald> multithreaded gtk apps are also no fun
10:15:13 <monochrom> Here is a wacky example.  You get to define a language in which a string begins with a CFG and the rest of the string is supposed to conform to that.  You can use a monadic parser to parse that.  You can't use an applicative parser.
10:15:44 <monochrom> Bacteria and viruses have their ecosystems too!  Don't dismiss the low-level rank-and-file guys!
10:15:59 <hololeap> let's say for example, you've got `line = manyTill anyChar endOfLine` and `keyVal = (,) <$> manyTill anyChar (string ": ") <*> anyChar`... is there any way to "glue" these together using a monadic `join` so the end result is just `Parser (String, String)`?
10:16:44 <maerwald> So you're calling stack a virus essentially? xD
10:17:24 <monochrom> Well I don't know.  Next thing you know, I'll be saying "stack is like GPL"...
10:18:26 <hololeap> it was supposed to be: `keyVal = (,) <$> manyTill anyChar (string ": ") <*> many1 anyChar`
10:18:38 <oo_miguel> hmm what am i doin wrong? I read some big file with : data <- readFile "foo"; then I run a couple of filters that just return some counts... let counts=map (someFilter data) filterParams... and finally I have: print $ show counts, which forces all the filters to be run and the file read at all
10:19:07 <oo_miguel> howver my ram gets filled, for some reason
10:20:13 <oo_miguel> if i run only one filter this does not happen (and the ram gets filled to the size of the file , approx 5gigs)
10:20:53 <oo_miguel> I would imagine haskell to load the file only once and access the same contents ... but for some reason this is not true
10:21:40 <cocreature> probably you are using "data" multiple times
10:21:54 <monochrom> hololeap: f <$> px <*> py = px >>= \x -> py >>= \y -> pure (f x y)  wherever >>= is available.
10:21:56 <cocreature> so while the first use is evaluated, it can’t be garbage collected so you end up with the whole file in memory
10:22:10 <oo_miguel> cocreature: I WANT The wohle file in mem
10:22:14 <oo_miguel> but only once
10:22:34 <cocreature> oo_miguel: can you show us some code?
10:22:45 <oo_miguel> ok wait, i will prepare some mini-example
10:22:55 <oo_miguel> might take a few minutes, brb
10:22:58 <cocreature> maybe the result of your filters is just large?
10:23:15 <monochrom> Is "data" of type [Char]?
10:23:19 <oo_miguel> yes
10:23:29 <oo_miguel> it is [Char]
10:23:41 <monochrom> You know that [Char] memory footprint is 24*n bytes if length is n?
10:24:25 <oo_miguel> monochrom: no I did not know this. should optimize this as well... ;)
10:24:39 <monochrom> You know that GHC uses copying GC i.e. double buffering so if you have m GB of heap then the actual memory footprint is 2m GB?
10:25:08 <oo_miguel> hmm I only tested with one filter OR many filters
10:25:15 <oo_miguel> maybe I will get the problem with 2 already
10:25:22 <oo_miguel> and in case of one it was garbage collected...
10:26:20 <monochrom> You can instantly reduce 24*n to 12*n if you switch to 32-bit GHC.
10:27:44 <oo_miguel> omg it also happens with just two filters (so it is the garbage collection only that saved me before)
10:27:56 <oo_miguel> So my 5gigs file ends up eating 32gigs of ram
10:30:32 <oo_miguel> I dislike the idea of switching to 32-bit ghc 
10:31:23 <oo_miguel> I assume Data.ByteString will serve me better than Char...
10:31:44 <hpc> only if the file is binary data
10:31:47 <hpc> if it's text, use Text
10:31:51 <oo_miguel> it is text
10:32:08 <oo_miguel> but ascii only
10:37:09 <dmwit> oo_miguel: It is usually easy to combine your multiple passes into a single one.
10:37:36 <oo_miguel> dmwit: aaah yes, you are absolutely right.. 
10:37:46 <dmwit> e.g. if you can make each pass into a monoid homomorphism from [Char] to some other monoid then tuples get you a monoid homomorphism from [Char] into a combined monoid.
10:37:51 <oo_miguel> dmwit: I do not need to iterate hunders of time over the same file. 
10:39:16 <cocreature> the foldl library is worth a look if you want to combine multiple independent passes into a single pass
10:39:27 <dmwit> > let average = (\(Sum n, Sum d) -> n / d) . foldMap (\x -> (Sum x, Sum 1)) in average [5, 10, 15, 100]
10:39:28 <lambdabot>  32.5
10:40:00 <dmwit> The common `average xs = sum xs / fromIntegral (length xs)` does two passes of `xs` and forces the whole thing into memory.
10:40:17 <dmwit> The above is an example of using the technique I described: make `sum` and `length` into monoid homomorphisms, then combine them with a tuple.
10:41:32 <dmwit> I guess these days I could even write `1` instead of `Sum 1`. =)
10:42:46 <cocreature> dmwit: doesn’t the fact that foldMap is a foldr screw you over here?
10:44:12 <dmwit> Hm. Does it?
10:44:29 <monochrom> You also need to fight against lazy evaluation. >:)
10:44:41 <cocreature> it seems like you really want a strict left fold here
10:44:44 <cocreature> not a foldr
10:44:56 <oo_miguel> Oh also I do not want to combine my passes.... each pass gives me other results which I need on its own
10:44:59 <Franciman> hi
10:45:27 <cocreature> oo_miguel: what do you mean by “need on its own”. why is a tuple/record that stores the results of all passes not sufficient?
10:45:51 <monochrom> "When confronted with a problem, some people go, 'I know, this is a monoid homomorphism'. Now they have three problems." >:)
10:46:04 <Franciman> given a term of applicative functor type, is it correct to consider it as a list of computations?
10:46:08 <oo_miguel> oh this would be sufficent, but I do not see this "tuple record" in the example given
10:46:16 <oo_miguel> just one combined value
10:46:20 <Franciman> which then get composed with <*>
10:46:30 <cocreature> (Sum n, Sum d) is the tuple you get back
10:46:39 <cocreature> that’s then combined but you can just not do that
10:47:25 <dmwit> That's okay. We can define many functions with the same type as `foldMap` that associate the operation different ways.
10:47:34 <dmwit> I have sometimes wished for a few more variants, really.
10:48:12 <dmwit> I have a tree-fold in Prelude.Dmwit that has saved me on a few occasions.
10:48:15 <cocreature> iirc there is a foldMap' in HEAD or at least I saw a patch for that at some point
10:48:49 <dmwit> (tree-fold: repeatedly cut the list into two-element chunks and combine each chunk. when you get to one chunk, return its value)
10:49:33 <cocreature> https://phabricator.haskell.org/D4924 + making sure you evaluate the elements in the tuple should behave properly
10:55:13 <oo_miguel> the (Sum n, Sum d) holds just wo values ?
10:55:16 <oo_miguel> two
10:56:28 <cocreature> I’m not sure what you are asking. a pair contains two elements sure
10:56:59 <oo_miguel> yes, so I do not understand how to apply all this to my problem with an arbitrary number of "passes"
10:57:11 <oo_miguel> and my requirement to process the result of each on its own
10:57:21 <cocreature> have a tuple with more elements?
10:57:54 <oo_miguel> can I create tuples dynamically?
10:58:08 <cocreature> if you really have a dynamic number of passes, use a list of results
10:58:31 <oo_miguel> I do not know the number of passes in advance, and I have hunderds of them
10:58:55 <oo_miguel> but probably I should redesign my approach anyway :P
10:58:56 <cocreature> also as I’ve mentioned, I would recommend that you look at the foldl library rather than foldMap as it’s easy to get the wrong performance characteristics using the latter
10:59:31 <oo_miguel> first I will switch to Text anyway, than I look for further optimization if required.. Thanks a lot for the ideas
11:05:43 <Rembane> In Servant client, I want to always set the Content Type request header to "application/json", even if I send nothing, since I'm working against a server that expects it and throws HTTP 415 Unsupported Media Type otherwise. How do I do that?
11:12:26 <dmj`> Rembane: put JSON in the content type, type API = “api” :> Get ‘[JSON] Int
11:14:18 <Zemyla> Should MonadCont be moved from mtl into transformers, since it's a Haskell 98 definable class?
11:15:10 <cocreature> I don’t think the split between mtl and transformers is Haskell 98 vs not Haskell 98, it’s transformer types in transformers and typeclasses that abstract over them in mtl
11:15:40 <Rembane> dmj`: Cool. Got it. I just got confused by things. 
11:18:10 <Zemyla> Yes, but MonadIO was part of transformers until it was moved to base.
11:20:16 <cocreature> Rembane: does that work? I would have thought that this only sets the accept header?
11:23:10 --- mode: glguy set +v Kaye_
11:23:29 <Kaye_> Hey all, could someone please explain to me the (?callStack :: CallStack) in these type constraints? http://hackage.haskell.org/package/simple-logger-0.0.4/docs/Control-Logger-Simple.html
11:23:35 <Kaye_> Googled around to no avail
11:24:24 <cocreature> Kaye_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#hascallstack
11:24:50 <geekosaur> also https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.12.0.0/GHC-Stack.html
11:25:33 <alexelcu> so how does one split by a regex in Haskell? 🙂
11:25:36 <geekosaur> which notes that the explicit one is an internal detail; the early implementation didn't have the HasCallStack alias
11:26:11 <Kaye_> So actually it's the ? and constraint part
11:26:38 <geekosaur> the ? marks an implicit parameter
11:27:19 <geekosaur> https://downloads.haskell.org/~ghc/8.6.1/docs/html/users_guide/glasgow_exts.html#implicit-parameters
11:27:40 <Kaye_> Perfect! That's exactly what I needed to read up on  this
11:27:41 <Kaye_> Thank you
11:27:41 <geekosaur> right, I shudl repoint to latest, tey fixed the links :)
11:27:43 <cocreature> that package should really be using HasCallStack instead. the fact that it works via implicit params is an implementation detail 
11:28:09 <geekosaur> right, they wrote that witht he early calstack impl that didn;'t have the alias yet
11:28:40 <Zemyla> alexelcu: There's no built-in regex library in Haskell, and generally anything that would use regexes in other languages uses parser combinators like parsec or Text.ParserCombinators.ReadP (in base) instead.
11:29:11 <dasli> I'm using `randomR` from the "random" package, and my results are not uniformly distributed in the range I specify
11:29:16 <dasli> Has anybody else experienced that?
11:29:57 <Kaye_> Hmm I see
11:30:41 <alexelcu> Zemyla: using parser combinators for splitting a string or other easy tasks sounds awful 🙂
11:31:41 <[exa]> alexelcu: not sure how that compares to pulling in a random regex library :]
11:32:48 <[exa]> alexelcu: (parser combinators are usually much more lightweight)
11:33:40 <Zemyla> And there really is one in base which isn't that hard to use. :V
11:34:32 <cocreature> parser combinators don’t really allow you to perform “split string at every position where this parser matches” in an efficient way
11:35:59 <cocreature> the insistence on using regex for everything in other languages is just as silly as the insistence on parser combinators for everything in Haskell
11:36:25 <cocreature> alexelcu: https://hackage.haskell.org/package/regex-compat-0.95.1/docs/Text-Regex.html#v:splitRegex looks promising
11:39:04 <Zemyla> Honestly, I've been thinking of trying to write a combinator-based regex library which would compile to DFAs, but it's pretty complex.
11:39:32 <cocreature> that sounds exactly like regex-applicative
11:39:36 <[exa]> Zemyla: too prone to complexity explosion. anyway there's regex-dfa
11:40:19 <Zemyla> cocreature: Yes, but that doesn't compile to a DFA. It still has loads of branching.
11:40:39 <cocreature> ah I see
11:41:04 <Rembane> cocreature: Yeah, but I got confused, Content Type headers are only went when PUT ot POST is used as actions. And I was using DELETE. 
11:42:02 <Zemyla> Also, does this define a valid MonadCont instance for all MonadTrans? And if so, how? I kind of wonder how the joins and returns don't accidentally lift the callCC behavior out.
11:42:08 <Zemyla> :t let { liftCallCC :: (MonadCont m, MonadTrans t, Monad (t m)) => ((a -> t m b) -> t m a) -> t m a; liftCallCC f = join $ lift $ callCC $ \k -> return $ f $ lift . k . return } in liftCallCC
11:42:10 <lambdabot> (Monad (t m), MonadTrans t, MonadCont m) => ((a -> t m b) -> t m a) -> t m a
11:42:15 * [exa] reading the list of warnings at Text.Regex.Posix, goes wow
11:44:24 <hololeap> how difficult would it be to create a ghc-equivalent to ccache?
11:45:59 <alexelcu> cocreature: thanks, I've imported that one — was initially discouraged by the `-compat` in the package name, but I can't find a splitting function in the other `regex-base` or elsewhere, my search fu is failing me
11:50:22 <[exa]> hololeap: depends on how easy it is to dig required information grom GHC. Internally, I guess you could easily glue it somewhere into compiler/main/GhcMake.hs or HscMain.hs
11:50:57 <cocreature> alexelcu: yeah, it’s kind of weird that it doesn’t seem to exist in a non -compat package. but afaict there is also nothing wrong with the -compat package so it should be fine
11:51:02 <[exa]> hololeap: ok probably not so "easily", more like in "ghc hacking easily"
11:53:59 <hololeap> [exa]: i just know so little about how ghc functions, i wasn't sure if there was something that would preclude a tool like this from ever existing
11:55:29 <[exa]> with gcc it works by gently asking the compiler about what are all files it's going to use and (speculation) comparing hashes of everything
11:57:29 <[exa]> not sure if ghc supports this right away but I don't see why it wouldn't be able to
11:58:48 <[exa]> (except perhaps for TH which requires some processing before being able to reliably create a list of source dependencies)
11:59:57 <Solonarv> ideally I think this should be something plugins can do - some sort of callback that lets GHC ask the plugin "hey I'm trying to load/compile this module, got anything?"
12:02:40 <hololeap> that would be awesome. i do a lot with haskell modules compiled in gentoo, and i spend a significant amount of time recompiling many packages just because a dependancy changed in some minor way.
12:07:04 <__monty__> Wouldn't new-build help with this?
12:07:57 <[exa]> in context of gentoo-portage package building? not sure
12:08:14 --- mode: glguy set +v xsusr
12:09:40 <hololeap> possibly... i've never heard of it before, but i'm looking into it now. the gentoo-haskell integration is always in need of improvements
12:11:53 <[exa]> hololeap: maybe there will be some -ddump option that will make it a trivial shellscripting exercise (there's -M option which works similarly to GCC's one)
12:13:03 <hololeap> it says "You can configure and build it using Nix-style local builds with this command"... what exactly is meant by "Nix-style"? i understand the general philosophy behind nix, but...
12:14:54 * hololeap isn't sure what "Nix-style" would mean
12:15:00 <cocreature> hololeap: hash the package configuration and all its dependencies and cache based on that
12:15:42 <Solonarv> something along the lines of "the output of a build depends only on its inputs (which are explicitly specified), as a pure function; so it can be transparently cached"
12:16:00 <hololeap> oh, that is essentially what is done with the gentoo/portage integration
12:18:06 <deviantfero> hey everyone
12:18:26 <deviantfero> I have a quick (maybe not so quick) question, what does deriving( Show ) do?
12:18:32 <deviantfero> more specifically, in this context
12:18:42 <deviantfero> https://wiki.haskell.org/Parsing_a_simple_imperative_language
12:20:02 <cocreature> deviantfero: it creates an instance of Show for the type
12:20:36 <deviantfero> and what would that mean in this context cocreature 
12:20:41 <deviantfero> sorry I'm really new to haskell
12:20:52 <deviantfero> and I can't see a definition of what is meant to be in this example
12:20:54 <cocreature> the Show typeclass allows you to convert things to strings
12:21:28 <cocreature> not sure if that is actually used here but being able to convert things to strings is pretty useful for debugging
12:23:10 <deviantfero> I'm guessing it is, I'm guessing the way it works is that you define, let's say BExpr as a bunch of possibilites
12:23:25 <deviantfero> and if it fits one of those, the data gets converted into a string...
12:23:30 <deviantfero> that's what I'm guessing
12:23:35 <cocreature> > show True
12:23:37 <lambdabot>  "True"
12:23:43 <cocreature> that uses the Show instance of Bool to convert True to a string
12:24:14 <cocreature> in your example you could do something like show (BoolConst True)
12:24:22 <cocreature> or print the AST that you get back from your parser
12:25:52 <Mrbuck> Hi 
12:28:23 <neo> .
12:29:16 <deviantfero> cocreature thanks so much
12:29:33 <deviantfero> for the explanation I mean, you put it in simple terms
12:29:35 <Guest81134> .
12:32:51 --- mode: glguy set +v MaoZeDong_
12:33:51 <MaoZeDong_> anyone here?
12:34:36 <BaneAliens> hi
12:35:50 <MaoZeDong_> i'm newbie in Haskell and good friends gave me advice to go here if i have questions :)
12:37:48 <Solonarv> plenty of people here, just ask away
12:37:54 <MaoZeDong_> but it seems here are not to many people
12:38:25 <Lycurgus> 1 thousand three hundred isnt enough?
12:38:58 <hpc> Lycurgus: it used to be 2000
12:39:03 <Solonarv> if you don't ask your question there is a 0% chance it gets answered
12:39:11 <Solonarv> ?where ask
12:39:11 <lambdabot> Don't ask to ask, just ask.
12:39:21 <Lycurgus> hpc yeah back in peak hs
12:39:44 <Solonarv> actually it may be because of a big purge there was a while ago
12:39:59 <Lycurgus> nah, it was down before that
12:40:41 <Lycurgus> actually is bouncing back up a lil
12:41:06 <hpc> a few months ago someone accidentally kicked everyone out of #haskell and a few other channels
12:41:12 <hpc> and it removed a lot of lurkers
12:41:53 <Lycurgus> well stuff isn't monotonic anyway
12:42:38 <Lycurgus> lang popularity usually is though
12:46:18 --- mode: glguy set +v yman
12:47:28 <Ariakenom_> join :: Ask (Ask x) -> Ask x
12:48:53 <yman> $ssl
12:49:23 <flogfr> Hey, in HDBC-PostgreSQL is it possible to extend the possibilities of SqlValue to some custom type
12:49:27 <flogfr> ?
12:50:14 <hpc> flogfr: use the Convertible class
12:51:39 <glguy> flogfr: The generic answer is that you can't extend a data type (like SqlValue) to have new possibilities beyond what it is already capable of expressing
12:52:01 <flogfr> hpc: not working the way I want. With the libpq, you send the parameters type of the prepare statement (kind of), and with the Convertible class, I was only able to convert my custom type (an enum for now), to a SqlString, but it doesn't match my prepared statement that should receive the parameter as a custome num type.
12:52:43 <flogfr> glguy: is it something ok to fork the library to add my custom types?
12:52:51 <flogfr> or there would be a better way?
12:53:00 <flogfr> (thanks for the answers)
12:53:19 <hpc> it sounds like your Convertible instance for your custom type needs to be fixed
12:53:37 <hpc> so it maps properly to what the database expects
12:54:27 <flogfr> what type is passed to the libpq?
12:55:12 <inkbottle> In `reads`, is the last letter 's' standing for String? (In `ReadS`, is the last letter 'S' standing for String?)
12:57:44 <flogfr> hpc: not sure what you're describing is possible
12:59:17 <hpc> how did you write the Convertible instance for your data type?
12:59:48 <flogfr> for instance: safeConvert _ = return . toSql $ "cat1" . which returns a SqlString
13:01:08 <flogfr> I would like my query parameter to be passed as my custom enum type. Which has a specific OID in my database. This custom OID should be send to the database with the libpq.
13:02:49 <hpc> so, that Convertible instance translates from your data type in haskell, to SqlValue
13:02:58 <hpc> which represents the postgresql data types
13:03:11 <flogfr> yes exactly
13:03:15 <hpc> so your Convertible instance should translate values of your data type into what you want to query on
13:03:35 <hpc> so the instance should produce SqlValues that are numbers with the right ids
13:04:11 <hpc> or if you can't do that (say you don't know the ids at compile time), then you should use a join in your query
13:04:23 <hpc> so the query itself translates the name to the id
13:05:33 <flogfr> my instance should produce SqlValue with the right oid* yes
13:05:49 <flogfr> but there's no such SqlValue in HDBC-PostgreSQL as my type is a custom one
13:06:32 <flogfr> I created an enum, let's call it "category" , and there's "cat1" , "cat2" , "cat3" in it
13:06:57 <flogfr> let's say my category enum type has the oid 1337
13:07:21 <flogfr> how from the Convertible instance I can produce a SqlValue with this oid to be passed in the libpq while running the query?
13:07:29 <flogfr> not sure it's possible without forking the library
13:07:36 <hpc> let's step away from haskell for a moment
13:07:47 <hpc> you're writing plain sql that does the query you want
13:07:58 <hpc> do you write a string or a number in the query?
13:08:10 <hpc> select * from foo where category_oid = ?
13:09:22 <flogfr> so in a psql session, I would do: "select * from foo where categories @> '{cat1}'"; And psql / PostgreSQL (not sure which one) would cast my '{cat1}' as a category[].
13:11:36 <flogfr> now if I use the libpq , with a similar query: "select * from foo where categories @> $1" , If I pass a string (with the related OID of the type text from postgresql which is 25) , it won't cast it to a my category[] type.
13:11:41 <flogfr> (same if it's not an array)
13:11:55 <hpc> ah, hmm
13:12:47 <[exa]> inkbottle: my guess is that S stands for Sequential because there's also ReadP which parses all possibilities in parallel
13:13:36 <inkbottle> [exa]: OK, thanks
13:21:43 <hpc> flogfr: what i see on https://www.postgresql.org/docs/11/static/arrays.html is that you can just pass the array in as an appropriately formatted string...
13:22:01 <hpc> flogfr: maybe make sure you're querying with SqlString "{cat1}" and not SqlString "cat1"?
13:22:27 <[exa]> flogfr: btw can you add an explicit cast(... as yourthing) around? also there might be a slight semantic difference from postgresql if you use the libpq version with prepared statements (that actually do call PREPARE)
13:22:59 <[exa]> *from psql
13:23:01 <flogfr> I don't do prepare statement, sorry if I said so. I'm using yeshql + hdbc-postgresql.
13:23:25 <flogfr> I will re-do my test with wireshark to see the query with the parameters.
13:24:53 <cocreature> flogfr: note that there is also yeshql-postgresql-simple which might be worth a look
13:25:15 <flogfr> cocreature: roger that, I'll look into it later
13:26:12 <[exa]> flogfr: we've had a funny story with a framework that PREPAREd the queries automatically and messed the postgresql types in weird ways.
13:27:24 <[exa]> btw setting log_statement='all' might be slightly more pleasant than digging it out of wireshark
13:28:07 <inkbottle> [exa]: There is also `shows` and `ShowS` in the "last letter is an 's'" pattern
13:28:54 <[exa]> my guess fails then, ShowP won't make much sense :]
13:29:26 <inkbottle> ;)
13:29:30 <flogfr> bien vu [exa] pour le cast, ca marche avec. Je trouve pas ca super propre mais ca fera l'affaire je pense :)
13:30:05 <flogfr> sorry :/ Good catch [exa] for the "cast". it works.
13:30:56 <[exa]> inkbottle: ...but wait! ShowS = String->String which is for construction of diff-string sequence :D
13:31:11 <flogfr> thanks hpc and [exa] 
13:32:02 <[exa]> flogfr: j'ai compris :]
13:33:01 <inkbottle> [exa]: OK, still working with "sequence" then ;)
13:35:17 <[exa]> anyway postgresql frontend structure has some simplifications that make automated type casting a bit magic, in the same way that e.g. in <9.4 table partitions couldn't be selected after the query was prepared
13:47:16 <rotaerk> neat https://www.youtube.com/watch?v=HnOix9TFy1A
13:48:41 <hpc> ooh
13:53:02 <mniip> how ever am I going to typeset an arrow category on IRC :(
13:53:24 <mniip> er
13:53:27 <mniip> a comma category
13:53:52 <Solonarv_> what's a comma category?
13:56:15 <mniip> Solonarv_, given F : E -> C, G : D -> C,  F↓G is a category where objects are <X:E, Y:D, f:FX->GY>
13:56:44 <Solonarv_> I see, I found the wikipedia article actually
13:56:58 <mniip> and arrows are pairs of morphisms in E and D respectively that make a square commute
14:00:40 <dmwit> rotaerk: If you already have sets as a datatype, why bother with sorted list insertion? If you don't have sets yet, and want to implement them as sorted lists, how do you specify that?
14:01:57 <rotaerk> *shrug*
14:03:01 <BaneAliens> anyone know what the warnings mean here ?
14:03:09 <BaneAliens> https://gist.github.com/Chuongv/e8de846faa2313e96cc1a820b0d1d1e7 is it because it's defaulting to Integer (==)?
14:04:42 <dmwit> No, it is defaulting `1`, `2`, and `3` to `Integer`.
14:04:59 <Tuplanolla> Try `2 ^ 8` in GHCi, BaneAliens.
14:05:01 <dmwit> (and, for completeness, this means that it is using `(==)` on values of type `Pair Integer`)
14:06:37 <Tuplanolla> The outcome is analogous.
14:07:18 <BaneAliens> hmm interesting, so with '2 ^8' I have to add in the type information otherwise I get those warnings
14:08:37 <BaneAliens> ahh I only get those warnings because I forgot I set it to -Wall
14:14:13 <BaneAliens> is my syntax wrong here? I'm trying to say 'a' and 'b' both conform to Eq 
14:14:14 <BaneAliens> instance Eq a b => Eq Tuple (a b) where
14:15:31 <Clint> (Eq a, Eq b) is not the same as Eq a b
14:18:22 <BaneAliens> so like this? 
14:18:24 <BaneAliens> instance (Eq a, Eq b) => Eq Tuple (a b) where
14:18:35 <BaneAliens> I'm still getting `Expected kind ‘* -> k0’, but ‘a’ has kind ‘*’`
14:18:48 <BaneAliens> Tuple is simply data Tuple a b = Tuple a b
14:19:04 <lyxia> Eq (Tuple a b)
14:20:02 <BaneAliens> ahhh yess, stupid me. Thanks :)
14:36:44 <mniip> wait
14:39:03 <MarcelineVQ> hurry, I'm cramping up
14:50:47 * Clint nods.
15:20:31 <eacameron> I want to upgrade mattermost module but 18.09 module doesn't let you specify the package of mattermost. Should I use an overlay to pull in a newer nixpkgs.mattermost on top of 18.09?
16:04:34 <inkbottle> I can't have readsTree from https://www.haskell.org/tutorial/stdclasses.html working: http://paste.debian.net/1048433/
16:20:22 <Axman6> it looks like that code relies on the pattern matching support in list comprehensions, if there is no '|' in  (l, '|':t) <- readsTree s, then that result from readTree will be skipped
16:21:03 <Axman6> at least in your readsTreeVar code
16:21:15 <inkbottle> reading...
16:22:07 <lyxia> inkbottle: look at the value of lex "|<"
16:22:09 <inkbottle> The readsTreeVar does work
16:22:17 --- mode: glguy set +v kaye
16:22:25 <inkbottle> lyxia: got it
16:22:36 <Axman6> I think lyxia ha spotted the but
16:22:41 <Axman6> has*
16:23:09 <Axman6> hmm, maybe not?
16:23:45 <lyxia> that looks like a bug in the report to me
16:26:15 <inkbottle> lyxia: So, I inserted two spaces in the second string ""<5| <6|3> >" and that did the trick
16:26:24 <inkbottle> bug or no bug, thanks a lot
16:26:34 <inkbottle> I wouldn't have found all by myself
16:28:08 <lyxia> yw
16:31:04 <inkbottle> Now: http://paste.debian.net/1048442/
16:31:35 <inkbottle> really thought it was the desugaring of the previous, but it says pattern matching non exhaustive
16:32:29 <inkbottle> I've read list comprehension is sugar for do notation...
16:35:44 <lyxia> You get a warning because that's not what do notation or list comprehension desugar to
16:36:08 <lyxia> on a partial pattern it adds a case with "fail"
16:38:59 <inkbottle> That's simply great explanation; could you point me out to a link about that? (the "fail" bit)
16:39:55 <hpc> there's not much to it
16:40:14 <notmike> Is it normal for /root/.cabal to exist if I've never even seen a proper piece of Haskell code?
16:40:41 <hpc> if you wrote do {(Just x) <- action; ...}, it desugars to action >>= \x -> case x of Just x -> ...; _ -> fail "pattern match failed on line 12345"
16:40:48 <lyxia> inkbottle: https://en.wikibooks.org/wiki/Haskell/do_notation#The_fail_method
16:40:53 <hpc> and what fail does depends on the instance
16:41:01 <hpc> > fail "doesn't matter" :: [Int]
16:41:02 <lambdabot>  []
16:41:27 <hpc> > fail "etc" :: Maybe Int
16:41:29 <lambdabot>  Nothing
16:41:34 <geekosaur> notmike, no butyour distribution may be doing something silly. arch runs soem commands if you install or remove haskell-based packages like pandoc
16:41:59 <notmike> geekosaur: is it generally ok to just leave it there in that latter case?
16:42:09 <geekosaur> I wouldn't worry about it
16:42:29 <inkbottle> lyxia, hpc: Great, thanks a lot
17:56:02 <dmwit> > do { False <- Right True; return () } :: Either String ()
17:56:03 <lambdabot>  *Exception: Pattern match failure in do expression at <interactive>:3:6-10
18:35:51 --- mode: glguy set +v Guest45
18:51:13 <Solonarv_> @let Test a = Err String | Val a deriving (Show, Functor)
18:51:14 <lambdabot>  Parse failed: Parse error: |
18:51:54 <geekosaur> data
18:56:28 <fragamus> how do guards work in the list monad
18:56:51 <fragamus> do they return something special
18:57:41 <fragamus> I mean how do they signal "you shall not pass"
18:59:20 <geekosaur> > fail "" :: [Int]
18:59:22 <lambdabot>  []
19:06:54 <fragamus> oh cool
19:06:58 <geekosaur> >>= in the list monad is more or less concat . map. so if mapping a function over some value in the original list produces an empty list, it disappears from the result and plays no further part
19:08:04 <fragamus> thanks geekosaur
19:47:54 --- mode: glguy set +v Ark
20:13:52 <fragamus> geekosaur are you here
20:59:38 <Geraldus> Hi friends! )
20:59:55 <Geraldus> Have a nice time!) 
21:02:45 <Axman6> hello!
22:21:50 --- mode: glguy set +v Guest56
22:26:06 <jackdk> what is the current recommendation for a typesafe file path library? I see path on hackage
22:26:10 <dmj`> @package github
22:26:10 <lambdabot> http://hackage.haskell.org/package/github
22:26:16 <dmj`> has anyone used this package?
22:49:00 <dminuoso> jackdk: It what sense would it be typesafe?
22:49:23 <jackdk> path tracks absolute and relative paths and is not just an alias for String
22:49:45 <jackdk> and distinguishes between files and directories
22:51:56 <cocreature> jackdk: "path" is your best choice there afaik
22:52:05 <jackdk> thought so. tyvm.
23:02:21 <piyush-kurur> hi, from yesterday onward I seem to have a problem with github being erratic, is it just me or others have also felt something
23:02:44 <dminuoso> piyush-kurur: https://twitter.com/githubstatus?lang=de
23:03:10 <piyush-kurur> dminuoso: okey good. I will just wait
23:33:46 <Geraldus> Hey friends!  Is it possible to declare Typeable instance of Either data type?
23:40:15 <int-e> > typeOf (Left () :: Either () ())
23:40:17 <lambdabot>  Either () ()
23:40:57 <terrorjack> Geraldus: I think not, ghc generates Typeable instances already (even without a deriving clause for that)
23:41:39 <dminuoso> terrorjack: It looks to me as if you could.
23:41:44 <phadej> you can still have `deriving (Typeable)` but it's there implicitly since 7.10 or so
23:41:58 <Geraldus> terrorjack: Yeah, looks like I solved my issue.  Let's see
23:42:02 <dminuoso> Not that you should have to, since like phadej said you can derive the instance.. :)
23:56:17 <nshepperd> +
