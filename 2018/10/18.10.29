00:00:28 <jle`> cocreature: i used to be more upset, but now i think it's not too bad because it's basically just foldMap
00:00:37 <jle`> with the Alt newtype wrapper
00:00:47 <jle`> :t \f -> foldMap (Alt . f)
00:00:48 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Monoid (Alt f a1), Foldable t) => (a2 -> f a1) -> t a2 -> Alt f a1
00:00:53 <jle`> :t \f -> runAlt . foldMap (Alt . f)
00:00:55 <lambdabot> error:
00:00:55 <lambdabot>     Variable not in scope: runAlt :: Alt f a1 -> c
00:01:01 <jle`> oof that original type signature
00:01:16 <jle`> :t \f -> getAlt . foldMap (Alt . f)
00:01:17 <lambdabot> forall k (t :: * -> *) (f :: k -> *) (a1 :: k) a2. (Monoid (Alt f a1), Foldable t) => (a2 -> f a1) -> t a2 -> f a1
00:01:31 <jle`> it's just foldMap with the Alt newtype wrapper
00:01:51 <jle`> but then again, we do have 'all' and 'any' in base, which is foldMap with the All/Any newtype wrappers
00:02:11 <jle`> and sum/product...which is foldMap with Sum and Product
00:02:16 <jle`> but at some point you have to stop i suppose
00:05:31 <cocreature> jle`: sure but that’s just as long as asum . fmap f
00:09:07 <jle`> i guess it's only useful if you don't have Functor f
00:10:06 <MarcelineVQ> what is?
00:11:26 <MarcelineVQ> Oh funny, for some reason I was thinking Functor was a superclass of Foldable, but it's of Traversable
00:13:40 <cocreature> MarcelineVQ: Functor being a superclass of Foldable would preclude instances like Set
00:14:48 <jle`> to me Foldable encompasses 'touch it and it breaks' type of structures
00:15:19 <MarcelineVQ> Set's always getting special treatment anyway, you know I heard when the plant shut down it actually got a bonus
00:15:46 <jle`> for foldable-polymorphic functions, you have to assume that anything you do with a foldable value collapses into a monoid
00:15:57 <jle`> so fmap is out of the picture
00:16:13 <aarvar> jle`: asum . fmap f . liftCoyoneda
00:16:23 <aarvar> no Functor required :)
00:17:18 <aarvar> or I guess that's just asum . Coyoneda f
00:17:45 <jle`> ah, that's a cute trick :)
00:18:16 <jle`> since the Foldable instance is foldMap (f . k)
00:18:26 <aarvar> right
00:18:53 <jle`> i stand corrected :)
00:19:12 <jle`> Coyoneda basically suspends the fmap until you foldMap it
00:19:26 <jle`> or asum in this case
00:19:54 <jle`> so you still can't ever directly observe the 'f a', it just nicely composes your monoidal collapsing functions
00:20:04 <aarvar> :t (asum .) . Coyoneda
00:20:05 <lambdabot> error:
00:20:05 <lambdabot>     Data constructor not in scope: Coyoneda :: a -> a1 -> [f a2]
00:20:36 <jle`> @let import Data.Functor.Coyoneda
00:20:37 <lambdabot>  Defined.
00:20:53 <aarvar> :t (asum .) . Coyoneda
00:20:54 <lambdabot> (Alternative f2, Foldable f1) => (b -> f2 a) -> f1 b -> f2 a
00:21:11 <aarvar> magic
00:21:21 <jle`> mathemagical
00:51:54 <dminuoso> cocreature: foldMap and traverse are beautiful beasts! For me they have been the definite proof that Haskell has the *right* abstractions. :)
00:52:14 <mniip> :t foldMap . foldMap
00:52:15 <lambdabot> (Foldable t2, Foldable t1, Monoid m) => (a -> m) -> t1 (t2 a) -> m
01:06:51 * hackage IOSpec 0.3.1 - A pure specification of the IO monad.  http://hackage.haskell.org/package/IOSpec-0.3.1 (WouterSwierstra)
01:37:50 * hackage language-docker 8.0.0 - Dockerfile parser, pretty-printer and embedded DSL  http://hackage.haskell.org/package/language-docker-8.0.0 (lorenzo)
01:52:09 <mniip> sm, re: your earlier question regarding hackagebot. No, that's an entirely new model
01:55:10 <mniip> ...not even written in haskell
01:55:52 <mniip> I thought why reinvent the wheel and picked up a "hip" IRC bot framework, turned out to be a can of worms
01:55:55 <MarcelineVQ> too earlier for my buffer :o
01:56:19 <mniip> MarcelineVQ, yes, that was 2 days ago
01:57:02 <mniip> about 42 hours ago
02:13:02 <bahamas> hello. I'm confused by something in this code https://bpaste.net/show/24ef2d70083d can anyone explain why the second argument to the `maybe` function isn't `return . Right`? since everything is happening inside the EitherIO monad.
02:14:08 <opqdonut> bahamas: return in EitherIO is the same as return (in IO) + Right (which is return in Either)
02:14:28 <opqdonut> :t return True :: EitherIO String Bool
02:14:29 <lambdabot> error:
02:14:29 <lambdabot>     Not in scope: type constructor or class ‘EitherIO’
02:14:29 <lambdabot>     Perhaps you meant ‘Either’ (imported from Data.Either)
02:14:32 <opqdonut> oh well
02:15:41 <bahamas> opqdonut: why is that?
02:16:21 <bahamas> a, it's how the monad is defined I think
02:16:24 <opqdonut> yeah
02:16:30 <MarcelineVQ> What is EitherIO from?
02:16:50 <bahamas> MarcelineVQ: it's from a tutorial about monad transformers https://two-wrongs.com/a-gentle-introduction-to-monad-transformers
02:16:56 <MarcelineVQ> ah ok
02:17:18 <Ariakenom> :t return
02:17:19 <lambdabot> Monad m => a -> m a
02:18:03 <Ariakenom> m = EitherIO means "return x" must have type EitherIO a
02:19:49 <bahamas> Ariakenom: yeah. I was working with the assumption that return just wrapped the value in the IO monad. that's what it meant at the beginning of the article, before we defined the EitherIO type
02:20:06 <bahamas> I just need to remember that `return` means wrap in the monad
02:20:46 <bahamas> I feel that `return` would be more intuitive if it was named `wrap`
02:20:59 <Ariakenom> you can use pure
02:21:01 <Ariakenom> :t pure
02:21:02 <lambdabot> Applicative f => a -> f a
02:21:43 <bahamas> Ariakenom: instead of return you mean?
02:22:08 <Ariakenom> yeah. many dislike return as a name actually
02:22:15 <mniip> return = pure, unless you're using some really really evil monad
02:22:29 <mniip> s/monad/type constructor with a Monad instance/
02:22:44 <Ariakenom> a non-monad Monad? :p
02:22:54 <MarcelineVQ> Others could say it better, my thinking goes  "pure a  is the action that does nothing and results in an a, it is purely a."
02:22:54 <mniip> something along those lines
02:26:06 <bahamas> MarcelineVQ: are there any arguments against calling `pure` `wrap`? it's probably my lack of experience, but I didn't think of `pure` to mean `lack of side-effects`
02:26:20 <Ariakenom> case sensitive terminology is nicely subtle  
02:26:28 <mniip> @let import Control.Monad.Free
02:26:30 <lambdabot>  Defined.
02:26:31 <mniip> :t wrap
02:26:32 <lambdabot> MonadFree f m => f (m a) -> m a
02:26:51 <bahamas> aha, it's taken
02:31:27 <dminuoso> bahamas: also if you look closely enough, "wrap" is the wrong notion
02:31:30 <dminuoso> it's rather a mapping.
02:31:50 <dminuoso> in the sense of `Identity a -> m a`
02:32:43 <MarcelineVQ> dminuoso: but now people will want to call it natural :O
02:33:17 <dminuoso> :)
02:33:35 <dminuoso> MarcelineVQ: though naturality is not enough, because `join` is also a natural transformation.
02:34:39 <MarcelineVQ> In the end naming is a fairly arbitrary thing, what's important is the types involved. Taken further I wouldn't mind it being called engraben, though I probably would mind am3nd#
02:35:06 <akr> Hi there, anyone knows how to perform a left join with haskelldb? Using restrict, I can make inner joins, but don't know how to do left ones
02:35:53 <MarcelineVQ> At least it's not agda, where the unicode spiders have spun their webs in the great and silent halls of madness
02:38:15 <bahamas> MarcelineVQ: naming is part of user experience. but I agree that the concept can be hard to capture in a single word like the concept signified by `return` is. and you don't want to call the function `putIntoActionThatDoesNothingAndReturnsValue` :)
02:38:19 <MarcelineVQ> Such pillars have been wrought there of constructed and inferred majesty that you can not see their end, and in so looking heavenward to try your balance is tipped, careful now, the silver strands anchoring those mighty obelisks are as razors.
02:40:32 <MarcelineVQ> ware the ides of \forall \alpha \beta . \alpha \rightarrow \beta  okay I'm done ^^;
02:41:28 <tdammers> bahamas: an additional challenge with Monad and similar typeclasses is that they're so abstract that the most accurate name for most things would just be the type signature
02:41:30 <MarcelineVQ> I'm one of those jerks that thinks putIntoActionThatDoesNothingAndReturnsValue is completely okay
02:41:59 <tdammers> monadicValueConstructedFromNothingButANonMonadicValue
02:42:42 <Ferdirand> ah, but we professionnals shorten it to "mvcfnbanmv"
02:46:18 <kreetx> is there a way to get the number of fields for an algebaric data constructor with the Data class?
02:46:54 <kreetx> I can get the number when the data constructor is a record, but can't find a way for those that have none
02:47:55 <mniip> "monadic value" is poor phrasing
02:50:00 <tdammers> true
02:50:13 <tdammers> avoiding it makes it even sillier though
02:51:01 <tdammers> soSupposeYouHaveAValueAndATypeOfKindTypeToTypeThatHasAMonadInstanceThenThisFunctionCanGiveYouAValueOfTheLatterIfYouPassTheFormer
02:51:11 <tdammers> i.e., Monad m => a -> m a
02:51:43 <MarcelineVQ> Well not let's not be silly, that's almost as weird as calling it  pointed
02:52:29 <tdammers> "return" is kind of unfortunate in a language that is about to accidentally approach mainstream levels of adoption
02:52:58 <tdammers> then again, "pure" is kind of unfortunate too, though for entirely different reasons
02:53:09 <MarcelineVQ> the 'monad of no return' is a suggestion that exists, dunno where it's at currently
02:54:21 <tdammers> just to play devil's advocate here, "singleton" is probably just as good a name - after all, we're constructing a value of type m a from a single value of type a
02:54:53 <tdammers> and it naturally matches up with the fact that it's a generalization of list/set/... singletons and the like
02:55:37 <tdammers> then again, it's questionable for things like Maybe or Either, and completely ridiculous for, say, IO or Cont
02:57:14 <Lears> > let singleton = pure in singleton 3 :: ZipList Int
02:57:16 <lambdabot>  ZipList {getZipList = [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
02:57:30 <MarcelineVQ> I'm okay with pure because it's doesn't make my google searches end up at tutorials for singletons in object languages, or an intermediate-step-lib for dependent jauntry. Which is a word I just made up that probably conveys exactly what I mean it to
02:57:37 <Putonlalla> :t moist -- You could just pick something meaningless.
02:57:38 <lambdabot> Applicative f => a -> f a
02:57:47 <Lears> Personally I like "embed".
02:58:05 <MarcelineVQ> I like lift but that shift sailed before I even knew what a ship was
02:58:12 <MarcelineVQ> ship sailed
02:58:45 <MarcelineVQ> lift0, lift1, lift2, lift3 :>
02:59:48 <jle`> i don't like the word singletons for haskell singletons
03:00:06 <jle`> i think the meaning is flipped
03:00:27 <jle`> singletons seems to imply that for a given type, there is one constructor
03:00:39 <jle`> but that's not the important part of a singleton as it is used
03:00:46 <MarcelineVQ> if it's any consolation richard isn't thrilled about it either, though I'm not sure it's the word, or just that the something better isn't implemented yet
03:00:48 <jle`> the important part is that for each constructor there is a specific type
03:01:04 <jle`> singletons would work just as well if there were multiple constructors that gave the same type
03:01:20 <jle`> the 'single' part isn't the important part
03:01:39 <phadej> jle`: bu there is exactly one constructor for a given type in `singletons`
03:01:40 <jle`> (although it does make them more practical)
03:01:45 <phadej> SNil :: Sing '[]
03:01:47 <phadej> e.g.
03:01:54 <jle`> yeah, but that's just an incidental thing, i think
03:02:01 <jle`> the single-property isn't the important feature
03:02:08 <phadej> Sing is type family, Sing '[] has only one inhabitant
03:02:09 <phadej> yes it is
03:02:28 <phadej> one-to-one is important
03:02:43 <jle`> wouldn't Sing Bool be just as well if it was data SBool :: Bool -> Type where SFalse :: SBool 'False, STrue1 :: SBool 'True, STrue2 :: SBool 'True ?
03:02:50 <jle`> s/,/;
03:03:10 <jle`> it would make things a little more inconvenient to totally pattern match
03:03:23 <jle`> but the important thing is that you can pattern match to get the 'True or 'False
03:04:02 <jle`> things work out a little nicer conceptually if it was one-to-one, but the one-to-one isn't the actual magic that makes them useful, i feel
03:04:27 <phadej> jle`: well, thaat STrue1/STrue2 singleton carries more information on term level, that is on type level.
03:05:01 <jle`> yeah, it does, so it's not a true singleton
03:05:06 <phadej> i.e. things like Sing Bool -> Sing Nat -- could be bogus
03:05:38 <phadej> sorry, -> SomeNat
03:06:00 <jle`> but isn't the useful part not the fact that there is one value per type, but the fact that there is one type per value?
03:06:09 <mniip> 10/29/2018 [12:57:42] <MarcelineVQ> I like lift but that shift sailed before I even knew what a ship was
03:06:25 <mniip> kleisliLift :: Kleisli m a b -> Hask (m a) (m b)
03:06:57 <jle`> i suppose all of the singletons in singletons are actual singletons, so it's not actually an incorrect name
03:07:01 <phadej> jle`: both.
03:07:09 <jle`> but it feels like the name emphasizes the wrong part of the design pattern
03:07:35 <phadej> it's just a name :)
03:08:06 <phadej> and if you don't carry OOP-legacy with you, it's not missleading name
03:08:13 <jle`> indeed, in the end i don't think it's of too much consequence...the original point was just a nitpick on the name alone ;)
03:09:52 <phadej> well, than you can nitpick on Monad name ;)
03:09:56 <phadej> '"Monad" means that which is one, has no parts and is therefore indivisible'
03:10:26 <mniip> funnily
03:10:34 <mniip> a monad is a triple
03:10:41 <phadej> indeed
03:10:51 <jle`> yeah, it makes it awkward when people who are aware of leibniz monad come to ask about CT/haskell monads
03:11:15 <ggole> So the APL people were right all along - who knew?
03:11:30 <jle`> although admittedly i don't think Triple would have been any better of a typeclass name
03:12:19 <jle`> class Etamu m where
03:12:22 <jle`>   eta :: a -> m a
03:12:25 <mniip> instance Monad Electron
03:12:25 <xourt> does anyone know how to get do: system-filepath-0.4.14:Filesystem.Path.Internal.FilePath -> String
03:12:27 <jle`>   mu :: m (m a) -> m a
03:12:47 <jle`> class Monoid m where
03:12:49 <mniip> jle`, just use a HKT definition of monoids
03:12:50 <jle`>   mon :: m
03:12:54 <jle`>   oid :: m -> m -> m
03:13:14 <shachaf> class Monad where monad :: Free m a -> m a
03:13:26 <shachaf> Er, Monad m
03:13:33 <shachaf> class Monoid m where monoid :: [m] -> m
03:13:38 <mniip> now that's kinda backwards
03:13:44 <shachaf> As long as you have one method the name's taken care of.
03:13:53 <jle`> i mean, the second one is close to what we already actually have :)
03:13:56 <mniip> also [m] isn't the free monoid in hask
03:14:00 <MarcelineVQ> xourt: https://hackage.haskell.org/package/system-filepath-0.4.14/docs/Filesystem-Path-CurrentOS.html
03:14:06 <shachaf> It's true.
03:14:31 <jle`> mempty = monoid []
03:14:36 <jle`> mappend x y = monoid [x,y]
03:14:37 <mniip> we're not in Set but rather in a category of dcpos
03:15:30 <mniip> data Tsil a = Lin | Snoc (Tsil a) a
03:15:53 <shachaf> > let x +++ y = fold [x,y] in N 1 +++ (N 2 +++ N 3)
03:15:56 <lambdabot>  N 1 ◇ ((N 2 ◇ (N 3 ◇ ε)) ◇ ε)
03:16:10 <shachaf> The real free monoid is FMList but it's kind of awful.
03:16:20 <jle`> yeah, i wonder if we could just have base Monoid be minimal (mempty | mappend)
03:16:29 <shachaf> Conclusion: Haskell is kind of awful?
03:16:51 <dstolfa> mniip: oh god this is too much
03:16:53 <merijn> jle`: Why?
03:16:54 <dstolfa> mniip: i can accept a snoc list
03:16:56 <dstolfa> but tsil
03:16:56 <mniip> data FreeMonoid a = FreeMonoid (forall m. Monoid m => (a -> m) -> m)
03:16:57 <dstolfa> no
03:17:07 <jle`> oh sorry, i meant minimal (mempty | mconcat)
03:17:08 <shachaf> That thing is called FMList, yes.
03:17:12 <xourt> MarcelineVQ: thank you
03:17:20 <mniip> shachaf, not sure where's the list part but okay
03:17:50 <merijn> jle`: I want you to know I feel offended at an heretofore unknown level by that suggestion...
03:17:53 <shachaf> https://hackage.haskell.org/package/fmlist
03:17:57 <shachaf> I didn't make up the name.
03:18:15 <jle`> or minimal ((mempty, mappend) | mconcat)
03:18:35 <jle`> merijn: well, mconcat :: FreeMonoid m -> m
03:18:39 <merijn> jle`: Mappend isn't required anymore due to Semigroup superclass
03:18:50 <jle`> yeah, semigroup throws a wrench into things
03:18:59 <shachaf> Anyway they can be infinite on both ends, or all sorts of odd things.
03:19:04 <merijn> You can pry semigroup from my cold dead hands...
03:19:06 <jle`> class Semigroup m where sconcat :: NonEmpty m -> m
03:19:19 <mniip> shachaf, ah so FM is not referring to "Free Monoid" at all
03:19:19 <jle`> class Semigroup m => Monoid m where mempty :: m
03:19:53 <shachaf> Fold Map vs. Free Monoid: Coincidence?
03:20:15 <mniip> I wonder, what would monoid laws look like if the elementary operation is mconcat
03:20:20 <mariatsji> hi, with "import Data.Aeson as Aeson" is it possible to infix the (.:) function like e.g. this? "mykey" Aeson.(.:) myVal" or do I need backticks somewhere?
03:21:24 <jle`> mariatsji: "mykey" Aeson..: myVal
03:21:36 <mniip> mconcat [x] = x; mconcat (mconcat xs:xss) = mconcat (xs ++ xss)
03:21:46 <mniip> does this seem enough?
03:21:52 <mariatsji> ty!
03:21:53 <shachaf> I think there's a nice way to phrase it.
03:22:42 <shachaf> Oh, right.
03:22:46 <shachaf> It's just saying it's a T-algebra
03:22:57 <mniip> a what now
03:22:59 <shachaf> "monoids are just free monoid monad monad-algebras"
03:23:08 <shachaf> https://en.wikipedia.org/wiki/Monad_(category_theory)#Algebras_for_a_monad
03:23:22 <mniip> ah
03:23:23 <mniip> those
03:23:47 <shachaf> So: mconcat (map mconcat xs) = mconcat (mconcat xs), and mconcat [x] = x ?
03:23:58 <mniip> neat
03:24:19 <mniip> this is the best recursive definition pair
03:24:45 <shachaf> Wait, no.
03:24:56 <jle`> ah, mirroring join (fmap join xs) = join (join xs), and join (return x) = x
03:24:57 <shachaf> mconcat (map mconcat xs) = mconcat (concat xs), and mconcat [x] = x
03:25:09 <shachaf> That makes more sense.
03:25:17 <mniip> a monad is just a monoid in the endofunctor category, a monoid is just an algebra of the free monoid monad
03:25:34 <shachaf> A monad is just an algebra of the free monad monad
03:25:51 <jle`> a monoid is just a monoid, what's the big deal?
03:25:55 <dminuoso> mniip: what is the reason the tensor is forgotten with that joke?
03:26:11 <shachaf> In general an X is just a T-algebra of the free X monad.
03:26:18 <mniip> it's not, you can have free monoids over different monoidal structures
03:26:28 <jle`> a monoid is just an algebra of the free monoid monoid, what's the big deal?
03:26:45 <mniip> and algebra you ask
03:26:53 <dminuoso> mniip: My point is, there's at least 2 monoids in the category of endofunctors that I can think of.
03:26:54 <mniip> that's just an algebra of the free algebra algebra
03:27:04 <dminuoso> And one is definitely not a monad
03:27:32 <mniip> shachaf, is X11 an algebra of the free xmonad
03:28:11 <shachaf> There are lots of monoidal structures you could put on that category, sure.
03:28:49 <shachaf> monoidal categories moproblems
03:28:59 <mniip> it's bimonoidal braided right?
03:29:07 <mniip> you can stack windows left, right, up and down
03:35:30 <shachaf> Remind me what the reason that (forall m. Monoid m => (a -> m) -> m) is a free monoid is?
03:35:36 <shachaf> I think I knew once.
03:36:37 <shachaf> Or at least I knew a bad reason.
03:37:50 <mniip> it's the free/forget adjunction
03:38:17 <mniip> given Hask(a, m) and the fact that m is a monoid you get Mon[Hask](FreeMonoid a, m)
03:40:47 <shachaf> I don't think I follow.
03:41:29 <shachaf> The (a -> m) argument is a function (a -> U m), you're saying?
03:41:30 <mniip> (a -> m) -> (Monoid m => FreeMonoid a -> m)
03:41:43 <mniip> Monoid m => (a -> m) -> FreeMonoid a -> m
03:42:05 <mniip> FreeMonoid a -> forall m. Monoid m => (a -> m) -> m
03:42:07 <shachaf> Where the arrow on the right is a homomorphism.
03:42:42 <mniip> 'forall' and the assumption that all monoid instances in scope are lawful ensures the homomorphity
03:43:13 <shachaf> Writing ~> for monoid homomorphisms, we have (F a ~> m) <-> (a -> U m)
03:43:33 <mniip> sure
03:44:26 <shachaf> Maybe that's not what you're getting at.
03:44:36 <mniip> the left-to-right is trivial so you're interested in the right-to-left map
03:44:45 <mniip> (a -> U m) -> (F a ~> m)
03:46:20 * hackage spdx 1 - SPDX license expression language, Extras  http://hackage.haskell.org/package/spdx-1 (phadej)
03:48:49 <shachaf> There's probably some complicated parametricity argument that you always get homomorphisms.
03:52:40 <shachaf> GHC internal error: ‘Ghci1.$trModule’ is not in scope during type checking, but it passed the renamer
03:52:44 <shachaf> thanks, ghc. thc.
03:57:08 <MarcelineVQ> shachaf: I get that sometimes when using holes in ghc 8.4.3, bumping down to 8.2.2 avoids it currently
03:57:20 <shachaf> Yes, looks like a known bug.
03:57:31 <shachaf> I just switched back to ImplicitParams like the good old days.
03:57:36 <shachaf> Just as good.
04:00:15 <MarcelineVQ> the one that gets me is when you don't import something but try to :t it with a type application. instead of saying, "What are you talking about, there's no liftA2 in scope." it says "I can't apply expression of type ..."
04:00:29 <MarcelineVQ> % foo @Maybe
04:00:29 <yahb> MarcelineVQ: ; <interactive>:19:1: error:; * Variable not in scope: foo; * Perhaps you meant `for' (imported from Data.Traversable); <interactive>:19:1: error:; * Cannot apply expression of type `t1'; to a visible type argument `Maybe'; * In the expression: foo @Maybe; In an equation for `it': it = foo @Maybe
04:00:32 <MarcelineVQ> % :t foo @Maybe
04:00:32 <yahb> MarcelineVQ: ; <interactive>:1:1: error:; * Cannot apply expression of type `t1'; to a visible type argument `Maybe'; * In the expression: foo @Maybe
04:00:47 <MarcelineVQ> :t foo
04:00:49 <lambdabot> error:
04:00:49 <lambdabot>     • Variable not in scope: foo
04:00:49 <lambdabot>     • Perhaps you meant ‘for’ (imported from Data.Traversable)
04:00:49 <mniip> because foo is a hole at that stage of compilation
04:03:02 <MarcelineVQ> People puttin holes in my text without any _ in sight? :(
04:06:07 <shachaf> OK, so the property you want is, for a homomorphism h, h = (\xs -> xs (\x -> h ($ x)) ?
04:06:21 <shachaf> Where xs is the FMList thing
04:07:03 <shachaf> ($ x) is a singleton, I suppose
04:07:10 --- mode: glguy set +v delYsid`
04:07:39 <delYsid`> Hmm, I cant seem to build ghc from git: *** No rule to make target 'utils/unlit/fs.c'
04:08:06 <MarcelineVQ> delYsid`:  did you  git submodule update  ? that's usually what gets me
04:08:59 <delYsid`> I did clone --recursive...
04:09:18 <shachaf> For any homomorphism h : FM a ~> m, h xs = foldMap xs (\x -> h (singleton x))
04:09:23 <shachaf> Makes sense.
04:09:46 <delYsid`> nope, submodule update didnt help either.
04:15:07 <mariatsji> hi, does anyone know of a built in type in Haskell that represents the Natural (non-zero) whole numbers?
04:15:29 <delYsid`> mariatsji: It is called Natural :-)
04:15:33 <mariatsji> awesome, ty
04:16:09 <MarcelineVQ> delYsid`: did you do your  cp mk/build.mk.sample mk/build.mk  edit build.mk for the build you want and   ./boot  ./configure  ?
05:25:08 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Identification or Voice(+v) require to chat during spam'
05:25:08 --- topic: set by glguy on [Thu Aug 02 09:06:52 2018]
05:36:10 <exarkun1> Anyone have anything neat for compiling Haskell type information into non-Haddock documentation (eg Sphinx)?  Or should I just be using Haddock all the time for everything...
05:44:09 <dmwit> I know of no other tool.
05:48:29 <dmwit> Taneb: I expect you'll have to fork a process and redirect its stderr. Is this possible in other languages? If so, have a look at the unix package, which offers roughly the same API as C for munging fd's and the like so should be sufficient if it's possible at all.
05:49:05 <merijn> dmwit: No you don't
05:49:12 <merijn> dmwit: Well, it depends
05:49:42 <merijn> dmwit: If you are confident your Haskell code is single-threaded you can simply redirect stderr for the duration of an IO action
05:50:00 <merijn> And base has all you need for that
05:50:50 <merijn> hDuplicate and hDuplicateTo are equivalent to dup and dup2 in C, which is all you need to redirect a handle
05:51:05 <exarkun1> Taneb: Did you already consider the obvious, making stderr an explicit parameter?
05:52:01 <merijn> exarkun1: Doesn't work if the IO a is coming from a library :)
05:53:33 <exarkun1> merijn: it does, it just takes more effort! (PR to library)
05:54:39 <exarkun1> The outcome is much better, so it might be worth it.  Forking and duping is all kinds of error prone.  Just writing to the right place to begin with is much better if you can swing it.
05:54:49 <asheshambasta> Has anyone had any issues with intero on GHC 8.4.4? It seems to be failing with allow-newer: true in my case.
06:06:10 <Taneb> exarkun1: I did consider that, but as merijn speculated it's an external library, so it's a slower (but I agree better) fix
06:12:32 <exarkun1> merijn: is it possible to be confident that your Haskell code is single-threaded?  How?
06:27:04 <gargawel> Hmmm. I have an old Hackage account, which I need to upgrade by entering my credentials. I have forgotten my password (I don't know that I actually changed it, but the one that was provided to me at the time does not work). It looks like I can't reset it (probably because it is too old). I never actually used it to upload anything, but would like to do so now. What should I do ?
06:28:34 <amx> #haskell-infrastructure might be a better fit
06:30:31 <dmwit> exarkun1: grep forkIO ?
06:31:29 <merijn> gargawel: Does it have an associated email?
06:31:41 <merijn> gargawel: If so the admins can manually upgrade and trigger the reset to your email
06:32:30 <Ariakenom> Async.concurrently (putStr "hello") (putStr "world")
06:32:39 <gargawel> merijn: Well, it probably has. I requested the account in 2013 from said email.
06:32:47 <tdammers> aww, I hate how SQLite transactions don't nest
06:33:02 <gargawel> I /suppose/ the admin that replied to me associated it to that account, but I can't be sure.
06:33:25 <gargawel> I'll send an email, then.
06:33:48 <dmwit> Ariakenom: Yep, need to grep all libraries, too. Just saying it is in principle possible to know (and maybe not even hard).
06:33:48 <merijn> gargawel: yeah, #haskell-infrastructure or email is the way to go if you still have access to the associated email
06:34:19 <dmwit> Of course it is not possible in general to answer one way or the other.
06:34:26 <Ariakenom> dmwit: so parse import list and grep their source?
06:34:29 <dmwit> But if your goal is single-threaded, it is pretty easy to achieve.
06:34:41 <dmwit> Ariakenom: Just ask cabal what your dependency tree is. cabal freeze
06:35:06 <dmwit> Take the nuclear option. Cut any dependencies which use forkIO.
06:35:08 <Ariakenom> (non-concurrent seems more accurate)
06:41:21 * hackage combinat 0.2.9.0 - Generate and manipulate various combinatorial objects.  http://hackage.haskell.org/package/combinat-0.2.9.0 (BalazsKomuves)
06:56:15 <greymalkin> Is there any way to get cabal to recognize that an hspec/quickcheck application is more than one test?  The final summary line is somewhat misleading in that it's 1 of 1 suites and 1 of 1 testcases despite the number of different properties tested.
06:58:17 * shapr hops cheerfully
06:59:41 --- mode: glguy set +v kolawole
07:00:53 --- mode: glguy set +v UnkDevE
07:05:53 --- mode: glguy set +v boxscapeR
07:06:26 <merijn> greymalkin: The detailed test interfaces was supposed to do that
07:06:35 <merijn> greymalkin: But afaik it's been stuck in limbo for years
07:06:56 <merijn> greymalkin: The exitcode interface everyone uses doesn't accommodate that sorta thing
07:07:20 <merijn> greymalkin: Although I'm sure people would love if you try and revive the detailed testing interface :)
07:08:32 <merijn> greymalkin: Given how undermanned cabal/cabal-install I wouldn't expect this to improve without someone offering to do the work
07:09:49 <CptCaptain> How would I go about writting this python snippet in Haskell? https://pastebin.com/w0tZHn7D
07:09:56 <greymalkin> Then there's the other problem: Is this big enough that I can suspend the work I'm doing now to make the detailed test work right? I'm obviously not the only one coming up with the answer "no".
07:10:52 <merijn> greymalkin: Sure, I get that :) But someone has to make the unreasonable choice sometimes :)
07:11:19 <merijn> CptCaptain: What's the part where you get stuck?
07:11:27 <CptCaptain> The mutable dict
07:11:40 <merijn> CptCaptain: You don't need one.
07:12:00 <merijn> CptCaptain: You're looping over the list and at every step adding/modifying a key to the dict, yes?
07:12:05 <CptCaptain> yes
07:12:31 <merijn> CptCaptain: So we have a dictionary and a list element and want an updated dictionary...
07:12:44 <merijn> :t foldl'
07:12:45 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
07:12:59 <merijn> CptCaptain: Imagine "b = Map String Int" or something :)
07:13:10 <CptCaptain> Aaaah, thanks. I'll try that.
07:13:34 <merijn> CptCaptain: Although, in this specific case you can do even simpler things (although writing out the fold solution is good practice!)
07:13:58 <merijn> :t M.fromListWith
07:13:59 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
07:14:44 <merijn> CptCaptain: Which says "given a function to combine two a's and a list of '(k, a)' tuples, build a 'Map k a'
07:14:44 <maerwald_> mutation feels more efficient here
07:15:22 <merijn> CptCaptain: So you can simply turn the string into a list of words, convert every word into a tuple (String, Int) and build the map directly
07:15:49 <maerwald_> and I would argue you haven't re-implementet the "algorithm" unless you use mutability
07:16:42 <merijn> maerwald_: I'm pretty confident about my guess that CptCaptain mostly cares about "convert this input into this result" and not so much about the "use a mutable map for this" :)
07:30:47 <rain2> suppose I have made a monad that is an interpreter for a programming language. I'm curious about how I might make a virtual machine to execute that programming language directly. Know of any guides on this?
07:31:30 <merijn> What does "execute that programming language directly" mean?
07:31:45 <[exa]> rain2: you need to output the VM code
07:35:24 <cppxor2arr> is anyone here familiar with Perlin noise?
07:37:44 <cppxor2arr> if i give the perlin noise function (x,y) as input (x and y change value by small amounts. definitely between 0~1) basically i can use it to generate smooth changing random values. perlin(x,y) and perlin(x+0.01,y+0.01) are close together for example
07:38:46 <cppxor2arr> but if i want to have infinitely generating terrain i'll keep changing these values (increase/decrease) and what if i hit the max bound of float/double?
07:40:10 <merijn> cppxor2arr: tbh, Double is huge, so that'll take awhile
07:40:14 <cemerick> why is the overlapping pragma required here? Shouldn't the `Num a` constraint completely disambiguate things? https://gist.github.com/cemerick/9d277f4b5b556f93fcf336842a436405
07:40:36 <merijn> cppxor2arr: A bigger problem is that Doubles aren't uniformly spread out, so the farther you go from 0, the bigger the gaps between samples must be
07:40:56 <cppxor2arr> :o ok
07:40:59 <merijn> cemerick: Constraints on instances are not considered when doing class resolution
07:41:17 <merijn> cemerick: Also, keep in mind String can (theoretically) have a Num instance
07:41:27 <merijn> cemerick: See, for example
07:41:29 <merijn> @hackage acme-php
07:41:30 <lambdabot> http://hackage.haskell.org/package/acme-php
07:42:02 <cemerick> heh, ok
07:42:03 <cppxor2arr> if i had a program that generated terrain similar to minecraft im guessing between restarts the seed changes so i can start perlin inputs from 0 again
07:42:29 <merijn> cppxor2arr: You have to "re-orient" every once in a while to keep precision
07:42:30 <cemerick> merijn: I didn't know about the resolution/constraint limitation though, thanks
07:42:38 <merijn> cppxor2arr: Or use fixed precision
07:43:04 <cppxor2arr> ok i think i get what you mean
07:45:09 <merijn> cppxor2arr: There should be a bunch of gamedev blogs talking about this and solutions for it
07:45:20 * hackage yampa-gloss 0.1.0.0 - A GLOSS backend for Yampa  http://hackage.haskell.org/package/yampa-gloss-0.1.0.0 (IvanPerez)
07:45:22 <cppxor2arr> thanks
07:46:08 --- mode: glguy set +v davenall
07:46:20 * hackage simple-vec3 0.4.0.9 - Three-dimensional vectors of doubles with basic operations  http://hackage.haskell.org/package/simple-vec3-0.4.0.9 (DmitryDzhus)
07:46:33 <`slikts> quick, what's a poset
07:46:56 --- mode: glguy set -v davenall
07:47:00 <haasn> cppxor2arr: failing that you could encode your stuff as an integer offset + a floating residual
07:47:57 <Ariakenom> `slikts: partially ordered set 
07:48:11 <`slikts> thanks for nothing
07:50:07 <`slikts> the diagram here helped: https://en.wikipedia.org/wiki/Partially_ordered_set
07:51:06 <fendor> how can i reverse in a repa array an arbitrary sublist? E.g. for 2-opt search in the tsp problem
07:51:15 <merijn> `slikts: A poset is a set where "compare :: a -> a -> Maybe Ordering", rather than "compare :: a -> a -> Ordering"
07:52:39 <`slikts> not claiming that it isn't, but are you sure that's accurate?
07:53:45 <`slikts> oh, right, reading further helped
07:53:45 <`slikts> thanks
07:54:12 <merijn> `slikts: Hence the name "partial" the ordering is only defined for *some* pairs, rather than *all* pairs
07:54:18 <`slikts> yeah
07:58:42 <hololeap> what flags are there that will reduce GHC memory usage during compile-time?
07:59:04 <merijn> hololeap: The GHC user's guide has a chapter on that, iirc
08:00:53 * hackage writer-cps-exceptions 0.1.0.0 - Control.Monad.Catch instances for the stricter CPS WriterT and RWST  http://hackage.haskell.org/package/writer-cps-exceptions-0.1.0.0 (minad)
08:02:21 * hackage persist 0.1 - Minimal serialization library with focus on performance  http://hackage.haskell.org/package/persist-0.1 (minad)
08:05:14 <hololeap> merijn: i don't see that. i see something on compiling programs faster, but nothing on using less memory in the process. i'm trying to compile on a machine with 4G of ram, and for some things it isn't enough. i would rather the programs compile slower and have GHC use less memory.
08:07:12 <merijn> hmm, I thought it talked about compiling with less memory too
08:32:13 --- mode: glguy set +v boris_rh_
08:37:29 <csaurus> I have a question about converting one type of transformer into another. I have a reader with environment A, and a reader with environment B which contains an A so there's a transformation between them both
08:38:05 <csaurus> is this a good candidated for mmorph, or monad-control? I assume there must be a common name or way to change actions in the second reader to actions in the first
08:38:22 <merijn> csaurus: Sounds like mmorph or even lens' zoom
08:38:36 <merijn> Nothing is ever a good candidate for monad-control :p
08:38:49 <merijn> monad-control is generally an indicator I need to revisit my design :p
08:38:53 <csaurus> merijn: ok, thanks ha. I was trying to wrap my head around it, but mmorph seems easier
08:39:27 <merijn> csaurus: mmorph stand for monad morphism, which is literally you asked about :)
08:39:46 <merijn> i.e. a morphism between "ReaderT A m" and "ReaderT B m"
08:40:23 <csaurus> yes exactly./ Or rather  a ReaderT B m -> ReaderT A m
08:40:40 <csaurus> I have a function I wrote that does this, but would rather use a common name or API to do it for readability
08:42:25 <csaurus> wait, I got my arrows switched around
08:43:51 * hackage gingersnap 0.2.2.1 - Tools for consistent and safe JSON APIs with snap-core and postgresql-simple  http://hackage.haskell.org/package/gingersnap-0.2.2.1 (TomBop)
08:43:52 <dmwit> :t withReaderT
08:43:53 <lambdabot> forall k r' r (m :: k -> *) (a :: k). (r' -> r) -> ReaderT r m a -> ReaderT r' m a
08:43:57 <dmwit> csaurus: ?
08:45:22 <dmwit> Use mmorph only if the ReaderT isn't visibly the top transformer.
08:45:26 <csaurus> dmwit: I think that would work as well, or at least simplify the function I wrote to do the convertion
08:46:46 <csaurus> The ReaderT is at the top. Basically I have an application config and a request specific configuration with a request UUID. I'd like to not dump that into the app config since other executables depend on it so I made a new type which contains a uuid and an app config
08:47:44 <csaurus> since the code is shared between two programs, one of which uses just the app config and one of which will sometimes use the request config that's why I asked about a function that can convert between them where needed for compatability
08:48:55 <csaurus> I've investigated a couple different designs and this is the best I could come up with
08:49:09 <merijn> csaurus: Honestly, sounds like lens' zoom is what you want
08:51:01 <csaurus> merijn: I will have a look at that, currently we don't use lenses
09:04:00 * hackage jmonkey 0.1.0.1 - Jmonkey is very restricted but handy EDSL for JavaScript.  http://hackage.haskell.org/package/jmonkey-0.1.0.1 (opyapeus)
09:13:52 <cocreature> /
09:14:06 <cocreature> sry
09:35:21 * hackage shell-monad 0.6.6 - shell monad  http://hackage.haskell.org/package/shell-monad-0.6.6 (JoeyHess)
09:38:41 --- mode: glguy set +v skregas
09:40:25 --- mode: glguy set -v skregas
09:41:26 <dminuoso> Hi. I have a sum type like `data Thing = A Int | B Int | C String ...` and some Get/Put instances. Now I'd like to have a clean mechanism that a user can *add* to this sum type together with Get/Put instances.
09:41:57 <dminuoso> What is the idiomatic way to allow a user of my library to extend that `Thing` type with additional constructors - in effect.
09:42:40 <bsima> I think the idiomatic thing is to use a type variable, not a concrete type
09:52:21 * hackage gingersnap 0.2.2.2 - Tools for consistent and safe JSON APIs with snap-core and postgresql-simple  http://hackage.haskell.org/package/gingersnap-0.2.2.2 (TomBop)
09:59:51 * hackage Agda 2.5.4.2 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.5.4.2 (AndresSicardRamirez)
10:41:51 * hackage hoauth2 1.8.0 - Haskell OAuth2 authentication client  http://hackage.haskell.org/package/hoauth2-1.8.0 (HaishengWu)
10:43:20 * hackage cabal-test-quickcheck 0.1.8.2 - QuickCheck for Cabal  http://hackage.haskell.org/package/cabal-test-quickcheck-0.1.8.2 (TimothyJones)
11:13:51 --- mode: glguy set +v davenall
11:27:25 --- mode: glguy set +v TyroIRCuser
11:31:31 <cemerick> how is `Data.ByteString.Char8.putStrLn` being aliased to `putStrLn` in my ghci, and how can I stop that?
11:32:19 <zachk> import qualified as ? 
11:32:48 <cemerick> sorry, tbc, this is prior to entering any expressions at all
11:33:22 <cemerick> my .ghci file only changes the prompt, FWIW
11:33:28 <zachk> cemerick, do you have stuff importing it in your .ghci file
11:33:30 <zachk> oh
11:34:14 <cocreature> cemerick: how are you launching ghci?
11:34:33 <cemerick> cocreature: `stack ghci`
11:35:26 <cemerick> it loads all of the modules defined in the current project, but I shouldn't expect their imports and such to affect the interpreter's top-level env, correct?
11:36:03 <cocreature> you might want to read https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#what-s-really-in-scope-at-the-prompt
11:36:50 <cocreature> in particular if you :load a module you are basically evaluating expressions in the context of that module
11:37:13 <cemerick> correct, I'd expect something like this if I were `:load`ing
11:37:26 <cocreature> pretty sure stack ghci does that for you
11:37:55 <cocreature> it dumps the path to the .ghci file it uses iirc, might need to enable some verbose options. that should show you the exact commands it runs
11:42:18 <cemerick> whew, ghci takes on the imports found in the `Main` module, didn't expect that
11:46:08 <Welkin> scotty certainly doesn't make it easy to include other wai applications. I have to do it by turning them into middleware, which feels awkward
11:46:21 <Welkin> I wonder if I should not use scotty at all for this and instead just use wai/warp directly
11:46:44 <Welkin> I got EventSource (server-sent events) working though, at least it looks that way right now
11:50:51 <dmj`> Welkin: Servant’s Raw endpoint work great for embedding other wai apps, like SSE / websockets
11:50:56 <dmj`> s/work/works
11:51:08 <Welkin> I know that, but I wanted something a little lighter than servant
11:51:25 <Welkin> I don't even need to use any monad transformers with this setup
11:53:30 <Welkin> also, hi dmj` 
11:53:38 <dmj`> Welkin: hi :)
11:53:43 <Welkin> do you still work a lot with servant?
11:53:52 <dmj`> Welkin: pm me
12:04:09 <bsima> cemerick: when did you switch from clojure to haskell?
12:05:18 <cemerick> bsima: "switch" sounds so…decisive :-P  I've been using haskell pretty heavily for ~ a year though, originally in conjunction with clash
12:06:17 <bsima> ah, yeah hardware stuff seems awkward with clojure
12:06:22 <bsima> the jvm and all
12:07:27 <bsima> and, what are you using clash for, if you don't mind me asking? 
12:08:27 <cemerick> the JVM isn't particularly a barrier there (viz. Chisel), but yeah, clojure is particularly unsuited to the task
12:09:47 <cemerick> I'm not using clash atm, that project came to a (positive) conclusion/hold ~June. It was "porting" a geological simulation workload from a ball of C++ to hardware
12:11:17 <bsima> cool
12:17:49 <bsima> anyone know of a good way to test asynchronous haskell code? Specifically an HTTP api with a background process?
12:18:47 <CptCaptain> Why does ClassyPrelude's head not work on lists?
12:19:02 <Welkin> make your api a library, then you can test it or run it for real
12:19:11 <CptCaptain> Couldn't match expected type ‘NonNull mono’ with actual type '[Int]'
12:19:27 <Welkin> CptCaptain: classyprelude is a big mess of custom type classes
12:19:33 <Welkin> just use the standard prelude
12:20:03 <cocreature> CptCaptain: because it’s partial on lists and iirc classy prelude tries to eliminate partial functions
12:20:23 <cocreature> there is fromNullable for a conversion
12:20:35 <Welkin> head is generally not what you want; use pattern matching instead
12:20:42 <Welkin> if you must, use headMay (safe head)
12:22:50 <CptCaptain> headEx also works.
12:23:01 --- mode: glguy set +v sakalli__
12:23:12 <Welkin> bsima: also see https://hackage.haskell.org/package/wai-extra-3.0.24.3/docs/Network-Wai-Test.html
12:24:07 <bsima> Welkin: yea, I'm working on a yesod project, so I've got yesod-test and all that
12:24:45 <bsima> I guess the best thing to do would be to open a channel and block until the async response I want is received
12:26:12 <cocreature> bsima: do you actually need to involve the channel at all? I would try to decouple the async processing from the actual task of computing the response from the input which can just be a regular function and then use that directly in your test
12:28:30 <bsima> cocreature: yeah that's a good idea, test at a "lower level" first
12:29:18 <bsima> the thing is that each request forks a background worker to do the work and store the result in the database
12:29:40 <bsima> i kinda wanted to test and make sure that works because I don't quite undertand all the moving parts
12:30:19 <the_2nd> how can I refresh the console output to e.g. make a progress bar? Similar to brick, just don't need all those features
12:30:46 <bsima> here's another way to ask it: can I be sure that this function won't hang or leak resources? https://www.stackage.org/haddock/lts-12.16/yesod-core-1.6.8.1/Yesod-Core-Handler.html#v:forkHandler
12:30:47 <cocreature> sure if you actually want an integration test that tests that this works correctly, then removing that part from your test isn’t that useful
12:30:52 <Welkin> the_2nd: use vty https://hackage.haskell.org/package/vty
12:32:47 <the_2nd> aw, Windows unsupported
12:33:12 <Solonarv> windows terminals are generally a bit iffy, that's not easily fixed by a lbrary
12:34:44 <cocreature> there are a few simpler packages, e.g., progress-meter. maybe one of those supports windows
12:36:08 <Welkin> the_2nd: I ran into the same issue when I wanted to use vty for a tutorial series
12:36:23 <the_2nd> I might just go GUI / Website then
12:36:26 <Welkin> but with it not working on windows, I thought that would be too exclusive
12:36:31 <Welkin> yeah
12:36:39 <Welkin> I ended up going that route too
12:36:41 <the_2nd> wanted to do TUI since that would be 'good enough' in my case
12:36:50 <Welkin> opengl or canvas
12:36:53 <Welkin> canvas is much easier
12:37:08 <the_2nd> I just need slightly formatted text
12:37:16 <the_2nd> so html + css would work just fine
12:38:34 <Welkin> oh?
12:38:37 <Welkin> you don't even need canvas then
12:38:40 <sssilver> is it true that Haskell programmers are a closely-knit bunch and everyone knows each other?
12:38:46 <Welkin> the things you can do with html and css are crazy these days
12:39:00 * hackage snap-extras 0.12.2.1 - A collection of useful helpers and utilities for Snap web applications.  http://hackage.haskell.org/package/snap-extras-0.12.2.1 (MichaelXavier)
12:39:57 <Welkin> look into the css `transform` property and `transition` for any animations
12:40:02 <Welkin> it is hardware accelerated
12:40:14 --- mode: glguy set +v sakalli__
12:40:20 <Welkin> there are also image masks you can use
12:40:23 <cocreature> sssilver: yeah I think that’s a fair assessment. the community as fairly small so a lot of people know each other
12:40:38 <isomorphismes> there seem to be about 5 HTTP packages in haskell. all self-described as simple/minimal/powerful/etc. How should I choose one?
12:40:47 <Welkin> isomorphismes: an http client?
12:40:56 <isomorphismes> Welkin: yes
12:41:04 <Welkin> what do you need it for?
12:41:10 <Welkin> are you writing a binding to an api?
12:41:15 <cocreature> if you want something low level http-client which is what pretty much everything builds upon
12:41:16 <Welkin> if so, use servant-client
12:41:32 <isomorphismes> Welkin: writing a website
12:41:49 --- mode: glguy set +v zincy_
12:41:59 <cocreature> if you want to cover a complete API, servant-client. if you want something for fairly simple requests I’d use "req"
12:42:16 <cocreature> why do you need an http client for a website? that sounds like something you need an http server for not a client
12:42:20 <isomorphismes> there’s wreq, req, Network.HTTP, http-kit, HTTP, ……
12:42:42 <zincy_> How do you import a module from a package that is specified as a path in the "packages" section of the stack.yaml
12:42:56 <cocreature> zincy_: take a look at the module name and import that
12:43:10 <cocreature> the path in the packages section is completely irrelevant when it comes to how you import it
12:43:20 <zincy_> cocreature: tried that but to no avail
12:43:30 <isomorphismes> after reading the “tour of go in haskell” I thought I would try do do my project in haskell (which people say nice things about) rather than golang. But in go it’s clear which http library to use: net/http (the standard one).
12:43:47 <Welkin> haskell is all about options
12:43:53 <Welkin> there is no defacto standard for anything
12:43:58 --- mode: glguy set -v sakalli__
12:44:00 <Welkin> there are always multiple options
12:44:04 <cocreature> zincy_: have you added the package to build-depends in your cabal file?
12:44:27 <Welkin> none of them are worse than the others, just depends on your taste and your needs
12:44:48 <zincy_> I added it to the dependencies in package.yaml
12:45:07 <zincy_> but then I get an error - MyPackage needed, but the stack configuration has no specified version 
12:45:48 <mizu_no_oto>  sssilver: No.  Prominent Haskell programmers know each other from e.g. conferences, but that's not particularly different from other languages.
12:45:49 <Welkin> as far as writing a web server application, use scotty if you are new to haskell
12:46:09 <Welkin> it is similar to sinatra or express
12:46:21 * hackage hpack-dhall 0.4.0 - hpack's dhalling  http://hackage.haskell.org/package/hpack-dhall-0.4.0 (philderbeast)
12:47:17 <cocreature> zincy_: that sounds like either your path points to the wrong package or the names don’t match up
12:47:29 <cocreature> zincy_: can you show us the stack.yaml file?
12:48:23 <hugbubby> idk if u have some kinda faq for this but what's the best book to learn haskell with
12:48:55 <hugbubby> for someone who's looking for thoroughness rather than brevity
12:49:08 <zincy_> https://pastebin.com/CC6ur3uB
12:49:10 <cocreature> isomorphismes: you still haven’t answered what exactly you want to do with the lib. that makes it somewhat hard to recommend something specific
12:49:22 <cocreature> for your typical website you need a server not a client as I’ve mentioned
12:50:03 <cocreature> zincy_: alright, can you show us the cabal file in ../../../myapp and the package.yaml file in .
12:50:05 <Welkin> hugbubby: you will need to read a lot of source code, anything in base will do
12:50:08 <Welkin> there is no single book
12:50:17 <Welkin> Programming in Haskell is a good one
12:50:39 <Welkin> do the UPenn CIS 194 course (Spring 2013): https://www.seas.upenn.edu/~cis194/spring13/
12:59:51 <max3> why do i get this compile error?
12:59:52 <max3> https://paste.rs/ybr.hs
13:00:37 <cocreature> max3: because in recent GHC releases Applicative is a superclass of Monad
13:00:49 <cocreature> so you need an Applicative as well
13:01:08 <max3> (Applicative m, Monad m) ?
13:01:24 <Welkin> that's already included as part of Monad
13:01:30 <cocreature> no you need to write an Applicative instance for MaybeT
13:01:30 <Welkin> you need an Applicative instance of your m
13:01:34 <max3> ah
13:01:54 <Solonarv> no, you need to write an instance: instance blah => Applicative (MaybeT m) where ...
13:03:01 <max3> lol and Functor
13:03:29 <cocreature> you can derive functor
13:03:51 <Solonarv> since this is clearly a learning exercise, it can be useful to write the instance yourself
13:03:52 <cocreature> you can also be lazy and use your Monad instance to implement your applicative instance
13:04:02 <cocreature> e.g. pure = return; (<*>) = ap
13:04:37 <max3> where is ap again? i forget
13:04:48 <cocreature> Control.Monad
13:04:49 <Solonarv> should be in Control.Monad
13:05:57 <max3> no instance of Monad m arising from use of 'return'
13:06:42 <cocreature> instance Monad m => Applicative (MaybeT m) where …
13:06:56 <max3> oh right
13:07:50 <mizu_no_oto> Can't you do `instance Applicative m => Applicative (MaybeT m) where …`?
13:08:16 <max3> and for Functor fmap = liftM right?
13:08:26 <tdammers> hmm, I wonder... we have do notation to make the pattern f >>= \a -> g >>= \b -> h nicer; but another common pattern is where you have a cascading series of "wrappers" (bracket and the like), each level introducing a binding, e.g. withDatabase $ \db -> withNetworkConnection $ \socket -> withFile "foobar.dat" $ \file -> something, and I wonder if there is a clever way to flatten that in a similar fashion
13:09:40 <Welkin> tdammers: newline after ->
13:10:01 <Welkin> same with desugared do-notation
13:10:05 <Solonarv> mizu_no_oto: yes, but not if you're using "pure = return; (<*>) = ap"
13:10:32 <tdammers> Welkin: yeah, but other than that?
13:10:37 <Solonarv> tdammers: there's a language extension in newer GHCs that lets you drop the $
13:10:49 <tdammers> Solonarv: that smells of PureScript :)
13:10:53 <max3> thanks
13:11:19 <Solonarv> well, it's purely syntactic and fairly unambiguous
13:11:42 <Welkin> I don't even like $
13:11:49 <Welkin> adding more ambiguity is a terrible idea
13:12:05 <Solonarv> $ *is* better than deeply-nested parens, IMO
13:12:57 <jle`> tdammers: that's ContT, isn't it?
13:13:20 <Solonarv> ah yes, you could use Contt
13:13:21 <tdammers> jle`: it might be, heh
13:13:28 <Solonarv> tdammers: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-BlockArguments
13:13:50 * hackage stratosphere 0.26.2 - EDSL for AWS CloudFormation  http://hackage.haskell.org/package/stratosphere-0.26.2 (jdreaver)
13:14:05 <tdammers> Solonarv: yep, just like purescript
13:14:25 <Solonarv> never used ps, I'll take your word for it
13:14:46 <jle`> :t ContT (withFile "foo.txt" WriteMode)
13:14:47 <lambdabot> ContT r IO Handle
13:14:51 <cocreature> tdammers: there is also gabriel’s "managed" package which is basically a specialized form of Codensity iirc
13:15:37 <cocreature> with Codensity being a restricted form of Cont where you need to accept a polymorphic continuation
13:15:40 <tdammers> just when I thought I was done learning, sheesh
13:15:46 <jle`> :t liftA2 (,) (ContT (withFile "foo.txt" WriteMode) (withFile "bar.txt" ReadMode))
13:15:48 <lambdabot> error:
13:15:48 <lambdabot>     • Couldn't match expected type ‘((Handle -> IO r1) -> IO r1)
13:15:48 <lambdabot>                                     -> f a’
13:15:50 <jle`> :t liftA2 (,) (ContT (withFile "foo.txt" WriteMode) (withFile "bar.txt" ReadMode)
13:15:52 <lambdabot> error:
13:15:52 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
13:15:52 <jle`> sorry
13:16:15 <tdammers> jle`: no worries, I already got it :D
13:16:17 <jle`> :t (,) <$> ContT (withFile "foo.txt" WriteMode) <*> ContT (withFile "bar.txt" ReadMode)
13:16:19 <lambdabot> ContT r IO (Handle, Handle)
13:17:01 <jle`> in do notation you can just match myHandle <- ContT $ withFile "foo.txt" WriteMode
13:17:06 <jle`> s/match/bind
13:19:07 <Solonarv> I wonder why withFile and friends don't have type "FilePath -> Mode -> (forall s. Handle s -> r) -> r" - would be nice to guarantee that the Handle can't escape
13:19:37 <tdammers> hysterical raisins, I guess
13:19:40 <jle`> intimidating error messages maybe
13:22:13 <cocreature> then people use lazy IO since base is full of it and things escape anyway :)
13:22:21 * hackage mpi-hs 0.3.1.0 - MPI bindings for Haskell  http://hackage.haskell.org/package/mpi-hs-0.3.1.0 (eschnett)
13:23:31 <Solonarv> hmm, is there a library that implements thusly-scoped withXXX functions?
13:25:21 <jle`> that'd be cute, but i think handles escaping is not really the big problem about these types of io functions
13:25:22 <cocreature> Solonarv: there is the regions package and various packages that build upon it such as safer-file-handles but they never took off
13:27:25 <hugbubby> So I hearz that haskell can do something like, create web pages
13:27:40 <hugbubby> I saw gwern's web page and tht it was apparently generated via haskell
13:27:42 <hugbubby> how do this
13:27:54 <hugbubby> what ort of wizardry enables him to perform this feat
13:28:12 <zachk> do you want to generate html or server a web page or both?
13:28:19 <zachk> serve a webpage even
13:28:27 <hugbubby> #1 please
13:28:43 <Solonarv> for a simple static website, hakyll is good
13:29:31 <Welkin> hakyll is specifically for a static blog
13:29:32 <hugbubby> I see, that appears to be what he uses. Thank u kind sir
13:29:42 <Welkin> for a static site, I use racket (pollen)
13:30:05 <Welkin> which is for making online books, but you can use it easily for any site
13:30:05 <hugbubby> I will now go look to create my own static blog
13:30:07 <tdammers> I feel obligated to shamelessly plug https://sprinkles.tobiasdammers.nl/ here, although that doesn't really qualify as "using Haskell"
13:30:08 <Solonarv> there a bunch of other haskell web libraries too
13:30:19 <dstolfa> tdammers: sprinkles... nice.
13:30:21 <Welkin> hakyll is not easy to customize though
13:30:31 <Welkin> if you want to do anything custom, I don't recommend it
13:30:55 <Welkin> I don't even use haskell for my static site any more, hence https://docs.racket-lang.org/pollen/index.html
13:31:47 <hugbubby> I'm not interested in customization. I just want to serve text.
13:32:40 <tdammers> .oO(scp *.txt server:www/)
13:32:47 <cocreature> there are almost more static site generators than websites using them so finding one should be fairly easy :)
13:33:12 <cocreature> tdammers: come on, at least be civilized enough to use rsync :)
13:34:25 <zachk> hugbubby, its easy to write a simple webserver using Scotty 
13:34:38 <Solonarv> if you don't even need rendering/routing you can just stick nginx on default settings or somethig on your server
13:35:44 <tdammers> cocreature: I could have used ftp
13:36:20 <tdammers> Solonarv: that's what I tried to hint at
13:37:46 <cocreature> tdammers: I’m sufficiently young to refuse to acknowledge the existence of ftp :)
13:38:21 <tdammers> shared hosting is still a thing
13:38:23 <Welkin> I have used ftp to transfer data across my local network, before usb 2.0
13:39:01 <Welkin> usb 1.1 was painfully slow
13:39:21 <Solonarv> I've actually used windows' network drive stuff for that, easier than ftp tbh
13:39:43 <Solonarv> (assuming all machines involved are windows, of course)
13:40:16 <tdammers> reminds me of the deployment script we had at my first real programming job
13:40:25 --- mode: glguy set +v boxscapeR
13:40:27 <tdammers> open two Windows Explorer instances side by side
13:40:45 <tdammers> navigate to your local working copy on the left, and to the production server on the right
13:40:51 * hackage sandi 0.4.3 - Data encoding library  http://hackage.haskell.org/package/sandi-0.4.3 (MagnusTherning)
13:41:06 <tdammers> painstakingly mark all the directories that need to be copied over on the left, and then drag them into the right window
13:41:23 <tdammers> careful though, if you drop them in the wrong place, or mark the wrong files, things will break
13:41:34 <Solonarv> yuck
13:41:47 <tdammers> I wrote an actual deployment script at some point
13:42:07 <tdammers> but it still required serious hand-holding, because Windows Server, at least back then, was hilariously bad at being scripted
13:42:09 <Welkin> there is a piece of dust in your trackball
13:42:11 <Welkin> and you mess up
13:42:40 <tdammers> IIS would sometimes silently fail to restart, just keep running the old code, and not tell you a thing
13:43:08 <tdammers> so we added a little version tag to the front page that we used to verify that the app had restarted
13:43:43 <tdammers> I pondered scripting that check, but decided not to, because if it failed, you'd have to intervene manually anyway
13:43:53 <Solonarv> > trackball
13:43:53 <Solonarv> that's how you know this is last-decade
13:43:55 <lambdabot>  error: Variable not in scope: trackball
13:44:05 <Solonarv> hah, lambdabot gets i
13:56:20 * hackage gingersnap 0.2.2.3 - Tools for consistent and safe JSON APIs with snap-core and postgresql-simple  http://hackage.haskell.org/package/gingersnap-0.2.2.3 (TomBop)
13:57:51 * hackage lambdabot-trusted 5.1.0.4 - Lambdabot trusted code.  http://hackage.haskell.org/package/lambdabot-trusted-5.1.0.4 (BertramFelgenhauer)
13:58:50 * hackage lambdabot-core 5.1.0.4, lambdabot-irc-plugins 5.1.0.4, lambdabot-novelty-plugins 5.1.0.4, lambdabot-haskell-plugins 5.1.0.4, lambdabot-social-plugins 5.1.0.4, lambdabot-reference-plugins 5.1.0.4, lambdabot 5.1.0.4, lambdabot-misc-plugins 5.1.0.4 (BertramFelgenhauer)
14:23:34 <__monty__> I'm still working on an exercise implementing subtraction for church encoding. I'm running into an occurs check error I don't understand: http://ix.io/1qoQ
14:24:13 <__monty__> I had to introduce fix because of a similar infinite type error but I don't see why the type of (\m -> m id) has to be infinite.
14:25:27 <jle`> __monty__: an 'infinite' type error doesn't quite mean that the type is infinite, but rather that the two can't unify because of infinite descent/recursion
14:25:41 <jle`> __monty__: it's trying to unify a with (a -> a) -> a
14:25:51 <jle`> it's trying to pick a type variable 'a' that matches 'a' with (a -> a) -> a
14:25:54 <jle`> but it's not possible
14:26:11 <__monty__> Yes, but I don't understand where the constraint is coming from.
14:27:21 <c_wraith> for what it's worth, church numerals usually require rank 2 types so that polymorphism is preserved.
14:27:50 <jle`> because of what 'n' takes, it expects the first argument to be 'a', but instead it apperas to be (\m -> m id), which is (a -> a) -> a
14:27:55 <jle`> but yeah, what are the definitions of Church?
14:28:01 <jle`> you might be losing some polymorphism
14:31:33 <__monty__> newtype Church = Church { runChurch :: forall a. (a -> a) -> a -> a }
14:31:56 <__monty__> And RankNTypes is in the pragmas.
14:32:51 * hackage fused-effects 0.1.1.0 - A fast, flexible, fused effect system.  http://hackage.haskell.org/package/fused-effects-0.1.1.0 (robrix)
14:41:15 <jle`> hm, maybe try using runChurch instead of pattern matching out Church
14:42:14 <c_wraith> ah, good point.
14:42:26 <c_wraith> the pattern match fixes the type variable
14:46:10 <__monty__> Without the pattern matches, and a small change because I wasn't covering the case where m == 0. It's still the same error: http://ix.io/1qp5
14:53:52 <hugbubby> I just read something very peculiar in learnyouahaskell
14:54:33 <hugbubby> https://imgur.com/a/FPkXYh1
14:54:50 <hugbubby> Why would anyone ever use the ++ operator, then?
14:55:37 <hugbubby> http://learnyouahaskell.com/starting-out
14:55:49 <hugbubby> just use the inverse :, right?
14:56:56 <dminuoso> juanxc: What is the inverse :?
14:57:00 <hexagoxel> :t (:)
14:57:01 <lambdabot> a -> [a] -> [a]
14:57:05 <hexagoxel> :t (++)
14:57:06 <lambdabot> [a] -> [a] -> [a]
14:57:12 <dstolfa> hugbubby: because ++ is "append" or "concat" of lists. cons is a type constructor taking only one element. if you cons (or snoc) enough things, you're walking through the list effectively :-)
14:57:56 <hugbubby> what's cons? ':'?
14:58:01 <Solonarv> yes
14:58:06 <dminuoso> hugbubby: yes. (:) is pronounced cons
14:58:31 <hugbubby> shouldn't the compiler pick which one is better or is that something I have to do?
14:58:44 <dstolfa> they're not the same thing, though
14:58:46 <hugbubby> x ++ y and y : x are all the same to me, right?
14:58:49 <dstolfa> they serve a different purpose
14:58:51 * hackage lens-typelevel 0.1.1.0 - Type-level lenses using singletons  http://hackage.haskell.org/package/lens-typelevel-0.1.1.0 (jle)
14:58:53 <dstolfa> :t (:)
14:58:55 <lambdabot> a -> [a] -> [a]
14:58:55 <dstolfa> :t (++)
14:58:57 <lambdabot> [a] -> [a] -> [a]
14:59:00 <dstolfa> note the difference between [a] and a
14:59:03 <hugbubby> hm
14:59:12 <hugbubby> i see
14:59:21 <Solonarv> no, they're not - the left argument of (:) is a single element, the left argument of (++) is an entire list
14:59:57 <jle`> > 1 : [2,3,4]
14:59:59 <lambdabot>  [1,2,3,4]
15:00:00 <jle`> > [1] ++ [2,3,4]
15:00:02 <lambdabot>  [1,2,3,4]
15:02:55 <hugbubby> I guess what I'm wondering is: why can't haskell optimize [1,2,3,...10^9] ++ 1 to [1] : [1,2,3...]
15:03:27 <hugbubby> Or do those both take the same amount of time to process?
15:04:20 <ystael> hugbubby: you seem to be under the impression that those two expressions are the same. the second is a type error, and even if it were corrected to 1 : [1,2,3,...,10^9], it would not be the same as the first.
15:04:41 <ystael> actually the first is a type error also, it should be [1,2,3,...,10^9] ++ [1].
15:04:48 <hugbubby> yeah I mixed them up
15:04:53 <hugbubby> ++ is the one that requires lists
15:05:03 <hugbubby> But why would they not output the same thing?
15:05:06 <ystael> the first expression sticks the 1 on at the right end. the second expression sticks the 1 on at the left end.
15:05:19 <dstolfa> hugbubby: try it out! :-)
15:05:23 <dstolfa> ghci is great for testing things quickly
15:05:33 <dstolfa> hugbubby: [1,2,3] ++ [1] and 1 : [1,2,3]
15:05:46 <jle`> > [1,2,3] ++ [1]
15:05:47 <lambdabot>  [1,2,3,1]
15:05:50 <jle`> > 1 : [1,2,3]
15:05:52 <lambdabot>  [1,1,2,3]
15:06:05 <jle`> sorry i spoiled it
15:06:34 <hugbubby> its ok I already went back into ghci and checked it out
15:06:42 <hugbubby> lol
15:07:33 <hugbubby> What about [1] ++ [2,3,4,...10^9]? Will it optimize that with :? I just tried somethign similar and it outputted the same thing.
15:07:55 <jle`> it doesn't need to optimize it
15:08:00 <jle`> because just look at the definition of (++) :)
15:08:08 <jle`> [] ++ ys = ys
15:08:16 <jle`> (x:xs) ++ ys = x : (xs ++ ys)
15:08:32 <jle`> here we have (1:[]) ++ [2..], so that matches the second pattern
15:08:42 <hugbubby> where can I find these definitions :O
15:08:46 <jle`> so it is equivalent to 1 : ([] ++ ys)
15:09:00 <jle`> and [] ++ [2..] matches the first pattern, so it's just [2..]
15:09:16 <jle`> so [1] ++ ys reduces to 1 : ys
15:09:39 <jle`> [1]++ys  ==>    1:([] ++ ys)   ==> 1 : ys
15:09:57 <jle`> hugbubby: you can find them at the haddocks/documentation
15:15:53 --- mode: glguy set +v isomorphismes
15:16:40 <isomorphismes> cocreature: I don’t want to go into lots of detail in a public room. Yes, it should be a server not a client. I guess I was hoping that a few of the HTTP libraries I mentioned are duds that haven’t been removed from hackage.
15:25:45 <zachk> @src (++) -- hugbubby 
15:25:45 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:25:49 <zachk> @src (++) 
15:25:50 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
15:25:54 <zachk> -_-
15:26:30 <danza> ^^
15:27:08 <hexagoxel> hugbubby: look for the "source" links on the right, e.g. on https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-OldList.html
15:27:46 <hugbubby> kewl, thx
15:29:52 <hexagoxel> hugbubby: and in general, you can use one of the search engines, like https://hayoo.fh-wedel.de/?query=(%2B%2B)
15:30:32 --- mode: glguy set +v boxscapeR
15:30:51 --- mode: glguy set -v boxscapeR
15:35:36 <delYsid> Given (xs,ys), how do I get all split points?
15:36:21 * hackage aeson-schema 0.4.1.3 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.4.1.3 (ChristianMarie)
15:46:41 <boxscapeR> > uncurry zip ([1,2,3], [4,5,6]) -- something like this delYsid? Or did you mean something else?
15:46:44 <lambdabot>  [(1,4),(2,5),(3,6)]
16:07:18 <koz_> Are we getting linear types in GHC 8.8, or is it further down the road than that?
16:10:25 <c_wraith> depends on how implementation goes
16:11:28 <koz_> Ah, OK. I was just curious, because it seems cool.
16:16:21 <c_wraith> I wish it didn't change the lexical rules of haskell types.
16:16:48 <jle`> it's not even quite approved yet, koz_ 
16:16:56 <Solonarv> huh? oh you mean because the linear arrow is written "-o" ?
16:17:08 <jle`> it's conditionally accepted pending some critical changes/problems be solved
16:17:09 <c_wraith> and the various forms of quantified arrows
16:17:53 <c_wraith> I'm fine with syntactic changes, but lexical changes make me have to think a lot harder, because I'm no longer sure if I'm even tokenizing correctly.
16:17:57 * dminuoso ponders about the interaction between ImpredicativeTypes and affine types GHC
16:18:04 <Solonarv> is that a "breaks existing code" worry, or a "makes the parser more complex" one?
16:18:07 * dminuoso sees deep black crashes incoming
16:18:11 <Solonarv> ah you answered before I finished typing
16:19:00 <c_wraith> dminuoso, I mean... "broken". ImpredicativeTypes is broken already. mixing it with anything else can't help. :)
16:19:28 <dolio> They should just remove ImpredicativeTypes.
16:19:52 <dminuoso> c_wraith: Didn't I hear someone once say that "nobody is sure whether ImpredicativeTypes is broken, because they dont know what it *means* in Haskell"?
16:20:06 <c_wraith> wasn't it slated for remove in like 6.12 and it just never actually went away?
16:20:11 <c_wraith> *removal
16:20:17 <dminuoso> Or rather "what it is supposed to do/how it is supposed to work"
16:21:18 <boxscapeR> is the linear arrow actually  written -o? I saw that in SPJ's talk, but other than that I mostly saw ->.
16:21:25 <dminuoso> boxscapeR: yes
16:21:27 <boxscapeR> okay
16:21:37 <dminuoso> boxscapeR: he calls it "lollipop"
16:21:43 <boxscapeR> right, I remember
16:22:06 <dolio> lollipop is the official name.
16:22:55 <dolio> http://www.lix.polytechnique.fr/~dale/lolli/
16:23:01 <c_wraith> dminuoso, in concept it's not so bad, but actually using it would require a lot of annotating "instantiate this type variable impredicatively" annotations. trying to make it work without those is a mystery
16:23:36 <shachaf> Is using lollipop to indicate a linear map (between modules) justified or a confusing pun?
16:23:47 <c_wraith> hmm. got lost mid-sentence again. fortunately the only problem was redundancy
16:23:48 <boxscapeR> (the rendered syntax page of the proposal still says ->. but I suppose they do also say that the syntax will change)
16:26:14 <shachaf> I guess the justification is that it's a symmetric monoidal closed closed category or something.
16:27:33 --- mode: glguy set +v nksegos_
16:34:00 --- mode: glguy set +v jackdk
16:34:00 --- mode: glguy set -v jackdk
16:35:12 --- mode: glguy set +v binary181
16:35:16 <binary181> hi
16:38:58 <binary181> just updated arch linux but when i log into xmonad now, it shows for 2-4 seconds then logs be back out to the login screen
16:40:15 <glguy> binary181: You'll probably get better help in #archlinux or #xmonad unless you have a Haskell error message you need help understanding.
16:43:21 * hackage cacophony 0.10.1 - A library implementing the Noise protocol.  http://hackage.haskell.org/package/cacophony-0.10.1 (jgalt)
16:44:54 <benzrf> ⅋ is befuddling
16:48:34 <shachaf> It is if you think of linear things as resources, which you probably shouldn't.
16:52:38 <t7> is that the buyers choice operator?
16:54:19 <dminuoso> shachaf: why not?
16:54:41 <shachaf> Because ⅋ will befuddle you.
16:54:55 <dminuoso> shachaf: of course!
16:55:23 <shachaf> why not?
16:55:37 <shachaf> I get it now.
16:55:48 <dminuoso> :)
16:56:10 <benzrf> well, i think ive found the clearest understanding in game semantics, buuuut the multiplicative fragment of linear logic is not complete for the the game semantics i was reading about, so...
16:56:25 <shachaf> get a better game semantics hth
16:56:42 <benzrf> link me one pls
16:56:57 <shachaf> https://www.sciencedirect.com/science/article/pii/S0168007297000468
16:57:00 <shachaf> hth
16:57:27 <shachaf> Also you can read Mike Shulman's article.
16:57:29 <benzrf> hmm, i'll take a look
16:57:32 <shachaf> It's not game semantics but it's good.
16:57:33 <benzrf> does it extend to full ll
16:57:39 <benzrf> what article is that
16:57:50 <shachaf> https://golem.ph.utexas.edu/category/2018/05/linear_logic_for_constructive.html
16:57:55 <benzrf> oh lol yeah i started reading that
16:57:57 <benzrf> then i left it in a tab
16:58:23 <benzrf> but ⅋ still feels slightly mysterious to me even in that context, i think... maybe i should finish the article.
16:58:29 <shachaf> It uses the Chu construction but that's not the only reason it's good.
16:58:41 <shachaf> "A proof of P⅋Q consists of both (1) a construction of a proof of Q from any refutation of P, and (2) a construction of a proof of P from any refutation of Q. A refutation of P⅋Q is, like for P∨Q, a refutation of P together with a refutation of Q."
16:59:16 <benzrf> yes i read that
16:59:48 <benzrf> i think that basically recapitulates my understanding that i had from the blass game semantics
17:00:26 <benzrf> i dunno.
17:02:09 <benzrf> when i read this page http://llwiki.ens-lyon.fr/mediawiki/index.php/Sequent_calculus the additives binary connectives make good sense to me, and so do ⊗_L and ⅋_R (insofar as they just tell you what the commas mean), but ⅋_L and ⊗_R dont quite click for me, i think mostly because i dont really understand ⅋
17:02:54 <benzrf> perhaps i'm trying to think about resources...
17:03:33 <benzrf> is computability logic worth reading about
17:04:21 <benzrf> oh wait lol it's by the same guy as this paper
17:05:06 <shachaf> Do you like A^⊥ ⅋ A?
17:06:02 <benzrf> sure, but mostly because i know it means lollipop :^)
17:06:08 <benzrf> well, it also makes sense to me from a game standpoint
17:06:11 <johnw> if I have data Foo (f :: * -> *) = Foo (f (Foo f)), and I want to derive Show for this, is there a way with GHC <8.6 to do it without needing quantified constraints?  That is, I think in 8.6 the easiest thing to do would be: deriving instance (forall a. Show a => Show (f a)) => Show (Foo f), but I'm not sure how to say this for GHC 8.4...
17:06:38 <mniip> johnw, Show1 can do it I think
17:06:48 <mniip> and I mean the liftShowsPrec business, not the other kind
17:06:50 <benzrf> ooooooooh https://benzrf.com/uploads/929f371feef29591.png
17:06:53 <benzrf> that's quite interesting
17:08:29 <johnw> mniip: Ok, trying
17:09:20 <mniip> instance Show1 f => Show (Foo f) where showsPrec d (Foo x) = showParen (d > 10) $ showString "Foo " . liftShowsPrec showsPrec showList 11 x
17:09:45 <mniip> where the inner showsPrec is a recursive use of the one we're defining
17:10:24 <johnw> mniip: doesn't work
17:10:33 <mniip> how come
17:10:39 <johnw> Show1 wants (* -> *), and my type is (* -> *) -> *
17:10:50 <mniip> you don't instance Show1 Foo
17:10:55 <johnw> ah
17:10:55 <mniip> you Show1 f
17:11:10 <mniip> and from that follows Show (Foo f)
17:11:14 <johnw> got it
17:11:43 <mniip> actually in this specific the "other kind" would have sufficed
17:11:52 <johnw> hmm.. showsPrec for this type wlil be huge
17:11:53 <phadej> johnw: http://hackage.haskell.org/package/recursion-schemes-5.0.3/docs/src/Data.Functor.Foldable.html#line-473
17:11:53 <mniip> instance Show1 f => Show (Foo f) where showsPrec d (Foo x) = showParen (d > 10) $ showString "Foo " . showsPrec1 11 x
17:12:01 <johnw> I'm trying to use Text.Show.Deriving to automate it
17:12:06 <mniip> ha!
17:12:26 <johnw> phadej: great example
17:12:46 <mniip> I wrote literally the same in my correction :P
17:12:52 <phadej> https://github.com/phadej/language-pts/blob/master/src/Text/Show/Extras.hs this might be useful
17:12:55 <johnw> yeah, you did :)
17:13:27 <mniip> showsQuad huh
17:13:28 <phadej> https://github.com/phadej/language-pts/blob/34b3c3fa6ebf756bca2ede5343fd672ef80960d4/src/Language/PTS/Term.hs#L182
17:13:44 * mniip showsQuints
17:14:55 * geekosaur squints
17:15:55 <johnw> following the same pattern, but this fails: instance NFData1 f => NFData (Instr f) where
17:16:26 <phadej> writing that kind of Show instances of that kind is "easy" for human, but hard for machine as finding out whether it needs to >>= <$> <*> or $
17:17:03 <mniip> johnw, fails how
17:17:18 <johnw> Could not deduce (NFData (f (Instr f)))
17:17:55 <mniip> did you use rnf1 instead of rnd
17:17:56 <mniip> rnf
17:18:20 <johnw> i didn't give a body yet
17:18:23 <johnw> this was just an instance head
17:18:31 <mniip> it's trying to default using generics I think
17:18:37 <johnw> ah, that makes sense
17:18:37 <phadej> yes
17:20:27 <benzrf> shachaf: ack! https://benzrf.com/uploads/afd5f6c41e59b3e3.png
17:20:45 <benzrf> i think linearity over affine-ness was precisely one of the things i was having trouble getting a feel for
17:21:10 <benzrf> a proper extension of even affine logic, it says
17:21:16 <benzrf> that certainly doesn't sound complete to me!
17:21:35 <benzrf> er, doesn't sound like something with respect to which CLL is complete
17:25:43 <benzrf> lol when he talks about resources he conveniently doesnt seem to mention ⅋
17:32:02 --- mode: glguy set +v hpc
17:32:29 --- mode: glguy set -v hpc
17:32:33 <benzrf> "affine-ness"... "affinity", perhaps?
18:49:51 * hackage confcrypt 0.1.0.3 -   http://hackage.haskell.org/package/confcrypt-0.1.0.3 (ChrisCoffey)
19:00:21 * hackage cuckoo-filter 0.1.0.2 - Pure and impure Cuckoo Filter  http://hackage.haskell.org/package/cuckoo-filter-0.1.0.2 (ChrisCoffey)
19:18:52 --- mode: glguy set +v icyrock
19:19:18 <icyrock> trying to install dhall-json with stack
19:19:26 <icyrock> using lts-12.16
19:19:36 <icyrock> stack install basement runs into this issue
19:19:42 <icyrock> hsc2hs: .stack-work/dist/x86_64-linux/Cabal-2.2.0.1/build/Basement/Terminal/Size_hsc_make: runProcess: runInteractiveProcess: exec: permission denied (Permission denied)
19:19:45 <icyrock> how do i troubleshoot?
19:20:22 <glguy> icyrock: Are you building on a partition that has noexec set?
19:21:57 <icyrock> running on /home
19:22:14 <icyrock> mount doesn't show noexec
19:25:10 --- mode: glguy set -v icyrock
19:26:05 <icyrock> glguy: are you building with lts-12.16 perhaps? just checking if it works on your end
19:26:46 <lone_ranger> is it possible to define a function in foldl and use it or does it have to be defined before hand?
19:28:48 <glguy> lone_ranger: You can use a lambda if you want
19:29:01 <glguy> foldl (\x y -> my function)
19:30:29 <lone_ranger> glguy: ok, but outside of that it doest work right?
19:32:43 <MarcelineVQ> > foldl (let g x y = y : x in g) [] [1,2,3] -- could use let if your prefer
19:32:45 <lambdabot>  [3,2,1]
19:33:54 <MarcelineVQ> Whatever you write though you're in the middle of an expression, so it has to be syntacticly valid for it to be there
19:34:48 <geekosaur> what do you mean by "work right"?
19:43:41 <lone_ranger> geekosaur: I mean if I cannot use a lamba the foldl will not work
19:44:04 <lone_ranger> but MarcelineVQ gave a good example
19:44:27 <lone_ranger> never thought of using let that way
19:44:52 <glguy> icyrock: No, I haven't tried to build dhall. It requires far too many dependencies (making it not useful as a configuration language though that seems to be what it's suggested use is)
19:49:14 <glguy> It looks like your error is with the "basement" package, which is another I avoid, but I was able to build basement using stack just now. I don't use stack either (I'm really not the one to be helping you with this) but to get more help I'd recommend pastebinning all the information you have about the problem like what versions of tools you're using, what full commands and error output you got, etc
19:49:35 <icyrock> glguy: thanks, you were right. i was running stack itself in /home, but stack was using /tmp behind the scenes, which has noexec
19:49:39 <glguy> This command `stack ghci --resolver=lts-12.16 --package basement` was able to build basement
19:50:27 <icyrock> glguy: interesting, your /tmp doesn't have noexec?
19:51:31 <glguy> Most don't (mine included)
19:52:03 <realfascism> has haskell got a database? like cassandra is BARf java
19:52:05 <realfascism> ?
19:52:17 <icyrock> glguy: got it. well at least i got it solved. thanks for the pointer!
19:53:40 <geekosaur> realfascism, mostly we bind to existing databases instead of reinventing the wheel
20:01:02 <Squarism> if i declare a class with a (type family) data declaration : "class Foo a where ; data Bar a"  and "instance Foo SomeType ; data Bar SomeType = Int". Cant I use "Bar SomeType" for Int's wherever Foo is imported?
20:01:45 <glguy> No, Bar is declared as a data family, not a type family there
20:02:09 <glguy> and you've defined Int as a new data constructor
20:02:21 * hackage yesod-recaptcha2 0.3.0 - yesod recaptcha2  http://hackage.haskell.org/package/yesod-recaptcha2-0.3.0 (ncaq)
20:02:45 <Squarism> glguy, ah thanks. That sorted it
20:11:06 <realfascism> I would like world better if java .net was all replacd with haskell
20:11:18 <realfascism> maybe I just have good taste I duno
20:38:45 --- mode: glguy set +v shafox
20:38:58 --- mode: glguy set -v shafox
20:41:10 <nitrix> Nothing guarantees that things would be necessarily any better. We'd have to try it to find out.
20:41:37 <geekosaur> and available tech isn't the issue, convincing people is the issue
20:41:40 <nitrix> If that was the case, Haskell would probably be exposed to a new set of problems and use cases not anticipated and the language would possibly need some adaptations.
20:42:07 <nitrix> Some of which might affect your "good taste".
20:43:26 <MarcelineVQ> self-control... pie-day...
20:43:36 <koz_> MarcelineVQ: Wat.
20:43:47 <koz_> It's not 3/14.
20:43:51 <MarcelineVQ> koz_:  some things don't need a response :>
20:45:12 <nitrix> One example that I have in mind is how we ended up still having mutable data structures in our immutable language.
20:46:21 <nitrix> realfascism: The ideal is the ideal, and then there's practice. To Java's defense, it didn't start out by being the monster that it is today. That's a discussion better had on ##programming though.
20:47:43 <MarcelineVQ> koz_: not that you don't need one, I meant the subject
21:28:51 * hackage extensible-effects-concurrent 0.8 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.8 (SvenHeyll)
21:36:49 <Guest49982> hi
21:37:53 <Guest49982> hi andy and wowo
21:38:04 <Guest49982> *wowi42
21:38:10 <Guest49982> 'sup
21:39:56 <Guest49982> .join #programming
21:40:20 <Guest49982> hi ChanServ 
21:40:25 <Guest49982> hi cyjiao 
21:40:29 <Guest49982> hi cybai 
21:40:30 <Guest49982> xD
21:57:51 * hackage toodles 0.1.0.15 - Manage the TODO entries in your code  http://hackage.haskell.org/package/toodles-0.1.0.15 (aviaviavi)
22:05:51 * hackage decidable 0.1.4.0 - Combinators for manipulating dependently-typed predicates.  http://hackage.haskell.org/package/decidable-0.1.4.0 (jle)
22:06:36 <johnw> I feel like manipulating a dependently-typed predicate means getting to accept a bad inhabitant
22:07:55 <jle`> is that a pun :)
22:08:25 <johnw> i'm not even sure!
22:24:53 * hackage http2 1.6.4 - HTTP/2 library including frames, priority queues and HPACK  http://hackage.haskell.org/package/http2-1.6.4 (KazuYamamoto)
22:38:21 <pavonia> How do you read the info files generated by the Alex tool? I see several "State s" sections there and for each many lines "'c' -> t" that apparently mean "if in state s and reading a 'c', go to state t". But what happens if a character occurs next that is not listed there?
22:39:27 <geekosaur> it's a syntax error
22:42:30 <pavonia> geekosaur: I don't think so. For example if you compile this file http://hackage.haskell.org/package/alex-3.2.4/src/examples/haskell.x and follow the path of "aa", you end up in a state where there's no escape from by any character beside the usual identifier symbols
22:42:54 <pavonia> But a space character after "aa" is perfectly legal syntax
23:07:51 <infinity0> anyone familiar with +RTS -xc?
23:16:51 * hackage toodles 0.1.0.16 - Manage the TODO entries in your code  http://hackage.haskell.org/package/toodles-0.1.0.16 (aviaviavi)
23:21:26 <cocreature> infinity0: just ask your actual question, it’s hard to know if someone is familiar enough with +RTS -xc to answer an unknown question
23:23:55 <infinity0> cocreature: i remembered there is #ghc so i asked there instead. i think it's a bug and i filed it as #15832
23:26:44 <Wizek> Any ideas what `Didn't see ghc-boot-8.4.4 in your package indices.` might mean?
23:27:11 <Wizek> this package seems to be on stackage, yet hackage only seems to have 8.4.3. Could this be a mistake?
23:27:19 <Wizek> https://hackage.haskell.org/package/ghc-boot-8.4.3
23:27:27 <Wizek> https://www.stackage.org/package/ghc-boot
23:30:44 <cocreature> ghc-boot is bundled with ghc, afaik it’s only uploaded to hackage so that you can view the docs
23:31:22 <Wizek> cocreature: In that case, any ideas why stack might be saying this to me? 
23:31:26 <cocreature> dunno
23:31:34 <cocreature> is it just a warning or an error?
23:31:40 <Wizek> error
23:33:19 <geekosaur> stackage probably extracts it from the ghc build, then is trying to look for it in the hackage index. that it's on hackage only for docs means among other things that they forget to do it sometimes when they release
23:33:45 <geekosaur> probably a bug report or note to the mailing list would be smart
23:35:14 <Wizek> geekosaur: Alright. Though since it is supposed to be bundled, would that actually get me through this error? Or any ideas what I could try as a workaround? 
23:36:36 <cocreature> use an lts that comes with 8.4.3?
23:36:39 <geekosaur> I don't know if stack assumes that anything in stackage can be found in the hackage index. (But that sounds like what would case this, if stackage itself gets it from the ghc build instead of hackage.)
23:37:13 <geekosaur> and yeh, it sounds like you need to stick with 8.4.3 until either hackage isupdated or stack is fixed to not assume things it gets from ghc are on hackage
23:39:53 <Wizek> that makes some sense, thanks geekosaur. I also have the (possibly crazy?) idea to just add `- ghc-boot-8.4.3` to `extra-deps` while using 8.4.4.
23:41:43 <cocreature> Wizek: are you on the latest stack release? I was looking through the source to see if it already special cases other packages and it looks like that particular piece of code has been removed
23:41:51 <geekosaur> I can think of a number of ways that could go wrong, since it's the glue that attaches ghc to its own dependencies. Several fo whch are also egneral dependencies
23:42:45 <Wizek> cocreature: stack-1.9.1
23:44:57 <Wizek> geekosaur: giving lts-12.14 a try 
