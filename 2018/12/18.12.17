00:09:52 <coldpress> anyone found a solution for aoc day 17 that doesn't take forever?
00:13:52 <iqubic> So I have a function f :: (a -> a) and a value x :: a, and an n :: Int. I want a function that does "f $ f $ f $ f.... f $ f x" n times and gives me the result. Is that possible
00:14:15 <iqubic> The type of this function should be something like: Int -> (a -> a) -> a -> a
00:15:11 <iqubic> So it just takes the starting value and applies f to it n times in a row and then sends that value along.
00:15:17 <suzu> nest 0 f x = f x
00:15:29 <iqubic> Sure.
00:15:34 <iqubic> go with that.
00:15:34 <suzu> nest n f x = f $ nest (n-1) f x
00:15:50 <iqubic> That works really wel..
00:16:37 <suzu> i dont think this function is defined in based otherwise
00:16:39 <suzu> base *
00:16:42 <suzu> oh you could maybe use iterate
00:16:52 <iqubic> iterate and take?
00:16:56 <suzu> hmm not take
00:17:00 <suzu> use !!
00:17:01 <iqubic> how would that work?
00:17:06 <suzu> iterate f x !! n
00:17:38 <suzu> iterate f x !! 3 would be f $ f $ f x
00:21:53 <Lears> % :t \n -> appEndo . stimes n . Endo
00:21:53 <yahb> Lears: forall {b} {a}. Integral b => b -> (a -> a) -> a -> a
00:22:00 <Lears> Another option.
00:23:48 <Lears> Ah, though stimesMonoid is better here.
00:24:33 --- mode: glguy set +v frowny
00:28:22 <iqubic> Well, now I want something I can't have.
00:28:58 <iqubic> I want "f $ f $ f $ f ... f $ g $ x"
00:29:24 <iqubic> I want something similar to the iterate, but I want the initial value to be "g $ x"
00:29:36 <iqubic> Is that possible?
00:29:39 <Lears> So pass in g x instead of x?
00:29:47 <iqubic> I'll try that.
00:30:25 <iqubic>     • Occurs check: cannot construct the infinite type: a ~ AD a
00:30:37 <iqubic> The hell is happning there?!?!?
00:32:58 <iqubic> What the hell is an occurs check?
00:34:19 <Lears> It's just a type error where GHC is trying to unify a with AD a.
00:34:38 <iqubic> I see.
00:34:46 <iqubic> I think I know where it comes from.
00:34:58 <iqubic> data AD a = D a (AD a)
00:35:03 <iqubic> It comes from there, right?
00:35:25 <iqubic> like I think it does.
00:36:24 <iqubic> No, actually, I had the wrong type signature. LOL.
00:37:35 * hackage registry 0.1.2.2 - data structure for assembling components  http://hackage.haskell.org/package/registry-0.1.2.2 (etorreborre)
00:38:33 <frowny> isn’t that just (iterate . g)?
00:39:28 <frowny> um, ((. g) . iterate)
00:43:43 <teto> I have created a datatype X which derives  (Enum, Show). Weird thing is if I try to define "instance Show X where" then I get "Duplicate instance declarations: instance Show X". Is there a default implementation ? how can I override it ?
00:44:30 <Ariakenom> teto: remove Show from the deriving list
00:44:33 <geekosaur> fi you're deriving it, why are you specifying a manual one?
00:44:42 <frowny> when you’re doing derives, you’re asking for a default omp[lementation
00:44:58 <frowny> just don’t derive Show
00:45:19 <teto> ok I thought I had to specify it before implementing it when it's actually the opposite xD
00:45:36 <frowny> that apostrophe is messing up the logs oops
00:46:43 <teto> the default implementation prints the actual enum item names like "enumEntry1" but I don't know how to replicate this behavior ? Ideally I would like to define `show EnumEntry1 = "enumEtnry1 " ++ fromEnum enumEntry1`
00:47:58 <geekosaur> the compiler has access to that, you'd have to do it manually or via Generics etc.
00:49:40 <teto> I found about Template Haskell but it seems overkill. Didn't know about Generics, will look into that otherwise I will define it manually. Thanks
00:50:21 <dminuoso> teto: please consider that `Show` is not meant for pretty printing.
00:51:02 <dminuoso> Show is meant to produce valid Haskell code that, if you copy pasted it into GHCi, would produce the same value back.
00:52:08 <dminuoso> iow `read . show = id`
00:53:15 <Ariakenom> dminuoso: isn't that a too strong of a statement?
00:53:39 <Ariakenom> at least in terms of failed parses but I'm guessing other things
00:55:07 <dminuoso> Ariakenom: Well no, the other way wouldn't necessarily hold.
00:55:22 <Ariakenom> oh right
01:04:16 <dminuoso> Who can explain to me why cabal new-build is failing here? https://gist.github.com/dminuoso/3a242e75acbefef3e4744a4a0426e69e
01:07:17 <coldpress> hmmst, Exercise 1.4-iii of Maguire says multiplication is commutative
01:08:41 <coldpress> I'm thinking of defining the isomorphism function in a very ugly way: productExpTo f (b, c) = uncurry f (c, b)
01:08:56 <coldpress> is there a better way of writing this? (prefereably fixpoint format?)
01:09:27 <coldpress> s/prefereably/preferably
01:09:50 <dminuoso> :t flip
01:09:51 <lambdabot> (a -> b -> c) -> b -> a -> c
01:10:24 <jackdk_> @pl \f (b,c) ->uncurry f (c,b)
01:10:24 <lambdabot> (`ap` snd) . (. fst) . (. flip (,)) . (.) . uncurry
01:10:38 <coldpress> somehow that looks even worse haha
01:11:04 <dminuoso> coldpress: Just use flip..
01:11:24 <frowny> and then uncurry
01:12:24 <suzu> Exercise 1.4-iii of Maguire?
01:12:27 <suzu> what's Maguire?
01:13:22 <suzu> coldpress
01:15:09 <uptick> quick question, regarding cabal's flags, what's the difference in just using cabal install, cabal update, vs. cabal v2-install, cabal v2-update, etc? or cabal new-install, cabal new-update....etc? 
01:15:36 <coldpress> http://thinkingwithtypes.com/
01:16:12 <suzu> ah
01:16:19 <dminuoso> uptick: So there's two build-styles in cabal right now.
01:16:24 <coldpress> ah, uncurry . flip
01:16:27 <dminuoso> uptick: "old style" and "new style" (which is nix inspired)
01:16:48 <coldpress> wonder how the lambdabot didn't find a simpler fixpoint
01:17:09 <dminuoso> uptick: new style gives you deterministic builds but with a global cache.
01:17:46 <frowny> it's not called fixpoint
01:18:44 <uptick> dminuoso: hmm. if i'm just using haskell and cabal to use a certain package. which would you recommend or does it not matter? :P
01:18:48 <coldpress> freepoint?
01:19:02 <uptick> i remember using cabal install and it was warning me for using legacy command flag
01:19:07 <suzu> pointfree :)
01:19:10 <dminuoso> uptick: new style all the way, it's the future way, the old style will at some point in the near future be deprecated.
01:19:45 <dminuoso> uptick: So just use all the new-* commands
01:20:18 <coldpress> suzu: flip freepoint :)
01:21:02 <dminuoso> I think v2 is just a prefix synonym for new
01:21:11 <uptick> so v1 is legacy, v2 is current(old), new is (current(beta), the one that's going to be the norm in the future) and without flags with just install, update, that will be deprecated right?
01:22:04 <suzu> you can do productExpTo f (b, c) = uncurry f (c, b)
01:22:06 <suzu> err sorry
01:22:14 <suzu> productExpTo f = uncurry f . swap
01:22:15 <dminuoso> uptick: there's two schemes: old which is "no prefix (currently)" or v1-*
01:22:27 <dminuoso> uptick: and new which is new-* or v2-*
01:22:30 <uptick> oh i see
01:22:54 <suzu> or productExpTo = (. swap) . uncurry
01:22:59 <dminuoso> Admittedly it's a bit confusing. :)
01:23:04 <suzu> but that one is confusing
01:24:30 <uptick> dminuoso: ah. thank you so much. that cleared things up a lot
01:24:32 <uptick> :)
01:25:10 <uptick> also, quick question. i used ghcup for installation. the ghc i got was 8.4.4 but this isn't the newest version though?
01:25:34 <suzu> that is not the newest, yes
01:26:14 <suzu> i've never heard of ghcup
01:26:22 <suzu> stack/nix can get you whatever ghc you'd like
01:26:36 <dminuoso> Or just install GHC manually..
01:26:38 <suzu> isolated to the project-level and coexisting of other GHCs
01:27:16 <dminuoso> Anyway, can someone tell me the reason why cabal is failing this build? I can't make sense of this: https://gist.github.com/dminuoso/3a242e75acbefef3e4744a4a0426e69e
01:30:24 <dminuoso> Locally this builds just fine.
01:46:48 <dminuoso> Mmm, it seems there might be something bugged with `new-build --only-dependencies`
01:46:51 <dminuoso> =.
01:46:53 <dminuoso> =/
01:49:08 <merijn> dminuoso: How so?
01:49:22 <dminuoso> merijn: https://gist.github.com/dminuoso/3a242e75acbefef3e4744a4a0426e69e
01:49:47 <dminuoso> Removing the layer `Step 8/15 : RUN cabal new-build --only-dependencies .` makes it build again.
01:51:35 <merijn> I don't get the problem description
01:51:48 <dminuoso> merijn: Oh. Look at the build failure at the end.
01:52:30 <merijn> Why do all the listed dependencies not have vowels in them?
01:52:54 <merijn> That looks suspicious
01:53:09 <dminuoso> It kind of does, doesn't it.
01:53:25 <dminuoso> merijn: It only triggers when I have that layer where I build only dependencies first. 
01:53:50 <merijn> I don't know that part enough, ask in #hackage?
01:53:58 <merijn> Also, which version of cabal-install?
01:56:09 <dminuoso> merijn: Mmm, whatever is most recent for cabal-install-2.4 from http://downloads.haskell.org/debian
01:59:55 <dminuoso> Bloody, it wont reproduce now.
01:59:57 <dminuoso> What is this.
02:03:02 --- mode: glguy set +v frowny
02:13:40 <bahamas> how can I avoid these mismatches? Couldn't match expected type ‘B.ByteString’
02:13:43 <bahamas>                   with actual type ‘Data.ByteString.Internal.ByteString’
02:14:06 <bahamas> I have this import: import qualified Data.ByteString.Lazy as B
02:14:27 <bahamas> and I'm encoding some text with T.encodeUtf8
02:15:13 <merijn> bahamas: Presumably T.encodeUtf8 comes from the strict encoding module, which encodes as a strict bytestring
02:15:32 <merijn> bahamas: There is also a Data.Text.Encoding.Lazy
02:15:52 <bahamas> merijn: I see. btw, should I use strict or lazy?
02:16:07 <dminuoso> bahamas: That depends on your usecase obviously
02:16:12 <merijn> "It Depends (TM)"
02:16:40 <trcc> dminuoso merijn there must be some best practices on this?
02:16:48 <dminuoso> trcc: There are no general best practices really.
02:17:18 <trcc> something like: rule of thumb - keep everything lazy. Change to strict when needed.
02:17:21 <trcc> hm ok
02:17:56 <merijn> trcc: Lazy means you don't have to keep everything in memory, but most of the sources of lazy BS/Text tend to be lazy IO which has its own pitfalls with regards to, e.g. timely closing of file descriptors
02:18:18 <bahamas> what are the uses case for each? I'm a haskell beginner, so I have no idea what to choose
02:18:31 <dminuoso> trcc: For text I'd rather go with the other way around I suppose. Start with strict, and switch to lazy if you are processing high amounts of text and it works for you.
02:18:43 <merijn> Strict is problematic for large data, since you might not have the memory. Of course, there's also the option of streaming small chunks of strict Text/BS using streaming libraries like conduit/pipes/etc.
02:18:55 <dminuoso> And lazy is problematic for small data. :P
02:19:10 <trcc> dminuoso merijn: so, if reading from files, do it strict unless memory issues?
02:19:17 <trcc> seems reasonable to not keep the file handle
02:19:25 <merijn> At this point I prefer strict + streaming libs, but that adds a bit of conceptual/learning overhead when starting out
02:19:48 <trcc> Thank you
02:19:51 <merijn> trcc: For text files that are a couple kilobytes max I'd say "just use the readFile from strict BS/Text", yes
02:20:07 <trcc> ok
02:20:19 <merijn> Hell, even a few megabytes big is no problem, unless you plan to open thousands at a time :p
02:20:39 <dminuoso> trcc: You could consider a lazy bytestring to be just [Strict.ByteString] with a newtype wrapper.
02:20:48 <merijn> trcc: The real rule of thumb is "anything, as long as it's not String" ;)
02:20:56 <trcc> hehe yes, I have noticed that rule of thumb
02:21:57 <bahamas> it looks like I'm forced to use the strict version of bytestring/text, because a library that I'm using is returning strict text. how do I import the strict version of bytestring. doing import qualified Data.ByteString as B doesn't do it
02:22:02 <merijn> It's fine for small/simple stuff, but String can takes as much as 24 (!!) bytes per character, which for text files of several KB is...not ideal. Text otoh will be ~2 bytes per character (plus a few bytes overhead)
02:22:15 <merijn> bahamas: That is the strict version
02:22:23 <merijn> bahamas: lazy is in Data.ByteString.Lazy
02:22:37 * dminuoso started using String again in some minor libraries where he parses stuff
02:22:46 <dminuoso> It's less headaches with megaparsec for mini config files :P
02:23:07 <bahamas> merijn: maybe aeson is expecting a lazy bytestring then? that's where the clash appears
02:23:53 <merijn> aeson seems to encode lazy data, yeah (you can check by just mousing over the type in the hackage docs)
02:24:17 <merijn> That shows you the original module (and thus whether it's lazy or strict)
02:24:40 <bahamas> a, there's eitherDecodeStrict
02:24:47 <merijn> bahamas: the .Lazy modules have toStrict and fromStrict functions
02:25:32 <bahamas> that's good to know
02:26:48 <merijn> bahamas: Also good to know is that fromStrict is basically free
02:27:39 <dminuoso> fromStrict is essentially just `[]` =P
02:27:49 <merijn> Since lazy versions are just a "lazy list of strict chunks", you just turn it into a single element list
02:31:40 <trcc> bahamas: which tooling have you decided to use for you haskell development?
02:52:19 --- mode: glguy set +v donnut
02:53:02 <donnut> where [ACheesyName] & [sky]..
02:53:26 <donnut> i have info..
02:54:06 <donnut> @glguy 
02:54:06 <lambdabot> Unknown command, try @list
02:54:40 <donnut> lambdanot.. okey..
02:56:14 <Bish> :)
02:56:37 <donnut> INDONESIA now war..
02:57:43 <donnut> between associations
03:07:24 <suzu> sounds dangerous
03:08:41 <donnut> @sozu.. what sounds..
03:08:41 <lambdabot> Unknown command, try @list
03:09:57 <donnut> @list
03:09:57 <lambdabot> What module?  Try @listmodules for some ideas.
03:10:25 <donnut> :v
03:10:35 <donnut> 😀😀😀😀😀
03:10:41 <donnut> 😂😂😂😂
03:11:33 <yushyin> stop using @ at the front of a line, it will trigger the lambdabot
03:12:34 <donnut> @yushyin, why..
03:12:34 <lambdabot> Unknown command, try @list
03:13:18 <yushyin> just stop it
03:13:41 <donnut> okey.. thanks..
03:15:32 * Arahael wonders why @ was chosen, and not... \
03:16:15 <Arahael> Or even λ
03:17:07 <donnut> maybe because it's dangerous
03:18:19 <donnut> [Arahael] maybe because it's dangerous..
03:18:43 <Arahael> donnut: Convention in IRC is to just use the name, and then a colon. :)
03:18:52 <__monty__> Arahael: It's so people don't bring those mentions here from twitter.
03:19:03 <__monty__> It's just noise.
03:19:40 <Arahael> __monty__: Ah, yes, I forgot that's how people use @'s.
03:20:18 <Arahael> Yikes! Just saw a recommendation from reflex-frp: Apparently ghcjs likes to use 16 GB of memory(!)
03:20:19 <suzu> the other day somebody said #haskell should move to slack
03:20:25 <Arahael> "GHCJS uses a lot of memory during compilation. 16GB of memory is recommended, with 8GB being pretty close to bare minimum."
03:20:31 <suzu> they were quickly shut down
03:20:33 <suzu> as is approropraite
03:20:35 <suzu> appropriate*
03:20:56 <Arahael> suzu: Good.  It's a pity, slack is an awesome thing, but I don't like using 1 GB when a few dozen MB's will suffice.
03:21:30 <suzu> slack is .. i don't know
03:21:50 <Arahael> Hmm, apparently my irc client is using nearly 80 MB, still, that's vastly preferable to 1 GB or more.
03:21:58 <__monty__> It's a sad trend, moving communities into vendor locked spaces.
03:22:03 <suzu> it's real slow, kinda laggy
03:22:04 <donnut> now i'm starting to understand ...
03:22:06 <suzu> use tons of memory
03:22:19 <suzu> whereas i can get irc to work on a ramshackled toaster
03:22:37 <suzu> irc clients are pouring out the wazoo
03:22:41 <Arahael> suzu: You can use IRC with slack quite well, except a lot of the slack admins block irc.
03:22:52 <suzu> i do like slack's eye-candy though
03:22:59 <suzu> and notifications are nice. that is all
03:23:14 <Arahael> Maybe one of us should develop a slack-like IRC client, but with sensible memory usage.
03:23:26 <Arahael> I should get some sleep
03:23:29 <__monty__> You can get notifications with irc. It's not provided by default but that shouldn't stop anyone who wants them.
03:23:50 * Arahael wouldn't want notifications from his 39 irc channels anyway.
03:23:59 <suzu> you need to hack on your client a bit to make it work
03:24:12 <suzu> slack has done the heavy lifting in that regard. email / push notification / desktop notifs
03:24:24 <__monty__> That doesn't really work, you can't augment irc with a bunch of crap because all the other irc clients won't understand it. It'd just no longer be irc but a different incarnation of slack.
03:24:28 <suzu> but they do control everything about the platform so that isn't difficult to do
03:25:08 <donnut> irc language, it's hard to understand
03:25:10 <Arahael> __monty__: Sure you can.  Don't forget, you can IRC with slack just fine, just they disable it.
03:25:18 <suzu> there is irccloud
03:25:35 <__monty__> Arahael: I mean that you can't add any of the eye-candy features.
03:25:52 <Arahael> __monty__: You can if you expose them using a url.
03:25:59 <Arahael> __monty__: Click on the url, get the feature.
03:26:33 <__monty__> Because people love clicking on mysterious urls... This is offtopic though so let's stop or move to #haskell-offtopic.
03:26:54 <donnut> example
03:27:20 <Arahael> __monty__: Heh, it does annoy me that they're "expanded" by default, I wish they were collapsed by default!
03:27:25 <Arahael> But enough, sure. :) I should get to bed.
03:27:29 <yoneda> @__monty__ "It's a sad trend, moving communities into vendor locked spaces"  +1
03:27:29 <lambdabot> Unknown command, try @list
03:28:22 <__monty__> yoneda: Too bad you had to use @, that layers so much irony on top of the statement : )
03:29:12 <donnut> hahaha ... joking badly
03:31:18 * yoneda blushes from shame
03:36:11 <dminuoso> merijn: Turns out cabal new-build dist-newstyle/ from macOS is not compatible with linux dist-newstyle.
03:36:36 <dminuoso> So if you copy over dist-newstyle/ from macOS onto linux, you get that highly bizarre error with the vowels you saw earlier. 
03:37:05 <dminuoso> The subtleties you ignore when you compare two projects and think "look, this line is the only thing that differs.. the other differences *clearly* must be unrelated"
03:48:20 <donnut> i insomnia..
03:49:27 <donnut> who's play LOL..
03:49:59 <donnut> PLAY LEANGUE OF LEGENDS
04:36:05 * hackage cryptoids-types 1.0.0 - Shared types for encrypting internal object identifiers before exposure  http://hackage.haskell.org/package/cryptoids-types-1.0.0 (gkleen)
04:40:34 * hackage pontarius-xmpp 0.5.5 - An XMPP client library  http://hackage.haskell.org/package/pontarius-xmpp-0.5.5 (PhilippBalzarek)
04:45:13 <Bish> what part of sequenceA does replace the whole thing with Nothing when doing sequenceA [Just 1,Nothing]
04:47:17 <Bish> i mean there is no if else expression
04:47:24 <Bish> so how does this end up being Nothing
04:47:45 <Ariakenom> where do you mean, in the source for sequenceA?
04:47:49 <Bish> yes
04:47:59 <Bish> sequenceA (x:xs) = (:) <$> x <*> sequenceA xs looks like this,r ight?
04:48:40 <Bish> i think i know how this happens, but not where exactly
04:48:52 --- mode: glguy set +v _rht
04:48:53 <Lears> > (:) <$> Nothing <*> pure []
04:48:56 <lambdabot>  Nothing
04:49:07 <Ariakenom> Bish: look at the definition of <*>
04:49:14 <Ariakenom> for Maybe
04:50:55 <Ariakenom> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-841
04:52:04 <Bish> still confusing, but i get it
04:52:11 <Bish> Nothing applied is nothing no matter what
04:52:35 <Bish> but Maybe is "pulled" out of the list... and to my "understanding" it should be looking like Just [Nothing]
04:52:40 <Bish> i know that is wrong, and why that is wrong
04:52:46 <Bish> but intuitively i understand it this way
04:52:49 <Ariakenom> Bish: You can do like Lears suggested and write out some expansions of the definitions
04:52:55 <dminuoso> Bish: It's better to think in terms of `traverse` perhaps.
04:53:05 <dminuoso> Bish: Think of `Maybe` as an "exception" effect.
04:53:33 <Bish> yeah, i understand that
04:53:39 <dminuoso> So if you traverse with `(Int -> Maybe Bool)` over some `[Int]` you basically "loop" over the list, producing either a result or throw an exception and have no result.
04:54:03 <dminuoso> So the result type is `Maybe [Bool]`
04:54:28 <Bish> yep, i get what it does but not exactly how
04:55:09 <Bish> guess my problem is never looking at traverseble didn.t even notice sequenceA does only need that
04:55:17 <Bish> figured they're both applicative or what not
04:56:38 <Bish> wait, whats the difference between sequence and sequenceA
04:56:47 <Bish> it's just "weaker" as in not requiring a monad?
04:57:24 <ventonegro> :t sequence
04:57:25 <dminuoso> Yup.
04:57:25 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
04:57:31 <ventonegro> :t sequenceA
04:57:32 <dminuoso> Bish: It's a historical accident.
04:57:32 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
04:57:47 <dminuoso> Bish: Kind of how we have `pure` and `return` at the same time.
04:57:53 <Bish> oh, i see
04:58:04 <Bish> because applicative was created l8er
04:58:17 <Bish> yeah, but naming makes sense atleast if it was sequenceM
04:58:54 <dminuoso> Bish: If the authors had that much foresight, they would have just gotten `sequence :: (Applicative f, Traversable t) => t (f a) -> f (t a)
04:59:14 <Bish> dminuoso: to be fair, that's very hards
04:59:24 <Bish> i am very picky in those things, but jesus that's hard
04:59:33 <Bish> couldn't you use that as an argument why haskell sucks?
04:59:50 <Bish> i mean it's not very flexible to changes because of typematching
05:00:18 <dminuoso> What do you mean?
05:00:26 <Bish> i am learning haskell because it's sick
05:00:40 <dminuoso> 13:59             Bish | i mean it's not very flexible to changes because of typematching
05:00:41 <Bish> but i have the feeling if i design a program like that.. it's gonna be great (if i know where i am going with the software project)
05:00:44 <dminuoso> It's as flexible as any other language.
05:00:51 <dminuoso> The difference is that Haskell *tells* you your program is clearly broken.
05:01:01 <Bish> dminuoso: no, i understand that, and that part is great
05:01:05 <Bish> but i ask my self: at what cost?
05:01:08 <dminuoso> Languages like Ruby defer that knowledge until runtime - and making it generally very hard to figure out *what* actually broke
05:01:16 <Bish> if you create a certain datastructure, and it's great and all
05:01:20 <Bish> but then you need to change a core thing
05:01:27 <Bish> would you write it completely new in the ned?
05:01:46 <Bish> i feel like ruby would be "stronger" in that regard, but sure, bugs
05:01:56 <dminuoso> Bish: The same holds true for Ruby as well.
05:02:12 <dminuoso> Bish: If you change the API of Array there's a *lot* you need to refactor. The difficulty just becomes figuring out *what* you need to refactor.
05:02:20 <dminuoso> Haskell is no different in that regard.
05:02:31 <Bish> hm, but metaprogramming and stuff makes easy to do dirty in place fixes
05:02:44 <Bish> like, runtime metaprogramming
05:02:47 <dminuoso> Bish: At the cost of creating brittle and hard to debug code.
05:02:51 <Bish> and, sure that isn't goo and error-prone
05:02:54 <dminuoso> And code that is almost impossible to reason about.
05:03:03 <dminuoso> Code that is hard to maintain without being the author.
05:03:21 <dminuoso> Code that is impossible to refactor due to subtle interdependencies, order or evaluation, mutual monkey patching
05:03:45 <Bish> yep, quesiton is, what is more work: searching your impossible ruby bug, or rewriting haskell code
05:03:51 <Bish> im curious about that
05:04:09 <Bish> let's see when i am used to haskell, gonna do some fun project with it, now where i "kinda" get it
05:04:28 <dminuoso> Bish: In my experience Haskell has a tendency to force you think a lot in types/interfaces before you actually implement code.
05:04:48 <dminuoso> Which forces you to design your program more cleanly, avoiding the need to retroactively patch your program because you forgot some dependency.
05:05:06 <Bish> yeah, i am talking about changed requirements
05:05:13 <Bish> that's something i imagine being shit in haskell
05:05:17 <dminuoso> And the type system makes it easy to refactor code down the road. In Ruby it may appear easy, but even some "monkey patch" on the spot has the ability to break many things that are not obvious.
05:05:41 <Bish> like... you have a database for a website with user registration login and whatnot
05:06:03 <Bish> and now your boss comes and says "yeah, for every user, he has sub-users, which can login too, with less rights"
05:06:19 <Ariakenom> Bish: it's not uncommon to hear refactoring haskell is great. because the compiler tells you what you forgot to change
05:06:45 <Bish> would my example be in the category "refactor"
05:06:47 <Bish> rather not, right?
05:08:30 <Ariakenom> no, I didn't mean for that example
05:08:43 <Bish> yes, was just making sure for my own sake
05:09:04 <Bish> i am not that fluent in developer terminology even though being one
05:11:36 <tdammers> IME, Haskell is orders of magnitude easier to refactor than any one of PHP, Python, Perl, JavaScript, or Ruby
05:12:06 <Bish> yeah im hyped to test that
05:12:08 <trcc> tdammers: agree.. Though I sometimes miss a new renaming tool :)
05:12:10 <Bish> wish i had the time
05:12:13 <tdammers> "refactoring" means "changing the code without changing its behavior"
05:12:36 <Bish> yeah well ne doubt haskell will be easier in that regard
05:12:44 <tdammers> trcc: sure - but in most cases, just using sed -i on the codebase, and then following the compiler errors, is a good enough substitute
05:13:12 <Bish> are there editors written in haskell :D
05:13:13 <tdammers> Bish: although out in the wild, you will often hear developers say "refactor" when really they mean "rewrite"
05:13:18 <dminuoso> tdammers: Even changing the code *with* changing its behavior is absolutely amazing.
05:13:36 <trcc> somewhat.. still missing it
05:13:43 <trcc> Bish: leksah
05:13:45 <dminuoso> The infamous "if it typechecks its correct" line is surprisingly correct so many times.
05:13:54 <tdammers> well yes
05:14:05 <tdammers> it's not that types make your code automatically correct
05:14:10 <Bish> dminuoso: well, in my little experience in haskell i have
05:14:13 <tdammers> but they do make it easier to set yourself up for success
05:14:17 <trcc> only tried it some years ago, and it was not particularly success on windows.. Might have changed, but I am on mac now so...
05:14:32 <Bish> there are not many functions that make sense in a position, that have different type signatures
05:15:02 <Ariakenom> dminuoso: That's been my experience on some types of programs. This years advent of code I've usually had an error or 2 after type checking though
05:15:09 <Bish> that's what strikes me most about haskell.. sometimes you do things because of types and you don't know what you're doing and in the end it's ebtter than everything you could've come up with
05:15:33 <Ariakenom> But that's after writing the entire solution down without running it once. Which I still viewed as quite good.
05:16:55 <sm> Bish: agreed
05:17:14 <__monty__> Most of my errors are in the parsing code because I'm not used to ReadP. Also some index issues because of foldr though.
05:17:57 <tdammers> Bish: I guess what happens there is you write down what you know about the solution, and then instead of trying to intuit or "grok" the entire thing, you just apply a bunch of formal rules, a bit like how you solve systems of equations
05:18:17 <tdammers> and the formal rules make sure every step you take is sound (within limits)
05:18:52 <Bish> https://www.youtube.com/watch?v=RtYWKG_zZrM i found this interesting as a newby
05:19:05 <Bish> that's a good example on how types make things easier
05:19:17 <Bish> (although i don't get what the Min Integer Monoid exactly does)
05:20:21 <dminuoso> Bish: So a monoid is just the generic interface for "combining things together". 
05:20:30 <dminuoso> (In some associative manner)
05:20:35 <Bish> oh yeah i watched at the definition
05:20:42 <dminuoso> Turns out you can combine two integers together based on the notion "pick the smaller one"
05:20:45 <Bish> but still, confuses me, that's tooa dvanced
05:20:56 <dminuoso> "pick the smaller one" obviously takes 2 numbers and gives you one back. So it kind of "combines two into one"
05:21:01 <Bish> i get kinda what it does, that's why it allows a "default" value
05:21:18 <Bish> because it knows there is a number where everynumber compared to this one is a minimum
05:21:30 <Bish> neutral element and such
05:21:37 <tdammers> it helps to think of a monoid as a triple of type, operation, and neutral element ("zero")
05:21:42 <Bish> but how that helps im in that thingy is weird to me
05:21:48 <tdammers> so for example, (Int, (+), 0) is a monoid
05:21:55 <tdammers> (Int, (*), 1) is another monoid
05:22:28 <tdammers> (String, (++), "") is also a monoid
05:22:42 <tdammers> in fact, because String = [Char], ([a], (++), []) is the same monoid
05:23:18 <tdammers> (Bool, (||), False) is a monoid over booleans, but so is (Bool, (&&), True)
05:23:28 <dminuoso> Bish: It may not be as useful to learn the relationship between Applicative and Monoid if you dont have a firm grasp on these types yet.
05:23:43 <dminuoso> You may not even need to understand it to be proficient at Haskell.
05:24:16 <tdammers> a more exotic, less obvious monoid is (a -> a, (.), id) - that is, endofunctions over function composition, with the identity function as the neutral element
05:24:56 --- mode: glguy set +v tall
05:27:44 <Franciman> Hi, I'm doing: `ghcid -c "cabal new-repl --enable-benchmarks all"` but my benchmark file doesn't get compiled yet
05:27:50 <Franciman> what am I doing wrong?
05:28:17 <Franciman> compiled and checked*
05:28:28 <Franciman> i.e. if I write invalid haskell, i don't see errors
05:31:02 <Franciman> oh i found out
05:38:30 <Bish> Franciman: did you turn the screen on :p
05:39:06 <Franciman> Bish, that was the issue, yeah
05:48:54 --- mode: glguy set +v f_en
05:49:04 * hackage vector-sized 1.2.0.0 - Size tagged vectors  http://hackage.haskell.org/package/vector-sized-1.2.0.0 (jophish)
05:50:07 <f_en> whats the best way to say that there is a type associated to the values appearing in a container?
05:51:05 <f_en> actually, associated to the container...
05:51:58 <dminuoso> f_en: What do you mean by "type associated to the container" exactly?
05:52:00 <MarcelineVQ> is the type a property of the container? the container is indexed possibly, it depends on whether that type affects the logic of what you do with the container. if it does it's indexed, if it doesn't it's paramterized
05:52:17 <f_en> like, `f' of `f a' defines `b :: * -> *'
05:53:45 <dminuoso> f_en: What is the nature of that relationship between f and b?
05:54:06 <f_en> maybe its just an empty class with a fundep, class Associated (f :: k) (b :: k) | f -> b
05:54:40 <f_en> might also need k as a parameter to the class to place it in scope...
05:55:15 <f_en> basically, it just want to return another type that can also contain the contents
05:56:05 <f_en> its supposed to encode something about values also made available during some abstraction over traversable
05:56:26 <f_en> like for lists b = Identity (as it is Traversable)
05:56:48 <f_en> and for shaped containers where the shape is given by `i', b = (i,)
05:57:26 <f_en> and it is "Traversablei" where traversei :: Applicative f => ((i,a) -> f b) -> t a -> f (t b)
05:57:55 <f_en> it seems to be a valid abstraction because there seems to be many different forms of traversable
05:59:48 <f_en> such as for Free; Applicative f => (Free t a -> f (Free t b)) -> Free t a -> f (Free t b)
06:00:50 <f_en> and to save rewriting the traversable class for each of these, it would be better just to associate this type (appearing as the argument to the applicative function) to the container
06:02:04 <f_en> then Traversable instances would have b = Identitiy, and the traversable class is a synonym to this generalised traverse class with Identity as a param
06:02:26 <dminuoso> How do you folks remember which one is which with `some/many`?
06:02:43 <f_en> which seems to give a natural way to associate a type to a container as desired
06:02:44 <dminuoso> Over the past 12 months I find myself hoogling on a weekly basis.. and I just cant connect them in my head.
06:03:28 <f_en> also, any ideas about this generalisation of traversable!?
06:03:33 <MarcelineVQ> dminuoso: never had trouble with it, maybe associate (s)ome with (s)ingle+
06:04:21 <lyxia> "some" is also used to talk about existentially quantified properties -> at least one.
06:04:45 <f_en> > /= >=
06:04:48 <lambdabot>  <hint>:1:1: error: parse error on input ‘/=’
06:06:14 <f_en> at least some /= at least one
06:06:23 <f_en> if that helps...
06:07:02 <f_en> for those whoes first language might not be english
06:09:35 <f_en> ok, maybe a better question could be, what is that version of traversable for free? where the associated type (the argument to the applicative function) is Free f a, as this is what is available instead of `a' as in traverse
06:24:26 <rcat> how can I build my project with 'cabal new-build' so that haddock is availble from ghci with `:doc'?
06:28:22 <coldpress> Bish: good video, didn't know about sequenceA
06:29:55 <dminuoso> coldpress: sequenceA is just traverse in disguise.
06:41:07 <Ariakenom> what can I use to parse a binary number?
06:43:10 <dminuoso> Ariakenom: That would depend on the format it's stored in, wouldn't it?
06:43:27 <dminuoso> Or what is a binary number to you?
06:43:32 <sm> 101011101
06:43:43 <sm> "101011101". I'd like to know too
06:45:03 <zzz> i find myself doing `map (map read) . map words . lines` or `map (map read . words) . lines` again and again for inputs like "1\n2 3 4\n5 6". is there a more idiomatic pattern for this?
06:46:07 <tdammers> zzz: using a proper parser-combinator maybe?
06:47:51 <zzz> ok so at this level there's no useful way around it
06:49:37 <tdammers> depends what you want out of it
06:50:12 <tdammers> at the very least, you could say parse = map (map read) . map words . lines
06:50:19 <tdammers> and then use that instead of spelling it out every time
06:52:53 <Solonarv> map (map read . words) . lines, perhaps?
06:53:23 <zzz> Solonarv: yes that's what i wrote ;)
06:53:29 <tdammers> doesn't matter much, compiler is going to optimize it one way or the other anyway ;)
06:54:04 <zzz> i just have that itch that there should be some btter way of expressing this that i'm not seeing. thanks guys
06:54:48 <dminuoso> zzz: Use extra bindings.
06:55:05 --- mode: glguy set +v Guest71
06:55:12 <dminuoso> Trying to be clever and pointfree in such a situation is just a hassle when you need to look at the code a week later.
06:56:28 <zzz> dminuoso: what do you mean by extra bindings? what i'm trying to do is to make it _less_ confusing than map (map . map) map map
06:57:23 <tdammers> binding as in bind it to a more meaningful name
06:57:36 <tdammers> and then use that name instead of the complex expression
06:57:49 <tdammers> you could even introduce more bindings
06:58:14 <tdammers> e.g., linesOfWords :: String -> [[String]]; linesOfWords = map words . lines
06:58:33 <tdammers> and then parse = map (map read) . linesOfWords
06:58:48 <dminuoso> Being very liberal with bindings helps make code easy to read.
06:58:54 <tdammers> you could also define map2 f = map (map f)
06:59:06 <tdammers> then you could write parse = map2 read . linesOfWords
06:59:41 <Guest71> https://www.youtube.com/watch?v=l1fPCX0JRAk
06:59:45 <tdammers> which, I think, makes the intention much clearer: chop the string into lines, and lines into words, and then map the "read" function over those words, retaining the lines-of-something structure
07:01:27 <Ariakenom> it's a trade off on what's easier to read ofc. bindings are indirections
07:02:31 <Ariakenom> dminuoso: wrt "binary" yes I said number when I meant string. so "11011" :: String
07:19:02 <lavalike> is there a facility to print how much memory a certain binding is taking in time? even just something to get it, and then Debug.Trace can take care of printing it
07:22:31 <cocreature> lavalike: there is "weigh" but that measures allocations not resident memory
07:23:20 <cocreature> and ofc GHC’s builtin heap profiler but that is a bit more complex than just calling a function
07:25:21 <lavalike> I'm not sure what the profiler is telling me (:
07:26:41 <cocreature> have you read the user guide section on profiling, in particular, the sub section of heap profiling?
07:27:02 <lavalike> https://pastebin.com/raw/Tyyisffk
07:28:31 <lavalike> I'm reading through, on one hand I'm happy to see half of the program's time is spent in that particular spot, on the other, it's puzzling
07:35:06 <cocreature> lavalike: note that this also only shows you allocations and not resident memory. look at the heap profiling section in the user guide for the latter
07:35:20 <lavalike> OK
07:39:00 <lavalike> cocreature: https://i.imgur.com/PheaXk3.png
07:40:26 <lavalike> I think this is still hiding the real cause but it's interesting
07:43:04 <lavalike> https://i.imgur.com/vpviZfa.png
07:43:23 <lavalike> so many tuples
07:45:17 <lavalike> was hoping for an explosion of one particular type
07:49:52 --- mode: glguy set +v Guest83
07:51:37 <Guest83> https://www.youtube.com/watch?v=l1fPCX0JRAk
07:52:33 <isd> Hey all, is there a way to get cabal to pass -Werror to GHC when building a project, but *not* its dependencies, without just editing the .cabal file?
08:03:23 <cocreature> isd: add ghc-options in the package specific section of cabal.project/cabal.project.local
08:20:54 <isd> cocreature: aha, thanks
08:42:01 <the_2nd> I have to do the following instead of just calling liftIO $ ...
08:42:07 <the_2nd> foo <- liftIO $ ...
08:42:09 <the_2nd> foo
08:42:38 <the_2nd> why can't I just use the liftIO directly? Shouldn't it do the same?
08:43:07 <the_2nd> error is getting ActionT instead of ActionM
08:43:57 <geekosaur> no, "the same" would be: foo <- liftIO $ ...; return foo
08:44:34 * hackage haskoin-store 0.9.2 - Storage and index for Bitcoin and Bitcoin Cash  http://hackage.haskell.org/package/haskoin-store-0.9.2 (xenog)
08:45:29 <the_2nd> is there a shorthand for what I'm doing? Seems wrong to me
08:45:52 <geekosaur> an oversimlified version is the liftIO $ ... has type IO (IO x)
08:47:02 <geekosaur> except the types don't match up here, from the sound of it, so you can't use what would work there (join)
08:47:38 <geekosaur> m, actually maybe you can
08:47:38 <Welkin> for values in a Map that need to have a specific ordering, and must be reorderable, is it reasonable to use an Array (or List) to represent the ordering?
08:48:31 <geekosaur> Welkin, there's several ways depending on how you're using it and what tradeoffs you want to make. that's one way, yes
08:48:34 <Welkin> there are two solutions I came up with, a Map plus an Array/List, or include an ordering value (a floating point number) inside each value
08:48:47 <Welkin> I will need to read as often as I write
08:49:29 <Welkin> Map + Array will give me logarithmic reads and writes, Array only will give me constanct time reads and linear writes
08:50:57 <Welkin> my context is similar to that of the Trello application
08:51:07 <Welkin> and it looks like they use the floating-point number trick
08:51:18 <Welkin> which I have used in the past, but it feels terribly clunky
08:51:26 --- mode: glguy set +v Chorhizo
08:51:29 <Welkin> I had to use it in the pst because I stored the data in a relational db
08:51:39 * hackage network-uri-lenses 0.1.0.0 -   http://hackage.haskell.org/package/network-uri-lenses-0.1.0.0 (Jappie)
08:51:39 <Welkin> this time I am storing the data as json
08:51:48 * shapr hops cheerfully
08:51:52 <shapr> GOOD MORNING #haskell !
08:52:07 * Clint blinks.
08:52:20 <shapr> good morning Clint !
08:52:34 <geekosaur> the_2nd, sorry, still waking up. yes, you should be able to use join to run that action
08:55:09 <Clint> shapr: good morning
08:55:21 <shapr> Clint: how's code? written anything cool lately?
09:06:04 * hackage network-uri-lenses 0.2.0.0 - Lenses for network-uri  http://hackage.haskell.org/package/network-uri-lenses-0.2.0.0 (Jappie)
09:07:48 --- mode: glguy set +v safinaskar
09:07:52 --- mode: glguy set -v safinaskar
09:08:05 <safinaskar> hi
09:08:18 <safinaskar> mniip: are you here? i found your https://github.com/mniip/BOOTSTRA . maybe you interested in helping this guy with bootstrapping ghc from c? https://elephly.net/posts/2017-01-09-bootstrapping-haskell-part-1.html
09:09:19 <mniip> hahaha
09:09:27 <mniip> that blog post is actually how I discovered bootstrappable
10:01:21 <marxS> forgive me for sounding silly, but I've seen some outspoken advocates of using haskell for machine learning. But why would this make sense given that machine learning is almost all iteration-based approaches?
10:01:38 <dexterfoo> what type class do is there for something that has a "next" function, for example a day-of-the-week? (next Mon == Tue)
10:01:41 <marxS> that surely must rely on some mutability?
10:02:01 <marxS> dexterfoo, what, the q doesnt make sense
10:02:11 <marxS> oh nvm
10:02:28 <marxS> just use succ
10:02:28 <bsima> marxS: have you read this? http://colah.github.io/posts/2015-09-NN-Types-FP/
10:02:29 <koala_man> dexterfoo: Enum 
10:02:47 <marxS> oh yeah, succ is enum
10:02:48 <marxS> lol
10:03:09 <marxS> well it takes argument with an enum instance
10:03:29 <marxS> no, bsima , will look now
10:03:58 <dexterfoo> koala_man: Enum won't work
10:05:17 <hololeap> dexterfoo: why not?
10:05:49 <safinaskar> I want to describe my context-free grammar (possibly left recursive) and immediately get parser for it and pretty printer for it
10:05:52 <dgpratt> One of the things I really like about TypeScript is union (not "tagged" union) and intersection types. I gather from discussions of union/intersection types in Haskell that there is an apparent incompatibility with type inference. Is there any resource known to this group that describes this incompatibility? That would be accessible to a lay-person, such as myself?
10:05:54 <safinaskar> how to do this?
10:06:09 <safinaskar> library solution or hand-written both will go
10:06:50 <Solonarv> safinaskar: I think there are libraries for this, but I'm not sure what they are
10:06:57 <Solonarv> Try searching for "bidirectional parser"
10:08:11 <Zemyla_> safinaskar: You'll want to use a profunctor, like data ReadShow a b = ReadShow (Int -> a -> ShowS) (ReadPrec b).
10:08:59 <Zemyla> That's the really basic version, but it demonstrates the combinators you'll need in general:
10:09:53 <Zemyla> (***) :: ReadShow a b -> ReadShow c d -> ReadShow (a, c) (b, d); ReadShow sa rb *** ReadShow sc rd = ReadShow (\p (a, c) -> sa p a . sc p c) (liftA2 (,) rb rd)
10:10:36 <Zemyla> (+++) :: ReadShow a b -> ReadShow c d -> ReadShow (Either a c) (Either b d); ReadShow sa rb +++ ReadShow sc rd = ReadShow (\p -> either (sa p) (sc p)) (fmap Left rb <|> fmap Right rd)
10:11:29 <Zemyla> From these, you can assemble pretty much anything.
10:12:58 <safinaskar> Zemyla: thanks a lot
10:13:08 <safinaskar> Zemyla: does it handle left-recursive grammars?
10:13:30 <safinaskar> Zemyla: say, i want to parse usual "calculator" language, i. e. 1+2*3
10:14:35 <Zemyla> Not that form. You'll need to right-recursivize it or add a combinator that turns ReadShow a b -> ReadShow [a] [b].
10:20:12 <safinaskar> Zemyla and others: but i want some beautiful solution. i. e. i want my code to close resemble bnf grammar itself (possible left recursive). what to do?
10:21:02 <safinaskar> Zemyla and others: not neccessary it should be combinators. say big data structure with grammar and then passing that grammar to parsing function will go
10:21:51 <Solonarv> I found this: https://hackage.haskell.org/package/invertible-syntax
10:21:57 <Solonarv> but it's really old
10:22:08 <safinaskar> Solonarv: thanks
10:22:33 <Solonarv> Don't thank me yet! I don't think that'll end up being super helpful.
10:23:29 <Solonarv> @hackage boomerang -- seems to be less abandoned
10:23:29 <lambdabot> http://hackage.haskell.org/package/boomerang -- seems to be less abandoned
10:25:03 <hololeap> dexterfoo: you might like `succSafe` and `predSafe`: https://hackage.haskell.org/package/safe-0.3.17/docs/Safe.html#v:succSafe
10:26:56 <unclechu> hololeap: what is "safe" about it? what would be the result of `succSafe maxBound`?
10:27:05 <unclechu> `minBound`?
10:27:40 <hololeap> unclechu: correct
10:27:49 <Solonarv> no, actually
10:28:06 <Solonarv> it's maxBound
10:28:41 <hololeap> i'm looking at the source: predSafe = predDef minBound
10:28:41 <unclechu> okay, and if i think it supposed to be `Nothing` instead i just use `succMay`, am i right?
10:28:56 <hololeap> that's dumb
10:29:05 <Solonarv> hololeap: yes, but the question was about succSafe
10:29:26 <Solonarv> succSafe maxBound = maxBound, predSafe minBound = minBound
10:29:36 <Solonarv> unclechu: yes
10:30:07 <hololeap> ok, well i thought succSafe = succDef minBound
10:44:11 * hackage pretty-show 1.9.3 - Tools for working with derived `Show` instances and genericinspection of values.  http://hackage.haskell.org/package/pretty-show-1.9.3 (IavorDiatchki)
10:46:13 --- mode: glguy set +v jakov
10:46:48 <glguy> jakov: type: Male
10:46:58 <jakov> Male
10:47:09 <glguy> You did it
10:47:30 * Clint squints.
10:48:12 * Ariakenom nods
10:50:33 <glguy> jakov: that was the answer
10:52:25 <glguy> jakov: please send your questions to this channel. I'm about to disappear.
10:52:36 <jakov> Thank you, i need to Digest it :D. Since I dont use IRC too much, i was confused with being voiced momentarily, and thought, that by following what you say ..... aah whatever. 
10:52:48 <glguy> 14,99[10:45] 99,99 13,99+jakov:99,99 Hello ! Assuming I have a data:     data Human = Male | Female, how do I make a 'Male' of type Human ?
10:52:57 <jakov> Thanks !
10:54:55 <geekosaur> consider that te definition of Bool is: data Bool = False | True
11:09:24 --- mode: glguy set +v ClathomasPrime_
11:12:03 <ClathomasPrime_> Hello! Is there a nice way to use MonadReader functions in a MonadState? If I have a function that should only read the state, it'd be nice for the type to reflect that
11:12:05 * hackage extensible-effects-concurrent 0.16.1 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.16.1 (SvenHeyll)
11:14:08 <ClathomasPrime_> I suppose what I'd want might have type :: MonadState s m2 => (forall m1. MonadReader s m1 => m1 a) -> m2 a
11:14:29 <geekosaur> not as such, no. this sounds more in the area of effects systems than mtl
11:14:41 <lyxia> if MonadReader is the only constraint you can use it as a plain function.
11:15:07 <jakov> I think, i simplyfied my problem too much. I have a  'data Device = Maybe Handle', where Handle is a System.IO filehandle. And i have an IO function that may throw an error. 
11:15:37 <jakov> And the compiler says ' Couldn't match expected type ‘IO DeviceHandle’
11:15:37 <jakov>                   with actual type ‘Maybe (IO Handle)’ '
11:15:38 <Solonarv> % let readerState k = get >>= runReaderT k
11:15:38 <yahb> Solonarv: ; <interactive>:583:21: error:; * Variable not in scope: get :: m a0; * Perhaps you meant `set' (imported from Control.Lens); <interactive>:583:29: error: Variable not in scope: runReaderT :: t -> a0 -> m b; (0.01 secs,)
11:15:52 <Solonarv> % import Control.Monad.State
11:15:52 <yahb> Solonarv: (0.00 secs, 0 bytes)
11:16:03 <Solonarv> % import Control.Monad.Reader
11:16:03 <yahb> Solonarv: (0.00 secs, 0 bytes)
11:16:07 <Solonarv> % let readerState k = get >>= runReaderT k
11:16:07 <yahb> Solonarv: (0.02 secs, 148,448 bytes)
11:16:12 <Solonarv> % :t readerState
11:16:12 <yahb> Solonarv: forall {r} {m :: Type -> Type} {b}. MonadState r m => ReaderT r m b -> m b
11:16:40 <Solonarv> Does that help?
11:16:57 <jakov> how can i make the 'Maybe (IO Handle)' a 'IO( Maybe Handle)'
11:17:17 <ClathomasPrime_> @solonarv looks promising! 
11:17:17 <lambdabot> Unknown command, try @list
11:17:25 <Solonarv> 'sequenceA' is what you want, jakov
11:17:59 <Solonarv> % :t sequenceA (undefined :: Maybe (IO Handle))
11:17:59 <yahb> Solonarv: ; <interactive>:1:35: error: Not in scope: type constructor or class `Handle'
11:18:18 <Solonarv> gah! yahb, what happened to your imports!
11:18:34 <Solonarv> % :t sequenceA (undefined :: Maybe (IO Handle))
11:18:34 <yahb> Solonarv: IO (Maybe Handle)
11:19:10 <Solonarv> jakov: ^
11:32:53 <jakov> Thank you very much, i still have to dig through some type mess I produced. It's highly possible that i will have more questions to come :D 
11:35:07 <jakov> And if i have a 'data DeviceHandle = Maybe Handle', how do i make a 'Nothing' type of DeviceHandle ?
11:36:07 <amalloy> jakov: that's not the type you think it is
11:36:27 <amalloy> you probably meant `type DeviceHandle = MaybeHandle`
11:36:37 <amalloy> Maybe Handle, that is
11:37:03 <cocreature> or add a constructor name
11:37:40 <cocreature> "data DeviceHandle = Maybe Handle" creates a constructor called Maybe that takes a single argument of type Handle
11:37:43 <jle`> instance Semigroupoid (,)
11:37:45 <jle`> cute
11:37:56 <monochrom> What is Semigroupoid?
11:38:06 <jle`> Category with no id
11:38:13 <monochrom> Oh, that.
11:38:16 <jle`> like how a Category is a Groupoid
11:38:42 <jakov> sorry to bother you here, i just figured out, that i have to read up on the difference between 'data' and 'type'.
11:38:58 <monochrom> Does it go like (x,y) >>> (y,z) = (x,z)?
11:39:01 <jle`> er, a category that is invertible is a groupoid
11:39:33 <jle`> monochrom: yes, or, well, the other way around, for kind-checking
11:39:49 <monochrom> Neato.
11:40:14 <jle`> i guess not kind-checking, but for consistency with the  (->) instance
11:55:18 <Bish> hi im still trying to figure out how exactly sequenceA works
11:55:27 <Bish> (:) <$> (Just 1) <*> ([]::[Maybe Int]) shouldn't this work?
11:55:39 <Bish> dminuoso: *wink*
11:56:08 <ski> > (:) <$> (Just 1) <*> sequenceA ([]::[Maybe Int])
11:56:10 <lambdabot>  Just [1]
11:56:23 <jle`> Bish: <*> has to take things of the same 'f'
11:56:32 <jle`> you gave it a Maybe Int, and a [Maybe Int]
11:56:47 <jle`> maybe try giving it a `Maybe Int` and a `Maybe [Int]`
11:56:49 <Bish> i do+'t see it
11:57:03 <jle`> maybe it would be easier if we use [] in prefix form
11:57:09 <jle`> you gave it a `Maybe Int` and a `[] (Maybe Int)`
11:57:15 <Bish> no that's not what confusing me
11:57:21 <ski> > liftA2 (:) (Just 1) (sequenceA ([] :: [Maybe Int]))
11:57:23 <lambdabot>  Just [1]
11:57:25 <Bish> i literally don't see the difference in what ski wrote and mine :D
11:57:37 <ski> i added `sequenceA'
11:57:41 <jle`> Bish: ski added 'sequenceA'
11:57:45 <Bish> ohhhh
11:58:03 <jle`> sequenceA :: [Maybe Int] -> Maybe [Int]
11:58:05 <ski> which converts from `[Maybe Int]' to `Maybe [Int]', here
11:58:09 <Bish> yeah i get it
11:58:32 <ski> and `(:)' wants an `Int', and a `[Int]', giving a `[Int]'
11:58:51 <ski> so `liftA2 (:)' wants a `Maybe Int', and a `Maybe [Int]', giving a `Maybe [Int]'
11:59:13 <ski> and `liftA2 (:) foo bar' is just another wau to write `(:) <$> foo <*> bar'
11:59:21 <ski> s/wau/way/
11:59:52 <Bish> wau! thank you!
11:59:53 <ski> so, you were attempting to feed a `[Maybe Int]' where a `Maybe [Int]' was expected
12:00:00 <jle`> or you could say that `Just (1:) :: Maybe ([Int] -> [Int])`
12:00:12 <jle`> and so Just (1:) <*> _, _ should be Maybe [Int]
12:00:22 <Bish> that's how sequenceA [Just 1, Nothing] is just nothing
12:00:33 <jle`> it's not Just Nothing, it's Nothing ;)
12:00:38 <Bish> yeah :>
12:01:08 <ski> `sequenceA' gives `Nothing' if there's any `Nothing' in the list, otherwise it gives `Just vals', where `vals' is the list of values, with all the `Just's stripped away
12:01:24 <jle`> sequenceA is essentially liftAN
12:02:11 <jle`> ....i guess the analogy isn't perfect
12:02:13 <dmwit> ?quote Goldilocks
12:02:13 <lambdabot> Sgeo says: What did Goldilocks say upon seeing "Maybe (b -> Either a b)"? It's Just Right!
12:02:21 <ski> (compare with `catMaybes', which just filters out all the `Nothings', and then removes the `Just's in front of the remaining elements. in this case you get an empty list only if *all* the original elements were `Nothing's)
12:02:33 <Bish> dminuoso: good one
12:03:45 <Bish> dmwit: *
12:04:12 <Bish> uhm, if i watch at the definition of the function
12:04:17 <Bish> Nothing <*> _m      = Nothing
12:04:19 <Bish> that makes sense
12:04:30 <Bish> (:) <$> Just 1 <*> (Nothing)
12:04:39 <Bish> but what about the other way around?
12:06:34 <t7> is there a nice way to see my expression reductions?
12:06:59 <ski> perhaps `stepeval', if you have simple expressions
12:07:02 <ski> @where stepeval
12:07:02 <lambdabot> <http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi>,<https://github.com/bmillwood/stepeval>
12:07:37 <ski> Bish : `_ <*> Nothing = Nothing', and `Just f <*> Just x = Just (f x)'
12:08:21 <Bish> ski: where would i nread that?
12:08:32 <Bish> _ <*> Nothing = Nothing can't remember seeing that
12:10:06 <Bish> that would totally make sense too me, but i don't know where to read that
12:10:59 <cocreature> Bish: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-841 it’s not quite implemented like that but if you expand the definition of fmap you can see that it will behave like that
12:11:06 <cocreature> (minus strictness in the first argument)
12:11:53 <Solonarv> Bish: You can find this by going to the documentation for 'Applicative', here: https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Applicative
12:11:57 <Bish> cocreature: that's exactly what i read 
12:12:14 <Solonarv> then scroll down to the "Instances" section, and click "Source" next to the instance for []
12:12:17 <ski> Bish : <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.12.0.0/src/GHC-Base.html#instance%20Applicative%20Maybe>
12:12:22 <Bish> Solonarv: i get how applicative worrks i just don't understend the specific context
12:12:44 <Solonarv> ...err, next to the instance for Maybe
12:12:45 <Bish> ski: i am read that but' can't see a Just something <*> Nothing
12:13:01 <ski> see `fmap' on the lines just above
12:13:02 <Bish> only a Nothing <*> _
12:13:19 <Solonarv> Bish: that falls under the 'Just f <*> m' case
12:13:23 <Bish> ah.. so that happens inside
12:13:28 <Bish> (:) <$>
12:13:29 <Bish> ?
12:13:33 <ski>   Just f <*> m  =  fmap f m
12:13:36 <ski> so
12:13:47 <ski>   Just f <*> Nothing  =  fmap f Nothing  =  Nothing
12:13:48 <ski> and
12:13:59 <Bish> so in the sequenceA implementation
12:14:05 <ski>   Just f <*> (Just a)  =  fmap f (Just a)  =  Just (f a)
12:14:09 <Bish> the <$> does this
12:14:13 <Bish> right?
12:14:27 <ski> `(<$>)' is just another name for `fmap'
12:14:32 <Bish> so, yes?
12:14:34 <Bish> just making sure
12:14:47 <ski> (i'm not sure what you mean by "this")
12:14:55 <Bish> (:) <$> Nothing <*> (Just [1])
12:14:57 <Bish> this is nothing
12:15:04 <Bish> because Nothing <*> _ = Nothing
12:15:21 <ski>      (:) <$> Nothing <*> Just [1]
12:15:27 <ski>   =  ((:) <$> Nothing) <*> Just [1]
12:15:36 <ski>   =  Nothing <*> Just [1]
12:15:38 <ski>   =  Nothing
12:16:13 <Bish> (:) <$> (Just 1) <*> (Nothing)
12:16:15 <ski> (first step is just inserting brackets, for disambiguation/clarification)
12:16:30 <ski>      (:) <$> Just 1 <*> Nothing
12:16:37 <ski>   =  ((:) <$> Just 1) <*> Nothing
12:16:54 <ski>   =  Just (1 :) <*> Nothing
12:17:00 <ski>   =  fmap (1 :) Nothing
12:17:03 <ski>   =  Nothing
12:17:12 <Bish> coooool
12:17:18 <Bish> that's what i was missing the whole time
12:17:29 <Bish> thanks a bunch
12:17:32 <ski> np
12:17:38 <jakov> cocreature , what is the difference between 'data DeviceHandle = DeviceHandle Maybe Handle' and 'data DeviceHandle = Maybe Handle'
12:17:54 <aplainzetakind> Can something like this be expressed more succintly without do notation in the List monad: do { a <- xs; (: a) <$> filter (not . (`elem` a)) ys }
12:18:35 * ski idly wonders whether aplainzetakind meant `(a :)' rather than `(: a)'
12:18:45 <ski> (otherwise, `a' is a list)
12:18:51 <aplainzetakind> ski: it is
12:19:01 <Solonarv> flip (:)<$> a <*> filter (...) ys -- that should do it
12:19:03 <aplainzetakind> [[a]] -> [a] -> [[a]]
12:19:27 <ski> so `xss' is a list of lists, and `ys' is just a list
12:19:32 <Solonarv> oh wait, I missed the fact that you're using 'a' in the argument to 'filter'
12:19:53 <ski> er, `xs', not `xss'
12:20:02 <Solonarv> @. pf undo do { a <- xs; (: a) <$> filter (not . (`elem` a)) ys }
12:20:02 <lambdabot> Plugin `compose' failed with: user error (Unknown command: "pf")
12:20:07 <ski> (my mind auto-corrected it to `xss' without me realizing it ;)
12:20:11 <Solonarv> @. pl undo do { a <- xs; (: a) <$> filter (not . (`elem` a)) ys }
12:20:11 <lambdabot> ap ((<$>) . flip (:)) (flip filter ys . (not .) . flip elem) =<< xs
12:20:19 <Solonarv> oh god.
12:20:32 <aplainzetakind> Well that settles it :)
12:20:48 <Solonarv> `@. pl undo`: not even once
12:21:28 <aarvar> aplainzetakind: you could use >>= instead of do notation, but it doesn't make much difference
12:21:45 <aplainzetakind> To clarify, I want to get products of lists while weeding out repetitions.
12:22:15 <aplainzetakind> By product, I mean still getting lists and not tuples.
12:22:45 <aplainzetakind> I can just fold what I wrote above of course.
12:23:15 <aplainzetakind> But maybe there's a cool sequencing way to do it that would be nice to know.
12:23:21 <ski>  [ y:xs | xs <- xss,y <- ys,y `notElem` xs]  -- aplainzetakind, how about a list comprehension ?
12:23:28 <aarvar> yuck
12:23:57 * ski smiles
12:24:23 <ski> @type elem
12:24:24 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
12:24:27 <ski> @type notElem
12:24:28 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
12:25:07 <aplainzetakind> ski: Sure that would also do.
12:25:29 <ski> jakov : the latter is almost surely a mistake, since it's not talking about the type constructor `Maybe'. instead it's generating a data constructor named `Maybe', having type `Handle -> DeviceHandle'
12:25:47 <cocreature> jakov: the second one behaves as I’ve explained, the first one creates a constructor called DeviceHandle that takes two arguments one of type Maybe and one of type Handle. what you probably want is data DeviceHandle = DeviceHandle (Maybe Handle) which creates a constructor called DeviceHandle that takes a single argument of type Maybe Handle
12:26:00 <MarcelineVQ> this conversation doesn't have enough tails in it
12:26:24 <ski> jakov : `data' (and `newtype') generates a *new* type, and requires data constructor names. `type' just gives a new name to an existing type, doesn't generate any new data constructors
12:28:25 <ski> jakov : with `data' (and `newtype'), the first thing after the `=' is not a type, but a data constructor (which lives in the value world, not in the type world)
12:28:53 <ski> jakov : with `type', what's written after `=' is a single type (like `Maybe Handle', e.g.)
12:30:01 <ski>   data MyNewTypeConstructor = MyNewDataConstructor0 ExistingType00 ExistingType01 ... | MyNewDataConstructor1 ExistingType10 ExistingType11 ... | ...
12:30:02 <jakov> cocreature : thank you what was exaclty what i needed !! 
12:30:19 <ski>   newtype MyNewTypeConstructor = MyNewDataConstructor ExistingType
12:30:38 <ski>   type NewNameForExistingType = ExistingType
12:30:52 <ski> `type' declares a synonym, a new name, for an existing type
12:31:15 <jakov>  ski : thank you, but the difference between 'type' and 'data' is quite simple. 
12:31:24 <ski> `newtype' is like `data' here, with the restriction that there can (must) only be a single data constructor, and it can (must) only have a single argument
12:32:02 <ski> (there are also some differences in behaviour of values of a type declared using `data' vs. `newtype', but i'll refrain from stating that here)
12:32:34 <jakov> yes. thanks. i can read up the latter. 
12:34:53 <jakov> ski, thank you for your explanations, i didn't mean to be rude. 
12:35:44 <ski> no problem (i didn't take it to be rude)
12:36:28 <dmwit> aplainzetakind: Can you arrange for your input lists not to have duplicates instead?
12:36:35 <jakov> could you please tell me how i could make a 'Nothing' of type DeviceHandle where 'data DeviceHandle = DeviceHandle (Maybe Handle)'
12:36:55 <jakov> I hope, that from all i have learned, the question makes sense !?
12:37:32 <ski> jakov : fwiw, i would suggest that you actually say something like `data DeviceHandle = MkDeviceHandle (Maybe Handle)', naming the type constructor and the data constructor differently. it will make the difference between them clearer in your head, i think
12:37:34 <monochrom> It contains a conceptual error. But the answer is "DeviceHandle Nothing".
12:37:45 <ski> (and it makes it easier for us to refer to them)
12:38:07 <ski> jakov : given that, use `MkDeviceHandle Nothing' to construct a value of type `DeviceHandle'
12:38:15 <monochrom> Or maybe s/conceptual error/poor wording/
12:39:05 <monochrom> And yeah it is also advisable to rename to MkDeviceHandler to deconfuse yourself and your readers.
12:39:25 <ski> jakov : strictly speaking, this is not "a 'Nothing' of type DeviceHandle", it's a `Nothing', wrapped inside a `DeviceHandle' (via the `MkDeviceHandle' data constructor, which is what's wrapping the `Nothing')
12:40:39 <ski> (if you prefer you could use `MakeDeviceHandle' or `ConstructDeviceHandle' or `MkDH' or `DH', or perhaps some other name which you fancy better)
12:41:29 <kAworu> Hi everyone, I'm new to Haskell and regret not having learning it sooner :)
12:41:32 <dmwit> (N.B. The suggestion is to use distinct names while you are learning; it is not a suggestion that good, production code should do this.)
12:41:38 <ski> welcome, kAworu
12:42:17 * ski would actually suggest doing this in good production code as well
12:42:22 <ski> (maybe i'm weird ?)
12:43:06 <dmwit> Okay. Well I have different taste than ski (and my taste is obviously the best one).
12:43:22 * ski grins
12:43:38 * DigitalKiwi tastes the best
12:43:54 <dmwit> Kiwi *is* a pretty great taste.
12:44:14 * ski idly wonders whether digital kiwis have a color
12:44:22 * DigitalKiwi chirps in agreement
12:44:28 <ski> (and can they fly ?)
12:44:31 <dmwit> They have the same color as other kiwis, just more fingers.
12:45:12 <dmwit> They're hairy and brown and taste great. Now am I talking about a bird or fruit?
12:45:24 <ski> yes
12:45:42 <DigitalKiwi> https://img00.deviantart.net/c85f/i/2008/035/b/7/how_to_prepare_a_kiwi_by_sojiokage.jpg
12:46:14 <ski> kAworu : .. i hope you have access to some reasonable learning resources. also feel free to ask newbie/beginner questions here. or just lurk around, sometimes trying to follow conversations
12:49:12 <Solonarv> You can also ask beginner question in #haskell-beginners instead
12:49:25 <ski> (or in addition ..)
12:53:25 <jakov> oho.. that's the way it works. Sweet. I am very grateful for your help ! If i would use the same string for the constructor and the type, is ghc able to tell them apart ?
12:54:09 <ski> yes (except in export and import lists, where it's ambiguous)
12:54:50 <ski> (you can mention the data constructors in brackets after the type constructor though)
12:55:37 <jakov> nice ...
12:59:08 <monochrom> Actually there is no ambiguity because "module F(Ctor) where data T = Ctor Int" is disallowed.
12:59:31 <jakov> still in the sence of all the deviceHandle stuff with 'data DeviceHandle = MkDeviceHandle (Maybe Handle)', how do i make a 'Handle' of type 'DeviceHandle' with a 'Just' ?
12:59:49 <monochrom> So if you have "module F(T) where data T = T Int" then "F(T)" always means the type T not the data constructor T.
12:59:55 <ski> > let rec = "rerecursing" : [c | 'r':'e':c <- rec] in rec
12:59:57 <lambdabot>  ["rerecursing","recursing","cursing"*Exception: <<loop>>
13:02:14 <monochrom> Hrm that's interesting.
13:03:04 <monochrom> I think I have to do that "sequence of convergents starting from bottom" to see what's going on.
13:04:29 <zachk> jakov, maybe try MkDeviceHandle (Just needAHandleHere) or using Nothing there 
13:05:26 <ski> hm, just checked, and indeed an export list `(T)' only exports the type constructor (not both). perhaps the behaviour changed ?
13:05:43 <jakov> still in the sence of all the deviceHandle stuff with 'data DeviceHandle = MkDeviceHandle (Maybe Handle)', how do i make a 'Handle' of type 'DeviceHandle' with a 'Just' ?
13:05:48 <jakov> sry .. 
13:06:21 <ski> anyway, the `rec' thing is just the usual breadth-first traversal of a tree biting its own tail if the tree is finite
13:06:32 <ski> i'm not aware of a nice way to avoid that ..
13:06:37 <amalloy> jakov: after writing `data DeviceHandle = MkDeviceHandle (Maybe Handle)`, try asking ghci `:t MkDeviceHandle`. you will see that you've made a function of type `Maybe Handle -> DeviceHandle`
13:06:55 <ski> jakov : call `MkDeviceHandle' with a value constructed via `Just'
13:07:02 <amalloy> and since you already know how to build objects of type Maybe Handle, you therefore know how to build objects of type DeviceHandle
13:07:08 <ski> jakov : e.g. `MkDeviceHandle (Just h)', if `h' is a `Handle'
13:07:31 <monochrom> ski: No, Haskell 98 (or even older) has "Data constructors cannot be named in export lists except as subordinate names"
13:07:52 <ski> monochrom : oh, i must be confused then. ty
13:08:22 <monochrom> The motivation is "would be ambiguous otherwise" but then once the rule is set in stone you won't be excused even if you are not cauing any ambiguity :)
13:09:18 <jakov> ski , thank you i have come that far. now i have to get it out of IO, where i have an IO function with IO(Handle) , and i would want to cast is to type IO(DeviceHandle).. 
13:09:54 <ski> i suppose i've always been careful to either list the data constructors explicitly in a bracket, or use `..', and so i've not noticed the mismatch in expected and actual behaviour there
13:09:59 <dmwit> There could be other solutions. Foo() vs _(Foo), e.g.
13:10:29 <jakov> and 'sequenceA MkDeviceHandle openFileFunc' does not work. 
13:10:31 --- mode: glguy set +v ilyakooo0
13:10:50 <ski> jakov : use `fmap f myIOAction', where `myIOAction' has type `IO Handle', and `f' has type `Handle -> DeviceHandle'
13:10:50 <dmwit> Interesting. What led you to believe it *would* work?
13:11:19 <ski> jakov : or use the `<-' syntax in `do'-notation to extract a `Handle' by executing your `myIOAction'
13:11:30 <ski> (namely `h <- myIOAction')
13:11:50 <jakov> thx, i'll try it out ! 
13:12:48 <ski> jakov : `sequenceA' takes a list (or other traversable structure, including `Maybe') containing actions. `MkDeviceHandle' is not a list (or `Maybe' or other structure) containing I/O-actions
13:13:57 <ski> jakov : nor would `sequenceA (MkDeviceHandle openFileFunc)' work, since `DeviceHandle' isn't a traversable structure (and `openFileFunc' is presumably not an `IO'-action, but merely a function that, when passed some argument(s) will return such an action)
13:14:40 <ski> (and in any case `MkDeviceHandle' does not want an I/O-action, nor a function. it wants `Maybe' a `Handle')
13:15:29 <kAworu> ski: Thanks! I'm reading http://learnyouahaskell.com/ and have been fluent in Scala, Ocaml and Rust so I don't feel completely lost, but I came here to do just what you suggested :)
13:16:43 <ski> kAworu : it has been suggested that LYAH isn't that good as an introduction. e.g. if you want some exercises (which LYAH lacks), you could try
13:16:47 <ski> @where CIS194
13:16:47 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
13:16:59 <geekosaur> dmwit, they asked earlir and got a bad answer
13:17:29 <geekosaur> (guessing with no source in evidence. I'd wondered about that btu was working on tring to wake up the rest of the way)
13:17:52 <ski> kAworu : ok, so since you're familiar with OCaml, then perhaps the "Gentle introduction" might actually not be too bad, in your case, then
13:17:59 <ski> @where tutorial
13:17:59 <lambdabot> http://www.haskell.org/tutorial/
13:18:28 <ski> (people have expressed that one not being so "Gentle", if you don't already know basic FP)
13:19:52 <ski> kAworu : at some point, i would suggest getting a textbook
13:20:02 <ski> in the meantime, you could also try e.g.
13:20:05 <ski> @where wikibook
13:20:05 <lambdabot> http://en.wikibooks.org/wiki/Haskell
13:20:28 <ski> (i haven't read that one, but some others seem to think it's ok)
13:20:46 <monochrom> It is OK. It may even be sufficient.
13:24:58 <kAworu> ski: Thanks, I'll take a look!
13:25:51 <dmwit> geekosaur: Thanks. I actually didn't care that much about the answer, but was trying to start a conversation that might give me a handle to help them correct some misunderstanding.
13:26:00 <dmwit> But they seem to have gotten what they wanted, so no sweat.
13:26:26 <geekosaur> but my point was the misunderstanding came from being misled earlier
13:26:48 * dmwit nods
13:27:12 <bsima> is there a way to run the test suite after it has been built with stack --no-run-tests?
13:27:17 <bsima> can't find this in the docs
13:29:54 <dmwit> Maybe this is a stupid question, but... does `stack test` not work?
13:30:41 <bsima> i've got a stupider situation - "stack test" builds and runs the test suite, but I'm building in docker with multi-stage builds
13:31:07 <bsima> so the docker container i'm building in doesn't have access to the environment variables needed to connect to the database
13:31:41 <dmwit> That... doesn't really seem like a thing you're going to fix by massaging your stack command line.
13:32:08 <bsima> was hoping i could create a myproject-test executable, then run that in the deployable docker container
13:32:28 <bsima> which would run the tests in the proper environment
13:33:11 <dmwit> Okay. That seems like it should be possible.
13:33:26 <dmwit> I don't know where stack stores its build products, but I would poke around in .stack-work first.
13:33:54 <bsima> afaict it just generates a 'myproject' executable, nothing with tests
13:33:55 <dmwit> Or e.g. `find . -name <name-of-your-test> -executable -type f`.
13:34:35 <dmwit> Hm. Are you sure you asked it to build the test?
13:34:43 <bsima> yep
13:35:06 <bsima> i don't think this is possible, i've read thru most of the docs, and i've been using stack for a while now
13:36:08 <jakov> ski : Thank you very much for your support! It worked out very well :D
13:36:21 <bsima> *maybe* i could do something weird with Setup.hs, creating a second executable that only runs the tests
13:36:42 <bsima> idk, i should probably fix this at the docker level
13:38:15 <vaibhavsagar> how do I get cabal to be super verbose when building?
13:38:29 <vaibhavsagar> is there a configure flag I can pass?
13:38:47 <monochrom> Adding -v or -v2 or -v3 to the command line.
13:39:15 <vaibhavsagar> when building or configuring?
13:39:22 --- mode: glguy set +v roidusilence
13:39:42 <monochrom> building
13:40:02 <vaibhavsagar> hmm, is there a configure flag?
13:40:10 <vaibhavsagar> I'm doing this with Nix
13:40:28 <monochrom> I don't know nix.
13:40:54 <ski> jakov : yw
13:41:17 <ski> kAworu : ditto :)
13:42:11 <monochrom> There is one in $HOME/.cabal/config and you can make it "verbose: 3" but that's way too permanent and global.
13:43:09 <monochrom> Then again that's what everyone would do when BASIC was the mainstream language and everything had to be global variables.
13:44:52 <monochrom> It also means that now "cabal configure" is also very verbose.
13:45:15 <roidusilence> yo, latest stack resolver prevents sfml from building because of deprecated warnings in the c code
13:45:22 <roidusilence> How do I allow it ?
13:45:34 <Solonarv> more easily: stack exec -- where <name-of-exe>
13:47:42 <dmwit> Ah, yes, I knew that trick with cabal, and should have thought to transfer it to stack.
13:57:55 <roidusilence> anyone knows how I can change the c compiler link flags in stack ?
13:59:34 <monochrom> Actually maybe it honours the environment variable CCFLAGS?
14:05:28 <roidusilence> maybe, but I dont get why it would build with one resolver and not the other
14:05:36 <roidusilence> if it was the case
14:05:39 <roidusilence> I'll check
14:16:58 <roidusilence> haha monochrom
14:17:01 <roidusilence> you were right
14:17:24 <roidusilence> I just added -Wno-deprecated-declarations to the CFLAGS env variable and it worked
14:17:30 <roidusilence> thank you =)
14:20:01 <monochrom> Oh oops it's CFLAGS but congrats.
14:26:43 <safinaskar> is there somewhere graph of inclusion of common type classes? (i. e. Monad, Applicative, Alternative, etc) preferrable it should capture post-applicative-monad-proposal world
14:27:01 <safinaskar> and preferrable with links to docs or something like that
14:27:24 <geekosaur> @where typeclassopedia
14:27:24 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
14:27:50 --- mode: glguy set +v nefple[m]
14:29:48 <aplainzetakind> Is there a two bit unboxed type? I can't make new unboxed types from old, right?
14:30:33 <Solonarv> I don't think there's even a one-bit unboxed type
14:30:40 <geekosaur> unboxed types are typically machine words, aside from ByteArray# and such
14:31:00 <aplainzetakind> Solonarv: Isn't Bool unboxed?
14:31:06 <geekosaur> no
14:31:08 <monochrom> Bool is very boxed.
14:31:33 <geekosaur> Bool consists of a machine word representing a constructor tag.
14:31:56 <nshepperd1> . o O (boxed types, gift wrapped types)
14:32:22 <glguy> You know, Unboxed, Boxed, Very-unboxed
14:32:24 <c_wraith> nshepperd1, did you read ezyang's posts about the topic? :P
14:32:55 <aplainzetakind> Hmm. Doesn't an array being unboxed mean its elements are unboxed then?
14:33:03 <monochrom> Maybe "very" is a hyperbole.
14:33:05 <nshepperd1> c_wraith: haha no, which one?
14:33:14 <monochrom> Yes.
14:33:43 <c_wraith> nshepperd1, http://blog.ezyang.com/2011/04/how-the-grinch-stole-the-haskell-heap/ (not the first in the series, but the best named)
14:33:51 <aplainzetakind> MArray has an (STUArray s) Bool (ST s) instance.
14:34:03 <safinaskar> geekosaur: thanks
14:35:31 <glguy> My understanding is that people make unboxing videos and put them on YouTube, but I there might be a market for videos where you unbox things like Int, Bool, ... arrays!
14:36:41 * ski . o O ( chess-unboxing )
14:36:48 <c_wraith> this could be an instructional video for edwardk's struct library
14:36:53 <nshepperd1> c_wraith: this is lovely :)
14:37:02 <MarcelineVQ> Your ideas are intriguing to me and I wish to subscribe to your newsletter.
14:38:06 <aplainzetakind> So what does it mean to have an unboxed array of very boxed Bools?
14:38:38 <glguy> It means that there aren't actually Bools stored in the array
14:38:39 <monochrom> aplainzetakind: There is no implicational relation between "is type X boxed or unboxed?" and "did someone implement a unboxed array of X items?"
14:39:16 <aplainzetakind> OK, it looks like Bool to me but under the hood it's lower level.
14:39:18 <glguy> The Bools are reconstituted when you read from the array
14:39:23 <geekosaur> aplainzetakind, if you have a bunch of Bools as a group (array) you can represdent them as a byte array with bit ops
14:39:34 <monochrom> We know because Int is boxed but STUArray ... Int ... exists.
14:40:02 <monochrom> In fact the vector package goes so far as to do unboxed Complex Double.
14:40:12 <monochrom> err, unboxed array of Complex Double.
14:40:36 --- mode: glguy set -v nefple[m]
14:40:47 <aplainzetakind> Can I somehow have a STUArray ... somethingWithFourValues ...?
14:41:16 <monochrom> It just means that whenever you fetch one item from the array, time is spent on reboxing; and whenever you write, time is spent on evaluating and unboxing.
14:41:49 <monochrom> STUArray is closed, you aren't allow to extend it.
14:42:34 <monochrom> But the vector package's version is open, you can extend it.  Usually it means you use four arrays of basic things to represent an array of 4-tuples.
14:42:53 <monochrom> Indeed that's what it did to Complex Double: 2 arrays of Double.
14:42:57 * ski . o O ( `STUArray s i (STUArray s j e)' ? )
14:43:15 <c_wraith> ski, I don't think that has an instance 
14:43:25 <glguy> aplainzetakind: You'd need to make an instance http://hackage.haskell.org/package/array-0.5.3.0/docs/Data-Array-MArray.html#t:MArray
14:43:47 <glguy> This package doesn't go out of its way to make it easy to write new instances
14:43:59 <ski> (hm, perhaps that's the wrong question. s/STUArray/UArray/)
14:44:22 <c_wraith> in fact it goes out of its way to hide a lot of the documentation.
14:44:33 <c_wraith> I'm not sure why array does that.
14:45:41 <monochrom> Oh it's MArray that's closed.
14:47:01 <monochrom> I think the idea is "this is an API for primitives".
14:47:47 <monochrom> err that's ambiguous wording. A user-facing API but can only be backed by primitives.
14:48:08 * ski . o O ( one man's primitive is another man's library operation )
14:48:22 <ski> (.. i know what you mean, though)
14:48:40 <monochrom> I am a very tall person. >:)
14:49:08 <monochrom> "Everything is awesom"
14:54:30 <monochrom> Understandably "unboxed array" is ambiguous. The convention is: It means individual items are unboxed. The whole array itself is still boxed because you have to put it on the heap. (Definition of boxed: Put it on the heap, pass around address.)
14:55:33 <monochrom> And so you have a little bit of ugly relation (or no-relation) between the unboxed-boxed axis and the unlifted-lifted axis.
14:56:14 <aplainzetakind> What is the unlifted-lifted axis?
14:56:16 <monochrom> A primitive array is unlifted (cannot have bottom) but has to be boxed.
14:56:30 <monochrom> "can you have bottom?"
14:56:58 <aplainzetakind> Isn't bottom non-halting?
14:57:54 <Solonarv> that's one way for something to be bottom
14:58:03 <Solonarv> "throw an exception" is another
14:58:08 <monochrom> Would you like the fairy tale answer or the adult life answer?
14:58:19 <aplainzetakind> Adult life please.
14:58:24 <Fairy> I'd take a tale, please.
14:59:03 <c_wraith> bottom just means "cannot be evaluated to a value belonging to the expression's type"
14:59:20 <monochrom> Adult life answer: Could be non-termination, exception, and maybe something else I forgot.
14:59:38 <c_wraith> unless you take the domain theory pov that bottoms inhabit all types...
15:00:25 <aplainzetakind> In most things I read it was the latter I think.
15:00:34 <ski> % let x :: GHC.Exts.Int#; x = undefined in GHC.Exts.I# x
15:00:35 <yahb> ski: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:1:29 in interactive:Ghci4
15:01:11 <ski> % let f :: () -> GHC.Exts.Int#; f () = f () in GHC.Exts.I# (f ())
15:01:16 <yahb> ski: [Timed out]
15:02:03 <monochrom> Maybe I should not have used the denotational bottom criterion. Maybe I should have used the operational laziness criterion.
15:02:29 <monochrom> Unlifted doesn't support laziness. Lifted supports laziness.
15:02:43 <zachk> is bottom really a haskell thing? or is it more of a semantic thing? 
15:03:01 <monochrom> Yes and yes. Haskell has a semantic story too.
15:03:31 <ski> you could say that the (denotational) meaning of any non-terminating expression in any language is bottom. but then in most languages, all functions are strict
15:04:01 <monochrom> Dude, in a denotational story, there is no "termination" or "non-termination".
15:04:22 <ski> yea, mea culpa. i should say something like "no information"
15:04:23 <monochrom> If you don't perform computational steps you have no such thing.
15:04:44 <monochrom> Yeah, only "how much of an answer will you get"
15:04:49 <ski> an expression that computes no information
15:05:59 <ski> (anyway, you tend to get away with not thinking about bottom in your semantic domains, as being a "semantic value", because of function strictness)
15:06:39 <ski> monochrom : ty
15:07:15 <aplainzetakind> Immutability concerns language semantics only right? Nothing is implied about what goes on post-compilation?
15:07:23 <ski> (for calling me out on this. i need to restructure my vocabulary there)
15:07:41 <monochrom> I don't understand the question.
15:08:01 <geekosaur> the rts uses mutability under the hood, if that's what you're asking
15:08:09 <ski> aplainzetakind : it concerns reasoning at the level of the language, yes
15:08:21 <monochrom> I don't think semantics and post-compilation are disjoint, for one of many problems with that question.
15:08:48 <ski> ("having side-effects" is a POV thing, relative to the language you're reasoning in)
15:09:20 <aplainzetakind> I know my question lacks precise terminology, because I don't know the precise terminology for these things, but roughly.
15:09:30 <monochrom> You can give examples.
15:09:43 <monochrom> You can think up and describe a scenerio. Etc. etc.
15:09:47 <sm> hey all.. aren't there tricksy case expressions you can use to emulate a switch statement ? ie where the left hand side are boolean values, not patterns
15:09:54 <aplainzetakind> If I run an immutable array through a recursive thing, it doesn't necessarily produce a gazillion copies in memory right?
15:10:01 <sm> having trouble finding/doing it
15:10:06 <monochrom> It may.
15:10:11 <aplainzetakind> Depending on how I write the recursion I know.
15:10:24 <aplainzetakind> whence I said necessarily.
15:10:31 <MarcelineVQ> sm: is that different than guards?
15:10:33 <geekosaur> sm, you may be thinking of MultiWayIf?
15:10:37 <ski> sm : perhaps you're thinking of `case () of () | blah -> ... | bleh -> ... | bloh -> ...' ? also see `MultiWayIf'
15:10:58 <geekosaur> which is just a set fo guards without a case pattern, short for what ski just said
15:11:41 <ski> aplainzetakind : more details are probably needed
15:11:58 <monochrom> "f a = f a" won't clone.  "f a = f (a // [(4, 'x')]" will clone-and-modify.
15:12:31 * ski . o O ( hold-and-modify )
15:12:37 <monochrom> For high-quality wording I wouldn't combine negation with modal operators e.g. "not necessary" "not possible"
15:12:56 <sm> yes I was thinking of both those things. I just figured out https://gist.github.com/simonmichael/9b209b192de2ba79232475a50fdc0061, but I had to write the _ before each |
15:13:23 <monochrom> Because "not (necessary P)" vs "necessary (not P)".
15:14:00 <sm> MultiWayIf looks like the modern way. Thanks!
15:14:03 <aplainzetakind> "it doesn't necessarily" vs "necessarily it doesn't"
15:14:06 <absence> :t liftA2 -- are there structures that would let you provide something like f a -> g b -> g c or f a -> g b -> h c, or would you need a completely specific/custom "ap" for a given g and possibly h?
15:14:07 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:14:31 <nshepperd1> All that glitters is not gold
15:14:39 <monochrom> Did you know: "Everyone is not happy" means "not (everyone is happy)".
15:15:03 <monochrom> See also: "All is not lost".
15:15:14 <monochrom> English sucks. Don't bet your life on it.
15:15:57 <aplainzetakind> I don't intend to. It's easy to disambiguate when need arises.
15:15:59 * ski . o O ( also see "'The' Modal Fallacy" by Norman Swartz at <https://web.archive.org/web/20171217095728/http://www.sfu.ca:80/~swartz/modal_fallacy.htm> )
15:16:00 <sm> oh that's great, glad to know that finally
15:16:08 <sm> these little conveniences help
15:16:13 <aplainzetakind> Everyone s unhappy, it's not the case that everyone is happy, etc.
15:16:50 <monochrom> It is easy for the speaker to clarify when the audience requests. Not for the audience to guess.
15:17:22 <monochrom> Also, repetition is not clarification.
15:19:01 <aplainzetakind> Maybe my English isn't good enough, but I just don't see the ambiguity in "not necessarily".
15:19:46 <monochrom> OK maybe I didn't make myself clear.
15:20:12 <monochrom> When the audience requests clarification, you give it.  You don't argue why you don't need to.
15:22:02 * ski idly ponders doing both
15:27:30 <nshepperd1> "not necessary" isn't ambiguous
15:30:16 <nshepperd1> But i suppose anything can leave doubt when there's a nontrivial chance that people say it wrong
15:30:38 <monochrom> There is also the angle of confirmation.
15:31:29 <monochrom> Suppose you and your dentist make an appointment that on April 27th 2019 you will be visiting the dentist for regular checkup and cleaning etc.
15:31:53 <monochrom> On April 26th the dentist's receptionist will phone you to remind you of the appointment.
15:32:23 <monochrom> Do you fire back to say "this is stupid, there is no ambiguity, why are you wasting my time"?
15:32:36 <aplainzetakind> What I said basically meant "yes I meant it in that sense". I'm baffled that it got construed as arguing I don't need to clarify myself, and that this is going on for so long.
15:32:56 <Sgeo_> Was I pinged earlier?
15:33:12 <glguy> Sgeo_: You were mentioned in a lambdabot quote
15:33:37 <aplainzetakind> Also I'm not entirely happy with the "teaching manners" attitude, I must say.
15:34:25 <Sgeo_> glguy, thank you
15:36:26 <glguy> I'd have guesed you were "entirely not happy"... (sorry, I had to)
15:36:34 <monochrom> haha
15:37:13 <glguy> Did the original question get answered?
15:41:13 <nshepperd1> aplainzetakind: anyway, it's theoretically possible for a loop (recursive function) operating on an immutable array to modify the array in place, if the compiler can prove the conditions where that would make sense (eg. nobody else has access to the array). But ghc doesn't implement anything like that
15:41:23 <nshepperd1> aplainzetakind: is that's what you were asking about
15:42:12 <glguy> Also it's safe to carry an immutable array around in a recursively defined function without being concerned that the array itself is being copied rather than being pass around by reference
15:42:53 <aplainzetakind> nshepperd1: Yes, and I suppose to know the conditions under which that happens is very involved, right?
15:44:51 <aplainzetakind> glguy: By "carry around" you mean unmodified, right?
15:45:21 <glguy> If it's an immutable array, then there's no modifying it
15:45:44 <glguy> If it's a mutable array then it's fine to mutate it and it will also be passed around by reference
15:46:09 <nshepperd1> aplainzetakind: It's pretty complicated, yes
15:46:15 <aplainzetakind> That's the only way it makes sense I suppose.
15:46:31 <aplainzetakind> Something like `f x arr = f (g x) arr` and not `f x arr = f x (g arr)`
15:47:27 <glguy> In the case of 'f x (g arr) ', g could very well return the array, or it could create a new one
15:47:32 <glguy> that just depends on g
15:48:56 <nshepperd1> aplainzetakind: there's also a simple optimisation you can do to eliminate intermediate lists/arrays: replace map f . map g with map (f.g). That sort of thing is called "list fusion" or "deforestation". There's some of that in haskell, for lists in the standard library and for arrays in the 'vector' package
15:52:34 <aplainzetakind> glguy, nshepperd1: Thanks.
15:53:35 <MarcelineVQ> and for streams in the streamly package :D
15:54:07 <MarcelineVQ> had this open recently, dunno if its of interest http://www.cse.unsw.edu.au/~arob423/papers/lippmeier2013flowfusion.pdf
16:20:34 * hackage extensible-effects-concurrent 0.17.0 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.17.0 (SvenHeyll)
16:55:09 <Arcaelyx> glguy: Oh hi. Didn't know you were on here as well.
16:56:34 <DigitalKiwi> glguy is everywhere
16:57:01 <Arcaelyx> Yeah, I've seen him around in the FP Discord server.
16:57:38 <MarcelineVQ> DigitalKiwi: upwards of 2 places, by induction he must be in all places
16:59:21 <DigitalKiwi> glguy: he's everywhere you want to be
17:00:47 <koz_> Think of him, and he will be there.
17:07:52 * ski . o O ( ".., Logic has its own Trinity, namely Semantics (the Father), Syntax (the Son or Verb) and Meta (the Holy Ghost). Many logical papers look like a religious service." )
17:13:23 <DigitalKiwi> the alonzo church puns certainly help
17:14:50 <geekosaur> ...can I call the Church-Turing thesis deux ex machina?
17:17:01 <Solonarv> o_O
17:20:39 <DigitalKiwi> you can call it whatever you want but you might get lectured
17:22:03 <geekosaur> *deus. way to ruin a bad joke .
17:23:27 <MarcelineVQ> I thought deux was the joke
17:23:57 <DigitalKiwi> I was willing to give geekosaur the benefit of the doubt as it being a joke I didn't get
17:24:28 <geekosaur> it occurred to me it could go either way, but I was thinking of the literal translation as opposed to modern usage
17:24:40 <geekosaur> ("the god out of the machine")
17:33:35 * hackage extensible-effects-concurrent 0.18.0 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.18.0 (SvenHeyll)
17:42:42 --- mode: glguy set +v charlietuna
17:43:09 <charlietuna> new here
17:43:27 <charlietuna> i'm in the ca bay area
17:49:41 <aplainzetakind> > array ((1, 1), (10, 10)) [ ((i, j), '?') | i <- [1..10], j <- [1, 10] ]
17:49:44 <lambdabot>  array ((1,1),(10,10)) [((1,1),'?'),((1,2),*Exception: (Array.!): undefined a...
17:51:49 <aplainzetakind> why?
17:53:07 <lyxia> what did you expect to happen
17:53:08 <Solonarv> j <- [1, 10] -- should be 1..10
17:53:29 <aplainzetakind> argh
17:53:52 <infinisil> I had no idea arrays could have tuple indices!
17:55:31 <geekosaur> anything you can define an Ix instance for
17:56:10 <geekosaur> whichbasically means if you can tell it how to map to / from your index type to a linear array, you can use it
17:56:17 <infinisil> Yeah, makes sense now that I look at Ix, have always just glanced over that class
17:58:37 <infinisil> Hmm, couldn't the vector package also use something like that?
17:58:52 <infinisil> Or is there a good reason vector and array should be separate?
18:02:43 <Solonarv> It turns out having to mess around with indexes is pretty annoying when you really just want a simple int-indexed array
18:03:42 <Solonarv> and there is a non-zero performance overhead associated with converting indices
18:04:07 <geekosaur> ^
18:24:45 --- mode: glguy set +v ACheesyName
18:25:35 * hackage codex 0.5.2.0 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.5.2.0 (parsonsmatt)
18:25:52 <ACheesyName> hello I'm trying to learn how to do I/O in haskell from http://learnyouahaskell.com/input-and-output . what does the $ symbol do in `putStrLn $ a ++ " " ++ b` ?
18:26:25 <Clint> @src ($)
18:26:25 <lambdabot> f $ x = f x
18:27:21 <ACheesyName> so it is used here just to avoid placing paranthesis around (a ++ " " ++ b) ? it's a precedence thing?
18:27:58 <Solonarv> Got it in one.
18:28:35 <ACheesyName> ok I thought it would be some complicated monad thing. thank heavens
18:30:19 <infinisil> Solonarv: If you just use the 'Ix Int' instance, there shouldn't be any performance degradation?
18:30:36 <infinisil> Oh, there's lower and upper bounds though
18:30:52 <glguy> If you use 10 ($) in your code, the 11th is free, so people like to add them in wherever they can
18:31:17 <glguy> Vector has the same problem
18:31:50 <glguy> It tracks an initial index that has to be included in indexing operations
18:32:23 <infinisil> Huh it does? It doesn't start with 0?
18:32:56 <Solonarv> infinisil: data Vector a = Vector !Int !Int !blah
18:33:23 <Solonarv> blah is the actual backing data structure (can't remember what it's called), the int's are offset + length
18:33:29 <glguy> Vector internally tracks an offset to avoid copying when you do an operation like take
18:33:33 <Solonarv> It's implemented that way to support efficient slicing
18:33:57 <infinisil> Hmm I see
18:34:34 <infinisil> Sooo, then having vector use Ix for indices shouldn't worsen performance, right?
18:35:30 <infinisil> Because I don't want to use array just because I need different indices
18:35:57 <Solonarv> It might make the API more awkward, but I don't think it would necessarily degrade performance
18:36:14 <Solonarv> (consider concatenation)
18:36:17 <glguy> Mixing Ix and vector means you have two offsets to worry about
18:36:27 <glguy> Using the array package is just fine
18:37:46 <infinisil> I often hear 'vector is a better array', but it's really 'vector is a better array if you only need 0-indexing with ints'
18:38:22 <geekosaur> vector is simpler and faster for many common use cases. array is more flexible]
18:38:27 <glguy> Or if you're building and consuming them in a way that benefits from it's fusion rewrites
18:38:54 <infinisil> Now I'm conflicted even more!
18:39:07 <infinisil> It feels like these should be a single package really
18:39:52 <geekosaur> possibly in some alternate reality where array wasn't essentially a part of ghc and vector designed much later around fancy fusion
18:41:17 <glguy> Neither one is more correct, they are just optimized for different situations. It's also ok that we have Map, too
18:41:40 <Solonarv> and IntMap, and Seq, and HashMap... :D
18:42:03 <infinisil> Haskell should be able to abstract the usecases and provide something that can accomodate both
18:42:13 <geekosaur> abstraction comes at a cost
18:42:37 <geekosaur> at one point someone introduced a set of containers with shared APIs. nobody used them because of the overhead
18:43:02 <glguy> The API s just aren't compatible
18:43:09 <infinisil> mono-traversable?
18:43:24 <Solonarv> I think there's a backpacky version of containers somewhere
18:43:27 <infinisil> I don't think mono-traversable should have a performance impact
18:43:37 <glguy> Or a benefit
18:43:48 <geekosaur> http://hackage.haskell.org/package/EdisonCore
18:44:10 <infinisil> glguy: You don't see a benefit to mono-traversable?
18:44:13 <geekosaur> actually it looks liek someone was at least semi-maintaining them in 2016
18:44:44 <glguy> infinisil: I don't really
18:44:50 <geekosaur> infinisil, very little, and the downside that if things do't go exactly right it degrades to a bunch of packs and unpacks
18:44:59 <geekosaur> and your performance tanks
18:46:45 <infinisil> glguy: https://github.com/mrkkrp/megaparsec/blob/master/Text/Megaparsec/Stream.hs#L190
18:47:44 <infinisil> I recently made a PR for using mono-traversable which would have gotten rid of those repetitions
18:48:01 <glguy> ok
18:48:04 <infinisil> It's perfect for libraries
18:48:29 <glguy> I'm not saying people can't or don't use it, I just don't think it's a generally useful abstraction
18:49:00 <glguy> I've got plenty of practice with more powerful versions of it via lens
18:49:01 <infinisil> Any specific reason?
18:49:14 <infinisil> Ah lens
18:49:22 --- mode: glguy set +v wroathe_
18:49:31 --- mode: glguy set -v wroathe_
18:49:41 <wroathe_> Is Yesod pretty much the standard for web frameworks in Haskell at the moment?
18:50:12 <glguy> wroathe_: I hear more people recommending some of the lighter-weight starting points like scotty
18:50:12 <Solonarv> It's definitely not *the* standard, there are quite a few options.
18:50:41 <wroathe_> Other than Yesod, which do you guys think I should take a look at?
18:51:13 <glguy> infinisil: It just enforces a pretty specific access pattern in an ad-hoc way. I find using various traversal functions to  be useful, I don't think we need the MonoTraversable class
18:51:47 <glguy> infinisil: I'm much more interested in things that are parameterized over an arbitrary traversal. classes that just exist to allow us to reuse the same name over and over aren't as interesting
18:52:36 <glguy> We already have the Each class in lens when we just want an adhoc traversal that does something reasonable
18:53:46 --- mode: glguy set +v f_en
18:54:52 <f_en> if two classes are linked by a common operation, does that mean there is a class which could be used in place of both of them?
18:55:36 <Solonarv> Sometimes, depends on the classes.
18:56:10 <Solonarv> Maybe it just means one should be a superclass of the other
18:56:42 <f_en> :t sequenceA
18:56:43 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
18:57:12 <f_en> so if one class was defined by a function of type; (Applicative f, Traversable t) => t (f a)
18:57:36 <f_en> and another was defined by a function of type; (Applicative f, Traversable t) => f (t a)
18:58:06 <f_en> then these types seem linked
18:58:07 <geekosaur> f_en, only if there's some benefit to doing so, i.e. the class adds something over just the existing ones
18:58:38 <f_en> geekosuar, well the hope would be that it could capture several possible class definitions as one
18:59:29 <f_en> e.g. there seems to be a generalisation of state using the traversable instance of (,)
19:00:31 <geekosaur> if all it does is capture some subset of values, and doesn't give you any additional expressiveness, all you're doing is making life harder for people trying to wade through the typelcass hierarchy
19:00:59 <f_en> so e.g. classes defined by 1. s -> (a,s) = s -> (a,Identity s) = s -> Identity (a,s), 2. s -> (a,Maybe s) 3. s -> Maybe (a,s), all have that form
19:02:02 <f_en> instead of writing state-like classes for each different applicative, and each way of sequencing the applicative through a traversable, one common class could be used, it would save a lot of code duplication in writing such similar classes
19:02:30 <f_en> well, the traversable is fixed to (,) in the case of State
19:04:33 <yyt16384> is there an infinite list structure which supports fast indexing? (by caching the initial elements in an array, for example)
19:05:22 <f_en> hmm, there might be some confusion of "linked by a common operation", its at type level, over the types of the class defining functions 
19:05:28 <Solonarv> 'memoize (myInfiniteList !!)', I guess?
19:06:25 <f_en> yyt16384: haskell does some sort of garbage collection so if the values had already been accessed, they should remain in memory 
19:06:28 <nshepperd> you're still going with this replacing Traversable thing?
19:06:57 <f_en> its just a question of trying to lower duplicated code
19:07:00 <nshepperd> a typeclass is really just a set of types
19:07:37 <nshepperd> code duplication in defining instances can be prevented by just using a helper function
19:07:57 <f_en> its not trying to generate new classes using type level functions on the types of the defining function
19:08:16 <f_en> just when thats possible, does that mean one class could be used to capture all such instances?
19:08:33 <f_en> maybe taking an additional parameter to do the rearrangement 
19:08:48 <Solonarv> Perhaps, yes.
19:08:54 <nshepperd> nobody needs to generate new classes
19:09:27 <nshepperd> if you've got lots of classes, you've got lots of problems
19:10:03 <f_en> if they are linked by an obvious systematic way to generate them, it seems like a lot of effort could be saved by writing a more abstract class that captured all the different cases
19:10:28 <f_en> as essentially, they form a "class" ... (!?)
19:10:35 * hackage stratosphere 0.29.0 - EDSL for AWS CloudFormation  http://hackage.haskell.org/package/stratosphere-0.29.0 (jdreaver)
19:10:51 <f_en> (class of classes, seems worrying)
19:11:15 <f_en> but it would be ok if that could be captured just with one class, and if thats a general paradigm, it would be good to know about it
19:11:26 <dmwit> yyt16384: I suppose one could do some sort of exponential backoff kind of thing.
19:11:29 <nshepperd> i dunno what you're talking about anymore
19:11:35 <dmwit> yyt16384: A list of perfectly balanced trees, e.g.
19:11:50 <f_en> the above explanation is quite clear
19:12:11 <nshepperd> how many classes do you have that you need to automate defining them?
19:12:21 <f_en> no
19:12:42 <f_en> if that could be done, does that mean it could just have one class instead
19:12:56 <yyt16384> Solonarv: it doesn't seem to work for me, accessing different indices still require linear time each time
19:13:18 <Solonarv> yyt16384: which 'memoize' function did you use?
19:14:01 <yyt16384> Solonarv: from the 'memoize' package, in Data.Function.Memoize
19:14:23 <Solonarv> Ah, try something from MemoTrie perhaps?
19:16:06 <dmwit> yyt16384: How did you test that accessing different indices required linear time?
19:16:53 <dmwit> Well, never mind. Any package you use will give linear time indexing the first time you ask for the value at an index.
19:16:57 <dmwit> Only later requests are sped up.
19:17:14 <dmwit> ...which is why I suggested starting from a data structure that isn't a plain list. =)
19:17:21 <f_en> nshepperd, the example above showed one for each different position of an applicative distributed over a traversable, so thats 2. and the case where the applicative is Identity is a third common case. basically there are 3 classes of that form, with Maybe and Identity as the applicative, which seem quite common
19:18:06 <dmwit> Of course, you'll still need to be able to "skip ahead" more than one element at a time when producing the values. But that seems somewhat plausible.
19:18:06 <yyt16384> dmwit: sum . map f $ [1..n] requires clearly quadratic time
19:18:26 <dmwit> yyt16384: Right. You're getting no benefit from memoization, because you never call `f` on the same input twice.
19:18:41 <dmwit> (And switching to another memoization package won't help with that.)
19:18:54 <Arahael> yyt16384: Why quadratic?
19:19:10 <lyxia> That looks pretty linear to me
19:19:12 <dmwit> Arahael: Because `f` is linear in `n`. =)
19:19:21 <lyxia> oh
19:19:26 <Arahael> dmwit: Yes, but that's only the one array.  It's still linear?
19:19:27 <lyxia> f is the function being memoized
19:19:39 <lyxia> or memoized function, whatever
19:19:46 <dmwit> Arahael: No. `[1..n]` is linear in `n`, and *each call to `f`* is linear in `n`.
19:19:47 <f_en> since they seem to be similar at value level, as the types from applying sequence, it identifies a pattern, and this is just one example - if every time such a situation occurs a similar approach could be used it would be a good idea. 
19:19:48 <Arahael> dmwit: If you increment n, you only increment it by the constant.
19:20:04 <dmwit> So you get a linear number of linear-time calls -- quadratic time.
19:20:42 <Arahael> dmwit: I can only see two loops there, effectively - the sum, and the map.
19:20:53 <Arahael> dmwit: And they are effectively processed sequentially.
19:20:56 <dmwit> Arahael: That is because you cannot see the implementation of `f`!
19:20:57 <yyt16384> dmwit: yeah, but basically what i have is a way to generate the first n elements in O(n) time but no quick way to generate an individual element
19:21:03 <dmwit> Arahael: The implementation of `f` has another loop.
19:21:39 <Arahael> dmwit: Ah... That would indeed be quadratic.
19:21:44 <dmwit> yyt16384: If you cannot skip ahead, then there is no hope, even with a different data structure.
19:22:06 <nshepperd> f_en: well, the vacuous answer is that either two classes are actually related in that they're special cases of a meaningful pattern, in which case you could replace them with one class and be better off, or they're not, in which case you shouldn't
19:22:27 <nshepperd> but that's not something you can determine just be making analogies between types
19:22:42 <f_en> how so?
19:22:49 <dmwit> yyt16384: Wait. I take that back.
19:23:03 <dmwit> yyt16384: If indexing is indeed the main cost, you can alleviate that in the way I suggested.
19:23:27 <nshepperd> because the methods of a typeclass have meanings...
19:23:31 <f_en> if its because the type function between the types is as yet unknown...
19:24:37 <f_en> but then it creates a situation where for every identified transformation, can there be a common class?
19:24:44 <yyt16384> dmwit: i'm thinking about generating more elements as needed (exponentially increasing the upper bound) and store them into an array
19:24:56 <yyt16384> dmwit: but i guess i need to implement it myself
19:25:27 <nshepperd> you really need to do the work to show that the instances are all defined in a way that actually doesn't care about whatever you intend to abstract over
19:27:14 <f_en> well the simple example is for list and nonempty, where its either (f a -> (a,Maybe (f a))), where the last value can be returned even if empty cant, or (f a -> Maybe (a,f a)) which would be unable to return a value if given the empty list
19:27:38 * hackage bson 0.3.2.7 - BSON documents are JSON-like objects with a standard binaryencoding.  http://hackage.haskell.org/package/bson-0.3.2.7 (VictorDenisov)
19:28:03 <f_en> and the common pattern is that those types are the commuting of the maybe through the traversable, like sequence over (,)
19:28:07 <nshepperd> "class TraverseMaybe t where { traverseMaybe :: (a -> Maybe b) -> t a -> Maybe (t b) }; class TraverseList t where { traverseList :: (a -> [b]) -> t a -> [t b] }"
19:28:37 <f_en> not that
19:28:48 <f_en> thats just traverse with the applicative fixed
19:28:49 <nshepperd> are TraverseMaybe and TraverseList redundant with traverse :: Applicative f => (a -> f b) -> t a -> f (t b)?
19:28:58 <f_en> oh right
19:29:15 <nshepperd> there's no way to know without looking at the actual *values* of the instances for both classes
19:29:18 <f_en> hmm, but there isnt a type level relation between the applicatives
19:29:31 <f_en> basically, that just describes where classes are normally used.
19:29:34 <nshepperd> and proving that they only use the Applicative operations
19:30:53 <f_en> obviously its better if the pattern isnt just type level const to replace one parameter
19:31:06 <f_en> thought maybe thats the pattern we are used to
19:33:01 <f_en> yeah, seems like it might need to take a type level function as an argument to the class then, if Const is just used normally for each parameter
19:33:54 <nshepperd> you're not even noticing what i'm saying
19:34:11 <monochrom> I agree. Why bother.
19:34:29 <monochrom> Plus now I have to update my /ignore list too.
19:35:40 <f_en> is that directed at me?
19:37:25 <f_en> nshepperd: your saying that it would depend on the class
19:37:57 <f_en> so what about when that is taken into account?
19:38:14 <f_en> for those cases where such a pattern *has* been identified
19:39:08 <f_en> monochrom: dont let these nihilists affect you
19:42:30 --- mode: glguy set -v f_en
19:50:30 <dmwit> oh dang
19:50:37 <dmwit> Just uploaded my proof of concept for yyt.
19:51:07 <dmwit> ?tell yyt16384 Proof of concept of my idea. Empirically it does indeed get sublinear indexing. https://gist.github.com/dmwit/85c8c1f5e9c1d8abf960904fe2433195
19:51:07 <lambdabot> Consider it noted.
19:52:42 <Solonarv> dmwit: you might want to rename the file in that gist to 'something.hs' so you get syntax highlighting
19:53:33 <dmwit> ooo, pretty pastels
19:55:04 * hackage extensible-effects-concurrent 0.18.1 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.18.1 (SvenHeyll)
19:55:49 <dmwit> I just had a horrible thought. There's no way GHC can be smart enough to turn `[indexS i vs | i <- [0..n]]` into `take n vs`, right?
19:56:16 <dmwit> There's no way.
19:57:11 <Solonarv> Theoretically possible, practically I'd be very surprised if it happened
19:57:32 <Solonarv> -ddump-simpl -dsuppress-all to the rescue!
19:57:58 <dmwit> Also I don't understand what the indentation settings do on gists. I selected "Tabs" and "4". But it's still indented to 8-space tabstops everywhere there's a tab.
19:58:01 <dmwit> So why did it ask me?
19:59:04 <Solonarv> I think that might just select how many spaces are inserted when you pick 'spaces'
20:02:12 <dmwit> https://gist.github.com/dmwit/8af20541a8b172984d5aa80057534124 appears to disprove that hypothesis. I selected "spaces" and "2", yet the tabs and 8-space tabstops remain.
20:02:18 <dmwit> IDK
20:02:46 <Solonarv> Ah, I was unclear: how many spaces are inserted when you press the Tab key
20:03:05 <dmwit> Why would I do that.
20:03:37 <Solonarv> Because you want to indent with spaces but prefer hitting a key once over hitting a key four times?
20:03:38 <dmwit> But okay. That does at least jive with what I see.
20:04:01 <dmwit> No, I mean: is there somebody that actually composes their gist in the gist.github.com editor??
20:04:43 <Solonarv> Sure, I do that sometimes.
20:06:37 <dmwit> -ddump-simpl confirms GHC is not divine.
20:06:51 <dmwit> yyt16384: Did you see my gist?
20:09:55 <safinaskar> do you want peace all over the world? with haskell it is possible!
20:10:05 <safinaskar> just type import Data.WorldPeace :)
20:10:13 <safinaskar> https://hackage.haskell.org/package/world-peace
20:12:25 <dmwit> hmmmmmm
20:22:12 --- mode: glguy set +v ACheesyName
20:39:04 <coldpress> why mute f_en tho?
20:52:22 --- mode: glguy set +v nybble41[m]
20:52:52 <nybble41[m]> No fancy data structures, just lists, but it does indexing in logarithmic time (on average).
20:56:04 <nybble41[m]> dmwit: Just in case that first message didn't get through: I ran into a similar problem recently, and this was my solution: https://gist.github.com/nybble41/d70dcb93620bfe3f9d2b6bcd0eab960f
21:02:07 <yyt16384> dmwit: i converted your implementation into an array-based one and it's working nice, thanks! (sorry i wasn't around before)
21:07:52 <dmwit> coldpress: You're welcome to inquire further in #haskell-ops.
21:10:06 <dmwit> nybble41[m]: Very clever!
21:11:43 <nybble41[m]> Thanks. It's basically just a recursive skiplist. A quick-and-dirty way to speed up an existing quadratic list-based solution.
21:12:01 --- mode: glguy set -v _rht
21:42:44 * hackage waargonaut 0.5.0.0 - JSON wrangling  http://hackage.haskell.org/package/waargonaut-0.5.0.0 (schalmers)
21:53:18 --- mode: glguy set +v _rht
21:53:36 --- mode: glguy set -v _rht
22:08:58 --- mode: glguy set +v donnut
22:12:22 <donnut> who's on..
22:27:57 <jle`> some of us :)
22:28:17 <glguy> we were busy doing AoC
22:48:09 <s__> oh yeah
22:48:54 <s__> someone's here ?
22:49:06 <notzmv> morning s__ 
22:52:06 <s__> notzmv: OK :) i'm just testing my new IRC app for android. My app's working now
23:02:35 * hackage unix-time 0.4.1 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.4.1 (KazuYamamoto)
23:24:34 <coldpress> s__: which app is that?
23:59:11 --- mode: glguy set +v BobUeland_
