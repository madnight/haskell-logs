00:00:44 <koz_> Oh, cool.
00:12:56 --- mode: glguy set +v ggrsa
00:15:00 <ggrsa>  who knows the user thra11 ?
00:18:49 <Ariakenom> is there documentation on whether a structure can be infinite? You can have an infinite [] but not Data.Map. I guess it would be on strictness in the spine?
00:20:19 <[exa]> Ariakenom: how would you check uniqueness of keys in an infinite Data.Map?
00:21:01 <Ariakenom> sorry, not what I meant to ask. I how would you express in the documentation that it can't be infinite.
00:21:44 <[exa]> oh so :]
00:21:53 <dminuoso> Data.Map cannot be infinite?
00:22:16 <[exa]> IIRC there's some kind of such statement in Data.Sequence
00:22:43 <geekosaur> its' also implied by Sequence being backed by a fingertree
00:22:55 <[exa]> dminuoso: /me raises eyebrow
00:24:28 <Ariakenom> yes sequence does say. It was sequence was even what made me think of it.
00:25:31 <Ariakenom> And it does give one example on other spine strictness stuff.
00:26:14 <Ariakenom>  (1 : undefined) !! 0 = 1
00:26:17 <Ariakenom>  (1 :<| undefined) `index` 0 = undefined
00:26:18 <jle`> dminuoso: Data.Map has a maximum limit actually, (maxBound :: Int)
00:26:42 <jle`> Ariakenom: but yeah, "strictness on spine" is probably the thing you'd look for if you're looking at a new data type
00:26:50 <Maxdamantus> jle`: even if it weren't for the maximum limit, there'd presumably be no way to construct an infinite map.
00:26:52 <Ariakenom> hm, what would the memory consumption of a 2**32 big Map be?
00:27:27 <jle`> i'm guessing, asymptotically, probably the same as a linked list or vector with that many items
00:27:53 <Maxdamantus> (just as there's no way to construct some sort of infinite Rational or infinite Integer; regardless of the underlying structure, there are no operations that allow you to do it)
00:29:00 <Ariakenom> but I suppose Int won't be (much?) smaller than size_t so it would be out of memory before out of Ints
00:29:13 <Maxdamantus> or, disregarding Haskell, it's not possibly to construct an infinite number (irrational) using *, / +, -.
00:29:28 <jle`> Ariakenom: "strictness on spine" essentially means that the structure of the thing must be fully evaluated in order to use it (the "holes" must be evaluated, but not the contents of the holes)
00:29:41 <jle`> so this precludes infinite data structures
00:29:51 <jle`> s/holes/boxes
00:30:53 <jle`> so strictness-on-spine is a sufficient condition. i'm not sure if it's necessary, or what a better 'necessary' condition might be
00:30:58 <Ariakenom> jle`: Indeed. I was pondering on if there were some precise formulations.
00:33:19 <Ariakenom> It came up when I was doing todays advent. I knew from having a vague idea about the implementation like geekosaur said. and apparently the docs say it which is great.
00:33:50 <Ariakenom> But then I wondered how you would express properties like that
01:21:16 <siers> jle`, I actually need conduits, otherwise I've to roll out my own incremental parsing logic.
01:23:19 <siers> What happens under the hood of those conduit aeson parsers? Does the parser know that the input still could/n't be valid if more bytes arrived? Or does it just feed the parser with bigger and bigger chunks, possibly hopelessly until end of time?
01:24:14 <merijn> siers: It feeds the parser chunks until it succeeds
01:24:26 <merijn> Well, or fails, obviously
01:24:29 <siers> merijn, so if I gave it garbage forever it would eat all ram?
01:24:41 <merijn> siers: Garbage presumably would fail to parse
01:25:02 <siers> wouldn't a half-arrived valid input fail to parse as well?
01:28:05 <siers> merijn, 
01:28:31 <merijn> siers: No, attoparsec supports incremental parsing
01:28:44 <merijn> siers: So partial input will return "needs more input"
01:29:02 <siers> ok, cool
01:29:17 <merijn> siers: So the conduit just keeps incrementally feeding input until 1) parse success (then yield) or 2) parse fail (depend on which conduit you use)
01:29:49 <merijn> siers: See https://hackage.haskell.org/package/attoparsec-0.13.2.2/docs/Data-Attoparsec-ByteString.html#t:IResult
01:30:02 <siers> oh cool!
01:34:56 <ghibe> Hello everyone, I accidentally installed https://www.haskell.org/downloads/osx when I found out it's really old I wanted to report it but there's a link to an archived repo where there was already a forgotten open issue about it. How do I contact the person currently responsible for the site ?
01:35:08 <ghibe> the old issue https://github.com/ghcformacosx/ghc-dot-app/issues/51
01:36:34 <merijn> ghibe: There's a github link for issues at the bottom: https://github.com/haskell-infra/hl
01:36:38 <merijn> So that seems the right place
01:37:20 <merijn> ghibe: Anyway, on macOS (and really every *nix OS) I tend to just manually install the ghc bindist and cabal-install
01:43:16 <ghibe> merijn: thanks! I didn't realize there are 2 links to github. When you say bindist you mean https://www.haskell.org/ghc/download_ghc_8_6_3.html#macosx_x86_64 ?
01:43:59 <merijn> ghibe: Yeah, that's the one. It's literally just "./configure --prefix=$HOME/path/to/install" followed by "make install" to install everything
01:46:09 <ghibe> merijn: ok thanks!
01:46:33 <dminuoso> So great. I *think* getaddrinfo is not thread safe under macOS high sierra.
01:47:04 <dminuoso> All my testing has revealed that it's the getaddrinfo `network` calls into that spuriously errs out with "nodename nor servname provided, or not known"
01:48:28 <merijn> dminuoso: My manpage reports:
01:48:36 <merijn> "The getaddrinfo() implementations on all versions of OS X and iOS are now, and always have been, thread-safe. Previous versions of this man page incorrectly reported that getaddrinfo() was not thread-safe."
01:49:24 <dminuoso> merijn: And my test resolving the same host name 20-30 per second across multiple threads suggests differently.
01:49:45 <merijn> dminuoso: Have you considered that network itself may be responsible for those bugs? :)
01:50:37 <dminuoso> merijn: The error code in question directly calls into getaddrinfo() and it errors.
01:50:52 <merijn> ghibe: I think there's also a bindist for cabal-install, but personally I tend to just build it from source after cloning the cabal repo (there's a nice bootstrap.sh script which takes cares of building and installing all dependencies, so it's just a single command plus like 5-10 minutes of waiting
01:50:55 <dminuoso> I have instrumented network with enough code to be sure that it's not `network` where the error happens
01:51:24 <merijn> dminuoso: Could be, can you reproduce the same problem from a small C program?
01:51:32 <[exa]> dminuoso: truss the syscalls?
01:51:54 <merijn> [exa]: truss does not exist on macOS. You can try dtruss or DTrace
01:52:13 <[exa]> oh yes, dtruss
01:52:46 <dminuoso> [exa]: I couldn't get any results from running dtruss/DTrace through Haskell.
01:52:54 <dminuoso> It's as if there were no syscalls happening, was all rather weird.
01:53:15 <[exa]> dminuoso: it should have an option for following the forks, possibly -f
01:53:21 <merijn> ghibe: Bonus, if you install different GHC bindists into different paths you can switch implementations simply by adjusting which one is first in your $PATH :)
01:54:48 <dminuoso> [exa]: Ohh! THat's it.
01:55:16 <[exa]> it might even have -e filter for the syscalls
01:57:37 <dminuoso> [exa]: Any idea what syscall I should be tracing?
02:00:17 <dminuoso> I suspect it's going to be some mechanism using read()
02:00:33 <dminuoso> though I think merijn's approach might be more fruitful.
02:20:35 * hackage funcons-tools 0.2.0.7 - A modular interpreter for executing funcons  http://hackage.haskell.org/package/funcons-tools-0.2.0.7 (ltvanbinsbergen)
02:22:05 * hackage funcons-values 0.1.0.5 - Library providing values and operations on values in a fixed universe.  http://hackage.haskell.org/package/funcons-values-0.1.0.5 (ltvanbinsbergen)
02:28:05 * hackage funcons-simple 0.1.0.5 - A modular interpreter for executing SIMPLE funcons  http://hackage.haskell.org/package/funcons-simple-0.1.0.5 (ltvanbinsbergen)
02:43:44 <dminuoso> merijn: Hah it's a bug in the macOS responder indeed.
02:43:57 <dminuoso> A particular combination of hints *together* with multithreading triggers this.
02:43:59 <bahamas> I'm curious, what do people thing about freer-simple? I like the feeling of elegance it gives to the code
02:44:29 * bahamas says this after banging his head against it trying to understand it
02:46:27 <merijn> bahamas: Last time I tried to use Free and co (for some AST) I spent a week on it, just kept getting more and more boilerplate and then I was talking to edwardk about it and his solution was to just write it the "simple" way without Free, so I changed it to that and things got much simpler :p
02:47:53 <MarcelineVQ> The maverick :>
02:48:50 <bahamas> merijn: I see. I'm also using it for an AST (to generate PureScript programmatically). in my case, I just copied some examples from the library I'm using and modified some functions. I like the idea of just adding different effects and handling them
02:49:22 <bahamas> but I realize I've just scratched the surface and I don't know if I would be able to implement something with freer from 0 at this point
02:50:13 <bahamas> and I finally can pretty-print an AST, which is AWESOME
03:06:08 --- mode: glguy set +v shiona
03:07:06 <kuribas> Anyone who would like a haskell job in europe?
03:07:41 <shiona> I was trying to do todays AoC in somewhat the same way as https://www.reddit.com/r/adventofcode/comments/a61ojp/2018_day_14_solutions/ebr5c0q but instead of keeping a Seq internally and outputting items as a List, I tried to use a single datastructure for both (similar to the zip-fibonacci). However I wasn't able to come up with a datastructure that would have been both indexable quickly, lazy enough and 
03:07:46 <kuribas> backend development for a webapplication...
03:07:47 <shiona> understandable by me.
03:08:54 <shiona> Is there such a datastructure, if not is there a reason there isn't and if there is then what is it and does it have any benefits over the one by mstksg (in the reddit post)
03:09:50 <dminuoso> kuribas: Which country?
03:11:18 <kuribas> dminuoso: Belgium
03:12:51 <kuribas> dminuoso: I am good friends with one of the owners.  He asked me, but I am not looking currently.
03:13:12 <kuribas> dminuoso: they are rewriting a scala service into haskell
03:14:34 * hackage funcons-simple 0.1.0.7 - A modular interpreter for executing SIMPLE funcons  http://hackage.haskell.org/package/funcons-simple-0.1.0.7 (ltvanbinsbergen)
03:16:08 <kuribas> dminuoso: you'd make a fine candidate!
03:37:34 <__monty__> kuribas: Any experience requirements?
03:37:57 <kuribas> __monty__: some haskell experience is desired
03:38:32 <kuribas> __monty__: but no other specialised knowledge
03:39:07 <__monty__> I meant industry experience, I'm on the lookout for my first job.
03:39:19 <kuribas> __monty__: how much do you know haskell and linux?
03:40:59 <kuribas> __monty__: are you comfortable with monad transformers, lens, ...
03:59:32 <bollu> What's up with this error? https://gist.github.com/bollu/82f550ec168cb342c1c92597cf6482b6  
03:59:34 * hackage ngx-export-tools 0.4.1.0 - Extra tools for Nginx haskell module  http://hackage.haskell.org/package/ngx-export-tools-0.4.1.0 (lyokha)
04:00:02 <merijn> bollu: All cases of a function definition have to have the same number of arguments
04:00:08 <bollu> merijn but why?
04:00:15 <bollu> merijn the definition is clearly legal
04:00:29 <merijn> bollu: Is it clearly legal? I don't recall the definition in the report
04:00:43 <merijn> bollu: Is it sensible? Sure. I'm not convinced it's legal
04:01:09 <bollu> merijn ah yes, I meant "sensible" :) 
04:01:19 <bollu> merijn hm, is type-checking this hard?
04:01:25 <bollu> I'm trying to understand why this would not be legal
04:01:56 <merijn> bollu: It's about how to compile things, while *semantically* the number of arguments in your definition doesn't matter. In *reality* it does and GHC will optimise and compile things differently
04:03:26 <bollu> merijn in this case, you can always take it to be (a -> (b -> c)), and that should be OK? It's less optimal than directly pushing and jumping, but, I mean, it's more expressive?
04:04:27 <merijn> bollu: Anyway, fixing this is fairly trivial too, just add the extra argument in the first case
04:05:33 <bollu> merijn ofc
04:05:55 <bollu> merijn but the argument for why it's disallowed is unconvincing to me. Anyway, thanks :) 
04:06:46 <dminuoso> merijn: So funny story. Turns out that if under macOS you se AI_ADDRCONFIG with AF_UNSPEC and run getaddrinfo in multiple threads against a hostname for which no AAAA record exists, then sporadically you get failures.
04:06:49 <dminuoso> *set
04:07:19 <dminuoso> Best thing is, this even applies if you have no ipv6 link.
04:07:19 <merijn> dminuoso: That doesn't sound fun :p
04:08:30 <dminuoso> I was so bad at writing the C code.
04:08:46 <dminuoso> Kept forgetting semicolons, commented code out with --, forgot parens for functions..
04:08:47 <merijn> dminuoso: Should've used C++11 so you have std::thread ;)
04:10:34 <MarcelineVQ> dminuoso: write it from haskell weee
04:11:09 <merijn> MarcelineVQ: He was trying to reproduce a Haskell bug to see if the bug was in the Haskell or the libc code :p
04:21:35 * hackage regex 1.0.1.4 - Toolkit for regex-base  http://hackage.haskell.org/package/regex-1.0.1.4 (ChrisDornan)
04:22:35 * hackage regex-with-pcre 1.0.1.4 - Toolkit for regex-base  http://hackage.haskell.org/package/regex-with-pcre-1.0.1.4 (ChrisDornan)
04:27:16 <dminuoso> Is there someone here running Mojave to quickly run a testprogram for me?
04:29:21 <merijn> dminuoso: Me
04:29:37 <merijn> Well, depending on the requirements for said program :p
04:30:17 <dminuoso> merijn: https://gist.github.com/dminuoso/3daed17de9d4e7b17f8289643edd5e5f
04:30:23 <dminuoso> Just see if this emits any errors for you.
04:32:25 <MarcelineVQ> reverse (reverse xs) = xs is what, invariant? idempotent?
04:32:40 <merijn> MarcelineVQ: What are you trying to describe?
04:32:49 <merijn> Don't you just mean "equal" or "equivalent"?
04:32:52 <merijn> dminuoso: So far not yet
04:33:00 <hpc> it's a property of reverse
04:33:05 <MarcelineVQ> I'm wanting to say that reversing twice is identity
04:33:11 <MarcelineVQ> I think
04:33:14 <merijn> MarcelineVQ: You just did ;)
04:33:23 <Ariakenom> inverse is a relevant word
04:33:23 <merijn> dminuoso: Ah! It just failed
04:33:28 <MarcelineVQ> But is there a word with that meaning hehe
04:33:51 <merijn> "reverse is its own inverse"?
04:34:10 <Ferdirand> i think the technical term is "involutive"
04:34:24 <merijn> dminuoso: It's been running about 1 minute, maybe 2. So far I have one failure
04:34:26 <Ariakenom> not true for infinite xs though
04:34:27 <dminuoso> merijn: That took quite a bit, but who knows what influences the race condition. Here it gives me 2-4 errors per second. 
04:34:51 <dminuoso> merijn: Thanks, what exact macOS version are you running?
04:34:53 <merijn> dminuoso: Latency to DNS, maybe?
04:35:11 <merijn> dminuoso: Mojave: 10.14.2 (18C54)
04:35:16 <MarcelineVQ> Ferdirand: that sounds familiar, I'll have a search thank you Ariakenom: why not?
04:35:26 <merijn> dminuoso: Ah, 3 failures now
04:35:34 <hpc> dminuoso: try running it with wireshark maybe
04:35:36 <Ariakenom> > reverse (reverse [0..])
04:35:42 <lambdabot>  mueval-core: Time limit exceeded
04:35:48 <Ariakenom> MarcelineVQ ^
04:35:52 <merijn> dminuoso: But like I said, I'm hooked in right into the backbone so I have pretty impeccable latency to DNS and everything, so that might be relevant :)
04:35:58 <MarcelineVQ> Oh, well if you compute it sure :>
04:36:09 <Ariakenom> > head $ reverse (reverse [0..])
04:36:16 <lambdabot>  mueval-core: Time limit exceeded
04:36:16 <lambdabot>  mueval: ExitFailure 1
04:36:18 <Ariakenom> > head $ [0..]
04:36:21 <lambdabot>  0
04:37:21 <dminuoso> hpc: It's all cached by the macOS responder.
04:37:31 <hpc> ah
04:37:50 <merijn> hpc: ok, so I'm looking at...say 2 errors per minute
04:37:52 <merijn> eh
04:37:55 <hpc> does a bsd vm fail in the same way?
04:37:57 <merijn> s/hpc/dminuoso
04:38:07 <dminuoso> merijn: It shouldn't fail at all.
04:38:16 <dminuoso> merijn: can you bump up the threads?
04:38:22 <merijn> dminuoso: Sure, agreed :p
04:40:03 <trcc> It is revelation, almost an epiphany, when you finally understand the type system of haskell to the degree where hoogle becomes useful!
04:40:13 <merijn> dminuoso: Ok, with 20 threads it fails considerably more and faster
04:40:39 <merijn> trcc: The next improvement will be when you understand it well enough to understand free theorems :)
04:41:28 <hpc> or when you can look at a type and know what its function does without any code or identifier names
04:42:05 <merijn> hpc: I think those two are related :)
04:42:18 <Ariakenom> :t fmap fix pure
04:42:18 <hpc> yeah
04:42:19 <lambdabot> b -> b
04:42:48 <trcc> merijn:  let me dabble in my own success just for a minute! :D
04:43:09 <merijn> Does anyone know a good beginner intro to free theorems? I only know the Wadler paper
04:43:30 <merijn> trcc: The tragedy of success in learning is that you mostly learn about even more things to learn ;)
04:43:59 <trcc> yes, it is absolutely horrible
04:44:07 <trcc> you become addicted in some sense
04:44:51 <trcc> Anyways, my hobby haskell was timeboxed to 15 minutes ago, better start doing my real work
04:44:55 <hpc> /topic Welcome to #abstractions-anonymous
04:45:05 * hackage regex-examples 1.0.1.4 - Tutorial, tests and example programs for regex  http://hackage.haskell.org/package/regex-examples-1.0.1.4 (ChrisDornan)
04:46:05 <sm> oh nice. http://regex.uk/
04:51:16 <dminuoso> merijn: See I just wanted to learn Haskell on the side as a little fun project.
04:51:54 <dminuoso> Now I travel to conferenes and other events, run around with a Thompson-Wheeler logo printed on my hoodie and write less-shitty-than-before code all day long.
04:52:01 <dminuoso> And Im addicted to learning things. :(
04:52:07 <merijn> dminuoso: In less time too! ;)
05:23:48 <__monty__> Thompson-wheeler?
05:28:09 <amx> apparently that's the name of the haskell logo
05:51:39 <__monty__> So it is, googling thompson wheeler didn't point me in the right direction.
05:56:13 <merijn> I think that's just names of the people involved with creating it :)
05:56:48 <merijn> __monty__: From the wiki "The logo thought up by Darrin Thompson and produced by Jeff Wheeler is the winning logo of the 2009 logo competition."
05:57:15 <__monty__> Yes, I found the wiki page thanks to amx's comment.
05:59:36 <__monty__> Then I read part of the wiki entry on David Wheeler who was awarded the world's first Phd in CS, of Burrows-Wheeler fame before realizing this is a different Wheeler. Still, net gain, learning about an unrelated but accomplished computer scientist.
06:03:40 <merijn> ;)
06:20:22 <dminuoso> :t (_1 . _Just)
06:20:24 <lambdabot> (Applicative f, Field1 s t (Maybe a) (Maybe b)) => (a -> f b) -> s -> f t
06:20:39 <dminuoso> What kind of optic is this in `lens` terminology? If I consider profunctor optics this should be an AffineTraversal no?
06:22:28 <merijn> Isn't a a lens combined with a prism just another prism?
06:23:22 <nshepperd1> It's a traversal
06:24:00 <dminuoso> merijn: http://oleg.fi/gists/images/optics-hierarchy.svg
06:24:36 <dminuoso> nshepperd1: Ah I guess a Traversal is fine since it includes AffineTraversal right?
06:27:06 <dminuoso> > let f :: Traversal' (Maybe Char, Int) Char; f = (_1 . _Just) in ()
06:27:09 <lambdabot>  ()
06:27:11 <dminuoso> Well it type checks so thats fine. :)
06:27:39 <nshepperd1> Yeah
06:28:10 <nshepperd1> It would be AffineTraversal if the _Just prism was defined using Pointed
06:28:27 <nshepperd1> Our a profunctor optic
06:28:40 <nshepperd1> http://oleg.fi/gists/posts/2017-03-20-affine-traversal.html
06:29:16 <asheshambasta> Hi! I'm looking at Beam for MySQL and it seems like it encourages the use of UndecidableInstances (https://tathougies.github.io/beam/tutorials/tutorial3/) which, as per my understanding, should be avoided. 
06:29:33 <dminuoso> asheshambasta: UndecidableInstances is a perfectly fine extension that is safe.
06:30:35 <dminuoso> asheshambasta: The typechecker is overly conservative, UndecidableInstances just loosens it a bit to allow many more sensible instances. The worst case you could trigger is loop the type checker and cause it to fail compilation - but that's pretty much equivalent to a type checker error anyway.
06:31:21 <asheshambasta> dminuoso: I see 
06:31:38 <asheshambasta> So using it is fine, and the worst it could lead to is a failing compilation. 
06:31:55 <merijn> asheshambasta: UndecidableInstances is safe, in the sense that it won't ever compile "wrong" code. It just means things can break at compilation and/or overly long compile times
06:32:02 <strangeglyph> Hi! I see that fix f returns the least fixpoint of f. But there doesn't seem to be a method that gives a fixpoint given some initial value x?
06:32:28 <asheshambasta> merijn, dminuoso: got it, thanks
06:32:45 <lyxia> strangeglyph: how would you do it
06:33:58 <strangeglyph> lyxia: something like 'x if f x == x else fix' $ f x', probably
06:34:20 <dminuoso> asheshambasta: In your specific case there exists an: instance HasSqlValueSyntax be String => HasSqlValueSyntax be ShippingCarrier
06:35:09 <dminuoso> asheshambasta: Haskell has a conservative rule that says "The thing to the right must be smaller than on the right side", so that if reduces the thing it has to prove. That guarantees it will eventually terminate (because the head will shrink).
06:35:49 <dminuoso> asheshambasta: Imagine there also existed an instance HasSqlValueSyntax be ShippingCarrier => HasSqlValueSyntax be String
06:36:06 <lyxia> strangeglyph: it's quite rare that you need it and it's so inefficient
06:36:16 <dminuoso> It would end up in a loop to prove that the instance exist.
06:37:29 <asheshambasta> dminuoso: yeah, that is what I've been reading online, and its a little hard for me grasp 
06:38:02 <asheshambasta> but your explanation helps
06:39:26 <dminuoso> merijn: Are there any subtle issues that can arise with UndecideableInstances?
06:39:33 <fendor> when executing a stack script in nix mode, it seems like the path is set by stack. Because of that, a lot of commands are not in the path of the script and I cannot call them. For example, stack itself is not in the PATH. How can I add such programs to the PATH'?
06:41:24 <merijn> Not that I'm aware off
06:44:24 <dmwit> "overly long compile times" is being a bit coy, don't you think?
06:45:07 <dmwit> To be as clear as possible: using UndecidableInstances introduces exactly one new failure mode, which is that the compiler may *never* finish.
06:45:26 <dminuoso> dmwit: But GHC *will* finish by virtue of timing out in the typechecker, no?
06:45:29 <merijn> dmwit: Not true
06:45:38 <merijn> dmwit: GHC will bail out after a finite time
06:45:53 <dmwit> whaaaat
06:46:22 <merijn> dmwit: It will only attempt finite number of recursion steps before giving up, rather than infinite loop
06:46:30 <merijn> You can tweak the exact number via flags
06:48:51 <byorgey> Does it still do the recursion check without UndecidableInstances turned on?
06:48:53 <dmwit> Well how about that.
06:49:48 <dmwit> I guess -freduction-depth is a totally sensible flag to have, but in my mental model it always behaved as if -freduction-depth=0 (which actually means -freduction-depth=infinity lol).
06:50:06 <byorgey> challenge: write a valid Haskell program for which instance selection is provably (to GHC) terminating, but which has to recurse to a depth > 200 (or whatever the default reduction depth is)
06:50:28 <dmwit> byorgey: I have a wonderful 201 line example, composed with editor macros. ;-)
06:50:35 <byorgey> ...which has << 200 classes =)
06:51:05 <byorgey> dmwit: I knew someone was going to suggest that =)
06:51:07 * ski . o O ( `-freduction-codepth=n' <=> `-freduction-depth=inf-n' )
06:52:59 <Solonarv_> byorgey: that's very easy, just have an instance like Foo xs => Foo (x ': xs)
06:53:13 <Solonarv_> and use it at a >200-element type-level list
06:56:33 <dmwit> https://gist.github.com/dmwit/d9ddce9f90f67e86bba6a8d028789c7e
06:56:53 <dmwit> Requires only LiberalTypeSynonyms, and even then only requires it so I didn't have to do an editor macro. ;-)
06:57:03 <dmwit> Can be made 100% Haskell 98 with little thinking.
06:58:25 <asthasr> Has there been any work done in terms of treating Authorization as a monad?
07:00:03 <dminuoso> asthasr: What is Authorization?
07:00:29 <asthasr> authorization in the sense of applications and users. e.g. "this user needs this permission"
07:00:49 <asthasr> in essence I'm thinking of how you could "bubble up" permission requirements to the top level of an app and then only check the ones that you know you need...
07:05:31 <dmwit> asthasr: Yes, but the implementations I know of require a dependent type system.
07:06:15 <dmwit> asthasr: http://www.cis.upenn.edu/~stevez/sol/
07:06:32 <Solonarv_> eh, you could probably do it with RebindableSyntax and/or an mtl-like effect system
07:06:47 <merijn> Couldn't you make it work with an indexed monad?
07:07:00 <merijn> I don't think any of this requires dependent types
07:07:16 <Solonarv_> yeah that's what I was thinking of wrt RebindableSyntax
07:07:48 <dmwit> "Is it doable?" Maybe, I don't know? "Has somebody done it?" The existing things I know of require dependent types.
07:12:32 <MarcelineVQ> relatedly, haskell has session types. indexed monads can help but cale told me they're not as useful without DT
07:14:19 --- mode: glguy set +v salljm
07:19:33 --- mode: glguy set +v hello987
07:39:57 <v0d1ch> are there any alternatives for esqueleto, I need lib that supports joins and is present on recent stackage lts
07:40:55 <merijn> v0d1ch: I found esqueleto needlessly complex and confusing, so my own "solution" was to just handwrite SQL, tbh
07:41:34 <v0d1ch> oh that sounds like a pain to me :(
07:42:07 <merijn> How so?
07:42:20 --- mode: glguy set +v Bob___
07:42:45 * ski looks at Bob___
07:42:47 <amx> why doesn't esqueleto work for you? (I am not using it btw)
07:43:18 <v0d1ch> merijn:  you loose type safety for one
07:43:43 <v0d1ch> for two I don't know, isn't that enough for you :) 
07:43:53 <merijn> v0d1ch: esqueleto also has a bunch of holes that aren't type-safe
07:44:01 <merijn> v0d1ch: Which is why I decided it wasn't worth the effort
07:44:31 <amx> v0d1ch: there is opaleye for postgresql
07:45:22 <v0d1ch> amx: yeah I saw that but it is not on lts-12.22
07:45:35 <v0d1ch> maybe I need to learn how to use just cabal :)
07:46:22 <v0d1ch> merijn: do you have some example of (non) typed holes in esqueleto ? I guess I really got used to it but want to explore alternatives
07:47:02 <merijn> opaleye seems promising, but only supports postgres so that was out for me
07:47:07 <merijn> There's Selda too
07:47:29 <merijn> But since opaleye builds on top of Persistent that'd involve migrating off of persistent
07:47:31 <merijn> eh
07:47:37 <merijn> s/opaleye/esqueleto
08:00:10 <asheshambasta> merijn: I'm also facing that question, I'm writing a large service in Haskell (from Scala) and Beam seems nice 
08:00:30 <asheshambasta> but as I can see, Beam is quite boilerplatey
08:00:50 <merijn> Yeah, beam seems...needlessly complex
08:01:03 <merijn> Honestly, next time I think I'll just use sqlite-simple >.>
08:01:04 <asheshambasta> I'm also not sure if I want the DB library's types with my datatypes 
08:01:11 <merijn> and/or postgres-simple
08:01:36 <asheshambasta> merijn: whats the recommended database library of choice in the community considering MySQL where you need to do a lot of joins? 
08:02:04 <merijn> Personally I always stay far away from MySQL, so no clue :p
08:02:06 <asheshambasta> I'd like to stay away from TH and yet have less boilerplate than Beam 
08:02:31 <asheshambasta> Squeal seems nice too 
08:02:42 <asheshambasta> (but its only postgres)
08:03:28 <asheshambasta> but to my eyes as still a new Haskeller, all that type level magic Squeal seems to be resorting too hurts my eyes 
08:03:34 <asheshambasta> to* 
08:04:27 <asheshambasta> I've had a good experience with Selda, its simple and it gets the job done. 
08:06:53 <merijn> On a completely unrelated note: Anyone know of a good way to bucket floating point values within a fixed range? (Fixed as in, known before bucketing, but not across multiple runs)
08:08:04 * hackage exact-pi 0.5.0.1 - Exact rational multiples of pi (and integer powers of pi)  http://hackage.haskell.org/package/exact-pi-0.5.0.1 (dmcclean)
08:08:40 <sshine> asheshambasta, yes, Squeal seams nice.
08:08:46 <sshine> er, seems. :)
08:09:20 <asheshambasta> sshine: yeah, and its making me seriously consider using Postgres for this project insted. 
08:09:38 <asheshambasta> instead*, but all of our infrastructure is currently built on top of MySQ: 
08:09:43 <asheshambasta> MySQL*. 
08:09:55 <sshine> asheshambasta, what project is that?
08:10:24 <DigitalKiwi> asheshambasta: it's always good to seriously consider using postgresql
08:10:52 <asheshambasta> sshine: centralapp.com, some requirements have changed significantly and we're in the process of starting to rewrite an aging 5 year old Scala service in Haskell 
08:11:19 <berndl> asheshambasta: that's awesome
08:11:48 <asheshambasta> DigitalKiwi: Yeah, I'm not even sure why I chose MySQL back then. But we had no money and we wanted to go live fast, so I guess that was the reason. 
08:12:04 <DigitalKiwi> https://bitbucket.org/pvo/vmm/issues/3/add-support-for-mysql-mariadb
08:13:18 <asheshambasta> who's Anonymous :-) 
08:13:45 <DigitalKiwi> dunno
08:14:24 <DigitalKiwi> I've used vmm so that's how I found that and it's my favorite and most succint argument for not using mysql ;P
08:15:21 <asheshambasta> DigitalKiwi: I see that there's usually first support for Postgresql and then for MySQL
08:15:32 <asheshambasta> however, I have no data to back that, its just an observation. 
08:16:41 <DigitalKiwi> #postgresql would be glad to talk to you about it, there are many reasons to not use mysql, and they know them better than I, and this is #haskell >.>
08:18:03 <DigitalKiwi> tho there was a thing tha twent around a while ago and it was someone did some stuff in haskell and there was a comment about how haskell users seemed to hate mysql because the library support isn't as good and I'm like...well, yeah, of course haskell users wouldn't like broken databases :P
08:19:21 <DigitalKiwi> also that issue was from 2013 and afaik postgresql is actually more popular than mysql these days and a lot of the reasons that you would have gone with mysql 5 years ago have improved in postgresql
08:20:21 <amx> asheshambasta: i assume you already tried mysql-simple and decided you want something more high-level?
08:23:14 <asheshambasta> amx: Yes, definitely something higher level than that 
08:23:46 <asheshambasta> amx: We're built on top of MySQL at this time, so migrating services is going to be a pain but I'm willing to strongly consider Postgresql if the advantages are palpable.
08:26:12 <asheshambasta> amx: and honestly, the boilerplate in Beam is off-putting. 
08:26:13 --- mode: glguy set +v ggrsa
08:27:55 <amx> asheshambasta: FWIW, I spent a couple of days trying to port an application over to opaleye and threw in the towel. I'm back to writing SQL by hand with type errors and all.
08:29:15 <asheshambasta> amx: I was wonderfully surprised by Selda though, I used it for a pet-project and really liked its simplicity. It hit the sweet spot for me, if you ask me.
08:31:07 <amx> Thanks, I'll take a look
08:32:27 <asheshambasta> amx: what I also dislike with Beam is that it requires that it infect your datatypes (Columnar fields, for example), which feels weird 
08:35:24 <berndl> It's 2018 and we still haven't solve the impedance mismatch when interfacing with RDBMs.
08:37:27 <aiowej> Hi all! I'm writing interpreters in Haskell, and want to gradutate to code generation. I'm looking to learn how to compile a simple lambda calculus to C++. Writing here to ask for any tips on reading material, and especially if anyone can recommend "COMPILING LAMBDA CALCULUS" (https://t3x.org/clc/index.html), if it's worth its $35 price. Thanks for reading my humble question, and have a great hacking weekend :)
08:38:41 * ski . o O ( "Facts and Fallacies about First Normal Form" <https://www.red-gate.com/simple-talk/sql/learn-sql-server/facts-and-fallacies-about-first-normal-form/> )
08:44:35 <cocreature> aiowej: it might be helpful to take a look at something like a CEK machine to get an idea for how you can execute a lambda calculus
08:47:06 <cocreature> aiowej: there are also various talks on how to compile functional languages to LLVM, e.g., https://www.youtube.com/watch?v=Re3XgFfflzg&feature=youtu.be. there’s also a similar talk by stephen diehl
08:52:04 <sshine> aiowej, Simon Peyton-Jones'es book?
08:52:41 <sshine> aiowej, https://www.microsoft.com/en-us/research/uploads/prod/1987/01/slpj-book-1987-r90.pdf
08:53:05 <LysergicDreams> I'm writing a library that verifies wordpress cookies & nonces. I want to use it with Wai Requests, but should I write it to support Network.Http Requests as well?
08:54:16 * hackage proteome 0.3.8.0 - neovim project manager  http://hackage.haskell.org/package/proteome-0.3.8.0 (tek)
08:55:02 <aiowej> cocreature: sshine: Thanks for your links! Will check these out 
08:59:13 <aiowej> sshine: Do you per chance know if the Simon Peyton Jones book covers generating native or C code? Reading the table of contents, it seems to generate code for the G-Machine vm. 
09:01:35 * hackage morphisms 0.1.0 - It's all about functions  http://hackage.haskell.org/package/morphisms-0.1.0 (iokasimovmt)
09:14:47 <boeingx> Hi! Anyone knows how (->) is defined in GHC? Since we can implement Functor (and Applicative, Monad) instances for it, it is defined as something like abstract data type?
09:15:05 * hackage recursion 2.2.0.0 - A recursion schemes library for GHC.  http://hackage.haskell.org/package/recursion-2.2.0.0 (vmchale)
09:16:03 <boeingx> It is very difficult to find information about (->) on Google, because it is somewhat a stopword :(
09:17:53 <Solonarv> boeingx: basically, yes - it´s like any other data type with a hidden constructor
09:18:44 <berndl> Solonarv: aren't function definitions the constructors of (->) ?
09:19:40 <Solonarv> No, just like [_, _, _, _] isn´t a constructor of lists
09:20:58 <berndl> Sure, but's because that implicitly uses [] and (:).
09:21:47 <boeingx> Solonarv: but in plain Haskell we cannot defined some datatype with *hidden* data constructor right? So this is a hack?
09:22:06 <Solonarv> You can simply not export the constructor
09:22:12 <adamCS> asheshambasta:  I'm new to DBs but I've been having a pretty easy time with Beam.  I can see what you're saying about the types but since the Columnar type family is defined so that "Columnar Identity a ~ a" I have found it pretty painless.  I added a DB to an existing app and I just moved all the type definitions to the beam part and added the "type MyTable = MyTableT Identity" and everything else basically just worked. 
09:22:26 <glguy> boeingx: You don't need access to the implementation of a data type in order to make instances for it
09:22:31 <Solonarv> Which is something plenty of libraries do
09:23:14 <Solonarv> example: Set (from the ´containers´ library)
09:24:48 <boeingx> glguy: yes, just curious about how (->) is actually defined
09:25:17 <Solonarv> the straightforward answer is: compiler magic
09:25:19 <glguy> boeingx: It's implementation is built into the runtime system and compiler. There's no single place to look at it
09:25:39 <Solonarv> just like, for example, Int# (the primitive int type)
09:26:18 <boeingx> glguy: I see... thanks
09:26:41 <boeingx> Solonarv: is this what we called GHC Core?
09:27:04 <Solonarv> No, GHC Core is an intermediate representation used by the compiler
09:28:19 <Solonarv> It´s basically a simpler Haskell, with no syntax sugar and more explicitness, which makes it easier to implement various code transformations
09:29:52 <ski> boeingx : it's not defined in the language, it's an abstract data type, just like `Int',`Integer',`Float',`Double',`Array',`IORef',`IO',`IOArray',&c. are
09:31:01 <Solonarv> (actually, most of those are bad examples: they *do* have a definition written in Haskell somewhere)
09:31:19 <Solonarv> (but that definition is just a simple wrapper around the corresponding primitive type)
09:31:52 <ski> well, not Haskell as in the standard
09:33:29 <Solonarv> Fair enough. I was talking about GHC (and GHC-based compilers) in particular, since that covers the vast majority of Haskell usage.
09:34:02 <Solonarv> also, by its nature a standard won´t answer questions like ¨what is the actual implementation of <X>¨
09:36:03 <ski> it's like "what is the actual definition of ⌜∈⌝ in ZF set theory ?"
09:36:25 <ski> it's an undefined term. not defined in the theory
09:39:01 <boeingx> ski: when you say "it's not definedin the language", you mean not in the Haskell report?
09:39:05 <monochrom> In fact the standard doesn't even tell you time and space complexity.
09:39:41 <glguy> or what time or space are!
09:40:07 <Solonarv> boeingx: yes
09:41:54 <boeingx> Solonarv: btw, is Haskell Report something "readable"? Or it is reserved for those who build compilers?
09:42:04 <monochrom> It is readable.
09:42:10 <Solonarv> It´s quite readable
09:42:13 <glguy> You should read it if you're writing Haskell
09:42:19 <monochrom> In fact so basic that after studying it you still can't build a compiler.
09:42:36 <Solonarv> heh
09:43:25 <boeingx> Cool. I'll have something to read during Christmas then :)
09:44:49 <asheshambasta> adamCS: yeah, that is nice, but just that having to go through that boilerplate is a bit of a pain. 
09:45:39 <asheshambasta> adamCS: but then again, I'm still considering and studying this, in the end, all I'd like is an ergonomic library that also doesn't result in some funky SQL. 
09:45:47 <asheshambasta> Squeal looks very nice 
09:46:56 <adamCS> asheshambasta:  I can see that.  And, looking at Selda, I can see how that requires less of that work.  And I'm not sure what the tradeoffs are.  I will say that as pleased as I am with Beam, the types can be sort of atrocious in that way that makes error messages horrible and any attempt to help along the type inference/debug by adding signatures sort of intimidating.
09:48:07 <asheshambasta> adamCS: agreed. And that is also one of my major issues with it. I've tried using beam for a hobby project earlier and then gave up. Selda provided much more of a no-nonsense interface/experience. 
09:49:33 <adamCS> Yeah.  I can see that.  My thing is small and getting beam to work was a learning experience for me.  And the errors were mostly my learning curve on how SQL/RDBMs work.  But I can see that a more no-nonsense approach, if it generated good SQL, would be good.
09:50:59 <asheshambasta> adamCS: I'd strongly suggest looking at Squeal too, I think its a much more 'isomorphic' approach to interfacing with SQL. 
09:51:11 <adamCS> will do!
09:51:40 <asheshambasta> + its vastly less boilerplate than Beam 
09:52:03 --- mode: glguy set +v chalo_
09:52:29 <chalo_> hi, someone could explain me how to use lambdabot? i mean, how should i send instructions to him.
09:52:59 <glguy> What do you want to do with lambdabot?
09:53:28 <chalo_> i could ask for types like :t map
09:53:34 <chalo_> but i could send a instruccion like
09:53:48 <chalo_> snd ("hi","bye")
09:53:54 <chalo_> couldnt*
09:54:09 <Solonarv> if you want to evaluate an expression:
09:54:10 <glguy> If you're just exploring Haskell you'll get the most out of running commands like that in your local GHCi
09:54:19 <Solonarv> > snd (¨hi¨, ¨bye¨)
09:54:21 <lambdabot>  <hint>:1:10: error: parse error on input ‘,’
09:54:45 <Solonarv> ...dangit hexchat
09:54:59 <chalo_> ahaha i forgive the space between > and snd
09:55:07 <chalo_> that works with that space, thks :)
09:55:43 <chalo_> im studying for an exam ahah
10:34:48 <bollu> does anyone know this operator: (a, [b]) -> [(a, b)] 
10:35:28 <Solonarv> :t uncurry (zip . repeat)
10:35:30 <lambdabot> (a, [b]) -> [(a, b)]
10:36:08 <Solonarv> :t uncurry (fmap . (,))
10:36:10 <lambdabot> Functor f => (a1, f a2) -> f (a1, a2)
10:36:10 <mniip> :t \(x, y) -> pure x <*> y
10:36:11 <lambdabot> Applicative f => (a -> b, f a) -> f b
10:36:15 <mniip> oops
10:36:23 <mniip> :t \(x, y) -> pure (,) <*> pure x <*> y
10:36:24 <lambdabot> Applicative f => (a1, f a2) -> f (a1, a2)
10:36:40 <bollu> mniip nice, but I think you need the zippy version of List to do what I want
10:36:47 <mniip> um
10:36:48 <bollu> I want to "push" the a into the bs
10:36:51 <mniip> there's not difference
10:36:51 <Solonarv> mniip: pure f <*> x === fmap f x
10:36:56 <mniip> no*
10:36:57 <bollu> mniip no?
10:37:08 <mniip> yeah, this is basically using the fmap of the functor
10:37:25 <mniip> and ZipList and [] have the same underlying functor
10:38:01 <bollu> I saw Applicative f => ... 
10:38:10 <bollu> let me try :D 
10:38:28 <Solonarv> bollu: as I pointed out, pure f <*> x === fmap f x
10:38:43 <bollu> Solonarv indeed, that helps :) 
10:39:16 <Solonarv> > let foo = uncurry (fmap . (,)) in foo (1, [2, 4, 6])
10:39:19 <lambdabot>  [(1,2),(1,4),(1,6)]
10:40:15 <fryguybob> > sequence (1, "abc")
10:40:17 <lambdabot>  [(1,'a'),(1,'b'),(1,'c')]
10:40:20 <lavalike> runSTUArray :: (forall s. ST s (STUArray s i e)) -> UArray i e  how does one, in principle compute both such an UArray and some extra data? This function constrains the return type
10:41:49 <bollu> :t sequence
10:41:51 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
10:42:12 * Solonarv flips table
10:42:13 <bollu> that is genius o_O 
10:42:24 <Solonarv> :t sequenceA
10:42:25 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
10:42:25 <bollu> yeah
10:42:32 <bollu> but fuck, that's an insane way to view it
10:42:33 <lavalike> @src sequence
10:42:33 <lambdabot> sequence []     = return []
10:42:33 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:42:33 <lambdabot> --OR
10:42:33 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:42:49 <fryguybob> I always just assume sequence does what I want...
10:43:44 <Solonarv> sequence does the same thing as sequenceA
10:44:06 <Solonarv> sequence is the old version from before the AMP
10:44:15 <lavalike> I am puzzled as to how returns, say, a pair of (STUArray s i e, Bool) from actions that make the first one up
10:45:42 <Solonarv> lavalike: I think there´s a variant with a type like: Traversable f => (forall s. ST s (f (STUArray s i e))) -> f (UArray i e)
10:46:02 <geekosaur> is't runSTUArray just a convenience wrapper for runST?
10:46:27 <Solonarv> geekosaur: you will notice that STUArray s /= UArray
10:46:58 <geekosaur> and? you are providing a fucntion that has an STUArray s to play wth, to generate a UArray
10:47:07 <lavalike> geekosaur: the docs say it's a wrapper around unsafeFreeze but I can't find that
10:47:07 <geekosaur> which you can do manually in runST
10:47:19 <geekosaur> ok,m so they optimize it a bit.
10:47:19 <lavalike> let's see
10:47:23 <fryguybob> geekosaur: It uses unsafeFreeze
10:47:49 <lavalike> you are right it's indeed  runSTUArray st = runST (st >>= unsafeFreezeSTUArray)
10:47:54 <geekosaur> never mind, my point is buried in so much irrelevance that it no longer matters
10:48:08 <geekosaur> clqearlu it so mafgical that ti's completely impossibel to replicate with any form of runST
10:48:18 <lavalike> geekosaur: so this is what I have to do, make an ST action that returns, say, a tuple, and runST it
10:48:50 <lavalike> I am curious as to how one accesses `unsafeFreeSTUArray`
10:49:34 <ski> @type let runSTArray' :: Ix i => (forall s. ST s (Data.Array.ST.STArray s i e,a)) -> (Array i e,a); runSTArray' act = runST (do (arr,a) <- act; arr <- Data.Array.Unsafe.unsafeFreeze arr; return (arr,a)) in runSTArray'
10:49:35 <lambdabot> Ix i => (forall s. ST s (GHC.Arr.STArray s i e, a)) -> (Array i e, a)
10:49:51 <lavalike> that's a lot of characters
10:50:04 <geekosaur> ...
10:50:21 <lavalike> OK: runST + that, perfect, thanks for the example (:
10:50:48 <lavalike> (This stuff is hard to parse don't "..." me!!)
10:50:50 * ski idly wonders why that required `Ix'
10:53:07 <amalloy> ski: because it's legal to create an STArray with a non-Ix parameter, but you can't do anything with it, right? and we specified i as a type parameter instead of as a value
10:54:27 <fryguybob> ski: There used to be a data type context on Array but it has been removed.
10:55:49 <cocreature> I still don’t understand the motivation behind the design of DataTypeContexts
10:58:21 <ski> @type Data.Array.Unsafe.unsafeFreeze
10:58:22 <lambdabot> (Data.Array.Base.IArray b e, Data.Array.Base.MArray a e m, Ix i) => a i e -> m (b i e)
10:58:25 <ski> @type Data.Vector.unsafeFreeze
10:58:26 <lambdabot> Control.Monad.Primitive.PrimMonad m => Data.Vector.Mutable.MVector (Control.Monad.Primitive.PrimState m) a -> m (Data.Vector.Vector a)
10:58:30 <ski> no `Ix' in the latter
10:58:55 <ski> hm, though i suppose that could be because there's no index type parameter at all :)
10:59:16 <cocreature> the index type is Int and Int is an instance of Ix
10:59:37 <ski> right
11:00:06 <cocreature> (but vector doesn’t use that instance because why should it)
11:00:54 <ski> @type Data.Array.ST.runSTArray
11:00:55 <lambdabot> (forall s. ST s (GHC.Arr.STArray s i e)) -> Array i e
11:00:56 <ski> @type Data.Array.ST.runSTUArray
11:00:57 <lambdabot> (forall s. ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
11:01:04 <ski> those still doesn't use `Ix'
11:11:19 <WilliamHamilton[> hi, how do I deal with the error `Unsupported extension: NoStarIsType` when compiling some libraries with ghc 862?
11:13:41 <cocreature> WilliamHamilton[: that sounds weird. are you sure you’re using 8.6.2? I would have expected that you get that error if you try to compile with ghc < 8.6
11:14:02 <cocreature> (and only then)
11:14:31 <Solonarv> the GHC user´s guide says: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-StarIsType
11:14:38 <Solonarv> ¨Since: 8.6.1¨
11:15:35 <Superhanz> so elemIndex 4 [1,2,3,4,5,6] would give me Just 3, the index position of the element I was searching for in the list
11:15:52 <Superhanz> what happens if instead of being numbers, I have a predicate function that I want to use
11:16:12 <Superhanz> i.e. isPred :: Card -> Bool
11:16:18 <Superhanz> and I have a list of cards
11:16:31 <Superhanz> what function should I be using?
11:17:46 <cocreature> Superhanz: findIndex
11:17:57 <Superhanz> brilliant
11:18:02 <Superhanz> that is exactly the right type for what I want
11:18:04 <Superhanz> cheers
11:18:10 <cocreature> it’s two steps below elemIndex so sometimes looking at the docs is helpful :)
11:27:18 <amalloy> Superhanz: you can also find that by searching for the type you wanted: (a -> Bool) -> [a] -> Maybe Int
11:27:59 <Superhanz> didn't think of that
11:28:02 <Superhanz> thanks
11:34:27 <GewJi> can I write a new programming language using haskell?
11:34:44 <c_wraith> it's a pretty common thing to do in Haskell.
11:34:47 <koz_> GewJi: Yeah. I'd even say Haskell is _good_ at that.
11:35:13 <GewJi> c_wraith could you write a highly-excellent one?  Very responsive?
11:35:24 <koz_> GewJi: What does that even _mean_?
11:35:24 <GewJi> 'optimized'?  downwards-compatible?
11:35:34 <monochrom> Yeay Haskell Platform 8.6.3 just when I need it.
11:35:49 <GewJi> 15pork
11:35:56 <c_wraith> all of those are just a matter of spending the time on it.
11:36:06 <koala_man> I don't know if Haskell would be a good thing to write a *runtime* in
11:36:07 <Solonarv> well, Haskell (or rather, its most popular compiler) is written in Haskell
11:36:15 <GewJi> Is haskell really that great?
11:36:16 <koala_man> but compiler, definitely
11:36:23 <koala_man> GewJi: #haskell says yes
11:36:31 <GewJi> koala_man what would you write the runtime in then?
11:36:54 <c_wraith> koala_man, lots of the ghc runtime is actually in Haskell. big chunks like the IO manager, at least. probably several more.
11:36:56 <monochrom> I think Haskell is great for writing code optimization.  Last time I did it was in C++ and, while STL helped, still tedious and choreful.
11:37:03 <GewJi> koala_man I'm kind of too shocked to believe a langauge like haskell can do all that
11:37:26 <c_wraith> GewJi, why? it's Turing complete. it can write files.
11:37:37 <monochrom> RTS may be better off in C or Rust. Or at least 90% of it.
11:37:46 <koala_man> I should have said "interpreter", not as in a compiled runtime
11:37:47 <GewJi> c_wraith Well, --
11:38:01 <c_wraith> GewJi, for a compiler, that's really all you need.
11:38:24 <GewJi> well... hmm... where to begin
11:38:29 <koala_man> I would like to see a performant GC written in Haskell
11:38:42 <monochrom> I hope you don't mind me asking why are you asking all these questions, what do you have in mind?
11:39:15 <GewJi> monochrom why should I mind, then?
11:40:01 <monochrom> I don't know. Statistically a lot of people are secretive.
11:40:14 <GewJi> monochrom come in, then.
11:40:48 <xacktm> I think he's saying you need to come *out* :P
11:41:17 <GewJi> sports =/= gay
11:42:07 <Solonarv> GewJi, so: why are you asking these questions? what do you have in mind?
11:46:25 <lavalike> monochrom: thank you very much for https://www.vex.net/~trebla/haskell/annote-STArray.xhtml
11:46:53 <monochrom> w00t thanks
11:47:54 <monochrom> Actually I wonder if NoMonomorphsimRestriction helps.
11:56:07 <monochrom> Ah it won't help.  The problem starts as a show.read problem.
11:58:03 <monochrom> It's an old article. Today we have ScopedTypeVariables and it offers another solution.
12:09:18 <trcc> Solonarv: it is some very weird questions..
12:21:31 <lavalike> monochrom: I'm interested!
12:29:35 * hackage proteome 0.3.9.0 - neovim project manager  http://hackage.haskell.org/package/proteome-0.3.9.0 (tek)
12:31:20 <trcc> I am currently going over a list executing f on every element. If f results in Nothing, then I return Nothing immediately and stop recursing. Is there a construct for this in Haskell? Seems quite general. Perhaps something like sequence $ foldr ...?
12:32:29 <amalloy> trcc: traverse f
12:32:54 <trcc> amalloy: will look it up
12:33:23 <amalloy> well, it sounded from the beginning of your question like you were mapping - if you're folding maybe you want foldM or something. traverse f xs = sequence $ map f xs
12:34:16 <trcc> I am not mapping, because I do not want to go through the entire list if an element fails. But you might be right!
12:34:35 <cocreature> trcc: what should be the result if nothing fails?
12:35:05 <trcc> Is any execution of f on an element results in Nothing, then the entire thing should be Nothing
12:35:14 <trcc> cocreature: 
12:35:17 <cocreature> right, I’m asking about the other case
12:35:20 <amalloy> trcc: start with the types. "executing f on every element" doesn't say much in a functional language. what matters is what you do with the results. do you have like, xs :: [a], f :: a -> Maybe b, and you want back Maybe [b]?
12:35:43 <cocreature> if f returns Just x (for some x) on all elements, what should be the final result?
12:35:46 <int-e> > sequence [Just 1, Just 2]
12:35:49 <lambdabot>  Just [1,2]
12:35:57 <int-e> > sequence [Just 1, Just 2, Nothing, Just 3]
12:36:00 <lambdabot>  Nothing
12:36:12 <trcc> https://gist.github.com/CThuleHansen/d5b98eb2eccc28b47c82daebf748d021
12:36:29 <cocreature> yeah that’s traverse
12:36:44 <cocreature> :t traverse :: (a -> Maybe b) -> [a] -> Maybe [b]
12:36:46 <lambdabot> (a -> Maybe b) -> [a] -> Maybe [b]
12:36:51 <koz_> Could someone give me a hint about what the extend function (from the Comonad class) does with NonEmpty?
12:36:53 <cocreature> it’s actually more generalt han that
12:36:56 <cocreature> :t traverse
12:36:57 <koz_> I'm looking at the source and it's not making any sense.
12:36:57 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:37:03 <int-e> :t mapM
12:37:04 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
12:37:13 <lavalike> I understand that it is not a given that using mutable, unboxed arrays should give me a performance boost; but it became hundreds of times slower than the immutable array version. I'm flabbergasted. Does anyone have tips about STUArrays?
12:37:36 <lyxia> koz_: pairs every element with the tail after it
12:37:47 <lyxia> oh wait no that's duplicate
12:38:13 <cocreature> lavalike: how are you measuring?
12:38:30 <cocreature> not sure there is much that can be said without you providing a bit more detail
12:38:41 <lyxia> koz_: extend applies a function to every element and its tail (given as a NonEmpty) and gives you the list of results.
12:38:45 <Solonarv> koz_: extend f [a, b, c] = [f [a, b, c], f [b, c], f [c]] -- excuse the abuse of notation
12:39:50 <Solonarv> (just pretend OverloadedLists is enabled)
12:41:51 <c_wraith> lavalike, unboxed arrays can be a performance pessimization, if your use case results in constantly boxing and unboxing.
12:42:33 <Solonarv> > extend f (a :| [b, c, d]) -- koz_
12:42:34 <lavalike> This is my code https://pastebin.com/raw/5TAMRT7Y
12:42:36 <lambdabot>  error:
12:42:36 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M364271246832...
12:42:36 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
12:42:47 <Solonarv> nyeeeh
12:43:18 <lavalike> c_wraith: that seems like an interesting idea, I was hoping ghc would remove the intermediate lists for the predicate function
12:43:29 <ski> > extend f (a :| [b, c, d])  :: NonEmpty Expr
12:43:31 <lambdabot>  f (a :| [b,c,d]) :| [f (b :| [c,d]),f (c :| [d]),f (d :| [])]
12:44:19 <trcc> ah beautiful!!
12:44:27 <Solonarv> a, thanks ski
12:44:27 <davean> lavalike: also, an unboxed array means all the computations has to be done, not just the used computation
12:44:34 <trcc> amalloy int-e cocreature thank you
12:44:42 <davean> lavalike: as such you'll sacrifice a lot of composability of algs
12:45:34 <lavalike> davean: I think I am fine with that, it's (in theory) a memset and then fiddling with one-two entries at a time, until the predicate returns True
12:45:53 <c_wraith> lavalike, but anything more than vague warnings will require code to comment on. :)
12:46:24 <lavalike> c_wraith: I posted it!
12:46:55 <lavalike> I should have highlighted you helpful souls, sorry, cocreature c_wraith https://pastebin.com/raw/5TAMRT7Y
12:47:02 <c_wraith> oh, sorry. I'm not the only one who missed it, though. :)
12:47:03 <int-e> lavalike: takeWhile (>=0) <$> M.getElems a  is reading all the array
12:47:14 <davean> lavalike: I think oyu want to be using vector.
12:47:46 <lavalike> int-e: oh! Hmmmm
12:48:15 <c_wraith> lavalike, int-e nailed the important bit, I think. but it's definitely also reboxing for that. :)
12:49:04 <lavalike> That also makes sense. I should write the predicate differently.
12:51:01 <haasn> I remember somebody, I think byorgey, wrote an article as an introduction to haskell that started with analogies between haskell and mathematics (function instantiation by variable replacement and solving equations). Does anybody know what I'm referring to?
12:51:10 * hackage proteome 0.3.10.0 - neovim project manager  http://hackage.haskell.org/package/proteome-0.3.10.0 (tek)
12:51:35 <monochrom> That would be my http://www.vex.net/~trebla/haskell/prerequisite.xhtml
12:51:41 <haasn> monochrom: thanks
12:51:52 <haasn> sorry I got you mixed up with byorgey!
12:53:37 <lavalike> int-e: I'm curious though, the predicate does not look at its second argument at all, is M.getElems reading all the array anyway?
12:54:00 <c_wraith> yes
12:54:04 <monochrom> I think it has to. For fear of changes to your array soon after.
12:54:20 <ab9rf> who is changing your array?
12:54:30 <monochrom> No one.
12:54:41 <c_wraith> this is a difference between mutable and immutable arrays. elems can be lazy in an immutable array
12:55:08 <lavalike> c_wraith: why?
12:55:45 <lavalike> That single change makes many universes of difference.
12:55:47 <davean> lavalike: because a mutable one can change
12:55:58 <monochrom> lavalike: Consider why there is a slow "freeze array" and there is a fast "unsafe freeze array".
12:56:26 <ab9rf> i absolutely hate dealing with this stuff
12:56:42 <ab9rf> it brings back nightmares of writing threaded C code back in the 90s
12:56:52 <davean> ab9rf: Man, I loved doing that!
12:57:04 <davean> I miss it.
12:57:14 <int-e> lavalike: getElems is something like  forM [0..arraysize] (readArray
12:57:20 <ab9rf> picking through code one line at a time trying to figure out exactly where your critical sections are, and making sure that all of your mutexes are arranged so as to avoid deadlock
12:57:36 <int-e> lavalike: getElems is something like  forM [0..arraysize] (readArray a) ... oops, bad return key!
12:57:59 <davean> ab9rf: Oh, I always just preplanned all that
12:58:05 <davean> ab9rf: thats design stuff.
12:58:10 <int-e> lavalike: and the ST monad is strict, so all these readArray calls are executed, and the list built, before the takeWhile even starts executing
12:58:15 <ab9rf> davean: i worked on implementing a threadable tile swapper in the gimp back in the late 90s, when pthread became available.
12:58:16 <lavalike> Oh the monad is strict!
12:58:28 <lavalike> I can get behind that.
12:58:34 <monochrom> davean: I agree too.  But if there are collaborators then you begin to distruct everyone >:)
12:58:38 <davean> lavalike: Doesn't matter. Make it lazy
12:58:41 <int-e> lavalike: and making it non-strict would be insane because it's effectful.
12:58:52 <davean> lavalike: you still have a problem
12:59:00 <int-e> (even if the effects are limited to locally allocated memory)
12:59:11 <lavalike> Clearly, it has to be, I'm fine with that.
12:59:31 <Solonarv> ...actually, there is Control.Monad.ST.Lazy
12:59:40 <ab9rf> hehe
12:59:42 <int-e> lavalike: so you'll need a getElemsWhile.
12:59:44 <lavalike> It also makes sense that I can't pass the elements to the predicate as a list without shuffling them into a list (doing a lot of work)
12:59:48 <ab9rf> optional laziness
13:00:03 <monochrom> Actually I suspect that ST.Lazy doesn't make this one lazy either.
13:00:19 <lavalike> int-e: yes, definitely
13:00:23 <int-e> Solonarv: ST.Lazy can "abort early" but not change the order or omit effects.
13:00:23 <ab9rf> does it actually require a list, or will accept any Traversable?
13:00:34 <davean> monochrom: collaborators better be good or they're a liability in threaded C code
13:00:39 <int-e> Solonarv: not without some unsafeInterleaveST stuff (does that exist?)
13:00:54 <monochrom> Yes
13:00:59 <c_wraith> I've never understood how lazy ST works. I get much more reliable results from unsafeInterleaveST. but it is very aptly named. don't use it, unless you know exactly why it won't break your stuff. :)
13:01:22 <davean> monochrom: there are only a handful of people I'll let work on threaded C code I interact with.
13:01:39 <monochrom> But unsafeInterleaveST (getElems a) is still going to be an all-or-nothing deal.
13:01:52 <lavalike> Which would be fine in this case I think.
13:02:09 <lavalike> Since the predicate never consumes it
13:02:32 <c_wraith> don't use it. it will break something in the future.
13:02:43 <int-e> monochrom: right, but you coul have a getLazyELems a, which would then be subject to terrible caveats (getLazyElems a may see later writes to a)
13:02:53 <lavalike> c_wraith: that's future lavalike's problem!
13:03:03 <ab9rf> it already has broken something, but the breakage just hasn't been evaluated yet
13:03:36 <monochrom> To a large extent my most accurate (and empirically supported) model of ST.Lazy is: a write doesn't happen until a relevant read happens.  But even then this is not an exact model, I have seen rare counterexamples.
13:03:52 <monochrom> But it is not going to be lazy on the reads.
13:04:58 <monochrom> So for example if you have an infinite loop that writes to the same v, and you go on to forget v and not read it anyway, you still terminate.
13:05:08 <monochrom> I think.
13:05:26 <monochrom> I had some experiment posted on lpaste but now it's RIP.
13:06:03 <monochrom> But I gave it the cute title "sprinkle sprinkle little trace, how I wonder when you are"
13:10:15 <int-e> monochrom: The key for ST.Lazy is that when the result of a basic ST operation (readint or writing arrays, etc.) is forced, all preceding basic ST operations will also happen, in their specified order... thanks to artificial data dependencies in the state token.
13:11:46 <int-e> (that is the picture without unsafeInterleaveST, which forks the state token and introduces actual non-determinism in the order of execution...)
13:17:56 <int-e> oops
13:17:57 <int-e> @where paste
13:17:57 <lambdabot> https://gist.github.com
13:18:38 <int-e> http://paste.debian.net/1055915/ -- fun with unsafeInterleaveST
13:29:06 <LysergicDreams> Is there a way to get stack to show haddock coverage when building projects with multiple packages? I can only get it to show up when I specify a single package to build.
13:31:24 <davean> LysergicDreams: no idea but cabal new-haddock all definately does show them all
13:43:03 <lyxia> I think there are logs somewhere in .stack-work
13:52:24 <koz_> Solonarv: Ah, so it makes basically a triangular matrix?
13:52:27 <koz_> (of sorts?)
13:56:09 <koz_> For the PVP, if I add exposed functions to a module, but don't change any existing ones, does this require a major version bump?
13:59:01 <monochrom> No. See https://pvp.haskell.org/ look for "Non-breaking change"
14:02:28 <_deepfire> I wish GHC printed more context for the errors of form "Couldn't match type A to B arising from a use of C"..
14:03:01 <_deepfire> whenever type families are involved in both A & B, the deductions necessary to understand what's going on are exploding in complexity..
14:03:24 <_deepfire> and even :kind! is not enough
14:04:18 <_deepfire> I would like to know, for instance, where A and B came from -- what was their form before the last TF reduction?
14:09:47 --- mode: glguy set +v Testing789
14:13:26 <Testing789> how to fix? https://repl.it/repls/ZealousEsteemedSites
14:14:18 <koz_> Testing789: Occurence has kind Type -> Type, but Show instances must have kind Type.
14:14:20 <monochrom> What's the problem specifically?
14:14:34 <koz_> What you _probably_ wanted was 'instance (Show a) => Show (Occurence a) where ...
14:14:36 <koz_> '
14:15:10 <geekosaur> you don't get to reduce the a away because you need to talk about it, in short
14:15:36 <koz_> That being said, for Show (Occurence a), I'd actually just let GHC derive it, unless you're doing this for pedagogical reasons.
14:16:53 <Testing789> well if I take it out I get No instance for (Show (Occurrence Char)) when I try to run my program
14:17:08 <Testing789> with your fix it works btw thanks
14:17:09 <Welkin> you need to add `deriving Show`
14:17:20 <koz_> What Welkin suggests is what you'd normally do, yes.
14:17:24 <koz_> (thanks Welkin!)
14:17:55 <Testing789> ah ok. good that I know both ways now
14:18:51 <koz_> Testing789: There's several typeclasses you can auto-derive instances for. Show is one of them (and honestly, unless you have very good reasons to, it's better to rely on that instead of rolling your own).
14:20:25 <koz_> [insert stock admonition that 'Show is not a pretty printer']
14:22:17 <Welkin> Show is best used for print debugging
14:31:07 <_deepfire> Welkin, and even there -- whenever your stuff under debug is complicated enough, tree-friendly Doc is more effective
14:32:41 <sm> pretty-show will pretty-print your stock Show instances, I really like it
14:33:04 <_deepfire> sm, point!
14:34:09 <sm> except for its naming. I use this constantly:  pp :: Show a => a -> IO ()\n pp = putStrLn . ppShow
14:40:53 * _deepfire finds some TF-debugging solace in -ddump-tc-trace
14:41:52 <sm> _deepfire: what are these things ?
14:47:31 <monochrom> TF = type family.  tc = type checker.
14:49:27 <_deepfire> yes, right, sorry for too much jargon..
14:53:44 --- mode: glguy set +v noipmusp
14:53:51 <noipmusp> Does Haskell have any absurd functor in form "data Absurd a = Absurd"?
14:54:06 <amalloy> noipmusp: that's Proxy
14:54:58 <noipmusp> Funny, I was always confused by Proxy. Thank you.
14:55:38 <monochrom> That is not the usual kind of absurd we have in mind.  That is more like unit () phatom-type-ized.
14:56:02 <monochrom> Absurd would be "data Absurd a" period.
14:56:53 <int-e> @let newtype Absurd = Absurd Absurd
14:56:54 <lambdabot>  Defined.
14:57:19 <noipmusp> Thank you for the explanation. I thought it's not the right term.
14:57:53 <Solonarv> int-e: that used to be the definition of Void
14:58:07 <Solonarv> (before it was possible to simply write ´data Void´)
14:58:10 <int-e> monochrom's version will allow writing absurd :: Absurd a -> b without 'undefined' though :)
14:58:31 <geekosaur> foolish functor? (…watch that have a meaning)
14:58:35 <ski> (ignoring bottoms, a value of type `()' could be thought of as containing zero bits of information. perhaps one could think of a value of type `Void' as containing negative infinity bits of information)
14:58:52 <ski> > logBase 2 1
14:58:54 <lambdabot>  0.0
14:58:55 <ski> > logBase 2 0
14:58:57 <lambdabot>  -Infinity
14:59:40 <ski> @type let void :: Void -> a; void v = case v of {} in void
14:59:41 <lambdabot> Void -> a
15:00:06 <ski> > let void :: Void -> a; void v = case v of {} in seq (void (error "foo !")) ()
15:00:08 <lambdabot>  *Exception: foo !
15:01:29 <monochrom> Revisionist fictional etymology: "void" came from "voila" and one day someone mispelled it as "voial" and then someone misread it by merging "al" into "d".
15:02:44 <monochrom> Note that "voila :: Voila -> a" makes perfect sense. >:)
15:05:22 <jle`> noipmusp: it's also `Const ()`
15:05:27 <c_wraith> what has the internet done to me? I thi k correct words are typos just because everyone typos them these days. I read that as "viola" until I reached the last sentence and then went "oh, it was spelled right"
15:05:49 <Solonarv> ¨Voila¨ is clearly ¨Voil a¨; ¨Voil¨ comes from the French ¨voile¨, which means veil. This function tears off the veil (¨Voil¨) from around the ¨a¨, revealing it. ¨voila¨ is a French exclamation spoken when somethin is revealed, so it is the obvious name for this function.
15:05:51 <haasn> int-e: so will yours; absurd :: Absurd a -> b; absurd (Absurd abs) = absurd abs
15:06:00 <Solonarv> (I read Unsong lately. Please send help.)
15:06:19 <haasn> unless you consider that "undefined"
15:06:57 <jle`> 🎿 Void is often thought of as containing "infinite" information, though, isn't it
15:07:06 <Solonarv> (argh, why does every freaking client insist on typing weird unicode single/double quotes)
15:07:46 <jle`> ah it's not an insistence, i have a plugin going on that converts emojies
15:07:50 <jle`> emojis?
15:08:11 <Solonarv> No, this is happening on my end when I type stuff
15:08:46 <haasn> jle`: emojira? :p
15:09:06 <monochrom> Solonarv: I'm using hexchat too but it doesn't convert my ' and "
15:09:25 <Solonarv> I was using hexchat earlier, now I´m using pidgin, and they both do it
15:10:18 <monochrom> But do check their "auto replace" lists.
15:10:46 <coldpress> Solonarv: use irssi or weechat?
15:12:05 <Solonarv> I´ll try them
15:12:39 <DigitalKiwi> glirc
15:28:09 <dmwit> > let void :: Void -> a; void v = case v of {} in seq void ()
15:28:12 <lambdabot>  ()
15:29:22 <noipmusp> Is it possible to define "foo a b c = Foo (f a) (g b) c" using point-free notation?
15:29:55 <dmwit> ?pl \a b c -> foo (f a) (g b) c
15:29:55 <lambdabot> (. g) . foo . f
15:30:18 <noipmusp> Oh, that's nasty.
15:30:37 <ab9rf> pointfree often is
15:30:48 <ab9rf> "well, isn't that clever?"
15:31:08 <jle`> yeah, in almost every situation, the point-free way of writing is messier than the pointful one
15:31:28 <jle`> it's only in some nice cases where point-free can help make things more concise...but that's the exception, not the norm
15:32:04 <rain1> @pl \x -> Foo (fst x) (fst y)
15:32:04 <lambdabot> flip Foo (fst y) . fst
15:32:16 <ab9rf> once in a rare while it'll reveal a parallelism or some other thing that allows one to generalize something 
15:32:37 <rain1> :t curry ((,) <$> fst <*> snd)
15:32:38 <lambdabot> a -> b -> (a, b)
15:33:14 <jle`> :t \f -> curry (f <$> fst <*> snd)
15:33:15 <lambdabot> (a -> b -> c) -> a -> b -> c
15:35:00 <dmwit> rain1: Did you mean `snd x` instead of `fst y`?
15:45:36 * hackage Plot-ho-matic 0.12.2.3 - Real-time line plotter for generic data  http://hackage.haskell.org/package/Plot-ho-matic-0.12.2.3 (GregHorn)
16:01:00 <f-a> Hello, I have a simple question on type-level literals http://paste.debian.net/1055948/
16:02:08 <hpc> "type" does type aliases
16:02:10 <glguy> f-a: Type synonyms don't create distinct types
16:02:15 <hpc> phantom types in type aliases vanish entirely
16:02:22 <glguy> so MyList 10 expands to: [Char]
16:02:48 <f-a> good to know, thanks
16:16:34 * hackage proteome 0.3.11.0 - neovim project manager  http://hackage.haskell.org/package/proteome-0.3.11.0 (tek)
16:22:08 <bsima> does anyone happen to know if there is a "best practices" for running a purescript app in front of a haskell app? Maybe some example codebase I could look at?
16:25:20 <hpc> snap has a purescript thingy iirc, don't know how good it is though
16:40:11 <aplainzetakind> I remember reading in Haskell from First Principles that Writer is to be avoided. Is that generally accepted?
16:40:48 <glguy> You should just understand how it can be misused and then not use it like that
16:40:49 <Solonarv_> It has issues in that it's too lazy, which leads to terrible performance
16:41:02 <glguy> It has benefits where it's very lazy which allows for some great uses
16:41:35 <aplainzetakind> How about Control.Monad.Writer.Strict then?
16:41:38 <glguy> The problem is that sometimes what people do is they look at mtl's classes and decide which one they should used based on the types of the methods provided by that class
16:41:54 <glguy> and they think "I want write only" and assumet what's what MonadWrite is about
16:42:03 <glguy> MonadWriter*
16:42:44 <dmwit> Man, I *just* wrote something on this. I didn't touch on the lazy vs. strict writer divide, but you might find it interesting anyway: https://stackoverflow.com/q/53785921/791604
16:43:48 <glguy> aplainzetakind: the .STrict has to do with the behavior of the >>= implementation, not if you're going to have to worry about laziness
16:44:07 <aplainzetakind> dmwit: checking it out, thanks.
16:44:10 <Solonarv_> random tangent: would 'class Functor f => Applicative f where aempty :: Monoid m => f m; (<<>>) :: Monoid m => f m -> f m -> f m' be equivalent to the usual definition?
16:44:34 <glguy> It would be a bit less powerful
16:45:33 <glguy> Solonarv_: How would you recover the (<*>) operation from that class?
16:45:36 <hpc> that looks more like Alternative
16:45:53 <Solonarv_> glguy: yeah, that's what I had trouble figuring out
16:46:42 <dmwit> Solonarv_: You might like the more well-known alternative (perhaps you already know it!) of `1 :: f (); (*) :: f a -> f b -> f (a,b)`.
16:47:02 <Solonarv_> yes, I've see that one
16:47:57 <aplainzetakind> glguy: I'm trying to insert things I parse into a Map, incrementing the counter of occurences in the values of the map. I attempted using ParsecT e State (Map Text Int) a, but my memory caved because the input is huge. geekosaur suggested I learn Conduit, but I'll give one last shot to trying to fix it by making the map insertion strict somehow, as this is my first real experience with using any 
16:48:03 <aplainzetakind> sort of transformer stack and I'm not eager to further complicate things.
16:48:30 <glguy> That sounds like a job for State
16:48:32 <dmwit> Yes, I wouldn't be surprised if laziness was the problem there.
16:48:42 <glguy> Writer is more suited to streaming applications
16:48:53 <dmwit> You might also like http://hackage.haskell.org/package/multiset
16:55:02 <aplainzetakind> dmwit: ^ that's obviously exactly what I need. thanks.
17:05:33 <GewJi> Anybody think I'm a bot now???
17:06:09 <Solonarv> No? people leave and re-join all the time
17:16:10 <zachk> personally, I think lambdabot, might actually be a bot. 
17:16:43 <buhman> no way
17:16:53 <buhman> lambdabot: are you a bot?
17:17:16 <buhman> see, a bot would have responded right away; obviously a regular afk human
17:22:38 <DigitalKiwi> buhman: maybe the bot is broken or someone made it ignore you
17:22:56 <DigitalKiwi> buhman: phrik for a long time which we know to be a bot wouldn't talk to me :(
17:23:42 <aplainzetakind> OK this is probably a stupid question. I import State qualified as St, then inside a `ParsecT ...` do block, I use St.lift. Using just lift is not in scope. `:i St.lift` tells me it's a typeclass function from MonadTrans, so why do I need to prefix the function? Would I need to use Ma.fmap on a Ma.Maybe value if I imported Maybe qualified?
17:23:45 <c_wraith> @botsnack
17:23:45 <lambdabot> :)
17:24:01 <DigitalKiwi> witchcraft!
17:24:41 <c_wraith> aplainzetakind, the answer depends on your other imports.
17:24:47 <geekosaur> ^
17:25:13 <geekosaur> Control.Monad.State re-exports Control.Monad.Trans. this makes its names looklike they came from whatever you imported ControlMonad.State as
17:25:58 <c_wraith> gah, re-exports. they can be convenient, but they can sure lead to weird situations
17:26:24 <aplainzetakind> ghci tells me St.lift comes from transformers, but I import Control.Monad.State from mtl, but that's routine I think.
17:26:45 <c_wraith> yeah, mtl re-exports the transformers types, too
17:26:53 <geekosaur> mtl is based on transformers and re-exports its classes
17:27:08 <geekosaur> guh. typig no so much, correcting taking tiio long
17:27:59 <aplainzetakind> I don't know what could interfere? Megaparsec?
17:28:21 <geekosaur> what do you think is "interfering"?
17:28:56 <geekosaur> you imported Control.Monad.State qualified, everything including its re-exports is therefore qualified
17:29:27 <aplainzetakind> Alright I understand now.
17:33:32 <aplainzetakind> Actually I don't.
17:34:09 <aplainzetakind> Lifting into ParsecT, I'd expect to use the MonadTrans instance of ParsecT, which exists.
17:34:53 <geekosaur> instances exist. typeclass methods are functions and are imported and exported as such
17:35:18 <geekosaur> if you import only an instance, it's lke importing a ty'pe without its data constructors
17:35:27 <aplainzetakind> I see.
17:35:32 <geekosaur> C.M.State exports the instance methods
17:35:51 <geekosaur> er, classmethods; you get the instance ones only by that instance being selected
17:36:27 <aplainzetakind> If I also import the transformers MonadTrans things unqualified, then I could use the name `lift` unqualified then?
17:36:44 <Solonarv> Yes.
17:36:55 <aplainzetakind> OK. Thanks.
17:47:22 <dmwit> aplainzetakind: What's more, you don't even need to import it from a different module if you don't want to.
17:47:38 <dmwit> import qualified Control.Monad.State as St; import Control.Monad.State (lift) -- works just fine
17:54:36 <aplainzetakind> dmwit: nice
18:01:19 <_deepfire> ahh, fclabels still doesn't have prisms..
18:02:45 <_deepfire> so much for lens-sop building on it..
18:07:33 * _deepfire wonders if one can cheat and use fclabel's Lens to express prisms
18:09:40 <Solonarv> You can't express prisms in terms of lenses if you want 'review'
18:22:40 <_deepfire> that's a good point, but in the interest of moving things forward, I must discover how far I can get with this compromise..
18:23:18 <Solonarv> (the result would be a traversal, IIRC - that's what microlens uses instead of prisms)
18:24:10 <_deepfire> I tried to use generic-lens in context of generics-sop, but I found it too hard to provide it the necessary type-level evidence to get it going
18:27:34 --- mode: glguy set +v cyjiao_
18:47:49 --- mode: glguy set +v LorenzoEvans
18:58:05 * hackage recursion-schemes 5.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-5.1 (gelisam)
19:07:57 <monochrom> Generalized "banana, lens, barbedwire" would be "fruit, refraction, security perimeter".
19:08:53 * monochrom tries to work out something that could be called "lion, witch, wardrobe"
19:11:03 <geekosaur> lions, tigers, bears?
19:11:11 <DigitalKiwi> oh my
19:11:53 <mniip> monochrom, generalized lens could be fourier
19:12:23 <Solonarv> to be fair, we already have generalized lenses - just not the *same* lenses :P
19:12:43 <geekosaur> or fresnel?
19:16:18 <monochrom> OK, fruit, spectral analysis, security perimeter.  OK?
19:16:44 <Arahael> fruitcase, nutcase, hospital. :)
19:17:24 <Arahael> Ah, ignore that, I mixed it up.
19:17:38 <monochrom> wait how does barbed wire generalize to hospital? Unless it's that kind of hospital for nutcases and so it needs a security perimeter and complete lockdown etc etc
19:19:13 <Arahael> monochrom: It is. ;)
19:19:19 <monochrom> "This hospital needs hardening."
19:19:25 <Arahael> monochrom: For fruitcases and nutcases. ;)
19:21:34 <monochrom> OMG https://github.com/haskell/ghcup
19:22:09 <dmwit> I really dislike the name "banana, lens, and barbed wire". It refers to nothing of semantic content; only to the syntax they chose in that paper.
19:22:39 <suzu> that paper is also hard to read
19:22:45 <Solonarv> dmwit++
19:22:47 <suzu> because of their damn bananas lenses and barbed wire
19:23:29 <Levy[m]> It's not general enough
19:23:30 <Levy[m]> that's why
19:23:37 <dmwit> I don't know. I'm innoculated to it by many years of reading other papers with the same glyphs. So I didn't find it hard -- or maybe I did, but in a way I was familiar with and so I neglected the cognitive cost.
19:24:09 <dmwit> But this is in fact part of my complaint. Those glyphs are used by many other papers to mean other things; and on the other side there are many other papers that are talking about the same content but using different glyphs.
19:32:06 <suzu> i feel like it just made the communication in the paper more difficult than it needed to be
19:32:40 <Levy[m]> It's the same for quite a few
19:33:12 <Levy[m]> gloss over it and come back when you have a gist of the section
19:33:42 <monochrom> Hrm I need to learn what "cabal new-install" exactly do, e.g., which registry does it register to.
19:34:36 <Solonarv> Hey, I know what it does! It complains that it doesn't know how to symlink things!
19:34:41 <Solonarv> (on windows, that is)
19:34:45 <monochrom> Heh.
19:35:09 <DigitalKiwi> windows was a mistake
19:35:13 <glguy> My understanding is that it only works for executables currently (but that support for meaningfully new-installing libraries is on its way)
19:35:19 <monochrom> It says it wants you to set a setting that tells it your favourite exe directory for symlinks.
19:35:35 <glguy> It installs things into your ~/.cabal/store and then symlnks the executables to the directory you've configured, usually ~/.cabal/bin
19:35:38 <monochrom> Yeah there is a --lib flag or will be.
19:35:47 <Solonarv> Yes, and when you set a directory it complains that it doesn't know how to symlink things (again, on windows)
19:36:05 * Solonarv grumble grumble not like windows has had symlinks for a while or anything...
19:36:06 <monochrom> Oh then that's too bad.
19:36:22 <geekosaur> well, general symlinks tht do't need admin are newish (win10)
19:36:48 <monochrom> Ha "sudo make me a symlink"
19:36:54 <geekosaur> win7+ had the abilityto abuse reparse points, but only an administrator can create those
19:37:55 <Solonarv> It'd be nice if there was a fallback which copies the binary instead of symlinking
19:38:10 <Solonarv> I think there's an issue about that on the cabal repo, actually
19:38:12 <geekosaur> tjen people whie about disk space
19:38:40 <cads> monochrom: that is a reasonable api
19:38:59 <Solonarv> monochrom: okay, you are a symlink now.
19:39:10 <monochrom> I would say "then there should be a setting in .cabal/config for people to choose between fail and fallback-to-copy" but now we're down the rabbit hole of an XYZ problem...
19:39:17 <cads> aaah, perverse instantiation
19:39:44 <sproingie> "make it an option" == "support two different code paths"
19:39:58 <geekosaur> you have to anyway, windows vs. unix
19:40:18 <geekosaur> and win10 vs. win7+ is a thing anyway, for a bunch of APIs
19:40:43 <Solonarv> yeah I don't think it's a good idea to drop support for win <10
19:41:06 <monochrom> This is a headache. This is a migraine.
19:41:08 <Solonarv> (I'm on <10, so of course I would say that)
19:41:27 <monochrom> Fortunately "cabal install" still exists (but it wants you to say "cabal v1-install" now).
19:41:46 <sproingie> more options still means more code paths.  still, i wouldn't mind it using hard links on platforms that support it
19:42:02 <monochrom> I know a lot of people who have to stay with Windows 7 so don't worry it will last for another decade.
19:42:27 <sproingie> dropping xp makes sense.  even cygwin did that.
19:42:39 <dmwit> monochrom: Have you seen https://github.com/hvr/cabal-env ?
19:42:48 <geekosaur> you still need a fallback path there too: bindir is on a different filesystem, filesystems with directory-based quotas (openafs/coda), etc.
19:43:47 <monochrom> If it survives two more decades then it can survive forever because by then we can assign a few AI robots to maintain Windows 7 and keep it security-patched, "no human is laboured in producing these security updates", right? right?
19:44:20 <monochrom> dmwit: No I haven't.
19:44:41 <glguy> I've been getting great mileage out of: cabal v2-repl --build-dep some-library
19:44:53 <monochrom> Corollary: If "cabal v1-install --global" can survive for two more decades then muwhahahaha...
19:44:56 <glguy> when I want a GHCi session with some library available for one-off stuff
19:45:05 <monochrom> Wait there is a v2 too?!
19:45:07 <sproingie> it's almost like filesystem operations could be abstracted into some reusable library ...
19:45:19 <glguy> monochrom: It occurred to someone that the new- prefix doesn't scale
19:45:31 <geekosaur> actually it's not quite that simple. win10 has a bunch of internal improvements that make it a lot easier to keep up to date and secure, iuncluding a lot of ancient APIs ripped out that were security holes begging to be exploited
19:45:39 <sclv> right. V2 is just the permanent “nee”
19:45:48 <sclv> “New”
19:45:54 <glguy> nee is the new new
19:46:00 <monochrom> Yeah true, just look at "HD", "UHD", "what will you call the next one, OMFGHD?"
19:46:00 <geekosaur> win7 improved a number fo them, win10 mostly finished the job
19:46:03 <dmwit> nee is the nee new
19:46:13 <sclv> New, nex, ney, nez
19:46:22 <dmwit> new is the oll nee
19:46:23 <sproingie> BFHD
19:46:29 <glguy> nez game+
19:46:35 <sclv> ne_MAXINT_
19:46:44 <geekosaur> pretty sure I've already seen some claimed XHD out there
19:47:05 <Solonarv> new, nex, ney, nez, oeuil, oreille, lèvre, ...
19:47:25 <geekosaur> *snrk*
19:47:42 <Solonarv> :D
19:47:51 <DigitalKiwi> didn't windows 7 stop getting updates or was it just me :|
19:47:56 <dmwit> For even more confusion, in English "nee" is actually a word, and it means "old" for names.
19:48:19 <geekosaur> DigitalKiwi, iirc large enough corps can still get them
19:48:30 <geekosaur> home isnallations have been desupported
19:48:52 <DigitalKiwi> oh well there's my problem
19:50:29 <monochrom> Wait, I thought only XP and Vista were stopped.
19:51:04 <monochrom> Oh well what do I know.
19:51:51 <monochrom> Hrm is GHC's -package-env just a synonym/rename of -package-db?
19:51:56 <geekosaur> they werre fully stopped. corporations stll have a lot of embedded win7 that can't be upgraded (e.g. in equipment)
19:52:32 <geekosaur> granting that some of tat can't even be security patched, but some of it can
19:53:42 <DigitalKiwi> there are a lot of xp machines that run like manufacturing stuff like presses and cutters etc. that will never be replaced 
19:53:48 <geekosaur> corporate IT environments can be rather frustrating to manage; all too often there's no right solution, just different bad ones
19:54:07 <geekosaur> yep, but they also ddn't take security updates even when they were available
19:54:29 <geekosaur> there's still embedded win95 out there. and even win3.1 and os/2
19:55:06 <DigitalKiwi> there are probably machines from the 30s that have been retrofitted lol
20:00:13 <Arahael> geekosaur: Nothing wrong with that, really, provided they have no network connectivity.
20:00:49 <geekosaur> sadly, a lot of it is network-controlled CNC
20:00:58 <geekosaur> so you need an isolated network for it
20:01:15 <Arahael> That's a decent mitigation.
20:01:23 <geekosaur> except many companies don't have clueful enough IT --- or IT given sufficient funding --- to do that
20:02:05 <Arahael> True. :(
20:02:20 <DigitalKiwi> or IT
20:02:37 <geekosaur> these days most have somnething they call IT
20:02:52 <sproingie> have you tried turning it off and on again?
20:03:00 <geekosaur> far too often, it;'s been pushed onto admin assistants with no training or experience to speak of
20:03:13 <geekosaur> or funding
20:03:47 <sproingie> typically it's "the IT guy" who's reasonably clueful but has zero mandate to actually change things
20:04:09 <geekosaur> thats' another popular one, yeh
20:04:33 <MarcelineVQ> or time
20:06:40 <Arahael> When I was a kid, I was the "IT guy", but with zero budget.
20:07:21 <Solonarv> so, you were just the "IT guy"? :P
20:07:32 <DigitalKiwi> now it's the same but not a kid
20:08:02 <geekosaur> I started out that way too... but in the 80s that described IT pretty much anywhere outside the F100
20:13:43 <GewJi> This one is driving me insane right now, boys.  It's loot
20:15:45 <Arahael> Solonarv: Well, I was teh dude who knew hwo to setup any computer, software, or network, back then. (Or stumble around and figure it out, at least)
20:17:07 <monochrom> Back then, those systems were also more figure-out-able. (None of today's "user friendly = opague, keep it secret" Windows attitude.)
20:17:23 <Arahael> I really detest that trend.
20:17:44 <Arahael> Today, you won't have any idea that a whole feature even exists, if you don't have the access level.
20:18:37 <GewJi> how important is a type identifier to a programming language?
20:18:49 <Arahael> We got a new Jira at work, even.  Now, if you send someone a link to a jira issue, and they look at it and it says: "Access denied", you know *nothing* about why. :(  Perhaps it was a typo? Perhaps the issue doesn't eixst? Perhaps you're logged in but don't have access to thep roject? Whatever, you have *zero information*.
20:19:05 * hackage modular-arithmetic 1.2.1.4 - A type for integers modulo some constant.  http://hackage.haskell.org/package/modular-arithmetic-1.2.1.4 (TikhonJelvis)
20:19:47 <GewJi> For example: string x "Hello" where `string` is the type identifier (not necessarily declaring it)
20:20:05 <GewJi> Like if I'm not defining something, should I still be identifying the type?
20:20:26 <Arahael> I now take the somewhat unproductive, passive agressive stance of reporting *any* such issue with the IT support, as I don't feel it's worth my time to spend the day or so to figure out why they don't have access.
20:20:32 <GewJi> string x = "Hello."; print string x;
20:21:06 <Arahael> GewJi: I'd say it's useful, but shouldn't be required.  ML typing is awesome.
20:21:26 <GewJi> Arahael that sounds like crap
20:21:39 <Arahael> GewJi: How so?
20:24:48 <GewJi> Arahael I forget what part of a compiler give you errors...
20:24:56 <GewJi> but at least they try to guess what's wrong
20:26:00 <GewJi> I'd be pretty upset if a software was giving me no chance to even figure out why my app was broken.
20:26:09 <Arahael> Ah, yeah.  That is indeed crap.
20:26:44 <Arahael> And I've lost the patience to try and figure it out by trial and error. I've studied software and computrs in general for 2 decades, we shouldn't have to do trial and error anymore.
20:26:49 <Arahael> So yeah, I just report it.
20:27:37 <GewJi> I'm thinking about changing my nick to DontHelpMe
20:27:38 <GewJi> lol
20:28:00 <GewJi> Arahael don't freak out
20:28:12 <DigitalKiwi> I wonder if it's a security thing. like it's best practice for a website to respond the same to a request for password reset to an email that doesn't exist in the system as it does for one that is valid
20:28:36 <Arahael> DigitalKiwi: It might be, but if so, it's poorly thought out.
20:29:03 <Arahael> DigitalKiwi: And even if they wanted it to be that way, you effectively require escalation to figure out what happened, so that's just what I do.
20:29:42 <Arahael> DigitalKiwi: So, for a project to which I have *full access* to, a link that says "access denied" to a non-existant issue, well, dude, I'm escalating it. 
20:29:53 <Arahael> DigitalKiwi: I'm just tired of it, I guess.
20:30:03 <DigitalKiwi> jira is bad anyway it's made by those compulsory spai aussies ;p
20:30:24 <Arahael> DigitalKiwi: As an aussie, that's a whole 'nother topic. :(
20:31:18 <DigitalKiwi> I told tony fire all australians
20:31:36 <DigitalKiwi> something tells me he's not going to listen :(
20:31:53 <Arahael> DigitalKiwi: Yes.
20:32:01 <Arahael> GewJi: I won't freak out. :)
20:32:51 <emmanuel_erc> Is there a good resource for discovering how cabal-install actually works?
20:33:18 <sclv> What do you want to know
20:34:24 <sclv> http://www.vex.net/~trebla/haskell/sicp.xhtml http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
20:34:43 <emmanuel_erc> I keep getting these error messages about cabal not being able to install a package because it can't find another one, despite the fact that when I run 'ghc-pkg describe <saidpackage>' I can cleary see it on my system.
20:34:54 <emmanuel_erc> and I want to truly understand why this is happening
20:35:36 <sclv> https://www.haskell.org/cabal/users-guide/
20:35:39 <pavonia> emmanuel_erc: Are you sure the installed package version matches one expected by cbal?
20:36:37 <emmanuel_erc> pavonia: Yes, the version numbers are the same.
20:39:14 <sclv> emmanuel_erc: if you paste the cmd line jnput and output both you can get better advice
20:39:49 --- mode: glguy set +v Steve_
20:47:20 <emmanuel_erc> ok I'll try that
20:50:33 <emmanuel_erc> Here is the output I get https://pastebin.com/SSAs7iwC. The command I invoke is at the top of the page.
20:51:06 <koz_> % :i Comparison
20:51:07 <yahb> koz_: ; <interactive>:1:1: error: Not in scope: `Comparison'
20:53:35 <no-n> @pl (\x -> (x, div n x))
20:53:36 <lambdabot> ap (,) (div n)
20:53:53 <geekosaur> emmanuel_erc, that doesn't say "didn't find", it says "found but it's broken"
20:53:57 <glguy> emmanuel_erc: new-install doesn't use the packages installed into the user package database you find with ghc-pkg list
20:54:07 <geekosaur> ghc-pkg list mithnot shwo that. ghc-pkg check, like the error message says to do, does
20:54:09 <glguy> so that's why your use of ghc-pkg didn't relate to the error
20:54:16 <geekosaur> also, that
20:54:55 <geekosaur> btu in tat case, I'd think something else is wrong since broken packages shouldn't happen with v2-build
20:55:04 <geekosaur> unoless you've been messing around in cabal's stash
20:55:25 <emmanuel_erc> I've deleted .cabal once to see if I could reset things.
20:55:52 <geekosaur> (also I saw an error in there about hdf5 C lib via pkg-config, but profunctor packages shouldn't care about that)
20:56:38 <emmanuel_erc> So, it could find find the profunctors package. But it is somehow can't find one of its modules? How can that be?
20:56:41 <glguy> Maybe sclv knows? But I don't know if there's any cabal support for unregistering things from the store
20:56:59 <glguy> you'll need to convince cabal to rebuild that package
20:57:15 <emmanuel_erc> lens or profunctors?
20:57:16 <no-n> @pl \(x, y) -> x /= y
20:57:16 <lambdabot> uncurry (/=)
20:57:20 <glguy> profunctors
20:57:24 <emmanuel_erc> ah..
20:58:17 <glguy> the packages get installed into ~/.cabal/store
20:58:33 <glguy> AoC is about to start, so I have to disappear
20:59:12 <emmanuel_erc> profunctors is not in my store
20:59:24 <emmanuel_erc> that shouldn't be the case?
20:59:27 <glguy> It'd be named something without vowels
20:59:50 <glguy> like ~/.cabal/store/ghc-8.6.2/prfnctrs-5.3-2a144ed9
21:00:00 <emmanuel_erc> I don't see that at all
21:04:04 <sclv> Is there anything in the store for your ghc at all?
21:04:22 <sclv> If its partial you can delete just the store and try again
21:04:30 <sclv> Sorry I cannot be more help
21:08:47 <emmanuel_erc> There is something thre
21:08:50 <emmanuel_erc> there*
21:08:56 <emmanuel_erc> I'll nuke it and see what happens
21:09:48 <emmanuel_erc> I've got the same error
22:52:22 <sclv> Whoops realized i forgot to ask if it was arch
22:52:28 <sclv> I bet it was arch
22:52:39 <koz_> Oh Arch, you are the cause of many Haskell woes.
23:14:04 * hackage doctest-driver-gen 0.3.0.0 - Generate driver file for doctest's cabal integration  http://hackage.haskell.org/package/doctest-driver-gen-0.3.0.0 (Hexirp)
23:19:23 <koz_> When I use 'cabal new-haddock', I get a whole pile of 'could not find link destinations' for various stuff in modules I import. How would I get those warnings to go away?
23:19:36 --- mode: glguy set +v redver
23:25:41 --- mode: glguy set +v redver
23:32:13 <geekosaur> set 'documentation: true' in ~/.cabal/config and rebuild stuff?
23:34:06 <koz_> geekosaur: Ah, thanks!
