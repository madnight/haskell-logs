00:00:53 <iqubic> what does unfold do?
00:00:59 <iqubic> :t unfold
00:01:00 <lambdabot> error:
00:01:00 <lambdabot>     • Variable not in scope: unfold
00:01:00 <lambdabot>     • Perhaps you meant one of these:
00:03:01 <pacak1> :t unfoldr
00:03:02 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
00:03:07 <suzu> yeah its not the most efficient sort
00:03:25 <suzu> if you want a fast sort, manipulate memory directly and do swaps
00:06:25 <iqubic> so what does unfoldr do?
00:07:32 <suzu> the first argument takes a seed, and may give you a value to produce and another seed
00:07:48 <suzu> and that new seed is used yet again to try and produce another value
00:08:36 <suzu> a fold collapses a list down into a value
00:08:42 <suzu> so an unfold should take a value and produce a list
00:18:19 <iqubic> When is unfold used in the wild?
00:18:31 <iqubic> Can I get an example?
00:21:34 <pacak1> > unfoldr (\x -> if x > 0 then Just (x-1, x-1) else Nothing) 10
00:21:36 <lambdabot>  [9,8,7,6,5,4,3,2,1,0]
00:22:25 <pacak1> :t minViewWithKey
00:22:27 <lambdabot> error:
00:22:27 <lambdabot>     • Variable not in scope: minViewWithKey
00:22:27 <lambdabot>     • Perhaps you meant one of these:
00:23:27 <pacak1> > unfoldr minView (M.fromList [(1,2), (3, 4)])
00:23:29 <lambdabot>  error:
00:23:29 <lambdabot>      • Variable not in scope:
00:23:29 <lambdabot>          minView
00:23:39 <pacak1> > unfoldr M.minView (M.fromList [(1,2), (3, 4)])
00:23:41 <lambdabot>  [2,4]
00:23:57 <pacak1> When you have something and you want a list.
00:57:58 <nshepperd> hm.. unfoldr uncons = foldr (:) []
00:58:07 <nshepperd> foldr cons, unfoldr uncons
00:58:16 <nshepperd> the un- cancels out!
01:34:49 <trcc> Hi everyone. I am making a haskell library. Here, the developer creates a function, f, that is passed to the library. The library then receives an external FFI call, and then invokes this f function. Now, I would like the f function to have a data structure, X, as parameter, that is defined by the developer. Furthermore, f must "return" X. The framework then converts X to a Ptr and returns it to the external entity. Next time the external entity in
01:34:49 <trcc> vokes the library, then Ptr X is passed to the library, which again passes it to f. Any ideas on how to do this?
01:44:02 <bollu> in the (non-strict, strict) x (pure, impure) grid, how come there's no (strict, pure) language? because IO would be impossible?
01:45:06 <mudri> Idris is such a language.
01:45:54 <c_wraith> Idris has the best reason for being strict.  "I don't want to think about implementing that"
01:46:12 <c_wraith> (seriously, that's a good reason in the context of what the language is trying to achieve)
01:49:50 <bollu> c_wraith :) 
01:50:36 <bollu> mudri, c_wraith Huh, I didn't realise that Idris was strict, that's interesting!
01:50:43 <bollu> what are the trade-offs, if any?
01:50:58 <c_wraith> it makes it a lot easier to write a termination checker. :)
01:53:05 <mudri> Mm, the termination checker would still work if it were non-strict (for total programs made up of total parts, the strict/non-strict distinction doesn't matter).
01:53:28 <c_wraith> well, that's true in that direction
01:53:50 <c_wraith> But there are things you can write in Haskell that terminate only because of laziness
01:54:43 <mudri> The termination checker misses a lot of things, and it'd be acceptable to miss these things too.
01:55:04 <mudri> (because they rely on non-total parts)
01:55:33 --- mode: glguy set +v t4nk125
01:55:34 <c_wraith> but really, the main point Edwin has made on several occasions is that he wants to be able to rely on a value of type T actually containing a value of type T
01:55:34 <Levy[m]> productivity checker is nice
01:55:45 <c_wraith> Just because it makes the implementation easier
01:55:57 <c_wraith> No great theoretical reason.
01:56:04 <c_wraith> It's just easier for him to write
01:56:30 <mudri> Yeah, the RTS must be easier.
01:57:27 <mudri> I also remember him saying something about targeting systems programming, which makes sense 'cause that's a thing they seem to do at St Andrews.
01:58:36 <Levy[m]> That was later explained as a non-goal iirc (new core might change that though)
01:59:08 <trcc> How can I store an unknown type in a record? The user provides a data structure X to my haskell package, which I then would like to store in a record, and later call a user function with the particular data structure X. How can I do this, when the data structure is unknown from the view of the my haskell package?
02:00:58 <c_wraith> trcc: the *best* approach is to parameterize the type, such that the caller knows what it is, even if you don't.
02:02:44 <trcc> c_wraith: can you provide a bit more of a clue? something like data UserState x = UserState x
02:02:46 <trcc> ?
02:06:02 <trcc> c_wraith: but then I get the issue of storing it in a reord. I.e. data Component = Component {userState :: UserState}. I do not know the kind of UserState.
02:06:50 <merijn> trcc: Parameterise the component?
02:08:02 <trcc> merijn: Thinking...
02:08:07 <trcc> will respond soon :)
02:08:43 <merijn> The solution to "how do I track this parametricity?" is almost always: "More parametricity!"
02:09:20 <trcc> I will try to follow this road, and see where it leads
02:11:48 <trcc> merijn: the issue is, that the Component is part of an FFI interface
02:12:00 <trcc> so it cannot really be parameterised
02:13:28 <trcc> then all of my ffi functions must take a type parameter, which I am not sure will work in context of FFI?
02:13:42 <merijn> trcc: Depends, what does the FFI do with them?
02:14:53 <trcc> On first invocation from external entity, it returns StablePtr (IORef Component). On following invocations, the external entity passes this back.
02:15:09 <trcc> so it is sort of maintaining state between subsequent clls
02:15:13 <trcc> hmm maybe I could then
02:15:29 <merijn> trcc: If the state is not allowed to change in your API, I don't see a problem :)
02:15:48 <trcc> I update the component between function calls
02:16:14 <merijn> trcc: Right, but if your API requires the same type for it in all updates, that's fine
02:16:22 <trcc> Cool. I will try!
02:16:26 <trcc> Thank you
02:16:31 <trcc> and c_wraith as well
02:17:36 <butterthebuddha> I should be able to figure this out, but I haven't written serious haskell in a little bit and I'm rusty: how do I run a monad exactly n times?
02:18:00 <merijn> :t replicateM -- ?
02:18:01 <lambdabot> Applicative m => Int -> m a -> m [a]
02:18:09 <butterthebuddha> Cool ty
02:53:42 <Ke> I guess timeout does not work with stm?
02:57:23 <merijn> Not as-is, but it should be straightforward to make an STM version
02:57:31 <merijn> Doesn't async have something like that already?
02:58:34 <Ke> the funny thing is, there are timeouts, they just get triggered by some other inputs
03:00:29 <merijn> timeout just uses async exceptions, I think
03:00:37 <merijn> And STM works fine with those
03:11:14 <Ke> merijn: like timeout wait ?
03:18:43 --- mode: glguy set +v test0711
03:19:55 * hackage arbtt 0.10.1 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.10.1 (JoachimBreitner)
03:29:06 <larryba> hi
03:29:14 <larryba> has anyone tried to calculate Easter date? there are so many algorithms in here I'm kind of lost which one to use. https://en.wikipedia.org/wiki/Computus
03:33:04 --- mode: glguy set +v prime
03:34:55 <Guest39611> Hey guys, I wrote a function that simply expressions, something like 3*x+(3+5) And it does return 3*x+(8), but when I write it as 3*x+3+5 it just returns 3*x+3+5 
03:35:51 <Guest39611> https://pastebin.com/cSKbp3tX
03:35:59 <Guest39611> this is the function and data for it 
03:37:30 <Guest39611> is the only way to do this is to implement function like simplify'' :: [Expr] -> Expr that takes an array of Expr like Add (Num 3) (Num 5) and so forth? 
03:48:12 <larryba> how bad do you think this is when done locally, when implementing algorithm that uses mod and div heavily?  (%)  = mod (/) = div
03:49:54 <larryba> this one. div and mod are called a total of 14 times. https://en.wikipedia.org/wiki/Computus#Anonymous_Gregorian_algorithm
03:54:22 <Ariakenom> larryba: not sure what your question is. integer division takes about 100 cycles so maybe 25 microseconds or something https://gmplib.org/~tege/x86-timing.pdf
03:55:37 <larryba> I don't care about cycles. I am talking about redefining % and / because  x % y and x / y  are nicer to read than  x `mod` y   and   x `div` y
03:56:29 <larryba> https://pastebin.com/9Aquk1Wh
04:18:24 --- mode: glguy set +v mreh
04:18:39 --- mode: glguy set -v mreh
04:26:55 <larryba> which one do you find more readable? https://pastebin.com/cEtiNQSJ
04:47:03 <larryba> weekDayDiff Tuesday Monday returns 1. what would you expect this to return? weekDayDiff Monday Sunday
04:48:29 <Solonarv> 1 or -6 are both reasonable; I'd prefer 1
04:54:54 <dmwit> Solonarv: They weren't in the channel when you answered.
04:55:14 <Solonarv> ah, but they are now - I'll repost
04:55:23 <Solonarv> larryba: 1 or -6 are both reasonable; I'd prefer 1
04:55:27 <dmwit> larryba: You might like divMod.
04:55:47 <dmwit> larryba: Also your names are atrocious.
04:56:09 <dmwit> larryba: For your second one, you need not (must not) redefine mod and div like that. You can just use them infix directly.
04:56:44 <larryba> dmwit, they aren't my names, I am following this algorithm. https://en.wikipedia.org/wiki/Computus#Gauss's_Easter_algorithm
04:56:49 <__monty__> dmwit: I think they're problem's not so much with them being prefix as it is with them not being like in other languages.
04:57:16 <__monty__> *their
04:57:19 <larryba> why shouldn't I redefine them locally?
04:57:52 <dmwit> larryba: Because (`mod`) = mod makes mod an infinite loop. =)
04:58:08 <larryba> huh
04:58:12 <dmwit> It completely ignores the existing mod.
04:58:19 <dmwit> Same as if you had written x = x.
04:58:37 <larryba> where did I write (`mod`) = mod?
04:58:46 <dmwit> In your second alternative, at the head of the where block.
04:59:01 <dmwit> (Same for (`div`) = div.)
04:59:01 <larryba> my code works
04:59:22 <larryba> oh
04:59:49 <larryba> just ignore those lines in the second function, I forgot to remove them
05:00:13 <__monty__> larryba: Fwiw, I find `mod` much more readable than % and I think mathematicians would tend to agree. You're just more familar with % probably.
05:00:18 <larryba> my question was about stylistic decision to redefine (/) and (%) localy. ie  (%)  = mod           (/) = div
05:00:35 <larryba> __monty__ what about div vs /?
05:00:55 <dmwit> Don't redefine them.
05:01:35 <__monty__> And `div` isn't so bad imo. It's immediately obvious it's integer division whereas redefining / leads to confusion, *maybe* you could mimic python's // but still more confusing than anything imo.
05:01:52 <Solonarv> If you redefine common operators to have a different meaning, it makes your code harder to read.
05:02:00 <larryba> does it really lead to confusion when it is defined at the top?
05:02:51 <__monty__> larryba: People don't usually go line by line if the code looks simple enough.
05:03:08 <__monty__> At least, *I* don't. Maybe that's what I do wrong : )
05:05:12 <larryba> __monty__ that is true
05:21:17 <Solonarv> Even if I read line by line, that's still an extra bit of context I need to remember
05:21:36 <larryba> I'll use div/mod
05:22:49 <larryba> about weekDayDiff Monday Sunday returning 6. so Sunday should be first weekday, and Saturday last? then weekDayDiff Sunday Saturday should return 6?
05:22:59 <larryba> about weekDayDiff Monday Sunday returning 1. so Sunday should be first weekday, and Saturday last? then weekDayDiff Sunday Saturday should return 6?
05:25:16 <Solonarv> Yes, though that's independent of which weekday you call "first"
05:25:36 <Solonarv> If today is a Sunday, the next Saturday is 6 days from now
05:28:20 <larryba> so first argument is hypothetical today, and second argument is N days after today? that makes sense
05:32:38 <Solonarv> weekDayDiff x y ≡ x `weekDayDiff` y ≅ x - y ≅ (later) - (today), so (to me) the logical argument ordering is 'weekDayDiff later earlier'
05:34:38 <Solonarv> so weekDayDiff Monday Sunday ≡ 0 - 6 ≡ 1, and weekDayDiff Sunday Saturday ≡ 6 - 5 ≡ 1 as well
05:37:26 <larryba> I like that it doesn't matter which day is the start of the week, but to me the order of those arguments looks backwards
05:38:41 <Solonarv> It does if you use it prefix, but that's the kind of function I would prefer to use infix
05:39:27 <Solonarv> i.e. if I'm using that function I'd prefer to write 'x `weekDayDiff` y' over 'weekDayDiff x y'
05:41:18 <larryba> yeah I understand
05:46:05 <larryba> weekDayDiff later earlier does make sense if we look at it like subtraction, even if it is used in prefix
06:02:32 <Ke> realized, I don't need stm, but timeout does not work with regular chans either
06:02:56 --- mode: glguy set +v PatrickRobotham
06:24:18 <larryba> what about weekDayDiff Monday Monday? it could be 0 or 7
06:43:22 <nan`> i am having a problem with stack (i think) leaving .dump-hi files around when a library (hint) is trying to clean up a directory. Has anyone run into something like this before? What is the proper process for cleaning up .dump-hi files?
06:43:46 <nan`> more info: https://github.com/haskell-hint/hint/issues/78
06:45:38 <Ke> huh, not even threadDelay works
06:49:00 <nan`> how does stack even generate these .dump-hi files and when/why
06:49:38 <larryba> Solonarv, I renamed the function to weekdayFromTo, to remove ambiguity whether first argument is earlier or later. but I'm not sure what weekdayFromTo Monday Monday should return, 0 or 7
06:51:06 <Ke> I am actually struggling to find a way to do anything that does not run on busyloop
06:53:38 <larryba> <Ke> huh, not even threadDelay works <- paste some code
06:56:07 <Ke> https://users.aalto.fi/~jkarlson/codes/xmonad.hs function pingThread
06:56:28 <Ke> threadDelay seems to complete only, when I move my cursor
06:57:10 <Ke> this issues may have something to do with monad
06:57:13 <Ke> xmonad
06:57:21 <Tuplanolla> It's explained in the documentation.
06:57:33 <Ke> which doc?
06:57:42 <Tuplanolla> The one for `threadDelay`.
06:58:17 <Ke> you mean the part, where it says threadDelay can complete later than actual target time?
06:58:28 <Tuplanolla> Yes.
06:59:01 <Ke> that part is always there in any such function, it normally does not mean unbounded runtime in practise
06:59:47 <Ke> is there some more eager delay function
07:00:25 <Tuplanolla> It's not a property of the function, but that of the way GHC schedules threads.
07:00:32 <larryba> threadDelay completing later than target time doesn't explain busy loop
07:01:03 <Ke> larryba: there is no busy loop, I mean I can't solve the problem without creating a busyloop
07:01:19 <Ke> well, I could use ffi to call nanosleep
07:02:25 <Ke> larryba: the problem is, that threadDelay probably never completes, if there is no external trigger
07:04:43 <Ke> Tuplanolla: also wittgenstein would not agree that it would be a documented feature, in contemporary language in such context such statement just mean it's not a hard real time feature
07:06:57 <Tuplanolla> "Scheduling may be either pre-emptive or co-operative, depending on the implementation of Concurrent Haskell (see below for information related to specific compilers). In a co-operative system, context switches only occur when you use one of the primitives defined in this module. This means that programs such as [the following] will print either `aaaaaaaaaaaaaa`... or `bbbbbbbbbbbb`..., instead of some random interleaving of `a`s
07:07:34 <Tuplanolla> I don't see how that says anything about time constraints.
07:07:50 <Tuplanolla> It clearly says the thread may never be scheduled again.
07:08:53 <Ke> Tuplanolla: may not is always true, but normally there is an attempt to resume execution as soon as possible after the time has elapsed
07:10:24 <Ke> the problem in this case is probably, that the system is too idle
07:12:37 <Ke> or xmonad does something silly
07:13:11 <Tuplanolla> The thread that is currently running simply doesn't do any io to trigger rescheduling.
07:15:09 <Ke> anyway, do you have any suggestions for fixes?
07:15:16 <larryba> <Tuplanolla> It clearly says the thread may never be scheduled again. <- can this ever happen in practice, other then when you compile without threading support, and fire multiple threads
07:18:19 <Tuplanolla> If possible, put a timer in the running thread that periodically wakes up the other threads by doing something trivial.
07:19:35 <Ke> I am not sure I can touch the xmonad code itself
07:20:23 <Tuplanolla> I was worried that might be the case.
07:45:08 <ph88> can i build this project with stack?  https://github.com/haskell/hsc2hs
07:57:47 <larryba> why is IO () needed in here?   f xs ys = g xs ys where g x y = mapM_ (\(x,y) -> (printf "%s %s\n" x y)) (zip x y) :: IO ()
07:58:49 <larryba> I wrote signature, f :: [String] -> [String] -> IO (), so there should be no ambiguity whether I wanted String or IO (). and yet, I get: Could not deduce (PrintfType (m b0))
08:00:50 <larryba> https://pastebin.com/XYi2S3XV
08:02:00 <ClaudiusMaximus> :t mapM_
08:02:01 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
08:02:16 <ClaudiusMaximus> the 'b' there is ambiguous
08:02:54 --- mode: glguy set +v mreh
08:03:48 <larryba> how am I clearing that ambiguity when by adding `:: IO ()'?
08:03:53 <larryba> s/when//
08:05:54 <pavonia> larryba: Move the signature to the inner after printf
08:06:09 <larryba> pavania that works too
08:06:29 <larryba> and :: String doesn't. so where's the ambiguity? there are two options, String and IO (), and only one compiles
08:07:17 <pavonia> It can't be String because of the result type being IO ()
08:12:30 <ClaudiusMaximus> larryba: there is the open world assumption, someone could define another instance so the compiler can't choose IO ()
08:14:08 <lyxia> larryba: https://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Printf.html#t:PrintfType there is an instance  (a ~ ()) => PrintfType (IO a)
08:14:52 <lyxia> so that if once you know "m ~ IO", "a" gets unified with "()".
08:15:16 <larryba> why can't it figure out that it is IO when it has f :: [String] -> [String] -> IO ()
08:15:38 <lyxia> because g gets generalized
08:20:53 <coldpress> hey all, what's the best way to parse a right-recursive BNF grammar without Text.Parsec's chain combinators? I'm trying buildExpressionParser, but it can't capture right-recursion because I did not define any operators
08:21:12 <lyxia> larryba: you can try experimenting with MonoLocalBinds
08:21:29 <larryba> lyxia, shouldn't the function be as generalized as much as possible while the code still compiles, but no more than that?
08:21:59 <coldpress> argh ignore me pls, i should just use the chain combinators
08:22:05 <larryba> it doesn't compile without type hints if I add {- Language: MonoLocalBinds -} 
08:22:11 <lyxia> well PrintfType is kind of insane anyway
08:24:04 <lyxia> this kind of type class hackery is useful but not that well understood and with plenty of rough edges like this
08:25:32 <larryba> lyxia, yeah, printf is weird, unsafe, but I still end up using it
08:34:44 --- mode: glguy set +v cronokirby
08:38:06 <seishun> how does one normally count the number of elements in a set that satisfy a predicate? `Set.size $ Set.filter pred s`?
08:38:53 <davean> seishun: that sounds about right - thats a pretty expensive operation though. Maybe you want something not a set?
08:38:59 <davean> at least if the set is large.
08:40:11 <seishun> davean: maybe, all I'm doing is iterating over it many times, each time removing an element from it
08:40:27 <seishun> maybe Data.Sequence would be better for this?
08:40:41 <davean> Sequence gives you the ability to have fast search
08:40:53 <davean> which, if that fast search worked for you, would be nlogn instead of n^2
08:40:59 <davean> rather a massive improvement
08:41:25 <seishun> I don't even search
08:41:48 <fendoer> can i tell a stack script to always use the global resolver?
08:42:50 <davean> seishun: yes, and I'm saying that not searching is the thing that makes it slow
08:42:57 <davean> well, you *do* search
08:43:29 <davean> you specificly do a linear search (though in a tree structure, so let me revise the above, its more like (n^2)logn
08:44:33 <seishun> no, I iterate over every element, calculate a value for each (that depends on the rest of the elements), then delete the element with the lowest value
08:44:49 <davean> that is a search right there
08:44:59 <davean> You're describing a search
08:45:41 <cronokirby> this reminds me of a heap
08:46:10 <seishun> okay, but why would that be (n^2)logn
08:46:39 <davean> cronokirby: depends on if his view is the same each time or not
08:46:45 <cronokirby> mhm
08:47:13 <davean> seishun: because there are n elements in the set, and each step to get the next element would be log n
08:48:07 <davean> so your basic "remove one" in a set is nlogn and in a seq if you can index for it is logn
08:48:49 <seishun> what about the iteration part, is it faster in Seq too?
08:49:10 <davean> No, its the same in seq
08:49:23 <monochrom> Tree traversal is linear time. "I need to build a new set of k elements, they come in unknown order" is k log k.  This thing doesn't have an n^2 term.
08:49:26 <davean> the advantage of seq is avoiding the iterative search
08:50:05 <seishun> what do you mean by iterative search?
08:50:24 <davean> seishun: in a DB it would be refered to as "full table scan"
08:50:53 <davean> monochrom: I may have been mistaken but he said he was calculating a new value - perhaps its not persisted
08:51:01 <monochrom> Oh haha this is "I need to build a new set of k elements but I already know they're ascending" so it is actually linear time too.
08:51:16 <monochrom> You didn't see the code "Set.size (Set.filter blah blah)"?
08:51:32 <monochrom> Set.filter is linear time.  See the haddock.
08:51:34 <davean> monochrom: I adjusted once he said something that didn't necissarily fit with that
08:52:02 <monochrom> OK then carry on.
08:52:14 * monochrom hates telepathic talking.
08:53:41 <seishun> there are two parts, first for each element (a) I find how many other elements (b) satisfy `pred a b`, second I delete the element where the value is the lowest
08:53:49 <seishun> hope that clears things up a bit...
08:55:44 <mreh> > intercalate " " . repeat $ "ho"
08:55:46 <lambdabot>  "ho ho ho ho ho ho ho ho ho ho ho ho ho ho ho ho ho ho ho ho ho ho ho ho ho ...
08:56:10 --- mode: glguy set -v mreh
08:58:44 <rezzme> >1*5
08:59:13 <rezzme> > 1+3
08:59:15 <lambdabot>  4
08:59:34 <mreh> someone do the 12 days of Christmas
09:00:04 <monochrom> Like sum [1..12]?
09:00:07 <rezzme> i'm an utter noob so i'm not the one
09:00:29 <mreh> > heads ["patridge in a pear tree", "two turtle doves", "three french hens"]
09:00:32 <lambdabot>  error:
09:00:32 <lambdabot>      • Variable not in scope: heads :: [[Char]] -> t
09:00:32 <lambdabot>      • Perhaps you meant one of these:
09:01:00 <rezzme> besides, 12 days?? I thought it lasted only two days
09:01:06 <monochrom> Oh no it is sum [sum [1..i] | i <- [1..12]]
09:01:13 <aarvar> On the 0th day of Christmas...
09:01:34 <mreh> > inits ["patridge in a pear tree", "two turtle doves", "three french hens"]
09:01:37 <lambdabot>  [[],["patridge in a pear tree"],["patridge in a pear tree","two turtle doves...
09:01:45 <mreh> close
09:01:49 <seishun> hm, how do I get the index of the minimal value in a Seq?
09:02:08 <rezzme> that looks pretty cool monochrom 
09:02:10 <seishun> do I have to `zip [0..]`?
09:02:33 <rezzme> > sum[1..i] | i <- 3
09:02:35 <lambdabot>  <hint>:1:11: error: parse error on input ‘|’
09:03:06 <monochrom> You need an outer pair of []s
09:04:19 <rezzme> oh, okay. i thought it was a bit like mathematics: x element of R | 0 < x < 1
09:04:34 <monochrom> In math you need an outer pair of {}.
09:05:00 <int-e> > 14*13*12 `div` (3*2*1) == sum [sum [1..i] | i <- [1..12]]
09:05:02 <lambdabot>  True
09:05:17 <rezzme> ... you're right, you need the {} to make it a set
09:05:54 <rezzme> [sum [1..i] | i <- 3]
09:05:57 <rezzme> sorry
09:06:02 <rezzme> > [sum [1..i] | i <- 3]
09:06:04 <lambdabot>  error:
09:06:04 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_113’
09:06:04 <lambdabot>      • In the expression: e_113
09:06:10 <monochrom> Sometimes {} is missing because the author is using LaTeX and they forgot it's \{ \} in LaTeX. >:)
09:07:02 * rezzme pets his latex book
09:07:25 <monochrom> It's i<-[1..3] not i<-3
09:08:27 <seishun> oh, there's mapWithIndex, nice
09:11:12 <seishun> still slow with a Seq :(
09:11:26 <rezzme> monochrom, got it, thanks
09:12:13 <seishun> slower than with a list
09:12:28 <davean> seishun: why don't you show your code.
09:18:10 <seishun> davean: https://gist.github.com/seishun/8870d99ec9ef16312c7677be954c2650
09:27:14 --- mode: glguy set +v shd
11:01:50 * hackage fast-downward 0.1.0.0 - Solve classical planning problems (STRIPS/SAS+) using Haskell & Fast Downward.  http://hackage.haskell.org/package/fast-downward-0.1.0.0 (OliverCharles)
11:20:49 <iqubic> unfoldr is like magic to me.
11:21:43 <beka> iqubic: :)
11:22:11 <beka> the generalizations are great
11:22:56 <lavalike> how can I get more information at a: array *** Exception: Error in array index
11:23:04 <iqubic> I don't even know what you'd use unfoldr for in production.
11:23:40 <lavalike> to produce a list!
11:23:41 <hpc> creating a list from a generator function and an initial seed
11:23:56 <iqubic> but when is that useful?
11:24:03 <beka> iqubic: lots of things! you can, for instance, define lots of fun things w/ unfold such as quicksort
11:24:21 <iqubic> How do you define quicksort as an unfold?
11:24:26 <beka> :)
11:24:57 <iqubic> I don't think it is possible to define quicksort as an unfold.
11:25:00 <beka> consider this haskell-y quicksort definition:
11:25:35 <beka> sort [] = []  ;  sort (x:xs) = sort (filter (<= x) xs) ++ [x] ++ sort (filter (x <) xs)
11:25:59 <iqubic> Sure. I'll buy that.
11:26:14 <beka> for any given xs, the following is true: if its empty, we're done. if it's not empty, we're not done, yeah?
11:26:33 <beka> so we have some predicate   done :: [a] -> Bool  ;  done [] = True ; done (x:xs) = False
11:26:35 <iqubic> Sure.
11:27:01 <lavalike> any idea how to nail down such an array index exception?
11:27:12 <lavalike> just a line number would be swell
11:27:22 <beka> also, we have a way of splitting any given non-empty list into two smaller lists:   given   x:xs   we split it into   filter (<= x) xs   and also   filter (x <) xs
11:27:26 <beka> make sense iqubic?
11:27:31 <iqubic> yes it does
11:28:20 <beka> namely:   partition (x:xs) = (filter (<= x) xs, filter (x <) xs)
11:28:27 <beka> partition :: [a] -> ([a],[a])
11:28:48 <iqubic> I will agree to that.
11:29:20 <beka> so we have:   done :: [a] -> Bool   and   partition :: [a] -> ([a],[a])
11:30:12 <iqubic> I get that. Yeah.
11:30:47 <beka> infact, lets do something more fun:   partition (x:xs) = (x, filter (<= x) xs, filter (< x) xs)
11:31:19 <iqubic> How do we get an unfold out of this?
11:31:31 <beka> so if we have an **appropriate unfold**,    we can define   sortTree xs = appropriateUnfold done partition
11:31:40 <beka> and then just flatten the sort tree
11:31:46 <iqubic> I think so.
11:31:49 <beka> in this case it's not an unfold for lists (its not unfoldr)
11:31:51 <iqubic> :t unfoldr
11:31:52 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
11:31:59 <beka> rather its an unfold for *trees*!
11:32:07 <iqubic> So it's closer to an anamorphism
11:32:15 <beka> unfolds are anamorphisms :)
11:32:34 <beka> unfoldr p f   is a list anamorphism written in a weird way
11:32:58 <iqubic> So one could just do this: http://dpaste.com/0XGXRH0
11:33:20 <beka> oh, yes
11:33:25 <iqubic> Not the most efficient quicksort, but it works.
11:33:30 <beka> wait, you've playing around with recursion schemes???
11:33:36 <beka> but you only just discovered unfoldr?
11:33:37 <iqubic> I am indeed.
11:33:44 <iqubic> And yes.
11:33:47 <beka> well in this case let me rephrase!
11:33:59 <beka> do you know about fold-unfold fusion laws?
11:34:08 <iqubic> No I do not.
11:34:55 <iqubic> I am learning about recursion schemes because I think they will simplify my code in places and make it easier to write recursive algoritms.
11:35:24 <beka> basically there is a theorem that says if you can define a function   h : A -> B    as   h = fold f . unfold g   then you can also define   h = hylo f g
11:36:08 <beka> where fold and unfold are the "natural" fold and unfold (foldr and unfoldr are unnatural in that they're .. weirdly defined)
11:36:20 <beka> (they're equivalent but ugly for these purposes)
11:37:03 <beka> fold f . unfold g   will be much more expensive than   hylo f g   because the former will build up an entire intermediate structure with the unfold (an intermediate list, an intermediate tree, etc.) only to then consume it with the fold
11:38:02 <beka> whereas hylo never does this, right. it'll just construct the correct composed function calls in the right way
11:38:36 <beka> so then what happens, right, is that if you can define   h = fold f . unfold g   your compile (if its smart!) can say "aha! this is a hylo!" and redefine it as h = hylo f g
11:39:03 <beka> and you get a bunch of efficiency gain for free b/c you're no longer allocating and deallocating all that memory for nothing
11:39:10 <iqubic> I see. Tha makes a lot of sense.
11:39:17 <beka> haskell lets you have rewrite rules like this
11:40:02 <iqubic> So Cata applied to trees is a bottom up traversal. I. E. it starts at the leaves and works its way up.
11:40:05 <beka> which is why you see a lot of foldr in Prelude. there are other fusion laws too, and this means that haskell can improve the efficiency of your programs by doing all sorts of fusion at compile time
11:40:22 <iqubic> Is it possible to have a top down traversal that starts at the root of the tree?
11:40:29 <beka> yeah catamorphisms in general are "bottom up"
11:40:45 <beka> i dont want to call it a traversal because traversal can mean lots of different things
11:41:23 <beka> usually "traversal" is used in an *imperative* context to talk about applying a procedure to each node in a tree, where the procedure is used for side effects
11:41:34 <beka> you don't usually talk about traversals when *transforming* things
11:41:57 <iqubic> So I have this AST, plus the correct call to template haskell to allow recursion-schemes to work.
11:41:59 <iqubic> http://dpaste.com/045HAQA
11:42:21 <beka> dunno what thats supposed to mean tbh
11:42:29 <iqubic> Oh, sorry.
11:42:34 <iqubic> Ignore me.
11:42:35 <beka> i get the AST language but
11:43:11 <iqubic> It's just that I'm going to be doing things like: "derivative :: Expr -> Expr"
11:43:33 <beka> ah
11:43:39 <iqubic> derivative (Add x y) = Add (derivative x) (derivative y)
11:44:36 <iqubic> derivative (Mul x y) = Add (Mul x (derivative y)) (mul y (derivative x))
11:45:35 <iqubic> And that's why I want a top down recursion-scheme, so that I can look at the outermost thing first, and then work in. Because that's how you do derivatives with pen and paper.
11:48:18 <ph88> is there a tool to format the output of traceShow ?
11:48:59 <iqubic> So I'm not sure what recursion-scheme would be the best.
11:49:43 <beka> iqubic: you might be able to think of that as an unfold, sure
11:50:01 <iqubic> How so?
11:50:03 <beka> thats more of a paramorphism tho, since you want not only the resursive calls but the sub arguments
11:50:13 <ph88> hmm ill go with pretty-simple
11:50:13 <iqubic> Right, I suppose so.
11:50:41 <iqubic> Or it might be an apomorphism, as that's the dual of the paramorphism
11:51:12 <beka> derivative = para Const (\x y dx dy -> Add dx dy) (\x y dx dy -> Add (Mul x dy) (Mul dx y))
11:51:31 <iqubic> What does that do?
11:51:37 <beka> its the derivative :)
11:51:41 <iqubic> Or rather, how does it work.
11:52:08 <iqubic> Also, I plan to add a lot more cases to this.
11:52:17 <iqubic> So I'd like it to extensible.
11:52:40 <iqubic> And I'd like it to start from the top and work down. Which I'm not sure this does.
11:52:41 <beka> para c a m (Const c) = c    ;    para c a m (Add x y) = a x y (para c a m x) (para c a m y)    ;    para c a m (Mull x y) = m a x (para c a m x) (para c a m y)
11:53:39 <iqubic> What does that show?
11:53:48 <iqubic> I'm finding it a bit hard to understand.
11:55:07 <iqubic> Does that start at the top of the data structure and work its way down?
11:55:34 <iqubic> Also, para is only a two arg function.
11:55:36 <iqubic> :t para
11:55:37 <lambdabot> Plated a => (a -> [r] -> r) -> a -> r
11:55:44 <iqubic> Not that.
11:55:54 <iqubic> (Base t (t, a) -> a) -> t -> a 
11:57:36 <Tuplanolla> It can be a three-argument function if `a` is a function type, iqubic.
11:58:29 <iqubic> Tuplanolla: I'm still not sure how the derivative function is supposed to work.
11:59:09 <iqubic> What I want to do is figure out how to modify my cabal file to actually add recursion-schemes as a dependency.
12:00:13 <iqubic> And then I want to write an eval function and pretty printer, both with cata.
12:02:06 <iqubic> How the heck do I add external libraries as a dep to my stack project?
12:03:05 <iqubic> TIL: A cabal is a small group of people united in some close design.
12:04:00 <iqubic> TIL: Cabal: Common Architecture for Building Applications and Libraries
12:05:29 <beka> iqubic: it defines para
12:05:31 <beka> or at least para for Expr
12:06:28 <sclv> iqbic do you have a package.yaml file as well as a package.cabal file?
12:07:02 <sclv> iqubic: if you have the package.yaml file you add it there instead and the cabal file is generated from it, its irritating
12:07:03 <iqubic> yeah, but how does it work?
12:07:15 <sclv> its an hpack file
12:07:30 <iqubic> I thought you only updated the cabal file.
12:07:43 <sclv> stack does this thing where it doesn't default to having you use a cabal file
12:07:52 <sclv> it instead autogenerates it from a package.yaml file
12:07:52 <iqubic> I see.
12:07:59 <sclv> you add the dep to the package.yaml _and_ the stack.yaml
12:08:05 <sclv> https://github.com/sol/hpack
12:08:07 <iqubic> I have both a cabal file and a yaml file, so...
12:08:23 <sclv> do you have two yaml files or just one?
12:08:27 <sclv> the stack.yaml file is always there
12:08:41 <sclv> the package.yaml is used in addition if you have an hpack (rather than plain cabal) setup
12:09:04 <iqubic> I don't have hpack setup.
12:09:16 <sclv> ok, so just the one yaml file, not two?
12:09:18 <iqubic> And I just have a stack.yaml. no package.yaml
12:09:28 <iqubic> Yeah, just the one yaml file.
12:09:31 <sclv> ok, then just add the package you want to depend on to the build-depends field of your cabal file
12:09:56 <iqubic> What would that look like?
12:10:42 <sclv> currently it says something like `build-depends: base > 2 && < 5` right?
12:11:09 <sclv> so make it `build-depends: base > 2 && < 5, [someotherpackage], [anotherpackage]`
12:12:04 <beka> iqubic: what do you mean how does it work!
12:12:04 <sclv> here's an example cabal file to look at https://hackage.haskell.org/package/bytestring-0.10.8.2/bytestring.cabal
12:12:09 <beka> iqubic: it's a definition! :P
12:12:48 <beka> it'd help i bet to kind of understand what folds are doing generically
12:13:18 <iqubic> yeah.
12:13:19 <beka> so: consider the type of the constructors for lists:   [] :: [a]    (:) :: a -> [a] -> [a]
12:13:38 <beka> now consider the arguments to fold:    z :: r    f :: a -> r -> r
12:13:41 <beka> they're *very* similar
12:13:49 <beka> in fact, if r == [a] then they're the same types!
12:14:24 <beka> fold f z xs   is just xs, except all of the occurrences of [] have been replaced by z, and all occurrences of (:) have been replaced by f
12:14:32 <beka> fold is, in some sense, a constructor swapper
12:14:41 <iqubic> I see how that works.
12:14:43 <beka> so:   foldr (:) [] xs == xs
12:15:32 <beka> but what is para for lists? well its just like fold, except the recursive constructors get replaced with a function that takes no only the recursively transformed lists (like f does) but ALSO the recursive list itself, the one that gets transformed
12:16:03 <beka> para g z [] = z    ;    para g z (x : xs) = g x xs (para g z xs)
12:16:14 <beka> g :: a -> [a] -> r -> r
12:16:19 <beka> compare to f :: a -> r -> r
12:17:18 <beka> now look at Expr:     Const :: Int -> Expr     Add :: Expr -> Expr -> Expr    Mul :: Expr -> Expr -> Expr
12:17:26 <beka> (im simplifying Expr for expositional purposes)
12:18:01 <beka> so then, just like we did with lists, we can make a fold for Expr, which has arguments    c :: Int -> r    a :: r -> r -> r    m :: r -> r -> r 
12:18:23 <beka> this is all for some fixed r, btw
12:19:02 <beka> so,    foldExpr c a r exp   should be JUST like exp except it has Const replaced w/ c, Add replaced with a, and Mul replaced with m
12:20:00 <beka> er,    foldExp c a m exp   sorry
12:20:29 <beka> how to define it? well, equationally!    foldExpr c a m (Const i) = c i    ;    foldExpr c a m (Add x y) = a (foldExpr c a m x) (foldExpr c a m y)    ;    foldExpr c a m (Mul x y) = m (foldExpr c a m x) (foldExpr c a m y)
12:20:47 <beka> we're just going over exp and swapping out Const for c, etc.
12:21:39 <beka> and so by analogy to fold for lists, paraExpr is just like foldExpr except the args also take the recursive expr's as arguments, not just the recursive result
12:57:48 --- mode: glguy set +v inertialframe
13:44:56 <merijn> What's the correct way to import a data family?
13:45:48 <merijn> I'm trying to import a persistent EntityField from a module, but if I write just the data constructor GHC yells at me to import the core type, but if I do that, GHC complains it's not exported...
13:48:49 <hpc> can you write it as "TypeName(..)" as if it was a regular data type?
13:49:16 <merijn> hpc: Then it says it's not exported from that module
13:49:26 <hpc> hmmmmmmm
13:50:32 <Tuplanolla> Use `-ddump-minimal-imports` to find out, merijn.
13:53:10 <MarcelineVQ> I think there's 'pattern' and 'type' qualifiers for fancier imports
13:53:32 * hackage cql-io 1.1.0 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-1.1.0 (romanb)
13:53:35 <merijn> MarcelineVQ: Yeah, but I need to import a constructor
13:54:07 <Solonarv> TypeName(ConstructorName), perhaps?
13:54:20 <merijn> Solonarv: Nope, that's what hpc said and I tried, but that says it's not exported
13:56:12 <merijn> Unrelatedly: Ugh, why are vectors not Foldable?
13:57:39 <monochrom> They aren't?
13:57:53 <merijn> monochrom: I don't see an instance, at least?
13:58:11 <merijn> monochrom: There are various fold functions defined, but no Foldable instance
13:59:08 <int-e> merijn: the boxed ones have a foldable instance according to http://hackage.haskell.org/package/vector-0.12.0.2/docs/Data-Vector.html
13:59:11 <MarcelineVQ> merijn: you using unboxed?
13:59:16 <int-e> the unboxed ones aren't polymorphic enough
13:59:19 <merijn> int-e: I'm using Unboxed, though
13:59:19 <monochrom> OK I have just fired up ghci then ":m + Data.Vector" and ":m + Data.Foldable" then ":info Vector" and it has Foldable.
13:59:44 <merijn> int-e: Why's that?
14:00:02 <monochrom> I guess some reason why Set is not a Functor.
14:00:06 <monochrom> s/some/same/
14:00:15 <merijn> monochrom: Foldable can't produce the initial type, though
14:00:22 <merijn> monochrom: That'd only apply to Traversable
14:00:32 <monochrom> great indexed Functor and Foldable but have to be indexed.
14:01:06 <merijn> I don't buy this "can't be because not polymorphic" unless someone can come with an example/argument why that is
14:01:30 <Solonarv> I think it's something like: the implementation of 'Vector a' needs to dispatch on 'a', but Foldable doesn't allow that
14:01:36 <monochrom> OK foldMap is forall a. ... -> t a -> ...
14:01:50 * hackage cql-io-tinylog 0.1.0 - Tinylog integration for cql-io.  http://hackage.haskell.org/package/cql-io-tinylog-0.1.0 (romanb)
14:02:13 <monochrom> where t = unboxed vector
14:02:52 <merijn> monochrom: So, what's the problem?
14:03:20 <int-e> merijn: I suppose you could define  data SomeVector a where SomeVector :: Unbox a => Vector a
14:03:53 <int-e> merijn: And then define a foldable instance for that. But Vector a doesn't store the Unbox dictionary, so you can't deconstruct it, so there's no fold.
14:04:03 <merijn> int-e: That's more work than not using foldable, though
14:04:07 <Solonarv> int-e: ah, that should work
14:04:45 <int-e> uh, the type is missing a '-> SomeVector a' at the end
14:04:46 <Solonarv> the 'Unbox a' dictionary is what I meant when I said "dispatch on 'a'", btw
14:05:05 <merijn> int-e: Ah, you can't unbox constrain the element with foldable
14:05:07 <merijn> hmmm
14:05:13 <merijn> That's obnoxious
14:05:51 <Solonarv> There's probably a constrained variant of Foldable somewhere
14:05:56 <monochrom> That's what I was trying to convey with my own "forall a."
14:06:22 <Solonarv> It might even have an instance for unboxed vectors!
14:07:06 <merijn> Solonarv: Yeah, but all that is more work than just manually prefixing every call with vector with V.toList
14:10:41 <monochrom> Going through V.toList may or may not incur overhead. Fusion may or may not happen. Carefully check core.
14:11:54 <merijn> monochrom: I don't care about fusion as I'm just iterating over the vector than throwing it out
14:12:17 <c_wraith> isn't that exactly when fusion matters?
14:12:20 <merijn> monochrom: basically just "mapM_ myFun", but generalised as I use it for other things than vector and there's some surrounding boilerplate
14:12:43 <monochrom> There is possible overhead of re-boxing.
14:20:50 <monochrom> Well, maybe unboxed's own customized folds incur re-boxing overhead too because a statically unknown function passed in as parameter is involved.
14:21:18 <int-e> monochrom: it's probably fine; `toList` is defined in terms if `build` so should interact nicely with GHC's list fusion.
14:22:41 <monochrom> But even then, frequently converting say Double# to Double is not nice.
14:25:08 <seishun> is there a function like `words` that would also eat all non-letter chars? specifically I need to get rid of "();,"
14:25:30 <Solonarv> you can use 'filter' to remove them first
14:25:40 <Solonarv> or 'fmap' to turn them into spaces
14:26:04 <seishun> oh, that would work
14:26:11 <monochrom> Ah turn them into space first. Because maybe "a;b" should be treated like "a b" not "ab".
14:26:30 <seishun> that doesn't happen in my case
14:26:53 <Solonarv> % let toSpace c | c `elem` "();." = ' ' | otherwise = c
14:26:54 <yahb> Solonarv: 
14:27:17 <Solonarv> % words . fmap toSpace $ "a;b"
14:27:17 <yahb> Solonarv: ["a","b"]
14:28:05 <monochrom> There is also the split package if you later want fairly general splitting criterion.
14:28:40 <seishun> it seems filtering would work fine for me, thanks
14:28:47 <int-e> % words . fmap toSpace $ "(a;;b)"
14:28:48 <yahb> int-e: ["a","b"]
14:29:11 <monochrom> Yeah, I agree with KISS too. But do bookmark the split package for future use.
14:29:43 <merijn> Is a monoidal version of when (aka "f b v = if b then v else mempty" defined anywhere?
14:29:54 <merijn> Because I keep wanting/using that
14:31:41 <int-e> > [1 | False] ++ [2 | True] -- now you just need list comprehension for monoids (which is probably a bit too much to ask)
14:31:43 <lambdabot>  [2]
14:32:27 <int-e> (I don't know of such a function)
14:32:41 <merijn> int-e: Not quite workable in that form, I think
14:37:49 <int-e> merijn: it would have worked if you monoid had been a list (of course, then `when` would have worked as well)
14:38:54 <Solonarv> That's guard, not when
14:39:06 <Solonarv> > guard False :: [()]
14:39:08 <lambdabot>  []
14:39:14 <hpc> :t guard
14:39:15 <lambdabot> Alternative f => Bool -> f ()
14:39:18 <Solonarv> > when False :: [()]
14:39:20 <lambdabot>  error:
14:39:20 <lambdabot>      • Couldn't match expected type ‘[()]’
14:39:20 <lambdabot>                    with actual type ‘f0 () -> f0 ()’
14:39:29 <merijn> Solonarv: Guard is the wrong type
14:39:30 <int-e> Solonarv: silly me
14:39:47 <Solonarv> merijn: I was responding to int-e
14:40:04 <int-e> well, let's be honest. stupid me.
14:40:45 <Solonarv> More generally, it works for any monoid that's equivalent to Alt f a for some f
14:41:47 <Solonarv> (i.e. a monoid where (<>) = (<|>) and mempty = empty)
15:05:47 <merijn> Anyone with persistent experience and the best way to have a datatype of which a certain alternative can't ever be stored in the dataset?
15:21:51 <_deepfire> Solonarv: what was your experience with lambdacube-3d?
15:22:31 <Solonarv> Huh? I've never used it.
15:23:02 <Solonarv> I played around with the demo on its website and read the introduction, that's about it
15:23:28 <_deepfire> Well, that's what I meant, I wondered how you found it : -)
15:23:34 <_deepfire> Just the initial experience..
15:24:13 <_deepfire> Were there any stumbling blocks?
15:30:52 <Solonarv> I don't know enough about OpenGL to differentiate between a stumbling block and a gap in my OpenGL knowedge
16:02:44 <iqubic> does the dante package for emacs properly understand that one can put external deps in a .cabal file?
16:05:46 * hackage hspec-wai 0.9.1 - Experimental Hspec support for testing WAI applications  http://hackage.haskell.org/package/hspec-wai-0.9.1 (SimonHengel)
16:07:57 <iqubic> So I have this snippet from my .cabal file. https://paste.pound-python.org/show/AYLDfFULFztFQwWAEwYC/
16:08:31 <iqubic> However, I can't get a repl going. running "stack ghci" gives me issues. https://paste.pound-python.org/show/ZFCcYjWavib2YuMXHhsg/
16:09:19 <iqubic> Anyone know what's going on here?
16:09:28 <sclv> If the package isn’t in the stackage snapshot you also need to add it to your stack.yaml
16:09:48 <iqubic> Is there a way to update my stackage snapshot?
16:09:56 <sclv> This is why using stack is more confusing for newbs than cabal, sigh
16:10:12 <sclv> There may be no snapshot with that pkg?
16:10:31 <sclv> Stackage only has a small portion of hackage
16:10:36 <iqubic> I'm trying to add recursion-schemes as a dep.
16:10:40 <sclv> You need to specify other things manually
16:10:41 <sclv> Yes
16:11:24 <sclv> hm: it appears to be in stackage?
16:11:24 <MarcelineVQ> recursion-schemes is on stackage. And this error doesn't say anything about snapshots or pkg db's.
16:11:26 <sclv> https://www.stackage.org/lts-13.0/package/recursion-schemes-5.1
16:11:27 <iqubic> Also, see this: https://www.stackage.org/package/recursion-schemes
16:12:00 <iqubic> So what is the error? Am I getting this error because I am trying to use Stack on Nixos?
16:12:28 <sclv> i think the "Build failed, but trying to launch GHCi anyway"  is the big hint
16:12:33 <ACheesyName> nixos lol
16:12:48 <MarcelineVQ> possibly, what did google say?
16:12:56 <iqubic> I didn't google this yet.
16:14:33 <sclv> this is a bit mysterious to me as a non nixos user sorry
16:15:00 <sclv> its obviously expecting something to be available in some location that isn't
16:15:09 <sclv> my own advice is just to use cabal and run cabal new-repl instead
16:15:09 <iqubic> right.
16:15:31 <iqubic> sclv: how would that help me?
16:15:46 <sclv> because stack is doing something weird
16:15:48 <sclv> and cabal might not
16:15:49 <sclv> idk
16:15:59 <sclv> stack and nixos is a weird combo
16:16:23 <sclv> there's a well established haskell nix workflow like https://github.com/Gabriel439/haskell-nix
16:16:48 <sclv> and that's not the new- stuff either, tbh. but its the "complex but solid" nix  story
16:16:55 <sclv> the lightweight one should be able to be cabal new- or stack
16:17:10 <sclv> if you strace or something and see what file is trying to be launched you could maybe guess what's going on, idk
16:18:08 <iqubic> At some point I should go through and read this guide here: https://github.com/Gabriel439/haskell-nix
16:19:17 <iqubic> And then I should convert my current project to using nix instead of stack.
16:27:54 * hackage hspec-wai-json 0.9.1 - Testing JSON APIs with hspec-wai  http://hackage.haskell.org/package/hspec-wai-json-0.9.1 (SimonHengel)
17:21:04 --- mode: glguy set +v sososasa
17:23:39 <sososasa> ?wiki monad
17:23:39 <lambdabot> https://wiki.haskell.org/monad
17:25:36 --- mode: glguy set +v sososasa
17:31:23 --- mode: glguy set +v sososasa
17:38:37 <sososasa> Dear Haskell users, I am learning this language (it has been three weeks) and am doing practice problems(codingbat) currently. Can anyone take a look at my code and see if I can do any better?
17:38:44 <sososasa> https://github.com/samanShresthaRay/codingbat/blob/master/Solutions.hs
17:43:37 <aplainzetakind> sososasa: 9 `elem` a gives False with [] for a anyway.
17:45:57 <sososasa> So contains9 [] = False line is redundant right?
17:46:05 <aplainzetakind> Yes.
17:46:06 <Solonarv> Yup
17:46:23 <aplainzetakind> show('x')
17:46:30 <aplainzetakind> Parentheses redundant.
17:46:38 <aplainzetakind> "x" is much better.
17:47:03 <Solonarv> > show 'x'
17:47:05 <lambdabot>  "'x'"
17:47:13 <Solonarv> > "x" -- not the same thing!
17:47:14 <lambdabot>  "x"
17:47:42 <aplainzetakind> Oh.
17:47:46 <aplainzetakind> Yes.
17:47:47 <sososasa> which line are you looking at?
17:47:55 <Solonarv> 31
17:48:11 <sososasa> OK\
17:48:11 <Solonarv> lots of redundant parentheses in that line, actually
17:48:51 <aplainzetakind> I'm not sure what that function is doing, so, is "'x'" intended then?
17:48:51 <Solonarv> parentheses are not part of function-call syntax in Haskell
17:49:16 <sososasa> Hold on I am going back to question
17:50:08 <sososasa> The question says this:
17:50:10 <sososasa> Given a string, return a version where all the "x" have been removed. Except an "x" at the very start or end should not be removed.
17:50:25 <sososasa> stringX("xxHxix") → "xHix"
17:50:36 <sososasa> stringX("abxxxcd") → "abcd"
17:50:44 <sososasa> stringX("xabxxxcdx") → "xabcdx"
17:51:20 <aplainzetakind> I see. Then you probably don't want `show 'x'` anyway, no?
17:52:08 <sososasa> Can you tell me how i can concatenate the "x" without show?
17:52:24 <Solonarv> you just write "x" instead of show 'x'
17:52:26 <Solonarv> That's it
17:52:52 <sososasa> Ok. Hold on.
17:53:40 <aplainzetakind> next function: instead of foldr (++) [], you can just use concat. Actually for the whole line just say concatMap flatten as
17:54:31 <sososasa> Ok I am making changes
17:59:11 <[Leary]> @let stringX :: [Char] -> [Char]; stringX y@(a:as) | head(y) == 'x' || last(y) == 'x' = "x" ++ stringX (tail(init(y))) ++ "x" | otherwise = filter (/= 'x') y
17:59:12 <lambdabot>  Defined.
17:59:18 <[Leary]> > stringX ""
17:59:20 <lambdabot>  "*Exception: /tmp/mueval22594-0.hs:(162,1)-(165,33): Non-exhaustive patterns...
17:59:23 <[Leary]> > stringX "x"
17:59:25 <lambdabot>  "x*Exception: Prelude.tail: empty list
17:59:28 <[Leary]> > stringX "xa"
17:59:30 <lambdabot>  "x*Exception: /tmp/mueval22636-0.hs:(162,1)-(165,33): Non-exhaustive pattern...
17:59:33 <[Leary]> > stringX "bx"
17:59:35 <lambdabot>  "x*Exception: /tmp/mueval22657-0.hs:(162,1)-(165,33): Non-exhaustive pattern...
17:59:40 <[Leary]> > stringX "xxxx"
17:59:42 <lambdabot>  "xx*Exception: /tmp/mueval22678-0.hs:(162,1)-(165,33): Non-exhaustive patter...
17:59:55 <[Leary]> Seem to be some problems with this implementation.
18:00:39 <aplainzetakind> sososasa: compress' doesn't know what to do with an empty list or a 1 element list. Since it is recursive it will hit those eventually.
18:01:32 --- mode: glguy set +v sososasa
18:01:37 <libertyprime> Hey guys. Is there an easy way to get runhaskell to print out the line of the script being executed?
18:02:03 <libertyprime> I'm after something like "bash -v".
18:02:47 <sososasa> Is there a performance hit if we do "anyString" ++ "anyString" ++ "anyString" ++ .... ?
18:02:52 <Solonarv> No, because Haskell isn't executed line by line
18:03:06 <Solonarv> sososasa: yes, but you probably shouldn't worry about that yet
18:03:22 <libertyprime> Solonary: hmm yes that was very naive question of me. I am also noob
18:03:25 <sososasa> All in due time i guess
18:03:40 <Solonarv> Your code isn't even correct yet, focus on that first
18:04:04 <sososasa> which line are you looking at?
18:04:40 <Solonarv> No one line in particular. What [Leary] and aplainzetakind brought up are examples of what I mean.
18:05:05 <Solonarv> I'm too sleepy to do more than throw out off-hand remarks, sorry :P
18:05:19 <sososasa> Thats all right
18:05:50 <sososasa> and this irc reset on me for some reason so I have to come back again :(
18:06:32 <sososasa> and I cannot see anything past the "concatMap flatten as" comment
18:06:51 <Solonarv> oh, duh
18:07:34 <sososasa> I may have to remember your names next time we meet lol
18:08:21 <aplainzetakind> There is a link to the logs in the topic.
18:08:30 <aplainzetakind> You can go see what you missed.
18:08:57 <sososasa> Yes I am lookign at it now
18:09:00 <sososasa> looking
18:09:14 <Solonarv> oh, I forgot we actually have logs here
18:11:05 <aplainzetakind> What is this codingbat?
18:11:24 <sososasa> https://codingbat.com/java
18:11:45 <sososasa> they give you problems questions to solve
18:12:02 <Solonarv> uh, I'd suggest finding a set of problems that's written for Haskell.
18:12:19 <aplainzetakind> 99 Haskell problems is a good set.
18:13:13 <julianleviston> or hackerrank
18:13:18 <Solonarv> You could also use a Haskell course or book, the good ones all have exercises along the way
18:13:43 <sososasa> Total noob here so I got discouraged when I saw their solutions
18:14:02 <sososasa> but I initially did go to 99 haskell problems
18:14:15 <Solonarv> I'm going to guess that you'll learn better with an actual, you know, learning resource
18:14:27 <Solonarv> instead of just getting exercises thrown at you
18:14:33 <Solonarv> @where cis194
18:14:33 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
18:14:44 <aplainzetakind> ^
18:14:45 <Solonarv> ^ this one is recommended in here fairly often
18:14:53 <Solonarv> other options:
18:14:58 <Solonarv> @where wikibook
18:14:58 <lambdabot> http://en.wikibooks.org/wiki/Haskell
18:15:04 <Solonarv> @where pih
18:15:04 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
18:15:15 <Solonarv> ^ if you want an actual book
18:16:03 <aplainzetakind> cis914 is great, but the lecture notes are very brief so you'd need to supplement it with some reading.
18:17:16 --- mode: glguy set +v sososasa_
18:19:52 <Solonarv> sososasa_: welcome back! you might want to check the logs again, there are a bunch of learning resources
18:20:11 <Solonarv> (that were posted while you were disconnected)
18:21:07 <sososasa_> Yes, but before I leave codingbat can you please help me on this stringX and compress' problems?
18:21:27 <sososasa_> Leaving this knowing that I have errors just doesnt feel right....
18:22:18 <aplainzetakind> Well, isn't compress' just a variant of compress?
18:22:30 <aplainzetakind> It seems to be doing the same thing.
18:22:38 <Solonarv> stringX almost works, you just didn't specify what it should return if the input is empty
18:23:24 <sososasa_> Yup, compress' needs to be deleted
18:24:25 <sososasa_> and for stringX, i did this:      | y == [ ] = [ ]
18:24:40 <sososasa_> but its still showing me non exhaustive if I pass empty string
18:24:46 <Solonarv> That doesn't work, no
18:24:56 <aplainzetakind> I would just write `compress'' = map head . group` if you want variety.
18:26:04 <Solonarv> stringX will try to match its argument against the pattern 'a:as'; the guards associated with that pattern are only tried if the pattern matches
18:26:52 <ACheesyName> data State = StateA Integer Integer | StateB String String <-- is there a way to make the Integer and String fields into records so they can be looked up and updated by name
18:27:10 <ACheesyName> or can it only be done with two helper types?
18:27:14 <sososasa_> Oh I see. No need for y@(a:as) at all. 
18:27:21 <Solonarv> Sure, just use record syntax ACheesyName
18:27:39 <amalloy> yeah, each constructor can be a record independent of the others
18:27:56 <geekosaur> the pattern match is better. just add a pattern for [] instead of the guard
18:28:15 <Solonarv> ACheesyName: Although I wouldn't recommend doing that, because it's a way for runtime exceptions to sneak into your program
18:28:42 <aplainzetakind> sososasa_: I think your first guard would turn an input of "x" into "xx" (supposing the empty list is handled).
18:30:08 <sososasa_> Looks like it is throwing exception saying: *** Exception: Prelude.tail: empty list
18:30:19 <aplainzetakind> Yes you have that too.
18:31:04 <aplainzetakind> tail and init are unsafe, and throw exceptions on empty lists, so using them in shrinking recursive definitions will almost surely cause trouble.
18:31:41 <aplainzetakind> I would reverse the rest of the list and pattern match against that I think.
18:32:34 <aplainzetakind> Something like stringX (a:as) | x == 'x' = case reverse as of ('x':as') -> ...
18:34:51 --- mode: glguy set +v sososasa
18:35:06 <sososasa> Ok that helps and now I will not bother with codingbat for haskell
18:35:51 <sososasa> Thank you Solonarv, aplainzetakind, [Leary]
18:37:07 <Solonarv> sososasa: also, I'd recommend setting up a bouncer so you don't miss any conversation when your internet dies
18:39:40 <aplainzetakind> Solonarv: that requires a vps or something right?
18:40:14 <sososasa> any irc app you recommend for Linux?
18:40:21 <aplainzetakind> irssi
18:40:46 <sososasa> OK
18:40:50 <Solonarv> aplainzetakind: not necessarily, there are some bouncer services that handle the hosting for you
18:41:16 <Solonarv> It's been a while since I looked into them, so I couldn't say what they are
18:43:29 <aplainzetakind> Solonarv: hm, found some. good.
18:44:30 <notzmv> weechat is pretty nice
18:44:54 <Solonarv> I mean, obviously if you have any kind of server already you can easily toss an IRC bouncer on it
18:45:50 <Solonarv> I switched to Quassel a bit ago
18:46:03 <Solonarv> (from thunderbird xd)
18:54:33 --- mode: glguy set +v functionalcoder1
18:55:03 <functionalcoder1> !palomer
19:38:20 * hackage serverless-haskell 0.8.5 - Deploying Haskell code onto AWS Lambda using Serverless  http://hackage.haskell.org/package/serverless-haskell-0.8.5 (AlexeyKotlyarov)
20:02:52 <iqubic> 12. It has 12 people
20:29:06 <ACheesyName> https://repl.it/repls/LonelyMediumpurplePhp <-- is there a way to write f that will actually use the record field extractors bar and baz?
20:31:18 <ACheesyName> nvm fixed but it's strange
20:32:55 <[Leary]> You can make bar and baz the same accessor.
22:52:28 <danso> if haskell were redesigned today, would functional dependencies be the default? 
22:53:29 <danso> for example, how often is it useful that you can write a polymorphic function that can have type Int -> String or type Int -> Char
22:56:39 <geekosaur> that argument's still ongoing, I think
22:57:07 <geekosaur> most of the theory wonks prefer associated type families to fundeps
23:03:16 <c_wraith> from the perspective of actually using them, I really prefer fundeps
23:04:39 <c_wraith> maybe when dependent haskell gets real functions at the type level, they'll be less awkward than type families
23:11:02 <iqubic> So cabal configure is failing: http://dpaste.com/2ZMXSMP
23:11:58 <iqubic> Here's the relevent part of my cabal file: http://dpaste.com/38PKRS0
23:12:59 <iqubic> Anyone know what's going on here?
23:13:51 <[Leary]> Probably: you haven't made recursion-schemes available via nix, and cabal doesn't know it's on hackage because you've never run cabal update.
23:14:19 <iqubic> I mean, I'm running Nixos, and trying to get nix and haskell to play well together
23:15:47 <iqubic> [Leary]: One: I have a shell.nix that tells nix that recursion-schemes is a thing that exists. Two: I am able to run "nix-shell" Three: I have just run cabal update.
23:15:55 <iqubic> Four: It still isn't working.
23:16:12 <iqubic> shell.nix: http://dpaste.com/1A4X081
23:16:30 <iqubic> math.nix: http://dpaste.com/0352RS2
23:16:57 <iqubic> Those two files together tell nix that I am relying on recursion-schemes.
23:17:04 <iqubic> But it isn't working at all.
23:18:00 <[Leary]> The shell.nix looks like it should be your default.nix, the .env attribute of which you should use for the shell.
23:18:26 <iqubic> Oh, yeah.. my bad. That actually is a default.nix
23:19:10 <iqubic> So how should I call "nix-shell" to get stuff to work properly?
23:19:57 <[Leary]> You might be able to do nix-shell -A env, I'm not sure if that will work.
23:20:40 <iqubic> Yeah, that works.
23:20:48 <iqubic> Why do I need to run it like that?
23:22:03 <[Leary]> As I said before, the shell needs to use the env attribute of the derivation. Your default.nix is for doing nix build, nix shell is just silly enough to fall back on it.
23:22:17 <iqubic> Oh, I see.
23:23:01 <iqubic> So I bet this would work better if I just create a shell.nix with the exact same contents.
23:23:26 <[Leary]> It can just be (import ./.).env
23:23:27 <iqubic> And I wouldn't need the -A env.
23:23:36 <iqubic> Oh, really. Cool
23:39:36 <coldpress> argh why doesn't Parsec have a comment lexer :( it only has a whiteSpace lexer
23:47:29 <amalloy> coldpress: are you using Text.Parsec.Token, or what? 
23:48:25 <coldpress> Text.ParserCombinators.Parsec.Language (emptyDef)
