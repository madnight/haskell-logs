00:14:12 <savolla> I wanted to download #haskell log and its 341 MB ? geez
00:15:56 <suzu> well it is an old channel, lol
00:16:15 <suzu> i bet that log compresses reeeal well tho
00:16:18 <suzu> it is all english text
00:16:20 <suzu> :P
00:58:47 <tsahyt> I need to map an effectful function over nodes in an fgl graph, but can't find any means to do so? am I out of luck here?
00:59:19 <[exa]> "fgl" ?
00:59:28 <[exa]> oh I see
01:00:16 <tsahyt> what I'd need would be something like nmapM :: (a -> m b) -> gr a c -> m (gr b c)
01:00:40 <tsahyt> with a DynGraph gr constraint, presumably
01:02:10 <[exa]> in what order would you want the nodes traversed?
01:04:07 <tsahyt> order doesn't matter for me. the function I'm mapping is something along the lines of (MonadError e m, MonadRandom m) => a -> m b.
01:04:57 <tsahyt> I suppose the most straightforward way to do it would be to just traverse the underlying IntMap
01:05:33 <[exa]> well the order is important because the monadic operation could then produce different results on apparently same graphs
01:06:03 <[exa]> which is probably the cause of not including it into the library
01:06:18 <tsahyt> I guess that's a good enough reason
01:06:40 <tsahyt> in my specific case, all orders are acceptable. at least I can't think of a reason why I'd prefer one over the other
01:07:11 <[exa]> if there's something that pulls the nodes in a reasonable order (topo ordering?) you can probably do some of that using contextM or so
01:10:25 <[exa]> I mean, you can monadically pre-generate a list of random values (or whatever you need for the transform) and then apply that using nmap
01:11:44 <coldpress> is there some catch for aoc12 part 2?
01:12:31 <tsahyt> mhm. I still tend towards just using the underlying intmap representation and mapping over that
01:13:50 <tsahyt> type GraphRep a b = IntMap (Context' a b), should be easy enough to map over the a here
01:14:10 <tsahyt> it doesn't export the Gr constructor though
01:31:12 <tsahyt> alga doesn't seem to support this either
01:32:28 --- mode: glguy set +v Darwin226
01:32:45 <Darwin226> Hey, if I have a question about typechecker plugin development, is this the right channel to ask?
01:33:13 <merijn> Darwin226: Sure, although you might get better answers in #ghc
01:33:25 <Darwin226> Ok, I'll try here first
01:33:54 <tsahyt> [exa]: I guess my best option that doesn't involve unsafeCoerce would be to do a topological sort, recover the labels into a [(Node, label)], traverse the resulting list on the second tuple element, then rebuild the graph, since the edges haven't changed
01:34:59 <tsahyt> that way I have one well defined order too
01:57:52 <coldpress> coldpress: got it
02:03:14 * hackage LParse 0.2.3.0 - A continuation-based parser library  http://hackage.haskell.org/package/LParse-0.2.3.0 (Sacchan)
02:04:44 <Darwin226> So I want to write a typechecker plugin that when it sees two specific constraints (lets say (Show a, Show b)), adds an additional constraint (a ~ b)
02:04:49 <Darwin226> is this possible?
02:05:12 <Darwin226> I don't want to solve the Show constraints, I just want to put a new one into the system and tell the compiler to try and solve it
02:11:24 <[exa]> Darwin226: so basically you'd require that all showable arguments of an abstraction are more or less the same type?
02:11:34 <[exa]> (why?)
02:12:21 <Darwin226> [exa]: Show was just an example. The actual case is more convoluted
02:13:02 <merijn> Darwin226: Also, you might want to email ghc-devs mailing list, since there will be more active readers who can answer questions
02:14:19 <Darwin226> merijn: Uh.. I've never emailed a mailing list before.
02:14:46 <Darwin226> I'll try #ghc first
02:16:03 <merijn> Darwin226: It's literally the same as mailing a normal email address :p
02:34:44 * hackage hwormhole 0.2.0.0 - magic-wormhole client  http://hackage.haskell.org/package/hwormhole-0.2.0.0 (rkrishnan)
02:41:33 --- mode: glguy set +v mreh
02:42:01 --- mode: glguy set -v mreh
02:45:15 * hackage BiobaseEnsembl 0.1.0.0 - Ensembl related datastructures and functions  http://hackage.haskell.org/package/BiobaseEnsembl-0.1.0.0 (FlorianEggenhofer)
02:53:28 --- mode: glguy set +v Flyers
02:53:41 --- mode: glguy set -v Flyers
02:58:25 --- mode: glguy set -v Darwin226
03:08:47 * hackage proteome 0.3.6.0 - neovim project manager  http://hackage.haskell.org/package/proteome-0.3.6.0 (tek)
03:39:11 --- mode: glguy set +v hoppfull
03:39:25 --- mode: glguy set -v hoppfull
03:56:29 <hoppfull> Hello, just installed Stack on windows, ran "stack new" to create a new project. Ran "stack setup" inside the project and everything seemed to go well. Then when running "stack build" produces an error that I can't seem to solve: "<command-line>:0:14: error: lexical error (UTF-8 decoding error)" I have no idea what this is.
03:56:57 --- mode: ChanServ set +o glguy
03:57:17 <hoppfull> At first I thought it was the รถ in my console on line 0, column 14 but then I moved to another folder and ran "stack build" again with the same result. Does anyone have a clue what this is?
03:57:49 <merijn> hoppfull: Sounds like mismatch between the encoding stack is *guessing* is used by your shell and the actual encoding
03:58:49 <Ariakenom> it has to guess?
03:59:08 <Ariakenom> isn't there an environment variable or something?
03:59:56 <hoppfull> merijn, thank you, I will see if this is the problem.
04:00:07 <merijn> Ariakenom: That environment variable can be wrong
04:00:13 <Putonlalla> It might have something to do with the default encoding in the Windows command line being CP-1252.
04:00:15 <merijn> Ariakenom: And often is on linux distros
04:00:18 <Putonlalla> At least that used to be the case.
04:01:08 <Ariakenom> of course it is ...
04:02:41 <hoppfull> I've played with haskell and stack before and never had this issue.
04:02:57 <hoppfull> On a different computer but on windows 10.
04:03:06 <hoppfull> Same as I have now.
04:03:26 --- mode: ChanServ set +o glguy
04:04:29 <merijn> Check if the files in your project are all actually valid utf-8?
04:08:37 <hoppfull> VS code says they are. I've tried resaving them as utf-8.
04:09:34 <hoppfull> Oh. Well.
04:17:39 <hoppfull> Hmm, interesting. Looks like I missed that I got an error when running stack setup.
04:45:14 <hoppfull> Alright, a short but intense adventure with Haskell. Thanks for your help.
04:49:03 <reygoch> Is there some formal notion of "Projection" (this is what I call it). Essentially, sometimes I have to "project" objects into some vector space to do for example some clustering. After that I need to be able to revert values back to their original form. At the moment, I'm doing this in my own way with `Projector a b = Projector ( a -> b )` and `Projection a b = Projection a b`.
04:49:38 <reygoch> This seems like something relatively common so I'd like to know if there are some more powerful concepts that can be applied for this purpose.
04:50:33 <merijn> reygoch: Maybe Profunctor?
04:52:08 <reygoch> merijn: will check out
05:06:04 <infinisil> reygoch: Sounds a bit like lenses
05:06:18 <infinisil> Isometric lenses
05:09:05 <infinisil> See the bottom half of http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Iso.html
05:10:52 <reygoch> infinisil: thanks, that looks like what I want
05:30:29 <thblt> Hello! I'm toying with the idea of driving a Javascript-based UI in Electron from Haskell code.  Basically, from the Haskell side all I need to do is to maintain a persistent, bilateral connexion to the javascript side, maintain global state somewhere, and have both sides talk together with JSON (and bridging JSON messages to Haskell functions transforming the global state, with access to IO).  Is there an Haskell lib I could look into
05:30:30 <thblt> for that? Thanks!
05:46:04 <dmwit> I don't know enough about websockets to confidently recommend them for this, but it seems like the kind of thing other people seem to reach for when they describe situations like yours.
05:47:59 <dmwit> Maybe... 40% certain that you will choose them in the end given that you know about them.
05:49:19 <tdammers> if you need full duplex, then websockets. if you can suffice with a request/response paradigm, just use HTTP (AJAX)
05:58:29 <thblt> dmwit: tdammers: thanks!
06:06:29 <dmwit> thblt: You should let us know what you end up deciding on so I can mark my prediction correct or not. ;-)
06:37:17 * hackage hasbolt 0.1.3.2 - Haskell driver for Neo4j 3+ (BOLT protocol)  http://hackage.haskell.org/package/hasbolt-0.1.3.2 (zmactep)
06:37:54 <thblt> Actually it seems electron supports regular sockets, so there's no actual need to use web-somethings.  I'm looking into the various ipc/rpc packages available for both electron and Haskell
06:42:22 <sshine> thblt, with "Javascript-based UI", do you mean one that runs in a browser, or one that runs in a more privileged browser-based sandbox?
06:44:56 <thblt> sshine: I'm planning to use Electron, which falls under the latter case. 
06:52:14 * hackage ihs 0.1.0.3 - Interpolated Haskell  http://hackage.haskell.org/package/ihs-0.1.0.3 (minad)
07:59:32 <Boarders> if I am using the builder type here: http://hackage.haskell.org/package/text-show-3.7.5/docs/TextShow.html#t:Builder
07:59:54 <Boarders> and I do an unconc operation by converting to string and re-converting the tail to Builder, will that be horribly inefficient?
08:00:20 <Boarders> I want to perform some sort of takeWhile or dropWhile operation with a Builder type but I don't know the best approach
08:04:47 <bahamas> hello. does anyone know if there is a magical pretty-printing library that provides a type class I could just derive in my types and have the types printed with indentation? I'm trying to print an AST
08:05:38 <dminuoso> bahamas: There's something close: pretty-simple
08:05:51 <lyxia> bahamas: what about pretty-show
08:06:01 <lyxia> it's an overlay on top of show
08:06:09 --- mode: glguy set +v Chorhizo
08:07:13 <Ariakenom> Boarders: I guess you may have to read source if you wanna know
08:08:17 <Chorhizo> Hey guys. Trying to create a 2d array, I need O(1) access to elements by index as I'm trying to average neighbours of all elements. I've seen Linear.V2 could be used, or maybe just Data.Vector? I'm planning on just mapping the computation, should be super easy to parallelise for huge matrices?
08:08:45 <Chorhizo> I was kind of surprised to find it hard to find information on this, perhaps I'm just looking in the wrong place.
08:09:06 <bahamas> dminuoso: lyxia. thanks! I'll have a look
08:09:15 <infinisil> Chorhizo: Use the vector package
08:09:25 <infinisil> ?hackage vector
08:09:25 <lambdabot> http://hackage.haskell.org/package/vector
08:09:33 <Ariakenom> Boarders: It makes intuitive sense that only some "spine" of the lazy text gets changed and only 1 chunk of characters gets copied
08:09:42 <Ariakenom> but I really don't know
08:10:00 <Chorhizo> infinisil: great, thanks.
08:10:07 <Boarders> I thought so too but I'm not sure
08:11:23 <mizu_no_oto> Chorhizo: if you know the size of the array, you could also just use Data.Array
08:13:40 <Chorhizo> mizu_no_oto: I do know the size, would Data.Array have the constructs to split up and parallelise it easily?
08:14:14 * hackage haskell-names 0.9.5 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.9.5 (AlexandrRuchkin)
08:15:01 <infinisil> Chorhizo: i think standard haskell parallelization methods should work for both of those
08:15:36 <infinisil> For the immutable variants at least
08:16:02 <merijn> If you want performance you'll probably want Vector over Array
08:16:09 <merijn> Assuming you don't need complex indexing
08:16:19 <merijn> Ah, that was already mentioned...
08:16:26 <Boarders> Chorhizo: http://hackage.haskell.org/package/parallel-3.2.2.0/docs/Control-Parallel-Strategies.html
08:16:31 <Chorhizo> infinisil: ok, great. I'll be honest I have no idea what those methods are, but I'll google about and report back if I get super stuck.
08:16:50 <Boarders> you probably don't want to actually "split" things up as it is quite tricky to make sure you are using all threads efficiently 
08:17:08 <Boarders> it's worth having a look at this module and using something like parmap
08:17:19 <Chorhizo> Boarders: cheers, merijn: don't need complex indexing, literally just averaging neighbours to each element for now (one up,down,left, right)
08:17:39 <Chorhizo> Boarders: that sounds perfect
08:17:45 * hackage twitch 0.1.7.2 - A high level file watcher DSL  http://hackage.haskell.org/package/twitch-0.1.7.2 (AndreasSchacker)
08:18:15 <infinisil> Chorhizo: https://wiki.haskell.org/Parallelism
08:19:14 <infinisil> ?hackage parallel
08:19:14 <lambdabot> http://hackage.haskell.org/package/parallel
08:19:29 <infinisil> This library specifically ^^
08:27:16 <the_2nd> what are currently suggested FRP libs? Searching for it mostly yields old articles / wiki entries, making it hard to evaluate the current situation
08:28:57 <bahamas> is there any way I can use a git dependency with cabal?
08:32:23 <merijn> bahamas: If you use new-build/v2-build, yes
08:38:18 <bahamas> merijn: I do. what's the syntax? I can't find anything in the docs about this. I'm looking here: https://www.haskell.org/cabal/users-guide/nix-local-build.html#local-versus-external-packages
08:40:16 <merijn> bahamas: https://github.com/merijn/GPU-benchmarks/blob/master/cabal.project#L3-L7
08:40:24 <the_2nd> is new-build etc. a replacement for old cabal or stack as well? Or is stack still 'on top' of new-cabal ?
08:40:25 <merijn> bahamas: Not sure if docs have been updated to include it, tbh
08:40:41 <merijn> the_2nd: stack is on top of Cabal (the library) and will forever be
08:40:57 <merijn> the_2nd: cabal-install (the commandline executable) is *also* build on top of Cabal (the library)
08:41:29 <merijn> the_2nd: new-build is the (near future) replacement of the "build" command of cabal-install
08:42:32 <the_2nd> and does one use new-build with stack or is it meant to replace it?
08:43:32 <bahamas> merijn: thanks. and in the *.cabal file you list the dependency as `persistent-sqlite`, i.e. the value of subdir?
08:43:44 <merijn> the_2nd: It's unrelated to stack and whether you consider it "meant to replace it" depends on your interpretation
08:43:45 <bahamas> the_2nd: you use it without stack
08:44:01 <merijn> bahamas: You list it as whatever the cabal package in the repo is named :)
08:44:25 <merijn> bahamas: The subdirectory part is only because some repos (for example persistent) include multiple packages per repo
08:44:37 <bahamas> merijn: ah, ok. so I can ommit it
08:45:42 <merijn> bahamas: Basically, the repo entry makes that repo a "local" package and the new-build solver will always pick local packages over packages from hackage
08:48:08 <bahamas> merijn: I added the package and after running `cabal new-repl`, I get `NoCabalFileFound`. does that mean the project needs a cabal file?
08:48:28 <bahamas> it doesn't have one, because it uses stack
08:48:39 <merijn> bahamas: The git dependency, you mean?
08:50:51 <bahamas> yes
08:51:15 <merijn> bahamas: Yes, because without a Cabal file how is it supposed to know how to build it?
08:53:20 <bahamas> merijn: you're right. fortunately, it has a package.yaml, so I just went to the cloned dir and generated one
08:55:07 <sm> ok enough floundering.. how could I adjust  take 5 $ iterate f 0  after changing f to an IO function ?
08:55:50 <sm> I tried sequence $ take 3 $ iterate (>>= f) (pure 0), which is not correct
08:56:39 <merijn> sm: >>= takes an "m a" as input, not an "a"
08:56:57 <merijn> oh, wait, you have pure so that should work
08:57:01 <sm> yes the above compiles, it's just wrong
08:57:13 <aplainzetakind> Why not just fmap?
08:57:23 <merijn> sm: Wrong how?
08:57:57 <sm> it's sort of like scanl, it returns [0 applications, 1 application, 2 applications, ...]
08:57:58 <merijn> oh, actually
08:58:04 <sm> if that makes any sense
08:58:05 <aplainzetakind> Scratch that.
08:58:07 <merijn> sm: Yeah, I was about to say
08:58:13 <merijn> sm: It does make sense, think about it
08:58:22 <sm> argh my head
08:58:42 <sm> I'm trying to solve aoc part 2, must conserve brain cells :)
08:58:44 <merijn> sm: >>= creates a new action from a previous one and a function
08:58:46 <sm> but I agree
08:58:51 <merijn> sm: The first element will be >>=f applied once
08:58:52 <geekosaur> doesnt this run into strictness of (>>=) though? in particular in IO
08:59:00 <nshepperd1> That'll run the io action multiple times with the sequence
08:59:08 <aplainzetakind> (foldl (>=>) pure $ repeat 3 f) 0
08:59:14 <merijn> sm: The next element will be the first IO action composed with >>= f *again*
08:59:23 <merijn> sm: So you're repeating all previous actions at every step
08:59:38 <sm> I know
08:59:50 <merijn> You probably want to manually foldM, or use
08:59:53 <merijn> @hackage monad-loops
08:59:53 <lambdabot> http://hackage.haskell.org/package/monad-loops
09:00:01 * sm peers at aplainzetakind's thing
09:00:11 <sm> oh, good idea
09:00:33 <sm> hehe my "little" aoc scripts are pulling in half of hackage
09:00:34 <merijn> sm: monad-loops probably contains every loop you've ever wanted :p
09:00:43 <shiona_> I've been thinking that there ought to be iterateM_
09:00:53 <shiona_> now I know where it is
09:01:04 <sm> shiona_: yes that's exactly what I was looking for/trying to make.. ditto
09:01:23 <sm> I hoogled for iteratem but didn't find this
09:02:13 <sm> (it was there, I missed it). Added to my new list of goto libs, thanks!
09:03:44 <sm> would http://hackage.haskell.org/package/loops-0.2.0.2/docs/Control-Monad-Loop.html#v:iterate and while also do it ? can't quite tell
09:03:56 <merijn> sm: Hoogle doesn't index all Hackage libraries, sadly
09:04:29 <sm> I use https://hoogle.haskell.org 
09:13:46 <__monty__> I want to apply a function to a list then the tail of that list then the tail of the tail, etc. Does this sound like a familiar function? Or should I just map f (scanl (flip drop xs) [1..length xs - 1]?
09:13:57 <glguy> :t tails
09:13:58 <lambdabot> [a] -> [[a]]
09:14:02 <hololeap> is anyone here familiar with Travis CI and Nix? i'm trying to help out https://github.com/reflex-frp/reflex with their CI testing, but i don't know how to proceed at this point. this is the failing job in question: https://travis-ci.org/reflex-frp/reflex/jobs/467094483
09:14:49 <nshepperd> :t \n f x -> evalStateT (replicateM n (do { x0 <- get; x1 <- lift (f x0); put x1; return x1 })) x
09:14:51 <lambdabot> Monad m => Int -> (a -> m a) -> a -> m [a]
09:15:19 <hololeap> monoidal-containers is listed in their default.nix, as you can see here: https://github.com/reflex-frp/reflex/blob/develop/default.nix
09:15:54 <__monty__> glguy++
09:15:58 <Chorhizo> This might be a stupid question, but if I want to map a function that requires the index of the element it's working on in a 2d array, do I need to create some zip function so I have ((x,y), elem)?
09:17:24 <hololeap> Chorhizo: there are different ways to do that, but yeah the index needs to be available to the function somehow
09:17:40 <simendsjo> I'm looking to parse a simple DSL entered by the user. It's a single line without much syntax (similar to org-mode date prompt). The parsers I'm finding is very heavyweight -- are there any parsers with very few dependencies for such simple use-cases?
09:17:52 <sm> those monad-loops operators are tricky. I found the right one for my case: g <- iterateUntilM (const False) (nextgen rules) g0
09:18:23 <sm> g <- iterateUntilM ((<21).fst) (nextgen rules) g0, rather
09:20:09 <Chorhizo> hololeap: thought so, thanks.
09:23:34 <hololeap> Chorhizo: it's a bit of an advanced topic, but you might want to look into how to use comonads, especially the store comonad in this case.
09:24:04 <hololeap> but the overhead of learning about comonads might be too high if you have a deadline
09:24:45 <Chorhizo> hololeap: that sounds a little over my head right now, there is no deadline -- this is just for my own fun. I'll try with a basic zip first and read about that later :)
09:25:52 <Chorhizo> I am surprised though, I would expect haskell to be good for some graphical processing, where stuff like this is very common, I wonder if there is not a more elegant solution
09:29:30 <hololeap> Chorhizo: the "default" practice problem is to implement conway's game of life using Control.Comonad.Store (from the comonad package). this blog post may be helpful: https://bartoszmilewski.com/2017/01/02/comonads/
09:30:33 <hololeap> Chorhizo: also, i've never done much with graphical processing myself, but GPipe-GLFW seems pretty interesting
09:31:19 <hololeap> http://tobbebex.blogspot.com/2015/09/gpu-programming-in-haskell-using-gpipe.html
09:32:02 <Chorhizo> hololeap: comonads do sound perfect for that, especially with his description ' if you want to think of a comonad as a container, it always comes pre-filled with contents, and it lets you peek at it.'
09:40:11 <bsima> what does everyone use for SQL libraries? I've always used persistent but I'm wondering what else is good
09:44:18 <hololeap> bsima: i found beam to be really good: http://tathougies.github.io/beam/
09:45:21 <bsima> hololeap: thanks, i was going to use that but needed MySQL support, but looks like I'll be switching to Postgres for this project after all
09:45:26 <bsima> what do you like about beam?
09:46:49 <bsima> i think my biggest gripe with persistent right now is that afaict i can't add module docs to the schema descriptions
09:46:57 <bsima> because it's all template haskell
09:47:17 <bsima> i need docs because i forget why i wrote some code >.<
09:47:37 <bsima> (by module docs I mean haddocks)
09:49:32 <hololeap> beam allows you to write data types that can function like "normal" data types and also be insertable into a database, which is really helpful if you need to build up data for different tables using the same document
09:49:39 <hololeap> also, it doesn't use template haskell
09:50:22 <hololeap> it does use some advanced type-level features and has a learning curve though
09:50:57 <bsima> i think i can handle the learning curve, my rate of learning has been increasing lately
09:51:07 <bsima> still have much to learn but i'm able to hack my way thru this stuff now 
09:53:26 <bsima> the beam query language does look nice. Even looks better than esqueleto
09:54:23 <hololeap> bsima: i would go through the tutorial on the page i linked. there is also a rough translation to using the postgres backend here: https://github.com/jacobono/beam-postgres-tutorial
09:55:26 <bsima> okay I'll do that, thanks hololeap
09:55:43 <bsima> have you run into any limitations with beam?
09:57:13 <hololeap> not really, but i'm far from SQL proficient. the biggest problem i ran into was the learning curve and using new (to me) language extensions
09:59:07 <bsima> yeah this type signature is crazy http://tathougies.github.io/beam/user-guide/queries/relationships/#many-to-many
10:00:56 <hololeap> i wouldn't worry about the type signatures too much. they don't come up that often. once you work through the tutorial and get a working example it will become clear as to what is practical knowledge and what is just implementation details
10:01:13 <bsima> ok
10:01:49 <hololeap> also, the docs seem like a bit of a WIP in places (thankfully not too many places)
10:12:26 <bsima> hololeap: aren't all docs like that :)
10:28:07 <dgpratt> from here http://oleg.fi/gists/posts/2018-12-12-find-correct-laws.html there is a mathematical definition of a lens that looks like this: Lens S A = โC,SโCรA -- can someone give me an interpretation of this definition?
10:29:07 <dgpratt> one of the things I struggle with in interpreting this sort of thing is not even knowing what is the assumed precedence of various symbols
10:29:20 <mnoonan> "having a lens from S to A means you can split an S into an A and some other junk"
10:29:33 <koz_> jle` has a blogpost on this very topic as well.
10:29:57 <koz_> dgpratt: https://blog.jle.im/entry/lenses-products-prisms-sums.html
10:30:17 <koz_> You might wanna read that as a companion piece.
10:30:22 <koz_> It'll help you make more sense of it all.
10:30:36 <dgpratt> ok, I can kind of see the sense of that interpretation, thanks mnoonan , koz_ 
10:32:03 <dgpratt> so the definition part might be read something like "there exists some C such that S is approximately equal to the pair of C and A"?
10:32:26 <lyxia> equivalent to the product of C a nd A
10:32:35 <koz_> Isomorphic I think.
10:32:36 <phadej> isomorphic*
10:32:38 <dgpratt> ah, ok
10:32:40 <phadej> (comments noted)
10:32:44 * hackage hsdev 0.3.2.3 - Haskell development library  http://hackage.haskell.org/package/hsdev-0.3.2.3 (AlexandrRuchkin)
10:32:46 <koz_> phadej: What soda do you want, lol. :P
10:33:17 <phadej> isomorphic and equivalence isn't the same thing (it's even mentioned in the blog post, in the conclusion, keep reading ;)
10:34:55 <phadej> isomorphism means you an go back and forth, and roundtrip makes you arrive at the same thing
10:35:05 <phadej> e.g. (Char, Bool) and (Bool, Char) are isomorphic
10:35:27 <phadej> equivalence means than you can go back an forth, but roundtrip make put you in the different place
10:35:45 <phadej> e.g. Either Char Char and Char are equivalent (logically speaking), but not isomorphic
10:39:39 <phadej> otoh, those usage make differ, e.g. https://en.wikipedia.org/wiki/Homotopy_type_theory uses equivalence (though I think it should use isomorphism)
10:39:50 <phadej> ... in describing univalence axiom
10:39:51 <dgpratt> A big part of the challenge for me in understanding such things as that definition is to get my programmer brain to _think_ more mathematically. To me, the definition of "Lens" looks like a function of "S" and "A" that will presumably yield some useful value. But in this case, I think it's more the point of what that definition says about "S" and "A"...maybe. And then there's the whole "exists" concept...My brain wants to ask
10:39:51 <dgpratt> "Exists...where exactly? How do we know? How do we find it?".
10:40:53 <bsima> does anything exist? is this irc channel real?
10:41:22 <phadej> dgpratt: existentials are mind twisting, I agree
10:41:47 <phadej> and Lens is a function, type level function, it yields a type :)
10:42:21 <phadej> type Pair a = (a,a) -- an ordinary Haskell example
10:42:43 <koz_> dgpratt: Nobody cares _how_, as long as you can prove it does.
10:42:53 <koz_> Mathematics doesn't concern itself with construction most of the time.
10:43:06 <dgpratt> yeah, I've been exposed to such concepts before, but they don't come readily to mind when I need them
10:43:58 <koz_> A good example was when we were shown a pure existence proof of a context-free language.
10:44:14 <koz_> The proof didn't in any way whatsoever describe what that language looked like - merely showing that it _must_ exist.
10:44:35 <phadej> though, in that post the existenetials are constructive
10:44:45 <phadej> I try to explain what they actually are
10:45:34 <phadej> ... e.g. when lens is contructed from getter :: s -> a and setter :: s -> a -> s
10:48:13 <phadej> the mind twisting thing with existentials is that you _can_ extract them from constructive constructions, but you have treat than uniformly, and as there are no type equality decision procedure (e.g. you cannot ask if some type `a` is a Maybe and get a Boolean back - the parametricity stuff), you can't really do anything with it
10:48:22 <phadej> it's there, but essentially opaque
10:49:02 <koz_> C.f. GADTs.
10:49:20 <koz_> (I think)
10:49:36 <phadej> well, gadt's "store" the evidence of type-equality
10:50:06 <koz_> So not quite.
10:50:06 <phadej> data G a where MkG :: G Int  ~~  data G a = MkG (a :~: Int)
10:50:30 <phadej> and there's ways to represent :~: without GADTs (http://hackage.haskell.org/package/eq, not as handy though)
10:51:01 <phadej> the compiler does a lot of plumbing for us with GADTs
10:51:24 <koz_> I guess a better example would be the 'CPS-style' functions for fixed-length vectors, like this one: http://hackage.haskell.org/package/vector-sized-1.0.4.0/docs/Data-Vector-Sized.html#v:withSizedList
10:51:52 <koz_> In this case, 'n' could be 'whatever', and we have to deal with each possible 'whatever' in the function.
10:51:57 <phadej> yes, to consume "existential" you have to provide "universal" function :)
10:54:45 <phadej> playing with exists and forall quantifiers in some proof assistant (e.g. Coq) might help to build the untuition, e.g. logical foundations https://softwarefoundations.cis.upenn.edu/lf-current/Logic.html#lab177 (6th chapter, so probably not the shortest route)
10:55:31 <koz_> I would also encourage reading Mordechai Ben Ari's 'Logic for Computer Scientists'. It takes a while to get to this stuff, but the basics it gives you are really good, and computationally focused.
10:56:28 <phadej> yes, whatever works for you, reading books, playing with computers, watching lectures ...
11:06:36 <bsima> drawing and writing about math concepts in real paper notebooks helps me learn, fwiw
11:07:39 <koz_> Agreed with bsima.
11:14:44 * hackage dotenv 0.8.0.0 - Loads environment variables from dotenv files  http://hackage.haskell.org/package/dotenv-0.8.0.0 (camm)
11:18:14 * hackage recursion 2.1.0.0 - A recursion schemes library for GHC.  http://hackage.haskell.org/package/recursion-2.1.0.0 (vmchale)
11:23:24 <phadej> well, the notation is indeed optimised for hand writing ;)
11:31:55 <amalloy> phadej: briefly skimming that i thought you said "hand waving". optimised for hand-waving does sorta describe do-notation for IO
11:49:44 * hackage Fin 0.2.5.1 - Finite totally-ordered sets  http://hackage.haskell.org/package/Fin-0.2.5.1 (MatthewFarkasDyck)
11:49:53 <monochrom> Cognitively the act of getting your hand involved opens a second channelof engagement. (Speaking aloud also works, same reason.)
11:50:20 <monochrom> Turing-machinely the paper/board you write on is your unlimited tape.
11:50:31 <geekosaur> see also rubber duck debugging
11:51:10 <geekosaur> (anything that guides you to organize your thoughts, really)
11:51:14 <monochrom> I talk to myself all the time. It spices up my conversations.
11:51:23 <koz_> monochrom: Glad to hear I'm not the only one.
11:51:32 <koz_> I'm known to monologue on Haskell things when hiking in the woods. :P
11:51:51 * hackage Fin 0.2.6.1 - Finite totally-ordered sets  http://hackage.haskell.org/package/Fin-0.2.6.1 (MatthewFarkasDyck)
11:52:25 <monochrom> Many of us do.  I just love to throw in "it spices up my conversations" to tie the knot. >:)
11:53:28 <geekosaur> monohabaรฑero
11:54:12 <koz_> geekosaur: Is that 'if Snoyman made seasonings'?
11:54:40 <geekosaur> no, it's spicy monochrom >.>
11:54:46 <monochrom> haha
11:55:15 <koz_> Wouldn't that be 'polychrom'?
11:56:07 <geekosaur> no, and especially not if he's talking to himself >.>
11:56:39 <monochrom> monochrโm
11:56:54 <koz_> Oooh, dat spicy Unicode.
12:20:01 <Younder> coq has a new logic on homotopy type theory called HoTT
12:20:28 <Younder> I say this in remembrance of Vladimir Voevodsky a brilliant mathematician who died before his time. This is his legacy.
12:20:48 <Younder> Homtopy type theory, the univalent theorem and a program at Princeton Institute of Advanced Study for continuing it.
12:23:09 --- mode: glguy set +v noname__
12:24:22 <rain1> Younder: can you give a link?
12:24:30 <rain1> to see about this
12:33:41 <Younder> rain1, http://homotopytypetheory.org/
12:34:03 <Younder> also https://github.com/HoTT/HoTT
13:22:32 <dexterfoo> Why does Haskell syntax need the "lambda" symbol? why can't we parse this:  map (x -> x + 1) [1,2,3]
13:24:19 <c_wraith> arbitrary backtracking hurts. not the computer so much, but it sure hurts a human to read.
13:25:25 <c_wraith> remember, a lambda can bind arbitrarily many arguments
13:25:32 <geekosaur> you have to be able to tell the difference between an expression and a pattern. without \ to switch to pattern context, you don't know which you have until you get to the ->
13:26:46 <c_wraith> Haskell's grammar was mostly not designed with computer parsing in mind. it's not even context-free!
13:27:00 <dexterfoo> i'm (trying to) make a small language similar to haskell. so if there is no pattern matching, then it should be ok to use the lambda syntax without the leading lambda char?
13:27:57 <c_wraith> but Haskell's grammar is mostly good at preventing human readers from needing to backtrack to parse it.
13:28:04 <geekosaur> and it can be a full pattern, not just a simple binding. plus things like, as an expression `Just x` is fine, as patterns `Just x` is two patterns
13:28:12 <geekosaur> c_wraith, wel, until ghc started extending it
13:28:25 <c_wraith> ... mostly.
13:29:09 <c_wraith> infix pattern matching still gets me most of the time.
13:30:39 <c_wraith> dexterfoo, for your language, do what you like. if for no other reason than to just try it and see what you like and don't like.
13:31:01 <c_wraith> dexterfoo, as long as you don't have a giant base of code you need to keep working, you can change the syntax around.
13:43:09 <aplainzetakind> Is it even possible to do aoc part 2 today with code? I did it "manually".
13:43:40 <Has_lisp> Hello, I'm trying to decide what language to learn between common lisp or haskell. I know that i'm asking this in haskell room so it will be baised but i need guidance. So why one and not another.
13:43:42 <Superhanz> is it bad that quite a few of my functions have 3 parameters
13:43:51 <Has_lisp> sorry if this question is not good.
13:44:03 <Superhanz> learn lisp
13:44:08 <glguy> Superhanz: no, that's fine
13:44:31 <Superhanz> I feel that instaed of programming functionally, I am just circumventing this by passing lots of parameters
13:45:03 <Superhanz> like if one function needs something from another function, whereas in imperative I'd just reference some variable, I'm instead just passing it 
13:45:06 <glguy> aplainzetakind: Does "with code" mean iteratively computing all 50e9 generations?
13:45:50 <Has_lisp> ok sorry for the question
13:45:52 <aplainzetakind> Well, I don't know how to clarify what I mean without massive spoilers.
13:45:52 <MarcelineVQ> why not both? You could even learn haskell then write your own lisp with it
13:46:57 <Superhanz> it doesn't really matter what you learn right?
13:47:05 <Superhanz> because so many skills are just transferable
13:47:59 <geekosaur> each one teaches different things
13:48:51 <Has_lisp> but people says both lisp and haskell are very different language from all the other languages out there. So i thought maybe i should learn one of them
13:49:17 <geekosaur> some are transferable, btu for example lisp doesn't give you laziness and haskell doesn't give you a form of untyped lambda calculus
13:49:29 <glguy> If you're going to learn a lisp maybe pick something in modern development like Racket
13:49:40 <glguy> Learning Haskell will give you a chance to learn more interesting things about types
13:50:15 <Has_lisp> ok
13:51:16 * hackage BiobaseHTTP 1.1.0 - Libary to interface with the Bioinformatics HTTP services - Entrez Ensembl  http://hackage.haskell.org/package/BiobaseHTTP-1.1.0 (FlorianEggenhofer)
13:55:05 <dexterfoo> Has_lisp: i think that used to be true for lisp up until about a decade ago. the popular modern dynamicly typed languages (python, javascript...) have the main features that used to make lisp special (dynamic typing, high order functions, garbage collection). they lack macros and some other advanced lisp stuff (and of they are generally used in an imperative rather than functional style). but if you already
13:55:08 <dexterfoo> have experience in one of the popular dynamicly typed programming languages, then i would say that haskell has a lot more to teach you
13:55:55 <ldlework> Chicken Scheme is another lisp I recommend
13:55:58 <ldlework> or Common Lisp
13:56:49 <ldlework> Has_lisp: I think that learning lisp is not nearly as hard as learning haskell as lisp has a very simple grammar relatively speaking.
13:57:10 <ldlework> (but haskell is way more interestsing)
13:57:39 <amalloy> aplainzetakind: i'm pretty sure you can't do 5e10 squared operations in any reasonable amount of time
13:57:57 <glguy> amalloy: why squared?
13:58:52 <amalloy> well, maybe it's squared over 2? because for each of N things, you have to do 5e10/2 iterations on it, right?
13:59:04 <amalloy> on average
13:59:47 <glguy> No, it's just 5e10 generations, but it doesn't take longer to compute each generation
14:00:19 <amalloy> it should, shouldn't it? since the area you need to cover is growing
14:00:32 <aplainzetakind> glguy: the diameter of each generation is greater
14:00:34 <glguy> Yeah, if it was growing then it would take longer
14:00:44 <aplainzetakind> -potentially-
14:00:45 <amalloy> i see, i think
14:00:54 <CodeKiwi> The various write you a scheme in 48 hours are enjoyable 
14:01:38 <amalloy> i haven't done part 2 yet myself. glguy, if i understand correctly you're hinting at sparseness?
14:09:20 <glguy> My program would finish part2 in pretty close to 2 days (3000 minutes) if I let it run and that's withnot being very careful with how I represent the garden ( just using [] type)
14:12:44 <__monty__> glguy: So you haven't solved it yet?
14:12:56 <glguy> I didn't say that
14:14:45 * hackage confetti 1.0.0 - A simple config file swapping tool  http://hackage.haskell.org/package/confetti-1.0.0 (aviaviavi)
14:14:46 <c_wraith> sounds to me like a change in plan is required.
14:16:33 <glguy> My actual program runs quickly, I was just trying to say that it's feasible to write a program that just computes all 50 billion generations
14:21:44 <int-e> Hmm what is part 2?
14:23:59 --- mode: glguy set +v cyjiao_
14:31:16 --- mode: glguy set -j
14:32:09 --- mode: glguy set +j 3:5
14:46:51 <dmj`> is it absolutely impossible to make a field with the name "data"
14:47:06 <glguy> yeah
14:47:23 <dmj`> ugh
14:48:10 <dmj`> trying to use Generics for something, the implementation doesn't allow for changing the field labels
14:51:28 <glguy> You'll just have to want to do something differently, you can't even sneak it through TH any more :)
14:51:52 <glguy> >>> (:[]) <$> dataD (cxt []) (mkName "T") [] Nothing [recC (mkName "C") [varBangType (mkName "data") (bangType (bang noSourceUnpackedness noSourceStrictness) [t| Int |])]] [];
14:51:52 <glguy> <interactive>:24:1: error:    Illegal variable name: โdataโ    When splicing a TH declaration: data T = C {data :: GHC.Types.Int}
15:02:00 <dmj`> ugh, could write my own typeclass I guess, that modifies the field name, was hoping not to have to do that. Maybe just vanilla functions for now
15:25:11 * bsima really likes the 'brittany' code formatter
15:26:22 <sm> nice.. ghcid + doctest: ghcid -c 'stack ghci 12.hs' -T':!doctest 12.hs'
15:36:08 <lavalike> sm: intriguing
15:38:33 <sm> and ghcid -c 'stack ghci 12.hs' -T main  to run your main of course
15:38:57 <sm> -T x runs ghci command :x. But with the ! you need the leading : first
15:39:03 <sm> in bash anyway
15:39:47 <lavalike> -T'...' seems to be enough for a simple ghci-based ghcid instance (no stack)
15:41:49 <sm> oh sure, it works without stack
15:42:10 <sm> for a non-stack project
15:42:14 <lavalike> lovely
15:42:26 <lavalike> I needed an excuse to try out doctest
15:42:34 <sm> I do it that way just so ghcid sees my stack installed libs
15:42:45 <sm> glguy turned me on to it for aoc
15:42:53 <sm> it has its uses
15:45:03 <glguy> Yeah, it works great to do: ghcid --command=cabal\ v2-repl\ whatever
15:45:04 * hackage BiobaseFasta 0.2.0.0 - streaming FASTA parser  http://hackage.haskell.org/package/BiobaseFasta-0.2.0.0 (ChristianHoener)
15:56:43 <sm> and for anything ghcid doesn't handle, there's always entr: ls 12.hs | entr bash -c 'do; crazy; stuff; on; change'
16:35:19 <jackdk> sm I didn't know about entr; that's cool
16:46:52 <zachk> whats entr?
16:47:09 <hpc> basically a bash frontend to inotify
16:58:46 <sm> entr is the most usable/portable of the cli tools that do actions when files change
16:59:08 <sm> it's very handy for quick live feedback loops
16:59:19 * hackage test-lib 0.2 - A library to make a quick test-runner script.  http://hackage.haskell.org/package/test-lib-0.2 (IavorDiatchki)
16:59:46 <sm> I'll plug a third tool in this vein: livereloadx, reloads stuff in your browser when files change
16:59:46 <Welkin> do you have a link?
17:00:00 <Welkin> it's not the most searchable term
17:00:20 <sm> hmm.. apparently not
17:00:27 <sm> I thought it was entrproject.org
17:00:58 <sm> http://eradman.com/entrproject/
17:11:32 <glguy> % (1,2) {first = 10}
17:11:32 <yahb> glguy: (10,2); (0.03 secs, 154,424 bytes)
17:11:39 <glguy> % (1,2) {second = 20}
17:11:39 <yahb> glguy: (1,20); (0.02 secs, 154,424 bytes)
17:12:08 <Welkin> what
17:12:19 <Welkin> what is that?
17:12:32 <glguy> Just updating my tuples with some record notation
17:12:42 <Welkin> is that a ghc extension?
17:12:44 <jle`>  :set +s
17:12:48 <jle`> in ghci
17:12:51 <Welkin> no
17:12:58 <Welkin> I mean the record update notation for tuples
17:13:13 <jle`> you can make custom abstract records using pattern synonyms
17:13:18 <jle`> i suspect that's what happened here
17:13:41 <jle`> % pattern T2 { forst = x, socond = y } = (x, y)
17:13:42 <yahb> jle`: ; <interactive>:518:20: error:; parse error on input `='; Perhaps you need a 'let' in a 'do' block?; e.g. 'let x = 5' instead of 'x = 5'; (0.00 secs,)
17:13:59 <jle`> :(
17:14:01 <glguy> pattern Tuple2 { first, second } = (first, second)
17:14:05 <jle`> ah
17:14:19 <jle`> % pattern T2 { forst, socond } = (forst, socond)
17:14:19 <yahb> jle`: (0.01 secs, 0 bytes)
17:14:26 <jle`> % (1,2) { forst = 10 }
17:14:27 <yahb> jle`: (10,2); (0.03 secs, 154,424 bytes)
17:14:40 <glguy> % forst ('a','b')
17:14:40 <yahb> glguy: 'a'; (0.01 secs, 151,776 bytes)
17:14:53 <jle`> sorry for ruining the magic, if that was your intetion :)
17:15:28 <glguy> I wasn't going to keep it a secret :)
17:15:55 <jle`> in practice i think i've only used this to label fields in pattern synonyms
17:16:03 <jle`> record modifier syntax is already kind of clunky
17:16:15 <jle`> so it's weird to me to manually subject yourself to it
17:16:19 <jle`> the main reason i use record syntax is for layouting
17:17:43 <glguy> I'm not as down on records as a lot of other people seem to be
17:21:02 <mniip> wait what
17:21:06 <mniip> what extension is this
17:26:59 <geekosaur> pattern synonyms?
17:27:36 <jle`> yeah, ghc since 8.4 or something has had records in pattern synonyms
17:27:59 <jle`> but i remembe rwhen tehy first came out, haddock support was very bad (not haddock's fault, the export syntax/mechanisms were clunky too)
17:28:04 <jle`> so i didn't really lean into it that much
17:33:34 <aplainzetakind> I have a parser of type ParsecT Void T.Text (St.State (M.Map T.Text Int)) () which puts the content of matching lines in a map which counts their occurences. This works with toy inputs, but I want to run this over a large (5.5G) file. Testing in ghci in the hopeless manner of `(execState . runParsecT blahblah) <$> readFile "file"` of course gave me a segfault. How do I incrementally/lazily process 
17:33:40 <aplainzetakind> the file, and do I have to add an IO layer to the ParsecT stack to do it?
17:36:21 <mniip> % pattern Ex :: () => forall a. a -> (); pattern Ex x <- x where Ex _ = ()
17:36:21 <yahb> mniip: (0.02 secs, 0 bytes)
17:36:42 <mniip> % pattern Ex' { ex } = Ex ex
17:36:42 <yahb> mniip: (0.00 secs, 0 bytes)
17:36:46 <mniip> % :t ex
17:36:46 <yahb> mniip: ; <interactive>:1:1: error:; * Cannot use record selector `ex' as a function due to escaped type variables; Probable fix: use pattern-matching syntax instead; * In the expression: ex
17:37:05 <mniip> % :t \a b -> a { ex = b }
17:37:06 <yahb> mniip: ; <interactive>:1:9: error:; * Record update for insufficiently polymorphic field: ex :: a; * In the expression: a {ex = b}; In the expression: \ a b -> a {ex = b}
17:37:34 <geekosaur> aplainzetakind, I think this kind of lazy parsing is best done with conduit / pipes? simple lazy I/O doesn't work so well here
17:37:51 <geekosaur> which is a large reason why conduit and pipes exist
17:38:15 <mniip> I don't see why this doesn't work though
17:38:31 <geekosaur> and both have adapters for parsec / megaparsec and attoparsec
17:38:37 <monochrom> aplainzetakind: Maybe the only reason you're taking so much space is merely because insert x1 (insert x2 (insert x3 (insert x4 (...  staying unevaluated so you don't have a map you have a huge chain.
17:39:29 <geekosaur> could be that as well. or ghci being unoptimized so it's wasting a lot more memory than a compiled-with-optimization program would
17:39:48 <aplainzetakind> monochrom: I don't know for certain but I don't think there'll be too many enries in the map.
17:40:05 <Welkin> what about berts to go with those ernies?
17:40:08 <monochrom> And after you solve that, the next one along the same line will be a huge unevaluated 0+1+1+1+1+...
17:40:18 <aplainzetakind> geekosaur: I don't even know what they are actually, I'll look them up.
17:40:37 <monochrom> aplainzetakind, it totally does not depend on the number of entries.  Only the number of times you modify the map.
17:41:04 <aplainzetakind> monochrom: ah I misunderstood, of course.
17:42:35 <aplainzetakind> How does Text.pack work? It can lazily pass the input through right?
17:44:00 <geekosaur> Txt isn't very lazy
17:44:50 <geekosaur> there is a lazy Text type but it does it by breaking a single Text into a lazy list of largeish chunks
17:45:03 <geekosaur> (same for lazy ByteString)
17:45:29 <monochrom> Yeah both ByteString.Lazy and Text.Lazy are like at 64KB chunks granularity level of lazy.
17:45:56 <monochrom> Fortunately it's close enough to O(1) on computers since 1990.
17:46:00 <aplainzetakind> Because the thing I fmap over readFile does pass the input through that. Could it be waiting to load the entire thing?
17:46:11 <monochrom> Would totally overwhelm a PDP-11 though
17:46:49 <monochrom> There are like 5 different "readFile"s.
17:47:05 <monochrom> Make it 6.
17:48:04 * hackage unix-time 0.4.0 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.4.0 (KazuYamamoto)
17:51:21 <dmwit> monochrom: Prelude, {lazy,strict} {bytestring,text}, what's number 6?
17:51:47 <monochrom> There is a strict-io library
17:51:58 <dmwit> nice!
17:52:12 <monochrom> Because some people really hate laziness.  QED.
18:04:33 <aplainzetakind> I switched to Text.Lazy and it seems to be running in almost constant memory.
18:10:32 <davean> monochrom: so, interleaved IO is a bit nasty as a default IMO
18:12:41 <monochrom> But reading the whole file into memory at once is the other nasty default.
18:13:59 <geekosaur> and now you're seeing why conduit and pipes. but neither is quite as "simple"
18:15:01 <geekosaur> theres kinda no winning here; people have been trying to come up with nice solutions ever since Oleg introduced left-fold enumerators
18:16:18 <aplainzetakind> It 'seemed' constant for a while but then ramped up and eventually got killed. I'll learn what conduit is.
18:44:57 <inkbottle> > ((=<< id) . ((flip . ((.) .)) .) . (.)) (,) (+1) 2 3 -- Haskell made obvious
18:45:00 <lambdabot>  (3,4)
18:45:45 <monochrom> Who wrote that?!
18:46:47 <marvin2> @pl (\x y -> (x+1,y+1)) 2 3
18:46:47 <lambdabot> (3, 4)
18:46:50 <marvin2> @pl (\x y -> (x+1,y+1))
18:46:50 <lambdabot> (. (1 +)) . (,) . (1 +)
18:47:05 <inkbottle> almost
18:47:59 <inkbottle> @pl (\f x y -> (f 1,f 1))
18:47:59 <lambdabot> const . const . liftM2 (,) ($ 1) ($ 1)
18:48:27 <inkbottle> @pl (\f x y -> (f x,f y))
18:48:27 <lambdabot> flip =<< (((.) . (,)) .)
18:49:29 <inkbottle> Anyway, was half funny the first time
18:49:49 <monochrom> Yes, no dispute on that.
18:50:07 <inkbottle> ;-)
18:52:20 <mniip> @pl (\f g x y) -> f (g x) (g y)
18:52:20 <lambdabot> (line 1, column 10):
18:52:20 <lambdabot> unexpected ")"
18:52:20 <lambdabot> expecting pattern or "->"
18:52:25 <mniip> @pl \f g x y -> f (g x) (g y)
18:52:25 <lambdabot> join . ((flip . ((.) .)) .) . (.)
19:28:05 <bwi88888> }k
19:28:32 <bwi88888> w
19:30:23 <geekosaur> hrm
19:33:44 --- mode: cherryh.freenode.net set +o Sigyn
19:57:05 * hackage hw-ip 1.0.0.0 - Library for manipulating IP addresses and CIDR blocks  http://hackage.haskell.org/package/hw-ip-1.0.0.0 (haskellworks)
20:21:04 * hackage sensu-run 0.6.1 - A tool to send command execution results to Sensu  http://hackage.haskell.org/package/sensu-run-0.6.1 (MitsutoshiAoe)
22:15:23 <maerwald> so it seems wreq doesn't use openssl under the hood, but a haskell implementation?
22:35:33 <Arahael> maerwald: Thank goodness. ;)
22:40:29 <maerwald> Arahael: why? That would be quite bad
22:45:20 <Arahael> maerwald: OpenSSL has become somewhat awkward, it's no-longer the obviously best choice.
22:46:04 <maerwald> Haskell as an implementation language for low-level cryptographiy is quite dangerous, since there are a lot of unanswered questions as to how it behaves in security context
22:46:14 <maerwald> But I'm not sure that is actually the case
22:47:00 <nshepperd> i'd be a little worried about using some not-widely-used or homegrown library
22:50:10 <cocreature> a significant portion of the Haskell ecosystem uses the Haskell tls lib instead of openssl
22:50:26 <dminuoso> Which I consider highly problematic.
22:50:27 <nshepperd> and i've got no idea how you prevent side channels (timing etc) in pure haskell
22:50:56 <cocreature> right, Iโm not saying that this is a good thing, just stating that wreq isnโt alone here by any mean
22:52:48 <dminuoso> nshepperd: There's too many side channel attacks you dont have good answers for in Haskell. For most crypto paths you have to completely disable optimizations, consider very very carefully what STG code is generated, and then very carefully disable/control optimization on the codegen stage..
22:53:05 <dminuoso> And even then you will have a hard time emitting cryptographically strong assembly.
22:53:19 <dminuoso> And that's just from a codegen perspective alone.
23:28:19 <quchen> Got an algorithmic problem. Iโm implementing it in Haskell, but itโs not a Haskell problem. The channel seems quiet, sooo
23:29:19 <quchen> Iโve got a point in 2D (x, y), and a set of obstacles, also points. Iโd like to find a line starting at (x,y), extending to infinity, that avoids the obstacles.
23:30:10 <quchen> Avoiding means that it definitely does not intersect any of the obstacles, but for numerical reasons Iโd like it to be ยปquite farยซ from each of the points.
23:30:50 <quchen> In other words, youโre scared alone in the forest and want to run into the direction where the least trees are.
23:30:52 <dminuoso> quchen: The obstacles, are these just isolated points or do they form some polygons?
23:31:01 <quchen> Just isolated points.
23:31:42 <quchen> Ideally, this would work with the points being rational, but Doubles are fine too for now.
23:33:16 <quchen> dminuoso: This came up when I wanted to check whether a point is inside a polygon โ easy enough, cast a ray from infinity, and check how many edges it intersects; odd -> point is inside, even -> point is outside.
23:33:42 <quchen> Problem: when your ray just so happens to go exactly through a corner, that may register as 0-2 edge intersections, because of numerical instabilities.
23:33:42 <dminuoso> quchen: Heh yeah, it kind of reminded me of a hackathon I was on..
23:33:50 <dminuoso> Is this still related? 
23:34:19 <dminuoso> quchen: Your problem seems too trivial, there must be something Im missing.
23:34:39 <dminuoso> Do you need a perfect solution? Or are you looking for something approximate?
23:35:26 <quchen> dminuoso: Check whether a point is inside a polygon, thatโs the problem.
23:35:27 <dminuoso> If you took a random obstacle, consider a line - and then take the angle to all other obstacles, sort - take the largest angle and draw a line right half way through the angle - that seems like a trivial approach.
23:35:37 <dminuoso> Given your originally presented problem
23:36:06 <dminuoso> Oh well, there's one intermediate step missing but well.
23:36:40 <Lears> It might be simpler to form and use a convex decomposition of the polygon.
23:36:57 <quchen> As in triangulation?
23:37:18 <quchen> dminuoso: That would be quadratic, no?
23:37:31 <dminuoso> quchen: Mmm no it should be linear.
23:39:08 <Lears> Into triangles sure, or whatever else you fancy. The only part that matters is that point-inclusion gets real simple once the polygons get convex.
23:39:54 <quchen> As long as theyโre triangles, at least. For arbitrary convex polygons Iโm not sure itโs that easy (compared to arbitrary polygons).
23:40:21 <quchen> But for triangulation you have to know whether a point is inside a polygon, I think, so I canโt triangulate.
23:41:42 <quchen> dminuoso: Alright, so youโre picking a random obstacle, find the obstacle next to it (by angle), and go between the two with your solution line?
23:42:17 <quchen> dminuoso: That wonโt work if your obstacles are colinear with respect to the starting point
23:42:18 <dminuoso> quchen: You calculate all angles, sort by angle, then compute consecutive differences between angles
23:43:00 <dminuoso> quchen: If *all* of them are, yes it wont.
23:43:15 <quchen> Ah, okay. Yes, that should work, itโs my current draft.
23:44:02 <quchen> Problem is, it requires angles. Iโd like to be as Rational as possible (for ivory tower reasons). And now Iโm out of ideas.
23:44:26 <quchen> Comparing angles without trigonometry (and square roots) is an interesting challenge.
23:45:13 <quchen> dminuoso: Iโll try to get the algorithm to work. But itโs reassuring that thereโs not some ยปoh just use Harryโs algorithmยซ solution here.
23:46:09 <quchen> dminuoso: Itโs surprising how little discussion there is about numerical instabilities in geometry online. Everyone just shows the happy path. (By the way, polygon cutting still doesnโt work โ better, but not good)
23:47:27 <quchen> dminuoso: And all of this started because I wanted to print Munihac stickers! >:-|
23:59:49 <dminuoso> quchen: Remind me, how does polygon shenanigans relate to printing munihac stickers again?
