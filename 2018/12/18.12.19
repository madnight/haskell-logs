00:00:00 <bahamas> I found an open issue
00:08:40 <suzu> whats the cryptographic library of choice for haskell?
00:08:42 <suzu> saltine?
00:09:29 <suzu> looking to encrypt data with a symmetric key and also verify its integrity ofc
00:10:00 <MarcelineVQ> I hear Crypto most often but don't actually know
00:10:29 <MarcelineVQ> that's clearly out of date though, maybe I have the name wrong, you should probably ignore me
00:10:53 <suzu> this is too low-level and requires me to do some lifting myself and probably get it wrong
00:10:55 <MarcelineVQ> oh cryptonite
00:11:06 <rkrishnan> suzu: saltine is a library around the libsodium. If you are interested in more lower level cryptography primitives, please take a look at cryptonite.
00:11:11 <MarcelineVQ> that's what I was thinking of
00:11:22 <dminuoso> 09:08           suzu | whats the cryptographic library of choice for haskell?
00:11:26 <dminuoso> suzu: What exactly do you want to do?
00:11:36 <dminuoso> crypto implemented in Haskell is likely to be notoriously unsafe
00:11:39 <suzu> encrypt a file and store it with somebody i don't trust
00:11:55 <suzu> so i need symmetric encryption and also HMAC capability
00:12:08 <suzu> and probably salting/noncing
00:12:16 <suzu> afaict saltine looks like what i want
00:12:38 <suzu> but was wondering if it has been superseded by something or if i am looking in the wrong place
00:14:08 <trcc> So I am close to having an initial version of my first open source haskell project. As it is my first project, I would love some feedback. Any good ideas on how to got about this?
00:14:15 <trcc> go*
00:14:17 <suzu> put it on github
00:14:23 <suzu> post on reddit asking for some eyes
00:14:29 <suzu> and here too
00:15:34 <dmwit> trcc: I don't think they're into complete projects, but there's a code review StackExchange that would be open to a couple paragraphs-worth of code.
00:16:09 <dminuoso> trcc: You could also ask on the haskell mailing list.
00:16:28 <trcc> dmwit dminuoso thanks for input!
00:16:29 <suzu> a bit off-topic, but has anybody used Backblaze B2 object storage here?
00:18:05 <suzu> pm if so please. having weird problems with it or am maybe doing something wrong in hs-land
00:26:51 <DigitalKiwi> post it to HN you'll get tons of feedback
00:28:44 <suzu> lol dont do that
00:29:15 <suzu> at least -- it is my personal opinion that is not necessarily a good fit
00:32:18 <koz_> I would also suggest not posting there.
00:36:53 <bahamas> has anyone installed ghc-mod with cabal recently? I get a base conflict when running cabal new-install ghc-mod
00:40:07 <maerwald> bahamas: https://github.com/DanielG/ghc-mod/issues/835
00:40:47 <suzu> is there a Eff '[SIO] type?
00:41:42 <suzu> maybe i can decompose IO into a safe io with EitherT SomeException IO a?
00:43:13 <bahamas> maerwald: I get the same problem if I use install instead of new-install
00:43:43 <suzu> i'm trying to move from MaybeT IO a, to simply an IO a and treat "Nothing" values as exceptional
00:45:20 <suzu> i suppose i can write `MonadThrow m => Maybe a -> m a` and use that to unpeel the Maybe
00:47:12 <bahamas> so this is the essential line: rejecting: base-4.12.0.0/installed-4.1... (conflict: ghc-mod =>
00:47:15 <bahamas> base<4.10 && >=4.6.0.1)
00:48:18 --- mode: glguy set +v Mknz
00:49:02 <bahamas> I see the problem. latest release of ghc-mod was in 2017
00:50:06 <suzu> what are you installing ghc-mod for?
00:51:25 <bahamas> suzu: to get a better development experience
00:53:29 <unsymbol> is there a way to exclude modules from the test coverage calculation using stack test --coverage?
00:53:53 <koz_> bahamas: I would not recommend ghc-mod for a better development experience.
00:54:00 <koz_> As you are, no doubt, now experiencing.
00:54:11 <rfold> I want to execute some code when a major GC happens (this code can be in a separate process, that's fine), and the solution I came up with is to use +RTS -B and observe when the program prints an ASCII BEL. I'd like to know if this is fragile and if there's a better way of doing this.
00:54:26 <bahamas> koz_: what do you recommend? I already tried to setup haskell-ide but I didn't get very far
00:54:33 <koz_> bahamas: What's your editor?
00:54:41 <bahamas> koz_: well, either neovim or vs code
00:54:44 <koz_> I have a happy setup on ALE for Neovim.
00:54:52 <koz_> Using GHC (as in, the compiler) and HLint.
00:54:54 <koz_> (and nothing else)
00:54:58 <bahamas> koz_: can you share it?
00:55:01 <koz_> One sec.
00:55:30 <koz_> http://ix.io/1wm8
00:55:32 <suzu> if you are using emacs, intero is incredible
00:55:33 <suzu> well okay idk about incredible. but it is very nice
00:55:38 <bahamas> just keep in mind, I don't have much experience with configuring (neo)vim, so it would help to have step-by-step instructions
00:55:41 <koz_> Disclaimer: I use new-* with cabal and not stack.
00:55:50 <koz_> bahamas: OK, this is a project-local .nvimrc.
00:56:18 <koz_> For my full init.vim: http://ix.io/1wm9
00:56:23 <koz_> Not all of this will be relevant to you.
00:56:42 <koz_> (specifically, Nofrils is a very religious choice which you may well not agree with)
00:57:29 <koz_> bahamas: Feel free to PM me if some/all of this makes no sense, and I'd be happy to assist.
00:58:03 <Ariakenom_> rfold: nice :D
00:59:37 <bahamas> koz_: ok. this is an improvement. at least I see feedback in the editor
00:59:41 <bahamas> thanks for the help
00:59:50 <koz_> bahamas: No worries! Let me know if you need further assistance.
01:00:05 <koz_> I admit I had to do a bit of a hackeroo to get the Alexis King options, because ALE is...special.
01:00:31 <koz_> You may also not want to use hindent for auto-indenting your code (again, another rather religious choice on my part).
01:00:48 <koz_> This is _especially_ because some more recent extensions confuse the hell out of it.
01:00:56 <koz_> (DerivingVia, I'm looking at you)
01:02:54 <bahamas> koz_: btw, do you use a particular syntax file for haskell. mine just highlights a few things: strings, ints, and a few keywords
01:03:18 <bahamas> no different highligthing for types and value constructors
01:03:21 <koz_> bahamas: See what I said about Nofrils being a religious choice.
01:03:41 <bahamas> a, that handles it
01:03:42 <koz_> Nofrils turns off all highlighting except strings and comments.
01:03:54 <bahamas> oh, I see
01:04:30 <bahamas> I still have trouble figuring out when a name refers to a type constructor or a value constructor. different colors would help
01:04:50 <koz_> bahamas: I follow the policy that I only 'recycle' data constructors on newtypes.
01:04:56 <koz_> But YMMV.
01:05:05 <koz_> s/data constructors/constructor names/
01:07:28 <koz_> bahamas: The question of 'how do I editor for Haskell' comes up enough I might just blog my setup.
01:07:55 <bahamas> koz_: I'm working with codebases written by other people, so I don't have an option
01:09:20 <DigitalKiwi> dante is nice if you want something like intero but don't want stack
01:09:22 <koz_> bahamas: Awww, then I'm sorry to hear that.
01:09:55 <maerwald> dante: "I don't force you into stack, but into emacs" :trollface:
01:09:59 <dminuoso> 10:04        bahamas | I still have trouble figuring out when a name refers to a type constructor or a value constructor. different colors would help
01:11:16 <dminuoso> bahamas: Whenever I wanted to know, I just replaced the thing I was looking at with `Int` and imagined whether it was "the right universe"
01:11:22 <DigitalKiwi> well emacs is the best anyway so there
01:12:04 <DigitalKiwi> doom-emacs or spacemacs are nice
01:12:50 <koz_> (doom-emacs... in Soviet Russia, Doom runs everything?) O o koz_
01:12:53 <DigitalKiwi> evil-mode: it's everything you want vim to be
01:13:04 <bahamas> DigitalKiwi: I tried both. I couldn't get passed the errors at setup time
01:13:35 <bahamas> so they're not begginer friendly, because if I have to know elisp just to start, I won't get very far
01:13:52 <bahamas> dminuoso: I'll try that approach next time. thanks!
01:13:54 <DigitalKiwi> the only one i had problems with was doom because i was using a configuration that only worked with the development branch but after that smooth sailing
01:14:17 * DigitalKiwi doesn't know elisp
01:14:53 <suzu> same
01:15:09 <suzu> i use emacs with .. vim keys and try to avoid really emacs'ing tbh
01:15:41 <dminuoso> bahamas: But I do agree that it can be quite confusing. Different colors might really be helpful in a text editor.
01:15:54 <DigitalKiwi> tbh spacemacs is probably easier and i'd have a lot more trouble with doom if i used that first but after a while with spacemacs i moved to doom
01:15:57 <dminuoso> It took me a few weeks to absorb it to the point where I no longer needed to think about it.
01:16:49 <bahamas> yeah, I've only been writing Haskell professionally for 2 weeks. I'm still stumbling through it
01:16:50 <DigitalKiwi> and that after like 10 years with vim
01:17:30 <dminuoso> Another rule of thumb could be "if its to the right of :: or @ it's a type constructor, if its to the right of = it's a value constructor".
01:17:46 <dminuoso> I think this holds far enough for a beginner, because the cases where you cant use this mind model are more advanced type features.
01:17:47 <DigitalKiwi> and really i probably use vim as much if not more than emacs which is mostly only for srs programming
01:17:49 <bahamas> I think that Haskell tooling could be so much better, because the language also could help thanks to its type system
01:18:09 <bahamas> dminuoso: I'm mostly confused in definitions of ADTs
01:18:28 <dminuoso> bahamas: Ah! There's a cool extension you could use: GADTSyntax.
01:18:45 <bahamas> dminuoso: and I've also been hiting advanced features, since I'm dealing with the purescript compiler and freer-simple at the moment
01:19:26 <dminuoso> So then you would have: data Maybe a where Just :: a -> Maybe a; Nothing :: Maybe a 
01:19:27 <tdammers> bahamas: the biggest roadblocks right now are 1) the redundancy between several available representations of Haskell syntax and AST (GHC, TH, haskell-src-exts); and the fact that the API GHC exposes isn't stable, or even explicitly specified (it's really just "whatever data structures GHC uses internally)
01:19:37 <dminuoso> bahamas: ^- this might be much easier to read. :)
01:20:15 <bahamas> dminuoso: yes, I like the explicitness of GADTs
01:20:31 <dminuoso> bahamas: You can opt into just the visual style using GADTSyntax without enabling full GADTs.
01:20:47 <dminuoso> It's just a cosmetic extension, but one that I think is really valuable for beginner.
01:22:05 <bahamas> tdammers: any reason for the latter other than lack of resources?
01:22:35 <suzu> @type ReaderT
01:22:36 <lambdabot> forall k r (m :: k -> *) (a :: k). (r -> m a) -> ReaderT r m a
01:24:23 <bahamas> dminuoso: so what's the difference between using GADTSyntax and GADT?
01:25:06 <merijn> bahamas: You can't actually do anything normal ADTs can't do with GADTSyntax
01:25:23 <merijn> bahamas: GADTSyntax just lets you write normal ADTs using the GADT syntax
01:26:49 <dminuoso> Also on a sidenote, GADTs implies MonoLocalBinds.
01:27:00 <merijn> bahamas: i.e. "data Maybe a where Just :: a -> Maybe a; Nothing :: Maybe a"
01:27:14 <merijn> GADTs also implies existentialquantification and a bunch of other things
01:27:31 <dminuoso> Really? That seems to be missed in the user manual.
01:27:39 <bahamas> ok. this made me realize I don't really know what GADTs are. I'll read up on them when I get the chance
01:29:02 <merijn> dminuoso: Well, it doesn't globally enable it
01:29:20 <merijn> dminuoso: But GADTs allows you to write existentially quantified code within the GADT definitions
01:30:18 <dminuoso> % -set XNoExistentialQuantification
01:30:18 <yahb> dminuoso: ; <interactive>:15:6: error: Data constructor not in scope: XNoExistentialQuantification :: ASetter s t a0 b
01:30:23 <dminuoso> % :set -XNoExistentialQuantification
01:30:24 <yahb> dminuoso: 
01:30:29 <dminuoso> % :set -XGADTs
01:30:29 <yahb> dminuoso: 
01:30:43 <dminuoso> % newtype F = forall s. F s
01:30:43 <yahb> dminuoso: ; <interactive>:18:13: error:; * A newtype constructor cannot have existential type variables; F :: forall s. s -> F; * In the definition of data constructor `F'; In the newtype declaration for `F'
01:30:49 <dminuoso> % data F = forall s. F s
01:30:49 <yahb> dminuoso: 
01:30:50 <merijn> bahamas: They're, well, Generalised ADTs. So they can encode somethings that ADTs can't. For example, the classic example is an expression datatype like "data Expr a = IntE Int | Const a | Add (Expr a) (Expr a)"
01:31:11 <dminuoso> And to make this usuable, you get type refinement on pattern matching.
01:31:39 <merijn> bahamas: With ADTs "IntE :: Int -> Expr a" you can't somehow tell GHC that "IntE" can only construct values of type "Expr Int", because ADTs don't allow that
01:32:18 <merijn> bahamas: With GADTs you're allowed to say "data Expr a where IntE :: Int -> Expr Int; Const :: a -> Expr a; Add :: Expr a -> Expr a -> Expr a" for example
01:32:55 <merijn> bahamas: So now GHC *knows* that when you have "f :: Expr Bool" that the IntE constructor can never occur, because values constructed with IntE can *never* be "Expr Bool"
01:33:48 <koz_> Sandy's book actually gives a very good description of this.
01:34:50 <dminuoso> I think GADTs are kind of hard to understand by just reading, but really simple by trying them out.
01:36:05 <dminuoso> At least that's how I felt about them.
01:36:09 <merijn> Yes
01:36:39 <merijn> Also, most of my mileage wrt GADTs has been from combining them with DataKinds
01:37:15 <dminuoso> At any rate, bahamas. I just recommend GADTSyntax because it doesn't functionally change Haskell - but give you a less-confusing/less-dense way of defining ADTs.
01:37:25 <merijn> Like this simple HList implementation https://gist.github.com/merijn/dc00bc7cebd6df012c5e
01:37:36 <dminuoso> Allowing you to stay in the mental model of "things to the right of :: are types" and "things to the right of = are values" (depending on whichever is closest)
01:37:50 <merijn> Yeah, I think GADTSyntax should be default as it's far more educational/consistent for beginners, IMO
01:38:51 <dminuoso> Isn't GADTSyntax in the list of candidate extensions to come into Haskell 2020?
01:40:05 <merijn> I hope so :p
01:40:19 <maerwald> merijn: simple? DataKind, FlexibleContexts, FlexibleInstances, KindSignatures, TypeFamilies, ...
01:40:20 <merijn> GADTs themselves probably won't be
01:40:35 <merijn> maerwald: For HLists it is simple
01:40:44 <merijn> I never said it was simple on an absolute scale
01:41:33 <merijn> Also, the TypeFamilies/TypeOperators aren't strictly necessary, they're just for the neater/more advanced examples at the end
01:41:58 <rfold> I wish I didn't have to make an arbitrary choice between GADTs and TypeFamilies when I want to use ~ constraints
01:42:00 <merijn> FlexibleInstances, FlexibleContexts, and KindSignatures should just be made standard in the 2020 report, imo
01:47:01 <tdammers> MultiParamTypeClasses and ScopedTypeVariables are absolute no-brainers too
01:47:17 <merijn> Sure, there's a bunch like that
01:47:22 <merijn> TupleSections, for one
01:47:40 <tdammers> oh yes, please. and LambdaCase
01:48:03 <merijn> LambdaCase and MultiWayIf I'm not opposed to, but I don't think they're as important
01:48:09 <dminuoso> BangPatterns too please.
01:48:21 <merijn> dminuoso: That one is already in the works, afaik
01:48:27 <dminuoso> Oh neat
01:48:50 <tdammers> LC and MWI are fairly non-intrusive - I don't think I can come up with a sensible code example that relies on them *not* being enabled to catch programming errors
01:49:14 <tdammers> let alone a correct code example that breaks when you enable them
01:49:21 <merijn> Oh, InstanceSigs is also a no brainer
01:50:15 <tdammers> I think a good rule of thumb is that if you can opt out of an extension by simply not using the feature it introduces, then enabling it by default is fine
01:50:40 <merijn> tdammers: Well, the other restriction that I can agree with is that it needs a good formal definition of exactly what it means
01:50:52 <merijn> GADTs is problematic because the underlying theory is a bit shaky
01:50:59 <tdammers> ah, hmm
01:51:05 <Ariakenom_> informally formal?
01:51:08 <merijn> A lot of their behaviour is specified in GHC specific implementation terms
01:51:34 <merijn> tdammers: But a lot of the syntactical extensions have straightforward semantics and trivial implementation
01:51:51 <tdammers> yeah, true
01:52:08 <merijn> We should also probably fix the broken support for no-case unicode letters :p
01:52:23 <tdammers> IMO unicode syntax was a mistake
01:52:44 <merijn> tdammers: Unicode syntax and unicode identifiers are separate issues, though
01:52:56 <tdammers> well, let's say both are probably mistakes
01:53:15 <tdammers> although I am somewhat partial to stuff like ∀ and →
01:53:54 <merijn> I disagree, limiting identifiers to ascii is a ridiculous limitation
01:54:09 <tdammers> my biggest issue with unicode syntax (both flavors) is that it's hard enough to find a font that clearly disambiguates similar ASCII characters; with unicode in the mix, the complexity of that explodes
01:55:30 <tdammers> there's also some gotchas, like how the same glyph can be represented as different code point sequences (e.g. combining diacritic + plain letter vs. accented letter), which makes things like equality comparisons problematic
01:55:34 <merijn> That seems like a ridiculous reason for disallowing identifiers to be written in people's native language, though. Just don't use ambiguous unicode characters when programming
01:55:54 <tdammers> é is ambiguous already
01:57:21 <tdammers> I think you probably want combining diacritic aigu + e to compare equal to é, in order to maintain the "if it looks the same, it is the same" assumption
01:57:51 <tdammers> but I'm not convinced GHC actually does that
01:57:58 <merijn> tdammers: The unicode spec has normalisation and comparison for that sorta thing though.
01:58:09 <tdammers> yes, but that means you do have to do all that
01:58:32 <merijn> tdammers: Probably not, but that's a matter of adopting libicu
01:58:39 <tdammers> right
01:59:01 <tdammers> so yeah, implementing unicode semantics correctly and fully would be a requirement for that
01:59:52 <tdammers> also, I think the syntactically relevant uppercase / lowercase thing in Haskell can be problematic with scripts that have a concept of letters, but not casing
02:00:51 <tdammers> OTOH, the prospect of writing an all-blackletter prelude is tempting
02:00:59 <merijn> tdammers: That's what I suggest changing. GHC is currently not compliant with the report :p
02:01:21 <merijn> Because the report uses a "uppercase/lowercase" distinction, rather than "uppercase/not uppercase" which GHC does
02:01:51 <merijn> Good thing too, else we couldn't have acme-LookOfDisapproval: https://hackage.haskell.org/package/acme-lookofdisapproval-0.1/docs/Acme-LookOfDisapproval.html
02:03:05 <rfold> tdammers: MultiParamTypeClasses isn't very useful without FunctionalDependencies
02:04:56 <rfold> merijn: more like the look of "0CA0" enclosed in a square.
02:05:24 <tdammers> rfold: it's not? I think it is. WIthout them, you sometimes have to explicitly annotate types, but that doesn't make it useless IMO
02:06:19 <tdammers> e.g., class Walk a b where walk :: a -> [b]
02:06:50 <rfold> I guess. :P
02:07:52 <rfold> But yeah, what you said, opt-out-by-not-using extensions I just put in my default extensions because it's less work
02:08:22 <rfold> I used to also put ApplicativeDo and StrictData in there but I stopped doing that because the former is buggy and the latter silently breaks code generators like Happy
02:08:57 <dminuoso> StrictData I dont like at all.
02:09:14 <tdammers> ApplicativeDo is kind of terrible, and the reasons why are even more terrible
02:09:28 <rfold> The only problem I have with StrictData is that Haddock doesn't add the ! annotations because of a bug :D
02:09:35 <lavalike> is there a way to pack a series of constraints into 1 declaration? constraint Foo a = (Num a, Ord a, Bounded a) -- say
02:09:43 <dminuoso> tdammers: Why do you think it's terrible?
02:09:46 <rfold> lavalike: look up Haskell ConstraintKinds
02:09:50 <lavalike> aight
02:10:15 <rfold> lavalike: after enabling ConstraintKinds, it would be the same syntax as in your example, except instead of "constraint" it'd be "type"
02:11:15 <cocreature> is there a way to get all arguments that follow a command in optparse-applicative _without_ having to follow the command by --?
02:12:09 <lavalike> rfold: beautiful, thanks
02:13:19 <cocreature> ah forwardOptions looks promising
02:13:26 <tdammers> dminuoso: I don't remember the exact details, but IIRC the core problem is that you need to somehow distinguish between monadic and applicative do blocks, and due to the way GHC is structured, the decision is made at a point where we don't really have proper information to base the decision on, so the logic that does that is a terribly inappropriate kludge that leads to lots of false negatives (i.e., do
02:13:28 <tdammers> blocks that could be applicative but end up monadic anyway, because the extension can't figure it out)
02:14:28 <dminuoso> tdammers: So what happens if there was no `Monad f` for the type? Would it then fail to typecheck?
02:14:36 <dminuoso> Or would that information be enough to pick Applicative instead?
02:15:17 <tdammers> I think the type checking happens later
02:16:27 <rfold> ApplicativeDo is purely a syntactic transformation.
02:16:36 <tdammers> part of the desugar pass
02:17:39 <rfold> do { a <- x; pure (f a) } uses only fmap; do { a <- x; b <- y; pure (a, b) } uses only fmap and <*>; do { a <- x; b <- y a; pure (a, b) } uses >>=
02:18:04 <merijn> cocreature: Yes? I'm pretty sure I do that somewhere
02:18:09 <rfold> Caveat: do { a <- x; b; pure (f a) } uses >>, not *>, for reasons still unclear to me.
02:18:19 <tdammers> rfold: performance
02:18:31 <rfold> Also fun: pure . f $ x will not use ApplicativeDo; pure (f x) and pure $ f x will
02:18:31 <Ariakenom_> I remember edwardk tried to do some commuting of <*> generated by applicativedo, but gave up because it used too many unnecessary binds.
02:18:32 <tdammers> >> can be implemented more efficiently than *> sometimes
02:18:59 <merijn> cocreature: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/ingest-src/Main.hs#L316 ?
02:19:49 <merijn> cocreature: Or did you mean "all arguments" to include flags?
02:20:12 <rfold> I'd liked it more if there were a new keyword, say ado, that never uses >>=, and normal do would be left alone. I think this would also make for more conscious use of Haxl.
02:20:23 <cocreature> merijn: I want to include flags but forwardOptions works just fine for that
02:20:23 <tdammers> rfold: yes, because the detection is based purely on syntactic patterns. pure (f x) has the right shape, (compose pure f) x does not
02:21:19 <tdammers> rfold: agree. Or just make it an even dumber syntactic transformation that uses whichever >>= and return are in scope
02:21:39 <tdammers> or introduce additional symbols that you can redefine
02:21:56 <tdammers> purescript style\
02:21:57 <rfold> tdammers: that one's available with RebindableSyntax
02:22:01 <tdammers> oh right
02:22:03 <tdammers> yeah
02:22:24 <Ariakenom_> eh, wasn't the point to make it implicit
02:26:02 <rfold> Doesn't mean it was a good point :P
02:26:51 <rfold> I don't think the current situation is bad. It could've been a bit nicer, but I'd still gladly use ApplicativeDo
02:27:44 <Ariakenom_> applicative operators aren't too bad for explicit use, right?
02:28:17 <rfold> Can't name the intermediate steps, which is a pain if there are many, or if the operands are loosely typed (e.g. FromJSON)
02:28:53 <__monty__> Can't you name the steps with let in?
02:30:06 <rfold> Yeah that should work, let x = a in let y = b in liftA2 f x y. But this is still inferior when f is a record constructor and you'd like to write F { fX = x, fY = y }
02:30:19 <rfold> Or even F {..} if that's your kind of thing
02:32:01 <rfold> Ok FromJSON is a bad example because it's Monad, we use ApplicativeDo a lot for optparse-applicative, precisely because of records
02:32:34 <__monty__> You only need one let. And why can't you do let x=..; y=.. in F { fX = x, fY = y }?
02:33:17 <merijn> rfold: I generally just use lots of where definitions and <$> and <*> with optparse
02:33:58 <magthe> I'm playing with `pipes` a little and I thought I rewrite some of my code that's using `conduit`, but I got stuck on finding an equivalent to `sinkList`. How do I run an Effect and collect the results in a list?
02:34:03 <rfold> __monty__: because x and y are of type m Int and m Bool and not Int and Bool
02:34:43 <magthe> the `conduit` code looks like this: runConduit $ mapM_ yield cmds .| myTransform .| sinkList
02:36:11 <rfold> magthe: can you ~> with the toList combinator from Pipes.Prelude before passing it to runEffect?
02:36:40 <merijn> magthe: Effect's don't have multiple results
02:36:51 <rfold> magthe: nevermind, that's the wrong function
02:37:09 <merijn> magthe: An Effect is like the result of 'runConduit' it doesn't really further compose, it represent a "finished" pipe
02:37:38 <magthe> merijn: well, does that mean that I can't convert the `conduit` code to `pipes` at all?
02:38:35 <merijn> magthe: "It Depends" some conduit code might need stuff like pipes-group and pipes-parse, it's hard to say without seeing what your current' pipes code looks like
02:39:52 <magthe> merijn: it's a simple translation of the `conduit` code so far, mapM_ yield [values] >-> myTransform >-> ?????
02:40:20 <magthe> or maybe I should just rethink how I test `myTransform` completely?
02:48:36 <cocreature> magthe: you could use https://hackage.haskell.org/package/foldl-1.4.5/docs/Control-Foldl.html#v:list to collect the elements
02:55:23 <magthe> cocreature, merijn: nope, I found it, what I want is https://hackage.haskell.org/package/pipes-4.3.9/docs/Pipes-Prelude.html#v:toList
03:16:11 <cocreature> phadej: Hey, I think at some point you mentioned that there is a way to do rudamentary heap profiling that does not involve recompiling GHC but is not documented in the user guide. Could you remind me of how I can do this?
03:17:41 <Bish> has someone heard of people whose first programming language was haskell?
03:18:00 <__monty__> Yes.
03:18:00 <Bish> is it weird to them? or will regular languages be weird to them after learning haskell
03:18:09 <Axman6> yes
03:18:21 <Arahael> That was an "or" question.
03:18:29 <Bish> Arahael: yeah i get the joke, never heard it before
03:18:30 <Bish> hoho
03:18:31 <Axman6> those who've done some maths don't seem to struggle much
03:18:54 <__monty__> Haven't heard of someone who learned haskell and then learned java or python. I'd expect imperative thinking to be harder than if they hadn't learned haskell.
03:19:18 <__monty__> Even if it's just because assigning intermediate results is often frowned upon.
03:20:44 <phadej> cocreature: -RTS -s -h
03:20:46 <phadej> iirc
03:20:47 <phadej> sorry
03:20:49 <phadej> -T -h
03:21:55 <phadej> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-options-for-profiling
03:22:03 <phadej> and it's even highlighted in the recent manual
03:22:24 <cocreature> phadej: nice, thank you!
03:22:28 <phadej> cheers
03:23:35 <phadej> write a blog post!
03:24:02 <cocreature> heh, maybe :)
03:33:37 <zzz> does Haskell count unicode uppercase greek letters as uppercase? can Ω be a type? 
03:36:52 <cocreature> > isUpper 'Ω'
03:36:54 <lambdabot>  True
03:37:34 <zzz> oh thanks
03:37:48 <cocreature> afaik it uses the unicode definitions
03:37:54 <olligobber> > let Ω = 1 in Ω
03:37:56 <lambdabot>  error: Not in scope: data constructor ‘Ω’
03:38:03 <jle`> @let data Ω = Ω Ω
03:38:05 <lambdabot>  Defined.
03:38:10 <olligobber> ooh
03:38:36 <zzz> @let data ∑ = ∑∑
03:38:36 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8721) is outside of bounds (0,255)
03:38:43 <zzz> @let data ∑ = ∑ ∑
03:38:43 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8721) is outside of bounds (0,255)
03:38:45 <jle`> heh
03:38:54 <jle`> lambdabot error
03:38:54 <cocreature> lol
03:39:06 <cocreature> sounds like someone has screwed up unicode :)
03:39:12 <jle`> @undefine
03:39:12 <lambdabot> Undefined.
03:39:15 <zzz> @let data Σ = Σ Σ
03:39:16 <lambdabot>  Defined.
03:39:18 <jle`> @let type Ω = Int
03:39:19 <lambdabot>  Defined.
03:39:25 <zzz> ok so ∑ /= Σ
03:39:28 <zzz> my bad
03:39:36 <jle`> @let add :: Ω -> Ω -> Ω; add x y = x + y
03:39:38 <lambdabot>  Defined.
03:39:40 <jle`> > add 1 2
03:39:42 <lambdabot>  3
03:40:47 <jle`> hm, is there a way to write absurd for data V = V V without explicit recursion
03:41:13 <quchen> Depends on what you mean with explicit recursion
03:41:15 <zzz> > isUpper 'ƒ'
03:41:18 <lambdabot>  False
03:41:23 <quchen> You can just use fix id, that’s not recursive
03:41:33 <quchen> At least not explicitly
03:41:50 <jle`> true :)
03:41:51 --- mode: glguy set +v johnmi3
03:41:55 <jle`> i would say 'without recursion'
03:42:02 <jle`> but that seems a bit unfar as data V = V V is a recursive type
03:42:09 <jle`> @let data V = V V
03:42:10 <lambdabot>  Defined.
03:42:37 <jle`> @let avsurd (V v) = avsurd v
03:42:38 <lambdabot>  Defined.
03:42:53 <quchen> Well you have to create some ⊥ value, so you can use infinite recursion or error or what have you
03:42:54 <jle`> hm, i guess that's actually safely total
03:43:08 <jle`> because we recurse on a "smaller" input
03:43:10 <quchen> Finding the largest prime is also a very good ⊥ if your home is cold
03:43:18 <johnmi3> > take 5 [1..]
03:43:20 <lambdabot>  [1,2,3,4,5]
03:43:46 <johnmi3> > isUpper 'Ă'
03:43:48 <lambdabot>  True
03:44:11 <jle`> `avsurd (V v) = avsurd v` is, i guess, not too bad, because we recurse on a smaller input, so it should pass totality checkers, right?
03:44:31 <olligobber> > isAlpha 'ㅤ'
03:44:33 <lambdabot>  True
03:44:44 <olligobber> > isSpace ' '
03:44:46 <lambdabot>  True
03:44:55 <sshine> obviously.
03:45:03 <olligobber> > length $ words "ㅤ ㅤ ㅤ"
03:45:05 <lambdabot>  3
03:45:16 <jle`> the neat thing about data Void, absurd = \case {}, is that it's "obviously" total
03:45:45 <cocreature> jle`: well "v = V v" isn’t bottom is it? so I would hope that writing absurd for a type that has non-bottom inhabitans is harder
03:46:20 <jle`> oh, yeah, data V = V v isn't actually void then is it
03:46:38 <jle`> maybe newtype V = V V ?
03:46:54 <cocreature> right, the newtype version is bottom
03:46:59 <cocreature> s/bottom/Void
03:47:28 <day> how do you write functions that are supposed to return Int but in cases they cant provide an Int what are they supposed to return then? False? whats their return type then? Int/Bool?
03:47:43 <quchen> day: Maybe Int, for example.
03:47:59 <day> right ive seen maybe
03:48:00 <quchen> :t find (\x -> x == 10) 
03:48:02 <lambdabot> (Num a, Eq a, Foldable t) => t a -> Maybe a
03:48:09 <quchen> :t find (\x -> x == 10) [1..5]
03:48:10 <lambdabot> (Enum a, Num a, Eq a) => Maybe a
03:48:12 <quchen> > find (\x -> x == 10) [1..5]
03:48:14 <lambdabot>  Nothing
03:48:17 <quchen> > find (\x -> x == 10) [1..50]
03:48:19 <lambdabot>  Just 10
03:49:01 <Bish> (λx -> x+1) this should be possible
03:49:05 <Bish> shouldn't it :p
03:49:15 <quchen> > (\x -> x+1) 10
03:49:17 <lambdabot>  11
03:49:30 <sshine> Bish, surely you just did it, so it's possible. :-P
03:49:56 <Bish> i mean the lambda symbol should mean something, souldn't it?
03:50:07 <quchen> It’s an ordinary letter.
03:50:23 <quchen> > (\λ -> λ+1) 10
03:50:26 <lambdabot>  11
03:50:35 <Bish> yeah , i know but i feel stupid to write \λ
03:50:42 <quchen> Then don’t.
03:50:55 <Bish> because \y is supposed to look like λ , shouldn't it?
03:51:03 <sshine> yes
03:51:44 <Bish> quchen: well i won't but still it should mean something
03:51:52 <sshine> it does mean something.
03:51:53 <Bish> because we have something "that looks like it" because none would write it
03:52:04 <sshine> it's a letter. :)
03:52:08 <Bish> sshine: a special meaning 
03:52:09 <sshine> ask any greek.
03:52:22 <Bish> in haskell, not in general
03:52:24 <sshine> Bish, it means something special to me.
03:52:26 <olligobber> there's probably a language extension to allow using a lambda instead of \
03:52:43 <Bish> olligobber: :D now we're going places
03:52:59 <Bish> guess that would piss everyone else off using that code
03:53:03 <sshine> Bish, it seems a bit researchy to use letters not on a standard keyboard as core syntax.
03:53:14 <jle`> there is a language extension that allows unicode operators for things like ->, ::, etc.
03:53:31 <jle`> but lambda is a bit tricky because it special-cases a valid variable name
03:53:52 <jle`> because λ is a valid variable name someone might use
03:54:23 <jle`> so it's not as simple as, say, an arrow for ->
03:54:41 <Bish> oh, that does exist?
03:54:57 <jle`> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unicode-syntax
03:55:12 <sshine> https://wiki.haskell.org/Unicode-symbols#UnicodeSyntax
03:55:36 <Bish> but i have to enable that, right?
03:55:52 <Bish> ∀ for forall is great :p
03:56:29 <sshine> Bish, you'll like Agda. :)
03:56:46 <Bish> nah, those 10-ish operators aren't worth it
03:58:12 <sshine> I think you can also get a mode for Emacs that renders Haskell code like Unicode but encodes it like regular ASCII.
04:00:47 <jle`> there are fonts that render ligatures specially, too
04:00:54 <Bish> yeah sure, 
04:00:59 <jle`> https://github.com/i-tu/Hasklig
04:13:34 <__monty__> There's also haskell-concealplus for vim.
04:15:17 --- mode: glguy set +v hpc
04:15:22 <hpc> symbols that are big in ascii remain big
04:15:43 <hpc> er
04:15:51 <hpc> i think i would like the ligature fonts the best, if i was forced to customize in one of those ways (before i got voiced)
04:25:47 <__monty__> They're less flexible but that probably comes with less trouble.
04:25:58 <lortabac> hello, I am looking for an extensible record solution that allows converting to and from standard Haskell records
04:26:39 <lortabac> and reasonable compile times
04:26:51 <lortabac> any ideas?
04:32:52 --- mode: glguy set +v coot__
04:34:30 <_d0t> hello! What would be the best haskell equivalent to c structures given that I want to implement a succinct data structure?
04:34:55 <_d0t> And regular haskell product types have too much overhead
04:35:38 <_d0t> I'm thinking about using short bytestrings and implementing accessor functions manually
04:35:43 <_d0t> Would that be a good idea?
04:36:25 * hackage unix-time 0.4.3 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.4.3 (KazuYamamoto)
04:37:44 <phadej> _d0t: did you verify that product types are in fact too slow?
04:38:02 <phadej> (or big, not sure what's your overhead)
04:38:10 <_d0t> I was referring to memory overhead
04:38:23 <_d0t> From what I know about haskell memory model, I think they definitely would be
04:38:51 <Ariakenom_> _d0t: do you want to mutate the data?
04:39:17 <_d0t> Ariakenom_: no
04:39:39 <_d0t> Well, it would be a bonus but it's not necessary
04:40:55 <_d0t> I'd say, Storable but without all the IO is what I'm looking for
04:40:56 <__monty__> _d0t: What makes you think they're big? Afaik sums are tagged but products are stored in contiguous words. You might want to unbox things but other than that there shouldn't be much overhead, afaik?
04:41:19 <_d0t> __monty__: what about the tag in the beginning?
04:42:34 <_d0t> anyway, I don't want to discuss haskell types overhead right now. I'm just looking for alternatives for my case if there are any.
04:44:20 <phadej> Unboxed.Vector Word8
04:44:27 <__monty__> _d0t: No need for a tag if it's not a sum type, afaik.
04:45:47 <_d0t> __monty__: so, say I have `data T = T !Word64 !Word32 !Word32`. How much memory space would this occupy?
04:45:50 <merijn> Are there operations that are commutative, but not associative? If so, what's a good example?
04:46:05 <_d0t> given -funbox-strict-fields and other optimizations
04:46:13 <_d0t> phadej: thanks, will check that out
04:46:35 <Ariakenom_> __monty__ _d0t https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
04:46:44 --- mode: glguy set +v m-renaud
04:46:55 <merijn> _d0t: That depends, do you want to include the space taken up by the Word values too?
04:47:02 <_d0t> merijn: yes
04:47:14 <_d0t> but shouldn't they be unboxed and inlined into the parent type?
04:47:28 <Ariakenom_> an overhead of 1 pointer afaict
04:47:42 <cocreature> merijn: \x y -> x * y + 1
04:47:43 <_d0t> is there a way to get rid of it?
04:48:08 <__monty__> Unboxed tuples are just stack values if I'm reading this right.
04:48:15 <merijn> I'd say 7? One for the info pointer for T, 3 words for the fields inside T and 3 for the actual words. The unboxing of the words saves you 3 words by skiping the indirections to them
04:49:28 <_d0t> Also, is it a good idea to use Storable and hide it behind unsafePerformIO?
04:49:35 <_d0t> Given that I won't mutate any data.
04:49:36 <Ariakenom_> as a note I don't think you need -funbox..., ghc will unbox small strict fields
04:49:37 <merijn> _d0t: Note that Word32 themselves are still boxed values, as "data Int = Int# Int#" and "data Word32 = W# Word#"
04:49:53 <merijn> Or, you know, just use the UNPACK pragma?
04:49:55 <_d0t> merijn: yes, I know. Is there a way to unbox them as well?
04:50:19 <_d0t> merijn: I think I did mention -funbox-strict-fields :)
04:50:24 <merijn> _d0t: You can use Word# directly
04:50:41 <merijn> _d0t: I prefer explicit pragmas for specific data over global flags, tbh
04:50:42 <_d0t> merijn: what are the drawbacks of using Word#?
04:51:10 <merijn> _d0t: Requires -XMagicHash, not portable, can't be parsed to polymorphic functions
04:51:23 <_d0t> hmm...
04:51:28 <merijn> (portable in the sense of "to other currently non-existent Haskell implementations")
04:51:34 <_d0t> Yeah, I got it
04:51:43 <_d0t> I think that should work for me.
04:52:25 <_d0t> Another question. How come Word16 and Word32 are both defined using Word#? Does that mean they have the same size?
04:52:31 <merijn> _d0t: Int#, Word# and co are, in principle, perfectly safe on their own and there's a reason GHC explicitly has support for them.
04:52:40 <merijn> _d0t: They are the same size, yes
04:53:03 <_d0t> Are there any native 16-bit and 32-bit wide types?
04:53:05 <merijn> _d0t: Because most architectures reading full words is cheaper/more efficient than readin partial machine words
04:53:50 <merijn> _d0t: Not really, but it depends what you need/want them for
04:54:22 <_d0t> As I said, I want a tightly-packed product type with a bunch of access functions
04:54:59 <merijn> _d0t: Honestly, combined with your question about Storable + unsafePerformIO (terrible idea!) I think what you really want is something like what I did for my binary decision tree implementation
04:55:11 <_d0t> merijn: could you link it?
04:55:32 <toxicafunk> hi
04:55:35 <_d0t> I actually want to implement poptrie in haskell
04:55:44 <_d0t> https://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p57.pdf
04:55:50 <merijn> _d0t: Basicaly, I had a C implementation that encoded the tree as an array of struct (for cache behaviour reasons) that I ported to Haskell using Storable Vector
04:55:57 <merijn> _d0t: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Model.hs
04:56:09 <merijn> Skip the huge inline string of C++ code in the middle :p
04:56:40 <merijn> The relevant bits are the datatype at the end and it's Storable instance and the predict function at the top
04:56:44 <toxicafunk> I have a small program which reads a file, each line is a message from which I extract an Id and use it as key to send the line and the key to a kafka topic
04:57:02 <_d0t> merijn: why's unsafePerformIO a bad idea in this case btw?
04:57:15 <toxicafunk> i have a couple of versions of such program, one of them uses hw-kafka and conduit to process the file
04:57:20 <toxicafunk> hereś the code
04:57:22 <toxicafunk> https://github.com/toxicafunk/kafkaproducerhs/blob/0.1.0/app/Main.hs
04:57:26 <merijn> _d0t: Because it always is and Storable vector lets you use Storable for read-only operations without IO :)
04:57:28 <toxicafunk> this works ok
04:57:48 <toxicafunk> but now I want to use Conduit.Async to do the same concurrently
04:57:59 <toxicafunk> this is what i got
04:58:00 <toxicafunk> https://github.com/toxicafunk/kafkaproducerhs/blob/hw_kafka-conduit/app/Main.hs
04:58:11 <toxicafunk> but it doesn work, of course
04:58:15 <merijn> Obviously vector uses unsafeX somewhere, but that's behind a well-tested and widely used API, rather than reinventing it yourself from scratch with all the potential mistakes
04:58:29 <_d0t> merijn: oh... that's probably what I could use, yes
04:58:52 <_d0t> I mean, I don't mind to have a haskell value for the node that is being inspected, but for storage that's less acceptable
04:58:57 <merijn> _d0t: See also the related "black magic" thing: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Utils.hs :)
04:59:15 <merijn> For turning ByteString's of manually laid out data into vectors
04:59:21 <_d0t> I'll try storable vectors. Thank you.
04:59:32 <toxicafunk> • Couldn't match type ‘CA.CConduit’ with ‘ConduitT’ arising from a functional dependency between: constraint ‘stm-conduit-4.0.1:Data.Conduit.Async.Composition.CCatable ConduitT ConduitT ConduitT’ arising from a use of ‘CA.buffer'’ instance ‘stm-conduit-4.0.1:Data.Conduit.Async.Composition.CCatable ConduitT ConduitT CA.CConduit’
04:59:47 <merijn> _d0t: Anyway, manually laid out access is exactly what the last 40 lines of that Model file do :)
05:00:12 <_d0t> merijn: yeah, I know how Storable works.
05:00:42 <toxicafunk> so i'm thinking ther should eb a way to convert my ConduitT to a CConduit or viceversa
05:00:54 <toxicafunk> any pointers?
05:01:10 <merijn> _d0t: That implementation is about 40% slower than the original C (granted, that one was averaging 150 nanoseconds per prediction), but the Haskell version ended up being faster due to getting nicely inlined inside the surrounding conduit code
05:01:12 <Axman6> edwardk did some interesting stuff in the structs package iirc for defining data with more unpacking etc.
05:02:04 <Axman6> https://github.com/ekmett/structs
05:02:07 <merijn> Axman6: Yeah, I've seen it, but this approach has a nicely low barrier to entry and gets pretty solid performance :)
05:02:21 <merijn> Axman6: Doesn't require TH, etc.
05:02:41 <Axman6> indeed, structs scares me
05:04:01 <Axman6> it's the answer to "How do I, in Haskell, get the performance of C, with the safety of C"
05:04:17 <merijn> Axman6: So is mine, tbh
05:04:37 <merijn> Look at the Utils.hs module :p
05:04:52 <merijn> "My Haskell isn't fast enough" means you just don't have enough MagicHash :p
05:05:36 <Axman6> I miss the days of working on the language shootout. so much MagicHash
05:06:20 <hpc> we need MoreMagicHash
05:06:29 <hpc> http://catb.org/jargon/html/magic-story.html
05:21:47 <delYsid> Anyone know of a simple side-scroller game writtein in Haskell for stealing ideas from?
05:22:48 <delYsid> I am writing a web audio based side-scroller audio game in PureScript, and am sort of stuck thinking up my datastructure?
05:23:28 <delYsid> And since most of my learning comes from reading code, I was hoping to find something similar to get inspired by.
05:25:57 <delYsid> https://github.com/mlang/motar -> https://blind.guru/wa/
05:36:24 --- mode: glguy set +v Ulbrec
05:39:40 <ski> merijn : "Are there operations that are commutative, but not associative? If so, what's a good example?" -- hm, `k,l |-> (k+l)! / (k! * l!)' is one ..
05:43:52 <savolla> hey guys do you recommend any regular expression exercises? book/site ?
05:54:34 <asheshambasta> How does one overcome this? https://gist.github.com/asheshambasta/1d1622f37ca66923631cb72aadc2490f for library; see: https://hackage.haskell.org/package/squeal-postgresql-0.4.0.0/docs/src/Squeal.PostgreSQL.PQ.html#runQueryParams
05:56:25 <asheshambasta> What is perplexing is: why doesn't GHC see that the type "params" is the same in the constraint of the function and in the query? So I'm telling it that there's an instance for ToParams that it can use. Instead, it tries to match things with some other type `params0`.
05:57:48 * ski . o O ( FDs )
05:58:55 <ski> asheshambasta : the error message ?
05:59:42 <asheshambasta> ski: https://gist.github.com/asheshambasta/1d1622f37ca66923631cb72aadc2490f#gistcomment-2789776
05:59:47 <asheshambasta> (overlapping instances)
05:59:52 <int-e> FD's won't help; (...) => ToParams x tys  is going to overlap with every other instance of ToParams
06:00:41 <merijn> asheshambasta: The constraint of instances is not considered when resolving them
06:00:53 <ski> (oh, sorry. i missed that there was an additional thing with the error, down there)
06:01:05 <int-e> (which is why I wrote (...) there)
06:01:42 <asheshambasta> What's the suggested way to "solve" this? 
06:04:38 <int-e> I guess the given  ToParams (DBId schema a) params  constraint has to be dropped and possibly replaced by the corresponding Generics stuff.
06:05:22 <int-e> that, or you enable overlapping instances and then ghc should pick the more specific instance, which is the given one.
06:07:17 <asheshambasta> Hm, okay, that was the line I was thinking of however, https://hackage.haskell.org/package/squeal-postgresql-0.4.0.0/docs/src/Squeal.PostgreSQL.PQ.html#runQueryParams the source doesn't seem to need that extension
06:07:30 <asheshambasta> Why?
06:08:19 <asheshambasta> Is it because it also doesn't specify the `i` as a concrete type?
06:09:08 <merijn> Other solution/workaround would be to get rid of multiparam typeclass and try to use a type family to map from a schema to an actual type
06:11:31 <asheshambasta> I see
06:11:55 * hackage ngx-export-tools 0.4.2.1 - Extra tools for Nginx haskell module  http://hackage.haskell.org/package/ngx-export-tools-0.4.2.1 (lyokha)
06:12:22 <int-e> asheshambasta: oh wait... you have a param0 and a param there... so the given constraint is not a perfect match for the required one.
06:12:35 <int-e> err, params0 and params.
06:12:44 <int-e> (the params0 only occurs in the error message)
06:13:41 * int-e is a bit confused now about what ghc is actually doing there... are locally given constraints always preferred over other instances?
06:14:05 <asheshambasta>  
06:14:05 <asheshambasta> yeah but I still don't understand and I share the same confusion as yours 
06:14:32 <asheshambasta> Or is the "statement" of a constraint only telling GHC that I know there's some instance that exists, now you pick which one you'd like to use. 
06:19:21 --- mode: glguy set +v default_
06:30:19 <int-e> asheshambasta: uhm what's the  where q = undefined  doing there?
06:31:06 <asheshambasta> int-e: holy f***
06:31:10 <int-e> that's shadowing the 'q' argument and explains where the params0 comes from.
06:31:26 * int-e is annoyed that he didn't see that sooner...
06:31:27 <asheshambasta> int-e: you're absolutely right
06:31:49 <initiumdoeslinux> merijn can be forever found in the haskell irc :)
06:33:20 * asheshambasta is embarrassed 
06:37:41 <asheshambasta> Thank you so much int-e 
06:39:34 --- mode: glguy set +v euler2718
06:53:26 <zoulock> Hello, is this the right place to ask for help to debug a program?
06:55:07 <infinisil> zoulock: Only if it's a Haskell program!
06:55:40 <zoulock> infinisil: Of course it is lol"
06:56:14 <suzu> then yes
06:56:19 <suzu> ask away
06:56:55 <zoulock> I'm having some problem with Writer monad and a lazy infinite list
06:57:23 <zoulock> Here is the code: https://github.com/zoulock/Memory-Simulator
06:58:42 <zoulock> Basically, it gets stuck traversing the list, and I don't know how to make it stop on a certain condition
07:02:22 <suzu> this is a big repo with a lot going on
07:02:37 <suzu> could you explain in more detail exactly what you are doing and what the problem is
07:02:42 <zoulock> yes, but it's basically graphics stuff
07:02:52 <zoulock> ok
07:05:49 <zoulock> it's a simulation of how a cpu assigns processes to certain memory locations. A process arrives to the processor, gets put in a queue and when there is available space gets assigned. It stays in memory as long as it,s execution time and then gets removed. I'm trying to log all the actions the processor does in the Writer monad, but when I evaluate it it gets stuck in an infinite loop.
07:08:23 <suzu> well as a first step you could maybe try using Debug.Trace to gain a better understanding of how the control flow of your program is ending up running forever
07:10:11 <zoulock> I have, and from what I understand, it keeps calling the function step. I need to stop it when it gets to a certain iteration, but I don't know how.
07:14:54 <__monty__> Is there a function to saturate a function by drawing arguments from a list? What I'd like to do rn is turn 5-element lists into 5-tuples.
07:16:13 <zoulock> __monty__: you can write your own one.
07:17:49 <int-e> :t \[a,b,c,d,e] -> (a,b,c,d,e) -- probably saner...
07:17:50 <lambdabot> [e] -> (e, e, e, e, e)
07:20:26 <__monty__> int-e: But so boring : )
07:20:35 <int-e> the trouble starts with the fact that saturating arguments is not exactly well-defined.
07:21:32 <MarcelineVQ> __monty__: food for thought: a 5 element list has 6 constructors involved, this could suggest that a 5 tuple's 5 slots might not quite fit the translation. a Maybe 5-tuple does have 6 options however
07:21:33 <int-e> > map ((+) 1) [2]
07:21:36 <lambdabot>  [3]
07:21:58 <int-e> :t printf
07:21:59 <lambdabot> PrintfType r => String -> r
07:22:10 <MarcelineVQ> Which I've worded pretty terribly
07:22:50 --- mode: glguy set +v default_
07:23:16 <int-e> You'd end up with a printf-like trick, but, arguably, for less benefit.
07:24:05 <int-e> __monty__: Boring is good, as long as it's not tons of boilerplate code.
07:24:34 <merijn> __monty__, int-e: Well, if you use some GADT style HList you can, in fact, get arguments from a variable length list for a function
07:24:34 <__monty__> int-e: Boring isn't very motivating for learning. Not planning to look at this code again tbh.
07:25:03 <merijn> __monty__: See the apply function here: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
07:25:29 <merijn> __monty__: It (type-safely!) applies a function of whatever number of arguments to the elements of a list
07:27:15 <__monty__> merijn: Except the function needs to be able to accept an arbitrary number of arguments?
07:28:00 <merijn> __monty__: My case (unlike the Printf) hack doesn't. But it requires the list to be the same length and right arguments for the function
07:28:23 <merijn> __monty__: I could probably make it work on any list that had *at least* the right number of arguments, but that's a bit messier
07:28:56 <__monty__> I'm also thinking making the HList'll be at least as much work as just making the tuple. Still cool though. It basically implements polyvariadic functions, right? I did an exercise implementing that with type classes.
07:30:18 <merijn> __monty__: The list encodes the number and types of its argument in the type, and the "Fun" type family computes the type of a function that consumes all of those. 'apply' then uses that to ensure that any function passed has a type corresponding to the actual number and types of the inputs it will get
07:30:58 <merijn> __monty__: The typeclass approach to polyvariadic functions generally isn't quite as typesafe since either 1) your function has to work on all possible inputs and regardless of number or 2) there are some partial/crashing cases
07:31:22 <merijn> __monty__: The apply function otoh is completely type safe, it will never "fail" at runtime (unless the function you give it somehow does)
07:31:48 <merijn> __monty__: Similar the "head" and "tail" in that modules are also typesafe
07:32:43 <int-e> an HList is not really a list anyway.
07:32:47 <MarcelineVQ> merijn: is this some sort of christian magic?
07:34:29 <int-e> It's more of a generic tuple; the whole shape is encoded in the type.
07:37:44 <merijn> int-e: I disagree, a tuple to me means O(1) projection
07:41:05 <int-e> merijn: that just makes it an inefficient tuple ;)
07:47:15 <infinisil> Are HLists not O(1) projection? I mean the types should be resolved at compile time, so at runtime it should really just be a tuple
07:48:37 <infinisil> Oh, I guess tuples have some special compiler support to allow O(1), if tuples were just (a, (b, (c, ...))) then it would be slow too. Or not? Because it's a fixed memory layout
07:48:52 <infinisil> I have no idea lol
07:49:48 <shapr> infinisil: criterion?
07:51:06 <infinisil> If I had any motivation to test maybe, but that's currently not the case :)
07:51:41 <infinisil> HList's are probably O(n) at compile time haha
07:52:18 <merijn> infinisil: The HList as I linked it is just a linked list, so O(n)
07:52:51 <merijn> infinisil: Not at compile time, GHC doesn't arbitrarily rewrite it into some other presentation, besides if the tail is used in multiple places that wouldn't even work
07:53:01 <infinisil> Hmm I see
07:53:46 <merijn> As such it won't perform particularly fast or well, but that's ok if flexibility is more important than speed (as it very often is)
07:55:15 --- mode: glguy set +v Ulbrec
07:56:29 <merijn> Entirely unrelated note: Anyone got tips for typesetting data structures in LaTeX pseudocode?
07:59:47 <cemerick> I have floundered against a variant of the fold-over-huge-list problem, which appears to never finish. Any suggestions? https://github.com/cemerick/silly-shootout/blob/63c6d1c385c532725e7051156ddd380047ff1e17/Bench.hs
08:00:11 <cemerick> Note it does complete over a list 1e7 long.
08:00:18 <Ariakenom_> merijn: typesetting data structures how?
08:07:19 <Ariakenom_> cemerick: what if you change the Strict pragma to StrictData
08:09:52 <cemerick> Ariakenom_: same -- though Strict shouldn't ever yield "worse" outcomes AFAIK?
08:10:04 <Ariakenom_> ... why would you say that
08:11:07 <cemerick> Ariakenom_: these sorts of problems usually arise from not accounting for laziness properly, and Strict is less lazy than StrictData?
08:12:20 <zoulock> how can I implement this? a -> (a -> (Writer [b] a) -> [(a, [b])] 
08:13:07 <Ariakenom_> cemerick: "accounting for" does not mean use more strictness
08:14:29 <cemerick> Ariakenom_: correct, but having totally strict semantics cannot _hurt_ in this particular snippet, could it?
08:14:30 <Ariakenom_> cemerick: [1..1e9] can be an "iterator" in a lazy setting or a huge list in a strict setting
08:14:57 <cemerick> mmm, fair point
08:17:07 <cemerick> Ariakenom_: actually, that list shouldn't be affected by any strictness declaration, since it's not a definition, binding, case, etc? (at least, that's how I'm reading https://ghc.haskell.org/trac/ghc/wiki/StrictPragma)
08:20:24 <Ariakenom_> cemerick: Yup, should be the same. thanks, somehow had a hard time finding Strict docs
08:20:27 <shapr> @djinn a -> (a -> (Writer [b] a) -> [(a, [b])]
08:20:27 <lambdabot> Cannot parse command
08:20:30 <shapr> aw
08:20:35 <shapr> @djinn a -> a
08:20:35 <lambdabot> f a = a
08:20:52 <shapr> @djinn (a -> (Writer [b] a) -> [(a, [b])]
08:20:52 <lambdabot> Cannot parse command
08:20:58 <shapr> @djinn (a -> (m [b] a) -> [(a, [b])]
08:20:59 <lambdabot> Cannot parse command
08:21:01 * shapr shrugs
08:21:15 <vaibhavsagar> how do I statically link a haskell library against a C++ library?
08:21:19 <shapr> zoulock: perhaps you could break it down into pieces and use type holes to find the solution?
08:21:28 <shapr> vaibhavsagar: oh boy, you are in for some fun
08:21:44 <vaibhavsagar> I've tried adding -pgmlg++ to the ghc-options and stdc++ to the extra-libraries
08:21:53 <shapr> from what I've read, wrap in a plain C wrapper is step 1
08:22:01 <vaibhavsagar> shapr: I'm scared
08:22:25 <vaibhavsagar> this is the zeromq4-haskell library btw
08:22:26 <shapr> vaibhavsagar: I ended up drinking whiskey after a weekend of wrapping Haskell code into C code
08:22:33 <shapr> and I almost never drink
08:23:06 <vaibhavsagar> I tried https://stackoverflow.com/a/37643200
08:23:23 <shapr> oh, you want to wrap a C lib into a Haskell program, that's much easier
08:23:57 <vaibhavsagar> a c++ lib
08:24:01 <c_wraith> yeah, that direction only has inscrutable memory corruption bugs if you make a mistake.  Way better. :)
08:24:19 <vaibhavsagar> I just want to appease the linker
08:24:39 <c_wraith> Oh, you already have haskell FFI bindings?
08:24:59 <vaibhavsagar> I want to modify the zeromq4-haskell library to link statically
08:25:01 <c_wraith> The difficulty is in the linking step?
08:25:26 <vaibhavsagar> yes, in a package that depends on zeromq4-haskell
08:26:45 --- mode: glguy set +v tibi
08:26:51 <shapr> vaibhavsagar: what's the error?
08:27:01 <tibi> Hello !
08:27:06 <shapr> HI tibi! How's code?
08:27:16 <shapr> tibi: learned anything nifty lately?
08:27:46 <tibi> I was browsing haskell.org and seen that the https://www.haskell.org/news is not responding  
08:28:24 <shapr> oh, I forget who runs the website
08:28:38 <tibi> @sharp not so much. But i am looking forward to do so 
08:28:38 * lambdabot pokes not so much. But i am looking forward to do so  in the eye
08:29:03 <shapr> tibi: ooh, what are you learning next?
08:30:26 <tibi> sharp: well. for a year or so I have been in love with haskell and now I wanna try to contribute to it
08:30:53 <shapr> tibi: awesome! where do you want to start?
08:31:01 <tibi> I come from a C background and I like very much the simplicity and the types in haskell 
08:31:31 <tibi> is there an irc for dev?
08:32:15 <vaibhavsagar> shapr: https://pastebin.com/cbbFFSma
08:32:18 <shapr> tibi: last I heard, a good intro to contributing to GHC is https://twitter.com/bgamari/status/1006171802140364800
08:32:26 <tibi> i was looking here: https://www.haskell.org/irc; but couldn t find any that are not specific (ie games haskell, iphone etc)
08:32:56 <tibi> oo danke ! :D
08:33:02 <shapr> bitte
08:33:16 <tibi> Deutsch?  
08:33:25 <shapr> nein, svensk :-P
08:33:31 <shapr> or close enough
08:34:06 <shapr> vaibhavsagar: now I'm scared too
08:34:15 <tibi> ahh. I am romanian, but i like the language :))
08:34:24 <Ariakenom_> % 1e9 == (1e9 + 1:: Float) -- cemerick 
08:34:24 <yahb> Ariakenom_: True
08:34:29 <shapr> tibi: I'm from Alabama, USA but I like languages
08:36:03 <shapr> vaibhavsagar: were I in your situation, I'd start shotgun debugging by adding -I and -L for the libs
08:36:10 <shapr> It's especially interesting that you're using musl
08:36:40 <Ariakenom_> cemerick: floats are evil, can't believe I didn't suspect them earlier :)
08:37:15 <shapr> there was a static musl build with nix repo I used successfully...
08:37:41 <shapr> vaibhavsagar: ah, based on your blog post I believe: https://github.com/nh2/static-haskell-nix
08:37:46 <shapr> already seen/used that?
08:37:48 <cemerick> Ariakenom_: that's amusing (and not consistent with other machine floats AFAICT, so worth investigating), but the same behaviour exists if I type out 1000000000
08:38:59 <cemerick> oh, but it's still going to be a [Float]; sheesh
08:39:40 <Ariakenom_> cemerick: It's normal float behaviour, your precision drops below one at that magnitude
08:40:09 <ski> @check \x -> let y = 10e5 * x in y /= y + (1 :: Float)
08:40:11 <lambdabot>  *** Failed! Falsifiable (after 17 tests and 3 shrinks):
08:40:11 <lambdabot>  27.13002
08:40:14 <Ariakenom_> cemerick: just using Double should be fine
08:42:35 <Ariakenom_> @check \e -> let x=1^e in (x::Float) /= x+1
08:42:37 <lambdabot>  *** Failed! Exception: 'Negative exponent' (after 2 tests):
08:42:37 <lambdabot>  -1
08:42:45 <Ariakenom_> hrm hrm
08:42:52 <Ariakenom_> @check \e -> let x=1^abs e in (x::Float) /= x+1
08:42:54 <lambdabot>  +++ OK, passed 100 tests.
08:43:16 <Ariakenom_> @check \e -> let x=10^abs e in (x::Float) /= x+1
08:43:18 <lambdabot>  *** Failed! Falsifiable (after 17 tests and 4 shrinks):
08:43:18 <lambdabot>  -14
08:44:18 <shapr> vaibhavsagar: after looking at your blog posts, I suspect you know more than I do about this
08:44:24 <nh2> vaibhavsagar shapr: it seems that you have already got libzmq.a (good), and the only remaining problem is to link in the static libstdc++ as well. I've done a bit of googling just now, there seems to be flags `-static-libgcc -static-libstdc++`, give that a shot
08:44:50 <Ariakenom_> Float is being 20x slower for me too
08:44:59 <cemerick> Ariakenom_: thank you, it's sorted now
08:45:09 <cemerick> `map (r 20 0 100 . fromIntegral) ([0..1000000000] :: [Int])`
08:45:12 <nh2> vaibhavsagar: (these are apparently gcc flags, so you may have to put them, in cabal's cc-flags, and perhaps also as -optc ghc-options given that cabal doesn't pass those on automatically (the bug I reported)
08:45:20 <dmwit> > take 1 . dropWhile (\x -> x+1 /= x) . iterate (*2) $ 1 :: [Float]
08:45:22 <lambdabot>  [1.6777216e7]
08:45:42 <dmwit> > 16777215 /= 16777216
08:45:44 <lambdabot>  True
08:45:49 <dmwit> > 16777216 /= 16777217
08:45:51 <lambdabot>  True
08:45:52 <shapr> nh2: ah, I've gotten much benefit from your static-haskell-nix repo, thanks for creating that!
08:46:24 <nh2> shapr: very good; the Return of Static Linking is neigh
08:46:37 <dmwit> > (16777215 /= (16777216 :: Float), 16777216 /= (16777217 :: Float))
08:46:39 <lambdabot>  (True,False)
08:46:55 <vaibhavsagar> nh2: thanks, I will try those flags now
08:46:56 <dmwit> Now you know exactly where the precision drops off!
08:47:07 <shapr> nh2: yeah, buncha small utilities I'd like to create for use in ec2
08:51:58 <cemerick> Ariakenom_: my intuitions aren't helped that various langs call doubles floats, etc :-P
08:54:24 <cemerick> final result for interested onlookers: https://github.com/cemerick/silly-shootout/blob/10057ccc4a74597fb1d847dfa8ed5b9c43826d12/Bench.hs
08:56:08 <MarcelineVQ> cemerick: if it interests you https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#fractional-looking-integer-literals
08:56:57 <cemerick> MarcelineVQ: heh, that's funny
08:57:20 <cemerick> maybe in a "likes are florps" sort of way
08:59:35 <v0d1ch> anyone knows something about stack-builders company ? is it a nice place to work at ? 🤔
09:00:24 <adamCS> Anyone have any tips for figuring out why ghc (8.4.3 and 8.6.3) would seg-fault when compiling a quasiquote?  I'm trying to get inline-r working and, though the library installs fine, as soon as the code includes an r quasiquote, even an empty one "[r| |]", the compiler segfaults.  I'm on OS X high-sierra (10.14.2).
09:10:30 <vaibhavsagar> nh2: no luck with those flags :(
09:18:29 <pounce> Hello... I just profiled my code since it's taking forever, and it says it allocated 91GB of memory on the heap. Is this my problem ? and how do I reduce it?
09:19:33 <Solonarv> That's the total amount that was ever allocated, it doesn't mean your program had 91GB allocated at anyb point in time
09:20:00 <Solonarv> We don't have enough information to know if that's why your code is slow.
09:20:26 * hackage juicy-draw 0.1.0.0 - Functions for drawing and filling lines, rectangles and polygons directly onto a mutable image  http://hackage.haskell.org/package/juicy-draw-0.1.0.0 (rcook)
09:23:35 <pounce> Solonarv: Here's my code: https://ptpb.pw/EHS9/hs#L-27 all the work is done in the `dijkstra_recusive` function
09:24:42 <Solonarv> We'd need the profiling result as well, or at least I would
09:26:19 <pounce> Solonarv: here's the perf result I got by giving it +RTS -stderr https://ptpb.pw/7EKO
09:27:11 <pounce> (this is from before I made foldl strict. The strict version just finished running and it's a second faster)
09:27:18 <Solonarv> That's not a profile. It's just an overall measurement.
09:27:26 <pounce> ah, how should I profile it?
09:29:18 <Solonarv> How are you compiling?
09:30:10 <pounce> I'm compiling it with `-dynamic` and now `-rtsopts` to get the allocation data
09:30:14 <pounce> oh! also -O2
09:30:31 <Solonarv> So you're just using GHC directly, or..?
09:30:41 <pounce> yeah
09:32:02 <Solonarv> Add -prof -fprof-auto to the GHC options
09:36:32 <Solonarv> here is the relevant bit of the GHC manual: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
09:38:38 <pounce> uh-oh, it doesn't look like my packages have profiling support
09:39:31 <nh2> vaibhavsagar: do you have an example I can easily try that results in the error?
09:43:06 <pounce> hmm, I guess I just have to figure out how to use cabal
09:44:49 <Solonarv> yeah, cabal handles that pretty well
09:45:30 <sclv> v0d1ch: i know ppl from there and they’ve seemed cool from what i know
09:46:27 <pounce> I'm having a bunch of trouble because I installed all these packages through my package manager. I tried installing a package with cabal but it had an error `There are files missing in the ‘base-4.12.0.0’ package`, do y'all know how to fix this?
09:46:37 <geekosaur> arch?
09:47:06 <pounce> yeah
09:47:19 <pounce> oh wait, that's what it usually says if I don't compile with -dynamic
09:47:24 <geekosaur> ghc-static package will help some.
09:48:04 <pounce> yeah I'll try that out ^^
09:48:09 <geekosaur> but only some, you can't get the static libs for most of them. see the arch wiki, and you may at some point want to remove the stuff from the package manager and install manualy
09:48:54 <pounce> yeah, that's what I think I have to do anyway to get profiling support ^^
09:51:58 <pounce> How do I install everything manually?
09:57:41 <v0d1ch> sclv: nice, thanks
09:59:01 <Solonarv> I think you want to: remove the dynamic ghc/cabal packages, install the static variants, and let cabal handle any haskell packages you need
09:59:16 <Solonarv> The Arch wiki has a page with more detail
10:02:32 <geekosaur> they asoened profling libs
10:29:44 --- mode: glguy set +v Boarders
10:30:10 --- mode: glguy set -v Boarders
10:30:45 <Boarders> does anyone know if there is the equivalent of 'stack hoogle --server' with cabal
10:31:27 <__monty__> Boarders: I just run hoogle --local.
10:31:43 <vaibhavsagar> nh2: https://gist.github.com/vaibhavsagar/219af0ae2ca1e4861806f11de2b62c85
10:31:45 <__monty__> I use nix to set up the hoogle though. You'll need to look into how to index docs.
10:33:23 <vaibhavsagar> nh2: unfortunately you'll need to build our fork of GHC with TH saved splices support and then all the necessary dependencies
10:39:20 <Boarders> how do I set a particular version of ghc with a cabal project
10:40:20 <glguy> Boarders: you can specify the GHC version with the -w flag when you configure it
10:40:28 <Boarders> ah ok
10:41:11 <Boarders> thanks
10:54:39 * hackage Glob 0.10.0 - Globbing library  http://hackage.haskell.org/package/Glob-0.10.0 (MattiNiemenmaa)
11:05:25 <spoonm> I was talking to a friend yesterday and he mentioned code golfing to me, then presented a Haskell example that struck me as weird because it wasn't using spaces for function application
11:05:40 <spoonm> I went ahead and tried `foldr1(+)[1,2]` on GHCi and it works
11:05:53 <spoonm> can anyone explain to me what's going on? why is this a thing and how?
11:06:01 <glguy> Haskell doesn't actually use spaces for function application, spaces are part of the lexical syntax that can separate some tokens
11:06:27 <monochrom> Space is not function application. Juxtaposition is. Space is there just to separate tokens, and clearly there are other ways to separate tokens.
11:06:30 <glguy> In Haskell function application is achieved by having one expression immediately follow another, or by using the operator syntax
11:07:04 <nh2> vaibhavsagar: what are TH saved splices?
11:07:04 <spoonm> oh wow, I've been seeing it all wrong, then
11:07:24 <nh2> vaibhavsagar: also, could I try reproducing it just with `static-haskell-nix` master?
11:07:44 <monochrom> This is why every CS curriculum should include a compulsory parsing course.
11:08:08 <spoonm> monochrom: isn't it part of compiler modules?
11:08:09 <zachk> parsing all by itself?
11:08:47 <monochrom> It is in the status quo, and the status quo also makes the compiler module optional.
11:08:55 <spoonm> it does?
11:09:13 <nefple[m]> NLP was a required class for me, and I think for most CS programs
11:09:40 <monochrom> Concepts concerning parsing can easily be part of basic first year courses because like you have to talk about syntax anyway.
11:09:51 <spoonm> CS curricula here in Brazil has compilers as a required class, right after "formal languages and automata", which can come after "programming paradigms" or any programming module
11:10:15 <pounce> hah.... my cs program has "programming in C#" required but nothing to do with parsing/nlp/programming languages
11:11:34 <monochrom> Beware that the world is huge and there is 90% chance that your locality is an exception.
11:11:49 * glguy shudders
11:11:51 <pounce> I hope so 
11:12:28 <monochrom> Like, 90% of my friends know of Linux, and >50% use Linux mainly.  You think that's the world average?!
11:13:00 <glguy> I'd always assumed monochrom was friends with everyone
11:13:25 <spoonm> monochrom: it certainly seems that way until I leave home and have to talk to someone I don't know
11:13:28 <monochrom> Consider the positive feedback in the dynamics of how your locality affects you and how you choose your locality.  Aka echo chamber.
11:14:03 <spoonm> everyone's a seasoned unix user until I go shopping and some old classmate runs into me and asks me what I do for fun nowadays
11:18:25 <nefple[m]> and they're a Hurd user right? yeah been there too :\
11:18:43 <monochrom> haha
11:20:18 <nh2> vaibhavsagar: for me `zeromq4-haskell`'s test suite fails on `static-haskell-nix` btw, also for you?
11:20:46 <vaibhavsagar> nh2: yes, it's been broken for some time
11:20:53 <vaibhavsagar> (the test-suite, not the package)
11:21:05 <vaibhavsagar> I just do `dontCheck` and continue
11:21:18 <vaibhavsagar> I'm trying to repro with your `static-haskell-nix` repo
11:44:29 <nh2> vaibhavsagar: I'm a bit slow currently, working on https://github.com/NixOS/nixpkgs/issues/52439 in parallel
11:49:52 --- mode: glguy set -v m-renaud
11:53:05 <vaibhavsagar> nh2: any help is appreciated but you're certainly not obliged to work on it :)
11:53:36 <nh2> vaibhavsagar: I too am interested in being able to link in C++ statically
11:53:59 <vaibhavsagar> if/when I get this working it will definitely be upstreamed
12:08:23 <toxicafunk> hey!
12:08:34 <toxicafunk> for those who know conduit
12:09:00 <toxicafunk> is there a way to turn a ConduitT into a CCounduit from stm-conduit?
12:10:19 <toxicafunk> Couldn't match type ‘CA.CConduit’ with ‘ConduitT’ arising from a functional dependency between: constraint ‘stm-conduit-4.0.1:Data.Conduit.Async.Composition.CCatable ConduitT ConduitT ConduitT’ arising from a use of ‘CA.buffer'’ instance ‘stm-conduit-4.0.1:Data.Conduit.Async.Composition.CCatable ConduitT ConduitT CA.CConduit’
12:10:25 * hackage regex 1.0.2.0 - Toolkit for regex-base  http://hackage.haskell.org/package/regex-1.0.2.0 (ChrisDornan)
12:11:55 * hackage regex-with-pcre 1.0.2.0 - Toolkit for regex-base  http://hackage.haskell.org/package/regex-with-pcre-1.0.2.0 (ChrisDornan)
12:12:55 * hackage regex-examples 1.0.2.0 - Tutorial, tests and example programs for regex  http://hackage.haskell.org/package/regex-examples-1.0.2.0 (ChrisDornan)
12:21:45 <nh2> vaibhavsagar: OK I can definitely repro the problem
12:21:49 <nh2> with static-haskell-nix
12:22:07 <nh2> by just adding
12:22:07 <nh2> zeromq4-haskell = dontCheck super.zeromq4-haskell;
12:22:07 <nh2> zeromq4-haskell-repro = self.callCabal2nix "zeromq4-haskell-repro" ../zeromq4-haskell-repro {};
12:22:16 <nh2> where ../zeromq4-haskell-repro is your cloned gist
12:22:25 <nh2> and running `NIX_PATH=nixpkgs=https://github.com/NixOS/nixpkgs/archive/88ae8f7d.tar.gz nix-build --no-link survey/default.nix -A haskellPackages.zeromq4-haskell-repro`
12:24:25 * hackage list-zip-def 0.1.0.3 - Provides zips with default values.  http://hackage.haskell.org/package/list-zip-def-0.1.0.3 (muesli4)
12:26:35 <vaibhavsagar> nh2: good to know!
12:27:21 <vaibhavsagar> I tried it with `-pgmlg++` and `extra-libraries: stdc++` and the flags you suggested, didn't make a difference
12:29:43 <thblt> Hello #haskell, mind a naive question? I'm writing a toy lisp interpreter in Haskell, and all the functions callable from Lisp have the type Machine -> IO (LispObject, Machine). (Machine is the Lisp machine's state, roughly the binding environment, and it returns a value and a new machine state.  I'm just realizing I'm reinventing the State monad, am I correct?
12:30:41 <Solonarv> Yup, 'StateT Machine IO' ~ 'Machine -> IO (_, Machine)'
12:30:45 <thblt> (There's no "function arguments" parameter because they're bound in the Machine before the function gets executed, which I believe is the way to go)
12:31:03 <thblt> Solonarv: thank you!
12:32:13 <Solonarv> although: I'm generally a fan of replacing 'StateT s IO' with 'ReaderT (IORef s) IO' - the latter is easier to reason about in the presence of exceptions and other non-linear control flow
12:33:51 <vaibhavsagar> I imagine they aren't doing a lot of that if this is a toy lisp interpreter
12:34:11 * thblt looks up IORef
12:34:28 <Solonarv> Yeah, fair enough :>
12:35:01 <nh2> vaibhavsagar: it links when I add -lstdc++ to the final cc invocation
12:35:14 <nh2> but I'm not sure how to get it there
12:35:41 <vaibhavsagar> nh2: can we add it to the cc-flags of the cabal file for zeromq4-haskell?
12:37:06 --- mode: glguy set +v euler2718
12:37:13 <nh2> vaibhavsagar: I tried that but it doesn't work
12:38:22 <vaibhavsagar> hmm, looks like there isn't a `cc-flags` anymore (if there ever was): https://www.haskell.org/cabal/users-guide/cabal-projectindex.html
12:38:26 <nh2> vaibhavsagar: I suspect it's because it passes the flag too early on the command line, it needs to be at the end
12:38:39 <nh2> vaibhavsagar: isn't it cc-options?
12:38:44 <thblt> Solonarv: Looked up your second solution.  IIUC, ReaderT is fundamentally a read-only environment (functions receive it, but don't modify it), but using a IORef for the state data makes it mutable, right?
12:38:44 <vaibhavsagar> instead there is `cc-options`, `cpp-options`, and `cxx-options`
12:41:15 <Solonarv> thblt: precisely
12:41:59 <Solonarv> so in this case your environment is a reference to a mutable cell which holds your state
12:46:45 --- mode: glguy set +v jammeeet
12:46:48 <vaibhavsagar> nh2: I tried setting `cpp-options: -lstdc++` and that might have worked, trying again with just that flag
12:47:45 <nh2> vaibhavsagar: I don't see how that would work, passing it to the c-preprocessor
12:47:46 <cocreature> vaibhavsagar: extra-libraries: stdc++ might also be worth a try
12:48:08 <vaibhavsagar> cocreature: that is set too
12:48:13 <cocreature> if you really want to specify it as an option ld-options seems most appropriate
12:48:25 <cocreature> if that is set then I would be surprised if -lstdc++ helps
12:48:42 <cocreature> (but I haven’t followed the full discussion so sorry if I’m missing something here)
12:48:45 <nh2> vaibhavsagar: I managed
12:48:49 <vaibhavsagar> well, it didn't work without it
12:49:39 <geekosaur> I'd be reallys urprised if cpp-options worked for that
12:49:45 <geekosaur> it's C preprocessor options, not C++
12:49:49 <nh2> vaibhavsagar: the solution is to do the same as I do here: https://github.com/nh2/static-haskell-nix/blob/ae18fc38f0a343e1e23e36e4986c725efd5712c0/survey/default.nix#L420
12:50:23 <vaibhavsagar> geekosaur: that is hilarious
12:50:26 * hackage tasty-ant-xml 1.1.5 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.1.5 (OliverCharles)
12:50:42 <nh2> the problem is that Cabal or GHC or both pass the options too early to the compiler, before the other -l flags that need C++ functions
12:51:17 <nh2> vaibhavsagar: with `--start-group` you can work around that, disabling the normal behaviour of the linker that you need to give files in order
12:51:23 <nh2> vaibhavsagar: I'll post you the solution in a bit
12:51:41 <cocreature> linkers are the worst
12:52:05 <vaibhavsagar> yeah, false alarm, it didn't work with `cpp-options`
12:52:27 <cocreature> iirc lld is at least somewhat better in that regard and doesn’t care about the order
12:52:44 <Amras> https://pastebin.com/raw/4Lhqp15U I am probably being an idiot here, but I could use the help
12:53:04 <cocreature> Amras: you’ll have to give us a bit more context, what is going wrong?
12:53:05 <Amras> x is type a, xs is type [a]. return x:xs is for some reason [[a]] instead of m [a]
12:53:29 <Solonarv> ooh, you're missing parentheses
12:53:33 <cocreature> return (x:xs)
12:53:37 <Amras> -_-
12:53:38 <Amras> right yes
12:53:40 <pounce> Gah, I need to make this faster
12:53:44 <cocreature> otherwise that parses as (return x):xs
12:53:45 <Amras> I think I need coffee then
12:54:10 <Amras> thanks
12:54:55 <nh2> vaibhavsagar: cocreature: `ghc-options:        -optl-Wl,--start-group -optl-lstdc++`
12:54:59 <nh2> this works for me
12:55:36 <cocreature> nh2: is there any way to get options to be passed in the correct order? seems kind of hacky to mess with --start-group here
12:56:25 <geekosaur> no, sadly
12:56:40 <geekosaur> and apparently no interest in doing so; "it works for dynamic linking"
12:56:56 <cocreature> :/
12:57:11 <geekosaur> your'e apparetly expected to use --whole-archive or the group stuff for static foreign libs
12:57:27 <cocreature> yeah I remember running into this myself at some point
12:58:15 <vaibhavsagar> nh2: is that missing any `=` anywhere?
12:58:42 <cocreature> soon we’ll all be using lld everywhere and everything will be great ;)
12:58:52 <vaibhavsagar> and can it go in `ld-options`?
13:01:26 <nh2> vaibhavsagar: no, why should there be a `=`? that is for your cabal file, while the thing I passed is a CLI argument
13:01:49 <nh2> vaibhavsagar: there are Cabal bugs that make that `ld-options` aren't passed on properly, so it likely must be ghc-options
13:01:53 <vaibhavsagar> ah, I see
13:02:33 <nh2> vaibhavsagar: I have cabal pull-requests open for this for a while now: https://github.com/haskell/cabal/pull/5451 but it takes forever for them to get merged
13:02:36 <vaibhavsagar> but wait, the thing you posted should go in the command-line?
13:02:51 <thblt> Solonarv: thanks again!
13:03:24 <nh2> vaibhavsagar: no, what I *linked* is passed on the CLI (the existing workaround for pkg-config packages in static-haskell-nix), and thus it has a =, the thing I posted goes straight in `zeromq4-haskell-repro.cabal`
13:03:40 <nh2> into the `executable` section (that's where I put it)
13:03:56 <nh2> cocreature: I'm sure with more cabal and GHC patching we can get things in the correct order
13:04:50 <vaibhavsagar> nh2: can it be added to the `zeromq4-haskell.cabal` to fix it at that level?
13:05:06 <vaibhavsagar> I realise these are all silly questions but I'm relatively new to this stuff
13:07:07 <vaibhavsagar> e.g. I had an issue where the haskell `mysql` package wasn't building correctly and the solution was to patch `mysql_config` to provide the correct linker flags
13:08:04 <vaibhavsagar> but it appeared to build fine and only demonstrated linker errors when I tried to build a package depending on it
13:11:36 <monochrom> cocreature: If I have a cyclic dependency between say two static libraries, will lld handle it too? >:)
13:13:19 <pounce> May I have some suggestions on making my program faster? I've been profiling it and I know where it's spending most of it's time, but I'm not sure how to improve it. (the file: https://ptpb.pw/gFUN/hs perf data: https://ptpb.pw/bsWL )
13:13:36 <pounce> I've tried switching from Map/OrdPSQ to IntMap/IntPSQ, but it doesn't make things must faster. I'd like to avoid that if possible
13:17:36 <monochrom> pounce: How big is your graph?
13:18:49 <pounce> 80^2 verticies with 1-4 connections each (but so far I only have it working on the 1-2 edge case)
13:19:21 <kadoban> Woh, and it's taking 300 seconds?
13:19:24 <nh2> vaibhavsagar: I'm not sure. You may also be able to do it from the nix side with `overrideCabal` and `appendConfigureFlag` like I did in what I linked, so that you don't have to do it in the .cabal file
13:19:50 <pounce> kadoban: if I time it it's taking several minutes, I'm not sure why it shows up in the perf as 300sec
13:19:57 <monochrom> I'm wondering if you have accidentally written an exponential time algorithm instead of Dijkstra's.
13:19:58 <vaibhavsagar> that's true, thanks
13:20:16 <pounce> monochrom: I may have XwX
13:20:18 <kadoban> Yeah, something about that is *way* off. Even like a n^4 algorithm should be only a few seconds
13:20:24 <vaibhavsagar> it would be nice to fix it for the package instead of all packages that depend on it
13:20:40 <monochrom> Because I'm seeing "f x = foldl' (a function that calls f) ..."
13:20:41 <pounce> it's not getting the right answer on some graphs anyway... i might just rewrite
13:22:50 <pounce> hmm, I wonder if I can factor the recursive stuff out of the fold
13:22:59 <pounce> I was originally thinking it was needed
13:23:22 <monochrom> reduce is not supposed to make any recursive call at all.
13:23:28 <nh2> vaibhavsagar: can you try it out? It might actually work, because the position of the argument can be a different one if the haskell zeromq-library's cabal file has it in
13:23:43 <pounce> I may have just thought about this wrong.
13:23:58 <vaibhavsagar> nh2: I did, but it didn't seem to work :(
13:24:58 <nh2> vaibhavsagar: in return for the debugging, could you file me an issue on static-haskell-nix that describes the problem, and quotes all relevant information from this channel? :P
13:25:09 <nh2> it would be very good to have this written down so people can refer to it
13:25:54 <nh2> and then we can go ahead and create a cabal bug and link that as well
13:26:00 <monochrom> I expect Dijkstra's to go like: dijkstra psq = extractMin from psq, psq' = update psq with edges of the vertex you extractMin'ed, dijkstra psq'
13:26:00 <monochrom> And there is no reason the "update psq with those edges" require calling disjktra.
13:26:06 <vaibhavsagar> nh2: sure!
13:26:26 <nh2> vaibhavsagar: thanks!
13:26:30 <dyl> Sidebar: read some of the old Dijkstra reports on THE. 
13:26:36 <dyl> God he was such an asshat. 
13:27:00 <dyl> It takes no less than halfway through the introduction for him to throw shade at all of his collaborators and subtly suggests they’re bad programmers. 
13:28:48 <pounce> monochrom: yeah, that's probably a good idea... That should make it one loop instead of many
13:28:50 <monochrom> I already outdo Dijkstra. I immediately right away state that 90% of my students are bad programmers and will stay bad programmers.  Bite me.
13:29:33 <pounce> O.o
13:29:54 <monochrom> The fact is they code like "f xs = .... head (tail (tail xs)) .... head (tail (tail xs)) ... head (tail (tail xs)) ..."  do you seriously expect me to do the postmodernist thing and congratulate them?
13:30:04 <dyl> monochrom where are you teaching? 
13:30:13 <pounce> Oh wow that's faster!
13:30:30 <monochrom> In other words they don't even have the courtesy to write "f xs = let y = head (tail (tail xs)) in ..."
13:30:36 <dyl> Also: it really grinds my goats how little instructors cared about code formatting and style in undergrad. 
13:30:45 <monochrom> In other words they don't even do the most trivial refactoring.
13:30:47 <dyl> Code isn’t just for computers, it’s for people too. 
13:30:55 <dyl> I don’t care if your code style is absurd, as long as its consistent. 
13:31:03 <monochrom> U of Toronto Scarborough
13:31:56 <monochrom> So give Dijkstra the benefit of doubt and consider the 50% possibility that Dijkstra's collaborators were really that bad and totally deserved it.  Because I know 90% of my students would do.
13:32:12 <pounce> monochrom: duuh you need lisp where you have the function cddaar which does that
13:32:27 <monochrom> (And no reason to believe that people 60 years ago were better than our next generation.)
13:32:35 <dyl> It’s just funny how he did it. 
13:32:48 <dyl> It was effectively a progress report, and he doesn’t name any of the collaborators. 
13:33:02 <dyl> And then notes that such a project could only be achieved with “exceptionally good programmers” or something like that.
13:33:04 <monochrom> pounce, it was actually Scheme. I translated it to Haskell-like syntax for #haskell.
13:33:13 <dyl> And this is right before explaining why it’s taking so long.
13:33:18 <pounce> (actually I think head (tail (tail xs)) would be cddar? )
13:33:23 <pounce> wait no
13:33:26 * pounce doesn't lisp
13:33:35 <dyl> We can’t all be the king of Spain’s 
13:33:37 <dyl> .*
13:33:52 <pounce> but yeah thanks monochrom that took it down two orders of magnatute
13:34:32 <monochrom> No problem.
13:35:06 <dyl> I think there should be some sort of required course in undergrad CS on “Social Aspects of Computing” or such. Cover code style, code review techniques, how to explain code and right *good* self documenting code, how to use VCS, etc. 
13:35:16 <dyl> Just basically “how to not aggravate everyone who reads your code”.
13:35:31 <dyl> write*... I just wrote “right good”...
13:36:01 <monochrom> And if you're wondering whether my students could be excused by "oh they have been doing OO for two-three years, FP is a struggle for them", the other courses that need their OO skill reveal that they have only understood up to "getters and setters".
13:36:08 <dyl> It’s frankly boggling that so many MS students STILL CANT USE GIT.
13:36:33 <pounce> yeah, they introduced git in my "lets all love C#" class and people don't understand it...
13:36:59 <dyl> I mean, I think Git is a classic example of "toxic abstraction".
13:37:09 <dyl> It makes way more sense when you actually dig into the graph model it uses.
13:37:16 <dyl> The porcelain is very grimy and misleading.
13:37:24 <pounce> yeah :/
13:37:32 <Amras> my uni had a course like that for first year students
13:37:35 <Amras> it didn't help
13:38:05 <Amras> what you'd want is to split the course up into like 4-8 hours each semester
13:38:08 <dyl> I think the bigger problem is that a lot of people see code as a disposable artifact that either qualitatively works or doesn't, rather than as a qualitative artifact that can be judged on beauty, style, elegance, etc.
13:38:11 <Amras> and make anyone who doesn't pass drop out
13:38:17 <dyl> So as a result they don't take pride in doing it well.
13:38:45 <Amras> unrelated thing: Can anyone here tell me why SocketStatus is deprecated and what I'm supposed to use instead
13:39:10 <geekosaur> more to the point, code is a means to an end and they care about the end. which is: money
13:39:13 <Amras> because having my server throw exceptions when a client disconnects doesn't seem like a good solution
13:39:33 <Amras> and yeah, bad code makes good money unfortunately :/
13:39:39 <Amras> 's why there's so many PHP and Java jobs out there
13:40:00 <Amras> have it barely work and be unmaintainable so the company can move on to the next piece of crap
13:40:05 <dyl> I think we're doing students a big disservice by not treating CS as what it actually is in practice: more a liberal art than a science.
13:40:18 <dyl> The single biggest programming skill imo? Ability to do research.
13:40:43 <dyl> The best programmers I've met are generally the fastest ones to go to a search engine and start doing research on the problem, existing solutions, etc.
13:40:47 <Amras> (that Socket thing is pretty urgent btw)
13:40:49 <pounce> algorithm: now fast but still doesn't work
13:40:54 <dyl> Amras I'm looking :p. 
13:41:13 <Amras> ^-^
13:43:11 <c_wraith> pounce, I bet you could make it even faster by hardolcoding your output and ignoring your input, as long as being correct isn't high-priority. :)
13:43:42 <monochrom> Um I think it should be "being general".
13:44:23 <c_wraith> sorry, I do know you're trying to make it right. just wanted to throw that classic joke in.
13:44:46 <monochrom> Sorry!
13:44:48 <pounce> problem82 = pure . const ANSWER -- this is what my friend's program got
13:45:33 <c_wraith> perfect!
13:45:46 <dyl> From what I can see Amras, it's deprecated as they want Socket to be a lot more abstract/opaque than it currently is.
13:46:15 <Amras> dyl: I think isConnected also doesn't provide the data it says on the tin, if I'm reading the docs right
13:46:37 <Amras> that said, it would be awfully nice to have a way to gracefully handle clients closing a connection
13:47:37 <Amras> I'm wondering if I should be using Exception and trying to catch after a send
13:48:29 --- mode: glguy set +v Y_Sharoda
13:48:51 <Amras> since I can't find any other way to handle this
13:49:15 <Amras> but it seems like such a trivial/common thing that there should be a more elegant solution
13:51:37 <monochrom> It is possible that you should try-send-catch-exception anyway. Even with ordinary files you're supposed to try-read/write-catch-exception rather than "are you OK? if yes I'll read/write, if not then I won't".
13:52:09 <Amras> hm... yeah, that's fair
13:52:24 <monochrom> Paranoically between the time "are you OK?" and "I read/write now" things could change so the status query is meaningless.
13:52:54 <Amras> even at the low level, an "isClosed" query would probably be implemented as "int ret = send(); if (ret<0) throw EverythingIsOnFire;"
13:52:57 <monochrom> More realistically a lot of these devices really don't know their real status until you try.
13:53:04 <Amras> yup
13:53:08 <Amras> that's a fair point
14:12:55 * hackage ghc-prof 1.4.1.5 - Library for parsing GHC time and allocation profiling reports  http://hackage.haskell.org/package/ghc-prof-1.4.1.5 (MitsutoshiAoe)
14:16:39 <dyl> Amras / monochrom : perhaps a more heterodox suggestion but
14:16:54 <dyl> I would generally advise against using the Haskell API for sockets, and just writing the networking layer of whatever it is in C.
14:17:02 <dyl> (If this isn't just a toy project.)
14:17:41 <dyl> Not because the Haskell APIs are bad, they're perfectly fine, but rather because networking code is generally rather chock full of unsafe code and it's going to be a lot more painful to debug in Haskell than in C. 
14:18:53 <monochrom> Hrm, that may be right.
14:18:56 <dyl> Additionally, if your program is intended to be cross-platform, you're going to want to do a lot of platform-specific stuff that won't be as easy to do as you'd like in Haskell. 
14:19:10 <dyl> For example, if you're on Darwin or BSD? You probably want to use kqueue and avoid epoll/select.
14:19:21 <dyl> If you're on Windows? You probably want to leverage IOCP where possible.
14:19:25 <monochrom> Yeah the Linux vs BSD divide is really annoying.
14:19:32 <dyl> If you're on Linux? You probably want to use the async variant of getaddrinfo.
14:19:45 <dyl> (where on Darwin and BSD you'd use a dispatch queue to get asynchrony)
14:20:51 <dyl> monochrom Linux needs to catch up :p.
14:21:03 <dyl> kqueue is to epoll/select as trebuchets are to catapults
14:21:06 <dyl> (that is, superior)
14:21:41 <dyl> Writing netcode with libdispatch over kqueue on Darwin and BSD is... remarkably pleasant.
14:22:16 <dyl> Sadly the Linux version of libdispatch has to use libkqueue which is not quite as good as native kernel support for kqueues.
14:22:25 <dyl> (But it's still a much nicer abstraction.)
14:22:28 <jjb> hello everybody!
14:22:31 <dyl> Hello!
14:23:11 <rlf> hello!
14:23:14 <dmwit> Dr. Nick here!
14:23:31 <dyl> dmwit you had to go and ruin our 3-letter username streak!
14:23:45 <dyl> ;p
14:23:46 <jjb> i LOVE dr nick!
14:24:13 <boj> dang
14:25:04 <jjb> one of the things that i have found frustrating in ghci has been my ability to have a data structure but no real way to know what i can do with it. i have configured it to respond to ":hoogle :: Foo -> Bar" but the results are not what I expect and I think I must have a fundamental misunderstanding
14:25:34 <jjb> e.g. when i ask for ":: Char -> Integer" i get Char -> Char and Integer -> Integer
14:25:51 <dyl> Hoogle is currently kinda broken :p.
14:25:59 <jjb> oh well that explains it!
14:26:06 <dyl> Both of them, rather. One of them works, but doesn't support type search. The other supports type search but doesn't quite work.
14:26:28 <jjb> is there a way i can dynamically interrogate the current runtime?
14:27:12 <jjb> (because lots of the time that is what i really want)
14:27:17 <dyl> In theory? Sure. In practice? Not that I know of.
14:27:22 <dyl> Type information is static after all.
14:27:48 <dyl> There is some work by some folks at UCSD on a "Hoogle+" which would do what you want (and even suggest compositions of functions).
14:27:57 <dmwit> Dynamically interrogate how?
14:28:16 <dyl> I saw a demo last week :p, it's very cool. It still has a ways to go and doesn't handle typeclasses thouh </3.
14:28:19 <jjb> "what functions in the current environment take an X as input" for example
14:28:31 <dyl> I wonder if you could use a typed hole :\?
14:28:48 <jjb> i am still quite a beginner on haskell so i don't even know what that means
14:28:55 <dmwit> I, too, would like this tool. At the moment, hoogling `X -> a` is about the best we've got.
14:28:55 <Amras> dyl: are you suggesting IPC or compiling C into the ghc binary?
14:29:04 <dyl> C FFI.
14:29:11 <dyl> IPC means you just have two problems now :p.
14:29:13 <dmwit> It is harder to do well than you might guess at first, though.
14:29:17 <dyl> You can do:
14:29:19 <dyl> > (_ :: Int -> String) 10
14:29:21 <lambdabot>  error:
14:29:21 <lambdabot>      • Found hole: _ :: Int -> String
14:29:21 <lambdabot>      • In the expression: _ :: Int -> String
14:29:26 <mnoonan> jjb: is that true with a recent-ish hoogle build? I've been working on fixing type search, and those shouldn't match (anymore)
14:29:28 <jjb> given that it doesn't exist i'm not surprised it's hard in practice!
14:29:41 <mnoonan> "that" meaning your Char -> Char example
14:29:46 <dyl> and on my end it will suggest show, mempty (?) and undefined.
14:29:59 <jjb> i am doing this from a current ubuntu with the default package sources, iirc
14:30:08 <dmwit> dyl: yes, mempty =)
14:30:12 <dyl> > mempty 10
14:30:14 <lambdabot>  ()
14:30:19 <dmwit> dyl: mempty :: a -> String = const ""
14:30:29 <dyl> Ooooh, for (->)
14:30:33 <dmwit> generally mempty :: Monoid b => a -> b = const mempty
14:30:59 <dyl> Anyhow, I'm rooting for the Hoogle+ folks :p.
14:31:09 <dyl> It'd be quite nice to have a working Hoogle again.
14:31:22 <dyl> Why did type searching stop working anyhow?
14:31:24 <mnoonan> jjb: Probably an older version, then. hoogle.haskell.org uses a nightly build and gives somewhat more sane search results now: https://hoogle.haskell.org/?hoogle=%3A%3A%20Char%20-%3E%20Integer
14:31:35 <jjb> ah, thanks!
14:31:48 <dyl> "Warning: Alpha version, type search doesn't work!" ;p
14:31:54 <jjb> sounds like it's worth re-pointing the pkg system at something more specific
14:31:55 <mnoonan> dyl: it literally wasn't implemented at all in hoogle 5, only a faster "fingerprint search"
14:32:05 <dyl> So basically just bag of words?
14:32:10 <mnoonan> more or less, yeah
14:32:23 <mnoonan> that's why it used to match "Char -> Int" for the query "Int -> Char" :|
14:33:53 <pounce> heh
14:34:29 <mnoonan> I implemented a unification-based type search in hoogle 5 that works kinda ok, and I'm now working on a trie-based search that I'm hoping will be performant enough
14:34:46 <safinaskar> is haskell context free lang? i. e. can it fully described by context free grammar
14:34:49 <safinaskar> ?
14:35:19 <__monty__> safinaskar: Except for layout, yes.
14:35:44 <safinaskar> i have read somewhere that haskell's rule "lambdas always go on to right as long as it is possible" doesn't allow haskell to be context free lang. is this true?
14:36:31 <__monty__> mnoonan: Does it still allow for unordered arguments though? Presupposes a multi-argument function view of things but sometimes that's what you want.
14:37:25 <mnoonan> __monty__: yeah, it actually isn't quite a trie but encodes all possible argument orders in a compact way. I almost believe that it works, even! :)
14:37:29 <__monty__> safinaskar: I don't see why, I'm no expert though. It doesn't sound past the power of regular languages even to me.
14:38:21 <mnoonan> the only problem is there are some cases where you may need to backtrack during the "trie" traversal, and I don't have a good feel for how common those will be in practice yet.
14:38:28 <__monty__> safinaskar: Well, obviously it is as soon as you introduce the matching of parens but I think a regular language + the lambda rule would still be regular.
14:39:37 <__monty__> mnoonan: Sounds interesting, I'll keep an eye on hoogle's improvements.
14:40:28 <dmwit> safinaskar: I believe fixity declarations take Haskell out of CFG-land.
14:41:01 <dmwit> I don't think "lambdas extend to the right as far as possible" is a dealbreaker for CFGs.
14:42:25 <dmwit> (GHC handles the fixity problem by re-associating everything in a second pass after the CFG-only part of the parser is finished.)
14:42:35 <monochrom> Regex's "maximum munch" and "minimum munch" neither never disqualified regex as regular.
14:42:40 <Amras> fixity?
14:42:50 <dmwit> Amras: Precedence and associativity declarations.
14:43:10 <dmwit> e.g. `infixl 9 foo` declares that when `foo` is used infix, it has the lowest possible precedence and associates to the left.
14:43:38 <dmwit> So getting the right parse tree requires the "context" of what fixity declarations are lying around.
14:45:03 <dmwit> % :i *
14:45:03 <yahb> dmwit: class Num a where; ...; (*) :: a -> a -> a; ...; -- Defined in `GHC.Num'; infixl 7 *
14:45:13 <dmwit> There's an example at the end there. =)
14:48:18 <pounce> My algorithm keeps getting the same answer even though it's wrong... :(
14:50:35 <jle`> hello
14:50:46 <jle`> i always mix up MonadPrim, Control.Monad.Primitive, PrimState
14:50:49 <safinaskar> dmwit: "I believe fixity declarations take Haskell out of CFG-land" - yes, possibly. but let's assume that we have some predefined set of operators with known fixity
14:51:01 <jle`> i write PrimMonad, MonadPrimitive, Control.Monad.Prim, StatePrim, etc.
14:51:04 <jle`> but never the actual one
14:51:35 <jle`> oh, i just did it again, it's actually PrimMonad, not MonadPrim
14:53:02 <monochrom> It is very annoying to write an unambiguous CFG that implements maximum munch. But it can be done.
14:53:55 <monochrom> Normally we write an ambiguous but simpler CFG and then add "resolve ambiguity by maximum munch".
14:54:04 <nshepperd1> I vaguely remember the two problems with cfg-ness of standard haskell being fixity and layout
14:54:58 <nshepperd1> Ghc haskell presumably has lots of bonus contextfulness thanks to all the language pragmas that change parsing
14:56:42 <safinaskar> let's assume we have very simple lambda calculus language.   the only operations are: add, multiply, function application, lambda abstraction, haskell-style "let" and "if". and we have have exactly haskell-style rules, including haskell's "lambda goes to right as far as possible". can such language be described by context free grammar?
14:56:58 <nshepperd1> Although, there's only a finite set of those so maybe not..?
14:57:06 <energizer> Hello, I am a python programmer. I saw some discussion about a concept called "recursion schemes" in Haskell, which seemed interesting to me. I'm curious how much prerequisite material there is before I could understand the basics of recursion schemes?
14:58:25 <nshepperd1> safinaskar: sure, i don't see why not
14:58:30 <monochrom> Language pragmas are required to be at a pretty predictable position so you can still stay CF.  But by the time you have "100 subgrammars, to be selected by the first few characters of the input" it's morally context-not-quite-free.
14:58:39 <amalloy> energizer: just the other day i finally read https://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/, an excellent intro to that topic. have you seen it? it starts by saying how much background you need
14:59:18 <energizer> amalloy: ah "the first few chapters", thanks
14:59:19 <monochrom> (And clearly anyone writing a sane parser for it will use context-sensitive tools.)
14:59:33 <energizer> amalloy: is that a realistic assessment in your view?
15:00:08 <amalloy> energizer: hard for me to say for sure. i have been doing hobby programming in haskell for years, so i don't have the right perspective
15:00:13 <monochrom> (Similarly if you have a 2^(8GB) finite state machine you just call it a Turing machine.)
15:01:02 <amalloy> if you just have those few chapters as background you will probably have to read the article quite carefully
15:01:22 <amalloy> but i think it does not assume much beyond those chapters
15:01:32 <energizer> amalloy: ok thanks
15:01:34 <safinaskar> monochrom: nshepperd1: language pragmas that affect parsing can be placed in the top of the file only
15:01:46 <safinaskar> monochrom: nshepperd1: so they don't make language non-cf
15:03:46 <__monty__> energizer: I'd just try reading that article. If you find you can't make heads or tails of the language examples then I'd read something like lyah or the wikibook.
15:04:49 <amalloy> specifically the chapters of lyah you'd most need would be, i guess, 3-6 and 8
15:04:52 <dmwit> It's sort of impressive how completely safinaskar and monochrom are talking past each other here.
15:15:55 * hackage axel 0.0.9 - The Axel programming language.  http://hackage.haskell.org/package/axel-0.0.9 (jgrosso256)
15:21:02 <pounce> Ok, so I have 4 functions which have the signature `Int -> a -> a -> bool`. Their first argument will all be the same, and I want to turn them into one function `a -> a -> bool` by or-ing them all together. Is there an easy way to do this?
15:21:11 <pounce> (I also want to do it with 2 and 3 of them)
15:22:09 <hpc> so, you have a variable number of functions with that type
15:22:33 <hpc> that's [Int -> a -> a -> Bool], and one Int
15:22:42 <hpc> and the other arguments are going to be the same too, or do you have 8 values of type a?
15:23:25 * hackage herf-time 0.3.0 - haskell time manipulation in a 'kerf like' style.  http://hackage.haskell.org/package/herf-time-0.3.0 (scottmurphy09)
15:23:43 <hpc> assuming they're the same too, your full type is [Int -> a -> a -> Bool] -> Int -> a -> a -> Bool
15:23:53 <hpc> to do something to each element of the list, you're doing a map
15:23:59 <hpc> and you want a function that applies all the parameters
15:24:28 <hpc> so (\f i a b -> f i a b) - taking the function in the list as a parameter too because you don't know which one it is
15:24:39 <hpc> :t map (\f i a b -> f i a b)
15:24:40 <lambdabot> [t1 -> t2 -> t3 -> t4] -> [t1 -> t2 -> t3 -> t4]
15:24:49 <hpc> er
15:25:13 <hpc> :t \i a b -> map (\f -> f i a b) -- you want the parameters that are the same OUTSIDE the map
15:25:14 <lambdabot> t1 -> t2 -> t3 -> [t1 -> t2 -> t3 -> b] -> [b]
15:25:32 <hpc> a bit of massaging in the function definition puts those parameters in the right order
15:25:41 <hpc> :t any -- and this collapses the list of Bools you get at the end
15:25:42 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
15:25:55 <hpc> pounce: that should be enough to write your function
15:26:04 <pounce> yep I think that'll help me out!
15:33:24 <energizer> what's it telling me? https://paste.gg/p/anonymous/ee9282b7fe3448b1a5a2f5c0fa798997
15:34:07 <glguy> You tried to use 1 as a String, but String isn't an instance of the Num type, and integer literals only work for types that are instances of Num
15:35:48 * energizer reads on
15:36:21 <pounce> Is `\f -> f a b` =  `($) a b` ?
15:36:31 <Solonarv> Yes
15:36:37 <glguy> no
15:36:37 <Solonarv> wait no
15:36:43 <pounce> :?
15:37:02 <glguy> `($) a b` is `a b`
15:37:05 <hpc> :t \f -> f a b
15:37:06 <lambdabot> (Expr -> Expr -> t) -> t
15:37:17 <hpc> :t ($) a b
15:37:19 <lambdabot> error:
15:37:19 <lambdabot>     • Couldn't match expected type ‘Expr -> b’ with actual type ‘Expr’
15:37:19 <lambdabot>     • In the first argument of ‘($)’, namely ‘a’
15:37:27 <ski>   ($ b) . ($ a)  =  \f -> f a b
15:37:32 <hpc> well, a and b have special definitions
15:38:58 <Solonarv> Sure, if they weren't defined then you'd get an error message saying as much
15:40:12 <pounce> hmm thanks
15:45:50 --- mode: glguy set +v Ulbrec
15:54:13 <pounce> \o/ solved the problem
16:00:01 <amalloy> is there a good mnemonic for how an expression like: foo <$> x *> y <*> z will parse? i had sorta expected foo <$> (x *> y) <*> z. i would also happily accept a suggested way to write such expressions that won't surprise me, short of wrapping everything with parens
16:01:42 <hpc> for the most part, it's like writing (foo x y z)
16:02:25 <amalloy> well, with <*> it would be. but *> and <* get weird
16:05:44 <safinaskar> hi
16:06:04 <safinaskar> very recently, say, two weeks ago i successfully browsed ghc sources online
16:06:08 <safinaskar> for example, here: https://ghc.haskell.org/trac/ghc/browser/ghc/compiler/deSugar/DsExpr.hs
16:06:13 <safinaskar> but now this link is dead
16:06:41 <geekosaur> there's a migration going on
16:06:42 <safinaskar> moreover, https://ghc.haskell.org/trac/ghc/browser/ghc/compiler now seems to show "git object storage" instead of usual ghc sources
16:06:49 <energizer> `readToInt x = read x :: Int` is there another way to write this function, so that it says, "this function takes an thing that when you read it gives an int, and returns an int"?
16:07:03 <safinaskar> geekosaur: is there some internet post about it?
16:07:58 <geekosaur> http://mail.haskell.org/pipermail/ghc-devs/2018-December/016677.html
16:08:57 <safinaskar> geekosaur: thanks
16:14:08 <jsjolen> The Wikipedia article on Hindley-Milner is great for learning about H-M but as an encyclopedia article it's disastrous
16:14:28 <safinaskar> why https://hoogle.haskell.org/?hoogle=semiIso finds nothing?
16:14:41 <safinaskar> there is http://hackage.haskell.org/package/semi-iso-1.0.0.0/docs/Control-Lens-SemiIso.html
16:17:05 <Bish> how would i group elements of a list in pairs, so that [1..] becomes [[1,2],[3,4]]
16:17:11 <Bish> same with 3 etc.
16:17:22 <safinaskar> mnoonan: you are hoogle author? please answer question above
16:18:36 <geekosaur> Bish, Data.List.Split.chunksOf
16:18:44 <geekosaur> (from the split package)
16:18:56 <Bish> ermagerd there is a whole package for that dask
16:19:08 <geekosaur> there's lots of ways to split a list
16:19:55 <Bish> god, i read the definition and it's so simple
16:20:00 <Bish> why didnt i come up with that
16:21:21 <Bish> geekosaur: oh but data.list.split isn't a default package
16:21:35 <Bish> is it?
16:21:48 <geekosaur> if your'e going to panic abotu default packages, you're going to be missing pretty much everything
16:21:56 <geekosaur> there's only a handful of bootlibs
16:22:13 <geekosaur> this list *shrinks* over time
16:27:12 <pounce> Is there a function that does \f x = f x x ?
16:27:41 <ski> > join f x    :: Expr
16:27:43 <lambdabot>  f x x
16:27:54 <dyl> @djinn (a -> a -> a) -> a -> a
16:27:54 <lambdabot> f a b = a b b
16:28:24 <dyl> This seems like something that’s probably in Data.Aviary. 
16:28:28 <dyl> It looks like a bird to me.
16:28:57 <MarcelineVQ> most people would think you're joking :>
16:29:07 <pounce> oh yeah! I remember hearing it was a bird
16:29:14 * pounce is guessing lark
16:29:51 <dyl> It’s warbler.
16:30:00 <amalloy> energizer: often simply `read` is enough, because the compiler will infer from context that you expect an Int in return
16:30:04 <Solonarv> % :t join @((->) _)
16:30:04 <yahb> Solonarv: (w -> w -> a) -> w -> a
16:30:14 <dyl> http://hackage.haskell.org/package/data-aviary-0.4.0/docs/Data-Aviary-Birds.html#warbler
16:31:14 <MarcelineVQ> some birds less birdy than others
16:31:34 <pounce> hmmm I swear I saw this somewhere else :x
16:34:56 <Bish> geekosaur: why isn't the implementation of chunkfsOf simpler like
16:35:03 <Bish> chunked i ls = [take i ls] ++ chunked i (drop i ls)
16:35:06 <Bish> is dropping expensive?
16:35:27 <Bish> i guess not
16:36:16 <geekosaur> dropping isn't, (++) can be, there's also laziness to consider
16:37:50 <MarcelineVQ> guessing it's written the way it is in order to fuse well
16:49:55 * hackage fast-logger 2.4.12 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.4.12 (KazuYamamoto)
16:50:26 * hackage wai-logger 2.3.3 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.3.3 (KazuYamamoto)
17:00:55 * hackage pretty-show 1.9.4 - Tools for working with derived `Show` instances and genericinspection of values.  http://hackage.haskell.org/package/pretty-show-1.9.4 (IavorDiatchki)
17:05:15 <Welkin> tough crowd tonight
17:06:06 <Solonarv> hm?
17:06:21 <Welkin> oh, there is life on this planet
17:27:37 <jackboy[m]> Which natural or hybrid language is easier to parse and understand by computer, humans (&animals as well if possible)?
17:30:53 <Welkin> computer "languages" are the easiest to understand because all terms are well defined
17:31:20 <Welkin> human languages are fluid and contextual, and nothing is well-defined
17:31:39 <jackboy[m]> Which one is easiest
17:31:43 <monochrom> COBOL, if you are OK with me saying it's a hybrid language.
17:32:18 <MarcelineVQ> I ​kind of like ini files.
17:32:26 <monochrom> Because "multiply x by y into z".  Someone even made a youtube video praising COBOL with "it's easy to debug because it reads like English"
17:33:01 <monochrom> IIRC COBOL is also fluid and contextual and have ill-defined corners >:)
17:33:01 <geekosaur> if only...
17:34:25 <monochrom> I mean clearly pretty tiny compared to English but also pretty glaring compared to say SML.
17:35:50 <monochrom> So anyway the natural side of COBOL is "multiply x by y into z" and the robot side is it has to be all caps and you have to put it at the correct column.
17:36:12 <monochrom> Yes I'm trying to establish a most-pointless-of-both-worlds story.
17:37:21 <geekosaur> of course, back then it was "every little bit helps" because there was nothing natural about working at keypunches
17:40:47 <monochrom> With that in mind, you would also wonder "if so, why make people spell out the whole bloody 'multiply' that's 8 letters there".
17:41:26 <monochrom> Ah but the other goal they were trying was "so managers can write code themselves and not need to interview and hire subordinate programmers"
17:41:51 <monochrom> In retrospect that's an oxymoron and completely misses the point of why some people want to be managers.
17:41:59 <geekosaur> yeep
17:42:21 <jackboy[m]> I think sign language is unique and easy to understand by all
17:42:27 <monochrom> You want to be managers precisely because you want to keep around subordinates to order around so that you can enjoy the power trip.
17:42:44 <jackboy[m]> Of course we may need to create more signs for more words though
17:42:53 <geekosaur> although I have to wonder how true that assertion is, given it came out of the Navy, not business
17:43:28 <monochrom> Ah so let's revisionist that to s/manager/commander/ hehe
17:43:30 <jackboy[m]> But at the end of the day, it has no grammar clutter and our mind don't need to form images from words of we start using sign language
17:44:31 <geekosaur> no, because that's even more explicitly "of course that lands on a private"
17:44:33 <Solonarv> Instead we need to form images from handsigns, which isn't inherently better
17:46:04 <Welkin> you don't think in images
17:46:08 <Welkin> you think in abstract ideas
17:46:33 <monochrom> How about we make a compromise. I think in abstract images. :)
17:46:45 <MarcelineVQ> ​I imagine plenty of people think in images :X
17:47:34 <Solonarv> I rarely think in images, I actually had a period where I'm somewhat certain I almost exclusively thought in words
17:47:56 * geekosaur thinks in concept hairballs
17:48:02 <monochrom> Actually not entirely false. For some scenerios I think up a Venn diagram in which each circle surrounds a lot of people (say) but I don't bother to also imagine those thousands of people points.  So it is an abstract image.
17:48:07 <MarcelineVQ> I'm not even sure what thinking in words means
17:48:47 <monochrom> Also the circle is abstract because it's only topologically homeomorphic to S^1 not geometrically a circle.
17:49:05 <Solonarv> Heh
17:49:23 <MarcelineVQ> Specifically I mean, I'm not sure what a word is in the mind
17:49:36 <monochrom> So my Venn diagram will have a potatoe a tomato and a worm.
17:50:20 <monochrom> Words in my mind sometimes manifests as glyph, some other times as sound bite.
17:50:56 <monochrom> Yes I am actually one of those rebels who play sound when I read text despite what all the teachers say against it.
17:51:18 --- mode: glguy set +v mnoonan_
17:51:28 <mnoonan_> safinaskar: sorry, just saw your question. I am not the author but I have been working on type search. Your search fails because the semi-iso package is not in the stackage package set, I think.
17:51:42 <Solonarv> I did kick the "think only in words" habit
17:53:00 <jackboy[m]> Which are best ways to remember and understand new  vocab in short time (I hate flash card technique)
17:53:29 <Welkin> spaced repetition, but fuck that
17:53:38 <Welkin> it's for rote memorization, not understanding
17:53:44 <monochrom> Hire a psychologist to electrcute you until you remember it?
17:53:45 <Welkin> understanding anything takes time
17:54:07 <monochrom> I mean you didn't say "cheapest".
17:54:52 <monochrom> And why are you asking in #haskell?  You are trying to learn "forall"?
17:55:22 <dmwit> monochrom: I'm shocked at you. How did you start answering without first demanding "what does 'best' mean?"?!
17:55:47 <monochrom> Oh I saw "in short time" towards the end. That does it.
18:01:21 <magicman> 
18:06:27 <MarcelineVQ> The answer is make your survival dependent on it.
18:06:36 <MarcelineVQ> You learn real fast if you'll die otherwise.
18:07:07 <aplainzetakind> MarcelineVQ: Any practical setups for that?
18:07:09 <MarcelineVQ> The other is flash cards. Anki is a good option.
18:07:18 <MarcelineVQ> aplainzetakind: hungry wolves cover a lot of cases.
18:07:49 <MarcelineVQ> Another one is to become indebted to a powerful person.
18:08:14 <MarcelineVQ> I'd stick with flashcards, Anki is a great option.
18:08:30 <Average-user> What parser library would you recommend, and why?
18:08:38 <MarcelineVQ> parsec, people know how to help you.
18:09:01 <Average-user> What about Happy?
18:10:05 <MarcelineVQ> never used it directly
18:10:22 <Solonarv> There's megaparsec too, which is quite similar to parsec
18:10:27 * hackage viewprof 0.0.0.26 - Text-based interactive GHC .prof viewer  http://hackage.haskell.org/package/viewprof-0.0.0.26 (MitsutoshiAoe)
18:12:53 <jackboy[m]> How memory and brain remember and stores new vocab and what's recalling process
18:13:12 <jackboy[m]> Is anki the only one effective methods for all
18:13:20 <OmegaDoug> Can anyone recommend a stateful approach to writing an assembler (exercise in nand2tetris). I need to generate a symbol table that will be referenced during the assembly process. I think I could take a stateless, two pass approach and first generate the symbol table and pass that to an assembly function. However, I think this would be a good change to get some experience with using state in Haskell.
18:13:31 <jackboy[m]> Or there are better hacks as well
18:13:54 <jackboy[m]> Person to person basis
18:14:27 <MarcelineVQ> OmegaDoug: oh neat, thanks for mentioning that
18:16:10 <OmegaDoug> MarcelineVQ:  no trouble. I take it you're a fan of nand2tetris?
18:16:40 <MarcelineVQ> No idea, sounds interesting
18:18:05 <OmegaDoug> MarcelineVQ: lol, I see. I'd recommend it. I've yet to find another resource which explains how computers work as well as this one. It's a really engaging book.
18:20:55 <Welkin> or you can study for a computer engineering degree
18:21:50 <Welkin> I'm actually very glad I chose that over computer science. I was able to avoid all kinds of bullshit like java and the "baby" version of microcontrollers
18:26:09 <OmegaDoug> No doubt, but that's a big commitment. 
18:26:18 <srk> how would you convert program such as sample = toCode [ unitsMM, move <> x 10, nop ] which creates a list of Codes converted from symbolic names into monadic code like sample = unitsMM >>= (move <> x 10) >>= nop?
18:26:21 <OmegaDoug> I'd consider CE if I could go back in time.
18:26:35 <maerwald> Welkin: hm, I didn't know there is a separate discipline
18:26:40 <maerwald> We don't have that in germany I think
18:26:50 <srk> which returns the same list (with writer or state?)
18:26:51 <Welkin> computer engineering is hardware and firmware
18:26:57 <maerwald> Ah
18:27:09 <Welkin> computer "science" is software that runs on top of all that
18:27:11 <maerwald> I thought it's something different
18:27:13 <Welkin> it's also a joke degree in the US
18:27:15 <maerwald> Like actual engineering =)
18:27:23 <Welkin> computer engineering is actual engineering
18:27:37 <Welkin> it is electrical engineering + low-level software (firmware/drivers)
18:27:42 <maerwald> Well, as much as computer science is engineering ;=
18:27:46 <srk> tell that to rocket engineers
18:29:02 <Welkin> "coding" bootcamps are the new java schools
18:29:14 <Welkin> become a developer in just 3 months!
18:29:23 <Average-user> But whit Computer engineering you lose all the theoretical and mathematical side of the thing
18:29:32 <Welkin> you do not
18:29:41 <Welkin> it is a specialty of electrical engineering
18:29:44 <Welkin> it has tons of math
18:29:51 <Welkin> "computer science" on the other hand has no math
18:30:02 <Welkin> it's not actually computer science, but they call it that
18:30:08 <Average-user> Yeah but math realted to pyshics, not discrete mathematics
18:30:08 <Welkin> it's more like "software development"
18:30:13 <maerwald> Welkin: uh, then you haven't been in image processing or computational geometry classes 
18:30:18 <maerwald> That is full of maths
18:30:20 <geekosaur> depends on the track. CS out of math departments does. CS out of business schools, not so much
18:30:23 <Welkin> no, you require lots of discrete maths in computer engineering
18:30:41 <Welkin> and statistics
18:32:55 <srk> looks like I just need to write a monad instance for my type similar to list
18:34:04 <Solonarv> Is is possible that you're talking past each other? The content of some particular degree does tend to vary between countries and even between schools in the same country.
18:38:30 <Welkin> I am talking about in the US in general
18:38:41 <srk> or theoretical CS studies had stuff like automatas, complexity, decidibility, lots of crypto. pretty good basis for lots of engineering stuff (not :D)
18:39:15 <srk> to be able to understand papers and calculus is really handy
19:11:39 <monochrom> A CS program can have (as mentioned) NP-completeness, halting problem, equivalence of regex and FSM, equivalence of CFG and pushdown automata, etc.  (A CE program is likely only going to do FSM as Moore machines and Mealy machines, and omit their relation with regex.)
19:11:58 <monochrom> OTOH a CE program is going to have Fourier transform and Laplace transform.
19:13:12 <monochrom> All of these varies by school, of course. A weak school is going to emphasize "we are so practical!" which is code for "we can't be sophisticated".
19:13:58 <glguy> Ooh, I like codes
19:15:36 --- mode: glguy set +v ACheesyName
19:15:59 <monochrom> A strong school OTOH is going to say nothing. You just see that their students learn theories for breakfast and build real stuff for lunch (and drink beer for dinner).
19:16:32 <kadoban> Haha
19:20:32 <monochrom> I had been in school for too long, but the benefit is I had a math program, a CS program, and half a CE program. I like them all. I couldn't quite articulate my opinion until I saw Donald Knuth said it beautifully: The best theory is inspired by practice. The best practice is inspired by theory.
19:21:38 <monochrom> Anyone who mock any one side is code for sour grape.
19:23:37 <ACheesyName> hello again. I'm looking for information on the (->) type. where would I find some?
19:23:54 <monochrom> What kind of information?
19:24:07 <ACheesyName> well, for starters, the source code of its definiton
19:24:20 <monochrom> But there is none. It's strongly built-in.
19:25:26 <ACheesyName> well then the kind of information that would help me solve exercise 3 on this page: http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
19:26:14 <glguy> How do you normally make and use functions?
19:26:58 <Solonarv> Are you having trouble understanding the ((->) t) syntax?
19:27:00 <monochrom> In that case study any Haskell textbook, study the parts that cover "function", "function definition" and "lambda" (how to make one), "function application" (how to use one).
19:28:15 <ACheesyName> Solonarv: yes. does ((->) t) mean an arbitrary function that evaluates to a type t?
19:29:01 <Solonarv> No. '(->) a b' means the same thing as 'a -> b'.
19:29:13 <Axman6> ((->) a b) === (a -> b), so ((->) a) is roughly equivalent to the (syntactically illegal IIRC) (a ->), or the type of functions which accept an argument of type a but we don't know what type is returned yet
19:30:00 <ACheesyName> ah thanks Axman6. so (->) is just a de-infixed -> in the normal manner. I see now
19:30:35 <Axman6> so Int -> String, Int -> Bool, Int -> Char -> IO () are all examples of things which fit into ((->) Int), ((->) Int) String, ((->) Int) Bool, ((->) Int) (Char -> IO ())
19:30:35 <Solonarv> Oh, you're already familiar with using () to make an operator prefix - that helps :D
19:30:44 <Axman6> yep
19:31:03 <Axman6> it takes some getting used to, and it's annoying we can't use (r ->)
19:33:21 <monochrom> I have objection to "((->) a) is the type of functions which ...".
19:34:07 <geekosaur> as opposed to problms with the rest of it?
19:34:14 <monochrom> In this case it is actually unnecessary to say in words what it means. The real meaning is in how it instantiates the type of furry.
19:34:54 <monochrom> "instance Fluffy ((->) t))" means furry :: (a -> b) -> ((->) t) a -> ((->) t) b.
19:36:02 <monochrom> Yes geekosaur. ((->) a) has the wrong kind to be a type of any collection of functions.
19:37:37 <monochrom> Do people learn and play Chess anymore?
19:38:14 <ACheesyName> I gave up Chess when my ELO slipped under 750
19:38:26 <monochrom> Because Chess is an example in which you don't worry about what "rook" means, you just learn its rules and learn to deal with it. I.e., a formal system, a system in which the only meaning is the formalism.
19:39:32 <glguy> You never learned what rook means?
19:39:47 <monochrom> I never looked up the dictionary.
19:40:31 <monochrom> I saw a piece that looks like a castle and it's spelled "r o o k". I said "whatever" and read the rule and started using it.
19:41:23 <monochrom> I said "whatever" because a real castle can't move so clearly this is another monad burrito story that you'd better just play along and be done with it.
19:41:37 <kadoban> Doesn't it mean like chariot or something weird?
19:41:45 <kadoban> I never understood how that matched the shape of the piece
19:42:10 <monochrom> With a chariot you would then question why it can't move like a bishop.
19:43:09 <monochrom> Down this road is just a whole can of worms with a rabbit hole inside the can because next why a queen can do both bishop things and rook things.  Hell wasn't it true that females couldn't be bishops?
19:43:29 <monochrom> It can go on and on to nowhere if you ever ask "what does it mean?"
19:43:38 <monochrom> I means nothing. It's a formal system. Deal with it.
19:44:12 <infinisil> Hey, I'm using `bracket setup teardown application` in the hopes of teardown running in any case
19:44:28 <infinisil> But when the application is running in systemd and I restart it (SIGINT?) It doesn't run!
19:44:45 <infinisil> Anybody an idea what's up with that?
19:46:25 * hackage juicy-draw 0.2.0.0 - Draw and fill lines, rectangles and polygons  http://hackage.haskell.org/package/juicy-draw-0.2.0.0 (rcook)
19:47:36 <glguy> infinisil: Is it running on the main thread?
19:48:04 <infinisil> It does have a background thread, but the bracket is on the main one for sure
19:48:27 <glguy> Do you know what signal is actually being sent?
19:49:03 <infinisil> Ah, just looked it up, it's SIGTERM
19:49:25 <infinisil> Which I think should be handled?
19:49:57 <glguy> I don't think that one's handled be default, no
19:50:15 <infinisil> Ah darn
19:50:27 <monochrom> Or more treacherously, handled but doesn't turn it into an exception for you.
19:50:49 <monochrom> Approximately only SIGINT is promised to be turned into UserInterrupt
19:51:38 <infinisil> Hmm, so how do I handle SIGTERM then?
19:51:45 <monochrom> But you can load up System.Posix.Signals and add a handler that throws an exception of your choice to a thread of your choice.
19:52:37 <monochrom> (The handler you write will be run in a brand new thread.)
19:52:50 <safinaskar> mnoonan_: thanks. how to search whole hackage, not just stackage?
19:53:34 <glguy> https://gist.github.com/glguy/c8d6822166192666af0f4272599b2cef
19:53:40 <glguy> infinisil: Something like this would be a start
19:54:11 <infinisil> Hmm I see thanks
19:54:42 <infinisil> Actually I think I can use this: https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-Signals.html#v:awaitSignal
19:55:15 <infinisil> Or from the text is seems like a bad idea
20:22:58 <energizer> lyah says  `head' :: [a] -> a` but the interpreter says s Variable not in scope, what am i doing wrong?
20:27:26 <lyxia> Where does it say that
20:28:19 <energizer> lyxia: http://learnyouahaskell.com/syntax-in-functions#pattern-matching
20:29:19 <lyxia> then it seems you didn't define or load head'
20:29:52 <energizer> but the definition appears below that
20:30:13 <geekosaur> yes, it's having youdefine an alternative to the biltin
20:30:21 <geekosaur> the real one doesn't have a ' appended
20:30:40 <energizer> so how can i get to the definition if it errors before it gets to that part?
20:30:50 <geekosaur> in ghci, put it on the same line with ;
20:31:09 <lyxia> wait are you putting the definitions in a file
20:31:17 <lyxia> and does the error come from loading that file
20:31:27 <energizer> no not in a file
20:31:41 <ephemient> you can also wrap multi-line ghci statements in :{ .. :}
20:32:14 <geekosaur> ghci reqires stuff in the same binding group to be read together. either use :{ :} to enter multiple lines, or combine lines with semicolons
20:32:35 <energizer> i see, thanks
20:32:36 <geekosaur> files are more flexible, but ghci unlike ghc can't see what you're going to type next
20:33:37 <ephemient> also https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#multiline-input
20:58:39 <nshepperd> phew, finally finished with AoC #12
20:59:29 <nshepperd> I learned what StableNames are good for
21:05:04 <kadoban> nshepperd: What's the second part of it? Anything interesting?
21:05:39 <nshepperd> well, it wants you to simulate the 1d automaton for 50 billion steps
21:05:47 <nshepperd> so i ended up implementing hashlife
21:07:55 <nshepperd> in the process figuring out how to do hash-consing in haskell based on StableNames
21:09:16 <zearen> Is this an okay place to ask about build issues with cabal new-build ?
21:09:53 <MarcelineVQ> yes
21:11:22 <zearen> Alright, so I'm trying to build taffybar locally, but GHC can't find some packages when executing Setup.hs for many of the dependencies.
21:11:55 <zearen> It's like cabal is ignoring setup-depends, and I don't really know how to trouble shoot this.
21:12:04 <zearen> Gimme a sec to get logs.
21:14:58 <zearen> Aww, where did hpaste go ?
21:15:46 <geekosaur> gone
21:16:31 <energizer> "These two pieces of code do the same thing and are interchangeable:" http://learnyouahaskell.com/syntax-in-functions#pattern-matching
21:16:39 <energizer> which two?
21:16:57 <MarcelineVQ> the two head' versions, with and without case
21:17:15 <geekosaur> imediately following that statement
21:17:41 <energizer> oh it looks different with/without js
21:19:35 <kadoban> nshepperd: Oh, that's cool
21:20:04 <kadoban> 1D hashlife, that's a pretty decent little mini project
21:22:23 <zearen> https://pastebin.com/mh3rdjQi
21:23:32 <zearen> When I check, it appears the required packages are in the store, so *shrug*
21:23:50 <zearen> I looked for bugs, but I couldn't find one that matched this.
21:24:05 <geekosaur> packages yes, files not necessarily.
21:24:10 <geekosaur> first: is this arch?
21:24:22 <zearen> Oh boy.  Yes it is.
21:24:35 <geekosaur> yep. they removed al the static archives. force -dynamic build
21:25:33 <geekosaur> or remove the arch library packages and install them yourself via cabal
21:25:35 <zearen> I mean, these packages are in .cabal/store, not installed at the OS level.
21:25:38 <geekosaur> or remove the arch library packages and install them yourself via cabal
21:25:44 <zearen> I have ghc-static anyway ^^;
21:25:56 <zearen> I took that second approach.
21:26:05 <geekosaur> ghc-static doesn't install static libs for the packages not included with ghc
21:26:52 <zearen> Noted.  So maybe just add ghc-opts: -dynamic to cabal.project.local ?
21:27:25 <geekosaur> I';m not sure. if you actally installed those packages locally, they should be complete
21:27:41 <geekosaur> possibly: cabal new-exec ghc-pkg check
21:27:55 * hackage mono-traversable 1.0.10.0 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-1.0.10.0 (MichaelSnoyman)
21:29:56 <zearen> Everything checks out (save for a bunch of warnings about haddock, but they're irrelevant].
21:31:54 <geekosaur> youmigt try the dynamci build anyway, if you are getting those two packages from arch instead of local install (haskell-gi and cabal-doctest)
21:32:32 <zearen> Oooh, now this is curious.  When I do the analogous ghc-pkg list, the required packages aren't listed.
21:33:03 <geekosaur> they wo't be
21:33:35 <geekosaur> newstyle cabal keeps its own private package databases, which is why I had you use "cabal new-exec"
21:33:49 <geekosaur> which can see the package db it assembled specifically to build this
21:34:34 <zearen> Yes, I ran `cabal new-exec ghc-pkg list`.  That's what I meant by "analogous".  Sorry for the lack of clarity.
21:34:51 <nshepperd> kadoban: yep, a little easier than the 2d hashlife i think (or at least easier to wrap my head around the geometry), but still a lot to learn
21:37:05 <zearen> When I try to new-install them directly, cabal tells me they're up to date.
21:37:18 <zearen> --reinstall doesn't anything.  Hmmm...
21:38:31 <sclv> i've seen weird stuff with new-install and cairo before
21:39:43 * geekosaur has no idea at thsi point
21:40:12 <geekosaur> aside from possibly that both of those are running into setup-depends related problems
21:40:52 <zearen> Yeah, I solved the Cairo issue with --allow-newer=Cabal, but this seems to be different.
21:41:24 <zearen> I'll have to try and go for a minimal case for repro then...
21:44:43 <sclv> zearen: what version cabal?
21:44:51 <geekosaur> re setup-depends, I recall both thoe packges having issues with it
21:45:01 <sclv> all these issues are about setup-depends
21:45:16 <geekosaur> you could try a newer cabal-install, but you may also have to ask in #hackage where there's more experts on this stuff
21:45:17 <sclv> iirc setup-depends doesn't play with the dynamic-only path
21:46:48 <geekosaur> but iirc you can get a similar looking error if Setup tries to build and use modules in the package it'sintended to set up (gi does this in particular, ad iirc so does cabal-doctest)
21:47:34 <geekosaur> kind of an evil hack that just happened to work when Setup wasn't package visibility constrained, but both cabal new-* and stack have trouble with it
21:50:15 <zearen> sclv: 2.4.0.1 IIRC ?
21:50:53 <zearen> 2.4.0.0 built with 2.4.0.1 whatever that implies o.O
21:51:02 <sclv> ok that's sufficiently recent
21:51:09 <sclv> its interesting its setup-depends in combo with arch
21:51:10 <geekosaur> cabal-install and the Cabal library are different things
21:51:16 <sclv> even tho you say you have all the static stuff installed
21:52:10 <sclv> as i said i think the dynamic flag doesn't scope over setup-depends stuff
21:52:23 <sclv> so it could be you have the dynamic versions but the setup-depends is looking for the static ones
21:52:38 <jjb> using QuickCheck, is there a way to use my own `arbitrary` function for an existing datatype, or do i have to define a newtype and add an arbitrary instance, etc?
21:52:52 <geekosaur> oh, hm. I don't know if it even passes -dynamci when building Setup
21:52:59 <geekosaur> that couldbe ugly
21:53:04 <jjb> arg i'm sorry, called afk, will be back soon i hope
21:53:50 <geekosaur> @tell jjb the work is done by a typeclass, so you would need a newtype with its own Arbitrary instance
21:53:50 <lambdabot> Consider it noted.
21:53:58 <zearen> That would make sense.  All I see in the store under the relevant packages are *.so and *.dyn_hi
21:54:34 <geekosaur> oh,t hat was whayoumeant earlier
21:54:35 <geekosaur> sorry
21:55:02 <zearen> Meh, debugging over IRC is difficult :p
21:55:43 <zearen> I wonder if there's a way to configure the ghc invocation for Setup.hs...
21:57:07 --- mode: glguy set +v u0_a336
21:57:45 <u0_a336> sup..
21:57:47 <u0_a336> sup..
21:57:49 <u0_a336> sup..
21:59:46 <zearen> I wonder if there's a way to configure the ghc invocation for Setup.hs...
21:59:52 <zearen> Er, oops.
22:00:18 <zearen> I do have a minimal repro, so I guess I'll file an issue.
22:01:20 --- mode: glguy set +v donnut
22:01:27 <donnut> cepot..
22:01:38 <u0_a336> ??
22:01:41 <donnut> cepoooooot...
22:01:46 <u0_a336> np
22:01:49 --- mode: ChanServ set +o monochrom
22:01:52 <donnut> rpp..
22:02:05 --- mode: monochrom set -o monochrom
22:03:00 --- mode: ChanServ set +o geekosaur
22:03:45 <MarcelineVQ> odd, children should be in bed by now.
22:03:52 --- mode: glguy set +v u0_a336
22:04:14 --- mode: glguy set +v donnut
22:04:28 <geekosaur> this is not the channel for that
22:04:57 <donnut> ow im so sorry.. [geekosaur]
22:05:37 <donnut> whos on..
22:05:44 <u0_a336> i
22:05:47 --- mode: glguy set +b *!*@120.188.86.5
22:06:16 --- mode: geekosaur set -o geekosaur
22:06:29 <geekosaur> I hd a omewhat tighter mask set up, but don't quite trust it
22:08:40 <sclv> personally my desire is to remove support for dynamic only from ghc as well
22:08:44 <sclv> rather than support it better
22:08:55 <sclv> if ghc can't even do it, then that'll stop arch from trying to and confusing everyone :-)
22:12:55 * hackage stripe-concepts 1.0.0.0 - Types for the Stripe API  http://hackage.haskell.org/package/stripe-concepts-1.0.0.0 (chris_martin)
22:13:46 <nan`> if one of my project's "extra-dep"s is a directory, is there any way to get 'jump to definition' to jump 
22:14:27 <nan`> (for stack)
22:14:53 <nan`> stack/intero
22:17:07 <zearen> I think I solved it with --ghc-option=-dynamic.
22:17:41 <zearen> I should probably write this up somewhere so the next poor soul can Google search for it.
22:18:04 <zearen> Bleh, I don't want to manage a dev blog though Xþ
22:18:41 <geekosaur> arch wiki?
22:20:31 <zearen> That's a good idea ^.^
22:21:55 * hackage stripe-signature 1.0.0.0 - Verification of Stripe webhook signatures  http://hackage.haskell.org/package/stripe-signature-1.0.0.0 (chris_martin)
22:23:06 <suzu> ^ whats up with this donnut guy
22:24:43 <geekosaur> going by nicks and host (singular) those may have been some kind of bot(s)
22:28:49 <suzu> ic
22:29:34 * hackage stripe-wreq 1.0.0.0 - Use the Stripe API via Wreq  http://hackage.haskell.org/package/stripe-wreq-1.0.0.0 (chris_martin)
22:32:25 * hackage stripe-scotty 1.0.0.0 - Listen for Stripe webhook events with Scotty  http://hackage.haskell.org/package/stripe-scotty-1.0.0.0 (chris_martin)
22:39:15 <jjb>  thanks @geekosaur!
22:42:01 <zearen> Arch Wiki updated.  Thanks for the advice :)
22:42:54 <jjb> oh look i made it work! *pats self on back*
22:44:38 <nyc> It'll be nice if I can get my hands on the equipment to write code again.
22:45:23 <coldpress> what is the best way to parse GADTs? https://en.wikibooks.org/wiki/Haskell/GADT
22:45:57 <cocreature> coldpress: I’m not sure I understand your question. Are you writing your own Haskell parser?
22:46:16 <coldpress> i used the solution here: https://stackoverflow.com/questions/11104536 but I can't derive (Show) for the existentially quantified AnyExpr type
22:46:18 <c_wraith> coldpress: if you know what type the top-level expression will have, the normal stuff works
22:46:24 <nyc> I need to get on board the GADT train at some point.
22:46:29 <cocreature> oh you want to parse some string into a GADT, I see
22:46:47 <c_wraith> coldpress: if you don't know what type the top-level value will have, you need an existential wrapper
22:46:49 <coldpress> c_wraith: Some expressions evaluate to Int, some to Bool, so the top-level must be either a Sum type (ugly) or an existential type
22:47:22 <coldpress> now i want to (Show) the parsed existential AST in GHCi, but I can't make a standalone deriving declaration
22:47:25 <cocreature> GADTs are one of the places where existentials are actually pretty reasonable
22:47:59 <c_wraith> coldpress: then just write the instance by hand?  It should be a one-liner.
22:48:17 <cocreature> assuming you already have the instance for the actual GADT :)
22:49:20 <cocreature> what happens if you try to standalone derive it?
22:49:45 <c_wraith> probably the same thing as if you try to normal-derive it.  an error about existentials and deriving show
22:51:05 <c_wraith> which is a totally reasonable error message, except in the case where a GADT lets you recover all the necessary type information.
22:52:38 <cocreature> well it actually does work for me
22:53:00 <c_wraith> maybe ghc has become smarter about that recently?
22:53:06 <cocreature> so I’m wondering if the Show instance for Expr is the problem here. it should be "instance Show (Expr a)" not "instance Show a => Show (Expr a)"
22:53:46 <c_wraith> hmm, maybe GHC derives the wrong constraints when making Show for a GADT
22:54:14 <cocreature> right, I’ve definitely seen that happen. I would write the instance myself
22:54:28 <c_wraith> or standalone it
22:54:40 <c_wraith> So you can explicitly put no constraint in place
22:55:07 <coldpress> right, lemme try :)
22:56:40 <coldpress> i'm just having trouble thinking what a `show` for an existential type would be, since there's no way to recover the type after it's been untyped (right)?
22:57:03 <c_wraith> In general, that's true.  But a GADT lets you recover the type
22:57:24 <c_wraith> ...  or at least it can, if the constructors are set up that way
22:57:28 <cocreature> also if you have "instance Show (Expr a)" you don’t need to recover a in the Show instance for the existential
22:57:37 <cocreature> as the instance doesn’t require any constraints on a
22:57:49 <c_wraith> right.  that's the more important part.
22:58:01 <c_wraith> I misunderstood the question so went off on a tangent.
23:01:01 <coldpress> c_wraith: i'm not sure if I understand how to recover the type, is it by declaring `data Expr a where ...`?
23:01:18 <c_wraith> Well, first off.  are you sure you need to?
23:01:34 <c_wraith> You shouldn't need to for a Show instance for the wrapper.
23:02:19 <coldpress> Ooh I think i got it working, just had to add some constraints within AnyExpr
23:02:42 <cocreature> no, don’t do that. fix your Show constraint on Expr so it doesn’t require a constraint on a
23:03:57 <coldpress> cocreature: thanks! that really helped
23:19:39 --- mode: glguy set +v cr0d_
23:32:51 <energizer> how do i make an infix function prefix? like (++ "a" "b") to get "ab" 
23:33:08 <energizer> s/prefix/into a prefix function/
23:33:39 <geekosaur> wrap it in parens
23:33:45 <geekosaur> > (+1) 1 2
23:33:45 <geekosaur> er
23:33:46 <geekosaur> > (+) 1 2
23:33:47 <lambdabot>  error:
23:33:47 <lambdabot>      • Could not deduce (Num t0)
23:33:47 <lambdabot>        from the context: (Num (t -> t1), Num t)
23:33:49 <lambdabot>  3
23:34:20 <energizer> thanks
23:36:48 <energizer> can i make + into a postfix function?
23:37:50 <energizer> so 1 2 +  makes 3
23:37:56 <dminuoso> energizer: No.
23:38:19 <geekosaur> not as such. there's an extension which abuses section syntax tomake unary postfix operators, but that's it
23:38:37 <energizer> ok
23:38:40 <dminuoso> geekosaur: Curious, which extension is that?
23:38:58 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#postfix-operators
23:39:11 <[Leary]> > 1 & 2 & (+) -- The closest thing we have to postfix functions is this.
23:39:13 <lambdabot>  error:
23:39:13 <lambdabot>      • Could not deduce (Num a0)
23:39:13 <lambdabot>        from the context: (Num (a -> a1), Num a1, Num a)
23:39:27 <[Leary]> Hmm, is the fixity not write for that?
23:39:31 <[Leary]> right*
23:39:46 <[Leary]> > 1 & (2 & (+))
23:39:48 <lambdabot>  3
23:43:14 <jle`> yeah, the fixity of & is meant to be chainable
23:43:25 <jle`> > 10 & negate & (+2)
23:43:27 <lambdabot>  -8
23:44:43 <dminuoso> Not a big fan of postfix operators.
23:45:14 <dminuoso> I blame mathematicians for making them up.
23:45:34 <glguy> Anyone have a favorite FIFO queue implemention in a package? Preferably with some nice pattern synonyms, probably implemented with two linked lists?
23:46:19 <jle`> dminuoso: postfix is actually usually used in an operationa/comp sci sense, i think
23:46:28 <jle`> as stack-popping
23:46:53 <jle`> during my college years i 'thought' in postfix a lot because i used an RPN calculator to do most of my number crunching
23:47:05 <jle`> glguy: TChan? ;)
23:47:40 <jle`> glguy: oh actually i remember now, in the past, the data structure i always used for a queue
23:48:13 <jle`> that had O(1) enqueue and dequeue
23:48:46 <jle`> and is offered by a core package in the haskell ecosystem
23:50:20 <jle`> i'm sorry that i blanked out when you asked before :)
23:51:23 <dminuoso> jle`: I mean Im sure that it's used in some fields, but for actual programming it's a poor fit because it causes you to scan with your eyes much more to mentally read code.
23:51:55 <jle`> dminuoso: right it's bad for writing code, but it's good to manipulate as an AST
23:52:41 <dminuoso> I guess in a way this is one of the few redeeming features of lisp - simplicity of the syntax.
23:53:01 <MarcelineVQ> few? poor lisp, don't listen to the mean man
23:54:36 <jle`> dminuoso: one of the common tricks for writing a (a + b * c) etc. calculator in an imperative language is to parse it into postfix, and just do iterative stack pushing and popping
23:55:07 <jle`> but i guess it's not postfix "notation" here, but postfix representation
23:55:39 <dminuoso> jle`: Mmm, you could do the same in prefix notation as well.
23:55:58 <jle`> prefix notation, you get a tree representation of sorts
23:56:08 <jle`> but postfix you get a nice imperative stack based implementation
23:56:30 <jle`> because you have `b c * a +`
23:56:40 <jle`> is "push b, push c, pop 2, push a, pop 2"
23:57:15 <jle`> 'b' is "push b", '*' is 'pop 2, and push back their product'
23:59:23 <jle`> @let interp (Left x:ns) stack = interp ns (x:stack); interp (Right f:ns) (x:y:stack) = interp ns (f x y:stack); interp [] (x:_) = x
23:59:24 <lambdabot>  Defined.
23:59:49 <jle`> > interp [Left 3, Left 4, Right (*), Left 9, Right (+)]
23:59:51 <lambdabot>  <[Integer] -> Integer>
23:59:55 <jle`> > interp [Left 3, Left 4, Right (*), Left 9, Right (+)] []
23:59:57 <lambdabot>  21
