00:02:16 --- mode: glguy set +v Aalind
01:39:06 --- mode: ChanServ set +o glguy
02:19:25 * hackage xmonad-extras 0.15.1 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.15.1 (psibi)
04:26:00 <nan`> does template haskell do some caching? It seems like sometimes if i add, for example, a fail to the compile-time code, it is not picked up at next compile unless i also edit the actual result for running at runtime
04:29:00 <nan`> the caching that it is doing seems buggish to me, but i'm new to it
04:37:25 * hackage proteome 0.3.15.0 - neovim project manager  http://hackage.haskell.org/package/proteome-0.3.15.0 (tek)
04:38:55 <slaterr> @hoogle (a, b, c) -> c
04:38:55 <lambdabot> Data.Tuple.Utils fst3 :: (a, b, c) -> a
04:38:56 <lambdabot> Data.Tuple.HT fst3 :: (a, b, c) -> a
04:38:56 <lambdabot> Text.Regex.TDFA.Common fst3 :: (a, b, c) -> a
04:39:14 <slaterr> no such function?
04:43:13 <Axman6> if you're happy with lens it's view _1
04:44:08 <Axman6> :t view _1
04:44:09 <lambdabot> (Field1 s s b b, MonadReader s m) => m b
04:44:38 <Axman6> :t view _1 `asAppliedTo` (1,True,"hello")
04:44:39 <lambdabot> Num a => (a, Bool, [Char]) -> a
04:45:25 <slaterr> > view _3 (10,20,30)
04:45:28 <lambdabot>  30
04:45:58 <devoid> :t error
04:45:59 <lambdabot> [Char] -> a
04:46:17 <slaterr> thanks. probably not worth to bring in lens for such a small project, and just for this, but I'll keep it in mind in the future
04:57:22 <int-e> @hoogle thd3
04:57:23 <lambdabot> Data.Tuple.Utils thd3 :: (a, b, c) -> c
04:57:23 <lambdabot> Data.Tuple.HT thd3 :: (a, b, c) -> c
04:57:23 <lambdabot> Text.Regex.TDFA.Common thd3 :: (a, b, c) -> c
04:58:06 <int-e> (lucky guess)
04:59:24 <slaterr> is that the same function, rexported, or each library defined its own?
05:19:03 <slaterr> both getLocalTime or getZonedTime return local time, or time in the time zone computer is set to. so which one should I be using?
05:19:43 <slaterr> I need current day of the week and time 
05:21:50 <slaterr> confusing.. zonedTimeToLocalTime <$> getZonedTime returns IO LocalTime, while getLocalTime returns IO SYSTEMTIME
05:27:55 <dmwit> ?tell nan` GHC's own recompilation-checker knows about TH and should Do The Right Thing. If your TH depends on external files, you can use addDependentFile to inform GHC. Unfortunately cabal v2-* doesn't get the check quite right, so perhaps that's what you're seeing.
05:27:55 <lambdabot> Consider it noted.
05:36:17 <mpickering> Is there a pre-baked solution in brick for applications which need to have multiple pages
05:36:36 <mpickering> for instance, I need to handle keypress events differently in each context
05:37:02 <mpickering> it seems quite bad to have to add a flag to the global state to indicate the context and then case on it to determine what to do on each keypress
05:49:33 <dmwit> That... seems very natural to me. Why does it seem bad?
06:05:55 * hackage unbeliever 0.8.0.0 - Opinionated Haskell Interoperability  http://hackage.haskell.org/package/unbeliever-0.8.0.0 (AndrewCowie)
06:12:06 <slaterr> is there a higher order function I could have used in here instead of manual recursion? https://pastebin.com/yBH8f5S5
06:13:20 <mpickering> dmwit: If I have 50 different contexts in my application then having a 50 way case in the Enter handler doesn't seem great
06:13:28 <mpickering> I suppose I can define a handler for each context and then chain them together
06:13:39 <[Leary]> :t until -- slaterr
06:13:40 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
06:15:03 <mpickering> or not even chain them together and just dispatch first based on the context
06:15:42 <slaterr> [Leary] perfect.. I was suspecting that something like that existed.. should have hoogled
06:15:54 <slaterr> > until (>10) (+) 0
06:15:56 <lambdabot>  error:
06:15:56 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ a -> a
06:15:56 <lambdabot>        Expected type: (a -> a) -> a -> a
06:16:02 <slaterr> > until (>10) (+1) 0
06:16:04 <lambdabot>  11
06:16:10 <LKoen> > until (>= 100) ((+) 1) 50
06:16:12 <lambdabot>  100
06:16:34 <LKoen> ooookay
06:17:18 <slaterr> nextWorkingDay = until isWorkingDay (addDays 1)    -- much nicer
06:20:03 <LKoen> [Leary]: it looks to me as if until ignores its last argument?     until (>10) (+1) x    seems to return 11 no matter the value of x
06:20:34 <slaterr> > until (<0) (+1) 0
06:20:40 <lambdabot>  mueval-core: Time limit exceeded
06:22:01 <[Leary]> > until (>10) (+1) 0.5
06:22:03 <lambdabot>  10.5
06:32:37 <slaterr> [Leary] if number is smaller than 10, then repeatedly applying (+1) will make it larger than 10, eventually
06:36:23 <[Leary]> Sure will. And if the starting value is also an integer, you can be pretty confident you'll have 11 when that happens.
06:45:34 <dmwit> mpickering: If you have 50 cases that don't have any structure, I don't see an alternative.
06:45:49 <dmwit> Or, if there is structure, then your "tag" should reflect that structure.
06:46:01 <mpickering> I've defined handlers for each context now and functions to compose and lift them
06:46:21 <dmwit> s/tag/flag/ I guess
06:47:14 <mpickering> I refactored so that the `Mode` carried the context specific state 
06:47:21 <mpickering> not sure how this will work out in the long run
06:47:28 <dmwit> > until (>10) (+1) 1000 -- not 11, even though it's an integer
06:47:30 <lambdabot>  1000
06:47:45 <mpickering> I'm now more alarmed that microlens doesn't define `ALens`
06:49:10 <[Leary]> dmwit: "if number is smaller than 10, [...]" ... "And if the starting value is /also/ an integer [...]"
06:54:26 <dmwit> ok
07:25:17 <merijn> Will Vector.Generic optimise away when the vector types are known statically?
07:44:45 <merijn> > (1/0 :: Double) > 2
07:44:47 <lambdabot>  True
07:45:12 <slaterr> > 1/0 :: Double
07:45:14 <lambdabot>  Infinity
07:52:43 <merijn> And relatedly: Is there zip for vector that enforces equal length lists? >.>
08:04:57 <LKoen> [Leary]: I searched in hoogle for a function of type   (a -> Bool) -> (a -> a) -> a -> Integer, but didn't find any. is there such a thing?
08:05:17 <LKoen> like until, except it returns the number of iterations needed to satisfy the predicate
08:07:25 <merijn> That seems an oddly specific function
08:07:51 <merijn> Combination of iterate, takeWhile and length should work, though?
08:08:25 * hackage proteome 0.3.16.0 - neovim project manager  http://hackage.haskell.org/package/proteome-0.3.16.0 (tek)
08:09:19 <asheshambasta> I've been taking my first steps into type-level land with Haskell; and I wanted to ask if there's a solution more satisfactory than the one I'm going for here: https://gist.github.com/asheshambasta/788b78ac0419e0abcbc2bd7d2c7ca890
08:10:29 <merijn> asheshambasta: What's unsatisfactory about it?
08:10:42 <asheshambasta> merijn: having to resort to a smart constructor :-) 
08:11:20 <merijn> I'm afraid probably not
08:14:10 <asheshambasta> merijn: okay, so this is usually the approach taken to reflect + constrain some "state-information" with types, right? I mean the benefits are great elsewhere in the codebase, its just the construction bit here that seems a little ... prone to human error. That is, someone could still wrap an Node' where status = Expired inside `Node 'Valid`
08:14:52 <merijn> asheshambasta: Having the construction handled other than smart constructors requires dependent types
08:15:06 <merijn> asheshambasta: Since you want the the type to depend on the runtime value
08:15:13 <asheshambasta> merijn: yeah
08:15:16 <merijn> asheshambasta: And Haskell just doesn't really have those :)
08:15:53 <asheshambasta> Okay, this is good enough for me, I was just wondering if my solution was too naive and if I was missing out on something. 
08:16:17 <lyxia> Or you could have the status appear as a parameter of Node', and have Node just hide it, instead of duplicating the tag.
08:16:37 <merijn> lyxia: That doesn't solve the smart constructor issue, though
08:16:41 <merijn> Just moves it to Node
08:17:28 <asheshambasta> lyxia: I'd like to have it exposed at `Node` since then I can restrict functions that only work with certain `Status` values 
08:17:50 <asheshambasta> eg. ```authenticate :: Node 'Valid -> m AuthStatus```
08:18:24 <LKoen> > howLongUntil p step x = length (takeWhile (not . p) (iterate step x))
08:18:27 <lambdabot>  <hint>:1:23: error:
08:18:27 <lambdabot>      parse error on input ‘=’
08:18:27 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
08:21:42 <lyxia> asheshambasta: I mean this https://gist.github.com/Lysxia/01c0ff0d6dca65ba1e456719fea2adba
08:22:12 <lyxia> asheshambasta: whoever constructs a Node must already know whether it's valid or not, and they can then hide it existentially
08:23:32 <lyxia> asheshambasta: then if you get a (Node s) you can recover knowledge about s at the type-level by pattern-matching on the status.
08:24:56 <lyxia> -- pseudo-dependently typed programming with singletons
08:25:17 <Solonarv> asheshambasta: pattern synonyms might help make this less annoying to use
08:25:57 <asheshambasta> lyxia: cool, yeah this looks nicer
08:26:48 <asheshambasta> Solonarv: how do you mean? 
08:27:44 <Solonarv> oh, I was actually referring to your original approach. With singletons you don't need it.
08:30:20 <slaterr> > let howLongUntil p step = length . takeWhile (not . p) . iterate step in howLongUntil (>10) (+1) 1
08:30:23 <lambdabot>  10
08:30:59 <merijn> hmm, is there an identity conduit somewhere?
08:31:32 <slaterr> > sequence [Left "error1", Left "error2", Right 10]
08:31:34 <lambdabot>  Left "error1"
08:32:18 <slaterr> is there something similar to above, but with [Either a b] -> Either [a] [b] signature?
08:32:39 <ski> what should happen if there's both `a's and `b' in the list ?
08:32:48 <slaterr> it should return all lefts
08:32:59 <ski> what should happen if there's neither `a's nor `b's in the list ?
08:33:13 <slaterr> Left "No elements"
08:33:15 <slaterr> I guess
08:33:25 <slaterr> no, just an empty list
08:33:48 <lyxia> Right []   sounds reasonable
08:33:52 <slaterr> yeah
08:34:06 <merijn> :t partitionEithers
08:34:07 <lambdabot> [Either a b] -> ([a], [b])
08:34:22 <merijn> Although that's not quite the same, I suppose
08:34:27 <asheshambasta> lyxia: do I need to enable an extension to be able to have (_ :: Status) ? 
08:34:37 <merijn> Actually, "Either [a] [b]" looks like Validation?
08:34:42 <lyxia> slaterr: sequence with this Applicative https://hackage.haskell.org/package/either-5.0.1/docs/Data-Either-Validation.html
08:35:00 <lyxia> asheshambasta: maybe
08:35:35 <lyxia> asheshambasta: for this one I just let GHC remind me.
08:36:14 <ski> @hackage validation
08:36:14 <lambdabot> http://hackage.haskell.org/package/validation
08:36:20 <asheshambasta> lyxia: it isn't being too helpful in my case; ```    Unexpected type ‘(_ :: Status)’ ``` 
08:36:20 <asheshambasta>  
08:36:48 <merijn> ski: I dislike that one
08:36:54 <lyxia> asheshambasta: It might be KindSignatures
08:36:57 <merijn> ski: edwardk's Validation in either is nicer
08:37:10 <ski> ok
08:37:16 <asheshambasta> that is already enabled 
08:37:56 <lyxia> asheshambasta: you have GADTs too?
08:37:58 <merijn> Oh, looks like the interface changed a bit
08:38:17 <slaterr> > msum [Failure "error1", Failure "error2", Success "success"]
08:38:18 <asheshambasta> yeah
08:38:20 <lambdabot>  error:
08:38:20 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘[Char]’
08:38:20 <lambdabot>      • In the first argument of ‘Failure’, namely ‘"error1"’
08:38:45 <slaterr> :t Failure
08:38:46 <lambdabot> Int -> Int -> Int -> Int -> Test.QuickCheck.Random.QCGen -> Int -> String -> Maybe Test.QuickCheck.Exception.AnException -> [(String, Double)] -> String -> [String] -> Result
08:38:54 <slaterr> hmm
08:40:05 <lyxia> asheshambasta: ah maybe it just doesn't like wildcards, so use either  "data SStatus (s :: Status) where" or "data SStatus :: Status -> Type where"
08:42:13 * ski would use the former in case `s' was the parameter of all the data constructor result types, and use the latter otherwise
08:43:12 <ski> (well, maybe in some corner cases use the latter anyway ..)
08:43:30 <lyxia> Like Coq :)
08:43:56 <ski> (an example would be `Vector n a', with that parameter ordering)
08:46:15 * ski . o O ( parametricity,roles )
08:47:22 <lyxia> wouldn't it be Vector a n
08:48:39 <hpc> you want the element type last for stuff like fmap
08:48:53 <ski> exactly
08:49:21 <ski> for the other ordering, you'd use `data Vector (a :: Type) :: Nat -> Type', and there's no complication
08:49:49 <lyxia> ok
08:51:01 <ski> but imagine a dependently typed data type, something like `data Foo : (x : T) -> U x -> Set', and imagine you want to use `x' as an index, while still using `U x'-typed argument parametrically
08:51:27 <ski> how would one express that ?
08:51:57 <ski> perhaps by using some kind of parametricity modality (cf. Dependent Haskell, e.g.)
08:52:33 <ski> and is there a relation between that, and parameter roles <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#roles> ?
09:01:06 <lyxia> Surely if anyone knows, Richard Eisenberg must know.
09:20:03 <Welkin> has anyone built a persistent database in haskell (not including acid-state)?
09:20:55 <nisstyre> Welkin: http://hackage.haskell.org/package/TCache
09:21:02 <nisstyre> does that fit your criteria?
09:21:16 <Welkin> specifically, I'm thinking about wide-column stores (like BigTable or DynamoDB)
09:21:27 <Welkin> a HAskell version of Cassandra, for example
09:22:13 <nisstyre> Welkin: I feel like a lot more of those projects end up getting written in Erlang or Java
09:22:20 <Welkin> why is that?
09:22:32 <Welkin> I know CouchDB and Riak are in erlang
09:22:35 <nisstyre> not sure exactly why, maybe people just aren't using Haskell for that because it requires a lot of domain knowledge
09:22:42 <Welkin> one reason I assume is that the beam gc is more tame
09:22:51 <nisstyre> and the set of people who are really knowledgeable in both is small
09:23:05 <Welkin> I wanted to try writing a wide column store in haskell for fun
09:23:10 <nisstyre> Welkin: BEAM is great but I don't see why you couldn't rely on the GHC RTS for the same stuff
09:23:13 <Welkin> it seems pretty easy
09:23:19 <Welkin> at least for a proof of concept
09:23:22 <nisstyre> I guess Haskell doesn't have as much fault tolerance built in
09:23:29 <Welkin> there is cloud haskell
09:23:31 <nisstyre> i.e. supervisor trees
09:23:34 <Welkin> distributed haskell*
09:23:37 <nisstyre> but you can do it in Haskell
09:23:49 <nisstyre> Welkin: yeah but it isn't really that widely used is it?
09:24:02 <nisstyre> Cloud Haskell vs OTP, OTP is much more mature
09:24:05 <Welkin> it look one-to-one with the erlang api
09:24:25 <Welkin> of course, I wouldn't expect it to beat otp in terms of maturity
09:25:04 <nisstyre> Welkin: so I think it's just a combination of lack of crossover knowledge in both distributed databases AND Haskell, and lack of maturity in the tooling compared to Erlang or Java
09:25:17 <Welkin> I found only one package on hackage that implements sstables from 2010
09:25:55 <nisstyre> Welkin: outside of cloud Haskell, is there even something like ETS that is easy to use?
09:26:16 <Welkin> acid-state is the only thing I can think of
09:26:19 <nisstyre> yeah
09:26:34 --- mode: glguy set +v nickednamed
09:26:58 <nickednamed> Hi all. I have a very Newbie Question. I want to make an algorithmic trading system to automate losing all my money, and learn more Haskell. I am new to software development in general. I have some design questions: What is the typical way to deal with streams, and event based programs? Convert stream to a Type, then process, or store stream as a String, and process/convert to Types as needed? CSV?
09:27:18 <nisstyre> nickednamed: might want to look into conduits
09:27:44 <nisstyre> https://github.com/snoyberg/conduit
09:28:22 <nisstyre> you don't need to use the base conduit library, but rather http-conduit probably
09:28:25 <nisstyre> or even wreq
09:29:07 <nisstyre> actually I'm not sure if you can use conduits with wreq
09:30:26 * hackage type-map 0.1.5.0 - Type-indexed maps  http://hackage.haskell.org/package/type-map-0.1.5.0 (lyxia)
09:31:30 <nickednamed> nisstyre: I already have websocket stream working (using wuss) and I have the stream printing to terminal, and writing the stream to a file (as a String).. I cannot yet convert to a JSON Object Type (using aeson), but I wondered: should I convert stream to JSON types, and write a list of JSON Objects to the file, or write stream as a String, and parse it, making JSON Objects as needed. Or use CSV. 
09:31:36 <nickednamed> Basically, I have a stream, which is printed, and writtento file as a String, and I don;t know what to do now.
09:32:36 <nisstyre> nickednamed: do you need to parse them before writing to the file?
09:33:00 <Welkin> what about graph databases in haskell?
09:33:06 <nisstyre> I guess my question is, does your API return valid JSON already?
09:33:24 <nisstyre> Welkin: no clue, I know there is GraphQL stuff
09:33:28 <Welkin> I find that, in general, there are few open-source graph databases besides neo4j
09:34:56 <nisstyre> nickednamed: if you want to just build spreadsheets of stock prices or something then I would say stream it to a CSV library and spit out CSV
09:41:52 <nickednamed> nisstyre: Well that's what I'm asking really.. I don't suppose I do, as long as I can pull/parse it later as needed - but I don't really know anything about Haskell programming.
09:42:34 <bollu> I'm looking for a function: (foldable f, monoid m) => f m -> m
09:42:44 <glguy> :t fold
09:42:45 <lambdabot> (Monoid m, Foldable t) => t m -> m
09:42:47 <Welkin> nickednamed: https://hackage.haskell.org/package/cassava
09:42:56 <bollu> thanks!
09:43:29 <bollu> fg
09:43:47 <nickednamed> I want to eventually create a trading system. So I would like to be able to use the streams to produce trading signals, calculate losses/profits, etc.
09:51:19 <nickednamed> Welkin: Thank you. I have made a note of this, and have looked into it for CSV stuff, should I need to design things that way.
10:02:43 <glguy> Anyone have a favorite fast min Int priority queue? I'm finding IntMap[a] hard to beat with the first couple packages I've tried from Hackage
10:05:21 <Welkin> theoretically, can you really get better than a priority heap?
10:06:18 <glguy> I'm interested in the constant factors in particular
10:08:31 <Ariakenom> glguy: did you try https://hackage.haskell.org/package/fingertree-0.1.4.2/docs/Data-PriorityQueue-FingerTree.html ?
10:09:52 <Ariakenom> although "These have the same big-O complexity as skew heap implementations, but are approximately an order of magnitude slower. On the other hand, they are stable, so they can be used for fair queueing. They are also shallower, so that fmap consumes less space."
10:21:40 <monochrom> IntMap is pretty clever, it is possible that the techniques for priority queues are no cleverer.
10:27:40 <mpickering> Anyone know any libraries for simply managing configuration files which should persist in $XDG_CONFIG_HOME ?
10:28:23 <mpickering> glguy: I thought psqueues was meant to be the best one?
10:30:32 <slaterr> how to stuff `FilePath -> IO (Either String String)' into `String -> IO (Either String [Data])'? I need to do 'double level' >>=, for both IO and Either monad
10:30:37 <mpickering> I suppose this would save me about 10 lines 
10:35:04 <Solonarv> ExceptT?
10:35:09 <slaterr> @pl (\ex -> case ex of Left l -> return (Left l); Right r -> f r)
10:35:09 <lambdabot> (line 1, column 29):
10:35:10 <lambdabot> unexpected '>'
10:35:10 <lambdabot> expecting operator
10:35:35 <Solonarv> @unmtl ExceptT String IO [Data]
10:35:35 <lambdabot> ExceptT String IO [Data]
10:35:43 <Solonarv> pah, stupid lambdabot
10:35:55 <slaterr> above works, @pl can't parse it I  guess
10:35:55 <Rembane> What answer were you expecting?
10:36:22 <geekosaur> it doesn't know enough to elimiate cases. you probably want
10:36:26 <geekosaur> :t either
10:36:27 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:36:33 <Rembane> slaterr: fmap does the same thing as your case-expression.
10:36:36 <slaterr> Rembane, a cool new operator I never heard of, or a combination of existing operators I didn't think of
10:36:41 <geekosaur> m, and that
10:37:37 <Rembane> slaterr: Do you need to use IO when you turn the String into [Data]?
10:38:12 <slaterr> no, that is the IO part
10:38:15 <slaterr> +only
10:38:48 <Rembane> Then fmap might do what you want all the time.
10:38:52 <Rembane> :t (fmap . fmap)
10:38:53 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
10:40:11 <Rembane> Or if you want to do something more exciting Solonarv's solution is nice.
10:40:13 <slaterr> I can't see how that would be useful
10:40:21 <slaterr> how to plug fmap . fmap into what I have above?
10:40:47 <Rembane> Lets see... is FilePath a newtype wrapper for a String?
10:40:58 <slaterr> yes
10:42:23 <monochrom> No. Type synonym. If it's the Prelude FilePath. But who knows, no actual code was posted, it's all hypothetical talk.
10:42:42 <slaterr> I am writing a dummy case
10:42:50 <monochrom> Or maybe telepathical talk but what do I know.
10:42:50 <slaterr> with dummy data types and functions
10:43:13 <slaterr> what is the channels' preferred pastebin site other than github? I don't have github
10:43:26 <Rembane> Anonymous gist?
10:43:40 <monochrom> Anything other than pastebin.com would be fine with me.
10:43:56 <slaterr> pastebin.com and lpaste are the only ones I know. and pastebin is the only one working
10:44:04 <monochrom> lpaste is dead.
10:44:40 <Rembane> dpaste.com is still alive.
10:44:56 <monochrom> pastebin.com is like OK but first thing I do I click "raw" because why suffer the double-spacing and the redaction of string literals.
10:45:02 <DigitalKiwi> and dpase.de is nice too
10:45:23 <DigitalKiwi> +t
10:46:18 <monochrom> The only time I ever double-spaced code was in my MSc thesis because like "thesis must be double-spaced".
10:46:27 <DigitalKiwi> 18:25 @phrik: Pastebin.com is swamped with advertisements and random captchas. Malware found on pastebin.com has resulted in it being blocked for some users. 
10:46:28 <DigitalKiwi>               It injects CRLF line-endings. Please, use something else. Use something sane like https://ptpb.pw https://gist.github.com https://bpaste.net https://ix.io 
10:46:37 <slaterr> here http://dpaste.com/3X27BJV
10:46:39 <monochrom> Therefore pastebin.com is perpetually turning your code into MSc theses!
10:46:49 <slaterr> Rembane, I don't think fmap . fmap will work there, but perhaps I'm wrong
10:47:40 <Rembane> monochrom: I like that reasoning
10:49:37 <slaterr> FilePath from System.FilePath, my code compiles without it, so I forgot to include it
10:50:28 <monochrom> You just need "go :: String -> [Data]" and you should it like "Right text -> return (go text)"
10:50:59 <monochrom> Err no, "Right text -> return (Right (go text))"
10:51:00 <slaterr> it has to return Either to report errors of its own
10:51:37 <Rembane> slaterr: Like this: http://dpaste.com/1HPSDY9
10:52:10 <monochrom> But I would follow Rembane.  The point about "go :: String -> [Data]" stands though.
10:52:24 <slaterr> Rembane, code does not compile (you can try it yourself, all the identifiers are there once you include System.FilePath)
10:52:36 <slaterr> Couldn't match type `IO (Either String [Data])' with `[Data]'
10:52:43 <Rembane> slaterr: It typechecks when I run runghc. 
10:52:58 <monochrom> Again you need to change to "go :: String -> [Data]"
10:52:59 <slaterr> did you change go's signature?
10:53:08 <Rembane> I did
10:53:08 <slaterr> monochrom, again, I can't change it, because go can return Left
10:53:12 <slaterr> types are correct
10:53:34 <slaterr> Rembane then it doesn't count  :)
10:54:20 <monochrom> You have "undefined" there so now we have two cases.
10:54:32 <Rembane> slaterr: Fair enough. 
10:54:47 <monochrom> Either you say it would be insulting if I didn't trust you. Then this ends the dialogue.
10:55:16 <monochrom> Or you show something about why go needs to carry the burden of IO and needs to carry the burden of Either.
10:56:34 <slaterr> monochrom, why are you still arguing, even after I said twice that types are correct? I have to *prove* it has to be correct? wth
10:57:05 <monochrom> OK then you want the end of dialogue case.
10:57:14 <slaterr> monochrom, only with you
10:57:22 <slaterr> because you obviously decided to be difficulty
10:57:25 <slaterr> difficult*
10:58:10 <Solonarv> well, ExceptT seems like the right solution to me
10:58:55 <slaterr> does that mean I would have to change the types?
11:00:14 <ski> not necessarily. but it would be nicer to do that, at least to some extent (such as the type of `go' at least, since that's local anyway)
11:00:29 <Solonarv> only from 'IO (Either String a)' to the equivalent 'ExceptT String IO a'
11:00:44 <Solonarv> slaterr: http://dpaste.com/21DR5F2
11:02:48 <ski> i'd suggest doing what Solonarv suggested, going from `IO (Either String T)' to `ExceptT String IO T' (it should be. not `ExceptT IO String T', that was a mistake). except probably at boundaries of the chunk of code that uses this `IO (Either String (...))' pattern
11:03:01 <slaterr> Solonarv looks nice
11:03:29 <monochrom> There is a function that coverts IO (Either X Y) to ExceptT X IO Y so if you have to call third-party things get gives you IO (Either X Y) all is not lost.
11:03:47 <Solonarv> that function is called ExceptT - it's simply the constructor :>
11:06:31 <ski> slaterr : but if you really insist on not changing the type signatures, you can say `loadData = runExceptT (ExceptT . go <=< ExceptT . readFileSafe)'
11:06:59 <slaterr> can this be modified to work? 
11:07:03 <slaterr> loadData path = readFileSafe path >>= either return go
11:07:28 <slaterr> getting * Couldn't match type `[Char]' with `Either String [Data]', and my head is spinning trying to figure out the correct type
11:07:50 <ski>   loadData path = readFileSafe path >>= either (Left . return) go  -- but this is almost as bad as the code you started with
11:08:03 <ski> er, sorry, should be `return . Left' there
11:09:08 <monochrom> ExceptT allows you to use >>= and fmap etc to perform "preserve Left x as Left x"
11:09:37 <ski> that's what it's *for*
11:09:49 <monochrom> If you find yourself repeating "Left x -> return (Left x)" all the time, it's time to switch.
11:10:10 <monochrom> At least that's the recommendation.
11:10:50 <ski> (oh, and i suppose s/runExceptT/runExceptT ./, in the `<=<' variant, above)
11:11:08 <slaterr> I'll look into ExceptT, seems to be the right solution for this
11:11:50 <ski> <https://hackage.haskell.org/package/mtl/docs/Control-Monad-Except.html>
11:12:27 <ski> (does AAM go into `MaybeT' and `ExceptT', btw ?)
11:12:38 <monochrom> Actually I would start with using IO's own exception system.
11:13:17 <monochrom> Err what is AAM?
11:13:20 <ski> ok, apparently it doesn't (it does mention `ErrorT' ..)
11:13:22 <ski> @where AAM
11:13:22 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
12:06:25 --- mode: glguy set +v beginnerSOL
12:06:38 <beginnerSOL> hey guys.
12:07:05 <beginnerSOL> I have an idea, want to know your opinion.
12:09:38 <beginnerSOL> As a small member of the Haskell world, I want to do something for Haskell. what do you think if we build a chanell called "haskell-quotes" ?
12:10:15 <cocreature> beginnerSOL: I think you’ll to describe the purpose of that channel in a bit more detail
12:15:17 <beginnerSOL> ok, this is where this idea came from. i think Haskell has a reputation among other people for being academic, dry, hard or something like that. I want to change that because i don't think so. and i want other people to feel better about Haskell. on the other hand, "funny" things help attract people to different stuff and we can actually use this "funny-ness" to help people learn stuff using analogies.
12:16:37 <beginnerSOL> this is what happened, today i was thinking about polymorphism, parametric, constrained, concrete, and stuff related to typeclasses and polymorphism.
12:17:57 <beginnerSOL> suddenly i thought "Be like a concrete type in your life, don't change colors!"
12:19:35 <beginnerSOL> I know, I'm a beginner, so I might actually hurt people's understanding because of lack of knowledge, but people who know Haskell can actually put a lot of meanings and concepts in these kind of quotes.
12:22:31 <beginnerSOL> I thought maybe having something "funny" both helps attracting people and also a cool place for good Haskell programmers to "teach using fun and analogies".
12:24:58 <pavonia> Is an IRC channel really the best place for a list of funny quotes about Haskell?
12:27:03 <beginnerSOL> I'm not sure, I'm also new to IRC. I just had this idea and wanted to share it with you to see if it's a good idea or not.
12:27:32 <yushyin> https://wiki.haskell.org/Humor
12:28:12 <ski> @quote only.one.bacon
12:28:13 <lambdabot> gwern says: drat. what *do* all you people talk about? only one bacon and one zombie quote
12:28:20 <beginnerSOL> (being funny doesn't mean something is shallow or not useful, a lot of meanings, concepts and hard stuff can be beautifully explained using funny things and analogies.)
12:29:17 <DigitalKiwi> sounds like you should tweet about it
12:29:26 <ski> @quote unofficial.motto
12:29:27 <lambdabot> dpratt71 says: <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed.
12:31:15 * DigitalKiwi thought it's bracketed "avoid (success at all costs)" not "avoid success (at all costs)"
12:31:30 <Solonarv> That's the joke
12:31:49 <Solonarv> Yeah an IRC channel is not great as a quote repository
12:33:16 <Solonarv> beginnerSOL: IRC doesn't have history, so if someone joins a channel they just see emptiness - until someone sends a message
12:33:33 <beginnerSOL> So you guys think its not a good idea?
12:34:19 <beginnerSOL> I thought about something only for Haskell, not all the peogrammers and languages.
12:34:25 <ski> @wiki QuotesPage
12:34:25 <lambdabot> https://wiki.haskell.org/QuotesPage
12:34:55 <beginnerSOL> ski: what is this "@" ?
12:35:23 <beginnerSOL> I don't understand this lamdabot thing.
12:35:23 <ski> escape character for lambdabot commands
12:35:35 <ski> @help wiki
12:35:35 <lambdabot> wiki <page>. URLs of Haskell wiki pages
12:36:25 <ski> @remember monochrom People dig analogies. But you know that if analogies never break, then there is no need to learn new things. By definition "new" means no analogy with old things.
12:36:25 <lambdabot> Done.
12:37:51 <beginnerSOL> ok got it.
12:38:03 <beginnerSOL> who's Simon Marlow?
12:38:08 <ski> @quote new.internet.rule
12:38:08 <lambdabot> djahandarie says: I think there should be a new internet rule.... "if it exists, there is a monad tutorial using it as an analogy"
12:38:11 <ski> @quote tennis.racket
12:38:11 <lambdabot> Binkley says: Using analogies to introduce monads is almost as bad as trying to change a tire with a tennis racket.
12:38:25 * hackage shell-monad 0.6.7 - shell monad  http://hackage.haskell.org/package/shell-monad-0.6.7 (JoeyHess)
12:38:52 <ski> JaffaCake <https://en.wikipedia.org/wiki/Simon_Marlow>
12:40:01 <beginnerSOL> "noted Haskell guru"
12:40:09 <ski> @quote sarah
12:40:09 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
12:40:18 <ski> anyway .. as you can see, there are already some quotes
12:40:35 <Rembane> What?! :D
12:40:40 <Rembane> Oh
12:40:46 <Rembane> Go as in the game, not as in the language?
12:40:51 <ski> yep
12:41:07 <ski> (this was before the language was introduced, i think)
12:41:26 <LKoen> I don't get it
12:41:49 <Rembane> ski: Good. This makes everything less confused.
12:42:48 <beginnerSOL> ski: how do i access these quotes? the list of all of them.
12:42:59 <ski> hm, not sure
12:43:13 * ski has never felt the need to
12:44:18 <Solonarv> You can get a dump of the database somehow
12:44:18 <[Leary]> @where state
12:44:18 <lambdabot> http://silicon.int-e.eu/lambdabot/State/
12:44:23 <Solonarv> ah, there it is
12:44:23 <beginnerSOL> but i want to see what people said. this IRC thing doesn't really have history?
12:45:39 <LKoen> there are some channels where bots record everything that is said, but in most channels that's not the case
12:45:41 <beginnerSOL> what if i want to search for something and see what people said?
12:46:12 <LKoen> and on most freenode channels I think there is an explicit policy NOT to log discussions
12:46:17 <cocreature> beginnerSOL: then you’re out of luck in general
12:46:27 <beginnerSOL> is this not having history a good thing?
12:46:31 <__monty__> LKoen: That hasn't been my experience.
12:46:34 <cocreature> fwiw for this channel there are logs, see the link in the topic
12:46:39 <ski> logs are in the topic
12:46:50 <cocreature> but that’s a feature that is bolted on by adding a bot not something inherent in irc
12:47:06 <ski> beginnerSOL : it can be
12:47:35 <_deepfire> kosmikus:  an stab at prism implementation: https://github.com/well-typed/lens-sop/pull/1
12:47:36 <beginnerSOL> for example ski spent a lot of time and energy couple of days ago to explain something to me, maybe that discussion will help someone later.
12:47:38 <LKoen> it's a good thing for people who don't like everything they've ever said being recorded and kept forever
12:47:41 <yushyin> LKoen: freenode policy is to inform about logs if there are public logs
12:47:45 <int-e> LKoen: Freenode policy is that if there are logs, they must be mentioned in the topic.
12:47:49 <LKoen> ah, ok
12:47:50 <monochrom> IRC was invented 30 years ago when no one wanted to offer history storage for free.
12:48:37 <_deepfire> kosmikus: it's probably horrible on many levels, so I'm eager to hear your suggestions!
12:48:55 <monochrom> Consider the fact that even on Usenet participating servers deleted 6-month-old posts.
12:50:20 <beginnerSOL> ski how?
12:50:27 <beginnerSOL> ski: 
12:50:40 <ski> what LKoen said
12:51:52 <nisstyre> monochrom: I would still do that today TBH
12:51:56 <monochrom> Don't fool yourself. We know that not saving history was caused by economics not idealism because today we see that as soon as someone finds a way to fund the storage, they will save. Just look at Facebook.
12:51:58 <ski> people can be more open, if they know what's being said is not stored for posterity
12:51:58 <nisstyre> ephemeral stuff is hip right now
12:52:07 <nisstyre> people don't want to be able to go back and see their horrible past
12:52:56 <monochrom> Old posts on Facebook have routinely backfired in e.g. potential employer finds out and decide to not hire you.
12:53:03 <nisstyre> exactly
12:53:10 <nisstyre> which is why I periodically clean my social media history
12:53:24 <monochrom> But doesn't mean Facebook will delete your old post though.
12:53:32 <nisstyre> that's true
12:53:50 <nisstyre> also google might still have it in some cases where they index public posts
12:54:04 <ski> also, IRC commonly tends to be highly interactive/responsive. while it may sometimes be useful to go back and read an old conversation, it's commonly better to be part of the conversation (or a new one)
12:54:12 <monochrom> IRC and Usenet are "safe" not because they're ruled by idealists who respect you. It's because they're ruled by cheapos.
12:54:32 <nisstyre> I think I have logs enabled but I never ever publish them
12:55:15 <nisstyre> that's not much though considering you could just have a bot join every channel on Freenode and log everything
12:55:16 <beginnerSOL> ski explained something for me that took more than 2 hours i guess, i think it's a good idea to be able to have a history of that and search for something in that discussion, ski can't repeat a 2 hour talk everyday.
12:55:35 <nisstyre> beginnerSOL: do you know how to enable logs on your IRC client?
12:55:47 <ski> nisstyre : that has happened
12:55:48 <nisstyre> you can also use a bouncer or something like screen/tmux to be connected 24/7
12:56:33 <beginnerSOL> nisstyre: i know nothing about IRC.
12:57:11 <beginnerSOL> other than identifying myself using that /msg NickServ stuff.
12:57:40 <nisstyre> beginnerSOL: well there's no time like the present for learning new stuff
12:58:30 <monochrom> You can always take a nap now and learn it tomorrow.
12:59:27 <ski> beginnerSOL : personally, i don't mind going through such lengthy explanations, when i have time&energy. if people feel the need to reciprocate, there's plenty of other people they could help
13:01:11 <nisstyre> I actually like helping people on IRC even when I have real work to do
13:01:21 <nisstyre> it's a nice change of pace to look at new problems
13:03:09 <beginnerSOL> you guys are really nice.
13:03:47 <nisstyre> beginnerSOL: thanks!
13:04:01 <beginnerSOL> normally people try their best to charge money for these kinda helps and guidances. but the atmosphere here is great.
13:04:42 <ski> being passionate helps. also having fun
13:05:39 * ski also appreciates that some people have a more harsh/stern tone, prodding people to not be too lazy
13:07:45 <nisstyre> ski: I don't help someone if I sense that they're being a help vampire, but I will help if it's obvious someone is willing to put serious thought/effort in
13:09:04 <ski> yes. you shouldn't do someone's work for them, that's doing them a disservice
13:09:43 <ski> (that's one lesson i've learned here, over the years)
13:14:37 <nisstyre> ski: yeah, in order to actually learn something you *have* to struggle with it, there's no way around that
13:15:06 <nisstyre> unless you're a genius prodigy or something, but that only exists on TV really
13:19:24 <beginnerSOL> ski: you're right
13:22:33 <beginnerSOL> guys, one question, you know that I'm a complete beginner and Haskell is my first language and i have a goal, my goal is to first learn Haskell so that i can build web apps (startups). do you think it's possible for me to build my startup ideas in 1.5 years from now?
13:23:25 <aplainzetakind> beginnerSOL: Probably depends on the startup ideas.
13:24:35 <beginnerSOL> do you think it's possible to learn Haskell and Yesod in 1.5 years?
13:25:14 <beginnerSOL> (for a complete beginner with Haskell as his first language)
13:25:52 <beginnerSOL> if it's not a realistic goal then please help me.
13:25:58 <aplainzetakind> Yes. (disclaimer: I myself don't even have the skill you are aiming for)
13:26:13 <aplainzetakind> It is definitely a realistic goal. 1.5 years is a long time.
13:32:37 <cjay-> Using Data.Vector from the vector package: Is it expected behavior that the following doesn't terminate?
13:32:40 <cjay-> foo = fromListN 10 (2 : toList foo)
13:33:23 <dmwit> beginnerSOL: Learning the tools in 1.5 years is reasonable. Learning the tools and building a startup in the same time seems riskier to me. But then building a startup seems risky, period.
13:35:13 <Solonarv> cjay-: yes, vectors must be finite
13:35:37 <Solonarv> oh wait that's not what's happening
13:35:48 <__monty__> The tech is also only a small part of startups so that alone'll never be enough.
13:36:10 <beginnerSOL> I'm a doctor, i don't want to build startups for money or profit, i became a doctor for my mother, she loved to see me as a doctor so i did it for her. but I've always had a love for programming deep inside, i love to build things and ideas that i have.
13:36:12 <dmwit> cjay-: fromListN n does not guarantee that there are at least n elements.
13:36:17 <dmwit> cjay-: So, yes, expected.
13:38:32 <dmwit> cjay-: You might like to make the shape of the list explicit, e.g. `foo = fromListN 10 (2 : map (\i -> foo ! i) [0..8])`
13:40:07 <zachk> beginnerSOL, what kind of doctor are you?
13:41:53 <beginnerSOL> zachk i think physician is the right word.
13:42:00 <zachk> ah
13:47:47 <cjay-> dmwit: I have a recursive definition that yields multiple elements at a time. It seems rather difficult to make the shape explicit under such circumstances.
13:50:03 <cjay-> the amount of elements that become known at a time depend on the previous vector elements
13:50:29 <cjay-> Data.Array.listArray dosen't have that problem, does it?
13:51:20 <zachk> cjay-, in a dependently typed language, I think you might need a dependent pair in your return type 
13:51:53 <cjay-> hmm
13:52:15 <cjay-> ok listArray dosen't terminate either, with my example from above
13:52:45 <aplainzetakind> I have a Set, which I consume in a recursive function, removing the smallest element each time and incorporating it in an accumulator. The set is defined as `Set.fromList $ (,) <$> [1..x] <*> [1..y]`. Would calling Set.deleteFinMin on this require it to be evaluated, or can it somehow lazily come up with only the next element in line?
13:53:15 <cjay-> I'd need a creation function that allocates the given bounds no matter what
13:55:00 <ski> > let foo = listArray (0,9) (2 : [foo ! i | i <- [0 .. 8]]) in foo
13:55:01 <lambdabot>  array (0,9) [(0,2),(1,2),(2,2),(3,2),(4,2),(5,2),(6,2),(7,2),(8,2),(9,2)]
13:57:32 <deltasquared> does there exist a shorthand way, given two (Data.)Sets, to get two lists of the items that are unique to the 1st set and unique to the 2nd set? I'm not particularly bothered about elements common to both in this instance
13:57:51 <ski> > let tabulate ix f = listArray ix [f i | i <- range ix]; fibs = tabulate (0,9) $ \case 0 -> 0; 1 -> 1; n -> fibs ! (n-1) + fibs ! (n-2) in fibs
13:57:53 <lambdabot>  array (0,9) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34)]
13:58:11 <ski> cjay- : anything wrong with those ?
14:01:21 <cjay-> ski: a better example for what I want: foo = listArray (0, 9) (2 : if (foo!0) > 1 then [] else [0])
14:01:40 <cjay-> it's hard to make the shape of the list explicit when different amounts of elements are generated at a time
14:02:50 <cjay-> accesses on the array or vector just hang before the creation function has completely consumed the list
14:02:53 <ski> that will pass a singleton list to `listArray'. how would you expect that to work ?
14:03:32 <ski> (or rather, it would pass a singleton list, if it didn't check the list length before yielding the allocated array)
14:04:05 <_deepfire> phadej: should that be called "partial lens", instead of prism?
14:04:25 <cjay-> hmm, it actually terminates with smaller bounds
14:04:31 * deltasquared really needs to try and wrap his head around lens at some point
14:04:57 <ski> cjay-, obviously
14:05:11 * ski . o O ( impartial function )
14:05:44 <cjay-> but only with (0,0)
14:05:51 <cjay-> let foo = listArray (0, 1) (2 : if (foo!0) > 1 then [3,2] else [0])
14:05:55 <cjay-> that doesn't terminate 
14:06:52 <cjay-> it really only works when the shape of the list is explicit, like dmwit said
14:08:06 <ski> yes, it wants to check the length of the list, before letting go of the array
14:09:15 <cjay-> couldn't it just allocate the array and mark each cell with "not defined" before going through the list?
14:09:27 <cjay-> yielding an error if a cell is touched that is not written yet
14:10:25 <cjay-> it wouldn't really need to mark cells when going left to right like that
14:11:25 <ski> > let setLength n = foldr (\_ k ~(x:xs) -> x : k xs) (\_ -> []) [1 .. n]; foo = listArray (0,2) (setLength 3 (2 : if (foo!0) > 1 then [3,2] else [0])) in foo
14:11:26 <lambdabot>  array (0,2) [(0,2),(1,3),(2,2)]
14:14:06 <cjay-> I need a while to digest that
14:14:30 <cjay-> hmm irrefutable patterns, I had forgot that those exist
14:15:21 <ski> you could probably write it more scrutable, that's just something i cobbled together quickly
14:15:57 <ski> > let setLength n = foldr (\_ k ~(x:xs) -> x : k xs) (\_ -> []) [1 .. n] in setLength 3 [2,3,5,7]
14:15:59 <lambdabot>  [2,3,5]
14:16:02 <ski> > let setLength n = foldr (\_ k ~(x:xs) -> x : k xs) (\_ -> []) [1 .. n] in setLength 3 [2,3]
14:16:04 <lambdabot>  [2,3,*Exception: <interactive>:3:26-49: Irrefutable pattern failed for patte...
14:16:10 <ski> > let setLength n = foldr (\_ k ~(x:xs) -> x : k xs) (\_ -> []) [1 .. n] in length (setLength 3 [2,3])
14:16:12 <lambdabot>  3
14:21:24 <cjay-> that's really crazy :)
14:21:58 <ski> how so ?
14:23:05 <cjay-> crazy as in mind blowing. thanks :)
14:23:17 <cjay-> ski: is it efficient though?
14:24:12 <cjay-> hmm I suppose it is
14:24:14 <ski> shouldn't be too bad, i think
14:25:16 <ski> one could have done `setLength n xs = [xs !! i | i <- [0 .. n-1]]', but that would be less efficient
14:25:28 <_deepfire> phadej, next idea -- traversal : -)
14:25:48 <ski> @where evolution
14:25:48 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
14:25:59 <ski> cjay- : check out the "leaned so far right he came back left again!" section there ^
14:26:16 <cjay-> thanks I'll take a look
14:28:06 <hpc> isn't that just take?
14:30:14 <ski> nope
14:31:07 <ski> it always gives a list of the required length (assuming it's a natural number)
14:31:24 <hpc> oh, i missed that part
14:32:03 <ski> in this case, used to break vicious strictness in a recursive data loop, by making it lazy enough
14:32:26 <Rembane> What does the ~ operator do in the pattern match?
14:32:36 <ski> delay the matching
14:32:46 <ski> @src partition
14:32:46 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
14:32:46 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
14:32:47 <lambdabot>                               | otherwise = (ts, x:fs)
14:33:06 <deltasquared> ooh, src, I haven't spotted that one before
14:33:13 <deltasquared> @src difference
14:33:13 <lambdabot> Source not found. Wrong!  You cheating scum!
14:33:15 <ski> > (take 4 *** take 4) (partition even [0 ..])  -- this wouldn't work, without the `~' there
14:33:17 <lambdabot>  ([0,2,4,6],[1,3,5,7])
14:33:23 <geekosaur> be aware it's  manually maintained database, and small
14:33:28 <Rembane> ski: Oh. Cool! Thank you! 
14:33:42 <deltasquared> geekosaur: oh, I see. guess I'll just stick to cabal unpack then :P
14:34:04 <geekosaur> and occasionally lies
14:34:52 <ski> @arr
14:34:52 <lambdabot> Smartly me lass
14:39:53 <Solonarv> is there an introduction to using OpenGL from Haskell somewhere?
14:40:40 <_deepfire> Solonarv: not a direct answer to your question, but you might find lambdacube-3d exciting.
14:40:44 <Solonarv> Preferable one that isn't bitrotted to death
14:42:41 * Solonarv looks at lambdacube
14:42:45 <Solonarv> looks interesting!
14:43:19 <_deepfire> Solonarv: https://lambdacube3d.com/editor.html
14:43:45 <_deepfire> also, https://github.com/lambdacube3d/lambdacube-quake3
14:46:14 <_deepfire> the whole stack should compile on 8.6
14:50:22 <deltasquared> certainly the idea of evaluating a list of triangles to draw inside some imperative glue code is how I envisioned doing a haskell GL app anyway...
14:55:36 <AfC> Is there a way to prevent test executables from showing up on Hackage? It has "buildable: false" in the executable block of the .cabal file but the names are still showing up on the generated haddock page.
15:00:23 <_deepfire> How does one derive Generic for GADTs in 2018?
15:04:22 <glguy> Afc: if you don't want it to show up you'll need to edit it out before you upload it
15:07:09 * _deepfire finds https://ryanglscott.github.io/2018/02/11/how-to-derive-generic-for-some-gadts/
15:11:46 <_deepfire> glguy: since QuantifiedConstraints are now in -- does that mean that it's possible that the Generic derivation strategy you outlined can be now implemented?  Maybe someone already worked on it?
15:29:24 <AfC> glguy: high tech. I like it.
15:43:54 <dmwit> aplainzetakind: (xs \\ ys, ys \\ xs) should do the trick
16:08:58 <glguy> _deepfire: Are you thinking of Ryan Scott?
16:42:52 <mpickering> As I understand it the generic programming with all kinds work is considered superior
17:05:39 <reallymemorable> I installed Haskell with the .pkg from haskell.org but when i type ghci in terminal I get this
17:05:42 <reallymemorable> https://paste.ofcode.org/7SzSBMwidSEk8ZJBNNhzUh
17:05:49 <reallymemorable> I googled it but didn't see a solution for haskell
17:09:25 <dmwit> Neat.
17:09:33 <dmwit> I wonder why invoking ghci tries to invoke gcc.
17:09:40 <dmwit> Does ghci --verbose reveal any more clues?
17:10:21 <reallymemorable> ghc: unrecognised flag: --verbose
17:10:32 <hpc> have you installed xcode?
17:10:39 <reallymemorable> checking now
17:11:14 <hpc> ghc on mac requires xcode 4 or 5, according to the haskell.org install directions
17:11:14 <reallymemorable> apparently not
17:11:16 <reallymemorable> installing now
17:11:50 <hpc> insert obligatory "on linux it's just a yum install" here :D
17:12:15 <reallymemorable> lol
17:12:27 <reallymemorable> i used yum on mac a while back
17:12:31 <reallymemorable> would that have solved it
17:12:44 <hpc> that's a thing?!
17:12:49 <reallymemorable> yeah
17:13:22 <dmwit> (Should be just "-v", not "--verbose". Sorry about that.)
17:13:31 <reallymemorable> yeah that command didnt run
17:13:34 <reallymemorable> but problem solved
17:29:50 <reallymemorable> have any of you guys used fluidsynth?
18:13:55 * hackage groundhog-th 0.10.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.10.1 (BorisLykah)
18:54:07 <_deepfire> glguy: oh, I apologize, indeed..
18:54:53 <_deepfire> For some reason I was convinced you are Ryan : -)
20:27:55 * hackage purebred-email 0.1.0.0 - types and parser for email messages (including MIME)  http://hackage.haskell.org/package/purebred-email-0.1.0.0 (frasertweedale)
20:36:30 <_deepfire> mpickering: do you refer to http://hackage.haskell.org/package/kind-generics ?
21:23:55 * hackage han2zen 0.1 - Convert Halfwidth Katakana to Fullwidth Katakana.  http://hackage.haskell.org/package/han2zen-0.1 (WataruYamada)
22:15:36 * hackage grids 0.1.0.0 -   http://hackage.haskell.org/package/grids-0.1.0.0 (ChrisPenner)
22:27:42 <nyc> I should probably learn generics.
22:29:42 <nyc> I also wonder what else can be done with GADT'e besides evaluating expressions.
22:40:37 * hackage grids 0.1.1.0 -   http://hackage.haskell.org/package/grids-0.1.1.0 (ChrisPenner)
