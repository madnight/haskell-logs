01:01:30 --- mode: glguy set +v BobUeland
02:17:41 <dinnu93> Hi
02:19:02 <dinnu93> I'm trying to learn haskell, where should I begin ?
02:19:51 <ski> with a textbook, perhaps ?
02:20:15 <dinnu93> which one ?
02:20:31 <dinnu93> @ski
02:20:31 <lambdabot> Maybe you meant: wiki src ask
02:21:01 <ski> perhaps "Haskell: The Craft of Functional Programming" by Simon Thompson
02:21:02 <ski> perhaps
02:21:05 <ski> @where PIH
02:21:05 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
02:21:19 <ski> or
02:21:24 <ski> @where HPFFP
02:21:24 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
02:21:28 <ski> or
02:21:31 <ski> @where SOE
02:21:31 <lambdabot> "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
02:21:46 <ski> you could also check out
02:21:48 <dinnu93> Which one is best for beginners according to you ?
02:21:51 <ski> @where wikibook
02:21:51 <lambdabot> http://en.wikibooks.org/wiki/Haskell
02:22:03 <ski> @where HR
02:22:03 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
02:22:03 <dinnu93> I'm thinking haskell from first principles
02:22:13 <ski> then go for it ?
02:22:19 <dinnu93> Thanks 
02:22:27 <ski> you could also try
02:22:30 <ski> @where CIS194
02:22:30 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
02:22:43 <ski> if you want some online-available exercises
02:22:55 <dinnu93> oK
02:23:26 <ski> of the books above, i've only read the Thompson one, so i can't really say which is the best for beginners
02:23:56 <ski> (and it probably depends on learning style, and knowledge background, interest inclination, anyway)
02:24:34 <ski> i can say that people in this channel seem to think LYAH is not that good for learning Haskell
02:24:51 <ski> (perhaps could be good for getting a first rough impression. not sure)
02:35:16 <dinnu93> Thanks :ski
02:35:29 <ski> you're welcome
03:23:34 * hackage tidal 1.0.0 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-1.0.0 (AlexMcLean)
03:58:09 <siers> How do I make an IO () into a StateT s IO ()?
03:58:53 <ski> use `lift' or `liftIO'
03:58:58 <suzu> lift
03:59:07 <siers> ah!
03:59:49 <ski> `lift' adds one "level". `liftIO' adds an arbitrary number of "levels", starting at `IO'
04:00:20 <ski> if you think you might have several levels in the future, but you're sure you're starting at `IO', then `liftIO' might be preferable
04:01:16 <siers> I have just one level and lift looks nicer for now. :)
04:01:22 <ski> otoh, if you accue multiple levels, you might want to abstract those away into an abstract data type. however, you still need to implement your primitive operations for that, where `liftIO' could still be preferable
04:01:43 <siers> I was aware of liftIO, but I thought there must be something for an arbitrary monad
04:02:29 <ski> (s/accue/accrue/)
04:09:53 <the_2nd> (How) can I undo/redo with acid-state? e.g. go to latest-1
04:18:16 * hackage shortcut-links 0.4.2.1 - Link shortcuts for use in text markup  http://hackage.haskell.org/package/shortcut-links-0.4.2.1 (Artyom)
04:21:55 <amalloy> i don't totally understand the difference between: (main = print . runST $ pure 1) and (main = print $ runST (pure 1)). something to do with the type variable for ST escaping? the former fails because "Couldn't match type ‘f0 Integer’ with ‘forall s. ST s a0’    Expected type: f0 Integer -> a0    Actual type: (forall s. ST s a0) -> a0"
04:34:39 <cocreature> amalloy: GHC has a hack to treat $ specially
04:35:14 <cocreature> oh actually that’s not what’s going on here, sry
04:35:20 <cocreature> :t (.)
04:35:21 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:35:27 <cocreature> :t runST
04:35:29 <lambdabot> (forall s. ST s a) -> a
04:35:52 <cocreature> GHC would have to unify the "a" in the type signature of (.) with "forall s. ST s a"
04:36:19 <cocreature> but GHC doesn’t unify a type variable with a universally quantified type (that’s what impredicative polymorphism would allow)
04:37:38 <cocreature> the hack that I was refering makes "runST $ pure 1" work
04:52:04 <siers> Is there a 'nice' way to lift a -> Int -> IO c into a -> Int -> StateT s IO c? I only thought of "do x <- use a; lift f x 1"
04:54:28 <cocreature> siers: that looks more like you want to go from "a -> Int -> IO c" to "a -> StateT s IO c"
04:54:32 <cocreature> i.e. get the Int from the State
04:55:14 <siers> nono, I actually just used int to highlight having two arguments
04:56:16 <cocreature> so do you want "Int -> StateT s IO c"? you are definitely getting some argument from the State so it doesn’t make sense to have the same number of arguments
04:56:51 <ski>   lift . (`f` 1) =<< use a  -- ?
04:56:55 <siers> ah, "a" became an english letterin that sentence
04:57:11 <siers> «a -> b -> IO c» → «a -> b -> StateT s IO c»
04:57:39 <cocreature> liftIO (f x y)
04:58:03 <siers> oh man… I do not feel coherent enough today 
04:58:31 <siers> ski got the right idea. I screwed up the types
04:58:40 <siers> sorry :D
04:59:04 <cocreature> I would just stick to do notation
04:59:22 * ski assumed missing the brackets in the original expression was just a simple oversight
04:59:32 * ski probably would, as well
04:59:47 <siers> I only do them in a single line in IRC, so I tend to forget
05:00:05 <siers> yeah, how do people who work in teams feel about pointfree expressions?
05:01:02 <cocreature> making things pointfree shouldn’t be a goal in itself. if it makes things more readable do it, if it doesn’t don’t
05:01:18 <cocreature> that’s a decision you’re going to have to make on a case by case basis
05:01:36 * ski likes calling it "pointless", as a reminder that commonly (not always) the result is not an improvement
05:02:18 <siers> oh! I never really properly realized that it's a joke
05:04:24 <siers> woo hoo, I wrote my first websocket server in haskell
05:04:49 <siers> it's not a serious application, but I used so many things to build it
05:09:33 <siers> Can aeson generate automatic sum type parsers? {"type": "ping", "seq": 1} / {"type": "auth", "user": …} and data Request = ReqAuth AuthRequest | ReqPing PingRequest?
05:25:29 <beginnerSOL-M> Hey
05:25:32 <asheshambasta> Hi, has anyone had any experience with https://github.com/morphismtech/squeal/ ? 
05:42:42 <__monty__> Hi, beginnerSOL-M 
05:57:15 <maerwald> __monty__: don't I know you from #python btw?
05:58:01 <__monty__> You might yes, don't go there often anymore.
06:35:33 <__monty__> maerwald: It's been years since I was active there though. Did I really leave such an impression?
06:36:37 <maerwald> I don't know, maybe my brain messing up nicknames, who knows
06:57:15 --- mode: glguy set +v a_
07:10:05 <coldpress> maerwald: was that a subtle joke on the nickname and the channel name?
07:10:55 <__monty__> I conceived of the nick when I was learning python, it was my first irc experience.
07:52:21 <asheshambasta> phew, need to learn more about type-level stuff in Haskell. 
07:55:42 <__monty__> Squeal heavy on the type logic?
08:06:20 --- mode: glguy set +v _rht
08:12:34 <inkbottle> [Partial "-" application]: I've got that function `(- 10)` somewhere and yes it raises an error; so I replaced it with `((-) 10)`, but then it doesn't produce the same result ;). Putting a flip in front seems a little bit an overkill...
08:13:12 <coldpress> is there a more performant concatMap?
08:14:00 <coldpress> actually ignore that, I think my memory problems come from accumulating inside foldl
08:14:11 <inkbottle> about my quest above, pointfree proposes `subtract`, So I think that's it
08:15:07 <hpc> coldpress: try foldl'
08:15:13 <hpc> foldl is almost always the wrong functio
08:15:14 <hpc> n
08:16:02 <__monty__> inkbottle: That probably exists just for that. Otherwise I'd go with a lambda.
08:19:44 <dmwit> one day we will have {_ - 10} as a syntax ;-)
08:19:51 <inkbottle> __monty__: I did go for `(flip (-) 10)` because the signification is more clear that `subtract`: why would anyone remember it's the flipped version of `(-)`? (Note I've tried "`(-)`" meaning trying to make infix operator from the prefix version of an infix..
08:20:25 <dmwit> ("Why would anyone remember subtract is the flipped version of (-)?" Answer: because they've needed a subtraction section, same as you.)
08:20:33 <inkbottle> dmwit: are you kidding?
08:20:46 <inkbottle> about {_...
08:20:48 <dmwit> Well, I've said two things. One of them was kidding, and the other was not.
08:20:55 <dmwit> Yes, that was a joke.
08:21:00 <inkbottle> OK ;)
08:21:19 <dmwit> I think it would be a nice feature, but I don't think anybody's working on it. So I put the probability of it happening in the next ten years very very low.
08:22:12 <__monty__> Would (- x) is subtraction, -x is negation be evil?
08:23:11 <dmwit> Yes, because `f -10` is `(-) f 10`, and so `f (-10)` is the standard fix.
08:23:44 <dmwit> So congratulations, you've just broken every piece of existing code that passes a negative number to a function. =P
08:24:57 <__monty__> No no, (-x) would still be negation.
08:25:02 <__monty__> Note the lack of whitespace.
08:25:21 <asheshambasta> Okay, so I'm throwing in the towel here. https://gist.github.com/asheshambasta/31c7fe8077961ac47489af3dc9b4f487#file-squeal-hs-L80 -- too much type level voodoo for my liking, I think. 
08:25:22 <__monty__> It'd be *almost* like having negative literals.
08:28:49 --- mode: glguy set +v frowny
08:30:10 <infinisil> asheshambasta: What the hell, this is not haskell anymore
08:30:41 <asheshambasta> infinisil: yeah, interesting library though
08:30:56 <asheshambasta> I spent the entire day playing with it and, in the end, succumbing to use something simpler. 
08:31:11 <infinisil> asheshambasta: You can probably insert a whole there and then ask what it's type is supposed to be
08:31:19 <TMA> if `f (-10)` is the standard fix, would `f $ -10` work too (as with `f (g h)` vs. `f $ g h`)?
08:31:34 <asheshambasta> infinisil: I've already tried that
08:31:46 <asheshambasta> I had to stop since I was starting to feel dizzy
08:32:07 <ggole> __monty__: elm does that
08:32:23 <__monty__> TMA: I don't think it does. - for negation is a little special.
08:32:33 <__monty__> ggole: elm has other problems though.
08:32:56 <asheshambasta> infinisil: https://gist.github.com/asheshambasta/31c7fe8077961ac47489af3dc9b4f487#gistcomment-2787040 voila.
08:33:42 <asheshambasta> In the end, one needs to decide if such a level of "deep embedding" of SQL into Haskell is necessary at all. 
08:34:25 <ggole> I wasn't suggesting switching to elm, just that it is a idea that has seen use in the wild.
08:36:13 <__monty__> ggole: I meant when it comes to handling of negation specifically : ), just needed some time to track down the issue. https://git.io/fpNDn
08:37:18 <__monty__> asheshambasta: And (_ & notNullable)?
08:38:21 <asheshambasta> __monty__: https://gist.github.com/asheshambasta/31c7fe8077961ac47489af3dc9b4f487#gistcomment-2787042
08:39:56 <ggole> __monty__: huh, that's a strange choice
08:40:16 <__monty__> Yes, it is : )
08:40:32 <__monty__> What bothers me most is how they seemingly don't care about the confusion.
08:41:16 <__monty__> asheshambasta: And that's not the answer? `'PGENUM ['Valid...`?
08:42:39 <asheshambasta> __monty__: doesn't seem to be, no
08:50:39 <asheshambasta> The book "Thinking with Types" also seems to suggest; "When in doubt, err on the side of _not_ doing it at the type level"; and I think in my use case, Squeal takes this a bit too far and too "deep" for my liking. I also think its vastly more important to feel productive in a programming language and deliver results in it than be bogged down with the latest new library/technique that starts to hurt your brain. 
08:59:58 <sm> I've failed at figuring out how to use bitwise and/or from https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bits.html . I've tried, in ghci, 1 (.&.) 2 and  (1::Int) (.&.) (2::Int). Why don't these work ?
09:00:34 <shiona> > 1 .&. 2
09:00:36 <lambdabot>  0
09:01:19 <shiona> ()'s around it make operators use prefix notation
09:01:23 <shiona> > (.&.) 1 2
09:01:26 <lambdabot>  0
09:01:29 <cocreature> shiona: it’s not any different from (+), 1 (+) 2 doesn’t work either
09:01:44 <cocreature> eh that was for sm
09:01:46 <geekosaur> + is a verb. (+) is a noun.
09:02:18 <sm> ohh.. thank you. I wasn't going to see that for a while :)
09:26:05 <WilliamHamilton[> I have a problem with `hcmap` in generic-sop: here's some code I was toying with https://paste.ee/p/2gaxW
09:26:48 <WilliamHamilton[> it all compiles except line 98, where I'm trying to use `hcmap` to show the terms in the SOP
09:29:00 <WilliamHamilton[> (also, I had to turn on IncoherentInstances and I'd like to learn the proper way to do without it. Try disabling IncoherentInstances to see the error)
09:34:16 <WilliamHamilton[> pinging kosmikus ^
09:34:33 <f-a> I get a     • Could not deduce (All (Compose Show (NP Term)) (Code a))
09:34:33 <f-a>         arising from a use of ‘show’
09:34:36 <f-a> WilliamHamilton[: 
09:37:06 <WilliamHamilton[> f-a: wait, let's focus on the main problem now. Leave incoherentInstances on and uncomment the line 98
09:37:11 <WilliamHamilton[> I get the error:
09:37:37 <WilliamHamilton[>     • Could not deduce: (AllF (Compose Show (NP Term)) (Code a1),
09:37:38 <WilliamHamilton[>                          AllF (All Show) (Code a1))
09:37:38 <WilliamHamilton[>         arising from a use of ‘show’
09:38:28 <WilliamHamilton[> f-a: which line do you get your error in?
09:39:08 <f-a> 99
09:39:40 <f-a> with `f = hcmap (Proxy @Show) (K . show) w` commented out
09:41:47 <WilliamHamilton[> f-a: it's strange, because that constraint is present at line 84, and I don't get that error. What ghc are you using?
09:42:18 <f-a> 8.6.3
09:44:21 <WilliamHamilton[> ok substitute the last `show w` at line 99 with "foo". Does it compile now?
09:44:24 <WilliamHamilton[> f-a: ^
09:45:31 <f-a> of course it does :P
09:46:14 <WilliamHamilton[> f-a: very good, cause that part wasn't important :D. Now uncomment line 98
09:46:44 <WilliamHamilton[> do you get the error I pasted before?
09:47:26 <f-a> yeah now I got the same error as you do
09:49:16 * hackage array 0.5.3.0 - Mutable and immutable arrays  http://hackage.haskell.org/package/array-0.5.3.0 (HerbertValerioRiedel)
09:49:58 <WilliamHamilton[> ok, so I guess my question is: how should I structure my code to be able to do line 98? Where should I put constraints? What am I doing wrong?
09:50:09 <lyxia> this Term type looks very suspicious
09:50:24 <WilliamHamilton[> it's not that I don't understand why it happens, but I don't know how to do it right
09:50:35 * hackage list-t 1.0.2 - ListT done right  http://hackage.haskell.org/package/list-t-1.0.2 (NikitaVolkov)
09:50:38 <WilliamHamilton[> lyxia: why? For the generic constraints?
09:50:50 <lyxia> yes
09:51:28 <lyxia> what does Rec represent?
09:51:31 <WilliamHamilton[> lyxia: what would be the alternatives?
09:52:02 <WilliamHamilton[> so Term represents a "prolog term". Rec represents the case in which I have some subterms that could be variables
09:52:28 <WilliamHamilton[> so for example, the thing I would write in prolog as (FooR X Y)
09:52:56 <WilliamHamilton[> lines 29-34 have some examples that should clarify the intent
09:53:25 <lyxia> OK I'm starting to get the idea.
09:55:23 <WilliamHamilton[> lyxia:  full disclosure (to convey the full picture): I've done something similar using the new generic library `generics-mrsop`, and I can get that to work, but it is a bit awkward, so I'd like to see if I can do that in `generics-sop` too
09:57:10 <lyxia> WilliamHamilton[: add a constraint  AllF (All (Compose Show Term)) (Code a)   and replace the proxy with   Proxy @(Compose Show Term)
09:57:46 <lyxia> you're trying to show a (Term a1) where a1 is the type of one field of a
09:58:05 <lyxia> but Show a1 is not sufficient to do that
10:00:42 <lyxia> I would also put the (Generic a, HasDatatypeInfo a) constraint in the instances and definitions that need it instead of hiding it in the constructor
10:03:12 <lyxia> it makes all the constraints visible near the place where they are used
10:03:20 <WilliamHamilton[> well, the suggestion works, I am impressed by the speed of debugging! Now I'll try to reconstruct the train of thought for learning purposes, and then I'll factor out the constraints
10:03:38 <WilliamHamilton[> thank you very much for your help, lyxia and f-a !
10:03:51 <f-a> haha I did actually 0
10:04:07 <f-a> and while I was wrapping my head around it, lyxia did it, apparently without even ghci open
10:04:42 <lyxia> I did get ghc's help :)
10:04:54 <lyxia> WilliamHamilton[: and it seems you can remove the IncoherentInstance now
10:09:16 <WilliamHamilton[> lyxia: indeed, the need of IncoherentInstances arose because I didn't actually understand what the problem was
10:20:22 <cjay-> +RTS -N seems to go by the number of hyperthreads instead of actual cores. I wonder if this is a good default. Stuff that I tested ran faster with -N set to the number of actual cores.
10:43:49 <kosmikus> WilliamHamilton[: I'm around now, but if I understand correctly, lyxia has solved it all already? :)
10:45:06 <WilliamHamilton[> kosmikus: yes, thank you for writing, lyxia solved it in record time! And I find the solution quite pleasant, compared to the one with generics-mrsop
10:52:37 <hpc> cjay-: with just OS threads, it's workload-dependent - hyperthreads are just the leftover clock cycles when there's a pipeline stall like for memory access
10:53:07 <hpc> cjay-: not sure if it's still workload-dependent with green threads, since for the most part threads that are waiting like that get swapped out
10:53:21 <kosmikus> WilliamHamilton[: ok, just as an added remark, you should never have to use `AllF` directly. it's an implementation detail of `All` that unfortunately leaks in error messages.
10:53:35 <hpc> maybe it's still useful for workloads with really bad memory characteristics
10:53:56 <hpc> cjay-: that seems like it would be interesting to figure out, when what settings are better
10:53:57 <kosmikus> WilliamHamilton[: just use `All` rather than `AllF` in constraints.
10:54:27 <WilliamHamilton[> I changed that constraint to `All2 (Compose Show Term) (Code a))` eventually
10:54:33 <WilliamHamilton[> does `All` subsume `All2`?
10:54:53 <nolrai> So "Illegal polymorphic type: Lens' (Int, Int, Int, Int) Int       GHC doesn't yet support impredicative polymorphism" is a GHC bug right?
10:55:26 <lyxia> no it's not
10:55:27 <kosmikus> WilliamHamilton[: no, `All2 c` is exactly the same in `All (All c)`, at least in generics-sop-0.4 and above
10:55:43 <kosmikus> WilliamHamilton[: s/in/as/
10:55:53 <cocreature> nolrai: Lens' is a type synonym for a universally quantified type
10:56:20 <nolrai> Ah, and it become impredicative when?
10:57:13 <WilliamHamilton[> kosmikus: very good, thanks for the remark, I'll avoid AllF in all the user facing code; a question though: why is All basically AllF + SListI? What does SListI buy in general?
10:57:31 <lyxia> nolrai: There are no proposals for that at the moment.
10:57:41 <cocreature> nolrai: impredicative polymorphism comes into play when you want to unify a type variable with a universally quantied type
10:57:55 <cocreature> if you show us some of your code it might be easier to give some more details
10:58:45 <WilliamHamilton[> s/in all the user facing code/in all code :D
10:59:03 <kosmikus> WilliamHamilton[: again, since generics-sop-0.4, `SlistI xs` is the same as `All Top xs`. it provides information to pattern match on the type-level list structure of `xs`, but does not enforce any constraints.
11:00:36 <WilliamHamilton[> kosmikus: got it, thanks. I'll check the new definition with Top (I remember when it was just the implicit singleton)
11:00:41 <kosmikus> WilliamHamilton[: adding the extra superclass constraint is only for convenience, because it's often needed, and never harmful, because `All c xs` morally implies `All Top xs`, but GHC cannot see that.
11:01:34 <kosmikus> WilliamHamilton[: Top is just the "empty" constraint in generics-sop, i.e., Top is a class that has all types as an instance.
11:03:59 <kosmikus> WilliamHamilton[: once generics-sop will require ghc-8.6 as a minimum, we will be able to use quantified class constraints to teach GHC a more general rule, see https://github.com/well-typed/generics-sop/issues/73#issuecomment-424237405
11:09:07 <WilliamHamilton[> kosmikus: what does the new version (with quantified class constraints) mean? I mean, not the idea of quantified constraints, I know that, but the semantic meaning of the translation
11:09:31 <WilliamHamilton[> the meaning should be `xs is a list`, how is this achieved with the first version?
11:09:45 <cjay-> hpc: I suppose that if all OS threads run something that waits for memory most of the time, having more of them just increases the cache misses
11:12:05 * hackage cabal-plan 0.5.0.0 - Library and utiltity for processing cabal's plan.json file  http://hackage.haskell.org/package/cabal-plan-0.5.0.0 (HerbertValerioRiedel)
11:12:05 <kosmikus> WilliamHamilton[: any `All c xs` constraint means "xs is a list and every element x in xs satisfies c xs". so in principle, nothing else is needed. in practice, all the unconstrained functions (hmap, hpure, ...) have `SListI` constraints which are equivalent to `All Top`. if you want to call an unconstrained function in a constrained one, you need to know `All Top xs`, not `All c xs`. and as I said, GHC 
11:12:11 <kosmikus> can currently not see that `All c xs` in principle implies `All Top xs`, so we explicitly state it as an additional constraint.
11:12:58 <kosmikus> WilliamHamilton[: the new precondition would more generally state that `All c xs` implies `All d xs` as long as for all `x` in `xs`, `c x` implies `d x`.
11:13:00 <WilliamHamilton[> no, I get that, but what does `class (..., forall d . (forall x . c x => d x) => All d xs) => All c xs` mean?
11:13:29 <WilliamHamilton[> oh I see, it's quite straightforward
11:13:36 <kosmikus> WilliamHamilton[: this in particular implies that `All c xs` implies `All Top xs`, because for all `x` in `xs`, `c x` implies `Top x` (because `Top x` trivially holds).
11:14:02 <WilliamHamilton[> sure, makes sense!
11:15:31 <kosmikus> WilliamHamilton[: have to go. good luck with this. I'll try to take a closer look at it tomorrow. would like to understand what you're trying to do in a bit more detail.
11:16:18 <WilliamHamilton[> kosmikus: sure, thank you. If you want the gist just ping me here and I'll happlily explain
11:24:00 <nolrai> cocreature: https://gist.github.com/Nolrai/cf45decf1bfe0ce86a08feb7cd831189 (Sorry I had to clean up some other bugs which turned out unrelated.)
11:27:39 <cocreature> nolrai: right, you can’t have a tuple with elements of a universally quantified type
11:28:00 <cocreature> you can make a newtype wrapper to allow that or use a monomorphized lens
11:28:29 <cocreature> ALens' should probably work
11:28:48 <koz_> cocreature: Oh, so _that_ is what the AFoo types in lens are for?
11:28:57 <koz_> I always wondered.
11:29:44 <cocreature> at least that’s what ALens is for. it’s been a while since I’ve looked at that stuff so I don’t want to make any claims about the other AFoo types :)
11:34:54 --- mode: glguy set +v qaz
11:36:21 <qaz> hello guys 
11:36:24 <qaz> isDiv :: Fractional a => a -> a -> a isDiv x y = (if isDiv x y ==x then True else False)
11:36:35 <qaz> why can't i exexute this?
11:36:42 <qaz> *execute
11:36:56 <koz_> qaz: What is the error that you get? On what inputs?
11:37:11 <qaz> sorry wrong code
11:37:13 <qaz> isDiv :: Fractional a => a -> a -> Bool isDiv x y = (if (x/y)*y==x then True else False )
11:37:31 <koz_> qaz: My questions stand.
11:38:00 <cocreature> probably because you don’t have an Eq a constraint
11:38:15 <qaz> can you please explain
11:38:15 <cocreature> also "if e then True else False" is equivalent to just "e"
11:38:25 <cocreature> show us the error first :)
11:38:26 <koz_> qaz: Fractional a does not imply Eq a.
11:39:13 <qaz> ew5.hs:36:17: error:    * Could not deduce (Eq a) arising from a use of `=='      from the context: Fractional a        bound by the type signature for:                   isDiv :: forall a. Fractional a => a -> a -> Bool        at new5.hs:35:1-39      Possible fix:        add (Eq a) to the context of          the type signature for:            isDiv :: forall a. Fractional a => a -> a -> Bool    * In the expression: (x / y) * y == x     
11:39:41 <koz_> qaz: This is telling you that, as your function uses == in its definition, a has to be an instance of Eq, but you haven't said that in your signature.
11:42:01 <qaz> I need to check divisibility of x by y . As x/y is a Fraction, then multiplying back by y, I  get initial result (True) or another fraction (False). How can i programm this behaviour in Haskell?
11:42:21 <koz_> qaz: Did you read anything that cocreature and I wrote?
11:42:34 <koz_> If you don't understand what we're saying, it's OK to ask for a clarification.
11:43:09 <qaz> ye i don't understand Eq
11:43:19 <cocreature> you probably don’t want to use / here
11:43:26 <cocreature> / is for fractional division of things like Double
11:43:37 <cocreature> checking those for divisibility doesn’t make too much sense
11:43:45 <qaz> i can't use mod
11:43:48 <f-a> why not
11:43:54 <cocreature> presumably you want something like isDiv :: Int -> Int -> Bool
11:43:58 <qaz> only "built in" functions
11:44:08 <cocreature> / isn’t any more or any less builtin than mod
11:44:18 <f-a> qaz: mod *is* builtin
11:44:34 <f-a> (from the prelude)
11:44:35 <qaz> nah it was explicitly said to me - don't use mod 
11:44:38 <cocreature> but if you want to avoid "mod", you want "div" which is integer division not "/"
11:44:44 <qaz> and div
11:44:48 <f-a> qaz: then use : "rem" :P
11:45:13 <f-a> qaz: then reimplement those yourself with + and < I guess
11:45:47 <koz_> qaz: You don't understand what Eq is, or why you need it in your case?
11:45:49 <qaz> i try to do it with /
11:45:51 <cocreature> > 1 / 2
11:45:53 <lambdabot>  0.5
11:45:57 <cocreature> this is not going to help you
11:46:00 <cocreature> > 1 / 2 * 2
11:46:02 <lambdabot>  1.0
11:46:13 <cocreature> pretty sure that this is not the behavior you are looking for
11:46:17 <qaz> oh I see
11:47:00 <cocreature> if you are not allowed to use "div" and "mod" then I think you’re going to have to tell us what you are actually allowed to use. those seem pretty strong restrictions
11:47:18 <koz_> This sounds like a homework question.
11:47:55 <qaz> + - * = <= ++ [] :
11:48:28 <f-a> do you think you can implement mod with - and <= , qaz ?
11:48:59 <f-a> *+
11:49:16 <cocreature> to check if x is divisible of y, find the first multiple of y that is >= x and check if it is equal to x
11:51:54 <qaz> not clear what you mean by find the first multiple of y
11:52:20 <cocreature> go through y, 2 * y, 3 * y, … and take the first one that is >= x
11:53:37 <qaz> but it can be a long list
11:54:12 <f-a> it deffo can
11:54:29 <f-a> use an accumulator if you are concerned
11:54:51 <cocreature> if you’re not allowed to use div and mod then I doubt efficiency is the primary concern :)
11:55:21 <qaz> is there a way to implement my initial if (x/y)*y==x  somehow
11:55:30 <cocreature> yes using div :)
11:55:47 <cocreature> (x `div` y) * y == x would give you the right behavior
11:56:11 <qaz> same error
11:56:35 <qaz> * Could not deduce (Integral a) arising from a use of `div'   from the context: Fractional a     bound by the type signature for:                isDiv :: forall a. Fractional a => a -> a -> Bool     at new5.hs:35:1-39   Possible fix:     add (Integral a) to the context of       the type signature for:         isDiv :: forall a. Fractional a => a -> a -> Bool * In the first argument of `(*)', namely `(x `div` y)'   In the first argument o
11:56:37 <koz_> qaz: Do you not understand Eq? Or do you not understand why you need an 'Eq a' constraint to write that?
11:56:44 <koz_> (well, Integral a)
11:56:49 <koz_> (and that's _not_ the same error)
11:57:40 <qaz> works great ) , now we need to get rid of div
11:57:41 <cocreature> qaz: start by figuring out the type you want. I am pretty sure your assignment doesn’t ask you to implement something of type "Fractional a => a -> a -> Bool"
11:57:56 <koz_> I'd actually like to see the exact question at this point.
11:58:34 <qaz> one moment i will type question
12:01:12 <qaz> isDiv a b returns True if when Integer a is divisible by Integer b. You can't use predefined Haskell functions. Tip: write help function that runs division with remainder
12:01:56 <koz_> Yeah, your signature needs to be isDiv :: Integer -> Integer -> Bool.
12:02:04 <koz_> According to how the question is written.
12:02:17 <cocreature> > let x `divides` y = maybe (error "foobar") (==y) (find (>= y) (map (\i -> fromIntegral i * x) [1..])) in 2 `divides` 4
12:02:18 <lambdabot>  True
12:02:22 <cocreature> > let x `divides` y = maybe (error "foobar") (==y) (find (>= y) (map (\i -> fromIntegral i * x) [1..])) in 2 `divides` 5
12:02:24 <lambdabot>  False
12:02:36 <qaz> but predefined functions
12:02:40 <cocreature> but “you can’t use predefined Haskell functions” is a pretty vague restriction
12:03:17 <qaz> i deduce that only arithmetic operations and [] : are possible
12:03:49 --- mode: glguy set +v the_other_cat
12:03:50 <cocreature> but arithmetic operators aren’t any more or any less predefined than "div" or "mod"
12:04:05 <koz_> Yeah, I'm also very confused what that restriction actually means.
12:04:22 <the_other_cat> Hi there, can I add a customized function myShow to the Show typeclass (next to prelude's show), or do I have to create a custom typeclass for this?
12:04:59 <cocreature> anyway, the implementation I showed above might qualify
12:05:05 <f-a> would your function be of type :: Show a -> a -> String, the_other_cat ?
12:05:17 <cocreature> the_other_cat: you can’t modify existing typeclasses
12:05:30 <f-a> if so, you can just make a function without making a new typeclass
12:05:50 --- mode: glguy set +v ACheesyName
12:05:52 <qaz> here you can't use Haskel predefined functions for division and modulo calculation
12:06:16 <bollu> what's the most lightweight way to profile a haskell program?
12:06:16 <f-a> then reimplement those as cocreature and the Tip: suggested, qaz 
12:06:38 <the_other_cat> f-a: now I'm confused, shouldn't it be Show a => a -> String? if so: yes
12:06:47 <cocreature> bollu: lightweight in what sense?
12:06:55 <bollu> cocreature doesn't need me to recompile the world
12:06:55 <koala_man> I'm hoping to get a better stacktrace for an exception. How do I install profiling versions of dependent libraries with cabal? I hoped 'cabal install --dependencies-only --reinstall' would do it, but it just says "Use --reinstall if you want to reinstall anyway."
12:06:58 <the_other_cat> cocreature: ok thanks for clarifying
12:07:06 <ACheesyName> https://repl.it/repls/HarshNativeAbstractions I'm not ready to study monads in detail yet can someone help me just fix this compilation problem so I can test my state machine example
12:07:28 <f-a> sorry the_other_cat , mistype, I meant => 
12:07:50 <the_other_cat> f-a: understood, thanks
12:07:59 <pounce> Hello, I'm trying to make a function point-free, and I think I have the recursive case down. But I also want to have a basecase and I'm doing that with pattern matching. GHC is complaining `equations for `f` have different numbers of arguments` and I'm not sure how to fix this without getting rid of the basecase
12:08:09 <cocreature> bollu: if you compile with DWARF debugging info you can throw perf at it which has the advantage that it doesn’t mess without optimizations (but you’ll get worse call stacks). I don’t know of a way to avoid recompilation completely
12:08:33 <bollu> cocreature nice, I never considered throwing perf at a haskell binary :) 
12:08:35 <bollu> cocreature will try
12:08:39 <bollu> cocreature thanks!
12:08:48 <cocreature> pounce: move the argument to the right
12:08:58 <cocreature> pounce: i.e. replace f x = … by f = \x -> …
12:09:16 <cocreature> but note that making a function point-free shouldn’t be a goal in itself
12:10:01 <cocreature> bollu: note that for this to produce something reasonable you also need a ghc built for DWARF debugging info
12:10:03 <pounce> yeah, i'm mostly trying to do it to figure out haskell i haven't used before
12:10:36 <pounce> cocreature: how does that help me make a base case though?
12:10:39 <bollu> cocreature oh, mh
12:11:07 <koz_> What are some ways to diagnose why a module is taking an eternity to compile?
12:11:10 <cocreature> pounce: now you can pattern match all you want on the rhs of ->
12:11:26 <bollu> my abstract interpreter builds up a bunch of maps of maps of maps, and GHC is taking unpleasantly long on simple programs
12:11:29 <cocreature> while still having an equation that takes 0 arguments so it matches your other equations
12:21:30 <cocreature> bollu: tbh the dwarf stuff is more useful if you want to make sure that profiling doesn’t mess with optimizations and less useful as a way to avoid recompilation
12:21:34 * hackage hakyll-images 0.0.1 - Hakyll utilities to work with images  http://hackage.haskell.org/package/hakyll-images-0.0.1 (LaurentRDC)
12:24:18 <bollu> cocreature mh, I see. In that case, what is your preferred method to profile GHC?
12:26:58 --- mode: glguy set +v tzemanovic
12:29:51 --- mode: glguy set -v tzemanovic
12:30:08 <dmwit> ?pl \x -> case x of [] -> []; a:b -> a:b
12:30:08 <lambdabot> (line 1, column 22):
12:30:09 <lambdabot> unexpected '>'
12:30:09 <lambdabot> expecting operator
12:30:29 <dmwit> I don't think point-free-ifying things with pattern matching in them is possible in general.
12:30:53 <dmwit> pounce: ^
12:31:48 <dmwit> If the type you're using has a catamorphism it probably is possible. But the catamorphism itself will probably be written pointfully.
12:32:12 <dmwit> (Catamorphisms are basically function-ified pattern matches.)
12:32:52 <amalloy> yeah, you should be able to write a catamorphism for any type, and given that catamorphism you could write any function on it without pattern matching
12:34:17 <tzemanovic> @help
12:34:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:34:31 <tzemanovic> @help list
12:34:31 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
12:39:12 <pounce> that's fair dmwit. just wondering, would there be a way to make a point-free version of if x == 0 then $base_value else f x ?
12:40:30 <amalloy> pounce: see Data.Bool.bool
12:41:39 <amalloy> you'll also want <*> to be able to refer to x twice
12:43:23 <pounce> just wondering, where could I find documentation for <*> ? it's a little hard to search :p
12:43:58 <amalloy> https://www.haskell.org/hoogle/?hoogle=%3C*%3E
12:44:16 <pounce> thank you!
12:44:50 <amalloy> specifically the instance for functions: http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#v:-60--42--62-
12:45:20 <amalloy> oh, hm, that doesn't link to the instance for functions
12:46:45 <MarcelineVQ> it does it's just formatted weird
12:47:04 <pounce> I also found it on the operators page 
12:47:53 <WilliamHamilton[> is there a way to emulate dependent constructors in GADTs declarations? Like:
12:47:53 <WilliamHamilton[> data Foo (a :: Nat) where
12:47:54 <WilliamHamilton[> Foo :: a -> Foo a
12:48:10 <WilliamHamilton[> sorry
12:48:27 <WilliamHamilton[> `Foo :: (a :: Nat) -> Foo a`
12:48:40 <WilliamHamilton[> what is the singletons way to do this?
12:49:12 <amalloy> pounce: if i had to write that point-free (i wouldn't), i'd write: bool <$> f <*> pure baseCase <*> (== 0)
12:49:44 <frowny> the <$> can be .
12:49:52 <frowny> not that I understand either
12:52:55 <amalloy> i never know how the precedence of other operators compares to applicative stuff, so when possible i just use the applicatives
12:54:08 <WilliamHamilton[> lyxia: ^?
12:55:52 <pounce> 0thank you amalloy ! I'm going to look more into applicatives now
12:59:47 <pounce> how are ap and <*> different?
12:59:57 <amalloy> :t ap
12:59:59 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:00:09 <amalloy> :t (<*>)
13:00:10 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:00:28 <amalloy> ap is older and requires Monad, but behaves the same as <*> 
13:01:22 <geekosaur> ap is kinda Applicative from before Applicative existed
13:02:19 <pounce> aah gotcha
13:02:35 <pounce> that makes more sense now since i get ap
13:02:52 --- mode: glguy set +v shiro[cloud]
13:06:14 * hackage sbv 7.13 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-7.13 (LeventErkok)
13:14:05 * hackage ginger 0.8.3.0 - An implementation of the Jinja2 template language in Haskell  http://hackage.haskell.org/package/ginger-0.8.3.0 (TobiasDammers)
13:19:05 * hackage wsjtx-udp 0.1.3.5 - WSJT-X UDP protocol  http://hackage.haskell.org/package/wsjtx-udp-0.1.3.5 (MarcFontaine)
13:38:05 * hackage JuicyPixels 3.3.3 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.3.3 (VincentBerthoux)
13:38:10 <lyxia> WilliamHamilton[: I'm not sure what you mean by "emulate dependent constructore"
13:40:29 <WilliamHamilton[> lyxia: as I have partially asnwered that question I'll ask a similar one: let's say I want to keep in the type of the term a list of [(Nat, Type)], so that I don't assign two types at the same variable. Something like:
13:40:49 * WilliamHamilton[ sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/lRANtSSbPkvIzEEEkKQwxfBJ >
13:41:28 <WilliamHamilton[> my original question was about the var constructor, that I was trying to write as
13:42:09 <WilliamHamilton[> Var :: Int -> Term '[ '(n, a) ] a, but I wanted the Int and the n to correspond. In the end I just let go the term level representation, and hope to extract it later via KnownNat
13:43:02 <WilliamHamilton[> now, the question is, with what should I replace the ??? in the example before? Each subterm could be tracking a different list of variables
13:44:06 * hackage Rasterific 0.7.4.2 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.7.4.2 (VincentBerthoux)
13:45:05 <WilliamHamilton[> (meta-question: is the typed representation too heavy, and should I instead do it at the term level at the cost of littering everything with Maybes?)
13:52:08 --- mode: glguy set +v qaz
13:53:01 <qaz> is there some lazy evaluation visualizer online? 
13:56:07 <ACheesyName> why can't haskell find foldl'? is foldl1 the new name of it? https://repl.it/repls/ColorfulFearlessDevices
13:56:23 <c_wraith> it's not in prelude
13:56:29 <c_wraith> you have to import it from Data.List
13:56:45 <koz_> c_wraith: You mean Data.Foldable right?
13:57:40 <geekosaur> same thing these days?
13:57:50 <geekosaur> (more or less)
13:58:11 <ACheesyName> ah it works now thanks
13:58:34 <koz_> ACheesyName: For the record, foldl1 is for _non-empty_ Foldable things.
13:59:07 <ACheesyName> I will avoid foldl1 then o_O
14:22:25 <lyxia> WilliamHamilton[: it seems easier to use the same "vars" everywhere in the term, so   Var :: (KnownNat n, Lookup n vars ~ a) => Term vars a   etc.
14:25:18 <WilliamHamilton[> lyxia: right, this seems a valid alternative, but aren't you concerned that it just moves the problem? Say that I want to use a term as part of another: do I have to enlarge the list of variable of the small one?
14:33:24 <Peter_Storm__> Hello, anyone in here use Beam>
14:33:58 <shapr> Peter_Storm__: what's beam? Is that related to erlang's beam?
14:34:14 <shapr> oh, I bet it's not : https://tathougies.github.io/beam/
14:34:22 <shapr> looks like a database lib
14:34:22 <Peter_Storm__> its the database library :)
14:34:28 <Peter_Storm__> yeah that one
14:34:36 * shapr reads more
14:35:09 <shapr> Peter_Storm__: this looks cool, what's your question about beam?
14:35:30 <Peter_Storm__> i'm trying to parameterise a delete query
14:35:42 <Peter_Storm__> and I cant get the types to line up
14:35:54 <shapr> ooh, what do you have?
14:36:07 <shapr> I haven't used beam, but I enjoy lining up types!
14:36:26 <Peter_Storm__> Beam types are crazy though xD
14:36:37 <shapr> I was just wishing yesterday for something like LINQ, where I could write basic Haskell code that gets pushed down to the actual SQL query
14:36:41 <shapr> this looks like the thing!
14:37:00 <Peter_Storm__> https://www.irccloud.com/pastebin/vBJJBvVO/
14:37:26 <Peter_Storm__> https://www.irccloud.com/pastebin/c0tUZlHB/
14:37:36 <Peter_Storm__> WHOOPS
14:37:38 <Peter_Storm__> thats wrong
14:37:40 <Peter_Storm__> the "name"
14:37:42 <shapr> Peter_Storm__: are you using type holes to help out?
14:37:51 <Peter_Storm__> is obviously not a string
14:37:58 <Peter_Storm__> Yeah, but if I just hardcode "name"
14:38:02 <Peter_Storm__> it compiles
14:38:14 <shapr> what if you put an underscore in place of "name" ?
14:38:19 <shapr> what type do you get?
14:39:04 <Peter_Storm__> https://www.irccloud.com/pastebin/bmCDHQCK/
14:39:08 <Peter_Storm__> but again
14:39:14 <Peter_Storm__> when I just write a literal Text string
14:39:15 <shapr> ok wow, you weren't kidding
14:39:19 <Peter_Storm__> it compiles
14:39:57 <Peter_Storm__> I'm literally just trying to parameterise this: http://tathougies.github.io/beam/user-guide/manipulation/delete/
14:40:06 <Peter_Storm__> maybe it just doesnt work
14:40:38 <geekosaur> where did you get "_name" from?
14:41:01 <geekosaur> that would normally be a "name not in scope" error, but leadin underscore makes it a typed hole if not otherwise defined
14:41:16 <monochrom> Yes we are intending a typed hole.
14:41:22 <shapr> yeah, I requested that
14:41:32 <geekosaur> oh, sorry,. missed
14:41:40 * shapr hugs geekosaur 
14:41:41 <monochrom> But yes also always show the latest complete code
14:42:04 <monochrom> Humans cannot compete with the "patch" unix program.
14:42:05 <Peter_Storm__> again, if I hardcode the `name`
14:42:18 <Peter_Storm__> it works fine, and it's just `Text` afaik
14:42:36 <geekosaur> anyway, a string literal will either be type String, or will be (IsString s => s)
14:42:51 <geekosaur> so you don't know that it's actually a Text it wants there
14:42:58 <Peter_Storm__> It is
14:43:05 <Peter_Storm__> Beam works with Text
14:43:25 <shapr> Peter_Storm__: what would you want there instead? I think the code with "name" checks to see if pathPathName is equal to that value?
14:43:26 <Peter_Storm__> With OverLoadedStrings and all that, right?
14:43:27 <geekosaur> actall it looks to me like ti wants something wrapped around Text for some reason
14:43:59 <Peter_Storm__> shapr: Yeah, delete the row that has that name
14:44:04 <monochrom> With OverloadedStrings you actually know less, not more. Because string literals get more polymorphic.
14:44:42 <geekosaur> ^
14:44:48 <monochrom> Pretty sure their "QGenExpr blah blah blah Text blah blah" is also an IsString instance therefore a vanilla "name" gets that type not Text.
14:44:58 <geekosaur> wich is the point I was making
14:45:01 <shapr> Peter_Storm__: so you tried something like (\s -> delete (customer chinookDb)  (\c s -> customerFirstName c ==. s)) ?
14:45:04 <monochrom> I mean like that's literally what the errro message says.
14:45:20 <monochrom> Sometimes you've got to believe the error message and disbelieve yourself.
14:45:50 <shapr> monochrom: are you saying debugging is the act of discovering how my worldview does not match reality?
14:46:04 <monochrom> So we're seeing the second most popular myth.
14:46:17 <shapr> now I want to know all the popular myths!
14:46:18 <geekosaur> shapr, now you're getting it :)
14:46:33 <shapr> Peter_Storm__: what parameterized code failed to compile?
14:46:36 <monochrom> The #1 most popular myth is "$ replaces parentheses". So now the #2 is "OverloadedString gives you Text".
14:46:47 <Peter_Storm__> shapr: Yeah, again if I hardcode the name to just `"name"` it compiles
14:47:29 <shapr> if nothing else, you could nail down an incorrect type for "name" and see what type is required
14:48:01 * shapr continues to fail to install nixos
14:48:05 <monochrom> Actually there are also "big-O means worst case, big-Omega means best case" but they are not specific to Haskell.
14:48:27 <Peter_Storm__> Yeah, ok... I just needed to wrap it :D
14:48:35 <Peter_Storm__> with a `val_` function
14:48:40 <geekosaur> ...right, so this wants a QGenExpr, not simply a Text, because it can e.g. be a reference to a column name (e.g. where columnA = columnB). so actual values need to be "promoted" somehow
14:48:42 <geekosaur> yeh
14:48:49 <shapr> oh good, I like to think we helped
14:48:59 <Peter_Storm__> yeah, you guys definitely did
14:49:05 <Peter_Storm__> Thanks guys :)
14:50:07 <shapr> yay!
14:52:13 <geekosaur> I got pulled into another discussion (we're debugging os x builds...)
14:52:34 <__monty__> monochrom: Worst-case is not a good way of looking at O()?
14:53:01 <monochrom> How should I answer? No.
14:53:54 <__monty__> Maybe explain why? Or explain what *is* a good way to think of it?
14:54:01 <monochrom> Or maybe I should counter-ask. Who said it's a good way and why?
14:54:38 <__monty__> My intuition. Not sure where that guy got it any more.
14:54:41 <monochrom> OK but I want to train people to explicitly ask what they want to ask.
14:54:48 <__monty__> But being bounded above does sound like worst-case.
14:55:09 <__monty__> As long as we're talking tightest bound.
14:55:29 <ddellacosta> at the end of the last paragraph in the section of the Roles GHC trac page (https://ghc.haskell.org/trac/ghc/wiki/Roles#Theproblemwewishtosolve) it says "...so we have effectively converted a Bool to an Int." Shouldn't this be the opposite, i.e. "Int to a Bool?"
14:55:37 <__monty__> And knuth's big-omega the same but vice-versa.
14:56:21 <monochrom> Big-O is a set of functions that satisify a certain mathematical criterion. The criterion says nothing about what those functions stand for.
14:56:28 <__monty__> Also, I think I remember being taught big-theta is "performance on average."
14:56:55 <monochrom> or where those functions came from.
14:56:58 <__monty__> What do you mean by stand for? Space v. time?
14:57:03 <monochrom> Yes.
14:57:20 <Solonarv> space vs. time, best/average/worst case, etc
14:57:30 <__monty__> Worst-case doesn't change definitions whether you're talking about space or time though.
14:57:41 <Solonarv> It does change complexity
14:57:44 <monochrom> For example "lg n in O(n)" is a provably truse statement.  Sign your name here if you agree.
14:57:59 <hpc> provably truse?
14:58:06 <monochrom> probably true.
14:58:19 * nshepperd agrees that's probably true
14:58:35 <monochrom> I know right? You suspect it's "provably ruse"
14:59:07 <hpc> it's definitely true
14:59:08 <nshepperd> space vs. time, best vs average vs worst, amortized vs oneshot
14:59:48 <monochrom> I want 100 signatures before I continue. :)
15:00:23 <__monty__> Then I'm off. Update me on the petition's status tomorrow.
15:00:44 <nshepperd> many things you could be talking about... and big-O vs theta vs small-o is orthogonal to all of those
15:00:55 <monochrom> I need you to show commitment so you can't back out later when I show you the logical conclusion that you happen to dislike.
15:01:08 <hpc> specifically: f(x) = O(g(x)) iff exists M x_0, forall x >= x_0, |f(x)| <= Mg(x)
15:01:11 <monochrom> But yeah what nshepperd just said.
15:01:39 <hpc> M = 1, x_0 = 5 (too sleepy to do logarithms)
15:02:00 <monochrom> My lg n there could be something's worst case time, or maybe something's best case time, or worst case space, or best case electricity consumed, or just a function I pull out of thin air and has nothing to do with any algorithm or problem.
15:02:24 <monochrom> Nonetheless "lg n in O(n)" is provably true regardless of why I care so much about lg n and n.
15:03:03 <hpc> when we talk about algorithms, imagine some magic operation worst_case_time :: Function -> Function
15:03:13 <hpc> and when we talk about the efficiency of say, a sorting algorithm
15:03:23 <hpc> we're saying worst_case_time(sort) = O(something)
15:03:54 <hpc> using that wonky predicate above
15:03:57 <geekosaur> ddellacosta, no, they start with Int, which without roles coudl coerce to Age, thus Inspect Int to Inspect Age, hence Bool to Int
15:04:00 <Solonarv> O / o / Ω / ω / Θ is "how fast does this function grow", best/worst/average/space/time/oneshot/amortized is "which function are we even talking about"
15:04:01 <monochrom> I can theorize why people conflate them.  Too many things to learn so they must simplify something.
15:04:02 <__monty__> Usually you say time(sort) = O(something) though.
15:04:47 <geekosaur> monochrom, worse than that, actually. our brains do that without telling us
15:04:53 <hpc> __monty__: worst case is more standard in my experience - there are security implications to thinking any less
15:05:16 <hpc> (specifically for avoiding denial of service attacks)
15:05:47 <__monty__> Everything I've seen, which granted isn't much, used time().
15:07:29 <monochrom> And now on to "tight bound".
15:08:28 <monochrom> While we believe that people converse in good faith therefore when someone says "my algorithm takes O(n) time" they mean you can't really change "n" to anything lesser so they mean "Theta(n)"
15:08:38 <monochrom> nothing in the math says that it must be so.
15:09:39 <monochrom> A constant-time algorithm still qualifies as "my algorithm takes O(n)" time.  Only social conventions frown upon speaking like that.
15:10:21 <monochrom> Because "my algorithm takes time a certain function f(n), and f(n) in O(n)" is still a true statement for a constant-time algorithm.
15:10:28 <ddellacosta> geekosaur: thanks
15:10:49 <geekosaur> ou do have to read the midle of the paragraph carefully to catch that; it'sa bit confusing
15:11:19 <geekosaur> the way it's presented, you expect the other way around unless you follow it careflly
15:12:40 <platz> if you have an infinte list of ST s [Int] , can you lazily consume it?
15:12:41 <dminuoso> monochrom: Have you read the "Myth of RAM" articles? It's a nice insight into a special pitfall that is commonly ignored when doing complexity analysis.
15:12:57 <monochrom> platz: Depends on actual code but likely not.
15:13:01 <ddellacosta> geekosaur: yeah, I've read it a few times already and I'm still confused! Trying again now though, thank you for the clarification
15:13:45 <geekosaur> Ifollowed it but had to keep a sort of translation table in my head for what the type family was doing throughout
15:13:53 <monochrom> dminuoso: No. But I think I can guess. If you have n bits of space, you need lg n time not constant-time to fetch.
15:13:59 <dminuoso> monochrom: Spot on. :)
15:15:05 * hackage inline-c 0.7.0.0 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.7.0.0 (FrancescoMazzoli)
15:15:09 <platz> so then if you're building an infinite mutable vector in ST, it sounds like you can't produce a list of what has been build so far
15:15:09 <dminuoso> monochrom: The articles go far enough to provide with some examples that this is actually reflected in cache hierarchies quite well.
15:15:22 <dminuoso> http://www.ilikebigbits.com/2014_04_21_myth_of_ram_1.html and the following 3 articles.
15:15:32 <platz> even if the whole thing is in ST
15:15:48 <monochrom> I think s/even if/because/ actually.
15:15:52 <ACheesyName> except it's not that clear that you need lg n time to fetch. you certainly need lg n space. but if, e.g., you only increment pointers thats amortized constant time per operation
15:16:01 <glguy> If you're careful you can produce a lazy list with ST to be consumed from outside the ST environment
15:16:34 <dminuoso> ACheesyName: No it's not. Pointers consume space.
15:16:38 <platz> that sounds like what i want but i'll have to play with it more, thanks
15:17:12 <__monty__> Not quite with it yet. If someone says "algorithm X has time complexity O(n)" why isn't that roughly equivalent to, "Algorithm X'll take n steps in the worst case."?
15:17:43 <ACheesyName> dminuoso: that's what I said. but manipulating a pointer does not necessarily involve touching all the space consumed by the pointer. in theory.
15:18:09 <monochrom> dminuoso: Even back when there was no cache, RAM itself was organized into "it takes logBase b n units of time to decode an address because the decoding circuit has that many layers". It's just that n is merely 64KB and b is very large so logBase b n <= 3 in practice.
15:19:34 <dminuoso> monochrom: Oh interesting. So it was kind of NUMA?
15:20:05 <monochrom> No it's very uniform. Every address, be it 00000000 or FFFFFFFF, takes the same amount of time.
15:21:02 <monochrom> The "decoding circuit"'s job is to take an address and determine which chip is responsible.  The decoding circuit is a complete tree of depth logBase b n.
15:21:16 <dminuoso> monochrom: Oh actually I need to correct myself, the factor is O(sqrt(n)) for most common O(1) algorithms, say array lookup.
15:21:23 <Solonarv> "time complexity" by itself is an ambiguous term.
15:21:23 <monochrom> b is proportional to chip capacity so it's a big number
15:21:51 <dminuoso> monochrom: That is, array lookup takes O(sqrt(n)) time complexity for an array of length n.
15:22:08 <dminuoso> Which is dictated by essentially the bekenstein bound and speed of light.
15:22:26 <monochrom> OMG I didn't think of that.
15:22:33 <Solonarv> "Algorithm X'll take n steps in the worst case." is expressed by "Algorithm X has a worst-case time complexity in Θ(n)"
15:22:56 <Solonarv> (at least I think it's Θ, feel free to correct me if I'm wrong)
15:23:02 <monochrom> Yeah we live in 3D space not 100D, there are going to be physical limits...
15:23:25 <Solonarv> even in 100D there would be physical limits, I think.
15:23:26 <monochrom> Yeah Θ is right
15:23:56 <monochrom> Yeah, just more head room.
15:24:15 <dminuoso> monochrom: The interesting bit is, is that cache hierarchies (up to paging onto the disk) fits the O(sqrt(n)) curve quite well on most systems.
15:24:17 <Solonarv> More poignantly, our universe is effectively discrete as far as this subject is concerned
15:24:26 <monochrom> At least we thank God we still don't need to worry about the holographic limit :)
15:24:32 <Rembane> dminuoso: Why the sqrt? 
15:24:35 * hackage tidal 1.0.1 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-1.0.1 (AlexMcLean)
15:24:53 <dminuoso> Rembane: How familiar are you with theoretical physics relating to black holes?
15:25:18 <Rembane> dminuoso: I know some of the words, that's about it. 
15:25:57 <dminuoso> Rembane: So the idea is very simple: The maximum amount of information you can stuff into some region of space is essentially described by a black hole.
15:26:26 <dminuoso> And it turns out that the amount of information is not dicated by its volume, but its surface area.
15:28:55 <__monty__> Solonarv: That didn't actually answer my question though. It just gave another way of saying the second part.
15:29:33 <Solonarv> it isn't equivalent because it isn't equivalent.
15:30:11 <Rembane> dminuoso: And the surface is a square, so that's where the square root shows up?
15:30:12 <Solonarv> There is no deep reason why it isn't equivalent, just like there's no deep reason why 'x+1 = 0' and 'x < 0' aren't equivalent.
15:31:18 <__monty__> Solonarv: We're not talking mathematical equivalence here. More like, hand-wavingly they're the same.
15:31:42 <__monty__> Given non-malacious things like providing a tight O(..).
15:32:02 <Solonarv> hand-wavingly they *still* aren't quite the same
15:32:25 <dminuoso> Rembane: Right. So from the center of the sphere, you get (r^2 * some_factor) for maximum amount of information.
15:32:53 <Solonarv> analogy: "this algorithm has O(n) complexity" is like saying "people are 170cm tall"
15:32:55 <monochrom> __monty__: If you saying "Θ(n)" then I would agree "yeah roughly proportional to n" but even then watch out for oddballs like 3n+sqrt(n).
15:32:57 <dminuoso> Rembane: So at that point you just take speed of light into consideration, and you get sqrt(n) worst time access for the above case.
15:33:35 <dminuoso> Rembane: and since of course the bekenstein bound gives you an upper bound (if you reach that, the volume collapses into a blackhole), you have your upper bound
15:34:07 <Rembane> dminuoso: That's amazing! Thank you! 
15:34:48 <Solonarv> __monty__: does that analogy help?
15:35:23 <monochrom> Actually I don't understand that analogy :)
15:35:30 <Rembane> dminuoso: How close to a black hole in information density do we get? Like... when do we have to go from O(1) to O(sqrt(n))?
15:35:39 <__monty__> Solonarv: Not really, I don't see what average height and functions have to do with each other.
15:36:13 <Solonarv> note that I did *not* say average height, I just said height. My example statement is ambiguous.
15:36:34 <Solonarv> Depending on the context, it could be interpreted as an upper or lower bound as well.
15:36:37 <__monty__> monochrom: But why then don't you go "Ah O(n), that means n or better but watch out for oddballs like 3n+sqrt(n)."?
15:36:38 <dminuoso> Rembane: Big O considers *worst* case, we don't take some arbitrary limit.
15:37:00 <monochrom> With O(n) there are additional oddballs like 42.
15:37:24 <Solonarv> dminuoso: we do take a limit... but the limit is +infinity
15:37:25 <monochrom> But yes.
15:37:33 <__monty__> monochrom: Note that I said non-malicious, so 42'd be O(1).
15:37:35 <Rembane> dminuoso: That's a very good point. I tend to forget that. 
15:38:50 <Solonarv> __monty__: similarly, "this algorithm takes <blah> time" is ambiguous, because it isn't clear whether you're talking about average, lower/upper bound, or something else.
15:39:02 <monochrom> I like to act in good faith and believe that other people do too.  But really "Θ" is just one more stroke than "O", how hard is it?
15:39:21 <Solonarv> To be fair it is significantly more annoying to type on most keyboards
15:40:00 <__monty__> Also, most people don't know about little-o, let alone big-theta.
15:40:31 <__monty__> Isn't there some quote about fast-and-loose reasoning being morally correct?
15:40:34 <monochrom> And precisely because I act in good faith, I make more effort, not less, to make more precise statements, not less precise, and I minimize, not maximize, the smugness of "you know what I mean".
15:40:49 <dminuoso> __monty__: In CS context big-theta and big-o seem to be used interchangably far too often, a mistake I like to make too.
15:41:06 <__monty__> I guess I'll just have to run into a situation where my intuition about O() leads me astray to get it. Have a good night.
15:41:10 <Solonarv> Fast-and-loose reasoning does tend to be correct surprisingly often, but not always.
15:41:28 <monochrom> O, Theta, Omega are covered in the main text of CLRS and most other textbooks too.  I am not very imposing, really; I am not going little-o.
15:42:35 * hackage ginger 0.8.4.0 - An implementation of the Jinja2 template language in Haskell  http://hackage.haskell.org/package/ginger-0.8.4.0 (TobiasDammers)
15:42:38 <monochrom> Fast loose morally intuition are OK if you know under what circumstances they are enough and under what circumstances they break.
15:42:50 <dminuoso> I mean it's factually correct that big-O complexity of array lookup gives you this bound O(n!)
15:42:50 <__monty__> I for one had never heard of CLRS. And not everyone worried about the performance of algorithms has a CS degree.
15:42:56 <dminuoso> Whether this is a useful thing to say I dont know.
15:43:08 <monochrom> The litmus test is this: The ability to be formal and precise is your license to be informal and imprecise.
15:43:25 <dminuoso> So I should correct myself and state: Array lookup has Θ(sqrt(n)) time complexity for an array of length n. 
15:44:24 <monochrom> Not going to school is not an excuse for staying ignorant and wrong.
15:44:57 <ACheesyName> what's the most commonly used type for arbitrary bytes in haskell?
15:45:05 <hpc> ByteString
15:45:12 <monochrom> As soon as you claim to be professional you have to learn and care.
15:46:10 <monochrom> If it's difficult to learn then tough. You chose this profession and you chose to claim to be a professional, even waving your self-crowned "engineer" title.
15:46:16 <dminuoso> Is there a way to keep myself from accidentally using OverloadedStrings with ByteString?
15:46:27 <__monty__> I think the reason people don't use big-theta shows when you look at one of the earliest examples in complexity courses. Quicksort is O(n^2) but it's not Θ(n^2).
15:47:55 <MarcelineVQ> I've not even heard of Θ :X
15:48:02 <dminuoso> __monty__: According to what definition?
15:48:14 <Solonarv> dminuoso: don't turn on OverloadedStrings? turn on RebindableSyntax and use a fromString that doesn't work on ByteString?
15:48:19 <__monty__> dminuoso: Not sure what you mean?
15:48:28 <monochrom> Yes in the education scene there are also a lot of watering down because they know you can't take both O and Theta.
15:49:21 <monochrom> Down that slippery slope you also get to say "most schools don't teach FP; most people don't even go to school".
15:49:50 <Solonarv> MarcelineVQ: IIRC, Θ() essentially means "the tightest O() bound possible"
15:50:00 <MarcelineVQ> as in not-amortized?
15:50:17 <Solonarv> Amortized or not is orthogonal
15:50:24 <MarcelineVQ> oh, hmm
15:50:29 <__monty__> Solonarv: No, it's bounding below as well as above. Tightest O() doesn't necessarily bound below.
15:50:35 <hpc> monochrom: most people aren't even programmers!
15:50:59 <Solonarv> Amortized or not is "which function are we talking about", O vs Θ are different statements about that function
15:51:06 <Solonarv> __monty__: ah, thanks for the correction
15:51:18 <monochrom> Recall that O(g) comes down to "f <= constant * g(n)".  Theta upgrades that to "constant1 * g(n) <= f(n) <= constant2 * g(n)" so try to think sandwiching.
15:51:53 <dminuoso> monochrom: Well Big-Theta is Big-O and Big-Omega combined
15:52:00 <dminuoso> That's the way I remember it.
15:52:01 <monochrom> More examply, "lg n in O(n)" is true, but "lg n in Theta(n)" is false.
15:52:28 <monochrom> Yeah. Except people then complain to you about not having heard of Omega. "Now you have two problems." >:)
15:52:39 <__monty__> monochrom: I don't understand your tangent tbh. It doesn't address the quicksort example at all afaics.
15:52:55 <MarcelineVQ> I thought O was Ω ehe
15:53:22 <monochrom> Should I address it? What do you expect of me, really?
15:54:21 <dminuoso> __monty__: big-theta for quicksort does not exist?
15:54:51 <dminuoso> I mean quicksort has Ω(n*log n) and O(n^2) for worst case.
15:54:59 <__monty__> monochrom: I don't expect anything. Since we were having a conversation I was hoping you'd answer with agreement or disagreement+motivation. You don't think that the simplest example making big-theta inconvenient matters with regards to its usage?
15:55:06 <dminuoso> For best or average case you have Θ(n*log n) though.
15:55:29 <__monty__> dminuoso: It does. But only when you're looking at one of the cases specifically. O(n^2) is true for all of them.
15:55:44 <__monty__> Hence it's easily interpreted as O == worst-case.
15:55:46 <dminuoso> __monty__: Just like Ω(1) holds for *any* algorithm
15:56:08 <dminuoso> Well O is just an upper bound. You might as well say O(n!) for quicksort
15:56:19 <dminuoso> It still holds true.
15:56:23 <__monty__> dminuoso: We get back to the non-malicious assumption that the bound is tight.
15:57:11 <Solonarv> but the O(n^2) bound on quicksort is only tight on the worst case!
15:57:17 <dminuoso> __monty__: But isn't that making up some definition? 
15:57:39 <__monty__> Solonarv: Which means it's also tight on any-case : )
15:58:00 <__monty__> Solonarv: We're not looking at the cases one-by-one is the point.
15:58:35 * hackage tidal 1.0.2 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-1.0.2 (AlexMcLean)
15:58:38 <geekosaur> dminuoso, I'd claim it's metamatematics: if you're not using the same general rules, you migth as well be speaking different languages
15:58:51 <Solonarv> well that's fine if you want to be really ambiguous and hand-wavy
15:59:31 <monochrom> My opinion is that this "non-malicious assumption" was invented to avoid doing the legwork of learning big-Theta.
15:59:31 <__monty__> Regardless of whether that's good to do or not. Most people only pick up the basics of complexity theory and that's what they pick up. I don't (yet?) see a point in fixing their mental model and saying they're wrong for thinking O is worst-case.
15:59:34 * hackage inline-c 0.7.0.1 - Write Haskell source files including C code inline. No FFI required.  http://hackage.haskell.org/package/inline-c-0.7.0.1 (FrancescoMazzoli)
16:00:00 <geekosaur> if you haven;'t agreed thatour'e using reasonably tight bounds, you're conveying much less information wit your statement
16:00:33 <dminuoso> geekosaur: Then you're abusing the big-O notation to mean something different.
16:00:47 <dminuoso> If the point is not to give an upper bound, but to give an upper tight bound - maybe we should invent a new symbol for that.
16:01:05 <dminuoso> Rather than overloading O(...) and leaving the reader to guess what the author possibly meant.
16:01:16 <geekosaur> dminuoso, no, tis is not about big-O. this is about *talking about* it. this is about "if I say 3, I mean 3 and not 5"
16:01:21 <monochrom> In practice I'm flexible adaptable agreeable so when I speak to a community that only knows O and uses it for Theta without knowing I can speak their language and not cause trouble.
16:01:39 <monochrom> But there is also the angle of why accept the status quo and not improve it.
16:01:42 <dminuoso> monochrom: Oh absolutely I dont mind redefining things, but that needs to *happen* at least.
16:01:44 <geekosaur> in a conetxt where either si true, but 3 is the more &*useful* one for reasoning. not for mathematics,for communication adn what we do inside our heds
16:01:49 <dminuoso> Or it needs to be crystal clear from the context.
16:02:12 <dminuoso> geekosaur: Your typing quality is suprisingly degraded. New keyboard? :)
16:02:36 <geekosaur> we have general constraints so we don't he to assume everything is handwavy and must immediately be clarified
16:03:01 <geekosaur> your "but that's abusingBog==ig-O"is my "but no I have to ask what you *really* mean"
16:03:03 <geekosaur> erp
16:03:08 <geekosaur> eh, tis keyboard is crap
16:03:30 <monochrom> decaying keyboard or something :)
16:03:54 <geekosaur> that one was a backspace gone wrong :/
16:04:01 <geekosaur> I type way too fast for this steaming pile
16:04:32 <geekosaur> and then don't notice until after I send, or I do and then don't notice it dropped the attemtped edit
16:05:23 <__monty__> Thanks for the discussion, I'll mull it over but I haven't really been convinced yet.
16:05:25 <geekosaur> anyway, you're disputing because it' *correct*, I'm disputing becaue it's not *useful*
16:06:53 <geekosaur> or it's correct but misleading.
16:07:13 <__monty__> Fwiw, I sympathize with geekosaur's view.
16:07:18 <geekosaur> whichis why I said it's meta-mathematics
16:09:28 <nshepperd1> Pretending that big-O is big-theta and calling not doing that 'bad faith' seems rather antisocial
16:10:18 <monochrom> Actually, why? Actually, what's antisocial?
16:10:29 <nshepperd1> There are cases when you can prove big-O, and you can't prove theta
16:10:47 <geekosaur> if I have to assume everything you say is low precision and must be refined, which one is antisocial?
16:10:59 <nshepperd1> In which case, how do you communicate your result if people will interpret it as theta?
16:11:18 <geekosaur> I'm more likely to asusme you're annoying and go find someone who folows the social contract on precision
16:11:21 <hpc> by communicating it correctly and relying on people to know the generally accepted mathematical foundations it's built on
16:12:04 <dminuoso> hpc: That's what communication is based on, a mutual understanding that both parties have the same agreed upon definitions for some terms.
16:12:29 <monochrom> Because my impression of "social" is "what the majority do, the norm" and so if the majority accuses you of bad faith (even if they are wrong and you are right), then accusing you is social and defending you is antisocial. No?
16:12:37 <nshepperd1> If you mean theta, you can say theta
16:12:39 <dminuoso> It greatly hinders communications when people start mixing terms up, forcing you to deduce what you might have meant. It's part of human language sadly, but it should have no place in CS or mathematical environments.
16:13:17 <monochrom> Also some communities are not worth joining. As a last resort.
16:15:25 <isd> Hey all, I'm working through Sandy Maguire's book on type-level programming in Haskell. It's been a fascinating read, but there are a lot of clerical errors, and I'm hitting an example in the book that doesn't type check and I can't work out what's wrong. Any ideas: https://pastebin.com/p31iBg2S ? (type error is at the bottom in the comment).
16:16:58 <isd> Ah, of course I work it out right after giving up and asking
16:17:10 <hpc> heh
16:17:16 <isd> MapList should end in Exp [b] not Exp b.
16:17:18 <koz_> isd: I've notified Sandy about those errors.
16:17:23 <koz_> (well, _some_ of those errors)
16:17:31 <isd> Yeah, there are a lot.
16:17:32 <koz_> He told me it'll be in the next release about a week ago.
16:17:38 <koz_> Feel free to email him with more.
16:17:59 <monochrom> "Fixed in HEAD" >:)
16:18:06 <koz_> If you're _really_ motivated, send him a PR: https://github.com/isovector/thinking-with-types
16:19:08 <koz_> But thanks for buying the book, isd!
16:19:13 <koz_> It's very cool.
16:19:18 <isd> Indeed
16:19:25 * koz_ bought it on release.
16:19:28 <isd> (that example was also missing the TypeOperators extension...)
16:19:35 <isd> I got it a couple weeks ago
16:37:08 <hpd[m]1> As someone being only familiar with dead-tree books: Do you get an updated copy of the ebook if you bought it and a new version is released?
16:37:18 <koz_> hpd[m]1: I guess so.
16:37:23 <koz_> I didn't think to ask.
16:38:40 <hpd[m]1> ok. I might buy it anyways :-)
16:43:06 <concaveirc> Hello all, is there a type that represents a 2-d grid of objects accurately for something like Minesweeper?
16:43:20 <koz_> concaveirc: Depends on what you need done with it.
16:43:29 <concaveirc> A list of lists could work, but the constraint about all of the sublist sizes having to be the same would be ignored
16:43:39 <koz_> You can represent a 2D grid of 'objects' in a variety of ways, depending on what 'objects' you are interested in.
16:43:47 <koz_> concaveirc: Check out massiv.
16:43:54 <koz_> It might be what you seek.
16:44:16 <concaveirc> I'm thinking of creating a type for the types of Minesweeper tiles, and use Maybe to describe whether or not a tile has been revealed.
16:44:18 <koz_> (list of lists isn't a very good representation if you care about random access, which for something like Minesweeper, you probably very much do)
16:44:57 <Solonarv> Maybe doesn't seem like a great idea: even if the player hasn't revealed a tile, the *game* still needs to know what's there
16:44:57 <glguy> The array package's Array (Int, Int) type is convenient for dealing with 2-d grids like that
16:45:12 <concaveirc>   Actually, Maybe would not work as there is no notion of being, say, a 5 tile while it is a nothing.
16:45:24 <concaveirc> Oh, yeah, what Solonarv said
16:45:24 <Solonarv> Yes, that was my point :>
16:46:13 <Solonarv> glguy++
16:46:48 <hpc> or even better, Array (Word, Word)
16:47:39 <concaveirc> Why Word? is it because of the size of the array being small?
16:47:41 <Solonarv> How's that better?
16:47:49 <concaveirc> Array looks good though.
16:47:54 <hpc> you generally don't have negative indexes for arrays
16:48:14 <Solonarv> if you want to express "nonnegative integer", use Natural
16:48:47 <hpc> Solonarv: that introduces libgmp, if the other type used Integer i might have suggested that though
16:48:49 <ACheesyName> what's the syntax for requring a type variable to be an instance of a type class in a "data" declaration?
16:49:09 <Solonarv> There isn't one. DatatypeContexts is deprecated.
16:49:12 <concaveirc> I see. Has anyone used Math.Geometry.Grid in the grid package? It looks similar to array to me, and handles adjacency.
16:49:17 <geekosaur> you mostly don't, because it doesnt do what you want
16:49:39 <geekosaur> it tests it when you make a value, it doesn't give you the constraint wen you use it. put the constraint on the use
16:49:56 <hpc> ACheesyName: if you really really want it, you probably want a GADT
16:50:07 <hpc> data Foo a where Foo :: Num a => a -> Foo a
16:50:46 <hpc> then you can write
16:50:54 <hpc> doSomething :: Foo a -> Foo a
16:51:02 <hpc> doSomething (Foo a) = Foo (a + 1)
16:51:10 <hpc> pattern matching brings the class constraint into scope
16:52:14 <ACheesyName> so I should rather put the constraint on the functions that accept the data type?
16:52:26 <hpc> generally yes, that's the way to go
16:53:16 <hpc> oh, also
16:53:39 <hpc> when you do that GADT thing, you don't have the protection of the class constraint on doSomething
16:53:42 <hpc> doSomething (undefined :: Foo ()) :: Foo ()
16:53:45 <hpc> ^ is valid
16:53:50 <hpc> even though there's no instance Num ()
16:53:55 <koz_> \query lambdabot \x -> (**) <$> getRandomR (0, 1) <*> (pure . recip $ x)
16:54:11 <koz_> Argh, forgot something important.
16:54:23 <koz_> \query lambdabot
16:54:41 <hpc> koz_: https://sprignaturemoves.com/wp-content/uploads/2011/06/slash-backslash.png
16:54:42 <koz_> Huh, my PMs are failing, weird.
16:54:45 <MarcelineVQ> /
16:54:51 <koz_> Oh. Lol.
16:54:55 <hpc> just follow the guitars
16:55:42 <koz_> Yeah, the pointfree version isn't any nicer. :(
16:56:10 <glguy> Switching to Word because you won't have negative numbers is unnecessary
16:56:16 <glguy> You also won't have super huge indexes
16:56:40 <glguy> You'll have the same number of invalid indexes and you just wrap-around behavior to a more confusing index when you have a bug
16:56:57 <Solonarv> Yeah, good point
16:57:08 <hpc> > maxBound :: Word + 1
16:57:10 <MarcelineVQ> negative indexes are an advantage if you want to have 0,0 be the center of things as well, it seems to me
16:57:10 <lambdabot>  error:
16:57:10 <lambdabot>      Not in scope: type constructor or class ‘+’
16:57:17 <hpc> > maxBound + 1 :: Word
16:57:19 <lambdabot>  0
16:57:21 <glguy> and you'll have a type that is less convenient to use with the rest of the Int ecosystem
16:57:28 <Solonarv> @hackage finite-typelits - If you want to be super safe you can use this
16:57:28 <lambdabot> http://hackage.haskell.org/package/finite-typelits - If you want to be super safe you can use this
16:57:29 <hpc> ah right, forgot about overflow
16:57:32 <glguy> It's just a new source of error
16:57:33 <Solonarv> But I wouldn't recommend it
17:00:32 <koz_> What's a good priority queue implementation for Haskell?
17:00:56 <sm> psqueues ?
17:02:09 <hpc> do cpus have a good way to make overflowing operations fail? i have completely forgotten
17:04:02 <koz_> sm: Thanks, looks great.
17:04:19 <geekosaur> generally not for machine words
17:04:31 <geekosaur> floating point ops generally do
17:04:38 <hpc> yeah for floats it's trivial
17:04:47 <hpc> the spec says overflows become Inf
17:04:49 <geekosaur> but you have to add check instructions of some variety for e.g. Int
17:05:10 <hpc> blegh
17:05:29 <monochrom> For machine word arithmetic, CPUs raise the carry flag. But since this is not exposed by C, people forgot that it exists.
17:05:43 <hpc> ah
17:06:01 <geekosaur> you still have to test it, to.
17:06:13 <monochrom> One more reason to dispel the myth "C is close to hardware".
17:06:17 <geekosaur> there's no "raise an exception if CF set"
17:06:28 <hpc> it'd be nice to have a checked arithmetic option of some kind in ghc
17:06:41 <geekosaur> (mostlybecause you need to use it to chain operatiosn when working with values whose size exceeds a machine word)
17:06:59 <geekosaur> which is why it's a carry flag, not an overflow signal
17:07:36 <hpc> maybe two different sets of arithmetic instructions would help
17:07:43 <hpc> but god forbid intel "bloat" their "instruction set"
17:09:49 * geekosaur remembers when CPUs had distinct ADD and ADC (add with carry) ops. don't miss them at all...
17:10:21 <monochrom> ADC is necessary for a decent multi-word addition algorithm.
17:10:53 <geekosaur> but there are ways to imlement it that aren't separate ADD opcodes
17:11:54 <sproingie> DWIM DEADBEEF; HCF
17:12:10 <geekosaur> hm, actually I think tat one might remain specifically for the multiword one, because it's conveient. but you still can't then detect an overfow that isn't an intentional carry
17:12:48 <hpc> sproingie: wait until intel adds the XMLFBPST instruction which takes a pointer to a 1MB buffer
17:13:17 <monochrom> Wait, XML processing in hardware?!
17:13:22 <hpc> geekosaur: ah, i found how i got it in my head that Word was a good idea
17:13:39 <geekosaur> why not, we've got kernel web servrs already...
17:13:44 <hpc> geekosaur: rust does checked arithmetic when cargo does testing builds
17:14:15 <sproingie> geekosaur: in a *different* kernel just sitting around on the chip at that
17:14:16 <hpc> monochrom: new-generation cpus have another processor running minix built in
17:14:33 <geekosaur> sproingie, no, I am talking about the linux kernel module
17:14:37 <kadoban> geekosaur: Isn't add-without-carry a different name for xor?
17:14:41 <geekosaur> management chips are a different thing
17:14:55 <monochrom> No kadoban, there is internal carry too.
17:15:18 <hpc> kadoban: take a chain of half-adders, then cut off only the last carry
17:15:19 <geekosaur> kadoban, no because xor also suppresses cary between bits in the current word. add withut carry only suppresses it for the highest bit
17:15:25 <monochrom> On a 4-bit computer 0001+0011 = 0100 you can't get that with xor.
17:15:27 <kadoban> Ahh, I see
17:15:46 <kadoban> Thanks
17:16:28 <geekosaur> and in any case what those opcodes really mean is whether the carry bit is added at the same time or not
17:16:45 <geekosaur> so a multiword additio is ADD x y; ADC x+1 y+1; ...
17:16:59 <geekosaur> thsu propagating the carry into each successive word as needed
17:17:32 <geekosaur> so on a 64-bit CPU this gets you 128-bit or larger] integers
17:45:19 <koz_> Is there a description of what LaTeX Haddock understands. I tried writing \(W = \sum_{i \in 0,1,\ldots,n - 1} w_i\), and it wouldn't render.
17:46:17 <koz_> s/understands./understands?/
17:47:13 <neachdainn> Hey all. What is the correct way to benchmark a function that takes zero arguments? I'm hoping to use Criterion but I'm new to Haskell
17:47:27 <koz_> neachdainn: I assume this function is monadic?
17:48:20 <neachdainn> I'm not 100% sure what you mean by that. This particular function is just the first problem in Project Euler
17:48:29 <mniip> koz_, it's probably using mathjax to render
17:48:32 <koz_> neachdainn: If a Haskell function takes no arguments, it's a constant.
17:49:07 <koz_> My question was 'what effects are you also executing that make it not-a-constant'?
17:49:59 <neachdainn> None. I just want to be able to compare different attempts at solving the problems
17:50:30 <koz_> neachdainn: I would suggest coding your solution to take parameters then, since otherwise, in theory, GHC might just decide to compute it at compile time.
17:50:38 <koz_> (I'm not saying it will, but it would be well within its rights to)
17:50:44 <ACheesyName> is there a way to make this work? https://repl.it/repls/OrnateDizzyCoolingfan basically I want to output a constant through a type class
17:51:16 <koz_> ACheesyName: What exactly are you trying to do?
17:51:19 --- mode: glguy set +v alphy
17:51:42 <alphy> hi
17:51:44 <neachdainn> If I have the function take an argument, but I pattern match with `myFunction _ = ...`, will that be sufficient to prevent computing at compile time?
17:52:00 <ACheesyName> I'm modeling state machines and I want to be able to have an initializer for each state machine in the type class. maybe it can't be done this way in haskell
17:52:26 <koz_> neachdainn: If your function takes no arguments, and has no effects, it's a constant for all intents and purposes, no matter how it's written.
17:52:48 <koz_> Seriously, if you just wanna bench Euler 1, make it take a parameter. It's not that much of an adjustment.
17:53:02 <koz_> And just have Criterion call it with the argument Euler 1 asks for.
17:53:29 <alphy> Can anyone help with pattern matching optimization? I'm a bit new and my patterns look a bit hardcoded :(
17:53:38 <koz_> alphy: Gist please.
17:53:53 <monochrom> Patterns should be hardcoded.
17:54:01 <koz_> ACheesyName: What is an 'initializer'? How are you representing state machines?
17:54:41 <alphy> https://gist.github.com/ef4203/c1b75aadb61beb385f83972415446e51 I'd appreshiate some feedback :)
17:55:10 <neachdainn> koz_: It's not a major change, no. And I'm fine with it if that's the only solution, I am just hoping for a cleaner solution since I'm going to be doing this 100+ times.
17:55:33 <koz_> alphy: Given your Proposition type, you can't really write it much simpler than that I don't think.
17:55:58 <monochrom> There are a couple of lines you can delete, but add "simplify x = x" at the end instead.
17:56:03 <alphy> hmm :/
17:56:20 <monochrom> But the rest are already as good as it gets.
17:56:47 <Solonarv> Agreed. Another nitpick: some parentheses are unnecessary
17:56:57 <koz_> Nothing a little HLint won't notice.
17:56:59 <mniip> alphy, simplify (Or (Var x) (Var y)) is an infinite loop
17:57:09 <Solonarv> A potentially more serious issue: some inputs loop forever
17:57:45 <alphy> Oh, okay, that probably explains my issues
17:58:23 <geekosaur> ACheesyName, you can certainly do that (afaik the only problem you have there is no instance?); see the Bounded class. whether that's the appropriate solution is \another question
17:58:32 <mniip> your best bet is a single-pass optimization
17:58:36 <Solonarv> My recommendation is to split this function in two:
17:58:45 <Solonarv> One function to do a single step
17:59:13 <Solonarv> another function which repeatedly single-steps until nothing changes
17:59:14 <mniip> simplify (And x y) = case simplify x of Const False -> ...; Const True -> ...; x' -> case simplify y of ...
18:00:05 <mniip> so that this is actually a well-founded recursion
18:00:18 <alphy> Oh, yeah thanks
18:01:09 <mniip> note than in the "default" case you don't re-simplify the  And x' y'
18:01:18 <mniip> as you know there's nothing to simplify
18:02:04 <mniip> you could maybe make this look nicer with view patterns and the probably underdocumented feature that is pattern groups to look like
18:02:28 <mniip> simplify (And (simplify -> Const True) (simplify -> y)) = y
18:02:55 <mniip> though then you have to be careful with the order of the equation so as not to disturb pattern groups
18:03:04 <mniip> equations*
18:03:43 <alphy> Again, why was line 17 an endless loop?
18:04:48 <alphy> The other patterns should be stopping the endless loop, (that was my thought)
18:05:01 <mniip> it's not line 17
18:05:04 <mniip> it's the entire function
18:05:27 <Solonarv> Yes, that's not the only input that sends it into an infinite loop
18:05:30 <mniip> I mean, I provided an example input: Or (Var x) (Var y)
18:05:37 <mniip> do you see why it causes an infinite loop?
18:06:35 <alphy> ohhhh now I see
18:06:54 <alphy> Took me a bit 
18:08:45 <mniip> also a few suggestions regarding the "optimization": you might want to reassociate chained ands/ors in a particular way, and also sort such a list in an arbitrary fashion to eliminate duplicate operands
18:09:04 <mniip> you might also want to count the number of negated and non-negated operands in a chain and apply de-morgan
18:15:32 <platz> can you not use Control.Monad.ST.Lazy with Data.Vector.Mutable ?
18:20:07 <infinisil> platz: https://github.com/haskell/vector/issues/147
18:22:02 <platz> hrmm i see
18:22:30 <alphy> Right, before I make the pattern look prettier - how do I actually stop it from looping endlessly ?
18:32:48 --- mode: glguy set +v ACheesyName
18:37:44 <platz> ah it seems i can prefix every vector call with strictToLazyST and it will actually work
18:38:38 <koz_> platz: Doesn't that destroy the benefit of lazy ST though?
18:39:10 <infinisil> Yup..
18:40:42 <platz> well afaict i can use       liftA2 (++) (pure news) (step (Choc e1' e2' size' scores))
18:41:12 <platz> ahh sorry, i mean i can use liftA2 on a simple list and it seems to be lazy
18:41:22 <platz> i don't care about the vector itself
18:42:10 <platz> but i'll admit i'm out of my depth here
18:52:46 <platz> perf doesn't seem that good either
18:54:09 <ephemient> platz: are you trying to do something like this? https://www.reddit.com/comments/a61ojp/-/ebrdrbn
19:15:58 <crysikrend> Hey everyone, I need some help with websockets and streaming data with conduit through a websocket :( 
19:16:13 <crysikrend> I am struggling to find material to learn about it
19:16:47 <platz> ephemient: yeah - i had a strict/preallocated version working, but wanted to see if i could change it to a lazy, generative one
19:17:06 <platz> the lazy one is working but seems much slower https://gist.github.com/jonschoning/110a93066730ad0ba040f0c94b5f481f
19:27:19 --- mode: glguy set +v ACheesyName
20:01:35 <maerwald> When I read a variable from the PrivStore in propellor it seems to append a newline to it
20:24:49 <uptick> using haskell for the first time. just did cabal new-instll tidal ,  but i'm getting this message :::warning: you asked to install executables, but there are no executables in target: tidal. perhaps you want to use --lib to install libraries instead. so i did cabal new-install --lib tidal, and it said resolving dependencies... up to date
20:25:33 <glguy> tidal's a library. If you want to use it , add it as a build-depend to your package
20:25:40 <uptick> yet when i checked inside ~/.cabal/packages/hackage.haskell.org/tidal/1.0.0/  there seems to be only this tidal-1.0.0.tar.gz compression file
20:26:02 <glguy> cabal will automatically build it when you build your package
20:26:46 <uptick> so cabal new-build tidal ?
20:27:13 <glguy> no
20:27:20 <glguy> You can't use tidal on its own, it's a library
20:27:41 <uptick> :P sorry first time with haskell so i'm kind of clueless :P
20:27:56 <glguy> What are you trying to do?
20:28:34 <uptick> just trying to install tidal so i can use it, but i have to get it through haskell so not really familiar with the process
20:28:46 <glguy> If you want to play with tidal in a GHCi session you can run:  cabal v2-repl --build-dep tidal
20:29:17 <glguy> tidal is a library that you'd use when building your own executable
20:29:39 <uptick> what's the difference between v2-repl and new-repl ?
20:29:50 <glguy> v2's the modern name for new
20:30:45 <uptick> when i was installing cabal i did cabal new-update, cabal new-install cabal-install though. does it matter? or should i be using v2-update, v2-install ?
20:31:27 <glguy> It doesn't really matter, but the new- prefix is going away in the next version
20:31:37 <glguy> if your cabal-install version is up-to-date using new- generates a warning
20:31:43 <glguy> if it doesn't you should update your cabal-install executable
20:35:16 <uptick> i see
20:35:26 <uptick> i'll do it over with v2 then
20:35:29 <uptick> thanks so much
20:43:12 <monochrom> They say "the only requirement for the triumph of evil is to have good persons do nothing" and it's true. stack spread a disease and I did not speak venomously against it.
20:44:05 <monochrom> Namely, the distortion of the meaning of "install".  So suddenly "install" means exe-only, libraries excluded or discarded.
20:44:35 <monochrom> And I did not mock it, therefore now cabal is also succumbing to this disease.
20:45:26 <GewJi> you sound like a lunatic, monochrom.
20:45:31 <maerwald> you cannot install tests with cabal 
20:45:52 <sclv> i thought that the plan was to have install handle libraries eventually
20:45:57 <sclv> in conj with env files
20:45:58 <monochrom> I am OK with the stance "lone install requests for libraries is a bad idea in the context of GHC, it contributes to cabal hell".  The correct thing to do is then deprecate and remove "install", the same way "upgrade" was removed too.
20:46:22 <coldpress> isd, koz_: I checked out Maguire's book, and I have a noob question about Exercise 1.4-i: shouldn't the multiplication make a function of type (b->a,c->a) -> Either b c -> a instead?
20:47:04 <monochrom> If you remove "install" and add "install-exes" it clears things up and it hints new users towards asking the right questions.
20:49:32 <jle`> coldpress: what's the exercise?
20:50:40 <coldpress> jle`: pp 19 of http://samples.leanpub.com/thinking-with-types-sample.pdf
20:51:23 <jle`> coldpress: ah, the function you gave is equivalent
20:51:39 <jle`> `(a,b) -> c` is the same as `a -> (b -> c)`
20:51:54 <jle`> in haskell we usually write it as `a -> b -> c`, as a stylistic preference
20:52:13 <jle`> in Haskell we usually write functions `(a, b) -> c` as `a -> b -> c`, just as a cultural/stylistic thing
20:52:25 <jle`> the process is known as "currying"
20:53:36 <jle`> so the question does ask you to write a `(b -> a, c -> a) -> Either b c -> a`, but only it asks for it in (equivalent) form of `(b -> a) -> (c -> a) -> Either b c -> a`
20:53:48 <jle`> just to follow the stylistic norms in haskell
20:53:49 <monochrom> Since you're reading Thinking with Types, I also get to remind you of the cardinality analogy: C^(A*B) = (C^B)^A
20:56:54 <coldpress> jle`: doh, currying! thanks!
20:57:28 <coldpress> monochrom: i believe that's exercise 1.4-iii
20:57:50 <monochrom> Ah
20:59:00 <jle`> coldpress: no problem! and yeah, often we internalize these rules/idioms so much that we don't even notice we are doing them :)
21:12:05 * hackage persistent-sqlite 2.9.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.9.1 (psibi)
21:39:41 <koz_> coldpress: jle` said it much better than I ever could.
21:39:49 <koz_> (as usual)
21:40:06 <iqubic> Hey folks. I'm wondering if anyone has a function of type: (a -> b) -> (a, a) -> (b, b).
21:40:17 <koz_> join bimap
21:40:21 <koz_> :t join bimap
21:40:22 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
21:40:40 <iqubic> I have a 2-tuple, where fst and snd are the same data type, and I want to map a function over both of them..
21:40:52 <iqubic> Do I need to import anything to get that to work?
21:40:54 <koz_> iqubic: This is something more general than what you requested, since (a,a) is a Bifunctor.
21:41:00 <koz_> iqubic: Data.Bifunctor.
21:41:06 <koz_> (and Control.Monad for join)
21:41:50 <iqubic> Is there a way for me to apply one function to the left, and a different function to the right, but at the same time?
21:42:14 <koz_> iqubic: bimap
21:42:16 <koz_> :t bimap
21:42:17 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
21:42:20 <iqubic> I see.
21:42:24 <iqubic> Thanks.
21:42:59 <iqubic> How easy is it to create a bimap instance for something?
21:43:10 <koz_> Bifunctor instance.
21:43:18 <koz_> You need to provide a bimap implementation.
21:43:23 <koz_> With the law that bimap id id == id
21:43:27 <iqubic> I know.
21:43:45 <iqubic> Can I just tell haskell that I want to derive bimap?
21:43:54 <koz_> iqubic: No, it's not auto-derivable.
21:44:03 <iqubic> Darn. Why not?
21:44:18 <lyxia> because nobody implemented it
21:44:19 <koz_> I dunno if lyxia's all-singing, all-dancing, all-generic library that lets you autoderive everything from Generic supports Bifunctor.
21:44:26 <koz_> Ah, speak of the devil.
21:44:29 <lyxia> o/
21:44:46 <koz_> lyxia: Does your all-singing, all-dancing, all-generic library that lets you autoderive everything from Generic support Bifunctor?
21:44:51 <lyxia> Soon™
21:44:56 <iqubic> Ah.
21:45:12 <koz_> iqubic: The Haskell report requires only a specific set of typeclasses be autoderivable.
21:45:24 <koz_> They are, _I think_, Show, Read, Eq, Ord, Bounded, Enum and Ix?
21:45:35 <iqubic> And that doesn't include functor, does it?
21:45:36 <koz_> GHC supports Functor, Foldable, Traversable and Generic on top of those.
21:45:44 <koz_> But that's GHC-specific via extensions.
21:45:52 <iqubic> I see. Cool.
21:46:09 <koz_> Additionally, if your type is a newtype, you can auto-derive stuff from the 'underlying' type using GND.
21:46:18 <koz_> And as of 8.6, there's also DerivingVia.
21:46:24 <koz_> (which is like GND but on steroids)
21:46:52 <koz_> Lastly, there's lyxia's all-singing, all-dancing, all-generic library, which lets you derive everything but the kitchen sink (and Bifunctor) using Generic and some magic.
21:47:39 <iqubic> Weird...
21:47:39 <lyxia> all the magic is Generic :D
21:47:51 <iqubic> I'm getting weird type errors.
21:48:00 <koz_> iqubic: Gist your code and type errors.
21:48:05 <koz_> And we'll see if we can make them less weird.
21:48:50 <koz_> lyxia: What's your all-singing, all-dancing, all-generic library called again?
21:49:01 <lyxia> generic-data
21:49:04 <koz_> Thanks.
21:49:50 <iqubic> http://dpaste.com/3XDGVM6
21:50:17 <koz_> iqubic: Bifunctor expects something of kind Type -> Type.
21:50:19 <iqubic> I just cut out the unimportant parts.
21:50:25 <koz_> 'AD a' is of kind Type.
21:50:30 <iqubic> Why is that?
21:50:32 <koz_> What you want is 'instance Bifunctor AD where'
21:50:48 <koz_> Same reason as Functor, Foldable, Traversable, Monad, Applicative, and their Bi-equivalents.
21:51:06 <iqubic> Well, that still doesn't work.
21:51:16 <koz_> OK, so paste what you're having issues with.
21:51:36 <koz_> (sorry, Type -> Type -> Type, my silly)
21:52:03 <iqubic> New issue: http://dpaste.com/3EF8PKE
21:52:13 <koz_> Yep, that was me being silly.
21:52:29 <iqubic> So what is the issue in my code?
21:52:34 <koz_> Bifunctor, like Bi-everything, requires a kind of Type -> Type -> Type.
21:52:55 <koz_> So you'd need something analogous to 'data AD a b = AD a b' for a valid Bifunctor instance to be possible.
21:53:00 <iqubic> Am I getting these errors because I am forcing the two parts of AD to be the same?
21:53:03 <koz_> Yes.
21:53:10 <koz_> More precisely, AD has the wrong kind.
21:53:18 <koz_> AD, as you have it, has kind Type -> Type.
21:53:33 <koz_> That is, if I tell you what 'a' is, you can magic me up an 'a-specific' AD.
21:54:12 * koz_ is unhappy there's no Bimonad.
21:54:21 <koz_> (although bibind is a bit awkward)
21:54:44 <koz_> (bibind == >>==== ?) O o koz_
21:55:25 <iqubic> Alright, you know what... This is two much work to do. I'm having to change half a dozen functions to account AD now having two type parameters.
21:55:26 <koz_> No wait that'd be >>>>==.
21:55:48 <iqubic> I can do without a bifunctor instance for this.
21:55:50 <koz_> iqubic: Do you need to just write a couple of functions fixed to (a,a)?
21:56:06 <koz_> If so, you can just newtype over that, then unwrap and lean on the underlying Bifunctor of (,).
21:56:17 <koz_> (if you use Data.Coerce.coerce, you don't even pay any runtime cost)
21:57:07 <iqubic> koz_: I know what I'm doing.
21:57:11 <iqubic> I'll be fine.
21:57:21 <koz_> iqubic: I didn't mean to imply you didn't.
21:57:51 <iqubic> You're fine. Thanks for the help though.
22:00:25 <iqubic> WTF is this error???
22:00:47 <iqubic> Wait... I fixed it.
22:01:22 <iqubic> I need to add a Num type constraint to the Num instance. (AD a) only has a Num instance if a has Num instance.
22:03:40 <iqubic> What does the fromInteger function do?
22:04:47 <MarcelineVQ> it takes an Integer and allows it to be a Num a => a
22:05:08 <iqubic> Oh. I see.
22:06:37 <ski> if you write a numeric integer literal, like `37', that implicitly calls `fromInteger' on an `Integer' `37'
22:07:18 <iqubic> I see. I get how that works.
22:25:40 <cocreature> bollu: just the regular GHC profiling stuff
22:26:04 <cocreature> bollu: recompiling is annoying but you can cache it across projects so it isn’t that big of a deal in practice ime
22:37:35 * hackage KMP 0.2.0.0 - Knuth–Morris–Pratt string searching algorithm  http://hackage.haskell.org/package/KMP-0.2.0.0 (CindyLinz)
22:42:05 * hackage mismi-p 0.0.1 - A commmon prelude for the mismi project.  http://hackage.haskell.org/package/mismi-p-0.0.1 (nhibberd)
22:45:16 * hackage mismi-kernel 0.0.1 - AWS Library  http://hackage.haskell.org/package/mismi-kernel-0.0.1 (nhibberd)
22:46:21 * hackage mismi-core 0.0.1 - AWS Library  http://hackage.haskell.org/package/mismi-core-0.0.1 (nhibberd)
23:30:34 * hackage mismi-s3-core 0.0.1 - AWS Library  http://hackage.haskell.org/package/mismi-s3-core-0.0.1 (nhibberd)
23:33:48 <dminuoso> Are there any restrictions on hackage when forking a project?
23:34:53 <maerwald> Prefer unique module names
23:35:17 <bahamas> does anyone have a haskell setup for neovim that I could just clone and start using?
23:36:01 <dminuoso> Well that's hard not to prefer no? I thought Hackagae enforced unique modules names.
23:36:44 <maerwald> dminuoso: does it? You mean it unpacks your sdist, examines your module names and compares it with entire hackage?
23:36:47 <maerwald> That sounds odd
23:37:05 <maerwald> note: package name != module name
23:37:24 <maerwald> and in fact, there are packages that export the same
23:37:32 <maerwald> e.g. unix vs unix-bytestring afair
23:37:34 <dminuoso> Oh mmm.
23:38:49 <bahamas> this is why I prefer the PackageImports extension. it makes it easier to see where the module is coming from
23:56:16 <pdxleif> @hoogle Applicative f => (s -> f (Maybe (a, s))) -> s -> f [a]
23:56:17 <lambdabot> Agda.Utils.Tuple mapFstM :: (Applicative m) => (a -> m c) -> (a, b) -> m (c, b)
23:56:17 <lambdabot> Agda.Utils.Tuple mapSndM :: (Applicative m) => (b -> m d) -> (a, b) -> m (a, d)
23:56:17 <lambdabot> Data.GI.Base.Utils mapFirstA :: Applicative f => (a -> f c) -> [(a, b)] -> f [(c, b)]
23:56:29 <pdxleif> @hoogle Monad f => (s -> f (Maybe (a, s))) -> s -> f [a]
23:56:30 <lambdabot> Control.Monad.Loops unfoldrM :: Monad m => (a -> m (Maybe (b, a))) -> a -> m [b]
23:56:30 <lambdabot> Language.C.Analysis.TravMonad mapSndM :: (Monad m) => (b -> m c) -> (a, b) -> m (a, c)
23:56:30 <lambdabot> Control.Monad.Extra unfoldM :: Monad m => (s -> m (Maybe (a, s))) -> s -> m [a]
