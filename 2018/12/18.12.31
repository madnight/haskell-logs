00:05:09 <amalloy> what are the syntax rules for how to use a unary infix data constructor? i was looking at a stackoverflow question where someone had defined: data Ex a = P a | (:+) (Ex a)     and it was hard to figure out how to pattern-match on it infix-style
00:05:52 <c_wraith> that's a weird one.  It'd require whatever extension lets you create unary operators.
00:06:13 <iqubi4> How do you use that as a constructor?
00:06:23 <c_wraith> You can match on it just like that foo ((:+) bar) ...
00:07:08 <amalloy> yeah, but all those parens suck - why even define it like this if that's the only way to use it? I thought something like (bar :+) would work but it didn't seem to
00:07:14 <c_wraith> and you might be able to use the unary section syntax...  foo (bar :+) ...    not sure about that one.  In general, use infix constructors for *binary* constructors.
00:09:38 <MarcelineVQ> huh, neat, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#numeric-underscores
00:10:27 --- mode: glguy set +v newuse
00:11:52 <MarcelineVQ> amalloy: that would with PostfixOperators
00:12:26 <MarcelineVQ> in terms at least, not in patterns :X
00:13:58 <newuse> sum [] = 0
00:14:02 <newuse> sum (n:ns) = n + sum ns
00:14:05 <newuse> sum [1,2,3]
00:14:07 <newuse> returns
00:14:14 <newuse> Non-exhaustive patterns in function sum
00:14:20 <newuse> why?
00:14:25 <c_wraith> newuse: you're entering them in ghci
00:14:30 <newuse> yep
00:14:33 <c_wraith> that's why
00:14:40 <newuse> how so?
00:14:49 <c_wraith> you define sum, then you define a *totally different* thing named sum that replaces the first
00:15:00 <c_wraith> each line is a complete definition
00:15:28 <newuse> but you're saying that i I put that in a file, inside presumably some main function
00:15:31 <newuse> that would work?
00:15:48 <c_wraith> or you could put both parts on one line
00:16:13 <newuse> separated by a semi-colon or what's the syntax here?
00:16:19 <larryba> exactly what you typed
00:16:29 <dmj`> MarcelineVQ: it's processing instructions :)
00:16:36 <c_wraith> yes, semicolon is the separator
00:16:51 <c_wraith> Or you can put the definition in a file.  No main is needed.
00:17:12 <newuse> oh swell
00:17:13 <MarcelineVQ> dmj`: ?
00:17:15 <newuse> that worked in ghci
00:17:32 <newuse> thank you. I'll try it inside a file...
00:17:59 <newuse> Context : this is from Graham Hutton's book.
00:18:34 <newuse> he should kind of make that stuff explicit considering his audience
00:20:06 <MarcelineVQ> He might be trusting the audience to read the ghci manual :X https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#using-ghci Dunno though, haven't read the book
00:22:23 <newuse> his aim is to teach "everything from first principles" with no previous knowledge required, except being 16 or older with an aptitude for scientific reasoning
00:23:20 <newuse> it might have been useful in that context to spend a few lines on the inner workings of this particular languages' repl mechanics
00:23:52 <c_wraith> You have a good point.
00:24:05 <c_wraith> It's something that's easy to miss if you're too close, I suppose.
00:29:28 <newuse> in any case thanks a lot for helping me out!
00:51:39 --- mode: glguy set +v PatrickRobotham
00:56:36 <lyxia> AfC: Thanks!
01:10:38 <AfC> larryba: if you're going to use throw/catch you would be well advised to use the *safe-exceptions* package, or at the very least make sure you're aware of the caveats described therein. There are some gotchas.
01:12:35 <larryba> AfC any other gotchas besides that one (accidentally catching async exceptions)?
01:15:02 <larryba> and what do you mean if I'm going to use it.. isn't it a requirement to use it? even if I don't throw, other actions out of my control do
01:27:15 <AfC> larryba: indeed. You said MonadThrow, though, so that implies catching later, leading to caveat fuckup of the RTS not providing a aync/async distinction. Easy to catch system exceptions by accident.
01:28:40 <larryba> yeah. I'm surprised this wasn't solved in the types, have separate sync/async exceptions
01:28:54 <larryba> but maybe there's a reason for that
01:39:21 <phadej> there have been some changes to the Control.Exception api regarding async exceptions not so long ago
01:41:49 <dmj`> phadej: wasn't catch was modified to handle async exceptions better?
01:42:01 <dmj`> wasn't catch modified*
01:42:44 <phadej> not sure, it looks like that AsyncException stuff were added in base-4.7 and safe-exceptions takes use of that
01:43:25 <phadej> i.e. safe-exceptions catch catches everything but AsyncExceptions
01:45:00 <phadej> yet IIRC you can still "throw anything" at threads
01:45:15 <phadej> but you really shouldn't except the four constructors of AsyncException
01:46:08 <phadej> a bit like NonFatal stuff in Scala, there are exceptions you shouldn't catch
01:46:24 <phadej> (and throw yourself)
01:47:09 <phadej> but I might be very wrong
01:47:34 <phadej> I'd read the proper chapters of "parallel and concurrent programming in haskell"
02:12:34 --- mode: glguy set +v newuse
02:14:46 <newuse> Hi. I'm still battling with my little function from earlier on. I was told to paste it 'as is' inside a file and compile it. except that
02:14:47 <newuse> sum2 [] = 0
02:14:51 <newuse> sum2 (n:ns) = n + sum2 ns
02:14:56 <newuse> sum2 [1,2,3]
02:15:14 <newuse> then returns "naked expression at top level"
02:15:20 <newuse> I then replaced the last line with
02:15:27 <newuse> main = print(sum2 [1,2,3])
02:15:36 <newuse> Is this the correct way to do it?
02:17:08 <amalloy> newuse: sure, that's reasonable. alternatively you could put the definition of sum2 in a source file, but not the "sum2 [1,2,3]" part. then you could load the file from ghci and type sum2 [1,2,3] into ghci
02:18:26 <newuse> if i save just the first 2 lines inside .hs file and compile i get
02:18:28 <newuse> Variable not in scope: main :: IO a0     • Perhaps you meant ‘min’ (imported from Prelude)
02:18:43 <newuse> as error from ghc
02:18:49 <larryba> newuse you need main when you compile (with ghc)
02:18:55 <larryba> you don't need it when you load the file into ghci
02:19:21 <larryba> are you typing `main' in ghci?
02:19:47 <newuse> no
02:49:13 <tito_04> Why does the exceptions package reimplement EitherT/ExceptT as CatchT?
02:50:09 <tito_04> The MonadThrow/Catch instance for ExceptT throws/catches in the base monad (has MonadThrow/Catch m constraint where m is the base monad)
02:50:42 <tito_04> But the CatchT instance uses Left/Right to throw exceptions
02:51:13 <phadej> that's the reason = different instances.
02:51:35 <tito_04> But why did he reimplement CatchT and not just use ExceptT?
02:51:52 <tito_04> ExceptT is made for "pure" exceptions
02:52:01 <tito_04> Just like CatchT
02:52:16 <lyxia> is it?
02:52:24 <phadej> the reason might be historical
02:53:20 <phadej> i'm quite sure CatchT predates ExceptT
02:53:38 <lyxia> oh ExceptT is "pure" exceptions but nowhere does it say CatchT should be as well.
02:54:08 <tito_04> CatchT is implemented with Either 
02:54:25 <tito_04> So it works like ExceptT
02:55:25 <tito_04> The only difference is that ExceptT allows you to choose the exception type, CatchT uses SomeException
02:55:46 <lyxia> well you could also say the current implementation of CatchT (ExceptT m) works like the other transformers
02:56:16 <lyxia> uh MonadCatch (ExceptT m)
03:05:48 <larryba> how can I fetch only successful reads? https://bpaste.net/show/dccb5c473f8d
03:06:49 <larryba> with readM. I know I can just use catMaybes with readMaybe
03:07:59 <Solonarv> you want 'traverse'
03:08:15 <Solonarv> i.e. 'traverse readM $ words ...'
03:08:31 <Solonarv> oh wait, I misread
03:09:07 <[exa]> larryba: you can catch the exceptions and replace them by Nothing and use catMaybes after that
03:09:51 <[exa]> larryba: AFAIK `fromException` does that
03:10:07 <[exa]> oh no sorry
03:17:13 <larryba> I can access them individually. I just don't know how to concat non-failed ones. 
03:18:15 <larryba> join $ (return . (!!1)) $ map readM $ words "10 20 foo" :: Either SomeException Int     =>    Right 20
03:20:32 <[exa]> what about just fmapping concat there?
03:20:49 <[exa]> instead of (!!1)
03:20:57 <larryba> which is just (!!1) <$> map readM $ words "10 20 foo" :: Either SomeException Int..  I am blindly following the types, and my head is spinning
03:22:05 <[exa]> there's a function in Data.Either that only selects Rights
03:22:08 <larryba> awesome
03:22:22 <larryba> concat <$> map readM $ words "10 20 foo" => [10,20]
03:23:56 <larryba> I don't get how that works, though
03:24:21 <[exa]> it seems Either is foldable in the exact way you need it
03:24:39 <[exa]> (or the exception monad it's using)
03:24:58 <[exa]> you might want to add a type hole somewhere just to see what type gets selected, like (concat :: _)
03:28:23 <lavalike> where's readM from?
03:28:25 <larryba> I'm not sure what to make out of it. http://dpaste.com/1BFVQT8
03:28:35 <larryba> lavalike, it is defined on link above
03:29:53 <larryba> is it using [] instance for MonadThrow?
03:34:20 <larryba> concat <$> map readM $ words "ha 10 20 foo"  returns [].   concat <$> map readM $ words "ha 10 20 foo" :: [Int]  returns [10,20]
03:36:26 <lavalike> :t catMaybes
03:36:27 <lambdabot> [Maybe a] -> [a]
03:36:40 <larryba> I have no clue how I'd use that
03:36:44 <larryba> with this
03:37:03 <lavalike> s/concat <$>/catMaybes $/
03:38:35 <larryba> this one is interesting. map readM $ words "ha 10 20 foo"  :: [[Int]]  => [[],[10],[20],[]]
03:38:43 <larryba> so it was using [] instance of MonadThrow
03:39:44 <kuribas> :t readM
03:39:45 <lambdabot> error:
03:39:45 <lambdabot>     • Variable not in scope: readM
03:39:45 <lambdabot>     • Perhaps you meant one of these:
03:40:06 <larryba> kuribas, definition is here: https://bpaste.net/show/dccb5c473f8d
03:40:57 <kuribas> larryba: shouldn't you use readEither then?
03:42:03 <kuribas> it gives the actual error as a string
03:42:06 <larryba> kuribas, I picked up that definition from here: https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell
03:42:58 <larryba> it is interesting, because you can use it directly in Maybe a, Either SomeExcept a, IO a, or [a] context
03:43:31 <kuribas> larryba: if you replace readMaybe with readEither, you get a more meaningful error message.
03:44:00 <larryba> kuribas, ah, I see
03:44:54 <kuribas> I don't know why they didn't use it...
03:44:59 <kuribas> Maybe backwards compatibility.
03:45:33 <kuribas> hmm no, readMaybe is there the same time as readEither
03:46:28 <larryba> Typeable made readM more complex to follow, that is why I removed it
03:48:40 <larryba> eh, error message isn't any better :). *** Exception: Prelude.read: no parse
03:49:17 <bor0> hi. I have this class (Eq a, Ord b) => CalEvent a b, with `start` and `end` both being of type `a -> b`. now when I try to write a function `eventsIntersect :: (CalEvent a b) => a -> a -> Bool` haskell says that it cannot deduce `(CalEvent a b0)`
03:50:34 <c_wraith> bor0: well, you need to tell it what type b is, or it can't pick an instance
03:50:36 <bor0> is there anything I can do to fix this type error, or is there a flaw in my class/function typedef?
03:51:01 <bor0> c_wraith, within `eventsIntersect` I call `start (x :: a) :: b`, and I only use `<=` within it
03:51:07 <bor0> can it not deduce that it already is `Old`?
03:51:11 <bor0> `Ord`*
03:51:16 <c_wraith> That's not a type, though
03:51:22 <c_wraith> it needs a specific type.
03:51:33 <c_wraith> > read "11"
03:51:35 <lambdabot>  *Exception: Prelude.read: no parse
03:51:43 <bor0> I see
03:51:46 <c_wraith> > read "11" :: Int
03:51:48 <lambdabot>  11
03:51:53 <bor0> how can I help the compiler type-infer a typeclass?
03:52:28 <c_wraith> there are a number of ways.  first and foremost, though...  Is that class definition useful?
03:52:41 <bor0> I don't know :D I wanted to make it more abstract but maybe that was my error
03:53:02 <bor0> it worked fine when I had `class (Eq a, Ord a) => CalEvent a` with start/end both of type `a -> UTCTime`
03:53:25 <c_wraith> I mean, you could make it work, with sufficient use of advanced features.  But I question whether it's really even what you want.
03:53:26 <bor0> but why tie it to UTCTime
03:53:57 <bor0> oh, this is just a hobby. not a homework nor something that will go in production. I just browse the compiler's features I guess
03:54:21 <bor0> so I think I'm interested in `sufficient use of advanced features` :D
03:54:40 <c_wraith> You could make it work with ScopedTypeVariables, AllowAmbiguousTypes, and TypeApplications
03:55:13 <bor0> (inserting those randomly, will figure out what they mean later once it compiles)
03:55:54 <c_wraith> change the type of eventsIntersect to forall b a. (CalEvent a b) => a -> a -> Bool
03:56:22 <bor0> I know forall because I did some Idris. can you explain it in this context?
03:56:50 <c_wraith> It's the ScopedTypeVariables extension - it's bringing the types b and a into scope for the function body
03:57:08 <c_wraith> They're in that order for...  reasons that will become clear later
03:57:49 <bor0> wow, ScopedTypeVariables is powerful. dependent types!
03:58:06 <c_wraith> hardly.  Just explicit type binders. :)
03:58:20 <bor0> in the function body?
03:58:28 <c_wraith> They still only exist as types
03:59:18 <c_wraith> It's just enough to let your use of (start x :: b) compile because it can link the type b in the ascription to the type b in the signature
03:59:52 <bor0> so back to my class def, is it usual to abstract it to that point or using start :: a -> UTCTime is ok? or maybe to make things easier I could write a new class on top of `CalEvent a b`?
03:59:57 <bor0> what's the usual approach?
04:00:12 <c_wraith> Honestly, it's not something I'd use a class for at all
04:00:23 <c_wraith> a class seems too polymorphic
04:00:47 <c_wraith> I want a big collection of these things, which is difficult to do when their types are unconstrained
04:01:10 <bor0> so I have data Booking = Booking { bookingId :: Int, , bookingStart :: UTCTime, , bookingEnd :: UTCTime }. what if there's another data structure that has more fields and still want to use my intersection function
04:01:29 <bor0> (obviously there's `instance CalEvent Booking`)
04:03:11 <c_wraith> There are a few design choices, depending on how much run-time flexibility you want to support.
04:04:07 <bor0> what if my intention was to release this as a library on package? it's just a few functions for calculating collision groups for intersecting events
04:04:17 <bor0> s/package/hackage/. Xchat :(
04:04:18 <c_wraith> One is to just use a parameterized event type.  data Event a = Event { eventId :: Int, eventStart :: UTCTime, eventEnd :: UTCTime, data :: a}
04:05:04 <c_wraith> well, except that field can't be named data.
04:05:07 <c_wraith> eventData, then
04:07:08 <c_wraith> But it's possible you might need to go more clojure-like in your design, if you really expect arbitrary data to get stuffed into them.  That can happen, if you're storing data from external sources for instance.
04:08:19 <c_wraith> In which case maybe you want something more like data Event = Event { eventId :: Int, eventStart :: UTCTime, eventEnd :: UTCTime, eventData :: Value}
04:08:38 <c_wraith> where Value is the type from aeson.  Just store any arbitrary json blob in there.
04:09:00 <bor0> let's say I have this: https://gist.github.com/bor0/ffd4136e3cee94de17ebfc6177d7aa3f and I want to release calevent.hs on hackage. the only thing that bothers me is `UTCTime` being tied into `CalEvent`
04:09:44 <bor0> maybe somebody wants to use my `eventsIntersect` but without `UTCTime`
04:11:27 <hpc> what other type would they use?
04:11:30 <hpc> any Ord?
04:11:40 <bor0> Int maybe? 0 is 00:00, 60 is 01:00, etc
04:11:45 <bor0> yes, any Ord
04:12:24 <hpc> maybe use a type family
04:14:34 <bor0> from what I googled, this would mean inserting `data` into my class so that it can infer the types I guess?
04:14:47 <hpc> i personally don't see anything wrong with the use of UTCTime here
04:15:29 <Lears> Why not just write the intersection logic in a function which accepts intervals as `(a, a)` values (where we have `Ord a`), and let transforming an event into that form be the library users business?
04:15:33 <hpc> it seems like the right type here to express things that occur at specific unambiguous points in time
04:15:39 <bor0> this is where I got the idea to further generalize instead of `UTCTime` https://github.com/taterbase/calendar-puzzle/blob/master/app/js/main.js#L14-L20
04:16:54 <bor0> it is ambiguous but maybe they want to use the library only for a particular day, instead of date :))
04:17:19 <bor0> (there is no they and I guess even if I had released it it will have 0 downloads.) I'm just curious how it's usually achieved
04:18:19 <bor0> I guess sticking to UTCTime makes sense. it's just that we have a lot of other ways to represent time
04:22:29 <hpc> we have different types for different types of time
04:22:44 <hpc> calendar events happen at an objective time no matter where you are, so time zones don't really figure in
04:22:53 <hpc> that eliminates most of the time type ecosystem
04:23:58 <hpc> etc etc
04:24:59 <bor0> thanks for the discussion. this was fun
04:25:43 <bor0> I'm happy there's an abstraction barrier in Haskell so that we don't end up over-abstracting (or under-abstracting)
04:26:31 <bor0> for everything else, there's always `Do Repeat Yourself`
04:27:27 <int-e> bor0: you can say that again
04:27:40 <bor0> :D
04:27:41 <hpc> lol
04:31:19 <ph88> lyxia, i used currying for that piece of code
04:34:34 <lyxia> Curry tastes good.
04:40:28 <ph88> :D
04:50:38 <kuribas> what's an abstraction barrier?
04:50:49 <kuribas> IMO haskell easily leads itself to over abstracting
04:53:28 <hpc> an abstraction barrier is some set of concepts about a thing
04:53:38 <hpc> such that those are the only parts of that thing that you care about
04:54:05 <hpc> and importantly, that set of concepts that matter is way smaller than what it takes to think about its full implementation
04:54:21 <kuribas> oh right
04:55:27 <kuribas> that's what I like about haskell.  In lisp, you have a lot of flexibility, but there are no limitations, so the flexibility can also make it more complex.
04:55:48 <larryba> if anyone still cares, , <$> was using function instance, ie, (.) operator :).  
04:55:57 <larryba> concat $ map readM (words "10 20 30 foo") :: [Int]   =>   [10, 20, 30]
04:56:35 <kuribas> the reader monad (function version) is only good for obfuscation.
04:56:44 <hpc> when i had to use it for classes, lisp's flexibility did me negative favors
04:57:02 <hpc> all i wanted to do was write functional code like lisp wants you to
04:57:16 <hpc> and i couldn't use first-class functions because sometimes they were macros
04:57:37 <kuribas> hpc: use lambda?
04:57:38 <hpc> or i couldn't easily transform a function into one parameterized by another function, because the syntax for a function call vs a function dereference are pretty different
04:57:51 <kuribas> ah a LISP-2
04:57:54 <hpc> eta expansion is for scrubs :P
04:58:26 <kuribas> dynamic typing makes it hard to write code with many HOFs.
04:58:29 <hpc> yeah it was clisp
04:59:00 <hpc> i ended up managing pretty well after finding a style that worked
04:59:15 <hpc> i had the only neural network implementation in the class that could train a dataset faster than "overnight"
04:59:23 <kuribas> cool
04:59:47 <hpc> it really made me appreciate haskell's types in particular though :D
05:00:01 <hpc> sometimes the type is a function's entire abstraction barrier
05:00:10 <kuribas> I recently went to a presentation of a guy that created a neural network interface in haskell.
05:00:20 <hpc> once you know the type, you need literally no information about the implementation other than "it's not bottom"
05:00:47 <kuribas> sadly my coworkers don't see any advantage in types.
05:02:03 <hpc> my coworkers do, even if they don't use languages with types at all :/
05:02:15 <kuribas> in lisp it is hard to make highly abstract code that is performant as well.
05:02:49 <kuribas> you choose, or make a mix.
05:03:30 <kuribas> or in general create a language using symbols, then interprete that language.
05:04:02 <kuribas> But the problem I see there is that the language can get unwieldy without constraints, and the interpreter is low level and often complicated.
05:04:41 <kuribas> My coworkers on the other hand would claim that the haskell approach is *too restrictive*.
05:05:15 <kuribas> hpc: what language do you use at work?
05:05:32 <hpc> lately bash
05:05:41 <hpc> overall puppet's probably my most-used work language
05:05:49 <kuribas> cool.  I am using bash as well.
05:06:03 <kuribas> bash is ok if you restrict yourself.
05:06:39 <hpc> puppet has typescript-like types (unions instead of sums, and a lot of weird type equivalencies), and it's pure :D
05:06:52 <kuribas> though it is always a hack, it normally doesn't matter for the job you use it for.
05:06:54 <kuribas> ah
05:07:04 <hpc> it has an evaluation phase and an execution phase, which is important because they happen on different boxes
05:07:05 * kuribas doesn't know puppet
05:07:08 <lquenti> python bc its the companys language. Although I have to say that I prefer to use type hints and stuff, just because restrictive but verbose coding is important.
05:07:16 <hpc> definitely learn it sometime, it's great
05:08:10 <kuribas> lquenti: you can write good python code.  The problem is many python developpers don't really know how to structure well.
05:08:26 <kuribas> And the "python best practices" are insane.
05:09:27 <lquenti> kuribas: EXACTLY. I mean, they are trying their best w/ for example list comprehensions but I guess part of the problem is that Python does not force you to write even a bit elegant code
05:10:23 <hpc> it practically discourages it
05:10:28 <hpc> even imports have side effects
05:11:15 <lquenti> hpc since you wrote you work w/ bash and bc of your name: If you have sth in your hpc area, what do you use if sth has to scale? Do you really write bashscripts w/ 200+ Lines?
05:11:40 <hpc> oh, hpc doesn't stand for what you think it stands for
05:12:17 <hpc> but if pressed, i would probably put the thing on one physical machine and start from there
05:13:10 <lquenti> Oh sorry, I thought just because of bash it would mean high performance computing :D
05:13:19 <hpc> heh
05:13:31 <hpc> i usually get haskell program coverage
05:14:27 <lquenti> Im still pretty nooby myself. TIL: hpc exists ^^
05:15:32 <__monty__> I wouldn't expect bash to be used for HPC much tbh. Managing the cluster sure but the actual computations are usually written in C or fortran, no? Maybe python sometimes...
05:15:53 <kuribas> lquenti: no, bash is for gluing stuff together.
05:16:36 <lquenti> __monty__ Yeah but you have to schedule the tasks as well, which at least for me seems like bash would be a decent fit
05:16:49 <hpc> sometimes getting the results out of your big computation is a combination of grep and sed
05:17:01 <hpc> and that's better than writing a bunch more data manipulation
05:17:20 <ideas_guy> :t error
05:17:22 <lambdabot> [Char] -> a
05:17:30 <ideas_guy> :t undefined
05:17:31 <lambdabot> a
05:19:30 <kuribas> lquenti: my experience was that if you question the python developpers believes, they get hostile.
05:19:50 <kuribas> lquenti: like avoiding exceptions.  It's the only language that I know that encourages it.
05:20:12 <hpc> oh god, have i got a story about python exceptions
05:20:49 <hpc> the short version is that in gnu mailman, if you use their "api" to set someone to digest mode, you use list.set("subscriber@example.com", digest_flag, true)
05:21:01 <hpc> and it throws SubscriberAlreadyDigest
05:21:14 <hpc> there's like 20 different flags you can use for .set()
05:21:17 <[exa]> Error: Subscribers have been digested
05:21:25 <hpc> so using it properly involves catching something like 30 different exceptions
05:21:42 <hpc> and almost all of them could have just been noops
05:22:01 <hpc> [exa]: heh
05:22:06 <[exa]> hpc: let's call it duck-exceptioning
05:24:08 <lquenti> hiribas Well for that, at least its not PEP-conform to just except everything. But its still awful 
05:24:39 <lquenti> hpc THE FUCK
05:24:51 <kuribas> lquenti: generators use exceptions as well
05:25:36 <Rembane> kuribas: They either give you a new value or throw a StopIteration?
05:26:23 <kuribas> Rembane: right
05:26:57 <kuribas> lquenti: I am pretty sure even experienced python developpers would cringe at my previous place's code
05:27:24 <kuribas> lquenti: and your supposed to catch keyerror as well
05:27:29 <lquenti> kuribas glad Im not in any way passible! But why?
05:27:42 <lquenti> so why was your code so cringeworthy?
05:28:19 <kuribas> lquenti: catching AttributeError, TypeError, etc, just to match on different objects.
05:28:53 <kuribas> instead of isinstance
05:29:52 <kuribas> using strings for enums
05:30:31 <lquenti> uh that one I think most people just know when coded in a low level language b4
05:31:22 <kuribas> using classes where functions worked as well
05:31:34 <kuribas> (simply wrapping functions in a class, because "it is OO")
05:31:56 <lquenti> haha OOP just use a FunctionFactory!!!
05:32:07 <lquenti> design patterns are so awful
05:32:57 <kuribas> just one big messy state, created around the ORM.
05:33:03 <[exa]> "you can use lambdas to construct unnamed factories!!!1"
05:33:47 <kuribas> with lots of tiny tables, for what could easily have been an xml or json structure.
05:34:21 <kuribas> which can be maniputed with XPath... Not as great as lenses, but still much better
05:34:26 <lquenti> But Google uses my hip xyz Stack too!!!1
05:35:06 <kuribas> lquenti: they didn't use microservices, fortunately :)
05:35:13 <kuribas> I couldn't imagine what a mess that would be
05:37:27 <lquenti> Im still curious about one thing about you all: What is your profession if its not too private? I always think of haskell programmer as either nerdy students or some category theory phds
05:37:41 <kuribas> lquenti: lisp programmer :)
05:38:06 <kuribas> my education is music actually
05:38:22 <kuribas> lquenti: I am a nerdy musician :)
05:38:59 <kuribas> I am not sure CT PHDs like haskell...
05:39:02 <lquenti> what an interesting story like following the passion educationwise but still ending w/ a job in a lovely language
05:39:26 <__monty__> kuribas: Because it's not pure enough? : >
05:40:00 <kuribas> __monty__: yeah, I have heared complaints that CT is used to loosely.
05:40:42 <kuribas> that it lacks rigour in haskell
05:41:32 <kuribas> lquenti: I did music teaching and accompaniment, but I didn't enjoy it too much.
05:42:53 <lquenti> kuribas: But how does anyone transition from music to programming? Seems not related to each other
05:43:10 <kuribas> lquenti: I was always nerdy though :)
05:43:22 <kuribas> I didn't just stop music and started learning about computers
05:43:36 <ph88> lyxia, here is my solution https://bpaste.net/show/b69b7316c996
05:43:55 --- mode: glguy set +v benl23_
05:44:03 <kuribas> lquenti: there is a lot of overlap between music and computing
05:44:05 <kuribas> or music and math
05:44:23 <benl23_> its more fun to compute.
05:44:25 <lquenti> Ah okay I got it now
05:45:00 <lyxia> ph88: doesn't it look like there's still repetition
05:45:15 <ph88> lyxia, yes i'm very satisfied :D
05:45:35 <ph88> oh i misread your sentence
05:45:58 <ph88> lyxia, my goal was to extra the differences because it's implementation detail for bytearray and text .. i wanted to keep the commonalities
05:46:04 <kuribas> lquenti: what makes you going from python to haskell?
05:48:24 <lquenti> Im still on my bachlors degree in compsci. Since I started studying I worked for an institute nearby and they used python, which I knew enough about to be productive. Last Semester I learned about Haskell and I was totally hooked that I kept spending much of my free time learning about the language!
05:48:56 <Athas> Good!  It is better!
05:49:51 <kuribas> lquenti: cool!  don't let anyone convince you that haskell isn't a practical language.
05:50:04 <phadej> lquenti: i actually programm haskell for living
05:50:22 <kuribas> phadej: where do you work, if I may ask?
05:50:31 <phadej> and so far it isn't compilers neither blockchain
05:50:38 <Rembane> phadej: What?! :O
05:50:40 <thevishy> haskell is really nice. I think it is a good tool to have even when you program in other languages for a living.
05:50:52 <Rembane> phadej: I thought all FP jobs were in blockchain these days! 
05:50:58 <phadej> Rembane: imagine that ;)
05:51:02 <kuribas> phadej: good for you, blockchain is a bubble.
05:51:03 <lquenti> kuribas phadej I actually dont care that much about practicality since the world seems to become more functional (ES6, Rust) and its just a hobby of myself
05:51:14 <kuribas> lquenti: true
05:51:48 <kuribas> phadej: are you the maintainer of aeson?
05:51:54 <thevishy> Haskell's Wiki says that the last stable release was in 2010. What does that mean?
05:52:09 <kuribas> that the wiki is outdated?
05:52:15 <phadej> kuribas: "major contributor"
05:52:32 <lquenti> phadej Rembane maybe a stupid question but why is Haskell good for blockchain?
05:52:55 <Rembane> lquenti: You can create assurances by using the type system that your investors like. Otherwise I don't know. :)
05:53:57 <kuribas> phadej: I'd like to add structured error messages to aeson.
05:54:09 <lquenti> Haha what a funny application of haskells features
05:54:39 <kuribas> phadej: should be possible in a mostly backward compatible way, but may change error strings.
05:54:51 <kuribas> phadej: you think the maintainers would accept such a change?
05:54:53 <thevishy> It says stable release was in 2010 and next release is in 2020
05:55:01 <phadej> kuribas: i'll believe you when I see the patch :)
05:55:06 <thevishy> I was thinking that nothing new got added to the language perhaps
05:55:10 <kuribas> phadej: fair enough
05:55:36 <phadej> kuribas: and probably yes. especilly if it doesn't regress performance
05:55:47 <ph88> can i put type constraints in "type = blabla"  ?
05:55:55 <kuribas> aeson uses attoparsec right?
05:56:06 <phadej> kuribas: yes
05:56:22 <kuribas> phadej: then I'd need to implement another parser on top of it that can generate non-string errors.
05:56:23 <phadej> and the lexical level errors are terrible due that
05:56:47 <phadej> i.e. if you have eg two consecutive commad
05:56:50 <phadej> commas
05:57:02 <phadej> but then: performance
05:57:09 <kuribas> phadej: would you suggest change the low level parser library?
05:57:26 <tdammers> lquenti: AFAIK the main reason Haskell is popular for blockchain stuff is because people are now realizing that formal underpinnings are vital due to security concerns (a single edge case can ruin an entire cryptocurrencry overnight), so the untyped "just write more unit tests" approach isn't really appropriate, and among the languages that have a strong enough type system do encode the formalisms, Haskell
05:57:27 <tdammers> is probably the most practical one
05:57:43 <tdammers> s/do/to/
05:58:17 <lyxia> ph88: why not    let f toPtrLen = toPtrLen pattern (compileCurry P.c'pcre2_compile_16 p_options p_errorcode p_erroroffset p_ccontext)
05:58:28 <kuribas> tdammers: it's not filling one fad with another one?
05:59:02 <lyxia> ph88: so the next two lines are just ... <- Code <$> f textToPtrLen   and   ... <- Code <$> f bytearrayToPtrLen
05:59:22 <phadej> kuribas: that would be difficult. Hand made low-level JSON parser would be better approach, IMHO
05:59:39 <ph88> lyxia, yes that would be the next type .. but to get to this point i had to refactor out the implementation detail of bytearray and text
05:59:40 <phadej> at this point it makes sense to specialise precisely
05:59:58 <tdammers> kuribas: idk - IMO using a typed language for a problem domain where a high degree of certainty is important isn't a stupid idea
06:00:18 <ph88> lyxia, actually i have it like this now  https://bpaste.net/show/4b21f7a0b34b  so genericCompile kind of takes the place of your "f" but with more stuff in it :P
06:00:19 <tdammers> kuribas: riding the fad in order to sell it to management may or may not be a smart strategy
06:00:23 <lquenti> tdammers makes complete sense
06:00:41 <lyxia> ph88: right
06:00:58 <ph88> basically now i anything that can be turned into a pointer and length can be compiled :P
06:02:25 <kuribas> phadej: something like a parser combinator on top of an event based parser?
06:03:27 <ph88> lyxia, do you think it's possible to put the type constraint (Integral length) in the type InputConverter instead of the function ?
06:06:18 <phadej> kuribas: not necessarily. Parsing into Value first is ok approach. OTOH having streaming parser would be nice, yet there is json-stream
06:07:15 <phadej> therr is old PoC PR by me about these ideas
06:08:11 <phadej> https://github.com/bos/aeson/pull/560
06:08:33 <lyxia> ph88: I don't think so, since it's the caller of genericCompile that decides what length should be, and that constraint is there to tell the caller what it could be.
06:08:44 <ph88> ok
06:09:28 <kuribas> phadej: bypassing Value may give a good performance improvement.
06:10:05 <kuribas> phadej: if that's even possible with the current parseJSON type
06:10:42 <lyxia> parseJSON already assumes you have a Value
06:10:46 <phadej> you'd need to make toEncoding line parseStream
06:11:14 <phadej> and I doubt performance improvement would be thst huge, because unordered records
06:11:41 <kuribas> hmm right
06:11:42 <ph88> is there some typeclass where it's required to implement an allocate and free function ?
06:13:17 <phadej> also streaming parser would make monadic parsing difficult, e.g. check type field to decide how to parse the rest
06:13:48 <phadej> the performance between best and worst scenario would be noticeable
06:14:01 <kuribas> phadej: yeah, there would be no real difference for parsing objects
06:14:50 <phadej> there might be if you inly need two fields of hundred, but that's not common
06:15:36 <kuribas> no indeed
06:15:48 <kuribas> only for parsing long nested arrays
06:31:56 <kuribas> phadej: my idea is to create version which return more information.  For example data JSONError = ...   Then type Parser = ExtParser String,  extWithObject :: String -> (Object -> Parser a) -> Value -> Parser JSONError a
06:33:52 <kuribas> phadej: or I could add a typeclass to withObject etc... to transform the error.
06:34:18 <kuribas> phadej: and add an instance for String so it's backwards compatible
06:43:45 <ph88> what steps should i do before library release ?
06:43:53 * hackage datasets 0.3.0 - Classical data sets for statistics and machine learning  http://hackage.haskell.org/package/datasets-0.3.0 (ocramz)
06:44:17 <reactormonk> ph88, make sure your package.yaml / .cabal file are somewhat complete
06:44:29 <ph88> ok, anything else ?
06:45:09 <reactormonk> https://hackage.haskell.org/upload
06:45:25 <reactormonk> Then pick your side on the semver vs. PvP battle
06:45:52 <reactormonk> setup CI preferably
06:46:15 <reactormonk> after it's on hackage, https://github.com/commercialhaskell/stackage/blob/master/MAINTAINERS.md#adding-a-package
06:47:18 <ph88> by estimate how much is semver and PvP used percentage wise ?
06:48:27 <reactormonk> I don't know - you might want to constrain that question to "packages updated in the last X years".
06:48:44 <kuribas> isn't pvp the haskell default?
06:48:59 <kuribas> well standard
06:49:19 <kuribas> I'd just use pvp because that is what others use.
06:51:51 <Solonarv> PvP is recommended by Hackage and assumed by tools such as cabal
06:52:34 <Solonarv> ph88: make sure you *have* a cabal file, and ideally that it's checked into source control - not just a package.yaml
06:56:12 <kuribas> ph88: preferably make it installable by cabal, not just stack.
06:56:20 <kuribas> I hate when something only works under stack.
06:57:05 <yushyin> yes that would be great, it is ok to support stack, but please also support cabal.
06:57:26 <mouse07410> Speaking of stack and cabal - I've a problem you might be able to help with. 
06:57:46 <mouse07410> A problem with cabal-doctest-1.0.6 and several packages that require it. 
06:59:17 <mouse07410> Those packages fail to compile, complaining that they cannot import "Distribution.Extra.Doctest", and that some files are missing from cabal-doctest-1.0.6.
07:01:33 <mouse07410> The stuff works under stack and passes "stack test" - I see the correct output. "stack install" does not complain - but I'm unable to find the installed/registered library, and "ghc-pkg list | grep saltine" returns empty 
07:03:28 <Solonarv> That's perfectly normal, stack doesn't install things globally
07:03:35 <mouse07410> One of the packages in question is https://GitHub.com/tel/saltine.git - could not install via cabal (it's normal way), but stack apparently succeeded. 
07:03:39 <Solonarv> (no, even `stack install` doesn't)
07:04:12 <Solonarv> try: stack exec -- ghc-pkg list | grep saltine
07:05:13 <mouse07410> Solonarv: is there a way to tell stack to install globally? And how can I use the results of "stack install" in other packages?
07:05:46 <Solonarv> in order: not as far as I know; the same way you use a package normally: add it as a dependency
07:07:49 <mouse07410> And in that case those installed dependencies would be only usable for stack-driven builds, right?
07:08:10 <Solonarv> No? specifying dependencies isn't a stack feature.
07:09:29 <mouse07410> Speeding them - isn't. But *finding*/*resolving* them appears to be - if I can find the installed stuff only via "stack exec ..."?
07:09:44 <mouse07410> Speeding => specifying
07:15:56 <mouse07410> Solonarv: your method showed that stack did install the library it built - into ".stack-work/install/x86_64-osx/ts-13.0/8.6.3/pkgdb"
07:17:10 <Solonarv> Yes indeed, they have to be installed *somewhere*. But that location isn't global!
07:17:12 <mouse07410> In the directory where the source of that library is - not in the "~/.stack/" or such. 
07:17:37 <Solonarv> That's exactly what "not a global install" means.
07:17:52 <mouse07410> There's no way to somehow move/copy it from there to a better place...? :-(
07:20:06 <mouse07410> Also, there's STACK_ROOT  env var. Should it point at "~/.stack"?
07:20:50 <Solonarv> what are you actually trying to do?
07:21:09 <Solonarv> If you want to use a library in your project, you should simply add it to your 'build-depends'.
07:21:59 <ph88> what about documentation ?
07:22:38 <mouse07410> I want to just that library in other projects. And I suspect that if I add it to dependencies there - it won't be find-able because it lives in a subdirectory of a source of this project. 
07:22:56 <mouse07410> Documentation to what? 
07:23:39 <mouse07410> stack docs didn't even tell correctly how to specify multiple extra-lib-dirs - I had to experiment. 
07:24:14 <Solonarv> I don't know about documentation - I usually read docs on hackage/stackage.
07:24:24 <ph88> to my library of course
07:24:35 <Solonarv> But if you add a library to build-depends, it will be "found" - that's the whole point of build-depends!
07:26:47 <yushyin> ph88: do you ask how to do library documentation?
07:27:07 <ph88> how and what, what type
07:27:21 <ph88> by the way i have a dependency on cmake .. should i put that somewhere ?
07:32:16 <mouse07410> Solonarv: indeed, I made an experiment, and stack did find that library listed as a dependency. It is still very inconvenient to have the resulting executable 7 levels deep down a subdir tree of the current project. There's no way to automatically copy it to somewhere more palatable? :-(
07:34:18 <lyxia> ph88: I think you should mention anything that a user needs to do beyond "stack install" or "cabal install" to use your package.
07:35:06 <ph88> mention it where though ?
07:35:16 <lyxia> When you don't know, put it in the README
07:35:27 <Solonarv> mouse07410: 'stack install' will build executables and copy them to ~/.local/bin (by default)
07:37:42 <mouse07410> Oh, that's outstanding. 
07:40:03 <mouse07410> And it worked!
07:43:30 <ph88> what should i do about the following error ?  https://bpaste.net/show/f5421ca026f5
07:48:07 <Boomerang> ph88: Put a type signature to your Num :)
07:49:51 <ph88> Boomerang, i have only this https://bpaste.net/show/aea8580f7e33  (line 2 in paste is line 18 in error)
07:49:57 <ph88> which Num ?
07:52:36 <Boomerang> ph88: What is the type of genericCompile?
07:53:50 <ph88> genericCompile :: Integral length => (InputConverter pattern length (Ptr C'pcre2_real_code_16)) -> (Maybe CompileContext) -> pattern -> IO (Either CompileError Code)
07:54:33 <Boomerang> The issue is that GHC can't guess what `length` should be so it is defaulting it to Integer
07:58:07 <Boomerang> ph88: I think it should be a warning by default unless you've made it an error. You should be able to specify what type you want. For example with TypeApplications you could do: genericCompile @Integer
07:59:08 <ph88> maybe it's better to change this function   bytearrayToPtrLen :: (BA.ByteArrayAccess ba, Num b) => ba -> (Ptr p -> b -> IO a) -> IO a
07:59:33 <ph88> ye it's good now when i change b to Int
07:59:45 <Boomerang> :)
08:34:02 --- mode: glguy set +v stepstep
08:34:22 * hackage collection-json 1.2.0.0 - Collection+JSON—Hypermedia Type Tools  http://hackage.haskell.org/package/collection-json-1.2.0.0 (alunduil)
08:36:23 * hackage siren-json 0.2.0.0 - Siren Tools for Haskell  http://hackage.haskell.org/package/siren-json-0.2.0.0 (alunduil)
08:38:53 * hackage network-uri-json 0.3.0.0 - FromJSON and ToJSON Instances for Network.URI  http://hackage.haskell.org/package/network-uri-json-0.3.0.0 (alunduil)
08:55:56 <adamCS> Vinyl/Frames question:  Is there a simple way to refer to the type of an ElField in a constraint?  I have a record with a field T (type T = "t" :-> a) and I'd like to write a function taking that record and a t as an argument.  I can pattern match: f :: (KnownSymbol tl, ElemOf r t, t ~ (tl :-> a)) => r -> a -> ..., but that seems sort of long winded.  Am I missing a simpler way to express that?  
08:57:38 --- mode: glguy set +v gentauro
08:57:44 <gentauro> Boomerang: Will you be around end of February (CPH?)
08:58:27 <gentauro> I might have convinced  From:
08:58:33 <gentauro> Oskar Wickström
08:58:53 <gentauro> to give a talk on his `Declarative GTK+` lib for Haskell :)
08:58:54 <lyxia> adamCS: that's the right way to do it
08:59:42 <adamCS> lyxia:  Okay.  Thanks.  It's sort of painful to have to constrain the label just to get the type. 
09:00:15 <lyxia> adamCS: you can also define a type family:    type family FType ef ; type instance FType (_ :-> t) = t
09:00:51 <adamCS> lyxia: Ah! That would help. I don't need the labels.  
09:04:22 * hackage arity-generic-liftA 0.1.0.0 - Provides an arity-generic version of the liftA2, liftA3... liftAn functions.  http://hackage.haskell.org/package/arity-generic-liftA-0.1.0.0 (oisdk)
09:07:36 <Solonarv> adamCS: I think that type family might already be defined somewhere in vinyl
09:08:22 <lyxia> ^ that last package looks familiar... https://www.reddit.com/r/haskell/comments/aaik7t/blog_variablearity_zipwith_in_terms_of/ecsowxo/
09:08:26 <adamCS> Solonarv:  I sort of thought it would be and then I couldn't find it.  But maybe I wasn't looking in the right place.
09:17:13 <oisdk> lyxia yup that's me! (/u/foBrowsing & oisdk)
09:18:43 <Solonarv> oooh that's cool!
09:19:02 <Solonarv> I've tried writing something similar but ran up against sucky type inference
09:19:48 <lyxia> :)
09:20:28 <SrPx> I'm thinking about the problem of determining if two λ-calculus terms are equal. Note those terms could be infinite, ex., given `a = 1 : 2 : a`, and `b = 2 : 1 : b`, then `a == 1 : b`. But I don't think the equality of two arbitrary terms can be decided in general. Can it be decided for ADTs though? What are its properties? I'd like to read about this problem, so I'd appreciate a name.
09:26:18 <rain1> SrPx: normally lambda calculus terms are finite
09:27:15 <rain1> you can maybe the solve the problem you had in mind using unification
09:27:24 <rain1> assuming no lambda terms occur
09:28:51 <ggole> If you allow cycles, it sounds a bit like graph isomorphism
09:28:54 <lyxia> This kind of problem occurs with equirecursive types (where the infinite structures are types) and dependent types with coinduction.
09:30:55 <ph88> someone want to help me with my regex library ? i'm a bit bored working on it now, but basic functions are done. Maybe if somebody tries it i'm more motivated to add some features
09:35:41 <Boomerang> gentauro: I might, I'm coming back to CPH later this month! :D It'd be great to have Oskar give a talk, I met him in ZuriHac and it was a pleasure to talk with him!
09:36:57 <lyxia> SrPx: try to decide   map f [0..] == map g [0..]   and bam the Halting Problem hits you.
09:37:14 <SrPx> lyxia: makes sense
09:37:46 <Solonarv> That example has nothing to do with the halting problem
09:37:55 <SrPx> lyxia: yes that's the context where I'm seeing this problem, deciding equality (for type checking) in a type system that allowed infinite structures like Haskell's
09:38:10 <lyxia> Solonarv: why not
09:38:18 <Solonarv> in the sense that a computer equipped with a halting-problem-oracle still couldn't decide their equality
09:38:35 <ph88> i want such an oracle
09:38:52 <ph88> does it come as PCIe card ?
09:38:55 <rain1> Solonarv: you could decide it using a halting oracle
09:39:05 <lyxia> Should I have said "Rice's Theorem hits you"
09:39:08 <Solonarv> how?
09:39:13 <rain1> just ask it if  if (map f [0..] == map g [0..]) then loop else terminate  terminates
09:39:24 <SrPx> if you have dependent types and haskell-like infinite structures, obviously your type-checker won't terminate in the case you have two infinite terms at the type level and must check if they're equal. I'd just like to read more about this specific problem in this context
09:40:24 <lyxia> Can't you more simply ask whether "map f [0..] == map g [0..]" terminates
09:41:21 <rain1> no
09:41:48 <nshepperd1> Is they're equal, it won't terminate so sure
09:42:16 <nshepperd1> You probably also want to check whether f and g terminate
09:42:36 <Solonarv> Hmm... ask it if 'take 1 . filter (uncurry (/=)) $ zip (map f [0..]) (map g [0..])' terminates?
09:42:41 <Solonarv> Yeah, I'm convinced now
09:43:00 <lyxia> what I wrote is a plain Bool
09:43:18 <Solonarv> But that never terminates no matter what
09:43:34 <Solonarv> [0..] == [0..] also never terminates
09:43:34 <lyxia> > map (+1) [0 ..] == map id [0 :: Integer ..]
09:43:36 <lambdabot>  False
09:44:05 <Solonarv> okay, fair enough - it can only return False or diverge
09:44:26 <Solonarv> Hmm....
09:44:54 <ggole> Or continue until a bit flip causes it to return True
09:45:08 <Solonarv> There are no cosmic rays in our theory
09:45:17 <ggole> Then what use is your theory?
09:45:23 * ggole is not serious
09:46:22 <ggole> Hmm, a power outage probably counts as diverging too.
09:46:22 <nshepperd1> A halting oracle that always returns "true, because a cosmic ray happens eventually" is a disappointing child
09:47:13 <SrPx> ...
09:47:21 <wroathe> Is ⊥  enough to describe every possible failure case when talking about computations? Meaning that if I say a function can return 0, 1, or ⊥, does that mean I can describe every scenario where the function does not return precisely 0 or 1 with ⊥?
09:47:24 <ggole> This is helpful! I'm being helpful!
09:48:00 <wroathe> Just thinking about how ⊥ applies to the plethora of possible failure cases in programming...
09:48:06 <carette> Suppose I'm using classy lenses, and I have a method uid :: Lens' x a with two instance already defined for Foo and Bar.
09:48:19 <carette> Then I define
09:48:34 <carette> data XXX = Bong Foo | Bang Bar
09:48:55 <carette> of course, now I can easily (hand-define) uid for XXX. But what is the easiest way to do so?
09:48:59 <Solonarv> wroathe: usually lumping all forms of "never returns" into ⊥ is good enough
09:49:20 <carette> (I've asked on #haskell-lens, but there doesn't seem to be anyone there ATM)
09:49:30 <wroathe> Solonarv: Got it, and yeah I suppose it wouldn't be correct to say that a function "returns" ⊥
09:49:50 <reactormonk> carette, I think you can auto-derive a prism here, then somehow merge prism + 2 lenses into a regular lens, but it's been a while.
09:50:02 <reactormonk> or just manually write it.
09:58:11 <Clint> can someone explain https://paste.debian.net/1058175/ to me?
10:04:52 <carette> reactormonk as I said, I can indeed write it by hand (I have). I am trying to see if I can simplify it.
10:05:04 <carette> auto-deriving most of it would be best.
10:06:16 <carette> Oh well, by-hand it is for now. I guess I'll come back when more people seem to be active.
10:53:51 <wroathe> Is there an easy way to query a list of all of the typeclasses in base?
12:28:23 * hackage microlens-aeson 2.3.0.1 - Law-abiding lenses for Aeson, using microlens.  http://hackage.haskell.org/package/microlens-aeson-2.3.0.1 (fosskers)
12:34:19 <jle`> wroathe: maybe check out the source and grep "^class" ?
12:34:27 <jle`> * "^class "
12:34:51 <wroathe> jle`: Yeah, that's what I was thinking. I was just checking to see if there was maybe a fancy feature of hoogle I didn't know about.
12:34:57 <wroathe> Or something like that
12:35:05 <jle`> hm, there might be
12:39:13 <Solonarv> wroathe: usually lumping all forms of "never returns" into ⊥ is good enough
12:39:20 <Solonarv> oops, typo
12:39:58 <wroathe> Solonarv: Yeah, I saw your response earlier. Sorry for not acknowledging. Thanks for the help!
12:40:22 <Solonarv> wroathe: I didn't mean to re-send it, I switched to the wrong window
12:41:29 <wroathe> Ah
13:57:25 <khumba> Hi folks, happy NYE.  What's the upload file size limit on Hackage?  And/or is there a good way to manually build and upload docs without rendered source code?  I'm trying to upload qtah docs, and the recommended "cabal haddock" command produces an oversized 3.3MiB tarball.
13:58:34 <sclv> we just migrated the server and prob forgot ti bump tbe limit
14:02:37 <khumba> Ah, that size should be fine then?  I'll try again at some point in the future, thanks sclv.
14:42:19 --- mode: glguy set +v wroathe
14:42:37 --- mode: glguy set -v wroathe
14:42:51 <wroathe> Does anyone here know right off hand where the Monad instance definition for State is located?
14:42:56 <wroathe>                  Specifically the implementation for (>>=)?
14:43:24 <wroathe> The source code I mean
14:43:46 <c_wraith> there's only StateT
14:44:15 <hpc> http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Lazy.html#v:StateT - it's a type alias for StateT, but here's the data definition
14:44:22 <hpc> you can click "Source" next to the right instance...
14:44:22 <c_wraith> https://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control.Monad.Trans.State.Lazy.html#line-218
14:44:32 <hpc> which isn't linked
14:44:43 <hpc> so you have to look at the source and actually find it, which c_wraith did
14:44:59 <c_wraith> I didn't look at the source.  I just went to the docs for transformers instead of mtl
14:45:05 <hpc> oh
14:45:08 <c_wraith> because I knew the instance lives there
14:45:35 <wroathe> Oh, perfect. Thanks c_wraith!
14:45:42 <c_wraith> strict version:  https://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control.Monad.Trans.State.Strict.html#line-215
15:03:22 * hackage gitit 0.12.3.1 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.12.3.1 (JohnMacFarlane)
15:22:06 <wroathe> It's interesting that only certain monads provide accessor functions for their wrapped value, like runIdentity, runReader, runState, etc, which let you escape that monadic context, but once you're in IO you're trapped there.
15:22:48 <wroathe> I get why, but that to me seems like an important distinction between the various types of monads
15:22:50 <c_wraith> Note that a lot of those aren't simple wrappers
15:23:04 <c_wraith> Reader and State don't just unwrap a finished value
15:23:12 <c_wraith> They require additional arguments to function
15:25:19 <hpc> runIdentity is the only simple wrapper of them
15:25:20 <wroathe> c_wraith: well, technically doesn't it just unwrap the function you've been building up in the state monad? The argument you're talking about is applied to that inner function to get the resulting tuple
15:26:06 <c_wraith> yes, that's what it those functions do.  But there's still something there that connects them to IO in a way.
15:26:10 <wroathe> State doesn't just contain a simple value like a string, it wraps a \s -> (a, s)
15:26:35 <c_wraith> The value of type m a doesn't contain an a.  It *produces* one, in the right circumstances.
15:26:44 <wroathe> Right, but what I'm saying is that you can't do: IO a -> a
15:26:53 <c_wraith> That's the same as IO
15:27:55 <c_wraith> There are differences in that the production function is exposed (safely) for many other monads.  But the same "contains" vs "produces" model applies.
15:36:44 <wroathe> c_wraith: Yeah, I guess I'm saying that that key distinction between State and IO may be the place where beginners start to feel like the same name (monad) is being applied to two different concepts
15:36:49 <wroathe> Even though they're not different concepts
15:37:01 <wroathe> There is that minor distinction to factor in, that makes IO seem all the more magical
15:49:00 --- mode: glguy set +v wroathe
15:49:14 --- mode: glguy set -v wroathe
15:49:29 <wroathe> c_wraith: The thing that immediately stands out to me about that is that, at least for the simple monads that I know of, all of the computations of monads that expose run* functions can be rewritten in terms of regular old pure functions
15:59:52 * hackage RSA 2.3.1 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-2.3.1 (AdamWick)
16:03:52 <aplainzetakind> what's an easy way to write a parser (megaparsec) that would parse one of a certain number of set strings? I can only think of <|>'ing a bunch of `string "foo"`s. I'm hoping there's a case-like way to do this.
16:04:50 <Welkin> asum ["one", "two"]
16:04:53 <hpc> foldr1 (<|>) ["data", "module", "class", "type", ...]
16:04:55 <Welkin> :t asum
16:04:57 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
16:05:11 <hpc> oh, already defined :D
16:06:21 <MarcelineVQ> also called choice in some parsing libs, curious about what case-like way means for this task though
16:07:57 <aplainzetakind> Well I want to parse "foo" "bar" and * into `data Target = Foo | Bar | Unknown` basically.
16:08:59 <aplainzetakind> That asum is handy and I can fmap a String -> Target function over that of course.
16:10:29 --- mode: glguy set +v zachk
16:10:30 <zachk> don't you need a try on the earlier combinators to do backtracking? 
16:10:36 <zachk> don't you need a try on the earlier combinators to do backtracking? 
16:10:48 --- mode: orwell.freenode.net set +v zachk
16:10:48 --- mode: glguy set -v zachk
16:11:43 <aplainzetakind> zachk: I think `string` has backtracking built-in somehow.
16:13:43 <MarcelineVQ> aplainzetakind: Foo <$ string "foo" is kind of neat
16:13:44 <aplainzetakind> yes (string "foo" <|> string "faa") can parse "faa"
16:15:15 <aplainzetakind> MarcelineVQ: true, that would probably be more concise and clear than a utility function with cases.
16:17:26 --- mode: glguy set +v shiro[cloud]
16:17:42 --- mode: glguy set +v eubarbos`
16:23:19 --- mode: glguy set +v newToHaskell
16:27:28 <newToHaskell> Hi, I'm working through some exercises in a book. I'm supposed to create a function which takes a function f and integer n and returns a function that applies f to its argument n times. This is my solution: https://pastebin.com/6Bsgzrfe . However, the its implied that the function should curry out the x argument and I'm not sure how to do that without the compiler complaining of infinite type error. Can anyone please help?
16:30:02 <c_wraith> Honestly, I'm not sure that's a great exercise.
16:30:22 <c_wraith> also, that's called "eta reduction", not "currying"
16:30:37 <c_wraith> In any case, you can eta reduce the second equation using (.)
16:31:09 <hpc> (f . g) x = f (g x)
16:31:21 <hpc> find some part of your definition matching the RHS, then rewrite it as the LHS
16:32:00 <hpc> then x will be in the right position for eta reduction
16:37:43 <newToHaskell> Got it, thanks
16:38:24 <newToHaskell> This question is before the book introduces function composition so I'm not sure exactly how they expect us to solve it...
16:38:46 <iqubi4> Can you share with us what you did?
16:39:23 <iqubi4> also: power = iterate f x ! n
16:40:53 <newToHaskell> eta reduced: https://pastebin.com/2RjbiYeR
16:40:54 <coldpress> +newToHaskell: use the properties of eta reduction
16:44:22 <coldpress> did you solve your problem?
16:45:44 <iqubi4> @pl power = iterate f x ! n
16:45:44 <lambdabot> power = iterate f x ! n
16:46:02 <iqubi4> @pl power f x n = iterate f x ! n
16:46:02 <lambdabot> power = ((!) .) . iterate
16:46:04 <newToHaskell> yes, I solved it thanks
16:46:45 <iqubi4> If you want to really obsure, use the above code.
16:49:24 <Welkin> except remove the list indexing
17:04:28 <argent0> how do I make a short circuiting `mappend`? https://paste.pound-python.org/show/MWq7cRjeMbJK9lG3hTHt/
17:14:53 * hackage mapalgebra 0.1.2 - Efficient, polymorphic Map Algebra.  http://hackage.haskell.org/package/mapalgebra-0.1.2 (fosskers)
17:15:23 <c_wraith> argent0: write equations that ignore their second input.
17:15:40 <c_wraith> argent0: you have exactly one equation which does - the first one
17:15:50 <c_wraith> argent0: every other case won't short-circuit
17:29:35 <argent0> c_wraith: I'll check it out
17:36:22 * hackage libretls 0.0.0.0 - libtls bindings  http://hackage.haskell.org/package/libretls-0.0.0.0 (CarterSchonwald)
17:38:23 * hackage hspec-core 2.6.1 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.6.1 (SimonHengel)
18:23:23 * hackage hspec 2.6.1, hspec-discover 2.6.1 (SimonHengel): https://qbin.io/rc-custom-bu8y
18:33:50 <Arahael> I want to parallelize my mapM, how do I do so? (I've tried searching online, but it's hard.  Apparently I might be able to do this with 'par', but where can I find that?)
18:34:04 <Arahael> It's not in scope, so I have to import it from... somewhere...
18:34:21 <Arahael> I've read https://wiki.haskell.org/Parallelism
18:34:36 <Arahael> But it doesn't tell me (it directs me to the relevatn chapter in real world haskell, but it's a dead link)
18:42:44 <rotaerk> Arahael, https://hackage.haskell.org/package/monad-parallel
18:47:59 <Arahael> rotaerk: Beautiful, that works nicely - thanks.  Using their mapM, too easy.  It's absolutely messing up my console output, but that's very much as expected. :)
18:55:59 <Arahael> Interesting, using Prelude.mapM, vs Control.Parallel.mapM, the parallel version is 2x faster.
19:12:52 * hackage unboxed 0.1.0.0 - All the standard sum types but strict and unboxed as possible  http://hackage.haskell.org/package/unboxed-0.1.0.0 (CarterSchonwald)
19:14:28 <sclv> khumba: hackage server has had its upload size bumped, i think...
19:31:53 * hackage numerical 0.0.0.0 - core package for Numerical Haskell project  http://hackage.haskell.org/package/numerical-0.0.0.0 (CarterSchonwald)
19:37:53 <iqubi4> :t (::)
19:37:54 <lambdabot> error: parse error on input ‘::’
19:37:59 <iqubi4> Darn.
19:38:22 <Arahael> iqubi4: Yeah, that's syntax, not an operator, I believe.
19:39:12 <iqubi4> I know. Someone in #emacs was saying it was an operator.
19:41:55 <Arahael> With Megaparsec, given a Parser Foo, can I get IO out of that?
19:42:18 <Arahael> I'm wondering if I can load additional files in the process of parsing a particular token, or if I need to defer that to after the parse.
19:42:47 <amalloy> you'll want to use the parser transformer instead of just Parser, and have IO be your underlying monad
19:43:11 <Arahael> Hmm.
19:43:34 <amalloy> type Parsec e s = ParsecT e s Identity
19:43:36 <iqubi4> So something ParserT IO Foo
19:43:52 <amalloy> so you'll use IO instead of Identity
19:44:15 <Arahael> So it's certainly doable.  Now I have to figure out the harder question of whether I should.
19:45:02 <khumba> sclv: The upload worked this time, thanks for your help!  For some reason, Bool/String/Int hyperlinks point to Cabal's Distribution.Compat.Prelude.Internal module, that's weird, but other than that the docs are there now, hooray.
19:48:14 <Arahael> Is it possible to tell Haskell's type system that a particular value should never be discarded?
19:48:37 <Arahael> Eg, _ <- doNotDiscardX should result in a warning.
19:49:07 <iqubi4> nope.
19:49:09 <MarcelineVQ> with linear haskell possibly
19:49:39 <dmj`> MarcelineVQ: hey
19:50:05 <ensyde> @MarcelineVQ linear haskell? haskell newby. What is that exactly
19:50:05 <lambdabot> Unknown command, try @list
19:50:25 <c_wraith> a proposed language extension that adds linear arrows
19:50:44 <iqubi4> what is linear haskell?
19:50:49 <c_wraith> ^
19:51:00 <Arahael> iqubi4: I think I'll settle for "nope", given the current discussion! :)
19:51:31 <Arahael> At least, grepping for _, and void, are relatively simple tasks.
19:51:32 <MarcelineVQ> Arahael: It would need to be phrased differently than _ <- doNotDiscardX anyway, so no is a fine answer
19:52:07 <lyxia> you can kind of approximate it with an indexed monad
19:52:12 <MarcelineVQ> ensyde, iqubi4: https://ghc.haskell.org/trac/ghc/wiki/LinearTypes
19:52:23 <ensyde> ty
19:52:33 <Arahael> MarcelineVQ: Yeah, I'm not disputing it.
19:53:05 <dmj`> MarcelineVQ:  got the VM working :) 
19:53:18 <MarcelineVQ> dmj`: neato
19:53:24 <dmj`> it's cool
19:56:16 <dmj`> the other games work too, not just 2047
19:56:19 <dmj`> 2048* :)
19:56:23 * hackage resin 0.2.0.3 - High performance variable binders  http://hackage.haskell.org/package/resin-0.2.0.3 (CarterSchonwald)
19:58:11 <MarcelineVQ> dmj`: What's next?
19:58:25 <dmj`> upload to hackage I guess
19:58:33 <dmj`> :)
20:03:21 <iqubi4> My new year's resolution for 2018 is to stop making off by one errors.
20:06:51 <dmj`> MarcelineVQ: might work on cocoa bindings
20:07:53 * hackage LC3 0.1.0.0 - LC-3 virtual machine  http://hackage.haskell.org/package/LC3-0.1.0.0 (DavidJohnson)
20:11:23 * hackage graphviz 2999.20.0.3 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.20.0.3 (IvanMiljenovic)
20:11:53 * hackage LC3 0.1.0.1 - LC-3 virtual machine  http://hackage.haskell.org/package/LC3-0.1.0.1 (DavidJohnson)
20:14:21 <lyxia> Arahael: https://gist.github.com/Lysxia/6be7bd107e2b5863140acaa7556aa3a1
20:14:57 <lyxia> -- Forgetting to free, or freeing twice the same pointer, causes a type error.
20:15:59 <Arahael> lyxia: That's pretty awesome, sadly, I can't use it for "_ <- foo" cases.
20:16:05 <Arahael> lyxia: I'll bookmark it regardless. :)
20:19:53 * hackage LC3 0.1.0.2 - LC-3 virtual machine  http://hackage.haskell.org/package/LC3-0.1.0.2 (DavidJohnson)
20:27:41 --- mode: glguy set +v test
21:07:27 <nitrix> Happy new year EST.
21:08:21 <emilypi> Ayyyyy lmao
21:10:08 <coldpress> thinking about functional userspace drivers https://media.ccc.de/v/35c3-9670-safe_and_secure_drivers_in_high-level_languages
21:11:36 <rnmhdn> what haskall interactive options are there?
21:11:59 <rnmhdn> anyone know what this video is using at minute 3? https://youtu.be/fCoQb-zqYDI
21:12:54 <iqubi4> That's emacs and haskell-mode.
21:13:28 <rnmhdn> can't I get ghci to have syntax highlighting 
21:13:42 <rnmhdn> can't I get anything like that in vim?
21:13:56 <iqubi4> 1. Not sure.
21:14:03 <iqubi4> 2. I don't think so.
21:27:09 <coldpress> rnmhdn: I believe for vim there is vim-syntastic
21:27:31 <rnmhdn> I meant for having a haskell repl within vim
21:27:41 <coldpress> just open up a new terminal window
21:27:52 <rnmhdn> I want the syntax highlighting within a repl
21:28:14 <rnmhdn> like in ipython
21:28:31 <coldpress> why are you working within a repl though? you can store your source code in a file, load the file into ghci, and reload ghci when needed
21:29:50 <coldpress> ooh nice, i've been meaning to implement a LC-3 VM in haskell
22:01:52 * hackage passman 0.1 - a simple password manager  http://hackage.haskell.org/package/passman-0.1 (jlamothe)
22:10:23 * hackage gitit 0.12.3.2 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.12.3.2 (JohnMacFarlane)
22:12:51 --- mode: glguy set +v oortScrambler
22:14:24 <oortScrambler> It doesn't have the terminal directly there but you can send things to a terminal running GHCI and it works alright
22:21:22 * hackage parser-combinators 1.0.1 - Lightweight package providing commonly useful parser combinators  http://hackage.haskell.org/package/parser-combinators-1.0.1 (mrkkrp)
22:39:16 <nyc> What language extensions have I missed since 2004 or thereabouts?
22:40:46 <nyc> Actually, I haven't done much since my initial learning in 1996 besides the Fibonacci implementation under my former name.
22:45:22 * hackage script-monad 0.0.3 - Stack of error, reader, writer, state, and prompt monad transformers  http://hackage.haskell.org/package/script-monad-0.0.3 (nbloomf)
22:46:04 <butterthebuddha> What's a good post-cis 194 haskell resource?
22:47:55 <nyc> butterthebuddha: Could you clarify?
22:48:29 <butterthebuddha> I've done all the CIS 194 homework. Where should I look next to learn more "intermediate" haskell?
22:49:35 <Arahael> butterthebuddha: Have you done actual projects with haskell yet?  I'm "intermediate", as I'm sure others here will confirm, but I do strongly feel that once you've got the basics down, you need more pragmatic experience before really appreciating additional resources.
22:49:37 <nyc> butterthebuddha: I don't know what CIS 194 is.
22:50:21 <butterthebuddha> Arahael: I'm working on implementing Euchre (its a card game) in Haskell right now
22:50:37 <butterthebuddha> nyc: http://www.cis.upenn.edu/~cis194/spring13/ <- this seems to be a popular first-introduction to haskell
22:50:57 <Arahael> butterthebuddha: Awesome. :)
22:51:05 <Arahael> butterthebuddha: What graphics lib do you use, out of itnerest?
22:51:08 <Arahael> *interest
22:51:17 <butterthebuddha> It's completely CLI based
22:51:49 <amalloy> if you already have a project in mind, and a basic proficiency with the language, then you don't really want generic learning resources. surely there are some specific things in your project that aren't going well or feel missing - you want resources on those things
22:51:53 * hackage equeue 0 - Application level triggered, and edge triggered event multiqueues.  http://hackage.haskell.org/package/equeue-0 (davean)
22:52:06 <butterthebuddha> I plan on avoiding writing GUI code for as long as possible
22:52:23 <Arahael> butterthebuddha: Why?
22:53:12 <butterthebuddha> amalloy: I will need resources specific to my projects, but I imagine there are some standard topics that I would want to learn that will make my code better in general 
22:53:19 <butterthebuddha> Arahael: it is terrible, from what I hear
22:53:51 <butterthebuddha> besides, it feels like most of my time would be spent wrangling with the API rather than actually with the language, so it doesn't seem like a productive way to learn the language itself
22:55:40 <Arahael> butterthebuddha: Terrible means there are real problems to solve.
22:55:54 <Arahael> butterthebuddha: Almost all languages have terrible UI libraries.
22:55:59 <nyc> butterthebuddha: People tend to like writing compilers in functional languages. Maybe try the Andrew Appel ML compiler book and do it in Haskell instead of ML.
22:56:15 <butterthebuddha> Arahael: indeed, so I hope to never have to write UI code directly
22:56:47 <butterthebuddha> nyc: I'll take a look at that. There was a lisp compiler I was working on that I abandoned. I might try to finish that first
22:56:47 <Arahael> butterthebuddha: You could use an SDL binding for the game.
22:57:22 <Arahael> Hmm.  A lisp -> haskell compiler.
22:57:40 <Arahael> Which lisp?
22:58:20 <butterthebuddha> I misspoke; it's not a compiler, but rather an interpreter. Though if I ever finish it, I'm going to attempt to compile the lisp to x86
22:58:25 <AfC> nyc: did you just say you haven't been doing Haskell since circa 1996? Cool!
22:58:43 <Arahael> butterthebuddha: That'll be *awesome* :)
22:58:46 <nyc> butterthebuddha: Lisp is tough because it's functional. A first-order imperative language is what the Andrew Appel books use.
22:58:46 <butterthebuddha> Its a simple version of lisp similar to the one originally published by McCarthy
22:59:00 <Arahael> butterthebuddha: The 1956 lisp, that doesn't have numbers?
22:59:15 <butterthebuddha> Mine does have numbers, but yes
22:59:22 <Arahael> Very nice :)
23:00:02 <nyc> AfC: I wrote occasional things, but didn't do much significant learning.
23:00:10 <AfC> nyc: (to have seen the language in its early days and now to see its growth)
23:01:15 <nyc> AfC: More language features?
23:01:55 <AfC> nyc: I've been full time in Haskell for 7 years now and still consider myself quite the brutalist. It (and functional programming generally) is a long, delightful learning curve if you want it to be. Or you can do it professionally and be REALLY FRUSTRATED for a living :)
23:03:13 <AfC> nyc: evolution of the language's ecosystem (more so than the language itself);
23:04:05 <Arahael> AfC: Using haskell professionally would be *awesome*.  "Really Frustrated" would be using Haskell as a hobby...  And coding Delphi at work. :)
23:04:42 <AfC> nyc: outstanding and continuing contribution to the quality (read performance) of the runtime in industrial settings;
23:05:10 <Arahael> Also very interesting to see: Increasing haskellification of mainstream languages. (Though granted: It's mostly ocamlification)
23:05:11 <nyc> AfC: I've never worked with Haskell professionally. I guess I can stack monads, but only got paid for my work on the kernel.
23:05:37 <nyc> Arahael: F# ?
23:05:45 <butterthebuddha> Can I only use the vector-algorithms library with IO?
23:06:33 <Arahael> nyc: Yes, F#, Swift, Kotlin...
23:06:45 <AfC> nyc: you're a kernel hacker who knows functional programming? Jeez, don't suppose you want to move to Australia?
23:07:20 <AfC> Arahael: Heh, yes. You win
23:07:25 <AfC> Arahael: 
23:07:34 <nyc> AfC: What's in Oz?
23:08:08 <Arahael> nyc: Heat.
23:08:32 <AfC> Arahael: (it's frustrating when you assemble several [dozens, even] of outstanding functional programmers but then try to get them focused on writing stuff in a corporate setting. It's NOT an easy environment to be a developer; many give up. The ones that don't argue about which build system they should use.
23:08:43 <nyc> Arahael: I'm unfamiliar with those things.
23:09:50 <julianleviston> So much heat.
23:10:16 <Arahael> AfC: Build systems are a big deal. :(  We use Rake at work.
23:10:26 <nyc> AfC: Eh, coding means working with other people.
23:11:11 <Arahael> nyc: F#, Swift, Kotlin, are all languages that have more "functional" language features compared to the mainstream.
23:11:37 <Arahael> nyc: Focusing on .NET, macOS, and Java, respectively.
23:11:55 <AfC> nyc: sure does. Software engineering is a team sport. Ironically, I think one of the challenges is that so many people [certainly applies to me] learned Haskell by themselves and predominantly write their Haskell to their own aesthetic. Makes working in a team a big adjustment.
23:12:32 <julianleviston> AfC: in my experience, all teams have a different aesthetic, no matter what the language.
23:12:44 <julianleviston> AfC: which means wherever you go, you have to learn the style du jour of that team.
23:12:44 <coldpress> AfC: is it the merging of different styles of code that cannot be solved by a linter?
23:13:06 <Arahael> coldpress: Linter? How did you manage to get the team to agree on linting? ;)
23:13:06 <julianleviston> that’s what we do at work.
23:13:12 <nyc> Arahael: Hmm. I never deal with .NET, MacOS, or Java. Just C and assembly.
23:13:22 <julianleviston> Arahael: you start with a point, then adjust it with meetings.
23:13:43 <Arahael> julianleviston: Heh.
23:13:52 <Arahael> In seriousness, you can go far with having a sane CI build system.
23:13:56 <AfC> coldpress: it's more than that, I'm afraid. What library family do you use for streaming I/O? What conventions do you use around allocation practices? What fucking _build system_ do you use? The list goes on, kinda forever.
23:14:12 <nyc> Coding style is something you do to meet a standard.
23:14:13 <Arahael> coldpress: Also: Tabs vs spaces?
23:14:16 <coldpress> Arahael: I don't have a team :) but there were a couple small group projects where my partners agreed to linting, really takes your mind of formatting code
23:14:18 <coldpress> spaces
23:14:30 <AfC> Arahael: yeah, but HOW MANY SPACES, hm?
23:14:31 <julianleviston> AfC: you should watch there was a talk by Ryan Trinkle about how to work with it in a team — use cool things sparingly was his TLDR advice.
23:14:48 <AfC> julianleviston: I was in the room when he gave that talk.
23:15:08 <julianleviston> AfC: right then! did none of his advice make sense to you?
23:15:08 <Arahael> One team at work can't agree on semicolons...  In a javascript project.  They've finally all agreed to use a code formatting tool that *none* of them likes. (As it's preferable to inconsistent semicolons)
23:15:17 <julianleviston> AfC: that talk was in sydney was it not? :)
23:16:26 <AfC> Still haven't seen a Haskell code formatter I can get along with, and I'm desperate for one
23:16:41 <julianleviston> Arahael: that’s not so great. Our FE team is in JS, and use the airbnb linter rules as a base set. Seemed to work. Everyone had a trouble when dropping semi-colons, but now they often report semi-colon code “looks weird” :)
23:17:33 <julianleviston> Arahael: I feel like generally the programming world is moving towards not caring so much about formatting. Maybe I’m overly optimistic :)
23:17:33 <Arahael> One reason I really like Go is that a lot of these decisions are taken out.
23:17:43 <MarcelineVQ> Formatting tools? I envy those for whom writing code (including formatting) is the slow part of programming.
23:18:06 <AfC> Arahael: literally the only thing I like about the language: when they released it they released _gofmt_ with it and simply told everyone to use it. Done deal.
23:18:11 <Arahael> MarcelineVQ: Reading badly formatted code is annoying.
23:18:19 <Arahael> AfC: Indeed.
23:18:30 <Arahael> AfC: They're really opiniated about build tools, too!
23:18:39 <julianleviston> MarcelineVQ: it’s really a different way of programming, I think… there’s not much *hard* stuff in JS world (because all the tricky stuff is so hard they don’t try to solve it)… and so people end up discussing things that don’t mater, coz. you know, you can change them ;-)
23:19:25 <julianleviston> MarcelineVQ: like… which Promise library to use (whereas whether to use Promises or not isn’t even on the question table)
23:23:44 <coldpress> Arahael: the way to fix that is with an opinionated formatter
23:25:48 <AfC> what I really need is a code formatter that will leave comments alone. I mean, really alone, because the [stupid] degree to which Haddock is sensitive makes it really tough to clean things up
23:26:58 <coldpress> haha yeah that's frustrating sometimes, but i guess it's good that your comments aren't all over the place
23:27:19 <nyc> Be sure to argue formatting rules when setting the standard, but when concretely writing, write to whatever standard is in play.
23:30:26 <nyc> Commented code often needs formatting, which largely thwarts mechanical methods.
23:39:25 <Arahael> coldpress: Yep.
23:39:50 <Arahael> AfC: The problem is that comments are overloaded.
23:40:08 <Arahael> AfC: Python did well to make comments part of the actual syntax, as an example.
23:40:28 <julianleviston> Arahael: or clojure/elixir with their docstring stuff
23:40:34 <nyc> There are questions that aren't just whitespace, too, like naming conventions for functions and variables. I tend to favor vowel-less abbreviations and single letters all lowercase e.g. fsck, n, but others favor Java naming conventions e.g. fileSystemCheck, counter.
23:41:01 <julianleviston> Arahael: I really wish there was some kind of semantic level definition space in haskell… a space for something like denotational design.
23:42:56 <nyc> Set a coding standard to demand comments?
23:52:53 * hackage webdriver-w3c 0.0.2 - Bindings to the WebDriver API  http://hackage.haskell.org/package/webdriver-w3c-0.0.2 (nbloomf)
23:53:00 <AfC> Arahael: sure. I have adopted the convention of only using block {-| ... -} comments for Haddock and using line comments -- ... for code comments. Works out nicely from a consistency standpoint. But it's that personal aesthetic thing again
23:56:12 <Arahael> AfC: Right.
