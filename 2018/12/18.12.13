00:00:42 <quchen> dminuoso: Making the Haskell logo not homogeneously blue but with an interesting pattern in it so I have to write my own library for generative art and aaaaaarabbithole
00:01:03 <quchen> Wasn’t fast enough, so blue stickers you got
00:01:12 <quchen> And I’m left with the geometry problem
00:01:17 <quchen> https://github.com/quchen/generative-art
00:01:56 <dminuoso> quchen: Any chance you can combine this with Joachims project?
00:02:44 <quchen> dminuoso: I think they target pretty different parts of the spectrum, his is explorative experimentation, mine is cold geometry
00:10:30 <tdammers> I think the thing with generative art is really still that you experiment a lot and then select the few happy paths that occurred
00:10:41 <CodeKiwi> apparenly dminuoso has never changed a light bulb
00:10:44 <tdammers> after all that's pretty much how art generally works
00:11:13 <CodeKiwi> https://www.youtube.com/watch?v=AbSehcT19u0
00:11:16 <tdammers> generate a thousand crappy attempts and then maybe one of them is alright, and that's the one you present
00:22:56 <bahamas> hello. I want to take the return value of this function: https://gitlab.com/joneshf/purty/blob/master/lib/Module.hs#L90, extract the value out ouf `Eff` and pass it to `pPrint` from pretty-simple. can anyone guide me on how to do that? 
00:23:43 <bahamas> I'm playing with this in ghci, so I just need an ad-hoc solution
00:40:16 <Ariakenom> lockestep: lockestep: map :: {function :: a->b, listToMap :: [a]} -> [b]
00:42:07 <Ariakenom> and a row typed record can be used for optional parameters
01:07:45 <maerwald> It seems 'tests: True' for your main package is broken in cabal.project if you have test specs, because if you run new-install it will try to *install* the test spec and fail. So you cannot enable tests with new-install in any way
01:14:11 <maerwald> dminuoso: btw https://github.com/vincenthz/hs-tls/issues/117
01:14:20 <maerwald> so we are vulnerable :)
01:15:57 <dminuoso> maerwald: Im not surprised.
01:17:36 <maerwald> I'm going to check all reverse deps of hs-tls and whether I can get rid of them... but probably not
01:35:42 <kuribas> can you have an applicative functor where you give extra information with the function call?
01:35:47 <kuribas> for example to have a trace of it?
01:36:39 <Boomerang> Something like These?
01:36:59 <Boomerang> https://hackage.haskell.org/package/these-0.7.5/docs/Data-These.html
01:37:16 <jle`> kuribas: you mean like Writer ?
01:37:24 <jle`> (or (w,))
01:37:29 <kuribas> like MyApplicative f => Annotated (a -> b) -> f a -> f b
01:37:52 <jle`> is that supposed to be a type signature
01:37:59 <Bish> is there a good way to write trace (show a) a
01:38:03 <Bish> without let
01:38:11 <dminuoso> Bish: just like that?
01:38:12 <jle`> is MyApplicative a typeclass?
01:38:13 <Boomerang> traceShoeId?
01:38:14 <jle`> Bish: traceShow ?
01:38:19 <jle`> er, traceShowId
01:38:19 <kuribas> jle`: yeah
01:38:29 <Boomerang> *traceShowId ^^
01:38:31 <Bish> dminuoso: well, i thought parenthesis are bad
01:38:33 <jle`> kuribas: what is Annotated?
01:38:40 <dminuoso> Bish: parenthesis are *not* bad.
01:38:42 <dminuoso> Bish: It's a myth.
01:38:51 <Bish> then i really don't get the invention of $
01:38:51 <jle`> Bish: parentheses are amazing :D i don't know anyone who says parentheses are bad
01:38:55 <kuribas> jle`: Annotated f = Annotated String f
01:39:08 <Bish> and now i will go into my infix prefix rant again, so put your ears into another direction
01:39:12 <jle`> Bish: it can help with clarity in some situations
01:39:16 <jle`> but not all
01:39:20 <jle`> it's a situational tool
01:39:23 <dminuoso> Ive stopped abusing (.) even and went back to using parens more liberally.
01:39:29 <dminuoso> It's far more expressive if after a year you go back to your code.
01:39:32 <Bish> jle`: removing infix can help with clarity everyhwere
01:39:38 <jle`> kuribas: are you looking for a type, or a typeclass?
01:39:46 <Boomerang> Bish $ can be useful for other things than getting rid of parenthesis, like getting of lambdas :D
01:39:51 <jle`> Bish: i don't know if i'd go to that extreme
01:39:55 <kuribas> maybe just adding a writer instance is enough...
01:39:56 <Bish> jle`: i'd
01:39:59 <jle`> a lot can be said for something like:
01:40:02 <jle`> > filter (< 3) [1..10]
01:40:05 <lambdabot>  [1,2]
01:40:09 <kuribas> jle`: I want to see the evaluation graph of what I am evaluating.
01:40:14 <Boomerang> > map ($ 3) [succ, pred]
01:40:16 <lambdabot>  [4,2]
01:40:21 <jle`> kuribas: so why are you bringing in a typeclass?
01:40:22 <Bish> Boomerang: the fuck
01:40:32 <kuribas> jle`: doesn't need to be a typeclass...
01:40:35 <dminuoso> Bish: $ is just specialized id.
01:40:44 <jle`> Bish: map ($ 3) [succ, pred] = [succ $ 3, pred $ 3]
01:40:51 <jle`> kuribas: oh, but what is MyApplicative f => there?
01:40:53 <Bish> haha, never seen it partially solved tho
01:40:59 <Bish> i get that.. $ does nothing if it is prefixed
01:41:03 <kuribas> jle`: yes, MyApplicative is a typeclass
01:41:05 <Bish> that's why i think it's stupid
01:41:11 <kuribas> jle`: like applicative, but annotated...
01:41:26 <jle`> oh, so are you asking about a typeclass of applicative functors that are annotated?
01:41:30 <maerwald> I'm unable to figure out what ssl implementation scotty uses :o
01:41:31 <kuribas> jle`: yes!
01:41:36 <jle`> ah, okay.
01:41:45 <kuribas> sorry that wasn't very clear
01:41:59 <jle`> i misunderstood. usually when people ask things like "is there a functor where..", the answer is usually the actual type, like Maybe, IO, Either e, etc.
01:42:00 <Bish> dminuoso: how do i say that a function with 2 parameters is used with 1?
01:42:10 <Bish> uncurrying would be wrong
01:42:16 <jle`> Bish: partial application
01:42:17 <Boomerang> partially applied?
01:42:23 <Bish> Boomerang: that's good
01:42:33 <Bish> so people use partially applied $?
01:42:52 <Boomerang> Not often, I was just giving another "use case" for $
01:42:55 <jle`> usually for situations like map ($ 3), above.  it can improve readability over map (`id` 3)
01:43:09 <Bish> Boomerang: well that'd confuse the hell out of newcomers
01:43:29 <jle`> is it any more confusing than `map (+ 3)`, though?
01:43:52 <jle`> once newcomers understand what an operator section is, then they have the tools to read and understand operator sections like map (+ 3), filter (< 4), etc.
01:44:09 <jle`> and operator sections usually come early in teaching haskell
01:44:19 --- mode: glguy set +v orangecat
01:44:21 <merijn> I prefer "consistent and useful" over "easy for newcomers", you're only a newcomer for a few months, consistency and usefulness is helpful for the rest of your life
01:44:54 <Boomerang> I'm sorry if it confused you too much. You seemed to already know that $ wasn't necessary so I assumed that example would come at a good time in your Haskell adventures :)
01:45:34 <jle`> kuribas: asking "is there a typeclass for ..." is sort of a weird question, usually, because it might be approaching from the wrong direction.  do you have any instances that you have in mind?
01:45:35 <Boomerang> > map (\f -> f 3) [succ, pred] -- This is probably more readable!
01:45:38 <lambdabot>  [4,2]
01:45:54 <jle`> kuribas: if you want to look for some behavior, then you usually are looking for a specific type
01:46:13 <jle`> kuribas: if you *have* many such types in mind, and you can give many examples, *then* it sort of makes sense to start asking "can i abstract over these types"
01:46:50 <jle`> if you're looking for a specific behavior, we can talk about finding a *type* that gives you that specific behavior
01:47:13 <jle`> if you're looking to abstract over the same behavior over many different types, then you can list some of those types and we can talk about a meaningful abstraction
01:47:37 <jle`> going the other way around doesn't really work
01:52:00 --- mode: glguy set +v zasi
01:53:41 <kuribas> jle`: yeah, I suppose I should write my types first, and then look if they are applicative...
01:54:07 <kuribas> jle`: I was just wondering if I can use FRP to model operations on time-series.
01:54:50 <kuribas> but also keeping track of the evaluation
01:55:15 <jle`> does Writer do the trick?
01:55:59 <kuribas> it could, but it like to add more information
01:56:17 <kuribas> in our lisp code, each function has a description
01:56:28 <kuribas> I mean formula
01:56:40 <jle`> because Annotated (a -> b) could just be (a -> Writer String b)
01:56:40 <kuribas> it's like a function with a lot of metadata
01:57:39 <zasi> is there a special reason to use folds over (x:xs) syntax ?
01:57:40 <kuribas> perhaps it's better to represent the evaluation graph as a GADT, instead of just strings
01:57:54 <kuribas> jle`: I am just trying to model our lisp app in haskell...
01:58:25 <jle`> zasi: if by folds you mean foldr/foldl, then one good reason is to avoid explicit recursion
01:58:30 <cole-k> quick question, how can I concat a lazy infinite list? I figure that (++) doesn't work because it wants to traverse to the end. Is it maybe not possible?
01:58:47 <Bish> why can i write multiple "functiond efinitions" in ghci? i mean it works inside a normal hs file
01:58:48 <jle`> zasi: if you're familiar with imperative languages, it's kind of like why we use while/for instead of GOTO
01:58:55 <cole-k> (by concat i mean prepend a finite list)
01:58:58 <Bish> something like f 1 = 1, f 2 = 2 .. etc
01:59:10 <jle`> > take 10 $ [1..] ++ [2,3,4]
01:59:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
01:59:15 <jle`> ^ cole-k 
01:59:29 <jle`> Bish: are you using a comma? try using a semicolon
01:59:34 <zasi> hmm isn't explicit better ? Its a lot more readable imo
01:59:42 <kuribas> jle`: but I don't think I can have both a evaluation graph GADT and FRP...
01:59:53 <jle`> zasi: explicit recursion leads to bugs, since there are a lot of ways you could accidentally write an infinite loop
02:00:09 <jle`> zasi: also, if you've been writing foldr/foldl etc. for a while, foldr can be much more readable than explicit recursion
02:00:12 <Bish> jle`: why does it have to be in the same line?
02:00:13 <jle`> if you're familiar with them
02:00:19 <Bish> while it doesn't for compiling
02:00:29 <cole-k> jle`: hm, thanks. guess my code is just wrong then.
02:00:41 <jle`> zasi: since foldr/foldl contain familiar control flow patterns
02:00:51 <jle`> zasi: if you're reading explicit recursion, you don't know what the control flow pattern is
02:01:04 <jle`> you have to look around in the code and find out when the recursion is happening, and how it is being called, how many times, etc.
02:01:06 <maerwald> Does anyone know if a property result is 'FailedChange', will that actually be a *failure*?
02:01:11 <maerwald> http://hackage.haskell.org/package/propellor-5.5.0/docs/Propellor-Types-Result.html#v:FailedChange
02:01:19 <maerwald> as in: will deployment fail
02:01:26 <jle`> if you're familiar with foldr, then you've already internalized and are familiar with the control flow of foldr
02:01:31 <jle`> because you've seen it hundreds of times
02:01:46 <jle`> Bish: in ghci, each "line" is actually a command to change the environemnt
02:01:55 <jle`> Bish: it doesn't quite behave like normal source code
02:02:02 <zasi> thank you for the detailed response ^^
02:02:04 <Bish> so type annotation for a function also has to be in that line?
02:02:20 <jle`> Bish: 'defining a function' in ghci is a command to change the environment, so if you type f 1 = 1, then f 2 = 2, then that's like defining f, and then re-defining it
02:02:28 <zasi> It was pretty hard to wrap my mind around foldl/foldr
02:02:35 <jle`> it allows for shadowing, like ghci> x = 3; then later, you can type ghci> x = 4, and it shadows the previous definition
02:02:39 <Bish> jle`: yeah i figured, couldn't make sense of it, before you explained though
02:02:43 <zasi> but it seems like a necessity
02:02:56 <Boomerang> Bish: You can get multi-line with :{ to open and :} to close
02:02:58 <jle`> Bish: it's definitely unexpected though, and it trips up a lot of people
02:03:08 <jle`> Bish: for myself, i default to :set +m, which allows for multi-line input
02:03:22 <jle`> Bish: if you :set +m, then ghci will wait until you're "done" with a let ... binding before "comitting" it
02:03:39 <jle`> zasi: using foldr and foldl is never strictly "necessary", because you can always re-write it using explicit recursion
02:03:57 <jle`> zasi: but foldr and foldl let us wrap up very common patterns of recursion in a clean, bug-tested way
02:04:21 <jle`> zasi: so foldr and foldl' are tools we can use to make our code cleaner and more bug-free; they aren't things we have to use because they are imposed on us
02:04:24 <Boomerang> I didn't know about `:set +m`, this is great jle` :D
02:04:32 <jle`> Boomerang: yeah, set it in ~/.ghci :)
02:05:09 <jle`> zasi: you can trust me when i say that after seeing it many times, it's much more easy to immediately read than explicit recursion. and as a writer, it's much less easy to mess things up
02:05:54 <jle`> remember with explicit recursion, you have to inspect and see how and when the recursion is going, and where it's going to, etc.
02:06:04 <jle`> if you're unfamiliar with foldr and foldl, then it might feel the same way.
02:06:20 <jle`> but after using and reading them many times, you internalize the "control flow" that they offer.  this benefit only comes from familiarity
02:06:27 <Boomerang> Well another advantage of foldl and foldr is that they work on other Foldable structures than lists :)
02:07:12 <jle`> the benefit of safer writing, though, comes even if you aren't familiar :)
02:44:18 * hackage gray-extended 1.5.3 - Gray encoding schemes  http://hackage.haskell.org/package/gray-extended-1.5.3 (AmyDeBuitleir)
03:19:34 * hackage minimorph 0.2.1.0 - English spelling functions with an emphasis on simplicity.  http://hackage.haskell.org/package/minimorph-0.2.1.0 (MikolajKonarski)
04:17:15 <trcc> I am going through a HashMap looking for a particular value and changing it. (Not key, value) Currently I am doing it with map: HM.map updateValWithValRef myMap where updateValWithValRef x = if V.vRef x == valRef then x {V.val = valVal} else x. This seems plain wrong. I could of course manually step through the map, but this also seems a bit wrong. The reason why I cannot look up the value based on key is, that 2 different parties are using it in t
04:17:15 <trcc> wo different ways. One is using a "name" and the other is using a "valueReference", which is stored within the value.
04:18:45 <lyxia> use two maps?
04:19:01 <trcc> where one maps valref to name>
04:19:17 <trcc> would probably be faster in the long run
04:27:16 --- mode: glguy set +v Ndrew
04:29:17 <Boomerang> I started thinking about an abstraction you could build around using multiple keys. Turns out it already exists! https://hackage.haskell.org/package/data-map-multikey-0.0.1.2/docs/Data-Map-MultiKey.html :D
04:30:08 <Boomerang> Last update in 2015 though, hopefully it still works with recent versions of container
04:31:18 <Solonarv_> ew, runtime type errors :/
04:31:19 <Boomerang> Or even older you have multimap: https://hackage.haskell.org/package/multimap-1.2.1
04:31:49 <trcc> ah cool, thanks
04:33:39 <Boomerang> ixset looks pretty good too: https://hackage.haskell.org/package/ixset-1.1.1/docs/Data-IxSet.html
04:36:06 <Boomerang> And ixset-typed is the safer option of Solonarv_ :D
04:36:22 <Boomerang> *for
04:38:48 <trcc> hmm I think a double map is more simple
04:38:54 <trcc> I only have to look up one particular value
04:39:11 <trcc> and I can just create the lookup hashmap initially
04:41:05 <Taneb> Boomerang: if I remember correctly, ixset is pretty... overkill
04:41:44 <Taneb> Although I haven't looked at it since 2012 or os
04:44:03 <Boomerang> Taneb: I didn't know about it until just now, I was just wondering if there was a good abstraction for this problem and then I found many packages. ^^
04:48:14 * Solonarv_ . o O ( "there is always a relevant xkcd")
04:51:23 <hpc> by induction, the first xkcd comic is infinitely relevant
04:52:09 <merijn> Honestly, I think by now xkcd has lost "the funny", I think SMBC is a much better spiritaul successor to xkcd of yore
04:56:29 <hodapp> yeahhhhh, xkcd stopped being funny like 9 years ago
04:57:45 <merijn> smbc isn't always as nerdy as xkcd, but it can geek out just as hard if not harder and has remained consistently funny. Although that's a discussion more suited to -offtopic ;)
04:58:38 <Superhanz> Okay I'm currently thinking of writing an auxillary funciton for a problem I have, but I'm just checking there isn't some higher order way I could do this
04:58:55 <Superhanz> I have a funciton called chooseRoute :: Board -> Route
04:59:14 <Superhanz> and another funciton subChooseRoute :: Board -> Maybe Route
04:59:36 <Superhanz> where Route is a synonym for [Board]
04:59:58 <Superhanz> how would I get chooseRoute to repeatedly run subChooseRoute, and append the Routes returned until Nothing is returned?
05:01:00 <Superhanz> where subChooseRoute is initially given the board chooseRoute is given, and then the next time it is run it is given the last element from the returned Route
05:01:04 <Superhanz> and so forth
05:01:56 <Superhanz> I can't really given the code for subChooseRoute since it is for an assignment and I can't share code
05:02:13 <coldpress> did you mean Board is a synonym for [Route]?
05:02:40 <Superhanz> nope Route = [Board]
05:02:44 <Superhanz> this is a game of Solitaire
05:03:03 <Superhanz> and Route is a sequence of boards that are 1 move apart
05:03:44 <merijn> Superhanz: Sounds like something based on scanl/scanlr
05:03:58 <merijn> or, not, I mean unfold, I think
05:03:59 <merijn> :t unfoldl
05:04:01 <lambdabot> error:
05:04:01 <lambdabot>     • Variable not in scope: unfoldl
05:04:01 <lambdabot>     • Perhaps you meant one of these:
05:04:08 <merijn> :t unfold 
05:04:09 <lambdabot> error:
05:04:09 <lambdabot>     • Variable not in scope: unfold
05:04:09 <lambdabot>     • Perhaps you meant one of these:
05:04:25 <Superhanz> what does unfold do?
05:04:48 <quchen> :t unfoldr
05:04:48 <Superhanz> I've come across fold pattern
05:04:49 <merijn> :t unfoldr -- 3 time's the charm
05:04:50 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
05:04:51 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
05:05:11 <Superhanz> yes that does look like appropriate for me
05:05:12 <Superhanz> thanks
05:05:25 <merijn> Superhanz: Fold's collapse a list into a value, unfoldr conversely unfolds a value into a list :)
05:05:37 <Superhanz> that is perfect
05:05:45 <Superhanz> lol I was going to make a long ass auxillary function
05:06:26 <merijn> Superhanz: You probably need a small wrapper to wrangle the tuple result into what you have, but that should be little effort
05:06:55 <Superhanz> what is a wrapper?
05:07:44 <merijn> Superhanz: You have "Board -> Maybe Route", but unfoldr wants "b -> Maybe (a, b)" so you need a small functio to "wrap" subChooseRoute to have the right type
05:07:57 --- mode: glguy set +v bender_
05:08:29 <Superhanz> ah so it basically will just make subChooseRouteWrapper :: Board -> Maybe(Route, Route)
05:08:33 <Superhanz> where the Route is the same
05:09:20 <merijn> For example
05:09:26 <Boomerang> No I think it's `Board -> Maybe (Route, Board)` where the returned Board is the last Route (from your description) :)
05:09:45 <Superhanz> I actually am appending the routes returned by subChooseRoute
05:09:59 <Superhanz> probably would be Board -> Maybe (Route, Board)
05:10:08 <Boomerang> You can append all the lists afterwards with concat!
05:10:52 <Superhanz> is I get a list [Route, Route, Route, Route
05:10:59 <Superhanz> *[Route, Route, Route, Route]
05:11:05 <Superhanz> how would I make these into one list?
05:11:13 <Boomerang> :t concat
05:11:14 <lambdabot> Foldable t => t [a] -> [a]
05:11:18 <Superhanz> sweet thanks
05:11:34 <Boomerang> > concat [ [1,2,3], [4,5,6] ]
05:11:36 <lambdabot>  [1,2,3,4,5,6]
05:11:49 <Superhanz> omg Boomerang I literally typed the exact same thing into my ghci terminal
05:11:52 <Superhanz> like letter for letter
05:12:02 <Superhanz> no quite literally letter for letter
05:12:04 <Superhanz> spooky
05:12:05 <hpc> lol
05:12:12 <hpc> @quote stereo
05:12:12 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
05:12:20 <Boomerang> I'm so predictible... ^^
05:12:23 <hpc> aw, wrong quote
05:14:31 <quchen> Lambdabot has lost so many great quotes
05:14:38 <quchen> Jafet has but a single one left!
05:14:43 <merijn> quchen: That quote is still there, you just need to find it
05:14:46 <merijn> @quote stereo
05:14:47 <lambdabot> xplat says: Welcome to #haskell-blah, where your bot commands are executed in triumphant stereo!
05:15:03 <merijn> quchen: You just need to find a unique part of the quote
05:15:06 <merijn> and/or user
05:15:12 <merijn> @quote stereo
05:15:12 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
05:15:19 <quchen> merijn: Nope – I tried it many times
05:15:26 <merijn> Because stereo is obviously to ambiguous :p
05:15:29 <quchen> The acrostic one is also lost I think
05:15:36 <hpc> @quote fugue
05:15:36 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
05:15:36 <merijn> @quote acrostic
05:15:36 <lambdabot> No quotes match. Wrong!  You cheating scum!
05:15:39 <quchen> ?quote socratic
05:15:39 <lambdabot> chrisdone says: It's actually impossible to employ the socratic method in here. Ask a newbie a question and it *will* be answered by someone else.
05:16:13 <CodeKiwi> what's the socratic method?
05:16:16 <Boomerang> Do you have to explicitely add quotes or is it anything a user said?
05:16:22 <merijn> CodeKiwi: Teaching via leading questions
05:16:29 <merijn> Boomerang: You need to explicitly add them
05:16:44 <CodeKiwi> when do you drink hemlock
05:16:47 <merijn> Or let others add them, if you're not a narcissist :p
05:16:51 <merijn> @quote merijn
05:16:51 <lambdabot> merijn says: This code would be trivial in Haskell :\
05:16:59 <merijn> ^ Still true
05:17:14 <Boomerang> Does it remove quotes that start with @quote?
05:17:25 <merijn> Boomerang: Probably
05:17:57 <merijn> @quote merijn Edward
05:17:57 <lambdabot> merijn says: after a week you can delete 80% of your code and replace it with whatever edwardk wrote that day ;-)
05:18:02 <merijn> dammit, wrong one
05:18:22 <merijn> Apparently I say lots of quotable things about edwardk...
05:18:52 <Putonlalla> @quote Tuplanolla
05:18:52 <lambdabot> No quotes match. Do you think like you type?
05:19:00 <Putonlalla> Very good.
05:19:14 <Superhanz> the sheer ugliness of my wrapper just totally cancels out all elegance I get from using unfoldr
05:19:18 <Superhanz> https://pastebin.com/9dHJaAB3
05:19:26 <merijn> quchen: I have a (curated) version of the database from years ago, but I trashed *a lot* of quotes I didn't find funny :p
05:19:47 <merijn> Doesn't contain anything with "acrostic" either
05:19:54 <dminuoso> Okay interesting, so `Free []` gives me a tree for free!
05:20:25 <quchen> merijn: Is it online?
05:20:39 <quchen> merijn: KMC and Jafet usually deliver
05:21:01 <infinisil> Superhanz: That compiles?
05:21:01 <merijn> No, just my personal quotes file :p
05:21:53 <merijn> quchen: Yes, he has quite a few left :p
05:22:10 <merijn> <kmc> SYB has some pretty serious machinery inside ...as though all the scrapped boilerplate has been bolted together to make some kind of steam-powered death robot
05:22:19 <Boomerang> Superhanz: does subChooseRoute need to return a `Maybe Route`? You could use the empty list to stop unfolding
05:22:33 <Ariakenom> @quote Ariakenom
05:22:33 <lambdabot> Ariakenom says: join :: Ask (Ask x) -> Ask x
05:22:38 <Superhanz> hmm yes good idea
05:22:47 --- mode: glguy set +v default_
05:22:47 <Superhanz> what would I use instaed of unfoldr?
05:22:52 <Boomerang> Also does it need to be the last element? It would be a lot more efficient if it was the first
05:23:24 <Boomerang> I would still use unfoldr just change subChooseRoute
05:23:40 <Superhanz> it does unfortunately have to be last element
05:24:10 <Superhanz> there will only ever be like 60 or so boards in the Route though
05:24:17 <merijn> Apparently kmc is my spirit animal...
05:24:19 <Superhanz> so I don't think the inefficiency should be devestating
05:24:35 <merijn> "<kmc> I think C++ is best thought of as an esolang. It's fun to learn, fun to figure out how to do some trivial things in only 300 lines of code. Not fun to use for practical stuff."
05:27:33 <dminuoso> merijn: And its fun for https://tgceec.tumblr.com/
05:27:53 <dminuoso> C++ really does lend itself to that sort of thing.
05:28:03 <merijn> tumblr doesn't work for me because I've got cookies blocked :p
05:28:12 <merijn> And I don't feel tumbr is worth whitelisting >.>
05:28:17 <dminuoso> merijn: It's the Grand C++ Error Explosion Competition.
05:28:27 <infinisil> RIP Tumblr
05:28:34 <dminuoso> The challenge is to write a C++ program to generate the largest possible error message while terminating.
05:28:36 <merijn> dminuoso: Ah, that one
05:28:40 <merijn> dminuoso: I've seen it
05:32:57 <Ariakenom> . o O (a RNG based on c++ error messages)
05:33:03 * Ariakenom searches the web
05:34:45 <dminuoso> Ariakenom: Well you have no entropy source afaik.
05:35:05 <dminuoso> Unless you write some typechecker plugin for GCC to get access to say /dev/urandom
05:35:13 <Ariakenom> psuedo random
05:35:21 <dminuoso> Not even pseudo random, if you have 0 entropy.
05:35:27 <Ariakenom> the seed is the program
05:35:33 <dminuoso> Mmm. Interesting idea.
05:36:12 <dminuoso> Unrelatedly, lets say I want to parse a simple config file with key,value pairs - is there a small parser library to do this for me?
05:36:24 <trcc> Boomerang: the multimap you suggested has not been updated since 2013, is that fine in context of Haskell or do packages seem to get bad over time due to other changes?
05:36:32 <trcc> http://hackage.haskell.org/package/multimap
05:36:52 <dminuoso> Well strictly speaking it's subtly more complicated. So something akin to .ini files or a minimalistic subset of json would be fine.
05:38:15 <Boomerang> trcc: It only depends on base and containers which have a fairly stable API. I would give multimap a shot, but it is getting a bit old
05:38:22 <Superhanz> if I have something like (2**8) + 3 + (2**8)
05:38:28 <Superhanz> how many times is 2**8 evaluated?
05:38:38 <Superhanz> like is Haskell smart enough to just evaluate this once?
05:38:46 <opqdonut> no
05:38:46 <trcc> Boomerang: ok thank you. I like it more than the multikey, as multikey seems to have runtime type errors, as Solonarv_ mentioned
05:39:01 <opqdonut> Superhanz: this is called Common Subexpression Elimination, and it can cause problems as well as solve them
05:39:11 <opqdonut> Superhanz: so haskell doesn't do it automatically, use a let if you want to compute it just once
05:39:20 <Superhanz> hmm okay thanks
05:39:48 <dminuoso> opqdonut: that's not true entirely though, is it?
05:39:50 <opqdonut> hmm the wiki claims GHC does do CSE in some limited cases, https://wiki.haskell.org/GHC_optimisations#Common_subexpression_elimination
05:39:54 <opqdonut> so I might be wrong
05:40:08 <tdammers> it does, but it's super conservative about it
05:40:27 <dminuoso> opqdonut: One of the primary reasons why accursedUnutterablePerformIO is so notoriously dangerous is *exactly* because of CSE happening in GHC.
05:40:29 <tdammers> the general idea with GHC optimizations is that if we can't be reasonably sure that it will actually improve things, we won't do it
05:40:38 <Boomerang> trcc: I might have read too fast, it might do the opposite (multiple values for 1 key)
05:40:48 <dminuoso> opqdonut: Because it can do CSE on say two `malloc 1024` - the effects of which I dont need to explain to you.
05:41:04 <trcc> ahh yes
05:41:05 <trcc> haha
05:41:19 <opqdonut> dminuoso: heh
05:41:23 <trcc> Boomerang: thanks again. Just spared me a lot of wondering when trying to make it work heh
05:41:46 <trcc> Guess I am back with two maps then
05:42:37 <trcc> to two maps*
05:42:57 <Ariakenom> :t 2**8
05:42:58 <lambdabot> Floating a => a
05:43:04 <Ariakenom> :t (**)
05:43:06 <lambdabot> Floating a => a -> a -> a
05:43:59 <dminuoso> Superhanz: Another issue with CSE is that it can introduce spaceleaks since it might keep thunks alive for much longer.
05:44:23 <Superhanz> better practice to just do it once then
05:44:36 <Superhanz> thanks
05:44:52 <dminuoso> Superhanz: If you use a let binding, you can reasonably expect GHC to share the expression.
05:45:07 <dminuoso> i.e. `let x = 2**8 in x + 3 + x
05:46:29 <Superhanz> yup I have come across bindings
05:46:49 <Superhanz> just wondering if it mattered, because it is a bit of pain doing local bindings if you want to make a lambda function
05:47:04 <Superhanz> I know you can do it
05:47:06 <dminuoso> Superhanz: Do you have a concrete example?
05:47:59 <Boomerang> lambda can be on multiple lines :D Also you can always refactor away the lambda into its own definition
05:48:24 <Superhanz>  Just (fullRoute, ((last fullRoute):seenRoutes, last fullRoute)
05:48:39 <Superhanz> put last fullRoute in where block
05:49:14 <Boomerang> Oh don't worry about the efficiency of last. I didn't mean to scare you off with my comment
05:49:36 <Boomerang> You're already doing last many times with your sub function on every unfold
05:49:46 <dminuoso> Superhanz: Unrelatedly, you are aware of the danger of using `last` right? :)
05:49:53 <Superhanz> no?
05:49:56 <dminuoso> :t last
05:49:58 <lambdabot> [a] -> a
05:50:00 <dminuoso> Superhanz: What happens if the list is empty?
05:50:08 <Superhanz> it returns Nothing
05:50:10 <Superhanz> this is my funciton
05:50:13 <Superhanz> it has two guards
05:50:16 <Boomerang> I was asking about the possibility of using first to steer you towards the `uncons` function :D
05:50:22 <Boomerang> :t uncons
05:50:22 <Superhanz> first guard is null route
05:50:23 <lambdabot> [a] -> Maybe (a, [a])
05:50:37 <dminuoso> Superhanz: Ah fair enough, in that case it's fine.
05:50:40 <Superhanz> what is uncons?
05:50:49 <Boomerang> Which is a safer head that's appropriate to use with your unfoldr :)
05:51:02 <Superhanz> oh man I am learning too much new stuff
05:51:04 <Boomerang> > uncons [1,2,3]
05:51:07 <ab9rf> one of the thins that really drew me to haskell was the ease with which one can create bindings
05:51:07 <lambdabot>  Just (1,[2,3])
05:51:14 <Superhanz> that is pretty cool
05:51:14 <Boomerang> > uncons []
05:51:17 <lambdabot>  Nothing
05:51:19 <Superhanz> that is good
05:51:24 <dminuoso> ab9rf: One thing that kept me at haskell was the ease with which one can create ADTs.
05:51:37 <Superhanz> I'm sure you could write my code in half the number of lines
05:51:46 <dminuoso> It's so much easier and sane to quickly create a datatype on the spot to express some information rather than by contract.
05:51:50 <Superhanz> guess that is why it is worth hanging out in an irc
05:51:51 <ab9rf> Superhanz: terseness is not necessarily a virtue
05:51:56 <maerwald> dminuoso: rust has it too :)
05:51:58 <Boomerang> That wouldn't be fun! You have to figure it out! :D
05:52:04 <dminuoso> maerwald: It's more noisy in Rust though.
05:52:06 <Superhanz> terseness is good if it is equally understandable
05:52:13 <dminuoso> but yeah.
05:52:24 <maerwald> dminuoso: everything is more noise, since it's a low-level language :P
05:52:57 <dminuoso> Superhanz: Here's something that many developers tend to ignore or forget:
05:53:05 <maerwald> But, as long as it's not macro heavy code, I find it easier to read than haskell
05:53:08 <dminuoso> Superhanz: Imagine you write some complex program and then after 2 years of not looking at it you need to fix a bug.
05:53:18 <dminuoso> Now you are forced to understand terse and dense code.
05:53:56 <Superhanz> true
05:53:59 <dminuoso> Superhanz: The bottleneck when writing code is not code size or typing speed.
05:54:09 <dminuoso> So writing a bit more code has negligable costs, but large benefits.
05:54:46 <dminuoso> Writing more compact code requires more time because you need to spend time in making it compact and spend time in deciphering it.
05:54:54 <maerwald> dminuoso: what?! Now you are arguing against all that pretty golfing people do in haskell :D
05:55:04 <Superhanz> it is good if it is compact, and also intuitive
05:55:37 <dminuoso> Superhanz: Which is easily obtained by creating many small bindings.
05:55:45 <dminuoso> Creating many small compact code regions that are all easily understandable.
05:55:48 <Ariakenom> "So writing a bit more code has negligable costs, but large benefits." Why would you say that, a simpler solution is often shorter.
05:56:01 <maerwald> Ariakenom: why do you think that?
05:56:13 <Superhanz> oh you are referring to me not wanting to make a binding
05:56:22 <dminuoso> Ariakenom: Im not arguing to write more code intentional - Im just arguing to not focus too much on writing "less lines of code"
05:56:25 <Superhanz> in my defense this was just because it is lambda function
05:56:35 <Superhanz> i make a lot of small bindings when writing normal functions
05:58:56 <Boomerang> Superhanz: It doesn't need to be a lambda :) You can write a serarate function and then use that
05:59:29 <Superhanz> need to write all my code in one massive function that is good style right
05:59:36 <Superhanz> 1 massive bowl of spagetti
05:59:58 <Superhanz> and function is just one line, which is made out of 1 million tiny lambda functions
06:00:15 <Superhanz> and each variable is just one letter long
06:00:38 <maerwald> dminuoso: I think the argument gets a little bit more controversial if we talk about simple vs complex types
06:00:58 <Boomerang> If you're going for terseness no variable is even better than 1 char long ^^
06:01:20 <Superhanz> oh yeah absolutely no variables
06:01:30 <Superhanz> and no white space
06:03:02 <Ariakenom> maerwald: ex some advent solution a couple of days ago. there was a first brute force solution with a recursive function, long and many details to keep track of. Then a foldr solution using some structure of the problem, shorter and fewer things involved.
06:03:19 <dminuoso> Mmm, is there a trivial solution to take some `Free [] String`, and turn all leafs `Pure (Pure ... (Free [] "blah")) ` into `Pure "blah"`?
06:03:32 <maerwald> Ariakenom: that is kind of vague
06:03:37 <Boomerang> @pl (\a b c d e -> d (e a) (c (b, a))) -- Superhanz :D
06:03:37 <lambdabot> ap ((.) . (.) . flip . (flip .) . flip (.) . flip id) ((flip id .) . flip (,))
06:03:52 <Boomerang> Too much whitespace
06:04:03 <dminuoso> Err ops, I made a little mistake there, let me fix that:
06:05:28 <dminuoso> I meant, to turn any deeply nested: Free [Free [Pure "blah"]] into just `Pure "blah"`
06:12:04 * hackage fswatch 0.1.0.6 - File System watching tool with cli and slave functionalities.  http://hackage.haskell.org/package/fswatch-0.1.0.6 (kelemzol)
06:17:33 <xsperry> is there a round half away from zero function in base?
06:18:46 <merijn> xsperry: I don't think so?
06:19:51 <merijn> xsperry: You can just check "<0" and pick a rounding that way (although that's not ideal)
06:21:34 <xsperry> that is what I planned on doing. any issue with that that I'm not aware of?
06:23:15 <merijn> Not that I can think off
06:24:31 <xsperry> https://pastebin.com/9s96tnME
06:25:53 --- mode: glguy set +v Flyers
06:26:52 <lortabac> hello, I have a question about time zones. Is there a way to abstract over summer/winter time and treat them as if they were a single time zone? I did not find how to do it with Data.Time
06:27:33 <merijn> lortabac: By using location
06:27:58 <merijn> lortabac: Also, why do you want to do this?
06:28:52 <lortabac> I have some dates in CET, I need to convert back and forth from UTC
06:29:12 <merijn> Dates in the future?
06:29:25 <lortabac> I need some way to express that these dates are in Paris time, CET or CEST
06:29:35 <lortabac> in the past and in the future
06:29:42 <merijn> lortabac: Right, so store "Paris time" instead of CET/CEST
06:29:51 <merijn> Future dates cannot be safely converted to UTC
06:30:04 <merijn> Only dates in the past can be converted to UTC safely
06:30:09 <lortabac> merijn: How do I express that notion of "Paris time"?
06:30:41 <merijn> lortabac: That's a good question :)
06:30:54 <lortabac> I am ok with only converting past dates
06:31:12 <merijn> The normally (slightly) academic issue with future dates and UTC is going to be very real soon for CET/CEST
06:31:40 <merijn> Since there are plans to eliminate DST in Europe, the UTC meaning of CET/CEST may change in the near future
06:32:12 <merijn> So the UTC date/time of future CET/CEST times may shift
06:32:36 <Boomerang> The worst bit is every country gets to decide which one of winter or summer time they keep ^^
06:32:54 <merijn> Boomerang: In theory, yes. In reality it's being coordinated
06:32:55 <lortabac> haha, it's going to get complicated
06:33:44 <lortabac> merijn: so, is there a way to convert past dates from "Paris time" to UTC?
06:34:18 <lortabac> without having to choose CET or CEST manually
06:35:23 <merijn> lortabac: It looks like the IANA timezone database has a builtin definition of locations, afaict
06:35:51 <Ariakenom> the time library does not provide that feature if I recall correctly
06:35:56 <Ariakenom> "TimeZone for a time zone offset (not actually the time zone itself) like -0700"
06:36:01 <Ariakenom> https://hackage.haskell.org/package/time-1.9.2/docs/Data-Time.html
06:36:24 <Ariakenom> where "time zone itself" would be paris
06:36:25 <merijn> lortabac: See also: https://stackoverflow.com/tags/timezone/info
06:37:37 <bollu> How does one get across the overloading of `let` in GHCi to beginners?
06:38:48 <merijn> bollu: My approach is to discourage the use of ghci for writing bindings in general and the use of "let" inside it in specific :p
06:40:05 <bollu> merijn I see
06:40:21 <bollu> merijn Can we have an RFC to call the let in GHCi a define or some such? :P or has that ship sailed?
06:40:28 <merijn> I'm also not convinced the move to make "ghci more like source files" was a good one
06:40:49 <merijn> At least in the past ghci was very obviously *not* regular Haskell
06:41:04 <xsperry> what does `overloading of let' mean? the fact that you don't need `in'? or that you can "reassign" prior variable names?
06:41:29 <lortabac> bollu: AFAIK let is not required anymore in GHCI
06:41:43 <xsperry> both are consistent with let use in do a block
06:41:49 <xsperry> s/do a/a do/
06:42:16 <lortabac> so beginners don't even need to know about that particular use of let in GHCI
06:42:19 <bollu> oh, interesting
06:42:23 <bollu> cool!
06:44:47 <lortabac> merijn, Ariakenom: I found the timezone-olson package to parse IANA timezone files
06:45:02 <lortabac> it looks a bit complex, but it seems to be what I was looking for
06:45:18 <merijn> lortabac: Timezone packages that don't look complex are lying to you ;)
06:45:44 <lortabac> :)
06:47:38 <xsperry> don't suppose there's a function that can "pretty-print" floating numbers? with user defined and/or locale specific characters used for decimal and thousands separators
06:47:57 <Ariakenom> lortabac: ah nice
06:48:02 <Athas> Has anyone said anything about when Stackage nightly will switch to the newest GHC?
06:48:33 <merijn> xsperry: There is, in base even
06:48:44 <merijn> :t showFFloat -- I think?
06:48:46 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
06:49:03 <merijn> Althought that's not locale sensitive
06:51:57 <Boomerang> > showFFloat (Just 3) pi ""
06:51:59 <lambdabot>  "3.142"
06:52:09 <xsperry> why do all those functions return ShowS? String -> String
06:52:30 <merijn> xsperry: More efficient when composing a lot
06:52:37 <Boomerang> > showFFloat (Just 3) pi "Hello :D"
06:52:40 <lambdabot>  "3.142Hello :D"
06:52:46 <merijn> xsperry: It's basically a DList for String
06:52:48 <merijn> xsperry: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
06:53:04 <xsperry> Boomerang, yes. there are many related functions in Numeric, but I don't see one where I can specify decimal character?
06:53:22 <xsperry> > showFFloat (Just 3) 1000000 ""
06:53:25 <lambdabot>  "1000000.000"
06:53:39 <Superhanz> is there a way I can output an IO String in trace?
06:53:42 <xsperry> or a thousands separator
06:53:42 <Superhanz> from a pure function
06:55:19 <Boomerang> > showEFloat (Just 3) 1000000 ""
06:55:22 <lambdabot>  "1.000e6"
06:55:34 <Boomerang> Or did you have something else in mind?
06:56:08 <quchen> Superhanz: Just write your own trace function.
06:56:27 --- mode: glguy set +v Chorhizo
06:56:34 <quchen> trace x = unsafePerformIO $ do { print "hello" >> pure x }
06:56:36 <quchen> Something along those lines
06:56:49 <xsperry> Boomerang 1000000 => "1.000.000,00" or "1,000,000.00", ideally depending on locale, less ideally, by allowing me to pass characters myself
06:57:00 <Chorhizo> I'm using mainly Data.Vector instead of arrays for something, and kind of losing my mind with imports lol.
06:57:11 <merijn> Chorhizo: How so?
06:57:13 <Superhanz> hmm okay that sounds simple enough
06:57:15 <Superhanz> thanks quchen
06:57:29 <Chorhizo> pressed enter early, woops. Basically, is there a way most people structure their qualified imports so that V.* isn't everywhere?
06:57:44 <Chorhizo> (for import qualified Data.Vector as V)
06:57:46 <Boomerang> xsperry: Depending on locale is going to get tricky, there are some locales that don't group in 3
06:57:52 <merijn> Chorhizo: tbh, I just write "V." everywhere, much easier for readers to see what's going on
06:57:53 <quchen> We put V.* everywhere. That’s the solution. :-)
06:58:15 <Chorhizo> ah, thanks! Thought there'd be some standard people follow and I guess that's it
06:58:19 <quchen> Chorhizo: import Data.Vector (Vector); import qualified Data.Vector as V -- this way you get the Vector type unqualified, and the functions qualified.
06:58:34 <Chorhizo> oh that's much nicer, thanks
06:58:38 <Chorhizo> for infix functions e.g. (!)
06:58:53 <Chorhizo> V.! is horrible, is there a way around it or is that just how it is
06:58:57 <quchen> V.! is ugly to read, yes, but luckily we don’t use it much
06:59:05 <infinisil> import Data.Vector (Vector, (!))
06:59:07 <merijn> Chorhizo: You can add an explicit import for (!)
06:59:12 <Chorhizo> but isn't that why we use vectors, for O(1) access? 
06:59:24 <Chorhizo> yeah I guess I'll do that since it's a small program 
06:59:26 <merijn> I usually use V.! if I only use it once or twice
06:59:40 <merijn> If I use (!) a lot, I might explicitly import it
06:59:47 <Chorhizo> is there a way to make it infix like that? I'd assume you can't do `(V.!)`
06:59:59 <quchen> Chorhizo: Many times you don’t want random access – map and zip go a long way for doing things you need indexing in other languages for
07:00:00 <merijn> Chorhizo: V.! is infix
07:00:07 <Chorhizo> oh what
07:00:19 <merijn> Chorhizo: Operators are still operators even when qualified :p
07:00:35 <Chorhizo> merijn: well that makes sense, I just need space for it right
07:00:41 <Chorhizo> so I cant do xV.!y
07:00:45 <Chorhizo> it's x V.! y
07:00:49 <merijn> right
07:00:59 <Chorhizo> cool, thanks a lot guys.
07:01:02 <iqubic> Why is it so darn hard to get Dante wowking for Emacs?
07:01:16 <merijn> iqubic: Because you're stuck in Purgatory? :)
07:01:43 <xsperry> Boomerang, right. but, from what I see, no functions in that package group in 3, or in any other number, and there's no way to specify decimal separator character either. is that correct?
07:01:48 <quchen> Hah, and I was already preparing a funny (haha get it?) joke as well, merijn 
07:02:10 <iqubic> merijn: What does that mean? Is it a reference to Dante's Inferno?
07:02:36 <iqubic> I want some actual help here.
07:02:37 <merijn> iqubic: That was a not particularly helpful joke about Dante's Inferno, yes :)
07:03:06 <merijn> I don't know dante or emacs, so that's all the contribution I have >.>
07:03:13 <iqubic> Ah. I see.
07:05:34 <dminuoso> iqubic: For a working editor integration use the well supported and tested "terminal" integration. 
07:05:41 <dminuoso> That is, fire up an extra terminal and run ghcid.
07:06:13 --- mode: glguy set +v jhaj
07:06:20 <maerwald> does ghcid work properly with cabal new-?
07:06:28 <merijn> dminuoso: That's not really a solution, tbh
07:06:39 <merijn> maerwald: It works somewhat, yes. But it's not ideal
07:07:34 <Solonarv_> it doesn't work all that well when you have multiple internal libraries
07:07:40 <Solonarv_> but that's on cabal, not ghcid
07:07:55 <Solonarv_> (cabal new-repl can only load one component at a time)
07:08:07 <merijn> I've been work on something more robust on top of ghcid, but that's not going to get any extra attention until February at the earliest
07:08:29 <iqubic> So I have like no idea how to get Dante working, and I have to go now. I'll figure this out later.
07:08:37 <merijn> Basically, it's a caching daemon that builds on top of new-repl and ghcid to figure out which component a module belongs to and loading that
07:09:09 <merijn> But I was sorta hoping someone else would fix ghc-mod or HIE before I have time to actually work on it again :p
07:09:10 <Boomerang> xsperry: I think the formatting library might help (I've never used it before): https://hackage.haskell.org/package/formatting-6.3.6/docs/Formatting-Formatters.html#v:commas
07:10:34 <Boomerang> Actually that function is only for Integral :/
07:11:01 <merijn> Be lazy and FFI call out to C's locale formatting xD
07:12:29 --- mode: glguy set -v jhaj
07:12:42 <xsperry> standard C can actually do this? or is it POSIX?
07:12:55 <xsperry> Boomerang, I'll check it out
07:15:33 <dminuoso> Let's say I have some prism, is there a way to modify what `preview` will see if the target exists if I cant make an Iso?
07:21:48 <Solonarv_> my understanding says that any getter will do, assuming you only intend to 'preview' with the resulting optic
07:26:15 <c50a326> hey can I write a "hello, world" program or an echo server program (something super simple), using IO only as a Functor or Applicative, not as a monad?
07:27:05 <merijn> Define "as a monad"
07:27:09 <c_wraith> c50a326, hello world doesn't need IO to have any instances.
07:27:11 <c50a326> I mean is it possible to write programs in haskell that do IO without using `>>=` etc
07:27:15 <Solonarv_> a simple "hello world" program is just one line: main = putStrLn "hello, world"
07:27:21 <c_wraith> an echo server requires the Monad instance
07:28:01 <Solonarv_> You don't need functor/applicative/monad &co to make IO actions happen, you need them to compose IO actions
07:28:15 <merijn> Solonarv_: Well, not even for that
07:28:35 <c_wraith> if you don't import ghc internals you do. :P
07:28:49 <c50a326> I mean can you write an echo server just using <$> and <*>, and not using do notation and >>= or anything from Monad?
07:29:09 <c50a326> can you compose IO actions with <$> and <*>?
07:29:30 <Solonarv_> Yes, but you that form of composition is more limited
07:29:32 <ab9rf> pretty sure you need monadic bind for an echo server
07:29:34 <tdammers> every Monad is an Applicative, so yes
07:30:08 <merijn> c50a326: the "monad" part is not what let's us do IO, it just happens that "the way we do IO" can be conveniently captured by the monad interface
07:30:12 <tdammers> but you can't capture the full expressive power of Monad, only that of Applicativ
07:30:17 <Solonarv_> >>= for IO allows you to decide which IO actions to perform based on the result of previous IO actions
07:31:01 <merijn> The implementation of >>= for IO could exist without the Monad class existing and Haskell would work exactly like it does now
07:31:42 <merijn> So the entire Monad bit in this question is a red herring
07:32:57 <tdammers> main = putStrLn "Hello, world!" -- there, I used absolutely no instances of IO there, not even Functor
07:33:56 <c50a326> Solonarv_ did that above :p
07:34:15 <c50a326> is it possible to write an example of something cool with IO that only uses <$> and <*> ?
07:34:27 <ab9rf> you need to define "something cool"
07:34:37 <c50a326> not `main = putStrLn "hello, world!"`, basically :P
07:34:44 <c50a326> anything of more than like 2 IO actions
07:35:22 <ab9rf> well, you can't do anything that requires examinin the result of a prior IO action
07:35:38 <Solonarv_> main = for_ [1..10] \i -> putStrLn ("iteration " <> show i) -- does this count? 
07:35:49 <ab9rf> but you can draw pretty pictures
07:36:06 <Solonarv_> (this uses *> internally, which is from Applicative)
07:36:08 <ab9rf> output the results of pretty much any pure calculation
07:36:21 <c50a326> oh cool, this works: main = getLine *> getLine *> putStrLn "Hi"
07:36:29 <Boomerang> interact -- done we have an echo server ^^
07:36:36 <ab9rf> Boomerang: haha
07:36:52 <Boomerang> *id
07:37:04 <Solonarv_> Indeed it does, you just can't use the result of those 'getLine's to decide what to do next
07:37:32 <c50a326> is there not a hacky way of using <$> and <*> in tandem and writing the program backwards to make it work?
07:37:33 <ab9rf> you can read input, but you can't do anything with what you read
07:37:43 <ab9rf> for that you need bind
07:37:53 <c50a326> ah okay
07:38:15 <merijn> ab9rf: You can do lots with what you read!
07:38:24 <merijn> ab9rf: *what* you do just can't depend on the value of what you read
07:38:28 <ab9rf> merijn: heh
07:38:50 <tdammers> let str = unsafePerformIO getLine in putStrLn str
07:38:53 * tdammers runs away
07:39:05 <ab9rf> BAD
07:39:05 <DigitalKiwi> bad naughty tdammers
07:39:39 <ab9rf> c50a326: there's the "hacky way" you wnted
07:40:33 <c50a326> the thing is, I'm just reading about this validation applicative, which collects its errors along the way
07:41:05 <c50a326> so I'm just wondering if that's possible then howcome above isn't possible... but I guess I'll figure that out soon, just need to study this validation applicative and its types
07:42:43 <c_wraith> c50a326, it's exactly because it validates things locally. that is, whether something is valid cannot depend on it a previous thing was valid.
07:43:02 <c_wraith> *If a previous..
07:43:05 <c50a326> ah yeah true!
07:43:33 <c_wraith> so it explicitly forbids the one thing monad allows that Applicative doesn't.
07:43:37 <Boomerang> It also doesn't deal with IO errors, you need explicit errors
07:46:41 <fendor> I couldnt find a platform indenpendent way to strip the end of `String`s from whitespace and newlines, is there some builtin? Or do I have to use `Text`?
07:48:05 * hackage grid 7.8.11 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.8.11 (AmyDeBuitleir)
07:48:34 <tdammers> > dropWhileEnd isSpace "Hello    "
07:48:37 <lambdabot>  "Hello"
07:48:42 <tdammers> fendor: ^
07:49:14 <tdammers> dropWhileEnd is in Data.List, isSpace is in Data.Char. Both are in base.
07:50:12 <fendor> > dropWhileEnd isSeparator "Hello  \n  "
07:50:15 <lambdabot>  "Hello  \n"
07:50:32 <fendor> i suppose, i did that wrong
07:52:25 <fendor> > dropWhileEnd isSpace "Hello  \n  "
07:52:27 <lambdabot>  "Hello"
07:52:28 <tdammers> > dropWhileEnd isSpace "Hello    \n    "
07:52:31 <lambdabot>  "Hello"
07:52:36 <tdammers> right
07:52:38 <tdammers> yeah
07:52:42 <fendor> i really should read the documentation
07:52:45 <tdammers> newlines are whitespace too
07:52:52 <fendor> thank you very much!
07:52:54 <tdammers> np
07:58:30 <LysergicDreams> window move up
08:02:07 * hackage som 10.1.7 - Self-Organising Maps  http://hackage.haskell.org/package/som-10.1.7 (AmyDeBuitleir)
08:07:14 <bahamas> with cabal new-*, how can I specify a dependency found on the local file system (a patched library) ?
08:07:44 <Putonlalla> Massiv seems to be raising in popularity on Hackage. Is it already in usable shape (in comparison to Repa)?
08:07:48 <merijn> bahamas: Specify a path to it in the packages field of your cabal.project
08:08:45 <merijn> bahamas: Or one of the other packages fields (check the docs for details), because you probably don't want local only paths directly in packages :)
08:13:39 * hackage gray-extended 1.5.4 - Gray encoding schemes  http://hackage.haskell.org/package/gray-extended-1.5.4 (AmyDeBuitleir)
08:18:53 <bahamas> merijn: what do you mean by not wanting local only paths directly in packages? I did like this for now `packages: myproject.cabal, lib/lib.cabal`
08:19:50 <merijn> bahamas: What I mean is that cabal.project is a file that you would normally commit inside your repo, so you don't want things only available on your local filesystem in there as people cloning your repo might not have those
08:21:38 <bahamas> merijn: oh, yes. I'll add that library to the repo
08:21:55 <merijn> bahamas: Well, there's also a packages field that is optional, you can use that one
08:22:05 <boxscapeR> What's the lowest language that ghc translates haskell into, i.e. the language that the runtime system receives as input I suppose
08:22:21 <merijn> bahamas: (packages listed in packages *must* exist, packages listed in the other are used *if available*)
08:22:36 <merijn> boxscapeR: The runtime system doesn't receive a language as input
08:22:49 <boxscapeR> right, but it receives code encoded in some language, I phrased that poorly
08:22:55 <merijn> boxscapeR: The RTS is just a library of some primitive functionality that is linked into compiled Haskell
08:22:55 <tito_04> There's STG
08:22:59 <merijn> boxscapeR: It does not
08:23:09 <merijn> boxscapeR: The RTS is not an interpreter
08:23:12 <boxscapeR> okay
08:23:39 <merijn> The lowest level language GHC generates is just regular machine code, like any C or C++ compiler would
08:24:01 <dminuoso> Mmm, how do I discriminate an `Either Error Void`?
08:24:08 <merijn> boxscapeR: The machine code that GHC generates just contains calls to symbols in it, and those symbols are defined in the RTS library
08:24:17 <boxscapeR> okay
08:24:25 <dminuoso> Would some `Right foo -> foo` be proper for the Right case?
08:24:49 <boxscapeR> thanks merijn
08:24:49 <merijn> boxscapeR: Imagine the RTS as a library that has a "malloc", "runGC", "spawnThread", etc. symbols and the compiler just inserting those in the compiled code
08:25:00 <merijn> Because that's basically what it is
08:25:00 <boxscapeR> right, okay
08:26:32 <boxscapeR> It seems really difficult to me to translate a lambda-calculus type expression directly into assembly if it can depend on runtime input, but I guess I'll have to read some more on ghc to find out how that works
08:26:38 <merijn> Completely unrelatedly, I just fixed up and further generalised the world's most general FizzBuzz implementation: https://gist.github.com/merijn/cd0e7918a96fe913cf7d66833e8da354 :D
08:26:54 <merijn> boxscapeR: Have you read the STG paper and/or been pointed to it?
08:27:26 <boxscapeR> tito_04 pointed out STG and I found an article about it on the ghc site which seems helpful, but I have not
08:27:34 <merijn> @where stg
08:27:34 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
08:27:38 <boxscapeR> thank you
08:27:53 <merijn> boxscapeR: That paper basically covers "how do you even compile a lazy functional language to x86?!"
08:27:54 <tito_04> It's from 1992
08:28:00 <boxscapeR> ok
08:28:18 <boxscapeR> sounds like exactly what I'm looking for
08:28:19 <merijn> boxscapeR: Only requires very basic functional language knowledge and a little bit of C/asm basics would help
08:36:05 * hackage blas-ffi 0.0.2 - Auto-generated interface to Fortran BLAS  http://hackage.haskell.org/package/blas-ffi-0.0.2 (HenningThielemann)
08:45:29 <asthasr> Am I right in thinking that the run* functions (runState, runRand, runIdentity...) are the "extract" part of a comonad?
08:45:39 <kuribas> compiling to asm isn't hard.  Doing it efficiently is...
08:46:07 <merijn> asthasr: Not really, as most things with run functions aren't Comonads :p
08:46:17 <asthasr> dang
08:46:19 <kuribas> isn't extract the dual of bind?
08:46:27 <merijn> kuribas: Yes
08:46:39 <tdammers> :t extract
08:46:40 <lambdabot> error: Variable not in scope: extract
08:46:40 <merijn> oh, wait, no
08:46:44 <merijn> Dual of return
08:47:05 <kuribas> ah... But not related to extract in any case
08:47:10 <asthasr> it seemed like those run*s are basically "extracting" from a monad so I thought I'd achieved an insight
08:47:20 <tdammers> @let import Control.Comonad
08:47:21 <lambdabot>  Defined.
08:47:22 <tdammers> :t extract
08:47:24 <lambdabot> Comonad w => w a -> a
08:47:33 <tdammers> :t runIdentity
08:47:34 <lambdabot> Identity a -> a
08:47:46 <tdammers> so yes, there is some similarity
08:48:08 <merijn> asthasr: If it's any consolation I still don't really get Comonad after like a decade (admittedly I haven't tried very hard, as I've never really had a use for it)
08:49:19 <kuribas> but you also need extend for a comond
08:49:23 <asthasr> @let import Control.Random
08:49:24 <lambdabot>  .L.hs:66:1: error:
08:49:24 <lambdabot>      Could not find module ‘Control.Random’
08:49:24 <lambdabot>      Use -v to see a list of the files searched for.
08:49:24 <kuribas> :t extend
08:49:26 <lambdabot> Comonad w => (w a -> b) -> w a -> w b
08:49:30 <asthasr> @let import System.Random
08:49:33 <lambdabot>  Defined.
08:49:40 <asthasr> :t runRand
08:49:41 <lambdabot> error: Variable not in scope: runRand
08:50:11 <asthasr> fine, i'll just copy and paste. don't want to spam: RandomGen g => Rand g a -> g -> (a, g)
08:50:33 <tdammers> that's neither monadic nor comonadic though
08:50:59 <tdammers> or, well, it's actually monadic, but we're not making this explicit by actually using a Monad instance
08:51:18 <tdammers> we could wrap it in a state monad though
08:51:54 <asthasr> "Rand g" is monadic, right? then you provide g and in so doing you can extract a. (Although it's 'evalRand' that discards g)
08:52:28 <tdammers> right, yeah
08:52:36 <tdammers> Rand is essentially State g
08:53:37 <asthasr> also are there any good, readable codebases to go and look at for "real" uses of monad transformer stacks?
08:54:46 <sproingie> just about anything using mtl i'd imagine
08:55:11 <Solonarv_> mtl (or mtl-style) does not imply deep transformer stacks
08:55:52 <asthasr> alternatively -- are stacks now deprecated? (i've seen some discussion along those lines, along with advocacy of things that seem like... "fused together" monads -- RWST and the like)
08:55:59 <Solonarv_> I don't know where you'd find "deep" transformer stacks, because they're somewhat problematic to work with -- especially if you're doing IO
08:56:39 <sproingie> not so much deprecated as never well-liked in the first place, but still well-supported
08:56:56 <Solonarv_> I'd say most application code is some variant of 'ReaderT e IO', with the occasional ExceptT or additional Reader-like transformer thrown in
08:57:19 <glguy> or only uses transformers in isolation
08:57:26 <asthasr> (ReaderT e) being useful primarily for configuration, right?
08:57:40 <Solonarv_> Useful for state too, if you're already in IO anyway
08:58:00 <Solonarv_> (stick an IORef into the environment, or something similar)
08:58:14 <sproingie> the main problem with stacks is trying to support more than one of the same transformer
08:58:38 <Solonarv_> similarly, also useful for logging: stick a 'LogMessage -> IO ()' into the environment
08:58:52 <merijn> asthasr: You'll find that the consensus on monad stacks and their use varies drastically across people :p
08:59:46 <asthasr> merijn: Then it doesn't seem to fulfill the consensus laws :p
09:01:26 * sproingie ponders whether consensus is associative and other laws
09:01:49 <tdammers> I think the kind of situation where you would benefit from complex monad stacks is kind of rare
09:02:28 <Solonarv_> And also, some monad transformers exhibit surprising behavior when layered over some base monads
09:02:38 <Solonarv_> example: StateT over IO, because of exceptions
09:02:56 <Solonarv_> other example: ContT over basically anything
09:03:02 <asthasr> tdammers: The source of my question was really because I had a situation where I wanted to use some state for something I was building up, random numbers, and a "configuration" set at runtime, plus of course output.
09:03:38 <sproingie> the ordering of monad stacks is also very significant, and not terribly intuitive
09:03:53 <asthasr> tdammers: my initial attempt, something like ReaderT e Rand g State s IO, basically resulted in two hours of zero progress and only misery
09:04:02 <Solonarv_> my rule of thumb is: if the bottom of the stack is IO, use at most reader + except
09:04:28 <Solonarv_> if the bottom is Identity, I'll be more liberal.
09:04:31 <merijn> Solonarv_: LoggingT, ResourceT...
09:04:33 <tdammers> MaybeT can occasionally be useful, but you'd usually introduce that in a very ad-hoc fashion
09:04:45 <asthasr> in the end I just abandoned it, restructured it to take a config object and to build the result incrementally in one imperative-style function calling into other functions that returned Rand g a types
09:05:08 <asthasr> so ultimately I didn't even use a "stack" as such
09:05:17 <Solonarv_> ResourceT is reader-like, I don't remember how LoggingT works, MaybeT is "close enough" to except
09:05:30 <tdammers> maybe worth noting that "State(T)" isn't *exactly* state
09:05:52 <tdammers> it has slightly different semantics from, say, ReaderT (IORef a)
09:06:17 <sproingie> one can keep state with it though, regardless of whether it's in-place
09:09:20 <asthasr> anyone have any open source code that uses, say, LoggingT?
09:11:19 <lavalike> sm: I wish -T':!doctest ..' would not push "All good" out of the top of the window, then it'd be perfect (:
09:12:11 <sproingie> searching for users of monad-logger would do it.  but i forget where the reverse dependencies thing for hackage is
09:12:41 <sproingie> here we go: https://packdeps.haskellers.com/reverse/monad-logger
09:25:12 <shapr> TL;DR The Intel Core i7-8700K is 20%-30% faster than the AMD Ryzen 7 2700X at Haskell compile workloads, and performs 7%-19% better in terms of performance per Euro. - https://qbaylogic.github.io/benchmark-compilation/
09:30:10 <Superhanz> what is the best way to generate 10 pseudorandom numbers?
09:30:13 <Superhanz> in haskell
09:30:16 <Superhanz> in context of a pure funciton
09:30:57 <geekosaur> grab a seed from IO initially, and thread it through pure code via MonadRandom or StateT
09:31:17 <ski> @type runState (replicateM 10 (state random))
09:31:18 <glguy> Superhanz: You'll just need a function argument that is a random number generator
09:31:19 <lambdabot> (RandomGen s, Random a) => s -> ([a], s)
09:31:47 <Superhanz> thanks
09:31:54 <Superhanz> I'll check out RandomGen
09:32:01 <glguy> You don't need to worry about monads, MonadRandom, StateT, etc
09:32:19 <Superhanz> I don't understand monads so I probably won't jump in just yet
09:32:25 <ski> > evalState (replicateM 10 (state (randomR (0,9)))) (mkStdGen 1234)
09:32:27 <lambdabot>  [7,5,1,6,1,2,1,9,1,5]
09:32:33 <ski> you could just use
09:32:35 <ski> @type random
09:32:37 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
09:32:37 <ski> or
09:32:37 <Superhanz> thanks ski
09:32:39 <ski> @type randomR
09:32:40 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
09:32:43 <ski> directly
09:32:55 <Superhanz> :type randomR
09:32:59 <Superhanz> @type randomR
09:33:00 <ski> Superhanz : using the state monad just makes that a bit more pleasant, and less error-prone
09:33:00 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
09:33:35 <ski> `randomR (lo,hi)' is like `random', except the result will be inbetween the bounds `lo' and `hi'
09:33:39 <glguy> https://gist.github.com/glguy/d0617f43c0ef190013cd25c241b49c31
09:33:43 <glguy> Superhanz: for example
09:34:06 <ski> Superhanz : how new are you with Haskell ?
09:34:35 <ski> Superhanz : do you, more or less, understand type inference ?
09:34:41 <Superhanz> I have been doing it for a month or two now
09:35:04 <ski> Superhanz : have you seen how one can define new `data' types ? including ones that are parameterized ?
09:35:09 <Superhanz> I have heard of type inference
09:35:16 <Superhanz> data = True | False
09:35:24 <Superhanz> *boolean = True | False
09:35:33 <Superhanz> data boolean = True | False
09:35:41 <Solonarv_> the name needs to start with Uppercase as well, but you got it
09:36:03 <Superhanz> glguy: thanks, that code is perfect
09:37:13 <ski> yea, using `take' on `randoms' (or `randomRs') is similar (but probably slightly simpler) than my variant of using `replicateM' to repeat the random generation
09:37:45 <ski> `newStdGen' is how you get a fresh random generator seed, from `IO'
09:38:18 <ski> (in the example above, i used `mkStdGen', because lambdabot doesn't do I/O. please don't use `mkStdGen' in actual code)
09:39:15 <Superhanz> what is wrong with mkStdGen?
09:39:34 <asthasr> Superhanz: you want to see a thing I recently wrote?
09:39:36 <Superhanz> it is pseudorandom and doesn't change when you give it hte same seed?
09:39:38 <Superhanz> yeah sure
09:39:41 <ski> Superhanz : you will get the same sequence of "random" values, each time you run it
09:40:12 <ski> (sometimes, that's what you want. e.g. if you're trying to reproduce a (e.g. buggy) behaviour. but usually, it's not)
09:40:19 <Solonarv_> ski: if you want to do IO, use yahb instead
09:40:41 <ski> Solonarv_ : aye, i was thinking that, when i wrote it :)
09:41:09 * ski idly wonders how hard it would be to define `Show StdGen' in terms of `mkStdGen'
09:42:03 <asthasr> Superhanz: https://hastebin.com/sepulamamo.hs
09:42:13 <Solonarv_> huh? that doesn't seem possible, 'a' is in negative position in the Show methods but in positive position in mkStdGen
09:42:49 <Solonarv_> in simpler words: mkStdGen lets you create a StdGen, which doesn't help at all when your task is to *consume* a StdGen for the Show instance
09:43:06 <ski> Solonarv_ : i mean, to generate a `String' which represents a call to `mkStdGen' on some `Int'
09:43:34 <Solonarv_> oooh, you meant something like the instances for Set, Map &co?
09:43:36 <asthasr> Superhanz: Literally just learned to do random numbers as well, so this is what I landed on
09:43:47 <Superhanz> this is brute solving maths problems?
09:43:47 <ski> Solonarv_ : so, in effect, to compute a pre-inverse to `mkStdGen'. given any `g', compute `n' such that `mkStdGen n = g'
09:44:02 <ski> Superhanz : abstract data type instance, yes
09:44:07 <asthasr> Superhanz: no, it's generating them for my daughter to practice on
09:44:16 * Solonarv_ looks at the random package
09:44:19 <Superhanz> wow thats pretty cool
09:44:21 <ski> > runState (replicateM 10 (state (randomR (0,9)))) (mkStdGen 1234)  -- note that this is ugly :/
09:44:24 <lambdabot>  ([7,5,1,6,1,2,1,9,1,5],522754180 1336516156)
09:44:41 <ski> `522754180 1336516156' is a very strange-looking Haskell expression
09:45:23 <ski> @quote son.or.daughter
09:45:23 <lambdabot> Dave_Benjamin says: please talk to your son or daughter about parametric polymorphism
09:46:59 <Solonarv_> ski: should be pretty simple to do, actually.
09:47:48 <ski> Superhanz : given the type signature of `randomR', define a function that given a `(lo,hi)' bound, generates two random numbers
09:48:03 <ski> Superhanz : then, using that, define a function that generates four random numbers
09:48:49 <ski> Superhanz : those exercises would give you a better understanding of why the signature of `randomR' is like it is
09:50:12 <Superhanz> I will give that a go after this assignment 
09:50:28 <xsperry> in your experience, do newbies react better if you show them =<< instead of >>= when teaching about Monads? when they see the signature of (>>=) common intuition is that the value in "unpacked" out of the Monad, while (=<<) signature may suggest that function is `lifted` to work with Monad, ie (a -> m b) -> (m a -> m b)
09:50:31 <Superhanz> Haskell is melting my brain
09:50:48 <Superhanz> not the language but the crushing time pressue and lack of sleep to get this done in time
09:50:54 <Superhanz> well the language a bit
09:51:04 <Solonarv_> xsperry: hmm, good point! I think it may help.
09:51:17 <Solonarv_> also lines up better with ($), fmap, and (<*>)
09:52:42 <ski> @quote is.the.solution
09:52:42 <lambdabot> quicksilver says: head-explosion is the solution, not the problem.
09:52:47 <maerwald> Superhanz: haskell is slow to write
09:53:03 <maerwald> more thought about what you do
09:53:30 <Superhanz> yup and less easy to get into than a new imperative language
09:53:36 <maerwald> Yeah
09:53:40 <Superhanz> like debugging in Haskell is still excruciating for me
09:53:49 <Superhanz> I'm sure if I spent like another few months learning it it would be okay
09:54:03 <maerwald> Debugging is a general problem and one of the few things imperative languages do better
09:54:25 <Solonarv_> Yeah, Haskell's evaluation model makes debugging a bit difficult
09:54:29 <Solonarv_> @quote adhd
09:54:29 <lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
09:54:39 <Solonarv_> \o/ got the right quote!
09:54:44 <maerwald> lol
09:55:17 <Superhanz> ahahahaha
09:55:24 * ski . o O ( declarative debugging )
09:56:41 <monochrom> Declarative debugging may mean trying to prove correctness and then fail but then how it fails tells you where your code is wrong.
09:57:18 <maerwald> correctness?
09:57:30 <monochrom> Yes you heard me.
09:57:31 <maerwald> Maybe high-level
09:57:37 <maerwald> Not actual correctness :)
09:57:47 <Solonarv_> I think the concrete version of that is write small functions and test them (using property-based testing like QuickCheck)
09:57:52 <maerwald> And with debugging, you care about actual correctness
09:57:55 <monochrom> I didn't say you should always do everything declaratively.
09:58:07 <ski> (fwiw, i had something like Buddha in mind)
09:58:08 <monochrom> I only said what would declarative debugging mean.
09:58:37 <ski> @where Buddha
09:58:38 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
09:58:47 <ski> but i think that's long bit-rotted, unfortunately
09:58:55 <monochrom> But woah people do have knee-jerk overreactions to the keyword "correctness".
09:59:15 <maerwald> monochrom: looking at our tls library, you could say that
09:59:15 <ski> (perhaps we should talk about "incorrectness", instead ?)
10:00:09 <maerwald> after I just discovered half of our ecosystem is vulnerable :D
10:00:29 <maerwald> (and upstream doesn't care)
10:01:16 <bsima> https://core.ac.uk/display/24312664 buddha paper
10:02:39 <MarcelineVQ> is upstream doesn't care really an accurate description?
10:02:48 <maerwald> https://github.com/vincenthz/hs-tls/issues/117
10:03:27 <maerwald> Or rather: no one cares :P
10:03:35 <maerwald> The issue is quite old, so
10:04:24 <ski> <https://web.archive.org/web/20091122221642/http://ww2.cs.mu.oz.au:80/~bjpop/buddha/>
10:04:32 <glguy> tls is convenient as its implemented in Haskell and has no system library dependencies. For a better TLS implementation I just use openssl
10:04:48 <maerwald> "close enough" is not good enough for cryptography
10:05:20 <maerwald> The problem is you cannot easily remove it from your "stack"
10:05:24 <maerwald> transient deps etc
10:05:41 <maerwald> warp/wai/scotty whatnot depends on it indirectly afais
10:06:13 <monochrom> How to fix it?
10:07:12 <asthasr> Superhanz: I realized that I left some noise in there where I was playing around with stuff. Here is a somewhat cleaned up version: https://hastebin.com/mazekoqose.hs
10:07:21 <maerwald> Stop using a haskell implementation of TLS, because there is not enough knowledge or research about how this actually *behaves*
10:07:52 <maerwald> Algorithmic/logical correctness is not sufficient and the type system is neither
10:08:26 <maerwald> But then you have to fix a few hundred packages and switch them, lol
10:09:07 <Superhanz> asthasr, sweet
10:09:19 <Superhanz> I haven't had chance to check it out yet, got deadline in 5 hours
10:09:32 <asthasr> maerwald: That is disgusting :(
10:10:22 <maerwald> I'm not so much confused about the vulnerability, but about the attitude. If you're not taking security seriously, don't write a crypto lib.
10:10:46 <maerwald> (which is why I don't, beyond my knowledge/capacity)
10:10:54 <Superhanz> how do I cast int to float?
10:10:59 <Superhanz> tried fromIntegral on the int
10:11:04 <Superhanz> doesn't seem to work :/
10:11:51 <ski> > fromIntegral (2 :: Int) :: Float
10:11:53 <lambdabot>  2.0
10:11:57 <Solonarv_> "doesn't work" how?
10:12:26 <ski> (s/cast/coerce/)
10:12:42 <Solonarv_> 'convert' is more accurate, iMO
10:12:43 <MarcelineVQ> ​/convert
10:12:45 <MarcelineVQ> :>
10:12:51 <Superhanz> (fromIntegral $ sum listOfScores) / (fromIntegral $ length listOfScores)
10:13:02 <asthasr> maerwald: check this out -- https://github.com/plaid/link/issues/68
10:13:11 <Superhanz> no instance for Fractional Int arising from use of '/'
10:13:12 <asthasr> maerwald: similar attitude, similar environment
10:13:31 <xsperry> > let listOfScores = [1..10] in (fromIntegral $ sum listOfScores) / (fromIntegral $ length listOfScores)
10:13:33 <lambdabot>  5.5
10:13:35 <ski> what's the type of `listOfScores' ?
10:13:59 <ski> and how do you use the result of this division ?
10:14:10 <Superhanz> should be integer?
10:14:25 <Superhanz> although i tried the expression in ghci and it works fine for a list of ints i just made up
10:14:26 <ski> the result is some fractional type, not `Integer'
10:14:42 <xsperry> it seems like your are using the result of that expression in a place where you should be using Int
10:14:46 <maerwald> asthasr: "the financial sector moves a bit more slowly than other technology companies" -- unfortunately, he's right there :)
10:15:02 <Superhanz> ski: you're right I had float in type signature
10:15:06 <Superhanz> *Int
10:15:09 <Superhanz> int in type signature
10:15:15 <Superhanz> and it should have been float
10:15:20 <ski> changing that fixes the problem ?
10:15:38 <asthasr> maerwald: sure! but maybe that means "we cannot do this" rather than "we should do this in the most painfully insecure way possible" :)
10:15:50 <Superhanz> are you being sarcastic ski
10:15:57 <ski> no
10:16:05 <Superhanz> yeah it does fix problem 
10:16:08 <Superhanz> thanks for noticing that
10:16:09 <ski> just wondering if there was any more problem, or not ?
10:16:23 <Superhanz> in my defense I am very sleep deprived 
10:16:41 <Solonarv_> That is not a state conducive to learning... well, anything really
10:17:04 <monochrom> It's conducive to sleeping. >:)
10:17:28 <ski> well, i've heard people talk about the experience of programming in Haskell, while drunk, and how it differs from drunk programming in other languages (especially ones without static type checking)
10:17:48 <xsperry> Superhanz do you get the seemingly cryptic error message now? No instance for Fractional Int
10:18:16 <koz_> ski: Drunk programming Haskell sounds _hilarious_.
10:18:17 <ski> (how the type system can, to some extent, guide you away from the worst nonsense, but how that doesn't necessarily mean that the resulting code will be that useful ..)
10:18:20 <nshepperd1> maerwald: perhaps someone needs to write a drop in replacement for hs-tls that wraps openssl?
10:18:36 <DigitalKiwi> sorry if I've misunderstood but aren't the problems with the hs-tls only in one mode and if people don't use that it's not an issue or?
10:18:37 <Superhanz> I don't get any error message now
10:18:40 <Welkin> ski: programming in any language without a ML-style type system is a disaster, even without being drunk
10:19:00 <nshepperd1> At least then it's a matter of writing 100 easy patches instead of 100 difficult patches
10:19:01 <glguy> DigitalKiwi: no, that issue isn't the only problem
10:19:01 <ski> Superhanz : xsperry meant "do you understand what the error message you got previouslt means, now ?"
10:19:15 <DigitalKiwi> glguy: oh :(
10:19:15 <monochrom> That's just the difference between brownian motion in R^2 and brownian motion in [0,1]x[0,1].
10:19:42 <Superhanz> I am ashamed to say that as soon as Ski solved the bug I moved onto next thing
10:19:52 <Superhanz> didn't try and memorise the error message
10:19:54 <monochrom> Although, we actually understand well brownian motion in [0,1]x[0,1], i.e., thermodynamics, so there is that.
10:19:54 <ski> np
10:19:55 <Superhanz> should do that though
10:20:14 <maerwald> nshepperd1: Hmm. We have hopenssl, could do something on top of that maybe
10:21:12 <monochrom> And yes please don't skip over error messages.
10:22:51 <ski>   "Over the years, one of the top complaints that I have heard from people who have taken programming courses and found them very hard going is \"I could never make sense of the compiler error messages.\""
10:22:58 <ski>   "Come to think of it, one of the things that drives me up the wall is 3rd year students handing in C programs with obvious problems that the C compiler DID tell them about, but they weren't EXPECTING to understand anything the compiler said, so they didn't bother looking at what it did say or even the particular lines it was talking about"
10:24:02 <monochrom> Who wrote that? (I agree.)
10:24:40 <koz_> I would go even further - don't skip over _warnings_ either.
10:25:05 <koz_> There's nothing more disheartening to me than seeing my Gentoo compiling [established package] and I get _screenfuls_ of compiler warnings.
10:25:08 <DigitalKiwi> galaxy brain: turn warnings into errors
10:25:14 <koz_> (especially if said package was written in C)
10:25:27 <koz_> DigitalKiwi: Would it surprise you that I do _exactly_ this?
10:25:42 <DigitalKiwi> no, I do this too
10:26:26 <DigitalKiwi> it just seems like the right thing 
10:26:55 <monochrom> It is right or wrong depending on reasonableness of the warnings.
10:27:18 <geekosaur> and a compliction thereis warnings due to backward compatibility
10:27:20 <MarcelineVQ> the main issue with warnings into errors, I imagine, is that it narrows version comparability, now you need the gcc where that's not a warning
10:27:39 <DigitalKiwi> enabling all warnings and turning them into errors can be kind of bad heh
10:27:55 <DigitalKiwi> like *all* of them
10:27:59 <monochrom> Yeah -Wall contains too many religious dogmatic ones.
10:28:09 <monochrom> Even double-standard ones.
10:28:31 <Solonarv_> Haskell example: unused do binds
10:28:39 <glguy> We might need a new standard that encompasses both standards
10:28:47 <maerwald> -Wno-error to the rescue
10:28:58 <monochrom> So far the default warnings of gcc and GHC have been reasonable and I would gladly fix my code if I got one.
10:29:00 <DigitalKiwi> blah blah there's an xkcd blah
10:30:38 <koz_> Yay, Thinking With Types went open source! https://github.com/isovector/thinking-with-types
10:30:48 <geekosaur> suddenly perfectly fine code people have been using for years is anathema because community standards changed and the compiler was declared to be enforcer
10:31:43 <monochrom> Well that's the point at which I say "what's the difference between community standard and religious dogma?"
10:31:50 <ski> monochrom : "Re: Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-(09,10) at <http://lists.mercurylang.org/archives/users/2006-October/004000.html>,<http://lists.mercurylang.org/archives/users/2006-October/004011.html>
10:32:38 <monochrom> Hell, go to any church.  Any social norm among the people in that church is their community standard.
10:32:40 <geekosaur> how antisocial the community is
10:33:21 <maerwald> "Hell, go to any church"... I see what you did there
10:33:40 <monochrom> haha darn
10:33:47 * ski . o O ( "Church, go to any hell ..." )
10:34:26 <DigitalKiwi> OOP?
10:34:40 <maerwald> no swearing here
10:34:57 <DigitalKiwi> sowwie
10:38:04 <nshepperd1> Community norms in the hells are flexible
10:41:26 <geekosaur> that depends on the nature of "hells". consider prisons
10:41:49 * hackage google-oauth2-jwt 0.3.1 - Get a signed JWT for Google Service Accounts  http://hackage.haskell.org/package/google-oauth2-jwt-0.3.1 (MichelBoucey)
10:42:54 <nshepperd1> "Mercury has a much steeper learning curve, BECAUSE in many cases the compiler tells you when your program is not going to do what you thought it would, and you never get to find out what would have happened, so you don't understand what the compiler is trying to tell you." Hmm
10:44:17 * nshepperd1 . o O (constructive vs non constructive proofs of incorrectness)
10:45:05 <ski> hm, conjuring up a use of type-incorrect code which would go wrong, came up in discussion a couple of days ago
10:47:02 <ski> "Dynamic Witnesses for Static Type Errors (or, Ill-Typed Programs Usually Go Wrong)" by Eric L Seidel,Ranjit Jhala,Westley Weimer in 2016-06-24 at <https://arxiv.org/abs/1606.07557>
10:47:57 <ski> (<https://www.reddit.com/r/types/comments/6scejn/dynamic_witnesses_for_static_type_errors/>,<http://lambda-the-ultimate.org/node/5355>)
11:05:25 --- mode: glguy set +v Orlan
11:08:14 --- mode: glguy set +v abbccc
11:12:12 * hackage BiobaseHTTPTools 1.0.0 - Tools to query Bioinformatics HTTP services e.g. Entrez, Ensembl.  http://hackage.haskell.org/package/BiobaseHTTPTools-1.0.0 (FlorianEggenhofer)
11:13:06 <Orlan> what is a typing context?
11:13:37 <koz_> Orlan: Why do you ask?
11:15:08 <rntz> Orlan: it's a thing used by PL theory folks in rules that formalise whether a program should type-check or not. it maps variables to their types.
11:15:17 <Orlan> koz_: Because i don't know how ot bind with typing variables
11:16:21 <koz_> Orlan: What do you mean by 'bind with typing variables'? Are you having issues writing something in Haskell? Compiling something? Some other thing?
11:17:59 <Orlan> koz_: I try to understand Hindley-Minler type system
11:19:12 <ski> a typing context tells you the type of all the variables in scope
11:20:17 <Orlan> koz_: I must asks it in math channel?
11:20:24 <ski> in `if b then and cs else False' (which has type `Bool'), the typing context will have to include : the type of `b' is `Bool', and the type of `cs' is `[Bool]'
11:20:52 <ski> Orlan : here is fine
11:21:27 <ski> symbolically, one could write the above as
11:21:41 <rntz> Orlan: if you're ok with reading a textbook, you might want to try Types And Programming Languages, by Benjamin Pierce, if you want to understand Hindley-Milner (and a lot of other things besides).
11:21:43 <ski>   ...,b :: Bool,cs :: [Bool] |- if b then and cs else False :: Bool
11:21:58 <ski> @where polymorphic-type-inference
11:21:58 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
11:22:13 <ski> is a paper i sometimes suggest to people trying to understand HM
11:23:49 <bifunc2> How important is it for a Haskell library name to match its GitHub repository name? This seems to be the convention.
11:24:18 <siers> What's Setup.hs for?
11:24:43 <glguy> bifunc2: It's moreimportant that you link to the right repository in the cabal file
11:26:35 <argent0> hi, I have a question regarding histomorphisms in recursion-schemes. The Cofree keeps the whole history, so writing a a `fib n` function would be linear in space, right?
11:26:50 <argent0> eg: https://github.com/argent0/adventOfCode2018/blob/abdc302b8b5e64f8cd99243e332b16969045c083/src/Day13.hs#L292
11:28:21 <Welkin> what do you use to add a copyright/license header to each file in an existing project? cat? sed?
11:28:42 <Welkin> either can work, but I wonder if I'm missing an obvious/easier solution
11:29:42 <argent0> Welkin: cat -- for file concatenation
11:30:28 <argent0> cat cpy.law Frob.hs > Frob'.hs
11:31:15 <int-e> . o O ( Frob\'.hs )
11:32:05 <bifunc2> Thanx
11:32:49 <siers> Is Setup.hs not needed any more if I have nix?
11:35:01 <Welkin> Frob? Makes me think of John Frobisher from Torchwood, played by Peter Capaldi
11:35:38 <Welkin> I can out output routing (>) to overwrite the same file, right?
11:35:43 <Welkin> can use*
11:36:35 <argent0> Welkin: **!!NO!!**
11:36:37 <koz_> Welkin: I use a plugin for that.
11:36:42 <koz_> (a Neovim plugin that is)
11:37:03 <koz_> But I guess you wanna do it for like, ten thousand files or something?
11:40:07 <[exa]> Welkin: what about in-place ed/sed?
11:40:10 --- mode: glguy set +v Guest8244
11:42:31 <Guest8244> Hey, I am kinda new to haskell, and trying to make a calculator, so im trying to parse expressions, using a parser with this data: newtype Parser a = P (String -> Maybe (a,String)), what is the difference between that datatype and this: newtype Parser a = String -> Maybe (a,String)
11:43:20 <amalloy> Guest8244: the second one you've written is not a legal type definition
11:43:33 <[exa]> Guest8244: in the second case you probably wanted to use 'type'
11:43:34 <amalloy> a newtype needs a name for its value constructor
11:43:39 <Welkin> [exa]: can you concat files together with that? Or do an insert?
11:45:01 <Guest8244> and when a function uses the first parser, do I need to instantiate the parser? like create an object of it?
11:46:06 <Welkin> a parser is just a function
11:46:18 <ski> (or "contains a function")
11:46:20 <Solonarv_> Welkin: something like this: sed -i "s@^@$(cat cpy.law)@" *.hs
11:46:24 <Solonarv_> (I think)
11:46:39 <Welkin> thanks, I'll try that
11:46:55 <Solonarv_> (test it without the -i first)
11:47:59 <[exa]> Welkin: yes, an in-place insert. here's an example http://wiki.bash-hackers.org/howto/edit-ed
11:48:58 <[exa]> basically the command is 'r cpy.law'
11:49:37 <Guest8244> but since its a newtype then its a datatype and not a function right? 
11:50:22 <ski> it contains a function
11:50:34 --- mode: glguy set +v gusdebbja
11:51:10 <Guest8244> and the function would be this: P (String -> Maybe (a,String)
11:51:20 <Guest8244> right?
11:51:54 <ski> that's a mixture of value-level things (the data constructor `P'), and type-level things (the type of the contained function)
11:52:21 <ski> you could define a parser, like
11:52:32 <[exa]> Guest8244: the 'newtype' adds a bit of wrap that disappears in the run-time, but plays important role for typechecking and some other things
11:52:48 * argent0 frob.com
11:53:11 <[exa]> Guest8244: in final effect, you can't use it as a function directly, but need to unwrap the P first
11:53:57 <[exa]> Conversely, you can build typeclass instances with the wrapping, which you could not do with plain function
11:54:19 <ski>   char :: Char -> Parser (); char c0 = P parseIt where parseIt (c:s) | c0 == c = Just ((),s); parseIt _ = Nothing
11:54:30 <Guest8244> I see 
11:55:05 <ski> so `char c0' constructs a function `parseIt', which it wraps inside the data constructor `P', giving a result of type `Parser ()'
11:55:19 <ski> `parseIt' itself has type `String -> Maybe ((),String)'
11:55:48 <ski> (one could write a type signature for it, if one wanted to)
11:56:56 <Guest8244> I see, it makes more sense now thanks a lot 
11:59:59 <Superhanz> is there a cons that adds to the end of the list?
12:00:02 <Superhanz> aside from ++
12:00:10 <Superhanz> i.e. 1:[2,3] = [1,2,3]
12:00:21 <Superhanz> i want [1,2]:3 = [1,2,3]
12:01:24 <ski> no
12:01:31 <Superhanz> okay np
12:02:14 <ski> lists are single-linked lists. a non-empty list consists of the first element, and a list containing the remaining elements
12:02:20 <Welkin> cons is only at the head
12:02:29 <ski> `[0,1,2,3]' really is shorthand for `0:1:2:3:[]'
12:02:34 <Welkin> adding to the end is called snoc and requires you to traverse the entire list
12:02:42 <ski> (which means `0:(1:(2:(3:[])))')
12:03:03 <ski> @let snoc xs x = xs ++ [x]
12:03:05 <lambdabot>  Defined.
12:03:17 <ski> > snoc [0,1,2] 3
12:03:19 <lambdabot>  error:
12:03:19 <lambdabot>      Ambiguous occurrence ‘snoc’
12:03:19 <lambdabot>      It could refer to either ‘Lens.snoc’,
12:03:23 <ski> er, ok
12:03:24 <Welkin> oh lens
12:03:26 <ski> > L.snoc [0,1,2] 3
12:03:28 <lambdabot>  [0,1,2,3]
12:03:56 <ski> doing `0 : [1,2,3]' doesn't require traversing the list. it's an O(1) operation
12:04:05 <Welkin> if you need to add elements to the end you probably don't want a list
12:04:20 <ski> doing `snoc [0,1,2] 3' *does* require traversing the list, is `O(n)', `n' being the length of the list
12:04:21 <DigitalKiwi> glguy: I didn't see it in the wiki or github or config-format...if it's there I missed it I did search tho :| is there a way to do autocorrect in glirc?
12:04:36 <Welkin> but you can also cons to the head and then reverse the list when you need to use it to display some data
12:04:52 <Superhanz> i see
12:04:56 <Superhanz> I see*
12:05:06 <Superhanz> crap i think hexchat is broken
12:05:12 <DigitalKiwi> err, spellcheck, rather
12:05:16 * ski idly wonders whether Superhanz has defined `reverse :: [a] -> [a]', yet
12:05:20 <Welkin> Superhanz: you can implement a queue with two lists with great ease
12:05:32 <Welkin> data Queue a = Queue [a] [a]
12:05:36 <Superhanz> I am going to have to restart hexchat, I can only see half of what people are writing
12:05:56 <Welkin> then you can add to the end of the queue, if that is what  you are going for
12:06:10 <Superhanz> ah that is better
12:06:24 <Superhanz> have not defined reverse yet ski
12:06:29 <ski> ok
12:06:38 <ski> if you want to, you could think about how one could do that
12:06:39 <Superhanz> is it On**2
12:06:52 <ski> it ought to be `O(n)', `n' being the length of the list
12:07:07 <ski> (if it isn't, it's needlessly inefficient)
12:07:11 <Superhanz> cons is O(1)
12:07:16 <Superhanz> and ++ is O(n)?
12:07:29 <ski> `n' being the length of the left list, yes
12:08:00 <ski> (i could give you a hint, if you'd want to hear it. but perhaps you'd like to think it over, first)
12:09:12 <Superhanz> I really would like to spend time thinking about how Haskell works, so I can write better code but I have deadline problem atm
12:09:32 <Superhanz> got like 4 hours remaining for AI for a game of 8-Off Solitaire
12:09:37 <Superhanz> my win rate is super low rn
12:09:50 <Superhanz> and breadth first search takes like 5 minutes to run
12:12:14 <Welkin> you are just using breadth-first search?
12:12:27 <Welkin> not minimax with pruning?
12:13:36 <monochrom> The irony of "what is a typing context?" needing context.
12:13:45 <Superhanz> I am doing pruning
12:14:05 <Superhanz> it would be impossible otherwise
12:14:16 <Superhanz> or at least would take like 1000x longer
12:14:46 <[exa]> Superhanz: do you have a statistic of how many vertices the search examined?
12:15:56 <Superhanz> I estimate ~10 moves from each new state
12:16:12 <Superhanz> and I look 4 - 5 moves ahead
12:16:28 <Superhanz> when I look any further it takes too long
12:16:33 <Superhanz> which is expected
12:16:40 <Guest8244> I hope I am not too annoying, but isn't (Parser a) means Parser can take any datatype? like Parser Double, Parser Char, Parser String and so forth? 
12:16:50 <[exa]> Superhanz: do you have a heuristic on the states?
12:17:02 <monochrom> Yes Guest8244.
12:17:09 <ski> Guest8244 : yes, the type variable `a' (parameter of the data type) can be instantiated to any type
12:17:10 <[exa]> Guest8244: yes, it can _parse_ any datatype
12:17:26 <monochrom> Actually maybe not.  "any" is ambiguous.
12:17:39 <[exa]> Guest8244: chances are that it doesn't work though, if you think about implementation...
12:18:01 <Superhanz> yeah I am not finding optimal solution
12:18:03 <monochrom> Show actual code that goes wrong and we will discuss in specific concreteness.
12:18:16 <Superhanz> there are some basic ways you can tell if a new board is good
12:18:30 <[exa]> Superhanz: throw dijkstra in, discard more than top50 solutions, hope for the best
12:18:58 <Superhanz> Is dijkstra different to breadth first search?
12:19:14 <[exa]> yes, it prefers the branches with good heuristic
12:19:16 <Superhanz> I know distances are more important right? Distance doesn't actually matter for me
12:19:24 <monochrom> Yes. FIFO queue vs priority queue.
12:20:09 <Superhanz> I could try branch and bound... i don't think it would make a difference though
12:20:11 <monochrom> And between Dijkstra and Prim, what's used for priority.
12:20:14 <Superhanz> actually wait you're right
12:20:18 <Superhanz> it would make a diffrence
12:20:37 <Superhanz> ah crap I should have implemented Dijstkra from get go
12:20:49 <Superhanz> that was stupid of me
12:21:21 <[exa]> (well, usually dijsktra is used to find the shortest path from start so that all paths hit the "end" at the same time which is the shortest path. Here you want to expand the thing that you think is the closest from the end...so basically it's not dijkstra, but the data structures are same)
12:21:25 <hyperisco> if I have a Getter, and I need an equality predicate (a → a → Boolean), is there a fancy way to compose it? 
12:21:48 <dmwit> Guest8244: You might like my description of polymorphism as a communication protocol: https://stackoverflow.com/a/42821578/791604 (This expands on monochrom's comment about "'any' is ambiguous".)
12:21:55 <Guest8244> okay, thanks, I did not implement the Parser module tho, we are got it from the university and we are suppose to use it uneddited
12:21:59 <hyperisco> other than the mundane  \x y -> x ^. p == y ^. p
12:22:16 <[exa]> hyperisco: there is some `on` in Data.Function which could work like this, iirc
12:22:40 <hyperisco> oh yeah I can just do on (^. p) presumably
12:22:40 <Superhanz> I will try and get this BFS working, then I will change the priority of new boards and try and make it Branch and Bound
12:22:42 <[exa]> Guest8244: just curious, what university?
12:22:44 <Superhanz> thanks [exa]
12:23:08 <[exa]> Superhanz: in fact if you have a queue of unexpanded nodes in BFS, just convert it to priority queue ordered by the heuristic and you've got it
12:23:12 * hackage proteome 0.3.7.0 - neovim project manager  http://hackage.haskell.org/package/proteome-0.3.7.0 (tek)
12:23:23 <monochrom> dmwit: Do you have a story for recursive calls? >:)
12:23:27 <hyperisco> on (==) (view p)
12:23:50 <monochrom> which is when I say: I talk to myself all the time, it adds spice to my conversations.
12:23:56 <hyperisco> though why say (==) when you can say eq
12:24:22 <[exa]> hyperisco: it's even better with infix `on`
12:24:26 <dmwit> monochrom: Actually, I say *nothing* about how implementors or callers may satisfy the requirements put on them by the protocol, and in particular I don't talk about how recursion may be used to satisfy those constraints.
12:25:23 <dmwit> s/constraints/requirements/ for maximal parallelism
12:25:59 <dmwit> hyperisco: I do wish there was an `equating` somewhere in the standard library. It's a nice complement to `comparing` and I find I need it every once in a while.
12:27:10 <Guest8244> Chalmers university, sweden gothenburg
12:28:08 <dmwit> > (length "on (==)", length "equating")
12:28:11 <lambdabot>  (7,8)
12:28:14 <dmwit> So there is that. =)
12:28:28 <hyperisco> > length "on eq"
12:28:30 <lambdabot>  5
12:28:57 <dmwit> But I think for me typing symbols and parentheses and stuff has a slightly higher cognitive cost than English words.
12:29:02 <monochrom> Newsflash: Scheme is found to be more concise than Haskell.
12:29:12 <hyperisco> oh I am getting my languages mixed up… no eq in haskell
12:39:48 <Guest8244> -- | Try the first parser and if it fails try the second
12:39:48 <Guest8244> (+++) :: Parser a -> Parser a -> Parser a
12:39:48 <Guest8244> p +++ q  = P $ \s ->
12:39:48 <Guest8244>              case parse p s of
12:39:48 <Guest8244>                   Nothing -> parse q s
12:39:49 <Guest8244>                   r       -> r
12:40:03 <Guest8244> what would be the difference between the Parsers ?
12:40:18 <Guest8244> if they all originate from the same type?
12:40:48 <monochrom> The grammars they accept.
12:41:22 <monochrom> You need a concrete example, either of your own invention or borrowing from that paper.
12:41:57 <Guest8244> I would love a concrete example, since I dont fully grasp how the function work, i wouldnt create a concrete example 
12:42:44 <monochrom> But you can easily contrive two thingies, f and g, both having the same type Parser Integer for example, and then investigate what's f+++g.
12:42:58 <monochrom> Plus I also said "borrowing from that paper".  Did you see that?
12:43:31 <monochrom> What is your strategy for learning?
12:43:56 <dmwit> Guest8244: Counter-question: what is the difference between 3 and 4? They both originate from the same type (namely, Int).
12:44:04 <[exa]> Guest8244: btw please use pastebin for more than 2 lines of code
12:44:50 <Guest8244> I saw that, I thought you meant that the file where I got that function has examples, which it didnt, so not quite sure what you mean,  Thanks dmwit, that makes sense to me, also thanks will use pastebin next time 
12:45:18 <Guest8244> my strategy was reading learnyouahaskell but that didnt help tackeling this assignment
12:45:30 <monochrom> No, general learning.
12:46:01 <monochrom> But yes, "only reading" is like only 5% of an effective learning strategy.
12:47:37 <Guest8244> I did other exercices, that I understood, like Blackjack, and some exercies about list comprehension, but this Parser datatype, just can't wrap my hand around it, yes ofc practicing is the best strategy, sadly i have 3 other courses plus master thesis to take care of, so can't practice much
12:48:34 <Guest8244> I guess this is what happens when u only program OOP and almost never functional programming 
12:48:40 <monochrom> Exercises are adequate for supervised learning. Inadequate for unsupervised learning.
12:48:54 <aplainzetakind> Are there standard versions of pred/succ that wrap around when they hit min/maxBound?
12:49:30 <dmwit> aplainzetakind: No. But for some types, (subtract 1) and (+1) do that.
12:49:33 <monochrom> No, the standard wants you to not wrap around.
12:50:12 <dmwit> In particular, the {Int,Word}{8,16,32,64} family of types specify the behavior of (subtract 1) and (+1) to do that.
12:50:13 <glguy> aplainzetakind: Generally it's worth forgetting about pred/succ and just leaving them as hidden details for getting [1..10] notation for integers
12:51:41 <davean> a fact that has made me very sad several times.
12:52:10 <monochrom> Facts usually do that. Make people sad.
12:52:38 <monochrom> The truth will make you flee.
12:53:57 <dmwit> ?let aBazilliontyTen = 100000000010
12:53:58 <lambdabot>  Defined.
12:54:03 <aplainzetakind> glguy: Why is that?
12:54:20 <jle`> if a fact doesn't make you sad, is it really even a fact worth knowing
12:54:26 <[exa]> dmwit: pls don't convert to float
12:55:19 <dmwit> > dmwit :: Float
12:55:21 <lambdabot>  NaN
12:55:25 <[exa]> nayyyyyy
12:55:39 <aplainzetakind> I just have data `Direction = E | N | W | S` and it would be nice to turn left by just calling succ.
12:55:45 * dmwit . o O ( I am not a number! )
12:55:51 <[exa]> :]
12:55:57 <monochrom> jle`: Ah but my "facts usually make people sad" is only a correlation, not causality.  The cause is from people themselves.
12:55:59 <glguy> aplainzetakind: For the integer types it can be handy to get the ranges, for floating point numbers the end conditions are a little surprising and trip people up. For ADTs it's not great to rely or the ordering of the defined constructors, succ adds an extra overflow test on numbers that people typically don't want, the Enum class only works on things that fit into an Int reliably
12:56:24 <dmwit> aplainzetakind: I have a cunning plan. `type Direction = (Int, Int)`. Turn left by multiplying by the 90 degree rotation matrix.
12:56:30 <[exa]> aplainzetakind: 'succ' should not form cycles, right?
12:56:38 <monochrom> A rational, truth-respecting person is made happy by all facts.
12:56:57 <glguy> aplainzetakind: backing the order of directions such that succ happens to implement left is basically a hack
12:57:07 <aplainzetakind> [exa]: Well succ itself probably shouldn't, I'm just asking if there's a variant.
12:57:13 <monochrom> For other people, recall "ignorance is bliss; in lieu of that, try denial".
12:57:18 <glguy> (which is probably fine for a throw away program, but not a good practice in general)
12:57:20 <dmwit> Some facts are nice. I recently learned that when photons destructively interfere, they get stamped "return to sender" at the receiving end and go back in time to avoid being sent at all.
12:57:24 <dmwit> That's kind of neat.
12:58:02 <[exa]> aplainzetakind: if it's for a game that has some reminiscent of vector space that the stuff is moving through, please really do use some variant of the 2-dim direction vector that dmwit suggested
12:58:17 * ski . o O ( "I am not a Church numeral! / I am a free variable!" )
12:58:22 <aplainzetakind> dmwit: I can't pattern match on that cunning plan though.
12:58:24 <jle`> aplainzetakind: i don't think having a 'universal' thing built into the language is common enough to warrant inclusion.  relying on order of enum for actual business logic is prett bad and pretty fragile, i think
12:58:36 <dmwit> ?remember ski I am not a Church numeral! I am a free variable!
12:58:36 <lambdabot> Okay.
12:58:39 <aplainzetakind> It's for the AoC carts btw.
12:58:48 <dmwit> aplainzetakind: Why can't you pattern match on it?
12:58:53 <jle`> aplainzetakind: the actual way you would write this in real code ould be to manually match up each constructor ith the new constructor
12:58:55 <ski> well, that's a quote from someone else
12:59:08 <jle`> turnLeft E = N; turnLeft N = W; turnLeft W = S; turnLeft S = E
12:59:08 <monochrom> aplainzetakind: You need to wrap around, but you don't need to hijack the "succ" name.
12:59:09 <dmwit> ?forget ski I am not a Church numeral! I am a free variable!
12:59:09 <lambdabot> Done.
12:59:09 <ski> (not sure from where. perhaps the "lambda the ultimate" papers ?)
12:59:21 <dmwit> ?remember someone_else I am not a Church numeral! I am a free variable!
12:59:21 <lambdabot> I will remember.
12:59:25 <[exa]> aplainzetakind: then 'cw' and 'ccw' would probably be better names
12:59:56 <[exa]> 'successor of the north' sounds like a heir from game of thrones who knows nothing
12:59:59 <ski> (it's listed at <http://gotlisp.com/lambda/lambda.txt>, but that doesn't tell where it's from)
13:00:47 <aplainzetakind> I don't have a problem achieving what I want to achive, I just asked if something already exists that would save three lines.
13:00:52 <aplainzetakind> If not, fine.
13:01:10 <aplainzetakind> [exa]: Those names I have.
13:01:29 <jle`> ah yeah, no, i don't think it's universally useful enough or generally useful enough, or reliable enough, to be something that exists 
13:01:42 <jle`> aplainzetakind: also, be aware that shorter code is often less readable
13:01:59 <jle`> writing the same thing in three lines less might actually be a *bad* thing, not a good thing, in most cases
13:02:21 <[exa]> ok, that's probably most reasonable. Having that different from 'succ' also allows you to list directions using [E..] without creating infinity, which may be handy
13:03:11 <dmwit> Well, [E ..], anyway.
13:03:17 <dmwit> E.. is most likely a scope error. =)
13:03:59 <jle`> sorry, by "be aware", i meant "be comforted in the fact that"
13:04:08 <aplainzetakind> I have `data Dir = L | U | R | D; data Turn = CW | STR | CCW` and I have `turn :: Turn -> Dir -> Dir`. I think this is a clean enough model.
13:05:11 <aplainzetakind> And I got tempted to write something like `turn CW = pred'`, that's all.
13:05:33 <mniip> STR?
13:05:39 <dmwit> (probably "straight")
13:05:48 <aplainzetakind> ^
13:05:49 <mniip> an identity action?
13:06:53 <dmwit> type Dir = Mod 4; type Turn = Mod 4; turn :: Turn -> Dir -> Dir; turn = (+)
13:07:05 <dmwit> ;-)
13:08:04 * hackage hakyll-sass 0.2.4 - Hakyll SASS compiler over hsass  http://hackage.haskell.org/package/hakyll-sass-0.2.4 (meoblast001)
13:08:34 <aplainzetakind> dmwit: the 4th member of Turn has no business being there.
13:09:10 <jle`> yeah, there's Dir = Finite 5, and you can use modulo addition for that.  i didn't do it myself though because i couldn't think of a clean way to implement the (0,1),(2,3) and (0,3)(1,2) permutations
13:09:12 <jle`> in a nice way
13:09:15 <jle`> * Finite 4
13:09:31 <jle`> manually pattern matching on 0/1/2/3 constructors gives impartial pattern match warnings
13:10:55 <jle`> implementing the mirrors requires implementing (01)(23) for one variant of mirror, and (03)(12) for another variant of mirror
13:11:22 <jle`> (01)(23) can probably be a separateProduct -> mod addition
13:11:59 <aplainzetakind> mirrors?
13:12:19 <jle`> sorry, that's what i called / and \ :) 'turns' i suppose
13:12:41 <jle`> i called them mirrors because they looked visually like mirrors
13:12:48 <jle`> in the ascii embedding
13:13:01 * ski . o O ( `Finite (m + n) ~= Either (Finite m) (Finite n)' )
13:13:16 <aplainzetakind> jle`: makes sense.
13:25:43 <dminuoso> Reasking since there was no response. Let's say I have some prism, is there a way to modify what `preview` will see if the target exists if I cant make an Iso?
13:25:43 <dminuoso> Or do I have to just fmap over the result of preview if I really want that behavior?
13:30:26 <Solonarv_> dminuoso: 'to :: (s -> a) -> Getter s a'
13:30:51 <Solonarv_> compose that with your prism
13:31:28 <Solonarv_> or if you already have an optic you can just use that
13:32:23 <dminuoso> Solonarv_: Are there any limitations to what you can compose?
13:32:29 <dminuoso> That is, can you compose any two optics?
13:32:39 <Solonarv_> As far as I know, yes
13:33:02 <Solonarv_> (assuming you're using 'lens', that's the entire purpose of the encoding used by that library)
13:33:57 <Solonarv_> % Left "hello" ^? _Left . to length
13:33:58 <yahb> Solonarv_: ; <interactive>:1:1: error:; GHC internal error: `Ghci42.x' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []; <interactive>:542:14: error:; * Variable not in scope: (^?) :: Either [Char] b0 -> (a1 -> c0) -> t; * Perhaps you meant one of these: `^' (imported from Prelude), `^^' (imported from Prelude), `!?' (imported from Data.Map); <interactive
13:34:34 <Solonarv_> % (Left "hello" :: Either String Int) ^? _Left . to length
13:34:34 <yahb> Solonarv_: ; <interactive>:1:1: error:; GHC internal error: `Ghci42.x' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []; <interactive>:543:37: error:; * Variable not in scope: (^?) :: Either String Int -> (a1 -> c0) -> t; * Perhaps you meant one of these: `^' (imported from Prelude), `^^' (imported from Prelude), `!?' (imported from Data.Map); <interactiv
13:34:41 <Solonarv_> pah!
13:35:32 <hexagoxel> "Variable not in scope: (^?)" ?
13:35:46 <sm> evening all
13:35:54 <f-a> hey sm
13:36:09 <sm> is there a shorter/inline way to write printandupdate here ? https://hastebin.com/inusihedep.bash
13:37:23 <hexagoxel> hear hear, a code golfing challenge
13:37:35 <f-a> sm: I suspect arrows could help
13:37:38 <f-a> let me try
13:37:38 <sm> w' <- update w, I should have said
13:37:52 <sm> yikes arrows in the back
13:38:04 <sm> arrows in the knee
13:40:39 <f-a> sm: I suspect printworld is IO (), right?
13:43:19 <asthasr> I thought everyone hated arrows
13:44:11 <w1n5t0n> has anyone used the Sound.OSC module? Having some trouble figuring out how to receive messages over UDP
13:44:51 <delYsid> Yay for OSC, but never in Haskell.
13:45:28 <ski> @quote time.leaks
13:45:28 <lambdabot> monochrom says: Time leaks like an arrow. Syntax rules like a macro.
13:46:49 --- mode: glguy set +v cmotoche
13:47:35 <w1n5t0n> There's this function that takes a UDP port and returns a (Maybe Message), but I'm not sure how to use it due to laziness: https://hackage.haskell.org/package/hosc-0.16/docs/Sound-OSC-Transport-FD.html#v:recvMessage
13:49:07 <dminuoso> wildsebastian: What does laziness has to do with this?
13:49:40 <dminuoso> Uhh I meant w1n5t0n.
13:49:58 <c_wraith> I don't blame him. a lot of intro materials overuse lazy IO and imply all IO works like that. 
13:50:32 <dminuoso> w1n5t0n: Do take particular note that a) it takes a *Transport* and b) it returns an `IO (Maybe Message)`.
13:50:57 <dminuoso> c_wraith: Ah fair enough, Ive started to really dislike lazy IO.
13:51:04 <dminuoso> But luckily we have things like conduit now. :)
13:51:12 <c_wraith> only started? :)
13:52:02 --- mode: glguy set +v ACheesyName
13:53:02 <ACheesyName> hello I'm a second time beginner at Haskell. That is, I already failed to learn it once and this is my second attempt.
13:53:24 <w1n5t0n> what I'm confused about is whether I should open the UDP port beforehand. For sending I'm doing something like "sendOSC globalUDPRef msg", where 'globalUDPRef = unsafePerformIO $ OSC.openUDP "127.0.0.1" 57120'
13:53:59 <w1n5t0n> which is "NOINLINE"d
13:54:12 <hexagoxel> sm: printandupdate = update >=> \w -> printworld w $> w
13:54:13 <ACheesyName> What I don't understand right now is how allowing partial functions via error affects purity. Should I avoid error because it isn't pure?
13:54:23 <dminuoso> ACheesyName: Correct.
13:54:43 <f-a> nice one hexagoxel 
13:54:46 <dminuoso> ACheesyName: So a function `String -> Int` suggests that it maps *ALL* strings onto the set of Int.
13:55:12 <ski> (s/onto/to/)
13:55:22 <ski> (or maybe "into" ?)
13:55:32 <dminuoso> ski: Mmm, why not "onto"?
13:55:38 <saml> is functional pearls good?
13:55:55 <dminuoso> ACheesyName: So if you wanted to admit that a function could fail, one possible way is by using `Maybe` to denote failure with Nothing.
13:55:56 <ski> because that suggests that every `Int' can be reached as an output of the function, applied to some input
13:56:04 <ski> (iow that the function is surjective)
13:56:09 <dminuoso> ski: Oh so `onto` implies surjectivity to you?
13:56:15 <dminuoso> Interesting, I was not aware of that. :)
13:56:20 <ski> ("onto" is a synonym of "surjective", in math)
13:56:39 <ski> (and "one-to-one" is a synonym of "injective")
13:57:04 <ski> saml : often
13:57:24 <dminuoso> ACheesyName: If you wanted a more descriptive failure, you could use `Either String` for example (or any other failure type other than String) to include some particular error message.
13:57:43 <[exa]> ACheesyName: say the error has a "side effect" of cancelling everything to the point where you catch it
13:57:48 <dminuoso> ACheesyName: A user then is forced to discriminate the return value to test whether it was a `Just x` with a result x or failed with `Nothing`.
13:58:20 <[exa]> ACheesyName: if that isn't described by the return type, it's not pure
13:58:25 <dminuoso> Recovering from `error` is really hard and non-obvious that you even need to do it.
13:59:30 <saml> is red black tree good?
13:59:46 <[exa]> good as a good person?
13:59:56 <[exa]> saml: (it's good for _some_ purposes)
14:00:24 <dminuoso> ACheesyName: (Or for the second example the user would be forced to discriminate the return value to test whether it was a `Right x` carrying a positive failure `x` or a `Left e` carrying an error message `e`.
14:01:42 <siers> I've a correct DeriveGeneric language pragma, but ghc through «cabal build» only compiles with it when I add it through --ghc-option=-XDeriveGeneric
14:04:14 <mpickering> That seems wrong
14:04:24 <Solonarv_> siers: upload your .cabal file and the source file somewhere, and post links
14:07:10 <sm> f-a: sorry, yes
14:07:24 <sm> hexagoxel: thanks, doesn't quite compile here
14:07:35 <f-a> sm: Data.Functor
14:07:38 <f-a> ( I suspect )
14:07:42 <sm> yes
14:07:54 <f-a> have you imported it?
14:08:38 <dmwit> jle`: (3-) will get you one mirror. You can get the other by conjugating the first mirror by a rotation.
14:08:45 <sm> aha, I had left off an extra argument on update. Looks good!
14:09:51 <dminuoso> ACheesyName: But really the important bit is: recovering from error is fairly hard.
14:10:05 <dmwit> jle`: Which... after a bit of arithmetic, is (1-). =)
14:10:24 <siers> https://bitbucket.org/wimuan/ghc-cabal-bug/src/master/ here it is :: cabal-install version 2.0.0.1 :: The Glorious Glasgow Haskell Compilation System, version 8.2.2
14:11:19 <geekosaur> siers, pragmas must come first
14:11:24 <geekosaur> after the moduledecl is too late
14:11:48 <siers> I should've thought of that. :) thanks!
14:11:52 <siers> yup
14:11:55 <geekosaur> (the exceptons are tose whose scope is a particlar identifier or declaration)
14:13:05 <w1n5t0n> I got the type system happy but I'm not actually receiving anything, do I have to manually instantiate the UPD port somehow? https://gist.github.com/lnfiniteMonkeys/c4b2cc7cfaade7f4a2a5628bbb6f54fb
14:14:00 <dmwit> :t ((<$)<*>)
14:14:01 <lambdabot> Functor f => (a -> f b) -> a -> f a
14:14:54 <dmwit> :t \update printworld -> update >=> ((<$) <*> printworld)
14:14:56 <lambdabot> Monad m => (a -> m b1) -> (b1 -> m b2) -> a -> m b1
14:15:06 <dmwit> sm: ^
14:15:10 <dmwit> So readable!
14:15:30 <f-a> I have a function like `filterTable :: Viewable vb => vb t Bool ->  Int`, is there a way to create a `Filter t` type synonym to replace `vb t Bool`?
14:16:14 <dmwit> You can even leave off the outer parentheses, I guess.
14:16:40 <dmwit> f-a: No, but you can create a `Filter vb t` synonym.
14:16:59 <dmwit> (`Filter (vb t)` is also possible.)
14:19:42 <f-a> dmwit: thanks (unfortunately, I hoped I could reduce the constructors/vars from 3 to 2)
14:20:01 <dmwit> That would be dishonest!
14:20:05 <f-a> =D
14:20:34 <f-a> well Lens kind of does a similar trickery, right?
14:20:52 <f-a> (a type var on the right not present on the left)
14:21:08 <glguy> the problem is you type variable was not isolated
14:21:15 <glguy> so you're not doing something like what lens does
14:21:23 <dmwit> I suspect it doesn't expand the way you think it does.
14:22:05 <dmwit> If you had `filterTable :: (forall vb. Viewable vb => vb t Bool) -> Int`, then it would be a different story. Then you could write a type synonym that didn't mention `vb`.
14:22:10 <dmwit> But that's a very different type.
14:22:32 <f-a> of course, that´s rankXtypes, right?
14:22:47 <dmwit> Rank2Types or RankNTypes, yes.
14:23:19 <f-a> ok, thanks dmwit glguy. Just to make it clear, an "isolated" type is...?
14:24:04 * hackage xmonad-volume 0.1.1.0 - XMonad volume controls  http://hackage.haskell.org/package/xmonad-volume-0.1.1.0 (vmchale)
14:26:37 <dmwit> In the type `forall a. t`, any instance of of type variable `a` is called "bound".
14:26:46 <dmwit> Variables which are not bound are called "unbound".
14:27:15 <dmwit> (...any instance of type variable `a` *inside the subterm `t`* is called "bound". Sorry.)
14:27:53 <dmwit> Type synonyms made to abstract a type can avoid mentioning bound variables on the left.
14:28:29 <jle`> dmwit: ah! interesting :)
14:29:05 <jle`> 🎿 actually yeah, maybe we couild do both in terms of sum/product for Finite
14:29:16 <jle`> ^ ski
14:31:20 <sm> dmwit: yikes!
14:31:43 <dmwit> f-a: ...and, just to tie things together, your type was `forall vb t. Viewable vb => vb t Bool -> Int`; in the subterm you wanted to make a synonym for, `vb t Bool`, both `vb` and `t` are unbound and so must be mentioned on the left of the equality.
14:32:04 <f-a> gotcha
14:32:09 <f-a> I mean, roger
14:32:14 <dmwit> f-a: You could expand the term you're synonymizing to include the `forall` if you wanted; e.g. `type FilterConsumer = forall vb t. Viewable vb => vb t Bool -> Int` would be fine.
14:32:46 * ski blinks
14:33:07 <dmwit> But `forall vb. vb t Bool` is not a subterm of your type, so abstracting that would not preserve your type. (It also wouldn't preserve the meaning of your type!)
14:33:59 <dmwit> sm: It... actually is pretty understandable if you're the one that wrote it. =P
14:34:13 <jle`> oh hey, it worked!
14:34:19 <siers> If I get values from decode's lazy bytestring will it only consume as much as necessary and I can do it twice if two objects are parsable?
14:34:24 <dmwit> sm: But maybe I've just seen the `ap zipWith tail` trick too many times.
14:34:46 <jle`> mirrorOne = combineSum . bimap (+1) (+1) . separateSum
14:35:00 <jle`> mirrorTwo = combineProduct . bimap (+1) (+1) . separateProduct
14:35:04 <jle`> neat
14:36:19 <jle`> ( ski )
14:36:37 <jle`> where i'm using (+1) as a crude 'flip'
14:37:40 <ski> aye, i suppose i had something like that in mind
14:38:26 <jle`> but now to just find a nice way to translate {0..4} into <0,1>, <1,0>, <0,-1>, <-1, 0>
14:38:58 <jle`> oh, that's just i^n
14:39:08 <jle`> or i^-n
14:39:24 <dmwit> uh
14:39:27 <dmwit> i^n = 0 ??
14:39:45 <jle`> by <0,1> i mean 0 + 1i, etc.
14:39:51 <dmwit> It's sin n, cos n.
14:40:19 <jle`> n={0..4} to i, -1, -i, -1 is i^-n
14:40:38 <dmwit> Okay, yes, I understand your notation now. =)
14:40:41 <jle`> um that time i revered the direction by accident
14:41:10 <jle`> yeah, a bit frustrating that 'i' is used as a name for a generic index, and also for -1^2 = i, heh
14:41:36 <dmwit> Oh, I knew you meant the imaginary i. I just didn't understand that you intended each pair to be one complex number.
14:42:26 <jle`> oh yeah, that too was an abuse of notation
14:47:57 <aplainzetakind> What is {0..4}?
14:49:27 --- mode: glguy set +v james
14:50:53 <jle`> oh sorry, i meant {0..3}
14:50:57 <aplainzetakind> :)
14:51:12 <jle`> it's Finite 4, or the set with 4 (ordered) elements :)
14:51:22 <jle`> "ordered"
14:53:30 --- mode: glguy set +v ghostofjames
15:01:35 * hackage brick 0.45 - A declarative terminal user interface library  http://hackage.haskell.org/package/brick-0.45 (JonathanDaugherty)
15:10:05 * bsima really wants to use brick for something
15:11:24 <siers> If I get a lazy ByteString {"a": 1}{"b": 2} from a websocket and then do two aeson decodes, will I decode what I expect to decode?
15:11:59 <glguy> What do you expect to decode? the same thing twice?
15:12:06 <siers> first one, then second one
15:12:14 <siers> I'm probably going to find out as I'm writing it, but I'd rather know in advance. :)
15:12:22 <jle`> siers: what do you mean by "two aeson decodes"
15:12:35 <glguy> You were hoping to give the same bytestring to decode twice and hoped to get a different answer the second time?
15:12:37 <jle`> functions in haskell are pure, so if you use the same function on the same input, you'll always get the same answer
15:12:43 <siers> glguy, it shouldn't work that way
15:13:06 <siers> I was doing wishful thinking here for a second I guess
15:13:30 <jle`> siers: in haskell, `f x` will always produce the same result, no matter how many times you use it
15:13:52 <jle`> so using decode on the same bytestring will always give the same result
15:14:09 <jle`> you won't get two different results if you use the same function on the same value twice :)
15:14:26 <siers> there should be a decode :: string -> (maybe successdecode, restofthestring)
15:15:31 <siers> Can aeson do stream decoding like that at all?
15:15:46 <glguy> http://hackage.haskell.org/package/aeson-1.4.2.0/docs/Data-Aeson-Parser.html
15:15:50 <johnjay> best place to find small haskell projects? github/lab/org?
15:16:43 <glguy> When you run an attoparsec parser you can get the unused portion
15:17:13 <glguy> johnjay: hackage.haskell.org is the best place to find projects. Most will have a lnk to their repositories there
15:17:55 <siers> ah it uses attoparsec — I didn't know
15:18:31 <siers> so I would sorta have to invent this, there's no function that does that sort already?
15:19:28 <jle`> siers: you could parse `many json`, maybe
15:19:37 <siers> I'm scared to even try :D
15:19:38 <glguy> Not if you wanted the results as they arrived
15:19:46 <jle`> ah, yeah.
15:19:57 <siers> I'm only interested in fully parsed phrases
15:20:05 <siers> first {a: 1}, then {b: 2}
15:20:24 <jle`> siers: it looks like attoparsec does let you do this
15:20:25 <geekosaur> tht would be the "as they arrived"
15:20:31 <jle`> with the `parse` function
15:20:36 <siers> geekosaur, i see
15:20:43 <jle`> parse :: Parser a -> ByteString -> Result a
15:20:44 <siers> okay, I guess I have to try this then
15:21:12 <siers> It's going to go wrong and I won't be able to figure out what went wrong :D
15:21:21 <jle`> so `parse json :: ByteString -> Result Value`, which is what you want i think
15:21:32 <jle`> since 'Result' contains the leftovers
15:21:53 <ondrejs> Hello, what's the current way to send data between a Haskell server and a PureScript client please? I am using Aeson in Haskell but the plugin for compatible json instances in PureScript https://github.com/eskimor/purescript-argonaut-generic-codecs is out of date.
15:21:55 <jle`> but i'm not sure if the json parser looks for eof, in which case that might kill this.
15:22:16 <siers> jle`, if that's works that's amazing how nicely that's decoupled
15:22:17 <glguy> It doesn't
15:22:22 <jle`> :(
15:22:38 <glguy> It doesn't look for eof
15:22:41 <siers> jle`, :)
15:22:41 <glguy> YOu should write :)
15:23:06 <jle`> oh, i thought you were replying to "if that works"
15:23:24 <jle`> in that case: :)
15:23:32 <siers> I bet it works, but I have to write some more code before I can try it out
15:23:57 <siers> because I don't want to write dummy code that'd sleep and write to a socket
15:24:04 <siers> I'll just use an actual server
15:24:17 <jle`> but you should probably not do this by hand like this; you might want to abstract over the pull-over-websocket and parse-json-chunks with something like conduits
15:24:40 <glguy> Maybe get it working before complicating it with conduit
15:24:49 <siers> glguy, Yes, that's what I was thinking.
15:24:54 <jle`> ah yeah, it should probably work first :)
15:25:04 <siers> I'd like to yak shave, but I wouldn't get anywhere never.
15:25:10 <siers> or ever
15:25:12 <siers> haha
15:25:35 <jle`> but once you get it working, getting conduits to unify the websocket source and the parsing and the transformation will probably make things more robust
15:25:40 <jle`> http://hackage.haskell.org/package/conduit-extra-1.3.0/docs/Data-Conduit-Attoparsec.html might work
15:26:34 <siers> I'm afraid I wouldn't be able to mentally deal with that right now
15:26:39 <w1n5t0n> what is the Haskell way of dealing with even listeners? In this case a listener for UDP messages, I have a function to go from a UDP port to a (Maybe Message) and it works, but only when I send a message and then call that function manually in the prompt. Is there a way to make it do something as soon as it receives the message?
15:26:57 <w1n5t0n> event*
15:27:55 <ondrejs> w1n5t0n: would having a thread blocking-waiting for the next message work?
15:28:45 <ondrejs> I'd think the function you have relies on the IO () monad
15:29:07 <w1n5t0n> ondrejs: I guess it would, I'm just not sure if that's a good way or a Haskell-idiomatic one. I don't really know how other languages deal with this either, all I know is that I set up a listener and it does something when it receives the message
15:29:10 <w1n5t0n> yes it does
15:32:59 <Solonarv_> I think the Haskell-typical way is to forkIO a thread which block-waits on the next message, yes
15:33:56 <ondrejs> I guess streams (e.g., conduit library) might be a fancy way to do this but I am not sure and I would personally not use fancy stuff until I have some benefit from it.
15:34:13 <Solonarv_> there's probably a 'select()' equivalent somewhere for waiting on multiple handles
15:37:41 <jackdk> Solonarv_ : That sounds right to me. With haskell's concurrency as good as it is, I think fork-and-block is probably more sanity-preserving than writing an oldschool select(2)-style loop
15:37:52 <w1n5t0n> Solonarv_: it seems so from this "udpServer" function here: https://hackage.haskell.org/package/hosc-0.16/docs/Sound-OSC-Transport-FD-UDP.html#v:udpServer
15:38:22 <lalbornoz> o go
15:38:24 <w1n5t0n> although I don't know what "void" is here
15:38:25 <lalbornoz> nm wrong window
15:39:27 <ski> (something that ought to be renamed. e.g. to `ignore')
15:40:27 <Solonarv_> void = fmap (const ())
15:40:38 <Solonarv_> (but yes, it should be renamed)
15:45:48 <w1n5t0n> renamed to what in this case? what is the purpose of that whole block?
15:47:20 * ski thinks `ignore' is a reasonable name
15:48:19 <ski> (it's used by SML)
15:49:57 <lyxia> ignore++
15:51:48 <ski> (just checked. also OCaml)
15:53:38 <w1n5t0n> is ignore a function?
15:54:00 <glguy> :t ignore
15:54:01 <lambdabot> error:
15:54:01 <lambdabot>     • Variable not in scope: ignore
15:54:01 <lambdabot>     • Perhaps you meant one of these:
15:54:04 <glguy> :t void
15:54:05 <lambdabot> Functor f => f a -> f ()
15:54:17 <glguy> Yes, you can tell because the outer most type is a function arrow
15:54:44 <ski> @type Foreign.Marshal.Error.void
15:54:46 <lambdabot> IO a -> IO ()
15:54:51 <geekosaur> afak the only reason "void" was used was taken from C's casting to void to ignore results. which is nto so different from where "return" came from, and look how good an idea that was
15:55:57 <w1n5t0n> hmm, how come I get a "error: Variable not in scope" when running ":t void" in ghci?
15:55:58 <ski> only we already have a `Void', whose elimination would like to be referred to as `void'
15:56:11 <Solonarv_> w1n5t0n: you haven't imported it
15:56:12 <ski> w1n5t0n : `:m + Foreign'
15:56:24 <w1n5t0n> ahh, I see thanks
15:56:38 <Solonarv_> :t Data.Functor.void
15:56:39 <lambdabot> Functor f => f a -> f ()
15:56:44 <Solonarv_> ^ it's there too
15:57:05 <Solonarv_> that's the "proper" variant
15:58:38 --- mode: glguy set +v Jamzz
16:00:21 <jackdk> geekosaur: a good enough idea to do it twice, apparently! detaching all the faulty intuitions around `return` was a huge part of my actually-grokking-monad journey. (Taking a detour to learn Applicative and using `pure` instead helped a lot, too.)
16:00:44 <freeman42x[nix]> does anyone here know how to set up Agda standard library under NixOS?
16:01:27 <w1n5t0n> ok I got something working now, I don't understand what the purpose of void is here though
16:03:34 <ktonga> hi, is it to use natural transformation ok or kind of a smell?
16:04:10 <jackdk> I think that's going to depend a lot on context.
16:04:42 <jackdk> ski: rename `void`? That's `absurd`!
16:05:19 <ktonga> blah :: (MonadIO n, MonadReader (Env n) m, MonadIO m) -> m ()
16:05:30 <ktonga> i have actions on `n` in an Env 
16:05:31 * ski smiles
16:05:39 <ktonga> which i need to lift into `m`
16:06:06 <ski> do it
16:06:23 <ktonga> i know that both will have IO son i kinda can write transformations 
16:07:05 <ktonga> but then i have to propagate that extra contraint from main
16:07:34 <johnjay> is there a way to do opengl in haskell?
16:09:36 <Solonarv_> @hackage OpenGL -- we have this
16:09:36 <lambdabot> http://hackage.haskell.org/package/OpenGL -- we have this
16:09:44 <Solonarv_> johnjay: ^
16:10:06 <johnjay> ok. i hope the wikibook explains how to install hackages or something
16:10:08 <johnjay> if so i'm set
16:10:15 <Solonarv_> and a small zoo of related packages, including bindings to: SDL2, GLUT, GLFW
16:10:39 <Solonarv_> There should be a section on that in the book, yes
16:13:43 <hpc> if you run into trouble getting that initial window open, i am a big fan of sdl2
16:16:13 <Solonarv_> Yeah, it's pretty nice
16:16:50 <Solonarv_> my main annoyance with it is that it has like 3 different ways to put stuff on the screen, and they don't seem to be compatible with each other
16:17:05 <Solonarv_> (those ways being: Renderer, Surface, and grabbing the OpenGL context)
16:17:10 <hpc> that part is fairly moot if... yeah
16:17:22 <hpc> once you know you're doing opengl, the choice is made
16:17:46 <hpc> what i like most about sdl2 is its gamepad support
16:18:02 <Solonarv_> Yeah, but... I haven't found a way to do text rendering via OpenGL /without/ using one of the built-in fonts
16:18:29 <hpc> (admittedly with rust) it took me about an hour to go from never installed rust before, to having a window open and gamepad event handling better than about 75% of my steam library
16:19:23 <hpc> my understanding of font rendering is you find another library that does nothing but ttf
16:19:30 <johnjay> hpc: there do seem to be a lot of rust fanatics around. i read a thread on r/emacs where people were clamoring to rewrite it in Rust
16:19:35 <hpc> and then just hope it doesn't have rendering artifacts
16:19:49 <Solonarv_> yes, there's sdl2-ttf which works fine... if you're using Renderer or Surface
16:20:06 <Solonarv_> I haven't found an "opengl-ttf" library
16:20:07 <hpc> Solonarv_: there are ones for opengl i am sure
16:20:15 <Solonarv_> (admittedly, I didn't look very hard)
16:20:16 <hpc> ah, maybe not in haskell though
16:20:19 <hpc> me either
16:20:38 <sm> hpc: nice
16:20:39 <Solonarv_> yeah, I meant one that has haskell bindings
16:20:53 <hpc> johnjay: it's a very haskell-like language imo - statement block syntax is almost a regex away from IO do-notation
16:21:07 <hpc> its ADTs are almost identical
16:21:12 * Solonarv_ has read the Rust book but not done anything with it
16:21:14 <hpc> it feels very natural to me
16:21:23 <Solonarv_> Likewise
16:22:28 <johnjay> ok let's rewrite everything in rust er uh haskell
16:22:31 <johnjay> or something
16:23:49 <Solonarv_> sounds like too much work
16:23:55 <hpc> i have mentioned a couple of times before, but my ideal future would be that rust ends up where java or python was 10 years ago
16:24:12 <hpc> then it gets a stable ABI
16:24:24 <hpc> then haskell gets a typesafe rust FFI
16:25:01 <hpc> imagine ghc knowing how to translate between haskell type signatures and rust type signatures in lib bindings
16:25:36 <Solonarv_> that would be pretty amazing
16:26:00 <Solonarv_> but rust doesn't have higher-kinded polymorphism, IIRC
16:26:07 <Solonarv_> (currently, I mean)
16:26:33 <hpc> rust is definitely going to be the simpler low-level language, and that's fine
16:27:01 <hpc> it just grates on me to see people casually writing messy C libs, giving them python bindings, and calling it high-level programming
16:27:12 <Solonarv_> I meant for the automatically translating types part
16:27:19 <Solonarv_> yeah that annoys me too
16:27:49 <hpc> i see bugs come up over and over and over again, where we've solved the underlying cause of those entire classes of bugs years ago
16:28:13 <hpc> straying into -offtopic again heh
16:28:33 <johnjay> hpc: with haskell?
16:28:39 <johnjay> or with just knowledge in general
16:29:24 <hpc> sort of both
16:29:33 <jackdk> imagine someone writing elm-export style stuff for other language bindings. easiest for C headers, I guess
16:29:59 <hpc> the ways of thinking about problems that led to haskell, and haskell itself making you think that way
16:30:27 <johnjay> hpc: ok. it's hard to tell the difference between genuine knowledge and mindless zombies with slogans sometimes
16:31:04 <hpc> heh
16:31:38 <johnjay> but that's also offtopic i imagine
16:48:46 <Axman6> johnjay: for OpenGL, there is also the gl package
16:49:27 <johnjay> ah ok
16:50:02 <Axman6> which implements like the entirity of OpenGL and all its extensions or something insane like that. Typical edwardk
16:51:31 <Solonarv_> How can one man write so much Haskell
16:52:05 <hpc> with a keyboard
16:52:53 <Solonarv_> Hm, fair point.
17:01:07 <c_wraith> iirc, he didn't write the package so much as a tool to convert the opengl headers to FFI bindings.
17:05:15 <siers> jle`, it kinda works, but it's only part of the solution — I'd still need to wait for more input
17:05:25 <siers> jle`, if this isn't enough to parse it yet
17:12:28 <aplainzetakind> I can put a `let` inside a single guard condition, but can I span multiple guards somehow? Clearly `f x let foo = bar in | ...` is meaningless.
17:12:48 <ski> use `where' ?
17:12:55 <hpc> ^
17:13:13 <Solonarv_> or use -XPatternGuards
17:13:27 <aplainzetakind> Can I nest wheres?
17:13:30 <ski> doesn't span multiple guards
17:13:32 <aplainzetakind> I'm already in one.
17:13:32 <ski> sure
17:13:38 <aplainzetakind> Aright.
17:13:43 <hpc> "where" can attach to any definition
17:13:51 <hpc> > let x = y where y = 5 in x
17:13:53 <siers> is it easy to create a conduit source from an IO action that reads from a socket?
17:13:54 <lambdabot>  5
17:13:54 <ski> (and to any `case' branch, as well)
17:14:00 <Solonarv_> `f x | foo <- bar, ...` might do what you want, too (that's what PatternGuards enables)
17:14:07 <hpc> > let x = y where y = z where z = 5 in x
17:14:09 <lambdabot>  5
17:15:26 <Solonarv_> siers: I think it should be fairly simple, check the conduit docs
17:17:23 <siers> Solonarv_, sure, but those docs are big
17:19:38 <Solonarv_> siers: https://hackage.haskell.org/package/conduit-1.3.1/docs/Data-Conduit.html#v:yieldM is half of what you want
17:19:48 <Solonarv_> combine it with 'forever'
17:22:09 <siers> That might be useful, but I'm off to sleep now
17:22:11 <siers> thanks!
17:23:11 <siers> yup, should work + tutorials are much better for a conduit noob https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview
17:24:34 --- mode: glguy set +v ian5v_
17:25:31 <ian5v_> i get "error: parse error on input ‘symbol’", which is really strange to me!
17:25:58 --- mode: glguy set -v ian5v
17:26:26 <ian5v> i believe this last message got eaten by spam filters, apologies if it doubled up:
17:26:32 <ian5v> i have a strange bug that i think might be related to using unicode in my code. https://hastebin.com/joxupoyino.rb
17:31:25 <geekosaur> actually, I would ask hwo certain you are of indentation
17:31:46 <geekosaur> actually, I would ask hwo certain you are of indentation
17:32:15 <geekosaur> in particular, if I remove the "-- ", I get lines that are not indented enough
17:33:12 <Solonarv_> yes, that seems to be the culprit here
17:33:42 <Solonarv_> this is actually the reason I rarely put stuff on the same line as the 'do'
17:34:00 <geekosaur> hm, sorry, didn't mean to send that first line twice
17:34:35 * hackage tasty-quickcheck-laws 0.0.1 - Pre-built tasty trees for checking lawful class properties using QuickCheck  http://hackage.haskell.org/package/tasty-quickcheck-laws-0.0.1 (nbloomf)
17:34:38 --- mode: glguy set +v Chorhizo
17:38:06 <ian5v> oh ugh, this isn't the first time this has gotten me
17:38:07 <ian5v> thank you!
17:38:33 <ian5v> i guess i'll try to keep things off of that do line in the future.
17:39:36 <Chorhizo> I created some parallel code in haskell that's literally 100 times slower than my sequential C implementation, are there any common pitfalls I might be running into?
17:40:53 <Rembane> Chorhizo: Maybe your problem isn't that parallellizable. 
17:40:59 <Rembane> Chorhizo: What are you parallellizing?
17:41:59 <geekosaur> a common one is not forcing computations in the parallel part, so they get forced sequentially afterward on output. but there are others
17:42:07 <geekosaur> @where parconc
17:42:07 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
17:42:58 <Chorhizo> Rembane: It's basically a toy problem for a unit I was studying on parallel computing where we had coursework in C, I'm doing the same computation on every element, SIMD style, just averaging the 4 neighbours (up, down, left, right) of each element, and the edges are fixed
17:46:12 <ACheesyName> beginner question how do I fix ambiguous type variable (resulting from print Nothing): https://repl.it/repls/GainsboroVengefulDecompiler
17:47:50 <Solonarv_> simplest solution: add a type annotation
17:48:04 <ski>   print(myLast ([] :: [Integer]))  -- type ascription
17:48:52 <Solonarv_> or: print(myLast [] :: Maybe Integer)
17:48:59 <geekosaur> there's also a hck that ghci uses (hidden in ExtendedDefaultRules): add () to the defaults list, so if all else fails it would infer [()] for that line
17:49:44 <ski>   main = mapM_ (print . myLast) [[],[1],[1,2],[1,2,3]]
17:49:56 <ski>   main = mapM_ (print . myLast) (inits [1,2,3])
17:50:00 <geekosaur> note tht ExtendedDefaultRules extension is not a great idea for source files, it's really intended to make ghci more convenient. otherwise it gives type inference too much rope
17:50:28 <Chorhizo> It's not a huge problem, so it might make more sense to see https://gist.github.com/PotterJam/5bff7d9f2d243f258ae1e0d4b0035259 , any general advice on how I'm handling the data / parallelising it would be really useful
17:59:32 <ACheesyName> ski: thanks the type ascription did it
17:59:34 <Axman6> Chorhizo: isn't 10 ^^ (-1) just 1.0?
18:00:42 <Solonarv_> > 10 ^^ (-1) -- clearly not!
18:00:45 <lambdabot>  0.1
18:00:58 <Axman6> uh, yes, right
18:01:50 <Axman6> Chorhizo: have you seen the Repa library?
18:05:50 * hackage HsHTSLib 1.3.2.4 - High level bindings to htslib.  http://hackage.haskell.org/package/HsHTSLib-1.3.2.4 (kaizhang)
18:09:13 <Chorhizo> Axman6: no, I haven't actually
18:19:40 <jchook> > 1 + 1
18:19:43 <lambdabot>  2
18:19:47 <jackdk> > 0.2 + 0.1
18:19:48 <jchook> that is so friggin cool
18:19:49 <lambdabot>  0.30000000000000004
18:20:06 <jchook> lol okay so... even haskell suffers from floating point precision
18:20:21 <ski> @where floating-point
18:20:21 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David
18:20:21 <lambdabot> Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
18:20:32 <Solonarv_> Every language that follows the IEEE float standard has this issue.
18:20:47 <russruss> hey all, I'm helping a friend work through the advent of code, and there's a really bad space leak.  I'm sort of out a loss for how to start debugging this - general hints for finding space leaks and helping the compiler with strictness analysis would be useful, or if anyone wants to dive in the code is here - again, looking to solve the space leak
18:20:47 <russruss> , not necessarily looking for a better approach for the problem https://gist.github.com/russellmcc/1ffcb1edb12cf49ab82e6b07ca102031
18:20:48 <Solonarv_> It's a problem with the standard, not with any particular implementation
18:20:59 <jchook> or is it a problem with finity
18:21:08 <jackdk> > 2 % 10 + 1 % 10
18:21:10 <lambdabot>  3 % 10
18:21:19 <jackdk> ^ we have rationals built in, at least
18:21:35 <jchook> lovely
18:21:45 <russruss> I think there's a space link because it uses memory at a rate that doesn't seem to scale linearly with the size of the working memory
18:21:49 <jchook> > :type 2 % 10
18:21:51 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
18:21:54 <jchook> :(
18:22:03 <Solonarv_> @type 2 % 10
18:22:04 <lambdabot> Integral a => Ratio a
18:22:05 <russruss> so I'm thinking that working memory from previous steps is being kept alive somehow?
18:22:34 <Solonarv_> lambdabot is a bit weird, it isn't /exactly/ a ghci session
18:23:56 <ski> `> ...' is only for evaluation of an expression (and showing the result, obviously)
18:24:45 <ski> > 1 % 2 + 1 % 3 + 1 % 6
18:24:48 <lambdabot>  1 % 1
18:26:33 <Solonarv_> > 6 % 9
18:26:35 <lambdabot>  2 % 3
18:27:40 <jchook> why have Ratio and Fractional?
18:28:01 <geekosaur> Fractioonal isn['t a type
18:28:04 * hackage itanium-abi 0.1.1.0 - An implementation of name mangling/demangling for the Itanium ABI  http://hackage.haskell.org/package/itanium-abi-0.1.1.0 (TristanRavitch)
18:28:08 <Solonarv_> Ratio is a specific type, Fractional is a type class
18:28:39 <ski> `Fractional' is a type class of number types supporting division
18:28:48 <ski> @src Fractional
18:28:48 <lambdabot> class (Num a) => Fractional a where
18:28:48 <lambdabot>     (/)          :: a -> a -> a
18:28:48 <lambdabot>     recip        :: a -> a
18:28:48 <lambdabot>     fromRational :: Rational -> a
18:29:02 <ski> @src Rational
18:29:02 <lambdabot> type Rational = Ratio Integer
18:29:30 <jchook> ok thanks that helps
18:30:29 <jchook> > 1/2 + 1/3 + 1/6
18:30:31 <lambdabot>  0.9999999999999999
18:30:37 <jchook> :)
18:30:58 <jchook> also illustrates some of the difference
18:31:16 <ski> rationals are exact
18:31:45 <ski> > 2 / 3 :: Rational
18:31:47 <lambdabot>  2 % 3
18:33:05 <jchook> > 1/0
18:33:08 <lambdabot>  Infinity
18:34:07 <jchook> > EQ > LT
18:34:09 <lambdabot>  True
18:34:52 <Solonarv_> @check \n d -> let q = fromRational (n % d) in q == q
18:34:54 <lambdabot>  *** Failed! Exception: 'Ratio has zero denominator' (after 1 test):
18:34:54 <lambdabot>  0 0
18:35:00 <Solonarv_> pah
18:35:24 <Solonarv_> @check \p q -> p/q == (p/q :: Double)
18:35:27 <lambdabot>  *** Failed! Falsifiable (after 1 test):
18:35:27 <lambdabot>  0.0 0.0
18:35:52 <ski> @check \n d -> (d /= 0) ==> let q = fromRational (n % d) in q == q
18:35:55 <lambdabot>  +++ OK, passed 100 tests.
18:36:19 <ski> @check \n (NonZero d) -> let q = fromRational (n % d) in q == q
18:36:21 <lambdabot>  +++ OK, passed 100 tests.
18:37:30 <Solonarv_> @check \n (NonZero d) -> let q = fromRational (n % d) in q/q == q/q
18:37:33 <lambdabot>  *** Failed! Falsifiable (after 1 test and 1 shrink):
18:37:33 <lambdabot>  0 NonZero {getNonZero = -1}
18:38:17 <jchook> reminds me of a fascinating article about dividing by zero: https://www.hillelwayne.com/post/divide-by-zero/
18:43:09 * ski . o O ( "How to Divide by Zero" by DMAshura at <https://www.1dividedby0.com/> )
18:48:47 <jchook> ski: I have a feeling I will be visiting this article many times
19:03:06 <jchook> is there a way to do @src in ghci?
19:04:15 <geekosaur> no, and @src is a lie anyway
19:04:28 <geekosaur> its' reading a etxt database in lambdabot, which is irregularly maintained
19:05:59 <jchook> geekosaur: ok thanks for the info. is it even feasible to do with haskell in a reliable way?
19:06:15 <jchook> e.g. some kind of command haskell-src <type>
19:06:43 <geekosaur> sure, you can extend ghci in various ways via :def. I don't know of anyone who's actually done the work for you though
19:07:13 <sproingie> hoogle web ui is probably the quickest way there
19:07:30 <jchook> yes, I often find myself hoogle + [Source] anchor
19:07:30 <geekosaur> or hayoo, yeh
19:07:49 <jchook> I find reading the source to be extremely helpful
19:08:36 <jchook> not always crystal at first, but some kind of osmosis occurs over time
19:11:28 <geekosaur> anyway there's no particular reason one couldn't write something to query hoogle/hayoo, parse out the source link, and feed it to a browser (including, since it's text with coloring, probably lynx etc.). nobody's done it that I know of
19:14:56 <sproingie> i just use an IDE that indexes all the things (intellij) and map "go to definition" to force-click
19:25:34 <ldlework> hi sproingie 
19:30:58 <safinaskar> hi
19:32:22 <coldpress> hello
19:32:24 <safinaskar> how to match regex, check that it actually matches, and, if yes, then extract matched portions? i. e. i want something like this:    case "hello,world" =~ "(.*),(.*)" of { Nothing -> ":("; Just [a,b] -> "got " ++ a ++ "," ++ b; }
19:32:43 <safinaskar> preferabbly using Text.Regex.PCRE
19:35:21 <monochrom> I think =~~ does exactly that.
19:37:33 <safinaskar> monochrom: thanks. where are the docs? hackage page for Text.Regex.PCRE refers to Text.Regex.PCRE.Wrap, but page for Text.Regex.PCRE.Wrap contains no docs
19:39:16 <monochrom> Both =~ and =~~ are polymorphic functions that work the same on all RegexLike and RegexContext instances.  You will have to read about them in the regex-base package.
19:40:08 <monochrom> regex-pcre is one such instance but there are many others.  They aren't going to repeat the same explanation.
19:41:09 <monochrom> If you see "this is out of date" don't stop reading.
19:47:59 <pdxleif> lens, bifunctor, arrow, Data.Either.Combinators... ya got choices https://stackoverflow.com/questions/13503965/mapping-over-eithers-left
19:48:41 <pdxleif> the arrow one's "built-in", but I'm kind of leaning towards lens or bifunctor - because those are things I actually use elsewhere.
19:53:46 <safinaskar> monochrom: still i did not find any useful docs at regex-base pages
20:02:52 <stevejb> Hello, I have a pandoc builder question.
20:02:57 <stevejb> I have this code:
20:03:06 <stevejb> https://pastebin.com/6Hz98wzc
20:03:13 <stevejb> It produces this markdown:
20:03:14 <stevejb> https://pastebin.com/L2bPXNHS
20:03:20 <stevejb> what is happening to the tables?
20:06:04 * hackage script-monad 0.0.2 - Transformer stack of error, reader, writer, state, and prompt monads  http://hackage.haskell.org/package/script-monad-0.0.2 (nbloomf)
20:18:50 <cemerick> I'm seeing something very odd tinkering with `Data.Vector` & co; everything is very slow, compared to my intuition of what should be happening (and, it seems, compared to the claimed performance characteristics as well?). e.g. repeated `V.head` calls taking 200ms and such. What might I be doing wrong?
20:25:52 <jle`> cemerick: what do you mean by 'repeated V.head calls' ?
20:26:01 <jle`> can you show your benchmark code?
20:26:55 <cemerick> jle`: nothing sophisticated. `x = V.replicate 100000000 0`, and execution time of `V.head x` never drops below 200ms.
20:27:15 <jle`> cemerick: are you sure it's not the replication that is taking the 200ms?
20:27:28 <jle`> remember that just naming something 'x' is lazy, it doesn't actually do any evaluation
20:27:42 <jle`> so you might be timing the replication, not the head
20:28:53 <cemerick> jle`: well, the first head call takes 400ms, successive ones are 200. It's an expression, not a monadic action or something, so it shouldn't ever get *re*evaluated?
20:28:58 <jle`> saying 'x = V.replicate 1000000 0' doesn't do anything, it's basically an alias
20:29:08 <cemerick> correct, that returns immediately
20:29:24 <jle`> cemerick: rigt, it 'returns' immediately because it doesn't actually allocate anything
20:29:53 <jle`> cemerick: also, make sure that your vector is monomorphic
20:30:17 <jle`> because if your value is polymorphic, then the thunk won't ever be cached/stored
20:30:24 <jle`> that's because every instance of Num gives you a different vector
20:30:34 <jle`> so ghc won't save *every* instance of Num's vector
20:31:29 <geekosaur> right, where are you testing this? ghci will default to being polymorphic, so it redoes it each time. (ghci is also interpreted and not optimized, which will e.g. defeat fusion rules)
20:31:41 <cemerick> whew
20:31:58 <jle`> that's why i ask to see the actual benchmark code :)
20:32:30 <ggole> Won't x be a function there?
20:32:33 <monochrom> Yes, always insist to ask "how do I reproduce your observation?"
20:33:11 <monochrom> And always think up an experiment to refute a hypothesis.
20:33:34 <ggole> (After type classes introduction, I mean)
20:33:40 <monochrom> Yes.
20:33:52 <jle`> otherwise all we can do is guess a few different things and wait for an answer; if we just see the code we could check it all right away :)
20:34:02 <monochrom> Well maybe monomorphism restriction kicks in, and now you really need to see the global code.
20:34:16 <monochrom> Always refuse to guess.
20:34:25 <monochrom> Don't feed bad habits.
20:34:25 <cemerick> it appears that ~every instance of my struggling with haskell grounds out in "ghci" :-P
20:34:46 <monochrom> Oh yes, whenever ghci disagrees with ghc, ghci is wrong.
20:34:50 <geekosaur> ghci is alost nver the place to run benchmarks
20:35:26 <cemerick> geekosaur: benchmarks, no, but when there was perceptible delay in my thawing/freezing a basic vector, I got curious.
20:35:35 * hackage script-monad 0.0.2.1 - Transformer stack of error, reader, writer, state, and prompt monads  http://hackage.haskell.org/package/script-monad-0.0.2.1 (nbloomf)
20:35:35 <monochrom> And also almost never the place to test "if I change the order of these two lines of code, what happens?"
20:35:42 <geekosaur> and there are ways to maker it behave more like ghc, but in general ghci is "be kind to users", not "be fast"
20:35:58 <monochrom> And also almost never the place to test "print []".
20:36:20 <sproingie> just learned today about how ghci makes that work
20:36:32 <geekosaur> in this case, you mith get something sensible with: ghci -XMonomorphismRestriction -XNoExtendedDefaultRules -fobject-code
20:36:36 <cemerick> these are a very strange set of premises for those used to optimizing lisp compilers/REPLs ;-P
20:38:44 <geekosaur> lisp isn't exactly known for "be kind to users"
20:38:51 <ggole> A Lisp REPL is intended to interact with a running system, so they tend to be very different from the static language toplevels.
20:39:23 <sproingie> geekosaur: lisp *environments* however are famously kind
20:39:36 <cemerick> geekosaur: we have reached an intense conflict of opinions
20:39:57 <cemerick> geekosaur: in any case, yes, those options yield expected behaviour, including with my thaw/freeze bits, thanks!
20:40:14 * cemerick goes off to re-read about all of them
20:40:15 <monochrom> Right, there is no fundamental conflict between kindness and code optimization.
20:41:00 <geekosaur> yeh, in ghci's case it's largely an unfortunate implemenation issue in the bytecode backend that means optimization leads to core dumps
20:41:33 <geekosaur> (bco can't tell the difference between boxed and unboxed tuples. one of the first things optimization does is unbox stuff.)
20:41:48 <monochrom> However, there is a fundamental conflict between intuitiveness and logicalness.
20:42:44 <sproingie> are you saying logic seems illogical? :)
20:42:47 <monochrom> For example if you ask "print []" it is intuitive to just tell you "[]" but it is logical to reject and say "stop, what type is it, is it [Char] or is it [Integer]? It matters."
20:43:34 <monochrom> I am saying logic seems inhumane.
20:43:48 <monochrom> Many humans feel hurt by logic.
20:46:32 <sproingie> one never calls it "warm logic" after all
20:47:07 * ski . o O ( hot logic )
20:47:14 <sproingie> that does have a ring to it
20:47:17 <monochrom> For another example it is intuitive for beginners to enter code into REPL directly but it is an XY problem to then ask "now how do I save the code or modify it?" costing millions of dollars and hours inflating a REPL into an IDE.  The logical way is instead "use an editor".
20:47:27 <sproingie> wakka :- chikka
20:48:08 <sproingie> there have been better repls back in the hugs days
20:48:25 * ski . o O ( "error: undefined predicate: chikka/0" )
20:48:56 <ski> @quote use.hugs
20:48:56 <lambdabot> BMeph says: "Friends Don't Let Friends Use Hugs."
20:49:35 <monochrom> I like Hugs actually.
20:49:46 <ski> ditto
20:50:34 <monochrom> More KISS error messages, and proof that the root cause of cabal hell is code optimization.
20:51:21 <monochrom> If you use an interpreter and always start with source code, there is not going to be any ABI mismatch, since there is no B.
20:51:40 <sproingie> an ideal environment should offer seamless transition between repl and ide.  emacs lisp nails it, for example (default keybindings notwithstanding)
20:51:52 <monochrom> I say this not to promote slowness but to remind you "good fast cheap --- choose two".
20:53:53 <jle`> you heard it here first everyone: monochrom has a slowness agenda
20:54:06 <monochrom> haha
20:56:07 <monochrom> An ideal environment requires people to stop spending time on academic-publishable type-theory projects (I am looking at you, Dependent Haskell) and start spending time on unpublishable REPL improvements.
20:57:14 * ski . o O ( researchers gotta research )
20:58:32 <cemerick> monochrom: I guess I'll just  be That Guy and vaguely point towards all the insanely fast, polished, and Free / gratis lisp impls out there :-P
20:58:45 <sproingie> any with a decent type system?
20:59:08 <cemerick> the point re: publishable type theory projects stands, of course
20:59:20 <monochrom> cemerick: Could you tell me where their developers got their lunch money from?
20:59:43 <cemerick> sproingie: Shen I suppose, and then Racket if you'll accept "reasonably fast" instead of "insanely fast"
21:00:04 <cemerick> we'll see how hackett makes out
21:00:43 * geekosaur could argue that Lisp devs need to make such environments just to keep from going insane....
21:01:28 <sproingie> starting at insane is a big help too
21:01:29 <cemerick> monochrom: in general, the same sorts of orgs that keep any other language/compiler dev fed?
21:02:17 <monochrom> Yeah. So you're looking for Galois Inc or FP Complete in the case of Haskell.
21:04:12 <monochrom> Lisp and Emacs and a lot of GNU stuff too started at an old time when like MIT hired programmers just for the sake of programming therefore people like RMS existed.  These sweet positions don't exist any more.
21:06:33 <ian5v> I have a function String -> String, but i'm curious if i can lift it to work on my own "Val" type. 
21:06:36 <ian5v> https://hastebin.com/cupenohuqi.sql
21:08:13 <monochrom> The simplest way is to hand-write your own.
21:10:04 <koz_> ian5v: Val is a sum type. What happens when your Val is 'BoolVal False'?
21:10:15 <ian5v> something like flip_bits_lifted :: Val -> Val?
21:10:54 <monochrom> That just tells you you can think up good names.
21:10:58 <koz_> ian5v: You have a function String -> String.
21:11:06 <ian5v> koz_: i am unsure! i would guess a runtime exception (something like "nonexhaustive case")
21:11:20 <sproingie> perhaps you want Val to be a functor
21:11:34 <ian5v> that sounds right, yeah
21:11:41 <geekosaur> ian5v, it's a common error to think that Functor meas "liftable". It only means that under specific circumstances, which don't appear to be met here.
21:11:47 <monochrom> That is a rabbit hole. Now you want Val to take a type parameter too.
21:12:10 <monochrom> I still stand by my answer.
21:12:13 <koz_> Yeah, because it doesn't make sense to have Val take a type parameter, since it's just a tagged value of a set of specific types, in this case {Bool, String, Int}.
21:12:23 <koz_> What would 'Val Double' even be?
21:13:34 <ian5v> geekosaur: what are those circumstances?
21:15:22 <geekosaur> the essence of Functor is fmap :: (a -> b) -> (f a -> f b). This requires that a can be different from b (hence requiring a type parameter), and that the result be defined for all inputs provided that the mapped function is
21:17:24 <geekosaur> in this case, you want f to be Val, but I cannot speak of a Val a or Val b, only of Val
21:19:02 <c50a326> hey do people regularly use a 3-way Either? Does it have a name?
21:19:48 <monochrom> People regularly define their own 3-way types and name it domain-specifically.
21:19:48 <geekosaur> and even if you change Val to fit that, its fmap can't check the type of the lifted function to see what part of the Val to operate on. Functor is the wrong tool, in other words
21:20:12 <monochrom> Also 4-way types and 5-way types and so on.
21:20:34 <ian5v> i see. thank you geekosaur!
21:20:37 <monochrom> GHC itself has a couple of its own 20-way types. (But I didn't count carefully.)
21:20:55 <c50a326> oh wow
21:23:28 <geekosaur> last I checked, HsExpr was rather more than 20
21:46:34 <c50a326> hey I was thinking of making a 3-way applicative validator that collects errors _and_ warnings, like this https://ptpb.pw/17UG/hs
21:46:49 <dminuoso> c50a326: Sometimes even making your own `data Foo s = Quux s | Bar` can be more useful than reusing Maybe.
21:47:13 <c50a326> but it's just not working out (unworkaroundable type errors and stuff), I guess I'm just trying to force this Applicative when it can't work that way?
21:47:22 <c50a326> or am I missing some way to make it work as I was thinking?
21:49:30 <dminuoso> c50a326: You seem to have missed a case there for (<*>)
21:49:58 <geekosaur> I'd also question the logic: just throw away wartnings unless they're the last thing that happens?
21:51:10 <c50a326> oh yeah I didn't finish writing it because intero lol
21:51:23 <c50a326> just in the middle of writing it I was like "oh this isn't working" hence the question
21:52:13 <c50a326> I mean specifically I can't do like:   Err x <*> Warn y = Err (x <> y)
21:52:22 <dminuoso> Of course not.
21:52:24 <c50a326> because the types of Err and Warn might be different
21:52:34 <dminuoso> c50a326: You could use the datatype `Validate` and then make your own monoid error type.
21:52:59 --- mode: glguy set +v ArchiCurry
21:53:00 <c50a326> ah could I have like GenericError = Warn String | Error String -- maybe
21:53:04 <ArchiCurry> hi guys 
21:53:16 <dminuoso> *Validation that is.
21:53:18 <ArchiCurry> somebody have some experience in building haskellR 
21:53:19 <ArchiCurry> ?
21:53:29 <c50a326> and then Either GenericError Cont ... something like that... but damn, I wanted to try wrting my own three-way Applicative implementation with a practical use case...
21:53:41 <dminuoso> c50a326: Well `Validation GenericError Cont`
21:53:58 <dminuoso> Since `Either` shortcircuits on errors, whereas Validation collects.
21:53:59 <ArchiCurry> i was trying to work some category theory ideas with ecological statistics 
21:54:12 <c50a326> ah yeah
21:54:51 <dminuoso> c50a326: And you dont have to supply your own Monoid if you use `[]` to build a free monoid on GenericError.
21:55:50 <dminuoso> Or I guess Semigroup would be sufficient here.
21:56:53 <dminuoso> I suppose NonEmpty gives you the free semigroup then.
22:00:37 <c50a326> dminuoso: pardon? sorry I'm bad with this terminology like "free" and "to build a free x on"
22:00:54 <c50a326> and even "supply your own Monoid"
22:01:48 <dminuoso> c50a326: So consider this: When you use `Validation YourErr Int`, it might accumulate errors of YourErr using it's Monoid instance (<>) right?
22:01:59 <dminuoso> Or rather, using it's Semigroup instance! SMP gets me confused.
22:02:41 <c50a326> so YourErr needs to be a Semigroup, yes, okay
22:03:06 <geekosaur> I'd argue w should be Monoid, e Semigroup. the problem with w beng what I mentoned earlier: Warn w <*> Cont c discards warnings
22:04:00 <c50a326> how does the difference between Monoid and Semigroup mean that you can engineer that difference in behaviour?
22:04:05 <geekosaur> I think warnings shoudl be a Monoid in Cont, instead of a separate Warn
22:04:20 <geekosaur> (Monoid so no-warnings can be represented)
22:04:40 <dminuoso> c50a326: A list of things can be thought of things that are being `<>`ed together, but with the choice of "which instance should we use" delayed.
22:06:14 <c50a326> geekosaur: so like: Semigroup a => Val a b = Err a | Cont a b -- or something?
22:06:19 <dminuoso> > foldMap Min [1,2,3,4]
22:06:22 <lambdabot>  error:
22:06:22 <lambdabot>      • Data constructor not in scope: Min :: Integer -> m
22:06:22 <lambdabot>      • Perhaps you meant one of these:
22:06:30 <dminuoso> % import Data.Semigroup
22:06:30 <yahb> dminuoso: (0.00 secs, 0 bytes)
22:06:43 <dminuoso> % foldMap Min [1,2,3,4]
22:06:43 <yahb> dminuoso: ; <interactive>:545:1: error:; * Ambiguous type variable `a0' arising from a use of `print'; prevents the constraint `(Show a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance forall a. Show a => Show (ZipList a) -- Defined in `Control.Applicative'; instance forall a b. (Show a, Show
22:06:46 <dminuoso> Gah.
22:06:53 <dminuoso> % foldMap First [1,2,3,4]
22:06:54 <yahb> dminuoso: ; <interactive>:546:1: error:; * No instance for (Monoid (First Integer)) arising from a use of `it'; There are instances for similar types: instance forall a. Monoid (Data.Monoid.First a) -- Defined in `Data.Monoid'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it; (0.02 secs,)
22:06:55 <geekosaur> c50a326, Semigroupmas you always have at least one value. but presumably ou start with no warnings
22:07:25 <c50a326> oh so that's why Monoid, and can start with empty string or 0 or something, claro!
22:07:35 <geekosaur> also an operation that elicits a warning currently loses its result whle passing on the warning. sometims that is what you want, but it's not what I'd expect in the common case
22:16:53 <dminuoso> Oh. Why is there no `sfoldMap :: Semigroup s => (a -> s) -> NonEmpty a -> NonEmpty s`?
22:17:18 <dminuoso> (Is there a typeclass like Foldable for non-empty data structures?)
22:17:33 <dminuoso> Uhh wait. `sfoldMap :: Semigroup s => (a -> s) -> NonEmpty a -> s` of course
22:18:48 <koz_> dminuoso: That would be good to have in a Foldable1 class.
22:19:19 <koz_> (suitably generalized of course)
22:20:14 <dminuoso> koz_: semigroupoids looks useful. :)
22:20:36 <koz_> dminuoso: 'There's an Edward library for that' is Haskell's 'there's an app for that', I swear.
22:21:08 <koz_> I swear he could find categorical foundations for a pizza-ordering API.
22:21:16 <cocreature> Foldable1 
22:21:23 <cocreature> does have that function
22:21:31 <koz_> cocreature: Where's Foldable1 from?
22:21:36 <dminuoso> koz_: semigroupoids.
22:21:42 * koz_ derp.
22:21:45 <cocreature> https://hackage.haskell.org/package/semigroupoids-5.3.1/docs/Data-Semigroup-Foldable.html#t:Foldable1
22:21:55 <dminuoso> koz_: Your hint was sufficiently good enough for me to conclude what cocreature has already mentioned.
22:21:55 <koz_> OK, I can now add that to my 'use this in all the places' list.
22:23:34 <koz_> And of course it specializes Traverse1 in the exact expected way.
22:27:19 <uptick> hmm weird i see a lot of people using stack to install a package i'm interested in, but i don't actually see this package on stackage's repository o.0
22:27:37 <koz_> uptick: Which package?
22:27:55 <uptick> tidal
22:28:03 <uptick> https://www.stackage.org/nightly-2018-12-14
22:28:10 <uptick> i was checking for it here
22:28:39 <koz_> uptick: This here tidal? https://github.com/tidalcycles/Tidal
22:28:42 <geekosaur> people often develop packages with stack, that are used before formal release
22:28:57 <uptick> ya that's the one
22:29:35 <koz_> I was wondering 'wait, the music streaming services has a Haskell library?'.
22:29:40 <koz_> s/services/service/
22:30:00 <uptick> it's available on cabal's hackage repository, but since i'm on arch, i'm trying to avoid using the stack/cabal/ghc packages from arch's repo 'cuz everything are dynamically linked
22:30:26 <uptick> koz_: ya it's different, this is for music programming :P
22:30:47 <koz_> uptick: You can still git clone, then use stack to build it.
22:30:56 <koz_> They supply a stack.yaml, so it should Just Work (tm).
22:51:05 --- mode: glguy set +v sbanger
23:03:30 <jle`> boo hiss i can't get ghc to not memoize a list so my benchmarks now won't give meaningful results
23:13:36 <tdammers> don't microbenchmark mkay
23:13:43 * tdammers runs away
23:15:42 <jle`> oh i accidentally wrote a chronomorphism
23:15:59 <jle`> now to figure out if stating it that way would help anything
23:16:33 <jle`> rewriting things as a hylomorphism is fairly lightweight, but rewriting it as a chronomorphism makes you draw in Free/Cofree
23:16:45 <jle`> so idk if the cognitive burden of introducing Free/Cofree is worth it
23:18:47 <jle`> might as well do it just for practice
23:57:29 <koz_> Am I the only one who mentally sees 'Coffee' instead of 'Cofree'?
23:57:38 <geekosaur> nope
23:58:00 <koz_> I guess comonads are like hot beverages?
23:58:19 <dminuoso> koz_: I do not believe it until I see a published paper proving this.
23:58:25 <geekosaur> or like caffeine, take your pick
23:58:41 <koz_> geekosaur: In that they keep going and going?
23:59:13 <geekosaur> that, or "logic is an organized way of going wrong with confidence"
23:59:24 <koz_> geekosaur: Who said that?
23:59:50 <geekosaur> Charles Kettering
