00:15:25 * hackage wordpress-auth 1.0.0.0 - Validate Wordpress Cookies & Nonces; Build Wordpress Hashes & Salts  http://hackage.haskell.org/package/wordpress-auth-1.0.0.0 (lysergia)
00:20:26 * hackage servant-auth-wordpress 1.0.0.0 - Authenticate Routes Using Wordpress Cookies  http://hackage.haskell.org/package/servant-auth-wordpress-1.0.0.0 (lysergia)
01:37:55 * hackage bitset-word8 0.1.1.1 - Space efficient set of Word8 and some pre-canned sets useful for parsing HTTP  http://hackage.haskell.org/package/bitset-word8-0.1.1.1 (nshimaza)
01:57:33 --- mode: glguy set +v fcse
02:28:51 --- mode: glguy set +v pastorali
02:31:19 <pastorali> hey, in the example given here on approximating square roots: https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion ("fix (\next guess tol val" etc.) why is "next" the "x" part of "f x"?
02:32:10 <merijn> :t fix
02:32:11 <lambdabot> (a -> a) -> a
02:33:06 <merijn> :t fix `asAppliedTo` (\f () -> True)
02:33:07 <lambdabot> ((() -> Bool) -> () -> Bool) -> () -> Bool
02:33:50 <merijn> pastorali: Fix compute a value by applying a function to it's own result. Which is a bit mindbending the first time you see it
02:34:06 <pastorali> and the fifth time as well :(
02:34:11 <merijn> pastorali: ;)\
02:35:24 <merijn> Those examples seem a bit complicated still, though. I think I wrote out "map" somewhere
02:35:25 * hackage mime-types 0.1.0.9 - Basic mime-type handling types and functions  http://hackage.haskell.org/package/mime-types-0.1.0.9 (MichaelSnoyman)
02:35:51 <merijn> pastorali: Step 1 is the insight that "fix == recursion"
02:36:29 <merijn> pastorali: So you can use fix to implement recursion in languages that don't directly support it (although it'd be weird to support fix without supporting recursion, but anyway...)
02:37:10 <merijn> pastorali: This matters in the untyped lambda calculus, since we often work with functions without a way of naming them (and recursion requires a function to be able to call itself, which usually requires a name!)
02:37:50 <merijn> pastorali: I can't really explain fix, but explaining how fix does recursion (like in your initial example) is fortunately simpler
02:38:08 <pastorali> I'd love that
02:38:11 <merijn> pastorali: The basic trick to "doing recursion without names" is "well, just make the recursive call an explicit argument"
02:38:21 <merijn> pastorali: Here's a slightly simpler example: https://gist.github.com/merijn/b86649a6aa21bd140803
02:39:10 <merijn> pastorali: To implement "map" we want to recursively call "map" inside the function. But if we don't have names, we can't! What name would we even use?
02:40:08 <merijn> pastorali: So, instead we add an additional argument (the recursion call) to our function and use that, but now we need to somehow supply this "recursive" argument. What function does it need? Well, the one we just wrote
02:41:06 <merijn> pastorali: The thing we want to pass to "map'" (in my example) is: our thing applied to the thing we want to pass to map', which is our thing applied to...
02:41:52 <merijn> "fix f = f (fix f)" <- does this make more sense?
02:43:19 <pastorali> I am still trying to wrap my head around your code sample and explanation, it might take a while (thanks so much!)
02:43:25 <merijn> "fix f = f (fix f)" is "the same" as "fix f = let x = f x in x", in the sense that they compute the same result. The second one is just more efficient when compiled with GHC
02:43:47 <merijn> But I think it's a mistake to show fix that way initially as it's even more confusing
02:44:17 <merijn> pastorali: I recommend grabbing a piece of paper, using my "fix f = f (fix f)" implementation and manually write out the reduction of myMap on paper
02:44:44 <merijn> Also, write out the types at every step
02:45:54 <merijn> pastorali: Also, note that a feeling of your brain melting and leaking out your ears is a natural response to exposure to fix before building up some tolerance :p
02:46:25 <pastorali> ahaha
02:46:37 <[exa]> I like that feeling.
02:47:20 <merijn> [exa]: Sure, I just feel that sometimes beginners don't get reassured enough that it's a perfectly natural experience for some tricky things :p
02:48:15 <merijn> Aside from some mathematicians with lots of experience with fixpoints, I don't think anyone ever saw fix and went "yeah...that makes sense" as first reaction :p
02:48:40 <pastorali> it really does feel that way. some haskell tutorials really feel like a recap for people who already understand the concept
02:49:21 <merijn> pastorali: Keep in mind that a lot of wiki and wikibook entries are *old*. Some of them were written when that was actually the case
02:49:54 <pastorali> also I guess it just takes time for this stuff to sink in, surely it'll get easier to understand those things the more "things" I understand
02:50:07 <merijn> pastorali: The original "Haskell tutorial" was written for people coming from SML (another functional language with ADTs, etc.) leading to a name that is (now) hilariously misleading
02:50:18 <merijn> @quote Brend gentle.intro
02:50:19 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
02:51:02 <merijn> pastorali: Pen + paper and manually writing out substitutions (for both types and functions) is a highly underrated method for understanding what's going on
02:51:37 <merijn> The nice thing about haskell is that "naively rewriting code by inlining function definitions" is a completely accurate method for seeing what code means :)
02:53:27 <pastorali> I'm working it out with pen and paper right now.
02:56:33 <merijn> And now for something completely unrelated: Where is this file located? https://github.com/haskell/vector/blob/master/Data/Vector/Unboxed.hs#L1495
02:56:55 <merijn> I'm trying to figure out how unboxed zip and co are implemented, but I can't find the code :\
03:09:38 <merijn> Relatedly: Is there a convenient zip function for Vector that fails if they're different lengths?
03:10:00 <merijn> Or do I just have to compare lengths?
03:54:10 <cocreature> merijn: presumably https://github.com/haskell/vector/blob/master/internal/unbox-tuple-instances
03:57:16 <merijn> cocreature: Yeah, I found it after, I was searching the repo for "unboxed-tuple-instances" which gave zero hits, for obvious reasons xD
04:08:55 <c50a326> line 14 error https://ptpb.pw/bg4d/hs ... I'm sure I've had this exact same thing before and cannot remember the problem lol
04:09:33 <c50a326> Cannot construct infinite type
04:11:54 <c50a326> maybe the `instance Functor (MyList x) where` is wrong, wasn't sure about that... I know for List with the [] notation it's just `instance Functor [] where` but I'm not sure if that is analogous to `instance Functor (MyList x)` here... :S
04:18:34 <c50a326> ah maybe I need to swap around x and xs in the List type definition
04:19:21 <c50a326> oh no that did nothing
04:20:01 <merijn> c50a326: for future reference: It'd help to include the error in the paste ;)
04:20:35 <merijn> c50a326: Anyhoo the error is fairly straightforward
04:20:49 <merijn> c50a326: Your cons takes two argument of different types
04:21:17 <merijn> (x and xs) and your fmap implementation tries to apply the function 'f' to "x", which is not guaranteed to have the same type as xs
04:21:36 <merijn> c50a326: Additionally, the name of the type is MyList, but eh, this is not a list :)
04:22:03 <merijn> c50a326: Presumably you meant to write "data MyList x = Cons x (MyList x) | Empty"?
04:22:31 <c50a326> oh damn, yeah
04:24:49 <pastorali> merijn: I think I finally got it (again, thanks so much). one thing that still eludes me is the expansion from the second line to the third https://paste.ofcode.org/3beT5EXCuVjssWNDaDETyxC (why does "next" to the left of the equality, expand to the definition of the lambda expression?)
04:26:19 <merijn> pastorali: Well, look at line 5, what argument are you passing lambda?
04:26:56 <pastorali> the function next itself.
04:27:33 <merijn> pastorali: Not quite, you're passing it 'next', i.e. the result of passing 'next' to that lambda
04:28:10 <pastorali> oh
04:28:16 <merijn> pastorali: Next is "lambda applied to next", this is a bit easier if you use the definition "fix f = f (fix f)" then the rewriting is simpler
04:41:53 --- mode: glguy set +v PatrickRobotham
04:49:59 <pastorali> merijn: okay, NOW I get it. phew.
04:50:17 <merijn> pastorali: \o/
05:14:40 <nan`> what is unsafe about unsafeRunInterpreterWithArgs?
05:14:57 <nan`> Language.Haskell.Interpreter.Unsafe
05:16:22 <c_wraith> IIRC, I got that added.  I didn't really expect the name of it, though
05:17:12 <c_wraith> Anyway, the "unsafe" thing is that it can pass flags that get rejected by the normal interface because they don't work with a running interpreter.
05:19:02 <nan`> ok
05:19:19 <c_wraith> It was important to have because the normal runInterpreter + set combo didn't work.  ghc has some weird rules about when you can set certain flags
05:22:41 <nan`> still trying to use snap development mode. not sure why my cabal "other-modules" are being added to the args, not sure what to do with them
05:23:16 <nan`> i separated them from '-XHaskell98' but they still cause an error. I remove them and i get unable to load package `integer-gmp-1.0.2.0'
05:23:24 <nan`> i kinda don't know what i'm doing haha
05:35:29 <nan`> c_wraith: if i remove 'other-modules' altogether the interpreter seems to work fine, i was just curious how to make it run if i actually do use other-modules
05:40:52 --- mode: glguy set +v Fraus
05:50:05 <TyrfingMjolnir> How do I get started?
05:56:16 <merijn> TyrfingMjolnir: I think you're going to have to get a little more specific. How to get started with *what*?
06:00:32 --- mode: glguy set +v Fraus
06:02:02 <Fraus> Hey folks! I just asked a question on StackOverflow regarding a begineer Haskell problem, if anyone reading this would take the time to help me I would be very grateful!. https://stackoverflow.com/questions/53904181/why-cant-i-write-the-function-like-this
06:02:47 <sproingie> Fraus: what is the compile error you're getting?
06:03:02 <sproingie> add it to your SO question, that's one reason it's getting downvoted
06:03:24 <Fraus> Oh sorry didn
06:03:29 <Fraus> didn't think about that
06:03:33 <sproingie> (it otherwise looks like a good question, you put down what you tried and even had a working answer)
06:03:49 <Fraus> I don't know if I can copy the error in here without it looking wonky
06:03:56 <sproingie> not here, in SO
06:04:56 <Fraus> Alright, fixed :=)
06:04:59 <sproingie> ah right it's the pattern match
06:05:18 <__monty__> Fraus: Boolean comparison, with (==) does not allow a pattern match on either side.
06:06:02 <sproingie> anyway looks like there's a good answer now
06:06:19 <Fraus> Yeah someone did, damn people are really fast
06:06:21 <Fraus> thanks guys
06:07:29 <sproingie> i kinda like the 'where' version better than the 'case' one.  desugars to the same logic i'm sure.  TMTOWTDI :)
06:08:06 <__monty__> You can also just do the pattern match in the definition of countAces.
06:09:28 <Fraus> Yeah sproingie, guards just "click" better for me, dunno why
06:10:04 <__monty__> Fraus: You can do pattern guards: https://wiki.haskell.org/Pattern_guard
06:10:19 <__monty__> It's just a bit weird, since you can just pattern match in the definition usually.
06:10:31 <Fraus> thanks monty, will look at it
06:11:55 <sproingie> pattern guard probably isn't as elegant for this
06:13:54 <sproingie> SO seems to initially downvote everything these days.  reminds me of wikipedia's revert squad.
06:14:27 <Fraus> So if I want to pattern match while using guards I have to use the "case of" method?
06:14:42 <Fraus> Or just in this specific case?
06:14:55 <merijn> Fraus: Pattern guards lets you mix case + guards
06:15:45 <merijn> __monty__: pattern matching in guards lets you avoid writing out the entire pattern multiple times
06:16:06 <sproingie> pattern matching is either on the LHS of the '=' in a function definition or in a case statement
06:16:12 <sproingie> not an ==
06:16:24 <__monty__> Fraus: Guards are really only about boolean tests on your arguments. (Ignoring pattern guards.)
06:16:53 <merijn> __monty__: Ignoring pattern guards seems a bit arbitrary, though?
06:17:14 <__monty__> merijn: If you only want to distinguish on one of many patterns you mean?
06:17:21 <sproingie> pattern guard is good if you have to "extract" the pattern you're matching somehow.  in this case you're just popping off the head of the list, and you've already done that, so no pattern guard comes to mind
06:17:54 <__monty__> sproingie: | (NormalCard Ace _) <- c = ... Would be the pattern guard.
06:18:05 <merijn> __monty__: If you just have the one pattern, sure
06:18:21 <merijn> __monty__: I have a nice example in the code I'm working on right now, lemme look it up
06:19:20 <__monty__> merijn: It doesn't seem arbitrary to me. Boolean guards are the basic and most common form afaik. Pattern guards are something you only run into after a while.
06:19:38 <sproingie> __monty__: i guess that would be the most direct translation of that == code, yah
06:19:50 <merijn> __monty__: https://bpaste.net/show/bd8b89a059bb
06:20:16 <merijn> I want to catch two case of a constructor within a large pattern without duplicating the entire pattern there
06:21:24 <__monty__> merijn: Yeah that's a good application I didn't immediately think of. But a case expression isn't much worse imo.
06:21:45 <__monty__> Though I guess you can replace boolean guards with case expressions all the same.
06:21:53 <merijn> __monty__: Case expression would be worse because you'd have to duplicate the failure case
06:22:51 <dmwit> How is "merijn" pronounced?
06:23:29 <merijn> dmwit: If you're Dutch or Belgium: Just the way you write it. If your neither, you probably won't pronounce it correctly ever :p
06:23:37 <__monty__> Mer as in mermaid, ijn almost as in Ayn Rand.
06:24:06 <dmwit> Right, I'll just call you Sean then.
06:24:20 <TyrfingMjolnir> merijn: haskell
06:24:37 <dmwit> ?wiki tutorials
06:24:37 <lambdabot> https://wiki.haskell.org/tutorials
06:24:38 <sproingie> "throat warbler mangrove"
06:24:40 <merijn> __monty__: It's only close to "ayn" if you're an Anglophone and thus think that difference is small ;)
06:25:01 <__monty__> merijn: Couldn't think of anything closer though.
06:25:14 <merijn> dmwit: This is reasonable: https://forvo.com/word/merijn/
06:25:15 <__monty__> And I see about the duplication. Guards are pretty cool.
06:25:37 <TyrfingMjolnir> tutorials never helped me learn anything
06:25:43 <TyrfingMjolnir> xmonad + cheat sheet?
06:25:51 <__monty__> TyrfingMjolnir: Maybe something like codewars?
06:26:11 <TyrfingMjolnir> __monty__: What is codewars?
06:26:39 <__monty__> It's a code exercises website, they're pretty common.
06:26:46 <sproingie> programming challenges.  codewars and hackerrank are a couple big ones.
06:26:56 <TyrfingMjolnir> __monty__: Something like ipython?
06:26:57 <Boomerang> Hello! Any idea how to make wai-websocket work? I have been trying the example code at https://hackage.haskell.org/package/wai-websockets-3.0.1.2/docs/Network-Wai-Handler-WebSockets.html#v:websocketsOr with https://www.websocket.org/echo.html but no luck so far, the connection keeps timing out and I don't see anything happening on the Haskell side. What am I missing?
06:27:20 <dmwit> merijn: Sweet, thanks!
06:27:25 <__monty__> TyrfingMjolnir: iPython is just a python interpreter afaik? So the equivalent would be ghci, more or less.
06:27:54 <TyrfingMjolnir> __monty__: Thanks
06:27:57 <dmwit> There is a Haskell plugin for iPython.
06:28:03 <merijn> dmwit: Practice has taught me that Anglophones are very bad at even hearing distinctions between some Dutch phonemes, let alone reproducing them :)
06:28:06 <dmwit> Well, for Jupyter, which is the backend that iPython is a frontend for.
06:28:07 <Axman6> you can use Jupyter with Haskell
06:28:24 <dmwit> merijn: Doesn't stop me from trying.
06:28:49 <sproingie> equivalent of ghci would be the built in python repl.  'cept ghci has autocomplete.
06:28:50 <merijn> Which reminds me...I should register for NL-FP :p
06:29:09 <Axman6> sproingie: python's repl doesn't have autocomplete? D:
06:29:40 <__monty__> It does for me.
06:29:47 <dmwit> Makes me think of that Paul Graham essay on blub. When I read it I hadn't done any FP, and couldn't understand the distinction he was trying to make between a function which increments a number by n and a function which takes n and produces an n-incrementor.
06:30:12 <dmwit> Now that distinction seems natural. But you can't make it natural without trying to understand it over and over and over.
06:30:23 <sproingie> it seems to vary across dists.  osx python doesn't have it.
06:30:55 <Axman6> Boomerang: wireshark? =)
06:31:23 <Boomerang> Axman6: If I could avoid that ^^ That sounds very involved
06:32:13 <__monty__> sproingie: Ah, actually, it seems more like a py2 v. py3 IDLE distinction. Py3 has tab complete on my mac.
06:32:56 <sproingie> ah indeed python3 has completion
06:33:08 <__monty__> dmwit: Sounds a lot like Von Neumann's "Young man, in mathematics you don't understand things. You just get used to them."
06:33:30 <sproingie> sounds like an anti-feynmann
06:33:43 <Axman6> Boomerang: up to you; you coulsd try using netcat to see what the client end is sending initially
06:34:40 <__monty__> sproingie: This quote got me through my "Aaargh, why is this so difficult, I don't like math anymore." phase.
06:35:02 <Boomerang> Axman6: I'll give wireshark a go, any good tutorials around?
06:36:17 <Axman6> not really, you can just fire it up and I think you could bind it to just your loopback interface and find the appropriate connections when you run your client
06:36:33 <sproingie> wireshark will probably decode websocket frames already, it's pretty out-of-the-box ready for most stuff
06:36:46 <Boomerang> Great, thanks! :)
06:37:00 <Axman6> yopu could also wrap the reasult of websocketsOr so it will print the Request it gets sent ands the response your app responds with
06:37:25 <sproingie> the debugging tools in your browser might also snoop websockets.  never used it for that purpose tho, so dunno.
06:37:41 <Axman6> \req resp -> print req >> websocketsOr ... req resp
06:39:05 <sproingie> they'll also show your https traffic, something wireshark won't be so good at
06:39:30 <sproingie> (unless wireshark's doing some kind of MITM)
06:39:46 <Axman6> I was assuming that local testing wouldn't be using HTTPS
06:40:43 <sproingie> probably not, but more tools is always good.  ¯\_(ツ)_/¯
06:41:29 <Boomerang> Yeah, just http for now! I'll try to print the request before handing it off to websockets!
06:42:39 <Boomerang> I hadn't realised Application was just a type alias
06:47:06 <Boomerang> I don't even get a request with websocket, only with http. It must be filtered out before reaching the server somehow
06:48:55 <Boomerang> It does take longer to timeout on the client side than if I was pointing the client to the wrong ip/port. So the presence of the server still matters even though it doesn't receive anything
06:52:25 <Boomerang> Ok, I think I was just testing it wrong :/
06:52:36 * Boomerang face palm
06:52:59 <Boomerang> I was testing with `wss://...` instead of `ws://...` :|
06:53:46 <Boomerang> Thanks for your help!
06:54:02 <sproingie> .oO( wtfs:// )
06:58:25 * hackage thread-hierarchy 0.3.0.1 - Simple Haskel thread management in hierarchical manner  http://hackage.haskell.org/package/thread-hierarchy-0.3.0.1 (nshimaza)
07:13:33 <nan`> does anyone here use the mac haskell platform? I am using the newest version and the stack they ship is incompatible with the cabal-install they ship
07:13:47 <nan`> so it seems, anyway
07:14:30 * Lycurgus has used c. ghc 6, with ports
07:14:30 <nan`> "Installed version of cabal-install (2.4.1.0) is newer than stack has been tested with."
07:15:32 <Lycurgus> stack is meant to have variable of those things so you can manage them
07:16:06 <sproingie> it's just a warning, it shouldn't cause any actual problems.
07:16:55 * hackage heavy-logger 0.3.2.1 - Full-weight logging based on fast-logger  http://hackage.haskell.org/package/heavy-logger-0.3.2.1 (IlyaPortnov)
07:17:01 <nan`> "The following lines from cabal-install output could not be parsed: ..."
07:17:13 --- mode: glguy set +v t4nk004
07:17:32 <sproingie> happens with stock cabal too.  but if it's doing it for everything, maybe do a stack install cabal-install
07:17:45 <t4nk004> What is the meaning of the type ((->) t)?
07:17:47 <sproingie> which will drop it in ~/.local/bin
07:18:12 <sproingie> tnks: a function that takes arguments of type t
07:18:53 <t4nk004> thanks
07:19:18 <nan`> sproingie: a stack install cabal-install?
07:19:26 <sproingie> minus the "a" :)
07:20:13 <sproingie> that'll put a 'cabal' executable in ~/.local/bin that should be in sync with what stack expects
07:20:36 <sproingie> normally you don't want to do 'stack install' (or cabal install for that matter) but for global commands like that it's fine
07:22:18 <sproingie> not sure if it's guaranteed to be a tested version actually.  the warning went away last time i tried it.
07:22:37 <sproingie> it won't affect the HP's version anyway so it can't hurt
07:23:55 <sproingie> (hi cabal and stack, how about versioned machine-readable output?)
07:51:03 <aplainzetakind> When I recursively define an array in this manner, I get exponential time and no memoization: https://gist.github.com/aplainzetakind/5083e81d12d3a9dcbd11531129043872
07:51:57 <aplainzetakind> How do I actually learn what memoization depends on in situations like these instead of relying on trial and error?
07:56:14 <infinisil> aplainzetakind: You need to think of the thunks
07:59:34 <nan`> isn't stack install meant to install the build product of your project into bin
07:59:46 <nan`> nevermind
08:00:38 <aplainzetakind> infinisil: I see the potential thunks, but I don't know how to avoid them.
08:01:04 <infinisil> aplainzetakind: No, you should *not* avoid them
08:01:09 <infinisil> They give you memoization
08:02:30 <infinisil> aplainzetakind: In your code, nothing gets memoized because you always pass along d and t, meaning `gIndex 0 0` is a different thunk than `gIndex 0 0` somewhere within the recursion
08:03:22 <aplainzetakind> So it's because of the parameters? If I hardcode d and t values everywhere, it would run fine?
08:03:26 <infinisil> (same with eArray and such)
08:04:00 <aplainzetakind> I suspected this is the case actually, but isn't there a way to memoize over parameters?
08:04:01 <infinisil> aplainzetakind: Yeah, but that's not very practical obviously. You can also define all of these functions in a `where` clause for a single toplevel definition that takes d and t
08:04:12 <dmwit> aplainzetakind: Yes, or if you had a single outer function that took `d` and `t` and then had `gIndex`, `eLevel`, and `eArray` be mutually recursive definitions under that single lambda.
08:04:35 <aplainzetakind> Hmm. I'll try to work out what that looks like.
08:04:37 <aplainzetakind> Thanks.
08:04:51 <infinisil> :)
08:05:40 <dmwit> aplainzetakind: eArray d t = array ... where gIndex p@(x, y) | ... = ...; eLevel p@(x, y) = ...
08:05:58 <dmwit> Oh, no, gIndex refers to eArray. So you need that part to be recursive, too.
08:06:24 <dmwit> aplainzetakind: eArray d t = result where result = array ...; gIndex p@(x, y) | ... = ...; eLevel p@(x, y) = ... result ...
08:06:56 <dmwit> (Anyway don't call `eArray` again inside its own definition.)
08:09:50 <nan`> stack is broken, it doesn't parse cabal-install output properly =(
08:10:04 <nan`> i even tried an old cabal-install
08:12:43 <dmwit> > let f x = (x+30) `mod` 20183 in iterate (\xs -> map f $ [head xs + 48271] ++ zipWith (*) xs (tail xs) ++ [last xs + 16807]) [0]
08:12:45 <lambdabot>  [[0],[7935,16837],[15870,10348,13491],[3622,13902,19270,10145],[11557,16672,...
08:12:51 <dmwit> aplainzetakind: ^
08:15:10 <mpickering> In a brick application is it a normal design to recursively call the event handler on a custom event to communicate information back up the tree? 
08:15:28 <mpickering> actually ignore me
08:15:31 <mpickering> that just wouldn't work
08:15:59 <aplainzetakind> dmwit: Does this give successive x + y = k diagonals?
08:16:09 <aplainzetakind> x - y = k
08:16:35 <aplainzetakind> nope x + y
08:28:13 <larryba> soonestWorkingDay <- suggestions for less stupid name than this? 
08:28:41 <Tuplanolla> Is `next` too short, larryba?
08:29:26 <monochrom> next day, next working day, the most depressive working day of the cycle >:)
08:29:27 <larryba> Tuplanolla it is misleading. if current day is a working day, it should return back that same day, instead of the following working day
08:29:56 <monochrom> (I have Monday in mind for the lattest)
08:30:26 <monochrom> asap
08:30:30 <Tuplanolla> You can call it `tricky` and explain that in the documentation.
08:30:35 <monochrom> haha
08:30:37 <larryba> soonestWorkingDay :: Day -> Day
08:31:01 <monochrom> asapDay
08:31:14 <Tuplanolla> I would also accept `workingMan'sNow`.
08:31:54 <monochrom> Or just asap if there is not also asapHour, asapYear etc.
08:38:05 --- mode: glguy set +v nnt
08:44:05 <WilhelmVonWeiner> Is there a way to compile Haskell code on OpenBSD? GHC is installed but trying to compile a simple `main = print "Hello world"` gives me an error about strlcpy()
08:56:31 <hpc> i don't know if this is an option for you, but it works great for me on freebsd
09:00:03 <dmwit> aplainzetakind: Yep. I didn't implement your reset at t, but it's easy to add. Also I think I got the boundary condition wrong by d. Both easy to fix.
09:06:07 <WilhelmVonWeiner> hpc: I don't think I'll be migrating operating systems any time soon
09:10:09 <WilhelmVonWeiner> Maybe OCaml or F# work. Thanks
09:22:35 --- mode: glguy set +v Fraus
10:30:56 --- mode: glguy set +v Nasko
10:38:52 <Tuplanolla> There is a great comment in the `X86.Regs` module of `ghc`. It says `Sigh.` and nothing else.
10:55:10 <int-e> Tuplanolla: and it's more than 22 years old.
10:56:37 <hpc> and they say comments in code rapidly become out of date...
10:57:26 <int-e> https://gitlab.haskell.org/ghc/ghc/blob/10521d8418f/ghc/compiler/nativeGen/I386Code.lhs#L109
10:58:54 <int-e> This seems to belong to the initial import of current history, so it's unclear how old it really is.
11:07:49 <elgoosy> hi, what is wrong with this?
11:07:51 <elgoosy> https://pastebin.com/LEjyE4zr
11:08:25 * hackage persistent-mysql-haskell 0.5.1 - A pure haskell backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-haskell-0.5.1 (naushadh)
11:08:47 <lyxia> elgoosy: filter must be applied to a function
11:08:59 <lyxia> oh wait that's afunction
11:09:43 <lyxia> length expects a list, but filter is giving it a function
11:10:29 <lyxia> these operators associate like this   ((== 0) . length . filter) $ elem x
11:10:29 <Solonarv> elgoosy: what you wrote is '(==0) (length (filter (elem x)))'
11:11:04 <lyxia> You probably meant   (== 0) . length . filter (elem x)
11:11:52 <elgoosy> oh 
11:12:04 <elgoosy> thank you, wanna be fancy with $ and got caught
11:12:05 <elgoosy> :)
11:13:54 <elgoosy> no, still complains :/
11:14:10 <lyxia> :t length
11:14:11 <lambdabot> Foldable t => t a -> Int
11:14:21 <lyxia> it certainly doesn't help that length is generalized...
11:14:50 <lyxia> :t \x -> (== 0) . length . filter (elem x)
11:14:51 <lambdabot> (Eq a, Foldable t) => a -> [t a] -> Bool
11:15:18 <lyxia> what do you want your function to do
11:15:35 <elgoosy> but my type signature is more concrete Int -> [Int] -> Bool.
11:15:39 <elgoosy> I dont get it..
11:15:46 <lyxia> elem x :: [a] -> Bool, so filter (elem x) :: [[a]] -> [[a]]
11:15:53 <ClaudiusMaximus> @check \xs -> ((== 0) . length) xs == null xs
11:15:56 <lambdabot>  +++ OK, passed 100 tests.
11:16:21 <lyxia> elgoosy: note [t a] in the type lambdabot gave above
11:17:03 <hpc> > filter (elem 5) [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]
11:17:05 <lambdabot>  [[1,2,3,4,5]]
11:19:02 <elgoosy> i see
11:19:25 <elgoosy> what if I wanted to have this function in where block
11:19:56 <elgoosy> i can't right? cause it needs this type signature explicit  (Eq a, Foldable t) => a -> [t a] -> Bool
11:20:14 <hpc> it'll infer that type, if your function is correct
11:20:56 <elgoosy> that's true
11:20:59 <elgoosy> thank you guys
11:21:18 <Solonarv> and you can write type signatures in a where block just fine
11:46:23 <seishun> if I define an infinite list of generated values, will it memoize indexes that I access?
11:46:49 <hpc> if the list you make is monomorphic and stays in scope the whole time, yes
11:47:31 <seishun> I see, cool
11:47:33 <seishun> even in ghci?
11:47:41 <hpc> yes
11:47:44 <seishun> yay
11:48:10 <hpc> "memoization" uses the fact that thunks aren't recomputed every time
11:51:21 --- mode: glguy set +v shiro[cloud]
11:53:51 <bwe> I am wondering what the Aeson error msg wants to tell me with   Left "Error in $.s: expected Int, encountered String"
11:55:11 <bwe> What does the $.s refer to? I couldn't find something in the documentation.
11:55:55 <Rembane> I wonder if it is a template string that hasn't gotten the data it needs.
11:56:44 <larryba> re my earlier question about function name and its semantics, what do you think of this? and can you figure out what it does, just by looking at the signature? earliestBusinessDay :: TimeOfDay -> LocalTime -> Day
11:57:04 <larryba> just by looking at the signature and name
12:05:58 <Solonarv> bwe, Rembane: $.c tells you which field the error occured in. $ refers to the top-level value, so $.c is the top-level object's 'c' field.
12:06:36 <Rembane> Solonarv: Sweet! 
12:07:21 <Rembane> Solonarv: Is this documented anywhere?
12:08:19 <lyxia> I don't think it is
12:08:46 <Solonarv> I have no idea, actually. I inferred it from seeing a bunch of messages where the path was more obviously a path, like '$.foo.bar'
12:08:59 <lyxia> I think it might be a convention from elsewhere
12:09:16 <Solonarv> That was my guess too
12:09:24 <geekosaur> that $,.s tuff seems javascript-y
12:09:51 <Rembane> Hm... is it to succinct to be something from the xpath universe?
12:10:15 <Solonarv> it's certainly valid JS syntax, since $ is a valid identifier in JS
12:11:05 <Rembane> Indeed, $ leads my associations to jQuery. 
12:12:44 <pavonia> It's JSONPath syntax https://goessner.net/articles/JsonPath/
12:15:05 <lyxia> larryba: What are you doing with both a TimeOfDay and a LocalTime (which contains a TimeOfDay)?
12:17:51 <larryba> not that obvious? earliestBusinessDay businessHourEnd currentTime
12:18:57 <Solonarv> I'm registering on Hackage to upload packages, is there anything I need to include in the request email besides the request itself?
12:19:59 <hpc> the hackage website should tell you everything you need to do
12:20:45 <larryba> larryba, I think function name and signature should tell the whole story, without having to read additional documentation. so maybe I need a better name? 
12:20:59 <larryba> that was for lyxia, not for myself :)
12:21:03 <Solonarv> Yes, I've read that. I'm specifically talking about the email to trustees@hackage.org where I request to be added to the uploaders group.
12:21:34 <hpc> ah, don't think so then
12:23:44 <lyxia> larryba: I disagree, a comment would be pretty good
12:24:51 <larryba> it would, but ideally it should be obvious what the function does without it
12:24:59 <lyxia> an API without comments looks quite daunting
12:26:06 <larryba> comments or documentation should be included, but a good name and signature should ideally tell the whole story on their own
12:26:24 <geekosaur> ...as if
12:26:40 <larryba> :t take
12:26:41 <lambdabot> Int -> [a] -> [a]
12:26:45 <larryba> :t takeWhile
12:26:47 <lambdabot> (a -> Bool) -> [a] -> [a]
12:26:58 <bwe> Solonarv: OK, got it.
12:27:14 <Rembane> My favourite is cycle. It has the same type signature as id.
12:27:32 <lyxia> these are exceptions rather than the norm IMO. They benefit from being part of the standard library.
12:28:03 <int-e> > cycle []
12:28:03 <geekosaur> that lads to APIs usable only by whoever came up with them, because not everyone works the same way,. for sufficiently simple stuff you can do it, sure, but by the time you're up to complex applications, you are not getting away with name-and-type as full docs
12:28:05 <lambdabot>  *Exception: Prelude.cycle: empty list
12:28:29 <Solonarv> lyxia: I agree; while it's often possible to correctly guess a function's behavior from name + type, lack of documentation for a library makes it very hard to find out what the "entry points" are and how the functions fit together
12:28:33 <int-e> > fix cycle
12:28:36 <lambdabot>  *Exception: <<loop>>
12:30:22 <Solonarv> well, that's not surprising.
12:33:30 <kaol> I'm stuck with using type variables. https://github.com/kaol/heist/blob/d6cd90c58ea0982330bc598d99664fd0e483fe4d/src/Heist/Internal/Types/HeistState.hs#L431 I added a second type variable to HeistState but how can I pass it in that definition? I have only a HeistT n available instead of a HeistT n m.
12:47:12 <dmj`> kaol:  you'd have to make it present in HeistT as well
12:48:10 <dmj`> kaol: once you put a free variable inside of a datatype that is used by other data types, you'll have to bubble it up to all of them. 
12:48:29 <lyxia> it looks like StT should not depend on the monad being transformed
12:48:52 <kaol> I don't know where to put my m. HeistT n m would be a kind error.
12:49:01 --- mode: glguy set +v rezzme
12:49:40 <lyxia> There isn't actually any place to put it
12:51:17 <geekosaur> you're trying to pull off type level side effects. they're no more acceptable than value level side effects...
12:52:05 <geekosaur> (wel, in a certainw ay fo thinking about it)
12:54:50 <dmj`> kaol: why add a new parameter in the first place?
12:55:11 <larryba> is it guaranteed that read won't throw exception in here? https://pastebin.com/JCykyFXU
12:55:59 <glguy> larryba: That should be fine, but instead you can just use Text.Read.readMaybe
12:56:02 <dmj`> larryba: Text.Read.readMaybe 
12:56:25 <dmj`> would work for all Read a => a
12:57:11 <larryba> I'll use readMaybe, but re my question, it is laziness that guarantees this is safe? read xs isn't evaluated, until we reach code that evaluates int?
12:57:39 <kaol> dmj`: Because the original HeistState n implementation uses "_compiledSpliceMap   :: HashMap Text (HeistT n IO (DList (Chunk n)))" and I wanted to generalize IO to some MonadIO m.
12:58:57 <lyxia> larryba: right
13:01:20 <kaol> I suppose I'll try to define "data HeistState n = forall m. MonadIO m => ..." and see where I can get with that. If I can come up with how to use compiledSpliceMap without exposing m.
13:05:32 <dmj`> kaol: who knew html generation could be so difficult
13:05:42 <dmj`> kaol: have you tried lucid / blaze ?
13:06:03 <dmj`> @package type-of-html
13:06:03 <lambdabot> http://hackage.haskell.org/package/type-of-html
13:06:12 <dmj`> also looks very cool and is the fastest
13:06:25 * hackage morphisms-functors 0.1.2 - Functors, theirs compositions and transformations  http://hackage.haskell.org/package/morphisms-functors-0.1.2 (iokasimovmt)
13:08:38 <kaol> dmj`: That's not helpful.
13:08:56 <dmj`> kaol: do you absolutely have to use heist?
13:09:57 <kaol> I came here to ask about a programming language feature.
13:16:06 <dmj`> kaol: I thought you wanted to generate HTML, just trying to help.
13:16:48 <kaol> I wanted to write a patch.
13:17:18 <safinaskar> do you know what is worse that camelCaseStartingFromSmallLetter?
13:17:49 <safinaskar> it is aLL_CAPS_EXCEPT_FOR_FIRST_LETTER
13:18:05 <safinaskar> look here: https://hackage.haskell.org/package/ghc-8.6.1/docs/PrelNames.html#v:pRELUDE
13:20:15 <kaol> I do happen to also use heist to generate html but it's in no way precluded by something that's at most just an inconvenience in the library. I was just mystified by the issue I ran in to. And I think I now know better what's up with that.
13:26:13 --- mode: glguy set +v jmmoore
13:43:46 --- mode: glguy set +v jmmoore
13:56:18 <monochrom> Yeah I agree all caps except first letter is an eye sore (if you don't misread it) and a trap (if you misread it).
13:58:44 <hpc> it's optimized for typing
13:58:53 <hpc> you just title-case every identifier and press capslock to switch :D
13:59:17 <monochrom> haha
13:59:44 <hpc> what we really need is
13:59:51 <hpc> CoNsTrUcToRs
13:59:58 <hpc> iDeNtIfIeRs
14:00:10 <Tuplanolla> Is there such a word in the English language that replacing the initial i with an l or vice versa is also a word?
14:00:18 <Tuplanolla> I conjecture not.
14:00:19 <monochrom> No I have a better idea. Camel snake case: Camel_Snake_Case.  Best of both worlds.
14:00:45 <hpc> Tuplanolla: homoglyph is a more general term that might apply
14:01:19 <hpc> monochrom: http://www.freakingnews.com/pictures/60500/Poisonous-Camel-Snake--60626.jpg
14:01:51 <monochrom> Excellent
14:02:18 <monochrom> No wonder people just fish for solutions on the Internet.
14:02:53 <Tuplanolla> Is there such a homoglyph in the Latin alphabet that is inhabited by two different letters with different casings?
14:03:00 <Tuplanolla> I conjecture not.
14:03:30 <monochrom> Back in the old days we didn't have all combinations of problems so if you are given an assignment that says "implement Newton's method in Lisp" you learn Newton's method and you learn Lisp, separately, then you combine them yourself.
14:03:31 <hpc> Tuplanolla: take away serifs and Il1 are damn near identical
14:03:56 --- mode: glguy set +v cole-k
14:04:02 <Tuplanolla> Those are covered by the first conjecture, hpc.
14:04:05 <cole-k> Tuplanolla: iamb and lamb
14:04:11 <hpc> you had to carry your punch cards uphill both ways in the snow
14:04:29 <monochrom> But now the internet does have all possible combinations. If it's "implement Newton's method in Lisp but you have to use call/cc but it has to be emacs lisp not common lisp" you just enter that whole thing into Google and you will get it because someone has done it.
14:04:39 <cole-k> also if you allow proper nouns, ion and Lon
14:04:49 <hpc> Tuplanolla: oh, you mean a specific word and not a name for the concept
14:04:53 <Rembane> When I worked at a call center we were thinking of only handing out passwords consisting of a combination of the characters IO10l|
14:05:11 <monochrom> hahaha
14:05:25 <Rembane> monochrom: You just need something that evaluates the code that Google gives you. 
14:05:34 <hpc> the best password generator i ever saw used exclusively lower-case letters and numbers that you could type with one hand
14:05:39 --- mode: glguy set +v jerzy
14:05:50 <Rembane> Which hand?
14:05:55 <cole-k> Rembane: https://www.xkcd.com/1105/
14:06:00 <Tuplanolla> It seems my conjecture is false, cole-k. However, I wouldn't mind replacing "English" with "English without iamb".
14:06:02 <hpc> i forget, probably left
14:06:09 <hpc> so you can also mouse
14:06:21 <monochrom> @quote monochrom semantics.of.IO
14:06:21 <lambdabot> monochrom says: <monochrom> great way to answer a semantics question by commenting on the font  <monochrom> "what is the semantics of IO?" "the I may be narrower than O in some fonts, and same width
14:06:22 <lambdabot> in some other fonts"  <monochrom> "on very old typewriters, it also denotes the number 10 (ten), for those of you looking for a denotation" XD
14:06:36 <Rembane> cole-k: Awesome! :D
14:07:05 <Tuplanolla> Clearly our definition of English is too strong if it doesn't let us prove nice theorems about it.
14:07:23 <hpc> @remember Tuplanolla Clearly our definition of English is too strong if it doesn't let us prove nice theorems about it.
14:07:23 <lambdabot> Nice!
14:07:31 <cole-k> no iambs means no Shakespeare :(
14:08:02 <Rembane> What's the operation for weakening english?
14:08:15 <Tuplanolla> Remove the word iamb, Rembane.
14:08:21 <larryba> can readMaybe be implemented with read? from what I understand, non-IO code can't catch exceptions, so I guess it can't be? and yet readMaybe exists, including for custom read types
14:08:31 <Tuplanolla> It's very important for programming unambiguously.
14:08:32 <monochrom> No cannot.
14:08:40 <Rembane> Tuplanolla: Oh. What's an iamb?
14:09:04 <Tuplanolla> Ask our iamb expert, cole-k.
14:09:20 <Rembane> Sure thing! 
14:09:25 <Rembane> cole-k: What's an iamb?
14:09:31 <monochrom> reads is the fundamental one. From it you get readMaybe and read and readIO and readLn.
14:10:01 <cole-k> Rembane: it’s a way of syllable stress
14:10:24 <cole-k> e.g. for poetry
14:11:11 <Rembane> cole-k: Does it have something to do with the mapping between spelling and pronounciation?
14:11:47 <monochrom> Um, "metrical foot". I must be misinterpreting it. Like "joulish BTU".
14:12:27 <larryba> monochrom I see
14:12:28 <cole-k> Rembane: not particularly, I think. I probably gave a poor definition. A common meter is iambic pentameter
14:12:33 <geekosaur> 'foot' here is the poetry meaning
14:12:37 <monochrom> Oh cool a plural form is "iambuses"
14:12:39 <hpc> fun fact: a joule is actually "ghoul" as spoken by the creator of "gif"
14:12:56 <monochrom> (Because a singular form is "iambus")
14:13:24 <Rembane> A bus filled with jam must be good.
14:13:27 <cole-k> Which is stringing together five iambs (short syllable followed by long syllable)
14:13:50 <monochrom> iambdabus calculus magnus maximus optimus
14:14:43 <Rembane> cole-k: Interesting. Where does this show up? 
14:15:07 <geekosaur> it'd be jargon if not for Shakespeare >.>
14:15:54 <Rembane> Why is Shakespeare's fault?
14:15:56 <cole-k> Rembane: it’s a poetic meter, typically. So certain poems will conform to the format. You’d use the term as jargon to describe it
14:15:56 <Rembane> +it 
14:16:08 <Rembane> cole-k: Aha. Cool. Got it! 
14:16:13 <monochrom> Wait, is BTU energy/time? Should I have said "wattish BTU" instead?
14:16:46 <geekosaur> Rembane, because he's popular enough that various bits of poetry jargon have leaked a bit
14:16:51 <cole-k> Sorry I’m slow, on mobile - explaining poetry is not my forte normally
14:17:21 <Rembane> geekosaur: Oh. From Shakespeare into the english language? Like somekind of spoken, rhyming zombie infection?
14:17:55 <monochrom> And SPJ and Erik Meijer are also popular enough so that Haskell jargons like "monad transformer" leaked out too.  We are all familiar with this. >:)
14:22:42 <__monty__> Where did monad transformer leak out to?
14:23:46 <rain2> https://en.wikipedia.org/wiki/Church_encoding#Church_Booleans
14:24:00 <rain2> i don't understand why there's 2 versions of not, one for strict and one for lazy
14:24:03 <monochrom> I was exaggerating. So maybe not monad transformers per se. But just look at all the "monad in python/java/ruby/php" blogs.
14:24:20 <rain2> don't both work for both? why does it give two
14:25:59 <monochrom> OK if I have "(\a -> \b -> a) 0 undefined" if you use an eager order you say "let me evaluate the two parameters early" and you will get undefined and you won't get 0.
14:26:16 <monochrom> (and of course replace "0" and "undefined" by suitable church encoding)
14:26:57 <monochrom> If you work in an eager language you have to go out of your way to regain short-circuiting.
14:30:15 <monochrom> Hrm maybe my answer isn't good.
14:31:20 <__monty__> Does it have anything to do with laziness? Cause both of those work in haskell.
14:31:58 <Rembane> Aren't the logic operators usually lazy in programming languages? 
14:32:27 <rain2> wait isn't it a theorem that lazy always works if strict works?
14:32:45 <merijn> rain2: That's definitely true, yes
14:33:12 <rain2> so I guess the wiki claims are false
14:33:18 <larryba> Rembane, yes, but functions and operators you define yourself usually aren't.
14:33:21 <merijn> rain2: Any terminating strict computation remains terminating when made lazy (albeit with different performance) but not vice versa
14:34:30 <Rembane> larryba: Indeed. Unless I implement them in terms of the lazy ones? 
14:36:19 <merijn> Rembane: Even then
14:37:16 <merijn> Rembane: Most languages implement (overloaded) operators as regular functions/methods which will strict call by value, forcing their arguments, regardless of the implementation you use
14:38:02 <__monty__> Hmm, both definitions of not work in python too. Am I missing something or is the wiki plain wrong?
14:38:18 <rain2> i think we need to correct the wiki page
14:39:00 <rain2> it seems that with your python test , we found that both versions work in both 
14:40:23 <Rembane> merijn: Interesting. I thought that if I do something like: f(a_1, ..., a_N): a_1 && ... && a_N; then the body of the function would only be evaluated until the first false value, even if say the values are functions... or have I gone down the wrong rabbit hole? 
14:40:33 <geekosaur> did you test with all variants? in particular, all combnatios of nontermination?
14:40:33 <__monty__> I'm trying to think about the implications of bottom as an argument.
14:40:50 <merijn> Rembane: In most mainstream language a_1 through a_N are evaluated before 'f' is even called
14:40:59 <rain2> in a strict calculus, f x y with bottom if either of x or y are bottom isn't it?
14:41:23 <__monty__> Yes.
14:41:29 <Rembane> merijn: Cool, I suppose the languages where I learned these semantics aren't mainstream enough. :)
14:41:36 <Rembane> merijn: I blame Perl! 
14:41:40 <merijn> Rembane: Which language was that?
14:42:05 <merijn> Rembane: Ah, I don't know Perl, but certainly this applies to Python, Ruby, C++, Java (does that even support overloading operators?)
14:42:46 <rain2> someone want to repair the article?
14:42:51 <rain2> i dont have a wiki account
14:43:24 <larryba> also applies also to C, Common Lisp, C#. besides haskell, I've never used a language that doesn't evaluate all the functions arguments. I don't know perl well either, so I can't comment
14:43:28 <__monty__> Rembane: In python that'd be kinda lazy too if you use the shortcutting boolean operators and the arguments are reference values like functions.
14:43:50 <Rembane> __monty__: I was thinking that. Hm... 
14:48:06 <drdo> Am I the only one that always gets "Error: unknown pseudo-op: `.subsections_via_symbols'" when trying to do a fresh stack setup?
14:48:22 <drdo> On several combinations of machine and distribution
14:55:17 <bbear> hello
14:57:47 <bbear> I am willing to chat a bit
15:04:04 <Solonarv> bbear: hello! what do you want to chat about?
15:06:03 <hpc> and your answer has to be haskell :D
15:06:23 <merijn> hpc: Naah, type theory, functional programming, etc. works too :p
15:06:51 <Rembane> Dependently typed programming should work too
15:07:19 <Levy[m]> Not yet
15:07:22 <Levy[m]> too early
15:07:42 <leifmetcalf> Model> Advantage2
15:07:43 <Athas> Dependently typed non-functional programming!
15:07:43 <leifmetcalf> ware> 1.0.431.us (4MB), 11/14/2017
15:07:43 <leifmetcalf> Active layout file> qwerty.txt
15:07:44 <leifmetcalf> b keys mode> win
15:07:44 <leifmetcalf> lay speed> off=0, slow=1, normal=3, fast=9> 3
15:07:45 <leifmetcalf> us report play speed> off=0, slow=1, normal=3, fast=4> 3
15:07:45 <leifmetcalf> yclick status> on
15:07:46 <leifmetcalf> Toggle tone status> on
15:07:46 <leifmetcalf> red macros> 0
15:07:47 <leifmetcalf> Keys remapped> 0
15:07:59 <merijn> Athas: So...Ada?
15:29:58 --- mode: glguy set +v ACheesyName
15:32:24 <ACheesyName> I have a question about aeson (the JSON parser). Suppose I have JSON like this: {"type":"foo","payload":{more JSON}}. where I need to inspect that type==foo before futher parsing of the payload. can this be parsed generically? what type should I have the payload field?
15:33:08 <Welkin> use the monad instance
15:35:40 <Solonarv> ACheesyName: are you asking "can aeson figure out a decoder for this"?
15:36:02 <Solonarv> I don't think so, you'll have to write the parser yourself; but that's not very difficult
15:37:02 <ACheesyName> I guess I'm asking of aeson can leave part of the input unparsed. like what you get if you have a json.RawMessage field in Go
15:37:14 <Welkin> parse it as a Value
15:37:17 <jle`> ACheesyName: also remember that aeson parses the entire thing as a JSON AST before doing any parsing into types
15:37:23 <jle`> into haskell types, i mean
15:37:26 <Solonarv> Yeah, aeson doesn't care if there are "unused" felds
15:38:26 <jle`> ACheesyName: so what you can do is check for "type", and then based on the result, use a different parse-into-your-type parser for "payload"
15:40:25 <Welkin> ACheesyName: like this https://hastebin.com/renutodena.hs
15:42:09 <ACheesyName> jle`: ok thanks I'll try that. I just wasn't sure what type to use for payload but I'll try Value
15:42:55 <jle`> ACheesyName: if you're writing a 'Parser', you don't have to commit to a type
15:43:07 <jle`> you can use the Monad instance, like Welkin posted
15:43:31 <jle`> first check for the value of "type"
15:43:34 <ACheesyName> ah well I don't want to use a parser I want to use generics
15:43:43 <jle`> and then depending on the value, dispatch the parser you want
15:43:57 <jle`> ACheesyName: generics is just a very limited way of writing a parser
15:44:10 <jle`> if you mean GHC.Generics, that is
15:44:25 <ACheesyName> I'll try to let it parse into a Value, see what happens, then consider other options
15:44:43 <Welkin> it's always better to write your pasrer by hand
15:44:46 <jle`> aeson's Generic interface is basically just abstracting over a very common type of Parser
15:44:48 <Welkin> then you have complete control over it
15:44:54 <Welkin> parser*
15:44:58 <bbear> Solonarv: hpc: merijn: I 've more or less mastered my python / django / pytest / MySQL stack and I think I am doing a good job at it. Now I am asking myself "what's next ?"
15:45:11 <jle`> it's useful when your Parser is simple and follows common/basic rules, but if it doesn't, it's better to write your own parser by hand
15:45:26 <jle`> either way you're writing a Parser
15:45:31 <bbear> Wondering how to structure my career
15:45:38 <jle`> one directed by Generic, and other directed by hand
15:46:14 <Welkin> bbear: graduate to postgres, then learn graph databases, wide column stores, document stores, partitioning and replication, database tuning, and then shift into data science and learn statistics, machine learning, deep learning
15:46:35 <Welkin> with some data warehousing on top
15:46:47 <Solonarv> is there documentation somewhere about cabal's "script" feature? It doesn't seem to be mentioned on cabal.readthedocs.io
15:47:04 <hpc> bbear: learn operating system stuff
15:47:37 <hpc> or learn how to do packaging correctly
15:47:42 * Welkin slaps the + off of hpc
15:47:43 <hpc> both of those are rare skills nowadays
15:48:08 <bbear> i'm good at packaging
15:48:14 <isBEKaml> hpc: do you have an example of good packaging? :D
15:48:27 <isBEKaml> Everyone seems to have an opinion that can rankle others
15:48:40 <Welkin> isBEKaml: rpm?
15:48:43 <hpc> i actually don't
15:48:50 <hpc> rpm is pretty good, its syntax is heinous
15:49:12 <bbear> yes
15:49:21 <isBEKaml> Welkin: Yeah, hpc said it already. specfiles -_-
15:49:22 <bbear> I packaged something for centOS one day.
15:49:24 <hpc> i like how rust packages are packaged, except for the part where they're in perpetual beta
15:49:51 <hpc> i like writing a cabal file and a stack.yaml file in haskell, it keeps the package definition and build environment nice and separate
15:49:57 <hpc> but really reproducible
15:50:17 <bbear> haskell packaging is definetely not the worst.
15:50:37 <bbear> Ive got no idea about deployment though.
15:50:41 <hpc> getting version numbers right and deprecations, and figuring out how to avoid making mistakes
15:52:02 <hpc> maybe learn networking - i am in the middle of that atm
15:52:39 <Solonarv> cabal file + cabal.project.freeze does that too, no need to pull in stack
15:53:03 <hpc> yeah, when new-* stabilizes i am probably going to drop stack
15:53:11 <Welkin> I already did
15:53:22 <Welkin> just switch
15:53:25 <Solonarv> Same. All I use stack for now is installing GHC
15:53:55 <Rembane> I use Stack for rerunning the typechecker when I have changed a file, how do you do that using only cabal?
15:54:11 <Solonarv> ghcid --command 'cabal new-repl'
15:54:47 <bbear> At some point it seems like coding/learning new skills is like doing plumbing for another part of computer science.
15:54:49 <Solonarv> so technically not *only* cabal, I suppose :>
15:55:38 <Welkin> Rembane: use any file watcher in existence
15:55:38 <bbear> I mean I need to learn something that I feel has a purpose.
15:55:43 <Welkin> there are countless ones
15:56:00 <Rembane> Welkin: Fair enough. The good things with stack is that it is in front of my nose.
16:05:38 <bbear> what book should I dig ?
16:09:38 <Welkin> for what?
16:40:26 <ACheesyName> here is what I have so far: https://repl.it/repls/CarefulAnchoredBlocks note that aeson does not work on repl.it at all. the compilation error I get now is that `decode` cannot handle `Value`, only `ByteString`. how do I decode further from a `Value`? it looks like it should be possible given the definition of FromJSON
16:41:21 <Welkin> your code looks like lisp
16:41:43 <Welkin> you don't need nearly so many parentheses, as a side note
16:44:06 <hpc> ACheesyName: http://hackage.haskell.org/package/aeson-1.4.2.0/docs/Data-Aeson.html#v:decode-39- vs http://hackage.haskell.org/package/aeson-1.4.2.0/docs/Data-Aeson.html#v:fromJSON
16:45:06 <Welkin> your types look a little insance there
16:45:23 <Welkin> Maybe (Either (Maybe ...) (Maybe ...))
16:45:27 <Welkin> insane*
16:48:02 <amalloy> also that if/else/if/else could be `case messageType c of ...`
16:50:40 <zzz> i can't seem to understand how "stack test" works. I can't seem to get constructors from Main.hs in scope
17:24:29 <dmj`> Will GHC spawn a new OS thread even if I've compiled without -threaded when performing foreign calls into C
17:27:17 <geekosaur> if it's "safe", yes.
17:29:44 <c_wraith> also, only if it needs to.
17:30:00 <c_wraith> it keeps a pool of OS threads for native calls around.
17:30:14 <c_wraith> it reuses them instead of spawning new ones, if it can.
17:33:50 <koz_> Is there a default name for Shake build scripts? Kinda like how if you run 'make' without specifying a file, it'll default to a file named 'makefile'.
17:40:17 <dmj`> geekosaur: I'm noticing on htop 16 processes for this Haskell program, even though -threaded is not enabled. Each is using 1.0T VIRT memory (think this is a ghc bug actually), then each process has high residency 545M. And there's 16 of them. This doesn't mean the residency is really 545M * 16 right... It says I'm only using 4GB so don't think so
17:40:52 <geekosaur> 1TB is an htop stupidity, it doesn't underrstand the 2-stage allocator
17:41:11 <geekosaur> and residency doesn't account for shared pages
17:41:14 <dmj`> c_wraith: these are capabilities right? When I first ran my program I dumped getRTSFlags, this said capabilities were at 0
17:41:29 <geekosaur> each thread has that much in its address space, not that much dedicated to itself
17:42:04 <dmj`> geekosaur: How is it possible to use multiple threads if -threaded isn't enabled though
17:42:08 <geekosaur> mdoern memory management is tricky enough that even htop gets it wrong
17:42:18 <geekosaur> becauwse the I/O manager is threaded
17:42:39 <geekosaur> "-threaded" limits threads available to haskell code, not to the process
17:42:57 <geekosaur> and the I/O mnager always uses threads, including a manager thread and a pool for FFI calls
17:43:25 <geekosaur> (note that the runtime itself makes a number of FFI calls)
17:45:45 <dmj`> geekosaur: if the execution is serial, wouldn't that imply only one FFI call can be made at a time, assuming no forkIO is being called
17:46:41 <dmj`> geekosaur: and is it possible to have -threaded enabled, but not have the parallel GC enabled?
17:47:08 <geekosaur> +RTS -qg
17:47:12 <geekosaur> (with no parameter)
17:48:18 <geekosaur> I can;'t tell you if it might e.g. do something "clever" with sparks. or if there's anything actually e.g. treating pool allocation differently in the non-threaded runtime
17:49:38 <geekosaur> at some point you'll want to ask in #ghc ... and then learn the non-threaded runtime is more or less "if it works, that's nice"
17:50:46 <dmj`> For this code I'm running (hmatrix), without -threaded, it would seem that multiple OS threads are being created despire the fact all of the FFI code that hmatrix uses is unsafe...
17:53:16 <dmj`> geekosaur: thanks for the help, I'll try #ghc
18:06:40 <dmj`> geekosaur: +RTS -N -qg` is twice as fast, and uses much less heap. Really think parallel gc should be off by default...
18:06:58 <droplet> is there a way to convert Map Int b -> IntMap b other than going via ordered lists?
18:12:09 <Gurkenglas> "IM.unions . M.mapWithKey IM.singleton" maybe, though lambdabot says unions takes a list and hackage says a foldable
18:12:21 <Gurkenglas> Why doesn't fromList take a foldable?
18:14:41 <Gurkenglas> Though I'd be disappointed if going through a list isn't fused away by the compiler
18:17:02 <geekosaur> because fromList implements OverloadedLists? suppose there ae ways to make that work out but it's risking even worse type errors than overloaded literals normally get you
18:18:16 <Welkin> I don't see wha'ts wrong with `IntMap.fromList . Map.toList`
18:20:00 <geekosaur> I don't either, really, since the two are backed by different structures so there's no way to somehow swap the backing while keeping the shape
18:23:16 <ACheesyName> if I "import qualified Data.ByteString" I get Module ‘Data.ByteString’ does not export ‘Lazy’. if I "import qualified Data.ByteString.Lazy" I get No module named ‘Data.ByteString’ is imported. how to win?
18:23:37 <Welkin> import both qualified
18:23:45 <Welkin> import qualified Data.ByteString as BS
18:23:51 <Welkin> import qualified Data.ByteString.Lazy as LBS
18:24:27 <ACheesyName> so these things cannot be imported without "as"?
18:24:36 <Welkin> they can
18:25:08 <Welkin> but this is the standard way to keep your namespace clean
18:25:23 <Welkin> you could drop the `as` part
18:25:28 <Welkin> then you need to use the fully qualified name
18:25:45 <Welkin> `Data.ByteString.length` vs `BS.length`
18:26:25 * hackage haskseg 0.1.0.0 - Simple unsupervised segmentation model  http://hackage.haskell.org/package/haskseg-0.1.0.0 (TomLippincott)
18:26:48 <geekosaur> also you seem confused about the difference between the two? "Lazy" is not a type qualifier of some kind, it's part of the module name 
18:27:57 <ACheesyName> ah I needed Data.ByteString.Lazy.ByteString not Data.ByteString.Lazy alone
18:29:25 * hackage haskseg 0.1.0.1 - Simple unsupervised segmentation model  http://hackage.haskell.org/package/haskseg-0.1.0.1 (TomLippincott)
18:34:09 <droplet> Welkin, geekosaur: fair enough, for some reason I guessed they're similar internally so there would be a more direct
18:34:12 <droplet> way
18:43:32 --- mode: glguy set +v gksato
20:03:56 <iqubic> Is there a better way to do this: http://dpaste.com/3W6PSTD
20:04:26 <iqubic> Having to repeat the same constraint so many times over in every single constructor is kinda a big pain.
20:05:28 <iqubic> I don't actually need a GADT because all of the constructors of AST will have those same constraints. However, I'm unsure of how to get the same effect without a GADT.
20:07:38 <iqubic> Because I want to be able to create an eval function like this:  http://dpaste.com/18KVBAD
20:08:25 <iqubic> However, I'm not sure how to get that pattern matching effect without using a really ugly GADT where ever constructor has the same two constraints.
20:09:15 <[Leary]> What's wrong with using the equivalent ADT and putting the constraint on eval instead?
20:11:18 <iqubic> Uhh... I didn't think of that.
20:11:24 <iqubic> That's what's wrong with it.
20:11:41 <iqubic> Actually, I'm not really sure what you mean. Can you give me an example?
20:12:46 <monochrom> Then the opposite problem is that if you don't have just one "eval" function but a million "eval" functions or helper functions etc then you now repeat the constraint over all functions.
20:13:15 <monochrom> This dilemma is known as the "unexpression problem". >:)
20:13:47 <iqubic> Well... My eval function actually is a mess too.
20:13:55 <monochrom> so-called because "I don't want to express my constraints" >:)
20:14:52 <iqubic> Right.
20:15:00 <iqubic> Well, this is also really bad.
20:15:01 <iqubic> http://dpaste.com/3F63R86
20:15:11 <iqubic> Is there some way to clean that up?
20:15:35 <iqubic> Because that's basically the same pattern over and over again, and that is code smell to me.
20:16:20 <monochrom> May be "data type a la carte" helps. But I am not sure.
20:16:35 <monochrom> err, plural, "data types a la carte".
20:17:14 <iqubic> What does that mean?
20:17:23 <monochrom> Title of paper.
20:18:16 <iqubic> I wish there was a way to deal with this, but I don't know how to reconcile the fact that I have some binary operations and some unary operations.
20:19:25 <[Leary]> That looks fine to me, iqubic. You can try to make it better, but you'll only make it more complicated than it should be.
20:19:31 --- mode: glguy set +v PatrickRobotham
20:19:49 <iqubic> Because the pattern is basically, apply eval on all the args, then apply some function to that.
20:20:38 <iqubic> I have about 20 different mathematical operations and they are all define in exactly that way.
20:21:18 <iqubic> Also, I had to write my own trig functions for some of the more complex operations.
20:21:19 <iqubic> eval (Cot x) = 1 / tan (eval x)
20:22:02 <iqubic> Haskell has support for Sin, Cos, and Tan, but then I have to do that thrice to get Sec, Csc, and Cot
20:22:12 <iqubic> That bugs me a lot.
20:22:29 <[Leary]> Re my original response, you just want to use `eval :: (RealFloat a, Eq a) => Expr a -> a`. I don't know how you skipped that and went straight to GADTs.
20:23:29 <iqubic> Yeah, I'll just do that.
20:25:12 <iqubic> I have no idea why I leapt straight to GADTs
20:26:18 <amalloy> iqubic: if you want to remove your duplication one thing you could do would be to replace all the binary constructors with a single constructor parameterized by a function: Bin (+) x y instead of Add x y
20:26:28 <pacak1> iqubic: recursion schemes (catamorphism) should simplify your eval
20:27:14 <pacak1> It will be "eval (Add x y) = x + y"
20:27:17 <amalloy> the other axis would be, yes, a catamorphism. avoids writing the recursion at all, but doesn't reduce the number of matches you have to do
20:27:57 <pacak1> :t cata
20:27:58 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
20:28:24 <Solonarv_> recursion-schemes is extra cool because you don't have to re-write your data type
20:28:59 <pacak1> Yea, there's TH code I wrote and someone managed to get it upstream
20:29:12 <Solonarv_> And if you aren't allergic to TH you don't even need to write the base functor, yeah
20:33:40 <iqubic> Where can I go to learn about catas?
20:34:02 <iqubic> or recursion schemes in general.
20:35:04 <pacak1> bananas lenses barbed wire paper
20:35:39 <pacak1> https://maartenfokkinga.github.io/utwente/mmf91m.pdf (not those lenses)
20:36:00 <pacak1> https://www.youtube.com/watch?v=Zw9KeP3OzpU - nice talk
20:37:35 <Solonarv_> "bananas, lenses, barbed wire" - what a terrible naming scheme!
20:37:59 <iqubic> Is there a library I can use to simplify the recursion here?
20:38:31 <pacak1> recursion-schemes
20:38:46 <Solonarv_> @hackage recursion-schemes
20:38:46 <lambdabot> http://hackage.haskell.org/package/recursion-schemes
20:39:00 <iqubic> Once I get the eval function working properly I'm going to learn about parsing. I
20:39:23 <iqubic> I am planning on making a parser that goes from String -> Expr a
20:39:52 <iqubic> That should be possible right? Is that a good introduction to the common parser libraries?
20:40:41 <Solonarv_> Sure, very possible
20:41:41 <Solonarv_> my recommendation for a parsing library:
20:41:46 <Solonarv_> @hackage megaparsec
20:41:46 <lambdabot> http://hackage.haskell.org/package/megaparsec
20:41:47 <iqubic> Like I want to turn ((5 * 7) + 1) into "(Add (Mul (Const 5) (Const 7)) (Const 1))"
20:41:57 <iqubic> Not attoparsec?
20:42:07 <pacak1> attoparsec is fast
20:42:12 <Solonarv_> So is megaparsec
20:42:14 <pacak1> megaparsec gives human readable error messages
20:42:26 <iqubic> So whatever kind of parser I make will need to be recursive.
20:42:51 <Solonarv_> Indeed.
20:42:56 <iqubic> Because each time I hit an open parenthesis I need to do recursion.
20:43:15 <pacak1> You'll want tokenizer at some point
20:43:23 <iqubic> What is a tokenizer?
20:43:50 <Solonarv_> Not something you need if you just want to parse arithmetic expressions, tbh
20:44:10 <pacak1> turns "(a+b)" into [OpenParen, Var "a", Op "+", Var "b", ClosingParen]
20:44:36 <pacak1> So you don't have to deal with spaces 
20:44:45 <iqubic> Solonarv: I want to parse and eval them.
20:45:11 <Solonarv_> I meant "if you're not parsing anything more complicated than arithmetic expressions"
20:45:44 <pacak1> If he is studying - might as well learn about all the things :)
20:45:58 <iqubic> Solonarv: Arithmetic expressions are all I plan on doing right now.
20:46:00 <Solonarv_> On the other appendage, better to learn things one at a time
20:46:17 <Solonarv_> Or at least not try to ingest too much at once.
20:46:22 <iqubic> But I'm also going to add support for variables at some point.
20:46:41 <iqubic> And doing stuff like "eval x + 1 with x = 10"
20:47:30 <iqubic> But once I add variable support I'm going to add functionality for finding the mathematical derivative of a function.
20:47:31 <pacak1> That's where it becomes useful to distingwish that "x" is a variable name and "eval" / "with" are keywords.
20:47:46 <iqubic> pacak1: Yeah, I know.
20:48:26 <iqubic> So at the end of all this I want a function called: derivative :: Expr a -> Expr a
20:48:44 <iqubic> which has support for variables and such.
20:48:57 <amalloy> pacak1: eval and parsing are basically distinct steps. your eval plans don't really affect what tools you need to parse
20:49:23 <iqubic> amalloy: That's true until I get to adding variables into the language.
20:49:46 <pacak1> Btw, don't bother to learn recursion schemes beyond those listed in the paper. While Zygohistomorphic prepromorphisms exist I haven't seen using anything more complicated than cata/ana used in real production code.
20:50:08 <iqubic> pacak1: That's good to know.
20:50:38 <iqubic> So I'm not sure how to deal with variables. Like how do I modify my eval function to handle variables.
20:55:46 <butterthebuddha> What's the easiest way to make megaparsec parse enums without having to manually write out each variant as a string?
20:56:02 <butterthebuddha> None of the variants have any data attached to them
20:58:26 <jle`> butterthebuddha: i often do `choice [ x <$ string (show x) | x <- [Foo ..] ]`
20:58:47 <jle`> (with a `try` in there somewhere)
21:02:33 <iqubic> How does haskell avoid numerical errors like 1/0?
21:02:36 <iqubic> > 1 / 0
21:02:38 <lambdabot>  Infinity
21:02:54 <iqubic> What does Infinity mean there???
21:03:02 <iqubic> log e
21:03:05 <iqubic> > log e
21:03:07 <lambdabot>  log e
21:03:15 <iqubic> Huh???
21:05:44 <iqubic> :t log
21:05:45 <lambdabot> Floating a => a -> a
21:05:53 <iqubic> > log 0
21:05:55 <lambdabot>  -Infinity
21:10:25 * hackage unix-time 0.4.4 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.4.4 (KazuYamamoto)
21:15:16 <c_wraith> > div 1 0
21:15:18 <lambdabot>  *Exception: divide by zero
21:15:40 <c_wraith> that is, it works the same as most other languages.
21:15:57 <c_wraith> Integer division by zero raises an exception 
21:16:25 <c_wraith> floating-point division by zero is IEEE-754
21:16:45 <c_wraith> so it results in infinity or negative infinity.
21:36:20 <iqubic> :t (<$>)
21:36:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:27:46 <nan`> stack can't parse cabal output
22:32:14 <nan`> stack/cabal so annoying
22:38:33 <nan`> stack init always needs old cabal
23:24:52 <ahri> is there a generalised concept of "not"/"inverse"/"opposite" in Haskell? I have a custom data type isomorphic to Bool and would like to `not` it
23:31:13 <ahri> I didn't see an appropriate `a -> a` so I'm assuming not, unless it's hidden away in a package my (limited) hoogle skills can't find; `negate :: Num a => a -> a` is the closest I can find but I'm in search of a general typeclass
23:31:35 <koz_> ahri: What would it possibly mean to have a 'generalized not'?
23:31:41 <koz_> This is inherently a highly specific concept.
23:32:22 <geekosaur> every so often a 'boolean typeclass' is discussed. it's nto the most useful of ideas
23:32:27 <koz_> That being said, _maybe_ you want something like this? https://www.stackage.org/haddock/nightly-2018-12-24/Boolean-0.2.4/Data-Boolean.html
23:32:58 <koz_> Or possibly this? https://www.stackage.org/haddock/nightly-2018-12-24/boolean-like-0.1.1.0/Combinator-Booly.html
23:33:25 <koz_> I echo the geeky dino though - it's not something that seems like a good plan.
23:40:38 <royal_screwup21> since functional programming involves creating new objects every time (and no object mutation), doesn't that leave a large memory footprint?
23:40:50 <ahri> koz_: hm, given the context I provided I thought it was clear; given a type with 2 inhabitants a generalised concept of `not` seems reasonable enough to swap between them as is common in boolean logic
23:41:59 <ahri> I think a better approach on my part my be to `newtype` Bool rather than have an isomorphic type
23:42:20 <ahri> *may be
23:43:30 <ahri> royal_screwup21: guarantees from the typesystem make it easier for GHC to optimize in those cases and be efficient 
23:44:11 <koz_> royal_screwup21: Also, for certain things (like data structures), you can copy most of them on a change.
23:44:26 <koz_> (so for example, you can tail-share lists if you cons to them)
23:44:32 <ahri> see "persistent data structures" if you're interested in more-than-trivial types (aggregates etc.)
23:44:39 <AfC> s/copy/reuse/
23:44:43 <koz_> (and red-black trees require only logarithmic copying on an insertion)
23:44:56 <koz_> Yeah, reuse what was I meant, thanks AfC.
23:45:04 <royal_screwup21> ah okay
23:47:22 <amalloy> even with all that, functional languages do tend to generate a lot of objects. but they're all short-lived, and the GC just sweeps them away quickly and cheaply
23:47:41 <koz_> In some cases, you can also 'fuse' away intermediate stuff.
23:47:46 <koz_> GHC does this a lot with lists, for example.
23:47:59 <ahri> I think I'll `newtype` and have a `Functor` instance for my type allowing me to re-use Bool tools - does that seem more sensible to you koz_, geekosaur?
23:48:15 <geekosaur> Functor doesn;'t work that way
23:48:23 <koz_> ahri: How do you plan to have a Functor instance for a type with two inhabitants?
23:48:30 <koz_> (unless your type parameter is phantom)
23:48:58 <koz_> geekosaur: I think I owe you a soda?
23:50:57 <ahri> hah, my thinking was that my newtype would wrap Bool so I could unwrap it with Functor, but that thinking is not helpful in this case is it?
23:51:06 <koz_> ahri: Functor is a completely different idea.
23:51:11 <koz_> What you _actually_ want is Coerce.
23:51:22 <koz_> (or CoercibleUtils for some convenience)
23:51:37 <ahri> ooh, this sounds like a fun rabbit hole
23:51:46 <koz_> ahri: It is pretty useful.
23:52:01 <koz_> But yeah, Functor requires that your type have kind Type -> Type.
23:52:14 <koz_> Which I am almost 100% sure you do not.
23:57:14 <[Leary]> Functor fits well enough, you just need to parameterise over Bool.
23:58:03 <koz_> [Leary]: I would argue a newtype over Bool, along with Coerce-based stuff, fits _better_.
23:58:09 <koz_> But YMMV I suppose.
