00:16:46 <Arahael> Using stack here, but it seems that the app is already using -rtsopts for the build, but +RTS -s doesn't seem to do anything at runtime.
00:17:13 <Arahael> Unless... Maybe stack itself is grabbing those args...
00:19:03 <Arahael> Yep, stack was grabbing hte args!  calling the resulting build directly worked.
00:19:36 <Arahael>    7,361,002,120 bytes allocated in the heap
00:19:42 <Arahael> ^^ 7.3 GB was allocated?
00:19:52 * Arahael marvels at how fast computers are these days.
00:20:21 <Arahael> These stats are *awesome*
00:28:14 <iqubic> So I want a way to store key value pairs in Haskell. Something like a Map of somesort.
00:28:28 <iqubic> What library should I use?
00:28:36 <koz_> iqubic: containers?
00:28:49 <koz_> unordered-containers are an option if you have Hashable instances and don't care about ordering.
00:28:52 <iqubic> I'll look into it.
00:29:24 <iqubic> koz_: All I want is for the Keys to be String and the Values to be numbers of some sort.
00:29:31 <koz_> iqubic: Map works fine.
00:29:36 <iqubic> Cool.
00:30:21 <iqubic> Why does this page only have 4 functions listed?
00:30:21 <iqubic> https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map.html
00:30:37 <iqubic> Or err... 5
00:30:53 <koz_> https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Lazy.html
00:30:55 <koz_> Or
00:30:58 <iqubic> Yeah.
00:31:05 <koz_> https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Map-Strict.html
00:32:01 <iqubic> Why would I chose one over the other?
00:32:46 <iqubic> like how does strict differ from lazy?
00:32:53 <amalloy> iqubic: the page you linked starts with an answer to that question
00:33:28 <iqubic> Looks like I'll be using Strict than.
00:39:31 <iqubic> What's the difference between an Ascending List vs a Descending List vs just using fromList?
00:39:57 <koz_> iqubic: ascendingList requires the input to be ordered by keys in ascending order.
00:40:02 <koz_> Or you will get weird breakages.
00:40:07 <iqubic> Ah. I see.
00:40:11 <koz_> Ditto descendingList but in the other order.
00:40:16 <koz_> fromList doesn't mind what order.
00:40:45 <iqubic> So I'll use fromList because I'll be taking user input, and using that to generate the dictionary.
00:41:05 <iqubic> Because I'm not sure what order the user will give me their input.
00:43:00 <iqubic> what does the qualified keyword do in "import qualified Foo.Bar as FooBar"
00:43:16 <koz_> iqubic: All calls to functions in Foo.Bar must be prefixed with FooBar.
00:43:20 <koz_> And are otherwise not visible.
00:43:27 <iqubic> And why is that useful?
00:43:32 <koz_> iqubic: Name clashes.
00:43:35 <koz_> Or avoidance of said.
00:43:41 <iqubic> Data.Map tells you to do that, but I'm not sur why.
00:43:43 <koz_> For examples where this matters _a lot_, see vector.
00:43:47 <iqubic> s/sur/sure/
00:43:53 <koz_> Because Map uses a lot of functions named the same way as Prelude stuff.
00:44:00 <iqubic> Right.
00:44:05 <iqubic> I didn't know that.
00:44:10 <koz_> Live and learn.
00:44:58 <iqubic> What about wl-pprint? I assume that should be fine to import without it being qualified, but I'm not sure how to check.
00:45:08 <koz_> iqubic: Try and see.
00:45:38 <iqubic> Alright. I will.
00:49:39 <ccapndave> Hey everyone - I just found out about loop/recur in Clojure.  Is is possible to make a similar system in Haskell?
00:49:47 <koz_> ccapndave: It's not necessary.
00:49:59 <koz_> Since GHC performs TCO and we prefer folds to explicit recursion anyway.
00:50:25 <ccapndave> loop/recur seems easier for my brain to handle somehow
00:50:44 <koz_> ccapndave: Honestly, in Haskell, we'd mostly use folds anyway.
00:51:04 <koz_> If whatever you're writing is TCOable, it's likely easier to write it as a fold too.
00:51:13 <ccapndave> Fair enough
00:53:34 <ccapndave> I'm writing a very simply expression parser which implements https://en.wikipedia.org/wiki/Shunting-yard_algorithm and converting the algorithm (which is expressed in terms of "while" loops) into immutable structures is a bit brain-melting
00:53:59 <ccapndave> I've ended up making lots of helper functions, which have sort of all ended up being called `loop`
00:54:21 <ccapndave> So I wondered if there was any kind of convention for naming these things and stumbled upon loop/recur
01:12:59 --- mode: glguy set +v gamme
01:16:23 * hackage gi-gtk-declarative 0.4.0 - Declarative GTK+ programming in Haskell  http://hackage.haskell.org/package/gi-gtk-declarative-0.4.0 (owickstrom)
01:27:45 --- mode: glguy set +v mreh
01:29:01 --- mode: glguy set -v mreh
02:00:23 * hackage ngx-export-tools 0.4.2.4 - Extra tools for Nginx haskell module  http://hackage.haskell.org/package/ngx-export-tools-0.4.2.4 (lyokha)
02:17:45 --- mode: glguy set +v mreh
02:28:15 --- mode: glguy set +v zebi
03:39:52 * hackage atom-conduit 0.5.0.2 - Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).  http://hackage.haskell.org/package/atom-conduit-0.5.0.2 (koral)
03:48:01 --- mode: glguy set +v Guest4
03:48:08 <Guest4> Hello there
03:48:18 <Guest4> How is everyone doing?
04:14:16 <jadrian> is there some way to obtain a middle ground between a type synonym and a newtype? e.g. such that the program compiles as if it were a type synonym, but produces warnings where it wouldn't work if it were a newtype
04:14:58 <jadrian> the idea being, to facilitate transition of a code base using e.g. Int to some safer newtype I = I Int
04:15:32 <rfold> There is no such thing AFAIK. But you can just change the definition and fix all the code. GHC will give you a list of all places you have to fix.
04:16:29 <jadrian> rfold: indeed, simply if its a very large codebase fixing all the code may not be trivial
04:16:56 <dibblego> make it a newtype, write the Iso, use the Iso, turn the Iso into a Prism later to get the safety
04:19:19 <jadrian> dibblego: I'm not that well versed on Lenses yet... looking at the page for Iso 
04:19:34 <dibblego> it's pretty good for exactly this problem
04:35:35 <julianleviston> Seems to take people a while to grok lenses at first… mostly because often it’s said that they’re getters and setters, when they’re really not. They’re *the focus* of some piece of structure within a type (and its posible modification), and you use the functions that come with the libraries to *build* getters and setters (and other modifiers) around these focii.
04:39:22 * hackage gi-gtk-declarative 0.4.1 - Declarative GTK+ programming in Haskell  http://hackage.haskell.org/package/gi-gtk-declarative-0.4.1 (owickstrom)
04:40:24 <jadrian> julianleviston: I do have lenses on my todo list, but what makes it less appealing to me (and maybe I'm wrong here) is that I suppose that level of abstaction  makes for some horrible type error messages
04:41:20 <julianleviston> jadrian: if you understand the basic function itself, it makes it much more understandable.
04:41:36 <julianleviston> They’re decidedly *not* magic, at that point.
04:41:38 <merijn> jadrian: I've been writing Haskell for, like, 10 years by now and I still only rarely use lenses and even then only the most basic ones
04:43:58 <jadrian> merijn: yeap, I'm almost in the same boat except I just got around to watch some videos and tutorials and never got to really use them
04:46:04 <jadrian> julianleviston: indeed, I'm sure it helps, but in my experience it is easy for haskell type errors to be somewhat confusing, more so than you'd except
04:46:26 <jadrian> julianleviston: it's the problem of finding a balance between type safety and flexibility in the type system
04:46:47 <jadrian> the more flexible the more options to make code work
04:47:12 <jadrian> so the less clear type errors can become
04:47:48 <julianleviston> I’m not sure I follow what you mean by flexiiblity in this context.
04:50:53 * hackage gi-gtk-declarative-app-simple 0.4.0 - Declarative GTK+ programming in Haskell in the style of Pux.  http://hackage.haskell.org/package/gi-gtk-declarative-app-simple-0.4.0 (owickstrom)
04:51:15 <ph88> how can i dereference a pointer ?
04:51:32 <julianleviston> ph88 what’s a pointer in Haskell?
04:51:50 <ph88> Foreign.Ptr
04:53:09 <jadrian> julianleviston: monomorphism is less flexible than polymorphism
04:53:26 <jadrian> julianleviston: add type classes and you have more felxibility
04:53:34 <jadrian> and so on and so forth
04:53:46 <julianleviston> jadrian: ok
04:54:16 <jadrian> julianleviston: flexibility in this context would be measured by the "amount" of programs that can be typechecked
04:55:37 <jadrian> julianleviston: as you increase the set of programs that could be typechecked, the type error messages become more vague and abstract, because there's more intricate ways to fix the code
04:56:44 <jadrian> julianleviston: and the more abstract one's code is, the less constrained the type checker becomes in that particular instance
04:56:47 <julianleviston> I don’t think flexibility (by your definition) increases or decreases the set of programs that can be typechecked — only how easy it is to write programs that mean more with less code, no? (ie you seem to be talking about abstraction)
04:57:39 <ph88> looks like peek for pointer deref
04:57:40 <julianleviston> but sure… more abstract things are harder to understand, possibly.
04:59:02 <jadrian> julianleviston: depends on what we mean by that precisely, in some cases it objectively allows for more programs, e.g. think higher rank polymorphism where you can apply some quantified argument to different monomorphic types
04:59:15 <merijn> ph88: What are you doing that requires that?
04:59:21 <jadrian> julianleviston: similar with type classes
04:59:23 <julianleviston> I feel like perhaps haskell has particularly difficult to understand error messages because of the fact that it’s intensely complex… (at least GHC) — the extensions see to it.
04:59:35 <jadrian> julianleviston:  you can apply an fmap to different monorphic types
04:59:45 <jadrian> julianleviston: in a monomorphic setting you cannot do any of that
04:59:58 <ph88> merijn, pass an CUShort instead of Ptr CUShort  to a foreign function
05:00:29 <julianleviston> jadrian: sure, but you can make the same meanings (ie the same programs).
05:00:34 <julianleviston> jadrian: it just takes more work ;-)
05:01:50 <jadrian> jadrian: perhaps it's best to say, "there's more ways to type check particular programs" 
05:01:56 <jadrian> I think that's clearer
05:01:58 <ph88> eh CInt 
05:02:53 <jadrian> jadrian: so there's a larger search space when trying to type check a program
05:03:03 <ph88> if i want to allocate a small buffer, it there some better data structure than a separate Ptr and the length of the buffer ?
05:03:04 <jadrian> jadrian: and offering hints to fix it
05:05:25 <julianleviston> jadrian: yeah, this is a silly discussion. Sorry for splitting hairs.
05:05:38 <jadrian> julianleviston: just tangentialy related, just noticed this a few days ago  f:: Int -> Int; f * (n+1) 
05:05:41 <julianleviston> jadrian: you find Haskell’s error messages opaque sometimes, that’s fair critcism.
05:06:16 <jadrian> julianleviston: Couldn't match expected type ‘Int -> Int’ with actual type ‘Int’;   Possible cause: ‘(+)’ is applied to too many arguments
05:07:43 <jadrian> julianleviston: for fun tried  f:: Int -> Int; f * (n+)   and the error became,  Couldn't match expected type ‘Int -> Int’ with actual type ‘Int’;   Possible cause: ‘(+)’ is applied to too few arguments
05:08:26 <jadrian> this is a small monomorphic function with a type signature
05:08:44 <julianleviston> jadrian: there’s no `=` sign is there?
05:08:52 <jadrian> opss
05:09:22 <jadrian> julianleviston: sorry, that should be,    f :: Int -> Int; f n = f * (n+1)    and then f :: Int -> Int; f n = f * (n+)
05:09:42 <julianleviston> jadrian: so you wrote bottom.
05:10:36 <jadrian> julianleviston: we can add a base case, the problem is we accidently multiply the function f with an Int
05:11:11 <jadrian> julianleviston: note it's not,  f (n+1), but f * (n+1)
05:11:47 <jadrian> julianleviston: it's a small example buit if you're writing a long math expression it's easy to put a (*) out of place
05:14:32 <julianleviston> jadrian: uhhuh.
05:15:18 <julianleviston> jadrian: how long did it take you to fix?
05:15:38 <jadrian> julianleviston: suppose you write instead,  f n =  2 *(f * (n-1)) * (2 * (n-1) + 1) `div` n+2 , now it hints that the problem is in the 2nd factor "n+2"
05:15:43 <julianleviston> jadrian: in my experience, those kinds of confusing errors usually take less than a minute.
05:16:05 <jadrian> julianleviston: it wasn't my bug just something I saw, and to me it was obvious where the bug was
05:16:14 <julianleviston> jadrian: exactly.
05:17:09 <jadrian> julianleviston: right but this is very simple and I've been doing haskell for long, the point was more along the lines that if something this simple leads the type checker in such a wrong direction, imagine with a super abstract highly polymorphic type
05:18:03 <julianleviston> jadrian: one reason why it’s good to use small definitions, I guess.
05:18:21 <jadrian> julianleviston: maybe I'm sounding to negative... I do really like haskell's type system, just saying that this can be a pain at times
05:19:13 <jadrian> julianleviston: true, that does help 
05:19:14 <julianleviston> jadrian: maybe it’s not if we move slower, in smaller steps?
05:20:29 <jadrian> julianleviston: well it's more doable for the programmer, however what I was trying to say is that often times the type checker doesn't really help much other than saying "it's wrong"
05:20:55 <jadrian> julianleviston: i.e. you might be better off not even trying to understand the error message and just find the error looking at the term
05:21:28 <merijn> jadrian: It depend on the kind of polymorphism. It's mostly (typeclass) polymorphic values like Num and OverloadedStrings that screw things up
05:21:30 <jadrian> julianleviston: and part of the usefulness of a type system isn't just pointing out something doesn't type check, but to guide you in fixing it.
05:21:42 <julianleviston> jadrian: that’s debatable.
05:21:58 <julianleviston> jadrian: I understand the elm perspective.
05:22:12 <jadrian> julianleviston: it is debatable indeed
05:23:09 <julianleviston> jadrian: if one uses typed holes, often that’s helpful in being a guide. But one has to know how to use them.
05:23:10 <jadrian> merijn: well... even simple parametric polymorphism might turn a simple error into something more confusing... e.g. "couldn't construct the infinite type yadayadayada" when unification fails
05:23:51 <merijn> jadrian: Sure, but it's less common :)
05:23:52 <jadrian> merijn: not saying it's a big deal, only that it can turn a simple concise error into something much more technical
05:24:03 <merijn> jadrian: It also depends on how much you really on inference
05:24:08 <merijn> s/really/rely
05:24:25 <jadrian> julianleviston: yes, true, but we're getting to type debugging,
05:24:42 <merijn> The longer I write haskell, the more I'm in favour of "annotate every binding"
05:25:02 <jadrian> merijn: true, but which is why I mentioned this in the context of lenses
05:25:22 <julianleviston> jadrian: no, I mean in construction. If one programs like that, it’s quite difficult to make mistakes.
05:25:31 <merijn> jadrian: This is why I dislike lens, tbh :p
05:25:44 <jadrian> julianleviston: ah fair point, yes it does help
05:26:11 <jadrian> merijn: it's what puts me off to... I'll eventually try them out more seriously though
05:26:24 <jadrian> ops got to go
05:27:04 <julianleviston> I kind of wish haskell had first class denotational design or at least some capacity for semantic annotation.
05:59:52 * hackage morphisms-objects 0.1.1 - Algebraic structures  http://hackage.haskell.org/package/morphisms-objects-0.1.1 (iokasimovmt)
06:10:24 <nan`> does anyone know a way to log all instructions executed? I am having haskell crash with EXC_BAD_ACCESS in an unknown region of memory and i want to figure out how it got there.
06:11:23 <infinisil> nan`: strace?
06:11:51 <nan`> infinisil: hm, strace could help
06:12:06 <nan`> i thought it was only system calls but that would still be useful
06:12:29 <nan`> shoot i'm on macos and it's not in ports
06:12:37 <nan`> i think there is an equivalent, though
06:13:23 <merijn> nan`: You want dtruss on macOS
06:13:32 <nan`> ty
06:13:34 <merijn> nan`: And/or some other DTRACE tool
06:27:32 <nan`> ty
06:28:17 <nan`> ooh is system integrity protection new in mojave?
06:28:30 <nan`> nm no it's not
06:31:22 * hackage morphisms-functors 0.1.4 - Functors, theirs compositions and transformations  http://hackage.haskell.org/package/morphisms-functors-0.1.4 (iokasimovmt)
06:33:25 <nan`> how are these hackage messages generated exactly? Is this new stuff?
06:36:43 <hpc> that bot's been around for years
06:36:56 <hpc> it just watches hackage's rss feed or something along those lines
06:39:43 <infinisil> https://hackage.haskell.org/api#recentPackages probably
06:49:42 <nan`> how do you find good docs on syscalls in osx? For example i have a failing ioctl with a code and i want to understand the code it was trying to use
06:50:44 <codedmart> Say I have a file that is 1GB. I want to read the file in 50MB chunks and with each chunk upload the AWS S3 and also run some commands after I upload each chunk. What is the best option for this? I was looking at http-client `partFileSource` and `artFileSourceChunked`, but I am not sure that is the right path.
06:53:00 <Bish> when creating a project with cabal with multiple modules
06:53:08 <Bish> i jusut have to specify "other-modules" right?
06:53:41 <Bish> i get this
06:53:44 <Bish> cabal: can't find source for Map in src, dist/build/autogen
06:57:00 <delYsid> hmm, I think I just wrote my first useful custom monad, by accident.
06:57:02 <dmwit> Well, not to put too fine a point on it, but... where is the source for Map?
06:57:14 <Bish> dmwit: src/map/map.hs
06:57:22 <Bish> and i also specified hs-source-dirs: src
06:57:27 <dmwit> Okay. It needs to be in src/Map.hs
06:57:42 <Bish> hm that sucks, im not allowed to go deep?
06:57:49 <Bish> and i cannot name it "map"? 
06:57:56 <dmwit> No, you cannot name it "map".
06:58:03 <dmwit> You can go deeper if you want, you just have to tell it where to look.
06:58:15 <Bish> that is not so free as i expected
06:58:17 <dmwit> Put it in src/map/Map.hs if you want, but then you must say hs-source-dirs: src/map
06:59:03 <dmwit> (Or hs-source-dirs: src src/map if you want to have sources in both locations.)
07:12:19 --- mode: glguy set +v Fraus
07:13:14 <Fraus> Hey guys! I am studying for an introductory Haskell exam and need some help with a problem, I posted it on https://stackoverflow.com/questions/53970720/am-i-understanding-this-function-correctly , if anyone could spare the time I would be very grateful! If not, that's okay too! Thanks! :)
07:13:42 <the_2nd> Does anyone know how I can make hyperlinks in Hakyll pages use target=_blank?
07:14:00 <the_2nd> when content is generated from .md files
07:20:25 <ski> Fraus : "But with \"Duey\" since this name is equal to the first inputted name, it will add this to otherFathers and then return this as the result, since there are no more families to check." -- the first "this" is (or should refer to) something else than the latter two "this" words, in that sentence
07:21:49 <ski> Fraus : the first refers to `"Duey"'. the second ought to refer to `["Ronald"]', which is what `fathers' will be bound to, in that call to `par'
07:22:08 <Fraus> Thanks for the reply Ski, I will check if I understand what you mean!
07:22:14 <ski> (the third "this" is `fathers ++ otherFathers')
07:23:29 <ski> Fraus : you could note that `par' is only ever called with an empty list, or a singleton list. so `fathers' will have at most one element
07:24:04 <Fraus> "Duey" is equal to the first inputted name. So it will  ["Ronald"] ++ [otherFathers]
07:24:07 <Fraus> Is that what you mean?
07:25:15 <ski> Fraus : and `par' is called once per `Fam' node in your tree. the initial call (corresponding to the topmost `Fam') to `par' will pass `[]' as `fathers'. all the recursive calls happens on direct subtrees, eventually traversing all nodes in the tree. and in all these cases, `fathers' will be a singleton list containing the name contained in the node just *above* the current node
07:25:42 <ski> Fraus : consider your sentence :
07:25:59 <ski>   But with "Duey" since this name is equal to the first inputted name, it will add this to otherFathers and then return this as the result, since there are no more families to check.
07:26:14 <julianleviston> guh those variable names are pretty terrible.
07:26:22 <Fraus> Oh yeah I see what you mean
07:26:34 <ski> the correct (truthful) interpretation of this sentence, that accurately describes the code, would be
07:26:59 <ski>   But with "Duey" since this name is equal to the first inputted name, it will add "Duey" to otherFathers and then return ["Duey"] ++ otherFathers as the result, since there are no more families to check.
07:27:41 <ski> Fraus : so you hopefully see what i mean about the "this"es in your sentence refering to different things. i'm just making this explicit, since one might assume that they'd refer to the same thing
07:28:32 <Fraus> Yeah definitely! Thanks
07:28:33 <ski> Fraus : did you follow my descriptions of recursive calls of `par' above ?
07:29:34 <Fraus> I understand that it calls `par` once per `Fam` node. But I am not quite sure I understand the rest of what you wrote.
07:29:53 <Fraus> It will pass on [] as `fathers`, but how does anything end up in the `fathers` list then?
07:29:58 <ski> well, there are, syntactically/lexically/statically speaking, only two calls to `par' in that code
07:30:10 <ski> one is in the direct body of `parent'
07:30:22 <ski> the other is in the body of `par', so is a recursive call
07:31:07 <ski> so, the initial/top call to `par' will be the one made from `parent', and that passes `[]' as first argument to `par'. so the first time we enter the definition of `par', `fathers' will be equal (/ bound) to `[]'
07:32:02 <Fraus> Yes I understand that
07:32:26 <ski> however, for each child node `c' in the list `cs' of direct child nodes of the current node passed to `par', we will recursively call `par'. this time passing not `[]', but `[child]' (a singleton list containing the name located in the current/present node given to the current call to `par')
07:32:52 <Fraus> Yup!
07:33:32 <ski> so, all subsequent calls to `par' (the recursive calls, arising from the initial call from `parent') will bind `fathers' not to `[]' but to `[child]', for differing values of `child' (namely, the name of the direct *parent* node of the node passed to that particular call to `par')
07:34:18 <ski> so, for all calls to `par', except the initial/top one, `fathers' will be bound to a singleton list containing the name in the direct partent node
07:34:31 <ski> for the initial/top call, `fathers' will be bound to the empty list
07:34:35 <Fraus> Yeah I am following
07:34:45 <ski> so therefore `fathers' has at most one element
07:35:32 <ski> with a recursion like here, `par' having an extra "accumulator" argument, it could well have been the case that we'd add more and more stuff to this list argument, so that `fathers' could be a long list, if we started with a deep tree say
07:35:37 <ski> but that's not the case here
07:36:23 <ski> now, `otherFathers' basically contains the list of all "solutions" found by traversing the subtrees of the current tree node
07:36:24 <Fraus> I think I am understanding what you are saying, thanks so much for taking the time
07:36:44 <Fraus> So here'
07:37:22 <Fraus> but in the context of this function, would you call otherFathers a list or a function?
07:37:51 --- mode: glguy set +v mreh
07:38:01 <Fraus> I guess it is a list since we can append it to other lists, but at the same time it contains a bunch of functions?
07:38:48 <ski> `otherFathers' here is certainly a list
07:39:14 <ski> it is *produced* by recursively calling our function `par', on particular inputs (and the concatenating the results)
07:39:40 <ski> you could say that the computation of this list consists of making certain function calls
07:39:54 <ski> or s/computation/evaluation/
07:40:24 <Fraus> But at any given time this list is empty? Except when "child" == "name"?
07:40:30 <ski> just like the evaluation of the number `max (2*3) (2+3)' will require calling the functions `max',`(*)',`(+)'
07:40:38 <Fraus> Yeah I get what you are saying
07:40:56 <ski> well, i was about to come to that, when you asked about `otherFathers' :)
07:41:11 <ski> however, we have (potentially) multiple subtrees, each of them yielding a list of "solutions". but we want only a single list to return from the current call. therefore we use `concat' (or `concatMap', or equivalently `[p | c <- cs,p <- par [child] c]', which does the "flattening" implicitly, by the generator `p <- ...')
07:42:16 <ski> however, consider the case where we have a node with zero subtrees. then `cs' is the empty list, so there will actually be no further recursive call to `par', down this branch. so `otherFathers' will be the empty list in this case
07:43:46 <ski> using `otherFathers' in the return value from `par' (iow either `father ++ otherFathers', or `otherFathers', depending on which guard case is taken) will only "forward" solutions from the subtrees to solutions found for the current tree node
07:44:27 <ski> in order for this to be useful at all, to not always return an empty list, we *must* add something concrete, at *some* point in the code, to this `otherFathers'
07:44:47 <ski> otherwise, we'd just be concatenating a lot of empty lists, ending up with an empty list in the end
07:45:03 <Fraus> Alright so let's see if I am getting this. Here's a question
07:45:21 <ski> and the *only* place that happens in the code is in the `father ++ otherFathers' case, in the case `father' is not the empty list 
07:45:43 <Fraus> If we were to not concatenate, and the tree was bigger and containing multiple "Dueys", we would end up with a list of lists?
07:46:31 <ski> well, then the recursive calls would each give a list of lists, but we collect the results of the recursive calls on the direct subtrees into a list, so then we'd get a list of lists of lists
07:46:47 <ski> but then the recursive calls would each give a list of lists of lists, but ...
07:47:17 <ski> end result, the types would not work out
07:47:35 <Fraus> oh okay
07:48:10 <ski> (if one adapted `father' from singleton list to singleton list containing singleton list, and so on, the effective result type would be the infinite type `[[[[...]]]]', which has no "bottom leaf level", and therefore no place left for any names)
07:49:31 <ski> (it *would* be possible to do what i sketched here, if we returned a (solution) *tree* instead of a plain "flat" list. we could define `data Solution = Sol Name [Solution]' .. but i don't think this extra nesting that the tree would give would be preferable to having a flat list, here)
07:49:49 <ski> Fraus : anyway, continuing from
07:49:56 <ski> <ski> otherwise, we'd just be concatenating a lot of empty lists, ending up with an empty list in the end
07:50:01 <ski> <ski> and the *only* place that happens in the code is in the `father ++ otherFathers' case, in the case `father' is not the empty list
07:52:06 <ski> so, the effect of `par' is to compare each `child' in *each* node of the tree with `n'. in that case, we add a *non-empty* list `[father]' onto the collected solutions `otherFathers'. (except in the case of the top node. if the name there is `child', and it's equal to `n', we still don't add anything, since there is no `father', since there is no parent node)
07:52:50 <Fraus> yup yup
07:53:06 <ski> if you draw the tree on paper, you could think of this as checking each `child' of each node, comparing with `n', and in case they're equal you circle (or underline, whatever) the name in the *parent* node (if it exists)
07:53:33 <ski> then it's just a matter of collecting together all the circled names, in some order (in this case, in the preorder traversal of the tree)
07:54:36 <ski> i suppose my intent here is to try to help you to "see" (visualize) the behaviour of the code in front of you, to connect the written code to how it would behave, to understand how each part of the code fits into the behaviour
07:54:58 <Fraus> Yeah I see what you are getting at
07:55:45 <ski> (i don't really care if you actually "see" it as some kind of image or not. i'm not really good at thinking in images. but i can still sortof "feel" how things are "structurally connected", if that makes any sense. in any case, people think in different ways)
07:56:13 <Fraus> I often do similar things when I get a problem in class, I try to visualize it, but if I were to write this parent function for example I am not sure where I would start
07:56:37 <Fraus> But I guess that's why I am going to school hehe :)
07:57:29 <ski> anyway, the reason i talked about "solutions" and `otherFathers' above is to highlight in which parts of the code "stuff is actually happening", and which parts only act as "plumbing for values from other parts to flow through"
07:58:06 <ski> if `fathers ++ otherFathers' was changed to `otherFathers', or if `fathers' was always an empty list, then you'd always get an empty list as result, when calling `par' (and `parent')
07:58:51 <ski> at least, i think trying to identify such "crucial parts" of the code of a recursive definitions, helps me with reading such code
07:59:02 <ski> hopefully it's of some use to you, as well
08:00:08 <Fraus> Yes definitely, I have learnt a lot! It takes some time to process everything but it has been very helpful :) I am new to freenode and stackoverflow and all these sites, is there any way to give +rep?
08:00:15 <ski> Fraus : so, your explanation of the code, on SO, sounded ok, as far as it went. i was trying to deepen the understanding a little bit
08:00:50 * ski has no idea what `+rep' means
08:01:23 <isBEKaml> Fraus: if ski doesn't write an answer on SO, you could summarize this entire conversation into an answer on SO and accept it. That's actually recommended on SO
08:01:47 <isBEKaml> Fraus: IOW, you can accept your own answers to your posts
08:01:58 <Fraus> Oh alright, yeah I guess I'
08:01:59 <Fraus> I'
08:02:03 <Fraus> I'll do something like that
08:02:55 <ski> Fraus : as for the second question on SO, i think it'll become clearer, with more experience under your belt of writing tree (and list) traversals of different kinds
08:03:09 <ski> Fraus : i suppose i would probably start something like
08:04:28 <ski>   parent n (Fam f fs) = searchFamilies f fs
08:04:32 <ski>     where
08:05:24 <ski>     searchFamilies f fs = [p | f <- fs,p <- searchFamily f fs]
08:05:43 <ski>     searchFamily f0 (Fam f fs)
08:06:25 <ski>       | f == n    = f0 : ps
08:06:33 <ski>       | otherwise =      ps
08:06:37 <ski>         where
08:06:48 <ski>         ps = searchFamilies f fs
08:07:17 <ski> the point being that i "want to treat the top node of the tree differently from the other trees"
08:08:04 <ski> so `parent' unpacks the top node. `searchFamilies' is responsible for traversing the children list of trees. `searchFamily' is responsible for handling each of those children nodes, one at a time
08:08:51 <ski> we could dispense with defining `searchFamilies', replacing the calls to it with its body. but then we'd duplicate that body of code, since there's two calls to `searchFamilies' above. and i didn't want to do that
08:10:01 <ski> er, sorry, the `searchFamilies f fs = [p | f <- fs,p <- searchFamily f fs]' part ought to be `searchFamilies f0 fs = [p | f <- fs,p <- searchFamily f0 f]'
08:10:23 <ski> (and probably the naming could be better. i just wrote down the first thing that came to mind)
08:11:02 <ski> anyway, the possible advantage of the above version is that we don't need to pass a list `fathers' recursively, where that list contains at most one element
08:11:30 <ski> first, since it has at most one element, one could replace it with `Maybe' (but then one'd need to rephrase `fathers ++ otherFathers')
08:12:02 <ski> second, because i separated the top node case from the other subnodes, i can just pass the name in the parent node of the current node, no list at all
08:13:33 <ski> Fraus : as for how to think, in order to be able to come up with something like this (or like the code in that SO post), hmm
08:14:10 <ski> Fraus : you'll probably need a first, possibly vague, intuition of how you're going to go about things
08:14:37 <ski> you want to visit every node in the tree, so you need to use recursion to step down to children nodes, to eventually reach every node
08:15:21 <ski> and you need to understand that you'll get a list of possibly many solutions from each child, which then will need to be concatenated into a single list of solutions for the current node
08:15:45 <ski> then you need to see that you need to get hold of the name of the parent node
08:16:01 <ski> one way to do that would be to have recursive clauses like
08:16:31 <ski>   blah (Fam f1 []) = ...
08:16:38 <ACheesyName> is there a standard function for setting an element of a list at a given index? (resulting in a new list)?
08:16:50 <ski>   blah (Fam f1 (Fam f fs:children)) = ...
08:17:19 <ski> so here `f1' would be the name of the parent node of `Fam f fs'. you'd have a recursive call `blah (Fam f1 children)' in this case
08:17:47 <ski> ACheesyName : i suspect lens would have it
08:18:44 <ski> anyway, instead of using such "deep nesting", i opted for passing the name of the father down to the "next recursive calls" (on the children). just like was done in the SO post (except in that case wrapped in a singleton list)
08:19:53 <ski> Fraus : i also decided to split up into mutual recursion between `searchFamilies' and `searchFamily', in order to avoid code duplication of the body of `searchFamilies'
08:22:53 <ski> (it would be possible to instead get rid of `searchFamily', by inlining the body of that into the single call to it, in `searchFamilies'. so `searchFamilies f0 fs0 = [p | Fam f1 fs1 <- fs0,p <- [f0 | f1 == n] ++ searchFamilies f1 fs1]', say)
08:23:24 <ski> Fraus : not sure i can explicate that much better how i was thinking ..
08:24:10 <Fraus> I understand what you are getting at and your thought process, but I think I need a lot more experience dealing with these sort of questions before that happens intuitively.
08:24:55 <ski> yes, hence "i think it'll become clearer, with more experience under your belt of writing tree (and list) traversals of different kinds" :)
08:25:17 <ski> Fraus : now, what does "give +rep" mean ?
08:25:29 <Fraus> Yeah I know! :D
08:26:43 <Fraus> Oh, +rep is sorta like an upvote on someone's profile.
08:26:49 <ski> oic
08:26:52 <Fraus> But if I understood correctly there is no such system on here
08:27:37 <ski> Fraus : well, if you feel the need/want to show appreciation, you could do that by trying to be helpful in turn to other people with other questions
08:27:50 <ski> (to your ability, of course)
08:28:36 <ski> (there is actually a `karma' "system" here. not that it's used *that* much. and i actually prefer it that way)
08:28:40 --- mode: glguy set +v Fraus
08:29:02 <Fraus> Yes ski, I try to (to the best of my ability) but a lot of things are way over my head
08:30:13 <ski> no worry
08:57:50 <ACheesyName> :t (!!)
08:57:51 <lambdabot> [a] -> Int -> a
09:22:52 * hackage cabal-debian 4.38.3 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.38.3 (DavidFox)
09:53:22 * hackage dhall 1.20.0 - A configuration language guaranteed to terminate  http://hackage.haskell.org/package/dhall-1.20.0 (GabrielGonzalez)
09:55:53 * hackage dhall-json 1.2.6 - Compile Dhall to JSON or YAML  http://hackage.haskell.org/package/dhall-json-1.2.6 (GabrielGonzalez)
09:57:22 * hackage category 0.2.2.0 - Categorical types and classes  http://hackage.haskell.org/package/category-0.2.2.0 (MatthewFarkasDyck)
09:59:52 * hackage dhall-bash 1.0.18 - Compile Dhall to Bash  http://hackage.haskell.org/package/dhall-bash-1.0.18 (GabrielGonzalez)
10:01:53 <nan`> why does dtruss on os x show 2 return values on success? is there a channel for osx kernel dev
10:02:06 --- mode: glguy set +v turba_dilatatio
10:03:52 * hackage dhall-text 1.0.15 - Template text using Dhall  http://hackage.haskell.org/package/dhall-text-1.0.15 (GabrielGonzalez)
10:26:22 * hackage happstack-authenticate 2.3.4.15 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-2.3.4.15 (JeremyShaw)
10:34:20 <delYsid> Hmm, monads are cool!
10:35:48 <MarcelineVQ> You are cool
10:41:22 <koz_> MarcelineVQ: No, _you're_ cool. :P
10:44:47 <MarcelineVQ> shucks buster
10:47:14 <delYsid> nah really, I just had an epiphany moment.  Wrote my first useful monad, and while I am at it, finally understood (somewhat) when to use a class!
10:47:46 <koz_> delYsid: May you have many more.
10:48:03 <DigitalKiwi> can...can i be cool too :<
10:48:12 <dyl> delYsid unfortunately, a side-effect of understanding monads is that you lose the ability to explain them.
10:48:30 <koz_> DigitalKiwi: Of course!
10:48:41 <koz_> dyl: It's not something I have observed in myself.
10:48:48 <koz_> Your mileage clearly does vary.
10:48:50 <delYsid> dyl: I gather.
10:48:51 <DigitalKiwi> dyl: but that doesn't stop anyone from trying
10:50:46 <delYsid> I hear people are frowning upon putting constraints in types that are not strictly necessary, right?  Like, my class offers one thing, but the user typically also wants the MonadState and MonadReader typeclasses when using that class.  Putting these as superclasses makes things easier on the user side, but is strictly not true... Opinions?
10:51:50 <delYsid> Like here: https://github.com/mlang/motar/blob/update-monad/src/StateUpdateM.purs
10:52:10 <koz_> delYsid: That's Purescript, which isn't strictly speaking Haskell.
10:53:14 <delYsid> koz_: yeah...
10:54:36 <dyl> Do you mean like XDatatypeContexts? Or putting constraints on GADT constructors?
10:54:40 <int-e> delYsid: In Haskell the common pattern for lifting these classes through a custom monad transformer is to put those constraints on the instances, say: instance MonadReader r m => MonadReader r (MyMonad m) where {- implementation -}
10:54:41 <dyl> (inclusive or here)
10:55:58 <defanor> is there a way to set a default XML namespace with HXT? particularly for output, to avoid the same prefixes duplicated many times in the resulting string
10:56:05 <dyl> delYsid a perhaps useful observation is that putting constraints on datatype constructors is *never* strictly necessary :).
10:56:37 <dyl> It may appear *convenient*, but it's never required to write a datatype. Now, operations over that datatype on the other hand...
11:01:24 <delYsid> I am talking about class constraints, not datatype constraints.
11:04:15 <dyl> delYsid In general I would only include a constraint on a class when it is necessary to talk about the behavior (especially laws) of that class.   
11:04:26 <dyl> i.e. when it's about "what can be done with" rather than "what is".
11:06:26 <dyl> For example, Ord encodes total ordering, and to talk about total ordering, in particular antisymmetry, we need (==). 
11:07:22 <dyl> In other words: you need an Eq instance to even pose the question of whether an Ord instance is well defined or not. 
11:07:54 <mouse07410> I need GHC to link the compiled file with a dynamic library in a specific directory. How do I (a) tell GHC to pass that argument to GCC (in what format), and (b) is there a way to put that directory (and maybe several dirs) into a config file that all the subsequent GHC invocations would use?
11:08:05 <dyl> Also, I'd challenge the idea that "putting these as superclasses makes things easier on the user side". It often may not, particularly for testin.
11:12:58 <merijn> mouse07410: GHC supports -L and -l just like gcc
11:13:11 <MarcelineVQ> delYsid: Another angle is that some superclass p => class a says, any type which can be an instance of class a is also already an instance of p. We don't necessarily need the methods of Eq to define Ord, however we can define an Eq instance via the methods that Ord provides alone, thus any Ord a is also Eq a
11:13:17 <merijn> mouse07410: And the correct way of specifying that would be to define them as ghc-options: in your cabal file
11:14:22 * hackage pandoc-pyplot 1.1.0.0 - A Pandoc filter for including figures generated from Matplotlib  http://hackage.haskell.org/package/pandoc-pyplot-1.1.0.0 (LaurentRDC)
11:14:32 <mouse07410> So, (1) I should put them in cabal fine, and (2) they should go as "ghc-options" rather than "gcc-options"?
11:15:40 <Solonarv> I think the cabal format actually has a field for that, check the docs
11:15:55 <mouse07410> Do I just put them all together and enclose into double quotes, like "-L/opt/special -lmylib -L/opt/local/lib"?
11:16:57 <merijn> mouse07410: No quotes and assuming you're asking GHC to build a library/executable GHC is responsible for calling the linker (via gcc) with the right flags
11:17:22 <merijn> Solonarv: cc-options exists but is for when you're asking cabal to compile C files, it's not for specifying linker flags
11:18:30 <mouse07410> Yeah, cabal file has "gcc-options" and "ghc-options", but no clear description how to put multiple flags/parameters in there, nor when to use one as opposed to the other. 
11:18:47 <merijn> mouse07410: You put multiple flags by separating them with whitespace
11:19:06 <merijn> mouse07410: Also: https://cabal.readthedocs.io/en/latest/developing-packages.html#developing-packages
11:20:10 <mouse07410> @merijn thanks! so I should use "ghc-options". Do I need to somehow mark them so GHC "knows" they are for GCC linking rather than for GHC itself?
11:20:10 <lambdabot> Unknown command, try @list
11:21:17 <merijn> mouse07410: -L and -l aren't "for" gcc. They're linker options specifying where to find libraries and which libraries to link. The fact that GHC may use gcc as a linker on your platform is, essentially, an implementation detail
11:23:14 <mouse07410> Cool, got it. Can I hope/expect that GHC would use these directories and libraries first and in the order I provided, and go to it's default/system libraries after that?
11:24:22 <monochrom> Consider extra-libraries and extra-lib-dirs instead.
11:24:59 <ph88> if i want to allocate a small buffer, it there some better data structure than a separate Ptr and the length of the buffer ?
11:26:18 <[exa]> ph88: small buffer for what?
11:26:52 <ph88> [exa], for copying some bytes into
11:27:21 <[exa]> and you want to give it to a C function or a syscall that copies the bytes there?
11:27:22 <mouse07410> I didn't know about "extra-libraries". "extra-lib-dirs" did not seem to work, and I can't figure the correct further for adding several of those
11:27:49 <_deepfire> Where there any tools for extracting the global (cross-module) top level definition dependency graphs?
11:27:53 <_deepfire> *Were
11:28:13 <ph88> [exa], C function
11:28:20 <mouse07410> "further" -> "format"
11:29:38 <koz_> ph88: Storable Vector?
11:30:06 <ph88> i'll have a look
11:34:05 <ph88> seems like i can try it with  unsafeToForeignPtr0
11:34:23 <[exa]> ph88: that way either the Ptr (read the warnings though, there are some finer alternatives) or the storable
11:34:47 <ph88> well i need to pass the Ptr
11:36:07 <ph88> why are the initialization methods of Vector.Storable not in IO ?
11:36:14 <trcc> Hi. Any best practices on algebraic data types vs records? I.e. I have a function, where the "return" is: status, variable state, Maybe user state. I am considering to stuffing these into a record type, a product type or perhaps a double tuple.. Any best practices?
11:36:27 <ph88> for manual allocation https://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Marshal-Alloc.html#g:3 i need IO
11:36:30 <Solonarv> Records *are* product types
11:36:38 <Solonarv> (in Haskell, that is)
11:37:19 <Solonarv> I'd lean towards a record, personally
11:37:25 <koz_> Records are basically tuples with names for their elements.
11:37:37 <koz_> I would agree with Solonarv in this case.
11:37:42 <trcc> Thank you
11:37:51 <trcc> when would one use a product type?
11:37:52 <ph88> does Vector.Storable use unsafePerformIO ?
11:38:07 <koz_> trcc: I don't understand. A record _is_ a product type.
11:38:24 <trcc> koz_: I am thinking syntax. Not semantics
11:38:35 <koz_> trcc: 'Product type' is not a syntactic construction.
11:38:51 <trcc> you a record: A {a = .., b=...} vs A Int Int for example
11:39:01 <dyl> ph88: I don’t know, but maybe like Bytestring it internally uses accursedUnutterablePerformIO :).
11:39:17 <koz_> Basically, the main advantage of records is that each element has a name you can refer to.
11:39:21 <dyl> :t Data.ByteString.Internal. accursedUnutterablePerformIO
11:39:22 <lambdabot> error:
11:39:22 <lambdabot>     Not in scope: data constructor ‘Data.ByteString.Internal’
11:39:22 <lambdabot>     Perhaps you meant one of these:
11:39:34 <koz_> If you think you'd need to refer to them by name, or that would be convenient, it's worth doing.
11:39:41 <dyl> :t Data.ByteString.Internal.accursedUnutterablePerformIO
11:39:42 <lambdabot> IO a -> a
11:39:54 <trcc> ok. Thank
11:39:55 <trcc> s
11:40:08 <koz_> This is especially true when a) you have a lot of elements, or b) you don't always wanna have to pattern match on the whole thing to 'take it apart'.
11:40:11 <dyl> I’m joking, but actually: I would suggest just looking at the source.
11:40:28 <koz_> In practice, once you go beyond about 2-3 elements, records become a better choice in most cases.
11:41:07 <koz_> That being said, record field names _do_ take function names out of your namespace, and can cause clashes (although some GHC extensions can limit the damage).
11:41:55 <trcc> ok. Will keep that in mind. In particular b)
11:42:06 <Solonarv> (the usual fix is to prefix field names with the type name, e.g. 'data Foo = Foo { fooBlah :: ..., fooBlah :: ... })
11:42:25 <koz_> Yeah, the 'C approach to namespacing' is always a solution.
11:42:36 <trcc> Solonarv: thank you! I have definitely been missing that. I am encountering it quite often
11:42:49 <c_wraith> unlike C, Haskell actually guarantees the *whole* identifier is considered. :P
11:42:56 <koz_> c_wraith: I don't follow.
11:43:30 <c_wraith> The original C spec only guaranteed the first few letters of the identifier would be used.  I think it was 8 or 12.
11:43:54 <koz_> c_wraith: I _assume_ this isn't part of any current standard though?
11:43:58 <c_wraith> It's likely more recent versions lifted that.
11:44:02 <koz_> Although it being C I wouldn't be surprised.
11:44:16 <c_wraith> Note that as with everything in C, it was only "implementations are not required to use more than..."
11:44:26 <koz_> I suspect the original spec (by which I assume you mean K&R?) had this because computers were _hilariously_ limited in their capabilities.
11:44:29 <c_wraith> Any implementation is allowed to support longer names.
11:44:34 <c_wraith> yes, K&R
11:44:53 <koz_> s/computers/computers back then/
11:45:22 <koz_> Yeah, C is pedantically non-proscriptive despite basically requiring an execution model that looks like a PDP-11.
11:45:23 <c_wraith> It's just one more way in which "portable" C is unlikely to be portable to a compiler that obeys the spec as maliciously as possible.
11:45:43 <estrom> c_wraith: I believe strcmp, strncmp, and the naming schemes reflect this limitation
11:45:45 <koz_> c_wraith: I think when C99 was being discussed, some of their proscriptions had to be dropped as it made memcpy un-implementable.
11:46:22 <c_wraith> estrom: yeah, I think that's why they got those names.
11:46:39 <koz_> UNIX also follows some of these conventions (creat, I'm looking at you).
11:47:09 <koz_> Which is why 'traditional' UNIX utilities are invoked as 'ls -wtfBbq'
11:47:23 * koz_ is pretty confident this is an actual command.
11:48:19 <c_wraith> Looks like the minimum was 8 in K&R, and some more recent standard bumped it up to 31.
11:48:25 <benzrf> christ
11:48:39 <c_wraith> So a maliciously compliant C compiler could still treat identifiers that differ in the 32nd character as identical
11:48:44 <koz_> Yep.
11:49:15 <koz_> I guess that way, every identifier fits into a 32-byte string. :P
11:49:23 <koz_> This deserves a doge meme.
11:49:36 <pony> such compact
11:49:39 <koz_> very efficiency
11:49:41 <koz_> amaze
11:50:17 <koz_> (because C's policy on identifiers is still more-or-less 'ASCII or GTFO')
11:52:01 <koz_> c_wraith: Wouldn't that cause _hilarious_ compile-time errors?
11:53:14 <c_wraith> I'm not sure that's the word I'd use.
11:53:24 <koz_> 'Suicide-inducing' then?
11:53:41 <koz_> (or maybe 'homicide-inducing', depending on the poor person's mental state)
11:53:43 <c_wraith> only anguish-inducing, thanks.
11:53:44 <Rembane> c_wraith: Change to word you would use to hilarious using sed. :)
11:58:06 <koz_> pony: https://imgur.com/LDKqs2B
11:58:45 <pony> :)
11:58:56 <koz_> dogr.io is your friend.
12:02:31 <MarcelineVQ> memmes? if the c standard was a chungus the c++ standard is a bug c
12:03:26 <MarcelineVQ> huh, must have misclicked, that's an oddly truncated message.
12:04:07 <MarcelineVQ> man, life is weird.
12:05:10 <MarcelineVQ> anyway *is a big chungus
12:14:53 * hackage microsoft-translator 0.1.2 - Bindings to the Microsoft Translator API  http://hackage.haskell.org/package/microsoft-translator-0.1.2 (Cliff_Harvey)
12:24:31 <dukedave> I'm going mad here, what higher order function am I missing to fold over a list of tuples, i.e: `meanLine lines = (mean $ map fst lines, mean $ map snd lines)`
12:28:07 <dukedave> I tried a Hoogle with `(a->b) -> f (g a) -> f (g b)` (where `f` is Vector and `g` is tuple)
12:29:09 <ski> @type fmap . fmap
12:29:10 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
12:29:36 <marvin2> fmap for (,) will just map over snd
12:29:36 <ACheesyName> why is the quality of randomness from mkStdGen so low here? am I doing it wrong or what? https://repl.it/repls/AbleCheapSpools
12:29:53 <ski> "where ... `g` is tuple" ?
12:30:15 <marvin2> dukedave, not sure if lens is worth importing just for this.. but here it is
12:30:21 <c_wraith> ACheesyName: mkStdGen is low-quality.  It needs a lot of bits set to really scramble the internal state well.
12:30:23 <marvin2> > map (over both (+10)) [(1, 2), (3, 4)]
12:30:27 <lambdabot>  [(11,12),(13,14)]
12:30:42 <glguy> dukedave: You use the same list folding functions as when you're not folding tuples
12:31:35 <dukedave> Ooh, I did find a `both` in https://hackage.haskell.org/package/extra-1.6.14/docs/Data-Tuple-Extra.html#v:both
12:31:46 <glguy> ACheesyName: mkStdGen makes no promises about what happens when you sequentially increment the argument to mkStdGen
12:31:57 <marvin2> that is a different both, but it'll work too
12:32:01 <dukedave> Could I do as @ski suggested but using `both` instead of `fmap` ?
12:32:19 <ski> @type let mean = uncurry (/) . (sum &&& fromIntegral . length) in (mean *** mean) . (map fst &&& map snd)
12:32:20 <lambdabot> (Fractional c', Fractional c) => [(c, c')] -> (c, c')
12:32:31 <c_wraith> :t join (***)
12:32:32 <lambdabot> Arrow a => a b' c' -> a (b', b') (c', c')
12:33:07 <glguy> dukedave: ski is messing around, you shouldn't use any of that arrow stuff
12:35:37 <wroathe> test
12:35:56 <c_wraith> glguy: what about bifunctor stuff instead? :P
12:36:23 <glguy> I don't see what that would have to do with a list of tuples either
12:36:29 <c_wraith> :t join bimap
12:36:30 <lambdabot> Bifunctor p => (c -> d) -> p c c -> p d d
12:36:45 <glguy> yeah, that doesn't help compute the mean of the fst and mean of the snd given a list of tuples
12:36:55 <c_wraith> No, but neither does the both function
12:37:04 <glguy> I agree, also not helpful
12:37:08 <wroathe> So I'm trying to install a package that depends on text-show-3.6.2, which depends on template-haskell < 2.13. I've got template-haskell-2.13 on my system, and cabal complains that it can't fulfill it's goals because of that constraint...
12:37:23 <glguy> wroathe: template-haskell versions are locked to GHC versions
12:37:25 <c_wraith> If you want to get clever with this, use the fold package or something.
12:37:29 <dukedave> `both` just feels like it should be somewhere in the solution though
12:37:33 <glguy> wroathe: so you'll need to downgrade your GHC to use that package
12:37:43 <glguy> dukedave: What's the problem?
12:37:56 <c_wraith> wroathe: you might also try the --allow-newer flag to see if it really *needs* th < 2.13
12:38:37 <wroathe> glguy: Where that gets interesting is that there appears to be a flag to control this constraint: https://github.com/RyanGlScott/text-show/blob/master/text-show.cabal#L179
12:38:56 <wroathe> But that seemingly has no impact: cabal new-install -f-template-haskell-2-11 text-show-3.6.2
12:39:05 <wroathe> Am I just doing this wrong?
12:39:07 <dukedave> glguy: I just figured there had to be a 'nicer' way to do `(mean $ map fst lines, mean $ map snd lines)` 
12:39:14 <glguy> wroathe: You want to turn that flag *on*, not off
12:39:26 <wroathe> glguy: DOH
12:39:35 <wroathe> epic facepalm
12:39:35 <c_wraith> dukedave: if you really are looking at composing folds, take a look at the foldl package
12:39:37 <hvr> wroathe: it's an automatic flag though
12:39:46 <Solonarv> You can do some shenanigans to do it in one pass, the foldl package is one way
12:39:47 <c_wraith> dukedave: https://hackage.haskell.org/package/foldl
12:39:58 <dukedave> Where 'nicer' = don't use `fst` `snd` and `(,`)
12:40:34 <glguy> Using the technique from the foldl package will have the advantage of being a good consumer of the list, it'll be used in a single pass
12:40:39 <wroathe> hvr: Yeah, even if I specify turning it on it still doesn't work
12:40:39 <glguy> otherwise you can write that using foldl'
12:40:48 <wroathe> [__1] rejecting: template-haskell-2.13.0.0/installed-2.1... (conflict:
12:40:49 <wroathe> text-show +/-template-haskell-2-11 => template-haskell>=2.5 && <2.13)
12:40:54 <wroathe> always gives me this :(
12:41:02 <Solonarv> @let newtype Mean a = Mean (Sum a, Sum a) deriving (Semigroup, Monoid)
12:41:03 <lambdabot>  .L.hs:180:26: error:
12:41:03 <lambdabot>      Not in scope: type constructor or class ‘Semigroup’
12:41:03 <lambdabot>      |
12:41:15 <hvr> wroathe: if you look at http://hackage.haskell.org/package/text-show-3.6.2/dependencies
12:41:17 <Solonarv> % newtype Mean a = Mean (Sum a, Sum a) deriving (Semigroup, Monoid)
12:41:18 <yahb> Solonarv: ; <interactive>:104:48: error:; * Can't make a derived instance of `Semigroup (Mean a)':; `Semigroup' is not a stock derivable class (Eq, Show, etc.); Try GeneralizedNewtypeDeriving for GHC's newtype-deriving extension; * In the newtype declaration for `Mean'; <interactive>:104:59: error:; * Can't make a derived instance of `Monoid (Mean a)':; `Monoid' is not a stock d
12:41:35 <wroathe> Going to try the --allow-newer approach, thanks c_wraith 
12:41:38 <hvr> wroathe: you'll notice that it's merely a discriminator between two bounded ranges 
12:41:51 <dukedave> Ooh thanks glguy and c_wraith , foldl package looks just what I need 
12:42:57 <Solonarv> % toMean a = Mean (Sum a, Sum 1)
12:42:58 <yahb> Solonarv: 
12:43:18 <Solonarv> % fromMean (Mean (Sum total, Sum count)) = total / count
12:43:18 <yahb> Solonarv: 
12:43:23 <glguy> wroathe: It builds fine using GHC 8.4.4 for me, what are you actually doing that fails?
12:43:28 <marvin2> dukedave, yes, map (both mean) would work if you just want to simply the expression
12:43:35 <Solonarv> % fromMean $ foldMap toMean [1..10]
12:43:35 <yahb> Solonarv: 5.5
12:43:38 <marvin2> simplify*
12:43:38 <glguy> wroathe: I tried: cabal v2-repl --build-dep text-show -w ghc-8.4.4
12:44:53 <Solonarv> % join bimap fromMean $ foldMap (join bimap toMean) [ (x, y) | x <- [1..10], y <- [7..31] ]
12:44:54 <yahb> Solonarv: (5.5,19.0)
12:45:22 <glguy> marvin2: No, that doesn't help
12:46:00 <wroathe> glguy: https://gist.github.com/JustinChristensen/f1c7ab050ee172a319aa5d9752005f97
12:46:12 <wroathe> glguy: I'm also on 8.4.4
12:46:42 <wroathe> Basically, I'm trying to pull pasta down as a global package so I can play around with it in ghci
12:46:58 <glguy> wroathe: Part of the problem is that pasta doesn't use the current version of text-show
12:47:21 <wroathe> Should it be required to though?
12:47:40 <wroathe> Sorry for the dumb questions, I'm still getting acquainted with the haskell ecosystem
12:47:42 <glguy> Possibly if the maintainer isn't updating the older versions to work with newer things
12:47:54 <merijn> wroathe: The problem is that the old version of text-show requires an old version of template haskell, which is tied to your compiler version :)
12:47:55 <glguy> It's not Haskell specific. It's maintainer specific
12:48:57 <merijn> wroathe: So pasta won't build because the old text-show can't be compiled with your GHC version. Possibly the only problem is the version bound on text-show (assuming text-show hasn't changed it's API significantly since the version paste requires)
12:49:05 <wroathe> So afaik stack can manage multiple ghc versions on a system. Is the preferred approach to use some stack magic to get an older version of GHC?
12:49:29 <glguy> No, you don't need stack to use different GHC versions
12:49:42 <merijn> wroathe: The preferred solution is to quickly fix the package's constraints and submit a PR ;)
12:49:42 <glguy> cabal does that fine, you select the GHC you want with the -w flag
12:50:18 <merijn> wroathe: You don't even need -w, tbh. Just ensuring the GHC version you want is first in your path is sufficient
12:50:22 <glguy> The constraints should be updated when someone tests that things work with the newer package. That some one might be you today
12:50:52 <monochrom> The burden of history is upon your shoulders.
12:50:55 <glguy> Sure, but setting a GHC version once for a project with -w is better and easier than editing $PATH
12:52:00 <glguy> e.g. cabal v2-configure -w ghc-8.4.4
12:52:22 <wroathe> Alright, thanks guys. This little primer is making me think that this is going to be a common hassle
12:52:48 <merijn> wroathe: It depends on how frequently used your dependencies are
12:53:12 <hvr> wroathe: https://qfpl.io/posts/multiple-ghcs/
12:53:14 <merijn> wroathe: Most of the common packages are updated often and quickly. More obscure ones can have out of date dependency bounds
12:54:08 <glguy> I'm using ghcup now. It symlinks all the GHC binaries into one directory that I have in my PATH: ~/.ghcup/bin
12:54:58 <wroathe> What got me started down this road is that I was evaluating database migration libraries/approaches in haskell and noticed that Yesod's persistence library builds up SQL statements using string concatenation: https://github.com/yesodweb/persistent/blob/master/persistent-postgresql/Database/Persist/Postgresql.hs#L599
12:55:14 <hvr> :)))
12:55:31 <wroathe> I've worked with ActiveRecord in Ruby quite a bit in the past, and they use an AST builder called AREL for building up SQL strings
12:55:57 <wroathe> So I was seeing what the library options are for that in Haskell, which led me to pasta :)
12:56:28 <hvr> wroathe: just wondering, what did you think about opaleye? :)
12:57:31 <hvr> (since you mentioned sql AST builders)
12:57:40 <merijn> hvr: Only supports postgres, though :\
12:57:46 <merijn> Selda looks promising, though
12:58:02 <c_wraith> dukedave: funny, looks like doing that with the foldl library still uses fst, snd, and (,)
12:58:04 <hvr> nice, didn't notice that one
12:58:17 <c_wraith> dukedave: but it will at least run more efficiently. :)
12:58:35 <wroathe> hvr: Haven't looked into that yet. It was on my list.
12:58:47 <wroathe> You guys are great btw. Thanks a ton.
12:58:56 * hvr also recently stumbled over http://travis.athougies.net/projects/beam.html
12:59:09 <hvr> but I haven't yet time to actually try it
12:59:43 <hvr> wroathe: however, the README there has a neat comparison to other haskell db libs
12:59:46 <merijn> hvr: Beam's API looks *way* overcomplicated
13:00:11 <hvr> merijn: which is funny... as it claims to be simpler than opaleye :-)
13:00:26 <dukedave> c_wraith: ooh, good to know, I'll update my TODO ;)
13:16:37 <wroathe> hvr: Wow, Beam sounds awesome. I'm gonna have a look.
13:26:37 <iqubic> Does anyone here use Nix and Emacs?
13:28:32 <iqubic> I'm really not liking the combination of Dante and Nix, because Dante doesn't seem to find the dependencies correctly.
13:30:38 <iqubic> Dante is an emacs package.
13:31:07 <ph88> why do i get a redundant pattern match here ? https://bpaste.net/show/c4e18a9f1485 
13:31:39 <ph88> can not test for pointer equality ?
13:32:09 <Solonarv> Sure you can, but not with a pattern match
13:32:25 <ph88> oh :(
13:32:43 <hpc> you're taking the pointer, whatever it is
13:32:48 <hpc> and naming it nullPtr
13:33:18 <Solonarv> a variable pattern (like the 'nullPtr' in your pattern) will always define a new variable with that name
13:33:39 <koz_> A pattern match essentially names the elements of whatever you're matching against - it doesn't match the elements to anything.
13:33:56 <ph88> by the way .. i'm looking for a way to refactor the lambda on line 14 to 22 .. i don't like the big indent .. but i'm not sure what else i can do here
13:34:16 <Solonarv> you can use a guard instead: case pcre_code of (PCRE_Code ptr) | ptr == nullPtr -> ...
13:34:41 <Solonarv> ph88: use more newlines
13:34:41 <iqubic> So how does one get Emacs and Nix and Haskell to work well together.
13:34:52 <Solonarv> I'll put together an example, one sec
13:34:53 <iqubic> I can't seem to get it to work well.
13:34:57 <koz_> iqubic: A question better asked in a channel dedicated to Emacs I think.
13:35:06 <iqubic> Sure. I'll do that.
13:35:14 <koz_> Since I think your issues are to do with Emacs/Nix integration, which isn't really about Haskell.
13:35:23 <iqubic> Yeah, I suppose.
13:35:34 <hpc> i bet they'll kick it back to here or the nix channel
13:35:50 <koz_> Or to the Dante package perhaps?
13:36:00 <koz_> It may not have been designed with Nix in mind.
13:37:05 <ph88> Solonarv, ok i put some newlines now
13:37:29 <__monty__> iqubic: Best thing would be asking in #nixos, many there use emacs and haskell. Best thing would be to catch johnw online : )
13:38:59 <Solonarv> ph88: https://bpaste.net/show/46da89df09a0
13:39:24 <Solonarv> if you're on ghc 8.6+ you can enable BlockArguments and you don't need parentheses around the lambda
13:39:38 <ph88> thx Solonarv 
13:39:55 <ph88> Solonarv, i like to support an older version of ghc
13:40:16 <Solonarv> Fair enough, just add the parentheses back in that case
13:45:40 --- mode: glguy set +v cronokirby
13:45:44 <cronokirby> i.e. I can just format without having to correct
13:48:23 * hackage ribosome 0.1.1.0 - api extensions for nvim-hs  http://hackage.haskell.org/package/ribosome-0.1.1.0 (tek)
13:50:23 * hackage chromatin 0.1.0.0 - neovim package manager  http://hackage.haskell.org/package/chromatin-0.1.0.0 (tek)
13:51:16 <monochrom> Cute package names.
13:54:18 <Solonarv> My favorite kind
13:55:38 <adius> Hi, does anyone know of a review of Kotlin written by a Haskell developer?
13:57:12 <adius> I find it hard to trust any language reviews not written by a Haskell developer 😅😂
13:57:22 * hackage beam-newtype-field 0.2.0.0 - A newtype for wrapping newtypes into beam schemas  http://hackage.haskell.org/package/beam-newtype-field-0.2.0.0 (Jappie)
13:58:27 <Solonarv> I somehow managed to pick "scorch" as a package name by iterating wordplay from "apecs ui"
14:00:41 <monochrom> Oh that inspires a cunning plan. Start from pretty ordinary wording of what your program does, then go to its entry in Wikipedia, do a random walk from there for say 10 steps and see where you land.
14:08:53 * hackage proteome 0.3.17.0 - neovim project manager  http://hackage.haskell.org/package/proteome-0.3.17.0 (tek)
14:10:16 <Solonarv> Heh. I just did multilingual puns and false-friends
14:32:20 <vaibhavsagar> the other day I had this great idea for what to call a fork of Hugs: jhappi
14:32:30 <vaibhavsagar> which is Hindi for "hug"
14:32:51 <vaibhavsagar> I like that it has one "h" and also ends with "i"
14:35:44 <hpc> adius: i got curious and looked up kotlin
14:35:56 <hpc> it looks like the best option for android dev at the moment, and mediocre for anything else
14:36:40 <hpc> unless there are other android languages now besides java and c++
14:37:38 <hpc> tying it back to haskell a bit, its way of defining methods outside classes reminds me of orphaned instances
14:37:44 <hpc> (and also the worst parts of ruby)
14:38:09 <hpc> i would try to avoid that feature as much as possible, knowing where methods are defined by what class they operate on is really helpful when documentation is lacking
14:39:13 <adius> hpc: Also looks like a good option if you have Java legacy code and need to rewrite it anyways to use Kotlin instead, don't you think?
14:40:08 <hpc> i would look at other jvm languages too, if it's just a general java program
14:40:12 <adius> Yeah, I think there a lot of features which should be avoided in Kotlin, but at least it has some functional "must have" features
14:40:16 <hpc> there are probably better ones out there
14:40:23 <adius> like?
14:40:36 <hpc> (it's hard for me to judge though, the warts of being on jvm are pretty universal)
14:40:54 <hpc> clojure maybe?
14:41:08 <hpc> i forget if jython is still a thing, that might give you a path away from the jvm entirely
14:41:25 <adius> Well, definitely Eta, but it doesn't look production ready. Scala seems to be worse, and clojure is probably to different for the normal Java developer
14:42:02 <hpc> kotlin is fine enough i suppose
14:47:55 <infinisil> monochrom: There was a little game I played some time ago: Start from a random wiki entry, then try to reach the article for "balls" (you know which kind, this was me at ~14 y/o what do you expect) in as few clicks as possible
14:48:40 <DigitalKiwi> https://twitter.com/ArchKiwi/status/1069358576551034885
14:49:39 <DigitalKiwi> eta is more production ready than scala, that's not really saying much tho, but tons of people use scala in production
14:50:58 --- mode: glguy set +v th3j4ck4l
14:53:39 <monochrom> Just rename it to "Beta" and no one will judge its production readiness >:)
14:53:46 <hpc> oh wow, how did i forget about eta
14:56:12 <Arahael> Does haskell offer any tools that help explain why it takes so long to compile?
14:57:26 <dmj`> Arahael: use --disable-optimization
14:57:33 <dmj`> will go faster
14:58:35 <koz_> I'm curious too, since one thing I'm responsible for takes a zillion years to compile, and occasionally exhausts the simplifier.
14:58:37 <ph88> can module names contain underscores ?
14:59:20 <hpc> yes, but it's discouraged
14:59:30 <hpc> just use TitleCase
15:00:06 <dyl> I haven’t figured out what it’ll mean yet, but I’d like to throw out the idea of “pasteurized data types”.
15:00:14 <dyl> I think someone should work it into a new library or paper.
15:00:21 <Arahael> dmj`: Thanks.
15:00:39 <dyl> It’s like sanitizing data, but at higher temp/pressure.
15:01:09 <Lycurgus> boiled or fried, take ur pick
15:01:14 <koz_> How about steamed?
15:01:31 <Arahael> dmj`: ghc: unrecognised flag: --disable-optimization
15:01:42 <dmj`> Arahael: it's a cabal configure option
15:01:51 <dmj`> Arahael: for ghc use --ghc-option=-O0
15:01:59 <dmj`> --ghc-options
15:02:00 <dyl> koz_: don’t remind me about by bao bun addiction.
15:02:03 <dyl> my*
15:02:33 <Arahael> dmj`: Ah - I use stack - will use the ghc option there, thanks :)
15:03:19 <dyl> On that note: if anyone knows a place I can get a good steamed soft shell crab bun in San Diego... 
15:04:00 <Arahael> dyl: Yep, that works.
15:04:09 <Arahael> * dmj` Yep, that works
15:04:26 <dmj`> Arahael: great, yea it should be on by default imo
15:04:31 <dyl> Where is this “Yep, that” restaurant? 
15:04:41 <Arahael> dmj`: I agree.
15:04:53 * hackage clckwrks 0.24.0.10 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.24.0.10 (JeremyShaw)
15:04:57 <dyl> I have the rumblies that only whole giant underwater insects in pillowy buns can satisfy. 
15:05:12 <Arahael> dyl: That would be an awesome restaurant, if only you knew where it was!
15:05:31 <hpc> reminder that food ∈ topic(#haskell-offtopic)
15:06:56 <dyl> hpc prefers his shrimp and lobster in weak headless normal form. ;p
15:16:19 <koz_> More seriously - how would I diagnose why something takes a zillion years to compile and exhausts the simplifier?
15:27:42 <lukelau> With cabal new-build is it possible to install the data-files to a location other than in .cabal/store?
15:29:52 * hackage clckwrks-plugin-page 0.4.3.15 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.15 (JeremyShaw)
15:30:23 * hackage clckwrks-cli 0.2.17.2 - a command-line interface for adminstrating some aspects of clckwrks  http://hackage.haskell.org/package/clckwrks-cli-0.2.17.2 (JeremyShaw)
15:31:53 <DigitalKiwi> there are bars here named "i don't care" and "the office"
15:45:32 <ClaudiusMaximus> cabal new-install is adding some unrequested package to its "user targets" and i can't figure out how to reset its internal state.  any clues?
15:46:44 <ClaudiusMaximus> https://code.mathr.co.uk/et/blob/6e7517ec34b7693b10f8553f49a8c68b19f20dab:/et.cabal#l83 is my cabal file, $ cabal new-install et.cabal -v3 | grep targets
15:46:47 <ClaudiusMaximus> targets: et
15:46:49 <ClaudiusMaximus> targets: array, base, binary, bytestring, containers, deepseq, directory, et, filepath, ghc, ghc-boot, ghc-boot-th, ghc-prim, ghci, grenade, hpc, integer-gmp, pretty, process, rts, template-haskell, terminfo, text, time, transformers, unix
15:47:06 <ClaudiusMaximus> the problem package is grenade, which i did try to new-install in the past
15:47:22 * hackage clckwrks-plugin-media 0.6.16.5 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.6.16.5 (JeremyShaw)
15:47:24 <ClaudiusMaximus> afaict it is not in the dependency chain of et
16:16:09 <ph88> is there a function to map over Left ?
16:16:37 <c_wraith> ph88: see Bifunctor
16:16:59 <c_wraith> ph88: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Bifunctor.html#v:first
16:17:16 <ph88> thx
16:17:43 <Axman6> I'm having trouble with stack on FreeBSD, I can';t seem to get anything to install, whatever I try to install I get  "Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.3: No cabal file found." https://pastebin.com/w8itXMca
16:18:07 <Axman6> I'm installed stack using pkg, but nothing seems to work after that
16:19:20 <hpc> i have a Vagrantfile that installs it with curl -sSL https://get.haskellstack.org/ | sh
16:19:35 <hpc> maybe try that?
16:19:36 <ACheesyName> how do I convert an Int to an Integer? toInteger looks too general
16:20:19 <ClaudiusMaximus> @src fromIntegral
16:20:19 <lambdabot> fromIntegral = fromInteger . toInteger
16:20:22 <hpc> ACheesyName: until you get an ambiguous type error, there's not really such a thing as too general ;)
16:21:32 <Axman6> ACheesyName: "Too general"?
16:21:52 <ACheesyName> :t toInteger
16:21:53 <lambdabot> Integral a => a -> Integer
16:21:57 <Axman6> hpc: yeah I gave that a go and it just says it's already installed
16:22:16 <Axman6> Is an Int not Integral?
16:22:26 <ACheesyName> ah a must be integral I missed that part
16:22:42 <ACheesyName> makes sense now
16:22:49 <Axman6> :t toInteger @Int
16:22:51 <lambdabot> error:
16:22:51 <lambdabot>     Pattern syntax in expression context: toInteger@Int
16:22:51 <lambdabot>     Did you mean to enable TypeApplications?
16:22:57 <Axman6> % :t toInteger @Int
16:22:58 <yahb> Axman6: Int -> Integer
16:22:58 <ClaudiusMaximus> https://hackage.haskell.org/package/integer-gmp-1.0.2.0/docs/GHC-Integer.html#v:smallInteger is the specific version, but you don't want this unless you are doing super-low-level hackery
16:23:24 <Axman6> there'll be a RULE for toInteger :: Int -> Integer
16:23:33 <hpc> s/doing super-low-level hackery/are a ghc dev/
16:23:54 <hpc> low-level hackery and libgmp rarely go hand in hand
16:27:57 <Axman6> oh man, looks like the problem with stack is because of a change in FreeBSD 12's inode C structure, how fun!nhttps://github.com/commercialhaskell/stack/issues/3515
16:31:07 <ClaudiusMaximus> (my cabal issue is resolved, there were some unwanted lines in `~/.ghc/x86_64-linux-8.6.3/environments/default`)
16:34:13 <hpc> open for over a year, that's a shame
16:39:02 <Axman6> there's a fix in there which seems to work (download stack built on 12, and use system-ghc which has also be built on 12)
16:40:02 <Axman6> "fix"
16:40:56 <hpc> that's awful close to a fix of "don't use stack"
16:41:06 <hpc> once you deviate from the resolver, what else does it really offer
16:41:22 <Axman6> eh?
16:41:49 <Axman6> you just need to (hopefully temporarilly) not use a version of GHC not built on FreeBSD 12
16:42:13 <hpc> as long as it's temporary
16:42:15 <hpc> we'll see
16:42:32 <Axman6> this is hardly a stack problem, particularly since you can just pick a resolver which uses the ghc version pkg provides
16:42:34 <hpc> it's a lot worse for me, i don't have a native bsd box so i use vagrant
16:42:53 <hpc> meaning i have to script the ghc build and add however much time to its startup time
17:03:37 <ACheesyName> why doesn't this work? https://repl.it/repls/CookedWillingHack is it the lambda pair syntax not being supported or did I do something else wrong?
17:07:23 <MarcelineVQ> seems like a limitation of the website, either type main on the right, or put module Main where at the top of the file
17:08:41 <ACheesyName> oh wow thanks I was just changing my code to the much clunkier case x of (a,b) -> form
17:11:57 <reygoch> With lens library, how do you modify subfields of a "Maybe" subrecord?
17:12:12 <reygoch> I have a record which maybe has a subrecord in one of his fields
17:12:20 <pounce> can i pattern match with numbers? e.g. have a function definition like `foo 0 = 4\n foo (n+1) = 21 + foo n`
17:12:35 <reygoch> poince: no
17:12:54 <reygoch> poince: but you can use guards to that effect
17:14:00 <reygoch> pounce: you can use single number, but you can't deconstruct them like (n + 1)
17:14:12 <marvin2> what is (n+1) suppose to match?
17:14:15 <monochrom> pounce: "foo 0 =" is OK "foo (n+1) =" is not.
17:14:46 <reygoch> does anyone has some experience with lens library?
17:14:49 <monochrom> Actually "foo (n+1) =" was OK a long time ago but it is now removed from the Haskell standard.
17:14:52 <reygoch> and generic lens?
17:17:20 <Solonarv> reygoch: '_Just' accesses the 'a' in a 'Maybe a'
17:17:50 <pounce> marvin2: it'd match any int but `n` would be its predecessor
17:18:12 <pounce> i guess i have to make my own natural number type \s
17:18:28 <Solonarv> reygoch: so the optic you're looking for is 'outer . _Just . inner'
17:19:19 <reygoch> Solonarv: I've tried '#uriAuthority . #_Just . #uriRegName .~ "some value"'
17:19:34 <Solonarv> why would there be a # in front of it?
17:19:48 <reygoch> Solonarv: but I'm getting an "Couldn't match type' error 
17:20:01 <Solonarv> reygoch: _Just is from lens, not from generic-lens
17:20:13 <reygoch> oh
17:20:36 <Solonarv> If I had meant #_Just, I would have typed that
17:20:57 <reygoch> hm.. still ambiguous
17:21:58 <Solonarv> then the ambiguity probably comes from OverloadedLabels
17:22:19 <Solonarv> try using field @"uriAuthority" and field @"uriRegName" instead
17:22:45 <Solonarv> if that doesn't work I'll need a more complete example of your code
17:26:54 <reygoch> Solonarv: still doesn't work, here is my paste https://pastebin.com/j0gdVdYf
17:27:32 <reygoch> Solonarv: I've pasted example of a structure and example where I'm trying to use lens and the error I get
17:28:57 <Solonarv> oh, now it makes sense
17:29:23 <Solonarv> try replacing '_Just' with '_Just @URIAuth', that should help
17:29:35 <Solonarv> (and I think you can switch back to OverloadedLabels, that isn't the issue)
17:30:21 <reygoch> tried that already and it doesn't work
17:30:25 <reygoch> :(
17:30:52 <Solonarv> "doesn't work" how?
17:31:43 <reygoch> same error
17:32:03 <reygoch> omfg! I've just noticed that URIAuth doesn't have a generic instance
17:33:05 <Solonarv> Ah, oops!
17:34:11 <ph88> how to write a literal hex in source code?  i took this from C  0x40000000u   is it the same in haskell ?
17:34:49 <ClaudiusMaximus> > 0x40000000
17:34:52 <lambdabot>  1073741824
17:35:02 <ph88> what about sign ?
17:35:05 <ClaudiusMaximus> > 0x40000000 :: Word
17:35:07 <lambdabot>  1073741824
17:35:10 <ph88> i guess it depends on the type
17:36:51 <Solonarv> > -0xf0
17:36:53 <lambdabot>  -240
17:54:55 <marvin2> all number literals are polymorphic, type depends on the context
17:54:59 <marvin2> :t 10
17:55:01 <lambdabot> Num p => p
17:56:17 <ACheesyName> :t 1210741897491271987491741987491874192847197
17:56:18 <lambdabot> Num p => p
18:02:43 <fr33domlover> I implemented a variant of foldl' that can stop in the middle and skip the rest of the list, it seems to worl but I'm unsure if it's really strict the way it should be, can anyone please take a look? :) https://share.riseup.net/#Uy2u99lgZm8BFUt1hVU2Mg
18:05:44 <fr33domlover> (I know foldr can short-circuit, but it only does that based on the list item, not on the value being built)
18:06:34 <Solonarv> foldr short-circuits whenever the function you give it doesn't use its second argument
18:08:16 <Solonarv> % :t foldlP'
18:08:17 <yahb> Solonarv: Foldable f => (b -> Bool) -> (b -> a -> b) -> b -> f a -> b
18:08:37 <Solonarv> (I defined it in yahb's ghci so we can see what's happening)
18:09:38 <Solonarv> % foldlP' (< 10) undefined 0 [1..]
18:09:38 <yahb> Solonarv: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:117:16 in interactive:Ghci63
18:10:20 <Solonarv> % foldlP' (< 10) (\_ _ -> 0) 0 [1..]
18:10:20 <yahb> Solonarv: 0
18:10:34 <Solonarv> % foldlP' (< 10) (\_ _ -> 0) undefined [1..]
18:10:35 <yahb> Solonarv: 0
18:10:40 <fr33domlover> % foldlP' (const False) (+) 0 [1..100000000000000]
18:10:45 <yahb> fr33domlover: [Timed out]
18:11:06 <fr33domlover> Solonarv, hmmm in GHCI that gives me 1 instantly
18:11:50 <fr33domlover> ah oops hmmm
18:11:56 <fr33domlover> nope wrong example :p
18:12:03 <fr33domlover> % foldlP' (const True) (+) 0 [1..100000000000000]
18:12:04 <yahb> fr33domlover: ; <interactive>:1:1: error:; * Variable not in scope: foldlP' :: (b0 -> Bool) -> (Integer -> Integer -> Integer) -> Integer -> [Integer] -> t; * Perhaps you meant one of these: S.foldl' (imported from Data.Set), IS.foldl' (imported from Data.IntSet), foldl' (imported from Data.List)
18:12:22 <Solonarv> % let { foldlP' :: Foldable f => (b -> Bool) -> (b -> a -> b) -> b -> f a -> b; foldlP' final f z0 xs = foldr f' id xs z0 where f' x k z = let r = f z x in if final r then r else k $! r }
18:12:23 <yahb> Solonarv: 
18:12:32 <fr33domlover> % foldlP' (const True) (+) 0 [1..100000000000000]
18:12:33 <yahb> fr33domlover: 1
18:12:33 <Solonarv> try again
18:12:34 <coldpress> how do I derive Eq for existential types? ghc tells me the existential types are rigid (and cannot be compared)
18:12:46 <fr33domlover> % foldlP' (> 1) (+) 0 [1..100000000000000]
18:12:46 <yahb> fr33domlover: 3
18:12:49 <fr33domlover> % foldlP' (> 10) (+) 0 [1..100000000000000]
18:12:50 <yahb> fr33domlover: 15
18:13:15 <fr33domlover> Solonarv, seems to work? But should it be "if final r" or "if final $! r" ?
18:13:27 <fr33domlover> I mean did I write it correctly to be strict
18:13:44 <Solonarv> seems right at first glance
18:13:54 <Solonarv> I'm not in the proper headspace to do an in-depth analysis
18:14:38 <Solonarv> 'if final r' should work, since both branches force 'r' anyway
18:14:41 <fr33domlover> Solonarv, btw what's the difference between yahb and lambdabot?
18:14:56 <Solonarv> yahb is a proper GHCi session, lambdabot isn't
18:15:32 <Solonarv> yahb also runs a newer GHC version (IIRC), and has more packages available
18:15:45 <Solonarv> % putStrLn "oh, and yahb can do IO"
18:15:45 <yahb> Solonarv: oh, and yahb can do IO
18:15:53 <Solonarv> > putStrLn "lambdabot doesn't"
18:15:55 <lambdabot>  <IO ()>
18:17:12 <Solonarv> lambdabot on the other hand has some extra features apart from evaluating Haskell expressions:
18:17:30 <Solonarv> @undo do { x <- getLine; putStrLn x }
18:17:30 <lambdabot> getLine >>= \ x -> putStrLn x
18:23:46 <dmj`> coldpress: solution, don't use existential types
18:24:27 <coldpress> dmj`: can't I specify the constraint that both operands to (==) have the same type?
18:24:39 <dmj`> coldpress: can you paste your code
18:27:43 <ClaudiusMaximus> what's a good database (SQL schema?) represenation for members of equivalence classes?  the operation i need is, given one member of an equivalence class, find a canonical member by some metric (metric can change, and the class is constructed incrementally)
18:27:49 <coldpress> dmj`: https://pastebin.com/MP67NZmg
18:29:24 <ClaudiusMaximus> this is for optimizing arithmetic expressions using various costs for (+), (*), etc - of course the expression must compute the same result
18:29:48 <Lears> coldpress: You might be able to use Data.Type.Equality. I've never used it myself, so I'm not sure what its limitations are.
18:30:26 <Lears> You'll also need to wrap up an Eq instance for the type, or you wont be able to compare them even when they are the same.
18:31:49 <Solonarv> add a '(Typeable a, Eq a) =>' context to the 'AnyExpr' constructor
18:32:24 <Solonarv> Typeable lets you recover the type at runtime (so you can check that they match), and Eq lets you actually compare them
18:34:02 <pounce> how do i enable view patterns?
18:34:13 <dmj`> {-# LANGUAGE ViewPatterns #-}
18:34:20 <dmj`> :set -XViewPatterns
18:34:25 <ph88> https://github.com/zirrostig/Htemp
18:43:04 <coldpress> Solonarv: Typeable looks promising
18:43:08 <coldpress> thanks!
18:45:22 * hackage dimensional-codata 2014.0.0.1 - CODATA Recommended Physical Constants with Dimensional Types  http://hackage.haskell.org/package/dimensional-codata-2014.0.0.1 (dmcclean)
20:20:10 <AfC> dimensional-codata looks interesting. There are a number of packages that attempt to do units in the type system. Hard to assess or compare them without having a current use case.
20:49:22 * hackage persistent-sqlite 2.9.2 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.9.2 (psibi)
22:26:14 <ClaudiusMaximus> nice, implemented common subexpression elimination for my arithmetic expression type in ~50 lines of code using uniplate
22:48:19 <iqubic> ClaudiusMaximus: What is uniplate? And how did you do that?
22:49:24 <ClaudiusMaximus> !hackage uniplate
22:49:49 <iqubic> I found it already.
22:50:01 <iqubic> Can't you just use recursion-schemes?
22:50:18 <ClaudiusMaximus> https://bpaste.net/show/f042b7cf7152
22:50:32 <ClaudiusMaximus> i don't know recursion-schemes
22:50:58 <iqubic> What is that doing?
22:51:41 <ClaudiusMaximus> data Expr t = EVar t | EAdd (Expr t) (Expr t) | ...
22:51:54 <ClaudiusMaximus> https://bpaste.net/show/b50b061095e0 example
22:52:00 <iqubic> Sure. I understand how that creates an AST.
22:52:33 <iqubic> Still not quite sure what you are showing me though.
22:52:59 <ClaudiusMaximus> common subexpression elimination is eg turning (x * x) * (x * x) into let y = (x * x) in (y * y)
22:53:33 <iqubic> Oh. I see. I thought you were doing something else.
22:54:30 <iqubic> I thought you were doing stuff like: "0 + X = X" or "1 * X = X" or "0 * X = 0"
22:55:34 <ClaudiusMaximus> i think that's called simplification, i have code to do that too, but it's not as elegant
22:55:52 <ClaudiusMaximus> i wrote it before i learnt uniplate
22:56:29 <iqubic> I am working with ASTs too and learning about recursion-schemes. 
22:56:55 <ClaudiusMaximus> https://code.mathr.co.uk/et/blob/refs/heads/master:/src/Fractal/EscapeTime/Compiler/Expr/Simplify.hs is my simplifier
22:57:21 <iqubic> I'm currently working on "derivation :: Expr t -> Expr t"
22:57:45 <ClaudiusMaximus> https://code.mathr.co.uk/et/blob/refs/heads/master:/src/Fractal/EscapeTime/Compiler/Expr/Deriv.hs like this?
22:58:11 <ClaudiusMaximus> not sure if my inverse trig are correct, need to double check
22:59:10 <iqubic> Yeah, something like that.
22:59:39 <iqubic> I'm going to be using recursion-schemes to factor out the explicit recursion.
23:12:52 * hackage libarchive 0.1.0.0 - Haskell bindings for libarchive  http://hackage.haskell.org/package/libarchive-0.1.0.0 (vmchale)
23:31:53 * hackage rio 0.1.8.0 - A standard library for Haskell  http://hackage.haskell.org/package/rio-0.1.8.0 (MichaelSnoyman)
23:34:23 * hackage libarchive 0.2.0.0 - Haskell bindings for libarchive  http://hackage.haskell.org/package/libarchive-0.2.0.0 (vmchale)
