00:00:03 <coldpress> sclv: thanks for your advice, i'll build ghc-8.2 from source
00:00:52 <geekosaur> that doesn't sound like the advice
00:01:00 <geekosaur> there are bindists for older versions, for one
00:05:29 <coldpress> geekosaur: can stack install an older base package?
00:05:41 <geekosaur> ...
00:05:56 <coldpress> or can it install an older bindist?
00:06:01 <geekosaur> stack can install an older resolver including older ghc and older base
00:06:23 <geekosaur> and yes, has its own binary distributions of ghc
00:06:29 <maerwald> Yep, new-install switches current directory to some random /tmp dir
00:09:08 <sm> maerwald: can file-embed help ?
00:10:34 <maerwald> sm: that just uses qAddDependentFile
00:10:37 <maerwald> which is what is broken
00:11:24 <coldpress> ah right, just change the resolver to 11.22
00:11:31 <coldpress> to get ghc-8.2.2... nice!
00:12:37 <maerwald> and wildcard matching in data-files is broken, haha
00:12:51 <maerwald> Just filing bug reports today I guess
00:17:14 <sm> maerwald++
00:17:26 <sm> keeping the wheels of FOSS turning
00:18:49 <maerwald> if you have foo.bar.png and do extra-source-files: *.png, then it will not match
00:20:44 <maerwald> what is cabal-hash.txt :)
00:23:11 <maerwald> It tries to find a cabal-hash.txt file during new-install somewhere in the store, but can't
00:23:46 <maerwald> https://github.com/haskell/cabal/issues/4130
00:28:00 <maerwald> Sometimes I feel stack has less bugs, although I don't like the design
00:28:21 <maerwald> Probably because cabal carries more legacy code
00:32:10 <[exa]> hm, hindent fails to build for me because of a duplicate typeclass, any ideas on what to do? https://gist.github.com/exaexa/c7bd6a32ef1ac2fd195820bd9c5cdbc3
00:34:25 --- mode: glguy set +v cronokirby
00:36:18 <[exa]> oh, haskell-src-exts-1.21 converted Kind to Type alias
00:37:07 <geekosaur> reflecting ghc's reality for some time, yes
00:37:24 <geekosaur> just comment out the instance definition for Kind
00:40:44 <coldpress> is there a way to prevent stack from installing packages in tmp? I'd like to fix some bugs in packages but the files keep disappearing
00:43:21 <[exa]> geekosaur: good, I'll report an issue upstream as well
00:43:56 <dminuoso> coldpress: What exact workflow do you have to "fix some bugs in packages?
00:44:14 <dminuoso> coldpress: Are you trying to manipulate the dependencies stack manages, by modifying them?
00:45:25 <[exa]> btw any chance that hindent maintainers are around?
00:46:37 <coldpress> dminuoso: i'm installing wxcore-0.92.3.0 with ghc-8.2.2 but CBool is ambiguous so that installation is failing
00:47:25 <coldpress> i want to change the imports in WxcTypes.hs such that CBool is no longer ambiguous
00:48:39 <maerwald> It also seems when you do 'cabal new-insall exe:1 exe:2' it will instlal *all* executables regardless of your choice of executables
00:49:09 <teto> I have a simple function trying to read user input but ends up with Couldn't match expected type ‘IO ()’ with actual type ‘a0 -> m0 a0’ . Here i took out the relevant pieces (dozen lines)  https://paste.ubuntu.com/p/JxHNn6Vf28/
00:50:32 <[exa]> teto: return is always "1-parameter" in haskell, it doesn't have the semantic of terminating a function, just wrapping a value so that it can be passed around as "result" through the monad
00:51:03 <[exa]> so you probably want 'return answer'
00:51:54 <coldpress> dminuoso: i guess i'll install a older version of wx
00:52:22 <[exa]> teto: alternatively, you don't need to even bind the 'answer'   -- doing   'a <- doSomething ; return a'    is perfectly equivalent to just  'doSomething'
01:07:57 <teto> [exa]: thanks but I am just getting started so more code will follow. How can I discard the returned value so that it compiles ? 
01:08:35 <trcc> I have a HS file defining 2 records (A and B), that each contain the field "inputs". I am importing this in another module, and I need to do: A {inputs = inputs B}. But it cannot decide which inputs I mean. I have duplicate record fields in both HS files. Any way to do this? Or should I rename the fields in one of the records?
01:08:42 <[exa]> teto: return ()
01:09:18 <[exa]> teto: () is the 'not really anything' value that is used instead of C-style void
01:10:00 <[exa]> trcc: import qualified?
01:10:04 <maerwald> Anyone knows why "cabal new-run spec:test" tries to execute openBinaryTempFileWithDefaultPermissions while 'stack test' doesn't?
01:10:08 <trcc> [exa] I am using that
01:10:12 <trcc> but both records are in the same file
01:10:17 <teto> aahh that's why, I was sure I had already used "return" durimg a first glimpse at haskell but I must have been wrong, I was using return ()
01:11:38 <[exa]> trcc: so if I understand it, you have some kind of OverloadedRecords thing that doesn't trigger correctly in the other file?
01:13:47 <teto> [exa]: ah thanks a lot, I've spent quite some time bootstrapping the project and finally I feel like I can complete some feature
01:14:19 <trcc> In file V.hs I have 2 records: Data A = A {inputs :: Inputs} and Data B = B {inputs :: Inputs}. In file F.hs I import qualified V. And here I have an instance b :: B. And I need to return a instance a :: A. So I do: V.A {inputs = V.inputs b}. This gives me the error, that inputs could refer to both inputs in A and inputs in B
01:16:31 <[exa]> trcc: what do you get from :t V.inputs ?
01:17:08 <trcc> the error
01:17:24 <trcc> ambiguous occurence
01:18:03 <[exa]> do you have OverloadedRecords turned on somewhere?
01:18:05 <trcc> Yes
01:18:08 <trcc> no
01:18:11 <trcc> I have duplicaterecordfields
01:19:01 <[exa]> what if you explicitly specify that b is B, like: V.inputs (b :: V.B)   ?
01:20:12 <trcc> halleluja
01:20:13 <trcc> it worked
01:20:47 <trcc> really thought the type inference could figure that out?
01:21:06 <[exa]> oh nice.. DuplicateRecordFields don't have a lot of typesystem information available -- it's like trying to do overloading without overloading machinery
01:21:51 <[exa]> it should be able to use V.B from context if it can be inferred (wikipage says so) but it probably wasn't your case
01:33:05 <coldpress_> how does one normally resolve install errors? manually downgrade iteratively until there isn't an error?
01:33:51 <merijn> coldpress_: Install errors of what? Installed using what?
01:35:36 <coldpress_> wxcore-0.92.3.0 installed using stack, error of ambiguous CBool (WxCTypes' CBool and basic package's Foreign.C.CBool)
01:36:22 <coldpress_> according to this open issue https://sourceforge.net/p/wxhaskell/bugs/116/
01:38:08 <merijn> coldpress_: Looks like they define their own CBool which classes with CBool in base. So, yes, you'd have to use a version of base (and thus GHC) that predates that addition
01:40:14 * hackage observable 0.1.4 - Continuation patterns  http://hackage.haskell.org/package/observable-0.1.4 (iokasimovmt)
01:56:39 <coldpress_> merijn: thanks!
02:26:44 * hackage hlint 2.1.12 - Source code suggestions  http://hackage.haskell.org/package/hlint-2.1.12 (NeilMitchell)
02:32:44 * hackage wreq 0.5.3.1 - An easy-to-use HTTP client library.  http://hackage.haskell.org/package/wreq-0.5.3.1 (ondrap)
02:39:13 --- mode: glguy set +v mreh
02:39:15 --- mode: glguy set -v mreh
02:40:47 <mreh> s there a stack command to download an entire snapshot?
02:41:02 --- mode: glguy set +v mreh
02:41:05 --- mode: glguy set -v mreh
02:42:58 <MarcelineVQ> you can add acme-everything-2018.11.18 to the extra-deps of a project using the resolver you desire, if you're brave, never tried it
02:43:51 <MarcelineVQ> that won't neccesarily get everthing from the resolver though, but will (if it works) get more than the resolver has
02:44:17 <MarcelineVQ> fuck me they're not even here
02:44:31 <MarcelineVQ> oh you're back haha
02:44:40 * mreh waves
02:44:49 <MarcelineVQ> anyway essentially you'd be building all of hackage with the hope that it'll pull dependencies from your resolver as needed
02:45:02 <MarcelineVQ> doesn't sound like much fun to me if you value your time :(
02:45:25 <mreh> I'd like to try to put a layer in my docker images that has all the packages for a particular snapshot
02:45:31 <mreh> I've no idea how big that might be though!
02:45:51 <mreh> It's supposed to be an option in the fcpo/stack-build image too, but I gave up on that image
02:46:22 <MarcelineVQ> Oh was about to suggest you check those out, I don't know anything about docker though
02:48:03 <mreh> every time I'm rebuilding a docker image that has updated dependencies, it re-downloads all of them, just thinking through solutions
02:48:38 <mreh> there's probably something in fcpo/stack-build I can copy
02:55:23 --- mode: glguy set +v Orlan
02:59:07 <dminuoso> Who is responsible for hoogle?
02:59:56 <mreh> dminuoso: https://github.com/ndmitchell ?
03:08:09 <dmwit> mreh: You can probably just copy the cabal freeze-file into a build-depends block.
03:09:08 --- mode: glguy set +v mitologi
03:10:43 <dmwit> mreh: e.g. check out https://www.stackage.org/lts-12.22/cabal.config
03:11:33 <mreh> dmwit I was looking for that, thanks
03:11:35 <mitologi> channel rearrangement
03:26:56 <dminuoso> mreh: Ah no I meant who is responsible for hosting hoogle?
03:27:07 <dminuoso> It seems as if hoogle is down.
03:27:13 <dminuoso> Or has been for a bit.
03:29:24 * hackage hledger-ui 1.12.1 - Curses-style user interface for the hledger accounting tool  http://hackage.haskell.org/package/hledger-ui-1.12.1 (SimonMichael)
03:29:36 <mreh> dminuoso, oh! boo
03:33:47 <[exa]> dminuoso: looks like there are database updates or whatever every now and then, I've seen 3-minute downtime someday last week
03:34:59 <dminuoso> [exa]: Well it's been down for about an hour now, so... :)
03:37:03 <merijn> dminuoso: #haskell-infrastructure
03:38:55 <Jetien> Hi, if i write a type class "class Foo a where bar :: [Int]" can I even use "bar"? I don't know how I would give a type hint for "a" when using "bar"
03:39:52 <merijn> Jetien: That's why Proxy was invented
03:40:11 <[exa]> dminuoso: oh so
03:40:20 <merijn> Jetien: Because the answer to "how would I give a type hint?" is "you wouldn't/can't"
03:40:38 <Jetien> merijn: thanks
03:41:15 <merijn> Jetien: Generally the most flexible solution is to write it as "class Foo a where bar :: proxy a -> [Int]"
03:41:27 <merijn> :t Proxy
03:41:29 <lambdabot> forall k (t :: k). Proxy t
03:42:00 <merijn> That lets you use Proxy (or any type of kind "* -> *", like Maybe, [], etc. that you happen to have lying around) to select which Foo instance
03:48:44 <Boomerang> You can get away with not using `Proxy` by instead enabling `AllowAmbiguousTypes` and `TypeApplications`. But this is probably not recommended? I don't know what the consensus is on `AllowAmbiguousTypes`, the name is not very reassuring... ^^
03:51:46 <Boomerang> % class Foo a where bar :: [Int]
03:51:47 <yahb> Boomerang: 
03:51:56 <Boomerang> % instance Foo Char where bar = [3]
03:51:56 <yahb> Boomerang: 
03:52:03 <Boomerang> % bar @Char
03:52:04 <yahb> Boomerang: [3]
03:52:34 <Rerecursing> Hi all! We're having problems installing arbtt on arch linux :(
03:52:47 <Rerecursing> (a haskell package)
03:53:18 <Rerecursing> I know it's arch linux fault for making it so annoying, but everybody I know tried for a while and failed
03:53:32 <merijn> Boomerang: Neither of those are recommended, in my opinion
03:53:55 <Rerecursing> I think the easiest way should be `$ cabal v2-install arbtt` but it gives me an error
03:53:57 <Rerecursing> cabal: ghc-pkg dump failed: dieVerbatim: user error (cabal: '/usr/bin/ghc-pkg'
03:53:59 <Rerecursing> exited with an error:
03:54:00 <merijn> TypeApplications is brittle as it makes things not generally considered part of the public API a part of the public API
03:54:01 <Rerecursing> ghc-pkg: /home/lorenzo/.cabal/store/ghc-8.6.2/package.db:
03:54:03 <Rerecursing> getDirectoryContents:openDirStream: does not exist (No such file or directory)
03:54:05 <Rerecursing> )
03:56:26 <Rerecursing> I think it's because ghc is 8.6.2 and in .cabal/store I only have 8.4.4
04:00:28 <Boomerang> merijn: Yeah like the order of the argument in an explicit forall. I agree it's not great. I do like TypeApplications though and I wish `:t` and haddock properly showed the order of type variables in the type signatures
04:00:41 <dminuoso> Boomerang: The extension AllowAmbiguousTypes is harmless.
04:01:48 <dmwit> Boomerang: :set -fprint-explicit-foralls and then use :t +v
04:02:02 <dmwit> Boomerang: (You can set these up to be more transparent in your .ghci)
04:03:11 <Boomerang> Yes I remember that one! It should become the default if we ever want to use TypeApplications reliably :)
04:03:41 <Boomerang> I think you told me about -fprint-explicit-foralls and :t +v, very useful! :)
04:04:19 <dmwit> The one you can copy directly into .ghci. For the other, here's what I use:
04:04:31 <dmwit> (starting about... 120 seconds ago ;-)
04:04:32 <dmwit> :def t Prelude.return Prelude.. (":type +v "Prelude.++)
04:04:44 * hackage alist 0.1.0.3 - lists with O(1) append  http://hackage.haskell.org/package/alist-0.1.0.3 (AlanHawkins)
04:05:27 <dmwit> Hm. Probably one day having this will confuse me, because I'll try :t +d or something.
04:05:37 * dmwit thumbs his nose at future dmwit
04:07:06 <dmwit> merijn: Eh. I like it. Let's just fix the general consideration instead of avoiding this useful tool.
04:08:03 <Boomerang> I usually try to not add too much to my .ghci, otherwise I get the ilusion that things work properly (missing language extensions), but I guess this version of `:t` seems fairly harmless :D
04:08:27 <dmwit> I think it's amusing to say "you can't specify the type, so we invented Proxy". Bit of history rewriting there. ^_^
04:10:40 <dmwit> (We had e.g. `bitSize :: Bits a => a -> Int` since the dark ages. `Proxy` was invented to avoid the unspoken "never inspect the argument" contract, not to have a way to pass a type.)
04:10:51 <[exa]> A bit general question: What's the best way to create extensible AST-like structures? Suppose you've got a gloss-like description of something (Picture) and you need to interpret it by several different ways (in gloss that would be: 1] draw it 2] just guess the bounds 3] output SVG of that), but want the thing to be extensible (e.g. for easily adding new shapes).
04:11:10 <dmwit> [exa]: Sounds like the expression problem.
04:11:32 <[exa]> The usual design leads to easy extensibility of the "methods" (you just write the function) on a rigid AST, I have a limited amount of "methods" but need to extend the AST quite a bit
04:11:52 <dmwit> [exa]: The standard answer there I think is the Data Types a la Carte paper, at which point after spending a few hours understanding what's going on you decide "yeah, okay, turns out I don't need both kinds of extensions so bad as to want to do *that*"...
04:13:01 <[exa]> that is the paper about how either extensions of typeclasses or of underlying types are bad?
04:13:42 <dmwit> Oh, it sounds like you've already come down on one side of the expression problem. Great. That simplifies things.
04:13:58 <[exa]> anyway, as a first thing I'm just trying to find a general structure that would allow ASTs to be extended, data AST = A | B | C is not very inflatable
04:14:37 <[exa]> my best guesses is 1] free monads 2] GADTs for existential-style type
04:14:59 <[exa]> but well, kindof wanted to hear any available opinions before diving into the mess :]
04:15:10 <Boomerang> Is the Trees That Grow solution overkill?
04:15:19 <[exa]> lemme google that
04:15:33 <dmwit> st
04:15:38 <dmwit> (Sorry.)
04:17:15 <Boomerang> [exa]: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf
04:20:21 <[exa]> Boomerang: hm it looks like 3.4 is about my problem
04:22:02 <[exa]> ok that's a really spj-style solution. :]
04:22:05 <Boomerang> Yes! I'm not sure if this technique has been used for anything practical yet. If I remember correctly there were talks about using it for the main ADT in GHC
04:23:32 <wz1000> That is the style used for the GHC ADT in newer versions of the compiler
04:24:33 <wz1000> and the work is still ongoing
04:24:49 <[exa]> I'll probably fallback to existential+typeclass solution, but the pattern aliases etc. is an inspiring way to do that
04:25:56 <[exa]> from a greater distance the result should be just 'extensible-AST interpreter with N different ways to interpret everything'
04:26:02 <wz1000> [exa]: alternatively, if you don't need serialization, you can represent the data asa record of the methods
04:26:34 <[exa]> that's what existentials basically do under the hood, isn't it?
04:26:41 <[exa]> but yes, that's probably the most visible way
04:26:44 <[exa]> thanks
04:30:28 <josteink> I have (pretty general?) type-system question, and Im curious if anyone in here has an opinion on it
04:31:00 <josteink> Basically, in a (typescript-)project Im now having two different retry transformations for lambdas
04:31:04 <josteink> / (lambda() => T)           ==> Promise<T> (with retry)
04:31:06 <josteink> / (lambda() => Promise<T>)  ==> Promise<T> (with retry)
04:31:34 <josteink> does anyone have an opinion on if one of these are a generalized form of the other, and if so, which one? :)
04:32:52 <lyxia> isn't the latter a generalization of the former?
04:33:36 <lyxia> given  t : T  you can always wrap it in a promise to use the second retry
04:33:37 <josteink> I wasnt entirely sure, but giving it a thought, I figured that the former can easily be applied to the latter, since a T can easily be transformed into a Promise<T>
04:33:45 <lyxia> :)
04:33:51 <josteink> so yes, I guess the latter is the generalization.
04:34:13 <josteink> This whole "talking to a duck (called the internet)" thing really works well, huh? :)
04:34:18 <lyxia> quack
04:35:04 <josteink> thanks for quaking
04:35:10 <Jerbot> you know what T stands for?
04:35:42 <josteink> hm. what do you mean?
04:38:09 <Jerbot> In the UK, it's a solicitation 
04:38:11 <[exa]> ok nice that was faster than I thought
04:38:32 * Jerbot steals a beer and clammers off. 
04:40:04 <[exa]> so I'm at this AST that's extensible and can be interpreted in 2 ways: https://gist.github.com/exaexa/68cfcd2763b1214bc2e15d957c7fe66f
04:40:44 <[exa]> Q: there's the obvious Code (Something (Code ...)) pattern, if I substutite f=Code, isn't that some kind of Free construction?
04:42:10 <opqdonut> [exa]: that's just Mu (Code :.: f)
04:42:12 <opqdonut> or so
04:43:01 <[exa]> that would be Code(f(Code(f(Code(f(...infinity))))))) right?
04:43:42 <opqdonut> yeah I was kinda imagining you'd parameterize Addition with Code
04:43:59 <opqdonut> that's the pattern I've used for extensible ASTs
04:44:38 <opqdonut> if my AST is expressed as (Mu AstF), I can add annotations by switching to (Mu (AnnotateF :.: AstF))
04:45:23 <[exa]> so I can parametrize the whole thing with param=Mu Code, thus getting out the "static" Code everywhere
04:45:27 <[exa]> does it help anything else?
04:46:07 <opqdonut> I found it useful because I could write types for my compiler passes
04:46:11 <[exa]> except for ofcourse having the base switchable so I can (oh god) even have extensible amount of typeclasses for each
04:46:21 <[exa]> gooooood
04:46:33 <opqdonut> something like: Mu AstF -> Mu (TypeAnalysisF :.: AstF)
04:46:49 <opqdonut> and Mu (TypeAnalysisF :.: AstF) -> Mu (RegisterColouringF :.: AstF)
04:47:02 <opqdonut> and Mu (RegisterColouringF :.: AstF) -> Output
04:47:20 <opqdonut> but maybe that's not what you're after, but actually being able to extend the AstF
04:47:57 <[exa]> yeah this extends it to "depth", I'm more after convenient width extensions
04:48:06 <opqdonut> I guess you could do something like (Mu (Sum AstF MyAdditionsF))
04:48:13 <opqdonut> but then you'd need to navigate the nested sums
04:48:24 <opqdonut> which is kind of a PITA
04:48:27 <[exa]> yep
04:50:11 <[exa]> ok nevermind, I can easily stuff anything instead of the Code later using Mu, which will come quite useful
04:52:09 <[exa]> but yeah, Free can perfectly be used for building the thing
04:54:15 * hackage net-spider 0.2.0.0 - A graph database middleware to maintain a time-varying graph.  http://hackage.haskell.org/package/net-spider-0.2.0.0 (debugito)
05:00:41 <uptick> quick question about cabal, so when i was updating cabal and installing pacakges with it, it mentioned that i was using the legacy v1 style of cabal usage. please switch to using either the new project style commands or the legacy v1 command alias as new-style projects will become the default in the next version of cabal-install? o.0
05:01:08 <uptick> this happened when i was updating cabal and when i was doing cabal install <package>
05:01:21 <uptick> do i need to redo or something? 
05:04:12 <dmwit> That should be just a warning for now.
05:04:26 --- mode: glguy set +v lf
05:04:30 <dmwit> i.e. whatever action you took should not have failed merely because you chose the wrong name for the action.
05:04:37 <dmwit> But you'll want to retrain your fingers. =)
05:04:51 <dmwit> (And update any scripts you have.)
05:05:37 <uptick> i might just delete my .cabal folder and start again lol
05:05:44 <uptick> first time using haskell and cabal
05:05:50 <uptick> i used this https://github.com/haskell/ghcup
05:05:52 --- mode: glguy set +v guest___
05:06:01 <dmwit> Why delete .cabal?
05:06:37 <uptick> basically, with arch all haskell libraries ends up become a pacakge 'cuz the package manager dynamically link haskell stuff
05:06:44 <dmwit> 1. it's not needed 2. it probably doesn't do what you think it does anyway
05:06:50 <uptick> so i had to use this ghcup in order to bypass arch's pacman manager
05:07:30 <uptick> i should be using the new-style projects commands?
05:07:41 <uptick> or the new style projects v2-... commands?
05:07:45 <dmwit> Well. I use them and like them.
05:08:39 <uptick> by the way say i wanna install the package Tidal
05:08:47 <uptick> do i run cabal install tidal?
05:08:55 <uptick> that's the old way i guess
05:09:04 <uptick> cabal new-install tidal
05:09:08 <uptick> would be the new way i guess
05:09:19 <trcc> [exa]: you helped me earlier with my issue related to records. Memory refresh:
05:09:24 <trcc> In file V.hs I have 2 records: Data A = A {inputs :: Inputs} and Data B = B {inputs :: Inputs}. In file F.hs I import qualified V. And here I have an instance b :: B. And I need to return a instance a :: A. So I do: V.A {inputs = V.inputs b}. This gives me the error, that inputs could refer to both inputs in A and inputs in B
05:09:27 <uptick> someone from reddit mentioned this though:   cabal new-repl --build-depends tidal
05:09:42 <[exa]> trcc: check
05:09:50 <trcc> I am sorry I had to leave
05:10:00 <trcc> but I do not understand why the type inference does not owkr automatically
05:10:19 <[exa]> trcc: put a _ instead of the V.inputs there
05:10:25 <[exa]> to see what it sees
05:11:32 <trcc> Found hole: _ :: V.Setup -> V.Inputs
05:11:56 <trcc> inputs is of type Inputs and Setup is the B
05:12:27 <dmwit> trcc: I guess you're using DuplicateRecordFields.
05:12:31 <trcc> dmwit: yes
05:12:48 <trcc> [exa]: this type seems correct. There is only 1 record field that does this
05:12:49 <dmwit> trcc: DuplicateRecordFields *only* disambiguates field names when they are on the left-hand side of record syntax.
05:13:23 <dmwit> trcc: So you will have to write something like `case b of V.B { inputs = i } -> V.A { inputs = i }` or so.
05:13:36 <dmwit> trcc: (Or hoist the pattern match to wherever `b` is getting bound, of course.)
05:14:11 <trcc> ah the b :: B does not work either
05:14:51 <trcc> ok
05:14:52 <trcc> thank you
05:14:59 <trcc> Man they should change this
05:15:26 <[exa]> that's what overloadedRecords are for :]
05:15:34 <trcc> ah no
05:15:48 <dmwit> trcc: I think you could also write `V.A { inputs = (V.inputs :: B -> Inputs) b }`.
05:15:55 <dmwit> But I'm not sure.
05:16:07 <[exa]> dmwit: wiki says that should work, yes
05:16:34 <trcc> i do not understand why : V.A {inputs = V.inputs (b :: V.inputs)} works, when V.A {inputs = V.inputs b} does not work
05:16:50 <dmwit> That definitely shouldn't work.
05:16:54 <trcc> it does
05:16:57 <dmwit> Did you mean `(V.inputs b :: V.Inputs)`?
05:17:14 <trcc> V.FMIComponent {inputs = V.inputs (s :: V.Setup)}
05:17:31 <dmwit> Yes, *that* I believe.
05:17:39 <trcc> but why can it not deduce the type of s?
05:17:59 <trcc> It comes directly from this case switch:     Just (s :: V.Setup) -> do ...
05:18:04 <Athas> What's the best way to work with futures in Haskell?  The Par monad?
05:18:40 <dmwit> trcc: It turns out that in the general case, type-directed name resolution is super hard. =)
05:19:03 <bwe> I usually have conflicting record names (different types with some records carrying same values). Is there some better way than just to give the record a (slightly) different name? 
05:19:14 <dmwit> trcc: Generally the flow is the other way: when you encounter a name during type inference, you *look up* its type.
05:19:25 <dmwit> trcc: You don't assume you know its type, and use that fact to decide which entity the name refers to.
05:19:46 <dmwit> bwe: The module system is still the best namespacing mechanism Haskell has to offer.
05:19:46 <trcc> well the type of s is decided
05:20:16 <trcc> [exa]: overloadedrecords is that a proposal or?
05:20:18 <dmwit> trcc: That is a misunderstanding on your part, it turns out. I agree it *looks* like it should be clear... but the algorithm simply doesn't work that way.
05:20:42 <dmwit> trcc: Now, if you want to propose an alternate algorithm, I'm sure there will be some people who will be interested to hear about it. =)
05:20:45 <trcc> hehe I am sure it is a misunderstanding on my part, just trying to dig a bit deeper :) But hank you
05:20:52 <trcc> dmwit: some day I will :P
05:20:58 <trcc> probably fixed by then
05:21:08 <trcc> [exa]: this one? https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
05:21:42 <dmwit> I'm happy to explain further. But fair warning: it would probably take an hour or two to fill in background before I could...
05:21:47 <bwe> dmwit: I don't understand the context of module system. Would you mind to elabourate on this?
05:22:17 <trcc> dmwit: go ahead, i'll check the log later :P  - thank you for your answers. They were useful and enlighting!
05:22:43 <dmwit> bwe: doesn't work: `data A = A { id :: Int }; data B = B { id :: Int }` does work: `module A where data A = A { id :: Int }` and `module B where data B = B { id :: Int }`.
05:23:09 <dmwit> trcc: Uh, well, if you want something non-interactive, then there's papers out there on Hindley-Milner.
05:23:27 <trcc> already toooo many papers behind.. But yes, that is actually in my pile
05:23:42 <dmwit> https://stackoverflow.com/q/12532552/791604 perhaps would be an approachable starting point
05:24:15 <bwe> dmwit: Got that. Usually I want to work with A and B in the same context. How do you manage that?
05:24:41 <dmwit> bwe: import qualified My.Package.A as A; import qualified My.Package.B as B
05:24:55 <dmwit> bwe: If you want the type names bare you can also import My.Package.A (A) and import My.Package.B (B)
05:25:17 <dmwit> Or import My.Package.A (A(A)) or whatever if you want the constructors, too.
05:26:55 <dmwit> (...and then `A.id` and `B.id` are how you disambiguate between the two `id`s.)
05:27:29 <dmwit> (It's a bit like using a prefix, except that the library user gets to decide what prefix it is, including none at all if they only care about one of them! Nice.)
05:33:44 * hackage hoogle 5.0.17.4 - Haskell API Search  http://hackage.haskell.org/package/hoogle-5.0.17.4 (NeilMitchell)
05:34:02 <dmwit> Athas: A lot of people seem to recommend the async package, though if you don't need IO then Par does seem like a nice choice, too.
05:38:17 <merijn> Athas: Depends on the context?
05:38:50 <merijn> I mean "forkIO with blocking sequential code" is a perfectly sensible way of dealing with that, for example...
05:39:10 <merijn> So are the futures dependent on each other? Independent? Need IO? etc.
05:41:14 <Athas> merijn: I've just become inspired from reading a lot of papers on how to efficient schedule futures and such.
05:41:30 <Athas> I didn't realise it was such an academically active area.
05:42:33 <Athas> (Data parallelism is still the choice of the refined gentleman, of course.)
05:47:16 <michalrus> We can have strings in types (Symbol), but can we have numbers?
05:48:17 <lyxia> Nat
05:52:00 <Solonarv> As the name indicates, they're natural numbers, i.e. 0 and up
06:07:38 <seishun> how do I print out every string in a list, and stop for input on every step? something like `mapM_ (putStrLn >> getLine)`
06:08:47 <merijn> seishun: Eh, that would work, just needs a lambda to deal with putStrLn's argument
06:09:02 <merijn> seishun: Although mapM_ would throw away all lines you read from stdin
06:09:21 <seishun> yes, I just need it to pause
06:09:27 <seishun> any way to do it without a lambda?
06:09:27 <merijn> :t mapM_ (\s -> putStrLn s >> getLine)
06:09:31 <lambdabot> Foldable t => t String -> IO ()
06:09:48 <merijn> Maybe, but why would you? It'd just makes things more confusing to read
06:09:54 <fendor> seishun, mapM_ ((>> getLine) . putStrLn)
06:10:03 <merijn> Yeah...don't do that
06:10:31 <fendor> i agree
06:10:35 <seishun> yeah
06:11:05 <__monty__> Don't go down the pointfree rabbit hole just for the sake of it, it's pointless.
06:11:37 <cemerick> I have -fbreak-on-exception in GHCi, but ^C while waiting for `:trace <some-expr>` to come back still just interrupts evaluation, rather than dropping to the debugger. What am I doing wrong?
06:22:44 * hackage observable 0.1.5 - Continuation patterns  http://hackage.haskell.org/package/observable-0.1.5 (iokasimovmt)
06:27:54 <__monty__> I have a haskell program that blows its stack when run with runghc. How do I find out which parts cause this?
06:30:37 <__monty__> The part I have trouble with is I have no explicit recursion. I know haskell does TCO so that shouldn't cause stack overflows anyway but I can't get my brain around what the problem *is* if not recursion.
06:30:59 <__monty__> I suspect it's the fold I'm doing but switching from foldl to foldl' didn't help.
06:33:04 <Ariakenom_> __monty__: what about https://wiki.haskell.org/Debugging#Stack_trace ?
06:33:53 --- mode: glguy set +v Ferdirand
06:33:59 <merijn> __monty__: "does TCO" <- yes, no, maybe
06:34:03 --- mode: glguy set +v cronokirby
06:34:27 <cronokirby> normally you can get a stack overflow if you try to right fold over something huge
06:34:39 <merijn> __monty__: Depending on your point of view, GHC either implements *every* function as a tailcall, or no functions as tail calls
06:35:02 <__monty__> cronokirby: Aha, but I'm left folding over something huge /smirk
06:35:16 <__monty__> merijn: Tell me more.
06:35:16 <Athas> Does GHC ever do tail call optimisation when evaluating chains of thunks?
06:35:20 <Athas> (Is that even possible?)
06:35:27 <merijn> __monty__: GHC Haskell doesn't use a function call stack at all, so you can never stack overflow with recursion
06:35:52 <cronokirby> normally foldl on something big shouldn't overflow
06:35:58 <cronokirby> it'll just use a bunch of memory
06:36:26 <cronokirby> Athas: well it's just due to lazy evaluation
06:36:29 <merijn> __monty__: Instead there is a stack of pattern matches (plus which code to call based on the match), which you can sometimes overflow, but that's generally hard
06:36:45 <merijn> __monty__: Do you have an example of the code you're running
06:37:40 <dminuoso> Interview question 1: Will this exhaust your stack or heap? foldr (+) 0
06:37:55 <__monty__> [Spoiler alert] It's advent of code day 9: http://ix.io/1vI9
06:37:58 * dminuoso blinks at merijn, as he asked these questions before..
06:37:59 <merijn> dminuoso: Neither, because it's not applied to anything so not evaluated :p
06:38:09 <dminuoso> merijn: Oh well!
06:38:14 <merijn> dminuoso: Bam! Lawyered!
06:38:24 * dminuoso crawls back
06:39:16 <merijn> __monty__: Needs less if/then and more guards :)
06:40:07 <dminuoso> And type annotations.
06:40:24 * __monty__ hacks away at the if-then-else's furiously
06:40:32 <merijn> __monty__: Instead of having "let nP = foo in .." in each side of if/then you can instead just have "myCond = n `multiple` 23; nP | myCond = {- true branch -}; | otherwise = {- false branch -}"
06:40:32 <dminuoso> 30 lines without a single annotation, packed with so much code.. no idea what that does.
06:40:58 <merijn> __monty__: Extra bonus, writing it that way you can move everything inside where instead of using let (which is ugly, imo)
06:41:24 <Athas> __monty__: the foldl' makes no difference because it will only force the tuple constructor.
06:41:32 <Athas> But I am quite sure your problem is a standard space leak.
06:42:07 <merijn> __monty__: If Athas is right you can probably use BangPatterns on the tuple in makeMove to solve the leak
06:42:51 <merijn> Incidentally, using guards for "conditionally setting a variable" is severely underrated as code cleanup tool
06:44:02 <Athas> I agree; guards on non-functions is very useful but rarely used.
06:45:09 <cronokirby> yeah I had no problem with space leaks on my day 9 solution
06:45:28 <merijn> Athas: I guess people just forget that it's possible, because they usually see guard introduced on functions
06:46:29 <cronokirby> https://github.com/cronokirby/Advent-2018/blob/master/9.hs
06:46:45 <Athas> merijn: I'm halfway sure that Haskell defeated SML/OCaml because of such small syntactic advantages!
06:47:01 <Athas> Pattern guards, n-ary constructors, the case-sensitive syntax...
06:47:10 <Athas> I value that much more than I do the laziness or the enforced purity.
06:47:18 <Ariakenom_> yeah I hadn't thought about guards on non functions. cool
06:47:58 <mniip> dminuoso, both, whichever is shorter?
06:50:51 <cemerick> so I've found my issue without using the debugger, but I'm still curious, so I'll repeat my question :-)
06:50:54 <cemerick> I have -fbreak-on-exception in GHCi, but ^C while waiting for `:trace <some-expr>` to come back still just interrupts evaluation, rather than dropping to the debugger. What am I doing wrong?
06:51:43 <dmwit> cemerick: Hm. Is <some-expr> only using interpreted things?
06:52:31 <cemerick> dmwit: I guess I don't know?
06:52:58 <merijn> The GHC runtime by default intercepts the ^C signal, and runs a signal handler to signal the main thread with an async exception
06:53:09 <dminuoso> mniip: Realistically it would only overflow the stack though.
06:53:12 <merijn> So the question is: Does ghci evaluate expressions in the main thread?
06:53:23 <merijn> And/or does ghci provide a different handler?
06:53:51 <merijn> I suspect ghci always treats ^C as abort, rather than *actually* raising the async exception in the interpreted code
06:53:53 --- mode: glguy set +v nksegos
06:54:17 <merijn> So I'm not sure this *can* work like you want
06:54:42 <mniip> dminuoso, but foldr is not strict, so foldr f z (x:xs)  creates a thunk for  foldr f xs  on the heap
06:55:07 <mniip> and then enters f, and then f case-analyses its arguments
06:55:14 <mniip> which consumes stack
06:55:17 <cemerick> merijn: ok; fwiw, I'm just following the advice from https://wiki.haskell.org/Debugging#Infinite_loops
06:55:35 <merijn> cemerick: Which OS?
06:55:56 <cemerick> merijn: a linux atm
06:56:18 <merijn> cemerick: Also, that advice is from 2007, so I'm not sure ghci hasn't changed since then. But the good news is, we have stack traces in compiled code now!
06:56:48 <merijn> cemerick: If you compile with -profiling and run with "+RTS -xc" you get stack traces for exceptions, so you can then ^C the compiled version and that *should* work right
06:57:15 <merijn> (The GHC user guide has all the details on profiling, RTS opts and stack traces)
06:57:34 <cemerick> merijn: Okay, I will investigate those bits, thank you.
06:57:51 <bwe> dmwit: Thanks for your point on using modules for disambiguate same record names between different types.
06:58:08 <cemerick> For context, the code in question is traversing an indirectly-mapped tree, a branch of which had a loop.
06:58:19 <dmwit> bwe: Cheers!
06:58:51 <cemerick> So being able to break interactively (rather than just at a pre-determined breakpoint or exception throw) would have been the ticket
07:00:11 <merijn> cemerick: Might also want to ask in #ghc and see if anyone knows what's up and why it doesn't work
07:07:48 <__monty__> Hmm, is this what you were talking about re the guards and bangpatterns. Not sure replicating the guard is all that much clearer tbh. http://ix.io/1vIm
07:08:11 <__monty__> The bangpatterns don't seem to have helped.
07:09:08 --- mode: glguy set +v genuisghost
07:16:45 * hackage hwormhole 0.1.0.0 - magic-wormhole client  http://hackage.haskell.org/package/hwormhole-0.1.0.0 (rkrishnan)
07:20:41 <avidela> Hi, I have a typeclass with associated types with two instances. I've indexed them using an empty datatype (D1, D2) I have a plain ADT like so `data Datatype = One | Two` I would like to have a function that call the right instance of my typeclass (D1 or D2) depending one a value of `One` or `Two`. How shoud I proceed?
07:22:20 <__monty__> Another version because my imperatively inspired index trickery was actually slower than just rotating the Sequence. http://ix.io/1vIu
07:23:51 <__monty__> avidela: It sounds like you're looking for singleton types. If you didn't intend to do dependently typed stuff though you might want to rethink your approach.
07:24:09 <avidela> I do intend to use dependently typed stuff
07:24:45 <avidela> __monty__ I'm quite familiar with Idris but Haskell's way of handling lifting values to the type level is still very opaque to me
07:25:19 <__monty__> rkrishnan: Magic-wormhole's pretty cool. Have you seen croc? I like/prefer their UX/philosophy. https://github.com/schollz/croc
07:25:44 <__monty__> avidela: Dependent types in haskell isn't called hasochism for nothing ; )
07:26:05 <avidela> __monty__ hahaha I was reading that paper today
07:27:15 <glguy> __monty__: you'll get better performance out of Seq of you can stick to working with the ends
07:28:16 <__monty__> glguy: I think I am now. Unless you're referring to splitAt? Or did you mean the iX stuff?
07:29:15 <glguy> Yeah, split At
07:30:04 <rkrishnan> __monty__: thanks. I haven't looked at croc. I will take a look.
07:30:07 <glguy> https://github.com/glguy/advent2018/blob/master/execs/Day09.hs was how I used splitAt
07:30:35 <rkrishnan> __monty__: please use it and let me know how it goes. Glad to help.
07:30:55 <__monty__> glguy: I'm trying to avoid spoilers for now. Seeing you mention Data.Seq the other day was already a spoiler : )
07:31:00 <glguy> Seq gets more expensive when you work with its middle with deleteAt and insertAt
07:31:37 <__monty__> rkrishnan: Well, my wormhole needs fit the croc scenario perfectly so I'm afraid I won't be able to try it : )
07:31:56 <__monty__> glguy: Makes sense, it's what I observed.
07:32:00 <rkrishnan> __monty__: Just had a quick look at croc. We use exactly the same technique, PAKE (specifically SPAKE2) underneath.
07:33:26 <glguy> If you want an antispoiler, you can solve this faster not using Seq
07:34:00 <glguy> You could always start over :)
07:34:11 <coldpress> what is faster than Seq?
07:35:17 <__monty__> rkrishnan: No, what I'm talking about is "simply running the binary will ask for a wormhole code" stuff like that makes it *so* much easier for non-techies. Explaining windows' cmd to someone who's never used it while never having used windows myself proved to be too big a hurdle.
07:35:36 <Kekker_> Hello, I'm back with some more questions
07:37:12 <Kekker_> I have code that takes the first line of input and parses it into a tree, and I want to pass that tree into another function for every line of code that comes after. I just don't know how to pass it. Is there a way to save the tree and pass it as an argument?
07:37:18 <Kekker_> "main = interact (\s -> case lines s of first:_ -> fst parse ; _:more -> decode)"
07:37:26 <Kekker_> I want to pass the result of "parse" into "decode"
07:37:32 <__monty__> glguy: Hmm, I've looked for other data structures but all I could think of is an array. But I'm not sure the extra cost for inserts is worth it. I really feel like not having read Okasaki is a pretty serious disadvantage in AoC.
07:39:28 <lyxia> Kekker_: main = do line1 <- getLine ; let t = toTree line1 ; doStuff t
07:41:35 <glguy> __monty__: just knowing the containers package is enough for AoC, you don't need to read Okasaki
07:42:38 --- mode: glguy set +v aoeu
07:43:53 <Kekker_> lyxia: I can't use do
07:44:11 <Kekker_> it's part of an assignment, not using "do" is one of the constraints
07:45:22 <Kekker_> can I do something like "\s -> case lines s of first:_ -> (fst parse) >>== t; _:more -> decode t"?
07:45:43 <delYsid> main = toTree <$> getLine >>= doStuff
07:45:49 <lyxia> Kekker_: does "not using do" also mean "not using >>="
07:45:56 <Kekker_> no it doesn't
07:46:07 <Kekker_> I'm not allowed to use records, do, or $
07:46:13 <Kekker_> >>== is fair game
07:46:40 <lyxia> ok I see it's a style thing. then I agree with what delYsid wrote.
07:46:54 <__monty__> glguy: Hmm, don't see anything in containers that'd be more suitable than Sequence. I am assuming I need to keep around the full circle because I don't think you can algebraically figure out the value of a marble 7 marbles CCW from the current marble at the time you encounter a marble that's a multiple of 23. (At least I can't figure it out.)
07:47:09 <Kekker_> What does the $ do? I'd have to cut that part out
07:47:28 <rkrishnan> __monty__: yes, I agree. hwormhole also does the same and also attempts to provide command completion of the codes etc.
07:47:29 <delYsid> a b $ c == (a b) c
07:47:54 <Kekker_> man how many of those are there? isn't that basically what . does?
07:48:04 <__monty__> rkrishnan: Do you provide binaries for windows? That's the other main hurdle for non-techies.
07:48:04 <delYsid> no
07:48:12 <delYsid> . is composition, $ is application
07:49:12 <delYsid> forbidding $ isn't that much of an issue, forbidding do can make code verbose and rather hard to read after a while.
07:49:49 <geekosaur> but at the same time, understanding what's going on underneath do is important
07:49:59 <Kekker_> yea I'd be done already if I could use do. The point of forbidding do is to force us to understand the core functional part of haskell, since "do" allows us to write more imperitively
07:50:21 <Kekker_> yea pretty much what geekosaur said
07:50:56 <delYsid> geekosaur: Agreed.  When I began writing haskell, I actually deliberately used >>= a lot over do to make the desugaring stick.
07:51:42 <delYsid> do is just sugar.  Like a nice macro in Lisp :-)
07:51:50 <Kekker_> so would "main = toTree <$> getLine >>= doStuff" just desugar to " main = toTree getLine >>= doStuff"
07:52:10 <tdammers> no
07:52:15 <tdammers> <$> isn't sugar
07:52:32 <tdammers> <$> is a plain old function (that happens to be used as an infix operator here)
07:53:00 <delYsid> You end up having to think more about operator precedence, which is also good.  I still dont really know the operator fixity by heart, guessing feels pretty stupid but that is what it is for now.
07:53:00 <c_wraith> It's also different from $ which is also a library-defined operator
07:53:09 <tdammers> also, do notation isn't inherently imperative, really
07:53:16 <Kekker_> It's an infix for "(a b) c" isn't it? "a b $ c = (a b) c" was said earlier I think
07:53:31 <delYsid> tdammers: We're talking about 'do', not (<$>)
07:53:51 <Kekker_> do isn't inherently imperative, it's just easier to work with for imperative programmers
07:54:00 <tdammers> delYsid: referring to the "would main = toTree <$> getLine >>= doStuff just desugar to..." part
07:54:08 <__monty__> Kekker_: It's `a $ b = a b`, it's just there because of the fixity.
07:54:12 <Solonarv> $ is the infix operator for function application. <$> is a /different/ infix operator.
07:54:37 <Kekker_> so if I'm not allowed to use $, would I technically be allowed to use <$>?
07:54:40 <tdammers> Kekker_: no, I think it's actually harder to reason about for imperative programmers, because naively going with the superficial imperative looks will lead to confusion
07:54:44 * hackage fedora-dists 1.0.0 - Library for Fedora distribution versions  http://hackage.haskell.org/package/fedora-dists-1.0.0 (JensPetersen)
07:55:20 <Kekker_> tdammers: I'd be done already if I could use do, so as an imperative programmer I disagree
07:55:36 <Kekker_> as an imperative programmer who's new to haskell, at least
07:55:48 <delYsid> Kekker_: $ and <$> are not related.  But given your assignment, I am guessing you are not supposed to use operators which you dont understand.  <$> is just an infix version of fmap.  And I used it to avoid the pesky let expression.
07:56:17 <tdammers> > do { x <- ["hello", "goodbye"]; y <- ["world", "sailor"]; return (x ++ ", " ++ y) }
07:56:20 <lambdabot>  ["hello, world","hello, sailor","goodbye, world","goodbye, sailor"]
07:56:52 <rkrishnan> __monty__: not yet. I don't have a windows machine with me. But I could build it on windows (via a friend's machine). Planning to add AppVeyor CI this week and get binaries off it and provide it in the downloads.
07:56:55 <tdammers> imperative me this
07:57:13 <Kekker_> delYsid: Ok that makes sense. And yea I'm not supposed to use code snippets I don't get
07:57:20 <delYsid> There is no such thing as an imperative programmer.  There is just different levels of experience.
07:57:29 <mreh> > [ x ++ ", " ++ y | x <- ["hello", "goodbye"], y <- ["world", "sailor"] ]
07:57:31 <lambdabot>  ["hello, world","hello, sailor","goodbye, world","goodbye, sailor"]
07:58:14 <Kekker_> so would  "main = toTree <$> getLine >>= doStuff" be "main = fmap toTree getLine >>== doStuff"?
07:58:21 <[exa]> no
07:58:23 <tdammers> there is very much such a thing as a programmer who has so far only been exposed to imperative programming, and whose first impulse to solving any programming problem is an imperative approach
07:58:41 <delYsid> Kekker_: Minus the typo, yes, it is >>= and not >>==
07:58:45 <[exa]> Kekker_: oh yes, I missed the fmap
07:58:48 <[exa]> sorry :]
07:59:10 <Kekker_> [exa] it's alright, you just scared me for a second cuz what I wrote actually made sense in my head lol
07:59:24 <Kekker_> delYsid: oh ok thanks, idk why I kept writing ==
08:00:02 <realtechnerd> yo
08:00:12 <benzrf> yo
08:00:15 <benzrf> lol
08:00:27 <delYsid> tdammers: Maybe I am out of common sense here, but I feel for me, the difference between functional and imperative these days boils down to immutable vs. mutable.  But maybe I lost sight haha
08:01:04 <tdammers> delYsid: maybe so, but that still has far reaching consequences for your programming style
08:01:04 <delYsid> When I use a Ref, things start to feel "imperative".
08:01:23 <Kekker_> I understand where you're coming from, but I'd say good imperative programming has a distinct focus on immutability
08:02:04 <delYsid> they're moving towards immutability because parallelism is breaking their necks...
08:02:19 <Kekker_> nothing should be mutable unless it's meant to be mutated, which after programming in Rust I've realized is more rare than most would expect
08:02:33 <tdammers> etymologically speaking, "imperative" isn't so much about mutability as it is about using "commands" as the principal building blocks for programs
08:02:45 <tdammers> imperative = "a program is a sequence of commands"
08:02:51 <tdammers> functional = "a program is an expression"
08:03:06 <Kekker_> I'd agree with that
08:03:42 <tdammers> but of course commands are inherently effectful - they "do something", and that action somehow manipulates the environment it happens in
08:03:57 <delYsid> tdammers: So why does using >>= feel so very much more functional to me then 'do'?  They are the same.  The second only *looks* like it is using "commands".
08:04:07 <tdammers> right
08:04:20 <tdammers> that's probably because many monadic types model some sort of sequentiality
08:04:40 <tdammers> and their primitives represent something that can be seen as an imperative command, if you squint a little
08:05:25 <tdammers> (it's for a reason that we sometimes speak of "monadic actions")
08:05:28 <tdammers> the >>= notation highlights the fact that we are building more complex actions out of simpler ones
08:05:34 <dminuoso> delYsid: It's rather imperative vs declarative, not as much about functional - though functional is a type of declarative programming.
08:06:22 <delYsid> dminuoso: I always felt like declarative is a bit of a buzzword, borders being a bit fluid.  But I get your point.
08:06:42 <tdammers> "declarative" isn't a boolean, there's a bit of a spectrum there
08:06:50 <delYsid> I can write declarative code in a "impterative" language, lets just design a nice DSL with C++ templates :-)
08:06:54 <tdammers> plus of course it's in the eye of the beholder at least a bit
08:07:19 <dminuoso> delYsid: Sure, just like you can write imperative-style code in a declarative language like Haskell.
08:07:25 <tdammers> I mean, you can say that C is declarative, because the syntax declaratively defines an imperative program
08:07:46 <tdammers> (see also the "C is a pure functional language" argument)
08:08:11 <dminuoso> By the way!
08:08:12 <Kekker_> hm I'm getting "Illegal type signature: `IO() main`" with the "main = (unlines . (fmap parse getLine >>= doStuff))"
08:08:13 <dminuoso> delYsid | [15:55:26] Kekker_: $ and <$> are not related.
08:08:28 <dminuoso> delYsid: ^- they are very much related. The choice of using a $ inside <$> is not a coincidence.
08:08:50 <delYsid> Anyway, me not having a lot of theoretical CS background, after almost 27 years of programming, I still feel the major difference is about mutability.  The rest is clever patterns or knowing type classes... Bah, I am rambling, sorry.
08:09:01 <__monty__> Hmm, running `ghc file.hs` is not producing a binary, only a .hi and a .o. What am I doing wrong?
08:09:09 <tdammers> Kekker_: that's because it's Haskell, not C. In Haskell, it's Term :: Type, not Type Term
08:09:21 <Kekker_> __monty__: ghc --make file.hs
08:09:34 <delYsid> dminuoso: Yes, I know.  But for the purpose of that answer, I didnt want to add to the confusion.
08:09:36 <monochrom> https://www.vex.net/~trebla/humour/tautologies.html #0
08:09:59 <__monty__> Kekker_: No difference.
08:10:04 <dminuoso> delYsid: Fair enough. :)
08:10:05 <Kekker_> tdammers: I've written it as "main :: IO()" though
08:10:24 <Kekker_> "main :: IO()"\n"main = interact (unlines . (fmap parse getLine >>= decode))"
08:10:27 <__monty__> I'm pretty sure `ghc file.hs` used to produce binaries fwiw. Maybe I'm going crazy though.
08:10:30 <monochrom> I think you forgot an "interact".
08:10:44 <dminuoso> Kekker_: The space between `IO` and `()` is not optional.
08:10:56 <monochrom> Oh nevermind, you're doing getLine now.
08:11:34 <geekosaur> Kekker_, --make has been defautl since ghc7
08:11:38 <Kekker_> dminuoso: that's really weird, it was compiling fine before without the space. Thanks though, that worked
08:11:53 <delYsid> Nice to see that this channel is still alive.  I am seeing other communities going off to Slack, which is pretty bigtime sad.
08:12:26 <delYsid> In particular, #PureScript is pretty silent these days.
08:12:30 <__monty__> delYsid: There have been slacks for haskell forever. Irc rulez though.
08:12:52 <geekosaur> __monty__, I would expect an error message about not being able to find Main.main during a link step, leaving the objects from the compile behind. or your'e using -c 
08:12:57 <monochrom> Existence does not imply or even cause significance.
08:13:01 <delYsid> __monty__: Yeah, IRC is *the* thing.
08:13:38 <Kekker_> I really wish irc had more functionality. It's simple to a fault
08:14:09 <Kekker_> something as simple as writing code blocks would be SO nice, since IRC is used for so much technical discussion
08:14:17 <delYsid> I never needed more then IRC when it came to chat.  Works for me since 1996.
08:14:38 <__monty__> geekosaur: I get [1 of 1] Compiling file      ( file.hs, file.o ) And it produces the .o and the .hi but no errors and no `file`.
08:15:19 <michalrus> lyxia: Solonarv: thanks! (For `Nat`)
08:15:22 <dminuoso> Kekker_: Pretty sure it was not. Perhaps you forgot to save the file?
08:15:22 <dminuoso> Okay wow. I did not expect that, it's valid.
08:15:51 <geekosaur> I was wodnering, space should not matter there
08:15:59 <Kekker_> I've been compiling with IO() for days at this point
08:16:10 <Kekker_> I don't get that error after including the space though
08:16:20 <geekosaur> it tends to mislead peoel used to other lan guages, but as far as the compiler is concerned it's fine
08:16:53 <Kekker_> oh, uh I just deleted the space again and apparently I don't get it with the space either. I guess the compiler just freaked out on me or somethin
08:17:10 <monochrom> Or the file system freaked out on you.
08:17:19 <Kekker_> possibly. Windows, man
08:17:27 <monochrom> Or cosmic ray.
08:17:34 <Kekker_> That too
08:19:27 <Kekker_> hm, the more I look at it the less I'm sure fmap is the right solution to my problem. "decode" takes two arguments, the tree and a string. when I use >>=, I'm only passing the tree that I built in the first line, but not any of the later lines
08:20:36 <__monty__> Anyone who can spot an obvious space leak in my code for AoC day 9 part 2? http://ix.io/1vIu I don't know where to look for problems and I can't compile with -prof because of another issue : /
08:21:09 <sm> Kekker_: tried matrix ? I think it's a nice next step from irc
08:21:55 <Kekker_> sm: I've tried matrix, but riot is a piece of crap. I like the protocol, they just need a much better implementation to show it off
08:24:07 <sm> I think it works well enough, and is improving
08:26:02 <Kekker_> I haven't used it since summer, so maybe it's improved. When I used it, the UI was extremely cluttered and confusing, and on mobile it's very slow
08:27:44 <Kekker_> can I use "let" in a case statement?
08:29:06 <geekosaur> expression (for both), which for klet means let {bindings} in {expression}
08:31:47 <Kekker_> "main = interact (fmap parse getLine >>= decode)" is really close to working, but isn't 100%. "main = interact (\s -> case lines s of first:_ -> parse ; _:more -> decode)" is also missing one piece.
08:32:45 <Kekker_> I have "parse :: [Char] -> Tree" and "decode :: (Tree -> [Char]) -> [Char]". The fmap one gets me the Tree argument for decode, but not the [Char]. The lambda one gets me the [Char], but not Tree
08:33:09 <lavalike> :t interact
08:33:11 <lambdabot> (String -> String) -> IO ()
08:34:25 <Kekker_> I just need some way to pass "_:more" AND the "fmap parse getLine" into "decode"
08:35:19 <lavalike> surprising you need to use lines inside interact, maybe I'm remembering wrong, but I thought the String you get is a line
08:35:28 <lavalike> guess not!
08:36:12 <Kekker_> lines gives you a list of strings, delimited by newlines
08:36:17 <lavalike> @src interact
08:36:17 <lambdabot> interact f = do s <- getContents; putStr (f s)
08:36:20 <tdammers> Kekker_: if you need more than IRC has to offer, then maybe use some pastebin? or gists, or whatever?
08:36:22 <Kekker_> similar to how words separates by space
08:36:49 <Kekker_> tdammers: yea that's true
08:36:56 <lavalike> Kekker_: is that really the type of decode?
08:37:09 <Kekker_> I just realized what might work, I'll get back to you with code if I need more help
08:37:33 <Kekker_> lavalike: decode is a function I wrote, so yes I wrote it to have that type
08:37:54 <lavalike> Kekker_: you said "decode takes two arguments" and then "decode :: (...) -> [Char]"
08:38:06 <sm> irc can be improved by sufficiently smart bots, too
08:41:17 <Kekker_> lavalike: decode takes a Tree and a [Char]. I wrote "decode :: (Tree -> [Char]) -> [Char]". The parens are there to emphasize which are the args
08:41:48 <lavalike> Kekker_: the funny bit is that (->) associates to the right haha!
08:42:06 <lavalike> decode :: Tree -> String -> String *is* Tree -> (String -> String)
08:43:44 <Kekker_> if I call decode myTree myString, "myTree" and "myString" get passed into decode, and decode then returns a string
08:45:33 <Kekker_> am I completely wrong on that?
08:46:44 * hackage fedora-dists 1.0.0.1 - Library for Fedora distribution versions  http://hackage.haskell.org/package/fedora-dists-1.0.0.1 (JensPetersen)
08:47:24 <geekosaur> 'decode :: (Tree -> [Char]) -> [Char] ' means decode takes a function from Tree to [Char]. compare the type of ' map '
08:48:19 <geekosaur> or of 'interact' for that matter
08:53:48 <c_wraith> that type doesn't look very useful. it's basically the same as Either Tree [Char]
08:54:46 <c_wraith> I guess it's not identical to that, as it could apply the function then process the result.
08:55:11 <c_wraith> but in any case, it's a weird way to divide responsibilities.
08:55:18 <Kekker_> ugh this is getting so frustrating
08:55:44 <delYsid> Kekker_: I missed the actual assignment, care to share?
08:56:02 <Kekker_> https://cs.fit.edu/~ryan/cse4250/projects/tree/decode.html
08:56:59 <Kekker_> I have the binary tree built already, I just need a way to read it. I've felt like I'm minutes from being done for a day now
08:57:24 <Kekker_> I'll send what I have in a minute
09:02:53 <Kekker_> https://pastebin.com/cKj7seaD
09:03:01 <Kekker_> that's my current code
09:05:47 <Akii> Is it possible to have a servant app running that has some in-memory state and not use IORefs for that? Or TVars for that matter, since they also rely on IORefs afaik. I read that IORefs are pretty slow and all I really have is some ongoing state update
09:06:02 <Akii> probably not since I cannot possibly see how that would work
09:08:22 <Kekker_> I'm gonna go to lunch, I'll be back in about an hour. I'll resend the links when I get back
09:11:08 <sm> heap-profiling yesterday's AoC, I'm getting the feeling this list construction is building up thunks (not much of a spoiler): https://hastebin.com/wilonedimu.cpp . I could use a more efficient type, but I'd like to know how you would force that to be more strict ? I have tried a few things that had no effect
09:11:16 <c_wraith> Akii, IORefs being "slow" is a matter of perspective. or in some cases, a matter of thundering herd atomicModifyIORef use
09:12:46 <c_wraith> sm, I basically give up if I have strictness issues when doing [] manipulation. and by "give up" I mean "switch to a different data structure"
09:12:53 <sm> such as printing (tracing) the length of the list..
09:13:35 <sm> I haven't tried using an ADT and marking the field strict
09:14:31 <c_wraith> sm, are you willing pay the O(n) price for that approach on every insert?
09:14:59 <lyxia> sm: forceSpine (as ++ [n] ++ bs) where forceSpine = foldr seq ()    but at that point you might as well not use lists for random access.
09:15:23 <sm> c_wraith: for showing the length ? sure, not for production but I'm more interested in learning how to force and troubleshoot
09:15:52 <sm> ie I want to test my ideas and see if the heap profile changes
09:15:58 <c_wraith> sm, then cleverly apply something like what lyxia provided.
09:16:06 * sm will try that in a sec - thanks
09:16:09 <c_wraith> you'll need another seq
09:17:29 <lyxia> let !x = forceSpine ... in (x,i,n)
09:17:54 <c_wraith> lyxia, should there be a flip on that seq?
09:18:55 <lyxia> ah I see what I missed
09:19:17 <lyxia> let x = ... ; !() = forceSpine x in (x, i, n)
09:20:00 <lyxia> c_wraith: good catch though
09:20:18 <c_wraith> \_ r -> r `seq` ()
09:20:37 <c_wraith> I think that's what the function should be
09:21:00 <lyxia> oh
09:21:14 <lyxia> right foldr seq doesn't just force the spine
09:22:06 <lyxia> :t foldr (const id) ()
09:22:08 <lambdabot> Foldable t => t b -> ()
09:22:26 <c_wraith> ah, that'll work.
09:24:17 <sm> this is hard to follow
09:24:44 <c_wraith> sorry about that.
09:24:52 <sm> for an already-confused person. :) no problem
09:25:03 * sm tries stuff
09:25:26 <sm> if this stuff was easy, we'd all be doing it
09:25:50 <lyxia> basically, forceSpine = foldr (const id) ()   forceAllElementsToWHNF = foldr seq ()
09:27:11 <c_wraith> and don't forget to force the result of that to make sure it does something. and then be sure to share its argument with the return value.
09:27:44 * hackage minimorph 0.2.0.0 - English spelling functions with an emphasis on simplicity.  http://hackage.haskell.org/package/minimorph-0.2.0.0 (MikolajKonarski)
09:27:46 <c_wraith> there are a bunch of subtle steps to get right when taming excessive laziness.
09:27:53 <sm> indeed
09:27:55 <sm> lyxia: those have type [a] -> () or so, how would you use them ?
09:28:10 <c_wraith> and why my approach is "don't use list for situations like this"
09:28:33 <lyxia> forceSpine myList `seq` resultThatUses myList
09:28:54 <sm> before I abandon List, I am determined to make the heap profiler acknowledge my existence!
09:29:06 <lyxia> let !() = forceSpine myList in resultThatUses myList
09:29:13 <sm> my entire haskell career, it just laughs at me
09:29:33 <sm> lyxia: ah, interesting
09:30:03 <sm> very interesting
09:30:04 <c_wraith> sure, you're on a noble quest. but having been there before, it's one I choose to avoid now. :)
09:30:26 <lyxia> Those thunks will actually still be there, just forced earlier.
09:30:49 <c_wraith> they'll be forced when the tuple is.
09:30:56 <c_wraith> which is potentially way earlier.
09:31:09 <c_wraith> but you need to look at how the tuple is being handled.
09:31:46 <__monty__> sm: Still working on part 2 too?
09:33:01 <sm> __monty__: yeah! 
09:33:15 <sm> lyxia: still trying to compile: https://hastebin.com/jewizakivo.pl
09:35:32 <sm> oh I screwed up the type sig didn't I
09:36:01 <sm> that's better
09:38:44 <sm> no improvement
09:39:23 <sm> better in that I got it compiling, but no real change in memory usage
09:40:45 * hackage proteome 0.3.3.0 - neovim project manager  http://hackage.haskell.org/package/proteome-0.3.3.0 (tek)
09:41:34 <glguy> mniip: Could you version bump base on yoctoparsec?
09:42:47 * hackage proteome 0.3.4.0 - neovim project manager  http://hackage.haskell.org/package/proteome-0.3.4.0 (tek)
09:44:17 <amalloy> sm: i would expect CPU time to be a bigger problem than memory usage if you do part 2 with just a list
09:44:53 <amalloy> oh, wait. maybe i'm thinking of a previous day
09:46:07 <glguy> sm: What's this doing? forceSpine = foldr (const id) ()
09:46:07 <mniip> glguy, sure
09:46:29 <__monty__> glguy: Your hint for d9p2, would the new data structure be in containers?
09:47:54 <amalloy> __monty__: the one i used is in containers
09:48:04 <sm> glguy: I'm not sure yet, it's from lyxia & c_wraith 
09:48:21 <mniip> glguy, up to =4.12.0.0?
09:48:27 <glguy> Oh, I see, it replaces the [] with a () and goes to find it
09:48:41 <glguy> mniip: That's what I've tested it at
09:49:00 <glguy> __monty__: The faster solution I was thinking of doesn't use containers, no
09:49:20 <__monty__> 6G of allocation for 50x the final marble seems a bit excessive...
09:49:34 <amalloy> btw, who was it that suggested i try regex-applicative? i've used it for a couple simple AoC parsers and it's much nicer than using regexes
09:49:53 <__monty__> I've been using ReadP for AoC.
09:50:05 <glguy> I've been using megaparsec
09:50:15 <sm> amalloy: yeah I think memory is the issue because time profile says 70% GC, allocating 1.5G/s, and -hd heap profile shows all 500M used by (:)
09:50:28 <vaibhavsagar> I've been using attoparsec
09:50:37 <vaibhavsagar> it's great that there are so many options :)
09:50:40 <__monty__> glguy: Would it use no data structure at all? (Just trying to figure out if there's a catch ; )
09:51:05 <amalloy> for non-regular parsing tasks i still use old-fashioned parsec. what's the draw of all the newer variants?
09:51:06 <glguy> I just updated my day 8 solution to use yoctoparsec ^_^
09:51:22 <mniip> glguy, revised
09:51:39 <glguy> amalloy: The changes are mentioned at the bottom : http://hackage.haskell.org/package/megaparsec
09:51:44 <glguy> mniip: thanks !
09:51:54 <c_wraith> sm, how are you handling the return value? if you're doing an irrefutable match (with a let, for instance), it will still be leaking there.
09:52:24 <glguy> yoctoparsec example: https://github.com/glguy/advent2018/blob/master/execs/Day08.hs#L54-L60
09:52:34 <glguy> __monty__: Yeah, used a data structure
09:53:30 <__monty__> amalloy: Only reason I use ReadP is it's in base : )
09:53:52 <mniip> amalloy, yoctoparsec is just a three-line library that shows off a cute idea I came up with
09:54:47 <mniip> the entire library: https://github.com/mniip/yoctoparsec/blob/master/src/Control/Monad/Yoctoparsec.hs
09:54:54 <__monty__> Smallest library on hackage? o.O
09:55:52 <sm> c_wraith: just pushed it.. https://github.com/simonmichael/aoc2018/blob/master/09.hs#L184 is called by https://github.com/simonmichael/aoc2018/blob/master/09.hs#L213, called by https://github.com/simonmichael/aoc2018/blob/master/09.hs#L233, called by https://github.com/simonmichael/aoc2018/blob/master/09.hs#L270
09:56:58 <sm> aside, re parsing, http://hackage.haskell.org/package/scanf is kind of nice for small parsers
09:58:10 <sm> much easier than parsec and the rest; less adhoc than hand-rolled parsers
10:00:49 <c_wraith> I really don't like using th though!
10:01:37 <c_wraith> fortunately, we're getting close to that sort of library working at the type level.
10:01:47 <sm> it has a non-th option
10:02:01 <c_wraith> it probably could be hacked in now, but real ghc support would be nice.
10:02:25 <sm> isn't it a quasi quoter, which some say is less bad than TH ?
10:03:15 <c_wraith> I only object to them on the compile time axis, in which they're equivalent
10:03:23 <sm> I see
10:03:28 <glguy> I'd rather have TH than type-level programming
10:05:38 <c_wraith> glguy, is that because of error reporting?
10:06:37 <glguy> You get to program in the more useful value-level language, it's more debuggable, more access to libraries and of the language
10:09:27 <c_wraith> glguy, 95% of what I want is just being able to use type-level format args for printf and scanf. silly as it sounds, that's a place where the convenience and type safety would be worth the rest.
10:13:12 <c_wraith> sm, I think the problem is at the matching of the result of the place call.
10:13:39 <c_wraith> sm, but it's really hard to track it down with the program structure. too much passing tuples around.
10:14:58 <sm> c_wraith: that helps me get the idea.. thanks
10:16:56 <dmj`> anyone know if brendanhay has been around?
10:18:06 <hololeap> am i missing something about how ApplicativeDo works? http://dpaste.com/0VWXZNF
10:18:18 <sm> c_wraith: using an ADT with strict fields would avoid that kind of tuple laziness, right ?
10:18:36 <sm> s/would/should/
10:18:51 <c_wraith> sm, no, the problem is that you're matching with a let
10:19:26 <c_wraith> sm, pattern matching with a let just creates a thunk for each name that it binds.
10:19:51 <c_wraith> sm, which further defers evaluation
10:20:02 <sm> ack
10:22:05 <sm> well, I realise that there are many sources of thunks in my code, but is it generally true that converting (Int,Int) to data AB{a::!Int,b::!Int} is removing one of those sources ?
10:22:33 <lyxia> hololeap: you have patterns, which cannot be desugared to Applicative notation
10:24:31 <monochrom> Yes sm. But keep in mind "const () (seq AB{a=undefined,b=undefined} ())" is still ()
10:24:46 <hololeap> lyxia: this works: http://dpaste.com/3W8ZG71 ... so there's no way to write that in ApplicativeDo style?
10:25:00 <int-e> . o O ( constant surprise )
10:25:11 <monochrom> My http://www.vex.net/~trebla/haskell/strict-field.xhtml is a pretty good account of this.
10:25:27 <lyxia> hololeap: try ~(_, f') <- ...
10:25:34 <monochrom> Oh int-e did you see my other constant surprise on lexical syntax?  const 2undefined
10:26:12 <lyxia> hololeap: it's still not quite the same strictness
10:26:59 <hololeap> lyxia: do i have to enable an extension for that tilde to be valid syntax?
10:27:06 <geekosaur> no
10:28:02 <hololeap> Parse error in pattern: 'f      Possibly caused by a missing 'do'?
10:28:09 <hololeap> man, i don't get it...
10:28:39 <hololeap> oh duh, nvm
10:28:50 <sm> monochrom: thanks
10:28:53 <hololeap> so why does it work with the tilde but not otherwise?
10:29:33 <geekosaur> tilde makes a pattern lazy/irrefutable instead of default strict (note that let bindings default to lazy though)
10:29:50 <hololeap> that's weird, i thought everything defaulted to lazy
10:29:53 <int-e> monochrom: I didn't
10:30:13 <c_wraith> hololeap, oh, no. it's a lot more subtle than that. :)
10:30:22 <geekosaur> default-strict pattern matching si how anything gets evaluated at all
10:30:38 <hololeap> ah, that makes sense
10:30:39 <hololeap> and what about it being strict causes ApplicativeDo to fail?
10:32:06 <hololeap> i mean, in my second paste i'm pattern matching in `thing` ... so is there some special mechanics that only happen within a do block?
10:32:41 <hololeap> i'm just trying to understand...
10:33:25 <geekosaur> ApplicativeDo is itself something of a fragile abuse
10:34:38 <lyxia> hololeap: if the pattern doesn't match the rest of the block will not be evaluated
10:34:48 <lyxia> you can't do that with just Applicative.
10:35:28 <cocreature> % do (x,y) <- putStrLn "hello" *> pure undefined; z <- putStrLn "world"; pure z
10:35:28 <yahb> cocreature: hello; *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:436:38 in interactive:Ghci138
10:35:51 <cocreature> % liftA2 (\(x,y) z -> z) (putStrLn "hello" *> pure undefined) (putStrLn "world")
10:35:51 <yahb> cocreature: hello; world
10:35:55 <cocreature> here’s a concrete example
10:36:07 <hololeap> oh, ok... but doesn't the whole program fail on a failed pattern match regardless?
10:36:48 <dmwit> That... depends on what you mean by "the whole program".
10:36:56 <dmwit> Any IO that's already been done stays done.
10:37:14 <cocreature> and it depends on what you mean by “fail” :)
10:37:14 <dmwit> So "how much IO has been done before the exception is thrown?" matters, at the very least.
10:37:23 <hololeap> something roughly equivalent to `error`
10:38:04 <dmwit> The ~ is essentially asking the compiler to delay the exception until later.
10:38:10 <dmwit> So more stuff can get "done".
10:39:10 <dmwit> (And it would be awfully impolite for ApplicativeDo to change how much stuff got done by default, don't you think?)
10:39:29 <Solonarv> % evaluate (let !False = True in "oops") `catch` \(_ :: PatternMatchFail) -> putStrLn "swallowed"
10:39:29 <yahb> Solonarv: ; <interactive>:438:76: error:; * Couldn't match type `()' with `[Char]'; Expected type: IO [Char]; Actual type: IO (); * In the expression: putStrLn "swallowed"; In the second argument of `catch', namely `\ (_ :: PatternMatchFail) -> putStrLn "swallowed"'; In the expression: evaluate (let !False = True in "oops") `catch` \ (_ :: PatternMatchFail) -> putStrLn "swallowed"
10:39:52 <Solonarv> % evaluate (let !False = True in putStrLn "oops") `catch` \(_ :: PatternMatchFail) -> putStrLn "swallowed"
10:39:53 <yahb> Solonarv: ; <interactive>:439:85: error:; * Couldn't match type `()' with `IO ()'; Expected type: IO (IO ()); Actual type: IO (); * In the expression: putStrLn "swallowed"; In the second argument of `catch', namely `\ (_ :: PatternMatchFail) -> putStrLn "swallowed"'; In the expression: evaluate (let !False = True in putStrLn "oops") `catch` \ (_ :: PatternMatchFail) -> putStrLn "s
10:40:16 <monochrom> Yes, do-notation pattern-matching is defined in the Haskell Report to be strict and also adds a fall-through case that uses "error".
10:40:40 <Solonarv> % evaluate (let !False = True in ())
10:40:41 <yahb> Solonarv: *** Exception: <interactive>:440:15-27: Non-exhaustive patterns in False
10:40:45 <cocreature> monochrom: it does? I thought the report defined it as using "fail"
10:40:45 <monochrom> However, if you're in IO, you can also catch exceptions, including "error" events.
10:40:46 <dmwit> % evaluate (let !False = True in "oops") `catch` \(_ :: PatternMatchFail) -> putStrLn "swallowed" >> return "not oops"
10:40:47 <yahb> dmwit: swallowed; "not oops"
10:40:57 <Solonarv> % evaluate (let !False = True in ())  `catch` \(_ :: PatternMatchFail) -> putStrLn "swallowed"
10:40:58 <yahb> Solonarv: swallowed
10:41:00 <monochrom> Oh! Oops, "fail" not "error".
10:41:22 <Solonarv> So: you can absolutely catch pattern-match failures
10:41:37 <monochrom> And then IO's fail is error.  And then what I said about catchable exceptions.
10:41:54 <hololeap> would another way of saying it be that strict pattern matching in an Applicative can break the purity that Applicative is supposed to have?
10:42:09 <dmwit> > (fail "foo" :: IO ()) `seq` "not error"
10:42:12 <lambdabot>  "not error"
10:42:44 <cocreature> “purity” seems like the wrong word here. I would use something like “non-dependence”
10:42:45 <sm> c_wraith, lyxia: I guess this is not too interesting but FWIW: I failed at forcing tuples by hand. I changed the top level iterate to iterate', which moved the memory usage peak to the mid point instead of the end point. foldSpine or forceAllElementsToWHNF were pessimisations when using iterate', either one tripled the run time. 
10:42:51 <monochrom> hololeap: I think no. Could you show an example?
10:42:52 <dmwit> `fail` is a specialization of `throwIO`, I think.
10:44:51 <sm> when a -hd (closure description) profile says the memory is used by :, does that rule out lazy tuples being the cause ?
10:47:54 <hololeap> > do ; Just x <- pure Nothing ; pure x ; 
10:47:58 <lambdabot>  error:
10:47:58 <lambdabot>      • Ambiguous type variables ‘m0’, ‘b0’ arising from a use of ‘show_M20826...
10:47:58 <lambdabot>        prevents the constraint ‘(Show (m0 b0))’ from being solved.
10:48:11 <hololeap> % do ; Just x <- pure Nothing ; pure x ; 
10:48:11 <yahb> hololeap: *** Exception: user error (Pattern match failure in do expression at <interactive>:443:6-11)
10:48:20 <hololeap> % (\(Just x) -> x) Nothing
10:48:21 <yahb> hololeap: *** Exception: <interactive>:444:2-15: Non-exhaustive patterns in lambda
10:48:55 <monochrom> Partial functions do not break purity.
10:50:19 <hololeap> doesn't ApplicativeDo desugar the first example into something like this?  (\(Just x) -> x) <*> pure Nothing
10:50:46 <hololeap> (\(Just x) -> x) <$> pure Nothing
10:51:33 <jeromelanteri> what's wrong there ? https://ptpb.pw/OOEU
10:52:20 <monochrom> do {Just x <- pure Nothing ; pure x} = pure Nothing >>= \a -> case a of { Just x -> pure x;  _ -> fail "pattern matching failure" }
10:52:34 <jeromelanteri> i have a text, i'm trying to transform all cgars to upper (try for learn with interact)
10:52:43 <Tuplanolla> You need to map twice, jeromelanteri.
10:53:03 <jeromelanteri> Tuplanolla, hho map strain and chars ?
10:53:09 <jeromelanteri> string
10:53:13 <monochrom> But sorry, I was still doing old-school monadic do notation.
10:53:14 <Tuplanolla> Once to get inside the list and another time to get inside each string.
10:53:22 <hololeap> well, at this point i can just accept "use the tilde when pattern matching with ApplicativeDo, because reasons pertaining to IO, and besides GHC will yell at you if you don't"
10:53:30 <Tuplanolla> You can use `map` for both.
10:53:39 <jeromelanteri> Tuplanolla, let's try this...
10:53:39 <monochrom> Let me take a quick look at ApplicativeDo again.
10:54:22 <cocreature> hololeap: I explicitely gave you an example where it behaves differently
10:54:25 <monochrom> But I have a feeling ApplicativeDo maintains the same strictness as monadic do.
10:54:38 <hololeap> cocreature: sorry, let me re-read... there was a lot going on
10:57:32 <monochrom> hololeap: In the GHC user's guide, go to the section on "Applicative do-notation", and keep reading for the subsubsubsection "Strict patterns".
10:58:04 <hololeap> % liftA2 (\!(x,y) z -> z) (putStrLn "hello" *> pure undefined) (putStrLn "world")
10:58:04 <yahb> hololeap: ; <interactive>:445:19: error: parse error on input `->'
10:58:08 <jeromelanteri> Tuplanolla, this time no compilation error, but .:upperLine test is waiting forever
10:58:47 <monochrom> But tldr: To ensure that ApplicativeDo has the same strictness as monadic do, especially if you do have a monad anyway, when you have a strict pattern it goes back to Monad.
10:59:00 <jeromelanteri> https://ptpb.pw/Yz_p
10:59:24 <monochrom> @type \m -> do{ (x,y) <- m; return () }
10:59:26 <lambdabot> Monad m => m (a, b) -> m ()
10:59:53 <c_wraith> yeah, I guess it does have to do that.
11:00:42 <monochrom> The reason they do this is because they want to preserve this bottom line: Suppose you have code that already works without ApplicativeDo, then turning on ApplicativeDo should change nothing.
11:01:11 <hololeap> monochrom: ok, that's helpful. the first part shows syntax without the tilde and i never read far enought to get to the part about strictness... thanks everyone
11:01:40 <monochrom> (And suppose that for every Monad instance, Monad and Applicative and Functor are consistent with each other.)
11:02:15 <monochrom> Wait, did I accidentally make a pun? "bottom" line eh?  >:)
11:02:25 <jeromelanteri> Tuplanolla, i definitely not understand why it turn like inside an infinit loop
11:03:52 <cocreature> jeromelanteri: that’s not an infinite loop. have you entered some text?
11:04:16 <cocreature> it’s waiting for you to enter input
11:04:53 <monochrom> This is called a Mexican Standoff.
11:05:02 <jeromelanteri> OMG !!!
11:05:17 <monochrom> The computer is also thinking "why is the human in an infinite loop?"
11:05:53 <monochrom> Your computer asked cocreature in another channel. That's how cocreature knows. >:)
11:06:04 <jeromelanteri> monochrom, sure... i forget < char before name of file
11:06:14 <monochrom> Oh!
11:06:22 <jeromelanteri> ok, thank you guys
11:06:46 <monochrom> This is why it's better to treat every troubleshooting question as a lab report.
11:07:03 <monochrom> You ought to carefully enumerate the steps to reproduce your observation.
11:07:17 <vaibhavsagar> hi, I'm trying to statically link an executable with Cabal and getting an error about a missing `libHSbase-compat-0.10.5.so`, has anyone seen this before?
11:07:40 <monochrom> https://www.vex.net/~trebla/humour/tautologies.html #4 is many people's favourite.
11:08:19 * hololeap . o (i was defining my Applicative instance using do-notation, which is apparently also a no-no)
11:08:40 <Tuplanolla> But mind reading is great fun, monochrom.
11:08:50 <monochrom> Yeah that is either circular or incurs a spurrious Monad constraint.
11:08:59 <__monty__> Hmm, what changes when you add a module declaration for runghc? If I include a module declaration I get a stack overflow. Otherwise the program finished in 1:18.
11:09:40 <c_wraith> nothing should change
11:09:47 <c_wraith> that's weird behavior
11:09:48 <monochrom> Tuplanolla: I'm afraid mind reading is insufficient and unnecessary.  Remote desktop access is better.
11:10:23 <nshepperd1> Read the mind of the machine
11:12:20 <nshepperd1> vaibhavsagar: are you on archlinux?
11:12:46 <vaibhavsagar> nshepperd1: no, NixOS
11:12:53 <vaibhavsagar> I got all the dependencies working
11:13:00 <vaibhavsagar> but the final build is eluding me
11:13:56 <nshepperd1> Oh
11:15:08 <bsima> vaibhavsagar: what nix expression are you using to build it?
11:15:36 <vaibhavsagar> bsima: `nix-build -E 'let pkgs = import <nixpkgs> {}; src = builtins.fetchTarball { url = "https://github.com/kadena-io/pact/archive/2742322f96605ba6307eef3b791729fb3b6862d9.tar.gz"; sha256 = "18qihgpib44ak1ffl69yrngwi2g1iv75szbz55jp7kzb6xqq2gvx";}; in pkgs.callPackage (import "${src}/static.nix") {}'`
11:16:03 <vaibhavsagar> it's for work, but all the code is public
11:24:20 <__monty__> c_wraith: I *am* using a nix-shell shebang, it sets up a nix-shell with a ghcWithPackages with the packages you need but then it just call runghc yourfile.hs afaik.
11:26:50 * hackage extra 1.6.14 - Extra functions I use.  http://hackage.haskell.org/package/extra-1.6.14 (NeilMitchell)
11:26:55 <c_wraith> __monty__, is it possible it's passing a main-is argument to runghc?
11:27:36 <c_wraith> or that nix is blowing up because it's trying to find Main?
11:27:37 <__monty__> c_wraith: I'll have to ask in #nixos.
11:31:23 <__monty__> c_wraith: I don't think so though. Because then it shouldn't work ever. But it usually works. It's not working for a ~heavy computation.
11:44:47 <hololeap> how is this instance implemented (i can't find the source)?  MonadReader r m => MonadReader r (StateT s m)
11:45:19 <prohobo> this language is hard wtf
11:47:12 <yushyin> and fun!
11:47:14 <tdammers> hololeap: type "MonadReader" into hayoo. Find something like this: http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader. Clicking "# source" next to the relevant instance leads you here: http://hackage.haskell.org/package/mtl-2.2.2/docs/src/Control.Monad.Reader.Class.html#line-166
11:48:32 <Solonarv> minor pedantry: the '#' is a link to that location in the haddocks, the 'source' part is the link to the source
11:49:01 <hololeap> tdammers: thanks
11:49:41 <hololeap> (it needs UndecidableInstances)
11:51:49 <geekosaur> the coverage condition is stricter than it "needs to be", because ensuring termination is Hard. so there are cases where typechecking is known to terminate, but you can't prove it to the compiler
11:52:11 <geekosaur> this is more or less why UndecidableInstances exists
11:56:32 * hololeap . o O {-# LANGUAGE UnknowableConjuration #-}
11:58:14 <Solonarv> There's a proposal around to make the decidability checker a bit smarter, but I'm not sure what state it's in
12:15:34 <lyxia> DecidableInstances <3
12:16:32 <lyxia> https://github.com/ghc-proposals/ghc-proposals/pull/114
12:38:47 * hackage xmobar 0.29.3 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.29.3 (JoseAntonioOrtegaRuiz)
12:55:46 <xsperry> d
12:56:04 <xsperry> hi. is 9961491.exe file created in windows temp directory related to ghc?
12:56:22 <xsperry> name appears random, but it is always the same
12:58:51 <xsperry> file is reported as suspicious by windows defender. and it seems to be created when I try to compile projects that use FFI
13:00:25 <hololeap> i'm surprised there isn't a function like :: Functor m => (m a -> m b) -> StateT s m a -> StateT s m b
13:01:37 <lyxia> I don't think that's possible to implement without losing the state
13:02:59 <hololeap> i wrote one, but it's ugly: http://dpaste.com/29G35QQ
13:05:56 <lyxia> it loses the state
13:06:32 <hololeap> yeah, you're right
13:10:21 <Solonarv> I think there's a class somewhere for "'f' such that a well-behaved '(f a -> f b) -> f (x, a) -> f (x, b)' exists"
13:10:31 <Solonarv> You'd want that instead of Functor
13:10:41 <Solonarv> I can't remember what it's called, though
13:11:41 <glguy> xsperry: hsc2hs works by creating an executable and generating a Haskell source file
13:12:03 <hololeap> i was trying to implement `listen` for StateT (just as an exercise)... now i see that they have a specific `liftListen` function for each transformer
13:13:56 <xsperry> glguy, I see
13:18:43 <hololeap> i notice that ReaderT and IdentityT don't need `liftListen`. what's the math-y explaination for this?
13:19:10 <hololeap> something to do with representable functors?
13:19:37 <monochrom> They are instances of MonadReader too.
13:20:05 <monochrom> If you mean "they just need 'listen'"
13:20:26 <monochrom> Wait, is "listen" a method of MonadReader? MonadWriter?
13:20:33 <hololeap> MonadWriter
13:20:56 <monochrom> OK yeah then correction: They're instances of MonadWriter too.
13:21:44 <hololeap> listen and pass seem to twist up most monad transformers where there isn't a general way of implementing all of them. ReaderT and IdentityT seem to be immune, though, since they just use mapReaderT and mapIdentityT, respectively
13:22:26 <hololeap> the others need a specific implementation for those two functions
13:24:01 <monochrom> ReaderT and IdentityT are pretty non-intrusive so yeah.
13:24:39 <hololeap> it reminds me of UnliftIO, which can only be implemented with ReaderT or IdentityT on top of IO... is it because they are both Distributive, i wonder...
13:25:09 <monochrom> IdentityT m a = m a; ReaderT x m a = x -> m a.  So basically you're transforming m a to m a again with little or no change.
13:25:46 <monochrom> Wherease for example StateT s m a = s -> m (s, a), in other words transforming m a to s -> m (s, a), that's a big surgery.
13:28:33 <hololeap> yeah, StateT has `s` on both the lhs and rhs, so that may have a lot to do with it
13:28:57 <dmwit> There is mapStateT.
13:29:27 <dmwit> (For your "I'm surprised there isn't a function like ..." question.)
13:29:45 <hololeap> dmwit: oh, thanks. that's pretty close
13:31:09 <monochrom> @type mapStateT
13:31:11 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
13:31:20 <dmwit> What is `liftListen`? I don't see it in the docs.
13:31:33 <monochrom> @type liftListen
13:31:34 <lambdabot> error: Variable not in scope: liftListen
13:31:39 <hololeap> https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Maybe.html#v:liftListen
13:31:45 <monochrom> % @type liftListen
13:31:46 <yahb> monochrom: ; <interactive>:451:1: error: parse error on input `@'
13:31:52 <hololeap> https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-State-Lazy.html#v:liftListen
13:31:54 <monochrom> oops
13:31:58 <monochrom> % :type liftListen
13:31:58 <yahb> monochrom: forall {m :: Type -> Type} {w} {a}. Monad m => Control.Monad.Signatures.Listen w m (Maybe a) -> Control.Monad.Signatures.Listen w (MaybeT m) a
13:32:14 <monochrom> Oh nevermind
13:33:03 <dmwit> Claim: MaybeT and StateT also don't need liftListen.
13:33:13 <monochrom> Oh double nevermind, yahb's answer is consistent with that one.
13:33:30 <dmwit> (Or, perhaps: ReaderT and IdentityT *do* need liftListen. Depends what you mean by "need".)
13:36:42 <hololeap> dmwit: my point is that StateT and MaybeT need different implementations for `listen` and `pass`, whereas ReaderT and IdentityT can get away with `mapReaderT` `...` for both of those functions 
13:36:46 <hololeap> http://hackage.haskell.org/package/mtl-2.2.2/docs/src/Control.Monad.Writer.Class.html#line-123
13:36:48 <monochrom> I think the plan is that in transformers for every FooT they write down a liftListen (for example; where applicable), so that in mtl when you finally write "instance MonadWriter m => MonadWriter (FooT m)" you just have to use liftListen.
13:37:30 <hololeap> and i feel like there has to be a mathematical reason for ReaderT and IdenityT's "specialness"
13:37:31 <dmwit> hololeap: It is premature optimization. Imagine in your head that they have written `liftListen = mapIdentityT; liftPass = mapIdentityT` and then inlined those definitions in mtl.
13:37:49 <monochrom> FooT's liftListen may be trivial or non-trivial depending on FooT but at least all the important logic is already there.
13:38:45 <dmwit> hololeap: (They could do the same for MaybeT if they wanted, by inlining the definition of State.liftListen, and then not defining liftListen. There is nothing deep theoretically going on there; it barely transcends above the syntactic.)
13:41:59 <dmwit> Whoops, mixed up MaybeT and StateT there. But you get the idea.
13:45:55 <hololeap> % :type mapReaderT
13:45:55 <yahb> hololeap: forall {k2} {k1} {m :: k2 -> Type} {a :: k2} {n :: k1 -> Type} {b :: k1} {r}. (m a -> n b) -> ReaderT r m a -> ReaderT r n b
13:46:05 <hololeap> :t mapReaderT
13:46:07 <lambdabot> forall k2 k1 (m :: k2 -> *) (a :: k2) (n :: k1 -> *) (b :: k1) r. (m a -> n b) -> ReaderT r m a -> ReaderT r n b
13:47:08 <systemfault> Hmm, what's that weird syntax yahb is using?
13:47:53 <MarcelineVQ> explicit foralls and polykinds
13:48:35 <systemfault> Ugh... rabbit hole, I'll get there eventually.
13:48:40 <MarcelineVQ> :set -fprint-explicit-foralls -XPolyKinds  in ghci to try them yourself
13:48:52 <systemfault> Thank you :)
13:48:59 <w1n5t0n> hi all, I have a [(String, String)] that are to be interpreted as pairs of (src, dest). I want to sort it such that, for every pair, a 'src' string never appears after it's 'dest'. Any tips on how to go about it?
13:49:37 <w1n5t0n> the output would be a [String] if that wasn't clear
13:49:54 <hololeap> dmwit: well, all i can say is that mapReaderT and mapIdentityT have much simpler type signatures compared to the mapXT functions for the other transformers, so i do think there is something deeper going on
13:51:18 <glguy> w1n5t0n: Which day was that one?
13:52:14 <w1n5t0n> glguy: what do you mean by day?
13:52:40 <glguy> That question comes up in one of the advent of code puzzles this year
13:54:27 <w1n5t0n> glguy: oh haha I didn't even know, it's for a project I'm currently working on!
13:55:15 <glguy> OK, then you can read about https://en.wikipedia.org/wiki/Topological_sorting
13:55:56 <hololeap> w1n5t0n: what do you mean by 'src' never appears after its 'dest'?
13:55:56 --- mode: glguy set +v mreh
13:57:06 <dmwit> hololeap: "something deeper": Hm, well. If you're observing that IdentityT is not a very complicated transformer, then, sure. =)
13:58:45 * hackage exact-pi 0.5.0.0 - Exact rational multiples of pi (and integer powers of pi)  http://hackage.haskell.org/package/exact-pi-0.5.0.0 (Bodigrim)
13:58:56 <hololeap> dmwit: i guess a better question would be, "what criteria does a monad transformer have to meet so that you can write a well behaved function with the type :: (m a -> n b) -> t m a -> t n b"
13:59:15 <dmwit> Yeesh, the kinds on mapReaderT. I wonder if anybody has a use for having a different kind than * on b. =P
13:59:16 <w1n5t0n> hololeap: I mean that if any string appears as the first element of one or more pairs, then those strings that it pairs with will appear after it in the sorted list, never before
13:59:59 <Kekker_> I'm back again with more questions about haskell. I had to take an extended lunch cuz I was not in a good mood
14:00:06 <w1n5t0n> glguy: thanks, that's exactly what I was looking for!
14:00:11 <Kekker_> so, I have this homework: https://cs.fit.edu/~ryan/cse4250/projects/tree/decode.html
14:00:22 <Kekker_> and I've written this code: https://pastebin.com/cKj7seaD
14:01:07 <Kekker_> I need to get the decode function to work for every line of code after the first. It has to take a line of input and iterate over the tree I've built to "decode" a word
14:01:19 <dmwit> hololeap: Right. And I guess we could define "well behaved" by saying "if the first argument is a monad morphism, then the output is, too" or similar.
14:01:33 <dmwit> It's an interesting question, I guess.
14:02:28 <hololeap> at least i finally phrased it well. i'll think on it
14:03:14 <dmwit> Kekker_: Perhaps you'd prefer `fmap (fst.parse) getLine`.
14:04:02 <Kekker_> Maybe. I can figure that out later, what I really need right now is the decode function
14:04:04 <dmwit> Kekker_: I don't think you're going to get a lot of takers on "implement decode for me", if that's your question.
14:04:42 <dmwit> Besides the fact that it doesn't seem like it would help you learn Haskell (a goal for most people in here!) it's completely unethical.
14:04:51 <Kekker_> I'm not asking for a code snippet, I'm asking for help. I've been here on and off all day today and yesterday trying to get this to work
14:05:11 <dmwit> Okay. Do you have a more focused question, then?
14:05:14 <hexagoxel> w1n5t0n: fgl has topsort. not sure if it is a worthwhile dependency for you.
14:05:16 <zachk> Kekker_, aeson decode?
14:05:39 <hololeap> Kekker_: for `parse`, why do you have `| c <= '*'` ?
14:06:09 <Kekker_> I check to see if the character is a * because that's what signals a node on the tree
14:06:33 <glguy> zachk: No, aeson doesn't feature in the solution to this problem
14:06:34 <hololeap> shouldn't it be `c == '*'` then?
14:07:18 <Kekker_> probably. I thought <= was like the <- syntax, not an equality operator
14:07:30 <sm> ok, after failing to improve List-based performance at all, I did switch to Sequence and got a 500-1000x memory & time improvement (c_wraith/glguy++)
14:07:35 <Kekker_> the tutorial I've been using didn't explain that very well
14:08:32 <Kekker_> so, a more focused question: how can I get the decode function to iterate over a recursive tree if I don't have pointers to each branch?
14:08:56 <dmwit> Are you familiar with pattern matching?
14:09:13 <c_wraith> sm, yeah, lists are just not good for that problem.
14:09:33 <Kekker_> I am definitely familiar with pattern matching
14:10:01 <Kekker_> That's how I was able to write the Tree in the first place, it's very Rust-like to me
14:10:39 <hololeap> Kekker_: you can rewrite Tree to be:  data Tree a = Leaf a | Branch (Tree a) (Tree a)
14:10:48 <hololeap> and then you can write a Foldable instance for it
14:10:57 <dmwit> Okay. Well, if you're given a tree, and pattern match on it, you will get "pointers" to the tree's branches as the result of one of the matches.
14:11:34 <dmwit> hololeap: That... seems like putting the cart before the horse.
14:12:12 <hololeap> well, decode looks an awful lot like Data.Foldable.toList
14:12:26 <Kekker_> hololeap: I'm not sure how folding works, I'll read up on that. 
14:12:47 <Kekker_> dmwit: What am I supposed to be pattern matching though? Am I matching whether it's a leaf or a branch?
14:12:58 <hololeap> sorry, i might be getting too far ahead
14:13:05 <dmwit> hololeap: Sure. But writing a Foldable instance is no easier than writing decode in the first place.
14:13:21 <dmwit> You still need all the same mental tools to accomplish that task.
14:13:27 <dmwit> Kekker_: Yes, exactly.
14:13:40 * hololeap . o O ({-# LANGUAGE DeriveFoldable #-})
14:13:48 <hololeap> lol
14:13:52 <Kekker_> Ok. How would I be able to extract the actual letter from the leaf? Is that done with <-
14:14:11 <dmwit> Kekker_: What do you think the pattern would look like for matching a leaf?
14:17:28 <dmwit> I mean, if you don't know, that's fine. We can point you at tutorials that describe the syntax for pattern matching.
14:17:53 <dmwit> I'm assuming you know a bit, since you say you're very familiar with pattern matching, but perhaps you didn't realize that was jargon with a specialized meaning in Haskell.
14:18:19 <Kekker_> I'm trying to get something written down, but I don't really know how the rest of the match would work
14:19:00 <sm> c_wraith: that problem and a rule of thumb for picking Sequence being: "lots of random access inserts", would you say ?
14:19:13 <sm> inserts/modifications
14:19:14 <dmwit> Kekker_: Okay. That's a little bit worrying, because what I have in mind is less than a dozen characters long. So I suspect we have miscommunicated somewhere.
14:19:19 <Kekker_> I started with "decode t | l == Leaf a where l == something" but the more I tried to write into that the more it seemed weird
14:20:35 <Kekker_> I guess I know less about pattern matching than I thought I did
14:20:48 <c_wraith> sm, I mostly go to Data.Sequence for the case when I want add/remove access to both ends. I wrote my solution to that problem using a policy of "the selected item is always the start of the sequence" and did all the moving around the circle by moving elements from one end to the other.
14:20:59 <Kekker_> which has pretty much been my experience with Haskell today in general. I know less about a lot of things than I thought I did
14:21:20 <Kekker_> the more I read and the more questions I ask, the less I understand
14:21:20 <dmwit> Kekker_: I recommend http://www.cis.upenn.edu/~cis194/spring13/lectures/02-ADTs.html
14:21:39 <dmwit> It seems to be a pretty succinct description of the basics of pattern matching.
14:21:41 <sm> c_wraith: interesting
14:21:44 <c_wraith> sm, ie, I have memorized O(1) amortized read/add/remove from the ends.
14:22:01 <sm> I'm glad to know about Sequence, I never see it discussed
14:22:17 <c_wraith> sm, so.. when that's the performance I want and a simpler structure doesn't do, that's what I take.
14:22:19 <glguy> sm: Did you look at my Sequence solution now that you're done with yours?
14:22:34 <Kekker_> dmwit: So basically it's "decode t | t Leaf --code ; | otherwise --code"?
14:22:36 <sm> glguy: no, I'll do that now
14:22:38 <MarcelineVQ> sequence and zippers seemed to be the methods there. I mean it's plainly a cyclic zipper jus visually, but both fit well
14:22:48 <sm> and thanks for mentioning it
14:22:51 <sm> yesterday
14:22:51 <Kekker_> or rather "... _ --code"
14:23:04 <dmwit> Kekker_: I don't believe you read that whole page in two minutes. =)
14:23:13 <joe9> any openbsd users here? How do you install stack? from source or is there a package?
14:23:54 <Levy[m]> iirc manually
14:24:06 <__monty__> glguy: I just shaved 20s off my time for d9p2 by replacing x `mod` 23 == 0 by x == 23 o.O
14:24:08 <Kekker_> dmwit: I didn't lol, but the examples right in front made sense. The data type held a few different types, like an enum, so the pattern match just matched the type you write next to the argument
14:24:27 <dmwit> Kekker_: Read, and learn.
14:24:36 <Kekker_> am I... wrong?
14:25:14 <dmwit> Kekker_: Read, and find out whether you are wrong!
14:25:22 <hololeap> Kekker_: maybe this will help get you started: https://pastebin.com/rCCTTJqk
14:25:42 <Kekker_> Yea I thought that's what I wrote already
14:25:52 <Kekker_> oh no I wrote with pipes nvm
14:27:07 <Kekker_> So I'm right, then. It's just matching enums
14:27:16 <Kekker_> I just wrote the syntax wrong
14:27:21 <hololeap> Kekker_: sorry, you need parens around the pattern match: https://pastebin.com/wASxshvS
14:27:44 <MarcelineVQ> __monty__: are you using Int, and/or compiling with optimization?
14:27:58 <Kekker_> hololeap: yea I see that further in the link that dmwit sent
14:28:03 <Kekker_> I added them in already
14:28:20 <__monty__> MarcelineVQ: I'm using Int but I'm interpreting.
14:28:52 <Levy[m]> Kekker_: Using C terminology will limit you the further you go with Haskell
14:29:09 <dmwit> (It's Rust terminology, I think. And in that context, it's fine and basically right.)
14:29:12 <Kekker_> I'm not using C terminology?
14:29:18 <Levy[m]> ah
14:29:24 <Levy[m]> still odd
14:29:27 <Kekker_> Yea it's Rust, enums work different in Rust. They're more haskell-y
14:29:50 <Kekker_> I've been talking with some Rust guys I know as well, and it's remarkable how much Haskell has influenced Rust
14:29:56 <__monty__> Except haskell *has* a different concept of Enum.
14:29:58 <Levy[m]> which brings up the question of why rust calls them that
14:30:02 <MarcelineVQ> __monty__: compiling with -01 or 2 might help even the odds when you have performance oddities. I've heard rem is faster than mod as well, dunno if that's the case
14:30:54 <Kekker_> Rust Enums are like a subset of Haskell data. I can pattern match data in the same way I can pattern match rust enums
14:31:51 <cjay->  
14:32:28 <Kekker_> I can see where I'm going with this. Now I just need to figure out how I get the input string into decode
14:32:35 <Kekker_> I'll try some things and come back if I can't figure it out
14:34:11 <crysikrend> Hey everyone, I've been recently trying to learn about websockets in haskell. I don't know much about networking so I figured I'd learn it in my preferred language. I am going with servant as it has a lot of stuff I can use. The end goal is to stream data through a websocket, which is already quite a big task for me. I've done some learning into Conduit and done some tutorials, and now i am unsure what to do
14:34:12 <crysikrend> next, whether I try to use conduits with servant, or learn about WAI apps next? I can't find a blog or tutorial that illustrates all these moving parts in an easy to digest way.. sorry if those were some dumb questions
14:35:18 <zachk> there is a websocket WAI middleware somewhere crysikrend , I used it with scotty once to good affect, I am guessing servant uses warp as well , though
14:35:29 <crysikrend> yeah it does
14:35:35 <crysikrend> which I also need to learn about :(
14:36:04 <crysikrend> I know servant uses warp to serve a WAI application, which is somehow going to supply a Source conduit thing?
14:41:00 <zachk> crysikrend, here is a webserver using websockets and scotty to tunnel telnet connections over the web: https://paste.pound-python.org/show/JCVaPdw506hmzL0SjPai/
14:42:43 <crysikrend> okay, a lot to read
14:43:25 <crysikrend> what's the difference between Network.Websockets and Wai.Handler.Websockets ?
14:44:26 <jackdk> so that's just blindly shoving data between the websocket and the telnet server's socket? So if the telnet server tries to do IAC sequences, they'll appear on the websocket?
14:44:50 <jackdk> or is crysikrend's usecase implementing IAC handling within whatever's opening the websocket?
14:45:04 <crysikrend> I don't know what IAC is :( 
14:45:09 <Kekker_> dmwit: So I've separated the "decode" function into two functions, one to take the tree and another to decode an input string.
14:45:12 <crysikrend> I wish I was more educated with all this stuff
14:45:42 <Kekker_> I've written this: "readLoop t = decode (t, getLine, [])", but I get an error on the "getLine" because it's expecting [Char] not IO String
14:45:42 <jackdk> IAC sequences are how the telnet protocol negotiates with the client about what options it can handle
14:46:07 <Kekker_> I've had to deal with IO String in other programs, but I solve that with <-, which I don't think I can use here. How do I fix that?
14:46:30 <crysikrend> thanks jackdk 
14:46:36 <jackdk> so you get negotiations where the server says "I can do compression. I can control line-mode. I can ... " and the client comes back with "Please compress. Please don't fiddle line-mode. I can tell you about my terminal type"
14:46:37 <crysikrend> okay.. this is a lot to take in
14:47:01 <jackdk> so, for a first pass, it's fine to treat telnet connections as just a byte stream
14:47:21 <jackdk> but if you start seeing weird byte 255s on either end, that's what they are
14:48:00 <jackdk> see rfc 854: http://www.omnifarious.org/~hopper/technical/telnet-rfc.html (this site is waay overkill for just getting started, but it tells you where everything is)
14:48:40 <crysikrend> so.. to put it into context for my situation, if you were to play teacher, what should my next focus be? I know about conduits for streaming, and I know that a servant package can take a SourceIO thing into
14:48:57 <amalloy> Kekker_: you can use do-notation anytime you want to produce a value of type IO a. for example, readLoop t = do {line <- getLine; decode (t, line, [])}
14:49:08 <crysikrend> take a conduit and put it into a SourceIO or something, I'm not sure where SourceIOs are used in servant though 
14:49:22 <crysikrend> oh thanks for that second link
14:49:37 <Kekker_> amalloy: I realize that, and that's how I've dealt with it before. However, this is for an assignment, I'm strictly not allowed to use do, records, or $
14:49:45 <amalloy> presuming that readLoop :: IO a, decode :: (x, String, y) -> IO a
14:50:07 <amalloy> ah. well, then, i'd say to look up what do-notation desugars to
14:50:19 <Kekker_> I actually want to get rid of IO, not produce it
14:50:41 <amalloy> impossible, i'm afraid, if you want to use getLine
14:51:25 <Kekker_> hm. Is there another way to get input?
14:52:09 <amalloy> nothing that doesn't involve IO. i think your goal of wanting to get rid of IO is misguided; what makes you think you need to do that?
14:52:34 <Kekker_> could I use a map? In my main line I do "interact (fmap (fst . parse) getLine >>= readLoop)" to pass the input to "parse", which builds the tree
14:53:10 <jackdk> crysikrend: given my extensive experience at failing to build mud servers, I'd say know that the telnet stuff exists but pretend that it doesn't. once you've got something going that's fun, go back and refactor it to add the support you want
14:53:34 <amalloy> sure. fmap is one way to take an IO a, and pass it to some function that wants an a. in this way you're not really "getting rid of" IO, but rather promoting the function from (a -> b) to (IO a -> IO b)
14:53:34 <jackdk> (aside: I really need to finish off https://git.sr.ht/~jack/libtelnet-haskell and push it to hackage.)
14:53:43 <zachk> jackdk, yea its a web front end for a mud that is telnetty, but I don't do anything fancy on the server side, so the web front end just treats the connections as line buffered streams of bytes 
14:54:05 <Kekker_> does IO String function similarly to [Char]?
14:54:13 <jackdk> zachk: that's really cool. haskell and muds are both great
14:54:19 <amalloy> String is the same as [Char]
14:54:19 <jackdk> is it live anywhere yet?
14:54:33 <Kekker_> I know String is, I'm just not sure if IO is
14:54:48 <amalloy> IO t is not the same as t, for any t
14:54:52 <zachk> i have a front end that handles the network connections and basic chat functionality, and a separate core that is hot loadable, the core is slow going in coding features for it though 
14:55:17 <jackdk> zachk: wow, hot-loadable core? that's sick. How'd you do that?
14:55:21 <crysikrend> jackdk: in terms of haskell packages and actually learning what to type though, I don't know my next step. Here's what I have so far: https://gist.github.com/Crysikrend/12184e49c34b02e5fa7ded4a5321e0ad
14:55:25 <Kekker_> so... back to my initial problem then. I'd like to use the string from the input as a list, but it tells me that I have IO String
14:55:40 <jackdk> Kekker_: are you familiar with the OO design patterns literature? If so, you can think of IO as a bit like the command pattern
14:55:43 <Kekker_> do I have to find a way to get rid of IO String, or can I use IO String as a string?
14:55:49 <geekosaur> @where iotut
14:55:49 <lambdabot> https://www.vex.net/~trebla/haskell/IO.xhtml
14:55:49 <jackdk> except more powerful and composable
14:55:52 <amalloy> if you have getLine :: IO String, and you want to call f :: (a, String, b) -> c, you will need to use either fmap or >>= to convert your IO string into an IO (a, String, b)
14:56:16 <amalloy> then you can give that to f (with fmap or >>=), and get back an IO c
14:56:21 <Kekker_> jackdk: I'd have to read that section again, but yes I'm familiar with the command pattern
14:56:23 <zachk> jackdk, its not online anywhere yet, need like account creation for startes and to add alot more features to the core, I use cloud haskell/distributed processes and have separate binaries communicating via message passing, in the core I use an stm TVar for the global state though to keep it simple and consistent
14:56:43 <zachk> Kekker_, use the IO String in a do block in the IO monad
14:56:55 <zachk> you can fmap over it 
14:57:02 <Kekker_> zachk: I can't use do
14:57:07 <zachk> or use line <- IO String function
14:57:07 <zachk> oh
14:57:12 <zachk> use fmap then 
14:57:14 <amalloy> Kekker_: what i suggested earlier is, you know how to solve this with do, right?
14:57:17 <zachk> @type fmap 
14:57:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:57:25 <zachk> IO is a functor 
14:57:26 <MarcelineVQ> "<amalloy> ah. well, then, i'd say to look up what do-notation desugars to"
14:57:28 <amalloy> solve it with do, and then look up how do-notation desugars and do it by hand
14:57:41 <Kekker_> with do, I'd just "input <- getLine" and I'm able to use input in any string function
14:58:09 <zachk> fmap anyStringFunction (IO String function)
14:58:17 <dmwit> Kekker_: Yes. You can teach any `t`-consuming function to be an `IO t`-consuming function.
14:58:29 <dmwit> Kekker_: That is essentially as good as turning any `IO t` into a `t`.
14:58:38 <zachk> you can't really escape the IO though Kekker_ , like ever 
14:58:54 <dmwit> Kekker_: However, this explanation doesn't seem to get much traction with people for some reason. (I think it is the best explanation.)
14:59:14 <dmwit> Kekker_: For one that does get a bit more traction, you could try sigfpe's "IO Monad for People who Simply Don't Care".
15:00:04 <Kekker_> so If I have "readLoop :: Tree -> [Char]" and "decode :: (Tree, [Char], [Char]) -> [Char]", could I do "readLoop t = fmap (t, getLine, []) decode"?
15:00:11 <spion> hmm. I wonder what I'm doing wrong? I thought in haskell `let scanned = takeUntil (elem scanned) sums` is supposed to work
15:00:31 <dmwit> Kekker_: No. You can't usefully call `getLine` from any function whose return type does not start with `IO`.
15:01:13 <delYsid> Kekker_: The parse function you pasted before you left is missing a terminating case I think.
15:01:16 <jackdk> the "I need to escape IO" thought usually comes from insufficient fluency with the functor/applicative/monad operations, because what you need to do is combine these commands to build larger commands. Eventually you have a single command called `main` that the runtime executes for you
15:01:16 <spion> err. `let scanned = takeWhile (not . elem scanned) sums`
15:01:21 <jackdk> that was certainly the case for me
15:01:33 <Kekker_> dmwit: so what did you mean by teaching t functions into IO t?
15:01:58 <dmwit> Kekker_: If you have `readLoop :: Tree -> [Char]`, you can turn that into `readLoop :: IO Tree -> IO [Char]`.
15:01:59 <Kekker_> delYsid: You mean from a few hours ago? What do you mean terminating case?
15:02:25 <dmwit> Kekker_: Similarly, if you have `decode :: (Tree, [Char], [Char]) -> [Char]`, you can turn that into `decode :: IO (Tree, [Char], [Char]) -> IO [Char]`.
15:02:30 <delYsid> Kekker_: Well, it recurses, but when does it stop?
15:02:32 <jackdk> Kekker_: instead of thinking of `fmap :: Functor f => (a -> b) -> f a -> f b` as a "function of two arguments", think of it as a function that transforms functions `fmap :: Functor f => (a -> b) -> (f a -> f b)`
15:02:44 <dmwit> Kekker_: If you have some other function `foo :: [Char] -> Bar`, you can turn that into `foo :: IO [Char] -> IO Bar`.
15:03:16 <dmwit> Kekker_: This last one is especially interesting because then `getLine :: IO [Char]` has just the right type to be its first argument.
15:03:22 <jackdk> Kekker_ also, have you tried manually desugaring the do-notation in what you wrote before (I assume you have working code that uses `do`, and are avoiding it for pedagogical reasons)?
15:03:25 <Kekker_> delYsid: When the string ends. I've had it "show" before, it does work.
15:03:38 <Kekker_> though I'm not sure why it does, now that you mention it
15:03:53 <delYsid> Kekker_: In general, using head smells of trouble.  This looks like a job for pattern matching, and then the missing terminating case should be obvious.
15:04:08 <dmwit> Kekker_: Also I was unforgivably sloppy. I said "you can turn `readLoop :: Tree -> [Char]` into `readLoop :: IO Tree -> IO [Char]`", but I *should* have said "...into `fmap readLoop :: IO Tree -> IO [Char]`".
15:04:17 <Kekker_> jackdk: I don't actually have working do code right now
15:04:22 <dmwit> Kekker_: Same for the other functions. In each case I forgot to say `fmap`, and this was bad and I apologize.
15:04:39 <jackdk> dmwit: "unforgiveable"? pah. lies. we forgive you.
15:04:53 <delYsid> Kekker_: parse (c:cs) = ...; parse [] = ...
15:05:15 <dmwit> Kekker_: Putting these observations together, if `foo :: [Char] -> Bar`, then `fmap foo getLine :: IO Bar`.
15:05:18 <jackdk> Kekker_: I would strongly suggest writing it with `do` at some point, then when you have something that works, you can transform it into calls to `>>=`, `fmap`, etc
15:05:44 <jackdk> zachk: so your core, when it reboots, just dumps and reloads state? and because everything else is running as distributed processes, they buffer and reconnect smoothly?
15:06:19 <Kekker_> delYsid: Thanks, I'll do that in a minute
15:06:37 <dmwit> Kekker_: There is another function for teaching things that already do IO to consume IO.
15:06:40 <dmwit> :t (=<<)
15:06:41 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:07:06 <dmwit> In particular, `(=<<) :: (a -> IO b) -> (IO a -> IO b)`.
15:07:37 <Kekker_> I'm a little bit overwhelmed with information right now, gimme a sec to read all the messages
15:07:49 <zachk> jackdk, I haven't gotten to state handling yet, there is only like two rooms atm, for testing, and like just as many users built in
15:07:53 <dmwit> So `fmap` teaches completely pure functions that take `a` arguments how to be `IO` functions that take `IO a` arguments; and `(=<<)` teaches `IO` functions which take `a` arguments how to be `IO` functions which take `IO a` arguments.
15:08:25 <jackdk> zachk: fair enough. I wish you great success because it sounds cool
15:08:49 <zachk> thank you, I have been sporadically working on it for a while now :)
15:09:19 <monochrom> Someone please also suggest my IO tutorial when the time is right. >:)
15:09:31 <MarcelineVQ> monochrom: in fact it was already :>
15:09:41 <dmwit> monochrom: The time was already right in the past, and the cause was taken up. =)
15:10:25 <Kekker_> https://pastebin.com/ZCvjQQrh
15:10:30 <Kekker_> that's for sure wrong
15:11:12 <Kekker_> but those are the lines that I'm working with. I get mapping to a function that takes an argument of similar type, but I'm trying to move the string from getline into a tuple
15:11:27 <spion> oh. flip elem.
15:11:34 <Kekker_> is that doable with fmap or =<<? Is that doable at all?
15:11:57 <Kekker_> spion: is that for me or is that another conversation
15:12:20 <spion> sorry, i just answered my own question :)
15:12:33 <Kekker_> oh, got it
15:13:23 <monochrom> The type "Tree -> [Char]" does not allow you to use getLine.
15:13:48 <Levy[m]> what you have currently doesn't make much sense since you now are pasing a tuple to fmap rather than a function
15:14:05 <dmwit> Kekker_: Start simple, with no IO. Can you write a function of type `[Char] -> [Char]` which assumes you have already given it the line read from `getLine`?
15:14:24 --- mode: glguy set +v Arney
15:14:28 <dmwit> Kekker_: Let us call it `readLoopPure`.
15:14:35 <Arney> what do i get when i do liftM (+) (Just 1)
15:14:50 <Arney> Maybe a function? does that mean i can bind and call it?
15:14:52 <dmwit> Arney: Just ((+) 1), of course.
15:15:01 <dmwit> Arney: Certainly.
15:15:06 <Arney> dmwit: how would i do that?
15:15:13 <Arney> liftM (+) (Just 1) >>= (\x->x 1)
15:15:15 <Arney> trying like this
15:15:30 <monochrom> @type liftM (+) (Just 1) >>= (\x->x 1)
15:15:32 <lambdabot> Num (Maybe b) => Maybe b
15:15:39 <hololeap> > liftM (+) (Just 1) (Just 2)
15:15:40 <dmwit> Arney: Perhaps you would like `\x -> return (x 1)` or similar!
15:15:40 <Levy[m]> Kekker_: think of IO as a context*, any IO action can only be executed within an IO context
15:15:42 <lambdabot>  error:
15:15:42 <lambdabot>      • Couldn't match expected type ‘Maybe Integer -> t’
15:15:42 <lambdabot>                    with actual type ‘Maybe (Integer -> Integer)’
15:16:00 <dmwit> > liftM (+) (Just 1) >>= \f -> return (f 1)
15:16:02 <lambdabot>  Just 2
15:16:04 <Arney> yeah that works.
15:16:06 <monochrom> Ah yeah what dmwit says
15:16:21 <Kekker_> dmwit: I don't think so. readLoop takes the Tree as its argument, without that it wouldn't work right
15:16:24 <dmwit> > liftM (+) (Just 1) >>= \f -> if even (f 1) then f 2 else Nothing
15:16:28 <lambdabot>  error:
15:16:28 <lambdabot>      • No instance for (Integral (Maybe ()))
15:16:28 <lambdabot>          arising from a use of ‘e_1112’
15:16:40 <dmwit> > liftM (+) (Just 1) >>= \f -> if even (f 1) then Just (f 2) else Nothing -- fell prey to the same mistake, lol
15:16:42 <lambdabot>  Just 3
15:16:43 <Arney> why do i need to return there, i don't get it
15:16:45 <monochrom> Also <*> could be useful.
15:17:07 <monochrom> return = Just for this example.  You need Just somewhere don't you?
15:17:07 <dmwit> Kekker_: Okay, no problem. Can you then write a function `readLoopPure :: Tree -> [Char] -> [Char]` instead?
15:17:22 <Arney> monochrom: where would i see it in the type signure
15:17:33 <Arney> i mean, i get that it's Just(a->a)
15:17:37 <dmwit> Arney: (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
15:17:47 <dmwit> Arney: So the second argument to `(>>=)` must return a `Maybe`.
15:17:50 <Arney> but that a->a function shouldn't it "return" a and not m a?
15:18:03 <monochrom> The type of >>= requires  (foo :: Maybe X) >>= (bar :: X -> Maybe Y)  and it is not (bar :: X -> Y)
15:18:04 <Arney> so the pure i am "calling" is the one of the monad
15:18:12 <Arney> yeah i get that, thanks
15:18:12 <dmwit> Arney: Since you have a function which doesn't return a `Maybe`, you must teach it how to return a `Maybe` instead.
15:18:14 <Arney> that's all
15:18:14 <Kekker_> dmwit: I don't think I can do that either. I call readLoop from the main line: "main = interact (fmap (fst . parse) getLine >>= readLoop)", and I don't think I can pass a second argument to readLoop there... can I?
15:18:43 <dmwit> Kekker_: Why not?
15:18:55 <Kekker_> the compiler yells at me when I try lol
15:19:12 <Levy[m]> what does the compiler say?
15:19:18 <dmwit> Kekker_: Well, it won't yell when *I* try. =)
15:19:28 <hololeap> :t \m f x -> m >>= f x
15:19:29 <lambdabot> Monad m => m a -> (t -> a -> m b) -> t -> m b
15:19:33 <dmwit> Kekker_: So start with `readLoopPure :: Tree -> [Char] -> [Char]`, and we will build towards `main` together.
15:19:52 <Arney> is there something that makes a->a to a->m a
15:19:53 <hpc> fun fact: every copy of ghc comes with a simulated copy of dmwit that writes the working version of your code for you
15:19:57 <Arney> i guess that.s return, right?
15:19:58 <monochrom> Yeah comment out main for now.
15:20:03 <Kekker_> I don't know where that second argument would go logically. Does >>= pass the left side as the leftmost argument, or the rightmost? Does it matter?
15:20:12 <dmwit> Arney: Pretty much. You need the composition operator (.) as well.
15:20:27 <monochrom> @type \f -> return . f
15:20:29 <lambdabot> Monad m => (a1 -> a2) -> a1 -> m a2
15:20:56 <dmwit> Kekker_: The type has the answer.
15:20:57 <dmwit> :t (>>=)
15:20:59 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:21:08 <Arney> yeah i am just doing stupid things to understnad
15:21:17 <Kekker_> uh
15:21:19 <dmwit> Kekker_: But it doesn't matter. We are not dealing with IO yet, and won't be using (>>=) yet.
15:21:21 <Kekker_> so leftmost? I think?
15:21:26 <Kekker_> okokok
15:21:28 <Arney> im guessing it makes sense becausue pure "pulls" stuff into the monad
15:21:34 <monochrom> Yeah
15:22:28 <Kekker_> I'm getting "The IO action `main' is not defined in module `Main'"
15:22:45 <Kekker_> I've commented out "module Main where", "main :: IO()", and "main = interact ..."
15:22:46 <monochrom> If you like to try out Applicative's <*>, there is also: liftM (+) (Just 1) <*> (Just 2)
15:22:48 <dmwit> You can stub it out; try `main = return ()`.
15:23:01 <Arney> but pure doesn't exactly turn id to x->return \x
15:23:04 <Arney> does it?
15:23:14 <dmwit> Kekker_: A question, though; you wrote `main = interact (...)`. Are you required to use `interact` by the assignment?
15:23:36 <dmwit> Kekker_: Never mind whether you're required to. We should discuss whether you *intend* to, for whatever reasons.
15:23:36 <monochrom> Right, pure :: a -> m a
15:23:51 <hololeap> dmwit: they are not allowed to use `do`, so interact seems like a good way to go
15:23:58 <dmwit> Arney: Right. That's why I said you also need another piece. =)
15:24:12 <Arney> but where isn't there a function that does that
15:24:14 <amalloy> hololeap: not if you need to do any other IO besides reading stdin once
15:24:14 <Arney> stupid question
15:24:14 <dmwit> hololeap: It is certainly one good way to go. It is also incompatible with the current path.
15:24:23 <Kekker_> dmwit: No, it's not strictly required, but it's heavily implied that I should. I've been adapting the inside of interact since I started, I don't honestly know what it does
15:24:50 <Kekker_> my professor just told us it's magic, and since everything is compiling with it I never questioned it
15:24:51 <Arney> how do i create a function that turns id to \x->[x] (specific case) list monad
15:25:03 <Arney> i rather return the x instead, sure, and that gets concatmapped
15:25:16 <dmwit> Kekker_: Okay. What do you need to know to decide whether you want to use `interact` or some other approach?
15:25:19 <Levy[m]> Kekker_: Look up the definition of Interact
15:25:24 <Arney> but there is not something that "transform" the return value ofa  fucntion, does it?
15:25:38 <amalloy> Arney: function composition transforms the return value of a function
15:25:41 <monochrom> Not in the standard libraries.
15:25:43 <dmwit> Don't look up the definition of interact. It is full of details that will only distract from your goals.
15:25:54 <hololeap> :t (\([l1],ls) -> undefined) . splitAt 1 . lines
15:25:55 <lambdabot> String -> c
15:25:57 <Kekker_> I wasn't planning on looking until after
15:25:58 <dmwit> I mean, my understanding of your goals.
15:26:02 <Arney> amalloy: i get that, but why can't i make the function magicially call pure?
15:26:13 <Arney> oh.. i guess because the function doesn't know what pure is
15:26:15 <Kekker_> I just need to know whether my program will be able to output properly without interact
15:26:18 <Arney> without context.. is that right?
15:26:20 <amalloy> Arney: so, what is the exact type of the function you want?
15:26:21 <geekosaur> magically by and large isn't a thing in haskell
15:26:24 <MarcelineVQ> magic isn't real unless you believe hard enough
15:26:32 <dmwit> Kekker_: Your program can be written with interact, and can be written without interact.
15:26:38 <Arney> amalloy: another whay to write pure.id
15:26:56 <amalloy> :t pure . id
15:26:57 <monochrom> Arney: You can use \f -> \x -> return (f x)  i.e., \f -> return . f  but it is not given a name in the standard libraries.
15:26:57 <lambdabot> Applicative f => a -> f a
15:27:16 <amalloy> pure . id sounds like a great function to me. 
15:27:19 <Kekker_> dmwit: What difference does it make?
15:28:15 <dmwit> Kekker_: If you use `interact`, our goal will be to write a completely pure function which takes a `String` representing the entire input typed by the user and produces a `String` representing the entire output of the program.
15:28:23 <Kekker_> I know all the examples that the professor provided using interact also contained lines and unlines. Are those affected?
15:28:25 <Arney> what do you do when monads "stack" ?
15:28:33 <Arney> how does a function know which return is meant?
15:28:43 <dmwit> Kekker_: If you do not use `interact`, our goal will be to write an IO action which behaves similarly.
15:28:52 <monochrom> Like "StateT X IO Y"?
15:29:13 <Kekker_> I would prefer to use a String, I think. It sounds simpler, though I say that without a full understand of what IO action means
15:29:15 <dmwit> Arney: The magic of type inference! (And sometimes, in rare cases, it does not know.)
15:29:28 <Levy[m]> dmwit: It's a two line definition...
15:29:32 <dmwit> Kekker_: Fine. Then abolish the fact that `getLine` exists from your mind entirely.
15:29:41 <Arney> dmwit: and then, what do you do?
15:29:55 <Kekker_> dmwit: ooooookay then. getLine is gone
15:30:09 <dmwit> Arney: Give it some hints with manual type annotations, for example.
15:30:35 <monochrom> Bah people speak too generally.
15:30:36 <Arney> well, thanks as usual for the answers
15:31:42 <Kekker_> so I take it when using interact, I'm going to want to use lines and not getLine?
15:31:52 <dmwit> That seems sensible to me.
15:32:15 <c_wraith> if you're using interact, you really shouldn't touch anything else with IO in the type.
15:32:20 <monochrom> If you aim at String->String the type does not allow you to use getLine or putStrLn.
15:32:55 <Arney> (Just (Just 1)) >>= (\x->return x >>= (\x->pure (x+1)))
15:32:58 <Arney> why doesn't this work now?
15:33:12 <monochrom> First does it type-check?
15:33:20 <Arney> yep
15:33:37 <Arney> atleast if i understand the term correctly
15:33:42 <monochrom> OK then let me show my evaluation steps and maybe you see what happens.
15:34:02 <monochrom> = return (Just 1) >>= (\x->pure (x+1))
15:34:20 <Arney> without the +1 it works
15:34:26 <monochrom> = pure ((Just 1) + 1)
15:34:36 <monochrom> I don't know how to do Just 1 + 1
15:34:51 <Arney> i don't know when that happens :o
15:34:53 <monochrom> I don't have a "Num a => Num (Maybe a)" instance.
15:35:04 <monochrom> @type  (Just (Just 1)) >>= (\x->return x >>= (\x->pure (x+1)))
15:35:05 <lambdabot> (Num (Maybe a), Num a) => Maybe (Maybe a)
15:35:11 <dmwit> Levy[m]: It is a two-line definition; but as soon as you see it, it raises two questions in your mind ("how does the first line work?" "how does the second line work?"). And then you get into lazy IO, and buffering, and a zillion other details as you try to chase down how each piece works.
15:35:16 <Arney> can you correct it maybe?
15:35:18 <Arney> then i see?
15:35:36 <Kekker_> dmwit: That was my issue. I didn't know how the first or second lines worked at all
15:35:44 <monochrom> I would delete one of the two Just's.
15:35:45 <Arney> why is x still (Just 1)?
15:35:46 <dmwit> Levy[m]: After just two clicks you are looking at deeply internal Handle-managing code with terms like SemiClosedHandle.
15:35:55 <Arney> i mean the second x
15:35:59 <hololeap> @type (Just (Just 1)) >>= (\x->return x >>= (\x-> liftM (+1) x))
15:36:00 <lambdabot> Num b => Maybe b
15:36:10 <Kekker_> though if I use getLine, the program would terminate after one run through the functions wouldnt it?
15:36:18 <Kekker_> with lines, it would wait until you closed the program?
15:36:32 <dmwit> Both of those claims sound false to me.
15:36:35 <monochrom> (return x0 >>= \x1 -> ... x1 ...)  =  ... x0 ...
15:36:40 <Kekker_> why
15:36:52 <Arney> but shouldn't the second x not be "unwrapped" to Num already?
15:36:59 <Arney> i mean i bind 2 times
15:37:11 <monochrom> No I don't think unwrapping. I only follow real rules.
15:37:14 <dmwit> Why would using getLine cause your program to terminate before you intended it?
15:37:29 <monochrom> return x0 >>= f  =  f x0.  Done.  What unwrapping?
15:37:30 <Arney> monochrom: yeah and i want to understand the rules that's why i do that weird stuff
15:37:41 <Kekker_> dmwit: I never said that
15:37:42 <monochrom> return (Just 1) >>= f  =  f (Just 1).  Done.
15:37:46 <dmwit> Why would using lines cause your program to wait? <- Actually this one I suppose I probably get. It is a holdover from patterns learned in strict languages. But Haskell is not strict.
15:38:24 <Kekker_> I'd assumed lines would cause the program to wait because it takes every line of input, but when you run the terminal through cli the input only goes through one line at a time
15:38:26 <monochrom> If you really like unwrapping, >>= only unwraps one level.
15:38:36 <Arney> that's why i call it twice :p
15:38:40 <monochrom> You have Just (Just 1) you have two levels.
15:38:43 <dmwit> (And `interact` is even a bit more magical than merely "not strict". But we won't get into that yet. It is enough for now to know that if the function you give to `interact` is lazy in the right ways, your program behaves as if typing and outputting are lazy in the right ways.)
15:38:54 <monochrom> You have a return that increases the level again.
15:39:09 <Arney> but i return the value of a nother bind
15:39:27 <Arney> which then should get a Num as a parameter, no?
15:39:31 <hololeap> Kekker_: if you use `main = interact f`, it will take the input from stdin, process it with `f` (a pure function, no IO), print the results to stdout, then terminate
15:39:49 <Levy[m]> dmwit: which then results in questions about "lazy in the right way"
15:39:56 <dmwit> Levy[m]: Certainly.
15:40:12 <Arney> oh, with correct parenthesis my stuff works
15:40:17 <monochrom> OK maybe I can say this.  You start with Just(Just...) two levels. After >>= one level, After return two levels again.  No net decrease.
15:40:20 <Kekker_> hololeap: Thank you for a straight answer
15:40:40 <Levy[m]> and you eventually end up on the same path
15:40:41 <Arney> (Just (Just 1)) >>= (\x->return (x >>= (\x->pure x+1))) ⇒ doesn't work
15:40:46 <dmwit> hololeap's answer doesn't appear to be the answer to the question you asked.
15:40:53 <Arney> (Just (Just 1)) >>= (\x->return (x >>= (\x->pure (x+1)))) ⇒ works
15:41:01 <Arney> that's what i was trying to do
15:41:15 <monochrom> > (Just (Just 1)) >>= (\x->return (x >>= (\x->pure (x+1))))
15:41:15 * hackage RLP 1.1.1 - RLP serialization as defined in Ethereum Yellow Paper  http://hackage.haskell.org/package/RLP-1.1.1 (jasagredo)
15:41:17 <lambdabot>  Just (Just 2)
15:41:37 <monochrom> OK I see.
15:42:03 <Arney> why did the first typecheck?
15:42:17 <Kekker_> dmwit: I asked what interact does a long while ago. He gave me a useful, easy to understand answer
15:42:38 <dmwit> Okay, great!
15:43:03 <monochrom> I don't know how to answer, apart from following the whole unification resolution process that type-infers the expression.
15:43:38 <monochrom> But it is unusable anyway.  You incur a "Num (Maybe a)" constraint.
15:44:01 <Kekker_> The reason I switched from using lines in the first place was every time I tried to use it, I would get some obtuse compiler error saying lines is applied to too few arguments
15:44:14 <Kekker_> but without it, I get the annoying IO errors
15:46:13 <Levy[m]> what is the shape (type) of `lines` and which shape (type) did you need?
15:47:35 <dmwit> Kekker_: I've lost track of the story, I think. What would you say is the top-level thing stopping you from making progress right now?
15:48:06 <Kekker_> passing a line of input into decode
15:48:38 <Kekker_> Levy[m]: Lines is [String] and I need String
15:48:42 <Kekker_> :t lines
15:48:43 <lambdabot> String -> [String]
15:48:45 <dmwit> Do you believe you can write a function which takes all the lines, and picks out the line you want to pass into decode?
15:49:00 <Kekker_> I don't know what I believe
15:49:16 <Kekker_> I don't know this language, I honestly don't know the answer to any of the questions you've been asking me
15:49:49 <dmwit> Okay. This particular question is easy to test empirically just by trying. If you find you cannot, then at least you will have a focused subproblem to learn more about.
15:50:04 <dmwit> And if you can, then I believe you will have made progress towards your goal.
15:50:20 <Kekker_> I cannot. I've been trying to learn for a week and I haven't made any progress without someone explaining things to me
15:50:25 <Kekker_> I can't learn this on my own
15:50:31 <Arney> Kekker_: haha, beginner
15:50:37 <Arney> im doing this for 3 month
15:50:42 <Kekker_> thanks arney, I needed that
15:50:52 <Arney> and i have a looooooot of languages in my arsenal
15:50:55 <Arney> godspeed young man
15:51:03 <dmwit> That is, indeed, a problem. In that case, now is the time to find out what resources your class provides for getting one-on-one tutoring.
15:51:11 <Arney> it's worth it though, understanding monads was heaven
15:51:14 <Levy[m]> Kekker_: Which material are you following?
15:51:26 <hololeap> Kekker_: you can use `head` to pop the first line off of your [String], or use pattern matching
15:51:44 <Kekker_> Levy[m]: http://learnyouahaskell.com/chapters
15:52:07 <Kekker_> I don't understand the application of anything that I read
15:52:23 <Kekker_> hololeap: I try that, but then I get the too few arguments error
15:52:34 <Arney> Kekker_: well you do understand let add a b = a+b, right?
15:53:03 <hololeap> Kekker_: do you have an updated paste of your code? it's probably a simple mistake somewhere
15:53:46 <sm> Kekker_: try https://leanpub.com/haskell-cookbook, it's hands-on
15:54:19 <dmwit> There are many alternate resources.
15:54:22 --- mode: glguy set +v bigos
15:54:43 <bigos> how do I convert a String to IO String
15:54:53 <monochrom> pure
15:54:56 <dmwit> bigos: `pure` or `return` will do that
15:54:58 * Arney helped watching "escaping the ivory tower", looking at implemntation of List Monad, and then watching "tsoding" explaining the IO monad
15:55:02 <Levy[m]> search for a function `a -> m a`
15:55:09 <Arney> Levy[m]: hehe.
15:55:24 <Levy[m]> I was too late
15:55:34 <dmwit> ?hoogle String -> IO String
15:55:34 <lambdabot> Foreign.C.Error throwErrno :: String -> IO a
15:55:34 <lambdabot> System.Exit die :: String -> IO a
15:55:35 <lambdabot> Language.Haskell.TH.Syntax badIO :: String -> IO a
15:55:38 <dmwit> ouch, no
15:55:49 <Levy[m]> ?hoogle a -> m a
15:55:49 <Arney> why can't haskell actually compare functions?
15:55:50 <lambdabot> Control.Exception.Lifted evaluate :: MonadBase IO m => a -> m a
15:55:50 <lambdabot> Happstack.Server.Response ok :: (FilterMonad Response m) => a -> m a
15:55:50 <lambdabot> Happstack.Server.Response noContent :: (FilterMonad Response m) => a -> m a
15:55:59 <Levy[m]> ok that's even worse
15:56:03 <Arney> simply because they aren't typeclassed?
15:56:04 <Kekker_> hololeap: https://pastebin.com/F8LJ5Nps
15:56:08 <Arney> with Eq?
15:56:18 <Arney> that's a stupid question
15:56:18 <Kekker_> when I replace getLine with "head lines" I get the error
15:56:28 <dmwit> Well. Yes, although then the obvious followup is "why is there no Eq instance for functions?".
15:56:35 <Kekker_> but then I'm getting errors anyways cuz I can't really do anything right
15:56:53 <hpc> Arney: determining if two programs are equal is mathematically "very hard"
15:57:02 <Levy[m]> Equality of functions is a fun yet involved topic
15:57:07 <Arney> hpc: string compare
15:57:09 <Arney> no.. i get it.
15:57:17 <dmwit> And there the answer is two-fold: one obvious way to do it would be pointer equality, but this would violate referential equality. So you need something better, and "something better" is undecidable.
15:57:26 <Arney> Kekker_: start "ghci"
15:57:39 <Arney> try "lines "a\nb""
15:57:50 <dmwit> But you can do it if the functions are on a finite domain. I have a package for it, if that sounds interesting.
15:57:53 <Arney> you will get ["a","b"] becausue the "\n" marks new lines
15:58:03 <Kekker_> I get a parse error
15:58:13 <Arney> well, skip the first and the last "
15:58:21 <Arney> lines "a\nb"
15:58:32 <dmwit> Arney: You might also like https://stackoverflow.com/q/17045941/791604
15:58:39 <Kekker_> yea I realize how escape sequences work, and I know that lines is [[Char]]
15:58:52 <Arney> well.. yeah, next step is
15:58:53 <dmwit> Kekker_: lines is not [[Char]]
15:58:56 <Arney> write "head" in front of that
15:59:07 <Kekker_> dmwit: it returns [[Char]]
15:59:14 <Arney> head lines "a\nb" ⇐ this won't work
15:59:18 <dmwit> Kekker_: With that I agree.
15:59:28 <Arney> because "lines" is the first parameter of head in that case, you need parenthetis
15:59:42 <Arney> so you do: head (lines "a\nb")
15:59:55 <Arney> and nobody mentiones $
16:00:04 <monochrom> No no, there is no $
16:00:08 <delYsid> $ is forbidden :-)
16:00:15 <Kekker_> lol thanks guys
16:00:17 <Levy[m]> What even is $?
16:00:27 <Levy[m]> anyway
16:00:39 <Kekker_> Arney: how does that work in an interact function? head (lines) still gives me the same error
16:00:46 <Arney> lines "a\nb" will become ["a","b"], and head will give you the first thing in that list
16:00:55 <Levy[m]> :t head . lines
16:00:56 <lambdabot> String -> String
16:01:09 <Arney> headline, huehue
16:01:18 <Arney> you can even talk that function
16:01:37 <Levy[m]> current = head . lines -- ?
16:01:47 <dmwit> Kekker_: `head lines` does not work because `lines` is a function, and `head` expects a list.
16:01:55 <Kekker_> that's what I figured
16:02:06 <dmwit> Kekker_: So you must call `lines` on a `String`. Then you can call `head` on the result.
16:02:08 <Kekker_> so the question is, how do I take the head of the output of lines
16:02:13 <Kekker_> in an interact
16:02:41 <Levy[m]> well, there's composition
16:02:49 * hackage miniutter 0.5.0.0 - Simple English clause creation from arbitrary words  http://hackage.haskell.org/package/miniutter-0.5.0.0 (MikolajKonarski)
16:02:52 <dmwit> Kekker_: One possible way to proceed would be to name the `String` that `interact` passes to your callback.
16:02:55 <Kekker_> I've tried head . lines
16:02:58 <Kekker_> should I try lines . head?
16:03:19 <Arney> no head $ lines "a\nb"
16:03:22 <[Leary]> Don't attempt pointfree yet. Use a lambda or a named helper function.
16:03:26 <dmwit> My personal opinion: no, you should not try random code snippets and see what sticks.
16:03:28 <Levy[m]> look at the types and see why that doesn't work
16:03:28 <Kekker_> Arney: can't use $
16:03:35 <Arney> :D
16:04:00 <Levy[m]> the :t is your best friend
16:04:01 <Arney> head (lines "your string)
16:04:02 <dmwit> Kekker_: You know how to define functions that take arguments, no?
16:04:02 <Arney> will work
16:04:05 <Kekker_> dmwit: That wasn't a random code snippet, I was wondering if I got composition backwards
16:04:21 <monochrom> dmwit: My opposite opinion: You should try random mutations. The problem with humans is they are not random enough to actually run into any correct answer.
16:04:26 <dmwit> Kekker_: So do that. Write a function `doEverything :: String -> String`. Then you have `String` in the body of `doEverything` to call `lines` on.
16:04:42 <Arney> Kekker_: no, composition of those 2 doesn't work like that
16:04:43 <Levy[m]> Kekker_: Check the types of all involved and see how they line up
16:04:44 <dmwit> Kekker_: Then at the top level you can write `main = interact doEverything`.
16:04:49 <Arney> if you watch the type of "head.lines"
16:05:05 <Arney> well it's exactly what you want. so i remain silent
16:05:12 <Kekker_> Levy[m]: Not sure what you mean
16:05:39 <Arney> if you write: head.lines "abc"
16:05:40 <Levy[m]> in GHCI use :t on (.), head, and lines
16:05:47 <Arney> lines "abc" will get precedence
16:05:57 <Arney> so again you will have to use parenthesis
16:06:03 <dmwit> monochrom: Hm. Challenge problem: specify the distribution you have in mind that you think would work well. =)
16:06:04 <Arney> (head.lines) "abc"
16:06:36 <Arney> or head.lines $ "abc" which is the same thing
16:06:50 <zachk> @type interact
16:06:51 <lambdabot> (String -> String) -> IO ()
16:06:51 <Kekker_> Levy[m]: I do get WHY the (.) doesn't work, I just don't understand how to make it work
16:07:02 <Arney> haskell should've gone the lisp way, and be prefix only
16:07:04 <Arney> am i alone with that?
16:07:06 <dmwit> So DON'T USE (.).
16:07:14 <dmwit> If you don't understand it, use something you do understand.
16:07:22 <zachk> Arney, I like infix operators for some stuff, especially math 
16:07:23 <Kekker_> I don't understand ANYTHING
16:07:26 <Kekker_> like, at all
16:07:30 <dmwit> Then later you can try to mutate to use the thing you don't understand to check and grow your understanding.
16:07:36 <Arney> zachk: especially in math i don't get it.. 
16:07:38 <dmwit> Bah. You understand how to create functions.
16:07:42 <dmwit> I've seen you do it at least once.
16:07:54 <zachk> Kekker_, haskell is kind of like that at first, then it clicks, takes a few weeks/months 
16:07:55 <Arney> and im super positive i would've gotten monads faster, if it was prefix only
16:07:59 <Kekker_> I don't understand haskell
16:08:10 <zachk> fire up ghci and just play around with it 
16:08:13 <Kekker_> I have 5 hours, not weeks
16:08:25 <zachk> oh
16:08:33 <Kekker_> I didn't even leave this one to the last minute, I've been playing with haskell for 2 weeks now
16:08:37 <Arney> better invent timemachine
16:08:44 <monochrom> dmwit: A learned person has a distribution that has higher probability for correct answers. That works well. (Learned persons work well, duh.)  A haven't-learned but really rational person will use a uniform distribution.  A haven't learned but normal human suffers Dunning-Kruger so their distribution actually unfavours correct answers.
16:08:45 <Arney> Kekker_: well, brace yourself
16:08:49 <Kekker_> I can't wrap my head around anything I'm reading or doing, except basic syntax
16:08:53 <Levy[m]> Then I guess it's 1-2 hours on haskell basics and the rest on the task
16:09:09 <Levy[m]> If you want I can walk you through some of it
16:09:21 <[Leary]> Kekker_: `f . g` is just `\x -> f (g x)`, so forget about composition and handle your argument explicitly.
16:09:23 <zachk> kekker, you might want something like (unlines. map functionThatDoesStuff . lines) fed into interact 
16:09:29 <zachk> @type map 
16:09:31 <lambdabot> (a -> b) -> [a] -> [b]
16:09:50 <Arney> zachk: let bind = (>>=) in bind [1,2,3] (\x->pure x)
16:09:52 <Arney> much clearer, to me
16:10:04 <Levy[m]> because atm it's not really going anywhere
16:10:25 <Arney> you can kinda speak it, like language
16:10:35 <Arney> bind that monat to that function, which then returns something monad-ish
16:11:05 <Arney> [1,2,3] >>= pure is just crap for leaning.. but that's just me i guess
16:11:43 <Levy[m]> Implementing monads is the way to learn them
16:11:55 <Levy[m]> practically rewriting part of prelude
16:12:09 <Levy[m]> then reader, state, writer
16:13:00 <Kekker_> Ok I may have been hyperbolic
16:13:50 <Kekker_> I know some basics, I don't want to spend another two hours rereading basics. I know how lists work, I know how to define a function and perform pattern matching, and I now properly know what interact does
16:13:51 <Levy[m]> anyway, Kekker_ , mind going over haskell basics again for a bit?
16:13:58 <Kekker_> I still don't know how to apply any of this
16:14:40 <Kekker_> What basics am I missing Levy[m]
16:14:56 <Levy[m]> not basics as in Int, Bool, String, but more of composing things you already have
16:15:26 <Kekker_> I really only want to learn what's relevant for this specific program, since it's due in less than 5 hours and I have another 50 years of my life to learn more haskell
16:15:44 <Levy[m]> That's the unfortunate trap
16:15:47 <Kekker_> Wdym composing things I already have?
16:16:19 <Kekker_> I'm definitely interested in Haskell and functional programming, and I've been wanting to learn for a while, I'm just busy
16:16:20 <sm> Kekker_: when I am in that place, this helps: leave ghcid running in another window. Simplify your program until it compiles. Add the smallest changes you can without breaking the compile. Literally change one character at a time if you need to. Also have ghci open to test types manually.
16:16:32 <Levy[m]> such as the parts you've mentioned thus far along with a few more utilites from prelude, etc to help glue things together
16:17:12 <Kekker_> sm: I don't have ghcid
16:17:15 <sm> get it
16:17:20 <Kekker_> from where?
16:17:21 <Levy[m]> ^
16:17:24 <sm> hackage
16:17:31 <Kekker_> I don't know what that is
16:17:35 <sm> find out
16:17:40 <Kekker_> great
16:17:45 <Arney> thanks for your help channel
16:17:48 <Arney> good night
16:17:52 <sm> to learn how to glue things together, you need rapid feedback 
16:17:56 <hololeap> Kekker_: here, you still need to fill in the implementation details, but this should at least give you an idea of what the basic structure could look like: https://pastebin.com/Pqz3xF8v
16:18:01 <Levy[m]> It doesn't take long plus it has a search function
16:18:07 <Arney> Kekker_: watch "escape from the ivory tower" on youtube
16:19:17 <Arney> then watch really closely on functors,applicative, monads until you understand how "replicateM 3 [1,2,3]"
16:19:20 <Arney> that's what helped me.
16:19:34 * Levy[m] wishes haskell had typed holes like Idris
16:19:40 <Kekker_> hololeap: Oh, I hadn't thought of writing my own splitLines. That makes sense.
16:19:40 <hpc> it does
16:19:51 <Levy[m]> with the same clean messages
16:20:02 <hpc> ah, that it doesn't have yet
16:20:02 <Levy[m]> instead of spewing text on the screen
16:21:16 <Levy[m]> That and error reflection
16:24:17 <Kekker_> :hololeap so for loopOverLines, you take a function and a list of strings, right? And then you map the strings on top of the function that you passed in?
16:26:14 <Kekker_> and you do unlines of that map because that's what gets returned all the way back to the interact?
16:28:29 <geekosaur> interact abstracts I/O into processing a lazy string to produce a lazy string. from there it's your problem.
16:28:54 <geekosaur> lines splits a string into lines, unlines does the reverse. both are lazy
16:29:23 <Kekker_> what exactly does lazy mean
16:29:33 <Kekker_> a lot of people have been saying that but I'm not sure what it means
16:29:54 <Kekker_> I'm also not entirely sure what pure means
16:29:56 <Levy[m]> Lazy means it only does stuff when it needs to
16:30:00 <Levy[m]> in this case
16:30:11 <geekosaur> in a strict  language, you would expect that "lines" reads the entire input and then splits it. in fact, it does so only as something requires it
16:31:21 <geekosaur> and lists are maximally lazy: on each processing step you force evaluation only of a single cons node (:), and you force evaluation of its head or tail separately
16:32:20 <geekosaur> (thus 'length :: [a] -> Int' never forces any of the list elements' values, only the (:) nodes that link the list together)
16:32:37 <Kekker_> So if lines wasn't lazy, would it only give output right before the program terminates? Instead of providing output every time you hit return?
16:33:52 <geekosaur> even hitting return is less ebcause of lines/unlines than because terminals work in terms of lines by default (handles set to line buffering, and on unixlikes the terminal sends a line at a time so you can use backsapce to edit)
16:34:30 <Kekker_> oh ok
16:34:47 <Kekker_> so what would be something lines would do differently if it wasn't lazy?
16:35:24 <geekosaur> red the entire inptu first. my point there was that, withut the lienbuffering stuf, you could see output per character even with lines/unlines
16:36:14 <geekosaur> depending on what  exactly you did in between
16:37:28 <Kekker_> ohhh ok I see what you mean
16:37:32 <Kekker_> took me a couple minutes
16:37:54 <geekosaur> so, in tis case, evaluation is driven by the guts of interact requesting and outputing charcters from the final string (aka list of Char) you produce. each time it requests a character, that forces just enough processing to read and evaluate enough input to produce that character
16:39:24 <geekosaur> if you do a strit patern match during the processing that forces more input to be read, you coud still end up reading the whole input first, or an entire line, or ... whatever your pattern match requires
16:40:45 <Kekker_> ok I think that makes sense
16:42:17 <geekosaur> (I recomend sticking to lines there, just because things get confusing if it's immediately outputting words as you type them. but that's why terminal-based programs generally default to line buffering
16:45:47 <geekosaur> well, that and line editing. bu that's then confused by fancy line editing like readline / editline / etc.; they use character mode but produce a line at a time because once it's been passed to your program it's too late to edit it)
16:47:02 <dmwit> You are asking how to walk.
16:47:16 <dmwit> One group wants to teach you by saying, "You know how you can run from A to B? Just do that, but slower.".
16:47:31 <dmwit> One group wants to teach you by grabbing your legs and forcing them into the correct motions for you.
16:47:46 <dmwit> One group wants to start by telling you how gravity works.
16:48:01 <dmwit> These are all bad in their own way. But none of them is as bad as all of them. So I took my dog for a walk. =)
16:48:10 <geekosaur> well, they did ask about laziness. in this case I think it's useful to know that lazy evaluatio is evaluation driven by need
16:48:44 <Kekker_> I learn much better by reading and understanding source code than I do from having my questions answered with questions
16:48:48 <geekosaur> I would not worry too much about mechanics, though, just reaize that any given oepration does only the minimum necessary, and its all driven by interact requesting individual characters from the result
16:49:46 <Kekker_> If I can see practical code and connect the dots, I grow to understand how it works and can use similar code in my own work. If I don't know how something works, and when I ask I'm told "well how do you think it works", I just get more confused
16:50:33 <geekosaur> and wen you "turn the crank" on a list you get the next element and an unevaluated rest-of-the-list, and turning the crank again does the same to that rest-of-the-list
16:50:56 <geekosaur> strings represented as lists of characters are fairly inefficient, but maximally "turn-the-crank" lazy
16:52:32 <Levy[m]> Kekker_: What do you exactly want to write? What's the goal of the program?
16:52:34 <geekosaur> (and provide the compiler a chance to compile the whole thing to a loop as tight as you'd get in C. and occasionally tighter because C has to allow for the possibility that the list can be modified from "outside"; Haskell can make it go away entirely in some cases)
16:54:05 <aplainzetakind> I want to parse certain lines (say, the ones beginning with an hyphen) in a file while skipping others (by parse I mean get the contents). I'm not sure how to do the "skip others" bit. I can't use <|> without actually returning something from the non-matching lines.
16:54:23 <aplainzetakind> ...using megaparsec.
16:54:26 <dmwit> Return Nothing or [].
16:54:32 <dmwit> Use Just or (:[]) on the matching lines.
16:55:03 <aplainzetakind> So I can't just discard stuff without bringing in Maybe?
16:55:23 <Kekker_> Levy[m]: It's character encoding. take the first line of input and build a binary tree filled with ASCII characters, then use the following lines to read from the tree and produce a sequence of letters
16:55:37 <geekosaur> sometimes you can rearrange things so that youi don't need to produce anything for the skips. it does make for difficult to read code in many cases though
16:55:47 <dmwit> Or write `foo = liftA2 (:) stuffICareAbout foo <|> (stuffIDon'tCareAbout *> foo)`.
16:56:05 <dmwit> uh
16:56:12 <dmwit> maybe include a `<|> pure []` in there. ;-)
16:57:06 <aplainzetakind> Actually I'm really looking for a stuffIDon'tCareAbout.
16:57:50 <dmwit> ...you still need to write a parser that describes what stuff you want to skip.
16:57:55 <aplainzetakind> Because I can just `do { x <- iCare; many iDon'tCare; pure x}` and `many` this.
16:58:25 <aplainzetakind> Is there a way to say "match anyline that doesn't match p"?
16:58:47 <aplainzetakind> s/anyline/any line/
16:59:44 <amalloy> aplainzetakind: anyChar `manyTill` newline?
17:00:08 <dmwit> aplainzetakind: With my proposed snippet, you can use "match any line" without the needing the extra "that doesn't match p" constraint.
17:00:08 <amalloy> like, you first try the parser p, and if that succeeds then great, you parse the line using iCare
17:01:33 <Levy[m]> Kekker_: so lines >>> split into binary tree and rest >>> join by using the tree to write encoded text. You can do that with three functions where the first is `lines`, second takes the head and builds a tree while then passing the tree and rest to the last function. Thus `lines : String -> [String]`, `encode : Tree -> [String] -> String`, and the glue function `treeEncode : [String] -> String`
17:01:41 <Levy[m]> or along those lines
17:02:20 <Levy[m]> s/:/::/ (been away from haskell land for too long it seems)
17:02:59 <aplainzetakind> OK, I may have a very wrong idea of how I will go about this, but my plan is to use a `ParsecT SomeError Text (State (Map Text Int)) a`, and insert the matches into a Map after each match.
17:03:40 <Kekker_> Yes, hololeap helped me out with that. I have a secondary main that calls a splitLines function that separates the first line of input from the rest and builds a tree from that, which is then passed into a lineIterator that maps each line of input to the decode function
17:04:04 <aplainzetakind> dmwit: Which makes me think writing a parser that will put everything into list is not very suitable.
17:04:52 <dmwit> It shouldn't really be hard to adapt my snippet to stuff it in the State instead of returning it.
17:05:04 <Levy[m]> Kekker_: so where are you now with it?
17:05:18 <Kekker_> I'm working on the decode function
17:05:19 <aplainzetakind> dmwit: Alright then, I'll try.
17:05:21 <aplainzetakind> Thanks.
17:05:51 <Ptival> is there a way to make HUnit unit tests based on files in the file system, such that their names reflect the file they are testing? The type of `testCase` forces us to commit to a name prior to running any IO. Even `withResource` gives us a handle to a `IO a` rather than the `a`, disallowing making one `testCase` per file
17:06:23 <Kekker_> I'm recursively building the output string in a similar way to how I built the binary tree. I'm returning the Leaf as an array of 1: "[c]", and if I come across a branch I'm performing decode on either a or b depending on the head of the input string
17:07:03 <Kekker_> I'll send the code when I'm done with it, since so many of you guys helped me out with it
17:07:03 <Levy[m]> List or Array?
17:07:11 <Kekker_> sorry, list
17:07:24 <Kekker_> does haskell actually have arrays?
17:07:33 <geekosaur> it does, in several forms
17:07:41 <dmwit> ?faq Can I make an array in Haskell?
17:07:41 <lambdabot> https://wiki.haskell.org/FAQ
17:07:45 <dmwit> awww
17:07:58 <dmwit> Yes, Haskell has arrays.
17:08:24 <Levy[m]> many different types of arrays
17:08:41 <Levy[m]> but that's for another day
17:08:51 <Kekker_> Yea
17:09:27 <geekosaur> yeh, worry about this first. understand laziness and how it changes how you do things
17:10:02 <Levy[m]> well, enough to get by. Fully understanding it takes a while
17:10:20 <geekosaur> then you can consider the ways different kinds of "spine-strict" representations change things
17:10:29 * Levy[m] wishes haskell had explicity Lazy annotation in types
17:10:41 <hpc> Levy[m]: it has the opposite :P
17:11:12 <Levy[m]> syntax is rather ugly though
17:12:23 <c_wraith> you don't want to require explicit lazy, since it messes up the defaults
17:13:31 <Kekker_> hm... I have it working for one character. I know why it doesn't grab the others, but I'm not sure how I'm going to do it
17:16:38 <Levy[m]> c_wraith: or reported it at least since there's many gotchas with it currently for beginners
17:17:36 <c_wraith> Levy[m], beginners have to learn something new. no way around that. but making laziness opt-in is basically the same as removing it.
17:18:17 <nh2> where do `library-stripping: False` or `debug-info: 3` have to go in my .cabal file? I can't find a place where cabal accepts them.
17:19:35 <Levy[m]> not opt-in, a visual hint instead. Tooling side could just be a certain colour or a change of font which is probably better since that doesn't touch haskell implementations directly
17:19:52 <c_wraith> nh2, don't those options go in cabal config? that's not something packages can control locally.
17:20:45 <nh2> c_wraith: hmm I feared that, looks like you're right
17:21:42 <c_wraith> Levy[m], hmm. ok, I don't mind that, but it's still something that would need to be annotated explicitly. best case, you'd still need a third state for "not documented"
17:22:59 <Kekker_> how would I reset my position on a binary tree if I'm traversing recursively
17:23:24 <c_wraith> You don't. you return the value and let the caller proceed.
17:23:49 <hpc> nh2: a good way to remember it is that the cabal file defines the package but not the environment it's built in
17:23:52 <Kekker_> hm.
17:23:57 <c_wraith> well, return the value and the new input state 
17:24:07 <Levy[m]> Guess I've been spoiled by semantic highlighting
17:24:34 <Levy[m]> see it once, wants it everywhere
17:24:35 <nh2> hpc: you could well argue though that the amount of debugging symbols is something you want to set per-package
17:25:33 <c_wraith> nh2, the package installer might want to set that per package. the package author should get no say.
17:25:45 <c_wraith> nh2, and cabal files come from the package author
17:28:27 <hpc> good build systems are hard to come by
17:28:44 <hpc> right now the state of the art is "you get the same package back the second time you build it"
17:29:04 --- mode: glguy set +v fooz
17:29:40 <fooz> hello! how can i state a type inequality constraint?
17:29:50 <geekosaur> manually
17:30:32 <c_wraith> it can be done, but seek other solutions.
17:30:37 <fooz> ie. `(a ~ Foo b) =>` constraints a to be equal to whatever `Foo b` is .. i want something which says "non equal"
17:30:51 <geekosaur> that is, you use a typeclass for type (in)equality and use it as a constraint. explicit type inequality requires the compiler to somehow know ahead of time things that can only be known at runtime
17:30:57 <c_wraith> like, if you're trying to use this to make an instance not overlap everything, it won't work anyway.
17:31:10 <fooz> ah, geekosaur that makes sense
17:31:53 <Solonarv> You can use a type family like 'type family NotEq (a :: k) (b :: k) :: Constraint where NotEq a a = TypeError <snip>; NotEq a b = ()'
17:31:59 <fooz> i'm trying to constraint a heterogeneous list to contain only one value of each type.. 
17:32:30 <fooz> Solonarv: oh, that looks promising!
17:32:40 <Solonarv> But that type family will just be stuck if its arguments are not known to be distinct, and stuck type families are really annoying.
17:32:43 <geekosaur> that sounds like a pain. there's a type-indexed map on hackage which should do essentially the same thing, though?
17:33:18 <fooz> hmm.. 
17:33:47 <geekosaur> tht said, if you're working wth something that specifically requires HList, this won't work
17:33:48 <fooz> it's not necessary for my work, i just thought it would be nice..
17:34:07 <fooz> no, i'm using tuples not hlist
17:34:48 <c_wraith> hlist is runtime-identical to nest tuples anyway. :)
17:35:00 <c_wraith> *nested
17:35:13 <fooz> oh, hah!
17:36:27 <hololeap> Kekker_: i was away, but to answer your question, yes it maps the function over each string in the list, but afterwards it calls `unlines :: [[Char]] -> [Char]` which takes a list of strings and joins them with '\n' into a single string
17:37:09 <fooz> is lpaste dead? :(
17:37:17 <c_wraith> yep :(
17:37:23 <hololeap> now that i think about it, lines and unlines sort of do the opposite of what they are named :p
17:37:51 <hololeap> but they are just convenience functions
17:38:06 <Kekker_> hololeap: Thank you! That was actually super helpful, I don't know why I was so obsessed with keeping main on one line
17:38:29 <Kekker_> everyone said "don't do one liners" and "try interact with a handler function" but for some reason that never stuck
17:39:13 <hololeap> Kekker_: yeah, don't be afraid to split things up into seperate functions. you can always play around with its brevity after you get it working
17:40:00 <Kekker_> I've actually got stringBuilder function split off, since I couldn't figure out how to concatenate each char into a list after finding it recursively
17:40:09 <Kekker_> Your example helped a lot with how I view my program
17:40:29 <c_wraith> in general, it's really hard to do everything at once.
17:40:39 <c_wraith> splitting into pieces is a really good idea
17:40:40 <hololeap> one of the nice things about haskell is that you can set up what it will eventually look like and fill in the gaps with `undefined`
17:41:04 <Kekker_> Yea. It's funny to think I haven't been looking at this purely functional programming language as a writing a bunch of functions
17:41:12 <hololeap> and then expand it step by step, calling the compiler to make sure it still type-checks
17:41:14 <Kekker_> it's been a lot of dots and lambdas and weird alien stuff
17:41:40 <hololeap> it takes some getting used to if you're used to telling the computer instructions
17:41:50 <Kekker_> Yea that also helps a lot hololeap. Using undefined just to check if my programs structure compiles helps a lot
17:54:13 <fooz> here's what i have for my heterogeneous list https://pastebin.com/L8h6kzqT
17:54:31 <fooz> the constraint i'm trying to write is the one in comments called `Without`
17:55:23 <fooz> i'm tempted to try Solonarv's type family to implement the constraint (by searching the list and asserting each type is non-equal to the needle)
17:55:49 <fooz> but perhaps this is one thing that is better left alone
17:56:56 <Solonarv> Yeah you don't need to assert that the types are unique
17:57:12 <amalloy> Kekker_: if you use _ instead of undefined, haskell will even help you fill in the hole
17:57:48 <Kekker_> Oh yea, I use that in Rust all the time
17:57:48 <fooz> seemed like it might prevent the creation of confusing lists (ones where the same type is consed in multiple times)
17:57:55 <Solonarv> also, you don't want {-# INCOHERENT #-}, you want {-# OVERLAPPABLE #-} (and/or {-# OVERLAPPING #-} on the other one
17:58:04 <hololeap> i love that haskell can smash concurrency and parallel computing problems with ease, but it's a super S++ mission to make a heterogeneous list
17:58:27 <fooz> this was actually really easy.. i made it yesterday in about 10 minutes
17:58:36 <Solonarv> I mean, it really isn't
17:58:39 <fooz> the S++ part is making it typesafe :P
17:58:56 <Kekker_> I have this almost working: https://pastebin.com/WACwaN0d
17:59:01 <hololeap> true
17:59:09 <Kekker_> stringBuilder hangs right before the last letter. Why is that?
17:59:25 <fooz> the fact that we can even discuss adding heterogenous lists and then "how to make them safe" all without modifying the language is pretty great :P
17:59:31 <Kekker_> so if it's supposed to output "ACE", it outputs "AC
17:59:39 <Kekker_> and then hangs
18:02:02 <hololeap> Kekker_: it's probably doing inifinite recursion somewhere...
18:02:14 <Kekker_> Yea that's what I figure, I'm just not sure why?
18:02:16 <geekosaur> I'd check the end logic you've split between stringBuilder and decode. get it wrong and it'll loop on the recursive case forever
18:02:36 <Kekker_> right yea, that's what I've been looking at. I'm just not seeing it
18:05:53 <amalloy> Kekker_: the implementation of decode looks a bit suspicious too
18:06:04 <amalloy> shouldn't line 33 return c?
18:06:34 <Kekker_> yes it should
18:06:36 <Kekker_> good catch
18:07:44 <Kekker_> and line 40 should've been i+1. With that it works
18:07:55 <Kekker_> Thank you, that was bugging the crap outta me
18:08:28 <Kekker_> I'm gonna run a few test cases, but I think this is working
18:09:03 <hololeap> Kekker_: there are less error-prone ways to write this without using counters, if you're interested
18:09:21 <hololeap> just with pattern matching
18:09:39 <hololeap> but let us know if you get it to work
18:10:03 <Kekker_> Yea I'm interested. I couldn't figure out how to cleanly drop the right amount of numbers from the input
18:10:46 <hololeap> well, one thing to keep in mind is that you can detect an empty string just with pattern matching. you don't have to make a comparison using its length
18:10:54 <Kekker_> cuz the input is something like "**B**DECA" for the tree, then "10110101" has to return "ACE". 101 is the code for A, and 01 is the code for E
18:11:10 <Kekker_> yes I can take out the if statement
18:11:28 <Kekker_> in stringBuilder right?
18:11:40 <hololeap> right
18:11:58 <fooz> Solonarv: where do i import Constraint from?
18:12:03 <Kekker_> wait no, that's not to detect an empty string, that's to make sure I don't try to drop more than the string has
18:12:15 <Kekker_> but I don't think that matters right? drop does that automaticaly?
18:12:17 <fooz> https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/constraint-kind.html doesn't mention it, though it uses Constraint
18:12:29 <hololeap> but also, decode could be the type :: Tree -> (Tree, [Char]) -> (Tree, [Char])
18:12:39 <Solonarv> I think it's in Data.Constraint or possibly Data.Kind
18:12:46 <hololeap> hold on...
18:12:53 <fooz> oooh, i missed that when i looked up base on hackage... ty
18:12:59 <hololeap> let me make sure i got that right...
18:13:11 <fooz> yup! Data.Kind .. ty!
18:13:25 <Kekker_> I'm not sure how nicely that would work with stringBuilder
18:14:08 <Kekker_> I added the counters just to drop from the input string. I want to make sure the tree starts from the beginning every time stringBuilder gets called
18:14:31 <hololeap> no, it would be :: Tree -> [Char] -> (Tree, [Char])
18:14:49 <hololeap> uh..
18:14:57 <Kekker_> am I making sense?
18:15:01 <hololeap> sorry, let me play with it for a second
18:15:05 <Kekker_> yea sure, go ahead
18:15:12 <Kekker_> I should probably comment my code better lol
18:15:20 <hololeap> in any case, you don't need an Int anywhere
18:15:53 <Kekker_> even for the drop?
18:19:05 <Kekker_> oh I could do :: Tree -> [Char] -> ([Char], [Char]) and return [c], [xs]
18:19:23 <hololeap> Kekker_: that's exactly what i was working on
18:19:32 <Kekker_> Ok yea that's much cleaner
18:22:08 <Kekker_> I just got infinite recursion when I tried that though
18:24:04 <maerwald> why do GHC compiled binaries on ubuntu/debian link to libnuma.so.1?
18:24:08 <fooz> ok, i don't know if i'll keep this but it's pretty neat.. now when you use a heterogeneous list `a` you just constraint it to `Has list Int` (if you're going to `get stuff :: Int`) or `Hasnt list Int` (if you're going to `cons` on an `Int`)
18:24:14 <fooz> thanks for your help!
18:27:25 <geekosaur> maerwald, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-flag---numa
18:35:14 <maerwald> geekosaur: I haven't set anything like that
18:35:39 <geekosaur> so the runtime rebuiilds itself based on your options?]
18:38:57 <geekosaur> NUMA requires rather more than "dynamically load some lib and make some magic calls". if this truly offends you, build a ghc without NUMA support
18:39:14 <hololeap> Kekker_: this is what i was thinking of, no idea if it works: https://pastebin.com/PPNUHV26
18:41:14 <Kekker_> hololeap: this is what I was working on: https://pastebin.com/eLbhYpw0
18:41:58 <Kekker_> I was thinking about passing the built string in the decode arguments, but I never got around to trying it. I might try that again
18:51:57 <Kekker_> ok I got it working without the counter. I'm gonna submit what I have, but I'll probably mess around with it more later
18:52:20 <Kekker_> Thanks everyone! I seriously could not have done this without you guys, this place is great
18:53:14 * hackage toodles 1.0.2 - Manage the TODO entries in your code  http://hackage.haskell.org/package/toodles-1.0.2 (aviaviavi)
18:53:57 <hololeap> Kekker_: i figured it out... you need to reference the original tree when you recurse after hitting a leaf, so a nested function is necessary: https://pastebin.com/zTwX8SC3
18:55:10 <hololeap> or maybe there is another way without it being nested?
18:55:19 <hololeap> nested is easier imo
18:55:23 <Kekker_> I actually got it working with this: https://pastebin.com/DVeQQ9rj
18:55:56 <Kekker_> That's what I'm submitting. It's still not as clean as it could be, but it's what I have
18:56:00 <hololeap> Kekker_: fyi, `null s` == `s == []`
18:56:09 <hololeap> nice
18:56:17 <Kekker_> oh, alright. good to know
18:56:19 <hololeap> it's a good first program
18:56:31 <Kekker_> thanks again for your help, I really really appreciate it
18:56:51 <Kekker_> It's a hard first program, but it definitely forced me to get down and dirty with the language
18:57:03 <Kekker_> even though the solution was simpler than I thought it would be
18:57:03 <hololeap> np :)
18:58:16 <maerwald> geekosaur: well, is it possible to disable it?
18:58:27 <maerwald> It breaks my busybox binaries
18:58:34 <geekosaur> by building a ghc without it
18:58:40 <maerwald> That's awful
18:58:51 <geekosaur> es, I supose yu shouldfile a "bug" so someone can teach you why it's not dynamic
18:59:27 <geekosaur> since your question mens you either ignored or did not understad what I said earlier
18:59:52 <jackdk> @type null
18:59:54 <lambdabot> Foldable t => t a -> Bool
19:00:00 <jackdk> @type (==[])
19:00:01 <lambdabot> Eq a => [a] -> Bool
19:00:36 <jackdk> hololeap: you can null on lists that don't have elements in Eq
19:00:45 <geekosaur> these days the point of null vs. ==[] is kinda lost since you're incurring a constraint regardless
19:01:49 <maerwald> geekosaur: I asked whether it's possible to disable without rebuilding, I have no idea why you react like that :)
19:02:07 <geekosaur> [11 02:38:34] <geekosaur> NUMA requires rather more than "dynamically load some lib and make some magic calls". if this truly offends you, build a ghc without NUMA support
19:02:18 <maerwald> Yes, I read that
19:02:25 <geekosaur> but it someow doesn't apply?
19:02:38 <maerwald> I asked whether rebuilding is the **only** way
19:02:54 <geekosaur> Iwould have mentoned one if there were
19:02:59 <maerwald> How would I know
19:03:29 <geekosaur> the best someone might do is that someone might arrange for -threaded=numa link option someday
19:03:52 <maerwald> So it seems the pre-built GHC bindists all have numa enabled
19:04:38 <maerwald> And then people install GHC and get those linker errors: https://github.com/haskell/ghcup/issues/58
19:05:21 <hololeap> jackdk: interesting point, but irrelevant in this case since we were talking about [Char]
19:05:51 <hololeap> but yeah, you are correct
19:11:26 <argent0> Hi, what is the the prefered regex library?
19:11:49 <argent0> there are regex-compat & regex-posix
19:12:53 <lyxia> have you considered using a parser combinator library like megaparsec instead
19:13:44 <argent0> lyxia: Yes, I use attoparsec, But I need them for quick and dirty hacks for the advent of code 2018
19:13:58 <lyxia> there's also regex-applicative that's somewhere in the middle (but quite more on the combinator-y side)
19:14:44 <lyxia> scanf for C-like format strings (I wrote that one) AFAICT that should cover most of the AoC problems
19:15:34 <lyxia> I've seen regex-tdfa being used by various packages but the standard regex API in Haskell is so confusing.
19:17:27 <argent0> lyxia: thanks I'll check them up. scanf looks nice
19:21:55 <celphi> https://www.irccloud.com/pastebin/ulyGxiyy/
19:22:20 <amalloy> argent0: i picked up regex-applicative for the simpler aoc input formats. it's nice because it has a similar API to parsec but is actually regular
19:25:43 <[Leary]> celphi: There's not much point in saying "I get an error" without saying what the error is.
19:26:01 <celphi> <interactive>:2:12: error: Data constructor not in scope: B :: Mood
19:26:02 <glguy> Why is actually being regular an advantage for AoC?
19:26:56 <amalloy> it's not
19:26:59 <[Leary]> celphi: Doesn't sound related to your `changeMood` declaration.
19:27:22 <celphi> What do you mean?
19:27:45 <celphi> That error is from doing changeMood B
19:27:45 <amalloy> i just like the idea of using as weak a parser as necessary. why use backtracking and a monad when an O(n) applicative solution exists?
19:27:56 <[Leary]> It's saying you're trying to use a constructor `B` of type `Mood`, but it doesn't know of any. I don't see that in your paste.
19:28:11 <glguy> amalloy: In the case of AoC I think the reason is that you don't know that a weak parser is all that is needed at the onset
19:28:15 <celphi> But isn't "_" a catch all?
19:28:41 <celphi> My book is saying _ is a catch all for pattern matching.
19:29:05 <amalloy> glguy: really? so far every time i've looked at an input file it's clear very quickly whether i need a powerful parser
19:29:18 <[Leary]> Trying to supply something that's not in scope or that doesn't type check will cause an error before the code ever attempts to pattern match.
19:29:23 <amalloy> if i were competing for leaderboard positions i'd just import parsec every time, but i'm not
19:29:47 <glguy> OK. I was looking at it from a speed point of view.
19:30:34 <celphi> I've copied the text from book. Please rea this and explainto me what it means then.
19:30:35 <celphi> https://wandbox.org/permlink/I6rSgdNwW50ewlQA
19:31:01 <celphi> Because it's saying _ should cover all inputs.
19:31:15 <glguy> All inputs of the correct type
19:31:22 <celphi> Oh.
19:31:32 <[Leary]> At runtime, yes. But if your code doesn't compile, then you never get to runtime.
19:32:33 <celphi> Thnx ppl. :)
19:41:21 <dmwit> glguy: Actually being regular can be an advantage if it means you don't have to think about whether you've done all the backtracking right in your parser.
19:43:12 <dmwit> glguy: e.g. I describe a parser on SO that accepts things like `foo-7a86cb8b-0987-fe40-61f2-42b0f6fc3e1c`, which has a UUID at the end... but also accepts `foo-bar-<UUID>`. https://stackoverflow.com/a/52558307/791604
19:43:24 <dmwit> I think that would be kind of hard to get right with other libraries.
19:43:58 <dmwit> (Although perhaps AoC shies away from "weird" grammars like that.)
19:45:40 <c_wraith> dmwit: lots of parsers have no trouble with ambiguous grammars.  :)
19:45:43 <glguy> ReadP would be happy to parse that
19:45:56 <dmwit> ReadP would be fine, yep. Maybe yoctoparsec, too.
19:46:01 <glguy> just as one of the parsers people have been using
19:46:06 <dmwit> But I think you'll agree those are not the libraries most people reach for first. =)
19:46:06 <c_wraith> Earley, uu-parsinglib
19:46:41 <dmwit> c_wraith: Also, this grammar isn't ambiguous...
19:46:48 <dmwit> (But yes, I take your point.)
19:47:01 <c_wraith> But so far, every problem can be parsed by mapping non-numeric characters to ' ' the using words :)
19:47:10 <c_wraith> *then
19:47:20 <c_wraith> oh, wait.  They were letters once.
19:47:44 <c_wraith> Had to do filter ((== 1) . length) . words.  :)
19:48:40 <glguy> c_wraith: and don't forget '-'
19:48:51 <c_wraith> I was pretending that was numeric.  >_>
19:48:51 <glguy> I know someone who lost time trying to filter input like that
19:49:34 <c_wraith> I lost a bunch of time on last night's forgetting the difference between "some" and "many".  (well, getting them backwards)
19:49:41 <c_wraith> There's no excuse for that.
19:52:58 <nshepperd> i've just used parsec every time so far, doing it the obvious way
19:53:08 <glguy> As a closing comment on the topic, I like using megaparsec (or things like it) because my biggest risk isn't too much power, it's that I'll implement the parser incorrectly. Getting the error message about where the line failed to parse helps me debug my parser
19:53:51 <nshepperd> i guess defining garbage = many (noneOf (['0'..'9'] ++ ['-'])) could save time per c_wraith's comment
19:53:59 <nshepperd> but i'm not really going for time
19:56:23 <nshepperd> i'm curious how people found the right t in #10 today
19:59:25 <c_wraith> nshepperd: I did it by just stepping the simulation.  But the match wasn't too hard to guess at it.
19:59:57 <c_wraith> you can calculate a time near the intersection pretty easily just by looking at when all the points will be near each other
20:04:20 <nshepperd> I did that, but I also guessed that gur fbyhgvba jbhyq nccrne jura gur ahzore bs begubtbanyyl nqwnprag cbvagf jnf uvtu
20:05:01 <glguy> V ybbxrq sbe obhaqvat obkrf gung jrer 20 be srjre ebjf gnyy
20:06:57 <nshepperd> oh, that makes sense
20:07:58 <c_wraith> I went even simpler, and was rewarded that the input wasn't set up to punish it.
20:08:25 <c_wraith> V sbhaq gur gvzr jvgu gur zvavzhz obhaqvat obk nern
20:08:37 <c_wraith> not guaranteed to work, but the input didn't punish it
20:09:42 <nshepperd> yeah, i was slightly worried about there being 'red herring' points that wouldn't be part of the picture
20:09:52 <nshepperd> google code jam always has those >_>
20:14:14 * argent0 after inspecting regex's in haskell. Will just pipe through grep.
20:21:51 <dmwit> You might also consider using one of the many excellent parser combinator libraries.
20:23:05 <argent0> dmwit: I do use them, just wanted something quick and dirty
20:23:43 <argent0> like: numbers = snd . partitionEithers . fmap (AP.parseOnly AP.decimal . T.pack) . DL.groupBy ((==) `on` isDigit)
20:24:20 <argent0> numbers :: Num a => String -> a
20:28:30 * lyxia has a feeling of déjà vu.
20:29:34 <lyxia> (see discussion 1h20 min ago)
20:54:43 --- mode: glguy set +v PatrickRobotham
21:11:14 * hackage appar 0.1.6 - A simple applicative parser  http://hackage.haskell.org/package/appar-0.1.6 (KazuYamamoto)
21:32:14 * hackage iproute 1.7.7 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.7.7 (KazuYamamoto)
22:31:25 <cocreature> argent0: regex-applicative can be a useful compromise
22:32:10 <dminuoso> Interesting, so it just occured to me that the IsString instance of ByteString requires knowledge about encoding.
22:32:11 <dminuoso> A quick glance of the code does not reveal what it does..
22:32:41 <cocreature> dminuoso: it has the usual Char8 behavior of silently truncating characters
22:32:46 <cocreature> which is … bad
22:35:09 <argent0> cocreature: I'll check it thanks
22:35:44 <dminuoso> cocreature: Ah heh. Yeah I realized that it couldn't possibly do the right thing without even trying.
22:36:19 <dminuoso> I guess there is no way to undo instances, is there? :)
22:36:19 <cocreature> I’m not sure there is even a “right thing” to do here
22:37:25 <dminuoso> Ah well, not without possibly breaing dependencies anyway.
22:38:13 <dminuoso> cocreature: Yeah that's my point.
22:39:43 <geekosaur> the "right thing" given Haskell instances is to banish it to a separate package, imo
22:40:40 <dminuoso> I wish I would fully understand why instances have to live in an open world.
22:41:10 <cocreature> that’s a better option but it can still screw you over if it ends up somewhere in your dependency tree
22:41:29 <geekosaur> because the compiler can't know what instances you create months or years after building the library
22:42:11 <geekosaur> and because there's necessarily a runtime component of some kind in at least the case of polymorphic recursion
22:42:34 <geekosaur> (e.g. a Show instance delegating to a different Show instance)
22:44:11 <dminuoso> geekosaur: But that's more related to type inference, is it not?
22:44:50 <dminuoso> I mean if instead of typeclasses we had explicit dictionaries that needed to be passed, then it would be controllable.
22:45:45 <geekosaur> not entirely. even with the implicit ones, there's IfCxt that can craft new ones on the fly. explicit ones would be even easier to (ab)use.
22:46:41 <geekosaur> to sure that helps any mroe after the fact
22:48:13 <geekosaur> you can have what you want if and only if you use whole-program compilation
22:49:34 <geekosaur> otherwise a later compilation can't reach backwards and change the result of an earlier one, or you must refuse creation of instances separately from the class so it can be closed
22:50:25 <geekosaur> seriously, every time you use deriving, you are relying on instances being open
22:51:29 <geekosaur> (it would be possible to add a system of closed instances, but closed type families are generally a more comprehensible solution there)
23:14:14 * hackage unliftio 0.2.9.0 - The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)  http://hackage.haskell.org/package/unliftio-0.2.9.0 (MichaelSnoyman)
23:34:23 <bahamas> hello. I have set the OverloadedStrings pragam in my file, but this line 'convertPyExpr expr = Left ("Expr " <> show expr <> " not supported yet")' causes this error "Couldn't match type ‘[Char]’ with ‘Text’" what am I doing wrong?
23:34:34 <bahamas> *pragma
23:36:59 <dminuoso> :t show
23:37:00 <lambdabot> Show a => a -> String
23:37:01 <dminuoso> bahamas: ^-
23:37:08 <dminuoso> So what happens is
23:37:10 <dminuoso> :t <>
23:37:12 <lambdabot> error: parse error on input ‘<>’
23:37:12 <dminuoso> :t (<>)
23:37:14 <lambdabot> Monoid m => m -> m -> m
23:37:28 <dminuoso> bahamas: Haskell infers that, based on the usage of `<>` the thing to the left and right must be the same type.
23:37:35 <dminuoso> The expression `show expr :: String`
23:38:18 <bahamas> dminuoso: I understand. it's because show returns a String. do I need to use Text.unpack . show?
23:38:49 <dminuoso> bahamas: Close, you need Text.pack.
23:39:07 <dminuoso> bahamas: Or depending on your usecase provide a pretty print function that directly produces Text.
23:45:21 --- mode: glguy set +v [exa]
23:45:24 <bahamas> dminuoso: thank you!
23:49:33 <bahamas> dminuoso: btw, are there any guidelines that would help me avoid this text/string mess as much as possible?
23:59:17 <tdammers> you can't avoid it entirely, but there are a few strategies that work reasonably well
