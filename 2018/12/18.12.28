01:10:03 <bor0> `Data.List.GroupBy` groups elements according to a predicate in a sequential order. is there a function that groups elements in n^2, i.e. compare each by each? I achieve this in another language by using (for i = 0; i < arr.length; i++) for (j = i + 1; j < arr.length; j++) if (predicate(i, j)...)
01:13:00 <bor0> or I guess I could build the array first and then `groupBy` on that
01:13:21 <marvin2> bor0 what is your input and expected output?
01:14:25 <bor0> I can give the full story. let's say I have a list of events, where each event has a start and end time. for sake of simplicity we can assume they are ordered by start time. I want to group events that have intersecting times (I have the predicate for this, `bookingsPredicate`)
01:15:07 <bor0> the reason for doing this is that when I render them I want to display the bars in full-width, so for elements that have intersecting times, if there are 2 such elements each will have width of 50%
01:15:16 <bor0> if I have them grouped, I can determine their respective width
01:15:35 <bor0> sequential grouping is not enough for this. I need to compare them each by each
01:16:24 <bor0> (or somehow transform this list before `groupBy`-ing it :))
01:18:35 <marvin2> what if one timestamp intersects with several?
01:18:37 <bor0> (the reason why sequential grouping doesn't work is that if element 1 and 2 have intersecting times, and element 1 and 3 also have that, I need 2 groups: [1, 2], [1, 3])
01:18:43 <bor0> exactly!
01:18:58 <bor0> I need all possible such intersections
01:20:49 <bor0> cartesian product won't work since another valid group is: [1, 2, 3], [1, 4]. I have written a for loop in javascript but it looks too messy. I want to look at the Haskell code and try to make the JS code more elegant maybe
01:22:08 <amalloy> i think you need more than N^2 work to find this, because you don't just want pairs of items
01:24:02 <bor0> I have something like this: let ret = []; for (i = 0; i < arr.length; i++) { let tmp = []; for (j = i + 1; j < arr.length; j++) { if (predicate(i, j)) tmp.push(...) } ret.push(tmp);
01:24:09 <bor0> it seems to produce expected results unless I'm missing something
01:26:47 <amalloy> that algorithm would never produce [[1,2,3], [1,4]], as far as i can tell
01:34:04 <bor0> sorry, my bad. I don't think [[1, 2, 3], [1, 4]] is a valid case. the intersection should be disjunctive, so [1,2,3,4] would be valid even if 3 and 4 don't have intersecting times
01:34:17 <bor0> (but 1 and 4 do e.g.)
01:36:14 <bor0> no, that's wrong. my reasoning is flawed and that algorithm is broken. I just saw it break in action
01:37:33 <bor0> https://cloudup.com/cw-BOL_P1sm the most-left bar should be above the most-right, each having width of 33% instead of 25%. I knew just chatting about this in #haskell would be useful, so thank you already :)
01:37:59 <bor0> so now I need to take a step back. instead of making it more elegant I should fix it
03:22:54 --- mode: glguy set +v mreh
03:23:19 --- mode: glguy set -v mreh
03:30:07 <mreh> how are you supposed to handle `UserInterrupt` when you want to use something like `bracket`?
03:30:37 <merijn> mreh: I'm not sure what you mean by "supposed to"? As in "how can you handle it"?
03:31:18 <mreh> `bracket` masks exceptions, so I get a 10s long delay until the thread gets killed by the kernel after hitting Ctrl-C once
03:31:24 <Ariakenom> I want to divide 2 bit sequences streamingly, producing partial results lazily. Does anyone have a good resource or something?
03:31:35 <merijn> mreh: bracket only masks exceptions in the allocation
03:31:43 <Ariakenom> and cleanup
03:31:46 <merijn> mreh: You should *not* be doing long operations in the allocation
03:32:20 <mreh> ah... I'm opening up an acid-state database
03:32:33 <merijn> mreh: Safe resource deallocation or quick responses to user interrupts. Pick one.
03:32:42 <mreh> maybe it's something to do with ghcid
03:33:14 <mreh> it's like the `UserInterrupt` never reaches my thread
03:33:25 <merijn> mreh: I used to like acid-state, but it's recently been pointed out to me that it's not actually ACID, so I would recommend "not using it" :)
03:33:41 <merijn> mreh: Once the main thread exits all other threads are terminated
03:33:45 <butterthebuddha> How do I write a function of type (a1 -> a2 -> a3) -> (a1 -> a2 -> IO a3)
03:34:13 <butterthebuddha> but for any number of arugments
03:34:14 <merijn> butterthebuddha: eh, take the existing function, apply it, then use return? :)
03:34:15 <mreh> merijn, it's not? what would you use?
03:34:17 <butterthebuddha> arguments*
03:35:02 <merijn> mreh: Lemme check if I can find the link
03:35:17 <mreh> _Lemmih_ check?
03:35:27 <ski> butterthebuddha : how many arguments does `id' take ? or `const' ?
03:35:39 <butterthebuddha> 1
03:35:50 <ski> > id id 2
03:35:51 <butterthebuddha> const takes 2
03:35:52 <lambdabot>  2
03:35:58 <merijn> mreh: https://github.com/acid-state/acid-state/issues/79
03:36:07 <ski> > const const 0 1 2
03:36:09 <lambdabot>  1
03:36:13 <ski> how about `foldr' ?
03:36:20 <butterthebuddha> :t foldr
03:36:21 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
03:36:24 <butterthebuddha> 3
03:36:49 <merijn> mreh: So crashes can leave the data in unrecoverable state, which is like the opposite of what ACID's supposed to mean >.>
03:37:04 <mreh> merijn, maybe I should use persistent?
03:37:07 <ski> > foldr (\n k acc -> acc : k (acc + n)) (\acc -> [acc]) [1,2,3,4] 0
03:37:09 <lambdabot>  [0,1,3,6,10]
03:37:09 <merijn> mreh: As for what to use, it depends what kinda data are you storing and how much of it?
03:37:25 <mreh> merijn, quite a lot of data
03:37:26 <cocreature> merijn: just adding ACID to your library name automatically makes your code ACID-compliant!
03:37:48 <ski> butterthebuddha : in each of these cases, you can only say a minimum number of arguments that a function expects. "the number of arguments of a function" is not a well-defined concept
03:37:53 <merijn> mreh: I'm using persistent right now, because I originally wrote this code with it an migrating away is too much hassle. But in hindsight I'm not sure persistent's been worth the hassle
03:37:59 <merijn> mreh: What is "quite a lot"?
03:38:25 <merijn> megabytes? hundreds of megabytes? gigabytes? hundreds of gigabytes?
03:38:27 <ski> butterthebuddha : in fact, you can partially apply a function that returns a function, so you can even call it with less than "the minimum number of expected arguments"
03:38:54 <mreh> merijn, gigs probably
03:39:14 <merijn> mreh: I wouldn't store gigabytes worth of data in acid-state ven if it worked, tbh
03:39:42 <mreh> I was thinking acid-state plus a few blobs on disk
03:40:09 <merijn> mreh: My goto default database recommendation is SQLite. At the point you reach gigabytes of data I'd *start* (note: start) to consider postgres, anything much bigger postgres.
03:40:25 <merijn> mreh: Right, so how much data did you plan to keep in the database?
03:40:26 <mreh> merijn, mySQL?
03:40:35 <merijn> mreh: I would never consider mySQL, tbh :p
03:40:53 <merijn> As far as SQL databases go it's either SQLite or postgres :p
03:42:03 <mreh> I'm beginning to wonder why I went with Haskell, it's taken me a long time to get a backend going
03:42:24 <mreh> obviously there are established frameworks, and I'm working in rather new territory
03:42:37 <mreh> established frameworks in other languages that is
03:42:40 <merijn> mreh: What are you working on?
03:43:13 <mreh> a web service, front-end built it TypeScript and the backend API is being built in Haskell
03:43:44 <mreh> I've got servant working with a simple database that is stored in an IORef, but now I'm working on persisting that data
03:44:36 <merijn> mreh: For a quick prototype I'd just use SQLite (no setup, overhead, etc.) and should be easy enough to migrate to postgres later
03:45:02 <mreh> how do you handle migrations?
03:45:28 <merijn> mreh: You mean across schema versions? Or?
03:45:41 <mreh> merijn, yeah across schema versions
03:46:52 <merijn> Right now I'm using persistent's stuff combined with just some manual code, but as I said I would probably not use persistent again unless I was doing really simple things (like storing simple records and never needing joins). Next time I'd probably use sqlite-simple and write manual migrations, tbh
03:47:29 <mreh> sqlite is attractive, no need for a separate service to run a DBMS
03:47:58 <merijn> mreh: Hence why it's my default choice :p
03:48:14 <mreh> I can mount the data directory on a volume in a container
03:48:20 <mreh> very nice
03:49:00 <merijn> mreh: Also works nice as an "application specific file format", plus the ability to "migrate" a database between machines by just FTP/SCPing a file is nice
03:53:34 <statusbot> Maintenance update: restarting hackage-server *now* -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5c260e2e3b2cea04b1356532
04:01:22 <mreh> Selda looks nice as a high level binding, and includes Postgres support too
04:04:17 <merijn> Yeah, I've been looking at Selda too, but haven't used it yet, so I can't say how well it holds up
04:05:10 <butterthebuddha> ski: sure, all I want to do is write a function of type (a1 -> ... -> an) -> a1 -> ... -> IO an
04:05:18 <butterthebuddha> without necessarily knowing what n is
04:05:29 <merijn> butterthebuddha: That's hard
04:05:42 <butterthebuddha> Which is why I am here
04:05:49 <merijn> butterthebuddha: You can kinda do it if you're willing to enable a bunch of extensions and resort to type hackery
04:05:57 <butterthebuddha> I am
04:05:59 <merijn> But I'm not sure it'll be robust
04:06:05 <ski> my point was that given the type of a function, you can't always define "the number of arguments" in a meaningful way
04:06:45 <merijn> Also, you need to be happy to accept only return values which are not functions
04:06:55 <ski> the basic problem is polymorphism, where the result type of a function is a type variable (or a type variable applied to some type(s))
04:07:58 <ski> yes, i can imagine that people would sometimes want to use `(a1 -> a2 -> a3) -> (a1 -> IO (a2 -> a3))'
04:11:39 --- mode: glguy set +v bacoco
04:12:45 --- mode: glguy set +v PatrickRobotham
04:20:20 <nan`> what is the best way to debug a segfault in haskell?
04:20:33 <reactormonk> nan`, doing FFI?
04:20:43 <nan`> reactormonk: no
04:21:00 <hc> 2 /win 26     /win 26
04:21:02 <hc> oops
04:21:24 <nan`> can i use gdb?
04:21:41 <merijn> nan`: Yes, no, maybe
04:21:53 <merijn> nan`: If it's segfaulting in the RTS you can get useful info from gdb
04:22:15 <merijn> nan`: If it's crashing in Haskell code...that's not going to be very helpful
04:22:57 <nan`> well gdb says "File format not recognized" even though the file command says i have a 64-bit mach-o
04:23:16 <merijn> nan`: How did you get that GDB?
04:23:20 <nan`> macports
04:23:21 <nan`> haw
04:23:30 <nan`> it's a 64-bit gdb
04:23:51 <merijn> nan`: Mainline gdb doesn't support macOS, so I'm not sure if macport has the right patches to understand things
04:24:25 <nan`> merijn: ok thanks
04:25:20 <nan`> hm
04:25:34 <merijn> nan`: You should have lldb installed, though
04:25:35 <nan`> something said if i enable profiling i can get a stack?
04:25:48 <merijn> nan`: No, stack traces are generated by the RTS
04:25:57 <merijn> nan`: segfaults are the OS killing your process
04:26:08 <nan`> RTS = runtime system?
04:26:10 <merijn> Yeah
04:26:17 <nan`> hm
04:26:42 <merijn> nan`: I would first grep the entire codebase for any foreign imports and any use off nullPtr
04:26:55 <merijn> nan`: You must have some clue where it's segfaulting
04:27:44 <nan`> it's near json filesystem read/write i thnk
04:27:51 <nan`> this is development mode of snap framework
04:28:28 <merijn> hmm
04:28:34 <nan`> so it's in interpreted haskell
04:30:33 <nan`> am reading https://wiki.haskell.org/Debugging
04:32:10 <Ariakenom> anyone know why Bits have Eq superclass?
04:34:06 <[exa]> meh, hackage is giving 502 bad gateway?
04:34:54 <Ariakenom> [exa]: https://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5c260e2e3b2cea04b1356532
04:35:08 <c_wraith> [exa]: now it's giving a 503!
04:35:22 <Ariakenom> I'm using stackage for a bit
04:35:57 <c_wraith> Ariakenom: my best guess it that Bits gives you enough tools to implement (==) bitwise anyway, so they figured it might as well have Eq as a superclass
04:36:20 <c_wraith> That's why Traversable has Functor and Foldable as superclasses
04:39:45 <Ariakenom> c_wraith: ok, I'll throw in an empty Eq instance :p
04:42:59 <merijn> Ariakenom: Why can't you make an Eq instance?
04:44:57 <Ariakenom> merijn: I should be able to, just haven't figured it out. It's a repeating bit sequence at the end and I represent it with an infinite list.
04:45:08 <Ariakenom> rotate probably won't make sense though
04:45:45 <Ariakenom> I can gist in a minute
04:46:46 <Ariakenom> there are a lot of methods in the minimal complete definition for Bit
04:55:27 <Ariakenom> shouldn't popCount be deprecated like bitSize?
04:56:40 <Ariakenom> % popCount (-1::Integer) -- what is this, C?
04:56:40 <yahb> Ariakenom: -1
04:57:11 <c_wraith> That's a fascinating result.
04:57:35 <c_wraith> % popCount (-5::Integer) -- what is this, C?
04:57:36 <yahb> c_wraith: -2
04:57:42 <c_wraith> ok, I see what it's doing.
04:57:44 <c_wraith> cute.
04:59:19 <Ariakenom> % popCount (-2 :: Integer) -- but wrong
04:59:19 <yahb> Ariakenom: -1
04:59:48 <c_wraith> That's perfectly consistent
04:59:48 <merijn> Ariakenom: Wrong by which definition?
05:00:02 <merijn> "not my expectation" != wrong
05:00:22 <c_wraith> It's popCount x | x <  0 = negate (popCount (negate x))
05:00:40 <c_wraith> I'm not sure that's especially useful, but at least it's well-defined
05:00:57 <Ariakenom> oh, thought it was no of zeroes
05:02:03 <Ariakenom> https://gist.github.com/Ariakenom/06c9c04c4e6218f2d4feffe5841edc30
05:02:18 <Ariakenom> ^ Fractional and Bits
05:02:29 <ski> if there's a finite number of `1's (in the twos complement representation), and an infinite number of `0's, then it gives the number of `1's. if there's an infinite number of `1's, and a finite number of `0's, then it gives negative the number of `0's. conceptually, one might think of it as giving `-n' instead of `positiveInfinity - n'
05:03:05 <Ariakenom> ski: no -1 has zero but it answered -1
05:05:30 <ski> i stand corrected. i suppose it's actually looking at the two's complement representation of `n-1', in case `n' is negative ? hmm
05:05:41 <ski> or is there a better way of thinking about it ?
05:05:52 <c_wraith> ski: my suggestion?
05:06:03 <c_wraith> ie, pretend negative numbers don't exist
05:06:13 <ski> yea, that works
05:06:49 <ski> i'm just pondering whether what i said was completely useless, or whether one could repair it
05:07:11 <Ariakenom> my gist has a fun number type that has Bits and Fractional. Fractional is exact except you can't divide by powers of 2
05:07:56 <Ariakenom> the Bit instance works as normal for integers, except for some undefined methods
05:13:19 <ski> ok, now i see. i think if you replace "twos complement" by "ones complement" in what i said, then it works out, and is simpler than talking about `n-1'
05:13:58 <ski> however, "ones complement" is not as nice as "twos complement", so that's still an argument not in favor of this viewpoint
05:14:44 <Ariakenom> yes, is there rationale somewhere? the report?
05:15:05 <c_wraith> I don't think Bits is in the report
05:15:26 <ski> (now i'm wondering whether the actual behaviour of `popCount' would be more useful than what i described initially (in terms of twos complement), or vice versa. or perhaps there would be another behaviour which would be more useful)
05:17:53 <Ariakenom> for my case either can be infinite
05:18:28 <ski> either what can be infinite ?
05:19:58 <Ariakenom> either definition of popCount
05:22:11 <ski> so you're allowing any infinite sequence of bits ?
05:22:53 <Ariakenom> yes. there's a repeating pattern to the "left"
05:23:31 <Ariakenom> you can load it into ghci if you want https://gist.github.com/Ariakenom/06c9c04c4e6218f2d4feffe5841edc30
05:24:10 <Ariakenom> the bad show instance is the first 15 bits. "default (Dyad)" is convenient
05:24:12 <ski> oh, so only sequences which eventually repeat a (positive length) sequences of bits, as you move in the direction of more significant bits ?
05:25:39 <ph88> docs down?  https://hackage.haskell.org/package/process/docs/System-Process.html 
05:25:41 <Ariakenom> they can repeat 0 for naturals, 1 for negative integers, a finite sequence for fractions
05:26:00 <ski> ok, so since `repeat 1' represents `-1', `cycle [1,0]' represents `-1/3', right ?
05:26:07 <Ariakenom> ph88: yup https://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5c260e2e3b2cea04b1356532
05:26:50 <Ariakenom> ski: yup
05:27:04 <ph88> looks professional :P
05:27:47 <Ariakenom> ph88: statusbot linked that a while ago, it's all I know
05:28:30 <Ariakenom> ski: I should be able to track the finite sequence instead of using an infinite list like now, but I don't
05:28:48 * ski nods
05:29:08 <Ariakenom> so I can't Eq or do a nice Show
05:29:58 <ski> well, it might be nice if `Show' printed it in a fraction form, like `-1/3' above
05:30:10 <Ariakenom> exactly
05:30:38 <[Leary]> ph88: If you're lucky you have local haddocks hidden away in your system; you can find them with e.g. ghc-pkg field --simple-output base haddock-html
05:31:04 <ph88> we are all lucky to have stackage :P
05:31:08 <Solonarv> You could change it to be a pair of (starting bits, repeating part)
05:31:09 <ph88> https://www.stackage.org/haddock/lts-13.0/process-1.6.3.0/System-Process.html
05:31:48 * ski . o O ( subtype vs. quotient type )
05:31:51 <Ariakenom> Solonarv: yes, but I need to change the operations to keep track of them
05:32:08 <Solonarv> Well, yes, and change the operations appropriately
05:32:38 <ski> i suspect that having an infinite sequence, together with a proof of eventual repetition, in say Agda, would be nicer to work with
05:32:42 <Solonarv> (and don't use the standard lazy list; instead use a spine-strict list, because it must be finite)
05:33:01 <ski> perhaps you could store an infinite list, plus an offset and a repeat length
05:33:44 <Ariakenom> Solonarv: if I should change the representation it should be to something ByteString like
05:33:53 <ski> that way, you could compute with the infinite list as you alread do, just you also have to keep track of the offset and the repetition length
05:34:36 <Ariakenom> ski: interesting, that does have some nice laziness properties
05:34:49 <ski> then, one'd have to decide whether to always normalize/canonicalize the representation, or only do it when necessary
05:35:08 <ski> it's have to be an abstract data type in any case
05:40:24 --- mode: glguy set +v Mouse_
05:41:28 <ph88> i'm trying to run cmake as subprocess for some reason it's not working in the same way as i manually call it from the command line https://bpaste.net/show/985ec790661c
05:43:07 <mtesseract> ph88: Just a guess: shouldn't ,"-G \"Unix Makefiles\"" actually be written as two distinct parameters?
05:43:27 <ph88> that could be ye
05:44:46 <ph88> mtesseract, i tried your suggestion as separate parameters .. seems to give the same error
05:45:05 <mtesseract> can you update the pastebin?
05:45:07 <ski> Ariakenom : ty
05:46:31 <ph88> mtesseract, https://bpaste.net/show/faa8811568a7
05:46:33 <Ariakenom> ski: it lets you write bit swap for arbitrary length
05:46:35 <Ariakenom> bitSwap x = (((-1/3) .&. x) `shiftL` 1) .|. (((-2/3) .&. x) `shiftR` 1)
05:48:13 <ski> hm, so applying a permutation over a finite (non-empty) set, repeatedly on successive chunks of bits
05:48:36 <Ariakenom> usually the -1/3 constant changes depending on int32 or int64 etc
05:48:59 <ski> now i'm pondering notions of finite expression of permutations over `Nat'
05:49:18 <mtesseract> ph88: I think ..., "-G", "Unix Makefiles" would be more correct.
05:49:28 <ph88> ok
05:49:42 <ski> (the simplest of would just be to have the permutation be the identity on all but finitely many points)
05:50:26 <ph88> thank you mtesseract it worked <3 <3 <3
05:51:14 <mtesseract> ph88: Nice. That is due to the fact that the quotation marks you used here are parsed and interpreted by the shell (in the working setup), but they are not passed to the child process.
05:51:49 <ph88> i also had to remove the other quotes in the -B and -H flags
05:52:25 <ph88> btw how do i detect if i'm on linux windows or mac ?
05:54:22 <Solonarv> You can do it at compile-time using CPP
05:54:33 <Solonarv> I don't remember the exact name of the macro
05:54:45 <ph88> Setup.hs is already on compile time ..
05:55:31 --- mode: glguy set +v bo
05:55:32 <Solonarv> Hm. There's probably something in the Cabal library.
05:55:37 <bo> Hello, lads, can someone explain how I can verify that list has exactly 10 elements? Problem with 'length' is that the list can be infinite
05:56:21 <ski> bo : `length (take 11 xs) == 10' ?
05:56:41 <ski> or perhaps use `genericLength' with `Nat'
05:56:59 <ph88> Solonarv, i found this https://www.stackage.org/haddock/lts-13.0/base-4.12.0.0/System-Info.html
05:57:43 <Solonarv> that should work, though it doesn't seem to document which value indicates which OS.
05:59:49 <mtesseract> +bo: Alternatively: null . drop 10
06:00:38 <ph88> Solonarv, well i can tell you on linux it's linux :P
06:00:50 <bo> ski: thanks, but unfortunately that doesn't seem right... I'm given some list (of unknown length) and I should validate it only if it contains exactly 10 elements, no more, no less. If it does, False is to be returned
06:02:02 <Solonarv> @let hasLength xs i = length (take (i+1) xs) == i
06:02:03 <lambdabot>  Defined.
06:02:13 <Solonarv> > [1..9] `hasLength` 10
06:02:16 <lambdabot>  False
06:02:24 <Solonarv> > [1..10] `hasLength` 10
06:02:24 <ski> > genericLength [0 ..] == (10 :: Nat)
06:02:26 <lambdabot>  True
06:02:27 <lambdabot>  False
06:02:33 <ski> heh
06:02:34 <ski> > genericLength [0 ..] == (10 :: Nat)
06:02:36 <lambdabot>  False
06:02:54 <Solonarv> > [1..] `hasLength` 10
06:02:56 <lambdabot>  False
06:03:05 <ski> bo ^
06:03:06 <bo> Thanks, lads, will now try to understand the samples
06:03:20 <bo> solonarv, thanks, this seems to be the one
06:03:53 <bo> [1..] `hasLength` 10
06:04:00 <bo> > [1..] `hasLength` 10
06:04:00 <ski> you need the `> '
06:04:02 <lambdabot>  False
06:04:08 <Tuplanolla> > [] `hasLength` maxBound
06:04:10 <lambdabot>  False
06:04:14 <bo> Oh, ok, thanks
06:04:15 <ski> > genericLength [0 .. 9] == (10 :: Nat)
06:04:17 <lambdabot>  True
06:04:19 <ski> > genericLength [0 .. 8] == (10 :: Nat)
06:04:21 <lambdabot>  False
06:04:22 <ski> > genericLength [0 .. 10] == (10 :: Nat)
06:04:24 <lambdabot>  False
06:05:29 <ski> > 0 < (let inf :: Nat; inf = 1 + inf in inf)
06:05:31 <lambdabot>  True
06:06:50 <bo> Oooooh, I got it! 'length (take 10 list) == 10' implies that if it has less, the length will be < 10! Good thinking, thanks :)
06:07:15 <ski> yes
06:07:22 <[Leary]> > 0 < let omega :: Nat; omega = omega + 1 in omega
06:07:25 <lambdabot>  *Exception: <<loop>>
06:07:29 <bo> I can combine that with drop 10 list == [] to verify that it has no more than 10 elements
06:07:38 <Solonarv> it needs to be 'take 11', actually
06:07:39 <ski> but if it has more than ten, then `length (take 10 list)' will still be `10'. hence i used `11'
06:07:47 <[Leary]> Heh, GHC knows omega + 1 /= 1 + omega.
06:07:58 <ski> [Leary] : noncommutative addition, yay :)
06:08:34 <ski> bo : i suppose you could do it that way, as well
06:09:00 <bo> Yes, yes, 11, correct! Damn these infinite lists, breaking my brains since... Last week :)
06:09:21 <ski> @quote is.the.solution
06:09:21 <lambdabot> quicksilver says: head-explosion is the solution, not the problem.
06:10:18 <locallycompact> Is hackage down for everyone? 502 http://hackage.haskell.org/
06:10:35 <ski> > let omega :: Nat; omega = omega + 1 in omega + 1 /= 1 + omega  -- [Leary], i suppose it doesn't actually know
06:10:38 <lambdabot>  *Exception: <<loop>>
06:10:41 <_deepfire> locallycompact: it is for me
06:10:49 <Tuplanolla> > replicate maxBound () `hasLength` maxBound -- This is `False` even though it should be `True`, Solonarv.
06:10:51 <lambdabot>  False
06:11:03 <merijn> locallycompact: THere was an announcement about an update this morning which was taking longer than expected
06:11:17 <ski> Tuplanolla : good point
06:11:20 <_deepfire> https://downforeveryoneorjustme.com/hackage.haskell.org
06:11:35 <Tuplanolla> Always avoid arithmetic if you can.
06:13:21 <ski> bo : so it seems your variant, using `drop' as well, is better
06:13:38 <ph88> is there a Bool monad that stops when False is returned ?
06:13:39 <ski> (bo : you could use `splitAt', though, and `null' instead of `== []')
06:14:09 <ski> ph88 : maybe you're thinking of `Maybe' ?
06:14:19 <bo> ski: thanks, reading about 'splitAt' now...
06:14:20 <ski> (`Maybe ()' is basically `Bool')
06:14:27 <ph88> ok i'll use that then
06:14:34 <ph88> so Maybe monad stops at Nothing ?
06:14:50 <julianleviston> yeah it kind of has to....
06:14:57 <ski> bo : `splitAt' does `take' and `drop' in one go, only traversing the list once. if you want to do both (with the same index/cutofF) on the same list, you probably want to use `splitAt' instead
06:16:07 <ski> ph88 : that's it's raison d'être
06:16:13 <ph88> sounds like something Chuck Norris could do
06:18:36 <bo> ski: right! I can split a list at 10 and if it's infinite, the tail will be > []. If it's shorter, the head will be less than 10 elements. Once again, excellent thinking, this seems to be what i want, thanks!
06:21:44 <JSharp> looks like Hackage is down/unavailable - but the error message recently changed to an under maintenance message / so it's probably already being handled :)
06:21:55 <JSharp> does anyone have any more information?
06:22:12 <ph88> what if i want to mix IO monad and Maybe monad ?
06:22:34 <mtesseract> ph88: You can use monad transformers.
06:22:49 <ski> bo : just to be clear, don't use `== []' or `> []', since those requires having `Eq' or even `Ord' on elements. use `null' (or direct pattern-matching)
06:23:18 <ski> ph88 : use `MaybeT IO'
06:23:56 <bo> ski: oh, ok, got it. I'm reading 'Learnyouahaskell' and haven't gotten to 'null's yet
06:24:11 <ski> (in some circumstances, it may be better to use `IO' exceptions. but if not, then you probably want `MaybeT IO' or `ExceptT MyErrorCondition IO')
06:24:17 <ski> @src null
06:24:17 <lambdabot> null []    = True
06:24:17 <lambdabot> null (_:_) = False
06:24:38 <ski> bo : it just pattern-matches on a list, to check whether it's the empty list, or has at least one element (iow, is a non-empty list)
06:26:23 <ski> bo : otoh `==' on lists requires elements to be comparable for equality, and `>' requires them to be comparable for ordering, even if you pass an empty list as one argument. so using those will require more than is actually needed in this case. hence use `null' (or direct pattern-matching, which is also fine, if it doesn't clutter up your code too much)
06:27:03 <ski> (of course, if you know that your element type already has equality, or ordering, then it doesn't matter. but it may be useful to set up the habit of using `null' or pattern-matching anyway)
06:29:23 <bo> I think I understand, but not sure, TBH. Just struggling with understanding pattern matching, actually. You refer to this? f (x:[])
06:29:50 <bo> I probably don't know enough yet to understand what I don't understand :D
06:31:41 <ski> when you define a function by one or more defining equations, like
06:32:14 <ski>   add2DPoint (x0,y0) (x1,y1) = (x0 + x1,y0 + y1)
06:32:24 <ski> or
06:32:53 <ski>   isOrdered [        ] = True
06:33:06 <ski>   isOrdered [x       ] = True
06:33:11 <statusbot> Maintenance update: hackage update took a little longer than expected (compacting state). finished now! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5c260e2e3b2cea04b1356532
06:33:23 <ski>   isOrdered (x0:x1:xs) = x0 <= x1 && isOrdered (x1:xs)
06:33:33 <ski> you're using pattern-matching
06:33:47 <ski> also in a simpler example, like
06:33:51 <ski>  not False = True
06:33:54 <ski>   not True  = False
06:34:47 <ski> to the left of the `=' sign in a defining equation of a function, you first have the name of the function being defined, followed by one or more patterns, (possibly) matching arguments
06:35:07 <bo> I think i got it now
06:35:17 <ski> the pattern `[x]' above is the same as the pattern `x:[]'
06:35:19 <statusbot> Maintenance update: Hackage is operational again! Sorry for the extended delay. -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5c260e2e3b2cea04b1356532
06:35:49 <ski> if you define something like
06:35:58 <ski>   rotateList n xs = back ++ front
06:36:00 <ski>     where
06:36:06 <ski>     (front,back) = splitAt n xs
06:36:40 <ski> then `(front,back)' here is also a pattern. in this case we're deconstructing / taking apart, the single result computed by the call to `splitAt'
06:37:11 <bo> Ok, so what you said to me is 'don't use' if list == [] return false', but do it f [] = False?
06:37:18 <ski> in the `add2DPoint',`isOrdered' cases above, we're taking apart the input arguments to the respective function
06:37:19 --- mode: glguy set +v misterjaaaz
06:37:50 <ski> bo : well, if you define a helper function `f' to do that, sure
06:38:01 <ski> but you don't have to do that, since `null' is already defined for you
06:38:06 <ph88> ski, i only know about Just or Nothing after running IO .. so i think i need type IO Maybe
06:38:20 <bo> Alright, i got it! Thanks :)
06:38:34 <ski> bo : anyway, you could also write an expression
06:38:38 <ski>   case list of
06:38:47 <ski>     [  ] -> ...
06:38:51 <ski>     x:xs -> ...
06:39:06 <ski> that will check whether `list' is an empty list or not
06:39:14 <ski> that's also pattern-matching
06:39:15 <bo> Didn't get to cases yet... Trying to fully understand guards first :)
06:39:31 <ski> the above definition of `isOrdered' is equivalent to
06:39:48 <ski>   isOrdered xs0 = case xs0 of
06:39:58 <ski>     [      ] -> True
06:40:06 <ski>     [x     ] -> True
06:40:16 <ski>     x0:x1:xs -> x0 <= x1 && isOrdered (x1:xs)
06:40:51 <ski> however, if you can move pattern-matching from a `case' to "the left of `='s in defining equations", then that's usually considered more readable
06:41:20 * hackage gi-gtk-declarative-app-simple 0.3.0 - Declarative GTK+ programming in Haskell in the style of Pux.  http://hackage.haskell.org/package/gi-gtk-declarative-app-simple-0.3.0 (owickstrom)
06:41:28 <ski> (because then you can, at least to a large extent, read the defining equations as separate true facts about the function. you can think and reason about them, in isolation)
06:41:52 <ski> bo : so my first definition of `isOrdered' would be considered preferable to this latter (equivalent) one
06:42:11 <bo> ski: Is pattern matching applicable any time I'd like to assign something to a variable? Like object deconstruction in javascript? let { foo, bar } = obj?
06:42:20 * hackage gi-gtk-declarative 0.3.0 - Declarative GTK+ programming in Haskell  http://hackage.haskell.org/package/gi-gtk-declarative-0.3.0 (owickstrom)
06:42:39 <ski> bo : however, sometimes you want to match on the shape of some intermediate result, and then you either have to use `case', or define a new (possibly local) helper function that does that pattern-matching
06:42:51 <ski> (unless there already exists a function doing the matching that you need)
06:44:04 <ski> bo : nitpick, it's not assignment (variables in Haskell are not mutable, you can't assign to them. another way of thinking about that is that you can (indeed must) initialize them, but you can't *re*assign values to them). it's binding
06:44:51 <ski> > let (front,back) = splitAt 4 "hackage" in back ++ front
06:44:53 <lambdabot>  "agehack"
06:45:21 <bo> So i can do pattern matching any time i perform binding to a variable? Like in where clause, guards, lets and other places? Neat!
06:45:29 <merijn> bo: Yes
06:45:29 <ski> you could call that "object deconstruction", though i think "value deconstruction" would be more common terminology in Haskell
06:46:56 <ski> bo : even if you define `f x = x^2' (and then call say `f 3') or `y = x+1', that's doing (very trivial) pattern-matching, matching the input `3' with the pattern `x', resulting in the binding `x = 3'. or matching the value of `x+1' with the pattern `y', resulting in the binding `y = 4'
06:47:41 <ski> a pattern can be just a single variable. that's a pattern which always succeeds matching its incoming value, resulting in binding the variable to that value
06:47:50 * hackage tasty-rerun 1.1.14 - Run tests by filtering the test tree depending on the result of previous testruns  http://hackage.haskell.org/package/tasty-rerun-1.1.14 (OliverCharles)
06:48:03 <Solonarv> ph88: MaybeT can do that
06:48:07 <bo> Ok, you got me back on track here, this I do understand
06:48:23 <Solonarv> in fact MaybeT IO a has the same representation as IO (Maybe a)
06:48:32 <Solonarv> @unmtl MaybeT IO a
06:48:32 <lambdabot> IO (Maybe a)
06:48:42 <ski> a pattern like `(x0,y0)' is a pattern which matches the incoming pair value, by deconstructing that pair into its two components, then correspondingly matching those two values to the subpatterns `x0',`y0', which succeed immediately, resulting in bindings for `x0' and `y0'
06:48:50 * hackage ekg-carbon 1.0.11 - An EKG backend to send statistics to Carbon (part of Graphite monitoring tools)  http://hackage.haskell.org/package/ekg-carbon-1.0.11 (OliverCharles)
06:49:04 <ski> a wildcard pattern `_' always succeeds in matching (like a variable pattern), but doesn't actually bind a variable
06:49:45 <ski> a constant constructor pattern, like `False',`True',`[]' only matches if the incoming value (the "scrutinee") is that particular value, and in that case, binds no variables
06:50:27 <ski> bo : i could go on, but i think you get the basic idea
06:51:49 <bo> ski: i believe i did :) Thanks! All I have to do is to put it into practice now :)
06:55:11 <ski> bo : if your pattern doesn't cover all possible shapes of the value that it'll match on, then you probably want to be able to express alternative branches. then you need either `case' or matching on the left of `=', in a function definition. if you match like `(front,back) = ...' in a `let' or `where', then you can't express branching with that
06:56:32 <ski> bo : of course a value of a pair type can not potentially be of conflicting "shapes". a pair always has two components. but if you used say `(front,middle:back) = splitAt n xs' to get at the element `middle' at the index `n' in `xs', then that matching would fail if the list `xs' was too short
06:57:15 <ski> bo : if you wanted to be able to recover from that error condition, you should use a form of pattern-matching that allows you to provide multiple branches
06:58:21 <bo> ski: Just when I thought I got the point, you lost me again :) But it's no worries for now, I'll finish reading learyouahaskell first, this should give me solid background to understanding what you're saying
06:58:49 <ski> no worry, take your time
07:33:43 --- mode: glguy set +v Flash1293
07:50:50 * hackage heterocephalus 1.0.5.3 - A type-safe template engine for working with popular front end development tools  http://hackage.haskell.org/package/heterocephalus-1.0.5.3 (arowM)
07:54:50 * hackage ngx-export-tools 0.4.2.3 - Extra tools for Nginx haskell module  http://hackage.haskell.org/package/ngx-export-tools-0.4.2.3 (lyokha)
07:55:56 <Tyr4> Hello everyone, I have a small question. Why does msum use a foldr? Is there any reason to not use a foldl?
07:57:03 <Franciman> Tyr4, I think it's because of laziness
07:57:11 <geekosaur> in general, foldr works better lazy, foldl works better strict (and in most cases the latter should be foldl' instead)
07:58:00 <Franciman> also foldr and foldl are to give the same result, since the MonadPlus is like a monoid
07:58:08 <Franciman> so you have associativity
07:58:45 <Tyr4> If I understand well, to perform a msum we know that we have to goes through the whole list, so foldr is better. ...?
07:59:02 <Solonarv> We don't necessarily have to go through the entire list
07:59:29 <Solonarv> > head (msum (repeat (Just 1)))
07:59:31 <lambdabot>  error:
07:59:31 <lambdabot>      • Couldn't match type ‘Maybe’ with ‘[]’
07:59:31 <lambdabot>        Expected type: [a]
08:01:19 <phadej> > asum (repeat (Just 1))
08:01:21 <lambdabot>  Just 1
08:05:00 <Tyr4> OK
08:05:07 <Tyr4> > foldr mplus mzero $ (Just 1):(repeat Nothing)
08:05:09 <lambdabot>  Just 1
08:05:26 <Tyr4> but foldl mplus mzero $ repeat (Just 1) does not terminate
08:05:53 <ski> > foldl mplus mzero (Just 1 : repeat Nothing)
08:06:00 <lambdabot>  mueval-core: Time limit exceeded
08:06:39 <Tyr4> but intuitively I would say that it was foldr that will not ter
08:06:45 <Tyr4> minate
08:07:28 <ski> `foldl' will always traverse the whole list, before giving back any information on the result
08:07:54 <ski> `foldr' can possibly (depending on the callback function) give back result information, before reaching the end of the list
08:08:09 <ski> (and an infinite has no end, so `foldl' is therefore useless on it)
08:08:35 <ski> we say `foldl' is bulky (which is a consequence of it being tail recursive), while `foldr' can be incremental
08:08:47 <ski> @src foldl
08:08:47 <lambdabot> foldl f z []     = z
08:08:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:09:10 <Tyr4> It was exactly what I was looking for. Thank you!
08:09:29 <ski> in the recursive case, the result will be computed by a recursive call to `foldl', so it "spins around, non-stop, until the end"
08:09:44 <ski> the recursive call to `foldl' is a tail call
08:09:50 <ski> @src foldr
08:09:50 <lambdabot> foldr f z []     = z
08:09:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:10:14 <sproingie> so if f can ignore the second arg, it stops, right?
08:10:38 <ski> in this case, the recursive call is passed as an argument to `f'. if `f' (in some cases) doesn't force (/ demand the value of) its second argument, then the recursive call won't happen. so we can terminate in that case, even if we get an infinite list
08:10:44 <ski> yep
08:12:23 <ski> > foldr (\n res -> if n == 0 then 0 else n * res) 1 [5,4 .. 1]  -- factorial of `5' is `5 * 4 * 3 * 2 * 1', which is `120'
08:12:26 <lambdabot>  120
08:12:55 <ski> > foldr (\n res -> if n == 0 then 0 else n * res) 1 ([5,4 .. 1] ++ repeat 0)  -- here we have the product of another list, an infinite one
08:12:57 <lambdabot>  0
08:13:26 <ski> > foldr (\n res -> n * res) 1 ([5,4 .. 1] ++ repeat 0)  -- skipping the zero check, we don't terminate
08:13:32 <lambdabot>  mueval-core: Time limit exceeded
08:24:44 <ph88> i'm not entirely sure how i'm supposed to use MaybeT https://bpaste.net/show/f98491c52b81
08:28:02 <Solonarv> have you looked at the documentation?
08:28:26 <cocreature> :t hPutStrLn
08:28:27 <lambdabot> error:
08:28:28 <lambdabot>     • Variable not in scope: hPutStrLn
08:28:28 <lambdabot>     • Perhaps you meant one of these:
08:28:39 <cocreature> % :t hPutStrLn
08:28:39 <yahb> cocreature: Handle -> String -> IO ()
08:28:52 <cocreature> that definitely does not have type MaybeT IO String
08:29:04 <Solonarv> and neither does Nothing
08:29:16 <cocreature> % :i MaybeT
08:29:17 <yahb> cocreature: ; <interactive>:1:1: error: Not in scope: `MaybeT'
08:29:26 <cocreature> % import Control.Monad.Trans.Maybe
08:29:27 <yahb> cocreature: 
08:29:28 <cocreature> % :i MaybeT
08:29:29 <yahb> cocreature: type role MaybeT representational nominal; newtype MaybeT (m :: * -> *) a = MaybeT {runMaybeT :: m (Maybe a)}; -- Defined in `Control.Monad.Trans.Maybe'; instance [safe] (Functor m, Monad m) => Alternative (MaybeT m) -- Defined in `Control.Monad.Trans.Maybe'; instance [safe] (Functor m, Monad m) => Applicative (MaybeT m) -- Defined in `Control.Monad.Trans.Maybe'; instance [safe] (Data.Functor.Classe
08:29:32 --- mode: glguy set +v wwmd
08:29:37 <cocreature> % :t MaybeT
08:29:37 <yahb> cocreature: m (Maybe a) -> MaybeT m a
08:29:42 <cocreature> that’s going to be useful
08:29:50 <cocreature> also liftIO 
08:30:08 <wwmd> Hello! Can I ask a quick question?
08:30:13 <cocreature> wwmd: sure
08:30:40 <orbisvicis> can I run ghc -e '...' with an import?
08:30:41 <wwmd> Why do pattern matches inside of a list comprehension fail so elegantly?
08:31:20 <wwmd> why is it that when I type [x | Just x <- [Nothing, Nothing, Nothing]] that it gives me [] instead of an incomplete pattern match error?
08:32:09 <ski> @undo [x | Just x <- [Nothing, Nothing, Nothing]]
08:32:09 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) [Nothing, Nothing, Nothing]
08:32:27 <ClaudiusMaximus> > fail "oops" :: [a] -- might be related to this?
08:32:29 <lambdabot>  []
08:32:41 <cocreature> wwmd: the simple but unsatisfying answer is “because the Haskell standard defines it to be that way”
08:32:41 <ski> pattern match failure behaves the same as a list comprehension guard failure
08:32:59 <ski> ClaudiusMaximus : not directly, but the behaviour matches, for sure
08:33:16 <wwmd> Ah, so it automatically wraps pattern matches in Case expressions?
08:33:25 <Tuplanolla> With `MonadComprehensions`...
08:33:31 <ski> @undo [x | mx <- [Nothing, Nothing, Nothing],guard (isJust mx),let x = fromJust mx]
08:33:31 <lambdabot> concatMap (\ mx -> if guard (isJust mx) then let { x = fromJust mx} in [x] else []) [Nothing, Nothing, Nothing]
08:33:38 <Solonarv> wwmd: indeed
08:33:46 <cocreature> wwmd: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11 take a look at the fourth equation in the translation
08:33:51 <ski> > [x | Just x <- [Nothing, Nothing, Nothing]]
08:33:53 <lambdabot>  []
08:33:57 <ski> > [x | mx <- [Nothing, Nothing, Nothing],guard (isJust mx),let x = fromJust mx]
08:33:58 <lambdabot>  error:
08:33:59 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘f0 ()’
08:33:59 <lambdabot>      • In the expression: guard (isJust mx)
08:34:24 <Solonarv> ski: a "guard" in a list comprehension is just a bare expression
08:34:31 <ski> oh, right. should just be a `Bool' expression there, not a call to `guard' :)
08:34:31 <cocreature> there is a more general pattern here that failed pattern matches in do blocks desugar to a call to "fail" which is often not equivalent to erroring out (e.g. for lists it returns an empty list, for Maybe it returns Nothing, …)
08:34:35 <Solonarv> (which must have type Bool)
08:34:37 <ski> > [x | mx <- [Nothing, Nothing, Nothing],isJust mx,let x = fromJust mx]
08:34:39 <lambdabot>  []
08:34:50 <ski> Solonarv : managed to mometarily confuse myself there ;)
08:35:04 <ski> > [x | mx <- [Nothing, Nothing, Nothing],let Just x = fromJust mx]  -- error
08:35:06 <lambdabot>  [*Exception: Maybe.fromJust: Nothing
08:35:23 <ski> > [x | mx <- [Nothing, Nothing, Nothing],let Just x = mx]  -- or even this
08:35:26 <lambdabot>  [*Exception: <interactive>:3:44-54: Irrefutable pattern failed for pattern J...
08:35:42 <Solonarv> Only works for <- binds, not let-binds. I've managed to confuse myself regarding that in the past.
08:35:49 <wwmd> Thanks, you've helped me out so much. I've been puzzling over this for the longest time.
08:36:12 <ski> yes, for this reason, i sometimes do `<pat> <- [<expr>]' in a list comprehension
08:36:12 <wwmd> I've noticed this works with do-notation too.
08:36:35 <ski> @undo do Just x <- [Nothing, Nothing, Nothing]; return x
08:36:35 <lambdabot> [Nothing, Nothing, Nothing] >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
08:36:40 <Solonarv> List comprehensions and do-notation are nearly the same thing, actually
08:37:12 <ski> in the case of `do', it calls `fail', which will behave in the way we want here, because of what ClaudiusMaximus said
08:37:35 <wwmd> Do you prefer monad comprehensions to do notation? 
08:37:51 <ski> the ordering isn't quite the same
08:38:22 <ski> `do ...; return <expr>' corresponds to `[<expr> | ...]'
08:39:34 <ski> if your `do' doesn't end in a `return' (or `pure', or equivalent), say `do ...; <final command>', then you'd have to rephrase it as `[result | ...,result <- <final command>]', which can be annoying
08:39:50 <Solonarv> I usually prefer do-notation or just using the monad/applicative/functor/etc operations directly
08:40:04 <Solonarv> Often even for lists!
08:40:18 * ski sometimes does that, as well
08:40:32 <ski> if you're dealing with some sort collection, it may be nicer to use monad comprehensions
08:40:44 <wwmd> Is there a way to parallelize do-notation for lists? In a similar way to parallel list comprehensions?
08:41:00 <ski> use `zipWith' or `zip'
08:41:13 <wwmd> Ah
08:41:14 <ski> or use `ZipList', perhaps
08:41:17 <Solonarv> or the more generic 'mzipWith' / 'mzip'
08:42:41 <wwmd> Is there a way to use '@undo' in the ghci REPL?
08:42:56 <wwmd> It's helpful to see my code desugared like that.
08:43:00 <ski> not sure
08:43:19 <ski> i think it's possible to get Hoogle in the interactor
08:43:26 <Solonarv> There's a way to set up lambdabot as a local program
08:43:30 * ski has never tried
08:43:54 <ClaudiusMaximus> > [ (a, b) | a <- "hello" | b <- "world" ]
08:43:56 <lambdabot>  [('h','w'),('e','o'),('l','r'),('l','l'),('o','d')]
08:50:50 * hackage ribosome 0.1.0.0 - api extensions for nvim-hs  http://hackage.haskell.org/package/ribosome-0.1.0.0 (tek)
08:51:51 <wwmd> @undo [ (a,b) | a <- "hello" | b <- "world" ]
08:51:51 <lambdabot> [(a, b)| a <- "hello"| b <- "world"]
08:52:35 <wwmd> @undo do  a <- "hello"; b <- "world"; return (a,b)
08:52:35 <lambdabot> "hello" >>= \ a -> "world" >>= \ b -> return (a, b)
08:53:37 <Math22232> > [ (a, b) | a <- "hello" | b <- "world" ]
08:53:39 <lambdabot>  [('h','w'),('e','o'),('l','r'),('l','l'),('o','d')]
08:54:03 <Math22232> > [ (a, b) | a <- [1..] | b <- "world" ]
08:54:04 <lambdabot>  [(1,'w'),(2,'o'),(3,'r'),(4,'l'),(5,'d')]
08:54:05 <wwmd> zip "hello" "world"
08:54:20 <Math22232> >zip "hello" "world"
08:54:40 <Math22232> >\4 -> 4+1
08:55:14 <Solonarv> Math22232: you need a space after the >
08:55:28 <wwmd> > zip "hello" "world"
08:55:29 <Math22232> sj
08:55:30 <lambdabot>  [('h','w'),('e','o'),('l','r'),('l','l'),('o','d')]
08:55:31 <Math22232> ah
08:55:32 <Math22232> ty
08:55:39 <Math22232> > \4 -> 4+ 1
08:55:41 <lambdabot>  <Integer -> Integer>
08:55:49 <ski> % unwords [w | (i,w) <- (zip [0 ..] . words) "The hip bone is connected to the leg bone",then group by map toLower w using groupWith,then sortWith by Down (length w),then take 2,(i,w) <- zip i w,then sortWith by i]
08:55:50 <yahb> ski: "The bone the bone"
08:56:02 <Math22232> > map \x-x+4 [1..100]
08:56:04 <lambdabot>  <hint>:1:5: error: parse error on input ‘\’
08:56:08 <Math22232> > map \x->x+4 [1..100]
08:56:10 <lambdabot>  <hint>:1:5: error: parse error on input ‘\’
08:56:14 <ski> you need brackets
08:56:15 <Math22232> > map (\x->x+4) [1..100]
08:56:17 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
08:56:39 <ski> `(+ 4)' is the same thing as `\x -> x + 4'
08:56:56 <Math22232> > map (x+4) [1..100]
08:56:58 <lambdabot>  error:
08:56:58 <lambdabot>      • Couldn't match expected type ‘Integer -> b’
08:56:59 <lambdabot>                    with actual type ‘Expr’
08:57:00 <Math22232> > map (+4) [1..100]
08:57:02 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
08:57:07 <Math22232> nice ^
08:58:33 <ski> wwmd : `undo' doesn't understand `ParallelListComp', nor `TransformListComp'
08:59:19 <wwmd> ski: gotcha, I was a little confused
08:59:39 <ski> wwmd : see if you can figure out the "bone" example above
09:00:53 <ski> i'm picking out (all instances of) the two words (ignoring case) that occur most frequently, stripping away all other words
09:02:02 <ski> (cf. `GROUP BY' and `SORT BY' in SQL)
09:29:01 --- mode: glguy set +v test2_
09:34:20 * hackage data-clist 0.1.2.2 - Simple functional ring type.  http://hackage.haskell.org/package/data-clist-0.1.2.2 (jeremyjh)
09:56:58 <merijn> Is there a /dev/null conduit? >.> i.e. I want to run a producer until exhausted, but not do anything with the output, just to time the producer's performance
10:10:10 <_deepfire> Dave.Null.Conduit : -)
10:10:21 * hackage morphisms-objects 0.1.0 - Algebraic structures  http://hackage.haskell.org/package/morphisms-objects-0.1.0 (iokasimovmt)
10:31:56 --- mode: glguy set +v mreh
10:53:40 <Bish> what part of haskell does the actual IO
10:53:47 <Bish> i mean.. at some point there has to be unsafe trusted code
10:54:01 <Bish> is it in the RTS? , where would i fine that line of code that does the syscall
10:56:06 <geekosaur> it is in the RTS, yes, in the I/O manager
10:56:58 <geekosaur> I sugest you spend some time studying the Commentary before rooting around in the guts. https://ghc.haskell.org/trac/ghc/wiki/Commentary
10:57:49 * ski . o O ( <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.12.0.0/src/GHC-List.html#iterate'> )
10:57:57 <ski> % head (iterate' undefined ())
10:57:57 <yahb> ski: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:76:16 in interactive:Ghci45
10:58:06 <ski> % let iterate' f x = ((x :) . iterate' f) $! f x in head (iterate' undefined ())
10:58:06 <yahb> ski: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:77:66 in interactive:Ghci45
10:58:15 <ski> % let iterate' f !x = x : iterate' f (f x) in head (iterate' undefined ())
10:58:15 <yahb> ski: ()
10:58:54 --- mode: glguy set -v mreh
11:01:03 <Ackpacket> I'm trying to model the game state of a texas hold'em poker table.  In that state, I need to track which seats at the table are open and which have players.  Any thoughts on an approach here?  Since there are only 9 seats I've thought about just making each one of them a record/field in the gamestate (e.g., Seat1, Seat2)  But then I lose any future value I might gain from being able to map or filter over a list of seated players
11:01:28 <Ackpacket> But if I maintain these players in a list, I have to track things like order, and changing a seat is more cumbersome
11:02:37 <ski> (possible cut off near the end of your first message : "..  But then I lose any future value I might gain from being able to map or filter over a list of seated players" ?)
11:03:05 <ski> what do you mean by "track things like order" ?
11:03:43 <Ackpacket> If I maintain a list of players, I then have to track their seat separately, either by keeping order in the list, or by adding a field to the players
11:03:47 <ski> i'm not sure what "changing a seat" means in "texas hold'em poker", and i don't see why doing that would be more cumbersome with a list than with a record
11:04:05 <Ackpacket> Ski, any card games you are more familiar with?
11:04:23 <ski> you could have a list of type `[Maybe Player]', `Nothing' indicates an empty seat
11:04:31 <Ackpacket> We can talk in terms of blackjack.  There's a table, a dealer, and 6-9 seats that can be occupied by players or nobody
11:06:12 <ski> or you could have an `Array Seat (Maybe Player)' or a `Map Seat (Maybe Player)' (or just `Map Seat Player', since finite maps can be partial). where `Seat' is either a new enumeration type, or perhaps just a synonym for (or `newtype' wrapping) say `Int'
11:06:38 <ski> in any case, you can use `Maybe' to indicate presence or absence of a player, at a seat
11:07:08 * ski isn't really that much familiar with card games, sorry
11:07:33 <Ackpacket> Appreciate the suggestion.  I thought about that.  Actually, I wasn't aware haskell supported arrays
11:07:37 <Ackpacket> Let me look into this
11:07:39 <ski> (i've written a simplistic blackjack thing, but not with more than two players)
11:08:15 <ski> there are both immutable and mutable arrays. `Array' is immutable. for mutable, you probably want either `IOArray' or `STArray'
11:08:48 <ski> (there are unboxed versions, for more space-efficient representations)
11:10:33 <Ackpacket> I guess a better way to discuss this would be in terms of requirements
11:10:45 <exarkun1> Trying out servant-py, encountering a type error `servant-0.13.0.1:Servant.API.ContentTypes.JSON expected in list '[servant-0.13.0.1:Servant.API.ContentTypes.OctetStream]` - seems to have to do with an API with `ReqBody '[OctetStream]`.  Anyone know if servant-py supports this?
11:10:45 <ski> anyway, if you have a list of `Maybe Player', then you don't need a separate seat field in `Player', since you can just use the index of the list element
11:11:17 <Ackpacket> ski, if replacing the third player more cumbersome then?
11:11:39 <ski> (it's not clear whether you want to allow say seats `1',`3',`4' to be occupied, but seat `2' unoccupied. iow do occupied seats need to be contiguous ? perhaps even starting at the first seat ?)
11:12:20 <ski> i don't know what you mean by "replacing the third player" (just like i don't know what "changing a seat" means)
11:12:46 <ski> the latter meaning one player moving from their current seat, to another, previously unoccupied, seat ?
11:15:36 <Ackpacket> Yes to your first question.  Having only seats 1, 3, and 4 occupied would be valid
11:16:12 <Ackpacket> An example operation on these nine seats would be to change one from the occupied state to the unoccupied state. (e.g., going from 1,3 and 4 being occupied to having 1 and 4 occupied)
11:17:03 <ski> ok, that could be just replacing `Just somePlayer' with `Nothing', at seat position `3' in the list/array/map
11:17:31 <ski> (or removing the association from seat position `3' to `somePlayer', in the latter finite map case)
11:18:09 <ski> (presumably you don't need to keep track of players who are no longer seated / who haven't taken a seat yet)
11:18:38 <ski> (well, perhaps you want to keep some kind of scoreboard ?)
11:20:39 <Ackpacket> Sometimes I think the most valuable thing I get out of coming into these rooms is better practice explaining something instead of just the topic I came for
11:21:01 <Ackpacket> I think instead of talking about some abstract concept and asking for the best approach, I'll try *taking* some approach and asking how I could be doing it better.
11:21:21 <ski> well, imho, both can be useful
11:22:07 * ski . o O ( <https://en.wikipedia.org/wiki/Rubber_duck_debugging> )
11:23:19 <lambdabot> quack!
11:25:18 <infinisil> Haha
11:25:56 * ski . o O ( "Jams O'Donnell, is that you?" )
11:40:18 <exarkun1> https://github.com/LeastAuthority/servant-py/commit/d30458aba607788aa06654f8f74e554ce503d5f3 "JSON expected in list '[OctetStream]" - anyone help with this?
11:41:23 <fresheyeball> so I would like to newtype some `Map`s
11:41:42 <fresheyeball> is there a way I can derive classy lens instances for my newtype?
11:41:57 <fresheyeball> having an `instance At` would be nice
11:42:23 * hackage human-readable-duration 0.2.1.0 - Provide duration helper  http://hackage.haskell.org/package/human-readable-duration-0.2.1.0 (yogsototh)
11:43:22 * hackage human-readable-duration 0.2.1.1 - Provide duration helper  http://hackage.haskell.org/package/human-readable-duration-0.2.1.1 (yogsototh)
11:43:55 <Bish> geekosaur: well thanks, but i like to understand how this stuff works
11:44:15 <geekosaur> that is why I pointed you at the Commentary
11:44:16 <Bish> i mean that particular part of ghc
11:49:18 <Solonarv> fresheyeball: turn on GeneralizedNewtypeDeriving + DerivingStrategies, and then you can just add 'deriving newtype (At, ...)' to your declaration
11:49:27 <hc> any haskellers@35c3?
11:51:53 * hackage human-readable-duration 0.2.1.2 - Provide duration helper  http://hackage.haskell.org/package/human-readable-duration-0.2.1.2 (yogsototh)
11:55:06 <fresheyeball> Solonarv: I tried that
11:55:43 <Solonarv> and what's the error you got?
11:56:18 <fresheyeball> well first of all I filled out the type family instances
11:56:30 <fresheyeball> Index and IxValue
11:57:06 <exarkun1> seems servant-foreign can't do what I want yet: https://github.com/haskell-servant/servant/issues/551
11:57:26 <fresheyeball> now I get "Couldn't match the representation of type 'f (Map Price Quantity)' with that of 'f PtoQ'
11:58:41 <Solonarv> Please paste your code somewhere and post a link to that.
12:00:10 <fresheyeball> Solonarv: https://dpaste.de/jnXT
12:01:49 <Solonarv> Oh yes, I see - which GHC version are you on?
12:01:54 <fresheyeball> 8.4.3
12:02:08 <fresheyeball> Solonarv: https://dpaste.de/TQre 
12:02:51 <Solonarv> Hmm, dang
12:03:15 <Solonarv> I don't think there's a way to newtype-derive that class then
12:06:23 * hackage elm2nix 0.1.0 - Turn your Elm project into buildable Nix project  http://hackage.haskell.org/package/elm2nix-0.1.0 (domenkozar)
12:21:25 --- mode: glguy set +v Ulbrec
12:28:38 <Ackpacket> Looking for tips on how to better arrange these datastructures to suit the operations I want to perform on them:  https://ideone.com/y70CM8
12:35:10 <amalloy> well, having 9 named fields with the same type is not as good as having a list. you can guarantee the list has exactly 9 elements by wrapping it with a newtype having a smart constructor
12:36:07 <amalloy> newtype Nine a = Nine [a]; mkNine xs | length xs == 9 = Just (Nine xs) | otherwise = Nothing
12:36:45 <amalloy> then your GameState would have a field of type Nine (Maybe SeatState)
12:36:57 <Solonarv> Or you can use vector-sized which does that for you
12:37:30 <amalloy> also using 0-9 inclusive to refer to seats 1-9 is confusing: what does 0 mean?
12:37:59 <Ackpacket> Dealer.  But since the personality (GameState -> Decision) is unchanging and not associated with a particular game, I saw no reason to track it in the game state
12:38:06 <Ackpacket> ^ seat 0
12:39:14 <Ackpacket> amalloy, if I maintain a list of 9, am I doomed to index in/out and reconstruct the list if I wanted to say, change the bet amount for seat 3?
12:39:53 <koz_> Ackpacket: Lists are _not_ a good structure if you want random access.
12:40:02 <koz_> Especially if you want _repeated_ random access.
12:40:08 <Ackpacket> That is the case for me.
12:40:14 <koz_> Then you should be using a vector.
12:40:17 <Solonarv> how, other than by indexing, would you specify that you mean the 3rd item? (but yes, don't use lists)
12:40:48 <koz_> Solonarv: I believe there's an @remember for this...
12:40:51 <Ackpacket> This is why I tried using separate fields
12:40:53 <koz_> (authored by you)
12:41:41 <Solonarv> koz_: heh, I'd forgotten about that
12:41:59 <Solonarv> Ackpacket: that's actually not a bad idea, but I'd recommend putting it in a separate data structure
12:42:02 <Solonarv> One sec
12:43:31 <Ackpacket> At some point in fully implementing this, I will have to go around the table, seat to seat, offering an opportunity to make a decision.  I could go around the table multiple times before the round is over, because some decisions can require checking all seats again.
12:43:50 <Ackpacket> It's at this point that having seat1, seat2, etc. might start making things complicated where a list wouldn't
12:44:16 <koz_> Ackpacket: Will there always be the same number of seats, or can this vary?
12:44:31 <Ackpacket> Always the same.  Ofc, some seats can be empty, which is the need for the Maybe
12:45:01 <koz_> Ackpacket: Then (as a co-maintainer of vector-sized) I am obliged to recommend vector-sized.
12:45:04 <Ackpacket> I've thought about just making FetchSeat (GameState -> Int -> SeatState) and ReplaceSeat (GameState -> SeatState -> Int -> GameState) and calling it a day
12:45:11 <Solonarv> koz_: I recommended it already :>
12:45:28 <koz_> Although to be honest, instead of a vector (sized or not) of Maybes, given that seats can be empty, some kind of Map may be more appropriate.
12:45:30 <Solonarv> but you can also just implement your own "exactly 9-element list": https://gist.github.com/Solonarv/4b922596d7813082eb0c9044fb67df9a
12:45:35 <koz_> (and avoids anything to do with Maybe)
12:47:02 <__monty__> Or, if you're into hasochism, type-safe fixed-size vectors are pretty nice : >
12:47:49 <Ackpacket> Still very new to haskell but I've heard lenses support some sort of computationally derived fields.  Any application for that here?  E.g. having a seatlist derived from Seat1, Seat2, etc.
12:48:53 <Ackpacket> Solonarv, how does random access work with your datatype?
12:49:31 <Solonarv> I didn't bother to specify it, but you can easily add indexing for 'Nine'
12:51:58 <ski> @quote Solonarv
12:51:58 <lambdabot> Solonarv says: simple linked lists are not a particularly great *data* structure, but in combination with laziness they make a pretty good *control* structure
12:53:28 <koz_> __monty__: I resent that. :P
12:55:38 <Ackpacket> koz_, not sure how a map avoid anything to do with maybes, since I'm now introducing another fork:  When the map does not have what I'm looking for.
12:56:20 <Solonarv> That's not *another* branch, that's the same branch you had originally
13:01:15 <Ackpacket> I spend so much more time just reasoning about code structure since picking up haskell.
13:01:48 <Solonarv> That sounds like a good thing
13:23:52 * hackage dimensional 1.2 - Statically checked physical dimensions,using Type Families and Data Kinds.  http://hackage.haskell.org/package/dimensional-1.2 (dmcclean)
13:34:06 <energizer> i dont know much haskell i am curious about a design question. often an app will receive a web request, ask the database a question, hear back from the db, and send a response to the web request using the db's response
13:35:04 <energizer> this means 4 different pieces of I/O, with the db interaction sitting right in the middle instead of at the edges
13:36:24 <energizer> is there a way to deal with this that makes it possible for the I/O to be kept on the "outside" instead of sitting right in the middle? or, what's the most ~elegant way to design this kind of system?
13:37:10 <Rembane> I've seen monad transformer stacks being used to great effect in that kind of applications. 
13:38:30 <energizer> Rembane: sorry to ask, would you mind ELI5?
13:40:58 <Rembane> energizer: What's a ELI5?
13:41:11 <energizer> Rembane: "explain like I'm 5"
13:41:51 <Rembane> energizer: Ah. I don't know if I'm good enough for that, but I'll give it a go anyway.
13:41:57 <hnsz> energizer: That went over my head for a full 10 seconds
13:43:09 <Rembane> energizer: Monad transformer stacks are at a 30 000 feet glance a way to combine (side) effects in a structured manner.
13:44:52 * hackage IOSpec 0.3.1.1 - A pure specification of the IO monad.  http://hackage.haskell.org/package/IOSpec-0.3.1.1 (BertramFelgenhauer)
13:45:28 <energizer> Rembane: Somehow combining the (http-receive, db-send, db-receive, http-send) into a single action?
13:46:01 <boj> energizer: something that reaches into and manipulates data is mostly side effecting anyways. you can't really push IO to the edges, but you can definitely wedge pure business logic in the middle
13:46:11 <Rembane> energizer: Well, they are at least composed in a sequential manner. 
13:52:40 <energizer> interesting, thanks
13:58:05 <merijn> We need to start some website where we can post our libraries that need (simple and easy to write) tests that you can't be bothered with as beginner exercises :p
13:58:23 * hackage dimensional 1.3 - Statically checked physical dimensions,using Type Families and Data Kinds.  http://hackage.haskell.org/package/dimensional-1.3 (dmcclean)
13:59:00 <ph88> thx cocreature 
14:00:53 * hackage g4ip-prover 2.0.0.0 - Theorem prover for intuitionistic propositional logic using G4ip  http://hackage.haskell.org/package/g4ip-prover-2.0.0.0 (klntsky)
14:10:32 <ph88> i have a function of type :: MaybeT IO String   in there i do   MaybeT $ liftIO $ return $ Just "linux"    .. is there perhaps a shorter way to write this ?
14:11:57 <[Leary]> > return "linux" :: MaybeT IO String
14:11:59 <lambdabot>  error:
14:11:59 <lambdabot>      Not in scope: type constructor or class ‘MaybeT’
14:11:59 <lambdabot>      Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
14:12:07 <[Leary]> % return "linux" :: MaybeT IO String
14:12:08 <yahb> [Leary]: ; <interactive>:79:1: error:; * No instance for (Data.Functor.Classes.Show1 IO) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
14:12:23 <[Leary]> True, forgot only lambdabot prints IO as types...
14:13:48 <geekosaur> not related
14:13:58 <[Leary]> Anyway, the whole point of return/pure is to embed your value into the monadic context. You don't need to try build that from scratch.
14:14:03 <geekosaur> "MaybeT IO String" is kind Type -> Type
14:14:08 <fresheyeball> is there any good way to newtype a Map?
14:14:18 <geekosaur> hm, no
14:14:47 <geekosaur> :k MaybeT
14:14:48 <lambdabot> error:
14:14:48 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
14:14:49 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
14:14:52 <geekosaur> oops
14:14:56 <merijn> fresheyeball: Good way how?
14:15:02 <fresheyeball> don't we just need to make a typeclass for the standard Map api?
14:15:04 <geekosaur> % :k MaybeT
14:15:04 <yahb> geekosaur: MaybeT :: (* -> *) -> * -> *
14:15:22 <fresheyeball> merijn: newtyped Maps are not ergonomic, as we have to manually wrap and unwrap
14:15:33 <fresheyeball> we also can't solve this with lens and newtype deriving 
14:15:36 <merijn> fresheyeball: Have you tried "coerce"?
14:15:39 <ski> ph88 : that `liftIO' is `id' of type `IO a -> IO a'
14:16:16 <fresheyeball> merijn: wouldn't that mean litering that throughout the code?
14:16:35 <ski> % :t return "linux" :: MaybeT IO String
14:16:35 <yahb> ski: MaybeT IO String
14:16:43 <fresheyeball> I really want `lookup` or `at` to just work the the newtype
14:16:45 <ski> ph88 : that works, as [Leary] suggested
14:16:46 <merijn> fresheyeball: Yes, no, maybe. It depends on how you use things
14:17:04 <merijn> fresheyeball: You can just define your own version of lookup and at that unwrap and then use those?
14:18:08 <fresheyeball> merijn: right, now I am thinking to do this well, I would need to wrap the entire Map api in a typeclass
14:18:20 <fresheyeball> and then newtype deriving would work to make it ergonomic 
14:18:50 <merijn> fresheyeball: That sounds like more work than just defining wrappers that unwrap before use, tbh
14:22:39 <koz_> Also, what laws would said typeclass have?
14:23:16 <kadoban> That it acts like Map, probably.
14:23:33 <kadoban> Doesn't seem like a worthwhile thing, on the face of it
14:23:43 <koz_> kadoban: 'Acts like a Map' isn't a law. Or a set of them for that matter.
14:23:54 <koz_> Closest thing I can think of are the lens laws, but then you should stop lying to yourself.
14:24:10 <fresheyeball> koz_: we can make it a law
14:24:26 <koz_> fresheyeball: Try writing it in a way that's usable to check or prove anything.
14:24:26 <fresheyeball> toMap and fromMap methods can be added
14:24:38 <kadoban> It could be made into laws fairly easily, but it ends up just being the documented and undocumented functionality of Map
14:24:43 <geekosaur> isn thter already a containers-lek package with typeclass abstractios?
14:24:44 <kadoban> (also it'd be tedious)
14:24:52 <koz_> kadoban: And fundamentally not useful.
14:24:57 <kadoban> Yes
14:25:29 <geekosaur> http://hackage.haskell.org/package/EdisonCore http://hackage.haskell.org/package/EdisonAPI
14:25:51 <vaibhavsagar> fresheyeball: https://github.com/kowainik/containers-backpack
14:26:11 <ph88> [Leary], ski how can i distinguish between Just and Nothing when i do    return "linux"  ?
14:26:22 <vaibhavsagar> although I don't think newtyping Maps is a good idea
14:26:38 <geekosaur> ph88, you can't
14:26:44 <[Leary]> > pure "linux" :: Maybe String
14:26:46 <lambdabot>  Just "linux"
14:26:46 <merijn> vaibhavsagar: newtyping Map is fine, you almost have to, because the Monoid instance of Map is stupid
14:26:46 <geekosaur> return is Just
14:26:53 <geekosaur> fail is Nothing
14:26:55 <merijn> vaibhavsagar: Making it a typeclass is silly, though
14:26:58 <ph88> oh fail
14:27:18 <vaibhavsagar> merijn: http://hackage.haskell.org/package/monoidal-containers solves that problem though
14:27:44 <vaibhavsagar> but I completely agree about typeclasses
14:28:09 <ski> ph88 : `return "linux"', of type `MaybeT IO String' will expand to `MaybeT (return (Just "linux"))'
14:28:30 <vaibhavsagar> unless it's something like http://hackage.haskell.org/package/total-map
14:28:58 <ski> ph88 : i'm not sure what you mean by "distinguish between Just and Nothing" here. you mean catching when some subaction either uses `return Nothing' or `return (Just (...))' ?
14:29:03 <fresheyeball> vaibhavsagar: monoidal containers looks like what I want
14:29:08 <fresheyeball> but why is it HashMap specific?
14:29:15 <fresheyeball> why use HashMap instead of Map?
14:29:28 <koz_> fresheyeball: http://hackage.haskell.org/package/monoidal-containers-0.4.0.0/docs/Data-Map-Monoidal.html
14:29:29 <vaibhavsagar> it's not?
14:29:34 <vaibhavsagar> it has instances for both
14:29:49 <fresheyeball> oic
14:29:50 <fresheyeball> my bad
14:30:12 <vaibhavsagar> I hear monoidal-containers is used extensively in reflex, which is where I heard about it
14:30:36 <fresheyeball> oh no wait
14:30:40 <fresheyeball> this doesn't solve it at all
14:30:52 <koz_> vaibhavsagar: I heard jle` sing the praises of monoidal-containers recently, which is how I know about it.
14:31:00 <fresheyeball> what I want a way to avoid writing all this out for a map newtype
14:31:12 <fresheyeball> monoidal containers actually demonstrates the problem I am seeing here
14:32:09 <vaibhavsagar> there is also http://hackage.haskell.org/package/mono-traversable
14:32:20 <vaibhavsagar> but I don't know anyone outside of fpco who uses that
14:33:01 <koz_> fresheyeball: Let me see if I understand. You wanna newtype over Map because ... you want different type class instances? You want some different operations? Something else?
14:34:10 <fresheyeball> koz_: I want to newtype over Map, because I have many many Map's in my program and semantics are easy to get lost
14:34:32 <koz_> fresheyeball: Now I'm even more confused.
14:34:34 <fresheyeball> right now they are outside of newtypes for ergonomics reasons only
14:34:39 <koz_> What do you mean 'semantics are easy to get lost'?
14:35:19 <fresheyeball> I mean that `Map Exchange (Map Price Quantity)` has a different meaning than `Map Price Quantity` in another part of the code
14:35:30 <amalloy> fresheyeball: it sounds like you just want a type alias for "documentation" purposes. "this isn't just a map, it's my config object"
14:35:40 <amalloy> but you want to treat them exactly like maps, using the ordinary map operations
14:35:44 <fresheyeball> amalloy: that is a fair way of putting it
14:35:46 <koz_> fresheyeball: Uhh... those two things are nothing alike anyway. Either to you or to the compiler.
14:35:50 <fresheyeball> I also don't want to mix things up by accident
14:36:01 <koz_> I am absolutely and totally not clear how such a mix-up could even occur.
14:37:18 <fresheyeball> koz_: look, I am sure you can understand that there is value in using newtypes to prevent us as programmers from conflating things in the code
14:37:32 <kadoban> I can certainly think of some Maps that could easily get confused
14:37:32 <amalloy> fresheyeball: suppose you succeeded in building your Mappish typeclass. all your map-likes would then behave exactly like maps using the same functions, and you would thus be able to accidentally mix them up again
14:37:39 <fresheyeball> for example I have `newtype Price = Price Rational` and `newtype Quantity = Quantity Rational`
14:37:54 <koz_> fresheyeball: There is a _world_ of difference between your first and second example.
14:38:07 <koz_> Specifically, your first example has two completely different types which don't require newtypes to distinguish them.
14:38:18 <koz_> While your second (sans newtyping) is _the same type_.
14:38:31 <fresheyeball> and no, if I have a typeclass I can't mix them up easily, I just get consistent api to interact
14:38:59 <vaibhavsagar> why do you need to newtype the Map though
14:39:01 <fresheyeball> Another option would be to have an easy way to get classy lens instances
14:39:12 <ph88> ski, i mean to write something that expands to   MaybeT (return (Nothing))
14:39:39 <koz_> :t lift
14:39:40 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
14:39:53 <koz_> ph88: Perhaps this is what  you seek?
14:40:09 <[Leary]> % runMaybeT empty
14:40:09 <yahb> [Leary]: Nothing
14:40:11 <ski> ph88 : use `mzero' or `empty'
14:40:13 <ph88> koz_, geekosaur just told me that if the monad fails it will return Nothing
14:40:14 <[Leary]> % runMaybeT mzere
14:40:14 <yahb> [Leary]: ; <interactive>:84:11: error:; * Variable not in scope: mzere :: MaybeT m a; * Perhaps you meant `mzero' (imported from Control.Monad)
14:40:18 <ph88> so i try fail   https://bpaste.net/show/d1235c4383ec
14:40:18 <[Leary]> % runMaybeT mzero
14:40:18 <yahb> [Leary]: Nothing
14:40:30 <fresheyeball> ok
14:40:31 <ski> koz_ : no, that doesn't help with that
14:40:48 <koz_> Oh, OK then. Whoops.
14:40:52 <geekosaur> :t fail
14:40:53 <lambdabot> Monad m => String -> m a
14:40:54 <[Leary]> % runMaybeT (fail "")
14:40:55 <fresheyeball> sometimes a `Map Price Quantity` is part of a larger strucutre, and just needs to be a map
14:40:55 <yahb> [Leary]: Nothing
14:41:09 <fresheyeball> other times it would be nice to have `newtype Orders = Orders (Map Price Quantity)`
14:41:12 <geekosaur> theString isn't useful with Maybe or MaybeT but s still required
14:41:21 <fresheyeball> because in this case I am using the map to represent Orders
14:41:34 <koz_> fresheyeball: OK, sure, on _that_ point I am with you.
14:41:44 <amalloy> fresheyeball: i would say, go ahead and define that newtype, and use the enwtype instance when you are passing these things around as opaque objects
14:41:44 <fresheyeball> I have tons of cases like this
14:41:50 <ph88> [Leary], do you know why fail needs a string ?
14:41:57 <amalloy> and when you need to crack them open to use them as a map, use coerce within that local scope
14:42:04 <koz_> fresheyeball: Have you looked at CoercibleUtils?
14:42:04 <geekosaur> because it's part of the API for MonadFail
14:42:06 <amalloy> or whatever other unwrap
14:42:08 <koz_> It makes this kind of thing much easier.
14:42:13 <[Leary]> So you can fail with a error message where that's applicable.
14:42:23 <koz_> Specifically look at 'over' and 'under', and their two-arg variants.
14:42:24 <fresheyeball> koz_: sure, but it adds a layer I don't need
14:42:26 <ski> ph88 : i think it rarely makes sense to use `fail' explicitly
14:42:40 <koz_> fresheyeball: I don't understand. How is this worse than doing the wrapping manually?
14:42:46 <geekosaur> in particualr, pattern matches in do expressions desugar such that patern match failure calls fail with the location fo the patern match failure
14:42:50 <[Leary]> % fail "error message" :: IO ()
14:42:50 <yahb> [Leary]: *** Exception: user error (error message)
14:43:11 <geekosaur> whch is why fail was introdced in the first place
14:43:18 <fresheyeball> koz_: why use `_Wrapped . at "foo"` when we can have an instance of `At` directly?
14:43:25 <ph88> ski, what's fail implicitly ?
14:43:37 <koz_> fresheyeball: I never mentioned lenses.
14:44:20 <fresheyeball> koz_: I know. Do you not see my point? Wrapping an unwrapping maps like this is a pretty big ergonomic pain point in the code
14:44:39 <ski> ph88 : pattern-match failure in `do'-notation expands to a call to `fail'
14:44:50 <koz_> fresheyeball: The compiler can't read your mind. CoercibleUtils is my choice of 'maximum ratio of ergonomics to not footgunning myself'.
14:44:52 <fresheyeball> I would end up doing this every time I want to interact with the underlying map
14:45:05 <ski> @undo do [x,y,z] <- getArgs; putStrLn (x ++ y ++ z)
14:45:05 <lambdabot> getArgs >>= \ a -> case a of { [x, y, z] -> putStrLn (x ++ y ++ z); _ -> fail ""}
14:45:15 <bor0> is there a way to make `getIntersections` more elegant in https://gist.github.com/bor0/7bbd00ee073e8582d1ad859d755035ca?
14:45:26 <geekosaur> except the compiler includes the actual location of the failure
14:45:34 <ski> yes
14:45:44 <fresheyeball> koz_: can I derive Coercible?
14:45:59 <koz_> fresheyeball: Coercible is done for you.
14:46:04 * ski isn't convinced it's a good idea to pass around that source location as an ordinary value, at run-time
14:46:04 <koz_> In fact, Data.Coerce says that.
14:46:20 <koz_> You _can't_ define Coercible instances yourself as such.
14:46:31 <fresheyeball> so I don't even need to derive it? it's just there for all newtypes?
14:46:37 <koz_> fresheyeball: Among other things.
14:46:45 <geekosaur> where rolep[ermits, yes
14:46:57 <koz_> I would recommend reading about roles (and the paper that spawned all this) if you want the full shakedown.
14:47:05 <fresheyeball> koz_: ok this is news to me
14:47:10 <fresheyeball> what other things are magic like this
14:47:10 <koz_> CoercibleUtils makes this a little nicer to use IMHO, but strictly speaking isn't mandatory.
14:47:56 <koz_> fresheyeball: If by 'magic' you mean 'compiler can do it for me', GHC can derive Functor, Foldable, Traversable, and Generic.
14:47:58 <koz_> (among others)
14:48:09 <koz_> You can also check out lyxia's all-singing, all-dancing, all-deriving library.
14:48:10 <fresheyeball> koz_: right, but I tell it when to do so
14:48:19 <fresheyeball> I have to say `deriving Functor`
14:48:36 <koz_> Yes, because Coercible isn't _really_ a type class in the same way as Functor is.
14:48:48 <koz_> Again, read the safe coercions paper, and the GHC wiki on roles, if you want the full details.
14:48:55 <fresheyeball> ok cool
14:48:59 <fresheyeball> thanks for the help
14:49:02 <fresheyeball> I am going to use this
14:49:03 <koz_> No worries.
14:49:11 <geekosaur> the oly two auto-derivd ones are Coercible (wich si actually internal tot het yepchecker and not realy a typeclass) and Typeable (which is compiler internal sate projected outward, more or less)
14:58:38 <Solonarv> I'm late, but:
14:58:52 <Solonarv> there *is* a typeclass for map-like things. That's exactly what At is.
15:01:15 <Solonarv> It can't be GND'ed for, essentially, technical reasons
15:02:55 <Solonarv> fresheyeball: you can define an At instance for your type and implement 'at i = _Wrapper . at i'
15:03:10 <Solonarv> er, _Wrapped
15:26:46 <Ackpacket> Solonarv, maybe I misunderstood you earlier, but you mentioned adding indexing for this custom datastructure Nine.  What does that look like?
15:27:23 <Solonarv> Depends on how type-safe you want to be, and how scared you are of lenses
15:28:28 <Ackpacket> Completely agnostic of lenses atm
15:28:41 <Ackpacket> Seems powerful.  Has a reputation for adding complexity where unnecessary.
15:28:47 <Ackpacket> That's all I've observed.
15:30:59 <Solonarv> Give me a few minutes, I'll edit my gist to add a few different approaches to indexing
15:33:13 <Ackpacket> tyvm
15:54:52 <Solonarv> Ackpacket: https://gist.github.com/Solonarv/4b922596d7813082eb0c9044fb67df9a
15:56:35 <ph88> how do i link with a static library .a archive file ?  only a single one, all other linking can be dynamic
16:00:15 <koz_> For funsies, I'm also gonna show the vector-sized version of Solonarv's work.
16:01:49 <Solonarv> koz_: please do, that's probably the cleanest version
16:01:49 <Habib> Does anyone know why postgresql-simple would complain about an incompatibility between Haskell Text and SQL int4 when my data declaration makes no reference to Text. I have two uses of Text in my whole application in places that have nothing to do with my postgresql-simple model.
16:01:53 * hackage ztar 1.0.1 - Creating and extracting arbitrary archives  http://hackage.haskell.org/package/ztar-1.0.1 (brandonchinn178)
16:01:57 <koz_> Solonarv: On it.
16:02:19 <mniip> Solonarv, you forgot Applicative and Monad
16:02:31 <Habib> The field in particular is typed as an Integer on the Haskell side, and an int on the SQL side.
16:02:49 <Solonarv> mniip: I was too lazy for applicative, and I don't think this has a valid Monad instance
16:02:55 <mniip> it does
16:03:02 <Solonarv> huh?
16:03:05 <koz_> Same as Finite 9 -> a.
16:03:10 <mniip> yes
16:03:14 <Solonarv> Oh, duh
16:03:19 <koz_> (thank you vector-sized, for my education)
16:03:44 <Solonarv> actually, that's another perfectly valid representation
16:03:59 <koz_> That's what vector-sized more-or-less boils down to, modulo memoization./
16:06:25 <Habib> Got it. Ordering of the fields in the Haskell record vs. ordering of the fields in the CREATE TABLE.
16:06:44 <Habib> Spent ages staring at that, and I get it in one minute after posting.
16:07:23 <Solonarv> something something rubber duck
16:08:23 <ph88> looking here atm https://www.haskell.org/cabal/users-guide/developing-packages.html?highlight=sources#foreign-libraries
16:10:59 <koz_> Solonarv, Ackpacket: https://gist.github.com/kozross/bf981a728dcf227d8a0253cd560ce4ea
16:11:45 <Ackpacket> Solonarv, ty for that example.
16:12:15 <Ackpacket> I wonder, seems like a lot of this missing type safety comes from the fact that we're accepting Ints as indices to something that really only accepts numbers 1-9
16:12:23 <Ackpacket> is there a way to model a set of numbers?
16:12:32 <koz_> Ackpacket: There are ways. Finite is one option.
16:12:34 <Ackpacket> without having to write One | Two | Three (etc.
16:13:14 <Solonarv> Ackpacket: that's exactly what Finite is
16:13:21 <Solonarv> @hackage finite-typelits
16:13:21 <lambdabot> http://hackage.haskell.org/package/finite-typelits
16:13:37 <koz_> Ackpacket: If you check my pasted gist, it uses Finite for precisely such a purpose.
16:13:55 <Solonarv> so does mine, in one of the examples :>
16:14:54 <koz_> I can actually derive an embarassing number of additional instances for my Nine thanks to GND.
16:14:57 <koz_> (including Comonad)
16:30:18 <edwardk> koz_: that reminds me i need to ship the new distributive
16:30:27 <koz_> edwardk: Oh hi!
16:30:33 <koz_> Happy holidays!
16:30:42 <edwardk> likewise
16:31:04 <koz_> What's new in the new distributive?
16:31:54 <edwardk> i gave a talk in iceland about it a month or so back, but basically newtype Log f = Log { getLog :: forall a. f a -> a } -- acts as a sort of canonical 'Rep' for a representable functor
16:32:31 <edwardk> so providing that, and aarvar's better distribute function means we can provide "all the instances"
16:32:43 <edwardk> with a newtype and deriving via it means you can do stuff like
16:32:48 <koz_> What's the 'better distribute function'?
16:33:39 <edwardk> data V3 a = V3 a a a deriving (Generic, Functor, Foldable, Traversable, Distributive) deriving (Applicative, Monad, MonadFix, ...) via (Dist V3)
16:34:12 <edwardk> class Distributive f where dist :: FFunctor w => w f -> f (w Identity)
16:34:15 <koz_> Oh, that's pretty cool.
16:34:21 <aarvar> sup
16:34:32 <edwardk> class FFunctor f where ffmap :: (f ~> g) -> w f -> w g
16:34:35 <edwardk> heya aarvar
16:34:38 <koz_> Look forward to seeing it (and seeing what I can do for vector-sized with it).
16:34:40 <edwardk> aarvar has a nicer form of that
16:34:47 <edwardk> but it basically covers all the instances for your Nine
16:35:44 <edwardk> been off playing with logic programming for the holiday though so i haven't gotten back to it
16:36:57 <zachk> logic programming in what, edwardk ?
16:37:22 * hackage self-extract 0.4.1 - A Haskell library to make self-extracting executables  http://hackage.haskell.org/package/self-extract-0.4.1 (brandonchinn178)
16:37:28 <aarvar> edwardk: you've now reminded me, I started writing a blog post on this stuff that I should finish
16:38:06 <edwardk> zachk: github.com/ekmett/guanxi
16:38:21 <edwardk> zachk: started a little project for it
16:41:24 <ACheesyName> what does this mean generally? "Type signatures are only allowed in patterns with ScopedTypeVariables" I'm trying to attach a typesig to left hand side of a let binding, is that not allowed?
16:41:53 <Solonarv> It isn't, unless you enable the mentioned extension
16:42:05 <Solonarv> Just enable the extension and you're good :D
16:43:05 <edwardk> ACheesyName: you need to put {-# LANGUAGE ScopedTypeVariables #-} to the top of the module you are writing
16:43:27 <edwardk> ACheesyName: what you're trying to do wasn't supported by Haskell originally, but was added through that extension
16:43:45 <aarvar> why is it part of that extension anyway
16:43:58 <aarvar> seems orthogonal to scoped type variables
16:43:58 <ACheesyName> so there are basically no downsides to enabling it?
16:44:27 <edwardk> aarvar: binding a pattern like that is bringing into scope any type variables for existentials.
16:44:30 <aarvar> ACheesyName: It's fine. ScopedTypeVariables should probably be on my default
16:45:02 <edwardk> this affects how we have to do typechecking in precisely the same way as any of the other ways that ScopedTypeVariables binds variables
16:45:27 <edwardk> aarvar: its marginal in that it means some typechecking algorithms like HMF that could be otherwise used to typecheck everything in haskell can't be used
16:46:04 <edwardk> for ermine we stuck with HMF and used 'some' annotations rather than scoped type vars
16:47:56 <Solonarv> Signatures on pattern bindings don't inherently imply STVs, do they? It seems like it should be possible to allow only a restricted subset of pattern-binding signatures, such that they can't bring any type variables into scope
16:48:30 <Solonarv> (clearly '(x :: Int) <- readMaybe "4"' doesn't introduce any type variables)
16:49:33 <zachk> Solonarv, are you missing a Just there? 
16:50:35 <Solonarv> No, that's meant to be a binding in a do-block
16:51:28 <aarvar> edwardk: btw, have you written anything for deriving efficient generic instances of distributive for recursive types?
16:51:40 <edwardk> Solonarv: yeah you could come up with some sort of crippled subset with yet another extension, but there isn't a lot of value to adding lots of barely tested extra logic to cleave apart a distinction that isn't present today. it was fused into scoped type variables rather to avoid having to name yet another extension, iirc
16:52:11 <Solonarv> Ah, that makes sense
16:52:14 <aarvar> Was thinking I should try and find the code I had for that, and see if I can get it to work in more cases...
16:52:31 <edwardk> aarvar: nothing beyond what you saw
16:55:47 * ski misses return type ascriptions
16:56:29 <aarvar> ski: can you not just annotate the type of the rhs?
16:57:32 <Solonarv> Yes, but that's often more cumbersome
16:58:52 <Solonarv> consider: 'blah :: Int <- some huge expression', versus 'blah <- (some huge expression) :: IO Int' - and what if you want to have a type variable instead of IO? then you need ScopedTypeVariables anyway!
16:59:08 <aarvar> or with type applications you can use id @Blah $
17:00:03 <aarvar> unless the type is polymorphic..
17:02:50 <ph88> does anyone know why my extra library is not being found?  https://bpaste.net/show/a317561c5026
17:03:20 <ski> well, i was thinking of `foo (x :: Blah) :: Bleh = ...'
17:04:28 <aarvar> ski: foo (x :: Blah) = id @Bleh $ ...
17:04:44 <ski> heh
17:05:03 <ski> (using `$' is ugly)
17:05:48 <ski> (and the way `ScopedTypeVariables' works never made any sense to me)
17:15:40 <geekosaur> ph8, try it as pcre2-16
17:16:09 <geekosaur> the "lib" is inferred as part of the name on unixlikes
17:45:46 <ph88> hurray ! thank you geekosaur it works
18:27:44 <koz_> > getRandom :: IO Float
18:27:46 <lambdabot>  error:
18:27:46 <lambdabot>      Variable not in scope: getRandom :: IO Float
18:27:53 <koz_> Hmm, wait, no.
18:29:02 <int-e> % 42 -- this one?
18:29:02 <yahb> int-e: 42
18:29:26 <koz_> Lol.
18:29:29 <int-e> % import System.Random
18:29:29 <yahb> int-e: 
18:29:32 <int-e> % getRandom :: IO Float
18:29:32 <yahb> int-e: ; <interactive>:101:1: error: Variable not in scope: getRandom :: IO Float
18:29:38 <int-e> hmm
18:29:51 <koz_> Nah, it's called 'random'.
18:29:54 <koz_> I checked in a PM.
18:29:56 <glguy> > insistRandom
18:29:57 <int-e> ah
18:29:58 <lambdabot>  error: Variable not in scope: insistRandom
18:30:03 <ACheesyName> is there a show pretty-printer that works online (like based on a form that you can just paste stuff into)
18:50:17 <ph88> ACheesyName, pretty printer for what ?
18:50:58 <Solonarv> I'm pretty sure (heh) pretty-show compiles under GHCJS, so... :>
18:52:04 <Solonarv> > insistRandom -- glguy ;)
18:52:06 <lambdabot>  4
18:56:04 <N3RGY> Is this a bug? The following is OK: 
18:56:06 <N3RGY> type Show1 (f :: * -> *) = (forall s . Show (f s))
18:56:11 <N3RGY> the following is not:
18:56:19 <N3RGY> type Show1 (f :: * -> *) = (forall s . Show s => Show (f s))
18:56:29 <N3RGY> Error is "Expected a type, but ‘Show (f s)’ has kind ‘Constraint’"
18:56:38 <Solonarv> which GHC version are you on?
18:56:53 <N3RGY> 8.6.2
18:57:39 <Solonarv> did you enable QuantifiedConstraints?
18:57:43 <N3RGY> yeah
18:58:15 <geekosaur> trywithout the parens, I think someone noted the other day it doesnt lke them for some reason
18:58:24 <N3RGY> Also, FWIW, this definition is fine in the LHS of an =>, but just not in a constraint synonym
18:58:40 <N3RGY> Removing parens does not help
18:59:32 <ACheesyName> pretty-printer for "show" output. like this thing: http://hackage.haskell.org/package/show-prettyprint which I can't get to work
19:01:27 <Solonarv> "can't get to work" is a bit vague
19:05:17 <ACheesyName> well it installs OK but when I run it the output is the same as show (not pretty)
19:07:35 <N3RGY> Do you guys agree that my issue with a quantified constraint in a constraint synonym is a bug? Might open a ticket later if so
19:12:39 <int-e> N3RGY: I fully agree with the error... you seem to be using  Show (f s)  as a type? I don't see how  type Show1 (f :: * -> *) = (forall s . Show (f s))  could be okay though.
19:13:08 <int-e> (ghc-8.6.1 rejects it)
19:13:45 <N3RGY> int-e: What is wrong with it? I'm using it as a constraint synonym
19:14:06 <N3RGY> it's fine to have e.g. "type C x = (Num x, Show x)"
19:14:50 <N3RGY> I don't think 8.6.1 will reject it if you enable ConstraintKinds
19:17:04 <int-e> hrm, you're right.  type Show1 (f :: * -> *) = (forall s . Show s => Show (f s) :: Constraint)  seems to get accepted.
19:17:31 <int-e> So perhaps => defaults to * on its right unless explicitly told otherwise?
19:17:51 * int-e shrugs.
19:18:15 <N3RGY> Ah you're right, that seems to do it
19:18:39 <N3RGY> Thanks!
19:20:05 <int-e> N3RGY: But I agree that it's odd that the first one gets accepted and the other not.
19:23:22 <N3RGY> QuantifiedConstraints or whatever is pretty new, so it's not surprising there are some rough edges
19:23:22 <ACheesyName> what should I use for a pretty-printing library that can pretty-print the output of show or replace show in program?
19:23:25 <Solonarv> ACheesyName: when you run what?
19:23:40 <Solonarv> No library can change the definition of 'show'. Haskell doesn't work like that.
19:24:25 <ACheesyName> well it would be invoked by a different name of course .. I meant replace uses of show in my program with that better function
19:25:41 <N3RGY> ACheesyName: I can't tell exactly what your question is, but if you're looking for a good pretty-printing library then check out http://hackage.haskell.org/package/formatting
19:25:51 <Solonarv> and what trouble are you having with show-prettyprint?
19:26:22 <Solonarv> (at this point you should probably upload your code somewhere and post a link)
19:28:30 <ACheesyName> I'll try to produce a MWE maybe that will identify the problem by itself
19:53:04 <ACheesyName> ok here's the problem I'm having with show-prettyprint ... it fails to work even on very simple synthetic testcase: https://repl.it/repls/UltimateEvergreenCosmos ... maybe I'm invoking it wrong?
19:56:48 <Solonarv> I actually have no idea what's going on in that code
19:57:32 <Solonarv> also it doesn't run in the online repl, and I can't be bothered to start one on my shitty laptop
19:59:03 <Solonarv> ACheesyName: what do you mean by "fail to work"? what is is outputting, and what do you expect it to output?
20:07:23 * hackage grammatical-parsers 0.3.2 - parsers that combine into grammars  http://hackage.haskell.org/package/grammatical-parsers-0.3.2 (MarioBlazevic)
20:10:50 <ACheesyName> Solonarv: it behaves the same as ordinary putStrLn+show. whereas I would expect some line breaks and indentation
20:11:52 <Solonarv> ACheesyName: the documentation of show-prettyprint says that if it fails to parse the input, it won't do any formatting. That's probably what's happening.
20:13:00 <Solonarv> If you provide the *actual* output I might be able to say whether that's the problem
20:20:53 <ACheesyName> added actual output prefixed with "-- "
20:22:05 <Solonarv> Hm, that's a bit weird
20:22:27 <Solonarv> Might be a bug in the library? try a different one, there was one suggested a bit ago
20:27:41 <ACheesyName> maybe I'll try the "pretty-simple" package
20:29:02 <amalloy> ACheesyName: looking at the source of that prettyprinter it seems to only try to handle the outermost value being a constructor, a number, a string, or a character
20:29:21 <amalloy> so it would work if this thing were wrapped in a newtype but doesn't expect a bare list
20:29:47 <ACheesyName> oh wow. good find
20:30:22 <ACheesyName> ok it is working now. just use Just around the list
20:31:27 <Solonarv> well yes, that'd be the "outermost value is a constructor" case
20:31:37 <Solonarv> still, I'd switch to a less brittle library if I were you
20:32:07 <ACheesyName> looks like I'll have to .. it works on the simpler example but not on my actual use case which has more complex data types in it
20:42:17 <remexre> is there a good way to do a zipper that goes through multiple types of data structures? e.g. I want to build a Decl, which may contain a Stmt, which may contain an Expr; if the Expr is a Lambda, that can contain a Decl again
20:46:36 <Ackpacket> Why am I unable to use Finite 10 in part of a function signature after importing Data.Finite?
20:47:19 <Ackpacket> import Data.Finite;  myfunction :: Finite 10 -> Bool
20:47:37 <Ackpacket>  Illegal type: ‘10’ Perhaps you intended to use DataKinds
20:48:06 <geekosaur> imports don't enabel extensions for you
20:48:13 <monochrom> So is "10" a legal type if you don't turn on DataKinds?
20:49:06 <dibblego> remexre: do you want a zipper? i.e. the context? If so, take the derivative of the structure. Otherwise, if context is not needed, a prism will do this
20:50:00 <remexre> I want the context, since "technically" this is a zipper over a partial expression, i.e. the "tip" of the zipper is actually a Maybe Expr
20:50:31 <remexre> so I want to rebuild the expression afterwards
20:50:51 <Ackpacket> monochrom, tbh, I'm not sure how to answer that.  I don't know what DataKinds does, and I think the documentation from Data.Finite assumes some level of knowledge I haven't reached yet =\
20:51:07 <monochrom> What does the GHC User Guide say?
20:55:22 <lukelau> Is it possible to have cabal new-install copy the binary instead of symlink it?
20:55:50 <koz_> lukelau: Copy where?
20:55:53 <geekosaur> not presently. it's been requested
20:55:53 <monochrom> I don't know, but I would ask "cabal new-install --help".
20:56:19 <lukelau> —help seems to list the usual --prefix options which don’t seem to do anything
20:56:38 <lukelau> koz_: Specifically to a path I provide
20:56:45 <Ackpacket> monochrom, where can I see that?
20:56:53 <lukelau> I’m aware I can reach in and grab the binaries inside dist-newstyle, but its a bit dirty
20:57:45 <monochrom> Also https://cabal.readthedocs.io/en/latest/ and https://cabal.readthedocs.io/en/stable/ are the cabal user guide (depending on whether you are using a really new or a stable version.)
20:59:04 <monochrom> Ackpacket: the section title is "Type-Level Literals"
21:00:10 <koz_> Ackpacket: Also, check out Sandy Maguire's book, or jle`'s 'Introduction to Singletons' if you want a more 'tutorial-like' explanation.
21:00:36 <monochrom> I won't link to it because you should find the user guide that matches your GHC version and ideally you should actually just use the copy that's already on your hard disk.
21:10:52 * hackage nix-diff 1.0.6 - Explain why two Nix derivations differ  http://hackage.haskell.org/package/nix-diff-1.0.6 (GabrielGonzalez)
21:49:17 <vaibhavsagar> has anyone used Liquid Haskell with Nix on a project before?
21:49:41 <vaibhavsagar> I can't figure out how to include other modules in the current package
21:50:48 <vaibhavsagar> I suspect this has something to do with GHC_PACKAGE_PATH, which is not set
23:12:18 <Arahael> I need to open a whole bunch of files - most of them are in utf-8, so that's just too easy. However, 5 of them are in "ansi", what's the best way for me to open them? (What encoding should I use?)
23:17:15 --- mode: glguy set +v shiona
23:17:23 <shiona> Arahael: "ansi" is rather vague definition for character encoding. I would suggest starting with just ascii decoding and checking if something is wrong
23:18:15 <Arahael> shiona: Yeah, I think I'll probably "get by" with latin1, but the majority are in unicode.
23:18:18 <Arahael> (utf-8, anyway)
23:18:52 --- mode: glguy set +v nelsonhb
23:19:03 <Arahael> Given that hGetContents is lazy, how do I try one encoding, and then fall back to latin1 if it fails?
23:19:51 <Arahael> (Alternatively, I suppose I could assume cp1251)
23:20:15 <shiona> I have no idea, but I guess you could read the file to a ByteString and then try different decodings from there
23:20:52 <Arahael> Not a bad idea, thanks.
23:21:02 <Arahael> It's frustrating how systems are often so vague about encodings.
23:21:13 <shiona> yea
23:22:31 <Arahael> If I use the strict ByteString, I suppose that effectively makes hGetContents read everything?
23:23:53 <shiona> Once again I have no idea, but I've become very vary of ever expecting strictness to actually work, because there seems to always be some other part that's lazy or that the strictness is limited
23:23:59 <MarcelineVQ> should, if you use ByteString's hGetContents
23:24:14 <shiona> ok, good to know
23:24:18 <Arahael> MarcelineVQ: Thanks. :)
23:24:19 <MarcelineVQ> specifics here https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#v:hGetContents
23:25:26 <Arahael> MarcelineVQ: I can still set the handle's encoding, though - does that have any impact over the strict bytestring?
23:26:34 <MarcelineVQ> Dunno sorry hehe
23:28:41 <nelsonhb> At times, the mythical Kunlun Mountain has been confused with the modern Kunlun Mountains and with Kurung (or Kurung Bnam, possibly meaning "Kings of the Mountain" in Old Khmer (formerly known as Old Cambodian), and equivalent to the Sanskrit Śailarāja, also meaning "Kings of the Mountain", referring to a mythical holy cosmic mountain. it is associated with trans-Gangetic India, possibly the Malay peninsula or areas controlled by the Sailendra
23:28:41 <nelsonhb> thalassocracy.
23:28:46 <MarcelineVQ> https://hackage.haskell.org/package/base-4.11.0.0/docs/GHC-IO-Handle.html#v:hSetEncoding suggests two ways to avoid that question
23:30:31 <Arahael> Looks like I should be using OpenBinaryFile, now - thanks for the tip!
23:30:58 <MarcelineVQ> Arahael: alternatively ByteString.readFile opens the file in binary mode
23:31:12 <MarcelineVQ> If you aren't forced to use handles
23:31:48 <Arahael> Does it matter?
23:32:28 <Arahael> Looks like Data.Text.Encoding.decodeUtf8' is exactly what I want.
23:32:45 <MarcelineVQ> Does what matter?
23:33:44 <Arahael> MarcelineVQ: I'm not forced to use handles, but I've used openBinaryFile regardless.
23:33:48 <Arahael> MarcelineVQ: Does that matter?
23:35:04 <Arahael> Awesome! Just parsed over 96k lines of delphi in 4.13 seconds, with my naive-as-heck absolutely-unoptimised haskell parser. :)
23:35:46 <MarcelineVQ> Only insofar as other people have already written the code for you. ByteString.readFile wraps withBinaryFile, which you may or may not prefer over openBinaryFile
23:36:20 <Arahael> Fair enough - my earlier (naive) code used the handle form.
23:36:33 <Arahael> Still, it would only impact for lines if i were to change it.
23:36:57 <MarcelineVQ> withFoo are a good habit for resources
23:37:15 <Arahael> MarcelineVQ: I think openBinaryFile will automatically close the file.
23:37:45 <MarcelineVQ> When?
23:37:52 <Arahael> I now read it into a ByteString, then use decodeUtf8', and pattern match the resulting Either Exception Text. :)
23:38:14 <Arahael> MarcelineVQ: At the end of the successful read.  Oh - hGetContents shoudl clsoe it, not the openBinaryFile, my mistake.
23:38:17 * Arahael should be more precise.
23:38:36 <Arahael> "getContents. Read stdin strictly. Equivalent to hGetContents stdin The Handle is closed after the contents have been read."
23:38:44 <MarcelineVQ> Well, fair enough
23:40:28 <Arahael> I'm rather chuffed that I've now got a working Delphi parser. :) (Please don't ask me if it's correct and bug free - it's absolutely not!)
23:41:40 <Arahael> Can I see the maximum memory that was used by a haskell application?
23:41:52 <Arahael> (Particualrly a short-lived command line app)
23:42:46 <osa1> Arahael: compile your app with -rtsopts and use `+RTS -s` when running
23:52:28 --- mode: glguy set +v wei_
