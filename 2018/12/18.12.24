00:01:30 <amalloy> [Leary]: a functor for which `not` makes sense after parameterizing over bool ends up being isomorphic to Identity, doesn't it?
00:06:28 <[Leary]> amalloy: I don't think your statement is quite right, though that is what I was suggesting. There are a lot of useful newtypes isomorphic to Identity, e.g. Down, Dual, Sum, Product.
00:21:43 <amalloy> those are all useful because operations on them assume the contained type satisfies some typeclass. if the problem is "there's no good typeclass for not-ness", adding a newtype wrapper doesn't help - you might as well just define that typeclass and provide an instance for Bool
00:26:51 <[Leary]> It's true that the ones I listed are useful because of their interactions with typeclasses, but we really don't need to involve them here. My point was just that there's very little difference between `newtype SecretlyBool = Secretly Bool` and `Secretly Bool` where `newtype Secretly a = Secretly a`, but the latter allows you to reuse tools provided for Functor, Applicative, Monad etc, and of course you can still use coersions if you pref
00:26:52 <[Leary]> er.
00:32:40 <ahri> I have a (probably dumb) question that I've failed to find an answer for with google; can I lift a function over a newtype?
00:33:25 <[Leary]> That's more or less what coerce does.
00:34:40 <amalloy> makes sense, [Leary]
00:34:44 <ahri> oh, I read over the Coercible and CoercibleUtils and didn't glean that information. I will re-read
00:36:11 <[Leary]> % (coerce not :: Dual Bool -> Dual Bool) (Dual True)
00:36:11 <yahb> [Leary]: Dual {getDual = False}
00:38:00 <koz_> ahri: You wanna read about roles to understand what coerce actually does. The safe coercions paper is also instructive.
01:13:38 <fr33domlover> If I'd like to traverse some list or Vector and then further map/fmap its values, does it matter if I first apply 'traverse' and then 'map' on the result, or apply the function I want to map inside the traversal? https://share.riseup.net/#2JXvNlCLQC0C5PZxcPKNqQ
01:13:56 --- mode: glguy set +v chreekat[m]
01:15:20 <fr33domlover> The former looks nicer to me but wondering about any differences in compilation, or if there's some generally accepted defauly
01:15:24 <fr33domlover> *defauly
01:20:45 <ahri> am I wasting my time writing `liftC :: Coercible a b => (a -> a) -> (b -> b); liftC = coerce` ? I just find the in-line type annotations to be noisy and would prefer a 'lift' style
01:21:56 --- mode: leguin.freenode.net set +v chreekat[m]
01:21:56 --- mode: leguin.freenode.net set +v chreekat[m]
01:21:56 --- mode: glguy set -v chreekat[m]
01:22:03 <koz_> ahri: Have you looked at CoercibleUtils? Specifically 'over' and 'under
01:22:05 <koz_> ?
01:22:48 <chreekat[m]> When did roles become a common topic? They keep popping up in conversations and I feel like I missed the bus. [Messaging again after identifying to nickserv]
01:23:46 <ahri> koz_: I did, but I find those function signatures confusing
01:24:41 <koz_> ahri: That's understandable. Check the examples - the first (a -> b) function is just to help guide the typechecker.
01:24:58 <koz_> Consider the example for 'over'.
01:25:24 <koz_> If we specialize for 'over All', we get this type:
01:25:56 <koz_> over All :: (a -> a') -> All a -> All a'
01:26:01 <koz_> Does that make more sense?
01:29:26 <lyxia> chreekat[m]: since Zero Cost Safe Coercions are a thing
01:29:41 <koz_> lyxia: Yeah, and the safe coercions paper.
01:29:59 <lyxia> https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/coercible.pdf?from=https%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fsimonpj%2Fpapers%2Fext-f%2Fcoercible.pdf
01:37:20 <chreekat[m]> Neat
01:40:22 <ahri> koz_: it does make sense except for the `a` and `a'` - I don't see why I need a primed type variable there when it can only be `a`? I also don't understand why I need to the `All` bit when my `liftC` is happy enough without
01:40:34 <koz_> They could be different.
01:41:13 <ahri> is there a wider context then, not just newtypes?
01:41:31 <koz_> ahri: Yes, but in your case, thinking about it in terms of newtypes is a good place to start.
01:42:39 <koz_> Another type specialization to consider: 'ala Sum foldMap'.
01:46:17 <ahri> ah, that's more interesting
01:47:28 <koz_> 'ala' is generally a very cool function.
01:47:48 <koz_> % :t ala Sum foldMap
01:47:49 <yahb> koz_: (Foldable t, Num b) => t b -> b
01:48:11 <koz_> Hmm, wait a sec.
01:48:13 <koz_> % :t ala
01:48:14 <yahb> koz_: (Functor f, Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
01:48:23 <koz_> Wait, no, that's a different ala, sigh.
01:48:47 <koz_> % import qualified CoercibleUtils as CU
01:48:47 <yahb> koz_: ; <no location info>: error:; Could not find module `CoercibleUtils'; It is not a module in the current program, or in any known package.
01:49:00 <koz_> :(
01:52:33 <ahri> % :i ala
01:52:34 <yahb> ahri: ala :: (Functor f, Rewrapping s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s) -- Defined in `Control.Lens.Wrapped'
01:52:53 <ahri> hmm
01:54:40 <koz_> ahri: Yeah, different ala.
01:54:51 <koz_> Lens also has some scary-looking type sigs.
01:54:54 <koz_> @confusing
01:54:54 <lambdabot> Unknown command, try @list
01:54:59 <koz_> :t confusing
01:55:00 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
01:55:01 <ahri> I know :'(
01:55:28 <koz_> (well, scary-looking _and_ punny)
01:56:19 <merijn> If it's any consolation after like 10 years of haskell I still rarely use lens, except for some minor trivial lens operations like view/modify :p
01:58:26 <koz_> merijn: I've not been Haskelling for nearly that long, but I feel (and do) the same.
01:58:40 <koz_> Most of the time, every time I think I need lens, it turns out I really don't.
02:14:04 --- mode: glguy set +v mreh
02:14:07 --- mode: glguy set -v mreh
02:14:55 <ahri> I find that when using deeply nested structures things are a bit easier when using Lens, but I only really know the view syntax
02:15:39 <ahri> I tend to avoid it because of the type signatures though
02:16:32 <merijn> ahri: Right, but I can usually avoid having deeply nested structures :)
02:18:41 <mreh> I'm trying to lift an expression into my custom Servant Server monad, but I'm not sure if ServerT is really a monad transformer in the traditional sense
02:19:27 <mreh> I'm getting errors that I do not understand
02:21:43 <ahri> merijn: yeah, I've not really found a way to do that with Reflex because I end up with nice declarative streams whose state is often quite nested. maybe I'm doing it wrong
02:34:24 --- mode: glguy set +v t4nk122
02:34:40 --- mode: glguy set +v PatrickRobotham
03:21:08 <merijn> Time to cross my fingers than pretty-show is reasonably fast/efficient >.>
03:34:50 <cocreature> merijn: eh, iirc pretty-show literally calls show first (which isn’t particularly known for being fast), parses the output and then pretty prints it (which is definitely not going to make it faster)
03:35:14 <Athas> Does anyone know how serious https://ghc.haskell.org/trac/ghc/ticket/16057 is?
03:35:42 <Athas> I don't use Windows myself, but some of my users do.  Should I refrain from upgrading the Stack snapshot to GHC 8.6.3 to avoid that bug, or is it very rare?
03:40:49 <merijn> cocreature: I was calling show already anyway, because writing a manual pretty printer is too much work, but I'm calling it A LOT, so I'm not sure how costly the reparsing is going to be
04:07:29 <seishun> hpc: you mentioned that the infinite list needs to stay in scope to avoid recomputing thunks - what if it's returned by a function, and I immediately pass it to a recursive function, without assigning to a variable? would it be considered to be in scope until the recursive function returns?
04:09:09 <seishun> e.g. `recursiveSearch (makeInfiniteList foo bar) baz`
04:09:40 <merijn> seishun: Yes
04:09:47 <seishun> great, thanks
04:10:17 <merijn> seishun: He just means that if you have an infinite list as, e.g., a where binding of a function, then that list will get recomputed every call of the function
04:10:38 <seishun> ah, that makes sense
05:18:54 <fr33domlover> Is there a non-empty Vector? I have a (HashMap Text (Vector Text)) but non-empty vector is like no key in the map at all, I don't need that duplication, could happily use a non-empty vector and avoid representing impossible conditions
05:19:15 <fr33domlover> *empty vector is like no key in the map
05:19:55 <fr33domlover> I can use HashMap Text (NonEmpty Text) but NonEmpty is based on lists
05:20:39 <lyxia> I haven't heard of an existing library with such a thing
05:22:26 <merijn> fr33domlover: How many empty vectors do you expect to have that this matters?
05:22:28 <dibblego> T Vector
05:22:39 <dibblego> http://hackage.haskell.org/package/non-empty-0.3.0.1/docs/Data-NonEmpty.html#t:T
05:24:55 <ph88> i often write small throw away scripts in php, now i want to try to use haskell for it. I looked at some packages for shell like things, can anyone recommend any of them? so far i found https://github.com/yesodweb/Shelly.hs and https://github.com/Gabriel439/Haskell-Turtle-Library
05:25:31 <merijn> ph88: I know lots of people like turtle, but I haven't used it myself
05:25:44 <merijn> I mostly just write one-off things by hand
05:26:35 <ph88> at the moment i want to rewrite this one just for practice https://bpaste.net/show/712f66f70056
05:26:44 <ph88> i use regex a lot of these kinds of scripts
05:26:52 <ph88> usually go through lines and regex something
05:27:11 <ph88> probably something i could do with sed and awk as well .. but i don't know these tools well :P
05:27:13 <fr33domlover> dibblego, thanks, looks interesting
05:27:30 <merijn> ph88: For those kinds of things I tend to use conduit to stream lines of text and then attoparsec to parse each line
05:27:53 <ph88> do you have an example of this you wrote ?
05:28:00 <merijn> ph88: So instead of regexes I just use parser combinators, and conduit makes streaming stuff and doing line by line things fairly easy
05:28:19 <merijn> ph88: Eh, if you don't mind LOTS of unrelated junk around it ;)
05:28:24 <ph88> :p
05:28:37 <fr33domlover> merijn, many :P but I could use NonEmpty for now, I'm not optimizing yet (although switching from Vector to NonEmpty probably will do the opposite of optimization, but it's not critical right now)
05:29:16 <ph88> i think i prefer regex over parser combinator tbh ... it seems easier to do ..
05:29:20 <merijn> ph88: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/ingest-src/Main.hs#L201-L206 (streams a file from disk, converts to text, then parses entries and streams those into the database
05:29:40 <merijn> ph88: The actual parsers are: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/ingest-src/Parsers.hs
05:30:32 <ph88> ok that's nice, almost like production code :P
05:30:41 <ph88> i like it to be as minimal as the php script though
05:31:09 <merijn> ph88: parser combinators are more verbose than regexes, but usually by the 2nd or 3rd time I edit code I quickly realise the verbosity is a feature :p
05:32:02 <ph88> yes it's common as my small scripts increase in size i have to reread carefully what they actually do :D
05:32:06 <ph88> but it's ok
05:32:26 <merijn> ph88: For really small things I just use bash + grep, tbh
05:32:43 <ph88> i'm not good with bash and grep :(
05:43:43 <ph88> so i want to write this in haskell https://bpaste.net/show/712f66f70056 and i'm looking at turtle. I need a sum while going line by line, should i use a fold or statemonad ?
05:45:57 <ph88> hhmm docs talk about Control.Foldl so i guess ill use that
05:51:17 <deltasquared> asking this again because it seemed to get lost in the backlog the other day... given two objects of (Data.)Set, is there a convenient method to retrieve two lists, one of objects unique to s1 and one of objects unique to s2?
05:51:43 <deltasquared> I guess I could probably do something myself using intersection then disjunction or something, just wondering if there was an optimised path
05:53:42 <merijn> deltasquared: I don't think there's a specific function for it, no
05:54:21 <merijn> You can probably cobble together a more efficient version than first intersect, then disjunction, but I'd start with just that
05:55:24 <hpc> either way it's probably going to end up being O(n+m) anyway
05:55:48 <deltasquared> oh, I've got it. take the first set, then iterate over the second. s2 value present in s1 = remove from s1. *not* present in s1, add to a separate set
05:55:55 <deltasquared> any objects in s1 but not in s2 would be left behind
05:56:06 <deltasquared> naturally, immutable data structures to the rescue here
05:56:45 <deltasquared> that would in theory end up being O(s2) surely...
05:57:01 <deltasquared> then again that's assuming removals from s1 are constant, which is likely false if it's a tree under the hood
06:02:48 <lyxia> s2 * log(s1)
06:21:36 <hpc> is hackage slow for anyone else?
06:22:02 <hpc> hmm, https is faster
06:22:11 <Lycurgus> not me, instantaneous more or less
06:23:04 <Lycurgus> they're prolly in process of redirecting or rejecting all plain http
06:23:53 <Lycurgus> or starving it or whatever
06:41:22 <coldpress> i'm getting segfault when i do runInputT in Haskeline, anyone have any idea why? Here is the example I used: https://hackage.haskell.org/package/haskeline-0.7.4.0/docs/System-Console-Haskeline.html
06:41:23 * merijn sighs
06:42:00 * merijn resets the sign to"It has been: 0 days since my code didn't work due to me not remembering which way filter worked"
06:42:28 <hpc> hahahaha
06:42:52 <merijn> every freaking time...
06:45:49 <hpc> this is one of the few smart things ruby does
06:45:57 <hpc> array.select {predicate}
06:46:01 <hpc> array.reject {predicate}
06:46:58 <hpc> and in a very revealing look into its design decisions, perl calls it grep
06:49:09 <hpc> coldpress: i can't imagine what that package could be doing to segfault...
06:49:22 <hpc> coldpress: does a trivial program using getLine segfault too?
06:52:14 <ph88> what should i do to develop a library package? so far i only build binaries
06:52:27 <coldpress> +hpc: not sure how much more trivial it can be https://pastebin.com/ickQpTWT
06:52:40 <merijn> ph88: Instead of having "executable Foo" in your cabal file, write "library" :p
06:52:45 <ph88> ok
06:53:04 <hpc> coldpress: i mean the getLine from base, cut out the haskeline package entirely
06:53:16 <hpc> since i bet that's what it uses internally
06:55:12 <hpc> oh nvm, it's doing a lot more than that
06:55:16 <coldpress> +hpc: base has no issue
06:55:18 <ph88> i see some libraries that have different modules for ByteString, ByteString.Lazy, Text, String and so on .. can i instead just make a typeclass and have a single module of which the user can provide the type or is that not a good idea ?
06:55:32 <hpc> i wouldn't know where to start with debugging this
06:55:49 <ph88> merijn, appreciate your opinion :p
06:57:00 <merijn> ph88: Right now not quite. ezyang's work on backpack might make that reasonable in the future
06:57:52 <ph88> merijn, why is it not reasonable with backpack right now ?
06:58:42 <merijn> ph88: Oh, you can work with it right now, but it's still brittle, not a lot of support and lots of figuring stuff out yourself atm
06:59:01 <ph88> merijn, ok where do i start ?
06:59:40 <merijn> ph88: Probably by reading the stuff on his blog: http://blog.ezyang.com/category/haskell/backpack/
06:59:46 <ph88> ok great
06:59:47 <ph88> thank you
07:03:07 <ezyang> also https://ghc.haskell.org/trac/ghc/wiki/Backpack 
07:03:21 <coldpress> +hpc: you get a segfault on your ghc too?
07:03:44 <hpc> i don't have haskeline installed
07:04:25 <hpc> what os are you testing this on?
07:10:07 <coldpress> +hpc: i'm using GHCi 8.4.4, linux
07:11:35 * hpc vagrant ups
07:14:32 <hpc> stock centos box with The Glorious Glasgow Haskell Compilation System, version 7.6.3
07:14:40 <hpc> works using rpm-packaged haskeline
07:14:49 <hpc> admittedly, that's super old
07:16:04 <hpc> trying debian
07:17:59 <hpc> so, when i installed it on debian it also wanted to install libtinfo-dev
07:18:04 --- mode: glguy set +v zdenal__
07:18:09 <hpc> and libncurses5-dev and some other stuff
07:31:46 <coldpress> +hpc: oh right, I remember symlinking one of the existing libncurses.so to fix a ld -ltinfo problem
07:31:56 <coldpress> but I don't think that's on this partition
07:36:17 <ph88> ezyang, can i still use stack to start my project at least (generate files) .. but the for building i need to talk to ghc directly for backpack support ? or how can i use the same components as are available in a particular stack LTS ?
07:37:18 <merijn> Not sure if stack has any backpack support
07:37:23 <merijn> cabal-install should, though
07:40:26 <ph88> so if i want to mimic some stack LTS version, i should look up version numbers of packages and then use cabal sandbox ?
07:40:54 <merijn> ph88: With cabal-install I would recommend using new-build over sandboxes nowadays
07:41:07 <ph88> i have 0 experience with cabal :P
07:41:12 <ph88> ok new-build
07:41:29 <merijn> ph88: This is a good quick intro: https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
07:43:43 <Solonarv> ph88: actually, you can get the versions of "everything in a stackage snapshot" in a format that cabal understands
07:44:00 <ph88> how ?
07:44:17 <Solonarv> I don't remember exactly, give me a few minutes to find it
07:50:12 <Solonarv> ph88: download https://www.stackage.org/lts-FOO.BAR/cabal.config and point cabal at it (see the cabal docs for how to do that)
07:50:46 <ph88> cool
07:50:49 <ph88> thank you
07:57:19 <coldpress> lquit
08:06:33 <Gurkenglas> Is there a tool that you give a bunch of alias definitions and it tries to shorten a string?
08:07:17 <merijn> ugh... conduit doesn't have a foldl1 that's unsafe? :\
08:08:01 <Gurkenglas> (which you could then use to say "express LogicT in terms of Free" and "shorten this .hs file" etc)
08:08:08 <ph88> when a C library comes with a configure script or a cmake file how does that work together when i want to compile it into a haskell project ?
08:09:04 <merijn> I don't suppose there's a convenient way to have an "arbitrary size" vector? I need zero vector for pointwise operations without knowing in advance how many elements...
08:09:38 <Solonarv> if you meant Data.Vector.Vector, no
08:09:51 <vaibhavsagar> merijn: can you use Data.Sequence?
08:09:57 <merijn> vaibhavsagar: No
08:13:02 <ph88> is it possible to pass custom variable to GHC and then use a haskell script to modify some source files before compilation ?
08:13:47 <Solonarv> merijn: could you use a wrapper type? for example: data ZipVector a = Repeat a | Finite (Vector a)
08:14:15 <merijn> Solonarv: I dunno? Depends on how expensive it'd be to unwrap every iteration
08:15:09 <Solonarv> I don't know what operations you're trying to implement, so that's all I could think of
08:15:40 <devoid_> language.
08:15:41 <merijn> Solonarv: Basically I have a stream of vectors that are chunked into groups and folding each group by pointwise summing the vectors
08:15:47 <Solonarv> Note that this type can't have a valid Traversable instance compatible with "Repeat foo means an infinite list of repeated foo"
08:16:01 <merijn> Solonarv: So I need a "0" element to start accumulating from
08:17:03 <Solonarv> Hmm... 
08:19:25 <devoid_> hello my fellow #haskell users
08:19:32 <devoid_> how are you doing on this fine day?
08:22:23 <vaibhavsagar> well, thanks devoid_, and you?
08:22:29 <Solonarv> merijn: https://gist.github.com/Solonarv/0a84ee87299072f9d7bb8d7d9567d012 try this?
08:22:30 <devoid_> verty good
08:22:35 <devoid_> better than most days
08:24:17 <merijn> Solonarv: hmmm, maybe
08:29:33 <ph88> how can i run code automatically when my library is getting compiled ?
08:36:57 <ph88> be back later
08:44:50 <Welkin> does anyone here use any message brokers like RabbitMQ or Apache Kafka (or ZeroMQ)?
08:45:11 <Welkin> I don't see many up-to-date or widely used clients for them
08:46:12 <Welkin> Haskell has channels, which reduce the need for message brokers in simple cases, but what about more complex ones?
08:46:29 <Welkin> do you build your own using channels or do you use a third-party message broker?
08:51:48 <merijn> Welkin: Depends what kinda usecase you're thinking of?
08:51:52 <Solonarv> @tell ph88 depends on your use case; CPP (the C preprocessor, which GHC has support for), Template Haskell, and type-level programming should cover most of them
08:51:52 <lambdabot> Consider it noted.
09:04:25 * hackage blake2 0.3.0 - A library providing BLAKE2  http://hackage.haskell.org/package/blake2-0.3.0 (jgalt)
09:19:02 --- mode: glguy set +v rzp
09:24:52 <sproingie> Welkin: there's the amqp package for rabbitmq, and pretty sure there are multiple kafka clients
09:57:29 <t7> i'm not convinced fundeps are a wonderful idea 
09:57:54 <t7> maybe its just with all the extensions on top, gets a bit surprising sometimes 
09:59:48 <hpc> how about type families?
10:00:19 <hpc> they're superficially a different sort of math, even though they express nearly the same thing
10:12:55 * hackage quickcheck-classes 0.6.0.0 - QuickCheck common typeclasses  http://hackage.haskell.org/package/quickcheck-classes-0.6.0.0 (chessai)
11:02:00 <droplet> if i have two Getters into the same type, can I run them 'in parallel' to get a new getter giving the pair
11:02:14 <droplet> or more generally a given function of the two outputs
11:06:05 <koz_> droplet: So, are you saying something like 'does there exist a function foo :: (s -> a) -> (s -> b) -> (s -> (a, b))'?
11:07:52 <Welkin> I almost thought that was going to be the s combinator
11:07:55 <hpc> is this for a specific library?
11:08:20 <koz_> % :t \f g -> bimap f g . join (,)
11:08:20 <yahb> koz_: (a -> b) -> (a -> d) -> a -> (b, d)
11:08:38 <droplet> koz_: Not directly, I'm asking something closer to 'is there a lens combinator which can combine the lenses _1 and _2 and behaves: (2,3,4) ^. (foo _1 _2) == (2,3)'
11:08:38 <koz_> droplet: ^ will give you foo.
11:09:06 <koz_> droplet: I'll let someone lens-capable answer that one, but given your 'more generally' question, my code answers that.
11:09:47 <hpc> :t _1
11:09:48 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
11:09:53 <droplet> koz_: sure, i can do it by running the lenses as functions, then combining and making a new getter but i was wondering if there's a lens-direct way
11:11:36 <droplet> koz_: liftA2 (,) also works for your foo
11:11:52 <Welkin> droplet: ask in #haskell-lens or just look in the docs
11:12:02 <Welkin> all functions/operators are listed in a bug table
11:12:04 <Welkin> big table*
11:12:06 <koz_> I always forget that (->) a is an Applicative. Thanks droplet.
11:12:14 <koz_> Welkin: Lol@bug table.
11:12:39 <droplet> Welkin: i'll try there, i'm not familiar enough with all the type signatures for the docs to make much sense yet
11:13:01 <koz_> :t liftA2 (,)
11:13:02 <lambdabot> Applicative f => f a -> f b -> f (a, b)
11:13:16 <droplet> thanks both
11:13:25 * hackage intero 0.1.35 - Complete interactive development program for Haskell  http://hackage.haskell.org/package/intero-0.1.35 (ChrisDone)
11:27:09 <Gurkenglas> droplet, http://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Unsound.html#v:lensProduct
11:46:31 <bifunc2> Data.Word8: https://hackage.haskell.org/package/word8-0.1.2/docs/src/Data-Word8.html
11:46:31 <bifunc2> If you look, for instance, at "isDigit :: Word8 -> Bool" and "_space = 0x20". Neither, and nothing else in the library, is marked as INLINE or INLINABLE.
11:46:32 <bifunc2> Is this problematic? Could this cause GHC to not inline these simple things?
11:46:49 <bifunc2> If I use this library, I mean.
11:48:02 <zachk> iirc ghc can choose to inline things without a pragma, and you need to use a pragma to make sure certain things don't get inlined 
11:48:51 <ph88> is it possible to run some code before compiling with ghc ? i need to configure some C sources and do some other things
11:52:17 <geekosaur> ghc is a compiler, not a build tool
11:52:42 <vaibhavsagar> ph88: sounds like a job for your build system
11:55:58 <ph88> well can i do it with cabal or stack ?
12:00:37 <geekosaur> build-type: custom, then a configure script
12:02:57 <Welkin> stack is not a build tool either
12:03:02 <Welkin> cabal is the build tool
12:06:58 <hpc> stack only controls the environment in which the build happens
12:07:18 <hpc> (when used correctly - package.yaml is an invasive mistake of a feature)
12:08:54 <ph88> invasive mistake of a feature? o_O
12:10:26 <Welkin> he means to say that stack is an on-purpose mistake and shouldn't be used
12:11:54 <ph88> how do i interface to a library already installed on my system? I mean code-wise .. i already found out about pkgconfig-depends
12:15:32 <hpc> oh yeah, had to afk a bit
12:15:53 <hpc> so the issue with package.yaml is that it takes over the responsibilities of the cabal file
12:16:16 <hpc> where before you have this nice separation of concerns between compiler, build tool, environment tool
12:21:02 <ph88> i found an example of somebody who uses a system lib with pkgconfig-depends .. it seems to use the cpp preprocessor https://github.com/Daniel-Diaz/pcre-light/blob/master/Text/Regex/PCRE/Light/Base.hsc#L103 is there any other other way to avoid using the preprocessor ? :/
12:33:12 <Clint> ph88: you want to use the C FFI without including C header files?
12:38:32 <dmwit> Yes, not all uses of the C FFI require CPP.
12:39:08 <dmwit> You can specify the C header file when you do a foreign import.
12:39:28 <Welkin> what about CCCP?
12:39:33 <ph88> ah that's great dmwit !
12:40:25 * hackage unpacked-maybe-numeric 0.1.0.0 - maybes of numeric values with fewer indirections  http://hackage.haskell.org/package/unpacked-maybe-numeric-0.1.0.0 (chessai)
12:41:19 <ph88> Welkin, https://en.wikipedia.org/wiki/CCCP_(disambiguation)  ??
12:42:08 <dmwit> Don't waste too many cycles on Welkin's comment, I think. It was just a dumb joke.
12:44:10 <ph88> this looks nice to use https://hackage.haskell.org/package/c2hs  any other handy tools i could use for FFI stuff ?
12:44:35 <dmwit> The other competitor in that space is hsc2hs.
12:45:27 <Welkin> and inline-c
12:45:28 <ph88> is hsc something i should go into ?
12:45:52 <Clint> bindings-DSL is a thing
12:46:38 <hpc> i still think it was a missed opportunity with C++ to name the preprocessor CPPPP
12:46:50 <ph88> Clint, reading from the description i think bindings-DSL is for exposing an FFI from haskell code. But i want't to call into a C library
12:47:18 <geekosaur> both, I think
12:51:03 <ph88> hmm ok .. well since i don't know which is best for me i'll just start of with c2hs
13:04:28 <ph88> c2hsc *
13:13:34 <fweht> hm i always thought let-expressions basically do substitution, now im trying to read a text on type inference and here it seems as let-expressions were something more subtil...  im confused
13:14:00 <fweht> *subtle
13:16:43 <ph88> i got a hsc and a c file now .. what's the next step ? what tool can i use to get some haskell types ?  i tried hsc2hs .. but this tool complains about a missing bindings.dsl.h file which i can't find on my system
13:17:38 <c_wraith> ph88: did you install bindings-dsl?
13:17:47 <ph88> no
13:18:06 <c_wraith> ph88: https://hackage.haskell.org/package/bindings-DSL
13:18:18 <ph88> ok so c2hsc is supposed to work together with bindings-dsl ..
13:18:24 <ph88> funny that it doesn't mention that :|
13:18:58 <c_wraith> bindings-DSL adds a bunch of macros c2hsc can use
13:20:56 <ph88> seems mandatory to me since there wasn't an option in c2hsc "do not use bindings.dsl.h file" or some other option not to use bindings-dsl stuff
13:23:15 <ph88> ok i have this file now, but it's located in ~/.stack/snapshots/x86_64-linux-tinfo6/lts-13.0/8.6.3/lib/x86_64-linux-ghc-8.6.3/bindings-DSL-1.0.25-2kwolusgL8L5V1adlcppFi/include/bindings.dsl.h  .. not the nicest path o_O
13:23:36 <jle`> fweht: you can think of it as substitution, but it's just that type inference has to treat them in a certain way for things to work out as expected
13:23:41 <monochrom> fweht: Type checking and evaluation can be quite different, almost independent of each other.
13:24:04 <jle`> and yeah, don't confuse the evaluation (substitution) from the type checking
13:24:09 <jle`> s/from/with
13:24:19 <fweht> ok, but if let-expressions just denote substitutions, they look like syntactic sugar to me
13:24:36 <monochrom> That's the evaluation POV only.
13:24:49 <fweht> monochrom: ok!
13:25:00 <fweht> is there some simple example which could illustrate this?
13:25:13 <jle`> fweht: yeah, you're confusing the actual evaluation of them with the type inference used to type them
13:25:54 <jle`> fweht: illustrate what?
13:25:59 <monochrom> "let f = \x -> x in (f 1, f True)" vs "(\f -> (f 1, f True)) (\x -> x)".
13:26:38 <jle`> fweht: you should be able to replace 'let' with subsitution.  but type checking has to take care to ensure that this is possible
13:26:47 <fweht> jle`:  the difference between those POVs...  ill have a look at monochroms example for a moment
13:27:07 <jle`> fweht: what you're reading is basically saying that type inference has to take care to be consistent with let-expressions-are-substitution
13:27:14 <monochrom> Most people want the former to be OK, so HM adds a "let-polymorphism" step to help.  Most people don't want a rank-2 system, so they want the latter to be a static error.
13:27:15 <jle`> it's not saying that let expressions aren't substitutions
13:27:46 <monochrom> Despite the fact that in untyped lambda calculi they both succeed in evaluation.
13:28:12 <monochrom> (And give the same answer.)
13:28:22 <jle`> fweht: let's say you want to type-infer `let f z = blah in (f x, f y)`.  the result should be the same as `(f z x, f z y)`
13:28:37 <jle`> fweht: when you implement type inference for this, you have to be sure to do it correctly so that the former gets the same type inferred as the latter
13:28:44 <jle`> fweht: that's what the text you are reading is saying
13:28:53 <jle`> it isn't saying that let's are not substitution
13:29:01 <jle`> it's talking about how to do type inference with lets
13:29:38 <fweht> ok i think i get it
13:29:40 <jle`> and, properly implementing type inference in the presence of let's has some (perhaps unexpected) subtleties
13:29:47 <ph88> hurray i have a hs file from a C header file :D
13:30:24 <zachk> aren't there let's in core?
13:30:32 <monochrom> Yes.
13:31:01 <jle`> (my example let expression and subsitution does have some errors, i realize now, heh)
13:31:06 <merijn> Core doesn't have type inference, though :p
13:32:09 <fweht> ok but you would also say i could implement the inference by first performing (syntactical, untyped) substitution and then do interference on the resulting term?
13:32:13 <jle`> fweht: in the end, you want let-substitution to type-infer to the same type as the original let expression.  the subtlety is implementing this correctly to match expectations
13:32:53 <monochrom> fweht: What would your system say about "if True then 1 else 'x'"?
13:33:36 <fweht> ah ok now i start to see the problems
13:34:07 <fweht> but how does if then else connect with let again?
13:34:23 <fweht> can ITE be rephrased as let-expression or something?
13:34:42 <monochrom> I am setting up for a "you don't want base type checking on evaluation, not even partial evaluation".
13:34:53 <monochrom> s/want base/want to base/
13:34:56 <fweht> ok
13:35:44 <monochrom> Although, I haven't worked out all the details. You should explore. But not armchair-explore. Write down the typing rules and implement a type checker. See what happens.
13:36:24 <fweht> sounds hard but i see your point
13:36:30 <merijn> monochrom: Tell that to the dependently typed language implementors ;)
13:38:16 <jle`> fweht: note that you're reading something that is talking about implementing type inference, so it's probably something that for the most part comes up mainly when implementing type inference
13:38:29 <jle`> so it is potentially hard to appreciate unless in the context of implementing type inference
13:38:35 <monochrom> It is possible that substitute-then-check is simply too slow.
13:39:14 <fweht> jle`: seems fair
13:40:05 <monochrom> If I have a chain of "let y=x+x in let z=y+y in let a=z+z in let b=a+a in ..." if this chain has length n then your substituter will spend 2^n time to build a 2^n-huge thing.
13:40:35 <monochrom> (This is also why even evaluators don't do it, they use environment i.e. sharing instead.)
13:40:35 <fweht> yup
13:41:19 <monochrom> If your type checker also fakes substitution by shared environment, then you're very close to going back to HM let-generalization. >:)
13:42:15 <fweht> ok, so its more about complexity and less about math then
13:42:19 <fweht> this helps me a lot
13:42:23 <fweht> just to keep this in mind
13:43:01 <merijn> fweht: Incidentally, I missed the start so not sure if anyone pointed you that way yet, but if you're curious about implementing type checkers, you should grab a copy of TaPL
13:43:04 <merijn> @where tapl
13:43:04 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
13:43:09 <jle`> fweht: there is one important distinction in typechecking too, there's let-substitution vs. lambda-substitution
13:43:23 <jle`> fweht: as in, let x = y in blah vs. (\x -> blah) y
13:44:04 <jle`> this difference is perhaps more fundamental, and actually sometimes comes up in practice too
13:44:07 <jle`> when writing code
13:44:30 <jle`> s/fundamental/interesting (?)
13:44:59 <fweht> ok!
13:45:39 <fweht> merijn: thanks for your input, im more curious about the math / type theory  then about implementation
13:46:07 <fweht> actually i want to understand exactly the type theoretic underpinnings of haskell and leave the efficient implementation to someone else!
13:46:08 <merijn> fweht: TaPL covers both type theory (including various proofs), as well as implementation
13:46:14 <monochrom> In terms of theory you can always go full dependent typing and be done with it. >:)
13:46:15 <fweht> sweet!
13:46:59 <merijn> fweht: tbh, TaPL is the de facto standard intro text for Type theory, it will covers everything from untyped lambda calculus up to way more complex than haskell
13:47:25 <Tuplanolla> Surely, by "be done with it" you actually mean "never be done with anything again", monochrom.
13:47:35 <merijn> So if you have any interest in that stuff it's hard to go wrong and it will get you up to speed with everything you need to dive into papers for more complicated things
13:48:06 <geekosaur> Tuplanolla, I'd argue that's what it usually means, when you look closely
13:48:45 <monochrom> The mathematician sense of "done" and the engineer sense of "done" are quite opposite.
13:48:56 <iqubic> How the heck does the recursion-schemes library work?
13:49:02 <iqubic> Like how the heck do I use it?
13:49:20 <merijn> iqubic: Step one, melt your brain :)
13:49:56 <fweht> actually i got interested in the topic because i wanted to understand why not everyone is going straight dependent types a la idris but instead things like liquid haskell pop up
13:50:08 <iqubic> merijn: I'm not asking about how the functions do what they do, but I'm asking about how I should use those functions
13:50:25 <fweht> and i want to get a better grasp on mathematical foundations, but i guess thats quite a different perspective
13:50:43 <monochrom> The mathematician just wants "proof of existence of solution"; however it must be "as generalized as possible". The engineer just wants to solve one special case at hand, but it must be an effective concrete answer.
13:52:26 <monochrom> fweht: One criterion of automatic type inference is that it must terminate. There is also a soft deadline that "if it finishes in polymonial time that's great".
13:52:28 <iqubic> monochrome: That reminds of calculus theorems like "the intermediate value theorem"
13:53:43 <geekosaur> fweht, not everyone wants to carry proofs around everywhere
13:53:46 <monochrom> I think eventually we are relaxing to "NP is OK if in practice/average it is polynomial time"
13:54:18 <iqubic> So how the heck does on use the recursion-schemes library?
13:54:37 <monochrom> Also not everyone wants to write their own proofs whenever Godel incompleteness kicks in. >:)
13:54:56 <iqubic> I want to simplify the recursion in my simple AST evaluator.
13:55:02 <Tuplanolla> You ignore all the things except for `cata`, iqubic.
13:55:12 <monochrom> (In fact if you ask me, the halting problem and Godel incompleteness limits humans as much as computers.)
13:55:52 <iqubic> Tuplanolla: i was already planning on doing that. Now I need to know how to use cata effectively.
13:56:08 <geekosaur> agreed... althguh there's several books arguinbg about that topic
13:56:16 <Tuplanolla> @google haskell blog post on how to use cata effectively
13:56:20 <lambdabot> http://dev.stephendiehl.com/hask/
13:56:20 <lambdabot> Title: What I Wish I Knew When Learning Haskell 2.3 ( Stephen Diehl )
13:56:38 <hpc> monochrom: brains are arguably finite state machines, and subject to far more pedestrian mathematical limits ;)
13:56:46 <Tuplanolla> I hit the universal result, but you can refine the search further.
13:56:53 <iqubic> Tuplanolla: Not really what I wanted.
13:57:37 <devoid_> hello kubrat
13:57:39 <devoid_> kqr: 
13:57:40 <devoid_> iqubic: 
13:57:45 <devoid_> how are you oin gotday?
13:57:48 <devoid_> doing
13:58:12 <iqubic> I'm doing great. I just want to learn how to use Cata to avoid explicit recursion.
13:58:52 <Tuplanolla> I can't fault Stephen for wishing to know everything, but I'd prefer it if this thing didn't come up with every search.
13:59:39 <iqubic> How is this for a source: https://wiki.haskell.org/Catamorphisms
13:59:43 <iqubic> ??
14:00:13 <merijn> > (0/0) < (1 :: Double)
14:00:15 <lambdabot>  False
14:00:23 <merijn> > (0/0) > (1 :: Double)
14:00:26 <lambdabot>  False
14:00:30 <iqubic> Nope... To much theory and not enough practical code.
14:00:42 <iqubic> > (0/0) == (1 :: Double)
14:00:43 <lambdabot>  False
14:00:51 <iqubic> WTF?!?!
14:01:07 <merijn> iqubic: 0/0 is NaN
14:01:23 <iqubic> I see.
14:01:58 <hpc> that's IEEE floats for you
14:02:06 <iqubic> So, what I need is a source that shows some practical examples of how to actually use Cata. I don't want to have to wade through a big slog of theory.
14:04:08 <monochrom> I suspect that those who know are stuck in airports because Christmas Eve peak hours. >:)
14:04:31 <monochrom> Or train stations for the Europeans.
14:04:58 <monochrom> (Oh the Chinese will have their turn near Chinese New Year.)
14:05:05 <iqubic> LOL. I really don't care about Christmas, as I am a Jew.
14:05:16 <iqubic> Sorry for offending you.
14:06:09 <merijn> monochrom: Hey! Some of us are at home stressing over their thesis instead >.>
14:06:23 <monochrom> All the same, even the workaholic Scrooge was unable to get any employee on Christmas Day.
14:07:01 <iqubic> And the Grinch wasn't much better.
14:08:09 <DigitalKiwi> ahem I think you mean boxing day eve
14:08:30 <hpc> i hear he got much nicer after he married into the mcduck family
14:08:30 <iqubic> Now there's a label I can get behind.
14:08:38 <monochrom> I know right? Boxing Day Sale starts this evening online.
14:08:57 <hpc> and tomorrow is unboxing day!
14:09:12 <iqubic> So I'm going to start reading the bananas, lenses, envelopes, and barbed wire paper.
14:09:31 <iqubic> Hopefully this isn't tons and tons of theory with no practical applications.
14:10:01 <merijn> argh...
14:10:07 <Tuplanolla> We're not stopping you, but it would have been easier to search for the blog posts, iqubic.
14:10:26 <merijn> After sorting a list 2 elements are out of sorted order...
14:10:46 <merijn> I am now taking bets on an incorrect sort due to NaNs in the data..
14:10:56 <hpc> merijn: sort it again, it'll work this time for sure
14:11:42 <hpc> merijn: in C++, there was a bug where sorting an array with NaNs in it caused invalid memory access
14:11:55 <monochrom> haha that's extreme
14:11:58 <iqubic> https://ulissesaraujo.wordpress.com/2007/12/19/catamorphisms-in-haskell/
14:12:06 <merijn> Ding, ding, ding
14:12:06 <iqubic> https://thealmarty.com/2018/10/23/programming-with-bananas-in-haskell-versus-ocaml/
14:12:11 <merijn> Ok, so...fun fact
14:12:25 <merijn> sortBy and sort are unsafe for [Double] with NaN inside
14:12:33 <iqubic> Alright, I'm going to stop posting the URL of every blog I find.
14:12:44 <merijn> Not really *that* fun of a fact, but...
14:12:58 <monochrom> It is OK to be sarcastic!
14:13:02 <DigitalKiwi> unfun fact
14:13:05 <iqubic> Nice to know nonetheless
14:14:37 <hpc> merijn: omg you weren't kidding
14:14:43 <hpc> Prelude Data.List> sort [1, 2, 3, (0/0)]
14:14:43 <hpc> [NaN,1.0,2.0,3.0]
14:14:43 <hpc> Prelude Data.List> sort $ sort [1, 2, 3, (0/0)]
14:14:43 <hpc> [1.0,2.0,3.0,NaN]
14:14:43 <merijn> hpc: No
14:14:52 <hpc> that's pretty bad
14:14:59 <merijn> hpc: Tell me about it
14:15:22 <Tuplanolla> Is it just the nan that's misplaced, merijn?
14:15:30 <merijn> Tuplanolla: No
14:15:39 <Tuplanolla> Sweet.
14:15:39 <merijn> There are non NaN elements out of place
14:16:26 <Tuplanolla> I can get my 35C3 depression started early.
14:16:44 <iqubic> I only see the NaN out of place there. Nothing else.
14:17:02 <DigitalKiwi> if you sort it a third time it's wrong again 
14:17:13 <merijn> iqubic: my data has more elements than hpc's example and there the NaN is out of place and so are some other elements
14:17:21 <iqubic> Ah.
14:17:44 <iqubic> Did Dijkstra coin the phrase "X considered harmful"?
14:17:54 <merijn> Technically, no
14:18:17 <zachk> Tuplanolla, whats 35C3 ?
14:18:21 <iqubic> I just now found the thing "goto considered harmful"
14:18:22 <merijn> Because the title of that Dijkstra essay was changed by his editor (another famous CS guy, but I forgot who)
14:18:26 <Tuplanolla> It's the annual "everything is bad and expected to get worse" conference, zachk.
14:18:32 <zenspider> iqubic: iirc, he didn't even title the paper that... Wirth did
14:18:35 <merijn> iqubic: Dijkstra's original title was "The case against goto"
14:18:47 <iqubic> Meijer et. al go so far as to condemn functional programming without recursion schemes as morally equivalent to imperative programming with goto. 
14:18:58 <iqubic> And then it links to the Dijkstra paper.
14:19:14 <iqubic> That's an actual quote from this blog post I'm reading.
14:19:32 <merijn> iqubic: I understand the argument, but practically speaking recursion schemes always felt harder and more cumbersome than the simple implementation :p
14:19:45 <iqubic> Really? How so?
14:20:14 <iqubic> Also, the above statement is not my opinion, as I am too ignorant to have my own opinion.
14:20:16 <merijn> iqubic: because half those schemes requires like 70% of my brain to even figure out how to fit things into them
14:20:30 <iqubic> Ah. I see.
14:20:42 <iqubic> I'm just going to stick to the simple Cata for now.
14:21:48 <Ariakenom> > 1 `S.member` S.fromList [1,0/0,2]
14:21:50 <lambdabot>  False
14:22:59 <iqubic> What the heck?!?!
14:23:11 <Ariakenom> nan is bad for you
14:23:12 <iqubic> > (1::Double) `S.member` S.fromList [1,0/0,2]
14:23:13 <lambdabot>  False
14:23:57 <iqubic> So I guess when I'm implementing my equation parser I should have it return a "Maybe Int" just so I don't have to deal with accidentally returning a NaN
14:24:25 <iqubic> Or rather "(RealFloat a) => Maybe a" but you get the idea.
14:24:46 <hpc> > S.fromList [1, 0/0, 2]
14:24:48 <lambdabot>  fromList [1.0,NaN,2.0]
14:25:14 <hpc> oh, it's traversing the tree the wrong way maybe
14:25:17 <iqubic> Is there a general super class that refers to *ALL* real numbers, whole, rational, or otherwise?
14:25:53 <zenspider> comparing floats with == (or equiv) is a bad idea... What does S.member use?
14:26:20 <iqubic> I was looking for that the other day an decided that "RealFloat" was the closes I was going to get to a true encapsalation of all numbers.
14:26:41 <zachk> > (0/0) == (0/0) 
14:26:43 <lambdabot>  False
14:26:44 <Tuplanolla> It uses `compare` to build a tree, zenspider.
14:26:45 <geekosaur> == is the only way it has
14:26:55 <geekosaur> or compare whih depends on ==
14:26:57 <Ariakenom> :t S.fromList
14:26:59 <lambdabot> Ord a => [a] -> S.Set a
14:27:01 <zachk> how can you even check for a NaN then ? 
14:27:10 <iqubic> https://hackage.haskell.org/package/containers-0.6.0.1/docs/src/Data.Set.Internal.html#member
14:27:16 <Ariakenom> :t \x -> guard (isNaN x) *> Just x
14:27:17 <zenspider> such is the way of floats... :/ 
14:27:17 <lambdabot> RealFloat b => b -> Maybe b
14:27:26 <iqubic> That's the official source.
14:27:41 <iqubic> :t (*>)
14:27:42 <lambdabot> Applicative f => f a -> f b -> f b
14:27:49 <iqubic> :t guard
14:27:50 <lambdabot> Alternative f => Bool -> f ()
14:28:16 <Tuplanolla> I have a relevant anecdote. This semester one of my students made a roundabout floating-point computation in one of the exercises and felt the need to accompany it with the comment "this is dirty". I've never been so proud.
14:28:21 <Ariakenom> actually had someone in here asking questions as to why something didn't terminate when he added a zero [1..10_000_000]
14:28:34 <zenspider> Tuplanolla: hah! good job
14:28:41 <Ariakenom> turns out that was [Float] and that was when the precision went below 1
14:31:02 <Ariakenom> also had a DB course that used float for money. If you implemented a formula as given in the instructions you got the wrong answer due to rounding ... :|
14:31:03 <merijn> zenspider: Comparing floats with == is perfectly fine if you know what you're doing
14:31:11 <merijn> It's just the NaN break Set too, apparently
14:31:27 <iqubic> Why does the recursion-schemess library want you to parameterize your datatypes like this: http://dpaste.com/1XNMCY3
14:31:31 <merijn> Which is unfortunate, as it means we have to pick between IEEE754 compliance or nice toys
14:32:15 <iqubic> why does it want that parameterized version istead of this: http://dpaste.com/2BQNFS9
14:32:57 <monochrom> I think that blaming NaN is blaming the messenger.
14:33:43 <merijn> > (1/0) > (1 :: Double)
14:33:45 <lambdabot>  True
14:33:49 <merijn> > (1/0) < (1 :: Double)
14:33:51 <lambdabot>  False
14:34:07 <iqubic> Huh?!?!
14:34:09 <monochrom> Likewise if you have a student's C program that segfaults and the segfault point is inside the RTS's free() you know that it is not the fault of free().
14:34:15 <merijn> iqubic: 1/0 is positive infinity
14:34:25 <iqubic>  > (1/0) `compare` (1 :: Double)
14:34:35 <merijn> > (1/0) :: Double
14:34:37 <lambdabot>  Infinity
14:34:43 <Tuplanolla> > length [0, 256 .. 65535 :: Word8]
14:34:49 <lambdabot>  mueval-core: Time limit exceeded
14:34:53 <iqubic> > (1/0) `compare` (1 :: Double)
14:34:56 <lambdabot>  GT
14:35:01 <iqubic> Oh, I see.
14:35:17 <iqubic> +infinity is greater than all reals.
14:36:41 <benzrf> iqubic: so that you can express your type as the fixed point of a functor
14:36:50 <benzrf> that's kind of the whole trick of recursion schemes
14:37:01 <iqubic> I see.
14:37:10 <benzrf> have you seen the definition of cata?
14:37:28 <iqubic> No. I haven't looked at that ever.
14:37:34 <benzrf> cata :: Functor f => (f a -> a) -> Fix f -> a
14:37:52 <iqubic> What does that do exactly?
14:37:59 <benzrf> cata phi (Fix x) = phi (fmap (cata phi) x)
14:38:13 <benzrf> check it out:
14:38:20 <iqubic> Sure.
14:38:25 <iqubic> I get how that works.
14:38:30 <benzrf> oh
14:38:37 <benzrf> so what's your question
14:38:39 <iqubic> phi is sometimes called alg.
14:38:41 <benzrf> right
14:39:00 <iqubic> benzrf: My question is: how is that actally useful in code?
14:39:52 <benzrf> well, modern recursion-schemes lets you define a typeclass for types that are equivalent to a fixed point of some functor, so that you *can* define your type non-parameterized and then give a function corresponding it
14:40:24 <benzrf> https://hackage.haskell.org/package/recursion-schemes-5.1/docs/Data-Functor-Foldable.html#t:Recursive
14:40:36 <iqubic> I'm not sure how to do that though.
14:40:50 <iqubic> what does the recursive type class do?
14:40:58 <benzrf> >a typeclass for types that are equivalent to a fixed point of some functor, so that you *can* define your type non-parameterized and then give a function corresponding it
14:41:25 <benzrf> everything besides project has a default implementation fyi
14:41:33 <benzrf> you only need to write project
14:41:35 <iqubic> Can I see an example of that being used?
14:41:40 <benzrf> sure
14:42:14 <benzrf> @let import Data.Functor.Base
14:42:15 <lambdabot>  .L.hs:94:1: error:
14:42:15 <lambdabot>      Could not find module ‘Data.Functor.Base’
14:42:15 <lambdabot>      Perhaps you meant
14:42:18 <benzrf> ah, oh well
14:42:40 <benzrf> in any case: first, data ListF a r = Nil | Cons a r deriving (Show, Functor)
14:42:46 <iqubic> Sure.
14:43:13 <iqubic> and type List = Fix ListF
14:43:20 <benzrf> no!
14:43:26 <iqubic> no? why not?
14:43:32 <benzrf> we do: type instance Base [a] = ListF a
14:43:53 <benzrf> the idea is that we instantiate this class for a type which is not actually defined as a fixed point of a functor
14:44:12 <benzrf> [a] is isomorphic to Fix ListF, and our instance displays this
14:44:29 <benzrf> but we can keep using [a], and let the library code automatically glue things together using the instance
14:44:42 <cjay-> Is there a reliable way to prevent memoization of a list definition? Should I introduce a fake parameter to make the definition a function? I guess that might be one of the reasons why those streaming libraries exist.
14:44:45 <monochrom> What is the type of project?
14:44:48 <iqubic> Do we need to create that type class in order to use functions like Cata?
14:44:53 <benzrf> type instance Base [a] = ListF a; instance Recursive [a] where project [] = Nil; project (a:as) = Cons a as
14:45:12 <benzrf> do you mean the cata in the recursion-schemes library, or cata more generally?
14:45:26 <benzrf> obviously we can define cata the way i did above, in which case we don't need the class
14:45:27 <monochrom> Interesting.
14:45:33 <iqubic> the cata from the recursion-schemes library
14:45:49 <monochrom> Hey this sounds like the best of both worlds!
14:46:25 * hackage cisco-spark-api 0.1.0.4 - DEPRECATED in favor of webex-teams-api  http://hackage.haskell.org/package/cisco-spark-api-0.1.0.4 (nshimaza)
14:46:40 <monochrom> Everyone has their own recursive types written long ago and now wedded to backward compatibility you can't really change them. But type family comes to the recuse!
14:46:41 <benzrf> iqubic: yeah, its type is cata :: Recursive t => (Base t a -> a) -> t -> a
14:46:49 <monochrom> err rescue!
14:47:04 <benzrf> it is just like the cata i wrote above, except that it uses project to unwrap the t
14:47:16 <hpc> "but type family comes to the recursive" monochrom ftfy
14:47:23 <monochrom> haha
14:47:30 <benzrf> cata phi t = phi (fmap (cata phi) (project t)), roughly
14:48:19 <merijn> ...rats
14:48:39 <monochrom> You found out where the NaN came from?
14:48:46 <merijn> monochrom: Oh, no, I knew that all along
14:49:04 <monochrom> You have a "where is the missing dollar" scenerio? >:)
14:49:14 <merijn> monochrom: It's because I'm initialising some vector elements to NaN to detect whether I set them or not
14:49:34 <merijn> monochrom: No, I know why they're there and don't plan to fix that right now
14:49:48 <merijn> No, I just had that sinking moment of "oh...that's why everything is broken..."
14:49:56 <monochrom> hehe
14:50:35 <merijn> monochrom: I'm rewriting this code which depends on vector elements origin corresponding to their index to be independent of that (as I now need to handle data not starting at 0)
14:51:01 <merijn> monochrom: The original code just does "zip [0..] originalData" to construct tuples of "origin + value"
14:51:16 <merijn> monochrom: I was comparing that against my new version but it kept not matching
14:51:31 --- mode: glguy set +v naudiz1
14:51:35 <iqubic> So I have this data structure, and I'm unsure of where to go from here: http://dpaste.com/3RWY7K7
14:51:37 <merijn> monochrom: It would, of course, help if I filtered NaNs out after the zip so the indices are actually correct...
14:52:02 <iqubic> I want to be able to use Cata to define an eval funtion on this AST.
14:52:43 <monochrom> I gather that your thesis work relies on coding up and running a number-intensive algorithm.  In that case that reminds me of a joke fairy tale.
14:53:03 <Fairy> I'm not a joke!
14:53:12 <monochrom> Ah but I'll tell it in #haskell-offtopic.
14:53:15 <naudiz1> hey... can you lead me to some resources that are good to getting back into haskell? I've used Haskell quite a lot a few years ago but I feel like I have no idea where to start anymore
14:53:17 <monochrom> Sorry Fairy!
14:53:28 <hpc> that's amazing
14:53:34 <Fairy> monochrom <3
14:53:35 <merijn> naudiz1: What was "a few years ago"?
14:53:42 <hpc> i thought my haskell program coverage jokes were bad
14:54:04 <iqubic> So I don't know what to do with my current ExprF to get to the point where I can use Cata.
14:54:08 <naudiz1> merijn: 2~3 years ago when I've written my bachelor thesis
14:54:33 <iqubic> http://dpaste.com/1RZSX44
14:54:34 <merijn> naudiz1: So you just need like a quick refresher? Because things haven't changed that much in 2 years
14:54:36 <naudiz1> and a little bit after that with some hobby projects
14:54:43 <naudiz1> merijn: exactly
14:54:49 <merijn> @where gentle
14:54:49 <lambdabot> http://www.haskell.org/tutorial/
14:55:12 <naudiz1> well, I guess that might work
14:55:34 <naudiz1> I'll give it a run, thanks
14:56:44 <naudiz1> anything in the direction of "best practice" or styleguides?
14:56:54 --- mode: glguy set +v atondwal2
14:57:18 --- mode: glguy set -v atondwal
14:57:33 --- mode: glguy set -v hpc
14:57:37 <merijn> I don't think there's any real consensus on style and best practices would depend a bit on what kinda stuff you're writing
14:57:45 <atondwal> iqubic: FYI, if you're okay with using TH, you can write the data strcuture normally and use makeBaseFunctor ''Expr to automatically define ExprF and the appropriate instances
14:59:00 <naudiz1> alright, in that case I'll just dirty-hack my way through for now until I have a feeling for the language again
14:59:08 <carter> merijn: sup!
14:59:36 <merijn> carter: too much work, not enough play, and a cat obstructing my haskell..:p
14:59:59 <merijn> carter: Also, I learned NaN breaks sort, sortBy, and Set!
15:00:00 <carter> Hrmm
15:00:37 <carter> merijn: then you’ll like the second or third thing I’m doing after this register patch
15:00:48 <iqubic> atondwal: I'd rather do it myself so I know what is going on.
15:00:56 <iqubic> I don't like my code being a black box
15:01:18 <carter> I was initially gonna do a patch for adding fp state to the green thread / TSO things for ghc
15:01:40 <carter> But then I looked at the size of the fp state rep on x86/32-64
15:01:58 <carter> And was like “gotta murder x87 support first ”
15:02:55 * hackage skip-var 0.1.1.0 - Skip variables  http://hackage.haskell.org/package/skip-var-0.1.1.0 (dtaskoff)
15:03:10 * merijn increments the facepalm counter by one
15:03:32 <merijn> Note to self: zipping vectors when your initial one is one element short ruins things...
15:03:48 <carter> Sleep helps too
15:04:03 <iqubic> atondwal: Do you know how to write the proper instances by hand?
15:04:11 <carter> Size indexed helps insofar as it forces you to check
15:04:13 <iqubic> Or is that just not something I should mess with.
15:04:57 <merijn> carter: Well, this is an intermediate stage in my move to a safer solution :p
15:05:22 <merijn> carter: Also, are you implying coding is not best done while sleep deprived and drinking whiskey? :p
15:05:34 <carter> Yeah go home
15:05:47 <merijn> carter: I am home :p
15:06:00 <iqubic> Then go to sleep.
15:06:42 <merijn> It's not that late yet, it's just several weeks of mediocre sleep adding up. I'm sure it's unrelared to stress wrt finishing my thesis...
15:09:33 <atondwal> iqubic: yeah, I'll give it a go
15:09:59 <iqubic> atondwal: Oh, thank you.
15:10:32 <merijn> The good news is: Things work now. I'll leave messing with SQL to optimise it for tomorrow
15:10:58 <iqubic> I'm going to read through this now: https://blog.sumtypeofway.com/recursion-schemes-part-41-2-better-living-through-base-functors/
15:13:46 <atondwal> iqubic: that one is good!
15:24:51 <atondwal> iqubic: How's this? https://gist.github.com/239c237a910625d444e6d960fb0c6277
15:26:18 <xenon-> hi. getting some weird behavior in the ghci
15:26:23 <xenon-> this works: sequence_ $ map (uncurry $ printf "%c %c\n") $ zip ['1'..'6'] ['a'..'f']
15:26:37 <xenon-> but if I type this first: map (uncurry $ printf "%c %c\n") $ zip ['1'..'6'] ['a'..'f']
15:26:46 <xenon-> and then: sequence_ it after, I get an error
15:26:55 <xenon-> Couldn't match expected type `[m a0]' with actual type `()'
15:27:21 <iqubic> atondwal: That looks great. Since I now understand the theory behind this, I'm now going to switch to using template haskell
15:27:24 <xenon-> I know about mapM_, just curious about this ghci's behavior. is it related to default types?
15:27:59 <xenon-> :t it gives me () after the map.. o_O
15:28:00 <lambdabot> error: parse error on input ‘..’
15:28:01 <iqubic> Also, my AST actually has like a dozen other matematical operators besides those there.
15:28:27 <merijn> xenon-: mapM_ prints the result of IO actions
15:28:34 <merijn> xenon-: Which, for mapM_ would be ()
15:28:50 <xenon-> merijn, yes, but I called map, not mapM_
15:30:46 <cjay-> Is there an idiomatic way to cause a lazy list to be recomputed every time, instead of being allocated?
15:31:04 <merijn> xenon-: Right, but sequence_ still ends up producing "IO ()", which ghci will print the result of :p
15:31:27 <hpc> specifically what happens is:
15:31:28 <hpc> Prelude> putStrLn ""
15:31:28 <hpc> Prelude> :t it
15:31:28 <hpc> it :: ()
15:31:46 <hpc> the result of the action is stored to it
15:32:01 <Solonarv> cjay-: I think there's a 'oneShot' function in GHC.Exts which should do that?
15:32:36 <hpc> i wouldn't depend on "it" in ghci that much
15:33:49 <hpc> cjay-: put it behind a function of some kind
15:33:55 <xenon-> merijn, hpc, I am calling sequence_ after map, not after mapM_, or after sequencing actions already. here's the session, maybe that will make things clearer.  https://pastebin.com/wUDJksbg
15:34:04 <hpc> or noinline it or something
15:34:55 <cjay-> Solonarv: thanks, looks like it does that (though it seems to be intended for a different use case)
15:35:48 <Solonarv> noinline will do the opposite - it prevents inlining, and inlining prevents sharing (for reasons which should be obvious)
15:35:53 <cjay-> hpc: adding a fake parameter was my first thought. but I found http://okmij.org/ftp/Haskell/index.html#memo-off where somebody did just that and it didn't work
15:36:12 <monochrom> xenon-: GHCi has extra defaulting to kill extra polymorphism (just so that it knows which Show instance to use, for example) therefore if you take polymorphic code out of context you get a specialization you don't want (because it tends to be the () type).
15:36:29 <hpc> cjay-: how are you getting it to print the type?
15:36:38 <iqubic> So I've got this section from my cabal file. http://dpaste.com/0BV4581
15:36:40 <hpc> i get an ambiguous type variable error
15:36:55 <iqubic> How do I add recursion-schemes as a depdency to this?
15:37:53 <cjay-> hpc: what type? I think you mean somebody else
15:38:02 <hpc> er, xenon-
15:38:39 <xenon-> monochrom what exactly defaulted to ()?
15:38:45 <xenon-> hpc on sequence_ it
15:38:46 <xenon-> ?
15:38:53 <hpc> on the middle line, with map
15:39:09 <hpc> i can't reproduce your ghci session
15:39:27 <xenon-> :t map (uncurry $ printf "%c %c\n") $ zip ['1'..'6'] ['a'..'f']   gives me  PrintfType b => [b]
15:39:28 <lambdabot> error: parse error on input ‘=>’
15:39:51 <hpc> ah, your paste doesn't say :t
15:40:00 <monochrom> xenon-: For example suppose you say "print []". Technically no one knows whether it's [] :: [Int] or [] :: [Char] or... and it matters because they all enjoy a different print format.  So GHCi says "meh it's [] :: [()] I'm done".
15:40:01 <xenon-> it doesn't, I just checked it now
15:40:02 <hpc> that doesn't set "it"
15:40:21 <monochrom> OK mine isn't a direct answer but I'm too lazy.
15:40:22 <iqubic> See, I don't know how to add external libraries as deps in a cabal file.
15:40:53 <xenon-> I checked the type so we can maybe find out why you're getting type error, and I'm not. my pasted session interaction is correct
15:41:03 <hpc> iqubic: take a look at the cabal files for some stuff on hackage
15:41:17 <iqubic> I'll try that.
15:41:25 <hpc> xenon-: oh, then i have no idea what's going on
15:41:26 <monochrom> It's likely [()] then, i.e., b=()
15:41:39 <hpc> Prelude> import Text.Printf
15:41:39 <hpc> Prelude Text.Printf> map (uncurry $ printf "%c %c\n") $ zip ['1'..'6'] ['a'..'f']
15:41:42 <hpc> <interactive>:2:1: error:
15:41:44 <hpc> ...
15:41:51 <Solonarv> iqubic: add it to the 'build-depends' section
15:42:01 <xenon-> > map (uncurry $ printf "%c %c\n") $ zip ['1'..'6'] ['a'..'f']
15:42:02 <lambdabot>  error:
15:42:03 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M773102395713...
15:42:03 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
15:42:09 <iqubic> What would that look like?
15:42:44 <monochrom> Yeah lambdabot is closer to Haskell Report conformance than ghci
15:43:42 <hpc> xenon-: i guess this is one of those cases where getting the question right is 90% of the answer
15:43:57 <Solonarv> lambdabot evaluates an expression, it doesn't act as a GHCi
15:44:12 <hpc> once you track down what's making your ghci behave differently from ours, the fix might become clear
15:44:19 <Solonarv> iqubic: exactly like the entry for 'base' that you already have in there
15:44:43 <Solonarv> iqubic: https://cabal.readthedocs.io
15:46:38 <xenon-> hpc I suspect you're getting something different here? https://pastebin.com/Bb5hKJ0U
15:47:19 <ACheesyName> how to fix this? https://repl.it/repls/NeglectedTenseRatios I'd like to use aeson generics with parametrized types. is it possible?
15:47:23 <monochrom> Um is that through emacs haskell-mode?
15:47:39 <monochrom> No nevermind.
15:47:50 <xenon-> monochrom yes. but I am getting same results in terminal
15:48:00 <xenon-> so how does [IO ()] become (), when I refer to it with `it'?
15:48:07 <monochrom> ":type" doesn't affect "it".
15:48:26 <Solonarv> ACheesyName: you need to write an instance for 'FixedState a b', not for 'FixedState' by itself
15:49:45 <xenon-> monochrom, I know, I posted wrong paste
15:49:50 <xenon-> I seemed to have figured it out
15:51:03 <xenon-> for whatever reason, ghci's `it' completely ignores last [IO ()] value, and refers to the prior it value. https://pastebin.com/vQCiCiK4
15:52:39 <monochrom> That one is really emacs haskell-mode shielding you from "No Show instance" error.
15:52:45 <hpc> i can't even reproduce /that/ paste
15:52:47 <hpc> Prelude Text.Printf> [printf ""] :: [IO ()]
15:52:47 <hpc> <interactive>:2:1: error:
15:52:47 <hpc>     • No instance for (Show (IO ())) arising from a use of ‘print’
15:53:03 <monochrom> Because real ghci does not repeat your expression.
15:53:38 <xenon-> you're right. hmm, odd, as I think I was reproducing some of my above code
15:55:10 <xenon-> correction, I get same behavior in terminal. I am using stack ghci
15:55:10 <ACheesyName> Solonarv: thanks solved
15:55:26 <ACheesyName> (got rid of FixedState entirely)
15:55:53 <xenon-> I get [IO <a>] printed. I am loading tons of libraries when I call stack ghci, though. maybe one defind Show instance for IO () and [IO ()]?
15:56:03 <monochrom> Yes.
15:56:03 <xenon-> I'm not sure how to check
15:56:24 <monochrom> Create a new empty project so that stack ghci loads nothing.
15:57:16 <xenon-> I mean how to check what file defined Show instance
15:57:17 <monochrom> Or maybe "git stash", "rm *", ..., "git stash pop" teeheehee
15:57:57 <monochrom> Oh, :info Show  but you have to fish through lengthy output
15:58:15 <monochrom> or maybe :info IO is a bit shorter
15:58:19 <xenon-> yeah, I am getting Ambiguous type variable `t0' arising from a use of `printt' error with ghci that isn't loading anything
16:03:40 <mudri> Did people here manage to work out the question about Church-encoded not the other day?
16:10:25 * hackage groundhog-th 0.10.2 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.10.2 (BorisLykah)
16:27:16 <[Leary]> I'm about to eat so I might not be able to get back to you quickly mudri, but what was the question? I've been writing a lot of Church/Scott/function encoded data recently.
16:29:32 <Solonarv> I think it was about the difference between 'not = λb. b (λt f. t) (λt f. f)' and 'not = λb t f. b f t' 
16:29:37 <Solonarv> [Leary]: ^
16:29:47 <Solonarv> I hope I got them right from memory
16:32:25 * hackage Network-NineP 0.4.4 - High-level abstraction over 9P protocol  http://hackage.haskell.org/package/Network-NineP-0.4.4 (SergeyAlirzaev)
16:36:39 <geekosaur> wikipedia? page said oen was valid for applicative order and the other for ormal ordr. asker was convinced wiki page had to be incorrect
16:37:00 <geekosaur> I suspect they were ignoring something critical because "why would that ever matter"
17:33:37 <ACheesyName> what's a good haskell repl online, kind of like repl.it but one that supports more widely-used packages like aeson?
17:49:59 <monochrom> Does codepad.org support that?
17:52:43 <monochrom> Does repl.it support that "3rd party package" button for Haskell?
17:54:27 --- mode: glguy set +v asdf__
17:54:40 <ACheesyName> on codepad, when I try my aeson code I get: ERROR "t.hs" - Can't find imported module "GHC.Generics". which makes sense because they seem to run hugs
17:54:54 <monochrom> Oh haha
17:55:05 <asdf__> who needs christmas when i have morphisms
17:56:34 <asdf__> but srsly whats a monomorphism
17:57:16 <asdf__> the definition i have idk what it means
17:57:55 <geekosaur> a top level binding without parameters or type signature is forced to resolve to a specific type, on the assumption that you wan it to behave like a constant (and eg. get lazy sharing)
17:58:29 <geekosaur> so something that might have its type inferred as (Num a => a) will instead use defaulting and get type Integer
17:58:42 <geekosaur> this is the monomorphism restriction
17:59:05 <asdf__> hmm, interesting thnx
17:59:24 <geekosaur> (not the same as oter uses of"morphism"; rather, it's the opposite of "polymorphic")
17:59:27 <asdf__> but i take it it also has a deeper meaning in category theory
17:59:35 <Lears> Monomophism here is the property of being monomorphic (having "one shape").
17:59:41 <asdf__> oh
17:59:43 <geekosaur> yes, that's a different thing. but in general that
17:59:59 <geekosaur> which in CT can man rathermore
18:17:19 <jle`> my favorite ghc extension today is TransformListComp
18:36:25 * hackage xmobar 0.29.4 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.29.4 (JoseAntonioOrtegaRuiz)
18:46:55 * hackage wai-logger 2.3.4, fast-logger 2.4.13 (KazuYamamoto): https://qbin.io/spank-acting-xmc0
18:47:13 <nyc> A monomorphism is just an injective morphism.
18:49:24 <butterthebuddha> nyc: not always
18:50:19 <nyc> butterthebuddha: I think that's how Hungerford defined it.
18:50:40 <butterthebuddha> what is the context?
19:14:25 <iqubic> Does anyone know if the Dante package for emacs supports stack?
20:03:33 <nyc> butterthebuddha: morphisms in category theory
20:04:14 <nyc> butterthebuddha: The text itself was on abstract algebra.
20:05:24 <ACheesyName> does it really matter to know category theory for programming in haskell?
20:05:54 <Clint> no
20:30:59 --- mode: glguy set +v PatrickRobotham
20:31:22 <juhp> I think this is probably a trivial lens question but with lens-aeson is there a natural way to convert say [String "ab", String "cd] to ["ab", "cd"] :: [Text] ?
20:32:54 <Solonarv> should be something like this: toListOf (traverse . _String)
20:33:21 <Solonarv> or the infix variant: [String "ab", String "cd] ^.. traverse . _String
20:33:57 <Solonarv> juhp: ^
20:35:21 <juhp> Solonarv: thanks
20:43:48 <[Leary]> mudri: The two versions of `not` look equivalent to me. I played around with evaluation strategies and impurity, but couldn't tease out a distinction.
20:47:48 <Solonarv> what about bottoms?
20:49:55 * hackage hhp 0.0.0 - Happy Haskell Programming  http://hackage.haskell.org/package/hhp-0.0.0 (KazuYamamoto)
21:01:05 <[Leary]> I don't see a distinction arising from bottoms either -- do you ask because you do? I usually prefer not to consider bottoms so maybe I'm thinking about it wrong.
21:01:44 <c_wraith> where are the implementations?
21:02:41 <[Leary]> https://en.wikipedia.org/wiki/Church_encoding#Church_Booleans
21:11:06 <c_wraith> hmm.  that looks like the sort of thing where bottoms would matter
21:35:56 <iqubic> :t (>>>)
21:35:57 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
21:36:08 <iqubic> Err??? What the heck?!?!
21:37:35 <systemfault> I never seen that but it looks like simple composition...
21:37:59 <systemfault> Well... left to right composition...
21:38:42 <iqubic> Yeah, it does.
21:40:34 <iqubic> Well, that is assuming (->) forms a Catagory
21:41:27 * hackage optparse-simple 0.1.1 - Simple interface to optparse-applicative  http://hackage.haskell.org/package/optparse-simple-0.1.1 (MichaelSnoyman)
22:33:14 <droplet> Gurkenglas: just saw your message - my hope was that if the result is only required to be a getter then it might be sound
22:45:16 <atondwal> iqubic: https://www.haskell.org/arrows/
22:45:47 <iqubic> I have a question, and my google-fu isn't strong enough to answer it.
22:47:04 <iqubic> Is it possible to write a sorting algorithm in haskell using a cata or para or something that avoids explicit recursion?
22:47:28 <iqubic> sort :: (Ord a) => [a] -> [a]
22:47:41 <suzu> yes
22:47:48 <suzu> mergesort is a hylomorphism
22:48:01 <iqubic> How does it work?
22:48:13 <iqubic> Can I see the sort written as a hylomorphism?
22:48:15 <suzu> a hylomorphism is a catamorphism followed by an anamorphism
22:48:27 <suzu> the list is deconstructed and reconstructed
22:49:35 <suzu> here's a good article iqubic
22:49:37 <iqubic> I know.
22:49:37 <suzu> https://blog.sumtypeofway.com/recursion-schemes-part-v/
22:49:47 <iqubic> I want to see the actual code of the sort
22:50:38 <iqubic> How often are histo and futu used? Like can I skip that part.
22:51:07 <iqubic> Because I was actually reading that article just now, and got so freaking confused by histo and futu.
22:51:13 <suzu> here's code iqubic 
22:51:15 <suzu> https://jtobin.io/sorting-with-style
22:52:43 <iqubic> Alright, that is officially the best version of Mergesort I have ever seen.
22:53:10 <iqubic> Now, I wonder, how hard would it be to write quicksort with hylo.
22:53:17 <iqubic> How hard indeed?
22:56:17 <zachmane> hello guys just wondering if anyone here has problems building shakespeare 2.0.20
22:56:29 <suzu> oh, not hard at all iqubic 
22:56:43 <suzu> define your tree to be either Empty, or Node k left right
22:57:26 <suzu> if it is Node k left right, then `k` is a pivot and `left` is a tree of everything lesser than k and right is everything greater than k
22:58:18 <iqubic> Right, but it's just that the coalg passed to ana needs to do more work than just split the list in half. And somehow the alg passed to cata needs to be able to access the pivot selected when tearing the list apart with ana.
22:58:26 <iqubic> And I'm not sure how to deal with that.
23:09:26 <c_wraith> who says you need to split a list in half for a merge sort?
23:09:46 <c_wraith> Just because schools only teach you one way doesn't mean there are no better ones.
23:12:45 <iqubic> c_wraith: That's basically what a quicksort is.
23:14:57 <suzu> iqubic: gimme a moment and i'll try to write it
23:15:15 <iqubic> Cool
23:16:13 <c_wraith> iqubic: a bottom-up mergesort is nothing like a quicksort...
23:16:22 <iqubic> Oh.
23:23:47 <iqubic> suzu: How's that implicitly recursive quicksort going?
23:28:55 * hackage RSolve 0.1.0.0 - A general solver for equations  http://hackage.haskell.org/package/RSolve-0.1.0.0 (ice1000)
23:29:18 <suzu> agh lpaste is down!
23:30:01 <suzu> here you are iqubic 
23:30:02 <suzu> https://pastebin.com/t7eqBmss
23:32:13 <iqubic> How does that work?
23:33:33 <iqubic> Oh, wait... I see how that works.
23:33:38 <iqubic> Really really clever there.
23:37:36 <iqubic> Interesting thing to note about quicksort vs mergesort. Mergesort does most of its work in the ana, when it put the list back together, where as quicksort does most of its work in the cata, where it divides the list up.
23:37:43 <iqubic> I literally just noticed this.
23:44:24 <nyc> I worry the constant factors might not be great for the implementation.
23:46:45 <nyc> It'd be better to split the list by taking alternating elements.
23:47:25 * hackage RSolve 0.1.0.1 - A general solver for equations  http://hackage.haskell.org/package/RSolve-0.1.0.1 (ice1000)
23:53:43 <pacak1> With all those ++ I'd be worried not just about constant factors.
23:56:02 <iqubic> yeah.
