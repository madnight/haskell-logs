00:04:42 <Ariakenom> Has anyone used String for a lot of code advent and found it ok or too slow?
00:07:35 <maerwald> tdammers: it's surprisingly hard to abstract over different "string" representations, isn't it? 
00:10:05 <Ariakenom> Worked fine for the first 6 for me.
00:10:14 * hackage oeis2 1.0.0 - Interface for Online Encyclopedia of Integer Sequences (OEIS).  http://hackage.haskell.org/package/oeis2-1.0.0 (23prime)
00:12:45 <tdammers> maerwald: I think the biggest complication is not so much writing those abstractions in the first place, but rather gluing together a bunch of libraries that don't use them
00:38:24 <suzu> grab string-conv
00:39:13 --- mode: glguy set +v slayer61616_
00:42:54 --- mode: cherryh.freenode.net set +v [exa]
00:42:54 --- mode: glguy set -v [exa]
00:44:17 * hackage io-choice 0.0.7 - Choice for IO and lifted IO  http://hackage.haskell.org/package/io-choice-0.0.7 (KazuYamamoto)
00:59:18 <rkrishnan> I am trying to build a package on Windows that depends on another package which depends on a C library. I am pasing --extra-include-dirs and --extra-lib-dirs but the build always fails. This is with cabal 2.4.1.0 and ghc 8.4.2.
01:00:12 --- mode: glguy set +v beginnerSOL
01:00:28 <beginnerSOL> Hey. I'm having problems with numbers in Haskell, specially the terms "floating point", "fixed point", "fixed precision", "arbitrary precision". how do I categorize these in my head?
01:00:50 <beginnerSOL> my problem is the terms "point" and "precision".
01:03:23 <koz_> beginnerSOL: Those aren't specific to Haskell.
01:06:37 <beginnerSOL> koz_ so what's their meaning in general? my problem is the terms "point" and "precision".
01:06:59 <koz_> beginnerSOL: The problem is that you can't just slice a formal term into pieces like that.
01:07:16 <koz_> It's like looking at 'finite automaton' and saying 'My problem is with the term 'finite''.
01:08:00 <koz_> When we say a number has 'fixed precision', it means that there is a specific amount of accuracy to which it can be represented.
01:08:01 <beginnerSOL> ok, so how do I understand those terms?
01:08:12 <koz_> This typically corresponds to having a fixed bit width for its representation.
01:08:22 <koz_> An example of a fixed precision thing is Haskell's Int.
01:08:33 <koz_> (which is required to be at least 30 bits wide I believe, but can be more)
01:08:44 <koz_> On an x86_64 machine, Int is 64 bits wide.
01:09:07 <koz_> This limits the magnitude that we can represent for obvious reasons.
01:09:15 <koz_> 'Arbitrary precision' means there is no such limit.
01:09:26 <toxicafunk> hi
01:09:26 <koz_> An example of _that_ would be Haskell's Integer.
01:09:31 <koz_> toxicafunk: Hola.
01:09:38 <koz_> With me so far beginnerSOL?
01:09:47 <beginnerSOL> yeah koz_
01:09:53 <toxicafunk> i have a file with 5k lines where each line is a message I want to send to a kafka topic
01:09:53 <dminuoso> Hello toxicafunk o/
01:09:53 <toxicafunk> i'm trying to process each line concurrently using `mapConcurrently` from the `async` pkg
01:09:53 <toxicafunk> processinmg means simply extracting an Id which will be used as message key, create the KafkaMessage and send it
01:10:26 <koz_> So, fixed-point versus floating-point is to do with finite-width representations of reals.
01:10:27 <toxicafunk> here's the relevant code
01:10:50 <Ariakenom> for point we can consider a string of numbers "18273". Then the placement of a point "1827.3", "18.273".
01:10:50 <koz_> Basically for a fixed-point representation, some of the bits are set aside to be 'to the left' of the decimal point, and the rest are 'to the right' of said decimal point.
01:10:50 <toxicafunk> ... wait, how do I format code here?
01:10:52 <koz_> And those are fixed.
01:10:55 <toxicafunk> :D
01:10:58 <koz_> toxicafunk: Gist.
01:11:08 <toxicafunk> makes sense :D
01:11:41 <koz_> Floating-point allows the point to 'float' or 'move around' depending on which number we're representing.
01:11:57 <koz_> Haskell's Float and Double are both floating-point, for example.
01:12:15 <koz_> I don't believe base contains any fixed-point equivalents.
01:12:22 <toxicafunk> here we go: https://gist.github.com/toxicafunk/09f1ad5c1df58ee4b12c40dafc900375
01:12:43 <koz_> Any questions beginnerSOL?
01:12:47 <toxicafunk> the issue I have is that it kind of "finishes" prematurely
01:12:59 <beginnerSOL> koz_ so the "precision" has to do with the number of bits and "point" with the decimal point?
01:13:12 <toxicafunk> i.e. 
01:13:14 <toxicafunk> $> stack exec kafkaproducer-exe /home/enrs/tools/just5k.json -- +RTS -l
01:13:14 <toxicafunk> 5000
01:13:26 <toxicafunk> but on the consumer side
01:13:27 <Ariakenom> BigFloat is a name often used for arbitrary precision, floating point.
01:13:27 <toxicafunk> Processed a total of 4894 messages
01:14:02 <koz_> beginnerSOL: Not exactly.
01:14:18 <koz_> You can't just separate out those terms like that.
01:14:24 <toxicafunk> basically mapConcurrently goes through all the 5k messages but finishes before all the "threads" finish
01:14:25 <koz_> Fixed-point is a singular term, meaning a specific thing.
01:14:32 <koz_> 'Arbitrary precision' likewise.
01:14:45 <koz_> I've given you rough definitions of all four.
01:14:58 <toxicafunk> the number of sent messages vary on every run of course
01:15:08 <beginnerSOL> I think I got it.
01:15:10 <Ariakenom> koz_: But that's what the names are based on, though?
01:15:22 <toxicafunk> so, any help or suggestions are welcolmed
01:15:32 <koz_> Ariakenom: What do you mean?
01:15:36 <toxicafunk> so, any help or suggestions are wellcolmed
01:15:57 <toxicafunk> so, any help or suggestions are welcolmed
01:15:58 <Ariakenom> precision and point refers to those things even though you can't put any prefix in front
01:16:21 <koz_> Ariakenom: In this specific context yes.
01:16:31 <Ariakenom> A relevant number type is also Rational which is a fraction of Integers. Arbitrary precision but no point in that sense.
01:16:33 <koz_> However, you can't just randomly pull out those terms and ask what they mean in a vaccuum.
01:17:37 <Ariakenom> Just point out that those terms aren't classifications of number types in general
01:17:59 <beginnerSOL> Thats the thing that made it confusing for me, I know we have Integral numbers and Fractional numbers, but those "point" and "precision" things made it confusing.
01:18:13 <koz_> beginnerSOL: Integral and Fractional is to do with capabilities.
01:18:21 <koz_> Not representations.
01:18:33 <koz_> Which is what 'fixed-point' and 'arbitrary precision' and friends are concerned with.
01:19:10 <toxicafunk> I also tried with mapM instead of mapConcurrently with even worst result
01:19:17 <toxicafunk> i.e. even less messages sent
01:19:48 <beginnerSOL> God bless you koz_ , so my problem was this separation between capabilities and representations.
01:20:01 <beginnerSOL> I get it now, thanks koz_
01:20:09 <koz_> beginnerSOL: No problem, happy to help.
01:20:28 <beginnerSOL> Thank to you too Ariakenom
01:25:34 --- mode: glguy set +v aleator
01:25:49 <Ariakenom> toxicafunk: kafka drops messages if queues fill, right?
01:26:34 <aleator> Which recursion scheme is best for implementing the take function?  
01:26:38 <toxicafunk> no, its not a queue, its a topic, specifically, a log file
01:27:17 <toxicafunk> i have implemented this same program in rust, scala and go, so its not a kafka issue
01:27:59 <toxicafunk> I'm new to haskell and that's why I'm reimplementing this program 
01:29:57 <toxicafunk> incidentally, I also tried using
01:30:02 <toxicafunk>  map (processMessage producer) (C8.lines file) `using` parList rseq
01:30:38 <toxicafunk> instead of mapConcurrenlty, but that did all the processing sequentially
01:31:00 <toxicafunk> ah, and "parList rpar" as well, but had the same issue
01:31:39 --- mode: glguy set +v mreh
01:31:49 --- mode: glguy set -v mreh
01:40:13 <toxicafunk>       ioMaybes <- sequence (map (processMessage producer) (lines file) `using` parList rpar)
01:40:13 <toxicafunk>       print $ F.length $ filter isNothing ioMaybes
01:40:41 <toxicafunk> this doesn't perform the IO op (sending to kafka) in parallel
01:41:21 <toxicafunk> if I undesrtand correctly it prepares the IO in parallel, but the IO execution happens when `filter` is called
01:41:24 <toxicafunk> am I right?
01:42:20 <Ariakenom> toxicafunk: the parList only affects evaluation of values, yes. not IO execution
01:42:58 <Ariakenom> you said not all threads finish, so does it work with a sleep at the end?
01:43:28 <toxicafunk> @Ariakenom what would I need to do so that `parList` executes the IOs, is there a way to acieve this?
01:43:28 <lambdabot> Unknown command, try @list
01:43:47 <toxicafunk> let me try with the sleep
01:44:32 <Ariakenom> toxicafunk: I'm gonna go with "don't" regarding parList :p
01:44:42 <toxicafunk> hehe, ok, why?
01:44:59 <toxicafunk> also, is threadDelay a good option instead of sleep for this case?
01:45:19 <Ariakenom> toxicafunk: yes that's the name of sleep
01:48:12 <Ariakenom> toxicafunk: wrt parList, you don't want to mix lazy evaluation and side effects (stronger claim: you don't wanna mix evaluation and side effects). that's why we have IO
01:49:30 <toxicafunk> so mapConcurrently is the correct choice here
01:49:34 <Ariakenom> yes
01:49:51 <toxicafunk> wrt threadSleep, yes, it works with a big enough value
01:49:57 <toxicafunk> i.e. 100000
01:50:07 <toxicafunk>       ioMaybes <- mapConcurrently (processMessage producer) (lines file)
01:50:07 <toxicafunk>       threadDelay 100000
01:50:07 <toxicafunk>       print $ F.length $ filter isNothing ioMaybes
01:50:36 <kuribas> is there a flip foldMap function?
01:50:51 <Ariakenom> toxicafunk: where's the documentation for newProducer?
01:51:01 <toxicafunk> wrt mapConcurrently, it doesn't actually uses sparks right?
01:51:09 <Ariakenom> toxicafunk: no
01:51:26 <kuribas> > (flip foldMap (Maybe 2) (+ 2) <> flip foldMap Nothing) :: [Int]
01:51:28 <lambdabot>  error:
01:51:29 <lambdabot>      â€¢ Couldn't match expected type â€˜[Int]â€™
01:51:29 <lambdabot>                    with actual type â€˜(a0 -> c0) -> c0â€™
01:51:37 <Ariakenom> toxicafunk: maybe the bindings are running threads you need tow ait for
01:51:42 <kuribas> > (flip foldMap (Maybe 2) (+ 2) <> flip foldMap Nothing (* 2)) :: [Int]
01:51:44 <lambdabot>  error:
01:51:44 <lambdabot>      â€¢ Data constructor not in scope: Maybe :: Integer -> [[Int]]
01:51:44 <lambdabot>      â€¢ Perhaps you meant variable â€˜maybeâ€™ (imported from Data.Maybe)
01:52:15 <toxicafunk> i'm using this client: https://github.com/haskell-works/hw-kafka-client
01:52:52 <Ariakenom> when "main" exits the program ends (more or less) so work might get cancelled
01:52:52 <toxicafunk> https://hackage.haskell.org/package/hw-kafka-client-2.5.0/docs/Kafka-Producer.html
01:53:20 <Ariakenom> " A newly created producer must be closed with closeProducer function."
01:53:27 <toxicafunk> that's my understanding as well,
01:53:45 <toxicafunk> mmmm k, I kinda ignored the closeProducer...
01:53:57 <toxicafunk> disn;t thought it would make a difference for a quick test
01:54:24 <toxicafunk> shoudl have read the doc first: Closes the producer. Will wait until the outbound queue is drained before returning the control.
01:54:45 <toxicafunk> thx @Ariakenom this is surely the issue
01:55:32 <Ariakenom> you're welcome toxicafunk 
01:55:50 <kuribas> @hoogle Functor f => f a -> (a -> b) -> f b
01:55:50 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
01:55:51 <lambdabot> Prelude (<$>) :: Functor f => (a -> b) -> f a -> f b
01:55:51 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
01:57:27 <toxicafunk> @Ariakenom in any case, you also helped clear some implementation details, so thx for that too!
01:57:27 <lambdabot> Unknown command, try @list
01:59:15 <Ariakenom> toxicafunk: sure thing. resources that need closing are usually used with a withX function that handles closing. looks like runProducer, strange that it is deprecated.
01:59:57 <toxicafunk> in the example they actually used bracket
02:01:35 <Ariakenom> toxicafunk: "withX = bracket openX closeX useX"
02:02:50 <toxicafunk> but I found it hard to adapt to the code I had, so forgot about it :(
02:05:56 <kuribas> is there a flip fmap function?
02:06:17 <Taneb> :t (<&>)
02:06:18 <lambdabot> Functor f => f a -> (a -> b) -> f b
02:06:26 <Taneb> In Data.Functor
02:07:05 <kuribas> :i (<&>)
02:07:12 <kuribas> @hoogle (<&>)
02:07:13 <lambdabot> Control.Lens.Lens (<&>) :: Functor f => f a -> (a -> b) -> f b
02:07:13 <lambdabot> Control.Lens.Operators (<&>) :: Functor f => f a -> (a -> b) -> f b
02:07:13 <lambdabot> Lens.Micro (<&>) :: Functor f => f a -> (a -> b) -> f b
02:07:27 <kuribas> Taneb: not a light dependency...
02:07:36 <Taneb> kuribas: it's in base in recent GHCs
02:07:41 <kuribas> ah cool
02:07:52 <Taneb> (since 8.4)
02:07:54 <kuribas> Taneb: which module?
02:07:58 <Taneb> Data.Functor
02:10:05 <kuribas> ah cool
02:16:55 <no-n> what's the right way to install stack on OpenBSD?
02:17:49 <no-n> I get Sorry, this installer does not support your operating system: OpenBSD
02:17:59 <aleator> Which recursion scheme is best for implementing the take function?  
02:19:32 <suzu> for take over a list?
02:19:42 <aleator> suzu: Yeah.
02:20:33 <aleator> Or more precisely, which of the recursion schemes best captures the notion of using a function as an accumulator? (Like what you'd do when implementing take using foldr)
02:20:42 <suzu> paramorphism
02:21:14 <suzu> a para involves folding over the structure while also being able to access the most recent state of your recursion
02:23:05 <aleator> I'm probably being dense here, but does that really apply to take? 
02:23:47 <suzu> no. you can write take without an accumulator
02:23:53 <suzu> i'm answering your latter question
02:26:15 <jadrian> suzu: for lists wouldn't `para` be a recursion scheme of the form,  h (x:xs) = f (x:xs) (h xs)  
02:26:56 <jadrian> suzu: with `cata` being of the form, h (x:xs) = f x (h xs)
02:27:55 <aleator> I don't think para is it. I'm trying to find out if patterns like 'foldr (\ x g n -> if n == 0 then []Â else x:g (n-1)) (const []) "foobar" 3' have a better scheme than cata
02:29:30 <suzu> para :: (Base t (t, a) -> a) -> t -> a 
02:29:33 <suzu> from recursion-schemes
02:30:15 <jadrian> suzu: yes I know that's the type of generic definition 
02:30:55 <suzu> there's a function of ((x:xs), a) -> a as an input
02:31:23 <aleator> suzu: Might I bother you for the implementation for the above foldr using para? I'm just too sleepy to see it myself.
02:31:59 <jadrian> suzu: my point is, a cata on lists (aka foldr) is a recursion of the form, `h [] = e ; h (x:xs) = f x (h xs)`. Similarly isn't para, `h [] = e ;  h (x:xs) = f (x:xs) (h xs)`
02:32:07 <jadrian> ?
02:32:57 <suzu> yes, i think that's right but im not qualified enough to say for certain
02:33:58 <jadrian> my point being, there's no accumulation going on
02:34:47 <jadrian> the difference being that in a cata each step combines the result of the recursion with an "element", while in para it combines the result with the whole structure
02:35:58 <jadrian> I might be missing something, and would need to refresh theory, but I don't a connection between para and accumulation
02:37:36 <suzu> hmm, i think you might be right
02:37:52 <suzu> it looks like it does access the remainder of the structure, not an accumulator
02:38:39 --- mode: glguy set +v beginnerSOL
02:38:42 <beginnerSOL> Hey, can you explain this error message? "No instance for (X Y) arising from Z"
02:39:36 <suzu> not sure what the correct answer is to your question then aleator, sorry
02:39:44 <beginnerSOL> does it mean Z doesn't have the type X OR Z doesn't have the type Y?
02:39:47 <jle`> beginnerSOL: usually it means that you are trying to use z (lower-case identifier), but Y needs an instance for typeclass X
02:39:55 <jle`> it's about typeclasses, not types, here
02:40:23 <jle`> No instance for (MyTypeClass MyType) arising from myThingIamUsing
02:40:52 <jadrian> I was trying to give yesod a go, going through the quick start guide and book, any project using yesod seems to have problems with intero though
02:41:06 <jadrian> "In the dependencies for intero-0.1.20: ghc-8.4.4 from stack configuration does not match >=7.8 && <8.0.3 needed since intero is a build target"
02:41:35 <suzu> what editor are you using?
02:41:39 <jadrian> emacs
02:41:44 <suzu> sapcemacs or emacs?
02:41:46 <suzu> space*
02:41:51 <jadrian> emacs
02:42:06 <suzu> you need to upgrade your intero
02:42:23 <jadrian> it seems the opposite is happening, i.e. my intero is too new
02:42:23 <suzu> the emacs package. not the haskell one
02:42:30 <jadrian> oh
02:42:35 <beginnerSOL> jle` thanks, got it. so the first one in the parens is about the typeclass and the second one about the type?
02:43:33 <suzu> a new emacs intero package will want to use a new intero haskell package, and intero 0.1.33 supports GHC 8.4.4
02:44:14 <jle`> beginnerSOL: mhm
02:44:28 <jle`> and the third one is an expression in your code usually
02:44:35 <jle`> or it might just be a single identifier
02:44:44 <beginnerSOL> jle` thanks ;-)
02:44:56 <suzu> it is likely a use of a function that is part of the typeclass X
02:45:12 <suzu> on some value of type Y. but type Y does not have an instance for typeclass X
02:45:28 <jadrian> suzu: I see I think I follow
02:46:16 <jadrian> suzu: so I do have intero 0.1.34 installed... but looking at the emacs package it does say elpa/intero-20170518.307
02:46:27 <jadrian> suzu: is that what you are referring to?
02:46:29 <suzu> upgrade your emacs package
02:46:32 <jadrian> right
02:46:44 <suzu> and then let the emacs package install intero for you
02:47:54 <jle`> beginnerSOL: np!
02:53:24 <jadrian> suzu: yes that was it, thanks! was quite lost there
02:55:17 <suzu> np yw
03:24:47 <dminuoso> What possible reasons might there be, that Network.Socket.getAddrInfo sporadically raises errors that the host does not exist?
03:31:43 <dminuoso> And wargh. I hate people: [ThreadId 17110] [Info] Authentication failed: Prelude.read: no parse
03:39:57 <[exa]> dminuoso: check the program out with strace, it's possible that something below is failing
03:40:11 <[exa]> dminuoso: (about the getAddrInfo ^ )
03:40:26 <[exa]> no comment about the parse. :D
03:41:10 <__monty__> Why does the read error not echo the string it errored on btw? It's highly inconvenient.
03:41:51 <[exa]> __monty__: yes, especially for authentication using passwords. :D
03:45:07 <__monty__> Is there ever a reason to parse a string containing a password? Why not just trust the string contains a password? Also, wouldn't the error usually happen client side anyway? And, if it happens serverside it's not as if erroring is the only way to get to the password.
03:45:25 <__monty__> Is your objection only with regard to the logging of errors or something?
03:46:15 <dminuoso> [exa]: Mmm, no idea how I can properly trace this under macOS.
03:46:27 <dminuoso> SIP is partially disabled, but I probably need to disable it completely.
03:46:57 <Axman6> man -k dtrace should show you some tools you can use
03:47:18 <Ariakenom> __monty__: cmd line arguments, reading from a cfg file
03:47:21 <Axman6> if you need to look at system calls, dtruss is a good place to start
03:47:56 <[exa]> __monty__: yeah, logging any auth-related stuff is complicated. I would highly distrust 'read' in that case as well.
03:48:09 <[exa]> not sure what part of that was dminuoso pointing out
03:48:40 <[exa]> dminuoso: dtruss is almost-workalike of strace, yes
03:48:58 <dminuoso> Well in this case the `read` is actually from an unrelated part. I just triggered a thunk that.. does some read shenanigans because oh well libraries.
03:49:46 <[exa]> "oh my" situation.
03:50:10 <Ariakenom> which library?
03:51:44 <__monty__> I probably wouldn't trust read with sensitive data anyway. I'd appreciate the convenience of having it report what it failed to parse while developing though.
03:52:23 <__monty__> You can do that with readS or something but it'd be a convenient default imo.
03:56:37 <dminuoso> [exa]: Though for what its worth, I've debugged the libraries I have deep enough to be sure that this is coming from the syscall directly.
04:31:53 <aplainzetakind> AoC spoiler: This takes minutes to run, what am I doing wrong? https://github.com/aplainzetakind/AoC2018/blob/master/src/day11/Day11.hs
04:33:03 <merijn> Isn't sum lazy for stupid reasons?
04:33:11 <merijn> i.e. foldl
04:33:20 <aplainzetakind> Hmm.
04:33:31 <merijn> aplainzetakind: Anyway, the *real* answer is: Build with profiling and see what's going on :)
04:33:47 <merijn> aplainzetakind: The GHC user's guide has quite some stuff on how to do that and how to get started
04:35:32 <fendor> When I want to execute processes in a stack project, then the path is being set by stack, correct? How can I change that, e.g. stack is installed by my system and I want to execute a stack process e.g. `stack path`?
04:36:21 <merijn> aplainzetakind: A really poor way to debug this (but really easy, so maybe still worth it): What happens if you import Data.Map.Strict instead of Data.Map?
04:36:44 * hackage extensible-effects-concurrent 0.15.0 - Message passing concurrency as extensible-effect  http://hackage.haskell.org/package/extensible-effects-concurrent-0.15.0 (SvenHeyll)
04:37:33 <merijn> aplainzetakind: The profiling aproach would be a lot better in terms of learning not only what's going wrong here, but also how to tackle similar problems in the future
04:37:35 <aplainzetakind> merijn: OK I will, though when I do that and it points me to the bottleneck function I'm usually clueless on how to make it faster. In the meantime, why would laziness in sum slow things down? (and would it actually? I changed to foldl' (+) 0 and it seems to be taking just as long)
04:38:14 <aplainzetakind> Yep, it finished with exactly the same time.
04:38:22 <merijn> aplainzetakind: I mean, summing via foldl is definitely slower, it's just not necessarily the issue here :p
04:39:05 <merijn> aplainzetakind: The problem with foldl is that it spends a bunch of time building O(N) thunks (all taking time) and then once it's done all that, proceeds to immediately force all O(N) thunks to actually compute the result
04:39:47 <merijn> aplainzetakind: foldl' forces those thunks as you build them, resulting in less memory buildup, less overhead (from first building thunks you'll 100% certainly end up forcing anyway), and allows the optimiser to work better
04:40:16 <aplainzetakind> merijn: I knew about the different ways they worked, but I thought it only effected space.
04:40:27 <aplainzetakind> s/effect/affect
04:41:27 <merijn> aplainzetakind: Space affects time, that's why we have "space-time trade-offs" ;) (although in this case we'd be using more space for more time, so that's not quite it)
04:43:05 <merijn> aplainzetakind: GHC's garbage collector is a copy-compacting GC, this is very nice for throughput in most scenarios (since GC designs are basicaly 100% trade-offs), but means that large amounts of live data make GC slower, for example. Additionally allocating a lot may trigger more GCs, exacerbating the effects, etc.
04:43:38 <merijn> Honestly, foldl is a huge historic mistake that no one dares to touch "just in case it accidentally breaks something somewhere..."
04:44:25 <hpc> there's one extremely niche use case where foldl has a defined value where a similar use of foldl' or foldr wouldn't
04:44:33 <hpc> but it would probably take me an hour to remember how to write it on purpose
04:44:39 <merijn> aplainzetakind: Anyway, profiling output (running with "+RTS -sstderr" is a good cheap starting point) will tell you where your program spends the most CPU time, where it uses the most memory, and how much time is spent (wasted) on GC
04:45:04 <Ariakenom> "basicaly 100% trade-offs" I'd disagree, I'm sure any GC I would build would just be bad with many decision that make it all around worse. :p
04:45:39 <merijn> Ariakenom: Sure, but you can't make a "best GC"
04:46:28 <hpc> Ariakenom: https://en.wikipedia.org/wiki/Pareto_efficiency
04:47:50 <Ariakenom> sure, just joked with the particular phrasing.
04:49:13 <hpc> ;)
04:49:21 <Ariakenom> hpc: ah interesting, haven't seen that name. although I've heard "efficient frontier"
04:50:23 <hpc> this is the same pareto behind the pareto principle btw
04:51:38 --- mode: glguy set +v crvdgc
04:52:20 <merijn> Ariakenom: Ah, "Pareto frontier" is one of the most useful concepts for talking about complex relations, designs, and trade-offs
04:56:27 <Ariakenom> I most recently remember it from this "TCP but good" talk I liked (retitled by me) https://www.youtube.com/watch?v=UsCOVF0vDe8
04:57:10 <Ariakenom> by Keith Winstein
05:01:05 <Ariakenom> Relevant slide: https://youtu.be/UsCOVF0vDe8?t=3001
05:06:20 --- mode: glguy set +v Haskeller
05:06:28 <Bish> why isn't <$> listed in :info Functor
05:06:53 <Haskeller> hello
05:07:27 <hpc> Bish: it's not actually part of Functor, only fmap is
05:07:29 <merijn> Bish: Because <$> isn't part of the functor class
05:07:29 <hpc> @src Functor
05:07:29 <lambdabot> class Functor f where
05:07:29 <lambdabot>     fmap :: (a -> b) -> f a -> f b
05:07:32 <hpc> @src (<$>)
05:07:32 <lambdabot> f <$> a = fmap f a
05:07:38 <Bish> merijn: well, fmap is?
05:07:52 <Haskeller> emm
05:07:57 <merijn> Bish: Sure, but those two facts aren't related at all? :)
05:08:09 <Bish> <$> is infix fmap, right?
05:08:14 <Bish> or am i stupid here
05:08:20 <Haskeller> IRC look like so cool!
05:08:34 <merijn> Bish: <$> is an infix function that happens to be defined using fmap, so *conceptually* it is infix fmap
05:08:42 <merijn> Bish: However it *isn't* fmap
05:08:44 <hpc> Bish: think of it this way, if you opened a text file and wrote "comparify = (==)", you wouldn't be able to then write "instance Eq SomeType where comparify = ..."
05:09:12 <Bish> merijn: because it's infix it's not the same?
05:09:24 <Haskeller> a
05:09:26 <merijn> Bish: The fact that it's infix is a separate thing
05:09:39 <Bish> i don't get it.
05:09:42 <merijn> Bish: Operators are just regular functions like all others
05:09:49 <Bish> that i get it
05:09:59 <Bish> but why does monads get >>=
05:10:02 <Bish> while functors don't
05:10:10 <merijn> Bish: Well, did you get hpc's example?
05:10:13 <Bish> isn't that super inconsistent?
05:10:16 <hpc> that's how the Monad type class is defined
05:10:18 <Bish> merijn: no
05:10:30 <Bish> hpc: yeah i know
05:11:02 <Ariakenom> Haskeller: hi
05:11:03 <Bish> but why does the haskell implementation favor "written out" in one class and doesn't on the other
05:11:23 <merijn> Bish: I mean, there's nothing (conceptually) stopping us from defining "class Monad m where bind :: m a -> (a -> m b) -> m b", similarly we could've defined "class Functor f where <$> :: (a -> b) -> f a -> f b"
05:11:35 <Bish> hence my question
05:11:44 <merijn> Bish: Human idiosyncrancies, historical reasons, confused authors, etc.
05:11:46 <Bish> it's inconsistenz
05:11:56 <Haskeller> :)
05:12:03 <Bish> which makes the infix prefix dilemma worse for me
05:12:28 <Ariakenom> damn those humans and their names
05:12:39 <Bish> Ariakenom: well, there are parts that are really stupid
05:12:46 <merijn> Bish: Honestly, I don't know why the difference arose and I'm not sure anyone remembers
05:12:57 <Bish> Base 10, writings numbers wrong way around, infix, all things we don't need and have because we're used to it
05:13:12 <Bish> and making it worse
05:13:28 <hpc> at least it's not mysql_real_escape_string :D
05:13:38 <merijn> Bish: What exactly is the "infix prefix dilemma" you have?
05:13:50 <tdammers> Base 10 has some roots in practicality, humans usually having 10 fingers and all that
05:13:54 <Bish> the fact that >>= is infix really stood in my way when learning how monads work
05:14:17 <Bish> and that fmap doesn't to that is confusing me even more
05:14:36 <Bish> tdammers: sure, i get that, but if every decision was done like that, phew
05:14:37 <hpc> Bish: have you learned Applicative?
05:14:59 <Bish> sure, same thing, but i got applicative after monads
05:15:05 <Bish> like, really, i have read it
05:15:18 <tdammers> Bish: it's a balance between "easy" and "simple" (where "easy" means "similar to something you already know", and "simple" means "uses few(er) concepts")
05:15:47 <dminuoso> [exa]: Gah, so I was a bit ignorant. getaddrinfo is not a syscall..
05:15:52 <MarcelineVQ> mmm, I use fmap a lot more than I use (>>=)   That's enough reason for it to be the default for me. If you're asking why not change the Functor instance to be <$> and fmap to be the extra prefix version, well, why change it?  If we're after consistency bind should be (=<<) instead of (>>=) as well, seems like odd things to change just because
05:16:02 <Bish> but easy â‡’ "something you know" is an assumption
05:16:04 <Bish> i don't think so
05:16:14 <tdammers> Bish: binary numbers are simpler than decimal: they only use two different digits instead of 10. But humans already know how to use their 10 fingers to represent numbers, and extending that system to 10 digits is easier, though not simpler, than switching to binary
05:16:27 <Bish> i am not saying we should use binary
05:16:29 <Bish> just not base 10
05:16:38 <tdammers> "easy" = "similar to something you already know" is meant to be a definition here
05:16:46 <Bish> yeah, well
05:17:01 <tdammers> I gave it because people confuse "simple" and "easy" all the time
05:17:07 <tdammers> but the distinction matters
05:17:10 <tdammers> anyway
05:17:13 <Bish> reminds me of that, "how does the mathmatician get out of the cage" joke
05:17:39 <tdammers> naming things is hard, and the choice is often arbitrary
05:17:58 <tdammers> so to make it easier (not simpler, mind you!) we often pick names that are somehow based on something familiar
05:18:01 <merijn> s/arbitrary/made for hard to articulate human, cultural, and background reasons
05:18:30 <tdammers> I mean it's arbitrary from a purely logical and technical point of view
05:19:29 <tdammers> fmap is based on map, which was discovered and understood before the Functor generalization was found
05:19:51 <Bish> and what did haskell do in the and?
05:19:53 <Bish> end*
05:19:57 <Bish> the swapped it around
05:20:02 <Bish> because it was discovered
05:20:08 <tdammers> swapped what around?
05:20:15 <Bish> map = fmap for lists
05:20:22 <Bish> but you won't find map somewhere else
05:20:26 <Bish> even though it was discovered first
05:20:32 <tdammers> it's still there
05:20:41 <Bish> where?
05:20:42 <tdammers> :t map
05:20:44 <lambdabot> (a -> b) -> [a] -> [b]
05:20:46 <tdammers> in Prelude
05:20:47 <Bish> sure, for lists.
05:20:57 <Bish> in one single point (where it was discovered)
05:20:59 <tdammers> yes of course, map has always been a list-specific thing
05:21:01 <Bish> yet you don't name fmap map
05:21:03 <dminuoso> Okay I found the issue. network appears to have some incorrect error handling.
05:21:19 <Bish> wasn't your argument naming things to things you're used to?
05:21:22 <tdammers> yes, because map is already named map, and we don't like breaking changes a lot
05:21:44 <tdammers> my argument was about picking names *based on* something we already know
05:21:46 <Bish> following your argumentation i would name fmap map(since this name was used first)
05:21:51 <dminuoso> tdammers: I'd bet to differ. Unlike many other languages we *do* embrace breaking changes, but we do it slowly in phases with migration plans.
05:21:53 <Bish> and have a maplist instead
05:21:56 <dminuoso> *beg to differ.
05:22:10 <dminuoso> tdammers: Consider things like AMP, Monoid/Semigroup..
05:22:17 <tdammers> dminuoso: we don't embrace breaking changes; we're just more willing to make them when the benefits are tangible
05:22:21 <Bish> to me. fmap and map how they are are making SUPER sense, and you're saying the opposite
05:22:22 <dminuoso> Heh fair enough.
05:24:11 <tdammers> my point is that fmap is called fmap because "fmap" is similar to "map"; we could have called it "f487987213" or "pancakes", but "fmap" is easier because of the similarity
05:24:46 <tdammers> now which of the two deserves the "map" name is a matter of debate, and there are even alternative Preludes around where map is defined to be exactly fmap
05:25:37 <tdammers> but from a change management perspective, map was first, and generalizing it is going to introduce more breakage (certain expressions now become ambiguous), while having to type fmap instead of map isn't a huge burden
05:25:57 <merijn> To be fair, fmap used to named map
05:26:09 <merijn> It was changed because "it was confusing to beginners"
05:26:09 <Bish> well isn't haskell older than that?
05:26:51 <Bish> well, it didn't confuse me now. so they might be right
05:26:55 <Bish> :p
05:27:23 <merijn> Bish: My point is, one reason to use fmap instead of <$> would be the fact that that was closer to "map"
05:27:33 <yushyin> https://www.haskell.org/definition/aboutHaskell98.html Appendix A
05:27:40 <merijn> Also, <$> mostly makes sense when combined with <*> from Applicative
05:27:44 <Bish> but then again... understanding that the List monad is nothing special isn't so obvious
05:27:46 <merijn> But Applicative wasn't invented until 2004
05:27:57 <Bish> would be cool if the type was f a instead of [a]
05:28:07 <Bish> merijn: shit's so young?
05:28:19 <Bish> man i wish i would've knew this back then
05:28:29 <tdammers> I prefer to say it was discovered rather than invented
05:28:46 <Bish> yeah that's the thing that strikes me mouth with this category stuff
05:28:51 <Bish> people seem to not construct things
05:28:58 <merijn> Bish: Monad and Functor predate Applicative by 14-ish years, yes
05:29:15 <merijn> Bish: Hence lack of consistency in naming
05:29:19 <Bish> they're like "this type matches, i wonder if i can make this a monoid"
05:29:21 <merijn> I'm not sure when <$> was coined
05:29:24 <Bish> boom
05:29:36 <merijn> Bish: Monoid is algebra, not category theory, though ;)
05:29:39 <tdammers> part of the reason is probably because most things are either full-blown Monads, or just Functors. Things that are Applicatives but not Monads are relatively rare.
05:29:50 <merijn> The impact of category theory on "normal" Haskell is usually very overstated
05:30:08 <Bish> merijn: but if a certain type becomes applicative because of a monoid, it do matter, doesn't it?
05:30:28 <Ariakenom> merijn: I actually use bind quite often
05:30:34 <tdammers> or, put differently, the benefits of restricting yourself to applicatives instead of just making it a monad aren't super obvious until you've experienced them
05:31:04 <Ariakenom> I know what you meant though
05:31:36 <dminuoso> Bish: One of the main issues in my opinion is actually a phrase that you just said
05:31:39 <dminuoso> "The List monad"
05:31:43 <dminuoso> Or equivalently "The IO monad"
05:31:53 <dminuoso> Which confuses two separate things.
05:31:54 <Bish> issues with what exaclty?
05:32:07 <Bish> how so?, that really helped me understand namiong those like that
05:32:50 <Bish> are you saying those 2 are the same things?
05:33:13 <dmwit> Bish: How come you don't call it "the list Ord"?
05:33:16 <dminuoso> Bish: No it's just that a lot of confusion comes from the fact that you put "IO/List/Maybe" and "monad" into the same term.
05:33:29 <dminuoso> Bish: The core nature of IO is not that it's a monad.
05:33:32 <Bish> dmwit: primary property is bind?
05:33:35 <dminuoso> Just like the core nature of [] is not that it's a list.
05:33:35 <Bish> or rather, the most important
05:33:42 <Bish> dminuoso: how would is ay it?
05:33:53 <Bish> how would i say it*, what is []?
05:34:00 <dminuoso> A type constructor for lists.
05:34:09 <dminuoso> Oops sorry!
05:34:19 <Bish> :D
05:34:20 <dminuoso> I meant to write: the core nature of [] is not that it's a monad!
05:34:41 <Bish> tbh, i would've not noticed that [] is a monad instance? did i say that correct?h
05:34:47 <yushyin> List with Monad instance, IO with Monad instance etc.
05:34:56 <Bish> ohyeah, i get your point
05:35:03 <Bish> you're right, i won't call it that anymore
05:35:47 <dminuoso> In particular it tends to introduce additional confusion to beginners when you talk about "the IO monad", rather than just "IO" - which would just signal that effects happen here.
05:35:49 <merijn> Bish: dminuoso's point is this: https://blog.jle.im/entry/io-monad-considered-harmful.html
05:35:52 <dminuoso> ^- :)
05:36:05 <dmwit> Monad *is* an important part of list's API, and of IO's API. But the full API has lots of other important bits, too.
05:36:24 <tdammers> something being a Monad isn't any more important than something being a Num, an Ord, an Eq, a Monoid, etc.
05:37:14 <merijn> tdammers: I would say that Ord, Eq, and Monoid are considerably more important than Num :p
05:37:17 <tdammers> but I think the issue at hand here is that Monoid, Monad, and similar typeclasses actually represent concepts that include both the type and the operations
05:37:45 <tdammers> e.g., we sometimes speak about "the integer addition monoid", meaning that integers form a monoid under addition
05:38:19 <tdammers> or more precisely, there exists a monoid that consists of the set of integers, integer addition, and integer 0
05:38:46 <dminuoso> tdammers: In that case it's more likely meant as a specialization (which integer monoid? the integer addition monoid!) though, rather than a characterization of "integer addition", no?
05:38:47 <tdammers> so we could say that the term "IO Monad" refers to the monad that is formed by the IO type
05:39:06 <dminuoso> tdammers: But that's taking the category theory perspective really.
05:39:26 <tdammers> dminuoso: set theory, if you prefer, but yes
05:39:56 <tdammers> I totally agree that "The IO Monad" isn't a helpful term when it comes to Haskell
05:39:57 <Bish> i already understand
05:40:00 <dminuoso> From a usage/programmers point you just care about the fact that there exists an instance Monad for the type constructor IO. So it's just about the fact that IO satisfies some interface.
05:40:01 <[Leary]> Imo there's nothing wrong with the terminology itself; the only issue is that beginners misuse and misunderstand it. I'd rather follow that up by using it well than by avoiding it entirely.
05:40:07 <Bish> the List applicative
05:40:09 <Bish> :p
05:40:15 <dminuoso> Bish: But then - which one?
05:40:22 <dminuoso> Bish: [] has two valid Applicative instances.
05:40:30 * Bish checks that
05:40:37 <dminuoso> Bish: dont check
05:40:40 <dminuoso> Bish: Try to find them yourself.
05:40:48 <Bish> i don't know what you mean
05:41:24 <Solonarv> try to figure out what they are, without looking them up
05:41:31 <tdammers> find sensible ways of implementing the Applicative interface for lists
05:42:35 <Bish> ahh, that's what you mean.
05:43:07 <Bish> that brings a new question to my mind, which i not yet know:
05:43:26 <Bish> how do you actually do something like saerch in O(log n)
05:43:30 <Bish> in haskell?
05:44:06 <dminuoso> Bish: The same you would in any language.
05:44:10 <merijn> Bish: Depends on the something. There's several random access array datatypes. There's Map and Set...
05:44:45 <Bish> i mean, how are they implemented? if i think about it, i just come back to those recusive things like list does it
05:44:53 <Bish> i mean how do you achieve that in lambda calculus
05:45:05 <dminuoso> Bish: Haskell is not lambda calculus.
05:45:28 <dminuoso> Bish: GHC has plenty primitives to provide raw memory access.
05:45:42 <Bish> so it's hacked in? kinda?
05:45:47 <Bish> part of the RTS?
05:45:53 <dminuoso> Not hacked in. It's engineered using GHC primitives.
05:46:05 <dminuoso> Just like say Ruby Hash is engineered.
05:46:07 <Solonarv> Depends: what do you mean by "search"?
05:46:08 <Bish> well, but List has some beauty to it
05:46:39 <Bish> you can write your own, you won't be able to write said primitives, am i correct?
05:46:54 <dminuoso> Bish: You can write said primitives just fine.
05:47:02 <Bish> in C?
05:47:02 <tdammers> List is also implemented with primitives
05:47:24 <Bish> tdammers: which one?
05:47:26 <dminuoso> Bish: no in Haskell.
05:47:28 <dminuoso> Bish: https://github.com/haskell/containers
05:47:42 <dminuoso> Bish: Is one of the more popular libraries implementing an assorted set of fast containers.
05:47:59 <dminuoso> It's written in Haskell.
05:48:11 <Ariakenom> Bish: you can define a tree with data like you can a list
05:48:56 <tdammers> Bish: apart from the syntax sugar, it's essentially data List a = Nil | Cons a (List a); list operations use all sorts of primitives, typically pattern-matching and guards and such
05:49:17 <Bish> yeah i understand that.. that's why i ask
05:49:28 <Bish> you won't binary search inside there, though
05:49:35 <dminuoso> Heck you can even unsafeCoerce between that `List a` and `[a]` for some choice of `a`.
05:49:37 <Bish> and there are data structures that can do that
05:49:40 <dminuoso> In most cases it will even work.
05:49:53 <dminuoso> So Haskells list primitive is not special at all, apart from the syntax.
05:49:57 <merijn> Anyway, primitives weren't "hacked in", supporting low level operations/primitives has been an explicit design goal of Haskell from the start
05:49:58 <Bish> Ariakenom: same goes for the tree.
05:50:28 <tdammers> in fact, we spend quite some effort on figuring out robust semantics for all those primitives
05:50:46 <tdammers> including primitives that deal with raw memory access
05:50:47 <Ariakenom> Bish: You can log n search a binary search tree though
05:53:35 <dminuoso> Bish: Like tdammers has hinted at: We have full access to raw memory, can do pointer manipulation of any kind, manual memory management..
05:53:47 <dminuoso> This is *ontop* of Haskell providing excellent high level abstractions/semantics.
05:54:08 <merijn> I have a challenge for anyone bored in here: I need to compare (so fuzzy equality) K outputs of N floating point values, but N is sufficiently large that storing the entire output isn't feasible. Suggestions for how to tackle this?
05:54:42 <dminuoso> Bish: We even have FFI defined in the Haskell standard, in order to faciliate stable interfaces with native libraries.
05:55:14 <Solonarv> [] is a linked list. You can't search through a linked list faster than Î©(n). This isn't a limitation of Haskell, it's a limitation of linked lists.
05:57:20 <Bish> Solonarv: yeah, i understand that.. but how do you write something that is not linked list
05:57:48 <Bish> that's still magic to me
05:58:00 <Solonarv> Depends on what it is you want to write instead! That question is like "How do you cook something that isn't tomato soup?"
05:58:14 <Ariakenom> data Tree a = Leaf | Branch a (Tree a) (Tree a)
05:58:31 <Bish> Solonarv: well, being pure functional recursive structurs like tree and list make sense
05:58:35 <Solonarv> ^ now you have a binary tree, for example
05:58:45 <Bish> but what do i do if i want the middle element of a list
05:58:52 --- mode: glguy set +v knack
05:58:57 <merijn> Bish: There' Array and Vector
05:59:09 <Bish> so, how is Array implemented?
05:59:11 <Solonarv> A binary tree is not a linked list! So if you've written a binary tree you've written something that isn't a linked list
05:59:31 <Bish> Solonarv: A List is also a Tre
05:59:45 <Ariakenom> But a tree isn't a list
05:59:46 <Bish> so i have written a tree
05:59:51 <dminuoso> Bish: Like I said. Haskell/GHC has primitives for raw memory access.
05:59:58 <dminuoso> Bish: With those you can build containers of any kind.
06:00:06 <Ariakenom> taking the middle of the tree is just the top, easy
06:00:22 <Bish> but i have to live with them being a big blackbox? dminuoso?
06:00:23 <Solonarv> Array is implented on top of one of these primitives. So is Vector. (it may even be the same one, I don't remember)
06:00:57 <Solonarv> Depends on your definition of "blackbox", I suppose.
06:01:09 <merijn> Bish: No, they're pretty well documented in things like ghc-prim, etc.
06:01:21 <dmwit> Ariakenom: ...*if* the tree is balanced.
06:01:22 <merijn> They're just super low level and easy to mess up with
06:01:37 <dminuoso> But that's not too different from containers implemented in any other language on this planet.
06:01:46 <Ariakenom> haskell tends to be very good at avoiding compiler-only magic, imo
06:01:53 <Bish> merijn: well input output being documented still makes it a black box :p
06:01:55 <merijn> Bish: All the low level stuff you could ever want: https://hackage.haskell.org/package/ghc-prim-0.5.3
06:01:58 <dminuoso> If you want to look at how std::vector in common C++ standard libraries is implemented, there's lots of subtleties and cruft.
06:02:00 <Solonarv> GHC and its RTS are open-source, so you can go look at the implementation if you want. That less black-box-y than, idk, file access!
06:02:22 <merijn> Bish: The details of *how* things are implementing are documented to, just GHC specific
06:02:41 <dmwit> dminuoso: Just for the record: there are significantly more than two valid Applicative [] instances.
06:02:46 <Bish> well, another implementation may name the package differenty, doesn't it?
06:02:51 <dminuoso> dmwit: Oh really? :o
06:03:09 <Bish> well, thanks i learned a lot as usual
06:03:14 <dminuoso> dmwit: Okay Ill have to ponder about that.
06:03:19 <merijn> Bish: This is similar to wanting to know the implementation of C++'s STL (like std::vector) or libc stuff like libc's qsort. Nothing wrong with wanting to know, but you shouldn't have to, and you don't :)
06:03:34 <dminuoso> Bish: The difference between how Haskell containers and other language containers are implemented is rather simple:
06:03:43 <Bish> yeah, i got to know how things work, otherwise i won't be able to use them (it's me)
06:04:11 <dmwit> dminuoso: For example, `pure x = [x]; fs@(f:ft) <*> xs@(x:_) = map f xs ++ map ($x) ft` (+ base cases).
06:04:16 * hackage monad-dijkstra 0.1.1.1 - Monad transformer for weighted graph searches using Dijkstra's or A* algorithm  http://hackage.haskell.org/package/monad-dijkstra-0.1.1.1 (ecramer)
06:04:18 <merijn> Bish: I mean, ghc-prim should be super familiar if you've ever looked at any sort of assembly or C primitives :)
06:04:23 <Bish> without reading the list monad instancs bind operation i would've never understoof why at all
06:04:31 <dmwit> dminuoso: More on the ideas that led to this instance here: https://stackoverflow.com/q/50701827/791604
06:04:35 <merijn> Bish: Also, have you ever read the STG paper?
06:04:40 <Bish> merijn: no
06:05:04 <Bish> and i have no clue what that is
06:05:15 <merijn> Bish: I highly recommend it to anyone who knows a bit of C/asm and "has to know how things work". It basically discusses "how do you compile a lazy functional language to x86 assembly in a sensible way?"
06:05:24 <dmwit> dminuoso: There's also a variant of ZipList where the shorter list is extended, rather than chopping off the longer list.
06:05:26 <merijn> Bish: It's a bit outdated, but an excellent starting point
06:05:28 <merijn> @where stg
06:05:28 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
06:05:31 <Bish> merijn: that sounds like something i'd read
06:05:40 <dmwit> dminuoso: But it seems the lpaste link to that code is dead. =P
06:06:01 <merijn> Bish: It only requires minimal haskell/functional language knowledge and a bit of asm/C helps, but probably not required
06:06:03 <Bish> ohh, i read about this already yeah, i might have, years ago
06:06:40 <merijn> Bish: (I mean, the functional language they use just has pattern matching, functions, function application and allocation, so hard to be more minimal :)
06:06:55 <Bish> merijn: yeah that is my point why i ask about those primitives
06:07:05 <Bish> because using these tools, no clue to write a ByteArray
06:07:18 <Bish> with constant time index access
06:07:46 <merijn> Bish: It also covers some stuff about primitive/unboxed values
06:08:26 <merijn> Bish: ByteArray (in the end) is something built into the compiler, the same way integers and addition in the end up have to be inside the compiler
06:10:19 <merijn> But then again, "int foo[100];" to create an int array has to be built into the C compiler too
06:11:20 <dmwit> On the other hand, `int *foo = malloc(100*sizeof(int))` uses a library.
06:11:29 <dmwit> (...but the library uses compiler builtins. ;-)
06:11:51 <dminuoso> Bish: For Haskell they are not defined and shipped with the language, or defined by the language.
06:12:05 <merijn> dminuoso: Not really :p
06:12:12 <dminuoso> merijn: Mmm?
06:12:15 <merijn> eh, s/dminuoso/dmwit
06:12:27 <tdammers> you could implement malloc in assembly and just link it in, no compiler builtins required
06:12:29 <merijn> dmwit: Generally the library uses raw syscalls (i.e. mmap and sbrk)
06:12:52 <dmwit> tdammers: I consider assembly a compiler builtin.
06:13:06 <tdammers> dmwit: even if the compiler never gets to see it?
06:13:07 <merijn> dmwit: There is no "allocate memory" instruction, though
06:13:18 <dminuoso> Bish: So in Haskell you have to refer to a library in order to get say `Vector`, whereas in C++ std::vector is defined by the standard and shipped with every stdlib.
06:13:20 <pong> > take (((18-4)/3)+1) $ iterate (+16) 16
06:13:23 <lambdabot>  error:
06:13:23 <lambdabot>      â€¢ Could not deduce (Fractional Int) arising from a use of â€˜/â€™
06:13:23 <lambdabot>        from the context: Num a
06:13:29 <dmwit> The ability to make a syscall is something built into the compiler, too.
06:13:57 <dmwit> tdammers: Sure! Or, to say another way: I know of a pretty great compiler that doesn't include the ability to dump assembly in the middle of your program, and I use it every day right here in-channel.
06:13:59 <dminuoso> dmwit: That holds true for every language that is not assembly though. :P
06:14:01 <merijn> pong: You can't use / for integer division
06:14:25 <dminuoso> Though one might argue that the assembler has support for syscalls baked in by fact of knowing about the syscall/sysenter instructions.
06:14:27 <tdammers> seriously though, the point here is that you need to bootstrap from *something*
06:14:27 <merijn> pong: You probably want "div"
06:14:45 <dmwit> tdammers++
06:14:57 <merijn> Pfft, who needs syscalls and assembly. Just run your code in the TLB and APIC
06:15:45 <pong> nice catch thx
06:15:47 <Bish> dminuoso: being a former c programmer i understand that analogy, but i could look at the assmbler code produced and stuff
06:15:51 <Bish> that's a bit harder for haskell
06:15:54 <pong> > take (((18-4)`div`3)+1) $ iterate (+16) 16
06:15:56 <lambdabot>  [16,32,48,64,80]
06:16:05 <Bish> mapping raw code â‡” assembler is pretty easy for c
06:16:24 <Bish> can you actually have sourcemaps in haskell, no right?
06:16:47 <tdammers> you can look at the intermediate code at various stages of the compilation
06:16:47 <merijn> Bish: GHC can output various intermediate stages
06:17:06 <Bish> yeah that doesn't help if it's not really human comprahensible
06:17:16 <tdammers> it's no worse than assembly
06:17:18 <merijn> Bish: It first produces Core (which you can output), then STG (which you can output), and recent GHC's generate DWARF output for assembly
06:17:29 <merijn> Bish: Core and STG are more readable than raw assembly from C compilers
06:17:46 <tdammers> plus there's tools to make them easier to handle
06:18:14 <tdammers> you do generally lose the ability to track things back directly to a source line
06:18:41 <tdammers> however given the rather drastic rewrites that the various compilation stages tend to do, I doubt that this would be extremely helpful in practice
06:18:42 <Solonarv> GHC also has an LLVM backend if you want to read LLVM
06:20:34 <Bish> tdammers: that's highly subjective, isn't it?
06:21:46 <tdammers> Bish: well, from a practical point of view, a somewhat optimized GHC-Haskell program will generally end up consisting mostly of stuff that is the result of heavy rewriting and cannot be traced back to any particular source line
06:22:05 <tdammers> for example, we have transformations where nested case expressions are turned inside-out
06:22:23 <tdammers> this will replicate the outer case into the inner case branches
06:22:29 <Solonarv> GHC performs drastic rewrites during compilation, and this makes it hard to have sensible/simple mapping from compiled binary to source code. This is not subjective. The subjective part is how helpful a *really complicated* source-map could possibly be
06:22:38 <tdammers> but after that, we delete the provably unreachable branches
06:23:42 <tdammers> so yes, you could keep source positions around through all that; but in order to understand what is going on, this is not going to be very helpful, because more than where that particular bit of code came from, you are interested in the kind of transformations that were applied, and how they came about
06:23:52 <merijn> @quote cmccann adhd
06:23:52 <lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
06:23:58 <dminuoso> Bish: It's not harder at all.
06:24:09 <dminuoso> Bish: You can look at core or stg code.
06:24:19 <dminuoso> Bish: It's just that you have less experience with core/stg than you may have with assembly.
06:24:34 <dminuoso> Oh sorry, was scrolled up. :)
06:24:46 <merijn> Also, as someone who has very recently looked at C++ generated assembly: The inspectability of C/C++ assembly is...highly overrated
06:25:21 <dminuoso> Yup, when you have highly optimized vectorized code - with GCC interleaving code to keep execution ports filled, code reordered to improve predictors..
06:25:54 <dminuoso> as-if allows compilers to do a *lot* of non-obvious things.
06:26:57 <dmwit> Have you seen that godbolt thing? It's got what you're saying is hard. You put in some Haskell code, it highlights which Haskell line corresponds with which assembly.
06:27:17 <dminuoso> dmwit: godbolt has haskell support? :o
06:27:24 <dmwit> Right??
06:27:35 <dminuoso> Oh my, Im truly excited now.
06:29:02 <MarcelineVQ> Solonarv: so, how do you? everything is red all the time and it will not come out in the wash
06:29:18 * Solonarv is very confused
06:29:25 <MarcelineVQ> :>
06:29:51 <merijn> dminuoso: Next thing I want: Nice Intel VTune support for Haskell code :>
06:30:24 <merijn> dminuoso: I've been curious how well GHC's DWARF support plays with VTune, but I honestly don't have the time to investigate
06:31:51 <dmwit> MarcelineVQ: What is the difference between a duck?
06:32:55 <MarcelineVQ> 326
06:33:03 * ski . o O ( "It's yellower on the side, than on the morning." )
06:33:20 <merijn> Since all the academics hang out here: In academic prose do I say: "standard in", "stdin", or "\texttt{stdin}" when talking about, well, stdin?
06:33:38 <dminuoso> merijn: stdin in what sense?
06:33:52 <merijn> dminuoso: As in, "the thing programs can read from"
06:34:00 <Solonarv> "standard in" sounds weird to me, I'd choose between "standard input" and "stdin" (possibly formatted)
06:34:10 <dminuoso> merijn: `standard input`
06:34:13 * Solonarv is not a real academic (disclaimer)
06:34:33 <merijn> Solonarv: I am (supposedly) and I still don't know :p
06:34:45 <dmwit> \texttt{stdin} would be my choice.
06:35:21 <dmwit> But I would look at it and worry that I had gotten too lost in operational details, and failed to properly abstract the concepts of the paper.
06:35:23 <merijn> Clearly I need a bigger sample size...
06:35:53 <merijn> dmwit: This is the "experimental setup" of my thesis where I'm explicitly only talking about operational details of my code :p
06:36:16 <merijn> If people don't wanna read about stdin and stuff they can fuck off to a more relevant chapter :p
06:36:31 <dmwit> Then it is 100% appropriate to use the standard jargon that people who do wanna read about stdin would recognize.
06:39:11 <tdammers> what a beautifully dished out academic burn... "fuck off to a more relevant chapter"
06:39:48 <MarcelineVQ> 'I've a wonderfully scathing invective that this margin is too small to contain.'
06:40:26 <merijn> tdammers: Proper doses of swearing always make text more engaging :p
06:41:06 <seishun> tried to solve today's aoc and got this "ghc.exe: internal error: IMAGE_REL_AMD64_ADDR32[NB]: High bits are set in 19ac5d848 for .text" :(
06:41:19 <merijn> Honestly, this year's SuperComputing conference once again drove home that academic presentations need more profanity and memes, and less dull monotone slides with way too much text...
06:41:25 <merijn> seishun: Impressive :)
06:41:39 <merijn> seishun: That sounds like the kinda error you might wanna ask #ghc about :)
06:42:00 <MarcelineVQ> merijn: memes don't stay fresh forever merijn :O
06:42:08 <MarcelineVQ> The paper could spoil.
06:42:26 <merijn> MarcelineVQ: Most academic presentations aren't ever fresh...
06:42:50 <MarcelineVQ> I guess, but they can be phresh
06:43:37 <seishun> can't reproduce it anymore
06:44:16 <merijn> seishun: Honestly, if it only happens once and never again I'd go download a memory checker
06:44:40 <merijn> seishun: Because that error + lack of reproducibility sounds like either RAM that's starting to die or a super unlucky bitflip from cosmic rays
06:44:57 <seishun> it happened after I hit stack overflow in ghci several times
06:50:47 <avidela> Can someone help me with dependent haskell? I've made a gist with the problem I'm trying to solve https://gist.github.com/andrevidela/b51d2671959be185e4bb6fe2c7ce6788
06:51:30 <avidela> I've been reading through Hasochism multiple times but I can't quite make it work basically I need a pi-type that can select the correct typeclass from a value of type `ValueKind` in the example
06:51:40 <avidela> the correct instance*
07:01:32 --- mode: glguy set +v jadrian
07:01:43 --- mode: glguy set -v jadrian
07:01:59 <jadrian> years ago, wasn't there some talk about making `join` part of the actual class definition? 
07:02:56 --- mode: glguy set +v gobrewers14
07:03:09 <Solonarv> Yes, but there's a snag related to GeneralizedNewtypeDeriving
07:03:24 <jadrian> oh
07:03:46 <Solonarv> I don't recall the details, but QuantifiedConstraints fixes that snag, so hopefully `join` can be in `Monad` soon-ish.
07:04:25 <jadrian> Solonarv: yes was now searching for it and found this https://ryanglscott.github.io/2018/03/04/how-quantifiedconstraints-can-let-us-put-join-back-in-monad/
07:04:29 <jadrian> will take a look at it
07:04:46 <MarcelineVQ> gosh that ryan's a busy guy
07:05:57 <seishun> oh man, I spent like an hour figuring out why my code hangs only to find out I had pasted `import qualified Data.Map.Strict as Map` from another file...
07:10:24 --- mode: glguy set +v ais
07:11:52 <Bish> why exactly aren't Chars utf8 by default?
07:12:03 <tdammers> because that doesn't make sense
07:12:10 <Bish> tdammers: why doesn't it?
07:12:13 <tdammers> a Char is a code point without any specific encoding
07:12:45 <Bish> well, and why doesn't it include all chars that are in utf8?
07:13:05 <tdammers> because that doesn't make sense either
07:13:10 <tdammers> there are no chars in utf8
07:13:16 <tdammers> utf8 is an encoding
07:13:19 <tdammers> not a character set
07:13:21 <Bish> so when i do 'ðŸ˜‹'
07:13:32 <tdammers> the associated character set is called "Unicode"
07:13:41 <Bish> does the terminal send the bytes down the drain and haskell says
07:13:43 <tdammers> and a Char can represent any Unicode code point
07:13:51 <Bish> ohyeah thats /128523
07:13:56 <tdammers> well, almost
07:14:19 <tdammers> so what happens (in any language, really, provided it does strings correctly) is this:
07:14:47 <tdammers> when you type, your terminal emulator processes your keystrokes and assembles them into strings, using whichever encoding it sees fit
07:15:08 <tdammers> or rather, the shell does the string stuff, the terminal emu just sends keystrokes to the shell
07:15:22 <tdammers> (and the current locale tells both ends which encoding to use)
07:15:26 <tdammers> so
07:15:33 <Ariakenom> % putStrLn "ðŸ˜‹"
07:15:33 <yahb> Ariakenom: ðŸ˜‹
07:15:49 <Bish> string encoding always confused e
07:15:50 <tdammers> anyway, when that string reaches your Haskell program, it arrives in *some* encoding
07:15:56 <tdammers> typically utf-8
07:16:15 <tdammers> on the Haskell side of things, what happens next depends on the string type
07:16:30 <Solonarv> (to be fair, Haskell doesn't quite do strings right: they're a linked list of characters)
07:16:31 <Bish> well, i am asking for the default i am aware there are encoded stirngs
07:16:39 <tdammers> Solonarv: code points, actually
07:16:47 <Solonarv> (if you want to do strings right, use the 'text' library)
07:17:00 <Bish> tdammers: so why don't stupidi encoding things happen?
07:17:02 <tdammers> Solonarv: technically, 'text' also does strings wrong
07:17:09 <tdammers> Bish: they do, if you do it wrong
07:17:13 <Bish> how is that emoji one char and not multiple? since it has multiple bytes
07:17:27 <Solonarv> tdammers: oh? wrong how?
07:17:29 <tdammers> Bish: but the default functionality in Haskell uses encoding-agnostic string types (String or Text)
07:17:34 <Bish> i mean haskell seems to notice it is utf8 transform and not care about it
07:17:51 <tdammers> Solonarv: getting the length of a Text counts code points, not actual string length
07:17:54 <Bish> tdammers: if it was agnostic, it would say "that char is 4 bytes, dunno what that is, probably 4 chars"
07:17:57 <Bish> doesn't it?
07:18:09 <Bish> or does ghci read the bytes utf8 then transform it in a good way
07:18:12 <tdammers> Solonarv: and likewise, equality is ill-defined in the face of things like combining diacritics
07:18:14 * hackage recursion 1.2.2.0 - A recursion schemes library for GHC.  http://hackage.haskell.org/package/recursion-1.2.2.0 (vmchale)
07:18:40 <Solonarv> no, "agnostic" means it doesn't care how they're represented.
07:18:47 <tdammers> Bish: no. "agnostic" here means that a String (or Text) value doesn't care how it was once encoded, or how it will be encoded later
07:19:09 <tdammers> Text internally uses UTF-16, but you practically never get to see this unless you poke at the code
07:19:45 <Bish> i don't get it
07:19:46 <tdammers> String uses linked lists of >=32-bit ints to represent code points directly
07:19:55 <Taneb> doctest-discover seems neat
07:19:59 <Bish> something needs to know that this is a utf8 char, doesn't it?
07:20:10 <tdammers> there is no such thing as a utf-8 char
07:20:14 <Bish> i mean.-. string might be agnostic, but something tells this string: this char is 4 bytes
07:20:21 <tdammers> no
07:20:28 <Ariakenom> there are a few concepts. bytes, encodings, codepoints. An encoding takes a list of codepoints and produces bytes.
07:20:46 <tdammers> Char has at least 32 bytes available, so any Unicode code point ("char", colloquially) will fit
07:21:01 <aweinstock> Bish: https://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text-Encoding.html#v:decodeUtf8 "knows" about utf8, in some sense
07:21:04 <Bish> but how does it know to take those 4 bytes
07:21:15 <tdammers> it doesn't
07:21:23 <tdammers> it doesn't take any bytes
07:21:40 <tdammers> it always holds a full code point, and it always reserves 32 bits (or more) for it
07:21:56 <tdammers> > ord 'a'
07:21:59 <lambdabot>  97
07:22:06 <tdammers> > ord 'ðŸ’©'
07:22:09 <lambdabot>  128169
07:22:14 <tdammers> see?
07:22:25 <Bish> no, i will never get this as it seems :D 
07:22:47 <Bish> i mean.. if ghci reads from stdin it gets "a\x12\x23\x23" something, doesn't matter
07:23:01 <Bish> how does ghci see, that's an a.. and that 3 bytes are freakin one char
07:23:03 <tdammers> OK, forget about stdin and all that for a sec
07:23:37 <Solonarv> String is not the function performing this conversion. 'getChar' (the function for reading one character from stdin) is.
07:23:42 <tdammers> you have a bunch of codepoints out there ("chars"): letters, digits, kanji, emoji, dingbats, diacritics, zero-width spaces, you name it
07:23:55 <tdammers> in order to represent those in a computer, we number them
07:24:43 <tdammers> and the way things are, we have a lot of those code points, but no more than 2^32, so we can simply assign numbers to all of them, and then store those numbers as 32-bit integers
07:24:48 <tdammers> following so far?
07:24:51 <Bish> yes.
07:24:53 <tdammers> OK
07:24:59 <tdammers> so now comes the next issue
07:25:01 <Bish> i et it, char counts to 2^32-1
07:25:06 <tdammers> yes
07:25:29 <tdammers> and the `ord` and `chr` functions allow you to translate directly between a Char and its associated 32-bit integer
07:25:46 <tdammers> now, 32 bits per code point is enough, but it's not very efficient
07:25:49 <marvin2> > ord (maxBound :: Char)
07:25:52 <lambdabot>  1114111
07:26:34 <tdammers> also, when we pipe strings between programs, those programs will read and write streams of bytes, not 32-bit ints
07:26:48 <Bish> yes, that's what i descriped hwen saying
07:26:51 <Bish> i mean.. if ghci reads from stdin it gets "a\x12\x23\x23" something, doesn't matter
07:27:06 <Bish> but still, something nows aobut the emoji, so what is it
07:28:01 <Ariakenom> Bish: "and the current locale tells both ends which encoding to use"
07:28:35 <Bish> Ariakenom: yeah, what function does this
07:29:13 <Solonarv> look for 'hGetChar'
07:29:44 <tdammers> so we need a way to marshal between "32 bit integers" and "streams of bytes"
07:30:02 <aweinstock> `printf "\x12\x23\x23" | ghc -e 'getChar >>= print . Data.Char.ord'` prints out 18 on my system; does that mean it's empirically bytewise?
07:30:44 <aweinstock> (hGetChar sourc at https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Handle.Text.html#hGetChar has some unrolled newline checking, but I don't see any unicode support unless that's delegated to readTextDevice)
07:30:50 <aweinstock> s/sourc/source/
07:31:28 <Solonarv> you should first check that it round-trips, I think? i.e. that getChar is using the encoding you think it is
07:31:40 <Solonarv> Mismatched encoding has bitten me in the back a few times
07:31:57 <ais> is it bad practice to use records in haskell? it seems to limit future change as the constructor requires all fields to be present, and it also has that namespace problem.
07:32:11 <dminuoso> ais: What namespace problem does it have?
07:32:25 <dminuoso> ais: And records are by no means bad. They are just product types, and thus a really useful tool.
07:32:43 <Solonarv> ais: the usual workaround to the naming issue is to add the record's name to each field
07:32:50 <Clint> aweinstock: which character do you think \x12\x23\x23 is in which encoding?
07:32:51 <dminuoso> ais: The extensibility you mentioned is a problem though in Haskell that has no trivial solutions. Some advanced solutions based on type trickery exist though for extensible records.
07:32:51 <Solonarv> (or possibly an abbreviation of it)
07:33:11 <Solonarv> i.e. 'data Person = Person { personName :: String, personAge :: Int }'
07:33:50 <aweinstock> Clint: I don't know what it was supposed to be, Bish posted "a\x12\x23\x23" as an example, and the 'a' was clearly parsing as ASCII for me (printing out 97), so I checked to see if throwing away the first character changed anything
07:34:32 <Clint> well, that's valid utf-8 for 3 (or 4) separate characters
07:34:46 <merijn> ais: Yes, no, maybe, it depends.
07:34:50 <merijn> ais: Take your pick ;)
07:35:05 <ais> i was asking, because recently i heard a talk by Rich Hickey
07:35:31 <ais> he did not seem to like records very much
07:35:44 <Clint> aweinstock: try printf "\xe2\x82\xac" | ...
07:35:48 <dminuoso> ais: Well it's probably from a particular point of view.
07:35:58 <marvin2> ais, "limit future change as the constructor requires all fields to be present" <- what exactly do you mean by this? and not all fields need to be present, but you'll error if you try to fetch unassigned field
07:36:02 <dminuoso> ais: One common issue with records in Haskell is that they are not extensible.
07:36:16 <dminuoso> Though libraries like `vinyl` give you trickery to address this.
07:36:33 <Clint> a point of view wherein Maybe and Either are oppressing him
07:36:47 <Solonarv> \x12 appears to be â†•
07:36:49 <aweinstock> `python -c '__import__("sys").stdout.write(u"\u2663".encode("utf8"))' | ghc -e 'getChar >>= print . Data.Char.ord'` shows 9827, so it's definitely reading utf8
07:36:56 <Solonarv> (at least in whatever encoding yahb uses)
07:37:18 <Clint> aweinstock: then your locale is probably using utf-8
07:37:48 <tdammers> Bish: alright, so the deal is we need to convert between "strings" (in whichever internal representation we want to use) and "bytes" (which is just raw byte sequences)
07:37:59 <tdammers> in Haskell, we represent those as separate types
07:38:12 <tdammers> Text / String for strings, and ByteString for byte sequences
07:38:32 <tdammers> and because they are separate types, we need to convert between them explicitly, which is good
07:39:37 <tdammers> now, on to utf-8
07:40:03 <tdammers> the simplest possible encoding we could pick would be to just use 4 bytes for each code point, and then just dump the 32-bit integers in there, in either little-endian or big-endian format
07:40:19 <dminuoso> Assuming the two functions coming from Data.Text, is this a lawful ISO? `iso encodeUtf8 decodeUtf8`
07:40:36 <tdammers> but that's not efficient, because some code points are very rare in practice, whereas a small handful of codepoints will appear very often
07:40:49 <dminuoso> Ive been staring at my code for about an hour now - debugging this crypto stuff would take a real long while, so Im hoping that my mistake lies in a wrong assumption here.
07:40:50 <tdammers> after all, this is how we got away with just 7 bits before
07:41:37 <merijn> dminuoso: Those are not required to be isomorphic, no
07:41:42 <ais> marvin2, i tried skipping one field when making a record, and my tests returned "Missing field in record construction chordType". Is this maybe because my record type is deriving Eq class?
07:41:43 <Solonarv> dminuoso: it probably is up to normalization, but I'm not sure if that still holds for stricter notions of equality
07:42:04 <merijn> dminuoso: Composite unicode characters can have multiple representations in terms of codepoints
07:42:07 <tdammers> so the utf-8 encoding makes clever use of this fact: frequently used code points are assigned numbers below 128, which makes them fit into 8 bits while keeping the MSB zero
07:42:19 <merijn> dminuoso: And I don't think Text guarantees that roundtripping will preserve the exact codepoint sequence
07:42:45 <tdammers> but anyway, the fact remains that you need to marshal between bytes and strings
07:43:18 <merijn> dminuoso: For example: Ã© can be represented as both a single codepoint for Ã© as well as a codepoint for the Â´ modifier followed by e codepoint
07:43:24 <__monty__> ais: I think they meant literally defining it as `undefined`.
07:43:25 <tdammers> the String- and Text-based IO functions secretly do this for you, which is how they can produce and consume Strings / Texts despite the program reading and writing byte streams on the outside
07:44:01 <tdammers> merijn: Text represents sequences of codepoints though, it doesn't combine modifiers
07:44:18 <marvin2> ais, it isn't. if I had to guess, you added additional field of different type in between, instead of at the end of all the fields. if you want to do changes like that, and keep newly added field undefined (not really the best idea) you can do this Record { field1 = 0, field2 = 1 }. then order does not matter
07:44:46 <merijn> tdammers: Sure, but are you willing to guarantee/bet that encodeUtf8 and decodeUtf8 will definitely produce an isomorphism
07:44:55 <tdammers> merijn: no, probably not
07:45:04 <Reisen> Is there a trick to conditional flags in stack projects? Trying to do something simple where -Werror is off with a command line argument
07:45:11 <tdammers> merijn: but I'd be more concerned about Text's ability to represent invalid UTF-16
07:45:39 <tdammers> merijn: and also the undefined behavior of feeding it malformed input to decode
07:45:59 <Reisen> I'm an idiot, --ghc-options -Werror is fine
07:46:19 <merijn> tdammers: Well, I was assuming dminuoso was asking about applying that ISO to existing valid Text
07:46:20 <seishun> help, why is this giving me a stack overflow https://gist.github.com/seishun/4cc651c45e090b074834e416569a93e5
07:46:43 <tdammers> merijn: as long as the Text is valid, it should round-trip cleanly, I think
07:47:14 <merijn> tdammers: "probably"
07:48:25 <tdammers> merijn: faulty implementations nonwithstanding
07:48:31 <tdammers> (or even just incomplete)
07:49:01 <ais> marvin2, i added it at the end. I wonder if it is possible to initialize a field with a default value, when a record is being created and nothing is palced in that field?
07:50:24 <Bish> do people use typeclasses for serialization?
07:50:31 <dminuoso> Bish: Some do.
07:51:00 <nshepperd> encodeUtf8 and decodeUtf8 should not be secretly normalizing text. that would be quite rude
07:51:01 <marvin2> ais, not directly, but you can do something like this. defaultValues = {-- fill in all the default values --} and then defaultValues { oneField = value }
07:51:33 <dminuoso> Bish: A typeclass is originally just a tool for overloading, though people have started using it for implicit arguments. Another common usecase is capturing lawful pattern.
07:51:38 <merijn> Bish: Depends on the usecase, for quick and dirty code, yes. For code interfacing with external tools/formats I write an explicit serialiser
07:51:54 <Solonarv> Many libraries in fact to just what marvin2  said
07:52:08 <Bish> dminuoso: i wonder why none describes it like that
07:52:11 <dminuoso> Bish: Generally if you have the option between "typeclass or just function/dictionary of functions", chances are the latter is a better choice.
07:52:40 <merijn> Bish: For example, binary's class lets you easily derive a quick serialisation format, but you don't control the exact output, whereas explicit Get and Put values do control that
07:53:02 <Bish> what does actually happen if 2 typeclasses define the same function and you want to use both?
07:53:07 <dminuoso> I really dislike binary/cereal for it doesn't make it obvious *what* it serializes to.
07:53:16 <dminuoso> And it comes with enough default instances that it's biased.
07:54:02 <merijn> dminuoso: Deriving Binary is nice if you don't care (as I said, quick and dirty code), but otherwise explicit Get and Put
07:54:12 <merijn> Bish: Same thing that happens for normal functions
07:54:19 <merijn> Bish: You need to import them qualified
07:54:31 <Bish> but can i be an instance of both then?
07:54:32 <dminuoso> merijn: *bindings/identifiers :)
07:54:37 <Solonarv> Bish: the same thing that happens if you have two ordinary functions with the same name, you get a complaint that GHC doesn't know which one you mean
07:54:48 <dminuoso> It's not just about functions, it's about any identifier you could import
07:55:12 <Solonarv> (this happens when you /actually use/ a name-clashing identifier, not when it's defined)
07:55:27 <merijn> I can't hear the channel over the sound of the pedant police sirens :p
07:55:44 <dminuoso> Heh!
07:56:26 <dminuoso> merijn: I find it curious that this channel has so much more pedantry than ##c++ - but the tone is way more constructive and positive..
07:56:58 <Putonlalla> I think you mean constructive and nonnegative, dminuoso.
07:57:05 * Clint chuckles.
07:57:07 <Solonarv> Bish: yes, you can define an instance for both. You just need to disambiguate the identifiers.
07:57:13 <merijn> dminuoso: I'd get grumpy if I had to think about const lpvalues and prvalues and what nots all day too
07:57:25 <c_wraith> negativity and pedantry usually have a correlation, but it isn't a requirement. :)
07:57:36 <marvin2> ais, here's an example: https://pastebin.com/DiRB6n8W
07:57:57 <Solonarv> i.e. when you have 'foo' imported from both 'A.B' and 'X.Y', you'll need to write 'A.B.foo' and 'X.Y.foo' instead of just 'foo', to specify which one you mean
07:58:38 <dminuoso> merijn: The C++ value taxonomy according to ISO/IEC 14882:2003 does not name a value category named `lpvalue`. What you are referring to must be some non-standard addition and thus outside the scope of this channel..
07:58:44 <dminuoso> Oh wait.. wrong channel!
07:59:03 <merijn> @quote copumpkin brutal
07:59:03 <lambdabot> copumpkin says: orbitz makes [##C++] especially brutal to make people appreciate #haskell more
07:59:06 <c_wraith> they don't have long-playing values?  Then how do they get more than 7 minutes per side?
07:59:19 <merijn> c_wraith: It's "Let's Play" values
07:59:23 <merijn> clearly... :p
07:59:30 <merijn> c_wraith: Keep up with the times!
07:59:55 <dminuoso> merijn: I was really surprised to see that Eelis wrote geordi in Haskell.
08:00:02 <c_wraith> I'm old, I shall remain old. (I'm not really old.  Just old enough that record players were still common when I was a child)
08:00:11 <dminuoso> It's a fancy IRC bot. :)
08:00:17 <merijn> dminuoso: I know
08:00:28 <merijn> dminuoso: Also, no one sane would write an IRC bot in C++...
08:01:58 <bahamas> can anyone tell me how I can use this function to get an AST back? https://gitlab.com/joneshf/purty/blob/master/lib/Module.hs#L70 the whole free-monad thing confuses me
08:02:19 * dminuoso wonders, don't PureScript folks have dedicated chats?
08:02:21 <orion> Are State and ST equal in terms of expressive power? 
08:02:38 <bahamas> dminuoso: they do, but this is Haskell, that's why I'm asking here
08:02:50 <Ariakenom> what's expressive power?
08:03:04 <orion> Ariakenom: One can be expressed in terms of the other.
08:03:21 <dminuoso> bahamas: Oh I don't mind really, it was curiosity. People talk about other languages frequently in here.
08:03:48 <dmj`> Anyone know why hpack puts Main.hs into other modules? And how can I get it to not do that
08:04:16 <Ariakenom> orion: like turing complete?
08:04:22 <merijn> orion: In terms of computing results I think so
08:04:24 <Solonarv> dmj`: adding it to exposed-modules should work
08:04:35 <dminuoso> orion: Well ST cant escape the internal state..
08:04:36 <merijn> orion: But definitely not when it comes to performance/computational complexity of that computation
08:05:23 <merijn> dmj`: Because hpack is opinionated by design and it's opinion doesn't agree with yours? :p
08:06:01 <Solonarv> orion: State can be expressed in terms of ST easily. ST can also be expressed in terms of State, but you'd need an auxiliary data structure because you can have multiple STRefs.
08:06:18 <Solonarv> I'll have a gist in a few minutes.
08:07:05 <merijn> Solonarv: That's basically reformulating Okasaki's proof that you can approximate the performance of any imperative algorithm with (at worst) O(log n) slowdown, by stuffing each mutable variable in a Map :p
08:07:20 <Solonarv> heh, yes :D
08:07:25 <bahamas> dminuoso: the IRC channel for purescript is not very active. but there's a slack called Functional Programming which channels for both Haskell and PureScript. that's a lot more lively
08:07:34 <dmj`> merijn: I guess that makes two of us :) 
08:08:21 <dmj`> merijn: figured it out, just had to boost source-dirs outside of a conditional block
08:08:29 <dmj`> hard to dance in a body cast
08:08:36 <merijn> dmj`: I just copy paste my template cabal file into different projects and edit as needed, because I'm too lazy to learn new shit and deal with discrepenancies between tools :p
08:09:57 <dmj`> merijn: sounds like there should be a cabal to hpack tool :)
08:09:57 <ais> marvin2, thanks, this helped me to pass the tests
08:10:05 <seishun> help, why is this giving me a stack overflow https://gist.github.com/seishun/4cc651c45e090b074834e416569a93e5
08:10:31 <orion> Solonarv: I see.
08:12:55 <dmj`> merijn: I'm with you, and I've recently regressed to new lows and now only use runghc Setup.hs to build and configure my projects. I also only use --disable-optimization which seems to speed up dev time by 200% in some cases
08:14:34 <orion> What is the general sentiment about extensible effects in contrast to Monad transformers? Are EEs ready for prime time?
08:16:35 <savolla> I immediately joined here after reading this :D https://news.ycombinator.com/item?id=7161236
08:17:20 <c_wraith> orion: They really need more language features than currently exist in order to be pleasant to use.  Not a bad idea, but still more awkward in Haskell than in purescript, for instance.
08:17:21 <dmj`> savolla: the quchen post from the irc logs is a classic
08:20:01 <savolla> dmj`: this post actually made me love haskell. I don't know anything about haskell btw :P I know C/C++ python and a bit Java
08:20:13 <dminuoso> cocreature: By the way - you remember how I've went back to light and slim monad transformers? I realized that throwing in IO to shortcircuit is *in no way* different than say MaybeT - it's also just as invisible when you fling around some generic `newtype Handler = ...`
08:20:16 <savolla> where to start :P
08:20:28 <mreh> @where lyah
08:20:28 <lambdabot> http://www.learnyouahaskell.com/
08:20:36 <mreh> savolla ^
08:20:44 <c_wraith> if you have some money to spend on it, the haskell book is probably the most comprehensive introduction.
08:20:55 <dminuoso> cocreature: That is from the type signature you don't get to see either way that some monadic action `thisThingShortCircuits :: ...` actually shortcircuits.
08:21:01 <mreh> c_wraith dons' book?
08:21:16 <c_wraith> mreh: no, that's real-world haskell
08:21:21 <c_wraith> @where book
08:21:21 <lambdabot> http://haskellbook.com/
08:21:26 <c_wraith> That's the one I mean
08:21:32 <mreh> XD  oh
08:21:51 <savolla> c_wraith: mreh thank you guys <3
08:22:06 <petercommand> it's literally called "the haskell book" :3
08:22:10 <dmj`> savolla: the typeclassopedia is still the best resource
08:22:15 <dmj`> @typeclassopedia
08:22:15 <lambdabot> Unknown command, try @list
08:22:21 <dmj`> @google typeclassopedia
08:22:22 <lambdabot> https://wiki.haskell.org/Typeclassopedia
08:22:31 <Taneb> I'm quite fond of Hutton's Programming in Haskell
08:23:47 <mreh> Taneb, is that the one where you do functional graphics?
08:23:57 <savolla> that sun with "holy shit" message is great
08:24:40 <seishun> it seems I'll have to implement my own maximumBy
08:24:58 --- mode: glguy set +v zincy
08:25:06 <mreh> :t sortBy
08:25:07 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
08:25:26 <zincy> What is the simplest way of running a bash command in haskell and printing the stdout
08:25:34 <zincy> say "ls -a"
08:26:03 <c_wraith> do you mean a *bash command* specifically, or just a process?
08:26:20 <c_wraith> because bash has a bunch of built-in things that it calls commands which aren't actually separate programs from bash
08:27:39 <Clint> zincy: "ls -a" has nothing to do with bash, but https://hackage.haskell.org/package/process-1.6.5.0/docs/System-Process.html
08:27:50 <zincy> shell?
08:27:54 <c_wraith> process
08:28:07 <Clint> you won't be using a shell at all
08:28:33 <mreh> why would you want to run ls -a in Haskell?
08:28:37 <mreh> and print the output
08:28:45 <bahamas> zincy: maybe give details about what you want to do
08:29:01 <dminuoso> What are some lightweight parser combinator options?
08:29:05 <c_wraith> mreh: just assume that's an example of a program everyone knows, not the actually target
08:29:17 <dminuoso> Ideally a library that doesn't transitively depend on kmettiverse-everything
08:29:30 <c_wraith> so not yoctoparsec?
08:29:37 <cocreature> not trifecta
08:29:44 <cocreature> megaparsec should be fine iirc
08:30:02 <lyxia> regex-applicative
08:30:13 <cocreature> the lib itself is not tiny but its dependency footprint is fairly small
08:30:45 <dminuoso> lyxia: Oh that's a neat library I hadn't considered - Im tempted now.
08:31:35 <dminuoso> It's dependencies are in my package already, I think it could work. :)
08:31:46 <NemesisD> has anyone had success with developing haskell applications with docker?
08:31:52 <dminuoso> NemesisD: Yes.
08:32:01 <mreh> NemesisD: yes
08:32:11 <mreh> try ghcid
08:33:00 <Taneb> mreh: that doesn't sound familiar
08:33:08 <Solonarv> orion: https://gist.github.com/Solonarv/fcd9a884e927686604fd8cf2f15a5499
08:33:16 <mreh> my startup script runs ghcid inside the project in development mode and runs the binary otherwise
08:33:52 <mreh> then I mount the source code as a volume, and ghcid picks up the changes to the code, rebuilds and restarts the app
08:33:54 <NemesisD> dminuoso: mreh could you folks give me a rough idea of your setup? my initial impression was to to have a dev image based on the official haskell release and to have the command be bash or a reasonable default for ghcid. my next hurdle is production: the haskell image is based on debian and would be quite heavyweight for prod but static linking is still tricky
08:34:11 <mreh> you have to run it using `ghcid -r`
08:34:18 <NemesisD> s/official haskell release/official haskell docker image/
08:34:33 <dminuoso> NemesisD: Any size issues are mitigated by multi-stage builds.
08:35:03 <dminuoso> NemesisD: Build it in your regular ghc-and-cabal-and-whatever-is-too-big-but-who-cares image, extract build artifacts and put it into a minimal image.
08:35:09 <Solonarv> I think the people making Stack have done some work on docker integration. I don't know any more than that, though.
08:35:20 <mreh> yeah, use stack, install GHC in one layer, install the deps in another
08:35:29 <mreh> then build in one after that
08:35:34 <dminuoso> NemesisD: You also dont need an official image/stack really. There's not much more than building stuff on your machine by hand.
08:36:16 <mreh> dminuoso: you extract into a minimal image?
08:36:40 <mreh> too slow to push a build image I suppose?
08:37:16 <dminuoso> mreh: Im not a fan of running 4GiB images for a binary that is just 1MiB in size.
08:37:18 <NemesisD> hmm, so what do you all use for your base for your build stage? i'm hesitant to extract the executables to a minimal image because i'd either have to figure out static linking or have my build image also use the minimal image as a base
08:37:22 <seishun> oh, it doesn't stack overflow if I compile and run it
08:37:34 <seishun> but I get a stack overflow in ghci
08:37:50 <dminuoso> NemesisD: debian? :)
08:38:10 <dminuoso> There's a minideb image Ive been meaning to try out, it should work without any issues.
08:38:11 <cocreature> seishun: ghci has a different default stack size iirc
08:38:31 <mreh> NemesisD: I build on ubuntu 18.04
08:38:37 <cocreature> using the same image as the base is probably a better option than trying to figure out static linking
08:38:45 <dminuoso> Yup.
08:38:51 <dminuoso> Or at least in the same flavour.
08:38:59 <seishun> cocreature: I think the issue here is that GHC optimized it to avoid using huge amounts of memory
08:39:03 <dminuoso> That is if your build image is based on minideb, then extract the build artifacts into a minideb too.
08:39:04 <NemesisD> that's what i do for non-docker deploys right now. have a powered off EC2 build server with the same OS as prod
08:39:41 <NemesisD> hmm ok, i'll look into minideb and using multi stage builds
08:40:23 <cocreature> seishun: thatâ€™s another option but Iâ€™m fairly sure that ghci has a more limited stack size as well
08:40:41 <cocreature> outside of ghci the default stack limit is something like 50% of available memory
08:40:56 <cocreature> so if you get a stack overflow you probably have bigger problems
08:41:06 <mreh> has anyone worked out a nice way not to have to re-download all of the dependencies every time they rebuld an image after updating them in their package.yaml?
08:41:22 <seishun> cocreature: >For the common case of lists, switching the implementations of maximumBy and minimumBy to foldl1 solves the issue, as GHC's strictness analysis can then make these functions only use O(1) stack space.
08:41:34 <dminuoso> mreh: Yes.
08:41:40 <dminuoso> mreh: Do you use gitlab-ci?
08:41:47 <mreh> dminuoso no
08:41:50 <cocreature> seishun: use foldl1' and it should wrok even without optimizations
08:41:52 <dminuoso> mreh: What CI do you use?
08:42:10 <mreh> dminuoso, none, I'm on developing at the moment
08:42:11 <seishun> cocreature: then I'll have to write my own maximumBy :(
08:42:13 <cocreature> the fact that maximumBy and minimumBy donâ€™t do this by default is stupid anyway
08:42:17 <mreh> only*
08:43:16 <cocreature> seishun: yeah itâ€™s annoying. the only good thing is that this is pretty easy to do
08:44:17 <dminuoso> mreh: So my idea is: rely on cabal new-build store doing the right thing.
08:44:30 <dminuoso> mreh: So you just need to get a store into the container into an early layer, so that new-build uses it.
08:45:57 <dminuoso> Possibly either in the form of a builder image that has some common dependencies pre-cached, or a specialized builder image for your project that has most dependencies pre-build..
08:46:07 <dminuoso> It's all weird hacks, but not too terrible.
08:46:14 * hackage eventsource-api 1.5.0 - Provides an eventsourcing high level API.  http://hackage.haskell.org/package/eventsource-api-1.5.0 (YorickLaupa)
08:46:18 <mreh> dminuoso: okay, so you just have to duplicate the dependencies somewhere
08:46:34 <mreh> seems like the only ugliness
08:46:59 <dminuoso> mreh: Maybe some fake .cabal file you build into a previous layer?
08:47:08 <dminuoso> That might be the dirtiest and quickest hack.
08:47:15 * hackage eventsource-stub-store 1.1.0, eventsource-store-specs 1.2.0, eventsource-geteventstore-store 1.2.0 (YorickLaupa)
08:47:22 <cocreature> or just cache them outside of your image and mount the store
08:47:34 <cocreature> which is how stackâ€™s docker integration works as well
08:47:36 <mreh> you can't mount in a build can you?
08:47:37 <dminuoso> Yeah that's what Im doing, since my question about gitlab-ci.
08:47:41 <dminuoso> mreh: sure you can.
08:47:57 <mreh> well that was my original idea!
08:49:54 <dminuoso> The clean way that I know of required docker 18.09 though..
08:50:10 <seishun> :t foldl1' (\x1 x2 -> max (snd x1) (snd x2))
08:50:12 <lambdabot> error:
08:50:12 <lambdabot>     â€¢ Occurs check: cannot construct the infinite type: b ~ (a, b)
08:50:12 <lambdabot>     â€¢ In the expression: max (snd x1) (snd x2)
08:50:26 <dminuoso> cocreature: Do you know what mechanism stack uses to inject the volume during build?
08:50:33 <mreh> dminuoso: Docker version 18.09.0, build 4d60db4
08:50:35 <mreh> that's handy
08:51:07 <seishun> oh right, I want to return the tuple itself
08:51:59 <dminuoso> mreh: Use buildkit with RUN --mount=type=bind then
08:52:09 <mreh> Ubuntu packages seem to have almost the bleeding edge
08:52:14 <cocreature> dminuoso: it doesnâ€™t do a build as in "docker build" afaik. it launches a container based on your image, mounts the store in that using -v and then copies the resulting executable out of that container
08:52:18 <cocreature> it predates multi-stage builds
08:53:39 <seishun> is there anything like maxOn or maxBy?
08:54:05 <Taneb> :t maximumBy
08:54:06 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
08:54:11 <Taneb> seishun: does that work for you?
08:54:26 <Taneb> (it's in Data.List and Data.Foldable)
08:54:26 <cocreature> pretty sure seishun wants to use maxBy to implement a non-shitty maximumBy
08:54:32 <seishun> ^
08:54:32 <cocreature> so it probably doesnâ€™t help :)
08:54:55 <cocreature> seishun: I donâ€™t think there is one at least not in base and itâ€™s hardly worth adding a dependency for
08:54:56 <Taneb> ah, whoops :D
08:56:48 <seishun> :t foldl1' (\(x1, y1) (x2, y2) -> if y1 > y2 then (x1, y1) else (x2, y2))
08:56:49 <lambdabot> Ord a1 => [(a2, a1)] -> (a2, a1)
08:57:27 <seishun> looks bad...
09:00:22 <rain1> :t minimumBy (comparing snd)
09:00:24 <lambdabot> (Ord a1, Foldable t) => t (a2, a1) -> (a2, a1)
09:01:06 <cocreature> :t \cmp -> foldl1' (\x y -> case cmp x y of GT -> x; _ -> y)
09:01:07 <lambdabot> (t -> t -> Ordering) -> [t] -> t
09:02:34 <seishun> at that point I might as well put the whole first parameter to foldl1' in a separate function
09:02:39 <rain1> :t foldl1' . comparing
09:02:40 <lambdabot> Ord a => (Ordering -> a) -> [Ordering] -> Ordering
09:02:53 <rain1> :t (foldl1' .) . comparing
09:02:54 <lambdabot> error:
09:02:54 <lambdabot>     â€¢ Couldn't match type â€˜Orderingâ€™ with â€˜a -> aâ€™
09:02:54 <lambdabot>       Expected type: (a -> a1) -> a -> a -> a -> a
09:03:24 <seishun> well I'm not getting a stack overflow anymore which is nice
09:07:27 <gabe4k> Has anyone had long compile times for parsers generated by happy? I generated a working parser, but ghc's typechecker takes ages to process it. Are there any common mistakes I could have made that would drastically explode the complexity of the types generated by happy?
09:10:00 <gabe4k> Haha NVM I think I figured it out
09:10:00 <gabe4k> https://www.haskell.org/happy/doc/html/sec-type-signatures.html
09:10:38 <gabe4k> For more advanced grammars, happy needs type annotations to generate more efficient grammars
09:11:09 <gabe4k> s\grammars\parser
09:35:08 <dminuoso> lyxia: Heh. Turns out some problems are best solved by changing the problem. Instead of parsing some csv-style of file with a simple optparse-applicative, I realized my life gets easier if I just store data using S-expressions.
09:35:36 <dminuoso> % p = fix $ \l -> (many (mfilter isSpace token) *> ((Pure <$> some (mfilter isAlphaNum token)) <|> (Free <$> (mfilter (== '(') token *> many l <* mfilter (== ')') token))) <* many (mfilter isSpace token))
09:35:36 <yahb> dminuoso: ; <interactive>:462:52: error:; * Data constructor not in scope: Pure :: [Char] -> a; * Perhaps you meant variable `pure' (imported from Prelude); <interactive>:462:99: error: Data constructor not in scope: Free :: [a] -> a
09:36:39 <dminuoso> % import Control.Applicative.Free
09:36:39 <yahb> dminuoso: 
09:36:42 <dminuoso> % p = fix $ \l -> (many (mfilter isSpace token) *> ((Pure <$> some (mfilter isAlphaNum token)) <|> (Free <$> (mfilter (== '(') token *> many l <* mfilter (== ')') token))) <* many (mfilter isSpace token))
09:36:42 <yahb> dminuoso: ; <interactive>:464:99: error: Data constructor not in scope: Free :: [Control.Applicative.Free.Ap f [Char]] -> Control.Applicative.Free.Ap f [Char]
09:56:48 <bsima> i've got a lot of json parsing with variable content and I want to test that the parsing is correct - is there a library or technique for this?
09:57:24 <Bish> you mean the json has a specific structure?
09:57:48 <bsima> yeah, sometimes fields are missing, so my aeson decodeer has a lot of 'Maybe's
09:58:49 <bsima> but i have a small corpus of example json files downloaded i can use in my tests
10:00:20 <bsima> this is kinda like golden tests
10:01:26 <bsima> hm, maybe i could do a golden test, decode and then re-encode, and compare with the original file to make sure the parsing is correct
10:01:36 * bsima is done thinking out loud, thanks
10:01:50 --- mode: glguy set +v one_haskell_boi
10:12:02 --- mode: glguy set +v bilg
10:23:35 <comerijn> bsima: Another solution is to have quickcheck generate random values of your type. Encode as JSON and then decode and check you get the right result
10:26:33 <fresheyeball> anyone know how to get cabal to create this file? `~/.cabal/store/ghc-8.0.2/package.db` ?
10:27:24 <glguy> That should be fixed in the current release of cabal-install
10:27:51 <fresheyeball> glguy: I am on 2.4.0.0
10:28:21 <glguy> Have you tried upgrading to the current version?
10:28:31 <bsima> comerijn: mm, nice idea, thanks
10:28:31 <bsima>  
10:28:52 <glguy> fresheyeball: There was a basically no-op build command I used on old versions to fix that file missing that I'm looking for
10:30:06 <glguy> It was: cabal new-repl -w ghc-8.0.2 --build-dep fail
10:30:12 <glguy> https://github.com/haskell/cabal/issues/5516
10:30:19 <glguy> but it's fixed in 2.4.1.0
10:30:28 <fresheyeball> trying
10:30:46 <glguy> There are other fixes there, too, so its worth updating even if that command helps
10:31:08 <glguy> https://www.haskell.org/cabal/download.html
10:54:48 <fresheyeball> glguy: ok so I have latest cabal-install
10:54:52 <fresheyeball> what was your incantation?
10:54:56 <fresheyeball> cabal update did not do it
10:55:23 <glguy> cabal new-repl -w ghc-8.0.2 --build-dep fail
10:55:32 <glguy> What does cabal --version say?
10:55:55 <fresheyeball> 2.4.1.0
10:57:14 * hackage recursion 2.0.0.0 - A recursion schemes library for GHC.  http://hackage.haskell.org/package/recursion-2.0.0.0 (vmchale)
11:00:09 <fresheyeball> glguy: is there a way to do it with repl? 
11:00:21 <glguy> repl doesn't use the store
11:00:44 * hackage language-ats 1.7.0.5 - Parser and pretty-printer for ATS.  http://hackage.haskell.org/package/language-ats-1.7.0.5 (vmchale)
11:00:52 <glguy> (so I wouldn't think there would be)
11:01:55 <fresheyeball> ugh
11:14:26 <aplainzetakind> What's a reasonable run time for today's AoC part 2? I can't tell if I'm being stupid or if the problem is intrinsically expensive.
11:15:07 <glguy> Mine runs in about half a second
11:15:29 <aplainzetakind> Well I have 80 seconds here, so.
11:16:02 <aplainzetakind> I'll take a look at yours then.
11:17:21 <sm> ha.. 20 minutes
11:17:53 <sm> simple exhaustive search using Vectors
11:18:27 <sm> glguy: I glanced at yours, will read again
11:19:12 <glguy> My original one used a less efficient dynamic programming approach and took a few seconds
11:19:24 <glguy> the current one on my github uses a better approach
11:19:50 <sm> how much time did you spend today ?
11:19:54 <amalloy> i was trying to figure out a proper dynamic programming solution but gave up on rectangles and only memoized squares, subtracting out the fringes manually
11:20:27 <glguy> sm: On cleaning it up or when submitting?
11:20:50 <sm> glguy: I'd be interested in both 
11:21:28 <glguy> I got part 2 done in 34 minutes. There were a few other #haskellers ahead of that. Probably gave it an hour of cleanup/fussing
11:21:57 <sm> today was relatively quick for me, 1h and 1.5h respectively
11:23:32 <sm> oh, you've pushed changes
11:23:44 <aplainzetakind> glguy: I think my algorithm is roughly the same (I'm not too familiar with arrays and their associated notation but still.) Would using arrays instead of lists have a ~160-fold effect?
11:25:04 <c_wraith> for today's part 2? yes.
11:25:11 <cjay-> is there a iterateUntil or iterateWhile somewhere? no luck with hoogle
11:25:17 <monochrom> I suspect if you use random access heavily, array will be much faster than list. If the list is looonnnggg.
11:25:46 <c_wraith> cjay-, no need, thanks to laziness. just use takeWhile with iterate
11:26:00 <monochrom> cjay-: I think no. Could you combine iterate and takeWhile?
11:26:20 <lavalike> mine takes 7-8 minutes, haven't had a lot of time to devote to this one
11:26:21 <monochrom> and also head if you're just looking for one thing.
11:26:30 <cjay-> I used iterate with dropWhile and head, I'm only interested in the last result
11:26:33 <monochrom> err, last.
11:26:53 <cjay-> but I learned that I have to feel bad for using head
11:26:56 <glguy> :t until
11:26:58 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
11:27:06 <cjay-> glguy: yay thanks
11:27:11 <monochrom> No, screw all rules of thumbs and hearsays.
11:27:25 <glguy> > until (> 100) (2*) 1
11:27:28 <lambdabot>  128
11:27:51 <Solonarv> the rule about head is "don't use it unless you know its argument won't be empty". iterate produces an infinite list, which is never empty.
11:28:04 <Solonarv> (if you want to talk in terms of rules)
11:28:08 <monochrom> The reason to prefer pattern matching is at my http://www.vex.net/~trebla/haskell/crossroad.xhtml .  And the reason doesn't always apply.  When the reason doesn't apply, do what's right, not what's popular.
11:28:31 <cjay-> ok :)
11:29:53 <aplainzetakind> This is my solution: https://github.com/aplainzetakind/AoC2018/blob/master/src/day11/Day11.hs and profiling tells me cellValue consumes 60% of the run time. Which is weird.
11:29:55 * sm wonders what's going on at summedAreaTable https://github.com/glguy/advent2018/blob/master/execs/Day11.hs#L93 (AoC spoiler)
11:30:08 <monochrom> Be a rational, critical, independent, anti-herd, non-conformant, too-good-for-"best practice" thinker.
11:30:20 <glguy> sm: The topic is covered in the wikipedia article at the top if you just want to understand the algorithm
11:30:31 <sm> aha!
11:30:33 <glguy> If you have a question about the Haskell itself I can focus on that though
11:30:58 <amalloy> sm: or read the function and try to puzzle out what it's doing yourself. i just finished that; it was a fun exercise
11:31:10 <sm> nicely documented and everything 
11:33:18 --- mode: glguy set +v Firedancer
11:35:44 <sm> that's great. Learning useful stuff, clearly I should keep doing AoC.
11:40:11 <glguy> sm: I'm open to feedback if some aspect of a solution needs more explanation or could benefit from being refactored. My goal is for the stuff in that repo to be a good example
11:42:07 <sm> glguy: it's very good. If summedAreaTable had a haddock, it probably would have set me straight. I missed the note up top (added since I first read)
11:42:25 <sm> no doctests today ? Guess you didn't need em
11:45:17 <glguy> good point
11:46:01 <glguy> I was too focused on cleaning up the algorithm :)
11:46:19 --- mode: glguy set +v kutta
11:47:38 <aplainzetakind> What's the go-to source to understand what boxed/unboxed data mean and what the consequences are?
11:48:43 <[exa]> aplainzetakind: do you know C or C++?
11:49:11 <aplainzetakind> No unfortunately.
11:49:28 <[exa]> aplainzetakind: any other programming language with pointers or at least tangible references?
11:50:36 <aplainzetakind> I don't know anything else\ except at a superficial level (I mean I read Kernighan and Richie up to pointers).
11:50:53 <[exa]> that should be sufficient :]
11:51:16 <aplainzetakind> Not including though.
11:51:20 <[exa]> unboxed data are "plain old data" -- if you have an unboxed Int somewhere, you can expect that there will be 8 bytes of memory with the integer value
11:52:12 <aplainzetakind> And boxed is references being passed around?
11:52:19 <[exa]> boxed data are "behind an indirection" -- instead of integer there's some kind of wrap (usually a pointer to some structure) which describes that the data is not yet there (not evaluated yet)
11:52:56 <[exa]> the point with boxed data is that you can use the wrap safely without any danger until you really need what's inside
11:53:07 <aplainzetakind> Boxed ~ strict, unboxed ~ lazy?
11:53:13 <[exa]> the other way
11:53:20 <aplainzetakind> Sorry, yes.
11:53:29 <[exa]> boxed = can be lazy, unboxed basically must be strict
11:54:03 <[exa]> btw this description is extremely approximate but hopefully it gives you the idea :]
11:54:19 <aplainzetakind> It does. Thanks.
11:54:30 <[exa]> the information about "not evaluated yet" is usually called thunk btw, if you would hear the term
11:54:47 <aplainzetakind> I'm familiar with that one.
11:55:11 <[exa]> and the main problem is that with boxed data you don't know whether it's going to create a bottom (i.e. undefined, endless loop, exception or some other problem)
11:55:51 <glguy> sm: I fixed a laziness oversight I don't understand yet and my solution went from 0.5 to 0.17s \o/
11:56:00 <ski> @quote therefore.I.am
11:56:00 <lambdabot> gnuvince says: I thunk, therefore I am not (yet)
11:56:04 <lavalike> :o
11:56:12 <aplainzetakind> Is the memory reserved with boxed data at least, without it being written to? Or is it completely a symbol of a future value.
11:56:35 <aplainzetakind> Silly question.
11:56:47 <aplainzetakind> It can't be reserved in general I think, right.
11:56:49 <[exa]> aplainzetakind: the description of the thunk sometimes takes more memory than the actual result :]
11:56:52 <amalloy> aplainzetakind: you wouldn't even know how much memory to allocate for it, typically
11:57:00 <aplainzetakind> How much memory would you need for a future Integer.
11:57:03 <[exa]> aplainzetakind: but in general it's impossible to guess
11:57:03 <aplainzetakind> amalloy: yes.
11:57:21 <[exa]> yes, it's simple for simple types :]
11:57:21 <ski> (or `Array Int Double')
11:57:33 <aplainzetakind> Thanks.
11:58:33 <sm> glguy: nice! I would be interested in that commit
11:58:44 * hackage discord-haskell 0.7.0 - Write bots for Discord in Haskell  http://hackage.haskell.org/package/discord-haskell-0.7.0 (Aquarial)
11:58:55 <[exa]> aplainzetakind: one more interesting thing - the boxed thunk is converted to boxed value in-place by rewriting when it's evaluated; so all places in the program where the thunk is copied can share result of a single thunk evaluation
12:00:26 <aplainzetakind> [exa]: The way I understand that sentence is that foldr would use pretty much constant memory, but I know that's not the case, so I don't understand you.
12:00:55 <aplainzetakind> Can you give an example?
12:02:35 <jle`> foldr has the potential to be constant-memory
12:02:46 <jle`> foldr is interesting because it's all up to the function you give
12:03:14 * hackage eigen 3.3.7.0 - Eigen C++ library (linear algebra: matrices, sparse matrices, vectors, numerical solvers).  http://hackage.haskell.org/package/eigen-3.3.7.0 (chessai)
12:03:51 <aplainzetakind> foldr (+) 0
12:04:20 <lavalike> @src sum
12:04:20 <lambdabot> sum = foldl (+) 0
12:05:35 <nisstyre> lavalike: foldl1 (+), I like to live dangerously
12:06:10 <nisstyre> empty sums are for wusses
12:06:37 <Ariakenom> nisstyre: the true high level language SQL agrees
12:06:49 <nisstyre> haha
12:07:13 <nisstyre> I didn't know the SQL sum doesn't take an empty list of terms or w/e
12:07:38 <Ariakenom> it's null in sql
12:07:54 <nisstyre> ah ok, that's actually worse
12:08:02 <nisstyre> then you won't get an exception
12:08:50 <Ariakenom> indeed
12:10:32 <[exa]> aplainzetakind: very approximate: you take value = someVeryHardComputation
12:10:40 <[exa]> then send value to 2 different places in program
12:11:06 <[exa]> and it gets evaluated only once, the second part gets the result for free
12:15:29 <nisstyre> that surely depends on an optimization though [exa] 
12:16:12 <nisstyre> does GHC use any kind of CPS transform on the code?
12:28:58 <dmwit> doesn't depend on optimization. works even in ghci
12:29:15 <dmwit> % :set +s
12:29:16 <yahb> dmwit: 
12:29:29 <dmwit> % let veryHard = last [1..100000] in veryHard
12:29:29 <yahb> dmwit: 100000; (0.03 secs, 7,354,160 bytes)
12:29:34 <dmwit> % let veryHard = last [1..1000000] in veryHard
12:29:34 <yahb> dmwit: 1000000; (0.05 secs, 72,154,896 bytes)
12:29:54 <dmwit> % let veryHard = last [1..1000000] in (veryHard, veryHard)
12:29:54 <yahb> dmwit: (1000000,1000000); (0.07 secs, 144,162,800 bytes)
12:30:12 <dmwit> Ah, well, I may have screwed myself with polymorphism, there.
12:30:30 <dmwit> % let veryHard = last [1..1000000] :: Int in veryHard
12:30:30 <yahb> dmwit: 1000000; (0.04 secs, 80,154,768 bytes)
12:30:36 <dmwit> % let veryHard = last [1..1000000] :: Int in (veryHard, veryHard)
12:30:36 <yahb> dmwit: (1000000,1000000); (0.04 secs, 80,162,360 bytes)
12:30:53 <dmwit> Does not take twice as long to give the answer twice, nor twice the memory.
12:35:44 * hackage git-annex 7.20181211 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-7.20181211 (JoeyHess)
12:36:50 <[exa]> nisstyre: there's some kind of guarantee of memoization -- if you enter let-binding once, the thunks from that are only going to get evaluated once
12:37:02 <[exa]> nisstyre: btw CPS is also there, yes
12:38:11 <dmwit> (In certain vanishingly rare cases a thunk may be evaluated multiple times, when multiple threads race to evaluate it. But blackholing makes that very, very rare.)
12:38:45 <[exa]> dmwit: btw thanks for the perfect show of monomorphism restriction :]
12:38:53 <dmwit> yes =P
12:43:04 <cjay-> does anyone know under what conditions this "safe destructive update" works without copying? https://hackage.haskell.org/package/vector-0.12.0.2/docs/Data-Vector.html#g:18
12:43:20 <cjay-> "The operation will be performed in place if it is safe to do so and will modify a copy of the vector otherwise."
12:45:08 <lyxia> you might want to open an issue to have it documented
12:45:59 <[exa]> source looks like it always uses 'clone' though
12:46:12 <Tuplanolla> Perhaps there are `RULES` somewhere to get rid of the `clone`.
12:46:36 <[exa]> well hidden then.
13:05:21 <NemesisD> dminuoso: following up on the docker thing, do you mount your source dir into the container for building haskell projects? if so, how do you get around file ownership issues? stack via ghcid seems to abort when it sees the working dir is owned by someone else
13:11:04 <koz_> jle`: Any chance you could ping Joe in some way or another to release on Hackage? It's been a week.
13:20:00 <ondrejs> hi. What's an easy way to run an `IO ()` function atomically? I could do it with a few lines of MVar code or perhaps STM but maybe there's some function in base or standard libraries that does preciselly this.
13:20:32 <ondrejs> *precisely
13:21:23 <c_wraith> you can't, by the traditional definition of atomicity
13:22:04 <c_wraith> the network connection might drop between two update calls you're making.
13:22:27 <c_wraith> or any other failure that comes from interfacing with the real world.
13:23:14 * hackage proteome 0.3.5.0 - neovim project manager  http://hackage.haskell.org/package/proteome-0.3.5.0 (tek)
13:23:15 <c_wraith> there might be better answers possible, though, if you have a more specific set of requirements
13:25:35 <ondrejs> I actually don't need atomicity, I need serialized actions
13:27:16 <[exa]> ondrejs: atomicity is a slightly different requirement as sequentiality. Can't you pass a token in the mvar or something?
13:27:35 <ondrejs> so something like `bracket acquireLock releaseLock print`
13:27:45 <ondrejs> [exa]: true, my mistake.
13:28:12 <ondrejs> I can do that, I am just wondering whether there is a standard function doing this
13:28:35 <ondrejs> no might be the answer :-)
13:28:36 <[exa]> MVars work a bit like mutexes with the take/put waiting semantics
13:28:43 <[exa]> lemme check
13:29:18 <[exa]> I'm not sure there'd be a command for completely stopping the rest of IO threads
13:32:23 <ondrejs> It makes sense this is actually not easy in an immutable setting.
13:33:32 <ondrejs> All right, I'll go for MVars. Thank you.
13:33:35 <[exa]> QSem might be handy for a bit more flexible locking 
13:34:00 <[exa]> they even have a similar bracket as you suggested in the manual
13:34:49 <ondrejs> I see, nice, thanks!
13:38:46 <koz_> [exa]: I was _just about_ to report that hindent bug.
13:38:49 <koz_> Thanks for beating me to it.
13:39:21 <koz_> (although hindent seems a bit dead lately)
13:40:35 <Zemyla> Why is tail even partial?
13:40:53 <Zemyla> Why can't tail just be defined as tail (_:as) = as; tail [] = []
13:41:43 <ski> that's `drop 1'
13:41:56 <rain1> it could be harder to find an mistake in a program if tail [] = []
13:43:31 <ski> "returning a nonsensical result" isn't necessarily better than aborting
13:43:50 <ski> (of course, what's deemed nonsensical depends on the circumstances)
13:44:37 <ski> (hmm .. one might perhaps want `forall xs0,x,xs. head xs0 = x /\ tail xs0 = xs => xs0 = x:xs' ?)
13:45:27 <dmwit> ondrejs: I would do something like `main = do chan <- newChan; forkIO (forever (join (readChan chan))); {- do whatever to send actions to the chan -}`.
13:45:50 <ski> (or even `forall xs0,xs. tail xs0 = xs => xs0 = head xs0:xs')
13:45:51 <dmwit> ondrejs: Maybe throw something in there to catch exceptions inside the `forever`. ;-)
13:46:41 <dmwit> Yes, I expect `head xs : tail xs = xs` when both sides are defined.
13:47:08 <jle`> koz_: i don't have any more connection to him than you do :) i just submit pr's on github too
13:47:36 <infinisil> Hey, some time ago I saw some blog posts or so that talked about structuring your entire application as a set of actions. Then you can choose to automatically log all of these actions, without explicitly writing prints all over the place. Anybody know what I'm talking about?
13:47:57 <infinisil> Maybe something to do with free monads
13:48:22 <geekosaur> maybe everything to do with?
13:48:34 <boj> yeah, i want to see free monads was related
13:49:06 <koz_> jle`: Oh well, figured I'd check with you anyways.
13:49:35 <koz_> infinisil: This _definitely_ sounds like a free monad/extensible effects type shindig.
13:50:50 <infinisil> AHh, might be http://degoes.net/articles/modern-fp
13:50:58 <infinisil> Found from https://stackoverflow.com/questions/40105759/logging-using-the-free-monad
13:51:26 <dmwit> (On the other hand, `take 1 xs ++ drop 1 xs = xs` is a pretty nice property, too, especially since it doesn't need the "when both sides are defined" caveat.)
13:52:22 <infinisil> And this also leads to https://hackage.haskell.org/package/extensible-effects
13:52:28 <infinisil> Which I've heard about too
13:55:28 <MarcelineVQ> infinisil: it's not what you're talking about but http://hackage.haskell.org/package/co-log is p. coopl
13:55:49 <infinisil> "co-log: Composable Contravariant Combinatorial Comonadic Configurable Convenient Logging" LOL
13:56:16 <MarcelineVQ> It's extensible effects or Has idioms or anything, just neat logging
13:56:40 <MarcelineVQ> *It's not extensible
13:56:48 <MarcelineVQ> naptime ;>
13:59:04 <ondrejs> dmwit: Also looks good, thanks!
14:11:14 <sshine> infinisil, heh.
14:11:23 <sshine> infinisil, but what's the "co-" *stand* for? ;)
14:13:51 <geekosaur> "cool" :p
14:14:44 <ski> @quote into.ffee
14:14:44 <lambdabot> #haskell says: < Fuuzetsu> why does this channel always eventually end up at co-jokes? < Iceland_jack> Fuuzetsu: What do category theorists drink on a cold winter night? < mm_freak> Fuuzetsu:
14:14:44 <lambdabot> because we turn cotheorems into ffee < Iceland_jack>     A: Hot a. < hpc> Fuuzetsu: it's the logical course of co-nversation < bennofs> because we all love CO-mputer science :) < Fuuzetsu> I
14:14:44 <lambdabot> immediately regret my decision to say anything.
14:15:27 <monochrom> That co-log package --- someone was really looking up their dictionary for co- words.
14:23:46 --- mode: glguy set +v w1n5t0n
14:25:41 <w1n5t0n> does Data.Array need to be included in a project's .cabal file for stack to be able to find it?
14:27:01 <glguy> array needs to be included in your project's .cabal file in the build-depends section in order to use the Data.Array module
14:27:29 <glguy> e.g. https://github.com/ekmett/lens/blob/master/lens.cabal#L196
14:28:19 <trcc> CDouble -> Double = fromRational . toRational?
14:28:43 <glguy> readToFrac
14:28:47 <glguy> :t realToFrac
14:28:49 <lambdabot> (Fractional b, Real a) => a -> b
14:29:15 <trcc> thank you glguy
14:31:00 <trcc> so it works because cdouble has an instance of a and double has an instance of fractional
14:31:01 <trcc> thanks
14:31:18 <nisstyre> [exa]: I see, so thunks are de-duplicated, I didn't know that was an actual guarantee, I thought it was just something GHC does
14:36:34 <sshine> is there a 'getContents' for Data.Text?
14:36:45 <glguy> Look in Data.Text.IO
14:36:58 <sshine> ah, thanks.
14:37:24 <glguy> When you're on the haddocks for a package, try pressing 's' to bring up the quick search box
14:37:49 <sshine> glguy, what! cool.
14:41:20 <avidela> Anyone could help with dependent types in haskell?
14:41:59 <jle`> avidela: don't ask to ask, just ask :)
14:42:47 <avidela> jle` I tried asking directly but apparenly dependent types aren't really popular :p
14:43:32 <jle`> avidela: if asking directly didn't help, why do you think asking to ask would help? :p
14:43:45 <jle`> i mean, ask your question that you want to ask directly
14:44:00 <jle`> this is preferable in every way.
14:44:23 <avidela> I have a data which I would like to use in order to select between multiple (indexed) typeclasses I've tried using DataKinds to index those typeclasses and I would like to use the data value in order to select the correct instance of the typeclass
14:44:29 <jle`> consider if someone were willing to say "yes, i am willing to help.".  in that case, they would *still* answer if you just asked the question right away
14:44:37 <avidela> I've made a gist illustating the problem here https://gist.github.com/andrevidela/b51d2671959be185e4bb6fe2c7ce6788
14:44:38 <jle`> so, asking the question right away has no negative effect
14:44:52 <jle`> now also, consider if someone were willing to help with a specific question, but not willing to commit to help in general for all possible questions
14:45:12 <jle`> this person would not answer "can anyone help?", but they *would* answer a direct question in chat
14:45:38 <jle`> so, asking the question directly in chat is always at least as effective as asking to ask, and usually is even more effective
14:46:04 <jle`> because you gain (1) the same audience as if you asked to ask, *plus* (2) the audience of people who would answer, but not commit to answering in advance
14:46:11 <avidela> I've also been reading though Hasochism and different resources about how to encode dependent types but I haven't found any success in implementing their idea though they've allowed great progress (specifically singleton types and GADTS)
14:47:02 <avidela> Finally, I've found nothing about indexed typeclasses and dependent types so if anyone has any resource about it, it would be welcome
14:48:43 <jle`> avidela: the issue in your gist is mainly that the *type* ValueKind is unrelated, in ghc, to the *kind* ValueKind
14:48:53 <jle`> so if you say firstValue = First, firstValue is a value of type ValueKind
14:49:10 <jle`> but, your typeclass has instances of kind ValueKind
14:49:23 <jle`> it's misleading because they have the same identifiers, but to ghc, they are completely unrelated, unfortunately
14:50:01 <jle`> libraries like 'singletons' get around this making a typeclass for every type-kind pair
14:50:07 <jle`> er, a type family
14:50:57 <avidela> jle` that's not the problem actually the problem is that `makeAndPrint` can't be discriminated for a single instance given a runtime value
14:50:59 <jle`> so, in this case, to GHC, the usage of the type 'First on line 17 is unrelated to the usage of the value First on line 32, to GHC they might as well be called Forst and Farst
14:51:47 <jle`> avidela: it can, but you need to reify the runtime value to move it to the type level
14:51:55 <avidela> andâ€¦how?
14:52:44 <jle`> there are a couple of ways to do this; the simplest way might be to use the singletons ecosystem, since it integrates a lot of these tools together in a nice way
14:53:39 <avidela> jle` I've already tried using Singleton types (though not the singleton libraries) wihtout success
14:53:41 <jle`> you can take a value of type ValueKind and turn it into a type (at runtime) of kind ValueKind by using one of the reifiers; there's toSing and withSomeSing, and the Sing pattern synonym
14:54:00 <avidela> jle` maybe you have a link to some resource somewhere that explains it in details?
14:54:13 <jle`> avidela: right, the singleton library offers tools that ties the singleton pattern to the value level, etc.
14:54:47 <jle`> avidela: i have an intro to singletons tutorial here, in case it might help https://blog.jle.im/entries/series/+introduction-to-singletons.html
14:55:36 <avidela> jle` Thank you, I'll read through it
14:57:45 <jle`> avidela: i've left a comment on your gist with a simple way to do what you mentioned, although restructuring the typeclass would make things a little cleaner
14:57:59 <jle`> i used two types of reification that the singletons library offers so you can compare :)
14:58:46 <avidela> excellent thank you very much :)
14:58:52 <avidela> this definitely helps a lot
14:59:48 <jle`> (added a third one)
15:01:17 <aplainzetakind> Stack has this issue and it always frustrates me when trying to build projects using recent stackage snapshots: https://github.com/commercialhaskell/stack/issues/4319
15:01:45 * hackage appar 0.1.7 - A simple applicative parser  http://hackage.haskell.org/package/appar-0.1.7 (KazuYamamoto)
15:15:25 <davean> "Cabal should be able to generate a working stack.yaml by adding the packages that are not in the resolver as extra-deps." but ... stack uses cabal, not the other way around
15:15:33 <davean> cabal knows nothing, and has nothing to do with, stack
15:16:32 <monochrom> Who wrote that?
15:16:54 <sclv> Its just a poorly written bug report
15:17:03 <monochrom> I guess there is also the ambiguity of "should".
15:17:29 <monochrom> i.e., what is right vs what is my preference
15:17:35 <davean> monochrom: I don't even thing adding "should" in saves it or even starts
15:18:03 <aplainzetakind> What is meant is probably "stack should be able to use cabal output to..."
15:18:23 <davean> aplainzetakind: that would make some sense.
15:18:32 <davean> It doesn't at all say that though.
15:19:07 <monochrom> Now it depends on whether that sentence is posted to stack wishlist or cabal wishlist.
15:19:19 <aplainzetakind> It's a stack issue.
15:19:21 <davean> monochrom: stack - see the bug report refered to above
15:19:28 <monochrom> Ah OK.
15:19:45 <aplainzetakind> It literally says "unable to parse cabal-install output"
15:20:06 <aplainzetakind> And crashes.
15:20:14 <davean> I'm backing away from this brain damage.
15:20:28 <sclv> Its frustrating that this has been a bug fir over a year iirc
15:20:44 * hackage DPutils 0.0.2.0 - utilities for DP  http://hackage.haskell.org/package/DPutils-0.0.2.0 (ChristianHoener)
15:20:44 <monochrom> The way it's bizarrely worded, I can't help but imagine someone going to the Chinese government and say "the US government should not start this trade war".  :)
15:21:00 <davean> monochrom: lol
15:21:21 <davean> monochrom: you need a level of not-quite-right indirection before that too though
15:21:34 <davean> monochrom: like the availability of flights to HI
15:24:30 <monochrom> Aw, there is still no Haskell Platform corresponding to GHC 8.6
15:26:14 * hackage ForestStructures 0.0.1.0 - Tree- and forest structures  http://hackage.haskell.org/package/ForestStructures-0.0.1.0 (ChristianHoener)
15:31:44 * hackage PrimitiveArray 0.9.0.0 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.9.0.0 (ChristianHoener)
15:40:44 * hackage SciBaseTypes 0.0.0.1 - Base types and classes for statistics, sciences and humanities  http://hackage.haskell.org/package/SciBaseTypes-0.0.0.1 (ChristianHoener)
15:50:51 * hackage BiobaseTypes 0.1.4.0 - Collection of types for bioinformatics  http://hackage.haskell.org/package/BiobaseTypes-0.1.4.0 (ChristianHoener)
16:17:40 <abhir00p[m]> Hi I am trying to call some vector C functions using FFI, and I get the following error on the code
16:17:42 <abhir00p[m]> https://pastecloud.net/jfHxtxEr3j
16:18:04 <abhir00p[m]> This is GHC version 8.6.1 with LLVM 6.0
16:19:11 <abhir00p[m]> I am not too familiar with the Haskell FFI mechanism, is there something missing from my code? the linker seems to fail
16:22:44 <lyxia> how did you tell the linker where to find the implementation of _mm_add_epi16
16:24:44 * hackage test-lib 0.1.0.0 - A library to make a quick test-runner script.  http://hackage.haskell.org/package/test-lib-0.1.0.0 (IavorDiatchki)
16:26:34 <abhir00p[m]> lyxia: I did not. I am not familiar with the FFIing mechanism. This is all the code that I wrote. So how do I specify the location from where the linker can pick up the implementation?
16:27:43 <monochrom> Did you know that for most C libraries you have to add something like -lfoo (say the C library I want is libfoo.so.*)?
16:28:30 <abhir00p[m]> No I was not aware of that.
16:28:41 <monochrom> This is true overall all of unix.  If you write a C program that uses a C library you already have to do that.
16:29:52 <abhir00p[m]> So this is not some external c library. These are the vector intrinsics which generally ship with both gcc and clang
16:30:11 <abhir00p[m]> Do I still need to specify some additional flags?
16:31:13 <monochrom> What is the exact nature of _mm_add_epi16?  Is it really a callable function?  Is it a C macro?  Is it a reserved word?
16:31:34 <monochrom> Because basically Haskell FFI is only going to do callable functions.
16:32:04 <hpc> epi smells a bit like a register name
16:32:15 <hpc> now that i think about it
16:32:17 <shachaf> _mm_add_epi16 is an intrinsic, not a function
16:32:33 <shachaf> You're not going to be able to FFI it and you probably don't want to anyway.
16:32:33 <monochrom> There is mitigation for C macros if you use GHC, but you have to turn on an extension, and the actual mechanism is GHC generates a callable function that contains the C macro.
16:33:19 <abhir00p[m]> monochrom: https://github.com/llvm-mirror/clang/blob/master/lib/Headers/emmintrin.h#L2150-L2153
16:33:49 <monochrom> And yeah FFI has overhead, FFI-ing a single-instruction thing is like I book an airplane flight to 12 time zones away just for McDonald's fries.
16:34:23 <abhir00p[m]> Yeah I am aware of the overheads.
16:34:57 <abhir00p[m]> Actually I was working on porting vector instruction support natively in GHC
16:35:20 <c_wraith> that sounds like it might be a better fit for primops
16:35:25 <abhir00p[m]> But currently to test some application I want to experiment with the FFI part
16:35:58 <Solonarv_> I vaguely recall a similar project
16:36:09 <Solonarv_> Perhaps I'm thinking of Data Parallel Haskell?
16:37:29 <abhir00p[m]> DPH eventually got abondoned. It was a more grand attempt to bring nested data parallelism to GHC. And it was not limited to SIMD instructions, also  implicit multicore parallelism as well
17:16:36 <aplainzetakind> Aren't type constructors curried much the same way as functions?
17:16:55 <Solonarv_> Correct. Why do you ask?
17:17:07 <Axman6> I'm not sure that's correct
17:17:23 <Axman6> type aliases aren't
17:17:48 <Solonarv_> (and neither are type families, fair enough)
17:17:51 <aplainzetakind> I want to newtype this: data ParsecT e s m a
17:18:15 <aplainzetakind> this fails: newtype ParserStateMap a = ParsecT Void T.Text (St.State (M.Map T.Text Int)) a
17:18:44 <c_wraith> you didn't provide a constructor name..
17:19:39 <aplainzetakind> Sorry my bad.
17:19:52 <aplainzetakind> I should type and not newtype
17:19:59 <aplainzetakind> Right.
17:29:44 * hackage language-ocaml 0.2.0 - Language tools for manipulating OCaml programs in Haskell  http://hackage.haskell.org/package/language-ocaml-0.2.0 (Ptival)
17:32:44 * hackage hinterface 0.8.0 - Haskell / Erlang interoperability library  http://hackage.haskell.org/package/hinterface-0.8.0 (SvenHeyll)
17:49:44 * hackage cuckoo-filter 0.2.0.2 - Pure and impure Cuckoo Filter  http://hackage.haskell.org/package/cuckoo-filter-0.2.0.2 (ChrisCoffey)
18:09:09 <coldpress> how do I break into debug mode on exception?
18:10:30 <infinisil> Nobody told me there was a debugging mode!
18:10:35 <dmj`> why don't we make Show for String `instance {-# overlaps #-} Show String where show = id`
18:11:08 <dmj`> then functions like `toText :: Show a => a -> Text` wouldn't be scary to use on `String`
18:12:33 <geekosaur> dmj`, because Show and Read are expected to produce Haskell source suitable for debugging and in particular for copy-paste into an editor or ghci.
18:13:51 <infinisil> dmj`: And Read/Show should be duals
18:14:00 <geekosaur> and if you do it only to the Show, show . read won't be id (and read will have problems as soon as a String is a subpat of an expression
18:14:08 <geekosaur> supart
18:14:11 <geekosaur> ergh
18:14:14 <geekosaur> subpart
18:14:23 <infinisil> > show "True"
18:14:26 <lambdabot>  "\"True\""
18:15:38 <dmj`> can we overlap the Read instance on String as well to keep them dual
18:16:30 <lyxia> show :: Show a => [a] -> String would also no longer typecheck
18:18:19 <dmj`> lyxia: it typechecks for me
18:18:51 <dmj`> with an overridden show
18:20:05 <infinisil> dmj`: Changing how Read parses values? I doubt that's gonna be wanted :)
18:20:14 <infinisil> Would break many things
18:20:30 <infinisil> And equivalently for Show probably
18:21:00 <lyxia> dmj`: https://gist.github.com/Lysxia/adf2ce85a36f27c5114848661f70f822 this typechecks for you?
18:21:54 <geekosaur> I alreadycomemtned ont hat probem but apparently it was ignored as irrelevant.
18:24:10 <coldpress> infinisil: iirc debug mode should be activated by default, but you need to set a breakpoint to trigger it
18:24:25 <dmwit> dmj`: Also: currently the Show instances that ship with GHC are 7-bit safe. Your proposal would end that. I think this is a bigger deal than the other ones, because the two most popular encodings agree on how to encode all 7-bit safe characters.
18:24:35 <coldpress> i'm wondering how to trigger it on exception, so that I don't have to figure out where to put my breakpoint
18:25:20 <dmj`> infinisil: oh, I had undefined as the body of test, it does prompt for IncoherentInstances
18:25:20 <dmwit> (Those two being latin-"nobody told me text was complicated"-1 and utf-"I'm just using whatever my language does for me"-8.)
18:25:34 <dmj`> geekosaur: It wasn't irrelevant, and it wasn't ignored
18:26:33 <dmj`> dmwit: didn't even consider that possibility
18:26:40 <dmj`> I'm thoroughly convinced now, thank you
18:27:29 <geekosaur> maybe the story here is some minimalist prettyprinting class should become part of base
18:27:55 <geekosaur> aside from thate veryone will promptly want changes that fit their specific use cases 
18:29:30 <infinisil> I don't see the benefit of that, one can just use a pretty printing libraring
18:29:38 <infinisil> library*
18:29:58 <geekosaur> that's what we think and everyoe else thinks should be avoided, thus wanting to override Show
18:30:27 <infinisil> Why do people think it should be avoided?
18:30:36 <lyxia> laziness
18:30:44 <infinisil> Dismissed!
18:31:14 <lyxia> or not wanting to depend on yet another library of dubious source
18:31:38 <dmj`> lyxia: laziness is ok in some cases I hear :) 
18:32:01 <lyxia> :)
18:32:02 <maerwald> "Your program is not useful, I skipped execution"
18:32:22 <geekosaur> well, actally there is a somewhat deeper problem here: once you have a typeclass yu can't override instances
18:32:33 <dmwit> I think the format is another point of contention. It turns out different people want to show their data in different ways.
18:32:49 <dmwit> Everyone thinks, "Why don't we just do X?" but each person that asks this has a slightly different value of "X".
18:33:10 <dmwit> ...which dovetails nicely with what geekosaur is currently saying. =)
18:33:10 <geekosaur> sometmes I wonder if a specal pragma could be added for "yes, allow ovrrides here but warn that the user gets to keep all the pieces". except impelmenting that could be difficult
18:33:38 <geekosaur> (the easy way, when available, is for default instance dicts to be weak symbols)
18:34:02 <nshepperd> let's move all of hackage into base
18:34:09 <infinisil> nshepperd: ^^
18:34:17 <infinisil> Um, just ^^
18:34:20 * hackage alg 0.2.9.0 - Algebraic structures  http://hackage.haskell.org/package/alg-0.2.9.0 (MatthewFarkasDyck)
18:34:22 <nshepperd> ^_^
18:34:28 <dmwit> That would certainly solve *some* problems. =)
18:35:38 <jackdk> "the stdlib is where packages go to die" -- learned experience from Python, and the dark side of "batteries included"
18:35:39 <nshepperd> with only one package, there'll be no more 'upper version bounds' debate!
18:36:04 <nshepperd> we can answer every 'is there a function in base to do X?' question with 'yes'
18:36:59 <infinisil> Unrelated, but you know what I want: package-conditioned modules. Modules from package A that only get included when a certain package B is also present in a cabal's build-depends
18:37:18 <maerwald> jackdk: well, packages harden in stdlib and should have stable API
18:37:28 <maerwald> which is already uncommon in haskell anyway
18:37:39 <dmwit> infinisil: Can't you just make those modules be a third package?
18:37:43 <infinisil> This would solve the problem of dependency bloat for packages that just provide a lot of instances for lots of types
18:37:52 <infinisil> dmwit: ^
18:37:55 <jackdk> I think we can avoid some of the problems because we slice a lot of things mathematically
18:38:10 <jackdk> but even then look at how much fun it was to live through AMP and FTP
18:38:10 <dmwit> I don't get it.
18:38:47 <jackdk> dmwit: the problem is that if you define a useful class, and want to provide instances of it for common types, either you depend on the kitchen sink
18:38:58 <jackdk> or, you have separate -instances packages and then you have orphans
18:39:13 <dmwit> Yeah. But, see, I don't consider the second situation a problem.
18:39:24 <jackdk> I do.
18:39:28 <dmwit> Why?
18:40:09 <jackdk> Because types should have at most one instance of any particular typeclass, and that way you guarantee that the same instance is used everywhere
18:40:11 <infinisil> dmwit: Take https://hackage.haskell.org/package/mono-traversable for example, it needs the bytestring dependency just to provide instances like SemiSequence ByteString
18:40:17 <infinisil> Ah yes what jackdk sais
18:40:35 <dmwit> jackdk: Sure, I understand the argument against orphan instances. But I don't buy it. In practice it doesn't bite.
18:40:55 <dmwit> Instead, in practice what you get is one canonical package that provides the extra instances, and it's authored at roughly the same time as the package that makes the new class.
18:40:58 <dmwit> So NBD
18:41:12 <jackdk> if you're lucky it's authored at around the same time
18:41:32 <jackdk> if not then you have some people using the package and others rolling their own
18:41:36 <dmwit> It's not really luck. It's all written by the same guy.
18:41:54 <infinisil> But even if we wanna go for an orphean instance route, there could then be NxM packages just providing them, one for every combination of type provider and class provider package
18:41:57 <jackdk> I don't think I'm going to say anything you haven't already heard, so I'm happy to leave the discussion here.
18:42:14 <dmwit> jackdk: How often have you tried to build something and been stopped because of two conflicting orphan instances?
18:42:53 <lyxia> I'm not sure that argument will hold since the practice of -instances packages is not that widespread
18:43:05 <nshepperd> it would be nice to have some sort of integration with ghc and cabal that would automatically import the instances module / package when the two modules are imported together
18:43:21 <nshepperd> to make using -instances packages less tedious
18:43:24 <infinisil> nshepperd: Yeah exactly, that would be nice
18:44:05 <infinisil> I'd like to have it more granular, on the package level though
18:44:24 <jackdk> dmwit: I have been slowed down by "I'm sure this thing had instances elsewhere, what did I forget to import?"
18:44:40 <dmwit> lyxia: In the long-term, I think my strategy would necessitate some kind of central registry where you could declare your orphan instances (and search for others', to avoid duplicating them).
18:45:02 <dmwit> jackdk: Ah, yeah, we could use some better tool support for that, definitely.
18:45:14 <infinisil> dmwit: Also thought of that, I doubt it will ever exist, but it would solve the problem
18:45:30 <infinisil> Well partly
18:45:38 <infinisil> Still needs to be integrated with cabal and such
18:46:02 <dmwit> I think it could be a useful thing to have without being integrated with cabal. So it could be done in stages.
18:47:00 <nshepperd> if it was a cabal extension either the class or datatype package could declare the orphan instance package for their intersection
18:47:17 * dmwit nods agreeably
18:49:27 <nshepperd> and then the orphan package could declare what module you need to import, and then cabal could just pass that as a command line flag
18:49:55 <nshepperd> then everything magically works
18:50:26 <infinisil> Yes!
18:50:54 <infinisil> I'm mainly interested in this because there are some projects that don't want to include additional dependencies because they pull too many others in
18:51:28 <nshepperd> *cough* lens *cough*
18:53:18 <infinisil> Oh boy, yeah
18:53:23 <infinisil> Great example
18:53:31 --- mode: glguy set +v pengfei
18:54:24 <jackdk> that would be greatly improved if we had Profunctor class in base
18:54:41 <jackdk> then a lightweight lens-types and lens-th might be possible for library authors
18:55:07 <nshepperd> putting all of hackage in base is the non-solution we're trying to avoid :p
18:55:42 <jackdk> not _all_ of hackage, just really useful typeclasses :-)
18:55:55 <jackdk> we already have Bifunctor
18:56:02 <infinisil> Yeah Profunctor seems reasonable to put in base
18:56:03 <dmwit> microlens has a pretty lightweight dependency tree.
18:56:17 <jackdk> without Profunctor and Choice, you can't specify prisms
18:56:23 <dmwit> And gets you most of the stuff you want, in a way that's compatible with lens in case somebody else is willing to incur the full dependency cost.
18:56:34 <jackdk> so lightweight lens libraries often represent them as Traversals
18:56:49 <jackdk> but you can't turn a Traversal around and use it as a constructor
18:56:59 <nshepperd> i mean, this is just the 'send patches to all the libraries that you have instances for' solution
18:57:03 <dmwit> Yes. You pay a small price for the benefits.
18:57:24 <nshepperd> it doesn't have to be in base to do that
20:10:15 * hackage generic-monoid 0.1.0.0 - Derive monoid instances for product types.  http://hackage.haskell.org/package/generic-monoid-0.1.0.0 (lukec)
